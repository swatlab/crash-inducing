    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1: 
58092: #include "StorageChild.h"
58092: #include "StorageParent.h"
58092: #include "nsXULAppAPI.h"
58092: using mozilla::dom::StorageChild;
58092: 
12302: #include "prnetdb.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDOMError.h"
80058: #include "nsDOMClassInfoID.h"
80058: #include "nsDOMJSUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIDocument.h"
    1: #include "nsDOMStorage.h"
13286: #include "nsEscape.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIURI.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIObserverService.h"
    1: #include "nsNetUtil.h"
    1: #include "nsICookiePermission.h"
10563: #include "nsIPermission.h"
    1: #include "nsIPermissionManager.h"
 6773: #include "nsCycleCollectionParticipant.h"
10561: #include "nsIOfflineCacheUpdate.h"
10561: #include "nsIJSContextStack.h"
25361: #include "nsIPrivateBrowsingService.h"
26323: #include "nsDOMString.h"
25361: #include "nsNetCID.h"
70840: #include "mozilla/Preferences.h"
76883: #include "nsThreadUtils.h"
83157: #include "mozilla/Telemetry.h"
91788: #include "DictionaryHelpers.h"
70840: 
81452: // calls FlushAndDeleteTemporaryTables(false)
81452: #define NS_DOMSTORAGE_FLUSH_TIMER_TOPIC "domstorage-flush-timer"
81452: 
81452: // calls FlushAndDeleteTemporaryTables(true)
81452: #define NS_DOMSTORAGE_FLUSH_FORCE_TOPIC "domstorage-flush-force"
81452: 
70840: using namespace mozilla;
    1: 
    1: static const PRUint32 ASK_BEFORE_ACCEPT = 1;
    1: static const PRUint32 ACCEPT_SESSION = 2;
    1: static const PRUint32 BEHAVIOR_REJECT = 2;
    1: 
    1: static const PRUint32 DEFAULT_QUOTA = 5 * 1024;
10561: // Be generous with offline apps by default...
10561: static const PRUint32 DEFAULT_OFFLINE_APP_QUOTA = 200 * 1024;
10561: // ... but warn if it goes over this amount
10561: static const PRUint32 DEFAULT_OFFLINE_WARN_QUOTA = 50 * 1024;
    1: 
56436: // Intervals to flush the temporary table after in seconds
56436: #define NS_DOMSTORAGE_MAXIMUM_TEMPTABLE_INACTIVITY_TIME (5)
56436: #define NS_DOMSTORAGE_MAXIMUM_TEMPTABLE_AGE (30)
56436: 
    1: static const char kPermissionType[] = "cookie";
    1: static const char kStorageEnabled[] = "dom.storage.enabled";
    1: static const char kDefaultQuota[] = "dom.storage.default_quota";
    1: static const char kCookiesBehavior[] = "network.cookie.cookieBehavior";
    1: static const char kCookiesLifetimePolicy[] = "network.cookie.lifetimePolicy";
10561: static const char kOfflineAppWarnQuota[] = "offline-apps.quota.warn";
10561: static const char kOfflineAppQuota[] = "offline-apps.quota.max";
    1: 
23579: // The URI returned is the innermost URI that should be used for
23579: // security-check-like stuff.  aHost is its hostname, correctly canonicalized.
23579: static nsresult
26323: GetPrincipalURIAndHost(nsIPrincipal* aPrincipal, nsIURI** aURI, nsCString& aHost)
23579: {
23579:   nsresult rv = aPrincipal->GetDomain(aURI);
23579:   NS_ENSURE_SUCCESS(rv, rv);
23579: 
23579:   if (!*aURI) {
23579:     rv = aPrincipal->GetURI(aURI);
23579:     NS_ENSURE_SUCCESS(rv, rv);
23579:   }
23579: 
23579:   if (!*aURI) {
23579:     return NS_OK;
23579:   }
23579: 
23579:   nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(*aURI);
23579:   if (!innerURI) {
23579:     return NS_ERROR_UNEXPECTED;
23579:   }
23579: 
26323:   rv = innerURI->GetAsciiHost(aHost);
23579:   if (NS_FAILED(rv)) {
23579:     return NS_ERROR_DOM_SECURITY_ERR;
23579:   }
23579:   
23579:   innerURI.swap(*aURI);
23579: 
23579:   return NS_OK;
23579: }
23579: 
    1: //
    1: // Helper that tells us whether the caller is secure or not.
    1: //
    1: 
79445: static bool
    1: IsCallerSecure()
    1: {
    1:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
72150:   nsresult rv = nsContentUtils::GetSecurityManager()->
    1:                   GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
80486:   NS_ENSURE_SUCCESS(rv, false);
    1: 
    1:   if (!subjectPrincipal) {
    1:     // No subject principal means no code is running. Default to not
    1:     // being secure in that case.
    1: 
80486:     return false;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> codebase;
    1:   subjectPrincipal->GetURI(getter_AddRefs(codebase));
    1: 
    1:   if (!codebase) {
80486:     return false;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> innerUri = NS_GetInnermostURI(codebase);
    1: 
    1:   if (!innerUri) {
80486:     return false;
    1:   }
    1: 
79445:   bool isHttps = false;
72150:   rv = innerUri->SchemeIs("https", &isHttps);
    1: 
    1:   return NS_SUCCEEDED(rv) && isHttps;
    1: }
    1: 
34057: PRUint32
34057: GetOfflinePermission(const nsACString &aDomain)
    1: {
10561:   // Fake a URI for the permission manager
10561:   nsCOMPtr<nsIURI> uri;
26323:   NS_NewURI(getter_AddRefs(uri), NS_LITERAL_CSTRING("http://") + aDomain);
10561: 
34057:   PRUint32 perm;
10561:   if (uri) {
10561:     nsCOMPtr<nsIPermissionManager> permissionManager =
10561:       do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
10561: 
10561:     if (permissionManager &&
34057:         NS_SUCCEEDED(permissionManager->TestPermission(uri, "offline-app", &perm)))
34057:         return perm;
34057:   }
34057: 
34057:   return nsIPermissionManager::UNKNOWN_ACTION;
34057: }
34057: 
79445: bool
34057: IsOfflineAllowed(const nsACString &aDomain)
34057: {
34057:   PRInt32 perm = GetOfflinePermission(aDomain);
34057:   return IS_PERMISSION_ALLOWED(perm);
34057: }
34057: 
34057: // Returns two quotas - A hard limit for which adding data will be an error,
34057: // and a limit after which a warning event will be sent to the observer
34057: // service.  The warn limit may be -1, in which case there will be no warning.
52374: // If aOverrideQuota is set, the larger offline apps quota is used and no
52374: // warning is sent.
34057: static PRUint32
52374: GetQuota(const nsACString &aDomain, PRInt32 *aQuota, PRInt32 *aWarnQuota,
52374:          bool aOverrideQuota)
34057: {
34057:   PRUint32 perm = GetOfflinePermission(aDomain);
52374:   if (IS_PERMISSION_ALLOWED(perm) || aOverrideQuota) {
10561:     // This is an offline app, give more space by default.
70842:     *aQuota = Preferences::GetInt(kOfflineAppQuota,
70842:                                   DEFAULT_OFFLINE_APP_QUOTA) * 1024;
10561: 
52374:     if (perm == nsIOfflineCacheUpdateService::ALLOW_NO_WARN ||
52374:         aOverrideQuota) {
10561:       *aWarnQuota = -1;
10561:     } else {
70842:       *aWarnQuota = Preferences::GetInt(kOfflineAppWarnQuota,
70842:                                         DEFAULT_OFFLINE_WARN_QUOTA) * 1024;
10561:     }
34057:     return perm;
10561:   }
10561: 
    1:   // FIXME: per-domain quotas?
70842:   *aQuota = Preferences::GetInt(kDefaultQuota, DEFAULT_QUOTA) * 1024;
10561:   *aWarnQuota = -1;
34057: 
34057:   return perm;
    1: }
    1: 
    1: nsSessionStorageEntry::nsSessionStorageEntry(KeyTypePointer aStr)
    1:   : nsStringHashKey(aStr), mItem(nsnull)
    1: {
    1: }
    1: 
    1: nsSessionStorageEntry::nsSessionStorageEntry(const nsSessionStorageEntry& aToCopy)
    1:   : nsStringHashKey(aToCopy), mItem(nsnull)
    1: {
    1:   NS_ERROR("We're horked.");
    1: }
    1: 
    1: nsSessionStorageEntry::~nsSessionStorageEntry()
    1: {
    1: }
    1: 
    1: //
    1: // nsDOMStorageManager
    1: //
    1: 
    1: nsDOMStorageManager* nsDOMStorageManager::gStorageManager;
    1: 
25361: nsDOMStorageManager::nsDOMStorageManager()
99466:   : mInPrivateBrowsing(false)
25361: {
25361: }
25361: 
83036: NS_IMPL_ISUPPORTS3(nsDOMStorageManager,
 6643:                    nsIDOMStorageManager,
83036:                    nsIObserver,
83036:                    nsISupportsWeakReference)
    1: 
    1: //static
    1: nsresult
    1: nsDOMStorageManager::Initialize()
    1: {
    1:   gStorageManager = new nsDOMStorageManager();
    1:   if (!gStorageManager)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
98908:   gStorageManager->mStorages.Init();
    1:   NS_ADDREF(gStorageManager);
    1: 
61792:   // No observers needed in non-chrome
61792:   if (XRE_GetProcessType() != GeckoProcessType_Default)
61792:     return NS_OK;
61792: 
41540:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
41540:   if (!os)
41540:     return NS_OK;
41540: 
82256:   nsresult rv;
83036:   rv = os->AddObserver(gStorageManager, "cookie-changed", true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
83036:   rv = os->AddObserver(gStorageManager, "offline-app-removed", true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
99466:   rv = os->AddObserver(gStorageManager, NS_PRIVATE_BROWSING_SWITCH_TOPIC, true);
99466:   NS_ENSURE_SUCCESS(rv, rv);
83036:   rv = os->AddObserver(gStorageManager, "profile-after-change", true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
83036:   rv = os->AddObserver(gStorageManager, "perm-changed", true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
83036:   rv = os->AddObserver(gStorageManager, "browser:purge-domain-data", true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
60667:   // Used for temporary table flushing
83036:   rv = os->AddObserver(gStorageManager, "profile-before-change", true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
83036:   rv = os->AddObserver(gStorageManager, NS_DOMSTORAGE_FLUSH_TIMER_TOPIC, true);
82256:   NS_ENSURE_SUCCESS(rv, rv);
25361: 
    1:   return NS_OK;
    1: }
    1: 
    1: //static
 6643: nsDOMStorageManager*
 6643: nsDOMStorageManager::GetInstance()
 6643: {
 6643:   NS_ASSERTION(gStorageManager,
 6643:                "nsDOMStorageManager::GetInstance() called before Initialize()");
 6643:   NS_IF_ADDREF(gStorageManager);
 6643:   return gStorageManager;
 6643: }
 6643: 
 6643: //static
    1: void
    1: nsDOMStorageManager::Shutdown()
    1: {
    1:   NS_IF_RELEASE(gStorageManager);
    1:   gStorageManager = nsnull;
 5230: 
83067:   ShutdownDB();
83067: }
83067: 
83067: //static
83067: void
83067: nsDOMStorageManager::ShutdownDB()
83067: {
58092:   delete DOMStorageImpl::gStorageDB;
58092:   DOMStorageImpl::gStorageDB = nsnull;
    1: }
    1: 
20261: static PLDHashOperator
    1: ClearStorage(nsDOMStorageEntry* aEntry, void* userArg)
    1: {
    1:   aEntry->mStorage->ClearAll();
    1:   return PL_DHASH_REMOVE;
    1: }
    1: 
59262: static PLDHashOperator
59262: ClearStorageIfDomainMatches(nsDOMStorageEntry* aEntry, void* userArg)
59262: {
59262:   nsCAutoString* aKey = static_cast<nsCAutoString*> (userArg);
59262:   if (StringBeginsWith(aEntry->mStorage->GetScopeDBKey(), *aKey)) {
59262:     aEntry->mStorage->ClearAll();
59262:   }
59262:   return PL_DHASH_REMOVE;
59262: }
59262: 
10563: static nsresult
23904: GetOfflineDomains(nsTArray<nsString>& aDomains)
10563: {
10563:   nsCOMPtr<nsIPermissionManager> permissionManager =
10563:     do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
10563:   if (permissionManager) {
10563:     nsCOMPtr<nsISimpleEnumerator> enumerator;
10563:     nsresult rv = permissionManager->GetEnumerator(getter_AddRefs(enumerator));
10563:     NS_ENSURE_SUCCESS(rv, rv);
10563: 
79445:     bool hasMore;
10563:     while (NS_SUCCEEDED(enumerator->HasMoreElements(&hasMore)) && hasMore) {
26323:       nsCOMPtr<nsISupports> supp;
26323:       rv = enumerator->GetNext(getter_AddRefs(supp));
26323:       NS_ENSURE_SUCCESS(rv, rv);
26323: 
26323:       nsCOMPtr<nsIPermission> perm(do_QueryInterface(supp, &rv));
10563:       NS_ENSURE_SUCCESS(rv, rv);
10563: 
10563:       PRUint32 capability;
10563:       rv = perm->GetCapability(&capability);
10563:       NS_ENSURE_SUCCESS(rv, rv);
10563:       if (capability != nsIPermissionManager::DENY_ACTION) {
10563:         nsCAutoString type;
10563:         rv = perm->GetType(type);
10563:         NS_ENSURE_SUCCESS(rv, rv);
10563: 
10563:         if (type.EqualsLiteral("offline-app")) {
10563:           nsCAutoString host;
10563:           rv = perm->GetHost(host);
10563:           NS_ENSURE_SUCCESS(rv, rv);
10563: 
23904:           aDomains.AppendElement(NS_ConvertUTF8toUTF16(host));
10563:         }
10563:       }
10563:     }
10563:   }
10563: 
10563:   return NS_OK;
10563: }
10563: 
    1: nsresult
    1: nsDOMStorageManager::Observe(nsISupports *aSubject,
    1:                              const char *aTopic,
    1:                              const PRUnichar *aData)
    1: {
47019:   if (!strcmp(aTopic, "profile-after-change")) {
99466:     nsCOMPtr<nsIPrivateBrowsingService> pbs =
99466:       do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
99466:     if (pbs)
99466:       pbs->GetPrivateBrowsingEnabled(&gStorageManager->mInPrivateBrowsing);
47019:   }
47019:   else if (!strcmp(aTopic, "offline-app-removed")) {
58092:     nsresult rv = DOMStorageImpl::InitDB();
10556:     NS_ENSURE_SUCCESS(rv, rv);
58092:     return DOMStorageImpl::gStorageDB->RemoveOwner(NS_ConvertUTF16toUTF8(aData),
80486:                                                    true);
10556:   } else if (!strcmp(aTopic, "cookie-changed") &&
10556:              !nsCRT::strcmp(aData, NS_LITERAL_STRING("cleared").get())) {
    1:     mStorages.EnumerateEntries(ClearStorage, nsnull);
    1: 
58092:     nsresult rv = DOMStorageImpl::InitDB();
    1:     NS_ENSURE_SUCCESS(rv, rv);
10563: 
10563:     // Remove global storage for domains that aren't marked for offline use.
23904:     nsTArray<nsString> domains;
10563:     rv = GetOfflineDomains(domains);
10563:     NS_ENSURE_SUCCESS(rv, rv);
80486:     return DOMStorageImpl::gStorageDB->RemoveOwners(domains, true, false);
99466:   } else if (!strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC)) {
99466:     mStorages.EnumerateEntries(ClearStorage, nsnull);
99466:     if (!nsCRT::strcmp(aData, NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).get()))
99466:       mInPrivateBrowsing = true;
99466:     else if (!nsCRT::strcmp(aData, NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).get()))
99466:       mInPrivateBrowsing = false;
99466:     nsresult rv = DOMStorageImpl::InitDB();
99466:     NS_ENSURE_SUCCESS(rv, rv);
99466: 
99466:     return DOMStorageImpl::gStorageDB->DropPrivateBrowsingStorages();
28495:   } else if (!strcmp(aTopic, "perm-changed")) {
28495:     // Check for cookie permission change
28495:     nsCOMPtr<nsIPermission> perm(do_QueryInterface(aSubject));
28495:     if (perm) {
28495:       nsCAutoString type;
28495:       perm->GetType(type);
28495:       if (type != NS_LITERAL_CSTRING("cookie"))
28495:         return NS_OK;
28495: 
28495:       PRUint32 cap = 0;
28495:       perm->GetCapability(&cap);
56623:       if (!(cap & nsICookiePermission::ACCESS_SESSION) ||
56623:           nsDependentString(aData) != NS_LITERAL_STRING("deleted"))
28495:         return NS_OK;
28495: 
28495:       nsCAutoString host;
28495:       perm->GetHost(host);
28495:       if (host.IsEmpty())
28495:         return NS_OK;
28495: 
58092:       nsresult rv = DOMStorageImpl::InitDB();
28495:       NS_ENSURE_SUCCESS(rv, rv);
28495: 
58092:       return DOMStorageImpl::gStorageDB->DropSessionOnlyStoragesForHost(host);
28495:     }
56436:   } else if (!strcmp(aTopic, "timer-callback")) {
56436:     nsCOMPtr<nsIObserverService> obsserv = mozilla::services::GetObserverService();
56436:     if (obsserv)
81452:       obsserv->NotifyObservers(nsnull, NS_DOMSTORAGE_FLUSH_TIMER_TOPIC, nsnull);
59262:   } else if (!strcmp(aTopic, "browser:purge-domain-data")) {
59262:     // Convert the domain name to the ACE format
59262:     nsCAutoString aceDomain;
59262:     nsresult rv;
59262:     nsCOMPtr<nsIIDNService> converter = do_GetService(NS_IDNSERVICE_CONTRACTID);
59262:     if (converter) {
59262:       rv = converter->ConvertUTF8toACE(NS_ConvertUTF16toUTF8(aData), aceDomain);
59262:       NS_ENSURE_SUCCESS(rv, rv);
59262:     } else {
59262:       // In case the IDN service is not available, this is the best we can come up with!
59262:       NS_EscapeURL(NS_ConvertUTF16toUTF8(aData),
59262:                    esc_OnlyNonASCII | esc_AlwaysCopy,
59262:                    aceDomain);
59262:     }
59262: 
59262:     nsCAutoString key;
59262:     rv = nsDOMStorageDBWrapper::CreateDomainScopeDBKey(aceDomain, key);
59262:     NS_ENSURE_SUCCESS(rv, rv);
59262: 
59262:     // Clear the storage entries for matching domains
59262:     mStorages.EnumerateEntries(ClearStorageIfDomainMatches, &key);
59262: 
59262:     rv = DOMStorageImpl::InitDB();
59262:     NS_ENSURE_SUCCESS(rv, rv);
59262: 
80486:     DOMStorageImpl::gStorageDB->RemoveOwner(aceDomain, true);
83067:   } else if (!strcmp(aTopic, "profile-before-change")) {
60667:     if (DOMStorageImpl::gStorageDB) {
81031:       DebugOnly<nsresult> rv =
81031:         DOMStorageImpl::gStorageDB->FlushAndDeleteTemporaryTables(true);
81031:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv),
81031:                        "DOMStorage: temporary table commit failed");
83067:       DOMStorageImpl::gStorageDB->Close();
83067:       nsDOMStorageManager::ShutdownDB();
60667:     }
81452:   } else if (!strcmp(aTopic, NS_DOMSTORAGE_FLUSH_TIMER_TOPIC)) {
60667:     if (DOMStorageImpl::gStorageDB) {
81031:       DebugOnly<nsresult> rv =
81031:         DOMStorageImpl::gStorageDB->FlushAndDeleteTemporaryTables(false);
81031:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv),
81031:                        "DOMStorage: temporary table commit failed");
60667:     }
81452:   } else if (!strcmp(aTopic, NS_DOMSTORAGE_FLUSH_FORCE_TOPIC)) {
81452:     if (DOMStorageImpl::gStorageDB) {
81452:       DebugOnly<nsresult> rv =
81452:         DOMStorageImpl::gStorageDB->FlushAndDeleteTemporaryTables(true);
81452:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv),
81452:                        "DOMStorage: temporary table commit failed");
81452:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 6643: NS_IMETHODIMP
 6643: nsDOMStorageManager::GetUsage(const nsAString& aDomain,
 6643:                               PRInt32 *aUsage)
 6643: {
58092:   nsresult rv = DOMStorageImpl::InitDB();
 6643:   NS_ENSURE_SUCCESS(rv, rv);
 6643: 
58092:   return DOMStorageImpl::gStorageDB->GetUsage(NS_ConvertUTF16toUTF8(aDomain),
99466:                                               false, aUsage);
 6643: }
 6643: 
10563: NS_IMETHODIMP
10563: nsDOMStorageManager::ClearOfflineApps()
10563: {
58092:     nsresult rv = DOMStorageImpl::InitDB();
10563:     NS_ENSURE_SUCCESS(rv, rv);
10563: 
23904:     nsTArray<nsString> domains;
10563:     rv = GetOfflineDomains(domains);
10563:     NS_ENSURE_SUCCESS(rv, rv);
80486:     return DOMStorageImpl::gStorageDB->RemoveOwners(domains, true, true);
26323: }
26323: 
26323: NS_IMETHODIMP
26323: nsDOMStorageManager::GetLocalStorageForPrincipal(nsIPrincipal *aPrincipal,
37608:                                                  const nsSubstring &aDocumentURI,
28438:                                                  nsIDOMStorage **aResult)
26323: {
26323:   NS_ENSURE_ARG_POINTER(aPrincipal);
26323:   *aResult = nsnull;
26323: 
26323:   nsresult rv;
26323: 
26323:   nsRefPtr<nsDOMStorage2> storage = new nsDOMStorage2();
26323:   if (!storage)
26323:     return NS_ERROR_OUT_OF_MEMORY;
26323: 
99466:   rv = storage->InitAsLocalStorage(aPrincipal, aDocumentURI);
26323:   if (NS_FAILED(rv))
26323:     return rv;
26323: 
26323:   *aResult = storage.get();
26323:   storage.forget();
26323: 
26323:   return NS_OK;
10563: }
10563: 
    1: void
58092: nsDOMStorageManager::AddToStoragesHash(DOMStorageImpl* aStorage)
    1: {
    1:   nsDOMStorageEntry* entry = mStorages.PutEntry(aStorage);
    1:   if (entry)
    1:     entry->mStorage = aStorage;
    1: }
    1: 
    1: void
58092: nsDOMStorageManager::RemoveFromStoragesHash(DOMStorageImpl* aStorage)
    1: {
    1:   nsDOMStorageEntry* entry = mStorages.GetEntry(aStorage);
    1:   if (entry)
    1:     mStorages.RemoveEntry(aStorage);
    1: }
    1: 
    1: //
    1: // nsDOMStorage
    1: //
    1: 
58092: nsDOMStorageDBWrapper* DOMStorageImpl::gStorageDB = nsnull;
    1: 
    1: nsDOMStorageEntry::nsDOMStorageEntry(KeyTypePointer aStr)
93686:   : nsPtrHashKey<const void>(aStr), mStorage(nsnull)
    1: {
    1: }
    1: 
    1: nsDOMStorageEntry::nsDOMStorageEntry(const nsDOMStorageEntry& aToCopy)
93686:   : nsPtrHashKey<const void>(aToCopy), mStorage(nsnull)
    1: {
    1:   NS_ERROR("DOMStorage horked.");
    1: }
    1: 
    1: nsDOMStorageEntry::~nsDOMStorageEntry()
    1: {
    1: }
    1: 
58092: NS_IMPL_CYCLE_COLLECTION_1(nsDOMStorage, mStorageImpl)
 6773: 
40490: DOMCI_DATA(StorageObsolete, nsDOMStorage)
40490: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMStorage)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMStorage)
 6773: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMStorage)
28438:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMStorageObsolete)
28438:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageObsolete)
    1:   NS_INTERFACE_MAP_ENTRY(nsPIDOMStorage)
28438:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StorageObsolete)
    1: NS_INTERFACE_MAP_END
    1: 
46997: nsresult
28676: NS_NewDOMStorage2(nsISupports* aOuter, REFNSIID aIID, void** aResult)
28676: {
28676:   nsDOMStorage2* storage = new nsDOMStorage2();
28676:   return storage->QueryInterface(aIID, aResult);
    1: }
    1: 
58092: DOMStorageBase::DOMStorageBase()
58092:   : mStorageType(nsPIDOMStorage::Unknown)
80486:   , mUseDB(false)
80486:   , mSessionOnly(true)
52374:   , mCanUseChromePersist(false)
    1: {
    1: }
    1: 
58092: DOMStorageBase::DOMStorageBase(DOMStorageBase& aThat)
58092:   : mStorageType(aThat.mStorageType)
80486:   , mUseDB(false) // Clones don't use the DB
80486:   , mSessionOnly(true)
37833:   , mDomain(aThat.mDomain)
26323:   , mScopeDBKey(aThat.mScopeDBKey)
58092:   , mQuotaETLDplus1DomainDBKey(aThat.mQuotaETLDplus1DomainDBKey)
58092:   , mQuotaDomainDBKey(aThat.mQuotaDomainDBKey)
52374:   , mCanUseChromePersist(aThat.mCanUseChromePersist)
    1: {
    1: }
    1: 
58092: void
99466: DOMStorageBase::InitAsSessionStorage(nsIURI* aDomainURI)
    1: {
28736:   // No need to check for a return value. If this would fail we would not get
28736:   // here as we call GetPrincipalURIAndHost (nsDOMStorage.cpp:88) from
28736:   // nsDOMStorage::CanUseStorage before we query the storage manager for a new
28736:   // sessionStorage. It calls GetAsciiHost on innermost URI. If it fails, we
28736:   // won't get to InitAsSessionStorage.
58092:   aDomainURI->GetAsciiHost(mDomain);
37608: 
80486:   mUseDB = false;
28676:   mScopeDBKey.Truncate();
28676:   mQuotaDomainDBKey.Truncate();
58092:   mStorageType = nsPIDOMStorage::SessionStorage;
28676: }
28676: 
58092: void
58092: DOMStorageBase::InitAsLocalStorage(nsIURI* aDomainURI,
99466:                                    bool aCanUseChromePersist)
    1: {
26323:   // No need to check for a return value. If this would fail we would not get
26323:   // here as we call GetPrincipalURIAndHost (nsDOMStorage.cpp:88) from
26323:   // nsDOMStorage::CanUseStorage before we query the storage manager for a new
26323:   // localStorage. It calls GetAsciiHost on innermost URI. If it fails, we won't
26323:   // get to InitAsLocalStorage. Actually, mDomain will get replaced with
26323:   // mPrincipal in bug 455070. It is not even used for localStorage.
58092:   aDomainURI->GetAsciiHost(mDomain);
37608: 
58092:   nsDOMStorageDBWrapper::CreateOriginScopeDBKey(aDomainURI, mScopeDBKey);
26323: 
26323:   // XXX Bug 357323, we have to solve the issue how to define
26323:   // origin for file URLs. In that case CreateOriginScopeDBKey
26323:   // fails (the result is empty) and we must avoid database use
26323:   // in that case because it produces broken entries w/o owner.
26323:   mUseDB = !mScopeDBKey.IsEmpty();
26323: 
34057:   nsDOMStorageDBWrapper::CreateQuotaDomainDBKey(mDomain,
80486:                                                 true, false, mQuotaDomainDBKey);
34057:   nsDOMStorageDBWrapper::CreateQuotaDomainDBKey(mDomain,
80486:                                                 true, true, mQuotaETLDplus1DomainDBKey);
58092:   mCanUseChromePersist = aCanUseChromePersist;
58092:   mStorageType = nsPIDOMStorage::LocalStorage;
52374: }
52374: 
58092: PLDHashOperator
58092: SessionStorageTraverser(nsSessionStorageEntry* aEntry, void* userArg) {
58092:   nsCycleCollectionTraversalCallback *cb = 
58092:       static_cast<nsCycleCollectionTraversalCallback*>(userArg);
58092: 
58092:   cb->NoteXPCOMChild((nsIDOMStorageItem *) aEntry->mItem);
28820: 
28820:   return PL_DHASH_NEXT;
28820: }
28820: 
58092: NS_IMPL_CYCLE_COLLECTION_CLASS(DOMStorageImpl)
58092: NS_IMPL_CYCLE_COLLECTION_UNLINK_0(DOMStorageImpl)
58092: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(DOMStorageImpl)
58092: {
58092:   if (tmp->mItems.IsInitialized()) {
58092:     tmp->mItems.EnumerateEntries(SessionStorageTraverser, &cb);
58092:   }
58092: }
58092: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
58092: 
60667: NS_IMPL_CYCLE_COLLECTING_ADDREF(DOMStorageImpl)
60667: NS_IMPL_CYCLE_COLLECTING_RELEASE(DOMStorageImpl)
58092: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(DOMStorageImpl)
99466:   NS_INTERFACE_MAP_ENTRY(nsISupports)
58092: NS_INTERFACE_MAP_END
58092: 
58092: DOMStorageImpl::DOMStorageImpl(nsDOMStorage* aStorage)
58092: {
58092:   Init(aStorage);
58092: }
58092: 
58092: DOMStorageImpl::DOMStorageImpl(nsDOMStorage* aStorage, DOMStorageImpl& aThat)
58092:   : DOMStorageBase(aThat)
58092: {
58092:   Init(aStorage);
58092: }
58092: 
58092: void
58092: DOMStorageImpl::Init(nsDOMStorage* aStorage)
58092: {
78721:   mItemsCachedVersion = 0;
58092:   mItems.Init(8);
58092:   mOwner = aStorage;
58092:   if (nsDOMStorageManager::gStorageManager)
58092:     nsDOMStorageManager::gStorageManager->AddToStoragesHash(this);
58092: }
58092: 
58092: DOMStorageImpl::~DOMStorageImpl()
58092: {
58092:   if (nsDOMStorageManager::gStorageManager)
58092:     nsDOMStorageManager::gStorageManager->RemoveFromStoragesHash(this);
58092: }
58092: 
28820: nsresult
58092: DOMStorageImpl::InitDB()
    1: {
    1:   if (!gStorageDB) {
28495:     gStorageDB = new nsDOMStorageDBWrapper();
    1:     if (!gStorageDB)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsresult rv = gStorageDB->Init();
    1:     if (NS_FAILED(rv)) {
    1:       // Failed to initialize the DB, delete it and null out the
    1:       // pointer so we don't end up attempting to use an
    1:       // un-initialized DB later on.
    1: 
    1:       delete gStorageDB;
    1:       gStorageDB = nsnull;
    1: 
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
58092: void
58092: DOMStorageImpl::InitFromChild(bool aUseDB, bool aCanUseChromePersist,
99466:                               bool aSessionOnly, const nsACString& aDomain,
58092:                               const nsACString& aScopeDBKey,
58092:                               const nsACString& aQuotaDomainDBKey,
58092:                               const nsACString& aQuotaETLDplus1DomainDBKey,
58092:                               PRUint32 aStorageType)
58092: {
58092:   mUseDB = aUseDB;
58092:   mCanUseChromePersist = aCanUseChromePersist;
60073:   mSessionOnly = aSessionOnly;
58092:   mDomain = aDomain;
58092:   mScopeDBKey = aScopeDBKey;
58092:   mQuotaDomainDBKey = aQuotaDomainDBKey;
58092:   mQuotaETLDplus1DomainDBKey = aQuotaETLDplus1DomainDBKey;
58092:   mStorageType = static_cast<nsPIDOMStorage::nsDOMStorageType>(aStorageType);
60073: }
60073: 
60073: void
60073: DOMStorageImpl::SetSessionOnly(bool aSessionOnly)
60073: {
60073:   mSessionOnly = aSessionOnly;
58092: }
58092: 
58092: void
99466: DOMStorageImpl::InitAsSessionStorage(nsIURI* aDomainURI)
58092: {
99466:   DOMStorageBase::InitAsSessionStorage(aDomainURI);
58092: }
58092: 
58092: void
58092: DOMStorageImpl::InitAsLocalStorage(nsIURI* aDomainURI,
99466:                                    bool aCanUseChromePersist)
58092: {
99466:   DOMStorageBase::InitAsLocalStorage(aDomainURI, aCanUseChromePersist);
58092: }
58092: 
58092: bool
58092: DOMStorageImpl::CacheStoragePermissions()
58092: {
58092:   // If this is a cross-process situation, we don't have a real storage owner.
58092:   // All the correct checks have been done on the child, so we just need to
58092:   // make sure that our session-only status is correctly updated.
58092:   if (!mOwner)
99466:     return nsDOMStorage::CanUseStorage(&mSessionOnly);
58092:   
58092:   return mOwner->CacheStoragePermissions();
58092: }
58092: 
58092: bool
58092: DOMStorageImpl::CanUseChromePersist()
58092: {
58092:   return mCanUseChromePersist;
58092: }
58092: 
    1: nsresult
58092: DOMStorageImpl::GetCachedValue(const nsAString& aKey, nsAString& aValue,
79445:                                bool* aSecure)
56436: {
56436:   aValue.Truncate();
80486:   *aSecure = false;
56436: 
56436:   nsSessionStorageEntry *entry = mItems.GetEntry(aKey);
56436:   if (!entry)
56436:     return NS_ERROR_NOT_AVAILABLE;
56436: 
56436:   aValue = entry->mItem->GetValueInternal();
56436:   *aSecure = entry->mItem->IsSecure();
56436: 
56436:   return NS_OK;
56436: }
56436: 
56436: nsresult
58092: DOMStorageImpl::GetDBValue(const nsAString& aKey, nsAString& aValue,
79445:                            bool* aSecure)
    1: {
    1:   aValue.Truncate();
    1: 
    1:   if (!UseDB())
    1:     return NS_OK;
    1: 
    1:   nsresult rv = InitDB();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString value;
26323:   rv = gStorageDB->GetKeyValue(this, aKey, value, aSecure);
26323: 
91477:   if (rv == NS_ERROR_DOM_NOT_FOUND_ERR) {
26323:     SetDOMStringToNull(aValue);
26323:   }
26323: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   aValue.Assign(value);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
58092: DOMStorageImpl::SetDBValue(const nsAString& aKey,
    1:                            const nsAString& aValue,
79445:                            bool aSecure)
    1: {
    1:   if (!UseDB())
    1:     return NS_OK;
    1: 
    1:   nsresult rv = InitDB();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34057:   PRInt32 offlineAppPermission;
10561:   PRInt32 quota;
10561:   PRInt32 warnQuota;
52374:   offlineAppPermission = GetQuota(mDomain, &quota, &warnQuota,
52374:                                   CanUseChromePersist());
10561: 
87797:   CacheKeysFromDB();
87797: 
10561:   PRInt32 usage;
34057:   rv = gStorageDB->SetKey(this, aKey, aValue, aSecure, quota,
34057:                          !IS_PERMISSION_ALLOWED(offlineAppPermission),
34057:                          &usage);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10561:   if (warnQuota >= 0 && usage > warnQuota) {
10561:     // try to include the window that exceeded the warn quota
10561:     nsCOMPtr<nsIDOMWindow> window;
10561:     JSContext *cx;
10561:     nsCOMPtr<nsIJSContextStack> stack =
10561:         do_GetService("@mozilla.org/js/xpc/ContextStack;1");
10561:     if (stack && NS_SUCCEEDED(stack->Peek(&cx)) && cx) {
10561:       nsCOMPtr<nsIScriptContext> scriptContext;
10561:       scriptContext = GetScriptContextFromJSContext(cx);
10561:       if (scriptContext) {
10561:         window = do_QueryInterface(scriptContext->GetGlobalObject());
10561:       }
10561:     }
10561: 
41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
10561:     os->NotifyObservers(window, "dom-storage-warn-quota-exceeded",
34057:                        NS_ConvertUTF8toUTF16(mDomain).get());
10561:   }
10561: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
79445: DOMStorageImpl::SetSecure(const nsAString& aKey, bool aSecure)
    1: {
    1:   if (UseDB()) {
    1:     nsresult rv = InitDB();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
26323:     return gStorageDB->SetSecure(this, aKey, aSecure);
    1:   }
    1: 
    1:   nsSessionStorageEntry *entry = mItems.GetEntry(aKey);
42587:   NS_ASSERTION(entry, "Don't use SetSecure() with nonexistent keys!");
    1: 
    1:   if (entry) {
    1:     entry->mItem->SetSecureInternal(aSecure);
    1:   }  
    1: 
    1:   return NS_OK;
    1: }
    1: 
20261: static PLDHashOperator
    1: ClearStorageItem(nsSessionStorageEntry* aEntry, void* userArg)
    1: {
    1:   aEntry->mItem->SetValueInternal(EmptyString());
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
58092: DOMStorageImpl::ClearAll()
    1: {
    1:   mItems.EnumerateEntries(ClearStorageItem, nsnull);
78721:   mItemsCachedVersion = 0;
    1: }
    1: 
58092: struct CopyArgs {
58092:   DOMStorageImpl* storage;
58092:   bool callerSecure;
58092: };
58092: 
58092: static PLDHashOperator
58092: CopyStorageItems(nsSessionStorageEntry* aEntry, void* userArg)
58092: {
58092:   // When copying items from one impl to another, we may not
58092:   // have an mOwner that we can call SetItem on. Therefore we need
58092:   // to replicate its behaviour.
58092:   
58092:   CopyArgs* args = static_cast<CopyArgs*>(userArg);
58092: 
58092:   nsAutoString unused;
58092:   nsresult rv = args->storage->SetValue(args->callerSecure, aEntry->GetKey(),
58092:                                         aEntry->mItem->GetValueInternal(), unused);
58092:   if (NS_FAILED(rv))
58092:     return PL_DHASH_NEXT;
58092: 
58092:   if (aEntry->mItem->IsSecure()) {
80486:     args->storage->SetSecure(aEntry->GetKey(), true);
58092:   }
58092: 
58092:   return PL_DHASH_NEXT;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::CloneFrom(bool aCallerSecure, DOMStorageBase* aThat)
58092: {
58092:   // For various reasons, we no longer call SetItem in CopyStorageItems,
58092:   // so we need to ensure that the storage permissions are correct.
58092:   if (!CacheStoragePermissions())
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092:   
58092:   DOMStorageImpl* that = static_cast<DOMStorageImpl*>(aThat);
58092:   CopyArgs args = { this, aCallerSecure };
58092:   that->mItems.EnumerateEntries(CopyStorageItems, &args);
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::CacheKeysFromDB()
58092: {
58092:   // cache all the keys in the hash. This is used by the Length and Key methods
58092:   // use this cache for better performance. The disadvantage is that the
58092:   // order may break if someone changes the keys in the database directly.
78721:   if (gStorageDB->IsScopeDirty(this)) {
58092:     nsresult rv = InitDB();
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092: 
58092:     mItems.Clear();
58092: 
58092:     rv = gStorageDB->GetAllKeys(this, &mItems);
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092: 
78721:     gStorageDB->MarkScopeCached(this);
58092:   }
58092: 
58092:   return NS_OK;
58092: }
58092: 
58092: struct KeysArrayBuilderStruct
58092: {
79445:   bool callerIsSecure;
58092:   nsTArray<nsString> *keys;
58092: };
58092: 
58092: static PLDHashOperator
58092: KeysArrayBuilder(nsSessionStorageEntry* aEntry, void* userArg)
58092: {
58092:   KeysArrayBuilderStruct *keystruct = (KeysArrayBuilderStruct *)userArg;
58092:   
58092:   if (keystruct->callerIsSecure || !aEntry->mItem->IsSecure())
58092:     keystruct->keys->AppendElement(aEntry->GetKey());
58092: 
58092:   return PL_DHASH_NEXT;
58092: }
58092: 
58092: nsTArray<nsString>*
58092: DOMStorageImpl::GetKeys(bool aCallerSecure)
58092: {
58092:   if (UseDB())
58092:     CacheKeysFromDB();
58092: 
58092:   KeysArrayBuilderStruct keystruct;
58092:   keystruct.callerIsSecure = aCallerSecure;
58092:   keystruct.keys = new nsTArray<nsString>();
58092:   if (keystruct.keys)
58092:     mItems.EnumerateEntries(KeysArrayBuilder, &keystruct);
58092:  
58092:   return keystruct.keys;
58092: }
58092: 
58092: class ItemCounterState
58092: {
58092:  public:
79445:   ItemCounterState(bool aIsCallerSecure)
58092:   : mIsCallerSecure(aIsCallerSecure), mCount(0)
58092:   {
58092:   }
58092: 
79445:   bool mIsCallerSecure;
74667:   PRUint32 mCount;
58092:  private:
58092:   ItemCounterState(); // Not to be implemented
58092: };
58092: 
58092: static PLDHashOperator
58092: ItemCounter(nsSessionStorageEntry* aEntry, void* userArg)
58092: {
58092:   ItemCounterState *state = (ItemCounterState *)userArg;
58092: 
58092:   if (state->mIsCallerSecure || !aEntry->mItem->IsSecure()) {
58092:     ++state->mCount;
58092:   }
58092: 
58092:   return PL_DHASH_NEXT;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::GetLength(bool aCallerSecure, PRUint32* aLength)
58092: {
58092:   // Force reload of items from database.  This ensures sync localStorages for
58092:   // same origins among different windows.
58092:   if (UseDB())
58092:     CacheKeysFromDB();
58092: 
58092:   ItemCounterState state(aCallerSecure);
58092: 
58092:   mItems.EnumerateEntries(ItemCounter, &state);
58092: 
58092:   *aLength = state.mCount;
58092:   return NS_OK;
58092: }
58092: 
58092: class IndexFinderData
58092: {
58092:  public:
79445:   IndexFinderData(bool aIsCallerSecure, PRUint32 aWantedIndex)
58092:   : mIsCallerSecure(aIsCallerSecure), mIndex(0), mWantedIndex(aWantedIndex),
58092:     mItem(nsnull)
58092:   {
58092:   }
58092: 
79445:   bool mIsCallerSecure;
58092:   PRUint32 mIndex;
58092:   PRUint32 mWantedIndex;
58092:   nsSessionStorageEntry *mItem;
58092: 
58092:  private:
58092:   IndexFinderData(); // Not to be implemented
58092: };
58092: 
58092: static PLDHashOperator
58092: IndexFinder(nsSessionStorageEntry* aEntry, void* userArg)
58092: {
58092:   IndexFinderData *data = (IndexFinderData *)userArg;
58092: 
58092:   if (data->mIndex == data->mWantedIndex &&
58092:       (data->mIsCallerSecure || !aEntry->mItem->IsSecure())) {
58092:     data->mItem = aEntry;
58092: 
58092:     return PL_DHASH_STOP;
58092:   }
58092: 
58092:   ++data->mIndex;
58092: 
58092:   return PL_DHASH_NEXT;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::GetKey(bool aCallerSecure, PRUint32 aIndex, nsAString& aKey)
58092: {
58092:   // XXX: This does a linear search for the key at index, which would
58092:   // suck if there's a large numer of indexes. Do we care? If so,
58092:   // maybe we need to have a lazily populated key array here or
58092:   // something?
58092: 
74829:   if (UseDB()) {
58092:     CacheKeysFromDB();
74829:   }
58092: 
58092:   IndexFinderData data(aCallerSecure, aIndex);
58092:   mItems.EnumerateEntries(IndexFinder, &data);
58092: 
58092:   if (!data.mItem) {
94360:     // aIndex was larger than the number of accessible keys. Return null.
94360:     aKey.SetIsVoid(true);
94360:     return NS_OK;
58092:   }
58092: 
58092:   aKey = data.mItem->GetKey();
58092:   return NS_OK;
58092: }
58092: 
58092: // The behaviour of this function must be kept in sync with StorageChild::GetValue.
58092: // See the explanatory comment there for more details.
58092: nsIDOMStorageItem*
58092: DOMStorageImpl::GetValue(bool aCallerSecure, const nsAString& aKey,
58092:                          nsresult* aResult)
58092: {
58092:   nsSessionStorageEntry *entry = mItems.GetEntry(aKey);
58092:   nsIDOMStorageItem* item = nsnull;
58092:   if (entry) {
58092:     if (aCallerSecure || !entry->mItem->IsSecure()) {
58092:       item = entry->mItem;
58092:     }
58092:   }
58092:   else if (UseDB()) {
79445:     bool secure;
58092:     nsAutoString value;
58092:     nsresult rv = GetDBValue(aKey, value, &secure);
58092:     // return null if access isn't allowed or the key wasn't found
58092:     if (rv == NS_ERROR_DOM_SECURITY_ERR || rv == NS_ERROR_DOM_NOT_FOUND_ERR ||
58092:         (!aCallerSecure && secure))
58092:       return nsnull;
58092: 
58092:     *aResult = rv;
58092:     NS_ENSURE_SUCCESS(rv, nsnull);
58092: 
58092:     nsRefPtr<nsDOMStorageItem> newitem =
58092:         new nsDOMStorageItem(this, aKey, value, secure);
58092:     if (newitem && (entry = mItems.PutEntry(aKey))) {
58092:       item = entry->mItem = newitem;
58092:     }
58092:     else {
58092:       *aResult = NS_ERROR_OUT_OF_MEMORY;
58092:     }
58092:   }
58092:   return item;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::SetValue(bool aIsCallerSecure, const nsAString& aKey,
58092:                          const nsAString& aData, nsAString& aOldValue)
58092: {
58092:   nsresult rv;
58092:   nsString oldValue;
58092:   SetDOMStringToNull(oldValue);
58092: 
58092:   // First store the value to the database, we need to do this before we update
58092:   // the mItems cache.  SetDBValue is using the old cached value to decide
58092:   // on quota checking.
58092:   if (UseDB()) {
58092:     rv = SetDBValue(aKey, aData, aIsCallerSecure);
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:   }
58092: 
58092:   nsSessionStorageEntry *entry = mItems.GetEntry(aKey);
58092:   if (entry) {
58092:     if (entry->mItem->IsSecure() && !aIsCallerSecure) {
58092:       return NS_ERROR_DOM_SECURITY_ERR;
58092:     }
58092:     oldValue = entry->mItem->GetValueInternal();
58092:     entry->mItem->SetValueInternal(aData);
58092:   }
58092:   else {
58092:     nsRefPtr<nsDOMStorageItem> newitem =
58092:         new nsDOMStorageItem(this, aKey, aData, aIsCallerSecure);
58092:     if (!newitem)
58092:       return NS_ERROR_OUT_OF_MEMORY;
58092:     entry = mItems.PutEntry(aKey);
58092:     NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
58092:     entry->mItem = newitem;
58092:   }
58092:   aOldValue = oldValue;
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::RemoveValue(bool aCallerSecure, const nsAString& aKey,
58092:                             nsAString& aOldValue)
58092: {
58092:   nsString oldValue;
58092:   nsSessionStorageEntry *entry = mItems.GetEntry(aKey);
58092: 
58092:   if (entry && entry->mItem->IsSecure() && !aCallerSecure) {
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092:   }
58092: 
58092:   if (UseDB()) {
58092:     nsresult rv = InitDB();
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092: 
96925:     CacheKeysFromDB();
96998:     entry = mItems.GetEntry(aKey);
96925: 
58092:     nsAutoString value;
79445:     bool secureItem;
58092:     rv = GetDBValue(aKey, value, &secureItem);
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:     if (!aCallerSecure && secureItem)
58092:       return NS_ERROR_DOM_SECURITY_ERR;
58092: 
58092:     oldValue = value;
58092: 
58092:     rv = gStorageDB->RemoveKey(this, aKey, !IsOfflineAllowed(mDomain),
58092:                                aKey.Length() + value.Length());
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:   }
58092:   else if (entry) {
58092:     // clear string as StorageItems may be referencing this item
58092:     oldValue = entry->mItem->GetValueInternal();
58092:     entry->mItem->ClearValue();
58092:   }
58092: 
58092:   if (entry) {
58092:     mItems.RawRemoveEntry(entry);
58092:   }
58092:   aOldValue = oldValue;
58092:   return NS_OK;
58092: }
58092: 
58092: PR_STATIC_CALLBACK(PLDHashOperator)
58092: CheckSecure(nsSessionStorageEntry* aEntry, void* userArg)
58092: {
79445:   bool* secure = (bool*)userArg;
58092:   if (aEntry->mItem->IsSecure()) {
80486:     *secure = true;
58092:     return PL_DHASH_STOP;
58092:   }
58092: 
58092:   return PL_DHASH_NEXT;
58092: }
58092: 
58092: nsresult
58092: DOMStorageImpl::Clear(bool aCallerSecure, PRInt32* aOldCount)
58092: {
58092:   if (UseDB())
58092:     CacheKeysFromDB();
58092: 
58092:   PRInt32 oldCount = mItems.Count();
58092: 
79445:   bool foundSecureItem = false;
58092:   mItems.EnumerateEntries(CheckSecure, &foundSecureItem);
58092: 
58092:   if (foundSecureItem && !aCallerSecure) {
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092:   }
58092: 
58092:   if (UseDB()) {
58092:     nsresult rv = InitDB();
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092: 
58092:     rv = gStorageDB->ClearStorage(this);
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:   }
58092: 
58092:   *aOldCount = oldCount;
58092:   mItems.Clear();
58092:   return NS_OK;
58092: }
58092: 
58092: nsDOMStorage::nsDOMStorage()
58092:   : mStorageType(nsPIDOMStorage::Unknown)
58092:   , mEventBroadcaster(nsnull)
58092: {
58092:   if (XRE_GetProcessType() != GeckoProcessType_Default)
58092:     mStorageImpl = new StorageChild(this);
58092:   else
58092:     mStorageImpl = new DOMStorageImpl(this);
58092: }
58092: 
58092: nsDOMStorage::nsDOMStorage(nsDOMStorage& aThat)
58092:   : mStorageType(aThat.mStorageType)
94224:   , mPrincipal(aThat.mPrincipal)
58092:   , mEventBroadcaster(nsnull)
58092: {
58092:   if (XRE_GetProcessType() != GeckoProcessType_Default) {
58092:     StorageChild* other = static_cast<StorageChild*>(aThat.mStorageImpl.get());
58092:     mStorageImpl = new StorageChild(this, *other);
67579:   } else {
58092:     DOMStorageImpl* other = static_cast<DOMStorageImpl*>(aThat.mStorageImpl.get());
58092:     mStorageImpl = new DOMStorageImpl(this, *other);
58092:   }
58092: }
58092: 
58092: nsDOMStorage::~nsDOMStorage()
58092: {
58092: }
58092: 
58092: static
58092: nsresult
79445: GetDomainURI(nsIPrincipal *aPrincipal, bool aIncludeDomain, nsIURI **_domain)
58092: {
58092:   nsCOMPtr<nsIURI> uri;
58092: 
58092:   if (aIncludeDomain) {
58092:     nsresult rv = aPrincipal->GetDomain(getter_AddRefs(uri));
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:   }
58092: 
58092:   if (!uri) {
58092:     nsresult rv = aPrincipal->GetURI(getter_AddRefs(uri));
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:   }
58092: 
58092:   // Check if we really got any URI. System principal doesn't return a URI
58092:   // instance and we would crash in NS_GetInnermostURI below.
58092:   if (!uri)
58092:     return NS_ERROR_NOT_AVAILABLE;
58092: 
58092:   nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(uri);
58092:   if (!innerURI)
58092:     return NS_ERROR_UNEXPECTED;
58092:   innerURI.forget(_domain);
58092: 
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
99466: nsDOMStorage::InitAsSessionStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI)
58092: {
58092:   nsCOMPtr<nsIURI> domainURI;
80486:   nsresult rv = GetDomainURI(aPrincipal, true, getter_AddRefs(domainURI));
58092:   NS_ENSURE_SUCCESS(rv, rv);
58092: 
58092:   mDocumentURI = aDocumentURI;
94224:   mPrincipal = aPrincipal;
58092: 
58092:   mStorageType = SessionStorage;
58092: 
99466:   mStorageImpl->InitAsSessionStorage(domainURI);
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
99466: nsDOMStorage::InitAsLocalStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI)
58092: {
58092:   nsCOMPtr<nsIURI> domainURI;
80486:   nsresult rv = GetDomainURI(aPrincipal, false, getter_AddRefs(domainURI));
58092:   NS_ENSURE_SUCCESS(rv, rv);
58092: 
58092:   mDocumentURI = aDocumentURI;
94224:   mPrincipal = aPrincipal;
58092: 
58092:   mStorageType = LocalStorage;
58092: 
58092:   bool canUseChromePersist = false;
58092:   nsCOMPtr<nsIURI> URI;
58092:   if (NS_SUCCEEDED(aPrincipal->GetURI(getter_AddRefs(URI))) && URI) {
58092:     canUseChromePersist = URICanUseChromePersist(URI);
58092:   }
58092:   
99466:   mStorageImpl->InitAsLocalStorage(domainURI, canUseChromePersist);
58092:   return NS_OK;
58092: }
58092: 
58092: //static
79445: bool
99466: nsDOMStorage::CanUseStorage(bool* aSessionOnly)
58092: {
58092:   // check if the calling domain can use storage. Downgrade to session
58092:   // only if only session storage may be used.
99466:   NS_ASSERTION(aSessionOnly, "null session flag");
99466:   *aSessionOnly = false;
58092: 
70840:   if (!Preferences::GetBool(kStorageEnabled)) {
80486:     return false;
70840:   }
58092: 
58092:   // chrome can always use storage regardless of permission preferences
58092:   if (nsContentUtils::IsCallerChrome())
80486:     return true;
58092: 
58092:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
72150:   nsresult rv = nsContentUtils::GetSecurityManager()->
58092:                   GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
80486:   NS_ENSURE_SUCCESS(rv, false);
58092: 
58092:   // if subjectPrincipal were null we'd have returned after
58092:   // IsCallerChrome().
58092: 
58092:   nsCOMPtr<nsIURI> subjectURI;
58092:   nsCAutoString unused;
58092:   if (NS_FAILED(GetPrincipalURIAndHost(subjectPrincipal,
58092:                                        getter_AddRefs(subjectURI),
58092:                                        unused))) {
80486:     return false;
58092:   }
58092: 
58092:   nsCOMPtr<nsIPermissionManager> permissionManager =
58092:     do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
58092:   if (!permissionManager)
80486:     return false;
58092: 
58092:   PRUint32 perm;
58092:   permissionManager->TestPermission(subjectURI, kPermissionType, &perm);
58092: 
58092:   if (perm == nsIPermissionManager::DENY_ACTION)
80486:     return false;
58092: 
58092:   // In private browsing mode we ougth to behave as in session-only cookies
58092:   // mode to prevent detection of being in private browsing mode and ensuring
58092:   // that there will be no traces left.
58092:   if (perm == nsICookiePermission::ACCESS_SESSION ||
99466:       nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode()) {
99466:     *aSessionOnly = true;
58092:   }
58092:   else if (perm != nsIPermissionManager::ALLOW_ACTION) {
70842:     PRUint32 cookieBehavior = Preferences::GetUint(kCookiesBehavior);
70842:     PRUint32 lifetimePolicy = Preferences::GetUint(kCookiesLifetimePolicy);
58092: 
58092:     // Treat "ask every time" as "reject always".
58092:     // Chrome persistent pages can bypass this check.
58092:     if ((cookieBehavior == BEHAVIOR_REJECT || lifetimePolicy == ASK_BEFORE_ACCEPT) &&
58092:         !URICanUseChromePersist(subjectURI))
80486:       return false;
58092: 
99466:     if (lifetimePolicy == ACCEPT_SESSION)
99466:       *aSessionOnly = true;
58092:   }
58092: 
80486:   return true;
58092: }
58092: 
79445: bool
58092: nsDOMStorage::CacheStoragePermissions()
58092: {
58092:   // Bug 488446, disallowing storage use when in session only mode.
58092:   // This is temporary fix before we find complete solution for storage
58092:   // behavior in private browsing mode or session-only cookies mode.
99466:   if (!CanUseStorage(&mStorageImpl->mSessionOnly))
80486:     return false;
58092: 
58092:   nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
58092:   if (!ssm)
80486:     return false;
58092: 
58092:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
72150:   nsresult rv = ssm->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
80486:   NS_ENSURE_SUCCESS(rv, false);
58092: 
94224:   return CanAccess(subjectPrincipal);
58092: }
58092: 
58092: // static
79445: bool
58092: nsDOMStorage::URICanUseChromePersist(nsIURI* aURI) {
79445:   bool isAbout;
58092:   return
58092:     (NS_SUCCEEDED(aURI->SchemeIs("moz-safe-about", &isAbout)) && isAbout) ||
58092:     (NS_SUCCEEDED(aURI->SchemeIs("about", &isAbout)) && isAbout);
58092: }
58092: 
58092: NS_IMETHODIMP
58092: nsDOMStorage::GetLength(PRUint32 *aLength)
58092: {
58092:   if (!CacheStoragePermissions())
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092:   
58092:   return mStorageImpl->GetLength(IsCallerSecure(), aLength);
58092: }
58092: 
58092: NS_IMETHODIMP
58092: nsDOMStorage::Key(PRUint32 aIndex, nsAString& aKey)
58092: {
58092:   if (!CacheStoragePermissions())
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092: 
58092:   return mStorageImpl->GetKey(IsCallerSecure(), aIndex, aKey);
58092: }
58092: 
58092: nsIDOMStorageItem*
58092: nsDOMStorage::GetNamedItem(const nsAString& aKey, nsresult* aResult)
58092: {
58092:   if (!CacheStoragePermissions()) {
58092:     *aResult = NS_ERROR_DOM_SECURITY_ERR;
58092:     return nsnull;
58092:   }
58092: 
58092:   *aResult = NS_OK;
58092:   return mStorageImpl->GetValue(IsCallerSecure(), aKey, aResult);
58092: }
58092: 
58092: nsresult
58092: nsDOMStorage::GetItem(const nsAString& aKey, nsAString &aData)
58092: {
58092:   nsresult rv;
58092: 
58092:   // IMPORTANT:
58092:   // CacheStoragePermissions() is called inside of
58092:   // GetItem(nsAString, nsIDOMStorageItem)
58092:   // To call it particularly in this method would just duplicate
58092:   // the call. If the code changes, make sure that call to
58092:   // CacheStoragePermissions() is put here!
58092: 
58092:   nsCOMPtr<nsIDOMStorageItem> item;
58092:   rv = GetItem(aKey, getter_AddRefs(item));
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092: 
58092:   if (item) {
58092:     rv = item->GetValue(aData);
58092:     NS_ENSURE_SUCCESS(rv, rv);
58092:   }
58092:   else
58092:     SetDOMStringToNull(aData);
58092: 
58092:   return NS_OK;
58092: }
58092: 
83157: static Telemetry::ID
83157: TelemetryIDForKey(nsPIDOMStorage::nsDOMStorageType type)
83157: {
83157:   switch (type) {
83157:   default:
83157:     MOZ_ASSERT(false);
83157:     // We need to return something to satisfy the compiler.
83157:     // Fallthrough.
83157:   case nsPIDOMStorage::LocalStorage:
83157:     return Telemetry::LOCALDOMSTORAGE_KEY_SIZE_BYTES;
83157:   case nsPIDOMStorage::SessionStorage:
83157:     return Telemetry::SESSIONDOMSTORAGE_KEY_SIZE_BYTES;
83157:   }
83157: }
83157: 
83157: static Telemetry::ID
83157: TelemetryIDForValue(nsPIDOMStorage::nsDOMStorageType type)
83157: {
83157:   switch (type) {
83157:   default:
83157:     MOZ_ASSERT(false);
83157:     // We need to return something to satisfy the compiler.
83157:     // Fallthrough.
83157:   case nsPIDOMStorage::LocalStorage:
83157:     return Telemetry::LOCALDOMSTORAGE_VALUE_SIZE_BYTES;
83157:   case nsPIDOMStorage::SessionStorage:
83157:     return Telemetry::SESSIONDOMSTORAGE_VALUE_SIZE_BYTES;
83157:   }
83157: }
83157: 
58092: NS_IMETHODIMP
58092: nsDOMStorage::GetItem(const nsAString& aKey, nsIDOMStorageItem **aItem)
58092: {
58092:   nsresult rv;
58092: 
58092:   NS_IF_ADDREF(*aItem = GetNamedItem(aKey, &rv));
58092: 
58092:   return rv;
58092: }
58092: 
58092: NS_IMETHODIMP
58092: nsDOMStorage::SetItem(const nsAString& aKey, const nsAString& aData)
58092: {
58092:   if (!CacheStoragePermissions())
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092: 
83157:   Telemetry::Accumulate(TelemetryIDForKey(mStorageType), aKey.Length());
83157:   Telemetry::Accumulate(TelemetryIDForValue(mStorageType), aData.Length());
83157: 
58092:   nsString oldValue;
58092:   nsresult rv = mStorageImpl->SetValue(IsCallerSecure(), aKey, aData, oldValue);
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092: 
91477:   if (oldValue != aData && mEventBroadcaster)
58092:     mEventBroadcaster->BroadcastChangeNotification(aKey, oldValue, aData);
58092: 
58092:   return NS_OK;
58092: }
58092: 
58092: NS_IMETHODIMP nsDOMStorage::RemoveItem(const nsAString& aKey)
58092: {
58092:   if (!CacheStoragePermissions())
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092: 
58092:   nsString oldValue;
58092:   nsresult rv = mStorageImpl->RemoveValue(IsCallerSecure(), aKey, oldValue);
58092:   if (rv == NS_ERROR_DOM_NOT_FOUND_ERR)
58092:     return NS_OK;
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092: 
91477:   if (!oldValue.IsEmpty() && mEventBroadcaster) {
58092:     nsAutoString nullString;
58092:     SetDOMStringToNull(nullString);
58092:     mEventBroadcaster->BroadcastChangeNotification(aKey, oldValue, nullString);
58092:   }
58092: 
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
58092: nsDOMStorage::Clear()
58092: {
58092:   if (!CacheStoragePermissions())
58092:     return NS_ERROR_DOM_SECURITY_ERR;
58092: 
58092:   PRInt32 oldCount;
58092:   nsresult rv = mStorageImpl->Clear(IsCallerSecure(), &oldCount);
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092:   
58092:   if (oldCount && mEventBroadcaster) {
58092:     nsAutoString nullString;
58092:     SetDOMStringToNull(nullString);
58092:     mEventBroadcaster->BroadcastChangeNotification(nullString, nullString, nullString);
58092:   }
58092: 
58092:   return NS_OK;
58092: }
58092: 
28676: already_AddRefed<nsIDOMStorage>
23579: nsDOMStorage::Clone()
    1: {
80486:   NS_ASSERTION(false, "Old DOMStorage doesn't implement cloning");
    1:   return nsnull;
    1: }
    1: 
37608: already_AddRefed<nsIDOMStorage>
37608: nsDOMStorage::Fork(const nsSubstring &aDocumentURI)
37608: {
80486:   NS_ASSERTION(false, "Old DOMStorage doesn't implement forking");
37608:   return nsnull;
37608: }
37608: 
79445: bool nsDOMStorage::IsForkOf(nsIDOMStorage* aThat)
37608: {
80486:   NS_ASSERTION(false, "Old DOMStorage doesn't implement forking");
80486:   return false;
37608: }
37608: 
58092: nsresult
58092: nsDOMStorage::CloneFrom(nsDOMStorage* aThat)
    1: {
58092:   return mStorageImpl->CloneFrom(IsCallerSecure(), aThat->mStorageImpl);
    1: }
    1: 
    1: nsTArray<nsString> *
    1: nsDOMStorage::GetKeys()
    1: {
58092:   return mStorageImpl->GetKeys(IsCallerSecure());
    1: }
    1: 
28676: nsIPrincipal*
28676: nsDOMStorage::Principal()
23579: {
28676:   return nsnull;
23579: }
23579: 
79445: bool
26323: nsDOMStorage::CanAccessSystem(nsIPrincipal *aPrincipal)
23579: {
23579:   if (!aPrincipal)
80486:     return true;
23579: 
23579:   nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
23579:   if (!ssm)
80486:     return false;
23579: 
79445:   bool isSystem;
28758:   nsresult rv = ssm->IsSystemPrincipal(aPrincipal, &isSystem);
23579: 
28758:   return NS_SUCCEEDED(rv) && isSystem;
26323: }
26323: 
79445: bool
26323: nsDOMStorage::CanAccess(nsIPrincipal *aPrincipal)
26323: {
94224:   // Allow C++ callers to access the storage
94224:   if (!aPrincipal)
80486:     return true;
26323: 
94224:   // Allow more powerful principals (e.g. system) to access the storage
94224:   bool subsumes;
94224:   nsresult rv = aPrincipal->SubsumesIgnoringDomain(mPrincipal, &subsumes);
94224:   if (NS_FAILED(rv))
94224:     return false;
94224: 
94224:   return subsumes;
23579: }
23579: 
37608: nsPIDOMStorage::nsDOMStorageType
37608: nsDOMStorage::StorageType()
37608: {
37608:   return mStorageType;
37608: }
37608: 
26323: //
26323: // nsDOMStorage2
26323: //
26323: 
26323: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMStorage2)
26323: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMStorage2)
26323:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mStorage)
26323: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
26323: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDOMStorage2)
28438:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mStorage, nsIDOMStorageObsolete)
26323: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
26323: 
40490: DOMCI_DATA(Storage, nsDOMStorage2)
40490: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMStorage2)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMStorage2)
26323: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMStorage2)
28438:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMStorage)
28438:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorage)
26323:   NS_INTERFACE_MAP_ENTRY(nsPIDOMStorage)
28438:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Storage)
26323: NS_INTERFACE_MAP_END
26323: 
28676: nsDOMStorage2::nsDOMStorage2()
28676: {
28676: }
28676: 
28676: nsDOMStorage2::nsDOMStorage2(nsDOMStorage2& aThat)
28676: {
28676:   mStorage = new nsDOMStorage(*aThat.mStorage.get());
28676:   mPrincipal = aThat.mPrincipal;
28676: }
28676: 
28676: nsresult
99466: nsDOMStorage2::InitAsSessionStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI)
28676: {
28676:   mStorage = new nsDOMStorage();
28676:   if (!mStorage)
28676:     return NS_ERROR_OUT_OF_MEMORY;
28676: 
28676:   mPrincipal = aPrincipal;
37608:   mDocumentURI = aDocumentURI;
37608: 
99466:   return mStorage->InitAsSessionStorage(aPrincipal, aDocumentURI);
28676: }
28676: 
26323: nsresult
99466: nsDOMStorage2::InitAsLocalStorage(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI)
26323: {
26323:   mStorage = new nsDOMStorage();
26323:   if (!mStorage)
26323:     return NS_ERROR_OUT_OF_MEMORY;
26323: 
26323:   mPrincipal = aPrincipal;
37608:   mDocumentURI = aDocumentURI;
37608: 
99466:   return mStorage->InitAsLocalStorage(aPrincipal, aDocumentURI);
26323: }
26323: 
28676: already_AddRefed<nsIDOMStorage>
26323: nsDOMStorage2::Clone()
26323: {
28676:   nsDOMStorage2* storage = new nsDOMStorage2(*this);
28676:   if (!storage)
26323:     return nsnull;
28676: 
28820:   storage->mStorage->CloneFrom(mStorage);
28676:   NS_ADDREF(storage);
28676: 
28676:   return storage;
26323: }
26323: 
37608: already_AddRefed<nsIDOMStorage>
37608: nsDOMStorage2::Fork(const nsSubstring &aDocumentURI)
37608: {
37608:   nsRefPtr<nsDOMStorage2> storage = new nsDOMStorage2();
97753:   storage->InitAsSessionStorageFork(mPrincipal, aDocumentURI, mStorage);
97753:   return storage.forget();
37608: }
37608: 
79445: bool nsDOMStorage2::IsForkOf(nsIDOMStorage* aThat)
37608: {
37608:   if (!aThat)
80486:     return false;
37608: 
37608:   nsDOMStorage2* storage = static_cast<nsDOMStorage2*>(aThat);
37608:   return mStorage == storage->mStorage;
37608: }
37608: 
97753: void
97753: nsDOMStorage2::InitAsSessionStorageFork(nsIPrincipal *aPrincipal, const nsSubstring &aDocumentURI, nsDOMStorage* aStorage)
37608: {
37608:   mPrincipal = aPrincipal;
37608:   mDocumentURI = aDocumentURI;
97753:   mStorage = aStorage;
37608: }
37608: 
26323: nsTArray<nsString> *
26323: nsDOMStorage2::GetKeys()
26323: {
26323:   return mStorage->GetKeys();
26323: }
26323: 
28676: nsIPrincipal*
28676: nsDOMStorage2::Principal()
26323: {
28676:   return mPrincipal;
26323: }
26323: 
79445: bool
26323: nsDOMStorage2::CanAccess(nsIPrincipal *aPrincipal)
26323: {
94224:   return mStorage->CanAccess(aPrincipal);
26323: }
26323: 
37608: nsPIDOMStorage::nsDOMStorageType
37608: nsDOMStorage2::StorageType()
37608: {
37608:   if (mStorage)
37608:     return mStorage->StorageType();
37608: 
37608:   return nsPIDOMStorage::Unknown;
37608: }
37608: 
76883: namespace {
76883: 
76883: class StorageNotifierRunnable : public nsRunnable
76883: {
76883: public:
76883:   StorageNotifierRunnable(nsISupports* aSubject)
76883:     : mSubject(aSubject)
76883:   { }
76883: 
76883:   NS_DECL_NSIRUNNABLE
76883: 
76883: private:
76883:   nsCOMPtr<nsISupports> mSubject;
76883: };
76883: 
76883: NS_IMETHODIMP
76883: StorageNotifierRunnable::Run()
76883: {
76883:   nsCOMPtr<nsIObserverService> observerService =
76883:     mozilla::services::GetObserverService();
76883:   if (observerService) {
76883:     observerService->NotifyObservers(mSubject, "dom-storage2-changed", nsnull);
76883:   }
76883:   return NS_OK;
76883: }
76883: 
76883: } // anonymous namespace
76883: 
37608: void
37608: nsDOMStorage2::BroadcastChangeNotification(const nsSubstring &aKey,
37608:                                            const nsSubstring &aOldValue,
37608:                                            const nsSubstring &aNewValue)
37608: {
37608:   nsresult rv;
37608:   nsCOMPtr<nsIDOMStorageEvent> event = new nsDOMStorageEvent();
37608:   rv = event->InitStorageEvent(NS_LITERAL_STRING("storage"),
80486:                                false,
80486:                                false,
37608:                                aKey,
37608:                                aOldValue,
37608:                                aNewValue,
37608:                                mDocumentURI,
37608:                                static_cast<nsIDOMStorage*>(this));
37608:   if (NS_FAILED(rv)) {
37608:     return;
37608:   }
37608: 
76883:   nsRefPtr<StorageNotifierRunnable> r = new StorageNotifierRunnable(event);
76883:   NS_DispatchToMainThread(r);
37608: }
37608: 
26323: NS_IMETHODIMP
26323: nsDOMStorage2::GetLength(PRUint32 *aLength)
26323: {
26323:   return mStorage->GetLength(aLength);
26323: }
26323: 
26323: NS_IMETHODIMP
26323: nsDOMStorage2::Key(PRUint32 aIndex, nsAString& aKey)
26323: {
26323:   return mStorage->Key(aIndex, aKey);
26323: }
26323: 
26323: NS_IMETHODIMP
26323: nsDOMStorage2::GetItem(const nsAString& aKey, nsAString &aData)
26323: {
26323:   return mStorage->GetItem(aKey, aData);
26323: }
26323: 
26323: NS_IMETHODIMP
26323: nsDOMStorage2::SetItem(const nsAString& aKey, const nsAString& aData)
26323: {
37608:   mStorage->mEventBroadcaster = this;
26323:   return mStorage->SetItem(aKey, aData);
26323: }
26323: 
26323: NS_IMETHODIMP
26323: nsDOMStorage2::RemoveItem(const nsAString& aKey)
26323: {
37608:   mStorage->mEventBroadcaster = this;
26323:   return mStorage->RemoveItem(aKey);
26323: }
26323: 
26323: NS_IMETHODIMP
26323: nsDOMStorage2::Clear()
26323: {
37608:   mStorage->mEventBroadcaster = this;
26323:   return mStorage->Clear();
    1: }
    1: 
    1: //
    1: // nsDOMStorageItem
    1: //
    1: 
 6773: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMStorageItem)
 6773: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMStorageItem)
 6773:   {
 6773:     tmp->mStorage = nsnull;
 6773:   }
 6773: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 6773: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDOMStorageItem)
 6773:   {
99466:     cb.NoteXPCOMChild((nsISupports*) tmp->mStorage);
 6773:   }
 6773: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 6773: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMStorageItem)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMStorageItem)
40490: 
40490: DOMCI_DATA(StorageItem, nsDOMStorageItem)
40490: 
 6773: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMStorageItem)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMStorageItem)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageItem)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMToString)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StorageItem)
    1: NS_INTERFACE_MAP_END
    1: 
58092: nsDOMStorageItem::nsDOMStorageItem(DOMStorageBase* aStorage,
    1:                                    const nsAString& aKey,
    1:                                    const nsAString& aValue,
79445:                                    bool aSecure)
    1:   : mSecure(aSecure),
    1:     mKey(aKey),
    1:     mValue(aValue),
    1:     mStorage(aStorage)
    1: {
    1: }
    1: 
    1: nsDOMStorageItem::~nsDOMStorageItem()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDOMStorageItem::GetSecure(bool* aSecure)
    1: {
    1:   if (!mStorage->CacheStoragePermissions() || !IsCallerSecure()) {
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1:   }
    1: 
    1:   if (mStorage->UseDB()) {
    1:     nsAutoString value;
26323:     return mStorage->GetDBValue(mKey, value, aSecure);
    1:   }
    1: 
    1:   *aSecure = IsSecure();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDOMStorageItem::SetSecure(bool aSecure)
    1: {
    1:   if (!mStorage->CacheStoragePermissions() || !IsCallerSecure()) {
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1:   }
    1: 
    1:   if (mStorage->UseDB()) {
    1:     nsresult rv = mStorage->SetSecure(mKey, aSecure);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   mSecure = aSecure;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStorageItem::GetValue(nsAString& aValue)
    1: {
    1:   if (!mStorage->CacheStoragePermissions())
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1: 
    1:   if (mStorage->UseDB()) {
79445:     bool secure;
26323:     nsresult rv = mStorage->GetDBValue(mKey, aValue, &secure);
26323:     if (rv == NS_ERROR_DOM_NOT_FOUND_ERR)
26323:       return NS_OK;
58092:     if (NS_SUCCEEDED(rv) && !IsCallerSecure() && secure)
58092:       return NS_ERROR_DOM_SECURITY_ERR;
26323:     return rv;
    1:   }
    1: 
    1:   if (IsSecure() && !IsCallerSecure()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1:   }
    1: 
    1:   aValue = mValue;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStorageItem::SetValue(const nsAString& aValue)
    1: {
    1:   if (!mStorage->CacheStoragePermissions())
    1:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
    1: 
79445:   bool secureCaller = IsCallerSecure();
    1: 
    1:   if (mStorage->UseDB()) {
    1:     // SetDBValue() does the security checks for us.
    1:     return mStorage->SetDBValue(mKey, aValue, secureCaller);
    1:   }
    1: 
79445:   bool secureItem = IsSecure();
    1: 
    1:   if (!secureCaller && secureItem) {
    1:     // The item is secure, but the caller isn't. Throw.
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1:   }
    1: 
    1:   mValue = aValue;
    1:   mSecure = secureCaller;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStorageItem::ToString(nsAString& aStr)
    1: {
    1:   return GetValue(aStr);
    1: }
    1: 
42550: // Cycle collection implementation for nsDOMStorageEvent
42550: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMStorageEvent)
42550: 
42550: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMStorageEvent, nsDOMEvent)
42550:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mStorageArea)
42550: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
42550: 
42550: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMStorageEvent, nsDOMEvent)
42550:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStorageArea)
42550: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
42550: 
42550: NS_IMPL_ADDREF_INHERITED(nsDOMStorageEvent, nsDOMEvent)
42550: NS_IMPL_RELEASE_INHERITED(nsDOMStorageEvent, nsDOMEvent)
42550: 
40490: DOMCI_DATA(StorageEvent, nsDOMStorageEvent)
40490: 
    1: // QueryInterface implementation for nsDOMStorageEvent
42550: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMStorageEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageEvent)
    1:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StorageEvent)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)
    1: 
    1: 
37608: /* readonly attribute DOMString key; */
37608: NS_IMETHODIMP nsDOMStorageEvent::GetKey(nsAString & aKey)
37608: {
37608:   aKey = mKey;
37608:   return NS_OK;
37608: }
37608: 
37608: /* readonly attribute DOMString oldValue; */
37608: NS_IMETHODIMP nsDOMStorageEvent::GetOldValue(nsAString & aOldValue)
37608: {
37608:   aOldValue = mOldValue;
37608:   return NS_OK;
37608: }
37608: 
37608: /* readonly attribute DOMString newValue; */
37608: NS_IMETHODIMP nsDOMStorageEvent::GetNewValue(nsAString & aNewValue)
37608: {
37608:   aNewValue = mNewValue;
37608:   return NS_OK;
37608: }
37608: 
37608: /* readonly attribute DOMString url; */
37608: NS_IMETHODIMP nsDOMStorageEvent::GetUrl(nsAString & aUrl)
37608: {
37608:   aUrl = mUrl;
37608:   return NS_OK;
37608: }
37608: 
37608: /* readonly attribute nsIDOMStorage storageArea; */
37608: NS_IMETHODIMP nsDOMStorageEvent::GetStorageArea(nsIDOMStorage * *aStorageArea)
37608: {
37608:   NS_ENSURE_ARG_POINTER(aStorageArea);
37608: 
91994:   NS_IF_ADDREF(*aStorageArea = mStorageArea);
37608:   return NS_OK;
37608: }
37608: 
37608: /* void initStorageEvent (in DOMString typeArg, in boolean canBubbleArg, in boolean cancelableArg, in DOMString keyArg, in DOMString oldValueArg, in DOMString newValueArg, in DOMString urlArg, in nsIDOMStorage storageAreaArg); */
37608: NS_IMETHODIMP nsDOMStorageEvent::InitStorageEvent(const nsAString & typeArg,
79445:                                                   bool canBubbleArg,
79445:                                                   bool cancelableArg,
37608:                                                   const nsAString & keyArg,
37608:                                                   const nsAString & oldValueArg,
37608:                                                   const nsAString & newValueArg,
37608:                                                   const nsAString & urlArg,
37608:                                                   nsIDOMStorage *storageAreaArg)
37608: {
37608:   nsresult rv;
37608: 
37608:   rv = InitEvent(typeArg, canBubbleArg, cancelableArg);
37608:   NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:   mKey = keyArg;
37608:   mOldValue = oldValueArg;
37608:   mNewValue = newValueArg;
37608:   mUrl = urlArg;
37608:   mStorageArea = storageAreaArg;
37608: 
37608:   return NS_OK;
37608: }
37608: 
91788: nsresult
91788: nsDOMStorageEvent::InitFromCtor(const nsAString& aType,
91788:                                 JSContext* aCx, jsval* aVal)
91788: {
91788:   mozilla::dom::StorageEventInit d;
91788:   nsresult rv = d.Init(aCx, aVal);
91788:   NS_ENSURE_SUCCESS(rv, rv);
91788:   return InitStorageEvent(aType, d.bubbles, d.cancelable, d.key, d.oldValue,
91788:                           d.newValue, d.url, d.storageArea);
91788: }
