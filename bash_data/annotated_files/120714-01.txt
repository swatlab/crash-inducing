 59571: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43032: 
 43032: package org.mozilla.gecko;
 43032: 
 96816: import org.mozilla.gecko.gfx.ImmutableViewportMetrics;
107125: import org.mozilla.gecko.gfx.IntSize;
 83777: import org.mozilla.gecko.gfx.LayerView;
107125: import org.mozilla.gecko.gfx.RectUtils;
 96816: import org.mozilla.gecko.gfx.ScreenshotLayer;
107152: import org.mozilla.gecko.mozglue.DirectBufferAllocator;
107150: import org.mozilla.gecko.util.FloatUtils;
118414: import org.mozilla.gecko.PrefsHelper;
107125: 
107125: import android.graphics.Rect;
107125: import android.graphics.RectF;
107125: import android.opengl.GLES20;
107125: import android.util.FloatMath;
114929: import android.util.Log;
 83777: 
106885: import java.nio.ByteBuffer;
106885: import java.util.Iterator;
106885: import java.util.LinkedList;
106885: import java.util.Queue;
105629: 
114416: public final class ScreenshotHandler implements Runnable {
105670:     public static final int SCREENSHOT_THUMBNAIL = 0;
105670:     public static final int SCREENSHOT_CHECKERBOARD = 1;
 96816: 
118414:     private static final String SCREENSHOT_DISABLED_PREF = "gfx.java.screenshot.enabled";
118414: 
105670:     private static final String LOGTAG = "GeckoScreenshotHandler";
105670:     private static final int BYTES_FOR_16BPP = 2;
105670:     private static final int MAX_PIXELS_PER_SLICE = 100000;
 96816: 
120714:     private static boolean sDisableScreenshot = true;
118414:     private static boolean sForceDisabled;
105670:     private static ScreenshotHandler sInstance;
105670: 
105670:     private final int mMaxTextureSize;
105670:     private final int mMinTextureSize;
105670:     private final int mMaxPixels;
105670: 
105670:     private final Queue<PendingScreenshot> mPendingScreenshots;
114929:     private ByteBuffer mBuffer;
105670:     private int mBufferWidth;
105670:     private int mBufferHeight;
105670:     private RectF mPageRect;
105670:     private float mWidthRatio;
105670:     private float mHeightRatio;
105670: 
105670:     private int mTabId;
105670:     private RectF mDirtyRect;
105670:     private boolean mIsRepaintRunnablePosted;
105670: 
105670:     private static synchronized ScreenshotHandler getInstance() {
114929:         if (sDisableScreenshot) {
114929:             return null;
114929:         }
105670:         if (sInstance == null) {
105670:             try {
105670:                 sInstance = new ScreenshotHandler();
105670:             } catch (UnsupportedOperationException e) {
114929:                 // initialization failed, fall through and return null.
114929:                 // also set the disable flag so we don't try again.
114929:                 sDisableScreenshot = true;
105670:             }
105670:         }
105670:         return sInstance;
 94805:     }
 96816: 
105670:     private ScreenshotHandler() {
105670:         int[] maxTextureSize = new int[1];
105670:         GLES20.glGetIntegerv(GLES20.GL_MAX_TEXTURE_SIZE, maxTextureSize, 0);
105670:         mMaxTextureSize = maxTextureSize[0];
105670:         if (mMaxTextureSize == 0) {
105670:             throw new UnsupportedOperationException();
 96816:         }
105670:         mMaxPixels = Math.min(ScreenshotLayer.getMaxNumPixels(), mMaxTextureSize * mMaxTextureSize);
105670:         mMinTextureSize = (int)Math.ceil(mMaxPixels / mMaxTextureSize);
105670:         mPendingScreenshots = new LinkedList<PendingScreenshot>();
107152:         mBuffer = DirectBufferAllocator.allocate(mMaxPixels * BYTES_FOR_16BPP);
105670:         mDirtyRect = new RectF();
105670:         clearDirtyRect();
118414:         PrefsHelper.getPref(SCREENSHOT_DISABLED_PREF,
118414:              new PrefsHelper.PrefHandlerBase() {
118414:                   @Override public void prefValue(String pref, boolean value) {
118414:                       if (SCREENSHOT_DISABLED_PREF.equals(pref) && !value)
118414:                           disableScreenshot(true);
118414:                   }
118414:              }
118414:             );
 96880:     }
 96880: 
114929:     private void cleanup() {
115943:         synchronized (mPendingScreenshots) {
115943:             if (mPendingScreenshots.isEmpty()) {
115943:                 // no screenshots are pending, its safe to free the buffer
115943:                 mBuffer = DirectBufferAllocator.free(mBuffer);
115943:             } else {
114929:                 discardPendingScreenshots();
115943:                 mBuffer = null;
115943:             }
115943:         }
114929:     }
114929: 
 98440:     // Invoked via reflection from robocop test
114929:     public static synchronized void disableScreenshot() {
118414:         disableScreenshot(true);
118414:     }
118414: 
118414:     // Invoked via reflection from robocop test
118414:     public static synchronized void disableScreenshot(boolean forced) {
114929:         if (sDisableScreenshot) {
118414:             if (!sForceDisabled)
118414:                 sForceDisabled = forced;
114929:             return;
114929:         }
118414: 
118414:         sForceDisabled = forced;
118414: 
 98440:         sDisableScreenshot = true;
114929:         if (sInstance != null) {
114929:             sInstance.cleanup();
114929:             sInstance = null;
114929:         }
114929:         Log.i(LOGTAG, "Screenshotting disabled");
114929:     }
114929: 
118414:     public static synchronized void enableScreenshot(boolean forced) {
118414:         if (!sDisableScreenshot || (sForceDisabled && !forced)) {
114929:             return;
114929:         }
114929:         sDisableScreenshot = false;
118414:         sForceDisabled = false;
114929:         Log.i(LOGTAG, "Screenshotting enabled");
 98440:     }
 98440: 
 96816:     public static void screenshotWholePage(Tab tab) {
114929:         if (GeckoApp.mAppContext.isApplicationInBackground()) {
105670:             return;
105670:         }
105670:         ScreenshotHandler handler = getInstance();
105670:         if (handler == null) {
105670:             return;
105670:         }
105670: 
105670:         handler.screenshotWholePage(tab.getId());
105670:     }
105670: 
114929:     private void discardPendingScreenshots() {
114929:         synchronized (mPendingScreenshots) {
114929:             for (Iterator<PendingScreenshot> i = mPendingScreenshots.iterator(); i.hasNext(); ) {
114929:                 i.next().discard();
114929:             }
114929:         }
114929:     }
114929: 
105670:     private void screenshotWholePage(int tabId) {
108841:         LayerView layerView = GeckoApp.mAppContext.getLayerView();
108841:         if (layerView == null) {
105670:             return;
105670:         }
108841:         ImmutableViewportMetrics viewport = layerView.getViewportMetrics();
105670:         RectF pageRect = viewport.getCssPageRect();
105670: 
105670:         if (FloatUtils.fuzzyEquals(pageRect.width(), 0) || FloatUtils.fuzzyEquals(pageRect.height(), 0)) {
105670:             return;
105670:         }
105670: 
105670:         synchronized (this) {
105670:             // if we're doing a full-page screenshot, toss any
105670:             // dirty rects we have saved up and reset the tab id.
105670:             mTabId = tabId;
105670:             clearDirtyRect();
105670:         }
114929:         discardPendingScreenshots();
105670: 
105670:         int dstx = 0;
105670:         int dsty = 0;
105670:         float bestZoomFactor = (float)Math.sqrt(pageRect.width() * pageRect.height() / mMaxPixels);
105670:         int dstw = IntSize.largestPowerOfTwoLessThan(pageRect.width() / bestZoomFactor);
105670:         // clamp with min texture size so that the height doesn't exceed the sMaxTextureSize
105670:         dstw = clamp(mMinTextureSize, dstw, mMaxTextureSize);
105670:         int dsth = mMaxPixels / dstw;
105670: 
105670:         mPageRect = pageRect;
105670:         mBufferWidth = dstw;
105670:         mBufferHeight = dsth;
105670:         mWidthRatio = dstw / pageRect.width();
105670:         mHeightRatio = dsth / pageRect.height();
105670: 
105670:         scheduleCheckerboardScreenshotEvent(pageRect, dstx, dsty, dstw, dsth);
105670:     }
105670: 
105670:     private static int clamp(int min, int val, int max) {
105670:         return Math.max(Math.min(max, val), min);
105670:     }
105670: 
114416:     // Called from native code by JNI
105670:     public static void notifyPaintedRect(float top, float left, float bottom, float right) {
105670:         ScreenshotHandler handler = getInstance();
105670:         if (handler == null) {
 97659:             return;
 96880:         }
101992: 
105670:         handler.notifyPageUpdated(top, left, bottom, right);
101181:     }
101315: 
105670:     private void notifyPageUpdated(float top, float left, float bottom, float right) {
105670:         synchronized (this) {
105670:             if (mPageRect == null || Tabs.getInstance().getSelectedTab().getId() != mTabId) {
105670:                 // if mPageRect is null, we haven't done a full-page
105670:                 // screenshot yet (or screenshotWholePage failed for some reason),
105670:                 // so ignore partial updates. also if the tab changed, ignore
105670:                 // partial updates until we do the next whole-page screenshot.
101992:                 return;
105670:             }
105670:             mDirtyRect.top = Math.max(mPageRect.top, Math.min(top, mDirtyRect.top));
105670:             mDirtyRect.left = Math.max(mPageRect.left, Math.min(left, mDirtyRect.left));
105670:             mDirtyRect.bottom = Math.min(mPageRect.bottom, Math.max(bottom, mDirtyRect.bottom));
105670:             mDirtyRect.right = Math.min(mPageRect.right, Math.max(right, mDirtyRect.right));
105670:             if (!mIsRepaintRunnablePosted) {
105670:                 GeckoAppShell.getHandler().postDelayed(this, 5000);
105670:                 mIsRepaintRunnablePosted = true;
105670:             }
105670:         }
105670:     }
105670: 
105670:     private void clearDirtyRect() {
105670:         mDirtyRect.set(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY,
105670:                        Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);
105670:     }
105670: 
105670:     public void run() {
105670:         // make a copy of the dirty rect to work with so we can keep
105670:         // accumulating new dirty rects.
105670:         RectF dirtyRect = new RectF();
105670:         synchronized (this) {
105670:             dirtyRect.set(mDirtyRect);
105670:             clearDirtyRect();
105670:             mIsRepaintRunnablePosted = false;
105670:         }
105670: 
105670:         if (dirtyRect.width() <= 0 || dirtyRect.height() <= 0) {
105670:             // we have nothing in the dirty rect, so nothing to do
105670:             return;
105670:         }
105670: 
105670:         Tab selectedTab = Tabs.getInstance().getSelectedTab();
105670:         if (selectedTab == null || selectedTab.getId() != mTabId) {
105670:             // tab changed, so bail out before we start screenshotting
105670:             // the wrong tab. note we must do this *after* resetting
105670:             // mIsRepaintRunnablePosted above.
105670:             return;
105670:         }
105670: 
108841:         LayerView layerView = GeckoApp.mAppContext.getLayerView();
108841:         if (layerView == null) {
105670:             // we could be in the midst of an activity tear-down and re-start, so guard
108841:             // against a null layer view
105670:             return;
105670:         }
105670: 
108841:         ImmutableViewportMetrics viewport = layerView.getViewportMetrics();
105670:         if (RectUtils.fuzzyEquals(mPageRect, viewport.getCssPageRect())) {
105670:             // the page size hasn't changed, so our dirty rect is still valid and we can just
105670:             // repaint that area
105670:             int dstx = (int)(mWidthRatio * (dirtyRect.left - viewport.cssPageRectLeft));
105670:             int dsty = (int)(mHeightRatio * (dirtyRect.top - viewport.cssPageRectTop));
105670:             int dstw = (int)(mWidthRatio * dirtyRect.width());
105670:             int dsth = (int)(mHeightRatio * dirtyRect.height());
105670:             scheduleCheckerboardScreenshotEvent(dirtyRect, dstx, dsty, dstw, dsth);
105670:         } else {
105670:             // the page size changed, so we need to re-screenshot the whole page
105670:             screenshotWholePage(mTabId);
105670:         }
105670:     }
105670: 
105670:     private void scheduleCheckerboardScreenshotEvent(RectF srcRect, int dstx, int dsty, int dstw, int dsth) {
105670:         int numSlices = (int)FloatMath.ceil(srcRect.width() * srcRect.height() / MAX_PIXELS_PER_SLICE);
105670:         if (numSlices == 0 || dstw == 0 || dsth == 0) {
105670:             return;
105670:         }
105670: 
105670:         PendingScreenshot pending = new PendingScreenshot(mTabId);
105670:         int sliceDstH = Math.max(1, dsth / numSlices);
105670:         float sliceSrcH = sliceDstH * srcRect.height() / dsth;
105670:         float srcY = srcRect.top;
105670:         for (int i = 0; i < dsth; i += sliceDstH) {
105670:             if (i + sliceDstH > dsth) {
105670:                 // the last slice may be smaller to account for rounding error.
105670:                 sliceDstH = dsth - i;
105670:                 sliceSrcH = sliceDstH * srcRect.height() / dsth;
105670:             }
105670:             GeckoEvent event = GeckoEvent.createScreenshotEvent(mTabId,
105670:                 (int)srcRect.left, (int)srcY, (int)srcRect.width(), (int)sliceSrcH,
105670:                 dstx, dsty + i, dstw, sliceDstH,
105670:                 mBufferWidth, mBufferHeight, SCREENSHOT_CHECKERBOARD, mBuffer);
105670:             srcY += sliceSrcH;
105670:             pending.addEvent(event);
105670:         }
105670:         synchronized (mPendingScreenshots) {
105670:             mPendingScreenshots.add(pending);
105670:             if (mPendingScreenshots.size() == 1) {
101992:                 sendNextEventToGecko();
101180:             }
101315:         }
101992:     }
101992: 
105670:     private void sendNextEventToGecko() {
105670:         synchronized (mPendingScreenshots) {
105670:             while (!mPendingScreenshots.isEmpty()) {
105670:                 // some of the pending screenshots may have been discard()ed
105670:                 // so keep looping until we find a real one
105670:                 if (mPendingScreenshots.element().sendNextEventToGecko()) {
105670:                     break;
101992:                 }
105670:                 mPendingScreenshots.remove();
101992:             }
101992:         }
101992:     }
101992: 
114416:     // Called from native code by JNI
115943:     synchronized public static void notifyScreenShot(final ByteBuffer data, final int tabId,
101992:                                         final int left, final int top,
101992:                                         final int right, final int bottom,
101992:                                         final int bufferWidth, final int bufferHeight, final int token) {
101992:         GeckoAppShell.getHandler().post(new Runnable() {
101992:             public void run() {
105670:                 switch (token) {
105670:                     case SCREENSHOT_CHECKERBOARD:
105670:                     {
105670:                         ScreenshotHandler handler = getInstance();
115184:                         if (handler == null) {
115943:                             // if the handler is null, we have a stale reference to the buffer, free it
115943:                             DirectBufferAllocator.free(data);
115184:                             break;
115184:                         }
105670:                         if (Tabs.getInstance().getSelectedTab().getId() == tabId) {
105670:                             PendingScreenshot current;
105670:                             synchronized (handler.mPendingScreenshots) {
105670:                                 current = handler.mPendingScreenshots.element();
105670:                                 current.slicePainted(left, top, right, bottom);
105670:                                 if (current.sendNextEventToGecko()) {
105670:                                     break;
101992:                                 }
105670:                                 // this screenshot has all its slices done, so push it out
105670:                                 // to the layer renderer and remove it from the list
101992:                             }
108840:                             LayerView layerView = GeckoApp.mAppContext.getLayerView();
108840:                             if (layerView != null) {
108840:                                 layerView.getRenderer().setCheckerboardBitmap(
105670:                                     data, bufferWidth, bufferHeight, handler.mPageRect,
105670:                                     current.getPaintedRegion());
101992:                             }
101992:                         }
105670:                         synchronized (handler.mPendingScreenshots) {
105670:                             handler.mPendingScreenshots.remove();
105670:                             handler.sendNextEventToGecko();
101992:                         }
101992:                         break;
101992:                     }
105670:                     case SCREENSHOT_THUMBNAIL:
101992:                     {
105670:                         Tab tab = Tabs.getInstance().getTab(tabId);
105924:                         if (tab != null) {
102352:                             GeckoApp.mAppContext.handleThumbnailData(tab, data);
105924:                         }
101992:                         break;
101992:                     }
101992:                 }
101992:             }
101992:         });
101992:     }
105670: 
105670:     static class PendingScreenshot {
105670:         private final int mTabId;
105670:         private final LinkedList<GeckoEvent> mEvents;
105670:         private final Rect mPainted;
105670: 
105670:         PendingScreenshot(int tabId) {
105670:             mTabId = tabId;
105670:             mEvents = new LinkedList<GeckoEvent>();
105670:             mPainted = new Rect();
101992:         }
105670: 
105670:         void addEvent(GeckoEvent event) {
105670:             mEvents.add(event);
105670:         }
105670: 
105670:         boolean sendNextEventToGecko() {
105670:             if (!mEvents.isEmpty()) {
105670:                 GeckoAppShell.sendEventToGecko(mEvents.remove());
105670:                 return true;
105670:             }
105670:             return false;
105670:         }
105670: 
105670:         void slicePainted(int left, int top, int right, int bottom) {
105670:             mPainted.union(left, top, right, bottom);
105670:         }
105670: 
105670:         Rect getPaintedRegion() {
105670:             return mPainted;
105670:         }
105670: 
105670:         void discard() {
105670:             mEvents.clear();
105670:         }
105670:     }
105670: }
