29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4; -*-
33564:  * vim: set ts=4 sw=4 et tw=99:
17437:  *
17437:  * ***** BEGIN LICENSE BLOCK *****
17437:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
17437:  *
17437:  * The contents of this file are subject to the Mozilla Public License Version
17437:  * 1.1 (the "License"); you may not use this file except in compliance with
17437:  * the License. You may obtain a copy of the License at
17437:  * http://www.mozilla.org/MPL/
17437:  *
17437:  * Software distributed under the License is distributed on an "AS IS" basis,
17437:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
17437:  * for the specific language governing rights and limitations under the
17437:  * License.
17437:  *
17437:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
17437:  * May 28, 2008.
17437:  *
17437:  * The Initial Developer of the Original Code is
17437:  *   Andreas Gal <gal@mozilla.com>
17437:  *
17437:  * Contributor(s):
17437:  *   Brendan Eich <brendan@mozilla.org>
17671:  *   Mike Shaver <shaver@mozilla.org>
17671:  *   David Anderson <danderson@mozilla.com>
17437:  *
17437:  * Alternatively, the contents of this file may be used under the terms of
17437:  * either of the GNU General Public License Version 2 or later (the "GPL"),
17437:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
17437:  * in which case the provisions of the GPL or the LGPL are applicable instead
17437:  * of those above. If you wish to allow use of your version of this file only
17437:  * under the terms of either the GPL or the LGPL, and not to allow others to
17437:  * use your version of this file under the terms of the MPL, indicate your
17437:  * decision by deleting the provisions above and replace them with the notice
17437:  * and other provisions required by the GPL or the LGPL. If you do not delete
17437:  * the provisions above, a recipient may use your version of this file under
17437:  * the terms of any one of the MPL, the GPL or the LGPL.
17437:  *
17437:  * ***** END LICENSE BLOCK ***** */
17437: 
17437: #include <math.h>
17437: 
17437: #include "jsapi.h"
26316: #include "jsstdint.h"
17848: #include "jsarray.h"
17848: #include "jsbool.h"
17958: #include "jscntxt.h"
17958: #include "jsgc.h"
17958: #include "jsiter.h"
30268: #include "jsnum.h"
19083: #include "jslibmath.h"
17958: #include "jsmath.h"
17437: #include "jsnum.h"
19990: #include "prmjtime.h"
20402: #include "jsdate.h"
18001: #include "jsscope.h"
17958: #include "jsstr.h"
20408: #include "jsbuiltins.h"
20429: #include "jstracer.h"
32581: #include "jsvector.h"
17437: 
30283: #include "jsatominlines.h"
35117: #include "jsobjinlines.h"
34349: #include "jsscopeinlines.h"
42714: #include "jscntxtinlines.h"
30283: 
17965: using namespace avmplus;
17532: using namespace nanojit;
37741: using namespace js;
17532: 
27166: JS_FRIEND_API(void)
27166: js_SetTraceableNativeFailed(JSContext *cx)
27166: {
37741:     SetBuiltinError(cx);
27166: }
27166: 
18728: /*
18728:  * NB: bool FASTCALL is not compatible with Nanojit's calling convention usage.
18728:  * Do not use bool FASTCALL, use JSBool only!
18728:  */
18728: 
18024: jsdouble FASTCALL
18024: js_dmod(jsdouble a, jsdouble b)
17437: {
17437:     if (b == 0.0) {
17437:         jsdpun u;
48497:         u.s.hi = JSDOUBLE_HI32_NAN;
48497:         u.s.lo = JSDOUBLE_LO32_NAN;
17437:         return u.d;
17437:     }
30268:     return js_fmod(a, b);
17437: }
39910: JS_DEFINE_CALLINFO_2(extern, DOUBLE, js_dmod, DOUBLE, DOUBLE, 1, ACC_NONE)
17437: 
20408: int32 FASTCALL
20408: js_imod(int32 a, int32 b)
19560: {
19974:     if (a < 0 || b <= 0)
19974:         return -1;
19974:     int r = a % b;
19974:     return r;
19560: }
39910: JS_DEFINE_CALLINFO_2(extern, INT32, js_imod, INT32, INT32, 1, ACC_NONE)
19560: 
48470: #if JS_BITS_PER_WORD == 32
17469: 
18024: jsdouble FASTCALL
48470: js_UnboxDouble(uint32 tag, uint32 payload)
17469: {
48470:     if (tag == JSVAL_TAG_INT32)
48470:         return (double)(int32)payload;
48470: 
48470:     jsval_layout l;
48470:     l.s.tag = (JSValueTag)tag;
48470:     l.s.payload.u32 = payload;
48470:     return l.asDouble;
48470: }
48470: JS_DEFINE_CALLINFO_2(extern, DOUBLE, js_UnboxDouble, UINT32, UINT32, 1, ACC_NONE)
48470: 
48470: int32 FASTCALL
48470: js_UnboxInt32(uint32 tag, uint32 payload)
48470: {
48470:     if (tag == JSVAL_TAG_INT32)
48470:         return (int32)payload;
48470: 
48470:     jsval_layout l;
48470:     l.s.tag = (JSValueTag)tag;
48470:     l.s.payload.u32 = payload;
48470:     return js_DoubleToECMAInt32(l.asDouble);
48470: }
48470: JS_DEFINE_CALLINFO_2(extern, INT32, js_UnboxInt32, UINT32, UINT32, 1, ACC_NONE)
48470: 
48470: #elif JS_BITS_PER_WORD == 64
48470: 
48470: jsdouble FASTCALL
48470: js_UnboxDouble(Value v)
48470: {
48470:     if (v.isInt32())
48470:         return (jsdouble)v.toInt32();
48470:     return v.toDouble();
17437: }
39910: JS_DEFINE_CALLINFO_1(extern, DOUBLE, js_UnboxDouble, JSVAL, 1, ACC_NONE)
17437: 
20408: int32 FASTCALL
48470: js_UnboxInt32(Value v)
17437: {
48470:     if (v.isInt32())
48470:         return v.toInt32();
48470:     return js_DoubleToECMAInt32(v.toDouble());
17437: }
48470: JS_DEFINE_CALLINFO_1(extern, INT32, js_UnboxInt32, VALUE, 1, ACC_NONE)
17450: 
48470: #endif
33564: 
18024: int32 FASTCALL
18024: js_DoubleToInt32(jsdouble d)
17450: {
17450:     return js_DoubleToECMAInt32(d);
17450: }
39910: JS_DEFINE_CALLINFO_1(extern, INT32, js_DoubleToInt32, DOUBLE, 1, ACC_NONE)
17462: 
20408: uint32 FASTCALL
18024: js_DoubleToUint32(jsdouble d)
17462: {
17462:     return js_DoubleToECMAUint32(d);
17462: }
39910: JS_DEFINE_CALLINFO_1(extern, UINT32, js_DoubleToUint32, DOUBLE, 1, ACC_NONE)
17532: 
18024: jsdouble FASTCALL
18024: js_StringToNumber(JSContext* cx, JSString* str)
17910: {
39941:     return StringToNumberType<jsdouble>(cx, str);
17910: }
39910: JS_DEFINE_CALLINFO_2(extern, DOUBLE, js_StringToNumber, CONTEXT, STRING, 1, ACC_NONE)
17910: 
20408: int32 FASTCALL
18024: js_StringToInt32(JSContext* cx, JSString* str)
17912: {
39941:     return StringToNumberType<int32>(cx, str);
19073: }
39910: JS_DEFINE_CALLINFO_2(extern, INT32, js_StringToInt32, CONTEXT, STRING, 1, ACC_NONE)
19073: 
42694: /* Nb: it's always safe to set isDefinitelyAtom to false if you're unsure or don't know. */
42694: static inline JSBool
42694: AddPropertyHelper(JSContext* cx, JSObject* obj, JSScopeProperty* sprop, bool isDefinitelyAtom)
18001: {
18001:     JS_LOCK_OBJ(cx, obj);
27546: 
35453:     uint32 slot = sprop->slot;
40847:     JSScope* scope = obj->scope();
36435:     if (slot != scope->freeslot)
47571:         return false;
35453:     JS_ASSERT(sprop->parent == scope->lastProperty());
35453: 
37766:     if (scope->isSharedEmpty()) {
18001:         scope = js_GetMutableScope(cx, obj);
27546:         if (!scope)
47571:             return false;
37766:     } else {
37766:         JS_ASSERT(!scope->hasProperty(sprop));
18001:     }
18001: 
35453:     if (!scope->table) {
47497:         if (slot < obj->numSlots()) {
48470:             JS_ASSERT(obj->getSlot(scope->freeslot).isUndefined());
28353:             ++scope->freeslot;
18001:         } else {
27546:             if (!js_AllocSlot(cx, obj, &slot))
27546:                 goto exit_trace;
18001: 
27012:             if (slot != sprop->slot) {
27012:                 js_FreeSlot(cx, obj, slot);
27546:                 goto exit_trace;
18001:             }
27012:         }
18001: 
42694:         scope->extend(cx, sprop, isDefinitelyAtom);
27546:     } else {
35453:         JSScopeProperty *sprop2 =
39894:             scope->addProperty(cx, sprop->id, sprop->getter(), sprop->setter(),
40265:                                SPROP_INVALID_SLOT, sprop->attributes(), sprop->getFlags(),
39894:                                sprop->shortid);
27546:         if (sprop2 != sprop)
27546:             goto exit_trace;
27546:     }
27546: 
27546:     if (js_IsPropertyCacheDisabled(cx))
27546:         goto exit_trace;
27546: 
27545:     JS_UNLOCK_SCOPE(cx, scope);
47571:     return true;
27544: 
27546:   exit_trace:
18001:     JS_UNLOCK_SCOPE(cx, scope);
47571:     return false;
18001: }
42694: 
42694: JSBool FASTCALL
42694: js_AddProperty(JSContext* cx, JSObject* obj, JSScopeProperty* sprop)
42694: {
42694:     return AddPropertyHelper(cx, obj, sprop, /* isDefinitelyAtom = */false);
42694: }
39910: JS_DEFINE_CALLINFO_3(extern, BOOL, js_AddProperty, CONTEXT, OBJECT, SCOPEPROP, 0, ACC_STORE_ANY)
18001: 
42694: JSBool FASTCALL
42694: js_AddAtomProperty(JSContext* cx, JSObject* obj, JSScopeProperty* sprop)
42694: {
42694:     return AddPropertyHelper(cx, obj, sprop, /* isDefinitelyAtom = */true);
42694: }
42694: JS_DEFINE_CALLINFO_3(extern, BOOL, js_AddAtomProperty, CONTEXT, OBJECT, SCOPEPROP, 0, ACC_STORE_ANY)
42694: 
23702: static JSBool
23702: HasProperty(JSContext* cx, JSObject* obj, jsid id)
18495: {
24858:     // Check that we know how the lookup op will behave.
39928:     for (JSObject* pobj = obj; pobj; pobj = pobj->getProto()) {
27343:         if (pobj->map->ops->lookupProperty != js_LookupProperty)
48470:             return JS_NEITHER;
48470:         Class* clasp = pobj->getClass();
23702:         if (clasp->resolve != JS_ResolveStub && clasp != &js_StringClass)
48470:             return JS_NEITHER;
27343:     }
18495: 
18495:     JSObject* obj2;
18495:     JSProperty* prop;
30442:     if (js_LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop) < 0)
48470:         return JS_NEITHER;
18495:     if (prop)
31501:         obj2->dropProperty(cx, prop);
18495:     return prop != NULL;
18495: }
18495: 
21784: JSBool FASTCALL
23702: js_HasNamedProperty(JSContext* cx, JSObject* obj, JSString* idstr)
23702: {
48470:     JSAtom *atom = js_AtomizeString(cx, idstr, 0);
48470:     if (!atom)
48470:         return JS_NEITHER;
23702: 
48470:     return HasProperty(cx, obj, ATOM_TO_JSID(atom));
23702: }
39910: JS_DEFINE_CALLINFO_3(extern, BOOL, js_HasNamedProperty, CONTEXT, OBJECT, STRING, 0, ACC_STORE_ANY)
23702: 
23702: JSBool FASTCALL
21784: js_HasNamedPropertyInt32(JSContext* cx, JSObject* obj, int32 index)
21784: {
21784:     jsid id;
23075:     if (!js_Int32ToId(cx, index, &id))
48470:         return JS_NEITHER;
21804: 
23702:     return HasProperty(cx, obj, id);
21784: }
39910: JS_DEFINE_CALLINFO_3(extern, BOOL, js_HasNamedPropertyInt32, CONTEXT, OBJECT, INT32, 0,
39910:                      ACC_STORE_ANY)
21784: 
18019: JSString* FASTCALL
18024: js_TypeOfObject(JSContext* cx, JSObject* obj)
18019: {
48470:     JS_ASSERT(obj);
38633:     return ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[obj->typeOf(cx)]);
18019: }
39910: JS_DEFINE_CALLINFO_2(extern, STRING, js_TypeOfObject, CONTEXT, OBJECT, 1, ACC_NONE)
18019: 
18019: JSString* FASTCALL
40307: js_BooleanIntToString(JSContext *cx, int32 unboxed)
18082: {
40307:     JS_ASSERT(uint32(unboxed) <= 1);
21447:     return ATOM_TO_STRING(cx->runtime->atomState.booleanAtoms[unboxed]);
21447: }
40307: JS_DEFINE_CALLINFO_2(extern, STRING, js_BooleanIntToString, CONTEXT, INT32, 1, ACC_NONE)
21447: 
18300: JSObject* FASTCALL
27012: js_NewNullClosure(JSContext* cx, JSObject* funobj, JSObject* proto, JSObject* parent)
27012: {
40430:     JS_ASSERT(funobj->isFunction());
40430:     JS_ASSERT(proto->isFunction());
28353:     JS_ASSERT(JS_ON_TRACE(cx));
27012: 
27012:     JSFunction *fun = (JSFunction*) funobj;
27012:     JS_ASSERT(GET_FUNCTION_PRIVATE(cx, funobj) == fun);
27012: 
33581:     JSObject* closure = js_NewGCObject(cx);
27012:     if (!closure)
27012:         return NULL;
27012: 
48470:     closure->initSharingEmptyScope(&js_FunctionClass, proto, parent, PrivateValue(fun));
27012:     return closure;
27012: }
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_NewNullClosure, CONTEXT, OBJECT, OBJECT, OBJECT, 0,
39910:                      ACC_STORE_ANY)
27012: 
33564: JS_REQUIRES_STACK JSBool FASTCALL
41276: js_PopInterpFrame(JSContext* cx, TracerState* state)
33564: {
33564:     JS_ASSERT(cx->fp && cx->fp->down);
42714:     JSStackFrame* const fp = cx->fp;
33564: 
33564:     /*
33564:      * Mirror frame popping code from inline_return in js_Interpret. There are
33564:      * some things we just don't want to handle. In those cases, the trace will
33564:      * MISMATCH_EXIT.
33564:      */
42714:     if (fp->hookData)
33564:         return JS_FALSE;
42714:     if (cx->version != fp->callerVersion)
33564:         return JS_FALSE;
42714:     if (fp->flags & JSFRAME_CONSTRUCTING)
33564:         return JS_FALSE;
42714:     if (fp->imacpc)
33564:         return JS_FALSE;
42714:     if (fp->blockChain)
38642:         return JS_FALSE;
33564: 
42714:     fp->putActivationObjects(cx);
35451:     
33564:     /* Update display table. */
42714:     if (fp->script->staticLevel < JS_DISPLAY_SIZE)
42714:         cx->display[fp->script->staticLevel] = fp->displaySave;
33564: 
33564:     /* Pop the frame and its memory. */
42717:     cx->stack().popInlineFrame(cx, fp, fp->down);
33564: 
33564:     /* Update the inline call count. */
33564:     *state->inlineCallCountp = *state->inlineCallCountp - 1;
33564:     return JS_TRUE;
33564: }
41276: JS_DEFINE_CALLINFO_2(extern, BOOL, js_PopInterpFrame, CONTEXT, TRACERSTATE, 0, ACC_STORE_ANY)
33564: 
32581: JSString* FASTCALL
32581: js_ConcatN(JSContext *cx, JSString **strArray, uint32 size)
32581: {
32581:     /* Calculate total size. */
32581:     size_t numChar = 1;
32581:     for (uint32 i = 0; i < size; ++i) {
32581:         size_t before = numChar;
32581:         numChar += strArray[i]->length();
32581:         if (numChar < before)
32581:             return NULL;
32581:     }
32581: 
32581: 
32581:     /* Allocate buffer. */
32651:     if (numChar & js::tl::MulOverflowMask<sizeof(jschar)>::result)
32581:         return NULL;
32581:     jschar *buf = (jschar *)cx->malloc(numChar * sizeof(jschar));
32581:     if (!buf)
32581:         return NULL;
32581: 
32581:     /* Fill buffer. */
32581:     jschar *ptr = buf;
32581:     for (uint32 i = 0; i < size; ++i) {
32581:         const jschar *chars;
32581:         size_t length;
32581:         strArray[i]->getCharsAndLength(chars, length);
32581:         js_strncpy(ptr, chars, length);
32581:         ptr += length;
32581:     }
32581:     *ptr = '\0';
32581: 
32581:     /* Create string. */
32581:     JSString *str = js_NewString(cx, buf, numChar - 1);
32581:     if (!str)
32581:         cx->free(buf);
32581:     return str;
32581: }
39910: JS_DEFINE_CALLINFO_3(extern, STRING, js_ConcatN, CONTEXT, STRINGPTR, UINT32, 0, ACC_STORE_ANY)
