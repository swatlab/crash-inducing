29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
20929:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS string type implementation.
    1:  *
    1:  * In order to avoid unnecessary js_LockGCThing/js_UnlockGCThing calls, these
    1:  * native methods store strings (possibly newborn) converted from their 'this'
    1:  * parameter and arguments on the stack: 'this' conversions at argv[-1], arg
    1:  * conversions at their index (argv[0], argv[1]).  This is a legitimate method
    1:  * of rooting things that might lose their newborn root due to subsequent GC
    1:  * allocations in the same native method.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
55477: #include "jshash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
40405: #include "jsfun.h"      /* for JS_ARGS_LENGTH_MAX */
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsregexp.h"
12581: #include "jsscope.h"
24499: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
10992: #include "jsbit.h"
30023: #include "jsvector.h"
40405: #include "jsversion.h"
40901: 
42714: #include "jscntxtinlines.h"
55565: #include "jsinterpinlines.h"
40901: #include "jsobjinlines.h"
55711: #include "jsregexpinlines.h"
32607: #include "jsstrinlines.h"
56740: #include "jsautooplen.h"        // generated headers last
    1: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
64345: #ifdef DEBUG
64345: bool
64345: JSString::isShort() const
    1: {
64345:     bool is_short = arena()->header()->thingKind == FINALIZE_SHORT_STRING;
64345:     JS_ASSERT_IF(is_short, isFlat());
64345:     return is_short;
64345: }
64345: 
64345: bool
64345: JSString::isFixed() const
64345: {
64345:     return isFlat() && !isExtensible();
64345: }
64345: #endif
64345: 
64345: static JS_ALWAYS_INLINE JSString *
64345: Tag(JSRope *str)
64345: {
64345:     JS_ASSERT(!(size_t(str) & 1));
64345:     return (JSString *)(size_t(str) | 1);
64345: }
64345: 
64345: static JS_ALWAYS_INLINE bool
64345: Tagged(JSString *str)
64345: {
64345:     return (size_t(str) & 1) != 0;
64345: }
64345: 
64345: static JS_ALWAYS_INLINE JSRope *
64345: Untag(JSString *str)
64345: {
64345:     JS_ASSERT((size_t(str) & 1) == 1);
64345:     return (JSRope *)(size_t(str) & ~size_t(1));
64345: }
64345: 
64345: JS_ALWAYS_INLINE void
64345: JSLinearString::mark(JSTracer *)
64345: {
64345:     JSLinearString *str = this;
64345:     while (!str->isStaticAtom() && str->markIfUnmarked() && str->isDependent())
64345:         str = str->asDependent().base();
64345: }
64345: 
64345: JS_ALWAYS_INLINE void
64345: JSString::mark(JSTracer *trc)
64345: {
64345:     if (isLinear()) {
64345:         asLinear().mark(trc);
64345:         return;
64345:     }
64345: 
64345:     /*
64345:      * This function must not fail, so a simple stack-based traversal must not
64345:      * be used (since it may oom if the stack grows large). Instead, strings
64345:      * are temporarily mutated to embed parent pointers as they are traversed.
64345:      * This algorithm is homomorphic to JSString::flatten.
64345:      */
64345:     JSRope *str = &asRope();
64345:     JSRope *parent = NULL;
64345:     first_visit_node: {
64345:         if (!str->markIfUnmarked())
64345:             goto finish_node;
64345:         JS_ASSERT(!Tagged(str->d.u1.left) && !Tagged(str->d.s.u2.right));
64345:         JSString *left = str->d.u1.left;
64345:         if (left->isRope()) {
64345:             str->d.u1.left = Tag(parent);
64345:             parent = str;
64345:             str = &left->asRope();
64345:             goto first_visit_node;
64345:         }
64345:         left->asLinear().mark(trc);
64345:     }
64345:     visit_right_child: {
64345:         JSString *right = str->d.s.u2.right;
64345:         if (right->isRope()) {
64345:             str->d.s.u2.right = Tag(parent);
64345:             parent = str;
64345:             str = &right->asRope();
64345:             goto first_visit_node;
64345:         }
64345:         right->asLinear().mark(trc);
64345:     }
64345:     finish_node: {
64345:         if (!parent)
64345:             return;
64345:         if (Tagged(parent->d.u1.left)) {
64345:             JS_ASSERT(!Tagged(parent->d.s.u2.right));
64345:             JSRope *nextParent = Untag(parent->d.u1.left);
64345:             parent->d.u1.left = str;
64345:             str = parent;
64345:             parent = nextParent;
64345:             goto visit_right_child;
64345:         }
64345:         JSRope *nextParent = Untag(parent->d.s.u2.right);
64345:         parent->d.s.u2.right = str;
64345:         str = parent;
64345:         parent = nextParent;
64345:         goto finish_node;
64345:     }
64345: }
64345: 
64345: void
64345: js::gc::TypedMarker(JSTracer *trc, JSString *str)
64345: {
64345:     str->mark(trc);
    1: }
    1: 
48491: static JS_ALWAYS_INLINE size_t
59888: RopeCapacityFor(size_t length)
48491: {
48491:     static const size_t ROPE_DOUBLING_MAX = 1024 * 1024;
48491: 
48491:     /*
48491:      * Grow by 12.5% if the buffer is very large. Otherwise, round up to the
48491:      * next power of 2. This is similar to what we do with arrays; see
48491:      * JSObject::ensureDenseArrayElements.
48491:      */
48491:     if (length > ROPE_DOUBLING_MAX)
59888:         return length + (length / 8);
59888:     return RoundUpPow2(length);
59888: }
59888: 
59890: static JS_ALWAYS_INLINE jschar *
59890: AllocChars(JSContext *maybecx, size_t wholeCapacity)
59890: {
59890:     /* +1 for the null char at the end. */
59890:     JS_STATIC_ASSERT(JSString::MAX_LENGTH * sizeof(jschar) < UINT32_MAX);
59890:     size_t bytes = (wholeCapacity + 1) * sizeof(jschar);
59890:     if (maybecx)
64560:         return (jschar *)maybecx->malloc_(bytes);
64560:     return (jschar *)OffTheBooks::malloc_(bytes);
59890: }
59890: 
64345: JSFlatString *
64345: JSRope::flatten(JSContext *maybecx)
48491: {
48491:     /*
59888:      * Perform a depth-first dag traversal, splatting each node's characters
59888:      * into a contiguous buffer. Visit each rope node three times:
59888:      *   1. record position in the buffer and recurse into left child;
59888:      *   2. recurse into the right child;
59888:      *   3. transform the node into a dependent string.
64345:      * To avoid maintaining a stack, tree nodes are mutated to indicate how many
64345:      * times they have been visited. Since ropes can be dags, a node may be
64345:      * encountered multiple times during traversal. However, step 3 above leaves
64345:      * a valid dependent string, so everything works out. This algorithm is
64345:      * homomorphic to TypedMarker(JSTracer *, JSString *).
59888:      *
59888:      * While ropes avoid all sorts of quadratic cases with string
59888:      * concatenation, they can't help when ropes are immediately flattened.
59888:      * One idiomatic case that we'd like to keep linear (and has traditionally
59888:      * been linear in SM and other JS engines) is:
59888:      *
59888:      *   while (...) {
59888:      *     s += ...
59888:      *     s.flatten
59888:      *   }
59888:      *
59888:      * To do this, when the buffer for a to-be-flattened rope is allocated, the
59888:      * allocation size is rounded up. Then, if the resulting flat string is the
59888:      * left-hand side of a new rope that gets flattened and there is enough
59888:      * capacity, the rope is flattened into the same buffer, thereby avoiding
59888:      * copying the left-hand side. Clearing the 'extensible' bit turns off this
59888:      * optimization. This is necessary, e.g., when the JSAPI hands out the raw
59888:      * null-terminated char array of a flat string.
59986:      *
59986:      * N.B. This optimization can create chains of dependent strings.
48491:      */
59888:     const size_t wholeLength = length();
59888:     size_t wholeCapacity;
59888:     jschar *wholeChars;
59888:     JSString *str = this;
59888:     jschar *pos;
59888: 
64345:     if (this->leftChild()->isExtensible()) {
64345:         JSExtensibleString &left = this->leftChild()->asExtensible();
64345:         size_t capacity = left.capacity();
64345:         if (capacity >= wholeLength) {
64345:             wholeCapacity = capacity;
64345:             wholeChars = const_cast<jschar *>(left.chars());
64345:             size_t bits = left.d.lengthAndFlags;
64345:             pos = wholeChars + (bits >> LENGTH_SHIFT);
64345:             left.d.lengthAndFlags = bits ^ (EXTENSIBLE_FLAGS | DEPENDENT_BIT);
64345:             left.d.s.u2.base = (JSLinearString *)this;  /* will be true on exit */
59888:             goto visit_right_child;
59888:         }
64345:     }
59888: 
59888:     wholeCapacity = RopeCapacityFor(wholeLength);
59890:     wholeChars = AllocChars(maybecx, wholeCapacity);
59937:     if (!wholeChars)
59890:         return NULL;
60215: 
60215:     if (maybecx)
60215:         maybecx->runtime->stringMemoryUsed += wholeLength * 2;
64345: 
59888:     pos = wholeChars;
59888:     first_visit_node: {
64345:         JSString &left = *str->d.u1.left;
64345:         str->d.u1.chars = pos;
64345:         if (left.isRope()) {
64345:             left.d.s.u3.parent = str;          /* Return to this when 'left' done, */
64345:             left.d.lengthAndFlags = 0x200;     /* but goto visit_right_child. */
64345:             str = &left;
59888:             goto first_visit_node;
59888:         }
64345:         size_t len = left.length();
64345:         PodCopy(pos, left.d.u1.chars, len);
59888:         pos += len;
59888:     }
59888:     visit_right_child: {
64345:         JSString &right = *str->d.s.u2.right;
64345:         if (right.isRope()) {
64345:             right.d.s.u3.parent = str;         /* Return to this node when 'right' done, */
64345:             right.d.lengthAndFlags = 0x300;    /* but goto finish_node. */
64345:             str = &right;
59888:             goto first_visit_node;
59888:         }
64345:         size_t len = right.length();
64345:         PodCopy(pos, right.d.u1.chars, len);
59888:         pos += len;
59888:     }
59888:     finish_node: {
59888:         if (str == this) {
59888:             JS_ASSERT(pos == wholeChars + wholeLength);
59888:             *pos = '\0';
64345:             str->d.lengthAndFlags = buildLengthAndFlags(wholeLength, EXTENSIBLE_FLAGS);
64345:             str->d.u1.chars = wholeChars;
64345:             str->d.s.u2.capacity = wholeCapacity;
64345:             return &this->asFlat();
64345:         }
64345:         size_t progress = str->d.lengthAndFlags;
64345:         str->d.lengthAndFlags = buildLengthAndFlags(pos - str->d.u1.chars, DEPENDENT_BIT);
64345:         str->d.s.u2.base = (JSLinearString *)this;       /* will be true on exit */
64345:         str = str->d.s.u3.parent;
59888:         if (progress == 0x200)
59888:             goto visit_right_child;
64345:         JS_ASSERT(progress == 0x300);
59888:         goto finish_node;
59888:     }
59888: }
59888: 
18040: JSString * JS_FASTCALL
    1: js_ConcatStrings(JSContext *cx, JSString *left, JSString *right)
    1: {
64345:     JS_ASSERT_IF(!left->isAtom(), left->compartment() == cx->compartment);
64345:     JS_ASSERT_IF(!right->isAtom(), right->compartment() == cx->compartment);
61430: 
59888:     size_t leftLen = left->length();
48491:     if (leftLen == 0)
48491:         return right;
59888: 
59888:     size_t rightLen = right->length();
48491:     if (rightLen == 0)
    1:         return left;
    1: 
59888:     size_t wholeLength = leftLen + rightLen;
59888: 
64345:     if (JSShortString::lengthFits(wholeLength)) {
64345:         JSShortString *str = js_NewGCShortString(cx);
64345:         if (!str)
48563:             return NULL;
59890:         const jschar *leftChars = left->getChars(cx);
59890:         if (!leftChars)
59890:             return NULL;
59890:         const jschar *rightChars = right->getChars(cx);
59890:         if (!rightChars)
59890:             return NULL;
48563: 
64345:         jschar *buf = str->init(wholeLength);
64345:         PodCopy(buf, leftChars, leftLen);
64345:         PodCopy(buf + leftLen, rightChars, rightLen);
59888:         buf[wholeLength] = 0;
64345:         return str;
48563:     }
48563: 
59888:     if (wholeLength > JSString::MAX_LENGTH) {
48491:         if (JS_ON_TRACE(cx)) {
48491:             if (!CanLeaveTrace(cx))
48491:                 return NULL;
48491:             LeaveTrace(cx);
48491:         }
48491:         js_ReportAllocationOverflow(cx);
48491:         return NULL;
48491:     }
48491: 
64345:     return JSRope::new_(cx, left, right, wholeLength);
64345: }
64345: 
64345: JSFixedString *
64345: JSDependentString::undepend(JSContext *cx)
    1: {
64345:     JS_ASSERT(isDependent());
64345: 
64345:     size_t n = length();
64345:     size_t size = (n + 1) * sizeof(jschar);
64560:     jschar *s = (jschar *) cx->malloc_(size);
    1:     if (!s)
    1:         return NULL;
    1: 
60215:     cx->runtime->stringMemoryUsed += size;
64345: 
64345:     PodCopy(s, chars(), n);
    1:     s[n] = 0;
64345: 
64345:     d.lengthAndFlags = buildLengthAndFlags(n, FIXED_FLAGS);
64345:     d.u1.chars = s;
    1: 
    1: #ifdef DEBUG
    1:     JSRuntime *rt = cx->runtime;
    1:     JS_RUNTIME_UNMETER(rt, liveDependentStrings);
    1:     JS_RUNTIME_UNMETER(rt, totalDependentStrings);
    1:     JS_LOCK_RUNTIME_VOID(rt,
    1:         (rt->strdepLengthSum -= (double)n,
    1:          rt->strdepLengthSquaredSum -= (double)n * (double)n));
    1: #endif
64345: 
64345:     return &this->asFixed();
64345: }
64345: 
64345: JSStringFinalizeOp JSExternalString::str_finalizers[JSExternalString::TYPE_LIMIT] = {
64345:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
64345: };
64345: 
64345: #ifdef JS_TRACER
64345: 
64345: JSBool JS_FASTCALL
64345: js_FlattenOnTrace(JSContext *cx, JSString* str)
 4718: {
64345:     return !!str->ensureLinear(cx);
64345: }
64345: JS_DEFINE_CALLINFO_2(extern, BOOL, js_FlattenOnTrace, CONTEXT, STRING, 0, nanojit::ACCSET_STORE_ANY)
64345: 
64345: #endif /* !JS_TRACER */
    1: 
59890: static JSLinearString *
48470: ArgToRootedString(JSContext *cx, uintN argc, Value *vp, uintN arg)
16519: {
16519:     if (arg >= argc)
64345:         return cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
16519:     vp += 2 + arg;
16519: 
48470:     if (vp->isObject() && !DefaultValue(cx, &vp->toObject(), JSTYPE_STRING, vp))
16519:         return NULL;
30023: 
59890:     JSLinearString *str;
48470:     if (vp->isString()) {
59890:         str = vp->toString()->ensureLinear(cx);
48470:     } else if (vp->isBoolean()) {
64345:         str = cx->runtime->atomState.booleanAtoms[(int)vp->toBoolean()];
48470:     } else if (vp->isNull()) {
64345:         str = cx->runtime->atomState.nullAtom;
48470:     } else if (vp->isUndefined()) {
64345:         str = cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
30023:     }
30023:     else {
59890:         str = NumberToString(cx, vp->toNumber());
59890:         if (!str)
59890:             return NULL;
48470:         vp->setString(str);
30023:     }
16519:     return str;
16519: }
16519: 
    1: /*
    1:  * Forward declarations for URI encode/decode and helper routines
    1:  */
    1: static JSBool
48470: str_decodeURI(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static JSBool
48470: str_decodeURI_Component(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static JSBool
48470: str_encodeURI(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static JSBool
48470: str_encodeURI_Component(JSContext *cx, uintN argc, Value *vp);
    1: 
33589: static const uint32 OVERLONG_UTF8 = UINT32_MAX;
33589: 
    1: static uint32
    1: Utf8ToOneUcs4Char(const uint8 *utf8Buffer, int utf8Length);
    1: 
    1: /*
    1:  * Contributions from the String class to the set of methods defined for the
    1:  * global object.  escape and unescape used to be defined in the Mocha library,
    1:  * but as ECMA decided to spec them, they've been moved to the core engine
    1:  * and made ECMA-compliant.  (Incomplete escapes are interpreted as literal
    1:  * characters by unescape.)
    1:  */
    1: 
    1: /*
    1:  * Stuff to emulate the old libmocha escape, which took a second argument
    1:  * giving the type of escape to perform.  Retained for compatibility, and
    1:  * copied here to avoid reliance on net.h, mkparse.c/NET_EscapeBytes.
    1:  */
    1: 
    1: #define URL_XALPHAS     ((uint8) 1)
    1: #define URL_XPALPHAS    ((uint8) 2)
    1: #define URL_PATH        ((uint8) 4)
    1: 
    1: static const uint8 urlCharType[256] =
    1: /*      Bit 0           xalpha          -- the alphas
    1:  *      Bit 1           xpalpha         -- as xalpha but
    1:  *                             converts spaces to plus and plus to %20
    1:  *      Bit 2 ...       path            -- as xalphas but doesn't escape '/'
    1:  */
    1:     /*   0 1 2 3 4 5 6 7 8 9 A B C D E F */
    1:     {    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,       /* 0x */
    1:          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,       /* 1x */
    1:          0,0,0,0,0,0,0,0,0,0,7,4,0,7,7,4,       /* 2x   !"#$%&'()*+,-./  */
    1:          7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,       /* 3x  0123456789:;<=>?  */
    1:          7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,       /* 4x  @ABCDEFGHIJKLMNO  */
    1:          7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,7,       /* 5X  PQRSTUVWXYZ[\]^_  */
    1:          0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,       /* 6x  `abcdefghijklmno  */
    1:          7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,       /* 7X  pqrstuvwxyz{\}~  DEL */
    1:          0, };
    1: 
    1: /* This matches the ECMA escape set when mask is 7 (default.) */
    1: 
    1: #define IS_OK(C, mask) (urlCharType[((uint8) (C))] & (mask))
    1: 
 4127: /* See ECMA-262 Edition 3 B.2.1 */
    1: JSBool
61734: js_str_escape(JSContext *cx, uintN argc, Value *vp, Value *rval)
    1: {
    1:     const char digits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
    1:                            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    1: 
59890:     jsint mask = URL_XALPHAS | URL_XPALPHAS | URL_PATH;
    1:     if (argc > 1) {
59890:         double d;
61734:         if (!ValueToNumber(cx, vp[3], &d))
    1:             return JS_FALSE;
    1:         if (!JSDOUBLE_IS_FINITE(d) ||
    1:             (mask = (jsint)d) != d ||
    1:             mask & ~(URL_XALPHAS | URL_XPALPHAS | URL_PATH))
    1:         {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%lx", (unsigned long) mask);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_STRING_MASK, numBuf);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
61734:     JSLinearString *str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
59890:     size_t length = str->length();
59890:     const jschar *chars = str->chars();
    1: 
    1:     /* Take a first pass and see how big the result string will need to be. */
59890:     size_t newlength = length;
59890:     for (size_t i = 0; i < length; i++) {
59890:         jschar ch;
    1:         if ((ch = chars[i]) < 128 && IS_OK(ch, mask))
    1:             continue;
    1:         if (ch < 256) {
    1:             if (mask == URL_XPALPHAS && ch == ' ')
    1:                 continue;   /* The character will be encoded as '+' */
    1:             newlength += 2; /* The character will be encoded as %XX */
    1:         } else {
    1:             newlength += 5; /* The character will be encoded as %uXXXX */
    1:         }
    1: 
    1:         /*
    1:          * This overflow test works because newlength is incremented by at
    1:          * most 5 on each iteration.
    1:          */
    1:         if (newlength < length) {
12983:             js_ReportAllocationOverflow(cx);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (newlength >= ~(size_t)0 / sizeof(jschar)) {
12983:         js_ReportAllocationOverflow(cx);
    1:         return JS_FALSE;
    1:     }
    1: 
64560:     jschar *newchars = (jschar *) cx->malloc_((newlength + 1) * sizeof(jschar));
    1:     if (!newchars)
    1:         return JS_FALSE;
59890:     size_t i, ni;
    1:     for (i = 0, ni = 0; i < length; i++) {
59890:         jschar ch;
    1:         if ((ch = chars[i]) < 128 && IS_OK(ch, mask)) {
    1:             newchars[ni++] = ch;
    1:         } else if (ch < 256) {
    1:             if (mask == URL_XPALPHAS && ch == ' ') {
    1:                 newchars[ni++] = '+'; /* convert spaces to pluses */
    1:             } else {
    1:                 newchars[ni++] = '%';
    1:                 newchars[ni++] = digits[ch >> 4];
    1:                 newchars[ni++] = digits[ch & 0xF];
    1:             }
    1:         } else {
    1:             newchars[ni++] = '%';
    1:             newchars[ni++] = 'u';
    1:             newchars[ni++] = digits[ch >> 12];
    1:             newchars[ni++] = digits[(ch & 0xF00) >> 8];
    1:             newchars[ni++] = digits[(ch & 0xF0) >> 4];
    1:             newchars[ni++] = digits[ch & 0xF];
    1:         }
    1:     }
    1:     JS_ASSERT(ni == newlength);
    1:     newchars[newlength] = 0;
    1: 
59890:     JSString *retstr = js_NewString(cx, newchars, newlength);
59890:     if (!retstr) {
64560:         cx->free_(newchars);
    1:         return JS_FALSE;
    1:     }
59890:     rval->setString(retstr);
    1:     return JS_TRUE;
    1: }
    1: #undef IS_OK
    1: 
    1: static JSBool
48470: str_escape(JSContext *cx, uintN argc, Value *vp)
 4127: {
61734:     return js_str_escape(cx, argc, vp, vp);
 4127: }
 4127: 
 4127: /* See ECMA-262 Edition 3 B.2.2 */
 4127: static JSBool
48470: str_unescape(JSContext *cx, uintN argc, Value *vp)
    1: {
59890:     JSLinearString *str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
59890:         return false;
59890: 
59890:     size_t length = str->length();
59890:     const jschar *chars = str->chars();
    1: 
    1:     /* Don't bother allocating less space for the new string. */
64560:     jschar *newchars = (jschar *) cx->malloc_((length + 1) * sizeof(jschar));
    1:     if (!newchars)
59890:         return false;
59890:     size_t ni = 0, i = 0;
    1:     while (i < length) {
59890:         jschar ch = chars[i++];
    1:         if (ch == '%') {
    1:             if (i + 1 < length &&
    1:                 JS7_ISHEX(chars[i]) && JS7_ISHEX(chars[i + 1]))
    1:             {
    1:                 ch = JS7_UNHEX(chars[i]) * 16 + JS7_UNHEX(chars[i + 1]);
    1:                 i += 2;
    1:             } else if (i + 4 < length && chars[i] == 'u' &&
    1:                        JS7_ISHEX(chars[i + 1]) && JS7_ISHEX(chars[i + 2]) &&
    1:                        JS7_ISHEX(chars[i + 3]) && JS7_ISHEX(chars[i + 4]))
    1:             {
    1:                 ch = (((((JS7_UNHEX(chars[i + 1]) << 4)
    1:                         + JS7_UNHEX(chars[i + 2])) << 4)
    1:                       + JS7_UNHEX(chars[i + 3])) << 4)
    1:                     + JS7_UNHEX(chars[i + 4]);
    1:                 i += 5;
    1:             }
    1:         }
    1:         newchars[ni++] = ch;
    1:     }
    1:     newchars[ni] = 0;
    1: 
59890:     JSString *retstr = js_NewString(cx, newchars, ni);
59890:     if (!retstr) {
64560:         cx->free_(newchars);
    1:         return JS_FALSE;
    1:     }
59890:     vp->setString(retstr);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_UNEVAL
    1: static JSBool
48470: str_uneval(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1: 
48470:     str = js_ValueToSource(cx, argc != 0 ? vp[2] : UndefinedValue());
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: const char js_escape_str[] = "escape";
    1: const char js_unescape_str[] = "unescape";
    1: #if JS_HAS_UNEVAL
    1: const char js_uneval_str[] = "uneval";
    1: #endif
    1: const char js_decodeURI_str[] = "decodeURI";
    1: const char js_encodeURI_str[] = "encodeURI";
    1: const char js_decodeURIComponent_str[] = "decodeURIComponent";
    1: const char js_encodeURIComponent_str[] = "encodeURIComponent";
    1: 
    1: static JSFunctionSpec string_functions[] = {
16519:     JS_FN(js_escape_str,             str_escape,                1,0),
16519:     JS_FN(js_unescape_str,           str_unescape,              1,0),
    1: #if JS_HAS_UNEVAL
16519:     JS_FN(js_uneval_str,             str_uneval,                1,0),
    1: #endif
16519:     JS_FN(js_decodeURI_str,          str_decodeURI,             1,0),
16519:     JS_FN(js_encodeURI_str,          str_encodeURI,             1,0),
16519:     JS_FN(js_decodeURIComponent_str, str_decodeURI_Component,   1,0),
16519:     JS_FN(js_encodeURIComponent_str, str_encodeURI_Component,   1,0),
 4127: 
 4127:     JS_FS_END
    1: };
    1: 
    1: jschar      js_empty_ucstr[]  = {0};
    1: JSSubString js_EmptySubString = {0, js_empty_ucstr};
    1: 
    1: #define STRING_ELEMENT_ATTRS (JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_PERMANENT)
    1: 
    1: static JSBool
    1: str_enumerate(JSContext *cx, JSObject *obj)
    1: {
67942:     JSString *str = obj->getPrimitiveThis().toString();
67942:     for (size_t i = 0, length = str->length(); i < length; i++) {
67942:         JSString *str1 = js_NewDependentString(cx, str, i, 1);
    1:         if (!str1)
67942:             return false;
48470:         if (!obj->defineProperty(cx, INT_TO_JSID(i), StringValue(str1),
62395:                                  PropertyStub, StrictPropertyStub,
32573:                                  STRING_ELEMENT_ATTRS)) {
67942:             return false;
67942:         }
67942:     }
67942: 
67942:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp)
    1: {
54169:     if (!JSID_IS_INT(id))
    1:         return JS_TRUE;
    1: 
48470:     JSString *str = obj->getPrimitiveThis().toString();
48470: 
48470:     jsint slot = JSID_TO_INT(id);
29366:     if ((size_t)slot < str->length()) {
64345:         JSString *str1 = JSAtom::getUnitStringForElement(cx, str, size_t(slot));
    1:         if (!str1)
    1:             return JS_FALSE;
48470:         if (!obj->defineProperty(cx, id, StringValue(str1), NULL, NULL,
32573:                                  STRING_ELEMENT_ATTRS)) {
    1:             return JS_FALSE;
    1:         }
    1:         *objp = obj;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
48470: Class js_StringClass = {
    1:     js_String_str,
67942:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::STRING_RESERVED_SLOTS) |
67942:     JSCLASS_NEW_RESOLVE | JSCLASS_HAS_CACHED_PROTO(JSProto_String),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
67942:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     str_enumerate,
48622:     (JSResolveOp)str_resolve,
48622:     ConvertStub
    1: };
    1: 
61734: /*
61734:  * Returns a JSString * for the |this| value associated with vp, or throws a
61734:  * TypeError if |this| is null or undefined.  This algorithm is the same as
61734:  * calling CheckObjectCoercible(this), then returning ToString(this), as all
61734:  * String.prototype.* methods do.
61734:  */
61734: static JS_ALWAYS_INLINE JSString *
61734: ThisToStringForStringProto(JSContext *cx, Value *vp)
11809: {
61734:     if (vp[1].isString())
61734:         return vp[1].toString();
61734: 
48470:     if (vp[1].isObject()) {
48470:         JSObject *obj = &vp[1].toObject();
61734:         if (obj->getClass() == &js_StringClass &&
61734:             ClassMethodIsNative(cx, obj,
61734:                                 &js_StringClass,
61734:                                 ATOM_TO_JSID(cx->runtime->atomState.toStringAtom),
61734:                                 js_str_toString))
61734:         {
40901:             vp[1] = obj->getPrimitiveThis();
48470:             return vp[1].toString();
48470:         }
61734:     } else if (vp[1].isNullOrUndefined()) {
61734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CONVERT_TO,
61734:                              vp[1].isNull() ? "null" : "undefined", "object");
61734:         return NULL;
48470:     }
48470: 
48470:     JSString *str = js_ValueToString(cx, vp[1]);
11809:     if (!str)
11809:         return NULL;
48470:     vp[1].setString(str);
11809:     return str;
11809: }
11809: 
    1: #if JS_HAS_TOSOURCE
    1: 
    1: /*
    1:  * String.prototype.quote is generic (as are most string methods), unlike
    1:  * toSource, toString, and valueOf.
    1:  */
    1: static JSBool
48470: str_quote(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
    1:     str = js_QuoteString(cx, str, '"');
    1:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
55711:     if (!GetPrimitiveThis(cx, vp, &str))
55711:         return false;
55711: 
55711:     str = js_QuoteString(cx, str, '"');
55711:     if (!str)
55711:         return false;
55711: 
    1:     char buf[16];
55711:     size_t j = JS_snprintf(buf, sizeof buf, "(new String(");
55711: 
63103:     JS::Anchor<JSString *> anchor(str);
59890:     size_t k = str->length();
59890:     const jschar *s = str->getChars(cx);
59890:     if (!s)
59890:         return false;
55711: 
55711:     size_t n = j + k + 2;
64560:     jschar *t = (jschar *) cx->malloc_((n + 1) * sizeof(jschar));
    1:     if (!t)
55711:         return false;
55711: 
55711:     size_t i;
    1:     for (i = 0; i < j; i++)
    1:         t[i] = buf[i];
    1:     for (j = 0; j < k; i++, j++)
    1:         t[i] = s[j];
    1:     t[i++] = ')';
    1:     t[i++] = ')';
    1:     t[i] = 0;
55711: 
 4718:     str = js_NewString(cx, t, n);
    1:     if (!str) {
64560:         cx->free_(t);
55711:         return false;
    1:     }
48470:     vp->setString(str);
55711:     return true;
    1: }
    1: 
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
30443: JSBool
48470: js_str_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
55711:     JSString *str;
55711:     if (!GetPrimitiveThis(cx, vp, &str))
48470:         return false;
55711:     vp->setString(str);
48470:     return true;
    1: }
    1: 
    1: /*
    1:  * Java-like string native methods.
    1:  */
20929:  
59951: JS_ALWAYS_INLINE bool
59951: ValueToIntegerRange(JSContext *cx, const Value &v, int32 *out)
    1: {
59951:     if (v.isInt32()) {
59951:         *out = v.toInt32();
59951:     } else {
59951:         double d;
59951: 
59951:         if (!ValueToNumber(cx, v, &d))
59951:             return false;
59951: 
59951:         d = js_DoubleToInteger(d);
59951:         if (d > INT32_MAX)
59951:             *out = INT32_MAX;
59951:         else if (d < INT32_MIN)
59951:             *out = INT32_MIN;
59951:         else 
59951:             *out = int32(d);
59951:     }
59951: 
59951:     return true;
59951: }
59951: 
59951: static JSBool
59951: str_substring(JSContext *cx, uintN argc, Value *vp)
59951: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
61734: 
59951:     int32 length, begin, end;
59951:     if (argc > 0) {
59951:         end = length = int32(str->length());
59951: 
59951:         if (!ValueToIntegerRange(cx, vp[2], &begin))
59951:             return false;
59951: 
    1:         if (begin < 0)
    1:             begin = 0;
    1:         else if (begin > length)
    1:             begin = length;
    1: 
59951:         if (argc > 1 && !vp[3].isUndefined()) {
59951:             if (!ValueToIntegerRange(cx, vp[3], &end))
59951:                 return false;
59951: 
59951:             if (end > length) {
59951:                 end = length;
59951:             } else {
    1:                 if (end < 0)
    1:                     end = 0;
    1:                 if (end < begin) {
59951:                     int32_t tmp = begin;
    1:                     begin = end;
    1:                     end = tmp;
    1:                 }
59951:             }
59951:         }
59951: 
59951:         str = js_NewDependentString(cx, str, size_t(begin), size_t(end - begin));
    1:         if (!str)
59951:             return false;
59951:     }
59951: 
48470:     vp->setString(str);
59951:     return true;
    1: }
    1: 
18703: JSString* JS_FASTCALL
18703: js_toLowerCase(JSContext *cx, JSString *str)
    1: {
59890:     size_t n = str->length();
59890:     const jschar *s = str->getChars(cx);
59890:     if (!s)
59890:         return NULL;
59890: 
64560:     jschar *news = (jschar *) cx->malloc_((n + 1) * sizeof(jschar));
    1:     if (!news)
18703:         return NULL;
59890:     for (size_t i = 0; i < n; i++)
    1:         news[i] = JS_TOLOWER(s[i]);
    1:     news[n] = 0;
 4718:     str = js_NewString(cx, news, n);
    1:     if (!str) {
64560:         cx->free_(news);
18703:         return NULL;
18703:     }
18703:     return str;
18703: }
18703: 
20408: static JSBool
48470: str_toLowerCase(JSContext *cx, uintN argc, Value *vp)
18703: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
18703:     str = js_toLowerCase(cx, str);
18703:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_toLocaleLowerCase(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     /*
    1:      * Forcefully ignore the first (or any) argument and return toLowerCase(),
    1:      * ECMA has reserved that argument, presumably for defining the locale.
    1:      */
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToLowerCase) {
61734:         JSString *str = ThisToStringForStringProto(cx, vp);
61734:         if (!str)
61734:             return false;
48470:         return cx->localeCallbacks->localeToLowerCase(cx, str, Jsvalify(vp));
 4127:     }
61734: 
20408:     return str_toLowerCase(cx, 0, vp);
18703: }
18703: 
18703: JSString* JS_FASTCALL
18703: js_toUpperCase(JSContext *cx, JSString *str)
    1: {
59890:     size_t n = str->length();
59890:     const jschar *s = str->getChars(cx);
59890:     if (!s)
59890:         return NULL;
64560:     jschar *news = (jschar *) cx->malloc_((n + 1) * sizeof(jschar));
    1:     if (!news)
18703:         return NULL;
59890:     for (size_t i = 0; i < n; i++)
    1:         news[i] = JS_TOUPPER(s[i]);
    1:     news[n] = 0;
 4718:     str = js_NewString(cx, news, n);
    1:     if (!str) {
64560:         cx->free_(news);
18703:         return NULL;
18703:     }
18703:     return str;
18703: }
18703: 
20408: static JSBool
48470: str_toUpperCase(JSContext *cx, uintN argc, Value *vp)
18703: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
18703:     str = js_toUpperCase(cx, str);
18703:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_toLocaleUpperCase(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     /*
    1:      * Forcefully ignore the first (or any) argument and return toUpperCase(),
11835:      * ECMA has reserved that argument, presumably for defining the locale.
    1:      */
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUpperCase) {
61734:         JSString *str = ThisToStringForStringProto(cx, vp);
61734:         if (!str)
61734:             return false;
48470:         return cx->localeCallbacks->localeToUpperCase(cx, str, Jsvalify(vp));
 4127:     }
61734: 
20408:     return str_toUpperCase(cx, 0, vp);
    1: }
    1: 
    1: static JSBool
48470: str_localeCompare(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
61734: 
    1:     if (argc == 0) {
48470:         vp->setInt32(0);
    1:     } else {
61734:         JSString *thatStr = js_ValueToString(cx, vp[2]);
    1:         if (!thatStr)
61734:             return false;
    1:         if (cx->localeCallbacks && cx->localeCallbacks->localeCompare) {
48470:             vp[2].setString(thatStr);
48470:             return cx->localeCallbacks->localeCompare(cx, str, thatStr, Jsvalify(vp));
48470:         }
59890:         int32 result;
59890:         if (!CompareStrings(cx, str, thatStr, &result))
61734:             return false;
59890:         vp->setInt32(result);
    1:     }
61734:     return true;
    1: }
    1: 
49109: JSBool
49109: js_str_charAt(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
 4127:     jsint i;
48470:     if (vp[1].isString() && argc != 0 && vp[2].isInt32()) {
48470:         str = vp[1].toString();
48470:         i = vp[2].toInt32();
29366:         if ((size_t)i >= str->length())
 4127:             goto out_of_range;
 4127:     } else {
61734:         str = ThisToStringForStringProto(cx, vp);
61734:         if (!str)
61734:             return false;
    1: 
64345:         double d;
    1:         if (argc == 0) {
    1:             d = 0.0;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[2], &d))
61734:                 return false;
    1:             d = js_DoubleToInteger(d);
    1:         }
    1: 
29366:         if (d < 0 || str->length() <= d)
 4127:             goto out_of_range;
 4127:         i = (jsint) d;
 4127:     }
 4127: 
64345:     str = JSAtom::getUnitStringForElement(cx, str, size_t(i));
    1:     if (!str)
61734:         return false;
48470:     vp->setString(str);
61734:     return true;
 4127: 
 4127:   out_of_range:
48470:     vp->setString(cx->runtime->emptyString);
61734:     return true;
    1: }
    1: 
49109: JSBool
49109: js_str_charCodeAt(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
 4127:     jsint i;
48470:     if (vp[1].isString() && argc != 0 && vp[2].isInt32()) {
48470:         str = vp[1].toString();
48470:         i = vp[2].toInt32();
29366:         if ((size_t)i >= str->length())
 4127:             goto out_of_range;
 4127:     } else {
61734:         str = ThisToStringForStringProto(cx, vp);
61734:         if (!str)
61734:             return false;
    1: 
59890:         double d;
    1:         if (argc == 0) {
    1:             d = 0.0;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[2], &d))
59890:                 return false;
    1:             d = js_DoubleToInteger(d);
    1:         }
    1: 
29366:         if (d < 0 || str->length() <= d)
 4127:             goto out_of_range;
 4127:         i = (jsint) d;
 4127:     }
 4127: 
59890:     const jschar *chars;
59890:     chars = str->getChars(cx);
59890:     if (!chars)
59890:         return false;
59890: 
59890:     vp->setInt32(chars[i]);
59890:     return true;
 4127: 
 4127: out_of_range:
48470:     vp->setDouble(js_NaN);
59890:     return true;
    1: }
    1: 
64345: /*
64345:  * Boyer-Moore-Horspool superlinear search for pat:patlen in text:textlen.
64345:  * The patlen argument must be positive and no greater than sBMHPatLenMax.
64345:  *
64345:  * Return the index of pat in text, or -1 if not found.
64345:  */
64345: static const jsuint sBMHCharSetSize = 256; /* ISO-Latin-1 */
64345: static const jsuint sBMHPatLenMax   = 255; /* skip table element is uint8 */
64345: static const jsint  sBMHBadPattern  = -2;  /* return value if pat is not ISO-Latin-1 */
64345: 
    1: jsint
33165: js_BoyerMooreHorspool(const jschar *text, jsuint textlen,
33165:                       const jschar *pat, jsuint patlen)
    1: {
33165:     uint8 skip[sBMHCharSetSize];
33165: 
33165:     JS_ASSERT(0 < patlen && patlen <= sBMHPatLenMax);
33165:     for (jsuint i = 0; i < sBMHCharSetSize; i++)
33165:         skip[i] = (uint8)patlen;
33165:     jsuint m = patlen - 1;
33165:     for (jsuint i = 0; i < m; i++) {
33165:         jschar c = pat[i];
33165:         if (c >= sBMHCharSetSize)
33165:             return sBMHBadPattern;
33165:         skip[c] = (uint8)(m - i);
33165:     }
33151:     jschar c;
33165:     for (jsuint k = m;
    1:          k < textlen;
33165:          k += ((c = text[k]) >= sBMHCharSetSize) ? patlen : skip[c]) {
33165:         for (jsuint i = k, j = m; ; i--, j--) {
    1:             if (text[i] != pat[j])
    1:                 break;
33165:             if (j == 0)
33165:                 return static_cast<jsint>(i);  /* safe: max string size */
33165:         }
33165:     }
33165:     return -1;
33165: }
33165: 
40288: struct MemCmp {
40288:     typedef jsuint Extent;
40288:     static JS_ALWAYS_INLINE Extent computeExtent(const jschar *, jsuint patlen) {
40288:         return (patlen - 1) * sizeof(jschar);
40288:     }
40288:     static JS_ALWAYS_INLINE bool match(const jschar *p, const jschar *t, Extent extent) {
40288:         return memcmp(p, t, extent) == 0;
40288:     }
40288: };
40288: 
40288: struct ManualCmp {
40288:     typedef const jschar *Extent;
40288:     static JS_ALWAYS_INLINE Extent computeExtent(const jschar *pat, jsuint patlen) {
40288:         return pat + patlen;
40288:     }
40288:     static JS_ALWAYS_INLINE bool match(const jschar *p, const jschar *t, Extent extent) {
40288:         for (; p != extent; ++p, ++t) {
40288:             if (*p != *t)
40288:                 return false;
40288:         }
40288:         return true;
40288:     }
40288: };
40288: 
40288: template <class InnerMatch>
40288: static jsint
41865: UnrolledMatch(const jschar *text, jsuint textlen, const jschar *pat, jsuint patlen)
40288: {
40288:     JS_ASSERT(patlen > 0 && textlen > 0);
40288:     const jschar *textend = text + textlen - (patlen - 1);
40288:     const jschar p0 = *pat;
40288:     const jschar *const patNext = pat + 1;
40288:     const typename InnerMatch::Extent extent = InnerMatch::computeExtent(pat, patlen);
40288:     uint8 fixup;
40288: 
40288:     const jschar *t = text;
40288:     switch ((textend - t) & 7) {
40288:       case 0: if (*t++ == p0) { fixup = 8; goto match; }
40288:       case 7: if (*t++ == p0) { fixup = 7; goto match; }
40288:       case 6: if (*t++ == p0) { fixup = 6; goto match; }
40288:       case 5: if (*t++ == p0) { fixup = 5; goto match; }
40288:       case 4: if (*t++ == p0) { fixup = 4; goto match; }
40288:       case 3: if (*t++ == p0) { fixup = 3; goto match; }
40288:       case 2: if (*t++ == p0) { fixup = 2; goto match; }
40288:       case 1: if (*t++ == p0) { fixup = 1; goto match; }
41865:     }
41865:     while (t != textend) {
41865:       if (t[0] == p0) { t += 1; fixup = 8; goto match; }
41865:       if (t[1] == p0) { t += 2; fixup = 7; goto match; }
41865:       if (t[2] == p0) { t += 3; fixup = 6; goto match; }
41865:       if (t[3] == p0) { t += 4; fixup = 5; goto match; }
41865:       if (t[4] == p0) { t += 5; fixup = 4; goto match; }
41865:       if (t[5] == p0) { t += 6; fixup = 3; goto match; }
41865:       if (t[6] == p0) { t += 7; fixup = 2; goto match; }
41865:       if (t[7] == p0) { t += 8; fixup = 1; goto match; }
41865:         t += 8;
40288:         continue;
40288:         do {
40288:             if (*t++ == p0) {
40288:               match:
40288:                 if (!InnerMatch::match(patNext, t, extent))
40288:                     goto failed_match;
40288:                 return t - text - 1;
40288:             }
40288:           failed_match:;
40288:         } while (--fixup > 0);
40288:     }
40288:     return -1;
40288: }
40288: 
33165: static JS_ALWAYS_INLINE jsint
33165: StringMatch(const jschar *text, jsuint textlen,
33165:             const jschar *pat, jsuint patlen)
33165: {
33165:     if (patlen == 0)
33165:         return 0;
33165:     if (textlen < patlen)
33165:         return -1;
33165: 
40415: #if defined(__i386__) || defined(_M_IX86) || defined(__i386)
35107:     /*
35107:      * Given enough registers, the unrolled loop below is faster than the
35107:      * following loop. 32-bit x86 does not have enough registers.
35107:      */
35107:     if (patlen == 1) {
35107:         const jschar p0 = *pat;
35107:         for (const jschar *c = text, *end = text + textlen; c != end; ++c) {
35107:             if (*c == p0)
35107:                 return c - text;
35107:         }
35107:         return -1;
35107:     }
35107: #endif
35107: 
35107:     /*
35306:      * If the text or pattern string is short, BMH will be more expensive than
35306:      * the basic linear scan due to initialization cost and a more complex loop
35306:      * body. While the correct threshold is input-dependent, we can make a few
35306:      * conservative observations:
35306:      *  - When |textlen| is "big enough", the initialization time will be
35306:      *    proportionally small, so the worst-case slowdown is minimized.
35306:      *  - When |patlen| is "too small", even the best case for BMH will be
35306:      *    slower than a simple scan for large |textlen| due to the more complex
35306:      *    loop body of BMH.
35306:      * From this, the values for "big enough" and "too small" are determined
35306:      * empirically. See bug 526348.
35107:      */
35306:     if (textlen >= 512 && patlen >= 11 && patlen <= sBMHPatLenMax) {
33165:         jsint index = js_BoyerMooreHorspool(text, textlen, pat, patlen);
33165:         if (index != sBMHBadPattern)
33165:             return index;
33165:     }
33165: 
35107:     /*
40288:      * For big patterns with large potential overlap we want the SIMD-optimized
40288:      * speed of memcmp. For small patterns, a simple loop is faster.
40288:      *
40288:      * FIXME: Linux memcmp performance is sad and the manual loop is faster.
35107:      */
40288:     return
40288: #if !defined(__linux__)
41865:            patlen > 128 ? UnrolledMatch<MemCmp>(text, textlen, pat, patlen)
40288:                         :
35107: #endif
41865:                           UnrolledMatch<ManualCmp>(text, textlen, pat, patlen);
    1: }
    1: 
48536: static const size_t sRopeMatchThresholdRatioLog2 = 5;
48536: 
59888: /*
59888:  * RopeMatch takes the text to search, the patern to search for in the text.
59888:  * RopeMatch returns false on OOM and otherwise returns the match index through
59888:  * the 'match' outparam (-1 for not found).
59888:  */
59888: static bool
59888: RopeMatch(JSContext *cx, JSString *textstr, const jschar *pat, jsuint patlen, jsint *match)
48536: {
59888:     JS_ASSERT(textstr->isRope());
59888: 
59888:     if (patlen == 0) {
59888:         *match = 0;
59888:         return true;
59888:     }
59888:     if (textstr->length() < patlen) {
59888:         *match = -1;
59888:         return true;
59888:     }
48536: 
48536:     /*
48536:      * List of leaf nodes in the rope. If we run out of memory when trying to
48536:      * append to this list, we can still fall back to StringMatch, so use the
48536:      * system allocator so we don't report OOM in that case.
48536:      */
64345:     Vector<JSLinearString *, 16, SystemAllocPolicy> strs;
48536: 
48536:     /*
48536:      * We don't want to do rope matching if there is a poor node-to-char ratio,
48536:      * since this means spending a lot of time in the match loop below. We also
48536:      * need to build the list of leaf nodes. Do both here: iterate over the
48536:      * nodes so long as there are not too many.
48536:      */
59888:     {
48536:         size_t textstrlen = textstr->length();
48536:         size_t threshold = textstrlen >> sRopeMatchThresholdRatioLog2;
59888:         StringSegmentRange r(cx);
59888:         if (!r.init(textstr))
59888:             return false;
59888:         while (!r.empty()) {
59888:             if (threshold-- == 0 || !strs.append(r.front())) {
59890:                 const jschar *chars = textstr->getChars(cx);
59890:                 if (!chars)
59890:                     return false;
59890:                 *match = StringMatch(chars, textstrlen, pat, patlen);
59888:                 return true;
59888:             }
59888:             if (!r.popFront())
59888:                 return false;
59888:         }
48536:     }
48536: 
48536:     /* Absolute offset from the beginning of the logical string textstr. */
48536:     jsint pos = 0;
48536: 
48536:     // TODO: consider branching to a simple loop if patlen == 1
48536: 
64345:     for (JSLinearString **outerp = strs.begin(); outerp != strs.end(); ++outerp) {
48536:         /* First try to match without spanning two nodes. */
64345:         JSLinearString *outer = *outerp;
64345:         const jschar *chars = outer->chars();
59890:         size_t len = outer->length();
48536:         jsint matchResult = StringMatch(chars, len, pat, patlen);
59888:         if (matchResult != -1) {
59888:             *match = pos + matchResult;
59888:             return true;
59888:         }
48536: 
48536:         /* Test the overlap. */
64345:         JSLinearString **innerp = outerp;
48536: 
48536:         /*
48536:          * Start searching at the first place where StringMatch wouldn't have
48536:          * found the match.
48536:          */
48536:         const jschar *const text = chars + (patlen > len ? 0 : len - patlen + 1);
48536:         const jschar *const textend = chars + len;
48536:         const jschar p0 = *pat;
48536:         const jschar *const p1 = pat + 1;
48536:         const jschar *const patend = pat + patlen;
48536:         for (const jschar *t = text; t != textend; ) {
48536:             if (*t++ != p0)
48536:                 continue;
48536:             const jschar *ttend = textend;
48536:             for (const jschar *pp = p1, *tt = t; pp != patend; ++pp, ++tt) {
48536:                 while (tt == ttend) {
59888:                     if (++innerp == strs.end()) {
59888:                         *match = -1;
59888:                         return true;
59888:                     }
64345:                     JSLinearString *inner = *innerp;
64345:                     tt = inner->chars();
59890:                     ttend = tt + inner->length();
48536:                 }
48536:                 if (*pp != *tt)
48536:                     goto break_continue;
48536:             }
48536: 
48536:             /* Matched! */
59888:             *match = pos + (t - chars) - 1;  /* -1 because of *t++ above */
59888:             return true;
48536: 
48536:           break_continue:;
48536:         }
48536: 
48536:         pos += len;
48536:     }
48536: 
59888:     *match = -1;
59888:     return true;
48536: }
48536: 
    1: static JSBool
48470: str_indexOf(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
33165: 
59890:     JSLinearString *patstr = ArgToRootedString(cx, argc, vp, 0);
33165:     if (!patstr)
59890:         return false;
59890: 
33165:     jsuint textlen = str->length();
59890:     const jschar *text = str->getChars(cx);
59890:     if (!text)
59890:         return false;
59890: 
59890:     jsuint patlen = patstr->length();
33165:     const jschar *pat = patstr->chars();
33165: 
33165:     jsuint start;
33165:     if (argc > 1) {
48470:         if (vp[3].isInt32()) {
48470:             jsint i = vp[3].toInt32();
33165:             if (i <= 0) {
33165:                 start = 0;
33165:             } else if (jsuint(i) > textlen) {
58257:                 start = textlen;
33165:                 textlen = 0;
33151:             } else {
33165:                 start = i;
33165:                 text += start;
33165:                 textlen -= start;
33165:             }
33165:         } else {
40828:             jsdouble d;
40828:             if (!ValueToNumber(cx, vp[3], &d))
    1:                 return JS_FALSE;
    1:             d = js_DoubleToInteger(d);
33165:             if (d <= 0) {
33165:                 start = 0;
33165:             } else if (d > textlen) {
58257:                 start = textlen;
33165:                 textlen = 0;
    1:             } else {
33165:                 start = (jsint)d;
33165:                 text += start;
33165:                 textlen -= start;
33165:             }
15342:         }
15342:     } else {
33165:         start = 0;
33165:     }
33165: 
33165:     jsint match = StringMatch(text, textlen, pat, patlen);
48470:     vp->setInt32((match == -1) ? -1 : start + match);
33165:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_lastIndexOf(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *textstr = ThisToStringForStringProto(cx, vp);
61734:     if (!textstr)
61734:         return false;
59890:     size_t textlen = textstr->length();
59890:     const jschar *text = textstr->getChars(cx);
59890:     if (!text)
59890:         return false;
59890: 
59890:     JSLinearString *patstr = ArgToRootedString(cx, argc, vp, 0);
59890:     if (!patstr)
59890:         return false;
59890: 
59890:     size_t patlen = patstr->length();
59890:     const jschar *pat = patstr->chars();
59890: 
59890:     jsint i = textlen - patlen; // Start searching here
26470:     if (i < 0) {
48470:         vp->setInt32(-1);
59890:         return true;
26470:     }
26470: 
    1:     if (argc > 1) {
48470:         if (vp[3].isInt32()) {
59890:             jsint j = vp[3].toInt32();
26470:             if (j <= 0)
26470:                 i = 0;
26470:             else if (j < i)
26470:                 i = j;
26470:         } else {
59890:             double d;
40828:             if (!ValueToNumber(cx, vp[3], &d))
59890:                 return false;
26470:             if (!JSDOUBLE_IS_NaN(d)) {
    1:                 d = js_DoubleToInteger(d);
26470:                 if (d <= 0)
    1:                     i = 0;
26470:                 else if (d < i)
    1:                     i = (jsint)d;
    1:             }
26470:         }
    1:     }
    1: 
    1:     if (patlen == 0) {
48470:         vp->setInt32(i);
59890:         return true;
    1:     }
    1: 
35107:     const jschar *t = text + i;
35107:     const jschar *textend = text - 1;
35107:     const jschar p0 = *pat;
35107:     const jschar *patNext = pat + 1;
35107:     const jschar *patEnd = pat + patlen;
35107: 
35107:     for (; t != textend; --t) {
35107:         if (*t == p0) {
35107:             const jschar *t1 = t + 1;
35107:             for (const jschar *p1 = patNext; p1 != patEnd; ++p1, ++t1) {
35107:                 if (*t1 != *p1)
35107:                     goto break_continue;
35107:             }
48470:             vp->setInt32(t - text);
59890:             return true;
35107:         }
35107:       break_continue:;
35107:     }
35107: 
48470:     vp->setInt32(-1);
59890:     return true;
    1: }
    1: 
18938: static JSBool
48470: js_TrimString(JSContext *cx, Value *vp, JSBool trimLeft, JSBool trimRight)
18938: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
59890:     size_t length = str->length();
59890:     const jschar *chars = str->getChars(cx);
59890:     if (!chars)
59890:         return false;
59890: 
59890:     size_t begin = 0;
59890:     size_t end = length;
18938: 
18938:     if (trimLeft) {
18938:         while (begin < length && JS_ISSPACE(chars[begin]))
18938:             ++begin;
18938:     }
18938: 
18938:     if (trimRight) {
18938:         while (end > begin && JS_ISSPACE(chars[end-1]))
18938:             --end;
18938:     }
18938: 
18938:     str = js_NewDependentString(cx, str, begin, end - begin);
18938:     if (!str)
59890:         return false;
18938: 
48470:     vp->setString(str);
59890:     return true;
18938: }
18938: 
18938: static JSBool
48470: str_trim(JSContext *cx, uintN argc, Value *vp)
18938: {
18938:     return js_TrimString(cx, vp, JS_TRUE, JS_TRUE);
18938: }
18938: 
18938: static JSBool
48470: str_trimLeft(JSContext *cx, uintN argc, Value *vp)
18938: {
18938:     return js_TrimString(cx, vp, JS_TRUE, JS_FALSE);
18938: }
18938: 
18938: static JSBool
48470: str_trimRight(JSContext *cx, uintN argc, Value *vp)
18938: {
18938:     return js_TrimString(cx, vp, JS_FALSE, JS_TRUE);
18938: }
18938: 
    1: /*
    1:  * Perl-inspired string functions.
    1:  */
32645: 
51460: /* Result of a successfully performed flat match. */
51460: class FlatMatch
51460: {
59890:     JSLinearString  *patstr;
51460:     const jschar    *pat;
51460:     size_t          patlen;
51460:     int32           match_;
51460: 
51460:     friend class RegExpGuard;
51460: 
51460:   public:
54398:     FlatMatch() : patstr(NULL) {} /* Old GCC wants this initialization. */
51460:     JSString *pattern() const { return patstr; }
51460:     size_t patternLength() const { return patlen; }
51460: 
33165:     /*
60169:      * Note: The match is -1 when the match is performed successfully,
51460:      * but no match is found.
51460:      */
51460:     int32 match() const { return match_; }
51460: };
51460: 
51460: /* A regexp and optional associated object. */
51460: class RegExpPair
51460: {
60799:     AutoRefCount<RegExp>    re_;
51460:     JSObject                *reobj_;
51460: 
60169:     explicit RegExpPair(RegExpPair &);
51460: 
51460:   public:
60799:     explicit RegExpPair(JSContext *cx) : re_(cx) {}
60799: 
60799:     void reset(JSObject &obj) {
60799:         reobj_ = &obj;
60799:         RegExp *re = RegExp::extractFrom(reobj_);
60799:         JS_ASSERT(re);
60799:         re_.reset(NeedsIncRef<RegExp>(re));
60799:     }
60799: 
60799:     void reset(AlreadyIncRefed<RegExp> re) {
60169:         reobj_ = NULL;
60799:         re_.reset(re);
60169:     }
60169: 
60169:     /* Note: May be null. */
51460:     JSObject *reobj() const { return reobj_; }
60799:     bool hasRegExp() const { return !re_.null(); }
60799:     RegExp &re() const { JS_ASSERT(hasRegExp()); return *re_; }
51460: };
51460: 
51460: /*
51460:  * RegExpGuard factors logic out of String regexp operations.
33165:  *
51460:  * @param optarg    Indicates in which argument position RegExp
51460:  *                  flags will be found, if present. This is a Mozilla
51460:  *                  extension and not part of any ECMA spec.
33165:  */
32645: class RegExpGuard
32645: {
32645:     RegExpGuard(const RegExpGuard &);
32645:     void operator=(const RegExpGuard &);
32645: 
51460:     JSContext   *cx;
51460:     RegExpPair  rep;
51460:     FlatMatch   fm;
51460: 
51460:     /*
51460:      * Upper bound on the number of characters we are willing to potentially
51460:      * waste on searching for RegExp meta-characters.
51460:      */
51460:     static const size_t MAX_FLAT_PAT_LEN = 256;
32645: 
59890:     static JSString *flattenPattern(JSContext *cx, JSLinearString *patstr) {
60571:         StringBuffer sb(cx);
60571:         if (!sb.reserve(patstr->length()))
54576:             return NULL;
54576: 
54576:         static const jschar ESCAPE_CHAR = '\\';
54576:         const jschar *chars = patstr->chars();
54576:         size_t len = patstr->length();
54576:         for (const jschar *it = chars; it != chars + len; ++it) {
54576:             if (RegExp::isMetaChar(*it)) {
60571:                 if (!sb.append(ESCAPE_CHAR) || !sb.append(*it))
54576:                     return NULL;
54576:             } else {
60571:                 if (!sb.append(*it))
54576:                     return NULL;
54576:             }
54576:         }
60571:         return sb.finishString();
54576:     }
54576: 
32645:   public:
60799:     explicit RegExpGuard(JSContext *cx) : cx(cx), rep(cx) {}
60169:     ~RegExpGuard() {}
34376: 
33165:     /* init must succeed in order to call tryFlatMatch or normalizeRegExp. */
33165:     bool
48470:     init(uintN argc, Value *vp)
33165:     {
51460:         if (argc != 0 && VALUE_IS_REGEXP(cx, vp[2])) {
60169:             rep.reset(vp[2].toObject());
33165:         } else {
51460:             fm.patstr = ArgToRootedString(cx, argc, vp, 0);
51460:             if (!fm.patstr)
33165:                 return false;
33165:         }
33165:         return true;
33165:     }
    1: 
    1:     /*
51460:      * Attempt to match |patstr| to |textstr|. A flags argument, metachars in the
51460:      * pattern string, or a lengthy pattern string can thwart this process.
51460:      *
51460:      * @param checkMetaChars    Look for regexp metachars in the pattern string.
51460:      * @return                  Whether flat matching could be used.
59888:      *
60211:      * N.B. tryFlatMatch returns NULL on OOM, so the caller must check cx->isExceptionPending().
33165:      */
51460:     const FlatMatch *
59888:     tryFlatMatch(JSContext *cx, JSString *textstr, uintN optarg, uintN argc,
59888:                  bool checkMetaChars = true)
29885:     {
60169:         if (rep.hasRegExp())
51460:             return NULL;
51460: 
59890:         fm.pat = fm.patstr->chars();
59890:         fm.patlen = fm.patstr->length();
51460: 
51460:         if (optarg < argc)
51460:             return NULL;
51460: 
51460:         if (checkMetaChars &&
51460:             (fm.patlen > MAX_FLAT_PAT_LEN || RegExp::hasMetaChars(fm.pat, fm.patlen))) {
51460:             return NULL;
51460:         }
51460: 
48536:         /*
48536:          * textstr could be a rope, so we want to avoid flattening it for as
48536:          * long as possible.
48536:          */
59888:         if (textstr->isRope()) {
59888:             if (!RopeMatch(cx, textstr, fm.pat, fm.patlen, &fm.match_))
59888:                 return NULL;
48536:         } else {
64345:             const jschar *text = textstr->asLinear().chars();
59890:             size_t textlen = textstr->length();
51460:             fm.match_ = StringMatch(text, textlen, fm.pat, fm.patlen);
51460:         }
51460:         return &fm;
51460:     }
33165: 
33165:     /* If the pattern is not already a regular expression, make it so. */
51460:     const RegExpPair *
48470:     normalizeRegExp(bool flat, uintN optarg, uintN argc, Value *vp)
33165:     {
60169:         if (rep.hasRegExp())
51460:             return &rep;
51460: 
60169:         /* Build RegExp from pattern string. */
32645:         JSString *opt;
32645:         if (optarg < argc) {
51460:             opt = js_ValueToString(cx, vp[2 + optarg]);
    1:             if (!opt)
51460:                 return NULL;
    1:         } else {
    1:             opt = NULL;
    1:         }
51460: 
54576:         JSString *patstr;
54576:         if (flat) {
54576:             patstr = flattenPattern(cx, fm.patstr);
54576:             if (!patstr)
54576:                 return false;
54576:         } else {
54576:             patstr = fm.patstr;
54576:         }
54576:         JS_ASSERT(patstr);
54576: 
60799:         AlreadyIncRefed<RegExp> re = RegExp::createFlagged(cx, patstr, opt);
60169:         if (!re)
51460:             return NULL;
60799:         rep.reset(re);
51460:         return &rep;
51460:     }
51460: 
51460: #if DEBUG
60169:     bool hasRegExpPair() const { return rep.hasRegExp(); }
51460: #endif
32645: };
32645: 
32645: /* js_ExecuteRegExp indicates success in two ways, based on the 'test' flag. */
32645: static JS_ALWAYS_INLINE bool
48470: Matched(bool test, const Value &v)
32645: {
48470:     return test ? v.isTrue() : !v.isNull();
32645: }
32645: 
53858: typedef bool (*DoMatchCallback)(JSContext *cx, RegExpStatics *res, size_t count, void *data);
32645: 
32645: /*
32645:  * BitOR-ing these flags allows the DoMatch caller to control when how the
32645:  * RegExp engine is called and when callbacks are fired.
32645:  */
32645: enum MatchControlFlags {
32645:    TEST_GLOBAL_BIT         = 0x1, /* use RegExp.test for global regexps */
32645:    TEST_SINGLE_BIT         = 0x2, /* use RegExp.test for non-global regexps */
32645:    CALLBACK_ON_SINGLE_BIT  = 0x4, /* fire callback on non-global match */
32645: 
32645:    MATCH_ARGS    = TEST_GLOBAL_BIT,
32645:    MATCHALL_ARGS = CALLBACK_ON_SINGLE_BIT,
32645:    REPLACE_ARGS  = TEST_GLOBAL_BIT | TEST_SINGLE_BIT | CALLBACK_ON_SINGLE_BIT
32645: };
32645: 
32645: /* Factor out looping and matching logic. */
32645: static bool
53858: DoMatch(JSContext *cx, RegExpStatics *res, Value *vp, JSString *str, const RegExpPair &rep,
32645:         DoMatchCallback callback, void *data, MatchControlFlags flags)
32645: {
51460:     RegExp &re = rep.re();
50491:     if (re.global()) {
32645:         /* global matching ('g') */
32645:         bool testGlobal = flags & TEST_GLOBAL_BIT;
51460:         if (rep.reobj())
51460:             rep.reobj()->zeroRegExpLastIndex();
32645:         for (size_t count = 0, i = 0, length = str->length(); i <= length; ++count) {
53858:             if (!re.execute(cx, res, str, &i, testGlobal, vp))
32645:                 return false;
32645:             if (!Matched(testGlobal, *vp))
    1:                 break;
53858:             if (!callback(cx, res, count, data))
32645:                 return false;
53858:             if (!res->matched())
32645:                 ++i;
    1:         }
    1:     } else {
32645:         /* single match */
33166:         bool testSingle = !!(flags & TEST_SINGLE_BIT),
33166:              callbackOnSingle = !!(flags & CALLBACK_ON_SINGLE_BIT);
32645:         size_t i = 0;
53858:         if (!re.execute(cx, res, str, &i, testSingle, vp))
32645:             return false;
53858:         if (callbackOnSingle && Matched(testSingle, *vp) && !callback(cx, res, 0, data))
32645:             return false;
32645:     }
32645:     return true;
32645: }
32645: 
50491: static bool
51460: BuildFlatMatchArray(JSContext *cx, JSString *textstr, const FlatMatch &fm, Value *vp)
50491: {
51460:     if (fm.match() < 0) {
50491:         vp->setNull();
50491:         return true;
50491:     }
50491: 
50491:     /* For this non-global match, produce a RegExp.exec-style array. */
59234:     JSObject *obj = NewSlowEmptyArray(cx);
50491:     if (!obj)
50491:         return false;
50491:     vp->setObject(*obj);
50491: 
51460:     return obj->defineProperty(cx, INT_TO_JSID(0), StringValue(fm.pattern())) &&
50491:            obj->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.indexAtom),
51460:                                Int32Value(fm.match())) &&
50491:            obj->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.inputAtom),
50491:                                StringValue(textstr));
50491: }
50491: 
48470: typedef JSObject **MatchArgType;
48470: 
    1: /*
32645:  * DoMatch will only callback on global matches, hence this function builds
32645:  * only the "array of matches" returned by match on global regexps.
    1:  */
32645: static bool
53858: MatchCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)
    1: {
48470:     JS_ASSERT(count <= JSID_INT_MAX);  /* by max string length */
48470: 
48470:     JSObject *&arrayobj = *static_cast<MatchArgType>(p);
    1:     if (!arrayobj) {
59234:         arrayobj = NewDenseEmptyArray(cx);
    1:         if (!arrayobj)
32645:             return false;
    1:     }
31883: 
50491:     Value v;
53858:     if (!res->createLastMatch(cx, &v))
32645:         return false;
31883: 
20408:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
54169:     return !!arrayobj->setProperty(cx, INT_TO_JSID(count), &v, false);
    1: }
    1: 
22658: static JSBool
48470: str_match(JSContext *cx, uintN argc, Value *vp)
18190: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
32645: 
33165:     RegExpGuard g(cx);
33165:     if (!g.init(argc, vp))
33165:         return false;
59888:     if (const FlatMatch *fm = g.tryFlatMatch(cx, str, 1, argc))
51460:         return BuildFlatMatchArray(cx, str, *fm, vp);
60211:     if (cx->isExceptionPending())  /* from tryFlatMatch */
59888:         return false;
51460: 
51460:     const RegExpPair *rep = g.normalizeRegExp(false, 1, argc, vp);
51460:     if (!rep)
32645:         return false;
32645: 
48470:     AutoObjectRooter array(cx);
48470:     MatchArgType arg = array.addr();
62876:     RegExpStatics *res = cx->regExpStatics();
62876:     if (!DoMatch(cx, res, vp, str, *rep, MatchCallback, arg, MATCH_ARGS))
32645:         return false;
32645: 
50491:     /* When not global, DoMatch will leave |RegExp.exec()| in *vp. */
51460:     if (rep->re().global())
48470:         vp->setObjectOrNull(array.object());
32645:     return true;
18190: }
18190: 
    1: static JSBool
48470: str_search(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
32645: 
33165:     RegExpGuard g(cx);
33165:     if (!g.init(argc, vp))
33165:         return false;
59888:     if (const FlatMatch *fm = g.tryFlatMatch(cx, str, 1, argc)) {
51460:         vp->setInt32(fm->match());
33165:         return true;
33165:     }
60211:     if (cx->isExceptionPending())  /* from tryFlatMatch */
59888:         return false;
51460:     const RegExpPair *rep = g.normalizeRegExp(false, 1, argc, vp);
51460:     if (!rep)
32645:         return false;
32645: 
62876:     RegExpStatics *res = cx->regExpStatics();
32645:     size_t i = 0;
53858:     if (!rep->re().execute(cx, res, str, &i, true, vp))
32645:         return false;
32645: 
48470:     if (vp->isTrue())
57789:         vp->setInt32(res->matchStart());
33165:     else
48470:         vp->setInt32(-1);
32645:     return true;
    1: }
    1: 
34376: struct ReplaceData
34376: {
34376:     ReplaceData(JSContext *cx)
60571:      : g(cx), sb(cx)
34376:     {}
34376: 
32645:     JSString           *str;           /* 'this' parameter object as a string */
32645:     RegExpGuard        g;              /* regexp parameter object and private data */
    1:     JSObject           *lambda;        /* replacement function object or null */
56740:     JSObject           *elembase;      /* object for function(a){return b[a]} replace */
59890:     JSLinearString     *repstr;        /* replacement string */
59890:     const jschar       *dollar;        /* null or pointer to first $ in repstr */
59890:     const jschar       *dollarEnd;     /* limit pointer for js_strchr_limit */
32645:     jsint              leftIndex;      /* left context index in str->chars */
32645:     JSSubString        dollarStr;      /* for "$$" InterpretDollar result */
32645:     bool               calledBack;     /* record whether callback has been called */
55565:     InvokeSessionGuard session;        /* arguments for repeated lambda Invoke call */
55565:     InvokeArgsGuard    singleShot;     /* arguments for single lambda Invoke call */
60571:     StringBuffer       sb;             /* buffer built during DoMatch */
31883: };
    1: 
50491: static bool
59890: InterpretDollar(JSContext *cx, RegExpStatics *res, const jschar *dp, const jschar *ep,
59959:                 ReplaceData &rdata, JSSubString *out, size_t *skip)
    1: {
    1:     JS_ASSERT(*dp == '$');
    1: 
    1:     /* If there is only a dollar, bail now */
    1:     if (dp + 1 >= ep)
50491:         return false;
    1: 
    1:     /* Interpret all Perl match-induced dollar variables. */
50491:     jschar dc = dp[1];
    1:     if (JS7_ISDEC(dc)) {
    1:         /* ECMA-262 Edition 3: 1-9 or 01-99 */
50491:         uintN num = JS7_UNDEC(dc);
58510:         if (num > res->parenCount())
50491:             return false;
50491: 
59890:         const jschar *cp = dp + 2;
    1:         if (cp < ep && (dc = *cp, JS7_ISDEC(dc))) {
50491:             uintN tmp = 10 * num + JS7_UNDEC(dc);
58510:             if (tmp <= res->parenCount()) {
    1:                 cp++;
    1:                 num = tmp;
    1:             }
    1:         }
    1:         if (num == 0)
50491:             return false;
    1: 
    1:         *skip = cp - dp;
58510: 
58676:         JS_ASSERT(num <= res->parenCount());
58511: 
58510:         /* 
58510:          * Note: we index to get the paren with the (1-indexed) pair
58510:          * number, as opposed to a (0-indexed) paren number.
58510:          */
53858:         res->getParen(num, out);
50491:         return true;
    1:     }
    1: 
    1:     *skip = 2;
    1:     switch (dc) {
    1:       case '$':
32645:         rdata.dollarStr.chars = dp;
32645:         rdata.dollarStr.length = 1;
50491:         *out = rdata.dollarStr;
50491:         return true;
    1:       case '&':
53858:         res->getLastMatch(out);
50491:         return true;
    1:       case '+':
53858:         res->getLastParen(out);
50491:         return true;
    1:       case '`':
53858:         res->getLeftContext(out);
50491:         return true;
    1:       case '\'':
53858:         res->getRightContext(out);
50491:         return true;
50491:     }
50491:     return false;
    1: }
    1: 
31883: static bool
53858: FindReplaceLength(JSContext *cx, RegExpStatics *res, ReplaceData &rdata, size_t *sizep)
    1: {
56740:     JSObject *base = rdata.elembase;
56740:     if (base) {
56740:         /*
56740:          * The base object is used when replace was passed a lambda which looks like
56740:          * 'function(a) { return b[a]; }' for the base object b.  b will not change
56740:          * in the course of the replace unless we end up making a scripted call due
56740:          * to accessing a scripted getter or a value with a scripted toString.
56740:          */
56740:         JS_ASSERT(rdata.lambda);
56740:         JS_ASSERT(!base->getOps()->lookupProperty);
56740:         JS_ASSERT(!base->getOps()->getProperty);
56740: 
56740:         Value match;
56740:         if (!res->createLastMatch(cx, &match))
56740:             return false;
56740:         JSString *str = match.toString();
56740: 
56740:         JSAtom *atom;
64343:         if (str->isAtom()) {
64345:             atom = &str->asAtom();
56740:         } else {
56740:             atom = js_AtomizeString(cx, str, 0);
56740:             if (!atom)
56740:                 return false;
56740:         }
56740:         jsid id = ATOM_TO_JSID(atom);
56740: 
56740:         JSObject *holder;
56740:         JSProperty *prop = NULL;
56740:         if (js_LookupPropertyWithFlags(cx, base, id, JSRESOLVE_QUALIFIED, &holder, &prop) < 0)
56740:             return false;
56740: 
56740:         /* Only handle the case where the property exists and is on this object. */
56740:         if (prop && holder == base) {
56740:             Shape *shape = (Shape *) prop;
56740:             if (shape->slot != SHAPE_INVALID_SLOT && shape->hasDefaultGetter()) {
56740:                 Value value = base->getSlot(shape->slot);
56740:                 if (value.isString()) {
59890:                     rdata.repstr = value.toString()->ensureLinear(cx);
59890:                     if (!rdata.repstr)
59890:                         return false;
56740:                     *sizep = rdata.repstr->length();
56740:                     return true;
56740:                 }
56740:             }
56740:         }
56740: 
56740:         /*
56740:          * Couldn't handle this property, fall through and despecialize to the
56740:          * general lambda case.
56740:          */
56740:         rdata.elembase = NULL;
56740:     }
56740: 
50491:     JSObject *lambda = rdata.lambda;
    1:     if (lambda) {
    1:         /*
    1:          * In the lambda case, not only do we find the replacement string's
    1:          * length, we compute repstr and return it via rdata for use within
32645:          * DoReplace.  The lambda is called with arguments ($&, $1, $2, ...,
    1:          * index, input), i.e., all the properties of a regexp match array.
    1:          * For $&, etc., we must create string jsvals from cx->regExpStatics.
    1:          * We grab up stack space to keep the newborn strings GC-rooted.
    1:          */
58510:         uintN p = res->parenCount();
31883:         uintN argc = 1 + p + 2;
34376: 
55567:         InvokeSessionGuard &session = rdata.session;
55567:         if (!session.started()) {
55565:             Value lambdav = ObjectValue(*lambda);
55712:             if (!session.start(cx, lambdav, UndefinedValue(), argc))
31883:                 return false;
55565:         }
31883: 
55567:         PreserveRegExpStatics staticsGuard(res);
55567:         if (!staticsGuard.init(cx))
55567:             return false;
55567: 
55567:         /* Push $&, $1, $2, ... */
55565:         uintN argi = 0;
55565:         if (!res->createLastMatch(cx, &session[argi++]))
41836:             return false;
41836: 
58510:         for (size_t i = 0; i < res->parenCount(); ++i) {
58510:             if (!res->createParen(cx, i + 1, &session[argi++]))
41836:                 return false;
41836:         }
    1: 
    1:         /* Push match index and input string. */
57789:         session[argi++].setInt32(res->matchStart());
55565:         session[argi].setString(rdata.str);
55565: 
55565:         if (!session.invoke(cx))
41836:             return false;
31883: 
55566:         /* root repstr: rdata is on the stack, so scanned by conservative gc. */
59890:         JSString *repstr = ValueToString_TestForStringInline(cx, session.rval());
59890:         if (!repstr)
59890:             return false;
59890:         rdata.repstr = repstr->ensureLinear(cx);
55566:         if (!rdata.repstr)
41836:             return false;
55566:         *sizep = rdata.repstr->length();
41836:         return true;
    1:     }
    1: 
50491:     JSString *repstr = rdata.repstr;
50491:     size_t replen = repstr->length();
59959:     for (const jschar *dp = rdata.dollar, *ep = rdata.dollarEnd; dp;
59959:          dp = js_strchr_limit(dp, '$', ep)) {
50491:         JSSubString sub;
50491:         size_t skip;
58676:         if (InterpretDollar(cx, res, dp, ep, rdata, &sub, &skip)) {
50491:             replen += sub.length - skip;
    1:             dp += skip;
50491:         } else {
    1:             dp++;
    1:         }
50491:     }
    1:     *sizep = replen;
32645:     return true;
    1: }
    1: 
60571: /* 
60571:  * Precondition: |rdata.sb| already has necessary growth space reserved (as
60571:  * derived from FindReplaceLength).
60571:  */
    1: static void
60571: DoReplace(JSContext *cx, RegExpStatics *res, ReplaceData &rdata)
    1: {
59890:     JSLinearString *repstr = rdata.repstr;
59890:     const jschar *cp;
59890:     const jschar *bp = cp = repstr->chars();
57585: 
59890:     const jschar *dp = rdata.dollar;
59890:     const jschar *ep = rdata.dollarEnd;
59890:     for (; dp; dp = js_strchr_limit(dp, '$', ep)) {
60571:         /* Move one of the constant portions of the replacement value. */
50491:         size_t len = dp - cp;
64229:         rdata.sb.infallibleAppend(cp, len);
    1:         cp = dp;
50491: 
50491:         JSSubString sub;
50491:         size_t skip;
58676:         if (InterpretDollar(cx, res, dp, ep, rdata, &sub, &skip)) {
50491:             len = sub.length;
64229:             rdata.sb.infallibleAppend(sub.chars, len);
    1:             cp += skip;
    1:             dp += skip;
    1:         } else {
    1:             dp++;
    1:         }
    1:     }
60571:     JS_ALWAYS_TRUE(rdata.sb.append(cp, repstr->length() - (cp - bp)));
    1: }
    1: 
32645: static bool
59890: ReplaceRegExpCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)
    1: {
32645:     ReplaceData &rdata = *static_cast<ReplaceData *>(p);
32645: 
32645:     rdata.calledBack = true;
64345:     JSLinearString &str = rdata.str->asLinear();  /* flattened for regexp */
32645:     size_t leftoff = rdata.leftIndex;
64345:     const jschar *left = str.chars() + leftoff;
57789:     size_t leftlen = res->matchStart() - leftoff;
57789:     rdata.leftIndex = res->matchLimit();
32645: 
32645:     size_t replen = 0;  /* silence 'unused' warning */
53858:     if (!FindReplaceLength(cx, res, rdata, &replen))
32645:         return false;
32645: 
32645:     size_t growth = leftlen + replen;
60571:     if (!rdata.sb.reserve(rdata.sb.length() + growth))
32645:         return false;
64229:     rdata.sb.infallibleAppend(left, leftlen); /* skipped-over portion of the search value */
60571:     DoReplace(cx, res, rdata);
32645:     return true;
    1: }
    1: 
33165: static bool
33165: BuildFlatReplacement(JSContext *cx, JSString *textstr, JSString *repstr,
51460:                      const FlatMatch &fm, Value *vp)
33165: {
59888:     RopeBuilder builder(cx);
59888:     size_t match = fm.match();
51460:     size_t matchEnd = match + fm.patternLength();
48536: 
59888:     if (textstr->isRope()) {
48536:         /*
48536:          * If we are replacing over a rope, avoid flattening it by iterating
48536:          * through it, building a new rope.
48536:          */
59888:         StringSegmentRange r(cx);
59888:         if (!r.init(textstr))
59888:             return false;
48536:         size_t pos = 0;
59888:         while (!r.empty()) {
59888:             JSString *str = r.front();
48536:             size_t len = str->length();
48536:             size_t strEnd = pos + len;
48536:             if (pos < matchEnd && strEnd > match) {
48536:                 /*
48536:                  * We need to special-case any part of the rope that overlaps
48536:                  * with the replacement string.
48536:                  */
48536:                 if (match >= pos) {
48536:                     /*
48536:                      * If this part of the rope overlaps with the left side of
48536:                      * the pattern, then it must be the only one to overlap with
48536:                      * the first character in the pattern, so we include the
48536:                      * replacement string here.
48536:                      */
48536:                     JSString *leftSide = js_NewDependentString(cx, str, 0, match - pos);
48536:                     if (!leftSide ||
51460:                         !builder.append(leftSide) ||
51460:                         !builder.append(repstr)) {
33165:                         return false;
33165:                     }
48536:                 }
48536: 
48536:                 /*
48536:                  * If str runs off the end of the matched string, append the
48536:                  * last part of str.
48536:                  */
48536:                 if (strEnd > matchEnd) {
48536:                     JSString *rightSide = js_NewDependentString(cx, str, matchEnd - pos,
48536:                                                                 strEnd - matchEnd);
51460:                     if (!rightSide || !builder.append(rightSide))
33165:                         return false;
48536:                 }
48536:             } else {
51460:                 if (!builder.append(str))
48536:                     return false;
48536:             }
48536:             pos += str->length();
59888:             if (!r.popFront())
59888:                 return false;
48536:         }
48536:     } else {
48536:         JSString *leftSide = js_NewDependentString(cx, textstr, 0, match);
48536:         if (!leftSide)
48536:             return false;
51460:         JSString *rightSide = js_NewDependentString(cx, textstr, match + fm.patternLength(),
51460:                                                     textstr->length() - match - fm.patternLength());
48536:         if (!rightSide ||
51460:             !builder.append(leftSide) ||
51460:             !builder.append(repstr) ||
51460:             !builder.append(rightSide)) {
48536:             return false;
48536:         }
48536:     }
48536: 
59888:     vp->setString(builder.result());
33165:     return true;
33165: }
33165: 
51460: /*
51460:  * Perform a linear-scan dollar substitution on the replacement text,
51460:  * constructing a result string that looks like:
51460:  *
51460:  *      newstring = string[:matchStart] + dollarSub(replaceValue) + string[matchLimit:]
51460:  */
51460: static inline bool
59890: BuildDollarReplacement(JSContext *cx, JSString *textstrArg, JSLinearString *repstr,
51460:                        const jschar *firstDollar, const FlatMatch &fm, Value *vp)
51460: {
59890:     JSLinearString *textstr = textstrArg->ensureLinear(cx);
59890:     if (!textstr)
59890:         return NULL;
59890: 
51460:     JS_ASSERT(repstr->chars() <= firstDollar && firstDollar < repstr->chars() + repstr->length());
51460:     size_t matchStart = fm.match();
51460:     size_t matchLimit = matchStart + fm.patternLength();
51460: 
51460:     /*
51460:      * Most probably:
51460:      *
51460:      *      len(newstr) >= len(orig) - len(match) + len(replacement)
51460:      *
51460:      * Note that dollar vars _could_ make the resulting text smaller than this.
51460:      */
60571:     StringBuffer newReplaceChars(cx);
51460:     if (!newReplaceChars.reserve(textstr->length() - fm.patternLength() + repstr->length()))
51460:         return false;
51460: 
51460:     /* Move the pre-dollar chunk in bulk. */
64229:     newReplaceChars.infallibleAppend(repstr->chars(), firstDollar);
51460: 
51460:     /* Move the rest char-by-char, interpreting dollars as we encounter them. */
51460: #define ENSURE(__cond) if (!(__cond)) return false;
51460:     const jschar *repstrLimit = repstr->chars() + repstr->length();
51460:     for (const jschar *it = firstDollar; it < repstrLimit; ++it) {
51460:         if (*it != '$' || it == repstrLimit - 1) {
51460:             ENSURE(newReplaceChars.append(*it));
51460:             continue;
51460:         }
51460: 
51460:         switch (*(it + 1)) {
51460:           case '$': /* Eat one of the dollars. */
51460:             ENSURE(newReplaceChars.append(*it));
51460:             break;
51460:           case '&':
51460:             ENSURE(newReplaceChars.append(textstr->chars() + matchStart,
51460:                                           textstr->chars() + matchLimit));
51460:             break;
51460:           case '`':
51460:             ENSURE(newReplaceChars.append(textstr->chars(), textstr->chars() + matchStart));
51460:             break;
51460:           case '\'':
51460:             ENSURE(newReplaceChars.append(textstr->chars() + matchLimit,
51460:                                           textstr->chars() + textstr->length()));
51460:             break;
51460:           default: /* The dollar we saw was not special (no matter what its mother told it). */
51460:             ENSURE(newReplaceChars.append(*it));
51460:             continue;
51460:         }
51460:         ++it; /* We always eat an extra char in the above switch. */
51460:     }
51460: 
51460:     JSString *leftSide = js_NewDependentString(cx, textstr, 0, matchStart);
51460:     ENSURE(leftSide);
51460: 
60571:     JSString *newReplace = newReplaceChars.finishString();
51460:     ENSURE(newReplace);
51460: 
51460:     JS_ASSERT(textstr->length() >= matchLimit);
51460:     JSString *rightSide = js_NewDependentString(cx, textstr, matchLimit,
51460:                                                 textstr->length() - matchLimit);
51460:     ENSURE(rightSide);
51460: 
59888:     RopeBuilder builder(cx);
51460:     ENSURE(builder.append(leftSide) &&
51460:            builder.append(newReplace) &&
51460:            builder.append(rightSide));
51460: #undef ENSURE
51460: 
59888:     vp->setString(builder.result());
51460:     return true;
51460: }
51460: 
51460: static inline bool
51460: str_replace_regexp(JSContext *cx, uintN argc, Value *vp, ReplaceData &rdata)
51460: {
51460:     const RegExpPair *rep = rdata.g.normalizeRegExp(true, 2, argc, vp);
51460:     if (!rep)
51460:         return false;
51460: 
51460:     rdata.leftIndex = 0;
51460:     rdata.calledBack = false;
51460: 
62876:     RegExpStatics *res = cx->regExpStatics();
59890:     if (!DoMatch(cx, res, vp, rdata.str, *rep, ReplaceRegExpCallback, &rdata, REPLACE_ARGS))
51460:         return false;
51460: 
51460:     if (!rdata.calledBack) {
51460:         /* Didn't match, so the string is unmodified. */
51460:         vp->setString(rdata.str);
51460:         return true;
51460:     }
51460: 
51460:     JSSubString sub;
53858:     res->getRightContext(&sub);
60571:     if (!rdata.sb.append(sub.chars, sub.length))
51460:         return false;
51460: 
60571:     JSString *retstr = rdata.sb.finishString();
51460:     if (!retstr)
51460:         return false;
51460: 
51460:     vp->setString(retstr);
51460:     return true;
51460: }
51460: 
51460: static inline bool
51460: str_replace_flat_lambda(JSContext *cx, uintN argc, Value *vp, ReplaceData &rdata,
51460:                         const FlatMatch &fm)
51460: {
51460:     JS_ASSERT(fm.match() >= 0);
51460:     LeaveTrace(cx);
51460: 
51460:     JSString *matchStr = js_NewDependentString(cx, rdata.str, fm.match(), fm.patternLength());
51460:     if (!matchStr)
51460:         return false;
51460: 
51460:     /* lambda(matchStr, matchStart, textstr) */
51460:     static const uint32 lambdaArgc = 3;
55565:     if (!cx->stack().pushInvokeArgs(cx, lambdaArgc, &rdata.singleShot))
51460:         return false;
51460: 
55565:     CallArgs &args = rdata.singleShot;
51460:     args.callee().setObject(*rdata.lambda);
55712:     args.thisv().setUndefined();
51460: 
51460:     Value *sp = args.argv();
51460:     sp[0].setString(matchStr);
51460:     sp[1].setInt32(fm.match());
51460:     sp[2].setString(rdata.str);
51460: 
55565:     if (!Invoke(cx, rdata.singleShot, 0))
51460:         return false;
51460: 
51460:     JSString *repstr = js_ValueToString(cx, args.rval());
51460:     if (!repstr)
51460:         return false;
51460: 
51460:     JSString *leftSide = js_NewDependentString(cx, rdata.str, 0, fm.match());
51460:     if (!leftSide)
51460:         return false;
51460: 
51460:     size_t matchLimit = fm.match() + fm.patternLength();
51460:     JSString *rightSide = js_NewDependentString(cx, rdata.str, matchLimit,
51460:                                                 rdata.str->length() - matchLimit);
51460:     if (!rightSide)
51460:         return false;
51460: 
59888:     RopeBuilder builder(cx);
51460:     if (!(builder.append(leftSide) &&
51460:           builder.append(repstr) &&
51460:           builder.append(rightSide))) {
51460:         return false;
51460:     }
51460: 
59888:     vp->setString(builder.result());
51460:     return true;
51460: }
51460: 
48676: JSBool
48676: js::str_replace(JSContext *cx, uintN argc, Value *vp)
    1: {
32645:     ReplaceData rdata(cx);
61734:     rdata.str = ThisToStringForStringProto(cx, vp);
61734:     if (!rdata.str)
61734:         return false;
54576:     static const uint32 optarg = 2;
32645: 
33165:     /* Extract replacement string/function. */
54576:     if (argc >= optarg && js_IsCallable(vp[3])) {
48470:         rdata.lambda = &vp[3].toObject();
56740:         rdata.elembase = NULL;
32645:         rdata.repstr = NULL;
32645:         rdata.dollar = rdata.dollarEnd = NULL;
56740: 
56740:         if (rdata.lambda->isFunction()) {
56740:             JSFunction *fun = rdata.lambda->getFunctionPrivate();
56740:             if (fun->isInterpreted()) {
56740:                 /*
56740:                  * Pattern match the script to check if it is is indexing into a
56740:                  * particular object, e.g. 'function(a) { return b[a]; }'.  Avoid
56740:                  * calling the script in such cases, which are used by javascript
56740:                  * packers (particularly the popular Dean Edwards packer) to efficiently
56740:                  * encode large scripts.  We only handle the code patterns generated
56740:                  * by such packers here.
56740:                  */
56740:                 JSScript *script = fun->u.i.script;
56740:                 jsbytecode *pc = script->code;
56740: 
56740:                 Value table = UndefinedValue();
56740:                 if (JSOp(*pc) == JSOP_GETFCSLOT) {
56740:                     table = rdata.lambda->getFlatClosureUpvar(GET_UINT16(pc));
56740:                     pc += JSOP_GETFCSLOT_LENGTH;
56740:                 }
56740: 
56740:                 if (table.isObject() &&
56740:                     JSOp(*pc) == JSOP_GETARG && GET_SLOTNO(pc) == 0 &&
56740:                     JSOp(*(pc + JSOP_GETARG_LENGTH)) == JSOP_GETELEM &&
56740:                     JSOp(*(pc + JSOP_GETARG_LENGTH + JSOP_GETELEM_LENGTH)) == JSOP_RETURN) {
56740:                     Class *clasp = table.toObject().getClass();
56740:                     if (clasp->isNative() &&
56740:                         !clasp->ops.lookupProperty &&
56740:                         !clasp->ops.getProperty) {
56740:                         rdata.elembase = &table.toObject();
56740:                     }
56740:                 }
56740:             }
56740:         }
    1:     } else {
32645:         rdata.lambda = NULL;
56740:         rdata.elembase = NULL;
32645:         rdata.repstr = ArgToRootedString(cx, argc, vp, 1);
32645:         if (!rdata.repstr)
32645:             return false;
32645: 
30624:         /* We're about to store pointers into the middle of our string. */
64345:         JSFixedString *fixed = rdata.repstr->ensureFixed(cx);
64345:         if (!fixed)
32645:             return false;
64345:         rdata.dollarEnd = fixed->chars() + fixed->length();
64345:         rdata.dollar = js_strchr_limit(fixed->chars(), '$', rdata.dollarEnd);
32645:     }
32645: 
33165:     if (!rdata.g.init(argc, vp))
33165:         return false;
51460: 
51460:     /*
51460:      * Unlike its |String.prototype| brethren, |replace| doesn't convert
51460:      * its input to a regular expression. (Even if it contains metachars.)
51460:      *
51460:      * However, if the user invokes our (non-standard) |flags| argument
51460:      * extension then we revert to creating a regular expression. Note that
51460:      * this is observable behavior through the side-effect mutation of the
51460:      * |RegExp| statics.
51460:      */
51460: 
59888:     const FlatMatch *fm = rdata.g.tryFlatMatch(cx, rdata.str, optarg, argc, false);
51460:     if (!fm) {
60211:         if (cx->isExceptionPending())  /* oom in RopeMatch in tryFlatMatch */
59888:             return false;
54576:         JS_ASSERT_IF(!rdata.g.hasRegExpPair(), argc > optarg);
51460:         return str_replace_regexp(cx, argc, vp, rdata);
51460:     }
51460: 
51460:     if (fm->match() < 0) {
48470:         vp->setString(rdata.str);
32645:         return true;
32645:     }
32645: 
51460:     if (rdata.lambda)
51460:         return str_replace_flat_lambda(cx, argc, vp, rdata, *fm);
51460: 
51460:     /* 
51460:      * Note: we could optimize the text.length == pattern.length case if we wanted,
51460:      * even in the presence of dollar metachars.
51460:      */
51460:     if (rdata.dollar)
51460:         return BuildDollarReplacement(cx, rdata.str, rdata.repstr, rdata.dollar, *fm, vp);
51460: 
51460:     return BuildFlatReplacement(cx, rdata.str, rdata.repstr, *fm, vp);
    1: }
    1: 
64270: class SplitMatchResult {
64270:     size_t endIndex_;
64270:     size_t length_;
64270: 
64270:   public:
64270:     void setFailure() {
64270:         JS_STATIC_ASSERT(SIZE_MAX > JSString::MAX_LENGTH);
64270:         endIndex_ = SIZE_MAX;
64270:     }
64270:     bool isFailure() const {
64270:         return (endIndex_ == SIZE_MAX);
64270:     }
64270:     size_t endIndex() const {
64270:         JS_ASSERT(!isFailure());
64270:         return endIndex_;
64270:     }
64270:     size_t length() const {
64270:         JS_ASSERT(!isFailure());
64270:         return length_;
64270:     }
64270:     void setResult(size_t length, size_t endIndex) {
64270:         length_ = length;
64270:         endIndex_ = endIndex;
64270:     }
64270: };
64270: 
64270: template<class Matcher>
64270: static JSObject *
64270: SplitHelper(JSContext *cx, JSLinearString *str, uint32 limit, Matcher splitMatch)
64270: {
64270:     size_t strLength = str->length();
64270:     SplitMatchResult result;
64270: 
64270:     /* Step 11. */
64270:     if (strLength == 0) {
64270:         if (!splitMatch(cx, str, 0, &result))
64270:             return NULL;
64270: 
    1:         /*
64270:          * NB: Unlike in the non-empty string case, it's perfectly fine
64270:          *     (indeed the spec requires it) if we match at the end of the
64270:          *     string.  Thus these cases should hold:
    1:          *
64270:          *   var a = "".split("");
64270:          *   assertEq(a.length, 0);
64270:          *   var b = "".split(/.?/);
64270:          *   assertEq(b.length, 0);
    1:          */
64270:         if (!result.isFailure())
64270:             return NewDenseEmptyArray(cx);
64270: 
64270:         Value v = StringValue(str);
64270:         return NewDenseCopiedArray(cx, 1, &v);
64270:     }
64270: 
64270:     /* Step 12. */
64270:     size_t lastEndIndex = 0;
64270:     size_t index = 0;
64270: 
64270:     /* Step 13. */
64270:     AutoValueVector splits(cx);
64270: 
64270:     while (index < strLength) {
64270:         /* Step 13(a). */
64270:         if (!splitMatch(cx, str, index, &result))
64270:             return NULL;
64270: 
    1:         /*
64270:          * Step 13(b).
    1:          *
64270:          * Our match algorithm differs from the spec in that it returns the
64270:          * next index at which a match happens.  If no match happens we're
64270:          * done.
    1:          *
64270:          * But what if the match is at the end of the string (and the string is
64270:          * not empty)?  Per 13(c)(ii) this shouldn't be a match, so we have to
64270:          * specially exclude it.  Thus this case should hold:
64270:          *
64270:          *   var a = "abc".split(/\b/);
64270:          *   assertEq(a.length, 1);
64270:          *   assertEq(a[0], "abc");
    1:          */
64270:         if (result.isFailure())
64270:             break;
64270: 
64270:         /* Step 13(c)(i). */
64270:         size_t sepLength = result.length();
64270:         size_t endIndex = result.endIndex();
64270:         if (sepLength == 0 && endIndex == strLength)
64270:             break;
64270: 
64270:         /* Step 13(c)(ii). */
64270:         if (endIndex == lastEndIndex) {
64270:             index++;
64270:             continue;
64270:         }
64270: 
64270:         /* Step 13(c)(iii). */
64270:         JS_ASSERT(lastEndIndex < endIndex);
64270:         JS_ASSERT(sepLength <= strLength);
64270:         JS_ASSERT(lastEndIndex + sepLength <= endIndex);
64270: 
64270:         /* Steps 13(c)(iii)(1-3). */
64270:         size_t subLength = size_t(endIndex - sepLength - lastEndIndex);
64270:         JSString *sub = js_NewDependentString(cx, str, lastEndIndex, subLength);
64270:         if (!sub || !splits.append(StringValue(sub)))
64270:             return NULL;
64270: 
64270:         /* Step 13(c)(iii)(4). */
64270:         if (splits.length() == limit)
64270:             return NewDenseCopiedArray(cx, splits.length(), splits.begin());
64270: 
64270:         /* Step 13(c)(iii)(5). */
64270:         lastEndIndex = endIndex;
64270: 
64270:         /* Step 13(c)(iii)(6-7). */
64270:         if (Matcher::returnsCaptures) {
64270:             RegExpStatics *res = cx->regExpStatics();
64270:             for (size_t i = 0; i < res->parenCount(); i++) {
64270:                 /* Steps 13(c)(iii)(7)(a-c). */
64270:                 if (res->pairIsPresent(i + 1)) {
64270:                     JSSubString parsub;
64270:                     res->getParen(i + 1, &parsub);
64270:                     sub = js_NewStringCopyN(cx, parsub.chars, parsub.length);
64270:                     if (!sub || !splits.append(StringValue(sub)))
64270:                         return NULL;
64270:                 } else {
64270:                     if (!splits.append(UndefinedValue()))
64270:                         return NULL;
64270:                 }
64270: 
64270:                 /* Step 13(c)(iii)(7)(d). */
64270:                 if (splits.length() == limit)
64270:                     return NewDenseCopiedArray(cx, splits.length(), splits.begin());
64270:             }
64270:         }
64270: 
64270:         /* Step 13(c)(iii)(8). */
64270:         index = lastEndIndex;
64270:     }
64270: 
64270:     /* Steps 14-15. */
64270:     JSString *sub = js_NewDependentString(cx, str, lastEndIndex, strLength - lastEndIndex);
64270:     if (!sub || !splits.append(StringValue(sub)))
64270:         return NULL;
64270: 
64270:     /* Step 16. */
64270:     return NewDenseCopiedArray(cx, splits.length(), splits.begin());
64270: }
    1: 
    1: /*
64270:  * The SplitMatch operation from ES5 15.5.4.14 is implemented using different
64270:  * matchers for regular expression and string separators.
64270:  *
64270:  * The algorithm differs from the spec in that the matchers return the next
64270:  * index at which a match happens.
    1:  */
64270: class SplitRegExpMatcher {
64270:     RegExpStatics *res;
64270:     RegExp *re;
64270: 
64270:   public:
64270:     static const bool returnsCaptures = true;
64270:     SplitRegExpMatcher(RegExp *re, RegExpStatics *res) : res(res), re(re) {
64270:     }
64270: 
64270:     inline bool operator()(JSContext *cx, JSLinearString *str, size_t index,
64270:                            SplitMatchResult *result) {
64333:         Value rval
64333: #ifdef __GNUC__ /* quell GCC overwarning */
64333:             = UndefinedValue()
64333: #endif
64333:         ;
53858:         if (!re->execute(cx, res, str, &index, true, &rval))
64270:             return false;
48470:         if (!rval.isTrue()) {
64270:             result->setFailure();
64270:             return true;
64270:         }
64270:         JSSubString sep;
64270:         res->getLastMatch(&sep);
64270: 
64270:         result->setResult(sep.length, index);
64270:         return true;
64270:     }
64270: };
64270: 
64270: class SplitStringMatcher {
64270:     const jschar *sepChars;
64270:     size_t sepLength;
64270: 
64270:   public:
64270:     static const bool returnsCaptures = false;
64270:     SplitStringMatcher(JSLinearString *sep) {
64270:         sepChars = sep->chars();
64270:         sepLength = sep->length();
64270:     }
64270: 
64270:     inline bool operator()(JSContext *cx, JSLinearString *str, size_t index,
64270:                            SplitMatchResult *res) {
64270:         JS_ASSERT(index == 0 || index < str->length());
64270:         const jschar *chars = str->chars();
64270:         jsint match = StringMatch(chars + index, str->length() - index, sepChars, sepLength);
64270:         if (match == -1)
64270:             res->setFailure();
64270:         else
64270:             res->setResult(sepLength, index + match + sepLength);
64270:         return true;
64270:     }
64270: };
64270: 
64270: /* ES5 15.5.4.14 */
20408: static JSBool
48470: str_split(JSContext *cx, uintN argc, Value *vp)
    1: {
64270:     /* Steps 1-2. */
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
40418: 
64270:     /* Step 5: Use the second argument as the split limit, if given. */
64270:     uint32 limit;
64270:     if (argc > 1 && !vp[3].isUndefined()) {
64270:         jsdouble d;
64270:         if (!ValueToNumber(cx, vp[3], &d))
64270:             return false;
64270:         limit = js_DoubleToECMAUint32(d);
64270:     } else {
64270:         limit = UINT32_MAX;
64270:     }
64270: 
64270:     /* Step 8. */
64270:     RegExp *re = NULL;
64270:     JSLinearString *sepstr = NULL;
64270:     bool sepUndefined = (argc == 0 || vp[2].isUndefined());
64270:     if (!sepUndefined) {
64270:         if (VALUE_IS_REGEXP(cx, vp[2])) {
64270:             re = static_cast<RegExp *>(vp[2].toObject().getPrivate());
64270:         } else {
64270:             JSString *sep = js_ValueToString(cx, vp[2]);
64270:             if (!sep)
64270:                 return false;
64270:             vp[2].setString(sep);
64270: 
64270:             sepstr = sep->ensureLinear(cx);
64270:             if (!sepstr)
64270:                 return false;
64270:         }
64270:     }
64270: 
64270:     /* Step 9. */
64270:     if (limit == 0) {
64270:         JSObject *aobj = NewDenseEmptyArray(cx);
64270:         if (!aobj)
64270:             return false;
64270:         vp->setObject(*aobj);
64270:         return true;
64270:     }
64270: 
64270:     /* Step 10. */
64270:     if (sepUndefined) {
48470:         Value v = StringValue(str);
59234:         JSObject *aobj = NewDenseCopiedArray(cx, 1, &v);
40418:         if (!aobj)
40418:             return false;
48470:         vp->setObject(*aobj);
40418:         return true;
40418:     }
64270:     JSLinearString *strlin = str->ensureLinear(cx);
64270:     if (!strlin)
64270:         return false;
64270: 
64270:     /* Steps 11-15. */
64270:     JSObject *aobj;
64270:     if (re) {
64270:         aobj = SplitHelper(cx, strlin, limit, SplitRegExpMatcher(re, cx->regExpStatics()));
    1:     } else {
64270:         // NB: sepstr is anchored through its storage in vp[2].
64270:         aobj = SplitHelper(cx, strlin, limit, SplitStringMatcher(sepstr));
64270:     }
40418:     if (!aobj)
40418:         return false;
64270: 
64270:     /* Step 16. */
48470:     vp->setObject(*aobj);
40418:     return true;
    1: }
    1: 
    1: #if JS_HAS_PERL_SUBSTR
    1: static JSBool
48470: str_substr(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
61734: 
59951:     int32 length, len, begin;
59951:     if (argc > 0) {
59951:         length = int32(str->length());
59951:         if (!ValueToIntegerRange(cx, vp[2], &begin))
59951:             return false;
59951: 
59951:         if (begin >= length) {
59951:             str = cx->runtime->emptyString;
59951:             goto out;
59951:         }
    1:         if (begin < 0) {
59951:             begin += length; /* length + INT_MIN will always be less then 0 */
    1:             if (begin < 0)
    1:                 begin = 0;
    1:         }
    1: 
56555:         if (argc == 1 || vp[3].isUndefined()) {
59951:             len = length - begin;
    1:         } else {
59951:             if (!ValueToIntegerRange(cx, vp[3], &len))  
59951:                 return false;
59951: 
59951:             if (len <= 0) {
59951:                 str = cx->runtime->emptyString;
59951:                 goto out;
59951:             }
59951: 
59951:             if (uint32(length) < uint32(begin + len))
59951:                 len = length - begin;
59951:         }
59951: 
59951:         str = js_NewDependentString(cx, str, size_t(begin), size_t(len));
    1:         if (!str)
59951:             return false;
59951:     }
59951: 
59951: out:
48470:     vp->setString(str);
59951:     return true;
    1: }
    1: #endif /* JS_HAS_PERL_SUBSTR */
    1: 
    1: /*
    1:  * Python-esque sequence operations.
    1:  */
20408: static JSBool
48470: str_concat(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
61734: 
61734:     /* Set vp (aka rval) early to handle the argc == 0 case. */
61734:     vp->setString(str);
61734: 
48470:     Value *argv;
    1:     uintN i;
 4127:     for (i = 0, argv = vp + 2; i < argc; i++) {
61734:         JSString *str2 = js_ValueToString(cx, argv[i]);
    1:         if (!str2)
61734:             return false;
48470:         argv[i].setString(str2);
    1: 
    1:         str = js_ConcatStrings(cx, str, str2);
    1:         if (!str)
61734:             return false;
48470:         vp->setString(str);
23707:     }
23707: 
61734:     return true;
    1: }
    1: 
    1: static JSBool
48470: str_slice(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     if (argc == 1 && vp[1].isString() && vp[2].isInt32()) {
 4127:         size_t begin, end, length;
 4127: 
48470:         JSString *str = vp[1].toString();
48470:         begin = vp[2].toInt32();
29366:         end = str->length();
 4127:         if (begin <= end) {
 4127:             length = end - begin;
 4127:             if (length == 0) {
 4127:                 str = cx->runtime->emptyString;
 4127:             } else {
12267:                 str = (length == 1)
64345:                       ? JSAtom::getUnitStringForElement(cx, str, begin)
 4127:                       : js_NewDependentString(cx, str, begin, length);
    1:                 if (!str)
    1:                     return JS_FALSE;
 4127:             }
48470:             vp->setString(str);
 4127:             return JS_TRUE;
 4127:         }
 4127:     }
 4127: 
61734:     JSString *str = ThisToStringForStringProto(cx, vp);
61734:     if (!str)
61734:         return false;
    1: 
    1:     if (argc != 0) {
 4127:         double begin, end, length;
 4127: 
40828:         if (!ValueToNumber(cx, vp[2], &begin))
    1:             return JS_FALSE;
 4127:         begin = js_DoubleToInteger(begin);
29366:         length = str->length();
    1:         if (begin < 0) {
    1:             begin += length;
    1:             if (begin < 0)
    1:                 begin = 0;
    1:         } else if (begin > length) {
    1:             begin = length;
    1:         }
    1: 
56555:         if (argc == 1 || vp[3].isUndefined()) {
    1:             end = length;
    1:         } else {
40828:             if (!ValueToNumber(cx, vp[3], &end))
    1:                 return JS_FALSE;
 4127:             end = js_DoubleToInteger(end);
    1:             if (end < 0) {
    1:                 end += length;
    1:                 if (end < 0)
    1:                     end = 0;
    1:             } else if (end > length) {
    1:                 end = length;
    1:             }
    1:             if (end < begin)
    1:                 end = begin;
    1:         }
    1: 
 4127:         str = js_NewDependentString(cx, str,
 4127:                                     (size_t)begin,
 4076:                                     (size_t)(end - begin));
    1:         if (!str)
    1:             return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_STR_HTML_HELPERS
    1: /*
    1:  * HTML composition aids.
    1:  */
59890: static bool
59890: tagify(JSContext *cx, const char *begin, JSLinearString *param, const char *end,
48470:        Value *vp)
    1: {
61734:     JSString *thisstr = ThisToStringForStringProto(cx, vp);
61734:     if (!thisstr)
61734:         return false;
59890:     JSLinearString *str = thisstr->ensureLinear(cx);
59890:     if (!str)
59890:         return false;
    1: 
    1:     if (!end)
    1:         end = begin;
    1: 
59890:     size_t beglen = strlen(begin);
59890:     size_t taglen = 1 + beglen + 1;                     /* '<begin' + '>' */
59890:     size_t parlen = 0; /* Avoid warning. */
    1:     if (param) {
29366:         parlen = param->length();
    1:         taglen += 2 + parlen + 1;                       /* '="param"' */
    1:     }
59890:     size_t endlen = strlen(end);
29366:     taglen += str->length() + 2 + endlen + 1;           /* 'str</end>' */
    1: 
    1:     if (taglen >= ~(size_t)0 / sizeof(jschar)) {
12983:         js_ReportAllocationOverflow(cx);
59890:         return false;
59890:     }
59890: 
64560:     jschar *tagbuf = (jschar *) cx->malloc_((taglen + 1) * sizeof(jschar));
    1:     if (!tagbuf)
59890:         return false;
59890: 
59890:     size_t j = 0;
    1:     tagbuf[j++] = '<';
59890:     for (size_t i = 0; i < beglen; i++)
    1:         tagbuf[j++] = (jschar)begin[i];
    1:     if (param) {
    1:         tagbuf[j++] = '=';
    1:         tagbuf[j++] = '"';
29366:         js_strncpy(&tagbuf[j], param->chars(), parlen);
    1:         j += parlen;
    1:         tagbuf[j++] = '"';
    1:     }
    1:     tagbuf[j++] = '>';
59890: 
29366:     js_strncpy(&tagbuf[j], str->chars(), str->length());
29366:     j += str->length();
    1:     tagbuf[j++] = '<';
    1:     tagbuf[j++] = '/';
59890:     for (size_t i = 0; i < endlen; i++)
    1:         tagbuf[j++] = (jschar)end[i];
    1:     tagbuf[j++] = '>';
    1:     JS_ASSERT(j == taglen);
    1:     tagbuf[j] = 0;
    1: 
59890:     JSString *retstr = js_NewString(cx, tagbuf, taglen);
59890:     if (!retstr) {
64560:         Foreground::free_((char *)tagbuf);
59890:         return false;
59890:     }
59890:     vp->setString(retstr);
59890:     return true;
    1: }
    1: 
    1: static JSBool
48470: tagify_value(JSContext *cx, uintN argc, Value *vp,
16519:              const char *begin, const char *end)
    1: {
59890:     JSLinearString *param = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!param)
    1:         return JS_FALSE;
 4127:     return tagify(cx, begin, param, end, vp);
    1: }
    1: 
    1: static JSBool
48470: str_bold(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "b", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_italics(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "i", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_fixed(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "tt", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_fontsize(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "font size", "font");
    1: }
    1: 
    1: static JSBool
48470: str_fontcolor(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "font color", "font");
    1: }
    1: 
    1: static JSBool
48470: str_link(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "a href", "a");
    1: }
    1: 
    1: static JSBool
48470: str_anchor(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return tagify_value(cx, argc, vp, "a name", "a");
    1: }
    1: 
    1: static JSBool
48470: str_strike(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "strike", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_small(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "small", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_big(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "big", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_blink(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "blink", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_sup(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "sup", NULL, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: str_sub(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return tagify(cx, "sub", NULL, NULL, vp);
    1: }
    1: #endif /* JS_HAS_STR_HTML_HELPERS */
    1: 
20408: #ifdef JS_TRACER
20408: JSString* FASTCALL
20408: js_String_getelem(JSContext* cx, JSString* str, int32 i)
20408: {
29366:     if ((size_t)i >= str->length())
20408:         return NULL;
64345:     return JSAtom::getUnitStringForElement(cx, str, size_t(i));
20408: }
20930: #endif
20408: 
27059: JS_DEFINE_TRCINFO_1(str_concat,
48613:     (3, (extern, STRING_RETRY, js_ConcatStrings, CONTEXT, THIS_STRING, STRING,
48613:          1, nanojit::ACCSET_NONE)))
20408: 
    1: static JSFunctionSpec string_methods[] = {
    1: #if JS_HAS_TOSOURCE
59941:     JS_FN("quote",             str_quote,             0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN(js_toSource_str,     str_toSource,          0,0),
    1: #endif
    1: 
    1:     /* Java-like methods. */
59941:     JS_FN(js_toString_str,     js_str_toString,       0,0),
59941:     JS_FN(js_valueOf_str,      js_str_toString,       0,0),
59941:     JS_FN("substring",         str_substring,         2,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("toLowerCase",       str_toLowerCase,       0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("toUpperCase",       str_toUpperCase,       0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("charAt",            js_str_charAt,         1,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("charCodeAt",        js_str_charCodeAt,     1,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("indexOf",           str_indexOf,           1,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("lastIndexOf",       str_lastIndexOf,       1,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("trim",              str_trim,              0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("trimLeft",          str_trimLeft,          0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("trimRight",         str_trimRight,         0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("toLocaleLowerCase", str_toLocaleLowerCase, 0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("toLocaleUpperCase", str_toLocaleUpperCase, 0,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("localeCompare",     str_localeCompare,     1,JSFUN_GENERIC_NATIVE),
    1: 
    1:     /* Perl-ish methods (search is actually Python-esque). */
59941:     JS_FN("match",             str_match,             1,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("search",            str_search,            1,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("replace",           str_replace,           2,JSFUN_GENERIC_NATIVE),
59941:     JS_FN("split",             str_split,             2,JSFUN_GENERIC_NATIVE),
    1: #if JS_HAS_PERL_SUBSTR
59941:     JS_FN("substr",            str_substr,            2,JSFUN_GENERIC_NATIVE),
    1: #endif
    1: 
    1:     /* Python-esque sequence methods. */
59941:     JS_TN("concat",            str_concat,            1,JSFUN_GENERIC_NATIVE, &str_concat_trcinfo),
59941:     JS_FN("slice",             str_slice,             2,JSFUN_GENERIC_NATIVE),
    1: 
    1:     /* HTML string methods. */
    1: #if JS_HAS_STR_HTML_HELPERS
59941:     JS_FN("bold",              str_bold,              0,0),
59941:     JS_FN("italics",           str_italics,           0,0),
59941:     JS_FN("fixed",             str_fixed,             0,0),
59941:     JS_FN("fontsize",          str_fontsize,          1,0),
59941:     JS_FN("fontcolor",         str_fontcolor,         1,0),
59941:     JS_FN("link",              str_link,              1,0),
59941:     JS_FN("anchor",            str_anchor,            1,0),
59941:     JS_FN("strike",            str_strike,            0,0),
59941:     JS_FN("small",             str_small,             0,0),
59941:     JS_FN("big",               str_big,               0,0),
59941:     JS_FN("blink",             str_blink,             0,0),
59941:     JS_FN("sup",               str_sup,               0,0),
59941:     JS_FN("sub",               str_sub,               0,0),
    1: #endif
    1: 
 4127:     JS_FS_END
    1: };
    1: 
32676: /*
48610:  * Set up some tools to make it easier to generate large tables. After constant
48610:  * folding, for each n, Rn(0) is the comma-separated list R(0), R(1), ..., R(2^n-1).
48610:  * Similary, Rn(k) (for any k and n) generates the list R(k), R(k+1), ..., R(k+2^n-1).
48610:  * To use this, define R appropriately, then use Rn(0) (for some value of n), then
48610:  * undefine R.
32676:  */
48610: #define R2(n)  R(n),   R((n) + (1 << 0)),    R((n) + (2 << 0)),    R((n) + (3 << 0))
48610: #define R4(n)  R2(n),  R2((n) + (1 << 2)),   R2((n) + (2 << 2)),   R2((n) + (3 << 2))
48610: #define R6(n)  R4(n),  R4((n) + (1 << 4)),   R4((n) + (2 << 4)),   R4((n) + (3 << 4))
48610: #define R8(n)  R6(n),  R6((n) + (1 << 6)),   R6((n) + (2 << 6)),   R6((n) + (3 << 6))
48610: #define R10(n) R8(n),  R8((n) + (1 << 8)),   R8((n) + (2 << 8)),   R8((n) + (3 << 8))
48610: #define R12(n) R10(n), R10((n) + (1 << 10)), R10((n) + (2 << 10)), R10((n) + (3 << 10))
48610: 
48610: #define R3(n) R2(n), R2((n) + (1 << 2))
48610: #define R7(n) R6(n), R6((n) + (1 << 6))
48610: 
59888: #define BUILD_LENGTH_AND_FLAGS(length, flags)                                 \
59888:     (((length) << JSString::LENGTH_SHIFT) | (flags))
59888: 
48610: /*
48610:  * Declare unit strings. Pack the string data itself into the mInlineChars
48610:  * place in the header.
48610:  */
48610: #define R(c) {                                                                \
64343:     BUILD_LENGTH_AND_FLAGS(1, JSString::STATIC_ATOM_FLAGS),                   \
64345:     { (jschar *)(((char *)(unitStaticTable + (c))) +                          \
64345:       offsetof(JSString::Data, inlineStorage)) },                             \
48610:     { {(c), 0x00} } }
32676: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(8)
32733: #else
32697: #pragma pack(push, 8)
32733: #endif
32697: 
64345: const JSString::Data JSAtom::unitStaticTable[]
32698: #ifdef __GNUC__
32698: __attribute__ ((aligned (8)))
32698: #endif
48610: = { R8(0) };
32697: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(0)
32733: #else
32697: #pragma pack(pop)
32733: #endif
32698: 
48610: #undef R
32676: 
32676: /*
48610:  * Declare length-2 strings. We only store strings where both characters are
48610:  * alphanumeric. The lower 10 short chars are the numerals, the next 26 are
48610:  * the lowercase letters, and the next 26 are the uppercase letters.
32676:  */
48610: #define TO_SMALL_CHAR(c) ((c) >= '0' && (c) <= '9' ? (c) - '0' :              \
48610:                           (c) >= 'a' && (c) <= 'z' ? (c) - 'a' + 10 :         \
48610:                           (c) >= 'A' && (c) <= 'Z' ? (c) - 'A' + 36 :         \
64345:                           JSAtom::INVALID_SMALL_CHAR)
48610: 
48610: #define R TO_SMALL_CHAR
48610: 
64345: const JSAtom::SmallChar JSAtom::toSmallChar[] = { R7(0) };
48610: 
48610: #undef R
48610: 
48610: /*
48610:  * This is used when we generate our table of short strings, so the compiler is
48610:  * happier if we use |c| as few times as possible.
48610:  */
48610: #define FROM_SMALL_CHAR(c) ((c) + ((c) < 10 ? '0' :      \
48610:                                    (c) < 36 ? 'a' - 10 : \
48610:                                    'A' - 36))
48610: #define R FROM_SMALL_CHAR
48610: 
64345: const jschar JSAtom::fromSmallChar[] = { R6(0) };
48610: 
48610: #undef R
48610: 
48610: /*
48610:  * For code-generation ease, length-2 strings are encoded as 12-bit int values,
48610:  * where the upper 6 bits is the first character and the lower 6 bits is the
48610:  * second character.
48610:  */
48610: #define R(c) {                                                                \
64343:     BUILD_LENGTH_AND_FLAGS(2, JSString::STATIC_ATOM_FLAGS),                   \
64345:     { (jschar *)(((char *)(length2StaticTable + (c))) +                       \
64345:       offsetof(JSString::Data, inlineStorage)) },                             \
48610:     { {FROM_SMALL_CHAR((c) >> 6), FROM_SMALL_CHAR((c) & 0x3F), 0x00} } }
32676: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(8)
32733: #else
32697: #pragma pack(push, 8)
32733: #endif
32697: 
64345: const JSString::Data JSAtom::length2StaticTable[]
32698: #ifdef __GNUC__
32698: __attribute__ ((aligned (8)))
32698: #endif
48610: = { R12(0) };
32676: 
32733: #ifdef __SUNPRO_CC
32733: #pragma pack(0)
32733: #else
32697: #pragma pack(pop)
32733: #endif
32697: 
48610: #undef R
48610: 
48610: /*
48610:  * Declare int strings. Only int strings from 100 to 255 actually have to be
48610:  * generated, since the rest are either unit strings or length-2 strings. To
48610:  * avoid the runtime cost of figuring out where to look for the string for a
48610:  * particular integer, we precompute a table of JSString*s which refer to the
48610:  * correct location of the int string.
48610:  */
48610: #define R(c) {                                                                \
64343:     BUILD_LENGTH_AND_FLAGS(3, JSString::STATIC_ATOM_FLAGS),                   \
64345:     { (jschar *)(((char *)(hundredStaticTable + ((c) - 100))) +               \
64345:       offsetof(JSString::Data, inlineStorage)) },                             \
48610:     { {((c) / 100) + '0', ((c) / 10 % 10) + '0', ((c) % 10) + '0', 0x00} } }
48610: 
48610: 
48610: JS_STATIC_ASSERT(100 + (1 << 7) + (1 << 4) + (1 << 3) + (1 << 2) == 256);
48610: 
48610: #ifdef __SUNPRO_CC
48610: #pragma pack(8)
48610: #else
48610: #pragma pack(push, 8)
48610: #endif
48610: 
64345: const JSString::Data JSAtom::hundredStaticTable[]
48610: #ifdef __GNUC__
48610: __attribute__ ((aligned (8)))
48610: #endif
48610: = { R7(100), /* 100 through 227 */
48610:     R4(100 + (1 << 7)), /* 228 through 243 */
48610:     R3(100 + (1 << 7) + (1 << 4)), /* 244 through 251 */
48610:     R2(100 + (1 << 7) + (1 << 4) + (1 << 3)) /* 252 through 255 */
32702: };
32702: 
48610: #undef R
48610: 
64345: #define R(c) ((c) < 10 ? JSAtom::unitStaticTable + ((c) + '0') :              \
64345:               (c) < 100 ? JSAtom::length2StaticTable +                        \
48610:               ((size_t)TO_SMALL_CHAR(((c) / 10) + '0') << 6) +                \
48610:               TO_SMALL_CHAR(((c) % 10) + '0') :                               \
64345:               JSAtom::hundredStaticTable + ((c) - 100))
64345: 
64345: const JSString::Data *const JSAtom::intStaticTable[] = { R8(0) };
48610: 
48610: #undef R
48610: 
48610: #ifdef __SUNPRO_CC
48610: #pragma pack(0)
48610: #else
48610: #pragma pack(pop)
48610: #endif
48610: 
48610: #undef R2
48610: #undef R4
48610: #undef R6
48610: #undef R8
48610: #undef R10
48610: #undef R12
48610: 
48610: #undef R3
48610: #undef R7
32702: 
26008: JSBool
50489: js_String(JSContext *cx, uintN argc, Value *vp)
    1: {
53557:     Value *argv = vp + 2;
53557: 
    1:     JSString *str;
    1:     if (argc > 0) {
53557:         str = js_ValueToString(cx, argv[0]);
    1:         if (!str)
53557:             return false;
    1:     } else {
    1:         str = cx->runtime->emptyString;
    1:     }
50489: 
53557:     if (IsConstructing(vp)) {
50489:         JSObject *obj = NewBuiltinClassInstance(cx, &js_StringClass);
67942:         if (!obj || !obj->initString(cx, str))
53557:             return false;
50489:         vp->setObject(*obj);
50489:     } else {
50489:         vp->setString(str);
50489:     }
53557:     return true;
    1: }
    1: 
20408: static JSBool
48470: str_fromCharCode(JSContext *cx, uintN argc, Value *vp)
    1: {
64345:     Value *argv = JS_ARGV(cx, vp);
31823:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
40828:     if (argc == 1) {
40828:         uint16_t code;
40828:         if (!ValueToUint16(cx, argv[0], &code))
40828:             return JS_FALSE;
64345:         if (JSAtom::hasUnitStatic(code)) {
64345:             vp->setString(&JSAtom::unitStatic(code));
17914:             return JS_TRUE;
17914:         }
48470:         argv[0].setInt32(code);
40828:     }
64560:     jschar *chars = (jschar *) cx->malloc_((argc + 1) * sizeof(jschar));
    1:     if (!chars)
    1:         return JS_FALSE;
64345:     for (uintN i = 0; i < argc; i++) {
40828:         uint16_t code;
40828:         if (!ValueToUint16(cx, argv[i], &code)) {
64560:             cx->free_(chars);
    1:             return JS_FALSE;
    1:         }
    1:         chars[i] = (jschar)code;
    1:     }
64345:     chars[argc] = 0;
64345:     JSString *str = js_NewString(cx, chars, argc);
    1:     if (!str) {
64560:         cx->free_(chars);
    1:         return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
27059: #ifdef JS_TRACER
27059: static JSString* FASTCALL
27059: String_fromCharCode(JSContext* cx, int32 i)
27059: {
27059:     JS_ASSERT(JS_ON_TRACE(cx));
27059:     jschar c = (jschar)i;
64345:     if (JSAtom::hasUnitStatic(c))
64345:         return &JSAtom::unitStatic(c);
27059:     return js_NewStringCopyN(cx, &c, 1);
27059: }
27059: #endif
27059: 
27059: JS_DEFINE_TRCINFO_1(str_fromCharCode,
48613:     (2, (static, STRING_RETRY, String_fromCharCode, CONTEXT, INT32, 1, nanojit::ACCSET_NONE)))
27059: 
    1: static JSFunctionSpec string_static_methods[] = {
32669:     JS_TN("fromCharCode", str_fromCharCode, 1, 0, &str_fromCharCode_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
67942: const Shape *
67942: JSObject::assignInitialStringShape(JSContext *cx)
67942: {
67942:     JS_ASSERT(!cx->compartment->initialStringShape);
67942:     JS_ASSERT(isString());
67942:     JS_ASSERT(nativeEmpty());
67942: 
67942:     return addDataProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom),
67942:                            JSSLOT_STRING_LENGTH, JSPROP_PERMANENT | JSPROP_READONLY);
67942: }
67942: 
    1: JSObject *
67942: js_InitStringClass(JSContext *cx, JSObject *global)
    1: {
67942:     JS_ASSERT(global->isGlobal());
67942:     JS_ASSERT(global->isNative());
67942: 
67942:     /*
67942:      * Define escape/unescape, the URI encode/decode functions, and maybe
67942:      * uneval on the global object.
67942:      */
67942:     if (!JS_DefineFunctions(cx, global, string_functions))
    1:         return NULL;
    1: 
67942:     /* Create and initialize String.prototype. */
67942:     JSObject *objectProto;
67942:     if (!js_GetClassPrototype(cx, global, JSProto_Object, &objectProto))
    1:         return NULL;
67942: 
67942:     JSObject *proto = NewObject<WithProto::Class>(cx, &js_StringClass, objectProto, global);
67942:     if (!proto || !proto->initString(cx, cx->runtime->emptyString))
67942:         return NULL;
67942: 
67942:     /* Now create the String function. */
67942:     JSAtom *atom = CLASS_ATOM(cx, String);
67942:     JSFunction *ctor = js_NewFunction(cx, NULL, js_String, 1, JSFUN_CONSTRUCTOR, global, atom);
67942:     if (!ctor)
67942:         return NULL;
67942: 
67942:     /* String creates string objects. */
67942:     FUN_CLASP(ctor) = &js_StringClass;
67942: 
67942:     /* Define String.prototype and String.prototype.constructor. */
67942:     if (!ctor->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
67942:                               ObjectValue(*proto), PropertyStub, StrictPropertyStub,
67942:                               JSPROP_PERMANENT | JSPROP_READONLY) ||
67942:         !proto->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
67942:                                ObjectValue(*ctor), PropertyStub, StrictPropertyStub, 0))
67942:     {
67942:         return NULL;
67942:     }
67942: 
67942:     /* Add properties and methods to the prototype and the constructor. */
67942:     if (!JS_DefineFunctions(cx, proto, string_methods) ||
67942:         !JS_DefineFunctions(cx, ctor, string_static_methods))
67942:     {
67942:         return NULL;
67942:     }
67942: 
67942:     /* Pre-brand String and String.prototype for trace-jitted code. */
67942:     proto->brand(cx);
67942:     ctor->brand(cx);
67942: 
67942:     /*
67942:      * Make sure proto's emptyShape is available to be shared by String
67942:      * objects. JSObject::emptyShape is a one-slot cache. If we omit this, some
67942:      * other class could snap it up. (The risk is particularly great for
67942:      * Object.prototype.)
67942:      *
67942:      * All callers of JSObject::initSharingEmptyShape depend on this.
67942:      */
67942:     if (!proto->getEmptyShape(cx, &js_StringClass, FINALIZE_OBJECT0))
67942:         return NULL;
67942: 
67942:     /* Install the fully-constructed String and String.prototype. */
67942:     if (!DefineConstructorAndPrototype(cx, global, JSProto_String, ctor, proto))
67942:         return NULL;
26535: 
    1:     return proto;
    1: }
    1: 
64345: JSFixedString *
 4718: js_NewString(JSContext *cx, jschar *chars, size_t length)
    1: {
64345:     if (!CheckStringLength(cx, length))
27474:         return NULL;
27474: 
64345:     return JSFixedString::new_(cx, chars, length);
64345: }
64345: 
67901: static JS_ALWAYS_INLINE JSFixedString *
56713: NewShortString(JSContext *cx, const jschar *chars, size_t length)
56713: {
67901:     /*
67901:      * Don't bother trying to find a static atom; measurement shows that not
67901:      * many get here (for one, Atomize is catching them).
67901:      */
67901: 
64345:     JS_ASSERT(JSShortString::lengthFits(length));
67901:     JSInlineString *str = JSInlineString::lengthFits(length)
67901:                           ? JSInlineString::new_(cx)
67901:                           : JSShortString::new_(cx);
56713:     if (!str)
56713:         return NULL;
67901: 
56713:     jschar *storage = str->init(length);
64345:     PodCopy(storage, chars, length);
56713:     storage[length] = 0;
64345:     return str;
64345: }
64345: 
67901: static JSInlineString *
56713: NewShortString(JSContext *cx, const char *chars, size_t length)
56713: {
64345:     JS_ASSERT(JSShortString::lengthFits(length));
67901:     JSInlineString *str = JSInlineString::lengthFits(length)
67901:                           ? JSInlineString::new_(cx)
67901:                           : JSShortString::new_(cx);
56713:     if (!str)
56713:         return NULL;
67901: 
56713:     jschar *storage = str->init(length);
56713:     if (js_CStringsAreUTF8) {
56713: #ifdef DEBUG
56713:         size_t oldLength = length;
56713: #endif
64345:         if (!js_InflateUTF8StringToBuffer(cx, chars, length, storage, &length))
56713:             return NULL;
56713:         JS_ASSERT(length <= oldLength);
56713:         storage[length] = 0;
56713:         str->resetLength(length);
56713:     } else {
56713:         size_t n = length;
56713:         jschar *p = storage;
56713:         while (n--)
59890:             *p++ = (unsigned char)*chars++;
56713:         *p = 0;
56713:     }
64345:     return str;
56713: }
56713: 
67904: jschar *
67904: StringBuffer::extractWellSized()
67904: {
67904:     size_t capacity = cb.capacity();
67904:     size_t length = cb.length();
67904: 
67904:     jschar *buf = cb.extractRawBuffer();
67904:     if (!buf)
67904:         return NULL;
67904: 
67904:     /* For medium/big buffers, avoid wasting more than 1/4 of the memory. */
67904:     JS_ASSERT(capacity >= length);
67904:     if (length > CharBuffer::sMaxInlineStorage &&
67904:         capacity - length > (length >> 2)) {
67904:         size_t bytes = sizeof(jschar) * (length + 1);
67904:         JSContext *cx = context();
67904:         jschar *tmp = (jschar *)cx->realloc_(buf, bytes);
67904:         if (!tmp) {
67904:             cx->free_(buf);
67904:             return NULL;
67904:         }
67904:         buf = tmp;
67904:     }
67904: 
67904:     return buf;
67904: }
31505: 
64345: JSFixedString *
60571: StringBuffer::finishString()
31477: {
60571:     JSContext *cx = context();
31477:     if (cb.empty())
64345:         return cx->runtime->atomState.emptyAtom;
31477: 
31925:     size_t length = cb.length();
60571:     if (!checkLength(length))
60571:         return NULL;
60571: 
64345:     JS_STATIC_ASSERT(JSShortString::MAX_SHORT_LENGTH < CharBuffer::InlineLength);
64345:     if (JSShortString::lengthFits(length))
56713:         return NewShortString(cx, cb.begin(), length);
56713: 
31477:     if (!cb.append('\0'))
31477:         return NULL;
31477: 
67904:     jschar *buf = extractWellSized();
31477:     if (!buf)
31477:         return NULL;
31477: 
64345:     JSFixedString *str = js_NewString(cx, buf, length);
31477:     if (!str)
64560:         cx->free_(buf);
31477:     return str;
31477: }
31477: 
64383: JSAtom *
64383: StringBuffer::finishAtom()
64383: {
64383:     JSContext *cx = context();
64383: 
64383:     size_t length = cb.length();
64383:     if (length == 0)
64383:         return cx->runtime->atomState.emptyAtom;
64383: 
64383:     JSAtom *atom = js_AtomizeChars(cx, cb.begin(), length, 0);
64383:     cb.clear();
64383:     return atom;
64383: }
64383: 
59890: JSLinearString *
64345: js_NewDependentString(JSContext *cx, JSString *baseArg, size_t start, size_t length)
    1: {
    1:     if (length == 0)
    1:         return cx->runtime->emptyString;
    1: 
59890:     JSLinearString *base = baseArg->ensureLinear(cx);
59890:     if (!base)
59890:         return NULL;
59890: 
29366:     if (start == 0 && length == base->length())
    1:         return base;
    1: 
59890:     const jschar *chars = base->chars() + start;
59890: 
64345:     if (JSLinearString *staticStr = JSAtom::lookupStatic(chars, length))
56740:         return staticStr;
54160: 
64345:     return JSDependentString::new_(cx, base, chars, length);
    1: }
    1: 
    1: #ifdef DEBUG
    1: #include <math.h>
    1: 
10217: void printJSStringStats(JSRuntime *rt)
10217: {
10217:     double mean, sigma;
10217: 
10217:     mean = JS_MeanAndStdDev(rt->totalStrings, rt->lengthSum,
10217:                             rt->lengthSquaredSum, &sigma);
10217: 
    1:     fprintf(stderr, "%lu total strings, mean length %g (sigma %g)\n",
10217:             (unsigned long)rt->totalStrings, mean, sigma);
10217: 
10217:     mean = JS_MeanAndStdDev(rt->totalDependentStrings, rt->strdepLengthSum,
10217:                             rt->strdepLengthSquaredSum, &sigma);
10217: 
    1:     fprintf(stderr, "%lu total dependent strings, mean length %g (sigma %g)\n",
10217:             (unsigned long)rt->totalDependentStrings, mean, sigma);
    1: }
    1: #endif
    1: 
64345: JSFixedString *
 4076: js_NewStringCopyN(JSContext *cx, const jschar *s, size_t n)
    1: {
64345:     if (JSShortString::lengthFits(n))
48563:         return NewShortString(cx, s, n);
48563: 
64560:     jschar *news = (jschar *) cx->malloc_((n + 1) * sizeof(jschar));
    1:     if (!news)
    1:         return NULL;
    1:     js_strncpy(news, s, n);
    1:     news[n] = 0;
64345:     JSFixedString *str = js_NewString(cx, news, n);
    1:     if (!str)
64560:         cx->free_(news);
    1:     return str;
    1: }
    1: 
64345: JSFixedString *
48563: js_NewStringCopyN(JSContext *cx, const char *s, size_t n)
48563: {
64345:     if (JSShortString::lengthFits(n))
48563:         return NewShortString(cx, s, n);
59890: 
59890:     jschar *chars = js_InflateString(cx, s, &n);
59890:     if (!chars)
59890:         return NULL;
64345:     JSFixedString *str = js_NewString(cx, chars, n);
59890:     if (!str)
64560:         cx->free_(chars);
59890:     return str;
59890: }
59890: 
64345: JSFixedString *
 4076: js_NewStringCopyZ(JSContext *cx, const jschar *s)
    1: {
59890:     size_t n = js_strlen(s);
64345:     if (JSShortString::lengthFits(n))
48563:         return NewShortString(cx, s, n);
48563: 
59890:     size_t m = (n + 1) * sizeof(jschar);
64560:     jschar *news = (jschar *) cx->malloc_(m);
    1:     if (!news)
    1:         return NULL;
    1:     memcpy(news, s, m);
64345:     JSFixedString *str = js_NewString(cx, news, n);
    1:     if (!str)
64560:         cx->free_(news);
    1:     return str;
    1: }
    1: 
64345: JSFixedString *
48563: js_NewStringCopyZ(JSContext *cx, const char *s)
48563: {
48563:     return js_NewStringCopyN(cx, s, strlen(s));
48563: }
48563: 
57812: const char *
57812: js_ValueToPrintable(JSContext *cx, const Value &v, JSAutoByteString *bytes, bool asSource)
    1: {
    1:     JSString *str;
    1: 
57812:     str = (asSource ? js_ValueToSource : js_ValueToString)(cx, v);
    1:     if (!str)
    1:         return NULL;
    1:     str = js_QuoteString(cx, str, 0);
    1:     if (!str)
    1:         return NULL;
57812:     return bytes->encode(cx, str);
    1: }
    1: 
48470: JSString *
48470: js_ValueToString(JSContext *cx, const Value &arg)
    1: {
48470:     Value v = arg;
48470:     if (v.isObject() && !DefaultValue(cx, &v.toObject(), JSTYPE_STRING, &v))
48470:         return NULL;
48470: 
    1:     JSString *str;
48470:     if (v.isString()) {
48470:         str = v.toString();
48470:     } else if (v.isInt32()) {
57760:         str = js_IntToString(cx, v.toInt32());
48470:     } else if (v.isDouble()) {
48470:         str = js_NumberToString(cx, v.toDouble());
48470:     } else if (v.isBoolean()) {
48470:         str = js_BooleanToString(cx, v.toBoolean());
48470:     } else if (v.isNull()) {
64345:         str = cx->runtime->atomState.nullAtom;
    1:     } else {
64345:         str = cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
    1:     }
    1:     return str;
    1: }
    1: 
30023: /* This function implements E-262-3 section 9.8, toString. */
60571: bool
67950: js::ValueToStringBufferSlow(JSContext *cx, const Value &arg, StringBuffer &sb)
30023: {
48470:     Value v = arg;
48470:     if (v.isObject() && !DefaultValue(cx, &v.toObject(), JSTYPE_STRING, &v))
59890:         return false;
51451: 
67950:     if (v.isString())
67950:         return sb.append(v.toString());
48470:     if (v.isNumber())
60571:         return NumberValueToStringBuffer(cx, v, sb);
48470:     if (v.isBoolean())
60571:         return BooleanToStringBuffer(cx, v.toBoolean(), sb);
48470:     if (v.isNull())
60571:         return sb.append(cx->runtime->atomState.nullAtom);
48470:     JS_ASSERT(v.isUndefined());
60571:     return sb.append(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
30023: }
30023: 
    1: JS_FRIEND_API(JSString *)
48470: js_ValueToSource(JSContext *cx, const Value &v)
    1: {
48470:     if (v.isUndefined())
64345:         return cx->runtime->atomState.void0Atom;
48470:     if (v.isString())
48470:         return js_QuoteString(cx, v.toString(), '"');
48470:     if (v.isPrimitive()) {
    1:         /* Special case to preserve negative zero, _contra_ toString. */
48470:         if (v.isDouble() && JSDOUBLE_IS_NEGZERO(v.toDouble())) {
    1:             /* NB: _ucNstr rather than _ucstr to indicate non-terminated. */
    1:             static const jschar js_negzero_ucNstr[] = {'-', '0'};
    1: 
 4076:             return js_NewStringCopyN(cx, js_negzero_ucNstr, 2);
    1:         }
    1:         return js_ValueToString(cx, v);
    1:     }
    1: 
67921:     Value rval = NullValue();
67921:     Value fval;
67921:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.toSourceAtom);
67921:     if (!js_GetMethod(cx, &v.toObject(), id, JSGET_NO_METHOD_BARRIER, &fval))
67921:         return false;
67921:     if (js_IsCallable(fval)) {
67921:         if (!ExternalInvoke(cx, v, fval, 0, NULL, &rval))
67921:             return false;
67921:     }
67921: 
67921:     return js_ValueToString(cx, rval);
    1: }
    1: 
59890: namespace js {
59890: 
59890: bool
59890: EqualStrings(JSContext *cx, JSString *str1, JSString *str2, JSBool *result)
59890: {
59890:     if (str1 == str2) {
59890:         *result = true;
59890:         return true;
59890:     }
59890: 
59890:     size_t length1 = str1->length();
59890:     if (length1 != str2->length()) {
59890:         *result = false;
59890:         return true;
59890:     }
59890: 
59890:     JSLinearString *linear1 = str1->ensureLinear(cx);
59890:     if (!linear1)
59890:         return false;
59890:     JSLinearString *linear2 = str2->ensureLinear(cx);
59890:     if (!linear2)
59890:         return false;
59890: 
64345:     *result = PodEqual(linear1->chars(), linear2->chars(), length1);
59890:     return true;
59890: }
59890: 
59890: bool
59890: EqualStrings(JSLinearString *str1, JSLinearString *str2)
59890: {
59890:     if (str1 == str2)
59890:         return true;
59890: 
59890:     size_t length1 = str1->length();
59890:     if (length1 != str2->length())
59890:         return false;
59890: 
64345:     return PodEqual(str1->chars(), str2->chars(), length1);
59890: }
59890: 
59890: }  /* namespace js */
59890: 
18728: JSBool JS_FASTCALL
59890: js_EqualStringsOnTrace(JSContext *cx, JSString *str1, JSString *str2)
 4529: {
59890:     JSBool result;
59890:     return EqualStrings(cx, str1, str2, &result) ? result : JS_NEITHER;
59890: }
59890: JS_DEFINE_CALLINFO_3(extern, BOOL, js_EqualStringsOnTrace,
59890:                      CONTEXT, STRING, STRING, 1, nanojit::ACCSET_NONE)
59890: 
59890: namespace js {
59890: 
59890: static bool
59890: CompareStringsImpl(JSContext *cx, JSString *str1, JSString *str2, int32 *result)
59890: {
 4529:     JS_ASSERT(str1);
 4529:     JS_ASSERT(str2);
 4529: 
59890:     if (str1 == str2) {
59890:         *result = 0;
59890:         return true;
59890:     }
59890: 
59890:     size_t l1 = str1->length();
59890:     const jschar *s1 = str1->getChars(cx);
59890:     if (!s1)
59890:         return false;
59890: 
59890:     size_t l2 = str2->length();
59890:     const jschar *s2 = str2->getChars(cx);
59890:     if (!s2)
59890:         return false;
59890: 
59890:     size_t n = JS_MIN(l1, l2);
59890:     for (size_t i = 0; i < n; i++) {
59890:         if (int32 cmp = s1[i] - s2[i]) {
59890:             *result = cmp;
59890:             return true;
59890:         }
59890:     }
59890:     *result = (int32)(l1 - l2);
59890:     return true;
59890: }
59890: 
59890: bool
59890: CompareStrings(JSContext *cx, JSString *str1, JSString *str2, int32 *result)
59890: {
59890:     return CompareStringsImpl(cx, str1, str2, result);
59890: }
59890: 
59890: }  /* namespace js */
16519: 
20408: int32 JS_FASTCALL
59890: js_CompareStringsOnTrace(JSContext *cx, JSString *str1, JSString *str2)
    1: {
59890:     int32 result;
59890:     if (!CompareStringsImpl(cx, str1, str2, &result))
59890:         return INT32_MIN;
59890:     JS_ASSERT(result != INT32_MIN);
59890:     return result;
59890: }
59890: JS_DEFINE_CALLINFO_3(extern, INT32, js_CompareStringsOnTrace,
59890:                      CONTEXT, STRING, STRING, 1, nanojit::ACCSET_NONE)
    1: 
57721: namespace js {
57721: 
59890: bool
59890: StringEqualsAscii(JSLinearString *str, const char *asciiBytes)
57721: {
57721:     size_t length = strlen(asciiBytes);
57721: #ifdef DEBUG
57721:     for (size_t i = 0; i != length; ++i)
57721:         JS_ASSERT(unsigned(asciiBytes[i]) <= 127);
57721: #endif
57721:     if (length != str->length())
57721:         return false;
57721:     const jschar *chars = str->chars();
57721:     for (size_t i = 0; i != length; ++i) {
57721:         if (unsigned(asciiBytes[i]) != unsigned(chars[i]))
57721:             return false;
57721:     }
57721:     return true;
57721: }
57721: 
57721: } /* namespacejs */
57721: 
    1: size_t
    1: js_strlen(const jschar *s)
    1: {
    1:     const jschar *t;
    1: 
    1:     for (t = s; *t != 0; t++)
    1:         continue;
    1:     return (size_t)(t - s);
    1: }
    1: 
    1: jschar *
    1: js_strchr(const jschar *s, jschar c)
    1: {
    1:     while (*s != 0) {
    1:         if (*s == c)
    1:             return (jschar *)s;
    1:         s++;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: jschar *
    1: js_strchr_limit(const jschar *s, jschar c, const jschar *limit)
    1: {
    1:     while (s < limit) {
    1:         if (*s == c)
    1:             return (jschar *)s;
    1:         s++;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: jschar *
68124: js_InflateString(JSContext *cx, const char *bytes, size_t *lengthp)
    1: {
 8893:     size_t nbytes, nchars, i;
 8893:     jschar *chars;
 8893: #ifdef DEBUG
 8893:     JSBool ok;
 8893: #endif
 8893: 
 8893:     nbytes = *lengthp;
68124:     if (js_CStringsAreUTF8) {
68124:         if (!js_InflateStringToBuffer(cx, bytes, nbytes, NULL, &nchars))
 8893:             goto bad;
64560:         chars = (jschar *) cx->malloc_((nchars + 1) * sizeof (jschar));
 8893:         if (!chars)
 8893:             goto bad;
 8893: #ifdef DEBUG
 8893:         ok =
 8893: #endif
68124:             js_InflateStringToBuffer(cx, bytes, nbytes, chars, &nchars);
 8893:         JS_ASSERT(ok);
 8893:     } else {
 8893:         nchars = nbytes;
64560:         chars = (jschar *) cx->malloc_((nchars + 1) * sizeof(jschar));
 8893:         if (!chars)
 8893:             goto bad;
 8893:         for (i = 0; i < nchars; i++)
 8893:             chars[i] = (unsigned char) bytes[i];
 8893:     }
 8893:     *lengthp = nchars;
 8893:     chars[nchars] = 0;
 8893:     return chars;
 8893: 
 8893:   bad:
 8893:     /*
 8893:      * For compatibility with callers of JS_DecodeBytes we must zero lengthp
 8893:      * on errors.
 8893:      */
 8893:     *lengthp = 0;
    1:     return NULL;
    1: }
    1: 
    1: /*
58976:  * May be called with null cx.
    1:  */
    1: char *
 8893: js_DeflateString(JSContext *cx, const jschar *chars, size_t nchars)
    1: {
 8893:     size_t nbytes, i;
    1:     char *bytes;
 8893: #ifdef DEBUG
 8893:     JSBool ok;
 8893: #endif
 8893: 
 8893:     if (js_CStringsAreUTF8) {
 8893:         nbytes = js_GetDeflatedStringLength(cx, chars, nchars);
 8893:         if (nbytes == (size_t) -1)
    1:             return NULL;
64560:         bytes = (char *) (cx ? cx->malloc_(nbytes + 1) : OffTheBooks::malloc_(nbytes + 1));
    1:         if (!bytes)
    1:             return NULL;
 8893: #ifdef DEBUG
 8893:         ok =
 8893: #endif
 8893:             js_DeflateStringToBuffer(cx, chars, nchars, bytes, &nbytes);
 8893:         JS_ASSERT(ok);
 8893:     } else {
 8893:         nbytes = nchars;
64560:         bytes = (char *) (cx ? cx->malloc_(nbytes + 1) : OffTheBooks::malloc_(nbytes + 1));
 8893:         if (!bytes)
 8893:             return NULL;
 8893:         for (i = 0; i < nbytes; i++)
 8893:             bytes[i] = (char) chars[i];
 8893:     }
 8893:     bytes[nbytes] = 0;
    1:     return bytes;
    1: }
    1: 
40444: size_t
40444: js_GetDeflatedStringLength(JSContext *cx, const jschar *chars, size_t nchars)
40444: {
40444:     if (!js_CStringsAreUTF8)
40444:         return nchars;
40444: 
40444:     return js_GetDeflatedUTF8StringLength(cx, chars, nchars);
40444: }
40444: 
    1: /*
58976:  * May be called with null cx through public API, see below.
    1:  */
    1: size_t
68124: js_GetDeflatedUTF8StringLength(JSContext *cx, const jschar *chars, size_t nchars)
    1: {
 8893:     size_t nbytes;
    1:     const jschar *end;
    1:     uintN c, c2;
    1:     char buffer[10];
    1: 
 8893:     nbytes = nchars;
 8893:     for (end = chars + nchars; chars != end; chars++) {
    1:         c = *chars;
    1:         if (c < 0x80)
    1:             continue;
68124:         if (0xD800 <= c && c <= 0xDFFF) {
    1:             /* Surrogate pair. */
    1:             chars++;
56209: 
56209:             /* nbytes sets 1 length since this is surrogate pair. */
56209:             nbytes--;
    1:             if (c >= 0xDC00 || chars == end)
    1:                 goto bad_surrogate;
    1:             c2 = *chars;
    1:             if (c2 < 0xDC00 || c2 > 0xDFFF)
    1:                 goto bad_surrogate;
    1:             c = ((c - 0xD800) << 10) + (c2 - 0xDC00) + 0x10000;
    1:         }
    1:         c >>= 11;
 8893:         nbytes++;
    1:         while (c) {
    1:             c >>= 5;
 8893:             nbytes++;
 8893:         }
 8893:     }
 8893:     return nbytes;
    1: 
    1:   bad_surrogate:
    1:     if (cx) {
    1:         JS_snprintf(buffer, 10, "0x%x", c);
    1:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage,
    1:                                      NULL, JSMSG_BAD_SURROGATE_CHAR, buffer);
    1:     }
    1:     return (size_t) -1;
    1: }
    1: 
    1: JSBool
    1: js_DeflateStringToBuffer(JSContext *cx, const jschar *src, size_t srclen,
    1:                          char *dst, size_t *dstlenp)
    1: {
40444:     size_t dstlen, i;
    1: 
 8893:     dstlen = *dstlenp;
 8893:     if (!js_CStringsAreUTF8) {
 8893:         if (srclen > dstlen) {
 8893:             for (i = 0; i < dstlen; i++)
 8893:                 dst[i] = (char) src[i];
 8893:             if (cx) {
 8893:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8893:                                      JSMSG_BUFFER_TOO_SMALL);
 8893:             }
 8893:             return JS_FALSE;
 8893:         }
 8893:         for (i = 0; i < srclen; i++)
 8893:             dst[i] = (char) src[i];
 8893:         *dstlenp = srclen;
 8893:         return JS_TRUE;
 8893:     }
 8893: 
40444:     return js_DeflateStringToUTF8Buffer(cx, src, srclen, dst, dstlenp);
40444: }
40444: 
40444: JSBool
40444: js_DeflateStringToUTF8Buffer(JSContext *cx, const jschar *src, size_t srclen,
68124:                              char *dst, size_t *dstlenp)
40444: {
40444:     size_t dstlen, i, origDstlen, utf8Len;
40444:     jschar c, c2;
40444:     uint32 v;
40444:     uint8 utf8buf[6];
40444: 
40444:     dstlen = *dstlenp;
 8893:     origDstlen = dstlen;
    1:     while (srclen) {
    1:         c = *src++;
    1:         srclen--;
68124:         if ((c >= 0xDC00) && (c <= 0xDFFF))
    1:             goto badSurrogate;
68124:         if (c < 0xD800 || c > 0xDBFF) {
    1:             v = c;
    1:         } else {
    1:             if (srclen < 1)
    1:                 goto badSurrogate;
    1:             c2 = *src;
    1:             if ((c2 < 0xDC00) || (c2 > 0xDFFF))
    1:                 goto badSurrogate;
    1:             src++;
    1:             srclen--;
    1:             v = ((c - 0xD800) << 10) + (c2 - 0xDC00) + 0x10000;
    1:         }
    1:         if (v < 0x0080) {
    1:             /* no encoding necessary - performance hack */
 2539:             if (dstlen == 0)
    1:                 goto bufferTooSmall;
    1:             *dst++ = (char) v;
    1:             utf8Len = 1;
    1:         } else {
    1:             utf8Len = js_OneUcs4ToUtf8Char(utf8buf, v);
    1:             if (utf8Len > dstlen)
    1:                 goto bufferTooSmall;
    1:             for (i = 0; i < utf8Len; i++)
    1:                 *dst++ = (char) utf8buf[i];
    1:         }
    1:         dstlen -= utf8Len;
    1:     }
    1:     *dstlenp = (origDstlen - dstlen);
    1:     return JS_TRUE;
    1: 
    1: badSurrogate:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     /* Delegate error reporting to the measurement function. */
    1:     if (cx)
    1:         js_GetDeflatedStringLength(cx, src - 1, srclen + 1);
    1:     return JS_FALSE;
    1: 
    1: bufferTooSmall:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     if (cx) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BUFFER_TOO_SMALL);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_InflateStringToBuffer(JSContext *cx, const char *src, size_t srclen,
    1:                          jschar *dst, size_t *dstlenp)
    1: {
40444:     size_t dstlen, i;
 8893: 
 8893:     if (!js_CStringsAreUTF8) {
 8893:         if (dst) {
 8893:             dstlen = *dstlenp;
 8893:             if (srclen > dstlen) {
 8893:                 for (i = 0; i < dstlen; i++)
 8893:                     dst[i] = (unsigned char) src[i];
 8893:                 if (cx) {
 8893:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8893:                                          JSMSG_BUFFER_TOO_SMALL);
 8893:                 }
 8893:                 return JS_FALSE;
 8893:             }
 8893:             for (i = 0; i < srclen; i++)
 8893:                 dst[i] = (unsigned char) src[i];
 8893:         }
 8893:         *dstlenp = srclen;
 8893:         return JS_TRUE;
 8893:     }
 8893: 
40444:     return js_InflateUTF8StringToBuffer(cx, src, srclen, dst, dstlenp);
40444: }
40444: 
40444: JSBool
40444: js_InflateUTF8StringToBuffer(JSContext *cx, const char *src, size_t srclen,
68124:                              jschar *dst, size_t *dstlenp)
40444: {
40444:     size_t dstlen, origDstlen, offset, j, n;
40444:     uint32 v;
40444: 
 8893:     dstlen = dst ? *dstlenp : (size_t) -1;
 8893:     origDstlen = dstlen;
 8893:     offset = 0;
    1: 
    1:     while (srclen) {
    1:         v = (uint8) *src;
    1:         n = 1;
    1:         if (v & 0x80) {
    1:             while (v & (0x80 >> n))
    1:                 n++;
    1:             if (n > srclen)
    1:                 goto bufferTooSmall;
33589:             if (n == 1 || n > 4)
    1:                 goto badCharacter;
    1:             for (j = 1; j < n; j++) {
    1:                 if ((src[j] & 0xC0) != 0x80)
    1:                     goto badCharacter;
    1:             }
  363:             v = Utf8ToOneUcs4Char((uint8 *)src, n);
68124:             if (v >= 0x10000) {
    1:                 v -= 0x10000;
    1:                 if (v > 0xFFFFF || dstlen < 2) {
    1:                     *dstlenp = (origDstlen - dstlen);
    1:                     if (cx) {
    1:                         char buffer[10];
    1:                         JS_snprintf(buffer, 10, "0x%x", v + 0x10000);
    1:                         JS_ReportErrorFlagsAndNumber(cx,
    1:                                                      JSREPORT_ERROR,
    1:                                                      js_GetErrorMessage, NULL,
    1:                                                      JSMSG_UTF8_CHAR_TOO_LARGE,
    1:                                                      buffer);
    1:                     }
    1:                     return JS_FALSE;
    1:                 }
    1:                 if (dst) {
    1:                     *dst++ = (jschar)((v >> 10) + 0xD800);
    1:                     v = (jschar)((v & 0x3FF) + 0xDC00);
    1:                 }
    1:                 dstlen--;
    1:             }
    1:         }
    1:         if (!dstlen)
    1:             goto bufferTooSmall;
    1:         if (dst)
    1:             *dst++ = (jschar) v;
    1:         dstlen--;
    1:         offset += n;
    1:         src += n;
    1:         srclen -= n;
    1:     }
    1:     *dstlenp = (origDstlen - dstlen);
    1:     return JS_TRUE;
    1: 
    1: badCharacter:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     if (cx) {
    1:         char buffer[10];
    1:         JS_snprintf(buffer, 10, "%d", offset);
    1:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
    1:                                      js_GetErrorMessage, NULL,
    1:                                      JSMSG_MALFORMED_UTF8_CHAR,
    1:                                      buffer);
    1:     }
    1:     return JS_FALSE;
    1: 
    1: bufferTooSmall:
    1:     *dstlenp = (origDstlen - dstlen);
    1:     if (cx) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BUFFER_TOO_SMALL);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: /*
    1:  * From java.lang.Character.java:
    1:  *
    1:  * The character properties are currently encoded into 32 bits in the
    1:  * following manner:
    1:  *
    1:  * 10 bits      signed offset used for converting case
    1:  *  1 bit       if 1, adding the signed offset converts the character to
    1:  *              lowercase
    1:  *  1 bit       if 1, subtracting the signed offset converts the character to
    1:  *              uppercase
    1:  *  1 bit       if 1, character has a titlecase equivalent (possibly itself)
    1:  *  3 bits      0  may not be part of an identifier
    1:  *              1  ignorable control; may continue a Unicode identifier or JS
    1:  *                 identifier
    1:  *              2  may continue a JS identifier but not a Unicode identifier
    1:  *                 (unused)
    1:  *              3  may continue a Unicode identifier or JS identifier
    1:  *              4  is a JS whitespace character
    1:  *              5  may start or continue a JS identifier;
    1:  *                 may continue but not start a Unicode identifier (_)
    1:  *              6  may start or continue a JS identifier but not a Unicode
    1:  *                 identifier ($)
    1:  *              7  may start or continue a Unicode identifier or JS identifier
    1:  *              Thus:
    1:  *                 5, 6, 7 may start a JS identifier
    1:  *                 1, 2, 3, 5, 6, 7 may continue a JS identifier
    1:  *                 7 may start a Unicode identifier
    1:  *                 1, 3, 5, 7 may continue a Unicode identifier
    1:  *                 1 is ignorable within an identifier
    1:  *                 4 is JS whitespace
    1:  *  2 bits      0  this character has no numeric property
    1:  *              1  adding the digit offset to the character code and then
    1:  *                 masking with 0x1F will produce the desired numeric value
    1:  *              2  this character has a "strange" numeric value
    1:  *              3  a JS supradecimal digit: adding the digit offset to the
    1:  *                 character code, then masking with 0x1F, then adding 10
    1:  *                 will produce the desired numeric value
    1:  *  5 bits      digit offset
    1:  *  1 bit       XML 1.0 name start character
    1:  *  1 bit       XML 1.0 name character
    1:  *  2 bits      reserved for future use
    1:  *  5 bits      character type
    1:  */
    1: 
    1: /* The X table has 1024 entries for a total of 1024 bytes. */
    1: 
    1: const uint8 js_X[] = {
    1:   0,   1,   2,   3,   4,   5,   6,   7,  /*  0x0000 */
    1:   8,   9,  10,  11,  12,  13,  14,  15,  /*  0x0200 */
    1:  16,  17,  18,  19,  20,  21,  22,  23,  /*  0x0400 */
    1:  24,  25,  26,  27,  28,  28,  28,  28,  /*  0x0600 */
    1:  28,  28,  28,  28,  29,  30,  31,  32,  /*  0x0800 */
    1:  33,  34,  35,  36,  37,  38,  39,  40,  /*  0x0A00 */
    1:  41,  42,  43,  44,  45,  46,  28,  28,  /*  0x0C00 */
    1:  47,  48,  49,  50,  51,  52,  53,  28,  /*  0x0E00 */
    1:  28,  28,  54,  55,  56,  57,  58,  59,  /*  0x1000 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x1C00 */
    1:  60,  60,  61,  62,  63,  64,  65,  66,  /*  0x1E00 */
    1:  67,  68,  69,  70,  71,  72,  73,  74,  /*  0x2000 */
    1:  75,  75,  75,  76,  77,  78,  28,  28,  /*  0x2200 */
    1:  79,  80,  81,  82,  83,  83,  84,  85,  /*  0x2400 */
    1:  86,  85,  28,  28,  87,  88,  89,  28,  /*  0x2600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2C00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x2E00 */
    1:  90,  91,  92,  93,  94,  56,  95,  28,  /*  0x3000 */
    1:  96,  97,  98,  99,  83, 100,  83, 101,  /*  0x3200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3C00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x3E00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4000 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4A00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0x4C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x4E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x5E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x6E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x7E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8C00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x8E00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9A00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0x9C00 */
    1:  56,  56,  56,  56,  56,  56, 102,  28,  /*  0x9E00 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA000 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA200 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA400 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA600 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xA800 */
    1:  28,  28,  28,  28,  28,  28,  28,  28,  /*  0xAA00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xAC00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xAE00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xB800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xBA00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xBC00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xBE00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC400 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC600 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xC800 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xCA00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xCC00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xCE00 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xD000 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xD200 */
    1:  56,  56,  56,  56,  56,  56,  56,  56,  /*  0xD400 */
    1:  56,  56,  56,  56,  56,  56, 103,  28,  /*  0xD600 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xD800 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xDA00 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xDC00 */
    1: 104, 104, 104, 104, 104, 104, 104, 104,  /*  0xDE00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE000 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE200 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE400 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE600 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xE800 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xEA00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xEC00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xEE00 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF000 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF200 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF400 */
    1: 105, 105, 105, 105, 105, 105, 105, 105,  /*  0xF600 */
    1: 105, 105, 105, 105,  56,  56,  56,  56,  /*  0xF800 */
    1: 106,  28,  28,  28, 107, 108, 109, 110,  /*  0xFA00 */
    1:  56,  56,  56,  56, 111, 112, 113, 114,  /*  0xFC00 */
    1: 115, 116,  56, 117, 118, 119, 120, 121   /*  0xFE00 */
    1: };
    1: 
    1: /* The Y table has 7808 entries for a total of 7808 bytes. */
    1: 
    1: const uint8 js_Y[] = {
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    0 */
    1:   0,   1,   1,   1,   1,   1,   0,   0,  /*    0 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    0 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    0 */
    1:   2,   3,   3,   3,   4,   3,   3,   3,  /*    0 */
    1:   5,   6,   3,   7,   3,   8,   3,   3,  /*    0 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*    0 */
    1:   9,   9,   3,   3,   7,   7,   7,   3,  /*    0 */
    1:   3,  10,  10,  10,  10,  10,  10,  10,  /*    1 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*    1 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*    1 */
    1:  10,  10,  10,   5,   3,   6,  11,  12,  /*    1 */
    1:  11,  13,  13,  13,  13,  13,  13,  13,  /*    1 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*    1 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*    1 */
    1:  13,  13,  13,   5,   7,   6,   7,   0,  /*    1 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   0,   0,   0,   0,   0,   0,   0,   0,  /*    2 */
    1:   2,   3,   4,   4,   4,   4,  15,  15,  /*    2 */
    1:  11,  15,  16,   5,   7,   8,  15,  11,  /*    2 */
    1:  15,   7,  17,  17,  11,  16,  15,   3,  /*    2 */
    1:  11,  18,  16,   6,  19,  19,  19,   3,  /*    2 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*    3 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*    3 */
    1:  20,  20,  20,  20,  20,  20,  20,   7,  /*    3 */
    1:  20,  20,  20,  20,  20,  20,  20,  16,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,   7,  /*    3 */
    1:  21,  21,  21,  21,  21,  21,  21,  22,  /*    3 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  25,  26,  23,  24,  23,  24,  23,  24,  /*    4 */
    1:  16,  23,  24,  23,  24,  23,  24,  23,  /*    4 */
    1:  24,  23,  24,  23,  24,  23,  24,  23,  /*    5 */
    1:  24,  16,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    5 */
    1:  27,  23,  24,  23,  24,  23,  24,  28,  /*    5 */
    1:  16,  29,  23,  24,  23,  24,  30,  23,  /*    6 */
    1:  24,  31,  31,  23,  24,  16,  32,  32,  /*    6 */
    1:  33,  23,  24,  31,  34,  16,  35,  36,  /*    6 */
    1:  23,  24,  16,  16,  35,  37,  16,  38,  /*    6 */
    1:  23,  24,  23,  24,  23,  24,  38,  23,  /*    6 */
    1:  24,  39,  40,  16,  23,  24,  39,  23,  /*    6 */
    1:  24,  41,  41,  23,  24,  23,  24,  42,  /*    6 */
    1:  23,  24,  16,  40,  23,  24,  40,  40,  /*    6 */
    1:  40,  40,  40,  40,  43,  44,  45,  43,  /*    7 */
    1:  44,  45,  43,  44,  45,  23,  24,  23,  /*    7 */
    1:  24,  23,  24,  23,  24,  23,  24,  23,  /*    7 */
    1:  24,  23,  24,  23,  24,  16,  23,  24,  /*    7 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    7 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    7 */
    1:  16,  43,  44,  45,  23,  24,  46,  46,  /*    7 */
    1:  46,  46,  23,  24,  23,  24,  23,  24,  /*    7 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    8 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    8 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    8 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    9 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*    9 */
    1:  16,  16,  16,  47,  48,  16,  49,  49,  /*    9 */
    1:  50,  50,  16,  51,  16,  16,  16,  16,  /*    9 */
    1:  49,  16,  16,  52,  16,  16,  16,  16,  /*    9 */
    1:  53,  54,  16,  16,  16,  16,  16,  54,  /*    9 */
    1:  16,  16,  55,  16,  16,  16,  16,  16,  /*    9 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*    9 */
    1:  16,  16,  16,  56,  16,  16,  16,  16,  /*   10 */
    1:  56,  16,  57,  57,  16,  16,  16,  16,  /*   10 */
    1:  16,  16,  58,  16,  16,  16,  16,  16,  /*   10 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   10 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   10 */
    1:  16,  46,  46,  46,  46,  46,  46,  46,  /*   10 */
    1:  59,  59,  59,  59,  59,  59,  59,  59,  /*   10 */
    1:  59,  11,  11,  59,  59,  59,  59,  59,  /*   10 */
    1:  59,  59,  11,  11,  11,  11,  11,  11,  /*   11 */
    1:  11,  11,  11,  11,  11,  11,  11,  11,  /*   11 */
    1:  59,  59,  11,  11,  11,  11,  11,  11,  /*   11 */
    1:  11,  11,  11,  11,  11,  11,  11,  46,  /*   11 */
    1:  59,  59,  59,  59,  59,  11,  11,  11,  /*   11 */
    1:  11,  11,  46,  46,  46,  46,  46,  46,  /*   11 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   11 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   11 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   12 */
    1:  60,  60,  60,  60,  60,  60,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  60,  60,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   13 */
    1:  46,  46,  46,  46,   3,   3,  46,  46,  /*   13 */
    1:  46,  46,  59,  46,  46,  46,   3,  46,  /*   13 */
    1:  46,  46,  46,  46,  11,  11,  61,   3,  /*   14 */
    1:  62,  62,  62,  46,  63,  46,  64,  64,  /*   14 */
    1:  16,  20,  20,  20,  20,  20,  20,  20,  /*   14 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   14 */
    1:  20,  20,  46,  20,  20,  20,  20,  20,  /*   14 */
    1:  20,  20,  20,  20,  65,  66,  66,  66,  /*   14 */
    1:  16,  21,  21,  21,  21,  21,  21,  21,  /*   14 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   14 */
    1:  21,  21,  16,  21,  21,  21,  21,  21,  /*   15 */
    1:  21,  21,  21,  21,  67,  68,  68,  46,  /*   15 */
    1:  69,  70,  38,  38,  38,  71,  72,  46,  /*   15 */
    1:  46,  46,  38,  46,  38,  46,  38,  46,  /*   15 */
    1:  38,  46,  23,  24,  23,  24,  23,  24,  /*   15 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   15 */
    1:  73,  74,  16,  40,  46,  46,  46,  46,  /*   15 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   15 */
    1:  46,  75,  75,  75,  75,  75,  75,  75,  /*   16 */
    1:  75,  75,  75,  75,  75,  46,  75,  75,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  20,  20,  20,  20,  20,  20,  20,  20,  /*   16 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   16 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   16 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   17 */
    1:  21,  21,  21,  21,  21,  21,  21,  21,  /*   17 */
    1:  46,  74,  74,  74,  74,  74,  74,  74,  /*   17 */
    1:  74,  74,  74,  74,  74,  46,  74,  74,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   17 */
    1:  23,  24,  15,  60,  60,  60,  60,  46,  /*   18 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   18 */
    1:  40,  23,  24,  23,  24,  46,  46,  23,  /*   19 */
    1:  24,  46,  46,  23,  24,  46,  46,  46,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  46,  46,  23,  24,  /*   19 */
    1:  23,  24,  23,  24,  23,  24,  46,  46,  /*   19 */
    1:  23,  24,  46,  46,  46,  46,  46,  46,  /*   19 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   20 */
    1:  46,  76,  76,  76,  76,  76,  76,  76,  /*   20 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   20 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   21 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   21 */
    1:  76,  76,  76,  76,  76,  76,  76,  46,  /*   21 */
    1:  46,  59,   3,   3,   3,   3,   3,   3,  /*   21 */
    1:  46,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  77,  /*   21 */
    1:  77,  77,  77,  77,  77,  77,  77,  16,  /*   22 */
    1:  46,   3,  46,  46,  46,  46,  46,  46,  /*   22 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  46,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   22 */
    1:  60,  60,  46,  60,  60,  60,   3,  60,  /*   22 */
    1:   3,  60,  60,   3,  60,  46,  46,  46,  /*   23 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   23 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   23 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   23 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   23 */
    1:  40,  40,  40,  46,  46,  46,  46,  46,  /*   23 */
    1:  40,  40,  40,   3,   3,  46,  46,  46,  /*   23 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   23 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   24 */
    1:  46,  46,  46,  46,   3,  46,  46,  46,  /*   24 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   24 */
    1:  46,  46,  46,   3,  46,  46,  46,   3,  /*   24 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   24 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   24 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   24 */
    1:  40,  40,  40,  46,  46,  46,  46,  46,  /*   24 */
    1:  59,  40,  40,  40,  40,  40,  40,  40,  /*   25 */
    1:  40,  40,  40,  60,  60,  60,  60,  60,  /*   25 */
    1:  60,  60,  60,  46,  46,  46,  46,  46,  /*   25 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   25 */
    1:  78,  78,  78,  78,  78,  78,  78,  78,  /*   25 */
    1:  78,  78,   3,   3,   3,   3,  46,  46,  /*   25 */
    1:  60,  40,  40,  40,  40,  40,  40,  40,  /*   25 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   25 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   26 */
    1:  46,  46,  40,  40,  40,  40,  40,  46,  /*   26 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   27 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*   27 */
    1:  40,  40,  40,  40,   3,  40,  60,  60,  /*   27 */
    1:  60,  60,  60,  60,  60,  79,  79,  60,  /*   27 */
    1:  60,  60,  60,  60,  60,  59,  59,  60,  /*   27 */
    1:  60,  15,  60,  60,  60,  60,  46,  46,  /*   27 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*   27 */
    1:   9,   9,  46,  46,  46,  46,  46,  46,  /*   27 */
36430:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
36430:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   28 */
    1:  46,  60,  60,  80,  46,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   29 */
    1:  40,  40,  46,  46,  60,  40,  80,  80,  /*   29 */
    1:  80,  60,  60,  60,  60,  60,  60,  60,  /*   30 */
    1:  60,  80,  80,  80,  80,  60,  46,  46,  /*   30 */
    1:  15,  60,  60,  60,  60,  46,  46,  46,  /*   30 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   30 */
    1:  40,  40,  60,  60,   3,   3,  81,  81,  /*   30 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   30 */
    1:   3,  46,  46,  46,  46,  46,  46,  46,  /*   30 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   30 */
    1:  46,  60,  80,  80,  46,  40,  40,  40,  /*   31 */
    1:  40,  40,  40,  40,  40,  46,  46,  40,  /*   31 */
    1:  40,  46,  46,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   31 */
    1:  40,  46,  40,  46,  46,  46,  40,  40,  /*   31 */
    1:  40,  40,  46,  46,  60,  46,  80,  80,  /*   31 */
    1:  80,  60,  60,  60,  60,  46,  46,  80,  /*   32 */
    1:  80,  46,  46,  80,  80,  60,  46,  46,  /*   32 */
    1:  46,  46,  46,  46,  46,  46,  46,  80,  /*   32 */
    1:  46,  46,  46,  46,  40,  40,  46,  40,  /*   32 */
    1:  40,  40,  60,  60,  46,  46,  81,  81,  /*   32 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   32 */
    1:  40,  40,   4,   4,  82,  82,  82,  82,  /*   32 */
    1:  19,  83,  15,  46,  46,  46,  46,  46,  /*   32 */
    1:  46,  46,  60,  46,  46,  40,  40,  40,  /*   33 */
    1:  40,  40,  40,  46,  46,  46,  46,  40,  /*   33 */
    1:  40,  46,  46,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   33 */
    1:  40,  46,  40,  40,  46,  40,  40,  46,  /*   33 */
    1:  40,  40,  46,  46,  60,  46,  80,  80,  /*   33 */
    1:  80,  60,  60,  46,  46,  46,  46,  60,  /*   34 */
    1:  60,  46,  46,  60,  60,  60,  46,  46,  /*   34 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   34 */
    1:  46,  40,  40,  40,  40,  46,  40,  46,  /*   34 */
    1:  46,  46,  46,  46,  46,  46,  81,  81,  /*   34 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   34 */
    1:  60,  60,  40,  40,  40,  46,  46,  46,  /*   34 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   34 */
    1:  46,  60,  60,  80,  46,  40,  40,  40,  /*   35 */
    1:  40,  40,  40,  40,  46,  40,  46,  40,  /*   35 */
    1:  40,  40,  46,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   35 */
    1:  40,  46,  40,  40,  46,  40,  40,  40,  /*   35 */
    1:  40,  40,  46,  46,  60,  40,  80,  80,  /*   35 */
    1:  80,  60,  60,  60,  60,  60,  46,  60,  /*   36 */
    1:  60,  80,  46,  80,  80,  60,  46,  46,  /*   36 */
    1:  15,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  40,  46,  46,  46,  46,  46,  81,  81,  /*   36 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   36 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   36 */
    1:  46,  60,  80,  80,  46,  40,  40,  40,  /*   37 */
    1:  40,  40,  40,  40,  40,  46,  46,  40,  /*   37 */
    1:  40,  46,  46,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   37 */
    1:  40,  46,  40,  40,  46,  46,  40,  40,  /*   37 */
    1:  40,  40,  46,  46,  60,  40,  80,  60,  /*   37 */
    1:  80,  60,  60,  60,  46,  46,  46,  80,  /*   38 */
    1:  80,  46,  46,  80,  80,  60,  46,  46,  /*   38 */
    1:  46,  46,  46,  46,  46,  46,  60,  80,  /*   38 */
    1:  46,  46,  46,  46,  40,  40,  46,  40,  /*   38 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   38 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   38 */
    1:  15,  46,  46,  46,  46,  46,  46,  46,  /*   38 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   38 */
    1:  46,  46,  60,  80,  46,  40,  40,  40,  /*   39 */
    1:  40,  40,  40,  46,  46,  46,  40,  40,  /*   39 */
    1:  40,  46,  40,  40,  40,  40,  46,  46,  /*   39 */
    1:  46,  40,  40,  46,  40,  46,  40,  40,  /*   39 */
    1:  46,  46,  46,  40,  40,  46,  46,  46,  /*   39 */
    1:  40,  40,  40,  46,  46,  46,  40,  40,  /*   39 */
    1:  40,  40,  40,  40,  40,  40,  46,  40,  /*   39 */
    1:  40,  40,  46,  46,  46,  46,  80,  80,  /*   39 */
    1:  60,  80,  80,  46,  46,  46,  80,  80,  /*   40 */
    1:  80,  46,  80,  80,  80,  60,  46,  46,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  80,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  81,  /*   40 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   40 */
    1:  84,  19,  19,  46,  46,  46,  46,  46,  /*   40 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   40 */
    1:  46,  80,  80,  80,  46,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  40,  46,  40,  40,  /*   41 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   41 */
    1:  40,  40,  40,  40,  46,  40,  40,  40,  /*   41 */
    1:  40,  40,  46,  46,  46,  46,  60,  60,  /*   41 */
    1:  60,  80,  80,  80,  80,  46,  60,  60,  /*   42 */
    1:  60,  46,  60,  60,  60,  60,  46,  46,  /*   42 */
    1:  46,  46,  46,  46,  46,  60,  60,  46,  /*   42 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   42 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   42 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   42 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   42 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   42 */
    1:  46,  46,  80,  80,  46,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  40,  46,  40,  40,  /*   43 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   43 */
    1:  40,  40,  40,  40,  46,  40,  40,  40,  /*   43 */
    1:  40,  40,  46,  46,  46,  46,  80,  60,  /*   43 */
    1:  80,  80,  80,  80,  80,  46,  60,  80,  /*   44 */
    1:  80,  46,  80,  80,  60,  60,  46,  46,  /*   44 */
    1:  46,  46,  46,  46,  46,  80,  80,  46,  /*   44 */
    1:  46,  46,  46,  46,  46,  46,  40,  46,  /*   44 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   44 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   44 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   44 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   44 */
    1:  46,  46,  80,  80,  46,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  46,  40,  40,  /*   45 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  46,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   45 */
    1:  40,  40,  46,  46,  46,  46,  80,  80,  /*   45 */
    1:  80,  60,  60,  60,  46,  46,  80,  80,  /*   46 */
    1:  80,  46,  80,  80,  80,  60,  46,  46,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  80,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   46 */
    1:  40,  40,  46,  46,  46,  46,  81,  81,  /*   46 */
    1:  81,  81,  81,  81,  81,  81,  81,  81,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   46 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   46 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  40,   3,  /*   47 */
    1:  40,  60,  40,  40,  60,  60,  60,  60,  /*   47 */
    1:  60,  60,  60,  46,  46,  46,  46,   4,  /*   47 */
    1:  40,  40,  40,  40,  40,  40,  59,  60,  /*   48 */
    1:  60,  60,  60,  60,  60,  60,  60,  15,  /*   48 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*   48 */
    1:   9,   9,   3,   3,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   48 */
    1:  46,  40,  40,  46,  40,  46,  46,  40,  /*   49 */
    1:  40,  46,  40,  46,  46,  40,  46,  46,  /*   49 */
    1:  46,  46,  46,  46,  40,  40,  40,  40,  /*   49 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   49 */
    1:  46,  40,  40,  40,  46,  40,  46,  40,  /*   49 */
    1:  46,  46,  40,  40,  46,  40,  40,   3,  /*   49 */
    1:  40,  60,  40,  40,  60,  60,  60,  60,  /*   49 */
    1:  60,  60,  46,  60,  60,  40,  46,  46,  /*   49 */
    1:  40,  40,  40,  40,  40,  46,  59,  46,  /*   50 */
    1:  60,  60,  60,  60,  60,  60,  46,  46,  /*   50 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*   50 */
    1:   9,   9,  46,  46,  40,  40,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   50 */
    1:  15,  15,  15,  15,   3,   3,   3,   3,  /*   51 */
    1:   3,   3,   3,   3,   3,   3,   3,   3,  /*   51 */
    1:   3,   3,   3,  15,  15,  15,  15,  15,  /*   51 */
    1:  60,  60,  15,  15,  15,  15,  15,  15,  /*   51 */
    1:  78,  78,  78,  78,  78,  78,  78,  78,  /*   51 */
    1:  78,  78,  85,  85,  85,  85,  85,  85,  /*   51 */
    1:  85,  85,  85,  85,  15,  60,  15,  60,  /*   51 */
    1:  15,  60,   5,   6,   5,   6,  80,  80,  /*   51 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   52 */
    1:  40,  40,  46,  46,  46,  46,  46,  46,  /*   52 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   52 */
    1:  60,  60,  60,  60,  60,  60,  60,  80,  /*   52 */
    1:  60,  60,  60,  60,  60,   3,  60,  60,  /*   53 */
    1:  60,  60,  60,  60,  46,  46,  46,  46,  /*   53 */
    1:  60,  60,  60,  60,  60,  60,  46,  60,  /*   53 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   53 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   53 */
    1:  60,  60,  60,  60,  60,  60,  46,  46,  /*   53 */
    1:  46,  60,  60,  60,  60,  60,  60,  60,  /*   53 */
    1:  46,  60,  46,  46,  46,  46,  46,  46,  /*   53 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  76,  76,  /*   54 */
    1:  76,  76,  76,  76,  76,  76,  46,  46,  /*   55 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  16,  /*   55 */
    1:  16,  16,  16,  16,  16,  16,  16,  46,  /*   55 */
    1:  46,  46,  46,   3,  46,  46,  46,  46,  /*   55 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   56 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  46,  46,  46,  46,  46,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   57 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  46,  46,  46,  46,  46,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   58 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   59 */
    1:  40,  40,  46,  46,  46,  46,  46,  46,  /*   59 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   60 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  16,  16,  /*   61 */
    1:  16,  16,  16,  16,  46,  46,  46,  46,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   61 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  23,  24,  23,  24,  23,  24,  /*   62 */
    1:  23,  24,  46,  46,  46,  46,  46,  46,  /*   62 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  46,  46,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  46,  46,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   63 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   63 */
    1:  86,  86,  86,  86,  86,  86,  46,  46,  /*   64 */
    1:  87,  87,  87,  87,  87,  87,  46,  46,  /*   64 */
    1:  16,  86,  16,  86,  16,  86,  16,  86,  /*   64 */
    1:  46,  87,  46,  87,  46,  87,  46,  87,  /*   64 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   64 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   64 */
    1:  88,  88,  89,  89,  89,  89,  90,  90,  /*   64 */
    1:  91,  91,  92,  92,  93,  93,  46,  46,  /*   64 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   65 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   65 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   65 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   65 */
    1:  86,  86,  86,  86,  86,  86,  86,  86,  /*   65 */
    1:  87,  87,  87,  87,  87,  87,  87,  87,  /*   65 */
    1:  86,  86,  16,  94,  16,  46,  16,  16,  /*   65 */
    1:  87,  87,  95,  95,  96,  11,  38,  11,  /*   65 */
    1:  11,  11,  16,  94,  16,  46,  16,  16,  /*   66 */
    1:  97,  97,  97,  97,  96,  11,  11,  11,  /*   66 */
    1:  86,  86,  16,  16,  46,  46,  16,  16,  /*   66 */
    1:  87,  87,  98,  98,  46,  11,  11,  11,  /*   66 */
    1:  86,  86,  16,  16,  16,  99,  16,  16,  /*   66 */
    1:  87,  87, 100, 100, 101,  11,  11,  11,  /*   66 */
    1:  46,  46,  16,  94,  16,  46,  16,  16,  /*   66 */
    1: 102, 102, 103, 103,  96,  11,  11,  46,  /*   66 */
    1:   2,   2,   2,   2,   2,   2,   2,   2,  /*   67 */
36430:   2,   2,   2,   2, 104, 104, 104, 104,  /*   67 */
    1:   8,   8,   8,   8,   8,   8,   3,   3,  /*   67 */
    1:   5,   6,   5,   5,   5,   6,   5,   5,  /*   67 */
    1:   3,   3,   3,   3,   3,   3,   3,   3,  /*   67 */
36430: 105, 106, 104, 104, 104, 104, 104,  46,  /*   67 */
    1:   3,   3,   3,   3,   3,   3,   3,   3,  /*   67 */
    1:   3,   5,   6,   3,   3,   3,   3,  12,  /*   67 */
    1:  12,   3,   3,   3,   7,   5,   6,  46,  /*   68 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
36430:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   68 */
    1:  46,  46, 104, 104, 104, 104, 104, 104,  /*   68 */
    1:  17,  46,  46,  46,  17,  17,  17,  17,  /*   68 */
    1:  17,  17,   7,   7,   7,   5,   6,  16,  /*   68 */
    1: 107, 107, 107, 107, 107, 107, 107, 107,  /*   69 */
    1: 107, 107,   7,   7,   7,   5,   6,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:   4,   4,   4,   4,   4,   4,   4,   4,  /*   69 */
    1:   4,   4,   4,   4,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   69 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  60,  60,  60,  60,  60,  60,  60,  60,  /*   70 */
    1:  60,  60,  60,  60,  60,  79,  79,  79,  /*   70 */
    1:  79,  60,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   70 */
    1:  15,  15,  38,  15,  15,  15,  15,  38,  /*   71 */
    1:  15,  15,  16,  38,  38,  38,  16,  16,  /*   71 */
    1:  38,  38,  38,  16,  15,  38,  15,  15,  /*   71 */
    1:  38,  38,  38,  38,  38,  38,  15,  15,  /*   71 */
    1:  15,  15,  15,  15,  38,  15,  38,  15,  /*   71 */
    1:  38,  15,  38,  38,  38,  38,  16,  16,  /*   71 */
    1:  38,  38,  15,  38,  16,  40,  40,  40,  /*   71 */
    1:  40,  46,  46,  46,  46,  46,  46,  46,  /*   71 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   72 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   72 */
    1:  46,  46,  46,  19,  19,  19,  19,  19,  /*   72 */
    1:  19,  19,  19,  19,  19,  19,  19, 108,  /*   72 */
    1: 109, 109, 109, 109, 109, 109, 109, 109,  /*   72 */
    1: 109, 109, 109, 109, 110, 110, 110, 110,  /*   72 */
    1: 111, 111, 111, 111, 111, 111, 111, 111,  /*   72 */
    1: 111, 111, 111, 111, 112, 112, 112, 112,  /*   72 */
    1: 113, 113, 113,  46,  46,  46,  46,  46,  /*   73 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   73 */
    1:   7,   7,   7,   7,   7,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   73 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,   7,  15,   7,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   74 */
    1:  15,  15,  15,  46,  46,  46,  46,  46,  /*   74 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   74 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   74 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   75 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,   7,   7,   7,   7,   7,   7,  /*   76 */
    1:   7,   7,  46,  46,  46,  46,  46,  46,  /*   76 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   76 */
    1:  15,  46,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:   7,   7,   7,   7,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:   7,   7,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,   5,   6,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   77 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   78 */
    1:  15,  15,  15,  46,  46,  46,  46,  46,  /*   78 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   79 */
    1:  15,  15,  15,  15,  15,  46,  46,  46,  /*   79 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   79 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   79 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   79 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   80 */
    1:  15,  15,  15,  46,  46,  46,  46,  46,  /*   80 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   80 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   80 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   80 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   80 */
    1: 114, 114, 114, 114,  82,  82,  82,  82,  /*   80 */
    1:  82,  82,  82,  82,  82,  82,  82,  82,  /*   80 */
    1:  82,  82,  82,  82,  82,  82,  82,  82,  /*   81 */
    1: 115, 115, 115, 115, 115, 115, 115, 115,  /*   81 */
    1: 115, 115, 115, 115, 115, 115, 115, 115,  /*   81 */
    1: 115, 115, 115, 115,  15,  15,  15,  15,  /*   81 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   81 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   81 */
    1:  15,  15,  15,  15,  15,  15, 116, 116,  /*   81 */
    1: 116, 116, 116, 116, 116, 116, 116, 116,  /*   81 */
    1: 116, 116, 116, 116, 116, 116, 116, 116,  /*   82 */
    1: 116, 116, 116, 116, 116, 116, 116, 116,  /*   82 */
    1: 117, 117, 117, 117, 117, 117, 117, 117,  /*   82 */
    1: 117, 117, 117, 117, 117, 117, 117, 117,  /*   82 */
    1: 117, 117, 117, 117, 117, 117, 117, 117,  /*   82 */
    1: 117, 117, 118,  46,  46,  46,  46,  46,  /*   82 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   82 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   82 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   83 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  46,  46,  /*   84 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   84 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   85 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   85 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   85 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  46,  46,  46,  46,  /*   86 */
    1:  46,  46,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   86 */
    1:  46,  15,  15,  15,  15,  46,  15,  15,  /*   87 */
    1:  15,  15,  46,  46,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  46,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   87 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   88 */
    1:  15,  15,  15,  15,  46,  15,  46,  15,  /*   88 */
    1:  15,  15,  15,  46,  46,  46,  15,  46,  /*   88 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*   88 */
    1:  46,  15,  15,  15,  15,  15,  15,  15,  /*   88 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   88 */
    1:  46,  46,  46,  46,  46,  46, 119, 119,  /*   88 */
    1: 119, 119, 119, 119, 119, 119, 119, 119,  /*   88 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   89 */
    1: 114, 114,  83,  83,  83,  83,  83,  83,  /*   89 */
    1:  83,  83,  83,  83,  15,  46,  46,  46,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  46,  15,  15,  15,  15,  15,  15,  15,  /*   89 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*   89 */
    1:   2,   3,   3,   3,  15,  59,   3, 120,  /*   90 */
    1:   5,   6,   5,   6,   5,   6,   5,   6,  /*   90 */
    1:   5,   6,  15,  15,   5,   6,   5,   6,  /*   90 */
    1:   5,   6,   5,   6,   8,   5,   6,   5,  /*   90 */
    1:  15, 121, 121, 121, 121, 121, 121, 121,  /*   90 */
    1: 121, 121,  60,  60,  60,  60,  60,  60,  /*   90 */
    1:   8,  59,  59,  59,  59,  59,  15,  15,  /*   90 */
    1:  46,  46,  46,  46,  46,  46,  46,  15,  /*   90 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   91 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  46,  46,  46,  /*   92 */
    1:  46,  60,  60,  59,  59,  59,  59,  46,  /*   92 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   92 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   93 */
    1:  40,  40,  40,   3,  59,  59,  59,  46,  /*   93 */
    1:  46,  46,  46,  46,  46,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  46,  46,  46,  /*   94 */
    1:  46,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   94 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*   95 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*   95 */
    1:  15,  15,  85,  85,  85,  85,  15,  15,  /*   95 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   95 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  46,  46,  46,  /*   96 */
    1:  85,  85,  85,  85,  85,  85,  85,  85,  /*   96 */
    1:  85,  85,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   96 */
    1:  15,  15,  15,  15,  46,  46,  46,  46,  /*   97 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   97 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   97 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   97 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   97 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   97 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   97 */
    1:  15,  15,  15,  15,  46,  46,  46,  15,  /*   97 */
    1: 114, 114, 114, 114, 114, 114, 114, 114,  /*   98 */
    1: 114, 114,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   98 */
    1:  15,  46,  46,  46,  46,  46,  46,  46,  /*   98 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*   98 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  46,  46,  46,  46,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*   99 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*  100 */
    1:  46,  46,  46,  15,  15,  15,  15,  15,  /*  100 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  46,  46,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  15,  /*  101 */
    1:  15,  15,  15,  15,  15,  15,  15,  46,  /*  101 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  46,  46,  /*  102 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  102 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  102 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  102 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  103 */
    1:  40,  40,  40,  40,  46,  46,  46,  46,  /*  103 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  103 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  103 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  103 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 122, 122, 122, 122, 122, 122, 122, 122,  /*  104 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1: 123, 123, 123, 123, 123, 123, 123, 123,  /*  105 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  106 */
    1:  40,  40,  40,  40,  40,  40,  46,  46,  /*  106 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  106 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  106 */
    1:  16,  16,  16,  16,  16,  16,  16,  46,  /*  107 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  107 */
    1:  46,  46,  46,  16,  16,  16,  16,  16,  /*  107 */
    1:  46,  46,  46,  46,  46,  46,  60,  40,  /*  107 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  107 */
    1:  40,   7,  40,  40,  40,  40,  40,  40,  /*  107 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*  107 */
    1:  40,  40,  40,  40,  40,  46,  40,  46,  /*  107 */
    1:  40,  40,  46,  40,  40,  46,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  108 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  109 */
    1:  40,  40,  46,  46,  46,  46,  46,  46,  /*  109 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  109 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  110 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  110 */
    1:  46,  46,  46,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  110 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  111 */
    1:  40,  40,  40,  40,  40,  40,   5,   6,  /*  111 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  112 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  112 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  113 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  114 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  114 */
    1:  40,  40,  40,  40,  46,  46,  46,  46,  /*  114 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:  60,  60,  60,  60,  46,  46,  46,  46,  /*  115 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  115 */
    1:   3,   8,   8,  12,  12,   5,   6,   5,  /*  115 */
    1:   6,   5,   6,   5,   6,   5,   6,   5,  /*  115 */
    1:   6,   5,   6,   5,   6,  46,  46,  46,  /*  116 */
    1:  46,   3,   3,   3,   3,  12,  12,  12,  /*  116 */
    1:   3,   3,   3,  46,   3,   3,   3,   3,  /*  116 */
    1:   8,   5,   6,   5,   6,   5,   6,   3,  /*  116 */
    1:   3,   3,   7,   8,   7,   7,   7,  46,  /*  116 */
    1:   3,   4,   3,   3,  46,  46,  46,  46,  /*  116 */
    1:  40,  40,  40,  46,  40,  46,  40,  40,  /*  116 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  116 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  117 */
    1:  40,  40,  40,  40,  40,  46,  46, 104,  /*  117 */
    1:  46,   3,   3,   3,   4,   3,   3,   3,  /*  118 */
    1:   5,   6,   3,   7,   3,   8,   3,   3,  /*  118 */
    1:   9,   9,   9,   9,   9,   9,   9,   9,  /*  118 */
    1:   9,   9,   3,   3,   7,   7,   7,   3,  /*  118 */
    1:   3,  10,  10,  10,  10,  10,  10,  10,  /*  118 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*  118 */
    1:  10,  10,  10,  10,  10,  10,  10,  10,  /*  118 */
    1:  10,  10,  10,   5,   3,   6,  11,  12,  /*  118 */
    1:  11,  13,  13,  13,  13,  13,  13,  13,  /*  119 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*  119 */
    1:  13,  13,  13,  13,  13,  13,  13,  13,  /*  119 */
    1:  13,  13,  13,   5,   7,   6,   7,  46,  /*  119 */
    1:  46,   3,   5,   6,   3,   3,  40,  40,  /*  119 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  119 */
    1:  59,  40,  40,  40,  40,  40,  40,  40,  /*  119 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  119 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  59,  59,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  40,  /*  120 */
    1:  40,  40,  40,  40,  40,  40,  40,  46,  /*  120 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  121 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  121 */
    1:  46,  46,  40,  40,  40,  40,  40,  40,  /*  121 */
    1:  46,  46,  40,  40,  40,  46,  46,  46,  /*  121 */
    1:   4,   4,   7,  11,  15,   4,   4,  46,  /*  121 */
    1:   7,   7,   7,   7,   7,  15,  15,  46,  /*  121 */
    1:  46,  46,  46,  46,  46,  46,  46,  46,  /*  121 */
    1:  46,  46,  46,  46,  46,  15,  46,  46   /*  121 */
    1: };
    1: 
    1: /* The A table has 124 entries for a total of 496 bytes. */
    1: 
    1: const uint32 js_A[] = {
    1: 0x0001000F,  /*    0   Cc, ignorable */
    1: 0x0004000F,  /*    1   Cc, whitespace */
    1: 0x0004000C,  /*    2   Zs, whitespace */
    1: 0x00000018,  /*    3   Po */
    1: 0x0006001A,  /*    4   Sc, currency */
    1: 0x00000015,  /*    5   Ps */
    1: 0x00000016,  /*    6   Pe */
    1: 0x00000019,  /*    7   Sm */
    1: 0x00000014,  /*    8   Pd */
    1: 0x00036089,  /*    9   Nd, identifier part, decimal 16 */
    1: 0x0827FF81,  /*   10   Lu, hasLower (add 32), identifier start, supradecimal 31 */
    1: 0x0000001B,  /*   11   Sk */
    1: 0x00050017,  /*   12   Pc, underscore */
    1: 0x0817FF82,  /*   13   Ll, hasUpper (subtract 32), identifier start, supradecimal 31 */
    1: 0x0000000C,  /*   14   Zs */
    1: 0x0000001C,  /*   15   So */
    1: 0x00070182,  /*   16   Ll, identifier start */
    1: 0x0000600B,  /*   17   No, decimal 16 */
    1: 0x0000500B,  /*   18   No, decimal 8 */
    1: 0x0000800B,  /*   19   No, strange */
    1: 0x08270181,  /*   20   Lu, hasLower (add 32), identifier start */
    1: 0x08170182,  /*   21   Ll, hasUpper (subtract 32), identifier start */
    1: 0xE1D70182,  /*   22   Ll, hasUpper (subtract -121), identifier start */
    1: 0x00670181,  /*   23   Lu, hasLower (add 1), identifier start */
    1: 0x00570182,  /*   24   Ll, hasUpper (subtract 1), identifier start */
    1: 0xCE670181,  /*   25   Lu, hasLower (add -199), identifier start */
    1: 0x3A170182,  /*   26   Ll, hasUpper (subtract 232), identifier start */
    1: 0xE1E70181,  /*   27   Lu, hasLower (add -121), identifier start */
    1: 0x4B170182,  /*   28   Ll, hasUpper (subtract 300), identifier start */
    1: 0x34A70181,  /*   29   Lu, hasLower (add 210), identifier start */
    1: 0x33A70181,  /*   30   Lu, hasLower (add 206), identifier start */
    1: 0x33670181,  /*   31   Lu, hasLower (add 205), identifier start */
    1: 0x32A70181,  /*   32   Lu, hasLower (add 202), identifier start */
    1: 0x32E70181,  /*   33   Lu, hasLower (add 203), identifier start */
    1: 0x33E70181,  /*   34   Lu, hasLower (add 207), identifier start */
    1: 0x34E70181,  /*   35   Lu, hasLower (add 211), identifier start */
    1: 0x34670181,  /*   36   Lu, hasLower (add 209), identifier start */
    1: 0x35670181,  /*   37   Lu, hasLower (add 213), identifier start */
    1: 0x00070181,  /*   38   Lu, identifier start */
    1: 0x36A70181,  /*   39   Lu, hasLower (add 218), identifier start */
    1: 0x00070185,  /*   40   Lo, identifier start */
    1: 0x36670181,  /*   41   Lu, hasLower (add 217), identifier start */
    1: 0x36E70181,  /*   42   Lu, hasLower (add 219), identifier start */
    1: 0x00AF0181,  /*   43   Lu, hasLower (add 2), hasTitle, identifier start */
    1: 0x007F0183,  /*   44   Lt, hasUpper (subtract 1), hasLower (add 1), hasTitle, identifier start */
    1: 0x009F0182,  /*   45   Ll, hasUpper (subtract 2), hasTitle, identifier start */
    1: 0x00000000,  /*   46   unassigned */
    1: 0x34970182,  /*   47   Ll, hasUpper (subtract 210), identifier start */
    1: 0x33970182,  /*   48   Ll, hasUpper (subtract 206), identifier start */
    1: 0x33570182,  /*   49   Ll, hasUpper (subtract 205), identifier start */
    1: 0x32970182,  /*   50   Ll, hasUpper (subtract 202), identifier start */
    1: 0x32D70182,  /*   51   Ll, hasUpper (subtract 203), identifier start */
    1: 0x33D70182,  /*   52   Ll, hasUpper (subtract 207), identifier start */
    1: 0x34570182,  /*   53   Ll, hasUpper (subtract 209), identifier start */
    1: 0x34D70182,  /*   54   Ll, hasUpper (subtract 211), identifier start */
    1: 0x35570182,  /*   55   Ll, hasUpper (subtract 213), identifier start */
    1: 0x36970182,  /*   56   Ll, hasUpper (subtract 218), identifier start */
    1: 0x36570182,  /*   57   Ll, hasUpper (subtract 217), identifier start */
    1: 0x36D70182,  /*   58   Ll, hasUpper (subtract 219), identifier start */
    1: 0x00070084,  /*   59   Lm, identifier start */
    1: 0x00030086,  /*   60   Mn, identifier part */
    1: 0x09A70181,  /*   61   Lu, hasLower (add 38), identifier start */
    1: 0x09670181,  /*   62   Lu, hasLower (add 37), identifier start */
    1: 0x10270181,  /*   63   Lu, hasLower (add 64), identifier start */
    1: 0x0FE70181,  /*   64   Lu, hasLower (add 63), identifier start */
    1: 0x09970182,  /*   65   Ll, hasUpper (subtract 38), identifier start */
    1: 0x09570182,  /*   66   Ll, hasUpper (subtract 37), identifier start */
    1: 0x10170182,  /*   67   Ll, hasUpper (subtract 64), identifier start */
    1: 0x0FD70182,  /*   68   Ll, hasUpper (subtract 63), identifier start */
    1: 0x0F970182,  /*   69   Ll, hasUpper (subtract 62), identifier start */
    1: 0x0E570182,  /*   70   Ll, hasUpper (subtract 57), identifier start */
    1: 0x0BD70182,  /*   71   Ll, hasUpper (subtract 47), identifier start */
    1: 0x0D970182,  /*   72   Ll, hasUpper (subtract 54), identifier start */
    1: 0x15970182,  /*   73   Ll, hasUpper (subtract 86), identifier start */
    1: 0x14170182,  /*   74   Ll, hasUpper (subtract 80), identifier start */
    1: 0x14270181,  /*   75   Lu, hasLower (add 80), identifier start */
    1: 0x0C270181,  /*   76   Lu, hasLower (add 48), identifier start */
    1: 0x0C170182,  /*   77   Ll, hasUpper (subtract 48), identifier start */
    1: 0x00034089,  /*   78   Nd, identifier part, decimal 0 */
    1: 0x00000087,  /*   79   Me */
    1: 0x00030088,  /*   80   Mc, identifier part */
    1: 0x00037489,  /*   81   Nd, identifier part, decimal 26 */
    1: 0x00005A0B,  /*   82   No, decimal 13 */
    1: 0x00006E0B,  /*   83   No, decimal 23 */
    1: 0x0000740B,  /*   84   No, decimal 26 */
    1: 0x0000000B,  /*   85   No */
    1: 0xFE170182,  /*   86   Ll, hasUpper (subtract -8), identifier start */
    1: 0xFE270181,  /*   87   Lu, hasLower (add -8), identifier start */
    1: 0xED970182,  /*   88   Ll, hasUpper (subtract -74), identifier start */
    1: 0xEA970182,  /*   89   Ll, hasUpper (subtract -86), identifier start */
    1: 0xE7170182,  /*   90   Ll, hasUpper (subtract -100), identifier start */
    1: 0xE0170182,  /*   91   Ll, hasUpper (subtract -128), identifier start */
    1: 0xE4170182,  /*   92   Ll, hasUpper (subtract -112), identifier start */
    1: 0xE0970182,  /*   93   Ll, hasUpper (subtract -126), identifier start */
    1: 0xFDD70182,  /*   94   Ll, hasUpper (subtract -9), identifier start */
    1: 0xEDA70181,  /*   95   Lu, hasLower (add -74), identifier start */
    1: 0xFDE70181,  /*   96   Lu, hasLower (add -9), identifier start */
    1: 0xEAA70181,  /*   97   Lu, hasLower (add -86), identifier start */
    1: 0xE7270181,  /*   98   Lu, hasLower (add -100), identifier start */
    1: 0xFE570182,  /*   99   Ll, hasUpper (subtract -7), identifier start */
    1: 0xE4270181,  /*  100   Lu, hasLower (add -112), identifier start */
    1: 0xFE670181,  /*  101   Lu, hasLower (add -7), identifier start */
    1: 0xE0270181,  /*  102   Lu, hasLower (add -128), identifier start */
    1: 0xE0A70181,  /*  103   Lu, hasLower (add -126), identifier start */
    1: 0x00010010,  /*  104   Cf, ignorable */
    1: 0x0004000D,  /*  105   Zl, whitespace */
    1: 0x0004000E,  /*  106   Zp, whitespace */
    1: 0x0000400B,  /*  107   No, decimal 0 */
    1: 0x0000440B,  /*  108   No, decimal 2 */
    1: 0x0427438A,  /*  109   Nl, hasLower (add 16), identifier start, decimal 1 */
    1: 0x0427818A,  /*  110   Nl, hasLower (add 16), identifier start, strange */
    1: 0x0417638A,  /*  111   Nl, hasUpper (subtract 16), identifier start, decimal 17 */
    1: 0x0417818A,  /*  112   Nl, hasUpper (subtract 16), identifier start, strange */
    1: 0x0007818A,  /*  113   Nl, identifier start, strange */
    1: 0x0000420B,  /*  114   No, decimal 1 */
    1: 0x0000720B,  /*  115   No, decimal 25 */
    1: 0x06A0001C,  /*  116   So, hasLower (add 26) */
    1: 0x0690001C,  /*  117   So, hasUpper (subtract 26) */
    1: 0x00006C0B,  /*  118   No, decimal 22 */
    1: 0x0000560B,  /*  119   No, decimal 11 */
    1: 0x0007738A,  /*  120   Nl, identifier start, decimal 25 */
    1: 0x0007418A,  /*  121   Nl, identifier start, decimal 0 */
    1: 0x00000013,  /*  122   Cs */
    1: 0x00000012   /*  123   Co */
    1: };
    1: 
    1: const jschar js_uriReservedPlusPound_ucstr[] =
    1:     {';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '#', 0};
    1: const jschar js_uriUnescaped_ucstr[] =
    1:     {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    1:      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    1:      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    1:      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    1:      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    1:      '-', '_', '.', '!', '~', '*', '\'', '(', ')', 0};
    1: 
64309: #define ____ false
64309: 
30451: /*
30451:  * This table allows efficient testing for the regular expression \w which is
30451:  * defined by ECMA-262 15.10.2.6 to be [0-9A-Z_a-z].
30451:  */
30451: const bool js_alnum[] = {
64309: /*       0     1     2     3     4     5     6     7     8     9  */
64309: /*  0 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  1 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  2 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  3 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  4 */ ____, ____, ____, ____, ____, ____, ____, ____, true, true,
64309: /*  5 */ true, true, true, true, true, true, true, true, ____, ____,
64309: /*  6 */ ____, ____, ____, ____, ____, true, true, true, true, true,
30451: /*  7 */ true, true, true, true, true, true, true, true, true, true,
30451: /*  8 */ true, true, true, true, true, true, true, true, true, true,
64309: /*  9 */ true, ____, ____, ____, ____, true, ____, true, true, true,
30451: /* 10 */ true, true, true, true, true, true, true, true, true, true,
30451: /* 11 */ true, true, true, true, true, true, true, true, true, true,
64309: /* 12 */ true, true, true, ____, ____, ____, ____, ____
30451: };
30451: 
64310: /*
64310:  * Identifier start chars:
64310:  * -      36:    $
64310:  * -  65..90: A..Z
64310:  * -      95:    _
64310:  * - 97..122: a..z
64310:  */
64310: const bool js_isidstart[] = {
64310: /*       0     1     2     3     4     5     6     7     8     9  */
64310: /*  0 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  1 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  2 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  3 */ ____, ____, ____, ____, ____, ____, true, ____, ____, ____,
64310: /*  4 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  5 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  6 */ ____, ____, ____, ____, ____, true, true, true, true, true, 
64310: /*  7 */ true, true, true, true, true, true, true, true, true, true, 
64310: /*  8 */ true, true, true, true, true, true, true, true, true, true, 
64310: /*  9 */ true, ____, ____, ____, ____, true, ____, true, true, true, 
64310: /* 10 */ true, true, true, true, true, true, true, true, true, true, 
64310: /* 11 */ true, true, true, true, true, true, true, true, true, true, 
64310: /* 12 */ true, true, true, ____, ____, ____, ____, ____
64310: };
64310: 
64310: /*
64310:  * Identifier chars:
64310:  * -      36:    $
64310:  * -  48..57: 0..9
64310:  * -  65..90: A..Z
64310:  * -      95:    _
64310:  * - 97..122: a..z
64310:  */
64310: const bool js_isident[] = {
64310: /*       0     1     2     3     4     5     6     7     8     9  */
64310: /*  0 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  1 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  2 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64310: /*  3 */ ____, ____, ____, ____, ____, ____, true, ____, ____, ____,
64310: /*  4 */ ____, ____, ____, ____, ____, ____, ____, ____, true, true, 
64310: /*  5 */ true, true, true, true, true, true, true, true, ____, ____,
64310: /*  6 */ ____, ____, ____, ____, ____, true, true, true, true, true, 
64310: /*  7 */ true, true, true, true, true, true, true, true, true, true, 
64310: /*  8 */ true, true, true, true, true, true, true, true, true, true, 
64310: /*  9 */ true, ____, ____, ____, ____, true, ____, true, true, true, 
64310: /* 10 */ true, true, true, true, true, true, true, true, true, true, 
64310: /* 11 */ true, true, true, true, true, true, true, true, true, true, 
64310: /* 12 */ true, true, true, ____, ____, ____, ____, ____
64310: };
64310: 
64309: /* Whitespace chars: '\t', '\n', '\v', '\f', '\r', ' '. */
64309: const bool js_isspace[] = {
64309: /*       0     1     2     3     4     5     6     7     8     9  */
64309: /*  0 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, true,
64309: /*  1 */ true, true, true, true, ____, ____, ____, ____, ____, ____,
64309: /*  2 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  3 */ ____, ____, true, ____, ____, ____, ____, ____, ____, ____,
64309: /*  4 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  5 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  6 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  7 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  8 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /*  9 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /* 10 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /* 11 */ ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
64309: /* 12 */ ____, ____, ____, ____, ____, ____, ____, ____
64309: };
64309: 
64309: #undef ____
64309: 
    1: #define URI_CHUNK 64U
    1: 
31890: static inline bool
60571: TransferBufferToString(JSContext *cx, StringBuffer &sb, Value *rval)
    1: {
60571:     JSString *str = sb.finishString();
 4718:     if (!str)
31890:         return false;
48470:     rval->setString(str);
64309:     return true;
    1: }
    1: 
    1: /*
    1:  * ECMA 3, 15.1.3 URI Handling Function Properties
    1:  *
    1:  * The following are implementations of the algorithms
    1:  * given in the ECMA specification for the hidden functions
    1:  * 'Encode' and 'Decode'.
    1:  */
    1: static JSBool
    1: Encode(JSContext *cx, JSString *str, const jschar *unescapedSet,
48470:        const jschar *unescapedSet2, Value *rval)
    1: {
    1:     static const char HexDigits[] = "0123456789ABCDEF"; /* NB: uppercase */
 4718: 
59890:     size_t length = str->length();
59890:     const jschar *chars = str->getChars(cx);
59890:     if (!chars)
59890:         return JS_FALSE;
59890: 
    1:     if (length == 0) {
48470:         rval->setString(cx->runtime->emptyString);
    1:         return JS_TRUE;
    1:     }
    1: 
60571:     StringBuffer sb(cx);
59890:     jschar hexBuf[4];
    1:     hexBuf[0] = '%';
    1:     hexBuf[3] = 0;
59890:     for (size_t k = 0; k < length; k++) {
59890:         jschar c = chars[k];
    1:         if (js_strchr(unescapedSet, c) ||
    1:             (unescapedSet2 && js_strchr(unescapedSet2, c))) {
60571:             if (!sb.append(c))
31890:                 return JS_FALSE;
    1:         } else {
    1:             if ((c >= 0xDC00) && (c <= 0xDFFF)) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_URI, NULL);
31890:                 return JS_FALSE;
    1:             }
59890:             uint32 v;
    1:             if (c < 0xD800 || c > 0xDBFF) {
    1:                 v = c;
    1:             } else {
    1:                 k++;
    1:                 if (k == length) {
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_URI, NULL);
31890:                     return JS_FALSE;
    1:                 }
59890:                 jschar c2 = chars[k];
    1:                 if ((c2 < 0xDC00) || (c2 > 0xDFFF)) {
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_URI, NULL);
31890:                     return JS_FALSE;
    1:                 }
    1:                 v = ((c - 0xD800) << 10) + (c2 - 0xDC00) + 0x10000;
    1:             }
59890:             uint8 utf8buf[4];
59890:             size_t L = js_OneUcs4ToUtf8Char(utf8buf, v);
59890:             for (size_t j = 0; j < L; j++) {
    1:                 hexBuf[1] = HexDigits[utf8buf[j] >> 4];
    1:                 hexBuf[2] = HexDigits[utf8buf[j] & 0xf];
60571:                 if (!sb.append(hexBuf, 3))
    1:                     return JS_FALSE;
    1:             }
31890:         }
31890:     }
31890: 
60571:     return TransferBufferToString(cx, sb, rval);
31890: }
    1: 
    1: static JSBool
48470: Decode(JSContext *cx, JSString *str, const jschar *reservedSet, Value *rval)
    1: {
59890:     size_t length = str->length();
59890:     const jschar *chars = str->getChars(cx);
59890:     if (!chars)
59890:         return JS_FALSE;
59890: 
    1:     if (length == 0) {
48470:         rval->setString(cx->runtime->emptyString);
    1:         return JS_TRUE;
    1:     }
    1: 
60571:     StringBuffer sb(cx);
59890:     for (size_t k = 0; k < length; k++) {
59890:         jschar c = chars[k];
    1:         if (c == '%') {
59890:             size_t start = k;
    1:             if ((k + 2) >= length)
 4718:                 goto report_bad_uri;
    1:             if (!JS7_ISHEX(chars[k+1]) || !JS7_ISHEX(chars[k+2]))
 4718:                 goto report_bad_uri;
59890:             jsuint B = JS7_UNHEX(chars[k+1]) * 16 + JS7_UNHEX(chars[k+2]);
    1:             k += 2;
    1:             if (!(B & 0x80)) {
    1:                 c = (jschar)B;
    1:             } else {
59890:                 intN n = 1;
    1:                 while (B & (0x80 >> n))
    1:                     n++;
33589:                 if (n == 1 || n > 4)
 4718:                     goto report_bad_uri;
59890:                 uint8 octets[4];
    1:                 octets[0] = (uint8)B;
    1:                 if (k + 3 * (n - 1) >= length)
 4718:                     goto report_bad_uri;
59890:                 for (intN j = 1; j < n; j++) {
    1:                     k++;
    1:                     if (chars[k] != '%')
 4718:                         goto report_bad_uri;
    1:                     if (!JS7_ISHEX(chars[k+1]) || !JS7_ISHEX(chars[k+2]))
 4718:                         goto report_bad_uri;
    1:                     B = JS7_UNHEX(chars[k+1]) * 16 + JS7_UNHEX(chars[k+2]);
    1:                     if ((B & 0xC0) != 0x80)
 4718:                         goto report_bad_uri;
    1:                     k += 2;
    1:                     octets[j] = (char)B;
    1:                 }
59890:                 uint32 v = Utf8ToOneUcs4Char(octets, n);
    1:                 if (v >= 0x10000) {
    1:                     v -= 0x10000;
    1:                     if (v > 0xFFFFF)
 4718:                         goto report_bad_uri;
    1:                     c = (jschar)((v & 0x3FF) + 0xDC00);
59890:                     jschar H = (jschar)((v >> 10) + 0xD800);
60571:                     if (!sb.append(H))
31890:                         return JS_FALSE;
    1:                 } else {
    1:                     c = (jschar)v;
    1:                 }
    1:             }
    1:             if (js_strchr(reservedSet, c)) {
60571:                 if (!sb.append(chars + start, k - start + 1))
31890:                     return JS_FALSE;
 4718:             } else {
60571:                 if (!sb.append(c))
31890:                     return JS_FALSE;
 4718:             }
 4718:         } else {
60571:             if (!sb.append(c))
    1:                 return JS_FALSE;
 4718:         }
 4718:     }
 4718: 
60571:     return TransferBufferToString(cx, sb, rval);
    1: 
 4718:   report_bad_uri:
 4718:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_URI);
 4718:     /* FALL THROUGH */
 4718: 
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
48470: str_decodeURI(JSContext *cx, uintN argc, Value *vp)
    1: {
59890:     JSLinearString *str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     return Decode(cx, str, js_uriReservedPlusPound_ucstr, vp);
    1: }
    1: 
    1: static JSBool
48470: str_decodeURI_Component(JSContext *cx, uintN argc, Value *vp)
    1: {
59890:     JSLinearString *str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     return Decode(cx, str, js_empty_ucstr, vp);
    1: }
    1: 
    1: static JSBool
48470: str_encodeURI(JSContext *cx, uintN argc, Value *vp)
    1: {
59890:     JSLinearString *str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
    1:     return Encode(cx, str, js_uriReservedPlusPound_ucstr, js_uriUnescaped_ucstr,
 4127:                   vp);
    1: }
    1: 
    1: static JSBool
48470: str_encodeURI_Component(JSContext *cx, uintN argc, Value *vp)
    1: {
59890:     JSLinearString *str = ArgToRootedString(cx, argc, vp, 0);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     return Encode(cx, str, js_uriUnescaped_ucstr, NULL, vp);
    1: }
    1: 
    1: /*
    1:  * Convert one UCS-4 char and write it into a UTF-8 buffer, which must be at
33589:  * least 4 bytes long.  Return the number of UTF-8 bytes of data written.
    1:  */
    1: int
    1: js_OneUcs4ToUtf8Char(uint8 *utf8Buffer, uint32 ucs4Char)
    1: {
    1:     int utf8Length = 1;
    1: 
33589:     JS_ASSERT(ucs4Char <= 0x10FFFF);
    1:     if (ucs4Char < 0x80) {
    1:         *utf8Buffer = (uint8)ucs4Char;
    1:     } else {
    1:         int i;
    1:         uint32 a = ucs4Char >> 11;
    1:         utf8Length = 2;
    1:         while (a) {
    1:             a >>= 5;
    1:             utf8Length++;
    1:         }
    1:         i = utf8Length;
    1:         while (--i) {
    1:             utf8Buffer[i] = (uint8)((ucs4Char & 0x3F) | 0x80);
    1:             ucs4Char >>= 6;
    1:         }
    1:         *utf8Buffer = (uint8)(0x100 - (1 << (8-utf8Length)) + ucs4Char);
    1:     }
    1:     return utf8Length;
    1: }
    1: 
    1: /*
    1:  * Convert a utf8 character sequence into a UCS-4 character and return that
    1:  * character.  It is assumed that the caller already checked that the sequence
    1:  * is valid.
    1:  */
    1: static uint32
    1: Utf8ToOneUcs4Char(const uint8 *utf8Buffer, int utf8Length)
    1: {
    1:     uint32 ucs4Char;
    1:     uint32 minucs4Char;
    1:     /* from Unicode 3.1, non-shortest form is illegal */
    1:     static const uint32 minucs4Table[] = {
33589:         0x00000080, 0x00000800, 0x00010000
    1:     };
    1: 
33589:     JS_ASSERT(utf8Length >= 1 && utf8Length <= 4);
    1:     if (utf8Length == 1) {
    1:         ucs4Char = *utf8Buffer;
    1:         JS_ASSERT(!(ucs4Char & 0x80));
    1:     } else {
    1:         JS_ASSERT((*utf8Buffer & (0x100 - (1 << (7-utf8Length)))) ==
    1:                   (0x100 - (1 << (8-utf8Length))));
    1:         ucs4Char = *utf8Buffer++ & ((1<<(7-utf8Length))-1);
    1:         minucs4Char = minucs4Table[utf8Length-2];
    1:         while (--utf8Length) {
    1:             JS_ASSERT((*utf8Buffer & 0xC0) == 0x80);
    1:             ucs4Char = ucs4Char<<6 | (*utf8Buffer++ & 0x3F);
    1:         }
33589:         if (JS_UNLIKELY(ucs4Char < minucs4Char)) {
33589:             ucs4Char = OVERLONG_UTF8;
33589:         } else if (ucs4Char == 0xFFFE || ucs4Char == 0xFFFF) {
    1:             ucs4Char = 0xFFFD;
    1:         }
    1:     }
    1:     return ucs4Char;
    1: }
    1: 
57721: namespace js {
57721: 
57721: size_t
59890: PutEscapedStringImpl(char *buffer, size_t bufferSize, FILE *fp, JSLinearString *str, uint32 quote)
    1: {
    1:     enum {
    1:         STOP, FIRST_QUOTE, LAST_QUOTE, CHARS, ESCAPE_START, ESCAPE_MORE
    1:     } state;
    1: 
    1:     JS_ASSERT(quote == 0 || quote == '\'' || quote == '"');
    1:     JS_ASSERT_IF(!buffer, bufferSize == 0);
    1:     JS_ASSERT_IF(fp, !buffer);
    1: 
57721:     if (bufferSize == 0)
57721:         buffer = NULL;
57721:     else
57721:         bufferSize--;
57721: 
59890:     const jschar *chars = str->chars();
59890:     const jschar *charsEnd = chars + str->length();
59890:     size_t n = 0;
    1:     state = FIRST_QUOTE;
59890:     uintN shift = 0;
59890:     uintN hex = 0;
59890:     uintN u = 0;
59890:     char c = 0;  /* to quell GCC warnings */
    1: 
    1:     for (;;) {
    1:         switch (state) {
    1:           case STOP:
    1:             goto stop;
    1:           case FIRST_QUOTE:
    1:             state = CHARS;
    1:             goto do_quote;
    1:           case LAST_QUOTE:
    1:             state = STOP;
    1:           do_quote:
    1:             if (quote == 0)
    1:                 continue;
    1:             c = (char)quote;
    1:             break;
    1:           case CHARS:
    1:             if (chars == charsEnd) {
    1:                 state = LAST_QUOTE;
    1:                 continue;
    1:             }
    1:             u = *chars++;
    1:             if (u < ' ') {
  814:                 if (u != 0) {
59890:                     const char *escape = strchr(js_EscapeMap, (int)u);
    1:                     if (escape) {
    1:                         u = escape[1];
    1:                         goto do_escape;
    1:                     }
  814:                 }
    1:                 goto do_hex_escape;
    1:             }
    1:             if (u < 127) {
    1:                 if (u == quote || u == '\\')
    1:                     goto do_escape;
    1:                 c = (char)u;
    1:             } else if (u < 0x100) {
    1:                 goto do_hex_escape;
    1:             } else {
    1:                 shift = 16;
    1:                 hex = u;
    1:                 u = 'u';
    1:                 goto do_escape;
    1:             }
    1:             break;
    1:           do_hex_escape:
    1:             shift = 8;
    1:             hex = u;
    1:             u = 'x';
    1:           do_escape:
    1:             c = '\\';
    1:             state = ESCAPE_START;
    1:             break;
    1:           case ESCAPE_START:
    1:             JS_ASSERT(' ' <= u && u < 127);
    1:             c = (char)u;
    1:             state = ESCAPE_MORE;
    1:             break;
    1:           case ESCAPE_MORE:
    1:             if (shift == 0) {
    1:                 state = CHARS;
    1:                 continue;
    1:             }
    1:             shift -= 4;
    1:             u = 0xF & (hex >> shift);
    1:             c = (char)(u + (u < 10 ? '0' : 'A' - 10));
    1:             break;
    1:         }
    1:         if (buffer) {
57721:             JS_ASSERT(n <= bufferSize);
57721:             if (n != bufferSize) {
    1:                 buffer[n] = c;
57721:             } else {
57721:                 buffer[n] = '\0';
57721:                 buffer = NULL;
57721:             }
    1:         } else if (fp) {
57721:             if (fputc(c, fp) < 0)
57721:                 return size_t(-1);
    1:         }
    1:         n++;
    1:     }
    1:   stop:
    1:     if (buffer)
    1:         buffer[n] = '\0';
    1:     return n;
    1: }
    1: 
57721: } /* namespace js */
