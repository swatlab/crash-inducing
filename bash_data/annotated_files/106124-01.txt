 86979: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* High level class and public functions implementation. */
     1: 
 90200: #include "mozilla/Assertions.h"
 90200: #include "mozilla/Base64.h"
 90200: #include "mozilla/Util.h"
 90200: 
     1: #include "xpcprivate.h"
 25050: #include "XPCWrapper.h"
     1: #include "nsBaseHashtable.h"
     1: #include "nsHashKeys.h"
    33: #include "jsatom.h"
 74914: #include "jsfriendapi.h"
 62690: #include "jsgc.h"
 18543: #include "dom_quickstubs.h"
 55669: #include "nsNullPrincipal.h"
 55669: #include "nsIURI.h"
 57074: #include "nsJSEnvironment.h"
 87321: #include "nsThreadUtils.h"
 37415: 
 47578: #include "XrayWrapper.h"
 55659: #include "WrapperFactory.h"
 55669: #include "AccessCheck.h"
 47574: 
 93515: #ifdef MOZ_JSDEBUGGER
 56783: #include "jsdIDebuggerService.h"
 93515: #endif
 56783: 
 80384: #include "XPCQuickStubs.h"
 80071: #include "dombindings.h"
 86226: 
 97422: #include "mozilla/dom/BindingUtils.h"
 94512: 
 80074: #include "nsWrapperCacheInlines.h"
 94465: #include "nsDOMMutationObserver.h"
 59217: 
 94512: using namespace mozilla::dom;
 99328: using namespace xpc;
 94512: 
 74914: NS_IMPL_THREADSAFE_ISUPPORTS7(nsXPConnect,
  3310:                               nsIXPConnect,
  3310:                               nsISupportsWeakReference,
 20312:                               nsIThreadObserver,
 20462:                               nsIJSRuntimeService,
 20462:                               nsIJSContextStack,
 74914:                               nsIThreadJSContextStack,
 74914:                               nsIJSEngineTelemetryStats)
     1: 
     1: nsXPConnect* nsXPConnect::gSelf = nsnull;
 82794: JSBool       nsXPConnect::gOnceAliveNowDead = false;
 14170: PRUint32     nsXPConnect::gReportAllJSExceptions = 0;
 82794: JSBool       nsXPConnect::gDebugMode = false;
 82794: JSBool       nsXPConnect::gDesiredDebugMode = false;
     1: 
  8870: // Global cache of the default script security manager (QI'd to
  8870: // nsIScriptSecurityManager)
 56703: nsIScriptSecurityManager *nsXPConnect::gScriptSecurityManager = nsnull;
  8870: 
     1: const char XPC_CONTEXT_STACK_CONTRACTID[] = "@mozilla.org/js/xpc/ContextStack;1";
     1: const char XPC_RUNTIME_CONTRACTID[]       = "@mozilla.org/js/xpc/RuntimeService;1";
     1: const char XPC_EXCEPTION_CONTRACTID[]     = "@mozilla.org/js/xpc/Exception;1";
     1: const char XPC_CONSOLE_CONTRACTID[]       = "@mozilla.org/consoleservice;1";
     1: const char XPC_SCRIPT_ERROR_CONTRACTID[]  = "@mozilla.org/scripterror;1";
     1: const char XPC_ID_CONTRACTID[]            = "@mozilla.org/js/xpc/ID;1";
     1: const char XPC_XPCONNECT_CONTRACTID[]     = "@mozilla.org/js/xpc/XPConnect;1";
     1: 
     1: /***************************************************************************/
     1: 
     1: nsXPConnect::nsXPConnect()
     1:     :   mRuntime(nsnull),
     1:         mInterfaceInfoManager(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID)),
     1:         mDefaultSecurityManager(nsnull),
     1:         mDefaultSecurityManagerFlags(0),
 82794:         mShuttingDown(false),
 82794:         mNeedGCBeforeCC(true),
 87321:         mEventDepth(0),
 48507:         mCycleCollectionContext(nsnull)
     1: {
 20312:     mRuntime = XPCJSRuntime::newXPCJSRuntime(this);
     1: 
 97525:     nsCycleCollector_registerJSRuntime(this);
     1: 
 14170:     char* reportableEnv = PR_GetEnv("MOZ_REPORT_ALL_JS_EXCEPTIONS");
 14170:     if (reportableEnv && *reportableEnv)
 14170:         gReportAllJSExceptions = 1;
     1: }
     1: 
     1: nsXPConnect::~nsXPConnect()
     1: {
 97525:     nsCycleCollector_forgetJSRuntime();
     1: 
  2991:     JSContext *cx = nsnull;
  2991:     if (mRuntime) {
  3100:         // Create our own JSContext rather than an XPCCallContext, since
  3100:         // otherwise we will create a new safe JS context and attach a
  3100:         // components object that won't get GCed.
 31897:         cx = JS_NewContext(mRuntime->GetJSRuntime(), 8192);
  2991:     }
  2991: 
102552:     // This needs to happen exactly here, otherwise we leak at shutdown. I don't
102552:     // know why. :-(
102552:     mRuntime->DestroyJSContextStack();
102552: 
 82794:     mShuttingDown = true;
  2991:     if (cx) {
  2991:         // XXX Call even if |mRuntime| null?
 89826:         XPCWrappedNativeScope::SystemIsBeingShutDown();
 89826: 
 89826:         mRuntime->SystemIsBeingShutDown();
  2991:         JS_DestroyContext(cx);
     1:     }
     1: 
     1:     NS_IF_RELEASE(mDefaultSecurityManager);
     1: 
  8870:     gScriptSecurityManager = nsnull;
  8870: 
     1:     // shutdown the logging system
     1:     XPC_LOG_FINISH();
     1: 
     1:     delete mRuntime;
     1: 
     1:     gSelf = nsnull;
 82794:     gOnceAliveNowDead = true;
     1: }
     1: 
     1: // static
     1: nsXPConnect*
     1: nsXPConnect::GetXPConnect()
     1: {
 87322:     // Do a release-mode assert that we're not doing anything significant in
 87322:     // XPConnect off the main thread. If you're an extension developer hitting
 87322:     // this, you need to change your code. See bug 716167.
 87322:     if (!NS_LIKELY(NS_IsMainThread() || NS_IsCycleCollectorThread()))
102242:         MOZ_CRASH();
 87322: 
 80389:     if (!gSelf) {
     1:         if (gOnceAliveNowDead)
     1:             return nsnull;
     1:         gSelf = new nsXPConnect();
     1:         if (!gSelf)
     1:             return nsnull;
     1: 
 62680:         if (!gSelf->mRuntime) {
 62680:             NS_RUNTIMEABORT("Couldn't create XPCJSRuntime.");
     1:         }
 62680:         if (!gSelf->mInterfaceInfoManager) {
 62680:             NS_RUNTIMEABORT("Couldn't get global interface info manager.");
 62680:         }
 62680: 
     1:         // Initial extra ref to keep the singleton alive
     1:         // balanced by explicit call to ReleaseXPConnectSingleton()
     1:         NS_ADDREF(gSelf);
 87321: 
 87321:         // Add XPConnect as an thread observer.
 87321:         //
 87321:         // The cycle collector sometimes calls GetXPConnect, but it should never
 87321:         // be the one that initializes gSelf.
 87321:         MOZ_ASSERT(NS_IsMainThread());
 87321:         nsCOMPtr<nsIThreadInternal> thread = do_QueryInterface(NS_GetCurrentThread());
 87321:         if (NS_FAILED(thread->AddObserver(gSelf))) {
  3310:             NS_RELEASE(gSelf);
  3310:             // Fall through to returning null
  3310:         }
     1:     }
     1:     return gSelf;
     1: }
     1: 
     1: // static
     1: nsXPConnect*
     1: nsXPConnect::GetSingleton()
     1: {
     1:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
     1:     NS_IF_ADDREF(xpc);
     1:     return xpc;
     1: }
     1: 
     1: // static
     1: void
     1: nsXPConnect::ReleaseXPConnectSingleton()
     1: {
     1:     nsXPConnect* xpc = gSelf;
 80389:     if (xpc) {
 87321: 
 87321:         // The thread subsystem may have been shut down already, so make sure
 87321:         // to check for null here.
 87321:         nsCOMPtr<nsIThreadInternal> thread = do_QueryInterface(NS_GetCurrentThread());
 87321:         if (thread) {
 87321:             MOZ_ASSERT(NS_IsMainThread());
 87321:             thread->RemoveObserver(xpc);
 87321:         }
     1: 
   858: #ifdef DEBUG
     1:         // force a dump of the JavaScript gc heap if JS is still alive
   858:         // if requested through XPC_SHUTDOWN_HEAP_DUMP environment variable
 20462:         {
   858:             const char* dumpName = getenv("XPC_SHUTDOWN_HEAP_DUMP");
 80389:             if (dumpName) {
   858:                 FILE* dumpFile = (*dumpName == '\0' ||
   858:                                   strcmp(dumpName, "stdout") == 0)
   858:                                  ? stdout
   858:                                  : fopen(dumpName, "w");
 80389:                 if (dumpFile) {
 91339:                     JS_DumpHeap(xpc->GetRuntime()->GetJSRuntime(), dumpFile, nsnull,
 91339:                                 JSTRACE_OBJECT, nsnull, static_cast<size_t>(-1), nsnull);
   858:                     if (dumpFile != stdout)
   858:                         fclose(dumpFile);
   858:                 }
   858:             }
     1:         }
     1: #endif
     1: #ifdef XPC_DUMP_AT_SHUTDOWN
     1:         // NOTE: to see really interesting stuff turn on the prlog stuff.
 80384:         // See the comment at the top of XPCLog.h to see how to do that.
     1:         xpc->DebugDump(7);
     1: #endif
     1:         nsrefcnt cnt;
     1:         NS_RELEASE2(xpc, cnt);
     1: #ifdef XPC_DUMP_AT_SHUTDOWN
     1:         if (0 != cnt)
     1:             printf("*** dangling reference to nsXPConnect: refcnt=%d\n", cnt);
     1:         else
     1:             printf("+++ XPConnect had no dangling references.\n");
     1: #endif
     1:     }
     1: }
     1: 
     1: // static
     1: nsresult
     1: nsXPConnect::GetInterfaceInfoManager(nsIInterfaceInfoSuperManager** iim,
     1:                                      nsXPConnect* xpc /*= nsnull*/)
     1: {
     1:     if (!xpc && !(xpc = GetXPConnect()))
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     *iim = xpc->mInterfaceInfoManager;
     1:     NS_IF_ADDREF(*iim);
     1:     return NS_OK;
     1: }
     1: 
     1: // static
     1: XPCJSRuntime*
 20312: nsXPConnect::GetRuntimeInstance()
     1: {
 20312:     nsXPConnect* xpc = GetXPConnect();
 20312:     NS_ASSERTION(xpc, "Must not be called if XPC failed to initialize");
 20312:     return xpc->GetRuntime();
     1: }
     1: 
     1: // static
     1: JSBool
     1: nsXPConnect::IsISupportsDescendant(nsIInterfaceInfo* info)
     1: {
 79445:     bool found = false;
     1:     if (info)
     1:         info->HasAncestor(&NS_GET_IID(nsISupports), &found);
     1:     return found;
     1: }
     1: 
     1: /***************************************************************************/
     1: 
 79445: typedef bool (*InfoTester)(nsIInterfaceInfoManager* manager, const void* data,
     1:                            nsIInterfaceInfo** info);
     1: 
 79445: static bool IIDTester(nsIInterfaceInfoManager* manager, const void* data,
     1:                       nsIInterfaceInfo** info)
     1: {
     1:     return NS_SUCCEEDED(manager->GetInfoForIID((const nsIID *) data, info)) &&
     1:            *info;
     1: }
     1: 
 79445: static bool NameTester(nsIInterfaceInfoManager* manager, const void* data,
     1:                        nsIInterfaceInfo** info)
     1: {
     1:     return NS_SUCCEEDED(manager->GetInfoForName((const char *) data, info)) &&
     1:            *info;
     1: }
     1: 
     1: static nsresult FindInfo(InfoTester tester, const void* data,
     1:                          nsIInterfaceInfoSuperManager* iism,
     1:                          nsIInterfaceInfo** info)
     1: {
     1:     if (tester(iism, data, info))
     1:         return NS_OK;
     1: 
     1:     // If not found, then let's ask additional managers.
     1: 
 79445:     bool yes;
     1:     nsCOMPtr<nsISimpleEnumerator> list;
     1: 
     1:     if (NS_SUCCEEDED(iism->HasAdditionalManagers(&yes)) && yes &&
     1:         NS_SUCCEEDED(iism->EnumerateAdditionalManagers(getter_AddRefs(list))) &&
 80389:         list) {
 79445:         bool more;
     1:         nsCOMPtr<nsIInterfaceInfoManager> current;
     1: 
     1:         while (NS_SUCCEEDED(list->HasMoreElements(&more)) && more &&
 80389:                NS_SUCCEEDED(list->GetNext(getter_AddRefs(current))) && current) {
     1:             if (tester(current, data, info))
     1:                 return NS_OK;
     1:         }
     1:     }
     1: 
     1:     return NS_ERROR_NO_INTERFACE;
     1: }
     1: 
     1: nsresult
     1: nsXPConnect::GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info)
     1: {
     1:     return FindInfo(IIDTester, aIID, mInterfaceInfoManager, info);
     1: }
     1: 
     1: nsresult
     1: nsXPConnect::GetInfoForName(const char * name, nsIInterfaceInfo** info)
     1: {
     1:     return FindInfo(NameTester, name, mInterfaceInfoManager, info);
     1: }
     1: 
 71367: bool
 71367: nsXPConnect::NeedCollect()
 71367: {
 71367:     return !!mNeedGCBeforeCC;
 71367: }
 71367: 
 48507: void
103363: nsXPConnect::Collect(PRUint32 reason)
     1: {
  7286:     // We're dividing JS objects into 2 categories:
  7286:     //
  7286:     // 1. "real" roots, held by the JS engine itself or rooted through the root
  7286:     //    and lock JS APIs. Roots from this category are considered black in the
  7286:     //    cycle collector, any cycle they participate in is uncollectable.
  7286:     //
  7286:     // 2. roots held by C++ objects that participate in cycle collection,
  7286:     //    held by XPConnect (see XPCJSRuntime::TraceXPConnectRoots). Roots from
  7286:     //    this category are considered grey in the cycle collector, their final
 48479:     //    color depends on the objects that hold them.
  7286:     //
  7286:     // Note that if a root is in both categories it is the fact that it is in
  7286:     // category 1 that takes precedence, so it will be considered black.
  7286:     //
 48479:     // During garbage collection we switch to an additional mark color (gray)
 48479:     // when tracing inside TraceXPConnectRoots. This allows us to walk those
 48479:     // roots later on and add all objects reachable only from them to the
 48479:     // cycle collector.
  7286:     //
 48479:     // Phases:
  7286:     //
  7286:     // 1. marking of the roots in category 1 by having the JS GC do its marking
 48479:     // 2. marking of the roots in category 2 by XPCJSRuntime::TraceXPConnectRoots
 48479:     //    using an additional color (gray).
 48479:     // 3. end of GC, GC can sweep its heap
  7286:     //
 48507:     // At some later point, when the cycle collector runs:
 48507:     //
 48479:     // 4. walk gray objects and add them to the cycle collector, cycle collect
 47580:     //
 48479:     // JS objects that are part of cycles the cycle collector breaks will be
 48479:     // collected by the next JS.
  7286:     //
 96941:     // If WantAllTraces() is false the cycle collector will not traverse roots
  7286:     // from category 1 or any JS objects held by them. Any JS objects they hold
  7286:     // will already be marked by the JS GC and will thus be colored black
  7286:     // themselves. Any C++ objects they hold will have a missing (untraversed)
  7286:     // edge from the JS object to the C++ object and so it will be marked black
  7286:     // too. This decreases the number of objects that the cycle collector has to
  7286:     // deal with.
 96941:     // To improve debugging, if WantAllTraces() is true all JS objects are
  7286:     // traversed.
     1: 
 88182:     MOZ_ASSERT(reason < js::gcreason::NUM_REASONS);
 88182:     js::gcreason::Reason gcreason = (js::gcreason::Reason)reason;
 94960: 
 94960:     JSRuntime *rt = GetRuntime()->GetJSRuntime();
 94871:     js::PrepareForFullGC(rt);
 94960:     js::GCForReason(rt, gcreason);
 48507: }
 48507: 
 48507: NS_IMETHODIMP
103363: nsXPConnect::GarbageCollect(PRUint32 reason)
 48507: {
103363:     Collect(reason);
 48507:     return NS_OK;
  7286: }
  7286: 
 82726: struct NoteWeakMapChildrenTracer : public JSTracer
 82726: {
 82726:     NoteWeakMapChildrenTracer(nsCycleCollectionTraversalCallback &cb)
 82726:         : mCb(cb)
 82726:     {
 82726:     }
 82726:     nsCycleCollectionTraversalCallback &mCb;
 82726:     JSObject *mMap;
 82726:     void *mKey;
 82726: };
 82726: 
 82726: static void
 90232: TraceWeakMappingChild(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 82726: {
 90200:     MOZ_ASSERT(trc->callback == TraceWeakMappingChild);
 90232:     void *thing = *thingp;
 82726:     NoteWeakMapChildrenTracer *tracer =
 82726:         static_cast<NoteWeakMapChildrenTracer *>(trc);
 82726:     if (kind == JSTRACE_STRING)
 82726:         return;
 82726:     if (!xpc_IsGrayGCThing(thing) && !tracer->mCb.WantAllTraces())
 82726:         return;
 82726:     if (AddToCCKind(kind)) {
 82726:         tracer->mCb.NoteWeakMapping(tracer->mMap, tracer->mKey, thing);
 82726:     } else {
 82726:         JS_TraceChildren(trc, thing, kind);
 82726:     }
 82726: }
 82726: 
 82726: struct NoteWeakMapsTracer : public js::WeakMapTracer
 82726: {
 91339:     NoteWeakMapsTracer(JSRuntime *rt, js::WeakMapTraceCallback cb,
 82726:                        nsCycleCollectionTraversalCallback &cccb)
 91339:       : js::WeakMapTracer(rt, cb), mCb(cccb), mChildTracer(cccb)
 82726:     {
 91339:         JS_TracerInit(&mChildTracer, rt, TraceWeakMappingChild);
 82726:     }
 82726:     nsCycleCollectionTraversalCallback &mCb;
 82726:     NoteWeakMapChildrenTracer mChildTracer;
 82726: };
 82726: 
 82726: static void
 82726: TraceWeakMapping(js::WeakMapTracer *trc, JSObject *m,
 82726:                  void *k, JSGCTraceKind kkind,
 82726:                  void *v, JSGCTraceKind vkind)
 82726: {
 90200:     MOZ_ASSERT(trc->callback == TraceWeakMapping);
 82726:     NoteWeakMapsTracer *tracer = static_cast<NoteWeakMapsTracer *>(trc);
 82726:     if (vkind == JSTRACE_STRING)
 82726:         return;
 82726:     if (!xpc_IsGrayGCThing(v) && !tracer->mCb.WantAllTraces())
 82726:         return;
 82726: 
 82726:     // The cycle collector can only properly reason about weak maps if it can
 82726:     // reason about the liveness of their keys, which in turn requires that
 82726:     // the key can be represented in the cycle collector graph.  All existing
 82726:     // uses of weak maps use either objects or scripts as keys, which are okay.
 90200:     MOZ_ASSERT(AddToCCKind(kkind));
 82726: 
 82726:     // As an emergency fallback for non-debug builds, if the key is not
 82726:     // representable in the cycle collector graph, we treat it as marked.  This
 82726:     // can cause leaks, but is preferable to ignoring the binding, which could
 82726:     // cause the cycle collector to free live objects.
 82726:     if (!AddToCCKind(kkind))
 82726:         k = nsnull;
 82726: 
 82726:     if (AddToCCKind(vkind)) {
 82726:         tracer->mCb.NoteWeakMapping(m, k, v);
 82726:     } else {
 82726:         tracer->mChildTracer.mMap = m;
 82726:         tracer->mChildTracer.mKey = k;
 82726:         JS_TraceChildren(&tracer->mChildTracer, v, vkind);
 82726:     }
 82726: }
 82726: 
  7286: nsresult
 96941: nsXPConnect::BeginCycleCollection(nsCycleCollectionTraversalCallback &cb)
  7286: {
 74825:     // It is important not to call GetSafeJSContext while on the
 74825:     // cycle-collector thread since this context will be destroyed
 74825:     // asynchronously and race with the main thread. In particular, we must
 74825:     // ensure that a context is passed to the XPCCallContext constructor.
 74825:     JSContext *cx = mRuntime->GetJSCycleCollectionContext();
 74825:     if (!cx)
 74825:         return NS_ERROR_OUT_OF_MEMORY;
 74825: 
 57794:     NS_ASSERTION(!mCycleCollectionContext, "Didn't call FinishTraverse?");
 74825:     mCycleCollectionContext = new XPCCallContext(NATIVE_CALLER, cx);
 48507:     if (!mCycleCollectionContext->IsValid()) {
 48507:         mCycleCollectionContext = nsnull;
 57794:         return NS_ERROR_FAILURE;
 48507:     }
 48507: 
 63073:     static bool gcHasRun = false;
 80389:     if (!gcHasRun) {
 91250:         JSRuntime* rt = GetRuntime()->GetJSRuntime();
 84755:         uint32_t gcNumber = JS_GetGCParameter(rt, JSGC_NUMBER);
 63073:         if (!gcNumber)
 63073:             NS_RUNTIMEABORT("Cannot cycle collect if GC has not run first!");
 63073:         gcHasRun = true;
 63073:     }
 63073: 
 91250:     GetRuntime()->AddXPConnectRoots(cb);
  2954: 
 91339:     NoteWeakMapsTracer trc(GetRuntime()->GetJSRuntime(), TraceWeakMapping, cb);
 82726:     js::TraceWeakMaps(&trc);
 82726: 
     1:     return NS_OK;
     1: }
     1: 
 88135: bool
 81562: nsXPConnect::NotifyLeaveMainThread()
 81562: {
 81562:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "Off main thread");
 88135:     JSRuntime *rt = mRuntime->GetJSRuntime();
 88135:     if (JS_IsInRequest(rt) || JS_IsInSuspendedRequest(rt))
 88135:         return false;
 88135:     JS_ClearRuntimeThread(rt);
 88135:     return true;
 81562: }
 81562: 
 81562: void
 81562: nsXPConnect::NotifyEnterCycleCollectionThread()
 81562: {
 81562:     NS_ABORT_IF_FALSE(!NS_IsMainThread(), "On main thread");
 81562:     JS_SetRuntimeThread(mRuntime->GetJSRuntime());
 81562: }
 81562: 
 81562: void
 81562: nsXPConnect::NotifyLeaveCycleCollectionThread()
 81562: {
 81562:     NS_ABORT_IF_FALSE(!NS_IsMainThread(), "On main thread");
 81562:     JS_ClearRuntimeThread(mRuntime->GetJSRuntime());
 81562: }
 81562: 
 81562: void
 81562: nsXPConnect::NotifyEnterMainThread()
 81562: {
 81562:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "Off main thread");
 81562:     JS_SetRuntimeThread(mRuntime->GetJSRuntime());
 81562: }
 81562: 
     1: nsresult
 57794: nsXPConnect::FinishTraverse()
     1: {
 88135:     if (mCycleCollectionContext)
  1084:         mCycleCollectionContext = nsnull;
 57794:     return NS_OK;
 57794: }
 57794: 
102293: class nsXPConnectParticipant: public nsCycleCollectionParticipant
102293: {
102293: public:
102293:     static NS_METHOD RootImpl(void *n)
102293:     {
102293:         return NS_OK;
102293:     }
102293:     static NS_METHOD UnlinkImpl(void *n)
102293:     {
102293:         return NS_OK;
102293:     }
102293:     static NS_METHOD UnrootImpl(void *n)
102293:     {
102293:         return NS_OK;
102293:     }
102293:     static NS_METHOD TraverseImpl(nsXPConnectParticipant *that, void *n,
102293:                                   nsCycleCollectionTraversalCallback &cb);
102293: };
102293: 
106109: static const CCParticipantVTable<nsXPConnectParticipant>::Type
106109: XPConnect_cycleCollectorGlobal =
106109: {
102293:   NS_IMPL_CYCLE_COLLECTION_NATIVE_VTABLE(nsXPConnectParticipant)
102293: };
102293: 
102070: nsCycleCollectionParticipant *
102070: nsXPConnect::GetParticipant()
101960: {
102293:     return XPConnect_cycleCollectorGlobal.GetParticipant();
101960: }
     1: 
 69648: JSBool
 69648: xpc_GCThingIsGrayCCThing(void *thing)
 69648: {
 71717:     return AddToCCKind(js_GetGCThingTraceKind(thing)) &&
 71717:            xpc_IsGrayGCThing(thing);
 69648: }
 69648: 
 91611: struct UnmarkGrayTracer : public JSTracer
 91611: {
 91611:     UnmarkGrayTracer() : mTracingShape(false), mPreviousShape(nsnull) {}
 91611:     UnmarkGrayTracer(JSTracer *trc, bool aTracingShape)
 91611:         : mTracingShape(aTracingShape), mPreviousShape(nsnull)
 91611:     {
 91611:         JS_TracerInit(this, trc->runtime, trc->callback);
 91611:     }
 91611:     bool mTracingShape; // true iff we are tracing the immediate children of a shape
 91611:     void *mPreviousShape; // If mTracingShape, shape child or NULL. Otherwise, NULL.
 91611: };
 91611: 
 71367: /*
 71367:  * The GC and CC are run independently. Consequently, the following sequence of
 71367:  * events can occur:
 71367:  * 1. GC runs and marks an object gray.
 71367:  * 2. Some JS code runs that creates a pointer from a JS root to the gray
 71367:  *    object. If we re-ran a GC at this point, the object would now be black.
 71367:  * 3. Now we run the CC. It may think it can collect the gray object, even
 71367:  *    though it's reachable from the JS heap.
 71367:  *
 71367:  * To prevent this badness, we unmark the gray bit of an object when it is
 71367:  * accessed by callers outside XPConnect. This would cause the object to go
 71367:  * black in step 2 above. This must be done on everything reachable from the
 71367:  * object being returned. The following code takes care of the recursive
 71367:  * re-coloring.
 71367:  */
 62690: static void
 90232: UnmarkGrayChildren(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 62690: {
 90232:     void *thing = *thingp;
 71367:     int stackDummy;
 91339:     if (!JS_CHECK_STACK_SIZE(js::GetNativeStackLimit(trc->runtime), &stackDummy)) {
 71367:         /*
 71367:          * If we run out of stack, we take a more drastic measure: require that
 71367:          * we GC again before the next CC.
 71367:          */
 71367:         nsXPConnect* xpc = nsXPConnect::GetXPConnect();
 71367:         xpc->EnsureGCBeforeCC();
 71367:         return;
 71367:     }
 71367: 
 91611:     if (!xpc_IsGrayGCThing(thing))
 62690:         return;
 62690: 
 80159:     static_cast<js::gc::Cell *>(thing)->unmark(js::gc::GRAY);
 62690: 
 91611:     /*
 91611:      * Trace children of |thing|. If |thing| and its parent are both shapes, |thing| will
 91611:      * get saved to mPreviousShape without being traced. The parent will later
 91611:      * trace |thing|. This is done to avoid increasing the stack depth during shape
 91611:      * tracing. It is safe to do because a shape can only have one child that is a shape.
 91611:      */
 91611:     UnmarkGrayTracer *tracer = static_cast<UnmarkGrayTracer*>(trc);
 91611:     UnmarkGrayTracer childTracer(tracer, kind == JSTRACE_SHAPE);
 91611: 
 91611:     if (kind != JSTRACE_SHAPE) {
 91611:         JS_TraceChildren(&childTracer, thing, kind);
 91611:         MOZ_ASSERT(!childTracer.mPreviousShape);
 91611:         return;
 91611:     }
 91611: 
 91611:     if (tracer->mTracingShape) {
 91611:         MOZ_ASSERT(!tracer->mPreviousShape);
 91611:         tracer->mPreviousShape = thing;
 91611:         return;
 91611:     }
 91611: 
 91611:     do {
 91611:         MOZ_ASSERT(!xpc_IsGrayGCThing(thing));
 91611:         JS_TraceChildren(&childTracer, thing, JSTRACE_SHAPE);
 91611:         thing = childTracer.mPreviousShape;
 91611:         childTracer.mPreviousShape = nsnull;
 91611:     } while (thing);
 62690: }
 62690: 
 62690: void
 97588: xpc_UnmarkGrayGCThingRecursive(void *thing, JSGCTraceKind kind)
 62690: {
 97588:     MOZ_ASSERT(thing, "Don't pass me null!");
 97588:     MOZ_ASSERT(kind != JSTRACE_SHAPE, "UnmarkGrayGCThingRecursive not intended for Shapes");
 62690: 
 62690:     // Unmark.
 97588:     static_cast<js::gc::Cell *>(thing)->unmark(js::gc::GRAY);
 62690: 
 62690:     // Trace children.
 91611:     UnmarkGrayTracer trc;
 97588:     JSRuntime *rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
 97588:     JS_TracerInit(&trc, rt, UnmarkGrayChildren);
 97588:     JS_TraceChildren(&trc, thing, kind);
 62690: }
 62690: 
  7286: struct TraversalTracer : public JSTracer
    33: {
  7286:     TraversalTracer(nsCycleCollectionTraversalCallback &aCb) : cb(aCb)
  7286:     {
  7286:     }
  7286:     nsCycleCollectionTraversalCallback &cb;
  1846: };
    33: 
 18907: static void
103074: NoteJSChild(JSTracer *trc, void *thing, JSGCTraceKind kind)
    33: {
 86955:     TraversalTracer *tracer = static_cast<TraversalTracer*>(trc);
 86955: 
 86955:     // Don't traverse non-gray objects, unless we want all traces.
 86955:     if (!xpc_IsGrayGCThing(thing) && !tracer->cb.WantAllTraces())
 86955:         return;
 86955: 
 84173:     /*
 84173:      * This function needs to be careful to avoid stack overflow. Normally, when
 84173:      * AddToCCKind is true, the recursion terminates immediately as we just add
 84173:      * |thing| to the CC graph. So overflow is only possible when there are long
 84173:      * chains of non-AddToCCKind GC things. Currently, this only can happen via
 84173:      * shape parent pointers. The special JSTRACE_SHAPE case below handles
 84173:      * parent pointers iteratively, rather than recursively, to avoid overflow.
 84173:      */
 80389:     if (AddToCCKind(kind)) {
 30096:         if (NS_UNLIKELY(tracer->cb.WantDebugInfo())) {
 13202:             // based on DumpNotify in jsapi.c
 13202:             if (tracer->debugPrinter) {
 13202:                 char buffer[200];
 13202:                 tracer->debugPrinter(trc, buffer, sizeof(buffer));
 13202:                 tracer->cb.NoteNextEdgeName(buffer);
 13202:             } else if (tracer->debugPrintIndex != (size_t)-1) {
 13202:                 char buffer[200];
 13202:                 JS_snprintf(buffer, sizeof(buffer), "%s[%lu]",
 13202:                             static_cast<const char *>(tracer->debugPrintArg),
 13202:                             tracer->debugPrintIndex);
 13202:                 tracer->cb.NoteNextEdgeName(buffer);
 13202:             } else {
 80387:                 tracer->cb.NoteNextEdgeName(static_cast<const char*>(tracer->debugPrintArg));
 13202:             }
 30096:         }
 97523:         tracer->cb.NoteJSChild(thing);
 84173:     } else if (kind == JSTRACE_SHAPE) {
 85055:         JS_TraceShapeCycleCollectorChildren(trc, thing);
 80390:     } else if (kind != JSTRACE_STRING) {
  8146:         JS_TraceChildren(trc, thing, kind);
  8146:     }
  1846: }
  1846: 
 88262: void
 88262: xpc_MarkInCCGeneration(nsISupports* aVariant, PRUint32 aGeneration)
 88262: {
 88262:     nsCOMPtr<XPCVariant> variant = do_QueryInterface(aVariant);
 88262:     if (variant) {
 88262:         variant->SetCCGeneration(aGeneration);
 88262:         variant->GetJSVal(); // Unmarks gray JSObject.
 88262:         XPCVariant* weak = variant.get();
 88262:         variant = nsnull;
 88262:         if (weak->IsPurple()) {
 88262:           weak->RemovePurple();
 88262:         }
 88262:     }
 88262: }
 88262: 
 88262: void
 94338: xpc_TryUnmarkWrappedGrayObject(nsISupports* aWrappedJS)
 88262: {
 94338:     nsCOMPtr<nsIXPConnectWrappedJS> wjs = do_QueryInterface(aWrappedJS);
 94338:     if (wjs) {
 88262:         // Unmarks gray JSObject.
 94338:         static_cast<nsXPCWrappedJS*>(wjs.get())->GetJSObject();
 88262:     }
 88262: }
 88262: 
102342: static bool
 24212: WrapperIsNotMainThreadOnly(XPCWrappedNative *wrapper)
 24212: {
 24212:     XPCWrappedNativeProto *proto = wrapper->GetProto();
 24212:     if (proto && proto->ClassIsMainThreadOnly())
 80486:         return false;
 24212: 
 24212:     // If the native participates in cycle collection then we know it can only
102342:     // be used on the main thread. In that case we assume the wrapped native
 24212:     // can only be used on the main thread too.
 24212:     nsXPCOMCycleCollectionParticipant* participant;
 24212:     return NS_FAILED(CallQueryInterface(wrapper->Native(), &participant));
 24212: }
 24212: 
102342: static inline void
102342: DescribeGCThing(bool isMarked, void *p, JSGCTraceKind traceKind,
102342:                 nsCycleCollectionTraversalCallback &cb)
     1: {
 30096:     if (cb.WantDebugInfo()) {
 11407:         char name[72];
 80389:         if (traceKind == JSTRACE_OBJECT) {
102342:             JSObject *obj = static_cast<JSObject*>(p);
102342:             js::Class *clasp = js::GetObjectClass(obj);
     1:             XPCNativeScriptableInfo *si = nsnull;
102342: 
102342:             if (IS_PROTO_CLASS(clasp)) {
     1:                 XPCWrappedNativeProto *p =
102342:                     static_cast<XPCWrappedNativeProto*>(xpc_GetJSPrivate(obj));
     1:                 si = p->GetScriptableInfo();
     1:             }
 80389:             if (si) {
  1846:                 JS_snprintf(name, sizeof(name), "JS Object (%s - %s)",
102342:                             clasp->name, si->GetJSClass()->name);
102342:             } else if (clasp == &js::FunctionClass) {
 84589:                 JSFunction *fun = JS_GetObjectFunction(obj);
 12529:                 JSString *str = JS_GetFunctionId(fun);
 80389:                 if (str) {
 59889:                     NS_ConvertUTF16toUTF8 fname(JS_GetInternedStringChars(str));
 30096:                     JS_snprintf(name, sizeof(name),
 30096:                                 "JS Object (Function - %s)", fname.get());
 80390:                 } else {
    33:                     JS_snprintf(name, sizeof(name), "JS Object (Function)");
    33:                 }
 80390:             } else {
 30096:                 JS_snprintf(name, sizeof(name), "JS Object (%s)",
102342:                             clasp->name);
    33:             }
 80390:         } else {
 77659:             static const char trace_types[][11] = {
 11407:                 "Object",
 11407:                 "String",
 77659:                 "Script",
 77659:                 "Xml",
 77659:                 "Shape",
 83221:                 "BaseShape",
 77659:                 "TypeObject",
 11407:             };
 80468:             JS_STATIC_ASSERT(NS_ARRAY_LENGTH(trace_types) == JSTRACE_LAST + 1);
 11407:             JS_snprintf(name, sizeof(name), "JS %s", trace_types[traceKind]);
 11407:         }
 11407: 
 84589:         // Disable printing global for objects while we figure out ObjShrink fallout.
 86105:         cb.DescribeGCedNode(isMarked, sizeof(js::shadow::Object), name);
 30096:     } else {
 86105:         cb.DescribeGCedNode(isMarked, sizeof(js::shadow::Object), "JS Object");
  1846:     }
102342: }
102342: 
103074: static void
103074: NoteJSChildTracerShim(JSTracer *trc, void **thingp, JSGCTraceKind kind)
103074: {
103074:     NoteJSChild(trc, *thingp, kind);
103074: }
103074: 
102342: static inline void
102342: NoteGCThingJSChildren(JSRuntime *rt, void *p, JSGCTraceKind traceKind,
102342:                       nsCycleCollectionTraversalCallback &cb)
102342: {
103073:     MOZ_ASSERT(rt);
  7286:     TraversalTracer trc(cb);
103074:     JS_TracerInit(&trc, rt, NoteJSChildTracerShim);
 82794:     trc.eagerlyTraceWeakMaps = false;
  8005:     JS_TraceChildren(&trc, p, traceKind);
102342: }
102342: 
102342: static inline void
102342: NoteGCThingXPCOMChildren(js::Class *clasp, JSObject *obj,
102342:                          nsCycleCollectionTraversalCallback &cb)
102342: {
102342:     MOZ_ASSERT(clasp);
102342:     MOZ_ASSERT(clasp == js::GetObjectClass(obj));
102342: 
102342:     if (clasp == &XPC_WN_Tearoff_JSClass) {
     1:         // A tearoff holds a strong reference to its native object
     1:         // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
     1:         // will be held alive through the parent of the JSObject of the tearoff.
     1:         XPCWrappedNativeTearOff *to =
102342:             static_cast<XPCWrappedNativeTearOff*>(xpc_GetJSPrivate(obj));
 18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)->mNative");
     1:         cb.NoteXPCOMChild(to->GetNative());
     1:     }
 55659:     // XXX This test does seem fragile, we should probably whitelist classes
 55659:     //     that do hold a strong reference, but that might not be possible.
102342:     else if (clasp->flags & JSCLASS_HAS_PRIVATE &&
102342:              clasp->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS) {
 18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)");
 10858:         cb.NoteXPCOMChild(static_cast<nsISupports*>(xpc_GetJSPrivate(obj)));
 94512:     } else if (binding::instanceIsProxy(obj)) {
 80071:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "js::GetProxyPrivate(obj)");
 80071:         nsISupports *identity =
 80071:             static_cast<nsISupports*>(js::GetProxyPrivate(obj).toPrivate());
 80071:         cb.NoteXPCOMChild(identity);
102342:     } else if (IsDOMClass(clasp) &&
102342:                DOMJSClass::FromJSClass(clasp)->mDOMObjectIsISupports) {
 94512:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "UnwrapDOMObject(obj)");
101296:         nsISupports *identity = UnwrapDOMObject<nsISupports>(obj);
 94512:         cb.NoteXPCOMChild(identity);
 80071:     }
102342: }
102342: 
103073: enum TraverseSelect {
103073:     TRAVERSE_CPP,
103073:     TRAVERSE_FULL
103073: };
103073: 
103073: static void
103073: TraverseGCThing(TraverseSelect ts, void *p, JSGCTraceKind traceKind,
102378:                 nsCycleCollectionTraversalCallback &cb)
102342: {
103073:     MOZ_ASSERT(traceKind == js_GetGCThingTraceKind(p));
102342:     JSObject *obj = nsnull;
102342:     js::Class *clasp = nsnull;
102342: 
102342:     // We do not want to add wrappers to the cycle collector if they're not
102342:     // explicitly marked as main thread only, because the cycle collector isn't
102342:     // able to deal with objects that might be used off of the main thread. We
102342:     // do want to explicitly mark them for cycle collection if the wrapper has
102342:     // an external reference, because the wrapper would mark the JS object if
102342:     // we did add the wrapper to the cycle collector.
102342:     bool dontTraverse = false;
102342:     bool markJSObject = false;
102342:     if (traceKind == JSTRACE_OBJECT) {
102342:         obj = static_cast<JSObject*>(p);
102342:         clasp = js::GetObjectClass(obj);
102342: 
102342:         if (clasp == &XPC_WN_Tearoff_JSClass) {
102342:             XPCWrappedNative *wrapper =
102342:                 static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(js::GetObjectParent(obj)));
102342:             dontTraverse = WrapperIsNotMainThreadOnly(wrapper);
102342:         } else if (IS_WRAPPER_CLASS(clasp) && IS_WN_WRAPPER_OBJECT(obj)) {
102342:             XPCWrappedNative *wrapper =
102342:                 static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(obj));
102342:             dontTraverse = WrapperIsNotMainThreadOnly(wrapper);
102342:             markJSObject = dontTraverse && wrapper->HasExternalReference();
102342:         }
102342:     }
102342: 
102342:     bool isMarked = markJSObject || !xpc_IsGrayGCThing(p);
102342: 
103073:     if (ts == TRAVERSE_FULL)
102342:         DescribeGCThing(isMarked, p, traceKind, cb);
102342: 
102342:     // If this object is alive, then all of its children are alive. For JS objects,
102342:     // the black-gray invariant ensures the children are also marked black. For C++
102342:     // objects, the ref count from this object will keep them alive. Thus we don't
102342:     // need to trace our children, unless we are debugging using WantAllTraces.
102342:     if (isMarked && !cb.WantAllTraces())
103073:         return;
103073: 
103073:     if (ts == TRAVERSE_FULL)
102378:         NoteGCThingJSChildren(nsXPConnect::GetRuntimeInstance()->GetJSRuntime(),
102378:                               p, traceKind, cb);
102342:  
102342:     if (traceKind != JSTRACE_OBJECT || dontTraverse)
103073:         return;
102342: 
102342:     NoteGCThingXPCOMChildren(clasp, obj, cb);
103073: }
103073: 
103073: NS_METHOD
103073: nsXPConnectParticipant::TraverseImpl(nsXPConnectParticipant *that, void *p,
103073:                                      nsCycleCollectionTraversalCallback &cb)
103073: {
103073:     TraverseGCThing(TRAVERSE_FULL, p, js_GetGCThingTraceKind(p), cb);
     1:     return NS_OK;
     1: }
     1: 
 53548: unsigned
 53548: nsXPConnect::GetOutstandingRequests(JSContext* cx)
  7286: {
 87282:     unsigned n = js::GetContextOutstandingRequests(cx);
 48507:     XPCCallContext* context = mCycleCollectionContext;
 53548:     // Ignore the contribution from the XPCCallContext we created for cycle
  7286:     // collection.
 80389:     if (context && cx == context->GetJSContext()) {
 90200:         MOZ_ASSERT(n);
 53548:         --n;
 53548:     }
 53548:     return n;
  7286: }
  7286: 
  7286: class JSContextParticipant : public nsCycleCollectionParticipant
  7286: {
  7286: public:
102293:     static NS_METHOD RootImpl(void *n)
  7286:     {
  7286:         return NS_OK;
  7286:     }
102293:     static NS_METHOD UnlinkImpl(void *n)
  7286:     {
 67680:         JSContext *cx = static_cast<JSContext*>(n);
 87283:         JSAutoRequest ar(cx);
 87283:         NS_ASSERTION(JS_GetGlobalObject(cx), "global object NULL before unlinking");
 87283:         JS_SetGlobalObject(cx, NULL);
  7286:         return NS_OK;
  7286:     }
102293:     static NS_METHOD UnrootImpl(void *n)
  7286:     {
  7286:         return NS_OK;
  7286:     }
102293:     static NS_METHOD TraverseImpl(JSContextParticipant *that, void *n,
102293:                                   nsCycleCollectionTraversalCallback &cb)
  7286:     {
  7286:         JSContext *cx = static_cast<JSContext*>(n);
  7286: 
 53548:         // Add outstandingRequests to the count, if there are outstanding
  7286:         // requests the context needs to be kept alive and adding unknown
  7286:         // edges will ensure that any cycles this context is in won't be
  7286:         // collected.
 53548:         unsigned refCount = nsXPConnect::GetXPConnect()->GetOutstandingRequests(cx) + 1;
 87298:         cb.DescribeRefCountedNode(refCount, js::SizeOfJSContext(), "JSContext");
 87968:         if (JSObject *global = JS_GetGlobalObject(cx)) {
 30096:             NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[global object]");
 97523:             cb.NoteJSChild(global);
 80748:         }
  7286: 
  7286:         return NS_OK;
  7286:     }
  7286: };
  7286: 
106109: static const CCParticipantVTable<JSContextParticipant>::Type
106109: JSContext_cycleCollectorGlobal =
106109: {
102293:   NS_IMPL_CYCLE_COLLECTION_NATIVE_VTABLE(JSContextParticipant)
102293: };
  7286: 
  7286: // static
  7286: nsCycleCollectionParticipant*
  7286: nsXPConnect::JSContextParticipant()
  7286: {
102293:     return JSContext_cycleCollectorGlobal.GetParticipant();
  7286: }
  7286: 
  7286: NS_IMETHODIMP_(void)
  7286: nsXPConnect::NoteJSContext(JSContext *aJSContext,
  7286:                            nsCycleCollectionTraversalCallback &aCb)
  7286: {
102293:     aCb.NoteNativeChild(aJSContext, JSContext_cycleCollectorGlobal.GetParticipant());
  7286: }
  7286: 
     1: 
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: // nsIXPConnect interface methods...
     1: 
     1: inline nsresult UnexpectedFailure(nsresult rv)
     1: {
     1:     NS_ERROR("This is not supposed to fail!");
     1:     return rv;
     1: }
     1: 
     1: /* void initClasses (in JSContextPtr aJSContext, in JSObjectPtr aGlobalJSObj); */
     1: NS_IMETHODIMP
     1: nsXPConnect::InitClasses(JSContext * aJSContext, JSObject * aGlobalJSObj)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aGlobalJSObj, "bad param");
     1: 
 37912:     // Nest frame chain save/restore in request created by XPCCallContext.
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 54733:     JSAutoEnterCompartment ac;
 54733:     if (!ac.enter(ccx, aGlobalJSObj))
 54733:         return UnexpectedFailure(NS_ERROR_FAILURE);
 52495: 
     1:     XPCWrappedNativeScope* scope =
     1:         XPCWrappedNativeScope::GetNewOrUsed(ccx, aGlobalJSObj);
     1: 
     1:     if (!scope)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     scope->RemoveWrappedNativeProtos();
     1: 
 97170:     if (!nsXPCComponents::AttachComponentsObject(ccx, scope, aGlobalJSObj))
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     if (!XPCNativeWrapper::AttachNewConstructorObject(ccx, aGlobalJSObj))
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     return NS_OK;
     1: }
     1: 
 56703: static bool
102756: CreateNewGlobal(JSContext *cx, JSClass *clasp, nsIPrincipal *principal,
 56703:                 xpc::CompartmentPrivate *priv, JSObject **global,
 55675:                 JSCompartment **compartment)
 48503: {
 56703:     // We take ownership of |priv|. Ensure that either we free it in the case
 56703:     // of failure or give ownership to the compartment in case of success (in
 56703:     // that case it will be free'd in CompartmentCallback during GC).
106124:     MOZ_ASSERT(priv);
 56703:     nsAutoPtr<xpc::CompartmentPrivate> priv_holder(priv);
 91900:     JSObject *tempGlobal =
102756:         JS_NewGlobalObject(cx, clasp, nsJSPrincipals::get(principal));
 48503: 
 48503:     if (!tempGlobal)
 56703:         return false;
 48503: 
 54427:     *global = tempGlobal;
 86105:     *compartment = js::GetObjectCompartment(tempGlobal);
 48503: 
 91250:     JS_SetCompartmentPrivate(*compartment, priv_holder.forget());
 56703:     return true;
 56703: }
 48503: 
 80070: #ifdef DEBUG
 80070: struct VerifyTraceXPCGlobalCalledTracer
 80070: {
 80070:     JSTracer base;
 80070:     bool ok;
 80070: };
 80070: 
 80070: static void
 90232: VerifyTraceXPCGlobalCalled(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 80070: {
 80070:     // We don't do anything here, we only want to verify that TraceXPCGlobal
 80070:     // was called.
 80070: }
 80070: #endif
 80070: 
 80070: void
 80070: TraceXPCGlobal(JSTracer *trc, JSObject *obj)
 80070: {
 80070: #ifdef DEBUG
 80389:     if (trc->callback == VerifyTraceXPCGlobalCalled) {
 80070:         // We don't do anything here, we only want to verify that TraceXPCGlobal
 80070:         // was called.
 82794:         reinterpret_cast<VerifyTraceXPCGlobalCalledTracer*>(trc)->ok = true;
 80070:         return;
 80070:     }
 80070: #endif
 80070: 
 91250:     if (XPCWrappedNativeScope *scope = XPCWrappedNativeScope::GetNativeScope(obj))
 80070:         scope->TraceDOMPrototypes(trc);
 97506: 
 97506:     mozilla::dom::TraceProtoOrIfaceCache(trc, obj);
 80070: }
 80070: 
 95543: #ifdef DEBUG
 95543: #include "mozilla/Preferences.h"
 95543: #include "nsIXULRuntime.h"
 95543: static void
 95543: CheckTypeInference(JSContext *cx, JSClass *clasp, nsIPrincipal *principal)
 95543: {
 95543:     // Check that the global class isn't whitelisted.
 95543:     if (strcmp(clasp->name, "Sandbox") ||
 95543:         strcmp(clasp->name, "nsXBLPrototypeScript compilation scope") ||
 95543:         strcmp(clasp->name, "nsXULPrototypeScript compilation scope"))
 95543:         return;
 95543: 
 95543:     // Check that the pref is on.
 95543:     if (!mozilla::Preferences::GetBool("javascript.options.typeinference"))
 95543:         return;
 95543: 
 95543:     // Check that we're not chrome.
 95543:     bool isSystem;
 95543:     nsIScriptSecurityManager* ssm;
 95543:     ssm = XPCWrapper::GetSecurityManager();
 95543:     if (NS_FAILED(ssm->IsSystemPrincipal(principal, &isSystem)) || !isSystem)
 95543:         return;
 95543: 
 95543:     // Check that safe mode isn't on.
 95543:     bool safeMode;
 95543:     nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
 95543:     if (!xr) {
 95543:         NS_WARNING("Couldn't get XUL runtime!");
 95543:         return;
 95543:     }
 95543:     if (NS_FAILED(xr->GetInSafeMode(&safeMode)) || safeMode)
 95543:         return;
 95543: 
 95543:     // Finally, do the damn assert.
 95543:     MOZ_ASSERT(JS_GetOptions(cx) & JSOPTION_TYPE_INFERENCE);
 95543: }
 95543: #else
 95543: #define CheckTypeInference(cx, clasp, principal) {}
 95543: #endif
 95543: 
 56703: nsresult
 56703: xpc_CreateGlobalObject(JSContext *cx, JSClass *clasp,
 56703:                        nsIPrincipal *principal, nsISupports *ptr,
 56703:                        bool wantXrays, JSObject **global,
 56703:                        JSCompartment **compartment)
 56703: {
 95298:     // Make sure that Type Inference is enabled for everything non-chrome.
 95298:     // Sandboxes and compilation scopes are exceptions. See bug 744034.
 95543:     CheckTypeInference(cx, clasp, principal);
 95298: 
 56703:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "using a principal off the main thread?");
 97462: 
 97462:     xpc::CompartmentPrivate *priv = new xpc::CompartmentPrivate(wantXrays);
102756:     if (!CreateNewGlobal(cx, clasp, principal, priv, global, compartment))
 56703:         return UnexpectedFailure(NS_ERROR_FAILURE);
 97462: 
 97462:     XPCCompartmentSet& set = nsXPConnect::GetRuntimeInstance()->GetCompartmentSet();
 97462:     if (!set.put(*compartment))
 48503:         return UnexpectedFailure(NS_ERROR_FAILURE);
 48503: 
 80070: #ifdef DEBUG
 91587:     // Verify that the right trace hook is called. Note that this doesn't
 91587:     // work right for wrapped globals, since the tracing situation there is
 91587:     // more complicated. Manual inspection shows that they do the right thing.
 91587:     if (clasp->flags & JSCLASS_XPCONNECT_GLOBAL &&
 91587:         !((js::Class*)clasp)->ext.isWrappedNative)
 91587:     {
 80070:         VerifyTraceXPCGlobalCalledTracer trc;
 91339:         JS_TracerInit(&trc.base, JS_GetRuntime(cx), VerifyTraceXPCGlobalCalled);
 82794:         trc.ok = false;
 80070:         JS_TraceChildren(&trc.base, *global, JSTRACE_OBJECT);
 80070:         NS_ABORT_IF_FALSE(trc.ok, "Trace hook needs to call TraceXPCGlobal if JSCLASS_XPCONNECT_GLOBAL is set.");
 80070:     }
 80070: #endif
 80070: 
 94512:     if (clasp->flags & JSCLASS_DOM_GLOBAL) {
 97422:         AllocateProtoOrIfaceCache(*global);
 94512:     }
 94512: 
 48503:     return NS_OK;
 48503: }
 48503: 
     1: NS_IMETHODIMP
     1: nsXPConnect::InitClassesWithNewWrappedGlobal(JSContext * aJSContext,
     1:                                              nsISupports *aCOMObj,
 48503:                                              nsIPrincipal * aPrincipal,
     1:                                              PRUint32 aFlags,
     1:                                              nsIXPConnectJSObjectHolder **_retval)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aCOMObj, "bad param");
     1:     NS_ASSERTION(_retval, "bad param");
 91577: 
 91577:     // We pass null for the 'extra' pointer during global object creation, so
 91577:     // we need to have a principal.
 91577:     MOZ_ASSERT(aPrincipal);
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1: 
 91589:     // Call into XPCWrappedNative to make a new global object, scope, and global
 91589:     // prototype.
 51515:     xpcObjectHelper helper(aCOMObj);
 91575:     MOZ_ASSERT(helper.GetScriptableFlags() & nsIXPCScriptable::IS_GLOBAL_OBJECT);
 91589:     nsRefPtr<XPCWrappedNative> wrappedGlobal;
 91589:     nsresult rv =
 91589:         XPCWrappedNative::WrapNewGlobal(ccx, helper, aPrincipal,
 91589:                                         aFlags & nsIXPConnect::INIT_JS_STANDARD_CLASSES,
 91589:                                         getter_AddRefs(wrappedGlobal));
 91589:     NS_ENSURE_SUCCESS(rv, rv);
 91589: 
 91589:     // Grab a copy of the global and enter its compartment.
 91589:     JSObject *global = wrappedGlobal->GetFlatJSObject();
 91589:     MOZ_ASSERT(!js::GetObjectParent(global));
 91589:     JSAutoEnterCompartment ac;
 91589:     if (!ac.enter(ccx, global))
 91589:         return NS_ERROR_UNEXPECTED;
 91589: 
 91589:     // Apply the system flag, if requested.
 91589:     bool system = (aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT) != 0;
 91589:     if (system && !JS_MakeSystemObject(aJSContext, global))
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 91589:     if (!(aFlags & nsIXPConnect::OMIT_COMPONENTS_OBJECT)) {
 91589:         // XPCCallContext gives us an active request needed to save/restore.
 97170:         if (!nsXPCComponents::AttachComponentsObject(ccx, wrappedGlobal->GetScope(), global))
     1:             return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 91589:         if (!XPCNativeWrapper::AttachNewConstructorObject(ccx, global))
 77353:             return UnexpectedFailure(NS_ERROR_FAILURE);
     1:     }
 91589: 
 94512:     // Stuff coming through this path always ends up as a DOM global.
 94512:     // XXX Someone who knows why we can assert this should re-check
 94512:     //     (after bug 720580).
 94512:     MOZ_ASSERT(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL);
 94512: 
 94512:     wrappedGlobal.forget(_retval);
     1:     return NS_OK;
     1: }
     1: 
 58714: nsresult
 58714: xpc_MorphSlimWrapper(JSContext *cx, nsISupports *tomorph)
 58714: {
 58714:     nsWrapperCache *cache;
 58714:     CallQueryInterface(tomorph, &cache);
 58714:     if (!cache)
 58714:         return NS_OK;
 58714: 
 58714:     JSObject *obj = cache->GetWrapper();
 58714:     if (!obj || !IS_SLIM_WRAPPER(obj))
 58714:         return NS_OK;
 58714:     return MorphSlimWrapper(cx, obj);
 58714: }
 58714: 
 31981: static nsresult
 31981: NativeInterface2JSObject(XPCLazyCallContext & lccx,
 31981:                          JSObject * aScope,
 31981:                          nsISupports *aCOMObj,
 48171:                          nsWrapperCache *aCache,
 31981:                          const nsIID * aIID,
 79445:                          bool aAllowWrapping,
 31981:                          jsval *aVal,
 31981:                          nsIXPConnectJSObjectHolder **aHolder)
 31981: {
 62405:     JSAutoEnterCompartment ac;
 62405:     if (!ac.enter(lccx.GetJSContext(), aScope))
 62405:         return NS_ERROR_OUT_OF_MEMORY;
 62405: 
 62405:     lccx.SetScopeForNewJSObjects(aScope);
 62405: 
 31981:     nsresult rv;
 51515:     xpcObjectHelper helper(aCOMObj, aCache);
 51515:     if (!XPCConvert::NativeInterface2JSObject(lccx, aVal, aHolder, helper, aIID,
 91578:                                               nsnull, aAllowWrapping, &rv))
 31981:         return rv;
 31981: 
 31981: #ifdef DEBUG
 55659:     NS_ASSERTION(aAllowWrapping ||
 55659:                  !xpc::WrapperFactory::IsXrayWrapper(JSVAL_TO_OBJECT(*aVal)),
 55659:                  "Shouldn't be returning a xray wrapper here");
 31981: #endif
 31981: 
 31981:     return NS_OK;
 31981: }
 31981: 
     1: /* nsIXPConnectJSObjectHolder wrapNative (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID); */
     1: NS_IMETHODIMP
     1: nsXPConnect::WrapNative(JSContext * aJSContext,
     1:                         JSObject * aScope,
     1:                         nsISupports *aCOMObj,
     1:                         const nsIID & aIID,
 22841:                         nsIXPConnectJSObjectHolder **aHolder)
 22841: {
 22841:     NS_ASSERTION(aHolder, "bad param");
 31981:     NS_ASSERTION(aJSContext, "bad param");
 31981:     NS_ASSERTION(aScope, "bad param");
 31981:     NS_ASSERTION(aCOMObj, "bad param");
 31981: 
 31981:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
 31981:     if (!ccx.IsValid())
 31981:         return UnexpectedFailure(NS_ERROR_FAILURE);
 31981:     XPCLazyCallContext lccx(ccx);
 22841: 
 22841:     jsval v;
 48171:     return NativeInterface2JSObject(lccx, aScope, aCOMObj, nsnull, &aIID,
 80486:                                     false, &v, aHolder);
 22841: }
 22841: 
 42675: /* void wrapNativeToJSVal (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDPtr aIID, out jsval aVal, out nsIXPConnectJSObjectHolder aHolder); */
 22841: NS_IMETHODIMP
 22841: nsXPConnect::WrapNativeToJSVal(JSContext * aJSContext,
 22841:                                JSObject * aScope,
 22841:                                nsISupports *aCOMObj,
 48171:                                nsWrapperCache *aCache,
 22842:                                const nsIID * aIID,
 79445:                                bool aAllowWrapping,
 22841:                                jsval *aVal,
 22841:                                nsIXPConnectJSObjectHolder **aHolder)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aScope, "bad param");
     1:     NS_ASSERTION(aCOMObj, "bad param");
     1: 
 22841:     if (aHolder)
 22841:         *aHolder = nsnull;
     1: 
 31981:     XPCLazyCallContext lccx(NATIVE_CALLER, aJSContext);
 31981: 
 48171:     return NativeInterface2JSObject(lccx, aScope, aCOMObj, aCache, aIID,
 48171:                                     aAllowWrapping, aVal, aHolder);
     1: }
     1: 
     1: /* void wrapJS (in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
     1: NS_IMETHODIMP
     1: nsXPConnect::WrapJS(JSContext * aJSContext,
     1:                     JSObject * aJSObj,
     1:                     const nsIID & aIID,
     1:                     void * *result)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aJSObj, "bad param");
     1:     NS_ASSERTION(result, "bad param");
     1: 
     1:     *result = nsnull;
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 55601:     JSAutoEnterCompartment aec;
 55601: 
 55601:     nsresult rv = NS_ERROR_UNEXPECTED;
 55601:     if (!aec.enter(ccx, aJSObj) ||
 55601:         !XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
  5491:                                               &aIID, nsnull, &rv))
     1:         return rv;
     1:     return NS_OK;
     1: }
     1: 
 37802: NS_IMETHODIMP
 37802: nsXPConnect::JSValToVariant(JSContext *cx,
 37802:                             jsval *aJSVal,
 37802:                             nsIVariant ** aResult)
 37802: {
 37802:     NS_PRECONDITION(aJSVal, "bad param");
 37802:     NS_PRECONDITION(aResult, "bad param");
 37802:     *aResult = nsnull;
 37802: 
 37802:     XPCCallContext ccx(NATIVE_CALLER, cx);
 37802:     if (!ccx.IsValid())
 37802:       return NS_ERROR_FAILURE;
 37802: 
 37802:     *aResult = XPCVariant::newVariant(ccx, *aJSVal);
 37802:     NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);
 37802: 
 37802:     return NS_OK;
 37802: }
 37802: 
     1: /* void wrapJSAggregatedToNative (in nsISupports aOuter, in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
     1: NS_IMETHODIMP
     1: nsXPConnect::WrapJSAggregatedToNative(nsISupports *aOuter,
     1:                                       JSContext * aJSContext,
     1:                                       JSObject * aJSObj,
     1:                                       const nsIID & aIID,
     1:                                       void * *result)
     1: {
     1:     NS_ASSERTION(aOuter, "bad param");
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aJSObj, "bad param");
     1:     NS_ASSERTION(result, "bad param");
     1: 
     1:     *result = nsnull;
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     nsresult rv;
     1:     if (!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
  5491:                                               &aIID, aOuter, &rv))
     1:         return rv;
     1:     return NS_OK;
     1: }
     1: 
     1: /* nsIXPConnectWrappedNative getWrappedNativeOfJSObject (in JSContextPtr aJSContext, in JSObjectPtr aJSObj); */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetWrappedNativeOfJSObject(JSContext * aJSContext,
     1:                                         JSObject * aJSObj,
     1:                                         nsIXPConnectWrappedNative **_retval)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aJSObj, "bad param");
     1:     NS_ASSERTION(_retval, "bad param");
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 30001:     SLIM_LOG_WILL_MORPH(aJSContext, aJSObj);
     1:     nsIXPConnectWrappedNative* wrapper =
 33785:         XPCWrappedNative::GetAndMorphWrappedNativeOfJSObject(aJSContext, aJSObj);
 80389:     if (wrapper) {
     1:         NS_ADDREF(wrapper);
     1:         *_retval = wrapper;
     1:         return NS_OK;
     1:     }
 30001: 
 30001:     // else...
 30001:     *_retval = nsnull;
 30001:     return NS_ERROR_FAILURE;
 30001: }
 30001: 
 30001: /* nsISupports getNativeOfWrapper(in JSContextPtr aJSContext, in JSObjectPtr  aJSObj); */
 30001: NS_IMETHODIMP_(nsISupports*)
 30001: nsXPConnect::GetNativeOfWrapper(JSContext * aJSContext,
 30001:                                 JSObject * aJSObj)
 30001: {
 30001:     NS_ASSERTION(aJSContext, "bad param");
 30001:     NS_ASSERTION(aJSObj, "bad param");
 30001: 
 30001:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
 80389:     if (!ccx.IsValid()) {
 30001:         UnexpectedFailure(NS_ERROR_FAILURE);
 30001:         return nsnull;
 30001:     }
 30001: 
 30001:     JSObject* obj2 = nsnull;
 30001:     nsIXPConnectWrappedNative* wrapper =
 30001:         XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aJSObj, nsnull,
 30001:                                                      &obj2);
 80088:     if (wrapper)
 80088:         return wrapper->Native();
 80088: 
 80088:     if (obj2)
 80088:         return (nsISupports*)xpc_GetJSPrivate(obj2);
 80088: 
 80092:     if (mozilla::dom::binding::instanceIsProxy(aJSObj)) {
 80088:         // FIXME: Provide a fast non-refcounting way to get the canonical
 80088:         //        nsISupports from the proxy.
 80088:         nsISupports *supports =
 80088:             static_cast<nsISupports*>(js::GetProxyPrivate(aJSObj).toPrivate());
 80088:         nsCOMPtr<nsISupports> canonical = do_QueryInterface(supports);
 80088:         return canonical.get();
 80088:     }
 80088: 
 80088:     return nsnull;
 30001: }
 30001: 
 30001: /* JSObjectPtr getJSObjectOfWrapper (in JSContextPtr aJSContext, in JSObjectPtr aJSObj); */
 30001: NS_IMETHODIMP
 30001: nsXPConnect::GetJSObjectOfWrapper(JSContext * aJSContext,
 30001:                                   JSObject * aJSObj,
 30001:                                   JSObject **_retval)
 30001: {
 30001:     NS_ASSERTION(aJSContext, "bad param");
 30001:     NS_ASSERTION(aJSObj, "bad param");
 30001:     NS_ASSERTION(_retval, "bad param");
 30001: 
 30001:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
 30001:     if (!ccx.IsValid())
 30001:         return UnexpectedFailure(NS_ERROR_FAILURE);
 30001: 
 30001:     JSObject* obj2 = nsnull;
 30001:     nsIXPConnectWrappedNative* wrapper =
 30001:         XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aJSObj, nsnull,
 30001:                                                      &obj2);
 80389:     if (wrapper) {
 30001:         wrapper->GetJSObject(_retval);
 30001:         return NS_OK;
 30001:     }
 80389:     if (obj2) {
 30001:         *_retval = obj2;
 30001:         return NS_OK;
 30001:     }
 80389:     if (mozilla::dom::binding::instanceIsProxy(aJSObj)) {
 80088:         *_retval = aJSObj;
 80088:         return NS_OK;
 80088:     }
     1:     // else...
     1:     *_retval = nsnull;
     1:     return NS_ERROR_FAILURE;
     1: }
     1: 
     1: /* nsIXPConnectWrappedNative getWrappedNativeOfNativeObject (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID); */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetWrappedNativeOfNativeObject(JSContext * aJSContext,
     1:                                             JSObject * aScope,
     1:                                             nsISupports *aCOMObj,
     1:                                             const nsIID & aIID,
     1:                                             nsIXPConnectWrappedNative **_retval)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aScope, "bad param");
     1:     NS_ASSERTION(aCOMObj, "bad param");
     1:     NS_ASSERTION(_retval, "bad param");
     1: 
     1:     *_retval = nsnull;
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCWrappedNativeScope* scope =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
     1:     if (!scope)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     AutoMarkingNativeInterfacePtr iface(ccx);
     1:     iface = XPCNativeInterface::GetNewOrUsed(ccx, &aIID);
     1:     if (!iface)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     XPCWrappedNative* wrapper;
     1: 
     1:     nsresult rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, scope, iface,
     1:                                                 &wrapper);
     1:     if (NS_FAILED(rv))
     1:         return NS_ERROR_FAILURE;
  3233:     *_retval = static_cast<nsIXPConnectWrappedNative*>(wrapper);
     1:     return NS_OK;
     1: }
     1: 
     1: /* nsIXPConnectJSObjectHolder reparentWrappedNativeIfFound (in JSContextPtr aJSContext, in JSObjectPtr aScope, in JSObjectPtr aNewParent, in nsISupports aCOMObj); */
     1: NS_IMETHODIMP
     1: nsXPConnect::ReparentWrappedNativeIfFound(JSContext * aJSContext,
     1:                                           JSObject * aScope,
     1:                                           JSObject * aNewParent,
     1:                                           nsISupports *aCOMObj,
     1:                                           nsIXPConnectJSObjectHolder **_retval)
     1: {
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCWrappedNativeScope* scope =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
     1:     if (!scope)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCWrappedNativeScope* scope2 =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aNewParent);
     1:     if (!scope2)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     return XPCWrappedNative::
     1:         ReparentWrapperIfFound(ccx, scope, scope2, aNewParent, aCOMObj,
     1:                                (XPCWrappedNative**) _retval);
     1: }
     1: 
 18907: static JSDHashOperator
     1: MoveableWrapperFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
 84755:                       uint32_t number, void *arg)
     1: {
 29161:     nsTArray<nsRefPtr<XPCWrappedNative> > *array =
 29161:         static_cast<nsTArray<nsRefPtr<XPCWrappedNative> > *>(arg);
 58714:     XPCWrappedNative *wn = ((Native2WrappedNativeMap::Entry*)hdr)->value;
 58714: 
 58714:     // If a wrapper is expired, then there are no references to it from JS, so
 58714:     // we don't have to move it.
 58714:     if (!wn->IsWrapperExpired())
 58714:         array->AppendElement(wn);
     1:     return JS_DHASH_NEXT;
     1: }
     1: 
 61142: static nsresult
 61142: MoveWrapper(XPCCallContext& ccx, XPCWrappedNative *wrapper,
 61142:             XPCWrappedNativeScope *newScope, XPCWrappedNativeScope *oldScope)
 61142: {
 61142:     // First, check to see if this wrapper really needs to be
 61142:     // reparented.
 61142: 
 80389:     if (wrapper->GetScope() == newScope) {
 61142:         // The wrapper already got moved, nothing to do here.
 61142:         return NS_OK;
 61142:     }
 61142: 
100253:     // For performance reasons, we wait to fix up orphaned wrappers (wrappers
100253:     // whose parents have moved to another scope) until right before they
100253:     // threaten to confuse us.
100253:     //
100253:     // If this wrapper is an orphan, reunite it with its parent. If, following
100253:     // that, the wrapper is no longer in the old scope, then we don't need to
100253:     // reparent it.
100253:     MOZ_ASSERT(wrapper->GetScope() == oldScope);
100253:     nsresult rv = wrapper->RescueOrphans(ccx);
100253:     NS_ENSURE_SUCCESS(rv, rv);
100253:     if (wrapper->GetScope() != oldScope)
100253:         return NS_OK;
100253: 
 61142:     nsISupports *identity = wrapper->GetIdentityObject();
 61142:     nsCOMPtr<nsIClassInfo> info(do_QueryInterface(identity));
 61142: 
 61142:     // ClassInfo is implemented as singleton objects. If the identity
 61142:     // object here is the same object as returned by the QI, then it
 61142:     // is the singleton classinfo, so we don't need to reparent it.
 61142:     if (SameCOMIdentity(identity, info))
 61142:         info = nsnull;
 61142: 
 61142:     if (!info)
 61142:         return NS_OK;
 61142: 
 61142:     XPCNativeScriptableCreateInfo sciProto;
 61142:     XPCNativeScriptableCreateInfo sci;
 61142:     const XPCNativeScriptableCreateInfo& sciWrapper =
 61142:         XPCWrappedNative::GatherScriptableCreateInfo(identity, info,
 61142:                                                      sciProto, sci);
 61142: 
 61142:     // If the wrapper doesn't want precreate, then we don't need to
 61142:     // worry about reparenting it.
 61142:     if (!sciWrapper.GetFlags().WantPreCreate())
 61142:         return NS_OK;
 61142: 
 61142:     JSObject *newParent = oldScope->GetGlobalJSObject();
100253:     rv = sciWrapper.GetCallback()->PreCreate(identity, ccx,
 61142:                                              newParent,
 61142:                                              &newParent);
 61142:     if (NS_FAILED(rv))
 61142:         return rv;
 61142: 
 80389:     if (newParent == oldScope->GetGlobalJSObject()) {
 61142:         // The old scope still works for this wrapper. We have to
 61142:         // assume that the wrapper will continue to return the old
 61142:         // scope from PreCreate, so don't move it.
 61142:         return NS_OK;
 61142:     }
 61142: 
 61142:     // The wrapper returned a new parent. If the new parent is in a
 61142:     // different scope, then we need to reparent it, otherwise, the
 61142:     // old scope is fine.
 61142: 
 61142:     XPCWrappedNativeScope *betterScope =
 61142:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, newParent);
 80389:     if (betterScope == oldScope) {
 61142:         // The wrapper asked for a different object, but that object
 61142:         // was in the same scope. This means that the new parent
 61142:         // simply hasn't been reparented yet, so reparent it first,
 61142:         // and then continue reparenting the wrapper itself.
 61142: 
 61142:         if (!IS_WN_WRAPPER_OBJECT(newParent)) {
 61142:             // The parent of wrapper is a slim wrapper, in this case
 61142:             // we need to morph the parent so that we can reparent it.
 61142: 
 61142:             rv = MorphSlimWrapper(ccx, newParent);
 61142:             NS_ENSURE_SUCCESS(rv, rv);
 61142:         }
 61142: 
 61142:         XPCWrappedNative *parentWrapper =
 61142:             XPCWrappedNative::GetWrappedNativeOfJSObject(ccx, newParent);
 61142: 
 61142:         rv = MoveWrapper(ccx, parentWrapper, newScope, oldScope);
 61142:         NS_ENSURE_SUCCESS(rv, rv);
 61142: 
 91315:         // If the parent wanted to stay in the old scope, we have to stay with
 91315:         // it. This can happen when doing document.write when the old detached
 91315:         // about:blank document is still floating around in the scope. Leave it
 91315:         // behind to die.
 91315:         if (parentWrapper->GetScope() == oldScope)
 91315:             return NS_OK;
 91315:         NS_ASSERTION(parentWrapper->GetScope() == newScope,
 91315:                      "A _third_ scope? Oh dear...");
 91315: 
 62690:         newParent = parentWrapper->GetFlatJSObject();
 80390:     } else
 61142:         NS_ASSERTION(betterScope == newScope, "Weird scope returned");
 61142: 
 61142:     // Now, reparent the wrapper, since we know that it wants to be
 61142:     // reparented.
 61142: 
 61142:     nsRefPtr<XPCWrappedNative> junk;
 61142:     rv = XPCWrappedNative::ReparentWrapperIfFound(ccx, oldScope,
 61142:                                                   newScope, newParent,
 61142:                                                   wrapper->GetIdentityObject(),
 61142:                                                   getter_AddRefs(junk));
 61142:     return rv;
 61142: }
 61142: 
 40041: /* void moveWrappers(in JSContextPtr aJSContext, in JSObjectPtr  aOldScope, in JSObjectPtr  aNewScope); */
     1: NS_IMETHODIMP
 40041: nsXPConnect::MoveWrappers(JSContext *aJSContext,
     1:                           JSObject *aOldScope,
     1:                           JSObject *aNewScope)
     1: {
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCWrappedNativeScope *oldScope =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aOldScope);
     1:     if (!oldScope)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCWrappedNativeScope *newScope =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aNewScope);
     1:     if (!newScope)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
  4187:     // First, look through the old scope and find all of the wrappers that
  4187:     // we're going to move.
 29161:     nsTArray<nsRefPtr<XPCWrappedNative> > wrappersToMove;
  4187: 
     1:     {   // scoped lock
 20312:         XPCAutoLock lock(GetRuntime()->GetMapLock());
     1:         Native2WrappedNativeMap *map = oldScope->GetWrappedNativeMap();
 26582:         wrappersToMove.SetCapacity(map->Count());
     1:         map->Enumerate(MoveableWrapperFinder, &wrappersToMove);
  4187:     }
     1: 
     1:     // Now that we have the wrappers, reparent them to the new scope.
 80389:     for (PRUint32 i = 0, stop = wrappersToMove.Length(); i < stop; ++i) {
 61142:         nsresult rv = MoveWrapper(ccx, wrappersToMove[i], newScope, oldScope);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: /* void setSecurityManagerForJSContext (in JSContextPtr aJSContext, in nsIXPCSecurityManager aManager, in PRUint16 flags); */
     1: NS_IMETHODIMP
     1: nsXPConnect::SetSecurityManagerForJSContext(JSContext * aJSContext,
     1:                                             nsIXPCSecurityManager *aManager,
     1:                                             PRUint16 flags)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCContext* xpcc = ccx.GetXPCContext();
     1: 
     1:     NS_IF_ADDREF(aManager);
     1:     nsIXPCSecurityManager* oldManager = xpcc->GetSecurityManager();
     1:     NS_IF_RELEASE(oldManager);
     1: 
     1:     xpcc->SetSecurityManager(aManager);
     1:     xpcc->SetSecurityManagerFlags(flags);
     1:     return NS_OK;
     1: }
     1: 
     1: /* void getSecurityManagerForJSContext (in JSContextPtr aJSContext, out nsIXPCSecurityManager aManager, out PRUint16 flags); */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetSecurityManagerForJSContext(JSContext * aJSContext,
     1:                                             nsIXPCSecurityManager **aManager,
     1:                                             PRUint16 *flags)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     NS_ASSERTION(aManager, "bad param");
     1:     NS_ASSERTION(flags, "bad param");
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCContext* xpcc = ccx.GetXPCContext();
     1: 
     1:     nsIXPCSecurityManager* manager = xpcc->GetSecurityManager();
     1:     NS_IF_ADDREF(manager);
     1:     *aManager = manager;
     1:     *flags = xpcc->GetSecurityManagerFlags();
     1:     return NS_OK;
     1: }
     1: 
     1: /* void setDefaultSecurityManager (in nsIXPCSecurityManager aManager, in PRUint16 flags); */
     1: NS_IMETHODIMP
     1: nsXPConnect::SetDefaultSecurityManager(nsIXPCSecurityManager *aManager,
     1:                                        PRUint16 flags)
     1: {
     1:     NS_IF_ADDREF(aManager);
     1:     NS_IF_RELEASE(mDefaultSecurityManager);
     1:     mDefaultSecurityManager = aManager;
     1:     mDefaultSecurityManagerFlags = flags;
  8870: 
  8870:     nsCOMPtr<nsIScriptSecurityManager> ssm =
  8870:         do_QueryInterface(mDefaultSecurityManager);
  8870: 
  8870:     // Remember the result of the above QI for fast access to the
  8870:     // script securityt manager.
  8870:     gScriptSecurityManager = ssm;
  8870: 
     1:     return NS_OK;
     1: }
     1: 
     1: /* void getDefaultSecurityManager (out nsIXPCSecurityManager aManager, out PRUint16 flags); */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetDefaultSecurityManager(nsIXPCSecurityManager **aManager,
     1:                                        PRUint16 *flags)
     1: {
     1:     NS_ASSERTION(aManager, "bad param");
     1:     NS_ASSERTION(flags, "bad param");
     1: 
     1:     NS_IF_ADDREF(mDefaultSecurityManager);
     1:     *aManager = mDefaultSecurityManager;
     1:     *flags = mDefaultSecurityManagerFlags;
     1:     return NS_OK;
     1: }
     1: 
     1: /* nsIStackFrame createStackFrameLocation (in PRUint32 aLanguage, in string aFilename, in string aFunctionName, in PRInt32 aLineNumber, in nsIStackFrame aCaller); */
     1: NS_IMETHODIMP
     1: nsXPConnect::CreateStackFrameLocation(PRUint32 aLanguage,
     1:                                       const char *aFilename,
     1:                                       const char *aFunctionName,
     1:                                       PRInt32 aLineNumber,
     1:                                       nsIStackFrame *aCaller,
     1:                                       nsIStackFrame **_retval)
     1: {
     1:     NS_ASSERTION(_retval, "bad param");
     1: 
     1:     return XPCJSStack::CreateStackFrameLocation(aLanguage,
     1:                                                 aFilename,
     1:                                                 aFunctionName,
     1:                                                 aLineNumber,
     1:                                                 aCaller,
     1:                                                 _retval);
     1: }
     1: 
     1: /* readonly attribute nsIStackFrame CurrentJSStack; */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetCurrentJSStack(nsIStackFrame * *aCurrentJSStack)
     1: {
     1:     NS_ASSERTION(aCurrentJSStack, "bad param");
     1:     *aCurrentJSStack = nsnull;
     1: 
     1:     JSContext* cx;
     1:     // is there a current context available?
 80389:     if (NS_SUCCEEDED(Peek(&cx)) && cx) {
     1:         nsCOMPtr<nsIStackFrame> stack;
     1:         XPCJSStack::CreateStack(cx, getter_AddRefs(stack));
 80389:         if (stack) {
     1:             // peel off native frames...
     1:             PRUint32 language;
     1:             nsCOMPtr<nsIStackFrame> caller;
     1:             while (stack &&
     1:                    NS_SUCCEEDED(stack->GetLanguage(&language)) &&
     1:                    language != nsIProgrammingLanguage::JAVASCRIPT &&
     1:                    NS_SUCCEEDED(stack->GetCaller(getter_AddRefs(caller))) &&
 80389:                    caller) {
     1:                 stack = caller;
     1:             }
     1:             NS_IF_ADDREF(*aCurrentJSStack = stack);
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsIXPCNativeCallContext CurrentNativeCallContext; */
     1: NS_IMETHODIMP
 10286: nsXPConnect::GetCurrentNativeCallContext(nsAXPCNativeCallContext * *aCurrentNativeCallContext)
     1: {
     1:     NS_ASSERTION(aCurrentNativeCallContext, "bad param");
     1: 
102556:     *aCurrentNativeCallContext = XPCJSRuntime::Get()->GetCallContext();
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXPConnect::SyncJSContexts(void)
     1: {
 20312:     // Do-nothing compatibility function
     1:     return NS_OK;
     1: }
     1: 
     1: /* nsIXPCFunctionThisTranslator setFunctionThisTranslator (in nsIIDRef aIID, in nsIXPCFunctionThisTranslator aTranslator); */
     1: NS_IMETHODIMP
     1: nsXPConnect::SetFunctionThisTranslator(const nsIID & aIID,
     1:                                        nsIXPCFunctionThisTranslator *aTranslator,
     1:                                        nsIXPCFunctionThisTranslator **_retval)
     1: {
 20312:     XPCJSRuntime* rt = GetRuntime();
     1:     nsIXPCFunctionThisTranslator* old;
     1:     IID2ThisTranslatorMap* map = rt->GetThisTranslatorMap();
     1: 
     1:     {
     1:         XPCAutoLock lock(rt->GetMapLock()); // scoped lock
 80389:         if (_retval) {
     1:             old = map->Find(aIID);
     1:             NS_IF_ADDREF(old);
     1:             *_retval = old;
     1:         }
     1:         map->Add(aIID, aTranslator);
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: /* nsIXPCFunctionThisTranslator getFunctionThisTranslator (in nsIIDRef aIID); */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetFunctionThisTranslator(const nsIID & aIID,
     1:                                        nsIXPCFunctionThisTranslator **_retval)
     1: {
 20312:     XPCJSRuntime* rt = GetRuntime();
     1:     nsIXPCFunctionThisTranslator* old;
     1:     IID2ThisTranslatorMap* map = rt->GetThisTranslatorMap();
     1: 
     1:     {
     1:         XPCAutoLock lock(rt->GetMapLock()); // scoped lock
     1:         old = map->Find(aIID);
     1:         NS_IF_ADDREF(old);
     1:         *_retval = old;
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: /* void clearAllWrappedNativeSecurityPolicies (); */
     1: NS_IMETHODIMP
     1: nsXPConnect::ClearAllWrappedNativeSecurityPolicies()
     1: {
     1:     XPCCallContext ccx(NATIVE_CALLER);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     return XPCWrappedNativeScope::ClearAllWrappedNativeSecurityPolicies(ccx);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXPConnect::CreateSandbox(JSContext *cx, nsIPrincipal *principal,
     1:                            nsIXPConnectJSObjectHolder **_retval)
     1: {
     1:     XPCCallContext ccx(NATIVE_CALLER, cx);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     *_retval = nsnull;
     1: 
     1:     jsval rval = JSVAL_VOID;
     1:     AUTO_MARK_JSVAL(ccx, &rval);
     1: 
101616:     SandboxOptions options;
101616:     nsresult rv = xpc_CreateSandboxObject(cx, &rval, principal, options);
     1:     NS_ASSERTION(NS_FAILED(rv) || !JSVAL_IS_PRIMITIVE(rval),
     1:                  "Bad return value from xpc_CreateSandboxObject()!");
     1: 
     1:     if (NS_SUCCEEDED(rv) && !JSVAL_IS_PRIMITIVE(rval)) {
  2072:         *_retval = XPCJSObjectHolder::newHolder(ccx, JSVAL_TO_OBJECT(rval));
     1:         NS_ENSURE_TRUE(*_retval, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:         NS_ADDREF(*_retval);
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXPConnect::EvalInSandboxObject(const nsAString& source, JSContext *cx,
     1:                                  nsIXPConnectJSObjectHolder *sandbox,
 79445:                                  bool returnStringOnly, jsval *rval)
     1: {
     1:     if (!sandbox)
     1:         return NS_ERROR_INVALID_ARG;
     1: 
     1:     JSObject *obj;
     1:     nsresult rv = sandbox->GetJSObject(&obj);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     return xpc_EvalInSandbox(cx, obj, source,
  3573:                              NS_ConvertUTF16toUTF8(source).get(), 1,
 24474:                              JSVERSION_DEFAULT, returnStringOnly, rval);
     1: }
     1: 
     1: /* nsIXPConnectJSObjectHolder getWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo); */
     1: NS_IMETHODIMP
     1: nsXPConnect::GetWrappedNativePrototype(JSContext * aJSContext,
     1:                                        JSObject * aScope,
     1:                                        nsIClassInfo *aClassInfo,
     1:                                        nsIXPConnectJSObjectHolder **_retval)
     1: {
     1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 55816:     JSAutoEnterCompartment ac;
 55816:     if (!ac.enter(aJSContext, aScope))
 55816:         return UnexpectedFailure(NS_ERROR_FAILURE);
 55816: 
     1:     XPCWrappedNativeScope* scope =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
     1:     if (!scope)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     XPCNativeScriptableCreateInfo sciProto;
 40489:     XPCWrappedNative::GatherProtoScriptableCreateInfo(aClassInfo, sciProto);
     1: 
     1:     AutoMarkingWrappedNativeProtoPtr proto(ccx);
 91578:     proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, scope, aClassInfo, &sciProto);
     1:     if (!proto)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     nsIXPConnectJSObjectHolder* holder;
     1:     *_retval = holder = XPCJSObjectHolder::newHolder(ccx,
     1:                                                      proto->GetJSProtoObject());
     1:     if (!holder)
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
     1:     NS_ADDREF(holder);
     1:     return NS_OK;
     1: }
     1: 
 79445: /* void releaseJSContext (in JSContextPtr aJSContext, in bool noGC); */
     1: NS_IMETHODIMP
 79445: nsXPConnect::ReleaseJSContext(JSContext * aJSContext, bool noGC)
     1: {
     1:     NS_ASSERTION(aJSContext, "bad param");
     1:     XPCCallContext* ccx = nsnull;
102556:     for (XPCCallContext* cur = GetRuntime()->GetCallContext();
     1:          cur;
 80389:          cur = cur->GetPrevCallContext()) {
 80389:         if (cur->GetJSContext() == aJSContext) {
     1:             ccx = cur;
     1:             // Keep looping to find the deepest matching call context.
     1:         }
     1:     }
     1: 
 80389:     if (ccx) {
     1: #ifdef DEBUG_xpc_hacker
 18543:         printf("!xpc - deferring destruction of JSContext @ %p\n",
 18543:                (void *)aJSContext);
     1: #endif
 82794:         ccx->SetDestroyJSContextInDestructor(true);
     1:         return NS_OK;
     1:     }
     1:     // else continue on and synchronously destroy the JSContext ...
     1: 
102554:     NS_ASSERTION(!XPCJSRuntime::Get()->GetJSContextStack()->
     1:                  DEBUG_StackHasJSContext(aJSContext),
     1:                  "JSContext still in threadjscontextstack!");
     1: 
     1:     if (noGC)
     1:         JS_DestroyContextNoGC(aJSContext);
     1:     else
     1:         JS_DestroyContext(aJSContext);
     1:     return NS_OK;
     1: }
     1: 
     1: /* void debugDump (in short depth); */
     1: NS_IMETHODIMP
     1: nsXPConnect::DebugDump(PRInt16 depth)
     1: {
     1: #ifdef DEBUG
     1:     depth-- ;
     1:     XPC_LOG_ALWAYS(("nsXPConnect @ %x with mRefCnt = %d", this, mRefCnt.get()));
     1:     XPC_LOG_INDENT();
     1:         XPC_LOG_ALWAYS(("gSelf @ %x", gSelf));
     1:         XPC_LOG_ALWAYS(("gOnceAliveNowDead is %d", (int)gOnceAliveNowDead));
     1:         XPC_LOG_ALWAYS(("mDefaultSecurityManager @ %x", mDefaultSecurityManager));
     1:         XPC_LOG_ALWAYS(("mDefaultSecurityManagerFlags of %x", mDefaultSecurityManagerFlags));
     1:         XPC_LOG_ALWAYS(("mInterfaceInfoManager @ %x", mInterfaceInfoManager.get()));
 80389:         if (mRuntime) {
     1:             if (depth)
     1:                 mRuntime->DebugDump(depth);
     1:             else
     1:                 XPC_LOG_ALWAYS(("XPCJSRuntime @ %x", mRuntime));
 80390:         } else
     1:             XPC_LOG_ALWAYS(("mRuntime is null"));
     1:         XPCWrappedNativeScope::DebugDumpAllScopes(depth);
     1:     XPC_LOG_OUTDENT();
     1: #endif
     1:     return NS_OK;
     1: }
     1: 
     1: /* void debugDumpObject (in nsISupports aCOMObj, in short depth); */
     1: NS_IMETHODIMP
     1: nsXPConnect::DebugDumpObject(nsISupports *p, PRInt16 depth)
     1: {
     1: #ifdef DEBUG
     1:     if (!depth)
     1:         return NS_OK;
 80389:     if (!p) {
     1:         XPC_LOG_ALWAYS(("*** Cound not dump object with NULL address"));
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsIXPConnect* xpc;
     1:     nsIXPCWrappedJSClass* wjsc;
     1:     nsIXPConnectWrappedNative* wn;
     1:     nsIXPConnectWrappedJS* wjs;
     1: 
     1:     if (NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnect),
 80389:                                        (void**)&xpc))) {
     1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnect..."));
     1:         xpc->DebugDump(depth);
     1:         NS_RELEASE(xpc);
 80390:     } else if (NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPCWrappedJSClass),
 80389:                                               (void**)&wjsc))) {
     1:         XPC_LOG_ALWAYS(("Dumping a nsIXPCWrappedJSClass..."));
     1:         wjsc->DebugDump(depth);
     1:         NS_RELEASE(wjsc);
 80390:     } else if (NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnectWrappedNative),
 80389:                                               (void**)&wn))) {
     1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnectWrappedNative..."));
     1:         wn->DebugDump(depth);
     1:         NS_RELEASE(wn);
 80390:     } else if (NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnectWrappedJS),
 80389:                                               (void**)&wjs))) {
     1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnectWrappedJS..."));
     1:         wjs->DebugDump(depth);
     1:         NS_RELEASE(wjs);
 80390:     } else
     1:         XPC_LOG_ALWAYS(("*** Could not dump the nsISupports @ %x", p));
     1: #endif
     1:     return NS_OK;
     1: }
     1: 
 79445: /* void debugDumpJSStack (in bool showArgs, in bool showLocals, in bool showThisProps); */
     1: NS_IMETHODIMP
 79445: nsXPConnect::DebugDumpJSStack(bool showArgs,
 79445:                               bool showLocals,
 79445:                               bool showThisProps)
     1: {
     1:     JSContext* cx;
 20462:     if (NS_FAILED(Peek(&cx)))
  5905:         printf("failed to peek into nsIThreadJSContextStack service!\n");
     1:     else if (!cx)
  5905:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
     1:     else
  5905:         xpc_DumpJSStack(cx, showArgs, showLocals, showThisProps);
 18403: 
     1:     return NS_OK;
     1: }
     1: 
 55472: char*
 79445: nsXPConnect::DebugPrintJSStack(bool showArgs,
 79445:                                bool showLocals,
 79445:                                bool showThisProps)
 55472: {
 55472:     JSContext* cx;
 55472:     if (NS_FAILED(Peek(&cx)))
 55472:         printf("failed to peek into nsIThreadJSContextStack service!\n");
 55472:     else if (!cx)
 55472:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
 55472:     else
 55472:         return xpc_PrintJSStack(cx, showArgs, showLocals, showThisProps);
 55472: 
 55472:     return nsnull;
 55472: }
 55472: 
     1: /* void debugDumpEvalInJSStackFrame (in PRUint32 aFrameNumber, in string aSourceText); */
     1: NS_IMETHODIMP
     1: nsXPConnect::DebugDumpEvalInJSStackFrame(PRUint32 aFrameNumber, const char *aSourceText)
     1: {
     1:     JSContext* cx;
 20462:     if (NS_FAILED(Peek(&cx)))
     1:         printf("failed to peek into nsIThreadJSContextStack service!\n");
     1:     else if (!cx)
     1:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
     1:     else
     1:         xpc_DumpEvalInJSStackFrame(cx, aFrameNumber, aSourceText);
 18403: 
     1:     return NS_OK;
     1: }
     1: 
 42675: /* jsval variantToJS (in JSContextPtr ctx, in JSObjectPtr scope, in nsIVariant value); */
     1: NS_IMETHODIMP
     1: nsXPConnect::VariantToJS(JSContext* ctx, JSObject* scope, nsIVariant* value, jsval* _retval)
     1: {
     1:     NS_PRECONDITION(ctx, "bad param");
     1:     NS_PRECONDITION(scope, "bad param");
     1:     NS_PRECONDITION(value, "bad param");
     1:     NS_PRECONDITION(_retval, "bad param");
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, ctx);
     1:     if (!ccx.IsValid())
     1:         return NS_ERROR_FAILURE;
 31395:     XPCLazyCallContext lccx(ccx);
     1: 
 62405:     ccx.SetScopeForNewJSObjects(scope);
 62405: 
     1:     nsresult rv = NS_OK;
 80389:     if (!XPCVariant::VariantDataToJS(lccx, value, &rv, _retval)) {
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
 42675: /* nsIVariant JSToVariant (in JSContextPtr ctx, in jsval value); */
     1: NS_IMETHODIMP
 48470: nsXPConnect::JSToVariant(JSContext* ctx, const jsval &value, nsIVariant** _retval)
     1: {
     1:     NS_PRECONDITION(ctx, "bad param");
 48470:     NS_PRECONDITION(value != JSVAL_NULL, "bad param");
     1:     NS_PRECONDITION(_retval, "bad param");
     1: 
     1:     XPCCallContext ccx(NATIVE_CALLER, ctx);
     1:     if (!ccx.IsValid())
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     *_retval = XPCVariant::newVariant(ccx, value);
     1:     if (!(*_retval))
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     return NS_OK;
     1: }
     1: 
  3310: NS_IMETHODIMP
 79445: nsXPConnect::OnProcessNextEvent(nsIThreadInternal *aThread, bool aMayWait,
  3310:                                 PRUint32 aRecursionDepth)
  3310: {
 87321:     // Record this event.
 87321:     mEventDepth++;
 87321: 
  3310:     // Push a null JSContext so that we don't see any script during
  3310:     // event processing.
 87321:     MOZ_ASSERT(NS_IsMainThread());
 20462:     return Push(nsnull);
  3310: }
  3310: 
  3310: NS_IMETHODIMP
  3310: nsXPConnect::AfterProcessNextEvent(nsIThreadInternal *aThread,
  3310:                                    PRUint32 aRecursionDepth)
  3310: {
 87321:     // Watch out for unpaired events during observer registration.
 87321:     if (NS_UNLIKELY(mEventDepth == 0))
 87321:         return NS_OK;
 87321:     mEventDepth--;
 87321: 
 57074:     // Call cycle collector occasionally.
 87321:     MOZ_ASSERT(NS_IsMainThread());
 62725:     nsJSContext::MaybePokeCC();
 94465:     nsDOMMutationObserver::HandleMutations();
 57074: 
 20462:     return Pop(nsnull);
  3310: }
  3310: 
  3310: NS_IMETHODIMP
  3310: nsXPConnect::OnDispatchedEvent(nsIThreadInternal* aThread)
  3310: {
  3310:     NS_NOTREACHED("Why tell us?");
  3310:     return NS_ERROR_UNEXPECTED;
  3310: }
  3310: 
  7230: NS_IMETHODIMP
  7230: nsXPConnect::AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer)
  7230: {
  7230:     return mRuntime->AddJSHolder(aHolder, aTracer);
  7230: }
  7230: 
  7230: NS_IMETHODIMP
  7230: nsXPConnect::RemoveJSHolder(void* aHolder)
  7230: {
  7230:     return mRuntime->RemoveJSHolder(aHolder);
  7230: }
  7230: 
 14170: NS_IMETHODIMP
103833: nsXPConnect::TestJSHolder(void* aHolder, bool* aRetval)
103833: {
103833: #ifdef DEBUG
103833:     return mRuntime->TestJSHolder(aHolder, aRetval);
103833: #else
103833:     MOZ_ASSERT(false);
103833:     return NS_ERROR_FAILURE;
103833: #endif
103833: }
103833: 
103833: NS_IMETHODIMP
 79445: nsXPConnect::SetReportAllJSExceptions(bool newval)
 14170: {
 14170:     // Ignore if the environment variable was set.
 14170:     if (gReportAllJSExceptions != 1)
 14170:         gReportAllJSExceptions = newval ? 2 : 0;
 14170: 
 14170:     return NS_OK;
 14170: }
 14170: 
 20312: /* attribute JSRuntime runtime; */
 20312: NS_IMETHODIMP
 20312: nsXPConnect::GetRuntime(JSRuntime **runtime)
 20312: {
 20312:     if (!runtime)
 20312:         return NS_ERROR_NULL_POINTER;
 20312: 
 81562:     JSRuntime *rt = GetRuntime()->GetJSRuntime();
 81562:     JS_AbortIfWrongThread(rt);
 81562:     *runtime = rt;
 20312:     return NS_OK;
 20312: }
 20312: 
 20312: /* attribute nsIXPCScriptable backstagePass; */
 20312: NS_IMETHODIMP
 20312: nsXPConnect::GetBackstagePass(nsIXPCScriptable **bsp)
 20312: {
 20312:     if (!mBackstagePass) {
 20312:         nsCOMPtr<nsIPrincipal> sysprin;
 20312:         nsCOMPtr<nsIScriptSecurityManager> secman =
 20312:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
 20312:         if (!secman)
 20312:             return NS_ERROR_NOT_AVAILABLE;
 20312:         if (NS_FAILED(secman->GetSystemPrincipal(getter_AddRefs(sysprin))))
 20312:             return NS_ERROR_NOT_AVAILABLE;
 20312: 
 20312:         mBackstagePass = new BackstagePass(sysprin);
 20312:         if (!mBackstagePass)
 20312:             return NS_ERROR_OUT_OF_MEMORY;
 20312:     }
 20312:     NS_ADDREF(*bsp = mBackstagePass);
 20312:     return NS_OK;
 20312: }
 20312: 
 36094: /* [noscript, notxpcom] void registerGCCallback(in JSGCCallback func); */
 36094: NS_IMETHODIMP_(void)
 36094: nsXPConnect::RegisterGCCallback(JSGCCallback func)
 36094: {
 36094:     mRuntime->AddGCCallback(func);
 36094: }
 36094: 
 36094: /* [noscript, notxpcom] void unregisterGCCallback(in JSGCCallback func); */
 36094: NS_IMETHODIMP_(void)
 36094: nsXPConnect::UnregisterGCCallback(JSGCCallback func)
 36094: {
 36094:     mRuntime->RemoveGCCallback(func);
 36094: }
 36094: 
 20462: //  nsIJSContextStack and nsIThreadJSContextStack implementations
 20462: 
 20462: /* readonly attribute PRInt32 Count; */
 20462: NS_IMETHODIMP
 20462: nsXPConnect::GetCount(PRInt32 *aCount)
 20462: {
 86979:     MOZ_ASSERT(aCount);
 20462: 
102554:     *aCount = XPCJSRuntime::Get()->GetJSContextStack()->Count();
 86979:     return NS_OK;
 20462: }
 20462: 
 20462: /* JSContext Peek (); */
 20462: NS_IMETHODIMP
 20462: nsXPConnect::Peek(JSContext * *_retval)
 20462: {
 86979:     MOZ_ASSERT(_retval);
 20462: 
102554:     *_retval = xpc_UnmarkGrayContext(XPCJSRuntime::Get()->GetJSContextStack()->Peek());
 86979:     return NS_OK;
 20462: }
 20462: 
 93515: #ifdef MOZ_JSDEBUGGER
 56783: void
 93515: nsXPConnect::CheckForDebugMode(JSRuntime *rt)
 93515: {
 62057:     JSContext *cx = NULL;
 62057: 
 62057:     if (gDebugMode == gDesiredDebugMode) {
 62057:         return;
 62057:     }
 62057: 
 62057:     // This can happen if a Worker is running, but we don't have the ability to
 62057:     // debug workers right now, so just return.
 56784:     if (!NS_IsMainThread()) {
 56784:         return;
 56784:     }
 56784: 
 56853:     JS_SetRuntimeDebugMode(rt, gDesiredDebugMode);
 56853: 
 56783:     nsresult rv;
 56783:     const char jsdServiceCtrID[] = "@mozilla.org/js/jsd/debugger-service;1";
 56783:     nsCOMPtr<jsdIDebuggerService> jsds = do_GetService(jsdServiceCtrID, &rv);
 62779:     if (NS_FAILED(rv)) {
 62057:         goto fail;
 62057:     }
 62057: 
 62057:     if (!(cx = JS_NewContext(rt, 256))) {
 62057:         goto fail;
 62057:     }
 62057: 
 62057:     {
 62779:         struct AutoDestroyContext {
 62779:             JSContext *cx;
 62779:             AutoDestroyContext(JSContext *cx) : cx(cx) {}
 62779:             ~AutoDestroyContext() { JS_DestroyContext(cx); }
 62779:         } adc(cx);
 62779:         JSAutoRequest ar(cx);
 62779: 
 98493:         if (!JS_SetDebugModeForAllCompartments(cx, gDesiredDebugMode))
 62057:             goto fail;
 62057:     }
 62057: 
 62057:     if (gDesiredDebugMode) {
 56783:         rv = jsds->ActivateDebugger(rt);
 56783:     }
 62057: 
 56783:     gDebugMode = gDesiredDebugMode;
 62057:     return;
 62057: 
 62057: fail:
 62057:     if (jsds)
 62057:         jsds->DeactivateDebugger();
 62057: 
 62779:     /*
 62779:      * If an attempt to turn debug mode on fails, cancel the request. It's
 62779:      * always safe to turn debug mode off, since DeactivateDebugger prevents
 62779:      * debugger callbacks from having any effect.
 62779:      */
 62779:     if (gDesiredDebugMode)
 82794:         JS_SetRuntimeDebugMode(rt, false);
 82794:     gDesiredDebugMode = gDebugMode = false;
 56783: }
 93515: #else //MOZ_JSDEBUGGER not defined
 93515: void
 93515: nsXPConnect::CheckForDebugMode(JSRuntime *rt)
 93515: {
 93515:     gDesiredDebugMode = gDebugMode = false;
 93515: }
 93515: #endif //#ifdef MOZ_JSDEBUGGER
 93515: 
 56783: 
 82537: NS_EXPORT_(void)
 82537: xpc_ActivateDebugMode()
 82537: {
 82537:     XPCJSRuntime* rt = nsXPConnect::GetRuntimeInstance();
 82537:     nsXPConnect::GetXPConnect()->SetDebugModeWhenPossible(true, true);
 82537:     nsXPConnect::CheckForDebugMode(rt->GetJSRuntime());
 82537: }
 82537: 
 20462: /* JSContext Pop (); */
 20462: NS_IMETHODIMP
 20462: nsXPConnect::Pop(JSContext * *_retval)
 20462: {
102554:     JSContext *cx = XPCJSRuntime::Get()->GetJSContextStack()->Pop();
 86979:     if (_retval)
 97592:         *_retval = xpc_UnmarkGrayContext(cx);
 86979:     return NS_OK;
 20462: }
 20462: 
 20462: /* void Push (in JSContext cx); */
 20462: NS_IMETHODIMP
 20462: nsXPConnect::Push(JSContext * cx)
 20462: {
 62069:      if (gDebugMode != gDesiredDebugMode && NS_IsMainThread()) {
102554:          const InfallibleTArray<XPCJSContextInfo>* stack =
102554:              XPCJSRuntime::Get()->GetJSContextStack()->GetStack();
 62779:          if (!gDesiredDebugMode) {
 62779:              /* Turn off debug mode immediately, even if JS code is currently running */
 62779:              CheckForDebugMode(mRuntime->GetJSRuntime());
 62779:          } else {
 62069:              bool runningJS = false;
 62069:              for (PRUint32 i = 0; i < stack->Length(); ++i) {
 62069:                  JSContext *cx = (*stack)[i].cx;
 87291:                  if (cx && js::IsContextRunningJS(cx)) {
 62069:                      runningJS = true;
 62069:                      break;
 62069:                  }
 62069:              }
 62779:              if (!runningJS)
 56783:                  CheckForDebugMode(mRuntime->GetJSRuntime());
 62069:          }
 62779:      }
 56783: 
102554:      return XPCJSRuntime::Get()->GetJSContextStack()->Push(cx) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 20462: }
 20462: 
 97744: /* virtual */
 97744: JSContext*
 97744: nsXPConnect::GetSafeJSContext()
 20462: {
102554:     return XPCJSRuntime::Get()->GetJSContextStack()->GetSafeJSContext();
 20462: }
 20462: 
 30001: nsIPrincipal*
 79445: nsXPConnect::GetPrincipal(JSObject* obj, bool allowShortCircuit) const
 30001: {
 83227:     NS_ASSERTION(IS_WRAPPER_CLASS(js::GetObjectClass(obj)),
 30001:                  "What kind of wrapper is this?");
 30001: 
 80389:     if (IS_WN_WRAPPER_OBJECT(obj)) {
 30001:         XPCWrappedNative *xpcWrapper =
 30001:             (XPCWrappedNative *)xpc_GetJSPrivate(obj);
 30001:         if (xpcWrapper) {
 30001:             if (allowShortCircuit) {
 30001:                 nsIPrincipal *result = xpcWrapper->GetObjectPrincipal();
 30001:                 if (result) {
 30001:                     return result;
 30001:                 }
 30001:             }
 30001: 
 30001:             // If not, check if it points to an nsIScriptObjectPrincipal
 30001:             nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
 30001:                 do_QueryInterface(xpcWrapper->Native());
 30001:             if (objPrin) {
 30001:                 nsIPrincipal *result = objPrin->GetPrincipal();
 30001:                 if (result) {
 30001:                     return result;
 30001:                 }
 30001:             }
 30001:         }
 80390:     } else {
 30001:         if (allowShortCircuit) {
 30001:             nsIPrincipal *result =
 30001:                 GetSlimWrapperProto(obj)->GetScope()->GetPrincipal();
 30001:             if (result) {
 30001:                 return result;
 30001:             }
 30001:         }
 30001: 
 30001:         nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
 30001:             do_QueryInterface((nsISupports*)xpc_GetJSPrivate(obj));
 30001:         if (objPrin) {
 30001:             nsIPrincipal *result = objPrin->GetPrincipal();
 30001:             if (result) {
 30001:                 return result;
 30001:             }
 30001:         }
 30001:     }
 30001: 
 30001:     return nsnull;
 30001: }
 30001: 
 51082: NS_IMETHODIMP
 51082: nsXPConnect::HoldObject(JSContext *aJSContext, JSObject *aObject,
 51082:                         nsIXPConnectJSObjectHolder **aHolder)
 51082: {
 51082:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
 51082:     XPCJSObjectHolder* objHolder = XPCJSObjectHolder::newHolder(ccx, aObject);
 51082:     if (!objHolder)
 51082:         return NS_ERROR_OUT_OF_MEMORY;
 51082: 
 51082:     NS_ADDREF(*aHolder = objHolder);
 51082:     return NS_OK;
 51082: }
 51082: 
 53556: NS_IMETHODIMP_(void)
 53556: nsXPConnect::GetCaller(JSContext **aJSContext, JSObject **aObj)
 53556: {
102556:     XPCCallContext *ccx = XPCJSRuntime::Get()->GetCallContext();
 53556:     *aJSContext = ccx->GetJSContext();
 53556: 
 53556:     // Set to the caller in XPC_WN_Helper_{Call,Construct}
 53556:     *aObj = ccx->GetFlattenedJSObject();
 53556: }
 53556: 
 86226: namespace xpc {
 86226: 
 86226: bool
102130: DeferredRelease(nsISupports *obj)
102130: {
102130:     return nsXPConnect::GetRuntimeInstance()->DeferredRelease(obj);
102130: }
102130: 
102130: bool
 86226: Base64Encode(JSContext *cx, JS::Value val, JS::Value *out)
 57556: {
 86226:     MOZ_ASSERT(cx);
 86226:     MOZ_ASSERT(out);
 86226: 
 86226:     JS::Value root = val;
 59217:     xpc_qsACString encodedString(cx, root, &root, xpc_qsACString::eNull,
 59217:                                  xpc_qsACString::eStringify);
 59217:     if (!encodedString.IsValid())
 82794:         return false;
 59217: 
 59217:     nsCAutoString result;
 86226:     if (NS_FAILED(mozilla::Base64Encode(encodedString, result))) {
 59217:         JS_ReportError(cx, "Failed to encode base64 data!");
 82794:         return false;
 59217:     }
 59217: 
 59217:     JSString *str = JS_NewStringCopyN(cx, result.get(), result.Length());
 59217:     if (!str)
 82794:         return false;
 59217: 
 59217:     *out = STRING_TO_JSVAL(str);
 82794:     return true;
 59217: }
 59217: 
 86226: bool
 86226: Base64Decode(JSContext *cx, JS::Value val, JS::Value *out)
 57556: {
 86226:     MOZ_ASSERT(cx);
 86226:     MOZ_ASSERT(out);
 86226: 
 86226:     JS::Value root = val;
 59217:     xpc_qsACString encodedString(cx, root, &root, xpc_qsACString::eNull,
 59217:                                  xpc_qsACString::eNull);
 59217:     if (!encodedString.IsValid())
 82794:         return false;
 59217: 
 59217:     nsCAutoString result;
 86226:     if (NS_FAILED(mozilla::Base64Decode(encodedString, result))) {
 59217:         JS_ReportError(cx, "Failed to decode base64 string!");
 82794:         return false;
 59217:     }
 59217: 
 59217:     JSString *str = JS_NewStringCopyN(cx, result.get(), result.Length());
 59217:     if (!str)
 82794:         return false;
 59217: 
 59217:     *out = STRING_TO_JSVAL(str);
 82794:     return true;
 59217: }
 59217: 
 89654: void
 89654: DumpJSHeap(FILE* file)
 89654: {
 89654:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "Must dump GC heap on main thread.");
 89654:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
 91339:     if (!xpc) {
 91339:         NS_ERROR("Failed to get nsXPConnect instance!");
 89654:         return;
 89654:     }
 91339:     js::DumpHeapComplete(xpc->GetRuntime()->GetJSRuntime(), file);
 89654: }
 89654: 
 99154: void
 99154: SetLocationForGlobal(JSObject *global, const nsACString& location)
 99154: {
 99154:     MOZ_ASSERT(global);
 99154: 
 99328:     CompartmentPrivate *priv = GetCompartmentPrivate(global);
 99154:     MOZ_ASSERT(priv, "No compartment private");
 99154: 
 99154:     priv->SetLocation(location);
 99154: }
 99154: 
 99154: void
 99154: SetLocationForGlobal(JSObject *global, nsIURI *locationURI)
 99154: {
 99154:     MOZ_ASSERT(global);
 99154: 
 99328:     CompartmentPrivate *priv = GetCompartmentPrivate(global);
 99154:     MOZ_ASSERT(priv, "No compartment private");
 99154: 
 99154:     priv->SetLocation(locationURI);
 99154: }
 99154: 
 86226: } // namespace xpc
 86226: 
103075: static void
103075: NoteJSChildGrayWrapperShim(void *data, void *thing)
103075: {
103075:     TraversalTracer *trc = static_cast<TraversalTracer*>(data);
103075:     NoteJSChild(trc, thing, js_GetGCThingTraceKind(thing));
103075: }
103075: 
103075: static void
103075: TraverseObjectShim(void *data, void *thing)
103075: {
103075:     nsCycleCollectionTraversalCallback *cb =
103075:         static_cast<nsCycleCollectionTraversalCallback*>(data);
103075: 
103075:     MOZ_ASSERT(js_GetGCThingTraceKind(thing) == JSTRACE_OBJECT);
103075:     TraverseGCThing(TRAVERSE_CPP, thing, JSTRACE_OBJECT, *cb);
103075: }
103075: 
103075: /*
103075:  * The cycle collection participant for a JSCompartment is intended to produce the same
103075:  * results as if all of the gray GCthings in a compartment were merged into a single node,
103075:  * except for self-edges. This avoids the overhead of representing all of the GCthings in
103075:  * the compartment in the cycle collector graph, which should be much faster if many of
103075:  * the GCthings in the compartment are gray.
103075:  *
103075:  * Compartment merging should not always be used, because it is a conservative
103075:  * approximation of the true cycle collector graph that can incorrectly identify some
103075:  * garbage objects as being live. For instance, consider two cycles that pass through a
103075:  * compartment, where one is garbage and the other is live. If we merge the entire
103075:  * compartment, the cycle collector will think that both are alive.
103075:  *
103075:  * We don't have to worry about losing track of a garbage cycle, because any such garbage
103075:  * cycle incorrectly identified as live must contain at least one C++ to JS edge, and
103075:  * XPConnect will always add the C++ object to the CC graph. (This is in contrast to pure
103075:  * C++ garbage cycles, which must always be properly identified, because we clear the
103075:  * purple buffer during every CC, which may contain the last reference to a garbage
103075:  * cycle.)
103075:  */
103075: class JSCompartmentParticipant : public nsCycleCollectionParticipant
103075: {
103075: public:
103075:     static NS_METHOD TraverseImpl(JSCompartmentParticipant *that, void *p,
103075:                                   nsCycleCollectionTraversalCallback &cb)
103075:     {
103075:         MOZ_ASSERT(!cb.WantAllTraces());
103075:         JSCompartment *c = static_cast<JSCompartment*>(p);
103075: 
103075:         /*
103075:          * We treat the compartment as being gray. We handle non-gray GCthings in the
103075:          * compartment by not reporting their children to the CC. The black-gray invariant
103075:          * ensures that any JS children will also be non-gray, and thus don't need to be
103075:          * added to the graph. For C++ children, not representing the edge from the
103075:          * non-gray JS GCthings to the C++ object will keep the child alive.
103075:          *
103075:          * We don't allow compartment merging in a WantAllTraces CC, because then these
103075:          * assumptions don't hold.
103075:          */
103075:         cb.DescribeGCedNode(false, sizeof(js::shadow::Object), "JS Compartment");
103075: 
103075:         /*
103075:          * Every JS child of everything in the compartment is either in the compartment
103075:          * or is a cross-compartment wrapper. In the former case, we don't need to
103075:          * represent these edges in the CC graph because JS objects are not ref counted.
103075:          * In the latter case, the JS engine keeps a map of these wrappers, which we
103075:          * iterate over.
103075:          */
103075:         TraversalTracer trc(cb);
103075:         JSRuntime *rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
103075:         JS_TracerInit(&trc, rt, NoteJSChildTracerShim);
103075:         trc.eagerlyTraceWeakMaps = false;
103075:         js::VisitGrayWrapperTargets(c, NoteJSChildGrayWrapperShim, &trc);
103075: 
103075:         /*
103075:          * To find C++ children of things in the compartment, we scan every JS Object in
103075:          * the compartment. Only JS Objects can have C++ children.
103075:          */
103075:         js::IterateGrayObjects(c, TraverseObjectShim, &cb);
103075: 
103075:         return NS_OK;
103075:     }
103075: 
103075:     static NS_METHOD RootImpl(void *p)
103075:     {
103075:         return NS_OK;
103075:     }
103075:     
103075:     static NS_METHOD UnlinkImpl(void *p)
103075:     {
103075:         return NS_OK;
103075:     }
103075: 
103075:     static NS_METHOD UnrootImpl(void *p)
103075:     {
103075:         return NS_OK;
103075:     }
103075: };
103075: 
103075: static CCParticipantVTable<JSCompartmentParticipant>::Type JSCompartment_cycleCollectorGlobal = {
103075:     NS_IMPL_CYCLE_COLLECTION_NATIVE_VTABLE(JSCompartmentParticipant)
103075: };
103075: 
103075: nsCycleCollectionParticipant *
103075: xpc_JSCompartmentParticipant()
103075: {
103075:     return JSCompartment_cycleCollectorGlobal.GetParticipant();
103075: }
103075: 
 56783: NS_IMETHODIMP
 82093: nsXPConnect::SetDebugModeWhenPossible(bool mode, bool allowSyncDisable)
 56783: {
 56783:     gDesiredDebugMode = mode;
 82093:     if (!mode && allowSyncDisable)
 62070:         CheckForDebugMode(mRuntime->GetJSRuntime());
 56783:     return NS_OK;
 56783: }
 56783: 
 74914: NS_IMETHODIMP
 74914: nsXPConnect::GetTelemetryValue(JSContext *cx, jsval *rval)
 74914: {
 74914:     JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
 74914:     if (!obj)
 74914:         return NS_ERROR_OUT_OF_MEMORY;
 74914: 
 91237:     unsigned attrs = JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT;
 74914: 
 74914:     size_t i = JS_GetE4XObjectsCreated(cx);
 74914:     jsval v = DOUBLE_TO_JSVAL(i);
 74914:     if (!JS_DefineProperty(cx, obj, "e4x", v, NULL, NULL, attrs))
 74914:         return NS_ERROR_OUT_OF_MEMORY;
 74914: 
 74914:     i = JS_SetProtoCalled(cx);
 74914:     v = DOUBLE_TO_JSVAL(i);
 74914:     if (!JS_DefineProperty(cx, obj, "setProto", v, NULL, NULL, attrs))
 74914:         return NS_ERROR_OUT_OF_MEMORY;
 74914: 
 74914:     i = JS_GetCustomIteratorCount(cx);
 74914:     v = DOUBLE_TO_JSVAL(i);
 74914:     if (!JS_DefineProperty(cx, obj, "customIter", v, NULL, NULL, attrs))
 74914:         return NS_ERROR_OUT_OF_MEMORY;
 74914: 
 74914:     *rval = OBJECT_TO_JSVAL(obj);
 74914:     return NS_OK;
 74914: }
 74914: 
 90410: NS_IMETHODIMP
 90410: nsXPConnect::NotifyDidPaint()
 90410: {
 94960:     js::NotifyDidPaint(GetRuntime()->GetJSRuntime());
 90410:     return NS_OK;
 90410: }
 90410: 
 93548: const PRUint8 HAS_PRINCIPALS_FLAG               = 1;
 93548: const PRUint8 HAS_ORIGIN_PRINCIPALS_FLAG        = 2;
 93548: 
 93548: static nsresult
 93548: WriteScriptOrFunction(nsIObjectOutputStream *stream, JSContext *cx,
 93548:                       JSScript *script, JSObject *functionObj)
 93548: {
 93548:     // Exactly one of script or functionObj must be given
 93548:     MOZ_ASSERT(!script != !functionObj);
 93548: 
 93548:     if (!script)
 93548:         script = JS_GetFunctionScript(cx, JS_GetObjectFunction(functionObj));
 93548: 
 93548:     nsIPrincipal *principal =
 93548:         nsJSPrincipals::get(JS_GetScriptPrincipals(script));
 93548:     nsIPrincipal *originPrincipal =
 93548:         nsJSPrincipals::get(JS_GetScriptOriginPrincipals(script));
 93548: 
 93548:     PRUint8 flags = 0;
 93548:     if (principal)
 93548:         flags |= HAS_PRINCIPALS_FLAG;
 93548: 
 93548:     // Optimize for the common case when originPrincipals == principals. As
 93548:     // originPrincipals is set to principals when the former is null we can
 93548:     // simply skip the originPrincipals when they are the same as principals.
 93548:     if (originPrincipal && originPrincipal != principal)
 93548:         flags |= HAS_ORIGIN_PRINCIPALS_FLAG;
 93548: 
 93548:     nsresult rv = stream->Write8(flags);
 93548:     if (NS_FAILED(rv))
 93548:         return rv;
 93548: 
 93548:     if (flags & HAS_PRINCIPALS_FLAG) {
 93548:         rv = stream->WriteObject(principal, true);
 93548:         if (NS_FAILED(rv))
 93548:             return rv;
 93548:     }
 93548: 
 93548:     if (flags & HAS_ORIGIN_PRINCIPALS_FLAG) {
 93548:         rv = stream->WriteObject(originPrincipal, true);
 93548:         if (NS_FAILED(rv))
 93548:             return rv;
 93548:     }
 93548: 
 94006:     uint32_t size;
 94006:     void* data;
 93548:     {
 93548:         JSAutoRequest ar(cx);
 93548:         if (functionObj)
 94006:             data = JS_EncodeInterpretedFunction(cx, functionObj, &size);
 93548:         else
 94006:             data = JS_EncodeScript(cx, script, &size);
 93548:     }
 93548: 
 94006:     if (!data)
 94006:         return NS_ERROR_OUT_OF_MEMORY;
 94006:     MOZ_ASSERT(size);
 93548:     rv = stream->Write32(size);
 93548:     if (NS_SUCCEEDED(rv))
 94006:         rv = stream->WriteBytes(static_cast<char *>(data), size);
 94006:     js_free(data);
 93548: 
 93548:     return rv;
 93548: }
 93548: 
 93548: static nsresult
 93548: ReadScriptOrFunction(nsIObjectInputStream *stream, JSContext *cx,
 93548:                      JSScript **scriptp, JSObject **functionObjp)
 93548: {
 93548:     // Exactly one of script or functionObj must be given
 93548:     MOZ_ASSERT(!scriptp != !functionObjp);
 93548: 
 93548:     PRUint8 flags;
 93548:     nsresult rv = stream->Read8(&flags);
 93548:     if (NS_FAILED(rv))
 93548:         return rv;
 93548: 
 93548:     nsJSPrincipals* principal = nsnull;
 93548:     nsCOMPtr<nsIPrincipal> readPrincipal;
 93548:     if (flags & HAS_PRINCIPALS_FLAG) {
 93548:         rv = stream->ReadObject(true, getter_AddRefs(readPrincipal));
 93548:         if (NS_FAILED(rv))
 93548:             return rv;
 93548:         principal = nsJSPrincipals::get(readPrincipal);
 93548:     }
 93548: 
 93548:     nsJSPrincipals* originPrincipal = nsnull;
 93548:     nsCOMPtr<nsIPrincipal> readOriginPrincipal;
 93548:     if (flags & HAS_ORIGIN_PRINCIPALS_FLAG) {
 93548:         rv = stream->ReadObject(true, getter_AddRefs(readOriginPrincipal));
 93548:         if (NS_FAILED(rv))
 93548:             return rv;
 93548:         originPrincipal = nsJSPrincipals::get(readOriginPrincipal);
 93548:     }
 93548: 
 93548:     PRUint32 size;
 93548:     rv = stream->Read32(&size);
 93548:     if (NS_FAILED(rv))
 93548:         return rv;
 93548: 
 93548:     char* data;
 93548:     rv = stream->ReadBytes(size, &data);
 93548:     if (NS_FAILED(rv))
 93548:         return rv;
 93548: 
 93548:     {
 93548:         JSAutoRequest ar(cx);
 94006:         if (scriptp) {
 94006:             JSScript *script = JS_DecodeScript(cx, data, size, principal, originPrincipal);
 94006:             if (!script)
 94006:                 rv = NS_ERROR_OUT_OF_MEMORY;
 93548:             else
 94006:                 *scriptp = script;
 94006:         } else {
 94006:             JSObject *funobj = JS_DecodeInterpretedFunction(cx, data, size,
 94006:                                                             principal, originPrincipal);
 94006:             if (!funobj)
 94006:                 rv = NS_ERROR_OUT_OF_MEMORY;
 94006:             else
 94006:                 *functionObjp = funobj;
 93548:         }
 94006:     }
 94006: 
 93548:     nsMemory::Free(data);
 94006:     return rv;
 93548: }
 93548: 
 93548: NS_IMETHODIMP
 93548: nsXPConnect::WriteScript(nsIObjectOutputStream *stream, JSContext *cx, JSScript *script)
 93548: {
 93548:     return WriteScriptOrFunction(stream, cx, script, nsnull);
 93548: }
 93548: 
 93548: NS_IMETHODIMP
 93548: nsXPConnect::ReadScript(nsIObjectInputStream *stream, JSContext *cx, JSScript **scriptp)
 93548: {
 93548:     return ReadScriptOrFunction(stream, cx, scriptp, nsnull);
 93548: }
 93548: 
 93548: NS_IMETHODIMP
 93548: nsXPConnect::WriteFunction(nsIObjectOutputStream *stream, JSContext *cx, JSObject *functionObj)
 93548: {
 93548:     return WriteScriptOrFunction(stream, cx, nsnull, functionObj);
 93548: }
 93548: 
 93548: NS_IMETHODIMP
 93548: nsXPConnect::ReadFunction(nsIObjectInputStream *stream, JSContext *cx, JSObject **functionObjp)
 93548: {
 93548:     return ReadScriptOrFunction(stream, cx, nsnull, functionObjp);
 93548: }
 93548: 
     1: /* These are here to be callable from a debugger */
     1: JS_BEGIN_EXTERN_C
 18403: JS_EXPORT_API(void) DumpJSStack()
     1: {
     1:     nsresult rv;
     1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
     1:     if (NS_SUCCEEDED(rv) && xpc)
 80486:         xpc->DebugDumpJSStack(true, true, false);
     1:     else
     1:         printf("failed to get XPConnect service!\n");
     1: }
     1: 
 55472: JS_EXPORT_API(char*) PrintJSStack()
 55472: {
 55472:     nsresult rv;
 55472:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
 55472:     return (NS_SUCCEEDED(rv) && xpc) ?
 80486:         xpc->DebugPrintJSStack(true, true, false) :
 55472:         nsnull;
 55472: }
 55472: 
 18403: JS_EXPORT_API(void) DumpJSEval(PRUint32 frameno, const char* text)
     1: {
     1:     nsresult rv;
     1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
     1:     if (NS_SUCCEEDED(rv) && xpc)
     1:         xpc->DebugDumpEvalInJSStackFrame(frameno, text);
     1:     else
     1:         printf("failed to get XPConnect service!\n");
     1: }
     1: 
 18403: JS_EXPORT_API(void) DumpJSObject(JSObject* obj)
     1: {
     1:     xpc_DumpJSObject(obj);
     1: }
     1: 
 98362: JS_EXPORT_API(void) DumpJSValue(JS::Value val)
     1: {
 98362:     printf("Dumping 0x%llu.\n", (long long) val.asRawBits());
 98362:     if (val.isNull()) {
     1:         printf("Value is null\n");
 98362:     } else if (val.isObject()) {
     1:         printf("Value is an object\n");
 98362:         DumpJSObject(&val.toObject());
 98362:     } else if (val.isNumber()) {
     1:         printf("Value is a number: ");
 98362:         if (val.isInt32())
 98362:           printf("Integer %i\n", val.toInt32());
 98362:         else if (val.isDouble())
 98362:           printf("Floating-point value %f\n", val.toDouble());
 98362:     } else if (val.isString()) {
     1:         printf("Value is a string: ");
 57721:         putc('<', stdout);
 98362:         JS_FileEscapedString(stdout, val.toString(), 0);
 57721:         fputs(">\n", stdout);
 98362:     } else if (val.isBoolean()) {
     1:         printf("Value is boolean: ");
 98362:         printf(val.isTrue() ? "true" : "false");
 98362:     } else if (val.isUndefined()) {
     1:         printf("Value is undefined\n");
 80390:     } else {
     1:         printf("No idea what this value is.\n");
     1:     }
     1: }
     1: JS_END_EXTERN_C
 18403: 
