   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developers of the Original Code are
   1:  * Sun Microsystems and IBM Corporation
   1:  * Portions created by the Initial Developer are Copyright (C) 2006
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Ginn Chen (ginn.chen@sun.com)
   1:  *   Aaron Leventhal (aleventh@us.ibm.com)
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsHyperTextAccessible.h"
   1: #include "nsAccessibilityAtoms.h"
   1: #include "nsAccessibilityService.h"
   1: #include "nsAccessibleTreeWalker.h"
   1: #include "nsPIAccessNode.h"
   1: #include "nsIClipboard.h"
   1: #include "nsContentCID.h"
   1: #include "nsIDOMAbstractView.h"
   1: #include "nsIDOMCharacterData.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsIDOMDocumentView.h"
   1: #include "nsIDOMRange.h"
   1: #include "nsIDOMWindowInternal.h"
   1: #include "nsIDOMXULDocument.h"
   1: #include "nsIFontMetrics.h"
   1: #include "nsIFrame.h"
   1: #include "nsIPlaintextEditor.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsTextFragment.h"
   1: 
   1: static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
   1: 
   1: // ------------
   1: // nsHyperTextAccessible
   1: // ------------
   1: 
   1: NS_IMPL_ADDREF_INHERITED(nsHyperTextAccessible, nsAccessible)
   1: NS_IMPL_RELEASE_INHERITED(nsHyperTextAccessible, nsAccessible)
   1: 
   1: nsresult nsHyperTextAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
   1: {
   1:   *aInstancePtr = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMXULDocument> xulDoc(do_QueryInterface(mDOMNode));
   1:   if (mDOMNode && !xulDoc) {
   1:     // We need XUL doc check for now because for now nsDocAccessible must inherit from nsHyperTextAccessible
   1:     // in order for HTML document accessibles to get support for these interfaces
   1:     // However at some point we may push <body> to implement the interfaces and
   1:     // return nsDocAccessible to inherit from nsAccessibleWrap
   1:     if (aIID.Equals(NS_GET_IID(nsIAccessibleText))) {
   1:       // If |this| contains any children
   1:       PRInt32 numChildren;
   1:       GetChildCount(&numChildren);
   1:       if (numChildren > 0) {
   1:         *aInstancePtr = NS_STATIC_CAST(nsIAccessibleText*, this);
   1:         NS_ADDREF_THIS();
   1:         return NS_OK;
   1:       }
   1:       return NS_ERROR_NO_INTERFACE;
   1:     }
   1: 
   1:     if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperText))) {
   1:       if (IsHyperText()) {
   1:         // If |this| contains text and embedded objects
   1:         *aInstancePtr = NS_STATIC_CAST(nsIAccessibleHyperText*, this);
   1:         NS_ADDREF_THIS();
   1:         return NS_OK;
   1:       }
   1:       return NS_ERROR_NO_INTERFACE;
   1:     }
   1: 
   1:     if (aIID.Equals(NS_GET_IID(nsIAccessibleEditableText))) {
   1:       // If this contains editable text
 262:       PRUint32 state, extState;
 262:       GetState(&state, &extState);
   1:       if (extState & nsIAccessibleStates::EXT_STATE_EDITABLE) {
   1:         *aInstancePtr = NS_STATIC_CAST(nsIAccessibleEditableText*, this);
   1:         NS_ADDREF_THIS();
   1:         return NS_OK;
   1:       }
   1:       return NS_ERROR_NO_INTERFACE;
   1:     }
   1:   }
   1: 
   1:   return nsAccessible::QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: nsHyperTextAccessible::nsHyperTextAccessible(nsIDOMNode* aNode, nsIWeakReference* aShell):
   1: nsAccessibleWrap(aNode, aShell)
   1: {
   1: }
   1: 
   1: PRBool nsHyperTextAccessible::IsHyperText()
   1: {
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   while (NextChild(accessible)) {
   1:     if (IsEmbeddedObject(accessible)) {
   1:       return PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetRole(PRUint32 *aRole)
   1: {
   1:   nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsIAtom *tag = content->Tag();
   1: 
3151:   if (tag == nsAccessibilityAtoms::form) {
   1:     *aRole = nsIAccessibleRole::ROLE_FORM;
   1:   }
   1:   else if (tag == nsAccessibilityAtoms::div ||
   1:            tag == nsAccessibilityAtoms::blockquote) {
   1:     *aRole = nsIAccessibleRole::ROLE_SECTION;
   1:   }
   1:   else if (tag == nsAccessibilityAtoms::h1 ||
   1:            tag == nsAccessibilityAtoms::h2 ||
   1:            tag == nsAccessibilityAtoms::h3 ||
   1:            tag == nsAccessibilityAtoms::h4 ||
   1:            tag == nsAccessibilityAtoms::h5 ||
   1:            tag == nsAccessibilityAtoms::h6) {
   1:     *aRole = nsIAccessibleRole::ROLE_HEADING;
   1:   }
   1:   else {
   1:     nsIFrame *frame = GetFrame();
   1:     if (frame && frame->GetType() == nsAccessibilityAtoms::blockFrame) {
   1:       *aRole = nsIAccessibleRole::ROLE_PARAGRAPH;
   1:     }
   1:     else {
   1:       *aRole = nsIAccessibleRole::ROLE_TEXT_CONTAINER; // In ATK this works
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
 262: NS_IMETHODIMP
 262: nsHyperTextAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
 262:   nsresult rv = nsAccessibleWrap::GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
 262:   if (!aExtraState)
 262:     return NS_OK;
 262: 
   1:   nsCOMPtr<nsIEditor> editor = GetEditor();
   1:   if (editor) {
   1:     PRUint32 flags;
   1:     editor->GetFlags(&flags);
   1:     if (0 == (flags & nsIPlaintextEditor::eEditorReadonlyMask)) {
 262:       *aExtraState |= nsIAccessibleStates::EXT_STATE_EDITABLE;
   1:     }
   1:   }
   1: 
   1:   PRInt32 childCount;
   1:   GetChildCount(&childCount);
   1:   if (childCount > 0) {
 262:     *aExtraState |= nsIAccessibleStates::EXT_STATE_SELECTABLE_TEXT;
   1:   }
 262: 
 262:   return NS_OK;
   1: }
   1: 
   1: void nsHyperTextAccessible::CacheChildren()
   1: {
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     mAccChildCount = eChildCountUninitialized;
   1:     return;
   1:   }
   1: 
   1:   if (mAccChildCount == eChildCountUninitialized) {
   1:     nsCOMPtr<nsIEditor> editor = GetEditor();
   1:     if (!editor) {
   1:       nsAccessible::CacheChildren();
   1:       return;
   1:     }
   1:     nsCOMPtr<nsIDOMElement> editorRoot;
   1:     editor->GetRootElement(getter_AddRefs(editorRoot));
   1:     nsCOMPtr<nsIDOMNode> editorRootDOMNode = do_QueryInterface(editorRoot);
   1:     if (!editorRootDOMNode) {
   1:       return;
   1:     }
   1:     nsAccessibleTreeWalker walker(mWeakShell, editorRootDOMNode, PR_TRUE);
   1:     nsCOMPtr<nsPIAccessible> privatePrevAccessible;
   1:     PRInt32 childCount = 0;
   1:     walker.GetFirstChild();
   1:     SetFirstChild(walker.mState.accessible);
   1: 
   1:     while (walker.mState.accessible) {
   1:       ++ childCount;
   1:       privatePrevAccessible = do_QueryInterface(walker.mState.accessible);
   1:       privatePrevAccessible->SetParent(this);
   1:       walker.GetNextSibling();
   1:       privatePrevAccessible->SetNextSibling(walker.mState.accessible);
   1:     }
   1:     mAccChildCount = childCount;
   1:   }
   1: }
   1: 
   1: // Substring must be entirely within the same text node
   1: nsIntRect nsHyperTextAccessible::GetBoundsForString(nsIFrame *aFrame, PRInt32 aStartOffset, PRInt32 aLength)
   1: {
   1:   nsIntRect screenRect;
   1:   nsIFrame *frame;
   1:   PRInt32 startOffsetInFrame;
   1:   nsresult rv = aFrame->GetChildFrameContainingOffset(aStartOffset, PR_FALSE,
   1:                                                       &startOffsetInFrame, &frame);
   1:   NS_ENSURE_SUCCESS(rv, screenRect);
   1: 
   1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
   1:   NS_ENSURE_TRUE(shell, screenRect);
   1: 
   1:   nsCOMPtr<nsIRenderingContext> rc;
   1:   shell->CreateRenderingContext(frame, getter_AddRefs(rc));
   1:   NS_ENSURE_TRUE(rc, screenRect);
   1: 
   1:   const nsStyleFont *font = frame->GetStyleFont();
   1:   const nsStyleVisibility *visibility = frame->GetStyleVisibility();
   1: 
   1:   rv = rc->SetFont(font->mFont, visibility->mLangGroup);
   1:   NS_ENSURE_SUCCESS(rv, screenRect);
   1: 
   1:   nsPresContext *context = shell->GetPresContext();
   1: 
   1:   while (frame && aLength > 0) {
   1:     // Start with this frame's screen rect, which we will 
   1:     // shrink based on the substring we care about within it.
   1:     // We will then add that frame to the total screenRect we
   1:     // are returning.
   1:     nsIntRect frameScreenRect = frame->GetScreenRectExternal();
   1: 
   1:     // Get the length of the substring in this frame that we want the bounds for
   1:     PRInt32 startFrameTextOffset, endFrameTextOffset;
   1:     frame->GetOffsets(startFrameTextOffset, endFrameTextOffset);
   1:     PRInt32 frameTotalTextLength = endFrameTextOffset - startFrameTextOffset;
   1:     PRInt32 frameSubStringLength = PR_MIN(frameTotalTextLength - startOffsetInFrame, aLength);
   1: 
   1:     // Add the point where the string starts to the frameScreenRect
   1:     nsPoint frameTextStartPoint;
   1:     rv = frame->GetPointFromOffset(context, rc, aStartOffset, &frameTextStartPoint);
   1:     NS_ENSURE_SUCCESS(rv, nsRect());   
   1:     frameScreenRect.x += context->AppUnitsToDevPixels(frameTextStartPoint.x);
   1: 
   1:     // Use the point for the end offset to calculate the width
   1:     nsPoint frameTextEndPoint;
   1:     rv = frame->GetPointFromOffset(context, rc, aStartOffset + frameSubStringLength, &frameTextEndPoint);
   1:     NS_ENSURE_SUCCESS(rv, nsRect());   
   1:     frameScreenRect.width = context->AppUnitsToDevPixels(frameTextEndPoint.x - frameTextStartPoint.x);
   1: 
   1:     screenRect.UnionRect(frameScreenRect, screenRect);
   1: 
   1:     // Get ready to loop back for next frame continuation
   1:     aStartOffset += frameSubStringLength;
   1:     startOffsetInFrame = 0;
   1:     aLength -= frameSubStringLength;
   1:     frame = frame->GetNextContinuation();
   1:   }
   1: 
   1:   return screenRect;
   1: }
   1: 
   1: /*
   1:  * Gets the specified text.
   1:  */
   1: nsIFrame* nsHyperTextAccessible::GetPosAndText(PRInt32& aStartOffset, PRInt32& aEndOffset, nsAString *aText,
   1:                                                nsIFrame **aEndFrame, nsIntRect *aBoundsRect)
   1: {
   1:   PRInt32 startOffset = aStartOffset;
   1:   PRInt32 endOffset = aEndOffset;
   1: 
   1:   // Clear out parameters and set up loop
   1:   if (aText) {
   1:     aText->Truncate();
   1:   }
   1:   if (endOffset < 0) {
   1:     const PRInt32 kMaxTextLength = 32767;
   1:     endOffset = kMaxTextLength; // Max end offset
   1:   }
   1:   else if (startOffset > endOffset) {
   1:     return nsnull;
   1:   }
   1: 
   1:   nsIFrame *startFrame = nsnull;
   1:   if (aEndFrame) {
   1:     *aEndFrame = nsnull;
   1:   }
   1:   if (aBoundsRect) {
   1:     aBoundsRect->Empty();
   1:   }
   1: 
   1:   nsIntRect unionRect;
   1:   nsCOMPtr<nsIAccessible> accessible;
   1: 
   1:   // Loop through children and collect valid offsets, text and bounds
   1:   // depending on what we need for out parameters
   1:   while (NextChild(accessible)) {
   1:     nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(accessible));
   1:     nsIFrame *frame = accessNode->GetFrame();
   1:     if (!frame) {
   1:       continue;
   1:     }
   1:     if (IsText(accessible)) {
 460:       nsCOMPtr<nsPIAccessible> pAcc(do_QueryInterface(accessible));
   1:       nsAutoString newText;
 460:       pAcc->GetContentText(newText);
 460: 
 460:       PRInt32 substringEndOffset = newText.Length();
   1:       if (startOffset < substringEndOffset) {
   1:         // Our start is within this substring
   1:         // XXX Can we somehow optimize further by getting the nsTextFragment
   1:         // and use CopyTo to a PRUnichar buffer to copy it directly to
   1:         // the string?
 460: 
   1:         if (startOffset > 0 || endOffset < substringEndOffset) {
   1:           // XXX the Substring operation is efficient, but does the 
   1:           // reassignment to the original nsAutoString cause a copy?
   1:           PRInt32 outStartLineUnused;
   1:           frame->GetChildFrameContainingOffset(startOffset, PR_TRUE, &outStartLineUnused, &frame);
   1:           if (endOffset < substringEndOffset) {
   1:             // Don't take entire substring: stop before the end
   1:             substringEndOffset = endOffset;
   1:           }
   1:           if (aText) {
   1:             newText = Substring(newText, startOffset,
   1:                                 substringEndOffset - startOffset);
   1:           }
   1:           if (aEndFrame) {
   1:             *aEndFrame = frame; // We ended in the current frame
   1:           }
   1:           aEndOffset = endOffset;
   1:         }
   1:         if (aText) {
   1:           if (!frame->GetStyleText()->WhiteSpaceIsSignificant()) {
   1:             // Replace \r\n\t in markup with space unless in this is
   1:             // preformatted text  where those characters are significant
   1:             newText.ReplaceChar("\r\n\t", ' ');
   1:           }
   1:           *aText += newText;
   1:         }
   1:         if (aBoundsRect) {
   1:           aBoundsRect->UnionRect(*aBoundsRect, GetBoundsForString(frame, startOffset,
   1:                                                                   substringEndOffset - startOffset));
   1:         }
   1:         if (!startFrame) {
   1:           startFrame = frame;
   1:           aStartOffset = startOffset;
   1:         }
   1:         startOffset = 0;
   1:       }
   1:       else {
   1:         startOffset -= substringEndOffset;
   1:       }
   1:       endOffset -= substringEndOffset;
   1:     }
   1:     else {
   1:       // Embedded object, append marker
   1:       // XXX Append \n for <br>'s
   1:       if (startOffset >= 1) {
   1:         -- startOffset;
   1:       }
   1:       else {
   1:         if (endOffset > 0) {
   1:           if (aText) {
   1:             *aText += (frame->GetType() == nsAccessibilityAtoms::brFrame) ?
   1:                       kForcedNewLineChar : kEmbeddedObjectChar;
   1:           }
   1:           if (aBoundsRect) {
   1:             aBoundsRect->UnionRect(*aBoundsRect, frame->GetScreenRectExternal());
   1:           }
   1:         }
   1:         if (!startFrame) {
   1:           startFrame = frame;
   1:           aStartOffset = 0;
   1:         }
   1:       }
   1:       -- endOffset;
   1:     }
   1:     if (endOffset <= 0 && startFrame) {
   1:       break; // If we don't have startFrame yet, get that in next loop iteration
   1:     }
   1:   }
   1: 
   1:   if (aEndFrame && !*aEndFrame) {
   1:     *aEndFrame = startFrame;
   1:   }
   1: 
   1:   return startFrame;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetText(PRInt32 aStartOffset, PRInt32 aEndOffset, nsAString &aText)
   1: {
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   return GetPosAndText(aStartOffset, aEndOffset, &aText) ? NS_OK : NS_ERROR_FAILURE;
   1: }
   1: 
   1: /*
   1:  * Gets the character count.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterCount(PRInt32 *aCharacterCount)
   1: {
   1:   *aCharacterCount = 0;
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> accessible;
   1: 
   1:   while (NextChild(accessible)) {
   1:     *aCharacterCount += TextLength(accessible);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /*
   1:  * Gets the specified character.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterAtOffset(PRInt32 aOffset, PRUnichar *aCharacter)
   1: {
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsAutoString text;
   1:   nsresult rv = GetText(aOffset, aOffset + 1, text);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   *aCharacter = text.First();
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult nsHyperTextAccessible::DOMPointToOffset(nsIDOMNode* aNode, PRInt32 aNodeOffset, PRInt32* aResult,
   1:                                                  nsIAccessible **aFinalAccessible)
   1: {
   1:   // Turn a DOM Node and offset into an offset into this hypertext.
   1:   // On failure, return null. On success, return the DOM node which contains the offset.
   1:   NS_ENSURE_ARG_POINTER(aResult);
   1:   *aResult = 0;
   1:   NS_ENSURE_ARG_POINTER(aNode);
   1:   NS_ENSURE_TRUE(aNodeOffset >= 0, NS_ERROR_INVALID_ARG);
   1:   if (aFinalAccessible) {
   1:     *aFinalAccessible = nsnull;
   1:   }
   1: 
   1:   PRInt32 addTextOffset = 0;
   1:   nsCOMPtr<nsIDOMNode> findNode;
   1: 
   1:   unsigned short nodeType;
   1:   aNode->GetNodeType(&nodeType);
   1:   if (nodeType == nsIDOMNode::TEXT_NODE) {
   1:     // For text nodes, aNodeOffset comes in as a character offset
   1:     // Text offset will be added at the end, if we find the offset in this hypertext
   1:     addTextOffset = aNodeOffset;
   1:     // Get the child node and 
   1:     findNode = aNode;
   1:   }
   1:   else {
   1:     // For non-text nodes, aNodeOffset comes in as a child node index
   1:     nsCOMPtr<nsIContent> parentContent(do_QueryInterface(aNode));
   1:     // Should not happen, but better to protect against crash if doc node is somehow passed in
   1:     NS_ENSURE_TRUE(parentContent, NS_ERROR_FAILURE);
 648:     // findNode could be null if aNodeOffset == # of child nodes, which means one of two things:
 648:     // 1) we're at the end of the children, keep findNode = null, so that we get the last possible offset
 648:     // 2) there are no children, use parentContent for the node to find. In this case parentContent can't be
 648:     //    the nsIAccessibleText, because an accesible text must have children
 648:      
   1:     findNode = do_QueryInterface(parentContent->GetChildAt(aNodeOffset));
 648:     if (!findNode && !aNodeOffset) {
 648:       NS_ASSERTION(!SameCOMIdentity(parentContent, mDOMNode), "Cannot find child for DOMPointToOffset search");
 648:       findNode = do_QueryInterface(parentContent); // Case #2: there are no children
 648:     }
   1:   }
   1: 
   1:   // Get accessible for this findNode, or if that node isn't accessible, use the
   1:   // accessible for the next DOM node which has one (based on forward depth first search)
   1:   nsCOMPtr<nsIAccessible> descendantAccessible;
   1:   if (findNode) {
   1:     descendantAccessible = GetFirstAvailableAccessible(findNode);
   1:   }
   1:   // From the descendant, go up and get the immediate child of this hypertext
   1:   nsCOMPtr<nsIAccessible> childAccessible;
   1:   while (descendantAccessible) {
   1:     nsCOMPtr<nsIAccessible> parentAccessible;
   1:     descendantAccessible->GetParent(getter_AddRefs(parentAccessible));
   1:     if (this == parentAccessible) {
   1:       childAccessible = descendantAccessible;
   1:       break;
   1:     }
   1:     // This offset no longer applies because the passed-in text object is not a child
   1:     // of the hypertext. This happens when there are nested hypertexts, e.g.
   1:     // <div>abc<h1>def</h1>ghi</div>
   1:     // If the passed-in DOM point was not on a direct child of the hypertext, we will
   1:     // return the offset for that entire hypertext
1318:     // If the offset was after the first character of the passed in object, we will now use 1 for
1318:     // addTextOffset, to put us after the embedded object char. We'll only treat the offset as
1318:     // before the embedded object char if we end at the very beginning of the child.
1318:     addTextOffset = addTextOffset > 0;
 764:     descendantAccessible = parentAccessible;
   1:   }  
   1: 
   1:   // Loop through, adding offsets until we reach childAccessible
   1:   // If childAccessible is null we will end up adding up the entire length of
   1:   // the hypertext, which is good -- it just means our offset node
   1:   // came after the last accessible child's node
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   while (NextChild(accessible) && accessible != childAccessible) {
   1:     *aResult += TextLength(accessible);
   1:   }
   1:   if (accessible) {
   1:     *aResult += addTextOffset;
   1:     NS_ASSERTION(accessible == childAccessible, "These should be equal whenever we exit loop and accessible != nsnull");
   1:     if (aFinalAccessible && (NextChild(accessible) || addTextOffset < TextLength(childAccessible))) {  
   1:       // If not at end of last text node, we will return the accessible we were in
   1:       NS_ADDREF(*aFinalAccessible = childAccessible);
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: PRInt32 nsHyperTextAccessible::GetRelativeOffset(nsIPresShell *aPresShell, nsIFrame *aFromFrame, PRInt32 aFromOffset,
   1:                                                  nsSelectionAmount aAmount, nsDirection aDirection, PRBool aNeedsStart)
   1: {
   1:   const PRBool kIsJumpLinesOk = PR_TRUE;          // okay to jump lines
   1:   const PRBool kIsScrollViewAStop = PR_FALSE;     // do not stop at scroll views
   1:   const PRBool kIsKeyboardSelect = PR_TRUE;       // is keyboard selection
   1:   const PRBool kIsVisualBidi = PR_FALSE;          // use visual order for bidi text
   1: 
   1:   EWordMovementType wordMovementType = aNeedsStart ? eStartWord : eEndWord;
   1:   if (aAmount == eSelectLine) {
   1:     aAmount = (aDirection == eDirNext) ? eSelectEndLine : eSelectBeginLine;
   1:   }
   1: 
   1:   // Ask layout for the new node and offset, after moving the appropriate amount
   1:   nsPeekOffsetStruct pos;
   1:   pos.SetData(aAmount, aDirection, aFromOffset, 0, kIsJumpLinesOk,
   1:               kIsScrollViewAStop, kIsKeyboardSelect, kIsVisualBidi,
   1:               wordMovementType);
   1:   nsresult rv = aFromFrame->PeekOffset(&pos);
   1:   if (NS_FAILED(rv)) {
   1:     if (aDirection == eDirPrevious) {
   1:       // Use passed-in frame as starting point in failure case for now,
   1:       // this is a hack to deal with starting on a list bullet frame,
   1:       // which fails in PeekOffset() because the line iterator doesn't see it.
   1:       // XXX Need to look at our overall handling of list bullets, which are an odd case
   1:       pos.mResultContent = aFromFrame->GetContent();
   1:       PRInt32 endOffsetUnused;
   1:       aFromFrame->GetOffsets(pos.mContentOffset, endOffsetUnused);
   1:     }
   1:     else {
   1:       return rv;
   1:     }
   1:   }
   1: 
   1:   // Turn the resulting node and offset into a hyperTextOffset
   1:   PRInt32 hyperTextOffset;
   1:   nsCOMPtr<nsIDOMNode> resultNode = do_QueryInterface(pos.mResultContent);
   1:   NS_ENSURE_TRUE(resultNode, -1);
   1: 
   1:   nsCOMPtr<nsIAccessible> finalAccessible;
   1:   rv = DOMPointToOffset(resultNode, pos.mContentOffset, &hyperTextOffset, getter_AddRefs(finalAccessible));
   1:   // If finalAccessible == nsnull, then DOMPointToOffset() searched through the hypertext
   1:   // children without finding the node/offset position
   1:   NS_ENSURE_SUCCESS(rv, -1);
   1: 
   1:   if (!finalAccessible && aDirection == eDirPrevious) {
   1:     // If we reached the end during search, this means we didn't find the DOM point
   1:     // and we're actually at the start of the paragraph
   1:     hyperTextOffset = 0;
   1:   }  
   1:   else if (aAmount == eSelectBeginLine) {
   1:     // For line selection with needsStart, set start of line exactly to line break
 764:     if (pos.mContentOffset == 0 && mFirstChild && 
 764:         Role(mFirstChild) == nsIAccessibleRole::ROLE_STATICTEXT &&
 764:         TextLength(mFirstChild) == hyperTextOffset) {
 764:       // XXX Bullet hack -- we should remove this once list bullets use anonymous content
 764:       hyperTextOffset = 0;
 764:     }
   1:     if (!aNeedsStart && hyperTextOffset > 0) {
   1:       -- hyperTextOffset;
   1:     }
   1:   }
   1:   else if (aAmount == eSelectEndLine && finalAccessible) { 
   1:     // If not at very end of hypertext, we may need change the end of line offset by 1, 
   1:     // to make sure we are in the right place relative to the line ending
   1:     if (Role(finalAccessible) == nsIAccessibleRole::ROLE_WHITESPACE) {  // Landed on <br> hard line break
   1:       // if aNeedsStart, set end of line exactly 1 character past line break
   1:       // XXX It would be cleaner if we did not have to have the hard line break check,
   1:       // and just got the correct results from PeekOffset() for the <br> case -- the returned offset should
   1:       // come after the new line, as it does in other cases.
   1:       ++ hyperTextOffset;  // Get past hard line break
   1:     }
   1:     // We are now 1 character past the line break
   1:     if (!aNeedsStart) {
   1:       -- hyperTextOffset;
   1:     }
   1:   }
   1: 
   1:   return hyperTextOffset;
   1: }
   1: 
   1: /*
   1: Gets the specified text relative to aBoundaryType, which means:
   1: BOUNDARY_CHAR             The character before/at/after the offset is returned.
   1: BOUNDARY_WORD_START       From the word start before/at/after the offset to the next word start.
   1: BOUNDARY_WORD_END         From the word end before/at/after the offset to the next work end.
   1: BOUNDARY_LINE_START       From the line start before/at/after the offset to the next line start.
   1: BOUNDARY_LINE_END         From the line end before/at/after the offset to the next line start.
   1: */
   1: 
   1: nsresult nsHyperTextAccessible::GetTextHelper(EGetTextType aType, nsAccessibleTextBoundary aBoundaryType,
   1:                                               PRInt32 aOffset, PRInt32 *aStartOffset, PRInt32 *aEndOffset,
   1:                                               nsAString &aText)
   1: {
   1:   aText.Truncate();
   1:   *aStartOffset = *aEndOffset = 0;
   1: 
   1:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
   1:   if (!presShell) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   PRInt32 startOffset = aOffset;
   1:   PRInt32 endOffset = aOffset;
   1: 
   1:   if (aBoundaryType == BOUNDARY_LINE_END) {
   1:     // Avoid getting the previous line
   1:     ++ startOffset;
   1:     ++ endOffset;
   1:   }
   1:   // Convert offsets to frame-relative
   1:   nsIFrame *startFrame = GetPosAndText(startOffset, endOffset);
   1:   if (!startFrame) {
   1:     PRInt32 textLength;
   1:     GetCharacterCount(&textLength);
   1:     return (aOffset < 0 || aOffset > textLength) ? NS_ERROR_FAILURE : NS_OK;
   1:   }
   1: 
   1:   nsSelectionAmount amount;
   1:   PRBool needsStart = PR_FALSE;
   1:   switch (aBoundaryType)
   1:   {
   1:   case BOUNDARY_CHAR:
   1:     amount = eSelectCharacter;
   1:     if (aType == eGetAt) {
   1:       aType = eGetAfter; // Avoid returning 2 characters
   1:     }
   1:     break;
   1:   case BOUNDARY_WORD_START:
   1:     needsStart = PR_TRUE;
   1:     amount = eSelectWord;
   1:     break;
   1:   case BOUNDARY_WORD_END:
   1:     amount = eSelectWord;
   1:     break;
   1:   case BOUNDARY_LINE_START:
   1:     // Newlines are considered at the end of a line,
   1:     // Since getting the BOUNDARY_LINE_START gets the text from the line-start
   1:     // to the next line-start, the newline is included at the end of the string
   1:     needsStart = PR_TRUE;
   1:     amount = eSelectLine;
   1:     break;
   1:   case BOUNDARY_LINE_END:
   1:     // Newlines are considered at the end of a line,
   1:     // Since getting the BOUNDARY_END_START gets the text from the line-end
   1:     // to the next line-end, the newline is included at the beginning of the string
   1:     amount = eSelectLine;
   1:     break;
   1:   case BOUNDARY_ATTRIBUTE_RANGE:
   1:     {
   1:       // XXX We should merge identically formatted frames
   1:       // XXX deal with static text case
   1:       // XXX deal with boundary type
   1:       nsIContent *textContent = startFrame->GetContent();
   1:       // If not text, then it's represented by an embedded object char 
   1:       // (length of 1)
   1:       // XXX did this mean to check for eTEXT?
   1:       PRInt32 textLength = textContent ? textContent->TextLength() : 1;
   1:       *aStartOffset = aOffset - startOffset;
   1:       *aEndOffset = *aStartOffset + textLength;
   1:       startOffset = *aStartOffset;
   1:       endOffset = *aEndOffset;
   1:       return GetText(startOffset, endOffset, aText);
   1:     }
   1:   default:  // Note, sentence support is deprecated and falls through to here
   1:     return NS_ERROR_INVALID_ARG;
   1:   }
   1: 
   1:   PRInt32 finalStartOffset, finalEndOffset;
   1: 
   1:   // If aType == eGetAt we'll change both the start and end offset from
   1:   // the original offset
   1:   if (aType == eGetAfter) {
   1:     finalStartOffset = aOffset;
   1:   }
   1:   else {
   1:     finalStartOffset = GetRelativeOffset(presShell, startFrame,  startOffset,
   1:                                          amount, eDirPrevious, needsStart);
   1:     NS_ENSURE_TRUE(finalStartOffset >= 0, NS_ERROR_FAILURE);
   1:   }
   1: 
   1:   if (aType == eGetBefore) {
   1:     endOffset = aOffset;
   1:   }
   1:   else {
   1:     // Start moving forward from the start so that we don't get 
   1:     // 2 words/lines if the offset occured on whitespace boundary
   1:     // Careful, startOffset and endOffset are passed by reference to GetPosAndText() and changed
   1:     startOffset = endOffset = finalStartOffset;
   1:     nsIFrame *endFrame = GetPosAndText(startOffset, endOffset);
   1:     if (!endFrame) {
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:     finalEndOffset = GetRelativeOffset(presShell, endFrame, endOffset, amount,
   1:                                        eDirNext, needsStart);
   1:     NS_ENSURE_TRUE(endOffset >= 0, NS_ERROR_FAILURE);
   1:     if (finalEndOffset == aOffset) {
   1:       // This happens sometimes when current character at finalStartOffset 
   1:       // is an embedded object character representing another hypertext, that
   1:       // the AT really needs to dig into separately
   1:       ++ finalEndOffset;
   1:     }
   1:   }
   1: 
   1:   // Fix word error for the first character in word: PeekOffset() will return the previous word when 
   1:   // aOffset points to the first character of the word, but accessibility APIs want the current word 
   1:   // that the first character is in
   1:   if (aType == eGetAt && amount == eSelectWord && aOffset == endOffset) { 
   1:     return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
   1:   }
   1: 
   1:   *aStartOffset = finalStartOffset;
   1:   *aEndOffset = finalEndOffset;
   1: 
   1:   NS_ASSERTION((finalStartOffset < aOffset && finalEndOffset >= aOffset) || aType != eGetBefore, "Incorrect results for GetTextHelper");
   1:   NS_ASSERTION((finalStartOffset <= aOffset && finalEndOffset > aOffset) || aType == eGetBefore, "Incorrect results for GetTextHelper");
   1: 
   1:   return GetPosAndText(finalStartOffset, finalEndOffset, &aText) ? NS_OK : NS_ERROR_FAILURE;
   1: }
   1: 
   1: /**
   1:   * nsIAccessibleText impl.
   1:   */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetTextBeforeOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
   1:                                                          PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
   1: {
   1:   return GetTextHelper(eGetBefore, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetTextAtOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
   1:                                                      PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
   1: {
   1:   return GetTextHelper(eGetAt, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetTextAfterOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
   1:                                                         PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
   1: {
   1:   return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetAttributeRange(PRInt32 aOffset, PRInt32 *aRangeStartOffset, 
   1:                                                        PRInt32 *aRangeEndOffset, nsIAccessible **aAccessibleWithAttrs)
   1: {
   1:   // Return the range of text with common attributes around aOffset
   1:   *aRangeStartOffset = *aRangeEndOffset = 0;
   1:   *aAccessibleWithAttrs = nsnull;
   1: 
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   
   1:   while (NextChild(accessible)) {
   1:     PRInt32 length = TextLength(accessible);
   1:     if (*aRangeStartOffset + length > aOffset) {
   1:       *aRangeEndOffset = *aRangeStartOffset + length;
   1:       NS_ADDREF(*aAccessibleWithAttrs = accessible);
   1:       return NS_OK;
   1:     }
   1:     *aRangeStartOffset += length;
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
 401: nsresult
 401: nsHyperTextAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
   1: {
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;  // Node already shut down
   1:   }
   1: 
 401:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
   1:   nsIAtom *tag = content->Tag();
   1: 
 401:   PRInt32 headLevel = 0;
 144:   if (tag == nsAccessibilityAtoms::h1)
 401:     headLevel = 1;
 144:   else if (tag == nsAccessibilityAtoms::h2)
 401:     headLevel = 2;
 144:   else if (tag == nsAccessibilityAtoms::h3)
 401:     headLevel = 3;
 144:   else if (tag == nsAccessibilityAtoms::h4)
 401:     headLevel = 4;
 144:   else if (tag == nsAccessibilityAtoms::h5)
 401:     headLevel = 5;
 144:   else if (tag == nsAccessibilityAtoms::h6)
 401:     headLevel = 6;
 144: 
 401:   if (headLevel) {
 401:     nsAutoString strHeadLevel;
 401:     strHeadLevel.AppendInt(headLevel);
3146:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::level,
 401:                            strHeadLevel);
   1:   }
   1: 
   1:   return  NS_OK;
   1: }
   1: 
   1: /*
   1:  * Given an offset, the x, y, width, and height values are filled appropriately.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterExtents(PRInt32 aOffset, PRInt32 *aX, PRInt32 *aY,
   1:                                                          PRInt32 *aWidth, PRInt32 *aHeight,
 728:                                                          PRUint32 aCoordType)
   1: {
   1:   return GetRangeExtents(aOffset, aOffset + 1, aX, aY, aWidth, aHeight, aCoordType);
   1: }
   1: 
   1: /*
   1:  * Given a start & end offset, the x, y, width, and height values are filled appropriately.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetRangeExtents(PRInt32 aStartOffset, PRInt32 aEndOffset,
   1:                                                      PRInt32 *aX, PRInt32 *aY,
   1:                                                      PRInt32 *aWidth, PRInt32 *aHeight,
 728:                                                      PRUint32 aCoordType)
   1: {
   1:   nsIntRect boundsRect;
   1:   nsIFrame *endFrameUnused;
2395:   if (!GetPosAndText(aStartOffset, aEndOffset, nsnull, &endFrameUnused, &boundsRect) ||
2395:       boundsRect.IsEmpty()) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   *aX = boundsRect.x;
   1:   *aY = boundsRect.y;
   1:   *aWidth = boundsRect.width;
   1:   *aHeight = boundsRect.height;
   1: 
 728:   if (aCoordType == nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE) {
   1:     //co-ord type = window
   1:     nsCOMPtr<nsIPresShell> shell = GetPresShell();
   1:     NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
   1:     nsCOMPtr<nsIDocument> doc = shell->GetDocument();
   1:     nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(doc));
   1:     NS_ENSURE_TRUE(docView, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIDOMAbstractView> abstractView;
   1:     docView->GetDefaultView(getter_AddRefs(abstractView));
   1:     NS_ENSURE_TRUE(abstractView, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIDOMWindowInternal> windowInter(do_QueryInterface(abstractView));
   1:     NS_ENSURE_TRUE(windowInter, NS_ERROR_FAILURE);
   1: 
   1:     PRInt32 screenX, screenY;
   1:     if (NS_FAILED(windowInter->GetScreenX(&screenX)) ||
   1:         NS_FAILED(windowInter->GetScreenY(&screenY))) {
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:     *aX -= screenX;
   1:     *aY -= screenY;
   1:   }
   1:   // else default: co-ord type = screen
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /*
   1:  * Gets the offset of the character located at coordinates x and y. x and y are interpreted as being relative to
   1:  * the screen or this widget's window depending on coords.
   1:  */
 728: NS_IMETHODIMP
 728: nsHyperTextAccessible::GetOffsetAtPoint(PRInt32 aX, PRInt32 aY,
 728:                                         PRUint32 aCoordType, PRInt32 *aOffset)
   1: {
   1:   *aOffset = -1;
   1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
   1:   if (!shell) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsIFrame *hyperFrame = GetFrame();
   1:   if (!hyperFrame) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsIntRect frameScreenRect = hyperFrame->GetScreenRectExternal();
   1: 
 728:   if (aCoordType == nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE) {
   1:     nsCOMPtr<nsIDocument> doc = shell->GetDocument();
   1:     nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(doc));
   1:     NS_ENSURE_TRUE(docView, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIDOMAbstractView> abstractView;
   1:     docView->GetDefaultView(getter_AddRefs(abstractView));
   1:     NS_ENSURE_TRUE(abstractView, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIDOMWindowInternal> windowInter(do_QueryInterface(abstractView));
   1:     NS_ENSURE_TRUE(windowInter, NS_ERROR_FAILURE);
   1: 
   1:     PRInt32 windowX, windowY;
   1:     if (NS_FAILED(windowInter->GetScreenX(&windowX)) ||
   1:         NS_FAILED(windowInter->GetScreenY(&windowY))) {
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:     aX += windowX;
   1:     aY += windowY;
   1:   }
   1:   // aX, aY are currently screen coordinates, and we need to turn them into
   1:   // frame coordinates relative to the current accessible
   1:   if (!frameScreenRect.Contains(aX, aY)) {
   1:     return NS_OK;   // Not found, will return -1
   1:   }
   1:   nsPoint pointInHyperText(aX - frameScreenRect.x, aY - frameScreenRect.y);
   1:   nsPresContext *context = GetPresContext();
   1:   NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
   1:   pointInHyperText.x = context->DevPixelsToAppUnits(pointInHyperText.x);
   1:   pointInHyperText.y = context->DevPixelsToAppUnits(pointInHyperText.y);
   1: 
   1:   // Go through the frames to check if each one has the point.
   1:   // When one does, add up the character offsets until we have a match
   1: 
   1:   // We have an point in an accessible child of this, now we need to add up the
   1:   // offsets before it to what we already have
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   PRInt32 offset = 0;
   1: 
   1:   while (NextChild(accessible)) {
   1:     nsCOMPtr<nsPIAccessNode> accessNode(do_QueryInterface(accessible));
   1:     nsIFrame *frame = accessNode->GetFrame();
   1:     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
   1:     while (frame) {
   1:       nsIContent *content = frame->GetContent();
   1:       NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
   1:       nsPoint pointInFrame = pointInHyperText - frame->GetOffsetToExternal(hyperFrame);
   1:       nsSize frameSize = frame->GetSize();
   1:       if (pointInFrame.x < frameSize.width && pointInFrame.y < frameSize.height) {
   1:         // Finished
   1:         if (IsText(accessible)) {
   1:           nsIFrame::ContentOffsets contentOffsets = frame->GetContentOffsetsFromPointExternal(pointInFrame, PR_TRUE);
   1:           if (contentOffsets.IsNull() || contentOffsets.content != content) {
   1:             return NS_OK; // Not found, will return -1
   1:           }
   1:           offset += contentOffsets.offset;
   1:         }
   1:         *aOffset = offset;
   1:         return NS_OK;
   1:       }
   1:       frame = frame->GetNextContinuation();
   1:     }
   1:     offset += TextLength(accessible);
   1:   }
   1: 
   1:   return NS_OK; // Not found, will return -1
   1: }
   1: 
   1: // ------- nsIAccessibleHyperText ---------------
   1: NS_IMETHODIMP nsHyperTextAccessible::GetLinks(PRInt32 *aLinks)
   1: {
   1:   *aLinks = 0;
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> accessible;
   1: 
   1:   while (NextChild(accessible)) {
   1:     if (IsEmbeddedObject(accessible)) {
   1:       ++*aLinks;
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetLink(PRInt32 aIndex, nsIAccessibleHyperLink **aLink)
   1: {
   1:   *aLink = nsnull;
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> accessible;
   1: 
   1:   while (NextChild(accessible)) {
   1:     if (IsEmbeddedObject(accessible) && aIndex-- == 0) {
   1:       CallQueryInterface(accessible, aLink);
   1:       return NS_OK;
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::GetLinkIndex(PRInt32 aCharIndex, PRInt32 *aLinkIndex)
   1: {
   1:   *aLinkIndex = -1; // API says this magic value means 'not found'
   1: 
   1:   PRInt32 characterCount = 0;
   1:   PRInt32 linkIndex = 0;
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> accessible;
   1: 
   1:   while (NextChild(accessible) && characterCount <= aCharIndex) {
   1:     PRUint32 role = Role(accessible);
   1:     if (role == nsIAccessibleRole::ROLE_TEXT_LEAF ||
   1:         role == nsIAccessibleRole::ROLE_STATICTEXT) {
   1:       characterCount += TextLength(accessible);
   1:     }
   1:     else {
   1:       if (characterCount ++ == aCharIndex) {
   1:         *aLinkIndex = linkIndex;
   1:         break;
   1:       }
   1:       if (role != nsIAccessibleRole::ROLE_WHITESPACE) {
   1:         ++ linkIndex;
   1:       }
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * nsIAccessibleEditableText impl.
   1:   */
   1: NS_IMETHODIMP nsHyperTextAccessible::SetAttributes(PRInt32 aStartPos, PRInt32 aEndPos,
   1:                                                    nsISupports *aAttributes)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::SetTextContents(const nsAString &aText)
   1: {
   1:   PRInt32 numChars;
   1:   GetCharacterCount(&numChars);
   1:   if (numChars == 0 || NS_SUCCEEDED(DeleteText(0, numChars))) {
   1:     return InsertText(aText, 0);
   1:   }
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::InsertText(const nsAString &aText, PRInt32 aPosition)
   1: {
   1:   if (NS_SUCCEEDED(SetCaretOffset(aPosition))) {
   1:     nsCOMPtr<nsIEditor> editor = GetEditor();
   1:     nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));
   1:     return peditor ? peditor->InsertText(aText) : NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::CopyText(PRInt32 aStartPos, PRInt32 aEndPos)
   1: {
   1:   nsCOMPtr<nsIEditor> editor = GetEditor();
   1:   if (editor && NS_SUCCEEDED(SetSelectionRange(aStartPos, aEndPos)))
   1:     return editor->Copy();
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::CutText(PRInt32 aStartPos, PRInt32 aEndPos)
   1: {
   1:   nsCOMPtr<nsIEditor> editor = GetEditor();
   1:   if (editor && NS_SUCCEEDED(SetSelectionRange(aStartPos, aEndPos)))
   1:     return editor->Cut();
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DeleteText(PRInt32 aStartPos, PRInt32 aEndPos)
   1: {
   1:   nsCOMPtr<nsIEditor> editor = GetEditor();
   1:   if (editor && NS_SUCCEEDED(SetSelectionRange(aStartPos, aEndPos)))
   1:     return editor->DeleteSelection(nsIEditor::eNone);
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::PasteText(PRInt32 aPosition)
   1: {
   1:   nsCOMPtr<nsIEditor> editor = GetEditor();
   1:   if (editor && NS_SUCCEEDED(SetCaretOffset(aPosition)))
   1:     return editor->Paste(nsIClipboard::kGlobalClipboard);
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: /**
   1:   * nsIEditActionListener impl.
   1:   */
   1: NS_IMETHODIMP nsHyperTextAccessible::WillCreateNode(const nsAString& aTag,
   1:                                                     nsIDOMNode *aParent, PRInt32 aPosition)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidCreateNode(const nsAString& aTag, nsIDOMNode *aNode,
   1:                                                    nsIDOMNode *aParent, PRInt32 aPosition, nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent,
   1:                                                     PRInt32 aPosition)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent,
   1:                                                    PRInt32 aPosition, nsresult aResult)
   1: {
   1:   InvalidateChildren();
   1: 
 582:   PRInt32 start;
 582:   PRUint32 length = 1;
 582:   PRBool isInserted = PR_TRUE;
 582: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
   1:   if (content && content->IsNodeOfType(nsINode::eTEXT)) {
 582:     length = content->TextLength();
 582:     if (!length)
   1:       return NS_OK;
   1:   }
   1:   else {
   1:     // Don't fire event for the first br
   1:     nsCOMPtr<nsIEditor> editor = GetEditor();
   1:     if (editor) {
   1:       PRBool isEmpty;
   1:       editor->GetDocumentIsEmpty(&isEmpty);
   1:       if (isEmpty) {
   1:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
2166:   nsCOMPtr<nsIDOMNode> parentNode;
2166:   aNode->GetParentNode(getter_AddRefs(parentNode));
2166:   if (NS_FAILED(DOMPointToOffset(parentNode, aPosition, &start)))
   1:     return NS_OK;
 582: 
 582:   nsCOMPtr<nsIAccessibleTextChangeEvent> event =
 582:     new nsAccTextChangeEvent(this, start, length, isInserted);
 582:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 582: 
 582:   return FireAccessibleEvent(event);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillDeleteNode(nsIDOMNode *aChild)
   1: {
 582:   PRInt32 start;
 582:   PRUint32 length = 1;
 582:   PRBool isInserted = PR_FALSE;
   1: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aChild));
   1:   if (content && content->IsNodeOfType(nsINode::eTEXT)) {
 582:     length = content->TextLength();
 582:     if (!length)
   1:       return NS_OK;
   1:   }
   1:   else {
   1:     // Don't fire event for the last br
   1:     nsCOMPtr<nsIEditor> editor = GetEditor();
   1:     if (editor) {
   1:       PRBool isEmpty;
   1:       editor->GetDocumentIsEmpty(&isEmpty);
   1:       if (isEmpty) {
   1:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
   1:   nsCOMPtr<nsIDOMNode> parentNode;
   1:   aChild->GetParentNode(getter_AddRefs(parentNode));
   1:   nsCOMPtr<nsIContent> parentContent(do_QueryInterface(parentNode));
   1:   NS_ENSURE_TRUE(parentContent, NS_ERROR_FAILURE);
   1:   nsCOMPtr<nsIContent> childContent(do_QueryInterface(aChild));
   1:   NS_ENSURE_TRUE(childContent, NS_ERROR_FAILURE);
 582:   if (NS_FAILED(DOMPointToOffset(parentNode, parentContent->IndexOf(childContent), &start)))
   1:     return NS_OK;
 582: 
 582:   nsCOMPtr<nsIAccessibleTextChangeEvent> event =
 582:     new nsAccTextChangeEvent(this, start, length, isInserted);
 582:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 582: 
 582:   return FireAccessibleEvent(event);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidDeleteNode(nsIDOMNode *aChild, nsresult aResult)
   1: {
   1:   return InvalidateChildren();
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillSplitNode(nsIDOMNode *aExistingRightNode, PRInt32 aOffset)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidSplitNode(nsIDOMNode *aExistingRightNode, PRInt32 aOffset,
   1:                                                   nsIDOMNode *aNewLeftNode, nsresult aResult)
   1: {
   1:   return InvalidateChildren();
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillJoinNodes(nsIDOMNode *aLeftNode,
   1:                                                    nsIDOMNode *aRightNode, nsIDOMNode *aParent)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidJoinNodes(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode,
   1:                                                   nsIDOMNode *aParent, nsresult aResult)
   1: {
   1:   return InvalidateChildren();
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillInsertText(nsIDOMCharacterData *aTextNode,
   1:                                                     PRInt32 aOffset, const nsAString& aString)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset,
   1:                                                    const nsAString& aString, nsresult aResult)
   1: {
 582:   PRInt32 start;
 582:   PRUint32 length = aString.Length();
 582:   PRBool isInserted = PR_TRUE;
   1: 
 582:   if (NS_FAILED(DOMPointToOffset(aTextNode, aOffset, &start)))
   1:     return NS_OK;
 582: 
 582:   nsCOMPtr<nsIAccessibleTextChangeEvent> event =
 582:     new nsAccTextChangeEvent(this, start, length, isInserted);
 582:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 582: 
 582:   return FireAccessibleEvent(event);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillDeleteText(nsIDOMCharacterData *aTextNode,
   1:                                                     PRInt32 aOffset, PRInt32 aLength)
   1: {
 582:   PRInt32 start;
 582:   PRUint32 length = aLength;
 582:   PRBool isInserted = PR_FALSE;
   1: 
 582:   if (NS_FAILED(DOMPointToOffset(aTextNode, aOffset, &start)))
   1:     return NS_OK;
 582: 
 582:   nsCOMPtr<nsIAccessibleTextChangeEvent> event =
 582:     new nsAccTextChangeEvent(this, start, length, isInserted);
 582:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 582: 
 582:   return FireAccessibleEvent(event);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset,
   1:                                                    PRInt32 aLength, nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::WillDeleteSelection(nsISelection *aSelection)
   1: // <input> & <textarea> fires this event while deleting text
   1: // <editor> fires WillDeleteText/WillDeleteNode instead
   1: // XXX Deal with > 1 selections
   1: {
   1:   PRInt32 selectionStart, selectionEnd;
   1:   GetSelectionBounds(0, &selectionStart, &selectionEnd);
   1: 
 582:   PRInt32 start = PR_MIN(selectionStart, selectionEnd);;
 582:   PRUint32 length = PR_ABS(selectionEnd - selectionStart);
 582:   PRBool isInserted = PR_FALSE;
   1: 
 582:   nsCOMPtr<nsIAccessibleTextChangeEvent> event =
 582:     new nsAccTextChangeEvent(this, start, length, isInserted);
 582:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
 582: 
 582:   return FireAccessibleEvent(event);
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::DidDeleteSelection(nsISelection *aSelection)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * =================== Caret & Selection ======================
   1:   */
   1: 
   1: nsresult nsHyperTextAccessible::SetSelectionRange(PRInt32 aStartPos, PRInt32 aEndPos)
   1: {
   1:   // Set the selection
   1:   nsresult rv = SetSelectionBounds(0, aStartPos, aEndPos);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // If range 0 was successfully set, clear any additional selection 
   1:   // ranges remaining from previous selection
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsCOMPtr<nsISelectionController> selCon;
   1:   GetSelections(getter_AddRefs(selCon), getter_AddRefs(domSel));
   1:   if (domSel) {
   1:     PRInt32 numRanges;
   1:     domSel->GetRangeCount(&numRanges);
   1: 
   1:     for (PRInt32 count = 0; count < numRanges - 1; count ++) {
   1:       nsCOMPtr<nsIDOMRange> range;
   1:       domSel->GetRangeAt(1, getter_AddRefs(range));
   1:       domSel->RemoveRange(range);
   1:     }
   1:   }
   1:   
   1:   if (selCon) {
   1:     selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
   1:        nsISelectionController::SELECTION_FOCUS_REGION, PR_TRUE);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsHyperTextAccessible::SetCaretOffset(PRInt32 aCaretOffset)
   1: {
   1:   return SetSelectionRange(aCaretOffset, aCaretOffset);
   1: }
   1: 
   1: /*
   1:  * Gets the offset position of the caret (cursor).
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetCaretOffset(PRInt32 *aCaretOffset)
   1: {
   1:   *aCaretOffset = 0;
   1: 
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> caretNode;
   1:   rv = domSel->GetFocusNode(getter_AddRefs(caretNode));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 caretOffset;
   1:   domSel->GetFocusOffset(&caretOffset);
   1: 
   1:   return DOMPointToOffset(caretNode, caretOffset, aCaretOffset);
   1: }
   1: 
   1: nsresult nsHyperTextAccessible::GetSelections(nsISelectionController **aSelCon, nsISelection **aDomSel)
   1: {
   1:   if (aSelCon) {
   1:     *aSelCon = nsnull;
   1:   }
   1:   if (aDomSel) {
   1:     *aDomSel = nsnull;
   1:   }
   1:   
   1:   nsCOMPtr<nsIEditor> editor = GetEditor();
   1:   if (editor) {
   1:     if (aSelCon) {
   1:       editor->GetSelectionController(aSelCon);
   1:       NS_ENSURE_TRUE(*aSelCon, NS_ERROR_FAILURE);
   1:     }
   1: 
   1:     if (aDomSel) {
   1:       editor->GetSelection(aDomSel);
   1:       NS_ENSURE_TRUE(*aDomSel, NS_ERROR_FAILURE);
   1:     }
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsIFrame *frame = GetFrame();
   1:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
   1: 
   1:   // Get the selection and selection controller
   1:   nsCOMPtr<nsISelectionController> selCon;
   1:   frame->GetSelectionController(GetPresContext(),
   1:                                 getter_AddRefs(selCon));
   1:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
   1:   if (aSelCon) {
   1:     NS_ADDREF(*aSelCon = selCon);
   1:   }
   1: 
   1:   if (aDomSel) {
   1:     nsCOMPtr<nsISelection> domSel;
   1:     selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel));
   1:     NS_ENSURE_TRUE(domSel, NS_ERROR_FAILURE);
   1:     NS_ADDREF(*aDomSel = domSel);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /*
   1:  * Gets the number of selected regions.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
   1: {
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRBool isSelectionCollapsed;
   1:   rv = domSel->GetIsCollapsed(&isSelectionCollapsed);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (isSelectionCollapsed) {
   1:     *aSelectionCount = 0;
   1:     return NS_OK;
   1:   }
   1:   return domSel->GetRangeCount(aSelectionCount);
   1: }
   1: 
   1: /*
   1:  * Gets the start and end offset of the specified selection.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::GetSelectionBounds(PRInt32 aSelectionNum, PRInt32 *aStartOffset, PRInt32 *aEndOffset)
   1: {
   1:   *aStartOffset = *aEndOffset = 0;
   1: 
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 rangeCount;
   1:   domSel->GetRangeCount(&rangeCount);
   1:   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   nsCOMPtr<nsIDOMRange> range;
   1:   rv = domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> startNode;
   1:   range->GetStartContainer(getter_AddRefs(startNode));
   1:   PRInt32 startOffset;
   1:   range->GetStartOffset(&startOffset);
   1:   rv = DOMPointToOffset(startNode, startOffset, aStartOffset);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> endNode;
   1:   range->GetEndContainer(getter_AddRefs(endNode));
   1:   PRInt32 endOffset;
   1:   range->GetEndOffset(&endOffset);
   1:   if (startNode == endNode && startOffset == endOffset) {
   1:     // Shortcut for collapsed selection case (caret)
   1:     *aEndOffset = *aStartOffset;
   1:     return NS_OK;
   1:   }
   1:   return DOMPointToOffset(endNode, endOffset, aEndOffset);
   1: }
   1: 
   1: /*
   1:  * Changes the start and end offset of the specified selection.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::SetSelectionBounds(PRInt32 aSelectionNum, PRInt32 aStartOffset, PRInt32 aEndOffset)
   1: {
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 isOnlyCaret = (aStartOffset == aEndOffset); // Caret is a collapsed selection
   1: 
   1:   PRInt32 rangeCount;
   1:   domSel->GetRangeCount(&rangeCount);
   1:   nsCOMPtr<nsIDOMRange> range;
   1:   if (aSelectionNum == rangeCount) { // Add a range
   1:     range = do_CreateInstance(kRangeCID);
   1:     NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
   1:   }
   1:   else if (aSelectionNum < 0 || aSelectionNum > rangeCount) {
   1:     return NS_ERROR_INVALID_ARG;
   1:   }
   1:   else {
   1:     domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
   1:     NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
   1:   }
   1: 
   1:   nsIFrame *endFrame;
   1:   nsIFrame *startFrame = GetPosAndText(aStartOffset, aEndOffset, nsnull, &endFrame);
   1:   NS_ENSURE_TRUE(startFrame, NS_ERROR_FAILURE);
   1: 
   1:   nsIContent *startParentContent = startFrame->GetContent();
   1:   if (startFrame->GetType() != nsAccessibilityAtoms::textFrame) {
   1:     nsIContent *newParent = startParentContent->GetParent();
   1:     aStartOffset = newParent->IndexOf(startParentContent);
   1:     startParentContent = newParent;
   1:   }
   1:   nsCOMPtr<nsIDOMNode> startParentNode(do_QueryInterface(startParentContent));
   1:   NS_ENSURE_TRUE(startParentNode, NS_ERROR_FAILURE);
   1:   rv = range->SetStart(startParentNode, aStartOffset);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (isOnlyCaret) { 
   1:     rv = range->Collapse(PR_TRUE);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1:   else {
   1:     nsIContent *endParentContent = endFrame->GetContent();
   1:     if (endFrame->GetType() != nsAccessibilityAtoms::textFrame) {
   1:       nsIContent *newParent = endParentContent->GetParent();
   1:       aEndOffset = newParent->IndexOf(endParentContent);
   1:       endParentContent = newParent;
   1:     }
   1:     nsCOMPtr<nsIDOMNode> endParentNode(do_QueryInterface(endParentContent));
   1:     NS_ENSURE_TRUE(endParentNode, NS_ERROR_FAILURE);
   1:     rv = range->SetEnd(endParentNode, aEndOffset);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   if (aSelectionNum == rangeCount) { // Add successfully created new range
   1:     return domSel->AddRange(range);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /*
   1:  * Adds a selection bounded by the specified offsets.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::AddSelection(PRInt32 aStartOffset, PRInt32 aEndOffset)
   1: {
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 rangeCount;
   1:   domSel->GetRangeCount(&rangeCount);
   1: 
   1:   return SetSelectionBounds(rangeCount, aStartOffset, aEndOffset);
   1: }
   1: 
   1: /*
   1:  * Removes the specified selection.
   1:  */
   1: NS_IMETHODIMP nsHyperTextAccessible::RemoveSelection(PRInt32 aSelectionNum)
   1: {
   1:   nsCOMPtr<nsISelection> domSel;
   1:   nsresult rv = GetSelections(nsnull, getter_AddRefs(domSel));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 rangeCount;
   1:   domSel->GetRangeCount(&rangeCount);
   1:   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   nsCOMPtr<nsIDOMRange> range;
   1:   domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
   1:   return domSel->RemoveRange(range);
   1: }
   1: 
