    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
17947:  * vim: set sw=4 ts=8 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS bytecode descriptors, disassemblers, and decompilers.
    1:  */
    1: #include "jsstddef.h"
    1: #ifdef HAVE_MEMORY_H
    1: #include <memory.h>
    1: #endif
    1: #include <stdarg.h>
    1: #include <stdio.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsdtoa.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
15613: #include "jsiter.h"
20908: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsregexp.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
21459: #include "jstracer.h"
    1: 
15453: #include "jsautooplen.h"
15453: 
15453: /* Verify JSOP_XXX_LENGTH constant definitions. */
15453: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)               \
15453:     JS_STATIC_ASSERT(op##_LENGTH == length);
15453: #include "jsopcode.tbl"
15453: #undef OPDEF
15453: 
    1: static const char js_incop_strs[][3] = {"++", "--"};
20943: static const char js_for_each_str[]  = "for each";
    1: 
 1154: const JSCodeSpec js_CodeSpec[] = {
    1: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
 1154:     {length,nuses,ndefs,prec,format},
    1: #include "jsopcode.tbl"
    1: #undef OPDEF
    1: };
    1: 
 1154: uintN js_NumCodeSpecs = JS_ARRAY_LENGTH(js_CodeSpec);
 1154: 
 1154: /*
 1154:  * Each element of the array is either a source literal associated with JS
 1154:  * bytecode or null.
 1154:  */
 1154: static const char *CodeToken[] = {
 1154: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
 1154:     token,
 1154: #include "jsopcode.tbl"
 1154: #undef OPDEF
 1154: };
 1154: 
21459: #if defined(DEBUG) || defined(JS_JIT_SPEW)
 1154: /*
21459:  * Array of JS bytecode names used by DEBUG-only js_Disassemble and by
21459:  * JIT debug spew.
 1154:  */
12410: const char *js_CodeName[] = {
 1154: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
 1154:     name,
 1154: #include "jsopcode.tbl"
 1154: #undef OPDEF
 1154: };
 1154: #endif
    1: 
    1: /************************************************************************/
    1: 
    1: static ptrdiff_t
    1: GetJumpOffset(jsbytecode *pc, jsbytecode *pc2)
    1: {
    1:     uint32 type;
    1: 
11377:     type = JOF_OPTYPE(*pc);
    1:     if (JOF_TYPE_IS_EXTENDED_JUMP(type))
    1:         return GET_JUMPX_OFFSET(pc2);
    1:     return GET_JUMP_OFFSET(pc2);
    1: }
    1: 
 3235: uintN
11813: js_GetIndexFromBytecode(JSContext *cx, JSScript *script, jsbytecode *pc,
11813:                         ptrdiff_t pcoff)
    1: {
    1:     JSOp op;
 3235:     uintN span, base;
    1: 
    1:     op = (JSOp)*pc;
11813:     if (op == JSOP_TRAP)
11813:         op = JS_GetTrapOpcode(cx, script, pc);
 3235:     JS_ASSERT(js_CodeSpec[op].length >= 1 + pcoff + UINT16_LEN);
    1: 
    1:     /*
 3235:      * We need to detect index base prefix. It presents when resetbase
    1:      * follows the bytecode.
    1:      */
    1:     span = js_CodeSpec[op].length;
 3235:     base = 0;
    1:     if (pc - script->code + span < script->length) {
    1:         if (pc[span] == JSOP_RESETBASE) {
 3235:             base = GET_INDEXBASE(pc - JSOP_INDEXBASE_LENGTH);
    1:         } else if (pc[span] == JSOP_RESETBASE0) {
 3235:             JS_ASSERT(JSOP_INDEXBASE1 <= pc[-1] || pc[-1] <= JSOP_INDEXBASE3);
 3235:             base = (pc[-1] - JSOP_INDEXBASE1 + 1) << 16;
 3235:         }
 3235:     }
 3235:     return base + GET_UINT16(pc + pcoff);
    1: }
    1: 
16072: uintN
16072: js_GetVariableBytecodeLength(jsbytecode *pc)
16072: {
16072:     JSOp op;
16072:     uintN jmplen, ncases;
16072:     jsint low, high;
16072: 
16072:     op = (JSOp) *pc;
16072:     JS_ASSERT(js_CodeSpec[op].length == -1);
16072:     switch (op) {
16072:       case JSOP_TABLESWITCHX:
16072:         jmplen = JUMPX_OFFSET_LEN;
16072:         goto do_table;
16072:       case JSOP_TABLESWITCH:
16072:         jmplen = JUMP_OFFSET_LEN;
16072:       do_table:
16072:         /* Structure: default-jump case-low case-high case1-jump ... */
16072:         pc += jmplen;
16072:         low = GET_JUMP_OFFSET(pc);
16072:         pc += JUMP_OFFSET_LEN;
16072:         high = GET_JUMP_OFFSET(pc);
16072:         ncases = (uintN)(high - low + 1);
16072:         return 1 + jmplen + INDEX_LEN + INDEX_LEN + ncases * jmplen;
16072: 
16072:       case JSOP_LOOKUPSWITCHX:
16072:         jmplen = JUMPX_OFFSET_LEN;
16072:         goto do_lookup;
16072:       default:
16072:         JS_ASSERT(op == JSOP_LOOKUPSWITCH);
16072:         jmplen = JUMP_OFFSET_LEN;
16072:       do_lookup:
16072:         /* Structure: default-jump case-count (case1-value case1-jump) ... */
16072:         pc += jmplen;
16072:         ncases = GET_UINT16(pc);
16072:         return 1 + jmplen + INDEX_LEN + ncases * (INDEX_LEN + jmplen);
16072:     }
16072: }
16072: 
18567: uintN
18567: js_GetVariableStackUseLength(JSOp op, jsbytecode *pc)
18567: {
18567:     JS_ASSERT(*pc == op || *pc == JSOP_TRAP);
18567:     JS_ASSERT(js_CodeSpec[op].nuses == -1);
18567:     switch (op) {
18567:       case JSOP_POPN:
18567:         return GET_UINT16(pc);
18567:       case JSOP_LEAVEBLOCK:
18567:         return GET_UINT16(pc);
18567:       case JSOP_LEAVEBLOCKEXPR:
18567:         return GET_UINT16(pc) + 1;
18567:       case JSOP_NEWARRAY:
18567:         return GET_UINT24(pc);
18567:       default:
18567:         /* stack: fun, this, [argc arguments] */
18567:         JS_ASSERT(op == JSOP_NEW || op == JSOP_CALL ||
21452:                   op == JSOP_EVAL || op == JSOP_SETCALL ||
21452:                   op == JSOP_APPLY);
18567:         return 2 + GET_ARGC(pc);
18567:     }
18567: }
18567: 
    1: #ifdef DEBUG
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_Disassemble(JSContext *cx, JSScript *script, JSBool lines, FILE *fp)
    1: {
    1:     jsbytecode *pc, *end;
    1:     uintN len;
    1: 
    1:     pc = script->code;
    1:     end = pc + script->length;
    1:     while (pc < end) {
    1:         if (pc == script->main)
    1:             fputs("main:\n", fp);
    1:         len = js_Disassemble1(cx, script, pc,
    1:                               PTRDIFF(pc, script->code, jsbytecode),
    1:                               lines, fp);
    1:         if (!len)
    1:             return JS_FALSE;
    1:         pc += len;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: const char *
    1: ToDisassemblySource(JSContext *cx, jsval v)
    1: {
    1:     JSObject *obj;
    1:     JSScopeProperty *sprop;
    1:     char *source;
    1:     const char *bytes;
    1:     JSString *str;
    1: 
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         obj = JSVAL_TO_OBJECT(v);
    1:         if (OBJ_GET_CLASS(cx, obj) == &js_BlockClass) {
    1:             source = JS_sprintf_append(NULL, "depth %d {",
    1:                                        OBJ_BLOCK_DEPTH(cx, obj));
    1:             for (sprop = OBJ_SCOPE(obj)->lastProp; sprop;
    1:                  sprop = sprop->parent) {
    1:                 bytes = js_AtomToPrintableString(cx, JSID_TO_ATOM(sprop->id));
    1:                 if (!bytes)
    1:                     return NULL;
    1:                 source = JS_sprintf_append(source, "%s: %d%s",
    1:                                            bytes, sprop->shortid,
    1:                                            sprop->parent ? ", " : "");
    1:             }
    1:             source = JS_sprintf_append(source, "}");
    1:             if (!source)
    1:                 return NULL;
    1:             str = JS_NewString(cx, source, strlen(source));
    1:             if (!str)
    1:                 return NULL;
    1:             return js_GetStringBytes(cx, str);
    1:         }
    1:     }
    1:     return js_ValueToPrintableSource(cx, v);
    1: }
    1: 
    1: JS_FRIEND_API(uintN)
    1: js_Disassemble1(JSContext *cx, JSScript *script, jsbytecode *pc,
    1:                 uintN loc, JSBool lines, FILE *fp)
    1: {
    1:     JSOp op;
    1:     const JSCodeSpec *cs;
    1:     ptrdiff_t len, off, jmplen;
    1:     uint32 type;
    1:     JSAtom *atom;
 3235:     uintN index;
 3235:     JSObject *obj;
 3235:     jsval v;
    1:     const char *bytes;
 3328:     jsint i;
    1: 
    1:     op = (JSOp)*pc;
    1:     if (op >= JSOP_LIMIT) {
    1:         char numBuf1[12], numBuf2[12];
    1:         JS_snprintf(numBuf1, sizeof numBuf1, "%d", op);
    1:         JS_snprintf(numBuf2, sizeof numBuf2, "%d", JSOP_LIMIT);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BYTECODE_TOO_BIG, numBuf1, numBuf2);
    1:         return 0;
    1:     }
    1:     cs = &js_CodeSpec[op];
    1:     len = (ptrdiff_t) cs->length;
    1:     fprintf(fp, "%05u:", loc);
    1:     if (lines)
    1:         fprintf(fp, "%4u", JS_PCToLineNumber(cx, script, pc));
12410:     fprintf(fp, "  %s", js_CodeName[op]);
11377:     type = JOF_TYPE(cs->format);
    1:     switch (type) {
    1:       case JOF_BYTE:
    1:         if (op == JSOP_TRAP) {
    1:             op = JS_GetTrapOpcode(cx, script, pc);
    1:             len = (ptrdiff_t) js_CodeSpec[op].length;
    1:         }
    1:         break;
    1: 
    1:       case JOF_JUMP:
    1:       case JOF_JUMPX:
    1:         off = GetJumpOffset(pc, pc);
16275:         fprintf(fp, " %u (%d)", loc + (intN) off, (intN) off);
    1:         break;
    1: 
 4380:       case JOF_ATOM:
 3235:       case JOF_OBJECT:
 3235:       case JOF_REGEXP:
11813:         index = js_GetIndexFromBytecode(cx, script, pc, 0);
 4380:         if (type == JOF_ATOM) {
 3235:             JS_GET_SCRIPT_ATOM(script, index, atom);
 3235:             v = ATOM_KEY(atom);
 3235:         } else {
 3235:             if (type == JOF_OBJECT)
 3235:                 JS_GET_SCRIPT_OBJECT(script, index, obj);
 3235:             else
 3235:                 JS_GET_SCRIPT_REGEXP(script, index, obj);
 3235:             v = OBJECT_TO_JSVAL(obj);
 3235:         }
 3235:         bytes = ToDisassemblySource(cx, v);
    1:         if (!bytes)
    1:             return 0;
    1:         fprintf(fp, " %s", bytes);
    1:         break;
    1: 
    1:       case JOF_UINT16:
 3328:         i = (jsint)GET_UINT16(pc);
 3328:         goto print_int;
    1: 
    1:       case JOF_TABLESWITCH:
    1:       case JOF_TABLESWITCHX:
    1:       {
    1:         jsbytecode *pc2;
    1:         jsint i, low, high;
    1: 
    1:         jmplen = (type == JOF_TABLESWITCH) ? JUMP_OFFSET_LEN
    1:                                            : JUMPX_OFFSET_LEN;
    1:         pc2 = pc;
    1:         off = GetJumpOffset(pc, pc2);
    1:         pc2 += jmplen;
    1:         low = GET_JUMP_OFFSET(pc2);
    1:         pc2 += JUMP_OFFSET_LEN;
    1:         high = GET_JUMP_OFFSET(pc2);
    1:         pc2 += JUMP_OFFSET_LEN;
16275:         fprintf(fp, " defaultOffset %d low %d high %d", (intN) off, low, high);
    1:         for (i = low; i <= high; i++) {
    1:             off = GetJumpOffset(pc, pc2);
16275:             fprintf(fp, "\n\t%d: %d", i, (intN) off);
    1:             pc2 += jmplen;
    1:         }
    1:         len = 1 + pc2 - pc;
    1:         break;
    1:       }
    1: 
    1:       case JOF_LOOKUPSWITCH:
    1:       case JOF_LOOKUPSWITCHX:
    1:       {
    1:         jsbytecode *pc2;
    1:         jsatomid npairs;
    1: 
    1:         jmplen = (type == JOF_LOOKUPSWITCH) ? JUMP_OFFSET_LEN
    1:                                             : JUMPX_OFFSET_LEN;
    1:         pc2 = pc;
    1:         off = GetJumpOffset(pc, pc2);
    1:         pc2 += jmplen;
    1:         npairs = GET_UINT16(pc2);
    1:         pc2 += UINT16_LEN;
16275:         fprintf(fp, " offset %d npairs %u", (intN) off, (uintN) npairs);
    1:         while (npairs) {
 3235:             JS_GET_SCRIPT_ATOM(script, GET_INDEX(pc2), atom);
 3235:             pc2 += INDEX_LEN;
    1:             off = GetJumpOffset(pc, pc2);
    1:             pc2 += jmplen;
    1: 
    1:             bytes = ToDisassemblySource(cx, ATOM_KEY(atom));
    1:             if (!bytes)
    1:                 return 0;
16275:             fprintf(fp, "\n\t%s: %d", bytes, (intN) off);
    1:             npairs--;
    1:         }
    1:         len = 1 + pc2 - pc;
    1:         break;
    1:       }
    1: 
    1:       case JOF_QARG:
    1:         fprintf(fp, " %u", GET_ARGNO(pc));
    1:         break;
    1: 
16429:       case JOF_LOCAL:
16072:         fprintf(fp, " %u", GET_SLOTNO(pc));
    1:         break;
    1: 
 4380:       case JOF_SLOTATOM:
 4380:       case JOF_SLOTOBJECT:
16072:         fprintf(fp, " %u", GET_SLOTNO(pc));
16072:         index = js_GetIndexFromBytecode(cx, script, pc, SLOTNO_LEN);
 5923:         if (type == JOF_SLOTATOM) {
 3235:             JS_GET_SCRIPT_ATOM(script, index, atom);
 3235:             v = ATOM_KEY(atom);
 3235:         } else {
 3235:             JS_GET_SCRIPT_OBJECT(script, index, obj);
 3235:             v = OBJECT_TO_JSVAL(obj);
 3235:         }
 3235:         bytes = ToDisassemblySource(cx, v);
    1:         if (!bytes)
    1:             return 0;
    1:         fprintf(fp, " %s", bytes);
    1:         break;
    1: 
    1:       case JOF_UINT24:
15279:         JS_ASSERT(op == JSOP_UINT24 || op == JSOP_NEWARRAY);
 3328:         i = (jsint)GET_UINT24(pc);
 3328:         goto print_int;
 3328: 
17899:       case JOF_UINT8:
17899:         i = pc[1];
17899:         goto print_int;
17899: 
 3328:       case JOF_INT8:
 3328:         i = GET_INT8(pc);
 3328:         goto print_int;
 3328: 
 3328:       case JOF_INT32:
 3328:         JS_ASSERT(op == JSOP_INT32);
 3328:         i = GET_INT32(pc);
 3328:       print_int:
 3328:         fprintf(fp, " %d", i);
    1:         break;
    1: 
    1:       default: {
    1:         char numBuf[12];
    1:         JS_snprintf(numBuf, sizeof numBuf, "%lx", (unsigned long) cs->format);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_UNKNOWN_FORMAT, numBuf);
    1:         return 0;
    1:       }
    1:     }
    1:     fputs("\n", fp);
    1:     return len;
    1: }
    1: 
    1: #endif /* DEBUG */
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Sprintf, but with unlimited and automatically allocated buffering.
    1:  */
    1: typedef struct Sprinter {
    1:     JSContext       *context;       /* context executing the decompiler */
    1:     JSArenaPool     *pool;          /* string allocation pool */
    1:     char            *base;          /* base address of buffer in pool */
    1:     size_t          size;           /* size of buffer allocated at base */
    1:     ptrdiff_t       offset;         /* offset of next free char in buffer */
    1: } Sprinter;
    1: 
    1: #define INIT_SPRINTER(cx, sp, ap, off) \
    1:     ((sp)->context = cx, (sp)->pool = ap, (sp)->base = NULL, (sp)->size = 0,  \
    1:      (sp)->offset = off)
    1: 
    1: #define OFF2STR(sp,off) ((sp)->base + (off))
    1: #define STR2OFF(sp,str) ((str) - (sp)->base)
    1: #define RETRACT(sp,str) ((sp)->offset = STR2OFF(sp, str))
    1: 
    1: static JSBool
 1857: SprintEnsureBuffer(Sprinter *sp, size_t len)
    1: {
 1857:     ptrdiff_t nb;
 5269:     char *base;
 1857: 
 1857:     nb = (sp->offset + len + 1) - sp->size;
 1857:     if (nb < 0)
 1857:         return JS_TRUE;
 5269:     base = sp->base;
 5269:     if (!base) {
 5269:         JS_ARENA_ALLOCATE_CAST(base, char *, sp->pool, nb);
    1:     } else {
 5269:         JS_ARENA_GROW_CAST(base, char *, sp->pool, sp->size, nb);
 5269:     }
 5269:     if (!base) {
 8296:         js_ReportOutOfScriptQuota(sp->context);
    1:         return JS_FALSE;
    1:     }
 5269:     sp->base = base;
    1:     sp->size += nb;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static ptrdiff_t
    1: SprintPut(Sprinter *sp, const char *s, size_t len)
    1: {
 1857:     ptrdiff_t offset;
    1:     char *bp;
    1: 
    1:     /* Allocate space for s, including the '\0' at the end. */
 1857:     if (!SprintEnsureBuffer(sp, len))
    1:         return -1;
    1: 
    1:     /* Advance offset and copy s into sp's buffer. */
    1:     offset = sp->offset;
    1:     sp->offset += len;
    1:     bp = sp->base + offset;
    1:     memmove(bp, s, len);
    1:     bp[len] = 0;
    1:     return offset;
    1: }
    1: 
    1: static ptrdiff_t
    1: SprintCString(Sprinter *sp, const char *s)
    1: {
    1:     return SprintPut(sp, s, strlen(s));
    1: }
    1: 
    1: static ptrdiff_t
    1: SprintString(Sprinter *sp, JSString *str)
    1: {
    1:     jschar *chars;
    1:     size_t length, size;
    1:     ptrdiff_t offset;
    1: 
 4718:     JSSTRING_CHARS_AND_LENGTH(str, chars, length);
    1:     if (length == 0)
    1:         return sp->offset;
    1: 
    1:     size = js_GetDeflatedStringLength(sp->context, chars, length);
 1857:     if (size == (size_t)-1 || !SprintEnsureBuffer(sp, size))
    1:         return -1;
    1: 
    1:     offset = sp->offset;
    1:     sp->offset += size;
    1:     js_DeflateStringToBuffer(sp->context, chars, length, sp->base + offset,
    1:                              &size);
    1:     sp->base[sp->offset] = 0;
    1:     return offset;
    1: }
    1: 
    1: 
    1: static ptrdiff_t
    1: Sprint(Sprinter *sp, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     char *bp;
    1:     ptrdiff_t offset;
    1: 
    1:     va_start(ap, format);
    1:     bp = JS_vsmprintf(format, ap);      /* XXX vsaprintf */
    1:     va_end(ap);
    1:     if (!bp) {
    1:         JS_ReportOutOfMemory(sp->context);
    1:         return -1;
    1:     }
    1:     offset = SprintCString(sp, bp);
    1:     free(bp);
    1:     return offset;
    1: }
    1: 
    1: const char js_EscapeMap[] = {
    1:     '\b', 'b',
    1:     '\f', 'f',
    1:     '\n', 'n',
    1:     '\r', 'r',
    1:     '\t', 't',
    1:     '\v', 'v',
    1:     '"',  '"',
    1:     '\'', '\'',
    1:     '\\', '\\',
 5969:     '\0', '0'
    1: };
    1: 
    1: #define DONT_ESCAPE     0x10000
    1: 
    1: static char *
    1: QuoteString(Sprinter *sp, JSString *str, uint32 quote)
    1: {
    1:     JSBool dontEscape, ok;
    1:     jschar qc, c;
 1857:     ptrdiff_t off, len;
    1:     const jschar *s, *t, *z;
    1:     const char *e;
    1:     char *bp;
    1: 
    1:     /* Sample off first for later return value pointer computation. */
    1:     dontEscape = (quote & DONT_ESCAPE) != 0;
    1:     qc = (jschar) quote;
    1:     off = sp->offset;
    1:     if (qc && Sprint(sp, "%c", (char)qc) < 0)
    1:         return NULL;
    1: 
    1:     /* Loop control variables: z points at end of string sentinel. */
 4718:     JSSTRING_CHARS_AND_END(str, s, z);
    1:     for (t = s; t < z; s = ++t) {
    1:         /* Move t forward from s past un-quote-worthy characters. */
    1:         c = *t;
 2311:         while (JS_ISPRINT(c) && c != qc && c != '\\' && c != '\t' &&
 2311:                !(c >> 8)) {
    1:             c = *++t;
    1:             if (t == z)
    1:                 break;
    1:         }
    1:         len = PTRDIFF(t, s, jschar);
    1: 
    1:         /* Allocate space for s, including the '\0' at the end. */
 1857:         if (!SprintEnsureBuffer(sp, len))
    1:             return NULL;
    1: 
    1:         /* Advance sp->offset and copy s into sp's buffer. */
    1:         bp = sp->base + sp->offset;
    1:         sp->offset += len;
    1:         while (--len >= 0)
    1:             *bp++ = (char) *s++;
    1:         *bp = '\0';
    1: 
    1:         if (t == z)
    1:             break;
    1: 
    1:         /* Use js_EscapeMap, \u, or \x only if necessary. */
    1:         if (!(c >> 8) && (e = strchr(js_EscapeMap, (int)c)) != NULL) {
    1:             ok = dontEscape
    1:                  ? Sprint(sp, "%c", (char)c) >= 0
    1:                  : Sprint(sp, "\\%c", e[1]) >= 0;
    1:         } else {
    1:             ok = Sprint(sp, (c >> 8) ? "\\u%04X" : "\\x%02X", c) >= 0;
    1:         }
    1:         if (!ok)
    1:             return NULL;
    1:     }
    1: 
    1:     /* Sprint the closing quote and return the quoted string. */
    1:     if (qc && Sprint(sp, "%c", (char)qc) < 0)
    1:         return NULL;
    1: 
    1:     /*
    1:      * If we haven't Sprint'd anything yet, Sprint an empty string so that
    1:      * the OFF2STR below gives a valid result.
    1:      */
    1:     if (off == sp->offset && Sprint(sp, "") < 0)
    1:         return NULL;
    1:     return OFF2STR(sp, off);
    1: }
    1: 
    1: JSString *
    1: js_QuoteString(JSContext *cx, JSString *str, jschar quote)
    1: {
    1:     void *mark;
    1:     Sprinter sprinter;
    1:     char *bytes;
    1:     JSString *escstr;
    1: 
    1:     mark = JS_ARENA_MARK(&cx->tempPool);
    1:     INIT_SPRINTER(cx, &sprinter, &cx->tempPool, 0);
    1:     bytes = QuoteString(&sprinter, str, quote);
    1:     escstr = bytes ? JS_NewStringCopyZ(cx, bytes) : NULL;
    1:     JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:     return escstr;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: struct JSPrinter {
    1:     Sprinter        sprinter;       /* base class state */
    1:     JSArenaPool     pool;           /* string allocation pool */
    1:     uintN           indent;         /* indentation in spaces */
    1:     JSPackedBool    pretty;         /* pretty-print: indent, use newlines */
    1:     JSPackedBool    grouped;        /* in parenthesized expression context */
    1:     JSScript        *script;        /* script being printed */
12981:     jsbytecode      *dvgfence;      /* DecompileExpression fencepost */
21808:     jsbytecode      **pcstack;      /* DecompileExpression modeled stack */
13702:     JSFunction      *fun;           /* interpreted function */
11435:     jsuword         *localNames;    /* argument and variable names */
    1: };
    1: 
    1: /*
    1:  * Hack another flag, a la JS_DONT_PRETTY_PRINT, into uintN indent parameters
    1:  * to functions such as js_DecompileFunction and js_NewPrinter.  This time, as
    1:  * opposed to JS_DONT_PRETTY_PRINT back in the dark ages, we can assume that a
    1:  * uintN is at least 32 bits.
    1:  */
    1: #define JS_IN_GROUP_CONTEXT 0x10000
    1: 
    1: JSPrinter *
13702: JS_NEW_PRINTER(JSContext *cx, const char *name, JSFunction *fun,
13702:                uintN indent, JSBool pretty)
    1: {
    1:     JSPrinter *jp;
    1: 
    1:     jp = (JSPrinter *) JS_malloc(cx, sizeof(JSPrinter));
    1:     if (!jp)
    1:         return NULL;
    1:     INIT_SPRINTER(cx, &jp->sprinter, &jp->pool, 0);
 5344:     JS_INIT_ARENA_POOL(&jp->pool, name, 256, 1, &cx->scriptStackQuota);
    1:     jp->indent = indent & ~JS_IN_GROUP_CONTEXT;
    1:     jp->pretty = pretty;
    1:     jp->grouped = (indent & JS_IN_GROUP_CONTEXT) != 0;
    1:     jp->script = NULL;
    1:     jp->dvgfence = NULL;
12981:     jp->pcstack = NULL;
13702:     jp->fun = fun;
 8179:     jp->localNames = NULL;
13702:     if (fun && FUN_INTERPRETED(fun) && JS_GET_LOCAL_NAME_COUNT(fun)) {
13702:         jp->localNames = js_GetLocalNameArray(cx, fun, &jp->pool);
13702:         if (!jp->localNames) {
13702:             js_DestroyPrinter(jp);
13702:             return NULL;
13702:         }
13702:     }
    1:     return jp;
    1: }
    1: 
    1: void
    1: js_DestroyPrinter(JSPrinter *jp)
    1: {
    1:     JS_FinishArenaPool(&jp->pool);
    1:     JS_free(jp->sprinter.context, jp);
    1: }
    1: 
    1: JSString *
    1: js_GetPrinterOutput(JSPrinter *jp)
    1: {
    1:     JSContext *cx;
    1:     JSString *str;
    1: 
    1:     cx = jp->sprinter.context;
    1:     if (!jp->sprinter.base)
    1:         return cx->runtime->emptyString;
    1:     str = JS_NewStringCopyZ(cx, jp->sprinter.base);
    1:     if (!str)
    1:         return NULL;
    1:     JS_FreeArenaPool(&jp->pool);
    1:     INIT_SPRINTER(cx, &jp->sprinter, &jp->pool, 0);
    1:     return str;
    1: }
    1: 
 2016: /*
 2016:  * NB: Indexed by SRC_DECL_* defines from jsemit.h.
 2016:  */
 2016: static const char * const var_prefix[] = {"var ", "const ", "let "};
 2016: 
 2016: static const char *
 2016: VarPrefix(jssrcnote *sn)
 2016: {
 2016:     if (sn && (SN_TYPE(sn) == SRC_DECL || SN_TYPE(sn) == SRC_GROUPASSIGN)) {
 2016:         ptrdiff_t type = js_GetSrcNoteOffset(sn, 0);
 2016:         if ((uintN)type <= SRC_DECL_LET)
 2016:             return var_prefix[type];
 2016:     }
 2016:     return "";
 2016: }
 2016: 
    1: int
    1: js_printf(JSPrinter *jp, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     char *bp, *fp;
    1:     int cc;
    1: 
    1:     if (*format == '\0')
    1:         return 0;
    1: 
    1:     va_start(ap, format);
    1: 
    1:     /* If pretty-printing, expand magic tab into a run of jp->indent spaces. */
    1:     if (*format == '\t') {
    1:         format++;
    1:         if (jp->pretty && Sprint(&jp->sprinter, "%*s", jp->indent, "") < 0)
    1:             return -1;
    1:     }
    1: 
    1:     /* Suppress newlines (must be once per format, at the end) if not pretty. */
    1:     fp = NULL;
    1:     if (!jp->pretty && format[cc = strlen(format) - 1] == '\n') {
    1:         fp = JS_strdup(jp->sprinter.context, format);
    1:         if (!fp)
    1:             return -1;
    1:         fp[cc] = '\0';
    1:         format = fp;
    1:     }
    1: 
    1:     /* Allocate temp space, convert format, and put. */
    1:     bp = JS_vsmprintf(format, ap);      /* XXX vsaprintf */
    1:     if (fp) {
    1:         JS_free(jp->sprinter.context, fp);
    1:         format = NULL;
    1:     }
    1:     if (!bp) {
    1:         JS_ReportOutOfMemory(jp->sprinter.context);
    1:         return -1;
    1:     }
    1: 
    1:     cc = strlen(bp);
    1:     if (SprintPut(&jp->sprinter, bp, (size_t)cc) < 0)
    1:         cc = -1;
    1:     free(bp);
    1: 
    1:     va_end(ap);
    1:     return cc;
    1: }
    1: 
    1: JSBool
    1: js_puts(JSPrinter *jp, const char *s)
    1: {
    1:     return SprintCString(&jp->sprinter, s) >= 0;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: typedef struct SprintStack {
    1:     Sprinter    sprinter;       /* sprinter for postfix to infix buffering */
    1:     ptrdiff_t   *offsets;       /* stack of postfix string offsets */
    1:     jsbytecode  *opcodes;       /* parallel stack of JS opcodes */
    1:     uintN       top;            /* top of stack index */
    1:     uintN       inArrayInit;    /* array initialiser/comprehension level */
 1577:     JSBool      inGenExp;       /* in generator expression */
    1:     JSPrinter   *printer;       /* permanent output goes here */
    1: } SprintStack;
    1: 
    1: /*
12981:  * Find the depth of the operand stack when the interpreter reaches the given
12981:  * pc in script. pcstack must have space for least script->depth elements. On
12981:  * return it will contain pointers to opcodes that populated the interpreter's
12981:  * current operand stack.
12981:  *
12981:  * This function cannot raise an exception or error. However, due to a risk of
12981:  * potential bugs when modeling the stack, the function returns -1 if it
12981:  * detects an inconsistency in the model. Such an inconsistency triggers an
12981:  * assert in a debug build.
12981:  */
12981: static intN
12981: ReconstructPCStack(JSContext *cx, JSScript *script, jsbytecode *pc,
12981:                    jsbytecode **pcstack);
12981: 
12981: #define FAILED_EXPRESSION_DECOMPILER ((char *) 1)
12981: 
12981: /*
12981:  * Decompile a part of expression up to the given pc. The function returns
12981:  * NULL on out-of-memory, or the FAILED_EXPRESSION_DECOMPILER sentinel when
12981:  * the decompiler fails due to a bug and/or unimplemented feature, or the
12981:  * decompiled string on success.
12981:  */
12981: static char *
13702: DecompileExpression(JSContext *cx, JSScript *script, JSFunction *fun,
12981:                     jsbytecode *pc);
12981: 
12981: /*
    1:  * Get a stacked offset from ss->sprinter.base, or if the stacked value |off|
12981:  * is negative, fetch the generating pc from printer->pcstack[-2 - off] and
12981:  * decompile the code that generated the missing value.  This is used when
    1:  * reporting errors, where the model stack will lack |pcdepth| non-negative
12981:  * offsets (see DecompileExpression and DecompileCode).
    1:  *
    1:  * If the stacked offset is -1, return 0 to index the NUL padding at the start
    1:  * of ss->sprinter.base.  If this happens, it means there is a decompiler bug
    1:  * to fix, but it won't violate memory safety.
    1:  */
    1: static ptrdiff_t
    1: GetOff(SprintStack *ss, uintN i)
    1: {
    1:     ptrdiff_t off;
12981:     jsbytecode *pc;
    1:     char *bytes;
    1: 
    1:     off = ss->offsets[i];
12981:     if (off >= 0)
12981:         return off;
12981: 
12981:     JS_ASSERT(off <= -2);
12981:     JS_ASSERT(ss->printer->pcstack);
12981:     if (off < -2 && ss->printer->pcstack) {
12981:         pc = ss->printer->pcstack[-2 - off];
12981:         bytes = DecompileExpression(ss->sprinter.context, ss->printer->script,
12981:                                     ss->printer->fun, pc);
    1:         if (!bytes)
    1:             return 0;
12981:         if (bytes != FAILED_EXPRESSION_DECOMPILER) {
    1:             off = SprintCString(&ss->sprinter, bytes);
    1:             if (off < 0)
    1:                 off = 0;
    1:             ss->offsets[i] = off;
    1:             JS_free(ss->sprinter.context, bytes);
    1:             return off;
    1:         }
12981:         if (!ss->sprinter.base && SprintPut(&ss->sprinter, "", 0) >= 0) {
12981:             memset(ss->sprinter.base, 0, ss->sprinter.offset);
12981:             ss->offsets[i] = -1;
12981:         }
12981:     }
12981:     return 0;
12981: }
    1: 
    1: static const char *
    1: GetStr(SprintStack *ss, uintN i)
    1: {
    1:     ptrdiff_t off;
    1: 
    1:     /*
    1:      * Must call GetOff before using ss->sprinter.base, since it may be null
    1:      * until bootstrapped by GetOff.
    1:      */
    1:     off = GetOff(ss, i);
    1:     return OFF2STR(&ss->sprinter, off);
    1: }
    1: 
15279: /*
15279:  * Gap between stacked strings to allow for insertion of parens and commas
15279:  * when auto-parenthesizing expressions and decompiling array initialisers
15279:  * (see the JSOP_NEWARRAY case in Decompile).
15279:  */
    1: #define PAREN_SLOP      (2 + 1)
    1: 
    1: /*
    1:  * These pseudo-ops help js_DecompileValueGenerator decompile JSOP_SETNAME,
    1:  * JSOP_SETPROP, and JSOP_SETELEM, respectively.  They are never stored in
    1:  * bytecode, so they don't preempt valid opcodes.
    1:  */
    1: #define JSOP_GETPROP2   256
    1: #define JSOP_GETELEM2   257
    1: 
 1577: static void
 1577: AddParenSlop(SprintStack *ss)
 1577: {
 1577:     memset(OFF2STR(&ss->sprinter, ss->sprinter.offset), 0, PAREN_SLOP);
 1577:     ss->sprinter.offset += PAREN_SLOP;
 1577: }
 1577: 
    1: static JSBool
    1: PushOff(SprintStack *ss, ptrdiff_t off, JSOp op)
    1: {
    1:     uintN top;
    1: 
 1857:     if (!SprintEnsureBuffer(&ss->sprinter, PAREN_SLOP))
    1:         return JS_FALSE;
    1: 
    1:     /* ss->top points to the next free slot; be paranoid about overflow. */
    1:     top = ss->top;
16072:     JS_ASSERT(top < StackDepth(ss->printer->script));
16072:     if (top >= StackDepth(ss->printer->script)) {
    1:         JS_ReportOutOfMemory(ss->sprinter.context);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* The opcodes stack must contain real bytecodes that index js_CodeSpec. */
    1:     ss->offsets[top] = off;
    1:     ss->opcodes[top] = (op == JSOP_GETPROP2) ? JSOP_GETPROP
    1:                      : (op == JSOP_GETELEM2) ? JSOP_GETELEM
    1:                      : (jsbytecode) op;
    1:     ss->top = ++top;
 1577:     AddParenSlop(ss);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static ptrdiff_t
20928: PopOffPrec(SprintStack *ss, uint8 prec)
    1: {
    1:     uintN top;
20928:     const JSCodeSpec *topcs;
    1:     ptrdiff_t off;
    1: 
    1:     /* ss->top points to the next free slot; be paranoid about underflow. */
    1:     top = ss->top;
    1:     JS_ASSERT(top != 0);
    1:     if (top == 0)
    1:         return 0;
    1: 
    1:     ss->top = --top;
    1:     off = GetOff(ss, top);
    1:     topcs = &js_CodeSpec[ss->opcodes[top]];
20928:     if (topcs->prec != 0 && topcs->prec < prec) {
    1:         ss->sprinter.offset = ss->offsets[top] = off - 2;
    1:         off = Sprint(&ss->sprinter, "(%s)", OFF2STR(&ss->sprinter, off));
    1:     } else {
    1:         ss->sprinter.offset = off;
    1:     }
    1:     return off;
    1: }
    1: 
    1: static const char *
20928: PopStrPrec(SprintStack *ss, uint8 prec)
20928: {
20928:     ptrdiff_t off;
20928: 
20928:     off = PopOffPrec(ss, prec);
20928:     return OFF2STR(&ss->sprinter, off);
20928: }
20928: 
20928: static ptrdiff_t
20928: PopOff(SprintStack *ss, JSOp op)
20928: {
20928:     return PopOffPrec(ss, js_CodeSpec[op].prec);
20928: }
20928: 
20928: static const char *
    1: PopStr(SprintStack *ss, JSOp op)
    1: {
20928:     return PopStrPrec(ss, js_CodeSpec[op].prec);
    1: }
    1: 
    1: typedef struct TableEntry {
    1:     jsval       key;
    1:     ptrdiff_t   offset;
    1:     JSAtom      *label;
    1:     jsint       order;          /* source order for stable tableswitch sort */
    1: } TableEntry;
    1: 
    1: static JSBool
    1: CompareOffsets(void *arg, const void *v1, const void *v2, int *result)
    1: {
    1:     ptrdiff_t offset_diff;
    1:     const TableEntry *te1 = (const TableEntry *) v1,
    1:                      *te2 = (const TableEntry *) v2;
    1: 
    1:     offset_diff = te1->offset - te2->offset;
    1:     *result = (offset_diff == 0 ? te1->order - te2->order
    1:                : offset_diff < 0 ? -1
    1:                : 1);
    1:     return JS_TRUE;
    1: }
    1: 
  259: static ptrdiff_t
  259: SprintDoubleValue(Sprinter *sp, jsval v, JSOp *opp)
  259: {
  259:     jsdouble d;
  259:     ptrdiff_t todo;
  259:     char *s, buf[DTOSTR_STANDARD_BUFFER_SIZE];
  259: 
  259:     JS_ASSERT(JSVAL_IS_DOUBLE(v));
  259:     d = *JSVAL_TO_DOUBLE(v);
  259:     if (JSDOUBLE_IS_NEGZERO(d)) {
  259:         todo = SprintCString(sp, "-0");
  259:         *opp = JSOP_NEG;
  259:     } else if (!JSDOUBLE_IS_FINITE(d)) {
  259:         /* Don't use Infinity and NaN, they're mutable. */
  259:         todo = SprintCString(sp,
  259:                              JSDOUBLE_IS_NaN(d)
  259:                              ? "0 / 0"
  259:                              : (d < 0)
  259:                              ? "1 / -0"
  259:                              : "1 / 0");
  259:         *opp = JSOP_DIV;
  259:     } else {
  259:         s = JS_dtostr(buf, sizeof buf, DTOSTR_STANDARD, 0, d);
  259:         if (!s) {
  259:             JS_ReportOutOfMemory(sp->context);
  259:             return -1;
  259:         }
  259:         JS_ASSERT(strcmp(s, js_Infinity_str) &&
  259:                   (*s != '-' ||
  259:                    strcmp(s + 1, js_Infinity_str)) &&
  259:                   strcmp(s, js_NaN_str));
  259:         todo = Sprint(sp, s);
  259:     }
  259:     return todo;
  259: }
  259: 
    1: static jsbytecode *
 1967: Decompile(SprintStack *ss, jsbytecode *pc, intN nb, JSOp nextop);
    1: 
    1: static JSBool
    1: DecompileSwitch(SprintStack *ss, TableEntry *table, uintN tableLength,
    1:                 jsbytecode *pc, ptrdiff_t switchLength,
    1:                 ptrdiff_t defaultOffset, JSBool isCondSwitch)
    1: {
    1:     JSContext *cx;
    1:     JSPrinter *jp;
  259:     ptrdiff_t off, off2, diff, caseExprOff, todo;
    1:     char *lval, *rval;
    1:     uintN i;
    1:     jsval key;
    1:     JSString *str;
    1: 
    1:     cx = ss->sprinter.context;
    1:     jp = ss->printer;
    1: 
    1:     /* JSOP_CONDSWITCH doesn't pop, unlike JSOP_{LOOKUP,TABLE}SWITCH. */
    1:     off = isCondSwitch ? GetOff(ss, ss->top-1) : PopOff(ss, JSOP_NOP);
    1:     lval = OFF2STR(&ss->sprinter, off);
    1: 
 9832:     js_printf(jp, "\tswitch (%s) {\n", lval);
    1: 
    1:     if (tableLength) {
    1:         diff = table[0].offset - defaultOffset;
    1:         if (diff > 0) {
    1:             jp->indent += 2;
    1:             js_printf(jp, "\t%s:\n", js_default_str);
    1:             jp->indent += 2;
 1967:             if (!Decompile(ss, pc + defaultOffset, diff, JSOP_NOP))
    1:                 return JS_FALSE;
    1:             jp->indent -= 4;
    1:         }
    1: 
    1:         caseExprOff = isCondSwitch ? JSOP_CONDSWITCH_LENGTH : 0;
    1: 
    1:         for (i = 0; i < tableLength; i++) {
    1:             off = table[i].offset;
    1:             off2 = (i + 1 < tableLength) ? table[i + 1].offset : switchLength;
    1: 
    1:             key = table[i].key;
    1:             if (isCondSwitch) {
    1:                 ptrdiff_t nextCaseExprOff;
    1: 
    1:                 /*
    1:                  * key encodes the JSOP_CASE bytecode's offset from switchtop.
    1:                  * The next case expression follows immediately, unless we are
    1:                  * at the last case.
    1:                  */
    1:                 nextCaseExprOff = (ptrdiff_t)JSVAL_TO_INT(key);
    1:                 nextCaseExprOff += js_CodeSpec[pc[nextCaseExprOff]].length;
    1:                 jp->indent += 2;
    1:                 if (!Decompile(ss, pc + caseExprOff,
 1967:                                nextCaseExprOff - caseExprOff, JSOP_NOP)) {
    1:                     return JS_FALSE;
    1:                 }
    1:                 caseExprOff = nextCaseExprOff;
    1: 
    1:                 /* Balance the stack as if this JSOP_CASE matched. */
    1:                 --ss->top;
    1:             } else {
    1:                 /*
    1:                  * key comes from an atom, not the decompiler, so we need to
    1:                  * quote it if it's a string literal.  But if table[i].label
    1:                  * is non-null, key was constant-propagated and label is the
    1:                  * name of the const we should show as the case label.  We set
    1:                  * key to undefined so this identifier is escaped, if required
    1:                  * by non-ASCII characters, but not quoted, by QuoteString.
    1:                  */
  259:                 todo = -1;
    1:                 if (table[i].label) {
    1:                     str = ATOM_TO_STRING(table[i].label);
    1:                     key = JSVAL_VOID;
  259:                 } else if (JSVAL_IS_DOUBLE(key)) {
  259:                     JSOp junk;
  259: 
  259:                     todo = SprintDoubleValue(&ss->sprinter, key, &junk);
  259:                     str = NULL;
    1:                 } else {
    1:                     str = js_ValueToString(cx, key);
    1:                     if (!str)
    1:                         return JS_FALSE;
    1:                 }
  259:                 if (todo >= 0) {
  259:                     rval = OFF2STR(&ss->sprinter, todo);
  259:                 } else {
  259:                     rval = QuoteString(&ss->sprinter, str, (jschar)
  259:                                        (JSVAL_IS_STRING(key) ? '"' : 0));
    1:                     if (!rval)
    1:                         return JS_FALSE;
  259:                 }
    1:                 RETRACT(&ss->sprinter, rval);
    1:                 jp->indent += 2;
    1:                 js_printf(jp, "\tcase %s:\n", rval);
    1:             }
    1: 
    1:             jp->indent += 2;
    1:             if (off <= defaultOffset && defaultOffset < off2) {
    1:                 diff = defaultOffset - off;
    1:                 if (diff != 0) {
 1967:                     if (!Decompile(ss, pc + off, diff, JSOP_NOP))
    1:                         return JS_FALSE;
    1:                     off = defaultOffset;
    1:                 }
    1:                 jp->indent -= 2;
    1:                 js_printf(jp, "\t%s:\n", js_default_str);
    1:                 jp->indent += 2;
    1:             }
 1967:             if (!Decompile(ss, pc + off, off2 - off, JSOP_NOP))
    1:                 return JS_FALSE;
    1:             jp->indent -= 4;
    1: 
    1:             /* Re-balance as if last JSOP_CASE or JSOP_DEFAULT mismatched. */
    1:             if (isCondSwitch)
    1:                 ++ss->top;
    1:         }
    1:     }
    1: 
    1:     if (defaultOffset == switchLength) {
    1:         jp->indent += 2;
    1:         js_printf(jp, "\t%s:;\n", js_default_str);
    1:         jp->indent -= 2;
    1:     }
    1:     js_printf(jp, "\t}\n");
    1: 
    1:     /* By the end of a JSOP_CONDSWITCH, the discriminant has been popped. */
    1:     if (isCondSwitch)
    1:         --ss->top;
    1:     return JS_TRUE;
    1: }
    1: 
18594: #define LOCAL_ASSERT_CUSTOM(expr, BAD_EXIT)                                   \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT(expr);                                                      \
18594:         if (!(expr)) { BAD_EXIT; }                                            \
    1:     JS_END_MACRO
    1: 
18594: #define LOCAL_ASSERT_RV(expr, rv)                                             \
18594:     LOCAL_ASSERT_CUSTOM(expr, return (rv))
18594: 
 8179: static JSAtom *
16429: GetArgOrVarAtom(JSPrinter *jp, uintN slot)
 8179: {
 8179:     JSAtom *name;
 8179: 
 8179:     LOCAL_ASSERT_RV(jp->fun, NULL);
18308:     LOCAL_ASSERT_RV(slot < (uintN) JS_GET_LOCAL_NAME_COUNT(jp->fun), NULL);
11435:     name = JS_LOCAL_NAME_TO_ATOM(jp->localNames[slot]);
 8179: #if !JS_HAS_DESTRUCTURING
 8179:     LOCAL_ASSERT_RV(name, NULL);
 8179: #endif
 8179:     return name;
 8179: }
 8179: 
    1: const char *
    1: GetLocal(SprintStack *ss, jsint i)
    1: {
    1:     ptrdiff_t off;
    1:     JSContext *cx;
    1:     JSScript *script;
    1:     jsatomid j, n;
    1:     JSAtom *atom;
    1:     JSObject *obj;
    1:     jsint depth, count;
    1:     JSScopeProperty *sprop;
    1:     const char *rval;
    1: 
    1: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, "")
    1: 
    1:     off = ss->offsets[i];
    1:     if (off >= 0)
    1:         return OFF2STR(&ss->sprinter, off);
    1: 
    1:     /*
    1:      * We must be called from js_DecompileValueGenerator (via Decompile) when
 3235:      * dereferencing a local that's undefined or null. Search script->objects
    1:      * for the block containing this local by its stack index, i.
    1:      */
    1:     cx = ss->sprinter.context;
    1:     script = ss->printer->script;
 3235:     LOCAL_ASSERT(script->objectsOffset != 0);
16072:     for (j = 0, n = JS_SCRIPT_OBJECTS(script)->length; ; j++) {
16072:         LOCAL_ASSERT(j < n);
 3235:         JS_GET_SCRIPT_OBJECT(script, j, obj);
    1:         if (OBJ_GET_CLASS(cx, obj) == &js_BlockClass) {
    1:             depth = OBJ_BLOCK_DEPTH(cx, obj);
    1:             count = OBJ_BLOCK_COUNT(cx, obj);
    1:             if ((jsuint)(i - depth) < (jsuint)count)
    1:                 break;
    1:         }
    1:     }
    1: 
    1:     i -= depth;
    1:     for (sprop = OBJ_SCOPE(obj)->lastProp; sprop; sprop = sprop->parent) {
    1:         if (sprop->shortid == i)
    1:             break;
    1:     }
    1: 
    1:     LOCAL_ASSERT(sprop && JSID_IS_ATOM(sprop->id));
    1:     atom = JSID_TO_ATOM(sprop->id);
    1:     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:     if (!rval)
    1:         return NULL;
    1:     RETRACT(&ss->sprinter, rval);
    1:     return rval;
    1: 
    1: #undef LOCAL_ASSERT
    1: }
    1: 
16429: static JSBool
16429: IsVarSlot(JSPrinter *jp, jsbytecode *pc, jsint *indexp)
16429: {
16429:     uintN slot;
16429: 
16429:     slot = GET_SLOTNO(pc);
16429:     if (slot < jp->script->nfixed) {
16429:         /* The slot refers to a variable with name stored in jp->localNames. */
16429:         *indexp = jp->fun->nargs + slot;
16429:         return JS_TRUE;
16429:     }
16429: 
16429:     /* We have a local which index is relative to the stack base. */
16429:     slot -= jp->script->nfixed;
16429:     JS_ASSERT(slot < StackDepth(jp->script));
16429:     *indexp = slot;
16429:     return JS_FALSE;
16429: }
16429: 
20908: #if JS_HAS_DESTRUCTURING
20908: 
20908: #define LOCAL_ASSERT(expr)  LOCAL_ASSERT_RV(expr, NULL)
20908: #define LOAD_OP_DATA(pc)    (oplen = (cs = &js_CodeSpec[op=(JSOp)*pc])->length)
20908: 
    1: static jsbytecode *
    1: DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc);
    1: 
    1: static jsbytecode *
    1: DecompileDestructuringLHS(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
    1:                           JSBool *hole)
    1: {
    1:     JSContext *cx;
    1:     JSPrinter *jp;
    1:     JSOp op;
    1:     const JSCodeSpec *cs;
16429:     uintN oplen;
16429:     jsint i;
    1:     const char *lval, *xval;
    1:     ptrdiff_t todo;
    1:     JSAtom *atom;
    1: 
    1:     *hole = JS_FALSE;
    1:     cx = ss->sprinter.context;
    1:     jp = ss->printer;
    1:     LOAD_OP_DATA(pc);
    1: 
    1:     switch (op) {
    1:       case JSOP_POP:
    1:         *hole = JS_TRUE;
    1:         todo = SprintPut(&ss->sprinter, ", ", 2);
    1:         break;
    1: 
    1:       case JSOP_DUP:
    1:         pc = DecompileDestructuring(ss, pc, endpc);
    1:         if (!pc)
    1:             return NULL;
    1:         if (pc == endpc)
    1:             return pc;
    1:         LOAD_OP_DATA(pc);
    1:         lval = PopStr(ss, JSOP_NOP);
    1:         todo = SprintCString(&ss->sprinter, lval);
 1289:         if (op == JSOP_POPN)
    1:             return pc;
    1:         LOCAL_ASSERT(*pc == JSOP_POP);
    1:         break;
    1: 
    1:       case JSOP_SETARG:
    1:       case JSOP_SETGVAR:
    1:       case JSOP_SETLOCAL:
 1289:         LOCAL_ASSERT(pc[oplen] == JSOP_POP || pc[oplen] == JSOP_POPN);
    1:         /* FALL THROUGH */
    1: 
    1:       case JSOP_SETLOCALPOP:
    1:         atom = NULL;
    1:         lval = NULL;
16429:         if (op == JSOP_SETARG) {
16429:             atom = GetArgOrVarAtom(jp, GET_SLOTNO(pc));
 8179:             LOCAL_ASSERT(atom);
 8179:         } else if (op == JSOP_SETGVAR) {
 3235:             GET_ATOM_FROM_BYTECODE(jp->script, pc, 0, atom);
16429:         } else if (IsVarSlot(jp, pc, &i)) {
16429:             atom = GetArgOrVarAtom(jp, i);
16429:             LOCAL_ASSERT(atom);
 8179:         } else {
16429:             lval = GetLocal(ss, i);
 8179:         }
    1:         if (atom)
    1:             lval = js_AtomToPrintableString(cx, atom);
    1:         LOCAL_ASSERT(lval);
    1:         todo = SprintCString(&ss->sprinter, lval);
    1:         if (op != JSOP_SETLOCALPOP) {
    1:             pc += oplen;
    1:             if (pc == endpc)
    1:                 return pc;
    1:             LOAD_OP_DATA(pc);
 1289:             if (op == JSOP_POPN)
    1:                 return pc;
    1:             LOCAL_ASSERT(op == JSOP_POP);
    1:         }
    1:         break;
    1: 
    1:       default:
    1:         /*
    1:          * We may need to auto-parenthesize the left-most value decompiled
    1:          * here, so add back PAREN_SLOP temporarily.  Then decompile until the
    1:          * opcode that would reduce the stack depth to (ss->top-1), which we
    1:          * pass to Decompile encoded as -(ss->top-1) - 1 or just -ss->top for
    1:          * the nb parameter.
    1:          */
    1:         todo = ss->sprinter.offset;
    1:         ss->sprinter.offset = todo + PAREN_SLOP;
 2531:         pc = Decompile(ss, pc, -((intN)ss->top), JSOP_NOP);
    1:         if (!pc)
    1:             return NULL;
    1:         if (pc == endpc)
    1:             return pc;
    1:         LOAD_OP_DATA(pc);
    1:         LOCAL_ASSERT(op == JSOP_ENUMELEM || op == JSOP_ENUMCONSTELEM);
    1:         xval = PopStr(ss, JSOP_NOP);
    1:         lval = PopStr(ss, JSOP_GETPROP);
    1:         ss->sprinter.offset = todo;
    1:         if (*lval == '\0') {
    1:             /* lval is from JSOP_BINDNAME, so just print xval. */
    1:             todo = SprintCString(&ss->sprinter, xval);
    1:         } else if (*xval == '\0') {
    1:             /* xval is from JSOP_SETCALL or JSOP_BINDXMLNAME, print lval. */
    1:             todo = SprintCString(&ss->sprinter, lval);
    1:         } else {
    1:             todo = Sprint(&ss->sprinter,
 1761:                           (JOF_OPMODE(ss->opcodes[ss->top+1]) == JOF_XMLNAME)
    1:                           ? "%s.%s"
    1:                           : "%s[%s]",
    1:                           lval, xval);
    1:         }
    1:         break;
    1:     }
    1: 
    1:     if (todo < 0)
    1:         return NULL;
    1: 
    1:     LOCAL_ASSERT(pc < endpc);
    1:     pc += oplen;
    1:     return pc;
    1: }
    1: 
    1: /*
    1:  * Starting with a SRC_DESTRUCT-annotated JSOP_DUP, decompile a destructuring
    1:  * left-hand side object or array initialiser, including nested destructuring
    1:  * initialisers.  On successful return, the decompilation will be pushed on ss
    1:  * and the return value will point to the POP or GROUP bytecode following the
    1:  * destructuring expression.
    1:  *
    1:  * At any point, if pc is equal to endpc and would otherwise advance, we stop
    1:  * immediately and return endpc.
    1:  */
    1: static jsbytecode *
    1: DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc)
    1: {
11039:     ptrdiff_t head;
    1:     JSContext *cx;
    1:     JSPrinter *jp;
    1:     JSOp op, saveop;
    1:     const JSCodeSpec *cs;
    1:     uintN oplen;
    1:     jsint i, lasti;
    1:     jsdouble d;
    1:     const char *lval;
    1:     JSAtom *atom;
    1:     jssrcnote *sn;
    1:     JSString *str;
    1:     JSBool hole;
    1: 
    1:     LOCAL_ASSERT(*pc == JSOP_DUP);
    1:     pc += JSOP_DUP_LENGTH;
    1: 
    1:     /*
    1:      * Set head so we can rewrite '[' to '{' as needed.  Back up PAREN_SLOP
    1:      * chars so the destructuring decompilation accumulates contiguously in
    1:      * ss->sprinter starting with "[".
    1:      */
    1:     head = SprintPut(&ss->sprinter, "[", 1);
    1:     if (head < 0 || !PushOff(ss, head, JSOP_NOP))
    1:         return NULL;
    1:     ss->sprinter.offset -= PAREN_SLOP;
    1:     LOCAL_ASSERT(head == ss->sprinter.offset - 1);
    1:     LOCAL_ASSERT(*OFF2STR(&ss->sprinter, head) == '[');
    1: 
    1:     cx = ss->sprinter.context;
    1:     jp = ss->printer;
    1:     lasti = -1;
    1: 
    1:     while (pc < endpc) {
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:         ptrdiff_t nameoff = -1;
11039: #endif
11039: 
    1:         LOAD_OP_DATA(pc);
    1:         saveop = op;
    1: 
    1:         switch (op) {
    1:           case JSOP_POP:
    1:             pc += oplen;
    1:             goto out;
    1: 
    1:           /* Handle the optimized number-pushing opcodes. */
    1:           case JSOP_ZERO:   d = i = 0; goto do_getelem;
    1:           case JSOP_ONE:    d = i = 1; goto do_getelem;
    1:           case JSOP_UINT16: d = i = GET_UINT16(pc); goto do_getelem;
    1:           case JSOP_UINT24: d = i = GET_UINT24(pc); goto do_getelem;
 3328:           case JSOP_INT8:   d = i = GET_INT8(pc);   goto do_getelem;
 3328:           case JSOP_INT32:  d = i = GET_INT32(pc);  goto do_getelem;
 3328: 
 3328:           case JSOP_DOUBLE:
 3235:             GET_ATOM_FROM_BYTECODE(jp->script, pc, 0, atom);
    1:             d = *ATOM_TO_DOUBLE(atom);
    1:             LOCAL_ASSERT(JSDOUBLE_IS_FINITE(d) && !JSDOUBLE_IS_NEGZERO(d));
    1:             i = (jsint)d;
    1: 
    1:           do_getelem:
    1:             sn = js_GetSrcNote(jp->script, pc);
    1:             pc += oplen;
    1:             if (pc == endpc)
    1:                 return pc;
    1:             LOAD_OP_DATA(pc);
    1:             LOCAL_ASSERT(op == JSOP_GETELEM);
    1: 
    1:             /* Distinguish object from array by opcode or source note. */
    1:             if (sn && SN_TYPE(sn) == SRC_INITPROP) {
    1:                 *OFF2STR(&ss->sprinter, head) = '{';
    1:                 if (Sprint(&ss->sprinter, "%g: ", d) < 0)
    1:                     return NULL;
    1:             } else {
    1:                 /* Sanity check for the gnarly control flow above. */
    1:                 LOCAL_ASSERT(i == d);
    1: 
    1:                 /* Fill in any holes (holes at the end don't matter). */
    1:                 while (++lasti < i) {
    1:                     if (SprintPut(&ss->sprinter, ", ", 2) < 0)
    1:                         return NULL;
    1:                 }
    1:             }
    1:             break;
    1: 
11377:           case JSOP_LENGTH:
11377:             atom = cx->runtime->atomState.lengthAtom;
11377:             goto do_destructure_atom;
11377: 
    1:           case JSOP_CALLPROP:
    1:           case JSOP_GETPROP:
11377:             GET_ATOM_FROM_BYTECODE(jp->script, pc, 0, atom);
11377:           do_destructure_atom:
    1:             *OFF2STR(&ss->sprinter, head) = '{';
    1:             str = ATOM_TO_STRING(atom);
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:             nameoff = ss->sprinter.offset;
11039: #endif
    1:             if (!QuoteString(&ss->sprinter, str,
    1:                              js_IsIdentifier(str) ? 0 : (jschar)'\'')) {
    1:                 return NULL;
    1:             }
    1:             if (SprintPut(&ss->sprinter, ": ", 2) < 0)
    1:                 return NULL;
    1:             break;
    1: 
    1:           default:
    1:             LOCAL_ASSERT(0);
    1:         }
    1: 
    1:         pc += oplen;
    1:         if (pc == endpc)
    1:             return pc;
    1: 
    1:         /*
    1:          * Decompile the left-hand side expression whose bytecode starts at pc
    1:          * and continues for a bounded number of bytecodes or stack operations
    1:          * (and which in any event stops before endpc).
    1:          */
    1:         pc = DecompileDestructuringLHS(ss, pc, endpc, &hole);
    1:         if (!pc)
    1:             return NULL;
11039: 
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:         if (nameoff >= 0) {
11039:             ptrdiff_t offset, initlen;
11039: 
11039:             offset = ss->sprinter.offset;
11039:             LOCAL_ASSERT(*OFF2STR(&ss->sprinter, offset) == '\0');
11039:             initlen = offset - nameoff;
11039:             LOCAL_ASSERT(initlen >= 4);
11039: 
11039:             /* Early check to rule out odd "name: lval" length. */
11039:             if (((size_t)initlen & 1) == 0) {
11039:                 size_t namelen;
11039:                 const char *name;
11039: 
11039:                 /*
11039:                  * Even "name: lval" string length: check for "x: x" and the
11039:                  * like, and apply the shorthand if we can.
11039:                  */
11039:                 namelen = (size_t)(initlen - 2) >> 1;
11039:                 name = OFF2STR(&ss->sprinter, nameoff);
11039:                 if (!strncmp(name + namelen, ": ", 2) &&
11039:                     !strncmp(name, name + namelen + 2, namelen)) {
11039:                     offset -= namelen + 2;
11039:                     *OFF2STR(&ss->sprinter, offset) = '\0';
11039:                     ss->sprinter.offset = offset;
11039:                 }
11039:             }
11039:         }
11039: #endif
11039: 
    1:         if (pc == endpc || *pc != JSOP_DUP)
    1:             break;
    1: 
    1:         /*
    1:          * Check for SRC_DESTRUCT on this JSOP_DUP, which would mean another
    1:          * destructuring initialiser abuts this one, and we should stop.  This
    1:          * happens with source of the form '[a] = [b] = c'.
    1:          */
    1:         sn = js_GetSrcNote(jp->script, pc);
    1:         if (sn && SN_TYPE(sn) == SRC_DESTRUCT)
    1:             break;
    1: 
    1:         if (!hole && SprintPut(&ss->sprinter, ", ", 2) < 0)
    1:             return NULL;
    1: 
    1:         pc += JSOP_DUP_LENGTH;
    1:     }
    1: 
    1: out:
    1:     lval = OFF2STR(&ss->sprinter, head);
11039:     if (SprintPut(&ss->sprinter, (*lval == '[') ? "]" : "}", 1) < 0)
    1:         return NULL;
    1:     return pc;
    1: }
    1: 
    1: static jsbytecode *
    1: DecompileGroupAssignment(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
    1:                          jssrcnote *sn, ptrdiff_t *todop)
    1: {
    1:     JSOp op;
    1:     const JSCodeSpec *cs;
    1:     uintN oplen, start, end, i;
    1:     ptrdiff_t todo;
    1:     JSBool hole;
    1:     const char *rval;
    1: 
    1:     LOAD_OP_DATA(pc);
    1:     LOCAL_ASSERT(op == JSOP_PUSH || op == JSOP_GETLOCAL);
    1: 
    1:     todo = Sprint(&ss->sprinter, "%s[", VarPrefix(sn));
    1:     if (todo < 0 || !PushOff(ss, todo, JSOP_NOP))
    1:         return NULL;
    1:     ss->sprinter.offset -= PAREN_SLOP;
    1: 
    1:     for (;;) {
    1:         pc += oplen;
    1:         if (pc == endpc)
    1:             return pc;
    1:         pc = DecompileDestructuringLHS(ss, pc, endpc, &hole);
    1:         if (!pc)
    1:             return NULL;
    1:         if (pc == endpc)
    1:             return pc;
    1:         LOAD_OP_DATA(pc);
    1:         if (op != JSOP_PUSH && op != JSOP_GETLOCAL)
    1:             break;
    1:         if (!hole && SprintPut(&ss->sprinter, ", ", 2) < 0)
    1:             return NULL;
    1:     }
    1: 
 1227:     LOCAL_ASSERT(op == JSOP_POPN);
    1:     if (SprintPut(&ss->sprinter, "] = [", 5) < 0)
    1:         return NULL;
    1: 
    1:     end = ss->top - 1;
 1289:     start = end - GET_UINT16(pc);
    1:     for (i = start; i < end; i++) {
    1:         rval = GetStr(ss, i);
 1289:         if (Sprint(&ss->sprinter,
 1289:                    (i == start) ? "%s" : ", %s",
    1:                    (i == end - 1 && *rval == '\0') ? ", " : rval) < 0) {
    1:             return NULL;
    1:         }
    1:     }
    1: 
    1:     if (SprintPut(&ss->sprinter, "]", 1) < 0)
    1:         return NULL;
    1:     ss->sprinter.offset = ss->offsets[i];
    1:     ss->top = start;
    1:     *todop = todo;
    1:     return pc;
    1: }
    1: 
    1: #undef LOCAL_ASSERT
    1: #undef LOAD_OP_DATA
    1: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
 1577: static JSBool
 1577: InitSprintStack(JSContext *cx, SprintStack *ss, JSPrinter *jp, uintN depth)
 1577: {
 1577:     size_t offsetsz, opcodesz;
 1577:     void *space;
 1577: 
 1577:     INIT_SPRINTER(cx, &ss->sprinter, &cx->tempPool, PAREN_SLOP);
 1577: 
 1577:     /* Allocate the parallel (to avoid padding) offset and opcode stacks. */
 1577:     offsetsz = depth * sizeof(ptrdiff_t);
 1577:     opcodesz = depth * sizeof(jsbytecode);
 1577:     JS_ARENA_ALLOCATE(space, &cx->tempPool, offsetsz + opcodesz);
 8296:     if (!space) {
 8296:         js_ReportOutOfScriptQuota(cx);
 1577:         return JS_FALSE;
 8296:     }
 1577:     ss->offsets = (ptrdiff_t *) space;
 1577:     ss->opcodes = (jsbytecode *) ((char *)space + offsetsz);
 1577: 
 1577:     ss->top = ss->inArrayInit = 0;
 1577:     ss->inGenExp = JS_FALSE;
 1577:     ss->printer = jp;
 1577:     return JS_TRUE;
 1577: }
 1577: 
    1: /*
    1:  * If nb is non-negative, decompile nb bytecodes starting at pc.  Otherwise
    1:  * the decompiler starts at pc and continues until it reaches an opcode for
    1:  * which decompiling would result in the stack depth equaling -(nb + 1).
 1967:  *
 1967:  * The nextop parameter is either JSOP_NOP or the "next" opcode in order of
 1967:  * abstract interpretation (not necessarily physically next in a bytecode
 1967:  * vector). So nextop is JSOP_POP for the last operand in a comma expression,
 1967:  * or JSOP_AND for the right operand of &&.
    1:  */
    1: static jsbytecode *
 1967: Decompile(SprintStack *ss, jsbytecode *pc, intN nb, JSOp nextop)
    1: {
    1:     JSContext *cx;
    1:     JSPrinter *jp, *jp2;
20943:     jsbytecode *startpc, *endpc, *pc2, *done;
    1:     ptrdiff_t tail, todo, len, oplen, cond, next;
    1:     JSOp op, lastop, saveop;
    1:     const JSCodeSpec *cs;
    1:     jssrcnote *sn, *sn2;
 1154:     const char *lval, *rval, *xval, *fmt, *token;
    1:     jsint i, argc;
    1:     char **argv;
    1:     JSAtom *atom;
    1:     JSObject *obj;
    1:     JSFunction *fun;
    1:     JSString *str;
    1:     JSBool ok;
    1: #if JS_HAS_XML_SUPPORT
    1:     JSBool foreach, inXML, quoteAttr;
    1: #else
    1: #define inXML JS_FALSE
    1: #endif
    1:     jsval val;
    1: 
    1:     static const char exception_cookie[] = "/*EXCEPTION*/";
    1:     static const char retsub_pc_cookie[] = "/*RETSUB_PC*/";
21441:     static const char iter_cookie[]      = "/*ITER*/";
    1:     static const char forelem_cookie[]   = "/*FORELEM*/";
    1:     static const char with_cookie[]      = "/*WITH*/";
    1:     static const char dot_format[]       = "%s.%s";
    1:     static const char index_format[]     = "%s[%s]";
    1:     static const char predot_format[]    = "%s%s.%s";
    1:     static const char postdot_format[]   = "%s.%s%s";
    1:     static const char preindex_format[]  = "%s%s[%s]";
    1:     static const char postindex_format[] = "%s[%s]%s";
    1:     static const char ss_format[]        = "%s%s";
20943:     static const char sss_format[]       = "%s%s%s";
    1: 
 8285:     /* Argument and variables decompilation uses the following to share code. */
16072:     JS_STATIC_ASSERT(ARGNO_LEN == SLOTNO_LEN);
 8285: 
    1: /*
    1:  * Local macros
    1:  */
20928: #define LOCAL_ASSERT(expr)    LOCAL_ASSERT_RV(expr, NULL)
 1967: #define DECOMPILE_CODE(pc,nb) if (!Decompile(ss, pc, nb, JSOP_NOP)) return NULL
 1967: #define NEXT_OP(pc)           (((pc) + (len) == endpc) ? nextop : pc[len])
21441: #define TOP_STR()             GetStr(ss, ss->top - 1)
    1: #define POP_STR()             PopStr(ss, op)
20928: #define POP_STR_PREC(prec)    PopStrPrec(ss, prec)
20928: 
20928: /*
20928:  * Pop a condition expression for if/for/while. JSOP_IFEQ's precedence forces
20928:  * extra parens around assignment, which avoids a strict-mode warning.
20928:  */
20967: #define POP_COND_STR()                                                        \
20967:     PopStr(ss, (js_CodeSpec[ss->opcodes[ss->top - 1]].format & JOF_SET)       \
20967:                ? JSOP_IFEQ                                                    \
20967:                : JSOP_NOP)
    1: 
    1: /*
    1:  * Callers know that ATOM_IS_STRING(atom), and we leave it to the optimizer to
    1:  * common ATOM_TO_STRING(atom) here and near the call sites.
    1:  */
    1: #define ATOM_IS_IDENTIFIER(atom) js_IsIdentifier(ATOM_TO_STRING(atom))
  969: #define ATOM_IS_KEYWORD(atom)                                                 \
  969:     (js_CheckKeyword(JSSTRING_CHARS(ATOM_TO_STRING(atom)),                    \
  969:                      JSSTRING_LENGTH(ATOM_TO_STRING(atom))) != TOK_EOF)
    1: 
    1: /*
    1:  * Given an atom already fetched from jp->script's atom map, quote/escape its
    1:  * string appropriately into rval, and select fmt from the quoted and unquoted
    1:  * alternatives.
    1:  */
    1: #define GET_QUOTE_AND_FMT(qfmt, ufmt, rval)                                   \
    1:     JS_BEGIN_MACRO                                                            \
    1:         jschar quote_;                                                        \
    1:         if (!ATOM_IS_IDENTIFIER(atom)) {                                      \
    1:             quote_ = '\'';                                                    \
    1:             fmt = qfmt;                                                       \
    1:         } else {                                                              \
    1:             quote_ = 0;                                                       \
    1:             fmt = ufmt;                                                       \
    1:         }                                                                     \
    1:         rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), quote_);      \
    1:         if (!rval)                                                            \
    1:             return NULL;                                                      \
    1:     JS_END_MACRO
    1: 
    1: #define LOAD_ATOM(PCOFF)                                                      \
 3235:     GET_ATOM_FROM_BYTECODE(jp->script, pc, PCOFF, atom)
 3235: 
 3235: #define LOAD_OBJECT(PCOFF)                                                    \
 3235:     GET_OBJECT_FROM_BYTECODE(jp->script, pc, PCOFF, obj)
 3235: 
 3235: #define LOAD_FUNCTION(PCOFF)                                                  \
13824:     GET_FUNCTION_FROM_BYTECODE(jp->script, pc, PCOFF, fun)
 3235: 
 3235: #define LOAD_REGEXP(PCOFF)                                                    \
 3235:     GET_REGEXP_FROM_BYTECODE(jp->script, pc, PCOFF, obj)
    1: 
 4342: #define GET_SOURCE_NOTE_ATOM(sn, atom)                                        \
 4342:     JS_BEGIN_MACRO                                                            \
 4342:         jsatomid atomIndex_ = (jsatomid) js_GetSrcNoteOffset((sn), 0);        \
 4342:                                                                               \
 4342:         LOCAL_ASSERT(atomIndex_ < jp->script->atomMap.length);                \
 4342:         (atom) = jp->script->atomMap.vector[atomIndex_];                      \
 4342:     JS_END_MACRO
 4342: 
    1: /*
    1:  * Get atom from jp->script's atom map, quote/escape its string appropriately
    1:  * into rval, and select fmt from the quoted and unquoted alternatives.
    1:  */
    1: #define GET_ATOM_QUOTE_AND_FMT(qfmt, ufmt, rval)                              \
    1:     JS_BEGIN_MACRO                                                            \
    1:         LOAD_ATOM(0);                                                         \
    1:         GET_QUOTE_AND_FMT(qfmt, ufmt, rval);                                  \
    1:     JS_END_MACRO
    1: 
20928: /*
20928:  * Per spec, new x(y).z means (new x(y))).z. For example new (x(y).z) must
20928:  * decompile with the constructor parenthesized, but new x.z should not. The
20928:  * normal rules give x(y).z and x.z identical precedence: both are produced by
20928:  * JSOP_GETPROP.
20928:  *
20928:  * Therefore, we need to know in case JSOP_NEW whether the constructor
20928:  * expression contains any unparenthesized function calls. So when building a
20928:  * MemberExpression or CallExpression, we set ss->opcodes[n] to JSOP_CALL if
20928:  * this is true. x(y).z gets JSOP_CALL, not JSOP_GETPROP.
20928:  */
20928: #define PROPAGATE_CALLNESS()                                                  \
20928:     JS_BEGIN_MACRO                                                            \
20928:         if (ss->opcodes[ss->top - 1] == JSOP_CALL)                            \
20928:             saveop = JSOP_CALL;                                               \
20928:     JS_END_MACRO
20928: 
    1:     cx = ss->sprinter.context;
14767:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     jp = ss->printer;
    1:     startpc = pc;
    1:     endpc = (nb < 0) ? jp->script->code + jp->script->length : pc + nb;
    1:     tail = -1;
    1:     todo = -2;                  /* NB: different from Sprint() error return. */
    1:     saveop = JSOP_NOP;
    1:     sn = NULL;
    1:     rval = NULL;
    1: #if JS_HAS_XML_SUPPORT
    1:     foreach = inXML = quoteAttr = JS_FALSE;
    1: #endif
    1: 
    1:     while (nb < 0 || pc < endpc) {
    1:         /*
    1:          * Move saveop to lastop so prefixed bytecodes can take special action
    1:          * while sharing maximal code.  Set op and saveop to the new bytecode,
    1:          * use op in POP_STR to trigger automatic parenthesization, but push
    1:          * saveop at the bottom of the loop if this op pushes.  Thus op may be
    1:          * set to nop or otherwise mutated to suppress auto-parens.
    1:          */
    1:         lastop = saveop;
    1:         op = (JSOp) *pc;
    1:         cs = &js_CodeSpec[op];
 3235:         if (cs->format & JOF_INDEXBASE) {
    1:             /*
 3235:              * The decompiler uses js_GetIndexFromBytecode to get atoms and
 3235:              * objects and ignores these suffix/prefix bytecodes, thus
 3235:              * simplifying code that must process JSOP_GETTER/JSOP_SETTER
 3235:              * prefixes.
    1:              */
    1:             pc += cs->length;
    1:             if (pc >= endpc)
    1:                 break;
    1:             op = (JSOp) *pc;
    1:             cs = &js_CodeSpec[op];
    1:         }
    1:         saveop = op;
    1:         len = oplen = cs->length;
    1: 
    1:         if (nb < 0 && -(nb + 1) == (intN)ss->top - cs->nuses + cs->ndefs)
    1:             return pc;
    1: 
 1326:         /*
 1326:          * Save source literal associated with JS now before the following
 1326:          * rewrite changes op. See bug 380197.
 1326:          */
 1326:         token = CodeToken[op];
 1326: 
    1:         if (pc + oplen == jp->dvgfence) {
    1:             JSStackFrame *fp;
    1:             uint32 format, mode, type;
    1: 
    1:             /*
    1:              * Rewrite non-get ops to their "get" format if the error is in
    1:              * the bytecode at pc, so we don't decompile more than the error
    1:              * expression.
    1:              */
    1:             for (fp = cx->fp; fp && !fp->script; fp = fp->down)
    1:                 continue;
    1:             format = cs->format;
13168:             if (((fp && fp->regs && pc == fp->regs->pc) ||
    1:                  (pc == startpc && cs->nuses != 0)) &&
16489:                 format & (JOF_SET|JOF_DEL|JOF_INCDEC|JOF_FOR|JOF_VARPROP)) {
 1761:                 mode = JOF_MODE(format);
    1:                 if (mode == JOF_NAME) {
    1:                     /*
 4380:                      * JOF_NAME does not imply JOF_ATOM, so we must check for
    1:                      * the QARG and QVAR format types, and translate those to
16429:                      * JSOP_GETARG or JSOP_GETLOCAL appropriately, instead of
16429:                      * to JSOP_NAME.
    1:                      */
11377:                     type = JOF_TYPE(format);
    1:                     op = (type == JOF_QARG)
    1:                          ? JSOP_GETARG
    1:                          : (type == JOF_LOCAL)
    1:                          ? JSOP_GETLOCAL
    1:                          : JSOP_NAME;
    1: 
    1:                     i = cs->nuses - js_CodeSpec[op].nuses;
    1:                     while (--i >= 0)
    1:                         PopOff(ss, JSOP_NOP);
    1:                 } else {
    1:                     /*
    1:                      * We must replace the faulting pc's bytecode with a
    1:                      * corresponding JSOP_GET* code.  For JSOP_SET{PROP,ELEM},
    1:                      * we must use the "2nd" form of JSOP_GET{PROP,ELEM}, to
    1:                      * throw away the assignment op's right-hand operand and
    1:                      * decompile it as if it were a GET of its left-hand
    1:                      * operand.
    1:                      */
    1:                     if (mode == JOF_PROP) {
 3164:                         op = (JSOp) ((format & JOF_SET)
 3164:                                      ? JSOP_GETPROP2
 3164:                                      : JSOP_GETPROP);
    1:                     } else if (mode == JOF_ELEM) {
 3164:                         op = (JSOp) ((format & JOF_SET)
 3164:                                      ? JSOP_GETELEM2
 3164:                                      : JSOP_GETELEM);
    1:                     } else {
    1:                         /*
14669:                          * Unknown mode (including mode 0) means that op is
14669:                          * uncategorized for our purposes, so we must write
14669:                          * per-op special case code here.
    1:                          */
    1:                         switch (op) {
    1:                           case JSOP_ENUMELEM:
    1:                           case JSOP_ENUMCONSTELEM:
    1:                             op = JSOP_GETELEM;
    1:                             break;
    1: #if JS_HAS_LVALUE_RETURN
    1:                           case JSOP_SETCALL:
    1:                             op = JSOP_CALL;
    1:                             break;
    1: #endif
14820:                           case JSOP_GETTHISPROP:
14820:                             /*
14820:                              * NB: JSOP_GETTHISPROP can't fail due to |this|
14820:                              * being null or undefined at runtime (beware that
14820:                              * this may change for ES4). Therefore any error
14820:                              * resulting from this op must be due to the value
14820:                              * of the property accessed via |this|, so do not
14820:                              * rewrite op to JSOP_THIS.
14820:                              *
16429:                              * The next two cases should not change op if
14820:                              * js_DecompileValueGenerator was called from the
14820:                              * the property getter. They should rewrite only
14820:                              * if the base object in the arg/var/local is null
14820:                              * or undefined. FIXME: bug 431569.
14820:                              */
14820:                             break;
    1:                           case JSOP_GETARGPROP:
    1:                             op = JSOP_GETARG;
    1:                             break;
    1:                           case JSOP_GETLOCALPROP:
    1:                             op = JSOP_GETLOCAL;
    1:                             break;
    1:                           default:
    1:                             LOCAL_ASSERT(0);
    1:                         }
    1:                     }
    1:                 }
    1:             }
    1: 
    1:             saveop = op;
    1:             if (op >= JSOP_LIMIT) {
    1:                 switch (op) {
    1:                   case JSOP_GETPROP2:
    1:                     saveop = JSOP_GETPROP;
    1:                     break;
    1:                   case JSOP_GETELEM2:
    1:                     saveop = JSOP_GETELEM;
    1:                     break;
    1:                   default:;
    1:                 }
    1:             }
    1:             LOCAL_ASSERT(js_CodeSpec[saveop].length == oplen ||
11377:                          JOF_TYPE(format) == JOF_SLOTATOM);
    1: 
    1:             jp->dvgfence = NULL;
    1:         }
    1: 
 1154:         if (token) {
    1:             switch (cs->nuses) {
    1:               case 2:
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
    1:                     /*
    1:                      * Avoid over-parenthesizing y in x op= y based on its
    1:                      * expansion: x = x op y (replace y by z = w to see the
    1:                      * problem).
    1:                      */
 3164:                     op = (JSOp) pc[oplen];
20942:                     rval = POP_STR();
20942:                     lval = POP_STR();
    1:                     /* Print only the right operand of the assignment-op. */
    1:                     todo = SprintCString(&ss->sprinter, rval);
    1:                     op = saveop;
    1:                 } else if (!inXML) {
20942:                     rval = POP_STR_PREC(cs->prec + !!(cs->format & JOF_LEFTASSOC));
20942:                     lval = POP_STR_PREC(cs->prec + !(cs->format & JOF_LEFTASSOC));
    1:                     todo = Sprint(&ss->sprinter, "%s %s %s",
 1154:                                   lval, token, rval);
    1:                 } else {
    1:                     /* In XML, just concatenate the two operands. */
    1:                     LOCAL_ASSERT(op == JSOP_ADD);
20942:                     rval = POP_STR();
20942:                     lval = POP_STR();
    1:                     todo = Sprint(&ss->sprinter, ss_format, lval, rval);
    1:                 }
    1:                 break;
    1: 
    1:               case 1:
    1:                 rval = POP_STR();
 1154:                 todo = Sprint(&ss->sprinter, ss_format, token, rval);
    1:                 break;
    1: 
    1:               case 0:
 1154:                 todo = SprintCString(&ss->sprinter, token);
    1:                 break;
    1: 
    1:               default:
    1:                 todo = -2;
    1:                 break;
    1:             }
    1:         } else {
    1:             switch (op) {
    1:               case JSOP_NOP:
    1:                 /*
    1:                  * Check for a do-while loop, a for-loop with an empty
    1:                  * initializer part, a labeled statement, a function
    1:                  * definition, or try/finally.
    1:                  */
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 todo = -2;
    1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
    1:                   case SRC_WHILE:
    1:                     ++pc;
    1:                     tail = js_GetSrcNoteOffset(sn, 0) - 1;
    1:                     LOCAL_ASSERT(pc[tail] == JSOP_IFNE ||
    1:                                  pc[tail] == JSOP_IFNEX);
 9832:                     js_printf(jp, "\tdo {\n");
    1:                     jp->indent += 4;
    1:                     DECOMPILE_CODE(pc, tail);
    1:                     jp->indent -= 4;
20928:                     js_printf(jp, "\t} while (%s);\n", POP_COND_STR());
    1:                     pc += tail;
    1:                     len = js_CodeSpec[*pc].length;
    1:                     todo = -2;
    1:                     break;
    1: 
    1:                   case SRC_FOR:
    1:                     rval = "";
    1: 
    1:                   do_forloop:
21520:                     JS_ASSERT(SN_TYPE(sn) == SRC_FOR);
21520: 
    1:                     /* Skip the JSOP_NOP or JSOP_POP bytecode. */
21520:                     pc += JSOP_NOP_LENGTH;
    1: 
    1:                     /* Get the cond, next, and loop-closing tail offsets. */
    1:                     cond = js_GetSrcNoteOffset(sn, 0);
    1:                     next = js_GetSrcNoteOffset(sn, 1);
    1:                     tail = js_GetSrcNoteOffset(sn, 2);
15556: 
15556:                     /*
15556:                      * If this loop has a condition, then pc points at a goto
15556:                      * targeting the condition.
15556:                      */
21520:                     pc2 = pc;
15556:                     if (cond != tail) {
15556:                         LOCAL_ASSERT(*pc == JSOP_GOTO || *pc == JSOP_GOTOX);
21520:                         pc2 += (*pc == JSOP_GOTO) ? JSOP_GOTO_LENGTH : JSOP_GOTOX_LENGTH;
21520:                     }
21520:                     LOCAL_ASSERT(tail + GetJumpOffset(pc+tail, pc+tail) == pc2 - pc);
    1: 
    1:                     /* Print the keyword and the possibly empty init-part. */
    1:                     js_printf(jp, "\tfor (%s;", rval);
    1: 
15556:                     if (cond != tail) {
    1:                         /* Decompile the loop condition. */
15556:                         DECOMPILE_CODE(pc + cond, tail - cond);
20941:                         js_printf(jp, " %s", POP_STR());
    1:                     }
    1: 
    1:                     /* Need a semicolon whether or not there was a cond. */
    1:                     js_puts(jp, ";");
    1: 
15556:                     if (next != cond) {
21520:                         /*
21520:                          * Decompile the loop updater. It may end in a JSOP_POP
21520:                          * that we skip; or in a JSOP_POPN that we do not skip,
21520:                          * followed by a JSOP_NOP (skipped as if it's a POP).
21520:                          * We cope with the difference between these two cases
21520:                          * by checking for stack imbalance and popping if there
21520:                          * is an rval.
21520:                          */
21520:                         uintN saveTop = ss->top;
21520: 
21520:                         DECOMPILE_CODE(pc + next, cond - next - JSOP_POP_LENGTH);
21520:                         LOCAL_ASSERT(ss->top - saveTop <= 1U);
21520:                         rval = (ss->top == saveTop)
21520:                                ? ss->sprinter.base + ss->sprinter.offset
21520:                                : POP_STR();
21520:                         js_printf(jp, " %s", rval);
    1:                     }
    1: 
    1:                     /* Do the loop body. */
 9832:                     js_printf(jp, ") {\n");
    1:                     jp->indent += 4;
21520:                     next -= pc2 - pc;
21520:                     DECOMPILE_CODE(pc2, next);
    1:                     jp->indent -= 4;
    1:                     js_printf(jp, "\t}\n");
    1: 
    1:                     /* Set len so pc skips over the entire loop. */
    1:                     len = tail + js_CodeSpec[pc[tail]].length;
    1:                     break;
    1: 
    1:                   case SRC_LABEL:
 4342:                     GET_SOURCE_NOTE_ATOM(sn, atom);
    1:                     jp->indent -= 4;
    1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                     if (!rval)
    1:                         return NULL;
    1:                     RETRACT(&ss->sprinter, rval);
 9832:                     js_printf(jp, "\t%s:\n", rval);
    1:                     jp->indent += 4;
    1:                     break;
    1: 
    1:                   case SRC_LABELBRACE:
 4342:                     GET_SOURCE_NOTE_ATOM(sn, atom);
    1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                     if (!rval)
    1:                         return NULL;
    1:                     RETRACT(&ss->sprinter, rval);
 9832:                     js_printf(jp, "\t%s: {\n", rval);
    1:                     jp->indent += 4;
    1:                     break;
    1: 
    1:                   case SRC_ENDBRACE:
    1:                     jp->indent -= 4;
    1:                     js_printf(jp, "\t}\n");
    1:                     break;
    1: 
    1:                   case SRC_FUNCDEF:
13824:                     JS_GET_SCRIPT_FUNCTION(jp->script,
13824:                                            js_GetSrcNoteOffset(sn, 0),
13824:                                            fun);
    1:                   do_function:
 8179:                     js_puts(jp, "\n");
13702:                     jp2 = JS_NEW_PRINTER(cx, "nested_function", fun,
    1:                                          jp->indent, jp->pretty);
    1:                     if (!jp2)
    1:                         return NULL;
13702:                     ok = js_DecompileFunction(jp2);
 8179:                     if (ok && jp2->sprinter.base)
    1:                         js_puts(jp, jp2->sprinter.base);
    1:                     js_DestroyPrinter(jp2);
    1:                     if (!ok)
    1:                         return NULL;
 8179:                     js_puts(jp, "\n\n");
    1:                     break;
    1: 
    1:                   case SRC_BRACE:
 9832:                     js_printf(jp, "\t{\n");
    1:                     jp->indent += 4;
    1:                     len = js_GetSrcNoteOffset(sn, 0);
    1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
    1:                     jp->indent -= 4;
    1:                     js_printf(jp, "\t}\n");
    1:                     break;
    1: 
    1:                   default:;
    1:                 }
    1:                 break;
    1: 
    1:               case JSOP_PUSH:
    1: #if JS_HAS_DESTRUCTURING
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
    1:                     pc = DecompileGroupAssignment(ss, pc, endpc, sn, &todo);
    1:                     if (!pc)
    1:                         return NULL;
 1227:                     LOCAL_ASSERT(*pc == JSOP_POPN);
 1227:                     len = oplen = JSOP_POPN_LENGTH;
    1:                     goto end_groupassignment;
    1:                 }
    1: #endif
    1:                 /* FALL THROUGH */
    1: 
    1:               case JSOP_BINDNAME:
    1:                 todo = Sprint(&ss->sprinter, "");
    1:                 break;
    1: 
    1:               case JSOP_TRY:
 9832:                 js_printf(jp, "\ttry {\n");
    1:                 jp->indent += 4;
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_FINALLY:
    1:                 jp->indent -= 4;
 9832:                 js_printf(jp, "\t} finally {\n");
    1:                 jp->indent += 4;
    1: 
    1:                 /*
 1825:                  * We push push the pair of exception/restsub cookies to
 1825:                  * simulate the effects [gosub] or control transfer during
 1825:                  * exception capturing on the stack.
    1:                  */
    1:                 todo = Sprint(&ss->sprinter, exception_cookie);
    1:                 if (todo < 0 || !PushOff(ss, todo, op))
    1:                     return NULL;
    1:                 todo = Sprint(&ss->sprinter, retsub_pc_cookie);
    1:                 break;
    1: 
    1:               case JSOP_RETSUB:
    1:                 rval = POP_STR();
    1:                 LOCAL_ASSERT(strcmp(rval, retsub_pc_cookie) == 0);
    1:                 lval = POP_STR();
    1:                 LOCAL_ASSERT(strcmp(lval, exception_cookie) == 0);
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_GOSUB:
    1:               case JSOP_GOSUBX:
    1:                 /*
    1:                  * JSOP_GOSUB and GOSUBX have no effect on the decompiler's
    1:                  * string stack because the next op in bytecode order finds
    1:                  * the stack balanced by a JSOP_RETSUB executed elsewhere.
    1:                  */
    1:                 todo = -2;
    1:                 break;
    1: 
 1227:               case JSOP_POPN:
    1:               {
20908:                 uintN newtop, oldtop;
    1: 
    1:                 /*
    1:                  * The compiler models operand stack depth and fixes the stack
    1:                  * pointer on entry to a catch clause based on its depth model.
    1:                  * The decompiler must match the code generator's model, which
    1:                  * is why JSOP_FINALLY pushes a cookie that JSOP_RETSUB pops.
    1:                  */
    1:                 oldtop = ss->top;
 1825:                 newtop = oldtop - GET_UINT16(pc);
    1:                 LOCAL_ASSERT(newtop <= oldtop);
    1:                 todo = -2;
    1: 
 1227:                 sn = js_GetSrcNote(jp->script, pc);
 1227:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
 1227:                     break;
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
    1:                     todo = Sprint(&ss->sprinter, "%s[] = [",
    1:                                   VarPrefix(sn));
    1:                     if (todo < 0)
    1:                         return NULL;
20908:                     for (uintN i = newtop; i < oldtop; i++) {
    1:                         rval = OFF2STR(&ss->sprinter, ss->offsets[i]);
    1:                         if (Sprint(&ss->sprinter, ss_format,
    1:                                    (i == newtop) ? "" : ", ",
    1:                                    (i == oldtop - 1 && *rval == '\0')
    1:                                    ? ", " : rval) < 0) {
    1:                             return NULL;
    1:                         }
    1:                     }
    1:                     if (SprintPut(&ss->sprinter, "]", 1) < 0)
    1:                         return NULL;
    1: 
    1:                     /*
21520:                      * If this is an empty group assignment, we have no stack
21520:                      * budget into which we can push our result string. Adjust
21520:                      * ss->sprinter.offset so that our consumer can find the
21520:                      * empty group assignment decompilation.
21520:                      */
21520:                     if (newtop == oldtop) {
21520:                         ss->sprinter.offset = todo;
21520:                     } else {
21520:                         /*
    1:                          * Kill newtop before the end_groupassignment: label by
21520:                          * retracting/popping early.  Control will either jump
21520:                          * to do_forloop: or do_letheadbody: or else break from
21520:                          * our case JSOP_POPN: after the switch (*pc2) below.
    1:                          */
21520:                         LOCAL_ASSERT(newtop < oldtop);
    1:                         ss->sprinter.offset = GetOff(ss, newtop);
    1:                         ss->top = newtop;
    1:                     }
    1: 
    1:                   end_groupassignment:
21520:                     LOCAL_ASSERT(*pc == JSOP_POPN);
21520: 
    1:                     /*
    1:                      * Thread directly to the next opcode if we can, to handle
    1:                      * the special cases of a group assignment in the first or
    1:                      * last part of a for(;;) loop head, or in a let block or
    1:                      * expression head.
    1:                      *
    1:                      * NB: todo at this point indexes space in ss->sprinter
    1:                      * that is liable to be overwritten.  The code below knows
    1:                      * exactly how long rval lives, or else copies it down via
    1:                      * SprintCString.
    1:                      */
    1:                     rval = OFF2STR(&ss->sprinter, todo);
    1:                     todo = -2;
    1:                     pc2 = pc + oplen;
21520:                     if (*pc2 == JSOP_NOP) {
    1:                         sn = js_GetSrcNote(jp->script, pc2);
    1:                         if (sn) {
    1:                             if (SN_TYPE(sn) == SRC_FOR) {
21520:                                 op = JSOP_NOP;
    1:                                 pc = pc2;
    1:                                 goto do_forloop;
    1:                             }
21520: 
    1:                             if (SN_TYPE(sn) == SRC_DECL) {
16072:                                 if (ss->top == StackDepth(jp->script)) {
    1:                                     /*
    1:                                      * This must be an empty destructuring
    1:                                      * in the head of a let whose body block
    1:                                      * is also empty.
    1:                                      */
21520:                                     pc = pc2 + JSOP_NOP_LENGTH;
    1:                                     len = js_GetSrcNoteOffset(sn, 0);
    1:                                     LOCAL_ASSERT(pc[len] == JSOP_LEAVEBLOCK);
    1:                                     js_printf(jp, "\tlet (%s) {\n", rval);
    1:                                     js_printf(jp, "\t}\n");
21520:                                     break;
    1:                                 }
    1:                                 todo = SprintCString(&ss->sprinter, rval);
    1:                                 if (todo < 0 || !PushOff(ss, todo, JSOP_NOP))
    1:                                     return NULL;
    1:                                 op = JSOP_POP;
21520:                                 pc = pc2 + JSOP_NOP_LENGTH;
    1:                                 goto do_letheadbody;
    1:                             }
21520:                         } else {
21520:                             /*
21520:                              * An unnannotated NOP following a POPN must be the
21520:                              * third part of for(;;) loop head. If the POPN's
21520:                              * immediate operand is 0, then we may have no slot
21520:                              * on the sprint-stack in which to push our result
21520:                              * string. In this case the result can be recovered
21520:                              * at ss->sprinter.base + ss->sprinter.offset.
21520:                              */
21520:                             if (GET_UINT16(pc) == 0)
    1:                                 break;
    1:                             todo = SprintCString(&ss->sprinter, rval);
    1:                             saveop = JSOP_NOP;
    1:                         }
    1:                     }
    1: 
    1:                     /*
    1:                      * If control flow reaches this point with todo still -2,
    1:                      * just print rval as an expression statement.
    1:                      */
 9832:                     if (todo == -2)
    1:                         js_printf(jp, "\t%s;\n", rval);
    1:                     break;
    1:                 }
    1: #endif
    1:                 if (newtop < oldtop) {
    1:                     ss->sprinter.offset = GetOff(ss, newtop);
    1:                     ss->top = newtop;
    1:                 }
    1:                 break;
    1:               }
    1: 
    1:               case JSOP_EXCEPTION:
    1:                 /* The catch decompiler handles this op itself. */
    1:                 LOCAL_ASSERT(JS_FALSE);
    1:                 break;
    1: 
    1:               case JSOP_POP:
    1:                 /*
    1:                  * By default, do not automatically parenthesize when popping
    1:                  * a stacked expression decompilation.  We auto-parenthesize
    1:                  * only when JSOP_POP is annotated with SRC_PCDELTA, meaning
    1:                  * comma operator.
    1:                  */
    1:                 op = JSOP_POPV;
    1:                 /* FALL THROUGH */
    1: 
    1:               case JSOP_POPV:
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
    1:                   case SRC_FOR:
    1:                     /* Force parens around 'in' expression at 'for' front. */
    1:                     if (ss->opcodes[ss->top-1] == JSOP_IN)
    1:                         op = JSOP_LSH;
    1:                     rval = POP_STR();
    1:                     todo = -2;
    1:                     goto do_forloop;
    1: 
    1:                   case SRC_PCDELTA:
    1:                     /* Comma operator: use JSOP_POP for correct precedence. */
    1:                     op = JSOP_POP;
    1: 
    1:                     /* Pop and save to avoid blowing stack depth budget. */
    1:                     lval = JS_strdup(cx, POP_STR());
    1:                     if (!lval)
    1:                         return NULL;
    1: 
    1:                     /*
    1:                      * The offset tells distance to the end of the right-hand
    1:                      * operand of the comma operator.
    1:                      */
    1:                     done = pc + len;
    1:                     pc += js_GetSrcNoteOffset(sn, 0);
    1:                     len = 0;
    1: 
 1967:                     if (!Decompile(ss, done, pc - done, JSOP_POP)) {
    1:                         JS_free(cx, (char *)lval);
    1:                         return NULL;
    1:                     }
    1: 
    1:                     /* Pop Decompile result and print comma expression. */
    1:                     rval = POP_STR();
    1:                     todo = Sprint(&ss->sprinter, "%s, %s", lval, rval);
    1:                     JS_free(cx, (char *)lval);
    1:                     break;
    1: 
    1:                   case SRC_HIDDEN:
    1:                     /* Hide this pop, it's from a goto in a with or for/in. */
    1:                     todo = -2;
    1:                     break;
    1: 
    1:                   case SRC_DECL:
    1:                     /* This pop is at the end of the let block/expr head. */
    1:                     pc += JSOP_POP_LENGTH;
    1: #if JS_HAS_DESTRUCTURING
    1:                   do_letheadbody:
    1: #endif
    1:                     len = js_GetSrcNoteOffset(sn, 0);
    1:                     if (pc[len] == JSOP_LEAVEBLOCK) {
 9832:                         js_printf(jp, "\tlet (%s) {\n", POP_STR());
    1:                         jp->indent += 4;
    1:                         DECOMPILE_CODE(pc, len);
    1:                         jp->indent -= 4;
    1:                         js_printf(jp, "\t}\n");
    1:                         todo = -2;
    1:                     } else {
    1:                         LOCAL_ASSERT(pc[len] == JSOP_LEAVEBLOCKEXPR);
    1: 
21450:                         lval = JS_strdup(cx, PopStr(ss, JSOP_NOP));
    1:                         if (!lval)
    1:                             return NULL;
    1: 
 1967:                         /* Set saveop to reflect what we will push. */
 1967:                         saveop = JSOP_LEAVEBLOCKEXPR;
 1967:                         if (!Decompile(ss, pc, len, saveop)) {
    1:                             JS_free(cx, (char *)lval);
    1:                             return NULL;
    1:                         }
21450:                         rval = PopStr(ss, JSOP_SETNAME);
    1:                         todo = Sprint(&ss->sprinter,
    1:                                       (*rval == '{')
    1:                                       ? "let (%s) (%s)"
    1:                                       : "let (%s) %s",
    1:                                       lval, rval);
    1:                         JS_free(cx, (char *)lval);
    1:                     }
    1:                     break;
    1: 
    1:                   default:
    1:                     /* Turn off parens around a yield statement. */
    1:                     if (ss->opcodes[ss->top-1] == JSOP_YIELD)
    1:                         op = JSOP_NOP;
    1: 
    1:                     rval = POP_STR();
 1575: 
 1575:                     /*
 1575:                      * Don't emit decompiler-pushed strings that are not
 1575:                      * handled by other opcodes. They are pushed onto the
 1575:                      * stack to help model the interpreter stack and should
 1575:                      * not appear in the decompiler's output.
 1575:                      */
 1575:                     if (*rval != '\0' && (rval[0] != '/' || rval[1] != '*')) {
    1:                         js_printf(jp,
    1:                                   (*rval == '{' ||
    1:                                    (strncmp(rval, js_function_str, 8) == 0 &&
    1:                                     rval[8] == ' '))
    1:                                   ? "\t(%s);\n"
    1:                                   : "\t%s;\n",
    1:                                   rval);
 1575:                     } else {
 1575:                         LOCAL_ASSERT(*rval == '\0' ||
 1575:                                      strcmp(rval, exception_cookie) == 0);
    1:                     }
    1:                     todo = -2;
    1:                     break;
    1:                 }
  351:                 sn = NULL;
    1:                 break;
    1: 
    1:               case JSOP_ENTERWITH:
    1:                 LOCAL_ASSERT(!js_GetSrcNote(jp->script, pc));
    1:                 rval = POP_STR();
 9832:                 js_printf(jp, "\twith (%s) {\n", rval);
    1:                 jp->indent += 4;
    1:                 todo = Sprint(&ss->sprinter, with_cookie);
    1:                 break;
    1: 
    1:               case JSOP_LEAVEWITH:
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 todo = -2;
    1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
    1:                     break;
    1:                 rval = POP_STR();
    1:                 LOCAL_ASSERT(strcmp(rval, with_cookie) == 0);
    1:                 jp->indent -= 4;
    1:                 js_printf(jp, "\t}\n");
    1:                 break;
    1: 
 3235:               case JSOP_ENTERBLOCK:
    1:               {
    1:                 JSAtom **atomv, *smallv[5];
    1:                 JSScopeProperty *sprop;
    1: 
 3235:                 LOAD_OBJECT(0);
    1:                 argc = OBJ_BLOCK_COUNT(cx, obj);
 8336:                 if ((size_t)argc <= JS_ARRAY_LENGTH(smallv)) {
    1:                     atomv = smallv;
    1:                 } else {
    1:                     atomv = (JSAtom **) JS_malloc(cx, argc * sizeof(JSAtom *));
    1:                     if (!atomv)
    1:                         return NULL;
    1:                 }
    1: 
18989:                 MUST_FLOW_THROUGH("enterblock_out");
18594: #define LOCAL_ASSERT_OUT(expr) LOCAL_ASSERT_CUSTOM(expr, ok = JS_FALSE; \
18594:                                                    goto enterblock_out)
    1:                 for (sprop = OBJ_SCOPE(obj)->lastProp; sprop;
    1:                      sprop = sprop->parent) {
    1:                     if (!(sprop->flags & SPROP_HAS_SHORTID))
    1:                         continue;
18594:                     LOCAL_ASSERT_OUT(sprop->shortid < argc);
    1:                     atomv[sprop->shortid] = JSID_TO_ATOM(sprop->id);
    1:                 }
    1:                 ok = JS_TRUE;
    1:                 for (i = 0; i < argc; i++) {
    1:                     atom = atomv[i];
    1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                     if (!rval ||
    1:                         !PushOff(ss, STR2OFF(&ss->sprinter, rval), op)) {
    1:                         ok = JS_FALSE;
    1:                         goto enterblock_out;
    1:                     }
    1:                 }
    1: 
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
    1: #if JS_HAS_BLOCK_SCOPE
    1:                   case SRC_BRACE:
 9832:                     js_printf(jp, "\t{\n");
    1:                     jp->indent += 4;
    1:                     len = js_GetSrcNoteOffset(sn, 0);
 1967:                     ok = Decompile(ss, pc + oplen, len - oplen, JSOP_NOP)
 1967:                          != NULL;
    1:                     if (!ok)
    1:                         goto enterblock_out;
    1:                     jp->indent -= 4;
    1:                     js_printf(jp, "\t}\n");
    1:                     break;
    1: #endif
    1: 
    1:                   case SRC_CATCH:
    1:                     jp->indent -= 4;
 9832:                     js_printf(jp, "\t} catch (");
    1: 
    1:                     pc2 = pc;
    1:                     pc += oplen;
18594:                     LOCAL_ASSERT_OUT(*pc == JSOP_EXCEPTION);
    1:                     pc += JSOP_EXCEPTION_LENGTH;
  990:                     todo = Sprint(&ss->sprinter, exception_cookie);
  990:                     if (todo < 0 || !PushOff(ss, todo, JSOP_EXCEPTION)) {
  990:                         ok = JS_FALSE;
  990:                         goto enterblock_out;
  990:                     }
  990: 
    1:                     if (*pc == JSOP_DUP) {
    1:                         sn2 = js_GetSrcNote(jp->script, pc);
  990:                         if (!sn2 || SN_TYPE(sn2) != SRC_DESTRUCT) {
    1:                             /*
  990:                              * This is a dup to save the exception for later.
  990:                              * It is emitted only when the catch head contains
  190:                              * an exception guard.
    1:                              */
18594:                             LOCAL_ASSERT_OUT(js_GetSrcNoteOffset(sn, 0) != 0);
    1:                             pc += JSOP_DUP_LENGTH;
  990:                             todo = Sprint(&ss->sprinter, exception_cookie);
  990:                             if (todo < 0 ||
  990:                                 !PushOff(ss, todo, JSOP_EXCEPTION)) {
  990:                                 ok = JS_FALSE;
  990:                                 goto enterblock_out;
  990:                             }
  990:                         }
  990:                     }
  990: 
    1: #if JS_HAS_DESTRUCTURING
    1:                     if (*pc == JSOP_DUP) {
    1:                         pc = DecompileDestructuring(ss, pc, endpc);
    1:                         if (!pc) {
    1:                             ok = JS_FALSE;
    1:                             goto enterblock_out;
    1:                         }
18594:                         LOCAL_ASSERT_OUT(*pc == JSOP_POP);
    1:                         pc += JSOP_POP_LENGTH;
    1:                         lval = PopStr(ss, JSOP_NOP);
    1:                         js_puts(jp, lval);
    1:                     } else {
    1: #endif
18594:                         LOCAL_ASSERT_OUT(*pc == JSOP_SETLOCALPOP);
16072:                         i = GET_SLOTNO(pc) - jp->script->nfixed;
    1:                         pc += JSOP_SETLOCALPOP_LENGTH;
    1:                         atom = atomv[i - OBJ_BLOCK_DEPTH(cx, obj)];
    1:                         str = ATOM_TO_STRING(atom);
    1:                         if (!QuoteString(&jp->sprinter, str, 0)) {
    1:                             ok = JS_FALSE;
    1:                             goto enterblock_out;
    1:                         }
    1: #if JS_HAS_DESTRUCTURING
    1:                     }
    1: #endif
    1: 
 1041:                     /*
 1041:                      * Pop the exception_cookie (or its dup in the case of a
 1041:                      * guarded catch head) off the stack now.
 1041:                      */
 1041:                     rval = PopStr(ss, JSOP_NOP);
18594:                     LOCAL_ASSERT_OUT(strcmp(rval, exception_cookie) == 0);
 1041: 
    1:                     len = js_GetSrcNoteOffset(sn, 0);
    1:                     if (len) {
    1:                         len -= PTRDIFF(pc, pc2, jsbytecode);
18594:                         LOCAL_ASSERT_OUT(len > 0);
    1:                         js_printf(jp, " if ");
 1967:                         ok = Decompile(ss, pc, len, JSOP_NOP) != NULL;
    1:                         if (!ok)
    1:                             goto enterblock_out;
    1:                         js_printf(jp, "%s", POP_STR());
    1:                         pc += len;
18594:                         LOCAL_ASSERT_OUT(*pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
    1:                         pc += js_CodeSpec[*pc].length;
    1:                     }
    1: 
    1:                     js_printf(jp, ") {\n");
    1:                     jp->indent += 4;
    1:                     len = 0;
    1:                     break;
 3164:                   default:
 3164:                     break;
    1:                 }
    1: 
    1:                 todo = -2;
    1: 
18594: #undef LOCAL_ASSERT_OUT
    1:               enterblock_out:
    1:                 if (atomv != smallv)
    1:                     JS_free(cx, atomv);
    1:                 if (!ok)
    1:                     return NULL;
    1:               }
 8285:               break;
    1: 
    1:               case JSOP_LEAVEBLOCK:
    1:               case JSOP_LEAVEBLOCKEXPR:
    1:               {
    1:                 uintN top, depth;
    1: 
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 todo = -2;
    1:                 if (op == JSOP_LEAVEBLOCKEXPR) {
    1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_PCBASE);
    1:                     rval = POP_STR();
    1:                 } else if (sn) {
    1:                     LOCAL_ASSERT(op == JSOP_LEAVEBLOCK);
    1:                     if (SN_TYPE(sn) == SRC_HIDDEN)
    1:                         break;
  990: 
  990:                     /*
  990:                      * This JSOP_LEAVEBLOCK must be for a catch block. If sn's
  990:                      * offset does not equal the model stack depth, there must
  990:                      * be a copy of the exception value on the stack due to a
  990:                      * catch guard (see above, the JSOP_ENTERBLOCK + SRC_CATCH
  990:                      * case code).
  990:                      */
    1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_CATCH);
  990:                     if ((uintN)js_GetSrcNoteOffset(sn, 0) != ss->top) {
  990:                         LOCAL_ASSERT((uintN)js_GetSrcNoteOffset(sn, 0)
  990:                                      == ss->top - 1);
  990:                         rval = POP_STR();
  990:                         LOCAL_ASSERT(strcmp(rval, exception_cookie) == 0);
  990:                     }
    1:                 }
    1:                 top = ss->top;
    1:                 depth = GET_UINT16(pc);
    1:                 LOCAL_ASSERT(top >= depth);
    1:                 top -= depth;
    1:                 ss->top = top;
    1:                 ss->sprinter.offset = GetOff(ss, top);
    1:                 if (op == JSOP_LEAVEBLOCKEXPR)
    1:                     todo = SprintCString(&ss->sprinter, rval);
    1:                 break;
    1:               }
    1: 
18308:               case JSOP_CALLUPVAR:
18308:               case JSOP_GETUPVAR:
21449: 
21449:                 if (!jp->fun)
21449:                     JS_GET_SCRIPT_FUNCTION(jp->script, 0, jp->fun);
21449: 
21449:                 if (!jp->localNames)
21449:                     jp->localNames = js_GetLocalNameArray(cx, jp->fun, &jp->pool);
21449: 
18308:                 i = JS_UPVAR_LOCAL_NAME_START(jp->fun) + GET_UINT16(pc);
18475:                 if (i >= JS_GET_LOCAL_NAME_COUNT(jp->fun)) {
18475:                     JSUpvarArray *uva;
21449: #ifdef DEBUG
18475:                     /*
18475:                      * We must be in an eval called from jp->fun, where
18475:                      * jp->script is the eval-compiled script.
19793:                      *
19793:                      * However, it's possible that a js_Invoke already
19793:                      * pushed a frame trying to call js_Construct on an
19793:                      * object that's not a constructor, causing us to be
19793:                      * called with an intervening frame on the stack.
18475:                      */
21449:                     JSStackFrame *fp = cx->fp;
21449:                     if (fp) {
19793:                         while (!(fp->flags & JSFRAME_EVAL))
19793:                             fp = fp->down;
19793:                         JS_ASSERT(fp->script == jp->script);
19793:                         JS_ASSERT(fp->down->fun == jp->fun);
18475:                         JS_ASSERT(FUN_INTERPRETED(jp->fun));
18475:                         JS_ASSERT(jp->script != jp->fun->u.i.script);
18475:                         JS_ASSERT(jp->script->upvarsOffset != 0);
21449:                     }
21449: #endif
18475:                     uva = JS_SCRIPT_UPVARS(jp->script);
18475:                     i = GET_UINT16(pc);
18475:                     i = UPVAR_FRAME_SLOT(uva->vector[i]);
18475:                 }
18308:                 atom = GetArgOrVarAtom(jp, i);
18308:                 goto do_name;
18308: 
    1:               case JSOP_CALLLOCAL:
    1:               case JSOP_GETLOCAL:
16429:                 if (IsVarSlot(jp, pc, &i)) {
16429:                     atom = GetArgOrVarAtom(jp, i);
16429:                     LOCAL_ASSERT(atom);
16429:                     goto do_name;
16429:                 }
    1:                 LOCAL_ASSERT((uintN)i < ss->top);
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
    1:                     pc = DecompileGroupAssignment(ss, pc, endpc, sn, &todo);
    1:                     if (!pc)
    1:                         return NULL;
 1227:                     LOCAL_ASSERT(*pc == JSOP_POPN);
 1227:                     len = oplen = JSOP_POPN_LENGTH;
    1:                     goto end_groupassignment;
    1:                 }
    1: #endif
    1: 
    1:                 rval = GetLocal(ss, i);
    1:                 todo = Sprint(&ss->sprinter, ss_format, VarPrefix(sn), rval);
    1:                 break;
    1: 
    1:               case JSOP_SETLOCAL:
    1:               case JSOP_SETLOCALPOP:
16429:                 if (IsVarSlot(jp, pc, &i)) {
16429:                     atom = GetArgOrVarAtom(jp, i);
16429:                     LOCAL_ASSERT(atom);
16429:                     goto do_setname;
16429:                 }
21865:                 lval = GetLocal(ss, i);
    1:                 rval = POP_STR();
    1:                 goto do_setlval;
    1: 
    1:               case JSOP_INCLOCAL:
    1:               case JSOP_DECLOCAL:
16429:                 if (IsVarSlot(jp, pc, &i)) {
16429:                     atom = GetArgOrVarAtom(jp, i);
16429:                     LOCAL_ASSERT(atom);
16429:                     goto do_incatom;
16429:                 }
    1:                 lval = GetLocal(ss, i);
    1:                 goto do_inclval;
    1: 
    1:               case JSOP_LOCALINC:
    1:               case JSOP_LOCALDEC:
16429:                 if (IsVarSlot(jp, pc, &i)) {
16429:                     atom = GetArgOrVarAtom(jp, i);
16429:                     LOCAL_ASSERT(atom);
16429:                     goto do_atominc;
16429:                 }
    1:                 lval = GetLocal(ss, i);
    1:                 goto do_lvalinc;
    1: 
    1:               case JSOP_RETRVAL:
    1:                 todo = -2;
    1:                 break;
    1: 
 1967:               case JSOP_RETURN:
 8179:                 LOCAL_ASSERT(jp->fun);
 8179:                 fun = jp->fun;
 1967:                 if (fun->flags & JSFUN_EXPR_CLOSURE) {
20928:                     /* Turn on parens around comma-expression here. */
20928:                     op = JSOP_SETNAME;
 1967:                     rval = POP_STR();
 1967:                     js_printf(jp, (*rval == '{') ? "(%s)%s" : ss_format,
 1967:                               rval,
 1967:                               ((fun->flags & JSFUN_LAMBDA) || !fun->atom)
 1967:                               ? ""
 1967:                               : ";");
 1967:                     todo = -2;
 1967:                     break;
 1967:                 }
 1967:                 /* FALL THROUGH */
 1967: 
    1:               case JSOP_SETRVAL:
    1:                 rval = POP_STR();
    1:                 if (*rval != '\0')
    1:                     js_printf(jp, "\t%s %s;\n", js_return_str, rval);
    1:                 else
    1:                     js_printf(jp, "\t%s;\n", js_return_str);
    1:                 todo = -2;
    1:                 break;
    1: 
    1: #if JS_HAS_GENERATORS
    1:               case JSOP_YIELD:
 1760: #if JS_HAS_GENERATOR_EXPRS
 1760:                 if (!ss->inGenExp || !(sn = js_GetSrcNote(jp->script, pc)))
 1760: #endif
 1760:                 {
 1967:                     /* Turn off most parens. */
 1967:                     op = JSOP_SETNAME;
    1:                     rval = POP_STR();
    1:                     todo = (*rval != '\0')
    1:                            ? Sprint(&ss->sprinter,
    1:                                     (strncmp(rval, js_yield_str, 5) == 0 &&
    1:                                      (rval[5] == ' ' || rval[5] == '\0'))
    1:                                     ? "%s (%s)"
    1:                                     : "%s %s",
    1:                                     js_yield_str, rval)
    1:                            : SprintCString(&ss->sprinter, js_yield_str);
    1:                     break;
 1577:                 }
 1760: #if JS_HAS_GENERATOR_EXPRS
 1577:                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_HIDDEN);
 1577:                 /* FALL THROUGH */
 1760: #endif
    1: 
    1:               case JSOP_ARRAYPUSH:
    1:               {
 1577:                 uintN pos, forpos;
    1:                 ptrdiff_t start;
    1: 
 1967:                 /* Turn off most parens. */
 1967:                 op = JSOP_SETNAME;
 1967: 
 1577:                 /* Pop the expression being pushed or yielded. */
    1:                 rval = POP_STR();
 1577: 
 1577:                 /*
20943:                  * Skip the for loop head stacked by JSOP_FORLOCAL until we hit
20943:                  * a block local slot (note empty destructuring patterns result
20943:                  * in unit-count blocks).
 1577:                  */
    1:                 pos = ss->top;
20943:                 while (pos != 0) {
20943:                     op = (JSOp) ss->opcodes[--pos];
21441:                     if (op == JSOP_ENTERBLOCK)
 1577:                         break;
 1577:                 }
20943:                 JS_ASSERT(op == JSOP_ENTERBLOCK);
 1577: 
 1577:                 /*
20943:                  * Here, forpos must index the space before the left-most |for|
20943:                  * in the single string of accumulated |for| heads and optional
 1577:                  * final |if (condition)|.
 1577:                  */
21441:                 forpos = pos + 2;
 1577:                 LOCAL_ASSERT(forpos < ss->top);
 1577: 
 1577:                 /*
20943:                  * Now move pos downward over the block's local slots. Even an
20943:                  * empty destructuring pattern has one (dummy) local.
 1577:                  */
    1:                 while (ss->opcodes[pos] == JSOP_ENTERBLOCK) {
    1:                     if (pos == 0)
    1:                         break;
    1:                     --pos;
    1:                 }
20945:                 JS_ASSERT_IF(saveop == JSOP_ARRAYPUSH,
20945:                              jp->script->nfixed + pos == GET_UINT16(pc));
 1577: 
 1760: #if JS_HAS_GENERATOR_EXPRS
 1577:                 if (saveop == JSOP_YIELD) {
 1577:                     /*
 1577:                      * Generator expression: decompile just rval followed by
 1577:                      * the string starting at forpos. Leave the result string
 1577:                      * in ss->offsets[0] so it can be recovered by our caller
 1577:                      * (the JSOP_ANONFUNOBJ with SRC_GENEXP case). Bump the
 1577:                      * top of stack to balance yield, which is an expression
 1577:                      * (so has neutral stack balance).
 1577:                      */
 1577:                     LOCAL_ASSERT(pos == 0);
 1577:                     xval = OFF2STR(&ss->sprinter, ss->offsets[forpos]);
 1577:                     ss->sprinter.offset = PAREN_SLOP;
 1577:                     todo = Sprint(&ss->sprinter, ss_format, rval, xval);
 1577:                     if (todo < 0)
 1577:                         return NULL;
 1577:                     ss->offsets[0] = todo;
 1577:                     ++ss->top;
 1577:                     return pc;
 1577:                 }
 1760: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: 
 1577:                 /*
 1577:                  * Array comprehension: retract the sprinter to the beginning
 1577:                  * of the array initialiser and decompile "[<rval> for ...]".
 1577:                  */
    1:                 LOCAL_ASSERT(ss->opcodes[pos] == JSOP_NEWINIT);
    1:                 start = ss->offsets[pos];
    1:                 LOCAL_ASSERT(ss->sprinter.base[start] == '[' ||
    1:                              ss->sprinter.base[start] == '#');
 1577:                 LOCAL_ASSERT(forpos < ss->top);
 1577:                 xval = OFF2STR(&ss->sprinter, ss->offsets[forpos]);
    1:                 lval = OFF2STR(&ss->sprinter, start);
    1:                 RETRACT(&ss->sprinter, lval);
 1577: 
20943:                 todo = Sprint(&ss->sprinter, sss_format, lval, rval, xval);
    1:                 if (todo < 0)
    1:                     return NULL;
 1577:                 ss->offsets[pos] = todo;
    1:                 todo = -2;
    1:                 break;
    1:               }
    1: #endif
    1: 
    1:               case JSOP_THROWING:
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_THROW:
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 todo = -2;
    1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
    1:                     break;
    1:                 rval = POP_STR();
 1154:                 js_printf(jp, "\t%s %s;\n", js_throw_str, rval);
    1:                 break;
    1: 
21441:               case JSOP_ITER:
21441:                 foreach = (pc[1] & (JSITER_FOREACH | JSITER_KEYVALUE)) ==
21441:                           JSITER_FOREACH;
21441:                 todo = SprintCString(&ss->sprinter, iter_cookie);
21441:                 break;
21441: 
21441:               case JSOP_NEXTITER:
21441:                 JS_NOT_REACHED("JSOP_NEXTITER");
21441:                 break;
21441: 
21441:               case JSOP_ENDITER:
21441:                 sn = js_GetSrcNote(jp->script, pc);
21441:                 todo = -2;
21441:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
21441:                     break;
21441:                 (void) PopOff(ss, op);
21441:                 (void) PopOff(ss, op);
21441:                 break;
21441: 
    1:               case JSOP_GOTO:
    1:               case JSOP_GOTOX:
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
20943:                   case SRC_FOR_IN:
20943:                     /*
20943:                      * The loop back-edge carries +1 stack balance, for the
20943:                      * flag processed by JSOP_IFNE. We do not decompile the
21441:                      * JSOP_IFNE, and instead push the left-hand side of 'in'
21441:                      * after the loop edge in this stack slot (the JSOP_FOR*
21441:                      * opcodes' decompilers do this pushing).
20943:                      */
20943:                     cond = GetJumpOffset(pc, pc);
20943:                     next = js_GetSrcNoteOffset(sn, 0);
20943:                     tail = js_GetSrcNoteOffset(sn, 1);
21441:                     JS_ASSERT(pc[cond] == JSOP_NEXTITER);
20943:                     DECOMPILE_CODE(pc + oplen, next - oplen);
21441:                     lval = POP_STR();
21436:                     if (ss->inArrayInit || ss->inGenExp) {
21441:                         (void) PopOff(ss, JSOP_NOP);
21441:                         rval = TOP_STR();
21441:                         LOCAL_ASSERT(ss->top >= 2);
21441:                         if (ss->opcodes[ss->top - 2] == JSOP_FORLOCAL) {
21441:                             ss->sprinter.offset = ss->offsets[ss->top - 1] - PAREN_SLOP;
20943:                             if (Sprint(&ss->sprinter, " %s (%s in %s)",
20943:                                        foreach ? js_for_each_str : js_for_str,
20943:                                        lval, rval) < 0) {
20943:                                 return NULL;
20943:                             }
20943:                             
20943:                             /*
20943:                              * Do not AddParentSlop here, as we will push the
20943:                              * top-most offset again, which will add paren slop
20943:                              * for us. We must push to balance the stack budget
20943:                              * when nesting for heads in a comprehension.
20943:                              */
20943:                             todo = ss->offsets[ss->top - 1];
20943:                         } else {
21441:                             LOCAL_ASSERT(ss->opcodes[ss->top - 2] == JSOP_ENTERBLOCK);
20943:                             todo = Sprint(&ss->sprinter, " %s (%s in %s)",
20943:                                           foreach ? js_for_each_str : js_for_str,
20943:                                           lval, rval);
20943:                         }
20943:                         if (todo < 0 || !PushOff(ss, todo, JSOP_FORLOCAL))
20943:                             return NULL;
20943:                         DECOMPILE_CODE(pc + next, cond - next);
20943:                     } else {
20943:                         /*
20943:                          * As above, rval or an extension of it must remain
20943:                          * stacked during loop body decompilation.
20943:                          */
21441:                         rval = GetStr(ss, ss->top - 2);
20943:                         js_printf(jp, "\t%s (%s in %s) {\n",
20943:                                   foreach ? js_for_each_str : js_for_str,
20943:                                   lval, rval);
20943:                         jp->indent += 4;
20943:                         DECOMPILE_CODE(pc + next, cond - next);
20943:                         jp->indent -= 4;
20943:                         js_printf(jp, "\t}\n");
20943:                     }
20943:                     pc += tail;
20943:                     LOCAL_ASSERT(*pc == JSOP_IFNE || *pc == JSOP_IFNEX);
20943:                     len = js_CodeSpec[*pc].length;
20943:                     break;
20943: 
    1:                   case SRC_WHILE:
    1:                     cond = GetJumpOffset(pc, pc);
    1:                     tail = js_GetSrcNoteOffset(sn, 0);
    1:                     DECOMPILE_CODE(pc + cond, tail - cond);
20928:                     js_printf(jp, "\twhile (%s) {\n", POP_COND_STR());
    1:                     jp->indent += 4;
    1:                     DECOMPILE_CODE(pc + oplen, cond - oplen);
    1:                     jp->indent -= 4;
    1:                     js_printf(jp, "\t}\n");
    1:                     pc += tail;
    1:                     LOCAL_ASSERT(*pc == JSOP_IFNE || *pc == JSOP_IFNEX);
    1:                     len = js_CodeSpec[*pc].length;
    1:                     todo = -2;
    1:                     break;
    1: 
    1:                   case SRC_CONT2LABEL:
 4342:                     GET_SOURCE_NOTE_ATOM(sn, atom);
    1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                     if (!rval)
    1:                         return NULL;
    1:                     RETRACT(&ss->sprinter, rval);
    1:                     js_printf(jp, "\tcontinue %s;\n", rval);
    1:                     break;
    1: 
    1:                   case SRC_CONTINUE:
    1:                     js_printf(jp, "\tcontinue;\n");
    1:                     break;
    1: 
    1:                   case SRC_BREAK2LABEL:
 4342:                     GET_SOURCE_NOTE_ATOM(sn, atom);
    1:                     rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                     if (!rval)
    1:                         return NULL;
    1:                     RETRACT(&ss->sprinter, rval);
    1:                     js_printf(jp, "\tbreak %s;\n", rval);
    1:                     break;
    1: 
    1:                   case SRC_HIDDEN:
    1:                     break;
    1: 
    1:                   default:
    1:                     js_printf(jp, "\tbreak;\n");
    1:                     break;
    1:                 }
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_IFEQ:
    1:               case JSOP_IFEQX:
    1:               {
    1:                 JSBool elseif = JS_FALSE;
    1: 
    1:               if_again:
    1:                 len = GetJumpOffset(pc, pc);
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1: 
    1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
    1:                   case SRC_IF:
    1:                   case SRC_IF_ELSE:
20928:                     rval = POP_COND_STR();
 1577:                     if (ss->inArrayInit || ss->inGenExp) {
    1:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_IF);
 1577:                         ss->sprinter.offset -= PAREN_SLOP;
    1:                         if (Sprint(&ss->sprinter, " if (%s)", rval) < 0)
    1:                             return NULL;
 1577:                         AddParenSlop(ss);
    1:                     } else {
 9832:                         js_printf(jp,
    1:                                   elseif ? " if (%s) {\n" : "\tif (%s) {\n",
    1:                                   rval);
    1:                         jp->indent += 4;
    1:                     }
    1: 
    1:                     if (SN_TYPE(sn) == SRC_IF) {
    1:                         DECOMPILE_CODE(pc + oplen, len - oplen);
    1:                     } else {
 1577:                         LOCAL_ASSERT(!ss->inArrayInit && !ss->inGenExp);
    1:                         tail = js_GetSrcNoteOffset(sn, 0);
    1:                         DECOMPILE_CODE(pc + oplen, tail - oplen);
    1:                         jp->indent -= 4;
    1:                         pc += tail;
    1:                         LOCAL_ASSERT(*pc == JSOP_GOTO || *pc == JSOP_GOTOX);
    1:                         oplen = js_CodeSpec[*pc].length;
    1:                         len = GetJumpOffset(pc, pc);
    1:                         js_printf(jp, "\t} else");
    1: 
    1:                         /*
    1:                          * If the second offset for sn is non-zero, it tells
    1:                          * the distance from the goto around the else, to the
    1:                          * ifeq for the if inside the else that forms an "if
    1:                          * else if" chain.  Thus cond spans the condition of
    1:                          * the second if, so we simply decompile it and start
    1:                          * over at label if_again.
    1:                          */
    1:                         cond = js_GetSrcNoteOffset(sn, 1);
    1:                         if (cond != 0) {
    1:                             DECOMPILE_CODE(pc + oplen, cond - oplen);
    1:                             pc += cond;
    1:                             elseif = JS_TRUE;
    1:                             goto if_again;
    1:                         }
    1: 
 9832:                         js_printf(jp, " {\n");
    1:                         jp->indent += 4;
    1:                         DECOMPILE_CODE(pc + oplen, len - oplen);
    1:                     }
    1: 
 1577:                     if (!ss->inArrayInit && !ss->inGenExp) {
    1:                         jp->indent -= 4;
    1:                         js_printf(jp, "\t}\n");
    1:                     }
    1:                     todo = -2;
    1:                     break;
    1: 
    1:                   case SRC_COND:
    1:                     xval = JS_strdup(cx, POP_STR());
    1:                     if (!xval)
    1:                         return NULL;
    1:                     len = js_GetSrcNoteOffset(sn, 0);
    1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
    1:                     lval = JS_strdup(cx, POP_STR());
    1:                     if (!lval) {
    1:                         JS_free(cx, (void *)xval);
    1:                         return NULL;
    1:                     }
    1:                     pc += len;
    1:                     LOCAL_ASSERT(*pc == JSOP_GOTO || *pc == JSOP_GOTOX);
    1:                     oplen = js_CodeSpec[*pc].length;
    1:                     len = GetJumpOffset(pc, pc);
    1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
    1:                     rval = POP_STR();
    1:                     todo = Sprint(&ss->sprinter, "%s ? %s : %s",
    1:                                   xval, lval, rval);
    1:                     JS_free(cx, (void *)xval);
    1:                     JS_free(cx, (void *)lval);
    1:                     break;
    1: 
    1:                   default:
    1:                     break;
    1:                 }
    1:                 break;
    1:               }
    1: 
    1:               case JSOP_IFNE:
    1:               case JSOP_IFNEX:
    1:                 LOCAL_ASSERT(0);
    1:                 break;
    1: 
    1:               case JSOP_OR:
    1:               case JSOP_ORX:
    1:                 xval = "||";
    1: 
    1:               do_logical_connective:
    1:                 /* Top of stack is the first clause in a disjunction (||). */
    1:                 lval = JS_strdup(cx, POP_STR());
    1:                 if (!lval)
    1:                     return NULL;
    1:                 done = pc + GetJumpOffset(pc, pc);
    1:                 pc += len;
    1:                 len = PTRDIFF(done, pc, jsbytecode);
 1967:                 if (!Decompile(ss, pc, len, op)) {
 1967:                     JS_free(cx, (char *)lval);
 1967:                     return NULL;
 1967:                 }
    1:                 rval = POP_STR();
    1:                 if (jp->pretty &&
    1:                     jp->indent + 4 + strlen(lval) + 4 + strlen(rval) > 75) {
    1:                     rval = JS_strdup(cx, rval);
    1:                     if (!rval) {
    1:                         tail = -1;
    1:                     } else {
    1:                         todo = Sprint(&ss->sprinter, "%s %s\n", lval, xval);
    1:                         tail = Sprint(&ss->sprinter, "%*s%s",
    1:                                       jp->indent + 4, "", rval);
    1:                         JS_free(cx, (char *)rval);
    1:                     }
    1:                     if (tail < 0)
    1:                         todo = -1;
    1:                 } else {
    1:                     todo = Sprint(&ss->sprinter, "%s %s %s", lval, xval, rval);
    1:                 }
    1:                 JS_free(cx, (char *)lval);
    1:                 break;
    1: 
    1:               case JSOP_AND:
    1:               case JSOP_ANDX:
    1:                 xval = "&&";
    1:                 goto do_logical_connective;
    1: 
    1:               case JSOP_FORARG:
20943:                 sn = NULL;
20943:                 i = GET_ARGNO(pc);
20943:                 goto do_forvarslot;
    1: 
16429:               case JSOP_FORLOCAL:
20943:                 sn = js_GetSrcNote(jp->script, pc);
20943:                 if (!IsVarSlot(jp, pc, &i)) {
20943:                     JS_ASSERT(op == JSOP_FORLOCAL);
20943:                     todo = Sprint(&ss->sprinter, ss_format, VarPrefix(sn), GetStr(ss, i));
20943:                     break;
20943:                 }
20943: 
20943:               do_forvarslot:
16429:                 atom = GetArgOrVarAtom(jp, i);
    1:                 LOCAL_ASSERT(atom);
20943:                 todo = SprintCString(&ss->sprinter, VarPrefix(sn));
20943:                 if (todo < 0 || !QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0))
20943:                     return NULL;
20943:                 break;
    1: 
    1:               case JSOP_FORNAME:
    1:                 LOAD_ATOM(0);
    1:                 sn = js_GetSrcNote(jp->script, pc);
20943:                 todo = SprintCString(&ss->sprinter, VarPrefix(sn));
20943:                 if (todo < 0 || !QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0))
20943:                     return NULL;
20943:                 break;
    1: 
    1:               case JSOP_FORPROP:
    1:                 xval = NULL;
    1:                 LOAD_ATOM(0);
    1:                 if (!ATOM_IS_IDENTIFIER(atom)) {
    1:                     xval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
    1:                                        (jschar)'\'');
    1:                     if (!xval)
    1:                         return NULL;
    1:                 }
    1:                 lval = POP_STR();
20959:                 if (xval) {
20959:                     JS_ASSERT(*lval);
20959:                     todo = Sprint(&ss->sprinter, index_format, lval, xval);
20959:                 } else {
20943:                     todo = Sprint(&ss->sprinter, ss_format, lval, *lval ? "." : "");
    1:                     if (todo < 0)
    1:                         return NULL;
20943:                     if (!QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0))
    1:                         return NULL;
20959:                 }
    1:                 break;
    1: 
    1:               case JSOP_FORELEM:
    1:                 todo = SprintCString(&ss->sprinter, forelem_cookie);
    1:                 break;
    1: 
    1:               case JSOP_ENUMELEM:
    1:               case JSOP_ENUMCONSTELEM:
    1:                 /*
    1:                  * The stack has the object under the (top) index expression.
    1:                  * The "rval" property id is underneath those two on the stack.
    1:                  * The for loop body net and gross lengths can now be adjusted
    1:                  * to account for the length of the indexing expression that
    1:                  * came after JSOP_FORELEM and before JSOP_ENUMELEM.
    1:                  */
    1:                 atom = NULL;
  351:                 op = JSOP_NOP;          /* turn off parens around xval */
    1:                 xval = POP_STR();
    1:                 op = JSOP_GETELEM;      /* lval must have high precedence */
    1:                 lval = POP_STR();
    1:                 op = saveop;
    1:                 rval = POP_STR();
    1:                 LOCAL_ASSERT(strcmp(rval, forelem_cookie) == 0);
20943:                 if (*xval == '\0') {
20943:                     todo = SprintCString(&ss->sprinter, lval);
20943:                 } else {
20943:                     todo = Sprint(&ss->sprinter,
20943:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
20943:                                   ? dot_format
20943:                                   : index_format,
20943:                                   lval, xval);
20943:                 }
20943:                 break;
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:               case JSOP_GETTER:
    1:               case JSOP_SETTER:
    1:                 todo = -2;
    1:                 break;
    1: #endif
    1: 
    1:               case JSOP_DUP2:
    1:                 rval = GetStr(ss, ss->top-2);
    1:                 todo = SprintCString(&ss->sprinter, rval);
 3164:                 if (todo < 0 || !PushOff(ss, todo,
 3164:                                          (JSOp) ss->opcodes[ss->top-2])) {
    1:                     return NULL;
 3164:                 }
    1:                 /* FALL THROUGH */
    1: 
    1:               case JSOP_DUP:
    1: #if JS_HAS_DESTRUCTURING
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 if (sn) {
    1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_DESTRUCT);
    1:                     pc = DecompileDestructuring(ss, pc, endpc);
    1:                     if (!pc)
    1:                         return NULL;
    1:                     len = 0;
    1:                     lval = POP_STR();
    1:                     op = saveop = JSOP_ENUMELEM;
    1:                     rval = POP_STR();
    1: 
    1:                     if (strcmp(rval, forelem_cookie) == 0) {
20943:                         todo = Sprint(&ss->sprinter, ss_format,
20943:                                       VarPrefix(sn), lval);
20943: 
20943:                         // Skip POP so the SRC_FOR_IN code can pop for itself.
20943:                         if (*pc == JSOP_POP)
20943:                             len = JSOP_POP_LENGTH;
20943:                     } else {
    1:                         todo = Sprint(&ss->sprinter, "%s%s = %s",
    1:                                       VarPrefix(sn), lval, rval);
20943:                     }
    1:                     break;
    1:                 }
    1: #endif
    1: 
    1:                 rval = GetStr(ss, ss->top-1);
 3164:                 saveop = (JSOp) ss->opcodes[ss->top-1];
    1:                 todo = SprintCString(&ss->sprinter, rval);
    1:                 break;
    1: 
    1:               case JSOP_SETARG:
16429:                 atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
    1:                 LOCAL_ASSERT(atom);
    1:                 goto do_setname;
    1: 
    1:               case JSOP_SETCONST:
    1:               case JSOP_SETNAME:
    1:               case JSOP_SETGVAR:
    1:                 LOAD_ATOM(0);
    1: 
    1:               do_setname:
    1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                 if (!lval)
    1:                     return NULL;
    1:                 rval = POP_STR();
    1:                 if (op == JSOP_SETNAME)
    1:                     (void) PopOff(ss, op);
    1: 
    1:               do_setlval:
    1:                 sn = js_GetSrcNote(jp->script, pc - 1);
    1:                 if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
    1:                     todo = Sprint(&ss->sprinter, "%s %s= %s",
    1:                                   lval,
    1:                                   (lastop == JSOP_GETTER)
    1:                                   ? js_getter_str
    1:                                   : (lastop == JSOP_SETTER)
    1:                                   ? js_setter_str
 1154:                                   : CodeToken[lastop],
    1:                                   rval);
    1:                 } else {
    1:                     sn = js_GetSrcNote(jp->script, pc);
    1:                     todo = Sprint(&ss->sprinter, "%s%s = %s",
    1:                                   VarPrefix(sn), lval, rval);
    1:                 }
    1:                 if (op == JSOP_SETLOCALPOP) {
    1:                     if (!PushOff(ss, todo, saveop))
    1:                         return NULL;
    1:                     rval = POP_STR();
    1:                     LOCAL_ASSERT(*rval != '\0');
    1:                     js_printf(jp, "\t%s;\n", rval);
    1:                     todo = -2;
    1:                 }
    1:                 break;
    1: 
    1:               case JSOP_NEW:
    1:               case JSOP_CALL:
    1:               case JSOP_EVAL:
21452:               case JSOP_APPLY:
    1: #if JS_HAS_LVALUE_RETURN
    1:               case JSOP_SETCALL:
    1: #endif
 1967:                 /* Turn off most parens (all if there's only one argument). */
    1:                 argc = GET_ARGC(pc);
 1967:                 op = (argc == 1) ? JSOP_NOP : JSOP_SETNAME;
    1:                 argv = (char **)
    1:                     JS_malloc(cx, (size_t)(argc + 1) * sizeof *argv);
    1:                 if (!argv)
    1:                     return NULL;
    1: 
    1:                 ok = JS_TRUE;
    1:                 for (i = argc; i > 0; i--) {
    1:                     argv[i] = JS_strdup(cx, POP_STR());
 2567:                     if (!argv[i])
    1:                         ok = JS_FALSE;
    1:                 }
    1: 
    1:                 /* Skip the JSOP_PUSHOBJ-created empty string. */
    1:                 LOCAL_ASSERT(ss->top >= 2);
    1:                 (void) PopOff(ss, op);
    1: 
  350:                 /*
  350:                  * Special case: new (x(y)(z)) must be parenthesized like so.
  350:                  * Same for new (x(y).z) -- contrast with new x(y).z.
20928:                  * See PROPAGATE_CALLNESS.
  350:                  */
 3164:                 op = (JSOp) ss->opcodes[ss->top-1];
  350:                 lval = PopStr(ss,
  350:                               (saveop == JSOP_NEW &&
21452:                                (op == JSOP_CALL || 
21452:                                 op == JSOP_EVAL ||
21452:                                 op == JSOP_APPLY ||
  350:                                 (js_CodeSpec[op].format & JOF_CALLOP)))
  350:                               ? JSOP_NAME
  350:                               : saveop);
    1:                 op = saveop;
  350: 
  350:                 argv[0] = JS_strdup(cx, lval);
    1:                 if (!argv[i])
    1:                     ok = JS_FALSE;
    1: 
    1:                 lval = "(", rval = ")";
    1:                 if (op == JSOP_NEW) {
    1:                     if (argc == 0)
    1:                         lval = rval = "";
    1:                     todo = Sprint(&ss->sprinter, "%s %s%s",
    1:                                   js_new_str, argv[0], lval);
    1:                 } else {
    1:                     todo = Sprint(&ss->sprinter, ss_format,
    1:                                   argv[0], lval);
    1:                 }
    1:                 if (todo < 0)
    1:                     ok = JS_FALSE;
    1: 
    1:                 for (i = 1; i <= argc; i++) {
    1:                     if (!argv[i] ||
    1:                         Sprint(&ss->sprinter, ss_format,
    1:                                argv[i], (i < argc) ? ", " : "") < 0) {
    1:                         ok = JS_FALSE;
    1:                         break;
    1:                     }
    1:                 }
    1:                 if (Sprint(&ss->sprinter, rval) < 0)
    1:                     ok = JS_FALSE;
    1: 
    1:                 for (i = 0; i <= argc; i++) {
    1:                     if (argv[i])
    1:                         JS_free(cx, argv[i]);
    1:                 }
    1:                 JS_free(cx, argv);
    1:                 if (!ok)
    1:                     return NULL;
    1: #if JS_HAS_LVALUE_RETURN
    1:                 if (op == JSOP_SETCALL) {
    1:                     if (!PushOff(ss, todo, op))
    1:                         return NULL;
    1:                     todo = Sprint(&ss->sprinter, "");
    1:                 }
    1: #endif
    1:                 break;
    1: 
    1:               case JSOP_DELNAME:
    1:                 LOAD_ATOM(0);
    1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                 if (!lval)
    1:                     return NULL;
    1:                 RETRACT(&ss->sprinter, lval);
    1:               do_delete_lval:
    1:                 todo = Sprint(&ss->sprinter, "%s %s", js_delete_str, lval);
    1:                 break;
    1: 
    1:               case JSOP_DELPROP:
    1:                 GET_ATOM_QUOTE_AND_FMT("%s %s[%s]", "%s %s.%s", rval);
20928:                 op = JSOP_GETPROP;
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, fmt, js_delete_str, lval, rval);
    1:                 break;
    1: 
    1:               case JSOP_DELELEM:
    1:                 op = JSOP_NOP;          /* turn off parens */
    1:                 xval = POP_STR();
20928:                 op = JSOP_GETPROP;
    1:                 lval = POP_STR();
    1:                 if (*xval == '\0')
    1:                     goto do_delete_lval;
    1:                 todo = Sprint(&ss->sprinter,
 1761:                               (JOF_OPMODE(lastop) == JOF_XMLNAME)
    1:                               ? "%s %s.%s"
    1:                               : "%s %s[%s]",
    1:                               js_delete_str, lval, xval);
    1:                 break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:               case JSOP_DELDESC:
    1:                 xval = POP_STR();
20928:                 op = JSOP_GETPROP;
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "%s %s..%s",
    1:                               js_delete_str, lval, xval);
    1:                 break;
    1: #endif
    1: 
    1:               case JSOP_TYPEOFEXPR:
    1:               case JSOP_TYPEOF:
    1:               case JSOP_VOID:
    1:                 rval = POP_STR();
 1154:                 todo = Sprint(&ss->sprinter, "%s %s",
 1154:                               (op == JSOP_VOID) ? js_void_str : js_typeof_str,
 1154:                               rval);
    1:                 break;
    1: 
    1:               case JSOP_INCARG:
    1:               case JSOP_DECARG:
16429:                 atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
    1:                 LOCAL_ASSERT(atom);
    1:                 goto do_incatom;
    1: 
    1:               case JSOP_INCNAME:
    1:               case JSOP_DECNAME:
    1:               case JSOP_INCGVAR:
    1:               case JSOP_DECGVAR:
    1:                 LOAD_ATOM(0);
    1:               do_incatom:
    1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                 if (!lval)
    1:                     return NULL;
    1:                 RETRACT(&ss->sprinter, lval);
    1:               do_inclval:
    1:                 todo = Sprint(&ss->sprinter, ss_format,
    1:                               js_incop_strs[!(cs->format & JOF_INC)], lval);
    1:                 break;
    1: 
    1:               case JSOP_INCPROP:
    1:               case JSOP_DECPROP:
    1:                 GET_ATOM_QUOTE_AND_FMT(preindex_format, predot_format, rval);
    1: 
    1:                 /*
    1:                  * Force precedence below the numeric literal opcodes, so that
    1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
    1:                  * around the left-hand side of dot.
    1:                  */
    1:                 op = JSOP_GETPROP;
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, fmt,
    1:                               js_incop_strs[!(cs->format & JOF_INC)],
    1:                               lval, rval);
    1:                 break;
    1: 
    1:               case JSOP_INCELEM:
    1:               case JSOP_DECELEM:
    1:                 op = JSOP_NOP;          /* turn off parens */
    1:                 xval = POP_STR();
    1:                 op = JSOP_GETELEM;
    1:                 lval = POP_STR();
    1:                 if (*xval != '\0') {
    1:                     todo = Sprint(&ss->sprinter,
 1761:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
    1:                                   ? predot_format
    1:                                   : preindex_format,
    1:                                   js_incop_strs[!(cs->format & JOF_INC)],
    1:                                   lval, xval);
    1:                 } else {
    1:                     todo = Sprint(&ss->sprinter, ss_format,
    1:                                   js_incop_strs[!(cs->format & JOF_INC)], lval);
    1:                 }
    1:                 break;
    1: 
    1:               case JSOP_ARGINC:
    1:               case JSOP_ARGDEC:
16429:                 atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
    1:                 LOCAL_ASSERT(atom);
    1:                 goto do_atominc;
    1: 
    1:               case JSOP_NAMEINC:
    1:               case JSOP_NAMEDEC:
    1:               case JSOP_GVARINC:
    1:               case JSOP_GVARDEC:
    1:                 LOAD_ATOM(0);
    1:               do_atominc:
    1:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                 if (!lval)
    1:                     return NULL;
    1:                 RETRACT(&ss->sprinter, lval);
    1:               do_lvalinc:
    1:                 todo = Sprint(&ss->sprinter, ss_format,
    1:                               lval, js_incop_strs[!(cs->format & JOF_INC)]);
    1:                 break;
    1: 
    1:               case JSOP_PROPINC:
    1:               case JSOP_PROPDEC:
    1:                 GET_ATOM_QUOTE_AND_FMT(postindex_format, postdot_format, rval);
    1: 
    1:                 /*
    1:                  * Force precedence below the numeric literal opcodes, so that
    1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
    1:                  * around the left-hand side of dot.
    1:                  */
    1:                 op = JSOP_GETPROP;
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, fmt, lval, rval,
    1:                               js_incop_strs[!(cs->format & JOF_INC)]);
    1:                 break;
    1: 
    1:               case JSOP_ELEMINC:
    1:               case JSOP_ELEMDEC:
    1:                 op = JSOP_NOP;          /* turn off parens */
    1:                 xval = POP_STR();
    1:                 op = JSOP_GETELEM;
    1:                 lval = POP_STR();
    1:                 if (*xval != '\0') {
    1:                     todo = Sprint(&ss->sprinter,
 1761:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
    1:                                   ? postdot_format
    1:                                   : postindex_format,
    1:                                   lval, xval,
    1:                                   js_incop_strs[!(cs->format & JOF_INC)]);
    1:                 } else {
    1:                     todo = Sprint(&ss->sprinter, ss_format,
    1:                                   lval, js_incop_strs[!(cs->format & JOF_INC)]);
    1:                 }
    1:                 break;
    1: 
11377:               case JSOP_LENGTH:
11377:                 fmt = dot_format;
11377:                 rval = js_length_str;
11377:                 goto do_getprop_lval;
11377: 
    1:               case JSOP_GETPROP2:
    1:                 op = JSOP_GETPROP;
    1:                 (void) PopOff(ss, lastop);
    1:                 /* FALL THROUGH */
    1: 
    1:               case JSOP_CALLPROP:
    1:               case JSOP_GETPROP:
    1:               case JSOP_GETXPROP:
    1:                 LOAD_ATOM(0);
    1: 
    1:               do_getprop:
    1:                 GET_QUOTE_AND_FMT(index_format, dot_format, rval);
11377:               do_getprop_lval:
20928:                 PROPAGATE_CALLNESS();
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, fmt, lval, rval);
    1:                 break;
    1: 
 8285:               case JSOP_GETTHISPROP:
 8285:                 LOAD_ATOM(0);
    1:                 GET_QUOTE_AND_FMT(index_format, dot_format, rval);
    1:                 todo = Sprint(&ss->sprinter, fmt, js_this_str, rval);
 8285:                 break;
 8285: 
 8285:               case JSOP_GETARGPROP:
 8285:                 /* Get the name of the argument or variable. */
16429:                 i = GET_ARGNO(pc);
16429: 
16429:               do_getarg_prop:
16429:                 atom = GetArgOrVarAtom(ss->printer, i);
 8179:                 LOCAL_ASSERT(atom);
11039:                 LOCAL_ASSERT(ATOM_IS_STRING(atom));
 8179:                 lval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
 8179:                 if (!lval || !PushOff(ss, STR2OFF(&ss->sprinter, lval), op))
    1:                     return NULL;
 8285: 
 8285:                 /* Get the name of the property. */
 8285:                 LOAD_ATOM(ARGNO_LEN);
    1:                 goto do_getprop;
    1: 
 8285:               case JSOP_GETLOCALPROP:
16429:                 if (IsVarSlot(jp, pc, &i))
16429:                     goto do_getarg_prop;
    1:                 LOCAL_ASSERT((uintN)i < ss->top);
    1:                 lval = GetLocal(ss, i);
    1:                 if (!lval)
    1:                     return NULL;
    1:                 todo = SprintCString(&ss->sprinter, lval);
    1:                 if (todo < 0 || !PushOff(ss, todo, op))
    1:                     return NULL;
16429:                 LOAD_ATOM(2);
    1:                 goto do_getprop;
    1: 
    1:               case JSOP_SETPROP:
    1:                 LOAD_ATOM(0);
    1:                 GET_QUOTE_AND_FMT("%s[%s] %s= %s", "%s.%s %s= %s", xval);
    1:                 rval = POP_STR();
    1: 
    1:                 /*
    1:                  * Force precedence below the numeric literal opcodes, so that
    1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
    1:                  * around the left-hand side of dot.
    1:                  */
    1:                 op = JSOP_GETPROP;
    1:                 lval = POP_STR();
    1:                 sn = js_GetSrcNote(jp->script, pc - 1);
    1:                 todo = Sprint(&ss->sprinter, fmt, lval, xval,
    1:                               (sn && SN_TYPE(sn) == SRC_ASSIGNOP)
    1:                               ? (lastop == JSOP_GETTER)
    1:                                 ? js_getter_str
    1:                                 : (lastop == JSOP_SETTER)
    1:                                 ? js_setter_str
 1154:                                 : CodeToken[lastop]
    1:                               : "",
    1:                               rval);
    1:                 break;
    1: 
    1:               case JSOP_GETELEM2:
    1:                 op = JSOP_GETELEM;
    1:                 (void) PopOff(ss, lastop);
    1:                 /* FALL THROUGH */
    1: 
    1:               case JSOP_CALLELEM:
    1:               case JSOP_GETELEM:
    1:                 op = JSOP_NOP;          /* turn off parens */
    1:                 xval = POP_STR();
    1:                 op = saveop;
20928:                 PROPAGATE_CALLNESS();
    1:                 lval = POP_STR();
    1:                 if (*xval == '\0') {
    1:                     todo = Sprint(&ss->sprinter, "%s", lval);
    1:                 } else {
    1:                     todo = Sprint(&ss->sprinter,
 1761:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
    1:                                   ? dot_format
    1:                                   : index_format,
    1:                                   lval, xval);
    1:                 }
    1:                 break;
    1: 
    1:               case JSOP_SETELEM:
    1:                 rval = POP_STR();
    1:                 op = JSOP_NOP;          /* turn off parens */
    1:                 xval = POP_STR();
    1:                 cs = &js_CodeSpec[ss->opcodes[ss->top]];
    1:                 op = JSOP_GETELEM;      /* lval must have high precedence */
    1:                 lval = POP_STR();
    1:                 op = saveop;
    1:                 if (*xval == '\0')
    1:                     goto do_setlval;
    1:                 sn = js_GetSrcNote(jp->script, pc - 1);
    1:                 todo = Sprint(&ss->sprinter,
 1761:                               (JOF_MODE(cs->format) == JOF_XMLNAME)
    1:                               ? "%s.%s %s= %s"
    1:                               : "%s[%s] %s= %s",
    1:                               lval, xval,
    1:                               (sn && SN_TYPE(sn) == SRC_ASSIGNOP)
    1:                               ? (lastop == JSOP_GETTER)
    1:                                 ? js_getter_str
    1:                                 : (lastop == JSOP_SETTER)
    1:                                 ? js_setter_str
 1154:                                 : CodeToken[lastop]
    1:                               : "",
    1:                               rval);
    1:                 break;
    1: 
    1:               case JSOP_ARGSUB:
    1:                 i = (jsint) GET_ARGNO(pc);
    1:                 todo = Sprint(&ss->sprinter, "%s[%d]",
    1:                               js_arguments_str, (int) i);
    1:                 break;
    1: 
    1:               case JSOP_ARGCNT:
    1:                 todo = Sprint(&ss->sprinter, dot_format,
    1:                               js_arguments_str, js_length_str);
    1:                 break;
    1: 
    1:               case JSOP_CALLARG:
    1:               case JSOP_GETARG:
    1:                 i = GET_ARGNO(pc);
16429:                 atom = GetArgOrVarAtom(jp, i);
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (!atom) {
    1:                     todo = Sprint(&ss->sprinter, "%s[%d]", js_arguments_str, i);
    1:                     break;
    1:                 }
    1: #else
    1:                 LOCAL_ASSERT(atom);
    1: #endif
    1:                 goto do_name;
    1: 
    1:               case JSOP_CALLNAME:
    1:               case JSOP_NAME:
    1:               case JSOP_GETGVAR:
    1:               case JSOP_CALLGVAR:
    1:                 LOAD_ATOM(0);
    1:               do_name:
    1:                 lval = "";
 8656: #if JS_HAS_XML_SUPPORT
    1:               do_qname:
 8656: #endif
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
    1:                                    inXML ? DONT_ESCAPE : 0);
    1:                 if (!rval)
    1:                     return NULL;
    1:                 RETRACT(&ss->sprinter, rval);
20943:                 todo = Sprint(&ss->sprinter, sss_format,
    1:                               VarPrefix(sn), lval, rval);
    1:                 break;
    1: 
    1:               case JSOP_UINT16:
    1:                 i = (jsint) GET_UINT16(pc);
    1:                 goto do_sprint_int;
    1: 
    1:               case JSOP_UINT24:
    1:                 i = (jsint) GET_UINT24(pc);
 3328:                 goto do_sprint_int;
 3328: 
 3328:               case JSOP_INT8:
 3328:                 i = GET_INT8(pc);
 3328:                 goto do_sprint_int;
 3328: 
 3328:               case JSOP_INT32:
 3328:                 i = GET_INT32(pc);
    1:               do_sprint_int:
 3328:                 todo = Sprint(&ss->sprinter, "%d", i);
    1:                 break;
    1: 
 8285:               case JSOP_DOUBLE:
 8285:                 LOAD_ATOM(0);
    1:                 val = ATOM_KEY(atom);
11039:                 LOCAL_ASSERT(JSVAL_IS_DOUBLE(val));
 3328:                 todo = SprintDoubleValue(&ss->sprinter, val, &saveop);
 8285:                 break;
 8285: 
 8285:               case JSOP_STRING:
 8285:                 LOAD_ATOM(0);
    1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
    1:                                    inXML ? DONT_ESCAPE : '"');
    1:                 if (!rval)
    1:                     return NULL;
    1:                 todo = STR2OFF(&ss->sprinter, rval);
 8285:                 break;
    1: 
 1577:               case JSOP_ANONFUNOBJ:
 1760: #if JS_HAS_GENERATOR_EXPRS
 1577:                 sn = js_GetSrcNote(jp->script, pc);
 1577:                 if (sn && SN_TYPE(sn) == SRC_GENEXP) {
 1577:                     JSScript *inner, *outer;
 1577:                     void *mark;
 1577:                     SprintStack ss2;
 1577: 
 3235:                     LOAD_FUNCTION(0);
 1577:                     inner = fun->u.i.script;
 1577: 
 1577:                     /*
 1577:                      * All allocation when decompiling is LIFO, using malloc
 1577:                      * or, more commonly, arena-alloocating from cx->tempPool.
 1577:                      * After InitSprintStack succeeds, we must release to mark
 1577:                      * before returning.
 1577:                      */
 1577:                     mark = JS_ARENA_MARK(&cx->tempPool);
16072:                     if (!InitSprintStack(cx, &ss2, jp, StackDepth(inner)))
 1577:                         return NULL;
 1577:                     ss2.inGenExp = JS_TRUE;
 1577: 
 1577:                     /*
 1577:                      * Recursively decompile this generator function as an
 1577:                      * un-parenthesized generator expression. The ss->inGenExp
 1577:                      * special case of JSOP_YIELD shares array comprehension
 1577:                      * decompilation code that leaves the result as the single
 1577:                      * string pushed on ss2.
 1577:                      */
 1577:                     outer = jp->script;
 1577:                     LOCAL_ASSERT(JS_UPTRDIFF(pc, outer->code) <= outer->length);
 1577:                     jp->script = inner;
20943:                     if (!Decompile(&ss2, inner->code, inner->length, JSOP_NOP)) {
 1577:                         JS_ARENA_RELEASE(&cx->tempPool, mark);
 1577:                         return NULL;
 1577:                     }
 1577:                     jp->script = outer;
 1577: 
 1577:                     /*
 4127:                      * Advance over this op and its global |this| push, and
 1577:                      * arrange to advance over the call to this lambda.
 1577:                      */
 1577:                     pc += len;
18046:                     LOCAL_ASSERT(*pc == JSOP_NULL || *pc == JSOP_NULLTHIS);
 1577:                     pc += JSOP_NULL_LENGTH;
 1577:                     LOCAL_ASSERT(*pc == JSOP_CALL);
 1577:                     LOCAL_ASSERT(GET_ARGC(pc) == 0);
 1577:                     len = JSOP_CALL_LENGTH;
 1577: 
 1577:                     /*
 1577:                      * Arrange to parenthesize this genexp unless:
 1577:                      *
 1760:                      *  1. It is the complete expression consumed by a control
 1760:                      *     flow bytecode such as JSOP_TABLESWITCH whose syntax
 1760:                      *     always parenthesizes the controlling expression.
15556:                      *  2. It is the condition of a loop other than a for (;;).
15556:                      *  3. It is the sole argument to a function call.
15556:                      *  4. It is the condition of an if statement and not of a
 1577:                      *     ?: expression.
 1577:                      *
 1760:                      * But (first, before anything else) always parenthesize
 1760:                      * if this genexp runs up against endpc and the next op is
15556:                      * not a loop condition (JSOP_IFNE*) opcode. In such cases,
15556:                      * this Decompile activation has been recursively called by
15556:                      * a comma operator, &&, or || bytecode.
 1577:                      */
15556:                     pc2 = pc + len;
15556:                     LOCAL_ASSERT(pc2 < endpc ||
 1760:                                  endpc < outer->code + outer->length);
 1577:                     LOCAL_ASSERT(ss2.top == 1);
 1577:                     ss2.opcodes[0] = JSOP_POP;
15556:                     if (pc2 == endpc &&
15556:                         (JSOp) *endpc != JSOP_IFNE &&
15556:                         (JSOp) *endpc != JSOP_IFNEX) {
 1760:                         op = JSOP_SETNAME;
 1760:                     } else {
15556:                         op = (JSOp) *pc2;
 1760:                         op = ((js_CodeSpec[op].format & JOF_PARENHEAD) ||
 1577:                               ((js_CodeSpec[op].format & JOF_INVOKE) &&
15556:                                GET_ARGC(pc2) == 1) ||
15556:                               ((op == JSOP_IFEQ || op == JSOP_IFEQX) &&
15556:                                (sn2 = js_GetSrcNote(outer, pc2)) &&
15556:                                SN_TYPE(sn2) != SRC_COND))
 1577:                              ? JSOP_POP
 1577:                              : JSOP_SETNAME;
 1967: 
 1967:                         /*
11808:                          * Stack this result as if it's a name and not an
11808:                          * anonymous function, so it doesn't get decompiled as
11808:                          * a generator function in a getter or setter context.
11808:                          * The precedence level is the same for JSOP_NAME and
11808:                          * JSOP_ANONFUNOBJ.
 1967:                          */
 1967:                         LOCAL_ASSERT(js_CodeSpec[JSOP_NAME].prec ==
 1967:                                      js_CodeSpec[saveop].prec);
 1967:                         saveop = JSOP_NAME;
 1760:                     }
 1577: 
 1577:                     /*
 1577:                      * Alas, we have to malloc a copy of the result left on
 1577:                      * the top of ss2 because both ss and ss2 arena-allocate
 1577:                      * from cx's tempPool.
 1577:                      */
 1577:                     rval = JS_strdup(cx, PopStr(&ss2, op));
 1577:                     JS_ARENA_RELEASE(&cx->tempPool, mark);
 1577:                     if (!rval)
 1577:                         return NULL;
 1577:                     todo = SprintCString(&ss->sprinter, rval);
 1577:                     JS_free(cx, (void *)rval);
 1577:                     break;
 1577:                 }
 3235: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577:                 /* FALL THROUGH */
 3235: 
    1:               case JSOP_NAMEDFUNOBJ:
 3235:                 LOAD_FUNCTION(0);
 3235:                 {
 1967:                     uintN indent = JS_DONT_PRETTY_PRINT;
 1967: 
 1967:                     /*
 1967:                      * Always parenthesize expression closures. We can't force
 1967:                      * saveop to a low-precedence op to arrange for auto-magic
 1967:                      * parenthesization without confusing getter/setter code
 1967:                      * that checks for JSOP_ANONFUNOBJ and JSOP_NAMEDFUNOBJ.
 1967:                      */
 1967:                     if (!(fun->flags & JSFUN_EXPR_CLOSURE))
 1967:                         indent |= JS_IN_GROUP_CONTEXT;
13702:                     str = JS_DecompileFunction(cx, fun, indent);
 4127:                     if (!str)
    1:                         return NULL;
    1:                 }
 4127:               sprint_string:
    1:                 todo = SprintString(&ss->sprinter, str);
    1:                 break;
    1: 
 3235:               case JSOP_OBJECT:
 3235:                 LOAD_OBJECT(0);
11039:                 LOCAL_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_RegExpClass);
 3235:                 goto do_regexp;
 3235: 
 3235:               case JSOP_REGEXP:
 3235:                 GET_REGEXP_FROM_BYTECODE(jp->script, pc, 0, obj);
 3235:               do_regexp:
 4127:                 if (!js_regexp_toString(cx, obj, &val))
 3235:                     return NULL;
 4127:                 str = JSVAL_TO_STRING(val);
 4127:                 goto sprint_string;
 3235: 
    1:               case JSOP_TABLESWITCH:
    1:               case JSOP_TABLESWITCHX:
    1:               {
    1:                 ptrdiff_t jmplen, off, off2;
    1:                 jsint j, n, low, high;
    1:                 TableEntry *table, *tmp;
    1: 
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
    1:                 len = js_GetSrcNoteOffset(sn, 0);
    1:                 jmplen = (op == JSOP_TABLESWITCH) ? JUMP_OFFSET_LEN
    1:                                                   : JUMPX_OFFSET_LEN;
    1:                 pc2 = pc;
    1:                 off = GetJumpOffset(pc, pc2);
    1:                 pc2 += jmplen;
    1:                 low = GET_JUMP_OFFSET(pc2);
    1:                 pc2 += JUMP_OFFSET_LEN;
    1:                 high = GET_JUMP_OFFSET(pc2);
    1:                 pc2 += JUMP_OFFSET_LEN;
    1: 
    1:                 n = high - low + 1;
    1:                 if (n == 0) {
    1:                     table = NULL;
    1:                     j = 0;
    1:                     ok = JS_TRUE;
    1:                 } else {
    1:                     table = (TableEntry *)
    1:                             JS_malloc(cx, (size_t)n * sizeof *table);
    1:                     if (!table)
    1:                         return NULL;
    1:                     for (i = j = 0; i < n; i++) {
    1:                         table[j].label = NULL;
    1:                         off2 = GetJumpOffset(pc, pc2);
    1:                         if (off2) {
    1:                             sn = js_GetSrcNote(jp->script, pc2);
    1:                             if (sn) {
    1:                                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
 4342:                                 GET_SOURCE_NOTE_ATOM(sn, table[j].label);
    1:                             }
    1:                             table[j].key = INT_TO_JSVAL(low + i);
    1:                             table[j].offset = off2;
    1:                             table[j].order = j;
    1:                             j++;
    1:                         }
    1:                         pc2 += jmplen;
    1:                     }
    1:                     tmp = (TableEntry *)
    1:                           JS_malloc(cx, (size_t)j * sizeof *table);
    1:                     if (tmp) {
    1:                         ok = js_MergeSort(table, (size_t)j, sizeof(TableEntry),
    1:                                           CompareOffsets, NULL, tmp);
    1:                         JS_free(cx, tmp);
    1:                     } else {
    1:                         ok = JS_FALSE;
    1:                     }
    1:                 }
    1: 
    1:                 if (ok) {
    1:                     ok = DecompileSwitch(ss, table, (uintN)j, pc, len, off,
    1:                                          JS_FALSE);
    1:                 }
    1:                 JS_free(cx, table);
    1:                 if (!ok)
    1:                     return NULL;
    1:                 todo = -2;
    1:                 break;
    1:               }
    1: 
    1:               case JSOP_LOOKUPSWITCH:
    1:               case JSOP_LOOKUPSWITCHX:
    1:               {
    1:                 ptrdiff_t jmplen, off, off2;
    1:                 jsatomid npairs, k;
    1:                 TableEntry *table;
    1: 
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
    1:                 len = js_GetSrcNoteOffset(sn, 0);
    1:                 jmplen = (op == JSOP_LOOKUPSWITCH) ? JUMP_OFFSET_LEN
    1:                                                    : JUMPX_OFFSET_LEN;
    1:                 pc2 = pc;
    1:                 off = GetJumpOffset(pc, pc2);
    1:                 pc2 += jmplen;
    1:                 npairs = GET_UINT16(pc2);
    1:                 pc2 += UINT16_LEN;
    1: 
    1:                 table = (TableEntry *)
    1:                     JS_malloc(cx, (size_t)npairs * sizeof *table);
    1:                 if (!table)
    1:                     return NULL;
    1:                 for (k = 0; k < npairs; k++) {
    1:                     sn = js_GetSrcNote(jp->script, pc2);
    1:                     if (sn) {
    1:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
 4342:                         GET_SOURCE_NOTE_ATOM(sn, table[k].label);
    1:                     } else {
    1:                         table[k].label = NULL;
    1:                     }
 3235:                     JS_GET_SCRIPT_ATOM(jp->script, GET_INDEX(pc2), atom);
 3235:                     pc2 += INDEX_LEN;
    1:                     off2 = GetJumpOffset(pc, pc2);
    1:                     pc2 += jmplen;
    1:                     table[k].key = ATOM_KEY(atom);
    1:                     table[k].offset = off2;
    1:                 }
    1: 
    1:                 ok = DecompileSwitch(ss, table, (uintN)npairs, pc, len, off,
    1:                                      JS_FALSE);
    1:                 JS_free(cx, table);
    1:                 if (!ok)
    1:                     return NULL;
    1:                 todo = -2;
    1:                 break;
    1:               }
    1: 
    1:               case JSOP_CONDSWITCH:
    1:               {
    1:                 ptrdiff_t off, off2, caseOff;
    1:                 jsint ncases;
    1:                 TableEntry *table;
    1: 
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
    1:                 len = js_GetSrcNoteOffset(sn, 0);
    1:                 off = js_GetSrcNoteOffset(sn, 1);
    1: 
    1:                 /*
    1:                  * Count the cases using offsets from switch to first case,
    1:                  * and case to case, stored in srcnote immediates.
    1:                  */
    1:                 pc2 = pc;
    1:                 off2 = off;
    1:                 for (ncases = 0; off2 != 0; ncases++) {
    1:                     pc2 += off2;
    1:                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
    1:                                  *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
    1:                     if (*pc2 == JSOP_DEFAULT || *pc2 == JSOP_DEFAULTX) {
    1:                         /* End of cases, but count default as a case. */
    1:                         off2 = 0;
    1:                     } else {
    1:                         sn = js_GetSrcNote(jp->script, pc2);
    1:                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
    1:                         off2 = js_GetSrcNoteOffset(sn, 0);
    1:                     }
    1:                 }
    1: 
    1:                 /*
    1:                  * Allocate table and rescan the cases using their srcnotes,
    1:                  * stashing each case's delta from switch top in table[i].key,
    1:                  * and the distance to its statements in table[i].offset.
    1:                  */
    1:                 table = (TableEntry *)
    1:                     JS_malloc(cx, (size_t)ncases * sizeof *table);
    1:                 if (!table)
    1:                     return NULL;
    1:                 pc2 = pc;
    1:                 off2 = off;
    1:                 for (i = 0; i < ncases; i++) {
    1:                     pc2 += off2;
    1:                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT ||
    1:                                  *pc2 == JSOP_CASEX || *pc2 == JSOP_DEFAULTX);
    1:                     caseOff = pc2 - pc;
    1:                     table[i].key = INT_TO_JSVAL((jsint) caseOff);
    1:                     table[i].offset = caseOff + GetJumpOffset(pc2, pc2);
    1:                     if (*pc2 == JSOP_CASE || *pc2 == JSOP_CASEX) {
    1:                         sn = js_GetSrcNote(jp->script, pc2);
    1:                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
    1:                         off2 = js_GetSrcNoteOffset(sn, 0);
    1:                     }
    1:                 }
    1: 
    1:                 /*
    1:                  * Find offset of default code by fetching the default offset
    1:                  * from the end of table.  JSOP_CONDSWITCH always has a default
    1:                  * case at the end.
    1:                  */
    1:                 off = JSVAL_TO_INT(table[ncases-1].key);
    1:                 pc2 = pc + off;
    1:                 off += GetJumpOffset(pc2, pc2);
    1: 
    1:                 ok = DecompileSwitch(ss, table, (uintN)ncases, pc, len, off,
    1:                                      JS_TRUE);
    1:                 JS_free(cx, table);
    1:                 if (!ok)
    1:                     return NULL;
    1:                 todo = -2;
    1:                 break;
    1:               }
    1: 
    1:               case JSOP_CASE:
    1:               case JSOP_CASEX:
    1:               {
    1:                 lval = POP_STR();
    1:                 if (!lval)
    1:                     return NULL;
    1:                 js_printf(jp, "\tcase %s:\n", lval);
    1:                 todo = -2;
    1:                 break;
    1:               }
    1: 
18965:               case JSOP_DEFFUN:
 3235:                 LOAD_FUNCTION(0);
    1:                 todo = -2;
    1:                 goto do_function;
 8285:                 break;
    1: 
    1:               case JSOP_TRAP:
11813:                 saveop = op = JS_GetTrapOpcode(cx, jp->script, pc);
    1:                 *pc = op;
    1:                 cs = &js_CodeSpec[op];
    1:                 len = cs->length;
    1:                 DECOMPILE_CODE(pc, len);
    1:                 *pc = JSOP_TRAP;
    1:                 todo = -2;
    1:                 break;
    1: 
15279:               case JSOP_HOLE:
15279:                 todo = SprintPut(&ss->sprinter, "", 0);
15279:                 break;
15279: 
15279:               case JSOP_NEWARRAY:
15279:               {
15279:                 ptrdiff_t off;
15279:                 char *base, *from, *to;
15279: 
15279:                 /*
15279:                  * All operands are stacked and ready for in-place formatting.
15279:                  * We know that PAREN_SLOP is 3 here, and take advantage of it
15279:                  * to avoid strdup'ing.
15279:                  */
15279:                 argc = GET_UINT24(pc);
15279:                 LOCAL_ASSERT(ss->top >= (uintN) argc);
15279:                 sn = js_GetSrcNote(jp->script, pc);
15279:                 if (argc == 0) {
15279:                     todo = Sprint(&ss->sprinter, "[%s]",
15279:                                   (sn && SN_TYPE(sn) == SRC_CONTINUE)
15279:                                   ? ", "
15279:                                   : "");
15279:                 } else {
15279:                     ss->top -= argc;
15279:                     off = GetOff(ss, ss->top);
15279:                     LOCAL_ASSERT(off >= PAREN_SLOP);
15279:                     base = OFF2STR(&ss->sprinter, off);
15279:                     to = base + 1;
15279:                     i = 0;
15279:                     for (;;) {
15279:                         /* Move to the next string that had been stacked. */
15279:                         from = OFF2STR(&ss->sprinter, off);
15279:                         todo = strlen(from);
15279:                         memmove(to, from, todo);
15279:                         to += todo;
15279:                         if (++i == argc &&
15279:                             !(sn && SN_TYPE(sn) == SRC_CONTINUE)) {
15279:                             break;
15279:                         }
15279:                         *to++ = ',';
15279:                         *to++ = ' ';
15279:                         off = GetOff(ss, ss->top + i);
15279:                     }
15279:                     LOCAL_ASSERT(to - base < ss->sprinter.offset - PAREN_SLOP);
15279:                     *base = '[';
15279:                     *to++ = ']';
15279:                     *to = '\0';
15279:                     ss->sprinter.offset = STR2OFF(&ss->sprinter, to);
15279:                     todo = STR2OFF(&ss->sprinter, base);
15279:                 }
15279:                 break;
15279:               }
15279: 
    1:               case JSOP_NEWINIT:
    1:               {
 8633:                 i = GET_INT8(pc);
11039:                 LOCAL_ASSERT(i == JSProto_Array || i == JSProto_Object);
 8633: 
    1:                 todo = ss->sprinter.offset;
    1: #if JS_HAS_SHARP_VARS
    1:                 op = (JSOp)pc[len];
    1:                 if (op == JSOP_DEFSHARP) {
    1:                     pc += len;
    1:                     cs = &js_CodeSpec[op];
    1:                     len = cs->length;
 8633:                     if (Sprint(&ss->sprinter, "#%u=",
 8633:                                (unsigned) (jsint) GET_UINT16(pc)) < 0)
    1:                         return NULL;
    1:                 }
    1: #endif /* JS_HAS_SHARP_VARS */
 8633:                 if (i == JSProto_Array) {
    1:                     ++ss->inArrayInit;
    1:                     if (SprintCString(&ss->sprinter, "[") < 0)
    1:                         return NULL;
    1:                 } else {
    1:                     if (SprintCString(&ss->sprinter, "{") < 0)
    1:                         return NULL;
    1:                 }
    1:                 break;
    1:               }
    1: 
    1:               case JSOP_ENDINIT:
 8633:               {
 8633:                 JSBool inArray;
 8633: 
    1:                 op = JSOP_NOP;           /* turn off parens */
    1:                 rval = POP_STR();
    1:                 sn = js_GetSrcNote(jp->script, pc);
    1: 
    1:                 /* Skip any #n= prefix to find the opening bracket. */
    1:                 for (xval = rval; *xval != '[' && *xval != '{'; xval++)
    1:                     continue;
 8633:                 inArray = (*xval == '[');
 8633:                 if (inArray)
    1:                     --ss->inArrayInit;
    1:                 todo = Sprint(&ss->sprinter, "%s%s%c",
    1:                               rval,
    1:                               (sn && SN_TYPE(sn) == SRC_CONTINUE) ? ", " : "",
 8633:                               inArray ? ']' : '}');
    1:                 break;
 8633:               }
    1: 
 8633:               {
 8633:                 JSBool isFirst;
11474:                 const char *maybeComma;
11474: 
11474:               case JSOP_INITELEM:
11474:                 isFirst = (ss->opcodes[ss->top - 3] == JSOP_NEWINIT);
21450: 
21450:                 /* Turn off most parens. */
21450:                 op = JSOP_SETNAME;
11474:                 rval = POP_STR();
11474: 
11474:                 /* Turn off all parens for xval and lval, which we control. */
11474:                 op = JSOP_NOP;
11474:                 xval = POP_STR();
11474:                 lval = POP_STR();
11474:                 sn = js_GetSrcNote(jp->script, pc);
11474: 
11474:                 if (sn && SN_TYPE(sn) == SRC_INITPROP) {
11474:                     atom = NULL;
11474:                     goto do_initprop;
11474:                 }
11474:                 maybeComma = isFirst ? "" : ", ";
20943:                 todo = Sprint(&ss->sprinter, sss_format,
11474:                               lval,
11474:                               maybeComma,
11474:                               rval);
    1:                 break;
    1: 
    1:               case JSOP_INITPROP:
    1:                 LOAD_ATOM(0);
    1:                 xval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
    1:                                    (jschar)
    1:                                    (ATOM_IS_IDENTIFIER(atom) ? 0 : '\''));
    1:                 if (!xval)
    1:                     return NULL;
 8633:                 isFirst = (ss->opcodes[ss->top - 2] == JSOP_NEWINIT);
    1:                 rval = POP_STR();
    1:                 lval = POP_STR();
11474:                 /* fall through */
11474: 
    1:               do_initprop:
11474:                 maybeComma = isFirst ? "" : ", ";
    1: #ifdef OLD_GETTER_SETTER
11474:                 todo = Sprint(&ss->sprinter, "%s%s%s%s%s%s%s:%s",
    1:                               lval,
11474:                               maybeComma,
    1:                               xval,
    1:                               (lastop == JSOP_GETTER || lastop == JSOP_SETTER)
    1:                               ? " " : "",
    1:                               (lastop == JSOP_GETTER) ? js_getter_str :
    1:                               (lastop == JSOP_SETTER) ? js_setter_str :
    1:                               "",
    1:                               rval);
    1: #else
    1:                 if (lastop == JSOP_GETTER || lastop == JSOP_SETTER) {
 1967:                     if (!atom ||
 1967:                         !ATOM_IS_STRING(atom) ||
 1316:                         !ATOM_IS_IDENTIFIER(atom) ||
  969:                         ATOM_IS_KEYWORD(atom) ||
 1967:                         (ss->opcodes[ss->top+1] != JSOP_ANONFUNOBJ &&
 1576:                          ss->opcodes[ss->top+1] != JSOP_NAMEDFUNOBJ)) {
11474:                         todo = Sprint(&ss->sprinter, "%s%s%s %s: %s",
11474:                                       lval,
11474:                                       maybeComma,
11474:                                       xval,
    1:                                       (lastop == JSOP_GETTER) ? js_getter_str :
    1:                                       (lastop == JSOP_SETTER) ? js_setter_str :
    1:                                       "",
    1:                                       rval);
    1:                     } else {
 1967:                         const char *end = rval + strlen(rval);
 1967: 
 1967:                         if (*rval == '(')
 1967:                             ++rval, --end;
 1967:                         LOCAL_ASSERT(strncmp(rval, js_function_str, 8) == 0);
 1967:                         LOCAL_ASSERT(rval[8] == ' ');
    1:                         rval += 8 + 1;
 1967:                         LOCAL_ASSERT(*end ? *end == ')' : end[-1] == '}');
 1967:                         todo = Sprint(&ss->sprinter, "%s%s%s %s%s%.*s",
    1:                                       lval,
11474:                                       maybeComma,
    1:                                       (lastop == JSOP_GETTER)
    1:                                       ? js_get_str : js_set_str,
    1:                                       xval,
  526:                                       (rval[0] != '(') ? " " : "",
 1967:                                       end - rval, rval);
    1:                     }
    1:                 } else {
    1:                     todo = Sprint(&ss->sprinter, "%s%s%s: %s",
11474:                                   lval, maybeComma, xval, rval);
    1:                 }
    1: #endif
    1:                 break;
 8633:               }
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:               case JSOP_DEFSHARP:
    1:                 i = (jsint) GET_UINT16(pc);
    1:                 rval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "#%u=%s", (unsigned) i, rval);
    1:                 break;
    1: 
    1:               case JSOP_USESHARP:
    1:                 i = (jsint) GET_UINT16(pc);
    1:                 todo = Sprint(&ss->sprinter, "#%u#", (unsigned) i);
    1:                 break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1: #if JS_HAS_DEBUGGER_KEYWORD
    1:               case JSOP_DEBUGGER:
    1:                 js_printf(jp, "\tdebugger;\n");
    1:                 todo = -2;
    1:                 break;
    1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:               case JSOP_STARTXML:
    1:               case JSOP_STARTXMLEXPR:
    1:                 inXML = op == JSOP_STARTXML;
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_DEFXMLNS:
    1:                 rval = POP_STR();
    1:                 js_printf(jp, "\t%s %s %s = %s;\n",
    1:                           js_default_str, js_xml_str, js_namespace_str, rval);
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_ANYNAME:
    1:                 if (pc[JSOP_ANYNAME_LENGTH] == JSOP_TOATTRNAME) {
    1:                     len += JSOP_TOATTRNAME_LENGTH;
    1:                     todo = SprintPut(&ss->sprinter, "@*", 2);
    1:                 } else {
    1:                     todo = SprintPut(&ss->sprinter, "*", 1);
    1:                 }
    1:                 break;
    1: 
 8285:               case JSOP_QNAMEPART:
 8285:                 LOAD_ATOM(0);
    1:                 if (pc[JSOP_QNAMEPART_LENGTH] == JSOP_TOATTRNAME) {
    1:                     saveop = JSOP_TOATTRNAME;
    1:                     len += JSOP_TOATTRNAME_LENGTH;
    1:                     lval = "@";
    1:                     goto do_qname;
    1:                 }
    1:                 goto do_name;
 8285: 
 8285:               case JSOP_QNAMECONST:
 8285:                 LOAD_ATOM(0);
    1:                 rval = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0);
    1:                 if (!rval)
    1:                     return NULL;
    1:                 RETRACT(&ss->sprinter, rval);
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "%s::%s", lval, rval);
 8285:                 break;
    1: 
    1:               case JSOP_QNAME:
    1:                 rval = POP_STR();
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "%s::[%s]", lval, rval);
    1:                 break;
    1: 
    1:               case JSOP_TOATTRNAME:
    1:                 op = JSOP_NOP;           /* turn off parens */
    1:                 rval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "@[%s]", rval);
    1:                 break;
    1: 
    1:               case JSOP_TOATTRVAL:
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_ADDATTRNAME:
    1:                 rval = POP_STR();
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "%s %s", lval, rval);
    1:                 /* This gets reset by all XML tag expressions. */
    1:                 quoteAttr = JS_TRUE;
    1:                 break;
    1: 
    1:               case JSOP_ADDATTRVAL:
    1:                 rval = POP_STR();
    1:                 lval = POP_STR();
    1:                 if (quoteAttr)
    1:                     todo = Sprint(&ss->sprinter, "%s=\"%s\"", lval, rval);
    1:                 else
    1:                     todo = Sprint(&ss->sprinter, "%s=%s", lval, rval);
    1:                 break;
    1: 
    1:               case JSOP_BINDXMLNAME:
    1:                 /* Leave the name stacked and push a dummy string. */
    1:                 todo = Sprint(&ss->sprinter, "");
    1:                 break;
    1: 
    1:               case JSOP_SETXMLNAME:
    1:                 /* Pop the r.h.s., the dummy string, and the name. */
    1:                 rval = POP_STR();
    1:                 (void) PopOff(ss, op);
    1:                 lval = POP_STR();
    1:                 goto do_setlval;
    1: 
    1:               case JSOP_XMLELTEXPR:
    1:               case JSOP_XMLTAGEXPR:
    1:                 todo = Sprint(&ss->sprinter, "{%s}", POP_STR());
    1:                 inXML = JS_TRUE;
    1:                 /* If we're an attribute value, we shouldn't quote this. */
    1:                 quoteAttr = JS_FALSE;
    1:                 break;
    1: 
    1:               case JSOP_TOXMLLIST:
    1:                 op = JSOP_NOP;           /* turn off parens */
    1:                 todo = Sprint(&ss->sprinter, "<>%s</>", POP_STR());
    1:                 inXML = JS_FALSE;
    1:                 break;
    1: 
    1:               case JSOP_TOXML:
    1:               case JSOP_CALLXMLNAME:
    1:               case JSOP_XMLNAME:
    1:               case JSOP_FILTER:
    1:                 /* These ops indicate the end of XML expressions. */
    1:                 inXML = JS_FALSE;
    1:                 todo = -2;
    1:                 break;
    1: 
    1:               case JSOP_ENDFILTER:
    1:                 rval = POP_STR();
20928:                 PROPAGATE_CALLNESS();
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "%s.(%s)", lval, rval);
    1:                 break;
    1: 
    1:               case JSOP_DESCENDANTS:
    1:                 rval = POP_STR();
20928:                 PROPAGATE_CALLNESS();
    1:                 lval = POP_STR();
    1:                 todo = Sprint(&ss->sprinter, "%s..%s", lval, rval);
    1:                 break;
    1: 
 3235:               case JSOP_XMLOBJECT:
 3235:                 LOAD_OBJECT(0);
 3235:                 todo = Sprint(&ss->sprinter, "<xml address='%p'>", obj);
 3235:                 break;
    1: 
 8285:               case JSOP_XMLCDATA:
 8285:                 LOAD_ATOM(0);
    1:                 todo = SprintPut(&ss->sprinter, "<![CDATA[", 9);
    1:                 if (!QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
    1:                                  DONT_ESCAPE))
    1:                     return NULL;
    1:                 SprintPut(&ss->sprinter, "]]>", 3);
 8285:                 break;
 8285: 
 8285:               case JSOP_XMLCOMMENT:
 8285:                 LOAD_ATOM(0);
    1:                 todo = SprintPut(&ss->sprinter, "<!--", 4);
    1:                 if (!QuoteString(&ss->sprinter, ATOM_TO_STRING(atom),
    1:                                  DONT_ESCAPE))
    1:                     return NULL;
    1:                 SprintPut(&ss->sprinter, "-->", 3);
 8285:                 break;
 8285: 
 8285:               case JSOP_XMLPI:
 8285:                 LOAD_ATOM(0);
    1:                 rval = JS_strdup(cx, POP_STR());
    1:                 if (!rval)
    1:                     return NULL;
    1:                 todo = SprintPut(&ss->sprinter, "<?", 2);
    1:                 ok = QuoteString(&ss->sprinter, ATOM_TO_STRING(atom), 0) &&
    1:                      (*rval == '\0' ||
    1:                       (SprintPut(&ss->sprinter, " ", 1) >= 0 &&
    1:                        SprintCString(&ss->sprinter, rval)));
    1:                 JS_free(cx, (char *)rval);
    1:                 if (!ok)
    1:                     return NULL;
    1:                 SprintPut(&ss->sprinter, "?>", 2);
 8285:                 break;
    1: 
    1:               case JSOP_GETFUNNS:
    1:                 todo = SprintPut(&ss->sprinter, js_function_str, 8);
    1:                 break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:               default:
    1:                 todo = -2;
    1:                 break;
    1:             }
    1:         }
    1: 
    1:         if (todo < 0) {
    1:             /* -2 means "don't push", -1 means reported error. */
    1:             if (todo == -1)
    1:                 return NULL;
    1:         } else {
    1:             if (!PushOff(ss, todo, saveop))
    1:                 return NULL;
    1:         }
    1: 
    1:         if (cs->format & JOF_CALLOP) {
    1:             todo = Sprint(&ss->sprinter, "");
    1:             if (todo < 0 || !PushOff(ss, todo, saveop))
    1:                 return NULL;
    1:         }
    1: 
    1:         pc += len;
    1:     }
    1: 
    1: /*
    1:  * Undefine local macros.
    1:  */
    1: #undef inXML
    1: #undef DECOMPILE_CODE
 1967: #undef NEXT_OP
21441: #undef TOP_STR
    1: #undef POP_STR
21441: #undef POP_STR_PREC
    1: #undef LOCAL_ASSERT
    1: #undef ATOM_IS_IDENTIFIER
    1: #undef GET_QUOTE_AND_FMT
    1: #undef GET_ATOM_QUOTE_AND_FMT
    1: 
    1:     return pc;
    1: }
    1: 
12981: static JSBool
12981: DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, uintN len,
    1:               uintN pcdepth)
    1: {
    1:     uintN depth, i;
    1:     SprintStack ss;
    1:     JSContext *cx;
    1:     void *mark;
    1:     JSBool ok;
    1:     JSScript *oldscript;
14767:     jsbytecode *oldcode, *oldmain, *code;
    1:     char *last;
    1: 
16072:     depth = StackDepth(script);
    1:     JS_ASSERT(pcdepth <= depth);
    1: 
    1:     /* Initialize a sprinter for use with the offset stack. */
    1:     cx = jp->sprinter.context;
    1:     mark = JS_ARENA_MARK(&cx->tempPool);
    1:     ok = InitSprintStack(cx, &ss, jp, depth);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     /*
    1:      * If we are called from js_DecompileValueGenerator with a portion of
    1:      * script's bytecode that starts with a non-zero model stack depth given
    1:      * by pcdepth, attempt to initialize the missing string offsets in ss to
    1:      * |spindex| negative indexes from fp->sp for the activation fp in which
    1:      * the error arose.
    1:      *
    1:      * See js_DecompileValueGenerator for how its |spindex| parameter is used,
    1:      * and see also GetOff, which makes use of the ss.offsets[i] < -1 that are
    1:      * potentially stored below.
    1:      */
    1:     ss.top = pcdepth;
    1:     if (pcdepth != 0) {
    1:         for (i = 0; i < pcdepth; i++) {
13182:             ss.offsets[i] = -2 - (ptrdiff_t)i;
12981:             ss.opcodes[i] = *jp->pcstack[i];
    1:         }
    1:     }
    1: 
    1:     /* Call recursive subroutine to do the hard work. */
    1:     oldscript = jp->script;
    1:     jp->script = script;
14767:     oldcode = jp->script->code;
14767:     oldmain = jp->script->main;
14767:     code = js_UntrapScriptCode(cx, jp->script);
14767:     if (code != oldcode) {
14767:         jp->script->code = code;
14917:         jp->script->main = code + (oldmain - oldcode);
14767:         pc = code + (pc - oldcode);
14767:     }
14767: 
 1967:     ok = Decompile(&ss, pc, len, JSOP_NOP) != NULL;
14767:     if (code != oldcode) {
14767:         JS_free(cx, jp->script->code);
14767:         jp->script->code = oldcode;
14767:         jp->script->main = oldmain;
14767:     }
    1:     jp->script = oldscript;
    1: 
    1:     /* If the given code didn't empty the stack, do it now. */
14804:     if (ok && ss.top) {
    1:         do {
    1:             last = OFF2STR(&ss.sprinter, PopOff(&ss, JSOP_POP));
    1:         } while (ss.top > pcdepth);
    1:         js_printf(jp, "%s", last);
    1:     }
    1: 
    1: out:
    1:     /* Free all temporary stuff allocated under this call. */
    1:     JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_DecompileScript(JSPrinter *jp, JSScript *script)
    1: {
12981:     return DecompileCode(jp, script, script->code, (uintN)script->length, 0);
    1: }
    1: 
    1: static const char native_code_str[] = "\t[native code]\n";
    1: 
    1: JSBool
13702: js_DecompileFunctionBody(JSPrinter *jp)
    1: {
    1:     JSScript *script;
 8179: 
13702:     JS_ASSERT(jp->fun);
 8179:     JS_ASSERT(!jp->script);
13702:     if (!FUN_INTERPRETED(jp->fun)) {
    1:         js_printf(jp, native_code_str);
    1:         return JS_TRUE;
    1:     }
13702: 
13702:     script = jp->fun->u.i.script;
12981:     return DecompileCode(jp, script, script->code, (uintN)script->length, 0);
    1: }
    1: 
    1: JSBool
13702: js_DecompileFunction(JSPrinter *jp)
    1: {
13702:     JSFunction *fun;
 8179:     uintN i;
 8179:     JSAtom *param;
    1:     jsbytecode *pc, *endpc;
    1:     ptrdiff_t len;
    1:     JSBool ok;
    1: 
13702:     fun = jp->fun;
13702:     JS_ASSERT(fun);
 8179:     JS_ASSERT(!jp->script);
 8179: 
    1:     /*
    1:      * If pretty, conform to ECMA-262 Edition 3, 15.3.4.2, by decompiling a
    1:      * FunctionDeclaration.  Otherwise, check the JSFUN_LAMBDA flag and force
    1:      * an expression by parenthesizing.
    1:      */
    1:     if (jp->pretty) {
    1:         js_printf(jp, "\t");
    1:     } else {
    1:         if (!jp->grouped && (fun->flags & JSFUN_LAMBDA))
    1:             js_puts(jp, "(");
    1:     }
    1:     if (JSFUN_GETTER_TEST(fun->flags))
    1:         js_printf(jp, "%s ", js_getter_str);
    1:     else if (JSFUN_SETTER_TEST(fun->flags))
    1:         js_printf(jp, "%s ", js_setter_str);
    1: 
    1:     js_printf(jp, "%s ", js_function_str);
    1:     if (fun->atom && !QuoteString(&jp->sprinter, ATOM_TO_STRING(fun->atom), 0))
    1:         return JS_FALSE;
    1:     js_puts(jp, "(");
    1: 
13702:     if (!FUN_INTERPRETED(fun)) {
13702:         js_printf(jp, ") {\n");
13702:         jp->indent += 4;
13702:         js_printf(jp, native_code_str);
13702:         jp->indent -= 4;
13702:         js_printf(jp, "\t}");
13702:     } else {
    1: #ifdef JS_HAS_DESTRUCTURING
    1:         SprintStack ss;
13702:         void *mark;
    1: #endif
    1: 
 8179:         /* Print the parameters. */
    1:         pc = fun->u.i.script->main;
    1:         endpc = pc + fun->u.i.script->length;
    1:         ok = JS_TRUE;
    1: 
    1: #ifdef JS_HAS_DESTRUCTURING
    1:         /* Skip JSOP_GENERATOR in case of destructuring parameters. */
    1:         if (*pc == JSOP_GENERATOR)
    1:             pc += JSOP_GENERATOR_LENGTH;
    1: 
    1:         ss.printer = NULL;
    1:         jp->script = fun->u.i.script;
 8179:         mark = JS_ARENA_MARK(&jp->sprinter.context->tempPool);
    1: #endif
    1: 
 8179:         for (i = 0; i < fun->nargs; i++) {
    1:             if (i > 0)
    1:                 js_puts(jp, ", ");
    1: 
16429:             param = GetArgOrVarAtom(jp, i);
 8179: 
    1: #if JS_HAS_DESTRUCTURING
    1: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, JS_FALSE)
    1: 
 8179:             if (!param) {
    1:                 ptrdiff_t todo;
    1:                 const char *lval;
    1: 
    1:                 LOCAL_ASSERT(*pc == JSOP_GETARG);
    1:                 pc += JSOP_GETARG_LENGTH;
    1:                 LOCAL_ASSERT(*pc == JSOP_DUP);
    1:                 if (!ss.printer) {
 8179:                     ok = InitSprintStack(jp->sprinter.context, &ss, jp,
16072:                                          StackDepth(fun->u.i.script));
    1:                     if (!ok)
    1:                         break;
    1:                 }
    1:                 pc = DecompileDestructuring(&ss, pc, endpc);
    1:                 if (!pc) {
    1:                     ok = JS_FALSE;
    1:                     break;
    1:                 }
    1:                 LOCAL_ASSERT(*pc == JSOP_POP);
    1:                 pc += JSOP_POP_LENGTH;
    1:                 lval = PopStr(&ss, JSOP_NOP);
    1:                 todo = SprintCString(&jp->sprinter, lval);
    1:                 if (todo < 0) {
    1:                     ok = JS_FALSE;
    1:                     break;
    1:                 }
    1:                 continue;
    1:             }
    1: 
    1: #undef LOCAL_ASSERT
    1: #endif
    1: 
 8179:             if (!QuoteString(&jp->sprinter, ATOM_TO_STRING(param), 0)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1: 
    1: #ifdef JS_HAS_DESTRUCTURING
 8179:         jp->script = NULL;
 8179:         JS_ARENA_RELEASE(&jp->sprinter.context->tempPool, mark);
    1: #endif
    1:         if (!ok)
    1:             return JS_FALSE;
 1967:         if (fun->flags & JSFUN_EXPR_CLOSURE) {
 1967:             js_printf(jp, ") ");
 1967:         } else {
    1:             js_printf(jp, ") {\n");
    1:             jp->indent += 4;
 1967:         }
 1967: 
    1:         len = fun->u.i.script->code + fun->u.i.script->length - pc;
13702:         ok = DecompileCode(jp, fun->u.i.script, pc, (uintN)len, 0);
 8179:         if (!ok)
    1:             return JS_FALSE;
 1967: 
 1967:         if (!(fun->flags & JSFUN_EXPR_CLOSURE)) {
    1:             jp->indent -= 4;
    1:             js_printf(jp, "\t}");
 1967:         }
13702:     }
 8179: 
 8179:     if (!jp->pretty && !jp->grouped && (fun->flags & JSFUN_LAMBDA))
    1:         js_puts(jp, ")");
 8179: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: char *
    1: js_DecompileValueGenerator(JSContext *cx, intN spindex, jsval v,
    1:                            JSString *fallback)
    1: {
12579:     JSStackFrame *fp;
12981:     jsbytecode *pc;
    1:     JSScript *script;
13168:     JSFrameRegs *regs;
12579:     intN pcdepth;
16072:     jsval *sp, *stackBase;
    1:     char *name;
    1: 
11420:     JS_ASSERT(spindex < 0 ||
11420:               spindex == JSDVG_IGNORE_STACK ||
11420:               spindex == JSDVG_SEARCH_STACK);
11420: 
    1:     for (fp = cx->fp; fp && !fp->script; fp = fp->down)
    1:         continue;
21958:     if (!fp || !fp->regs || !fp->regs->sp)
    1:         goto do_fallback;
    1: 
    1:     script = fp->script;
13168:     regs = fp->regs;
21808:     pc = fp->imacpc ? fp->imacpc : regs->pc;
12579:     if (pc < script->main || script->code + script->length <= pc) {
12579:         JS_NOT_REACHED("bug");
    1:         goto do_fallback;
12579:     }
    1: 
    1:     if (spindex != JSDVG_IGNORE_STACK) {
12579:         jsbytecode **pcstack;
12579: 
12579:         /*
12579:          * Prepare computing pcstack containing pointers to opcodes that
12579:          * populated interpreter's stack with its current content.
12579:          */
12579:         pcstack = (jsbytecode **)
16072:                   JS_malloc(cx, StackDepth(script) * sizeof *pcstack);
12579:         if (!pcstack)
12579:             return NULL;
21808:         pcdepth = ReconstructPCStack(cx, script, pc, pcstack);
12579:         if (pcdepth < 0)
12579:             goto release_pcstack;
12579: 
12579:         if (spindex != JSDVG_SEARCH_STACK) {
    1:             JS_ASSERT(spindex < 0);
12579:             pcdepth += spindex;
12579:             if (pcdepth < 0)
12579:                 goto release_pcstack;
12579:             pc = pcstack[pcdepth];
12579:         } else {
    1:             /*
12579:              * We search from fp->sp to base to find the most recently
12579:              * calculated value matching v under assumption that it is
12579:              * it that caused exception, see bug 328664.
    1:              */
16072:             stackBase = StackBase(fp);
13168:             sp = regs->sp;
12579:             do {
16072:                 if (sp == stackBase) {
12579:                     pcdepth = -1;
12579:                     goto release_pcstack;
12579:                 }
12579:             } while (*--sp != v);
12579: 
16072:             if (sp >= stackBase + pcdepth) {
12579:                 /*
21743:                  * The value comes from a temporary slot that the interpreter
21743:                  * uses for GC roots or when JSOP_APPLY extended the stack to
21743:                  * fit the argument array elements. Assume that it is the
21743:                  * current PC that caused the exception.
12579:                  */
21808:                 pc = fp->imacpc ? fp->imacpc : regs->pc;
12579:             } else {
16072:                 pc = pcstack[sp - stackBase];
12579:             }
12579:         }
12579: 
12579:       release_pcstack:
12579:         JS_free(cx, pcstack);
12579:         if (pcdepth < 0)
    1:             goto do_fallback;
    1:     }
12579: 
21808:     {
21808:         jsbytecode* savepc = regs->pc;
21808:         jsbytecode* imacpc = fp->imacpc;
21808:         if (imacpc) {
21808:             regs->pc = imacpc;
21808:             fp->imacpc = NULL;
21808:         }
13702:         name = DecompileExpression(cx, script, fp->fun, pc);
21808:         if (imacpc) {
21808:             regs->pc = savepc;
21808:             fp->imacpc = imacpc;
21808:         }
21808:     }
12981:     if (name != FAILED_EXPRESSION_DECOMPILER)
12981:         return name;
12981: 
12981:   do_fallback:
12981:     if (!fallback) {
12981:         fallback = js_ValueToSource(cx, v);
12981:         if (!fallback)
12981:             return NULL;
12981:     }
12981:     return js_DeflateString(cx, JSSTRING_CHARS(fallback),
12981:                             JSSTRING_LENGTH(fallback));
12981: }
12981: 
12981: static char *
13702: DecompileExpression(JSContext *cx, JSScript *script, JSFunction *fun,
12981:                     jsbytecode *pc)
12981: {
14917:     jsbytecode *code, *oldcode, *oldmain;
    1:     JSOp op;
    1:     const JSCodeSpec *cs;
12981:     jsbytecode *begin, *end;
    1:     jssrcnote *sn;
12981:     ptrdiff_t len;
12981:     jsbytecode **pcstack;
12981:     intN pcdepth;
    1:     JSPrinter *jp;
    1:     char *name;
    1: 
12981:     JS_ASSERT(script->main <= pc && pc < script->code + script->length);
14917: 
14917:     pcstack = NULL;
14917:     oldcode = script->code;
14917:     oldmain = script->main;
14917: 
18989:     MUST_FLOW_THROUGH("out");
14917:     code = js_UntrapScriptCode(cx, script);
14917:     if (code != oldcode) {
14917:         script->code = code;
14917:         script->main = code + (oldmain - oldcode);
14917:         pc = code + (pc - oldcode);
14917:     }
14917: 
    1:     op = (JSOp) *pc;
    1: 
    1:     /* None of these stack-writing ops generates novel values. */
    1:     JS_ASSERT(op != JSOP_CASE && op != JSOP_CASEX &&
15453:               op != JSOP_DUP && op != JSOP_DUP2);
    1: 
    1:     /*
    1:      * |this| could convert to a very long object initialiser, so cite it by
    1:      * its keyword name instead.
    1:      */
14917:     if (op == JSOP_THIS) {
14917:         name = JS_strdup(cx, js_this_str);
14917:         goto out;
14917:     }
    1: 
    1:     /*
    1:      * JSOP_BINDNAME is special: it generates a value, the base object of a
    1:      * reference.  But if it is the generating op for a diagnostic produced by
    1:      * js_DecompileValueGenerator, the name being bound is irrelevant.  Just
    1:      * fall back to the base object.
    1:      */
14917:     if (op == JSOP_BINDNAME) {
14917:         name = FAILED_EXPRESSION_DECOMPILER;
14917:         goto out;
14917:     }
    1: 
    1:     /* NAME ops are self-contained, others require left or right context. */
    1:     cs = &js_CodeSpec[op];
    1:     begin = pc;
    1:     end = pc + cs->length;
 1761:     switch (JOF_MODE(cs->format)) {
    1:       case JOF_PROP:
    1:       case JOF_ELEM:
    1:       case JOF_XMLNAME:
    1:       case 0:
    1:         sn = js_GetSrcNote(script, pc);
14917:         if (!sn) {
14917:             name = FAILED_EXPRESSION_DECOMPILER;
14917:             goto out;
14917:         }
    1:         switch (SN_TYPE(sn)) {
    1:           case SRC_PCBASE:
    1:             begin -= js_GetSrcNoteOffset(sn, 0);
    1:             break;
    1:           case SRC_PCDELTA:
    1:             end = begin + js_GetSrcNoteOffset(sn, 0);
    1:             begin += cs->length;
    1:             break;
    1:           default:
14917:             name = FAILED_EXPRESSION_DECOMPILER;
14917:             goto out;
    1:         }
    1:         break;
    1:       default:;
    1:     }
    1:     len = PTRDIFF(end, begin, jsbytecode);
14917:     if (len <= 0) {
14917:         name = FAILED_EXPRESSION_DECOMPILER;
14917:         goto out;
14917:     }
12981: 
16072:     pcstack = (jsbytecode **)
16072:               JS_malloc(cx, StackDepth(script) * sizeof *pcstack);
14917:     if (!pcstack) {
14917:         name = NULL;
14917:         goto out;
14917:     }
12981: 
18989:     MUST_FLOW_THROUGH("out");
12981:     pcdepth = ReconstructPCStack(cx, script, begin, pcstack);
12981:     if (pcdepth < 0) {
12981:          name = FAILED_EXPRESSION_DECOMPILER;
12981:          goto out;
12981:     }
12579: 
12579:     name = NULL;
13702:     jp = JS_NEW_PRINTER(cx, "js_DecompileValueGenerator", fun, 0, JS_FALSE);
12579:     if (jp) {
12579:         jp->dvgfence = end;
12981:         jp->pcstack = pcstack;
13702:         if (DecompileCode(jp, script, begin, (uintN) len, (uintN) pcdepth)) {
12579:             name = (jp->sprinter.base) ? jp->sprinter.base : (char *) "";
12579:             name = JS_strdup(cx, name);
12579:         }
12579:         js_DestroyPrinter(jp);
12579:     }
12981: 
12981:   out:
14917:     if (code != oldcode) {
14917:         JS_free(cx, script->code);
14917:         script->code = oldcode;
14917:         script->main = oldmain;
14917:     }
14917: 
12981:     JS_free(cx, pcstack);
12579:     return name;
12579: }
12579: 
17862: uintN
17862: js_ReconstructStackDepth(JSContext *cx, JSScript *script, jsbytecode *pc)
17862: {
17862:     return ReconstructPCStack(cx, script, pc, NULL);
17862: }
17862: 
12579: static intN
17947: ReconstructPCStack(JSContext *cx, JSScript *script, jsbytecode *target,
12579:                    jsbytecode **pcstack)
12579: {
12579:     intN pcdepth, nuses, ndefs;
17947:     jsbytecode *pc;
12579:     JSOp op;
12579:     const JSCodeSpec *cs;
12579:     ptrdiff_t oplen;
12579:     jssrcnote *sn;
12981:     intN i;
12579: 
12579: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, -1);
    1: 
    1:     /*
12579:      * Walk forward from script->main and compute the stack depth and stack of
12579:      * operand-generating opcode PCs in pcstack.
12579:      *
    1:      * FIXME: Code to compute oplen copied from js_Disassemble1 and reduced.
    1:      * FIXME: Optimize to use last empty-stack sequence point.
    1:      */
17947:     LOCAL_ASSERT(script->main <= target && target < script->code + script->length);
    1:     pcdepth = 0;
17947:     for (pc = script->main; pc < target; pc += oplen) {
    1:         op = (JSOp) *pc;
    1:         if (op == JSOP_TRAP)
    1:             op = JS_GetTrapOpcode(cx, script, pc);
    1:         cs = &js_CodeSpec[op];
    1:         oplen = cs->length;
16072:         if (oplen < 0)
16072:             oplen = js_GetVariableBytecodeLength(pc);
    1: 
    1:         /*
17947:          * A (C ? T : E) expression requires skipping either T (if target is in
17947:          * E) or both T and E (if target is after the whole expression) before
    1:          * adjusting pcdepth based on the JSOP_IFEQ or JSOP_IFEQX at pc that
    1:          * tests condition C.  We know that the stack depth can't change from
    1:          * what it was with C on top of stack.
    1:          */
    1:         sn = js_GetSrcNote(script, pc);
    1:         if (sn && SN_TYPE(sn) == SRC_COND) {
    1:             ptrdiff_t jmpoff, jmplen;
    1: 
    1:             jmpoff = js_GetSrcNoteOffset(sn, 0);
17947:             if (pc + jmpoff < target) {
    1:                 pc += jmpoff;
 3164:                 op = (JSOp) *pc;
    1:                 JS_ASSERT(op == JSOP_GOTO || op == JSOP_GOTOX);
    1:                 cs = &js_CodeSpec[op];
    1:                 oplen = cs->length;
17198:                 JS_ASSERT(oplen > 0);
    1:                 jmplen = GetJumpOffset(pc, pc);
17947:                 if (pc + jmplen < target) {
    1:                     oplen = (uintN) jmplen;
    1:                     continue;
    1:                 }
    1: 
    1:                 /*
17947:                  * Ok, target lies in E. Manually pop C off the model stack,
    1:                  * since we have moved beyond the IFEQ now.
    1:                  */
    1:                 --pcdepth;
12579:                 LOCAL_ASSERT(pcdepth >= 0);
    1:             }
    1:         }
    1: 
    1:         if (sn && SN_TYPE(sn) == SRC_HIDDEN)
    1:             continue;
    1: 
    1:         nuses = cs->nuses;
18567:         if (nuses < 0)
18567:             nuses = js_GetVariableStackUseLength(op, pc);
    1: 
    1:         ndefs = cs->ndefs;
18567:         if (ndefs < 0) {
    1:             JSObject *obj;
    1: 
18567:             JS_ASSERT(op == JSOP_ENTERBLOCK);
 3235:             GET_OBJECT_FROM_BYTECODE(script, pc, 0, obj);
    1:             JS_ASSERT(OBJ_BLOCK_DEPTH(cx, obj) == pcdepth);
    1:             ndefs = OBJ_BLOCK_COUNT(cx, obj);
    1:         }
12579: 
18567:         pcdepth -= nuses;
18567:         LOCAL_ASSERT(pcdepth >= 0);
16072:         LOCAL_ASSERT((uintN)(pcdepth + ndefs) <= StackDepth(script));
12579: 
12579:         /*
12981:          * Fill the slots that the opcode defines withs its pc unless it just
12981:          * reshuffle the stack. In the latter case we want to preserve the
12981:          * opcode that generated the original value.
12579:          */
12579:         switch (op) {
12579:           default:
17862:             if (pcstack) {
12579:                 for (i = 0; i != ndefs; ++i)
12579:                     pcstack[pcdepth + i] = pc;
17862:             }
12579:             break;
12579: 
12579:           case JSOP_CASE:
12579:           case JSOP_CASEX:
12579:             /* Keep the switch value. */
12579:             JS_ASSERT(ndefs == 1);
12579:             break;
12579: 
12579:           case JSOP_DUP:
12579:             JS_ASSERT(ndefs == 2);
17862:             if (pcstack)
12579:                 pcstack[pcdepth + 1] = pcstack[pcdepth];
12579:             break;
12579: 
12579:           case JSOP_DUP2:
12579:             JS_ASSERT(ndefs == 4);
17862:             if (pcstack) {
12579:                 pcstack[pcdepth + 2] = pcstack[pcdepth];
12579:                 pcstack[pcdepth + 3] = pcstack[pcdepth + 1];
17862:             }
12579:             break;
12579:         }
    1:         pcdepth += ndefs;
    1:     }
17947:     LOCAL_ASSERT(pc == target);
12579:     return pcdepth;
12579: 
12579: #undef LOCAL_ASSERT
12579: }
12579: 
12579: #undef LOCAL_ASSERT_RV
