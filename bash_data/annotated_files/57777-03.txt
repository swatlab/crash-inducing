52557: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52557:  * vim: set ts=4 sw=4 et tw=99:
52557:  *
52557:  * ***** BEGIN LICENSE BLOCK *****
52557:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52557:  *
52557:  * The contents of this file are subject to the Mozilla Public License Version
52557:  * 1.1 (the "License"); you may not use this file except in compliance with
52557:  * the License. You may obtain a copy of the License at
52557:  * http://www.mozilla.org/MPL/
52557:  *
52557:  * Software distributed under the License is distributed on an "AS IS" basis,
52557:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52557:  * for the specific language governing rights and limitations under the
52557:  * License.
52557:  *
52557:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52557:  * May 28, 2008.
52557:  *
52557:  * The Initial Developer of the Original Code is
52557:  *   Brendan Eich <brendan@mozilla.org>
52557:  *
52557:  * Contributor(s):
52557:  *
52557:  * Alternatively, the contents of this file may be used under the terms of
52557:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52557:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52557:  * in which case the provisions of the GPL or the LGPL are applicable instead
52557:  * of those above. If you wish to allow use of your version of this file only
52557:  * under the terms of either the GPL or the LGPL, and not to allow others to
52557:  * use your version of this file under the terms of the MPL, indicate your
52557:  * decision by deleting the provisions above and replace them with the notice
52557:  * and other provisions required by the GPL or the LGPL. If you do not delete
52557:  * the provisions above, a recipient may use your version of this file under
52557:  * the terms of any one of the MPL, the GPL or the LGPL.
52557:  *
52557:  * ***** END LICENSE BLOCK ***** */
52557: 
52557: #if !defined jsjaeger_h__ && defined JS_METHODJIT
52557: #define jsjaeger_h__
52557: 
52557: #include "jscntxt.h"
52557: 
52557: #include "assembler/assembler/MacroAssemblerCodeRef.h"
52557: 
52557: #if !defined JS_CPU_X64 && \
52557:     !defined JS_CPU_X86 && \
52557:     !defined JS_CPU_ARM
52557: # error "Oh no, you should define a platform so this compiles."
52557: #endif
52557: 
53224: #if !defined(JS_NUNBOX32) && !defined(JS_PUNBOX64)
53224: # error "No boxing format selected."
52560: #endif
52560: 
52557: namespace js {
52557: 
52557: struct VMFrame
52557: {
52557:     union Arguments {
52825:         struct {
52825:             void *ptr;
52825:             void *ptr2;
53471:             void *ptr3;
52825:         } x;
57717:         struct {
57718:             uint32 lazyArgsObj;
57717:             uint32 dynamicArgc;
57717:         } call;
52557:     } u;
52557: 
53168:     VMFrame      *previous;
53626:     void         *unused;
52557:     JSFrameRegs  regs;
52557:     JSContext    *cx;
53422:     Value        *stackLimit;
57777:     JSStackFrame *entryfp;
52557: 
52557: #if defined(JS_CPU_X86)
52557:     void *savedEBX;
52557:     void *savedEDI;
52557:     void *savedESI;
52557:     void *savedEBP;
52557:     void *savedEIP;
52557: 
53012: # ifdef JS_NO_FASTCALL
53168:     inline void** returnAddressLocation() {
53168:         return reinterpret_cast<void**>(this) - 3;
53012:     }
53012: # else
53168:     inline void** returnAddressLocation() {
53168:         return reinterpret_cast<void**>(this) - 1;
52557:     }
53012: # endif
52557: #elif defined(JS_CPU_X64)
52557:     void *savedRBX;
53477: # ifdef _WIN64
52557:     void *savedRSI;
52557:     void *savedRDI;
52557: # endif
52557:     void *savedR15;
52557:     void *savedR14;
52557:     void *savedR13;
52557:     void *savedR12;
52557:     void *savedRBP;
52557:     void *savedRIP;
52557: 
53477: # ifdef _WIN64
53168:     inline void** returnAddressLocation() {
53168:         return reinterpret_cast<void**>(this) - 5;
52557:     }
52557: # else
53168:     inline void** returnAddressLocation() {
53168:         return reinterpret_cast<void**>(this) - 1;
52557:     }
52557: # endif
52557: 
52557: #elif defined(JS_CPU_ARM)
52557:     void *savedR4;
52557:     void *savedR5;
52557:     void *savedR6;
52557:     void *savedR7;
52557:     void *savedR8;
52557:     void *savedR9;
52557:     void *savedR10;
52557:     void *savedR11;
52557:     void *savedLR;
52557: 
53168:     inline void** returnAddressLocation() {
53361:         return reinterpret_cast<void**>(this) - 1;
52557:     }
52557: #else
52557: # error "The VMFrame layout isn't defined for your processor architecture!"
52557: #endif
52557: 
52557:     JSRuntime *runtime() { return cx->runtime; }
53422: 
53482:     JSStackFrame *&fp() { return regs.fp; }
52557: };
52557: 
52557: #ifdef JS_CPU_ARM
53361: // WARNING: Do not call this function directly from C(++) code because it is not ABI-compliant.
52557: extern "C" void JaegerStubVeneer(void);
52557: #endif
52557: 
55503: namespace mjit {
56773: 
56773: /*
56773:  * Trampolines to force returns from jit code.
56773:  * See also TrampolineCompiler::generateForceReturn(Fast).
56773:  */
56773: struct Trampolines {
56773:     typedef void (*TrampolinePtr)();
56773: 
56773:     TrampolinePtr       forceReturn;
56773:     JSC::ExecutablePool *forceReturnPool;
56773: 
56773: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
56773:     TrampolinePtr       forceReturnFast;
56773:     JSC::ExecutablePool *forceReturnFastPool;
56773: #endif
56773: };
56773: 
56773: /*
56773:  * Method JIT compartment data. Currently, there is exactly one per
56773:  * JS compartment. It would be safe for multiple JS compartments to
56773:  * share a JaegerCompartment as long as only one thread can enter
56773:  * the JaegerCompartment at a time.
56773:  */
56773: class JaegerCompartment {
56773:     JSC::ExecutableAllocator *execAlloc;     // allocator for jit code
56773:     Trampolines              trampolines;    // force-return trampolines
56773:     VMFrame                  *activeFrame_;  // current active VMFrame
56773: 
56773:     void Finish();
56773: 
56773:   public:
56773:     bool Initialize();
56773: 
56773:     ~JaegerCompartment() { Finish(); }
56773: 
56773:     JSC::ExecutablePool *poolForSize(size_t size) {
56773:         return execAlloc->poolForSize(size);
56773:     }
56773: 
56773:     VMFrame *activeFrame() {
56773:         return activeFrame_;
56773:     }
56773: 
56773:     void pushActiveFrame(VMFrame *f) {
56773:         f->previous = activeFrame_;
56773:         activeFrame_ = f;
56773:     }
56773: 
56773:     void popActiveFrame() {
56773:         JS_ASSERT(activeFrame_);
56773:         activeFrame_ = activeFrame_->previous;
56773:     }
56773: 
56773:     Trampolines::TrampolinePtr forceReturnTrampoline() const {
56773:         return trampolines.forceReturn;
56773:     }
56773: 
56773: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
56773:     Trampolines::TrampolinePtr forceReturnFastTrampoline() const {
56773:         return trampolines.forceReturnFast;
56773:     }
56773: #endif
56773: };
56773: 
57679: /*
57679:  * Allocation policy for compiler jstl objects. The goal is to free the
57679:  * compiler from having to check and propagate OOM after every time we
57679:  * append to a vector. We do this by reporting OOM to the engine and
57679:  * setting a flag on the compiler when OOM occurs. The compiler is required
57679:  * to check for OOM only before trying to use the contents of the list.
57679:  */
57679: class CompilerAllocPolicy : public ContextAllocPolicy
57679: {
57679:     bool *oomFlag;
57679: 
57679:     void *checkAlloc(void *p) {
57679:         if (!p)
57679:             *oomFlag = true;
57679:         return p;
57679:     }
57679: 
57679:   public:
57679:     CompilerAllocPolicy(JSContext *cx, bool *oomFlag)
57679:     : ContextAllocPolicy(cx), oomFlag(oomFlag) {}
57679:     CompilerAllocPolicy(JSContext *cx, Compiler &compiler);
57679: 
57679:     void *malloc(size_t bytes) { return checkAlloc(ContextAllocPolicy::malloc(bytes)); }
57679:     void *realloc(void *p, size_t bytes) {
57679:         return checkAlloc(ContextAllocPolicy::realloc(p, bytes));
57679:     }
57679: };
57679: 
55503: namespace ic {
55503: # if defined JS_POLYIC
55503:     struct PICInfo;
56738:     struct GetElementIC;
57671:     struct SetElementIC;
55503: # endif
55503: # if defined JS_MONOIC
55503:     struct MICInfo;
56192:     struct EqualityICInfo;
56217:     struct TraceICInfo;
55503:     struct CallICInfo;
55503: # endif
55503: }
55503: }
55503: 
52557: typedef void (JS_FASTCALL *VoidStub)(VMFrame &);
52623: typedef void (JS_FASTCALL *VoidVpStub)(VMFrame &, Value *);
52557: typedef void (JS_FASTCALL *VoidStubUInt32)(VMFrame &, uint32);
52557: typedef void (JS_FASTCALL *VoidStubInt32)(VMFrame &, int32);
52557: typedef JSBool (JS_FASTCALL *BoolStub)(VMFrame &);
52557: typedef void * (JS_FASTCALL *VoidPtrStub)(VMFrame &);
52557: typedef void * (JS_FASTCALL *VoidPtrStubPC)(VMFrame &, jsbytecode *);
52557: typedef void * (JS_FASTCALL *VoidPtrStubUInt32)(VMFrame &, uint32);
52557: typedef JSObject * (JS_FASTCALL *JSObjStub)(VMFrame &);
52557: typedef JSObject * (JS_FASTCALL *JSObjStubUInt32)(VMFrame &, uint32);
52727: typedef JSObject * (JS_FASTCALL *JSObjStubFun)(VMFrame &, JSFunction *);
53591: typedef void (JS_FASTCALL *VoidStubFun)(VMFrame &, JSFunction *);
52738: typedef JSObject * (JS_FASTCALL *JSObjStubJSObj)(VMFrame &, JSObject *);
52738: typedef void (JS_FASTCALL *VoidStubAtom)(VMFrame &, JSAtom *);
52738: typedef JSString * (JS_FASTCALL *JSStrStub)(VMFrame &);
52740: typedef JSString * (JS_FASTCALL *JSStrStubUInt32)(VMFrame &, uint32);
52785: typedef void (JS_FASTCALL *VoidStubJSObj)(VMFrame &, JSObject *);
53168: typedef void (JS_FASTCALL *VoidStubPC)(VMFrame &, jsbytecode *);
53590: typedef JSBool (JS_FASTCALL *BoolStubUInt32)(VMFrame &f, uint32);
55503: #ifdef JS_MONOIC
55503: typedef void (JS_FASTCALL *VoidStubCallIC)(VMFrame &, js::mjit::ic::CallICInfo *);
55503: typedef void * (JS_FASTCALL *VoidPtrStubCallIC)(VMFrame &, js::mjit::ic::CallICInfo *);
55503: typedef void (JS_FASTCALL *VoidStubMIC)(VMFrame &, js::mjit::ic::MICInfo *);
55503: typedef void * (JS_FASTCALL *VoidPtrStubMIC)(VMFrame &, js::mjit::ic::MICInfo *);
56192: typedef JSBool (JS_FASTCALL *BoolStubEqualityIC)(VMFrame &, js::mjit::ic::EqualityICInfo *);
56217: typedef void * (JS_FASTCALL *VoidPtrStubTraceIC)(VMFrame &, js::mjit::ic::TraceICInfo *);
55503: #endif
55503: #ifdef JS_POLYIC
55503: typedef void (JS_FASTCALL *VoidStubPIC)(VMFrame &, js::mjit::ic::PICInfo *);
56738: typedef void (JS_FASTCALL *VoidStubGetElemIC)(VMFrame &, js::mjit::ic::GetElementIC *);
57671: typedef void (JS_FASTCALL *VoidStubSetElemIC)(VMFrame &f, js::mjit::ic::SetElementIC *);
55503: #endif
52557: 
52557: namespace mjit {
52557: 
55503: struct CallSite;
55503: 
53498: struct JITScript {
55503:     typedef JSC::MacroAssemblerCodeRef CodeRef;
55503:     CodeRef         code;       /* pool & code addresses */
55687:     void            **nmap;     /* pc -> JIT code map, sparse */
55503: 
53498:     js::mjit::CallSite *callSites;
53498:     uint32          nCallSites;
53498: #ifdef JS_MONOIC
55503:     ic::MICInfo     *mics;      /* MICs in this script. */
53498:     uint32          nMICs;      /* number of MonoICs */
55503:     ic::CallICInfo  *callICs;   /* CallICs in this script. */
53590:     uint32          nCallICs;   /* number of call ICs */
56192:     ic::EqualityICInfo *equalityICs;
56192:     uint32          nEqualityICs;
56217:     ic::TraceICInfo *traceICs;
56217:     uint32          nTraceICs;
56192: 
56192:     // Additional ExecutablePools that IC stubs were generated into.
56192:     typedef Vector<JSC::ExecutablePool *, 0, SystemAllocPolicy> ExecPoolVector;
56192:     ExecPoolVector execPools;
53498: #endif
53498: #ifdef JS_POLYIC
55503:     ic::PICInfo     *pics;      /* PICs in this script */
53498:     uint32          nPICs;      /* number of PolyICs */
56738:     ic::GetElementIC *getElems;
56738:     uint32           nGetElems;
57671:     ic::SetElementIC *setElems;
57671:     uint32           nSetElems;
53498: #endif
55503:     void            *invokeEntry;       /* invoke address */
55503:     void            *fastEntry;         /* cached entry, fastest */
55503:     void            *arityCheckEntry;   /* arity check address */
55503: 
57758:     ~JITScript();
57758: 
55503:     bool isValidCode(void *ptr) {
55503:         char *jitcode = (char *)code.m_code.executableAddress();
55503:         char *jcheck = (char *)ptr;
55503:         return jcheck >= jitcode && jcheck < jitcode + code.m_size;
55503:     }
55503: 
55503:     void sweepCallICs();
55503:     void purgeMICs();
55503:     void purgePICs();
53498: };
53498: 
55565: /*
55565:  * Execute the given mjit code. This is a low-level call and callers must
55565:  * provide the same guarantees as JaegerShot/CheckStackAndEnterMethodJIT.
55565:  */
55565: JSBool EnterMethodJIT(JSContext *cx, JSStackFrame *fp, void *code, Value *stackLimit);
55565: 
53471: /* Execute a method that has been JIT compiled. */
53471: JSBool JaegerShot(JSContext *cx);
53471: 
53471: /* Drop into the middle of a method at an arbitrary point, and execute. */
53471: JSBool JaegerShotAtSafePoint(JSContext *cx, void *safePoint);
52557: 
52557: enum CompileStatus
52557: {
52557:     Compile_Okay,
52557:     Compile_Abort,
52557:     Compile_Error
52557: };
52557: 
52853: void JS_FASTCALL
52853: ProfileStubCall(VMFrame &f);
52853: 
54626: CompileStatus JS_NEVER_INLINE
55503: TryCompile(JSContext *cx, JSStackFrame *fp);
52557: 
52559: void
52559: ReleaseScriptCode(JSContext *cx, JSScript *script);
52559: 
52557: static inline CompileStatus
55503: CanMethodJIT(JSContext *cx, JSScript *script, JSStackFrame *fp)
52557: {
55503:     if (!cx->methodJitEnabled)
52557:         return Compile_Abort;
55503:     JITScriptStatus status = script->getJITStatus(fp->isConstructing());
55503:     if (status == JITScript_Invalid)
55503:         return Compile_Abort;
55503:     if (status == JITScript_None)
55503:         return TryCompile(cx, fp);
52557:     return Compile_Okay;
52557: }
52557: 
53498: struct CallSite
53168: {
53168:     uint32 codeOffset;
53168:     uint32 pcOffset;
53168:     uint32 id;
57766: 
57766:     // Normally, callsite ID is the __LINE__ in the program that added the
57766:     // callsite. Since traps can be removed, we make sure they carry over
57766:     // from each compilation, and identify them with a single, canonical
57766:     // ID. Hopefully a SpiderMonkey file won't have two billion source lines.
57766:     static const uint32 MAGIC_TRAP_ID = 0xFEDCBABC;
57766: 
57766:     void initialize(uint32 codeOffset, uint32 pcOffset, uint32 id) {
57766:         this->codeOffset = codeOffset;
57766:         this->pcOffset = pcOffset;
57766:         this->id = id;
57766:     }
57766: 
57766:     bool isTrap() const {
57766:         return id == MAGIC_TRAP_ID;
57766:     }
53168: };
53168: 
56217: /* Re-enables a tracepoint in the method JIT. */
56217: void
56217: EnableTraceHint(JSScript *script, jsbytecode *pc, uint16_t index);
56217: 
56551: uintN
56551: GetCallTargetCount(JSScript *script, jsbytecode *pc);
56551: 
52557: } /* namespace mjit */
52557: 
52557: } /* namespace js */
52557: 
55687: inline void *
55687: JSScript::maybeNativeCodeForPC(bool constructing, jsbytecode *pc)
55687: {
55687:     js::mjit::JITScript *jit = getJIT(constructing);
55687:     if (!jit)
55687:         return NULL;
55687:     JS_ASSERT(pc >= code && pc < code + length);
55687:     return jit->nmap[pc - code];
55687: }
55687: 
55687: inline void **
55687: JSScript::nativeMap(bool constructing)
55687: {
55687:     return getJIT(constructing)->nmap;
55687: }
55687: 
55687: inline void *
55687: JSScript::nativeCodeForPC(bool constructing, jsbytecode *pc)
55687: {
55687:     void **nmap = nativeMap(constructing);
55687:     JS_ASSERT(pc >= code && pc < code + length);
55687:     JS_ASSERT(nmap[pc - code]);
55687:     return nmap[pc - code];
55687: }
55687: 
52557: #ifdef _MSC_VER
52557: extern "C" void *JaegerThrowpoline(js::VMFrame *vmFrame);
52557: #else
52557: extern "C" void JaegerThrowpoline();
52557: #endif
53471: extern "C" void InjectJaegerReturn();
52557: 
52557: #endif /* jsjaeger_h__ */
52880: 
