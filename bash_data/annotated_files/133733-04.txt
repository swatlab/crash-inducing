     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * the container for the style sheets that apply to a presentation, and
     1:  * the internal API that the style system exposes for creating (and
     1:  * potentially re-creating) style contexts
     1:  */
     1: 
     1: #ifndef nsStyleSet_h_
     1: #define nsStyleSet_h_
     1: 
 86054: #include "mozilla/Attributes.h"
 86054: 
     1: #include "nsIStyleRuleProcessor.h"
 36785: #include "nsCSSStyleSheet.h"
     1: #include "nsBindingManager.h"
     1: #include "nsRuleNode.h"
  3959: #include "nsTArray.h"
  3959: #include "nsCOMArray.h"
 21924: #include "nsAutoPtr.h"
 22737: #include "nsIStyleRule.h"
 35554: #include "nsCSSPseudoElements.h"
 35554: #include "nsCSSAnonBoxes.h"
102311: #include "mozilla/Attributes.h"
     1: 
     1: class nsIURI;
 21924: class nsCSSFontFaceRule;
 67980: class nsCSSKeyframesRule;
121979: class nsCSSPageRule;
 30988: class nsRuleWalker;
121909: struct ElementDependentRuleProcessorData;
 64158: struct TreeMatchContext;
     1: 
102311: class nsEmptyStyleRule MOZ_FINAL : public nsIStyleRule
 22737: {
 22737:   NS_DECL_ISUPPORTS
 43120:   virtual void MapRuleInfoInto(nsRuleData* aRuleData);
 22737: #ifdef DEBUG
113981:   virtual void List(FILE* out = stdout, int32_t aIndent = 0) const MOZ_OVERRIDE;
 22737: #endif
 22737: };
 22737: 
102311: class nsInitialStyleRule MOZ_FINAL : public nsIStyleRule
 77005: {
 77005:   NS_DECL_ISUPPORTS
 77005:   virtual void MapRuleInfoInto(nsRuleData* aRuleData);
 77005: #ifdef DEBUG
113981:   virtual void List(FILE* out = stdout, int32_t aIndent = 0) const MOZ_OVERRIDE;
 77005: #endif
 77005: };
 77005: 
     1: // The style set object is created by the document viewer and ownership is
     1: // then handed off to the PresShell.  Only the PresShell should delete a
     1: // style set.
     1: 
     1: class nsStyleSet
     1: {
     1:  public:
     1:   nsStyleSet();
     1: 
 84365:   size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 74692: 
     1:   // Initialize the object.  You must check the return code and not use
     1:   // the nsStyleSet if Init() fails.
     1: 
     1:   nsresult Init(nsPresContext *aPresContext);
     1: 
 24429:   nsRuleNode* GetRuleTree() { return mRuleTree; }
 24429: 
     1:   // enable / disable the Quirk style sheet
 79445:   void EnableQuirkStyleSheet(bool aEnable);
     1: 
     1:   // get a style context for a non-pseudo frame.
     1:   already_AddRefed<nsStyleContext>
 41643:   ResolveStyleFor(mozilla::dom::Element* aElement,
 41643:                   nsStyleContext* aParentContext);
     1: 
 64158:   already_AddRefed<nsStyleContext>
 64158:   ResolveStyleFor(mozilla::dom::Element* aElement,
 64158:                   nsStyleContext* aParentContext,
 64158:                   TreeMatchContext& aTreeMatchContext);
 64158: 
 40171:   // Get a style context (with the given parent) for the
 40171:   // sequence of style rules in the |aRules| array.
  3964:   already_AddRefed<nsStyleContext>
 31309:   ResolveStyleForRules(nsStyleContext* aParentContext,
119242:                        const nsTArray< nsCOMPtr<nsIStyleRule> > &aRules);
 40171: 
125555:   // used in ResolveStyleForRules below
125555:   struct RuleAndLevel
125555:   {
125555:     nsIStyleRule* mRule;
125555:     uint8_t mLevel;
125555:   };
125555: 
125555:   // Get a new style context for aElement for the rules in aRules
125555:   // aRules is an array of rules and their levels in reverse order,
125555:   // that is from the leaf-most to the root-most rule in the rule tree.
125555:   already_AddRefed<nsStyleContext>
125555:   ResolveStyleForRules(nsStyleContext* aParentContext,
125555:                        nsStyleContext* aOldStyle,
125555:                        const nsTArray<RuleAndLevel>& aRules);
125555: 
 40171:   // Get a style context that represents aBaseContext, but as though
 40171:   // it additionally matched the rules in the aRules array (in that
 40171:   // order, as more specific than any other rules).
 40171:   already_AddRefed<nsStyleContext>
 40171:   ResolveStyleByAddingRules(nsStyleContext* aBaseContext,
 31309:                             const nsCOMArray<nsIStyleRule> &aRules);
  3964: 
     1:   // Get a style context for a non-element (which no rules will match),
     1:   // such as text nodes, placeholder frames, and the nsFirstLetterFrame
     1:   // for everything after the first letter.
     1:   //
     1:   // Perhaps this should go away and we shouldn't even create style
     1:   // contexts for such content nodes.  However, not doing any rule
     1:   // matching for them is a first step.
     1:   already_AddRefed<nsStyleContext>
     1:   ResolveStyleForNonElement(nsStyleContext* aParentContext);
     1: 
 41643:   // Get a style context for a pseudo-element.  aParentElement must be
 35554:   // non-null.  aPseudoID is the nsCSSPseudoElements::Type for the
 35554:   // pseudo-element.
 35554:   already_AddRefed<nsStyleContext>
 41643:   ResolvePseudoElementStyle(mozilla::dom::Element* aParentElement,
 35554:                             nsCSSPseudoElements::Type aType,
 35555:                             nsStyleContext* aParentContext);
 35554: 
 35554:   // This functions just like ResolvePseudoElementStyle except that it will
106838:   // return nullptr if there are no explicit style rules for that
 35554:   // pseudo element.
 35554:   already_AddRefed<nsStyleContext>
 41643:   ProbePseudoElementStyle(mozilla::dom::Element* aParentElement,
 35554:                           nsCSSPseudoElements::Type aType,
 35554:                           nsStyleContext* aParentContext);
 64158:   already_AddRefed<nsStyleContext>
 64158:   ProbePseudoElementStyle(mozilla::dom::Element* aParentElement,
 64158:                           nsCSSPseudoElements::Type aType,
 64158:                           nsStyleContext* aParentContext,
 64158:                           TreeMatchContext& aTreeMatchContext);
 35554:   
 35554:   // Get a style context for an anonymous box.  aPseudoTag is the
 35554:   // pseudo-tag to use and must be non-null.
 35554:   already_AddRefed<nsStyleContext>
 35556:   ResolveAnonymousBoxStyle(nsIAtom* aPseudoTag, nsStyleContext* aParentContext);
 35554: 
 35554: #ifdef MOZ_XUL
 35554:   // Get a style context for a XUL tree pseudo.  aPseudoTag is the
 35554:   // pseudo-tag to use and must be non-null.  aParentContent must be
 35554:   // non-null.  aComparator must be non-null.
 35554:   already_AddRefed<nsStyleContext>
 41643:   ResolveXULTreePseudoStyle(mozilla::dom::Element* aParentElement,
 35554:                             nsIAtom* aPseudoTag,
 35554:                             nsStyleContext* aParentContext,
 35558:                             nsICSSPseudoComparator* aComparator);
 35554: #endif
 35554: 
 21924:   // Append all the currently-active font face rules to aArray.  Return
 21924:   // true for success and false for failure.
 79445:   bool AppendFontFaceRules(nsPresContext* aPresContext,
 21983:                              nsTArray<nsFontFaceRuleContainer>& aArray);
 21924: 
 67980:   // Append all the currently-active keyframes rules to aArray.  Return
 67980:   // true for success and false for failure.
 79445:   bool AppendKeyframesRules(nsPresContext* aPresContext,
 67980:                               nsTArray<nsCSSKeyframesRule*>& aArray);
 67980: 
121979:   // Append all the currently-active page rules to aArray.  Return
121979:   // true for success and false for failure.
121979:   bool AppendPageRules(nsPresContext* aPresContext,
121979:                        nsTArray<nsCSSPageRule*>& aArray);
121979: 
     1:   // Begin ignoring style context destruction, to avoid lots of unnecessary
     1:   // work on document teardown.
     1:   void BeginShutdown(nsPresContext* aPresContext);
     1: 
     1:   // Free all of the data associated with this style set.
     1:   void Shutdown(nsPresContext* aPresContext);
     1: 
     1:   // Notification that a style context is being destroyed.
     1:   void NotifyStyleContextDestroyed(nsPresContext* aPresContext,
     1:                                    nsStyleContext* aStyleContext);
     1: 
     1:   // Get a new style context that lives in a different parent
     1:   // The new context will be the same as the old if the new parent is the
     1:   // same as the old parent.
 44166:   // aElement should be non-null if this is a style context for an
 44166:   // element or pseudo-element; in the latter case it should be the
 44166:   // real element the pseudo-element is for.
     1:   already_AddRefed<nsStyleContext>
 40136:   ReparentStyleContext(nsStyleContext* aStyleContext,
 44166:                        nsStyleContext* aNewParentContext,
 44166:                        mozilla::dom::Element* aElement);
     1: 
 39698:   // Test if style is dependent on a document state.
 79445:   bool HasDocumentStateDependentStyle(nsPresContext* aPresContext,
 39698:                                         nsIContent*    aContent,
 56168:                                         nsEventStates  aStateMask);
 39698: 
     1:   // Test if style is dependent on content state
 40075:   nsRestyleHint HasStateDependentStyle(nsPresContext* aPresContext,
 42323:                                        mozilla::dom::Element* aElement,
 56168:                                        nsEventStates aStateMask);
     1: 
     1:   // Test if style is dependent on the presence of an attribute.
 40075:   nsRestyleHint HasAttributeDependentStyle(nsPresContext* aPresContext,
 42323:                                            mozilla::dom::Element* aElement,
     1:                                            nsIAtom*       aAttribute,
108991:                                            int32_t        aModType,
 79445:                                            bool           aAttrHasChanged);
     1: 
 16225:   /*
 16225:    * Do any processing that needs to happen as a result of a change in
 16225:    * the characteristics of the medium, and return whether style rules
 16225:    * may have changed as a result.
 16225:    */
 79445:   bool MediumFeaturesChanged(nsPresContext* aPresContext);
 16225: 
     1:   // APIs for registering objects that can supply additional
     1:   // rules during processing.
     1:   void SetBindingManager(nsBindingManager* aBindingManager)
     1:   {
     1:     mBindingManager = aBindingManager;
     1:   }
     1: 
     1:   // The "origins" of the CSS cascade, from lowest precedence to
     1:   // highest (for non-!important rules).
     1:   enum sheetType {
     1:     eAgentSheet, // CSS
     1:     eUserSheet, // CSS
 60634:     ePresHintSheet,
     1:     eDocSheet, // CSS
128825:     eScopedDocSheet,
     1:     eStyleAttrSheet,
     1:     eOverrideSheet, // CSS
 67985:     eAnimationSheet,
 69179:     eTransitionSheet,
     1:     eSheetTypeCount
  1539:     // be sure to keep the number of bits in |mDirty| below and in
  1539:     // NS_RULE_NODE_LEVEL_MASK updated when changing the number of sheet
  1539:     // types
     1:   };
     1: 
     1:   // APIs to manipulate the style sheet lists.  The sheets in each
     1:   // list are stored with the most significant sheet last.
     1:   nsresult AppendStyleSheet(sheetType aType, nsIStyleSheet *aSheet);
     1:   nsresult PrependStyleSheet(sheetType aType, nsIStyleSheet *aSheet);
     1:   nsresult RemoveStyleSheet(sheetType aType, nsIStyleSheet *aSheet);
     1:   nsresult ReplaceSheets(sheetType aType,
     1:                          const nsCOMArray<nsIStyleSheet> &aNewSheets);
120316:   nsresult InsertStyleSheetBefore(sheetType aType, nsIStyleSheet *aNewSheet,
120316:                                   nsIStyleSheet *aReferenceSheet);
     1: 
128825:   // Enable/Disable entire author style level (Doc, ScopedDoc & PresHint levels)
 79445:   bool GetAuthorStyleDisabled();
 79445:   nsresult SetAuthorStyleDisabled(bool aStyleDisabled);
     1: 
108991:   int32_t SheetCount(sheetType aType) const {
     1:     return mSheets[aType].Count();
     1:   }
     1: 
108991:   nsIStyleSheet* StyleSheetAt(sheetType aType, int32_t aIndex) const {
     1:     return mSheets[aType].ObjectAt(aIndex);
     1:   }
     1: 
128825:   nsresult RemoveDocStyleSheet(nsIStyleSheet* aSheet);
     1:   nsresult AddDocStyleSheet(nsIStyleSheet* aSheet, nsIDocument* aDocument);
     1: 
     1:   void     BeginUpdate();
     1:   nsresult EndUpdate();
     1: 
  3959:   // Methods for reconstructing the tree; BeginReconstruct basically moves the
  3959:   // old rule tree root and style context roots out of the way,
  3959:   // and EndReconstruct destroys the old rule tree when we're done
  3959:   nsresult BeginReconstruct();
  3959:   // Note: EndReconstruct should not be called if BeginReconstruct fails
  3959:   void EndReconstruct();
  3959: 
 21209:   // Let the style set know that a particular sheet is the quirks sheet.  This
 21209:   // sheet must already have been added to the UA sheets.  The pointer must not
 21209:   // be null.  This should only be called once for a given style set.
 21209:   void SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet);
 21209: 
 23163:   // Return whether the rule tree has cached data such that we need to
 23163:   // do dynamic change handling for changes that change the results of
 23163:   // media queries or require rebuilding all style data.
 23163:   // We don't care whether we have cached rule processors or whether
 23163:   // they have cached rule cascades; getting the rule cascades again in
 23163:   // order to do rule matching will get the correct rule cascade.
 79445:   bool HasCachedStyleData() const {
 23163:     return (mRuleTree && mRuleTree->TreeHasCachedData()) || !mRoots.IsEmpty();
 23163:   }
 23163: 
 33020:   // Notify the style set that a rulenode is no longer in use, or was
 33020:   // just created and is not in use yet.
 33020:   void RuleNodeUnused() {
 33020:     ++mUnusedRuleNodeCount;
 33020:   }
 33020: 
 33020:   // Notify the style set that a rulenode that wasn't in use now is
 33020:   void RuleNodeInUse() {
 33020:     --mUnusedRuleNodeCount;
 33020:   }
 33020: 
 36785:   nsCSSStyleSheet::EnsureUniqueInnerResult EnsureUniqueInnerOnCSSSheets();
 36785: 
 77005:   nsIStyleRule* InitialStyleRule();
 77005: 
     1:  private:
 86054:   nsStyleSet(const nsStyleSet& aCopy) MOZ_DELETE;
 86054:   nsStyleSet& operator=(const nsStyleSet& aCopy) MOZ_DELETE;
     1: 
 24429:   // Run mark-and-sweep GC on mRuleTree and mOldRuleTrees, based on mRoots.
 24429:   void GCRuleTrees();
 24429: 
     1:   // Update the rule processor list after a change to the style sheet list.
     1:   nsresult GatherRuleProcessors(sheetType aType);
     1: 
     1:   void AddImportantRules(nsRuleNode* aCurrLevelNode,
 33399:                          nsRuleNode* aLastPrevLevelNode,
 33399:                          nsRuleWalker* aRuleWalker);
     1: 
 33399:   // Move aRuleWalker forward by the appropriate rule if we need to add
 22737:   // a rule due to property restrictions on pseudo-elements.
 35555:   void WalkRestrictionRule(nsCSSPseudoElements::Type aPseudoType,
 33399:                            nsRuleWalker* aRuleWalker);
 22737: 
     1: #ifdef DEBUG
     1:   // Just like AddImportantRules except it doesn't actually add anything; it
     1:   // just asserts that there are no important rules between aCurrLevelNode and
     1:   // aLastPrevLevelNode.
     1:   void AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
     1:                               nsRuleNode* aLastPrevLevelNode);
     1:   
     1:   // Just like AddImportantRules except it doesn't actually add anything; it
     1:   // just asserts that there are no CSS rules between aCurrLevelNode and
 60633:   // aLastPrevLevelNode.  Mostly useful for the preshint level.
     1:   void AssertNoCSSRules(nsRuleNode* aCurrLevelNode,
     1:                         nsRuleNode* aLastPrevLevelNode);
     1: #endif
     1:   
     1:   // Enumerate the rules in a way that cares about the order of the
     1:   // rules.
128824:   // aElement is the element the rules are for.  It might be null.  aData
 35556:   // is the closure to pass to aCollectorFunc.  If aContent is not null,
 35556:   // aData must be a RuleProcessorData*
     1:   void FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc,
128824:                  RuleProcessorData* aData, mozilla::dom::Element* aElement,
121909:                  nsRuleWalker* aRuleWalker);
     1: 
     1:   // Enumerate all the rules in a way that doesn't care about the order
     1:   // of the rules and break out if the enumeration is halted.
     1:   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
121909:                           ElementDependentRuleProcessorData* aData,
 79445:                           bool aWalkAllXBLStylesheets);
     1: 
131259:   /**
131259:    * Bit-flags that can be passed to GetContext() in its parameter 'aFlags'.
131259:    */
131259:   enum {
131259:     eNoFlags =          0,
131259:     eIsLink =           1 << 0,
131259:     eIsVisitedLink =    1 << 1,
133733:     eDoAnimation =      1 << 2,
133733: 
133733:     // Indicates that we should skip the flex-item-specific chunk of
133733:     // ApplyStyleFixups().  This is useful if our parent has "display: flex"
133733:     // but we can tell it's not going to actually be a flex container (e.g. if
133733:     // it's the outer frame of a button widget, and we're the inline frame for
133733:     // the button's label).
133733:     eSkipFlexItemStyleFixup = 1 << 3
131259:   };
131259: 
 40136:   already_AddRefed<nsStyleContext>
 40136:   GetContext(nsStyleContext* aParentContext,
 33399:              nsRuleNode* aRuleNode,
 40189:              nsRuleNode* aVisitedRuleNode,
 35554:              nsIAtom* aPseudoTag,
 67985:              nsCSSPseudoElements::Type aPseudoType,
131259:              mozilla::dom::Element* aElementForAnimation,
131259:              uint32_t aFlags);
     1: 
132811:   nsPresContext* PresContext() { return mRuleTree->PresContext(); }
     1: 
     1:   // The sheets in each array in mSheets are stored with the most significant
     1:   // sheet last.
     1:   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
     1: 
128826:   // mRuleProcessors[eScopedDocSheet] is always null; rule processors
128826:   // for scoped style sheets are stored in mScopedDocSheetRuleProcessors.
     1:   nsCOMPtr<nsIStyleRuleProcessor> mRuleProcessors[eSheetTypeCount];
     1: 
128826:   // Rule processors for HTML5 scoped style sheets, one per scope.
128826:   nsTArray<nsCOMPtr<nsIStyleRuleProcessor> > mScopedDocSheetRuleProcessors;
128826: 
     1:   // cached instance for enabling/disabling
     1:   nsCOMPtr<nsIStyleSheet> mQuirkStyleSheet;
     1: 
     1:   nsRefPtr<nsBindingManager> mBindingManager;
     1: 
     1:   nsRuleNode* mRuleTree; // This is the root of our rule tree.  It is a
     1:                          // lexicographic tree of matched rules that style
     1:                          // contexts use to look up properties.
     1: 
108991:   uint16_t mBatching;
 96761: 
 96761:   unsigned mInShutdown : 1;
 96761:   unsigned mAuthorStyleDisabled: 1;
 96761:   unsigned mInReconstruct : 1;
128825:   unsigned mDirty : 9;  // one dirty bit is used per sheet type
 96761: 
108991:   uint32_t mUnusedRuleNodeCount; // used to batch rule node GC
  3959:   nsTArray<nsStyleContext*> mRoots; // style contexts with no parent
     1: 
 22737:   // Empty style rules to force things that restrict which properties
 22737:   // apply into different branches of the rule tree.
121456:   nsRefPtr<nsEmptyStyleRule> mFirstLineRule, mFirstLetterRule, mPlaceholderRule;
 22737: 
 77005:   // Style rule which sets all properties to their initial values for
 77005:   // determining when context-sensitive values are in use.
 77005:   nsRefPtr<nsInitialStyleRule> mInitialStyleRule;
 77005: 
 24429:   // Old rule trees, which should only be non-empty between
 24429:   // BeginReconstruct and EndReconstruct, but in case of bugs that cause
 24429:   // style contexts to exist too long, may last longer.
 24429:   nsTArray<nsRuleNode*> mOldRuleTrees;
     1: };
     1: 
 42984: #ifdef _IMPL_NS_LAYOUT
 33020: inline
 40517: void nsRuleNode::AddRef()
 33020: {
 33020:   if (mRefCnt++ == 0 && !IsRoot()) {
 33020:     mPresContext->StyleSet()->RuleNodeInUse();
 33020:   }
 33020: }
 33020: 
 33020: inline
 40517: void nsRuleNode::Release()
 33020: {
 33020:   if (--mRefCnt == 0 && !IsRoot()) {
 33020:     mPresContext->StyleSet()->RuleNodeUnused();
 33020:   }
 33020: }
     1: #endif
 42984: 
 42984: #endif
