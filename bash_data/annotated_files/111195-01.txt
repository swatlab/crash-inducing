     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set sw=2 ts=2 et tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 46852: #include "base/basictypes.h"
 46852: 
 80467: /* This must occur *after* base/basictypes.h to avoid typedefs conflicts. */
 80467: #include "mozilla/Util.h"
 80467: 
     1: // Local Includes
     1: #include "nsGlobalWindow.h"
 81313: #include "Navigator.h"
     1: #include "nsScreen.h"
     1: #include "nsHistory.h"
 72298: #include "nsPerformance.h"
 72298: #include "nsDOMNavigationTiming.h"
     1: #include "nsBarProps.h"
     1: #include "nsDOMStorage.h"
  1938: #include "nsDOMOfflineResourceList.h"
108290: #include "nsError.h"
103224: #include "nsIIdleService.h"
     1: 
 93484: #ifdef XP_WIN
 93484: #ifdef GetClassName
 93484: #undef GetClassName
 93484: #endif // GetClassName
 93484: #endif // XP_WIN
 93484: 
     1: // Helper Classes
     1: #include "nsXPIDLString.h"
     1: #include "nsJSUtils.h"
     1: #include "prmem.h"
     1: #include "jsapi.h"              // for JSAutoRequest
     1: #include "jsdbgapi.h"           // for JS_ClearWatchPointsForObject
 80154: #include "jsfriendapi.h"        // for JS_GetGlobalForFrame
 93876: #include "jswrapper.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsDOMClassInfo.h"
 62725: #include "nsJSEnvironment.h"
 64411: #include "nsCharSeparatedTokenizer.h" // for Accept-Language parsing
 64411: #include "nsUnicharUtils.h"
 70840: #include "mozilla/Preferences.h"
     1: 
     1: // Other Classes
 72328: #include "nsEventListenerManager.h"
     1: #include "nsEscape.h"
     1: #include "nsStyleCoord.h"
     1: #include "nsMimeTypeArray.h"
     1: #include "nsNetUtil.h"
  3239: #include "nsICachingChannel.h"
     1: #include "nsPluginArray.h"
     1: #include "nsIPluginHost.h"
 70185: #include "nsPluginHost.h"
 70185: #include "nsIPluginInstanceOwner.h"
 15958: #include "nsGeolocation.h"
 52355: #include "nsDesktopNotification.h"
     1: #include "nsContentCID.h"
     1: #include "nsLayoutStatics.h"
     1: #include "nsCycleCollector.h"
  1353: #include "nsCCUncollectableMarker.h"
 37802: #include "nsAutoJSValHolder.h"
 68769: #include "nsDOMMediaQueryList.h"
 74337: #include "mozilla/dom/workers/Workers.h"
102067: #include "nsJSPrincipals.h"
102221: #include "mozilla/Attributes.h"
     1: 
     1: // Interfaces Needed
 29018: #include "nsIFrame.h"
 34149: #include "nsCanvasFrame.h"
     1: #include "nsIWidget.h"
108457: #include "nsIWidgetListener.h"
     1: #include "nsIBaseWindow.h"
 94011: #include "nsDeviceSensors.h"
     1: #include "nsIContent.h"
     1: #include "nsIContentViewerEdit.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellLoadInfo.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
 29018: #include "nsIEditorDocShell.h"
     1: #include "nsIDocCharset.h"
     1: #include "nsIDocument.h"
     1: #include "nsIHTMLDocument.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMHTMLElement.h"
 54925: #ifndef MOZ_DISABLE_DOMCRYPTO
     1: #include "nsIDOMCrypto.h"
 54925: #endif
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMEvent.h"
 41071: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsIDOMKeyEvent.h"
 10976: #include "nsIDOMMessageEvent.h"
     1: #include "nsIDOMPopupBlockedEvent.h"
 37802: #include "nsIDOMPopStateEvent.h"
 68729: #include "nsIDOMHashChangeEvent.h"
  1938: #include "nsIDOMOfflineResourceList.h"
 16677: #include "nsIDOMGeoGeolocation.h"
 52355: #include "nsIDOMDesktopNotification.h"
 37608: #include "nsPIDOMStorage.h"
     1: #include "nsDOMString.h"
101616: #include "nsIEmbeddingSiteWindow.h"
     1: #include "nsThreadUtils.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsIHttpProtocolHandler.h"
     1: #include "nsIJSContextStack.h"
     1: #include "nsIJSRuntimeService.h"
 99539: #include "nsILoadContext.h"
     1: #include "nsIMarkupDocumentViewer.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIProgrammingLanguage.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIScriptGlobalObjectOwner.h"
     1: #include "nsIScriptSecurityManager.h"
 37063: #include "nsIScrollableFrame.h"
     1: #include "nsIView.h"
     1: #include "nsIViewManager.h"
     1: #include "nsISelectionController.h"
     1: #include "nsISelection.h"
     1: #include "nsIPrompt.h"
 42304: #include "nsIPromptService.h"
 57937: #include "nsIPromptFactory.h"
 57937: #include "nsIWritablePropertyBag2.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIWebBrowser.h"
     1: #include "nsIWebBrowserChrome.h"
     1: #include "nsIWebBrowserFind.h"  // For window.find()
     1: #include "nsIWebContentHandlerRegistrar.h"
     1: #include "nsIWindowMediator.h"  // For window.find()
 30385: #include "nsComputedDOMStyle.h"
     1: #include "nsIEntropyCollector.h"
     1: #include "nsDOMCID.h"
     1: #include "nsDOMWindowUtils.h"
     1: #include "nsIWindowWatcher.h"
     1: #include "nsPIWindowWatcher.h"
     1: #include "nsIContentViewer.h"
     1: #include "nsIJSNativeInitializer.h"
     1: #include "nsIScriptError.h"
     1: #include "nsIConsoleService.h"
  6910: #include "nsIControllers.h"
     1: #include "nsIControllerContext.h"
     1: #include "nsGlobalWindowCommands.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsContentUtils.h"
     1: #include "nsCSSProps.h"
 87152: #include "nsBlobProtocolHandler.h"
 53994: #include "nsIDOMFile.h"
 75350: #include "nsIDOMFileList.h"
     1: #include "nsIURIFixup.h"
 41653: #include "mozilla/FunctionTimer.h"
     1: #include "nsCDefaultURIFixup.h"
     1: #include "nsEventDispatcher.h"
     1: #include "nsIObserverService.h"
  3041: #include "nsIXULAppInfo.h"
     1: #include "nsNetUtil.h"
 29018: #include "nsFocusManager.h"
 47945: #include "nsIXULWindow.h"
 60229: #include "nsEventStateManager.h"
 72986: #include "nsITimedChannel.h"
 74805: #include "nsICookiePermission.h"
 88107: #include "nsServiceManagerUtils.h"
  3799: #ifdef MOZ_XUL
  3129: #include "nsXULPopupManager.h"
 30327: #include "nsIDOMXULControlElement.h"
 71258: #include "nsMenuPopupFrame.h"
  3799: #endif
     1: 
 57556: #include "xpcprivate.h"
     1: 
     1: #ifdef NS_PRINTING
     1: #include "nsIPrintSettings.h"
     1: #include "nsIPrintSettingsService.h"
     1: #include "nsIWebBrowserPrint.h"
     1: #endif
     1: 
     1: #include "nsWindowRoot.h"
     1: #include "nsNetCID.h"
     1: #include "nsIArray.h"
     1: #include "nsIScriptRuntime.h"
     1: 
     1: // XXX An unfortunate dependency exists here (two XUL files).
     1: #include "nsIDOMXULDocument.h"
     1: #include "nsIDOMXULCommandDispatcher.h"
     1: 
     1: #include "nsBindingManager.h"
 99253: #include "nsXBLService.h"
     1: 
     1: // used for popup blocking, needs to be converted to something
     1: // belonging to the back-end like nsIContentPolicy
     1: #include "nsIPopupWindowManager.h"
     1: 
 13279: #include "nsIDragService.h"
 41930: #include "mozilla/dom/Element.h"
 42412: #include "nsFrameLoader.h"
 42340: #include "nsISupportsPrimitives.h"
 42340: #include "nsXPCOMCID.h"
107068: #include "GeneratedEvents.h"
 42480: #include "mozilla/FunctionTimer.h"
 61353: #include "mozIThirdPartyUtil.h"
 42480: 
     1: #ifdef MOZ_LOGGING
     1: // so we can get logging even in release builds
     1: #define FORCE_PR_LOG 1
     1: #endif
     1: #include "prlog.h"
 74872: #include "prenv.h"
     1: 
 46347: #include "mozilla/dom/indexedDB/IDBFactory.h"
 56112: #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
 44204: 
 75350: #include "mozilla/dom/StructuredCloneTags.h"
 75350: 
 50698: #include "nsRefreshDriver.h"
 64121: #include "mozAutoDocUpdate.h"
 50698: 
 72923: #include "mozilla/Telemetry.h"
 74762: #include "nsLocation.h"
 80074: #include "nsWrapperCacheInlines.h"
 92083: #include "nsDOMEventTargetHelper.h"
 98631: #include "nsIAppsService.h"
103224: #include "prrng.h"
108822: #include "nsSandboxFlags.h"
 72923: 
 82109: #ifdef ANDROID
 82109: #include <android/log.h>
 82109: #endif
 82109: 
     1: #ifdef PR_LOGGING
     1: static PRLogModuleInfo* gDOMLeakPRLog;
     1: #endif
     1: 
 55110: static const char kStorageEnabled[] = "dom.storage.enabled";
 55110: 
 70840: using namespace mozilla;
 41634: using namespace mozilla::dom;
 48032: using mozilla::TimeStamp;
 48032: using mozilla::TimeDuration;
 41634: 
106838: nsGlobalWindow::WindowByIdTable *nsGlobalWindow::sWindowsById = nullptr;
 76293: bool nsGlobalWindow::sWarnedAboutWindowInternal = false;
103224: bool nsGlobalWindow::sIdleObserversAPIFuzzTimeDisabled = false;
     1: 
106838: static nsIEntropyCollector *gEntropyCollector          = nullptr;
108991: static int32_t              gRefCnt                    = 0;
108991: static int32_t              gOpenPopupSpamCount        = 0;
     1: static PopupControlState    gPopupControlState         = openAbused;
108991: static int32_t              gRunningTimeoutDepth       = 0;
 79445: static bool                 gMouseDown                 = false;
 79445: static bool                 gDragServiceDisabled       = false;
106838: static FILE                *gDumpFile                  = nullptr;
108991: static uint64_t             gNextWindowID              = 0;
108991: static uint32_t             gSerialCounter             = 0;
108991: static uint32_t             gTimeoutsRecentlySet       = 0;
 88604: static TimeStamp            gLastRecordedRecentTimeouts;
 88604: #define STATISTICS_INTERVAL (30 * PR_MSEC_PER_SEC)
 11785: 
     1: #ifdef DEBUG_jst
108991: int32_t gTimeoutCnt                                    = 0;
     1: #endif
     1: 
102909: #if !(defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
 79445: static bool                 gDOMWindowDumpEnabled      = false;
 21376: #endif
 21376: 
     1: #if defined(DEBUG_bryner) || defined(DEBUG_chb)
     1: #define DEBUG_PAGE_CACHE
     1: #endif
     1: 
 88107: #define DOM_TOUCH_LISTENER_ADDED "dom-touch-listener-added"
 88107: 
 60635: // The default shortest interval/timeout we permit
 64522: #define DEFAULT_MIN_TIMEOUT_VALUE 4 // 4ms
 63938: #define DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE 1000 // 1000ms
108991: static int32_t gMinTimeoutValue;
108991: static int32_t gMinBackgroundTimeoutValue;
108991: inline int32_t
 63938: nsGlobalWindow::DOMMinTimeoutValue() const {
 79445:   bool isBackground = !mOuterWindow || mOuterWindow->IsBackground();
 63938:   return
 63938:     NS_MAX(isBackground ? gMinBackgroundTimeoutValue : gMinTimeoutValue, 0);
 60635: }
     1: 
 34729: // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
 34729: // uses 5.
 34729: #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
 34729: 
     1: // The longest interval (as PRIntervalTime) we permit, or that our
     1: // timer code can handle, really. See DELAY_INTERVAL_LIMIT in
     1: // nsTimerImpl.h for details.
 70324: #define DOM_MAX_TIMEOUT_VALUE    DELAY_INTERVAL_LIMIT
     1: 
     1: #define FORWARD_TO_OUTER(method, args, err_rval)                              \
     1:   PR_BEGIN_MACRO                                                              \
     1:   if (IsInnerWindow()) {                                                      \
 55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
     1:     if (!outer) {                                                             \
     1:       NS_WARNING("No outer window available!");                               \
     1:       return err_rval;                                                        \
     1:     }                                                                         \
     1:     return outer->method args;                                                \
     1:   }                                                                           \
     1:   PR_END_MACRO
     1: 
     1: #define FORWARD_TO_OUTER_VOID(method, args)                                   \
     1:   PR_BEGIN_MACRO                                                              \
     1:   if (IsInnerWindow()) {                                                      \
 55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
     1:     if (!outer) {                                                             \
     1:       NS_WARNING("No outer window available!");                               \
     1:       return;                                                                 \
     1:     }                                                                         \
     1:     outer->method args;                                                       \
     1:     return;                                                                   \
     1:   }                                                                           \
     1:   PR_END_MACRO
     1: 
     1: #define FORWARD_TO_OUTER_CHROME(method, args, err_rval)                       \
     1:   PR_BEGIN_MACRO                                                              \
     1:   if (IsInnerWindow()) {                                                      \
 55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
     1:     if (!outer) {                                                             \
     1:       NS_WARNING("No outer window available!");                               \
     1:       return err_rval;                                                        \
     1:     }                                                                         \
 55729:     return ((nsGlobalChromeWindow *)outer)->method args;                      \
     1:   }                                                                           \
     1:   PR_END_MACRO
     1: 
 42412: #define FORWARD_TO_INNER_CHROME(method, args, err_rval)                       \
 42412:   PR_BEGIN_MACRO                                                              \
 42412:   if (IsOuterWindow()) {                                                      \
 42412:     if (!mInnerWindow) {                                                      \
 42412:       NS_WARNING("No inner window available!");                               \
 42412:       return err_rval;                                                        \
 42412:     }                                                                         \
 42412:     return ((nsGlobalChromeWindow *)mInnerWindow)->method args;               \
 42412:   }                                                                           \
 42412:   PR_END_MACRO
 42412: 
  4040: #define FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(method, args, err_rval)         \
  4040:   PR_BEGIN_MACRO                                                              \
  4040:   if (IsInnerWindow()) {                                                      \
 55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
  4040:     if (!outer) {                                                             \
  4040:       NS_WARNING("No outer window available!");                               \
  4040:       return err_rval;                                                        \
  4040:     }                                                                         \
 55729:     return ((nsGlobalModalWindow *)outer)->method args;                       \
  4040:   }                                                                           \
  4040:   PR_END_MACRO
  4040: 
     1: #define FORWARD_TO_INNER(method, args, err_rval)                              \
     1:   PR_BEGIN_MACRO                                                              \
     1:   if (IsOuterWindow()) {                                                      \
     1:     if (!mInnerWindow) {                                                      \
     1:       NS_WARNING("No inner window available!");                               \
     1:       return err_rval;                                                        \
     1:     }                                                                         \
     1:     return GetCurrentInnerWindowInternal()->method args;                      \
     1:   }                                                                           \
     1:   PR_END_MACRO
     1: 
  4040: #define FORWARD_TO_INNER_MODAL_CONTENT_WINDOW(method, args, err_rval)         \
  4040:   PR_BEGIN_MACRO                                                              \
  4040:   if (IsOuterWindow()) {                                                      \
  4040:     if (!mInnerWindow) {                                                      \
  4040:       NS_WARNING("No inner window available!");                               \
  4040:       return err_rval;                                                        \
  4040:     }                                                                         \
  4040:     return ((nsGlobalModalWindow*)GetCurrentInnerWindowInternal())->method args; \
  4040:   }                                                                           \
  4040:   PR_END_MACRO
  4040: 
     1: #define FORWARD_TO_INNER_VOID(method, args)                                   \
     1:   PR_BEGIN_MACRO                                                              \
     1:   if (IsOuterWindow()) {                                                      \
     1:     if (!mInnerWindow) {                                                      \
     1:       NS_WARNING("No inner window available!");                               \
     1:       return;                                                                 \
     1:     }                                                                         \
     1:     GetCurrentInnerWindowInternal()->method args;                             \
     1:     return;                                                                   \
     1:   }                                                                           \
     1:   PR_END_MACRO
     1: 
     1: // Same as FORWARD_TO_INNER, but this will create a fresh inner if an
     1: // inner doesn't already exists.
 29474: #define FORWARD_TO_INNER_CREATE(method, args, err_rval)                       \
     1:   PR_BEGIN_MACRO                                                              \
     1:   if (IsOuterWindow()) {                                                      \
     1:     if (!mInnerWindow) {                                                      \
     1:       if (mIsClosed) {                                                        \
 29474:         return err_rval;                                                      \
     1:       }                                                                       \
     1:       nsCOMPtr<nsIDOMDocument> doc;                                           \
     1:       nsresult fwdic_nr = GetDocument(getter_AddRefs(doc));                   \
 29474:       NS_ENSURE_SUCCESS(fwdic_nr, err_rval);                                  \
     1:       if (!mInnerWindow) {                                                    \
 29474:         return err_rval;                                                      \
     1:       }                                                                       \
     1:     }                                                                         \
     1:     return GetCurrentInnerWindowInternal()->method args;                      \
     1:   }                                                                           \
     1:   PR_END_MACRO
     1: 
     1: // CIDs
     1: static NS_DEFINE_CID(kXULControllersCID, NS_XULCONTROLLERS_CID);
     1: 
     1: static const char sJSStackContractID[] = "@mozilla.org/js/xpc/ContextStack;1";
 54925: #ifndef MOZ_DISABLE_DOMCRYPTO
     1: static const char kCryptoContractID[] = NS_CRYPTO_CONTRACTID;
     1: static const char kPkcs11ContractID[] = NS_PKCS11_CONTRACTID;
 54925: #endif
 37802: static const char sPopStatePrefStr[] = "browser.history.allowPopState";
 37802: 
     1: /**
 58023:  * An object implementing the window.URL property.
 58023:  */
102221: class nsDOMMozURLProperty MOZ_FINAL : public nsIDOMMozURLProperty
 58023: {
 58023: public:
 58023:   nsDOMMozURLProperty(nsGlobalWindow* aWindow)
 58023:     : mWindow(aWindow)
 58023:   {
 58023:   }
 58023: 
 58023:   NS_DECL_ISUPPORTS
 58023:   NS_DECL_NSIDOMMOZURLPROPERTY
 58023: 
 58023:   void ClearWindowReference() {
106838:     mWindow = nullptr;
 58023:   }
 58023: private:
 58023:   nsGlobalWindow* mWindow;
 58023: };
 58023: 
 58023: DOMCI_DATA(MozURLProperty, nsDOMMozURLProperty)
 58023: NS_IMPL_ADDREF(nsDOMMozURLProperty)
 58023: NS_IMPL_RELEASE(nsDOMMozURLProperty)
 58023: NS_INTERFACE_MAP_BEGIN(nsDOMMozURLProperty)
 58023:     NS_INTERFACE_MAP_ENTRY(nsIDOMMozURLProperty)
 58023:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMMozURLProperty)
 58023:     NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozURLProperty)
 58023: NS_INTERFACE_MAP_END
 58023: 
 58023: NS_IMETHODIMP
 58023: nsDOMMozURLProperty::CreateObjectURL(nsIDOMBlob* aBlob, nsAString& aURL)
 58023: {
 58023:   NS_PRECONDITION(!mWindow || mWindow->IsInnerWindow(),
 58023:                   "Should be inner window");
 58023: 
 58023:   NS_ENSURE_STATE(mWindow && mWindow->mDoc);
 58023:   NS_ENSURE_ARG_POINTER(aBlob);
 58023: 
 58023:   nsIDocument* doc = mWindow->mDoc;
 58023: 
 58023:   nsresult rv = aBlob->GetInternalUrl(doc->NodePrincipal(), aURL);
 58023:   NS_ENSURE_SUCCESS(rv, rv);
 58023: 
 58023:   doc->RegisterFileDataUri(NS_LossyConvertUTF16toASCII(aURL));
 58023: 
 58023:   return NS_OK;
 58023: }
 58023: 
 58023: NS_IMETHODIMP
 58023: nsDOMMozURLProperty::RevokeObjectURL(const nsAString& aURL)
 58023: {
 58023:   NS_PRECONDITION(!mWindow || mWindow->IsInnerWindow(),
 58023:                   "Should be inner window");
 58023: 
 58023:   NS_ENSURE_STATE(mWindow);
 58023: 
 58023:   NS_LossyConvertUTF16toASCII asciiurl(aURL);
 58023: 
 58023:   nsIPrincipal* winPrincipal = mWindow->GetPrincipal();
 58023:   if (!winPrincipal) {
 58023:     return NS_OK;
 58023:   }
 58023: 
 58023:   nsIPrincipal* principal =
 87152:     nsBlobProtocolHandler::GetFileDataEntryPrincipal(asciiurl);
 79445:   bool subsumes;
 58023:   if (principal && winPrincipal &&
 58023:       NS_SUCCEEDED(winPrincipal->Subsumes(principal, &subsumes)) &&
 58023:       subsumes) {
 58023:     if (mWindow->mDoc) {
 58023:       mWindow->mDoc->UnregisterFileDataUri(asciiurl);
 58023:     }
 87152:     nsBlobProtocolHandler::RemoveFileDataEntry(asciiurl);
 58023:   }
 58023: 
 58023:   return NS_OK;
 58023: }
 58023: 
 58023: /**
     1:  * An indirect observer object that means we don't have to implement nsIObserver
     1:  * on nsGlobalWindow, where any script could see it.
     1:  */
103224: class nsGlobalWindowObserver MOZ_FINAL : public nsIObserver,
103224:                                          public nsIInterfaceRequestor
103224: {
     1: public:
     1:   nsGlobalWindowObserver(nsGlobalWindow* aWindow) : mWindow(aWindow) {}
     1:   NS_DECL_ISUPPORTS
     1:   NS_IMETHOD Observe(nsISupports* aSubject, const char* aTopic, const PRUnichar* aData)
     1:   {
     1:     if (!mWindow)
     1:       return NS_OK;
     1:     return mWindow->Observe(aSubject, aTopic, aData);
     1:   }
106838:   void Forget() { mWindow = nullptr; }
103224:   NS_IMETHODIMP GetInterface(const nsIID& aIID, void** aResult)
103224:   {
103224:     if (mWindow && aIID.Equals(NS_GET_IID(nsIDOMWindow)) && mWindow) {
103224:       return mWindow->QueryInterface(aIID, aResult);
103224:     }
103224:     return NS_NOINTERFACE;
103224:   }
103224: 
     1: private:
     1:   nsGlobalWindow* mWindow;
     1: };
     1: 
103224: NS_IMPL_ISUPPORTS2(nsGlobalWindowObserver, nsIObserver, nsIInterfaceRequestor)
     1: 
     1: nsTimeout::nsTimeout()
     1: {
     1: #ifdef DEBUG_jst
     1:   {
     1:     extern int gTimeoutCnt;
     1: 
     1:     ++gTimeoutCnt;
     1:   }
     1: #endif
     1: 
     1:   memset(this, 0, sizeof(*this));
     1: 
     1:   MOZ_COUNT_CTOR(nsTimeout);
     1: }
     1: 
     1: nsTimeout::~nsTimeout()
     1: {
     1: #ifdef DEBUG_jst
     1:   {
     1:     extern int gTimeoutCnt;
     1: 
     1:     --gTimeoutCnt;
     1:   }
     1: #endif
     1: 
     1:   MOZ_COUNT_DTOR(nsTimeout);
     1: }
     1: 
109311: NS_IMPL_CYCLE_COLLECTION_LEGACY_NATIVE_CLASS(nsTimeout)
 24195: NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_0(nsTimeout)
 24195: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsTimeout)
 24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mWindow,
 24195:                                                        nsIScriptGlobalObject)
 24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrincipal)
 24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptHandler)
 24195: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 24195: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsTimeout, AddRef)
 24195: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsTimeout, Release)
 24195: 
 41409: nsPIDOMWindow::nsPIDOMWindow(nsPIDOMWindow *aOuterWindow)
106838: : mFrameElement(nullptr), mDocShell(nullptr), mModalStateDepth(0),
106838:   mRunningTimeout(nullptr), mMutationBits(0), mIsDocumentLoaded(false),
106838:   mIsHandlingResizeEvent(false), mIsInnerWindow(aOuterWindow != nullptr),
 80486:   mMayHavePaintEventListener(false), mMayHaveTouchEventListener(false),
 80486:   mMayHaveMouseEnterLeaveEventListener(false),
 80486:   mIsModalContentWindow(false),
 80486:   mIsActive(false), mIsBackground(false),
106838:   mInnerWindow(nullptr), mOuterWindow(aOuterWindow),
 56273:   // Make sure no actual window ends up with mWindowID == 0
 80486:   mWindowID(++gNextWindowID), mHasNotifiedGlobalCreated(false)
 56273:  {}
 41409: 
 41409: nsPIDOMWindow::~nsPIDOMWindow() {}
     1: 
     1: //*****************************************************************************
 55577: // nsOuterWindowProxy: Outer Window Proxy
 55577: //*****************************************************************************
 55577: 
100027: class nsOuterWindowProxy : public js::DirectWrapper
 93876: {
 93876: public:
100027:   nsOuterWindowProxy() : js::DirectWrapper(0) {}
 93876: 
 93876:   virtual bool isOuterWindow() {
 93876:     return true;
 93876:   }
 93876:   JSString *obj_toString(JSContext *cx, JSObject *wrapper);
 94738:   void finalize(JSFreeOp *fop, JSObject *proxy);
 93876: 
 93876:   static nsOuterWindowProxy singleton;
 93876: };
 93876: 
 93876: 
 55577: JSString *
 55577: nsOuterWindowProxy::obj_toString(JSContext *cx, JSObject *proxy)
 55577: {
 79734:     JS_ASSERT(js::IsProxy(proxy));
 55577: 
 55671:     return JS_NewStringCopyZ(cx, "[object Window]");
 55577: }
 55577: 
 80415: void
 94738: nsOuterWindowProxy::finalize(JSFreeOp *fop, JSObject *proxy)
 80415: {
 80415:   nsISupports *global =
 80415:     static_cast<nsISupports*>(js::GetProxyExtra(proxy, 0).toPrivate());
 80415:   if (global) {
 80415:     nsWrapperCache *cache;
 80415:     CallQueryInterface(global, &cache);
 93345:     cache->ClearWrapper();
 80415:   }
 80415: }
 80415: 
 55577: nsOuterWindowProxy
 55577: nsOuterWindowProxy::singleton;
 55577: 
 93876: static JSObject*
 93876: NewOuterWindowProxy(JSContext *cx, JSObject *parent)
 55577: {
109257:   JSAutoCompartment ac(cx, parent);
 79734:   JSObject *obj = js::Wrapper::New(cx, parent, js::GetObjectProto(parent), parent,
 55577:                                    &nsOuterWindowProxy::singleton);
 79734:   NS_ASSERTION(js::GetObjectClass(obj)->ext.innerObject, "bad class");
 55577:   return obj;
 55577: }
 55577: 
 55577: //*****************************************************************************
     1: //***    nsGlobalWindow: Object Management
     1: //*****************************************************************************
     1: 
     1: nsGlobalWindow::nsGlobalWindow(nsGlobalWindow *aOuterWindow)
     1:   : nsPIDOMWindow(aOuterWindow),
103224:     mIdleFuzzFactor(0),
103224:     mIdleCallbackIndex(-1),
103224:     mCurrentlyIdle(false),
103224:     mAddActiveEventFuzzTime(true),
 80486:     mIsFrozen(false),
 80486:     mFullScreen(false),
 80486:     mIsClosed(false),
 80486:     mInClose(false),
 80486:     mHavePendingClose(false),
 80486:     mHadOriginalOpener(false),
 80486:     mIsPopupSpam(false),
 80486:     mBlockScriptedClosingFlag(false),
 80486:     mFireOfflineStatusChangeEventOnThaw(false),
103224:     mNotifyIdleObserversIdleOnThaw(false),
103224:     mNotifyIdleObserversActiveOnThaw(false),
 80486:     mCreatingInnerWindow(false),
 80486:     mIsChrome(false),
 80486:     mCleanMessageManager(false),
 80486:     mNeedsFocus(true),
 80486:     mHasFocus(false),
 69620: #if defined(XP_MACOSX)
 80486:     mShowAccelerators(false),
 80486:     mShowFocusRings(false),
 41071: #else
 80486:     mShowAccelerators(true),
 80486:     mShowFocusRings(true),
 41071: #endif
 80486:     mShowFocusRingForContent(false),
 80486:     mFocusByKeyOccurred(false),
 80486:     mNotifiedIDDestroyed(false),
106838:     mTimeoutInsertionPoint(nullptr),
     1:     mTimeoutPublicIdCounter(1),
     1:     mTimeoutFiringDepth(0),
106838:     mJSObject(nullptr),
 29018:     mTimeoutsSuspendDepth(0),
 52336:     mFocusMethod(0),
 54231:     mSerial(0),
     1: #ifdef DEBUG
 80486:     mSetOpenerWindowCalled(false),
     1: #endif
 80486:     mCleanedUp(false),
 80486:     mCallCleanUpAfterModalDialogCloses(false),
 54231:     mDialogAbuseCount(0),
108233:     mStopAbuseDialogs(false),
108233:     mDialogsPermanentlyDisabled(false)
     1: {
     1:   nsLayoutStatics::AddRef();
     1: 
     1:   // Initialize the PRCList (this).
     1:   PR_INIT_CLIST(this);
     1: 
     1:   // Initialize timeout storage
     1:   PR_INIT_CLIST(&mTimeouts);
     1: 
     1:   if (aOuterWindow) {
     1:     // |this| is an inner window, add this inner window to the outer
     1:     // window list of inners.
     1:     PR_INSERT_AFTER(this, aOuterWindow);
     1: 
     1:     mObserver = new nsGlobalWindowObserver(this);
     1:     if (mObserver) {
     1:       NS_ADDREF(mObserver);
 41540:       nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
     1:       if (os) {
     1:         // Watch for online/offline status changes so we can fire events. Use
     1:         // a strong reference.
     1:         os->AddObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC,
 80486:                         false);
     1: 
 95449:         // Watch for dom-storage2-changed so we can fire storage
     1:         // events. Use a strong reference.
 80486:         os->AddObserver(mObserver, "dom-storage2-changed", false);
     1:       }
     1:     }
     1:   } else {
     1:     // |this| is an outer window. Outer windows start out frozen and
     1:     // remain frozen until they get an inner window, so freeze this
     1:     // outer window here.
     1:     Freeze();
     1: 
106838:     mObserver = nullptr;
 93879:     SetIsDOMBinding();
     1:   }
     1: 
     1:   // We could have failed the first time through trying
     1:   // to create the entropy collector, so we should
     1:   // try to get one until we succeed.
 21376: 
 21376:   gRefCnt++;
 21376: 
 60635:   if (gRefCnt == 1) {
102909: #if !(defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
 71001:     Preferences::AddBoolVarCache(&gDOMWindowDumpEnabled,
 71001:                                  "browser.dom.window.dump.enabled");
 21376: #endif
 71001:     Preferences::AddIntVarCache(&gMinTimeoutValue,
 71001:                                 "dom.min_timeout_value",
 60635:                                 DEFAULT_MIN_TIMEOUT_VALUE);
 71001:     Preferences::AddIntVarCache(&gMinBackgroundTimeoutValue,
 71001:                                 "dom.min_background_timeout_value",
 63938:                                 DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE);
103224:     Preferences::AddBoolVarCache(&sIdleObserversAPIFuzzTimeDisabled, 
103224:                                  "dom.idle-observers-api.fuzz_time.disabled",
103224:                                  false);
 60635:   }
 21376: 
106838:   if (gDumpFile == nullptr) {
 27826:     const nsAdoptingCString& fname =
 70976:       Preferences::GetCString("browser.dom.window.dump.file");
 27826:     if (!fname.IsEmpty()) {
 27826:       // if this fails to open, Dump() knows to just go to stdout
 27826:       // on null.
 27826:       gDumpFile = fopen(fname, "wb+");
 27826:     } else {
 27826:       gDumpFile = stdout;
 27826:     }
 27826:   }
 27826: 
 52336:   mSerial = ++gSerialCounter;
 52336: 
     1: #ifdef DEBUG
 74872:   if (!PR_GetEnv("MOZ_QUIET")) {
 14743:     printf("++DOMWINDOW == %d (%p) [serial = %d] [outer = %p]\n", gRefCnt,
 12416:            static_cast<void*>(static_cast<nsIScriptGlobalObject*>(this)),
 52336:            gSerialCounter, static_cast<void*>(aOuterWindow));
 74872:   }
     1: #endif
     1: 
     1: #ifdef PR_LOGGING
     1:   if (gDOMLeakPRLog)
     1:     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
     1:            ("DOMWINDOW %p created outer=%p", this, aOuterWindow));
     1: #endif
 72691: 
 77579:   NS_ASSERTION(sWindowsById, "Windows hash table must be created!");
 72691:   NS_ASSERTION(!sWindowsById->Get(mWindowID),
 72691:                "This window shouldn't be in the hash table yet!");
 72691:   sWindowsById->Put(mWindowID, this);
 92083: 
 92083:   mEventTargetObjects.Init();
 72691: }
 77579: 
 77579: /* static */
 77579: void
 77579: nsGlobalWindow::Init()
 77579: {
 77579:   CallGetService(NS_ENTROPYCOLLECTOR_CONTRACTID, &gEntropyCollector);
 77579:   NS_ASSERTION(gEntropyCollector,
 77579:                "gEntropyCollector should have been initialized!");
 77579: 
 77579: #ifdef PR_LOGGING
 77579:   gDOMLeakPRLog = PR_NewLogModule("DOMLeak");
 77579:   NS_ASSERTION(gDOMLeakPRLog, "gDOMLeakPRLog should have been initialized!");
 77579: #endif
 77579: 
 77579:   sWindowsById = new WindowByIdTable();
 77579:   sWindowsById->Init();
     1: }
     1: 
 92083: static PLDHashOperator
 92083: DisconnectEventTargetObjects(nsPtrHashKey<nsDOMEventTargetHelper>* aKey,
 92083:                              void* aClosure)
 92083: {
 92084:   nsRefPtr<nsDOMEventTargetHelper> target = aKey->GetKey();
 92084:   target->DisconnectFromOwner();
 92083:   return PL_DHASH_NEXT;
 92083: }
 92083: 
     1: nsGlobalWindow::~nsGlobalWindow()
     1: {
106838:   mEventTargetObjects.EnumerateEntries(DisconnectEventTargetObjects, nullptr);
 92083:   mEventTargetObjects.Clear();
 92083: 
 72691:   // We have to check if sWindowsById isn't null because ::Shutdown might have
 72691:   // been called.
 72691:   if (sWindowsById) {
 72691:     NS_ASSERTION(sWindowsById->Get(mWindowID),
 72691:                  "This window should be in the hash table");
 72691:     sWindowsById->Remove(mWindowID);
 56274:   }
 77579: 
 77699:   --gRefCnt;
 77699: 
     1: #ifdef DEBUG
 74872:   if (!PR_GetEnv("MOZ_QUIET")) {
110974:     nsAutoCString url;
 14743:     if (mLastOpenedURI) {
 14743:       mLastOpenedURI->GetSpec(url);
 14743:     }
 14743: 
 14743:     printf("--DOMWINDOW == %d (%p) [serial = %d] [outer = %p] [url = %s]\n",
 12416:            gRefCnt, static_cast<void*>(static_cast<nsIScriptGlobalObject*>(this)),
 55729:            mSerial, static_cast<void*>(mOuterWindow.get()), url.get());
 74872:   }
     1: #endif
     1: 
     1: #ifdef PR_LOGGING
     1:   if (gDOMLeakPRLog)
     1:     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
     1:            ("DOMWINDOW %p destroyed", this));
     1: #endif
     1: 
     1:   if (IsOuterWindow()) {
 80415:     JSObject *proxy = GetWrapperPreserveColor();
 80415:     if (proxy) {
 80415:       js::SetProxyExtra(proxy, 0, js::PrivateValue(NULL));
 80415:     }
 80415: 
     1:     // An outer window is destroyed with inner windows still possibly
 38439:     // alive, iterate through the inner windows and null out their
 38439:     // back pointer to this outer, and pull them out of the list of
 38439:     // inner windows.
     1: 
     1:     nsGlobalWindow *w;
     1:     while ((w = (nsGlobalWindow *)PR_LIST_HEAD(this)) != this) {
     1:       PR_REMOVE_AND_INIT_LINK(w);
     1:     }
     1:   } else {
 80393:     Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
 80393:                           mMutationBits ? 1 : 0);
 80393: 
     1:     if (mListenerManager) {
     1:       mListenerManager->Disconnect();
106838:       mListenerManager = nullptr;
     1:     }
     1: 
     1:     // An inner window is destroyed, pull it out of the outer window's
     1:     // list if inner windows.
     1: 
     1:     PR_REMOVE_LINK(this);
     1: 
     1:     // If our outer window's inner window is this window, null out the
     1:     // outer window's reference to this window that's being deleted.
     1:     nsGlobalWindow *outer = GetOuterWindowInternal();
 98106:     if (outer) {
 98106:       outer->MaybeClearInnerWindow(this);
     1:     }
     1:   }
     1: 
106838:   mDocument = nullptr;           // Forces Release
106838:   mDoc = nullptr;
     1: 
     1:   NS_ASSERTION(!mArguments, "mArguments wasn't cleaned up properly!");
 38439: 
 80486:   CleanUp(true);
 38439: 
 38439: #ifdef DEBUG
 38439:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIScriptGlobalObject*>(this));
 38439: #endif
 38439: 
 58023:   if (mURLProperty) {
 58023:     mURLProperty->ClearWindowReference();
 58023:   }
 58023: 
 94011:   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
 94010:   if (ac)
 94010:     ac->RemoveWindowAsListener(this);
 76835: 
 38439:   nsLayoutStatics::Release();
 38439: }
 38439: 
 92083: void
 92083: nsGlobalWindow::AddEventTargetObject(nsDOMEventTargetHelper* aObject)
 92083: {
 92083:   mEventTargetObjects.PutEntry(aObject);
 92083: }
 92083: 
 92083: void
 92083: nsGlobalWindow::RemoveEventTargetObject(nsDOMEventTargetHelper* aObject)
 92083: {
 92083:   mEventTargetObjects.RemoveEntry(aObject);
 92083: }
 92083: 
 38439: // static
 38439: void
 38439: nsGlobalWindow::ShutDown()
 38439: {
 38439:   if (gDumpFile && gDumpFile != stdout) {
 38439:     fclose(gDumpFile);
 38439:   }
106838:   gDumpFile = nullptr;
 72691: 
 77579:   NS_IF_RELEASE(gEntropyCollector);
 77579: 
 72691:   delete sWindowsById;
106838:   sWindowsById = nullptr;
 38439: }
 38439: 
 38439: // static
 38439: void
 38439: nsGlobalWindow::CleanupCachedXBLHandlers(nsGlobalWindow* aWindow)
 38439: {
 38439:   if (aWindow->mCachedXBLPrototypeHandlers.IsInitialized() &&
 38439:       aWindow->mCachedXBLPrototypeHandlers.Count() > 0) {
 38439:     aWindow->mCachedXBLPrototypeHandlers.Clear();
 38439: 
 57794:     nsISupports* supports;
 38439:     aWindow->QueryInterface(NS_GET_IID(nsCycleCollectionISupports),
 57794:                             reinterpret_cast<void**>(&supports));
 38439:     NS_ASSERTION(supports, "Failed to QI to nsCycleCollectionISupports?!");
 38439: 
 38439:     nsContentUtils::DropJSObjects(supports);
 38439:   }
 38439: }
 38439: 
 38439: void
 39378: nsGlobalWindow::MaybeForgiveSpamCount()
 39378: {
 39378:   if (IsOuterWindow() &&
 39378:       IsPopupSpamWindow())
 39378:   {
 80486:     SetPopupSpamWindow(false);
 39378:     --gOpenPopupSpamCount;
 39378:     NS_ASSERTION(gOpenPopupSpamCount >= 0,
 39378:                  "Unbalanced decrement of gOpenPopupSpamCount");
 39378:   }
 39378: }
 39378: 
 39378: void
 79445: nsGlobalWindow::CleanUp(bool aIgnoreModalDialog)
 39378: {
 39378:   if (IsOuterWindow() && !aIgnoreModalDialog) {
 39378:     nsGlobalWindow* inner = GetCurrentInnerWindowInternal();
 77547:     nsCOMPtr<nsIDOMModalContentWindow> dlg(do_QueryObject(inner));
 39378:     if (dlg) {
 39378:       // The window we're trying to clean up is the outer window of a
 39378:       // modal dialog.  Defer cleanup until the window closes, and let
 39378:       // ShowModalDialog take care of calling CleanUp.
 80486:       mCallCleanUpAfterModalDialogCloses = true;
 39378:       return;
 39378:     }
 39378:   }
 39378: 
 39378:   // Guarantee idempotence.
 39378:   if (mCleanedUp)
 39378:     return;
 80486:   mCleanedUp = true;
 39378: 
106838:   mEventTargetObjects.EnumerateEntries(DisconnectEventTargetObjects, nullptr);
 92083:   mEventTargetObjects.Clear();
 92083: 
 61999:   if (mObserver) {
 61999:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
 61999:     if (os) {
 61999:       os->RemoveObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC);
 61999:       os->RemoveObserver(mObserver, "dom-storage2-changed");
 61999:     }
 61999: 
103224:     if (mIdleService) {
103224:       mIdleService->RemoveIdleObserver(mObserver, MIN_IDLE_NOTIFICATION_TIME_S);
103224:     }
103224: 
 61999:     // Drop its reference to this dying window, in case for some bogus reason
 61999:     // the object stays around.
 61999:     mObserver->Forget();
 61999:     NS_RELEASE(mObserver);
 61999:   }
 61999: 
106838:   mNavigator = nullptr;
106838:   mScreen = nullptr;
106838:   mMenubar = nullptr;
106838:   mToolbar = nullptr;
106838:   mLocationbar = nullptr;
106838:   mPersonalbar = nullptr;
106838:   mStatusbar = nullptr;
106838:   mScrollbars = nullptr;
106838:   mLocation = nullptr;
106838:   mHistory = nullptr;
106838:   mFrames = nullptr;
106838:   mWindowUtils = nullptr;
106838:   mApplicationCache = nullptr;
106838:   mIndexedDB = nullptr;
106838: 
106838:   mPerformance = nullptr;
     1: 
     1:   ClearControllers();
     1: 
106838:   mOpener = nullptr;             // Forces Release
     1:   if (mContext) {
  6016: #ifdef DEBUG
  6016:     nsCycleCollector_DEBUG_shouldBeFreed(mContext);
  6016: #endif
106838:     mContext = nullptr;            // Forces Release
106838:   }
106838:   mChromeEventHandler = nullptr; // Forces Release
106838:   mParentTarget = nullptr;
     1: 
     1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
     1: 
     1:   if (inner) {
 39378:     inner->CleanUp(aIgnoreModalDialog);
     1:   }
     1: 
 61147:   if (mCleanMessageManager) {
 61147:     NS_ABORT_IF_FALSE(mIsChrome, "only chrome should have msg manager cleaned");
 61147:     nsGlobalChromeWindow *asChrome = static_cast<nsGlobalChromeWindow*>(this);
 61147:     if (asChrome->mMessageManager) {
 43461:       static_cast<nsFrameMessageManager*>(
 61147:         asChrome->mMessageManager.get())->Disconnect();
 61147:     }
 43461:   }
 43461: 
106838:   mInnerWindowHolder = nullptr;
106838:   mArguments = nullptr;
106838:   mArgumentsLast = nullptr;
106838:   mArgumentsOrigin = nullptr;
     1: 
 11622:   CleanupCachedXBLHandlers(this);
 11622: 
103224:   if (mIdleTimer) {
103224:     mIdleTimer->Cancel();
106838:     mIdleTimer = nullptr;
103224:   }
103224: 
     1: #ifdef DEBUG
  3233:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
     1: #endif
     1: }
     1: 
     1: void
     1: nsGlobalWindow::ClearControllers()
     1: {
     1:   if (mControllers) {
108991:     uint32_t count;
     1:     mControllers->GetControllerCount(&count);
     1: 
     1:     while (count--) {
     1:       nsCOMPtr<nsIController> controller;
     1:       mControllers->GetControllerAt(count, getter_AddRefs(controller));
     1: 
     1:       nsCOMPtr<nsIControllerContext> context = do_QueryInterface(controller);
     1:       if (context)
106838:         context->SetCommandContext(nullptr);
106838:     }
106838: 
106838:     mControllers = nullptr;
     1:   }
     1: }
     1: 
     1: void
 91214: nsGlobalWindow::FreeInnerObjects()
 35152: {
 35152:   NS_ASSERTION(IsInnerWindow(), "Don't free inner objects on an outer window");
 35152: 
 83058:   // Make sure that this is called before we null out the document and
 83058:   // other members that the window destroyed observers could
 83058:   // re-create.
 83058:   NotifyDOMWindowDestroyed(this);
 83058: 
 35152:   // Kill all of the workers for this window.
 35152:   nsIScriptContext *scx = GetContextInternal();
106838:   JSContext *cx = scx ? scx->GetNativeContext() : nullptr;
 74337:   mozilla::dom::workers::CancelWorkersForWindow(cx, this);
 35152: 
 56112:   // Close all IndexedDB databases for this window.
 56112:   indexedDB::IndexedDatabaseManager* idbManager =
 56112:     indexedDB::IndexedDatabaseManager::Get();
 56112:   if (idbManager) {
 61407:     idbManager->AbortCloseDatabasesForWindow(this);
 56112:   }
 56112: 
 35152:   ClearAllTimeouts();
 35152: 
103224:   if (mIdleTimer) {
103224:     mIdleTimer->Cancel();
106838:     mIdleTimer = nullptr;
103224:   }
103224: 
103224:   mIdleObservers.Clear();
103224: 
106838:   mChromeEventHandler = nullptr;
 35152: 
 35152:   if (mListenerManager) {
 35152:     mListenerManager->Disconnect();
106838:     mListenerManager = nullptr;
106838:   }
106838: 
106838:   mLocation = nullptr;
106838:   mHistory = nullptr;
 50477: 
 83058:   if (mNavigator) {
100179:     mNavigator->OnNavigation();
 83058:     mNavigator->Invalidate();
106838:     mNavigator = nullptr;
 83058:   }
 83058: 
 93484:   if (mScreen) {
102664:     mScreen->Reset();
106838:     mScreen = nullptr;
 93484:   }
 93484: 
 35152:   if (mDocument) {
 35152:     NS_ASSERTION(mDoc, "Why is mDoc null?");
 35152: 
 35152:     // Remember the document's principal.
 35152:     mDocumentPrincipal = mDoc->NodePrincipal();
 35152:   }
 35152: 
 35152: #ifdef DEBUG
 35152:   if (mDocument)
 35152:     nsCycleCollector_DEBUG_shouldBeFreed(nsCOMPtr<nsISupports>(do_QueryInterface(mDocument)));
 35152: #endif
 35152: 
 35152:   // Remove our reference to the document and the document principal.
106838:   mDocument = nullptr;
106838:   mDoc = nullptr;
106838:   mFocusedNode = nullptr;
 35152: 
 35152:   if (mApplicationCache) {
 35152:     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->Disconnect();
106838:     mApplicationCache = nullptr;
106838:   }
106838: 
106838:   mIndexedDB = nullptr;
 44204: 
 91214:   NotifyWindowIDDestroyed("inner-window-destroyed");
 35152: 
 11622:   CleanupCachedXBLHandlers(this);
 11622: 
     1: #ifdef DEBUG
  3233:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
     1: #endif
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsISupports
     1: //*****************************************************************************
     1: 
 55577: #define OUTER_WINDOW_ONLY                                                     \
 55577:   if (IsOuterWindow()) {
 55577: 
 55577: #define END_OUTER_WINDOW_ONLY                                                 \
 55577:     foundInterface = 0;                                                       \
 55577:   } else
 55577: 
     1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalWindow)
     1: 
 40490: DOMCI_DATA(Window, nsGlobalWindow)
 40490: 
 12033: // QueryInterface implementation for nsGlobalWindow
 12033: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGlobalWindow)
 12033:   // Make sure this matches the cast in nsGlobalWindow::FromWrapper()
 12033:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptGlobalObject)
 12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindow)
 12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMJSWindow)
 76293:   if (aIID.Equals(NS_GET_IID(nsIDOMWindowInternal))) {
 76293:     foundInterface = static_cast<nsIDOMWindowInternal*>(this);
 76293:     if (!sWarnedAboutWindowInternal) {
 76293:       sWarnedAboutWindowInternal = true;
 84636:       nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                       "Extensions", mDoc,
 84636:                                       nsContentUtils::eDOM_PROPERTIES,
 84636:                                       "nsIDOMWindowInternalWarning");
 76293:     }
 76293:   } else
 12033:   NS_INTERFACE_MAP_ENTRY(nsIScriptGlobalObject)
 12033:   NS_INTERFACE_MAP_ENTRY(nsIScriptObjectPrincipal)
 12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
 12033:   NS_INTERFACE_MAP_ENTRY(nsPIDOMWindow)
 60385:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageIndexedDB)
 12033:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 12033:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
 72298:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindowPerformance)
 77146:   NS_INTERFACE_MAP_ENTRY(nsITouchEventReceiver)
 77149:   NS_INTERFACE_MAP_ENTRY(nsIInlineEventHandlers)
 55578:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Window)
 55577:   OUTER_WINDOW_ONLY
 55577:     NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 55577:   END_OUTER_WINDOW_ONLY
 12033: NS_INTERFACE_MAP_END
 12033: 
 12033: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGlobalWindow)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsGlobalWindow)
     1: 
 88265: static PLDHashOperator
 93686: MarkXBLHandlers(nsXBLPrototypeHandler* aKey, JSObject* aData, void* aClosure)
 88265: {
 88265:   xpc_UnmarkGrayObject(aData);
 88265:   return PL_DHASH_NEXT;
 88265: }
 88265: 
 88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsGlobalWindow)
 88265:   if (tmp->IsBlackForCC()) {
 88265:     if (tmp->mCachedXBLPrototypeHandlers.IsInitialized()) {
106838:       tmp->mCachedXBLPrototypeHandlers.EnumerateRead(MarkXBLHandlers, nullptr);
 88265:     }
 94914:     nsEventListenerManager* elm = tmp->GetListenerManager(false);
 94914:     if (elm) {
 94914:       elm->UnmarkGrayJSListeners();
 94914:     }
 94914:     tmp->UnmarkGrayTimers();
 88265:     return true;
 88265:   }
 88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
 88265: 
 88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsGlobalWindow)
 88265:   return tmp->IsBlackForCC();
 88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
 88265: 
 88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsGlobalWindow)
 88265:   return tmp->IsBlackForCC();
 88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
     1: 
109228: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(nsGlobalWindow)
107315:   if (NS_UNLIKELY(cb.WantDebugInfo())) {
107315:     char name[512];
107315:     PR_snprintf(name, sizeof(name), "nsGlobalWindow #%ld", tmp->mWindowID);
110454:     cb.DescribeRefCountedNode(tmp->mRefCnt.get(), name);
109228:   } else {
109228:     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(nsGlobalWindow, tmp->mRefCnt.get())
107315:   }
107315: 
 88265:   if (!cb.WantAllTraces() && tmp->IsBlackForCC()) {
 25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
  1353:   }
  1353: 
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
     1: 
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArguments)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArgumentsLast)
     1: 
105502:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mPerformance, nsPerformance)
105502: 
 47537:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInnerWindowHolder)
 55729:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOuterWindow)
     1: 
 72328:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mListenerManager,
 72328:                                                   nsEventListenerManager)
 24195: 
 24195:   for (nsTimeout* timeout = tmp->FirstTimeout();
 24195:        tmp->IsTimeout(timeout);
 24195:        timeout = timeout->Next()) {
102293:     cb.NoteNativeChild(timeout, NS_CYCLE_COLLECTION_PARTICIPANT(nsTimeout));
 24195:   }
 24195: 
 94868:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLocalStorage)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSessionStorage)
 10340:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mApplicationCache)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocumentPrincipal)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDoc)
103224:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mIdleService)
     1: 
     1:   // Traverse stuff from nsPIDOMWindow
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChromeEventHandler)
 43679:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParentTarget)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
 27191:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFrameElement)
  6774: 
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedNode)
 29018: 
 60680:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mPendingStorageEvents)
 60680: 
108991:   for (uint32_t i = 0; i < tmp->mIdleObservers.Length(); i++) {
103224:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mIdleObservers[i].nsIIdleObserverPtr");
103224:     cb.NoteXPCOMChild(tmp->mIdleObservers.ElementAt(i).mIdleObserver.get());
103224:   }
     1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
     1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGlobalWindow)
 67680:   nsGlobalWindow::CleanupCachedXBLHandlers(tmp);
 67680: 
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
     1: 
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mControllers)
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mArguments)
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mArgumentsLast)
     1: 
105502:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPerformance)
105502: 
 47537:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInnerWindowHolder)
 98106:   if (tmp->mOuterWindow) {
 98106:     static_cast<nsGlobalWindow*>(tmp->mOuterWindow.get())->MaybeClearInnerWindow(tmp);
 55729:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOuterWindow)
 98106:   }
     1: 
 72139:   if (tmp->mListenerManager) {
 72139:     tmp->mListenerManager->Disconnect();
     1:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mListenerManager)
 72139:   }
 94868:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLocalStorage)
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSessionStorage)
 10340:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mApplicationCache)
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocumentPrincipal)
 72139:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDoc)
     1: 
     1:   // Unlink stuff from nsPIDOMWindow
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChromeEventHandler)
 43679:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParentTarget)
     1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)
 27191:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFrameElement)
  6774: 
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedNode)
103224:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mIdleService)
 29018: 
 60680:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mPendingStorageEvents)
 60680: 
103224:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mIdleObservers)
103224: 
     1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
     1: 
 11622: struct TraceData
 11622: {
 11622:   TraceData(TraceCallback& aCallback, void* aClosure) :
 11622:     callback(aCallback), closure(aClosure) {}
 11622: 
 11622:   TraceCallback& callback;
 11622:   void* closure;
 11622: };
 11622: 
 20261: static PLDHashOperator
 93686: TraceXBLHandlers(nsXBLPrototypeHandler* aKey, JSObject* aData, void* aClosure)
 11622: {
 11622:   TraceData* data = static_cast<TraceData*>(aClosure);
 97523:   data->callback(aData, "Cached XBL prototype handler", data->closure);
 11622:   return PL_DHASH_NEXT;
 11622: }
 11622: 
 11622: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGlobalWindow)
 11622:   if (tmp->mCachedXBLPrototypeHandlers.IsInitialized()) {
 11622:     TraceData data(aCallback, aClosure);
 11622:     tmp->mCachedXBLPrototypeHandlers.EnumerateRead(TraceXBLHandlers, &data);
 11622:   }
 11622: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 11622: 
 88265: bool
 88265: nsGlobalWindow::IsBlackForCC()
 88265: {
 88265:   return
 88265:     (mDoc &&
 88265:      nsCCUncollectableMarker::InGeneration(mDoc->GetMarkedCCGeneration())) ||
 88265:     (nsCCUncollectableMarker::sGeneration && IsBlack());
 88265: }
 88265: 
 88265: void
 88265: nsGlobalWindow::UnmarkGrayTimers()
 88265: {
 88265:   for (nsTimeout* timeout = FirstTimeout();
 88265:        timeout && IsTimeout(timeout);
 88265:        timeout = timeout->Next()) {
 88265:     if (timeout->mScriptHandler) {
 88265:       JSObject* o = timeout->mScriptHandler->GetScriptObject();
 88265:       xpc_UnmarkGrayObject(o);
 88265:     }
 88265:   }
 88265: }
 88265: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsIScriptGlobalObject
     1: //*****************************************************************************
     1: 
     1: nsresult
 97740: nsGlobalWindow::EnsureScriptEnvironment()
 97740: {
 97740:   FORWARD_TO_OUTER(EnsureScriptEnvironment, (), NS_ERROR_NOT_INITIALIZED);
 97740: 
 97740:   if (mJSObject) {
 97740:     return NS_OK;
 97740:   }
 97740: 
 97740:   NS_ASSERTION(!GetCurrentInnerWindowInternal(),
 97740:                "mJSObject is null, but we have an inner window?");
 97740: 
 97740:   nsCOMPtr<nsIScriptRuntime> scriptRuntime;
 97740:   nsresult rv = NS_GetJSRuntime(getter_AddRefs(scriptRuntime));
 97740:   NS_ENSURE_SUCCESS(rv, rv);
 97740: 
 97740:   nsCOMPtr<nsIScriptContext> context = scriptRuntime->CreateContext();
 97740: 
 97740:   NS_ASSERTION(!mContext, "Will overwrite mContext!");
 97740: 
     1:   // should probably assert the context is clean???
 97740:   context->WillInitializeContext();
 47537: 
 95298:   // We need point the context to the global window before initializing it
 95298:   // so that it can make various decisions properly.
 97740:   context->SetGlobalObject(this);
 97740: 
 97740:   rv = context->InitContext();
     1:   NS_ENSURE_SUCCESS(rv, rv);
 48477: 
     1:   if (IsFrame()) {
     1:     // This window is a [i]frame, don't bother GC'ing when the
     1:     // frame's context is destroyed since a GC will happen when the
     1:     // frameset or host document is destroyed anyway.
     1: 
 97740:     context->SetGCOnDestruction(false);
 97740:   }
 97740: 
 97740:   mContext = context;
 97740:   return NS_OK;
     1: }
     1: 
     1: nsIScriptContext *
 93911: nsGlobalWindow::GetScriptContext()
 93911: {
106838:   FORWARD_TO_OUTER(GetScriptContext, (), nullptr);
 47537:   return mContext;
     1: }
     1: 
     1: nsIScriptContext *
     1: nsGlobalWindow::GetContext()
     1: {
106838:   FORWARD_TO_OUTER(GetContext, (), nullptr);
     1: 
     1:   // check GetContext is indeed identical to GetScriptContext()
 93911:   NS_ASSERTION(mContext == GetScriptContext(),
     1:                "GetContext confused?");
     1:   return mContext;
     1: }
     1: 
     1: JSObject *
     1: nsGlobalWindow::GetGlobalJSObject()
     1: {
 47412:   return FastGetGlobalJSObject();
 44204: }
     1: 
 79445: bool
     1: nsGlobalWindow::WouldReuseInnerWindow(nsIDocument *aNewDocument)
     1: {
     1:   // We reuse the inner window when:
     1:   // a. We are currently at our original document.
     1:   // b. At least one of the following conditions are true:
     1:   // -- The new document is the same as the old document. This means that we're
     1:   //    getting called from document.open().
     1:   // -- The new document has the same origin as what we have loaded right now.
     1: 
     1:   if (!mDoc || !aNewDocument) {
 80486:     return false;
     1:   }
     1: 
     1:   if (!mDoc->IsInitialDocument()) {
 80486:     return false;
     1:   }
     1:   
 78530:   NS_ASSERTION(NS_IsAboutBlank(mDoc->GetDocumentURI()),
     1:                "How'd this happen?");
     1: 
     1:   // Great, we're the original document, check for one of the other
     1:   // conditions.
111188: 
     1:   if (mDoc == aNewDocument) {
 80486:     return true;
     1:   }
     1: 
 79445:   bool equal;
  3286:   if (NS_SUCCEEDED(mDoc->NodePrincipal()->Equals(aNewDocument->NodePrincipal(),
  3286:                                                  &equal)) &&
  3286:       equal) {
     1:     // The origin is the same.
 80486:     return true;
     1:   }
     1: 
 80486:   return false;
     1: }
     1: 
     1: void
111184: nsGlobalWindow::SetInitialPrincipalToSubject()
111184: {
111186:   FORWARD_TO_OUTER_VOID(SetInitialPrincipalToSubject, ());
111186: 
111184:   // First, grab the subject principal. These methods never fail.
111183:   nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
111184:   nsCOMPtr<nsIPrincipal> newWindowPrincipal, systemPrincipal;
111184:   ssm->GetSubjectPrincipal(getter_AddRefs(newWindowPrincipal));
111184:   ssm->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
111184:   if (!newWindowPrincipal) {
111184:     newWindowPrincipal = systemPrincipal;
111184:   }
111184: 
111184:   // Now, if we're about to use the system principal, make sure we're not using
111184:   // it for a content docshell.
111184:   if (newWindowPrincipal == systemPrincipal) {
111183:     int32_t itemType;
111184:     nsCOMPtr<nsIDocShellTreeItem> item = do_QueryInterface(GetDocShell());
111184:     nsresult rv = item->GetItemType(&itemType);
111183:     if (NS_FAILED(rv) || itemType != nsIDocShellTreeItem::typeChrome) {
111183:       newWindowPrincipal = nullptr;
111183:     }
111183:   }
111183: 
111186:   // If there's an existing document, bail if it either:
111186:   if (mDoc) {
111186:     // (a) is not an initial about:blank document, or
111186:     if (!mDoc->IsInitialDocument())
111186:       return;
111186:     // (b) already has the correct principal.
111186:     if (mDoc->NodePrincipal() == newWindowPrincipal)
111186:       return;
111186: 
111186: #ifdef DEBUG
111186:     // If we have a document loaded at this point, it had better be about:blank.
111186:     // Otherwise, something is really weird.
111186:     nsCOMPtr<nsIURI> uri;
111186:     mDoc->NodePrincipal()->GetURI(getter_AddRefs(uri));
111186:     NS_ASSERTION(uri && NS_IsAboutBlank(uri) &&
111186:                  NS_IsAboutBlank(mDoc->GetDocumentURI()),
111186:                  "Unexpected original document");
111186: #endif
111186:   }
111186: 
111186:   GetDocShell()->CreateAboutBlankContentViewer(newWindowPrincipal);
111186:   mDoc->SetIsInitialDocument(true);
111186: 
111186:   nsCOMPtr<nsIPresShell> shell;
111186:   GetDocShell()->GetPresShell(getter_AddRefs(shell));
111186: 
111186:   if (shell && !shell->DidInitialReflow()) {
111186:     // Ensure that if someone plays with this document they will get
111186:     // layout happening.
111186:     nsRect r = shell->GetPresContext()->GetVisibleArea();
111186:     shell->InitialReflow(r.width, r.height);
111186:   }
111183: }
111183: 
     1: PopupControlState
 79445: PushPopupControlState(PopupControlState aState, bool aForce)
     1: {
     1:   PopupControlState oldState = gPopupControlState;
     1: 
     1:   if (aState < gPopupControlState || aForce) {
     1:     gPopupControlState = aState;
     1:   }
     1: 
     1:   return oldState;
     1: }
     1: 
     1: void
     1: PopPopupControlState(PopupControlState aState)
     1: {
     1:   gPopupControlState = aState;
     1: }
     1: 
     1: PopupControlState
     1: nsGlobalWindow::PushPopupControlState(PopupControlState aState,
 79445:                                       bool aForce) const
     1: {
     1:   return ::PushPopupControlState(aState, aForce);
     1: }
     1: 
     1: void
     1: nsGlobalWindow::PopPopupControlState(PopupControlState aState) const
     1: {
     1:   ::PopPopupControlState(aState);
     1: }
     1: 
     1: PopupControlState
     1: nsGlobalWindow::GetPopupControlState() const
     1: {
     1:   return gPopupControlState;
     1: }
     1: 
     1: #define WINDOWSTATEHOLDER_IID \
     1: {0x0b917c3e, 0xbd50, 0x4683, {0xaf, 0xc9, 0xc7, 0x81, 0x07, 0xae, 0x33, 0x26}}
     1: 
102221: class WindowStateHolder MOZ_FINAL : public nsISupports
     1: {
     1: public:
     1:   NS_DECLARE_STATIC_IID_ACCESSOR(WINDOWSTATEHOLDER_IID)
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   WindowStateHolder(nsGlobalWindow *aWindow,
108657:                     nsIXPConnectJSObjectHolder *aHolder);
     1: 
     1:   nsGlobalWindow* GetInnerWindow() { return mInnerWindow; }
 47537:   nsIXPConnectJSObjectHolder *GetInnerWindowHolder()
 47537:   { return mInnerWindowHolder; }
     1: 
     1:   void DidRestoreWindow()
     1:   {
106838:     mInnerWindow = nullptr;
106838:     mInnerWindowHolder = nullptr;
     1:   }
     1: 
     1: protected:
     1:   ~WindowStateHolder();
     1: 
     1:   nsGlobalWindow *mInnerWindow;
     1:   // We hold onto this to make sure the inner window doesn't go away. The outer
     1:   // window ends up recalculating it anyway.
 47537:   nsCOMPtr<nsIXPConnectJSObjectHolder> mInnerWindowHolder;
     1: };
     1: 
     1: NS_DEFINE_STATIC_IID_ACCESSOR(WindowStateHolder, WINDOWSTATEHOLDER_IID)
     1: 
     1: WindowStateHolder::WindowStateHolder(nsGlobalWindow *aWindow,
108657:                                      nsIXPConnectJSObjectHolder *aHolder)
108657:   : mInnerWindow(aWindow)
     1: {
     1:   NS_PRECONDITION(aWindow, "null window");
     1:   NS_PRECONDITION(aWindow->IsInnerWindow(), "Saving an outer window");
     1: 
 47537:   mInnerWindowHolder = aHolder;
 29018: 
     1:   aWindow->SuspendTimeouts();
     1: }
     1: 
     1: WindowStateHolder::~WindowStateHolder()
     1: {
     1:   if (mInnerWindow) {
     1:     // This window was left in the bfcache and is now going away. We need to
     1:     // free it up.
     1:     // Note that FreeInnerObjects may already have been called on the
     1:     // inner window if its outer has already had SetDocShell(null)
 91214:     // called.
 91214:     mInnerWindow->FreeInnerObjects();
     1:   }
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(WindowStateHolder, WindowStateHolder)
     1: 
     1: nsresult
 93876: nsGlobalWindow::CreateOuterObject(nsGlobalWindow* aNewInner)
 93876: {
 93876:   JSContext* cx = mContext->GetNativeContext();
 93876: 
 93876:   if (IsChromeWindow()) {
 93876:     // Always enable E4X for XUL and other chrome content -- there is no
 93876:     // need to preserve the <!-- script hiding hack from JS-in-HTML daze
 93876:     // (introduced in 1995 for graceful script degradation in Netscape 1,
 93876:     // Mosaic, and other pre-JS browsers).
 99820:     JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_MOAR_XML);
 93876:   }
 93876: 
 93876:   JSObject* outer = NewOuterWindowProxy(cx, aNewInner->FastGetGlobalJSObject());
 93876:   if (!outer) {
 93876:     return NS_ERROR_FAILURE;
 93876:   }
 93876: 
 93876:   js::SetProxyExtra(outer, 0,
 93876:     js::PrivateValue(static_cast<nsIScriptGlobalObject*>(this)));
 93876: 
 93876:   return SetOuterObject(cx, outer);
 93876: }
 93876: 
 93876: nsresult
 93876: nsGlobalWindow::SetOuterObject(JSContext* aCx, JSObject* aOuterObject)
 93876: {
 93876:   // Force our context's global object to be the outer.
 93876:   // NB: JS_SetGlobalObject sets aCx->compartment.
 93876:   JS_SetGlobalObject(aCx, aOuterObject);
 93876: 
 93876:   // Set up the prototype for the outer object.
 93876:   JSObject* inner = JS_GetParent(aOuterObject);
 93876:   JS_SetPrototype(aCx, aOuterObject, JS_GetPrototype(inner));
 93876: 
 93876:   return NS_OK;
 93876: }
 93876: 
101133: /**
101133:  * Create a new global object that will be used for an inner window.
101133:  * Return the native global and an nsISupports 'holder' that can be used
101133:  * to manage the lifetime of it.
101133:  */
101133: static nsresult
101133: CreateNativeGlobalForInner(JSContext* aCx,
101133:                            nsGlobalWindow* aNewInner,
101133:                            nsIURI* aURI,
101133:                            nsIPrincipal* aPrincipal,
101133:                            JSObject** aNativeGlobal,
101133:                            nsIXPConnectJSObjectHolder** aHolder)
101133: {
101133:   MOZ_ASSERT(aCx);
101133:   MOZ_ASSERT(aNewInner);
101133:   MOZ_ASSERT(aNewInner->IsInnerWindow());
101133:   MOZ_ASSERT(aPrincipal);
101133:   MOZ_ASSERT(aNativeGlobal);
101133:   MOZ_ASSERT(aHolder);
101133: 
101133:   nsIXPConnect* xpc = nsContentUtils::XPConnect();
101133: 
101133:   nsRefPtr<nsIXPConnectJSObjectHolder> jsholder;
101133:   nsresult rv = xpc->InitClassesWithNewWrappedGlobal(
101133:     aCx, static_cast<nsIScriptGlobalObject*>(aNewInner),
111193:     aPrincipal, 0, getter_AddRefs(jsholder));
101133:   NS_ENSURE_SUCCESS(rv, rv);
101133: 
101133:   MOZ_ASSERT(jsholder);
101133:   jsholder->GetJSObject(aNativeGlobal);
101133:   jsholder.forget(aHolder);
101133: 
101133:   // Set the location information for the new global, so that tools like
101133:   // about:memory may use that information
101133:   MOZ_ASSERT(*aNativeGlobal);
101133:   xpc::SetLocationForGlobal(*aNativeGlobal, aURI);
101133: 
101133:   return NS_OK;
101133: }
101133: 
 93876: nsresult
     1: nsGlobalWindow::SetNewDocument(nsIDocument* aDocument,
 53996:                                nsISupports* aState,
 79445:                                bool aForceReuseInnerWindow)
 39376: {
 41653:   NS_TIME_FUNCTION;
 41653: 
106838:   NS_PRECONDITION(mDocumentPrincipal == nullptr,
     1:                   "mDocumentPrincipal prematurely set!");
101132:   MOZ_ASSERT(aDocument);
 39376: 
 39376:   if (IsInnerWindow()) {
     1:     if (!mOuterWindow) {
     1:       return NS_ERROR_NOT_INITIALIZED;
     1:     }
     1: 
     1:     // Refuse to set a new document if the call came from an inner
     1:     // window that's not the current inner window.
     1:     if (mOuterWindow->GetCurrentInnerWindow() != this) {
     1:       return NS_ERROR_NOT_AVAILABLE;
     1:     }
     1: 
 53996:     return GetOuterWindowInternal()->SetNewDocument(aDocument, aState,
 53996:                                                     aForceReuseInnerWindow);
 39376:   }
 39376: 
 39376:   NS_PRECONDITION(IsOuterWindow(), "Must only be called on outer windows");
 39376: 
 39376:   if (IsFrozen()) {
 39376:     // This outer is now getting its first inner, thaw the outer now
 39376:     // that it's ready and is getting an inner window.
 49089: 
 39376:     Thaw();
     1:   }
     1: 
     1:   NS_ASSERTION(!GetCurrentInnerWindow() ||
     1:                GetCurrentInnerWindow()->GetExtantDocument() == mDocument,
     1:                "Uh, mDocument doesn't match the current inner window "
     1:                "document!");
     1: 
 79445:   bool wouldReuseInnerWindow = WouldReuseInnerWindow(aDocument);
 53996:   if (aForceReuseInnerWindow &&
 53996:       !wouldReuseInnerWindow &&
 53996:       mDoc &&
 53996:       mDoc->NodePrincipal() != aDocument->NodePrincipal()) {
 53996:     NS_ERROR("Attempted forced inner window reuse while changing principal");
 53996:     return NS_ERROR_UNEXPECTED;
 53996:   }
 53996: 
     1:   nsCOMPtr<nsIDocument> oldDoc(do_QueryInterface(mDocument));
     1: 
     1:   nsIScriptContext *scx = GetContextInternal();
     1:   NS_ENSURE_TRUE(scx, NS_ERROR_NOT_INITIALIZED);
     1: 
 78415:   JSContext *cx = scx->GetNativeContext();
 54925: #ifndef MOZ_DISABLE_DOMCRYPTO
     1:   // clear smartcard events, our document has gone away.
     1:   if (mCrypto) {
 80486:     mCrypto->SetEnableSmartCardEvents(false);
     1:   }
 54925: #endif
     1:   if (!mDocument) {
     1:     // First document load.
     1: 
     1:     // Get our private root. If it is equal to us, then we need to
     1:     // attach our global key bindings that handles browser scrolling
     1:     // and other browser commands.
 73870:     nsIDOMWindow* privateRoot = nsGlobalWindow::GetPrivateRoot();
 73870: 
 73870:     if (privateRoot == static_cast<nsIDOMWindow*>(this)) {
 99253:       nsXBLService::AttachGlobalKeyHandler(mChromeEventHandler);
     1:     }
     1:   }
     1: 
 42996:   /* No mDocShell means we're already been partially closed down.  When that
 42996:      happens, setting status isn't a big requirement, so don't. (Doesn't happen
 42996:      under normal circumstances, but bug 49615 describes a case.) */
 42996: 
 42996:   nsContentUtils::AddScriptRunner(
 42996:     NS_NewRunnableMethod(this, &nsGlobalWindow::ClearStatus));
     1: 
 79445:   bool reUseInnerWindow = aForceReuseInnerWindow || wouldReuseInnerWindow;
     1: 
 73870:   nsresult rv = NS_OK;
 73870: 
     1:   // Set mDocument even if this is an outer window to avoid
     1:   // having to *always* reach into the inner window to find the
     1:   // document.
     1:   mDocument = do_QueryInterface(aDocument);
     1:   mDoc = aDocument;
     1: 
 14743: #ifdef DEBUG
 14743:   mLastOpenedURI = aDocument->GetDocumentURI();
 14743: #endif
 14743: 
 47537:   mContext->WillInitializeContext();
     1: 
     1:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
     1: 
100179:   if (currentInner && currentInner->mNavigator) {
100179:     currentInner->mNavigator->OnNavigation();
100179:   }
100179: 
     1:   nsRefPtr<nsGlobalWindow> newInnerWindow;
 91826:   bool createdInnerWindow = false;
     1: 
 79445:   bool thisChrome = IsChromeWindow();
     1: 
 21376:   nsCxPusher cxPusher;
 21376:   if (!cxPusher.Push(cx)) {
 21376:     return NS_ERROR_FAILURE;
 21376:   }
 21376: 
 97592:   XPCAutoRequest ar(cx);
     1: 
 51082:   nsCOMPtr<WindowStateHolder> wsh = do_QueryInterface(aState);
 51082:   NS_ASSERTION(!aState || wsh, "What kind of weird state are you giving me here?");
 51082: 
     1:   if (reUseInnerWindow) {
     1:     // We're reusing the current inner window.
     1:     NS_ASSERTION(!currentInner->IsFrozen(),
     1:                  "We should never be reusing a shared inner window");
     1:     newInnerWindow = currentInner;
     1: 
     1:     if (aDocument != oldDoc) {
 97589:       xpc_UnmarkGrayObject(currentInner->mJSObject);
 55578:       nsWindowSH::InvalidateGlobalScopePolluter(cx, currentInner->mJSObject);
     1:     }
 62643: 
 98380:     // We're reusing the inner window, but this still counts as a navigation,
 98380:     // so all expandos and such defined on the outer window should go away. Force
 98380:     // all Xray wrappers to be recomputed.
 97589:     xpc_UnmarkGrayObject(mJSObject);
 98380:     if (!JS_RefreshCrossCompartmentWrappers(cx, mJSObject)) {
 62643:       return NS_ERROR_FAILURE;
 62643:     }
102067: 
102067:     // Inner windows are only reused for same-origin principals, but the principals
102067:     // don't necessarily match exactly. Update the principal on the compartment to
102067:     // match the new document.
102067:     // NB: We don't just call currentInner->RefreshCompartmentPrincipals() here
102067:     // because we haven't yet set its mDoc to aDocument.
111189:     JSCompartment *compartment = js::GetObjectCompartment(currentInner->mJSObject);
111189: #ifdef DEBUG
111189:     bool sameOrigin = false;
111189:     nsIPrincipal *existing =
111189:       nsJSPrincipals::get(JS_GetCompartmentPrincipals(compartment));
111189:     aDocument->NodePrincipal()->Equals(existing, &sameOrigin);
111189:     MOZ_ASSERT(sameOrigin);
111189: #endif
111189:     JS_SetCompartmentPrincipals(compartment,
102067:                                 nsJSPrincipals::get(aDocument->NodePrincipal()));
     1:   } else {
     1:     if (aState) {
     1:       newInnerWindow = wsh->GetInnerWindow();
 47537:       mInnerWindowHolder = wsh->GetInnerWindowHolder();
     1: 
 51987:       NS_ASSERTION(newInnerWindow, "Got a state without inner window");
 51987:     } else if (thisChrome) {
     1:       newInnerWindow = new nsGlobalChromeWindow(this);
 51987:     } else if (mIsModalContentWindow) {
  4040:       newInnerWindow = new nsGlobalModalWindow(this);
  4040:     } else {
     1:       newInnerWindow = new nsGlobalWindow(this);
     1:     }
     1: 
     1:     if (!aState) {
     1:       // Freeze the outer window and null out the inner window so
     1:       // that initializing classes on the new inner doesn't end up
     1:       // reaching into the old inner window for classes etc.
     1:       //
     1:       // [This happens with Object.prototype when XPConnect creates
     1:       // a temporary global while initializing classes; the reason
     1:       // being that xpconnect creates the temp global w/o a parent
     1:       // and proto, which makes the JS engine look up classes in
     1:       // cx->globalObject, i.e. this outer window].
     1: 
106838:       mInnerWindow = nullptr;
     1: 
     1:       Freeze();
 80486:       mCreatingInnerWindow = true;
     1:       // Every script context we are initialized with must create a
     1:       // new global.
101133:       rv = CreateNativeGlobalForInner(cx, newInnerWindow,
111193:                                       aDocument->GetDocumentURI(),
 48503:                                       aDocument->NodePrincipal(),
 82800:                                       &newInnerWindow->mJSObject,
101133:                                       getter_AddRefs(mInnerWindowHolder));
101133:       NS_ASSERTION(NS_SUCCEEDED(rv) && newInnerWindow->mJSObject && mInnerWindowHolder,
     1:                    "Failed to get script global and holder");
 47537: 
 80486:       mCreatingInnerWindow = false;
 91826:       createdInnerWindow = true;
     1:       Thaw();
     1: 
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
     1:     if (currentInner && currentInner->mJSObject) {
     1:       if (oldDoc == aDocument) {
 86264:         // Move the navigator from the old inner window to the new one since
 86264:         // this is a document.write. This is safe from a same-origin point of
 86264:         // view because document.write can only be used by the same origin.
 86264:         newInnerWindow->mNavigator = currentInner->mNavigator;
106838:         currentInner->mNavigator = nullptr;
 86264:         if (newInnerWindow->mNavigator) {
 86264:           newInnerWindow->mNavigator->SetWindow(newInnerWindow);
 86264:         }
107922: 
107922:         // Make a copy of the old window's performance object on document.open.
107922:         // Note that we have to force eager creation of it here, because we need
107922:         // to grab the current document channel and whatnot before that changes.
107922:         currentInner->CreatePerformanceObjectIfNeeded();
107922:         if (currentInner->mPerformance) {
107922:           newInnerWindow->mPerformance =
107922:             new nsPerformance(newInnerWindow,
107922:                               currentInner->mPerformance->GetDOMTiming(),
107922:                               currentInner->mPerformance->GetChannel());
107922:         }
 91214:       }
 91214: 
 91214:       // Don't free objects on our current inner window if it's going to be
     1:       // held in the bfcache.
     1:       if (!currentInner->IsFrozen()) {
 91214:         currentInner->FreeInnerObjects();
     1:       }
     1:     }
     1: 
     1:     mInnerWindow = newInnerWindow;
 51078: 
 51078:     if (!mJSObject) {
 93876:       CreateOuterObject(newInnerWindow);
 51078:       mContext->DidInitializeContext();
 55577: 
 81042:       mJSObject = mContext->GetNativeGlobal();
 55577:       SetWrapper(mJSObject);
 51078:     } else {
 97589:       JSObject *outerObject = NewOuterWindowProxy(cx, xpc_UnmarkGrayObject(newInnerWindow->mJSObject));
 55577:       if (!outerObject) {
 55577:         NS_ERROR("out of memory");
 55577:         return NS_ERROR_FAILURE;
 55577:       }
 55577: 
 80415:       js::SetProxyExtra(mJSObject, 0, js::PrivateValue(NULL));
 80415: 
106125:       outerObject = xpc::TransplantObject(cx, mJSObject, outerObject);
 55577:       if (!outerObject) {
 55577:         NS_ERROR("unable to transplant wrappers, probably OOM");
 55577:         return NS_ERROR_FAILURE;
 55577:       }
 55577: 
 80415:       nsIScriptGlobalObject *global = static_cast<nsIScriptGlobalObject*>(this);
 80415:       js::SetProxyExtra(outerObject, 0, js::PrivateValue(global));
 80415: 
 55577:       mJSObject = outerObject;
 55577:       SetWrapper(mJSObject);
 55577: 
 55604:       {
109257:         JSAutoCompartment ac(cx, mJSObject);
 55604: 
 55604:         JS_SetParent(cx, mJSObject, newInnerWindow->mJSObject);
 55604: 
 93876:         SetOuterObject(cx, mJSObject);
 80660: 
 80660:         JSCompartment *compartment = js::GetObjectCompartment(mJSObject);
 80660:         xpc::CompartmentPrivate *priv =
 91250:           static_cast<xpc::CompartmentPrivate*>(JS_GetCompartmentPrivate(compartment));
 80660:         if (priv && priv->waiverWrapperMap) {
 80660:           NS_ASSERTION(!JS_IsExceptionPending(cx),
 80660:                        "We might overwrite a pending exception!");
 94415:           priv->waiverWrapperMap->Reparent(cx, newInnerWindow->mJSObject);
 80660:         }
 55577:       }
 61142:     }
 55577: 
 93360:     // Enter the new global's compartment.
109257:     JSAutoCompartment ac(cx, mJSObject);
 93360: 
 91826:     // If we created a new inner window above, we need to do the last little bit
 91826:     // of initialization now that the dust has settled.
 91826:     if (createdInnerWindow) {
 91826:       nsIXPConnect *xpc = nsContentUtils::XPConnect();
 91826:       nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
 91826:       nsresult rv = xpc->GetWrappedNativeOfJSObject(cx, newInnerWindow->mJSObject,
 91826:                                                     getter_AddRefs(wrapper));
 91826:       NS_ENSURE_SUCCESS(rv, rv);
 91826:       NS_ABORT_IF_FALSE(wrapper, "bad wrapper");
 91826:       rv = wrapper->FinishInitForWrappedGlobal();
 91826:       NS_ENSURE_SUCCESS(rv, rv);
 91826:     }
 91826: 
108657:     if (!aState) {
 55583:       if (!JS_DefineProperty(cx, newInnerWindow->mJSObject, "window",
 55583:                              OBJECT_TO_JSVAL(mJSObject),
 62397:                              JS_PropertyStub, JS_StrictPropertyStub,
 55583:                              JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {
 55583:         NS_ERROR("can't create the 'window' property");
 55583:         return NS_ERROR_FAILURE;
 55583:       }
 51082:     }
 51078:   }
     1: 
109257:   JSAutoCompartment ac(cx, mJSObject);
 61142: 
     1:   if (!aState && !reUseInnerWindow) {
     1:     // Loading a new page and creating a new inner window, *not*
     1:     // restoring from session history.
     1: 
     1:     // Now that both the the inner and outer windows are initialized
 47537:     // let the script context do its magic to hook them together.
 93877: #ifdef DEBUG
 93877:     JSObject* newInnerJSObject = newInnerWindow->FastGetGlobalJSObject();
 93877: #endif
 93877: 
 93877:     // Now that we're connecting the outer global to the inner one,
 93877:     // we must have transplanted it. The JS engine tries to maintain
 93877:     // the global object's compartment as its default compartment,
 93877:     // so update that now since it might have changed.
 93877:     JS_SetGlobalObject(cx, mJSObject);
 93877:     NS_ASSERTION(JS_GetPrototype(mJSObject) ==
 93877:                  JS_GetPrototype(newInnerJSObject),
 93877:                  "outer and inner globals should have the same prototype");
 25723: 
 25723:     nsCOMPtr<nsIContent> frame = do_QueryInterface(GetFrameElementInternal());
 93877:     if (frame) {
 80526:       nsPIDOMWindow* parentWindow = frame->OwnerDoc()->GetWindow();
 25723:       if (parentWindow && parentWindow->TimeoutSuspendCount()) {
 25723:         SuspendTimeouts(parentWindow->TimeoutSuspendCount());
 25723:       }
 25723:     }
     1:   }
 47537: 
     1:   // Add an extra ref in case we release mContext during GC.
 47537:   nsCOMPtr<nsIScriptContext> kungFuDeathGrip(mContext);
     1: 
     1:   // Now that the prototype is all set up, install the global scope
     1:   // polluter. This must happen after the above prototype fixup. If
     1:   // the GSP was to be installed on the inner window's real
     1:   // prototype (as it would be if this was done before the prototype
     1:   // fixup above) we would end up holding the GSP alive (through
     1:   // XPConnect's internal marking of wrapper prototypes) as long as
     1:   // the inner window was around, and if the GSP had properties on
     1:   // it that held an element alive we'd hold the document alive,
     1:   // which could hold event handlers alive, which hold the context
     1:   // alive etc.
     1: 
     1:   if ((!reUseInnerWindow || aDocument != oldDoc) && !aState) {
     1:     nsCOMPtr<nsIHTMLDocument> html_doc(do_QueryInterface(mDocument));
 55578:     nsWindowSH::InstallGlobalScopePolluter(cx, newInnerWindow->mJSObject,
     1:                                            html_doc);
     1:   }
     1: 
     1:   aDocument->SetScriptGlobalObject(newInnerWindow);
     1: 
     1:   if (!aState) {
     1:     if (reUseInnerWindow) {
     1:       if (newInnerWindow->mDoc != aDocument) {
     1:         newInnerWindow->mDocument = do_QueryInterface(aDocument);
     1:         newInnerWindow->mDoc = aDocument;
     1: 
     1:         // We're reusing the inner window for a new document. In this
     1:         // case we don't clear the inner window's scope, but we must
     1:         // make sure the cached document property gets updated.
     1: 
     1:         // XXXmarkh - tell other languages about this?
     1:         ::JS_DeleteProperty(cx, currentInner->mJSObject, "document");
     1:       }
     1:     } else {
102192:       newInnerWindow->InnerSetNewDocument(aDocument);
     1: 
     1:       // Initialize DOM classes etc on the inner window.
 55604:       rv = mContext->InitClasses(newInnerWindow->mJSObject);
     1:       NS_ENSURE_SUCCESS(rv, rv);
 55673:     }
     1: 
     1:     if (mArguments) {
 33525:       newInnerWindow->DefineArgumentsProperty(mArguments);
 33525:       newInnerWindow->mArguments = mArguments;
 33525:       newInnerWindow->mArgumentsOrigin = mArgumentsOrigin;
 33525: 
106838:       mArguments = nullptr;
106838:       mArgumentsOrigin = nullptr;
     1:     }
     1: 
     1:     // Give the new inner window our chrome event handler (since it
     1:     // doesn't have one).
     1:     newInnerWindow->mChromeEventHandler = mChromeEventHandler;
     1:   }
     1: 
 88182:   mContext->GC(js::gcreason::SET_NEW_DOCUMENT);
 47537:   mContext->DidInitializeContext();
 44204: 
 58025:   if (newInnerWindow && !newInnerWindow->mHasNotifiedGlobalCreated && mDoc) {
 58025:     // We should probably notify. However if this is the, arguably bad,
 58025:     // situation when we're creating a temporary non-chrome-about-blank
 58025:     // document in a chrome docshell, don't notify just yet. Instead wait
 58025:     // until we have a real chrome doc.
 58025:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
108991:     int32_t itemType = nsIDocShellTreeItem::typeContent;
 58025:     if (treeItem) {
 58025:       treeItem->GetItemType(&itemType);
 58025:     }
 58025: 
 58025:     if (itemType != nsIDocShellTreeItem::typeChrome ||
 58025:         nsContentUtils::IsSystemPrincipal(mDoc->NodePrincipal())) {
 80486:       newInnerWindow->mHasNotifiedGlobalCreated = true;
 43472:       nsContentUtils::AddScriptRunner(
 43472:         NS_NewRunnableMethod(this, &nsGlobalWindow::DispatchDOMWindowCreated));
 51987:     }
 58025:   }
 43472: 
 43472:   return NS_OK;
 43472: }
 43472: 
 43472: void
 43472: nsGlobalWindow::DispatchDOMWindowCreated()
 43472: {
 47340:   if (!mDoc || !mDocument) {
 47340:     return;
 47340:   }
 47340: 
 43472:   // Fire DOMWindowCreated at chrome event listeners
 43472:   nsContentUtils::DispatchChromeEvent(mDoc, mDocument, NS_LITERAL_STRING("DOMWindowCreated"),
 80486:                                       true /* bubbles */,
 80486:                                       false /* not cancellable */);
 43472: 
 39377:   nsCOMPtr<nsIObserverService> observerService =
 41540:     mozilla::services::GetObserverService();
 39377:   if (observerService) {
 39377:     nsAutoString origin;
 43472:     nsIPrincipal* principal = mDoc->NodePrincipal();
 39377:     nsContentUtils::GetUTFOrigin(principal, origin);
 39377:     observerService->
 39377:       NotifyObservers(static_cast<nsIDOMWindow*>(this),
 39377:                       nsContentUtils::IsSystemPrincipal(principal) ?
 39377:                         "chrome-document-global-created" :
 39377:                         "content-document-global-created",
 39377:                       origin.get());
 39377:   }
 39376: }
 39376: 
 42996: void
 42996: nsGlobalWindow::ClearStatus()
 42996: {
 42996:   SetStatus(EmptyString());
 42996:   SetDefaultStatus(EmptyString());
 42996: }
 42996: 
102192: void
 39402: nsGlobalWindow::InnerSetNewDocument(nsIDocument* aDocument)
 39376: {
 39376:   NS_PRECONDITION(IsInnerWindow(), "Must only be called on inner windows");
102192:   MOZ_ASSERT(aDocument);
 39376: 
 39376: #ifdef PR_LOGGING
102192:   if (gDOMLeakPRLog && PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
 39376:     nsIURI *uri = aDocument->GetDocumentURI();
110974:     nsAutoCString spec;
 39376:     if (uri)
 39376:       uri->GetSpec(spec);
 39376:     PR_LogPrint("DOMWINDOW %p SetNewDocument %s", this, spec.get());
 39376:   }
 39376: #endif
 39376: 
 39376:   mDocument = do_QueryInterface(aDocument);
 39376:   mDoc = aDocument;
106838:   mFocusedNode = nullptr;
106838:   mLocalStorage = nullptr;
106838:   mSessionStorage = nullptr;
 39376: 
 39376: #ifdef DEBUG
 39376:   mLastOpenedURI = aDocument->GetDocumentURI();
 39376: #endif
     1: 
 80393:   Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
 80393:                         mMutationBits ? 1 : 0);
 80393: 
     1:   // Clear our mutation bitfield.
     1:   mMutationBits = 0;
     1: }
     1: 
     1: void
     1: nsGlobalWindow::SetDocShell(nsIDocShell* aDocShell)
     1: {
     1:   NS_ASSERTION(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
 99584:   MOZ_ASSERT(aDocShell);
 99584: 
 99584:   if (aDocShell == mDocShell) {
     1:     return;
 38439:   }
 38439: 
     1:   mDocShell = aDocShell; // Weak Reference
     1: 
 83058:   NS_ASSERTION(!mNavigator, "Non-null mNavigator in outer window!");
 83058: 
 99584:   if (mFrames) {
     1:     mFrames->SetDocShell(aDocShell);
 99584:   }
 99584: 
     1:   // Get our enclosing chrome shell and retrieve its global window impl, so
     1:   // that we can do some forwarding to the chrome document.
     1:   nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
     1:   mDocShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
     1:   mChromeEventHandler = do_QueryInterface(chromeEventHandler);
     1:   if (!mChromeEventHandler) {
     1:     // We have no chrome event handler. If we have a parent,
     1:     // get our chrome event handler from the parent. If
     1:     // we don't have a parent, then we need to make a new
     1:     // window root object that will function as a chrome event
     1:     // handler and receive all events that occur anywhere inside
     1:     // our window.
     1:     nsCOMPtr<nsIDOMWindow> parentWindow;
     1:     GetParent(getter_AddRefs(parentWindow));
  3233:     if (parentWindow.get() != static_cast<nsIDOMWindow*>(this)) {
     1:       nsCOMPtr<nsPIDOMWindow> piWindow(do_QueryInterface(parentWindow));
     1:       mChromeEventHandler = piWindow->GetChromeEventHandler();
     1:     }
 99584:     else {
 99584:       NS_NewWindowRoot(this, getter_AddRefs(mChromeEventHandler));
 99584:     }
     1:   }
 63938: 
 79445:   bool docShellActive;
 63938:   mDocShell->GetIsActive(&docShellActive);
 63938:   mIsBackground = !docShellActive;
 99466: }
 99584: 
 99584: void
 99584: nsGlobalWindow::DetachFromDocShell()
 99584: {
 99584:   NS_ASSERTION(IsOuterWindow(), "Uh, DetachFromDocShell() called on inner window!");
 99584: 
 99584:   // DetachFromDocShell means the window is being torn down. Drop our
 99584:   // reference to the script context, allowing it to be deleted
 99584:   // later. Meanwhile, keep our weak reference to the script object
 99584:   // (mJSObject) so that it can be retrieved later (until it is
 99584:   // finalized by the JS GC).
 99584: 
 99584:   NS_ASSERTION(PR_CLIST_IS_EMPTY(&mTimeouts),
 99584:                "Uh, outer window holds timeouts!");
 99584: 
 99584:   // Call FreeInnerObjects on all inner windows, not just the current
 99584:   // one, since some could be held by WindowStateHolder objects that
 99584:   // are GC-owned.
 99584:   for (nsRefPtr<nsGlobalWindow> inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
 99584:        inner != this;
 99584:        inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
 99584:     NS_ASSERTION(!inner->mOuterWindow || inner->mOuterWindow == this,
 99584:                  "bad outer window pointer");
 99584:     inner->FreeInnerObjects();
 99584:   }
 99584: 
 99584:   // Make sure that this is called before we null out the document.
 99584:   NotifyDOMWindowDestroyed(this);
 99584: 
 99584:   NotifyWindowIDDestroyed("outer-window-destroyed");
 99584: 
 99584:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
 99584: 
 99584:   if (currentInner) {
 99584:     NS_ASSERTION(mDoc, "Must have doc!");
 99584:     
 99584:     // Remember the document's principal.
 99584:     mDocumentPrincipal = mDoc->NodePrincipal();
 99584: 
 99584:     // Release our document reference
106838:     mDocument = nullptr;
106838:     mDoc = nullptr;
106838:     mFocusedNode = nullptr;
 99584:   }
 99584: 
 99584:   ClearControllers();
 99584: 
106838:   mChromeEventHandler = nullptr; // force release now
 99584: 
 99584:   if (mArguments) { 
 99584:     // We got no new document after someone called
 99584:     // SetArguments(), drop our reference to the arguments.
106838:     mArguments = nullptr;
106838:     mArgumentsLast = nullptr;
106838:     mArgumentsOrigin = nullptr;
 99584:   }
 99584: 
 99584:   if (mContext) {
 99584:     mContext->GC(js::gcreason::SET_DOC_SHELL);
106838:     mContext = nullptr;
 99584:   }
 99584: 
 99584: #ifdef DEBUG
 99584:   nsCycleCollector_DEBUG_shouldBeFreed(mContext);
 99584:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
 99584: #endif
 99584: 
106838:   mDocShell = nullptr; // Weak Reference
 99584: 
 99584:   NS_ASSERTION(!mNavigator, "Non-null mNavigator in outer window!");
 99584: 
 99584:   if (mFrames) {
106838:     mFrames->SetDocShell(nullptr);
 99584:   }
 99584: 
 99584:   MaybeForgiveSpamCount();
 99584:   CleanUp(false);
 99539: 
 99539:     if (mLocalStorage) {
 99539:       nsCOMPtr<nsIPrivacyTransitionObserver> obs = do_GetInterface(mLocalStorage);
 99539:       if (obs) {
 99539:         mDocShell->AddWeakPrivacyTransitionObserver(obs);
 99539:       }
 99539:     }
 99539:     if (mSessionStorage) {
 99539:       nsCOMPtr<nsIPrivacyTransitionObserver> obs = do_GetInterface(mSessionStorage);
 99539:       if (obs) {
 99539:         mDocShell->AddWeakPrivacyTransitionObserver(obs);
 99539:       }
 99539:     }
     1: }
     1: 
     1: void
 73870: nsGlobalWindow::SetOpenerWindow(nsIDOMWindow* aOpener,
 79445:                                 bool aOriginalOpener)
     1: {
     1:   FORWARD_TO_OUTER_VOID(SetOpenerWindow, (aOpener, aOriginalOpener));
     1: 
     1:   NS_ASSERTION(!aOriginalOpener || !mSetOpenerWindowCalled,
     1:                "aOriginalOpener is true, but not first call to "
     1:                "SetOpenerWindow!");
     1:   NS_ASSERTION(aOpener || !aOriginalOpener,
     1:                "Shouldn't set mHadOriginalOpener if aOpener is null");
     1: 
 11416:   mOpener = do_GetWeakReference(aOpener);
 21853:   NS_ASSERTION(mOpener || !aOpener, "Opener must support weak references!");
 11416: 
     1:   if (aOriginalOpener) {
 80486:     mHadOriginalOpener = true;
     1:   }
     1: 
     1: #ifdef DEBUG
 80486:   mSetOpenerWindowCalled = true;
     1: #endif
     1: }
     1: 
 98014: static
 98014: already_AddRefed<nsIDOMEventTarget>
 98014: TryGetTabChildGlobalAsEventTarget(nsISupports *aFrom)
 98014: {
 98014:   nsCOMPtr<nsIFrameLoaderOwner> frameLoaderOwner = do_QueryInterface(aFrom);
 98014:   if (!frameLoaderOwner) {
 98014:     return NULL;
 98014:   }
 98014: 
 98014:   nsRefPtr<nsFrameLoader> frameLoader = frameLoaderOwner->GetFrameLoader();
 98014:   if (!frameLoader) {
 98014:     return NULL;
 98014:   }
 98014: 
 98014:   nsCOMPtr<nsIDOMEventTarget> eventTarget =
 98014:     frameLoader->GetTabChildGlobalAsEventTarget();
 98014:   return eventTarget.forget();
 98014: }
 98014: 
 43680: void
 43680: nsGlobalWindow::UpdateParentTarget()
 43680: {
 98014:   // Try to get our frame element's tab child global (its in-process message
 98014:   // manager).  If that fails, fall back to the chrome event handler's tab
 98014:   // child global, and if it doesn't have one, just use the chrome event
 98014:   // handler itself.
 98014: 
 98014:   nsCOMPtr<nsIDOMElement> frameElement = GetFrameElementInternal();
 98014:   nsCOMPtr<nsIDOMEventTarget> eventTarget =
 98014:     TryGetTabChildGlobalAsEventTarget(frameElement);
 98014: 
 98014:   if (!eventTarget) {
 98014:     eventTarget = TryGetTabChildGlobalAsEventTarget(mChromeEventHandler);
 98014:   }
 98014: 
 98014:   if (!eventTarget) {
 98014:     eventTarget = mChromeEventHandler;
 98014:   }
 98014: 
 98014:   mParentTarget = eventTarget;
 43680: }
 43680: 
 79445: bool
 62677: nsGlobalWindow::GetIsTabModalPromptAllowed()
 62677: {
 79445:   bool allowTabModal = true;
 62677:   if (mDocShell) {
 62677:     nsCOMPtr<nsIContentViewer> cv;
 62677:     mDocShell->GetContentViewer(getter_AddRefs(cv));
 63887:     cv->GetIsTabModalPromptAllowed(&allowTabModal);
 62677:   }
 62677: 
 62677:   return allowTabModal;
 62677: }
 62677: 
 72326: nsIDOMEventTarget*
 72322: nsGlobalWindow::GetTargetForDOMEvent()
 72322: {
 72326:   return static_cast<nsIDOMEventTarget*>(GetOuterWindowInternal());
 72326: }
 72326: 
 72326: nsIDOMEventTarget*
 72322: nsGlobalWindow::GetTargetForEventTargetChain()
 72322: {
 72322:   return IsInnerWindow() ?
 72326:     this : static_cast<nsIDOMEventTarget*>(GetCurrentInnerWindowInternal());
 72322: }
 72322: 
 72322: nsresult
 72322: nsGlobalWindow::WillHandleEvent(nsEventChainPostVisitor& aVisitor)
 72322: {
 72322:   return NS_OK;
 72322: }
 72322: 
 72322: JSContext*
 72322: nsGlobalWindow::GetJSContextForEventHandlers()
 72322: {
106838:   return nullptr;
 72322: }
 72322: 
     1: nsresult
     1: nsGlobalWindow::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
     1: {
   588:   NS_PRECONDITION(IsInnerWindow(), "PreHandleEvent is used on outer window!?");
108991:   static uint32_t count = 0;
108991:   uint32_t msg = aVisitor.mEvent->message;
     1: 
 80486:   aVisitor.mCanHandle = true;
 80486:   aVisitor.mForceContentDispatch = true; //FIXME! Bug 329119
     1:   if ((msg == NS_MOUSE_MOVE) && gEntropyCollector) {
     1:     //Chances are this counter will overflow during the life of the
     1:     //process, but that's OK for our case. Means we get a little
     1:     //more entropy.
     1:     if (count++ % 100 == 0) {
     1:       //Since the high bits seem to be zero's most of the time,
     1:       //let's only take the lowest half of the point structure.
108991:       int16_t myCoord[2];
     1: 
     1:       myCoord[0] = aVisitor.mEvent->refPoint.x;
     1:       myCoord[1] = aVisitor.mEvent->refPoint.y;
     1:       gEntropyCollector->RandomUpdate((void*)myCoord, sizeof(myCoord));
     1:       gEntropyCollector->RandomUpdate((void*)&(aVisitor.mEvent->time),
108991:                                       sizeof(uint32_t));
     1:     }
     1:   } else if (msg == NS_RESIZE_EVENT) {
 80486:     mIsHandlingResizeEvent = true;
 13279:   } else if (msg == NS_MOUSE_BUTTON_DOWN &&
 13279:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
 80486:     gMouseDown = true;
 72978:   } else if ((msg == NS_MOUSE_BUTTON_UP ||
 72978:               msg == NS_DRAGDROP_END) &&
 13279:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
 80486:     gMouseDown = false;
 13279:     if (gDragServiceDisabled) {
 13279:       nsCOMPtr<nsIDragService> ds =
 13279:         do_GetService("@mozilla.org/widget/dragservice;1");
 13279:       if (ds) {
 80486:         gDragServiceDisabled = false;
 13279:         ds->Unsuppress();
 13279:       }
 13279:     }
     1:   }
     1: 
 43680:   aVisitor.mParentTarget = GetParentTarget();
103224: 
103224:   // Handle 'active' event.
103224:   if (!mIdleObservers.IsEmpty() &&
103224:       NS_IS_TRUSTED_EVENT(aVisitor.mEvent) &&
103224:       (NS_IS_MOUSE_EVENT(aVisitor.mEvent) ||
103224:        NS_IS_DRAG_EVENT(aVisitor.mEvent))) {
103224:     mAddActiveEventFuzzTime = false;
103224:   }
103224: 
     1:   return NS_OK;
     1: }
     1: 
 54231: bool
108232: nsGlobalWindow::DialogsAreBlocked(bool *aBeingAbused)
108232: {
108232:   *aBeingAbused = false;
108232: 
101616:   nsGlobalWindow *topWindow = GetScriptableTop();
 54231:   if (!topWindow) {
111195:     NS_ASSERTION(!mDocShell, "DialogsAreBlocked() called without a top window?");
108232:     return true;
 54231:   }
 54231: 
 54231:   topWindow = topWindow->GetCurrentInnerWindowInternal();
108232:   if (!topWindow) {
108232:     return true;
108232:   }
108232: 
108233:   if (topWindow->mDialogsPermanentlyDisabled) {
108233:     return true;
108233:   }
108233: 
108233:   // Dialogs are blocked if the content viewer is hidden
108233:   if (mDocShell) {
108233:     nsCOMPtr<nsIContentViewer> cv;
108233:     mDocShell->GetContentViewer(getter_AddRefs(cv));
108233: 
108233:     bool isHidden;
108233:     cv->GetIsHidden(&isHidden);
108233:     if (isHidden) {
108233:       return true;
108233:     }
108233:   }
108233: 
108232:   *aBeingAbused = topWindow->DialogsAreBeingAbused();
108232: 
108232:   return topWindow->mStopAbuseDialogs && *aBeingAbused;
108232: }
108232: 
108232: bool
108232: nsGlobalWindow::DialogsAreBeingAbused()
108232: {
108232:   NS_ASSERTION(GetScriptableTop() &&
108232:                GetScriptableTop()->GetCurrentInnerWindowInternal() == this,
108232:                "DialogsAreBeingAbused called with invalid window");
108232:             
108232:   if (mLastDialogQuitTime.IsNull() ||
 86399:       nsContentUtils::CallerHasUniversalXPConnect()) {
 54231:     return false;
 54231:   }
 54231:  
108232:   TimeDuration dialogInterval(TimeStamp::Now() - mLastDialogQuitTime);
108232:   if (dialogInterval.ToSeconds() <
 70842:       Preferences::GetInt("dom.successive_dialog_time_limit",
108232:                           DEFAULT_SUCCESSIVE_DIALOG_TIME_LIMIT)) {
108232:     mDialogAbuseCount++;
108232: 
108232:     return GetPopupControlState() > openAllowed ||
108232:            mDialogAbuseCount > MAX_SUCCESSIVE_DIALOG_COUNT;
108232:   }
108232: 
108232:   // Reset the abuse counter
108232:   mDialogAbuseCount = 0;
 54231: 
 54231:   return false;
 54231: }
 54231: 
 54231: bool
108232: nsGlobalWindow::ConfirmDialogIfNeeded()
108232: {
108232:   FORWARD_TO_OUTER(ConfirmDialogIfNeeded, (), false);
 55612: 
 54231:   NS_ENSURE_TRUE(mDocShell, false);
 54231:   nsCOMPtr<nsIPromptService> promptSvc =
 54231:     do_GetService("@mozilla.org/embedcomp/prompt-service;1");
 54231: 
108232:   if (!promptSvc) {
 54231:     return true;
 54231:   }
 54231: 
 54231:   // Reset popup state while opening a modal dialog, and firing events
 54231:   // about the dialog, to prevent the current state from being active
 54231:   // the whole time a modal dialog is open.
 80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
 54231: 
 79445:   bool disableDialog = false;
 54231:   nsXPIDLString label, title;
 54231:   nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
 54231:                                      "ScriptDialogLabel", label);
 54231:   nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
 54231:                                      "ScriptDialogPreventTitle", title);
 54231:   promptSvc->Confirm(this, title.get(), label.get(), &disableDialog);
 54231:   if (disableDialog) {
108233:     PreventFurtherDialogs(false);
 54231:     return false;
 54231:   }
 54231: 
 54231:   return true;
 54231: }
 54231: 
 54231: void
108233: nsGlobalWindow::PreventFurtherDialogs(bool aPermanent)
 54231: {
101616:   nsGlobalWindow *topWindow = GetScriptableTop();
 54231:   if (!topWindow) {
 54231:     NS_ERROR("PreventFurtherDialogs() called without a top window?");
 54231:     return;
 54231:   }
 54231: 
 54231:   topWindow = topWindow->GetCurrentInnerWindowInternal();
108232:   if (topWindow) {
108232:     topWindow->mStopAbuseDialogs = true;
108233:     if (aPermanent) {
108233:       topWindow->mDialogsPermanentlyDisabled = true;
108233:     }
108232:   }
 54231: }
 54231: 
     1: nsresult
     1: nsGlobalWindow::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
     1: {
   588:   NS_PRECONDITION(IsInnerWindow(), "PostHandleEvent is used on outer window!?");
 29430: 
 29430:   // Return early if there is nothing to do.
 29430:   switch (aVisitor.mEvent->message) {
 29430:     case NS_RESIZE_EVENT:
 29430:     case NS_PAGE_UNLOAD:
 29430:     case NS_LOAD:
 29430:       break;
 29430:     default:
 29430:       return NS_OK;
 29430:   }
 29430: 
     1:   /* mChromeEventHandler and mContext go dangling in the middle of this
     1:    function under some circumstances (events that destroy the window)
     1:    without this addref. */
 72326:   nsCOMPtr<nsIDOMEventTarget> kungFuDeathGrip1(mChromeEventHandler);
     1:   nsCOMPtr<nsIScriptContext> kungFuDeathGrip2(GetContextInternal());
     1: 
     1:   if (aVisitor.mEvent->message == NS_RESIZE_EVENT) {
 80486:     mIsHandlingResizeEvent = false;
     1:   } else if (aVisitor.mEvent->message == NS_PAGE_UNLOAD &&
     1:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
     1:     // Execute bindingdetached handlers before we tear ourselves
     1:     // down.
     1:     if (mDocument) {
     1:       NS_ASSERTION(mDoc, "Must have doc");
     1:       mDoc->BindingManager()->ExecuteDetachedHandlers();
     1:     }
 80486:     mIsDocumentLoaded = false;
     1:   } else if (aVisitor.mEvent->message == NS_LOAD &&
     1:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
     1:     // This is page load event since load events don't propagate to |window|.
     1:     // @see nsDocument::PreHandleEvent.
 80486:     mIsDocumentLoaded = true;
     1: 
     1:     nsCOMPtr<nsIContent> content(do_QueryInterface(GetFrameElementInternal()));
     1:     nsCOMPtr<nsIDocShellTreeItem> treeItem =
     1:       do_QueryInterface(GetDocShell());
     1: 
108991:     int32_t itemType = nsIDocShellTreeItem::typeChrome;
     1: 
     1:     if (treeItem) {
     1:       treeItem->GetItemType(&itemType);
     1:     }
     1: 
     1:     if (content && GetParentInternal() &&
     1:         itemType != nsIDocShellTreeItem::typeChrome) {
     1:       // If we're not in chrome, or at a chrome boundary, fire the
     1:       // onload event for the frame element.
     1: 
     1:       nsEventStatus status = nsEventStatus_eIgnore;
     1:       nsEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent), NS_LOAD);
     1:       event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
     1: 
     1:       // Most of the time we could get a pres context to pass in here,
     1:       // but not always (i.e. if this window is not shown there won't
     1:       // be a pres context available). Since we're not firing a GUI
     1:       // event we don't need a pres context anyway so we just pass
     1:       // null as the pres context all the time here.
106838:       nsEventDispatcher::Dispatch(content, nullptr, &event, nullptr, &status);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::DispatchDOMEvent(nsEvent* aEvent,
     1:                                  nsIDOMEvent* aDOMEvent,
     1:                                  nsPresContext* aPresContext,
     1:                                  nsEventStatus* aEventStatus)
     1: {
     1:   return
  3233:     nsEventDispatcher::DispatchDOMEvent(static_cast<nsPIDOMWindow*>(this),
     1:                                        aEvent, aDOMEvent, aPresContext,
     1:                                        aEventStatus);
     1: }
     1: 
     1: void
 68467: nsGlobalWindow::OnFinalize(JSObject* aObject)
 68467: {
 47537:   if (aObject == mJSObject) {
 68467:     mJSObject = NULL;
 47537:   }
     1: }
     1: 
     1: void
 79445: nsGlobalWindow::SetScriptsEnabled(bool aEnabled, bool aFireTimeouts)
     1: {
     1:   FORWARD_TO_INNER_VOID(SetScriptsEnabled, (aEnabled, aFireTimeouts));
     1: 
     1:   if (aEnabled && aFireTimeouts) {
     1:     // Scripts are enabled (again?) on this context, run timeouts that
     1:     // fired on this context while scripts were disabled.
 41361:     void (nsGlobalWindow::*run)() = &nsGlobalWindow::RunTimeout;
 41361:     NS_DispatchToCurrentThread(NS_NewRunnableMethod(this, run));
     1:   }
     1: }
     1: 
     1: nsresult
 33525: nsGlobalWindow::SetArguments(nsIArray *aArguments, nsIPrincipal *aOrigin)
 33525: {
 33525:   FORWARD_TO_OUTER(SetArguments, (aArguments, aOrigin),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   // Hold on to the arguments so that we can re-set them once the next
     1:   // document is loaded.
     1:   mArguments = aArguments;
 33525:   mArgumentsOrigin = aOrigin;
 33525: 
 33525:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
 33525: 
 33525:   if (!mIsModalContentWindow) {
     1:     mArgumentsLast = aArguments;
 33525:   } else if (currentInner) {
 33525:     // SetArguments() is being called on a modal content window that
 33525:     // already has an inner window. This can happen when loading
 33525:     // javascript: URIs as modal content dialogs. In this case, we'll
 33525:     // set up the dialog window, both inner and outer, before we call
 33525:     // SetArguments() on the window, so to deal with that, make sure
 33525:     // here that the arguments are propagated to the inner window.
 33525: 
 33525:     currentInner->mArguments = aArguments;
 33525:     currentInner->mArgumentsOrigin = aOrigin;
 33525:   }
 33525: 
 33525:   return currentInner ?
 33525:     currentInner->DefineArgumentsProperty(aArguments) : NS_OK;
 33525: }
 33525: 
 33525: nsresult
 33525: nsGlobalWindow::DefineArgumentsProperty(nsIArray *aArguments)
 33525: {
 33525:   JSContext *cx;
 33525:   nsIScriptContext *ctx = GetOuterWindowInternal()->mContext;
 33525:   NS_ENSURE_TRUE(aArguments && ctx &&
 78415:                  (cx = ctx->GetNativeContext()),
 33525:                  NS_ERROR_NOT_INITIALIZED);
 33525: 
 33525:   if (mIsModalContentWindow) {
 33525:     // Modal content windows don't have an "arguments" property, they
 33525:     // have a "dialogArguments" property which is handled
 55578:     // separately. See nsWindowSH::NewResolve().
 33525: 
 33525:     return NS_OK;
 33525:   }
 33525: 
 47537:   return GetContextInternal()->SetProperty(mJSObject, "arguments", aArguments);
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsIScriptObjectPrincipal
     1: //*****************************************************************************
     1: 
     1: nsIPrincipal*
     1: nsGlobalWindow::GetPrincipal()
     1: {
     1:   if (mDoc) {
     1:     // If we have a document, get the principal from the document
     1:     return mDoc->NodePrincipal();
     1:   }
     1: 
     1:   if (mDocumentPrincipal) {
     1:     return mDocumentPrincipal;
     1:   }
     1: 
     1:   // If we don't have a principal and we don't have a document we
     1:   // ask the parent window for the principal. This can happen when
     1:   // loading a frameset that has a <frame src="javascript:xxx">, in
     1:   // that case the global window is used in JS before we've loaded
     1:   // a document into the window.
     1: 
     1:   nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
     1:     do_QueryInterface(GetParentInternal());
     1: 
     1:   if (objPrincipal) {
     1:     return objPrincipal->GetPrincipal();
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsIDOMWindow
     1: //*****************************************************************************
     1: 
107468: void
107468: nsPIDOMWindow::MaybeCreateDoc()
107468: {
107468:   MOZ_ASSERT(!mDoc);
107468:   if (nsIDocShell* docShell = GetDocShell()) {
107468:     // Note that |document| here is the same thing as our mDocument, but we
107468:     // don't have to explicitly set the member variable because the docshell
107468:     // has already called SetNewDocument().
107468:     nsCOMPtr<nsIDocument> document = do_GetInterface(docShell);
107468:   }
107468: }
107468: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetDocument(nsIDOMDocument** aDocument)
     1: {
107468:   nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(GetDoc());
107468:   document.forget(aDocument);
     1:   return NS_OK;
     1: }
     1: 
 73870: NS_IMETHODIMP
 73870: nsGlobalWindow::GetWindow(nsIDOMWindow** aWindow)
     1: {
     1:   FORWARD_TO_OUTER(GetWindow, (aWindow), NS_ERROR_NOT_INITIALIZED);
     1: 
 73870:   *aWindow = static_cast<nsIDOMWindow*>(this);
     1:   NS_ADDREF(*aWindow);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 73870: nsGlobalWindow::GetSelf(nsIDOMWindow** aWindow)
     1: {
     1:   FORWARD_TO_OUTER(GetSelf, (aWindow), NS_ERROR_NOT_INITIALIZED);
     1: 
 73870:   *aWindow = static_cast<nsIDOMWindow*>(this);
     1:   NS_ADDREF(*aWindow);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetNavigator(nsIDOMNavigator** aNavigator)
     1: {
 83058:   FORWARD_TO_INNER(GetNavigator, (aNavigator), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aNavigator = nullptr;
     1: 
     1:   if (!mNavigator) {
 83058:     mNavigator = new Navigator(this);
     1:   }
     1: 
     1:   NS_ADDREF(*aNavigator = mNavigator);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetScreen(nsIDOMScreen** aScreen)
     1: {
 93484:   FORWARD_TO_INNER(GetScreen, (aScreen), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aScreen = nullptr;
     1: 
     1:   if (!mScreen) {
 93484:     mScreen = nsScreen::Create(this);
 93484:     if (!mScreen) {
 93484:       return NS_ERROR_UNEXPECTED;
     1:     }
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aScreen = mScreen);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetHistory(nsIDOMHistory** aHistory)
     1: {
 61735:   FORWARD_TO_INNER(GetHistory, (aHistory), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aHistory = nullptr;
     1: 
 61735:   if (!mHistory) {
 61735:     mHistory = new nsHistory(this);
     1:     if (!mHistory) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aHistory = mHistory);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
105530: nsGlobalWindow::GetPerformance(nsISupports** aPerformance)
 72298: {
 72298:   FORWARD_TO_INNER(GetPerformance, (aPerformance), NS_ERROR_NOT_INITIALIZED);
 72298: 
106838:   *aPerformance = nullptr;
 72298: 
 72298:   if (nsGlobalWindow::HasPerformanceSupport()) {
107922:     CreatePerformanceObjectIfNeeded();
107922:     NS_IF_ADDREF(*aPerformance = mPerformance);
107922:   }
107922:   return NS_OK;
107922: }
107922: 
107922: void
107922: nsGlobalWindow::CreatePerformanceObjectIfNeeded()
107922: {
107922:   if (mPerformance || !mDoc) {
107922:     return;
 72523:   }
 72298:   nsRefPtr<nsDOMNavigationTiming> timing = mDoc->GetNavigationTiming();
 72986:   nsCOMPtr<nsITimedChannel> timedChannel(do_QueryInterface(mDoc->GetChannel()));
 79445:   bool timingEnabled = false;
 72986:   if (!timedChannel ||
 72986:       !NS_SUCCEEDED(timedChannel->GetTimingEnabled(&timingEnabled)) ||
 72986:       !timingEnabled) {
106838:     timedChannel = nullptr;
 72986:   }
 72298:   if (timing) {
105502:     mPerformance = new nsPerformance(this, timing, timedChannel);
 72298:   }
 72298: }
 72298: 
 99222: /**
 99222:  * GetScriptableParent is called when script reads window.parent.
 99222:  *
 99222:  * In contrast to GetRealParent, GetScriptableParent respects <iframe
 99222:  * mozbrowser> boundaries, so if |this| is contained by an <iframe
 99222:  * mozbrowser>, we will return |this| as its own parent.
 99222:  */
 99222: NS_IMETHODIMP
 99222: nsGlobalWindow::GetScriptableParent(nsIDOMWindow** aParent)
 99222: {
 99222:   FORWARD_TO_OUTER(GetScriptableParent, (aParent), NS_ERROR_NOT_INITIALIZED);
 99222: 
 99222:   *aParent = NULL;
 99222:   if (!mDocShell) {
 99222:     return NS_OK;
 99222:   }
 99222: 
109100:   if (mDocShell->GetIsContentBoundary()) {
 99222:     nsCOMPtr<nsIDOMWindow> parent = static_cast<nsIDOMWindow*>(this);
 99222:     parent.swap(*aParent);
 99222:     return NS_OK;
 99222:   }
 99222: 
 99222:   return GetRealParent(aParent);
 99222: }
 99222: 
 99222: /**
 99222:  * nsIDOMWindow::GetParent (when called from C++) is just a wrapper around
 99222:  * GetRealParent.
 99222:  */
 99222: NS_IMETHODIMP
 99222: nsGlobalWindow::GetRealParent(nsIDOMWindow** aParent)
 99222: {
 99222:   FORWARD_TO_OUTER(GetRealParent, (aParent), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aParent = nullptr;
 99222:   if (!mDocShell) {
 99222:     return NS_OK;
 99222:   }
     1: 
106198:   nsCOMPtr<nsIDocShell> parent;
106198:   mDocShell->GetParentIgnoreBrowserFrame(getter_AddRefs(parent));
     1: 
     1:   if (parent) {
     1:     nsCOMPtr<nsIScriptGlobalObject> globalObject(do_GetInterface(parent));
     1:     NS_ENSURE_SUCCESS(CallQueryInterface(globalObject.get(), aParent),
     1:                       NS_ERROR_FAILURE);
     1:   }
     1:   else {
 73870:     *aParent = static_cast<nsIDOMWindow*>(this);
     1:     NS_ADDREF(*aParent);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 99222: /**
 99222:  * GetScriptableTop is called when script reads window.top.
 99222:  *
 99222:  * In contrast to GetRealTop, GetScriptableTop respects <iframe mozbrowser>
 99222:  * boundaries.  If we encounter a window owned by an <iframe mozbrowser> while
 99222:  * walking up the window hierarchy, we'll stop and return that window.
 99222:  */
 99222: NS_IMETHODIMP
 99222: nsGlobalWindow::GetScriptableTop(nsIDOMWindow **aTop)
 99222: {
 99222:   return GetTopImpl(aTop, /* aScriptable = */ true);
 99222: }
 99222: 
 99222: /**
 99222:  * nsIDOMWindow::GetTop (when called from C++) is just a wrapper around
 99222:  * GetRealTop.
 99222:  */
 99222: NS_IMETHODIMP
 99222: nsGlobalWindow::GetRealTop(nsIDOMWindow** aTop)
 99222: {
 99222:   return GetTopImpl(aTop, /* aScriptable = */ false);
 99222: }
 99222: 
 99222: nsresult
 99222: nsGlobalWindow::GetTopImpl(nsIDOMWindow** aTop, bool aScriptable)
 99222: {
 99222:   FORWARD_TO_OUTER(GetTopImpl, (aTop, aScriptable), NS_ERROR_NOT_INITIALIZED);
106838:   *aTop = nullptr;
 99222: 
 99222:   // Walk up the parent chain.
 99222: 
 99222:   nsCOMPtr<nsIDOMWindow> prevParent = this;
 99222:   nsCOMPtr<nsIDOMWindow> parent = this;
 99222:   do {
 99222:     if (!parent) {
 99222:       break;
 99222:     }
 99222: 
 99222:     prevParent = parent;
 99222: 
 99222:     nsCOMPtr<nsIDOMWindow> newParent;
 99222:     nsresult rv;
 99222:     if (aScriptable) {
 99222:       rv = parent->GetScriptableParent(getter_AddRefs(newParent));
 99222:     }
 99222:     else {
 99222:       rv = parent->GetParent(getter_AddRefs(newParent));
 99222:     }
 99222:     NS_ENSURE_SUCCESS(rv, rv);
 99222: 
 99222:     parent = newParent;
 99222: 
 99222:   } while (parent != prevParent);
 99222: 
 99222:   if (parent) {
 99222:     parent.swap(*aTop);
 54231:   }
 54231: 
 54231:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetContent(nsIDOMWindow** aContent)
     1: {
     1:   FORWARD_TO_OUTER(GetContent, (aContent), NS_ERROR_NOT_INITIALIZED);
106838:   *aContent = nullptr;
     1: 
106198:   // If we're contained in <iframe mozbrowser>, then GetContent is the same as
106198:   // window.top.
109100:   if (mDocShell && mDocShell->GetIsBelowContentBoundary()) {
106198:     return GetScriptableTop(aContent);
106198:   }
106198: 
     1:   nsCOMPtr<nsIDocShellTreeItem> primaryContent;
     1:   if (!nsContentUtils::IsCallerChrome()) {
     1:     // If we're called by non-chrome code, make sure we don't return
     1:     // the primary content window if the calling tab is hidden. In
     1:     // such a case we return the same-type root in the hidden tab,
     1:     // which is "good enough", for now.
     1:     nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(mDocShell));
     1: 
     1:     if (baseWin) {
 79445:       bool visible = false;
     1:       baseWin->GetVisibility(&visible);
     1: 
     1:       if (!visible) {
     1:         nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
     1:         treeItem->GetSameTypeRootTreeItem(getter_AddRefs(primaryContent));
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (!primaryContent) {
     1:     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
     1:     GetTreeOwner(getter_AddRefs(treeOwner));
     1:     NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
     1: 
     1:     treeOwner->GetPrimaryContentShell(getter_AddRefs(primaryContent));
     1:   }
     1: 
 73870:   nsCOMPtr<nsIDOMWindow> domWindow(do_GetInterface(primaryContent));
107853:   domWindow.forget(aContent);
     1: 
     1:   return NS_OK;
     1: }
     1: 
106198: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetPrompter(nsIPrompt** aPrompt)
     1: {
     1:   FORWARD_TO_OUTER(GetPrompter, (aPrompt), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (!mDocShell)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIPrompt> prompter(do_GetInterface(mDocShell));
     1:   NS_ENSURE_TRUE(prompter, NS_ERROR_NO_INTERFACE);
     1: 
     1:   NS_ADDREF(*aPrompt = prompter);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetMenubar(nsIDOMBarProp** aMenubar)
     1: {
     1:   FORWARD_TO_OUTER(GetMenubar, (aMenubar), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aMenubar = nullptr;
     1: 
     1:   if (!mMenubar) {
 69041:     mMenubar = new nsMenubarProp(this);
     1:     if (!mMenubar) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aMenubar = mMenubar);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetToolbar(nsIDOMBarProp** aToolbar)
     1: {
     1:   FORWARD_TO_OUTER(GetToolbar, (aToolbar), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aToolbar = nullptr;
     1: 
     1:   if (!mToolbar) {
 69041:     mToolbar = new nsToolbarProp(this);
     1:     if (!mToolbar) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aToolbar = mToolbar);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetLocationbar(nsIDOMBarProp** aLocationbar)
     1: {
     1:   FORWARD_TO_OUTER(GetLocationbar, (aLocationbar), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aLocationbar = nullptr;
     1: 
     1:   if (!mLocationbar) {
 69041:     mLocationbar = new nsLocationbarProp(this);
     1:     if (!mLocationbar) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aLocationbar = mLocationbar);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetPersonalbar(nsIDOMBarProp** aPersonalbar)
     1: {
     1:   FORWARD_TO_OUTER(GetPersonalbar, (aPersonalbar), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aPersonalbar = nullptr;
     1: 
     1:   if (!mPersonalbar) {
 69041:     mPersonalbar = new nsPersonalbarProp(this);
     1:     if (!mPersonalbar) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aPersonalbar = mPersonalbar);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetStatusbar(nsIDOMBarProp** aStatusbar)
     1: {
     1:   FORWARD_TO_OUTER(GetStatusbar, (aStatusbar), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aStatusbar = nullptr;
     1: 
     1:   if (!mStatusbar) {
 69041:     mStatusbar = new nsStatusbarProp(this);
     1:     if (!mStatusbar) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aStatusbar = mStatusbar);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetScrollbars(nsIDOMBarProp** aScrollbars)
     1: {
     1:   FORWARD_TO_OUTER(GetScrollbars, (aScrollbars), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aScrollbars = nullptr;
     1: 
     1:   if (!mScrollbars) {
     1:     mScrollbars = new nsScrollbarsProp(this);
     1:     if (!mScrollbars) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aScrollbars = mScrollbars);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::GetClosed(bool* aClosed)
     1: {
     1:   FORWARD_TO_OUTER(GetClosed, (aClosed), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   // If someone called close(), or if we don't have a docshell, we're
     1:   // closed.
     1:   *aClosed = mIsClosed || !mDocShell;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetFrames(nsIDOMWindowCollection** aFrames)
     1: {
     1:   FORWARD_TO_OUTER(GetFrames, (aFrames), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aFrames = nullptr;
     1: 
     1:   if (!mFrames && mDocShell) {
     1:     mFrames = new nsDOMWindowList(mDocShell);
     1:     if (!mFrames) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
  3233:   *aFrames = static_cast<nsIDOMWindowCollection *>(mFrames);
     1:   NS_IF_ADDREF(*aFrames);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 10340: nsGlobalWindow::GetApplicationCache(nsIDOMOfflineResourceList **aApplicationCache)
 10340: {
 10340:   FORWARD_TO_INNER(GetApplicationCache, (aApplicationCache), NS_ERROR_UNEXPECTED);
 10340: 
 10340:   NS_ENSURE_ARG_POINTER(aApplicationCache);
 10340: 
 10340:   if (!mApplicationCache) {
 10340:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(GetDocShell()));
 10340:     if (!webNav) {
 10340:       return NS_ERROR_FAILURE;
 10340:     }
 10340: 
 10340:     nsCOMPtr<nsIURI> uri;
 10340:     nsresult rv = webNav->GetCurrentURI(getter_AddRefs(uri));
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 21366:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
 10340:     nsCOMPtr<nsIURI> manifestURI;
 21366:     nsContentUtils::GetOfflineAppManifest(doc, getter_AddRefs(manifestURI));
 10340: 
 29226:     nsRefPtr<nsDOMOfflineResourceList> applicationCache =
 92083:       new nsDOMOfflineResourceList(manifestURI, uri, this);
 29226:     NS_ENSURE_TRUE(applicationCache, NS_ERROR_OUT_OF_MEMORY);
 29226: 
 29226:     applicationCache->Init();
 10340: 
 10340:     mApplicationCache = applicationCache;
 10340:   }
 10340: 
 10340:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
 10340: 
 10340:   return NS_OK;
 10340: }
 10340: 
 10340: NS_IMETHODIMP
     1: nsGlobalWindow::GetCrypto(nsIDOMCrypto** aCrypto)
     1: {
 54925: #ifdef MOZ_DISABLE_DOMCRYPTO
 54925:   return NS_ERROR_NOT_IMPLEMENTED;
 54925: #else
     1:   FORWARD_TO_OUTER(GetCrypto, (aCrypto), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (!mCrypto) {
     1:     mCrypto = do_CreateInstance(kCryptoContractID);
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aCrypto = mCrypto);
     1: 
     1:   return NS_OK;
 54925: #endif
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetPkcs11(nsIDOMPkcs11** aPkcs11)
     1: {
106838:   *aPkcs11 = nullptr;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetControllers(nsIControllers** aResult)
     1: {
     1:   FORWARD_TO_OUTER(GetControllers, (aResult), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (!mControllers) {
     1:     nsresult rv;
     1:     mControllers = do_CreateInstance(kXULControllersCID, &rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Add in the default controller
     1:     nsCOMPtr<nsIController> controller = do_CreateInstance(
     1:                                NS_WINDOWCONTROLLER_CONTRACTID, &rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     
     1:     mControllers->InsertControllerAt(0, controller);
     1:     nsCOMPtr<nsIControllerContext> controllerContext = do_QueryInterface(controller);
     1:     if (!controllerContext) return NS_ERROR_FAILURE;
     1: 
  3233:     controllerContext->SetCommandContext(static_cast<nsIDOMWindow*>(this));
     1:   }
     1: 
     1:   *aResult = mControllers;
     1:   NS_ADDREF(*aResult);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 73870: nsGlobalWindow::GetOpener(nsIDOMWindow** aOpener)
     1: {
     1:   FORWARD_TO_OUTER(GetOpener, (aOpener), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aOpener = nullptr;
 11416: 
 34496:   nsCOMPtr<nsPIDOMWindow> opener = do_QueryReferent(mOpener);
 11416:   if (!opener) {
 11416:     return NS_OK;
 11416:   }
 11416: 
     1:   // First, check if we were called from a privileged chrome script
     1:   if (nsContentUtils::IsCallerTrustedForRead()) {
 11416:     NS_ADDREF(*aOpener = opener);
     1:     return NS_OK;
     1:   }
     1: 
 34496:   nsCOMPtr<nsPIDOMWindow> openerPwin(do_QueryInterface(opener));
 34496:   if (!openerPwin) {
 34496:     return NS_OK;
 34496:   }
 34496: 
 34496:   // First, ensure that we're not handing back a chrome window.
 34496:   nsGlobalWindow *win = static_cast<nsGlobalWindow *>(openerPwin.get());
 34496:   if (win->IsChromeWindow()) {
 34496:     return NS_OK;
 34496:   }
 34496: 
     1:   // We don't want to reveal the opener if the opener is a mail window,
     1:   // because opener can be used to spoof the contents of a message (bug 105050).
     1:   // So, we look in the opener's root docshell to see if it's a mail window.
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
     1:     do_QueryInterface(openerPwin->GetDocShell());
     1: 
     1:   if (docShellAsItem) {
     1:     nsCOMPtr<nsIDocShellTreeItem> openerRootItem;
     1:     docShellAsItem->GetRootTreeItem(getter_AddRefs(openerRootItem));
     1:     nsCOMPtr<nsIDocShell> openerRootDocShell(do_QueryInterface(openerRootItem));
     1:     if (openerRootDocShell) {
108991:       uint32_t appType;
     1:       nsresult rv = openerRootDocShell->GetAppType(&appType);
     1:       if (NS_SUCCEEDED(rv) && appType != nsIDocShell::APP_TYPE_MAIL) {
 11416:         *aOpener = opener;
     1:       }
     1:     }
     1:   }
 34496: 
     1:   NS_IF_ADDREF(*aOpener);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 73870: nsGlobalWindow::SetOpener(nsIDOMWindow* aOpener)
     1: {
     1:   // check if we were called from a privileged chrome script.
     1:   // If not, opener is settable only to null.
     1:   if (aOpener && !nsContentUtils::IsCallerTrustedForWrite()) {
     1:     return NS_OK;
     1:   }
     1: 
 80486:   SetOpenerWindow(aOpener, false);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetStatus(nsAString& aStatus)
     1: {
     1:   FORWARD_TO_OUTER(GetStatus, (aStatus), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   aStatus = mStatus;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::SetStatus(const nsAString& aStatus)
     1: {
     1:   FORWARD_TO_OUTER(SetStatus, (aStatus), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
     1:    * If caller is not chrome and dom.disable_window_status_change is true,
     1:    * prevent setting window.status by exiting early
     1:    */
     1: 
     1:   if (!CanSetProperty("dom.disable_window_status_change")) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   mStatus = aStatus;
     1: 
     1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
     1:   GetWebBrowserChrome(getter_AddRefs(browserChrome));
     1:   if(browserChrome) {
     1:     browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT,
     1:                              PromiseFlatString(aStatus).get());
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetDefaultStatus(nsAString& aDefaultStatus)
     1: {
     1:   FORWARD_TO_OUTER(GetDefaultStatus, (aDefaultStatus),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   aDefaultStatus = mDefaultStatus;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::SetDefaultStatus(const nsAString& aDefaultStatus)
     1: {
     1:   FORWARD_TO_OUTER(SetDefaultStatus, (aDefaultStatus),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
     1:    * If caller is not chrome and dom.disable_window_status_change is true,
     1:    * prevent setting window.defaultStatus by exiting early
     1:    */
     1: 
     1:   if (!CanSetProperty("dom.disable_window_status_change")) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   mDefaultStatus = aDefaultStatus;
     1: 
     1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
     1:   GetWebBrowserChrome(getter_AddRefs(browserChrome));
     1:   if (browserChrome) {
     1:     browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT_DEFAULT,
     1:                              PromiseFlatString(aDefaultStatus).get());
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetName(nsAString& aName)
     1: {
     1:   FORWARD_TO_OUTER(GetName, (aName), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsXPIDLString name;
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
     1:   if (docShellAsItem)
     1:     docShellAsItem->GetName(getter_Copies(name));
     1: 
     1:   aName.Assign(name);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::SetName(const nsAString& aName)
     1: {
     1:   FORWARD_TO_OUTER(SetName, (aName), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsresult result = NS_OK;
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
     1:   if (docShellAsItem)
     1:     result = docShellAsItem->SetName(PromiseFlatString(aName).get());
     1:   return result;
     1: }
     1: 
 24816: // Helper functions used by many methods below.
108991: int32_t
108991: nsGlobalWindow::DevToCSSIntPixels(int32_t px)
 24816: {
 24816:   if (!mDocShell)
 24816:     return px; // assume 1:1
 24816: 
 39823:   nsRefPtr<nsPresContext> presContext;
 24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 24816:   if (!presContext)
 24816:     return px;
 24816: 
 29322:   return presContext->DevPixelsToIntCSSPixels(px);
 24816: }
 24816: 
108991: int32_t
108991: nsGlobalWindow::CSSToDevIntPixels(int32_t px)
 24816: {
 24816:   if (!mDocShell)
 24816:     return px; // assume 1:1
 24816: 
 39823:   nsRefPtr<nsPresContext> presContext;
 24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 24816:   if (!presContext)
 24816:     return px;
 24816: 
 29322:   return presContext->CSSPixelsToDevPixels(px);
 24816: }
 24816: 
 24816: nsIntSize
 24816: nsGlobalWindow::DevToCSSIntPixels(nsIntSize px)
 24816: {
 24816:   if (!mDocShell)
 24816:     return px; // assume 1:1
 24816: 
 39823:   nsRefPtr<nsPresContext> presContext;
 24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 24816:   if (!presContext)
 24816:     return px;
 24816: 
 24816:   return nsIntSize(
 29322:       presContext->DevPixelsToIntCSSPixels(px.width),
 29322:       presContext->DevPixelsToIntCSSPixels(px.height));
 24816: }
 24816: 
 24816: nsIntSize
 24816: nsGlobalWindow::CSSToDevIntPixels(nsIntSize px)
 24816: {
 24816:   if (!mDocShell)
 24816:     return px; // assume 1:1
 24816: 
 39823:   nsRefPtr<nsPresContext> presContext;
 24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 24816:   if (!presContext)
 24816:     return px;
 24816: 
 24816:   return nsIntSize(
 29322:     presContext->CSSPixelsToDevPixels(px.width),
 29322:     presContext->CSSPixelsToDevPixels(px.height));
 24816: }
 24816: 
 24816: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetInnerWidth(int32_t* aInnerWidth)
     1: {
     1:   FORWARD_TO_OUTER(GetInnerWidth, (aInnerWidth), NS_ERROR_NOT_INITIALIZED);
     1: 
   334:   NS_ENSURE_STATE(mDocShell);
   334: 
     1:   EnsureSizeUpToDate();
     1: 
 39823:   nsRefPtr<nsPresContext> presContext;
 28807:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 28807: 
 59572:   if (presContext) {
 59572:     nsRect shellArea = presContext->GetVisibleArea();
 59572:     *aInnerWidth = nsPresContext::AppUnitsToIntCSSPixels(shellArea.width);
 28807:   } else {
 28807:     *aInnerWidth = 0;
 28807:   }
 28807: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::SetInnerWidth(int32_t aInnerWidth)
     1: {
     1:   FORWARD_TO_OUTER(SetInnerWidth, (aInnerWidth), NS_ERROR_NOT_INITIALIZED);
     1: 
   334:   NS_ENSURE_STATE(mDocShell);
   334: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent setting window.innerWidth by exiting early
     1:    */
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
106838:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&aInnerWidth, nullptr),
     1:                     NS_ERROR_FAILURE);
     1: 
 59572: 
 59572:   nsRefPtr<nsIPresShell> presShell;
 59572:   mDocShell->GetPresShell(getter_AddRefs(presShell));
 64531: 
 64531:   if (presShell && presShell->GetIsViewportOverridden())
 59572:   {
 59572:     nscoord height = 0;
 59572:     nscoord width  = 0;
 59572: 
 59572:     nsRefPtr<nsPresContext> presContext;
 59572:     presContext = presShell->GetPresContext();
 59572: 
 59572:     nsRect shellArea = presContext->GetVisibleArea();
 59572:     height = shellArea.height;
 59572:     width  = nsPresContext::CSSPixelsToAppUnits(aInnerWidth);
 59572:     return SetCSSViewportWidthAndHeight(width, height);
 59572:   }
 59572:   else
 59572:   {
108991:     int32_t height = 0;
108991:     int32_t width  = 0;
   334: 
     1:     nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
 59572:     docShellAsWin->GetSize(&width, &height);
 59572:     width  = CSSToDevIntPixels(aInnerWidth);
 59572:     return SetDocShellWidthAndHeight(width, height);
 59572:   }
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetInnerHeight(int32_t* aInnerHeight)
     1: {
     1:   FORWARD_TO_OUTER(GetInnerHeight, (aInnerHeight), NS_ERROR_NOT_INITIALIZED);
     1: 
   334:   NS_ENSURE_STATE(mDocShell);
   334: 
     1:   EnsureSizeUpToDate();
     1: 
 39823:   nsRefPtr<nsPresContext> presContext;
 28807:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 28807: 
 59572:   if (presContext) {
 59572:     nsRect shellArea = presContext->GetVisibleArea();
 59572:     *aInnerHeight = nsPresContext::AppUnitsToIntCSSPixels(shellArea.height);
 28807:   } else {
 28807:     *aInnerHeight = 0;
 28807:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::SetInnerHeight(int32_t aInnerHeight)
     1: {
     1:   FORWARD_TO_OUTER(SetInnerHeight, (aInnerHeight), NS_ERROR_NOT_INITIALIZED);
     1: 
   334:   NS_ENSURE_STATE(mDocShell);
   334: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent setting window.innerHeight by exiting early
     1:    */
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
106838:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(nullptr, &aInnerHeight),
     1:                     NS_ERROR_FAILURE);
     1: 
 59572:   nsRefPtr<nsIPresShell> presShell;
 59572:   mDocShell->GetPresShell(getter_AddRefs(presShell));
 64531: 
 64531:   if (presShell && presShell->GetIsViewportOverridden())
 59572:   {
 59572:     nscoord height = 0;
 59572:     nscoord width  = 0;
 59572: 
 59572:     nsRefPtr<nsPresContext> presContext;
 59572:     presContext = presShell->GetPresContext();
 59572: 
 59572:     nsRect shellArea = presContext->GetVisibleArea();
 59572:     width = shellArea.width;
 59572:     height  = nsPresContext::CSSPixelsToAppUnits(aInnerHeight);
 59572:     return SetCSSViewportWidthAndHeight(width, height);
 59572:   }
 59572:   else
 59572:   {
108991:     int32_t height = 0;
108991:     int32_t width  = 0;
   334: 
     1:     nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
 59572:     docShellAsWin->GetSize(&width, &height);
 59572:     height  = CSSToDevIntPixels(aInnerHeight);
 59572:     return SetDocShellWidthAndHeight(width, height);
 59572:   }
     1: }
     1: 
 13806: nsresult
 13806: nsGlobalWindow::GetOuterSize(nsIntSize* aSizeCSSPixels)
 13806: {
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
     1:   nsGlobalWindow* rootWindow =
  3233:     static_cast<nsGlobalWindow *>(GetPrivateRoot());
     1:   if (rootWindow) {
     1:     rootWindow->FlushPendingNotifications(Flush_Layout);
     1:   }
 13806: 
 13806:   nsIntSize sizeDevPixels;
 13806:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&sizeDevPixels.width,
 13806:                                             &sizeDevPixels.height),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   *aSizeCSSPixels = DevToCSSIntPixels(sizeDevPixels);
 13806:   return NS_OK;
 13806: }
 13806: 
 13806: NS_IMETHODIMP
108991: nsGlobalWindow::GetOuterWidth(int32_t* aOuterWidth)
 13806: {
 13806:   FORWARD_TO_OUTER(GetOuterWidth, (aOuterWidth), NS_ERROR_NOT_INITIALIZED);
 13806: 
 13806:   nsIntSize sizeCSSPixels;
 13806:   nsresult rv = GetOuterSize(&sizeCSSPixels);
 13806:   NS_ENSURE_SUCCESS(rv, rv);
 13806: 
 13806:   *aOuterWidth = sizeCSSPixels.width;
 13806:   return NS_OK;
 13806: }
 13806: 
 13806: NS_IMETHODIMP
108991: nsGlobalWindow::GetOuterHeight(int32_t* aOuterHeight)
 13806: {
 13806:   FORWARD_TO_OUTER(GetOuterHeight, (aOuterHeight), NS_ERROR_NOT_INITIALIZED);
 13806: 
 13806:   nsIntSize sizeCSSPixels;
 13806:   nsresult rv = GetOuterSize(&sizeCSSPixels);
 13806:   NS_ENSURE_SUCCESS(rv, rv);
 13806: 
 13806:   *aOuterHeight = sizeCSSPixels.height;
 13806:   return NS_OK;
 13806: }
 13806: 
 13806: nsresult
108991: nsGlobalWindow::SetOuterSize(int32_t aLengthCSSPixels, bool aIsWidth)
 13806: {
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent setting window.outerWidth by exiting early
     1:    */
     1: 
 30667:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
 13806:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(
106838:                         aIsWidth ? &aLengthCSSPixels : nullptr,
106838:                         aIsWidth ? nullptr : &aLengthCSSPixels),
     1:                     NS_ERROR_FAILURE);
     1: 
108991:   int32_t width, height;
 13806:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&width, &height), NS_ERROR_FAILURE);
 13806: 
108991:   int32_t lengthDevPixels = CSSToDevIntPixels(aLengthCSSPixels);
 13806:   if (aIsWidth) {
 13806:     width = lengthDevPixels;
 13806:   } else {
 13806:     height = lengthDevPixels;
 13806:   }
 80486:   return treeOwnerAsWin->SetSize(width, height, true);    
 13806: }
 13806: 
 13806: NS_IMETHODIMP
108991: nsGlobalWindow::SetOuterWidth(int32_t aOuterWidth)
 13806: {
 13806:   FORWARD_TO_OUTER(SetOuterWidth, (aOuterWidth), NS_ERROR_NOT_INITIALIZED);
 13806: 
 80486:   return SetOuterSize(aOuterWidth, true);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::SetOuterHeight(int32_t aOuterHeight)
     1: {
     1:   FORWARD_TO_OUTER(SetOuterHeight, (aOuterHeight), NS_ERROR_NOT_INITIALIZED);
     1: 
 80486:   return SetOuterSize(aOuterHeight, false);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetScreenX(int32_t* aScreenX)
     1: {
     1:   FORWARD_TO_OUTER(GetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
108991:   int32_t x, y;
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   *aScreenX = DevToCSSIntPixels(x);
     1:   return NS_OK;
     1: }
     1: 
 30882: nsRect
 30882: nsGlobalWindow::GetInnerScreenRect()
 30882: {
 30882:   if (!mDocShell)
 30882:     return nsRect();
 30882: 
 30882:   nsGlobalWindow* rootWindow =
 30882:     static_cast<nsGlobalWindow*>(GetPrivateRoot());
 30882:   if (rootWindow) {
 30882:     rootWindow->FlushPendingNotifications(Flush_Layout);
 30882:   }
 30882: 
 30882:   nsCOMPtr<nsIPresShell> presShell;
 30882:   mDocShell->GetPresShell(getter_AddRefs(presShell));
 30882:   if (!presShell)
 30882:     return nsRect();
 30882:   nsIFrame* rootFrame = presShell->GetRootFrame();
 30882:   if (!rootFrame)
 30882:     return nsRect();
 30882: 
 30882:   return rootFrame->GetScreenRectInAppUnits();
 30882: }
 30882: 
 30882: NS_IMETHODIMP
 30882: nsGlobalWindow::GetMozInnerScreenX(float* aScreenX)
 30882: {
 30882:   FORWARD_TO_OUTER(GetMozInnerScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
 30882: 
 30882:   nsRect r = GetInnerScreenRect();
 30882:   *aScreenX = nsPresContext::AppUnitsToFloatCSSPixels(r.x);
 30882:   return NS_OK;
 30882: }
 30882: 
 30882: NS_IMETHODIMP
 30882: nsGlobalWindow::GetMozInnerScreenY(float* aScreenY)
 30882: {
 30882:   FORWARD_TO_OUTER(GetMozInnerScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
 30882: 
 30882:   nsRect r = GetInnerScreenRect();
 30882:   *aScreenY = nsPresContext::AppUnitsToFloatCSSPixels(r.y);
 30882:   return NS_OK;
 30882: }
 30882: 
 30882: NS_IMETHODIMP
108991: nsGlobalWindow::GetMozPaintCount(uint64_t* aResult)
 42240: {
 42240:   FORWARD_TO_OUTER(GetMozPaintCount, (aResult), NS_ERROR_NOT_INITIALIZED);
 42240: 
 42240:   *aResult = 0;
 42240: 
 42240:   if (!mDocShell)
 42240:     return NS_OK;
 42240: 
 42240:   nsCOMPtr<nsIPresShell> presShell;
 42240:   mDocShell->GetPresShell(getter_AddRefs(presShell));
 42240:   if (!presShell)
 42240:     return NS_OK;
 42240: 
 42240:   *aResult = presShell->GetPaintCount();
 42240:   return NS_OK;
 42240: }
 42240: 
 42240: NS_IMETHODIMP
 84132: nsGlobalWindow::MozRequestAnimationFrame(nsIFrameRequestCallback* aCallback,
108991:                                          int32_t *aHandle)
 84132: {
 84132:   FORWARD_TO_INNER(MozRequestAnimationFrame, (aCallback, aHandle),
 52255:                    NS_ERROR_NOT_INITIALIZED);
 50368: 
 50368:   if (!mDoc) {
 50368:     return NS_OK;
 50368:   }
 50368: 
 83087:   if (!aCallback) {
 84627:     mDoc->WarnOnceAbout(nsIDocument::eMozBeforePaint);
 83087:     return NS_ERROR_XPC_BAD_CONVERT_JS;
 83087:   }
 83087: 
 98147:   if (mJSObject)
 98147:     js::NotifyAnimationActivity(mJSObject);
 98147: 
 84132:   return mDoc->ScheduleFrameRequestCallback(aCallback, aHandle);
 50368: }
 50368: 
 50368: NS_IMETHODIMP
108991: nsGlobalWindow::MozCancelRequestAnimationFrame(int32_t aHandle)
 84133: {
 84628:   return MozCancelAnimationFrame(aHandle);
 84628: }
 84628: 
 84628: NS_IMETHODIMP
108991: nsGlobalWindow::MozCancelAnimationFrame(int32_t aHandle)
 84628: {
 84628:   FORWARD_TO_INNER(MozCancelAnimationFrame, (aHandle),
 84133:                    NS_ERROR_NOT_INITIALIZED);
 84133: 
 84133:   if (!mDoc) {
 84133:     return NS_OK;
 84133:   }
 84133: 
 84133:   mDoc->CancelFrameRequestCallback(aHandle);
 84133:   return NS_OK;
 84133: }
 84133: 
 84133: NS_IMETHODIMP
108991: nsGlobalWindow::GetMozAnimationStartTime(int64_t *aTime)
 50368: {
 50368:   FORWARD_TO_INNER(GetMozAnimationStartTime, (aTime), NS_ERROR_NOT_INITIALIZED);
 50368: 
 50368:   if (mDoc) {
 50368:     nsIPresShell* presShell = mDoc->GetShell();
 50368:     if (presShell) {
 50368:       *aTime = presShell->GetPresContext()->RefreshDriver()->
 50368:         MostRecentRefreshEpochTime() / PR_USEC_PER_MSEC;
 50368:       return NS_OK;
 50368:     }
 50368:   }
 50368: 
 50368:   // If all else fails, just be compatible with Date.now()
 50368:   *aTime = JS_Now() / PR_USEC_PER_MSEC;
 50368:   return NS_OK;
 50368: }
 50368: 
 50368: NS_IMETHODIMP
 68769: nsGlobalWindow::MatchMedia(const nsAString& aMediaQueryList,
 68769:                            nsIDOMMediaQueryList** aResult)
 68769: {
 68769:   // FIXME: This whole forward-to-outer and then get a pres
 68769:   // shell/context off the docshell dance is sort of silly; it'd make
 68769:   // more sense to forward to the inner, but it's what everyone else
 68769:   // (GetSelection, GetScrollXY, etc.) does around here.
 68769:   FORWARD_TO_OUTER(MatchMedia, (aMediaQueryList, aResult),
 68769:                    NS_ERROR_NOT_INITIALIZED);
 68769: 
106838:   *aResult = nullptr;
 68769: 
103921:   // We need this now to ensure that we have a non-null |presContext|
103921:   // when we ought to.
103921:   // This is similar to EnsureSizeUpToDate, but only flushes frames.
103921:   nsGlobalWindow *parent = static_cast<nsGlobalWindow*>(GetPrivateParent());
103921:   if (parent) {
103921:     parent->FlushPendingNotifications(Flush_Frames);
103921:   }
103921: 
 68769:   if (!mDocShell)
 68769:     return NS_OK;
 68769: 
 68769:   nsRefPtr<nsPresContext> presContext;
 68769:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 68769: 
 68769:   if (!presContext)
 68769:     return NS_OK;
 68769: 
 68769:   presContext->MatchMedia(aMediaQueryList, aResult);
 68769:   return NS_OK;
 68769: }
 68769: 
 68769: NS_IMETHODIMP
108991: nsGlobalWindow::SetScreenX(int32_t aScreenX)
     1: {
     1:   FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent setting window.screenX by exiting early
     1:    */
     1: 
 30667:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
106838:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nullptr),
     1:                     NS_ERROR_FAILURE);
     1: 
108991:   int32_t x, y;
     1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   x = CSSToDevIntPixels(aScreenX);
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
     1:                     NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetScreenY(int32_t* aScreenY)
     1: {
     1:   FORWARD_TO_OUTER(GetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
108991:   int32_t x, y;
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   *aScreenY = DevToCSSIntPixels(y);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::SetScreenY(int32_t aScreenY)
     1: {
     1:   FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent setting window.screenY by exiting early
     1:    */
     1: 
 30667:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
106838:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nullptr, &aScreenY),
     1:                     NS_ERROR_FAILURE);
     1: 
108991:   int32_t x, y;
     1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   y = CSSToDevIntPixels(aScreenY);
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
     1:                     NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 24816: // NOTE: Arguments to this function should have values scaled to
 24816: // CSS pixels, not device pixels.
     1: nsresult
108991: nsGlobalWindow::CheckSecurityWidthAndHeight(int32_t* aWidth, int32_t* aHeight)
     1: {
  3799: #ifdef MOZ_XUL
   677:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
   677:     // if attempting to resize the window, hide any open popups
  3129:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
 11414:     nsContentUtils::HidePopupsInDocument(doc);
   677:   }
  3799: #endif
   677: 
     1:   // This one is easy. Just ensure the variable is greater than 100;
     1:   if ((aWidth && *aWidth < 100) || (aHeight && *aHeight < 100)) {
     1:     // Check security state for use in determing window dimensions
     1: 
     1:     if (!nsContentUtils::IsCallerTrustedForWrite()) {
     1:       //sec check failed
     1:       if (aWidth && *aWidth < 100) {
     1:         *aWidth = 100;
     1:       }
     1:       if (aHeight && *aHeight < 100) {
     1:         *aHeight = 100;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 59572: // NOTE: Arguments to this function should have values in device pixels
 59572: nsresult
108991: nsGlobalWindow::SetDocShellWidthAndHeight(int32_t aInnerWidth, int32_t aInnerHeight)
 59572: {
 59572:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
 59572:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
 59572: 
 59572:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
 59572:   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
 59572:   NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
 59572: 
 59572:   NS_ENSURE_SUCCESS(treeOwner->SizeShellTo(docShellAsItem, aInnerWidth, aInnerHeight),
 59572:                     NS_ERROR_FAILURE);
 59572: 
 59572:   return NS_OK;
 59572: }
 59572: 
 59572: // NOTE: Arguments to this function should have values in app units
 59572: nsresult
 59572: nsGlobalWindow::SetCSSViewportWidthAndHeight(nscoord aInnerWidth, nscoord aInnerHeight)
 59572: {
 59572:   nsRefPtr<nsPresContext> presContext;
 59572:   mDocShell->GetPresContext(getter_AddRefs(presContext));
 59572: 
 59572:   nsRect shellArea = presContext->GetVisibleArea();
 59572:   shellArea.height = aInnerHeight;
 59572:   shellArea.width = aInnerWidth;
 59572: 
 59572:   presContext->SetVisibleArea(shellArea);
 59572:   return NS_OK;
 59572: }
 59572: 
 24816: // NOTE: Arguments to this function should have values scaled to
 24816: // CSS pixels, not device pixels.
     1: nsresult
108991: nsGlobalWindow::CheckSecurityLeftAndTop(int32_t* aLeft, int32_t* aTop)
     1: {
     1:   // This one is harder. We have to get the screen size and window dimensions.
     1: 
     1:   // Check security state for use in determing window dimensions
     1: 
     1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
  3799: #ifdef MOZ_XUL
   677:     // if attempting to move the window, hide any open popups
  3129:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
 11414:     nsContentUtils::HidePopupsInDocument(doc);
  3799: #endif
   677: 
     1:     nsGlobalWindow* rootWindow =
  3233:       static_cast<nsGlobalWindow*>(GetPrivateRoot());
     1:     if (rootWindow) {
     1:       rootWindow->FlushPendingNotifications(Flush_Layout);
     1:     }
     1: 
     1:     nsCOMPtr<nsIBaseWindow> treeOwner;
     1:     GetTreeOwner(getter_AddRefs(treeOwner));
 39648: 
 39648:     nsCOMPtr<nsIDOMScreen> screen;
 39648:     GetScreen(getter_AddRefs(screen));
 39648: 
 39648:     if (treeOwner && screen) {
108991:       int32_t screenLeft, screenTop, screenWidth, screenHeight;
108991:       int32_t winLeft, winTop, winWidth, winHeight;
 39648: 
 39648:       // Get the window size
     1:       treeOwner->GetPositionAndSize(&winLeft, &winTop, &winWidth, &winHeight);
     1: 
 24816:       // convert those values to CSS pixels
 24816:       // XXX four separate retrievals of the prescontext
 24816:       winLeft   = DevToCSSIntPixels(winLeft);
 24816:       winTop    = DevToCSSIntPixels(winTop);
 24816:       winWidth  = DevToCSSIntPixels(winWidth);
 24816:       winHeight = DevToCSSIntPixels(winHeight);
 24816: 
     1:       // Get the screen dimensions
     1:       // XXX This should use nsIScreenManager once it's fully fleshed out.
     1:       screen->GetAvailLeft(&screenLeft);
     1:       screen->GetAvailWidth(&screenWidth);
     1:       screen->GetAvailHeight(&screenHeight);
 69620: #if defined(XP_MACOSX)
     1:       /* The mac's coordinate system is different from the assumed Windows'
     1:          system. It offsets by the height of the menubar so that a window
     1:          placed at (0,0) will be entirely visible. Unfortunately that
     1:          correction is made elsewhere (in Widget) and the meaning of
     1:          the Avail... coordinates is overloaded. Here we allow a window
     1:          to be placed at (0,0) because it does make sense to do so.
     1:       */
     1:       screen->GetTop(&screenTop);
     1: #else
     1:       screen->GetAvailTop(&screenTop);
     1: #endif
 39648: 
     1:       if (aLeft) {
     1:         if (screenLeft+screenWidth < *aLeft+winWidth)
     1:           *aLeft = screenLeft+screenWidth - winWidth;
     1:         if (screenLeft > *aLeft)
     1:           *aLeft = screenLeft;
     1:       }
     1:       if (aTop) {
     1:         if (screenTop+screenHeight < *aTop+winHeight)
     1:           *aTop = screenTop+screenHeight - winHeight;
     1:         if (screenTop > *aTop)
     1:           *aTop = screenTop;
     1:       }
     1:     } else {
     1:       if (aLeft)
     1:         *aLeft = 0;
     1:       if (aTop)
     1:         *aTop = 0;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetPageXOffset(int32_t* aPageXOffset)
     1: {
     1:   return GetScrollX(aPageXOffset);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetPageYOffset(int32_t* aPageYOffset)
     1: {
     1:   return GetScrollY(aPageYOffset);
     1: }
     1: 
     1: nsresult
108991: nsGlobalWindow::GetScrollMaxXY(int32_t* aScrollMaxX, int32_t* aScrollMaxY)
     1: {
     1:   FORWARD_TO_OUTER(GetScrollMaxXY, (aScrollMaxX, aScrollMaxY),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   FlushPendingNotifications(Flush_Layout);
 37063:   nsIScrollableFrame *sf = GetScrollFrame();
 37063:   if (!sf)
 37063:     return NS_OK;
 37063: 
 37063:   nsRect scrollRange = sf->GetScrollRange();
     1: 
     1:   if (aScrollMaxX)
 38330:     *aScrollMaxX = NS_MAX(0,
108991:       (int32_t)floor(nsPresContext::AppUnitsToFloatCSSPixels(scrollRange.XMost())));
     1:   if (aScrollMaxY)
 38330:     *aScrollMaxY = NS_MAX(0,
108991:       (int32_t)floor(nsPresContext::AppUnitsToFloatCSSPixels(scrollRange.YMost())));
108991: 
108991:   return NS_OK;
108991: }
108991: 
108991: NS_IMETHODIMP
108991: nsGlobalWindow::GetScrollMaxX(int32_t* aScrollMaxX)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aScrollMaxX);
     1:   *aScrollMaxX = 0;
106838:   return GetScrollMaxXY(aScrollMaxX, nullptr);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetScrollMaxY(int32_t* aScrollMaxY)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aScrollMaxY);
     1:   *aScrollMaxY = 0;
106838:   return GetScrollMaxXY(nullptr, aScrollMaxY);
     1: }
     1: 
     1: nsresult
108991: nsGlobalWindow::GetScrollXY(int32_t* aScrollX, int32_t* aScrollY,
 79445:                             bool aDoFlush)
     1: {
     1:   FORWARD_TO_OUTER(GetScrollXY, (aScrollX, aScrollY, aDoFlush),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (aDoFlush) {
     1:     FlushPendingNotifications(Flush_Layout);
     1:   } else {
     1:     EnsureSizeUpToDate();
     1:   }
     1: 
 37063:   nsIScrollableFrame *sf = GetScrollFrame();
 37063:   if (!sf)
 37063:     return NS_OK;
 37063: 
 37063:   nsPoint scrollPos = sf->GetScrollPosition();
 37063:   if (scrollPos != nsPoint(0,0) && !aDoFlush) {
     1:     // Oh, well.  This is the expensive case -- the window is scrolled and we
     1:     // didn't actually flush yet.  Repeat, but with a flush, since the content
     1:     // may get shorter and hence our scroll position may decrease.
 80486:     return GetScrollXY(aScrollX, aScrollY, true);
     1:   }
     1: 
108181:   nsIntPoint scrollPosCSSPixels = sf->GetScrollPositionCSSPixels();
108181:   if (aScrollX) {
108181:     *aScrollX = scrollPosCSSPixels.x;
108181:   }
108181:   if (aScrollY) {
108181:     *aScrollY = scrollPosCSSPixels.y;
108181:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetScrollX(int32_t* aScrollX)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aScrollX);
     1:   *aScrollX = 0;
106838:   return GetScrollXY(aScrollX, nullptr, false);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetScrollY(int32_t* aScrollY)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aScrollY);
     1:   *aScrollY = 0;
106838:   return GetScrollXY(nullptr, aScrollY, false);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::GetLength(uint32_t* aLength)
     1: {
     1:   nsCOMPtr<nsIDOMWindowCollection> frames;
     1:   if (NS_SUCCEEDED(GetFrames(getter_AddRefs(frames))) && frames) {
     1:     return frames->GetLength(aLength);
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 79445: bool
     1: nsGlobalWindow::DispatchCustomEvent(const char *aEventName)
     1: {
 79445:   bool defaultActionEnabled = true;
     1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
     1:   nsContentUtils::DispatchTrustedEvent(doc,
 73874:                                        GetOuterWindow(),
     1:                                        NS_ConvertASCIItoUTF16(aEventName),
 80486:                                        true, true, &defaultActionEnabled);
     1: 
     1:   return defaultActionEnabled;
     1: }
     1: 
102067: void
102067: nsGlobalWindow::RefreshCompartmentPrincipal()
102067: {
102067:   FORWARD_TO_INNER(RefreshCompartmentPrincipal, (), /* void */ );
102067: 
102067:   JS_SetCompartmentPrincipals(js::GetObjectCompartment(mJSObject),
102067:                               nsJSPrincipals::get(mDoc->NodePrincipal()));
102067: }
102067: 
     1: static already_AddRefed<nsIDocShellTreeItem>
     1: GetCallerDocShellTreeItem()
     1: {
 18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
106838:   nsIDocShellTreeItem *callerItem = nullptr;
     1: 
     1:   if (cx) {
     1:     nsCOMPtr<nsIWebNavigation> callerWebNav =
     1:       do_GetInterface(nsJSUtils::GetDynamicScriptGlobal(cx));
     1: 
     1:     if (callerWebNav) {
     1:       CallQueryInterface(callerWebNav, &callerItem);
     1:     }
     1:   }
     1: 
     1:   return callerItem;
     1: }
     1: 
 79445: bool
     1: nsGlobalWindow::WindowExists(const nsAString& aName,
 79445:                              bool aLookForCallerOnJSStack)
     1: {
     1:   NS_PRECONDITION(IsOuterWindow(), "Must be outer window");
     1:   NS_PRECONDITION(mDocShell, "Must have docshell");
     1: 
     1:   nsCOMPtr<nsIDocShellTreeItem> caller;
     1:   if (aLookForCallerOnJSStack) {
     1:     caller = GetCallerDocShellTreeItem();
     1:   }
     1: 
     1:   nsCOMPtr<nsIDocShellTreeItem> docShell = do_QueryInterface(mDocShell);
     1:   NS_ASSERTION(docShell,
     1:                "Docshell doesn't implement nsIDocShellTreeItem?");
     1: 
     1:   if (!caller) {
     1:     caller = docShell;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDocShellTreeItem> namedItem;
106838:   docShell->FindItemWithName(PromiseFlatString(aName).get(), nullptr, caller,
     1:                              getter_AddRefs(namedItem));
106838:   return namedItem != nullptr;
     1: }
     1: 
     1: already_AddRefed<nsIWidget>
     1: nsGlobalWindow::GetMainWidget()
     1: {
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1: 
106838:   nsIWidget *widget = nullptr;
     1: 
     1:   if (treeOwnerAsWin) {
     1:     treeOwnerAsWin->GetMainWidget(&widget);
     1:   }
     1: 
     1:   return widget;
     1: }
     1: 
 30327: nsIWidget*
 30327: nsGlobalWindow::GetNearestWidget()
 30327: {
 30327:   nsIDocShell* docShell = GetDocShell();
106838:   NS_ENSURE_TRUE(docShell, nullptr);
 30327:   nsCOMPtr<nsIPresShell> presShell;
 30327:   docShell->GetPresShell(getter_AddRefs(presShell));
106838:   NS_ENSURE_TRUE(presShell, nullptr);
 30327:   nsIFrame* rootFrame = presShell->GetRootFrame();
106838:   NS_ENSURE_TRUE(rootFrame, nullptr);
106838:   return rootFrame->GetView()->GetNearestWidget(nullptr);
 30327: }
 30327: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::SetFullScreen(bool aFullScreen)
     1: {
 90457:   return SetFullScreenInternal(aFullScreen, true);
 90457: }
 90457: 
 90457: nsresult
 90457: nsGlobalWindow::SetFullScreenInternal(bool aFullScreen, bool aRequireTrust)
 90457: {
     1:   FORWARD_TO_OUTER(SetFullScreen, (aFullScreen), NS_ERROR_NOT_INITIALIZED);
     1: 
  8932:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
  8932: 
 79445:   bool rootWinFullScreen;
  2114:   GetFullScreen(&rootWinFullScreen);
 90457:   // Only chrome can change our fullScreen mode, unless we're running in
 90457:   // untrusted mode.
 90457:   if (aFullScreen == rootWinFullScreen || 
 90457:       (aRequireTrust && !nsContentUtils::IsCallerTrustedForWrite())) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // SetFullScreen needs to be called on the root window, so get that
     1:   // via the DocShell tree, and if we are not already the root,
     1:   // call SetFullScreen on that window instead.
     1:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
     1:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
     1:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
 90457:   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(rootItem);
     1:   if (!window)
     1:     return NS_ERROR_FAILURE;
     1:   if (rootItem != treeItem)
 90457:     return window->SetFullScreenInternal(aFullScreen, aRequireTrust);
     1: 
     1:   // make sure we don't try to set full screen on a non-chrome window,
     1:   // which might happen in embedding world
108991:   int32_t itemType;
     1:   treeItem->GetItemType(&itemType);
     1:   if (itemType != nsIDocShellTreeItem::typeChrome)
     1:     return NS_ERROR_FAILURE;
     1: 
 51638:   // If we are already in full screen mode, just return.
 51638:   if (mFullScreen == aFullScreen)
 51638:     return NS_OK;
 51638: 
     1:   // dispatch a "fullscreen" DOM event so that XUL apps can
     1:   // respond visually if we are kicked into full screen mode
     1:   if (!DispatchCustomEvent("fullscreen")) {
     1:     return NS_OK;
     1:   }
     1: 
 47945:   // Prevent chrome documents which are still loading from resizing
 47945:   // the window after we set fullscreen mode.
 47945:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
 47945:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
 47945:   nsCOMPtr<nsIXULWindow> xulWin(do_GetInterface(treeOwnerAsWin));
 47945:   if (aFullScreen && xulWin) {
 80486:     xulWin->SetIntrinsicallySized(false);
 47945:   }
 47945: 
 51638:   // Set this before so if widget sends an event indicating its
 51638:   // gone full screen, the state trap above works.
 51638:   mFullScreen = aFullScreen;
 51638: 
104464:   // Sometimes we don't want the top-level widget to actually go fullscreen,
104464:   // for example in the B2G desktop client, we don't want the emulated screen
104464:   // dimensions to appear to increase when entering fullscreen mode; we just
104464:   // want the content to fill the entire client area of the emulator window.
104464:   if (!Preferences::GetBool("full-screen-api.ignore-widgets", false)) {
     1:     nsCOMPtr<nsIWidget> widget = GetMainWidget();
 64065:     if (widget)
     1:       widget->MakeFullScreen(aFullScreen);
104464:   }
     1: 
 84109:   if (!mFullScreen) {
 84109:     // Force exit from DOM full-screen mode. This is so that if we're in
 84109:     // DOM full-screen mode and the user exits full-screen mode with
 84109:     // the browser full-screen mode toggle keyboard-shortcut, we'll detect
 84109:     // that and leave DOM API full-screen mode too.
 84109:     nsIDocument::ExitFullScreen(false);
 77843:   }
 77843: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::GetFullScreen(bool* aFullScreen)
     1: {
     1:   FORWARD_TO_OUTER(GetFullScreen, (aFullScreen), NS_ERROR_NOT_INITIALIZED);
     1: 
  2114:   // Get the fullscreen value of the root window, to always have the value
  2114:   // accurate, even when called from content.
  2114:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
  8932:   if (treeItem) {
  2114:     nsCOMPtr<nsIDocShellTreeItem> rootItem;
  2114:     treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
  2114:     if (rootItem != treeItem) {
 73870:       nsCOMPtr<nsIDOMWindow> window = do_GetInterface(rootItem);
  2114:       if (window)
  2114:         return window->GetFullScreen(aFullScreen);
  2114:     }
  8932:   }
  2114: 
 30004:   // We are the root window, or something went wrong. Return our internal value.
 30004:   *aFullScreen = mFullScreen;
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
 21376: nsGlobalWindow::DOMWindowDumpEnabled()
     1: {
102909: #if !(defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
     1:   // In optimized builds we check a pref that controls if we should
     1:   // enable output from dump() or not, in debug builds it's always
     1:   // enabled.
 21376:   return gDOMWindowDumpEnabled;
 21376: #else
 80486:   return true;
     1: #endif
 21376: }
 21376: 
 21376: NS_IMETHODIMP
 21376: nsGlobalWindow::Dump(const nsAString& aStr)
 21376: {
 21376:   if (!DOMWindowDumpEnabled()) {
 21376:     return NS_OK;
 21376:   }
     1: 
     1:   char *cstr = ToNewUTF8String(aStr);
     1: 
 69620: #if defined(XP_MACOSX)
     1:   // have to convert \r to \n so that printing to the console works
 43423:   char *c = cstr, *cEnd = cstr + strlen(cstr);
     1:   while (c < cEnd) {
     1:     if (*c == '\r')
     1:       *c = '\n';
     1:     c++;
     1:   }
     1: #endif
     1: 
     1:   if (cstr) {
105784: #ifdef XP_WIN
105784:     if (IsDebuggerPresent()) {
105784:       OutputDebugStringA(cstr);
105784:     }
105784: #endif
 82109: #ifdef ANDROID
 88337:     __android_log_write(ANDROID_LOG_INFO, "GeckoDump", cstr);
 82109: #endif
 27826:     FILE *fp = gDumpFile ? gDumpFile : stdout;
 27826:     fputs(cstr, fp);
 27826:     fflush(fp);
     1:     nsMemory::Free(cstr);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsGlobalWindow::EnsureReflowFlushAndPaint()
     1: {
 62357:   NS_ASSERTION(IsOuterWindow(), "EnsureReflowFlushAndPaint() must be called on"
 62357:                "the outer window");
     1:   NS_ASSERTION(mDocShell, "EnsureReflowFlushAndPaint() called with no "
     1:                "docshell!");
     1: 
 22792:   if (!mDocShell)
 22792:     return;
 22792: 
     1:   nsCOMPtr<nsIPresShell> presShell;
     1:   mDocShell->GetPresShell(getter_AddRefs(presShell));
     1: 
     1:   if (!presShell)
     1:     return;
     1: 
     1:   // Flush pending reflows.
     1:   if (mDoc) {
     1:     mDoc->FlushPendingNotifications(Flush_Layout);
     1:   }
     1: 
     1:   // Unsuppress painting.
     1:   presShell->UnsuppressPainting();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetTextZoom(float *aZoom)
     1: {
     1:   FORWARD_TO_OUTER(GetTextZoom, (aZoom), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (mDocShell) {
     1:     nsCOMPtr<nsIContentViewer> contentViewer;
     1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
     1:     nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer));
     1: 
     1:     if (markupViewer) {
     1:       return markupViewer->GetTextZoom(aZoom);
     1:     }
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::SetTextZoom(float aZoom)
     1: {
     1:   FORWARD_TO_OUTER(SetTextZoom, (aZoom), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (mDocShell) {
     1:     nsCOMPtr<nsIContentViewer> contentViewer;
     1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
     1:     nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer));
     1: 
     1:     if (markupViewer)
     1:       return markupViewer->SetTextZoom(aZoom);
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: // static
     1: void
     1: nsGlobalWindow::MakeScriptDialogTitle(nsAString &aOutTitle)
     1: {
     1:   aOutTitle.Truncate();
     1: 
     1:   // Try to get a host from the running principal -- this will do the
     1:   // right thing for javascript: and data: documents.
     1: 
     1:   nsresult rv = NS_OK;
     1:   NS_ASSERTION(nsContentUtils::GetSecurityManager(),
     1:     "Global Window has no security manager!");
     1:   if (nsContentUtils::GetSecurityManager()) {
     1:     nsCOMPtr<nsIPrincipal> principal;
     1:     rv = nsContentUtils::GetSecurityManager()->
     1:       GetSubjectPrincipal(getter_AddRefs(principal));
     1: 
     1:     if (NS_SUCCEEDED(rv) && principal) {
     1:       nsCOMPtr<nsIURI> uri;
     1:       rv = principal->GetURI(getter_AddRefs(uri));
     1: 
     1:       if (NS_SUCCEEDED(rv) && uri) {
     1:         // remove user:pass for privacy and spoof prevention
     1: 
     1:         nsCOMPtr<nsIURIFixup> fixup(do_GetService(NS_URIFIXUP_CONTRACTID));
     1:         if (fixup) {
     1:           nsCOMPtr<nsIURI> fixedURI;
     1:           rv = fixup->CreateExposableURI(uri, getter_AddRefs(fixedURI));
     1:           if (NS_SUCCEEDED(rv) && fixedURI) {
110974:             nsAutoCString host;
     1:             fixedURI->GetHost(host);
     1: 
     1:             if (!host.IsEmpty()) {
     1:               // if this URI has a host we'll show it. For other
     1:               // schemes (e.g. file:) we fall back to the localized
     1:               // generic string
     1: 
110974:               nsAutoCString prepath;
     1:               fixedURI->GetPrePath(prepath);
     1: 
     1:               NS_ConvertUTF8toUTF16 ucsPrePath(prepath);
     1:               const PRUnichar *formatStrings[] = { ucsPrePath.get() };
     1:               nsXPIDLString tempString;
     1:               nsContentUtils::FormatLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
     1:                                                     "ScriptDlgHeading",
 91877:                                                     formatStrings,
     1:                                                     tempString);
     1:               aOutTitle = tempString;
     1:             }
     1:           }
     1:         }
     1:       }
     1:     }
     1:     else { // failed to get subject principal
     1:       NS_WARNING("No script principal? Who is calling alert/confirm/prompt?!");
     1:     }
     1:   }
     1: 
     1:   if (aOutTitle.IsEmpty()) {
     1:     // We didn't find a host so use the generic heading
     1:     nsXPIDLString tempString;
     1:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
     1:                                        "ScriptDlgGenericHeading",
     1:                                        tempString);
     1:     aOutTitle = tempString;
     1:   }
     1: 
     1:   // Just in case
     1:   if (aOutTitle.IsEmpty()) {
     1:     NS_WARNING("could not get ScriptDlgGenericHeading string from string bundle");
     1:     aOutTitle.AssignLiteral("[Script]");
     1:   }
     1: }
     1: 
 79445: bool
 10989: nsGlobalWindow::CanMoveResizeWindows()
 10989: {
 71105:   // When called from chrome, we can avoid the following checks.
 71105:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
 71105:     // Don't allow scripts to move or resize windows that were not opened by a
 71105:     // script.
 71105:     if (!mHadOriginalOpener) {
 80486:       return false;
 71105:     }
 71105: 
 71105:     if (!CanSetProperty("dom.disable_window_move_resize")) {
 80486:       return false;
 71105:     }
 71105: 
 71105:     // Ignore the request if we have more than one tab in the window.
 71105:     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
 71105:     GetTreeOwner(getter_AddRefs(treeOwner));
 71105:     if (treeOwner) {
108991:       uint32_t itemCount;
 71105:       if (NS_SUCCEEDED(treeOwner->GetTargetableShellCount(&itemCount)) &&
 71105:           itemCount > 1) {
 80486:         return false;
 71105:       }
 71105:     }
 71105:   }
 10989: 
 72453:   if (mDocShell) {
 79445:     bool allow;
 72453:     nsresult rv = mDocShell->GetAllowWindowControl(&allow);
 72453:     if (NS_SUCCEEDED(rv) && !allow)
 80486:       return false;
 72453:   }
 72453: 
 13279:   if (gMouseDown && !gDragServiceDisabled) {
 13279:     nsCOMPtr<nsIDragService> ds =
 13279:       do_GetService("@mozilla.org/widget/dragservice;1");
 13279:     if (ds) {
 80486:       gDragServiceDisabled = true;
 13279:       ds->Suppress();
 13279:     }
 13279:   }
 80486:   return true;
 13279: }
 10989: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Alert(const nsAString& aString)
     1: {
     1:   FORWARD_TO_OUTER(Alert, (aString), NS_ERROR_NOT_INITIALIZED);
     1: 
108232:   bool needToPromptForAbuse;
108232:   if (DialogsAreBlocked(&needToPromptForAbuse)) {
 54231:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
 54231: 
     1:   // Reset popup state while opening a modal dialog, and firing events
     1:   // about the dialog, to prevent the current state from being active
     1:   // the whole time a modal dialog is open.
 80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
     1: 
     1:   // Special handling for alert(null) in JS for backwards
     1:   // compatibility.
     1: 
     1:   NS_NAMED_LITERAL_STRING(null_str, "null");
     1: 
     1:   const nsAString *str = DOMStringIsNull(aString) ? &null_str : &aString;
     1: 
     1:   // Before bringing up the window, unsuppress painting and flush
     1:   // pending reflows.
     1:   EnsureReflowFlushAndPaint();
     1: 
     1:   nsAutoString title;
     1:   MakeScriptDialogTitle(title);
     1: 
     1:   // Remove non-terminating null characters from the 
     1:   // string. See bug #310037. 
     1:   nsAutoString final;
 38887:   nsContentUtils::StripNullChars(*str, final);
     1: 
 62631:   // Check if we're being called at a point where we can't use tab-modal
 62631:   // prompts, because something doesn't want reentrancy.
 79445:   bool allowTabModal = GetIsTabModalPromptAllowed();
 62631: 
 42304:   nsresult rv;
 57937:   nsCOMPtr<nsIPromptFactory> promptFac =
 57937:     do_GetService("@mozilla.org/prompter;1", &rv);
 42304:   NS_ENSURE_SUCCESS(rv, rv);
 42304: 
 57937:   nsCOMPtr<nsIPrompt> prompt;
 57937:   rv = promptFac->GetPrompt(this, NS_GET_IID(nsIPrompt),
 57937:                             reinterpret_cast<void**>(&prompt));
 57937:   NS_ENSURE_SUCCESS(rv, rv);
 57937: 
 57937:   nsCOMPtr<nsIWritablePropertyBag2> promptBag = do_QueryInterface(prompt);
 57937:   if (promptBag)
 62631:     promptBag->SetPropertyAsBool(NS_LITERAL_STRING("allowTabModal"), allowTabModal);
 57937: 
 94465:   nsAutoSyncOperation sync(GetCurrentInnerWindowInternal() ? 
 94465:                              GetCurrentInnerWindowInternal()->mDoc :
106838:                              nullptr);
108232:   if (needToPromptForAbuse) {
 79445:     bool disallowDialog = false;
 54231:     nsXPIDLString label;
 54231:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
 54231:                                        "ScriptDialogLabel", label);
 54231: 
 57937:     rv = prompt->AlertCheck(title.get(), final.get(), label.get(),
 54231:                             &disallowDialog);
 54231:     if (disallowDialog)
108233:       PreventFurtherDialogs(false);
 54231:   } else {
 57937:     rv = prompt->Alert(title.get(), final.get());
 54231:   }
 54231: 
 54231:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::Confirm(const nsAString& aString, bool* aReturn)
     1: {
     1:   FORWARD_TO_OUTER(Confirm, (aString, aReturn), NS_ERROR_NOT_INITIALIZED);
     1: 
108232:   bool needToPromptForAbuse;
108232:   if (DialogsAreBlocked(&needToPromptForAbuse)) {
 54231:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
 54231: 
     1:   // Reset popup state while opening a modal dialog, and firing events
     1:   // about the dialog, to prevent the current state from being active
     1:   // the whole time a modal dialog is open.
 80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
 80486: 
 80486:   *aReturn = false;
     1: 
     1:   // Before bringing up the window, unsuppress painting and flush
     1:   // pending reflows.
     1:   EnsureReflowFlushAndPaint();
     1: 
     1:   nsAutoString title;
     1:   MakeScriptDialogTitle(title);
     1: 
     1:   // Remove non-terminating null characters from the 
     1:   // string. See bug #310037. 
     1:   nsAutoString final;
 38887:   nsContentUtils::StripNullChars(aString, final);
     1: 
 62631:   // Check if we're being called at a point where we can't use tab-modal
 62631:   // prompts, because something doesn't want reentrancy.
 79445:   bool allowTabModal = GetIsTabModalPromptAllowed();
 62631: 
 42304:   nsresult rv;
 57937:   nsCOMPtr<nsIPromptFactory> promptFac =
 57937:     do_GetService("@mozilla.org/prompter;1", &rv);
 42304:   NS_ENSURE_SUCCESS(rv, rv);
 42304: 
 57937:   nsCOMPtr<nsIPrompt> prompt;
 57937:   rv = promptFac->GetPrompt(this, NS_GET_IID(nsIPrompt),
 57937:                             reinterpret_cast<void**>(&prompt));
 57937:   NS_ENSURE_SUCCESS(rv, rv);
 57937: 
 57937:   nsCOMPtr<nsIWritablePropertyBag2> promptBag = do_QueryInterface(prompt);
 57937:   if (promptBag)
 62631:     promptBag->SetPropertyAsBool(NS_LITERAL_STRING("allowTabModal"), allowTabModal);
 57937: 
 94465:   nsAutoSyncOperation sync(GetCurrentInnerWindowInternal() ? 
 94465:                              GetCurrentInnerWindowInternal()->mDoc :
106838:                              nullptr);
108232:   if (needToPromptForAbuse) {
 79445:     bool disallowDialog = false;
 54231:     nsXPIDLString label;
 54231:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
 54231:                                        "ScriptDialogLabel", label);
 54231: 
 57937:     rv = prompt->ConfirmCheck(title.get(), final.get(), label.get(),
 54231:                               &disallowDialog, aReturn);
 54231:     if (disallowDialog)
108233:       PreventFurtherDialogs(false);
 54231:   } else {
 57937:     rv = prompt->Confirm(title.get(), final.get(), aReturn);
 54231:   }
 54231: 
 54231:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Prompt(const nsAString& aMessage, const nsAString& aInitial,
     1:                        nsAString& aReturn)
     1: {
 62357:   FORWARD_TO_OUTER(Prompt, (aMessage, aInitial, aReturn),
 62357:                    NS_ERROR_NOT_INITIALIZED);
 62357: 
     1:   SetDOMStringToNull(aReturn);
     1: 
108232:   bool needToPromptForAbuse;
108232:   if (DialogsAreBlocked(&needToPromptForAbuse)) {
 54231:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
 54231: 
     1:   // Reset popup state while opening a modal dialog, and firing events
     1:   // about the dialog, to prevent the current state from being active
     1:   // the whole time a modal dialog is open.
 80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
     1: 
     1:   // Before bringing up the window, unsuppress painting and flush
     1:   // pending reflows.
     1:   EnsureReflowFlushAndPaint();
     1: 
     1:   nsAutoString title;
     1:   MakeScriptDialogTitle(title);
     1:   
     1:   // Remove non-terminating null characters from the 
     1:   // string. See bug #310037. 
     1:   nsAutoString fixedMessage, fixedInitial;
 38887:   nsContentUtils::StripNullChars(aMessage, fixedMessage);
 38887:   nsContentUtils::StripNullChars(aInitial, fixedInitial);
     1: 
 62631:   // Check if we're being called at a point where we can't use tab-modal
 62631:   // prompts, because something doesn't want reentrancy.
 79445:   bool allowTabModal = GetIsTabModalPromptAllowed();
 62631: 
 42304:   nsresult rv;
 57937:   nsCOMPtr<nsIPromptFactory> promptFac =
 57937:     do_GetService("@mozilla.org/prompter;1", &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 57937:   nsCOMPtr<nsIPrompt> prompt;
 57937:   rv = promptFac->GetPrompt(this, NS_GET_IID(nsIPrompt),
 57937:                             reinterpret_cast<void**>(&prompt));
 57937:   NS_ENSURE_SUCCESS(rv, rv);
 57937: 
 57937:   nsCOMPtr<nsIWritablePropertyBag2> promptBag = do_QueryInterface(prompt);
 57937:   if (promptBag)
 62631:     promptBag->SetPropertyAsBool(NS_LITERAL_STRING("allowTabModal"), allowTabModal);
 57937: 
 42304:   // Pass in the default value, if any.
 42304:   PRUnichar *inoutValue = ToNewUnicode(fixedInitial);
 79445:   bool disallowDialog = false;
 54231: 
 54231:   nsXPIDLString label;
108232:   if (needToPromptForAbuse) {
 54231:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
 54231:                                        "ScriptDialogLabel", label);
 54231:   }
 54231: 
 94465:   nsAutoSyncOperation sync(GetCurrentInnerWindowInternal() ? 
 94465:                              GetCurrentInnerWindowInternal()->mDoc :
106838:                              nullptr);
 79445:   bool ok;
 57937:   rv = prompt->Prompt(title.get(), fixedMessage.get(),
 54231:                       &inoutValue, label.get(), &disallowDialog, &ok);
 54231: 
 54231:   if (disallowDialog) {
108233:     PreventFurtherDialogs(false);
 54231:   }
 54231: 
 42304:   NS_ENSURE_SUCCESS(rv, rv);
 42304: 
 42304:   nsAdoptingString outValue(inoutValue);
 42304: 
 42304:   if (ok && outValue) {
 42304:     aReturn.Assign(outValue);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Focus()
     1: {
     1:   FORWARD_TO_OUTER(Focus, (), NS_ERROR_NOT_INITIALIZED);
     1: 
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (!fm)
 29018:     return NS_OK;
 29018: 
     1:   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(mDocShell);
     1: 
 79445:   bool isVisible = false;
     1:   if (baseWin) {
     1:     baseWin->GetVisibility(&isVisible);
     1:   }
     1: 
     1:   if (!isVisible) {
     1:     // A hidden tab is being focused, ignore this call.
     1:     return NS_OK;
     1:   }
     1: 
 76293:   nsIDOMWindow *caller = nsContentUtils::GetWindowFromCaller();
 73870:   nsCOMPtr<nsIDOMWindow> opener;
 52309:   GetOpener(getter_AddRefs(opener));
 52309: 
 52309:   // Enforce dom.disable_window_flip (for non-chrome), but still allow the
 52309:   // window which opened us to raise us at times when popups are allowed
 52309:   // (bugs 355482 and 369306).
 79445:   bool canFocus = CanSetProperty("dom.disable_window_flip") ||
 52309:                     (opener == caller &&
 52309:                      RevisePopupAbuseLevel(gPopupControlState) < openAbused);
     1: 
 29018:   nsCOMPtr<nsIDOMWindow> activeWindow;
 29018:   fm->GetActiveWindow(getter_AddRefs(activeWindow));
 29018: 
 29018:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
 29018:   NS_ASSERTION(treeItem, "What happened?");
 29018:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
 29018:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
 29018:   nsCOMPtr<nsIDOMWindow> rootWin = do_GetInterface(rootItem);
 79445:   bool isActive = (rootWin == activeWindow);
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   if (treeOwnerAsWin && (canFocus || isActive)) {
 79445:     bool isEnabled = true;
     1:     if (NS_SUCCEEDED(treeOwnerAsWin->GetEnabled(&isEnabled)) && !isEnabled) {
     1:       NS_WARNING( "Should not try to set the focus on a disabled window" );
     1:       return NS_OK;
     1:     }
     1: 
 29018:     // XXXndeakin not sure what this is for or if it should go somewhere else
     1:     nsCOMPtr<nsIEmbeddingSiteWindow> embeddingWin(do_GetInterface(treeOwnerAsWin));
     1:     if (embeddingWin)
     1:       embeddingWin->SetFocus();
     1:   }
     1: 
 29018:   if (!mDocShell)
 29018:     return NS_OK;
 29018: 
     1:   nsCOMPtr<nsIPresShell> presShell;
     1:   // Don't look for a presshell if we're a root chrome window that's got
     1:   // about:blank loaded.  We don't want to focus our widget in that case.
     1:   // XXXbz should we really be checking for IsInitialDocument() instead?
 79445:   bool lookForPresShell = true;
108991:   int32_t itemType = nsIDocShellTreeItem::typeContent;
     1:   treeItem->GetItemType(&itemType);
     1:   if (itemType == nsIDocShellTreeItem::typeChrome &&
 73870:       GetPrivateRoot() == static_cast<nsIDOMWindow*>(this) &&
     1:       mDocument) {
     1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
     1:     NS_ASSERTION(doc, "Bogus doc?");
     1:     nsIURI* ourURI = doc->GetDocumentURI();
     1:     if (ourURI) {
 78530:       lookForPresShell = !NS_IsAboutBlank(ourURI);
     1:     }
     1:   }
     1: 
     1:   if (lookForPresShell) {
     1:     mDocShell->GetEldestPresShell(getter_AddRefs(presShell));
     1:   }
 29018: 
 29018:   nsCOMPtr<nsIDocShellTreeItem> parentDsti;
 29018:   treeItem->GetParent(getter_AddRefs(parentDsti));
 29018: 
 29018:   // set the parent's current focus to the frame containing this window.
 29018:   nsCOMPtr<nsIDOMWindow> parent(do_GetInterface(parentDsti));
 29018:   if (parent) {
 29018:     nsCOMPtr<nsIDOMDocument> parentdomdoc;
 29018:     parent->GetDocument(getter_AddRefs(parentdomdoc));
 29018: 
 29018:     nsCOMPtr<nsIDocument> parentdoc = do_QueryInterface(parentdomdoc);
 29018:     if (!parentdoc)
 29018:       return NS_OK;
 29018: 
 29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
 29018:     nsIContent* frame = parentdoc->FindContentForSubDocument(doc);
 29018:     nsCOMPtr<nsIDOMElement> frameElement = do_QueryInterface(frame);
 29018:     if (frameElement) {
108991:       uint32_t flags = nsIFocusManager::FLAG_NOSCROLL;
 29018:       if (canFocus)
 29018:         flags |= nsIFocusManager::FLAG_RAISE;
 29018:       return fm->SetFocus(frameElement, flags);
 29018:     }
 29018:   }
 29018:   else if (canFocus) {
 29018:     // if there is no parent, this must be a toplevel window, so raise the
 29018:     // window if canFocus is true
 29018:     return fm->SetActiveWindow(this);
 29018:   }
 29018: 
 29018:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Blur()
     1: {
     1:   FORWARD_TO_OUTER(Blur, (), NS_ERROR_NOT_INITIALIZED);
     1: 
 52309:   // If dom.disable_window_flip == true, then content should not be allowed
 52309:   // to call this function (this would allow popunders, bug 369306)
 52309:   if (!CanSetProperty("dom.disable_window_flip")) {
 52309:     return NS_OK;
 52309:   }
 52309: 
101616:   // If embedding apps don't implement nsIEmbeddingSiteWindow, we
     1:   // shouldn't throw exceptions to web content.
     1:   nsresult rv = NS_OK;
     1: 
     1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
     1:   GetTreeOwner(getter_AddRefs(treeOwner));
101616:   nsCOMPtr<nsIEmbeddingSiteWindow> siteWindow(do_GetInterface(treeOwner));
     1:   if (siteWindow) {
106838:     // This method call may cause mDocShell to become nullptr.
     1:     rv = siteWindow->Blur();
     1: 
 29018:     // if the root is focused, clear the focus
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
 29018:     if (fm && mDocument) {
 29018:       nsCOMPtr<nsIDOMElement> element;
106838:       fm->GetFocusedElementForWindow(this, false, nullptr, getter_AddRefs(element));
 29018:       nsCOMPtr<nsIContent> content = do_QueryInterface(element);
 41634:       if (content == doc->GetRootElement())
 29018:         fm->ClearFocus(this);
 29018:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Back()
     1: {
     1:   FORWARD_TO_OUTER(Back, (), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
     1: 
     1:   return webNav->GoBack();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Forward()
     1: {
     1:   FORWARD_TO_OUTER(Forward, (), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
     1: 
     1:   return webNav->GoForward();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Home()
     1: {
     1:   FORWARD_TO_OUTER(Home, (), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (!mDocShell)
     1:     return NS_OK;
     1: 
     1:   nsAdoptingString homeURL =
 70976:     Preferences::GetLocalizedString(PREF_BROWSER_STARTUP_HOMEPAGE);
     1: 
     1:   if (homeURL.IsEmpty()) {
     1:     // if all else fails, use this
     1: #ifdef DEBUG_seth
     1:     printf("all else failed.  using %s as the home page\n", DEFAULT_HOME_PAGE);
     1: #endif
     1:     CopyASCIItoUTF16(DEFAULT_HOME_PAGE, homeURL);
     1:   }
     1: 
     1: #ifdef MOZ_PHOENIX
     1:   {
     1:     // Firefox lets the user specify multiple home pages to open in
     1:     // individual tabs by separating them with '|'. Since we don't
     1:     // have the machinery in place to easily open new tabs from here,
     1:     // simply truncate the homeURL at the first '|' character to
     1:     // prevent any possibilities of leaking the users list of home
     1:     // pages to the first home page.
     1:     //
     1:     // Once bug https://bugzilla.mozilla.org/show_bug.cgi?id=221445 is
     1:     // fixed we can revisit this.
108991:     int32_t firstPipe = homeURL.FindChar('|');
     1: 
     1:     if (firstPipe > 0) {
     1:       homeURL.Truncate(firstPipe);
     1:     }
     1:   }
     1: #endif
     1: 
     1:   nsresult rv;
     1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
     1:   rv = webNav->LoadURI(homeURL.get(),
     1:                        nsIWebNavigation::LOAD_FLAGS_NONE,
106838:                        nullptr,
106838:                        nullptr,
106838:                        nullptr);
     1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Stop()
     1: {
     1:   FORWARD_TO_OUTER(Stop, (), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:   if (!webNav)
     1:     return NS_OK;
     1: 
     1:   return webNav->Stop(nsIWebNavigation::STOP_ALL);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Print()
     1: {
     1: #ifdef NS_PRINTING
     1:   FORWARD_TO_OUTER(Print, (), NS_ERROR_NOT_INITIALIZED);
     1: 
 95379:   if (Preferences::GetBool("dom.disable_window_print", false))
 95379:     return NS_ERROR_NOT_AVAILABLE;
 95379: 
108232:   bool needToPromptForAbuse;
108232:   if (DialogsAreBlocked(&needToPromptForAbuse)) {
 54231:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
108232: 
108232:   if (needToPromptForAbuse && !ConfirmDialogIfNeeded()) {
108232:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
 54231: 
     1:   nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint;
     1:   if (NS_SUCCEEDED(GetInterface(NS_GET_IID(nsIWebBrowserPrint),
     1:                                 getter_AddRefs(webBrowserPrint)))) {
 94465:     nsAutoSyncOperation sync(GetCurrentInnerWindowInternal() ? 
 94465:                                GetCurrentInnerWindowInternal()->mDoc :
106838:                                nullptr);
     1: 
     1:     nsCOMPtr<nsIPrintSettingsService> printSettingsService = 
     1:       do_GetService("@mozilla.org/gfx/printsettings-service;1");
     1: 
     1:     nsCOMPtr<nsIPrintSettings> printSettings;
     1:     if (printSettingsService) {
 79445:       bool printSettingsAreGlobal =
 79445:         Preferences::GetBool("print.use_global_printsettings", false);
     1: 
     1:       if (printSettingsAreGlobal) {
     1:         printSettingsService->GetGlobalPrintSettings(getter_AddRefs(printSettings));
     1: 
     1:         nsXPIDLString printerName;
 42459:         printSettings->GetPrinterName(getter_Copies(printerName));
 42459:         if (printerName.IsEmpty()) {
     1:           printSettingsService->GetDefaultPrinterName(getter_Copies(printerName));
 42459:           printSettings->SetPrinterName(printerName);
 42459:         }
     1:         printSettingsService->InitPrintSettingsFromPrinter(printerName, printSettings);
     1:         printSettingsService->InitPrintSettingsFromPrefs(printSettings, 
 80486:                                                          true, 
     1:                                                          nsIPrintSettings::kInitSaveAll);
     1:       } else {
     1:         printSettingsService->GetNewPrintSettings(getter_AddRefs(printSettings));
     1:       }
     1: 
 68551:       nsCOMPtr<nsIDOMWindow> callerWin = EnterModalState();
106838:       webBrowserPrint->Print(printSettings, nullptr);
 68551:       LeaveModalState(callerWin);
     1: 
 79445:       bool savePrintSettings =
 79445:         Preferences::GetBool("print.save_print_settings", false);
     1:       if (printSettingsAreGlobal && savePrintSettings) {
     1:         printSettingsService->
     1:           SavePrintSettingsToPrefs(printSettings,
 80486:                                    true,
     1:                                    nsIPrintSettings::kInitSaveAll);
     1:         printSettingsService->
     1:           SavePrintSettingsToPrefs(printSettings,
 80486:                                    false,
     1:                                    nsIPrintSettings::kInitSavePrinterName);
     1:       }
     1:     } else {
     1:       webBrowserPrint->GetGlobalPrintSettings(getter_AddRefs(printSettings));
106838:       webBrowserPrint->Print(printSettings, nullptr);
     1:     }
     1:   }
 38377: #endif //NS_PRINTING
 38377: 
 38377:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::MoveTo(int32_t aXPos, int32_t aYPos)
     1: {
     1:   FORWARD_TO_OUTER(MoveTo, (aXPos, aYPos), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent window.moveTo() by exiting early
     1:    */
     1: 
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
     1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aXPos, &aYPos),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   // mild abuse of a "size" object so we don't need more helper functions
 24816:   nsIntSize devPos(CSSToDevIntPixels(nsIntSize(aXPos, aYPos)));
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(devPos.width, devPos.height),
     1:                     NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::MoveBy(int32_t aXDif, int32_t aYDif)
     1: {
     1:   FORWARD_TO_OUTER(MoveBy, (aXDif, aYDif), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent window.moveBy() by exiting early
     1:    */
     1: 
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
 24816:   // To do this correctly we have to convert what we get from GetPosition
 24816:   // into CSS pixels, add the arguments, do the security check, and
 24816:   // then convert back to device pixels for the call to SetPosition.
 24816: 
108991:   int32_t x, y;
     1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y), NS_ERROR_FAILURE);
     1: 
 24816:   // mild abuse of a "size" object so we don't need more helper functions
 24816:   nsIntSize cssPos(DevToCSSIntPixels(nsIntSize(x, y)));
 24816: 
 24816:   cssPos.width += aXDif;
 24816:   cssPos.height += aYDif;
 24816:   
 24816:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&cssPos.width,
 24816:                                             &cssPos.height),
 24816:                     NS_ERROR_FAILURE);
 24816: 
 24816:   nsIntSize newDevPos(CSSToDevIntPixels(cssPos));
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(newDevPos.width,
 24816:                                                 newDevPos.height),
     1:                     NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ResizeTo(int32_t aWidth, int32_t aHeight)
     1: {
     1:   FORWARD_TO_OUTER(ResizeTo, (aWidth, aHeight), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent window.resizeTo() by exiting early
     1:    */
     1: 
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1:   
     1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&aWidth, &aHeight),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   nsIntSize devSz(CSSToDevIntPixels(nsIntSize(aWidth, aHeight)));
 24816: 
 80486:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetSize(devSz.width, devSz.height, true),
     1:                     NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ResizeBy(int32_t aWidthDif, int32_t aHeightDif)
     1: {
     1:   FORWARD_TO_OUTER(ResizeBy, (aWidthDif, aHeightDif), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
     1:    * prevent window.resizeBy() by exiting early
     1:    */
     1: 
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
     1: 
108991:   int32_t width, height;
     1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&width, &height), NS_ERROR_FAILURE);
     1: 
 24816:   // To do this correctly we have to convert what we got from GetSize
 24816:   // into CSS pixels, add the arguments, do the security check, and
 24816:   // then convert back to device pixels for the call to SetSize.
 24816: 
 24816:   nsIntSize cssSize(DevToCSSIntPixels(nsIntSize(width, height)));
 24816: 
 24816:   cssSize.width += aWidthDif;
 24816:   cssSize.height += aHeightDif;
 24816: 
 24816:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&cssSize.width,
 24816:                                                 &cssSize.height),
     1:                     NS_ERROR_FAILURE);
     1: 
 24816:   nsIntSize newDevSize(CSSToDevIntPixels(cssSize));
 24816: 
 24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetSize(newDevSize.width,
 24816:                                             newDevSize.height,
 80486:                                             true),
 24816:                     NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::SizeToContent()
     1: {
     1:   FORWARD_TO_OUTER(SizeToContent, (), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   if (!mDocShell) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   /*
 13308:    * If caller is not chrome and the user has not explicitly exempted the site,
 13308:    * prevent window.sizeToContent() by exiting early
     1:    */
     1: 
 13308:   if (!CanMoveResizeWindows() || IsFrame()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // The content viewer does a check to make sure that it's a content
     1:   // viewer for a toplevel docshell.
     1:   
     1:   nsCOMPtr<nsIContentViewer> cv;
     1:   mDocShell->GetContentViewer(getter_AddRefs(cv));
     1:   nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(cv));
     1:   NS_ENSURE_TRUE(markupViewer, NS_ERROR_FAILURE);
     1:   NS_ENSURE_SUCCESS(markupViewer->SizeToContent(), NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetWindowRoot(nsIDOMEventTarget **aWindowRoot)
     1: {
 38336:   nsCOMPtr<nsPIWindowRoot> root = GetTopWindowRoot();
 38336:   return CallQueryInterface(root, aWindowRoot);
 38336: }
 38336: 
 38336: already_AddRefed<nsPIWindowRoot>
 38336: nsGlobalWindow::GetTopWindowRoot()
 38336: {
 73870:   nsIDOMWindow *rootWindow = GetPrivateRoot();
     1:   nsCOMPtr<nsPIDOMWindow> piWin(do_QueryInterface(rootWindow));
 38336:   if (!piWin)
106838:     return nullptr;
 38336: 
 38336:   nsCOMPtr<nsPIWindowRoot> window = do_QueryInterface(piWin->GetChromeEventHandler());
 38336:   return window.forget();
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::Scroll(int32_t aXScroll, int32_t aYScroll)
     1: {
     1:   return ScrollTo(aXScroll, aYScroll);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ScrollTo(int32_t aXScroll, int32_t aYScroll)
     1: {
     1:   FlushPendingNotifications(Flush_Layout);
 37063:   nsIScrollableFrame *sf = GetScrollFrame();
 37063: 
 37063:   if (sf) {
     1:     // Here we calculate what the max pixel value is that we can
     1:     // scroll to, we do this by dividing maxint with the pixel to
     1:     // twips conversion factor, and substracting 4, the 4 comes from
     1:     // experimenting with this value, anything less makes the view
     1:     // code not scroll correctly, I have no idea why. -- jst
108991:     const int32_t maxpx = nsPresContext::AppUnitsToIntCSSPixels(0x7fffffff) - 4;
     1: 
     1:     if (aXScroll > maxpx) {
     1:       aXScroll = maxpx;
     1:     }
     1: 
     1:     if (aYScroll > maxpx) {
     1:       aYScroll = maxpx;
     1:     }
 98475:     sf->ScrollToCSSPixels(nsIntPoint(aXScroll, aYScroll));
 37063:   }
 37063: 
 37063:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ScrollBy(int32_t aXScrollDif, int32_t aYScrollDif)
     1: {
     1:   FlushPendingNotifications(Flush_Layout);
 37063:   nsIScrollableFrame *sf = GetScrollFrame();
 37063: 
 37063:   if (sf) {
 37063:     nsPoint scrollPos = sf->GetScrollPosition();
 37063:     // It seems like it would make more sense for ScrollBy to use
 37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
 37063:     // Perhaps Web content does too.
 37063:     return ScrollTo(nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x) + aXScrollDif,
 37063:                     nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y) + aYScrollDif);
 37063:   }
 37063: 
 37063:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ScrollByLines(int32_t numLines)
     1: {
     1:   FlushPendingNotifications(Flush_Layout);
 37063:   nsIScrollableFrame *sf = GetScrollFrame();
 37063:   if (sf) {
 37063:     // It seems like it would make more sense for ScrollByLines to use
 37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
 37063:     // Perhaps Web content does too.
 37063:     sf->ScrollBy(nsIntPoint(0, numLines), nsIScrollableFrame::LINES,
 37063:                  nsIScrollableFrame::INSTANT);
 37063:   }
 37063: 
 37063:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ScrollByPages(int32_t numPages)
     1: {
     1:   FlushPendingNotifications(Flush_Layout);
 37063:   nsIScrollableFrame *sf = GetScrollFrame();
 37063:   if (sf) {
 37063:     // It seems like it would make more sense for ScrollByPages to use
 37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
 37063:     // Perhaps Web content does too.
 37063:     sf->ScrollBy(nsIntPoint(0, numPages), nsIScrollableFrame::PAGES,
 37063:                  nsIScrollableFrame::INSTANT);
 37063:   }
 37063: 
 37063:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ClearTimeout(int32_t aHandle)
 82813: {
 82813:   if (aHandle <= 0) {
 82813:     return NS_OK;
 82813:   }
 82813: 
 82813:   return ClearTimeoutOrInterval(aHandle);
 82813: }
 82813: 
 82813: NS_IMETHODIMP
108991: nsGlobalWindow::ClearInterval(int32_t aHandle)
 82813: {
 82813:   if (aHandle <= 0) {
 82813:     return NS_OK;
 82813:   }
 82813: 
 82813:   return ClearTimeoutOrInterval(aHandle);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::SetTimeout(int32_t *_retval)
     1: {
 80486:   return SetTimeoutOrInterval(false, _retval);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::SetInterval(int32_t *_retval)
     1: {
 80486:   return SetTimeoutOrInterval(true, _retval);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::SetResizable(bool aResizable)
     1: {
     1:   // nop
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: ReportUseOfDeprecatedMethod(nsGlobalWindow* aWindow, const char* aWarning)
     1: {
     1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(aWindow->GetExtantDocument());
 84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                   "DOM Events", doc,
 84636:                                   nsContentUtils::eDOM_PROPERTIES,
 84636:                                   aWarning);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::CaptureEvents(int32_t aEventFlags)
     1: {
     1:   ReportUseOfDeprecatedMethod(this, "UseOfCaptureEventsWarning");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalWindow::ReleaseEvents(int32_t aEventFlags)
     1: {
     1:   ReportUseOfDeprecatedMethod(this, "UseOfReleaseEventsWarning");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::RouteEvent(nsIDOMEvent* aEvt)
     1: {
     1:   ReportUseOfDeprecatedMethod(this, "UseOfRouteEventWarning");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::EnableExternalCapture()
     1: {
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::DisableExternalCapture()
     1: {
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: static
 79445: bool IsPopupBlocked(nsIDOMDocument* aDoc)
     1: {
     1:   nsCOMPtr<nsIPopupWindowManager> pm =
     1:     do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
     1: 
     1:   if (!pm) {
 80486:     return false;
     1:   }
     1: 
 79445:   bool blocked = true;
     1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDoc));
     1: 
     1:   if (doc) {
108991:     uint32_t permission = nsIPopupWindowManager::ALLOW_POPUP;
104689:     pm->TestPermission(doc->NodePrincipal(), &permission);
     1:     blocked = (permission == nsIPopupWindowManager::DENY_POPUP);
     1:   }
     1:   return blocked;
     1: }
     1: 
 51581: /* static */
 51581: void 
 51581: nsGlobalWindow::FirePopupBlockedEvent(nsIDOMDocument* aDoc,
     1:                                       nsIDOMWindow *aRequestingWindow, nsIURI *aPopupURI,
     1:                                       const nsAString &aPopupWindowName,
     1:                                       const nsAString &aPopupWindowFeatures)
     1: {
     1:   if (aDoc) {
     1:     // Fire a "DOMPopupBlocked" event so that the UI can hear about
     1:     // blocked popups.
     1:     nsCOMPtr<nsIDOMEvent> event;
 70359:     aDoc->CreateEvent(NS_LITERAL_STRING("PopupBlockedEvents"),
     1:                       getter_AddRefs(event));
     1:     if (event) {
     1:       nsCOMPtr<nsIDOMPopupBlockedEvent> pbev(do_QueryInterface(event));
     1:       pbev->InitPopupBlockedEvent(NS_LITERAL_STRING("DOMPopupBlocked"),
 80486:                                   true, true, aRequestingWindow,
     1:                                   aPopupURI, aPopupWindowName,
     1:                                   aPopupWindowFeatures);
101616:       event->SetTrusted(true);
     1: 
     1:       nsCOMPtr<nsIDOMEventTarget> targ(do_QueryInterface(aDoc));
 79445:       bool defaultActionEnabled;
     1:       targ->DispatchEvent(event, &defaultActionEnabled);
     1:     }
     1:   }
     1: }
     1: 
     1: void FirePopupWindowEvent(nsIDOMDocument* aDoc)
     1: {
     1:   // Fire a "PopupWindow" event
     1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDoc));
     1:   nsContentUtils::DispatchTrustedEvent(doc, aDoc,
     1:                                        NS_LITERAL_STRING("PopupWindow"),
 80486:                                        true, true);
     1: }
     1: 
     1: // static
 79445: bool
     1: nsGlobalWindow::CanSetProperty(const char *aPrefName)
     1: {
     1:   // Chrome can set any property.
     1:   if (nsContentUtils::IsCallerTrustedForWrite()) {
 80486:     return true;
     1:   }
     1: 
     1:   // If the pref is set to true, we can not set the property
     1:   // and vice versa.
 79445:   return !Preferences::GetBool(aPrefName, true);
 79445: }
 79445: 
 79445: bool
 34524: nsGlobalWindow::PopupWhitelisted()
 34524: {
 34524:   if (!IsPopupBlocked(mDocument))
 80486:     return true;
 34524: 
 34524:   nsCOMPtr<nsIDOMWindow> parent;
 34524: 
 34524:   if (NS_FAILED(GetParent(getter_AddRefs(parent))) ||
 34524:       parent == static_cast<nsIDOMWindow*>(this))
 34524:   {
 80486:     return false;
 34524:   }
 34524: 
 34524:   return static_cast<nsGlobalWindow*>
 34524:                     (static_cast<nsIDOMWindow*>
 34524:                                 (parent.get()))->PopupWhitelisted();
 34524: }
     1: 
     1: /*
     1:  * Examine the current document state to see if we're in a way that is
     1:  * typically abused by web designers. The window.open code uses this
     1:  * routine to determine whether to allow the new window.
 34524:  * Returns a value from the PopupControlState enum.
     1:  */
     1: PopupControlState
 34524: nsGlobalWindow::RevisePopupAbuseLevel(PopupControlState aControl)
 34524: {
 34524:   FORWARD_TO_OUTER(RevisePopupAbuseLevel, (aControl), aControl);
     1: 
     1:   NS_ASSERTION(mDocShell, "Must have docshell");
     1:   
     1:   nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(mDocShell));
     1: 
 30709:   NS_ASSERTION(item, "Docshell doesn't implement nsIDocShellTreeItem?");
     1: 
108991:   int32_t type = nsIDocShellTreeItem::typeChrome;
     1:   item->GetItemType(&type);
     1:   if (type != nsIDocShellTreeItem::typeContent)
     1:     return openAllowed;
     1: 
 34524:   PopupControlState abuse = aControl;
 34524:   switch (abuse) {
 34524:   case openControlled:
 34524:   case openAbused:
 34524:   case openOverridden:
 34524:     if (PopupWhitelisted())
 34524:       abuse = PopupControlState(abuse - 1);
 34524:   case openAllowed: break;
 34524:   default:
 34524:     NS_WARNING("Strange PopupControlState!");
 34524:   }
     1: 
     1:   // limit the number of simultaneously open popups
     1:   if (abuse == openAbused || abuse == openControlled) {
108991:     int32_t popupMax = Preferences::GetInt("dom.popup_maximum", -1);
     1:     if (popupMax >= 0 && gOpenPopupSpamCount >= popupMax)
     1:       abuse = openOverridden;
     1:   }
     1: 
     1:   return abuse;
     1: }
     1: 
     1: /* If a window open is blocked, fire the appropriate DOM events.
     1:    aBlocked signifies we just blocked a popup.
     1:    aWindow signifies we just opened what is probably a popup.
     1: */
     1: void
 79445: nsGlobalWindow::FireAbuseEvents(bool aBlocked, bool aWindow,
     1:                                 const nsAString &aPopupURL,
     1:                                 const nsAString &aPopupWindowName,
     1:                                 const nsAString &aPopupWindowFeatures)
     1: {
     1:   // fetch the URI of the window requesting the opened window
     1: 
     1:   nsCOMPtr<nsIDOMWindow> topWindow;
     1:   GetTop(getter_AddRefs(topWindow));
     1:   if (!topWindow)
     1:     return;
     1: 
     1:   nsCOMPtr<nsIDOMDocument> topDoc;
     1:   topWindow->GetDocument(getter_AddRefs(topDoc));
     1: 
     1:   nsCOMPtr<nsIURI> popupURI;
     1: 
     1:   // build the URI of the would-have-been popup window
     1:   // (see nsWindowWatcher::URIfromURL)
     1: 
     1:   // first, fetch the opener's base URI
     1: 
     1:   nsIURI *baseURL = 0;
     1: 
 18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
     1:   nsCOMPtr<nsIDOMWindow> contextWindow;
 18868: 
     1:   if (cx) {
     1:     nsIScriptContext *currentCX = nsJSUtils::GetDynamicScriptContext(cx);
     1:     if (currentCX) {
     1:       contextWindow = do_QueryInterface(currentCX->GetGlobalObject());
     1:     }
     1:   }
     1:   if (!contextWindow)
  3233:     contextWindow = static_cast<nsIDOMWindow*>(this);
     1: 
     1:   nsCOMPtr<nsIDOMDocument> domdoc;
     1:   contextWindow->GetDocument(getter_AddRefs(domdoc));
     1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domdoc));
     1:   if (doc)
 41900:     baseURL = doc->GetDocBaseURI();
     1: 
     1:   // use the base URI to build what would have been the popup's URI
     1:   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
     1:   if (ios)
     1:     ios->NewURI(NS_ConvertUTF16toUTF8(aPopupURL), 0, baseURL,
     1:                 getter_AddRefs(popupURI));
     1: 
     1:   // fire an event chock full of informative URIs
     1:   if (aBlocked)
     1:     FirePopupBlockedEvent(topDoc, this, popupURI, aPopupWindowName,
     1:                           aPopupWindowFeatures);
     1:   if (aWindow)
     1:     FirePopupWindowEvent(topDoc);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Open(const nsAString& aUrl, const nsAString& aName,
     1:                      const nsAString& aOptions, nsIDOMWindow **_retval)
     1: {
     1:   return OpenInternal(aUrl, aName, aOptions,
 80486:                       false,          // aDialog
 80486:                       false,          // aContentModal
 80486:                       true,           // aCalledNoScript
 80486:                       false,          // aDoJSFixups
108307:                       true,           // aNavigate
106838:                       nullptr, nullptr,  // No args
     1:                       GetPrincipal(),    // aCalleePrincipal
106838:                       nullptr,           // aJSCallerContext
     1:                       _retval);
     1: }
     1: 
     1: NS_IMETHODIMP
 19026: nsGlobalWindow::OpenJS(const nsAString& aUrl, const nsAString& aName,
 19026:                        const nsAString& aOptions, nsIDOMWindow **_retval)
 19026: {
 19026:   return OpenInternal(aUrl, aName, aOptions,
 80486:                       false,          // aDialog
 80486:                       false,          // aContentModal
 80486:                       false,          // aCalledNoScript
 80486:                       true,           // aDoJSFixups
108307:                       true,           // aNavigate
106838:                       nullptr, nullptr,  // No args
     1:                       GetPrincipal(),    // aCalleePrincipal
 19026:                       nsContentUtils::GetCurrentJSContext(), // aJSCallerContext
     1:                       _retval);
     1: }
     1: 
     1: // like Open, but attaches to the new window any extra parameters past
     1: // [features] as a JS property named "arguments"
     1: NS_IMETHODIMP
     1: nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
     1:                            const nsAString& aOptions,
     1:                            nsISupports* aExtraArgument, nsIDOMWindow** _retval)
     1: {
     1:   return OpenInternal(aUrl, aName, aOptions,
 80486:                       true,                    // aDialog
 80486:                       false,                   // aContentModal
 80486:                       true,                    // aCalledNoScript
 80486:                       false,                   // aDoJSFixups
108307:                       true,                    // aNavigate
106838:                       nullptr, aExtraArgument,    // Arguments
     1:                       GetPrincipal(),             // aCalleePrincipal
106838:                       nullptr,                    // aJSCallerContext
     1:                       _retval);
     1: }
     1: 
108307: // Like Open, but passes aNavigate=false.
108307: /* virtual */ nsresult
108307: nsGlobalWindow::OpenNoNavigate(const nsAString& aUrl,
108307:                                const nsAString& aName,
108307:                                const nsAString& aOptions,
108307:                                nsIDOMWindow **_retval)
108307: {
108307:   return OpenInternal(aUrl, aName, aOptions,
108307:                       false,          // aDialog
108307:                       false,          // aContentModal
108307:                       true,           // aCalledNoScript
108307:                       false,          // aDoJSFixups
108307:                       false,          // aNavigate
108307:                       nullptr, nullptr,  // No args
108307:                       GetPrincipal(),    // aCalleePrincipal
108311:                       nullptr,           // aJSCallerContext
108307:                       _retval);
108307: 
108307: }
108307: 
     1: NS_IMETHODIMP
 19026: nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
 19026:                            const nsAString& aOptions, nsIDOMWindow** _retval)
     1: {
     1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
     1:     return NS_ERROR_DOM_SECURITY_ERR;
     1:   }
     1: 
106838:   nsAXPCNativeCallContext *ncc = nullptr;
     1:   nsresult rv = nsContentUtils::XPConnect()->
 10286:     GetCurrentNativeCallContext(&ncc);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (!ncc)
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
106838:   JSContext *cx = nullptr;
     1: 
     1:   rv = ncc->GetJSContext(&cx);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:   uint32_t argc;
106838:   jsval *argv = nullptr;
     1: 
     1:   // XXX - need to get this as nsISupports?
     1:   ncc->GetArgc(&argc);
     1:   ncc->GetArgvPtr(&argv);
     1: 
     1:   // Strip the url, name and options from the args seen by scripts.
108991:   uint32_t argOffset = argc < 3 ? argc : 3;
 91972:   nsCOMPtr<nsIJSArgArray> argvArray;
 19026:   rv = NS_CreateJSArgv(cx, argc - argOffset, argv + argOffset,
 19026:                        getter_AddRefs(argvArray));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 19026:   return OpenInternal(aUrl, aName, aOptions,
 80486:                       true,             // aDialog
 80486:                       false,            // aContentModal
 80486:                       false,            // aCalledNoScript
 80486:                       false,            // aDoJSFixups
108307:                       true,                // aNavigate
106838:                       argvArray, nullptr,  // Arguments
     1:                       GetPrincipal(),      // aCalleePrincipal
     1:                       cx,                  // aJSCallerContext
     1:                       _retval);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetFrames(nsIDOMWindow** aFrames)
     1: {
     1:   FORWARD_TO_OUTER(GetFrames, (aFrames), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   *aFrames = this;
     1:   NS_ADDREF(*aFrames);
     1: 
     1:   FlushPendingNotifications(Flush_ContentAndNotify);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 94863: JSObject* nsGlobalWindow::CallerGlobal()
 10976: {
 18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
 18868:   if (!cx) {
 18868:     NS_ERROR("Please don't call this method from C++!");
 18868: 
106838:     return nullptr;
 10976:   }
 10976: 
 95519:   return JS_GetScriptedGlobal(cx);
 94863: }
 94863: 
 94863: nsGlobalWindow*
 94863: nsGlobalWindow::CallerInnerWindow()
 94863: {
 94863:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
 94863:   if (!cx) {
 94863:     NS_ERROR("Please don't call this method from C++!");
 94863: 
106838:     return nullptr;
 94863:   }
 94863: 
 94863:   JSObject *scope = CallerGlobal();
109257:   JSAutoCompartment ac(cx, scope);
 10976: 
 10976:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
 10976:   nsContentUtils::XPConnect()->
 80154:     GetWrappedNativeOfJSObject(cx, scope, getter_AddRefs(wrapper));
 10976:   if (!wrapper)
106838:     return nullptr;
 10976: 
 10976:   // The calling window must be holding a reference, so we can just return a
 10976:   // raw pointer here and let the QI's addref be balanced by the nsCOMPtr
 10976:   // destructor's release.
 10976:   nsCOMPtr<nsPIDOMWindow> win = do_QueryWrappedNative(wrapper);
 11028:   if (!win)
 11028:     return GetCurrentInnerWindowInternal();
 10976:   return static_cast<nsGlobalWindow*>(win.get());
 10976: }
 10976: 
 14898: /**
 14898:  * Class used to represent events generated by calls to Window.postMessage,
 14898:  * which asynchronously creates and dispatches events.
 14898:  */
 14898: class PostMessageEvent : public nsRunnable
 14898: {
 14898:   public:
 14898:     NS_DECL_NSIRUNNABLE
 14898: 
 14898:     PostMessageEvent(nsGlobalWindow* aSource,
 14898:                      const nsAString& aCallerOrigin,
 14898:                      nsGlobalWindow* aTargetWindow,
 14898:                      nsIURI* aProvidedOrigin,
 79445:                      bool aTrustedCaller)
 14898:     : mSource(aSource),
 14898:       mCallerOrigin(aCallerOrigin),
106838:       mMessage(nullptr),
 70373:       mMessageLen(0),
 14898:       mTargetWindow(aTargetWindow),
 14898:       mProvidedOrigin(aProvidedOrigin),
 14898:       mTrustedCaller(aTrustedCaller)
 14898:     {
 14898:       MOZ_COUNT_CTOR(PostMessageEvent);
 14898:     }
 14898:     
 14898:     ~PostMessageEvent()
 14898:     {
 70373:       NS_ASSERTION(!mMessage, "Message should have been deserialized!");
 14898:       MOZ_COUNT_DTOR(PostMessageEvent);
 14898:     }
 14898: 
 70373:     void SetJSData(JSAutoStructuredCloneBuffer& aBuffer)
 70373:     {
 70373:       NS_ASSERTION(!mMessage && mMessageLen == 0, "Don't call twice!");
 70373:       aBuffer.steal(&mMessage, &mMessageLen);
 70373:     }
 70373: 
 75350:     bool StoreISupports(nsISupports* aSupports)
 75350:     {
 75350:       mSupportsArray.AppendElement(aSupports);
 75350:       return true;
 75350:     }
 75350: 
 14898:   private:
 14898:     nsRefPtr<nsGlobalWindow> mSource;
 14898:     nsString mCallerOrigin;
 84755:     uint64_t* mMessage;
 70373:     size_t mMessageLen;
 14898:     nsRefPtr<nsGlobalWindow> mTargetWindow;
 14898:     nsCOMPtr<nsIURI> mProvidedOrigin;
 79445:     bool mTrustedCaller;
 75350:     nsTArray<nsCOMPtr<nsISupports> > mSupportsArray;
 14898: };
 14898: 
 75350: namespace {
 75350: 
 75350: struct StructuredCloneInfo {
 75350:   PostMessageEvent* event;
 79445:   bool subsumes;
 75350: };
 75350: 
 75350: static JSObject*
 75350: PostMessageReadStructuredClone(JSContext* cx,
 75350:                                JSStructuredCloneReader* reader,
101116:                                uint32_t tag,
101116:                                uint32_t data,
 75350:                                void* closure)
 75350: {
 78436:   NS_ASSERTION(closure, "Must have closure!");
 75350: 
 75350:   if (tag == SCTAG_DOM_BLOB || tag == SCTAG_DOM_FILELIST) {
 75350:     NS_ASSERTION(!data, "Data should be empty");
 75350: 
 75350:     nsISupports* supports;
 75350:     if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
 80154:       JSObject* global = JS_GetGlobalForScopeChain(cx);
 75350:       if (global) {
 75350:         jsval val;
 75350:         nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
 75350:         if (NS_SUCCEEDED(nsContentUtils::WrapNative(cx, global, supports,
 75350:                                                     &val,
 75350:                                                     getter_AddRefs(wrapper)))) {
 75350:           return JSVAL_TO_OBJECT(val);
 75350:         }
 75350:       }
 75350:     }
 75350:   }
 75350: 
 75350:   const JSStructuredCloneCallbacks* runtimeCallbacks =
 87277:     js::GetContextStructuredCloneCallbacks(cx);
 75350: 
 75350:   if (runtimeCallbacks) {
106838:     return runtimeCallbacks->read(cx, reader, tag, data, nullptr);
 75350:   }
 75350: 
109167:   return nullptr;
 75350: }
 75350: 
 75350: static JSBool
 75350: PostMessageWriteStructuredClone(JSContext* cx,
 75350:                                 JSStructuredCloneWriter* writer,
 75350:                                 JSObject* obj,
 75350:                                 void *closure)
 75350: {
 75350:   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
 75350:   NS_ASSERTION(scInfo, "Must have scInfo!");
 75350: 
 75350:   nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
 75350:   nsContentUtils::XPConnect()->
 75350:     GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrappedNative));
 75350:   if (wrappedNative) {
108991:     uint32_t scTag = 0;
 75350:     nsISupports* supports = wrappedNative->Native();
 75350: 
 75350:     nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(supports);
 75350:     if (blob && scInfo->subsumes)
 75350:       scTag = SCTAG_DOM_BLOB;
 75350: 
 75350:     nsCOMPtr<nsIDOMFileList> list = do_QueryInterface(supports);
 75350:     if (list && scInfo->subsumes)
 75350:       scTag = SCTAG_DOM_FILELIST;
 75350: 
 75350:     if (scTag)
 75350:       return JS_WriteUint32Pair(writer, scTag, 0) &&
 75350:              JS_WriteBytes(writer, &supports, sizeof(supports)) &&
 75350:              scInfo->event->StoreISupports(supports);
 75350:   }
 75350: 
 75350:   const JSStructuredCloneCallbacks* runtimeCallbacks =
 87277:     js::GetContextStructuredCloneCallbacks(cx);
 75350: 
 75350:   if (runtimeCallbacks) {
106838:     return runtimeCallbacks->write(cx, writer, obj, nullptr);
 75350:   }
 75350: 
 75350:   return JS_FALSE;
 75350: }
 75350: 
 75350: JSStructuredCloneCallbacks kPostMessageCallbacks = {
 75350:   PostMessageReadStructuredClone,
 75350:   PostMessageWriteStructuredClone,
106838:   nullptr
 75350: };
 75350: 
 75350: } // anonymous namespace
 75350: 
 14898: NS_IMETHODIMP
 14898: PostMessageEvent::Run()
 14898: {
 14898:   NS_ABORT_IF_FALSE(mTargetWindow->IsOuterWindow(),
 14898:                     "should have been passed an outer window!");
 14898:   NS_ABORT_IF_FALSE(!mSource || mSource->IsOuterWindow(),
 14898:                     "should have been passed an outer window!");
 14898: 
 70373:   // Get the JSContext for the target window
106838:   JSContext* cx = nullptr;
 70373:   nsIScriptContext* scriptContext = mTargetWindow->GetContext();
 70821:   if (scriptContext) {
 78415:     cx = scriptContext->GetNativeContext();
 70821:   }
 70821: 
 70821:   if (!cx) {
 70821:     // This can happen if mTargetWindow has been closed.  To avoid leaking,
 70821:     // we need to find a JSContext.
 70821:     nsIThreadJSContextStack* cxStack = nsContentUtils::ThreadJSContextStack();
 70821:     if (cxStack) {
 97744:       cx = cxStack->GetSafeJSContext();
 70821:     }
 70821: 
 70821:     if (!cx) {
 70821:       NS_WARNING("Cannot find a JSContext!  Leaking PostMessage buffer.");
 70821:       return NS_ERROR_FAILURE;
 70821:     }
 70821:   }
 70373: 
 70373:   // If we bailed before this point we're going to leak mMessage, but
 70373:   // that's probably better than crashing.
 70373: 
 70373:   // Ensure that the buffer is freed even if we fail to post the message
 70373:   JSAutoStructuredCloneBuffer buffer;
 74542:   buffer.adopt(mMessage, mMessageLen);
106838:   mMessage = nullptr;
 70373:   mMessageLen = 0;
 70373: 
 39378:   nsRefPtr<nsGlobalWindow> targetWindow;
 39378:   if (mTargetWindow->IsClosedOrClosing() ||
 39378:       !(targetWindow = mTargetWindow->GetCurrentInnerWindowInternal()) ||
 39378:       targetWindow->IsClosedOrClosing())
 15240:     return NS_OK;
 15240: 
 14898:   NS_ABORT_IF_FALSE(targetWindow->IsInnerWindow(),
 14898:                     "we ordered an inner window!");
 14898: 
 14898:   // Ensure that any origin which might have been provided is the origin of this
 14898:   // window's document.  Note that we do this *now* instead of when postMessage
 14898:   // is called because the target window might have been navigated to a
 14898:   // different location between then and now.  If this check happened when
 14898:   // postMessage was called, it would be fairly easy for a malicious webpage to
 14898:   // intercept messages intended for another site by carefully timing navigation
 14898:   // of the target window so it changed location after postMessage but before
 14898:   // now.
 14898:   if (mProvidedOrigin) {
 14898:     // Get the target's origin either from its principal or, in the case the
 14898:     // principal doesn't carry a URI (e.g. the system principal), the target's
 14898:     // document.
 14898:     nsIPrincipal* targetPrin = targetWindow->GetPrincipal();
 14898:     if (!targetPrin)
 14898:       return NS_OK;
 14898:     nsCOMPtr<nsIURI> targetURI;
 14898:     if (NS_FAILED(targetPrin->GetURI(getter_AddRefs(targetURI))))
 14898:       return NS_OK;
 14898:     if (!targetURI) {
 14898:       targetURI = targetWindow->mDoc->GetDocumentURI();
 14898:       if (!targetURI)
 14898:         return NS_OK;
 14898:     }
 14898: 
 14898:     // Note: This is contrary to the spec with respect to file: URLs, which
 14898:     //       the spec groups into a single origin, but given we intentionally
 14898:     //       don't do that in other places it seems better to hold the line for
 14898:     //       now.  Long-term, we want HTML5 to address this so that we can
 14898:     //       be compliant while being safer.
 14898:     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
 14898:     nsresult rv =
 80486:       ssm->CheckSameOriginURI(mProvidedOrigin, targetURI, true);
 14898:     if (NS_FAILED(rv))
 14898:       return NS_OK;
 14898:   }
 14898: 
 70373:   // Deserialize the structured clone data
 70373:   jsval messageData;
 70373:   {
 70373:     JSAutoRequest ar(cx);
 75350:     StructuredCloneInfo scInfo;
 75350:     scInfo.event = this;
 75350: 
 75350:     if (!buffer.read(cx, &messageData, &kPostMessageCallbacks, &scInfo))
 70373:       return NS_ERROR_DOM_DATA_CLONE_ERR;
 70373:   }
 14898: 
 14898:   // Create the event
 70359:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(targetWindow->mDocument);
 70359:   if (!domDoc)
 14898:     return NS_OK;
 14898:   nsCOMPtr<nsIDOMEvent> event;
 70359:   domDoc->CreateEvent(NS_LITERAL_STRING("MessageEvent"),
 14898:                       getter_AddRefs(event));
 14898:   if (!event)
 14898:     return NS_OK;
 14898: 
 14898:   nsCOMPtr<nsIDOMMessageEvent> message = do_QueryInterface(event);
 14898:   nsresult rv = message->InitMessageEvent(NS_LITERAL_STRING("message"),
 80486:                                           false /* non-bubbling */,
 80486:                                           true /* cancelable */,
 70373:                                           messageData,
 14898:                                           mCallerOrigin,
 14898:                                           EmptyString(),
 14898:                                           mSource);
 14898:   if (NS_FAILED(rv))
 14898:     return NS_OK;
 14898: 
 14898: 
 14898:   // We can't simply call dispatchEvent on the window because doing so ends
 14898:   // up flipping the trusted bit on the event, and we don't want that to
 14898:   // happen because then untrusted content can call postMessage on a chrome
 14898:   // window if it can get a reference to it.
 14898: 
 46225:   nsIPresShell *shell = targetWindow->mDoc->GetShell();
 14898:   nsRefPtr<nsPresContext> presContext;
 14898:   if (shell)
 14898:     presContext = shell->GetPresContext();
 14898: 
101616:   message->SetTrusted(mTrustedCaller);
101616:   nsEvent *internalEvent = message->GetInternalNSEvent();
 14898: 
 14898:   nsEventStatus status = nsEventStatus_eIgnore;
 14898:   nsEventDispatcher::Dispatch(static_cast<nsPIDOMWindow*>(mTargetWindow),
 14898:                               presContext,
 14898:                               internalEvent,
 14898:                               message,
 14898:                               &status);
 14898:   return NS_OK;
 14898: }
 14898: 
 11363: NS_IMETHODIMP
 70373: nsGlobalWindow::PostMessageMoz(const jsval& aMessage,
 70373:                                const nsAString& aOrigin,
 70373:                                JSContext* aCx)
 70373: {
 70373:   FORWARD_TO_OUTER(PostMessageMoz, (aMessage, aOrigin, aCx),
 70373:                    NS_ERROR_NOT_INITIALIZED);
 10976: 
 10976:   //
 10976:   // Window.postMessage is an intentional subversion of the same-origin policy.
 10976:   // As such, this code must be particularly careful in the information it
 10976:   // exposes to calling code.
 10976:   //
 10976:   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-crossDocumentMessages.html
 10976:   //
 10976: 
 10976:   // First, get the caller's window
 10976:   nsRefPtr<nsGlobalWindow> callerInnerWin = CallerInnerWindow();
 94863:   nsIPrincipal* callerPrin;
 94863:   if (callerInnerWin) {
 14898:     NS_ABORT_IF_FALSE(callerInnerWin->IsInnerWindow(),
 14898:                       "should have gotten an inner window here");
 10976: 
 12322:     // Compute the caller's origin either from its principal or, in the case the
 12322:     // principal doesn't carry a URI (e.g. the system principal), the caller's
 14898:     // document.  We must get this now instead of when the event is created and
 14898:     // dispatched, because ultimately it is the identity of the calling window
 14898:     // *now* that determines who sent the message (and not an identity which might
 14898:     // have changed due to intervening navigations).
 94863:     callerPrin = callerInnerWin->GetPrincipal();
 94863:   }
 94863:   else {
 94863:     // In case the global is not a window, it can be a sandbox, and the sandbox's
 94863:     // principal can be used for the security check.
 94863:     JSObject *global = CallerGlobal();
 94863:     NS_ASSERTION(global, "Why is there no global object?");
 94863:     JSCompartment *compartment = js::GetObjectCompartment(global);
 94863:     callerPrin = xpc::GetCompartmentPrincipal(compartment);
 94863:   }
 10976:   if (!callerPrin)
 10976:     return NS_OK;
 24084: 
 14898:   nsCOMPtr<nsIURI> callerOuterURI;
 14898:   if (NS_FAILED(callerPrin->GetURI(getter_AddRefs(callerOuterURI))))
 14898:     return NS_OK;
 24084: 
 24084:   nsAutoString origin;
 24084:   if (callerOuterURI) {
 24084:     // if the principal has a URI, use that to generate the origin
 24084:     nsContentUtils::GetUTFOrigin(callerPrin, origin);
 24084:   }
 94863:   else if (callerInnerWin) {
 24084:     // otherwise use the URI of the document to generate origin
 94863:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(callerInnerWin->GetExtantDocument());
 10976:     if (!doc)
 10976:       return NS_OK;
 14898:     callerOuterURI = doc->GetDocumentURI();
 24084:     // if the principal has a URI, use that to generate the origin
 24084:     nsContentUtils::GetUTFOrigin(callerOuterURI, origin);
 24084:   }
 94863:   else {
 94863:     // in case of a sandbox with a system principal origin can be empty
 94863:     if (!nsContentUtils::IsSystemPrincipal(callerPrin))
 94863:       return NS_OK;
 94863:   }
 12322: 
 14898:   // Convert the provided origin string into a URI for comparison purposes.
 14898:   // "*" indicates no specific origin is required.
 12322:   nsCOMPtr<nsIURI> providedOrigin;
 14898:   if (!aOrigin.EqualsASCII("*")) {
 12322:     if (NS_FAILED(NS_NewURI(getter_AddRefs(providedOrigin), aOrigin)))
 12322:       return NS_ERROR_DOM_SYNTAX_ERR;
 24084:     if (NS_FAILED(providedOrigin->SetUserPass(EmptyCString())) ||
 24084:         NS_FAILED(providedOrigin->SetPath(EmptyCString())))
 24084:       return NS_OK;
 24084:   }
 10976: 
 14898:   // Create and asynchronously dispatch a runnable which will handle actual DOM
 14898:   // event creation and dispatch.
 14898:   nsRefPtr<PostMessageEvent> event =
 94863:     new PostMessageEvent(nsContentUtils::IsCallerChrome() || !callerInnerWin
106838:                          ? nullptr
 14898:                          : callerInnerWin->GetOuterWindowInternal(),
 24084:                          origin,
 14898:                          this,
 14898:                          providedOrigin,
 14898:                          nsContentUtils::IsCallerTrustedForWrite());
 70373: 
 70373:   // We *must* clone the data here, or the jsval could be modified
 70373:   // by script
 70373:   JSAutoStructuredCloneBuffer buffer;
 75350:   StructuredCloneInfo scInfo;
 75350:   scInfo.event = event;
 75350: 
 75350:   nsIPrincipal* principal = GetPrincipal();
 75350:   if (NS_FAILED(callerPrin->Subsumes(principal, &scInfo.subsumes)))
 75350:     return NS_ERROR_DOM_DATA_CLONE_ERR;
 75350: 
 75350:   if (!buffer.write(aCx, aMessage, &kPostMessageCallbacks, &scInfo))
 70373:     return NS_ERROR_DOM_DATA_CLONE_ERR;
 70373: 
 70373:   event->SetJSData(buffer);
 70373: 
 14898:   return NS_DispatchToCurrentThread(event);
 10976: }
 10976: 
     1: class nsCloseEvent : public nsRunnable {
 39378: 
 39378:   nsRefPtr<nsGlobalWindow> mWindow;
 39378: 
     1:   nsCloseEvent(nsGlobalWindow *aWindow)
     1:     : mWindow(aWindow)
 39378:   {}
 39378: 
 39378: public:
 39378: 
 39378:   static nsresult
 39378:   PostCloseEvent(nsGlobalWindow* aWindow) {
 39378:     nsCOMPtr<nsIRunnable> ev = new nsCloseEvent(aWindow);
 39378:     nsresult rv = NS_DispatchToCurrentThread(ev);
 39378:     if (NS_SUCCEEDED(rv))
 39378:       aWindow->MaybeForgiveSpamCount();
 39378:     return rv;
     1:   }
     1: 
     1:   NS_IMETHOD Run() {
     1:     if (mWindow)
     1:       mWindow->ReallyCloseWindow();
     1:     return NS_OK;
     1:   }
     1: 
     1: };
     1: 
 79445: bool
 37611: nsGlobalWindow::CanClose()
 37611: {
 37611:   if (!mDocShell)
 80486:     return true;
 37611: 
 37611:   // Ask the content viewer whether the toplevel window can close.
 37611:   // If the content viewer returns false, it is responsible for calling
 37611:   // Close() as soon as it is possible for the window to close.
 37611:   // This allows us to not close the window while printing is happening.
 37611: 
 37611:   nsCOMPtr<nsIContentViewer> cv;
 37611:   mDocShell->GetContentViewer(getter_AddRefs(cv));
 37611:   if (cv) {
 79445:     bool canClose;
 80486:     nsresult rv = cv->PermitUnload(false, &canClose);
 37611:     if (NS_SUCCEEDED(rv) && !canClose)
 80486:       return false;
 37611: 
 37611:     rv = cv->RequestWindowClose(&canClose);
 37611:     if (NS_SUCCEEDED(rv) && !canClose)
 80486:       return false;
 80486:   }
 80486: 
 80486:   return true;
 37611: }
 37611: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Close()
     1: {
     1:   FORWARD_TO_OUTER(Close, (), NS_ERROR_NOT_INITIALIZED);
     1: 
109100:   if (!mDocShell || IsInModalState() ||
109100:       (IsFrame() && !mDocShell->GetIsContentBoundary())) {
     1:     // window.close() is called on a frame in a frameset, on a window
     1:     // that's already closed, or on a window for which there's
     1:     // currently a modal dialog open. Ignore such calls.
 99422: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (mHavePendingClose) {
     1:     // We're going to be closed anyway; do nothing since we don't want
     1:     // to double-close
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (mBlockScriptedClosingFlag)
     1:   {
     1:     // A script's popup has been blocked and we don't want
     1:     // the window to be closed directly after this event,
     1:     // so the user can see that there was a blocked popup.
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Don't allow scripts from content to close windows
     1:   // that were not opened by script
     1:   if (!mHadOriginalOpener && !nsContentUtils::IsCallerTrustedForWrite()) {
 79445:     bool allowClose =
 79445:       Preferences::GetBool("dom.allow_scripts_to_close_windows", true);
     1:     if (!allowClose) {
     1:       // We're blocking the close operation
     1:       // report localized error msg in JS console
     1:       nsContentUtils::ReportToConsole(
 84636:           nsIScriptError::warningFlag,
 84636:           "DOM Window", mDoc,  // Better name for the category?
     1:           nsContentUtils::eDOM_PROPERTIES,
 84636:           "WindowCloseBlockedWarning");
     1: 
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
 37611:   if (!mInClose && !mIsClosed && !CanClose())
 37611:     return NS_OK;
     1: 
     1:   // Fire a DOM event notifying listeners that this window is about to
     1:   // be closed. The tab UI code may choose to cancel the default
     1:   // action for this event, if so, we won't actually close the window
     1:   // (since the tab UI code will close the tab in stead). Sure, this
     1:   // could be abused by content code, but do we care? I don't think
     1:   // so...
     1: 
 79445:   bool wasInClose = mInClose;
 80486:   mInClose = true;
     1: 
     1:   if (!DispatchCustomEvent("DOMWindowClose")) {
     1:     // Someone chose to prevent the default action for this event, if
     1:     // so, let's not close this window after all...
 99422: 
     1:     mInClose = wasInClose;
     1:     return NS_OK;
     1:   }
     1: 
 37611:   return FinalClose();
 37611: }
 37611: 
 37611: nsresult
 37611: nsGlobalWindow::ForceClose()
 37611: {
 37611:   if (IsFrame() || !mDocShell) {
 37611:     // This may be a frame in a frameset, or a window that's already closed.
 37611:     // Ignore such calls.
 37611: 
 37611:     return NS_OK;
 37611:   }
 37611: 
 37611:   if (mHavePendingClose) {
 37611:     // We're going to be closed anyway; do nothing since we don't want
 37611:     // to double-close
 37611:     return NS_OK;
 37611:   }
 37611: 
 80486:   mInClose = true;
 37611: 
 37611:   DispatchCustomEvent("DOMWindowClose");
 37611: 
 37611:   return FinalClose();
 37611: }
 37611: 
 37611: nsresult
 37611: nsGlobalWindow::FinalClose()
 37611: {
     1:   // Flag that we were closed.
 80486:   mIsClosed = true;
     1: 
     1:   nsCOMPtr<nsIJSContextStack> stack =
     1:     do_GetService(sJSStackContractID);
     1: 
106838:   JSContext *cx = nullptr;
     1: 
     1:   if (stack) {
     1:     stack->Peek(&cx);
     1:   }
     1: 
     1:   if (cx) {
     1:     nsIScriptContext *currentCX = nsJSUtils::GetDynamicScriptContext(cx);
     1: 
 47537:     if (currentCX && currentCX == GetContextInternal()) {
 91969:       currentCX->SetTerminationFunction(CloseWindow, this);
 80486:       mHavePendingClose = true;
 91969:       return NS_OK;
 91969:     }
 91969:   }
     1: 
     1:   // We may have plugins on the page that have issued this close from their
     1:   // event loop and because we currently destroy the plugin window with
     1:   // frames, we crash. So, if we are called from Javascript, post an event
     1:   // to really close the window.
 91969:   if (nsContentUtils::IsCallerChrome() ||
 91969:       NS_FAILED(nsCloseEvent::PostCloseEvent(this))) {
     1:     ReallyCloseWindow();
     1:   } else {
 80486:     mHavePendingClose = true;
     1:   }
     1: 
 91969:   return NS_OK;
     1: }
     1: 
     1: 
     1: void
     1: nsGlobalWindow::ReallyCloseWindow()
     1: {
     1:   FORWARD_TO_OUTER_VOID(ReallyCloseWindow, ());
     1: 
     1:   // Make sure we never reenter this method.
 80486:   mHavePendingClose = true;
     1: 
     1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
     1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
     1: 
     1:   // If there's no treeOwnerAsWin, this window must already be closed.
     1: 
     1:   if (treeOwnerAsWin) {
     1: 
     1:     // but if we're a browser window we could be in some nasty
     1:     // self-destroying cascade that we should mostly ignore
     1: 
     1:     nsCOMPtr<nsIDocShellTreeItem> docItem(do_QueryInterface(mDocShell));
     1:     if (docItem) {
     1:       nsCOMPtr<nsIBrowserDOMWindow> bwin;
     1:       nsCOMPtr<nsIDocShellTreeItem> rootItem;
     1:       docItem->GetRootTreeItem(getter_AddRefs(rootItem));
     1:       nsCOMPtr<nsIDOMWindow> rootWin(do_GetInterface(rootItem));
     1:       nsCOMPtr<nsIDOMChromeWindow> chromeWin(do_QueryInterface(rootWin));
     1:       if (chromeWin)
     1:         chromeWin->GetBrowserDOMWindow(getter_AddRefs(bwin));
     1: 
     1:       if (rootWin) {
     1:         /* Normally we destroy the entire window, but not if
     1:            this DOM window belongs to a tabbed browser and doesn't
     1:            correspond to a tab. This allows a well-behaved tab
     1:            to destroy the container as it should but is a final measure
     1:            to prevent an errant tab from doing so when it shouldn't.
     1:            This works because we reach this code when we shouldn't only
     1:            in the particular circumstance that we belong to a tab
     1:            that has just been closed (and is therefore already missing
     1:            from the list of browsers) (and has an unload handler
     1:            that closes the window). */
     1:         // XXXbz now that we have mHavePendingClose, is this needed?
 79445:         bool isTab = false;
     1:         if (rootWin == this ||
     1:             !bwin || (bwin->IsTabContentWindow(GetOuterWindowInternal(),
     1:                                                &isTab), isTab))
     1:           treeOwnerAsWin->Destroy();
     1:       }
     1:     }
     1: 
 80486:     CleanUp(false);
     1:   }
     1: }
     1: 
 61768: nsIDOMWindow *
     1: nsGlobalWindow::EnterModalState()
     1: {
101616:   // GetScriptableTop, not GetTop, so that EnterModalState works properly with
101616:   // <iframe mozbrowser>.
101616:   nsGlobalWindow* topWin = GetScriptableTop();
 54231: 
 54231:   if (!topWin) {
     1:     NS_ERROR("Uh, EnterModalState() called w/o a reachable top window?");
     1: 
106838:     return nullptr;
     1:   }
     1: 
 60229:   // If there is an active ESM in this window, clear it. Otherwise, this can
 60229:   // cause a problem if a modal state is entered during a mouseup event.
 60229:   nsEventStateManager* activeESM =
 60229:     static_cast<nsEventStateManager*>(nsEventStateManager::GetActiveEventStateManager());
 60229:   if (activeESM && activeESM->GetPresContext()) {
 60229:     nsIPresShell* activeShell = activeESM->GetPresContext()->GetPresShell();
 60229:     if (activeShell && (
 60229:         nsContentUtils::ContentIsCrossDocDescendantOf(activeShell->GetDocument(), mDoc) ||
 60229:         nsContentUtils::ContentIsCrossDocDescendantOf(mDoc, activeShell->GetDocument()))) {
 60229:       nsEventStateManager::ClearGlobalActiveContent(activeESM);
 60421: 
106838:       activeShell->SetCapturingContent(nullptr, 0);
 60421: 
 60421:       if (activeShell) {
 70097:         nsRefPtr<nsFrameSelection> frameSelection = activeShell->FrameSelection();
 80486:         frameSelection->SetMouseDownState(false);
 60421:       }
 60229:     }
 60229:   }
 60229: 
 25722:   if (topWin->mModalStateDepth == 0) {
 25722:     NS_ASSERTION(!mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
 25722: 
 25722:     mSuspendedDoc = do_QueryInterface(topWin->GetExtantDocument());
 25724:     if (mSuspendedDoc && mSuspendedDoc->EventHandlingSuppressed()) {
 25722:       mSuspendedDoc->SuppressEventHandling();
 25724:     } else {
106838:       mSuspendedDoc = nullptr;
 25722:     }
 25722:   }
 25722:   topWin->mModalStateDepth++;
 29105: 
 61768:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
 61768: 
 61768:   nsCOMPtr<nsIDOMWindow> callerWin;
 61768:   nsIScriptContext *scx;
 61768:   if (cx && (scx = GetScriptContextFromJSContext(cx))) {
 61768:     scx->EnterModalState();
 61768:     callerWin = do_QueryInterface(nsJSUtils::GetDynamicScriptGlobal(cx));
 61768:   }
 61768: 
 57392:   if (mContext) {
 57392:     mContext->EnterModalState();
 29105:   }
 61768: 
 61768:   return callerWin;
     1: }
     1: 
     1: // static
     1: void
     1: nsGlobalWindow::RunPendingTimeoutsRecursive(nsGlobalWindow *aTopWindow,
     1:                                             nsGlobalWindow *aWindow)
     1: {
     1:   nsGlobalWindow *inner;
     1: 
     1:   // Return early if we're frozen or have no inner window.
     1:   if (!(inner = aWindow->GetCurrentInnerWindowInternal()) ||
     1:       inner->IsFrozen()) {
     1:     return;
     1:   }
     1: 
106838:   inner->RunTimeout(nullptr);
     1: 
     1:   // Check again if we're frozen since running pending timeouts
     1:   // could've frozen us.
     1:   if (inner->IsFrozen()) {
     1:     return;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMWindowCollection> frames;
     1:   aWindow->GetFrames(getter_AddRefs(frames));
     1: 
     1:   if (!frames) {
     1:     return;
     1:   }
     1: 
108991:   uint32_t i, length;
     1:   if (NS_FAILED(frames->GetLength(&length)) || !length) {
     1:     return;
     1:   }
     1: 
     1:   for (i = 0; i < length && aTopWindow->mModalStateDepth == 0; i++) {
     1:     nsCOMPtr<nsIDOMWindow> child;
     1:     frames->Item(i, getter_AddRefs(child));
     1: 
     1:     if (!child) {
     1:       return;
     1:     }
     1: 
     1:     nsGlobalWindow *childWin =
  3233:       static_cast<nsGlobalWindow *>
  3233:                  (static_cast<nsIDOMWindow *>
  3233:                              (child.get()));
     1: 
     1:     RunPendingTimeoutsRecursive(aTopWindow, childWin);
     1:   }
     1: }
     1: 
     1: class nsPendingTimeoutRunner : public nsRunnable
     1: {
     1: public:
     1:   nsPendingTimeoutRunner(nsGlobalWindow *aWindow)
     1:     : mWindow(aWindow)
     1:   {
     1:     NS_ASSERTION(mWindow, "mWindow is null.");
     1:   }
     1: 
     1:   NS_IMETHOD Run()
     1:   {
     1:     nsGlobalWindow::RunPendingTimeoutsRecursive(mWindow, mWindow);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1: private:
     1:   nsRefPtr<nsGlobalWindow> mWindow;
     1: };
     1: 
     1: void
 61768: nsGlobalWindow::LeaveModalState(nsIDOMWindow *aCallerWin)
     1: {
101616:   nsGlobalWindow* topWin = GetScriptableTop();
 54231: 
 54231:   if (!topWin) {
     1:     NS_ERROR("Uh, LeaveModalState() called w/o a reachable top window?");
     1:     return;
     1:   }
     1: 
     1:   topWin->mModalStateDepth--;
     1: 
     1:   if (topWin->mModalStateDepth == 0) {
     1:     nsCOMPtr<nsIRunnable> runner = new nsPendingTimeoutRunner(topWin);
     1:     if (NS_FAILED(NS_DispatchToCurrentThread(runner)))
     1:       NS_WARNING("failed to dispatch pending timeout runnable");
 25722: 
 25722:     if (mSuspendedDoc) {
 25722:       nsCOMPtr<nsIDocument> currentDoc =
 25722:         do_QueryInterface(topWin->GetExtantDocument());
 26591:       mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(currentDoc == mSuspendedDoc);
106838:       mSuspendedDoc = nullptr;
 25722:     }
     1:   }
 29105: 
 61768:   if (aCallerWin) {
 61768:     nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryInterface(aCallerWin));
 61768:     nsIScriptContext *scx = sgo->GetContext();
 62912:     if (scx)
 61768:       scx->LeaveModalState();
 61768:   }
 61768: 
 57392:   if (mContext) {
 57392:     mContext->LeaveModalState();
 29105:   }
 54231: 
 54231:   // Remember the time of the last dialog quit.
 54231:   nsGlobalWindow *inner = topWin->GetCurrentInnerWindowInternal();
 54231:   if (inner)
 54231:     inner->mLastDialogQuitTime = TimeStamp::Now();
     1: }
     1: 
 79445: bool
     1: nsGlobalWindow::IsInModalState()
     1: {
101616:   nsGlobalWindow *topWin = GetScriptableTop();
 54231: 
 54231:   if (!topWin) {
     1:     NS_ERROR("Uh, IsInModalState() called w/o a reachable top window?");
     1: 
 80486:     return false;
     1:   }
     1: 
 54231:   return topWin->mModalStateDepth != 0;
     1: }
     1: 
 11693: // static
 11693: void
 11693: nsGlobalWindow::NotifyDOMWindowDestroyed(nsGlobalWindow* aWindow) {
 11693:   nsCOMPtr<nsIObserverService> observerService =
 84835:     services::GetObserverService();
 11693:   if (observerService) {
 11693:     observerService->
 11693:       NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
106838:                       DOM_WINDOW_DESTROYED_TOPIC, nullptr);
 11693:   }
 11693: }
 11693: 
 42340: class WindowDestroyedEvent : public nsRunnable
 42340: {
 42340: public:
108991:   WindowDestroyedEvent(nsPIDOMWindow* aWindow, uint64_t aID,
 98106:                        const char* aTopic) :
 98106:     mID(aID), mTopic(aTopic)
 98106:   {
 98106:     mWindow = do_GetWeakReference(aWindow);
 98106:   }
 42340: 
 42340:   NS_IMETHOD Run()
 42340:   {
 42340:     nsCOMPtr<nsIObserverService> observerService =
 42340:       do_GetService("@mozilla.org/observer-service;1");
 42340:     if (observerService) {
 42340:       nsCOMPtr<nsISupportsPRUint64> wrapper =
 42340:         do_CreateInstance(NS_SUPPORTS_PRUINT64_CONTRACTID);
 42340:       if (wrapper) {
 42340:         wrapper->SetData(mID);
106838:         observerService->NotifyObservers(wrapper, mTopic.get(), nullptr);
 42340:       }
 42340:     }
 98106: 
 98106:     nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mWindow);
 98106:     if (window) {
 98106:       nsGlobalWindow* currentInner = 
 98106:         window->IsInnerWindow() ? static_cast<nsGlobalWindow*>(window.get()) :
 98106:                                   static_cast<nsGlobalWindow*>(window->GetCurrentInnerWindow());
 98106:       NS_ENSURE_TRUE(currentInner, NS_OK);
 98106: 
 98106:       JSObject* obj = currentInner->FastGetGlobalJSObject();
105543:       // We only want to nuke wrappers for the chrome->content case
105537:       if (obj && !js::IsSystemCompartment(js::GetObjectCompartment(obj))) {
 98106:         JSContext* cx =
 98106:           nsContentUtils::ThreadJSContextStack()->GetSafeJSContext();
 98106: 
 98106:         JSAutoRequest ar(cx);
105543:         js::NukeCrossCompartmentWrappers(cx, 
105543:                                          js::ChromeCompartmentsOnly(),
105543:                                          js::SingleCompartment(js::GetObjectCompartment(obj)),
105548:                                          window->IsInnerWindow() ? js::DontNukeWindowReferences :
105548:                                                                    js::NukeWindowReferences);
 98106:       }
 98106:     }
 98106: 
 42340:     return NS_OK;
 42340:   }
 42340: 
 42340: private:
108991:   uint64_t mID;
 42340:   nsCString mTopic;
 98106:   nsWeakPtr mWindow;
 42340: };
 42340: 
 42340: void
 42340: nsGlobalWindow::NotifyWindowIDDestroyed(const char* aTopic)
 42340: {
 98106:   nsRefPtr<nsIRunnable> runnable = new WindowDestroyedEvent(this, mWindowID, aTopic);
 42340:   nsresult rv = NS_DispatchToCurrentThread(runnable);
 42340:   if (NS_SUCCEEDED(rv)) {
 80486:     mNotifiedIDDestroyed = true;
 42340:   }
 42340: }
 42340: 
 70324: // static
 70324: void
 70324: nsGlobalWindow::NotifyDOMWindowFrozen(nsGlobalWindow* aWindow) {
 70324:   if (aWindow && aWindow->IsInnerWindow()) {
 70324:     nsCOMPtr<nsIObserverService> observerService =
 84835:       services::GetObserverService();
 70324:     if (observerService) {
 70324:       observerService->
 70324:         NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
106838:                         DOM_WINDOW_FROZEN_TOPIC, nullptr);
 70324:     }
 70324:   }
 70324: }
 70324: 
 70324: // static
 70324: void
 70324: nsGlobalWindow::NotifyDOMWindowThawed(nsGlobalWindow* aWindow) {
 70324:   if (aWindow && aWindow->IsInnerWindow()) {
 70324:     nsCOMPtr<nsIObserverService> observerService =
 84835:       services::GetObserverService();
 70324:     if (observerService) {
 70324:       observerService->
 70324:         NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
106838:                         DOM_WINDOW_THAWED_TOPIC, nullptr);
 70324:     }
 70324:   }
 70324: }
 70324: 
 82803: JSObject*
 11622: nsGlobalWindow::GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey)
 11622: {
106838:   JSObject* handler = nullptr;
 11622:   if (mCachedXBLPrototypeHandlers.IsInitialized()) {
 11622:     mCachedXBLPrototypeHandlers.Get(aKey, &handler);
 11622:   }
 82804:   return handler;
 11622: }
 11622: 
 11622: void
 11622: nsGlobalWindow::CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
 84858:                                          nsScriptObjectHolder<JSObject>& aHandler)
 11622: {
 98908:   if (!mCachedXBLPrototypeHandlers.IsInitialized()) {
 98908:     mCachedXBLPrototypeHandlers.Init();
 11622:   }
 11622: 
 11622:   if (!mCachedXBLPrototypeHandlers.Count()) {
 11622:     // Can't use macros to get the participant because nsGlobalChromeWindow also
 11622:     // runs through this code. Use QueryInterface to get the correct objects.
 11622:     nsXPCOMCycleCollectionParticipant* participant;
 11622:     CallQueryInterface(this, &participant);
 11622:     NS_ASSERTION(participant,
 11622:                  "Failed to QI to nsXPCOMCycleCollectionParticipant!");
 11622: 
 57794:     nsISupports* thisSupports;
 11622:     QueryInterface(NS_GET_IID(nsCycleCollectionISupports),
 57794:                    reinterpret_cast<void**>(&thisSupports));
 11622:     NS_ASSERTION(thisSupports, "Failed to QI to nsCycleCollectionISupports!");
 11622: 
 11622:     nsresult rv = nsContentUtils::HoldJSObjects(thisSupports, participant);
 11622:     if (NS_FAILED(rv)) {
 11622:       NS_ERROR("nsContentUtils::HoldJSObjects failed!");
 11622:       return;
 11622:     }
 11622:   }
 11622: 
 84858:   mCachedXBLPrototypeHandlers.Put(aKey, aHandler.get());
 11622: }
 11622: 
 99222: /**
 99222:  * GetScriptableFrameElement is called when script reads
 99222:  * nsIGlobalWindow::frameElement.
 99222:  *
 99222:  * In contrast to GetRealFrameElement, GetScriptableFrameElement says that the
 99222:  * window contained by an <iframe mozbrowser> has no frame element
 99222:  * (effectively treating a mozbrowser the same as a content/chrome boundary).
 99222:  */
 99222: NS_IMETHODIMP
 99222: nsGlobalWindow::GetScriptableFrameElement(nsIDOMElement** aFrameElement)
 99222: {
 99222:   FORWARD_TO_OUTER(GetScriptableFrameElement, (aFrameElement), NS_ERROR_NOT_INITIALIZED);
 99222:   *aFrameElement = NULL;
 99222: 
109100:   if (!mDocShell || mDocShell->GetIsContentBoundary()) {
 99222:     return NS_OK;
 99222:   }
 99222: 
 99222:   return GetFrameElement(aFrameElement);
 99222: }
 99222: 
 99222: /**
 99222:  * nsIGlobalWindow::GetFrameElement (when called from C++) is just a wrapper
 99222:  * around GetRealFrameElement.
 99222:  */
 99222: NS_IMETHODIMP
 99222: nsGlobalWindow::GetRealFrameElement(nsIDOMElement** aFrameElement)
 99222: {
 99222:   FORWARD_TO_OUTER(GetRealFrameElement, (aFrameElement), NS_ERROR_NOT_INITIALIZED);
 99222: 
 99222:   *aFrameElement = NULL;
     1: 
106198:   if (!mDocShell) {
106198:     return NS_OK;
106198:   }
106198: 
106198:   nsCOMPtr<nsIDocShell> parent;
106198:   mDocShell->GetParentIgnoreBrowserFrame(getter_AddRefs(parent));
106198: 
106198:   if (!parent || parent == mDocShell) {
     1:     // We're at a chrome boundary, don't expose the chrome iframe
     1:     // element to content code.
     1:     return NS_OK;
     1:   }
     1: 
     1:   *aFrameElement = mFrameElement;
     1:   NS_IF_ADDREF(*aFrameElement);
     1: 
     1:   return NS_OK;
     1: }
     1: 
  4422: // Helper for converting window.showModalDialog() options (list of ';'
  4422: // separated name (:|=) value pairs) to a format that's parsable by
  4422: // our normal window opening code.
  4422: 
  4040: void
  4040: ConvertDialogOptions(const nsAString& aOptions, nsAString& aResult)
  4040: {
  4040:   nsAString::const_iterator end;
  4040:   aOptions.EndReading(end);
  4040: 
  4040:   nsAString::const_iterator iter;
  4040:   aOptions.BeginReading(iter);
  4040: 
  4040:   while (iter != end) {
  4040:     // Skip whitespace.
  4040:     while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
  4040:       ++iter;
  4040:     }
  4040: 
  4040:     nsAString::const_iterator name_start = iter;
  4040: 
  4040:     // Skip characters until we find whitespace, ';', ':', or '='
  4040:     while (iter != end && !nsCRT::IsAsciiSpace(*iter) &&
  4040:            *iter != ';' &&
  4040:            *iter != ':' &&
  4040:            *iter != '=') {
  4040:       ++iter;
  4040:     }
  4040: 
  4040:     nsAString::const_iterator name_end = iter;
  4040: 
  4040:     // Skip whitespace.
  4040:     while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
  4040:       ++iter;
  4040:     }
  4040: 
  4040:     if (*iter == ';') {
  4040:       // No value found, skip the ';' and keep going.
  4040:       ++iter;
  4040: 
  4040:       continue;
  4040:     }
  4040: 
  4040:     nsAString::const_iterator value_start = iter;
  4040:     nsAString::const_iterator value_end = iter;
  4040: 
  4040:     if (*iter == ':' || *iter == '=') {
  4040:       // We found name followed by ':' or '='. Look for a value.
  4040: 
  4040:       iter++; // Skip the ':' or '='
  4040: 
  4040:       // Skip whitespace.
  4040:       while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
  4040:         ++iter;
  4040:       }
  4040: 
  4040:       value_start = iter;
  4040: 
  4040:       // Skip until we find whitespace, or ';'.
  4040:       while (iter != end && !nsCRT::IsAsciiSpace(*iter) &&
  4040:              *iter != ';') {
  4040:         ++iter;
  4040:       }
  4040: 
  4040:       value_end = iter;
  4040: 
  4040:       // Skip whitespace.
  4040:       while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
  4040:         ++iter;
  4040:       }
  4040:     }
  4040: 
  4040:     const nsDependentSubstring& name = Substring(name_start, name_end);
  4040:     const nsDependentSubstring& value = Substring(value_start, value_end);
  4040: 
  4040:     if (name.LowerCaseEqualsLiteral("center")) {
  4040:       if (value.LowerCaseEqualsLiteral("on")  ||
  4040:           value.LowerCaseEqualsLiteral("yes") ||
  4040:           value.LowerCaseEqualsLiteral("1")) {
  4040:         aResult.AppendLiteral(",centerscreen=1");
  4040:       }
  4040:     } else if (name.LowerCaseEqualsLiteral("dialogwidth")) {
  4040:       if (!value.IsEmpty()) {
  4040:         aResult.AppendLiteral(",width=");
  4040:         aResult.Append(value);
  4040:       }
  4040:     } else if (name.LowerCaseEqualsLiteral("dialogheight")) {
  4040:       if (!value.IsEmpty()) {
  4040:         aResult.AppendLiteral(",height=");
  4040:         aResult.Append(value);
  4040:       }
  4040:     } else if (name.LowerCaseEqualsLiteral("dialogtop")) {
  4040:       if (!value.IsEmpty()) {
  4040:         aResult.AppendLiteral(",top=");
  4040:         aResult.Append(value);
  4040:       }
  4040:     } else if (name.LowerCaseEqualsLiteral("dialogleft")) {
  4040:       if (!value.IsEmpty()) {
  4040:         aResult.AppendLiteral(",left=");
  4040:         aResult.Append(value);
  4040:       }
  4040:     } else if (name.LowerCaseEqualsLiteral("resizable")) {
  4040:       if (value.LowerCaseEqualsLiteral("on")  ||
  4040:           value.LowerCaseEqualsLiteral("yes") ||
  4040:           value.LowerCaseEqualsLiteral("1")) {
  4040:         aResult.AppendLiteral(",resizable=1");
  4040:       }
  4040:     } else if (name.LowerCaseEqualsLiteral("scroll")) {
  4040:       if (value.LowerCaseEqualsLiteral("off")  ||
  4040:           value.LowerCaseEqualsLiteral("no") ||
  4040:           value.LowerCaseEqualsLiteral("0")) {
  4040:         aResult.AppendLiteral(",scrollbars=0");
  4040:       }
  4040:     }
  4040: 
  4040:     if (iter == end) {
  4040:       break;
  4040:     }
  4040: 
  4040:     iter++;
  4040:   }
  4040: }
  4040: 
  4040: NS_IMETHODIMP
  4040: nsGlobalWindow::ShowModalDialog(const nsAString& aURI, nsIVariant *aArgs,
  4040:                                 const nsAString& aOptions,
  4040:                                 nsIVariant **aRetVal)
  4040: {
 62357:   FORWARD_TO_OUTER(ShowModalDialog, (aURI, aArgs, aOptions, aRetVal),
 62357:                    NS_ERROR_NOT_INITIALIZED);
 62357: 
106838:   *aRetVal = nullptr;
  4087: 
 95323:   if (Preferences::GetBool("dom.disable_window_showModalDialog", false))
 95323:     return NS_ERROR_NOT_AVAILABLE;
 95323: 
 54231:   // Before bringing up the window/dialog, unsuppress painting and flush
 54231:   // pending reflows.
 54231:   EnsureReflowFlushAndPaint();
 54231: 
108232:   bool needToPromptForAbuse;
108232:   if (DialogsAreBlocked(&needToPromptForAbuse)) {
 54231:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
108232: 
108232:   if (needToPromptForAbuse && !ConfirmDialogIfNeeded()) {
108232:     return NS_ERROR_NOT_AVAILABLE;
108232:   }
 22792: 
  4040:   nsCOMPtr<nsIDOMWindow> dlgWin;
 13096:   nsAutoString options(NS_LITERAL_STRING("-moz-internal-modal=1,status=1"));
  4422: 
  4422:   ConvertDialogOptions(aOptions, options);
  4040: 
  4040:   options.AppendLiteral(",scrollbars=1,centerscreen=1,resizable=0");
  4040: 
 68551:   nsCOMPtr<nsIDOMWindow> callerWin = EnterModalState();
108991:   uint32_t oldMicroTaskLevel = nsContentUtils::MicroTaskLevel();
 94651:   nsContentUtils::SetMicroTaskLevel(0);
  4040:   nsresult rv = OpenInternal(aURI, EmptyString(), options,
 80486:                              false,          // aDialog
 80486:                              true,           // aContentModal
 80486:                              true,           // aCalledNoScript
 80486:                              true,           // aDoJSFixups
108307:                              true,           // aNavigate
106838:                              nullptr, aArgs, // args
  4040:                              GetPrincipal(),    // aCalleePrincipal
106838:                              nullptr,            // aJSCallerContext
  4040:                              getter_AddRefs(dlgWin));
 94651:   nsContentUtils::SetMicroTaskLevel(oldMicroTaskLevel);
 68551:   LeaveModalState(callerWin);
 16266: 
 16266:   NS_ENSURE_SUCCESS(rv, rv);
 16266:   
 16266:   if (dlgWin) {
 33525:     nsCOMPtr<nsIPrincipal> subjectPrincipal;
 33525:     rv = nsContentUtils::GetSecurityManager()->
 33525:       GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
 33525:     if (NS_FAILED(rv)) {
 33525:       return rv;
 33525:     }
 33525: 
 79445:     bool canAccess = true;
 33525: 
 33525:     if (subjectPrincipal) {
 33525:       nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
 33525:         do_QueryInterface(dlgWin);
 33525:       nsCOMPtr<nsIPrincipal> dialogPrincipal;
 33525: 
 33525:       if (objPrincipal) {
 33525:         dialogPrincipal = objPrincipal->GetPrincipal();
 33525: 
 33525:         rv = subjectPrincipal->Subsumes(dialogPrincipal, &canAccess);
 33525:         NS_ENSURE_SUCCESS(rv, rv);
 33525:       } else {
 33525:         // Uh, not sure what kind of dialog this is. Prevent access to
 33525:         // be on the safe side...
 33525: 
 80486:         canAccess = false;
 33525:       }
 33525:     }
 33525: 
 39378:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(dlgWin));
 39378: 
 38439:     if (canAccess) {
  4040:       nsPIDOMWindow *inner = win->GetCurrentInnerWindow();
  4040: 
  4040:       nsCOMPtr<nsIDOMModalContentWindow> dlgInner(do_QueryInterface(inner));
  4040: 
  4040:       if (dlgInner) {
  4040:         dlgInner->GetReturnValue(aRetVal);
  4040:       }
 16266:     }
 39378: 
 39378:     nsRefPtr<nsGlobalWindow> winInternal =
 39378:       static_cast<nsGlobalWindow*>(win.get());
 39378:     if (winInternal->mCallCleanUpAfterModalDialogCloses) {
 80486:       winInternal->mCallCleanUpAfterModalDialogCloses = false;
 80486:       winInternal->CleanUp(true);
 39378:     }
 33525:   }
  4040:   
  4040:   return NS_OK;
  4040: }
  4040: 
 36462: class CommandDispatcher : public nsRunnable
 36462: {
 36462: public:
 36462:   CommandDispatcher(nsIDOMXULCommandDispatcher* aDispatcher,
 36462:                     const nsAString& aAction)
 36462:   : mDispatcher(aDispatcher), mAction(aAction) {}
 36462: 
 36462:   NS_IMETHOD Run()
 36462:   {
 36462:     return mDispatcher->UpdateCommands(mAction);
 36462:   }
 36462: 
 36462:   nsCOMPtr<nsIDOMXULCommandDispatcher> mDispatcher;
 36462:   nsString                             mAction;
 36462: };
 36462: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::UpdateCommands(const nsAString& anAction)
     1: {
     1:   nsPIDOMWindow *rootWindow = nsGlobalWindow::GetPrivateRoot();
     1:   if (!rootWindow)
     1:     return NS_OK;
     1: 
     1:   nsCOMPtr<nsIDOMXULDocument> xulDoc =
     1:     do_QueryInterface(rootWindow->GetExtantDocument());
     1:   // See if we contain a XUL document.
     1:   if (xulDoc) {
     1:     // Retrieve the command dispatcher and call updateCommands on it.
     1:     nsCOMPtr<nsIDOMXULCommandDispatcher> xulCommandDispatcher;
     1:     xulDoc->GetCommandDispatcher(getter_AddRefs(xulCommandDispatcher));
 36462:     if (xulCommandDispatcher) {
 36462:       nsContentUtils::AddScriptRunner(new CommandDispatcher(xulCommandDispatcher,
 36462:                                                             anAction));
 36462:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetSelection(nsISelection** aSelection)
     1: {
     1:   FORWARD_TO_OUTER(GetSelection, (aSelection), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   NS_ENSURE_ARG_POINTER(aSelection);
106838:   *aSelection = nullptr;
     1: 
     1:   if (!mDocShell)
     1:     return NS_OK;
     1: 
     1:   nsCOMPtr<nsIPresShell> presShell;
     1:   mDocShell->GetPresShell(getter_AddRefs(presShell));
     1: 
     1:   if (!presShell)
     1:     return NS_OK;
     1:     
     1:   *aSelection = presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
     1:   
     1:   NS_IF_ADDREF(*aSelection);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::Find(const nsAString& aStr, bool aCaseSensitive,
 79445:                      bool aBackwards, bool aWrapAround, bool aWholeWord,
 79445:                      bool aSearchInFrames, bool aShowDialog,
 79445:                      bool *aDidFind)
     1: {
 97404:   if (Preferences::GetBool("dom.disable_window_find", false))
 97404:     return NS_ERROR_NOT_AVAILABLE;
 97404: 
 18869:   FORWARD_TO_OUTER(Find, (aStr, aCaseSensitive, aBackwards, aWrapAround,
 18869:                           aWholeWord, aSearchInFrames, aShowDialog, aDidFind),
 18869:                    NS_ERROR_NOT_INITIALIZED);
 18869: 
     1:   nsresult rv = NS_OK;
 80486:   *aDidFind = false;
     1: 
     1:   nsCOMPtr<nsIWebBrowserFind> finder(do_GetInterface(mDocShell));
 22792:   NS_ENSURE_TRUE(finder, NS_ERROR_FAILURE);
     1: 
     1:   // Set the options of the search
     1:   rv = finder->SetSearchString(PromiseFlatString(aStr).get());
     1:   NS_ENSURE_SUCCESS(rv, rv);
 18869:   finder->SetMatchCase(aCaseSensitive);
 18869:   finder->SetFindBackwards(aBackwards);
 18869:   finder->SetWrapFind(aWrapAround);
 18869:   finder->SetEntireWord(aWholeWord);
 18869:   finder->SetSearchFrames(aSearchInFrames);
     1: 
     1:   // the nsIWebBrowserFind is initialized to use this window
     1:   // as the search root, but uses focus to set the current search
     1:   // frame. If we're being called from JS (as here), this window
     1:   // should be the current search frame.
     1:   nsCOMPtr<nsIWebBrowserFindInFrames> framesFinder(do_QueryInterface(finder));
     1:   if (framesFinder) {
     1:     framesFinder->SetRootSearchFrame(this);   // paranoia
     1:     framesFinder->SetCurrentSearchFrame(this);
     1:   }
     1:   
     1:   // The Find API does not accept empty strings. Launch the Find Dialog.
 18869:   if (aStr.IsEmpty() || aShowDialog) {
     1:     // See if the find dialog is already up using nsIWindowMediator
     1:     nsCOMPtr<nsIWindowMediator> windowMediator =
     1:       do_GetService(NS_WINDOWMEDIATOR_CONTRACTID);
     1: 
 73870:     nsCOMPtr<nsIDOMWindow> findDialog;
     1: 
     1:     if (windowMediator) {
     1:       windowMediator->GetMostRecentWindow(NS_LITERAL_STRING("findInPage").get(),
     1:                                           getter_AddRefs(findDialog));
     1:     }
     1: 
     1:     if (findDialog) {
     1:       // The Find dialog is already open, bring it to the top.
     1:       rv = findDialog->Focus();
     1:     } else { // Open a Find dialog
     1:       if (finder) {
     1:         nsCOMPtr<nsIDOMWindow> dialog;
     1:         rv = OpenDialog(NS_LITERAL_STRING("chrome://global/content/finddialog.xul"),
     1:                         NS_LITERAL_STRING("_blank"),
     1:                         NS_LITERAL_STRING("chrome, resizable=no, dependent=yes"),
     1:                         finder, getter_AddRefs(dialog));
     1:       }
     1:     }
     1:   } else {
     1:     // Launch the search with the passed in search string
     1:     rv = finder->FindNext(aDidFind);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Atob(const nsAString& aAsciiBase64String,
     1:                      nsAString& aBinaryData)
     1: {
 74412:   return nsContentUtils::Atob(aAsciiBase64String, aBinaryData);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::Btoa(const nsAString& aBinaryData,
     1:                      nsAString& aAsciiBase64String)
     1: {
 74412:   return nsContentUtils::Btoa(aBinaryData, aAsciiBase64String);
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsIDOMEventTarget
     1: //*****************************************************************************
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::RemoveEventListener(const nsAString& aType,
     1:                                     nsIDOMEventListener* aListener,
 79445:                                     bool aUseCapture)
     1: {
 80486:   nsRefPtr<nsEventListenerManager> elm = GetListenerManager(false);
 72329:   if (elm) {
 72329:     elm->RemoveEventListener(aType, aListener, aUseCapture);
 72329:   }
 72329:   return NS_OK;
     1: }
     1: 
 82743: NS_IMPL_REMOVE_SYSTEM_EVENT_LISTENER(nsGlobalWindow)
 82743: 
     1: NS_IMETHODIMP
 79445: nsGlobalWindow::DispatchEvent(nsIDOMEvent* aEvent, bool* aRetVal)
 72324: {
 72324:   FORWARD_TO_INNER(DispatchEvent, (aEvent, aRetVal), NS_OK);
     1: 
     1:   if (!mDoc) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // Obtain a presentation shell
 46225:   nsIPresShell *shell = mDoc->GetShell();
 39823:   nsRefPtr<nsPresContext> presContext;
     1:   if (shell) {
     1:     // Retrieve the context
     1:     presContext = shell->GetPresContext();
     1:   }
     1: 
     1:   nsEventStatus status = nsEventStatus_eIgnore;
     1:   nsresult rv =
106838:     nsEventDispatcher::DispatchDOMEvent(GetOuterWindow(), nullptr, aEvent,
     1:                                         presContext, &status);
     1: 
 72324:   *aRetVal = (status != nsEventStatus_eConsumeNoDefault);
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::AddEventListener(const nsAString& aType,
     1:                                  nsIDOMEventListener *aListener,
 79445:                                  bool aUseCapture, bool aWantsUntrusted,
108991:                                  uint8_t aOptionalArgc)
 72324: {
 72324:   NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
 37183:                "Won't check if this is chrome, you want to set "
 80486:                "aWantsUntrusted to false or make the aWantsUntrusted "
 37183:                "explicit by making optional_argc non-zero.");
 37183: 
 37184:   if (IsOuterWindow() && mInnerWindow &&
 37184:       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
 37184:     return NS_ERROR_DOM_SECURITY_ERR;
 37184:   }
 37184: 
 72329:   if (!aWantsUntrusted &&
 72329:       (aOptionalArgc < 2 && !nsContentUtils::IsChromeDoc(mDoc))) {
 80486:     aWantsUntrusted = true;
 80486:   }
 80486: 
 80486:   nsEventListenerManager* manager = GetListenerManager(true);
 29474:   NS_ENSURE_STATE(manager);
 76793:   manager->AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted);
 76793:   return NS_OK;
     1: }
     1: 
 82743: NS_IMETHODIMP
 82743: nsGlobalWindow::AddSystemEventListener(const nsAString& aType,
 82743:                                        nsIDOMEventListener *aListener,
 82743:                                        bool aUseCapture,
 82743:                                        bool aWantsUntrusted,
108991:                                        uint8_t aOptionalArgc)
 82743: {
 82743:   NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
 82743:                "Won't check if this is chrome, you want to set "
 82743:                "aWantsUntrusted to false or make the aWantsUntrusted "
 82743:                "explicit by making optional_argc non-zero.");
 82743: 
 82743:   if (IsOuterWindow() && mInnerWindow &&
 82743:       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
 82743:     return NS_ERROR_DOM_SECURITY_ERR;
 82743:   }
 82743: 
 82743:   if (!aWantsUntrusted &&
 82743:       (aOptionalArgc < 2 && !nsContentUtils::IsChromeDoc(mDoc))) {
 82743:     aWantsUntrusted = true;
 82743:   }
 82743: 
 82743:   return NS_AddSystemEventListener(this, aType, aListener, aUseCapture,
 82743:                                    aWantsUntrusted);
 82743: }
 82743: 
 72328: nsEventListenerManager*
 79445: nsGlobalWindow::GetListenerManager(bool aCreateIfNotFound)
 29474: {
106838:   FORWARD_TO_INNER_CREATE(GetListenerManager, (aCreateIfNotFound), nullptr);
     1: 
 72328:   if (!mListenerManager && aCreateIfNotFound) {
 72328:     mListenerManager =
 72328:       new nsEventListenerManager(static_cast<nsIDOMEventTarget*>(this));
 29474:   }
 29474: 
 29474:   return mListenerManager;
     1: }
     1: 
 27700: nsIScriptContext*
 27700: nsGlobalWindow::GetContextForEventHandlers(nsresult* aRv)
 27700: {
 80859:   *aRv = NS_ERROR_UNEXPECTED;
 80859:   if (IsInnerWindow()) {
 80859:     nsPIDOMWindow* outer = GetOuterWindow();
106838:     NS_ENSURE_TRUE(outer && outer->GetCurrentInnerWindow() == this, nullptr);
 80859:   }
 80859: 
 80859:   nsIScriptContext* scx;
 80859:   if ((scx = GetContext())) {
 80859:     *aRv = NS_OK;
 27700:     return scx;
 16056:   }
106838:   return nullptr;
 80859: }
 16056: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsPIDOMWindow
     1: //*****************************************************************************
     1: 
     1: nsPIDOMWindow*
     1: nsGlobalWindow::GetPrivateParent()
     1: {
106838:   FORWARD_TO_OUTER(GetPrivateParent, (), nullptr);
     1: 
     1:   nsCOMPtr<nsIDOMWindow> parent;
     1:   GetParent(getter_AddRefs(parent));
     1: 
  3233:   if (static_cast<nsIDOMWindow *>(this) == parent.get()) {
     1:     nsCOMPtr<nsIContent> chromeElement(do_QueryInterface(mChromeEventHandler));
     1:     if (!chromeElement)
106838:       return nullptr;             // This is ok, just means a null parent.
     1: 
     1:     nsIDocument* doc = chromeElement->GetDocument();
     1:     if (!doc)
106838:       return nullptr;             // This is ok, just means a null parent.
     1: 
     1:     nsIScriptGlobalObject *globalObject = doc->GetScriptGlobalObject();
     1:     if (!globalObject)
106838:       return nullptr;             // This is ok, just means a null parent.
     1: 
     1:     parent = do_QueryInterface(globalObject);
     1:   }
     1: 
     1:   if (parent) {
  3233:     return static_cast<nsGlobalWindow *>
  3233:                       (static_cast<nsIDOMWindow*>(parent.get()));
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: nsPIDOMWindow*
     1: nsGlobalWindow::GetPrivateRoot()
     1: {
106838:   FORWARD_TO_OUTER(GetPrivateRoot, (), nullptr);
     1: 
     1:   nsCOMPtr<nsIDOMWindow> top;
     1:   GetTop(getter_AddRefs(top));
     1: 
     1:   nsCOMPtr<nsPIDOMWindow> ptop = do_QueryInterface(top);
     1:   NS_ASSERTION(ptop, "cannot get ptop");
     1:   if (!ptop)
106838:     return nullptr;
     1: 
     1:   nsIDocShell *docShell = ptop->GetDocShell();
     1: 
     1:   // Get the chrome event handler from the doc shell, since we only
     1:   // want to deal with XUL chrome handlers and not the new kind of
     1:   // window root handler.
     1:   nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
     1:   docShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
     1: 
     1:   nsCOMPtr<nsIContent> chromeElement(do_QueryInterface(mChromeEventHandler));
     1:   if (chromeElement) {
     1:     nsIDocument* doc = chromeElement->GetDocument();
     1:     if (doc) {
     1:       nsIDOMWindow *parent = doc->GetWindow();
     1:       if (parent) {
     1:         parent->GetTop(getter_AddRefs(top));
     1:       }
     1:     }
     1:   }
     1: 
  3233:   return static_cast<nsGlobalWindow *>
  3233:                     (static_cast<nsIDOMWindow *>(top));
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetLocation(nsIDOMLocation ** aLocation)
     1: {
 50477:   FORWARD_TO_INNER(GetLocation, (aLocation), NS_ERROR_NOT_INITIALIZED);
     1: 
106838:   *aLocation = nullptr;
     1: 
 50477:   nsIDocShell *docShell = GetDocShell();
 50477:   if (!mLocation && docShell) {
 50477:     mLocation = new nsLocation(docShell);
     1:     if (!mLocation) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aLocation = mLocation);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29018: void
 79445: nsGlobalWindow::ActivateOrDeactivate(bool aActivate)
 29018: {
 39698:   // Set / unset mIsActive on the top level window, which is used for the
 39698:   // :-moz-window-inactive pseudoclass.
 29018:   nsCOMPtr<nsIWidget> mainWidget = GetMainWidget();
 39698:   if (!mainWidget)
 39698:     return;
 39698: 
 29018:   // Get the top level widget (if the main widget is a sheet, this will
 29018:   // be the sheet's top (non-sheet) parent).
 29018:   nsCOMPtr<nsIWidget> topLevelWidget = mainWidget->GetSheetWindowParent();
 39698:   if (!topLevelWidget) {
 29018:     topLevelWidget = mainWidget;
 39698:   }
 29018: 
 29018:   // Get the top level widget's nsGlobalWindow
 73870:   nsCOMPtr<nsIDOMWindow> topLevelWindow;
 29018:   if (topLevelWidget == mainWidget) {
 73870:     topLevelWindow = static_cast<nsIDOMWindow*>(this);
 29018:   } else {
 29018:     // This is a workaround for the following problem:
 29018:     // When a window with an open sheet loses focus, only the sheet window
 29018:     // receives the NS_DEACTIVATE event. However, it's not the sheet that
 39698:     // should lose the active styling, but the containing top level window.
108457: 
108457:     // widgetListener should be a nsXULWindow
108457:     nsIWidgetListener* listener = topLevelWidget->GetWidgetListener();
111195:     if (listener) {
108457:       nsCOMPtr<nsIXULWindow> window = listener->GetXULWindow();
108457:       nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(window));
 29018:       topLevelWindow = do_GetInterface(req);
 29018:     }
111195:   }
 29018:   if (topLevelWindow) {
 39698:     nsCOMPtr<nsPIDOMWindow> piWin(do_QueryInterface(topLevelWindow));
 39698:     piWin->SetActive(aActivate);
 39698:   }
 39698: }
 39698: 
 79445: static bool
 39698: NotifyDocumentTree(nsIDocument* aDocument, void* aData)
 39698: {
106838:   aDocument->EnumerateSubDocuments(NotifyDocumentTree, nullptr);
 39698:   aDocument->DocumentStatesChanged(NS_DOCUMENT_STATE_WINDOW_INACTIVE);
 80486:   return true;
 39698: }
 39698: 
 39698: void
 79445: nsGlobalWindow::SetActive(bool aActive)
 39698: {
 39698:   nsPIDOMWindow::SetActive(aActive);
106838:   NotifyDocumentTree(mDoc, nullptr);
 29546: }
     1: 
 79445: void nsGlobalWindow::SetIsBackground(bool aIsBackground)
 79445: {
 79445:   bool resetTimers = (!aIsBackground && IsBackground());
 72734:   nsPIDOMWindow::SetIsBackground(aIsBackground);
 72734:   if (resetTimers) {
 72734:     ResetTimersForNonBackgroundWindow();
 72734:   }
 72734: }
 72734: 
 48711: void nsGlobalWindow::MaybeUpdateTouchState()
 48711: {
 48711:   FORWARD_TO_INNER_VOID(MaybeUpdateTouchState, ());
 48711: 
 48711:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 48711: 
 48711:   nsCOMPtr<nsIDOMWindow> focusedWindow;
 48711:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
 48711: 
 48711:   if(this == focusedWindow) {
 48711:     UpdateTouchState();
 48711:   }
 48711: 
 48711:   if (mMayHaveTouchEventListener) {
 88107:     nsCOMPtr<nsIObserverService> observerService =
 88107:       do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
 89137: 
 88107:     if (observerService) {
 89137:       observerService->NotifyObservers(static_cast<nsIDOMWindow*>(this),
 88107:                                        DOM_TOUCH_LISTENER_ADDED,
106838:                                        nullptr);
 88107:     }
 91134:   }
 91134: }
 91134: 
 91134: void nsGlobalWindow::UpdateTouchState()
 91134: {
 91134:   FORWARD_TO_INNER_VOID(UpdateTouchState, ());
 91134: 
 91134:   nsCOMPtr<nsIWidget> mainWidget = GetMainWidget();
 91134:   if (!mainWidget) {
 91134:     return;
 91134:   }
 91134: 
 91134:   if (mMayHaveTouchEventListener) {
 91134:     mainWidget->RegisterTouchWindow();
 48711:   } else {
 48711:     mainWidget->UnregisterTouchWindow();
 48711:   }
 48711: }
 48711: 
 59871: void
 72326: nsGlobalWindow::SetChromeEventHandler(nsIDOMEventTarget* aChromeEventHandler)
 16549: {
 16549:   SetChromeEventHandlerInternal(aChromeEventHandler);
 16549:   if (IsOuterWindow()) {
 16549:     // update the chrome event handler on all our inner windows
 16549:     for (nsGlobalWindow *inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
 16549:          inner != this;
 16549:          inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
 55731:       NS_ASSERTION(!inner->mOuterWindow || inner->mOuterWindow == this,
 55731:                    "bad outer window pointer");
 16549:       inner->SetChromeEventHandlerInternal(aChromeEventHandler);
 16549:     }
 16549:   } else if (mOuterWindow) {
 16549:     // Need the cast to be able to call the protected method on a
 16549:     // superclass. We could make the method public instead, but it's really
 16549:     // better this way.
 55729:     static_cast<nsGlobalWindow*>(mOuterWindow.get())->
 16549:       SetChromeEventHandlerInternal(aChromeEventHandler);
 16549:   }
 16549: }
 16549: 
 79445: static bool IsLink(nsIContent* aContent)
 43884: {
 43884:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor = do_QueryInterface(aContent);
 43884:   return (anchor || (aContent &&
 43884:                      aContent->AttrValueIs(kNameSpaceID_XLink, nsGkAtoms::type,
 43884:                                            nsGkAtoms::simple, eCaseMatters)));
 43884: }
 43884: 
 29018: void
 29018: nsGlobalWindow::SetFocusedNode(nsIContent* aNode,
108991:                                uint32_t aFocusMethod,
 79445:                                bool aNeedsFocus)
 29018: {
 29018:   FORWARD_TO_INNER_VOID(SetFocusedNode, (aNode, aFocusMethod, aNeedsFocus));
 29018: 
 90691:   if (aNode && aNode->GetCurrentDoc() != mDoc) {
 90691:     NS_WARNING("Trying to set focus to a node from a wrong document");
 90691:     return;
 90691:   }
 90691: 
 90691:   if (mCleanedUp) {
 90691:     NS_ASSERTION(!aNode, "Trying to focus cleaned up window!");
106838:     aNode = nullptr;
 90691:     aNeedsFocus = false;
 90691:   }
 29018:   if (mFocusedNode != aNode) {
 80486:     UpdateCanvasFocus(false, aNode);
 29018:     mFocusedNode = aNode;
 41071:     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
 80486:     mShowFocusRingForContent = false;
 41071:   }
 41071: 
 41071:   if (mFocusedNode) {
 41071:     // if a node was focused by a keypress, turn on focus rings for the
 43884:     // window.
 43884:     if (mFocusMethod & nsIFocusManager::FLAG_BYKEY) {
 80486:       mFocusByKeyOccurred = true;
 43884:     } else if (
 43884:       // otherwise, we set mShowFocusRingForContent, as we don't want this to
 43884:       // be permanent for the window. On Windows, focus rings are only shown
 43884:       // when the FLAG_SHOWRING flag is used. On other platforms, focus rings
 43884:       // are only hidden for clicks on links.
 43884: #ifndef XP_WIN
 43884:       !(mFocusMethod & nsIFocusManager::FLAG_BYMOUSE) || !IsLink(aNode) ||
 41071: #endif
 43884:       aFocusMethod & nsIFocusManager::FLAG_SHOWRING) {
 80486:         mShowFocusRingForContent = true;
 41071:     }
 29018:   }
 29018: 
 29018:   if (aNeedsFocus)
 29018:     mNeedsFocus = aNeedsFocus;
 29018: }
 29018: 
108991: uint32_t
 29018: nsGlobalWindow::GetFocusMethod()
 29018: {
 29018:   FORWARD_TO_INNER(GetFocusMethod, (), 0);
 29018: 
 29018:   return mFocusMethod;
 29018: }
 29018: 
 79445: bool
 41071: nsGlobalWindow::ShouldShowFocusRing()
 41071: {
 80486:   FORWARD_TO_INNER(ShouldShowFocusRing, (), false);
 41071: 
 42263:   return mShowFocusRings || mShowFocusRingForContent || mFocusByKeyOccurred;
 41071: }
 41071: 
 41071: void
 41071: nsGlobalWindow::SetKeyboardIndicators(UIStateChangeType aShowAccelerators,
 41071:                                       UIStateChangeType aShowFocusRings)
 41071: {
 41071:   FORWARD_TO_INNER_VOID(SetKeyboardIndicators, (aShowAccelerators, aShowFocusRings));
 41071: 
 79445:   bool oldShouldShowFocusRing = ShouldShowFocusRing();
 71114: 
 41071:   // only change the flags that have been modified
 41071:   if (aShowAccelerators != UIStateChangeType_NoChange)
 41071:     mShowAccelerators = aShowAccelerators == UIStateChangeType_Set;
 41071:   if (aShowFocusRings != UIStateChangeType_NoChange)
 41071:     mShowFocusRings = aShowFocusRings == UIStateChangeType_Set;
 41071: 
 41071:   // propagate the indicators to child windows
 41071:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(GetDocShell());
 41071:   if (node) {
108991:     int32_t childCount = 0;
 41071:     node->GetChildCount(&childCount);
 41071: 
108991:     for (int32_t i = 0; i < childCount; ++i) {
 41071:       nsCOMPtr<nsIDocShellTreeItem> childShell;
 41071:       node->GetChildAt(i, getter_AddRefs(childShell));
 41071:       nsCOMPtr<nsPIDOMWindow> childWindow = do_GetInterface(childShell);
 41071:       if (childWindow) {
 41071:         childWindow->SetKeyboardIndicators(aShowAccelerators, aShowFocusRings);
 41071:       }
 41071:     }
 41071:   }
 41071: 
 79445:   bool newShouldShowFocusRing = ShouldShowFocusRing();
 71114:   if (mHasFocus && mFocusedNode &&
 71114:       oldShouldShowFocusRing != newShouldShowFocusRing &&
 71114:       mFocusedNode->IsElement()) {
 71114:     // Update mFocusedNode's state.
 71114:     if (newShouldShowFocusRing) {
 71114:       mFocusedNode->AsElement()->AddStates(NS_EVENT_STATE_FOCUSRING);
 71114:     } else {
 71114:       mFocusedNode->AsElement()->RemoveStates(NS_EVENT_STATE_FOCUSRING);
 41071:     }
 41071:   }
 41071: }
 41071: 
 41071: void
 79445: nsGlobalWindow::GetKeyboardIndicators(bool* aShowAccelerators,
 79445:                                       bool* aShowFocusRings)
 41071: {
 41071:   FORWARD_TO_INNER_VOID(GetKeyboardIndicators, (aShowAccelerators, aShowFocusRings));
 41071: 
 41071:   *aShowAccelerators = mShowAccelerators;
 41071:   *aShowFocusRings = mShowFocusRings;
 41071: }
 41071: 
 79445: bool
108991: nsGlobalWindow::TakeFocus(bool aFocus, uint32_t aFocusMethod)
 29018: {
 80486:   FORWARD_TO_INNER(TakeFocus, (aFocus, aFocusMethod), false);
 29018: 
 90691:   if (mCleanedUp) {
 90691:     return false;
 90691:   }
 90691:   
 29018:   if (aFocus)
 41071:     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
 29018: 
 29018:   if (mHasFocus != aFocus) {
 29018:     mHasFocus = aFocus;
 80486:     UpdateCanvasFocus(true, mFocusedNode);
 29018:   }
 29018: 
 29018:   // if mNeedsFocus is true, then the document has not yet received a
 29018:   // document-level focus event. If there is a root content node, then return
 29018:   // true to tell the calling focus manager that a focus event is expected. If
 29018:   // there is no root content node, the document hasn't loaded enough yet, or
 29018:   // there isn't one and there is no point in firing a focus event.
106838:   if (aFocus && mNeedsFocus && mDoc && mDoc->GetRootElement() != nullptr) {
 80486:     mNeedsFocus = false;
 80486:     return true;
 80486:   }
 80486: 
 80486:   mNeedsFocus = false;
 80486:   return false;
 29018: }
 29018: 
 29018: void
 29018: nsGlobalWindow::SetReadyForFocus()
 29018: {
 29018:   FORWARD_TO_INNER_VOID(SetReadyForFocus, ());
 29018: 
 79445:   bool oldNeedsFocus = mNeedsFocus;
 80486:   mNeedsFocus = false;
 29018: 
 41071:   // update whether focus rings need to be shown using the state from the
 41071:   // root window
 41071:   nsPIDOMWindow* root = GetPrivateRoot();
 41071:   if (root) {
 79445:     bool showAccelerators, showFocusRings;
 41071:     root->GetKeyboardIndicators(&showAccelerators, &showFocusRings);
 41071:     mShowFocusRings = showFocusRings;
 41071:   }
 41071: 
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm)
 33917:     fm->WindowShown(this, oldNeedsFocus);
 29018: }
 29018: 
 29018: void
 29018: nsGlobalWindow::PageHidden()
 29018: {
 29018:   FORWARD_TO_INNER_VOID(PageHidden, ());
 29018: 
 29018:   // the window is being hidden, so tell the focus manager that the frame is
 29018:   // no longer valid. Use the persisted field to determine if the document
 29018:   // is being destroyed.
 29018: 
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm)
 29018:     fm->WindowHidden(this);
 29018: 
 80486:   mNeedsFocus = true;
 29018: }
 29018: 
 68732: class HashchangeCallback : public nsRunnable
 68732: {
 68729: public:
 68729:   HashchangeCallback(const nsAString &aOldURL,
 68729:                      const nsAString &aNewURL,
 68729:                      nsGlobalWindow* aWindow)
 68729:     : mWindow(aWindow)
 68729:   {
 68729:     mOldURL.Assign(aOldURL);
 68729:     mNewURL.Assign(aNewURL);
 68729:   }
 68729: 
 68729:   NS_IMETHOD Run()
 68729:   {
 68729:     NS_PRECONDITION(NS_IsMainThread(), "Should be called on the main thread.");
 68729:     return mWindow->FireHashchange(mOldURL, mNewURL);
 68729:   }
 68729: 
 68729: private:
 68729:   nsString mOldURL;
 68729:   nsString mNewURL;
 68729:   nsRefPtr<nsGlobalWindow> mWindow;
 68729: };
 68729: 
 29975: nsresult
 68729: nsGlobalWindow::DispatchAsyncHashchange(nsIURI *aOldURI, nsIURI *aNewURI)
 68729: {
 68729:   FORWARD_TO_INNER(DispatchAsyncHashchange, (aOldURI, aNewURI), NS_OK);
 68729: 
 68729:   // Make sure that aOldURI and aNewURI are identical up to the '#', and that
 68729:   // their hashes are different.
110974:   nsAutoCString oldBeforeHash, oldHash, newBeforeHash, newHash;
 68729:   nsContentUtils::SplitURIAtHash(aOldURI, oldBeforeHash, oldHash);
 68729:   nsContentUtils::SplitURIAtHash(aNewURI, newBeforeHash, newHash);
 68729: 
 68729:   NS_ENSURE_STATE(oldBeforeHash.Equals(newBeforeHash));
 68729:   NS_ENSURE_STATE(!oldHash.Equals(newHash));
 68729: 
110974:   nsAutoCString oldSpec, newSpec;
 68729:   aOldURI->GetSpec(oldSpec);
 68729:   aNewURI->GetSpec(newSpec);
 68729: 
 68729:   NS_ConvertUTF8toUTF16 oldWideSpec(oldSpec);
 68729:   NS_ConvertUTF8toUTF16 newWideSpec(newSpec);
 68729: 
 68729:   nsCOMPtr<nsIRunnable> callback =
 68729:     new HashchangeCallback(oldWideSpec, newWideSpec, this);
 68729:   return NS_DispatchToMainThread(callback);
 58340: }
 58340: 
 58340: nsresult
 68729: nsGlobalWindow::FireHashchange(const nsAString &aOldURL,
 68729:                                const nsAString &aNewURL)
 58340: {
 58340:   NS_ENSURE_TRUE(IsInnerWindow(), NS_ERROR_FAILURE);
 29975: 
 29975:   // Don't do anything if the window is frozen.
 29975:   if (IsFrozen())
 29975:     return NS_OK;
 29975: 
 68729:   // Get a presentation shell for use in creating the hashchange event.
 68729:   NS_ENSURE_STATE(mDoc);
 68729: 
 68729:   nsIPresShell *shell = mDoc->GetShell();
 68729:   nsRefPtr<nsPresContext> presContext;
 68729:   if (shell) {
 68729:     presContext = shell->GetPresContext();
 68729:   }
 68729: 
 68729:   // Create a new hashchange event.
 68729:   nsCOMPtr<nsIDOMEvent> domEvent;
 68729:   nsresult rv =
106838:     nsEventDispatcher::CreateEvent(presContext, nullptr,
 68729:                                    NS_LITERAL_STRING("hashchangeevent"),
 68729:                                    getter_AddRefs(domEvent));
 68729:   NS_ENSURE_SUCCESS(rv, rv);
 68729: 
 68729:   nsCOMPtr<nsIDOMHashChangeEvent> hashchangeEvent = do_QueryInterface(domEvent);
 68729:   NS_ENSURE_TRUE(hashchangeEvent, NS_ERROR_UNEXPECTED);
 68729: 
 68729:   // The hashchange event bubbles and isn't cancellable.
 68729:   rv = hashchangeEvent->InitHashChangeEvent(NS_LITERAL_STRING("hashchange"),
 80486:                                             true, false,
 68729:                                             aOldURL, aNewURL);
 68729:   NS_ENSURE_SUCCESS(rv, rv);
 68729: 
101616:   rv = domEvent->SetTrusted(true);
 68729:   NS_ENSURE_SUCCESS(rv, rv);
 68729: 
 79445:   bool dummy;
 68729:   return DispatchEvent(hashchangeEvent, &dummy);
 29975: }
 29975: 
 37802: nsresult
 63195: nsGlobalWindow::DispatchSyncPopState()
 63195: {
 63195:   FORWARD_TO_INNER(DispatchSyncPopState, (), NS_OK);
 37802: 
 37802:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
 37802:                "Must be safe to run script here.");
 37802: 
 37802:   // Check that PopState hasn't been pref'ed off.
 79445:   if (!Preferences::GetBool(sPopStatePrefStr, false)) {
 70840:     return NS_OK;
 70840:   }
 37802: 
 37802:   nsresult rv = NS_OK;
 37802: 
 37802:   // Bail if the window is frozen.
 37802:   if (IsFrozen()) {
 37802:     return NS_OK;
 37802:   }
 37802: 
 37802:   // Get the document's pending state object -- it contains the data we're
 69563:   // going to send along with the popstate event.  The object is serialized
 69563:   // using structured clone.
 37802:   nsCOMPtr<nsIVariant> stateObj;
 69563:   rv = mDoc->GetStateObject(getter_AddRefs(stateObj));
 37802:   NS_ENSURE_SUCCESS(rv, rv);
 37802: 
 37802:   // Obtain a presentation shell for use in creating a popstate event.
 46225:   nsIPresShell *shell = mDoc->GetShell();
 39823:   nsRefPtr<nsPresContext> presContext;
 37802:   if (shell) {
 37802:     presContext = shell->GetPresContext();
 37802:   }
 37802: 
 37802:   // Create a new popstate event
 37802:   nsCOMPtr<nsIDOMEvent> domEvent;
106838:   rv = nsEventDispatcher::CreateEvent(presContext, nullptr,
 37802:                                       NS_LITERAL_STRING("popstateevent"),
 37802:                                       getter_AddRefs(domEvent));
 37802:   NS_ENSURE_SUCCESS(rv, rv);
 37802: 
 37802:   // Initialize the popstate event, which does bubble but isn't cancellable.
 63195:   nsCOMPtr<nsIDOMPopStateEvent> popstateEvent = do_QueryInterface(domEvent);
 37802:   rv = popstateEvent->InitPopStateEvent(NS_LITERAL_STRING("popstate"),
 80486:                                         true, false,
 63195:                                         stateObj);
 37802:   NS_ENSURE_SUCCESS(rv, rv);
 37802: 
101616:   rv = domEvent->SetTrusted(true);
 37802:   NS_ENSURE_SUCCESS(rv, rv);
 37802: 
 37802:   nsCOMPtr<nsIDOMEventTarget> outerWindow =
 37802:     do_QueryInterface(GetOuterWindow());
 37802:   NS_ENSURE_TRUE(outerWindow, NS_ERROR_UNEXPECTED);
 37802: 
101616:   rv = domEvent->SetTarget(outerWindow);
 37802:   NS_ENSURE_SUCCESS(rv, rv);
 37802: 
 79445:   bool dummy; // default action
 63195:   return DispatchEvent(popstateEvent, &dummy);
 37802: }
 37802: 
 37802: // Find an nsICanvasFrame under aFrame.  Only search the principal
 29018: // child lists.  aFrame must be non-null.
 34149: static nsCanvasFrame* FindCanvasFrame(nsIFrame* aFrame)
 34149: {
 34149:     nsCanvasFrame* canvasFrame = do_QueryFrame(aFrame);
 29018:     if (canvasFrame) {
 29018:         return canvasFrame;
 29018:     }
 29018: 
 77154:     nsIFrame* kid = aFrame->GetFirstPrincipalChild();
 29018:     while (kid) {
 29018:         canvasFrame = FindCanvasFrame(kid);
 29018:         if (canvasFrame) {
 29018:             return canvasFrame;
 29018:         }
 29018:         kid = kid->GetNextSibling();
 29018:     }
 29018: 
106838:     return nullptr;
 29018: }
 29018: 
 29018: //-------------------------------------------------------
 29018: // Tells the HTMLFrame/CanvasFrame that is now has focus
 29018: void
 79445: nsGlobalWindow::UpdateCanvasFocus(bool aFocusChanged, nsIContent* aNewContent)
 29018: {
 29018:   // this is called from the inner window so use GetDocShell
 29018:   nsIDocShell* docShell = GetDocShell();
 29018:   if (!docShell)
 29018:     return;
 29018: 
 29018:   nsCOMPtr<nsIEditorDocShell> editorDocShell = do_QueryInterface(docShell);
 29018:   if (editorDocShell) {
 79445:     bool editable;
 29018:     editorDocShell->GetEditable(&editable);
 29018:     if (editable)
 29018:       return;
 29018:   }
 29018: 
 29018:   nsCOMPtr<nsIPresShell> presShell;
 29018:   docShell->GetPresShell(getter_AddRefs(presShell));
 29018:   if (!presShell || !mDocument)
 29018:     return;
 29018: 
 29018:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
 41634:   Element *rootElement = doc->GetRootElement();
 41634:   if (rootElement) {
 29018:       if ((mHasFocus || aFocusChanged) &&
 41634:           (mFocusedNode == rootElement || aNewContent == rootElement)) {
 41634:           nsIFrame* frame = rootElement->GetPrimaryFrame();
 29018:           if (frame) {
 29018:               frame = frame->GetParent();
 34149:               nsCanvasFrame* canvasFrame = do_QueryFrame(frame);
 29018:               if (canvasFrame) {
 41634:                   canvasFrame->SetHasFocus(mHasFocus && rootElement == aNewContent);
 29018:               }
 29018:           }
 29018:       }
 29018:   } else {
 29018:       // Look for the frame the hard way
 29018:       nsIFrame* frame = presShell->GetRootFrame();
 29018:       if (frame) {
 34149:           nsCanvasFrame* canvasFrame = FindCanvasFrame(frame);
 29018:           if (canvasFrame) {
 80486:               canvasFrame->SetHasFocus(false);
 29018:           }
 29018:       }      
 29018:   }
 29018: }
 29018: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetComputedStyle(nsIDOMElement* aElt,
     1:                                  const nsAString& aPseudoElt,
     1:                                  nsIDOMCSSStyleDeclaration** aReturn)
     1: {
     1:   FORWARD_TO_OUTER(GetComputedStyle, (aElt, aPseudoElt, aReturn),
     1:                    NS_ERROR_NOT_INITIALIZED);
 36884: 
 36884:   NS_ENSURE_ARG_POINTER(aReturn);
106838:   *aReturn = nullptr;
 36884: 
 36884:   if (!aElt) {
 36884:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 36884:   }
 36884: 
 36884:   if (!mDocShell) {
 36884:     return NS_OK;
 36884:   }
 36884: 
 36884:   nsCOMPtr<nsIPresShell> presShell;
 36884:   mDocShell->GetPresShell(getter_AddRefs(presShell));
 36884: 
 36884:   if (!presShell) {
 36884:     return NS_OK;
 36884:   }
 36884: 
105781:   nsCOMPtr<dom::Element> element = do_QueryInterface(aElt);
105781:   NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
105781:   nsRefPtr<nsComputedDOMStyle> compStyle =
105781:     NS_NewComputedDOMStyle(element, aPseudoElt, presShell);
 30385: 
 30385:   *aReturn = compStyle.forget().get();
 30385: 
 30385:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetSessionStorage(nsIDOMStorage ** aSessionStorage)
     1: {
     1:   FORWARD_TO_INNER(GetSessionStorage, (aSessionStorage), NS_ERROR_UNEXPECTED);
     1: 
     1:   nsIPrincipal *principal = GetPrincipal();
 28676:   nsIDocShell* docShell = GetDocShell();
     1: 
     1:   if (!principal || !docShell) {
106838:     *aSessionStorage = nullptr;
 55110:     return NS_OK;
 55110:   }
 55110: 
 70840:   if (!Preferences::GetBool(kStorageEnabled)) {
106838:     *aSessionStorage = nullptr;
     1:     return NS_OK;
     1:   }
     1: 
 37608:   if (mSessionStorage) {
 37608: #ifdef PR_LOGGING
 37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
 37608:       PR_LogPrint("nsGlobalWindow %p has %p sessionStorage", this, mSessionStorage.get());
 37608:     }
 37608: #endif
 37608:     nsCOMPtr<nsPIDOMStorage> piStorage = do_QueryInterface(mSessionStorage);
 37608:     if (piStorage) {
 79445:       bool canAccess = piStorage->CanAccess(principal);
 37608:       NS_ASSERTION(canAccess,
 37608:                    "window %x owned sessionStorage "
 37608:                    "that could not be accessed!");
 37608:       if (!canAccess) {
106838:           mSessionStorage = nullptr;
 37608:       }
 37608:     }
 37608:   }
 37608: 
 37608:   if (!mSessionStorage) {
106838:     *aSessionStorage = nullptr;
 37608: 
 37608:     nsString documentURI;
 68775:     if (mDocument) {
 64020:       mDocument->GetDocumentURI(documentURI);
 68775:     }
 37608: 
108822:     // If the document has the sandboxed origin flag set
108822:     // don't allow access to localStorage.
108822:     if (!mDoc) {
108822:       return NS_ERROR_FAILURE;
108822:     }
108822: 
108822:     if (mDoc->GetSandboxFlags() & SANDBOXED_ORIGIN) {
108822:       return NS_ERROR_DOM_SECURITY_ERR;
108822:     }
108822: 
 23579:     nsresult rv = docShell->GetSessionStorageForPrincipal(principal,
 37608:                                                           documentURI,
 80486:                                                           true,
 37608:                                                           getter_AddRefs(mSessionStorage));
 23579:     NS_ENSURE_SUCCESS(rv, rv);
 23579: 
 37608: #ifdef PR_LOGGING
 37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
 37608:       PR_LogPrint("nsGlobalWindow %p tried to get a new sessionStorage %p", this, mSessionStorage.get());
 37608:     }
 37608: #endif
 37608: 
 37608:     if (!mSessionStorage) {
 23579:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 23579:     }
 99539: 
 99539:     nsCOMPtr<nsIPrivacyTransitionObserver> obs = do_GetInterface(mSessionStorage);
 99539:     if (obs) {
 99539:       docShell->AddWeakPrivacyTransitionObserver(obs);
 99539:     }
 37608:   }
 37608: 
 37608: #ifdef PR_LOGGING
 37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
 37608:       PR_LogPrint("nsGlobalWindow %p returns %p sessionStorage", this, mSessionStorage.get());
 37608:     }
 37608: #endif
 37608: 
 37608:   NS_ADDREF(*aSessionStorage = mSessionStorage);
 23579:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 28438: nsGlobalWindow::GetLocalStorage(nsIDOMStorage ** aLocalStorage)
 26323: {
 26323:   FORWARD_TO_INNER(GetLocalStorage, (aLocalStorage), NS_ERROR_UNEXPECTED);
 26323: 
 26323:   NS_ENSURE_ARG(aLocalStorage);
 26323: 
 70840:   if (!Preferences::GetBool(kStorageEnabled)) {
106838:     *aLocalStorage = nullptr;
 55110:     return NS_OK;
 55110:   }
 55110: 
 26323:   if (!mLocalStorage) {
106838:     *aLocalStorage = nullptr;
 26323: 
 26323:     nsresult rv;
 26323: 
 99539:     if (!nsDOMStorage::CanUseStorage())
 28495:       return NS_ERROR_DOM_SECURITY_ERR;
 28495: 
 26323:     nsIPrincipal *principal = GetPrincipal();
 26323:     if (!principal)
 26323:       return NS_OK;
 26323: 
 26323:     nsCOMPtr<nsIDOMStorageManager> storageManager =
 26323:       do_GetService("@mozilla.org/dom/storagemanager;1", &rv);
 26323:     NS_ENSURE_SUCCESS(rv, rv);
 26323: 
 37608:     nsString documentURI;
 68775:     if (mDocument) {
 64020:       mDocument->GetDocumentURI(documentURI);
 68775:     }
 37608: 
108822:     // If the document has the sandboxed origin flag set
108822:     // don't allow access to localStorage.
108822:     if (mDoc && (mDoc->GetSandboxFlags() & SANDBOXED_ORIGIN)) {
108822:       return NS_ERROR_DOM_SECURITY_ERR;
108822:     }
108822: 
 99539:     nsIDocShell* docShell = GetDocShell();
 99539:     nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(docShell);
 99539: 
 37608:     rv = storageManager->GetLocalStorageForPrincipal(principal,
 37608:                                                      documentURI,
 99539:                                                      loadContext && loadContext->UsePrivateBrowsing(),
 37608:                                                      getter_AddRefs(mLocalStorage));
 26323:     NS_ENSURE_SUCCESS(rv, rv);
 99539: 
 99539:     nsCOMPtr<nsIPrivacyTransitionObserver> obs = do_GetInterface(mLocalStorage);
 99539:     if (obs && docShell) {
 99539:       docShell->AddWeakPrivacyTransitionObserver(obs);
 99539:     }
 26323:   }
 26323: 
 26323:   NS_ADDREF(*aLocalStorage = mLocalStorage);
 26323:   return NS_OK;
 26323: }
 26323: 
 60385: //*****************************************************************************
 60385: // nsGlobalWindow::nsIDOMStorageIndexedDB
 60385: //*****************************************************************************
 60385: 
 44204: NS_IMETHODIMP
103210: nsGlobalWindow::GetIndexedDB(nsIIDBFactory** _retval)
 44204: {
 44204:   if (!mIndexedDB) {
100051:     nsresult rv;
100051: 
108831:     // If the document has the sandboxed origin flag set
108831:     // don't allow access to indexedDB.
108831:     if (mDoc && (mDoc->GetSandboxFlags() & SANDBOXED_ORIGIN)) {
108831:       return NS_ERROR_DOM_SECURITY_ERR;
108831:     }
108831: 
 76987:     if (!IsChromeWindow()) {
 61353:       nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil =
 61353:         do_GetService(THIRDPARTYUTIL_CONTRACTID);
 61353:       NS_ENSURE_TRUE(thirdPartyUtil, NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR);
 61353: 
 79445:       bool isThirdParty;
106838:       rv = thirdPartyUtil->IsThirdPartyWindow(this, nullptr, &isThirdParty);
 61353:       NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR);
 61353: 
 61353:       if (isThirdParty) {
 61353:         NS_WARNING("IndexedDB is not permitted in a third-party window.");
106838:         *_retval = nullptr;
 61353:         return NS_OK;
 61353:       }
 76987:     }
 61353: 
100051:     // This may be null if being created from a file.
107198:     rv = indexedDB::IDBFactory::Create(this, nullptr,
107198:                                        getter_AddRefs(mIndexedDB));
100051:     NS_ENSURE_SUCCESS(rv, rv);
 44204:   }
 44204: 
 46347:   nsCOMPtr<nsIIDBFactory> request(mIndexedDB);
 44204:   request.forget(_retval);
 44204:   return NS_OK;
 44204: }
 44204: 
     1: //*****************************************************************************
     1: // nsGlobalWindow::nsIInterfaceRequestor
     1: //*****************************************************************************
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalWindow::GetInterface(const nsIID & aIID, void **aSink)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aSink);
106838:   *aSink = nullptr;
     1: 
     1:   if (aIID.Equals(NS_GET_IID(nsIDocCharset))) {
     1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:     if (mDocShell) {
     1:       nsCOMPtr<nsIDocCharset> docCharset(do_QueryInterface(mDocShell));
     1:       if (docCharset) {
 88006:         NS_WARNING("Using deprecated nsIDocCharset: use nsIDocShell.GetCharset() instead ");
     1:         *aSink = docCharset;
     1:         NS_ADDREF(((nsISupports *) *aSink));
     1:       }
     1:     }
     1:   }
     1:   else if (aIID.Equals(NS_GET_IID(nsIWebNavigation))) {
     1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:     if (mDocShell) {
     1:       nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:       if (webNav) {
     1:         *aSink = webNav;
     1:         NS_ADDREF(((nsISupports *) *aSink));
     1:       }
     1:     }
     1:   }
101815:   else if (aIID.Equals(NS_GET_IID(nsIDocShell))) {
101815:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
101815: 
101817:     nsCOMPtr<nsIDocShell> docShell = mDocShell;
101815:     docShell.forget(aSink);
101815:   }
     1: #ifdef NS_PRINTING
     1:   else if (aIID.Equals(NS_GET_IID(nsIWebBrowserPrint))) {
     1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:     if (mDocShell) {
     1:       nsCOMPtr<nsIContentViewer> viewer;
     1:       mDocShell->GetContentViewer(getter_AddRefs(viewer));
     1:       if (viewer) {
     1:         nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint(do_QueryInterface(viewer));
     1:         if (webBrowserPrint) {
     1:           *aSink = webBrowserPrint;
     1:           NS_ADDREF(((nsISupports *) *aSink));
     1:         }
     1:       }
     1:     }
     1:   }
     1: #endif
 63880:   else if (aIID.Equals(NS_GET_IID(nsIDOMWindowUtils))) {
     1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
     1: 
 94546:     if (!mWindowUtils) {
 94546:       mWindowUtils = new nsDOMWindowUtils(this);
 94546:     }
 94546: 
 94546:     *aSink = mWindowUtils;
     1:     NS_ADDREF(((nsISupports *) *aSink));
     1:   }
     1:   else {
     1:     return QueryInterface(aIID, aSink);
     1:   }
     1: 
     1:   return *aSink ? NS_OK : NS_ERROR_NO_INTERFACE;
     1: }
     1: 
     1: void
     1: nsGlobalWindow::FireOfflineStatusEvent()
     1: {
     1:   if (!mDoc)
     1:     return;
     1:   nsAutoString name;
     1:   if (NS_IsOffline()) {
     1:     name.AssignLiteral("offline");
     1:   } else {
     1:     name.AssignLiteral("online");
     1:   }
     1:   // The event is fired at the body element, or if there is no body element,
     1:   // at the document.
     1:   nsCOMPtr<nsISupports> eventTarget = mDoc.get();
     1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDoc);
     1:   if (htmlDoc) {
     1:     nsCOMPtr<nsIDOMHTMLElement> body;
     1:     htmlDoc->GetBody(getter_AddRefs(body));
     1:     if (body) {
     1:       eventTarget = body;
     1:     }
     1:   }
     1:   else {
     1:     nsCOMPtr<nsIDOMElement> documentElement;
     1:     mDocument->GetDocumentElement(getter_AddRefs(documentElement));
     1:     if(documentElement) {        
     1:       eventTarget = documentElement;
     1:     }
     1:   }
 80486:   nsContentUtils::DispatchTrustedEvent(mDoc, eventTarget, name, true, false);
     1: }
     1: 
103224: class NotifyIdleObserverRunnable : public nsRunnable
103224: {
103224: public:
103224:   NotifyIdleObserverRunnable(nsIIdleObserver* aIdleObserver,
108991:                              uint32_t aTimeInS,
103224:                              bool aCallOnidle,
103224:                              nsGlobalWindow* aIdleWindow)
103224:     : mIdleObserver(aIdleObserver), mTimeInS(aTimeInS), mIdleWindow(aIdleWindow),
103224:       mCallOnidle(aCallOnidle)
103224:   { }
103224: 
103224:   NS_IMETHOD Run()
103224:   {
103224:     if (mIdleWindow->ContainsIdleObserver(mIdleObserver, mTimeInS)) {
103224:       return mCallOnidle ? mIdleObserver->Onidle() : mIdleObserver->Onactive();
103224:     }
103224:     return NS_OK;
103224:   }
103224: 
103224: private:
103224:   nsCOMPtr<nsIIdleObserver> mIdleObserver;
108991:   uint32_t mTimeInS;
103224:   nsRefPtr<nsGlobalWindow> mIdleWindow;
103224: 
103224:   // If false then call on active
103224:   bool mCallOnidle;
103224: };
103224: 
103224: void
104635: nsGlobalWindow::NotifyIdleObserver(IdleObserverHolder* aIdleObserverHolder,
103224:                                    bool aCallOnidle)
103224: {
104635:   MOZ_ASSERT(aIdleObserverHolder);
104635:   aIdleObserverHolder->mPrevNotificationIdle = aCallOnidle;
104635: 
103224:   nsCOMPtr<nsIRunnable> caller =
104635:     new NotifyIdleObserverRunnable(aIdleObserverHolder->mIdleObserver,
104635:                                    aIdleObserverHolder->mTimeInS,
103224:                                    aCallOnidle, this);
103224:   if (NS_FAILED(NS_DispatchToCurrentThread(caller))) {
103224:     NS_WARNING("Failed to dispatch thread for idle observer notification.");
103224:   }
103224: }
103224: 
103224: bool
108991: nsGlobalWindow::ContainsIdleObserver(nsIIdleObserver* aIdleObserver, uint32_t aTimeInS)
103224: {
103224:   MOZ_ASSERT(aIdleObserver, "Idle observer not instantiated.");
103224:   bool found = false;
103224:   nsTObserverArray<IdleObserverHolder>::ForwardIterator iter(mIdleObservers);
103224:   while (iter.HasMore()) {
103224:     IdleObserverHolder& idleObserver = iter.GetNext();
103224:     if (idleObserver.mIdleObserver == aIdleObserver &&
103224:         idleObserver.mTimeInS == aTimeInS) {
103224:       found = true;
103224:       break;
103224:     }
103224:   }
103224:   return found;
103224: }
103224: 
103224: void
103224: IdleActiveTimerCallback(nsITimer* aTimer, void* aClosure)
103224: {
103224:   nsRefPtr<nsGlobalWindow> idleWindow = static_cast<nsGlobalWindow*>(aClosure);
103224:   MOZ_ASSERT(idleWindow, "Idle window has not been instantiated.");
104635:   idleWindow->HandleIdleActiveEvent();
103224: }
103224: 
103224: void
103224: IdleObserverTimerCallback(nsITimer* aTimer, void* aClosure)
103224: {
103224:   nsRefPtr<nsGlobalWindow> idleWindow = static_cast<nsGlobalWindow*>(aClosure);
103224:   MOZ_ASSERT(idleWindow, "Idle window has not been instantiated.");
103224:   idleWindow->HandleIdleObserverCallback();
103224: }
103224: 
103224: void
103224: nsGlobalWindow::HandleIdleObserverCallback()
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
108991:   MOZ_ASSERT(static_cast<uint32_t>(mIdleCallbackIndex) < mIdleObservers.Length(),
103224:                                   "Idle callback index exceeds array bounds!");
104635:   IdleObserverHolder& idleObserver = mIdleObservers.ElementAt(mIdleCallbackIndex);
104635:   NotifyIdleObserver(&idleObserver, true);
103224:   mIdleCallbackIndex++;
103224:   if (NS_FAILED(ScheduleNextIdleObserverCallback())) {
103224:     NS_WARNING("Failed to set next idle observer callback.");
103224:   }
103224: }
103224: 
103224: nsresult
103224: nsGlobalWindow::ScheduleNextIdleObserverCallback()
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224:   MOZ_ASSERT(mIdleService, "No idle service!");
103224: 
103224:   if (mIdleCallbackIndex < 0 ||
108991:       static_cast<uint32_t>(mIdleCallbackIndex) >= mIdleObservers.Length()) {
103224:     return NS_OK;
103224:   }
103224: 
103224:   IdleObserverHolder& idleObserver =
103224:     mIdleObservers.ElementAt(mIdleCallbackIndex);
103224: 
108991:   uint32_t userIdleTimeMS = 0;
103224:   nsresult rv = mIdleService->GetIdleTime(&userIdleTimeMS);
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224: 
108991:   uint32_t callbackTimeMS = 0;
103763:   if (idleObserver.mTimeInS * 1000 + mIdleFuzzFactor > userIdleTimeMS) {
103763:     callbackTimeMS = idleObserver.mTimeInS * 1000 - userIdleTimeMS + mIdleFuzzFactor;
103224:   }
103224: 
103224:   mIdleTimer->Cancel();
103224:   rv = mIdleTimer->InitWithFuncCallback(IdleObserverTimerCallback,
103224:                                         this,
103224:                                         callbackTimeMS,
103224:                                         nsITimer::TYPE_ONE_SHOT);
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224: 
103224:   return NS_OK;
103224: }
103224: 
108991: uint32_t
103224: nsGlobalWindow::GetFuzzTimeMS()
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224: 
103224:   if (sIdleObserversAPIFuzzTimeDisabled) {
103224:     return 0;
103224:   }
103224: 
108991:   uint32_t randNum = MAX_IDLE_FUZZ_TIME_MS;
108991:   size_t nbytes = PR_GetRandomNoise(&randNum, sizeof(randNum));
103224:   if (nbytes != sizeof(randNum)) {
103224:     NS_WARNING("PR_GetRandomNoise(...) Not implemented or no available noise!");
103224:     return MAX_IDLE_FUZZ_TIME_MS;
103224:   }
103224: 
103224:   if (randNum > MAX_IDLE_FUZZ_TIME_MS) {
104634:     randNum %= MAX_IDLE_FUZZ_TIME_MS;
103224:   }
103224: 
103224:   return randNum;
103224: }
103224: 
103224: nsresult
103224: nsGlobalWindow::ScheduleActiveTimerCallback()
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224: 
103224:   if (!mAddActiveEventFuzzTime) {
104635:     return HandleIdleActiveEvent();
103224:   }
103224: 
103224:   MOZ_ASSERT(mIdleTimer);
103224:   mIdleTimer->Cancel();
103224: 
108991:   uint32_t fuzzFactorInMS = GetFuzzTimeMS();
103224:   nsresult rv = mIdleTimer->InitWithFuncCallback(IdleActiveTimerCallback,
103224:                                                  this,
103224:                                                  fuzzFactorInMS,
103224:                                                  nsITimer::TYPE_ONE_SHOT);
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224:   return NS_OK;
103224: }
103224: 
103224: nsresult
104635: nsGlobalWindow::HandleIdleActiveEvent()
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224: 
103224:   if (mCurrentlyIdle) {
103224:     mIdleCallbackIndex = 0;
103763:     mIdleFuzzFactor = GetFuzzTimeMS();
103224:     nsresult rv = ScheduleNextIdleObserverCallback();
103224:     NS_ENSURE_SUCCESS(rv, rv);
103224:     return NS_OK;
103224:   }
103224: 
103224:   mIdleCallbackIndex = -1;
103763:   MOZ_ASSERT(mIdleTimer);
103763:   mIdleTimer->Cancel();
103224:   nsTObserverArray<IdleObserverHolder>::ForwardIterator iter(mIdleObservers);
103224:   while (iter.HasMore()) {
103224:     IdleObserverHolder& idleObserver = iter.GetNext();
104635:     if (idleObserver.mPrevNotificationIdle) {
104635:       NotifyIdleObserver(&idleObserver, false);
104635:     }
103224:   }
103224: 
103224:   return NS_OK;
103224: }
103224: 
108991: uint32_t
103224: nsGlobalWindow::FindInsertionIndex(IdleObserverHolder* aIdleObserver)
103224: {
103224:   MOZ_ASSERT(aIdleObserver, "Idle observer not instantiated.");
103224: 
108991:   uint32_t i = 0;
103224:   nsTObserverArray<IdleObserverHolder>::ForwardIterator iter(mIdleObservers);
103224:   while (iter.HasMore()) {
103224:     IdleObserverHolder& idleObserver = iter.GetNext();
103224:     if (idleObserver.mTimeInS > aIdleObserver->mTimeInS) {
103224:       break;
103224:     }
103224:     i++;
103224:     MOZ_ASSERT(i <= mIdleObservers.Length(), "Array index out of bounds error.");
103224:   }
103224: 
103224:   return i;
103224: }
103224: 
103224: nsresult
103224: nsGlobalWindow::RegisterIdleObserver(nsIIdleObserver* aIdleObserver)
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224: 
103224:   nsresult rv;
103224:   if (mIdleObservers.IsEmpty()) {
103224:     mIdleService = do_GetService("@mozilla.org/widget/idleservice;1", &rv);
103224:     NS_ENSURE_SUCCESS(rv, rv);
103224: 
103224:     rv = mIdleService->AddIdleObserver(mObserver, MIN_IDLE_NOTIFICATION_TIME_S);
103224:     NS_ENSURE_SUCCESS(rv, rv);
103224: 
103224:     if (!mIdleTimer) {
103224:       mIdleTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
103224:       NS_ENSURE_SUCCESS(rv, rv);
103224:     } else {
103224:       mIdleTimer->Cancel();
103224:     }
103224:   }
103224: 
103224:   MOZ_ASSERT(mIdleService);
103224:   MOZ_ASSERT(mIdleTimer);
103224: 
103224:   IdleObserverHolder tmpIdleObserver;
103224:   tmpIdleObserver.mIdleObserver = aIdleObserver;
103224:   rv = aIdleObserver->GetTime(&tmpIdleObserver.mTimeInS);
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224:   NS_ENSURE_ARG_MAX(tmpIdleObserver.mTimeInS, PR_UINT32_MAX / 1000);
103224:   NS_ENSURE_ARG_MIN(tmpIdleObserver.mTimeInS, MIN_IDLE_NOTIFICATION_TIME_S);
103224: 
108991:   uint32_t insertAtIndex = FindInsertionIndex(&tmpIdleObserver);
103224:   if (insertAtIndex == mIdleObservers.Length()) {
103224:     mIdleObservers.AppendElement(tmpIdleObserver);
103224:   }
103224:   else {
103224:     mIdleObservers.InsertElementAt(insertAtIndex, tmpIdleObserver);
103224:   }
103224: 
103224:   bool userIsIdle = false;
103224:   rv = nsContentUtils::IsUserIdle(MIN_IDLE_NOTIFICATION_TIME_S, &userIsIdle);
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224: 
103224:   // Special case. First idle observer added to empty list while the user is idle.
103224:   // Haven't received 'idle' topic notification from slow idle service yet.
103224:   // Need to wait for the idle notification and then notify idle observers in the list.
103224:   if (userIsIdle && mIdleCallbackIndex == -1) {
103224:     return NS_OK;
103224:   }
103224: 
103426:   if (!mCurrentlyIdle) {
103426:     return NS_OK;
103426:   }
103426: 
103224:   MOZ_ASSERT(mIdleCallbackIndex >= 0);
103224: 
108991:   if (static_cast<int32_t>(insertAtIndex) < mIdleCallbackIndex) {
104635:     IdleObserverHolder& idleObserver = mIdleObservers.ElementAt(insertAtIndex);
104635:     NotifyIdleObserver(&idleObserver, true);
103224:     mIdleCallbackIndex++;
103224:     return NS_OK;
103224:   }
103224: 
108991:   if (static_cast<int32_t>(insertAtIndex) == mIdleCallbackIndex) {
103224:     mIdleTimer->Cancel();
103224:     rv = ScheduleNextIdleObserverCallback();
103224:     NS_ENSURE_SUCCESS(rv, rv);
103224:   }
103224:   return NS_OK;
103224: }
103224: 
103224: nsresult
103224: nsGlobalWindow::FindIndexOfElementToRemove(nsIIdleObserver* aIdleObserver,
108991:                                            int32_t* aRemoveElementIndex)
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224:   MOZ_ASSERT(aIdleObserver, "Idle observer not instantiated.");
103224: 
103224:   *aRemoveElementIndex = 0;
103224:   if (mIdleObservers.IsEmpty()) {
103224:     return NS_ERROR_FAILURE;
103224:   }
103224: 
108991:   uint32_t aIdleObserverTimeInS;
103224:   nsresult rv = aIdleObserver->GetTime(&aIdleObserverTimeInS);
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224:   NS_ENSURE_ARG_MIN(aIdleObserverTimeInS, MIN_IDLE_NOTIFICATION_TIME_S);
103224: 
103224:   nsTObserverArray<IdleObserverHolder>::ForwardIterator iter(mIdleObservers);
103224:   while (iter.HasMore()) {
103224:     IdleObserverHolder& idleObserver = iter.GetNext();
103224:     if (idleObserver.mTimeInS == aIdleObserverTimeInS &&
103224:         idleObserver.mIdleObserver == aIdleObserver ) {
103224:       break;
103224:     }
103224:     (*aRemoveElementIndex)++;
103224:   }
108991:   return static_cast<uint32_t>(*aRemoveElementIndex) >= mIdleObservers.Length() ?
103224:     NS_ERROR_FAILURE : NS_OK;
103224: }
103224: 
103224: nsresult
103224: nsGlobalWindow::UnregisterIdleObserver(nsIIdleObserver* aIdleObserver)
103224: {
103224:   MOZ_ASSERT(IsInnerWindow(), "Must be an inner window!");
103224: 
108991:   int32_t removeElementIndex;
103224:   nsresult rv = FindIndexOfElementToRemove(aIdleObserver, &removeElementIndex);
103224:   if (NS_FAILED(rv)) {
103224:     NS_WARNING("Idle observer not found in list of idle observers. No idle observer removed.");
103224:     return NS_OK;
103224:   }
103224:   mIdleObservers.RemoveElementAt(removeElementIndex);
103224: 
103426:   MOZ_ASSERT(mIdleTimer);
103224:   if (mIdleObservers.IsEmpty() && mIdleService) {
103224:     rv = mIdleService->RemoveIdleObserver(mObserver, MIN_IDLE_NOTIFICATION_TIME_S);
103224:     NS_ENSURE_SUCCESS(rv, rv);
106838:     mIdleService = nullptr;
103224: 
103426:     mIdleTimer->Cancel();
103224:     mIdleCallbackIndex = -1;
103224:     return NS_OK;
103224:   }
103224: 
103224:   if (!mCurrentlyIdle) {
103224:     return NS_OK;
103224:   }
103224: 
103224:   if (removeElementIndex < mIdleCallbackIndex) {
103224:     mIdleCallbackIndex--;
103224:     return NS_OK;
103224:   }
103224: 
103224:   if (removeElementIndex != mIdleCallbackIndex) {
103224:     return NS_OK;
103224:   }
103224: 
103224:   mIdleTimer->Cancel();
103224: 
103224:   // If the last element in the array had been notified then decrement
103224:   // mIdleCallbackIndex because an idle was removed from the list of
103224:   // idle observers.
103224:   // Example: add idle observer with time 1, 2, 3,
103224:   // Idle notifications for idle observers with time 1, 2, 3 are complete
103224:   // Remove idle observer with time 3 while the user is still idle.
103224:   // The user never transitioned to active state.
103224:   // Add an idle observer with idle time 4
108991:   if (static_cast<uint32_t>(mIdleCallbackIndex) == mIdleObservers.Length()) {
103224:     mIdleCallbackIndex--;
103224:   }
103224:   rv = ScheduleNextIdleObserverCallback();
103224:   NS_ENSURE_SUCCESS(rv, rv);
103224: 
103224:   return NS_OK;
103224: }
103224: 
     1: nsresult
     1: nsGlobalWindow::Observe(nsISupports* aSubject, const char* aTopic,
     1:                         const PRUnichar* aData)
     1: {
     1:   if (!nsCRT::strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC)) {
     1:     if (IsFrozen()) {
     1:       // if an even number of notifications arrive while we're frozen,
     1:       // we don't need to fire.
     1:       mFireOfflineStatusChangeEventOnThaw = !mFireOfflineStatusChangeEventOnThaw;
     1:     } else {
     1:       FireOfflineStatusEvent();
     1:     }
     1:     return NS_OK;
     1:   }
     1: 
103224:   if (!nsCRT::strcmp(aTopic, OBSERVER_TOPIC_IDLE)) {
103224:     mCurrentlyIdle = true;
103224:     if (IsFrozen()) {
103224:       // need to fire only one idle event while the window is frozen.
103224:       mNotifyIdleObserversIdleOnThaw = true;
103224:       mNotifyIdleObserversActiveOnThaw = false;
103224:     } else if (mOuterWindow && mOuterWindow->GetCurrentInnerWindow() == this) {
104635:       HandleIdleActiveEvent();
103224:     }
103224:     return NS_OK;
103224:   }
103224: 
103224:   if (!nsCRT::strcmp(aTopic, OBSERVER_TOPIC_ACTIVE)) {
103224:     mCurrentlyIdle = false;
103224:     if (IsFrozen()) {
103224:       mNotifyIdleObserversActiveOnThaw = true;
103224:       mNotifyIdleObserversIdleOnThaw = false;
103224:     } else if (mOuterWindow && mOuterWindow->GetCurrentInnerWindow() == this) {
103224:       ScheduleActiveTimerCallback();
103224:     }
103224:     return NS_OK;
103224:   }
103224: 
 37608:   if (IsInnerWindow() && !nsCRT::strcmp(aTopic, "dom-storage2-changed")) {
 37608:     nsIPrincipal *principal;
 37608:     nsresult rv;
 37608: 
 37608:     nsCOMPtr<nsIDOMStorageEvent> event = do_QueryInterface(aSubject, &rv);
 37608:     NS_ENSURE_SUCCESS(rv, rv);
 37608: 
 37608:     nsCOMPtr<nsIDOMStorage> changingStorage;
 37608:     rv = event->GetStorageArea(getter_AddRefs(changingStorage));
 37608:     NS_ENSURE_SUCCESS(rv, rv);
 37608: 
 37608:     nsCOMPtr<nsPIDOMStorage> pistorage = do_QueryInterface(changingStorage);
 37608:     nsPIDOMStorage::nsDOMStorageType storageType = pistorage->StorageType();
 37608: 
 94540:     bool fireMozStorageChanged = false;
 37608:     principal = GetPrincipal();
 37608:     switch (storageType)
 37608:     {
 37608:     case nsPIDOMStorage::SessionStorage:
 37608:     {
 37608:       nsCOMPtr<nsIDOMStorage> storage = mSessionStorage;
 37608:       if (!storage) {
 37608:         nsIDocShell* docShell = GetDocShell();
 37608:         if (principal && docShell) {
 37608:           // No need to pass documentURI here, it's only needed when we want
 80486:           // to create a new storage, the third paramater would be true
 37608:           docShell->GetSessionStorageForPrincipal(principal,
 37608:                                                   EmptyString(),
 80486:                                                   false,
 37608:                                                   getter_AddRefs(storage));
 37608:         }
 37608:       }
 37608: 
 37608:       if (!pistorage->IsForkOf(storage)) {
 37608:         // This storage event is coming from a different doc shell,
 37608:         // i.e. it is a clone, ignore this event.
 37608:         return NS_OK;
 37608:       }
 37608: 
 37608: #ifdef PR_LOGGING
 37608:       if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
 37608:         PR_LogPrint("nsGlobalWindow %p with sessionStorage %p passing event from %p", this, mSessionStorage.get(), pistorage.get());
 37608:       }
 37608: #endif
 37608: 
 94540:       fireMozStorageChanged = SameCOMIdentity(mSessionStorage, changingStorage);
 37608:       break;
 37608:     }
 37608:     case nsPIDOMStorage::LocalStorage:
 37608:     {
 37608:       // Allow event fire only for the same principal storages
 37608:       // XXX We have to use EqualsIgnoreDomain after bug 495337 lands
 37608:       nsIPrincipal *storagePrincipal = pistorage->Principal();
 79445:       bool equals;
 37608: 
 37608:       rv = storagePrincipal->Equals(principal, &equals);
 37608:       NS_ENSURE_SUCCESS(rv, rv);
 37608: 
 37608:       if (!equals)
 37608:         return NS_OK;
 37608: 
 94540:       fireMozStorageChanged = SameCOMIdentity(mLocalStorage, changingStorage);
 37608:       break;
 37608:     }
 37608:     default:
 37608:       return NS_OK;
 37608:     }
 37608: 
 94540:     // Clone the storage event included in the observer notification. We want
 94540:     // to dispatch clones rather than the original event.
 94540:     rv = CloneStorageEvent(fireMozStorageChanged ?
 94540:                            NS_LITERAL_STRING("MozStorageChanged") :
 94540:                            NS_LITERAL_STRING("storage"),
 94540:                            event);
 94540:     NS_ENSURE_SUCCESS(rv, rv);
 94540: 
101616:     event->SetTrusted(true);
 94540: 
 94540:     if (fireMozStorageChanged) {
101616:       nsEvent *internalEvent = event->GetInternalNSEvent();
 94540:       internalEvent->flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH;
 94540:     }
 94540: 
 37608:     if (IsFrozen()) {
 37608:       // This window is frozen, rather than firing the events here,
 37608:       // store the domain in which the change happened and fire the
 37608:       // events if we're ever thawed.
 37608: 
 60680:       mPendingStorageEvents.AppendObject(event);
 37608:       return NS_OK;
 37608:     }
 37608: 
 79445:     bool defaultActionEnabled;
 37608:     DispatchEvent((nsIDOMStorageEvent *)event, &defaultActionEnabled);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 56242:   if (!nsCRT::strcmp(aTopic, "offline-cache-update-added")) {
 56242:     if (mApplicationCache)
 56242:       return NS_OK;
 56242: 
 56242:     // Instantiate the application object now. It observes update belonging to
 56242:     // this window's document and correctly updates the applicationCache object
 56242:     // state.
 56242:     nsCOMPtr<nsIDOMOfflineResourceList> applicationCache;
 56242:     GetApplicationCache(getter_AddRefs(applicationCache));
 56242:     nsCOMPtr<nsIObserver> observer = do_QueryInterface(applicationCache);
 56242:     if (observer)
 56242:       observer->Observe(aSubject, aTopic, aData);
 56242: 
 56242:     return NS_OK;
 56242:   }
 56242: 
     1:   NS_WARNING("unrecognized topic in nsGlobalWindow::Observe");
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 94540: nsresult
 94540: nsGlobalWindow::CloneStorageEvent(const nsAString& aType,
 94540:                                   nsCOMPtr<nsIDOMStorageEvent>& aEvent)
 94540: {
 94540:   nsresult rv;
 94540: 
 94540:   bool canBubble;
 94540:   bool cancelable;
 94540:   nsAutoString key;
 94540:   nsAutoString oldValue;
 94540:   nsAutoString newValue;
 94540:   nsAutoString url;
 94540:   nsCOMPtr<nsIDOMStorage> storageArea;
 94540: 
 94540:   nsCOMPtr<nsIDOMEvent> domEvent = do_QueryInterface(aEvent, &rv);
 94540:   NS_ENSURE_SUCCESS(rv, rv);
 94540: 
 94540:   domEvent->GetBubbles(&canBubble);
 94540:   domEvent->GetCancelable(&cancelable);
 94540: 
 94540:   aEvent->GetKey(key);
 94540:   aEvent->GetOldValue(oldValue);
 94540:   aEvent->GetNewValue(newValue);
 94540:   aEvent->GetUrl(url);
 94540:   aEvent->GetStorageArea(getter_AddRefs(storageArea));
 94540: 
108282:   NS_NewDOMStorageEvent(getter_AddRefs(domEvent), nullptr, nullptr);
107068:   aEvent = do_QueryInterface(domEvent);
 94540:   return aEvent->InitStorageEvent(aType, canBubble, cancelable,
 94540:                                   key, oldValue, newValue,
 94540:                                   url, storageArea);
 94540: }
 94540: 
     1: nsresult
     1: nsGlobalWindow::FireDelayedDOMEvents()
     1: {
     1:   FORWARD_TO_INNER(FireDelayedDOMEvents, (), NS_ERROR_UNEXPECTED);
     1: 
108991:   for (int32_t i = 0; i < mPendingStorageEvents.Count(); ++i) {
106838:     Observe(mPendingStorageEvents[i], "dom-storage2-changed", nullptr);
 37608:   }
 37608: 
 10340:   if (mApplicationCache) {
 10340:     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->FirePendingEvents();
 10340:   }
 10340: 
     1:   if (mFireOfflineStatusChangeEventOnThaw) {
 80486:     mFireOfflineStatusChangeEventOnThaw = false;
     1:     FireOfflineStatusEvent();
     1:   }
     1: 
103224:   if (mNotifyIdleObserversIdleOnThaw) {
103224:     mNotifyIdleObserversIdleOnThaw = false;
104635:     HandleIdleActiveEvent();
103224:   }
103224: 
103224:   if (mNotifyIdleObserversActiveOnThaw) {
103224:     mNotifyIdleObserversActiveOnThaw = false;
103224:     ScheduleActiveTimerCallback();
103224:   }
103224: 
     1:   nsCOMPtr<nsIDocShellTreeNode> node =
     1:     do_QueryInterface(GetDocShell());
     1:   if (node) {
108991:     int32_t childCount = 0;
     1:     node->GetChildCount(&childCount);
     1: 
108991:     for (int32_t i = 0; i < childCount; ++i) {
     1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
     1:       node->GetChildAt(i, getter_AddRefs(childShell));
     1:       NS_ASSERTION(childShell, "null child shell");
     1: 
     1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
     1:       if (pWin) {
     1:         nsGlobalWindow *win =
  3233:           static_cast<nsGlobalWindow*>
  3233:                      (static_cast<nsPIDOMWindow*>(pWin));
     1:         win->FireDelayedDOMEvents();
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow: Window Control Functions
     1: //*****************************************************************************
     1: 
 73870: nsIDOMWindow *
     1: nsGlobalWindow::GetParentInternal()
     1: {
106838:   FORWARD_TO_OUTER(GetParentInternal, (), nullptr);
     1: 
     1:   nsCOMPtr<nsIDOMWindow> parent;
     1:   GetParent(getter_AddRefs(parent));
     1: 
  3233:   if (parent && parent != static_cast<nsIDOMWindow *>(this)) {
 73870:     return parent;
 73870:   }
 73870: 
 73870:   return NULL;
     1: }
     1: 
     1: // static
     1: void
     1: nsGlobalWindow::CloseBlockScriptTerminationFunc(nsISupports *aRef)
     1: {
  3233:   nsGlobalWindow* pwin = static_cast<nsGlobalWindow*>
  3233:                                     (static_cast<nsPIDOMWindow*>(aRef));
 80486:   pwin->mBlockScriptedClosingFlag = false;
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::OpenInternal(const nsAString& aUrl, const nsAString& aName,
 79445:                              const nsAString& aOptions, bool aDialog,
 79445:                              bool aContentModal, bool aCalledNoScript,
108307:                              bool aDoJSFixups, bool aNavigate,
108307:                              nsIArray *argv,
     1:                              nsISupports *aExtraArgument,
     1:                              nsIPrincipal *aCalleePrincipal,
     1:                              JSContext *aJSCallerContext,
     1:                              nsIDOMWindow **aReturn)
     1: {
     1:   FORWARD_TO_OUTER(OpenInternal, (aUrl, aName, aOptions, aDialog,
  5814:                                   aContentModal, aCalledNoScript, aDoJSFixups,
108307:                                   aNavigate, argv, aExtraArgument,
108307:                                   aCalleePrincipal, aJSCallerContext, aReturn),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
102909: #ifdef DEBUG
108991:   uint32_t argc = 0;
     1:   if (argv)
     1:       argv->GetLength(&argc);
     1: #endif
     1:   NS_PRECONDITION(!aExtraArgument || (!argv && argc == 0),
     1:                   "Can't pass in arguments both ways");
     1:   NS_PRECONDITION(!aCalledNoScript || (!argv && argc == 0),
     1:                   "Can't pass JS args when called via the noscript methods");
     1:   NS_PRECONDITION(!aJSCallerContext || !aCalledNoScript,
     1:                   "Shouldn't have caller context when called noscript");
     1: 
108307:   // Calls to window.open from script should navigate.
108307:   MOZ_ASSERT(aCalledNoScript || aNavigate);
108307: 
106838:   *aReturn = nullptr;
     1: 
     1:   nsCOMPtr<nsIWebBrowserChrome> chrome;
     1:   GetWebBrowserChrome(getter_AddRefs(chrome));
     1:   if (!chrome) {
     1:     // No chrome means we don't want to go through with this open call
     1:     // -- see nsIWindowWatcher.idl
     1:     return NS_ERROR_NOT_AVAILABLE;
     1:   }
     1: 
     1:   NS_ASSERTION(mDocShell, "Must have docshell here");
     1: 
108220:   // Popups from apps are never blocked.
108220:   bool isApp = false;
108220:   if (mDoc) {
108220:     isApp = mDoc->NodePrincipal()->GetAppStatus() >=
108220:               nsIPrincipal::APP_STATUS_INSTALLED;
108220:   }
108220: 
 79445:   const bool checkForPopup = !nsContentUtils::IsCallerChrome() &&
108220:     !isApp && !aDialog && !WindowExists(aName, !aCalledNoScript);
     1: 
     1:   // Note: it's very important that this be an nsXPIDLCString, since we want
106838:   // .get() on it to return nullptr until we write stuff to it.  The window
     1:   // watcher expects a null URL string if there is no URL to load.
     1:   nsXPIDLCString url;
     1:   nsresult rv = NS_OK;
     1: 
     1:   // It's important to do this security check before determining whether this
     1:   // window opening should be blocked, to ensure that we don't FireAbuseEvents
     1:   // for a window opening that wouldn't have succeeded in the first place.
     1:   if (!aUrl.IsEmpty()) {
     1:     AppendUTF16toUTF8(aUrl, url);
     1: 
108307:     // It's safe to skip the security check below if we're not a dialog
108307:     // because window.openDialog is not callable from content script.  See bug
108307:     // 56851.
108307:     //
108307:     // If we're not navigating, we assume that whoever *does* navigate the
108307:     // window will do a security check of their own.
108307:     if (url.get() && !aDialog && aNavigate)
     1:       rv = SecurityCheckURL(url.get());
     1:   }
     1: 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 34524:   PopupControlState abuseLevel = gPopupControlState;
     1:   if (checkForPopup) {
 34524:     abuseLevel = RevisePopupAbuseLevel(abuseLevel);
 34524:     if (abuseLevel >= openAbused) {
     1:       if (aJSCallerContext) {
     1:         // If script in some other window is doing a window.open on us and
     1:         // it's being blocked, then it's OK to close us afterwards, probably.
     1:         // But if we're doing a window.open on ourselves and block the popup,
     1:         // prevent this window from closing until after this script terminates
     1:         // so that whatever popup blocker UI the app has will be visible.
     1:         if (mContext == GetScriptContextFromJSContext(aJSCallerContext)) {
 80486:           mBlockScriptedClosingFlag = true;
     1:           mContext->SetTerminationFunction(CloseBlockScriptTerminationFunc,
 91969:                                            this);
     1:         }
     1:       }
     1: 
 80486:       FireAbuseEvents(true, false, aUrl, aName, aOptions);
     1:       return aDoJSFixups ? NS_OK : NS_ERROR_FAILURE;
     1:     }
     1:   }    
     1: 
     1:   nsCOMPtr<nsIDOMWindow> domReturn;
     1: 
     1:   nsCOMPtr<nsIWindowWatcher> wwatch =
     1:     do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
     1:   NS_ENSURE_TRUE(wwatch, rv);
     1: 
     1:   NS_ConvertUTF16toUTF8 options(aOptions);
     1:   NS_ConvertUTF16toUTF8 name(aName);
     1: 
106838:   const char *options_ptr = aOptions.IsEmpty() ? nullptr : options.get();
106838:   const char *name_ptr = aName.IsEmpty() ? nullptr : name.get();
     1: 
108307:   nsCOMPtr<nsPIWindowWatcher> pwwatch(do_QueryInterface(wwatch));
108307:   NS_ENSURE_STATE(pwwatch);
108307: 
     1:   {
     1:     // Reset popup state while opening a window to prevent the
     1:     // current state from being active the whole time a modal
     1:     // dialog is open.
 80486:     nsAutoPopupStatePusher popupStatePusher(openAbused, true);
     1: 
     1:     if (!aCalledNoScript) {
108307:       // We asserted at the top of this function that aNavigate is true for
108307:       // !aCalledNoScript.
108307:       rv = pwwatch->OpenWindow2(this, url.get(), name_ptr, options_ptr,
108307:                                 /* aCalledFromScript = */ true,
108307:                                 aDialog, aNavigate, argv,
     1:                                 getter_AddRefs(domReturn));
     1:     } else {
     1:       // Push a null JSContext here so that the window watcher won't screw us
     1:       // up.  We do NOT want this case looking at the JS context on the stack
     1:       // when searching.  Compare comments on
 73870:       // nsIDOMWindow::OpenWindow and nsIWindowWatcher::OpenWindow.
  5814:       nsCOMPtr<nsIJSContextStack> stack;
  5814: 
  5814:       if (!aContentModal) {
  5814:         stack = do_GetService(sJSStackContractID);
  5814:       }
     1: 
     1:       if (stack) {
106838:         rv = stack->Push(nullptr);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:       }
     1: 
108307:       rv = pwwatch->OpenWindow2(this, url.get(), name_ptr, options_ptr,
108307:                                 /* aCalledFromScript = */ false,
108307:                                 aDialog, aNavigate, aExtraArgument,
108307:                                 getter_AddRefs(domReturn));
     1: 
     1:       if (stack) {
     1:         JSContext* cx;
     1:         stack->Pop(&cx);
     1:         NS_ASSERTION(!cx, "Unexpected JSContext popped!");
     1:       }
     1:     }
     1:   }
     1: 
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // success!
     1: 
 95335:   NS_ENSURE_TRUE(domReturn, NS_OK);
     1:   domReturn.swap(*aReturn);
     1: 
     1:   if (aDoJSFixups) {      
     1:     nsCOMPtr<nsIDOMChromeWindow> chrome_win(do_QueryInterface(*aReturn));
     1:     if (!chrome_win) {
     1:       // A new non-chrome window was created from a call to
     1:       // window.open() from JavaScript, make sure there's a document in
     1:       // the new window. We do this by simply asking the new window for
     1:       // its document, this will synchronously create an empty document
     1:       // if there is no document in the window.
     1:       // XXXbz should this just use EnsureInnerWindow()?
     1: #ifdef DEBUG_jst
     1:       {
     1:         nsCOMPtr<nsPIDOMWindow> pidomwin(do_QueryInterface(*aReturn));
     1: 
     1:         nsIDOMDocument *temp = pidomwin->GetExtantDocument();
     1: 
     1:         NS_ASSERTION(temp, "No document in new window!!!");
     1:       }
     1: #endif
     1: 
     1:       nsCOMPtr<nsIDOMDocument> doc;
     1:       (*aReturn)->GetDocument(getter_AddRefs(doc));
     1:     }
     1:   }
     1:     
     1:   if (checkForPopup) {
     1:     if (abuseLevel >= openControlled) {
  3233:       nsGlobalWindow *opened = static_cast<nsGlobalWindow *>(*aReturn);
     1:       if (!opened->IsPopupSpamWindow()) {
 80486:         opened->SetPopupSpamWindow(true);
     1:         ++gOpenPopupSpamCount;
     1:       }
     1:     }
     1:     if (abuseLevel >= openAbused)
 80486:       FireAbuseEvents(false, true, aUrl, aName, aOptions);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: // static
     1: void
     1: nsGlobalWindow::CloseWindow(nsISupports *aWindow)
     1: {
     1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aWindow));
     1: 
     1:   nsGlobalWindow* globalWin =
  3233:     static_cast<nsGlobalWindow *>
  3233:                (static_cast<nsPIDOMWindow*>(win));
     1: 
     1:   // Need to post an event for closing, otherwise window and 
     1:   // presshell etc. may get destroyed while creating frames, bug 338897.
 39378:   nsCloseEvent::PostCloseEvent(globalWin);
 38439:   // else if OOM, better not to close. That might cause a crash.
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow: Timeout Functions
     1: //*****************************************************************************
     1: 
108991: uint32_t sNestingLevel;
 34729: 
     1: nsresult
     1: nsGlobalWindow::SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
108991:                                      int32_t interval,
108991:                                      bool aIsInterval, int32_t *aReturn)
     1: {
     1:   FORWARD_TO_INNER(SetTimeoutOrInterval, (aHandler, interval, aIsInterval, aReturn),
     1:                    NS_ERROR_NOT_INITIALIZED);
     1: 
  3181:   // If we don't have a document (we could have been unloaded since
  3181:   // the call to setTimeout was made), do nothing.
  3181:   if (!mDocument) {
  3181:     return NS_OK;
  3181:   }
  3181: 
 64670:   // Disallow negative intervals.  If aIsInterval also disallow 0,
 64670:   // because we use that as a "don't repeat" flag.
 64670:   interval = NS_MAX(aIsInterval ? 1 : 0, interval);
 64670: 
 64670:   // Make sure we don't proceed with an interval larger than our timer
 68864:   // code can handle. (Note: we already forced |interval| to be non-negative,
108991:   // so the uint32_t cast (to avoid compiler warnings) is ok.)
108991:   uint32_t maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
108991:   if (static_cast<uint32_t>(interval) > maxTimeoutMs) {
 68864:     interval = maxTimeoutMs;
 64670:   }
 64670: 
 71999:   nsRefPtr<nsTimeout> timeout = new nsTimeout();
 72734:   timeout->mIsInterval = aIsInterval;
 64670:   timeout->mInterval = interval;
 64670:   timeout->mScriptHandler = aHandler;
 64670: 
 64670:   // Now clamp the actual interval we will use for the timer based on
108991:   uint32_t nestingLevel = sNestingLevel + 1;
108991:   int32_t realInterval = interval;
 35709:   if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
 60635:     // Don't allow timeouts less than DOMMinTimeoutValue() from
     1:     // now...
 64670:     realInterval = NS_MAX(realInterval, DOMMinTimeoutValue());
 64670:   }
     1: 
     1:   // Get principal of currently executing code, save for execution of timeout.
  3286:   // If our principals subsume the subject principal then use the subject
  3286:   // principal. Otherwise, use our principal to avoid running script in
  3286:   // elevated principals.
     1: 
     1:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
     1:   nsresult rv;
     1:   rv = nsContentUtils::GetSecurityManager()->
     1:     GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
     1:   if (NS_FAILED(rv)) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 79445:   bool subsumes = false;
     1:   nsCOMPtr<nsIPrincipal> ourPrincipal = GetPrincipal();
     1: 
  3286:   // Note the direction of this test: We don't allow setTimeouts running with
  3286:   // chrome privileges on content windows, but we do allow setTimeouts running
  3286:   // with content privileges on chrome windows (where they can't do very much,
  3286:   // of course).
     1:   rv = ourPrincipal->Subsumes(subjectPrincipal, &subsumes);
     1:   if (NS_FAILED(rv)) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (subsumes) {
     1:     timeout->mPrincipal = subjectPrincipal;
     1:   } else {
  3286:     timeout->mPrincipal = ourPrincipal;
     1:   }
     1: 
 88604:   ++gTimeoutsRecentlySet;
 48032:   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
     1: 
 25074:   if (!IsFrozen() && !mTimeoutsSuspendDepth) {
     1:     // If we're not currently frozen, then we set timeout->mWhen to be the
     1:     // actual firing time of the timer (i.e., now + delta). We also actually
     1:     // create a timer and fire it off.
     1: 
 48032:     timeout->mWhen = TimeStamp::Now() + delta;
     1: 
     1:     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
     1: 
 78894:     nsRefPtr<nsTimeout> copy = timeout;
 78894: 
106314:     rv = timeout->InitTimer(TimerCallback, realInterval);
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
     1: 
     1:     // The timeout is now also held in the timer's closure.
 78894:     copy.forget();
     1:   } else {
 48032:     // If we are frozen, however, then we instead simply set
 48032:     // timeout->mTimeRemaining to be the "time remaining" in the timeout (i.e.,
 48032:     // the interval itself). We don't create a timer for it, since that will
 48032:     // happen when we are thawed and the timeout will then get a timer and run
 48032:     // to completion.
 48032: 
 48032:     timeout->mTimeRemaining = delta;
     1:   }
     1: 
     1:   timeout->mWindow = this;
     1: 
 34729:   if (!aIsInterval) {
 34729:     timeout->mNestingLevel = nestingLevel;
 34729:   }
 34729: 
     1:   // No popups from timeouts by default
     1:   timeout->mPopupState = openAbused;
     1: 
     1:   if (gRunningTimeoutDepth == 0 && gPopupControlState < openAbused) {
     1:     // This timeout is *not* set from another timeout and it's set
     1:     // while popups are enabled. Propagate the state to the timeout if
     1:     // its delay (interval) is equal to or less than what
     1:     // "dom.disable_open_click_delay" is set to (in ms).
     1: 
108991:     int32_t delay =
 70842:       Preferences::GetInt("dom.disable_open_click_delay");
     1: 
 64670:     // This is checking |interval|, not realInterval, on purpose,
 64670:     // because our lower bound for |realInterval| could be pretty high
 64670:     // in some cases.
     1:     if (interval <= delay) {
     1:       timeout->mPopupState = gPopupControlState;
     1:     }
     1:   }
     1: 
     1:   InsertTimeoutIntoList(timeout);
     1: 
     1:   timeout->mPublicId = ++mTimeoutPublicIdCounter;
     1:   *aReturn = timeout->mPublicId;
     1: 
     1:   return NS_OK;
     1: 
     1: }
     1: 
     1: nsresult
108991: nsGlobalWindow::SetTimeoutOrInterval(bool aIsInterval, int32_t *aReturn)
     1: {
  4427:   // This needs to forward to the inner window, but since the current
  4427:   // inner may not be the inner in the calling scope, we need to treat
  4427:   // this specially here as we don't want timeouts registered in a
  4427:   // dying inner window to get registered and run on the current inner
  4427:   // window. To get this right, we need to forward this call to the
  4427:   // inner window that's calling window.setTimeout().
  4427: 
  4427:   if (IsOuterWindow()) {
 10976:     nsGlobalWindow* callerInner = CallerInnerWindow();
  4427:     NS_ENSURE_TRUE(callerInner, NS_ERROR_NOT_AVAILABLE);
  4427: 
  4427:     // If the caller and the callee share the same outer window,
  4427:     // forward to the callee inner. Else, we forward to the current
  4427:     // inner (e.g. someone is calling setTimeout() on a reference to
  4427:     // some other window).
  4427: 
  4433:     if (callerInner->GetOuterWindow() == this &&
  4433:         callerInner->IsInnerWindow()) {
  4427:       return callerInner->SetTimeoutOrInterval(aIsInterval, aReturn);
  4427:     }
  4427: 
     1:     FORWARD_TO_INNER(SetTimeoutOrInterval, (aIsInterval, aReturn),
     1:                      NS_ERROR_NOT_INITIALIZED);
  4427:   }
     1: 
108991:   int32_t interval = 0;
 79445:   bool isInterval = aIsInterval;
     1:   nsCOMPtr<nsIScriptTimeoutHandler> handler;
 10986:   nsresult rv = NS_CreateJSTimeoutHandler(this,
  3106:                                           &isInterval,
     1:                                           &interval,
     1:                                           getter_AddRefs(handler));
     1:   if (NS_FAILED(rv))
     1:     return (rv == NS_ERROR_DOM_TYPE_ERR) ? NS_OK : rv;
     1: 
  3106:   return SetTimeoutOrInterval(handler, interval, isInterval, aReturn);
     1: }
     1: 
101176: bool
101176: nsGlobalWindow::RunTimeoutHandler(nsTimeout* aTimeout,
101176:                                   nsIScriptContext* aScx)
101176: {
101176:   // Hold on to the timeout in case mExpr or mFunObj releases its
101176:   // doc.
101176:   nsRefPtr<nsTimeout> timeout = aTimeout;
101176:   nsTimeout* last_running_timeout = mRunningTimeout;
101176:   mRunningTimeout = timeout;
101176:   timeout->mRunning = true;
101176: 
101176:   // Push this timeout's popup control state, which should only be
101176:   // eabled the first time a timeout fires that was created while
101176:   // popups were enabled and with a delay less than
101176:   // "dom.disable_open_click_delay".
101176:   nsAutoPopupStatePusher popupStatePusher(timeout->mPopupState);
101176: 
101176:   // Clear the timeout's popup state, if any, to prevent interval
101176:   // timeouts from repeatedly opening poups.
101176:   timeout->mPopupState = openAbused;
101176: 
101176:   ++gRunningTimeoutDepth;
101176:   ++mTimeoutFiringDepth;
101176: 
101176:   bool trackNestingLevel = !timeout->mIsInterval;
108991:   uint32_t nestingLevel;
101176:   if (trackNestingLevel) {
101176:     nestingLevel = sNestingLevel;
101176:     sNestingLevel = timeout->mNestingLevel;
101176:   }
101176: 
101176:   nsCOMPtr<nsIScriptTimeoutHandler> handler(timeout->mScriptHandler);
101176:   JSObject* scriptObject = handler->GetScriptObject();
101176:   if (!scriptObject) {
101176:     // Evaluate the timeout expression.
101176:     const PRUnichar* script = handler->GetHandlerText();
101176:     NS_ASSERTION(script, "timeout has no script nor handler text!");
101176: 
106838:     const char* filename = nullptr;
108991:     uint32_t lineNo = 0;
101176:     handler->GetLocation(&filename, &lineNo);
101176: 
101176:     NS_TIME_FUNCTION_MARK("(file: %s, line: %d)", filename, lineNo);
101176: 
101176:     bool is_undefined;
101176:     aScx->EvaluateString(nsDependentString(script), FastGetGlobalJSObject(),
101176:                          timeout->mPrincipal, timeout->mPrincipal,
106838:                          filename, lineNo, JSVERSION_DEFAULT, nullptr,
101176:                          &is_undefined);
101176:   } else {
101176:     nsCOMPtr<nsIVariant> dummy;
101176:     nsCOMPtr<nsISupports> me(static_cast<nsIDOMWindow *>(this));
101176:     aScx->CallEventHandler(me, FastGetGlobalJSObject(),
101176:                            scriptObject, handler->GetArgv(),
101176:                            // XXXmarkh - consider allowing CallEventHandler to
106838:                            // accept nullptr?
101176:                            getter_AddRefs(dummy));
101176: 
101176:   }
101176: 
101176:   // We ignore any failures from calling EvaluateString() or
101176:   // CallEventHandler() on the context here since we're in a loop
101176:   // where we're likely to be running timeouts whose OS timers
101176:   // didn't fire in time and we don't want to not fire those timers
101176:   // now just because execution of one timer failed. We can't
101176:   // propagate the error to anyone who cares about it from this
101176:   // point anyway, and the script context should have already reported
101176:   // the script error in the usual way - so we just drop it.
101176: 
101176:   if (trackNestingLevel) {
101176:     sNestingLevel = nestingLevel;
101176:   }
101176: 
101176:   --mTimeoutFiringDepth;
101176:   --gRunningTimeoutDepth;
101176: 
101176:   mRunningTimeout = last_running_timeout;
101176:   timeout->mRunning = false;
101176:   return timeout->mCleared;
101176: }
101176: 
101176: bool
101176: nsGlobalWindow::RescheduleTimeout(nsTimeout* aTimeout, const TimeStamp& now,
101176:                                   bool aRunningPendingTimeouts)
101176: {
101176:   if (!aTimeout->mIsInterval) {
101176:     if (aTimeout->mTimer) {
101176:       // The timeout still has an OS timer, and it's not an interval,
101176:       // that means that the OS timer could still fire; cancel the OS
101176:       // timer and release its reference to the timeout.
101176:       aTimeout->mTimer->Cancel();
106838:       aTimeout->mTimer = nullptr;
101176:       aTimeout->Release();
101176:     }
101176:     return false;
101176:   }
101176: 
101176:   // Compute time to next timeout for interval timer.
101176:   // Make sure nextInterval is at least DOMMinTimeoutValue().
101176:   TimeDuration nextInterval =
101176:     TimeDuration::FromMilliseconds(NS_MAX(aTimeout->mInterval,
108991:                                           uint32_t(DOMMinTimeoutValue())));
101176: 
101176:   // If we're running pending timeouts, set the next interval to be
101176:   // relative to "now", and not to when the timeout that was pending
101176:   // should have fired.
101176:   TimeStamp firingTime;
101176:   if (aRunningPendingTimeouts) {
101176:     firingTime = now + nextInterval;
101176:   } else {
101176:     firingTime = aTimeout->mWhen + nextInterval;
101176:   }
101176: 
101176:   TimeStamp currentNow = TimeStamp::Now();
101176:   TimeDuration delay = firingTime - currentNow;
101176: 
101176:   // And make sure delay is nonnegative; that might happen if the timer
101176:   // thread is firing our timers somewhat early or if they're taking a long
101176:   // time to run the callback.
101176:   if (delay < TimeDuration(0)) {
101176:     delay = TimeDuration(0);
101176:   }
101176: 
101176:   if (!aTimeout->mTimer) {
101176:     NS_ASSERTION(IsFrozen() || mTimeoutsSuspendDepth,
101176:                  "How'd our timer end up null if we're not frozen or "
101176:                  "suspended?");
101176: 
101176:     aTimeout->mTimeRemaining = delay;
101176:     return true;
101176:   }
101176: 
101176:   aTimeout->mWhen = currentNow + delay;
101176: 
101176:   // Reschedule the OS timer. Don't bother returning any error codes if
101176:   // this fails since the callers of this method don't care about them.
101176: 
101176:   // Make sure to cast the unsigned PR_USEC_PER_MSEC to signed
101176:   // PRTime to make the division do the right thing on 64-bit
101176:   // platforms whether delay is positive or negative (which we
101176:   // know is always positive here, but cast anyways for
101176:   // consistency).
106314:   nsresult rv = aTimeout->InitTimer(TimerCallback, delay.ToMilliseconds());
101176: 
101176:   if (NS_FAILED(rv)) {
101176:     NS_ERROR("Error initializing timer for DOM timeout!");
101176: 
101176:     // We failed to initialize the new OS timer, this timer does
101176:     // us no good here so we just cancel it (just in case) and
101176:     // null out the pointer to the OS timer, this will release the
101176:     // OS timer. As we continue executing the code below we'll end
101176:     // up deleting the timeout since it's not an interval timeout
106838:     // any more (since timeout->mTimer == nullptr).
101176:     aTimeout->mTimer->Cancel();
106838:     aTimeout->mTimer = nullptr;
101176: 
101176:     // Now that the OS timer no longer has a reference to the
101176:     // timeout we need to drop that reference.
101176:     aTimeout->Release();
101176: 
101176:     return false;
101176:   }
101176: 
101176:   return true;
101176: }
101176: 
     1: void
     1: nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
     1: {
     1:   // If a modal dialog is open for this window, return early. Pending
     1:   // timeouts will run when the modal dialog is dismissed.
 25074:   if (IsInModalState() || mTimeoutsSuspendDepth) {
     1:     return;
     1:   }
     1: 
 42480:   NS_TIME_FUNCTION;
 42480: 
     1:   NS_ASSERTION(IsInnerWindow(), "Timeout running on outer window!");
     1:   NS_ASSERTION(!IsFrozen(), "Timeout running on a window in the bfcache!");
     1: 
     1:   nsTimeout *nextTimeout, *timeout;
     1:   nsTimeout *last_expired_timeout, *last_insertion_point;
     1:   nsTimeout dummy_timeout;
108991:   uint32_t firingDepth = mTimeoutFiringDepth + 1;
     1: 
     1:   // Make sure that the window and the script context don't go away as
     1:   // a result of running timeouts
     1:   nsCOMPtr<nsIScriptGlobalObject> windowKungFuDeathGrip(this);
     1: 
     1:   // A native timer has gone off. See which of our timeouts need
     1:   // servicing
 48032:   TimeStamp now = TimeStamp::Now();
 48032:   TimeStamp deadline;
     1: 
     1:   if (aTimeout && aTimeout->mWhen > now) {
 51588:     // The OS timer fired early (yikes!), and possibly out of order
 51588:     // too. Set |deadline| to be the time when the OS timer *should*
 51588:     // have fired so that any timers that *should* have fired before
 51588:     // aTimeout *will* be fired now. This happens most of the time on
 51588:     // Win2k.
 51588: 
     1:     deadline = aTimeout->mWhen;
     1:   } else {
     1:     deadline = now;
     1:   }
     1: 
     1:   // The timeout list is kept in deadline order. Discover the latest
     1:   // timeout whose deadline has expired. On some platforms, native
     1:   // timeout events fire "early", so we need to test the timer as well
     1:   // as the deadline.
106838:   last_expired_timeout = nullptr;
     1:   for (timeout = FirstTimeout(); IsTimeout(timeout); timeout = timeout->Next()) {
     1:     if (((timeout == aTimeout) || (timeout->mWhen <= deadline)) &&
     1:         (timeout->mFiringDepth == 0)) {
     1:       // Mark any timeouts that are on the list to be fired with the
     1:       // firing depth so that we can reentrantly run timeouts
     1:       timeout->mFiringDepth = firingDepth;
     1:       last_expired_timeout = timeout;
     1:     }
     1:   }
     1: 
     1:   // Maybe the timeout that the event was fired for has been deleted
     1:   // and there are no others timeouts with deadlines that make them
     1:   // eligible for execution yet. Go away.
     1:   if (!last_expired_timeout) {
     1:     return;
     1:   }
     1: 
 88604:   // Record telemetry information about timers set recently.
 88604:   TimeDuration recordingInterval = TimeDuration::FromMilliseconds(STATISTICS_INTERVAL);
 88604:   if (gLastRecordedRecentTimeouts.IsNull() ||
 88604:       now - gLastRecordedRecentTimeouts > recordingInterval) {
108991:     uint32_t count = gTimeoutsRecentlySet;
 88604:     gTimeoutsRecentlySet = 0;
 88604:     Telemetry::Accumulate(Telemetry::DOM_TIMERS_RECENTLY_SET, count);
 88604:     gLastRecordedRecentTimeouts = now;
 88604:   }
 88604: 
     1:   // Insert a dummy timeout into the list of timeouts between the
     1:   // portion of the list that we are about to process now and those
     1:   // timeouts that will be processed in a future call to
     1:   // win_run_timeout(). This dummy timeout serves as the head of the
     1:   // list for any timeouts inserted as a result of running a timeout.
     1:   dummy_timeout.mFiringDepth = firingDepth;
 48032:   dummy_timeout.mWhen = now;
     1:   PR_INSERT_AFTER(&dummy_timeout, last_expired_timeout);
     1: 
     1:   // Don't let ClearWindowTimeouts throw away our stack-allocated
     1:   // dummy timeout.
     1:   dummy_timeout.AddRef();
     1:   dummy_timeout.AddRef();
     1: 
     1:   last_insertion_point = mTimeoutInsertionPoint;
 73617:   // If we ever start setting mTimeoutInsertionPoint to a non-dummy timeout,
 73617:   // the logic in ResetTimersForNonBackgroundWindow will need to change.
     1:   mTimeoutInsertionPoint = &dummy_timeout;
     1: 
 87192:   Telemetry::AutoCounter<Telemetry::DOM_TIMERS_FIRED_PER_NATIVE_TIMEOUT> timeoutsRan;
 87192: 
     1:   for (timeout = FirstTimeout();
 27828:        timeout != &dummy_timeout && !IsFrozen();
     1:        timeout = nextTimeout) {
     1:     nextTimeout = timeout->Next();
     1: 
     1:     if (timeout->mFiringDepth != firingDepth) {
     1:       // We skip the timeout since it's on the list to run at another
     1:       // depth.
     1: 
     1:       continue;
     1:     }
     1: 
 27828:     if (mTimeoutsSuspendDepth) {
 27828:       // Some timer did suspend us. Make sure the
 27828:       // rest of the timers get executed later.
 27828:       timeout->mFiringDepth = 0;
 27828:       continue;
 27828:     }
 27828: 
     1:     // The timeout is on the list to run at this depth, go ahead and
     1:     // process it.
     1: 
     1:     // Get the script context (a strong ref to prevent it going away)
     1:     // for this timeout and ensure the script language is enabled.
 94563:     nsCOMPtr<nsIScriptContext> scx = GetContextInternal();
     1: 
     1:     if (!scx) {
     1:       // No context means this window was closed or never properly
     1:       // initialized for this language.
     1:       continue;
     1:     }
     1: 
     1:     // The "scripts disabled" concept is still a little vague wrt
     1:     // multiple languages.  Prepare for the day when languages can be
     1:     // disabled independently of the other languages...
     1:     if (!scx->GetScriptsEnabled()) {
     1:       // Scripts were enabled once in this window (unless aTimeout ==
106838:       // nullptr) but now scripts are disabled (we might be in
     1:       // print-preview, for instance), this means we shouldn't run any
     1:       // timeouts at this point.
     1:       //
     1:       // If scripts are enabled for this language in this window again
     1:       // we'll fire the timeouts that are due at that point.
     1:       continue;
     1:     }
     1: 
     1:     // This timeout is good to run
 87192:     ++timeoutsRan;
101176:     bool timeout_was_cleared = RunTimeoutHandler(timeout, scx);
     1: 
     1:     if (timeout_was_cleared) {
     1:       // The running timeout's window was cleared, this means that
     1:       // ClearAllTimeouts() was called from a *nested* call, possibly
     1:       // through a timeout that fired while a modal (to this window)
     1:       // dialog was open or through other non-obvious paths.
     1: 
     1:       mTimeoutInsertionPoint = last_insertion_point;
     1: 
     1:       return;
     1:     }
     1: 
     1:     // If we have a regular interval timer, we re-schedule the
     1:     // timeout, accounting for clock drift.
101176:     bool needsReinsertion = RescheduleTimeout(timeout, now, !aTimeout);
     1: 
     1:     // Running a timeout can cause another timeout to be deleted, so
     1:     // we need to reset the pointer to the following timeout.
     1:     nextTimeout = timeout->Next();
     1: 
     1:     PR_REMOVE_LINK(timeout);
     1: 
101176:     if (needsReinsertion) {
101176:       // Insert interval timeout onto list sorted in deadline order.
 25838:       // AddRefs timeout.
     1:       InsertTimeoutIntoList(timeout);
     1:     }
 25838: 
 25838:     // Release the timeout struct since it's possibly out of the list
 25838:     timeout->Release();
     1:   }
     1: 
     1:   // Take the dummy timeout off the head of the list
     1:   PR_REMOVE_LINK(&dummy_timeout);
     1: 
     1:   mTimeoutInsertionPoint = last_insertion_point;
     1: }
     1: 
     1: nsrefcnt
     1: nsTimeout::Release()
     1: {
     1:   if (--mRefCnt > 0)
     1:     return mRefCnt;
     1: 
     1:   // language specific cleanup done as mScriptHandler destructs...
     1: 
     1:   // Kill the timer if it is still alive.
     1:   if (mTimer) {
     1:     mTimer->Cancel();
106838:     mTimer = nullptr;
     1:   }
     1: 
     1:   delete this;
     1:   return 0;
     1: }
     1: 
     1: nsrefcnt
     1: nsTimeout::AddRef()
     1: {
     1:   return ++mRefCnt;
     1: }
     1: 
     1: 
     1: nsresult
108991: nsGlobalWindow::ClearTimeoutOrInterval(int32_t aTimerID)
     1: {
     1:   FORWARD_TO_INNER(ClearTimeoutOrInterval, (aTimerID), NS_ERROR_NOT_INITIALIZED);
     1: 
108991:   uint32_t public_id = (uint32_t)aTimerID;
     1:   nsTimeout *timeout;
     1: 
     1:   for (timeout = FirstTimeout();
     1:        IsTimeout(timeout);
     1:        timeout = timeout->Next()) {
     1:     if (timeout->mPublicId == public_id) {
     1:       if (timeout->mRunning) {
     1:         /* We're running from inside the timeout. Mark this
     1:            timeout for deferred deletion by the code in
     1:            RunTimeout() */
 80486:         timeout->mIsInterval = false;
     1:       }
     1:       else {
     1:         /* Delete the timeout from the pending timeout list */
     1:         PR_REMOVE_LINK(timeout);
     1: 
     1:         if (timeout->mTimer) {
     1:           timeout->mTimer->Cancel();
106838:           timeout->mTimer = nullptr;
     1:           timeout->Release();
     1:         }
     1:         timeout->Release();
     1:       }
     1:       break;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 72734: nsresult nsGlobalWindow::ResetTimersForNonBackgroundWindow()
 72734: {
 72734:   FORWARD_TO_INNER(ResetTimersForNonBackgroundWindow, (),
 72734:                    NS_ERROR_NOT_INITIALIZED);
 72734: 
 72734:   if (IsFrozen() || mTimeoutsSuspendDepth) {
 72734:     return NS_OK;
 72734:   }
 72734: 
 72734:   TimeStamp now = TimeStamp::Now();
 72734: 
 73617:   // If mTimeoutInsertionPoint is non-null, we're in the middle of firing
 73617:   // timers and the timers we're planning to fire all come before
 73617:   // mTimeoutInsertionPoint; mTimeoutInsertionPoint itself is a dummy timeout
 73617:   // with an mWhen that may be semi-bogus.  In that case, we don't need to do
 73617:   // anything with mTimeoutInsertionPoint or anything before it, so should
 73617:   // start at the timer after mTimeoutInsertionPoint, if there is one.
 73617:   // Otherwise, start at the beginning of the list.
 73617:   for (nsTimeout *timeout = mTimeoutInsertionPoint ?
 73617:          mTimeoutInsertionPoint->Next() : FirstTimeout();
 73617:        IsTimeout(timeout); ) {
 72734:     // It's important that this check be <= so that we guarantee that
 72734:     // taking NS_MAX with |now| won't make a quantity equal to
 72734:     // timeout->mWhen below.
 72734:     if (timeout->mWhen <= now) {
 72734:       timeout = timeout->Next();
 72734:       continue;
 72734:     }
 72734: 
 72734:     if (timeout->mWhen - now >
 72734:         TimeDuration::FromMilliseconds(gMinBackgroundTimeoutValue)) {
 72734:       // No need to loop further.  Timeouts are sorted in mWhen order
 72734:       // and the ones after this point were all set up for at least
 72734:       // gMinBackgroundTimeoutValue ms and hence were not clamped.
 72734:       break;
 72734:     }
 72734: 
 72734:     /* We switched from background. Re-init the timer appropriately */
 72734:     // Compute the interval the timer should have had if it had not been set in a
 72734:     // background window
 72734:     TimeDuration interval =
 72734:       TimeDuration::FromMilliseconds(NS_MAX(timeout->mInterval,
108991:                                             uint32_t(DOMMinTimeoutValue())));
108991:     uint32_t oldIntervalMillisecs = 0;
 72734:     timeout->mTimer->GetDelay(&oldIntervalMillisecs);
 72734:     TimeDuration oldInterval = TimeDuration::FromMilliseconds(oldIntervalMillisecs);
 72734:     if (oldInterval > interval) {
 72734:       // unclamp
 72734:       TimeStamp firingTime =
 72734:         NS_MAX(timeout->mWhen - oldInterval + interval, now);
 72734: 
 72734:       NS_ASSERTION(firingTime < timeout->mWhen,
 72734:                    "Our firing time should strictly decrease!");
 72734: 
 72734:       TimeDuration delay = firingTime - now;
 72734:       timeout->mWhen = firingTime;
 72734: 
 72734:       // Since we reset mWhen we need to move |timeout| to the right
 72734:       // place in the list so that it remains sorted by mWhen.
 72734:       
 72734:       // Get the pointer to the next timeout now, before we move the
 72734:       // current timeout in the list.
 72734:       nsTimeout* nextTimeout = timeout->Next();
 72734: 
 72734:       // It is safe to remove and re-insert because mWhen is now
 72734:       // strictly smaller than it used to be, so we know we'll insert
 72734:       // |timeout| before nextTimeout.
 72734:       NS_ASSERTION(!IsTimeout(nextTimeout) ||
 72734:                    timeout->mWhen < nextTimeout->mWhen, "How did that happen?");
 72734:       PR_REMOVE_LINK(timeout);
 72734:       // InsertTimeoutIntoList will addref |timeout| and reset
 72734:       // mFiringDepth.  Make sure to undo that after calling it.
108991:       uint32_t firingDepth = timeout->mFiringDepth;
 72734:       InsertTimeoutIntoList(timeout);
 72734:       timeout->mFiringDepth = firingDepth;
 72734:       timeout->Release();
 72734: 
106314:       nsresult rv = timeout->InitTimer(TimerCallback, delay.ToMilliseconds());
 72734: 
 72734:       if (NS_FAILED(rv)) {
 72734:         NS_WARNING("Error resetting non background timer for DOM timeout!");
 72734:         return rv;
 72734:       }
 72734: 
 72734:       timeout = nextTimeout;
 72734:     } else {
 72734:       timeout = timeout->Next();
 72734:     }
 72734:   }
 72734: 
 72734:   return NS_OK;
 72734: }
 72734: 
     1: void
     1: nsGlobalWindow::ClearAllTimeouts()
     1: {
     1:   nsTimeout *timeout, *nextTimeout;
     1: 
     1:   for (timeout = FirstTimeout(); IsTimeout(timeout); timeout = nextTimeout) {
     1:     /* If RunTimeout() is higher up on the stack for this
     1:        window, e.g. as a result of document.write from a timeout,
     1:        then we need to reset the list insertion point for
     1:        newly-created timeouts in case the user adds a timeout,
     1:        before we pop the stack back to RunTimeout. */
     1:     if (mRunningTimeout == timeout)
106838:       mTimeoutInsertionPoint = nullptr;
     1: 
     1:     nextTimeout = timeout->Next();
     1: 
     1:     if (timeout->mTimer) {
     1:       timeout->mTimer->Cancel();
106838:       timeout->mTimer = nullptr;
     1: 
     1:       // Drop the count since the timer isn't going to hold on
     1:       // anymore.
     1:       timeout->Release();
     1:     }
     1: 
     1:     // Set timeout->mCleared to true to indicate that the timeout was
     1:     // cleared and taken out of the list of timeouts
 80486:     timeout->mCleared = true;
     1: 
     1:     // Drop the count since we're removing it from the list.
     1:     timeout->Release();
     1:   }
     1: 
     1:   // Clear out our list
     1:   PR_INIT_CLIST(&mTimeouts);
     1: }
     1: 
     1: void
     1: nsGlobalWindow::InsertTimeoutIntoList(nsTimeout *aTimeout)
     1: {
     1:   NS_ASSERTION(IsInnerWindow(),
     1:                "InsertTimeoutIntoList() called on outer window!");
     1: 
     1:   // Start at mLastTimeout and go backwards.  Don't go further than
     1:   // mTimeoutInsertionPoint, though.  This optimizes for the common case of
     1:   // insertion at the end.
     1:   nsTimeout* prevSibling;
     1:   for (prevSibling = LastTimeout();
     1:        IsTimeout(prevSibling) && prevSibling != mTimeoutInsertionPoint &&
 48032:          // This condition needs to match the one in SetTimeoutOrInterval that
 48032:          // determines whether to set mWhen or mTimeRemaining.
 48032:          ((IsFrozen() || mTimeoutsSuspendDepth) ?
 48032:           prevSibling->mTimeRemaining > aTimeout->mTimeRemaining :
 48032:           prevSibling->mWhen > aTimeout->mWhen);
     1:        prevSibling = prevSibling->Prev()) {
     1:     /* Do nothing; just searching */
     1:   }
     1: 
     1:   // Now link in aTimeout after prevSibling.
     1:   PR_INSERT_AFTER(aTimeout, prevSibling);
     1: 
     1:   aTimeout->mFiringDepth = 0;
     1: 
     1:   // Increment the timeout's reference count since it's now held on to
     1:   // by the list
     1:   aTimeout->AddRef();
     1: }
     1: 
     1: // static
     1: void
     1: nsGlobalWindow::TimerCallback(nsITimer *aTimer, void *aClosure)
     1: {
 71999:   nsRefPtr<nsTimeout> timeout = (nsTimeout *)aClosure;
     1: 
     1:   timeout->mWindow->RunTimeout(timeout);
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsGlobalWindow: Helper Functions
     1: //*****************************************************************************
 36884: 
     1: nsresult
     1: nsGlobalWindow::GetTreeOwner(nsIDocShellTreeOwner **aTreeOwner)
     1: {
     1:   FORWARD_TO_OUTER(GetTreeOwner, (aTreeOwner), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
     1: 
     1:   // If there's no docShellAsItem, this window must have been closed,
     1:   // in that case there is no tree owner.
     1: 
     1:   if (!docShellAsItem) {
106838:     *aTreeOwner = nullptr;
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   return docShellAsItem->GetTreeOwner(aTreeOwner);
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::GetTreeOwner(nsIBaseWindow **aTreeOwner)
     1: {
     1:   FORWARD_TO_OUTER(GetTreeOwner, (aTreeOwner), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
     1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
     1: 
     1:   // If there's no docShellAsItem, this window must have been closed,
     1:   // in that case there is no tree owner.
     1: 
     1:   if (docShellAsItem) {
     1:     docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
     1:   }
     1: 
     1:   if (!treeOwner) {
106838:     *aTreeOwner = nullptr;
     1:     return NS_OK;
     1:   }
     1: 
     1:   return CallQueryInterface(treeOwner, aTreeOwner);
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::GetWebBrowserChrome(nsIWebBrowserChrome **aBrowserChrome)
     1: {
     1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
     1:   GetTreeOwner(getter_AddRefs(treeOwner));
     1: 
     1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(treeOwner));
     1:   NS_IF_ADDREF(*aBrowserChrome = browserChrome);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 37063: nsIScrollableFrame *
 37063: nsGlobalWindow::GetScrollFrame()
 37063: {
106838:   FORWARD_TO_OUTER(GetScrollFrame, (), nullptr);
     1: 
     1:   if (!mDocShell) {
106838:     return nullptr;
     1:   }
     1: 
 26050:   nsCOMPtr<nsIPresShell> presShell;
 26050:   mDocShell->GetPresShell(getter_AddRefs(presShell));
 26050:   if (presShell) {
 37063:     return presShell->GetRootScrollFrameAsScrollable();
 37063:   }
106838:   return nullptr;
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::BuildURIfromBase(const char *aURL, nsIURI **aBuiltURI,
 79445:                                  bool *aFreeSecurityPass,
     1:                                  JSContext **aCXused)
     1: {
     1:   nsIScriptContext *scx = GetContextInternal();
106838:   JSContext *cx = nullptr;
106838: 
106838:   *aBuiltURI = nullptr;
 80486:   *aFreeSecurityPass = false;
     1:   if (aCXused)
106838:     *aCXused = nullptr;
     1: 
     1:   // get JSContext
     1:   NS_ASSERTION(scx, "opening window missing its context");
     1:   NS_ASSERTION(mDocument, "opening window missing its document");
     1:   if (!scx || !mDocument)
     1:     return NS_ERROR_FAILURE;
     1: 
 77547:   nsCOMPtr<nsIDOMChromeWindow> chrome_win = do_QueryObject(this);
     1: 
     1:   if (nsContentUtils::IsCallerChrome() && !chrome_win) {
     1:     // If open() is called from chrome on a non-chrome window, we'll
     1:     // use the context from the window on which open() is being called
     1:     // to prevent giving chrome priveleges to new windows opened in
     1:     // such a way. This also makes us get the appropriate base URI for
     1:     // the below URI resolution code.
     1: 
 78415:     cx = scx->GetNativeContext();
     1:   } else {
     1:     // get the JSContext from the call stack
     1:     nsCOMPtr<nsIThreadJSContextStack> stack(do_GetService(sJSStackContractID));
     1:     if (stack)
     1:       stack->Peek(&cx);
     1:   }
     1: 
     1:   /* resolve the URI, which could be relative to the calling window
     1:      (note the algorithm to get the base URI should match the one
     1:      used to actually kick off the load in nsWindowWatcher.cpp). */
110974:   nsAutoCString charset(NS_LITERAL_CSTRING("UTF-8")); // default to utf-8
106838:   nsIURI* baseURI = nullptr;
     1:   nsCOMPtr<nsIURI> uriToLoad;
     1:   nsCOMPtr<nsIDOMWindow> sourceWindow;
     1: 
     1:   if (cx) {
     1:     nsIScriptContext *scriptcx = nsJSUtils::GetDynamicScriptContext(cx);
     1:     if (scriptcx)
     1:       sourceWindow = do_QueryInterface(scriptcx->GetGlobalObject());
     1:   }
     1: 
     1:   if (!sourceWindow) {
     1:     sourceWindow = do_QueryInterface(NS_ISUPPORTS_CAST(nsIDOMWindow *, this));
 80486:     *aFreeSecurityPass = true;
     1:   }
     1: 
     1:   if (sourceWindow) {
     1:     nsCOMPtr<nsIDOMDocument> domDoc;
     1:     sourceWindow->GetDocument(getter_AddRefs(domDoc));
     1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
     1:     if (doc) {
 41900:       baseURI = doc->GetDocBaseURI();
     1:       charset = doc->GetDocumentCharacterSet();
     1:     }
     1:   }
     1: 
     1:   if (aCXused)
     1:     *aCXused = cx;
     1:   return NS_NewURI(aBuiltURI, nsDependentCString(aURL), charset.get(), baseURI);
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::SecurityCheckURL(const char *aURL)
     1: {
     1:   JSContext       *cx;
 79445:   bool             freePass;
     1:   nsCOMPtr<nsIURI> uri;
     1: 
     1:   if (NS_FAILED(BuildURIfromBase(aURL, getter_AddRefs(uri), &freePass, &cx)))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (!freePass && NS_FAILED(nsContentUtils::GetSecurityManager()->
     1:         CheckLoadURIFromScript(cx, uri)))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsGlobalWindow::FlushPendingNotifications(mozFlushType aType)
     1: {
     1:   if (mDoc) {
     1:     mDoc->FlushPendingNotifications(aType);
     1:   }
     1: }
     1: 
     1: void
     1: nsGlobalWindow::EnsureSizeUpToDate()
     1: {
     1:   // If we're a subframe, make sure our size is up to date.  It's OK that this
     1:   // crosses the content/chrome boundary, since chrome can have pending reflows
     1:   // too.
     1:   nsGlobalWindow *parent =
  3233:     static_cast<nsGlobalWindow *>(GetPrivateParent());
     1:   if (parent) {
     1:     parent->FlushPendingNotifications(Flush_Layout);
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::SaveWindowState(nsISupports **aState)
     1: {
     1:   NS_PRECONDITION(IsOuterWindow(), "Can't save the inner window's state");
     1: 
106838:   *aState = nullptr;
     1: 
     1:   if (!mContext || !mJSObject) {
     1:     // The window may be getting torn down; don't bother saving state.
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
     1:   NS_ASSERTION(inner, "No inner window to save");
     1: 
     1:   // Don't do anything else to this inner window! After this point, all
     1:   // calls to SetTimeoutOrInterval will create entries in the timeout
     1:   // list that will only run after this window has come out of the bfcache.
     1:   // Also, while we're frozen, we won't dispatch online/offline events
     1:   // to the page.
     1:   inner->Freeze();
     1: 
     1:   nsCOMPtr<nsISupports> state = new WindowStateHolder(inner,
108657:                                                       mInnerWindowHolder);
     1:   NS_ENSURE_TRUE(state, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1: #ifdef DEBUG_PAGE_CACHE
     1:   printf("saving window state, state = %p\n", (void*)state);
     1: #endif
     1: 
     1:   state.swap(*aState);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGlobalWindow::RestoreWindowState(nsISupports *aState)
     1: {
     1:   NS_ASSERTION(IsOuterWindow(), "Cannot restore an inner window");
     1: 
     1:   if (!mContext || !mJSObject) {
     1:     // The window may be getting torn down; don't bother restoring state.
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<WindowStateHolder> holder = do_QueryInterface(aState);
     1:   NS_ENSURE_TRUE(holder, NS_ERROR_FAILURE);
     1: 
     1: #ifdef DEBUG_PAGE_CACHE
     1:   printf("restoring window state, state = %p\n", (void*)holder);
     1: #endif
     1: 
 30602:   // And we're ready to go!
     1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
 41071: 
 41071:   // if a link is focused, refocus with the FLAG_SHOWRING flag set. This makes
 41071:   // it easy to tell which link was last clicked when going back a page.
 41071:   nsIContent* focusedNode = inner->GetFocusedNode();
 43884:   if (IsLink(focusedNode)) {
 41071:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 41071:     if (fm) {
 41071:       nsCOMPtr<nsIDOMElement> focusedElement(do_QueryInterface(focusedNode));
 41071:       fm->SetFocus(focusedElement, nsIFocusManager::FLAG_NOSCROLL |
 41071:                                    nsIFocusManager::FLAG_SHOWRING);
 41071:     }
 41071:   }
 41071: 
     1:   inner->Thaw();
     1: 
     1:   holder->DidRestoreWindow();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
108991: nsGlobalWindow::SuspendTimeouts(uint32_t aIncrease,
 79445:                                 bool aFreezeChildren)
 25723: {
 25723:   FORWARD_TO_INNER_VOID(SuspendTimeouts, (aIncrease, aFreezeChildren));
 25723: 
 79445:   bool suspended = (mTimeoutsSuspendDepth != 0);
 25723:   mTimeoutsSuspendDepth += aIncrease;
 25723: 
 25723:   if (!suspended) {
 94011:     nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
 94010:     if (ac) {
108991:       for (uint32_t i = 0; i < mEnabledSensors.Length(); i++)
 94010:         ac->RemoveWindowListener(mEnabledSensors[i], this);
 94010:     }
 59871: 
 74337:     // Suspend all of the workers for this window.
 74337:     nsIScriptContext *scx = GetContextInternal();
106838:     JSContext *cx = scx ? scx->GetNativeContext() : nullptr;
 74337:     mozilla::dom::workers::SuspendWorkersForWindow(cx, this);
 16753: 
 48032:     TimeStamp now = TimeStamp::Now();
     1:     for (nsTimeout *t = FirstTimeout(); IsTimeout(t); t = t->Next()) {
 48032:       // Set mTimeRemaining to be the time remaining for this timer.
     1:       if (t->mWhen > now)
 48101:         t->mTimeRemaining = t->mWhen - now;
     1:       else
 48032:         t->mTimeRemaining = TimeDuration(0);
     1:   
     1:       // Drop the XPCOM timer; we'll reschedule when restoring the state.
     1:       if (t->mTimer) {
     1:         t->mTimer->Cancel();
106838:         t->mTimer = nullptr;
     1:   
     1:         // Drop the reference that the timer's closure had on this timeout, we'll
     1:         // add it back in ResumeTimeouts. Note that it shouldn't matter that we're
     1:         // passing null for the context, since this shouldn't actually release this
     1:         // timeout.
     1:         t->Release();
     1:       }
     1:     }
 25723:   }
     1: 
     1:   // Suspend our children as well.
     1:   nsCOMPtr<nsIDocShellTreeNode> node(do_QueryInterface(GetDocShell()));
     1:   if (node) {
108991:     int32_t childCount = 0;
     1:     node->GetChildCount(&childCount);
     1: 
108991:     for (int32_t i = 0; i < childCount; ++i) {
     1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
     1:       node->GetChildAt(i, getter_AddRefs(childShell));
     1:       NS_ASSERTION(childShell, "null child shell");
     1: 
     1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
     1:       if (pWin) {
     1:         nsGlobalWindow *win =
  3233:           static_cast<nsGlobalWindow*>
  3233:                      (static_cast<nsPIDOMWindow*>(pWin));
     1:         NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
     1:         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
 43465: 
 43465:         // This is a bit hackish. Only freeze/suspend windows which are truly our
 43465:         // subwindows.
 43465:         nsCOMPtr<nsIContent> frame = do_QueryInterface(pWin->GetFrameElementInternal());
 80526:         if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
 43465:           continue;
 43465:         }
 43465: 
 43465:         win->SuspendTimeouts(aIncrease, aFreezeChildren);
 43465: 
 25723:         if (inner && aFreezeChildren) {
     1:           inner->Freeze();
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: nsresult
 79445: nsGlobalWindow::ResumeTimeouts(bool aThawChildren)
     1: {
     1:   FORWARD_TO_INNER(ResumeTimeouts, (), NS_ERROR_NOT_INITIALIZED);
     1: 
 25074:   NS_ASSERTION(mTimeoutsSuspendDepth, "Mismatched calls to ResumeTimeouts!");
 25723:   --mTimeoutsSuspendDepth;
 79445:   bool shouldResume = (mTimeoutsSuspendDepth == 0);
 25723:   nsresult rv;
 25723: 
 25723:   if (shouldResume) {
 94011:     nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
 94010:     if (ac) {
108991:       for (uint32_t i = 0; i < mEnabledSensors.Length(); i++)
 94010:         ac->AddWindowListener(mEnabledSensors[i], this);
 94010:     }
 59871: 
 74337:     // Resume all of the workers for this window.
 74337:     nsIScriptContext *scx = GetContextInternal();
106838:     JSContext *cx = scx ? scx->GetNativeContext() : nullptr;
 74337:     mozilla::dom::workers::ResumeWorkersForWindow(cx, this);
 16753: 
     1:     // Restore all of the timeouts, using the stored time remaining
 48032:     // (stored in timeout->mTimeRemaining).
 48032: 
 48032:     TimeStamp now = TimeStamp::Now();
     1: 
 25170: #ifdef DEBUG
 79445:     bool _seenDummyTimeout = false;
 25170: #endif
 25170: 
     1:     for (nsTimeout *t = FirstTimeout(); IsTimeout(t); t = t->Next()) {
 25170:       // There's a chance we're being called with RunTimeout on the stack in which
 25170:       // case we have a dummy timeout in the list that *must not* be resumed. It
 25170:       // can be identified by a null mWindow.
 25170:       if (!t->mWindow) {
 25170: #ifdef DEBUG
 25170:         NS_ASSERTION(!_seenDummyTimeout, "More than one dummy timeout?!");
 80486:         _seenDummyTimeout = true;
 25170: #endif
 25170:         continue;
 25170:       }
 25170: 
 48032:       // XXXbz the combination of the way |delay| and |t->mWhen| are set here
 48032:       // makes no sense.  Are we trying to impose that min timeout value or
 48032:       // not???
108991:       uint32_t delay =
108991:         NS_MAX(int32_t(t->mTimeRemaining.ToMilliseconds()),
 60635:                DOMMinTimeoutValue());
     1: 
     1:       // Set mWhen back to the time when the timer is supposed to
     1:       // fire.
 48032:       t->mWhen = now + t->mTimeRemaining;
     1: 
     1:       t->mTimer = do_CreateInstance("@mozilla.org/timer;1");
     1:       NS_ENSURE_TRUE(t->mTimer, NS_ERROR_OUT_OF_MEMORY);
     1: 
106314:       rv = t->InitTimer(TimerCallback, delay);
     1:       if (NS_FAILED(rv)) {
106838:         t->mTimer = nullptr;
     1:         return rv;
     1:       }
     1: 
     1:       // Add a reference for the new timer's closure.
     1:       t->AddRef();
     1:     }
 25723:   }
     1: 
     1:   // Resume our children as well.
     1:   nsCOMPtr<nsIDocShellTreeNode> node =
     1:     do_QueryInterface(GetDocShell());
     1:   if (node) {
108991:     int32_t childCount = 0;
     1:     node->GetChildCount(&childCount);
     1: 
108991:     for (int32_t i = 0; i < childCount; ++i) {
     1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
     1:       node->GetChildAt(i, getter_AddRefs(childShell));
     1:       NS_ASSERTION(childShell, "null child shell");
     1: 
     1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
     1:       if (pWin) {
     1:         nsGlobalWindow *win =
  3233:           static_cast<nsGlobalWindow*>
  3233:                      (static_cast<nsPIDOMWindow*>(pWin));
     1: 
     1:         NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
     1:         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
 43465: 
 43465:         // This is a bit hackish. Only thaw/resume windows which are truly our
 43465:         // subwindows.
 43465:         nsCOMPtr<nsIContent> frame = do_QueryInterface(pWin->GetFrameElementInternal());
 80526:         if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
 43465:           continue;
 43465:         }
 43465: 
 25723:         if (inner && aThawChildren) {
     1:           inner->Thaw();
     1:         }
     1: 
 25723:         rv = win->ResumeTimeouts(aThawChildren);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
108991: uint32_t
 25723: nsGlobalWindow::TimeoutSuspendCount()
 25723: {
 25723:   FORWARD_TO_INNER(TimeoutSuspendCount, (), 0);
 25723:   return mTimeoutsSuspendDepth;
 25723: }
 25723: 
 31738: void
108991: nsGlobalWindow::EnableDeviceSensor(uint32_t aType)
 94010: {
 94010:   bool alreadyEnabled = false;
108991:   for (uint32_t i = 0; i < mEnabledSensors.Length(); i++) {
 94010:     if (mEnabledSensors[i] == aType) {
 94010:       alreadyEnabled = true;
 94010:       break;
 94010:     }
 94010:   }
 94010: 
101616:   mEnabledSensors.AppendElement(aType);
101616: 
101616:   if (alreadyEnabled) {
101615:     return;
101616:   }
101377: 
 94011:   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
101616:   if (ac) {
 94010:     ac->AddWindowListener(aType, this);
 31738:   }
101616: }
 31738: 
 79901: void
108991: nsGlobalWindow::DisableDeviceSensor(uint32_t aType)
108991: {
108991:   int32_t doomedElement = -1;
108991:   int32_t listenerCount = 0;
108991:   for (uint32_t i = 0; i < mEnabledSensors.Length(); i++) {
 94010:     if (mEnabledSensors[i] == aType) {
 94342:       doomedElement = i;
101616:       listenerCount++;
101616:     }
101616:   }
101616: 
101616:   if (doomedElement == -1) {
 94010:     return;
101616:   }
 94010: 
 94010:   mEnabledSensors.RemoveElementAt(doomedElement);
 94010: 
101616:   if (listenerCount > 1) {
101616:     return;
101616:   }
101616: 
 94011:   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
101616:   if (ac) {
 94010:     ac->RemoveWindowListener(aType, this);
 79901:   }
101616: }
 79901: 
 58023: NS_IMETHODIMP
 58023: nsGlobalWindow::GetURL(nsIDOMMozURLProperty** aURL)
 58023: {
 58023:   FORWARD_TO_INNER(GetURL, (aURL), NS_ERROR_UNEXPECTED);
 58023: 
 58023:   if (!mURLProperty) {
 58023:     mURLProperty = new nsDOMMozURLProperty(this);
 58023:   }
 58023: 
 58023:   NS_ADDREF(*aURL = mURLProperty);
 58023: 
 58023:   return NS_OK;
 58023: }
 58023: 
 70840: // static
 70840: bool
 70840: nsGlobalWindow::HasIndexedDBSupport()
 70840: {
 79445:   return Preferences::GetBool("indexedDB.feature.enabled", true);
 70840: }
 70840: 
 72298: // static
 72298: bool
 72298: nsGlobalWindow::HasPerformanceSupport() 
 72298: {
 79445:   return Preferences::GetBool("dom.enable_performance", false);
 72298: }
 72298: 
 91403: void
 91403: nsGlobalWindow::SizeOfIncludingThis(nsWindowSizes* aWindowSizes) const
 91403: {
101275:   aWindowSizes->mDOMOther += aWindowSizes->mMallocSizeOf(this);
 75136: 
 77262:   if (IsInnerWindow()) {
 77262:     nsEventListenerManager* elm =
 80486:       const_cast<nsGlobalWindow*>(this)->GetListenerManager(false);
 77262:     if (elm) {
101275:       aWindowSizes->mDOMOther +=
 91403:         elm->SizeOfIncludingThis(aWindowSizes->mMallocSizeOf);
 77262:     }
 77262:     if (mDoc) {
 91403:       mDoc->DocSizeOfIncludingThis(aWindowSizes);
 91403:     }
 91403:   }
 91403: 
101275:   aWindowSizes->mDOMOther +=
 91403:     mNavigator ?
 91403:       mNavigator->SizeOfIncludingThis(aWindowSizes->mMallocSizeOf) : 0;
 89203: }
 89203: 
  4040: // nsGlobalChromeWindow implementation
  4040: 
     1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalChromeWindow)
     1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGlobalChromeWindow,
     1:                                                   nsGlobalWindow)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBrowserDOMWindow)
 42412:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMessageManager)
     1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
 72139: 
 72139: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsGlobalChromeWindow,
 72139:                                                 nsGlobalWindow)
 72139:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mBrowserDOMWindow)
 72139:   if (tmp->mMessageManager) {
 72139:     static_cast<nsFrameMessageManager*>(
 72139:       tmp->mMessageManager.get())->Disconnect();
 72139:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mMessageManager)
 72139:   }
 72139: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 72139: 
 40490: DOMCI_DATA(ChromeWindow, nsGlobalChromeWindow)
 40490: 
     1: // QueryInterface implementation for nsGlobalChromeWindow
   791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsGlobalChromeWindow)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMChromeWindow)
 55578:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ChromeWindow)
     1: NS_INTERFACE_MAP_END_INHERITING(nsGlobalWindow)
     1: 
     1: NS_IMPL_ADDREF_INHERITED(nsGlobalChromeWindow, nsGlobalWindow)
     1: NS_IMPL_RELEASE_INHERITED(nsGlobalChromeWindow, nsGlobalWindow)
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalChromeWindow::GetWindowState(uint16_t* aWindowState)
     1: {
     1:   *aWindowState = nsIDOMChromeWindow::STATE_NORMAL;
     1: 
     1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
     1: 
108991:   int32_t aMode = 0;
     1: 
     1:   if (widget) {
     1:     nsresult rv = widget->GetSizeMode(&aMode);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   switch (aMode) {
     1:     case nsSizeMode_Minimized:
     1:       *aWindowState = nsIDOMChromeWindow::STATE_MINIMIZED;
     1:       break;
     1:     case nsSizeMode_Maximized:
     1:       *aWindowState = nsIDOMChromeWindow::STATE_MAXIMIZED;
     1:       break;
 30075:     case nsSizeMode_Fullscreen:
 30075:       *aWindowState = nsIDOMChromeWindow::STATE_FULLSCREEN;
 30075:       break;
     1:     case nsSizeMode_Normal:
     1:       *aWindowState = nsIDOMChromeWindow::STATE_NORMAL;
     1:       break;
     1:     default:
     1:       NS_WARNING("Illegal window state for this chrome window");
     1:       break;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::Maximize()
     1: {
     1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (widget) {
     1:     rv = widget->SetSizeMode(nsSizeMode_Maximized);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::Minimize()
     1: {
     1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
     1:   nsresult rv = NS_OK;
     1: 
 30075:   if (widget)
     1:     rv = widget->SetSizeMode(nsSizeMode_Minimized);
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::Restore()
     1: {
     1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (widget) {
     1:     rv = widget->SetSizeMode(nsSizeMode_Normal);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::GetAttention()
     1: {
     1:   return GetAttentionWithCycleCount(-1);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsGlobalChromeWindow::GetAttentionWithCycleCount(int32_t aCycleCount)
     1: {
     1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (widget) {
     1:     rv = widget->GetAttention(aCycleCount);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
 47857: NS_IMETHODIMP
 71258: nsGlobalChromeWindow::BeginWindowMove(nsIDOMEvent *aMouseDownEvent, nsIDOMElement* aPanel)
 71258: {
 71258:   nsCOMPtr<nsIWidget> widget;
 71258: 
 71258:   // if a panel was supplied, use its widget instead.
 71258: #ifdef MOZ_XUL
 71258:   if (aPanel) {
 71258:     nsCOMPtr<nsIContent> panel = do_QueryInterface(aPanel);
 71258:     NS_ENSURE_TRUE(panel, NS_ERROR_FAILURE);
 71258: 
 71258:     nsIFrame* frame = panel->GetPrimaryFrame();
 71258:     NS_ENSURE_TRUE(frame && frame->GetType() == nsGkAtoms::menuPopupFrame, NS_OK);
 71258: 
 83107:     widget = (static_cast<nsMenuPopupFrame*>(frame))->GetWidget();
 71258:   }
 71258:   else {
 71258: #endif
 71258:     widget = GetMainWidget();
 71258: #ifdef MOZ_XUL
 71258:   }
 71258: #endif
 71258: 
 47857:   if (!widget) {
 47857:     return NS_OK;
 47857:   }
 47857: 
101616:   NS_ENSURE_TRUE(aMouseDownEvent, NS_ERROR_FAILURE);
101616:   nsEvent *internalEvent = aMouseDownEvent->GetInternalNSEvent();
 47857:   NS_ENSURE_TRUE(internalEvent &&
 47857:                  internalEvent->eventStructType == NS_MOUSE_EVENT,
 47857:                  NS_ERROR_FAILURE);
 47857:   nsMouseEvent *mouseEvent = static_cast<nsMouseEvent*>(internalEvent);
 47857: 
 47857:   return widget->BeginMoveDrag(mouseEvent);
 47857: }
 47857: 
     1: //Note: This call will lock the cursor, it will not change as it moves.
     1: //To unlock, the cursor must be set back to CURSOR_AUTO.
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::SetCursor(const nsAString& aCursor)
     1: {
     1:   FORWARD_TO_OUTER_CHROME(SetCursor, (aCursor), NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   nsresult rv = NS_OK;
108991:   int32_t cursor;
     1: 
     1:   // use C strings to keep the code/data size down
     1:   NS_ConvertUTF16toUTF8 cursorString(aCursor);
     1: 
     1:   if (cursorString.Equals("auto"))
     1:     cursor = NS_STYLE_CURSOR_AUTO;
     1:   else {
     1:     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(aCursor);
     1:     if (eCSSKeyword_UNKNOWN == keyword ||
     1:         !nsCSSProps::FindKeyword(keyword, nsCSSProps::kCursorKTable, cursor)) {
     1:       // XXX remove the following three values (leave return NS_OK) after 1.8
     1:       // XXX since they should have been -moz- prefixed (covered by FindKeyword).
     1:       // XXX (also remove |cursorString| at that point?).
     1:       if (cursorString.Equals("grab"))
     1:         cursor = NS_STYLE_CURSOR_GRAB;
     1:       else if (cursorString.Equals("grabbing"))
     1:         cursor = NS_STYLE_CURSOR_GRABBING;
     1:       else if (cursorString.Equals("spinning"))
     1:         cursor = NS_STYLE_CURSOR_SPINNING;
     1:       else
     1:         return NS_OK;
     1:     }
     1:   }
     1: 
 39823:   nsRefPtr<nsPresContext> presContext;
     1:   if (mDocShell) {
     1:     mDocShell->GetPresContext(getter_AddRefs(presContext));
     1:   }
     1: 
     1:   if (presContext) {
     1:     // Need root widget.
     1:     nsCOMPtr<nsIPresShell> presShell;
     1:     mDocShell->GetPresShell(getter_AddRefs(presShell));
     1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
     1: 
     1:     nsIViewManager* vm = presShell->GetViewManager();
     1:     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
     1: 
 64435:     nsIView* rootView = vm->GetRootView();
     1:     NS_ENSURE_TRUE(rootView, NS_ERROR_FAILURE);
     1: 
106838:     nsIWidget* widget = rootView->GetNearestWidget(nullptr);
     1:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
     1: 
     1:     // Call esm and set cursor.
106838:     rv = presContext->EventStateManager()->SetCursor(cursor, nullptr,
 80486:                                                      false, 0.0f, 0.0f,
 80486:                                                      widget, true);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::GetBrowserDOMWindow(nsIBrowserDOMWindow **aBrowserWindow)
     1: {
     1:   FORWARD_TO_OUTER_CHROME(GetBrowserDOMWindow, (aBrowserWindow),
     1:                           NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   NS_ENSURE_ARG_POINTER(aBrowserWindow);
     1: 
     1:   *aBrowserWindow = mBrowserDOMWindow;
     1:   NS_IF_ADDREF(*aBrowserWindow);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGlobalChromeWindow::SetBrowserDOMWindow(nsIBrowserDOMWindow *aBrowserWindow)
     1: {
     1:   FORWARD_TO_OUTER_CHROME(SetBrowserDOMWindow, (aBrowserWindow),
     1:                           NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   mBrowserDOMWindow = aBrowserWindow;
     1:   return NS_OK;
     1: }
     1: 
 30327: NS_IMETHODIMP
 30327: nsGlobalChromeWindow::NotifyDefaultButtonLoaded(nsIDOMElement* aDefaultButton)
 30327: {
 30327: #ifdef MOZ_XUL
 30327:   NS_ENSURE_ARG(aDefaultButton);
 30327: 
 30327:   // Don't snap to a disabled button.
 30327:   nsCOMPtr<nsIDOMXULControlElement> xulControl =
 30327:                                       do_QueryInterface(aDefaultButton);
 30327:   NS_ENSURE_TRUE(xulControl, NS_ERROR_FAILURE);
 79445:   bool disabled;
 30327:   nsresult rv = xulControl->GetDisabled(&disabled);
 30327:   NS_ENSURE_SUCCESS(rv, rv);
 30327:   if (disabled)
 30327:     return NS_OK;
 30327: 
 30327:   // Get the button rect in screen coordinates.
 30327:   nsCOMPtr<nsIContent> content(do_QueryInterface(aDefaultButton));
 30327:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 36657:   nsIFrame *frame = content->GetPrimaryFrame();
 30327:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 30327:   nsIntRect buttonRect = frame->GetScreenRect();
 30327: 
 30327:   // Get the widget rect in screen coordinates.
 30327:   nsIWidget *widget = GetNearestWidget();
 30327:   NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 30327:   nsIntRect widgetRect;
 30327:   rv = widget->GetScreenBounds(widgetRect);
 30327:   NS_ENSURE_SUCCESS(rv, rv);
 30327: 
 30327:   // Convert the buttonRect coordinates from screen to the widget.
 30327:   buttonRect -= widgetRect.TopLeft();
 30327:   rv = widget->OnDefaultButtonLoaded(buttonRect);
 30327:   if (rv == NS_ERROR_NOT_IMPLEMENTED)
 30327:     return NS_OK;
 30327:   return rv;
 30327: #else
 30327:   return NS_ERROR_NOT_IMPLEMENTED;
 30327: #endif
 30327: }
 30327: 
 42412: NS_IMETHODIMP
109557: nsGlobalChromeWindow::GetMessageManager(nsIMessageBroadcaster** aManager)
 42412: {
 42412:   FORWARD_TO_INNER_CHROME(GetMessageManager, (aManager), NS_ERROR_FAILURE);
 42412:   if (!mMessageManager) {
 42412:     nsIScriptContext* scx = GetContextInternal();
 42412:     NS_ENSURE_STATE(scx);
 78415:     JSContext* cx = scx->GetNativeContext();
 42412:     NS_ENSURE_STATE(cx);
109557:     nsCOMPtr<nsIMessageBroadcaster> globalMM =
 43461:       do_GetService("@mozilla.org/globalmessagemanager;1");
 43461:     mMessageManager =
109557:       new nsFrameMessageManager(true, /* aChrome */
106838:                                 nullptr,
106838:                                 nullptr,
106838:                                 nullptr,
106838:                                 nullptr,
 43461:                                 static_cast<nsFrameMessageManager*>(globalMM.get()),
109557:                                 cx,
109557:                                 false, /* aGlobal */
109557:                                 false, /* aProcessManager */
109557:                                 true /* aBroadcaster */);
 42412:     NS_ENSURE_TRUE(mMessageManager, NS_ERROR_OUT_OF_MEMORY);
 42412:   }
 43461:   CallQueryInterface(mMessageManager, aManager);
 42412:   return NS_OK;
 42412: }
 42412: 
  4040: // nsGlobalModalWindow implementation
  4040: 
  4040: // QueryInterface implementation for nsGlobalModalWindow
  4040: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalModalWindow)
  4040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGlobalModalWindow,
  4040:                                                   nsGlobalWindow)
 31393:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReturnValue)
  4040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
  4040: 
 40490: DOMCI_DATA(ModalContentWindow, nsGlobalModalWindow)
 40490: 
  4040: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsGlobalModalWindow)
  4040:   NS_INTERFACE_MAP_ENTRY(nsIDOMModalContentWindow)
 55578:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ModalContentWindow)
  4040: NS_INTERFACE_MAP_END_INHERITING(nsGlobalWindow)
  4040: 
  4040: NS_IMPL_ADDREF_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
  4040: NS_IMPL_RELEASE_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
  4040: 
  4040: 
  4040: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsGlobalModalWindow,
  4040:                                                 nsGlobalWindow)
  4040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReturnValue)
  4040: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
  4040: 
  4040: 
  4040: NS_IMETHODIMP
  4040: nsGlobalModalWindow::GetDialogArguments(nsIArray **aArguments)
  4040: {
  4040:   FORWARD_TO_INNER_MODAL_CONTENT_WINDOW(GetDialogArguments, (aArguments),
  4040:                                         NS_ERROR_NOT_INITIALIZED);
  4040: 
 79445:   bool subsumes = false;
 33525:   nsIPrincipal *self = GetPrincipal();
 33525:   if (self && NS_SUCCEEDED(self->Subsumes(mArgumentsOrigin, &subsumes)) &&
 33525:       subsumes) {
 33525:     NS_IF_ADDREF(*aArguments = mArguments);
 33525:   } else {
106838:     *aArguments = nullptr;
 33525:   }
  4040: 
  4040:   return NS_OK;
  4040: }
  4040: 
  4040: NS_IMETHODIMP
  4040: nsGlobalModalWindow::GetReturnValue(nsIVariant **aRetVal)
  4040: {
  4040:   FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(GetReturnValue, (aRetVal), NS_OK);
  4040: 
  4040:   NS_IF_ADDREF(*aRetVal = mReturnValue);
  4040: 
  4040:   return NS_OK;
  4040: }
  4040: 
  4040: NS_IMETHODIMP
  4040: nsGlobalModalWindow::SetReturnValue(nsIVariant *aRetVal)
  4040: {
  4040:   FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(SetReturnValue, (aRetVal), NS_OK);
  4040: 
  4040:   mReturnValue = aRetVal;
  4040: 
  4040:   return NS_OK;
  4040: }
  4040: 
 33525: nsresult
 33525: nsGlobalModalWindow::SetNewDocument(nsIDocument *aDocument,
 53996:                                     nsISupports *aState,
 79445:                                     bool aForceReuseInnerWindow)
 33525: {
101132:   MOZ_ASSERT(aDocument);
101132: 
 33525:   // If we're loading a new document into a modal dialog, clear the
 33525:   // return value that was set, if any, by the current document.
106838:   mReturnValue = nullptr;
 33525: 
 53996:   return nsGlobalWindow::SetNewDocument(aDocument, aState,
 53996:                                         aForceReuseInnerWindow);
 33525: }
 33525: 
 82604: void
 82604: nsGlobalWindow::SetHasAudioAvailableEventListeners()
 82604: {
 82604:   if (mDoc) {
 82604:     mDoc->NotifyAudioAvailableListener();
 82604:   }
 82604: }
 82604: 
 77149: #define EVENT(name_, id_, type_, struct_)                                    \
 77149:   NS_IMETHODIMP nsGlobalWindow::GetOn##name_(JSContext *cx,                  \
 77149:                                              jsval *vp) {                    \
 80486:     nsEventListenerManager *elm = GetListenerManager(false);                 \
 77149:     if (elm) {                                                               \
110743:       elm->GetEventHandler(nsGkAtoms::on##name_, vp);                        \
 77149:     } else {                                                                 \
 77149:       *vp = JSVAL_NULL;                                                      \
 77149:     }                                                                        \
 77149:     return NS_OK;                                                            \
 77149:   }                                                                          \
 77149:   NS_IMETHODIMP nsGlobalWindow::SetOn##name_(JSContext *cx,                  \
 77149:                                              const jsval &v) {               \
 80486:     nsEventListenerManager *elm = GetListenerManager(true);                  \
 77149:     if (!elm) {                                                              \
 77149:       return NS_ERROR_OUT_OF_MEMORY;                                         \
 77149:     }                                                                        \
 77149:                                                                              \
 77149:     JSObject *obj = mJSObject;                                               \
 77149:     if (!obj) {                                                              \
 77149:       return NS_ERROR_UNEXPECTED;                                            \
 77149:     }                                                                        \
110823:     return elm->SetEventHandlerToJsval(nsGkAtoms::on##name_, cx, obj, v,     \
110823:                                        true);                                \
 77149:   }
 77149: #define WINDOW_ONLY_EVENT EVENT
 77149: #define TOUCH_EVENT EVENT
 77149: #include "nsEventNameList.h"
 77149: #undef TOUCH_EVENT
 77149: #undef WINDOW_ONLY_EVENT
 77149: #undef EVENT
 77149: 
