     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Base class for all our document implementations.
     1:  */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
 37838: #ifdef MOZ_LOGGING
 37838: // so we can get logging even in release builds
 37838: #define FORCE_PR_LOG 1
 37838: #endif
 37838: #include "prlog.h"
     1: #include "plstr.h"
  7783: #include "prprf.h"
     1: 
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsDocument.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsContentList.h"
     1: #include "nsIObserver.h"
     1: #include "nsIBaseWindow.h"
 47937: #include "mozilla/css/Loader.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIScriptRuntime.h"
     1: #include "nsCOMArray.h"
     1: 
     1: #include "nsGUIEvent.h"
 84833: #include "nsAsyncDOMEvent.h"
 88172: #include "nsIDOMNodeFilter.h"
     1: 
     1: #include "nsIDOMStyleSheet.h"
     1: #include "nsDOMAttribute.h"
     1: #include "nsIDOMDOMStringList.h"
     1: #include "nsIDOMDOMImplementation.h"
     1: #include "nsIDOMDocumentXBL.h"
 41653: #include "mozilla/FunctionTimer.h"
     1: #include "nsGenericElement.h"
 16977: #include "nsGenericHTMLElement.h"
     1: #include "nsIDOMCDATASection.h"
     1: #include "nsIDOMProcessingInstruction.h"
     1: #include "nsDOMString.h"
     1: #include "nsNodeUtils.h"
  5440: #include "nsLayoutUtils.h" // for GetFrameForPoint
  5440: #include "nsIFrame.h"
 46908: #include "nsITabChild.h"
     1: 
     1: #include "nsRange.h"
     1: #include "nsIDOMText.h"
     1: #include "nsIDOMComment.h"
     1: #include "nsDOMDocumentType.h"
 16103: #include "nsNodeIterator.h"
     1: #include "nsTreeWalker.h"
     1: 
     1: #include "nsIServiceManager.h"
     1: 
     1: #include "nsContentCID.h"
     1: #include "nsDOMError.h"
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
 62765: #include "nsIJSON.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsNodeInfoManager.h"
     1: #include "nsIFileChannel.h"
     1: #include "nsIMultiPartChannel.h"
     1: #include "nsIRefreshURI.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIScriptError.h"
     1: 
     1: #include "nsNetUtil.h"     // for NS_MakeAbsoluteURI
     1: 
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIPrincipal.h"
     1: 
 73870: #include "nsIDOMWindow.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDOMElement.h"
 29018: #include "nsFocusManager.h"
     1: 
     1: // for radio group stuff
     1: #include "nsIDOMHTMLInputElement.h"
     1: #include "nsIRadioVisitor.h"
     1: #include "nsIFormControl.h"
     1: 
     1: #include "nsXMLEventsManager.h"
     1: 
     1: #include "nsBidiUtils.h"
     1: 
     1: #include "nsIDOMUserDataHandler.h"
     1: #include "nsIDOMXPathEvaluator.h"
     1: #include "nsIXPathEvaluatorInternal.h"
     1: #include "nsIParserService.h"
     1: #include "nsContentCreatorFunctions.h"
     1: 
     1: #include "nsIScriptContext.h"
     1: #include "nsBindingManager.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMHTMLFormElement.h"
     1: #include "nsIRequest.h"
     1: #include "nsILink.h"
 87152: #include "nsBlobProtocolHandler.h"
     1: 
 91519: #include "nsCharsetAlias.h"
 93784: #include "nsCharsetSource.h"
     1: #include "nsIParser.h"
     1: #include "nsIContentSink.h"
     1: 
     1: #include "nsDateTimeFormatCID.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "nsEventDispatcher.h"
    62: #include "nsMutationEvent.h"
     1: #include "nsDOMCID.h"
     1: 
 29420: #include "jsapi.h"
     1: #include "nsIJSContextStack.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsCycleCollector.h"
  1353: #include "nsCCUncollectableMarker.h"
  2324: #include "nsIContentPolicy.h"
 20078: #include "nsContentPolicyUtils.h"
 20078: #include "nsICategoryManager.h"
 20078: #include "nsIDocumentLoaderFactory.h"
 20078: #include "nsIContentViewer.h"
 20078: #include "nsIXMLContentSink.h"
 20078: #include "nsContentErrors.h"
 20078: #include "nsIXULDocument.h"
 20078: #include "nsIPrompt.h"
 21811: #include "nsIPropertyBag2.h"
 29539: #include "nsIDOMPageTransitionEvent.h"
 12256: #include "nsFrameLoader.h"
 42357: #include "nsEscape.h"
 89114: #include "nsObjectLoadingContent.h"
 94004: #include "nsHtml5TreeOpExecutor.h"
 34389: #ifdef MOZ_MEDIA
 34207: #include "nsHTMLMediaElement.h"
 34389: #endif // MOZ_MEDIA
 12256: 
 14228: #include "mozAutoDocUpdate.h"
 41629: #include "nsGlobalWindow.h"
 61406: #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
 72298: #include "nsDOMNavigationTiming.h"
 77844: #include "nsEventStateManager.h"
 14228: 
 23697: #include "nsSMILAnimationController.h"
 23697: #include "imgIContainer.h"
 25961: #include "nsSVGUtils.h"
 23697: 
 50698: #include "nsRefreshDriver.h"
 50698: 
 37418: // FOR CSP (autogenerated by xpidl)
 37418: #include "nsIContentSecurityPolicy.h"
 47342: #include "nsCSPService.h"
 42984: #include "nsHTMLStyleSheet.h"
 42984: #include "nsHTMLCSSStyleSheet.h"
 37418: 
 38488: #include "mozilla/dom/Link.h"
 52011: #include "nsIHTMLDocument.h"
 62607: #include "nsXULAppAPI.h"
 68879: #include "nsDOMTouchEvent.h"
 52011: 
 70840: #include "mozilla/Preferences.h"
 70840: 
 74594: #include "imgILoader.h"
 80074: #include "nsWrapperCacheInlines.h"
 74594: 
 70840: using namespace mozilla;
 38488: using namespace mozilla::dom;
 38488: 
 57140: typedef nsTArray<Link*> LinkArray;
 57140: 
 81397: // Reference to the document which requested DOM full-screen mode.
 81144: nsWeakPtr nsDocument::sFullScreenDoc = nsnull;
 38488: 
 81397: // Reference to the root document of the branch containing the document
 81397: // which requested DOM full-screen mode.
 81397: nsWeakPtr nsDocument::sFullScreenRootDoc = nsnull;
 81397: 
     1: #ifdef PR_LOGGING
     1: static PRLogModuleInfo* gDocumentLeakPRLog;
 37418: static PRLogModuleInfo* gCspPRLog;
     1: #endif
     1: 
 69024: #define NAME_NOT_VALID ((nsSimpleContentList*)1)
 15474: 
 15474: nsIdentifierMapEntry::~nsIdentifierMapEntry()
 15474: {
 15474: }
 15474: 
 15474: void
 15474: nsIdentifierMapEntry::Traverse(nsCycleCollectionTraversalCallback* aCallback)
 15474: {
 18993:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
 18993:                                      "mIdentifierMap mNameContentList");
 19130:   aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mNameContentList));
 18993: 
 18993:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback, "mIdentifierMap mDocAllList");
 15474:   aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mDocAllList));
 33810: 
 50428:   if (mImageElement) {
 50428:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
 50428:                                        "mIdentifierMap mImageElement element");
 50428:     nsIContent* imageElement = mImageElement;
 50428:     aCallback->NoteXPCOMChild(imageElement);
 50428:   }
 15474: }
 15474: 
 79445: bool
 50428: nsIdentifierMapEntry::IsEmpty()
 50428: {
 50428:   return mIdContentList.Count() == 0 && !mNameContentList &&
 50428:          !mChangeCallbacks && !mImageElement;
 50428: }
 50428: 
 41635: Element*
 41635: nsIdentifierMapEntry::GetIdElement()
 41635: {
 41635:   return static_cast<Element*>(mIdContentList.SafeElementAt(0));
 15474: }
 15474: 
 50428: Element*
 50428: nsIdentifierMapEntry::GetImageIdElement()
 50428: {
 50428:   return mImageElement ? mImageElement.get() : GetIdElement();
 50428: }
 50428: 
 15475: void
 15475: nsIdentifierMapEntry::AppendAllIdContent(nsCOMArray<nsIContent>* aElements)
 15475: {
 15475:   for (PRInt32 i = 0; i < mIdContentList.Count(); ++i) {
 41635:     aElements->AppendObject(static_cast<Element*>(mIdContentList[i]));
 15475:   }
 15475: }
 15475: 
 15515: void
 15515: nsIdentifierMapEntry::AddContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
 79445:                                                void* aData, bool aForImage)
 15515: {
 15515:   if (!mChangeCallbacks) {
 15515:     mChangeCallbacks = new nsTHashtable<ChangeCallbackEntry>;
 15515:     if (!mChangeCallbacks)
 15515:       return;
 15515:     mChangeCallbacks->Init();
 15515:   }
 15515: 
 50428:   ChangeCallback cc = { aCallback, aData, aForImage };
 15515:   mChangeCallbacks->PutEntry(cc);
 15515: }
 15515: 
 15515: void
 15515: nsIdentifierMapEntry::RemoveContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
 79445:                                                   void* aData, bool aForImage)
 15515: {
 15515:   if (!mChangeCallbacks)
 15515:     return;
 50428:   ChangeCallback cc = { aCallback, aData, aForImage };
 15515:   mChangeCallbacks->RemoveEntry(cc);
 15515:   if (mChangeCallbacks->Count() == 0) {
 15515:     mChangeCallbacks = nsnull;
 15515:   }
 15515: }
 15515: 
 15515: struct FireChangeArgs {
 41635:   Element* mFrom;
 41635:   Element* mTo;
 79445:   bool mImageOnly;
 79445:   bool mHaveImageOverride;
 15515: };
 15515: 
 20261: static PLDHashOperator
 15515: FireChangeEnumerator(nsIdentifierMapEntry::ChangeCallbackEntry *aEntry, void *aArg)
 15515: {
 15515:   FireChangeArgs* args = static_cast<FireChangeArgs*>(aArg);
 50428:   // Don't fire image changes for non-image observers, and don't fire element
 50428:   // changes for image observers when an image override is active.
 50428:   if (aEntry->mKey.mForImage ? (args->mHaveImageOverride && !args->mImageOnly) :
 50428:                                args->mImageOnly)
 50428:     return PL_DHASH_NEXT;
 15515:   return aEntry->mKey.mCallback(args->mFrom, args->mTo, aEntry->mKey.mData)
 15515:       ? PL_DHASH_NEXT : PL_DHASH_REMOVE;
 15515: }
 15515: 
 15515: void
 41635: nsIdentifierMapEntry::FireChangeCallbacks(Element* aOldElement,
 50428:                                           Element* aNewElement,
 79445:                                           bool aImageOnly)
 15515: {
 15515:   if (!mChangeCallbacks)
 15515:     return;
 15515: 
 50428:   FireChangeArgs args = { aOldElement, aNewElement, aImageOnly, !!mImageElement };
 15515:   mChangeCallbacks->EnumerateEntries(FireChangeEnumerator, &args);
 15515: }
 15515: 
 79445: bool
 41635: nsIdentifierMapEntry::AddIdElement(Element* aElement)
 41635: {
 41635:   NS_PRECONDITION(aElement, "Must have element");
 15474:   NS_PRECONDITION(mIdContentList.IndexOf(nsnull) < 0,
 15474:                   "Why is null in our list?");
 26475: 
 26475: #ifdef DEBUG
 41635:   Element* currentElement =
 41635:     static_cast<Element*>(mIdContentList.SafeElementAt(0));
 26475: #endif
 15474: 
 15474:   // Common case
 15474:   if (mIdContentList.Count() == 0) {
 41635:     if (!mIdContentList.AppendElement(aElement))
 80486:       return false;
 41635:     NS_ASSERTION(currentElement == nsnull, "How did that happen?");
 41635:     FireChangeCallbacks(nsnull, aElement);
 80486:     return true;
 15474:   }
 15474: 
 26475:   // We seem to have multiple content nodes for the same id, or XUL is messing
 26475:   // with us.  Search for the right place to insert the content.
 15474:   PRInt32 start = 0;
 15474:   PRInt32 end = mIdContentList.Count();
 15474:   do {
 15474:     NS_ASSERTION(start < end, "Bogus start/end");
 15474:     
 15474:     PRInt32 cur = (start + end) / 2;
 15474:     NS_ASSERTION(cur >= start && cur < end, "What happened here?");
 15474: 
 41635:     Element* curElement = static_cast<Element*>(mIdContentList[cur]);
 41635:     if (curElement == aElement) {
 15474:       // Already in the list, so already in the right spot.  Get out of here.
 26475:       // XXXbz this only happens because XUL does all sorts of random
 26475:       // UpdateIdTableEntry calls.  Hate, hate, hate!
 80486:       return true;
 15474:     }
 15474: 
 41635:     if (nsContentUtils::PositionIsBefore(aElement, curElement)) {
 15474:       end = cur;
 15474:     } else {
 15474:       start = cur + 1;
 15474:     }
 15474:   } while (start != end);
 15474: 
 41635:   if (!mIdContentList.InsertElementAt(aElement, start))
 80486:     return false;
 51858: 
 15515:   if (start == 0) {
 41635:     Element* oldElement =
 41635:       static_cast<Element*>(mIdContentList.SafeElementAt(1));
 41635:     NS_ASSERTION(currentElement == oldElement, "How did that happen?");
 41635:     FireChangeCallbacks(oldElement, aElement);
 15515:   }
 80486:   return true;
 15474: }
 15474: 
 50428: void
 41635: nsIdentifierMapEntry::RemoveIdElement(Element* aElement)
 15474: {
 51858:   NS_PRECONDITION(aElement, "Missing element");
 51858: 
 15515:   // This should only be called while the document is in an update.
 15515:   // Assertions near the call to this method guarantee this.
 15515: 
 51858:   // This could fire in OOM situations
 51858:   // Only assert this in HTML documents for now as XUL does all sorts of weird
 51858:   // crap.
 80527:   NS_ASSERTION(!aElement->OwnerDoc()->IsHTML() ||
 51858:                mIdContentList.IndexOf(aElement) >= 0,
 51858:                "Removing id entry that doesn't exist");
 51858: 
 15474:   // XXXbz should this ever Compact() I guess when all the content is gone
 15474:   // we'll just get cleaned up in the natural order of things...
 41635:   Element* currentElement =
 41635:     static_cast<Element*>(mIdContentList.SafeElementAt(0));
 51858:   mIdContentList.RemoveElement(aElement);
 41635:   if (currentElement == aElement) {
 41635:     FireChangeCallbacks(currentElement,
 41635:                         static_cast<Element*>(mIdContentList.SafeElementAt(0)));
 15515:   }
 50428: }
 50428: 
 50428: void
 50428: nsIdentifierMapEntry::SetImageElement(Element* aElement)
 50428: {
 50428:   Element* oldElement = GetImageIdElement();
 50428:   mImageElement = aElement;
 50428:   Element* newElement = GetImageIdElement();
 50428:   if (oldElement != newElement) {
 80486:     FireChangeCallbacks(oldElement, newElement, true);
 50428:   }
 15474: }
 15474: 
 15474: void
 69024: nsIdentifierMapEntry::AddNameElement(nsIDocument* aDocument, Element* aElement)
 15474: {
 68823:   if (!mNameContentList) {
 69024:     mNameContentList = new nsSimpleContentList(aDocument);
 68823:   }
 68823: 
 41635:   mNameContentList->AppendElement(aElement);
 15474: }
 15474: 
 15474: void
 41635: nsIdentifierMapEntry::RemoveNameElement(Element* aElement)
 15474: {
 78485:   if (mNameContentList) {
 41635:     mNameContentList->RemoveElement(aElement);
 15474:   }
 78485: }
 15474: 
     1: // Helper structs for the content->subdoc map
     1: 
     1: class SubDocMapEntry : public PLDHashEntryHdr
     1: {
     1: public:
     1:   // Both of these are strong references
 81062:   Element *mKey; // must be first, to look like PLDHashEntryStub
     1:   nsIDocument *mSubDocument;
     1: };
     1: 
     1: struct FindContentData
     1: {
     1:   FindContentData(nsIDocument *aSubDoc)
     1:     : mSubDocument(aSubDoc), mResult(nsnull)
     1:   {
     1:   }
     1: 
     1:   nsISupports *mSubDocument;
 81062:   Element *mResult;
     1: };
     1: 
     1: 
     1: /**
     1:  * A struct that holds all the information about a radio group.
     1:  */
     1: struct nsRadioGroupStruct
     1: {
 63105:   nsRadioGroupStruct()
 63105:     : mRequiredRadioCount(0)
 63107:     , mGroupSuffersFromValueMissing(false)
 63105:   {}
 63105: 
     1:   /**
     1:    * A strong pointer to the currently selected radio button.
     1:    */
     1:   nsCOMPtr<nsIDOMHTMLInputElement> mSelectedRadioButton;
  6365:   nsCOMArray<nsIFormControl> mRadioButtons;
 63105:   PRUint32 mRequiredRadioCount;
 63107:   bool mGroupSuffersFromValueMissing;
     1: };
     1: 
     1: 
     1: nsDOMStyleSheetList::nsDOMStyleSheetList(nsIDocument *aDocument)
     1: {
     1:   mLength = -1;
     1:   // Not reference counted to avoid circular references.
     1:   // The document will tell us when its going away.
     1:   mDocument = aDocument;
     1:   mDocument->AddObserver(this);
     1: }
     1: 
     1: nsDOMStyleSheetList::~nsDOMStyleSheetList()
     1: {
     1:   if (mDocument) {
     1:     mDocument->RemoveObserver(this);
     1:   }
     1: }
     1: 
 40490: DOMCI_DATA(StyleSheetList, nsDOMStyleSheetList)
 40490: 
     1: // XXX couldn't we use the GetIIDs method from CSSStyleSheetList here?
     1: // QueryInterface implementation for nsDOMStyleSheetList
  9123: NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetList)
  9123:   NS_INTERFACE_TABLE3(nsDOMStyleSheetList,
  9123:                       nsIDOMStyleSheetList,
  9123:                       nsIDocumentObserver,
  9123:                       nsIMutationObserver)
  9123:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StyleSheetList)
     1: NS_INTERFACE_MAP_END
     1: 
     1: 
     1: NS_IMPL_ADDREF(nsDOMStyleSheetList)
     1: NS_IMPL_RELEASE(nsDOMStyleSheetList)
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsDOMStyleSheetList::GetLength(PRUint32* aLength)
     1: {
     1:   if (mDocument) {
     1:     // XXX Find the number and then cache it. We'll use the
     1:     // observer notification to figure out if new ones have
     1:     // been added or removed.
     1:     if (-1 == mLength) {
     1:       mLength = mDocument->GetNumberOfStyleSheets();
     1: 
     1: #ifdef DEBUG
     1:       PRInt32 i;
     1:       for (i = 0; i < mLength; i++) {
     1:         nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(i);
     1:         nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(sheet));
     1:         NS_ASSERTION(domss, "All \"normal\" sheets implement nsIDOMStyleSheet");
     1:       }
     1: #endif
     1:     }
     1:     *aLength = mLength;
     1:   }
     1:   else {
     1:     *aLength = 0;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 20752: nsIStyleSheet*
 20752: nsDOMStyleSheetList::GetItemAt(PRUint32 aIndex)
 20752: {
 20752:   if (!mDocument || aIndex >= (PRUint32)mDocument->GetNumberOfStyleSheets()) {
 20752:     return nsnull;
 20752:   }
 20752: 
     1:   nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(aIndex);
     1:   NS_ASSERTION(sheet, "Must have a sheet");
 20752: 
 20752:   return sheet;
 20752: }
 20752: 
 20752: NS_IMETHODIMP
 20752: nsDOMStyleSheetList::Item(PRUint32 aIndex, nsIDOMStyleSheet** aReturn)
 20752: {
 20752:   nsIStyleSheet *sheet = GetItemAt(aIndex);
 20752:   if (!sheet) {
 20752:       *aReturn = nsnull;
 20752: 
 20752:       return NS_OK;
 20752:   }
 20752: 
     1:   return CallQueryInterface(sheet, aReturn);
     1: }
     1: 
     1: void
     1: nsDOMStyleSheetList::NodeWillBeDestroyed(const nsINode *aNode)
     1: {
     1:   mDocument = nsnull;
     1: }
     1: 
     1: void
     1: nsDOMStyleSheetList::StyleSheetAdded(nsIDocument *aDocument,
     1:                                      nsIStyleSheet* aStyleSheet,
 79445:                                      bool aDocumentSheet)
     1: {
     1:   if (aDocumentSheet && -1 != mLength) {
     1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
     1:     if (domss) {
     1:       mLength++;
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsDOMStyleSheetList::StyleSheetRemoved(nsIDocument *aDocument,
     1:                                        nsIStyleSheet* aStyleSheet,
 79445:                                        bool aDocumentSheet)
     1: {
     1:   if (aDocumentSheet && -1 != mLength) {
     1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
     1:     if (domss) {
     1:       mLength--;
     1:     }
     1:   }
     1: }
     1: 
     1: // nsOnloadBlocker implementation
     1: NS_IMPL_ISUPPORTS1(nsOnloadBlocker, nsIRequest)
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::GetName(nsACString &aResult)
     1: { 
     1:   aResult.AssignLiteral("about:document-onload-blocker");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsOnloadBlocker::IsPending(bool *_retval)
     1: {
 80486:   *_retval = true;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::GetStatus(nsresult *status)
     1: {
     1:   *status = NS_OK;
     1:   return NS_OK;
     1: } 
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::Cancel(nsresult status)
     1: {
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::Suspend(void)
     1: {
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::Resume(void)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::GetLoadGroup(nsILoadGroup * *aLoadGroup)
     1: {
     1:   *aLoadGroup = nsnull;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::SetLoadGroup(nsILoadGroup * aLoadGroup)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::GetLoadFlags(nsLoadFlags *aLoadFlags)
     1: {
     1:   *aLoadFlags = nsIRequest::LOAD_NORMAL;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsOnloadBlocker::SetLoadFlags(nsLoadFlags aLoadFlags)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: // ==================================================================
 20078: 
 20078: nsExternalResourceMap::nsExternalResourceMap()
 80486:   : mHaveShutDown(false)
 20078: {
 20078:   mMap.Init();
 20078:   mPendingLoads.Init();
 20078: }
 20078: 
 20078: nsIDocument*
 20078: nsExternalResourceMap::RequestResource(nsIURI* aURI,
 20078:                                        nsINode* aRequestingNode,
 20078:                                        nsDocument* aDisplayDocument,
 20078:                                        ExternalResourceLoad** aPendingLoad)
 20078: {
 20078:   // If we ever start allowing non-same-origin loads here, we might need to do
 20078:   // something interesting with aRequestingPrincipal even for the hashtable
 20078:   // gets.
 20078:   NS_PRECONDITION(aURI, "Must have a URI");
 20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
 20078:   *aPendingLoad = nsnull;
 20078:   if (mHaveShutDown) {
 20078:     return nsnull;
 20078:   }
 20078:   
 20078:   // First, make sure we strip the ref from aURI.
 20078:   nsCOMPtr<nsIURI> clone;
 70215:   nsresult rv = aURI->CloneIgnoringRef(getter_AddRefs(clone));
 70215:   if (NS_FAILED(rv) || !clone) {
 20078:     return nsnull;
 20078:   }
 20078:   
 20078:   ExternalResource* resource;
 20078:   mMap.Get(clone, &resource);
 20078:   if (resource) {
 20078:     return resource->mDocument;
 20078:   }
 20078: 
 20078:   nsRefPtr<PendingLoad> load;
 20078:   mPendingLoads.Get(clone, getter_AddRefs(load));
 20078:   if (load) {
 70215:     load.forget(aPendingLoad);
 20078:     return nsnull;
 20078:   }
 20078: 
 20078:   load = new PendingLoad(aDisplayDocument);
 20078: 
 98908:   mPendingLoads.Put(clone, load);
 20078: 
 20078:   if (NS_FAILED(load->StartLoad(clone, aRequestingNode))) {
 20078:     // Make sure we don't thrash things by trying this load again, since
 20078:     // chances are it failed for good reasons (security check, etc).
 20078:     AddExternalResource(clone, nsnull, nsnull, aDisplayDocument);
 20078:   } else {
 70215:     load.forget(aPendingLoad);
 20078:   }
 20078: 
 20078:   return nsnull;
 20078: }
 20078: 
 20078: struct
 20078: nsExternalResourceEnumArgs
 20078: {
 20078:   nsIDocument::nsSubDocEnumFunc callback;
 20078:   void *data;
 20078: };
 20078: 
 20705: static PLDHashOperator
 20078: ExternalResourceEnumerator(nsIURI* aKey,
 20078:                            nsExternalResourceMap::ExternalResource* aData,
 20078:                            void* aClosure)
 20078: {
 20078:   nsExternalResourceEnumArgs* args =
 20078:     static_cast<nsExternalResourceEnumArgs*>(aClosure);
 79445:   bool next =
 80486:     aData->mDocument ? args->callback(aData->mDocument, args->data) : true;
 20078:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
 20078: }
 20078: 
 20078: void
 20078: nsExternalResourceMap::EnumerateResources(nsIDocument::nsSubDocEnumFunc aCallback,
 20078:                                           void* aData)
 20078: {
 20078:   nsExternalResourceEnumArgs args = { aCallback, aData };
 20078:   mMap.EnumerateRead(ExternalResourceEnumerator, &args);
 20078: }
 20078: 
 20705: static PLDHashOperator
 20078: ExternalResourceTraverser(nsIURI* aKey,
 20078:                           nsExternalResourceMap::ExternalResource* aData,
 20078:                           void* aClosure)
 20078: {
 20078:   nsCycleCollectionTraversalCallback *cb = 
 20078:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 20078: 
 20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
 20078:                                      "mExternalResourceMap.mMap entry"
 20078:                                      "->mDocument");
 20078:   cb->NoteXPCOMChild(aData->mDocument);
 20078: 
 20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
 20078:                                      "mExternalResourceMap.mMap entry"
 20078:                                      "->mViewer");
 20078:   cb->NoteXPCOMChild(aData->mViewer);
 20078: 
 20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
 20078:                                      "mExternalResourceMap.mMap entry"
 20078:                                      "->mLoadGroup");
 20078:   cb->NoteXPCOMChild(aData->mLoadGroup);
 20078: 
 20078:   return PL_DHASH_NEXT;
 20078: }
 20078: 
 20078: void
 20078: nsExternalResourceMap::Traverse(nsCycleCollectionTraversalCallback* aCallback) const
 20078: {
 20078:   // mPendingLoads will get cleared out as the requests complete, so
 20078:   // no need to worry about those here.
 20078:   mMap.EnumerateRead(ExternalResourceTraverser, aCallback);
 20078: }
 20078: 
 49570: static PLDHashOperator
 49570: ExternalResourceHider(nsIURI* aKey,
 49570:                       nsExternalResourceMap::ExternalResource* aData,
 49570:                       void* aClosure)
 49570: {
 50640:   if (aData->mViewer) {
 49570:     aData->mViewer->Hide();
 50640:   }
 49570:   return PL_DHASH_NEXT;
 49570: }
 49570: 
 49570: void
 49570: nsExternalResourceMap::HideViewers()
 49570: {
 49570:   mMap.EnumerateRead(ExternalResourceHider, nsnull);
 49570: }
 49570: 
 49570: static PLDHashOperator
 49570: ExternalResourceShower(nsIURI* aKey,
 49570:                        nsExternalResourceMap::ExternalResource* aData,
 49570:                        void* aClosure)
 49570: {
 51653:   if (aData->mViewer) {
 49570:     aData->mViewer->Show();
 51653:   }
 49570:   return PL_DHASH_NEXT;
 49570: }
 49570: 
 49570: void
 49570: nsExternalResourceMap::ShowViewers()
 49570: {
 49570:   mMap.EnumerateRead(ExternalResourceShower, nsnull);
 49570: }
 49570: 
 60736: void
 60736: TransferZoomLevels(nsIDocument* aFromDoc,
 60736:                    nsIDocument* aToDoc)
 60736: {
 60736:   NS_ABORT_IF_FALSE(aFromDoc && aToDoc,
 60736:                     "transferring zoom levels from/to null doc");
 60736: 
 60736:   nsIPresShell* fromShell = aFromDoc->GetShell();
 60736:   if (!fromShell)
 60736:     return;
 60736: 
 60736:   nsPresContext* fromCtxt = fromShell->GetPresContext();
 60736:   if (!fromCtxt)
 60736:     return;
 60736: 
 60736:   nsIPresShell* toShell = aToDoc->GetShell();
 60736:   if (!toShell)
 60736:     return;
 60736: 
 60736:   nsPresContext* toCtxt = toShell->GetPresContext();
 60736:   if (!toCtxt)
 60736:     return;
 60736: 
 60736:   toCtxt->SetFullZoom(fromCtxt->GetFullZoom());
 90439:   toCtxt->SetMinFontSize(fromCtxt->MinFontSize(nsnull));
 60736:   toCtxt->SetTextZoom(fromCtxt->TextZoom());
 60736: }
 60736: 
 62341: void
 62341: TransferShowingState(nsIDocument* aFromDoc, nsIDocument* aToDoc)
 62341: {
 62341:   NS_ABORT_IF_FALSE(aFromDoc && aToDoc,
 62341:                     "transferring showing state from/to null doc");
 62341: 
 62341:   if (aFromDoc->IsShowing()) {
 80486:     aToDoc->OnPageShow(true, nsnull);
 62341:   }
 62341: }
 62341: 
 20078: nsresult
 20078: nsExternalResourceMap::AddExternalResource(nsIURI* aURI,
 80401:                                            nsIContentViewer* aViewer,
 20078:                                            nsILoadGroup* aLoadGroup,
 20078:                                            nsIDocument* aDisplayDocument)
 20078: {
 20078:   NS_PRECONDITION(aURI, "Unexpected call");
 20078:   NS_PRECONDITION((aViewer && aLoadGroup) || (!aViewer && !aLoadGroup),
 20078:                   "Must have both or neither");
 20078:   
 20078:   nsRefPtr<PendingLoad> load;
 20078:   mPendingLoads.Get(aURI, getter_AddRefs(load));
 20078:   mPendingLoads.Remove(aURI);
 20078: 
 20078:   nsresult rv = NS_OK;
 20078:   
 20078:   nsCOMPtr<nsIDocument> doc;
 20078:   if (aViewer) {
 37433:     doc = aViewer->GetDocument();
 20078:     NS_ASSERTION(doc, "Must have a document");
 20078: 
 20078:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(doc);
 20078:     if (xulDoc) {
 20078:       // We don't handle XUL stuff here yet.
 20078:       rv = NS_ERROR_NOT_AVAILABLE;
 20078:     } else {
 20078:       doc->SetDisplayDocument(aDisplayDocument);
 20078: 
 49570:       // Make sure that hiding our viewer will tear down its presentation.
 80486:       aViewer->SetSticky(false);
 49570: 
 23738:       rv = aViewer->Init(nsnull, nsIntRect(0, 0, 0, 0));
 20078:       if (NS_SUCCEEDED(rv)) {
 20078:         rv = aViewer->Open(nsnull, nsnull);
 20078:       }
 20078:     }
 20078:     
 20078:     if (NS_FAILED(rv)) {
 20078:       doc = nsnull;
 20078:       aViewer = nsnull;
 20078:       aLoadGroup = nsnull;
 20078:     }
 20078:   }
 20078: 
 20078:   ExternalResource* newResource = new ExternalResource();
 98908:   mMap.Put(aURI, newResource);
 98908: 
 20078:   newResource->mDocument = doc;
 20078:   newResource->mViewer = aViewer;
 20078:   newResource->mLoadGroup = aLoadGroup;
 60736:   if (doc) {
 60736:     TransferZoomLevels(aDisplayDocument, doc);
 62341:     TransferShowingState(aDisplayDocument, doc);
 60736:   }
 20078: 
 20078:   const nsTArray< nsCOMPtr<nsIObserver> > & obs = load->Observers();
 20078:   for (PRUint32 i = 0; i < obs.Length(); ++i) {
 20078:     obs[i]->Observe(doc, "external-resource-document-created", nsnull);
 20078:   }
 20078: 
 20078:   return rv;
 20078: }
 20078: 
 20078: NS_IMPL_ISUPPORTS2(nsExternalResourceMap::PendingLoad,
 20078:                    nsIStreamListener,
 20078:                    nsIRequestObserver)
 20078: 
 20078: NS_IMETHODIMP
 20078: nsExternalResourceMap::PendingLoad::OnStartRequest(nsIRequest *aRequest,
 20078:                                                    nsISupports *aContext)
 20078: {
 20078:   nsExternalResourceMap& map = mDisplayDocument->ExternalResourceMap();
 20078:   if (map.HaveShutDown()) {
 20078:     return NS_BINDING_ABORTED;
 20078:   }
 20078: 
 80401:   nsCOMPtr<nsIContentViewer> viewer;
 20078:   nsCOMPtr<nsILoadGroup> loadGroup;
 20078:   nsresult rv = SetupViewer(aRequest, getter_AddRefs(viewer),
 20078:                             getter_AddRefs(loadGroup));
 20078: 
 20078:   // Make sure to do this no matter what
 20078:   nsresult rv2 = map.AddExternalResource(mURI, viewer, loadGroup,
 20078:                                          mDisplayDocument);
 20078:   if (NS_FAILED(rv)) {
 20078:     return rv;
 20078:   }
 20078:   if (NS_FAILED(rv2)) {
 20078:     mTargetListener = nsnull;
 20078:     return rv2;
 20078:   }
 20078:   
 20078:   return mTargetListener->OnStartRequest(aRequest, aContext);
 20078: }
 20078: 
 20078: nsresult
 20078: nsExternalResourceMap::PendingLoad::SetupViewer(nsIRequest* aRequest,
 80401:                                                 nsIContentViewer** aViewer,
 20078:                                                 nsILoadGroup** aLoadGroup)
 20078: {
 20078:   NS_PRECONDITION(!mTargetListener, "Unexpected call to OnStartRequest");
 20078:   *aViewer = nsnull;
 20078:   *aLoadGroup = nsnull;
 20078:   
 20078:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
 20078:   NS_ENSURE_TRUE(chan, NS_ERROR_UNEXPECTED);
 20078: 
 20078:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
 20078:   if (httpChannel) {
 79445:     bool requestSucceeded;
 20078:     if (NS_FAILED(httpChannel->GetRequestSucceeded(&requestSucceeded)) ||
 20078:         !requestSucceeded) {
 20078:       // Bail out on this load, since it looks like we have an HTTP error page
 20078:       return NS_BINDING_ABORTED;
 20078:     }
 20078:   }
 20078:  
 20078:   nsCAutoString type;
 20078:   chan->GetContentType(type);
 20078: 
 20078:   nsCOMPtr<nsILoadGroup> loadGroup;
 20078:   chan->GetLoadGroup(getter_AddRefs(loadGroup));
 20078: 
 20078:   // Give this document its own loadgroup
 20078:   nsCOMPtr<nsILoadGroup> newLoadGroup =
 20078:         do_CreateInstance(NS_LOADGROUP_CONTRACTID);
 20078:   NS_ENSURE_TRUE(newLoadGroup, NS_ERROR_OUT_OF_MEMORY);
 20078:   newLoadGroup->SetLoadGroup(loadGroup);
 20078: 
 20078:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
 20078:   loadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
 20078: 
 20078:   nsCOMPtr<nsIInterfaceRequestor> newCallbacks =
 20078:     new LoadgroupCallbacks(callbacks);
 20078:   newLoadGroup->SetNotificationCallbacks(newCallbacks);
 20078: 
 20078:   // This is some serious hackery cribbed from docshell
 20078:   nsCOMPtr<nsICategoryManager> catMan =
 20078:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
 20078:   NS_ENSURE_TRUE(catMan, NS_ERROR_NOT_AVAILABLE);
 20078:   nsXPIDLCString contractId;
 20078:   nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", type.get(),
 20078:                                          getter_Copies(contractId));
 20078:   NS_ENSURE_SUCCESS(rv, rv);
 20078:   nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory =
 20078:     do_GetService(contractId);
 20078:   NS_ENSURE_TRUE(docLoaderFactory, NS_ERROR_NOT_AVAILABLE);
 20078: 
 20078:   nsCOMPtr<nsIContentViewer> viewer;
 20078:   nsCOMPtr<nsIStreamListener> listener;
 20078:   rv = docLoaderFactory->CreateInstance("external-resource", chan, newLoadGroup,
 20078:                                         type.get(), nsnull, nsnull,
 20078:                                         getter_AddRefs(listener),
 20078:                                         getter_AddRefs(viewer));
 20078:   NS_ENSURE_SUCCESS(rv, rv);
 80401:   NS_ENSURE_TRUE(viewer, NS_ERROR_UNEXPECTED);
 20078: 
 20078:   nsCOMPtr<nsIParser> parser = do_QueryInterface(listener);
 20078:   if (!parser) {
 20078:     /// We don't want to deal with the various fake documents yet
 20078:     return NS_ERROR_NOT_IMPLEMENTED;
 20078:   }
 20078: 
 20078:   // We can't handle HTML and other weird things here yet.
 20078:   nsIContentSink* sink = parser->GetContentSink();
 20078:   nsCOMPtr<nsIXMLContentSink> xmlSink = do_QueryInterface(sink);
 20078:   if (!xmlSink) {
 20078:     return NS_ERROR_NOT_IMPLEMENTED;
 20078:   }
 20078: 
 20078:   listener.swap(mTargetListener);
 80401:   viewer.forget(aViewer);
 80401:   newLoadGroup.forget(aLoadGroup);
 20078:   return NS_OK;
 20078: }
 20078: 
 20078: NS_IMETHODIMP
 20078: nsExternalResourceMap::PendingLoad::OnDataAvailable(nsIRequest* aRequest,
 20078:                                                     nsISupports* aContext,
 20078:                                                     nsIInputStream* aStream,
 20078:                                                     PRUint32 aOffset,
 20078:                                                     PRUint32 aCount)
 20078: {
 20078:   NS_PRECONDITION(mTargetListener, "Shouldn't be getting called!");
 20078:   if (mDisplayDocument->ExternalResourceMap().HaveShutDown()) {
 20078:     return NS_BINDING_ABORTED;
 20078:   }
 20078:   return mTargetListener->OnDataAvailable(aRequest, aContext, aStream, aOffset,
 20078:                                           aCount);
 20078: }
 20078: 
 20078: NS_IMETHODIMP
 20078: nsExternalResourceMap::PendingLoad::OnStopRequest(nsIRequest* aRequest,
 20078:                                                   nsISupports* aContext,
 20078:                                                   nsresult aStatus)
 20078: {
 20078:   // mTargetListener might be null if SetupViewer or AddExternalResource failed
 20078:   if (mTargetListener) {
 20078:     nsCOMPtr<nsIStreamListener> listener;
 20078:     mTargetListener.swap(listener);
 20078:     return listener->OnStopRequest(aRequest, aContext, aStatus);
 20078:   }
 20078: 
 20078:   return NS_OK;
 20078: }
 20078: 
 20078: nsresult
 20078: nsExternalResourceMap::PendingLoad::StartLoad(nsIURI* aURI,
 20078:                                               nsINode* aRequestingNode)
 20078: {
 20078:   NS_PRECONDITION(aURI, "Must have a URI");
 20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
 20078: 
 20078:   // Time to start a load.  First, the security checks.
 20078: 
 20078:   nsIPrincipal* requestingPrincipal = aRequestingNode->NodePrincipal();
 20078: 
 20078:   nsresult rv = nsContentUtils::GetSecurityManager()->
 20078:     CheckLoadURIWithPrincipal(requestingPrincipal, aURI,
 20078:                               nsIScriptSecurityManager::STANDARD);
 20078:   NS_ENSURE_SUCCESS(rv, rv);
 20078:   
 80263:   // Allow data URIs (let them skip the CheckMayLoad call), since we want
 80263:   // to allow external resources from data URIs regardless of the difference
 80263:   // in URI scheme.
 80263:   bool doesInheritSecurityContext;
 80263:   rv =
 80263:     NS_URIChainHasFlags(aURI,
 80263:                         nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
 80263:                         &doesInheritSecurityContext);
 80263:   if (NS_FAILED(rv) || !doesInheritSecurityContext) {
 80486:     rv = requestingPrincipal->CheckMayLoad(aURI, true);
 20078:     NS_ENSURE_SUCCESS(rv, rv);
 80263:   }
 20078: 
 20078:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 20078:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OTHER,
 20078:                                  aURI,
 20078:                                  requestingPrincipal,
 20078:                                  aRequestingNode,
 20078:                                  EmptyCString(), //mime guess
 20078:                                  nsnull,         //extra
 20078:                                  &shouldLoad,
 20078:                                  nsContentUtils::GetContentPolicy(),
 20078:                                  nsContentUtils::GetSecurityManager());
 20078:   if (NS_FAILED(rv)) return rv;
 20078:   if (NS_CP_REJECTED(shouldLoad)) {
 20078:     // Disallowed by content policy
 20078:     return NS_ERROR_CONTENT_BLOCKED;
 20078:   }
 20078: 
 80526:   nsIDocument* doc = aRequestingNode->OwnerDoc();
 20078: 
 21937:   nsCOMPtr<nsIInterfaceRequestor> req = nsContentUtils::GetSameOriginChecker();
 21937:   NS_ENSURE_TRUE(req, NS_ERROR_OUT_OF_MEMORY);
 21937: 
 20078:   nsCOMPtr<nsILoadGroup> loadGroup = doc->GetDocumentLoadGroup();
 20078:   nsCOMPtr<nsIChannel> channel;
 21937:   rv = NS_NewChannel(getter_AddRefs(channel), aURI, nsnull, loadGroup, req);
 20078:   NS_ENSURE_SUCCESS(rv, rv);
 20078: 
 20078:   mURI = aURI;
 20078: 
 20078:   return channel->AsyncOpen(this, nsnull);
 20078: }
 20078: 
 20078: NS_IMPL_ISUPPORTS1(nsExternalResourceMap::LoadgroupCallbacks,
 20078:                    nsIInterfaceRequestor)
 20078: 
 21877: #define IMPL_SHIM(_i) \
 21877:   NS_IMPL_ISUPPORTS1(nsExternalResourceMap::LoadgroupCallbacks::_i##Shim, _i)
 21877: 
 21877: IMPL_SHIM(nsILoadContext)
 21878: IMPL_SHIM(nsIProgressEventSink)
 21878: IMPL_SHIM(nsIChannelEventSink)
 21878: IMPL_SHIM(nsISecurityEventSink)
 21878: IMPL_SHIM(nsIApplicationCacheContainer)
 21877: 
 21877: #undef IMPL_SHIM
 21877: 
 21877: #define IID_IS(_i) aIID.Equals(NS_GET_IID(_i))
 21877: 
 21877: #define TRY_SHIM(_i)                                                       \
 21877:   PR_BEGIN_MACRO                                                           \
 21877:     if (IID_IS(_i)) {                                                      \
 21877:       nsCOMPtr<_i> real = do_GetInterface(mCallbacks);                     \
 21877:       if (!real) {                                                         \
 21877:         return NS_NOINTERFACE;                                             \
 21877:       }                                                                    \
 21877:       nsCOMPtr<_i> shim = new _i##Shim(this, real);                        \
 21877:       if (!shim) {                                                         \
 21877:         return NS_ERROR_OUT_OF_MEMORY;                                     \
 21877:       }                                                                    \
 21877:       *aSink = shim.forget().get();                                        \
 21877:       return NS_OK;                                                        \
 21877:     }                                                                      \
 21877:   PR_END_MACRO
 21877: 
 20078: NS_IMETHODIMP
 20078: nsExternalResourceMap::LoadgroupCallbacks::GetInterface(const nsIID & aIID,
 20078:                                                         void **aSink)
 20078: {
 20078:   if (mCallbacks &&
 46908:       (IID_IS(nsIPrompt) || IID_IS(nsIAuthPrompt) || IID_IS(nsIAuthPrompt2) ||
 46908:        IID_IS(nsITabChild))) {
 20078:     return mCallbacks->GetInterface(aIID, aSink);
 20078:   }
 21877: 
 21877:   *aSink = nsnull;
 21877: 
 21877:   TRY_SHIM(nsILoadContext);
 21877:   TRY_SHIM(nsIProgressEventSink);
 21877:   TRY_SHIM(nsIChannelEventSink);
 21877:   TRY_SHIM(nsISecurityEventSink);
 21877:   TRY_SHIM(nsIApplicationCacheContainer);
 21877:     
 21877:   return NS_NOINTERFACE;
 21877: }
 21877: 
 21877: #undef TRY_SHIM
 20078: #undef IID_IS
 20078: 
 20078: nsExternalResourceMap::ExternalResource::~ExternalResource()
 20078: {
 20078:   if (mViewer) {
 20078:     mViewer->Close(nsnull);
 20078:     mViewer->Destroy();
 20078:   }
 20078: }
 20078: 
 20078: // ==================================================================
     1: // =
     1: // ==================================================================
     1: 
     1: // If we ever have an nsIDocumentObserver notification for stylesheet title
     1: // changes, we could make this inherit from nsDOMStringList instead of
     1: // reimplementing nsIDOMDOMStringList.
102310: class nsDOMStyleSheetSetList MOZ_FINAL : public nsIDOMDOMStringList
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   NS_DECL_NSIDOMDOMSTRINGLIST
     1: 
     1:   nsDOMStyleSheetSetList(nsIDocument* aDocument);
     1: 
     1:   void Disconnect()
     1:   {
     1:     mDocument = nsnull;
     1:   }
     1: 
     1: protected:
     1:   // Rebuild our list of style sets
 23904:   nsresult GetSets(nsTArray<nsString>& aStyleSets);
     1:   
     1:   nsIDocument* mDocument;  // Our document; weak ref.  It'll let us know if it
     1:                            // dies.
     1: };
     1: 
     1: NS_IMPL_ADDREF(nsDOMStyleSheetSetList)
     1: NS_IMPL_RELEASE(nsDOMStyleSheetSetList)
 21218: NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetSetList)
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsDOMStyleSheetSetList)
 21218:     NS_INTERFACE_TABLE_ENTRY(nsDOMStyleSheetSetList, nsIDOMDOMStringList)
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMStringList)
     1: NS_INTERFACE_MAP_END
     1: 
     1: nsDOMStyleSheetSetList::nsDOMStyleSheetSetList(nsIDocument* aDocument)
     1:   : mDocument(aDocument)
     1: {
     1:   NS_ASSERTION(mDocument, "Must have document!");
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDOMStyleSheetSetList::Item(PRUint32 aIndex, nsAString& aResult)
     1: {
 23904:   nsTArray<nsString> styleSets;
     1:   nsresult rv = GetSets(styleSets);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
 23904:   if (aIndex >= styleSets.Length()) {
     1:     SetDOMStringToNull(aResult);
     1:   } else {
 23904:     aResult = styleSets[aIndex];
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDOMStyleSheetSetList::GetLength(PRUint32 *aLength)
     1: {
 23904:   nsTArray<nsString> styleSets;
     1:   nsresult rv = GetSets(styleSets);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
 23904:   *aLength = styleSets.Length();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDOMStyleSheetSetList::Contains(const nsAString& aString, bool *aResult)
     1: {
 23904:   nsTArray<nsString> styleSets;
     1:   nsresult rv = GetSets(styleSets);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
 23904:   *aResult = styleSets.Contains(aString);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 23904: nsDOMStyleSheetSetList::GetSets(nsTArray<nsString>& aStyleSets)
     1: {
     1:   if (!mDocument) {
     1:     return NS_OK; // Spec says "no exceptions", and we have no style sets if we
     1:                   // have no document, for sure
     1:   }
     1:   
     1:   PRInt32 count = mDocument->GetNumberOfStyleSheets();
     1:   nsAutoString title;
     1:   nsAutoString temp;
     1:   for (PRInt32 index = 0; index < count; index++) {
     1:     nsIStyleSheet* sheet = mDocument->GetStyleSheetAt(index);
     1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
     1:     sheet->GetTitle(title);
 23904:     if (!title.IsEmpty() && !aStyleSets.Contains(title) &&
 23904:         !aStyleSets.AppendElement(title)) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // ==================================================================
     1: // =
     1: // ==================================================================
     1: 
 48378: class nsDOMImplementation : public nsIDOMDOMImplementation
     1: {
     1: public:
 78421:   nsDOMImplementation(nsIDocument* aOwner,
 78421:                       nsIScriptGlobalObject* aScriptObject,
  6475:                       nsIURI* aDocumentURI,
 78421:                       nsIURI* aBaseURI);
     1:   virtual ~nsDOMImplementation();
     1: 
 78421:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 78421:   NS_DECL_CYCLE_COLLECTION_CLASS(nsDOMImplementation)
     1: 
     1:   // nsIDOMDOMImplementation
     1:   NS_DECL_NSIDOMDOMIMPLEMENTATION
     1: 
     1: protected:
 78421:   nsCOMPtr<nsIDocument> mOwner;
  6475:   nsWeakPtr mScriptObject;
     1:   nsCOMPtr<nsIURI> mDocumentURI;
     1:   nsCOMPtr<nsIURI> mBaseURI;
     1: };
     1: 
 78421: nsDOMImplementation::nsDOMImplementation(nsIDocument* aOwner,
 78421:                                          nsIScriptGlobalObject* aScriptObject,
  6475:                                          nsIURI* aDocumentURI,
 78421:                                          nsIURI* aBaseURI)
 78421:   : mOwner(aOwner),
 78421:     mScriptObject(do_GetWeakReference(aScriptObject)),
  6475:     mDocumentURI(aDocumentURI),
 78421:     mBaseURI(aBaseURI)
     1: {
     1: }
     1: 
     1: nsDOMImplementation::~nsDOMImplementation()
     1: {
     1: }
     1: 
 40490: DOMCI_DATA(DOMImplementation, nsDOMImplementation)
 40490: 
     1: // QueryInterface implementation for nsDOMImplementation
 78421: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMImplementation)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDOMImplementation)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMDOMImplementation)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMImplementation)
     1: NS_INTERFACE_MAP_END
     1: 
 78421: NS_IMPL_CYCLE_COLLECTION_1(nsDOMImplementation, mOwner)
 78421: 
 78421: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMImplementation)
 78421: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMImplementation)
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsDOMImplementation::HasFeature(const nsAString& aFeature,
     1:                                 const nsAString& aVersion,
 79445:                                 bool* aReturn)
     1: {
     1:   return nsGenericElement::InternalIsSupported(
  3233:            static_cast<nsIDOMDOMImplementation*>(this),
     1:            aFeature, aVersion, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDOMImplementation::CreateDocumentType(const nsAString& aQualifiedName,
     1:                                         const nsAString& aPublicId,
     1:                                         const nsAString& aSystemId,
     1:                                         nsIDOMDocumentType** aReturn)
     1: {
     1:   *aReturn = nsnull;
 78421:   NS_ENSURE_STATE(mOwner);
     1: 
     1:   nsresult rv = nsContentUtils::CheckQName(aQualifiedName);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aQualifiedName);
     1:   NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
     1: 
 15348:   // Indicate that there is no internal subset (not just an empty one)
 78421:   return NS_NewDOMDocumentType(aReturn, mOwner->NodeInfoManager(),
 78421:                                name, aPublicId,
 85953:                                aSystemId, NullString());
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDOMImplementation::CreateDocument(const nsAString& aNamespaceURI,
     1:                                     const nsAString& aQualifiedName,
     1:                                     nsIDOMDocumentType* aDoctype,
     1:                                     nsIDOMDocument** aReturn)
     1: {
     1:   *aReturn = nsnull;
     1: 
     1:   nsresult rv;
     1:   if (!aQualifiedName.IsEmpty()) {
     1:     const nsAFlatString& qName = PromiseFlatString(aQualifiedName);
     1:     const PRUnichar *colon;
 94402:     rv = nsContentUtils::CheckQName(qName, true, &colon);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     if (colon &&
     1:         (DOMStringIsNull(aNamespaceURI) ||
     1:          (Substring(qName.get(), colon).EqualsLiteral("xml") &&
     1:           !aNamespaceURI.EqualsLiteral("http://www.w3.org/XML/1998/namespace")))) {
     1:       return NS_ERROR_DOM_NAMESPACE_ERR;
     1:     }
     1:   }
     1:   else if (DOMStringIsNull(aQualifiedName) &&
     1:            !DOMStringIsNull(aNamespaceURI)) {
     1:     return NS_ERROR_DOM_NAMESPACE_ERR;
     1:   }
     1: 
  6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
  6475:     do_QueryReferent(mScriptObject);
  6475:   
 54461:   NS_ENSURE_STATE(!mScriptObject || scriptHandlingObject);
 54461: 
 95570:   nsCOMPtr<nsIDOMDocument> document;
 95570: 
 95570:   rv = nsContentUtils::CreateDocument(aNamespaceURI, aQualifiedName, aDoctype,
 78421:                                       mDocumentURI, mBaseURI, 
 78421:                                       mOwner->NodePrincipal(),
 82543:                                       scriptHandlingObject,
 82543:                                         DocumentFlavorLegacyGuess,
 95570:                                       getter_AddRefs(document));
 95570:   NS_ENSURE_SUCCESS(rv, rv);
 95570: 
 95570:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(document);
 95570:   doc->SetReadyStateInternal(nsIDocument::READYSTATE_COMPLETE);
 95570: 
 95570:   document.forget(aReturn);
 95570:   return NS_OK;
     1: }
     1: 
 52011: NS_IMETHODIMP
 52011: nsDOMImplementation::CreateHTMLDocument(const nsAString& aTitle,
 52011:                                         nsIDOMDocument** aReturn)
 52011: {
 78421:   *aReturn = nsnull;
 78421:   NS_ENSURE_STATE(mOwner);
 52011: 
 52011:   nsCOMPtr<nsIDOMDocumentType> doctype;
 52011:   // Indicate that there is no internal subset (not just an empty one)
 54461:   nsresult rv = NS_NewDOMDocumentType(getter_AddRefs(doctype),
 78421:                                       mOwner->NodeInfoManager(),
 52011:                                       nsGkAtoms::html, // aName
 52011:                                       EmptyString(), // aPublicId
 52011:                                       EmptyString(), // aSystemId
 85953:                                       NullString()); // aInternalSubset
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011: 
 54461: 
 54461:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 54461:     do_QueryReferent(mScriptObject);
 54461: 
 54461:   NS_ENSURE_STATE(!mScriptObject || scriptHandlingObject);
 54461:                                                        
 54461:   nsCOMPtr<nsIDOMDocument> document;
 54461:   rv = nsContentUtils::CreateDocument(EmptyString(), EmptyString(),
 54461:                                       doctype, mDocumentURI, mBaseURI,
 78421:                                       mOwner->NodePrincipal(),
 82543:                                       scriptHandlingObject,
 82543:                                       DocumentFlavorLegacyGuess,
 54461:                                       getter_AddRefs(document));
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 54461:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(document);
 52011: 
 52011:   nsCOMPtr<nsIContent> root;
 52011:   rv = doc->CreateElem(NS_LITERAL_STRING("html"), NULL, kNameSpaceID_XHTML,
 81061:                        getter_AddRefs(root));
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011:   rv = doc->AppendChildTo(root, false);
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011: 
 52011:   nsCOMPtr<nsIContent> head;
 52011:   rv = doc->CreateElem(NS_LITERAL_STRING("head"), NULL, kNameSpaceID_XHTML,
 81061:                        getter_AddRefs(head));
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011:   rv = root->AppendChildTo(head, false);
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011: 
 52011:   nsCOMPtr<nsIContent> title;
 52011:   rv = doc->CreateElem(NS_LITERAL_STRING("title"), NULL, kNameSpaceID_XHTML,
 81061:                        getter_AddRefs(title));
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011:   rv = head->AppendChildTo(title, false);
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011: 
 52011:   nsCOMPtr<nsIContent> titleText;
 52011:   rv = NS_NewTextNode(getter_AddRefs(titleText), doc->NodeInfoManager());
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011:   rv = titleText->SetText(aTitle, false);
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011:   rv = title->AppendChildTo(titleText, false);
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011: 
 52011:   nsCOMPtr<nsIContent> body;
 52011:   rv = doc->CreateElem(NS_LITERAL_STRING("body"), NULL, kNameSpaceID_XHTML,
 81061:                        getter_AddRefs(body));
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011:   rv = root->AppendChildTo(body, false);
 52011:   NS_ENSURE_SUCCESS(rv, rv);
 52011: 
 95570:   doc->SetReadyStateInternal(nsIDocument::READYSTATE_COMPLETE);
 95570: 
 52011:   document.forget(aReturn);
 52011: 
 52011:   return NS_OK;
 52011: }
 52011: 
     1: // ==================================================================
     1: // =
     1: // ==================================================================
     1: 
     1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
     1:   // bother initializing members to 0.
     1: 
     1: nsDocument::nsDocument(const char* aContentType)
 34205:   : nsIDocument()
 80486:   , mAnimatingImages(true)
 80229:   , mVisibilityState(eHidden)
     1: {
 46309:   SetContentTypeInternal(nsDependentCString(aContentType));
     1:   
     1: #ifdef PR_LOGGING
     1:   if (!gDocumentLeakPRLog)
     1:     gDocumentLeakPRLog = PR_NewLogModule("DocumentLeak");
     1: 
     1:   if (gDocumentLeakPRLog)
     1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
     1:            ("DOCUMENT %p created", this));
 37418: 
 37418:   if (!gCspPRLog)
 37418:     gCspPRLog = PR_NewLogModule("CSP");
     1: #endif
     1: 
     1:   // Start out mLastStyleSheetSet as null, per spec
     1:   SetDOMStringToNull(mLastStyleSheetSet);
 82192:   
 82192:   mLinksToUpdate.Init();
     1: }
     1: 
 20261: static PLDHashOperator
 93686: ClearAllBoxObjects(nsIContent* aKey, nsPIBoxObject* aBoxObject, void* aUserArg)
 11731: {
 11731:   if (aBoxObject) {
 11731:     aBoxObject->Clear();
 11731:   }
 11731:   return PL_DHASH_NEXT;
 11731: }
 11731: 
     1: nsDocument::~nsDocument()
     1: {
     1: #ifdef PR_LOGGING
     1:   if (gDocumentLeakPRLog)
     1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
     1:            ("DOCUMENT %p destroyed", this));
     1: #endif
     1: 
     1: #ifdef DEBUG
  3233:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIDocument*>(this));
     1: #endif
     1: 
 90468:   NS_ASSERTION(!mIsShowing, "Destroying a currently-showing document");
 74743: 
 80486:   mInDestructor = true;
 80486:   mInUnlinkOrDeletion = true;
     1: 
     1:   // Clear mObservers to keep it in sync with the mutationobserver list
     1:   mObservers.Clear();
     1: 
     1:   if (mStyleSheetSetList) {
     1:     mStyleSheetSetList->Disconnect();
     1:   }
     1: 
 69078:   if (mAnimationController) {
 69078:     mAnimationController->Disconnect();
 69078:   }
 69078: 
     1:   mParentDocument = nsnull;
     1: 
     1:   // Kill the subdocument map, doing this will release its strong
     1:   // references, if any.
     1:   if (mSubDocuments) {
     1:     PL_DHashTableDestroy(mSubDocuments);
     1: 
     1:     mSubDocuments = nsnull;
     1:   }
     1: 
     1:   // Destroy link map now so we don't waste time removing
     1:   // links one by one
 43079:   DestroyElementMaps();
     1: 
 14228:   nsAutoScriptBlocker scriptBlocker;
 14228: 
  8938:   PRInt32 indx; // must be signed
     1:   PRUint32 count = mChildren.ChildCount();
     1:   for (indx = PRInt32(count) - 1; indx >= 0; --indx) {
     1:     mChildren.ChildAt(indx)->UnbindFromTree();
     1:     mChildren.RemoveChildAt(indx);
     1:   }
 42105:   mFirstChild = nsnull;
 41634:   mCachedRootElement = nsnull;
     1: 
     1:   // Let the stylesheets know we're going away
     1:   indx = mStyleSheets.Count();
     1:   while (--indx >= 0) {
     1:     mStyleSheets[indx]->SetOwningDocument(nsnull);
     1:   }
     1:   indx = mCatalogSheets.Count();
     1:   while (--indx >= 0) {
     1:     mCatalogSheets[indx]->SetOwningDocument(nsnull);
     1:   }
 93754:   if (mAttrStyleSheet) {
     1:     mAttrStyleSheet->SetOwningDocument(nsnull);
 93754:     NS_RELEASE(mAttrStyleSheet);
 93754:   }
     1:   if (mStyleAttrStyleSheet)
     1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
     1: 
     1:   if (mListenerManager) {
     1:     mListenerManager->Disconnect();
 91087:     UnsetFlags(NODE_HAS_LISTENERMANAGER);
     1:   }
     1: 
     1:   if (mScriptLoader) {
     1:     mScriptLoader->DropDocumentReference();
     1:   }
     1: 
     1:   if (mCSSLoader) {
     1:     // Could be null here if Init() failed
     1:     mCSSLoader->DropDocumentReference();
     1:     NS_RELEASE(mCSSLoader);
     1:   }
     1: 
     1:   // XXX Ideally we'd do this cleanup in the nsIDocument destructor.
     1:   if (mNodeInfoManager) {
     1:     mNodeInfoManager->DropDocumentReference();
     1:   }
     1: 
     1:   delete mHeaderData;
 11731: 
 11731:   if (mBoxObjectTable) {
 11731:     mBoxObjectTable->EnumerateRead(ClearAllBoxObjects, nsnull);
     1:     delete mBoxObjectTable;
 11731:   }
 28045: 
 28045:   mPendingTitleChangeEvent.Revoke();
 38871: 
 38871:   for (PRUint32 i = 0; i < mFileDataUris.Length(); ++i) {
 87152:     nsBlobProtocolHandler::RemoveFileDataEntry(mFileDataUris[i]);
 38871:   }
 50815: 
 50815:   // We don't want to leave residual locks on images. Make sure we're in an
 50815:   // unlocked state, and then clear the table.
 80486:   SetImageLockingState(false);
 50815:   mImageTracker.Clear();
 94270: 
 94270:   mPlugins.Clear();
     1: }
     1: 
     1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocument)
     1: 
 12033: NS_INTERFACE_TABLE_HEAD(nsDocument)
 21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 21218:   NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsDocument)
 12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDocument)
 12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentXBL)
 12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIScriptObjectPrincipal)
 72322:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMEventTarget)
 12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsISupportsWeakReference)
 12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIRadioGroupContainer)
 12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIMutationObserver)
 18430:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIApplicationCacheContainer)
 68879:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentTouch)
 77145:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsITouchEventReceiver)
 77149:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIInlineEventHandlers)
 98051:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIObserver)
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
 21218:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDocument)
 41908:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
 41908:                                  new nsNode3Tearoff(this))
 41909:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNodeSelector,
 41909:                                  new nsNodeSelectorTearoff(this))
 12033:   if (aIID.Equals(NS_GET_IID(nsIDOMXPathEvaluator)) ||
 12033:       aIID.Equals(NS_GET_IID(nsIXPathEvaluatorInternal))) {
 12033:     if (!mXPathEvaluatorTearoff) {
 12033:       nsresult rv;
 12033:       mXPathEvaluatorTearoff =
 12033:         do_CreateInstance(NS_XPATH_EVALUATOR_CONTRACTID,
 12033:                           static_cast<nsIDocument *>(this), &rv);
 12033:       NS_ENSURE_SUCCESS(rv, rv);
 12033:     }
 12033: 
 12033:     return mXPathEvaluatorTearoff->QueryInterface(aIID, aInstancePtr);
 12033:   }
 12033:   else
 12033: NS_INTERFACE_MAP_END
 12033: 
 12033: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDocument)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_DESTROY(nsDocument, 
  1391:                                               nsNodeUtils::LastRelease(this))
     1: 
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsDocument)
 94914:   if (nsGenericElement::CanSkip(tmp, aRemovingAllowed)) {
 94914:     nsEventListenerManager* elm = tmp->GetListenerManager(false);
 94914:     if (elm) {
 94914:       elm->UnmarkGrayJSListeners();
 94914:     }
 94914:     return true;
 94914:   }
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
 88521: 
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsDocument)
 88521:   return nsGenericElement::CanSkipInCC(tmp);
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
 88521: 
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsDocument)
 88521:   return nsGenericElement::CanSkipThis(tmp);
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 88521: 
 20261: static PLDHashOperator
     1: SubDocTraverser(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
     1:                 void *arg)
     1: {
  3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
     1:   nsCycleCollectionTraversalCallback *cb = 
  3233:     static_cast<nsCycleCollectionTraversalCallback*>(arg);
     1: 
 13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mKey");
     1:   cb->NoteXPCOMChild(entry->mKey);
 13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mSubDocument");
     1:   cb->NoteXPCOMChild(entry->mSubDocument);
     1: 
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
 20261: static PLDHashOperator
 20078: RadioGroupsTraverser(const nsAString& aKey, nsRadioGroupStruct* aData,
 20078:                      void* aClosure)
  6365: {
     1:   nsCycleCollectionTraversalCallback *cb = 
  3233:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
     1: 
 13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
 13202:                                    "mRadioGroups entry->mSelectedRadioButton");
  6365:   cb->NoteXPCOMChild(aData->mSelectedRadioButton);
  6365: 
  6365:   PRUint32 i, count = aData->mRadioButtons.Count();
     1:   for (i = 0; i < count; ++i) {
 13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
 13202:                                        "mRadioGroups entry->mRadioButtons[i]");
  6365:     cb->NoteXPCOMChild(aData->mRadioButtons[i]);
  6365:   }
  6365: 
  6365:   return PL_DHASH_NEXT;
     1: }
     1: 
 20261: static PLDHashOperator
 93686: BoxObjectTraverser(nsIContent* key, nsPIBoxObject* boxObject, void* userArg)
     1: {
     1:   nsCycleCollectionTraversalCallback *cb = 
  3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
     1:  
 13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mBoxObjectTable entry");
     1:   cb->NoteXPCOMChild(boxObject);
     1: 
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
 20261: static PLDHashOperator
 15474: IdentifierMapEntryTraverse(nsIdentifierMapEntry *aEntry, void *aArg)
 15474: {
 15474:   nsCycleCollectionTraversalCallback *cb =
 15474:     static_cast<nsCycleCollectionTraversalCallback*>(aArg);
 15474:   aEntry->Traverse(cb);
 15474:   return PL_DHASH_NEXT;
 15474: }
 15474: 
 53870: static const char* kNSURIs[] = {
 53870:   "([none])",
 53870:   "(xmlns)",
 53870:   "(xml)",
 53870:   "(xhtml)",
 53870:   "(XLink)",
 53870:   "(XSLT)",
 53870:   "(XBL)",
 53870:   "(MathML)",
 53870:   "(RDF)",
 53870:   "(XUL)"
 53870: };
 53870: 
 53870: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(nsDocument)
 53870:   if (NS_UNLIKELY(cb.WantDebugInfo())) {
 69565:     char name[512];
 82486:     nsCAutoString loadedAsData;
 82486:     if (tmp->IsLoadedAsData()) {
 82486:       loadedAsData.AssignLiteral("data");
 82486:     } else {
 82486:       loadedAsData.AssignLiteral("normal");
 82486:     }
 53870:     PRUint32 nsid = tmp->GetDefaultNamespaceID();
 53870:     nsCAutoString uri;
 53870:     if (tmp->mDocumentURI)
 53870:       tmp->mDocumentURI->GetSpec(uri);
 80467:     if (nsid < ArrayLength(kNSURIs)) {
 82486:       PR_snprintf(name, sizeof(name), "nsDocument %s %s %s",
 82486:                   loadedAsData.get(), kNSURIs[nsid], uri.get());
 53870:     }
 53870:     else {
 82486:       PR_snprintf(name, sizeof(name), "nsDocument %s %s",
 82486:                   loadedAsData.get(), uri.get());
 53870:     }
 72420:     cb.DescribeRefCountedNode(tmp->mRefCnt.get(), sizeof(nsDocument), name);
 53870:   }
 53870:   else {
 72420:     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(nsDocument, tmp->mRefCnt.get())
 53870:   }
 53870: 
 30001:   // Always need to traverse script objects, so do that before we check
 30001:   // if we're uncollectable.
 30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 30001: 
 77323:   if (!nsINode::Traverse(tmp, cb)) {
 25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
  1353:   }
  1353: 
 15474:   tmp->mIdentifierMap.EnumerateEntries(IdentifierMapEntryTraverse, &cb);
 15474: 
 20078:   tmp->mExternalResourceMap.Traverse(&cb);
 20078: 
     1:   // Traverse the mChildren nsAttrAndChildArray.
     1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()); indx > 0; --indx) {
 13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
     1:     cb.NoteXPCOMChild(tmp->mChildren.ChildAt(indx - 1));
     1:   }
     1: 
     1:   // Traverse all nsIDocument pointer members.
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSecurityInfo)
 20078:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDisplayDocument)
     1: 
     1:   // Traverse all nsDocument nsCOMPtrs.
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParser)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptGlobalObject)
 72328:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mListenerManager,
 72328:                                                   nsEventListenerManager)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMStyleSheets)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptLoader)
     1: 
 20078:   tmp->mRadioGroups.EnumerateRead(RadioGroupsTraverser, &cb);
     1: 
     1:   // The boxobject for an element will only exist as long as it's in the
     1:   // document, so we'll traverse the table here instead of from the element.
     1:   if (tmp->mBoxObjectTable) {
     1:     tmp->mBoxObjectTable->EnumerateRead(BoxObjectTraverser, &cb);
     1:   }
     1: 
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
 36782:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mStyleAttrStyleSheet, nsIStyleSheet)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXPathEvaluatorTearoff)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLayoutHistoryState)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnloadBlocker)
 33055:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstBaseNodeWithHref)
 34007:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMImplementation)
 71030:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mImageMaps,
 71030:                                                        nsIDOMNodeList)
 38006:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOriginalDocument)
 46309:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCachedEncoder)
 69563:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStateObjectCached)
     1: 
     1:   // Traverse all our nsCOMArrays.
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mStyleSheets)
     1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mCatalogSheets)
 30065:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mPreloadingImages)
     1: 
 82857:   for (PRUint32 i = 0; i < tmp->mFrameRequestCallbacks.Length(); ++i) {
 82857:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mFrameRequestCallbacks[i]");
 82857:     cb.NoteXPCOMChild(tmp->mFrameRequestCallbacks[i]);
 52255:   }
 52255: 
 23697:   // Traverse animation components
 23697:   if (tmp->mAnimationController) {
 23697:     tmp->mAnimationController->Traverse(&cb);
 23697:   }
 23697: 
     1:   if (tmp->mSubDocuments && tmp->mSubDocuments->ops) {
     1:     PL_DHashTableEnumerate(tmp->mSubDocuments, SubDocTraverser, &cb);
     1:   }
     1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
     1: 
 30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsDocument)
 77323:   nsINode::Trace(tmp, aCallback, aClosure);
 30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 30001: 
 30001: 
     1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDocument)
 80486:   tmp->mInUnlinkOrDeletion = true;
 50721: 
 20078:   // Clear out our external resources
 20078:   tmp->mExternalResourceMap.Shutdown();
 20078: 
 14228:   nsAutoScriptBlocker scriptBlocker;
 14228: 
 77323:   nsINode::Unlink(tmp);
 77323: 
     1:   // Unlink the mChildren nsAttrAndChildArray.
     1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()) - 1; 
     1:        indx >= 0; --indx) {
     1:     tmp->mChildren.ChildAt(indx)->UnbindFromTree();
     1:     tmp->mChildren.RemoveChildAt(indx);
     1:   }
 42105:   tmp->mFirstChild = nsnull;
     1: 
 72852:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXPathEvaluatorTearoff)
 79452:   tmp->mCachedRootElement = nsnull; // Avoid a dangling pointer
 20078:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDisplayDocument)
 33055:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstBaseNodeWithHref)
 34007:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDOMImplementation)
 71030:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mImageMaps)
 38006:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOriginalDocument)
 46309:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCachedEncoder)
  8938: 
     1:   tmp->mParentDocument = nsnull;
     1: 
 30065:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mPreloadingImages)
 30065: 
 49019:   
 49019:   if (tmp->mBoxObjectTable) {
 49019:    tmp->mBoxObjectTable->EnumerateRead(ClearAllBoxObjects, nsnull);
 49019:    delete tmp->mBoxObjectTable;
 49019:    tmp->mBoxObjectTable = nsnull;
 49019:  }
 49019: 
 72852:   if (tmp->mListenerManager) {
 72852:     tmp->mListenerManager->Disconnect();
 91087:     tmp->UnsetFlags(NODE_HAS_LISTENERMANAGER);
 72852:     tmp->mListenerManager = nsnull;
 72852:   }
 72852: 
 72852:   if (tmp->mSubDocuments) {
 72852:     PL_DHashTableDestroy(tmp->mSubDocuments);
 72852:     tmp->mSubDocuments = nsnull;
 72852:   }
 72852: 
 82857:   tmp->mFrameRequestCallbacks.Clear();
 72852: 
 72852:   tmp->mRadioGroups.Clear();
 72852:   
     1:   // nsDocument has a pretty complex destructor, so we're going to
     1:   // assume that *most* cycles you actually want to break somewhere
     1:   // else, and not unlink an awful lot here.
 72852: 
 72852:   tmp->mIdentifierMap.Clear();
 50721: 
 74314:   if (tmp->mAnimationController) {
 74314:     tmp->mAnimationController->Unlink();
 74314:   }
 74314: 
 82231:   tmp->mPendingTitleChangeEvent.Revoke();
 82231:   
 80486:   tmp->mInUnlinkOrDeletion = false;
     1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
     1: 
     1: 
     1: nsresult
     1: nsDocument::Init()
     1: {
 94919:   if (mCSSLoader || mNodeInfoManager || mScriptLoader) {
     1:     return NS_ERROR_ALREADY_INITIALIZED;
     1:   }
     1: 
 15474:   mIdentifierMap.Init();
 98908:   mStyledLinks.Init();
  6365:   mRadioGroups.Init();
     1: 
     1:   // Force initialization.
     1:   nsINode::nsSlots* slots = GetSlots();
  8678:   NS_ENSURE_TRUE(slots,NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   // Prepend self as mutation-observer whether we need it or not (some
     1:   // subclasses currently do, other don't). This is because the code in
     1:   // nsNodeUtils always notifies the first observer first, expecting the
     1:   // first observer to be the document.
  9596:   NS_ENSURE_TRUE(slots->mMutationObservers.PrependElementUnlessExists(static_cast<nsIMutationObserver*>(this)),
     1:                  NS_ERROR_OUT_OF_MEMORY);
     1: 
     1: 
     1:   mOnloadBlocker = new nsOnloadBlocker();
     1:   NS_ENSURE_TRUE(mOnloadBlocker, NS_ERROR_OUT_OF_MEMORY);
     1: 
 38851:   mCSSLoader = new mozilla::css::Loader(this);
     1:   NS_ENSURE_TRUE(mCSSLoader, NS_ERROR_OUT_OF_MEMORY);
 38851:   NS_ADDREF(mCSSLoader);
 33262:   // Assume we're not quirky, until we know otherwise
     1:   mCSSLoader->SetCompatibilityMode(eCompatibility_FullStandards);
     1: 
 11169:   mNodeInfoManager = new nsNodeInfoManager();
 11169:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_OUT_OF_MEMORY);
 11169: 
 94919:   nsresult  rv = mNodeInfoManager->Init(this);
 11169:   NS_ENSURE_SUCCESS(rv, rv);
 11169: 
 74344:   // mNodeInfo keeps NodeInfoManager alive!
 11169:   mNodeInfo = mNodeInfoManager->GetDocumentNodeInfo();
 11169:   NS_ENSURE_TRUE(mNodeInfo, NS_ERROR_OUT_OF_MEMORY);
 71770:   NS_ABORT_IF_FALSE(mNodeInfo->NodeType() == nsIDOMNode::DOCUMENT_NODE,
 71770:                     "Bad NodeType in aNodeInfo");
 11169: 
 80526:   NS_ASSERTION(OwnerDoc() == this, "Our nodeinfo is busted!");
     1: 
  2007:   mScriptLoader = new nsScriptLoader(this);
  2007:   NS_ENSURE_TRUE(mScriptLoader, NS_ERROR_OUT_OF_MEMORY);
  2007: 
 98908:   mImageTracker.Init();
 98908:   mPlugins.Init();
 50815: 
     1:   return NS_OK;
     1: }
     1: 
 41182: void 
 41182: nsIDocument::DeleteAllProperties()
 41182: {
 41182:   for (PRUint32 i = 0; i < GetPropertyTableCount(); ++i) {
 41182:     PropertyTable(i)->DeleteAllProperties();
 41182:   }
 41182: }
 41182: 
 41182: void
 41182: nsIDocument::DeleteAllPropertiesFor(nsINode* aNode)
 41182: {
 41182:   for (PRUint32 i = 0; i < GetPropertyTableCount(); ++i) {
 41182:     PropertyTable(i)->DeleteAllPropertiesFor(aNode);
 41182:   }
 41182: }
 41182: 
 41182: nsPropertyTable*
 41182: nsIDocument::GetExtraPropertyTable(PRUint16 aCategory)
 41182: {
 41182:   NS_ASSERTION(aCategory > 0, "Category 0 should have already been handled");
 41702:   while (aCategory >= mExtraPropertyTables.Length() + 1) {
 41182:     mExtraPropertyTables.AppendElement(new nsPropertyTable());
 41182:   }
 41182:   return mExtraPropertyTables[aCategory - 1];
 41182: }
 41182: 
 72956: void
     1: nsDocument::AddXMLEventsContent(nsIContent *aXMLEventsElement)
     1: {
     1:   if (!mXMLEventsManager) {
     1:     mXMLEventsManager = new nsXMLEventsManager();
     1:     AddObserver(mXMLEventsManager);
     1:   }
     1:   mXMLEventsManager->AddXMLEventsContent(aXMLEventsElement);
     1: }
     1: 
     1: void
     1: nsDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
     1: {
     1:   nsCOMPtr<nsIURI> uri;
     1:   nsCOMPtr<nsIPrincipal> principal;
     1:   if (aChannel) {
     1:     // Note: this code is duplicated in nsXULDocument::StartDocumentLoad and
     1:     // nsScriptSecurityManager::GetChannelPrincipal.    
     1:     // Note: this should match nsDocShell::OnLoadingSite
  7109:     NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
     1: 
     1:     nsIScriptSecurityManager *securityManager =
     1:       nsContentUtils::GetSecurityManager();
     1:     if (securityManager) {
     1:       securityManager->GetChannelPrincipal(aChannel,
     1:                                            getter_AddRefs(principal));
     1:     }
     1:   }
     1: 
     1:   ResetToURI(uri, aLoadGroup, principal);
     1: 
 21811:   nsCOMPtr<nsIPropertyBag2> bag = do_QueryInterface(aChannel);
 21811:   if (bag) {
 21811:     nsCOMPtr<nsIURI> baseURI;
 21811:     bag->GetPropertyAsInterface(NS_LITERAL_STRING("baseURI"),
 21811:                                 NS_GET_IID(nsIURI), getter_AddRefs(baseURI));
 21811:     if (baseURI) {
 21811:       mDocumentBaseURI = baseURI;
 21811:     }
 21811:   }
 21811: 
     1:   mChannel = aChannel;
     1: }
     1: 
     1: void
     1: nsDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
     1:                        nsIPrincipal* aPrincipal)
     1: {
     1:   NS_PRECONDITION(aURI, "Null URI passed to ResetToURI");
     1: 
     1: #ifdef PR_LOGGING
     1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
     1:     nsCAutoString spec;
     1:     aURI->GetSpec(spec);
     1:     PR_LogPrint("DOCUMENT %p ResetToURI %s", this, spec.get());
     1:   }
     1: #endif
     1: 
     1:   mSecurityInfo = nsnull;
     1: 
     1:   mDocumentLoadGroup = nsnull;
     1: 
     1:   // Delete references to sub-documents and kill the subdocument map,
     1:   // if any. It holds strong references
     1:   if (mSubDocuments) {
     1:     PL_DHashTableDestroy(mSubDocuments);
     1: 
     1:     mSubDocuments = nsnull;
     1:   }
     1: 
     1:   // Destroy link map now so we don't waste time removing
     1:   // links one by one
 43079:   DestroyElementMaps();
     1: 
 79445:   bool oldVal = mInUnlinkOrDeletion;
 80486:   mInUnlinkOrDeletion = true;
     1:   PRUint32 count = mChildren.ChildCount();
 11681:   { // Scope for update
 80486:     MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_MODEL, true);    
     1:     for (PRInt32 i = PRInt32(count) - 1; i >= 0; i--) {
     1:       nsCOMPtr<nsIContent> content = mChildren.ChildAt(i);
     1: 
 48038:       nsIContent* previousSibling = content->GetPreviousSibling();
 48038: 
 42105:       if (nsINode::GetFirstChild() == content) {
 42105:         mFirstChild = content->GetNextSibling();
 42105:       }
 33055:       mChildren.RemoveChildAt(i);
 48038:       nsNodeUtils::ContentRemoved(this, content, i, previousSibling);
     1:       content->UnbindFromTree();
     1:     }
 11681:   }
 50721:   mInUnlinkOrDeletion = oldVal;
 41634:   mCachedRootElement = nsnull;
     1: 
     1:   // Reset our stylesheets
     1:   ResetStylesheetsToURI(aURI);
     1:   
     1:   // Release the listener manager
     1:   if (mListenerManager) {
     1:     mListenerManager->Disconnect();
     1:     mListenerManager = nsnull;
     1:   }
     1: 
     1:   // Release the stylesheets list.
     1:   mDOMStyleSheets = nsnull;
     1: 
 90437:   // Release our principal after tearing down the document, rather than before.
 90437:   // This ensures that, during teardown, the document and the dying window (which
 90437:   // already nulled out its document pointer and cached the principal) have
 90437:   // matching principals.
 90437:   SetPrincipal(nsnull);
 90437: 
 59194:   // Clear the original URI so SetDocumentURI sets it.
 59194:   mOriginalURI = nsnull;
 59194: 
     1:   SetDocumentURI(aURI);
 33055:   // If mDocumentBaseURI is null, nsIDocument::GetBaseURI() returns
 33055:   // mDocumentURI.
 33055:   mDocumentBaseURI = nsnull;
     1: 
     1:   if (aLoadGroup) {
     1:     mDocumentLoadGroup = do_GetWeakReference(aLoadGroup);
     1:     // there was an assertion here that aLoadGroup was not null.  This
 28078:     // is no longer valid: nsDocShell::SetDocument does not create a
 28078:     // load group, and it works just fine
 28078: 
 28078:     // XXXbz what does "just fine" mean exactly?  And given that there
 28078:     // is no nsDocShell::SetDocument, what is this talking about?
     1:   }
     1: 
     1:   mLastModified.Truncate();
     1:   // XXXbz I guess we're assuming that the caller will either pass in
     1:   // a channel with a useful type or call SetContentType?
 46309:   SetContentTypeInternal(EmptyCString());
     1:   mContentLanguage.Truncate();
     1:   mBaseTarget.Truncate();
     1:   mReferrer.Truncate();
     1: 
     1:   mXMLDeclarationBits = 0;
     1: 
     1:   // Now get our new principal
     1:   if (aPrincipal) {
     1:     SetPrincipal(aPrincipal);
     1:   } else {
     1:     nsIScriptSecurityManager *securityManager =
     1:       nsContentUtils::GetSecurityManager();
     1:     if (securityManager) {
     1:       nsCOMPtr<nsIPrincipal> principal;
     1:       nsresult rv =
     1:         securityManager->GetCodebasePrincipal(mDocumentURI,
     1:                                               getter_AddRefs(principal));
     1:       if (NS_SUCCEEDED(rv)) {
     1:         SetPrincipal(principal);
     1:       }
     1:     }
     1:   }
102067: 
102067:   // Refresh the principal on the compartment.
102067:   nsPIDOMWindow* win = GetInnerWindow();
102067:   if (win) {
102067:     win->RefreshCompartmentPrincipal();
102067:   }
     1: }
     1: 
     1: nsresult
     1: nsDocument::ResetStylesheetsToURI(nsIURI* aURI)
     1: {
     1:   NS_PRECONDITION(aURI, "Null URI passed to ResetStylesheetsToURI");
     1: 
 80486:   mozAutoDocUpdate upd(this, UPDATE_STYLE, true);
     1:   
     1:   // The stylesheets should forget us
     1:   PRInt32 indx = mStyleSheets.Count();
     1:   while (--indx >= 0) {
     1:     nsIStyleSheet* sheet = mStyleSheets[indx];
     1:     sheet->SetOwningDocument(nsnull);
     1: 
 42332:     if (sheet->IsApplicable()) {
     1:       RemoveStyleSheetFromStyleSets(sheet);
     1:     }
     1: 
     1:     // XXX Tell observers?
     1:   }
     1: 
     1:   indx = mCatalogSheets.Count();
     1:   while (--indx >= 0) {
     1:     nsIStyleSheet* sheet = mCatalogSheets[indx];
     1:     sheet->SetOwningDocument(nsnull);
     1: 
 42332:     if (sheet->IsApplicable()) {
 46225:       nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:       if (shell) {
  1722:         shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eAgentSheet, sheet);
     1:       }
     1:     }
     1: 
     1:     // XXX Tell observers?
     1:   }
     1: 
     1: 
     1:   // Release all the sheets
     1:   mStyleSheets.Clear();
     1:   // NOTE:  We don't release the catalog sheets.  It doesn't really matter
     1:   // now, but it could in the future -- in which case not releasing them
     1:   // is probably the right thing to do.
     1: 
     1:   // Now reset our inline style and attribute sheets.
 42399:   nsresult rv = NS_OK;
     1:   if (mAttrStyleSheet) {
     1:     // Remove this sheet from all style sets
 46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:     if (shell) {
 60634:       shell->StyleSet()->RemoveStyleSheet(nsStyleSet::ePresHintSheet,
 60633:                                           mAttrStyleSheet);
     1:     }
 42399:     mAttrStyleSheet->Reset(aURI);
     1:   } else {
 93754:     rv = NS_NewHTMLStyleSheet(&mAttrStyleSheet, aURI, this);
 93754:     if (NS_FAILED(rv)) {
 93754:       NS_IF_RELEASE(mAttrStyleSheet);
     1:       NS_ENSURE_SUCCESS(rv, rv);
 42399:     }
 93754:   }
     1: 
     1:   // Don't use AddStyleSheet, since it'll put the sheet into style
     1:   // sets in the document level, which is not desirable here.
     1:   mAttrStyleSheet->SetOwningDocument(this);
     1:   
     1:   if (mStyleAttrStyleSheet) {
     1:     // Remove this sheet from all style sets
 46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:     if (shell) {
  1722:       shell->StyleSet()->
     1:         RemoveStyleSheet(nsStyleSet::eStyleAttrSheet, mStyleAttrStyleSheet);
     1:     }
 42399:     mStyleAttrStyleSheet->Reset(aURI);
     1:   } else {
 36782:     mStyleAttrStyleSheet = new nsHTMLCSSStyleSheet();
 36782:     NS_ENSURE_TRUE(mStyleAttrStyleSheet, NS_ERROR_OUT_OF_MEMORY);
 36782:     rv = mStyleAttrStyleSheet->Init(aURI, this);
     1:     NS_ENSURE_SUCCESS(rv, rv);
 42399:   }
     1: 
     1:   // The loop over style sets below will handle putting this sheet
     1:   // into style sets as needed.
     1:   mStyleAttrStyleSheet->SetOwningDocument(this);
     1: 
     1:   // Now set up our style sets
 46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:   if (shell) {
  1722:     FillStyleSet(shell->StyleSet());
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: void
     1: nsDocument::FillStyleSet(nsStyleSet* aStyleSet)
     1: {
     1:   NS_PRECONDITION(aStyleSet, "Must have a style set");
 60634:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::ePresHintSheet) == 0,
 60634:                   "Style set already has a preshint sheet?");
     1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eDocSheet) == 0,
     1:                   "Style set already has document sheets?");
     1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eStyleAttrSheet) == 0,
     1:                   "Style set already has style attr sheets?");
     1:   NS_PRECONDITION(mStyleAttrStyleSheet, "No style attr stylesheet?");
     1:   NS_PRECONDITION(mAttrStyleSheet, "No attr stylesheet?");
     1:   
 60634:   aStyleSet->AppendStyleSheet(nsStyleSet::ePresHintSheet, mAttrStyleSheet);
     1: 
     1:   aStyleSet->AppendStyleSheet(nsStyleSet::eStyleAttrSheet,
     1:                               mStyleAttrStyleSheet);
     1: 
     1:   PRInt32 i;
     1:   for (i = mStyleSheets.Count() - 1; i >= 0; --i) {
     1:     nsIStyleSheet* sheet = mStyleSheets[i];
 42332:     if (sheet->IsApplicable()) {
     1:       aStyleSet->AddDocStyleSheet(sheet, this);
     1:     }
     1:   }
     1: 
     1:   for (i = mCatalogSheets.Count() - 1; i >= 0; --i) {
     1:     nsIStyleSheet* sheet = mCatalogSheets[i];
 42332:     if (sheet->IsApplicable()) {
     1:       aStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
     1:     }
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsDocument::StartDocumentLoad(const char* aCommand, nsIChannel* aChannel,
     1:                               nsILoadGroup* aLoadGroup,
     1:                               nsISupports* aContainer,
     1:                               nsIStreamListener **aDocListener,
 79445:                               bool aReset, nsIContentSink* aSink)
     1: {
     1: #ifdef PR_LOGGING
     1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
     1:     nsCOMPtr<nsIURI> uri;
     1:     aChannel->GetURI(getter_AddRefs(uri));
     1:     nsCAutoString spec;
     1:     if (uri)
     1:       uri->GetSpec(spec);
     1:     PR_LogPrint("DOCUMENT %p StartDocumentLoad %s", this, spec.get());
     1:   }
     1: #endif
     1: 
 95570:   MOZ_ASSERT(GetReadyStateEnum() == nsIDocument::READYSTATE_UNINITIALIZED,
 95570:              "Bad readyState");
 23639:   SetReadyStateInternal(READYSTATE_LOADING);
 23639: 
  4064:   if (nsCRT::strcmp(kLoadAsData, aCommand) == 0) {
 80486:     mLoadedAsData = true;
  4064:     // We need to disable script & style loading in this case.
  4064:     // We leave them disabled even in EndLoad(), and let anyone
  4064:     // who puts the document on display to worry about enabling.
  4064: 
  4064:     // Do not load/process scripts when loading as data
 80486:     ScriptLoader()->SetEnabled(false);
  4064: 
  4064:     // styles
 80486:     CSSLoader()->SetEnabled(false); // Do not load/process styles when loading as data
 20078:   } else if (nsCRT::strcmp("external-resource", aCommand) == 0) {
 20078:     // Allow CSS, but not scripts
 80486:     ScriptLoader()->SetEnabled(false);
 80486:   }
 80486: 
 80486:   mMayStartLayout = false;
 80486: 
 80486:   mHaveInputEncoding = true;
 16447: 
     1:   if (aReset) {
     1:     Reset(aChannel, aLoadGroup);
     1:   }
     1: 
     1:   nsCAutoString contentType;
     1:   if (NS_SUCCEEDED(aChannel->GetContentType(contentType))) {
     1:     // XXX this is only necessary for viewsource:
     1:     nsACString::const_iterator start, end, semicolon;
     1:     contentType.BeginReading(start);
     1:     contentType.EndReading(end);
     1:     semicolon = start;
     1:     FindCharInReadable(';', semicolon, end);
 46309:     SetContentTypeInternal(Substring(start, semicolon));
     1:   }
     1: 
     1:   RetrieveRelevantHeaders(aChannel);
     1: 
     1:   mChannel = aChannel;
     1: 
 55818:   nsresult rv = InitCSP();
 37418:   NS_ENSURE_SUCCESS(rv, rv);
 37418: 
 37418:   return NS_OK;
 37418: }
 37418: 
 37418: nsresult
 37418: nsDocument::InitCSP()
 37418: {
 47342:   if (CSPService::sCSPEnabled) {
 37418:     nsAutoString cspHeaderValue;
 37418:     nsAutoString cspROHeaderValue;
 37418: 
 37418:     this->GetHeaderData(nsGkAtoms::headerCSP, cspHeaderValue);
 37418:     this->GetHeaderData(nsGkAtoms::headerCSPReportOnly, cspROHeaderValue);
 37418: 
 79445:     bool system = false;
 37418:     nsIScriptSecurityManager *ssm = nsContentUtils::GetSecurityManager();
 37418: 
 37418:     if (NS_SUCCEEDED(ssm->IsSystemPrincipal(NodePrincipal(), &system)) && system) {
 37418:       // only makes sense to register new CSP if this document is not priviliged
 37418:       return NS_OK;
 37418:     }
 37418: 
 37418:     if (cspHeaderValue.IsEmpty() && cspROHeaderValue.IsEmpty()) {
 37418:       // no CSP header present, stop processing
 37418:       return NS_OK;
 37418:     }
 37418: 
 37418: #ifdef PR_LOGGING 
 37418:     PR_LOG(gCspPRLog, PR_LOG_DEBUG, ("CSP header specified for document %p", this));
 37418: #endif
 37418: 
 37418:     nsresult rv;
 37418:     nsCOMPtr<nsIContentSecurityPolicy> mCSP;
 37418:     mCSP = do_CreateInstance("@mozilla.org/contentsecuritypolicy;1", &rv);
 37418: 
 37418:     if (NS_FAILED(rv)) {
 37418: #ifdef PR_LOGGING 
 37418:       PR_LOG(gCspPRLog, PR_LOG_DEBUG, ("Failed to create CSP object: %x", rv));
 37418: #endif
 37418:       return rv;
 37418:     }
 37418: 
 37418:     // Store the request context for violation reports
 37418:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel);
 37418:     mCSP->ScanRequestData(httpChannel);
 37418: 
 37418:     // Start parsing the policy
 37418:     nsCOMPtr<nsIURI> chanURI;
 37418:     mChannel->GetURI(getter_AddRefs(chanURI));
 37418: 
 37418: #ifdef PR_LOGGING 
 37418:     PR_LOG(gCspPRLog, PR_LOG_DEBUG, ("CSP Loaded"));
 37418: #endif
 37418: 
 47165:     // ReportOnly mode is enabled *only* if there are no regular-strength CSP
 47165:     // headers present.  If there are, then we ignore the ReportOnly mode and
 47165:     // toss a warning into the error console, proceeding with enforcing the
 47165:     // regular-strength CSP.
 47165:     if (cspHeaderValue.IsEmpty()) {
 47165:       mCSP->SetReportOnlyMode(true);
 89354: 
 89354:       // Need to tokenize the header value since multiple headers could be
 89354:       // concatenated into one comma-separated list of policies.
 89354:       // See RFC2616 section 4.2 (last paragraph)
 89354:       nsCharSeparatedTokenizer tokenizer(cspROHeaderValue, ',');
 89354:       while (tokenizer.hasMoreTokens()) {
 89354:         const nsSubstring& policy = tokenizer.nextToken();
 89354:         mCSP->RefinePolicy(policy, chanURI);
 37418: #ifdef PR_LOGGING
 37418:         {
 37418:           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
 89354:                   ("CSP (report only) refined with policy: \"%s\"",
 89354:                     NS_ConvertUTF16toUTF8(policy).get()));
 47165:         }
 47165: #endif
 89354:       }
 47165:     } else {
 47165:       //XXX(sstamm): maybe we should post a warning when both read only and regular 
 47165:       // CSP headers are present.
 89354: 
 89354:       // Need to tokenize the header value since multiple headers could be
 89354:       // concatenated into one comma-separated list of policies.
 89354:       // See RFC2616 section 4.2 (last paragraph)
 89354:       nsCharSeparatedTokenizer tokenizer(cspHeaderValue, ',');
 89354:       while (tokenizer.hasMoreTokens()) {
 89354:         const nsSubstring& policy = tokenizer.nextToken();
 89354:         mCSP->RefinePolicy(policy, chanURI);
 47165: #ifdef PR_LOGGING
 47165:         {
 47165:           PR_LOG(gCspPRLog, PR_LOG_DEBUG,
 89354:                 ("CSP refined with policy: \"%s\"",
 89354:                   NS_ConvertUTF16toUTF8(policy).get()));
 47162:         }
 47162: #endif
 47162:       }
 89354:     }
 37418: 
 37926:     // Check for frame-ancestor violation
 37926:     nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
 37926:     if (docShell) {
 79445:         bool safeAncestry = false;
 37926: 
 37926:         // PermitsAncestry sends violation reports when necessary
 37926:         rv = mCSP->PermitsAncestry(docShell, &safeAncestry);
 37926:         NS_ENSURE_SUCCESS(rv, rv);
 37926: 
 37926:         if (!safeAncestry) {
 37926: #ifdef PR_LOGGING
 37926:             PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
 37926:                    ("CSP doesn't like frame's ancestry, not loading."));
 37926: #endif
 37926:             // stop!  ERROR page!
 37926:             mChannel->Cancel(NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION);
 37926:         }
 37926:     }
 37926: 
 37418:     //Copy into principal
 37418:     nsIPrincipal* principal = GetPrincipal();
 37418: 
 37418:     if (principal) {
 37418:         principal->SetCsp(mCSP);
 37418: #ifdef PR_LOGGING
 37418:         PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
 37418:                 ("Inserted CSP into principal %p", principal));
 37418:     }
 37418:     else {
 37418:       PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
 37418:               ("Couldn't copy CSP into absent principal %p", principal));
 37418: #endif
 37418:     }
 37418:   }
 37418: #ifdef PR_LOGGING
 37418:   else { //CSP was not enabled!
 37418:     PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
 37418:            ("CSP is disabled, skipping CSP init for document %p", this));
 37418:   }
 37418: #endif
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsDocument::StopDocumentLoad()
     1: {
     1:   if (mParser) {
 94237:     mParserAborted = true;
     1:     mParser->Terminate();
     1:   }
     1: }
     1: 
     1: void
     1: nsDocument::SetDocumentURI(nsIURI* aURI)
     1: {
 41900:   nsCOMPtr<nsIURI> oldBase = GetDocBaseURI();
     1:   mDocumentURI = NS_TryToMakeImmutable(aURI);
 41900:   nsIURI* newBase = GetDocBaseURI();
 33055: 
 79445:   bool equalBases = false;
 33055:   if (oldBase && newBase) {
 33055:     oldBase->Equals(newBase, &equalBases);
 33055:   }
 33055:   else {
 33055:     equalBases = !oldBase && !newBase;
 33055:   }
 33055: 
 59194:   // If this is the first time we're setting the document's URI, set the
 59194:   // document's original URI.
 59194:   if (!mOriginalURI)
 59194:     mOriginalURI = mDocumentURI;
 59194: 
 33055:   // If changing the document's URI changed the base URI of the document, we
 33055:   // need to refresh the hrefs of all the links on the page.
 33055:   if (!equalBases) {
 33055:     RefreshLinkHrefs();
 33055:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetLastModified(nsAString& aLastModified)
     1: {
     1:   if (!mLastModified.IsEmpty()) {
     1:     aLastModified.Assign(mLastModified);
     1:   } else {
     1:     // If we for whatever reason failed to find the last modified time
     1:     // (or even the current time), fall back to what NS4.x returned.
     1:     aLastModified.Assign(NS_LITERAL_STRING("01/01/1970 00:00:00"));
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 15474: void
 43079: nsDocument::AddToNameTable(Element *aElement, nsIAtom* aName)
 15474: {
 43946:   nsIdentifierMapEntry *entry =
 68823:     mIdentifierMap.PutEntry(nsDependentAtomString(aName));
 68823: 
 68823:   // Null for out-of-memory
 43079:   if (entry) {
 69024:     entry->AddNameElement(this, aElement);
 43079:   }
 43079: }
 43079: 
 43079: void
 43079: nsDocument::RemoveFromNameTable(Element *aElement, nsIAtom* aName)
 43079: {
 43079:   // Speed up document teardown
 68823:   if (mIdentifierMap.Count() == 0)
 15474:     return;
 15474: 
 43946:   nsIdentifierMapEntry *entry =
 43946:     mIdentifierMap.GetEntry(nsDependentAtomString(aName));
 78485:   if (!entry) // Could be false if the element was anonymous, hence never added
 15474:     return;
 43079: 
 43079:   entry->RemoveNameElement(aElement);
 15474: }
 15474: 
 15474: void
 43079: nsDocument::AddToIdTable(Element *aElement, nsIAtom* aId)
 43079: {
 43946:   nsIdentifierMapEntry *entry =
 43946:     mIdentifierMap.PutEntry(nsDependentAtomString(aId));
 26475: 
 26475:   if (entry) { /* True except on OOM */
 41635:     entry->AddIdElement(aElement);
 15474:   }
 15474: }
 15474: 
 15474: void
 43079: nsDocument::RemoveFromIdTable(Element *aElement, nsIAtom* aId)
 43079: {
 43079:   NS_ASSERTION(aId, "huhwhatnow?");
 43079: 
 43079:   // Speed up document teardown
 43079:   if (mIdentifierMap.Count() == 0) {
 15474:     return;
 43079:   }
 43079: 
 43946:   nsIdentifierMapEntry *entry =
 43946:     mIdentifierMap.GetEntry(nsDependentAtomString(aId));
 43079:   if (!entry) // Can be null for XML elements with changing ids.
 15474:     return;
 15474: 
 50428:   entry->RemoveIdElement(aElement);
 50428:   if (entry->IsEmpty()) {
 43946:     mIdentifierMap.RawRemoveEntry(entry);
 15474:   }
 15474: }
 15474: 
     1: nsIPrincipal*
     1: nsDocument::GetPrincipal()
     1: {
     1:   return NodePrincipal();
     1: }
     1: 
 79445: extern bool sDisablePrefetchHTTPSPref;
 28460: 
     1: void
     1: nsDocument::SetPrincipal(nsIPrincipal *aNewPrincipal)
     1: {
 28460:   if (aNewPrincipal && mAllowDNSPrefetch && sDisablePrefetchHTTPSPref) {
 28460:     nsCOMPtr<nsIURI> uri;
 28460:     aNewPrincipal->GetURI(getter_AddRefs(uri));
 79445:     bool isHTTPS;
 28460:     if (!uri || NS_FAILED(uri->SchemeIs("https", &isHTTPS)) ||
 28460:         isHTTPS) {
 80486:       mAllowDNSPrefetch = false;
 28460:     }
 28460:   }
     1:   mNodeInfoManager->SetDocumentPrincipal(aNewPrincipal);
     1: }
     1: 
     1: NS_IMETHODIMP
 18430: nsDocument::GetApplicationCache(nsIApplicationCache **aApplicationCache)
 18430: {
 18430:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
 18430: 
 18430:   return NS_OK;
 18430: }
 18430: 
 18430: NS_IMETHODIMP
 18430: nsDocument::SetApplicationCache(nsIApplicationCache *aApplicationCache)
 18430: {
 18430:   mApplicationCache = aApplicationCache;
 18430: 
 18430:   return NS_OK;
 18430: }
 18430: 
 18430: NS_IMETHODIMP
     1: nsDocument::GetContentType(nsAString& aContentType)
     1: {
 46309:   CopyUTF8toUTF16(GetContentTypeInternal(), aContentType);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsDocument::SetContentType(const nsAString& aContentType)
     1: {
 46309:   NS_ASSERTION(GetContentTypeInternal().IsEmpty() ||
 46309:                GetContentTypeInternal().Equals(NS_ConvertUTF16toUTF8(aContentType)),
     1:                "Do you really want to change the content-type?");
     1: 
 46309:   SetContentTypeInternal(NS_ConvertUTF16toUTF8(aContentType));
     1: }
     1: 
     1: /* Return true if the document is in the focused top-level window, and is an
     1:  * ancestor of the focused DOMWindow. */
     1: NS_IMETHODIMP
 79445: nsDocument::HasFocus(bool* aResult)
     1: {
 80486:   *aResult = false;
     1: 
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (!fm)
 29018:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   // Is there a focused DOMWindow?
 29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
 29018:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
 29018:   if (!focusedWindow)
 29018:     return NS_OK;
     1: 
     1:   // Are we an ancestor of the focused DOMWindow?
     1:   nsCOMPtr<nsIDOMDocument> domDocument;
     1:   focusedWindow->GetDocument(getter_AddRefs(domDocument));
     1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
     1: 
     1:   for (nsIDocument* currentDoc = document; currentDoc;
     1:        currentDoc = currentDoc->GetParentDocument()) {
     1:     if (currentDoc == this) {
     1:       // Yes, we are an ancestor
 80486:       *aResult = true;
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetReferrer(nsAString& aReferrer)
     1: {
     1:   CopyUTF8toUTF16(mReferrer, aReferrer);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetActiveElement(nsIDOMElement **aElement)
     1: {
     1:   *aElement = nsnull;
     1: 
     1:   // Get the focused element.
 29018:   nsCOMPtr<nsPIDOMWindow> window = GetWindow();
 69718:   if (window) {
 29018:     nsCOMPtr<nsPIDOMWindow> focusedWindow;
 29018:     nsIContent* focusedContent =
 80486:       nsFocusManager::GetFocusedDescendant(window, false,
 69718:                                            getter_AddRefs(focusedWindow));
 29018:     // be safe and make sure the element is from this document
 80526:     if (focusedContent && focusedContent->OwnerDoc() == this) {
 97636:       if (focusedContent->IsInNativeAnonymousSubtree()) {
 97636:         focusedContent = focusedContent->FindFirstNonNativeAnonymous();
 97636:       }
 97636:       if (focusedContent) {
 29018:         CallQueryInterface(focusedContent, aElement);
 29018:         return NS_OK;
     1:       }
 69718:     }
 97636:   }
     1: 
     1:   // No focused element anywhere in this document.  Try to get the BODY.
 77547:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryObject(this);
     1:   if (htmlDoc) {
     1:     nsCOMPtr<nsIDOMHTMLElement> bodyElement;
     1:     htmlDoc->GetBody(getter_AddRefs(bodyElement));
     1:     if (bodyElement) {
     1:       *aElement = bodyElement;
     1:       NS_ADDREF(*aElement);
  7851:     }
  7851:     // Because of IE compatibility, return null when html document doesn't have
  7851:     // a body.
     1:     return NS_OK;
     1:   }
     1: 
     1:   // If we couldn't get a BODY, return the root element.
     1:   return GetDocumentElement(aElement);
     1: }
     1: 
     1: NS_IMETHODIMP
 54146: nsDocument::GetCurrentScript(nsIDOMElement **aElement)
 54146: {
 54146:   nsIScriptElement* script = mScriptLoader->GetCurrentScript();
 54146:   if (script) {
 54146:     return CallQueryInterface(script, aElement);
 54146:   }
 54146:   
 54146:   *aElement = nsnull;
 54146: 
 54146:   return NS_OK;
 54146: }
 54146: 
 54146: NS_IMETHODIMP
 40200: nsDocument::ElementFromPoint(float aX, float aY, nsIDOMElement** aReturn)
  5440: {
 80486:   return ElementFromPointHelper(aX, aY, false, true, aReturn);
 21333: }
 21333: 
 21333: nsresult
 40200: nsDocument::ElementFromPointHelper(float aX, float aY,
 79445:                                    bool aIgnoreRootScrollFrame,
 79445:                                    bool aFlushLayout,
 21333:                                    nsIDOMElement** aReturn)
 21333: {
  5440:   NS_ENSURE_ARG_POINTER(aReturn);
  5440:   *aReturn = nsnull;
  5440:   // As per the the spec, we return null if either coord is negative
 31237:   if (!aIgnoreRootScrollFrame && (aX < 0 || aY < 0))
  5440:     return NS_OK;
  5440: 
  5440:   nscoord x = nsPresContext::CSSPixelsToAppUnits(aX);
  5440:   nscoord y = nsPresContext::CSSPixelsToAppUnits(aY);
  5440:   nsPoint pt(x, y);
  5440: 
  5440:   // Make sure the layout information we get is up-to-date, and
  5440:   // ensure we get a root frame (for everything but XUL)
 21333:   if (aFlushLayout)
  5440:     FlushPendingNotifications(Flush_Layout);
  5440: 
 46225:   nsIPresShell *ps = GetShell();
  5440:   NS_ENSURE_STATE(ps);
  5440:   nsIFrame *rootFrame = ps->GetRootFrame();
  5440: 
  5440:   // XUL docs, unlike HTML, have no frame tree until everything's done loading
  5440:   if (!rootFrame)
  5440:     return NS_OK; // return null to premature XUL callers as a reminder to wait
  5440: 
 80486:   nsIFrame *ptFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, pt, true,
 21333:                                                       aIgnoreRootScrollFrame);
  5440:   if (!ptFrame)
  5440:     return NS_OK;
  5440: 
101616:   nsIContent* elem = GetContentInThisDocument(ptFrame);
101616:   if (elem && !elem->IsElement()) {
101616:     elem = elem->GetParent();
101616:   }
102510:   if (elem) {
102510:     CallQueryInterface(elem, aReturn);
102510:   }
102510:   return NS_OK;
  5440: }
  5440: 
 40568: nsresult
 40568: nsDocument::NodesFromRectHelper(float aX, float aY,
 40568:                                 float aTopSize, float aRightSize,
 40568:                                 float aBottomSize, float aLeftSize,
 79445:                                 bool aIgnoreRootScrollFrame,
 79445:                                 bool aFlushLayout,
 40568:                                 nsIDOMNodeList** aReturn)
 40568: {
 40568:   NS_ENSURE_ARG_POINTER(aReturn);
 40568:   
 69024:   nsSimpleContentList* elements = new nsSimpleContentList(this);
 40568:   NS_ADDREF(elements);
 40568:   *aReturn = elements;
 40568: 
 40568:   // Following the same behavior of elementFromPoint,
 40568:   // we don't return anything if either coord is negative
 40568:   if (!aIgnoreRootScrollFrame && (aX < 0 || aY < 0))
 40568:     return NS_OK;
 40568: 
 40568:   nscoord x = nsPresContext::CSSPixelsToAppUnits(aX - aLeftSize);
 40568:   nscoord y = nsPresContext::CSSPixelsToAppUnits(aY - aTopSize);
 40568:   nscoord w = nsPresContext::CSSPixelsToAppUnits(aLeftSize + aRightSize) + 1;
 40568:   nscoord h = nsPresContext::CSSPixelsToAppUnits(aTopSize + aBottomSize) + 1;
 40568: 
 40568:   nsRect rect(x, y, w, h);
 40568: 
 40568:   // Make sure the layout information we get is up-to-date, and
 40568:   // ensure we get a root frame (for everything but XUL)
 40568:   if (aFlushLayout) {
 40568:     FlushPendingNotifications(Flush_Layout);
 40568:   }
 40568: 
 46225:   nsIPresShell *ps = GetShell();
 40568:   NS_ENSURE_STATE(ps);
 40568:   nsIFrame *rootFrame = ps->GetRootFrame();
 40568: 
 40568:   // XUL docs, unlike HTML, have no frame tree until everything's done loading
 40568:   if (!rootFrame)
 40568:     return NS_OK; // return nothing to premature XUL callers as a reminder to wait
 40568: 
 78095:   nsAutoTArray<nsIFrame*,8> outFrames;
 40568:   nsLayoutUtils::GetFramesForArea(rootFrame, rect, outFrames,
 80486:                                   true, aIgnoreRootScrollFrame);
 40568: 
 40568:   // Used to filter out repeated elements in sequence.
 40568:   nsIContent* lastAdded = nsnull;
 40568: 
102510:   for (PRUint32 i = 0; i < outFrames.Length(); i++) {
101616:     nsIContent* node = GetContentInThisDocument(outFrames[i]);
101616: 
101616:     if (node && !node->IsElement() && !node->IsNodeOfType(nsINode::eTEXT)) {
102510:       // We have a node that isn't an element or a text node,
102510:       // use its parent content instead.
101616:       node = node->GetParent();
101616:     }
101616:     if (node && node != lastAdded) {
101616:       elements->AppendElement(node);
101616:       lastAdded = node;
101616:     }
101616:   }
101616: 
 40568:   return NS_OK;
 40568: }
 40568: 
  5440: NS_IMETHODIMP
     1: nsDocument::GetElementsByClassName(const nsAString& aClasses,
     1:                                    nsIDOMNodeList** aReturn)
     1: {
 41910:   return nsContentUtils::GetElementsByClassName(this, aClasses, aReturn);
     1: }
     1: 
 32435: NS_IMETHODIMP
 32435: nsDocument::ReleaseCapture()
 32435: {
 32435:   // only release the capture if the caller can access it. This prevents a
 32435:   // page from stopping a scrollbar grab for example.
 32435:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(nsIPresShell::GetCapturingContent());
 32435:   if (node && nsContentUtils::CanCallerAccess(node)) {
 32435:     nsIPresShell::SetCapturingContent(nsnull, 0);
 32435:   }
 32435:   return NS_OK;
 32435: }
 32435: 
     1: nsresult
     1: nsDocument::SetBaseURI(nsIURI* aURI)
     1: {
 41221:   if (!aURI && !mDocumentBaseURI) {
 41221:     return NS_OK;
 41221:   }
 41221:   
 41221:   // Don't do anything if the URI wasn't actually changed.
 41221:   if (aURI && mDocumentBaseURI) {
 79445:     bool equalBases = false;
 41221:     mDocumentBaseURI->Equals(aURI, &equalBases);
 41221:     if (equalBases) {
 41221:       return NS_OK;
 41221:     }
 41221:   }
 41221: 
     1:   if (aURI) {
     1:     mDocumentBaseURI = NS_TryToMakeImmutable(aURI);
     1:   } else {
     1:     mDocumentBaseURI = nsnull;
     1:   }
 33055:   RefreshLinkHrefs();
 41221: 
 41221:   return NS_OK;
     1: }
     1: 
     1: void
 41221: nsDocument::GetBaseTarget(nsAString &aBaseTarget)
 41221: {
 60507:   aBaseTarget = mBaseTarget;
     1: }
     1: 
     1: void
     1: nsDocument::SetDocumentCharacterSet(const nsACString& aCharSetID)
     1: {
     1:   if (!mCharacterSet.Equals(aCharSetID)) {
     1:     mCharacterSet = aCharSetID;
     1: 
     1: #ifdef DEBUG
     1:     nsCAutoString canonicalName;
 91519:     nsCharsetAlias::GetPreferred(aCharSetID, canonicalName);
     1:     NS_ASSERTION(canonicalName.Equals(aCharSetID),
     1:                  "charset name must be canonical");
     1: #endif
     1: 
 26413:     PRInt32 n = mCharSetObservers.Length();
     1: 
     1:     for (PRInt32 i = 0; i < n; i++) {
 26413:       nsIObserver* observer = mCharSetObservers.ElementAt(i);
  3233: 
  3233:       observer->Observe(static_cast<nsIDocument *>(this), "charset",
     1:                         NS_ConvertASCIItoUTF16(aCharSetID).get());
     1:     }
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsDocument::AddCharSetObserver(nsIObserver* aObserver)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aObserver);
     1: 
     1:   NS_ENSURE_TRUE(mCharSetObservers.AppendElement(aObserver), NS_ERROR_FAILURE);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsDocument::RemoveCharSetObserver(nsIObserver* aObserver)
     1: {
     1:   mCharSetObservers.RemoveElement(aObserver);
     1: }
     1: 
     1: void
     1: nsDocument::GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const
     1: {
     1:   aData.Truncate();
     1:   const nsDocHeaderData* data = mHeaderData;
     1:   while (data) {
     1:     if (data->mField == aHeaderField) {
     1:       aData = data->mData;
     1: 
     1:       break;
     1:     }
     1:     data = data->mNext;
     1:   }
     1: }
     1: 
     1: void
     1: nsDocument::SetHeaderData(nsIAtom* aHeaderField, const nsAString& aData)
     1: {
     1:   if (!aHeaderField) {
     1:     NS_ERROR("null headerField");
     1:     return;
     1:   }
     1: 
     1:   if (!mHeaderData) {
     1:     if (!aData.IsEmpty()) { // don't bother storing empty string
     1:       mHeaderData = new nsDocHeaderData(aHeaderField, aData);
     1:     }
     1:   }
     1:   else {
     1:     nsDocHeaderData* data = mHeaderData;
     1:     nsDocHeaderData** lastPtr = &mHeaderData;
 79445:     bool found = false;
     1:     do {  // look for existing and replace
     1:       if (data->mField == aHeaderField) {
     1:         if (!aData.IsEmpty()) {
     1:           data->mData.Assign(aData);
     1:         }
     1:         else {  // don't store empty string
     1:           *lastPtr = data->mNext;
     1:           data->mNext = nsnull;
     1:           delete data;
     1:         }
 80486:         found = true;
     1: 
     1:         break;
     1:       }
     1:       lastPtr = &(data->mNext);
     1:       data = *lastPtr;
     1:     } while (data);
     1: 
     1:     if (!aData.IsEmpty() && !found) {
     1:       // didn't find, append
     1:       *lastPtr = new nsDocHeaderData(aHeaderField, aData);
     1:     }
     1:   }
     1: 
     1:   if (aHeaderField == nsGkAtoms::headerContentLanguage) {
     1:     CopyUTF16toUTF8(aData, mContentLanguage);
     1:   }
     1: 
     1:   if (aHeaderField == nsGkAtoms::headerDefaultStyle) {
     1:     // Only mess with our stylesheets if we don't have a lastStyleSheetSet, per
     1:     // spec.
     1:     if (DOMStringIsNull(mLastStyleSheetSet)) {
     1:       // Calling EnableStyleSheetsForSetInternal, not SetSelectedStyleSheetSet,
     1:       // per spec.  The idea here is that we're changing our preferred set and
     1:       // that shouldn't change the value of lastStyleSheetSet.  Also, we're
     1:       // using the Internal version so we can update the CSSLoader and not have
     1:       // to worry about null strings.
 80486:       EnableStyleSheetsForSetInternal(aData, true);
     1:     }
     1:   }
     1: 
     1:   if (aHeaderField == nsGkAtoms::refresh) {
     1:     // We get into this code before we have a script global yet, so get to
     1:     // our container via mDocumentContainer.
     1:     nsCOMPtr<nsIRefreshURI> refresher = do_QueryReferent(mDocumentContainer);
     1:     if (refresher) {
     1:       // Note: using mDocumentURI instead of mBaseURI here, for consistency
     1:       // (used to just use the current URI of our webnavigation, but that
     1:       // should really be the same thing).  Note that this code can run
     1:       // before the current URI of the webnavigation has been updated, so we
     1:       // can't assert equality here.
     1:       refresher->SetupRefreshURIFromHeader(mDocumentURI,
  6396:                                            NS_ConvertUTF16toUTF8(aData));
     1:     }
     1:   }
 28460: 
 28460:   if (aHeaderField == nsGkAtoms::headerDNSPrefetchControl &&
 28460:       mAllowDNSPrefetch) {
 28460:     // Chromium treats any value other than 'on' (case insensitive) as 'off'.
 28460:     mAllowDNSPrefetch = aData.IsEmpty() || aData.LowerCaseEqualsLiteral("on");
 28460:   }
     1: }
     1: 
 79445: bool
     1: nsDocument::TryChannelCharset(nsIChannel *aChannel,
     1:                               PRInt32& aCharsetSource,
 94004:                               nsACString& aCharset,
 94004:                               nsHtml5TreeOpExecutor* aExecutor)
     1: {
     1:   if(kCharsetFromChannel <= aCharsetSource) {
 80486:     return true;
     1:   }
     1: 
     1:   if (aChannel) {
     1:     nsCAutoString charsetVal;
     1:     nsresult rv = aChannel->GetContentCharset(charsetVal);
     1:     if (NS_SUCCEEDED(rv)) {
 94743:       nsCAutoString preferred;
 94743:       rv = nsCharsetAlias::GetPreferred(charsetVal, preferred);
     1:       if(NS_SUCCEEDED(rv)) {
 94743:         aCharset = preferred;
     1:         aCharsetSource = kCharsetFromChannel;
 80486:         return true;
 94004:       } else if (aExecutor && !charsetVal.IsEmpty()) {
 94004:         aExecutor->ComplainAboutBogusProtocolCharset(this);
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: nsresult
     1: nsDocument::CreateShell(nsPresContext* aContext, nsIViewManager* aViewManager,
     1:                         nsStyleSet* aStyleSet,
     1:                         nsIPresShell** aInstancePtrResult)
     1: {
     1:   // Don't add anything here.  Add it to |doCreateShell| instead.
     1:   // This exists so that subclasses can pass other values for the 4th
     1:   // parameter some of the time.
     1:   return doCreateShell(aContext, aViewManager, aStyleSet,
     1:                        eCompatibility_FullStandards, aInstancePtrResult);
     1: }
     1: 
     1: nsresult
     1: nsDocument::doCreateShell(nsPresContext* aContext,
     1:                           nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
     1:                           nsCompatibility aCompatMode,
     1:                           nsIPresShell** aInstancePtrResult)
     1: {
     1:   *aInstancePtrResult = nsnull;
     1: 
 36917:   NS_ASSERTION(!mPresShell, "We have a presshell already!");
 36917: 
 58185:   NS_ENSURE_FALSE(GetBFCacheEntry(), NS_ERROR_FAILURE);
     1: 
     1:   FillStyleSet(aStyleSet);
     1:   
     1:   nsCOMPtr<nsIPresShell> shell;
     1:   nsresult rv = NS_NewPresShell(getter_AddRefs(shell));
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   rv = shell->Init(this, aContext, aViewManager, aStyleSet, aCompatMode);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // Note: we don't hold a ref to the shell (it holds a ref to us)
 36917:   mPresShell = shell;
 35581: 
 49570:   mExternalResourceMap.ShowViewers();
 49570: 
 75000:   MaybeRescheduleAnimationFrameNotifications();
 63939: 
 63939:   shell.swap(*aInstancePtrResult);
 63939: 
 63939:   return NS_OK;
 63939: }
 63939: 
 63939: void
 75000: nsDocument::MaybeRescheduleAnimationFrameNotifications()
 75000: {
 75000:   if (!mPresShell || !IsEventHandlingEnabled()) {
 75000:     // bail out for now, until one of those conditions changes
 75000:     return;
 75000:   }
 75000: 
 52255:   nsRefreshDriver* rd = mPresShell->GetPresContext()->RefreshDriver();
 82857:   if (!mFrameRequestCallbacks.IsEmpty()) {
 82857:     rd->ScheduleFrameRequestCallbacks(this);
 82857:   }
 82857: }
 82857: 
 82857: void
 82857: nsIDocument::TakeFrameRequestCallbacks(FrameRequestCallbackList& aCallbacks)
 82857: {
 82857:   aCallbacks.AppendElements(mFrameRequestCallbacks);
 82857:   mFrameRequestCallbacks.Clear();
 52255: }
 52255: 
 91982: PLDHashOperator RequestDiscardEnumerator(imgIRequest* aKey,
 91982:                                          PRUint32 aData,
 91982:                                          void* userArg)
 91982: {
 91982:   aKey->RequestDiscard();
 91982:   return PL_DHASH_NEXT;
 91982: }
 91982: 
 52255: void
 49570: nsDocument::DeleteShell()
 49570: {
 49570:   mExternalResourceMap.HideViewers();
 75000:   if (IsEventHandlingEnabled()) {
 63939:     RevokeAnimationFrameNotifications();
 63939:   }
 82099: 
 91982:   // When our shell goes away, request that all our images be immediately
 91982:   // discarded, so we don't carry around decoded image data for a document we
 91982:   // no longer intend to paint.
 91982:   mImageTracker.EnumerateRead(RequestDiscardEnumerator, nsnull);
 91982: 
 63939:   mPresShell = nsnull;
 63939: }
 63939: 
 63939: void
 63939: nsDocument::RevokeAnimationFrameNotifications()
 63939: {
 82857:   if (!mFrameRequestCallbacks.IsEmpty()) {
 52255:     mPresShell->GetPresContext()->RefreshDriver()->
 82857:       RevokeFrameRequestCallbacks(this);
 52255:   }
 49570: }
 49570: 
 20261: static void
     1: SubDocClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
     1: {
  3233:   SubDocMapEntry *e = static_cast<SubDocMapEntry *>(entry);
     1: 
     1:   NS_RELEASE(e->mKey);
  8462:   if (e->mSubDocument) {
  8462:     e->mSubDocument->SetParentDocument(nsnull);
  8462:     NS_RELEASE(e->mSubDocument);
  8462:   }
     1: }
     1: 
 79445: static bool
     1: SubDocInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
     1: {
     1:   SubDocMapEntry *e =
  3233:     const_cast<SubDocMapEntry *>
  3233:               (static_cast<const SubDocMapEntry *>(entry));
  3233: 
 81062:   e->mKey = const_cast<Element*>(static_cast<const Element*>(key));
     1:   NS_ADDREF(e->mKey);
     1: 
     1:   e->mSubDocument = nsnull;
 80486:   return true;
     1: }
     1: 
     1: nsresult
 81062: nsDocument::SetSubDocumentFor(Element* aElement, nsIDocument* aSubDoc)
 81062: {
 81062:   NS_ENSURE_TRUE(aElement, NS_ERROR_UNEXPECTED);
     1: 
     1:   if (!aSubDoc) {
     1:     // aSubDoc is nsnull, remove the mapping
     1: 
     1:     if (mSubDocuments) {
     1:       SubDocMapEntry *entry =
  3233:         static_cast<SubDocMapEntry*>
 81062:                    (PL_DHashTableOperate(mSubDocuments, aElement,
     1:                                          PL_DHASH_LOOKUP));
     1: 
     1:       if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
     1:         PL_DHashTableRawRemove(mSubDocuments, entry);
     1:       }
     1:     }
     1:   } else {
     1:     if (!mSubDocuments) {
     1:       // Create a new hashtable
     1: 
     1:       static PLDHashTableOps hash_table_ops =
     1:       {
     1:         PL_DHashAllocTable,
     1:         PL_DHashFreeTable,
     1:         PL_DHashVoidPtrKeyStub,
     1:         PL_DHashMatchEntryStub,
     1:         PL_DHashMoveEntryStub,
     1:         SubDocClearEntry,
     1:         PL_DHashFinalizeStub,
     1:         SubDocInitEntry
     1:       };
     1: 
     1:       mSubDocuments = PL_NewDHashTable(&hash_table_ops, nsnull,
     1:                                        sizeof(SubDocMapEntry), 16);
     1:       if (!mSubDocuments) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1:     }
     1: 
     1:     // Add a mapping to the hash table
     1:     SubDocMapEntry *entry =
  3233:       static_cast<SubDocMapEntry*>
 81062:                  (PL_DHashTableOperate(mSubDocuments, aElement,
     1:                                        PL_DHASH_ADD));
     1: 
     1:     if (!entry) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
     1:     if (entry->mSubDocument) {
     1:       entry->mSubDocument->SetParentDocument(nsnull);
     1: 
     1:       // Release the old sub document
     1:       NS_RELEASE(entry->mSubDocument);
     1:     }
     1: 
     1:     entry->mSubDocument = aSubDoc;
     1:     NS_ADDREF(entry->mSubDocument);
     1: 
     1:     aSubDoc->SetParentDocument(this);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsIDocument*
     1: nsDocument::GetSubDocumentFor(nsIContent *aContent) const
     1: {
 81062:   if (mSubDocuments && aContent->IsElement()) {
     1:     SubDocMapEntry *entry =
  3233:       static_cast<SubDocMapEntry*>
 81062:                  (PL_DHashTableOperate(mSubDocuments, aContent->AsElement(),
     1:                                        PL_DHASH_LOOKUP));
     1: 
     1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
     1:       return entry->mSubDocument;
     1:     }
     1:   }
     1: 
     1:   return nsnull;
     1: }
     1: 
 20261: static PLDHashOperator
     1: FindContentEnumerator(PLDHashTable *table, PLDHashEntryHdr *hdr,
     1:                       PRUint32 number, void *arg)
     1: {
  3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
  3233:   FindContentData *data = static_cast<FindContentData*>(arg);
     1: 
     1:   if (entry->mSubDocument == data->mSubDocument) {
     1:     data->mResult = entry->mKey;
     1: 
     1:     return PL_DHASH_STOP;
     1:   }
     1: 
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
 81062: Element*
     1: nsDocument::FindContentForSubDocument(nsIDocument *aDocument) const
     1: {
     1:   NS_ENSURE_TRUE(aDocument, nsnull);
     1: 
     1:   if (!mSubDocuments) {
     1:     return nsnull;
     1:   }
     1: 
     1:   FindContentData data(aDocument);
     1:   PL_DHashTableEnumerate(mSubDocuments, FindContentEnumerator, &data);
     1: 
     1:   return data.mResult;
     1: }
     1: 
 79445: bool
     1: nsDocument::IsNodeOfType(PRUint32 aFlags) const
     1: {
     1:     return !(aFlags & ~eDOCUMENT);
     1: }
     1: 
 41634: Element*
 79452: nsIDocument::GetRootElement() const
 79452: {
 79452:   return (mCachedRootElement && mCachedRootElement->GetNodeParent() == this) ?
 79452:          mCachedRootElement : GetRootElementInternal();
 79452: }
 79452: 
 79452: Element*
 41634: nsDocument::GetRootElementInternal() const
  8938: {
  8938:   // Loop backwards because any non-elements, such as doctypes and PIs
  8938:   // are likely to appear before the root element.
  8938:   PRUint32 i;
  8938:   for (i = mChildren.ChildCount(); i > 0; --i) {
  8938:     nsIContent* child = mChildren.ChildAt(i - 1);
 41634:     if (child->IsElement()) {
 79452:       const_cast<nsDocument*>(this)->mCachedRootElement = child->AsElement();
 41634:       return child->AsElement();
 41634:     }
 41634:   }
 41634:   
 41634:   const_cast<nsDocument*>(this)->mCachedRootElement = nsnull;
  8938:   return nsnull;
  8938: }
  8938: 
  8938: nsIContent *
     1: nsDocument::GetChildAt(PRUint32 aIndex) const
     1: {
     1:   return mChildren.GetSafeChildAt(aIndex);
     1: }
     1: 
     1: PRInt32
     1: nsDocument::IndexOf(nsINode* aPossibleChild) const
     1: {
     1:   return mChildren.IndexOfChild(aPossibleChild);
     1: }
     1: 
     1: PRUint32
     1: nsDocument::GetChildCount() const
     1: {
     1:   return mChildren.ChildCount();
     1: }
     1: 
 15810: nsIContent * const *
 22251: nsDocument::GetChildArray(PRUint32* aChildCount) const
 22251: {
 22251:   return mChildren.GetChildArray(aChildCount);
 15810: }
 15810:   
 15810: 
     1: nsresult
     1: nsDocument::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
 79445:                           bool aNotify)
     1: {
 41634:   if (aKid->IsElement() && GetRootElement()) {
     1:     NS_ERROR("Inserting element child when we already have one");
     1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     1:   }
     1: 
 42105:   return doInsertChildAt(aKid, aIndex, aNotify, mChildren);
     1: }
     1: 
     1: nsresult
 79445: nsDocument::AppendChildTo(nsIContent* aKid, bool aNotify)
     1: {
     1:   // Make sure to _not_ call the subclass InsertChildAt here.  If
     1:   // subclasses wanted to hook into this stuff, they would have
     1:   // overridden AppendChildTo.
     1:   // XXXbz maybe this should just be a non-virtual method on nsINode?
     1:   // Feels that way to me...
     1:   return nsDocument::InsertChildAt(aKid, GetChildCount(), aNotify);
     1: }
     1: 
 94359: void
 79445: nsDocument::RemoveChildAt(PRUint32 aIndex, bool aNotify)
 70878: {
     1:   nsCOMPtr<nsIContent> oldKid = GetChildAt(aIndex);
  8938:   if (!oldKid) {
 94359:     return;
  8938:   }
  8938: 
 41636:   if (oldKid->IsElement()) {
  8938:     // Destroy the link map up front before we mess with the child list.
 43079:     DestroyElementMaps();
  8938:   }
  8938: 
 70878:   doRemoveChildAt(aIndex, aNotify, oldKid, mChildren);
 41634:   mCachedRootElement = nsnull;
     1: }
     1: 
     1: PRInt32
     1: nsDocument::GetNumberOfStyleSheets() const
     1: {
     1:   return mStyleSheets.Count();
     1: }
     1: 
     1: nsIStyleSheet*
     1: nsDocument::GetStyleSheetAt(PRInt32 aIndex) const
     1: {
     1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mStyleSheets.Count(), nsnull);
     1:   return mStyleSheets[aIndex];
     1: }
     1: 
     1: PRInt32
     1: nsDocument::GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const
     1: {
     1:   return mStyleSheets.IndexOf(aSheet);
     1: }
     1: 
     1: void
     1: nsDocument::AddStyleSheetToStyleSets(nsIStyleSheet* aSheet)
     1: {
 46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:   if (shell) {
  1722:     shell->StyleSet()->AddDocStyleSheet(aSheet, this);
     1:   }
     1: }
     1: 
     1: void
     1: nsDocument::AddStyleSheet(nsIStyleSheet* aSheet)
     1: {
     1:   NS_PRECONDITION(aSheet, "null arg");
     1:   mStyleSheets.AppendObject(aSheet);
     1:   aSheet->SetOwningDocument(this);
     1: 
 42332:   if (aSheet->IsApplicable()) {
     1:     AddStyleSheetToStyleSets(aSheet);
     1:   }
     1: 
 80486:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, true));
     1: }
     1: 
     1: void
     1: nsDocument::RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet)
     1: {
 46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:   if (shell) {
  1722:     shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eDocSheet, aSheet);
  1722:   }
     1: }
     1: 
     1: void
     1: nsDocument::RemoveStyleSheet(nsIStyleSheet* aSheet)
     1: {
     1:   NS_PRECONDITION(aSheet, "null arg");
     1:   nsCOMPtr<nsIStyleSheet> sheet = aSheet; // hold ref so it won't die too soon
     1: 
     1:   if (!mStyleSheets.RemoveObject(aSheet)) {
     1:     NS_NOTREACHED("stylesheet not found");
     1:     return;
     1:   }
     1: 
     1:   if (!mIsGoingAway) {
 42332:     if (aSheet->IsApplicable()) {
     1:       RemoveStyleSheetFromStyleSets(aSheet);
     1:     }
     1: 
 80486:     NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetRemoved, (this, aSheet, true));
     1:   }
     1: 
     1:   aSheet->SetOwningDocument(nsnull);
     1: }
     1: 
     1: void
     1: nsDocument::UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
     1:                               nsCOMArray<nsIStyleSheet>& aNewSheets)
     1: {
     1:   BeginUpdate(UPDATE_STYLE);
     1: 
     1:   // XXX Need to set the sheet on the ownernode, if any
     1:   NS_PRECONDITION(aOldSheets.Count() == aNewSheets.Count(),
     1:                   "The lists must be the same length!");
     1:   PRInt32 count = aOldSheets.Count();
     1: 
     1:   nsCOMPtr<nsIStyleSheet> oldSheet;
     1:   PRInt32 i;
     1:   for (i = 0; i < count; ++i) {
     1:     oldSheet = aOldSheets[i];
     1: 
     1:     // First remove the old sheet.
     1:     NS_ASSERTION(oldSheet, "None of the old sheets should be null");
     1:     PRInt32 oldIndex = mStyleSheets.IndexOf(oldSheet);
     1:     RemoveStyleSheet(oldSheet);  // This does the right notifications
     1: 
     1:     // Now put the new one in its place.  If it's null, just ignore it.
     1:     nsIStyleSheet* newSheet = aNewSheets[i];
     1:     if (newSheet) {
     1:       mStyleSheets.InsertObjectAt(newSheet, oldIndex);
     1:       newSheet->SetOwningDocument(this);
 42332:       if (newSheet->IsApplicable()) {
     1:         AddStyleSheetToStyleSets(newSheet);
     1:       }
     1: 
 80486:       NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, newSheet, true));
     1:     }
     1:   }
     1: 
     1:   EndUpdate(UPDATE_STYLE);
     1: }
     1: 
     1: void
     1: nsDocument::InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex)
     1: {
     1:   NS_PRECONDITION(aSheet, "null ptr");
     1:   mStyleSheets.InsertObjectAt(aSheet, aIndex);
     1: 
     1:   aSheet->SetOwningDocument(this);
     1: 
 42332:   if (aSheet->IsApplicable()) {
     1:     AddStyleSheetToStyleSets(aSheet);
     1:   }
     1: 
 80486:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, true));
     1: }
     1: 
     1: 
     1: void
     1: nsDocument::SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
 79445:                                          bool aApplicable)
     1: {
     1:   NS_PRECONDITION(aSheet, "null arg");
     1: 
     1:   // If we're actually in the document style sheet list
     1:   if (-1 != mStyleSheets.IndexOf(aSheet)) {
     1:     if (aApplicable) {
     1:       AddStyleSheetToStyleSets(aSheet);
     1:     } else {
     1:       RemoveStyleSheetFromStyleSets(aSheet);
     1:     }
     1:   }
     1: 
     1:   // We have to always notify, since this will be called for sheets
     1:   // that are children of sheets in our style set, as well as some
     1:   // sheets for nsHTMLEditor.
     1: 
     1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetApplicableStateChanged,
     1:                                (this, aSheet, aApplicable));
     1: }
     1: 
     1: // These three functions are a lot like the implementation of the
     1: // corresponding API for regular stylesheets.
     1: 
     1: PRInt32
     1: nsDocument::GetNumberOfCatalogStyleSheets() const
     1: {
     1:   return mCatalogSheets.Count();
     1: }
     1: 
     1: nsIStyleSheet*
     1: nsDocument::GetCatalogStyleSheetAt(PRInt32 aIndex) const
     1: {
     1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mCatalogSheets.Count(), nsnull);
     1:   return mCatalogSheets[aIndex];
     1: }
     1: 
     1: void
     1: nsDocument::AddCatalogStyleSheet(nsIStyleSheet* aSheet)
     1: {
     1:   mCatalogSheets.AppendObject(aSheet);
     1:   aSheet->SetOwningDocument(this);
     1: 
 42332:   if (aSheet->IsApplicable()) {
     1:     // This is like |AddStyleSheetToStyleSets|, but for an agent sheet.
 46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:     if (shell) {
  1722:       shell->StyleSet()->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
  1722:     }
     1:   }
     1:                                                                                 
 80486:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, false));
     1: }
     1: 
     1: void
     1: nsDocument::EnsureCatalogStyleSheet(const char *aStyleSheetURI)
     1: {
 38851:   mozilla::css::Loader* cssLoader = CSSLoader();
 38851:   if (cssLoader->GetEnabled()) {
     1:     PRInt32 sheetCount = GetNumberOfCatalogStyleSheets();
     1:     for (PRInt32 i = 0; i < sheetCount; i++) {
     1:       nsIStyleSheet* sheet = GetCatalogStyleSheetAt(i);
     1:       NS_ASSERTION(sheet, "unexpected null stylesheet in the document");
     1:       if (sheet) {
     1:         nsCAutoString uriStr;
 42400:         sheet->GetSheetURI()->GetSpec(uriStr);
     1:         if (uriStr.Equals(aStyleSheetURI))
     1:           return;
     1:       }
     1:     }
     1: 
     1:     nsCOMPtr<nsIURI> uri;
     1:     NS_NewURI(getter_AddRefs(uri), aStyleSheetURI);
     1:     if (uri) {
 42163:       nsRefPtr<nsCSSStyleSheet> sheet;
 80486:       cssLoader->LoadSheetSync(uri, true, true, getter_AddRefs(sheet));
     1:       if (sheet) {
     1:         BeginUpdate(UPDATE_STYLE);
     1:         AddCatalogStyleSheet(sheet);
     1:         EndUpdate(UPDATE_STYLE);
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: nsIScriptGlobalObject*
     1: nsDocument::GetScriptGlobalObject() const
     1: {
     1:    // If we're going away, we've already released the reference to our
     1:    // ScriptGlobalObject.  We can, however, try to obtain it for the
     1:    // caller through our docshell.
     1: 
 14469:    // We actually need to start returning the docshell's script global
 14469:    // object as soon as nsDocumentViewer::Close has called
 14469:    // RemovedFromDocShell on us.
 14469:    if (mRemovedFromDocShell) {
     1:      nsCOMPtr<nsIInterfaceRequestor> requestor =
     1:        do_QueryReferent(mDocumentContainer);
     1:      if (requestor) {
     1:        nsCOMPtr<nsIScriptGlobalObject> globalObject = do_GetInterface(requestor);
     1:        return globalObject;
     1:      }
     1:    }
     1: 
     1:    return mScriptGlobalObject;
     1: }
     1: 
     1: nsIScriptGlobalObject*
     1: nsDocument::GetScopeObject()
     1: {
     1:   nsCOMPtr<nsIScriptGlobalObject> scope(do_QueryReferent(mScopeObject));
     1:   return scope;
     1: }
     1: 
 34207: static void
 34207: NotifyActivityChanged(nsIContent *aContent, void *aUnused)
 34207: {
 34207: #ifdef MOZ_MEDIA
 34207:   nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aContent));
 34207:   if (domMediaElem) {
 34207:     nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aContent);
 34207:     mediaElem->NotifyOwnerDocumentActivityChanged();
 34207:   }
 34207: #endif
 89114:   nsCOMPtr<nsIObjectLoadingContent> objectLoadingContent(do_QueryInterface(aContent));
 89114:   if (objectLoadingContent) {
 89114:     nsObjectLoadingContent* olc = static_cast<nsObjectLoadingContent*>(objectLoadingContent.get());
 89114:     olc->NotifyOwnerDocumentActivityChanged();
 89114:   }
 34207: }
 34207: 
 34207: void
 34207: nsIDocument::SetContainer(nsISupports* aContainer)
 34207: {
 34207:   mDocumentContainer = do_GetWeakReference(aContainer);
 34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
 34207: }
 34207: 
     1: void
     1: nsDocument::SetScriptGlobalObject(nsIScriptGlobalObject *aScriptGlobalObject)
     1: {
     1: #ifdef DEBUG
     1:   {
     1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobalObject));
     1: 
     1:     NS_ASSERTION(!win || win->IsInnerWindow(),
     1:                  "Script global object must be an inner window!");
     1:   }
     1: #endif
 36864:   NS_ABORT_IF_FALSE(aScriptGlobalObject || !mAnimationController ||
 36864:                     mAnimationController->IsPausedByType(
 36864:                         nsSMILTimeContainer::PAUSE_PAGEHIDE |
 36864:                         nsSMILTimeContainer::PAUSE_BEGIN),
 36864:                     "Clearing window pointer while animations are unpaused");
     1: 
     1:   if (mScriptGlobalObject && !aScriptGlobalObject) {
     1:     // We're detaching from the window.  We need to grab a pointer to
     1:     // our layout history state now.
     1:     mLayoutHistoryState = GetLayoutHistoryState();
     1: 
 75000:     if (mPresShell && !EventHandlingSuppressed()) {
 63939:       RevokeAnimationFrameNotifications();
 63939:     }
 63939: 
     1:     // Also make sure to remove our onload blocker now if we haven't done it yet
     1:     if (mOnloadBlockCount != 0) {
     1:       nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
     1:       if (loadGroup) {
     1:         loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
     1:       }
     1:     }
     1:   }
     1: 
     1:   mScriptGlobalObject = aScriptGlobalObject;
     1: 
     1:   if (aScriptGlobalObject) {
 18343:     mScriptObject = nsnull;
 80486:     mHasHadScriptHandlingObject = true;
     1:     // Go back to using the docshell for the layout history state
     1:     mLayoutHistoryState = nsnull;
     1:     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
 28460: 
 29979: #ifdef DEBUG
 31428:     if (!mWillReparent) {
 29979:       // We really shouldn't have a wrapper here but if we do we need to make sure
 29979:       // it has the correct parent.
 62690:       JSObject *obj = GetWrapperPreserveColor();
 29420:       if (obj) {
 29420:         JSObject *newScope = aScriptGlobalObject->GetGlobalJSObject();
 29420:         nsIScriptContext *scx = aScriptGlobalObject->GetContext();
 78415:         JSContext *cx = scx ? scx->GetNativeContext() : nsnull;
 29420:         if (!cx) {
 29420:           nsContentUtils::ThreadJSContextStack()->Peek(&cx);
 29420:           if (!cx) {
 97744:             cx = nsContentUtils::ThreadJSContextStack()->GetSafeJSContext();
 29420:             NS_ASSERTION(cx, "Uhoh, no context, this is bad!");
 29420:           }
 29420:         }
 29420:         if (cx) {
 29979:           NS_ASSERTION(JS_GetGlobalForObject(cx, obj) == newScope,
 29979:                        "Wrong scope, this is really bad!");
 29979:         }
 29979:       }
 31428:     }
 29979: #endif
 29420: 
 28460:     if (mAllowDNSPrefetch) {
 28460:       nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
 28460:       if (docShell) {
 28460: #ifdef DEBUG
 28460:         nsCOMPtr<nsIWebNavigation> webNav =
 28460:           do_GetInterface(aScriptGlobalObject);
 28460:         NS_ASSERTION(SameCOMIdentity(webNav, docShell),
 28460:                      "Unexpected container or script global?");
 28460: #endif
 79445:         bool allowDNSPrefetch;
 28460:         docShell->GetAllowDNSPrefetch(&allowDNSPrefetch);
 28460:         mAllowDNSPrefetch = allowDNSPrefetch;
 28460:       }
 28460:     }
 63939: 
 75000:     MaybeRescheduleAnimationFrameNotifications();
     1:   }
  9596: 
  9596:   // Remember the pointer to our window (or lack there of), to avoid
  9596:   // having to QI every time it's asked for.
  9596:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mScriptGlobalObject);
  9596:   mWindow = window;
 80229: 
 80229:   // Set our visibility state, but do not fire the event.  This is correct
 80229:   // because either we're coming out of bfcache (in which case IsVisible() will
 80229:   // still test false at this point and no state change will happen) or we're
 80229:   // doing the initial document load and don't want to fire the event for this
 80229:   // change.
 80229:   mVisibilityState = GetVisibilityState();
     1: }
     1: 
  6475: nsIScriptGlobalObject*
 42823: nsDocument::GetScriptHandlingObjectInternal() const
 42823: {
 42823:   NS_ASSERTION(!mScriptGlobalObject,
 42823:                "Do not call this when mScriptGlobalObject is set!");
  6475: 
  6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
  6475:     do_QueryReferent(mScriptObject);
  8094:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(scriptHandlingObject);
  8094:   if (win) {
  8947:     NS_ASSERTION(win->IsInnerWindow(), "Should have inner window here!");
  8094:     nsPIDOMWindow* outer = win->GetOuterWindow();
  8094:     if (!outer || outer->GetCurrentInnerWindow() != win) {
  8094:       NS_WARNING("Wrong inner/outer window combination!");
  8094:       return nsnull;
  8094:     }
  8094:   }
  6475:   return scriptHandlingObject;
  6475: }
  6475: void
  6475: nsDocument::SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject)
  6475: {
  6475:   NS_ASSERTION(!mScriptGlobalObject ||
  6475:                mScriptGlobalObject == aScriptObject,
  6475:                "Wrong script object!");
  8947:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aScriptObject);
  8947:   NS_ASSERTION(!win || win->IsInnerWindow(), "Should have inner window here!");
 15633:   mScopeObject = mScriptObject = do_GetWeakReference(aScriptObject);
  6475:   if (aScriptObject) {
 80486:     mHasHadScriptHandlingObject = true;
  6475:   }
  6475: }
  6475: 
     1: nsPIDOMWindow *
 63954: nsDocument::GetWindowInternal() const
 41409: {
 41409:   NS_ASSERTION(!mWindow, "This should not be called when mWindow is not null!");
  9596: 
     1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
     1: 
     1:   if (!win) {
     1:     return nsnull;
     1:   }
     1: 
     1:   return win->GetOuterWindow();
     1: }
     1: 
     1: nsPIDOMWindow *
 40925: nsDocument::GetInnerWindowInternal()
 40925: {
 40925:   NS_ASSERTION(mRemovedFromDocShell,
 40925:                "This document should have been removed from docshell!");
 22210: 
     1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
     1: 
     1:   return win;
     1: }
     1: 
     1: nsScriptLoader*
  2007: nsDocument::ScriptLoader()
  2007: {
     1:   return mScriptLoader;
     1: }
     1: 
 79445: bool
 51393: nsDocument::InternalAllowXULXBL()
 51393: {
 58024:   if (nsContentUtils::AllowXULXBLForPrincipal(NodePrincipal())) {
 51393:     mAllowXULXBL = eTriTrue;
 80486:     return true;
 51393:   }
 51393: 
 51393:   mAllowXULXBL = eTriFalse;
 80486:   return false;
 51393: }
 51393: 
     1: // Note: We don't hold a reference to the document observer; we assume
     1: // that it has a live reference to the document.
     1: void
     1: nsDocument::AddObserver(nsIDocumentObserver* aObserver)
     1: {
 57140:   NS_ASSERTION(mObservers.IndexOf(aObserver) == nsTArray<int>::NoIndex,
 41925:                "Observer already in the list");
 41925:   mObservers.AppendElement(aObserver);
     1:   AddMutationObserver(aObserver);
     1: }
     1: 
 79445: bool
     1: nsDocument::RemoveObserver(nsIDocumentObserver* aObserver)
     1: {
     1:   // If we're in the process of destroying the document (and we're
     1:   // informing the observers of the destruction), don't remove the
     1:   // observers from the list. This is not a big deal, since we
     1:   // don't hold a live reference to the observers.
     1:   if (!mInDestructor) {
     1:     RemoveMutationObserver(aObserver);
  9536:     return mObservers.RemoveElement(aObserver);
     1:   }
     1: 
     1:   return mObservers.Contains(aObserver);
     1: }
     1: 
     1: void
 24482: nsDocument::MaybeEndOutermostXBLUpdate()
 24482: {
 24482:   // Only call BindingManager()->EndOutermostUpdate() when
 24482:   // we're not in an update and it is safe to run scripts.
 24482:   if (mUpdateNestLevel == 0 && mInXBLUpdate) {
 24482:     if (nsContentUtils::IsSafeToRunScript()) {
 80486:       mInXBLUpdate = false;
 24482:       BindingManager()->EndOutermostUpdate();
 24482:     } else if (!mInDestructor) {
 24482:       nsContentUtils::AddScriptRunner(
 41361:         NS_NewRunnableMethod(this, &nsDocument::MaybeEndOutermostXBLUpdate));
 24482:     }
 24482:   }
 24482: }
 24482: 
 24482: void
     1: nsDocument::BeginUpdate(nsUpdateType aUpdateType)
     1: {
 24482:   if (mUpdateNestLevel == 0 && !mInXBLUpdate) {
 80486:     mInXBLUpdate = true;
 13669:     BindingManager()->BeginOutermostUpdate();
  2025:   }
  2025:   
     1:   ++mUpdateNestLevel;
 13098:   nsContentUtils::AddScriptBlocker();
 26217:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginUpdate, (this, aUpdateType));
 14319: }
     1: 
     1: void
     1: nsDocument::EndUpdate(nsUpdateType aUpdateType)
     1: {
 26217:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndUpdate, (this, aUpdateType));
 26217: 
 13098:   nsContentUtils::RemoveScriptBlocker();
     1: 
     1:   --mUpdateNestLevel;
 24482: 
  2025:   // This set of updates may have created XBL bindings.  Let the
  2025:   // binding manager know we're done.
 24482:   MaybeEndOutermostXBLUpdate();
 24482: 
 24482:   MaybeInitializeFinalizeFrameLoaders();
     1: }
     1: 
     1: void
     1: nsDocument::BeginLoad()
     1: {
     1:   // Block onload here to prevent having to deal with blocking and
     1:   // unblocking it while we know the document is loading.
     1:   BlockOnload();
     1: 
 16373:   if (mScriptLoader) {
 16373:     mScriptLoader->BeginDeferringScripts();
 16373:   }
 16373: 
     1:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginLoad, (this));
     1: }
     1: 
 43946: void
 43946: nsDocument::ReportEmptyGetElementByIdArg()
 43946: {
 84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                   "DOM", this,
 84636:                                   nsContentUtils::eDOM_PROPERTIES,
 84636:                                   "EmptyGetElementByIdParam");
     1: }
     1: 
 42425: Element*
 43079: nsDocument::GetElementById(const nsAString& aElementId)
 42425: {
 43946:   if (!CheckGetElementByIdArg(aElementId)) {
 42425:     return nsnull;
 42425:   }
 42425: 
 43946:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aElementId);
 43079:   return entry ? entry->GetIdElement() : nsnull;
 42425: }
 42425: 
 81140: const nsSmallVoidArray*
 81140: nsDocument::GetAllElementsForId(const nsAString& aElementId) const
 81140: {
 81140:   if (aElementId.IsEmpty()) {
 81140:     return nsnull;
 81140:   }
 81140: 
 81140:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aElementId);
 81140:   return entry ? entry->GetIdElements() : nsnull;  
 81140: }
 81140: 
 42425: NS_IMETHODIMP
 42425: nsDocument::GetElementById(const nsAString& aId, nsIDOMElement** aReturn)
 42425: {
 43079:   Element *content = GetElementById(aId);
 42425:   if (content) {
 43079:     return CallQueryInterface(content, aReturn);
 43079:   }
 43079: 
 42156:   *aReturn = nsnull;
 43079: 
 43079:   return NS_OK;
 15474: }
 15474: 
 42325: Element*
 15515: nsDocument::AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
 79445:                                 void* aData, bool aForImage)
 15515: {
 43946:   nsDependentAtomString id(aID);
 43946: 
 43946:   if (!CheckGetElementByIdArg(id))
 15515:     return nsnull;
 15515: 
 43946:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(id);
 15515:   NS_ENSURE_TRUE(entry, nsnull);
 15515: 
 50428:   entry->AddContentChangeCallback(aObserver, aData, aForImage);
 50428:   return aForImage ? entry->GetImageIdElement() : entry->GetIdElement();
 15515: }
 15515: 
 15515: void
 50428: nsDocument::RemoveIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
 79445:                                    void* aData, bool aForImage)
 15515: {
 43946:   nsDependentAtomString id(aID);
 43946: 
 43946:   if (!CheckGetElementByIdArg(id))
 15515:     return;
 15515: 
 43946:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(id);
 22725:   if (!entry) {
 15515:     return;
 22725:   }
 15515: 
 50428:   entry->RemoveContentChangeCallback(aObserver, aData, aForImage);
 50428: }
 50428: 
 50428: NS_IMETHODIMP
 50428: nsDocument::MozSetImageElement(const nsAString& aImageElementId,
 50428:                                nsIDOMElement* aImageElement)
 50428: {
 50428:   if (aImageElementId.IsEmpty())
 50428:     return NS_OK;
 50428: 
 63249:   // Hold a script blocker while calling SetImageElement since that can call
 63249:   // out to id-observers
 63249:   nsAutoScriptBlocker scriptBlocker;
 63249: 
 50428:   nsCOMPtr<nsIContent> content = do_QueryInterface(aImageElement);
 50428:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(aImageElementId);
 50428:   if (entry) {
 50428:     entry->SetImageElement(content ? content->AsElement() : nsnull);
 50428:     if (entry->IsEmpty()) {
 50428:       mIdentifierMap.RemoveEntry(aImageElementId);
 50428:     }
 50428:   }
 50428:   return NS_OK;
 50428: }
 50428: 
 50428: Element*
 50428: nsDocument::LookupImageElement(const nsAString& aId)
 50428: {
 50428:   if (aId.IsEmpty())
 50428:     return nsnull;
 50428: 
 63586:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aId);
 50428:   return entry ? entry->GetImageIdElement() : nsnull;
 15515: }
 15515: 
     1: void
     1: nsDocument::DispatchContentLoadedEvents()
     1: {
 41653:   NS_TIME_FUNCTION;
  6205:   // If you add early returns from this method, make sure you're
  6205:   // calling UnblockOnload properly.
  6205:   
 30065:   // Unpin references to preloaded images
 30065:   mPreloadingImages.Clear();
 30065: 
 72298:   if (mTiming) {
 72298:     mTiming->NotifyDOMContentLoadedStart(nsIDocument::GetDocumentURI());
 72298:   }
 72298:     
     1:   // Fire a DOM event notifying listeners that this document has been
     1:   // loaded (excluding images and other loads initiated by this
     1:   // document).
  3233:   nsContentUtils::DispatchTrustedEvent(this, static_cast<nsIDocument*>(this),
     1:                                        NS_LITERAL_STRING("DOMContentLoaded"),
 80486:                                        true, true);
     1: 
 72298:   if (mTiming) {
 72298:     mTiming->NotifyDOMContentLoadedEnd(nsIDocument::GetDocumentURI());
 72298:   }
 72298: 
     1:   // If this document is a [i]frame, fire a DOMFrameContentLoaded
     1:   // event on all parent documents notifying that the HTML (excluding
     1:   // other external files such as images and stylesheets) in a frame
     1:   // has finished loading.
     1: 
     1:   // target_frame is the [i]frame element that will be used as the
     1:   // target for the event. It's the [i]frame whose content is done
     1:   // loading.
     1:   nsCOMPtr<nsIDOMEventTarget> target_frame;
     1: 
 11417:   if (mParentDocument) {
 11417:     target_frame =
 11417:       do_QueryInterface(mParentDocument->FindContentForSubDocument(this));
     1:   }
     1: 
     1:   if (target_frame) {
 11417:     nsCOMPtr<nsIDocument> parent = mParentDocument;
 14930:     do {
 70359:       nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(parent);
     1: 
     1:       nsCOMPtr<nsIDOMEvent> event;
 70359:       if (domDoc) {
 70359:         domDoc->CreateEvent(NS_LITERAL_STRING("Events"),
     1:                             getter_AddRefs(event));
     1: 
101616:       }
101616: 
101616:       if (event) {
 80486:         event->InitEvent(NS_LITERAL_STRING("DOMFrameContentLoaded"), true,
 80486:                          true);
     1: 
101616:         event->SetTarget(target_frame);
101616:         event->SetTrusted(true);
     1: 
     1:         // To dispatch this event we must manually call
     1:         // nsEventDispatcher::Dispatch() on the ancestor document since the
     1:         // target is not in the same document, so the event would never reach
     1:         // the ancestor document if we used the normal event
     1:         // dispatching code.
     1: 
101616:         nsEvent* innerEvent = event->GetInternalNSEvent();
     1:         if (innerEvent) {
     1:           nsEventStatus status = nsEventStatus_eIgnore;
     1: 
 46225:           nsIPresShell *shell = parent->GetShell();
     1:           if (shell) {
 39823:             nsRefPtr<nsPresContext> context = shell->GetPresContext();
     1: 
     1:             if (context) {
 11417:               nsEventDispatcher::Dispatch(parent, context, innerEvent, event,
 11417:                                           &status);
 11417:             }
 11417:           }
 11417:         }
 11417:       }
 14930:       
 14930:       parent = parent->GetParentDocument();
 14930:     } while (parent);
     1:   }
  6205: 
 25379:   // If the document has a manifest attribute, fire a MozApplicationManifest
 25379:   // event.
 41634:   Element* root = GetRootElement();
 25379:   if (root && root->HasAttr(kNameSpaceID_None, nsGkAtoms::manifest)) {
 25379:     nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
 25379:                                         NS_LITERAL_STRING("MozApplicationManifest"),
 80486:                                         true, true);
 80486:   }
 80486: 
 80486:   UnblockOnload(true);
     1: }
     1: 
     1: void
     1: nsDocument::EndLoad()
     1: {
  6177:   // Drop the ref to our parser, if any, but keep hold of the sink so that we
  6177:   // can flush it from FlushPendingNotifications as needed.  We might have to
  6177:   // do that to get a StartLayout() to happen.
  6170:   if (mParser) {
  6170:     mWeakSink = do_GetWeakReference(mParser->GetContentSink());
     1:     mParser = nsnull;
  6170:   }
     1:   
     1:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndLoad, (this));
 24144:   
 24144:   if (!mSynchronousDOMContentLoaded) {
 24144:     nsRefPtr<nsIRunnable> ev =
 41361:       NS_NewRunnableMethod(this, &nsDocument::DispatchContentLoadedEvents);
 24144:     NS_DispatchToCurrentThread(ev);
 24144:   } else {
 24144:     DispatchContentLoadedEvents();
 24144:   }
     1: }
     1: 
     1: void
 64120: nsDocument::ContentStateChanged(nsIContent* aContent, nsEventStates aStateMask)
 64120: {
 71103:   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
 71103:                   "Someone forgot a scriptblocker");
 64120:   NS_DOCUMENT_NOTIFY_OBSERVERS(ContentStateChanged,
 64120:                                (this, aContent, aStateMask));
     1: }
     1: 
     1: void
 56168: nsDocument::DocumentStatesChanged(nsEventStates aStateMask)
 39698: {
 39698:   // Invalidate our cached state.
 39698:   mGotDocumentState &= ~aStateMask;
 39698:   mDocumentState &= ~aStateMask;
 39698: 
 39698:   NS_DOCUMENT_NOTIFY_OBSERVERS(DocumentStatesChanged, (this, aStateMask));
 39698: }
 39698: 
 39698: void
     1: nsDocument::StyleRuleChanged(nsIStyleSheet* aStyleSheet,
     1:                              nsIStyleRule* aOldStyleRule,
     1:                              nsIStyleRule* aNewStyleRule)
     1: {
     1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleChanged,
     1:                                (this, aStyleSheet,
     1:                                 aOldStyleRule, aNewStyleRule));
     1: }
     1: 
     1: void
     1: nsDocument::StyleRuleAdded(nsIStyleSheet* aStyleSheet,
     1:                            nsIStyleRule* aStyleRule)
     1: {
     1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleAdded,
     1:                                (this, aStyleSheet, aStyleRule));
     1: }
     1: 
     1: void
     1: nsDocument::StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
     1:                              nsIStyleRule* aStyleRule)
     1: {
     1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleRemoved,
     1:                                (this, aStyleSheet, aStyleRule));
     1: }
     1: 
     1: 
     1: //
     1: // nsIDOMDocument interface
     1: //
101136: nsIContent*
101136: nsIDocument::GetDocumentType() const
101136: {
101136:   for (nsIContent* child = GetFirstChild();
101136:        child;
101136:        child = child->GetNextSibling()) {
101136:     if (child->NodeType() == nsIDOMNode::DOCUMENT_TYPE_NODE) {
101136:       return child;
101136:     }
101136:   }
101136:   return NULL;
101136: }
101136: 
     1: NS_IMETHODIMP
     1: nsDocument::GetDoctype(nsIDOMDocumentType** aDoctype)
     1: {
101136:   MOZ_ASSERT(aDoctype);
101136:   nsCOMPtr<nsIDOMDocumentType> doctype = do_QueryInterface(GetDocumentType());
101136:   doctype.forget(aDoctype);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetImplementation(nsIDOMDOMImplementation** aImplementation)
     1: {
 34007:   if (!mDOMImplementation) {
     1:     nsCOMPtr<nsIURI> uri;
     1:     NS_NewURI(getter_AddRefs(uri), "about:blank");
     1:     NS_ENSURE_TRUE(uri, NS_ERROR_OUT_OF_MEMORY);
 79445:     bool hasHadScriptObject = true;
  6475:     nsIScriptGlobalObject* scriptObject =
  6475:       GetScriptHandlingObject(hasHadScriptObject);
  6475:     NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
 78421:     mDOMImplementation = new nsDOMImplementation(this, scriptObject, uri, uri);
 34007:     if (!mDOMImplementation) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
 34007:   }
 34007: 
 34007:   NS_ADDREF(*aImplementation = mDOMImplementation);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetDocumentElement(nsIDOMElement** aDocumentElement)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDocumentElement);
     1: 
 41634:   Element* root = GetRootElement();
  8938:   if (root) {
  8938:     return CallQueryInterface(root, aDocumentElement);
  8938:   }
  8938: 
     1:   *aDocumentElement = nsnull;
  8938: 
  8938:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateElement(const nsAString& aTagName,
     1:                           nsIDOMElement** aReturn)
     1: {
     1:   *aReturn = nsnull;
 48124:   nsCOMPtr<nsIContent> content;
 48124:   nsresult rv = CreateElement(aTagName, getter_AddRefs(content));
 48124:   NS_ENSURE_SUCCESS(rv, rv);
 48124:   return CallQueryInterface(content, aReturn);
 48124: }
 48124: 
 79445: bool IsLowercaseASCII(const nsAString& aValue)
 48124: {
 48124:   PRInt32 len = aValue.Length();
 48124:   for (PRInt32 i = 0; i < len; ++i) {
 48124:     PRUnichar c = aValue[i];
 48124:     if (!(0x0061 <= (c) && ((c) <= 0x007a))) {
 80486:       return false;
 80486:     }
 80486:   }
 80486:   return true;
 48124: }
 48124: 
 48124: nsresult
 48124: nsDocument::CreateElement(const nsAString& aTagName,
 48124:                           nsIContent** aReturn)
 48124: {
 48124:   *aReturn = nsnull;
     1: 
 80486:   nsresult rv = nsContentUtils::CheckQName(aTagName, false);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 79445:   bool needsLowercase = IsHTML() && !IsLowercaseASCII(aTagName);
 48124:   nsAutoString lcTagName;
 48124:   if (needsLowercase) {
 91979:     nsContentUtils::ASCIIToLower(aTagName, lcTagName);
 48124:   }
 48124: 
 61268:   rv = CreateElem(needsLowercase ? lcTagName : aTagName,
 81061:                   nsnull, mDefaultElementType, aReturn);
 48124:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateElementNS(const nsAString& aNamespaceURI,
     1:                             const nsAString& aQualifiedName,
     1:                             nsIDOMElement** aReturn)
     1: {
     1:   *aReturn = nsnull;
 58381:   nsCOMPtr<nsIContent> content;
 58381:   nsresult rv = CreateElementNS(aNamespaceURI, aQualifiedName,
 58381:                                 getter_AddRefs(content));
 58381:   NS_ENSURE_SUCCESS(rv, rv);
 58381:   return CallQueryInterface(content, aReturn);
 58381: }
 58381: 
 58381: nsresult
 58381: nsDocument::CreateElementNS(const nsAString& aNamespaceURI,
 58381:                             const nsAString& aQualifiedName,
 58381:                             nsIContent** aReturn)
 58381: {
 94340:   nsCOMPtr<nsINodeInfo> nodeInfo;
     1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
     1:                                                      aQualifiedName,
     1:                                                      mNodeInfoManager,
 71770:                                                      nsIDOMNode::ELEMENT_NODE,
     1:                                                      getter_AddRefs(nodeInfo));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 82294:   return NS_NewElement(aReturn, nodeInfo.forget(), NOT_FROM_PARSER);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateTextNode(const nsAString& aData, nsIDOMText** aReturn)
     1: {
     1:   *aReturn = nsnull;
 48124:   nsCOMPtr<nsIContent> content;
 48124:   nsresult rv = CreateTextNode(aData, getter_AddRefs(content));
 48124:   NS_ENSURE_SUCCESS(rv, rv);
 48124:   return CallQueryInterface(content, aReturn);
 48124: }
 48124: 
 48124: nsresult
 48124: nsDocument::CreateTextNode(const nsAString& aData, nsIContent** aReturn)
 48124: {
 48124:   nsresult rv = NS_NewTextNode(aReturn, mNodeInfoManager);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // Don't notify; this node is still being created.
 80486:     (*aReturn)->SetText(aData, false);
 48124:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateDocumentFragment(nsIDOMDocumentFragment** aReturn)
     1: {
     1:   return NS_NewDocumentFragment(aReturn, mNodeInfoManager);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateComment(const nsAString& aData, nsIDOMComment** aReturn)
     1: {
     1:   *aReturn = nsnull;
     1: 
     1:   nsCOMPtr<nsIContent> comment;
     1:   nsresult rv = NS_NewCommentNode(getter_AddRefs(comment), mNodeInfoManager);
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // Don't notify; this node is still being created.
 80486:     comment->SetText(aData, false);
     1: 
     1:     rv = CallQueryInterface(comment, aReturn);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateCDATASection(const nsAString& aData,
     1:                                nsIDOMCDATASection** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   *aReturn = nsnull;
     1: 
 69474:   if (IsHTML()) {
 69474:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 69474:   }
 69474: 
 69474:   if (FindInReadable(NS_LITERAL_STRING("]]>"), aData)) {
     1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
 69474:   }
     1: 
     1:   nsCOMPtr<nsIContent> content;
     1:   nsresult rv = NS_NewXMLCDATASection(getter_AddRefs(content),
     1:                                       mNodeInfoManager);
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // Don't notify; this node is still being created.
 80486:     content->SetText(aData, false);
     1: 
     1:     rv = CallQueryInterface(content, aReturn);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateProcessingInstruction(const nsAString& aTarget,
     1:                                         const nsAString& aData,
     1:                                         nsIDOMProcessingInstruction** aReturn)
     1: {
     1:   *aReturn = nsnull;
     1: 
 80486:   nsresult rv = nsContentUtils::CheckQName(aTarget, false);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (FindInReadable(NS_LITERAL_STRING("?>"), aData)) {
     1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
     1:   }
     1: 
     1:   nsCOMPtr<nsIContent> content;
     1:   rv = NS_NewXMLProcessingInstruction(getter_AddRefs(content),
     1:                                       mNodeInfoManager, aTarget, aData);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   return CallQueryInterface(content, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateAttribute(const nsAString& aName,
     1:                             nsIDOMAttr** aReturn)
     1: {
     1:   *aReturn = nsnull;
 72272: 
 72272:   WarnOnceAbout(eCreateAttribute);
 72272: 
     1:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_NOT_INITIALIZED);
     1: 
 80486:   nsresult rv = nsContentUtils::CheckQName(aName, false);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 94340:   nsCOMPtr<nsINodeInfo> nodeInfo;
     1:   rv = mNodeInfoManager->GetNodeInfo(aName, nsnull, kNameSpaceID_None,
 71770:                                      nsIDOMNode::ATTRIBUTE_NODE,
     1:                                      getter_AddRefs(nodeInfo));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 72272:   nsAutoString value;
 72272:   nsCOMPtr<nsIDOMAttr> attribute =
 80486:     new nsDOMAttribute(nsnull, nodeInfo.forget(), value, false);
 72272:   attribute.forget(aReturn);
 72272:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateAttributeNS(const nsAString & aNamespaceURI,
     1:                               const nsAString & aQualifiedName,
     1:                               nsIDOMAttr **aResult)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aResult);
     1:   *aResult = nsnull;
     1: 
 72272:   WarnOnceAbout(eCreateAttributeNS);
 72272: 
 94340:   nsCOMPtr<nsINodeInfo> nodeInfo;
     1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
     1:                                                      aQualifiedName,
     1:                                                      mNodeInfoManager,
 71770:                                                      nsIDOMNode::ATTRIBUTE_NODE,
     1:                                                      getter_AddRefs(nodeInfo));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsAutoString value;
 72272:   nsCOMPtr<nsIDOMAttr> attribute =
 80486:     new nsDOMAttribute(nsnull, nodeInfo.forget(), value, true);
 72272:   attribute.forget(aResult);
 72272:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetElementsByTagName(const nsAString& aTagname,
     1:                                  nsIDOMNodeList** aReturn)
     1: {
 42425:   nsRefPtr<nsContentList> list = GetElementsByTagName(aTagname);
     1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   // transfer ref to aReturn
 42425:   *aReturn = list.forget().get();
 42425:   return NS_OK;
 42425: }
 42425: 
 42425: already_AddRefed<nsContentList>
     1: nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
 42425:                                    const nsAString& aLocalName)
     1: {
     1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
     1: 
     1:   if (!aNamespaceURI.EqualsLiteral("*")) {
     1:     nsresult rv =
     1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
     1:                                                             nameSpaceId);
 42425:     NS_ENSURE_SUCCESS(rv, nsnull);
     1:   }
     1: 
 63637:   NS_ASSERTION(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
 63637: 
 63637:   return NS_GetContentList(this, nameSpaceId, aLocalName);
 42425: }
 42425: 
 42425: NS_IMETHODIMP
 42425: nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
 42425:                                    const nsAString& aLocalName,
 42425:                                    nsIDOMNodeList** aReturn)
 42425: {
 42425:   nsRefPtr<nsContentList> list = GetElementsByTagNameNS(aNamespaceURI,
 42425:                                                         aLocalName);
     1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   // transfer ref to aReturn
 42425:   *aReturn = list.forget().get();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDocument::GetAsync(bool *aAsync)
     1: {
     1:   NS_ERROR("nsDocument::GetAsync() should be overriden by subclass!");
     1: 
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDocument::SetAsync(bool aAsync)
     1: {
     1:   NS_ERROR("nsDocument::SetAsync() should be overriden by subclass!");
     1: 
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDocument::Load(const nsAString& aUrl, bool *aReturn)
     1: {
     1:   NS_ERROR("nsDocument::Load() should be overriden by subclass!");
     1: 
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetStyleSheets(nsIDOMStyleSheetList** aStyleSheets)
     1: {
     1:   if (!mDOMStyleSheets) {
     1:     mDOMStyleSheets = new nsDOMStyleSheetList(this);
     1:     if (!mDOMStyleSheets) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   *aStyleSheets = mDOMStyleSheets;
     1:   NS_ADDREF(*aStyleSheets);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetSelectedStyleSheetSet(nsAString& aSheetSet)
     1: {
     1:   aSheetSet.Truncate();
     1:   
     1:   // Look through our sheets, find the selected set title
     1:   PRInt32 count = GetNumberOfStyleSheets();
     1:   nsAutoString title;
     1:   for (PRInt32 index = 0; index < count; index++) {
     1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
     1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
     1: 
     1:     nsCOMPtr<nsIDOMStyleSheet> domSheet = do_QueryInterface(sheet);
     1:     NS_ASSERTION(domSheet, "Sheet must QI to nsIDOMStyleSheet");
 79445:     bool disabled;
     1:     domSheet->GetDisabled(&disabled);
     1:     if (disabled) {
     1:       // Disabled sheets don't affect the currently selected set
     1:       continue;
     1:     }
     1:     
     1:     sheet->GetTitle(title);
     1: 
     1:     if (aSheetSet.IsEmpty()) {
     1:       aSheetSet = title;
     1:     } else if (!title.IsEmpty() && !aSheetSet.Equals(title)) {
     1:       // Sheets from multiple sets enabled; return null string, per spec.
     1:       SetDOMStringToNull(aSheetSet);
     1:       break;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::SetSelectedStyleSheetSet(const nsAString& aSheetSet)
     1: {
     1:   if (DOMStringIsNull(aSheetSet)) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Must update mLastStyleSheetSet before doing anything else with stylesheets
     1:   // or CSSLoaders.
     1:   mLastStyleSheetSet = aSheetSet;
 80486:   EnableStyleSheetsForSetInternal(aSheetSet, true);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetLastStyleSheetSet(nsAString& aSheetSet)
     1: {
     1:   aSheetSet = mLastStyleSheetSet;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetPreferredStyleSheetSet(nsAString& aSheetSet)
     1: {
     1:   GetHeaderData(nsGkAtoms::headerDefaultStyle, aSheetSet);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetStyleSheetSets(nsIDOMDOMStringList** aList)
     1: {
     1:   if (!mStyleSheetSetList) {
     1:     mStyleSheetSetList = new nsDOMStyleSheetSetList(this);
     1:     if (!mStyleSheetSetList) {
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:   }
     1: 
     1:   NS_ADDREF(*aList = mStyleSheetSetList);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::EnableStyleSheetsForSet(const nsAString& aSheetSet)
     1: {
     1:   // Per spec, passing in null is a no-op.
     1:   if (!DOMStringIsNull(aSheetSet)) {
     1:     // Note: must make sure to not change the CSSLoader's preferred sheet --
     1:     // that value should be equal to either our lastStyleSheetSet (if that's
     1:     // non-null) or to our preferredStyleSheetSet.  And this method doesn't
     1:     // change either of those.
 80486:     EnableStyleSheetsForSetInternal(aSheetSet, false);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsDocument::EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
 79445:                                             bool aUpdateCSSLoader)
     1: {
     1:   BeginUpdate(UPDATE_STYLE);
     1:   PRInt32 count = GetNumberOfStyleSheets();
     1:   nsAutoString title;
     1:   for (PRInt32 index = 0; index < count; index++) {
     1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
     1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
     1:     sheet->GetTitle(title);
     1:     if (!title.IsEmpty()) {
     1:       sheet->SetEnabled(title.Equals(aSheetSet));
     1:     }
     1:   }
     1:   if (aUpdateCSSLoader) {
     1:     CSSLoader()->SetPreferredSheet(aSheetSet);
     1:   }
     1:   EndUpdate(UPDATE_STYLE);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetCharacterSet(nsAString& aCharacterSet)
     1: {
     1:   CopyASCIItoUTF16(GetDocumentCharacterSet(), aCharacterSet);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::ImportNode(nsIDOMNode* aImportedNode,
 79445:                        bool aDeep,
 81082:                        PRUint8 aArgc,
     1:                        nsIDOMNode** aResult)
     1: {
 81082:   if (aArgc == 0) {
 81082:     aDeep = true;
 81082:   }
     1: 
     1:   *aResult = nsnull;
     1: 
 94629:   nsCOMPtr<nsINode> imported = do_QueryInterface(aImportedNode);
 94629:   NS_ENSURE_TRUE(imported, NS_ERROR_UNEXPECTED);
 94629: 
 94629:   nsresult rv = nsContentUtils::CheckSameOrigin(this, imported);
 94629:   NS_ENSURE_SUCCESS(rv, rv);
 94629: 
 94629:   switch (imported->NodeType()) {
     1:     case nsIDOMNode::ATTRIBUTE_NODE:
     1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
     1:     case nsIDOMNode::ELEMENT_NODE:
     1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
     1:     case nsIDOMNode::TEXT_NODE:
     1:     case nsIDOMNode::CDATA_SECTION_NODE:
     1:     case nsIDOMNode::COMMENT_NODE:
 78421:     case nsIDOMNode::DOCUMENT_TYPE_NODE:
     1:     {
     1:       nsCOMPtr<nsIDOMNode> newNode;
     1:       nsCOMArray<nsINode> nodesWithProperties;
     1:       rv = nsNodeUtils::Clone(imported, aDeep, mNodeInfoManager,
     1:                               nodesWithProperties, getter_AddRefs(newNode));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
 80526:       nsIDocument *ownerDoc = imported->OwnerDoc();
     1:       rv = nsNodeUtils::CallUserDataHandlers(nodesWithProperties, ownerDoc,
     1:                                              nsIDOMUserDataHandler::NODE_IMPORTED,
 80486:                                              true);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:       newNode.swap(*aResult);
     1: 
     1:       return NS_OK;
     1:     }
     1:     default:
     1:     {
     1:       NS_WARNING("Don't know how to clone this nodetype for importNode.");
     1: 
     1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1:     }
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::AddBinding(nsIDOMElement* aContent, const nsAString& aURI)
     1: {
     1:   NS_ENSURE_ARG(aContent);
     1:   
     1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
     1: 
     1:   nsCOMPtr<nsIURI> uri;
     1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
  3645:   // Figure out the right principal to use
  3645:   nsCOMPtr<nsIPrincipal> subject;
  3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
  3645:   if (secMan) {
  3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
  3645:     NS_ENSURE_SUCCESS(rv, rv);
  3645:   }
  3645: 
  3645:   if (!subject) {
  3645:     // Fall back to our principal.  Or should we fall back to the null
  3645:     // principal?  The latter would just mean no binding loads....
  3645:     subject = NodePrincipal();
  3645:   }
  3645:   
 13669:   return BindingManager()->AddLayeredBinding(content, uri, subject);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::RemoveBinding(nsIDOMElement* aContent, const nsAString& aURI)
     1: {
     1:   NS_ENSURE_ARG(aContent);
     1: 
     1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   nsCOMPtr<nsIURI> uri;
     1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
 13669:   return BindingManager()->RemoveLayeredBinding(content, uri);
     1: }
     1: 
     1: NS_IMETHODIMP
  2324: nsDocument::LoadBindingDocument(const nsAString& aURI)
     1: {
     1:   nsCOMPtr<nsIURI> uri;
     1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI,
     1:                           mCharacterSet.get(),
 41900:                           GetDocBaseURI());
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  3645:   // Figure out the right principal to use
  3645:   nsCOMPtr<nsIPrincipal> subject;
  3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
  3645:   if (secMan) {
  3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
  3645:     NS_ENSURE_SUCCESS(rv, rv);
  3645:   }
  3645: 
  3645:   if (!subject) {
  3645:     // Fall back to our principal.  Or should we fall back to the null
  3645:     // principal?  The latter would just mean no binding loads....
  3645:     subject = NodePrincipal();
  3645:   }
  3645:   
 13669:   BindingManager()->LoadBindingDocument(this, uri, subject);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetBindingParent(nsIDOMNode* aNode, nsIDOMElement** aResult)
     1: {
     1:   *aResult = nsnull;
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
     1:   if (!content)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(content->GetBindingParent()));
     1:   NS_IF_ADDREF(*aResult = elt);
     1:   return NS_OK;
     1: }
     1: 
 99618: static nsIContent*
     1: GetElementByAttribute(nsIContent* aContent, nsIAtom* aAttrName,
 99618:                       const nsAString& aAttrValue, bool aUniversalMatch)
     1: {
     1:   if (aUniversalMatch ? aContent->HasAttr(kNameSpaceID_None, aAttrName) :
     1:                         aContent->AttrValueIs(kNameSpaceID_None, aAttrName,
     1:                                               aAttrValue, eCaseMatters)) {
 99618:     return aContent;
     1:   }
     1: 
 78992:   for (nsIContent* child = aContent->GetFirstChild();
 78992:        child;
 78992:        child = child->GetNextSibling()) {
 78992: 
 99618:     nsIContent* matchedContent =
 99618:       GetElementByAttribute(child, aAttrName, aAttrValue, aUniversalMatch);
 99618:     if (matchedContent)
 99618:       return matchedContent;
 99618:   }
 99618: 
 99618:   return nsnull;
 99618: }
 99618: 
 99618: nsIContent*
 99618: nsDocument::GetAnonymousElementByAttribute(nsIContent* aElement,
 99618:                                            nsIAtom* aAttrName,
 99618:                                            const nsAString& aAttrValue) const
 99618: {
 99618:   nsINodeList* nodeList = BindingManager()->GetAnonymousNodesFor(aElement);
 99618:   if (!nodeList)
 99618:     return nsnull;
 99618: 
 99618:   PRUint32 length = 0;
 99618:   nodeList->GetLength(&length);
 99618: 
 99618:   bool universalMatch = aAttrValue.EqualsLiteral("*");
 99618: 
 99618:   for (PRUint32 i = 0; i < length; ++i) {
 99618:     nsIContent* current = nodeList->GetNodeAt(i);
 99618:     nsIContent* matchedElm =
 99618:       GetElementByAttribute(current, aAttrName, aAttrValue, universalMatch);
 99618:     if (matchedElm)
 99618:       return matchedElm;
 99618:   }
 99618: 
 99618:   return nsnull;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetAnonymousElementByAttribute(nsIDOMElement* aElement,
     1:                                            const nsAString& aAttrName,
     1:                                            const nsAString& aAttrValue,
     1:                                            nsIDOMElement** aResult)
     1: {
     1:   *aResult = nsnull;
     1: 
     1:   nsCOMPtr<nsIAtom> attribute = do_GetAtom(aAttrName);
 99618:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
 99618: 
 99618:   nsIContent* matchedContent =
 99618:     GetAnonymousElementByAttribute(content, attribute, aAttrValue);
 99618:   return matchedContent ? CallQueryInterface(matchedContent, aResult) : NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetAnonymousNodes(nsIDOMElement* aElement,
     1:                               nsIDOMNodeList** aResult)
     1: {
     1:   *aResult = nsnull;
     1: 
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
 13669:   return BindingManager()->GetAnonymousNodesFor(content, aResult);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateRange(nsIDOMRange** aReturn)
     1: {
 81387:   nsRefPtr<nsRange> range = new nsRange();
 81387:   nsresult rv = range->Set(this, 0, this, 0);
 81387:   NS_ENSURE_SUCCESS(rv, rv);
 81387: 
 81387:   range.forget(aReturn);
 81387:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateNodeIterator(nsIDOMNode *aRoot,
     1:                                PRUint32 aWhatToShow,
     1:                                nsIDOMNodeFilter *aFilter,
 88172:                                PRUint8 aOptionalArgc,
     1:                                nsIDOMNodeIterator **_retval)
     1: {
 16103:   *_retval = nsnull;
 16103: 
 88172:   if (!aOptionalArgc) {
 88172:     aWhatToShow = nsIDOMNodeFilter::SHOW_ALL;
 88172:   }
 88172: 
 94629:   if (!aRoot) {
 16103:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 94629:   }
 94629: 
 94629:   nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
 94629:   NS_ENSURE_TRUE(root, NS_ERROR_UNEXPECTED);
 94629: 
 94629:   nsresult rv = nsContentUtils::CheckSameOrigin(this, root);
 16103:   NS_ENSURE_SUCCESS(rv, rv);
 16103: 
 94629:   nsRefPtr<nsNodeIterator> iterator = new nsNodeIterator(root, aWhatToShow,
 88172:                                                          aFilter);
 94629:   iterator.forget(_retval);
 16103:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateTreeWalker(nsIDOMNode *aRoot,
     1:                              PRUint32 aWhatToShow,
     1:                              nsIDOMNodeFilter *aFilter,
 88172:                              PRUint8 aOptionalArgc,
     1:                              nsIDOMTreeWalker **_retval)
     1: {
     1:   *_retval = nsnull;
     1: 
 88172:   if (!aOptionalArgc) {
 88172:     aWhatToShow = nsIDOMNodeFilter::SHOW_ALL;
 88172:   }
 88172: 
 16103:   if (!aRoot)
     1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1: 
     1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
 16103:   NS_ENSURE_SUCCESS(rv, rv);
 16103: 
 16103:   NS_ENSURE_ARG_POINTER(_retval);
 16103: 
 16103:   nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
 16103:   NS_ENSURE_TRUE(root, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
 16103: 
 16103:   nsTreeWalker* walker = new nsTreeWalker(root,
 16103:                                           aWhatToShow,
 88172:                                           aFilter);
 16103:   NS_ENSURE_TRUE(walker, NS_ERROR_OUT_OF_MEMORY);
 16103: 
 16103:   NS_ADDREF(*_retval = walker);
 16103: 
 16103:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
 69169: nsDocument::GetDefaultView(nsIDOMWindow** aDefaultView)
 69169: {
 69169:   *aDefaultView = nsnull;
 90483:   nsCOMPtr<nsPIDOMWindow> win = GetWindow();
 90483:   win.forget(aDefaultView);
 90483:   return NS_OK;
 68870: }
 68870: 
     1: NS_IMETHODIMP
     1: nsDocument::GetLocation(nsIDOMLocation **_retval)
     1: {
     1:   NS_ENSURE_ARG_POINTER(_retval);
     1:   *_retval = nsnull;
     1: 
 73870:   nsCOMPtr<nsIDOMWindow> w = do_QueryInterface(mScriptGlobalObject);
     1: 
     1:   if (!w) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   return w->GetLocation(_retval);
     1: }
     1: 
 41634: Element*
 41634: nsIDocument::GetHtmlElement()
 41634: {
 41634:   Element* rootElement = GetRootElement();
 73870:   if (rootElement && rootElement->IsHTML(nsGkAtoms::html))
 41634:     return rootElement;
 16977:   return nsnull;
 16977: }
 16977: 
 41634: Element*
 41634: nsIDocument::GetHtmlChildElement(nsIAtom* aTag)
 41634: {
 41634:   Element* html = GetHtmlElement();
 16977:   if (!html)
 16977:     return nsnull;
 16977: 
 16977:   // Look for the element with aTag inside html. This needs to run
 16977:   // forwards to find the first such element.
 78992:   for (nsIContent* child = html->GetFirstChild();
 78992:        child;
 78992:        child = child->GetNextSibling()) {
 78992:     if (child->IsHTML(aTag))
 78992:       return child->AsElement();
 16977:   }
 16977:   return nsnull;
 16977: }
 16977: 
 16977: nsIContent*
 33329: nsDocument::GetTitleContent(PRUint32 aNamespace)
 16977: {
 16977:   // mMayHaveTitleElement will have been set to true if any HTML or SVG
 16977:   // <title> element has been bound to this document. So if it's false,
 16977:   // we know there is nothing to do here. This avoids us having to search
 16977:   // the whole DOM if someone calls document.title on a large document
 16977:   // without a title.
 16977:   if (!mMayHaveTitleElement)
 16977:     return nsnull;
 16977: 
 16977:   nsRefPtr<nsContentList> list =
 63637:     NS_GetContentList(this, aNamespace, NS_LITERAL_STRING("title"));
 16977: 
 79445:   return list->Item(0, false);
 16977: }
 16977: 
 16977: void
 33329: nsDocument::GetTitleFromElement(PRUint32 aNamespace, nsAString& aTitle)
 33329: {
 33329:   nsIContent* title = GetTitleContent(aNamespace);
 16977:   if (!title)
 16977:     return;
 80486:   nsContentUtils::GetNodeTextContent(title, false, aTitle);
 16977: }
 16977: 
     1: NS_IMETHODIMP
     1: nsDocument::GetTitle(nsAString& aTitle)
     1: {
 16977:   aTitle.Truncate();
 16977: 
 41634:   nsIContent *rootElement = GetRootElement();
 41634:   if (!rootElement)
 16977:     return NS_OK;
 16977: 
 16977:   nsAutoString tmp;
 16977: 
 41634:   switch (rootElement->GetNameSpaceID()) {
 16977: #ifdef MOZ_XUL
 16977:     case kNameSpaceID_XUL:
 41634:       rootElement->GetAttr(kNameSpaceID_None, nsGkAtoms::title, tmp);
 16977:       break;
 16977: #endif
 16977:     case kNameSpaceID_SVG:
 41634:       if (rootElement->Tag() == nsGkAtoms::svg) {
 33329:         GetTitleFromElement(kNameSpaceID_SVG, tmp);
 16977:         break;
 16977:       } // else fall through
 16977:     default:
 33329:       GetTitleFromElement(kNameSpaceID_XHTML, tmp);
 16977:       break;
 16977:   }
 16977: 
 16977:   tmp.CompressWhitespace();
 16977:   aTitle = tmp;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::SetTitle(const nsAString& aTitle)
     1: {
 41634:   Element *rootElement = GetRootElement();
 41634:   if (!rootElement)
 41634:     return NS_OK;
 41634: 
 41634:   switch (rootElement->GetNameSpaceID()) {
 16977:     case kNameSpaceID_SVG:
 16977:       return NS_OK; // SVG doesn't support setting a title
 16977: #ifdef MOZ_XUL
 16977:     case kNameSpaceID_XUL:
 41634:       return rootElement->SetAttr(kNameSpaceID_None, nsGkAtoms::title,
 80486:                                   aTitle, true);
 16977: #endif
 16977:   }
 16977: 
 16977:   // Batch updates so that mutation events don't change "the title
 16977:   // element" under us
 80486:   mozAutoDocUpdate updateBatch(this, UPDATE_CONTENT_MODEL, true);
 16977: 
 33329:   nsIContent* title = GetTitleContent(kNameSpaceID_XHTML);
 16977:   if (!title) {
 41634:     Element *head = GetHeadElement();
 16977:     if (!head)
 16977:       return NS_OK;
 16977: 
 16977:     {
 94340:       nsCOMPtr<nsINodeInfo> titleInfo;
 19197:       titleInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::title, nsnull,
 71770:                                                 kNameSpaceID_XHTML,
 71770:                                                 nsIDOMNode::ELEMENT_NODE);
 16977:       if (!titleInfo)
 16977:         return NS_OK;
 48124:       title = NS_NewHTMLTitleElement(titleInfo.forget());
 16977:       if (!title)
 16977:         return NS_OK;
 16977:     }
 16977: 
 80486:     head->AppendChildTo(title, true);
 80486:   }
 80486: 
 80486:   return nsContentUtils::SetNodeTextContent(title, aTitle, false);
 16977: }
 16977: 
 16977: void
 79445: nsDocument::NotifyPossibleTitleChange(bool aBoundTitleElement)
 16977: {
 81557:   NS_ASSERTION(!mInUnlinkOrDeletion || !aBoundTitleElement,
 81557:                "Setting a title while unlinking or destroying the element?");
 81557:   if (mInUnlinkOrDeletion) {
 81557:     return;
 81557:   }
 81557: 
 16977:   if (aBoundTitleElement) {
 80486:     mMayHaveTitleElement = true;
 16977:   }
 16977:   if (mPendingTitleChangeEvent.IsPending())
 16977:     return;
 16977: 
 41359:   nsRefPtr<nsRunnableMethod<nsDocument, void, false> > event =
 41361:     NS_NewNonOwningRunnableMethod(this,
 16977:       &nsDocument::DoNotifyPossibleTitleChange);
 16977:   nsresult rv = NS_DispatchToCurrentThread(event);
 16977:   if (NS_SUCCEEDED(rv)) {
 16977:     mPendingTitleChangeEvent = event;
 16977:   }
 16977: }
 16977: 
 16977: void
 16977: nsDocument::DoNotifyPossibleTitleChange()
 16977: {
 16977:   mPendingTitleChangeEvent.Forget();
 80486:   mHaveFiredTitleChange = true;
 16977: 
 16977:   nsAutoString title;
 16977:   GetTitle(title);
 16977: 
 46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:   if (shell) {
     1:     nsCOMPtr<nsISupports> container = shell->GetPresContext()->GetContainer();
 36917:     if (container) {
     1:       nsCOMPtr<nsIBaseWindow> docShellWin = do_QueryInterface(container);
 36917:       if (docShellWin) {
 71728:         docShellWin->SetTitle(title.get());
 16977:       }
 36917:     }
 36917:   }
     1: 
     1:   // Fire a DOM event for the title change.
 25813:   nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
     1:                                       NS_LITERAL_STRING("DOMTitleChanged"),
 80486:                                       true, true);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
     1: {
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
     1:   NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
  1839: 
 80526:   nsIDocument* doc = content->OwnerDoc();
  1839:   NS_ENSURE_TRUE(doc == this, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
     1: 
 33329:   if (!mHasWarnedAboutBoxObjects && !content->IsXUL()) {
 80486:     mHasWarnedAboutBoxObjects = true;
 84636:     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                     "BoxObjects", this,
 84636:                                     nsContentUtils::eDOM_PROPERTIES,
 84636:                                     "UseOfGetBoxObjectForWarning");
 11731:   }
 11731: 
     1:   *aResult = nsnull;
     1: 
     1:   if (!mBoxObjectTable) {
 93686:     mBoxObjectTable = new nsInterfaceHashtable<nsPtrHashKey<nsIContent>, nsPIBoxObject>;
 98908:     mBoxObjectTable->Init(12);
     1:   } else {
     1:     // Want to use Get(content, aResult); but it's the wrong type
     1:     *aResult = mBoxObjectTable->GetWeak(content);
     1:     if (*aResult) {
     1:       NS_ADDREF(*aResult);
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   PRInt32 namespaceID;
 13669:   nsCOMPtr<nsIAtom> tag = BindingManager()->ResolveTag(content, &namespaceID);
     1: 
     1:   nsCAutoString contractID("@mozilla.org/layout/xul-boxobject");
     1:   if (namespaceID == kNameSpaceID_XUL) {
     1:     if (tag == nsGkAtoms::browser ||
     1:         tag == nsGkAtoms::editor ||
     1:         tag == nsGkAtoms::iframe)
     1:       contractID += "-container";
     1:     else if (tag == nsGkAtoms::menu)
     1:       contractID += "-menu";
     1:     else if (tag == nsGkAtoms::popup ||
     1:              tag == nsGkAtoms::menupopup ||
  3129:              tag == nsGkAtoms::panel ||
     1:              tag == nsGkAtoms::tooltip)
     1:       contractID += "-popup";
     1:     else if (tag == nsGkAtoms::tree)
     1:       contractID += "-tree";
     1:     else if (tag == nsGkAtoms::listbox)
     1:       contractID += "-listbox";
     1:     else if (tag == nsGkAtoms::scrollbox)
     1:       contractID += "-scrollbox";
     1:   }
     1:   contractID += ";1";
     1: 
     1:   nsCOMPtr<nsPIBoxObject> boxObject(do_CreateInstance(contractID.get()));
     1:   if (!boxObject)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   boxObject->Init(content);
     1: 
     1:   if (mBoxObjectTable) {
     1:     mBoxObjectTable->Put(content, boxObject.get());
     1:   }
     1: 
     1:   *aResult = boxObject;
     1:   NS_ADDREF(*aResult);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsDocument::ClearBoxObjectFor(nsIContent* aContent)
     1: {
     1:   if (mBoxObjectTable) {
     1:     nsPIBoxObject *boxObject = mBoxObjectTable->GetWeak(aContent);
     1:     if (boxObject) {
     1:       boxObject->Clear();
     1:       mBoxObjectTable->Remove(aContent);
     1:     }
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsDocument::GetXBLChildNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult)
     1: {
 13669:   return BindingManager()->GetXBLChildNodesFor(aContent, aResult);
     1: }
     1: 
     1: nsresult
     1: nsDocument::GetContentListFor(nsIContent* aContent, nsIDOMNodeList** aResult)
     1: {
 13669:   return BindingManager()->GetContentListFor(aContent, aResult);
     1: }
     1: 
     1: void
     1: nsDocument::FlushSkinBindings()
     1: {
 13669:   BindingManager()->FlushSkinBindings();
     1: }
     1: 
 12256: nsresult
 13433: nsDocument::InitializeFrameLoader(nsFrameLoader* aLoader)
 13433: {
 13433:   mInitializableFrameLoaders.RemoveElement(aLoader);
 13433:   // Don't even try to initialize.
 13433:   if (mInDestructor) {
 13433:     NS_WARNING("Trying to initialize a frame loader while"
 13433:                "document is being deleted");
 13433:     return NS_ERROR_FAILURE;
 13433:   }
 23256: 
 13433:   mInitializableFrameLoaders.AppendElement(aLoader);
 23256:   if (!mFrameLoaderRunner) {
 24482:     mFrameLoaderRunner =
 41361:       NS_NewRunnableMethod(this, &nsDocument::MaybeInitializeFinalizeFrameLoaders);
 23256:     NS_ENSURE_TRUE(mFrameLoaderRunner, NS_ERROR_OUT_OF_MEMORY);
 23256:     nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
 13433:   }
 13433:   return NS_OK;
 13433: }
 13433: 
 13433: nsresult
 12256: nsDocument::FinalizeFrameLoader(nsFrameLoader* aLoader)
 12256: {
 13433:   mInitializableFrameLoaders.RemoveElement(aLoader);
 12256:   if (mInDestructor) {
 12256:     return NS_ERROR_FAILURE;
 12256:   }
 23256: 
 12256:   mFinalizableFrameLoaders.AppendElement(aLoader);
 23256:   if (!mFrameLoaderRunner) {
 24482:     mFrameLoaderRunner =
 41361:       NS_NewRunnableMethod(this, &nsDocument::MaybeInitializeFinalizeFrameLoaders);
 23256:     NS_ENSURE_TRUE(mFrameLoaderRunner, NS_ERROR_OUT_OF_MEMORY);
 23256:     nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
 12256:   }
 12256:   return NS_OK;
 12256: }
 12256: 
 14464: void
 24482: nsDocument::MaybeInitializeFinalizeFrameLoaders()
 24482: {
 24482:   if (mDelayFrameLoaderInitialization || mUpdateNestLevel != 0) {
 24482:     // This method will be recalled when mUpdateNestLevel drops to 0,
 24482:     // or when !mDelayFrameLoaderInitialization.
 23256:     mFrameLoaderRunner = nsnull;
 23256:     return;
 23256:   }
 23256: 
 24482:   // We're not in an update, but it is not safe to run scripts, so
 24482:   // postpone frameloader initialization and finalization.
 24482:   if (!nsContentUtils::IsSafeToRunScript()) {
 24482:     if (!mInDestructor && !mFrameLoaderRunner &&
 24482:         (mInitializableFrameLoaders.Length() ||
 24482:          mFinalizableFrameLoaders.Length())) {
 24482:       mFrameLoaderRunner =
 41361:         NS_NewRunnableMethod(this, &nsDocument::MaybeInitializeFinalizeFrameLoaders);
 24482:       nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
 24482:     }
 24482:     return;
 24482:   }
 24482:   mFrameLoaderRunner = nsnull;
 24482: 
 14660:   // Don't use a temporary array for mInitializableFrameLoaders, because
 14660:   // loading a frame may cause some other frameloader to be removed from the
 14660:   // array. But be careful to keep the loader alive when starting the load!
 14660:   while (mInitializableFrameLoaders.Length()) {
 14660:     nsRefPtr<nsFrameLoader> loader = mInitializableFrameLoaders[0];
 14660:     mInitializableFrameLoaders.RemoveElementAt(0);
 14660:     NS_ASSERTION(loader, "null frameloader in the array?");
 14660:     loader->ReallyStartLoading();
 14660:   }
 14660: 
 14660:   PRUint32 length = mFinalizableFrameLoaders.Length();
 14464:   if (length > 0) {
 14464:     nsTArray<nsRefPtr<nsFrameLoader> > loaders;
 14464:     mFinalizableFrameLoaders.SwapElements(loaders);
 14464:     for (PRUint32 i = 0; i < length; ++i) {
 14464:       loaders[i]->Finalize();
 14464:     }
 14464:   }
 14464: }
 14464: 
 14660: void
 14660: nsDocument::TryCancelFrameLoaderInitialization(nsIDocShell* aShell)
 14660: {
 14660:   PRUint32 length = mInitializableFrameLoaders.Length();
 14660:   for (PRUint32 i = 0; i < length; ++i) {
 14660:     if (mInitializableFrameLoaders[i]->GetExistingDocShell() == aShell) {
 14660:       mInitializableFrameLoaders.RemoveElementAt(i);
 14660:       return;
 14660:     }
 14660:   }
 14660: }
 14660: 
 79445: bool
 14757: nsDocument::FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell)
 14757: {
 14757:   if (aShell) {
 14757:     PRUint32 length = mFinalizableFrameLoaders.Length();
 14757:     for (PRUint32 i = 0; i < length; ++i) {
 14757:       if (mFinalizableFrameLoaders[i]->GetExistingDocShell() == aShell) {
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
 14757: }
 14757: 
 20078: nsIDocument*
 20078: nsDocument::RequestExternalResource(nsIURI* aURI,
 20078:                                     nsINode* aRequestingNode,
 20078:                                     ExternalResourceLoad** aPendingLoad)
 20078: {
 20078:   NS_PRECONDITION(aURI, "Must have a URI");
 20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
 20078:   if (mDisplayDocument) {
 20078:     return mDisplayDocument->RequestExternalResource(aURI,
 20078:                                                      aRequestingNode,
 20078:                                                      aPendingLoad);
 20078:   }
 20078: 
 20078:   return mExternalResourceMap.RequestResource(aURI, aRequestingNode,
 20078:                                               this, aPendingLoad);
 20078: }
 20078: 
 20078: void
 20078: nsDocument::EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData)
 20078: {
 20078:   mExternalResourceMap.EnumerateResources(aCallback, aData);
 20078: }
 20078: 
 23697: nsSMILAnimationController*
 23697: nsDocument::GetAnimationController()
 23697: {
 23697:   // We create the animation controller lazily because most documents won't want
 23697:   // one and only SVG documents and the like will call this
 23697:   if (mAnimationController)
 23697:     return mAnimationController;
 35510:   // Refuse to create an Animation Controller if SMIL is disabled, and also
 35510:   // for data documents.
 36884:   if (!NS_SMILEnabled() || mLoadedAsData || mLoadedAsInteractiveData)
 25961:     return nsnull;
 23697: 
 69077:   mAnimationController = new nsSMILAnimationController(this);
 23697:   
 23697:   // If there's a presContext then check the animation mode and pause if
 23697:   // necessary.
 46225:   nsIPresShell *shell = GetShell();
 23697:   if (mAnimationController && shell) {
 23697:     nsPresContext *context = shell->GetPresContext();
 23697:     if (context &&
 23697:         context->ImageAnimationMode() == imgIContainer::kDontAnimMode) {
 23697:       mAnimationController->Pause(nsSMILTimeContainer::PAUSE_USERPREF);
 23697:     }
 23697:   }
 23697: 
 57187:   // If we're hidden (or being hidden), notify the newly-created animation
 57187:   // controller. (Skip this check for SVG-as-an-image documents, though,
 57187:   // because they don't get OnPageShow / OnPageHide calls).
 57187:   if (!mIsShowing && !mIsBeingUsedAsImage) {
 57025:     mAnimationController->OnPageHide();
 57025:   }
 57025: 
 23697:   return mAnimationController;
 23697: }
 23697: 
     1: struct DirTable {
     1:   const char* mName;
     1:   PRUint8     mValue;
     1: };
     1: 
     1: static const DirTable dirAttributes[] = {
     1:   {"ltr", IBMBIDI_TEXTDIRECTION_LTR},
     1:   {"rtl", IBMBIDI_TEXTDIRECTION_RTL},
     1:   {0}
     1: };
     1: 
     1: /**
     1:  * Retrieve the "direction" property of the document.
     1:  *
     1:  * @lina 01/09/2001
     1:  */
     1: NS_IMETHODIMP
     1: nsDocument::GetDir(nsAString& aDirection)
     1: {
     1:   PRUint32 options = GetBidiOptions();
     1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
     1:     if (GET_BIDI_OPTION_DIRECTION(options) == elt->mValue) {
     1:       CopyASCIItoUTF16(elt->mName, aDirection);
     1:       break;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /**
     1:  * Set the "direction" property of the document.
     1:  *
     1:  * @lina 01/09/2001
     1:  */
     1: NS_IMETHODIMP
     1: nsDocument::SetDir(const nsAString& aDirection)
     1: {
     1:   PRUint32 options = GetBidiOptions();
     1: 
     1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
     1:     if (aDirection == NS_ConvertASCIItoUTF16(elt->mName)) {
     1:       if (GET_BIDI_OPTION_DIRECTION(options) != elt->mValue) {
     1:         SET_BIDI_OPTION_DIRECTION(options, elt->mValue);
 46225:         nsIPresShell *shell = GetShell();
     1:         if (shell) {
     1:           nsPresContext *context = shell->GetPresContext();
     1:           NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
 80486:           context->SetBidi(options, true);
     1:         } else {
     1:           // No presentation; just set it on ourselves
     1:           SetBidiOptions(options);
     1:         }
     1:       }
     1: 
     1:       break;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //
     1: // nsIDOMNode methods
     1: //
     1: NS_IMETHODIMP
     1: nsDocument::GetNodeName(nsAString& aNodeName)
     1: {
     1:   aNodeName.AssignLiteral("#document");
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetNodeValue(nsAString& aNodeValue)
     1: {
     1:   SetDOMStringToNull(aNodeValue);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::SetNodeValue(const nsAString& aNodeValue)
     1: {
     1:   // The DOM spec says that when nodeValue is defined to be null "setting it
     1:   // has no effect", so we don't throw an exception.
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetNodeType(PRUint16* aNodeType)
     1: {
     1:   *aNodeType = nsIDOMNode::DOCUMENT_NODE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetParentNode(nsIDOMNode** aParentNode)
     1: {
     1:   *aParentNode = nsnull;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 78189: nsDocument::GetParentElement(nsIDOMElement** aParentElement)
 78189: {
 78189:   *aParentElement = nsnull;
 78189:   return NS_OK;
 78189: }
 78189: 
 78189: NS_IMETHODIMP
     1: nsDocument::GetChildNodes(nsIDOMNodeList** aChildNodes)
     1: {
 23258:   return nsINode::GetChildNodes(aChildNodes);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDocument::HasChildNodes(bool* aHasChildNodes)
     1: {
     1:   NS_ENSURE_ARG(aHasChildNodes);
     1: 
     1:   *aHasChildNodes = (mChildren.ChildCount() != 0);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDocument::HasAttributes(bool* aHasAttributes)
     1: {
     1:   NS_ENSURE_ARG(aHasAttributes);
     1: 
 80486:   *aHasAttributes = false;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetFirstChild(nsIDOMNode** aFirstChild)
     1: {
 23258:   return nsINode::GetFirstChild(aFirstChild);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetLastChild(nsIDOMNode** aLastChild)
     1: {
 23258:   return nsINode::GetLastChild(aLastChild);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetPreviousSibling(nsIDOMNode** aPreviousSibling)
     1: {
     1:   *aPreviousSibling = nsnull;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetNextSibling(nsIDOMNode** aNextSibling)
     1: {
     1:   *aNextSibling = nsnull;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
     1: {
     1:   *aAttributes = nsnull;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetNamespaceURI(nsAString& aNamespaceURI)
     1: {
     1:   SetDOMStringToNull(aNamespaceURI);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetPrefix(nsAString& aPrefix)
     1: {
     1:   SetDOMStringToNull(aPrefix);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetLocalName(nsAString& aLocalName)
     1: {
     1:   SetDOMStringToNull(aLocalName);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
     1:                          nsIDOMNode** aReturn)
     1: {
 80486:   return ReplaceOrInsertBefore(false, aNewChild, aRefChild, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
     1:                          nsIDOMNode** aReturn)
     1: {
 80486:   return ReplaceOrInsertBefore(true, aNewChild, aOldChild, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
     1: {
 39585:   return nsINode::RemoveChild(aOldChild, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
     1: {
     1:   return nsDocument::InsertBefore(aNewChild, nsnull, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
 90796: nsDocument::CloneNode(bool aDeep, PRUint8 aOptionalArgc, nsIDOMNode** aReturn)
 90796: {
 90796:   if (!aOptionalArgc) {
 90796:     aDeep = true;
 90796:   }
 90796:   
 58904:   return nsNodeUtils::CloneNodeImpl(this, aDeep, !mCreatingStaticClone, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::Normalize()
     1: {
 72437:   return nsIDocument::Normalize();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::IsSupported(const nsAString& aFeature, const nsAString& aVersion,
 79445:                         bool* aReturn)
     1: {
  3233:   return nsGenericElement::InternalIsSupported(static_cast<nsIDOMDocument*>(this),
     1:                                                aFeature, aVersion, aReturn);
     1: }
     1: 
 71768: NS_IMETHODIMP
 71768: nsDocument::GetDOMBaseURI(nsAString &aURI)
 71768: {
 71768:   return nsIDocument::GetDOMBaseURI(aURI);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
     1: nsDocument::GetTextContent(nsAString &aTextContent)
     1: {
     1:   SetDOMStringToNull(aTextContent);
 71768:   return NS_OK;
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 79445: nsDocument::IsEqualNode(nsIDOMNode* aOther, bool* aResult)
 71768: {
 71769:   return nsINode::IsEqualNode(aOther, aResult);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::CompareDocumentPosition(nsIDOMNode *other,
 71768:                                    PRUint16 *aResult)
 71768: {
 71768:   return nsINode::CompareDocumentPosition(other, aResult);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::SetTextContent(const nsAString & aTextContent)
 71768: {
 71768:   return nsINode::SetTextContent(aTextContent);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::LookupPrefix(const nsAString & namespaceURI, nsAString & aResult)
 71768: {
 88543:   return nsINode::LookupPrefix(namespaceURI, aResult);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::IsDefaultNamespace(const nsAString & namespaceURI,
 79445:                               bool *aResult)
 71768: {
 88543:   return nsINode::IsDefaultNamespace(namespaceURI, aResult);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::LookupNamespaceURI(const nsAString & prefix,
 71768:                               nsAString & aResult)
 71768: {
 88543:   return nsINode::LookupNamespaceURI(prefix, aResult);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::SetUserData(const nsAString & key,
 71768:                        nsIVariant *data, nsIDOMUserDataHandler *handler,
 71768:                        nsIVariant **aResult)
 71768: {
 71768:   return nsINode::SetUserData(key, data, handler, aResult);
 71768: }
 71768: 
 71768: NS_IMETHODIMP
 71768: nsDocument::GetUserData(const nsAString & key,
 71768:                         nsIVariant **aResult)
 71768: {
 71768:   return nsINode::GetUserData(key, aResult);
 41906: }
 41906: 
 41906: NS_IMETHODIMP
 79445: nsDocument::Contains(nsIDOMNode* aOther, bool* aReturn)
 77764: {
 77764:   return nsINode::Contains(aOther, aReturn);
 77764: }
 77764: 
 77764: NS_IMETHODIMP
     1: nsDocument::GetInputEncoding(nsAString& aInputEncoding)
     1: {
 79009:   WarnOnceAbout(eInputEncoding);
 16447:   if (mHaveInputEncoding) {
     1:     return GetCharacterSet(aInputEncoding);
     1:   }
     1: 
 16447:   SetDOMStringToNull(aInputEncoding);
 16447:   return NS_OK;
 16447: }
 16447: 
     1: NS_IMETHODIMP
 79445: nsDocument::GetMozSyntheticDocument(bool *aSyntheticDocument)
 75189: {
 75189:   *aSyntheticDocument = mIsSyntheticDocument;
 75189:   return NS_OK;
 75189: }
 75189: 
 75189: NS_IMETHODIMP
     1: nsDocument::GetDocumentURI(nsAString& aDocumentURI)
     1: {
     1:   if (mDocumentURI) {
     1:     nsCAutoString uri;
     1:     mDocumentURI->GetSpec(uri);
     1:     CopyUTF8toUTF16(uri, aDocumentURI);
     1:   } else {
     1:     SetDOMStringToNull(aDocumentURI);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static void BlastSubtreeToPieces(nsINode *aNode);
     1: 
 20261: PLDHashOperator
 47799: BlastFunc(nsAttrHashKey::KeyType aKey, nsDOMAttribute *aData, void* aUserArg)
     1: {
     1:   nsCOMPtr<nsIAttribute> *attr =
  3233:     static_cast<nsCOMPtr<nsIAttribute>*>(aUserArg);
     1: 
 47799:   *attr = aData;
     1: 
     1:   NS_ASSERTION(attr->get(),
     1:                "non-nsIAttribute somehow made it into the hashmap?!");
     1: 
     1:   return PL_DHASH_STOP;
     1: }
     1: 
     1: static void
     1: BlastSubtreeToPieces(nsINode *aNode)
     1: {
 41636:   if (aNode->IsElement()) {
  3233:     nsGenericElement *element = static_cast<nsGenericElement*>(aNode);
     1:     const nsDOMAttributeMap *map = element->GetAttributeMap();
     1:     if (map) {
     1:       nsCOMPtr<nsIAttribute> attr;
     1:       while (map->Enumerate(BlastFunc, &attr) > 0) {
     1:         BlastSubtreeToPieces(attr);
     1: 
 19629: #ifdef DEBUG
 19629:         nsresult rv =
 19629: #endif
 19629:           element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
     1:                              attr->NodeInfo()->NameAtom(),
 80486:                              false);
     1: 
     1:         // XXX Should we abort here?
     1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
     1:       }
     1:     }
     1:   }
     1: 
 94359:   PRUint32 count = aNode->GetChildCount();
 94359:   for (PRUint32 i = 0; i < count; ++i) {
 78992:     BlastSubtreeToPieces(aNode->GetFirstChild());
 80486:     aNode->RemoveChildAt(0, false);
     1:   }
     1: }
     1: 
 69574: 
 69574: class nsUserDataCaller : public nsRunnable
 69574: {
 69574: public:
 69574:   nsUserDataCaller(nsCOMArray<nsINode>& aNodesWithProperties,
 69574:                    nsIDocument* aOwnerDoc)
 69574:     : mNodesWithProperties(aNodesWithProperties),
 69574:       mOwnerDoc(aOwnerDoc)
 69574:   {
 69574:   }
 69574: 
 69574:   NS_IMETHOD Run()
 69574:   {
 69574:     nsNodeUtils::CallUserDataHandlers(mNodesWithProperties, mOwnerDoc,
 69574:                                       nsIDOMUserDataHandler::NODE_ADOPTED,
 80486:                                       false);
 69574:     return NS_OK;
 69574:   }
 69574: 
 69574: private:
 69574:   nsCOMArray<nsINode> mNodesWithProperties;
 69574:   nsCOMPtr<nsIDocument> mOwnerDoc;
 69574: };
 69574: 
 94631: /**
 94631:  * Get a scope from aNewDocument. Also get a context through the scope of one
 94631:  * of the documents, from the stack or the safe context.
 94631:  *
 94631:  * @param aOldDocument The document to try to get a context from.
 94631:  * @param aNewDocument The document to get aNewScope from.
 94631:  * @param aCx [out] Context gotten through one of the scopes, from the stack
 94631:  *                  or the safe context.
 94631:  * @param aNewScope [out] Scope gotten from aNewDocument.
 94631:  */
 94631: static nsresult
 94631: GetContextAndScope(nsIDocument* aOldDocument, nsIDocument* aNewDocument,
 94631:                    JSContext** aCx, JSObject** aNewScope)
 94631: {
 94631:   MOZ_ASSERT(aOldDocument);
 94631:   MOZ_ASSERT(aNewDocument);
 94631: 
 94631:   *aCx = nsnull;
 94631:   *aNewScope = nsnull;
 94631: 
 94631:   JSObject* newScope = aNewDocument->GetWrapper();
 94631:   JSObject* global;
 94631:   if (!newScope) {
 94631:     nsIScriptGlobalObject *newSGO = aNewDocument->GetScopeObject();
 94631:     if (!newSGO || !(global = newSGO->GetGlobalJSObject())) {
 94631:       return NS_OK;
 94631:     }
 94631:   }
 94631: 
 94631:   JSContext* cx = nsContentUtils::GetContextFromDocument(aOldDocument);
 94631:   if (!cx) {
 94631:     cx = nsContentUtils::GetContextFromDocument(aNewDocument);
 94631: 
 94631:     if (!cx) {
 94631:       // No context reachable from the old or new document, use the
 94631:       // calling context, or the safe context if no caller can be
 94631:       // found.
 94631: 
 94631:       nsIThreadJSContextStack* stack = nsContentUtils::ThreadJSContextStack();
 94631:       stack->Peek(&cx);
 94631: 
 94631:       if (!cx) {
 97744:         cx = stack->GetSafeJSContext();
 94631: 
 94631:         if (!cx) {
 94631:           // No safe context reachable, bail.
 94631:           NS_WARNING("No context reachable in GetContextAndScopes()!");
 94631: 
 94631:           return NS_ERROR_NOT_AVAILABLE;
 94631:         }
 94631:       }
 94631:     }
 94631:   }
 94631: 
 94631:   if (!newScope && cx) {
 94631:     JS::Value v;
 94631:     nsresult rv = nsContentUtils::WrapNative(cx, global, aNewDocument,
 94631:                                              aNewDocument, &v);
 94631:     NS_ENSURE_SUCCESS(rv, rv);
 94631: 
 94631:     newScope = JSVAL_TO_OBJECT(v);
 94631:   }
 94631: 
 94631:   *aCx = cx;
 94631:   *aNewScope = newScope;
 94631: 
 94631:   return NS_OK;
 94631: }
 94631: 
     1: NS_IMETHODIMP
     1: nsDocument::AdoptNode(nsIDOMNode *aAdoptedNode, nsIDOMNode **aResult)
     1: {
     1:   NS_ENSURE_ARG(aAdoptedNode);
     1: 
     1:   *aResult = nsnull;
     1: 
 94629:   nsCOMPtr<nsINode> adoptedNode = do_QueryInterface(aAdoptedNode);
 94629:   NS_ENSURE_TRUE(adoptedNode, NS_ERROR_UNEXPECTED);
 94629: 
 94629:   nsresult rv = nsContentUtils::CheckSameOrigin(this, adoptedNode);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 69574:   // Scope firing mutation events so that we don't carry any state that
 69574:   // might be stale
 69574:   {
 69574:     nsINode* parent = adoptedNode->GetNodeParent();
 69574:     if (parent) {
 69574:       nsContentUtils::MaybeFireNodeRemoved(adoptedNode, parent,
 80526:                                            adoptedNode->OwnerDoc());
 69574:     }
 69574:   }
 69574: 
 69574:   nsAutoScriptBlocker scriptBlocker;
 69574: 
 94629:   switch (adoptedNode->NodeType()) {
     1:     case nsIDOMNode::ATTRIBUTE_NODE:
     1:     {
     1:       // Remove from ownerElement.
 69574:       nsCOMPtr<nsIDOMAttr> adoptedAttr = do_QueryInterface(aAdoptedNode);
 69574:       NS_ASSERTION(adoptedAttr, "Attribute not implementing nsIDOMAttr");
     1: 
     1:       nsCOMPtr<nsIDOMElement> ownerElement;
     1:       rv = adoptedAttr->GetOwnerElement(getter_AddRefs(ownerElement));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:       if (ownerElement) {
     1:         nsCOMPtr<nsIDOMAttr> newAttr;
     1:         rv = ownerElement->RemoveAttributeNode(adoptedAttr,
     1:                                                getter_AddRefs(newAttr));
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:         newAttr.swap(adoptedAttr);
     1:       }
     1: 
     1:       break;
     1:     }
     1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
     1:     case nsIDOMNode::ELEMENT_NODE:
     1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
     1:     case nsIDOMNode::TEXT_NODE:
     1:     case nsIDOMNode::CDATA_SECTION_NODE:
     1:     case nsIDOMNode::COMMENT_NODE:
 78421:     case nsIDOMNode::DOCUMENT_TYPE_NODE:
     1:     {
     1:       // We don't want to adopt an element into its own contentDocument or into
     1:       // a descendant contentDocument, so we check if the frameElement of this
     1:       // document or any of its parents is the adopted node or one of its
     1:       // descendants.
     1:       nsIDocument *doc = this;
     1:       do {
     1:         nsPIDOMWindow *win = doc->GetWindow();
     1:         if (win) {
     1:           nsCOMPtr<nsINode> node =
     1:             do_QueryInterface(win->GetFrameElementInternal());
     1:           if (node &&
     1:               nsContentUtils::ContentIsDescendantOf(node, adoptedNode)) {
     1:             return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
     1:           }
     1:         }
     1:       } while ((doc = doc->GetParentDocument()));
     1: 
     1:       // Remove from parent.
 77014:       nsCOMPtr<nsINode> parent = adoptedNode->GetNodeParent();
     1:       if (parent) {
 94359:         parent->RemoveChildAt(parent->IndexOf(adoptedNode), true);
     1:       }
     1: 
     1:       break;
     1:     }
     1:     case nsIDOMNode::DOCUMENT_NODE:
     1:     {
     1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1:     }
     1:     default:
     1:     {
     1:       NS_WARNING("Don't know how to adopt this nodetype for adoptNode.");
     1: 
     1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1:     }
     1:   }
     1: 
 80526:   nsIDocument *oldDocument = adoptedNode->OwnerDoc();
 79445:   bool sameDocument = oldDocument == this;
     1: 
     1:   JSContext *cx = nsnull;
     1:   JSObject *newScope = nsnull;
 59445:   if (!sameDocument) {
 94631:     rv = GetContextAndScope(oldDocument, this, &cx, &newScope);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   nsCOMArray<nsINode> nodesWithProperties;
     1:   rv = nsNodeUtils::Adopt(adoptedNode, sameDocument ? nsnull : mNodeInfoManager,
 59445:                           cx, newScope, nodesWithProperties);
     1:   if (NS_FAILED(rv)) {
     1:     // Disconnect all nodes from their parents, since some have the old document
     1:     // as their ownerDocument and some have this as their ownerDocument.
     1:     BlastSubtreeToPieces(adoptedNode);
     1: 
     1:     if (!sameDocument && oldDocument) {
 41182:       PRUint32 count = nodesWithProperties.Count();
 41182:       for (PRUint32 j = 0; j < oldDocument->GetPropertyTableCount(); ++j) {
 41182:         for (PRUint32 i = 0; i < count; ++i) {
     1:           // Remove all properties.
 41182:           oldDocument->PropertyTable(j)->
     1:             DeleteAllPropertiesFor(nodesWithProperties[i]);
     1:         }
     1:       }
 41182:     }
     1: 
     1:     return rv;
     1:   }
     1: 
 41182:   PRUint32 count = nodesWithProperties.Count();
     1:   if (!sameDocument && oldDocument) {
 41182:     for (PRUint32 j = 0; j < oldDocument->GetPropertyTableCount(); ++j) {
 41182:       nsPropertyTable *oldTable = oldDocument->PropertyTable(j);
 41182:       nsPropertyTable *newTable = PropertyTable(j);
 41182:       for (PRUint32 i = 0; i < count; ++i) {
 41182:         if (NS_SUCCEEDED(rv)) {
     1:           rv = oldTable->TransferOrDeleteAllPropertiesFor(nodesWithProperties[i],
     1:                                                           newTable);
 41182:         } else {
 41182:           oldTable->DeleteAllPropertiesFor(nodesWithProperties[i]);
 41182:         }
 41182:       }
 41182:     }
 41182: 
     1:     if (NS_FAILED(rv)) {
     1:       // Disconnect all nodes from their parents.
     1:       BlastSubtreeToPieces(adoptedNode);
     1: 
     1:       return rv;
     1:     }
     1:   }
     1: 
 69574:   if (nodesWithProperties.Count()) {
 69574:     nsContentUtils::AddScriptRunner(new nsUserDataCaller(nodesWithProperties,
 69574:                                                          this));
 69574:   }
 69574: 
 80526:   NS_ASSERTION(adoptedNode->OwnerDoc() == this,
 69574:                "Should still be in the document we just got adopted into");
 39584: 
 94629:   NS_ADDREF(*aResult = aAdoptedNode);
 94629:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
     1: {
 23258:   return nsINode::GetOwnerDocument(aOwnerDocument);
     1: }
     1: 
 72328: nsEventListenerManager*
 79445: nsDocument::GetListenerManager(bool aCreateIfNotFound)
 29474: {
 72328:   if (!mListenerManager && aCreateIfNotFound) {
 72328:     mListenerManager =
 72328:       new nsEventListenerManager(static_cast<nsIDOMEventTarget*>(this));
 91087:     SetFlags(NODE_HAS_LISTENERMANAGER);
 72328:   }
 72298: 
 29474:   return mListenerManager;
     1: }
     1: 
     1: nsresult
     1: nsDocument::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
     1: {
 80486:   aVisitor.mCanHandle = true;
     1:    // FIXME! This is a hack to make middle mouse paste working also in Editor.
     1:    // Bug 329119
 80486:   aVisitor.mForceContentDispatch = true;
     1: 
     1:   // Load events must not propagate to |window| object, see bug 335251.
     1:   if (aVisitor.mEvent->message != NS_LOAD) {
 74957:     nsGlobalWindow* window = static_cast<nsGlobalWindow*>(GetWindow());
 74957:     aVisitor.mParentTarget = static_cast<nsIDOMEventTarget*>(window);
 72298:   }
 72298:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::CreateEvent(const nsAString& aEventType, nsIDOMEvent** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   *aReturn = nsnull;
     1: 
     1:   // Obtain a presentation shell
     1: 
 46225:   nsIPresShell *shell = GetShell();
     1: 
     1:   nsPresContext *presContext = nsnull;
     1: 
     1:   if (shell) {
     1:     // Retrieve the context
     1:     presContext = shell->GetPresContext();
     1:   }
     1: 
     1:   // Create event even without presContext.
     1:   return nsEventDispatcher::CreateEvent(presContext, nsnull,
     1:                                         aEventType, aReturn);
     1: }
     1: 
 69754: void
 69754: nsDocument::FlushPendingNotifications(mozFlushType aType)
 69754: {
 84598:   // We need to flush the sink for non-HTML documents (because the XML
 84598:   // parser still does insertion with deferred notifications).  We
 84598:   // also need to flush the sink if this is a layout-related flush, to
 84598:   // make sure that layout is started as needed.  But we can skip that
 84598:   // part if we have no presshell or if it's already done an initial
 84598:   // reflow.
 84598:   if ((!IsHTML() ||
 84598:        (aType > Flush_ContentAndNotify && mPresShell &&
 84598:         !mPresShell->DidInitialReflow())) &&
 69754:       (mParser || mWeakSink)) {
  6170:     nsCOMPtr<nsIContentSink> sink;
  6170:     if (mParser) {
  6170:       sink = mParser->GetContentSink();
  6170:     } else {
  6170:       sink = do_QueryReferent(mWeakSink);
 42227:       if (!sink) {
 42227:         mWeakSink = nsnull;
 42227:       }
  6170:     }
     1:     // Determine if it is safe to flush the sink notifications
     1:     // by determining if it safe to flush all the presshells.
  6170:     if (sink && (aType == Flush_Content || IsSafeToFlush())) {
     1:       sink->FlushPendingNotifications(aType);
     1:     }
 42227:   }
     1: 
     1:   // Should we be flushing pending binding constructors in here?
     1: 
 19869:   if (aType <= Flush_ContentAndNotify) {
     1:     // Nothing to do here
     1:     return;
     1:   }
     1: 
     1:   // If we have a parent we must flush the parent too to ensure that our
 30709:   // container is reflowed if its size was changed.  But if it's not safe to
 11417:   // flush ourselves, then don't flush the parent, since that can cause things
 11417:   // like resizes of our frame's widget, which we can't handle while flushing
 11417:   // is unsafe.
 16227:   // Since media queries mean that a size change of our container can
 16227:   // affect style, we need to promote a style flush on ourself to a
 16227:   // layout flush on our parent, since we need our container to be the
 16227:   // correct size to determine the correct style.
 11417:   if (mParentDocument && IsSafeToFlush()) {
 16227:     mozFlushType parentType = aType;
 27993:     if (aType >= Flush_Style)
 38390:       parentType = NS_MAX(Flush_Layout, aType);
 16227:     mParentDocument->FlushPendingNotifications(parentType);
     1:   }
     1: 
 84597:   // We can optimize away getting our presshell and calling
 84597:   // FlushPendingNotifications on it if we don't need a flush of the sort we're
 84597:   // looking at.  The one exception is if mInFlush is true, because in that
 84597:   // case we might have set mNeedStyleFlush and mNeedLayoutFlush to false
 84597:   // already but the presshell hasn't actually done the corresponding work yet.
 84597:   // So if mInFlush and reentering this code, we need to flush the presshell.
 84597:   if (mNeedStyleFlush ||
 84597:       (mNeedLayoutFlush && aType >= Flush_InterruptibleLayout) ||
 84597:       aType >= Flush_Display ||
 84597:       mInFlush) {
 46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
 36917:     if (shell) {
 84597:       mNeedStyleFlush = false;
 84597:       mNeedLayoutFlush = mNeedLayoutFlush && (aType < Flush_InterruptibleLayout);
 84597:       // mInFlush is a bitfield, so can't us AutoRestore here.  But we
 84597:       // need to keep track of multi-level reentry correctly, so need
 84597:       // to restore the old mInFlush value.
 84597:       bool oldInFlush = mInFlush;
 84597:       mInFlush = true;
     1:       shell->FlushPendingNotifications(aType);
 84597:       mInFlush = oldInFlush;
 84597:     }
     1:   }
     1: }
     1: 
 79445: static bool
 40701: Flush(nsIDocument* aDocument, void* aData)
 40701: {
 40701:   const mozFlushType* type = static_cast<const mozFlushType*>(aData);
 40701:   aDocument->FlushPendingNotifications(*type);
 80486:   return true;
 40701: }
 40701: 
 40701: void
 40701: nsDocument::FlushExternalResources(mozFlushType aType)
 40701: {
 40701:   NS_ASSERTION(aType >= Flush_Style,
 40701:     "should only need to flush for style or higher in external resources");
 40701: 
 40701:   if (GetDisplayDocument()) {
 40701:     return;
 40701:   }
 40701:   EnumerateExternalResources(Flush, &aType);
 40701: }
 40701: 
     1: void
     1: nsDocument::SetXMLDeclaration(const PRUnichar *aVersion,
     1:                               const PRUnichar *aEncoding,
     1:                               const PRInt32 aStandalone)
     1: {
     1:   if (!aVersion || *aVersion == '\0') {
     1:     mXMLDeclarationBits = 0;
     1:     return;
     1:   }
     1: 
     1:   mXMLDeclarationBits = XML_DECLARATION_BITS_DECLARATION_EXISTS;
     1: 
     1:   if (aEncoding && *aEncoding != '\0') {
     1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_ENCODING_EXISTS;
     1:   }
     1: 
     1:   if (aStandalone == 1) {
     1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS |
     1:                            XML_DECLARATION_BITS_STANDALONE_YES;
     1:   }
     1:   else if (aStandalone == 0) {
     1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS;
     1:   }
     1: }
     1: 
     1: void
     1: nsDocument::GetXMLDeclaration(nsAString& aVersion, nsAString& aEncoding,
     1:                               nsAString& aStandalone)
     1: {
     1:   aVersion.Truncate();
     1:   aEncoding.Truncate();
     1:   aStandalone.Truncate();
     1: 
     1:   if (!(mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS)) {
     1:     return;
     1:   }
     1: 
     1:   // always until we start supporting 1.1 etc.
     1:   aVersion.AssignLiteral("1.0");
     1: 
     1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
     1:     // This is what we have stored, not necessarily what was written
     1:     // in the original
     1:     GetCharacterSet(aEncoding);
     1:   }
     1: 
     1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS) {
     1:     if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES) {
     1:       aStandalone.AssignLiteral("yes");
     1:     } else {
     1:       aStandalone.AssignLiteral("no");
     1:     }
     1:   }
     1: }
     1: 
 79445: bool
     1: nsDocument::IsScriptEnabled()
     1: {
     1:   nsCOMPtr<nsIScriptSecurityManager> sm(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
 80486:   NS_ENSURE_TRUE(sm, false);
     1: 
     1:   nsIScriptGlobalObject* globalObject = GetScriptGlobalObject();
 80486:   NS_ENSURE_TRUE(globalObject, false);
     1: 
     1:   nsIScriptContext *scriptContext = globalObject->GetContext();
 80486:   NS_ENSURE_TRUE(scriptContext, false);
     1: 
 78415:   JSContext* cx = scriptContext->GetNativeContext();
 80486:   NS_ENSURE_TRUE(cx, false);
     1: 
 79445:   bool enabled;
     1:   nsresult rv = sm->CanExecuteScripts(cx, NodePrincipal(), &enabled);
 80486:   NS_ENSURE_SUCCESS(rv, false);
     1:   return enabled;
     1: }
     1: 
 95441: nsRadioGroupStruct*
 95441: nsDocument::GetRadioGroup(const nsAString& aName)
     1: {
     1:   nsAutoString tmKey(aName);
 95441:   if (IsHTML()) {
     1:     ToLowerCase(tmKey); //should case-insensitive.
 95441:   }
 95441: 
 95441:   nsRadioGroupStruct* radioGroup;
 95441:   if (mRadioGroups.Get(tmKey, &radioGroup)) {
 95441:     return radioGroup;
 95441:   }
 95441: 
 95441:   nsAutoPtr<nsRadioGroupStruct> newRadioGroup(new nsRadioGroupStruct());
 98908:   mRadioGroups.Put(tmKey, newRadioGroup);
 95441: 
 95441:   return newRadioGroup.forget();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::SetCurrentRadioButton(const nsAString& aName,
     1:                                   nsIDOMHTMLInputElement* aRadio)
     1: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 95441:   NS_ENSURE_TRUE(radioGroup, NS_OK);
 95441: 
     1:   radioGroup->mSelectedRadioButton = aRadio;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetCurrentRadioButton(const nsAString& aName,
     1:                                   nsIDOMHTMLInputElement** aRadio)
     1: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 95441:   NS_ENSURE_TRUE(radioGroup, NS_OK);
 95441: 
     1:   *aRadio = radioGroup->mSelectedRadioButton;
     1:   NS_IF_ADDREF(*aRadio);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::GetNextRadioButton(const nsAString& aName,
 79445:                                const bool aPrevious,
     1:                                nsIDOMHTMLInputElement*  aFocusedRadio,
     1:                                nsIDOMHTMLInputElement** aRadioOut)
     1: {
     1:   // XXX Can we combine the HTML radio button method impls of 
     1:   //     nsDocument and nsHTMLFormControl?
     1:   // XXX Why is HTML radio button stuff in nsDocument, as 
     1:   //     opposed to nsHTMLDocument?
     1:   *aRadioOut = nsnull;
     1: 
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 95441:   NS_ENSURE_TRUE(radioGroup, NS_ERROR_FAILURE);
     1: 
     1:   // Return the radio button relative to the focused radio button.
     1:   // If no radio is focused, get the radio relative to the selected one.
     1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
     1:   if (aFocusedRadio) {
     1:     currentRadio = aFocusedRadio;
     1:   }
     1:   else {
     1:     currentRadio = radioGroup->mSelectedRadioButton;
     1:     if (!currentRadio) {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   }
     1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(currentRadio));
     1:   PRInt32 index = radioGroup->mRadioButtons.IndexOf(radioControl);
     1:   if (index < 0) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   PRInt32 numRadios = radioGroup->mRadioButtons.Count();
 79445:   bool disabled;
     1:   nsCOMPtr<nsIDOMHTMLInputElement> radio;
     1:   do {
     1:     if (aPrevious) {
     1:       if (--index < 0) {
     1:         index = numRadios -1;
     1:       }
     1:     }
     1:     else if (++index >= numRadios) {
     1:       index = 0;
     1:     }
  6365:     radio = do_QueryInterface(radioGroup->mRadioButtons[index]);
     1:     NS_ASSERTION(radio, "mRadioButtons holding a non-radio button");
     1:     radio->GetDisabled(&disabled);
     1:   } while (disabled && radio != currentRadio);
     1: 
     1:   NS_IF_ADDREF(*aRadioOut = radio);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::AddToRadioGroup(const nsAString& aName,
     1:                             nsIFormControl* aRadio)
     1: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 95441:   NS_ENSURE_TRUE(radioGroup, NS_OK);
 95441: 
  6365:   radioGroup->mRadioButtons.AppendObject(aRadio);
 63105: 
 63105:   nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
 63105:   NS_ASSERTION(element, "radio controls have to be content elements");
 63105:   if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
 63105:     radioGroup->mRequiredRadioCount++;
 63105:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::RemoveFromRadioGroup(const nsAString& aName,
     1:                                  nsIFormControl* aRadio)
     1: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 95441:   NS_ENSURE_TRUE(radioGroup, NS_OK);
 95441: 
  6365:   radioGroup->mRadioButtons.RemoveObject(aRadio);
 63105: 
 63105:   nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
 63105:   NS_ASSERTION(element, "radio controls have to be content elements");
 63105:   if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
 97600:     NS_ASSERTION(radioGroup->mRequiredRadioCount != 0,
 97600:                  "mRequiredRadioCount about to wrap below 0!");
 63105:     radioGroup->mRequiredRadioCount--;
 63105:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDocument::WalkRadioGroup(const nsAString& aName,
     1:                            nsIRadioVisitor* aVisitor,
 79445:                            bool aFlushContent)
     1: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 95441:   NS_ENSURE_TRUE(radioGroup, NS_OK);
     1: 
     1:   for (int i = 0; i < radioGroup->mRadioButtons.Count(); i++) {
 67869:     if (!aVisitor->Visit(radioGroup->mRadioButtons[i])) {
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 63105: PRUint32
 63105: nsDocument::GetRequiredRadioCount(const nsAString& aName) const
 63105: {
 63105:   nsRadioGroupStruct* radioGroup = nsnull;
 63105:   // TODO: we should call GetRadioGroup here (and make it const) but for that
 63105:   // we would need to have an explicit CreateRadioGroup() instead of create
 63105:   // one when GetRadioGroup is called. See bug 636123.
 63105:   nsAutoString tmKey(aName);
 63105:   if (IsHTML())
 63105:      ToLowerCase(tmKey); //should case-insensitive.
 63105:   mRadioGroups.Get(tmKey, &radioGroup);
 63105: 
 63105:   return radioGroup ? radioGroup->mRequiredRadioCount : 0;
 63105: }
 63105: 
 63105: void
 63105: nsDocument::RadioRequiredChanged(const nsAString& aName, nsIFormControl* aRadio)
 63105: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 63105: 
 63105:   if (!radioGroup) {
 63105:     return;
 63105:   }
 63105: 
 63105:   nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
 63105:   NS_ASSERTION(element, "radio controls have to be content elements");
 63105:   if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
 63105:     radioGroup->mRequiredRadioCount++;
 63105:   } else {
 97600:     NS_ASSERTION(radioGroup->mRequiredRadioCount != 0,
 97600:                  "mRequiredRadioCount about to wrap below 0!");
 63105:     radioGroup->mRequiredRadioCount--;
 63105:   }
 63105: }
 63105: 
 63107: bool
 63107: nsDocument::GetValueMissingState(const nsAString& aName) const
 63107: {
 63107:   nsRadioGroupStruct* radioGroup = nsnull;
 63107:   // TODO: we should call GetRadioGroup here (and make it const) but for that
 63107:   // we would need to have an explicit CreateRadioGroup() instead of create
 63107:   // one when GetRadioGroup is called. See bug 636123.
 63107:   nsAutoString tmKey(aName);
 63107:   if (IsHTML())
 63107:      ToLowerCase(tmKey); //should case-insensitive.
 63107:   mRadioGroups.Get(tmKey, &radioGroup);
 63107: 
 63107:   return radioGroup && radioGroup->mGroupSuffersFromValueMissing;
 63107: }
 63107: 
 63107: void
 63107: nsDocument::SetValueMissingState(const nsAString& aName, bool aValue)
 63107: {
 95441:   nsRadioGroupStruct* radioGroup = GetRadioGroup(aName);
 63107: 
 63107:   if (!radioGroup) {
 63107:     return;
 63107:   }
 63107: 
 63107:   radioGroup->mGroupSuffersFromValueMissing = aValue;
 63107: }
 63107: 
     1: void
     1: nsDocument::RetrieveRelevantHeaders(nsIChannel *aChannel)
     1: {
     1:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
     1:   PRTime modDate = LL_ZERO;
     1:   nsresult rv;
     1: 
     1:   if (httpChannel) {
     1:     nsCAutoString tmp;
     1:     rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"),
     1:                                         tmp);
     1: 
     1:     if (NS_SUCCEEDED(rv)) {
     1:       PRTime time;
 80486:       PRStatus st = PR_ParseTimeString(tmp.get(), true, &time);
     1:       if (st == PR_SUCCESS) {
     1:         modDate = time;
     1:       }
     1:     }
     1: 
     1:     // The misspelled key 'referer' is as per the HTTP spec
     1:     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("referer"),
     1:                                        mReferrer);
     1:     if (NS_FAILED(rv)) {
     1:       mReferrer.Truncate();
     1:     }
     1: 
     1:     static const char *const headers[] = {
     1:       "default-style",
     1:       "content-style-type",
     1:       "content-language",
     1:       "content-disposition",
     1:       "refresh",
 21577:       "x-dns-prefetch-control",
 37418:       "x-content-security-policy",
 41197:       "x-content-security-policy-report-only",
 48017:       "x-frame-options",
     1:       // add more http headers if you need
     1:       // XXXbz don't add content-location support without reading bug
     1:       // 238654 and its dependencies/dups first.
     1:       0
     1:     };
     1:     
     1:     nsCAutoString headerVal;
     1:     const char *const *name = headers;
     1:     while (*name) {
     1:       rv =
     1:         httpChannel->GetResponseHeader(nsDependentCString(*name), headerVal);
     1:       if (NS_SUCCEEDED(rv) && !headerVal.IsEmpty()) {
     1:         nsCOMPtr<nsIAtom> key = do_GetAtom(*name);
     1:         SetHeaderData(key, NS_ConvertASCIItoUTF16(headerVal));
     1:       }
     1:       ++name;
     1:     }
     1:   } else {
     1:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(aChannel);
     1:     if (fileChannel) {
     1:       nsCOMPtr<nsIFile> file;
     1:       fileChannel->GetFile(getter_AddRefs(file));
     1:       if (file) {
     1:         PRTime msecs;
     1:         rv = file->GetLastModifiedTime(&msecs);
     1: 
     1:         if (NS_SUCCEEDED(rv)) {
     1:           PRInt64 intermediateValue;
     1:           LL_I2L(intermediateValue, PR_USEC_PER_MSEC);
     1:           LL_MUL(modDate, msecs, intermediateValue);
     1:         }
     1:       }
     1:     } else {
     1:       nsCAutoString contentDisp;
 78165:       rv = aChannel->GetContentDispositionHeader(contentDisp);
 78165:       if (NS_SUCCEEDED(rv)) {
     1:         SetHeaderData(nsGkAtoms::headerContentDisposition,
     1:                       NS_ConvertASCIItoUTF16(contentDisp));
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (LL_IS_ZERO(modDate)) {
     1:     // We got nothing from our attempt to ask nsIFileChannel and
     1:     // nsIHttpChannel for the last modified time. Return the current
     1:     // time.
     1:     modDate = PR_Now();
     1:   }
     1: 
     1:   mLastModified.Truncate();
     1:   if (LL_NE(modDate, LL_ZERO)) {
     1:     PRExplodedTime prtime;
     1:     PR_ExplodeTime(modDate, PR_LocalTimeParameters, &prtime);
     1:     // "MM/DD/YYYY hh:mm:ss"
  7783:     char formatedTime[24];
  7783:     if (PR_snprintf(formatedTime, sizeof(formatedTime),
  7783:                     "%02ld/%02ld/%04hd %02ld:%02ld:%02ld",
     1:                     prtime.tm_month + 1, prtime.tm_mday, prtime.tm_year,
     1:                     prtime.tm_hour     ,  prtime.tm_min,  prtime.tm_sec)) {
     1:       CopyASCIItoUTF16(nsDependentCString(formatedTime), mLastModified);
     1:     }
     1:   }
     1: }
     1: 
     1: nsresult
 48124: nsDocument::CreateElem(const nsAString& aName, nsIAtom *aPrefix, PRInt32 aNamespaceID,
 81061:                        nsIContent **aResult)
     1: {
     1: #ifdef DEBUG
     1:   nsAutoString qName;
     1:   if (aPrefix) {
     1:     aPrefix->ToString(qName);
     1:     qName.Append(':');
     1:   }
 48124:   qName.Append(aName);
     1: 
 11568:   // Note: "a:b:c" is a valid name in non-namespaces XML, and
 11568:   // nsDocument::CreateElement can call us with such a name and no prefix,
 80486:   // which would cause an error if we just used true here.
 79445:   bool nsAware = aPrefix != nsnull || aNamespaceID != GetDefaultNamespaceID();
 11568:   NS_ASSERTION(NS_SUCCEEDED(nsContentUtils::CheckQName(qName, nsAware)),
 11568:                "Don't pass invalid prefixes to nsDocument::CreateElem, "
     1:                "check caller.");
     1: #endif
     1: 
     1:   *aResult = nsnull;
     1:   
 94340:   nsCOMPtr<nsINodeInfo> nodeInfo;
 48124:   mNodeInfoManager->GetNodeInfo(aName, aPrefix, aNamespaceID,
 71770:                                 nsIDOMNode::ELEMENT_NODE,
 48124:                                 getter_AddRefs(nodeInfo));
 19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
     1: 
 82294:   return NS_NewElement(aResult, nodeInfo.forget(), NOT_FROM_PARSER);
     1: }
     1: 
 79445: bool
     1: nsDocument::IsSafeToFlush() const
     1: {
 84597:   nsIPresShell* shell = GetShell();
 39668:   if (!shell)
 80486:     return true;
 39668: 
 39668:   return shell->IsSafeToFlush();
     1: }
     1: 
     1: nsresult
     1: nsDocument::Sanitize()
     1: {
     1:   // Sanitize the document by resetting all password fields and any form
     1:   // fields with autocomplete=off to their default values.  We do this now,
     1:   // instead of when the presentation is restored, to offer some protection
     1:   // in case there is ever an exploit that allows a cached document to be
     1:   // accessed from a different document.
     1: 
     1:   // First locate all input elements, regardless of whether they are
     1:   // in a form, and reset the password and autocomplete=off elements.
     1: 
     1:   nsCOMPtr<nsIDOMNodeList> nodes;
     1:   nsresult rv = GetElementsByTagName(NS_LITERAL_STRING("input"),
     1:                                      getter_AddRefs(nodes));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   PRUint32 length = 0;
     1:   if (nodes)
     1:     nodes->GetLength(&length);
     1: 
     1:   nsCOMPtr<nsIDOMNode> item;
     1:   nsAutoString value;
     1:   PRUint32 i;
     1: 
     1:   for (i = 0; i < length; ++i) {
     1:     nodes->Item(i, getter_AddRefs(item));
     1:     NS_ASSERTION(item, "null item in node list!");
     1: 
     1:     nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(item);
     1:     if (!input)
     1:       continue;
     1: 
 79445:     bool resetValue = false;
     1: 
     1:     input->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
     1:     if (value.LowerCaseEqualsLiteral("off")) {
 80486:       resetValue = true;
     1:     } else {
     1:       input->GetType(value);
     1:       if (value.LowerCaseEqualsLiteral("password"))
 80486:         resetValue = true;
     1:     }
     1: 
     1:     if (resetValue) {
     1:       nsCOMPtr<nsIFormControl> fc = do_QueryInterface(input);
     1:       fc->Reset();
     1:     }
     1:   }
     1: 
     1:   // Now locate all _form_ elements that have autocomplete=off and reset them
     1:   rv = GetElementsByTagName(NS_LITERAL_STRING("form"), getter_AddRefs(nodes));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   length = 0;
     1:   if (nodes)
     1:     nodes->GetLength(&length);
     1: 
     1:   for (i = 0; i < length; ++i) {
     1:     nodes->Item(i, getter_AddRefs(item));
     1:     NS_ASSERTION(item, "null item in nodelist");
     1: 
     1:     nsCOMPtr<nsIDOMHTMLFormElement> form = do_QueryInterface(item);
     1:     if (!form)
     1:       continue;
     1: 
     1:     form->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
     1:     if (value.LowerCaseEqualsLiteral("off"))
     1:       form->Reset();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: struct SubDocEnumArgs
     1: {
     1:   nsIDocument::nsSubDocEnumFunc callback;
     1:   void *data;
     1: };
     1: 
 20261: static PLDHashOperator
     1: SubDocHashEnum(PLDHashTable *table, PLDHashEntryHdr *hdr,
     1:                PRUint32 number, void *arg)
     1: {
  3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
  3233:   SubDocEnumArgs *args = static_cast<SubDocEnumArgs*>(arg);
     1: 
     1:   nsIDocument *subdoc = entry->mSubDocument;
 79445:   bool next = subdoc ? args->callback(subdoc, args->data) : true;
     1: 
     1:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
     1: }
     1: 
     1: void
     1: nsDocument::EnumerateSubDocuments(nsSubDocEnumFunc aCallback, void *aData)
     1: {
     1:   if (mSubDocuments) {
     1:     SubDocEnumArgs args = { aCallback, aData };
     1:     PL_DHashTableEnumerate(mSubDocuments, SubDocHashEnum, &args);
     1:   }
     1: }
     1: 
 20261: static PLDHashOperator
     1: CanCacheSubDocument(PLDHashTable *table, PLDHashEntryHdr *hdr,
     1:                     PRUint32 number, void *arg)
     1: {
  3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 79445:   bool *canCacheArg = static_cast<bool*>(arg);
     1: 
     1:   nsIDocument *subdoc = entry->mSubDocument;
     1: 
     1:   // The aIgnoreRequest we were passed is only for us, so don't pass it on.
 79445:   bool canCache = subdoc ? subdoc->CanSavePresentation(nsnull) : false;
     1:   if (!canCache) {
 80486:     *canCacheArg = false;
     1:     return PL_DHASH_STOP;
     1:   }
     1: 
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
     1: #ifdef DEBUG_bryner
     1: #define DEBUG_PAGE_CACHE
     1: #endif
     1: 
 79445: bool
     1: nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
     1: {
 25722:   if (EventHandlingSuppressed()) {
 80486:     return false;
 25722:   }
 25722: 
 25722:   nsPIDOMWindow* win = GetInnerWindow();
 25722:   if (win && win->TimeoutSuspendCount()) {
 80486:     return false;
 25722:   }
 25722: 
     1:   // Check our event listener manager for unload/beforeunload listeners.
 72326:   nsCOMPtr<nsIDOMEventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
  1418:   if (piTarget) {
 72328:     nsEventListenerManager* manager =
 80486:       piTarget->GetListenerManager(false);
     1:     if (manager && manager->HasUnloadListeners()) {
 80486:       return false;
     1:     }
     1:   }
     1: 
 61406:   // Check if we have pending network requests
     1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
     1:   if (loadGroup) {
     1:     nsCOMPtr<nsISimpleEnumerator> requests;
     1:     loadGroup->GetRequests(getter_AddRefs(requests));
     1: 
 79445:     bool hasMore = false;
     1: 
 71166:     // We want to bail out if we have any requests other than aNewRequest (or
 71166:     // in the case when aNewRequest is a part of a multipart response the base
 71166:     // channel the multipart response is coming in on).
 71166:     nsCOMPtr<nsIChannel> baseChannel;
 71166:     nsCOMPtr<nsIMultiPartChannel> part(do_QueryInterface(aNewRequest));
 71166:     if (part) {
 71166:       part->GetBaseChannel(getter_AddRefs(baseChannel));
 71166:     }
 71166: 
     1:     while (NS_SUCCEEDED(requests->HasMoreElements(&hasMore)) && hasMore) {
     1:       nsCOMPtr<nsISupports> elem;
     1:       requests->GetNext(getter_AddRefs(elem));
     1: 
     1:       nsCOMPtr<nsIRequest> request = do_QueryInterface(elem);
 71166:       if (request && request != aNewRequest && request != baseChannel) {
     1: #ifdef DEBUG_PAGE_CACHE
     1:         nsCAutoString requestName, docSpec;
     1:         request->GetName(requestName);
     1:         if (mDocumentURI)
     1:           mDocumentURI->GetSpec(docSpec);
     1: 
     1:         printf("document %s has request %s\n",
     1:                docSpec.get(), requestName.get());
     1: #endif
 80486:         return false;
     1:       }
     1:     }
     1:   }
     1: 
 61406:   // Check if we have running IndexedDB transactions
 61406:   indexedDB::IndexedDatabaseManager* idbManager =
 61406:     indexedDB::IndexedDatabaseManager::Get();
 61406:   if (idbManager && idbManager->HasOpenTransactions(win)) {
 80486:     return false;
 61406:   }
 61406: 
 79445:   bool canCache = true;
     1:   if (mSubDocuments)
     1:     PL_DHashTableEnumerate(mSubDocuments, CanCacheSubDocument, &canCache);
     1: 
     1:   return canCache;
     1: }
     1: 
     1: void
     1: nsDocument::Destroy()
     1: {
     1:   // The ContentViewer wants to release the document now.  So, tell our content
     1:   // to drop any references to the document so that it can be destroyed.
     1:   if (mIsGoingAway)
     1:     return;
     1: 
 80486:   mIsGoingAway = true;
  8462: 
 14469:   RemovedFromDocShell();
 14188: 
 79445:   bool oldVal = mInUnlinkOrDeletion;
 80486:   mInUnlinkOrDeletion = true;
  8462:   PRUint32 i, count = mChildren.ChildCount();
  8462:   for (i = 0; i < count; ++i) {
  8462:     mChildren.ChildAt(i)->DestroyContent();
  8462:   }
 50721:   mInUnlinkOrDeletion = oldVal;
  8462: 
     1:   mLayoutHistoryState = nsnull;
     1: 
 20078:   // Shut down our external resource map.  We might not need this for
 20078:   // leak-fixing if we fix DocumentViewerImpl to do cycle-collection, but
 20078:   // tearing down all those frame trees right now is the right thing to do.
 20078:   mExternalResourceMap.Shutdown();
 21384: 
 21384:   // XXX We really should let cycle collection do this, but that currently still
 21384:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
 30001:   nsContentUtils::ReleaseWrapper(static_cast<nsINode*>(this), this);
     1: }
     1: 
 14188: void
 14469: nsDocument::RemovedFromDocShell()
 14469: {
 14469:   if (mRemovedFromDocShell)
 14188:     return;
 14188: 
 80486:   mRemovedFromDocShell = true;
 34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull); 
 14188: 
 14188:   PRUint32 i, count = mChildren.ChildCount();
 14188:   for (i = 0; i < count; ++i) {
 14188:     mChildren.ChildAt(i)->SaveSubtreeState();
 14188:   }
 14188: }
 14188: 
     1: already_AddRefed<nsILayoutHistoryState>
     1: nsDocument::GetLayoutHistoryState() const
     1: {
     1:   nsILayoutHistoryState* state = nsnull;
     1:   if (!mScriptGlobalObject) {
     1:     NS_IF_ADDREF(state = mLayoutHistoryState);
     1:   } else {
     1:     nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mDocumentContainer));
     1:     if (docShell) {
     1:       docShell->GetLayoutHistoryState(&state);
     1:     }
     1:   }
     1: 
     1:   return state;
     1: }
     1: 
     1: void
 40932: nsDocument::EnsureOnloadBlocker()
 40932: {
 40932:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
 40932:   // -- it's not ours.
 40932:   if (mOnloadBlockCount != 0 && mScriptGlobalObject) {
 40932:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
 40932:     if (loadGroup) {
 40932:       // Check first to see if mOnloadBlocker is in the loadgroup.
 40932:       nsCOMPtr<nsISimpleEnumerator> requests;
 40932:       loadGroup->GetRequests(getter_AddRefs(requests));
 40932: 
 79445:       bool hasMore = false;
 40932:       while (NS_SUCCEEDED(requests->HasMoreElements(&hasMore)) && hasMore) {
 40932:         nsCOMPtr<nsISupports> elem;
 40932:         requests->GetNext(getter_AddRefs(elem));
 40932:         nsCOMPtr<nsIRequest> request = do_QueryInterface(elem);
 40932:         if (request && request == mOnloadBlocker) {
 40932:           return;
 40932:         }
 40932:       }
 40932: 
 40932:       // Not in the loadgroup, so add it.
 40932:       loadGroup->AddRequest(mOnloadBlocker, nsnull);
 40932:     }
 40932:   }
 40932: }
 40932: 
 40932: void
 41406: nsDocument::AsyncBlockOnload()
 41406: {
 41406:   while (mAsyncOnloadBlockCount) {
 41406:     --mAsyncOnloadBlockCount;
 41406:     BlockOnload();
 41406:   }
 41406: }
 41406: 
 41406: void
     1: nsDocument::BlockOnload()
     1: {
 20078:   if (mDisplayDocument) {
 20078:     mDisplayDocument->BlockOnload();
 20078:     return;
 20078:   }
 20078:   
     1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
     1:   // -- it's not ours.
     1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
 41406:     if (!nsContentUtils::IsSafeToRunScript()) {
 41406:       // Because AddRequest may lead to OnStateChange calls in chrome,
 41406:       // block onload only when there are no script blockers.
 41406:       ++mAsyncOnloadBlockCount;
 41406:       if (mAsyncOnloadBlockCount == 1) {
 87939:         bool success = nsContentUtils::AddScriptRunner(
 41410:           NS_NewRunnableMethod(this, &nsDocument::AsyncBlockOnload));
 87939: 
 87939:         // The script runner shouldn't fail to add. But if somebody broke
 87939:         // something and it does, we'll thrash at 100% cpu forever. The best
 87939:         // response is just to ignore the onload blocking request. See bug 579535.
 87939:         if (!success) {
 87939:           NS_WARNING("Disaster! Onload blocking script runner failed to add - expect bad things!");
 87939:           mAsyncOnloadBlockCount = 0;
 87939:         }
 41406:       }
 41406:       return;
 41406:     }
     1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
     1:     if (loadGroup) {
     1:       loadGroup->AddRequest(mOnloadBlocker, nsnull);
     1:     }
     1:   }
     1:   ++mOnloadBlockCount;      
     1: }
     1: 
     1: void
 79445: nsDocument::UnblockOnload(bool aFireSync)
     1: {
 20078:   if (mDisplayDocument) {
 20078:     mDisplayDocument->UnblockOnload(aFireSync);
 20078:     return;
 20078:   }
 20078: 
 41406:   if (mOnloadBlockCount == 0 && mAsyncOnloadBlockCount == 0) {
     1:     NS_NOTREACHED("More UnblockOnload() calls than BlockOnload() calls; dropping call");
     1:     return;
     1:   }
     1: 
     1:   --mOnloadBlockCount;
     1: 
     1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
     1:   // -- it's not ours.
     1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
 41406:     if (aFireSync && mAsyncOnloadBlockCount == 0) {
     1:       // Increment mOnloadBlockCount, since DoUnblockOnload will decrement it
     1:       ++mOnloadBlockCount;
     1:       DoUnblockOnload();
     1:     } else {
     1:       PostUnblockOnloadEvent();
     1:     }
     1:   }
     1: }
     1: 
     1: class nsUnblockOnloadEvent : public nsRunnable {
     1: public:
     1:   nsUnblockOnloadEvent(nsDocument *doc) : mDoc(doc) {}
     1:   NS_IMETHOD Run() {
     1:     mDoc->DoUnblockOnload();
     1:     return NS_OK;
     1:   }
     1: private:  
     1:   nsRefPtr<nsDocument> mDoc;
     1: };
     1: 
     1: void
     1: nsDocument::PostUnblockOnloadEvent()
     1: {
     1:   nsCOMPtr<nsIRunnable> evt = new nsUnblockOnloadEvent(this);
     1:   nsresult rv = NS_DispatchToCurrentThread(evt);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // Stabilize block count so we don't post more events while this one is up
     1:     ++mOnloadBlockCount;
     1:   } else {
     1:     NS_WARNING("failed to dispatch nsUnblockOnloadEvent");
     1:   }
     1: }
     1: 
     1: void
     1: nsDocument::DoUnblockOnload()
     1: {
 20078:   NS_PRECONDITION(!mDisplayDocument,
 20078:                   "Shouldn't get here for resource document");
 20078:   NS_PRECONDITION(mOnloadBlockCount != 0,
     1:                   "Shouldn't have a count of zero here, since we stabilized in "
     1:                   "PostUnblockOnloadEvent");
     1:   
     1:   --mOnloadBlockCount;
     1: 
     1:   if (mOnloadBlockCount != 0) {
     1:     // We blocked again after the last unblock.  Nothing to do here.  We'll
     1:     // post a new event when we unblock again.
     1:     return;
     1:   }
     1: 
 41406:   if (mAsyncOnloadBlockCount != 0) {
 41406:     // We need to wait until the async onload block has been handled.
 41406:     PostUnblockOnloadEvent();
 41406:   }
 41406: 
     1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
     1:   // -- it's not ours.
     1:   if (mScriptGlobalObject) {
     1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
     1:     if (loadGroup) {
     1:       loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
     1:     }
     1:   }
     1: }
     1: 
101616: nsIContent*
101616: nsDocument::GetContentInThisDocument(nsIFrame* aFrame) const
101616: {
101616:   for (nsIFrame* f = aFrame; f;
101616:        f = nsLayoutUtils::GetParentOrPlaceholderForCrossDoc(f)) {
102510:     nsIContent* content = f->GetContent();
102510:     if (!content || content->IsInAnonymousSubtree())
101616:       continue;
101616: 
102510:     if (content->OwnerDoc() == this) {
102510:       return content;
101616:     }
101616:     // We must be in a subdocument so jump directly to the root frame.
101616:     // GetParentOrPlaceholderForCrossDoc gets called immediately to jump up to
101616:     // the containing document.
101616:     f = f->PresContext()->GetPresShell()->GetRootFrame();
101616:   }
101616: 
     1:   return nsnull;
     1: }
     1: 
     1: void
 72326: nsDocument::DispatchPageTransition(nsIDOMEventTarget* aDispatchTarget,
 29539:                                    const nsAString& aType,
 79445:                                    bool aPersisted)
 29539: {
 29539:   if (aDispatchTarget) {
 29539:     nsCOMPtr<nsIDOMEvent> event;
 29539:     CreateEvent(NS_LITERAL_STRING("pagetransition"), getter_AddRefs(event));
 29539:     nsCOMPtr<nsIDOMPageTransitionEvent> ptEvent = do_QueryInterface(event);
101616:     if (ptEvent && NS_SUCCEEDED(ptEvent->InitPageTransitionEvent(aType, true,
 80486:                                                                  true,
 29539:                                                                  aPersisted))) {
101616:       event->SetTrusted(true);
101616:       event->SetTarget(this);
 29539:       nsEventDispatcher::DispatchDOMEvent(aDispatchTarget, nsnull, event,
 29539:                                           nsnull, nsnull);
 29539:     }
 29539:   }
     1: }
     1: 
 79445: static bool
 36864: NotifyPageShow(nsIDocument* aDocument, void* aData)
 36864: {
 79445:   const bool* aPersistedPtr = static_cast<const bool*>(aData);
 36869:   aDocument->OnPageShow(*aPersistedPtr, nsnull);
 80486:   return true;
 36864: }
 36864: 
     1: void
 79445: nsDocument::OnPageShow(bool aPersisted,
 36864:                        nsIDOMEventTarget* aDispatchStartTarget)
     1: {
 80486:   mVisible = true;
 34207: 
 34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
 36869:   EnumerateExternalResources(NotifyPageShow, &aPersisted);
 36864: 
 41634:   Element* root = GetRootElement();
  8938:   if (aPersisted && root) {
     1:     // Send out notifications that our <link> elements are attached.
  8938:     nsRefPtr<nsContentList> links = NS_GetContentList(root,
 53966:                                                       kNameSpaceID_Unknown,
 63637:                                                       NS_LITERAL_STRING("link"));
 53966: 
 80486:     PRUint32 linkCount = links->Length(true);
     1:     for (PRUint32 i = 0; i < linkCount; ++i) {
 79445:       nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, false));
     1:       if (link) {
     1:         link->LinkAdded();
     1:       }
     1:     }
     1:   }
     1: 
 25572:   // See nsIDocument
 25572:   if (!aDispatchStartTarget) {
 25575:     // Set mIsShowing before firing events, in case those event handlers
 25575:     // move us around.
 80486:     mIsShowing = true;
 25572:   }
 23147:  
 23697:   if (mAnimationController) {
 23697:     mAnimationController->OnPageShow();
 23697:   }
 52149: 
 52149:   if (aPersisted) {
 80486:     SetImagesNeedAnimating(true);
 52149:   }
 52149: 
 80229:   UpdateVisibilityState();
 80229: 
 72327:   nsCOMPtr<nsIDOMEventTarget> target = aDispatchStartTarget;
 72327:   if (!target) {
 72327:     target = do_QueryInterface(GetWindow());
 72327:   }
 29539:   DispatchPageTransition(target, NS_LITERAL_STRING("pageshow"), aPersisted);
 25572: }
     1: 
 79445: static bool
 36864: NotifyPageHide(nsIDocument* aDocument, void* aData)
 36864: {
 79445:   const bool* aPersistedPtr = static_cast<const bool*>(aData);
 36869:   aDocument->OnPageHide(*aPersistedPtr, nsnull);
 80486:   return true;
 36864: }
 36864: 
     1: void
 79445: nsDocument::OnPageHide(bool aPersisted,
 36864:                        nsIDOMEventTarget* aDispatchStartTarget)
     1: {
     1:   // Send out notifications that our <link> elements are detached,
     1:   // but only if this is not a full unload.
 41634:   Element* root = GetRootElement();
  8938:   if (aPersisted && root) {
  8938:     nsRefPtr<nsContentList> links = NS_GetContentList(root,
 53966:                                                       kNameSpaceID_Unknown,
 63637:                                                       NS_LITERAL_STRING("link"));
 53966: 
 80486:     PRUint32 linkCount = links->Length(true);
     1:     for (PRUint32 i = 0; i < linkCount; ++i) {
 79445:       nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, false));
     1:       if (link) {
     1:         link->LinkRemoved();
     1:       }
     1:     }
     1:   }
     1: 
 25572:   // See nsIDocument
 25572:   if (!aDispatchStartTarget) {
 25575:     // Set mIsShowing before firing events, in case those event handlers
 25575:     // move us around.
 80486:     mIsShowing = false;
 25572:   }
 23147: 
 23697:   if (mAnimationController) {
 23697:     mAnimationController->OnPageHide();
 23697:   }
 23697:   
 52149:   if (aPersisted) {
 80486:     SetImagesNeedAnimating(false);
 52149:   }
 52149: 
     1:   // Now send out a PageHide event.
 72327:   nsCOMPtr<nsIDOMEventTarget> target = aDispatchStartTarget;
 72327:   if (!target) {
 72327:     target = do_QueryInterface(GetWindow());
 72327:   }
 29539:   DispatchPageTransition(target, NS_LITERAL_STRING("pagehide"), aPersisted);
     1: 
 80486:   mVisible = false;
 80229: 
 80229:   UpdateVisibilityState();
 80229:   
 36869:   EnumerateExternalResources(NotifyPageHide, &aPersisted);
 34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
 81397: 
 81397:   if (IsFullScreenDoc()) {
 81397:     // A full-screen doc has been hidden. We need to ensure we exit
 81397:     // full-screen, i.e. remove full-screen state from all full-screen
 81397:     // documents, and exit the top-level window from full-screen mode.
 84109:     // By the time a doc is hidden, it has been removed from the doc tree,
 84109:     // so nsIDocument::ExitFullScreen() won't be able to traverse to this
 84109:     // document to reset its state, so reset full-screen state in *this*
 84109:     // document. OnPageHide() is called in every hidden document, so doing
 84109:     // this ensures all hidden documents have their full-screen state reset.
 99028:     CleanupFullscreenState();
 84109: 
 84109:     // Next reset full-screen state in all visible documents in the doctree.
 84109:     nsIDocument::ExitFullScreen(false);
 81397:   }
     1: }
     1: 
    62: void
    62: nsDocument::WillDispatchMutationEvent(nsINode* aTarget)
    62: {
    62:   NS_ASSERTION(mSubtreeModifiedDepth != 0 ||
    62:                mSubtreeModifiedTargets.Count() == 0,
    62:                "mSubtreeModifiedTargets not cleared after dispatching?");
    62:   ++mSubtreeModifiedDepth;
    62:   if (aTarget) {
  3137:     // MayDispatchMutationEvent is often called just before this method,
  3137:     // so it has already appended the node to mSubtreeModifiedTargets.
  3137:     PRInt32 count = mSubtreeModifiedTargets.Count();
  3137:     if (!count || mSubtreeModifiedTargets[count - 1] != aTarget) {
    62:       mSubtreeModifiedTargets.AppendObject(aTarget);
    62:     }
    62:   }
  3137: }
    62: 
    62: void
    62: nsDocument::MutationEventDispatched(nsINode* aTarget)
    62: {
    62:   --mSubtreeModifiedDepth;
    62:   if (mSubtreeModifiedDepth == 0) {
    62:     PRInt32 count = mSubtreeModifiedTargets.Count();
    62:     if (!count) {
    62:       return;
    62:     }
    62: 
    62:     nsCOMPtr<nsPIDOMWindow> window;
    62:     window = do_QueryInterface(GetScriptGlobalObject());
    62:     if (window &&
    62:         !window->HasMutationListeners(NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED)) {
    62:       mSubtreeModifiedTargets.Clear();
    62:       return;
    62:     }
    62: 
    62:     nsCOMArray<nsINode> realTargets;
    62:     for (PRInt32 i = 0; i < count; ++i) {
    62:       nsINode* possibleTarget = mSubtreeModifiedTargets[i];
 13936:       nsCOMPtr<nsIContent> content = do_QueryInterface(possibleTarget);
 13936:       if (content && content->IsInNativeAnonymousSubtree()) {
 13936:         continue;
 13936:       }
    62: 
    62:       nsINode* commonAncestor = nsnull;
    62:       PRInt32 realTargetCount = realTargets.Count();
    62:       for (PRInt32 j = 0; j < realTargetCount; ++j) {
    62:         commonAncestor =
    62:           nsContentUtils::GetCommonAncestor(possibleTarget, realTargets[j]);
    62:         if (commonAncestor) {
    62:           realTargets.ReplaceObjectAt(commonAncestor, j);
    62:           break;
    62:         }
    62:       }
    62:       if (!commonAncestor) {
    62:         realTargets.AppendObject(possibleTarget);
    62:       }
    62:     }
    62: 
    62:     mSubtreeModifiedTargets.Clear();
    62: 
    62:     PRInt32 realTargetCount = realTargets.Count();
    62:     for (PRInt32 k = 0; k < realTargetCount; ++k) {
 80486:       nsMutationEvent mutation(true, NS_MUTATION_SUBTREEMODIFIED);
 84833:       (new nsAsyncDOMEvent(realTargets[k], mutation))->RunDOMEventWhenSafe();
    62:     }
    62:   }
    62: }
    62: 
     1: void
 38488: nsDocument::AddStyleRelevantLink(Link* aLink)
 38488: {
 38488:   NS_ASSERTION(aLink, "Passing in a null link.  Expect crashes RSN!");
 38488: #ifdef DEBUG
 38488:   nsPtrHashKey<Link>* entry = mStyledLinks.GetEntry(aLink);
 38488:   NS_ASSERTION(!entry, "Document already knows about this Link!");
 38488:   mStyledLinksCleared = false;
 38488: #endif
 38488:   (void)mStyledLinks.PutEntry(aLink);
     1: }
     1: 
     1: void
 38488: nsDocument::ForgetLink(Link* aLink)
 38488: {
 38488:   NS_ASSERTION(aLink, "Passing in a null link.  Expect crashes RSN!");
 38488: #ifdef DEBUG
 38488:   nsPtrHashKey<Link>* entry = mStyledLinks.GetEntry(aLink);
 38488:   NS_ASSERTION(entry || mStyledLinksCleared,
 38488:                "Document knows nothing about this Link!");
 38488: #endif
 38488:   (void)mStyledLinks.RemoveEntry(aLink);
     1: }
     1: 
     1: void
 43079: nsDocument::DestroyElementMaps()
     1: {
 38488: #ifdef DEBUG
 38488:   mStyledLinksCleared = true;
 38488: #endif
 38488:   mStyledLinks.Clear();
 43079:   mIdentifierMap.Clear();
 38488: }
 38488: 
 38488: static
 38488: PLDHashOperator
 38488: EnumerateStyledLinks(nsPtrHashKey<Link>* aEntry, void* aArray)
 38488: {
 57140:   LinkArray* array = static_cast<LinkArray*>(aArray);
 38488:   (void)array->AppendElement(aEntry->GetKey());
 33055:   return PL_DHASH_NEXT;
 33055: }
 33055: 
 33055: void
 33055: nsDocument::RefreshLinkHrefs()
 33055: {
 38488:   // Get a list of all links we know about.  We will reset them, which will
 38488:   // remove them from the document, so we need a copy of what is in the
 38488:   // hashtable.
 57140:   LinkArray linksToNotify(mStyledLinks.Count());
 38488:   (void)mStyledLinks.EnumerateEntries(EnumerateStyledLinks, &linksToNotify);
 38488: 
 38488:   // Reset all of our styled links.
 71103:   nsAutoScriptBlocker scriptBlocker;
 57140:   for (LinkArray::size_type i = 0; i < linksToNotify.Length(); i++) {
 38488:     linksToNotify[i]->ResetLinkState(true);
 33055:   }
 33055: }
 33055: 
 19384: nsresult
 19384: nsDocument::CloneDocHelper(nsDocument* clone) const
 19384: {
 35581:   clone->mIsStaticDocument = mCreatingStaticClone;
 35581: 
 19384:   // Init document
 19384:   nsresult rv = clone->Init();
 19384:   NS_ENSURE_SUCCESS(rv, rv);
 19384: 
 19384:   // Set URI/principal
 19384:   clone->nsDocument::SetDocumentURI(nsIDocument::GetDocumentURI());
 19384:   // Must set the principal first, since SetBaseURI checks it.
 19384:   clone->SetPrincipal(NodePrincipal());
 22362:   clone->mDocumentBaseURI = mDocumentBaseURI;
 19384: 
 35581:   if (mCreatingStaticClone) {
 35581:     nsCOMPtr<nsIChannel> channel = GetChannel();
 35581:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
 35581:     if (channel && loadGroup) {
 35581:       clone->Reset(channel, loadGroup);
 35581:     } else {
 35581:       nsIURI* uri = static_cast<const nsIDocument*>(this)->GetDocumentURI();
 35581:       if (uri) {
 35581:         clone->ResetToURI(uri, loadGroup, NodePrincipal());
 35581:       }
 35581:     }
 35581:     nsCOMPtr<nsISupports> container = GetContainer();
 35581:     clone->SetContainer(container);
 35581:   }
 35581: 
 19384:   // Set scripting object
 79445:   bool hasHadScriptObject = true;
 19384:   nsIScriptGlobalObject* scriptObject =
 19384:     GetScriptHandlingObject(hasHadScriptObject);
 19384:   NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
 19384:   clone->SetScriptHandlingObject(scriptObject);
 19384: 
 19384:   // Make the clone a data document
 80486:   clone->SetLoadedAsData(true);
 19384: 
 19384:   // Misc state
 19384: 
 19384:   // State from nsIDocument
 19384:   clone->mCharacterSet = mCharacterSet;
 19384:   clone->mCharacterSetSource = mCharacterSetSource;
 19384:   clone->mCompatMode = mCompatMode;
 19384:   clone->mBidiOptions = mBidiOptions;
 19384:   clone->mContentLanguage = mContentLanguage;
 46309:   clone->SetContentTypeInternal(GetContentTypeInternal());
 19384:   clone->mSecurityInfo = mSecurityInfo;
 19384: 
 19384:   // State from nsDocument
 19384:   clone->mIsRegularHTML = mIsRegularHTML;
 19384:   clone->mXMLDeclarationBits = mXMLDeclarationBits;
 19384:   clone->mBaseTarget = mBaseTarget;
 23639:   return NS_OK;
 23639: }
 23639: 
 23639: void
 23639: nsDocument::SetReadyStateInternal(ReadyState rs)
 23639: {
 23639:   mReadyState = rs;
 95570:   if (rs == READYSTATE_UNINITIALIZED) {
 95570:     // Transition back to uninitialized happens only to keep assertions happy
 95570:     // right before readyState transitions to something else. Make this
 95570:     // transition undetectable by Web content.
 95570:     return;
 95570:   }
 72298:   if (mTiming) {
 72298:     switch (rs) {
 72298:       case READYSTATE_LOADING:
 72298:         mTiming->NotifyDOMLoading(nsIDocument::GetDocumentURI());
 72298:         break;
 72298:       case READYSTATE_INTERACTIVE:
 72298:         mTiming->NotifyDOMInteractive(nsIDocument::GetDocumentURI());
 72298:         break;
 72298:       case READYSTATE_COMPLETE:
 72298:         mTiming->NotifyDOMComplete(nsIDocument::GetDocumentURI());
 72298:         break;
 72298:       default:
 72298:         NS_WARNING("Unexpected ReadyState value");
 72298:         break;
 72298:     }
 72298:   }
 72298:   // At the time of loading start, we don't have timing object, record time.
 72298:   if (READYSTATE_LOADING == rs) {
 72298:     mLoadingTimeStamp = mozilla::TimeStamp::Now();
 72298:   }
 46273: 
 84833:   nsRefPtr<nsAsyncDOMEvent> plevent =
 84833:     new nsAsyncDOMEvent(this, NS_LITERAL_STRING("readystatechange"), false, false); 
 46273:   if (plevent) {
 46273:     plevent->RunDOMEventWhenSafe();
 46273:   }
 23639: }
 23639: 
 29975: nsIDocument::ReadyState
 29975: nsDocument::GetReadyStateEnum()
 29975: {
 29975:   return mReadyState;
 29975: }
 23639: 
 23639: NS_IMETHODIMP
 23639: nsDocument::GetReadyState(nsAString& aReadyState)
 23639: {
 23639:   switch(mReadyState) {
 23639:   case READYSTATE_LOADING :
 23639:     aReadyState.Assign(NS_LITERAL_STRING("loading"));
 23639:     break;
 23639:   case READYSTATE_INTERACTIVE :
 23639:     aReadyState.Assign(NS_LITERAL_STRING("interactive"));
 23639:     break;
 23639:   case READYSTATE_COMPLETE :
 23639:     aReadyState.Assign(NS_LITERAL_STRING("complete"));
 23639:     break;  
 23639:   default:
 23639:     aReadyState.Assign(NS_LITERAL_STRING("uninitialized"));
 23639:   }
 23639:   return NS_OK;
 23639: }
 25722: 
 79445: static bool
 25722: SuppressEventHandlingInDocument(nsIDocument* aDocument, void* aData)
 25722: {
 25722:   aDocument->SuppressEventHandling(*static_cast<PRUint32*>(aData));
 80486:   return true;
 25722: }
 25722: 
 25722: void
 25722: nsDocument::SuppressEventHandling(PRUint32 aIncrease)
 25722: {
 75000:   if (mEventsSuppressed == 0 && aIncrease != 0 && mPresShell &&
 75000:       mScriptGlobalObject) {
 75000:     RevokeAnimationFrameNotifications();
 75000:   }
 25722:   mEventsSuppressed += aIncrease;
 25722:   EnumerateSubDocuments(SuppressEventHandlingInDocument, &aIncrease);
 25722: }
 25722: 
 26591: static void
 26591: FireOrClearDelayedEvents(nsTArray<nsCOMPtr<nsIDocument> >& aDocuments,
 79445:                          bool aFireEvents)
 26591: {
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (!fm)
 29018:     return;
 29018: 
 26591:   for (PRUint32 i = 0; i < aDocuments.Length(); ++i) {
 26591:     if (!aDocuments[i]->EventHandlingSuppressed()) {
 29018:       fm->FireDelayedEvents(aDocuments[i]);
 46225:       nsCOMPtr<nsIPresShell> shell = aDocuments[i]->GetShell();
 36917:       if (shell) {
 26591:         shell->FireOrClearDelayedEvents(aFireEvents);
 26591:       }
 26591:     }
 26591:   }
 26591: }
 26591: 
 30065: void
 74594: nsDocument::MaybePreLoadImage(nsIURI* uri, const nsAString &aCrossOriginAttr)
 30065: {
 30065:   // Early exit if the img is already present in the img-cache
 30065:   // which indicates that the "real" load has already started and
 30065:   // that we shouldn't preload it.
 37354:   PRInt16 blockingStatus;
 37354:   if (nsContentUtils::IsImageInCache(uri) ||
 37354:       !nsContentUtils::CanLoadImage(uri, static_cast<nsIDocument *>(this),
 37354:                                     this, NodePrincipal(), &blockingStatus)) {
 30065:     return;
 30065:   }
 30065: 
 74594:   nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
 91990:   switch (nsGenericElement::StringToCORSMode(aCrossOriginAttr)) {
 91990:   case CORS_NONE:
 91990:     // Nothing to do
 91990:     break;
 91990:   case CORS_ANONYMOUS:
 74594:     loadFlags |= imgILoader::LOAD_CORS_ANONYMOUS;
 91990:     break;
 91990:   case CORS_USE_CREDENTIALS:
 74594:     loadFlags |= imgILoader::LOAD_CORS_USE_CREDENTIALS;
 91990:     break;
 91990:   default:
 91990:     /* should never happen */
 91990:     MOZ_NOT_REACHED("Unknown CORS mode!");
 91990:   }
 74594: 
 30065:   // Image not in cache - trigger preload
 30065:   nsCOMPtr<imgIRequest> request;
 30065:   nsresult rv =
 30065:     nsContentUtils::LoadImage(uri,
 30065:                               this,
 30065:                               NodePrincipal(),
 30065:                               mDocumentURI, // uri of document used as referrer
 30065:                               nsnull,       // no observer
 74594:                               loadFlags,
 30065:                               getter_AddRefs(request));
 30065: 
 30065:   // Pin image-reference to avoid evicting it from the img-cache before
 30065:   // the "real" load occurs. Unpinned in DispatchContentLoadedEvents and
 30065:   // unlink
 30065:   if (NS_SUCCEEDED(rv)) {
 30065:     mPreloadingImages.AppendObject(request);
 30065:   }
 30065: }
 37354: 
 56168: nsEventStates
 39698: nsDocument::GetDocumentState()
 39698: {
 56168:   if (!mGotDocumentState.HasState(NS_DOCUMENT_STATE_RTL_LOCALE)) {
 39698:     if (IsDocumentRightToLeft()) {
 39698:       mDocumentState |= NS_DOCUMENT_STATE_RTL_LOCALE;
 39698:     }
 39698:     mGotDocumentState |= NS_DOCUMENT_STATE_RTL_LOCALE;
 39698:   }
 56168:   if (!mGotDocumentState.HasState(NS_DOCUMENT_STATE_WINDOW_INACTIVE)) {
 46225:     nsIPresShell* shell = GetShell();
 39698:     if (shell && shell->GetPresContext() &&
 39698:         shell->GetPresContext()->IsTopLevelWindowInactive()) {
 39698:       mDocumentState |= NS_DOCUMENT_STATE_WINDOW_INACTIVE;
 39698:     }
 39698:     mGotDocumentState |= NS_DOCUMENT_STATE_WINDOW_INACTIVE;
 39698:   }
 39698:   return mDocumentState;
 39698: }
 39698: 
 38850: namespace {
 38850: 
 38850: /**
 38850:  * Stub for LoadSheet(), since all we want is to get the sheet into
 38850:  * the CSSLoader's style cache
 38850:  */
102310: class StubCSSLoaderObserver MOZ_FINAL : public nsICSSLoaderObserver {
 38850: public:
 38850:   NS_IMETHOD
 79445:   StyleSheetLoaded(nsCSSStyleSheet*, bool, nsresult)
 38850:   {
 38850:     return NS_OK;
 38850:   }
 38850:   NS_DECL_ISUPPORTS
 38850: };
 38850: NS_IMPL_ISUPPORTS1(StubCSSLoaderObserver, nsICSSLoaderObserver)
 38850: 
 38850: }
 38850: 
 38850: void
 38850: nsDocument::PreloadStyle(nsIURI* uri, const nsAString& charset)
 38850: {
 38850:   // The CSSLoader will retain this object after we return.
 38850:   nsCOMPtr<nsICSSLoaderObserver> obs = new StubCSSLoaderObserver();
 38850: 
 38850:   // Charset names are always ASCII.
 38850:   CSSLoader()->LoadSheet(uri, NodePrincipal(),
 38850:                          NS_LossyConvertUTF16toASCII(charset),
 38850:                          obs);
 38850: }
 38850: 
 38850: nsresult
 79445: nsDocument::LoadChromeSheetSync(nsIURI* uri, bool isAgentSheet,
 42163:                                 nsCSSStyleSheet** sheet)
 38850: {
 38850:   return CSSLoader()->LoadSheetSync(uri, isAgentSheet, isAgentSheet, sheet);
 38850: }
 38850: 
 26591: class nsDelayedEventDispatcher : public nsRunnable
 26591: {
 26591: public:
 26591:   nsDelayedEventDispatcher(nsTArray<nsCOMPtr<nsIDocument> >& aDocuments)
 26591:   {
 26591:     mDocuments.SwapElements(aDocuments);
 26591:   }
 26591:   virtual ~nsDelayedEventDispatcher() {}
 26591: 
 26591:   NS_IMETHOD Run()
 26591:   {
 80486:     FireOrClearDelayedEvents(mDocuments, true);
 26591:     return NS_OK;
 26591:   }
 26591: 
 26591: private:
 26591:   nsTArray<nsCOMPtr<nsIDocument> > mDocuments;
 26591: };
 26591: 
 79445: static bool
 25722: GetAndUnsuppressSubDocuments(nsIDocument* aDocument, void* aData)
 25722: {
 25722:   PRUint32 suppression = aDocument->EventHandlingSuppressed();
 25722:   if (suppression > 0) {
 25722:     static_cast<nsDocument*>(aDocument)->DecreaseEventSuppression();
 25722:   }
 26591:   nsTArray<nsCOMPtr<nsIDocument> >* docs =
 26591:     static_cast<nsTArray<nsCOMPtr<nsIDocument> >* >(aData);
 26591:   docs->AppendElement(aDocument);
 25722:   aDocument->EnumerateSubDocuments(GetAndUnsuppressSubDocuments, docs);
 80486:   return true;
 25722: }
 25722: 
 25722: void
 79445: nsDocument::UnsuppressEventHandlingAndFireEvents(bool aFireEvents)
 25722: {
 26591:   nsTArray<nsCOMPtr<nsIDocument> > documents;
 75000:   GetAndUnsuppressSubDocuments(this, &documents);
 26591: 
 26591:   if (aFireEvents) {
 26591:     NS_DispatchToCurrentThread(new nsDelayedEventDispatcher(documents));
 26591:   } else {
 80486:     FireOrClearDelayedEvents(documents, false);
 26591:   }
 26591: }
 26591: 
 34394: nsISupports*
 34394: nsDocument::GetCurrentContentSink()
 34394: {
 34394:   return mParser ? mParser->GetContentSink() : nsnull;
 34394: }
 34394: 
 28108: void
 53994: nsDocument::RegisterFileDataUri(const nsACString& aUri)
 38871: {
 38871:   mFileDataUris.AppendElement(aUri);
 38871: }
 38871: 
 38871: void
 53994: nsDocument::UnregisterFileDataUri(const nsACString& aUri)
 53994: {
 53994:   mFileDataUris.RemoveElement(aUri);
 53994: }
 53994: 
 53994: void
 69754: nsDocument::SetScrollToRef(nsIURI *aDocumentURI)
 69754: {
 69754:   if (!aDocumentURI) {
 69754:     return;
 69754:   }
 69754: 
 69754:   nsCAutoString ref;
 69754: 
 69754:   // Since all URI's that pass through here aren't URL's we can't
 69754:   // rely on the nsIURI implementation for providing a way for
 69754:   // finding the 'ref' part of the URI, we'll haveto revert to
 69754:   // string routines for finding the data past '#'
 69754: 
 69754:   aDocumentURI->GetSpec(ref);
 69754: 
 69754:   nsReadingIterator<char> start, end;
 69754: 
 69754:   ref.BeginReading(start);
 69754:   ref.EndReading(end);
 69754: 
 69754:   if (FindCharInReadable('#', start, end)) {
 69754:     ++start; // Skip over the '#'
 69754: 
 69754:     mScrollToRef = Substring(start, end);
 69754:   }
 69754: }
 69754: 
 69754: void
 42357: nsDocument::ScrollToRef()
 42357: {
 69754:   if (mScrolledToRefAlready) {
 69754:     return;
 69754:   }
 69754: 
 69754:   if (mScrollToRef.IsEmpty()) {
 69754:     return;
 69754:   }
 69754: 
 69754:   char* tmpstr = ToNewCString(mScrollToRef);
 69754:   if (!tmpstr) {
 69754:     return;
 69754:   }
 69754: 
 69754:   nsUnescape(tmpstr);
 69754:   nsCAutoString unescapedRef;
 69754:   unescapedRef.Assign(tmpstr);
 69754:   nsMemory::Free(tmpstr);
 69754: 
 69754:   nsresult rv = NS_ERROR_FAILURE;
 69754:   // We assume that the bytes are in UTF-8, as it says in the spec:
 69754:   // http://www.w3.org/TR/html4/appendix/notes.html#h-B.2.1
 69754:   NS_ConvertUTF8toUTF16 ref(unescapedRef);
 69754: 
 69754:   nsCOMPtr<nsIPresShell> shell = GetShell();
 69754:   if (shell) {
 69754:     // Check an empty string which might be caused by the UTF-8 conversion
 69754:     if (!ref.IsEmpty()) {
 69754:       // Note that GoToAnchor will handle flushing layout as needed.
 69754:       rv = shell->GoToAnchor(ref, mChangeScrollPosWhenScrollingToRef);
 69754:     } else {
 69754:       rv = NS_ERROR_FAILURE;
 69754:     }
 69754: 
 69754:     // If UTF-8 URI failed then try to assume the string as a
 69754:     // document's charset.
 69754: 
 69754:     if (NS_FAILED(rv)) {
 69754:       const nsACString &docCharset = GetDocumentCharacterSet();
 69754: 
 69754:       rv = nsContentUtils::ConvertStringFromCharset(docCharset, unescapedRef, ref);
 69754: 
 69754:       if (NS_SUCCEEDED(rv) && !ref.IsEmpty()) {
 69754:         rv = shell->GoToAnchor(ref, mChangeScrollPosWhenScrollingToRef);
 69754:       }
 69754:     }
 69754:     if (NS_SUCCEEDED(rv)) {
 80486:       mScrolledToRefAlready = true;
 69754:     }
 69754:   }
 69754: }
 69754: 
 69754: void
 69754: nsDocument::ResetScrolledToRefAlready()
 69754: {
 80486:   mScrolledToRefAlready = false;
 69754: }
 69754: 
 69754: void
 79445: nsDocument::SetChangeScrollPosWhenScrollingToRef(bool aValue)
 69754: {
 69754:   mChangeScrollPosWhenScrollingToRef = aValue;
 42357: }
 42357: 
 42357: void
 28108: nsIDocument::RegisterFreezableElement(nsIContent* aContent)
 28108: {
 28108:   if (!mFreezableElements) {
 28108:     mFreezableElements = new nsTHashtable<nsPtrHashKey<nsIContent> >();
 28108:     if (!mFreezableElements)
 28108:       return;
 28108:     mFreezableElements->Init();
 28108:   }
 28108:   mFreezableElements->PutEntry(aContent);
 28108: }
 28108: 
 79445: bool
 28108: nsIDocument::UnregisterFreezableElement(nsIContent* aContent)
 28108: {
 28108:   if (!mFreezableElements)
 80486:     return false;
 28108:   if (!mFreezableElements->GetEntry(aContent))
 80486:     return false;
 28108:   mFreezableElements->RemoveEntry(aContent);
 80486:   return true;
 28108: }
 28108: 
 28108: struct EnumerateFreezablesData {
 28108:   nsIDocument::FreezableElementEnumerator mEnumerator;
 28108:   void* mData;
 28108: };
 28108: 
 28108: static PLDHashOperator
 28108: EnumerateFreezables(nsPtrHashKey<nsIContent>* aEntry, void* aData)
 28108: {
 28108:   EnumerateFreezablesData* data = static_cast<EnumerateFreezablesData*>(aData);
 28108:   data->mEnumerator(aEntry->GetKey(), data->mData);
 28108:   return PL_DHASH_NEXT;
 28108: }
 28108: 
 28108: void
 28108: nsIDocument::EnumerateFreezableElements(FreezableElementEnumerator aEnumerator,
 28108:                                         void* aData)
 28108: {
 28108:   if (!mFreezableElements)
 28108:     return;
 28108:   EnumerateFreezablesData data = { aEnumerator, aData };
 28108:   mFreezableElements->EnumerateEntries(EnumerateFreezables, &data);
 28108: }
 35581: 
 82192: void
 82192: nsIDocument::RegisterPendingLinkUpdate(Link* aLink)
 82192: {
 82192:   mLinksToUpdate.PutEntry(aLink);
 82192:   mHasLinksToUpdate = true;
 82192: }
 82192: 
 82192: void
 82192: nsIDocument::UnregisterPendingLinkUpdate(Link* aLink)
 82192: {
 82192:   if (!mHasLinksToUpdate)
 82192:     return;
 82192:     
 82192:   mLinksToUpdate.RemoveEntry(aLink);
 82192: }
 82192:   
 82192: static PLDHashOperator
 82192: EnumeratePendingLinkUpdates(nsPtrHashKey<Link>* aEntry, void* aData)
 82192: {
 82192:   aEntry->GetKey()->GetElement()->UpdateLinkState(aEntry->GetKey()->LinkState());
 82192:   return PL_DHASH_NEXT;
 82192: }
 82192: 
 82192: void
 82192: nsIDocument::FlushPendingLinkUpdates() 
 82192: {
 82192:   if (!mHasLinksToUpdate)
 82192:     return;
 82192:     
 82192:   nsAutoScriptBlocker scriptBlocker;
 82192:   mLinksToUpdate.EnumerateEntries(EnumeratePendingLinkUpdates, nsnull);
 82192:   mLinksToUpdate.Clear();
 82192:   mHasLinksToUpdate = false;
 82192: }
 82192: 
 35581: already_AddRefed<nsIDocument>
 35581: nsIDocument::CreateStaticClone(nsISupports* aCloneContainer)
 35581: {
 35581:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(this);
 35581:   NS_ENSURE_TRUE(domDoc, nsnull);
 80486:   mCreatingStaticClone = true;
 35581: 
 35581:   // Make document use different container during cloning.
 35581:   nsCOMPtr<nsISupports> originalContainer = GetContainer();
 35581:   SetContainer(aCloneContainer);
 35581:   nsCOMPtr<nsIDOMNode> clonedNode;
 90796:   nsresult rv = domDoc->CloneNode(true, 1, getter_AddRefs(clonedNode));
 35581:   SetContainer(originalContainer);
 35581: 
 35581:   nsCOMPtr<nsIDocument> clonedDoc;
 35581:   if (NS_SUCCEEDED(rv)) {
 35581:     clonedDoc = do_QueryInterface(clonedNode);
 94112:     if (clonedDoc) {
 94112:       if (IsStaticDocument()) {
 94112:         clonedDoc->mOriginalDocument = mOriginalDocument;
 94112:       } else {
 35581:         clonedDoc->mOriginalDocument = this;
 94112:       }
 35581:       PRInt32 sheetsCount = GetNumberOfStyleSheets();
 35581:       for (PRInt32 i = 0; i < sheetsCount; ++i) {
 42163:         nsRefPtr<nsCSSStyleSheet> sheet = do_QueryObject(GetStyleSheetAt(i));
 35581:         if (sheet) {
 42332:           if (sheet->IsApplicable()) {
 42163:             nsRefPtr<nsCSSStyleSheet> clonedSheet =
 42162:               sheet->Clone(nsnull, nsnull, clonedDoc, nsnull);
 35581:             NS_WARN_IF_FALSE(clonedSheet, "Cloning a stylesheet didn't work!");
 35581:             if (clonedSheet) {
 35581:               clonedDoc->AddStyleSheet(clonedSheet);
 35581:             }
 35581:           }
 35581:         }
 35581:       }
 35581: 
 35581:       sheetsCount = GetNumberOfCatalogStyleSheets();
 35581:       for (PRInt32 i = 0; i < sheetsCount; ++i) {
 42163:         nsRefPtr<nsCSSStyleSheet> sheet =
 42163:           do_QueryObject(GetCatalogStyleSheetAt(i));
 35581:         if (sheet) {
 42332:           if (sheet->IsApplicable()) {
 42163:             nsRefPtr<nsCSSStyleSheet> clonedSheet =
 42162:               sheet->Clone(nsnull, nsnull, clonedDoc, nsnull);
 35581:             NS_WARN_IF_FALSE(clonedSheet, "Cloning a stylesheet didn't work!");
 35581:             if (clonedSheet) {
 35581:               clonedDoc->AddCatalogStyleSheet(clonedSheet);
 35581:             }
 35581:           }
 35581:         }
 35581:       }
 35581:     }
 35581:   }
 80486:   mCreatingStaticClone = false;
 35581:   return clonedDoc.forget();
 35581: }
 50368: 
 84132: nsresult
 84132: nsIDocument::ScheduleFrameRequestCallback(nsIFrameRequestCallback* aCallback,
 84132:                                           PRInt32 *aHandle)
 84132: {
 84132:   if (mFrameRequestCallbackCounter == PR_INT32_MAX) {
 84132:     // Can't increment without overflowing; bail out
 84132:     return NS_ERROR_NOT_AVAILABLE;
 84132:   }
 84132:   PRInt32 newHandle = ++mFrameRequestCallbackCounter;
 84132: 
 82857:   bool alreadyRegistered = !mFrameRequestCallbacks.IsEmpty();
 90479:   DebugOnly<FrameRequest*> request =
 84132:     mFrameRequestCallbacks.AppendElement(FrameRequest(aCallback, newHandle));
 84132:   NS_ASSERTION(request, "This is supposed to be infallible!");
 84132:   if (!alreadyRegistered && mPresShell && IsEventHandlingEnabled()) {
 52255:     mPresShell->GetPresContext()->RefreshDriver()->
 82857:       ScheduleFrameRequestCallbacks(this);
 52255:   }
 84132: 
 84132:   *aHandle = newHandle;
 84132:   return NS_OK;
 50368: }
 50815: 
 84133: void
 84133: nsIDocument::CancelFrameRequestCallback(PRInt32 aHandle)
 84133: {
 84133:   // mFrameRequestCallbacks is stored sorted by handle
 84626:   if (mFrameRequestCallbacks.RemoveElementSorted(aHandle) &&
 84626:       mFrameRequestCallbacks.IsEmpty() &&
 84626:       mPresShell && IsEventHandlingEnabled()) {
 84626:     mPresShell->GetPresContext()->RefreshDriver()->
 84626:       RevokeFrameRequestCallbacks(this);
 84626:   }
 84133: }
 84133: 
 63882: nsresult
 69563: nsDocument::GetStateObject(nsIVariant** aState)
 69563: {
 69563:   // Get the document's current state object. This is the object backing both
 69563:   // history.state and popStateEvent.state.
 69563:   //
 69563:   // mStateObjectContainer may be null; this just means that there's no
 69563:   // current state object.
 62765: 
 62765:   nsCOMPtr<nsIVariant> stateObj;
 69563:   if (!mStateObjectCached && mStateObjectContainer) {
 69563:     JSContext *cx = nsContentUtils::GetContextFromDocument(this);
 69563:     mStateObjectContainer->
 69563:       DeserializeToVariant(cx, getter_AddRefs(mStateObjectCached));
 69563:   }
 69563: 
 69563:   NS_IF_ADDREF(*aState = mStateObjectCached);
 62765:   
 62765:   return NS_OK;
 62765: }
 62765: 
 72298: nsDOMNavigationTiming*
 72298: nsDocument::GetNavigationTiming() const
 72298: {
 72298:   return mTiming;
 72298: }
 72298: 
 72298: nsresult
 72298: nsDocument::SetNavigationTiming(nsDOMNavigationTiming* aTiming)
 72298: {
 72298:   mTiming = aTiming;
 72298:   if (!mLoadingTimeStamp.IsNull() && mTiming) {
 72298:     mTiming->SetDOMLoadingTimeStamp(nsIDocument::GetDocumentURI(), mLoadingTimeStamp);
 72298:   }
 72298:   return NS_OK;
 72298: }
 72298: 
 71030: Element*
 71031: nsDocument::FindImageMap(const nsAString& aUseMapValue)
 71031: {
 71031:   if (aUseMapValue.IsEmpty()) {
 71031:     return nsnull;
 71031:   }
 71031: 
 71031:   nsAString::const_iterator start, end;
 71031:   aUseMapValue.BeginReading(start);
 71031:   aUseMapValue.EndReading(end);
 71031: 
 71031:   PRInt32 hash = aUseMapValue.FindChar('#');
 71031:   if (hash < 0) {
 71031:     return nsnull;
 71031:   }
 71031:   // aUsemap contains a '#', set start to point right after the '#'
 71031:   start.advance(hash + 1);
 71031: 
 71031:   if (start == end) {
 71031:     return nsnull; // aUsemap == "#"
 71031:   }
 71031: 
 71031:   const nsAString& mapName = Substring(start, end);
 71031: 
 71030:   if (!mImageMaps) {
 71030:     mImageMaps = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::map, nsGkAtoms::map);
 71030:   }
 71030: 
 80486:   PRUint32 i, n = mImageMaps->Length(true);
 71030:   for (i = 0; i < n; ++i) {
 71030:     nsIContent* map = mImageMaps->GetNodeAt(i);
 71031:     if (map->AttrValueIs(kNameSpaceID_None, nsGkAtoms::id, mapName,
 71030:                          eCaseMatters) ||
 71031:         map->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name, mapName,
 71030:                          eIgnoreCase)) {
 71030:       return map->AsElement();
 71030:     }
 71030:   }
 71030: 
 71030:   return nsnull;
 71030: }
 71030: 
 72662: #define DEPRECATED_OPERATION(_op) #_op "Warning",
 72272: static const char* kWarnings[] = {
 72662: #include "nsDeprecatedOperationList.h"
 72664:   nsnull
 72272: };
 72662: #undef DEPRECATED_OPERATION
 72272: 
 72272: void
 99908: nsIDocument::WarnOnceAbout(DeprecatedOperations aOperation,
 99908:                            bool asError /* = false */)
 72272: {
 79005:   PR_STATIC_ASSERT(eDeprecatedOperationCount <= 64);
 93454:   if (mWarnedAbout & (1ull << aOperation)) {
 72272:     return;
 72272:   }
 93454:   mWarnedAbout |= (1ull << aOperation);
 99908:   uint32_t flags = asError ? nsIScriptError::errorFlag
 99908:                            : nsIScriptError::warningFlag;
 99908:   nsContentUtils::ReportToConsole(flags,
 84636:                                   "DOM Core", this,
 84636:                                   nsContentUtils::eDOM_PROPERTIES,
 84636:                                   kWarnings[aOperation]);
 72272: }
 72272: 
 50815: nsresult
 50815: nsDocument::AddImage(imgIRequest* aImage)
 50815: {
 50815:   NS_ENSURE_ARG_POINTER(aImage);
 50815: 
 50815:   // See if the image is already in the hashtable. If it is, get the old count.
 50815:   PRUint32 oldCount = 0;
 50815:   mImageTracker.Get(aImage, &oldCount);
 50815: 
 50815:   // Put the image in the hashtable, with the proper count.
 98908:   mImageTracker.Put(aImage, oldCount + 1);
 50815: 
 61325:   nsresult rv = NS_OK;
 61325: 
 50815:   // If this is the first insertion and we're locking images, lock this image
 50815:   // too.
 61325:   if (oldCount == 0 && mLockingImages) {
 61325:     rv = aImage->LockImage();
 61325:     if (NS_SUCCEEDED(rv))
 52149:       rv = aImage->RequestDecode();
 52149:   }
 52149: 
 52149:   // If this is the first insertion and we're animating images, request
 52149:   // that this image be animated too.
 52149:   if (oldCount == 0 && mAnimatingImages) {
 61325:     nsresult rv2 = aImage->IncrementAnimationConsumers();
 61325:     rv = NS_SUCCEEDED(rv) ? rv2 : rv;
 61325:   }
 61325: 
 61325:   return rv;
 50815: }
 50815: 
 82604: static void
 82604: NotifyAudioAvailableListener(nsIContent *aContent, void *aUnused)
 82604: {
 82604: #ifdef MOZ_MEDIA
 82604:   nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aContent));
 82604:   if (domMediaElem) {
 82604:     nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aContent);
 82604:     mediaElem->NotifyAudioAvailableListener();
 82604:   }
 82604: #endif
 82604: }
 82604: 
 82604: void
 82604: nsDocument::NotifyAudioAvailableListener()
 82604: {
 82604:   mHasAudioAvailableListener = true;
 82604:   EnumerateFreezableElements(::NotifyAudioAvailableListener, nsnull);
 82604: }
 82604: 
 50815: nsresult
 50815: nsDocument::RemoveImage(imgIRequest* aImage)
 50815: {
 50815:   NS_ENSURE_ARG_POINTER(aImage);
 50815: 
 50815:   // Get the old count. It should exist and be > 0.
 90479:   PRUint32 count = 0;
 90479:   DebugOnly<bool> found = mImageTracker.Get(aImage, &count);
 50815:   NS_ABORT_IF_FALSE(found, "Removing image that wasn't in the tracker!");
 50815:   NS_ABORT_IF_FALSE(count > 0, "Entry in the cache tracker with count 0!");
 50815: 
 50815:   // We're removing, so decrement the count.
 50815:   count--;
 50815: 
 50815:   // If the count is now zero, remove from the tracker.
 50815:   // Otherwise, set the new value.
 91982:   if (count != 0) {
 91982:     mImageTracker.Put(aImage, count);
 91982:     return NS_OK;
 91982:   }
 91982: 
 91943:   mImageTracker.Remove(aImage);
 50815: 
 61325:   nsresult rv = NS_OK;
 61325: 
 91982:   // Now that we're no longer tracking this image, unlock it if we'd
 91982:   // previously locked it.
 91982:   if (mLockingImages) {
 61325:     rv = aImage->UnlockImage();
 91982:   }
 91982: 
 91982:   // If we're animating images, remove our request to animate this one.
 91982:   if (mAnimatingImages) {
 61325:     nsresult rv2 = aImage->DecrementAnimationConsumers();
 61325:     rv = NS_SUCCEEDED(rv) ? rv2 : rv;
 61325:   }
 61325: 
 91982:   // Request that the image be discarded if nobody else holds a lock on it.
 91982:   // Do this even if !mLockingImages, because even if we didn't just unlock
 91982:   // this image, it might still be a candidate for discarding.
 91982:   aImage->RequestDiscard();
 91982: 
 61325:   return rv;
 50815: }
 50815: 
 94270: nsresult
 94270: nsDocument::AddPlugin(nsIObjectLoadingContent* aPlugin)
 94270: {
 94270:   MOZ_ASSERT(aPlugin);
 94270:   if (!mPlugins.PutEntry(aPlugin)) {
 94270:     return NS_ERROR_OUT_OF_MEMORY;
 94270:   }
 94270:   return NS_OK;
 94270: }
 94270: 
 94270: void
 94270: nsDocument::RemovePlugin(nsIObjectLoadingContent* aPlugin)
 94270: {
 94270:   MOZ_ASSERT(aPlugin);
 94270:   mPlugins.RemoveEntry(aPlugin);
 94270: }
 94270: 
 94270: static bool
 94270: AllSubDocumentPluginEnum(nsIDocument* aDocument, void* userArg)
 94270: {
 94270:   nsTArray<nsIObjectLoadingContent*>* plugins =
 94270:     reinterpret_cast< nsTArray<nsIObjectLoadingContent*>* >(userArg);
 94270:   MOZ_ASSERT(plugins);
 94270:   aDocument->GetPlugins(*plugins);
 94270:   return true;
 94270: }
 94270: 
 94270: static PLDHashOperator
 94270: AllPluginEnum(nsPtrHashKey<nsIObjectLoadingContent>* aPlugin, void* userArg)
 94270: {
 94270:   nsTArray<nsIObjectLoadingContent*>* allPlugins =
 94270:     reinterpret_cast< nsTArray<nsIObjectLoadingContent*>* >(userArg);
 94270:   MOZ_ASSERT(allPlugins);
 94270:   allPlugins->AppendElement(aPlugin->GetKey());
 94270:   return PL_DHASH_NEXT;
 94270: }
 94270: 
 94270: void
 94270: nsDocument::GetPlugins(nsTArray<nsIObjectLoadingContent*>& aPlugins)
 94270: {
 94270:   aPlugins.SetCapacity(aPlugins.Length() + mPlugins.Count());
 94270:   mPlugins.EnumerateEntries(AllPluginEnum, &aPlugins);
 94270:   EnumerateSubDocuments(AllSubDocumentPluginEnum, &aPlugins);
 94270: }
 94270: 
 50815: PLDHashOperator LockEnumerator(imgIRequest* aKey,
 50815:                                PRUint32 aData,
 50815:                                void*    userArg)
 50815: {
 50815:   aKey->LockImage();
 50815:   aKey->RequestDecode();
 50815:   return PL_DHASH_NEXT;
 50815: }
 50815: 
 50815: PLDHashOperator UnlockEnumerator(imgIRequest* aKey,
 50815:                                  PRUint32 aData,
 50815:                                  void*    userArg)
 50815: {
 50815:   aKey->UnlockImage();
 50815:   return PL_DHASH_NEXT;
 50815: }
 50815: 
 50815: 
 50815: nsresult
 79445: nsDocument::SetImageLockingState(bool aLocked)
 50815: {
 62607:   if (XRE_GetProcessType() == GeckoProcessType_Content &&
 79445:       !Preferences::GetBool("content.image.allow_locking", true)) {
 62607:     return NS_OK;
 62607:   }
 62607: 
 50815:   // If there's no change, there's nothing to do.
 50815:   if (mLockingImages == aLocked)
 50815:     return NS_OK;
 50815: 
 50815:   // Otherwise, iterate over our images and perform the appropriate action.
 50815:   mImageTracker.EnumerateRead(aLocked ? LockEnumerator
 50815:                                       : UnlockEnumerator,
 50815:                               nsnull);
 50815: 
 50815:   // Update state.
 50815:   mLockingImages = aLocked;
 50815: 
 50815:   return NS_OK;
 50815: }
 52149: 
 52149: PLDHashOperator IncrementAnimationEnumerator(imgIRequest* aKey,
 52149:                                              PRUint32 aData,
 52149:                                              void*    userArg)
 52149: {
 52149:   aKey->IncrementAnimationConsumers();
 52149:   return PL_DHASH_NEXT;
 52149: }
 52149: 
 52149: PLDHashOperator DecrementAnimationEnumerator(imgIRequest* aKey,
 52149:                                              PRUint32 aData,
 52149:                                              void*    userArg)
 52149: {
 52149:   aKey->DecrementAnimationConsumers();
 52149:   return PL_DHASH_NEXT;
 52149: }
 52149: 
 52149: void
 79445: nsDocument::SetImagesNeedAnimating(bool aAnimating)
 52149: {
 52149:   // If there's no change, there's nothing to do.
 52149:   if (mAnimatingImages == aAnimating)
 52149:     return;
 52149: 
 52149:   // Otherwise, iterate over our images and perform the appropriate action.
 52149:   mImageTracker.EnumerateRead(aAnimating ? IncrementAnimationEnumerator
 52149:                                          : DecrementAnimationEnumerator,
 52149:                               nsnull);
 52149: 
 52149:   // Update state.
 52149:   mAnimatingImages = aAnimating;
 52149: }
 68879: 
 68879: NS_IMETHODIMP
 69169: nsDocument::CreateTouch(nsIDOMWindow* aView,
 68879:                         nsIDOMEventTarget* aTarget,
 68879:                         PRInt32 aIdentifier,
 68879:                         PRInt32 aPageX,
 68879:                         PRInt32 aPageY,
 68879:                         PRInt32 aScreenX,
 68879:                         PRInt32 aScreenY,
 68879:                         PRInt32 aClientX,
 68879:                         PRInt32 aClientY,
 68879:                         PRInt32 aRadiusX,
 68879:                         PRInt32 aRadiusY,
 68879:                         float aRotationAngle,
 68879:                         float aForce,
 69025:                         nsIDOMTouch** aRetVal)
 69025: {
 69025:   NS_ADDREF(*aRetVal = new nsDOMTouch(aTarget,
 68879:                                       aIdentifier,
 68879:                                       aPageX,
 68879:                                       aPageY,
 68879:                                       aScreenX,
 68879:                                       aScreenY,
 68879:                                       aClientX,
 68879:                                       aClientY,
 68879:                                       aRadiusX,
 68879:                                       aRadiusY,
 68879:                                       aRotationAngle,
 68879:                                       aForce));
 69025:   return NS_OK;
 68879: }
 68879: 
 68879: NS_IMETHODIMP
 68879: nsDocument::CreateTouchList(nsIVariant* aPoints,
 68879:                             nsIDOMTouchList** aRetVal)
 68879: {
101976:   nsRefPtr<nsDOMTouchList> retval =
101976:     new nsDOMTouchList(static_cast<nsIDocument*>(this));
 68879:   if (aPoints) {
 68879:     PRUint16 type;
 68879:     aPoints->GetDataType(&type);
 68879:     if (type == nsIDataType::VTYPE_INTERFACE ||
 68879:         type == nsIDataType::VTYPE_INTERFACE_IS) {
 68879:       nsCOMPtr<nsISupports> data;
 68879:       aPoints->GetAsISupports(getter_AddRefs(data));
 69025:       nsCOMPtr<nsIDOMTouch> point = do_QueryInterface(data);
 68879:       if (point) {
 68879:         retval->Append(point);
 68879:       }
 68879:     } else if (type == nsIDataType::VTYPE_ARRAY) {
 68879:       PRUint16 valueType;
 68879:       nsIID iid;
 68879:       PRUint32 valueCount;
 68879:       void* rawArray;
 68879:       aPoints->GetAsArray(&valueType, &iid, &valueCount, &rawArray);
 68879:       if (valueType == nsIDataType::VTYPE_INTERFACE ||
 68879:           valueType == nsIDataType::VTYPE_INTERFACE_IS) {
 68879:         nsISupports** values = static_cast<nsISupports**>(rawArray);
 68879:         for (PRUint32 i = 0; i < valueCount; ++i) {
 68879:           nsCOMPtr<nsISupports> supports = dont_AddRef(values[i]);
 69025:           nsCOMPtr<nsIDOMTouch> point = do_QueryInterface(supports);
 68879:           if (point) {
 68879:             retval->Append(point);
 68879:           }
 68879:         }
 68879:       }
 68879:       nsMemory::Free(rawArray);
 68879:     }
 68879:   }
 68879: 
 68879:   *aRetVal = retval.forget().get();
 68879:   return NS_OK;
 68879: }
 70432: 
 81201: static void
 82412: DispatchFullScreenChange(nsIDocument* aTarget)
 81201: {
 84833:   nsRefPtr<nsAsyncDOMEvent> e =
 84833:     new nsAsyncDOMEvent(aTarget,
 77845:                         NS_LITERAL_STRING("mozfullscreenchange"),
 80486:                         true,
 80486:                         false);
 81201:   e->PostDOMEvent();
 77845: }
 81144: 
 81144: NS_IMETHODIMP
 81144: nsDocument::MozCancelFullScreen()
 81144: {
 81144:   if (!nsContentUtils::IsRequestFullScreenAllowed()) {
 81144:     return NS_OK;
 81144:   }
 84109:   RestorePreviousFullScreenState();
 81144:   return NS_OK;
 81144: }
 81144: 
 81144: // Runnable to set window full-screen mode. Used as a script runner
 81144: // to ensure we only call nsGlobalWindow::SetFullScreen() when it's safe to 
 81144: // run script. nsGlobalWindow::SetFullScreen() dispatches a synchronous event
 81144: // (handled in chome code) which is unsafe to run if this is called in
 81144: // nsGenericElement::UnbindFromTree().
 81144: class nsSetWindowFullScreen : public nsRunnable {
 81144: public:
 81144:   nsSetWindowFullScreen(nsIDocument* aDoc, bool aValue)
 81144:     : mDoc(aDoc), mValue(aValue) {}
 81144: 
 81144:   NS_IMETHOD Run()
 81144:   {
 81144:     if (mDoc->GetWindow()) {
 90457:       mDoc->GetWindow()->SetFullScreenInternal(mValue, false);
 81144:     }
 81144:     return NS_OK;
 81144:   }
 81144: 
 81144: private:
 81144:   nsCOMPtr<nsIDocument> mDoc;
 81144:   bool mValue;
 81144: };
 77843: 
 77843: static void
 81144: SetWindowFullScreen(nsIDocument* aDoc, bool aValue)
 81144: {
 81144:   nsContentUtils::AddScriptRunner(new nsSetWindowFullScreen(aDoc, aValue));
 77849: }
 77849: 
 84109: class nsCallExitFullScreen : public nsRunnable {
 84109: public:
 84109:   NS_IMETHOD Run()
 84109:   {
 84109:     nsDocument::ExitFullScreen();
 84109:     return NS_OK;
 84109:   }
 84109: };
 84109: 
 84109: /* static */
 84109: void
 84109: nsIDocument::ExitFullScreen(bool aRunAsync)
 84109: {
 84109:   if (aRunAsync) {
 84109:     NS_DispatchToCurrentThread(new nsCallExitFullScreen());
 84109:     return;
 84109:   }
 84109:   nsDocument::ExitFullScreen();
 84109: }
 84109: 
 84109: static bool
 84109: ResetFullScreen(nsIDocument* aDocument, void* aData) {
 84109:   if (aDocument->IsFullScreenDoc()) {
 99028:     static_cast<nsDocument*>(aDocument)->CleanupFullscreenState();
 84109:     NS_ASSERTION(!aDocument->IsFullScreenDoc(), "Should reset full-screen");
 84109:     nsTArray<nsIDocument*>* changed = reinterpret_cast<nsTArray<nsIDocument*>*>(aData);
 84109:     changed->AppendElement(aDocument);
 84109:     aDocument->EnumerateSubDocuments(ResetFullScreen, aData);
 84109:   }
 84109:   return true;
 84109: }
 84109: 
 84109: /* static */
 84109: void
 84109: nsDocument::ExitFullScreen()
 84109: {
 84109:   // Clear full-screen stacks in all descendant documents.
 84109:   nsCOMPtr<nsIDocument> root(do_QueryReferent(sFullScreenRootDoc));
 84109:   if (!root) {
 84109:     // Not in full-screen mode.
 84109:     return;
 84109:   }
 84109:   NS_ASSERTION(root->IsFullScreenDoc(),
 84109:     "Full-screen root should be a full-screen doc...");
 84109: 
 84109:   // Stores a list of documents to which we must dispatch "mozfullscreenchange".
 84109:   // We're required by the spec to dispatch the events in leaf-to-root
 84109:   // order when exiting full-screen, but we traverse the doctree in a
 84109:   // root-to-leaf order, so we save references to the documents we must
 84109:   // dispatch to so that we dispatch in the specified order.
 84109:   nsAutoTArray<nsIDocument*, 8> changed;
 84109: 
 95203:   // We may also need to unlock the pointer, if it's locked.
 95203:   nsCOMPtr<Element> pointerLockedElement =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:   if (pointerLockedElement) {
 95203:     UnlockPointer();
 95203:   }
 95203: 
 84109:   // Walk the tree of full-screen documents, and reset their full-screen state.
 84109:   ResetFullScreen(root, static_cast<void*>(&changed));
 84109: 
 84109:   // Dispatch "mozfullscreenchange" events. Note this loop is in reverse
 84109:   // order so that the events for the leaf document arrives before the root
 84109:   // document, as required by the spec.
 84109:   for (PRUint32 i = 0; i < changed.Length(); ++i) {
 84109:     DispatchFullScreenChange(changed[changed.Length() - i - 1]);
 84109:   }
 84109: 
 84109:   // Reset global state. Do this before we move the window out of full-screen
 84109:   // mode, as that calls nsGlobalWindow::SetFullScreen() which calls back into
 84109:   // nsIDocument::ExitFullScreen().
 84109:   sFullScreenRootDoc = nsnull;
 84109:   sFullScreenDoc = nsnull;
 84109: 
 84109:   // Move the top-level window out of full-screen mode.
 84109:   SetWindowFullScreen(root, false);
 84109: }
 84109: 
 84109: void
 84109: nsDocument::RestorePreviousFullScreenState()
 77849: {
 81144:   NS_ASSERTION(!IsFullScreenDoc() || sFullScreenDoc != nsnull,
 81144:                "Should have a full-screen doc when full-screen!");
 81144: 
 81144:   if (!IsFullScreenDoc() || !GetWindow() || !sFullScreenDoc) {
 77849:     return;
 77843:   }
 77843: 
 95203:   // If fullscreen mode is updated the pointer should be unlocked
 95203:   nsCOMPtr<Element> pointerLockedElement =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:   if (pointerLockedElement) {
 95203:     UnlockPointer();
 95203:   }
 95203: 
 84109:   // Clear full-screen stacks in all descendant documents, bottom up.
 84109:   nsCOMPtr<nsIDocument> fullScreenDoc(do_QueryReferent(sFullScreenDoc));
 84109:   nsIDocument* doc = fullScreenDoc;
 84109:   while (doc != this) {
 84109:     NS_ASSERTION(doc->IsFullScreenDoc(), "Should be full-screen doc");
 99028:     static_cast<nsDocument*>(doc)->CleanupFullscreenState();
 95203:     UnlockPointer();
 84109:     DispatchFullScreenChange(doc);
 84109:     doc = doc->GetParentDocument();
 84109:   }
 84109: 
 84109:   // Roll-back full-screen state to previous full-screen element.
 84109:   NS_ASSERTION(doc == this, "Must have reached this doc.");
 81144:   while (doc != nsnull) {
 84109:     static_cast<nsDocument*>(doc)->FullScreenStackPop();
 95203:     UnlockPointer();
 81201:     DispatchFullScreenChange(doc);
 84109:     if (static_cast<nsDocument*>(doc)->mFullScreenStack.IsEmpty()) {
 84109:       // Full-screen stack in document is empty. Go back up to the parent
 84109:       // document. We'll pop the containing element off its stack, and use
 84109:       // its next full-screen element as the full-screen element.
 99028:       static_cast<nsDocument*>(doc)->CleanupFullscreenState();
 81144:       doc = doc->GetParentDocument();
 84109:     } else {
 84109:       // Else we popped the top of the stack, and there's still another
 84109:       // element in there, so that will become the full-screen element.
 98046:       if (fullScreenDoc != doc) {
 98046:         // We've popped so enough off the stack that we've rolled back to
 98046:         // a fullscreen element in a parent document. If this document isn't
 99029:         // approved for fullscreen, or if it's cross origin, dispatch an
 99029:         // event to chrome so it knows to show the authorization/warning UI.
 99029:         if (!nsContentUtils::HaveEqualPrincipals(fullScreenDoc, doc) ||
 99029:             (!nsContentUtils::IsSitePermAllow(doc->NodePrincipal(), "fullscreen") &&
 99029:              !static_cast<nsDocument*>(doc)->mIsApprovedForFullscreen)) {
 98046:           nsRefPtr<nsAsyncDOMEvent> e =
 98046:             new nsAsyncDOMEvent(doc,
 98046:                                 NS_LITERAL_STRING("MozEnteredDomFullscreen"),
 98046:                                 true,
 98046:                                 true);
 98046:           e->PostDOMEvent();
 98046:         }
 98046:       }
 84109:       sFullScreenDoc = do_GetWeakReference(doc);
 84109:       break;
 84109:     }
 84109:   }
 84109: 
 84109:   if (doc == nsnull) {
 84109:     // We moved all documents out of full-screen mode, reset global full-screen
 84109:     // state and move the top-level window out of full-screen mode.
 84109:     DebugOnly< nsCOMPtr<nsIDocument> > root(do_QueryReferent(sFullScreenRootDoc));
 84109:     NS_ASSERTION(!root->IsFullScreenDoc(), "Should have cleared all docs' stacks");
 81144:     sFullScreenDoc = nsnull;
 81397:     sFullScreenRootDoc = nsnull;
 81144:     SetWindowFullScreen(this, false);
 84109:   }
 77843: }
 77843: 
 79445: bool
 77843: nsDocument::IsFullScreenDoc()
 77843: {
 84109:   return GetFullScreenElement() != nsnull;
 81144: }
 81144: 
 81437: class nsCallRequestFullScreen : public nsRunnable
 81437: {
 81437: public:
 81437:   nsCallRequestFullScreen(Element* aElement)
 81437:     : mElement(aElement),
 81437:       mDoc(aElement->OwnerDoc()),
 81437:       mWasCallerChrome(nsContentUtils::IsCallerChrome())
 81437:   {
 81437:   }
 81437: 
 81437:   NS_IMETHOD Run()
 81437:   {
 81437:     nsDocument* doc = static_cast<nsDocument*>(mDoc.get());
 81437:     doc->RequestFullScreen(mElement, mWasCallerChrome);
 81437:     return NS_OK;
 81437:   }
 81437: 
 81437:   nsRefPtr<Element> mElement;
 81437:   nsCOMPtr<nsIDocument> mDoc;
 81437:   bool mWasCallerChrome;
 81437: };
 81437: 
 81437: void
 81437: nsDocument::AsyncRequestFullScreen(Element* aElement)
 81437: {
 82583:   NS_ASSERTION(aElement,
 82583:     "Must pass non-null element to nsDocument::AsyncRequestFullScreen");
 81437:   if (!aElement) {
 81437:     return;
 81437:   }
 81437:   // Request full-screen asynchronously.
 81437:   nsCOMPtr<nsIRunnable> event(new nsCallRequestFullScreen(aElement));
 81437:   NS_DispatchToCurrentThread(event);
 81437: }
 81437: 
 82583: static void
 82583: LogFullScreenDenied(bool aLogFailure, const char* aMessage, nsIDocument* aDoc)
 82583: {
 82583:   if (!aLogFailure) {
 82583:     return;
 82583:   }
 84833:   nsRefPtr<nsAsyncDOMEvent> e =
 84833:     new nsAsyncDOMEvent(aDoc,
 81201:                         NS_LITERAL_STRING("mozfullscreenerror"),
 81201:                         true,
 81201:                         false);
 81201:   e->PostDOMEvent();
 84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                   "DOM", aDoc,
 84636:                                   nsContentUtils::eDOM_PROPERTIES,
 84636:                                   aMessage);
 82583: }
 82583: 
 99028: nsresult
 99028: nsDocument::AddFullscreenApprovedObserver()
 99028: {
 99028:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
 99028:   NS_ENSURE_TRUE(os, NS_ERROR_FAILURE);
 99028: 
 99028:   nsresult res = os->AddObserver(this, "fullscreen-approved", true);
 99028:   NS_ENSURE_SUCCESS(res, res);
 99028: 
 99028:   return NS_OK;
 99028: }
 99028: 
 99028: nsresult
 99028: nsDocument::RemoveFullscreenApprovedObserver()
 99028: {
 99028:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
 99028:   NS_ENSURE_TRUE(os, NS_ERROR_FAILURE);
 99028: 
 99028:   nsresult res = os->RemoveObserver(this, "fullscreen-approved");
 99028:   NS_ENSURE_SUCCESS(res, res);
 99028: 
 99028:   return NS_OK;
 99028: }
 99028: 
 99028: void
 99028: nsDocument::CleanupFullscreenState()
 99028: {
 99028:   if (!mFullScreenStack.IsEmpty()) {
 84109:     // The top element in the full-screen stack will have full-screen
 84109:     // style bits set on it and its ancestors. Remove the style bits.
 84109:     // Note the non-top elements won't have the style bits set.
 84109:     Element* top = FullScreenStackTop();
 84109:     NS_ASSERTION(top, "Should have a top when full-screen stack isn't empty");
 84109:     if (top) {
 84109:       nsEventStateManager::SetFullScreenState(top, false);
 84109:     }
 84109:     mFullScreenStack.Clear();
 84109:   }
 99028:   SetApprovedForFullscreen(false);
 99028:   RemoveFullscreenApprovedObserver();
 99028: }
 84109: 
 84109: bool
 84109: nsDocument::FullScreenStackPush(Element* aElement)
 84109: {
 84109:   NS_ASSERTION(aElement, "Must pass non-null to FullScreenStackPush()");
 84109:   Element* top = FullScreenStackTop();
 84109:   if (top == aElement || !aElement) {
 84109:     return false;
 84109:   }
 84109:   if (top) {
 84109:     // We're pushing a new element onto the full-screen stack, so we must
 84109:     // remove the ancestor and full-screen styles from the former top of the
 84109:     // stack.
 84109:     nsEventStateManager::SetFullScreenState(top, false);
 84109:   }
 84109:   nsEventStateManager::SetFullScreenState(aElement, true);
 84109:   mFullScreenStack.AppendElement(do_GetWeakReference(aElement));
 84109:   NS_ASSERTION(GetFullScreenElement() == aElement, "Should match");
 84109:   return true;
 84109: }
 84109: 
 84109: void
 84109: nsDocument::FullScreenStackPop()
 84109: {
 84109:   if (mFullScreenStack.IsEmpty()) {
 84109:     return;
 84109:   }
 84109: 
 84109:   // Remove styles from existing top element.
 84109:   Element* top = FullScreenStackTop();
 84109:   nsEventStateManager::SetFullScreenState(top, false);
 84109: 
 84109:   // Remove top element. Note the remaining top element in the stack
 84109:   // will not have full-screen style bits set, so we will need to restore
 84109:   // them on the new top element before returning.
 84109:   PRUint32 last = mFullScreenStack.Length() - 1;
 84109:   mFullScreenStack.RemoveElementAt(last);
 84109: 
 84109:   // Pop from the stack null elements (references to elements which have
 84109:   // been GC'd since they were added to the stack) and elements which are
 84109:   // no longer in this document.
 84109:   while (!mFullScreenStack.IsEmpty()) {
 84109:     Element* element = FullScreenStackTop();
 84109:     if (!element || !element->IsInDoc() || element->OwnerDoc() != this) {
 84109:       NS_ASSERTION(!element->IsFullScreenAncestor(),
 84109:                    "Should have already removed full-screen styles");
 84109:       PRUint32 last = mFullScreenStack.Length() - 1;
 84109:       mFullScreenStack.RemoveElementAt(last);
 84109:     } else {
 84109:       // The top element of the stack is now an in-doc element. Apply the
 84109:       // full-screen styles and return.
 84109:       nsEventStateManager::SetFullScreenState(element, true);
 84109:       break;
 84109:     }
 84109:   }
 84109: }
 84109: 
 84109: Element*
 84109: nsDocument::FullScreenStackTop()
 84109: {
 84109:   if (mFullScreenStack.IsEmpty()) {
 84109:     return nsnull;
 84109:   }
 84109:   PRUint32 last = mFullScreenStack.Length() - 1;
 84109:   nsCOMPtr<Element> element(do_QueryReferent(mFullScreenStack[last]));
 84109:   NS_ASSERTION(element, "Should have full-screen element!");
 84109:   NS_ASSERTION(element->IsInDoc(), "Full-screen element should be in doc");
 84109:   NS_ASSERTION(element->OwnerDoc() == this, "Full-screen element should be in this doc");
 84109:   return element;
 84109: }
 84109: 
 84911: // Returns true if aDoc is in the focused tab in the active window.
 84911: static bool
 84911: IsInActiveTab(nsIDocument* aDoc)
 84911: {
 84911:   nsCOMPtr<nsISupports> container = aDoc->GetContainer();
 84911:   nsCOMPtr<nsIDocShell> docshell = do_QueryInterface(container);
 84911:   if (!docshell) {
 84911:     return false;
 84911:   }
 84911: 
 84911:   bool isActive = false;
 84911:   docshell->GetIsActive(&isActive);
 84911:   if (!isActive) {
 84911:     return false;
 84911:   }
 84911:   
 84911:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(container);
 84911:   if (!dsti) {
 84911:     return false;
 84911:   }
 84911:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
 84911:   dsti->GetRootTreeItem(getter_AddRefs(rootItem));
 84911:   if (!rootItem) {
 84911:     return false;
 84911:   }
 84911:   nsCOMPtr<nsIDOMWindow> rootWin = do_GetInterface(rootItem);
 84911:   if (!rootWin) {
 84911:     return false;
 84911:   }
 84911: 
 84911:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 84911:   if (!fm) {
 84911:     return false;
 84911:   }
 84911: 
 84911:   nsCOMPtr<nsIDOMWindow> activeWindow;
 84911:   fm->GetActiveWindow(getter_AddRefs(activeWindow));
 84911:   if (!activeWindow) {
 84911:     return false;
 84911:   }
 84911: 
 84911:   return activeWindow == rootWin;
 84911: }
 84911: 
 84109: void
 82583: nsDocument::RequestFullScreen(Element* aElement, bool aWasCallerChrome)
 82583: {
 82583:   NS_ASSERTION(aElement,
 82583:     "Must pass non-null element to nsDocument::RequestFullScreen");
 84109:   if (!aElement || aElement == GetFullScreenElement()) {
 82583:     return;
 82583:   }
 82583:   if (!aElement->IsInDoc()) {
 82583:     LogFullScreenDenied(true, "FullScreenDeniedNotInDocument", this);
 82583:     return;
 82583:   }
 82583:   if (aElement->OwnerDoc() != this) {
 82583:     LogFullScreenDenied(true, "FullScreenDeniedMovedDocument", this);
 82583:     return;
 82583:   }
 82583:   if (!GetWindow()) {
 82583:     LogFullScreenDenied(true, "FullScreenDeniedLostWindow", this);
 82583:     return;
 82583:   }
 82583:   if (!IsFullScreenEnabled(aWasCallerChrome, true)) {
 82583:     // IsFullScreenEnabled calls LogFullScreenDenied, no need to log.
 77843:     return;
 77843:   }
 84109:   if (GetFullScreenElement() &&
 84109:       !nsContentUtils::ContentIsDescendantOf(aElement, GetFullScreenElement())) {
 84109:     // If this document is full-screen, only grant full-screen requests from 
 84109:     // a descendent of the current full-screen element.
 84109:     LogFullScreenDenied(true, "FullScreenDeniedNotDescendant", this);
 84109:     return;
 84109:   }
 84911:   if (!nsContentUtils::IsChromeDoc(this) && !IsInActiveTab(this)) {
 84911:     LogFullScreenDenied(true, "FullScreenDeniedNotFocusedTab", this);
 84911:     return;
 84911:   }
 84911:   // Deny requests when a windowed plugin is focused.
 84911:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 84911:   if (!fm) {
 84911:     NS_WARNING("Failed to retrieve focus manager in full-screen request.");
 84911:     return;
 84911:   }
 84911:   nsCOMPtr<nsIDOMElement> focusedElement;
 84911:   fm->GetFocusedElement(getter_AddRefs(focusedElement));
 84911:   if (focusedElement) {
 84911:     nsCOMPtr<nsIContent> content = do_QueryInterface(focusedElement);
 84911:     if (nsContentUtils::HasPluginWithUncontrolledEventDispatch(content)) {
 84911:       LogFullScreenDenied(true, "FullScreenDeniedFocusedPlugin", this);
 84911:       return;
 84911:     }
 84911:   }
 84109: 
 99028:   AddFullscreenApprovedObserver();
 99028: 
 84109:   // Stores a list of documents which we must dispatch "mozfullscreenchange"
 84109:   // too. We're required by the spec to dispatch the events in root-to-leaf
 84109:   // order, but we traverse the doctree in a leaf-to-root order, so we save
 84109:   // references to the documents we must dispatch to so that we get the order
 84109:   // as specified.
 84109:   nsAutoTArray<nsIDocument*, 8> changed;
 84109: 
 81397:   // Remember the root document, so that if a full-screen document is hidden
 82213:   // we can reset full-screen state in the remaining visible full-screen documents.
 95203:   nsIDocument* fullScreenDoc = nsContentUtils::GetRootDocument(this);
 95203:   sFullScreenRootDoc = do_GetWeakReference(fullScreenDoc);
 95203: 
 95203:   // If a document is already in fullscreen, then unlock the mouse pointer
 95203:   // before setting a new document to fullscreen
 95203:   if (fullScreenDoc) {
 95203:     UnlockPointer();
 95203:   }
 95203: 
 95203:   // If a document is already in fullscreen, then unlock the mouse pointer
 95203:   // before setting a new document to fullscreen
 95203:   nsCOMPtr<Element> pointerLockedElement =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:   if (pointerLockedElement) {
 95203:     UnlockPointer();
 95203:   }
 81397: 
 81144:   // Set the full-screen element. This sets the full-screen style on the
 81144:   // element, and the full-screen-ancestor styles on ancestors of the element
 81144:   // in this document.
 84109:   DebugOnly<bool> x = FullScreenStackPush(aElement);
 84109:   NS_ASSERTION(x, "Full-screen state of requesting doc should always change!");
 84109:   changed.AppendElement(this);
 81144:   
 77843:   // Propagate up the document hierarchy, setting the full-screen element as
 81144:   // the element's container in ancestor documents. This also sets the
 81144:   // appropriate css styles as well. Note we don't propagate down the
 81144:   // document hierarchy, the full-screen element (or its container) is not
 81144:   // visible there.  
 77843:   nsIDocument* child = this;
 77843:   nsIDocument* parent;
 81144:   while ((parent = child->GetParentDocument())) {
 81144:     Element* element = parent->FindContentForSubDocument(child)->AsElement();
 84109:     if (static_cast<nsDocument*>(parent)->FullScreenStackPush(element)) {
 84109:       changed.AppendElement(parent);
 77843:       child = parent;
 84109:     } else {
 84109:       // We've reached either the root, or a point in the doctree where the
 84109:       // new full-screen element container is the same as the previous
 84109:       // full-screen element's container. No more changes need to be made
 84109:       // to the full-screen stacks of documents further up the tree.
 84109:       break;
 84109:     }
 84109:   }
 84109: 
 84109:   // Dispatch "mozfullscreenchange" events. Note this loop is in reverse
 84109:   // order so that the events for the root document arrives before the leaf
 84109:   // document, as required by the spec.
 84109:   for (PRUint32 i = 0; i < changed.Length(); ++i) {
 84109:     DispatchFullScreenChange(changed[changed.Length() - i - 1]);
 84109:   }
 84109: 
 99029:   // If this document hasn't already been approved in this session,
 99029:   // check to see if the user has granted the fullscreen access
 99029:   // to the document's principal's host, if it has one.
 99029:   if (!mIsApprovedForFullscreen) {
 99029:     mIsApprovedForFullscreen =
 99029:       nsContentUtils::IsSitePermAllow(NodePrincipal(), "fullscreen");
 99029:   }
 99029: 
 99029:   // If this document, or a document with the same principal has not
 99029:   // already been approved for fullscreen this fullscreen-session, dispatch
 99029:   // an event so that chrome knows to pop up a warning/approval UI.
 99029:   nsCOMPtr<nsIDocument> previousFullscreenDoc(do_QueryReferent(sFullScreenDoc));
 99029:   // Note previousFullscreenDoc=nsnull upon first entry, so we always
 99029:   // take this path on the first time we enter fullscreen in a fullscreen
 99029:   // session.
 99029:   if (!mIsApprovedForFullscreen ||
 99029:       !nsContentUtils::HaveEqualPrincipals(previousFullscreenDoc, this)) {
 98046:     nsRefPtr<nsAsyncDOMEvent> e =
 98046:       new nsAsyncDOMEvent(this,
 98046:                           NS_LITERAL_STRING("MozEnteredDomFullscreen"),
 98046:                           true,
 98046:                           true);
 98046:     e->PostDOMEvent();
 99028:   }
 99028: 
 84109:   // Remember this is the requesting full-screen document.
 84109:   sFullScreenDoc = do_GetWeakReference(static_cast<nsIDocument*>(this));
 77843: 
 84109: #ifdef DEBUG
 86721:   // Note assertions must run before SetWindowFullScreen() as that does
 86721:   // synchronous event dispatch which can run script which exits full-screen!
 84109:   NS_ASSERTION(GetFullScreenElement() == aElement,
 84109:                "Full-screen element should be the requested element!");
 84109:   NS_ASSERTION(IsFullScreenDoc(), "Should be full-screen doc");
 93984:   nsCOMPtr<nsIDOMElement> fse;
 84109:   GetMozFullScreenElement(getter_AddRefs(fse));
 84109:   nsCOMPtr<nsIContent> c(do_QueryInterface(fse));
 84109:   NS_ASSERTION(c->AsElement() == aElement,
 84109:     "GetMozFullScreenElement should match GetFullScreenElement()");
 84109: #endif
 86721: 
 86721:   // Make the window full-screen. Note we must make the state changes above
 86721:   // before making the window full-screen, as then the document reports as
 86721:   // being in full-screen mode when the chrome "fullscreen" event fires,
 86721:   // enabling chrome to distinguish between browser and dom full-screen
 86721:   // modes. Also note that nsGlobalWindow::SetFullScreen() (which
 86721:   // SetWindowFullScreen() calls) proxies to the root window in its hierarchy,
 86721:   // and does not operate on the a per-nsIDOMWindow basis.
 86721:   SetWindowFullScreen(this, true);
 77843: }
 77843: 
 77843: NS_IMETHODIMP
 93984: nsDocument::GetMozFullScreenElement(nsIDOMElement **aFullScreenElement)
 77843: {
 77843:   NS_ENSURE_ARG_POINTER(aFullScreenElement);
 77843:   *aFullScreenElement = nsnull;
 81144:   if (IsFullScreenDoc()) {
 81144:     // Must have a full-screen element while in full-screen mode.
 81144:     NS_ENSURE_STATE(GetFullScreenElement());
 81144:     CallQueryInterface(GetFullScreenElement(), aFullScreenElement);
 81144:   }
 77843:   return NS_OK;
 77843: }
 77843: 
 77843: Element*
 77843: nsDocument::GetFullScreenElement()
 77843: {
 84109:   Element* element = FullScreenStackTop();
 84109:   NS_ASSERTION(!element || element->IsFullScreenAncestor(),
 84109:     "Should have full-screen styles applied!");
 84109:   return element;
 77843: }
 77843: 
 77843: NS_IMETHODIMP
 79445: nsDocument::GetMozFullScreen(bool *aFullScreen)
 77843: {
 77843:   NS_ENSURE_ARG_POINTER(aFullScreen);
 81144:   *aFullScreen = IsFullScreenDoc();
 77843:   return NS_OK;
 77843: }
 77843: 
 79721: NS_IMETHODIMP
 79721: nsDocument::GetMozFullScreenEnabled(bool *aFullScreen)
 79721: {
 79721:   NS_ENSURE_ARG_POINTER(aFullScreen);
 82583:   *aFullScreen = IsFullScreenEnabled(nsContentUtils::IsCallerChrome(), false);
 81437:   return NS_OK;
 81437: }
 81437: 
 84109: static bool
 84109: HasFullScreenSubDocument(nsIDocument* aDoc, void* aData)
 84109: {
 84109:   if (aDoc->IsFullScreenDoc()) {
 84109:     // This subdocument is full-screen. Set result and return false to
 84109:     // stop iteration.
 84109:     *static_cast<bool*>(aData) = true;
 84109:     return false;
 84109:   }
 84109:   return true;
 84109: }
 84109: 
 84109: static bool
 84109: HasFullScreenSubDocument(nsIDocument* aDoc)
 84109: {
 84109:   bool result = false;
 84109:   aDoc->EnumerateSubDocuments(&HasFullScreenSubDocument, static_cast<void*>(&result));
 84109:   return result;
 84109: }
 84109: 
 81437: bool
 82583: nsDocument::IsFullScreenEnabled(bool aCallerIsChrome, bool aLogFailure)
 81437: {
 81437:   if (nsContentUtils::IsFullScreenApiEnabled() && aCallerIsChrome) {
 81308:     // Chrome code can always use the full-screen API, provided it's not
 81437:     // explicitly disabled. Note IsCallerChrome() returns true when running
 81437:     // in an nsRunnable, so don't use GetMozFullScreenEnabled() from an
 81437:     // nsRunnable!
 81437:     return true;
 81308:   }
 81308: 
 82583:   if (!nsContentUtils::IsFullScreenApiEnabled()) {
 82583:     LogFullScreenDenied(aLogFailure, "FullScreenDeniedDisabled", this);
 82583:     return false;
 82583:   }
 82583:   if (!IsVisible()) {
 82583:     LogFullScreenDenied(aLogFailure, "FullScreenDeniedHidden", this);
 81437:     return false;
 80916:   }
 84109:   if (HasFullScreenSubDocument(this)) {
 84109:     LogFullScreenDenied(aLogFailure, "FullScreenDeniedSubDocFullScreen", this);
 84109:     return false;
 84109:   }
 79721: 
 79721:   // Ensure that all ancestor <iframe> elements have the mozallowfullscreen
 79721:   // boolean attribute set.
 79721:   nsINode* node = static_cast<nsINode*>(this);
 79721:   do {
 79721:     nsIContent* content = static_cast<nsIContent*>(node);
 79721:     if (content->IsHTML(nsGkAtoms::iframe) &&
 79721:         !content->HasAttr(kNameSpaceID_None, nsGkAtoms::mozallowfullscreen)) {
 79721:       // The node requesting fullscreen, or one of its crossdoc ancestors,
 79721:       // is an iframe which doesn't have the "mozalllowfullscreen" attribute.
 79721:       // This request is not authorized by the parent document.
 82583:       LogFullScreenDenied(aLogFailure, "FullScreenDeniedIframeDisallowed", this);
 81437:       return false;
 79721:     }
 79721:     node = nsContentUtils::GetCrossDocParentNode(node);
 79721:   } while (node);
 79721: 
 81437:   return true;
 79721: }
 79721: 
 95203: static void
 95203: DispatchPointerLockChange(nsIDocument* aTarget)
 95203: {
 95203:   nsRefPtr<nsAsyncDOMEvent> e =
 95203:     new nsAsyncDOMEvent(aTarget,
 95203:                         NS_LITERAL_STRING("mozpointerlockchange"),
 95203:                         true,
 95203:                         false);
 95203:   e->PostDOMEvent();
 95203: }
 95203: 
 95203: static void
 95203: DispatchPointerLockError(nsIDocument* aTarget)
 95203: {
 95203:   nsRefPtr<nsAsyncDOMEvent> e =
 95203:     new nsAsyncDOMEvent(aTarget,
 95203:                         NS_LITERAL_STRING("mozpointerlockerror"),
 95203:                         true,
 95203:                         false);
 95203:   e->PostDOMEvent();
 95203: }
 95203: 
 98051: // Manages asynchronously requesting pointer lock. Used to dispatch an
 98051: // event to request pointer lock once fullscreen has been approved.
 98051: class nsAsyncPointerLockRequest : public nsRunnable
 98051: {
 98051: public:
 98051:   NS_IMETHOD Run()
 98051:   {
 98051:     sInstance = nsnull;
 98051:     if (mDocument && mElement) {
 98051:       mDocument->RequestPointerLock(mElement);
 98051:     }
 98051:     return NS_OK;
 98051:   }
 98051: 
 98051:   static void Request(Element* aElement, nsIDocument* aDocument)
 98051:   {
 98051:     if (sInstance) {
 98051:       // We already have an event instance pending. Change the requestee
 98051:       // to the new pointer lock requestee.
 98051:       sInstance->mElement = aElement;
 98051:       sInstance->mDocument = aDocument;
 98051:     } else {
 98051:       // Create a new event instance. Owning ref is held by the nsIEventTarget
 98051:       // to which this is dispatched.
 98051:       sInstance = new nsAsyncPointerLockRequest(aElement, aDocument);
 98051:       NS_DispatchToCurrentThread(sInstance);
 98051:     }
 98051:   }
 98051: 
 98051:   static void Cancel()
 98051:   {
 98051:     if (sInstance) {
 98051:       // Revoke references to requesting element/document, when the
 98051:       // dispatched event runs. The event will do nothing, and then be
 98051:       // destroyed.
 98051:       sInstance->mElement = nsnull;
 98051:       sInstance->mDocument = nsnull;
 98051:     }
 98051:   }
 98051: 
 98051: private:
 98051:   nsAsyncPointerLockRequest(Element* aElement, nsIDocument* aDocument)
 98051:     : mElement(aElement),
 98051:       mDocument(aDocument)
 98051:   {
 98051:     MOZ_COUNT_CTOR(nsAsyncPointerLockRequest);
 98051:   }
 98051: 
 98051:   ~nsAsyncPointerLockRequest()
 98051:   {
 98051:     MOZ_COUNT_DTOR(nsAsyncPointerLockRequest);
 98051:   }
 98051: 
 98051:   // Reference to the instance of any pending event. This is not an owning
 98051:   // reference; the nsIEventTarget to which this is dispatched holds the only
 98051:   // owning reference to this instance. This reference is valid between
 98051:   // an instance being created, and its Run() method being called.
 98051:   static nsAsyncPointerLockRequest* sInstance;
 98051: 
 98051:   // Element and document which reqested pointer lock.
 98051:   nsCOMPtr<Element> mElement;
 98051:   nsCOMPtr<nsIDocument> mDocument;
 98051: };
 98051: 
 98051: nsAsyncPointerLockRequest* nsAsyncPointerLockRequest::sInstance = nsnull;
 98051: nsWeakPtr nsDocument::sPendingPointerLockDoc;
 98051: nsWeakPtr nsDocument::sPendingPointerLockElement;
 98051: 
 98051: /* static */
 98051: void
 98051: nsDocument::ClearPendingPointerLockRequest(bool aDispatchErrorEvents)
 98051: {
 98051:   nsAsyncPointerLockRequest::Cancel();
 98051: 
 98051:   if (!sPendingPointerLockDoc) {
 98051:     // No pending request.
 98051:     return;
 98051:   }
 98051:   nsCOMPtr<nsIDocument> doc(do_QueryReferent(sPendingPointerLockDoc));
 98051:   if (aDispatchErrorEvents) {
 98051:     DispatchPointerLockError(doc);
 98051:   }
 98051:   nsCOMPtr<Element> element(do_QueryReferent(sPendingPointerLockElement));
 98051: #ifdef DEBUG
 98051:   nsCOMPtr<Element> pointerLockedElement =
 98051:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 98051:   NS_ASSERTION(pointerLockedElement != element,
 98051:     "We shouldn't be clearing pointer locked flag on pointer locked element!");
 98051: #endif
 98051:   if (element) {
 98051:     element->ClearPointerLock();
 98051:   }
 98051:   sPendingPointerLockDoc = nsnull;
 98051:   sPendingPointerLockElement = nsnull;
 98051: }
 98051: 
 98051: /* static */
 98051: nsresult
 98051: nsDocument::SetPendingPointerLockRequest(Element* aElement)
 98051: {
 98051:   // If there's an existing pending pointer lock request, deny it.
 98051:   ClearPendingPointerLockRequest(true);
 98051: 
 98051:   NS_ENSURE_TRUE(aElement != nsnull, NS_ERROR_FAILURE);
 98051: 
 98051:   sPendingPointerLockDoc = do_GetWeakReference(aElement->OwnerDoc());
 98051:   sPendingPointerLockElement = do_GetWeakReference(aElement);
 98051: 
 98051:   // Set the pointer lock flag, so that if the element is removed from
 98051:   // its document we know to cancel the pending request.
 98051:   aElement->SetPointerLock();
 98051: 
 98051:   return NS_OK;
 98051: }
 98051: 
 99028: void
 99028: nsDocument::SetApprovedForFullscreen(bool aIsApproved)
 99028: {
 99028:   mIsApprovedForFullscreen = aIsApproved;
 99028: }
 99028: 
 98051: nsresult
 98051: nsDocument::Observe(nsISupports *aSubject,
 98051:                     const char *aTopic,
 98051:                     const PRUnichar *aData)
 98051: {
 99026:   if (strcmp("fullscreen-approved", aTopic) == 0) {
 99026:     nsCOMPtr<nsIDocument> subject(do_QueryInterface(aSubject));
 99028:     if (subject != this) {
 99028:       return NS_OK;
 99028:     }
 99028:     SetApprovedForFullscreen(true);
 98051:     nsCOMPtr<nsIDocument> doc(do_QueryReferent(sPendingPointerLockDoc));
 99028:     if (this == doc) {
 99028:       // This doc has a pointer lock request, waiting for fullscreen to be
 99028:       // approved before it can be granted. Process the pointer lock request.
 98051:       nsCOMPtr<Element> element(do_QueryReferent(sPendingPointerLockElement));
 98051:       nsDocument::ClearPendingPointerLockRequest(false);
 99028:       nsAsyncPointerLockRequest::Request(element, this);
 98051:     }
 98051:   }
 98051:   return NS_OK;
 98051: }
 98051: 
 95203: void
 95203: nsDocument::RequestPointerLock(Element* aElement)
 95203: {
 95203:   NS_ASSERTION(aElement,
 95203:     "Must pass non-null element to nsDocument::RequestPointerLock");
 95203: 
 95203:   nsCOMPtr<Element> pointerLockedElement =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:   if (aElement == pointerLockedElement) {
 95203:     DispatchPointerLockChange(this);
 95203:     return;
 95203:   }
 95203: 
 98051:   if (!ShouldLockPointer(aElement)) {
 98051:     DispatchPointerLockError(this);
 98051:     return;
 98051:   }
 98051: 
 99028:   if (!mIsApprovedForFullscreen) {
 99028:     // Document isn't yet approved for fullscreen, so we must wait until
 98051:     // it's been approved.
 98051:     if (NS_FAILED(SetPendingPointerLockRequest(aElement))) {
 98051:       NS_WARNING("Failed to make pointer lock request pending!");
 98051:       DispatchPointerLockError(this);
 98051:     }
 98051:     return;
 98051:   }
 98051: 
 98051:   // If there's an existing pending pointer lock request, deny it.
 98051:   nsDocument::ClearPendingPointerLockRequest(true);
 98051: 
 98051:   if (!SetPointerLock(aElement, NS_STYLE_CURSOR_NONE)) {
 95203:     DispatchPointerLockError(this);
 95203:     return;
 95203:   }
 95203: 
 95203:   aElement->SetPointerLock();
 95203:   nsEventStateManager::sPointerLockedElement = do_GetWeakReference(aElement);
 95203:   nsEventStateManager::sPointerLockedDoc =
 95203:     do_GetWeakReference(static_cast<nsIDocument*>(this));
 95203:   DispatchPointerLockChange(this);
 95203: }
 95203: 
 95203: bool
 95203: nsDocument::ShouldLockPointer(Element* aElement)
 95203: {
 95203:   // Check if pointer lock pref is enabled
 95203:   if (!Preferences::GetBool("full-screen-api.pointer-lock.enabled")) {
 95203:     NS_WARNING("ShouldLockPointer(): Pointer Lock pref not enabled");
 95203:     return false;
 95203:   }
 95203: 
 95203:   if (aElement != GetFullScreenElement()) {
 95203:     NS_WARNING("ShouldLockPointer(): Element not in fullscreen");
 95203:     return false;
 95203:   }
 95203: 
 95203:   if (!aElement->IsInDoc()) {
 95203:     NS_WARNING("ShouldLockPointer(): Element without Document");
 95203:     return false;
 95203:   }
 95203: 
 95203:   // Check if the element is in a document with a docshell.
 95203:   nsCOMPtr<nsIDocument> ownerDoc = aElement->OwnerDoc();
 95203:   if (!ownerDoc) {
 95203:     return false;
 95203:   }
 95203:   if (!nsCOMPtr<nsISupports>(ownerDoc->GetContainer())) {
 95203:     return false;
 95203:   }
 95203:   nsCOMPtr<nsPIDOMWindow> ownerWindow = ownerDoc->GetWindow();
 95203:   if (!ownerWindow) {
 95203:     return false;
 95203:   }
 95203:   nsCOMPtr<nsPIDOMWindow> ownerInnerWindow = ownerDoc->GetInnerWindow();
 95203:   if (!ownerInnerWindow) {
 95203:     return false;
 95203:   }
 95203:   if (ownerWindow->GetCurrentInnerWindow() != ownerInnerWindow) {
 95203:     return false;
 95203:   }
 95203: 
 95203:   return true;
 95203: }
 95203: 
 95203: bool
 95203: nsDocument::SetPointerLock(Element* aElement, int aCursorStyle)
 95203: {
 95203:   // NOTE: aElement will be nsnull when unlocking.
 95203:   nsCOMPtr<nsPIDOMWindow> window = GetWindow();
 95203:   if (!window) {
 95203:     NS_WARNING("SetPointerLock(): No Window");
 95203:     return false;
 95203:   }
 95203: 
 95203:   nsIDocShell *docShell = window->GetDocShell();
 95203:   if (!docShell) {
 95203:     NS_WARNING("SetPointerLock(): No DocShell (window already closed?)");
 95203:     return false;
 95203:   }
 95203: 
 95203:   nsRefPtr<nsPresContext> presContext;
 95203:   docShell->GetPresContext(getter_AddRefs(presContext));
 95203:   if (!presContext) {
 95203:     NS_WARNING("SetPointerLock(): Unable to get presContext in \
 95203:                 domWindow->GetDocShell()->GetPresContext()");
 95203:     return false;
 95203:   }
 95203: 
 95203:   nsCOMPtr<nsIPresShell> shell = presContext->PresShell();
 95203:   if (!shell) {
 95203:     NS_WARNING("SetPointerLock(): Unable to find presContext->PresShell()");
 95203:     return false;
 95203:   }
 95203: 
 95203:   nsIFrame* rootFrame = shell->GetRootFrame();
 95203:   if (!rootFrame) {
 95203:     NS_WARNING("SetPointerLock(): Unable to get root frame");
 95203:     return false;
 95203:   }
 95203: 
 95203:   nsCOMPtr<nsIWidget> widget = rootFrame->GetNearestWidget();
 95203:   if (!widget) {
 95203:     NS_WARNING("SetPointerLock(): Unable to find widget in \
 95203:                 shell->GetRootFrame()->GetNearestWidget();");
 95203:     return false;
 95203:   }
 95203: 
 95203:   if (aElement && (aElement->OwnerDoc() != this)) {
 95203:     NS_WARNING("SetPointerLock(): Element not in this document.");
 95203:     return false;
 95203:   }
 95203: 
 95203:   // Hide the cursor and set pointer lock for future mouse events
 95203:   nsRefPtr<nsEventStateManager> esm = presContext->EventStateManager();
 95203:   esm->SetCursor(aCursorStyle, nsnull, false,
 95203:                  0.0f, 0.0f, widget, true);
 95203:   esm->SetPointerLock(widget, aElement);
 95203: 
 95203:   return true;
 95203: }
 95203: 
 95203: void
 95203: nsDocument::UnlockPointer()
 95203: {
 98051:   // If our pointer lock request is pending awaiting authorization, deny the
 98051:   // request.
 98051:   ClearPendingPointerLockRequest(true);
 98051: 
 95203:   if (!nsEventStateManager::sIsPointerLocked) {
 95203:     return;
 95203:   }
 95203: 
 95203:   nsCOMPtr<nsIDocument> pointerLockedDoc =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedDoc);
 95203:   if (!pointerLockedDoc) {
 95203:     return;
 95203:   }
 95203:   nsDocument* doc = static_cast<nsDocument*>(pointerLockedDoc.get());
 95203:   if (!doc->SetPointerLock(nsnull, NS_STYLE_CURSOR_AUTO)) {
 95203:     return;
 95203:   }
 95203: 
 95203:   nsCOMPtr<Element> pointerLockedElement =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:   if (!pointerLockedElement) {
 95203:     return;
 95203:   }
 95203: 
 95203:   nsEventStateManager::sPointerLockedElement = nsnull;
 95203:   nsEventStateManager::sPointerLockedDoc = nsnull;
 95203:   pointerLockedElement->ClearPointerLock();
 95203:   DispatchPointerLockChange(pointerLockedDoc);
 95203: }
 95203: 
 95203: void
 95203: nsIDocument::UnlockPointer()
 95203: {
 95203:   nsDocument::UnlockPointer();
 95203: }
 95203: 
 95203: NS_IMETHODIMP
 95203: nsDocument::MozExitPointerLock()
 95203: {
 95203:   UnlockPointer();
 95203:   return NS_OK;
 95203: }
 95203: 
 95203: NS_IMETHODIMP
 95203: nsDocument::GetMozPointerLockElement(nsIDOMElement** aPointerLockedElement)
 95203: {
 95203:   NS_ENSURE_ARG_POINTER(aPointerLockedElement);
 95203:   *aPointerLockedElement = nsnull;
 95203:   nsCOMPtr<Element> pointerLockedElement =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:   if (!pointerLockedElement) {
 95203:     return NS_OK;
 95203:   }
 95203: 
 95203:   // Make sure pointer locked element is in the same document and domain.
 95203:   nsCOMPtr<nsIDocument> pointerLockedDoc =
 95203:     do_QueryReferent(nsEventStateManager::sPointerLockedDoc);
 95203:   nsDocument* doc = static_cast<nsDocument*>(pointerLockedDoc.get());
 95203:   if (doc != this) {
 95203:     return NS_OK;
 95203:   }
 95203:   nsCOMPtr<nsIDOMNode> pointerLockedNode =
 95203:     do_QueryInterface(pointerLockedElement);
 95203:   nsresult rv = nsContentUtils::CheckSameOrigin(this, pointerLockedNode.get());
 95203:   if (NS_FAILED(rv)) {
 95203:     return NS_OK;
 95203:   }
 95203: 
 95203:   return CallQueryInterface(pointerLockedElement, aPointerLockedElement);
 95203: }
 95203: 
 77149: #define EVENT(name_, id_, type_, struct_)                                 \
 77149:   NS_IMETHODIMP nsDocument::GetOn##name_(JSContext *cx, jsval *vp) {      \
 77149:     return nsINode::GetOn##name_(cx, vp);                                 \
 77149:   }                                                                       \
 77149:   NS_IMETHODIMP nsDocument::SetOn##name_(JSContext *cx, const jsval &v) { \
 77149:     return nsINode::SetOn##name_(cx, v);                                  \
 77149:   }
 77149: #define TOUCH_EVENT EVENT
 78484: #define DOCUMENT_ONLY_EVENT EVENT
 77149: #include "nsEventNameList.h"
 78484: #undef DOCUMENT_ONLY_EVENT
 77149: #undef TOUCH_EVENT
 77149: #undef EVENT
 80229: 
 80229: void
 80229: nsDocument::UpdateVisibilityState()
 80229: {
 80229:   VisibilityState oldState = mVisibilityState;
 80229:   mVisibilityState = GetVisibilityState();
 80229:   if (oldState != mVisibilityState) {
 80229:     nsContentUtils::DispatchTrustedEvent(this, static_cast<nsIDocument*>(this),
 80229:                                          NS_LITERAL_STRING("mozvisibilitychange"),
 80229:                                          false, false);
 80229:   }
 80229: }
 80229: 
 80229: nsDocument::VisibilityState
 80229: nsDocument::GetVisibilityState() const
 80229: {
 80229:   // We have to check a few pieces of information here:
 80229:   // 1)  Are we in bfcache (!IsVisible())?  If so, nothing else matters.
 80229:   // 2)  Do we have an outer window?  If not, we're hidden.  Note that we don't
 80229:   //     want to use GetWindow here because it does weird groveling for windows
 80229:   //     in some cases.
 80229:   // 3)  Is our outer window background?  If so, we're hidden.
 80229:   // Otherwise, we're visible.
 80229:   if (!IsVisible() || !mWindow || !mWindow->GetOuterWindow() ||
 80229:       mWindow->GetOuterWindow()->IsBackground()) {
 80229:     return eHidden;
 80229:   }
 80229: 
 80229:   return eVisible;
 80229: }
 80229: 
 80229: /* virtual */ void
 80229: nsDocument::PostVisibilityUpdateEvent()
 80229: {
 80229:   nsCOMPtr<nsIRunnable> event =
 80229:     NS_NewRunnableMethod(this, &nsDocument::UpdateVisibilityState);
 80229:   NS_DispatchToMainThread(event);
 80229: }
 80229: 
 80229: NS_IMETHODIMP
 80229: nsDocument::GetMozHidden(bool* aHidden)
 80229: {
 80229:   *aHidden = mVisibilityState != eVisible;
 80229:   return NS_OK;
 80229: }
 80229: 
 80229: NS_IMETHODIMP
 80229: nsDocument::GetMozVisibilityState(nsAString& aState)
 80229: {
 80229:   // This needs to stay in sync with the VisibilityState enum.
 80229:   static const char states[][8] = {
 80229:     "hidden",
 80229:     "visible"
 80229:   };
 80229:   PR_STATIC_ASSERT(NS_ARRAY_LENGTH(states) == eVisibilityStateCount);
 80229:   aState.AssignASCII(states[mVisibilityState]);
 80229:   return NS_OK;
 80229: }
 89203: 
 91403: /* virtual */ void
 91403: nsIDocument::DocSizeOfExcludingThis(nsWindowSizes* aWindowSizes) const
 91403: {
101275:   aWindowSizes->mDOMOther +=
 91403:     nsINode::SizeOfExcludingThis(aWindowSizes->mMallocSizeOf);
 91403: 
 91413:   if (mPresShell) {
 91413:     mPresShell->SizeOfIncludingThis(aWindowSizes->mMallocSizeOf,
101693:                                     &aWindowSizes->mArenaStats,
101693:                                     &aWindowSizes->mLayoutPresShell,
 91413:                                     &aWindowSizes->mLayoutStyleSets,
 98124:                                     &aWindowSizes->mLayoutTextRuns,
 98124:                                     &aWindowSizes->mLayoutPresContext);
 91413:   }
 91413: 
102117:   aWindowSizes->mPropertyTables +=
102117:     mPropertyTable.SizeOfExcludingThis(aWindowSizes->mMallocSizeOf);
102117:   for (PRUint32 i = 0, count = mExtraPropertyTables.Length();
102117:        i < count; ++i) {
102117:     aWindowSizes->mPropertyTables +=
102117:       mExtraPropertyTables[i]->SizeOfExcludingThis(aWindowSizes->mMallocSizeOf);
102117:   }
102117: 
 91403:   // Measurement of the following members may be added later if DMD finds it
 91403:   // is worthwhile:
 91403:   // - many!
 91403: }
 91403: 
 91403: void
 91403: nsIDocument::DocSizeOfIncludingThis(nsWindowSizes* aWindowSizes) const
 91403: {
101275:   aWindowSizes->mDOMOther += aWindowSizes->mMallocSizeOf(this);
 91403:   DocSizeOfExcludingThis(aWindowSizes);
 91403: }
 91403: 
 89203: static size_t
 89203: SizeOfStyleSheetsElementIncludingThis(nsIStyleSheet* aStyleSheet,
 89203:                                       nsMallocSizeOfFun aMallocSizeOf,
 89203:                                       void* aData)
 89203: {
 89203:   return aStyleSheet->SizeOfIncludingThis(aMallocSizeOf);
 89203: }
 89203: 
 91403: size_t
 91403: nsDocument::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 91403: {
 91403:   // This SizeOfExcludingThis() overrides the one from nsINode.  But
 91403:   // nsDocuments can only appear at the top of the DOM tree, and we use the
 91403:   // specialized DocSizeOfExcludingThis() in that case.  So this should never
 91403:   // be called.
 91403:   MOZ_NOT_REACHED("nsDocument::SizeOfExcludingThis");
 91403:   return 0;
 91403: }
 91403: 
 91403: void
 91403: nsDocument::DocSizeOfExcludingThis(nsWindowSizes* aWindowSizes) const
 91403: {
 91403:   nsIDocument::DocSizeOfExcludingThis(aWindowSizes);
 91403: 
 91403:   for (nsIContent* node = nsINode::GetFirstChild();
 91403:        node;
 91403:        node = node->GetNextNode(this))
 91403:   {
101275:     size_t nodeSize = node->SizeOfIncludingThis(aWindowSizes->mMallocSizeOf);
101275:     size_t* p;
101275: 
101275:     switch (node->NodeType()) {
101275:     case nsIDOMNode::ELEMENT_NODE:
101275:       p = &aWindowSizes->mDOMElementNodes;
101275:       break;
101275:     case nsIDOMNode::TEXT_NODE:
101275:       p = &aWindowSizes->mDOMTextNodes;
101275:       break;
101275:     case nsIDOMNode::CDATA_SECTION_NODE:
101275:       p = &aWindowSizes->mDOMCDATANodes;
101275:       break;
101275:     case nsIDOMNode::COMMENT_NODE:
101275:       p = &aWindowSizes->mDOMCommentNodes;
101275:       break;
101275:     default:
101275:       p = &aWindowSizes->mDOMOther;
101275:       break;
101275:     }
101275: 
101275:     *p += nodeSize;
 91403:   }
 91403: 
 91403:   aWindowSizes->mStyleSheets +=
 91403:     mStyleSheets.SizeOfExcludingThis(SizeOfStyleSheetsElementIncludingThis,
 91403:                                      aWindowSizes->mMallocSizeOf); 
101275:   aWindowSizes->mDOMOther +=
 91403:     mAttrStyleSheet ?
 91403:     mAttrStyleSheet->DOMSizeOfIncludingThis(aWindowSizes->mMallocSizeOf) :
 91403:     0;
 91403: 
101616:   aWindowSizes->mDOMOther +=
101616:     mStyledLinks.SizeOfExcludingThis(NULL, aWindowSizes->mMallocSizeOf);
101616: 
101616:   aWindowSizes->mDOMOther +=
101616:     mIdentifierMap.SizeOfExcludingThis(NULL, aWindowSizes->mMallocSizeOf);
101616: 
 91403:   // Measurement of the following members may be added later if DMD finds it
 91403:   // is worthwhile:
 91403:   // - many!
 91403: }
 94465: 
 94465: bool
 94465: MarkDocumentTreeToBeInSyncOperation(nsIDocument* aDoc, void* aData)
 94465: {
 94465:   nsCOMArray<nsIDocument>* documents =
 94465:     static_cast<nsCOMArray<nsIDocument>*>(aData);
 94465:   if (aDoc) {
 94465:     aDoc->SetIsInSyncOperation(true);
 94465:     documents->AppendObject(aDoc);
 94465:     aDoc->EnumerateSubDocuments(MarkDocumentTreeToBeInSyncOperation, aData);
 94465:   }
 94465:   return true;
 94465: }
 94465: 
 94465: nsAutoSyncOperation::nsAutoSyncOperation(nsIDocument* aDoc)
 94465: {
 94465:   mMicroTaskLevel = nsContentUtils::MicroTaskLevel();
 94465:   nsContentUtils::SetMicroTaskLevel(0);
 94465:   if (aDoc) {
 94465:     nsPIDOMWindow* win = aDoc->GetWindow();
 94465:     if (win) {
 94465:       nsCOMPtr<nsIDOMWindow> topWindow;
 94465:       win->GetTop(getter_AddRefs(topWindow));
 94465:       nsCOMPtr<nsPIDOMWindow> top = do_QueryInterface(topWindow);
 94465:       if (top) {                               
 94465:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(top->GetExtantDocument());
 94465:         MarkDocumentTreeToBeInSyncOperation(doc, &mDocuments);
 94465:       }
 94465:     }
 94465:   }
 94465: }
 94465: 
 94465: nsAutoSyncOperation::~nsAutoSyncOperation()
 94465: {
 94465:   for (PRInt32 i = 0; i < mDocuments.Count(); ++i) {
 94465:     mDocuments[i]->SetIsInSyncOperation(false);
 94465:   }
 94465:   nsContentUtils::SetMicroTaskLevel(mMicroTaskLevel);
 94465: }
