 52558: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 52558:  * vim: set ts=4 sw=4 et tw=99:
 52558:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 52558: #if !defined jsjaeger_compiler_h__ && defined JS_METHODJIT
 52558: #define jsjaeger_compiler_h__
 52558: 
 56602: #include "jsanalyze.h"
 52558: #include "jscntxt.h"
 52558: #include "MethodJIT.h"
 52606: #include "CodeGenIncludes.h"
 55463: #include "BaseCompiler.h"
 52608: #include "StubCompiler.h"
 52831: #include "MonoIC.h"
 52880: #include "PolyIC.h"
 52558: 
 52558: namespace js {
 52558: namespace mjit {
 52558: 
 77343: /*
 77343:  * Patch for storing call site and rejoin site return addresses at, for
 77343:  * redirecting the return address in InvariantFailure.
 77343:  */
 77343: struct InvariantCodePatch {
 77343:     bool hasPatch;
 77343:     JSC::MacroAssembler::DataLabelPtr codePatch;
 77343:     InvariantCodePatch() : hasPatch(false) {}
 77343: };
 77343: 
 86348: struct JSActiveFrame {
 86348:     JSActiveFrame *parent;
 86348:     jsbytecode *parentPC;
 86348:     JSScript *script;
 86348: 
 86348:     /*
 86348:      * Index into inlineFrames or OUTER_FRAME, matches this frame's index in
 86348:      * the cross script SSA.
 86348:      */
 86348:     uint32_t inlineIndex;
 86348: 
 86348:     /* JIT code generation tracking state */
 86348:     size_t mainCodeStart;
 86348:     size_t stubCodeStart;
 86348:     size_t mainCodeEnd;
 86348:     size_t stubCodeEnd;
 86348:     size_t inlinePCOffset;
 86348: 
 86348:     JSActiveFrame();
 86348: };
 86348: 
 55463: class Compiler : public BaseCompiler
 52558: {
 57766:     friend class StubCompiler;
 57766: 
 52599:     struct BranchPatch {
 84755:         BranchPatch(const Jump &j, jsbytecode *pc, uint32_t inlineIndex)
 77343:           : jump(j), pc(pc), inlineIndex(inlineIndex)
 52599:         { }
 52599: 
 52599:         Jump jump;
 52599:         jsbytecode *pc;
 84755:         uint32_t inlineIndex;
 52599:     };
 52599: 
 53119: #if defined JS_MONOIC
 62386:     struct GlobalNameICInfo {
 62385:         Label fastPathStart;
 62386:         Call slowPathCall;
 83221:         DataLabelPtr shape;
 62386:         DataLabelPtr addrLabel;
 62386: 
 62386:         void copyTo(ic::GlobalNameIC &to, JSC::LinkBuffer &full, JSC::LinkBuffer &stub) {
 62386:             to.fastPathStart = full.locationOf(fastPathStart);
 62386: 
 62386:             int offset = full.locationOf(shape) - to.fastPathStart;
 62386:             to.shapeOffset = offset;
 62386:             JS_ASSERT(to.shapeOffset == offset);
 62386: 
 62386:             to.slowPathCall = stub.locationOf(slowPathCall);
 62386:         }
 62386:     };
 62386: 
 62386:     struct GetGlobalNameICInfo : public GlobalNameICInfo {
 62386:         Label load;
 62386:     };
 62386: 
 62386:     struct SetGlobalNameICInfo : public GlobalNameICInfo {
 62385:         Label slowPathStart;
 62385:         Label fastPathRejoin;
 60637:         DataLabel32 store;
 62385:         Jump shapeGuardJump;
 62385:         ValueRemat vr;
 62385:         RegisterID objReg;
 62385:         RegisterID shapeReg;
 62385:         bool objConst;
 52826:     };
 53590: 
 56192:     struct EqualityGenInfo {
 56192:         DataLabelPtr addrLabel;
 56192:         Label stubEntry;
 56192:         Call stubCall;
 56192:         BoolStub stub;
 56192:         MaybeJump jumpToStub;
 56192:         Label fallThrough;
 56192:         jsbytecode *jumpTarget;
 77343:         bool trampoline;
 77343:         Label trampolineStart;
 56192:         ValueRemat lvr, rvr;
 56192:         Assembler::Condition cond;
 56192:         JSC::MacroAssembler::RegisterID tempReg;
 56192:     };
 56192: 
 53590:     /* InlineFrameAssembler wants to see this. */
 68952:   public:
 68952:     struct CallGenInfo {
 68952:         /*
 68952:          * These members map to members in CallICInfo. See that structure for
 68952:          * more comments.
 68952:          */
 84755:         uint32_t     callIndex;
 68952:         DataLabelPtr funGuard;
 68952:         Jump         funJump;
 68952:         Jump         hotJump;
 68952:         Call         oolCall;
 68952:         Label        joinPoint;
 68952:         Label        slowJoinPoint;
 68952:         Label        slowPathStart;
 68952:         Label        hotPathLabel;
 68952:         DataLabelPtr addrLabel1;
 68952:         DataLabelPtr addrLabel2;
 68952:         Jump         oolJump;
 68952:         Label        icCall;
 68952:         RegisterID   funObjReg;
 68952:         FrameSize    frameSize;
 77343:         bool         typeMonitored;
 68952:     };
 68952: 
 53590:   private:
 53119: #endif
 52826: 
 68952:     /*
 68952:      * Writes of call return addresses which needs to be delayed until the final
 68952:      * absolute address of the join point is known.
 68952:      */
 68952:     struct CallPatchInfo {
 77343:         CallPatchInfo() : hasFastNcode(false), hasSlowNcode(false), joinSlow(false) {}
 68952:         Label joinPoint;
 68952:         DataLabelPtr fastNcodePatch;
 68952:         DataLabelPtr slowNcodePatch;
 68952:         bool hasFastNcode;
 68952:         bool hasSlowNcode;
 77343:         bool joinSlow;
 68952:     };
 68952: 
 56575:     struct BaseICInfo {
 78456:         BaseICInfo(JSOp op) : op(op), canCallHook(false), forcedTypeBarrier(false)
 56738:         { }
 56575:         Label fastPathStart;
 56575:         Label fastPathRejoin;
 56575:         Label slowPathStart;
 56575:         Call slowPathCall;
 56575:         DataLabelPtr paramAddr;
 56738:         JSOp op;
 78454:         bool canCallHook;
 78456:         bool forcedTypeBarrier;
 56738: 
 56738:         void copyTo(ic::BaseIC &to, JSC::LinkBuffer &full, JSC::LinkBuffer &stub) {
 56738:             to.fastPathStart = full.locationOf(fastPathStart);
 56738:             to.fastPathRejoin = full.locationOf(fastPathRejoin);
 56738:             to.slowPathStart = stub.locationOf(slowPathStart);
 56738:             to.slowPathCall = stub.locationOf(slowPathCall);
 78454:             to.canCallHook = canCallHook;
 78456:             to.forcedTypeBarrier = forcedTypeBarrier;
 56738:             to.op = op;
 56738:             JS_ASSERT(to.op == op);
 56738:         }
 56738:     };
 56738: 
 56738:     struct GetElementICInfo : public BaseICInfo {
 56738:         GetElementICInfo(JSOp op) : BaseICInfo(op)
 56738:         { }
 56738:         RegisterID  typeReg;
 56738:         RegisterID  objReg;
 56738:         ValueRemat  id;
 56738:         MaybeJump   typeGuard;
 83222:         Jump        shapeGuard;
 56575:     };
 56575: 
 57671:     struct SetElementICInfo : public BaseICInfo {
 57671:         SetElementICInfo(JSOp op) : BaseICInfo(op)
 57671:         { }
 57671:         RegisterID  objReg;
 57671:         StateRemat  objRemat;
 57671:         ValueRemat  vr;
 57671:         Jump        capacityGuard;
 83222:         Jump        shapeGuard;
 57671:         Jump        holeGuard;
 57671:         Int32Key    key;
 84755:         uint32_t    volatileMask;
 57671:     };
 57671: 
 56575:     struct PICGenInfo : public BaseICInfo {
 86855:         PICGenInfo(ic::PICInfo::Kind kind, JSOp op)
 86855:           : BaseICInfo(op), kind(kind), typeMonitored(false)
 52880:         { }
 52880:         ic::PICInfo::Kind kind;
 52884:         Label typeCheck;
 52880:         RegisterID shapeReg;
 52880:         RegisterID objReg;
 52884:         RegisterID typeReg;
 52880:         Label shapeGuard;
 56551:         jsbytecode *pc;
 86542:         PropertyName *name;
 52884:         bool hasTypeCheck;
 77343:         bool typeMonitored;
 98147:         bool cached;
 77353:         types::TypeSet *rhsTypes;
 52887:         ValueRemat vr;
 60590:         union {
 60590:             ic::GetPropLabels getPropLabels_;
 60590:             ic::SetPropLabels setPropLabels_;
 60590:             ic::BindNameLabels bindNameLabels_;
 60594:             ic::ScopeNameLabels scopeNameLabels_;
 60590:         };
 60590: 
 60590:         ic::GetPropLabels &getPropLabels() {
 86855:             JS_ASSERT(kind == ic::PICInfo::GET);
 60590:             return getPropLabels_;
 60590:         }
 60590:         ic::SetPropLabels &setPropLabels() {
 94227:             JS_ASSERT(kind == ic::PICInfo::SET);
 60590:             return setPropLabels_;
 60590:         }
 60590:         ic::BindNameLabels &bindNameLabels() {
 60590:             JS_ASSERT(kind == ic::PICInfo::BIND);
 60590:             return bindNameLabels_;
 60590:         }
 60594:         ic::ScopeNameLabels &scopeNameLabels() {
 86855:             JS_ASSERT(kind == ic::PICInfo::NAME ||
 71340:                       kind == ic::PICInfo::XNAME);
 60594:             return scopeNameLabels_;
 60594:         }
 53137: 
 60590:         void copySimpleMembersTo(ic::PICInfo &ic) {
 56575:             ic.kind = kind;
 56575:             ic.shapeReg = shapeReg;
 56575:             ic.objReg = objReg;
 86542:             ic.name = name;
 56575:             if (ic.isSet()) {
 56575:                 ic.u.vr = vr;
 56575:             } else if (ic.isGet()) {
 56575:                 ic.u.get.typeReg = typeReg;
 56575:                 ic.u.get.hasTypeCheck = hasTypeCheck;
 53137:             }
 77343:             ic.typeMonitored = typeMonitored;
 98147:             ic.cached = cached;
 77343:             ic.rhsTypes = rhsTypes;
 60590:             if (ic.isGet())
 60590:                 ic.setLabels(getPropLabels());
 60590:             else if (ic.isSet())
 60590:                 ic.setLabels(setPropLabels());
 60593:             else if (ic.isBind())
 60590:                 ic.setLabels(bindNameLabels());
 60594:             else if (ic.isScopeName())
 60594:                 ic.setLabels(scopeNameLabels());
 53137:         }
 53137: 
 52880:     };
 52880: 
 52611:     struct Defs {
 84755:         Defs(uint32_t ndefs)
 52611:           : ndefs(ndefs)
 52611:         { }
 84755:         uint32_t ndefs;
 52611:     };
 52611: 
 53168:     struct InternalCallSite {
 84755:         uint32_t returnOffset;
 77343:         DataLabelPtr inlinePatch;
 84755:         uint32_t inlineIndex;
 77343:         jsbytecode *inlinepc;
 77343:         RejoinState rejoin;
 57766:         bool ool;
 77343:         Label loopJumpLabel;
 77343:         InvariantCodePatch loopPatch;
 57766: 
 84755:         InternalCallSite(uint32_t returnOffset,
 84755:                          uint32_t inlineIndex, jsbytecode *inlinepc,
 77343:                          RejoinState rejoin, bool ool)
 77343:           : returnOffset(returnOffset),
 77343:             inlineIndex(inlineIndex), inlinepc(inlinepc),
 77343:             rejoin(rejoin), ool(ool)
 57766:         { }
 53168:     };
 53168: 
 53183:     struct DoublePatch {
 53183:         double d;
 53183:         DataLabelPtr label;
 53183:         bool ool;
 53183:     };
 53183: 
 59979:     struct JumpTable {
 59979:         DataLabelPtr label;
 59979:         size_t offsetIndex;
 59979:     };
 59979: 
 87654:     struct JumpTableEdge {
 87654:         uint32_t source;
 87654:         uint32_t target;
 87654:     };
 87654: 
 87654:     struct ChunkJumpTableEdge {
 87654:         JumpTableEdge edge;
 87654:         void **jumpTableEntry;
 87654:     };
 87654: 
 77343:     struct LoopEntry {
 84755:         uint32_t pcOffset;
 77343:         Label label;
 77343:     };
 77343: 
 87654:     /*
 87654:      * Information about the current type of an argument or local in the
 87654:      * script. The known type tag of these types is cached when possible to
 87654:      * avoid generating duplicate dependency constraints.
 87654:      */
 87654:     class VarType {
 77343:         JSValueType type;
 77343:         types::TypeSet *types;
 87654: 
 87654:       public:
 87654:         void setTypes(types::TypeSet *types) {
 87654:             this->types = types;
 87654:             this->type = JSVAL_TYPE_MISSING;
 87654:         }
 87654: 
 87654:         types::TypeSet *getTypes() { return types; }
 87654: 
 87654:         JSValueType getTypeTag(JSContext *cx) {
 87654:             if (type == JSVAL_TYPE_MISSING)
 87654:                 type = types ? types->getKnownTypeTag(cx) : JSVAL_TYPE_UNKNOWN;
 87654:             return type;
 87654:         }
 87654:     };
 87654: 
 87654:     struct OutgoingChunkEdge {
 87654:         uint32_t source;
 87654:         uint32_t target;
 87654: 
 90435: #ifdef JS_CPU_X64
 90435:         Label sourceTrampoline;
 90435: #endif
 90435: 
 87654:         Jump fastJump;
 87654:         MaybeJump slowJump;
 77343:     };
 77343: 
 77343:     struct SlotType
 77343:     {
 84755:         uint32_t slot;
 77343:         VarType vt;
 84755:         SlotType(uint32_t slot, VarType vt) : slot(slot), vt(vt) {}
 77343:     };
 77343: 
 77343:     JSScript *outerScript;
 87654:     unsigned chunkIndex;
 55503:     bool isConstructing;
 91569:     ChunkDescriptor outerChunk;
 77343: 
 77343:     /* SSA information for the outer script and all frames we will be inlining. */
 77343:     analyze::CrossScriptSSA ssa;
 77343: 
 99421:     Rooted<GlobalObject*> globalObj;
 91146:     const HeapSlot *globalSlots;  /* Original slots pointer. */
 77343: 
 52608:     Assembler masm;
 52560:     FrameState frame;
 77343: 
 77343:     /*
 77343:      * State for the current stack frame, and links to its parents going up to
 77343:      * the outermost script.
 77343:      */
 77343: 
 80222: public:
 86348:     struct ActiveFrame : public JSActiveFrame {
 77343:         Label *jumpMap;
 77343: 
 77343:         /* Current types for non-escaping vars in the script. */
 77343:         VarType *varTypes;
 77343: 
 77343:         /* State for managing return from inlined frames. */
 77343:         bool needReturnValue;          /* Return value will be used. */
 77343:         bool syncReturnValue;          /* Return value should be fully synced. */
 77343:         bool returnValueDouble;        /* Return value should be a double. */
 77343:         bool returnSet;                /* Whether returnRegister is valid. */
 77343:         AnyRegisterID returnRegister;  /* Register holding return value. */
 77343:         const FrameEntry *returnEntry; /* Entry copied by return value. */
 77343:         Vector<Jump, 4, CompilerAllocPolicy> *returnJumps;
 77343: 
 77343:         /*
 77343:          * Snapshot of the heap state to use after the call, in case
 77343:          * there are multiple return paths the inlined frame could take.
 77343:          */
 77343:         RegisterAllocation *exitState;
 77343: 
 77343:         ActiveFrame(JSContext *cx);
 77343:         ~ActiveFrame();
 77343:     };
 80222: 
 80222: private:
 77343:     ActiveFrame *a;
 77343:     ActiveFrame *outer;
 77343: 
 77343:     JSScript *script;
 77343:     analyze::ScriptAnalysis *analysis;
 77343:     jsbytecode *PC;
 77343: 
 77343:     LoopState *loop;
 77343: 
 77343:     /* State spanning all stack frames. */
 77343: 
 77343:     js::Vector<ActiveFrame*, 4, CompilerAllocPolicy> inlineFrames;
 57679:     js::Vector<BranchPatch, 64, CompilerAllocPolicy> branchPatches;
 53119: #if defined JS_MONOIC
 62386:     js::Vector<GetGlobalNameICInfo, 16, CompilerAllocPolicy> getGlobalNames;
 62386:     js::Vector<SetGlobalNameICInfo, 16, CompilerAllocPolicy> setGlobalNames;
 68952:     js::Vector<CallGenInfo, 64, CompilerAllocPolicy> callICs;
 57679:     js::Vector<EqualityGenInfo, 64, CompilerAllocPolicy> equalityICs;
 53119: #endif
 53119: #if defined JS_POLYIC
 57679:     js::Vector<PICGenInfo, 16, CompilerAllocPolicy> pics;
 57679:     js::Vector<GetElementICInfo, 16, CompilerAllocPolicy> getElemICs;
 57679:     js::Vector<SetElementICInfo, 16, CompilerAllocPolicy> setElemICs;
 53119: #endif
 68952:     js::Vector<CallPatchInfo, 64, CompilerAllocPolicy> callPatches;
 57679:     js::Vector<InternalCallSite, 64, CompilerAllocPolicy> callSites;
 57679:     js::Vector<DoublePatch, 16, CompilerAllocPolicy> doubleList;
 98147:     js::Vector<JSObject*, 0, CompilerAllocPolicy> rootedTemplates;
 98147:     js::Vector<RegExpShared*, 0, CompilerAllocPolicy> rootedRegExps;
 84755:     js::Vector<uint32_t> fixedIntToDoubleEntries;
 84755:     js::Vector<uint32_t> fixedDoubleToAnyEntries;
 59979:     js::Vector<JumpTable, 16> jumpTables;
 87654:     js::Vector<JumpTableEdge, 16> jumpTableEdges;
 77343:     js::Vector<LoopEntry, 16> loopEntries;
 87654:     js::Vector<OutgoingChunkEdge, 16> chunkEdges;
 52608:     StubCompiler stubcc;
 98891:     Label fastEntryLabel;
 53590:     Label arityLabel;
 77343:     Label argsCheckLabel;
 77343: #ifdef JS_MONOIC
 77343:     Label argsCheckStub;
 77343:     Label argsCheckFallthrough;
 77343:     Jump argsCheckJump;
 77343: #endif
 57766:     bool debugMode_;
 77343:     bool inlining_;
 77343:     bool hasGlobalReallocation;
 57679:     bool oomInVector;       // True if we have OOM'd appending to a vector.
 78457:     bool overflowICSpace;   // True if we added a constant pool in a reserved space.
 90410:     uint64_t gcNumber;
 77407:     PCLengthEntry *pcLengths;
 52599: 
 56774:     Compiler *thisFromCtor() { return this; }
 57679: 
 57679:     friend class CompilerAllocPolicy;
 52558:   public:
 87654:     Compiler(JSContext *cx, JSScript *outerScript, unsigned chunkIndex, bool isConstructing);
 52558:     ~Compiler();
 52558: 
 55503:     CompileStatus compile();
 52558: 
 52611:     Label getLabel() { return masm.label(); }
 52653:     bool knownJump(jsbytecode *pc);
 84755:     Label labelOf(jsbytecode *target, uint32_t inlineIndex);
 57766:     void addCallSite(const InternalCallSite &callSite);
 77343:     void addReturnSite();
 78454:     void inlineStubCall(void *stub, RejoinState rejoin, Uses uses);
 57766: 
 57766:     bool debugMode() { return debugMode_; }
 77343:     bool inlining() { return inlining_; }
 77432:     bool constructing() { return isConstructing; }
 77343: 
 77343:     jsbytecode *outerPC() {
 77343:         if (a == outer)
 77343:             return PC;
 77343:         ActiveFrame *scan = a;
 77343:         while (scan && scan->parent != outer)
 86348:             scan = static_cast<ActiveFrame *>(scan->parent);
 77343:         return scan->parentPC;
 77343:     }
 77343: 
 87654:     JITScript *outerJIT() {
 98147:         return outerScript->getJIT(isConstructing, cx->compartment->needsBarrier());
 87654:     }
 87654: 
 91569:     ChunkDescriptor &outerChunkRef() {
 91569:         return outerJIT()->chunkDescriptor(chunkIndex);
 91569:     }
 91569: 
 87654:     bool bytecodeInChunk(jsbytecode *pc) {
 87654:         return (unsigned(pc - outerScript->code) >= outerChunk.begin)
 87654:             && (unsigned(pc - outerScript->code) < outerChunk.end);
 87654:     }
 87654: 
 77343:     jsbytecode *inlinePC() { return PC; }
 84755:     uint32_t inlineIndex() { return a->inlineIndex; }
 77343: 
 77343:     Assembler &getAssembler(bool ool) { return ool ? stubcc.masm : masm; }
 77343: 
 77343:     InvariantCodePatch *getInvariantPatch(unsigned index) {
 77343:         return &callSites[index].loopPatch;
 77343:     }
 77343:     jsbytecode *getInvariantPC(unsigned index) {
 77343:         return callSites[index].inlinepc;
 77343:     }
 77343: 
 77343:     bool activeFrameHasMultipleExits() {
 77343:         ActiveFrame *na = a;
 77343:         while (na->parent) {
 77343:             if (na->exitState)
 77343:                 return true;
 86348:             na = static_cast<ActiveFrame *>(na->parent);
 77343:         }
 77343:         return false;
 77343:     }
 52608: 
 52558:   private:
 87654:     CompileStatus performCompilation();
 52558:     CompileStatus generatePrologue();
 52558:     CompileStatus generateMethod();
 52558:     CompileStatus generateEpilogue();
 87654:     CompileStatus finishThisUp();
 84755:     CompileStatus pushActiveFrame(JSScript *script, uint32_t argc);
 77343:     void popActiveFrame();
 94574:     void updatePCCounts(jsbytecode *pc, Label *start, bool *updated);
 82134:     void updatePCTypes(jsbytecode *pc, FrameEntry *fe);
 94574:     void updateArithCounts(jsbytecode *pc, FrameEntry *fe,
 82134:                              JSValueType firstUseType, JSValueType secondUseType);
 94574:     void updateElemCounts(jsbytecode *pc, FrameEntry *obj, FrameEntry *id);
 94574:     void bumpPropCount(jsbytecode *pc, int count);
 77343: 
 77343:     /* Analysis helpers. */
 77343:     CompileStatus prepareInferenceTypes(JSScript *script, ActiveFrame *a);
 77343:     void ensureDoubleArguments();
 91759:     void markUndefinedLocal(uint32_t offset, uint32_t i);
 81077:     void markUndefinedLocals();
 77343:     void fixDoubleTypes(jsbytecode *target);
 77343:     void watchGlobalReallocation();
 77343:     void updateVarType();
 77343:     void updateJoinVarTypes();
 77343:     void restoreVarType();
 84755:     JSValueType knownPushedType(uint32_t pushed);
 84755:     bool mayPushUndefined(uint32_t pushed);
 84755:     types::TypeSet *pushedTypeSet(uint32_t which);
 77343:     bool monitored(jsbytecode *pc);
 77343:     bool hasTypeBarriers(jsbytecode *pc);
 98960:     bool testSingletonProperty(HandleObject obj, HandleId id);
 98960:     bool testSingletonPropertyTypes(FrameEntry *top, HandleId id, bool *testObject);
 84755:     CompileStatus addInlineFrame(JSScript *script, uint32_t depth, uint32_t parent, jsbytecode *parentpc);
 84755:     CompileStatus scanInlineCalls(uint32_t index, uint32_t depth);
 77343:     CompileStatus checkAnalysis(JSScript *script);
 77343: 
 77343:     struct BarrierState {
 77343:         MaybeJump jump;
 77343:         RegisterID typeReg;
 77343:         RegisterID dataReg;
 77343:     };
 77343: 
 80962:     MaybeJump trySingleTypeTest(types::TypeSet *types, RegisterID typeReg);
 77343:     Jump addTypeTest(types::TypeSet *types, RegisterID typeReg, RegisterID dataReg);
 77343:     BarrierState pushAddressMaybeBarrier(Address address, JSValueType type, bool reuseBase,
 77343:                                          bool testUndefined = false);
 77343:     BarrierState testBarrier(RegisterID typeReg, RegisterID dataReg,
 78454:                              bool testUndefined = false, bool testReturn = false,
 78454:                              bool force = false);
 84755:     void finishBarrier(const BarrierState &barrier, RejoinState rejoin, uint32_t which);
 52560: 
 78456:     void testPushedType(RejoinState rejoin, int which, bool ool = true);
 78456: 
 52560:     /* Non-emitting helpers. */
 84755:     void pushSyncedEntry(uint32_t pushed);
 56766:     bool jumpInScript(Jump j, jsbytecode *pc);
 52651:     bool compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs);
 52560: 
 52645:     /* Emitting helpers. */
 77343:     bool constantFoldBranch(jsbytecode *target, bool taken);
 56766:     bool emitStubCmpOp(BoolStub stub, jsbytecode *target, JSOp fused);
 91237:     bool iter(unsigned flags);
 77824:     void iterNext(ptrdiff_t offset);
 77343:     bool iterMore(jsbytecode *target);
 53404:     void iterEnd();
 77343:     MaybeJump loadDouble(FrameEntry *fe, FPRegisterID *fpReg, bool *allocated);
 55503: #ifdef JS_POLYIC
 56738:     void passICAddress(BaseICInfo *ic);
 55503: #endif
 55503: #ifdef JS_MONOIC
 62386:     void passMICAddress(GlobalNameICInfo &mic);
 55503: #endif
 56037:     bool constructThis();
 77343:     void ensureDouble(FrameEntry *fe);
 77343: 
 77343:     /*
 77343:      * Ensure fe is an integer, truncating from double if necessary, or jump to
 77343:      * the slow path per uses.
 77343:      */
 77343:     void ensureInteger(FrameEntry *fe, Uses uses);
 77343: 
 77343:     /* Convert fe from a double to integer (per ValueToECMAInt32) in place. */
 77343:     void truncateDoubleToInt32(FrameEntry *fe, Uses uses);
 52645: 
 81336:     /*
 81336:      * Try to convert a double fe to an integer, with no truncation performed,
 81336:      * or jump to the slow path per uses.
 81336:      */
 81336:     void tryConvertInteger(FrameEntry *fe, Uses uses);
 81336: 
 52560:     /* Opcode handlers. */
 87654:     bool jumpAndRun(Jump j, jsbytecode *target,
 87654:                     Jump *slow = NULL, bool *trampoline = NULL,
 87654:                     bool fallthrough = false);
 77343:     bool startLoop(jsbytecode *head, Jump entry, jsbytecode *entryTarget);
 77343:     bool finishLoop(jsbytecode *head);
 87654:     inline bool shouldStartLoop(jsbytecode *head);
 86855:     void jsop_bindname(PropertyName *name);
 84755:     void jsop_setglobal(uint32_t index);
 86855:     void jsop_getprop_slow(PropertyName *name, bool forPrototype = false);
100006:     void jsop_getarg(uint32_t slot);
100006:     void jsop_setarg(uint32_t slot, bool popped);
 52741:     void jsop_this();
 54832:     void emitReturn(FrameEntry *fe);
 54832:     void emitFinalReturn(Assembler &masm);
 55503:     void loadReturnValue(Assembler *masm, FrameEntry *fe);
 55503:     void emitReturnValue(Assembler *masm, FrameEntry *fe);
 77343:     void emitInlineReturnValue(FrameEntry *fe);
 84755:     void dispatchCall(VoidPtrStubUInt32 stub, uint32_t argc);
 53223:     void interruptCheckHelper();
 77343:     void recompileCheckHelper();
 84755:     void emitUncachedCall(uint32_t argc, bool callingNew);
 95100:     void checkCallApplySpeculation(uint32_t argc, FrameEntry *origCallee, FrameEntry *origThis,
 68952:                                    MaybeRegisterID origCalleeType, RegisterID origCalleeData,
 68952:                                    MaybeRegisterID origThisType, RegisterID origThisData,
 68952:                                    Jump *uncachedCallSlowRejoin, CallPatchInfo *uncachedCallPatch);
 84755:     bool inlineCallHelper(uint32_t argc, bool callingNew, FrameSize &callFrameSize);
 55503:     void fixPrimitiveReturn(Assembler *masm, FrameEntry *fe);
 99781:     bool jsop_getgname(uint32_t index);
 84755:     void jsop_getgname_slow(uint32_t index);
 99781:     bool jsop_setgname(PropertyName *name, bool popGuaranteed);
 86855:     void jsop_setgname_slow(PropertyName *name);
 52826:     void jsop_bindgname();
 52838:     void jsop_setelem_slow();
 52843:     void jsop_getelem_slow();
 86542:     bool jsop_getprop(PropertyName *name, JSValueType type,
 86855:                       bool typeCheck = true, bool forPrototype = false);
 86855:     bool jsop_getprop_dispatch(PropertyName *name);
 86855:     bool jsop_setprop(PropertyName *name, bool popGuaranteed);
 86855:     void jsop_setprop_slow(PropertyName *name);
 56037:     bool jsop_instanceof();
 86855:     void jsop_name(PropertyName *name, JSValueType type);
 86542:     bool jsop_xname(PropertyName *name);
 89253:     void enterBlock(StaticBlockObject *block);
 54840:     void leaveBlock();
 84755:     void emitEval(uint32_t argc);
 61233:     bool jsop_tableswitch(jsbytecode *pc);
 98147:     Jump getNewObject(JSContext *cx, RegisterID result, JSObject *templateObject);
 52611: 
 52963:     /* Fast arithmetic. */
 87590:     bool jsop_binary_slow(JSOp op, VoidStub stub, JSValueType type, FrameEntry *lhs, FrameEntry *rhs);
 77343:     bool jsop_binary(JSOp op, VoidStub stub, JSValueType type, types::TypeSet *typeSet);
 77343:     void jsop_binary_full(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub,
 77343:                           JSValueType type, bool cannotOverflow, bool ignoreOverflow);
 77343:     void jsop_binary_full_simple(FrameEntry *fe, JSOp op, VoidStub stub,
 77343:                                  JSValueType type);
 77343:     void jsop_binary_double(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub,
 77343:                             JSValueType type);
 52963:     void slowLoadConstantDouble(Assembler &masm, FrameEntry *fe,
 52963:                                 FPRegisterID fpreg);
 52963:     void maybeJumpIfNotInt32(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
 52963:                              MaybeRegisterID &mreg);
 52963:     void maybeJumpIfNotDouble(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
 52963:                               MaybeRegisterID &mreg);
 56766:     bool jsop_relational(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
 56766:     bool jsop_relational_full(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
 56766:     bool jsop_relational_double(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
 77343:     bool jsop_relational_int(JSOp op, jsbytecode *target, JSOp fused);
 53201: 
 53201:     void emitLeftDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
 53201:                             MaybeJump &lhsNotDouble, MaybeJump &rhsNotNumber,
 53201:                             MaybeJump &lhsUnknownDone);
 53201:     void emitRightDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
 53201:                              MaybeJump &rhsNotNumber2);
 53318:     bool tryBinaryConstantFold(JSContext *cx, FrameState &frame, JSOp op,
 77343:                                FrameEntry *lhs, FrameEntry *rhs, Value *vp);
 52963: 
 52617:     /* Fast opcodes. */
 52617:     void jsop_bitop(JSOp op);
 77343:     bool jsop_mod();
 52713:     void jsop_neg();
 52724:     void jsop_bitnot();
 52734:     void jsop_not();
 52738:     void jsop_typeof();
 56766:     bool booleanJumpScript(JSOp op, jsbytecode *target);
 56766:     bool jsop_ifneq(JSOp op, jsbytecode *target);
 56766:     bool jsop_andor(JSOp op, jsbytecode *target);
 84755:     bool jsop_arginc(JSOp op, uint32_t slot);
 84755:     bool jsop_localinc(JSOp op, uint32_t slot);
 77343:     bool jsop_newinit();
 80431:     bool jsop_regexp();
 58056:     void jsop_initmethod();
 58056:     void jsop_initprop();
 58056:     void jsop_initelem();
 77343:     void jsop_setelem_dense();
 77345: #ifdef JS_METHODJIT_TYPED_ARRAY
 77344:     void jsop_setelem_typed(int atype);
 77344:     void convertForTypedArray(int atype, ValueRemat *vr, bool *allocated);
 77345: #endif
 60164:     bool jsop_setelem(bool popGuaranteed);
 86855:     bool jsop_getelem();
 77343:     void jsop_getelem_dense(bool isPacked);
 77343:     void jsop_getelem_args();
 77345: #ifdef JS_METHODJIT_TYPED_ARRAY
 77442:     bool jsop_getelem_typed(int atype);
 77345: #endif
 77357:     void jsop_toid();
 56775:     bool isCacheableBaseAndIndex(FrameEntry *obj, FrameEntry *id);
 52855:     void jsop_stricteq(JSOp op);
 56766:     bool jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
 79902:     CompileStatus jsop_equality_obj_obj(JSOp op, jsbytecode *target, JSOp fused);
 56766:     bool jsop_equality_int_string(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
 52916:     void jsop_pos();
 88181:     void jsop_in();
 52617: 
 77343:     static inline Assembler::Condition
 77343:     GetCompareCondition(JSOp op, JSOp fused)
 77343:     {
 77343:         bool ifeq = fused == JSOP_IFEQ;
 77343:         switch (op) {
 77343:           case JSOP_GT:
 77343:             return ifeq ? Assembler::LessThanOrEqual : Assembler::GreaterThan;
 77343:           case JSOP_GE:
 77343:             return ifeq ? Assembler::LessThan : Assembler::GreaterThanOrEqual;
 77343:           case JSOP_LT:
 77343:             return ifeq ? Assembler::GreaterThanOrEqual : Assembler::LessThan;
 77343:           case JSOP_LE:
 77343:             return ifeq ? Assembler::GreaterThan : Assembler::LessThanOrEqual;
 79902:           case JSOP_STRICTEQ:
 77343:           case JSOP_EQ:
 77343:             return ifeq ? Assembler::NotEqual : Assembler::Equal;
 79902:           case JSOP_STRICTNE:
 77343:           case JSOP_NE:
 77343:             return ifeq ? Assembler::Equal : Assembler::NotEqual;
 77343:           default:
 77343:             JS_NOT_REACHED("unrecognized op");
 77343:             return Assembler::Equal;
 77343:         }
 77343:     }
 77343: 
 77343:     static inline Assembler::Condition
 77343:     GetStubCompareCondition(JSOp fused)
 77343:     {
 86877:         return fused == JSOP_IFEQ ? Assembler::Zero : Assembler::NonZero;
 77343:     }
 77343: 
 77343:     /* Fast builtins. */
 77343:     JSObject *pushedSingleton(unsigned pushed);
 84755:     CompileStatus inlineNativeFunction(uint32_t argc, bool callingNew);
 84755:     CompileStatus inlineScriptedFunction(uint32_t argc, bool callingNew);
 77343:     CompileStatus compileMathAbsInt(FrameEntry *arg);
 77343:     CompileStatus compileMathAbsDouble(FrameEntry *arg);
 77343:     CompileStatus compileMathSqrt(FrameEntry *arg);
 78733:     CompileStatus compileMathMinMaxDouble(FrameEntry *arg1, FrameEntry *arg2,
 78733:                                           Assembler::DoubleCondition cond);
 78733:     CompileStatus compileMathMinMaxInt(FrameEntry *arg1, FrameEntry *arg2,
 78733:                                        Assembler::Condition cond);
 77343:     CompileStatus compileMathPowSimple(FrameEntry *arg1, FrameEntry *arg2);
 77343:     CompileStatus compileArrayPush(FrameEntry *thisv, FrameEntry *arg);
 80557:     CompileStatus compileArrayConcat(types::TypeSet *thisTypes, types::TypeSet *argTypes,
 80557:                                      FrameEntry *thisValue, FrameEntry *argValue);
 80556:     CompileStatus compileArrayPopShift(FrameEntry *thisv, bool isPacked, bool isArrayPop);
 84755:     CompileStatus compileArrayWithLength(uint32_t argc);
 84755:     CompileStatus compileArrayWithArgs(uint32_t argc);
 77343: 
 77343:     enum RoundingMode { Floor, Round };
 77343:     CompileStatus compileRound(FrameEntry *arg, RoundingMode mode);
 77343: 
 77343:     enum GetCharMode { GetChar, GetCharCode };
 77343:     CompileStatus compileGetChar(FrameEntry *thisValue, FrameEntry *arg, GetCharMode mode);
 52611: 
 81119:     CompileStatus compileStringFromCode(FrameEntry *arg);
 86581:     CompileStatus compileParseInt(JSValueType argType, uint32_t argc);
 81119: 
 57766:     void prepareStubCall(Uses uses);
 77343:     Call emitStubCall(void *ptr, DataLabelPtr *pinline);
 57766: };
 52611: 
 77343: // Given a stub call, emits the call into the inline assembly path. rejoin
 77343: // indicates how to rejoin should this call trigger expansion/discarding.
 77343: #define INLINE_STUBCALL(stub, rejoin)                                       \
 78454:     inlineStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), rejoin, Uses(0))
 78454: #define INLINE_STUBCALL_USES(stub, rejoin, uses)                            \
 78454:     inlineStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), rejoin, uses)
 57766: 
 77343: // Given a stub call, emits the call into the out-of-line assembly path.
 57766: // Unlike the INLINE_STUBCALL variant, this returns the Call offset.
 77343: #define OOL_STUBCALL(stub, rejoin)                                          \
 78454:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), rejoin, Uses(0))
 78454: #define OOL_STUBCALL_USES(stub, rejoin, uses)                               \
 78454:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), rejoin, uses)
 57766: 
 57766: // Same as OOL_STUBCALL, but specifies a slot depth.
 77343: #define OOL_STUBCALL_LOCAL_SLOTS(stub, rejoin, slots)                       \
 78454:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), rejoin, Uses(0), (slots))
 52558: 
 52558: } /* namespace js */
 52558: } /* namespace mjit */
 52558: 
 52558: #endif
 52611: 
