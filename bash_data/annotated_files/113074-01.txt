112662: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
112662:  * vim: set ts=4 sw=4 et tw=99:
111930:  *
111930:  * ***** BEGIN LICENSE BLOCK *****
111930:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111930:  *
111930:  * The contents of this file are subject to the Mozilla Public License Version
111930:  * 1.1 (the "License"); you may not use this file except in compliance with
111930:  * the License. You may obtain a copy of the License at
111930:  * http://www.mozilla.org/MPL/
111930:  *
111930:  * Software distributed under the License is distributed on an "AS IS" basis,
111930:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111930:  * for the specific language governing rights and limitations under the
111930:  * License.
111930:  *
111930:  * The Original Code is Mozilla Communicator client code, released
111930:  * March 31, 1998.
111930:  *
111930:  * The Initial Developer of the Original Code is
111930:  * Netscape Communications Corporation.
111930:  * Portions created by the Initial Developer are Copyright (C) 1998
111930:  * the Initial Developer. All Rights Reserved.
111930:  *
111930:  * Contributor(s):
111930:  *   David Anderson <dvander@alliedmods.net>
111930:  *
111930:  * Alternatively, the contents of this file may be used under the terms of
111930:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111930:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111930:  * in which case the provisions of the GPL or the LGPL are applicable instead
111930:  * of those above. If you wish to allow use of your version of this file only
111930:  * under the terms of either the GPL or the LGPL, and not to allow others to
111930:  * use your version of this file under the terms of the MPL, indicate your
111930:  * decision by deleting the provisions above and replace them with the notice
111930:  * and other provisions required by the GPL or the LGPL. If you do not delete
111930:  * the provisions above, a recipient may use your version of this file under
111930:  * the terms of any one of the MPL, the GPL or the LGPL.
111930:  *
111930:  * ***** END LICENSE BLOCK ***** */
111930: 
111930: #include "CodeGenerator.h"
111930: #include "IonLinker.h"
112206: #include "IonSpewer.h"
111930: #include "MIRGenerator.h"
111994: #include "shared/CodeGenerator-shared-inl.h"
111995: #include "jsnum.h"
112682: #include "jsinterpinlines.h"
111930: 
111930: using namespace js;
111930: using namespace js::ion;
111930: 
112292: namespace js {
112292: namespace ion {
112292: 
111930: CodeGenerator::CodeGenerator(MIRGenerator *gen, LIRGraph &graph)
111930:   : CodeGeneratorSpecific(gen, graph)
111930: {
111930: }
111930: 
111930: bool
111994: CodeGenerator::visitValueToInt32(LValueToInt32 *lir)
111994: {
111994:     ValueOperand operand = ToValue(lir, LValueToInt32::Input);
111994:     Register output = ToRegister(lir->output());
111994: 
111994:     Label done, simple, isInt32, isBool, notDouble;
111994: 
111994:     // Type-check switch.
112098:     masm.branchTestInt32(Assembler::Equal, operand, &isInt32);
112098:     masm.branchTestBoolean(Assembler::Equal, operand, &isBool);
112098:     masm.branchTestDouble(Assembler::NotEqual, operand, &notDouble);
111994: 
111994:     // If the value is a double, see if it fits in a 32-bit int. We need to ask
111994:     // the platform-specific codegenerator to do this.
111994:     FloatRegister temp = ToFloatRegister(lir->tempFloat());
111994:     masm.unboxDouble(operand, temp);
112035: 
112035:     Label fails;
112044:     switch (lir->mode()) {
112044:       case LValueToInt32::TRUNCATE:
112856:         if (!emitTruncateDouble(temp, output))
112856:             return false;
112044:         break;
112044:       default:
112044:         JS_ASSERT(lir->mode() == LValueToInt32::NORMAL);
112931:         emitDoubleToInt32(temp, output, &fails, lir->mir()->canBeNegativeZero());
112044:         break;
112044:     }
111994:     masm.jump(&done);
111994: 
111994:     masm.bind(&notDouble);
111994: 
112044:     if (lir->mode() == LValueToInt32::NORMAL) {
112044:         // If the value is not null, it's a string, object, or undefined,
112044:         // which we can't handle here.
112098:         masm.branchTestNull(Assembler::NotEqual, operand, &fails);
112044:     } else {
112044:         // Test for string or object - then fallthrough to null, which will
112044:         // also handle undefined.
112098:         masm.branchTestObject(Assembler::Equal, operand, &fails);
112098:         masm.branchTestString(Assembler::Equal, operand, &fails);
112098:     }
112098: 
112098:     if (fails.used() && !bailoutFrom(&fails, lir->snapshot()))
112044:         return false;
111994:     
111994:     // The value is null - just emit 0.
111994:     masm.mov(Imm32(0), output);
111994:     masm.jump(&done);
111994: 
111994:     // Just unbox a bool, the result is 0 or 1.
111994:     masm.bind(&isBool);
111994:     masm.unboxBoolean(operand, output);
111994:     masm.jump(&done);
111994: 
111994:     // Integers can be unboxed.
111994:     masm.bind(&isInt32);
111994:     masm.unboxInt32(operand, output);
111994: 
111994:     masm.bind(&done);
111994: 
111994:     return true;
111994: }
111994: 
111995: static const double DoubleZero = 0.0;
111995: 
111995: bool
111995: CodeGenerator::visitValueToDouble(LValueToDouble *lir)
111995: {
111995:     ValueOperand operand = ToValue(lir, LValueToDouble::Input);
111995:     FloatRegister output = ToFloatRegister(lir->output());
111995: 
111995:     Label isDouble, isInt32, isBool, isNull, done;
111995: 
111995:     // Type-check switch.
112098:     masm.branchTestDouble(Assembler::Equal, operand, &isDouble);
112098:     masm.branchTestInt32(Assembler::Equal, operand, &isInt32);
112098:     masm.branchTestBoolean(Assembler::Equal, operand, &isBool);
112098:     masm.branchTestNull(Assembler::Equal, operand, &isNull);
111995: 
112098:     Assembler::Condition cond = masm.testUndefined(Assembler::NotEqual, operand);
111995:     if (!bailoutIf(cond, lir->snapshot()))
111995:         return false;
111995:     masm.loadStaticDouble(&js_NaN, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isNull);
111995:     masm.loadStaticDouble(&DoubleZero, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isBool);
111995:     masm.boolValueToDouble(operand, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isInt32);
111995:     masm.int32ValueToDouble(operand, output);
111995:     masm.jump(&done);
111995: 
111995:     masm.bind(&isDouble);
111995:     masm.unboxDouble(operand, output);
111995:     masm.bind(&done);
111995: 
111995:     return true;
111995: }
111995: 
111995: bool
111995: CodeGenerator::visitInt32ToDouble(LInt32ToDouble *lir)
111995: {
111995:     masm.convertInt32ToDouble(ToRegister(lir->input()), ToFloatRegister(lir->output()));
111995:     return true;
111995: }
111995: 
111994: bool
112218: CodeGenerator::visitDoubleToInt32(LDoubleToInt32 *lir)
112218: {
112218:     Label fail;
112218:     FloatRegister input = ToFloatRegister(lir->input());
112218:     Register output = ToRegister(lir->output());
112931:     emitDoubleToInt32(input, output, &fail, lir->mir()->canBeNegativeZero());
112218:     if (!bailoutFrom(&fail, lir->snapshot()))
112218:         return false;
112218:     return true;
112218: }
112218: 
112218: bool
112037: CodeGenerator::visitTestVAndBranch(LTestVAndBranch *lir)
112037: {
112037:     const ValueOperand value = ToValue(lir, LTestVAndBranch::Input);
112851:     masm.branchTestValueTruthy(value, lir->ifTrue(), ToFloatRegister(lir->tempFloat()));
112851:     masm.jump(lir->ifFalse());
112037:     return true;
112037: }
112037: 
112851: 
112037: bool
112429: CodeGenerator::visitIntToString(LIntToString *lir)
112429: {
112809:     typedef JSString *(*pf)(JSContext *, int);
112541:     static const VMFunction js_IntToStringInfo = FunctionInfo<pf>(js_IntToString);
112429: 
112429:     pushArg(ToRegister(lir->input()));
112541:     return callVM(js_IntToStringInfo, lir);
112541: }
112541: 
112541: bool
112541: CodeGenerator::visitRegExp(LRegExp *lir)
112541: {
112541:     GlobalObject *global = gen->info().script()->global();
112541:     JSObject *proto = global->getOrCreateRegExpPrototype(gen->cx);
112541: 
112541:     typedef JSObject *(*pf)(JSContext *, JSObject *, JSObject *);
112692:     static const VMFunction CloneRegExpObjectInfo = FunctionInfo<pf>(CloneRegExpObject);
112541: 
112541:     pushArg(ImmGCPtr(proto));
112541:     pushArg(ImmGCPtr(lir->mir()->source()));
112692:     return callVM(CloneRegExpObjectInfo, lir);
112429: }
112429: 
112429: bool
112691: CodeGenerator::visitLambda(LLambda *lir)
112691: {
112984:     typedef JSObject *(*pf)(JSContext *, HandleFunction, HandleObject);
112691:     static const VMFunction Info = FunctionInfo<pf>(js::Lambda);
112691: 
112691:     pushArg(ToRegister(lir->scopeChain()));
112691:     pushArg(ImmGCPtr(lir->mir()->fun()));
112691:     return callVM(Info, lir);
112691: }
112691: 
112691: bool
112360: CodeGenerator::visitLabel(LLabel *lir)
112360: {
112360:     masm.bind(lir->label());
112360:     return true;
112360: }
112360: 
112360: bool
112444: CodeGenerator::visitNop(LNop *lir)
112444: {
112444:     return true;
112444: }
112444: 
112444: bool
112505: CodeGenerator::visitOsiPoint(LOsiPoint *lir)
112223: {
112505:     // Note: markOsiPoint ensures enough space exists between the last
112505:     // LOsiPoint and this one to patch adjacent call instructions.
112505: 
112505:     JS_ASSERT(masm.framePushed() == frameSize());
112505: 
112924:     uint32 osiCallPointOffset;
112924:     if (!markOsiPoint(lir, &osiCallPointOffset))
112505:         return false;
112505: 
112505:     LSafepoint *safepoint = lir->associatedSafepoint();
112924:     JS_ASSERT(!safepoint->osiCallPointOffset());
112924:     safepoint->setOsiCallPointOffset(osiCallPointOffset);
112223:     return true;
112223: }
112223: 
112223: bool
112317: CodeGenerator::visitGoto(LGoto *lir)
112317: {
112317:     LBlock *target = lir->target()->lir();
112317: 
112317:     // No jump necessary if we can fall through to the next block.
112317:     if (isNextBlock(target))
112317:         return true;
112317: 
112317:     masm.jump(target->label());
112317:     return true;
112317: }
112317: 
112317: bool
112108: CodeGenerator::visitParameter(LParameter *lir)
112108: {
112108:     return true;
112108: }
112108: 
112108: bool
112401: CodeGenerator::visitCallee(LCallee *lir)
112401: {
112401:     return true;
112401: }
112401: 
112401: bool
112108: CodeGenerator::visitStart(LStart *lir)
112108: {
112108:     return true;
112108: }
112108: 
112108: bool
112317: CodeGenerator::visitReturn(LReturn *lir)
112317: {
112317: #if defined(JS_NUNBOX32)
112317:     DebugOnly<LAllocation *> type    = lir->getOperand(TYPE_INDEX);
112317:     DebugOnly<LAllocation *> payload = lir->getOperand(PAYLOAD_INDEX);
112317:     JS_ASSERT(ToRegister(type)    == JSReturnReg_Type);
112317:     JS_ASSERT(ToRegister(payload) == JSReturnReg_Data);
112317: #elif defined(JS_PUNBOX64)
112317:     DebugOnly<LAllocation *> result = lir->getOperand(0);
112317:     JS_ASSERT(ToRegister(result) == JSReturnReg);
112317: #endif
112317:     // Don't emit a jump to the return label if this is the last block.
112317:     if (current->mir() != *gen->graph().poBegin())
112317:         masm.jump(returnLabel_);
112317:     return true;
112317: }
112317: 
112317: bool
112317: CodeGenerator::visitOsrEntry(LOsrEntry *lir)
112219: {
112219:     // Remember the OSR entry offset into the code buffer.
112492:     masm.flushBuffer();
112219:     setOsrEntryOffset(masm.size());
112219: 
112219:     // Allocate the full frame for this function.
112219:     masm.subPtr(Imm32(frameSize()), StackPointer);
112219:     return true;
112219: }
112219: 
112219: bool
112401: CodeGenerator::visitOsrScopeChain(LOsrScopeChain *lir)
112401: {
112401:     const LAllocation *frame   = lir->getOperand(0);
112401:     const LDefinition *object  = lir->getDef(0);
112401: 
112401:     const ptrdiff_t frameOffset = StackFrame::offsetOfScopeChain();
112401: 
112401:     masm.loadPtr(Address(ToRegister(frame), frameOffset), ToRegister(object));
112401:     return true;
112401: }
112401: 
112401: bool
112317: CodeGenerator::visitStackArg(LStackArg *lir)
112317: {
112317:     ValueOperand val = ToValue(lir, 0);
112317:     uint32 argslot = lir->argslot();
112317:     int32 stack_offset = StackOffsetOfPassedArg(argslot);
112317: 
112317:     masm.storeValue(val, Address(StackPointer, stack_offset));
112317:     return true;
112317: }
112317: 
112317: bool
112317: CodeGenerator::visitInteger(LInteger *lir)
112317: {
112317:     masm.move32(Imm32(lir->getValue()), ToRegister(lir->output()));
112317:     return true;
112317: }
112317: 
112317: bool
112118: CodeGenerator::visitPointer(LPointer *lir)
112118: {
112118:     masm.movePtr(ImmGCPtr(lir->ptr()), ToRegister(lir->output()));
112118:     return true;
112118: }
112118: 
112118: bool
112118: CodeGenerator::visitSlots(LSlots *lir)
112118: {
112258:     Address slots(ToRegister(lir->object()), JSObject::offsetOfSlots());
112118:     masm.loadPtr(slots, ToRegister(lir->output()));
112118:     return true;
112118: }
112118: 
112118: bool
112317: CodeGenerator::visitStoreSlotV(LStoreSlotV *store)
112317: {
112317:     Register base = ToRegister(store->slots());
112317:     int32 offset  = store->mir()->slot() * sizeof(Value);
112317: 
112317:     const ValueOperand value = ToValue(store, LStoreSlotV::Value);
112317: 
112726:     if (store->mir()->needsBarrier())
113010:        masm.emitPreBarrier(Address(base, offset), MIRType_Value);
112726: 
112317:     masm.storeValue(value, Address(base, offset));
112317:     return true;
112317: }
112317: 
112317: bool
112258: CodeGenerator::visitElements(LElements *lir)
112258: {
112258:     Address elements(ToRegister(lir->object()), JSObject::offsetOfElements());
112258:     masm.loadPtr(elements, ToRegister(lir->output()));
112258:     return true;
112258: }
112258: 
112258: bool
112401: CodeGenerator::visitFunctionEnvironment(LFunctionEnvironment *lir)
112401: {
112401:     Address environment(ToRegister(lir->function()), JSFunction::offsetOfEnvironment());
112401:     masm.loadPtr(environment, ToRegister(lir->output()));
112401:     return true;
112401: }
112401: 
112401: bool
112118: CodeGenerator::visitTypeBarrier(LTypeBarrier *lir)
112118: {
112118:     ValueOperand operand = ToValue(lir, LTypeBarrier::Input);
112118:     Register scratch = ToRegister(lir->temp());
112118: 
112118:     Label mismatched;
112118:     masm.guardTypeSet(operand, lir->mir()->typeSet(), scratch, &mismatched);
112118:     if (!bailoutFrom(&mismatched, lir->snapshot()))
112118:         return false;
112118:     return true;
112118: }
112118: 
112344: bool
112743: CodeGenerator::visitMonitorTypes(LMonitorTypes *lir)
112743: {
112743:     ValueOperand operand = ToValue(lir, LMonitorTypes::Input);
112743:     Register scratch = ToRegister(lir->temp());
112743: 
112743:     Label mismatched;
112743:     masm.guardTypeSet(operand, lir->mir()->typeSet(), scratch, &mismatched);
112743:     if (!bailoutFrom(&mismatched, lir->snapshot()))
112743:         return false;
112743:     return true;
112743: }
112743: 
112743: bool
112662: CodeGenerator::visitCallNative(LCallNative *call)
112662: {
112662:     JSFunction *target = call->function();
112662:     JS_ASSERT(target);
112662:     JS_ASSERT(target->isNative());
112662: 
112662:     int callargslot = call->argslot();
112662:     int unusedStack = StackOffsetOfPassedArg(callargslot);
112662: 
112662:     // Registers used for callWithABI() argument-passing.
112662:     const Register argJSContextReg = ToRegister(call->getArgJSContextReg());
112662:     const Register argUintNReg     = ToRegister(call->getArgUintNReg());
112662:     const Register argVpReg        = ToRegister(call->getArgVpReg());
112662: 
112662:     // Misc. temporary registers.
112662:     const Register tempReg = ToRegister(call->getTempReg());
112662: 
112662:     DebugOnly<uint32> initialStack = masm.framePushed();
112662: 
112662:     masm.checkStackAlignment();
112662: 
112662:     // Native functions have the signature:
112781:     //  bool (*)(JSContext *, unsigned, Value *vp)
112662:     // Where vp[0] is space for an outparam, vp[1] is |this|, and vp[2] onward
112662:     // are the function arguments.
112662: 
112662:     // Allocate space for the outparam, moving the StackPointer to what will be &vp[1].
112662:     masm.adjustStack(unusedStack);
112662: 
112662:     // Push a Value containing the callee object: natives are allowed to access their callee before
112851:     // setitng the return value. The StackPointer is moved to &vp[0].
112662:     masm.Push(ObjectValue(*target));
112662: 
112662:     // Preload arguments into registers.
112839:     masm.loadJSContext(argJSContextReg);
112662:     masm.move32(Imm32(call->nargs()), argUintNReg);
112662:     masm.movePtr(StackPointer, argVpReg);
112662: 
112662:     // Construct exit frame.
112662:     uint32 safepointOffset = masm.buildFakeExitFrame(tempReg);
113047:     masm.enterFakeExitFrame();
113047: 
112662:     if (!markSafepointAt(safepointOffset, call))
112662:         return false;
112662: 
112662:     // Construct and execute call.
112662:     masm.setupUnalignedABICall(3, tempReg);
112784:     masm.passABIArg(argJSContextReg);
112784:     masm.passABIArg(argUintNReg);
112784:     masm.passABIArg(argVpReg);
112662:     masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, target->native()));
112662: 
112662:     // Test for failure.
112662:     Label success, exception;
112662:     masm.branchTest32(Assembler::Zero, ReturnReg, ReturnReg, &exception);
112662: 
112662:     // Load the outparam vp[0] into output register(s).
113032:     masm.loadValue(Address(StackPointer, IonExitFrameLayout::SizeWithFooter()), JSReturnOperand);
112662:     masm.jump(&success);
112662: 
112662:     // Handle exception case.
112662:     {
112662:         masm.bind(&exception);
112662:         masm.handleException();
112662:     }
112662:     masm.bind(&success);
112662: 
113047:     // The next instruction is removing the footer of the exit frame, so there
113047:     // is no need for leaveFakeExitFrame.
113047: 
112662:     // Move the StackPointer back to its original location, unwinding the exit frame.
113032:     masm.adjustStack(IonExitFrameLayout::SizeWithFooter() - unusedStack + sizeof(Value));
112662:     JS_ASSERT(masm.framePushed() == initialStack);
112662: 
112662:     return true;
112662: }
112662: 
112662: bool
112344: CodeGenerator::visitCallGeneric(LCallGeneric *call)
112344: {
112344:     // Holds the function object.
112344:     const LAllocation *callee = call->getFunction();
112344:     Register calleereg = ToRegister(callee);
112344: 
112344:     // Temporary register for modifying the function object.
112344:     const LAllocation *obj = call->getTempObject();
112344:     Register objreg = ToRegister(obj);
112344: 
112344:     // Holds the function nargs. Initially undefined.
112344:     const LAllocation *nargs = call->getNargsReg();
112344:     Register nargsreg = ToRegister(nargs);
112344: 
112344:     uint32 callargslot = call->argslot();
112344:     uint32 unusedStack = StackOffsetOfPassedArg(callargslot);
112344: 
112344:     masm.checkStackAlignment();
112344: 
112674:     // Unless already known, guard that calleereg is actually a function object.
112674:     if (!call->hasSingleTarget()) {
112344:         masm.loadObjClass(calleereg, nargsreg);
112344:         masm.cmpPtr(nargsreg, ImmWord(&js::FunctionClass));
112344:         if (!bailoutIf(Assembler::NotEqual, call->snapshot()))
112344:             return false;
112674:     }
112344: 
112344:     Label end, invoke;
112344: 
112344:     // Guard that calleereg is a non-native function:
112344:     // Non-native iff (callee->flags & JSFUN_KINDMASK >= JSFUN_INTERPRETED).
112344:     // This is equivalent to testing if any of the bits in JSFUN_KINDMASK are set.
112674:     if (!call->hasSingleTarget()) {
112868:         Address flags(calleereg, offsetof(JSFunction, flags));
112967:         masm.load16ZeroExtend_mask(flags, Imm32(JSFUN_KINDMASK), nargsreg);
112868:         masm.branch32(Assembler::LessThan, nargsreg, Imm32(JSFUN_INTERPRETED), &invoke);
112674:     } else {
112674:         // Native single targets are handled by LCallNative.
112674:         JS_ASSERT(!call->getSingleTarget()->isNative());
112674:     }
112674: 
112344: 
112344:     // Knowing that calleereg is a non-native function, load the JSScript.
112344:     masm.movePtr(Address(calleereg, offsetof(JSFunction, u.i.script_)), objreg);
112344:     masm.movePtr(Address(objreg, offsetof(JSScript, ion)), objreg);
112344: 
112352:     // Guard that the IonScript has been compiled.
112344:     masm.branchPtr(Assembler::BelowOrEqual, objreg, ImmWord(ION_DISABLED_SCRIPT), &invoke);
112344: 
112359:     // Nestle %esp up to the argument vector.
112359:     masm.freeStack(unusedStack);
112359: 
112344:     // Construct the IonFramePrefix.
112366:     uint32 descriptor = MakeFrameDescriptor(masm.framePushed(), IonFrame_JS);
112344:     masm.Push(calleereg);
112366:     masm.Push(Imm32(descriptor));
112344: 
112344:     Label thunk, rejoin;
112344: 
112674:     if (call->hasSingleTarget()) {
112674:         // Missing arguments must have been explicitly appended by the IonBuilder.
112674:         JS_ASSERT(call->getSingleTarget()->nargs <= call->nargs());
112674:     } else {
112344:         // Check whether the provided arguments satisfy target argc.
112967:         masm.load16ZeroExtend(Address(calleereg, offsetof(JSFunction, nargs)), nargsreg);
112344:         masm.cmp32(nargsreg, Imm32(call->nargs()));
112344:         masm.j(Assembler::Above, &thunk);
112674:     }
112344: 
112352:     // No argument fixup needed. Load the start of the target IonCode.
112352:     {
112344:         masm.movePtr(Address(objreg, offsetof(IonScript, method_)), objreg);
112344:         masm.movePtr(Address(objreg, IonCode::OffsetOfCode()), objreg);
112352:     }
112344: 
112352:     // Argument fixup needed. Get ready to call the argumentsRectifier.
112674:     if (!call->hasSingleTarget()) {
112674:         // Skip this thunk unless an explicit jump target.
112674:         masm.jump(&rejoin);
112674:         masm.bind(&thunk);
112674: 
112352:         // Hardcode the address of the argumentsRectifier code.
112352:         IonCompartment *ion = gen->ionCompartment();
112352:         IonCode *argumentsRectifier = ion->getArgumentsRectifier(gen->cx);
112352:         if (!argumentsRectifier)
112352:             return false;
112352: 
112352:         JS_ASSERT(ArgumentsRectifierReg != objreg);
112344:         masm.move32(Imm32(call->nargs()), ArgumentsRectifierReg);
112344:         masm.movePtr(ImmWord(argumentsRectifier->raw()), objreg);
112352:     }
112344: 
112344:     masm.bind(&rejoin);
112352: 
112352:     masm.checkStackAlignment();
112352: 
112352:     // Finally call the function in objreg, as assigned by one of the paths above.
112344:     masm.callIon(objreg);
112505:     if (!markSafepoint(call))
112344:         return false;
112352: 
112344:     // Increment to remove IonFramePrefix; decrement to fill FrameSizeClass.
112344:     // The return address has already been removed from the Ion frame.
112344:     int prefixGarbage = sizeof(IonJSFrameLayout) - sizeof(void *);
112662:     masm.adjustStack(prefixGarbage - unusedStack);
112344: 
112352:     masm.jump(&end);
112352: 
112352:     // Handle uncompiled or native functions.
112352:     {
112352:         masm.bind(&invoke);
112352: 
112919:         typedef bool (*pf)(JSContext *, JSFunction *, uint32, Value *, Value *);
112352:         static const VMFunction InvokeFunctionInfo = FunctionInfo<pf>(InvokeFunction);
112352: 
112359:         // Nestle %esp up to the argument vector.
112359:         // Each path must account for framePushed_ separately, for callVM to be valid.
112359:         masm.freeStack(unusedStack);
112359: 
112352:         pushArg(StackPointer);                 // argv.
112998:         pushArg(Imm32(call->bytecodeArgc()));  // argc.
112352:         pushArg(calleereg);                    // JSFunction *.
112352: 
112352:         if (!callVM(InvokeFunctionInfo, call))
112352:             return false;
112352: 
112352:         // Un-nestle %esp from the argument vector. No prefix was pushed.
112359:         masm.reserveStack(unusedStack);
112352:     }
112352: 
112344:     masm.bind(&end);
112344: 
112874:     // If the return value of the constructing function is Primitive,
112874:     // replace the return value with the Object from CreateThis.
112874:     if (call->mir()->isConstructing()) {
112874:         Label notPrimitive;
112874: 
112874:         masm.branchTestPrimitive(Assembler::NotEqual, JSReturnOperand, &notPrimitive);
112874:         masm.loadValue(Address(StackPointer, unusedStack), JSReturnOperand);
112874: 
112874:         masm.bind(&notPrimitive);
112874:     }
112874: 
112874:     return true;
112874: }
112874: 
112874: bool
112874: CodeGenerator::visitCallConstructor(LCallConstructor *call)
112874: {
112874:     JS_ASSERT(call->mir()->isConstructing());
112874: 
112874:     // Holds the function object.
112874:     const LAllocation *callee = call->getFunction();
112874:     Register calleereg = ToRegister(callee);
112874: 
112874:     uint32 callargslot = call->argslot();
112874:     uint32 unusedStack = StackOffsetOfPassedArg(callargslot);
112874: 
112919:     typedef bool (*pf)(JSContext *, JSFunction *, uint32, Value *, Value *);
112874:     static const VMFunction InvokeConstructorFunctionInfo =
112874:         FunctionInfo<pf>(InvokeConstructorFunction);
112874: 
112874:     // Nestle %esp up to the argument vector.
112874:     masm.freeStack(unusedStack);
112874: 
112874:     pushArg(StackPointer);          // argv.
112874:     pushArg(Imm32(call->nargs()));  // argc.
112874:     pushArg(calleereg);             // JSFunction *.
112874: 
112874:     if (!callVM(InvokeConstructorFunctionInfo, call))
112874:         return false;
112874: 
112874:     // Un-nestle %esp from the argument vector. No prefix was pushed.
112874:     masm.reserveStack(unusedStack);
112874: 
112344:     return true;
112344: }
112344: 
112292: // Registers safe for use before generatePrologue().
112292: static const uint32 EntryTempMask = Registers::TempMask & ~(1 << OsrFrameReg.code());
112292: 
112118: bool
112108: CodeGenerator::generateArgumentsChecks()
112108: {
112108:     MIRGraph &mir = gen->graph();
112108:     MResumePoint *rp = mir.entryResumePoint();
112108: 
112108:     // Reserve the amount of stack the actual frame will use. We have to undo
112108:     // this before falling through to the method proper though, because the
112108:     // monomorphic call case will bypass this entire path.
112108:     masm.reserveStack(frameSize());
112108: 
112108:     // No registers are allocated yet, so it's safe to grab anything.
112292:     Register temp = GeneralRegisterSet(EntryTempMask).getAny();
112108: 
112401:     CompileInfo &info = gen->info();
112401: 
112401:     // Indexes need to be shifted by one, to skip the scope chain slot.
112401:     JS_ASSERT(info.scopeChainSlot() == 0);
112401:     static const uint32 START_SLOT = 1;
112401: 
112108:     Label mismatched;
112401:     for (uint32 i = START_SLOT; i < CountArgSlots(info.fun()); i++) {
112108:         // All initial parameters are guaranteed to be MParameters.
112108:         MParameter *param = rp->getOperand(i)->toParameter();
112108:         types::TypeSet *types = param->typeSet();
112108:         if (!types || types->unknown())
112108:             continue;
112108: 
112108:         // Use ReturnReg as a scratch register here, since not all platforms
112108:         // have an actual ScratchReg.
112401:         int32 offset = ArgToStackOffset((i - START_SLOT) * sizeof(Value));
112108:         masm.guardTypeSet(Address(StackPointer, offset), types, temp, &mismatched);
112108:     }
112108: 
112108:     if (mismatched.used() && !bailoutFrom(&mismatched, graph.entrySnapshot()))
112108:         return false;
112108: 
112108:     masm.freeStack(frameSize());
112108: 
112108:     return true;
112108: }
112108: 
112292: // Out-of-line path to report over-recursed error and fail.
112292: class CheckOverRecursedFailure : public OutOfLineCodeBase<CodeGenerator>
112292: {
112292:     LCheckOverRecursed *lir_;
112292: 
112292:   public:
112292:     CheckOverRecursedFailure(LCheckOverRecursed *lir)
112292:       : lir_(lir)
112292:     { }
112292: 
112292:     bool accept(CodeGenerator *codegen) {
112292:         return codegen->visitCheckOverRecursedFailure(this);
112292:     }
112292: 
112292:     LCheckOverRecursed *lir() const {
112292:         return lir_;
112292:     }
112292: };
112292: 
112292: bool
112292: CodeGenerator::visitCheckOverRecursed(LCheckOverRecursed *lir)
112292: {
112292:     // Ensure that this frame will not cross the stack limit.
112292:     // This is a weak check, justified by Ion using the C stack: we must always
112292:     // be some distance away from the actual limit, since if the limit is
112292:     // crossed, an error must be thrown, which requires more frames.
112292:     //
112292:     // It must always be possible to trespass past the stack limit.
112292:     // Ion may legally place frames very close to the limit. Calling additional
112292:     // C functions may then violate the limit without any checking.
112292: 
112479:     JSRuntime *rt = gen->cx->runtime;
112292: 
112292:     // No registers are allocated yet, so it's safe to grab anything.
112292:     const LAllocation *limit = lir->limitTemp();
112292:     Register limitReg = ToRegister(limit);
112292: 
112292:     // Since Ion frames exist on the C stack, the stack limit may be
112292:     // dynamically set by JS_SetThreadStackLimit() and JS_SetNativeStackQuota().
112479:     uintptr_t *limitAddr = &rt->ionStackLimit;
112946:     masm.loadPtr(AbsoluteAddress(limitAddr), limitReg);
112292: 
112292:     CheckOverRecursedFailure *ool = new CheckOverRecursedFailure(lir);
112292:     if (!addOutOfLineCode(ool))
112292:         return false;
112292: 
112292:     // Conditional forward (unlikely) branch to failure.
112292:     masm.branchPtr(Assembler::BelowOrEqual, StackPointer, limitReg, ool->entry());
112292: 
112292:     return true;
112292: }
112292: 
112292: bool
112716: CodeGenerator::visitDefVar(LDefVar *lir)
112716: {
112716:     Register scopeChain = ToRegister(lir->getScopeChain());
112716:     Register nameTemp   = ToRegister(lir->nameTemp());
112716: 
112984:     typedef bool (*pf)(JSContext *, HandlePropertyName, unsigned, HandleObject);
112984:     static const VMFunction DefVarOrConstInfo = FunctionInfo<pf>(DefVarOrConst);
112716: 
112716:     masm.movePtr(ImmWord(lir->mir()->name()), nameTemp);
112716: 
112716:     pushArg(scopeChain); // JSObject *
112781:     pushArg(Imm32(lir->mir()->attrs())); // unsigned
112716:     pushArg(nameTemp); // PropertyName *
112716: 
112716:     if (!callVM(DefVarOrConstInfo, lir))
112716:         return false;
112716: 
112716:     return true;
112716: }
112716: 
112716: bool
112292: CodeGenerator::visitCheckOverRecursedFailure(CheckOverRecursedFailure *ool)
112292: {
112292:     // The OOL path is hit if the recursion depth has been exceeded.
112292:     // Throw an InternalError for over-recursion.
112292: 
112292:     typedef bool (*pf)(JSContext *);
112292:     static const VMFunction ReportOverRecursedInfo =
112292:         FunctionInfo<pf>(ReportOverRecursed);
112292: 
112292:     if (!callVM(ReportOverRecursedInfo, ool->lir()))
112292:         return false;
112292: 
112292: #ifdef DEBUG
112292:     // Do not rejoin: the above call causes failure.
112292:     masm.breakpoint();
112292: #endif
112292:     return true;
112292: }
112292: 
112108: bool
111930: CodeGenerator::generateBody()
111930: {
111930:     for (size_t i = 0; i < graph.numBlocks(); i++) {
111930:         current = graph.getBlock(i);
111930:         for (LInstructionIterator iter = current->begin(); iter != current->end(); iter++) {
112445:             IonSpew(IonSpew_Codegen, "instruction %s", iter->opName());
111935:             if (!iter->accept(this))
111936:                 return false;
111930:         }
111935:         if (masm.oom())
111935:             return false;
111930:     }
111930:     return true;
111930: }
111930: 
112956: // Out-of-line object allocation for LNewArray.
112956: class OutOfLineNewArray : public OutOfLineCodeBase<CodeGenerator>
112956: {
112956:     LNewArray *lir_;
112956: 
112956:   public:
112956:     OutOfLineNewArray(LNewArray *lir)
112956:       : lir_(lir)
112956:     { }
112956: 
112956:     bool accept(CodeGenerator *codegen) {
112956:         return codegen->visitOutOfLineNewArray(this);
112956:     }
112956: 
112956:     LNewArray *lir() const {
112956:         return lir_;
112956:     }
112956: };
112956: 
112956: bool
112956: CodeGenerator::visitNewArrayCallVM(LNewArray *lir)
112956: {
112956:     Register objReg = ToRegister(lir->output());
112956: 
112956:     typedef JSObject *(*pf)(JSContext *, uint32, types::TypeObject *);
112956:     static const VMFunction NewInitArrayInfo = FunctionInfo<pf>(NewInitArray);
112956: 
112956:     JS_ASSERT(!lir->isCall());
112956:     saveLive(lir);
112956: 
112956:     pushArg(ImmGCPtr(lir->mir()->type()));
112956:     pushArg(Imm32(lir->mir()->count()));
112956: 
112956:     if (!callVM(NewInitArrayInfo, lir))
112956:         return false;
112956: 
112956:     if (ReturnReg != objReg)
112956:         masm.movePtr(ReturnReg, objReg);
112956: 
112956:     restoreLive(lir);
112956: 
112956:     return true;
112956: }
112956: 
111930: bool
112764: CodeGenerator::visitNewArray(LNewArray *lir)
112339: {
112956:     Register objReg = ToRegister(lir->output());
112956:     types::TypeObject *typeObj = lir->mir()->type();
112956:     uint32 count = lir->mir()->count();
112956: 
112956:     size_t maxArraySlots =
112956:         gc::GetGCKindSlots(gc::FINALIZE_OBJECT_LAST) - ObjectElements::VALUES_PER_HEADER;
112956: 
112981:     // Allocate space using the VMCall
112981:     // when mir hints it needs to get allocated immediatly,
112981:     // but only when data doesn't fit the available array slots.
112981:     bool allocating = lir->mir()->isAllocating() && count > maxArraySlots;
112981: 
112981:     if (!gen->cx->typeInferenceEnabled() || !typeObj || allocating)
112956:         return visitNewArrayCallVM(lir);
112956: 
112956:     OutOfLineNewArray *ool = new OutOfLineNewArray(lir);
112956:     if (!addOutOfLineCode(ool))
112339:         return false;
112956: 
113053:     RootedVarObject templateObject(gen->cx, NewDenseUnallocatedArray(gen->cx, count));
112956:     if (!templateObject)
112956:         return false;
112956:     templateObject->setType(typeObj);
112956: 
112956:     masm.getNewObject(gen->cx, objReg, templateObject, ool->entry());
112956:     masm.bind(ool->rejoin());
112956: 
112956:     return true;
112956: }
112956: 
112956: bool
112956: CodeGenerator::visitOutOfLineNewArray(OutOfLineNewArray *ool)
112956: {
112956:     if (!visitNewArrayCallVM(ool->lir()))
112956:         return false;
112956:     masm.jump(ool->rejoin());
112339:     return true;
112339: }
112339: 
112955: // Out-of-line object allocation for JSOP_NEWOBJECT.
112955: class OutOfLineNewObject : public OutOfLineCodeBase<CodeGenerator>
112955: {
112955:     LNewObject *lir_;
112955: 
112955:   public:
112955:     OutOfLineNewObject(LNewObject *lir)
112955:       : lir_(lir)
112955:     { }
112955: 
112955:     bool accept(CodeGenerator *codegen) {
112955:         return codegen->visitOutOfLineNewObject(this);
112955:     }
112955: 
112955:     LNewObject *lir() const {
112955:         return lir_;
112955:     }
112955: };
112955: 
112955: bool
112955: CodeGenerator::visitNewObjectVMCall(LNewObject *lir)
112955: {
112955:     Register objReg = ToRegister(lir->output());
112955: 
112984:     typedef JSObject *(*pf)(JSContext *, HandleObject, types::TypeObject *);
112955:     static const VMFunction Info = FunctionInfo<pf>(NewInitObject);
112955: 
112955:     JS_ASSERT(!lir->isCall());
112955:     saveLive(lir);
112955: 
112955:     pushArg(ImmGCPtr(lir->mir()->type()));
112955:     pushArg(ImmGCPtr(lir->mir()->baseObj()));
112955:     if (!callVM(Info, lir))
112955:         return false;
112955: 
112955:     if (ReturnReg != objReg)
112955:         masm.movePtr(ReturnReg, objReg);
112955: 
112955:     restoreLive(lir);
112955:     return true;
112955: }
112955: 
112339: bool
112764: CodeGenerator::visitNewObject(LNewObject *lir)
112764: {
112955:     Register objReg = ToRegister(lir->output());
112955: 
112984:     RootedVarObject baseObj(gen->cx, lir->mir()->baseObj());
112955:     types::TypeObject *typeObj = lir->mir()->type();
112955: 
112976:     if (!gen->cx->typeInferenceEnabled() || !typeObj ||
112976:         !baseObj || baseObj->hasDynamicSlots())
112976:     {
112955:         return visitNewObjectVMCall(lir);
112976:     }
112955: 
112955:     OutOfLineNewObject *ool = new OutOfLineNewObject(lir);
112955:     if (!addOutOfLineCode(ool))
112955:         return false;
112955: 
112984:     RootedVarObject templateObject(gen->cx, CopyInitializerObject(gen->cx, baseObj));
112955:     if (!templateObject)
112955:         return false;
112955:     templateObject->setType(typeObj);
112955: 
112955:     masm.getNewObject(gen->cx, objReg, templateObject, ool->entry());
112955:     masm.bind(ool->rejoin());
112955: 
112955:     return true;
112955: }
112955: 
112955: bool
112955: CodeGenerator::visitOutOfLineNewObject(OutOfLineNewObject *ool)
112955: {
112955:     if (!visitNewObjectVMCall(ool->lir()))
112955:         return false;
112955:     masm.jump(ool->rejoin());
112955:     return true;
112764: }
112764: 
112976: bool
112976: CodeGenerator::visitInitProp(LInitProp *lir)
112976: {
112976:     Register objReg = ToRegister(lir->getObject());
112976: 
112984:     typedef bool(*pf)(JSContext *cx, HandleObject obj, HandlePropertyName name, const Value &value);
112976:     static const VMFunction InitPropInfo = FunctionInfo<pf>(InitProp);
112976: 
113003:     pushArg(ToValue(lir, LInitProp::ValueIndex));
113003:     pushArg(ImmWord(lir->mir()->propertyName()));
112976:     pushArg(objReg);
112976: 
112976:     return callVM(InitPropInfo, lir);
112976: }
112976: 
112946: // Out-of-line object allocation for |new|, calling to the VM.
112946: class OutOfLineCreateThis : public OutOfLineCodeBase<CodeGenerator>
112946: {
112946:     LCreateThis *lir_;
112946: 
112946:   public:
112946:     OutOfLineCreateThis(LCreateThis *lir)
112946:       : lir_(lir)
112946:     { }
112946: 
112946:     bool accept(CodeGenerator *codegen) {
112946:         return codegen->visitOutOfLineCreateThis(this);
112946:     }
112946: 
112946:     LCreateThis *lir() const {
112946:         return lir_;
112946:     }
112946: };
112946: 
112946: bool
112946: CodeGenerator::visitCreateThisVMCall(LCreateThis *lir)
112946: {
112946:     Register objReg    = ToRegister(lir->output());
112946:     Register calleeReg = ToRegister(lir->getCallee());
112946:     Register protoReg  = ToRegister(lir->getPrototype());
112946: 
112946:     // Since LCreateThis is not isCall(), used registers must be saved around the call.
112946:     JS_ASSERT(!lir->isCall());
112946:     saveLive(lir);
112946: 
112984:     typedef JSObject *(*pf)(JSContext *cx, HandleObject callee, JSObject *proto);
112946:     static const VMFunction CreateThisInfo =
112946:         FunctionInfo<pf>(js_CreateThisForFunctionWithProto);
112946: 
112946:     pushArg(protoReg);
112946:     pushArg(calleeReg);
112946: 
112946:     if (!callVM(CreateThisInfo, lir))
112946:         return false;
112946: 
112946:     if (ReturnReg != objReg)
112946:         masm.movePtr(ReturnReg, objReg);
112946: 
112946:     restoreLive(lir);
112946:     return true;
112946: }
112946: 
112764: bool
112874: CodeGenerator::visitCreateThis(LCreateThis *lir)
112874: {
112946:     Register objReg = ToRegister(lir->output());
112946: 
112946:     // Attempt to inline allocation if possible.
112946:     if (lir->mir()->hasTemplateObject()) {
112946:         OutOfLineCreateThis *ool = new OutOfLineCreateThis(lir);
112946:         if (!addOutOfLineCode(ool))
112946:             return false;
112946: 
113053:         RootedVarObject templateObject(gen->cx, lir->mir()->getTemplateObject());
113053: 
113053:         masm.getNewObject(gen->cx, objReg, templateObject, ool->entry());
112946:         masm.bind(ool->rejoin());
112946:         return true;
112946:     }
112946: 
112946:     return visitCreateThisVMCall(lir);
112946: }
112946: 
112946: bool
112946: CodeGenerator::visitOutOfLineCreateThis(OutOfLineCreateThis *ool)
112874: {
112946:     if (!visitCreateThisVMCall(ool->lir()))
112874:         return false;
112946:     masm.jump(ool->rejoin());
112874:     return true;
112874: }
112874: 
112874: bool
112309: CodeGenerator::visitArrayLength(LArrayLength *lir)
112309: {
112309:     Address length(ToRegister(lir->elements()), ObjectElements::offsetOfLength());
112309:     masm.load32(length, ToRegister(lir->output()));
112309:     return true;
112309: }
112309: 
112309: bool
112867: CodeGenerator::visitTypedArrayLength(LTypedArrayLength *lir)
112867: {
112867:     Register obj = ToRegister(lir->object());
112867:     Register out = ToRegister(lir->output());
112867:     masm.unboxInt32(Address(obj, TypedArray::lengthOffset()), out);
112867:     return true;
112867: }
112867: 
112867: bool
112904: CodeGenerator::visitTypedArrayElements(LTypedArrayElements *lir)
112904: {
112904:     Register obj = ToRegister(lir->object());
112904:     Register out = ToRegister(lir->output());
112904:     masm.loadPtr(Address(obj, TypedArray::dataOffset()), out);
112904:     return true;
112904: }
112904: 
112904: bool
112309: CodeGenerator::visitStringLength(LStringLength *lir)
112309: {
112309:     Address lengthAndFlags(ToRegister(lir->string()), JSString::offsetOfLengthAndFlags());
112309:     Register output = ToRegister(lir->output());
112309: 
112309:     masm.loadPtr(lengthAndFlags, output);
112309:     masm.rshiftPtr(Imm32(JSString::LENGTH_SHIFT), output);
112309:     return true;
112309: }
112309: 
112429: bool
112655: CodeGenerator::visitAbsI(LAbsI *ins)
112655: {
112655:     Register input = ToRegister(ins->input());
112655:     Label positive;
112655: 
112655:     JS_ASSERT(input == ToRegister(ins->output()));
112655:     masm.test32(input, input);
112655:     masm.j(Assembler::GreaterThanOrEqual, &positive);
112655:     masm.neg32(input);
112655:     if (!ins->snapshot() || !bailoutIf(Assembler::Overflow, ins->snapshot()))
112655:         return false;
112655:     masm.bind(&positive);
112655: 
112655:     return true;
112655: }
112655: 
112655: bool
112471: CodeGenerator::visitBinaryV(LBinaryV *lir)
112429: {
113014:     typedef bool (*pf)(JSContext *, HandleValue, HandleValue, Value *);
112494:     static const VMFunction AddInfo = FunctionInfo<pf>(js::AddValues);
112494:     static const VMFunction SubInfo = FunctionInfo<pf>(js::SubValues);
112494:     static const VMFunction MulInfo = FunctionInfo<pf>(js::MulValues);
112494:     static const VMFunction DivInfo = FunctionInfo<pf>(js::DivValues);
112494:     static const VMFunction ModInfo = FunctionInfo<pf>(js::ModValues);
112970:     static const VMFunction UrshInfo = FunctionInfo<pf>(js::UrshValues);
112471: 
112471:     pushArg(ToValue(lir, LBinaryV::RhsInput));
112471:     pushArg(ToValue(lir, LBinaryV::LhsInput));
112494: 
112494:     switch (lir->jsop()) {
112494:       case JSOP_ADD:
112494:         return callVM(AddInfo, lir);
112494: 
112494:       case JSOP_SUB:
112494:         return callVM(SubInfo, lir);
112494: 
112494:       case JSOP_MUL:
112494:         return callVM(MulInfo, lir);
112494: 
112494:       case JSOP_DIV:
112494:         return callVM(DivInfo, lir);
112494: 
112494:       case JSOP_MOD:
112494:         return callVM(ModInfo, lir);
112494: 
112970:       case JSOP_URSH:
112970:         return callVM(UrshInfo, lir);
112970: 
112494:       default:
112494:         JS_NOT_REACHED("Unexpected binary op");
112494:         return false;
112494:     }
112494: }
112494: 
112494: bool
112494: CodeGenerator::visitCompareV(LCompareV *lir)
112494: {
112494:     typedef bool (*pf)(JSContext *, const Value &, const Value &, JSBool *);
112494:     static const VMFunction EqInfo = FunctionInfo<pf>(ion::LooselyEqual<true>);
112494:     static const VMFunction NeInfo = FunctionInfo<pf>(ion::LooselyEqual<false>);
112494:     static const VMFunction StrictEqInfo = FunctionInfo<pf>(ion::StrictlyEqual<true>);
112494:     static const VMFunction StrictNeInfo = FunctionInfo<pf>(ion::StrictlyEqual<false>);
112494:     static const VMFunction LtInfo = FunctionInfo<pf>(ion::LessThan);
112494:     static const VMFunction LeInfo = FunctionInfo<pf>(ion::LessThanOrEqual);
112494:     static const VMFunction GtInfo = FunctionInfo<pf>(ion::GreaterThan);
112494:     static const VMFunction GeInfo = FunctionInfo<pf>(ion::GreaterThanOrEqual);
112494: 
112494:     pushArg(ToValue(lir, LBinaryV::RhsInput));
112494:     pushArg(ToValue(lir, LBinaryV::LhsInput));
112494: 
112494:     switch (lir->jsop()) {
112494:       case JSOP_EQ:
112494:         return callVM(EqInfo, lir);
112494: 
112494:       case JSOP_NE:
112494:         return callVM(NeInfo, lir);
112494: 
112494:       case JSOP_STRICTEQ:
112494:         return callVM(StrictEqInfo, lir);
112494: 
112494:       case JSOP_STRICTNE:
112494:         return callVM(StrictNeInfo, lir);
112494: 
112494:       case JSOP_LT:
112494:         return callVM(LtInfo, lir);
112494: 
112494:       case JSOP_LE:
112494:         return callVM(LeInfo, lir);
112494: 
112494:       case JSOP_GT:
112494:         return callVM(GtInfo, lir);
112494: 
112494:       case JSOP_GE:
112494:         return callVM(GeInfo, lir);
112494: 
112494:       default:
112494:         JS_NOT_REACHED("Unexpected compare op");
112494:         return false;
112494:     }
112429: }
112429: 
112429: bool
112737: CodeGenerator::visitIsNullOrUndefined(LIsNullOrUndefined *lir)
112737: {
112737:     JSOp op = lir->mir()->jsop();
112737:     MIRType specialization = lir->mir()->specialization();
112737:     JS_ASSERT(IsNullOrUndefined(specialization));
112737: 
112737:     const ValueOperand value = ToValue(lir, LIsNullOrUndefined::Value);
112737:     Register output = ToRegister(lir->output());
112737: 
112737:     if (op == JSOP_EQ || op == JSOP_NE) {
112737:         Register tag = masm.splitTagForTest(value);
112737: 
112737:         Label nullOrUndefined, done;
112737:         masm.branchTestNull(Assembler::Equal, tag, &nullOrUndefined);
112737:         masm.branchTestUndefined(Assembler::Equal, tag, &nullOrUndefined);
112737: 
112737:         masm.move32(Imm32(op == JSOP_NE), output);
112737:         masm.jump(&done);
112737: 
112737:         masm.bind(&nullOrUndefined);
112737:         masm.move32(Imm32(op == JSOP_EQ), output);
112737:         masm.bind(&done);
112737:         return true;
112737:     }
112737: 
112737:     JS_ASSERT(op == JSOP_STRICTEQ || op == JSOP_STRICTNE);
112737: 
112737:     Assembler::Condition cond = JSOpToCondition(op);
112737:     if (specialization == MIRType_Null)
112737:         cond = masm.testNull(cond, value);
112737:     else
112737:         cond = masm.testUndefined(cond, value);
112737: 
112737:     emitSet(cond, output);
112737:     return true;
112737: }
112737: 
112737: bool
112737: CodeGenerator::visitIsNullOrUndefinedAndBranch(LIsNullOrUndefinedAndBranch *lir)
112737: {
112737:     JSOp op = lir->mir()->jsop();
112737:     MIRType specialization = lir->mir()->specialization();
112737:     JS_ASSERT(IsNullOrUndefined(specialization));
112737: 
112737:     const ValueOperand value = ToValue(lir, LIsNullOrUndefinedAndBranch::Value);
112737: 
112737:     if (op == JSOP_EQ || op == JSOP_NE) {
112737:         MBasicBlock *ifTrue;
112737:         MBasicBlock *ifFalse;
112737: 
112737:         if (op == JSOP_EQ) {
112737:             ifTrue = lir->ifTrue();
112737:             ifFalse = lir->ifFalse();
112737:         } else {
112737:             // Swap branches.
112737:             ifTrue = lir->ifFalse();
112737:             ifFalse = lir->ifTrue();
112737:             op = JSOP_EQ;
112737:         }
112737: 
112737:         Register tag = masm.splitTagForTest(value);
112737:         masm.branchTestNull(Assembler::Equal, tag, ifTrue->lir()->label());
112737: 
112737:         Assembler::Condition cond = masm.testUndefined(Assembler::Equal, tag);
112737:         emitBranch(cond, ifTrue, ifFalse);
112737:         return true;
112737:     }
112737: 
112737:     JS_ASSERT(op == JSOP_STRICTEQ || op == JSOP_STRICTNE);
112737: 
112737:     Assembler::Condition cond = JSOpToCondition(op);
112737:     if (specialization == MIRType_Null)
112737:         cond = masm.testNull(cond, value);
112737:     else
112737:         cond = masm.testUndefined(cond, value);
112737: 
112737:     emitBranch(cond, lir->ifTrue(), lir->ifFalse());
112737:     return true;
112737: }
112737: 
112737: bool
112429: CodeGenerator::visitConcat(LConcat *lir)
112429: {
112984:     typedef JSString *(*pf)(JSContext *, HandleString, HandleString);
112429:     static const VMFunction js_ConcatStringsInfo = FunctionInfo<pf>(js_ConcatStrings);
112429: 
112429:     pushArg(ToRegister(lir->rhs()));
112429:     pushArg(ToRegister(lir->lhs()));
112429:     if (!callVM(js_ConcatStringsInfo, lir))
112429:         return false;
112429:     return true;
112429: }
112309: 
112309: bool
112728: CodeGenerator::visitCharCodeAt(LCharCodeAt *lir)
112728: {
112728:     Register str = ToRegister(lir->str());
112728:     Register index = ToRegister(lir->index());
112728:     Register output = ToRegister(lir->output());
112728: 
112728:     typedef bool (*pf)(JSContext *, JSString *);
112728:     static const VMFunction ensureLinearInfo = FunctionInfo<pf>(JSString::ensureLinear);
112728:     OutOfLineCode *ool = oolCallVM(ensureLinearInfo, lir, (ArgList(), str), StoreNothing());
112728:     if (!ool)
112728:         return false;
112728: 
112728:     Address lengthAndFlagsAddr(str, JSString::offsetOfLengthAndFlags());
112728:     masm.loadPtr(lengthAndFlagsAddr, output);
112728: 
112728:     JS_ASSERT(JSString::LINEAR_FLAGS == 0);
112728:     masm.branchTest32(Assembler::NonZero, output, Imm32(JSString::LINEAR_MASK), ool->entry());
112728:     masm.bind(ool->rejoin());
112728: 
112728:     // getChars
112728:     Address charsAddr(str, JSString::offsetOfChars());
112728:     masm.loadPtr(charsAddr, output);
112967:     masm.load16ZeroExtend(BaseIndex(output, index, TimesTwo, 0), output);
112728: 
112728:     return true;
112728: }
112728: 
112728: bool
112728: CodeGenerator::visitFromCharCode(LFromCharCode *lir)
112728: {
112728:     Register code = ToRegister(lir->code());
112728:     Register output = ToRegister(lir->output());
112728: 
112728:     // This static variable would be used by js_NewString as an initial buffer.
112728:     Label fast;
112728:     masm.cmpPtr(code, ImmWord(StaticStrings::UNIT_STATIC_LIMIT));
112728:     masm.j(Assembler::Below, &fast);
112728: 
112728:     // Store the code in the tmpString. This assume that jitted codes are not
112728:     // running concurently.
112728:     static jschar tmpString[2] = {0, 0};
112728:     Register tmpStringAddr = output;
112728:     masm.movePtr(ImmWord(tmpString), tmpStringAddr);
112728:     masm.store16(code, Address(tmpStringAddr, 0));
112728: 
112728:     // Copy the tmpString to a newly allocated string.
112728:     typedef JSFixedString *(*pf)(JSContext *, const jschar *, size_t);
112728:     static const VMFunction newStringCopyNInfo = FunctionInfo<pf>(js_NewStringCopyN);
112728:     OutOfLineCode *ool = oolCallVM(newStringCopyNInfo, lir, (ArgList(), tmpStringAddr, Imm32(1)),
112728:                                    StoreRegisterTo(output));
112728:     if (!ool)
112728:         return false;
112728: 
112728:     masm.jump(ool->entry());
112728:     masm.bind(&fast);
112728:     masm.movePtr(ImmWord(&gen->cx->runtime->staticStrings.unitStaticTable), output);
112728:     masm.loadPtr(BaseIndex(output, code, ScalePointer), output);
112728:     masm.bind(ool->rejoin());
112728:     return true;
112728: }
112728: 
112728: bool
112231: CodeGenerator::visitInitializedLength(LInitializedLength *lir)
112231: {
112258:     Address initLength(ToRegister(lir->elements()), ObjectElements::offsetOfInitializedLength());
112236:     masm.load32(initLength, ToRegister(lir->output()));
112231:     return true;
112231: }
112231: 
112231: bool
112734: CodeGenerator::visitSetInitializedLength(LSetInitializedLength *lir)
112734: {
112734:     Address initLength(ToRegister(lir->elements()), ObjectElements::offsetOfInitializedLength());
112734:     Int32Key index = ToInt32Key(lir->index());
112734: 
112734:     masm.bumpKey(&index, 1);
112734:     masm.storeKey(index, initLength);
112734:     // Restore register value if it is used/captured after.
112734:     masm.bumpKey(&index, -1);
112734:     return true;
112734: }
112734: 
112734: bool
112851: CodeGenerator::visitNotV(LNotV *lir)
112696: {
112851:     Label setFalse;
112851:     Label join;
112851:     masm.branchTestValueTruthy(ToValue(lir, LNotV::Input), &setFalse, ToFloatRegister(lir->tempFloat()));
112851: 
112851:     // fallthrough to set true
112851:     masm.move32(Imm32(1), ToRegister(lir->getDef(0)));
112851:     masm.jump(&join);
112851: 
112851:     // true case rediercts to setFalse
112851:     masm.bind(&setFalse);
112851:     masm.move32(Imm32(0), ToRegister(lir->getDef(0)));
112851: 
112851:     // both branches meet here.
112851:     masm.bind(&join);
112851:     return true;
112696: }
112696: 
112696: bool
112488: CodeGenerator::visitBoundsCheck(LBoundsCheck *lir)
112488: {
112488:     if (lir->index()->isConstant())
112488:         masm.cmp32(ToRegister(lir->length()), Imm32(ToInt32(lir->index())));
112488:     else
112488:         masm.cmp32(ToRegister(lir->length()), ToRegister(lir->index()));
112488:     return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
112488: }
112488: 
112488: bool
112488: CodeGenerator::visitBoundsCheckRange(LBoundsCheckRange *lir)
112488: {
112488:     int32 min = lir->mir()->minimum();
112488:     int32 max = lir->mir()->maximum();
112488:     JS_ASSERT(max >= min);
112488: 
112488:     Register temp = ToRegister(lir->getTemp(0));
112488:     if (lir->index()->isConstant()) {
112488:         int32 nmin, nmax;
112488:         int32 index = ToInt32(lir->index());
112488:         if (SafeAdd(index, min, &nmin) && SafeAdd(index, max, &nmax) && nmin >= 0) {
112488:             masm.cmp32(ToRegister(lir->length()), Imm32(nmax));
112488:             return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
112488:         }
112488:         masm.mov(Imm32(index), temp);
112488:     } else {
112488:         masm.mov(ToRegister(lir->index()), temp);
112488:     }
112488: 
112488:     // If the minimum and maximum differ then do an underflow check first.
112488:     // If the two are the same then doing an unsigned comparison on the
112488:     // length will also catch a negative index.
112488:     if (min != max) {
112488:         if (min != 0) {
112488:             masm.add32(Imm32(min), temp);
112488:             if (!bailoutIf(Assembler::Overflow, lir->snapshot()))
112488:                 return false;
112488:             int32 diff;
112488:             if (SafeSub(max, min, &diff))
112488:                 max = diff;
112488:             else
112488:                 masm.sub32(Imm32(min), temp);
112488:         }
112488: 
112488:         masm.cmp32(temp, Imm32(0));
112488:         if (!bailoutIf(Assembler::LessThan, lir->snapshot()))
112488:             return false;
112488:     }
112488: 
112488:     // Compute the maximum possible index. No overflow check is needed when
112488:     // max > 0. We can only wraparound to a negative number, which will test as
112488:     // larger than all nonnegative numbers in the unsigned comparison, and the
112488:     // length is required to be nonnegative (else testing a negative length
112488:     // would succeed on any nonnegative index).
112488:     if (max != 0) {
112488:         masm.add32(Imm32(max), temp);
112488:         if (max < 0 && !bailoutIf(Assembler::Overflow, lir->snapshot()))
112488:             return false;
112488:     }
112488: 
112488:     masm.cmp32(ToRegister(lir->length()), temp);
112488:     return bailoutIf(Assembler::BelowOrEqual, lir->snapshot());
112488: }
112488: 
112488: bool
112488: CodeGenerator::visitBoundsCheckLower(LBoundsCheckLower *lir)
112488: {
112488:     int32 min = lir->mir()->minimum();
112488:     masm.cmp32(ToRegister(lir->index()), Imm32(min));
112488:     return bailoutIf(Assembler::LessThan, lir->snapshot());
112488: }
112488: 
112524: class OutOfLineStoreElementHole : public OutOfLineCodeBase<CodeGenerator>
112524: {
112524:     LInstruction *ins_;
112524:     Label rejoinStore_;
112524: 
112524:   public:
112524:     OutOfLineStoreElementHole(LInstruction *ins)
112524:       : ins_(ins)
112524:     {
112524:         JS_ASSERT(ins->isStoreElementHoleV() || ins->isStoreElementHoleT());
112524:     }
112524: 
112524:     bool accept(CodeGenerator *codegen) {
112524:         return codegen->visitOutOfLineStoreElementHole(this);
112524:     }
112524:     LInstruction *ins() const {
112524:         return ins_;
112524:     }
112524:     Label *rejoinStore() {
112524:         return &rejoinStore_;
112524:     }
112524: };
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementT(LStoreElementT *store)
112524: {
112726:     if (store->mir()->needsBarrier())
112726:        emitPreBarrier(ToRegister(store->elements()), store->index(), store->mir()->elementType());
112726: 
112524:     storeElementTyped(store->value(), store->mir()->value()->type(), store->mir()->elementType(),
112524:                       ToRegister(store->elements()), store->index());
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementV(LStoreElementV *lir)
112524: {
112524:     const ValueOperand value = ToValue(lir, LStoreElementV::Value);
112524:     Register elements = ToRegister(lir->elements());
112524: 
112726:     if (lir->mir()->needsBarrier())
112726:         emitPreBarrier(elements, lir->index(), MIRType_Value);
112726: 
112524:     if (lir->index()->isConstant())
112524:         masm.storeValue(value, Address(elements, ToInt32(lir->index()) * sizeof(js::Value)));
112524:     else
112524:         masm.storeValue(value, BaseIndex(elements, ToRegister(lir->index()), TimesEight));
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementHoleT(LStoreElementHoleT *lir)
112524: {
112524:     OutOfLineStoreElementHole *ool = new OutOfLineStoreElementHole(lir);
112524:     if (!addOutOfLineCode(ool))
112524:         return false;
112524: 
112524:     Register elements = ToRegister(lir->elements());
112524:     const LAllocation *index = lir->index();
112524: 
112524:     // OOL path if index >= initializedLength.
112524:     Address initLength(elements, ObjectElements::offsetOfInitializedLength());
112524:     masm.branchKey(Assembler::BelowOrEqual, initLength, ToInt32Key(index), ool->entry());
112524: 
112726:     if (lir->mir()->needsBarrier())
112726:         emitPreBarrier(elements, index, lir->mir()->elementType());
112726: 
112524:     masm.bind(ool->rejoinStore());
112524:     storeElementTyped(lir->value(), lir->mir()->value()->type(), lir->mir()->elementType(),
112524:                       elements, index);
112524: 
112524:     masm.bind(ool->rejoin());
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitStoreElementHoleV(LStoreElementHoleV *lir)
112524: {
112524:     OutOfLineStoreElementHole *ool = new OutOfLineStoreElementHole(lir);
112524:     if (!addOutOfLineCode(ool))
112524:         return false;
112524: 
112524:     Register elements = ToRegister(lir->elements());
112524:     const LAllocation *index = lir->index();
112524:     const ValueOperand value = ToValue(lir, LStoreElementHoleV::Value);
112524: 
112524:     // OOL path if index >= initializedLength.
112524:     Address initLength(elements, ObjectElements::offsetOfInitializedLength());
112524:     masm.branchKey(Assembler::BelowOrEqual, initLength, ToInt32Key(index), ool->entry());
112524: 
112726:     if (lir->mir()->needsBarrier())
112726:         emitPreBarrier(elements, index, lir->mir()->elementType());
112726: 
112524:     masm.bind(ool->rejoinStore());
112524:     if (lir->index()->isConstant())
112524:         masm.storeValue(value, Address(elements, ToInt32(lir->index()) * sizeof(js::Value)));
112524:     else
112524:         masm.storeValue(value, BaseIndex(elements, ToRegister(lir->index()), TimesEight));
112524: 
112524:     masm.bind(ool->rejoin());
112524:     return true;
112524: }
112524: 
112524: bool
112524: CodeGenerator::visitOutOfLineStoreElementHole(OutOfLineStoreElementHole *ool)
112524: {
112524:     Register object, elements;
112524:     LInstruction *ins = ool->ins();
112524:     const LAllocation *index;
112524:     MIRType valueType;
112524:     ConstantOrRegister value;
112524: 
112524:     if (ins->isStoreElementHoleV()) {
112524:         LStoreElementHoleV *store = ins->toStoreElementHoleV();
112524:         object = ToRegister(store->object());
112524:         elements = ToRegister(store->elements());
112524:         index = store->index();
112524:         valueType = store->mir()->value()->type();
112524:         value = TypedOrValueRegister(ToValue(store, LStoreElementHoleV::Value));
112524:     } else {
112524:         LStoreElementHoleT *store = ins->toStoreElementHoleT();
112524:         object = ToRegister(store->object());
112524:         elements = ToRegister(store->elements());
112524:         index = store->index();
112524:         valueType = store->mir()->value()->type();
112524:         if (store->value()->isConstant())
112524:             value = ConstantOrRegister(*store->value()->toConstant());
112524:         else
112524:             value = TypedOrValueRegister(valueType, ToAnyRegister(store->value()));
112524:     }
112524: 
112524:     // If index == initializedLength, try to bump the initialized length inline.
112524:     // If index > initializedLength, call a stub. Note that this relies on the
112524:     // condition flags sticking from the incoming branch.
112524:     Label callStub;
112524:     masm.j(Assembler::NotEqual, &callStub);
112524: 
112524:     Int32Key key = ToInt32Key(index);
112524: 
112524:     // Check array capacity.
112524:     masm.branchKey(Assembler::BelowOrEqual, Address(elements, ObjectElements::offsetOfCapacity()),
112524:                    key, &callStub);
112524: 
112524:     // Update initialized length. The capacity guard above ensures this won't overflow,
112524:     // due to NELEMENTS_LIMIT.
112524:     masm.bumpKey(&key, 1);
112524:     masm.storeKey(key, Address(elements, ObjectElements::offsetOfInitializedLength()));
112524: 
112524:     // Update length if length < initializedLength.
112524:     Label dontUpdate;
112524:     masm.branchKey(Assembler::AboveOrEqual, Address(elements, ObjectElements::offsetOfLength()),
112524:                    key, &dontUpdate);
112524:     masm.storeKey(key, Address(elements, ObjectElements::offsetOfLength()));
112524:     masm.bind(&dontUpdate);
112524: 
112524:     masm.bumpKey(&key, -1);
112524: 
112524:     if (ins->isStoreElementHoleT() && valueType != MIRType_Double) {
112524:         // The inline path for StoreElementHoleT does not always store the type tag,
112524:         // so we do the store on the OOL path. We use MIRType_None for the element type
112524:         // so that storeElementTyped will always store the type tag.
112524:         storeElementTyped(ins->toStoreElementHoleT()->value(), valueType, MIRType_None, elements,
112524:                           index);
112524:         masm.jump(ool->rejoin());
112524:     } else {
112524:         // Jump to the inline path where we will store the value.
112524:         masm.jump(ool->rejoinStore());
112524:     }
112524: 
112524:     masm.bind(&callStub);
112524:     saveLive(ins);
112524: 
112780:     typedef bool (*pf)(JSContext *, JSObject *, const Value &, const Value &, JSBool strict);
112524:     static const VMFunction Info = FunctionInfo<pf>(SetObjectElement);
112524: 
112780:     pushArg(Imm32(current->mir()->strictModeCode()));
112524:     pushArg(value);
112524:     if (index->isConstant())
112524:         pushArg(*index->toConstant());
112524:     else
112524:         pushArg(TypedOrValueRegister(MIRType_Int32, ToAnyRegister(index)));
112524:     pushArg(object);
112524:     if (!callVM(Info, ins))
112524:         return false;
112524: 
112524:     restoreLive(ins);
112524:     masm.jump(ool->rejoin());
112524:     return true;
112524: }
112524: 
112488: bool
112949: CodeGenerator::emitArrayPopShift(LInstruction *lir, const MArrayPopShift *mir, Register obj,
112949:                                  Register elementsTemp, Register lengthTemp, TypedOrValueRegister out)
112949: {
112949:     OutOfLineCode *ool;
112949:     typedef bool (*pf)(JSContext *, JSObject *, Value *);
112949: 
112949:     if (mir->mode() == MArrayPopShift::Pop) {
112949:         static const VMFunction Info = FunctionInfo<pf>(ion::ArrayPopDense);
112949:         ool = oolCallVM(Info, lir, (ArgList(), obj), StoreValueTo(out));
112949:         if (!ool)
112949:             return false;
112949:     } else {
112949:         JS_ASSERT(mir->mode() == MArrayPopShift::Shift);
112949:         static const VMFunction Info = FunctionInfo<pf>(ion::ArrayShiftDense);
112949:         ool = oolCallVM(Info, lir, (ArgList(), obj), StoreValueTo(out));
112949:         if (!ool)
112949:             return false;
112949:     }
112949: 
112949:     // Load elements and length.
112949:     masm.loadPtr(Address(obj, JSObject::offsetOfElements()), elementsTemp);
112949:     masm.load32(Address(elementsTemp, ObjectElements::offsetOfLength()), lengthTemp);
112949: 
112949:     // VM call if length != initializedLength.
112949:     Int32Key key = Int32Key(lengthTemp);
112949:     Address initLength(elementsTemp, ObjectElements::offsetOfInitializedLength());
112949:     masm.branchKey(Assembler::NotEqual, initLength, key, ool->entry());
112949: 
112949:     // Test for length != 0. On zero length either take a VM call or generate
112949:     // an undefined value, depending on whether the call is known to produce
112949:     // undefined.
112949:     Label done;
112949:     if (mir->maybeUndefined()) {
112949:         Label notEmpty;
112949:         masm.branchTest32(Assembler::NonZero, lengthTemp, lengthTemp, &notEmpty);
112949:         masm.moveValue(UndefinedValue(), out.valueReg());
112949:         masm.jump(&done);
112949:         masm.bind(&notEmpty);
112949:     } else {
112949:         masm.branchTest32(Assembler::Zero, lengthTemp, lengthTemp, ool->entry());
112949:     }
112949: 
112949:     masm.bumpKey(&key, -1);
112949: 
112949:     if (mir->mode() == MArrayPopShift::Pop) {
112949:         masm.loadElementTypedOrValue(BaseIndex(elementsTemp, lengthTemp, TimesEight), out,
112949:                                      mir->needsHoleCheck(), ool->entry());
112949:     } else {
112949:         JS_ASSERT(mir->mode() == MArrayPopShift::Shift);
112949:         masm.loadElementTypedOrValue(Address(elementsTemp, 0), out, mir->needsHoleCheck(),
112949:                                      ool->entry());
112949:     }
112949: 
112949:     masm.store32(lengthTemp, Address(elementsTemp, ObjectElements::offsetOfLength()));
112949:     masm.store32(lengthTemp, Address(elementsTemp, ObjectElements::offsetOfInitializedLength()));
112949: 
112949:     if (mir->mode() == MArrayPopShift::Shift) {
112949:         // Don't save the temp registers.
112949:         RegisterSet temps;
112949:         temps.add(elementsTemp);
112949:         temps.add(lengthTemp);
112949: 
112949:         saveVolatile(temps);
112949:         masm.setupUnalignedABICall(1, lengthTemp);
112949:         masm.passABIArg(obj);
112949:         masm.callWithABI(JS_FUNC_TO_DATA_PTR(void *, js::ArrayShiftMoveElements));
112949:         restoreVolatile(temps);
112949:     }
112949: 
112949:     masm.bind(&done);
112949:     masm.bind(ool->rejoin());
112949:     return true;
112949: }
112949: 
112949: bool
112949: CodeGenerator::visitArrayPopShiftV(LArrayPopShiftV *lir)
112949: {
112949:     Register obj = ToRegister(lir->object());
112949:     Register elements = ToRegister(lir->temp0());
112949:     Register length = ToRegister(lir->temp1());
112949:     TypedOrValueRegister out(ToOutValue(lir));
112949:     return emitArrayPopShift(lir, lir->mir(), obj, elements, length, out);
112949: }
112949: 
112949: bool
112949: CodeGenerator::visitArrayPopShiftT(LArrayPopShiftT *lir)
112949: {
112949:     Register obj = ToRegister(lir->object());
112949:     Register elements = ToRegister(lir->temp0());
112949:     Register length = ToRegister(lir->temp1());
112949:     TypedOrValueRegister out(lir->mir()->type(), ToAnyRegister(lir->output()));
112949:     return emitArrayPopShift(lir, lir->mir(), obj, elements, length, out);
112949: }
112949: 
112949: bool
112950: CodeGenerator::emitArrayPush(LInstruction *lir, const MArrayPush *mir, Register obj,
112950:                              ConstantOrRegister value, Register elementsTemp, Register length)
112950: {
112950:     typedef bool (*pf)(JSContext *, JSObject *, const Value &, uint32_t *);
112950:     static const VMFunction Info = FunctionInfo<pf>(ion::ArrayPushDense);
112950:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj, value), StoreRegisterTo(length));
112950:     if (!ool)
112950:         return false;
112950: 
112950:     // Load elements and length.
112950:     masm.loadPtr(Address(obj, JSObject::offsetOfElements()), elementsTemp);
112950:     masm.load32(Address(elementsTemp, ObjectElements::offsetOfLength()), length);
112950: 
112950:     Int32Key key = Int32Key(length);
112950:     Address initLength(elementsTemp, ObjectElements::offsetOfInitializedLength());
112950:     Address capacity(elementsTemp, ObjectElements::offsetOfCapacity());
112950: 
112950:     // Guard length == initializedLength.
112950:     masm.branchKey(Assembler::NotEqual, initLength, key, ool->entry());
112950: 
112950:     // Guard length < capacity.
112950:     masm.branchKey(Assembler::BelowOrEqual, capacity, key, ool->entry());
112950: 
112950:     masm.storeConstantOrRegister(value, BaseIndex(elementsTemp, length, TimesEight));
112950: 
112950:     masm.bumpKey(&key, 1);
112950:     masm.store32(length, Address(elementsTemp, ObjectElements::offsetOfLength()));
112950:     masm.store32(length, Address(elementsTemp, ObjectElements::offsetOfInitializedLength()));
112950: 
112950:     masm.bind(ool->rejoin());
112950:     return true;
112950: }
112950: 
112950: bool
112950: CodeGenerator::visitArrayPushV(LArrayPushV *lir)
112950: {
112950:     Register obj = ToRegister(lir->object());
112950:     Register elementsTemp = ToRegister(lir->temp());
112950:     Register length = ToRegister(lir->output());
112950:     ConstantOrRegister value = TypedOrValueRegister(ToValue(lir, LArrayPushV::Value));
112950:     return emitArrayPush(lir, lir->mir(), obj, value, elementsTemp, length);
112950: }
112950: 
112950: bool
112950: CodeGenerator::visitArrayPushT(LArrayPushT *lir)
112950: {
112950:     Register obj = ToRegister(lir->object());
112950:     Register elementsTemp = ToRegister(lir->temp());
112950:     Register length = ToRegister(lir->output());
112950:     ConstantOrRegister value;
112950:     if (lir->value()->isConstant())
112950:         value = ConstantOrRegister(*lir->value()->toConstant());
112950:     else
112950:         value = TypedOrValueRegister(lir->mir()->value()->type(), ToAnyRegister(lir->value()));
112950:     return emitArrayPush(lir, lir->mir(), obj, value, elementsTemp, length);
112950: }
112950: 
112950: bool
112663: CodeGenerator::visitCallIteratorStart(LCallIteratorStart *lir)
112663: {
112984:     typedef JSObject *(*pf)(JSContext *, HandleObject, uint32_t);
112663:     static const VMFunction Info = FunctionInfo<pf>(GetIteratorObject);
112663: 
112663:     pushArg(Imm32(lir->mir()->flags()));
112839:     pushArg(ToRegister(lir->object()));
112663:     return callVM(Info, lir);
112663: }
112663: 
112663: bool
112839: CodeGenerator::visitIteratorStart(LIteratorStart *lir)
112663: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register output = ToRegister(lir->output());
112839: 
112839:     uint32_t flags = lir->mir()->flags();
112839: 
112984:     typedef JSObject *(*pf)(JSContext *, HandleObject, uint32_t);
112839:     static const VMFunction Info = FunctionInfo<pf>(GetIteratorObject);
112839: 
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj, Imm32(flags)), StoreRegisterTo(output));
112839:     if (!ool)
112839:         return false;
112839: 
112839:     const Register temp1 = ToRegister(lir->temp1());
112839:     const Register temp2 = ToRegister(lir->temp2());
112839:     const Register niTemp = ToRegister(lir->temp3()); // Holds the NativeIterator object.
112839: 
112839:     // Iterators other than for-in should use LCallIteratorStart.
112839:     JS_ASSERT(flags == JSITER_ENUMERATE);
112839: 
112839:     // Fetch the most recent iterator and ensure it's not NULL.
113019:     masm.loadPtr(AbsoluteAddress(&gen->cx->runtime->nativeIterCache.last), output);
112839:     masm.branchTestPtr(Assembler::Zero, output, output, ool->entry());
112839: 
112839:     // Load NativeIterator.
112839:     masm.loadObjPrivate(output, JSObject::ITER_CLASS_NFIXED_SLOTS, niTemp);
112839: 
112839:     // Ensure the |active| and |unreusable| bits are not set.
112839:     masm.branchTest32(Assembler::NonZero, Address(niTemp, offsetof(NativeIterator, flags)),
112839:                       Imm32(JSITER_ACTIVE|JSITER_UNREUSABLE), ool->entry());
112839: 
112839:     // Load the iterator's shape array.
112839:     masm.loadPtr(Address(niTemp, offsetof(NativeIterator, shapes_array)), temp2);
112839: 
112839:     // Compare shape of object with the first shape.
112839:     masm.loadObjShape(obj, temp1);
112839:     masm.branchPtr(Assembler::NotEqual, Address(temp2, 0), temp1, ool->entry());
112839: 
112839:     // Compare shape of object's prototype with the second shape.
112839:     masm.loadObjProto(obj, temp1);
112839:     masm.loadObjShape(temp1, temp1);
112839:     masm.branchPtr(Assembler::NotEqual, Address(temp2, sizeof(Shape *)), temp1, ool->entry());
112839: 
112839:     // Ensure the object's prototype's prototype is NULL. The last native iterator
112839:     // will always have a prototype chain length of one (i.e. it must be a plain
112839:     // object), so we do not need to generate a loop here.
112839:     masm.loadObjProto(obj, temp1);
112839:     masm.loadObjProto(temp1, temp1);
112839:     masm.branchTestPtr(Assembler::NonZero, temp1, temp1, ool->entry());
112839: 
112839:     // Write barrier for stores to the iterator. We only need to take a write
112839:     // barrier if NativeIterator::obj is actually going to change.
112839:     if (gen->cx->compartment->needsBarrier()) {
112839:         masm.branchPtr(Assembler::NotEqual, Address(niTemp, offsetof(NativeIterator, obj)),
112839:                        obj, ool->entry());
112839:     }
112839: 
112839:     // Mark iterator as active.
112839:     masm.storePtr(obj, Address(niTemp, offsetof(NativeIterator, obj)));
112839:     masm.or32(Imm32(JSITER_ACTIVE), Address(niTemp, offsetof(NativeIterator, flags)));
112839: 
112839:     // Chain onto the active iterator stack.
112839:     masm.loadJSContext(temp1);
112839:     masm.loadPtr(Address(temp1, offsetof(JSContext, enumerators)), temp2);
112839:     masm.storePtr(temp2, Address(niTemp, offsetof(NativeIterator, next)));
112839:     masm.storePtr(output, Address(temp1, offsetof(JSContext, enumerators)));
112839: 
112839:     masm.bind(ool->rejoin());
112839:     return true;
112839: }
112839: 
112839: static void
112839: LoadNativeIterator(MacroAssembler &masm, Register obj, Register dest, Label *failures)
112839: {
112839:     JS_ASSERT(obj != dest);
112839: 
112839:     // Test class.
112839:     masm.branchTestObjClass(Assembler::NotEqual, obj, dest, &IteratorClass, failures);
112839: 
112839:     // Load NativeIterator object.
112839:     masm.loadObjPrivate(obj, JSObject::ITER_CLASS_NFIXED_SLOTS, dest);
112839: }
112839: 
112839: bool
112839: CodeGenerator::visitIteratorNext(LIteratorNext *lir)
112839: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register temp = ToRegister(lir->temp());
112839:     const ValueOperand output = ToOutValue(lir);
112839: 
112663:     typedef bool (*pf)(JSContext *, JSObject *, Value *);
112663:     static const VMFunction Info = FunctionInfo<pf>(js_IteratorNext);
112663: 
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj), StoreValueTo(output));
112839:     if (!ool)
112663:         return false;
112663: 
112839:     LoadNativeIterator(masm, obj, temp, ool->entry());
112839: 
113074:     masm.branchTest32(Assembler::NonZero, Address(temp, offsetof(NativeIterator, flags)),
113074:                       Imm32(JSITER_FOREACH), ool->entry());
113074: 
112839:     // Get cursor, next string.
112839:     masm.loadPtr(Address(temp, offsetof(NativeIterator, props_cursor)), output.scratchReg());
112839:     masm.loadPtr(Address(output.scratchReg(), 0), output.scratchReg());
112839:     masm.tagValue(JSVAL_TYPE_STRING, output.scratchReg(), output);
112839: 
112839:     // Increase the cursor.
112839:     masm.addPtr(Imm32(sizeof(JSString *)), Address(temp, offsetof(NativeIterator, props_cursor)));
112839: 
112839:     masm.bind(ool->rejoin());
112663:     return true;
112663: }
112663: 
112663: bool
112839: CodeGenerator::visitIteratorMore(LIteratorMore *lir)
112663: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register output = ToRegister(lir->output());
112839:     const Register temp = ToRegister(lir->temp());
112839: 
112984:     typedef bool (*pf)(JSContext *, HandleObject, JSBool *);
112839:     static const VMFunction Info = FunctionInfo<pf>(ion::IteratorMore);
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj), StoreRegisterTo(output));
112839:     if (!ool)
112839:         return false;
112839: 
112839:     LoadNativeIterator(masm, obj, output, ool->entry());
112839: 
113074:     masm.branchTest32(Assembler::NonZero, Address(output, offsetof(NativeIterator, flags)),
113074:                       Imm32(JSITER_FOREACH), ool->entry());
113074: 
112839:     // Set output to true if props_cursor < props_end.
112839:     masm.loadPtr(Address(output, offsetof(NativeIterator, props_end)), temp);
112839:     masm.cmpPtr(Address(output, offsetof(NativeIterator, props_cursor)), temp);
112839:     emitSet(Assembler::LessThan, output);
112839: 
112839:     masm.bind(ool->rejoin());
112839:     return true;
112839: }
112839: 
112839: bool
112839: CodeGenerator::visitIteratorEnd(LIteratorEnd *lir)
112839: {
112839:     const Register obj = ToRegister(lir->object());
112839:     const Register temp1 = ToRegister(lir->temp1());
112839:     const Register temp2 = ToRegister(lir->temp2());
112839: 
112663:     typedef bool (*pf)(JSContext *, JSObject *);
112971:     static const VMFunction Info = FunctionInfo<pf>(CloseIterator);
112663: 
112839:     OutOfLineCode *ool = oolCallVM(Info, lir, (ArgList(), obj), StoreNothing());
112839:     if (!ool)
112839:         return false;
112839: 
112839:     LoadNativeIterator(masm, obj, temp1, ool->entry());
112839: 
113074:     masm.branchTest32(Assembler::Zero, Address(temp1, offsetof(NativeIterator, flags)),
113074:                       Imm32(JSITER_ENUMERATE), ool->entry());
113074: 
112839:     // Clear active bit.
112839:     masm.and32(Imm32(~JSITER_ACTIVE), Address(temp1, offsetof(NativeIterator, flags)));
112839: 
112839:     // Reset property cursor.
112839:     masm.loadPtr(Address(temp1, offsetof(NativeIterator, props_array)), temp2);
112839:     masm.storePtr(temp2, Address(temp1, offsetof(NativeIterator, props_cursor)));
112839: 
112839:     // Advance enumerators list.
112839:     masm.loadJSContext(temp2);
112839:     masm.loadPtr(Address(temp1, offsetof(NativeIterator, next)), temp1);
112839:     masm.storePtr(temp1, Address(temp2, offsetof(JSContext, enumerators)));
112839: 
112839:     masm.bind(ool->rejoin());
112839:     return true;
112663: }
112663: 
112663: bool
111930: CodeGenerator::generate()
111930: {
111935:     JSContext *cx = gen->cx;
111935: 
112331:     if (!safepoints_.init(graph.localSlotCount()))
112331:         return false;
112331: 
112108:     // Before generating any code, we generate type checks for all parameters.
112108:     // This comes before deoptTable_, because we can't use deopt tables without
112108:     // creating the actual frame.
112108:     if (!generateArgumentsChecks())
112108:         return false;
112108: 
111935:     if (frameClass_ != FrameSizeClass::None()) {
111935:         deoptTable_ = cx->compartment->ionCompartment()->getBailoutTable(cx, frameClass_);
111935:         if (!deoptTable_)
111935:             return false;
111935:     }
111935: 
111930:     if (!generatePrologue())
111930:         return false;
111930:     if (!generateBody())
111930:         return false;
111930:     if (!generateEpilogue())
111930:         return false;
112505:     if (!generateInvalidateEpilogue())
112505:         return false;
111930:     if (!generateOutOfLineCode())
111930:         return false;
111930: 
111935:     if (masm.oom())
111935:         return false;
111935: 
111930:     Linker linker(masm);
111935:     IonCode *code = linker.newCode(cx);
111930:     if (!code)
111930:         return false;
111930: 
112693:     // We encode safepoints after the OSI-point offsets have been determined.
112693:     encodeSafepoints();
112693: 
112139:     JSScript *script = gen->info().script();
112139:     JS_ASSERT(!script->ion);
111935: 
112505:     uint32 scriptFrameSize = frameClass_ == FrameSizeClass::None()
112505:                            ? frameDepth_
112505:                            : FrameSizeClass::FromDepth(frameDepth_).frameSize();
112505: 
112505:     script->ion = IonScript::New(cx, graph.localSlotCount(), scriptFrameSize, snapshots_.size(),
112331:                                  bailouts_.length(), graph.numConstants(),
112505:                                  safepointIndices_.length(), osiIndices_.length(),
112505:                                  cacheList_.length(), safepoints_.size());
112139:     if (!script->ion)
111930:         return false;
112693:     invalidateEpilogueData_.fixup(&masm);
112505:     Assembler::patchDataWithValueCheck(CodeLocationLabel(code, invalidateEpilogueData_),
112505:                                        ImmWord(uintptr_t(script->ion)),
112505:                                        ImmWord(uintptr_t(-1)));
112505: 
112310:     IonSpew(IonSpew_Codegen, "Created IonScript %p (raw %p)",
112310:             (void *) script->ion, (void *) code->raw());
112206: 
112505:     script->ion->setInvalidationEpilogueDataOffset(invalidateEpilogueData_.offset());
112219:     script->ion->setOsrPc(gen->info().osrPc());
112219:     script->ion->setOsrEntryOffset(getOsrEntryOffset());
112739:     ptrdiff_t real_invalidate = masm.actualOffset(invalidate_.offset());
112693:     script->ion->setInvalidationEpilogueOffset(real_invalidate);
112219: 
112139:     script->ion->setMethod(code);
112139:     script->ion->setDeoptTable(deoptTable_);
112331:     if (snapshots_.size())
112139:         script->ion->copySnapshots(&snapshots_);
111935:     if (bailouts_.length())
112139:         script->ion->copyBailoutTable(&bailouts_[0]);
111975:     if (graph.numConstants())
112139:         script->ion->copyConstants(graph.constantPool());
112505:     if (safepointIndices_.length())
112505:         script->ion->copySafepointIndices(&safepointIndices_[0], masm);
112505:     if (osiIndices_.length())
112693:         script->ion->copyOsiIndices(&osiIndices_[0], masm);
112315:     if (cacheList_.length())
112482:         script->ion->copyCacheEntries(&cacheList_[0], masm);
112331:     if (safepoints_.size())
112331:         script->ion->copySafepoints(&safepoints_);
111975: 
111975:     linkAbsoluteLabels();
111975:     
111930:     return true;
111930: }
111930: 
112264: // An out-of-line path to convert a boxed int32 to a double.
112292: class OutOfLineUnboxDouble : public OutOfLineCodeBase<CodeGenerator>
112264: {
112264:     LUnboxDouble *unboxDouble_;
112264: 
112264:   public:
112264:     OutOfLineUnboxDouble(LUnboxDouble *unboxDouble)
112264:       : unboxDouble_(unboxDouble)
112264:     { }
112264: 
112264:     bool accept(CodeGenerator *codegen) {
112264:         return codegen->visitOutOfLineUnboxDouble(this);
112264:     }
112264: 
112264:     LUnboxDouble *unboxDouble() const {
112264:         return unboxDouble_;
112264:     }
112264: };
112264: 
112264: bool
112264: CodeGenerator::visitUnboxDouble(LUnboxDouble *lir)
112264: {
112264:     const ValueOperand box = ToValue(lir, LUnboxDouble::Input);
112264:     const LDefinition *result = lir->output();
112264: 
112264:     // Out-of-line path to convert int32 to double or bailout
112264:     // if this instruction is fallible.
112264:     OutOfLineUnboxDouble *ool = new OutOfLineUnboxDouble(lir);
112264:     if (!addOutOfLineCode(ool))
112264:         return false;
112264: 
112264:     masm.branchTestDouble(Assembler::NotEqual, box, ool->entry());
112264:     masm.unboxDouble(box, ToFloatRegister(result));
112264:     masm.bind(ool->rejoin());
112264:     return true;
112264: }
112264: 
112264: bool
112264: CodeGenerator::visitOutOfLineUnboxDouble(OutOfLineUnboxDouble *ool)
112264: {
112264:     LUnboxDouble *ins = ool->unboxDouble();
112264:     const ValueOperand value = ToValue(ins, LUnboxDouble::Input);
112264: 
112264:     if (ins->mir()->fallible()) {
112264:         Assembler::Condition cond = masm.testInt32(Assembler::NotEqual, value);
112264:         if (!bailoutIf(cond, ins->snapshot()))
112264:             return false;
112264:     }
112264:     masm.int32ValueToDouble(value, ToFloatRegister(ins->output()));
112264:     masm.jump(ool->rejoin());
112264:     return true;
112264: }
112292: 
112984: typedef bool (*GetPropertyOrNameFn)(JSContext *, HandleObject, HandlePropertyName, Value *);
112401: 
112339: bool
112401: CodeGenerator::visitCallGetProperty(LCallGetProperty *lir)
112339: {
112706:     typedef bool (*pf)(JSContext *, const Value &, PropertyName *, Value *);
112706:     static const VMFunction Info = FunctionInfo<pf>(GetProperty);
112339: 
112401:     pushArg(ImmGCPtr(lir->mir()->atom()));
112706:     pushArg(ToValue(lir, LCallGetProperty::Value));
112401:     return callVM(Info, lir);
112401: }
112401: 
112401: bool
112401: CodeGenerator::visitCallGetName(LCallGetName *lir)
112401: {
112401:     static const VMFunction Info = FunctionInfo<GetPropertyOrNameFn>(GetScopeName);
112401: 
112401:     pushArg(ImmGCPtr(lir->mir()->atom()));
112401:     pushArg(ToRegister(lir->getOperand(0)));
112401:     return callVM(Info, lir);
112401: }
112401: 
112401: bool
112401: CodeGenerator::visitCallGetNameTypeOf(LCallGetNameTypeOf *lir)
112401: {
112401:     static const VMFunction Info = FunctionInfo<GetPropertyOrNameFn>(GetScopeNameForTypeOf);
112401: 
112401:     pushArg(ImmGCPtr(lir->mir()->atom()));
112401:     pushArg(ToRegister(lir->getOperand(0)));
112401:     return callVM(Info, lir);
112339: }
112339: 
112467: bool
112486: CodeGenerator::visitCallGetElement(LCallGetElement *lir)
112486: {
112486:     typedef bool (*pf)(JSContext *, const Value &, const Value &, Value *);
112486:     static const VMFunction GetElementInfo = FunctionInfo<pf>(js::GetElement);
112836:     static const VMFunction CallElementInfo = FunctionInfo<pf>(js::CallElement);
112486: 
112486:     pushArg(ToValue(lir, LCallGetElement::RhsInput));
112486:     pushArg(ToValue(lir, LCallGetElement::LhsInput));
112836: 
112836:     JSOp op = JSOp(*lir->mir()->resumePoint()->pc());
112836: 
112836:     if (op == JSOP_GETELEM) {
112486:         return callVM(GetElementInfo, lir);
112836:     } else {
112836:         JS_ASSERT(op == JSOP_CALLELEM);
112836:         return callVM(CallElementInfo, lir);
112836:     }
112486: }
112486: 
112486: bool
112487: CodeGenerator::visitCallSetElement(LCallSetElement *lir)
112487: {
112780:     typedef bool (*pf)(JSContext *, JSObject *, const Value &, const Value &, JSBool strict);
112487:     static const VMFunction SetObjectElementInfo = FunctionInfo<pf>(js::SetObjectElement);
112487: 
112780:     pushArg(Imm32(current->mir()->strictModeCode()));
112487:     pushArg(ToValue(lir, LCallSetElement::Value));
112487:     pushArg(ToValue(lir, LCallSetElement::Index));
112487:     pushArg(ToRegister(lir->getOperand(0)));
112487:     return callVM(SetObjectElementInfo, lir);
112487: }
112487: 
112487: bool
112467: CodeGenerator::visitLoadFixedSlotV(LLoadFixedSlotV *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467:     ValueOperand result = GetValueOutput(ins);
112467: 
112467:     masm.loadValue(Address(obj, JSObject::getFixedSlotOffset(slot)), result);
112467:     return true;
112467: }
112467: 
112467: bool
112467: CodeGenerator::visitLoadFixedSlotT(LLoadFixedSlotT *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467:     AnyRegister result = ToAnyRegister(ins->getDef(0));
112467: 
112467:     masm.loadUnboxedValue(Address(obj, JSObject::getFixedSlotOffset(slot)), result);
112467:     return true;
112467: }
112467: 
112467: bool
112467: CodeGenerator::visitStoreFixedSlotV(LStoreFixedSlotV *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467: 
112467:     const ValueOperand value = ToValue(ins, LStoreFixedSlotV::Value);
112726: 
112726:     Address address(obj, JSObject::getFixedSlotOffset(slot));
112726:     if (ins->mir()->needsBarrier())
113010:         masm.emitPreBarrier(address, MIRType_Value);
112726: 
112726:     masm.storeValue(value, address);
112467: 
112467:     return true;
112467: }
112467: 
112467: bool
112467: CodeGenerator::visitStoreFixedSlotT(LStoreFixedSlotT *ins)
112467: {
112467:     const Register obj = ToRegister(ins->getOperand(0));
112467:     size_t slot = ins->mir()->slot();
112467: 
112467:     const LAllocation *value = ins->value();
112467:     MIRType valueType = ins->mir()->value()->type();
112467: 
112467:     ConstantOrRegister nvalue = value->isConstant()
112467:                               ? ConstantOrRegister(*value->toConstant())
112467:                               : TypedOrValueRegister(valueType, ToAnyRegister(value));
112467: 
112726:     Address address(obj, JSObject::getFixedSlotOffset(slot));
112726:     if (ins->mir()->needsBarrier())
113010:         masm.emitPreBarrier(address, MIRType_Value);
112726: 
112726:     masm.storeConstantOrRegister(nvalue, address);
112467: 
112467:     return true;
112467: }
112467: 
112445: // An out-of-line path to call an inline cache function.
112445: class OutOfLineCache : public OutOfLineCodeBase<CodeGenerator>
112315: {
112315:     LInstruction *ins;
112315: 
112315:     CodeOffsetJump inlineJump;
112315:     CodeOffsetLabel inlineLabel;
112315: 
112315:   public:
112445:     OutOfLineCache(LInstruction *ins)
112315:       : ins(ins)
112445:     {}
112315: 
112315:     void setInlineJump(CodeOffsetJump jump, CodeOffsetLabel label) {
112315:         inlineJump = jump;
112315:         inlineLabel = label;
112315:     }
112315: 
112315:     CodeOffsetJump getInlineJump() const {
112315:         return inlineJump;
112315:     }
112315: 
112315:     CodeOffsetLabel getInlineLabel() const {
112315:         return inlineLabel;
112315:     }
112315: 
112315:     bool accept(CodeGenerator *codegen) {
112445:         switch (ins->op()) {
112445:           case LInstruction::LOp_GetPropertyCacheT:
112445:           case LInstruction::LOp_GetPropertyCacheV:
112445:             return codegen->visitOutOfLineCacheGetProperty(this);
112859:           case LInstruction::LOp_GetElementCacheV:
112859:             return codegen->visitOutOfLineGetElementCache(this);
112676:           case LInstruction::LOp_SetPropertyCacheT:
112676:           case LInstruction::LOp_SetPropertyCacheV:
112676:             return codegen->visitOutOfLineSetPropertyCache(this);
112766:           case LInstruction::LOp_BindNameCache:
112766:             return codegen->visitOutOfLineBindNameCache(this);
112445:           default:
112445:             JS_NOT_REACHED("Bad instruction");
112445:             return false;
112445:         }
112315:     }
112315: 
112315:     LInstruction *cache() {
112315:         return ins;
112315:     }
112315: };
112315: 
112315: bool
112445: CodeGenerator::visitCache(LInstruction *ins)
112315: {
112445:     OutOfLineCache *ool = new OutOfLineCache(ins);
112315:     if (!addOutOfLineCode(ool))
112315:         return false;
112315: 
112315:     CodeOffsetJump jump = masm.jumpWithPatch(ool->entry());
112315:     CodeOffsetLabel label = masm.labelForPatch();
112315:     masm.bind(ool->rejoin());
112315: 
112315:     ool->setInlineJump(jump, label);
112315:     return true;
112315: }
112315: 
112315: bool
112445: CodeGenerator::visitOutOfLineCacheGetProperty(OutOfLineCache *ool)
112315: {
112315:     Register objReg = ToRegister(ool->cache()->getOperand(0));
112453:     RegisterSet liveRegs = ool->cache()->safepoint()->liveRegs();
112315: 
112315:     LInstruction *ins_ = ool->cache();
112315:     const MGetPropertyCache *mir;
112315: 
112315:     TypedOrValueRegister output;
112315: 
112315:     if (ins_->op() == LInstruction::LOp_GetPropertyCacheT) {
112315:         LGetPropertyCacheT *ins = (LGetPropertyCacheT *) ins_;
112315:         output = TypedOrValueRegister(ins->mir()->type(), ToAnyRegister(ins->getDef(0)));
112315:         mir = ins->mir();
112315:     } else {
112315:         LGetPropertyCacheV *ins = (LGetPropertyCacheV *) ins_;
112315:         output = TypedOrValueRegister(GetValueOutput(ins));
112315:         mir = ins->mir();
112315:     }
112315: 
112315:     IonCacheGetProperty cache(ool->getInlineJump(), ool->getInlineLabel(),
112315:                               masm.labelForPatch(), liveRegs,
112315:                               objReg, mir->atom(), output);
112315: 
112761:     cache.setScriptedLocation(mir->block()->info().script(), mir->resumePoint()->pc());
112315:     size_t cacheIndex = allocateCache(cache);
112315: 
112453:     saveLive(ins_);
112315: 
112339:     typedef bool (*pf)(JSContext *, size_t, JSObject *, Value *);
112339:     static const VMFunction GetPropertyCacheInfo = FunctionInfo<pf>(GetPropertyCache);
112339: 
112315:     pushArg(objReg);
112315:     pushArg(Imm32(cacheIndex));
112453:     if (!callVM(GetPropertyCacheInfo, ins_))
112315:         return false;
112315: 
112684:     masm.storeCallResultValue(output);
112453:     restoreLive(ins_);
112315: 
112315:     masm.jump(ool->rejoin());
112315: 
112315:     return true;
112315: }
112315: 
112766: bool
112859: CodeGenerator::visitOutOfLineGetElementCache(OutOfLineCache *ool)
112859: {
112859:     LGetElementCacheV *ins = ool->cache()->toGetElementCacheV();
112859:     const MGetElementCache *mir = ins->mir();
112859: 
112859:     Register obj = ToRegister(ins->object());
112859:     ConstantOrRegister index = TypedOrValueRegister(ToValue(ins, LGetElementCacheV::Index));
112859:     TypedOrValueRegister output = TypedOrValueRegister(GetValueOutput(ins));
112859: 
112859:     RegisterSet liveRegs = ins->safepoint()->liveRegs();
112859: 
112859:     IonCacheGetElement cache(ool->getInlineJump(), ool->getInlineLabel(),
112859:                              masm.labelForPatch(), liveRegs,
112859:                              obj, index, output,
112859:                              mir->monitoredResult());
112859: 
112859:     cache.setScriptedLocation(mir->block()->info().script(), mir->resumePoint()->pc());
112859:     size_t cacheIndex = allocateCache(cache);
112859: 
112859:     saveLive(ins);
112859: 
112859:     typedef bool (*pf)(JSContext *, size_t, JSObject *, const Value &, Value *);
112859:     static const VMFunction Info = FunctionInfo<pf>(GetElementCache);
112859: 
112859:     pushArg(index);
112859:     pushArg(obj);
112859:     pushArg(Imm32(cacheIndex));
112859:     if (!callVM(Info, ins))
112859:         return false;
112859: 
112859:     masm.storeCallResultValue(output);
112859:     restoreLive(ins);
112859: 
112859:     masm.jump(ool->rejoin());
112859:     return true;
112859: }
112859: 
112859: bool
112766: CodeGenerator::visitOutOfLineBindNameCache(OutOfLineCache *ool)
112766: {
112766:     LBindNameCache *ins = ool->cache()->toBindNameCache();
112766:     Register scopeChain = ToRegister(ins->scopeChain());
112766:     Register output = ToRegister(ins->output());
112766: 
112766:     RegisterSet liveRegs = ins->safepoint()->liveRegs();
112766: 
112766:     const MBindNameCache *mir = ins->mir();
112766:     IonCacheBindName cache(ool->getInlineJump(), ool->getInlineLabel(),
112766:                            masm.labelForPatch(), liveRegs,
112766:                            scopeChain, mir->name(), output);
112766:     cache.setScriptedLocation(mir->script(), mir->pc());
112766:     size_t cacheIndex = allocateCache(cache);
112766: 
112766:     saveLive(ins);
112766: 
113014:     typedef JSObject *(*pf)(JSContext *, size_t, HandleObject);
112766:     static const VMFunction BindNameCacheInfo = FunctionInfo<pf>(BindNameCache);
112766: 
112766:     pushArg(scopeChain);
112766:     pushArg(Imm32(cacheIndex));
112766:     if (!callVM(BindNameCacheInfo, ins))
112766:         return false;
112766: 
112766:     masm.storeCallResult(output);
112766:     restoreLive(ins);
112766: 
112766:     masm.jump(ool->rejoin());
112766:     return true;
112767: }
112766: 
112445: ConstantOrRegister
112445: CodeGenerator::getSetPropertyValue(LInstruction *ins)
112445: {
112445:     if (ins->getOperand(1)->isConstant()) {
112676:         JS_ASSERT(ins->isSetPropertyCacheT());
112445:         return ConstantOrRegister(*ins->getOperand(1)->toConstant());
112445:     }
112445: 
112445:     switch (ins->op()) {
112675:       case LInstruction::LOp_CallSetProperty:
112675:         return TypedOrValueRegister(ToValue(ins, LCallSetProperty::Value));
112676:       case LInstruction::LOp_SetPropertyCacheV:
112676:         return TypedOrValueRegister(ToValue(ins, LSetPropertyCacheV::Value));
112676:       case LInstruction::LOp_SetPropertyCacheT: {
112676:         LSetPropertyCacheT *ins_ = ins->toSetPropertyCacheT();
112445:         return TypedOrValueRegister(ins_->valueType(), ToAnyRegister(ins->getOperand(1)));
112445:       }
112445:       default:
112445:         JS_NOT_REACHED("Bad opcode");
112445:         return ConstantOrRegister(UndefinedValue());
112445:     }
112445: }
112445: 
112445: bool
112675: CodeGenerator::visitCallSetProperty(LCallSetProperty *ins)
112445: {
112445:     ConstantOrRegister value = getSetPropertyValue(ins);
112445: 
112445:     const Register objReg = ToRegister(ins->getOperand(0));
113016:     bool isSetName = JSOp(*ins->mir()->resumePoint()->pc()) == JSOP_SETNAME;
113016: 
113016:     pushArg(Imm32(isSetName));
113016:     pushArg(Imm32(ins->mir()->strict()));
112445: 
112445:     pushArg(value);
112675:     pushArg(ImmGCPtr(ins->mir()->atom()));
112445:     pushArg(objReg);
112445: 
113016:     typedef bool (*pf)(JSContext *, HandleObject, JSAtom *, const HandleValue, bool, bool);
113016:     static const VMFunction info = FunctionInfo<pf>(SetProperty);
113016: 
113016:     return callVM(info, ins);
112445: }
112445: 
112445: bool
112834: CodeGenerator::visitCallDeleteProperty(LCallDeleteProperty *lir)
112834: {
112834:     typedef bool (*pf)(JSContext *, const Value &, PropertyName *, JSBool *);
112834: 
112834:     pushArg(ImmGCPtr(lir->mir()->atom()));
112834:     pushArg(ToValue(lir, LCallDeleteProperty::Value));
112834: 
112834:     if (lir->mir()->block()->info().script()->strictModeCode) {
112834:         static const VMFunction Info = FunctionInfo<pf>(DeleteProperty<true>);
112834:         return callVM(Info, lir);
112834:     } else {
112834:         static const VMFunction Info = FunctionInfo<pf>(DeleteProperty<false>);
112834:         return callVM(Info, lir);
112834:     }
112834: }
112834: 
112834: bool
112676: CodeGenerator::visitOutOfLineSetPropertyCache(OutOfLineCache *ool)
112445: {
112445:     LInstruction *ins = ool->cache();
112445: 
112445:     Register objReg = ToRegister(ins->getOperand(0));
112454:     RegisterSet liveRegs = ins->safepoint()->liveRegs();
112445: 
112445:     ConstantOrRegister value = getSetPropertyValue(ins);
112675:     const MSetPropertyCache *mir = ins->mirRaw()->toSetPropertyCache();
112445: 
112445:     IonCacheSetProperty cache(ool->getInlineJump(), ool->getInlineLabel(),
112445:                               masm.labelForPatch(), liveRegs,
112445:                               objReg, mir->atom(), value,
112445:                               mir->strict());
112445: 
112445:     size_t cacheIndex = allocateCache(cache);
113016:     bool isSetName = JSOp(*mir->resumePoint()->pc()) == JSOP_SETNAME;
112445: 
112456:     saveLive(ins);
112445: 
113016:     pushArg(Imm32(isSetName));
112445:     pushArg(value);
112445:     pushArg(objReg);
112445:     pushArg(Imm32(cacheIndex));
112445: 
113016:     typedef bool (*pf)(JSContext *, size_t, HandleObject, HandleValue, bool);
112445:     static const VMFunction info = FunctionInfo<pf>(ion::SetPropertyCache);
112445: 
112445:     if (!callVM(info, ool->cache()))
112445:         return false;
112445: 
112456:     restoreLive(ins);
112445: 
112445:     masm.jump(ool->rejoin());
112445: 
112445:     return true;
112445: }
112445: 
112478: bool
112478: CodeGenerator::visitThrow(LThrow *lir)
112478: {
112478:     typedef bool (*pf)(JSContext *, const Value &);
112478:     static const VMFunction ThrowInfo = FunctionInfo<pf>(js::Throw);
112478: 
112478:     pushArg(ToValue(lir, LThrow::Value));
112478:     return callVM(ThrowInfo, lir);
112478: }
112478: 
112508: bool
112682: CodeGenerator::visitBitNotV(LBitNotV *lir)
112682: {
112682:     typedef bool (*pf)(JSContext *, const Value &, int *p);
112682:     static const VMFunction info = FunctionInfo<pf>(BitNot);
112682: 
112682:     pushArg(ToValue(lir, LBitNotV::Input));
112682:     return callVM(info, lir);
112682: }
112682: 
112749: bool
112749: CodeGenerator::visitBitOpV(LBitOpV *lir)
112749: {
112749:     typedef bool (*pf)(JSContext *, const Value &, const Value &, int *p);
112749:     static const VMFunction BitAndInfo = FunctionInfo<pf>(BitAnd);
112749:     static const VMFunction BitOrInfo = FunctionInfo<pf>(BitOr);
112749:     static const VMFunction BitXorInfo = FunctionInfo<pf>(BitXor);
112970:     static const VMFunction BitLhsInfo = FunctionInfo<pf>(BitLsh);
112970:     static const VMFunction BitRhsInfo = FunctionInfo<pf>(BitRsh);
112970: 
112970:     pushArg(ToValue(lir, LBitOpV::RhsInput));
112749:     pushArg(ToValue(lir, LBitOpV::LhsInput));
112749: 
112749:     switch (lir->jsop()) {
112749:       case JSOP_BITAND:
112749:         return callVM(BitAndInfo, lir);
112749:       case JSOP_BITOR:
112749:         return callVM(BitOrInfo, lir);
112749:       case JSOP_BITXOR:
112749:         return callVM(BitXorInfo, lir);
112970:       case JSOP_LSH:
112970:         return callVM(BitLhsInfo, lir);
112970:       case JSOP_RSH:
112970:         return callVM(BitRhsInfo, lir);
112749:       default:
112749:         break;
112749:     }
112749:     JS_NOT_REACHED("unexpected bitop");
112749:     return false;
112749: }
112749: 
112684: class OutOfLineTypeOfV : public OutOfLineCodeBase<CodeGenerator>
112684: {
112684:     LTypeOfV *ins_;
112684: 
112684:   public:
112684:     OutOfLineTypeOfV(LTypeOfV *ins)
112684:       : ins_(ins)
112684:     { }
112684: 
112684:     bool accept(CodeGenerator *codegen) {
112684:         return codegen->visitOutOfLineTypeOfV(this);
112684:     }
112684:     LTypeOfV *ins() const {
112684:         return ins_;
112684:     }
112684: };
112684: 
112684: bool
112684: CodeGenerator::visitTypeOfV(LTypeOfV *lir)
112684: {
112684:     const ValueOperand value = ToValue(lir, LTypeOfV::Input);
112684:     Register output = ToRegister(lir->output());
112684:     Register tag = masm.splitTagForTest(value);
112684: 
112684:     OutOfLineTypeOfV *ool = new OutOfLineTypeOfV(lir);
112684:     if (!addOutOfLineCode(ool))
112684:         return false;
112684: 
112839:     PropertyName **typeAtoms = gen->cx->runtime->atomState.typeAtoms;
112684: 
112684:     // Jump to the OOL path if the value is an object. Objects are complicated
112684:     // since they may have a typeof hook.
112684:     masm.branchTestObject(Assembler::Equal, tag, ool->entry());
112684: 
112684:     Label done;
112684: 
112684:     Label notNumber;
112684:     masm.branchTestNumber(Assembler::NotEqual, tag, &notNumber);
112684:     masm.movePtr(ImmGCPtr(typeAtoms[JSTYPE_NUMBER]), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notNumber);
112684: 
112684:     Label notUndefined;
112684:     masm.branchTestUndefined(Assembler::NotEqual, tag, &notUndefined);
112684:     masm.movePtr(ImmGCPtr(typeAtoms[JSTYPE_VOID]), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notUndefined);
112684: 
112684:     Label notNull;
112684:     masm.branchTestNull(Assembler::NotEqual, tag, &notNull);
112684:     masm.movePtr(ImmGCPtr(typeAtoms[JSTYPE_OBJECT]), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notNull);
112684: 
112684:     Label notBoolean;
112684:     masm.branchTestBoolean(Assembler::NotEqual, tag, &notBoolean);
112684:     masm.movePtr(ImmGCPtr(typeAtoms[JSTYPE_BOOLEAN]), output);
112684:     masm.jump(&done);
112684:     masm.bind(&notBoolean);
112684: 
112684:     masm.movePtr(ImmGCPtr(typeAtoms[JSTYPE_STRING]), output);
112684: 
112684:     masm.bind(&done);
112684:     masm.bind(ool->rejoin());
112684:     return true;
112684: }
112684: 
112684: bool
112684: CodeGenerator::visitOutOfLineTypeOfV(OutOfLineTypeOfV *ool)
112684: {
112684:     typedef JSString *(*pf)(JSContext *, const Value &);
112684:     static const VMFunction Info = FunctionInfo<pf>(TypeOfOperation);
112684: 
112684:     LTypeOfV *ins = ool->ins();
112684:     saveLive(ins);
112684: 
112684:     pushArg(ToValue(ins, LTypeOfV::Input));
112684:     if (!callVM(Info, ins))
112684:         return false;
112684: 
112684:     masm.storeCallResult(ToRegister(ins->output()));
112684:     restoreLive(ins);
112684: 
112684:     masm.jump(ool->rejoin());
112684:     return true;
112684: }
112684: 
112682: bool
112705: CodeGenerator::visitToIdV(LToIdV *lir)
112705: {
112705:     typedef bool (*pf)(JSContext *, const Value &, const Value &, Value *);
112705:     static const VMFunction Info = FunctionInfo<pf>(ToIdOperation);
112705: 
112705:     pushArg(ToValue(lir, LToIdV::Index));
112705:     pushArg(ToValue(lir, LToIdV::Object));
112705:     return callVM(Info, lir);
112705: }
112705: 
112705: bool
112508: CodeGenerator::visitLoadElementV(LLoadElementV *load)
112508: {
112508:     Register elements = ToRegister(load->elements());
112508:     const ValueOperand out = ToOutValue(load);
112508: 
112508:     if (load->index()->isConstant())
112508:         masm.loadValue(Address(elements, ToInt32(load->index()) * sizeof(Value)), out);
112508:     else
112508:         masm.loadValue(BaseIndex(elements, ToRegister(load->index()), TimesEight), out);
112508: 
112508:     if (load->mir()->needsHoleCheck()) {
112508:         Assembler::Condition cond = masm.testMagic(Assembler::Equal, out);
112508:         if (!bailoutIf(cond, load->snapshot()))
112508:             return false;
112508:     }
112508: 
112508:     return true;
112508: }
112508: 
112508: bool
112508: CodeGenerator::visitLoadElementHole(LLoadElementHole *lir)
112508: {
112508:     Register elements = ToRegister(lir->elements());
112508:     Register initLength = ToRegister(lir->initLength());
112508:     const ValueOperand out = ToOutValue(lir);
112508: 
112508:     // If the index is out of bounds, load |undefined|. Otherwise, load the
112508:     // value.
112508:     Label undefined, done;
112508:     if (lir->index()->isConstant()) {
112508:         masm.branch32(Assembler::BelowOrEqual, initLength, Imm32(ToInt32(lir->index())), &undefined);
112508:         masm.loadValue(Address(elements, ToInt32(lir->index()) * sizeof(Value)), out);
112508:     } else {
112508:         masm.branch32(Assembler::BelowOrEqual, initLength, ToRegister(lir->index()), &undefined);
112508:         masm.loadValue(BaseIndex(elements, ToRegister(lir->index()), TimesEight), out);
112508:     }
112508: 
112508:     // If a hole check is needed, and the value wasn't a hole, we're done.
112508:     // Otherwise, we'll load undefined.
112508:     if (lir->mir()->needsHoleCheck())
112508:         masm.branchTestMagic(Assembler::NotEqual, out, &done);
112508:     else
112508:         masm.jump(&done);
112508: 
112508:     masm.bind(&undefined);
112508:     masm.moveValue(UndefinedValue(), out);
112508:     masm.bind(&done);
112508:     return true;
112508: }
112508: 
112904: bool
112904: CodeGenerator::visitLoadTypedArrayElement(LLoadTypedArrayElement *lir)
112904: {
112904:     Register elements = ToRegister(lir->elements());
112904:     Register temp = lir->temp()->isBogusTemp() ? InvalidReg : ToRegister(lir->temp());
112904:     AnyRegister out = ToAnyRegister(lir->output());
112904: 
112904:     int arrayType = lir->mir()->arrayType();
112904:     int shift = TypedArray::slotWidth(arrayType);
112904: 
112904:     Label fail;
112904:     if (lir->index()->isConstant()) {
112904:         Address source(elements, ToInt32(lir->index()) * shift);
112904:         masm.loadFromTypedArray(arrayType, source, out, temp, &fail);
112904:     } else {
112904:         BaseIndex source(elements, ToRegister(lir->index()), ScaleFromShift(shift));
112904:         masm.loadFromTypedArray(arrayType, source, out, temp, &fail);
112904:     }
112904: 
112904:     if (fail.used() && !bailoutFrom(&fail, lir->snapshot()))
112904:         return false;
112904: 
112904:     return true;
112904: }
112904: 
112904: class OutOfLineLoadTypedArray : public OutOfLineCodeBase<CodeGenerator>
112904: {
112904:     LLoadTypedArrayElementHole *ins_;
112904: 
112904:   public:
112904:     OutOfLineLoadTypedArray(LLoadTypedArrayElementHole *ins)
112904:       : ins_(ins)
112904:     { }
112904: 
112904:     bool accept(CodeGenerator *codegen) {
112904:         return codegen->visitOutOfLineLoadTypedArray(this);
112904:     }
112904: 
112904:     LLoadTypedArrayElementHole *ins() const {
112904:         return ins_;
112904:     }
112904: };
112904: 
112904: bool
112904: CodeGenerator::visitLoadTypedArrayElementHole(LLoadTypedArrayElementHole *lir)
112904: {
112904:     Register object = ToRegister(lir->object());
112904:     const ValueOperand out = ToOutValue(lir);
112904: 
112904:     OutOfLineLoadTypedArray *ool = new OutOfLineLoadTypedArray(lir);
112904:     if (!addOutOfLineCode(ool))
112904:         return false;
112904: 
112904:     // Load the length.
112904:     Register scratch = out.scratchReg();
112904:     Int32Key key = ToInt32Key(lir->index());
112904:     masm.unboxInt32(Address(object, TypedArray::lengthOffset()), scratch);
112904: 
112904:     // OOL path if index >= length.
112904:     masm.branchKey(Assembler::BelowOrEqual, scratch, key, ool->entry());
112904: 
112904:     // Load the elements vector.
112904:     masm.loadPtr(Address(object, TypedArray::dataOffset()), scratch);
112904: 
112904:     int arrayType = lir->mir()->arrayType();
112904:     int shift = TypedArray::slotWidth(arrayType);
112904: 
112904:     Label fail;
112904:     if (key.isConstant()) {
112904:         Address source(scratch, key.constant() * shift);
112904:         masm.loadFromTypedArray(arrayType, source, out, lir->mir()->allowDouble(), &fail);
112904:     } else {
112904:         BaseIndex source(scratch, key.reg(), ScaleFromShift(shift));
112904:         masm.loadFromTypedArray(arrayType, source, out, lir->mir()->allowDouble(), &fail);
112904:     }
112904: 
112904:     if (fail.used() && !bailoutFrom(&fail, lir->snapshot()))
112904:         return false;
112904: 
112904:     masm.bind(ool->rejoin());
112904:     return true;
112904: }
112904: 
112904: bool
112904: CodeGenerator::visitOutOfLineLoadTypedArray(OutOfLineLoadTypedArray *ool)
112904: {
112904:     LLoadTypedArrayElementHole *ins = ool->ins();
112904:     saveLive(ins);
112904: 
112904:     Register object = ToRegister(ins->object());
112904:     ValueOperand out = ToOutValue(ins);
112904: 
112904:     typedef bool (*pf)(JSContext *, const Value &, const Value &, Value *);
112904:     static const VMFunction Info = FunctionInfo<pf>(js::GetElementMonitored);
112904: 
112904:     if (ins->index()->isConstant())
112904:         pushArg(*ins->index()->toConstant());
112904:     else
112904:         pushArg(TypedOrValueRegister(MIRType_Int32, ToAnyRegister(ins->index())));
112904:     pushArg(TypedOrValueRegister(MIRType_Object, AnyRegister(object)));
112904:     if (!callVM(Info, ins))
112904:         return false;
112904: 
112904:     masm.storeCallResultValue(out);
112904:     restoreLive(ins);
112904: 
112904:     masm.jump(ool->rejoin());
112904:     return true;
112904: }
112904: 
112936: template <typename T>
112936: static inline void
112936: StoreToTypedArray(MacroAssembler &masm, int arrayType, const LAllocation *value, const T &dest)
112936: {
112936:     if (arrayType == TypedArray::TYPE_FLOAT32 || arrayType == TypedArray::TYPE_FLOAT64) {
112936:         masm.storeToTypedFloatArray(arrayType, ToFloatRegister(value), dest);
112936:     } else {
112936:         if (value->isConstant())
112936:             masm.storeToTypedIntArray(arrayType, Imm32(ToInt32(value)), dest);
112936:         else
112936:             masm.storeToTypedIntArray(arrayType, ToRegister(value), dest);
112936:     }
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitStoreTypedArrayElement(LStoreTypedArrayElement *lir)
112936: {
112936:     Register elements = ToRegister(lir->elements());
112936:     const LAllocation *value = lir->value();
112936: 
112936:     int arrayType = lir->mir()->arrayType();
112936:     int shift = TypedArray::slotWidth(arrayType);
112936: 
112936:     if (lir->index()->isConstant()) {
112936:         Address dest(elements, ToInt32(lir->index()) * shift);
112936:         StoreToTypedArray(masm, arrayType, value, dest);
112936:     } else {
112936:         BaseIndex dest(elements, ToRegister(lir->index()), ScaleFromShift(shift));
112936:         StoreToTypedArray(masm, arrayType, value, dest);
112936:     }
112936: 
112936:     return true;
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitClampIToUint8(LClampIToUint8 *lir)
112936: {
112936:     Register input = ToRegister(lir->input());
112936:     Register output = ToRegister(lir->output());
112936:     masm.clampIntToUint8(input, output);
112936:     return true;
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitClampDToUint8(LClampDToUint8 *lir)
112936: {
112936:     FloatRegister input = ToFloatRegister(lir->input());
112936:     Register output = ToRegister(lir->output());
112936:     masm.clampDoubleToUint8(input, output);
112936:     return true;
112936: }
112936: 
112936: bool
112936: CodeGenerator::visitClampVToUint8(LClampVToUint8 *lir)
112936: {
112936:     ValueOperand input = ToValue(lir, LClampVToUint8::Input);
112936:     FloatRegister tempFloat = ToFloatRegister(lir->tempFloat());
112936:     Register output = ToRegister(lir->output());
112936: 
112936:     Register tag = masm.splitTagForTest(input);
112936: 
112936:     Label done;
112936:     Label isInt32, isDouble, isBoolean;
112936:     masm.branchTestInt32(Assembler::Equal, tag, &isInt32);
112936:     masm.branchTestDouble(Assembler::Equal, tag, &isDouble);
112936:     masm.branchTestBoolean(Assembler::Equal, tag, &isBoolean);
112936: 
112936:     // Undefined, null and objects are always 0.
112936:     Label isZero;
112936:     masm.branchTestUndefined(Assembler::Equal, tag, &isZero);
112936:     masm.branchTestNull(Assembler::Equal, tag, &isZero);
112936:     masm.branchTestObject(Assembler::Equal, tag, &isZero);
112936: 
112936:     // Bailout for everything else (strings).
112936:     if (!bailout(lir->snapshot()))
112936:         return false;
112936: 
112936:     masm.bind(&isInt32);
112936:     masm.unboxInt32(input, output);
112936:     masm.clampIntToUint8(output, output);
112936:     masm.jump(&done);
112936: 
112936:     masm.bind(&isDouble);
112936:     masm.unboxDouble(input, tempFloat);
112936:     masm.clampDoubleToUint8(tempFloat, output);
112936:     masm.jump(&done);
112936: 
112936:     masm.bind(&isBoolean);
112936:     masm.unboxBoolean(input, output);
112936:     masm.jump(&done);
112936: 
112936:     masm.bind(&isZero);
112936:     masm.move32(Imm32(0), output);
112936: 
112936:     masm.bind(&done);
112936:     return true;
112936: }
112936: 
112292: } // namespace ion
112292: } // namespace js
112508: 
