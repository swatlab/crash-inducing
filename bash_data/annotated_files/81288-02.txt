43343: /*
57090:  *  Copyright (c) 2010 The WebM project authors. All Rights Reserved.
43343:  *
43343:  *  Use of this source code is governed by a BSD-style license
43343:  *  that can be found in the LICENSE file in the root of the source
43343:  *  tree. An additional intellectual property rights grant can be found
43343:  *  in the file PATENTS.  All contributing project authors may
43343:  *  be found in the AUTHORS file in the root of the source tree.
43343:  */
43343: 
43343: 
43343: #include "treereader.h"
80365: #include "vp8/common/entropymv.h"
80365: #include "vp8/common/entropymode.h"
43343: #include "onyxd_int.h"
80365: #include "vp8/common/findnearmv.h"
57090: 
43343: #if CONFIG_DEBUG
43343: #include <assert.h>
43343: #endif
57090: static int vp8_read_bmode(vp8_reader *bc, const vp8_prob *p)
57090: {
57090:     const int i = vp8_treed_read(bc, vp8_bmode_tree, p);
57090: 
57090:     return i;
57090: }
57090: 
57090: 
57090: static int vp8_read_ymode(vp8_reader *bc, const vp8_prob *p)
57090: {
57090:     const int i = vp8_treed_read(bc, vp8_ymode_tree, p);
57090: 
57090:     return i;
57090: }
57090: 
57090: static int vp8_kfread_ymode(vp8_reader *bc, const vp8_prob *p)
57090: {
57090:     const int i = vp8_treed_read(bc, vp8_kf_ymode_tree, p);
57090: 
57090:     return i;
57090: }
57090: 
57090: 
57090: 
57090: static int vp8_read_uv_mode(vp8_reader *bc, const vp8_prob *p)
57090: {
57090:     const int i = vp8_treed_read(bc, vp8_uv_mode_tree, p);
57090: 
57090:     return i;
57090: }
57090: 
57090: static void vp8_read_mb_features(vp8_reader *r, MB_MODE_INFO *mi, MACROBLOCKD *x)
57090: {
57090:     /* Is segmentation enabled */
57090:     if (x->segmentation_enabled && x->update_mb_segmentation_map)
57090:     {
57090:         /* If so then read the segment id. */
57090:         if (vp8_read(r, x->mb_segment_tree_probs[0]))
57090:             mi->segment_id = (unsigned char)(2 + vp8_read(r, x->mb_segment_tree_probs[2]));
57090:         else
57090:             mi->segment_id = (unsigned char)(vp8_read(r, x->mb_segment_tree_probs[1]));
57090:     }
57090: }
57090: 
57090: static void vp8_kfread_modes(VP8D_COMP *pbi, MODE_INFO *m, int mb_row, int mb_col)
57090: {
57090:     vp8_reader *const bc = & pbi->bc;
57090:     const int mis = pbi->common.mode_info_stride;
57090: 
57090:         {
57090:             MB_PREDICTION_MODE y_mode;
57090: 
57090:             /* Read the Macroblock segmentation map if it is being updated explicitly this frame (reset to 0 above by default)
57090:              * By default on a key frame reset all MBs to segment 0
57090:              */
57090:             m->mbmi.segment_id = 0;
57090: 
57090:             if (pbi->mb.update_mb_segmentation_map)
57090:                 vp8_read_mb_features(bc, &m->mbmi, &pbi->mb);
57090: 
57090:             /* Read the macroblock coeff skip flag if this feature is in use, else default to 0 */
57090:             if (pbi->common.mb_no_coeff_skip)
57090:                 m->mbmi.mb_skip_coeff = vp8_read(bc, pbi->prob_skip_false);
57090:             else
57090:                 m->mbmi.mb_skip_coeff = 0;
57090: 
57090:             y_mode = (MB_PREDICTION_MODE) vp8_kfread_ymode(bc, pbi->common.kf_ymode_prob);
57090: 
57090:             m->mbmi.ref_frame = INTRA_FRAME;
57090: 
57090:             if ((m->mbmi.mode = y_mode) == B_PRED)
57090:             {
57090:                 int i = 0;
57090: 
57090:                 do
57090:                 {
80365:                     const B_PREDICTION_MODE A = above_block_mode(m, i, mis);
80365:                     const B_PREDICTION_MODE L = left_block_mode(m, i);
57090: 
80365:                     m->bmi[i].as_mode = (B_PREDICTION_MODE) vp8_read_bmode(bc, pbi->common.kf_bmode_prob [A] [L]);
57090:                 }
57090:                 while (++i < 16);
57090:             }
57090: 
57090:             m->mbmi.uv_mode = (MB_PREDICTION_MODE)vp8_read_uv_mode(bc, pbi->common.kf_uv_mode_prob);
57090:         }
57090: }
43343: 
43343: static int read_mvcomponent(vp8_reader *r, const MV_CONTEXT *mvc)
43343: {
43343:     const vp8_prob *const p = (const vp8_prob *) mvc;
43343:     int x = 0;
43343: 
43343:     if (vp8_read(r, p [mvpis_short]))  /* Large */
43343:     {
43343:         int i = 0;
43343: 
43343:         do
43343:         {
43343:             x += vp8_read(r, p [MVPbits + i]) << i;
43343:         }
43343:         while (++i < 3);
43343: 
43343:         i = mvlong_width - 1;  /* Skip bit 3, which is sometimes implicit */
43343: 
43343:         do
43343:         {
43343:             x += vp8_read(r, p [MVPbits + i]) << i;
43343:         }
43343:         while (--i > 3);
43343: 
43343:         if (!(x & 0xFFF0)  ||  vp8_read(r, p [MVPbits + 3]))
43343:             x += 8;
43343:     }
43343:     else   /* small */
43343:         x = vp8_treed_read(r, vp8_small_mvtree, p + MVPshort);
43343: 
43343:     if (x  &&  vp8_read(r, p [MVPsign]))
43343:         x = -x;
43343: 
43343:     return x;
43343: }
43343: 
43343: static void read_mv(vp8_reader *r, MV *mv, const MV_CONTEXT *mvc)
43343: {
43343:     mv->row = (short)(read_mvcomponent(r,   mvc) << 1);
43343:     mv->col = (short)(read_mvcomponent(r, ++mvc) << 1);
43343: }
43343: 
43343: 
43343: static void read_mvcontexts(vp8_reader *bc, MV_CONTEXT *mvc)
43343: {
43343:     int i = 0;
43343: 
43343:     do
43343:     {
43343:         const vp8_prob *up = vp8_mv_update_probs[i].prob;
43343:         vp8_prob *p = (vp8_prob *)(mvc + i);
43343:         vp8_prob *const pstop = p + MVPcount;
43343: 
43343:         do
43343:         {
43343:             if (vp8_read(bc, *up++))
43343:             {
43343:                 const vp8_prob x = (vp8_prob)vp8_read_literal(bc, 7);
43343: 
43343:                 *p = x ? x << 1 : 1;
43343:             }
43343:         }
43343:         while (++p < pstop);
43343:     }
43343:     while (++i < 2);
43343: }
43343: 
43343: 
43343: static MB_PREDICTION_MODE read_mv_ref(vp8_reader *bc, const vp8_prob *p)
43343: {
43343:     const int i = vp8_treed_read(bc, vp8_mv_ref_tree, p);
43343: 
43343:     return (MB_PREDICTION_MODE)i;
43343: }
43343: 
80365: static B_PREDICTION_MODE sub_mv_ref(vp8_reader *bc, const vp8_prob *p)
43343: {
43343:     const int i = vp8_treed_read(bc, vp8_sub_mv_ref_tree, p);
43343: 
80365:     return (B_PREDICTION_MODE)i;
43343: }
57090: 
57090: #ifdef VPX_MODE_COUNT
43343: unsigned int vp8_mv_cont_count[5][4] =
43343: {
43343:     { 0, 0, 0, 0 },
43343:     { 0, 0, 0, 0 },
43343:     { 0, 0, 0, 0 },
43343:     { 0, 0, 0, 0 },
43343:     { 0, 0, 0, 0 }
43343: };
57090: #endif
43343: 
80365: static const unsigned char mbsplit_fill_count[4] = {8, 8, 4, 1};
80365: static const unsigned char mbsplit_fill_offset[4][16] = {
57090:     { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15},
57090:     { 0,  1,  4,  5,  8,  9, 12, 13,  2,  3,   6,  7, 10, 11, 14, 15},
57090:     { 0,  1,  4,  5,  2,  3,  6,  7,  8,  9,  12, 13, 10, 11, 14, 15},
57090:     { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15}
57090: };
57090: 
57090: 
57090: 
57090: 
80365: static void mb_mode_mv_init(VP8D_COMP *pbi)
43343: {
57090:     vp8_reader *const bc = & pbi->bc;
57090:     MV_CONTEXT *const mvc = pbi->common.fc.mvc;
43343: 
80365: #if CONFIG_ERROR_CONCEALMENT
80365:     /* Default is that no macroblock is corrupt, therefore we initialize
80365:      * mvs_corrupt_from_mb to something very big, which we can be sure is
80365:      * outside the frame. */
80365:     pbi->mvs_corrupt_from_mb = UINT_MAX;
80365: #endif
57090:     pbi->prob_skip_false = 0;
57090:     if (pbi->common.mb_no_coeff_skip)
57090:         pbi->prob_skip_false = (vp8_prob)vp8_read_literal(bc, 8);
43343: 
57090:     if(pbi->common.frame_type != KEY_FRAME)
57090:     {
57090:         pbi->prob_intra = (vp8_prob)vp8_read_literal(bc, 8);
57090:         pbi->prob_last  = (vp8_prob)vp8_read_literal(bc, 8);
57090:         pbi->prob_gf    = (vp8_prob)vp8_read_literal(bc, 8);
43343: 
43343:         if (vp8_read_bit(bc))
43343:         {
43343:             int i = 0;
43343: 
43343:             do
43343:             {
57090:                 pbi->common.fc.ymode_prob[i] = (vp8_prob) vp8_read_literal(bc, 8);
43343:             }
43343:             while (++i < 4);
43343:         }
43343: 
43343:         if (vp8_read_bit(bc))
43343:         {
43343:             int i = 0;
43343: 
43343:             do
43343:             {
57090:                 pbi->common.fc.uv_mode_prob[i] = (vp8_prob) vp8_read_literal(bc, 8);
43343:             }
43343:             while (++i < 3);
43343:         }
43343: 
43343:         read_mvcontexts(bc, mvc);
57090:     }
57090: }
43343: 
80365: 
80365: static void read_mb_modes_mv(VP8D_COMP *pbi, MODE_INFO *mi, MB_MODE_INFO *mbmi,
57090:                             int mb_row, int mb_col)
43343: {
57090:     vp8_reader *const bc = & pbi->bc;
57090:     MV_CONTEXT *const mvc = pbi->common.fc.mvc;
57090:     const int mis = pbi->common.mode_info_stride;
43343: 
80365:     int_mv *const mv = & mbmi->mv;
57090:     int mb_to_left_edge;
57090:     int mb_to_right_edge;
57090:     int mb_to_top_edge;
57090:     int mb_to_bottom_edge;
57090: 
57090:     mb_to_top_edge = pbi->mb.mb_to_top_edge;
57090:     mb_to_bottom_edge = pbi->mb.mb_to_bottom_edge;
57090:     mb_to_top_edge -= LEFT_TOP_MARGIN;
57090:     mb_to_bottom_edge += RIGHT_BOTTOM_MARGIN;
43343: 
52275:     mbmi->need_to_clamp_mvs = 0;
57090:     /* Distance of Mb to the various image edges.
57090:      * These specified to 8th pel as they are always compared to MV values that are in 1/8th pel units
57090:      */
57090:     pbi->mb.mb_to_left_edge =
57090:     mb_to_left_edge = -((mb_col * 16) << 3);
57090:     mb_to_left_edge -= LEFT_TOP_MARGIN;
43343: 
57090:     pbi->mb.mb_to_right_edge =
57090:     mb_to_right_edge = ((pbi->common.mb_cols - 1 - mb_col) * 16) << 3;
57090:     mb_to_right_edge += RIGHT_BOTTOM_MARGIN;
57090: 
57090:     /* If required read in new segmentation data for this MB */
43343:     if (pbi->mb.update_mb_segmentation_map)
43343:         vp8_read_mb_features(bc, mbmi, &pbi->mb);
43343: 
57090:     /* Read the macroblock coeff skip flag if this feature is in use, else default to 0 */
57090:     if (pbi->common.mb_no_coeff_skip)
57090:         mbmi->mb_skip_coeff = vp8_read(bc, pbi->prob_skip_false);
43343:     else
43343:         mbmi->mb_skip_coeff = 0;
43343: 
57090:     if ((mbmi->ref_frame = (MV_REFERENCE_FRAME) vp8_read(bc, pbi->prob_intra)))    /* inter MB */
43343:     {
43343:         int rct[4];
43343:         vp8_prob mv_ref_p [VP8_MVREFS-1];
80365:         int_mv nearest, nearby, best_mv;
43343: 
57090:         if (vp8_read(bc, pbi->prob_last))
43343:         {
57090:             mbmi->ref_frame = (MV_REFERENCE_FRAME)((int)mbmi->ref_frame + (int)(1 + vp8_read(bc, pbi->prob_gf)));
43343:         }
43343: 
57090:         vp8_find_near_mvs(&pbi->mb, mi, &nearest, &nearby, &best_mv, rct, mbmi->ref_frame, pbi->common.ref_frame_sign_bias);
43343: 
43343:         vp8_mv_ref_probs(mv_ref_p, rct);
43343: 
57090:         mbmi->uv_mode = DC_PRED;
43343:         switch (mbmi->mode = read_mv_ref(bc, mv_ref_p))
43343:         {
43343:         case SPLITMV:
43343:         {
57090:             const int s = mbmi->partitioning =
57090:                       vp8_treed_read(bc, vp8_mbsplit_tree, vp8_mbsplit_probs);
43343:             const int num_p = vp8_mbsplit_count [s];
43343:             int j = 0;
43343: 
43343:             do  /* for each subset j */
43343:             {
80365:                 int_mv leftmv, abovemv;
80365:                 int_mv blockmv;
57090:                 int k;  /* first block in subset j */
43343:                 int mv_contz;
57090:                 k = vp8_mbsplit_offset[s][j];
43343: 
80365:                 leftmv.as_int = left_block_mv(mi, k);
80365:                 abovemv.as_int = above_block_mv(mi, k, mis);
80365:                 mv_contz = vp8_mv_cont(&leftmv, &abovemv);
43343: 
80365:                 switch (sub_mv_ref(bc, vp8_sub_mv_ref_prob2 [mv_contz])) /*pc->fc.sub_mv_ref_prob))*/
43343:                 {
43343:                 case NEW4X4:
80365:                     read_mv(bc, &blockmv.as_mv, (const MV_CONTEXT *) mvc);
80365:                     blockmv.as_mv.row += best_mv.as_mv.row;
80365:                     blockmv.as_mv.col += best_mv.as_mv.col;
43343:   #ifdef VPX_MODE_COUNT
43343:                     vp8_mv_cont_count[mv_contz][3]++;
43343:   #endif
43343:                     break;
43343:                 case LEFT4X4:
80365:                     blockmv.as_int = leftmv.as_int;
43343:   #ifdef VPX_MODE_COUNT
43343:                     vp8_mv_cont_count[mv_contz][0]++;
43343:   #endif
43343:                     break;
43343:                 case ABOVE4X4:
80365:                     blockmv.as_int = abovemv.as_int;
43343:   #ifdef VPX_MODE_COUNT
43343:                     vp8_mv_cont_count[mv_contz][1]++;
43343:   #endif
43343:                     break;
43343:                 case ZERO4X4:
80365:                     blockmv.as_int = 0;
43343:   #ifdef VPX_MODE_COUNT
43343:                     vp8_mv_cont_count[mv_contz][2]++;
43343:   #endif
43343:                     break;
43343:                 default:
43343:                     break;
43343:                 }
43343: 
81288:                 mbmi->need_to_clamp_mvs |= vp8_check_mv_bounds(&blockmv,
80365:                                                           mb_to_left_edge,
80365:                                                           mb_to_right_edge,
80365:                                                           mb_to_top_edge,
80365:                                                           mb_to_bottom_edge);
43343: 
57090:                 {
43343:                     /* Fill (uniform) modes, mvs of jth subset.
43343:                      Must do it here because ensuing subsets can
43343:                      refer back to us via "left" or "above". */
80365:                     const unsigned char *fill_offset;
80365:                     unsigned int fill_count = mbsplit_fill_count[s];
43343: 
80365:                     fill_offset = &mbsplit_fill_offset[s][(unsigned char)j * mbsplit_fill_count[s]];
57090: 
57090:                     do {
80365:                         mi->bmi[ *fill_offset].mv.as_int = blockmv.as_int;
57090:                         fill_offset++;
57090:                     }while (--fill_count);
57090:                 }
57090: 
43343:             }
43343:             while (++j < num_p);
43343:         }
43343: 
80365:         mv->as_int = mi->bmi[15].mv.as_int;
43343: 
43343:         break;  /* done with SPLITMV */
43343: 
43343:         case NEARMV:
80365:             mv->as_int = nearby.as_int;
57090:             /* Clip "next_nearest" so that it does not extend to far out of image */
80365:             vp8_clamp_mv(mv, mb_to_left_edge, mb_to_right_edge,
80365:                          mb_to_top_edge, mb_to_bottom_edge);
43343:             goto propagate_mv;
43343: 
43343:         case NEARESTMV:
80365:             mv->as_int = nearest.as_int;
57090:             /* Clip "next_nearest" so that it does not extend to far out of image */
80365:             vp8_clamp_mv(mv, mb_to_left_edge, mb_to_right_edge,
80365:                          mb_to_top_edge, mb_to_bottom_edge);
43343:             goto propagate_mv;
43343: 
43343:         case ZEROMV:
80365:             mv->as_int = 0;
43343:             goto propagate_mv;
43343: 
43343:         case NEWMV:
80365:             read_mv(bc, &mv->as_mv, (const MV_CONTEXT *) mvc);
80365:             mv->as_mv.row += best_mv.as_mv.row;
80365:             mv->as_mv.col += best_mv.as_mv.col;
52275: 
52275:             /* Don't need to check this on NEARMV and NEARESTMV modes
52275:              * since those modes clamp the MV. The NEWMV mode does not,
52275:              * so signal to the prediction stage whether special
52275:              * handling may be required.
43343:              */
80365:             mbmi->need_to_clamp_mvs = vp8_check_mv_bounds(mv,
80365:                                                       mb_to_left_edge,
80365:                                                       mb_to_right_edge,
80365:                                                       mb_to_top_edge,
80365:                                                       mb_to_bottom_edge);
43343: 
43343:         propagate_mv:  /* same MV throughout */
80365: #if CONFIG_ERROR_CONCEALMENT
80365:             if(pbi->ec_enabled)
43343:             {
80365:                 mi->bmi[ 0].mv.as_int =
80365:                 mi->bmi[ 1].mv.as_int =
80365:                 mi->bmi[ 2].mv.as_int =
80365:                 mi->bmi[ 3].mv.as_int =
80365:                 mi->bmi[ 4].mv.as_int =
80365:                 mi->bmi[ 5].mv.as_int =
80365:                 mi->bmi[ 6].mv.as_int =
80365:                 mi->bmi[ 7].mv.as_int =
80365:                 mi->bmi[ 8].mv.as_int =
80365:                 mi->bmi[ 9].mv.as_int =
80365:                 mi->bmi[10].mv.as_int =
80365:                 mi->bmi[11].mv.as_int =
80365:                 mi->bmi[12].mv.as_int =
80365:                 mi->bmi[13].mv.as_int =
80365:                 mi->bmi[14].mv.as_int =
80365:                 mi->bmi[15].mv.as_int = mv->as_int;
57090:             }
80365: #endif
43343:             break;
43343:         default:;
43343:   #if CONFIG_DEBUG
43343:             assert(0);
43343:   #endif
43343:         }
43343:     }
43343:     else
43343:     {
80365:         /* required for left and above block mv */
80365:         mbmi->mv.as_int = 0;
80365: 
43343:         /* MB is intra coded */
80365:         if ((mbmi->mode = (MB_PREDICTION_MODE) vp8_read_ymode(bc, pbi->common.fc.ymode_prob)) == B_PRED)
80365:         {
43343:             int j = 0;
43343:             do
43343:             {
80365:                 mi->bmi[j].as_mode = (B_PREDICTION_MODE)vp8_read_bmode(bc, pbi->common.fc.bmode_prob);
43343:             }
43343:             while (++j < 16);
43343:         }
43343: 
57090:         mbmi->uv_mode = (MB_PREDICTION_MODE)vp8_read_uv_mode(bc, pbi->common.fc.uv_mode_prob);
43343:     }
43343: 
43343: }
43343: 
57090: void vp8_decode_mode_mvs(VP8D_COMP *pbi)
57090: {
57090:     MODE_INFO *mi = pbi->common.mi;
57090:     int mb_row = -1;
57090: 
80365:     mb_mode_mv_init(pbi);
57090: 
57090:     while (++mb_row < pbi->common.mb_rows)
57090:     {
57090:         int mb_col = -1;
57090:         int mb_to_top_edge;
57090:         int mb_to_bottom_edge;
57090: 
57090:         pbi->mb.mb_to_top_edge =
57090:         mb_to_top_edge = -((mb_row * 16)) << 3;
57090:         mb_to_top_edge -= LEFT_TOP_MARGIN;
57090: 
57090:         pbi->mb.mb_to_bottom_edge =
57090:         mb_to_bottom_edge = ((pbi->common.mb_rows - 1 - mb_row) * 16) << 3;
57090:         mb_to_bottom_edge += RIGHT_BOTTOM_MARGIN;
57090: 
57090:         while (++mb_col < pbi->common.mb_cols)
57090:         {
80365: #if CONFIG_ERROR_CONCEALMENT
80365:             int mb_num = mb_row * pbi->common.mb_cols + mb_col;
80365: #endif
80365:             /*read_mb_modes_mv(pbi, xd->mode_info_context, &xd->mode_info_context->mbmi, mb_row, mb_col);*/
57090:             if(pbi->common.frame_type == KEY_FRAME)
57090:                 vp8_kfread_modes(pbi, mi, mb_row, mb_col);
57090:             else
80365:                 read_mb_modes_mv(pbi, mi, &mi->mbmi, mb_row, mb_col);
80365: 
80365: #if CONFIG_ERROR_CONCEALMENT
80365:             /* look for corruption. set mvs_corrupt_from_mb to the current
80365:              * mb_num if the frame is corrupt from this macroblock. */
80365:             if (vp8dx_bool_error(&pbi->bc) && mb_num < pbi->mvs_corrupt_from_mb)
80365:             {
80365:                 pbi->mvs_corrupt_from_mb = mb_num;
80365:                 /* no need to continue since the partition is corrupt from
80365:                  * here on.
80365:                  */
80365:                 return;
80365:             }
80365: #endif
57090: 
57090:             mi++;       /* next macroblock */
43343:         }
57090: 
57090:         mi++;           /* skip left predictor each row */
43343:     }
57090: }
57090: 
