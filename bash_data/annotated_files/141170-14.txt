 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsUsageArrayHelper.h"
     1: 
139851: #include "mozilla/Assertions.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "nsDateTimeFormatCID.h"
     1: #include "nsComponentManagerUtils.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsNSSCertificate.h"
     1: 
     1: #include "nspr.h"
     1: #include "secerr.h"
119899: 
119899: using namespace mozilla;
     1: 
139851: #ifdef PR_LOGGING
139851: extern PRLogModuleInfo* gPIPNSSLog;
139851: #endif
139851: 
139851: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID); // XXX? needed?::
     1: 
     1: nsUsageArrayHelper::nsUsageArrayHelper(CERTCertificate *aCert)
     1: :mCert(aCert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   defaultcertdb = CERT_GetDefaultCertDB();
     1:   nssComponent = do_GetService(kNSSComponentCID, &m_rv);
     1: }
     1: 
140654: // XXX: old, non-libpkix version of check that will be removed after the switch
140654: // to libpkix is final.
140654: void
140654: nsUsageArrayHelper::check(const char *suffix,
140654:                         SECCertificateUsage aCertUsage,
140654:                         uint32_t &aCounter,
140654:                         PRUnichar **outUsages)
140654: {
140654:   if (!aCertUsage) return;
140654:   nsAutoCString typestr;
140654:   switch (aCertUsage) {
140654:   case certificateUsageSSLClient:
140654:     typestr = "VerifySSLClient";
140654:     break;
140654:   case certificateUsageSSLServer:
140654:     typestr = "VerifySSLServer";
140654:     break;
140654:   case certificateUsageSSLServerWithStepUp:
140654:     typestr = "VerifySSLStepUp";
140654:     break;
140654:   case certificateUsageEmailSigner:
140654:     typestr = "VerifyEmailSigner";
140654:     break;
140654:   case certificateUsageEmailRecipient:
140654:     typestr = "VerifyEmailRecip";
140654:     break;
140654:   case certificateUsageObjectSigner:
140654:     typestr = "VerifyObjSign";
140654:     break;
140654:   case certificateUsageProtectedObjectSigner:
140654:     typestr = "VerifyProtectObjSign";
140654:     break;
140654:   case certificateUsageUserCertImport:
140654:     typestr = "VerifyUserImport";
140654:     break;
140654:   case certificateUsageSSLCA:
140654:     typestr = "VerifySSLCA";
140654:     break;
140654:   case certificateUsageVerifyCA:
140654:     typestr = "VerifyCAVerifier";
140654:     break;
140654:   case certificateUsageStatusResponder:
140654:     typestr = "VerifyStatusResponder";
140654:     break;
140654:   case certificateUsageAnyCA:
140654:     typestr = "VerifyAnyCA";
140654:     break;
140654:   default:
140654:     break;
140654:   }
140654:   if (!typestr.IsEmpty()) {
140654:     typestr.Append(suffix);
140654:     nsAutoString verifyDesc;
140654:     m_rv = nssComponent->GetPIPNSSBundleString(typestr.get(), verifyDesc);
140654:     if (NS_SUCCEEDED(m_rv)) {
140654:       outUsages[aCounter++] = ToNewUnicode(verifyDesc);
140654:     }
140654:   }
140654: }
140654: 
139851: namespace {
139851: 
139851: // Some validation errors are non-fatal in that, we should keep checking the
139851: // cert for other usages after receiving them; i.e. they are errors that NSS
139851: // returns when a certificate isn't valid for a particular usage, but which
139851: // don't indicate that the certificate is invalid for ANY usage. Others errors
139851: // (e.g. revocation) are fatal, and we should immediately stop validation of
139851: // the cert when we encounter them.
139851: bool
139851: isFatalError(uint32_t checkResult)
139851: {
139851:   return checkResult != nsIX509Cert::VERIFIED_OK &&
139851:          checkResult != nsIX509Cert::USAGE_NOT_ALLOWED &&
139851:          checkResult != nsIX509Cert::ISSUER_NOT_TRUSTED &&
139851:          checkResult != nsIX509Cert::ISSUER_UNKNOWN;
139851: }
139851: 
139851: } // unnamed namespace
139851: 
141170: #ifndef NSS_NO_LIBPKIX
141170: 
139851: // Validates the certificate for the given usage. If the certificate is valid
139851: // for the given usage, aCounter is incremented, a string description of the
139851: // usage is appended to outUsages, and nsNSSCertificate::VERIFIED_OK is
139851: // returned. Otherwise, if validation failed, one of the other "Constants for
139851: // certificate verification results" in nsIX509Cert is returned.
139851: uint32_t
139851: nsUsageArrayHelper::check(uint32_t previousCheckResult,
139851:                           const char *suffix,
139851:                           SECCertificateUsage aCertUsage,
140656:                           nsCERTValInParamWrapper * aValInParams,
139851:                           uint32_t &aCounter,
139851:                           PRUnichar **outUsages)
139851: {
139851:   if (!aCertUsage) {
139851:     MOZ_NOT_REACHED("caller should have supplied non-zero aCertUsage");
139851:     return nsIX509Cert::NOT_VERIFIED_UNKNOWN;
139851:   }
139851: 
139851:   if (isFatalError(previousCheckResult)) {
139851:       return previousCheckResult;
139851:   }
139851: 
139851:   nsAutoCString typestr;
139851:   switch (aCertUsage) {
139851:   case certificateUsageSSLClient:
139851:     typestr = "VerifySSLClient";
139851:     break;
139851:   case certificateUsageSSLServer:
139851:     typestr = "VerifySSLServer";
139851:     break;
139851:   case certificateUsageSSLServerWithStepUp:
139851:     typestr = "VerifySSLStepUp";
139851:     break;
139851:   case certificateUsageEmailSigner:
139851:     typestr = "VerifyEmailSigner";
139851:     break;
139851:   case certificateUsageEmailRecipient:
139851:     typestr = "VerifyEmailRecip";
139851:     break;
139851:   case certificateUsageObjectSigner:
139851:     typestr = "VerifyObjSign";
139851:     break;
139851:   case certificateUsageProtectedObjectSigner:
139851:     typestr = "VerifyProtectObjSign";
139851:     break;
139851:   case certificateUsageUserCertImport:
139851:     typestr = "VerifyUserImport";
139851:     break;
139851:   case certificateUsageSSLCA:
139851:     typestr = "VerifySSLCA";
139851:     break;
139851:   case certificateUsageVerifyCA:
139851:     typestr = "VerifyCAVerifier";
139851:     break;
139851:   case certificateUsageStatusResponder:
139851:     typestr = "VerifyStatusResponder";
139851:     break;
139851:   case certificateUsageAnyCA:
139851:     typestr = "VerifyAnyCA";
139851:     break;
139851:   default:
139851:     MOZ_NOT_REACHED("unknown cert usage passed to check()");
139851:     return nsIX509Cert::NOT_VERIFIED_UNKNOWN;
139851:   }
139851: 
140656:   SECStatus rv;
140656:   CERTValOutParam cvout[1];
140656:   cvout[0].type = cert_po_end;
140656: 
140656:   rv = CERT_PKIXVerifyCert(mCert, aCertUsage,
140656:                            aValInParams->GetRawPointerForNSS(),
140656:                            cvout, nullptr);
139851: 
139851:   if (rv == SECSuccess) {
139851:     typestr.Append(suffix);
139851:     nsAutoString verifyDesc;
139851:     m_rv = nssComponent->GetPIPNSSBundleString(typestr.get(), verifyDesc);
139851:     if (NS_SUCCEEDED(m_rv)) {
139851:       outUsages[aCounter++] = ToNewUnicode(verifyDesc);
139851:     }
139851:     return nsIX509Cert::VERIFIED_OK;
139851:   }
139851: 
139851:   PRErrorCode error = PR_GetError();
139851: 
139851:   const char * errorString = PR_ErrorToName(error);
139851:   uint32_t result = nsIX509Cert::NOT_VERIFIED_UNKNOWN;
139851:   verifyFailed(&result, error);
139851: 
139851:   // USAGE_NOT_ALLOWED is the weakest non-fatal error; let all other errors
139851:   // override it.
139851:   if (result == nsIX509Cert::USAGE_NOT_ALLOWED &&
139851:       previousCheckResult != nsIX509Cert::VERIFIED_OK) {
139851:       result = previousCheckResult;
139851:   }
139851: 
139851:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
139851:           ("error validating certificate for usage %s: %s (%d) -> %ud \n",
139851:           typestr.get(), errorString, (int) error, (int) result));
139851: 
139851:   return result;
139851: }
139851: 
141170: #endif
141170: 
139851: // Maps the error code to one of the Constants for certificate verification
139851: // results" in nsIX509Cert.
     1: void
108991: nsUsageArrayHelper::verifyFailed(uint32_t *_verified, int err)
     1: {
     1:   switch (err) {
     1:   /* For these cases, verify only failed for the particular usage */
     1:   case SEC_ERROR_INADEQUATE_KEY_USAGE:
     1:   case SEC_ERROR_INADEQUATE_CERT_TYPE:
     1:     *_verified = nsNSSCertificate::USAGE_NOT_ALLOWED; break;
     1:   /* These are the cases that have individual error messages */
     1:   case SEC_ERROR_REVOKED_CERTIFICATE:
     1:     *_verified = nsNSSCertificate::CERT_REVOKED; break;
     1:   case SEC_ERROR_EXPIRED_CERTIFICATE:
     1:     *_verified = nsNSSCertificate::CERT_EXPIRED; break;
     1:   case SEC_ERROR_UNTRUSTED_CERT:
     1:     *_verified = nsNSSCertificate::CERT_NOT_TRUSTED; break;
     1:   case SEC_ERROR_UNTRUSTED_ISSUER:
     1:     *_verified = nsNSSCertificate::ISSUER_NOT_TRUSTED; break;
     1:   case SEC_ERROR_UNKNOWN_ISSUER:
     1:     *_verified = nsNSSCertificate::ISSUER_UNKNOWN; break;
     1:   case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
     1:     // XXX are there other error for this?
     1:     *_verified = nsNSSCertificate::INVALID_CA; break;
104409:   case SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED:
104409:     *_verified = nsNSSCertificate::SIGNATURE_ALGORITHM_DISABLED; break;
     1:   default:
     1:     *_verified = nsNSSCertificate::NOT_VERIFIED_UNKNOWN; break;
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsUsageArrayHelper::GetUsagesArray(const char *suffix,
 79445:                       bool localOnly,
108991:                       uint32_t outArraySize,
108991:                       uint32_t *_verified,
108991:                       uint32_t *_count,
     1:                       PRUnichar **outUsages)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (NS_FAILED(m_rv))
     1:     return m_rv;
     1: 
139851:   NS_ENSURE_TRUE(nssComponent, NS_ERROR_NOT_AVAILABLE);
139851: 
     1:   if (outArraySize < max_returned_out_array_size)
     1:     return NS_ERROR_FAILURE;
     1: 
140654:   uint32_t &count = *_count;
140654:   count = 0;
140640: 
140654: // TODO: This block will be removed as soon as the switch to libpkix is
140654: // complete.
141170: #ifndef NSS_NO_LIBPKIX
140654: if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
141170: #endif
140654:   if (localOnly) {
140640:     nssComponent->SkipOcsp();
140640:   }
140654: 
140654:   SECCertificateUsage usages = 0;
140654:   int err = 0;
140654:   
140654:   // CERT_VerifyCertificateNow returns SECFailure unless the certificate is
140654:   // valid for all the given usages. Hoewver, we are only looking for the list
140654:   // of usages for which the cert *is* valid.
140654:   (void)
140654:   CERT_VerifyCertificateNow(defaultcertdb, mCert, true,
140654: 			    certificateUsageSSLClient |
140654: 			    certificateUsageSSLServer |
140654: 			    certificateUsageSSLServerWithStepUp |
140654: 			    certificateUsageEmailSigner |
140654: 			    certificateUsageEmailRecipient |
140654: 			    certificateUsageObjectSigner |
140654: 			    certificateUsageSSLCA |
140654: 			    certificateUsageStatusResponder,
140654: 			    nullptr, &usages);
140654:   err = PR_GetError();
140654: 
140654:   if (localOnly) {
140654:      nssComponent->SkipOcspOff();
140640:   }
140640: 
140654:   // The following list of checks must be < max_returned_out_array_size
140654:   
140654:   check(suffix, usages & certificateUsageSSLClient, count, outUsages);
140654:   check(suffix, usages & certificateUsageSSLServer, count, outUsages);
140656:   check(suffix, usages & certificateUsageSSLServerWithStepUp, count, outUsages);
140654:   check(suffix, usages & certificateUsageEmailSigner, count, outUsages);
140654:   check(suffix, usages & certificateUsageEmailRecipient, count, outUsages);
140654:   check(suffix, usages & certificateUsageObjectSigner, count, outUsages);
140654: #if 0
140654:   check(suffix, usages & certificateUsageProtectedObjectSigner, count, outUsages);
140654:   check(suffix, usages & certificateUsageUserCertImport, count, outUsages);
140654: #endif
140654:   check(suffix, usages & certificateUsageSSLCA, count, outUsages);
140654: #if 0
140654:   check(suffix, usages & certificateUsageVerifyCA, count, outUsages);
140654: #endif
140654:   check(suffix, usages & certificateUsageStatusResponder, count, outUsages);
140654: #if 0
140654:   check(suffix, usages & certificateUsageAnyCA, count, outUsages);
140654: #endif
140654: 
140654:   if (count == 0) {
140654:     verifyFailed(_verified, err);
140654:   } else {
140654:     *_verified = nsNSSCertificate::VERIFIED_OK;
140654:   }
140654:   return NS_OK;
141170: 
141170: #ifndef NSS_NO_LIBPKIX
140654: }
     1: 
140656:   RefPtr<nsCERTValInParamWrapper> params;
140656:   nsresult rv = localOnly ? nssComponent->GetDefaultCERTValInParamLocalOnly(params)
140656:                           : nssComponent->GetDefaultCERTValInParam(params);
140656:   NS_ENSURE_SUCCESS(rv, rv);
139851: 
139851:   // The following list of checks must be < max_returned_out_array_size
139851: 
139851:   uint32_t result;
140656:   result = check(nsIX509Cert::VERIFIED_OK, suffix, certificateUsageSSLClient,
140656:                  params, count, outUsages);
140656:   result = check(result, suffix, certificateUsageSSLServer,
140656:                  params, count, outUsages);
140656:   result = check(result, suffix, certificateUsageSSLServerWithStepUp,
140656:                  params, count, outUsages);
140656:   result = check(result, suffix, certificateUsageEmailSigner,
140656:                  params, count, outUsages);
140656:   result = check(result, suffix, certificateUsageEmailRecipient,
140656:                  params, count, outUsages);
140656:   result = check(result, suffix, certificateUsageObjectSigner,
140656:                  params, count, outUsages);
139851: #if 0
140656:   result = check(result, suffix, certificateUsageProtectedObjectSigner,
140656:                  params, count, outUsages);
140656:   result = check(result, suffix, certificateUsageUserCertImport,
140656:                  params, count, outUsages);
139851: #endif
140656:   result = check(result, suffix, certificateUsageSSLCA,
140656:                  params, count, outUsages);
139851: #if 0
140656:   result = check(result, suffix, certificateUsageVerifyCA,
140656:                  params, count, outUsages);
139851: #endif
140656:   result = check(result, suffix, certificateUsageStatusResponder,
140656:                  params, count, outUsages);
139851: #if 0
140656:   result = checkPKIX(result, check(suffix, certificateUsageAnyCA,
140656:                  params, count, outUsages);
139851: #endif
139851: 
139851:   if (isFatalError(result) || count == 0) {
139851:     MOZ_ASSERT(result != nsIX509Cert::VERIFIED_OK);
139851: 
139851:     // Clear the output usage strings in the case where we encountered a fatal
139851:     // error after we already successfully validated the cert for some usages.
139851:     for (uint32_t i = 0; i < count; ++i) {
139851:       delete outUsages[i];
139851:       outUsages[i] = nullptr;
139851:     }
139851:     count = 0;
139851:     *_verified = result;
139851:   } else {
139851:     *_verified = nsNSSCertificate::VERIFIED_OK;
139851:   }
139851:   return NS_OK;
141170: #endif
139851: }
