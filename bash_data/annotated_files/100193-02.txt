 84764: /* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 84764: /* vim: set ts=2 et sw=2 tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 84764: "use strict";
 84764: 
 84764: const Cc = Components.classes;
 84764: const Ci = Components.interfaces;
 84764: const Cu = Components.utils;
 84764: 
 84764: const WEBGL_CONTEXT_NAME = "experimental-webgl";
 84764: 
 87429: Cu.import("resource://gre/modules/Services.jsm");
 84764: Cu.import("resource:///modules/devtools/TiltMath.jsm");
 84764: Cu.import("resource:///modules/devtools/TiltUtils.jsm");
 84764: 
 84764: let EXPORTED_SYMBOLS = ["TiltGL"];
 84764: 
 84764: /**
 84764:  * Module containing thin wrappers around low-level WebGL functions.
 84764:  */
 84764: let TiltGL = {};
 84764: 
 84764: /**
 84764:  * Contains commonly used helper methods used in any 3D application.
 84764:  *
 84764:  * @param {HTMLCanvasElement} aCanvas
 84764:  *                            the canvas element used for rendering
 84764:  * @param {Function} onError
 84764:  *                   optional, function called if initialization failed
 84764:  * @param {Function} onLoad
 84764:  *                   optional, function called if initialization worked
 84764:  */
 84764: TiltGL.Renderer = function TGL_Renderer(aCanvas, onError, onLoad)
 84764: {
 84764:   /**
 84764:    * The WebGL context obtained from the canvas element, used for drawing.
 84764:    */
 84764:   this.context = TiltGL.create3DContext(aCanvas);
 84764: 
 84764:   // check if the context was created successfully
 84764:   if (!this.context) {
 84764:     TiltUtils.Output.alert("Firefox", TiltUtils.L10n.get("initTilt.error"));
 84764:     TiltUtils.Output.error(TiltUtils.L10n.get("initWebGL.error"));
 84764: 
 84764:     if ("function" === typeof onError) {
 84764:       onError();
 84764:     }
 84764:     return;
 84764:   }
 84764: 
 84764:   // set the default clear color and depth buffers
 84764:   this.context.clearColor(0, 0, 0, 0);
 84764:   this.context.clearDepth(1);
 84764: 
 84764:   /**
 84764:    * Variables representing the current framebuffer width and height.
 84764:    */
 84764:   this.width = aCanvas.width;
 84764:   this.height = aCanvas.height;
 91041:   this.initialWidth = this.width;
 91041:   this.initialHeight = this.height;
 84764: 
 84764:   /**
 84764:    * The current model view matrix.
 84764:    */
 84764:   this.mvMatrix = mat4.identity(mat4.create());
 84764: 
 84764:   /**
 84764:    * The current projection matrix.
 84764:    */
 84764:   this.projMatrix = mat4.identity(mat4.create());
 84764: 
 84764:   /**
 84764:    * The current fill color applied to any objects which can be filled.
 84764:    * These are rectangles, circles, boxes, 2d or 3d primitives in general.
 84764:    */
 84764:   this._fillColor = [];
 84764: 
 84764:   /**
 84764:    * The current stroke color applied to any objects which can be stroked.
 84764:    * This property mostly refers to lines.
 84764:    */
 84764:   this._strokeColor = [];
 84764: 
 84764:   /**
 84764:    * Variable representing the current stroke weight.
 84764:    */
 84764:   this._strokeWeightValue = 0;
 84764: 
 84764:   /**
 84764:    * A shader useful for drawing vertices with only a color component.
 84764:    */
 84764:   this._colorShader = new TiltGL.Program(this.context, {
 84764:     vs: TiltGL.ColorShader.vs,
 84764:     fs: TiltGL.ColorShader.fs,
 84764:     attributes: ["vertexPosition"],
 84764:     uniforms: ["mvMatrix", "projMatrix", "fill"]
 84764:   });
 84764: 
 84764:   // create helper functions to create shaders, meshes, buffers and textures
 84764:   this.Program =
 84764:     TiltGL.Program.bind(TiltGL.Program, this.context);
 84764:   this.VertexBuffer =
 84764:     TiltGL.VertexBuffer.bind(TiltGL.VertexBuffer, this.context);
 84764:   this.IndexBuffer =
 84764:     TiltGL.IndexBuffer.bind(TiltGL.IndexBuffer, this.context);
 84764:   this.Texture =
 84764:     TiltGL.Texture.bind(TiltGL.Texture, this.context);
 84764: 
 84764:   // set the default mvp matrices, tint, fill, stroke and other visual props.
 84764:   this.defaults();
 84764: 
 84764:   // the renderer was created successfully
 84764:   if ("function" === typeof onLoad) {
 84764:     onLoad();
 84764:   }
 84764: };
 84764: 
 84764: TiltGL.Renderer.prototype = {
 84764: 
 84764:   /**
 84764:    * Clears the color and depth buffers.
 84764:    */
 84764:   clear: function TGLR_clear()
 84764:   {
 84764:     let gl = this.context;
 84764:     gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets if depth testing should be enabled or not.
 84764:    * Disabling could be useful when handling transparency (for example).
 84764:    *
 84764:    * @param {Boolean} aEnabledFlag
 84764:    *                  true if depth testing should be enabled
 84764:    */
 84764:   depthTest: function TGLR_depthTest(aEnabledFlag)
 84764:   {
 84764:     let gl = this.context;
 84764: 
 84764:     if (aEnabledFlag) {
 84764:       gl.enable(gl.DEPTH_TEST);
 84764:     } else {
 84764:       gl.disable(gl.DEPTH_TEST);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets if stencil testing should be enabled or not.
 84764:    *
 84764:    * @param {Boolean} aEnabledFlag
 84764:    *                  true if stencil testing should be enabled
 84764:    */
 84764:   stencilTest: function TGLR_stencilTest(aEnabledFlag)
 84764:   {
 84764:     let gl = this.context;
 84764: 
 84764:     if (aEnabledFlag) {
 84764:       gl.enable(gl.STENCIL_TEST);
 84764:     } else {
 84764:       gl.disable(gl.STENCIL_TEST);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets cull face, either "front", "back" or disabled.
 84764:    *
 84764:    * @param {String} aModeFlag
 84764:    *                 blending mode, either "front", "back", "both" or falsy
 84764:    */
 84764:   cullFace: function TGLR_cullFace(aModeFlag)
 84764:   {
 84764:     let gl = this.context;
 84764: 
 84764:     switch (aModeFlag) {
 84764:       case "front":
 84764:         gl.enable(gl.CULL_FACE);
 84764:         gl.cullFace(gl.FRONT);
 84764:         break;
 84764:       case "back":
 84764:         gl.enable(gl.CULL_FACE);
 84764:         gl.cullFace(gl.BACK);
 84764:         break;
 84764:       case "both":
 84764:         gl.enable(gl.CULL_FACE);
 84764:         gl.cullFace(gl.FRONT_AND_BACK);
 84764:         break;
 84764:       default:
 84764:         gl.disable(gl.CULL_FACE);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Specifies the orientation of front-facing polygons.
 84764:    *
 84764:    * @param {String} aModeFlag
 84764:    *                 either "cw" or "ccw"
 84764:    */
 84764:   frontFace: function TGLR_frontFace(aModeFlag)
 84764:   {
 84764:     let gl = this.context;
 84764: 
 84764:     switch (aModeFlag) {
 84764:       case "cw":
 84764:         gl.frontFace(gl.CW);
 84764:         break;
 84764:       case "ccw":
 84764:         gl.frontFace(gl.CCW);
 84764:         break;
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets blending, either "alpha" or "add" (additive blending).
 84764:    * Anything else disables blending.
 84764:    *
 84764:    * @param {String} aModeFlag
 84764:    *                 blending mode, either "alpha", "add" or falsy
 84764:    */
 84764:   blendMode: function TGLR_blendMode(aModeFlag)
 84764:   {
 84764:     let gl = this.context;
 84764: 
 84764:     switch (aModeFlag) {
 84764:       case "alpha":
 84764:         gl.enable(gl.BLEND);
 84764:         gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
 84764:         break;
 84764:       case "add":
 84764:         gl.enable(gl.BLEND);
 84764:         gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
 84764:         break;
 84764:       default:
 84764:         gl.disable(gl.BLEND);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Helper function to activate the color shader.
 84764:    *
 84764:    * @param {TiltGL.VertexBuffer} aVerticesBuffer
 84764:    *                              a buffer of vertices positions
 84764:    * @param {Array} aColor
 84764:    *                the color fill to be used as [r, g, b, a] with 0..1 range
 84764:    * @param {Array} aMvMatrix
 84764:    *                the model view matrix
 84764:    * @param {Array} aProjMatrix
 84764:    *                the projection matrix
 84764:    */
 84764:   useColorShader: function TGLR_useColorShader(
 84764:     aVerticesBuffer, aColor, aMvMatrix, aProjMatrix)
 84764:   {
 84764:     let program = this._colorShader;
 84764: 
 84764:     // use this program
 84764:     program.use();
 84764: 
 84764:     // bind the attributes and uniforms as necessary
 84764:     program.bindVertexBuffer("vertexPosition", aVerticesBuffer);
 84764:     program.bindUniformMatrix("mvMatrix", aMvMatrix || this.mvMatrix);
 84764:     program.bindUniformMatrix("projMatrix", aProjMatrix || this.projMatrix);
 84764:     program.bindUniformVec4("fill", aColor || this._fillColor);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Draws bound vertex buffers using the specified parameters.
 84764:    *
 84764:    * @param {Number} aDrawMode
 84764:    *                 WebGL enum, like TRIANGLES
 84764:    * @param {Number} aCount
 84764:    *                 the number of indices to be rendered
 84764:    */
 84764:   drawVertices: function TGLR_drawVertices(aDrawMode, aCount)
 84764:   {
 84764:     this.context.drawArrays(aDrawMode, 0, aCount);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Draws bound vertex buffers using the specified parameters.
 84764:    * This function also makes use of an index buffer.
 84764:    *
 84764:    * @param {Number} aDrawMode
 84764:    *                 WebGL enum, like TRIANGLES
 84764:    * @param {TiltGL.IndexBuffer} aIndicesBuffer
 84764:    *                             indices for the vertices buffer
 84764:    */
 84764:   drawIndexedVertices: function TGLR_drawIndexedVertices(
 84764:     aDrawMode, aIndicesBuffer)
 84764:   {
 84764:     let gl = this.context;
 84764: 
 84764:     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, aIndicesBuffer._ref);
 84764:     gl.drawElements(aDrawMode, aIndicesBuffer.numItems, gl.UNSIGNED_SHORT, 0);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets the current fill color.
 84764:    *
 84764:    * @param {Array} aColor
 84764:    *                the color fill to be used as [r, g, b, a] with 0..1 range
 84764:    * @param {Number} aMultiplyAlpha
 84764:    *                 optional, scalar to multiply the alpha element with
 84764:    */
 84764:   fill: function TGLR_fill(aColor, aMultiplyAlpha)
 84764:   {
 84764:     let fill = this._fillColor;
 84764: 
 84764:     fill[0] = aColor[0];
 84764:     fill[1] = aColor[1];
 84764:     fill[2] = aColor[2];
 84764:     fill[3] = aColor[3] * (aMultiplyAlpha || 1);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets the current stroke color.
 84764:    *
 84764:    * @param {Array} aColor
 84764:    *                the color stroke to be used as [r, g, b, a] with 0..1 range
 84764:    * @param {Number} aMultiplyAlpha
 84764:    *                 optional, scalar to multiply the alpha element with
 84764:    */
 84764:   stroke: function TGLR_stroke(aColor, aMultiplyAlpha)
 84764:   {
 84764:     let stroke = this._strokeColor;
 84764: 
 84764:     stroke[0] = aColor[0];
 84764:     stroke[1] = aColor[1];
 84764:     stroke[2] = aColor[2];
 84764:     stroke[3] = aColor[3] * (aMultiplyAlpha || 1);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets the current stroke weight (line width).
 84764:    *
 84764:    * @param {Number} aWeight
 84764:    *                 the stroke weight
 84764:    */
 84764:   strokeWeight: function TGLR_strokeWeight(aWeight)
 84764:   {
 84764:     if (this._strokeWeightValue !== aWeight) {
 84764:       this._strokeWeightValue = aWeight;
 84764:       this.context.lineWidth(aWeight);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets a default perspective projection, with the near frustum rectangle
 84764:    * mapped to the canvas width and height bounds.
 84764:    */
 84764:   perspective: function TGLR_perspective()
 84764:   {
 84764:     let fov = 45;
 84764:     let w = this.width;
 84764:     let h = this.height;
 84764:     let x = w / 2;
 84764:     let y = h / 2;
 84764:     let z = y / Math.tan(TiltMath.radians(fov) / 2);
 84764:     let aspect = w / h;
 84764:     let znear = z / 10;
 84764:     let zfar = z * 10;
 84764: 
 84764:     mat4.perspective(fov, aspect, znear, zfar, this.projMatrix, -1);
 84764:     mat4.translate(this.projMatrix, [-x, -y, -z]);
 84764:     mat4.identity(this.mvMatrix);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets a default orthographic projection (recommended for 2d rendering).
 84764:    */
 84764:   ortho: function TGLR_ortho()
 84764:   {
 84764:     mat4.ortho(0, this.width, this.height, 0, -1, 1, this.projMatrix);
 84764:     mat4.identity(this.mvMatrix);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets a custom projection matrix.
 84764:    * @param {Array} matrix: the custom projection matrix to be used
 84764:    */
 84764:   projection: function TGLR_projection(aMatrix)
 84764:   {
 84764:     mat4.set(aMatrix, this.projMatrix);
 84764:     mat4.identity(this.mvMatrix);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Resets the model view matrix to identity.
 84764:    * This is a default matrix with no rotation, no scaling, at (0, 0, 0);
 84764:    */
 84764:   origin: function TGLR_origin()
 84764:   {
 84764:     mat4.identity(this.mvMatrix);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Transforms the model view matrix with a new matrix.
 84764:    * Useful for creating custom transformations.
 84764:    *
 84764:    * @param {Array} matrix: the matrix to be multiply the model view with
 84764:    */
 84764:   transform: function TGLR_transform(aMatrix)
 84764:   {
 84764:     mat4.multiply(this.mvMatrix, aMatrix);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Translates the model view by the x, y and z coordinates.
 84764:    *
 84764:    * @param {Number} x
 84764:    *                 the x amount of translation
 84764:    * @param {Number} y
 84764:    *                 the y amount of translation
 84764:    * @param {Number} z
 84764:    *                 optional, the z amount of translation
 84764:    */
 84764:   translate: function TGLR_translate(x, y, z)
 84764:   {
 84764:     mat4.translate(this.mvMatrix, [x, y, z || 0]);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Rotates the model view by a specified angle on the x, y and z axis.
 84764:    *
 84764:    * @param {Number} angle
 84764:    *                 the angle expressed in radians
 84764:    * @param {Number} x
 84764:    *                 the x axis of the rotation
 84764:    * @param {Number} y
 84764:    *                 the y axis of the rotation
 84764:    * @param {Number} z
 84764:    *                 the z axis of the rotation
 84764:    */
 84764:   rotate: function TGLR_rotate(angle, x, y, z)
 84764:   {
 84764:     mat4.rotate(this.mvMatrix, angle, [x, y, z]);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Rotates the model view by a specified angle on the x axis.
 84764:    *
 84764:    * @param {Number} aAngle
 84764:    *                 the angle expressed in radians
 84764:    */
 84764:   rotateX: function TGLR_rotateX(aAngle)
 84764:   {
 84764:     mat4.rotateX(this.mvMatrix, aAngle);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Rotates the model view by a specified angle on the y axis.
 84764:    *
 84764:    * @param {Number} aAngle
 84764:    *                 the angle expressed in radians
 84764:    */
 84764:   rotateY: function TGLR_rotateY(aAngle)
 84764:   {
 84764:     mat4.rotateY(this.mvMatrix, aAngle);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Rotates the model view by a specified angle on the z axis.
 84764:    *
 84764:    * @param {Number} aAngle
 84764:    *                 the angle expressed in radians
 84764:    */
 84764:   rotateZ: function TGLR_rotateZ(aAngle)
 84764:   {
 84764:     mat4.rotateZ(this.mvMatrix, aAngle);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Scales the model view by the x, y and z coordinates.
 84764:    *
 84764:    * @param {Number} x
 84764:    *                 the x amount of scaling
 84764:    * @param {Number} y
 84764:    *                 the y amount of scaling
 84764:    * @param {Number} z
 84764:    *                 optional, the z amount of scaling
 84764:    */
 84764:   scale: function TGLR_scale(x, y, z)
 84764:   {
 86486:     mat4.scale(this.mvMatrix, [x, y, z || 1]);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Performs a custom interpolation between two matrices.
 84764:    * The result is saved in the first operand.
 84764:    *
 84764:    * @param {Array} aMat
 84764:    *                the first matrix
 84764:    * @param {Array} aMat2
 84764:    *                the second matrix
 84764:    * @param {Number} aLerp
 84764:    *                 interpolation amount between the two inputs
 84764:    * @param {Number} aDamping
 84764:    *                 optional, scalar adjusting the interpolation amortization
 84764:    * @param {Number} aBalance
 84764:    *                 optional, scalar adjusting the interpolation shift ammount
 84764:    */
 84764:   lerp: function TGLR_lerp(aMat, aMat2, aLerp, aDamping, aBalance)
 84764:   {
 84764:     if (aLerp < 0 || aLerp > 1) {
 84764:       return;
 84764:     }
 84764: 
 84764:     // calculate the interpolation factor based on the damping and step
 84764:     let f = Math.pow(1 - Math.pow(aLerp, aDamping || 1), 1 / aBalance || 1);
 84764: 
 84764:     // interpolate each element from the two matrices
 84764:     for (let i = 0, len = this.projMatrix.length; i < len; i++) {
 84764:       aMat[i] = aMat[i] + f * (aMat2[i] - aMat[i]);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Resets the drawing style to default.
 84764:    */
 84764:   defaults: function TGLR_defaults()
 84764:   {
 84764:     this.depthTest(true);
 84764:     this.stencilTest(false);
 84764:     this.cullFace(false);
 84764:     this.frontFace("ccw");
 84764:     this.blendMode("alpha");
 84764:     this.fill([1, 1, 1, 1]);
 84764:     this.stroke([0, 0, 0, 1]);
 84764:     this.strokeWeight(1);
 84764:     this.perspective();
 84764:     this.origin();
 84764:   },
 84764: 
 84764:   /**
 84764:    * Draws a quad composed of four vertices.
 84764:    * Vertices must be in clockwise order, or else drawing will be distorted.
 84764:    * Do not abuse this function, it is quite slow.
 84764:    *
 84764:    * @param {Array} aV0
 84764:    *                the [x, y, z] position of the first triangle point
 84764:    * @param {Array} aV1
 84764:    *                the [x, y, z] position of the second triangle point
 84764:    * @param {Array} aV2
 84764:    *                the [x, y, z] position of the third triangle point
 84764:    * @param {Array} aV3
 84764:    *                the [x, y, z] position of the fourth triangle point
 84764:    */
 84764:   quad: function TGLR_quad(aV0, aV1, aV2, aV3)
 84764:   {
 84764:     let gl = this.context;
 84764:     let fill = this._fillColor;
 84764:     let stroke = this._strokeColor;
 84764:     let vert = new TiltGL.VertexBuffer(gl, [aV0[0], aV0[1], aV0[2] || 0,
 84764:                                             aV1[0], aV1[1], aV1[2] || 0,
 84764:                                             aV2[0], aV2[1], aV2[2] || 0,
 84764:                                             aV3[0], aV3[1], aV3[2] || 0], 3);
 84764: 
 84764:     // use the necessary shader and draw the vertices
 84764:     this.useColorShader(vert, fill);
 84764:     this.drawVertices(gl.TRIANGLE_FAN, vert.numItems);
 84764: 
 84764:     this.useColorShader(vert, stroke);
 84764:     this.drawVertices(gl.LINE_LOOP, vert.numItems);
 84764: 
 84764:     TiltUtils.destroyObject(vert);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Function called when this object is destroyed.
 84764:    */
 84764:   finalize: function TGLR_finalize()
 84764:   {
 84764:     if (this.context) {
 84764:       TiltUtils.destroyObject(this._colorShader);
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Creates a vertex buffer containing an array of elements.
 84764:  *
 84764:  * @param {Object} aContext
 84764:  *                 a WebGL context
 84764:  * @param {Array} aElementsArray
 84764:  *                an array of numbers (floats)
 84764:  * @param {Number} aItemSize
 84764:  *                 how many items create a block
 84764:  * @param {Number} aNumItems
 84764:  *                 optional, how many items to use from the array
 84764:  */
 84764: TiltGL.VertexBuffer = function TGL_VertexBuffer(
 84764:   aContext, aElementsArray, aItemSize, aNumItems)
 84764: {
 84764:   /**
 84764:    * The parent WebGL context.
 84764:    */
 84764:   this._context = aContext;
 84764: 
 84764:   /**
 84764:    * The array buffer.
 84764:    */
 84764:   this._ref = null;
 84764: 
 84764:   /**
 84764:    * Array of number components contained in the buffer.
 84764:    */
 84764:   this.components = null;
 84764: 
 84764:   /**
 84764:    * Variables defining the internal structure of the buffer.
 84764:    */
 84764:   this.itemSize = 0;
 84764:   this.numItems = 0;
 84764: 
 84764:   // if the array is specified in the constructor, initialize directly
 84764:   if (aElementsArray) {
 84764:     this.initBuffer(aElementsArray, aItemSize, aNumItems);
 84764:   }
 84764: };
 84764: 
 84764: TiltGL.VertexBuffer.prototype = {
 84764: 
 84764:   /**
 84764:    * Initializes buffer data to be used for drawing, using an array of floats.
 84764:    * The "aNumItems" param can be specified to use only a portion of the array.
 84764:    *
 84764:    * @param {Array} aElementsArray
 84764:    *                an array of floats
 84764:    * @param {Number} aItemSize
 84764:    *                 how many items create a block
 84764:    * @param {Number} aNumItems
 84764:    *                 optional, how many items to use from the array
 84764:    */
 84764:   initBuffer: function TGLVB_initBuffer(aElementsArray, aItemSize, aNumItems)
 84764:   {
 84764:     let gl = this._context;
 84764: 
 84764:     // the aNumItems parameter is optional, we can compute it if not specified
 84764:     aNumItems = aNumItems || aElementsArray.length / aItemSize;
 84764: 
 84764:     // create the Float32Array using the elements array
 84764:     this.components = new Float32Array(aElementsArray);
 84764: 
 84764:     // create an array buffer and bind the elements as a Float32Array
 84764:     this._ref = gl.createBuffer();
 84764:     gl.bindBuffer(gl.ARRAY_BUFFER, this._ref);
 84764:     gl.bufferData(gl.ARRAY_BUFFER, this.components, gl.STATIC_DRAW);
 84764: 
 84764:     // remember some properties, useful when binding the buffer to a shader
 84764:     this.itemSize = aItemSize;
 84764:     this.numItems = aNumItems;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Function called when this object is destroyed.
 84764:    */
 84764:   finalize: function TGLVB_finalize()
 84764:   {
 84764:     if (this._context) {
 84764:       this._context.deleteBuffer(this._ref);
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Creates an index buffer containing an array of indices.
 84764:  *
 84764:  * @param {Object} aContext
 84764:  *                 a WebGL context
 84764:  * @param {Array} aElementsArray
 84764:  *                an array of unsigned integers
 84764:  * @param {Number} aNumItems
 84764:  *                 optional, how many items to use from the array
 84764:  */
 84764: TiltGL.IndexBuffer = function TGL_IndexBuffer(
 84764:   aContext, aElementsArray, aNumItems)
 84764: {
 84764:   /**
 84764:    * The parent WebGL context.
 84764:    */
 84764:   this._context = aContext;
 84764: 
 84764:   /**
 84764:    * The element array buffer.
 84764:    */
 84764:   this._ref = null;
 84764: 
 84764:   /**
 84764:    * Array of number components contained in the buffer.
 84764:    */
 84764:   this.components = null;
 84764: 
 84764:   /**
 84764:    * Variables defining the internal structure of the buffer.
 84764:    */
 84764:   this.itemSize = 0;
 84764:   this.numItems = 0;
 84764: 
 84764:   // if the array is specified in the constructor, initialize directly
 84764:   if (aElementsArray) {
 84764:     this.initBuffer(aElementsArray, aNumItems);
 84764:   }
 84764: };
 84764: 
 84764: TiltGL.IndexBuffer.prototype = {
 84764: 
 84764:   /**
 84764:    * Initializes a buffer of vertex indices, using an array of unsigned ints.
 84764:    * The item size will automatically default to 1, and the "numItems" will be
 84764:    * equal to the number of items in the array if not specified.
 84764:    *
 84764:    * @param {Array} aElementsArray
 84764:    *                an array of numbers (unsigned integers)
 84764:    * @param {Number} aNumItems
 84764:    *                 optional, how many items to use from the array
 84764:    */
 84764:   initBuffer: function TGLIB_initBuffer(aElementsArray, aNumItems)
 84764:   {
 84764:     let gl = this._context;
 84764: 
 84764:     // the aNumItems parameter is optional, we can compute it if not specified
 84764:     aNumItems = aNumItems || aElementsArray.length;
 84764: 
 84764:     // create the Uint16Array using the elements array
 84764:     this.components = new Uint16Array(aElementsArray);
 84764: 
 84764:     // create an array buffer and bind the elements as a Uint16Array
 84764:     this._ref = gl.createBuffer();
 84764:     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._ref);
 84764:     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.components, gl.STATIC_DRAW);
 84764: 
 84764:     // remember some properties, useful when binding the buffer to a shader
 84764:     this.itemSize = 1;
 84764:     this.numItems = aNumItems;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Function called when this object is destroyed.
 84764:    */
 84764:   finalize: function TGLIB_finalize()
 84764:   {
 84764:     if (this._context) {
 84764:       this._context.deleteBuffer(this._ref);
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * A program is composed of a vertex and a fragment shader.
 84764:  *
 84764:  * @param {Object} aProperties
 84764:  *                 optional, an object containing the following properties:
 84764:  *        {String} vs: the vertex shader source code
 84764:  *        {String} fs: the fragment shader source code
 84764:  *         {Array} attributes: an array of attributes as strings
 84764:  *         {Array} uniforms: an array of uniforms as strings
 84764:  */
 84764: TiltGL.Program = function(aContext, aProperties)
 84764: {
 84764:   // make sure the properties parameter is a valid object
 84764:   aProperties = aProperties || {};
 84764: 
 84764:   /**
 84764:    * The parent WebGL context.
 84764:    */
 84764:   this._context = aContext;
 84764: 
 84764:   /**
 84764:    * A reference to the actual GLSL program.
 84764:    */
 84764:   this._ref = null;
 84764: 
 84764:   /**
 84764:    * Each program has an unique id assigned.
 84764:    */
 84764:   this._id = -1;
 84764: 
 84764:   /**
 84764:    * Two arrays: an attributes array, containing all the cached attributes
 84764:    * and a uniforms array, containing all the cached uniforms.
 84764:    */
 84764:   this._attributes = null;
 84764:   this._uniforms = null;
 84764: 
 84764:   // if the sources are specified in the constructor, initialize directly
 84764:   if (aProperties.vs && aProperties.fs) {
 84764:     this.initProgram(aProperties);
 84764:   }
 84764: };
 84764: 
 84764: TiltGL.Program.prototype = {
 84764: 
 84764:   /**
 84764:    * Initializes a shader program, using specified source code as strings.
 84764:    *
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing the following properties:
 84764:    *        {String} vs: the vertex shader source code
 84764:    *        {String} fs: the fragment shader source code
 84764:    *         {Array} attributes: an array of attributes as strings
 84764:    *         {Array} uniforms: an array of uniforms as strings
 84764:    */
 84764:   initProgram: function TGLP_initProgram(aProperties)
 84764:   {
 84764:     this._ref = TiltGL.ProgramUtils.create(this._context, aProperties);
 84764: 
 84764:     // cache for faster access
 84764:     this._id = this._ref.id;
 84764:     this._attributes = this._ref.attributes;
 84764:     this._uniforms = this._ref.uniforms;
 84764: 
 84764:     // cleanup
 84764:     delete this._ref.id;
 84764:     delete this._ref.attributes;
 84764:     delete this._ref.uniforms;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Uses the shader program as current one for the WebGL context; it also
 84764:    * enables vertex attributes necessary to enable when using this program.
 84764:    * This method also does some useful caching, as the function "useProgram"
 84764:    * could take quite a lot of time.
 84764:    */
 84764:   use: function TGLP_use()
 84764:   {
 84764:     let id = this._id;
 84764:     let utils = TiltGL.ProgramUtils;
 84764: 
 84764:     // check if the program wasn't already active
 84764:     if (utils._activeProgram !== id) {
 84764:       utils._activeProgram = id;
 84764: 
 84764:       // use the the program if it wasn't already set
 84764:       this._context.useProgram(this._ref);
 91039:       this.cleanupVertexAttrib();
 84764: 
 84764:       // enable any necessary vertex attributes using the cache
 91039:       for each (let attribute in this._attributes) {
 91039:         this._context.enableVertexAttribArray(attribute);
 91039:         utils._enabledAttributes.push(attribute);
 84764:       }
 84764:     }
 91039:   },
 91039: 
 91039:   /**
 91039:    * Disables all currently enabled vertex attribute arrays.
 91039:    */
 91039:   cleanupVertexAttrib: function TGLP_cleanupVertexAttrib()
 91039:   {
 91039:     let utils = TiltGL.ProgramUtils;
 91039: 
 91039:     for each (let attribute in utils._enabledAttributes) {
 91039:       this._context.disableVertexAttribArray(attribute);
 84764:     }
 91039:     utils._enabledAttributes = [];
 84764:   },
 84764: 
 84764:   /**
 84764:    * Binds a vertex buffer as an array buffer for a specific shader attribute.
 84764:    *
 84764:    * @param {String} aAtribute
 84764:    *                 the attribute name obtained from the shader
 84764:    * @param {Float32Array} aBuffer
 84764:    *                       the buffer to be bound
 84764:    */
 84764:   bindVertexBuffer: function TGLP_bindVertexBuffer(aAtribute, aBuffer)
 84764:   {
 84764:     // get the cached attribute value from the shader
 84764:     let gl = this._context;
 84764:     let attr = this._attributes[aAtribute];
 84764:     let size = aBuffer.itemSize;
 84764: 
 84764:     gl.bindBuffer(gl.ARRAY_BUFFER, aBuffer._ref);
 84764:     gl.vertexAttribPointer(attr, size, gl.FLOAT, false, 0, 0);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Binds a uniform matrix to the current shader.
 84764:    *
 84764:    * @param {String} aUniform
 84764:    *                 the uniform name to bind the variable to
 84764:    * @param {Float32Array} m
 84764:    *                       the matrix to be bound
 84764:    */
 84764:   bindUniformMatrix: function TGLP_bindUniformMatrix(aUniform, m)
 84764:   {
 84764:     this._context.uniformMatrix4fv(this._uniforms[aUniform], false, m);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Binds a uniform vector of 4 elements to the current shader.
 84764:    *
 84764:    * @param {String} aUniform
 84764:    *                 the uniform name to bind the variable to
 84764:    * @param {Float32Array} v
 84764:    *                       the vector to be bound
 84764:    */
 84764:   bindUniformVec4: function TGLP_bindUniformVec4(aUniform, v)
 84764:   {
 84764:     this._context.uniform4fv(this._uniforms[aUniform], v);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Binds a simple float element to the current shader.
 84764:    *
 84764:    * @param {String} aUniform
 84764:    *                 the uniform name to bind the variable to
 84764:    * @param {Number} v
 84764:    *                 the variable to be bound
 84764:    */
 84764:   bindUniformFloat: function TGLP_bindUniformFloat(aUniform, f)
 84764:   {
 84764:     this._context.uniform1f(this._uniforms[aUniform], f);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Binds a uniform texture for a sampler to the current shader.
 84764:    *
 84764:    * @param {String} aSampler
 84764:    *                 the sampler name to bind the texture to
 84764:    * @param {TiltGL.Texture} aTexture
 84764:    *                       the texture to be bound
 84764:    */
 84764:   bindTexture: function TGLP_bindTexture(aSampler, aTexture)
 84764:   {
 84764:     let gl = this._context;
 84764: 
 84764:     gl.activeTexture(gl.TEXTURE0);
 84764:     gl.bindTexture(gl.TEXTURE_2D, aTexture._ref);
 91039:     gl.uniform1i(this._uniforms[aSampler], 0);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Function called when this object is destroyed.
 84764:    */
 84764:   finalize: function TGLP_finalize()
 84764:   {
 84764:     if (this._context) {
 84764:       this._context.useProgram(null);
 84764:       this._context.deleteProgram(this._ref);
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Utility functions for handling GLSL shaders and programs.
 84764:  */
 84764: TiltGL.ProgramUtils = {
 84764: 
 84764:   /**
 84764:    * Initializes a shader program, using specified source code as strings,
 84764:    * returning the newly created shader program, by compiling and linking the
 84764:    * vertex and fragment shader.
 84764:    *
 84764:    * @param {Object} aContext
 84764:    *                 a WebGL context
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing the following properties:
 84764:    *        {String} vs: the vertex shader source code
 84764:    *        {String} fs: the fragment shader source code
 84764:    *         {Array} attributes: an array of attributes as strings
 84764:    *         {Array} uniforms: an array of uniforms as strings
 84764:    */
 84764:   create: function TGLPU_create(aContext, aProperties)
 84764:   {
 84764:     // make sure the properties parameter is a valid object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     // compile the two shaders
 84764:     let vertShader = this.compile(aContext, aProperties.vs, "vertex");
 84764:     let fragShader = this.compile(aContext, aProperties.fs, "fragment");
 84764:     let program = this.link(aContext, vertShader, fragShader);
 84764: 
 84764:     aContext.deleteShader(vertShader);
 84764:     aContext.deleteShader(fragShader);
 84764: 
 84764:     return this.cache(aContext, aProperties, program);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Compiles a shader source of a specific type, either vertex or fragment.
 84764:    *
 84764:    * @param {Object} aContext
 84764:    *                 a WebGL context
 84764:    * @param {String} aShaderSource
 84764:    *                 the source code for the shader
 84764:    * @param {String} aShaderType
 84764:    *                 the shader type ("vertex" or "fragment")
 84764:    *
 84764:    * @return {WebGLShader} the compiled shader
 84764:    */
 84764:   compile: function TGLPU_compile(aContext, aShaderSource, aShaderType)
 84764:   {
 84764:     let gl = aContext, shader, status;
 84764: 
 84764:     // make sure the shader source is valid
 84764:     if ("string" !== typeof aShaderSource || aShaderSource.length < 1) {
 84764:       TiltUtils.Output.error(
 84764:         TiltUtils.L10n.get("compileShader.source.error"));
 84764:       return null;
 84764:     }
 84764: 
 84764:     // also make sure the necessary shader mime type is valid
 84764:     if (aShaderType === "vertex") {
 84764:       shader = gl.createShader(gl.VERTEX_SHADER);
 84764:     } else if (aShaderType === "fragment") {
 84764:       shader = gl.createShader(gl.FRAGMENT_SHADER);
 84764:     } else {
 84764:       TiltUtils.Output.error(
 84764:         TiltUtils.L10n.format("compileShader.type.error", [aShaderSource]));
 84764:       return null;
 84764:     }
 84764: 
 84764:     // set the shader source and compile it
 84764:     gl.shaderSource(shader, aShaderSource);
 84764:     gl.compileShader(shader);
 84764: 
 84764:     // remember the shader source (useful for debugging and caching)
 84764:     shader.src = aShaderSource;
 84764: 
 84764:     // verify the compile status; if something went wrong, log the error
 84764:     if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
 84764:       status = gl.getShaderInfoLog(shader);
 84764: 
 84764:       TiltUtils.Output.error(
 84764:         TiltUtils.L10n.format("compileShader.compile.error", [status]));
 84764:       return null;
 84764:     }
 84764: 
 84764:     // return the newly compiled shader from the specified source
 84764:     return shader;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Links two compiled vertex or fragment shaders together to form a program.
 84764:    *
 84764:    * @param {Object} aContext
 84764:    *                 a WebGL context
 84764:    * @param {WebGLShader} aVertShader
 84764:    *                      the compiled vertex shader
 84764:    * @param {WebGLShader} aFragShader
 84764:    *                      the compiled fragment shader
 84764:    *
 84764:    * @return {WebGLProgram} the newly created and linked shader program
 84764:    */
 84764:   link: function TGLPU_link(aContext, aVertShader, aFragShader)
 84764:   {
 84764:     let gl = aContext, program, status;
 84764: 
 84764:     // create a program and attach the compiled vertex and fragment shaders
 84764:     program = gl.createProgram();
 84764: 
 84764:     // attach the vertex and fragment shaders to the program
 84764:     gl.attachShader(program, aVertShader);
 84764:     gl.attachShader(program, aFragShader);
 84764:     gl.linkProgram(program);
 84764: 
 84764:     // verify the link status; if something went wrong, log the error
 84764:     if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
 84764:       status = gl.getProgramInfoLog(program);
 84764: 
 84764:       TiltUtils.Output.error(
 84764:         TiltUtils.L10n.format("linkProgram.error", [status]));
 84764:       return null;
 84764:     }
 84764: 
 84764:     // generate an id for the program
 84764:     program.id = this._count++;
 84764: 
 84764:     return program;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Caches shader attributes and uniforms as properties for a program object.
 84764:    *
 84764:    * @param {Object} aContext
 84764:    *                 a WebGL context
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing the following properties:
 84764:    *         {Array} attributes: optional, an array of attributes as strings
 84764:    *         {Array} uniforms: optional, an array of uniforms as strings
 84764:    * @param {WebGLProgram} aProgram
 84764:    *                       the shader program used for caching
 84764:    *
 84764:    * @return {WebGLProgram} the same program
 84764:    */
 84764:   cache: function TGLPU_cache(aContext, aProperties, aProgram)
 84764:   {
 84764:     // make sure the properties parameter is a valid object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     // make sure the attributes and uniforms cache objects are created
 84764:     aProgram.attributes = {};
 84764:     aProgram.uniforms = {};
 84764: 
 84764:     Object.defineProperty(aProgram.attributes, "length",
 84764:       { value: 0, writable: true, enumerable: false, configurable: true });
 84764: 
 84764:     Object.defineProperty(aProgram.uniforms, "length",
 84764:       { value: 0, writable: true, enumerable: false, configurable: true });
 84764: 
 84764: 
 84764:     let attr = aProperties.attributes;
 84764:     let unif = aProperties.uniforms;
 84764: 
 84764:     if (attr) {
 84764:       for (let i = 0, len = attr.length; i < len; i++) {
 84764:         // try to get a shader attribute from the program
 84764:         let param = attr[i];
 84764:         let loc = aContext.getAttribLocation(aProgram, param);
 84764: 
 84764:         if ("number" === typeof loc && loc > -1) {
 84764:           // if we get an attribute location, store it
 84764:           // bind the new parameter only if it was not already defined
 84764:           if (aProgram.attributes[param] === undefined) {
 84764:             aProgram.attributes[param] = loc;
 84764:             aProgram.attributes.length++;
 84764:           }
 84764:         }
 84764:       }
 84764:     }
 84764: 
 84764:     if (unif) {
 84764:       for (let i = 0, len = unif.length; i < len; i++) {
 84764:         // try to get a shader uniform from the program
 84764:         let param = unif[i];
 84764:         let loc = aContext.getUniformLocation(aProgram, param);
 84764: 
 84764:         if ("object" === typeof loc && loc) {
 84764:           // if we get a uniform object, store it
 84764:           // bind the new parameter only if it was not already defined
 84764:           if (aProgram.uniforms[param] === undefined) {
 84764:             aProgram.uniforms[param] = loc;
 84764:             aProgram.uniforms.length++;
 84764:           }
 84764:         }
 84764:       }
 84764:     }
 84764: 
 84764:     return aProgram;
 84764:   },
 84764: 
 84764:   /**
 84764:    * The total number of programs created.
 84764:    */
 84764:   _count: 0,
 84764: 
 84764:   /**
 84764:    * Represents the current active shader, identified by an id.
 84764:    */
 84764:   _activeProgram: -1,
 84764: 
 84764:   /**
 84764:    * Represents the current enabled attributes.
 84764:    */
 91039:   _enabledAttributes: []
 84764: };
 84764: 
 84764: /**
 84764:  * This constructor creates a texture from an Image.
 84764:  *
 84764:  * @param {Object} aContext
 84764:  *                 a WebGL context
 84764:  * @param {Object} aProperties
 84764:  *                 optional, an object containing the following properties:
 84764:  *         {Image} source: the source image for the texture
 84764:  *        {String} format: the format of the texture ("RGB" or "RGBA")
 84764:  *        {String} fill: optional, color to fill the transparent bits
 84764:  *        {String} stroke: optional, color to draw an outline
 84764:  *        {Number} strokeWeight: optional, the width of the outline
 84764:  *        {String} minFilter: either "nearest" or "linear"
 84764:  *        {String} magFilter: either "nearest" or "linear"
 84764:  *        {String} wrapS: either "repeat" or "clamp"
 84764:  *        {String} wrapT: either "repeat" or "clamp"
 84764:  *       {Boolean} mipmap: true if should generate mipmap
 84764:  */
 84764: TiltGL.Texture = function(aContext, aProperties)
 84764: {
 84764:   // make sure the properties parameter is a valid object
 84764:   aProperties = aProperties || {};
 84764: 
 84764:   /**
 84764:    * The parent WebGL context.
 84764:    */
 84764:   this._context = aContext;
 84764: 
 84764:   /**
 84764:    * A reference to the WebGL texture object.
 84764:    */
 84764:   this._ref = null;
 84764: 
 84764:   /**
 84764:    * Each texture has an unique id assigned.
 84764:    */
 84764:   this._id = -1;
 84764: 
 84764:   /**
 84764:    * Variables specifying the width and height of the texture.
 84764:    * If these values are less than 0, the texture hasn't loaded yet.
 84764:    */
 84764:   this.width = -1;
 84764:   this.height = -1;
 84764: 
 84764:   /**
 84764:    * Specifies if the texture has loaded or not.
 84764:    */
 84764:   this.loaded = false;
 84764: 
 84764:   // if the image is specified in the constructor, initialize directly
 84764:   if ("object" === typeof aProperties.source) {
 84764:     this.initTexture(aProperties);
 84764:   } else {
 84764:     TiltUtils.Output.error(
 84764:       TiltUtils.L10n.get("initTexture.source.error"));
 84764:   }
 84764: };
 84764: 
 84764: TiltGL.Texture.prototype = {
 84764: 
 84764:   /**
 84764:    * Initializes a texture from a pre-existing image or canvas.
 84764:    *
 84764:    * @param {Image} aImage
 84764:    *                the source image or canvas
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing the following properties:
 84764:    *         {Image} source: the source image for the texture
 84764:    *        {String} format: the format of the texture ("RGB" or "RGBA")
 84764:    *        {String} fill: optional, color to fill the transparent bits
 84764:    *        {String} stroke: optional, color to draw an outline
 84764:    *        {Number} strokeWeight: optional, the width of the outline
 84764:    *        {String} minFilter: either "nearest" or "linear"
 84764:    *        {String} magFilter: either "nearest" or "linear"
 84764:    *        {String} wrapS: either "repeat" or "clamp"
 84764:    *        {String} wrapT: either "repeat" or "clamp"
 84764:    *       {Boolean} mipmap: true if should generate mipmap
 84764:    */
 84764:   initTexture: function TGLT_initTexture(aProperties)
 84764:   {
 84764:     this._ref = TiltGL.TextureUtils.create(this._context, aProperties);
 84764: 
 84764:     // cache for faster access
 84764:     this._id = this._ref.id;
 84764:     this.width = this._ref.width;
 84764:     this.height = this._ref.height;
 84764:     this.loaded = true;
 84764: 
 84764:     // cleanup
 84764:     delete this._ref.id;
 84764:     delete this._ref.width;
 84764:     delete this._ref.height;
 84764:     delete this.onload;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Function called when this object is destroyed.
 84764:    */
 84764:   finalize: function TGLT_finalize()
 84764:   {
 84764:     if (this._context) {
 84764:       this._context.deleteTexture(this._ref);
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Utility functions for creating and manipulating textures.
 84764:  */
 84764: TiltGL.TextureUtils = {
 84764: 
 84764:   /**
 84764:    * Initializes a texture from a pre-existing image or canvas.
 84764:    *
 84764:    * @param {Object} aContext
 84764:    *                 a WebGL context
 84764:    * @param {Image} aImage
 84764:    *                the source image or canvas
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing some of the following properties:
 84764:    *         {Image} source: the source image for the texture
 84764:    *        {String} format: the format of the texture ("RGB" or "RGBA")
 84764:    *        {String} fill: optional, color to fill the transparent bits
 84764:    *        {String} stroke: optional, color to draw an outline
 84764:    *        {Number} strokeWeight: optional, the width of the outline
 84764:    *        {String} minFilter: either "nearest" or "linear"
 84764:    *        {String} magFilter: either "nearest" or "linear"
 84764:    *        {String} wrapS: either "repeat" or "clamp"
 84764:    *        {String} wrapT: either "repeat" or "clamp"
 84764:    *       {Boolean} mipmap: true if should generate mipmap
 84764:    *
 84764:    * @return {WebGLTexture} the created texture
 84764:    */
 84764:   create: function TGLTU_create(aContext, aProperties)
 84764:   {
 84764:     // make sure the properties argument is an object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     if (!aProperties.source) {
 84764:       return null;
 84764:     }
 84764: 
 84764:     let gl = aContext;
 84764:     let width = aProperties.source.width;
 84764:     let height = aProperties.source.height;
 84764:     let format = gl[aProperties.format || "RGB"];
 84764: 
 84764:     // make sure the image is power of two before binding to a texture
 84764:     let source = this.resizeImageToPowerOfTwo(aProperties);
 84764: 
 84764:     // first, create the texture to hold the image data
 84764:     let texture = gl.createTexture();
 84764: 
 84764:     // attach the image data to the newly create texture
 84764:     gl.bindTexture(gl.TEXTURE_2D, texture);
 84764:     gl.texImage2D(gl.TEXTURE_2D, 0, format, format, gl.UNSIGNED_BYTE, source);
 84764:     this.setTextureParams(gl, aProperties);
 84764: 
 84764:     // do some cleanup
 84764:     gl.bindTexture(gl.TEXTURE_2D, null);
 84764: 
 84764:     // remember the width and the height
 84764:     texture.width = width;
 84764:     texture.height = height;
 84764: 
 84764:     // generate an id for the texture
 84764:     texture.id = this._count++;
 84764: 
 84764:     return texture;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets texture parameters for the current texture binding.
 84764:    * Optionally, you can also (re)set the current texture binding manually.
 84764:    *
 84764:    * @param {Object} aContext
 84764:    *                 a WebGL context
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing the texture properties
 84764:    */
 84764:   setTextureParams: function TGLTU_setTextureParams(aContext, aProperties)
 84764:   {
 84764:     // make sure the properties argument is an object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     let gl = aContext;
 84764:     let minFilter = gl.TEXTURE_MIN_FILTER;
 84764:     let magFilter = gl.TEXTURE_MAG_FILTER;
 84764:     let wrapS = gl.TEXTURE_WRAP_S;
 84764:     let wrapT = gl.TEXTURE_WRAP_T;
 84764: 
 84764:     // bind a new texture if necessary
 84764:     if (aProperties.texture) {
 84764:       gl.bindTexture(gl.TEXTURE_2D, aProperties.texture.ref);
 84764:     }
 84764: 
 84764:     // set the minification filter
 84764:     if ("nearest" === aProperties.minFilter) {
 84764:       gl.texParameteri(gl.TEXTURE_2D, minFilter, gl.NEAREST);
 84764:     } else if ("linear" === aProperties.minFilter && aProperties.mipmap) {
 84764:       gl.texParameteri(gl.TEXTURE_2D, minFilter, gl.LINEAR_MIPMAP_LINEAR);
 84764:     } else {
 84764:       gl.texParameteri(gl.TEXTURE_2D, minFilter, gl.LINEAR);
 84764:     }
 84764: 
 84764:     // set the magnification filter
 84764:     if ("nearest" === aProperties.magFilter) {
 84764:       gl.texParameteri(gl.TEXTURE_2D, magFilter, gl.NEAREST);
 84764:     } else {
 84764:       gl.texParameteri(gl.TEXTURE_2D, magFilter, gl.LINEAR);
 84764:     }
 84764: 
 84764:     // set the wrapping on the x-axis for the texture
 84764:     if ("repeat" === aProperties.wrapS) {
 84764:       gl.texParameteri(gl.TEXTURE_2D, wrapS, gl.REPEAT);
 84764:     } else {
 84764:       gl.texParameteri(gl.TEXTURE_2D, wrapS, gl.CLAMP_TO_EDGE);
 84764:     }
 84764: 
 84764:     // set the wrapping on the y-axis for the texture
 84764:     if ("repeat" === aProperties.wrapT) {
 84764:       gl.texParameteri(gl.TEXTURE_2D, wrapT, gl.REPEAT);
 84764:     } else {
 84764:       gl.texParameteri(gl.TEXTURE_2D, wrapT, gl.CLAMP_TO_EDGE);
 84764:     }
 84764: 
 84764:     // generate mipmap if necessary
 84764:     if (aProperties.mipmap) {
 84764:       gl.generateMipmap(gl.TEXTURE_2D);
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * This shim renders a content window to a canvas element, but clamps the
 91043:    * maximum width and height of the canvas to the WebGL MAX_TEXTURE_SIZE.
 84764:    *
 84764:    * @param {Window} aContentWindow
 84764:    *                 the content window to get a texture from
 84764:    * @param {Number} aMaxImageSize
 84764:    *                 the maximum image size to be used
 84764:    *
 84764:    * @return {Image} the new content window image
 84764:    */
 84764:   createContentImage: function TGLTU_createContentImage(
 84764:     aContentWindow, aMaxImageSize)
 84764:   {
 84764:     // calculate the total width and height of the content page
 84764:     let size = TiltUtils.DOM.getContentWindowDimensions(aContentWindow);
 84764: 
 84764:     // use a custom canvas element and a 2d context to draw the window
 84764:     let canvas = TiltUtils.DOM.initCanvas(null);
 84764:     canvas.width = TiltMath.clamp(size.width, 0, aMaxImageSize);
 84764:     canvas.height = TiltMath.clamp(size.height, 0, aMaxImageSize);
 84764: 
 84764:     // use the 2d context.drawWindow() magic
 84764:     let ctx = canvas.getContext("2d");
 84764:     ctx.drawWindow(aContentWindow, 0, 0, canvas.width, canvas.height, "#fff");
 84764: 
 84764:     return canvas;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Scales an image's width and height to next power of two.
 84764:    * If the image already has power of two sizes, it is immediately returned,
 84764:    * otherwise, a new image is created.
 84764:    *
 84764:    * @param {Image} aImage
 84764:    *                the image to be scaled
 84764:    * @param {Object} aProperties
 84764:    *                 an object containing the following properties:
 84764:    *         {Image} source: the source image to resize
 84764:    *       {Boolean} resize: true to resize the image if it has npot dimensions
 84764:    *        {String} fill: optional, color to fill the transparent bits
 84764:    *        {String} stroke: optional, color to draw an image outline
 84764:    *        {Number} strokeWeight: optional, the width of the outline
 84764:    *
 84764:    * @return {Image} the resized image
 84764:    */
 84764:   resizeImageToPowerOfTwo: function TGLTU_resizeImageToPowerOfTwo(aProperties)
 84764:   {
 84764:     // make sure the properties argument is an object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     if (!aProperties.source) {
 84764:       return null;
 84764:     }
 84764: 
 84764:     let isPowerOfTwoWidth = TiltMath.isPowerOfTwo(aProperties.source.width);
 84764:     let isPowerOfTwoHeight = TiltMath.isPowerOfTwo(aProperties.source.height);
 84764: 
 84764:     // first check if the image is not already power of two
 84764:     if (!aProperties.resize || (isPowerOfTwoWidth && isPowerOfTwoHeight)) {
 84764:       return aProperties.source;
 84764:     }
 84764: 
 84764:     // calculate the power of two dimensions for the npot image
 84764:     let width = TiltMath.nextPowerOfTwo(aProperties.source.width);
 84764:     let height = TiltMath.nextPowerOfTwo(aProperties.source.height);
 84764: 
 84764:     // create a canvas, then we will use a 2d context to scale the image
 84764:     let canvas = TiltUtils.DOM.initCanvas(null, {
 84764:       width: width,
 84764:       height: height
 84764:     });
 84764: 
 84764:     let ctx = canvas.getContext("2d");
 84764: 
 84764:     // optional fill (useful when handling transparent images)
 84764:     if (aProperties.fill) {
 84764:       ctx.fillStyle = aProperties.fill;
 84764:       ctx.fillRect(0, 0, width, height);
 84764:     }
 84764: 
 84764:     // draw the image with power of two dimensions
 84764:     ctx.drawImage(aProperties.source, 0, 0, width, height);
 84764: 
 84764:     // optional stroke (useful when creating textures for edges)
 84764:     if (aProperties.stroke) {
 84764:       ctx.strokeStyle = aProperties.stroke;
 84764:       ctx.lineWidth = aProperties.strokeWeight;
 84764:       ctx.strokeRect(0, 0, width, height);
 84764:     }
 84764: 
 84764:     return canvas;
 84764:   },
 84764: 
 84764:   /**
 84764:    * The total number of textures created.
 84764:    */
 84764:   _count: 0
 84764: };
 84764: 
 84764: /**
 84764:  * A color shader. The only useful thing it does is set the gl_FragColor.
 84764:  *
 84764:  * @param {Attribute} vertexPosition: the vertex position
 84764:  * @param {Uniform} mvMatrix: the model view matrix
 84764:  * @param {Uniform} projMatrix: the projection matrix
 84764:  * @param {Uniform} color: the color to set the gl_FragColor to
 84764:  */
 84764: TiltGL.ColorShader = {
 84764: 
 84764:   /**
 84764:    * Vertex shader.
 84764:    */
 84764:   vs: [
 84764:     "attribute vec3 vertexPosition;",
 84764: 
 84764:     "uniform mat4 mvMatrix;",
 84764:     "uniform mat4 projMatrix;",
 84764: 
 84764:     "void main() {",
 84764:     "    gl_Position = projMatrix * mvMatrix * vec4(vertexPosition, 1.0);",
 84764:     "}"
 84764:   ].join("\n"),
 84764: 
 84764:   /**
 84764:    * Fragment shader.
 84764:    */
 84764:   fs: [
 84764:     "#ifdef GL_ES",
 84764:     "precision lowp float;",
 84764:     "#endif",
 84764: 
 84764:     "uniform vec4 fill;",
 84764: 
 84764:     "void main() {",
 84764:     "    gl_FragColor = fill;",
 84764:     "}"
 84764:   ].join("\n")
 84764: };
 84764: 
 87429: TiltGL.isWebGLForceEnabled = function TGL_isWebGLForceEnabled()
 87429: {
 87429:   return Services.prefs.getBoolPref("webgl.force-enabled");
 87429: };
 87429: 
 84764: /**
 84764:  * Tests if the WebGL OpenGL or Angle renderer is available using the
 84764:  * GfxInfo service.
 84764:  *
 84764:  * @return {Boolean} true if WebGL is available
 84764:  */
 84764: TiltGL.isWebGLSupported = function TGL_isWebGLSupported()
 84764: {
 84764:   let supported = false;
 84764: 
 84764:   try {
 84764:     let gfxInfo = Cc["@mozilla.org/gfx/info;1"].getService(Ci.nsIGfxInfo);
 84764:     let angle = gfxInfo.FEATURE_WEBGL_ANGLE;
 84764:     let opengl = gfxInfo.FEATURE_WEBGL_OPENGL;
 84764: 
 84764:     // if either the Angle or OpenGL renderers are available, WebGL should work
 84764:     supported = gfxInfo.getFeatureStatus(angle) === gfxInfo.FEATURE_NO_INFO ||
 84764:                 gfxInfo.getFeatureStatus(opengl) === gfxInfo.FEATURE_NO_INFO;
 84764:   } catch(e) {
100193:     if (e && e.message) { TiltUtils.Output.error(e.message); }
100193:     return false;
100193:   }
 84764:   return supported;
 84764: };
 84764: 
 84764: /**
 84764:  * Helper function to create a 3D context.
 84764:  *
 84764:  * @param {HTMLCanvasElement} aCanvas
 84764:  *                            the canvas to get the WebGL context from
 84764:  * @param {Object} aFlags
 84764:  *                 optional, flags used for initialization
 84764:  *
 84764:  * @return {Object} the WebGL context, or null if anything failed
 84764:  */
 84764: TiltGL.create3DContext = function TGL_create3DContext(aCanvas, aFlags)
 84764: {
 84764:   TiltGL.clearCache();
 84764: 
 84764:   // try to get a valid context from an existing canvas
 84764:   let context = null;
 84764: 
 84764:   try {
 84764:     context = aCanvas.getContext(WEBGL_CONTEXT_NAME, aFlags);
 84764:   } catch(e) {
100193:     if (e && e.message) { TiltUtils.Output.error(e.message); }
100193:     return null;
100193:   }
 84764:   return context;
 84764: };
 84764: 
 84764: /**
 84764:  * Clears the cache and sets all the variables to default.
 84764:  */
 84764: TiltGL.clearCache = function TGL_clearCache()
 84764: {
 84764:   TiltGL.ProgramUtils._activeProgram = -1;
 91039:   TiltGL.ProgramUtils._enabledAttributes = [];
 84764: };
