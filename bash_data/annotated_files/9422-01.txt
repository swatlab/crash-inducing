   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Pierre Phaneuf <pp@ludusdesign.com>
4006:  *   Elika J. Etemad ("fantasai") <fantasai@inkedblade.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /* base class #1 for rendering objects that have child lists */
   1: 
   1: #include "nsContainerFrame.h"
4006: #include "nsHTMLContainerFrame.h"
   1: #include "nsIContent.h"
   1: #include "nsIDocument.h"
   1: #include "nsPresContext.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsStyleContext.h"
   1: #include "nsRect.h"
   1: #include "nsPoint.h"
   1: #include "nsGUIEvent.h"
   1: #include "nsStyleConsts.h"
   1: #include "nsIView.h"
   1: #include "nsHTMLContainerFrame.h"
   1: #include "nsFrameManager.h"
   1: #include "nsIPresShell.h"
   1: #include "nsCOMPtr.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsCSSAnonBoxes.h"
   1: #include "nsIViewManager.h"
   1: #include "nsIWidget.h"
   1: #include "nsGfxCIID.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsCSSRendering.h"
   1: #include "nsTransform2D.h"
   1: #include "nsRegion.h"
   1: #include "nsLayoutErrors.h"
   1: #include "nsDisplayList.h"
   1: #include "nsContentErrors.h"
   1: #include "nsIEventStateManager.h"
   1: 
   1: #ifdef NS_DEBUG
   1: #undef NOISY
   1: #else
   1: #undef NOISY
   1: #endif
   1: 
   1: nsContainerFrame::~nsContainerFrame()
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsContainerFrame::Init(nsIContent* aContent,
   1:                        nsIFrame*   aParent,
   1:                        nsIFrame*   aPrevInFlow)
   1: {
   1:   nsresult rv = nsSplittableFrame::Init(aContent, aParent, aPrevInFlow);
   1:   if (aPrevInFlow) {
   1:     // Make sure we copy bits from our prev-in-flow that will affect
   1:     // us. A continuation for a container frame needs to know if it
   1:     // has a child with a view so that we'll properly reposition it.
   1:     if (aPrevInFlow->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)
   1:       AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
   1:   }
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsContainerFrame::SetInitialChildList(nsIAtom*  aListName,
   1:                                       nsIFrame* aChildList)
   1: {
   1:   nsresult  result;
   1:   if (!mFrames.IsEmpty()) {
   1:     // We already have child frames which means we've already been
   1:     // initialized
   1:     NS_NOTREACHED("unexpected second call to SetInitialChildList");
   1:     result = NS_ERROR_UNEXPECTED;
   1:   } else if (aListName) {
   1:     // All we know about is the unnamed principal child list
   1:     NS_NOTREACHED("unknown frame list");
   1:     result = NS_ERROR_INVALID_ARG;
   1:   } else {
   1: #ifdef NS_DEBUG
   1:     nsFrame::VerifyDirtyBitSet(aChildList);
   1: #endif
   1:     mFrames.SetFrames(aChildList);
   1:     result = NS_OK;
   1:   }
   1:   return result;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsContainerFrame::AppendFrames(nsIAtom*  aListName,
   1:                                nsIFrame* aFrameList)
   1: {
   1:   if (nsnull != aListName) {
   1: #ifdef IBMBIDI
   1:     if (aListName != nsGkAtoms::nextBidi)
   1: #endif
   1:     {
   1:       NS_ERROR("unexpected child list");
   1:       return NS_ERROR_INVALID_ARG;
   1:     }
   1:   }
   1:   if (aFrameList) {
   1:     mFrames.AppendFrames(this, aFrameList);
   1: 
   1:     // Ask the parent frame to reflow me.
   1: #ifdef IBMBIDI
   1:     if (nsnull == aListName)
   1: #endif
   1:     {
 238:       PresContext()->PresShell()->
1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsContainerFrame::InsertFrames(nsIAtom*  aListName,
   1:                                nsIFrame* aPrevFrame,
   1:                                nsIFrame* aFrameList)
   1: {
   1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
   1:                "inserting after sibling frame with different parent");
   1: 
   1:   if (nsnull != aListName) {
   1: #ifdef IBMBIDI
   1:     if (aListName != nsGkAtoms::nextBidi)
   1: #endif
   1:     {
   1:       NS_ERROR("unexpected child list");
   1:       return NS_ERROR_INVALID_ARG;
   1:     }
   1:   }
   1:   if (aFrameList) {
   1:     // Insert frames after aPrevFrame
   1:     mFrames.InsertFrames(this, aPrevFrame, aFrameList);
   1: 
   1: #ifdef IBMBIDI
   1:     if (nsnull == aListName)
   1: #endif
   1:     {
 238:       PresContext()->PresShell()->
1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsContainerFrame::RemoveFrame(nsIAtom*  aListName,
   1:                               nsIFrame* aOldFrame)
   1: {
   1:   if (nsnull != aListName) {
   1: #ifdef IBMBIDI
   1:     if (nsGkAtoms::nextBidi != aListName)
   1: #endif
   1:     {
   1:       NS_ERROR("unexpected child list");
   1:       return NS_ERROR_INVALID_ARG;
   1:     }
   1:   }
   1: 
   1:   if (aOldFrame) {
   1:     // Loop and destroy the frame and all of its continuations.
   1:     // If the frame we are removing is a brFrame, we need a reflow so
   1:     // the line the brFrame was on can attempt to pull up any frames
   1:     // that can fit from lines below it.
8854:     PRBool generateReflowCommand = PR_TRUE;
8854: #ifdef IBMBIDI
8854:     if (nsGkAtoms::nextBidi == aListName) {
8854:       generateReflowCommand = PR_FALSE;
8854:     }
8854: #endif
3233:     nsContainerFrame* parent = static_cast<nsContainerFrame*>(aOldFrame->GetParent());
   1:     while (aOldFrame) {
   1:       // When the parent is an inline frame we have a simple task - just
   1:       // remove the frame from its parents list and generate a reflow
   1:       // command.
   1:       nsIFrame* oldFrameNextContinuation = aOldFrame->GetNextContinuation();
4006:       //XXXfr probably should use StealFrame here. I'm not sure if we need to
4006:       //      check the overflow lists atm, but we'll need a prescontext lookup
4006:       //      for overflow containers once we can split abspos elements with
4006:       //      inline containing blocks.
6589:       if (parent == this) {
   1:         parent->mFrames.DestroyFrame(aOldFrame);
6589:       } else {
6589:         // This recursive call takes care of all continuations after aOldFrame,
6589:         // so we don't need to loop anymore.
6589:         parent->RemoveFrame(nsnull, aOldFrame);
6589:         break;
6589:       }
   1:       aOldFrame = oldFrameNextContinuation;
   1:       if (aOldFrame) {
3233:         parent = static_cast<nsContainerFrame*>(aOldFrame->GetParent());
   1:       }
   1:     }
   1: 
   1:     if (generateReflowCommand) {
 238:       PresContext()->PresShell()->
1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsContainerFrame::Destroy()
   1: {
   1:   // Prevent event dispatch during destruction
   1:   if (HasView()) {
   1:     GetView()->SetClientData(nsnull);
   1:   }
   1: 
   1:   // Delete the primary child list
   1:   mFrames.DestroyFrames();
   1: 
4006:   // Destroy auxiliary frame lists
4006:   nsPresContext* prescontext = PresContext();
4006: 
4006:   nsFrameList overflowFrames(GetOverflowFrames(prescontext, PR_TRUE));
   1:   overflowFrames.DestroyFrames();
   1: 
4006:   if (IsFrameOfType(nsIFrame::eCanContainOverflowContainers)) {
4006:     nsFrameList* frameList = RemovePropTableFrames(prescontext,
4006:                                nsGkAtoms::overflowContainersProperty);
4006:     if (frameList)
4006:       frameList->Destroy();
4006: 
4006:     frameList = RemovePropTableFrames(prescontext,
4006:                   nsGkAtoms::excessOverflowContainersProperty);
4006:     if (frameList)
4006:       frameList->Destroy();
4006:   }
4006: 
3793:   if (IsGeneratedContentFrame()) {
3793:     // Make sure all the content nodes for the generated content inside
3793:     // this frame know it's going away.
3793:     // See also nsCSSFrameConstructor::CreateGeneratedContentFrame which
3793:     // created this frame.
3793:     nsCOMArray<nsIContent>* generatedContent =
3793:       static_cast<nsCOMArray<nsIContent>*>(
3793:         UnsetProperty(nsGkAtoms::generatedContent));
3793: 
3793:     if (generatedContent) {
3793:       for (int i = generatedContent->Count() - 1; i >= 0; --i) {
3793:         nsIContent* content = generatedContent->ObjectAt(i);
3793:         // Tell the ESM that this content is going away now, so it'll update
3793:         // its hover content, etc.
3793:         PresContext()->EventStateManager()->ContentRemoved(content);
3793:         content->UnbindFromTree();
3793:       }
3793:       delete generatedContent;
3793:     }
3793:   }
3793: 
   1:   // Destroy the frame and remove the flow pointers
   1:   nsSplittableFrame::Destroy();
   1: }
   1: 
   1: /////////////////////////////////////////////////////////////////////////////
   1: // Child frame enumeration
   1: 
   1: nsIFrame*
   1: nsContainerFrame::GetFirstChild(nsIAtom* aListName) const
   1: {
   1:   // We only know about the unnamed principal child list and the overflow
   1:   // list
   1:   if (nsnull == aListName) {
   1:     return mFrames.FirstChild();
   1:   } else if (nsGkAtoms::overflowList == aListName) {
 238:     return GetOverflowFrames(PresContext(), PR_FALSE);
4006:   } else if (nsGkAtoms::overflowContainersList == aListName) {
4006:     nsFrameList* list = GetPropTableFrames(PresContext(),
4006:                           nsGkAtoms::overflowContainersProperty);
4006:     return (list) ? list->FirstChild() : nsnull;
4006:   } else if (nsGkAtoms::excessOverflowContainersList == aListName) {
4006:     nsFrameList* list = GetPropTableFrames(PresContext(),
4006:                           nsGkAtoms::excessOverflowContainersProperty);
4006:     return (list) ? list->FirstChild() : nsnull;
4006: 
   1:   } else {
   1:     return nsnull;
   1:   }
   1: }
   1: 
4006: #define NS_CONTAINER_FRAME_OVERFLOW_LIST_INDEX                   0
4006: #define NS_CONTAINER_FRAME_OVERFLOW_CONTAINERS_LIST_INDEX        1
4006: #define NS_CONTAINER_FRAME_EXCESS_OVERFLOW_CONTAINERS_LIST_INDEX 2
4006: // If adding/removing lists, don't forget to update count in .h file
4006: 
4006: 
   1: nsIAtom*
   1: nsContainerFrame::GetAdditionalChildListName(PRInt32 aIndex) const
   1: {
4006:   if (NS_CONTAINER_FRAME_OVERFLOW_LIST_INDEX == aIndex)
   1:     return nsGkAtoms::overflowList;
4006:   else if (IsFrameOfType(nsIFrame::eCanContainOverflowContainers)) {
4006:     if (NS_CONTAINER_FRAME_OVERFLOW_CONTAINERS_LIST_INDEX == aIndex)
4006:       return nsGkAtoms::overflowContainersList;
4006:     else if (NS_CONTAINER_FRAME_EXCESS_OVERFLOW_CONTAINERS_LIST_INDEX == aIndex)
4006:       return nsGkAtoms::excessOverflowContainersList;
4006:   }
   1:   return nsnull;
   1: }
   1: 
   1: /////////////////////////////////////////////////////////////////////////////
   1: // Painting/Events
   1: 
   1: NS_IMETHODIMP
   1: nsContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                    const nsRect&           aDirtyRect,
   1:                                    const nsDisplayListSet& aLists)
   1: {
   1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return BuildDisplayListForNonBlockChildren(aBuilder, aDirtyRect, aLists);
   1: }
   1: 
   1: nsresult
   1: nsContainerFrame::BuildDisplayListForNonBlockChildren(nsDisplayListBuilder*   aBuilder,
   1:                                                       const nsRect&           aDirtyRect,
   1:                                                       const nsDisplayListSet& aLists,
   1:                                                       PRUint32                aFlags)
   1: {
   1:   nsIFrame* kid = mFrames.FirstChild();
   1:   // Put each child's background directly onto the content list
   1:   nsDisplayListSet set(aLists, aLists.Content());
   1:   // The children should be in content order
   1:   while (kid) {
   1:     nsresult rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set, aFlags);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     kid = kid->GetNextSibling();
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /* virtual */ void
   1: nsContainerFrame::ChildIsDirty(nsIFrame* aChild)
   1: {
   1:   AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
   1: }
   1: 
   1: PRBool
   1: nsContainerFrame::IsLeaf() const
   1: {
   1:   return PR_FALSE;
   1: }
   1: 
   1: PRBool
   1: nsContainerFrame::PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset)
   1: {
   1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
   1:   // Don't allow the caret to stay in an empty (leaf) container frame.
   1:   return PR_FALSE;
   1: }
   1: 
   1: PRBool
   1: nsContainerFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)
   1: {
   1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
   1:   // Don't allow the caret to stay in an empty (leaf) container frame.
   1:   return PR_FALSE;
   1: }
   1: 
   1: /////////////////////////////////////////////////////////////////////////////
   1: // Helper member functions
   1: 
   1: /**
   1:  * Position the view associated with |aKidFrame|, if there is one. A
   1:  * container frame should call this method after positioning a frame,
   1:  * but before |Reflow|.
   1:  */
   1: void
   1: nsContainerFrame::PositionFrameView(nsIFrame* aKidFrame)
   1: {
   1:   nsIFrame* parentFrame = aKidFrame->GetParent();
   1:   if (!aKidFrame->HasView() || !parentFrame)
   1:     return;
   1: 
   1:   nsIView* view = aKidFrame->GetView();
   1:   nsIViewManager* vm = view->GetViewManager();
   1:   nsPoint pt;
   1:   nsIView* ancestorView = parentFrame->GetClosestView(&pt);
   1: 
   1:   if (ancestorView != view->GetParent()) {
   1:     NS_ASSERTION(ancestorView == view->GetParent()->GetParent(),
   1:                  "Allowed only one anonymous view between frames");
   1:     // parentFrame is responsible for positioning aKidFrame's view
   1:     // explicitly
   1:     return;
   1:   }
   1: 
   1:   pt += aKidFrame->GetPosition();
   1:   vm->MoveViewTo(view, pt.x, pt.y);
   1: }
   1: 
   1: static void
   1: SyncFrameViewGeometryDependentProperties(nsPresContext*  aPresContext,
   1:                                          nsIFrame*        aFrame,
   1:                                          nsStyleContext*  aStyleContext,
   1:                                          nsIView*         aView,
   1:                                          PRUint32         aFlags)
   1: {
   1:   nsIViewManager* vm = aView->GetViewManager();
   1: 
   1:   PRBool isCanvas;
   1:   const nsStyleBackground* bg;
   1:   PRBool hasBG =
   1:     nsCSSRendering::FindBackground(aPresContext, aFrame, &bg, &isCanvas);
   1: 
   1:   if (isCanvas) {
   1:     nsIView* rootView;
   1:     vm->GetRootView(rootView);
   1: 
   1:     nsIDocument *doc = aPresContext->PresShell()->GetDocument();
   1:     if (doc) {
   1:       nsIContent *rootElem = doc->GetRootContent();
   1:       if (!doc->GetParentDocument() &&
   1:           (nsCOMPtr<nsISupports>(doc->GetContainer())) &&
   1:           rootElem && rootElem->IsNodeOfType(nsINode::eXUL)) {
   1:         // we're XUL at the root of the document hierarchy. Try to make our
   1:         // window translucent.
   1:         // don't proceed unless this is the root view
   1:         // (sometimes the non-root-view is a canvas)
   1:         if (aView->HasWidget() && aView == rootView) {
1394:           aView->GetWidget()->SetWindowTranslucency(nsLayoutUtils::FrameHasTransparency(aFrame));
   1:         }
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsContainerFrame::SyncFrameViewAfterReflow(nsPresContext* aPresContext,
   1:                                            nsIFrame*       aFrame,
   1:                                            nsIView*        aView,
   1:                                            const nsRect*   aCombinedArea,
   1:                                            PRUint32        aFlags)
   1: {
   1:   if (!aView) {
   1:     return;
   1:   }
   1: 
  93:   NS_ASSERTION(aCombinedArea, "Combined area must be passed in now");
  93: 
   1:   // Make sure the view is sized and positioned correctly
   1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
   1:     PositionFrameView(aFrame);
   1:   }
   1: 
   1:   if (0 == (aFlags & NS_FRAME_NO_SIZE_VIEW)) {
   1:     nsIViewManager* vm = aView->GetViewManager();
   1: 
   1:     vm->ResizeView(aView, *aCombinedArea, PR_TRUE);
   1: 
   1:     // Even if the size hasn't changed, we need to sync up the
   1:     // geometry dependent properties, because (kidState &
   1:     // NS_FRAME_OUTSIDE_CHILDREN) might have changed, and we can't
   1:     // detect whether it has or not. Likewise, whether the view size
   1:     // has changed or not, we may need to change the transparency
   1:     // state even if there is no clip.
   1:     nsStyleContext* savedStyleContext = aFrame->GetStyleContext();
   1:     SyncFrameViewGeometryDependentProperties(aPresContext, aFrame, savedStyleContext, aView, aFlags);
   1:   }
   1: }
   1: 
   1: void
   1: nsContainerFrame::SyncFrameViewProperties(nsPresContext*  aPresContext,
   1:                                           nsIFrame*        aFrame,
   1:                                           nsStyleContext*  aStyleContext,
   1:                                           nsIView*         aView,
   1:                                           PRUint32         aFlags)
   1: {
   1:   NS_ASSERTION(!aStyleContext || aFrame->GetStyleContext() == aStyleContext,
   1:                "Wrong style context for frame?");
   1: 
   1:   if (!aView) {
   1:     return;
   1:   }
   1: 
   1:   nsIViewManager* vm = aView->GetViewManager();
   1: 
   1:   if (nsnull == aStyleContext) {
   1:     aStyleContext = aFrame->GetStyleContext();
   1:   }
   1: 
   1:   // Make sure visibility is correct
   1:   if (0 == (aFlags & NS_FRAME_NO_VISIBILITY)) {
   1:     // See if the view should be hidden or visible
   1:     PRBool  viewIsVisible = PR_TRUE;
   1: 
   1:     if (!aStyleContext->GetStyleVisibility()->IsVisible() &&
   1:         !aFrame->SupportsVisibilityHidden()) {
   1:       // If it's a scrollable frame that can't hide its scrollbars,
   1:       // hide the view. This means that child elements can't override
   1:       // their parent's visibility, but it's not practical to leave it
   1:       // visible in all cases because the scrollbars will be showing
   1:       // XXXldb Does the view system really enforce this correctly?
   1:       viewIsVisible = PR_FALSE;
8323:     } else if (aFrame->GetType() == nsGkAtoms::menuPopupFrame) {
   1:       // if the view is for a popup, don't show the view if the popup is closed
   1:       nsIWidget* widget = aView->GetWidget();
   1:       if (widget) {
   1:         nsWindowType windowType;
   1:         widget->GetWindowType(windowType);
   1:         if (windowType == eWindowType_popup) {
   1:           widget->IsVisible(viewIsVisible);
   1:         }
   1:       }
3129:       else {
3129:         // widgets for popups can be created later when the popup is opened,
3129:         // so if there is no widget, the popup won't be open.
3129:         viewIsVisible = PR_FALSE;
3129:       }
   1:     }
   1: 
   1:     vm->SetViewVisibility(aView, viewIsVisible ? nsViewVisibility_kShow :
   1:                           nsViewVisibility_kHide);
   1:   }
   1: 
   1:   // See if the frame is being relatively positioned or absolutely
   1:   // positioned
   1:   PRBool isPositioned = aStyleContext->GetStyleDisplay()->IsPositioned();
   1: 
   1:   PRInt32 zIndex = 0;
   1:   PRBool  autoZIndex = PR_FALSE;
   1: 
   1:   if (!isPositioned) {
   1:     autoZIndex = PR_TRUE;
   1:   } else {
   1:     // Make sure z-index is correct
   1:     const nsStylePosition* position = aStyleContext->GetStylePosition();
   1: 
   1:     if (position->mZIndex.GetUnit() == eStyleUnit_Integer) {
   1:       zIndex = position->mZIndex.GetIntValue();
   1:     } else if (position->mZIndex.GetUnit() == eStyleUnit_Auto) {
   1:       autoZIndex = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   vm->SetViewZIndex(aView, autoZIndex, zIndex, isPositioned);
   1: 
   1:   SyncFrameViewGeometryDependentProperties(aPresContext, aFrame, aStyleContext, aView, aFlags);
   1: }
   1: 
   1: PRBool
   1: nsContainerFrame::FrameNeedsView(nsIFrame* aFrame)
   1: {
   1:   // XXX Check needed because frame construction can't properly figure out when
   1:   // a frame is the child of a scrollframe
   1:   if (aFrame->GetStyleContext()->GetPseudoType() ==
   1:       nsCSSAnonBoxes::scrolledContent) {
   1:     return PR_TRUE;
   1:   }
   1:   return aFrame->NeedsView();
   1: }
   1: 
   1: static nscoord GetCoord(const nsStyleCoord& aCoord, nscoord aIfNotCoord)
   1: {
   1:   return aCoord.GetUnit() == eStyleUnit_Coord
   1:            ? aCoord.GetCoordValue()
   1:            : aIfNotCoord;
   1: }
   1: 
   1: void
   1: nsContainerFrame::DoInlineIntrinsicWidth(nsIRenderingContext *aRenderingContext,
   1:                                          InlineIntrinsicWidthData *aData,
   1:                                          nsLayoutUtils::IntrinsicWidthType aType)
   1: {
   1:   if (GetPrevInFlow())
   1:     return; // Already added.
   1: 
   1:   NS_PRECONDITION(aType == nsLayoutUtils::MIN_WIDTH ||
   1:                   aType == nsLayoutUtils::PREF_WIDTH, "bad type");
   1: 
   1:   PRUint8 startSide, endSide;
   1:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR) {
   1:     startSide = NS_SIDE_LEFT;
   1:     endSide = NS_SIDE_RIGHT;
   1:   } else {
   1:     startSide = NS_SIDE_RIGHT;
   1:     endSide = NS_SIDE_LEFT;
   1:   }
   1: 
   1:   const nsStylePadding *stylePadding = GetStylePadding();
   1:   const nsStyleBorder *styleBorder = GetStyleBorder();
   1:   const nsStyleMargin *styleMargin = GetStyleMargin();
   1:   nsStyleCoord tmp;
   1: 
   1:   // This goes at the beginning no matter how things are broken and how
   1:   // messy the bidi situations are, since per CSS2.1 section 8.6
   1:   // (implemented in bug 328168), the startSide border is always on the
   1:   // first line.
   1:   aData->currentLine +=
   1:     GetCoord(stylePadding->mPadding.Get(startSide, tmp), 0) +
   1:     styleBorder->GetBorderWidth(startSide) +
   1:     GetCoord(styleMargin->mMargin.Get(startSide, tmp), 0);
   1: 
   1:   for (nsContainerFrame *nif = this; nif;
   1:        nif = (nsContainerFrame*) nif->GetNextInFlow()) {
   1:     for (nsIFrame *kid = nif->mFrames.FirstChild(); kid;
   1:          kid = kid->GetNextSibling()) {
   1:       if (aType == nsLayoutUtils::MIN_WIDTH)
   1:         kid->AddInlineMinWidth(aRenderingContext,
3233:                                static_cast<InlineMinWidthData*>(aData));
   1:       else
   1:         kid->AddInlinePrefWidth(aRenderingContext,
3233:                                 static_cast<InlinePrefWidthData*>(aData));
   1:     }
   1:   }
   1: 
   1:   // This goes at the end no matter how things are broken and how
   1:   // messy the bidi situations are, since per CSS2.1 section 8.6
   1:   // (implemented in bug 328168), the endSide border is always on the
   1:   // last line.
   1:   aData->currentLine +=
   1:     GetCoord(stylePadding->mPadding.Get(endSide, tmp), 0) +
   1:     styleBorder->GetBorderWidth(endSide) +
   1:     GetCoord(styleMargin->mMargin.Get(endSide, tmp), 0);
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsContainerFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
   1:                                   nsSize aCBSize, nscoord aAvailableWidth,
   1:                                   nsSize aMargin, nsSize aBorder,
   1:                                   nsSize aPadding, PRBool aShrinkWrap)
   1: {
   1:   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
   1:   nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
   1:                        aPadding.width;
   1:   // replaced elements always shrink-wrap
   1:   if (aShrinkWrap || IsFrameOfType(eReplaced)) {
   1:     // don't bother setting it if the result won't be used
   1:     if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
   1:       result.width = ShrinkWidthToFit(aRenderingContext, availBased);
   1:     }
   1:   } else {
   1:     result.width = availBased;
   1:   }
   1:   return result;
   1: }
   1: 
   1: /**
   1:  * Invokes the WillReflow() function, positions the frame and its view (if
   1:  * requested), and then calls Reflow(). If the reflow succeeds and the child
   1:  * frame is complete, deletes any next-in-flows using DeleteNextInFlowChild()
   1:  */
   1: nsresult
   1: nsContainerFrame::ReflowChild(nsIFrame*                aKidFrame,
   1:                               nsPresContext*           aPresContext,
   1:                               nsHTMLReflowMetrics&     aDesiredSize,
   1:                               const nsHTMLReflowState& aReflowState,
   1:                               nscoord                  aX,
   1:                               nscoord                  aY,
   1:                               PRUint32                 aFlags,
4006:                               nsReflowStatus&          aStatus,
4006:                               nsOverflowContinuationTracker* aTracker)
   1: {
   1:   NS_PRECONDITION(aReflowState.frame == aKidFrame, "bad reflow state");
   1: 
   1:   nsresult  result;
   1: 
   1:   // Send the WillReflow() notification, and position the child frame
   1:   // and its view if requested
   1:   aKidFrame->WillReflow(aPresContext);
   1: 
   1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_FRAME)) {
   1:     aKidFrame->SetPosition(nsPoint(aX, aY));
   1:   }
   1: 
   1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
   1:     PositionFrameView(aKidFrame);
   1:   }
   1: 
   1:   // Reflow the child frame
   1:   result = aKidFrame->Reflow(aPresContext, aDesiredSize, aReflowState,
   1:                              aStatus);
   1: 
   1:   // If the reflow was successful and the child frame is complete, delete any
   1:   // next-in-flows
4006:   if (NS_SUCCEEDED(result) && NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
   1:     nsIFrame* kidNextInFlow = aKidFrame->GetNextInFlow();
   1:     if (nsnull != kidNextInFlow) {
   1:       // Remove all of the childs next-in-flows. Make sure that we ask
   1:       // the right parent to do the removal (it's possible that the
   1:       // parent is not this because we are executing pullup code)
6521:       if (aTracker) aTracker->Finish(aKidFrame);
3233:       static_cast<nsContainerFrame*>(kidNextInFlow->GetParent())
   1:         ->DeleteNextInFlowChild(aPresContext, kidNextInFlow);
   1:     }
   1:   }
   1:   return result;
   1: }
   1: 
   1: 
   1: /**
   1:  * Position the views of |aFrame|'s descendants. A container frame
   1:  * should call this method if it moves a frame after |Reflow|.
   1:  */
   1: void
   1: nsContainerFrame::PositionChildViews(nsIFrame* aFrame)
   1: {
   1:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
   1:     return;
   1:   }
   1: 
   1:   nsIAtom*  childListName = nsnull;
   1:   PRInt32   childListIndex = 0;
   1: 
   1:   do {
   1:     // Recursively walk aFrame's child frames
   1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
   1:     while (childFrame) {
   1:       // Position the frame's view (if it has one) otherwise recursively
   1:       // process its children
   1:       if (childFrame->HasView()) {
   1:         PositionFrameView(childFrame);
   1:       } else {
   1:         PositionChildViews(childFrame);
   1:       }
   1: 
   1:       // Get the next sibling child frame
   1:       childFrame = childFrame->GetNextSibling();
   1:     }
   1: 
3129:     // also process the additional child lists, but skip the popup list as the
3129:     // view for popups is managed by the parent. Currently only nsMenuFrame
3129:     // has a popupList and during layout will call nsMenuPopupFrame::AdjustView.
3129:     do {
   1:       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
3129:     } while (childListName == nsGkAtoms::popupList);
   1:   } while (childListName);
   1: }
   1: 
   1: /**
   1:  * The second half of frame reflow. Does the following:
   1:  * - sets the frame's bounds
   1:  * - sizes and positions (if requested) the frame's view. If the frame's final
   1:  *   position differs from the current position and the frame itself does not
   1:  *   have a view, then any child frames with views are positioned so they stay
   1:  *   in sync
   1:  * - sets the view's visibility, opacity, content transparency, and clip
   1:  * - invoked the DidReflow() function
   1:  *
   1:  * Flags:
   1:  * NS_FRAME_NO_MOVE_FRAME - don't move the frame. aX and aY are ignored in this
   1:  *    case. Also implies NS_FRAME_NO_MOVE_VIEW
   1:  * NS_FRAME_NO_MOVE_VIEW - don't position the frame's view. Set this if you
   1:  *    don't want to automatically sync the frame and view
   1:  * NS_FRAME_NO_SIZE_VIEW - don't size the frame's view
   1:  */
   1: nsresult
   1: nsContainerFrame::FinishReflowChild(nsIFrame*                 aKidFrame,
   1:                                     nsPresContext*            aPresContext,
   1:                                     const nsHTMLReflowState*  aReflowState,
   1:                                     nsHTMLReflowMetrics&      aDesiredSize,
   1:                                     nscoord                   aX,
   1:                                     nscoord                   aY,
   1:                                     PRUint32                  aFlags)
   1: {
   1:   nsPoint curOrigin = aKidFrame->GetPosition();
   1:   nsRect  bounds(aX, aY, aDesiredSize.width, aDesiredSize.height);
   1: 
   1:   aKidFrame->SetRect(bounds);
   1: 
   1:   if (aKidFrame->HasView()) {
   1:     nsIView* view = aKidFrame->GetView();
   1:     // Make sure the frame's view is properly sized and positioned and has
   1:     // things like opacity correct
   1:     SyncFrameViewAfterReflow(aPresContext, aKidFrame, view,
   1:                              &aDesiredSize.mOverflowArea,
   1:                              aFlags);
   1:   }
   1: 
   1:   if (!(aFlags & NS_FRAME_NO_MOVE_VIEW) &&
   1:       (curOrigin.x != aX || curOrigin.y != aY)) {
   1:     if (!aKidFrame->HasView()) {
   1:       // If the frame has moved, then we need to make sure any child views are
   1:       // correctly positioned
   1:       PositionChildViews(aKidFrame);
   1:     }
   1: 
   1:     // We also need to redraw everything associated with the frame
   1:     // because if the frame's Reflow issued any invalidates, then they
   1:     // will be at the wrong offset ... note that this includes
   1:     // invalidates issued against the frame's children, so we need to
   1:     // invalidate the overflow area too.
   1:     aKidFrame->Invalidate(aDesiredSize.mOverflowArea);
   1:   }
   1:   
   1:   return aKidFrame->DidReflow(aPresContext, aReflowState, NS_FRAME_REFLOW_FINISHED);
   1: }
   1: 
4006: nsresult
4006: nsContainerFrame::ReflowOverflowContainerChildren(nsPresContext*           aPresContext,
4006:                                                   const nsHTMLReflowState& aReflowState,
4006:                                                   nsRect&                  aOverflowRect,
4006:                                                   PRUint32                 aFlags,
4006:                                                   nsReflowStatus&          aStatus)
4006: {
4006:   NS_PRECONDITION(aPresContext, "null pointer");
4006:   nsresult rv = NS_OK;
4006: 
4006:   nsFrameList* overflowContainers =
4006:                GetPropTableFrames(aPresContext,
4006:                                   nsGkAtoms::overflowContainersProperty);
4006: 
4006:   NS_ASSERTION(!(overflowContainers && GetPrevInFlow()
4006:                  && static_cast<nsContainerFrame*>(GetPrevInFlow())
4006:                       ->GetPropTableFrames(aPresContext,
4006:                           nsGkAtoms::excessOverflowContainersProperty)),
4006:                "conflicting overflow containers lists");
4006: 
4006:   if (!overflowContainers) {
4006:     // Drain excess from previnflow
4006:     nsContainerFrame* prev = (nsContainerFrame*) GetPrevInFlow();
4006:     if (prev) {
4006:       nsFrameList* excessFrames =
4006:         prev->RemovePropTableFrames(aPresContext,
4006:                 nsGkAtoms::excessOverflowContainersProperty);
4006:       if (excessFrames) {
4006:         nsFrameList reparenter;
4006:         reparenter.InsertFrames(this, nsnull, excessFrames->FirstChild());
4006:         nsHTMLContainerFrame::ReparentFrameViewList(aPresContext,
4006:                                                     excessFrames->FirstChild(),
4006:                                                     prev, this);
4006:         overflowContainers = excessFrames;
4006:         rv = SetPropTableFrames(aPresContext, overflowContainers,
4006:                                 nsGkAtoms::overflowContainersProperty);
4006:         if (NS_FAILED(rv)) {
4006:           excessFrames->DestroyFrames();
4006:           delete excessFrames;
4006:           return rv;
4006:         }
4006:       }
4006:     }
4006:   }
4006: 
4006:   if (!overflowContainers)
4006:     return NS_OK; // nothing to reflow
4006: 
6521:   nsOverflowContinuationTracker tracker(aPresContext, this, PR_FALSE, PR_FALSE);
4006:   for (nsIFrame* frame = overflowContainers->FirstChild(); frame;
4006:        frame = frame->GetNextSibling()) {
4006:     if (NS_SUBTREE_DIRTY(frame)) {
4006:       // Get prev-in-flow
4006:       nsIFrame* prevInFlow = frame->GetPrevInFlow();
4006:       NS_ASSERTION(prevInFlow,
4006:                    "overflow container frame must have a prev-in-flow");
4006:       NS_ASSERTION(frame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER,
4006:                    "overflow container frame must have overflow container bit set");
4006:       nsRect prevRect = prevInFlow->GetRect();
4006: 
4006:       // Initialize reflow params
4006:       nsSize availSpace(prevRect.width, aReflowState.availableHeight);
4006:       nsHTMLReflowMetrics desiredSize;
4006:       nsHTMLReflowState frameState(aPresContext, aReflowState,
4006:                                    frame, availSpace);
4006:       nsReflowStatus frameStatus = NS_FRAME_COMPLETE;
4006: 
6521:       // Cache old bounds
6521:       nsRect oldRect = frame->GetRect();
6521:       nsRect oldOverflow = frame->GetOverflowRect();
6521: 
4006:       // Reflow
4006:       rv = ReflowChild(frame, aPresContext, desiredSize, frameState,
6521:                        prevRect.x, 0, aFlags, frameStatus, &tracker);
4006:       NS_ENSURE_SUCCESS(rv, rv);
4006:       //XXXfr Do we need to override any shrinkwrap effects here?
4006:       // e.g. desiredSize.width = prevRect.width;
4006:       rv = FinishReflowChild(frame, aPresContext, &frameState, desiredSize,
4006:                              prevRect.x, 0, aFlags);
4006:       NS_ENSURE_SUCCESS(rv, rv);
4006: 
6521:       // Invalidate if there was a position or size change
6521:       nsRect rect = frame->GetRect();
6521:       if (rect != oldRect) {
6521:         nsRect dirtyRect = oldOverflow;
6521:         dirtyRect.MoveBy(oldRect.x, oldRect.y);
6521:         Invalidate(dirtyRect);
6521: 
6521:         dirtyRect = frame->GetOverflowRect();
6521:         dirtyRect.MoveBy(rect.x, rect.y);
6521:         Invalidate(dirtyRect);
6521:       }
6521: 
4006:       // Handle continuations
6521:       if (!NS_FRAME_IS_FULLY_COMPLETE(frameStatus)) {
6521:         if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
6521:           // Abspos frames can't cause their parent to be incomplete,
6521:           // only overflow incomplete.
6521:           NS_FRAME_SET_OVERFLOW_INCOMPLETE(frameStatus);
6521:         }
6521:         else {
4006:           NS_ASSERTION(NS_FRAME_IS_COMPLETE(frameStatus),
4006:                        "overflow container frames can't be incomplete, only overflow-incomplete");
6521:         }
6521: 
4006:         // Acquire a next-in-flow, creating it if necessary
4006:         nsIFrame* nif = frame->GetNextInFlow();
4006:         if (!nif) {
4006:           rv = nsHTMLContainerFrame::CreateNextInFlow(aPresContext, this,
4006:                                                       frame, nif);
4006:           NS_ENSURE_SUCCESS(rv, rv);
4006:           NS_ASSERTION(frameStatus & NS_FRAME_REFLOW_NEXTINFLOW,
4006:                        "Someone forgot a REFLOW_NEXTINFLOW flag");
4006:           frame->SetNextSibling(nif->GetNextSibling());
4006:           nif->SetNextSibling(nsnull);
4006:         }
4006:         else if (!(nif->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
4006:           // used to be a normal next-in-flow; steal it from the child list
4006:           rv = static_cast<nsContainerFrame*>(nif->GetParent())
4006:                  ->StealFrame(aPresContext, nif);
4006:           NS_ENSURE_SUCCESS(rv, rv);
4006:         }
4006: 
4006:         tracker.Insert(nif, frameStatus);
4006:       }
4006:       aStatus = NS_FRAME_MERGE_INCOMPLETE(aStatus, frameStatus);
4006:       // At this point it would be nice to assert !frame->GetOverflowRect().IsEmpty(),
4006:       // but we have some unsplittable frames that, when taller than
4006:       // availableHeight will push zero-height content into a next-in-flow.
4006:     }
4006:     else {
4006:       tracker.Skip(frame, aStatus);
4006:     }
4006:     ConsiderChildOverflow(aOverflowRect, frame);
4006:   }
4006: 
4006:   return NS_OK;
4006: }
4006: 
4006: void
4006: nsContainerFrame::DisplayOverflowContainers(nsDisplayListBuilder*   aBuilder,
4006:                                             const nsRect&           aDirtyRect,
4006:                                             const nsDisplayListSet& aLists)
4006: {
4006:   nsFrameList* overflowconts = GetPropTableFrames(PresContext(),
4006:                                  nsGkAtoms::overflowContainersProperty);
4006:   if (overflowconts) {
4006:     for (nsIFrame* frame = overflowconts->FirstChild(); frame;
4006:          frame = frame->GetNextSibling()) {
4006:       BuildDisplayListForChild(aBuilder, frame, aDirtyRect, aLists);
4006:     }
4006:   }
4006: }
4006: 
4006: nsresult
4006: nsContainerFrame::StealFrame(nsPresContext* aPresContext,
4006:                              nsIFrame*      aChild,
4006:                              PRBool         aForceNormal)
4006: {
4006:   PRBool removed = PR_TRUE;
4006:   if ((aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
4006:       && !aForceNormal) {
4006:     // Try removing from the overflow container list
4006:     if (!RemovePropTableFrame(aPresContext, aChild,
4006:                               nsGkAtoms::overflowContainersProperty)) {
4006:       // It must be in the excess overflow container list
4006:       removed = RemovePropTableFrame(aPresContext, aChild,
4006:                   nsGkAtoms::excessOverflowContainersProperty);
4006:     }
4006:   }
4006:   else {
4006:     if (!mFrames.RemoveFrame(aChild)) {
4006:       // We didn't find the child in the parent's principal child list.
4006:       // Maybe it's on the overflow list?
4006:       nsFrameList frameList(GetOverflowFrames(aPresContext, PR_TRUE));
4006:       removed = frameList.RemoveFrame(aChild);
4006:       if (frameList.NotEmpty()) {
4006:         nsresult rv = SetOverflowFrames(aPresContext, frameList.FirstChild());
4006:         NS_ENSURE_SUCCESS(rv, rv);
4006:       }
4006:     }
4006:   }
4006:   return (removed) ? NS_OK : NS_ERROR_UNEXPECTED;
4006: }
4006: 
   1: /**
   1:  * Remove and delete aNextInFlow and its next-in-flows. Updates the sibling and flow
   1:  * pointers
   1:  */
   1: void
   1: nsContainerFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
   1:                                         nsIFrame*      aNextInFlow)
   1: {
   1:   nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
   1:   NS_PRECONDITION(prevInFlow, "bad prev-in-flow");
   1: 
   1:   // If the next-in-flow has a next-in-flow then delete it, too (and
   1:   // delete it first).
   1:   // Do this in a loop so we don't overflow the stack for frames
   1:   // with very many next-in-flows
   1:   nsIFrame* nextNextInFlow = aNextInFlow->GetNextInFlow();
   1:   if (nextNextInFlow) {
   1:     nsAutoVoidArray frames;
   1:     for (nsIFrame* f = nextNextInFlow; f; f = f->GetNextInFlow()) {
   1:       frames.AppendElement(f);
   1:     }
   1:     for (PRInt32 i = frames.Count() - 1; i >= 0; --i) {
3233:       nsIFrame* delFrame = static_cast<nsIFrame*>(frames.ElementAt(i));
3233:       static_cast<nsContainerFrame*>(delFrame->GetParent())
   1:         ->DeleteNextInFlowChild(aPresContext, delFrame);
   1:     }
   1:   }
   1: 
6521:   aNextInFlow->Invalidate(aNextInFlow->GetOverflowRect());
6521: 
   1:   // Disconnect the next-in-flow from the flow list
   1:   nsSplittableFrame::BreakFromPrevFlow(aNextInFlow);
   1: 
   1:   // Take the next-in-flow out of the parent's child list
4006:   nsresult rv = StealFrame(aPresContext, aNextInFlow);
4006:   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failure");
   1: 
   1:   // Delete the next-in-flow frame and its descendants.
   1:   aNextInFlow->Destroy();
   1: 
   1:   NS_POSTCONDITION(!prevInFlow->GetNextInFlow(), "non null next-in-flow");
   1: }
   1: 
3107: /**
3107:  * Get the frames on the overflow list
3107:  */
   1: nsIFrame*
   1: nsContainerFrame::GetOverflowFrames(nsPresContext*  aPresContext,
   1:                                     PRBool          aRemoveProperty) const
   1: {
   1:   nsPropertyTable *propTable = aPresContext->PropertyTable();
   1:   if (aRemoveProperty) {
   1:     return (nsIFrame*) propTable->UnsetProperty(this,
   1:                                                 nsGkAtoms::overflowProperty);
   1:   }
   1:   return (nsIFrame*) propTable->GetProperty(this,
   1:                                             nsGkAtoms::overflowProperty);
   1: }
   1: 
   1: // Destructor function for the overflow frame property
   1: static void
   1: DestroyOverflowFrames(void*           aFrame,
   1:                       nsIAtom*        aPropertyName,
   1:                       void*           aPropertyValue,
   1:                       void*           aDtorData)
   1: {
   1:   if (aPropertyValue) {
   1:     nsFrameList frames((nsIFrame*)aPropertyValue);
   1: 
   1:     frames.DestroyFrames();
   1:   }
   1: }
   1: 
3107: /**
3107:  * Set the frames on the overflow list
3107:  */
   1: nsresult
   1: nsContainerFrame::SetOverflowFrames(nsPresContext* aPresContext,
   1:                                     nsIFrame*       aOverflowFrames)
   1: {
   1:   nsresult rv =
   1:     aPresContext->PropertyTable()->SetProperty(this,
   1:                                                nsGkAtoms::overflowProperty,
   1:                                                aOverflowFrames,
   1:                                                DestroyOverflowFrames,
   1:                                                nsnull);
   1: 
   1:   // Verify that we didn't overwrite an existing overflow list
   1:   NS_ASSERTION(rv != NS_PROPTABLE_PROP_OVERWRITTEN, "existing overflow list");
   1: 
   1:   return rv;
   1: }
   1: 
4006: // Destructor function for the proptable-stored framelists
4006: static void
4006: DestroyFrameList(void*           aFrame,
4006:                  nsIAtom*        aPropertyName,
4006:                  void*           aPropertyValue,
4006:                  void*           aDtorData)
4006: {
4006:   if (aPropertyValue)
4006:     static_cast<nsFrameList*>(aPropertyValue)->Destroy();
4006: }
4006: 
4006: nsFrameList*
4006: nsContainerFrame::GetPropTableFrames(nsPresContext*  aPresContext,
4006:                                      nsIAtom*        aPropID) const
4006: {
4006:   nsPropertyTable* propTable = aPresContext->PropertyTable();
4006:   return static_cast<nsFrameList*>(propTable->GetProperty(this, aPropID));
4006: }
4006: 
4006: nsFrameList*
4006: nsContainerFrame::RemovePropTableFrames(nsPresContext*  aPresContext,
4006:                                         nsIAtom*        aPropID) const
4006: {
4006:   nsPropertyTable* propTable = aPresContext->PropertyTable();
4006:   return static_cast<nsFrameList*>(propTable->UnsetProperty(this, aPropID));
4006: }
4006: 
4006: PRBool
4006: nsContainerFrame::RemovePropTableFrame(nsPresContext*  aPresContext,
4006:                                        nsIFrame*       aFrame,
4006:                                        nsIAtom*        aPropID) const
4006: {
4006:   nsFrameList* frameList = RemovePropTableFrames(aPresContext, aPropID);
9422:   if (!frameList) {
9422:     // No such list
9422:     return PR_FALSE;
9422:   }
9422:   if (!frameList->RemoveFrame(aFrame)) {
9422:     // Found list, but it doesn't have the frame. Put list back.
9422:     SetPropTableFrames(aPresContext, frameList, aPropID);
4006:     return PR_FALSE;
4006:   }
4006: 
4006:   if (frameList->IsEmpty()) {
4006:     // Removed frame and now list is empty. Delete it.
4006:     delete frameList;
4006:   }
4006:   else {
4006:     // Removed frame, but list not empty. Put it back.
4006:     SetPropTableFrames(aPresContext, frameList, aPropID);
4006:   }
4006:   return PR_TRUE;
4006: }
4006: 
4006: nsresult
4006: nsContainerFrame::SetPropTableFrames(nsPresContext*  aPresContext,
4006:                                      nsFrameList*    aFrameList,
4006:                                      nsIAtom*        aPropID) const
4006: {
4006:   NS_PRECONDITION(aPresContext && aPropID && aFrameList, "null ptr");
4006:   nsresult rv = aPresContext->PropertyTable()->SetProperty(this, aPropID,
4006:                   aFrameList, DestroyFrameList, nsnull);
4006:   NS_ASSERTION(rv != NS_PROPTABLE_PROP_OVERWRITTEN, "existing framelist");
4006:   return rv;
4006: }
4006: 
   1: /**
   1:  * Push aFromChild and its next siblings to the next-in-flow. Change the
   1:  * geometric parent of each frame that's pushed. If there is no next-in-flow
   1:  * the frames are placed on the overflow list (and the geometric parent is
   1:  * left unchanged).
   1:  *
   1:  * Updates the next-in-flow's child count. Does <b>not</b> update the
   1:  * pusher's child count.
   1:  *
   1:  * @param   aFromChild the first child frame to push. It is disconnected from
   1:  *            aPrevSibling
   1:  * @param   aPrevSibling aFromChild's previous sibling. Must not be null. It's
   1:  *            an error to push a parent's first child frame
   1:  */
   1: void
   1: nsContainerFrame::PushChildren(nsPresContext* aPresContext,
   1:                                nsIFrame*       aFromChild,
   1:                                nsIFrame*       aPrevSibling)
   1: {
   1:   NS_PRECONDITION(nsnull != aFromChild, "null pointer");
   1:   NS_PRECONDITION(nsnull != aPrevSibling, "pushing first child");
   1:   NS_PRECONDITION(aPrevSibling->GetNextSibling() == aFromChild, "bad prev sibling");
   1: 
   1:   // Disconnect aFromChild from its previous sibling
   1:   aPrevSibling->SetNextSibling(nsnull);
   1: 
   1:   if (nsnull != GetNextInFlow()) {
   1:     // XXX This is not a very good thing to do. If it gets removed
   1:     // then remove the copy of this routine that doesn't do this from
   1:     // nsInlineFrame.
   1:     nsContainerFrame* nextInFlow = (nsContainerFrame*)GetNextInFlow();
   1:     // When pushing and pulling frames we need to check for whether any
   1:     // views need to be reparented.
   1:     for (nsIFrame* f = aFromChild; f; f = f->GetNextSibling()) {
   1:       nsHTMLContainerFrame::ReparentFrameView(aPresContext, f, this, nextInFlow);
   1:     }
   1:     nextInFlow->mFrames.InsertFrames(nextInFlow, nsnull, aFromChild);
   1:   }
   1:   else {
   1:     // Add the frames to our overflow list
   1:     SetOverflowFrames(aPresContext, aFromChild);
   1:   }
   1: }
   1: 
   1: /**
   1:  * Moves any frames on the overflow lists (the prev-in-flow's overflow list and
   1:  * the receiver's overflow list) to the child list.
   1:  *
   1:  * Updates this frame's child count and content mapping.
   1:  *
   1:  * @return  PR_TRUE if any frames were moved and PR_FALSE otherwise
   1:  */
   1: PRBool
   1: nsContainerFrame::MoveOverflowToChildList(nsPresContext* aPresContext)
   1: {
   1:   PRBool result = PR_FALSE;
   1: 
   1:   // Check for an overflow list with our prev-in-flow
   1:   nsContainerFrame* prevInFlow = (nsContainerFrame*)GetPrevInFlow();
   1:   if (nsnull != prevInFlow) {
   1:     nsIFrame* prevOverflowFrames = prevInFlow->GetOverflowFrames(aPresContext,
   1:                                                                  PR_TRUE);
   1:     if (prevOverflowFrames) {
   1:       NS_ASSERTION(mFrames.IsEmpty(), "bad overflow list");
   1:       // When pushing and pulling frames we need to check for whether any
   1:       // views need to be reparented.
   1:       for (nsIFrame* f = prevOverflowFrames; f; f = f->GetNextSibling()) {
   1:         nsHTMLContainerFrame::ReparentFrameView(aPresContext, f, prevInFlow, this);
   1:       }
   1:       mFrames.InsertFrames(this, nsnull, prevOverflowFrames);
   1:       result = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   // It's also possible that we have an overflow list for ourselves
   1:   nsIFrame* overflowFrames = GetOverflowFrames(aPresContext, PR_TRUE);
   1:   if (overflowFrames) {
   1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
   1:     mFrames.AppendFrames(nsnull, overflowFrames);
   1:     result = PR_TRUE;
   1:   }
   1:   return result;
   1: }
   1: 
4006: nsOverflowContinuationTracker::nsOverflowContinuationTracker(nsPresContext*    aPresContext,
4006:                                                              nsContainerFrame* aFrame,
6521:                                                              PRBool            aWalkOOFFrames,
4006:                                                              PRBool            aSkipOverflowContainerChildren)
4006:   : mOverflowContList(nsnull),
4006:     mPrevOverflowCont(nsnull),
4006:     mSentry(nsnull),
4006:     mParent(aFrame),
6521:     mSkipOverflowContainerChildren(aSkipOverflowContainerChildren),
6521:     mWalkOOFFrames(aWalkOOFFrames)
4006: {
4006:   NS_PRECONDITION(aFrame, "null frame pointer");
4006:   nsContainerFrame* next = static_cast<nsContainerFrame*>
4006:                              (aFrame->GetNextInFlow());
4006:   if (next) {
4006:     mOverflowContList =
4006:       next->GetPropTableFrames(aPresContext,
4006:                                nsGkAtoms::overflowContainersProperty);
4006:     if (mOverflowContList) {
4006:       mParent = next;
4006:       SetUpListWalker();
4006:     }
4006:   }
6758:   if (!mOverflowContList) {
4006:     mOverflowContList =
4006:       mParent->GetPropTableFrames(aPresContext,
4006:                                   nsGkAtoms::excessOverflowContainersProperty);
4006:     if (mOverflowContList) {
4006:       SetUpListWalker();
4006:     }
4006:   }
4006: }
4006: 
4006: /**
4006:  * Helper function to walk past overflow continuations whose prev-in-flow
4006:  * isn't a normal child and to set mSentry and mPrevOverflowCont correctly.
4006:  */
4006: void
4006: nsOverflowContinuationTracker::SetUpListWalker()
4006: {
4006:   NS_ASSERTION(!mSentry && !mPrevOverflowCont,
4006:                "forgot to reset mSentry or mPrevOverflowCont");
4006:   if (mOverflowContList) {
4006:     nsIFrame* cur = mOverflowContList->FirstChild();
4006:     if (mSkipOverflowContainerChildren) {
4006:       while (cur && (cur->GetPrevInFlow()->GetStateBits()
4006:                      & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
4006:         mPrevOverflowCont = cur;
4006:         cur = cur->GetNextSibling();
4006:       }
8531:       while (cur && (!(cur->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
8531:                      == mWalkOOFFrames)) {
6521:         mPrevOverflowCont = cur;
6521:         cur = cur->GetNextSibling();
6521:       }
4006:     }
4006:     if (cur) {
4006:       mSentry = cur->GetPrevInFlow();
4006:     }
4006:   }
4006: }
4006: 
4006: /**
4006:  * Helper function to step forward through the overflow continuations list.
6521:  * Sets mSentry and mPrevOverflowCont, skipping over OOF or non-OOF frames
6521:  * as appropriate. May only be called when we have already set up an
6521:  * mOverflowContList; mOverflowContList cannot be null.
4006:  */
4006: void
4006: nsOverflowContinuationTracker::StepForward()
4006: {
4006:   NS_PRECONDITION(mOverflowContList, "null list");
4006: 
4006:   // Step forward
4006:   if (mPrevOverflowCont) {
4006:     mPrevOverflowCont = mPrevOverflowCont->GetNextSibling();
4006:   }
4006:   else {
4006:     mPrevOverflowCont = mOverflowContList->FirstChild();
4006:   }
4006: 
6521:   // Skip over oof or non-oof frames as appropriate
6521:   if (mSkipOverflowContainerChildren) {
6521:     nsIFrame* cur = mPrevOverflowCont->GetNextSibling();
8531:     while (cur && (!(cur->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
8531:                    == mWalkOOFFrames)) {
6521:       mPrevOverflowCont = cur;
6521:       cur = cur->GetNextSibling();
6521:     }
6521:   }
6521: 
4006:   // Set up the sentry
4006:   mSentry = (mPrevOverflowCont->GetNextSibling())
4006:             ? mPrevOverflowCont->GetNextSibling()->GetPrevInFlow()
4006:             : nsnull;
4006: }
4006: 
4006: nsresult
4006: nsOverflowContinuationTracker::Insert(nsIFrame*       aOverflowCont,
4006:                                       nsReflowStatus& aReflowStatus)
4006: {
4006:   NS_PRECONDITION(aOverflowCont, "null frame pointer");
8531:   NS_PRECONDITION(!mSkipOverflowContainerChildren || mWalkOOFFrames ==
8531:                   !!(aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
8531:                   "shouldn't insert frame that doesn't match walker type");
4006:   NS_PRECONDITION(aOverflowCont->GetPrevInFlow(),
4006:                   "overflow containers must have a prev-in-flow");
4006:   nsresult rv = NS_OK;
4006:   if (!mSentry || aOverflowCont != mSentry->GetNextInFlow()) {
4006:     // Not in our list, so we need to add it
4006:     nsPresContext* presContext = aOverflowCont->PresContext();
8049:     if (aOverflowCont->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
8049:       // aOverflowCont is in some other overflow container list,
4006:       // steal it first
8049:       NS_ASSERTION(!(mOverflowContList &&
8049:                      mOverflowContList->ContainsFrame(aOverflowCont)),
8049:                    "overflow containers out of order");
4006:       rv = static_cast<nsContainerFrame*>(aOverflowCont->GetParent())
4006:              ->StealFrame(presContext, aOverflowCont);
4006:       NS_ENSURE_SUCCESS(rv, rv);
4006:     }
4006:     else {
4006:       aOverflowCont->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
4006:     }
4006:     if (!mOverflowContList) {
4006:       mOverflowContList = new nsFrameList();
4006:       rv = mParent->SetPropTableFrames(presContext,
4006:              mOverflowContList, nsGkAtoms::excessOverflowContainersProperty);
4006:       NS_ENSURE_SUCCESS(rv, rv);
4006:       SetUpListWalker();
4006:     }
4006:     if (aOverflowCont->GetParent() != mParent) {
4006:       nsHTMLContainerFrame::ReparentFrameView(presContext, aOverflowCont,
4006:                                               aOverflowCont->GetParent(),
4006:                                               mParent);
4006:     }
4006:     mOverflowContList->InsertFrame(mParent, mPrevOverflowCont, aOverflowCont);
4006:     aReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
4006:   }
4006: 
4006:   // If we need to reflow it, mark it dirty
4006:   if (aReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW)
4006:     aOverflowCont->AddStateBits(NS_FRAME_IS_DIRTY);
4006: 
4006:   // It's in our list, just step forward
4006:   StepForward();
8531:   NS_ASSERTION(mPrevOverflowCont == aOverflowCont ||
8531:                (mSkipOverflowContainerChildren &&
8531:                 (mPrevOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW) !=
8531:                 (aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW)),
8531:               "OverflowContTracker in unexpected state");
4006:   return rv;
4006: }
4006: 
4006: void
4006: nsOverflowContinuationTracker::Finish(nsIFrame* aChild)
4006: {
4006:   NS_PRECONDITION(aChild, "null ptr");
4006:   NS_PRECONDITION(aChild->GetNextInFlow(),
6521:                 "supposed to call Finish *before* deleting next-in-flow!");
4006:   if (aChild == mSentry) {
4006:     // Make sure we drop all references if this was the only frame
4006:     // in the overflow containers list
4006:     if (mOverflowContList->FirstChild() == aChild->GetNextInFlow()
4006:         && !aChild->GetNextInFlow()->GetNextSibling()) {
4006:       mOverflowContList = nsnull;
4006:       mPrevOverflowCont = nsnull;
4006:       mSentry = nsnull;
4006:       mParent = static_cast<nsContainerFrame*>(aChild->GetParent());
4006:     }
4006:     else {
8531:       // Step past aChild
6521:       nsIFrame* prevOverflowCont = mPrevOverflowCont;
6521:       StepForward();
8733:       if (mPrevOverflowCont == aChild->GetNextInFlow()) {
8531:         // Pull mPrevOverflowChild back to aChild's prevSibling:
8531:         // aChild will be removed from our list by our caller
6521:         mPrevOverflowCont = prevOverflowCont;
4006:       }
4006:     }
4006:   }
8531: }
4006: 
   1: /////////////////////////////////////////////////////////////////////////////
   1: // Debugging
   1: 
   1: #ifdef NS_DEBUG
   1: NS_IMETHODIMP
   1: nsContainerFrame::List(FILE* out, PRInt32 aIndent) const
   1: {
   1:   IndentBy(out, aIndent);
   1:   ListTag(out);
   1: #ifdef DEBUG_waterson
3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
   1: #endif
   1:   if (HasView()) {
3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
   1:   }
   1:   if (nsnull != mNextSibling) {
3233:     fprintf(out, " next=%p", static_cast<void*>(mNextSibling));
   1:   }
   1:   if (nsnull != GetPrevContinuation()) {
3233:     fprintf(out, " prev-continuation=%p", static_cast<void*>(GetPrevContinuation()));
   1:   }
   1:   if (nsnull != GetNextContinuation()) {
3233:     fprintf(out, " next-continuation=%p", static_cast<void*>(GetNextContinuation()));
   1:   }
   1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
   1:   if (0 != mState) {
   1:     fprintf(out, " [state=%08x]", mState);
   1:   }
3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
3233:   nsContainerFrame* f = const_cast<nsContainerFrame*>(this);
   1:   nsRect* overflowArea = f->GetOverflowAreaProperty(PR_FALSE);
   1:   if (overflowArea) {
   1:     fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea->x, overflowArea->y,
   1:             overflowArea->width, overflowArea->height);
   1:   }
3233:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
   1:   nsIAtom* pseudoTag = mStyleContext->GetPseudoType();
   1:   if (pseudoTag) {
   1:     nsAutoString atomString;
   1:     pseudoTag->ToString(atomString);
   1:     fprintf(out, " pst=%s",
   1:             NS_LossyConvertUTF16toASCII(atomString).get());
   1:   }
   1: 
   1:   // Output the children
   1:   nsIAtom* listName = nsnull;
   1:   PRInt32 listIndex = 0;
   1:   PRBool outputOneList = PR_FALSE;
   1:   do {
   1:     nsIFrame* kid = GetFirstChild(listName);
   1:     if (nsnull != kid) {
   1:       if (outputOneList) {
   1:         IndentBy(out, aIndent);
   1:       }
   1:       outputOneList = PR_TRUE;
   1:       nsAutoString tmp;
   1:       if (nsnull != listName) {
   1:         listName->ToString(tmp);
   1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
   1:       }
   1:       fputs("<\n", out);
   1:       while (nsnull != kid) {
   1:         // Verify the child frame's parent frame pointer is correct
   1:         NS_ASSERTION(kid->GetParent() == (nsIFrame*)this, "bad parent frame pointer");
   1: 
   1:         // Have the child frame list
   1:         nsIFrameDebug*  frameDebug;
   1:         if (NS_SUCCEEDED(kid->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {
   1:           frameDebug->List(out, aIndent + 1);
   1:         }
   1:         kid = kid->GetNextSibling();
   1:       }
   1:       IndentBy(out, aIndent);
   1:       fputs(">\n", out);
   1:     }
   1:     listName = GetAdditionalChildListName(listIndex++);
   1:   } while(nsnull != listName);
   1: 
   1:   if (!outputOneList) {
   1:     fputs("<>\n", out);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: #endif
