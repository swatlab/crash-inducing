   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #ifndef nsIView_h___
   1: #define nsIView_h___
   1: 
   1: #include "nsCoord.h"
   1: #include "nsRect.h"
   1: #include "nsPoint.h"
   1: #include "nsIWidget.h"
   1: 
   1: class nsIViewManager;
   1: class nsIScrollableView;
   1: class nsViewManager;
   1: class nsView;
8292: class nsWeakView;
   1: 
   1: // Enumerated type to indicate the visibility of a layer.
   1: // hide - the layer is not shown.
   1: // show - the layer is shown irrespective of the visibility of 
   1: //        the layer's parent.
   1: enum nsViewVisibility {
   1:   nsViewVisibility_kHide = 0,
   1:   nsViewVisibility_kShow = 1
   1: };
   1: 
   1: // IID for the nsIView interface
8292: // 1b0215f7-f5d1-4574-9ab9-abdcceddb82e
   1: #define NS_IVIEW_IID    \
8292: { 0x1b0215f7, 0xf5d1, 0x4574, \
8292:   { 0x9a, 0xb9, 0xab, 0xdc, 0xce, 0xdd, 0xb8, 0x2e } }
   1: 
   1: // Public view flags are defined in this file
   1: #define NS_VIEW_FLAGS_PUBLIC              0x00FF
   1: // Private view flags are private to the view module,
   1: // and are defined in nsView.h
   1: #define NS_VIEW_FLAGS_PRIVATE             0xFF00
   1: 
   1: // Public view flags
   1: 
   1: // Indicates that the view is using auto z-indexing
   1: #define NS_VIEW_FLAG_AUTO_ZINDEX          0x0004
   1: 
   1: // Indicates that the view is a floating view.
   1: #define NS_VIEW_FLAG_FLOATING             0x0008
   1: 
   1: // If set it indicates that this view should be
   1: // displayed above z-index:auto views if this view 
   1: // is z-index:auto also
   1: #define NS_VIEW_FLAG_TOPMOST              0x0010
   1: 
8292: // If set, the view disowns the widget and leaves it up
8292: // to other code to destroy it.
8292: #define NS_VIEW_DISOWNS_WIDGET             0x0020
8292: 
   1: struct nsViewZIndex {
   1:   PRBool mIsAuto;
   1:   PRInt32 mZIndex;
   1:   PRBool mIsTopmost;
   1:   
   1:   nsViewZIndex(PRBool aIsAuto, PRInt32 aZIndex, PRBool aIsTopmost)
   1:     : mIsAuto(aIsAuto), mZIndex(aZIndex), mIsTopmost(aIsTopmost) {}
   1: };
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: /**
   1:  * View interface
   1:  *
   1:  * Views are NOT reference counted. Use the Destroy() member function to
   1:  * destroy a view.
   1:  *
   1:  * The lifetime of the view hierarchy is bounded by the lifetime of the
   1:  * view manager that owns the views.
   1:  *
   1:  * Most of the methods here are read-only. To set the corresponding properties
   1:  * of a view, go through nsIViewManager.
   1:  */
   1: 
   1: class nsIView
   1: {
   1: public:
   1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IVIEW_IID)
   1: 
   1:   /**
   1:    * See if this view is scrollable.
   1:    * @result an nsIScrollableView* if the view is scrollable, or nsnull if not.
   1:    */
   1:   virtual nsIScrollableView* ToScrollableView() { return nsnull; }
   1: 
   1:   /**
   1:    * Find the view for the given widget, if there is one.
   1:    * @return the view the widget belongs to, or null if the widget doesn't
   1:    * belong to any view.
   1:    */
   1:   static nsIView* GetViewFor(nsIWidget* aWidget);
   1: 
   1:   /**
   1:    * Get the view manager which "owns" the view.
   1:    * This method might require some expensive traversal work in the future. If you can get the
   1:    * view manager from somewhere else, do that instead.
   1:    * @result the view manager
   1:    */
   1:   nsIViewManager* GetViewManager() const
3233:   { return reinterpret_cast<nsIViewManager*>(mViewManager); }
   1: 
   1:   /**
   1:    * Destroy the view.
   1:    *
   1:    * The view destroys its child views, and destroys and releases its
   1:    * widget (if it has one).
   1:    *
   1:    * Also informs the view manager that the view is destroyed by calling
   1:    * SetRootView(NULL) if the view is the root view and calling RemoveChild()
   1:    * otherwise.
   1:    */
   1:   void Destroy();
   1: 
   1:   /**
   1:    * Called to get the position of a view.
   1:    * The specified coordinates are in the parent view's coordinate space.
   1:    * This is the (0, 0) origin of the coordinate space established by this view.
   1:    * @param x out parameter for x position
   1:    * @param y out parameter for y position
   1:    */
   1:   nsPoint GetPosition() const {
   1:     // Call ExternalIsRoot here so that we can get to it from other
   1:     // components
   1:     NS_ASSERTION(!ExternalIsRoot() || (mPosX == 0 && mPosY == 0),
   1:                  "root views should always have explicit position of (0,0)");
   1:     return nsPoint(mPosX, mPosY);
   1:   }
   1:   
   1:   /**
   1:    * Called to get the dimensions and position of the view's bounds.
   1:    * The view's bounds (x,y) are in the coordinate space of the parent view.
   1:    * The view's bounds (x,y) might not be the same as the view's position,
   1:    * if the view has content above or to the left of its origin.
   1:    * @param aBounds out parameter for bounds
   1:    */
   1:   nsRect GetBounds() const { return mDimBounds; }
   1: 
   1:   /**
   1:    * Get the offset between the coordinate systems of |this| and aOther.
   1:    * Adding the return value to a point in the coordinate system of |this|
   1:    * will transform the point to the coordinate system of aOther.
   1:    *
   1:    * If aOther is null, this will return the offset of |this| from the
   1:    * root of the viewmanager tree.
   1:    * 
   1:    * This function is fastest when aOther is an ancestor of |this|.
   1:    *
   1:    * NOTE: this actually returns the offset from aOther to |this|, but
   1:    * that offset is added to transform _coordinates_ from |this| to aOther.
   1:    */
   1:   nsPoint GetOffsetTo(const nsIView* aOther) const;
   1: 
   1:   /**
   1:    * Get the screen position of the view.
   1:    * @return the pixel position of the top-left of the view in screen
   1:    * coordinates.
   1:    */
   1:   nsIntPoint GetScreenPosition() const;
   1:   
   1:   /**
   1:    * Called to query the visibility state of a view.
   1:    * @result current visibility state
   1:    */
   1:   nsViewVisibility GetVisibility() const { return mVis; }
   1: 
   1:   /**
   1:    * Called to query the z-index of a view.
   1:    * The z-index is relative to all siblings of the view.
   1:    * @result mZIndex: explicit z-index value or 0 if none is set
   1:    *         mIsAuto: PR_TRUE if the view is zindex:auto
   1:    *         mIsTopMost: used when this view is zindex:auto
   1:    *                     PR_TRUE if the view is topmost when compared
   1:    *                     with another z-index:auto view
   1:    */
   1:   nsViewZIndex GetZIndex() const { return nsViewZIndex((mVFlags & NS_VIEW_FLAG_AUTO_ZINDEX) != 0,
   1:                                                        mZIndex,
   1:                                                        (mVFlags & NS_VIEW_FLAG_TOPMOST) != 0); }
   1: 
   1:   /**
   1:    * Get whether the view "floats" above all other views,
   1:    * which tells the compositor not to consider higher views in
   1:    * the view hierarchy that would geometrically intersect with
   1:    * this view. This is a hack, but it fixes some problems with
   1:    * views that need to be drawn in front of all other views.
   1:    * @result PR_TRUE if the view floats, PR_FALSE otherwise.
   1:    */
   1:   PRBool GetFloating() const { return (mVFlags & NS_VIEW_FLAG_FLOATING) != 0; }
   1: 
   1:   /**
   1:    * Called to query the parent of the view.
   1:    * @result view's parent
   1:    */
3233:   nsIView* GetParent() const { return reinterpret_cast<nsIView*>(mParent); }
   1: 
   1:   /**
   1:    * The view's first child is the child which is earliest in document order.
   1:    * @result first child
   1:    */
3233:   nsIView* GetFirstChild() const { return reinterpret_cast<nsIView*>(mFirstChild); }
   1: 
   1:   /**
   1:    * Called to query the next sibling of the view.
   1:    * @result view's next sibling
   1:    */
3233:   nsIView* GetNextSibling() const { return reinterpret_cast<nsIView*>(mNextSibling); }
   1: 
   1:   /**
   1:    * Set the view's link to client owned data.
   1:    * @param aData - data to associate with view. nsnull to disassociate
   1:    */
   1:   void SetClientData(void *aData) { mClientData = aData; }
   1: 
   1:   /**
   1:    * Query the view for it's link to client owned data.
   1:    * @result data associated with view or nsnull if there is none.
   1:    */
   1:   void* GetClientData() const { return mClientData; }
   1: 
   1:   /**
   1:    * Get the nearest widget in this view or a parent of this view and
   1:    * the offset from the widget's origin to this view's origin
   1:    * @param aOffset the offset from this view's origin to the widget's origin
   1:    * (usually positive)
   1:    * @return the widget closest to this view; can be null because some view trees
   1:    * don't have widgets at all (e.g., printing), but if any view in the view tree
   1:    * has a widget, then it's safe to assume this will not return null
   1:    * XXX Remove this 'virtual' when gfx+widget are merged into gklayout;
   1:    * Mac widget depends on this method, which is BOGUS!
   1:    */
   1:   virtual nsIWidget* GetNearestWidget(nsPoint* aOffset) const;
   1: 
   1:   /**
   1:    * Create a widget to associate with this view.
   1:    * @param aWindowIID IID for Widget type that this view
   1:    *        should have associated with it. if nsull, then no
   1:    *        width will be created for this view
   1:    * @param aWidgetInitData data used to initialize this view's widget before
   1:    *        its create is called.
   1:    * @param aNative native window that will be used as parent of
   1:    *        aWindowIID. if nsnull, then parent will be derived from
   1:    *        parent view and it's ancestors
   1:    * @param aWindowType is either content, UI or inherit from parent window.
   1:    *        This is used to expose what type of window this is to 
   1:    *        assistive technology like screen readers.
   1:    * @return error status
   1:    */
   1:   nsresult CreateWidget(const nsIID &aWindowIID,
   1:                         nsWidgetInitData *aWidgetInitData = nsnull,
   1:                         nsNativeWidget aNative = nsnull,
   1:                         PRBool aEnableDragDrop = PR_TRUE,
   1:                         PRBool aResetVisibility = PR_TRUE,
   1:                         nsContentType aWindowType = eContentTypeInherit);
   1: 
   1:   /**
   1:    * In 4.0, the "cutout" nature of a view is queryable.
   1:    * If we believe that all cutout view have a native widget, this
   1:    * could be a replacement.
   1:    * @param aWidget out parameter for widget that this view contains,
   1:    *        or nsnull if there is none.
   1:    */
   1:   nsIWidget* GetWidget() const { return mWindow; }
   1: 
   1:   /**
   1:    * Returns PR_TRUE if the view has a widget associated with it.
   1:    */
   1:   PRBool HasWidget() const { return mWindow != nsnull; }
   1: 
4577:   /**
4577:    * If called, will make the view disown the widget and leave it up
4577:    * to other code to destroy it.
4577:    */
4577:   void DisownWidget() {
8292:     mVFlags |= NS_VIEW_DISOWNS_WIDGET;
4577:   }
4577: 
   1: #ifdef DEBUG
   1:   /**
   1:    * Output debug info to FILE
   1:    * @param out output file handle
   1:    * @param aIndent indentation depth
   1:    * NOTE: virtual so that debugging tools not linked into gklayout can access it
   1:    */
   1:   virtual void List(FILE* out, PRInt32 aIndent = 0) const;
   1: #endif // DEBUG
   1: 
   1:   /**
   1:    * @result true iff this is the root view for its view manager
   1:    */
   1:   PRBool IsRoot() const;
   1: 
   1:   virtual PRBool ExternalIsRoot() const;
   1: 
8292:   void SetDeletionObserver(nsWeakView* aDeletionObserver);
   1: protected:
8292:   friend class nsWeakView;
   1:   nsViewManager     *mViewManager;
   1:   nsView            *mParent;
   1:   nsIWidget         *mWindow;
   1:   nsView            *mNextSibling;
   1:   nsView            *mFirstChild;
   1:   void              *mClientData;
   1:   PRInt32           mZIndex;
   1:   nsViewVisibility  mVis;
   1:   nscoord           mPosX, mPosY;
   1:   nsRect            mDimBounds; // relative to parent
   1:   float             mOpacity;
   1:   PRUint32          mVFlags;
8292:   nsWeakView*       mDeletionObserver;
   1: 
   1:   virtual ~nsIView() {}
   1: };
   1: 
   1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIView, NS_IVIEW_IID)
   1: 
8292: // nsWeakViews must *not* be used in heap!
8292: class nsWeakView
8292: {
8292: public:
8292:   nsWeakView(nsIView* aView) : mPrev(nsnull), mView(aView)
8292:   {
8292:     if (mView) {
8292:       mView->SetDeletionObserver(this);
8292:     }
8292:   }
8292: 
8292:   ~nsWeakView()
8292:   {
8292:     if (mView) {
8292:       NS_ASSERTION(mView->mDeletionObserver == this,
8292:                    "nsWeakViews deleted in wrong order!");
8292:       // Clear deletion observer temporarily.
8292:       mView->SetDeletionObserver(nsnull);
8292:       // Put back the previous deletion observer.
8292:       mView->SetDeletionObserver(mPrev);
8292:     }
8292:   }
8292: 
8292:   PRBool IsAlive() { return !!mView; }
8292: 
8292:   nsIView* GetView() { return mView; }
8292: 
8292:   void SetPrevious(nsWeakView* aWeakView) { mPrev = aWeakView; }
8292: 
8292:   void Clear()
8292:   {
8292:     if (mPrev) {
8292:       mPrev->Clear();
8292:     }
8292:     mView = nsnull;
8292:   }
8292: private:
8292:   static void* operator new(size_t) CPP_THROW_NEW { return 0; }
8292:   static void operator delete(void*, size_t) {}
8292:   nsWeakView* mPrev;
8292:   nsIView*    mView;
8292: };
8292: 
   1: #endif
