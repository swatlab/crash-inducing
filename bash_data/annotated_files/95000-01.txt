15751: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
15751: /* vim:set ts=2 sw=2 sts=2 et cindent: */
15751: /* ***** BEGIN LICENSE BLOCK *****
15751:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15751:  *
15751:  * The contents of this file are subject to the Mozilla Public License Version
15751:  * 1.1 (the "License"); you may not use this file except in compliance with
15751:  * the License. You may obtain a copy of the License at
15751:  * http://www.mozilla.org/MPL/
15751:  *
15751:  * Software distributed under the License is distributed on an "AS IS" basis,
15751:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15751:  * for the specific language governing rights and limitations under the
15751:  * License.
15751:  *
15751:  * The Original Code is Mozilla code.
15751:  *
15751:  * The Initial Developer of the Original Code is the Mozilla Corporation.
15751:  * Portions created by the Initial Developer are Copyright (C) 2007
15751:  * the Initial Developer. All Rights Reserved.
15751:  *
15751:  * Contributor(s):
15751:  *  Chris Double <chris.double@double.co.nz>
15751:  *
15751:  * Alternatively, the contents of this file may be used under the terms of
15751:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15751:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15751:  * in which case the provisions of the GPL or the LGPL are applicable instead
15751:  * of those above. If you wish to allow use of your version of this file only
15751:  * under the terms of either the GPL or the LGPL, and not to allow others to
15751:  * use your version of this file under the terms of the MPL, indicate your
15751:  * decision by deleting the provisions above and replace them with the notice
15751:  * and other provisions required by the GPL or the LGPL. If you do not delete
15751:  * the provisions above, a recipient may use your version of this file under
15751:  * the terms of any one of the MPL, the GPL or the LGPL.
15751:  *
15751:  * ***** END LICENSE BLOCK ***** */
15751: 
15751: /* rendering object for the HTML <video> element */
15751: 
15751: #include "nsHTMLParts.h"
15751: #include "nsCOMPtr.h"
15751: #include "nsIServiceManager.h"
15751: #include "nsGkAtoms.h"
15751: 
15751: #include "nsVideoFrame.h"
15751: #include "nsHTMLVideoElement.h"
15751: #include "nsIDOMHTMLVideoElement.h"
15751: #include "nsDisplayList.h"
15751: #include "gfxContext.h"
15751: #include "gfxImageSurface.h"
15751: #include "nsPresContext.h"
15751: #include "nsTransform2D.h"
15751: #include "nsContentCreatorFunctions.h"
15751: #include "nsBoxLayoutState.h"
15751: #include "nsBoxFrame.h"
29590: #include "nsImageFrame.h"
29590: #include "nsIImageLoadingContent.h"
52294: #include "nsCSSRendering.h"
75263: #include "nsContentUtils.h"
15751: 
27515: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
27515: #endif
27515: 
48691: using namespace mozilla;
39499: using namespace mozilla::layers;
71121: using namespace mozilla::dom;
39499: 
15751: nsIFrame*
15751: NS_NewHTMLVideoFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
15751: {
15751:   return new (aPresShell) nsVideoFrame(aContext);
15751: }
15751: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsVideoFrame)
32423: 
15751: nsVideoFrame::nsVideoFrame(nsStyleContext* aContext) :
15751:   nsContainerFrame(aContext)
15751: {
15751: }
15751: 
15751: nsVideoFrame::~nsVideoFrame()
15751: {
15751: }
15751: 
23554: NS_QUERYFRAME_HEAD(nsVideoFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
15751: 
15751: nsresult
69438: nsVideoFrame::CreateAnonymousContent(nsTArray<ContentInfo>& aElements)
15751: {
29590:   nsNodeInfoManager *nodeInfoManager = GetContent()->GetCurrentDoc()->NodeInfoManager();
94340:   nsCOMPtr<nsINodeInfo> nodeInfo;
29590:   if (HasVideoElement()) {
29590:     // Create an anonymous image element as a child to hold the poster
29590:     // image. We may not have a poster image now, but one could be added
29590:     // before we load, or on a subsequent load.
29590:     nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::img,
29590:                                             nsnull,
71770:                                             kNameSpaceID_XHTML,
71770:                                             nsIDOMNode::ELEMENT_NODE);
29590:     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
71121:     Element* element = NS_NewHTMLImageElement(nodeInfo.forget());
71121:     mPosterImage = element;
29590:     NS_ENSURE_TRUE(mPosterImage, NS_ERROR_OUT_OF_MEMORY);
29590: 
61720:     // Push a null JSContext on the stack so that code that runs
61720:     // within the below code doesn't think it's being called by
61720:     // JS. See bug 604262.
61720:     nsCxPusher pusher;
61720:     pusher.PushNull();
61720: 
29590:     // Set the nsImageLoadingContent::ImageState() to 0. This means that the
29590:     // image will always report its state as 0, so it will never be reframed
29590:     // to show frames for loading or the broken image icon. This is important,
29590:     // as the image is native anonymous, and so can't be reframed (currently).
29590:     nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(mPosterImage);
29590:     NS_ENSURE_TRUE(imgContent, NS_ERROR_FAILURE);
29590: 
80486:     imgContent->ForceImageState(true, 0);
71121:     // And now have it update its internal state
71121:     element->UpdateState(false);
29590: 
80486:     nsresult res = UpdatePosterSource(false);
29590:     NS_ENSURE_SUCCESS(res,res);
29590: 
29590:     if (!aElements.AppendElement(mPosterImage))
29590:       return NS_ERROR_OUT_OF_MEMORY;
29590:   }
29590: 
15751:   // Set up "videocontrols" XUL element which will be XBL-bound to the
15751:   // actual controls.
29590:   nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::videocontrols,
29590:                                           nsnull,
71770:                                           kNameSpaceID_XUL,
71770:                                           nsIDOMNode::ELEMENT_NODE);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
15751: 
51393:   NS_TrustedNewXULElement(getter_AddRefs(mVideoControls), nodeInfo.forget());
15751:   if (!aElements.AppendElement(mVideoControls))
15751:     return NS_ERROR_OUT_OF_MEMORY;
29590: 
15751:   return NS_OK;
15751: }
15751: 
15751: void
55877: nsVideoFrame::AppendAnonymousContentTo(nsBaseContentList& aElements,
55877:                                        PRUint32 aFliter)
38069: {
38069:   aElements.MaybeAppendElement(mPosterImage);
38069:   aElements.MaybeAppendElement(mVideoControls);
38069: }
38069: 
38069: void
36647: nsVideoFrame::DestroyFrom(nsIFrame* aDestructRoot)
15751: {
15751:   nsContentUtils::DestroyAnonymousContent(&mVideoControls);
29590:   nsContentUtils::DestroyAnonymousContent(&mPosterImage);
36647:   nsContainerFrame::DestroyFrom(aDestructRoot);
15751: }
15751: 
79445: bool
15751: nsVideoFrame::IsLeaf() const
15751: {
80486:   return true;
15751: }
15751: 
23156: // Return the largest rectangle that fits in aRect and has the
23156: // same aspect ratio as aRatio, centered at the center of aRect
23156: static gfxRect
23156: CorrectForAspectRatio(const gfxRect& aRect, const nsIntSize& aRatio)
23156: {
23156:   NS_ASSERTION(aRatio.width > 0 && aRatio.height > 0 && !aRect.IsEmpty(),
23156:                "Nothing to draw");
23156:   // Choose scale factor that scales aRatio to just fit into aRect
23156:   gfxFloat scale =
32531:     NS_MIN(aRect.Width()/aRatio.width, aRect.Height()/aRatio.height);
23156:   gfxSize scaledRatio(scale*aRatio.width, scale*aRatio.height);
23156:   gfxPoint topLeft((aRect.Width() - scaledRatio.width)/2,
23156:                    (aRect.Height() - scaledRatio.height)/2);
23156:   return gfxRect(aRect.TopLeft() + topLeft, scaledRatio);
23156: }
23156: 
39499: already_AddRefed<Layer>
39499: nsVideoFrame::BuildLayer(nsDisplayListBuilder* aBuilder,
47731:                          LayerManager* aManager,
47731:                          nsDisplayItem* aItem)
15751: {
51261:   nsRect area = GetContentRect() - GetPosition() + aItem->ToReferenceFrame();
23156:   nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
23156:   nsIntSize videoSize = element->GetVideoSize(nsIntSize(0, 0));
23156:   if (videoSize.width <= 0 || videoSize.height <= 0 || area.IsEmpty())
39499:     return nsnull;
23156: 
39499:   nsRefPtr<ImageContainer> container = element->GetImageContainer();
95000:   if (!container)
95000:     return nsnull;
39499:   
41389:   // Retrieve the size of the decoded video frame, before being scaled
41389:   // by pixel aspect ratio.
41389:   gfxIntSize frameSize = container->GetCurrentSize();
41389:   if (frameSize.width == 0 || frameSize.height == 0) {
41389:     // No image, or zero-sized image. No point creating a layer.
41389:     return nsnull;
41389:   }
41389: 
39499:   // Compute the rectangle in which to paint the video. We need to use
39499:   // the largest rectangle that fills our content-box and has the
39499:   // correct aspect ratio.
15751:   nsPresContext* presContext = PresContext();
15751:   gfxRect r = gfxRect(presContext->AppUnitsToGfxUnits(area.x),
15751:                       presContext->AppUnitsToGfxUnits(area.y),
15751:                       presContext->AppUnitsToGfxUnits(area.width),
15751:                       presContext->AppUnitsToGfxUnits(area.height));
39499:   r = CorrectForAspectRatio(r, videoSize);
57389:   r.Round();
57389:   gfxIntSize scaleHint(static_cast<PRInt32>(r.Width()),
57389:                        static_cast<PRInt32>(r.Height()));
57389:   container->SetScaleHint(scaleHint);
15751: 
47731:   nsRefPtr<ImageLayer> layer = static_cast<ImageLayer*>
47731:     (aBuilder->LayerBuilder()->GetLeafLayerFor(aBuilder, aManager, aItem));
47731:   if (!layer) {
47731:     layer = aManager->CreateImageLayer();
39499:     if (!layer)
39499:       return nsnull;
47731:   }
39499: 
39499:   layer->SetContainer(container);
39499:   layer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(this));
68423:   layer->SetContentFlags(Layer::CONTENT_OPAQUE);
39499:   // Set a transform on the layer to draw the video in the right place
39499:   gfxMatrix transform;
68632:   transform.Translate(r.TopLeft());
41389:   transform.Scale(r.Width()/frameSize.width, r.Height()/frameSize.height);
39499:   layer->SetTransform(gfx3DMatrix::From2D(transform));
81289:   layer->SetVisibleRegion(nsIntRect(0, 0, frameSize.width, frameSize.height));
39499:   nsRefPtr<Layer> result = layer.forget();
39499:   return result.forget();
15751: }
15751: 
15751: NS_IMETHODIMP
15751: nsVideoFrame::Reflow(nsPresContext*           aPresContext,
15751:                      nsHTMLReflowMetrics&     aMetrics,
15751:                      const nsHTMLReflowState& aReflowState,
15751:                      nsReflowStatus&          aStatus)
15751: {
15751:   DO_GLOBAL_REFLOW_COUNT("nsVideoFrame");
15751:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
15751:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
15751:                   ("enter nsVideoFrame::Reflow: availSize=%d,%d",
15751:                   aReflowState.availableWidth, aReflowState.availableHeight));
15751: 
15751:   NS_PRECONDITION(mState & NS_FRAME_IN_REFLOW, "frame is not in reflow");
15751: 
15751:   aStatus = NS_FRAME_COMPLETE;
15751: 
15751:   aMetrics.width = aReflowState.ComputedWidth();
15751:   aMetrics.height = aReflowState.ComputedHeight();
15751: 
15751:   // stash this away so we can compute our inner area later
15751:   mBorderPadding   = aReflowState.mComputedBorderPadding;
15751: 
15751:   aMetrics.width += mBorderPadding.left + mBorderPadding.right;
15751:   aMetrics.height += mBorderPadding.top + mBorderPadding.bottom;
15751: 
29590:   // Reflow the child frames. We may have up to two, an image frame
29590:   // which is the poster, and a box frame, which is the video controls.
29590:   for (nsIFrame *child = mFrames.FirstChild();
29590:        child;
29590:        child = child->GetNextSibling()) {
29590:     if (child->GetType() == nsGkAtoms::imageFrame) {
29590:       // Reflow the poster frame.
29590:       nsImageFrame* imageFrame = static_cast<nsImageFrame*>(child);
29590:       nsHTMLReflowMetrics kidDesiredSize;
29590:       nsSize availableSize = nsSize(aReflowState.availableWidth,
29590:                                     aReflowState.availableHeight);
29590:       nsHTMLReflowState kidReflowState(aPresContext,
29590:                                        aReflowState,
29590:                                        imageFrame,
29590:                                        availableSize,
29590:                                        aMetrics.width,
29590:                                        aMetrics.height);
29590:       if (ShouldDisplayPoster()) {
29590:         kidReflowState.SetComputedWidth(aReflowState.ComputedWidth());
29590:         kidReflowState.SetComputedHeight(aReflowState.ComputedHeight());
29590:       } else {
29590:         kidReflowState.SetComputedWidth(0);
29590:         kidReflowState.SetComputedHeight(0);
29590:       }
29590:       ReflowChild(imageFrame, aPresContext, kidDesiredSize, kidReflowState,
29590:                   mBorderPadding.left, mBorderPadding.top, 0, aStatus);
29590:       FinishReflowChild(imageFrame, aPresContext,
29590:                         &kidReflowState, kidDesiredSize,
29590:                         mBorderPadding.left, mBorderPadding.top, 0);
29590:     } else if (child->GetType() == nsGkAtoms::boxFrame) {
29590:       // Reflow the video controls frame.
29588:       nsBoxLayoutState boxState(PresContext(), aReflowState.rendContext);
29590:       nsBoxFrame::LayoutChildAt(boxState,
29590:                                 child,
29590:                                 nsRect(mBorderPadding.left,
29590:                                        mBorderPadding.top,
29590:                                        aReflowState.ComputedWidth(),
29590:                                        aReflowState.ComputedHeight()));
29585:     }
29590:   }
55039:   aMetrics.SetOverflowAreasToDesiredBounds();
15751: 
15751:   FinishAndStoreOverflow(&aMetrics);
15751: 
15751:   if (mRect.width != aMetrics.width || mRect.height != aMetrics.height) {
19380:     Invalidate(nsRect(0, 0, mRect.width, mRect.height));
15751:   }
15751: 
15751:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
15751:                   ("exit nsVideoFrame::Reflow: size=%d,%d",
15751:                   aMetrics.width, aMetrics.height));
15751:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
15751: 
15751:   return NS_OK;
15751: }
15751: 
39499: class nsDisplayVideo : public nsDisplayItem {
39499: public:
51260:   nsDisplayVideo(nsDisplayListBuilder* aBuilder, nsVideoFrame* aFrame)
51260:     : nsDisplayItem(aBuilder, aFrame)
15751:   {
39499:     MOZ_COUNT_CTOR(nsDisplayVideo);
39499:   }
39499: #ifdef NS_BUILD_REFCNT_LOGGING
39499:   virtual ~nsDisplayVideo() {
39499:     MOZ_COUNT_DTOR(nsDisplayVideo);
39499:   }
15751: #endif
15751:   
47732:   NS_DISPLAY_DECL_NAME("Video", TYPE_VIDEO)
15751: 
59779:   // It would be great if we could override GetOpaqueRegion to return nonempty here,
39499:   // but it's probably not safe to do so in general. Video frames are
39499:   // updated asynchronously from decoder threads, and it's possible that
59779:   // we might have an opaque video frame when GetOpaqueRegion is called, but
39499:   // when we come to paint, the video frame is transparent or has gone
39499:   // away completely (e.g. because of a decoder error). The problem would
39499:   // be especially acute if we have off-main-thread rendering.
39499: 
39499:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder)
39499:   {
39499:     nsIFrame* f = GetUnderlyingFrame();
51261:     return f->GetContentRect() - f->GetPosition() + ToReferenceFrame();
15751:   }
15751: 
39499:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters)
39499:   {
47731:     return static_cast<nsVideoFrame*>(mFrame)->BuildLayer(aBuilder, aManager, this);
39499:   }
47751: 
47751:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
47751:                                    LayerManager* aManager)
47751:   {
48691:     if (aManager->GetBackendType() != LayerManager::LAYERS_BASIC) {
48691:       // For non-basic layer managers we can assume that compositing
48691:       // layers is very cheap, and since ImageLayers don't require
48691:       // additional memory of the video frames we have to have anyway,
48691:       // we can't save much by making layers inactive. Also, for many
48691:       // accelerated layer managers calling
48691:       // imageContainer->GetCurrentAsSurface can be very expensive. So
48691:       // just always be active for these managers.
48691:       return LAYER_ACTIVE;
48691:     }
47752:     nsHTMLMediaElement* elem =
47752:       static_cast<nsHTMLMediaElement*>(mFrame->GetContent());
48691:     return elem->IsPotentiallyPlaying() ? LAYER_ACTIVE : LAYER_INACTIVE;
47751:   }
39499: };
39499: 
15751: NS_IMETHODIMP
15751: nsVideoFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
15751:                                const nsRect&           aDirtyRect,
15751:                                const nsDisplayListSet& aLists)
15751: {
15751:   if (!IsVisibleForPainting(aBuilder))
15751:     return NS_OK;
15751: 
15751:   DO_GLOBAL_REFLOW_COUNT_DSP("nsVideoFrame");
15751: 
15751:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
15751:   NS_ENSURE_SUCCESS(rv, rv);
15751: 
52294:   nsDisplayList replacedContent;
52294: 
39499:   if (HasVideoElement() && !ShouldDisplayPoster()) {
52294:     rv = replacedContent.AppendNewToTop(
51260:       new (aBuilder) nsDisplayVideo(aBuilder, this));
15751:     NS_ENSURE_SUCCESS(rv, rv);
22873:   }
15751: 
29590:   // Add child frames to display list. We expect up to two children, an image
29590:   // frame for the poster, and the box frame for the video controls.
29590:   for (nsIFrame *child = mFrames.FirstChild();
29590:        child;
29590:        child = child->GetNextSibling()) {
29590:     if (child->GetType() == nsGkAtoms::imageFrame && ShouldDisplayPoster()) {
29590:       rv = child->BuildDisplayListForStackingContext(aBuilder,
29590:                                                      aDirtyRect - child->GetOffsetTo(this),
52294:                                                      &replacedContent);
29590:       NS_ENSURE_SUCCESS(rv,rv);
29590:     } else if (child->GetType() == nsGkAtoms::boxFrame) {
29590:       rv = child->BuildDisplayListForStackingContext(aBuilder,
29590:                                                      aDirtyRect - child->GetOffsetTo(this),
52294:                                                      &replacedContent);
29590:       NS_ENSURE_SUCCESS(rv,rv);
15751:     }
29590:   }
29590: 
52294:   WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
52294: 
29590:   return NS_OK;
15751: }
15751: 
15751: nsIAtom*
15751: nsVideoFrame::GetType() const
15751: {
15751:   return nsGkAtoms::HTMLVideoFrame;
15751: }
15751: 
15751: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsVideoFrame::CreateAccessible()
15751: {
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
46338:   return accService ?
46338:     accService->CreateHTMLMediaAccessible(mContent, PresContext()->PresShell()) :
46338:     nsnull;
15751: }
15751: #endif
15751: 
15751: #ifdef DEBUG
15751: NS_IMETHODIMP
15751: nsVideoFrame::GetFrameName(nsAString& aResult) const
15751: {
15751:   return MakeFrameName(NS_LITERAL_STRING("HTMLVideo"), aResult);
15751: }
15751: #endif
15751: 
68481: nsSize nsVideoFrame::ComputeSize(nsRenderingContext *aRenderingContext,
15751:                                      nsSize aCBSize,
15751:                                      nscoord aAvailableWidth,
15751:                                      nsSize aMargin,
15751:                                      nsSize aBorder,
15751:                                      nsSize aPadding,
93353:                                      PRUint32 aFlags)
15751: {
36965:   nsSize size = GetVideoIntrinsicSize(aRenderingContext);
15751: 
15751:   IntrinsicSize intrinsicSize;
15751:   intrinsicSize.width.SetCoordValue(size.width);
15751:   intrinsicSize.height.SetCoordValue(size.height);
15751: 
15751:   nsSize& intrinsicRatio = size; // won't actually be used
15751: 
15751:   return nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(aRenderingContext,
15751:                                                            this,
15751:                                                            intrinsicSize,
15751:                                                            intrinsicRatio,
15751:                                                            aCBSize,
15751:                                                            aMargin,
15751:                                                            aBorder,
15751:                                                            aPadding);
15751: }
15751: 
68481: nscoord nsVideoFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
15751: {
36965:   nscoord result = GetVideoIntrinsicSize(aRenderingContext).width;
15751:   DISPLAY_MIN_WIDTH(this, result);
15751:   return result;
15751: }
15751: 
68481: nscoord nsVideoFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
15751: {
36965:   nscoord result = GetVideoIntrinsicSize(aRenderingContext).width;
15751:   DISPLAY_PREF_WIDTH(this, result);
15751:   return result;
15751: }
15751: 
15751: nsSize nsVideoFrame::GetIntrinsicRatio()
15751: {
36965:   return GetVideoIntrinsicSize(nsnull);
15751: }
15751: 
79445: bool nsVideoFrame::ShouldDisplayPoster()
29590: {
29590:   if (!HasVideoElement())
80486:     return false;
29590: 
29590:   nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
29590:   if (element->GetPlayedOrSeeked() && HasVideoData())
80486:     return false;
29590: 
29590:   nsCOMPtr<nsIImageLoadingContent> imgContent = do_QueryInterface(mPosterImage);
80486:   NS_ENSURE_TRUE(imgContent, false);
29590: 
29590:   nsCOMPtr<imgIRequest> request;
29590:   nsresult res = imgContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
29590:                                         getter_AddRefs(request));
29590:   if (NS_FAILED(res) || !request) {
80486:     return false;
29590:   }
29590: 
29590:   PRUint32 status = 0;
29590:   res = request->GetImageStatus(&status);
29590:   if (NS_FAILED(res) || (status & imgIRequest::STATUS_ERROR))
80486:     return false;
29590: 
80486:   return true;
29590: }
29590: 
36965: nsSize
68481: nsVideoFrame::GetVideoIntrinsicSize(nsRenderingContext *aRenderingContext)
15751: {
15751:   // Defaulting size to 300x150 if no size given.
15751:   nsIntSize size(300, 150);
15751: 
29590:   if (ShouldDisplayPoster()) {
29590:     // Use the poster image frame's size.
29590:     nsIFrame *child = mFrames.FirstChild();
29590:     if (child && child->GetType() == nsGkAtoms::imageFrame) {
29590:       nsImageFrame* imageFrame = static_cast<nsImageFrame*>(child);
29590:       nsSize imgsize;
52205:       if (NS_SUCCEEDED(imageFrame->GetIntrinsicImageSize(imgsize))) {
29590:         return imgsize;
29590:       }
29590:     }
52205:   }
29590: 
43661:   if (!HasVideoElement()) {
22873:     if (!aRenderingContext || !mFrames.FirstChild()) {
22873:       // We just want our intrinsic ratio, but audio elements need no
22873:       // intrinsic ratio, so just return "no ratio". Also, if there's
22873:       // no controls frame, we prefer to be zero-sized.
22873:       return nsSize(0, 0);
22873:     }
22873: 
22873:     // Ask the controls frame what its preferred height is
22873:     nsBoxLayoutState boxState(PresContext(), aRenderingContext, 0);
29590:     nscoord prefHeight = mFrames.LastChild()->GetPrefSize(boxState).height;
22873:     return nsSize(nsPresContext::CSSPixelsToAppUnits(size.width), prefHeight);
22873:   }
22873: 
15751:   nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
15751:   size = element->GetVideoSize(size);
15751: 
15751:   return nsSize(nsPresContext::CSSPixelsToAppUnits(size.width),
15751:                 nsPresContext::CSSPixelsToAppUnits(size.height));
15751: }
22873: 
29590: nsresult
79445: nsVideoFrame::UpdatePosterSource(bool aNotify)
29590: {
29590:   NS_ASSERTION(HasVideoElement(), "Only call this on <video> elements.");
29590:   nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
29590: 
29590:   nsAutoString posterStr;
29590:   element->GetPoster(posterStr);
29590:   nsresult res = mPosterImage->SetAttr(kNameSpaceID_None,
29590:                                        nsGkAtoms::src,
29590:                                        posterStr,
29590:                                        aNotify);
29590:   NS_ENSURE_SUCCESS(res,res);
29590:   return NS_OK;
29590: }
29590: 
29590: NS_IMETHODIMP
29590: nsVideoFrame::AttributeChanged(PRInt32 aNameSpaceID,
29590:                                nsIAtom* aAttribute,
29590:                                PRInt32 aModType)
29590: {
30046:   if (aAttribute == nsGkAtoms::poster && HasVideoElement()) {
80486:     nsresult res = UpdatePosterSource(true);
29590:     NS_ENSURE_SUCCESS(res,res);
29590:   }
29590:   return nsContainerFrame::AttributeChanged(aNameSpaceID,
29590:                                             aAttribute,
29590:                                             aModType);
29590: }
29590: 
79445: bool nsVideoFrame::HasVideoElement() {
29590:   nsCOMPtr<nsIDOMHTMLVideoElement> videoDomElement = do_QueryInterface(mContent);
29590:   return videoDomElement != nsnull;
29590: }
29590: 
79445: bool nsVideoFrame::HasVideoData()
22873: {
29590:   if (!HasVideoElement())
80486:     return false;
29590:   nsHTMLVideoElement* element = static_cast<nsHTMLVideoElement*>(GetContent());
29590:   nsIntSize size = element->GetVideoSize(nsIntSize(0,0));
29590:   return size != nsIntSize(0,0);
22873: }
