     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
107006: #include "base/basictypes.h"
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsLayoutUtils.h"
     1: #include "nsIFormControlFrame.h"
     1: #include "nsPresContext.h"
     1: #include "nsIContent.h"
 41068: #include "nsIDOMHTMLDocument.h"
 41320: #include "nsIDOMHTMLElement.h"
     1: #include "nsFrameList.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIAtom.h"
     1: #include "nsCSSPseudoElements.h"
 12349: #include "nsCSSAnonBoxes.h"
 72260: #include "nsCSSColorUtils.h"
     1: #include "nsIView.h"
     1: #include "nsPlaceholderFrame.h"
     1: #include "nsIScrollableFrame.h"
     1: #include "nsCSSFrameConstructor.h"
     1: #include "nsIDOMEvent.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsDisplayList.h"
     1: #include "nsRegion.h"
     1: #include "nsFrameManager.h"
     1: #include "nsBlockFrame.h"
     1: #include "nsBidiPresUtils.h"
     1: #include "imgIContainer.h"
     1: #include "gfxRect.h"
  1442: #include "gfxContext.h"
  4032: #include "gfxFont.h"
 93575: #include "nsRenderingContext.h"
     1: #include "nsIInterfaceRequestorUtils.h"
  1345: #include "nsCSSRendering.h"
  4032: #include "nsContentUtils.h"
 16601: #include "nsThemeConstants.h"
 16228: #include "nsPIDOMWindow.h"
 16228: #include "nsIBaseWindow.h"
 16228: #include "nsIDocShell.h"
 16228: #include "nsIDocShellTreeItem.h"
 16228: #include "nsIWidget.h"
 19214: #include "gfxMatrix.h"
 74753: #include "gfxPoint3D.h"
 19214: #include "gfxTypes.h"
 19962: #include "gfxUserFontSet.h"
 24551: #include "nsTArray.h"
 42402: #include "nsHTMLCanvasElement.h"
 29572: #include "nsICanvasRenderingContextInternal.h"
 29572: #include "gfxPlatform.h"
 33027: #include "nsClientRect.h"
 29959: #ifdef MOZ_MEDIA
 29572: #include "nsHTMLVideoElement.h"
 29959: #endif
100047: #include "nsHTMLImageElement.h"
 29572: #include "imgIRequest.h"
 29572: #include "nsIImageLoadingContent.h"
 32132: #include "nsCOMPtr.h"
115873: #include "nsCSSProps.h"
 37081: #include "nsListControlFrame.h"
 39499: #include "ImageLayers.h"
 70831: #include "mozilla/arm.h"
 41930: #include "mozilla/dom/Element.h"
 47739: #include "nsCanvasFrame.h"
 50420: #include "gfxDrawable.h"
 50420: #include "gfxUtils.h"
 60450: #include "nsDataHashtable.h"
 71908: #include "nsTextFrame.h"
 71908: #include "nsFontFaceList.h"
 95535: #include "nsFontInflationData.h"
 12349: #include "nsSVGUtils.h"
 19125: #include "nsSVGIntegrationUtils.h"
     1: #include "nsSVGForeignObjectFrame.h"
     1: #include "nsSVGOuterSVGFrame.h"
107806: #include "nsStyleStructInlines.h"
     1: 
 74749: #include "mozilla/Preferences.h"
 74749: 
 39629: #ifdef MOZ_XUL
 39629: #include "nsXULPopupManager.h"
 39629: #endif
 39629: 
 87692: #include "sampler.h"
107005: #include "nsAnimationManager.h"
107005: #include "nsTransitionManager.h"
 87692: 
 80467: using namespace mozilla;
 39499: using namespace mozilla::layers;
 41634: using namespace mozilla::dom;
 88122: using namespace mozilla::layout;
 39499: 
115873: #define FLEXBOX_ENABLED_PREF_NAME "layout.css.flexbox.enabled"
115873: 
 55416: #ifdef DEBUG
 55416: // TODO: remove, see bug 598468.
 55416: bool nsLayoutUtils::gPreventAssertInCompareTreePosition = false;
 55416: #endif // DEBUG
 55416: 
 55321: typedef gfxPattern::GraphicsFilter GraphicsFilter;
 60444: typedef FrameMetrics::ViewID ViewID;
 55321: 
108991: /* static */ uint32_t nsLayoutUtils::sFontSizeInflationEmPerLine;
108991: /* static */ uint32_t nsLayoutUtils::sFontSizeInflationMinTwips;
108991: /* static */ uint32_t nsLayoutUtils::sFontSizeInflationLineThreshold;
108991: /* static */ int32_t  nsLayoutUtils::sFontSizeInflationMappingIntercept;
119442: /* static */ uint32_t nsLayoutUtils::sFontSizeInflationMaxRatio;
 82670: 
 60450: static ViewID sScrollIdCounter = FrameMetrics::START_SCROLL_ID;
 60450: 
116061: #ifdef MOZ_FLEXBOX
115873: // These are indices into kDisplayKTable.  They'll be initialized
115873: // the first time that FlexboxEnabledPrefChangeCallback() is invoked.
115873: static int32_t sIndexOfFlexInDisplayTable;
115873: static int32_t sIndexOfInlineFlexInDisplayTable;
115873: // This tracks whether those ^^ indices have been initialized
115873: static bool sAreFlexKeywordIndicesInitialized = false;
116061: #endif // MOZ_FLEXBOX
115873: 
 60450: typedef nsDataHashtable<nsUint64HashKey, nsIContent*> ContentMap;
115831: static ContentMap* sContentMap = nullptr;
 60450: static ContentMap& GetContentMap() {
 60450:   if (!sContentMap) {
 60450:     sContentMap = new ContentMap();
 63963:     sContentMap->Init();
 60450:   }
 60450:   return *sContentMap;
 60450: }
 60450: 
115873: // When the pref "layout.css.flexbox.enabled" changes, this function is invoked
115873: // to let us update kDisplayKTable, to selectively disable or restore the
118966: // entries for "flex" and "inline-flex" in that table.
115873: #ifdef MOZ_FLEXBOX
115873: static int
115873: FlexboxEnabledPrefChangeCallback(const char* aPrefName, void* aClosure)
115873: {
115873:   MOZ_ASSERT(strncmp(aPrefName, FLEXBOX_ENABLED_PREF_NAME,
115873:                      NS_ARRAY_LENGTH(FLEXBOX_ENABLED_PREF_NAME)) == 0,
115873:              "We only registered this callback for a single pref, so it "
115873:              "should only be called for that pref");
115873: 
115873:   bool isFlexboxEnabled =
115873:     Preferences::GetBool(FLEXBOX_ENABLED_PREF_NAME, false);
115873: 
115873:   if (!sAreFlexKeywordIndicesInitialized) {
118966:     // First run: find the position of "flex" and "inline-flex" in
115873:     // kDisplayKTable.
115873:     sIndexOfFlexInDisplayTable =
118966:       nsCSSProps::FindIndexOfKeyword(eCSSKeyword_flex,
115873:                                      nsCSSProps::kDisplayKTable);
115873:     sIndexOfInlineFlexInDisplayTable =
118966:       nsCSSProps::FindIndexOfKeyword(eCSSKeyword_inline_flex,
115873:                                      nsCSSProps::kDisplayKTable);
115873: 
115873:     sAreFlexKeywordIndicesInitialized = true;
115873:   }
115873: 
115873:   // OK -- now, stomp on or restore the "flex" entries in kDisplayKTable,
115873:   // depending on whether the flexbox pref is enabled vs. disabled.
115873:   if (sIndexOfFlexInDisplayTable >= 0) {
115873:     nsCSSProps::kDisplayKTable[sIndexOfFlexInDisplayTable] =
118966:       isFlexboxEnabled ? eCSSKeyword_flex : eCSSKeyword_UNKNOWN;
115873:   }
115873:   if (sIndexOfInlineFlexInDisplayTable >= 0) {
115873:     nsCSSProps::kDisplayKTable[sIndexOfInlineFlexInDisplayTable] =
118966:       isFlexboxEnabled ? eCSSKeyword_inline_flex : eCSSKeyword_UNKNOWN;
115873:   }
115873: 
115873:   return 0;
115873: }
115873: #endif // MOZ_FLEXBOX
115873: 
107005: bool
107005: nsLayoutUtils::HasAnimationsForCompositor(nsIContent* aContent,
107005:                                           nsCSSProperty aProperty)
107005: {
107005:   if (!aContent->MayHaveAnimations())
107005:     return false;
107005:   ElementAnimations* animations =
107005:     static_cast<ElementAnimations*>(aContent->GetProperty(nsGkAtoms::animationsProperty));
107005:   if (animations) {
107005:     bool propertyMatches = animations->HasAnimationOfProperty(aProperty);
107005:     if (propertyMatches && animations->CanPerformOnCompositorThread()) {
107005:       return true;
107005:     }
107005:   }
107005: 
107005:   ElementTransitions* transitions =
107005:     static_cast<ElementTransitions*>(aContent->GetProperty(nsGkAtoms::transitionsProperty));
107005:   if (transitions) {
107005:     bool propertyMatches = transitions->HasTransitionOfProperty(aProperty);
107005:     if (propertyMatches && transitions->CanPerformOnCompositorThread()) {
107005:       return true;
107005:     }
107005:   }
107005: 
107005:   return false;
107005: }
 74749: 
 79445: bool
 74749: nsLayoutUtils::Are3DTransformsEnabled()
 74749: {
 79445:   static bool s3DTransformsEnabled;
 79445:   static bool s3DTransformPrefCached = false;
 74749: 
 74749:   if (!s3DTransformPrefCached) {
 80486:     s3DTransformPrefCached = true;
115831:     Preferences::AddBoolVarCache(&s3DTransformsEnabled,
 74749:                                  "layout.3d-transforms.enabled");
 74749:   }
 74749: 
 74749:   return s3DTransformsEnabled;
 74749: }
 74749: 
 95942: bool
107006: nsLayoutUtils::AreOpacityAnimationsEnabled()
107006: {
107006:   static bool sAreOpacityAnimationsEnabled;
107006:   static bool sOpacityPrefCached = false;
107006: 
107006:   if (!sOpacityPrefCached) {
107006:     sOpacityPrefCached = true;
107006:     Preferences::AddBoolVarCache(&sAreOpacityAnimationsEnabled,
107006:                                  "layers.offmainthreadcomposition.animate-opacity");
107006:   }
107006: 
109463:   return sAreOpacityAnimationsEnabled &&
109463:     gfxPlatform::OffMainThreadCompositingEnabled();
107006: }
107006: 
107006: bool
107006: nsLayoutUtils::AreTransformAnimationsEnabled()
107006: {
107006:   static bool sAreTransformAnimationsEnabled;
107006:   static bool sTransformPrefCached = false;
107006: 
107006:   if (!sTransformPrefCached) {
107006:     sTransformPrefCached = true;
107006:     Preferences::AddBoolVarCache(&sAreTransformAnimationsEnabled,
107006:                                  "layers.offmainthreadcomposition.animate-transform");
107006:   }
107006: 
109463:   return sAreTransformAnimationsEnabled &&
109463:     gfxPlatform::OffMainThreadCompositingEnabled();
107006: }
107006: 
107006: bool
107567: nsLayoutUtils::IsAnimationLoggingEnabled()
107567: {
107567:   static bool sShouldLog;
107567:   static bool sShouldLogPrefCached;
107567: 
107567:   if (!sShouldLogPrefCached) {
107567:     sShouldLogPrefCached = true;
107567:     Preferences::AddBoolVarCache(&sShouldLog,
107567:                                  "layers.offmainthreadcomposition.log-animations");
107567:   }
107567: 
107567:   return sShouldLog;
107567: }
107567: 
107567: bool
 95942: nsLayoutUtils::UseBackgroundNearestFiltering()
 95942: {
 95942:   static bool sUseBackgroundNearestFilteringEnabled;
 95942:   static bool sUseBackgroundNearestFilteringPrefInitialised = false;
 95942: 
 95942:   if (!sUseBackgroundNearestFilteringPrefInitialised) {
 95942:     sUseBackgroundNearestFilteringPrefInitialised = true;
115831:     sUseBackgroundNearestFilteringEnabled =
115831:       Preferences::GetBool("gfx.filter.nearest.force-enabled", false);
 95942:   }
 95942: 
 95942:   return sUseBackgroundNearestFilteringEnabled;
 95942: }
 95942: 
 97534: bool
 97534: nsLayoutUtils::GPUImageScalingEnabled()
 97534: {
 97534:   static bool sGPUImageScalingEnabled;
 97534:   static bool sGPUImageScalingPrefInitialised = false;
 97534: 
 97534:   if (!sGPUImageScalingPrefInitialised) {
 97534:     sGPUImageScalingPrefInitialised = true;
115831:     sGPUImageScalingEnabled =
115831:       Preferences::GetBool("layout.gpu-image-scaling.enabled", false);
 97534:   }
 97534: 
 97534:   return sGPUImageScalingEnabled;
 97534: }
 97534: 
 87626: void
 87626: nsLayoutUtils::UnionChildOverflow(nsIFrame* aFrame,
 87626:                                   nsOverflowAreas& aOverflowAreas)
 87626: {
 87630:   // Iterate over all children except pop-ups.
 87630:   const nsIFrame::ChildListIDs skip(nsIFrame::kPopupList |
 87630:                                     nsIFrame::kSelectPopupList);
 87626:   for (nsIFrame::ChildListIterator childLists(aFrame);
 87626:        !childLists.IsDone(); childLists.Next()) {
 87630:     if (skip.Contains(childLists.CurrentID())) {
 87626:       continue;
 87630:     }
 87626: 
 87626:     nsFrameList children = childLists.CurrentList();
 87626:     for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
 87626:       nsIFrame* child = e.get();
 87626:       nsOverflowAreas childOverflow =
 87626:         child->GetOverflowAreas() + child->GetPosition();
 87626:       aOverflowAreas.UnionWith(childOverflow);
 87626:     }
 87626:   }
 87626: }
 87626: 
 60450: static void DestroyViewID(void* aObject, nsIAtom* aPropertyName,
 60450:                           void* aPropertyValue, void* aData)
 60450: {
 60450:   ViewID* id = static_cast<ViewID*>(aPropertyValue);
 60450:   GetContentMap().Remove(*id);
 60450:   delete id;
 60450: }
 60450: 
 63413: /**
 63413:  * A namespace class for static layout utilities.
 63413:  */
 63413: 
 60450: ViewID
 60450: nsLayoutUtils::FindIDFor(nsIContent* aContent)
 60450: {
 60450:   ViewID scrollId;
 60450: 
 60450:   void* scrollIdProperty = aContent->GetProperty(nsGkAtoms::RemoteId);
 60450:   if (scrollIdProperty) {
 60450:     scrollId = *static_cast<ViewID*>(scrollIdProperty);
 60450:   } else {
 60450:     scrollId = sScrollIdCounter++;
 60450:     aContent->SetProperty(nsGkAtoms::RemoteId, new ViewID(scrollId),
 60450:                           DestroyViewID);
 60450:     GetContentMap().Put(scrollId, aContent);
 60450:   }
 60450: 
 60450:   return scrollId;
 60450: }
 60450: 
 60450: nsIContent*
 60450: nsLayoutUtils::FindContentFor(ViewID aId)
 60450: {
 60450:   NS_ABORT_IF_FALSE(aId != FrameMetrics::NULL_SCROLL_ID &&
 60450:                     aId != FrameMetrics::ROOT_SCROLL_ID,
 60450:                     "Cannot find a content element in map for null or root IDs.");
 60450:   nsIContent* content;
 60450:   bool exists = GetContentMap().Get(aId, &content);
 60450: 
 60450:   if (exists) {
 60450:     return content;
 60450:   } else {
106838:     return nullptr;
 60450:   }
 60450: }
 60450: 
 63413: bool
 63413: nsLayoutUtils::GetDisplayPort(nsIContent* aContent, nsRect *aResult)
 63413: {
 63413:   void* property = aContent->GetProperty(nsGkAtoms::DisplayPort);
 63413:   if (!property) {
 63413:     return false;
 63413:   }
 63413: 
 63413:   if (aResult) {
 63413:     *aResult = *static_cast<nsRect*>(property);
 63413:   }
 63413:   return true;
 63413: }
     1: 
 10780: nsIFrame*
 10780: nsLayoutUtils::GetLastContinuationWithChild(nsIFrame* aFrame)
 10780: {
 10780:   NS_PRECONDITION(aFrame, "NULL frame pointer");
 10780:   aFrame = aFrame->GetLastContinuation();
 77154:   while (!aFrame->GetFirstPrincipalChild() &&
 10780:          aFrame->GetPrevContinuation()) {
 10780:     aFrame = aFrame->GetPrevContinuation();
 10780:   }
 10780:   return aFrame;
 10780: }
 10780: 
     1: /**
     1:  * GetFirstChildFrame returns the first "real" child frame of a
     1:  * given frame.  It will descend down into pseudo-frames (unless the
     1:  * pseudo-frame is the :before generated frame).
     1:  * @param aFrame the frame
     1:  * @param aFrame the frame's content node
     1:  */
     1: static nsIFrame*
     1: GetFirstChildFrame(nsIFrame*       aFrame,
     1:                    nsIContent*     aContent)
     1: {
     1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
     1: 
     1:   // Get the first child frame
 77154:   nsIFrame* childFrame = aFrame->GetFirstPrincipalChild();
     1: 
     1:   // If the child frame is a pseudo-frame, then return its first child.
     1:   // Note that the frame we create for the generated content is also a
     1:   // pseudo-frame and so don't drill down in that case
     1:   if (childFrame &&
     1:       childFrame->IsPseudoFrame(aContent) &&
     1:       !childFrame->IsGeneratedContentFrame()) {
     1:     return GetFirstChildFrame(childFrame, aContent);
     1:   }
     1: 
     1:   return childFrame;
     1: }
     1: 
     1: /**
     1:  * GetLastChildFrame returns the last "real" child frame of a
     1:  * given frame.  It will descend down into pseudo-frames (unless the
     1:  * pseudo-frame is the :after generated frame).
     1:  * @param aFrame the frame
     1:  * @param aFrame the frame's content node
     1:  */
     1: static nsIFrame*
     1: GetLastChildFrame(nsIFrame*       aFrame,
     1:                   nsIContent*     aContent)
     1: {
     1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
     1: 
 10780:   // Get the last continuation frame that's a parent
 77154:   nsIFrame* lastParentContinuation =
 77154:     nsLayoutUtils::GetLastContinuationWithChild(aFrame);
 77154:   nsIFrame* lastChildFrame =
 77154:     lastParentContinuation->GetLastChild(nsIFrame::kPrincipalList);
 32843:   if (lastChildFrame) {
     1:     // Get the frame's first continuation. This matters in case the frame has
     1:     // been continued across multiple lines or split by BiDi resolution.
     1:     lastChildFrame = lastChildFrame->GetFirstContinuation();
     1: 
     1:     // If the last child frame is a pseudo-frame, then return its last child.
     1:     // Note that the frame we create for the generated content is also a
     1:     // pseudo-frame and so don't drill down in that case
     1:     if (lastChildFrame &&
     1:         lastChildFrame->IsPseudoFrame(aContent) &&
     1:         !lastChildFrame->IsGeneratedContentFrame()) {
     1:       return GetLastChildFrame(lastChildFrame, aContent);
     1:     }
     1: 
     1:     return lastChildFrame;
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: //static
 77154: nsIFrame::ChildListID
 36646: nsLayoutUtils::GetChildListNameFor(nsIFrame* aChildFrame)
 36646: {
 77154:   nsIFrame::ChildListID id = nsIFrame::kPrincipalList;
 36646: 
 36646:   if (aChildFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 36646:     nsIFrame* pif = aChildFrame->GetPrevInFlow();
 36646:     if (pif->GetParent() == aChildFrame->GetParent()) {
 77154:       id = nsIFrame::kExcessOverflowContainersList;
 36646:     }
 36646:     else {
 77154:       id = nsIFrame::kOverflowContainersList;
 36646:     }
 36646:   }
 36646:   // See if the frame is moved out of the flow
 36646:   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 36646:     // Look at the style information to tell
 36646:     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
 36646: 
 36646:     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
 77154:       id = nsIFrame::kAbsoluteList;
 36646:     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
 36646:       if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
 77154:         id = nsIFrame::kFixedList;
 36646:       } else {
 77154:         id = nsIFrame::kAbsoluteList;
 36646:       }
 36646: #ifdef MOZ_XUL
 36646:     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
 36646:       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
 36646: #ifdef DEBUG
 36646:       nsIFrame* parent = aChildFrame->GetParent();
 36646:       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
 36646:                    "Unexpected parent");
 36646: #endif // DEBUG
 36646: 
 36646:       // XXX FIXME: Bug 350740
 36646:       // Return here, because the postcondition for this function actually
 36646:       // fails for this case, since the popups are not in a "real" frame list
 36646:       // in the popup set.
 77154:       return nsIFrame::kPopupList;
 36646: #endif // MOZ_XUL
 36646:     } else {
107224:       NS_ASSERTION(aChildFrame->IsFloating(),
 36646:                    "not a floated frame");
 77154:       id = nsIFrame::kFloatList;
 36646:     }
 36646: 
 36646:   } else {
 36646:     nsIAtom* childType = aChildFrame->GetType();
 36646:     if (nsGkAtoms::menuPopupFrame == childType) {
 36646:       nsIFrame* parent = aChildFrame->GetParent();
 36646:       nsIFrame* firstPopup = (parent)
 77154:                              ? parent->GetFirstChild(nsIFrame::kPopupList)
106838:                              : nullptr;
 36646:       NS_ASSERTION(!firstPopup || !firstPopup->GetNextSibling(),
 36646:                    "We assume popupList only has one child, but it has more.");
 77154:       id = firstPopup == aChildFrame
 77154:              ? nsIFrame::kPopupList
 77154:              : nsIFrame::kPrincipalList;
 36646:     } else if (nsGkAtoms::tableColGroupFrame == childType) {
 77154:       id = nsIFrame::kColGroupList;
 36646:     } else if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
 77154:       id = nsIFrame::kCaptionList;
 36646:     } else {
 77154:       id = nsIFrame::kPrincipalList;
 36646:     }
 36646:   }
 36646: 
102909: #ifdef DEBUG
 36646:   // Verify that the frame is actually in that child list or in the
 36646:   // corresponding overflow list.
 36646:   nsIFrame* parent = aChildFrame->GetParent();
 79445:   bool found = parent->GetChildList(id).ContainsFrame(aChildFrame);
 36646:   if (!found) {
 36646:     if (!(aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
 77154:       found = parent->GetChildList(nsIFrame::kOverflowList)
 36646:                 .ContainsFrame(aChildFrame);
 36646:     }
107224:     else if (aChildFrame->IsFloating()) {
 77154:       found = parent->GetChildList(nsIFrame::kOverflowOutOfFlowList)
 36646:                 .ContainsFrame(aChildFrame);
 36646:     }
 77154:     // else it's positioned and should have been on the 'id' child list.
 36646:     NS_POSTCONDITION(found, "not in child list");
 36646:   }
 36646: #endif
 36646: 
 77154:   return id;
 36646: }
 36646: 
 36646: // static
     1: nsIFrame*
     1: nsLayoutUtils::GetBeforeFrame(nsIFrame* aFrame)
     1: {
     1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
     1:   NS_ASSERTION(!aFrame->GetPrevContinuation(),
     1:                "aFrame must be first continuation");
     1: 
     1:   nsIFrame* firstFrame = GetFirstChildFrame(aFrame, aFrame->GetContent());
     1: 
106838:   if (firstFrame && IsGeneratedContentFor(nullptr, firstFrame,
     1:                                           nsCSSPseudoElements::before)) {
     1:     return firstFrame;
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: // static
     1: nsIFrame*
     1: nsLayoutUtils::GetAfterFrame(nsIFrame* aFrame)
     1: {
     1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
     1: 
     1:   nsIFrame* lastFrame = GetLastChildFrame(aFrame, aFrame->GetContent());
     1: 
106838:   if (lastFrame && IsGeneratedContentFor(nullptr, lastFrame,
     1:                                          nsCSSPseudoElements::after)) {
     1:     return lastFrame;
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: // static
     1: nsIFrame*
  3113: nsLayoutUtils::GetClosestFrameOfType(nsIFrame* aFrame, nsIAtom* aFrameType)
     1: {
     1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
  3113:     if (frame->GetType() == aFrameType) {
     1:       return frame;
     1:     }
     1:   }
106838:   return nullptr;
     1: }
     1: 
 35300: // static
 35300: nsIFrame*
 35300: nsLayoutUtils::GetStyleFrame(nsIFrame* aFrame)
 35300: {
 35300:   if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
 77154:     nsIFrame* inner = aFrame->GetFirstPrincipalChild();
 35300:     NS_ASSERTION(inner, "Outer table must have an inner");
 35300:     return inner;
 35300:   }
 35300: 
 35300:   return aFrame;
 35300: }
 35300: 
     1: nsIFrame*
     1: nsLayoutUtils::GetFloatFromPlaceholder(nsIFrame* aFrame) {
 34911:   NS_ASSERTION(nsGkAtoms::placeholderFrame == aFrame->GetType(),
 34911:                "Must have a placeholder here");
 34912:   if (aFrame->GetStateBits() & PLACEHOLDER_FOR_FLOAT) {
     1:     nsIFrame *outOfFlowFrame =
     1:       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
107224:     NS_ASSERTION(outOfFlowFrame->IsFloating(),
 34912:                  "How did that happen?");
     1:     return outOfFlowFrame;
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: // static
 79445: bool
     1: nsLayoutUtils::IsGeneratedContentFor(nsIContent* aContent,
     1:                                      nsIFrame* aFrame,
     1:                                      nsIAtom* aPseudoElement)
     1: {
     1:   NS_PRECONDITION(aFrame, "Must have a frame");
     1:   NS_PRECONDITION(aPseudoElement, "Must have a pseudo name");
     1: 
     1:   if (!aFrame->IsGeneratedContentFrame()) {
 80486:     return false;
     1:   }
 16976:   nsIFrame* parent = aFrame->GetParent();
 16976:   NS_ASSERTION(parent, "Generated content can't be root frame");
 16976:   if (parent->IsGeneratedContentFrame()) {
 16976:     // Not the root of the generated content
 80486:     return false;
     1:   }
     1: 
 16976:   if (aContent && parent->GetContent() != aContent) {
 80486:     return false;
 16976:   }
 16976: 
 16976:   return (aFrame->GetContent()->Tag() == nsGkAtoms::mozgeneratedcontentbefore) ==
 16976:     (aPseudoElement == nsCSSPseudoElements::before);
     1: }
     1: 
     1: // static
     1: nsIFrame*
 18884: nsLayoutUtils::GetCrossDocParentFrame(const nsIFrame* aFrame,
 18884:                                       nsPoint* aExtraOffset)
     1: {
     1:   nsIFrame* p = aFrame->GetParent();
     1:   if (p)
     1:     return p;
     1: 
     1:   nsIView* v = aFrame->GetView();
     1:   if (!v)
106838:     return nullptr;
     1:   v = v->GetParent(); // anonymous inner view
     1:   if (!v)
106838:     return nullptr;
 18884:   if (aExtraOffset) {
 18884:     *aExtraOffset += v->GetPosition();
 18884:   }
     1:   v = v->GetParent(); // subdocumentframe's view
106838:   return v ? v->GetFrame() : nullptr;
     1: }
     1: 
     1: // static
 79445: bool
     1: nsLayoutUtils::IsProperAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
     1:                                              nsIFrame* aCommonAncestor)
     1: {
110989:   if (aFrame == aAncestorFrame)
 80486:     return false;
110989:   return IsAncestorFrameCrossDoc(aAncestorFrame, aFrame, aCommonAncestor);
     1: }
     1: 
     1: // static
 79445: bool
114041: nsLayoutUtils::IsAncestorFrameCrossDoc(const nsIFrame* aAncestorFrame, const nsIFrame* aFrame,
114041:                                        const nsIFrame* aCommonAncestor)
 30518: {
114041:   for (const nsIFrame* f = aFrame; f != aCommonAncestor;
110989:        f = GetCrossDocParentFrame(f)) {
110989:     if (f == aAncestorFrame)
 80486:       return true;
110989:   }
110989:   return aCommonAncestor == aAncestorFrame;
 30518: }
 30518: 
 30518: // static
 79445: bool
     1: nsLayoutUtils::IsProperAncestorFrame(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
     1:                                      nsIFrame* aCommonAncestor)
     1: {
110989:   if (aFrame == aAncestorFrame)
 80486:     return false;
110989:   for (nsIFrame* f = aFrame; f != aCommonAncestor; f = f->GetParent()) {
110989:     if (f == aAncestorFrame)
 80486:       return true;
     1:   }
110989:   return aCommonAncestor == aAncestorFrame;
     1: }
     1: 
     1: // static
108991: int32_t
     1: nsLayoutUtils::DoCompareTreePosition(nsIContent* aContent1,
     1:                                      nsIContent* aContent2,
108991:                                      int32_t aIf1Ancestor,
108991:                                      int32_t aIf2Ancestor,
 32864:                                      const nsIContent* aCommonAncestor)
     1: {
     1:   NS_PRECONDITION(aContent1, "aContent1 must not be null");
     1:   NS_PRECONDITION(aContent2, "aContent2 must not be null");
     1: 
  7820:   nsAutoTArray<nsINode*, 32> content1Ancestors;
     1:   nsINode* c1;
119415:   for (c1 = aContent1; c1 && c1 != aCommonAncestor; c1 = c1->GetParentNode()) {
     1:     content1Ancestors.AppendElement(c1);
     1:   }
     1:   if (!c1 && aCommonAncestor) {
     1:     // So, it turns out aCommonAncestor was not an ancestor of c1. Oops.
     1:     // Never mind. We can continue as if aCommonAncestor was null.
106838:     aCommonAncestor = nullptr;
     1:   }
     1: 
  7820:   nsAutoTArray<nsINode*, 32> content2Ancestors;
     1:   nsINode* c2;
119415:   for (c2 = aContent2; c2 && c2 != aCommonAncestor; c2 = c2->GetParentNode()) {
     1:     content2Ancestors.AppendElement(c2);
     1:   }
     1:   if (!c2 && aCommonAncestor) {
     1:     // So, it turns out aCommonAncestor was not an ancestor of c2.
     1:     // We need to retry with no common ancestor hint.
     1:     return DoCompareTreePosition(aContent1, aContent2,
106838:                                  aIf1Ancestor, aIf2Ancestor, nullptr);
     1:   }
     1: 
  7820:   int last1 = content1Ancestors.Length() - 1;
  7820:   int last2 = content2Ancestors.Length() - 1;
106838:   nsINode* content1Ancestor = nullptr;
106838:   nsINode* content2Ancestor = nullptr;
     1:   while (last1 >= 0 && last2 >= 0
  7820:          && ((content1Ancestor = content1Ancestors.ElementAt(last1)) ==
  7820:              (content2Ancestor = content2Ancestors.ElementAt(last2)))) {
     1:     last1--;
     1:     last2--;
     1:   }
     1: 
     1:   if (last1 < 0) {
     1:     if (last2 < 0) {
     1:       NS_ASSERTION(aContent1 == aContent2, "internal error?");
     1:       return 0;
     1:     }
     1:     // aContent1 is an ancestor of aContent2
     1:     return aIf1Ancestor;
     1:   }
     1: 
     1:   if (last2 < 0) {
     1:     // aContent2 is an ancestor of aContent1
     1:     return aIf2Ancestor;
     1:   }
     1: 
     1:   // content1Ancestor != content2Ancestor, so they must be siblings with the same parent
119415:   nsINode* parent = content1Ancestor->GetParentNode();
 55416: #ifdef DEBUG
 55416:   // TODO: remove the uglyness, see bug 598468.
 55416:   NS_ASSERTION(gPreventAssertInCompareTreePosition || parent,
 55416:                "no common ancestor at all???");
 55416: #endif // DEBUG
     1:   if (!parent) { // different documents??
     1:     return 0;
     1:   }
     1: 
108991:   int32_t index1 = parent->IndexOf(content1Ancestor);
108991:   int32_t index2 = parent->IndexOf(content2Ancestor);
     1:   if (index1 < 0 || index2 < 0) {
     1:     // one of them must be anonymous; we can't determine the order
     1:     return 0;
     1:   }
     1: 
     1:   return index1 - index2;
     1: }
     1: 
     1: static nsIFrame* FillAncestors(nsIFrame* aFrame,
101616:                                nsIFrame* aStopAtAncestor,
     1:                                nsTArray<nsIFrame*>* aAncestors)
     1: {
     1:   while (aFrame && aFrame != aStopAtAncestor) {
     1:     aAncestors->AppendElement(aFrame);
101616:     aFrame = nsLayoutUtils::GetParentOrPlaceholderFor(aFrame);
     1:   }
     1:   return aFrame;
     1: }
     1: 
     1: // Return true if aFrame1 is after aFrame2
 79445: static bool IsFrameAfter(nsIFrame* aFrame1, nsIFrame* aFrame2)
     1: {
     1:   nsIFrame* f = aFrame2;
     1:   do {
     1:     f = f->GetNextSibling();
     1:     if (f == aFrame1)
 80486:       return true;
     1:   } while (f);
 80486:   return false;
     1: }
     1: 
     1: // static
108991: int32_t
     1: nsLayoutUtils::DoCompareTreePosition(nsIFrame* aFrame1,
     1:                                      nsIFrame* aFrame2,
108991:                                      int32_t aIf1Ancestor,
108991:                                      int32_t aIf2Ancestor,
     1:                                      nsIFrame* aCommonAncestor)
     1: {
     1:   NS_PRECONDITION(aFrame1, "aFrame1 must not be null");
     1:   NS_PRECONDITION(aFrame2, "aFrame2 must not be null");
     1: 
   238:   nsPresContext* presContext = aFrame1->PresContext();
   238:   if (presContext != aFrame2->PresContext()) {
     1:     NS_ERROR("no common ancestor at all, different documents");
     1:     return 0;
     1:   }
     1: 
     1:   nsAutoTArray<nsIFrame*,20> frame1Ancestors;
101616:   if (!FillAncestors(aFrame1, aCommonAncestor, &frame1Ancestors)) {
     1:     // We reached the root of the frame tree ... if aCommonAncestor was set,
     1:     // it is wrong
106838:     aCommonAncestor = nullptr;
     1:   }
     1: 
     1:   nsAutoTArray<nsIFrame*,20> frame2Ancestors;
101616:   if (!FillAncestors(aFrame2, aCommonAncestor, &frame2Ancestors) &&
     1:       aCommonAncestor) {
     1:     // We reached the root of the frame tree ... aCommonAncestor was wrong.
     1:     // Try again with no hint.
     1:     return DoCompareTreePosition(aFrame1, aFrame2,
106838:                                  aIf1Ancestor, aIf2Ancestor, nullptr);
     1:   }
     1: 
108991:   int32_t last1 = int32_t(frame1Ancestors.Length()) - 1;
108991:   int32_t last2 = int32_t(frame2Ancestors.Length()) - 1;
     1:   while (last1 >= 0 && last2 >= 0 &&
     1:          frame1Ancestors[last1] == frame2Ancestors[last2]) {
     1:     last1--;
     1:     last2--;
     1:   }
     1: 
     1:   if (last1 < 0) {
     1:     if (last2 < 0) {
     1:       NS_ASSERTION(aFrame1 == aFrame2, "internal error?");
     1:       return 0;
     1:     }
     1:     // aFrame1 is an ancestor of aFrame2
     1:     return aIf1Ancestor;
     1:   }
     1: 
     1:   if (last2 < 0) {
     1:     // aFrame2 is an ancestor of aFrame1
     1:     return aIf2Ancestor;
     1:   }
     1: 
     1:   nsIFrame* ancestor1 = frame1Ancestors[last1];
     1:   nsIFrame* ancestor2 = frame2Ancestors[last2];
     1:   // Now we should be able to walk sibling chains to find which one is first
     1:   if (IsFrameAfter(ancestor2, ancestor1))
     1:     return -1;
     1:   if (IsFrameAfter(ancestor1, ancestor2))
     1:     return 1;
     1:   NS_WARNING("Frames were in different child lists???");
     1:   return 0;
     1: }
     1: 
     1: // static
     1: nsIFrame* nsLayoutUtils::GetLastSibling(nsIFrame* aFrame) {
     1:   if (!aFrame) {
106838:     return nullptr;
     1:   }
     1: 
     1:   nsIFrame* next;
106838:   while ((next = aFrame->GetNextSibling()) != nullptr) {
     1:     aFrame = next;
     1:   }
     1:   return aFrame;
     1: }
     1: 
     1: // static
     1: nsIView*
     1: nsLayoutUtils::FindSiblingViewFor(nsIView* aParentView, nsIFrame* aFrame) {
 82566:   nsIFrame* parentViewFrame = aParentView->GetFrame();
106838:   nsIContent* parentViewContent = parentViewFrame ? parentViewFrame->GetContent() : nullptr;
     1:   for (nsIView* insertBefore = aParentView->GetFirstChild(); insertBefore;
     1:        insertBefore = insertBefore->GetNextSibling()) {
 82566:     nsIFrame* f = insertBefore->GetFrame();
     1:     if (!f) {
     1:       // this view could be some anonymous view attached to a meaningful parent
     1:       for (nsIView* searchView = insertBefore->GetParent(); searchView;
     1:            searchView = searchView->GetParent()) {
 82566:         f = searchView->GetFrame();
     1:         if (f) {
     1:           break;
     1:         }
     1:       }
     1:       NS_ASSERTION(f, "Can't find a frame anywhere!");
     1:     }
     1:     if (!f || !aFrame->GetContent() || !f->GetContent() ||
     1:         CompareTreePosition(aFrame->GetContent(), f->GetContent(), parentViewContent) > 0) {
     1:       // aFrame's content is after f's content (or we just don't know),
     1:       // so put our view before f's view
     1:       return insertBefore;
     1:     }
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: //static
     1: nsIScrollableFrame*
114232: nsLayoutUtils::GetScrollableFrameFor(const nsIFrame *aScrolledFrame)
     1: {
     1:   nsIFrame *frame = aScrolledFrame->GetParent();
     1:   if (!frame) {
106838:     return nullptr;
     1:   }
 23554:   nsIScrollableFrame *sf = do_QueryFrame(frame);
     1:   return sf;
     1: }
     1: 
 47736: nsIFrame*
 47736: nsLayoutUtils::GetActiveScrolledRootFor(nsIFrame* aFrame,
114041:                                         const nsIFrame* aStopAtAncestor)
 47736: {
 47742:   nsIFrame* f = aFrame;
 47742:   while (f != aStopAtAncestor) {
 50412:     if (IsPopup(f))
 50412:       break;
 49156:     nsIFrame* parent = GetCrossDocParentFrame(f);
 47742:     if (!parent)
 47742:       break;
 47742:     nsIScrollableFrame* sf = do_QueryFrame(parent);
 47742:     if (sf && sf->IsScrollingActive() && sf->GetScrolledFrame() == f)
 47742:       break;
 47742:     f = parent;
 47742:   }
 47742:   return f;
 47736: }
 47736: 
 67668: nsIFrame*
 67668: nsLayoutUtils::GetActiveScrolledRootFor(nsDisplayItem* aItem,
 69752:                                         nsDisplayListBuilder* aBuilder,
 79445:                                         bool* aShouldFixToViewport)
 67668: {
 67668:   nsIFrame* f = aItem->GetUnderlyingFrame();
 69752:   if (aShouldFixToViewport) {
 80486:     *aShouldFixToViewport = false;
 69752:   }
 67668:   if (!f) {
106838:     return nullptr;
 67668:   }
 67668:   if (aItem->ShouldFixToViewport(aBuilder)) {
 69752:     if (aShouldFixToViewport) {
 80486:       *aShouldFixToViewport = true;
 69752:     }
 67668:     // Make its active scrolled root be the active scrolled root of
 67668:     // the enclosing viewport, since it shouldn't be scrolled by scrolled
 67668:     // frames in its document. InvalidateFixedBackgroundFramesFromList in
 67668:     // nsGfxScrollFrame will not repaint this item when scrolling occurs.
 67668:     nsIFrame* viewportFrame =
 67668:       nsLayoutUtils::GetClosestFrameOfType(f, nsGkAtoms::viewportFrame);
 67668:     NS_ASSERTION(viewportFrame, "no viewport???");
114042:     return nsLayoutUtils::GetActiveScrolledRootFor(viewportFrame, aBuilder->FindReferenceFrameFor(viewportFrame));
 67668:   } else {
114042:     return nsLayoutUtils::GetActiveScrolledRootFor(f, aItem->ReferenceFrame());
 67668:   }
 67668: }
 67668: 
 79445: bool
114041: nsLayoutUtils::IsScrolledByRootContentDocumentDisplayportScrolling(const nsIFrame* aActiveScrolledRoot,
 67668:                                                                    nsDisplayListBuilder* aBuilder)
 67668: {
 99197:   nsPresContext* presContext = aActiveScrolledRoot->PresContext()->
 99197:           GetToplevelContentDocumentPresContext();
 99197:   if (!presContext)
 99197:     return false;
 99197: 
 99197:   nsIFrame* rootScrollFrame = presContext->GetPresShell()->GetRootScrollFrame();
106838:   if (!rootScrollFrame || !nsLayoutUtils::GetDisplayPort(rootScrollFrame->GetContent(), nullptr))
 99197:     return false;
 67668:   return nsLayoutUtils::IsAncestorFrameCrossDoc(rootScrollFrame, aActiveScrolledRoot);
 67668: }
 67668: 
     1: // static
     1: nsIScrollableFrame*
 37057: nsLayoutUtils::GetNearestScrollableFrameForDirection(nsIFrame* aFrame,
 37057:                                                      Direction aDirection)
     1: {
 37057:   NS_ASSERTION(aFrame, "GetNearestScrollableFrameForDirection expects a non-null frame");
 37057:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
 37057:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(f);
 37057:     if (scrollableFrame) {
 37057:       nsPresContext::ScrollbarStyles ss = scrollableFrame->GetScrollbarStyles();
114765:       uint32_t directions = scrollableFrame->GetPerceivedScrollingDirections();
 37057:       if (aDirection == eVertical ?
 37057:           (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN &&
114765:            (directions & nsIScrollableFrame::VERTICAL)) :
 37057:           (ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN &&
114765:            (directions & nsIScrollableFrame::HORIZONTAL)))
 37057:         return scrollableFrame;
 37057:     }
 37057:   }
106838:   return nullptr;
     1: }
     1: 
     1: // static
 37057: nsIScrollableFrame*
 37057: nsLayoutUtils::GetNearestScrollableFrame(nsIFrame* aFrame)
     1: {
 37057:   NS_ASSERTION(aFrame, "GetNearestScrollableFrame expects a non-null frame");
 37057:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
 37057:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(f);
 37057:     if (scrollableFrame) {
 37057:       nsPresContext::ScrollbarStyles ss = scrollableFrame->GetScrollbarStyles();
 37057:       if (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN ||
 37057:           ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN)
 37057:         return scrollableFrame;
 37057:     }
 37057:   }
106838:   return nullptr;
     1: }
     1: 
 48947: //static
 79445: bool
 48947: nsLayoutUtils::HasPseudoStyle(nsIContent* aContent,
 48947:                               nsStyleContext* aStyleContext,
 48947:                               nsCSSPseudoElements::Type aPseudoElement,
 48947:                               nsPresContext* aPresContext)
 48947: {
 48947:   NS_PRECONDITION(aPresContext, "Must have a prescontext");
 48947: 
 48947:   nsRefPtr<nsStyleContext> pseudoContext;
 48947:   if (aContent) {
 48947:     pseudoContext = aPresContext->StyleSet()->
 48947:       ProbePseudoElementStyle(aContent->AsElement(), aPseudoElement,
 48947:                               aStyleContext);
 48947:   }
106838:   return pseudoContext != nullptr;
 48947: }
 48947: 
     1: nsPoint
     1: nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(nsIDOMEvent* aDOMEvent, nsIFrame* aFrame)
     1: {
101616:   if (!aDOMEvent)
     1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
101616:   nsEvent *event = aDOMEvent->GetInternalNSEvent();
 20234:   if (!event)
     1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
     1:   return GetEventCoordinatesRelativeTo(event, aFrame);
     1: }
     1: 
     1: nsPoint
  2817: nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent, nsIFrame* aFrame)
     1: {
     1:   if (!aEvent || (aEvent->eventStructType != NS_MOUSE_EVENT &&
 18445:                   aEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
108049:                   aEvent->eventStructType != NS_WHEEL_EVENT &&
 23284:                   aEvent->eventStructType != NS_DRAG_EVENT &&
 28352:                   aEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT &&
 31443:                   aEvent->eventStructType != NS_GESTURENOTIFY_EVENT &&
 87650:                   aEvent->eventStructType != NS_TOUCH_EVENT &&
 28352:                   aEvent->eventStructType != NS_QUERY_CONTENT_EVENT))
     1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
     1: 
  3233:   const nsGUIEvent* GUIEvent = static_cast<const nsGUIEvent*>(aEvent);
 87650:   return GetEventCoordinatesRelativeTo(aEvent,
 87650:                                        GUIEvent->refPoint,
 87650:                                        aFrame);
 87650: }
 87650: 
 87650: nsPoint
 87650: nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent,
 87650:                                              const nsIntPoint aPoint,
 87650:                                              nsIFrame* aFrame)
 87650: {
 87650:   if (!aFrame) {
 87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 87650:   }
 87650: 
 87650:   const nsGUIEvent* GUIEvent = static_cast<const nsGUIEvent*>(aEvent);
 87650:   nsIWidget* widget = GUIEvent->widget;
 87650:   if (!widget) {
 87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 87650:   }
 87650: 
111609:   return GetEventCoordinatesRelativeTo(widget, aPoint, aFrame);
111609: }
111609: 
111609: nsPoint
111609: nsLayoutUtils::GetEventCoordinatesRelativeTo(nsIWidget* aWidget,
111609:                                              const nsIntPoint aPoint,
111609:                                              nsIFrame* aFrame)
111609: {
111609:   if (!aFrame || !aWidget) {
111609:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
111609:   }
111609: 
 91486:   nsIView* view = aFrame->GetView();
 91486:   if (view) {
 91649:     nsIWidget* frameWidget = view->GetWidget();
111609:     if (frameWidget && frameWidget == aWidget) {
 91486:       // Special case this cause it happens a lot.
 91486:       // This also fixes bug 664707, events in the extra-special case of select
 91486:       // dropdown popups that are transformed.
 91486:       nsPresContext* presContext = aFrame->PresContext();
 91649:       nsPoint pt(presContext->DevPixelsToAppUnits(aPoint.x),
 91649:                  presContext->DevPixelsToAppUnits(aPoint.y));
 91486:       return pt - view->ViewToWidgetOffset();
 91486:     }
 91486:   }
 91486: 
 87650:   /* If we walk up the frame tree and discover that any of the frames are
 87650:    * transformed, we need to do extra work to convert from the global
 87650:    * space to the local space.
 87650:    */
 87650:   nsIFrame* rootFrame = aFrame;
 87650:   bool transformFound = false;
 87650:   for (nsIFrame* f = aFrame; f; f = GetCrossDocParentFrame(f)) {
 87650:     if (f->IsTransformed()) {
 87650:       transformFound = true;
 87650:     }
 87650: 
 87650:     rootFrame = f;
 87650:   }
 87650: 
 87650:   nsIView* rootView = rootFrame->GetView();
 87650:   if (!rootView) {
 87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 87650:   }
 87650: 
 87650:   nsPoint widgetToView = TranslateWidgetToView(rootFrame->PresContext(),
111609:                                                aWidget, aPoint, rootView);
 87650: 
 87650:   if (widgetToView == nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE)) {
 87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 87650:   }
 87650: 
 87650:   // Convert from root document app units to app units of the document aFrame
 87650:   // is in.
108991:   int32_t rootAPD = rootFrame->PresContext()->AppUnitsPerDevPixel();
108991:   int32_t localAPD = aFrame->PresContext()->AppUnitsPerDevPixel();
 87650:   widgetToView = widgetToView.ConvertAppUnits(rootAPD, localAPD);
 87650: 
 87650:   /* If we encountered a transform, we can't do simple arithmetic to figure
 87650:    * out how to convert back to aFrame's coordinates and must use the CTM.
 87650:    */
 87650:   if (transformFound) {
 87650:     return TransformRootPointToFrame(aFrame, widgetToView);
 87650:   }
 87650: 
 87650:   /* Otherwise, all coordinate systems are translations of one another,
 87650:    * so we can just subtract out the different.
 87650:    */
 87650:   nsPoint offset = aFrame->GetOffsetToCrossDoc(rootFrame);
 87650:   return widgetToView - offset;
     1: }
     1: 
 39629: nsIFrame*
 48255: nsLayoutUtils::GetPopupFrameForEventCoordinates(nsPresContext* aPresContext,
 48255:                                                 const nsEvent* aEvent)
 39629: {
 39629: #ifdef MOZ_XUL
 39629:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 39629:   if (!pm) {
106838:     return nullptr;
 39629:   }
 39629:   nsTArray<nsIFrame*> popups = pm->GetVisiblePopups();
108991:   uint32_t i;
 39629:   // Search from top to bottom
 39629:   for (i = 0; i < popups.Length(); i++) {
 39629:     nsIFrame* popup = popups[i];
 48255:     if (popup->PresContext()->GetRootPresContext() == aPresContext &&
 55040:         popup->GetScrollableOverflowRect().Contains(
 39629:           GetEventCoordinatesRelativeTo(aEvent, popup))) {
 39629:       return popup;
 39629:     }
 39629:   }
 39629: #endif
106838:   return nullptr;
 39629: }
 39629: 
 74283: gfx3DMatrix
 74757: nsLayoutUtils::ChangeMatrixBasis(const gfxPoint3D &aOrigin,
 74283:                                  const gfx3DMatrix &aMatrix)
 19214: {
 77291:   gfx3DMatrix result = aMatrix;
 77291: 
 77291:   /* Translate to the origin before aMatrix */
 77291:   result.Translate(-aOrigin);
 77291: 
 77291:   /* Translate back into position after aMatrix */
 77291:   result.TranslatePost(aOrigin);
 77291: 
 77291:   return result; 
 19214: }
 19214: 
 19214: /**
 19214:  * Given a gfxFloat, constrains its value to be between nscoord_MIN and nscoord_MAX.
 19214:  *
 19214:  * @param aVal The value to constrain (in/out)
 19214:  */
 19214: static void ConstrainToCoordValues(gfxFloat &aVal)
 19214: {
 19214:   if (aVal <= nscoord_MIN)
 19214:     aVal = nscoord_MIN;
 19214:   else if (aVal >= nscoord_MAX)
 19214:     aVal = nscoord_MAX;
 19214: }
 19214: 
 19214: nsRect
 19214: nsLayoutUtils::RoundGfxRectToAppRect(const gfxRect &aRect, float aFactor)
 19214: {
 19214:   /* Get a new gfxRect whose units are app units by scaling by the specified factor. */
 68640:   gfxRect scaledRect = aRect;
 68640:   scaledRect.ScaleRoundOut(aFactor);
 19214: 
 19214:   /* We now need to constrain our results to the max and min values for coords. */
 68634:   ConstrainToCoordValues(scaledRect.x);
 68634:   ConstrainToCoordValues(scaledRect.y);
 68634:   ConstrainToCoordValues(scaledRect.width);
 68634:   ConstrainToCoordValues(scaledRect.height);
 19214: 
 19214:   /* Now typecast everything back.  This is guaranteed to be safe. */
 68632:   return nsRect(nscoord(scaledRect.X()), nscoord(scaledRect.Y()),
 68632:                 nscoord(scaledRect.Width()), nscoord(scaledRect.Height()));
 19214: }
 19214: 
 59779: 
 59779: nsRegion
 59779: nsLayoutUtils::RoundedRectIntersectRect(const nsRect& aRoundedRect,
 59779:                                         const nscoord aRadii[8],
 59779:                                         const nsRect& aContainedRect)
 59779: {
 59779:   // rectFullHeight and rectFullWidth together will approximately contain
 59779:   // the total area of the frame minus the rounded corners.
 59779:   nsRect rectFullHeight = aRoundedRect;
 59779:   nscoord xDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_X], aRadii[NS_CORNER_BOTTOM_LEFT_X]);
 59779:   rectFullHeight.x += xDiff;
 59779:   rectFullHeight.width -= NS_MAX(aRadii[NS_CORNER_TOP_RIGHT_X],
 59779:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_X]) + xDiff;
 59779:   nsRect r1;
 59779:   r1.IntersectRect(rectFullHeight, aContainedRect);
 59779: 
 59779:   nsRect rectFullWidth = aRoundedRect;
 59779:   nscoord yDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_Y], aRadii[NS_CORNER_TOP_RIGHT_Y]);
 59779:   rectFullWidth.y += yDiff;
 59779:   rectFullWidth.height -= NS_MAX(aRadii[NS_CORNER_BOTTOM_LEFT_Y],
 59779:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_Y]) + yDiff;
 59779:   nsRect r2;
 59779:   r2.IntersectRect(rectFullWidth, aContainedRect);
 59779: 
 59779:   nsRegion result;
 59779:   result.Or(r1, r2);
 59779:   return result;
 59779: }
 59779: 
 19214: nsRect
 63072: nsLayoutUtils::MatrixTransformRectOut(const nsRect &aBounds,
 74283:                                       const gfx3DMatrix &aMatrix, float aFactor)
 63072: {
 63072:   nsRect outside = aBounds;
 63072:   outside.ScaleRoundOut(1/aFactor);
 63072:   gfxRect image = aMatrix.TransformBounds(gfxRect(outside.x,
 63072:                                                   outside.y,
 63072:                                                   outside.width,
 63072:                                                   outside.height));
 63072:   return RoundGfxRectToAppRect(image, aFactor);
 63072: }
 63072: 
 63072: nsRect
 19214: nsLayoutUtils::MatrixTransformRect(const nsRect &aBounds,
 74283:                                    const gfx3DMatrix &aMatrix, float aFactor)
 19214: {
 63072:   gfxRect image = aMatrix.TransformBounds(gfxRect(NSAppUnitsToDoublePixels(aBounds.x, aFactor),
 63072:                                                   NSAppUnitsToDoublePixels(aBounds.y, aFactor),
 63072:                                                   NSAppUnitsToDoublePixels(aBounds.width, aFactor),
 63072:                                                   NSAppUnitsToDoublePixels(aBounds.height, aFactor)));
 19214: 
 19214:   return RoundGfxRectToAppRect(image, aFactor);
 19214: }
 19214: 
 19214: nsPoint
 19214: nsLayoutUtils::MatrixTransformPoint(const nsPoint &aPoint,
 74283:                                     const gfx3DMatrix &aMatrix, float aFactor)
 19214: {
 19214:   gfxPoint image = aMatrix.Transform(gfxPoint(NSAppUnitsToFloatPixels(aPoint.x, aFactor),
 19214:                                               NSAppUnitsToFloatPixels(aPoint.y, aFactor)));
 19214:   return nsPoint(NSFloatPixelsToAppUnits(float(image.x), aFactor),
 19214:                  NSFloatPixelsToAppUnits(float(image.y), aFactor));
 19214: }
 19214: 
 87659: gfx3DMatrix
114041: nsLayoutUtils::GetTransformToAncestor(nsIFrame *aFrame, const nsIFrame *aAncestor)
 86353: {
 86353:   nsIFrame* parent;
119295:   gfx3DMatrix ctm;
119295:   if (aFrame == aAncestor) {
119295:     return ctm;
119295:   }
119295:   ctm = aFrame->GetTransformMatrix(aAncestor, &parent);
 86353:   while (parent && parent != aAncestor) {
 89891:     if (!parent->Preserves3DChildren()) {
 89891:       ctm.ProjectTo2D();
 89891:     }
 86353:     ctm = ctm * parent->GetTransformMatrix(aAncestor, &parent);
 86353:   }
 86353:   return ctm;
 86353: }
 86353: 
116070: bool
116070: nsLayoutUtils::GetLayerTransformForFrame(nsIFrame* aFrame,
116070:                                          gfx3DMatrix* aTransform)
116070: {
116070:   // FIXME/bug 796690: we can sometimes compute a transform in these
116070:   // cases, it just increases complexity considerably.  Punt for now.
116070:   if (aFrame->Preserves3DChildren() || aFrame->HasTransformGetter()) {
116070:     return false;
116070:   }
116070: 
116070:   nsIFrame* root = nsLayoutUtils::GetDisplayRootFrame(aFrame);
116070:   if (root->HasAnyStateBits(NS_FRAME_UPDATE_LAYER_TREE)) {
116070:     // Content may have been invalidated, so we can't reliably compute
116070:     // the "layer transform" in general.
116070:     return false;
116070:   }
116070:   // If the caller doesn't care about the value, early-return to skip
116070:   // overhead below.
116070:   if (!aTransform) {
116070:     return true;
116070:   }
116070: 
116070:   nsDisplayListBuilder builder(root, nsDisplayListBuilder::OTHER,
116070:                                false/*don't build caret*/);
116070:   nsDisplayList list;  
116070:   nsDisplayTransform* item =
116070:     new (&builder) nsDisplayTransform(&builder, aFrame, &list);
116070: 
116070:   *aTransform =
116070:     item->GetTransform(aFrame->PresContext()->AppUnitsPerDevPixel());
116072:   item->~nsDisplayTransform();
116070: 
116070:   return true;
116070: }
116070: 
 86248: static gfxPoint
 86353: TransformGfxPointFromAncestor(nsIFrame *aFrame,
 86248:                               const gfxPoint &aPoint,
 86353:                               nsIFrame *aAncestor)
 86244: {
 87659:   gfx3DMatrix ctm = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestor);
 86353:   return ctm.Inverse().ProjectPoint(aPoint);
 86248: }
 86248: 
 86248: static gfxRect
 86353: TransformGfxRectFromAncestor(nsIFrame *aFrame,
 86248:                              const gfxRect &aRect,
114041:                              const nsIFrame *aAncestor)
 19214: {
 87659:   gfx3DMatrix ctm = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestor);
 86353:   return ctm.Inverse().ProjectRectBounds(aRect);
 86353: }
 86353: 
 86353: static gfxRect
 86353: TransformGfxRectToAncestor(nsIFrame *aFrame,
 86353:                            const gfxRect &aRect,
118835:                            const nsIFrame *aAncestor)
 86353: {
 87659:   gfx3DMatrix ctm = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestor);
 87914:   return ctm.TransformBounds(aRect);
 19214: }
 19214: 
 19214: nsPoint
 86353: nsLayoutUtils::TransformRootPointToFrame(nsIFrame *aFrame,
 19214:                                          const nsPoint &aPoint)
 19214: {
 74753:     float factor = aFrame->PresContext()->AppUnitsPerDevPixel();
 74753:     gfxPoint result(NSAppUnitsToFloatPixels(aPoint.x, factor),
 74753:                     NSAppUnitsToFloatPixels(aPoint.y, factor));
 74753: 
106838:     result = TransformGfxPointFromAncestor(aFrame, result, nullptr);
 74753: 
 74753:     return nsPoint(NSFloatPixelsToAppUnits(float(result.x), factor),
 74753:                    NSFloatPixelsToAppUnits(float(result.y), factor));
 74753: }
 74753: 
 74753: nsRect 
 86353: nsLayoutUtils::TransformAncestorRectToFrame(nsIFrame* aFrame,
 74753:                                             const nsRect &aRect,
114041:                                             const nsIFrame* aAncestor)
 74753: {
118836:     float srcAppUnitsPerDevPixel = aAncestor->PresContext()->AppUnitsPerDevPixel();
118836:     gfxRect result(NSAppUnitsToFloatPixels(aRect.x, srcAppUnitsPerDevPixel),
118836:                    NSAppUnitsToFloatPixels(aRect.y, srcAppUnitsPerDevPixel),
118836:                    NSAppUnitsToFloatPixels(aRect.width, srcAppUnitsPerDevPixel),
118836:                    NSAppUnitsToFloatPixels(aRect.height, srcAppUnitsPerDevPixel));
 74753: 
 86353:     result = TransformGfxRectFromAncestor(aFrame, result, aAncestor);
 86353: 
118836:     float destAppUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
118836:     return nsRect(NSFloatPixelsToAppUnits(float(result.x), destAppUnitsPerDevPixel),
118836:                   NSFloatPixelsToAppUnits(float(result.y), destAppUnitsPerDevPixel),
118836:                   NSFloatPixelsToAppUnits(float(result.width), destAppUnitsPerDevPixel),
118836:                   NSFloatPixelsToAppUnits(float(result.height), destAppUnitsPerDevPixel));
 86353: }
 86353: 
 86353: nsRect
 86353: nsLayoutUtils::TransformFrameRectToAncestor(nsIFrame* aFrame,
 86353:                                             const nsRect& aRect,
118835:                                             const nsIFrame* aAncestor)
 86353: {
118836:   float srcAppUnitsPerDevPixel = aFrame->PresContext()->AppUnitsPerDevPixel();
118836:   gfxRect result(NSAppUnitsToFloatPixels(aRect.x, srcAppUnitsPerDevPixel),
118836:                  NSAppUnitsToFloatPixels(aRect.y, srcAppUnitsPerDevPixel),
118836:                  NSAppUnitsToFloatPixels(aRect.width, srcAppUnitsPerDevPixel),
118836:                  NSAppUnitsToFloatPixels(aRect.height, srcAppUnitsPerDevPixel));
 86353: 
 86353:   result = TransformGfxRectToAncestor(aFrame, result, aAncestor);
 74753: 
118836:   float destAppUnitsPerDevPixel = aAncestor->PresContext()->AppUnitsPerDevPixel();
118836:   return nsRect(NSFloatPixelsToAppUnits(float(result.x), destAppUnitsPerDevPixel),
118836:                 NSFloatPixelsToAppUnits(float(result.y), destAppUnitsPerDevPixel),
118836:                 NSFloatPixelsToAppUnits(float(result.width), destAppUnitsPerDevPixel),
118836:                 NSFloatPixelsToAppUnits(float(result.height), destAppUnitsPerDevPixel));
 19214: }
 19214: 
 23738: static nsIntPoint GetWidgetOffset(nsIWidget* aWidget, nsIWidget*& aRootWidget) {
 23738:   nsIntPoint offset(0, 0);
  3778:   nsIWidget* parent = aWidget->GetParent();
  3778:   while (parent) {
 23738:     nsIntRect bounds;
  3778:     aWidget->GetBounds(bounds);
  3778:     offset += bounds.TopLeft();
  3778:     aWidget = parent;
  3778:     parent = aWidget->GetParent();
  3778:   }
  3778:   aRootWidget = aWidget;
  3778:   return offset;
  3778: }
  3778: 
     1: nsPoint
     1: nsLayoutUtils::TranslateWidgetToView(nsPresContext* aPresContext,
     1:                                      nsIWidget* aWidget, nsIntPoint aPt,
     1:                                      nsIView* aView)
     1: {
  3778:   nsPoint viewOffset;
  3778:   nsIWidget* viewWidget = aView->GetNearestWidget(&viewOffset);
 50858:   if (!viewWidget) {
 50858:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 50858:   }
  3778: 
  3778:   nsIWidget* fromRoot;
 23738:   nsIntPoint fromOffset = GetWidgetOffset(aWidget, fromRoot);
  3778:   nsIWidget* toRoot;
 23738:   nsIntPoint toOffset = GetWidgetOffset(viewWidget, toRoot);
  3778: 
  3778:   nsIntPoint widgetPoint;
  3778:   if (fromRoot == toRoot) {
  3778:     widgetPoint = aPt + fromOffset - toOffset;
  3778:   } else {
 25183:     nsIntPoint screenPoint = aWidget->WidgetToScreenOffset();
 25183:     widgetPoint = aPt + screenPoint - viewWidget->WidgetToScreenOffset();
  3778:   }
  3778: 
  3778:   nsPoint widgetAppUnits(aPresContext->DevPixelsToAppUnits(widgetPoint.x),
  3778:                          aPresContext->DevPixelsToAppUnits(widgetPoint.y));
  3778:   return widgetAppUnits - viewOffset;
     1: }
     1: 
     1: // Combine aNewBreakType with aOrigBreakType, but limit the break types
     1: // to NS_STYLE_CLEAR_LEFT, RIGHT, LEFT_AND_RIGHT.
108991: uint8_t
108991: nsLayoutUtils::CombineBreakType(uint8_t aOrigBreakType,
108991:                                 uint8_t aNewBreakType)
     1: {
108991:   uint8_t breakType = aOrigBreakType;
     1:   switch(breakType) {
     1:   case NS_STYLE_CLEAR_LEFT:
     1:     if ((NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
     1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
     1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
     1:     }
     1:     break;
     1:   case NS_STYLE_CLEAR_RIGHT:
     1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
     1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
     1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
     1:     }
     1:     break;
     1:   case NS_STYLE_CLEAR_NONE:
     1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
     1:         (NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
     1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
     1:       breakType = aNewBreakType;
     1:     }
     1:   }
     1:   return breakType;
     1: }
     1: 
 82351: #ifdef MOZ_DUMP_PAINTING
     1: #include <stdio.h>
     1: 
 94996: static bool gDumpEventList = false;
 91338: int gPaintCount = 0;
     1: #endif
     1: 
 60444: nsresult
 60444: nsLayoutUtils::GetRemoteContentIds(nsIFrame* aFrame,
 60444:                                    const nsRect& aTarget,
 60444:                                    nsTArray<ViewID> &aOutIDs,
 79445:                                    bool aIgnoreRootScrollFrame)
 60444: {
 60444:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::EVENT_DELIVERY,
 80486:                                false);
 60444:   nsDisplayList list;
 60444: 
 94996:   if (aIgnoreRootScrollFrame) {
 60444:     nsIFrame* rootScrollFrame =
 60444:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
 60444:     if (rootScrollFrame) {
 60444:       builder.SetIgnoreScrollFrame(rootScrollFrame);
 60444:     }
 60444:   }
 60444: 
 60444:   builder.EnterPresShell(aFrame, aTarget);
 60444: 
 60444:   nsresult rv =
 60444:     aFrame->BuildDisplayListForStackingContext(&builder, aTarget, &list);
 60444: 
 60444:   builder.LeavePresShell(aFrame, aTarget);
 60444:   NS_ENSURE_SUCCESS(rv, rv);
 60444: 
 78095:   nsAutoTArray<nsIFrame*,8> outFrames;
 60444:   nsDisplayItem::HitTestState hitTestState(&aOutIDs);
 60444:   list.HitTest(&builder, aTarget, &hitTestState, &outFrames);
 60444:   list.DeleteAll();
 60444: 
 60444:   return NS_OK;
 60444: }
 60444: 
     1: nsIFrame*
  5440: nsLayoutUtils::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
 79445:                                 bool aShouldIgnoreSuppression,
 79445:                                 bool aIgnoreRootScrollFrame)
     1: {
 96794:   SAMPLE_LABEL("nsLayoutUtils", "GetFrameForPoint");
 40569:   nsresult rv;
 78095:   nsAutoTArray<nsIFrame*,8> outFrames;
 40569:   rv = GetFramesForArea(aFrame, nsRect(aPt, nsSize(1, 1)), outFrames,
 40569:                         aShouldIgnoreSuppression, aIgnoreRootScrollFrame);
106838:   NS_ENSURE_SUCCESS(rv, nullptr);
106838:   return outFrames.Length() ? outFrames.ElementAt(0) : nullptr;
 40569: }
 40569: 
 40569: nsresult
 40569: nsLayoutUtils::GetFramesForArea(nsIFrame* aFrame, const nsRect& aRect,
 40569:                                 nsTArray<nsIFrame*> &aOutFrames,
 79445:                                 bool aShouldIgnoreSuppression,
 79445:                                 bool aIgnoreRootScrollFrame)
 40569: {
 96794:   SAMPLE_LABEL("nsLayoutUtils","GetFramesForArea");
 57094:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::EVENT_DELIVERY,
 80486: 		                       false);
     1:   nsDisplayList list;
 40569:   nsRect target(aRect);
 40569: 
 40569:   if (aShouldIgnoreSuppression) {
  5440:     builder.IgnorePaintSuppression();
 40569:   }
 20863: 
 94996:   if (aIgnoreRootScrollFrame) {
 20863:     nsIFrame* rootScrollFrame =
 20863:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
 20863:     if (rootScrollFrame) {
 20863:       builder.SetIgnoreScrollFrame(rootScrollFrame);
 20863:     }
 20863:   }
 20863: 
     1:   builder.EnterPresShell(aFrame, target);
     1: 
     1:   nsresult rv =
     1:     aFrame->BuildDisplayListForStackingContext(&builder, target, &list);
     1: 
     1:   builder.LeavePresShell(aFrame, target);
 40569:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 82351: #ifdef MOZ_DUMP_PAINTING
     1:   if (gDumpEventList) {
 94996:     fprintf(stdout, "Event handling --- (%d,%d):\n", aRect.x, aRect.y);
 94996:     nsFrame::PrintDisplayList(&builder, list);
     1:   }
     1: #endif
     1: 
  9799:   nsDisplayItem::HitTestState hitTestState;
 40569:   list.HitTest(&builder, target, &hitTestState, &aOutFrames);
     1:   list.DeleteAll();
 40569:   return NS_OK;
     1: }
     1: 
     1: nsresult
 68481: nsLayoutUtils::PaintFrame(nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
 30541:                           const nsRegion& aDirtyRegion, nscolor aBackstop,
108991:                           uint32_t aFlags)
     1: {
 96794:   SAMPLE_LABEL("nsLayoutUtils","PaintFrame");
 49168:   if (aFlags & PAINT_WIDGET_LAYERS) {
 49168:     nsIView* view = aFrame->GetView();
 51184:     if (!(view && view->GetWidget() && GetDisplayRootFrame(aFrame) == aFrame)) {
 51184:       aFlags &= ~PAINT_WIDGET_LAYERS;
 51184:       NS_ASSERTION(aRenderingContext, "need a rendering context");
 51184:     }
 51184:   }
 49168: 
 47738:   nsPresContext* presContext = aFrame->PresContext();
 47739:   nsIPresShell* presShell = presContext->PresShell();
118837:   nsRootPresContext* rootPresContext = presContext->GetRootPresContext();
118837:   if (!rootPresContext) {
118837:     return NS_OK;
118837:   }
 47738: 
 63413:   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
 63413:   bool usingDisplayPort = false;
 63413:   nsRect displayport;
 63413:   if (rootScrollFrame) {
 63413:     nsIContent* content = rootScrollFrame->GetContent();
 63413:     if (content) {
 63413:       usingDisplayPort = nsLayoutUtils::GetDisplayPort(content, &displayport);
 63413:     }
 63413:   }
 63413: 
 79445:   bool ignoreViewportScrolling = presShell->IgnoringViewportScrolling();
 47738:   nsRegion visibleRegion;
 54080:   if (aFlags & PAINT_WIDGET_LAYERS) {
 47738:     // This layer tree will be reused, so we'll need to calculate it
 54080:     // for the whole "visible" area of the window
 54080:     // 
 54080:     // |ignoreViewportScrolling| and |usingDisplayPort| are persistent
 54080:     // document-rendering state.  We rely on PresShell to flush
 54080:     // retained layers as needed when that persistent state changes.
 63413:     if (!usingDisplayPort) {
 55040:       visibleRegion = aFrame->GetVisualOverflowRectRelativeToSelf();
 47738:     } else {
 63413:       visibleRegion = displayport;
 54080:     }
 54080:   } else {
 47738:     visibleRegion = aDirtyRegion;
 47738:   }
 47738: 
 51011:   // If we're going to display something different from what we'd normally
 51011:   // paint in a window then we will flush out any retained layer trees before
 51011:   // *and after* we draw.
 79445:   bool willFlushRetainedLayers = (aFlags & PAINT_HIDE_CARET) != 0;
 51011: 
 57094:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::PAINTING,
 57094: 		                       !(aFlags & PAINT_HIDE_CARET));
 67670:   if (usingDisplayPort) {
 69752:     builder.SetDisplayPort(displayport);
 67670:   }
 67670: 
     1:   nsDisplayList list;
 30541:   if (aFlags & PAINT_IN_TRANSFORM) {
 80486:     builder.SetInTransform(true);
 30541:   }
 32424:   if (aFlags & PAINT_SYNC_DECODE_IMAGES) {
 80486:     builder.SetSyncDecodeImages(true);
 32424:   }
 61835:   if (aFlags & (PAINT_WIDGET_LAYERS | PAINT_TO_WINDOW)) {
 80486:     builder.SetPaintingToWindow(true);
 42240:   }
 51851:   if (aFlags & PAINT_IGNORE_SUPPRESSION) {
 51851:     builder.IgnorePaintSuppression();
 47739:   }
118837:   // Windowed plugins aren't allowed in popups
118837:   if ((aFlags & PAINT_WIDGET_LAYERS) &&
118837:       !willFlushRetainedLayers &&
118837:       !(aFlags & PAINT_DOCUMENT_RELATIVE) &&
118837:       rootPresContext->NeedToComputePluginGeometryUpdates()) {
118837:     builder.SetWillComputePluginGeometry(true);
118837:   }
 47739:   nsRect canvasArea(nsPoint(0, 0), aFrame->GetSize());
 62806: 
 62806: #ifdef DEBUG
 54080:   if (ignoreViewportScrolling) {
 62806:     nsIDocument* doc = aFrame->GetContent() ?
106838:       aFrame->GetContent()->GetCurrentDoc() : nullptr;
 62806:     NS_ASSERTION(!aFrame->GetParent() ||
 62806:                  (doc && doc->IsBeingUsedAsImage()),
 62806:                  "Only expecting ignoreViewportScrolling for root frames and "
 62806:                  "for image documents.");
 62806:   }
 62806: #endif
 62806: 
 62806:   if (ignoreViewportScrolling && !aFrame->GetParent()) {
 47739:     nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
 47739:     if (rootScrollFrame) {
 47739:       nsIScrollableFrame* rootScrollableFrame =
 47739:         presShell->GetRootScrollFrameAsScrollable();
 54079:       if (aFlags & PAINT_DOCUMENT_RELATIVE) {
 47739:         // Make visibleRegion and aRenderingContext relative to the
 47739:         // scrolled frame instead of the root frame.
 47739:         nsPoint pos = rootScrollableFrame->GetScrollPosition();
 47739:         visibleRegion.MoveBy(-pos);
 54080:         if (aRenderingContext) {
 68479:           aRenderingContext->Translate(pos);
 54079:         }
 54080:       }
 47739:       builder.SetIgnoreScrollFrame(rootScrollFrame);
 47739: 
 47739:       nsCanvasFrame* canvasFrame =
 47739:         do_QueryFrame(rootScrollableFrame->GetScrolledFrame());
 47739:       if (canvasFrame) {
 47739:         // Use UnionRect here to ensure that areas where the scrollbars
 47739:         // were are still filled with the background color.
 47739:         canvasArea.UnionRect(canvasArea,
 47739:           canvasFrame->CanvasArea() + builder.ToReferenceFrame(canvasFrame));
 47739:       }
 47739:     }
 47739:   }
 29987:   nsresult rv;
 29987: 
 47738:   nsRect dirtyRect = visibleRegion.GetBounds();
     1:   builder.EnterPresShell(aFrame, dirtyRect);
 96794:   {
 96794:   SAMPLE_LABEL("nsLayoutUtils","PaintFrame::BuildDisplayList");
 29987:   rv = aFrame->BuildDisplayListForStackingContext(&builder, dirtyRect, &list);
 96794:   }
 79445:   const bool paintAllContinuations = aFlags & PAINT_ALL_CONTINUATIONS;
 50424:   NS_ASSERTION(!paintAllContinuations || !aFrame->GetPrevContinuation(),
 50424:                "If painting all continuations, the frame must be "
 50424:                "first-continuation");
 50424: 
 49168:   nsIAtom* frameType = aFrame->GetType();
     1: 
 50424:   if (paintAllContinuations) {
 50424:     nsIFrame* currentFrame = aFrame;
 50424:     while (NS_SUCCEEDED(rv) &&
106838:            (currentFrame = currentFrame->GetNextContinuation()) != nullptr) {
 96794:       SAMPLE_LABEL("nsLayoutUtils","PaintFrame::ContinuationsBuildDisplayList");
 50424:       nsRect frameDirty = dirtyRect - builder.ToReferenceFrame(currentFrame);
 50424:       rv = currentFrame->BuildDisplayListForStackingContext(&builder,
 50424:                                                             frameDirty, &list);
 50424:     }
 50424:   }
 50424: 
 30869:   // For the viewport frame in print preview/page layout we want to paint
 30869:   // the grey background behind the page, not the canvas color.
 30869:   if (frameType == nsGkAtoms::viewportFrame && 
 49166:       nsLayoutUtils::NeedsPrintPreviewBackground(presContext)) {
 30869:     nsRect bounds = nsRect(builder.ToReferenceFrame(aFrame),
 30869:                            aFrame->GetSize());
 49166:     rv = presShell->AddPrintPreviewBackgroundItem(builder, list, aFrame, bounds);
 30869:   } else if (frameType != nsGkAtoms::pageFrame) {
 29987:     // For printing, this function is first called on an nsPageFrame, which
 29987:     // creates a display list with a PageContent item. The PageContent item's
 29987:     // paint function calls this function on the nsPageFrame's child which is
 29987:     // an nsPageContentFrame. We only want to add the canvas background color
 29987:     // item once, for the nsPageContentFrame.
 30869: 
 47741:     // Add the canvas background color to the bottom of the list. This
 47741:     // happens after we've built the list so that AddCanvasBackgroundColorItem
 47741:     // can monkey with the contents if necessary.
 80559:     canvasArea.IntersectRect(canvasArea, visibleRegion.GetBounds());
 47739:     rv = presShell->AddCanvasBackgroundColorItem(
 47739:            builder, list, aFrame, canvasArea, aBackstop);
 49168: 
 49168:     // If the passed in backstop color makes us draw something different from
 49168:     // normal, we need to flush layers.
 54080:     if ((aFlags & PAINT_WIDGET_LAYERS) && !willFlushRetainedLayers) {
 49168:       nsIView* view = aFrame->GetView();
 49168:       if (view) {
 49168:         nscolor backstop = presShell->ComputeBackstopColor(view);
 49168:         // The PresShell's canvas background color doesn't get updated until
 49168:         // EnterPresShell, so this check has to be done after that.
 49168:         nscolor canvasColor = presShell->GetCanvasBackground();
 49168:         if (NS_ComposeColors(aBackstop, canvasColor) !=
 49168:             NS_ComposeColors(backstop, canvasColor)) {
 80486:           willFlushRetainedLayers = true;
 49168:         }
 49168:       }
 49168:     }
 29987:   }
 29987: 
     1:   builder.LeavePresShell(aFrame, dirtyRect);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 51851:   if (builder.GetHadToIgnorePaintSuppression()) {
 80486:     willFlushRetainedLayers = true;
 51851:   }
 51851: 
 82351: #ifdef MOZ_DUMP_PAINTING
114988:   FILE* savedDumpFile = gfxUtils::sDumpPaintFile;
 94286:   if (gfxUtils::sDumpPaintList || gfxUtils::sDumpPainting) {
 91338:     if (gfxUtils::sDumpPaintingToFile) {
 91338:       nsCString string("dump-");
 91338:       string.AppendInt(gPaintCount);
 91338:       string.Append(".html");
 91338:       gfxUtils::sDumpPaintFile = fopen(string.BeginReading(), "w");
 91338:     } else {
 91338:       gfxUtils::sDumpPaintFile = stdout;
 91338:     }
107692:     if (gfxUtils::sDumpPaintingToFile) {
 91338:       fprintf(gfxUtils::sDumpPaintFile, "<html><head><script>var array = {}; function ViewImage(index) { window.location = array[index]; }</script></head><body>");
107692:     }
 91338:     fprintf(gfxUtils::sDumpPaintFile, "Painting --- before optimization (dirty %d,%d,%d,%d):\n",
     1:             dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
107692:     nsFrame::PrintDisplayList(&builder, list, gfxUtils::sDumpPaintFile, gfxUtils::sDumpPaintingToFile);
 91338:     if (gfxUtils::sDumpPaintingToFile) {
 91338:       fprintf(gfxUtils::sDumpPaintFile, "<script>");
 91338:     }
     1:   }
     1: #endif
     1: 
 51633:   list.ComputeVisibilityForRoot(&builder, &visibleRegion);
     1: 
108991:   uint32_t flags = nsDisplayList::PAINT_DEFAULT;
 38805:   if (aFlags & PAINT_WIDGET_LAYERS) {
 38805:     flags |= nsDisplayList::PAINT_USE_WIDGET_LAYERS;
 54080:     if (willFlushRetainedLayers) {
 54080:       // The caller wanted to paint from retained layers, but set up
 54080:       // the paint in such a way that we can't use them.  We're going
 54080:       // to display something different from what we'd normally paint
 54080:       // in a window, so make sure we flush out any retained layer
 54080:       // trees before *and after* we draw.  Callers should be fixed to
 54080:       // not do this.
 54080:       NS_WARNING("Flushing retained layers!");
 47739:       flags |= nsDisplayList::PAINT_FLUSH_LAYERS;
 62767:     } else if (!(aFlags & PAINT_DOCUMENT_RELATIVE)) {
 63893:       nsIWidget *widget = aFrame->GetNearestWidget();
 63893:       if (widget) {
 59778:         builder.SetFinalTransparentRegion(visibleRegion);
 60643:         // If we're finished building display list items for painting of the outermost
 60643:         // pres shell, notify the widget about any toolbars we've encountered.
 63893:         widget->UpdateThemeGeometries(builder.GetThemeGeometries());
 38805:       }
 47739:     }
 62767:   }
 60857:   if (aFlags & PAINT_EXISTING_TRANSACTION) {
 60857:     flags |= nsDisplayList::PAINT_EXISTING_TRANSACTION;
 60857:   }
108188:   if (aFlags & PAINT_NO_COMPOSITE) {
108188:     flags |= nsDisplayList::PAINT_NO_COMPOSITE;
108188:   }
 47738: 
 42246:   list.PaintRoot(&builder, aRenderingContext, flags);
 47738: 
118837: #ifdef MOZ_DUMP_PAINTING
118837:   if (gfxUtils::sDumpPaintList || gfxUtils::sDumpPainting) {
118837:     if (gfxUtils::sDumpPaintingToFile) {
118837:       fprintf(gfxUtils::sDumpPaintFile, "</script>");
118837:     }
118837:     fprintf(gfxUtils::sDumpPaintFile, "Painting --- after optimization:\n");
118837:     nsFrame::PrintDisplayList(&builder, list, gfxUtils::sDumpPaintFile, gfxUtils::sDumpPaintingToFile);
118837: 
118837:     fprintf(gfxUtils::sDumpPaintFile, "Painting --- retained layer tree:\n");
118837:     nsIWidget* widget = aFrame->GetNearestWidget();
118837:     if (widget) {
118837:       nsRefPtr<LayerManager> layerManager = widget->GetLayerManager();
118837:       if (layerManager) {
118837:         FrameLayerBuilder::DumpRetainedLayerTree(layerManager, gfxUtils::sDumpPaintFile,
118837:                                                  gfxUtils::sDumpPaintingToFile);
118837:       }
118837:     }
118837:     if (gfxUtils::sDumpPaintingToFile) {
118837:       fprintf(gfxUtils::sDumpPaintFile, "</body></html>");
118837:       fclose(gfxUtils::sDumpPaintFile);
118837:     }
118837:     gfxUtils::sDumpPaintFile = savedDumpFile;
118837:     gPaintCount++;
118837:   }
118837: #endif
118837: 
 69805:   // Update the widget's opaque region information. This sets
118837:   // glass boundaries on Windows. Also set up plugin clip regions and bounds.
 62767:   if ((aFlags & PAINT_WIDGET_LAYERS) &&
 62767:       !willFlushRetainedLayers &&
 62767:       !(aFlags & PAINT_DOCUMENT_RELATIVE)) {
 63893:     nsIWidget *widget = aFrame->GetNearestWidget();
 63893:     if (widget) {
 69805:       nsRegion excludedRegion = builder.GetExcludedGlassRegion();
 69805:       excludedRegion.Sub(excludedRegion, visibleRegion);
 69805:       nsIntRegion windowRegion(excludedRegion.ToNearestPixels(presContext->AppUnitsPerDevPixel()));
 69805:       widget->UpdateOpaqueRegion(windowRegion);
 62767:     }
 62767:   }
 62767: 
118837:   if (builder.WillComputePluginGeometry()) {
118837:     rootPresContext->ComputePluginGeometryUpdates(aFrame, &builder, &list);
118837:   }
 47738: 
     1:   // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
     1:   list.DeleteAll();
     1:   return NS_OK;
     1: }
     1: 
108991: int32_t
     1: nsLayoutUtils::GetZIndex(nsIFrame* aFrame) {
107225:   if (!aFrame->IsPositioned())
     1:     return 0;
     1: 
     1:   const nsStylePosition* position =
     1:     aFrame->GetStylePosition();
     1:   if (position->mZIndex.GetUnit() == eStyleUnit_Integer)
     1:     return position->mZIndex.GetIntValue();
     1: 
     1:   // sort the auto and 0 elements together
     1:   return 0;
     1: }
     1: 
     1: /**
     1:  * Uses a binary search for find where the cursor falls in the line of text
     1:  * It also keeps track of the part of the string that has already been measured
     1:  * so it doesn't have to keep measuring the same text over and over
     1:  *
     1:  * @param "aBaseWidth" contains the width in twips of the portion
     1:  * of the text that has already been measured, and aBaseInx contains
     1:  * the index of the text that has already been measured.
     1:  *
     1:  * @param aTextWidth returns the (in twips) the length of the text that falls
     1:  * before the cursor aIndex contains the index of the text where the cursor falls
     1:  */
 79445: bool
 68481: nsLayoutUtils::BinarySearchForPosition(nsRenderingContext* aRendContext,
     1:                         const PRUnichar* aText,
108991:                         int32_t    aBaseWidth,
108991:                         int32_t    aBaseInx,
108991:                         int32_t    aStartInx,
108991:                         int32_t    aEndInx,
108991:                         int32_t    aCursorPos,
108991:                         int32_t&   aIndex,
108991:                         int32_t&   aTextWidth)
     1: {
108991:   int32_t range = aEndInx - aStartInx;
     1:   if ((range == 1) || (range == 2 && NS_IS_HIGH_SURROGATE(aText[aStartInx]))) {
     1:     aIndex   = aStartInx + aBaseInx;
 68484:     aTextWidth = aRendContext->GetWidth(aText, aIndex);
 80486:     return true;
     1:   }
     1: 
108991:   int32_t inx = aStartInx + (range / 2);
     1: 
     1:   // Make sure we don't leave a dangling low surrogate
     1:   if (NS_IS_HIGH_SURROGATE(aText[inx-1]))
     1:     inx++;
     1: 
108991:   int32_t textWidth = aRendContext->GetWidth(aText, inx);
108991: 
108991:   int32_t fullWidth = aBaseWidth + textWidth;
     1:   if (fullWidth == aCursorPos) {
     1:     aTextWidth = textWidth;
     1:     aIndex = inx;
 80486:     return true;
     1:   } else if (aCursorPos < fullWidth) {
     1:     aTextWidth = aBaseWidth;
     1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, aStartInx, inx, aCursorPos, aIndex, aTextWidth)) {
 80486:       return true;
     1:     }
     1:   } else {
     1:     aTextWidth = fullWidth;
     1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, inx, aEndInx, aCursorPos, aIndex, aTextWidth)) {
 80486:       return true;
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
 12349: static void
 19125: AddBoxesForFrame(nsIFrame* aFrame,
 19125:                  nsLayoutUtils::BoxCallback* aCallback)
     1: {
 34387:   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudo();
     1: 
 12349:   if (pseudoType == nsCSSAnonBoxes::tableOuter) {
 77154:     AddBoxesForFrame(aFrame->GetFirstPrincipalChild(), aCallback);
 77154:     nsIFrame* kid = aFrame->GetFirstChild(nsIFrame::kCaptionList);
 12349:     if (kid) {
 19125:       AddBoxesForFrame(kid, aCallback);
 12349:     }
 12349:   } else if (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
 12349:              pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
 12349:              pseudoType == nsCSSAnonBoxes::mozMathMLAnonymousBlock ||
 12349:              pseudoType == nsCSSAnonBoxes::mozXULAnonymousBlock) {
 77154:     for (nsIFrame* kid = aFrame->GetFirstPrincipalChild(); kid; kid = kid->GetNextSibling()) {
 19125:       AddBoxesForFrame(kid, aCallback);
 12349:     }
 12349:   } else {
 19125:     aCallback->AddBox(aFrame);
 19125:   }
 19125: }
 19125: 
 19125: void
 19125: nsLayoutUtils::GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback)
 19125: {
 19125:   while (aFrame) {
 19125:     AddBoxesForFrame(aFrame, aCallback);
 19125:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
 19125:   }
 19125: }
 19125: 
102547: struct BoxToRect : public nsLayoutUtils::BoxCallback {
102547:   typedef nsSize (*GetRectFromFrameFun)(nsIFrame*);
102547: 
 19125:   nsIFrame* mRelativeTo;
 19125:   nsLayoutUtils::RectCallback* mCallback;
108991:   uint32_t mFlags;
102547:   GetRectFromFrameFun mRectFromFrame;
102547: 
102547:   BoxToRect(nsIFrame* aRelativeTo, nsLayoutUtils::RectCallback* aCallback,
108991:             uint32_t aFlags, GetRectFromFrameFun aRectFromFrame)
102547:     : mRelativeTo(aRelativeTo), mCallback(aCallback), mFlags(aFlags),
102547:       mRectFromFrame(aRectFromFrame) {}
 19125: 
 19125:   virtual void AddBox(nsIFrame* aFrame) {
 12349:     nsRect r;
 12349:     nsIFrame* outer = nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(aFrame, &r);
 86354:     if (!outer) {
 86354:       outer = aFrame;
102547:       r = nsRect(nsPoint(0, 0), mRectFromFrame(aFrame));
 86354:     }
 86354:     if (mFlags & nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS) {
 86354:       r = nsLayoutUtils::TransformFrameRectToAncestor(outer, r, mRelativeTo);
 86354:     } else {
 86354:       r += outer->GetOffsetTo(mRelativeTo);
 86354:     }
 86354:     mCallback->AddRect(r);
 12349:   }
 19125: };
     1: 
102547: static nsSize
102547: GetFrameBorderSize(nsIFrame* aFrame)
102547: {
102547:   return aFrame->GetSize();
102547: }
102547: 
 12349: void
 12349: nsLayoutUtils::GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
108991:                                  RectCallback* aCallback, uint32_t aFlags)
 12349: {
102547:   BoxToRect converter(aRelativeTo, aCallback, aFlags, &GetFrameBorderSize);
102547:   GetAllInFlowBoxes(aFrame, &converter);
102547: }
102547: 
102547: static nsSize
102547: GetFramePaddingSize(nsIFrame* aFrame)
102547: {
102547:   return aFrame->GetPaddingRect().Size();
102547: }
102547: 
102547: void
102547: nsLayoutUtils::GetAllInFlowPaddingRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
108991:                                         RectCallback* aCallback, uint32_t aFlags)
102547: {
102547:   BoxToRect converter(aRelativeTo, aCallback, aFlags, &GetFramePaddingSize);
 19125:   GetAllInFlowBoxes(aFrame, &converter);
     1: }
     1: 
 80486: nsLayoutUtils::RectAccumulator::RectAccumulator() : mSeenFirstRect(false) {}
 33027: 
 33027: void nsLayoutUtils::RectAccumulator::AddRect(const nsRect& aRect) {
 12349:   mResultRect.UnionRect(mResultRect, aRect);
 12349:   if (!mSeenFirstRect) {
 80486:     mSeenFirstRect = true;
 12349:     mFirstRect = aRect;
 12349:   }
 12349: }
 33027: 
 33027: nsLayoutUtils::RectListBuilder::RectListBuilder(nsClientRectList* aList)
 33027:   : mRectList(aList), mRV(NS_OK) {}
 33027: 
 33027: void nsLayoutUtils::RectListBuilder::AddRect(const nsRect& aRect) {
 33027:   nsRefPtr<nsClientRect> rect = new nsClientRect();
 33027: 
 33027:   rect->SetLayoutRect(aRect);
 33027:   mRectList->Append(rect);
 33027: }
 33027: 
 33027: nsIFrame* nsLayoutUtils::GetContainingBlockForClientRect(nsIFrame* aFrame)
 33027: {
 86354:   return aFrame->PresContext()->PresShell()->GetRootFrame();
 33027: }
 12349: 
 12349: nsRect
 86354: nsLayoutUtils::GetAllInFlowRectsUnion(nsIFrame* aFrame, nsIFrame* aRelativeTo,
108991:                                       uint32_t aFlags) {
 12349:   RectAccumulator accumulator;
 86354:   GetAllInFlowRects(aFrame, aRelativeTo, &accumulator, aFlags);
 12349:   return accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect
 12349:           : accumulator.mResultRect;
     1: }
     1: 
 15339: nsRect
102547: nsLayoutUtils::GetAllInFlowPaddingRectsUnion(nsIFrame* aFrame,
102547:                                              nsIFrame* aRelativeTo,
108991:                                              uint32_t aFlags)
102547: {
102547:   RectAccumulator accumulator;
102547:   GetAllInFlowPaddingRects(aFrame, aRelativeTo, &accumulator, aFlags);
102547:   return accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect
102547:           : accumulator.mResultRect;
102547: }
102547: 
102547: nsRect
 15339: nsLayoutUtils::GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
 59781:                                        nsIFrame* aFrame,
108991:                                        uint32_t aFlags)
 15339: {
 15339:   const nsStyleText* textStyle = aFrame->GetStyleText();
107806:   if (!textStyle->HasTextShadow(aFrame))
 15339:     return aTextAndDecorationsRect;
 15339: 
 15339:   nsRect resultRect = aTextAndDecorationsRect;
108991:   int32_t A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
108991:   for (uint32_t i = 0; i < textStyle->mTextShadow->Length(); ++i) {
 59781:     nsCSSShadowItem* shadow = textStyle->mTextShadow->ShadowAt(i);
 59781:     nsMargin blur = nsContextBoxBlur::GetBlurRadiusMargin(shadow->mRadius, A2D);
 59781:     if ((aFlags & EXCLUDE_BLUR_SHADOWS) && blur != nsMargin(0, 0, 0, 0))
 59781:       continue;
 59781: 
 15339:     nsRect tmpRect(aTextAndDecorationsRect);
 15339: 
 19207:     tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
 59781:     tmpRect.Inflate(blur);
 15339: 
 15339:     resultRect.UnionRect(resultRect, tmpRect);
 15339:   }
 15339:   return resultRect;
 15339: }
 15339: 
     1: nsresult
 56866: nsLayoutUtils::GetFontMetricsForFrame(const nsIFrame* aFrame,
 82672:                                       nsFontMetrics** aFontMetrics,
 82672:                                       float aInflation)
     1: {
  4355:   return nsLayoutUtils::GetFontMetricsForStyleContext(aFrame->GetStyleContext(),
 82672:                                                       aFontMetrics,
 82672:                                                       aInflation);
  4355: }
  4355: 
  4355: nsresult
  4355: nsLayoutUtils::GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
 82672:                                              nsFontMetrics** aFontMetrics,
 82672:                                              float aInflation)
  4355: {
 19962:   // pass the user font set object into the device context to pass along to CreateFontGroup
 19962:   gfxUserFontSet* fs = aStyleContext->PresContext()->GetUserFontSet();
 19962: 
 82672:   nsFont font = aStyleContext->GetStyleFont()->mFont;
 82672:   // We need to not run font.size through floats when it's large since
 82672:   // doing so would be lossy.  Fortunately, in such cases, aInflation is
 82672:   // guaranteed to be 1.0f.
 82672:   if (aInflation != 1.0f) {
 82672:     font.size = NSToCoordRound(font.size * aInflation);
 82672:   }
 19962:   return aStyleContext->PresContext()->DeviceContext()->GetMetricsFor(
 88039:                   font, aStyleContext->GetStyleFont()->mLanguage,
 22335:                   fs, *aFontMetrics);
     1: }
     1: 
     1: nsIFrame*
     1: nsLayoutUtils::FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame)
     1: {
     1:   nsIFrame* result = aDescendantFrame;
     1: 
     1:   while (result) {
     1:     nsIFrame* parent = result->GetParent();
     1:     if (parent == aParent) {
     1:       break;
     1:     }
     1: 
     1:     // The frame is not an immediate child of aParent so walk up another level
     1:     result = parent;
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: nsBlockFrame*
  9572: nsLayoutUtils::GetAsBlock(nsIFrame* aFrame)
  9572: {
 23554:   nsBlockFrame* block = do_QueryFrame(aFrame);
  9572:   return block;
  9572: }
  9572: 
  9572: nsBlockFrame*
     1: nsLayoutUtils::FindNearestBlockAncestor(nsIFrame* aFrame)
     1: {
     1:   nsIFrame* nextAncestor;
     1:   for (nextAncestor = aFrame->GetParent(); nextAncestor;
     1:        nextAncestor = nextAncestor->GetParent()) {
  9572:     nsBlockFrame* block = GetAsBlock(nextAncestor);
  9572:     if (block)
     1:       return block;
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: nsIFrame*
 21943: nsLayoutUtils::GetNonGeneratedAncestor(nsIFrame* aFrame)
 21943: {
 21943:   if (!(aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT))
 21943:     return aFrame;
 21943: 
 21943:   nsIFrame* f = aFrame;
 21943:   do {
101616:     f = GetParentOrPlaceholderFor(f);
 21943:   } while (f->GetStateBits() & NS_FRAME_GENERATED_CONTENT);
 21943:   return f;
 21943: }
 21943: 
 21943: nsIFrame*
101616: nsLayoutUtils::GetParentOrPlaceholderFor(nsIFrame* aFrame)
     1: {
  6521:   if ((aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 32108:       && !aFrame->GetPrevInFlow()) {
101616:     return aFrame->PresContext()->PresShell()->FrameManager()->
101616:       GetPlaceholderFrameFor(aFrame);
  6521:   }
     1:   return aFrame->GetParent();
     1: }
     1: 
     1: nsIFrame*
101616: nsLayoutUtils::GetParentOrPlaceholderForCrossDoc(nsIFrame* aFrame)
101616: {
101616:   nsIFrame* f = GetParentOrPlaceholderFor(aFrame);
101616:   if (f)
101616:     return f;
101616:   return GetCrossDocParentFrame(aFrame);
101616: }
101616: 
101616: nsIFrame*
    94: nsLayoutUtils::GetNextContinuationOrSpecialSibling(nsIFrame *aFrame)
    94: {
    94:   nsIFrame *result = aFrame->GetNextContinuation();
    94:   if (result)
    94:     return result;
    94: 
    94:   if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0) {
    94:     // We only store the "special sibling" annotation with the first
 27338:     // frame in the continuation chain. Walk back to find that frame now.
 27338:     aFrame = aFrame->GetFirstContinuation();
    94: 
 39965:     void* value = aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling());
  3233:     return static_cast<nsIFrame*>(value);
    94:   }
    94: 
106838:   return nullptr;
    94: }
    94: 
 19125: nsIFrame*
 19125: nsLayoutUtils::GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
 19125: {
 19125:   nsIFrame *result = aFrame->GetFirstContinuation();
 19125:   if (result->GetStateBits() & NS_FRAME_IS_SPECIAL) {
 80486:     while (true) {
 19125:       nsIFrame *f = static_cast<nsIFrame*>
 39965:         (result->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 19125:       if (!f)
 19125:         break;
 19125:       result = f;
 19125:     }
 19125:   }
 19125: 
 19125:   return result;
 19125: }
 19125: 
 79445: bool
     1: nsLayoutUtils::IsViewportScrollbarFrame(nsIFrame* aFrame)
     1: {
     1:   if (!aFrame)
 80486:     return false;
     1: 
     1:   nsIFrame* rootScrollFrame =
   238:     aFrame->PresContext()->PresShell()->GetRootScrollFrame();
     1:   if (!rootScrollFrame)
 80486:     return false;
     1: 
 23554:   nsIScrollableFrame* rootScrollableFrame = do_QueryFrame(rootScrollFrame);
     1:   NS_ASSERTION(rootScrollableFrame, "The root scorollable frame is null");
     1: 
     1:   if (!IsProperAncestorFrame(rootScrollFrame, aFrame))
 80486:     return false;
     1: 
     1:   nsIFrame* rootScrolledFrame = rootScrollableFrame->GetScrolledFrame();
     1:   return !(rootScrolledFrame == aFrame ||
     1:            IsProperAncestorFrame(rootScrolledFrame, aFrame));
     1: }
     1: 
     1: static nscoord AddPercents(nsLayoutUtils::IntrinsicWidthType aType,
     1:                            nscoord aCurrent, float aPercent)
     1: {
     1:   nscoord result = aCurrent;
     1:   if (aPercent > 0.0f && aType == nsLayoutUtils::PREF_WIDTH) {
     1:     // XXX Should we also consider percentages for min widths, up to a
     1:     // limit?
     1:     if (aPercent >= 1.0f)
     1:       result = nscoord_MAX;
     1:     else
     1:       result = NSToCoordRound(float(result) / (1.0f - aPercent));
     1:   }
     1:   return result;
     1: }
     1: 
 51406: // Use only for widths/heights (or their min/max), since it clamps
 51406: // negative calc() results to 0.
 79445: static bool GetAbsoluteCoord(const nsStyleCoord& aStyle, nscoord& aResult)
 16031: {
 49566:   if (aStyle.IsCalcUnit()) {
 49566:     if (aStyle.CalcHasPercent()) {
 80486:       return false;
 49566:     }
 49566:     // If it has no percents, we can pass 0 for the percentage basis.
 49566:     aResult = nsRuleNode::ComputeComputedCalc(aStyle, 0);
 51406:     if (aResult < 0)
 51406:       aResult = 0;
 80486:     return true;
 49566:   }
 49566: 
 16031:   if (eStyleUnit_Coord != aStyle.GetUnit())
 80486:     return false;
 16031: 
 16031:   aResult = aStyle.GetCoordValue();
 51406:   NS_ASSERTION(aResult >= 0, "negative widths not allowed");
 80486:   return true;
 16031: }
 16031: 
119240: // Only call on style coords for which GetAbsoluteCoord returned false.
 79445: static bool
  2301: GetPercentHeight(const nsStyleCoord& aStyle,
  2301:                  nsIFrame* aFrame,
  2301:                  nscoord& aResult)
  2301: {
119240:   if (eStyleUnit_Percent != aStyle.GetUnit() &&
119240:       !aStyle.IsCalcUnit())
 80486:     return false;
  2301: 
119240:   MOZ_ASSERT(!aStyle.IsCalcUnit() || aStyle.CalcHasPercent(),
119240:              "GetAbsoluteCoord should have handled this");
119240: 
 79487:   nsIFrame *f = aFrame->GetContainingBlock();
  2301:   if (!f) {
  2301:     NS_NOTREACHED("top of frame tree not a containing block");
 80486:     return false;
  2301:   }
  2301: 
  2301:   const nsStylePosition *pos = f->GetStylePosition();
  2301:   nscoord h;
 16031:   if (!GetAbsoluteCoord(pos->mHeight, h) &&
 16031:       !GetPercentHeight(pos->mHeight, f, h)) {
  2301:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto ||
 51406:                  pos->mHeight.HasPercent(),
  2301:                  "unknown height unit");
 48945:     nsIAtom* fType = f->GetType();
 48945:     if (fType != nsGkAtoms::viewportFrame && fType != nsGkAtoms::canvasFrame &&
 48945:         fType != nsGkAtoms::pageContentFrame) {
  2301:       // There's no basis for the percentage height, so it acts like auto.
  2301:       // Should we consider a max-height < min-height pair a basis for
  2301:       // percentage heights?  The spec is somewhat unclear, and not doing
  2301:       // so is simpler and avoids troubling discontinuities in behavior,
  2301:       // so I'll choose not to. -LDB
 80486:       return false;
  2301:     }
  2301: 
 48945:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto,
 48945:                  "Unexpected height unit for viewport or canvas or page-content");
 48945:     // For the viewport, canvas, and page-content kids, the percentage
 48945:     // basis is just the parent height.
 48945:     h = f->GetSize().height;
 48945:     if (h == NS_UNCONSTRAINEDSIZE) {
 48945:       // We don't have a percentage basis after all
 80486:       return false;
 48945:     }
 48945:   }
 48945: 
  2301:   nscoord maxh;
 16031:   if (GetAbsoluteCoord(pos->mMaxHeight, maxh) ||
 16031:       GetPercentHeight(pos->mMaxHeight, f, maxh)) {
  2301:     if (maxh < h)
  2301:       h = maxh;
  2301:   } else {
  2301:     NS_ASSERTION(pos->mMaxHeight.GetUnit() == eStyleUnit_None ||
 51406:                  pos->mMaxHeight.HasPercent(),
  2301:                  "unknown max-height unit");
  2301:   }
  2301: 
  2301:   nscoord minh;
 16031:   if (GetAbsoluteCoord(pos->mMinHeight, minh) ||
 16031:       GetPercentHeight(pos->mMinHeight, f, minh)) {
  2301:     if (minh > h)
  2301:       h = minh;
  2301:   } else {
111125:     NS_ASSERTION(pos->mMinHeight.HasPercent() ||
111125:                  pos->mMinHeight.GetUnit() == eStyleUnit_Auto,
  2301:                  "unknown min-height unit");
  2301:   }
  2301: 
119240:   if (aStyle.IsCalcUnit()) {
119240:     aResult = NS_MAX(nsRuleNode::ComputeComputedCalc(aStyle, h), 0);
119240:     return true;
119240:   }
119240: 
  2301:   aResult = NSToCoordRound(aStyle.GetPercentValue() * h);
 80486:   return true;
  2301: }
  2301: 
  8046: // Handles only -moz-max-content and -moz-min-content, and
  8046: // -moz-fit-content for min-width and max-width, since the others
  8046: // (-moz-fit-content for width, and -moz-available) have no effect on
  1068: // intrinsic widths.
  1068: enum eWidthProperty { PROP_WIDTH, PROP_MAX_WIDTH, PROP_MIN_WIDTH };
 79445: static bool
  1068: GetIntrinsicCoord(const nsStyleCoord& aStyle,
 68481:                   nsRenderingContext* aRenderingContext,
  1068:                   nsIFrame* aFrame,
  1068:                   eWidthProperty aProperty,
  1068:                   nscoord& aResult)
  1068: {
  1068:   NS_PRECONDITION(aProperty == PROP_WIDTH || aProperty == PROP_MAX_WIDTH ||
  1068:                   aProperty == PROP_MIN_WIDTH, "unexpected property");
  1068:   if (aStyle.GetUnit() != eStyleUnit_Enumerated)
 80486:     return false;
108991:   int32_t val = aStyle.GetIntValue();
  8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
  8046:                val == NS_STYLE_WIDTH_MIN_CONTENT ||
  8046:                val == NS_STYLE_WIDTH_FIT_CONTENT ||
  8046:                val == NS_STYLE_WIDTH_AVAILABLE,
  1068:                "unexpected enumerated value for width property");
  8046:   if (val == NS_STYLE_WIDTH_AVAILABLE)
 80486:     return false;
  8046:   if (val == NS_STYLE_WIDTH_FIT_CONTENT) {
  1068:     if (aProperty == PROP_WIDTH)
 80486:       return false; // handle like 'width: auto'
  1068:     if (aProperty == PROP_MAX_WIDTH)
  8046:       // constrain large 'width' values down to -moz-max-content
  8046:       val = NS_STYLE_WIDTH_MAX_CONTENT;
  1068:     else
  8046:       // constrain small 'width' or 'max-width' values up to -moz-min-content
  8046:       val = NS_STYLE_WIDTH_MIN_CONTENT;
  1068:   }
  1068: 
  8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
  8046:                val == NS_STYLE_WIDTH_MIN_CONTENT,
  1068:                "should have reduced everything remaining to one of these");
 88122: 
 88122:   // If aFrame is a container for font size inflation, then shrink
 88122:   // wrapping inside of it should not apply font size inflation.
 98992:   AutoMaybeDisableFontInflation an(aFrame);
 88122: 
  8046:   if (val == NS_STYLE_WIDTH_MAX_CONTENT)
  1068:     aResult = aFrame->GetPrefWidth(aRenderingContext);
  1068:   else
  1068:     aResult = aFrame->GetMinWidth(aRenderingContext);
 80486:   return true;
  1068: }
  1068: 
     1: #undef  DEBUG_INTRINSIC_WIDTH
     1: 
     1: #ifdef DEBUG_INTRINSIC_WIDTH
108991: static int32_t gNoiseIndent = 0;
     1: #endif
     1: 
     1: /* static */ nscoord
 68481: nsLayoutUtils::IntrinsicForContainer(nsRenderingContext *aRenderingContext,
     1:                                      nsIFrame *aFrame,
     1:                                      IntrinsicWidthType aType)
     1: {
     1:   NS_PRECONDITION(aFrame, "null frame");
     1:   NS_PRECONDITION(aType == MIN_WIDTH || aType == PREF_WIDTH, "bad type");
     1: 
     1: #ifdef DEBUG_INTRINSIC_WIDTH
     1:   nsFrame::IndentBy(stdout, gNoiseIndent);
  3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
     1:   printf(" %s intrinsic width for container:\n",
     1:          aType == MIN_WIDTH ? "min" : "pref");
     1: #endif
     1: 
 88122:   // If aFrame is a container for font size inflation, then shrink
 88122:   // wrapping inside of it should not apply font size inflation.
 98992:   AutoMaybeDisableFontInflation an(aFrame);
 88122: 
     1:   nsIFrame::IntrinsicWidthOffsetData offsets =
     1:     aFrame->IntrinsicWidthOffsets(aRenderingContext);
     1: 
     1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
108991:   uint8_t boxSizing = stylePos->mBoxSizing;
     1:   const nsStyleCoord &styleWidth = stylePos->mWidth;
     1:   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
     1:   const nsStyleCoord &styleMaxWidth = stylePos->mMaxWidth;
     1: 
     1:   // We build up two values starting with the content box, and then
     1:   // adding padding, border and margin.  The result is normally
     1:   // |result|.  Then, when we handle 'width', 'min-width', and
     1:   // 'max-width', we use the results we've been building in |min| as a
     1:   // minimum, overriding 'min-width'.  This ensures two things:
     1:   //   * that we don't let a value of 'box-sizing' specifying a width
     1:   //     smaller than the padding/border inside the box-sizing box give
     1:   //     a content width less than zero
     1:   //   * that we prevent tables from becoming smaller than their
     1:   //     intrinsic minimum width
     1:   nscoord result = 0, min = 0;
     1: 
 51407:   nscoord maxw;
 79445:   bool haveFixedMaxWidth = GetAbsoluteCoord(styleMaxWidth, maxw);
 51407:   nscoord minw;
111124: 
111124:   // Treat "min-width: auto" as 0.
111124:   bool haveFixedMinWidth;
111124:   if (eStyleUnit_Auto == styleMinWidth.GetUnit()) {
111124:     // NOTE: Technically, "auto" is supposed to behave like "min-content" on
111124:     // flex items. However, we don't need to worry about that here, because
111124:     // flex items' min-sizes are intentionally ignored until the flex
111124:     // container explicitly considers them during space distribution.
111124:     minw = 0;
111124:     haveFixedMinWidth = true;
111124:   } else {
111124:     haveFixedMinWidth = GetAbsoluteCoord(styleMinWidth, minw);
111124:   }
 51407: 
     1:   // If we have a specified width (or a specified 'min-width' greater
     1:   // than the specified 'max-width', which works out to the same thing),
     1:   // don't even bother getting the frame's intrinsic width.
  1068:   if (styleWidth.GetUnit() == eStyleUnit_Enumerated &&
  8046:       (styleWidth.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
  8046:        styleWidth.GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT)) {
  8046:     // -moz-fit-content and -moz-available enumerated widths compute intrinsic
  1068:     // widths just like auto.
  8046:     // For -moz-max-content and -moz-min-content, we handle them like
  1068:     // specified widths, but ignore -moz-box-sizing.
  1068:     boxSizing = NS_STYLE_BOX_SIZING_CONTENT;
  1068:   } else if (styleWidth.GetUnit() != eStyleUnit_Coord &&
 51407:              !(haveFixedMinWidth && haveFixedMaxWidth && maxw <= minw)) {
     1: #ifdef DEBUG_INTRINSIC_WIDTH
     1:     ++gNoiseIndent;
     1: #endif
     1:     if (aType == MIN_WIDTH)
     1:       result = aFrame->GetMinWidth(aRenderingContext);
     1:     else
     1:       result = aFrame->GetPrefWidth(aRenderingContext);
     1: #ifdef DEBUG_INTRINSIC_WIDTH
     1:     --gNoiseIndent;
     1:     nsFrame::IndentBy(stdout, gNoiseIndent);
  3233:     static_cast<nsFrame*>(aFrame)->ListTag(stdout);
     1:     printf(" %s intrinsic width from frame is %d.\n",
     1:            aType == MIN_WIDTH ? "min" : "pref", result);
     1: #endif
  2301: 
  2301:     // Handle elements with an intrinsic ratio (or size) and a specified
  2301:     // height, min-height, or max-height.
111125:     // NOTE: We treat "min-height:auto" as "0" for the purpose of this code,
111125:     // since that's what it means in all cases except for on flex items -- and
111125:     // even there, we're supposed to ignore it (i.e. treat it as 0) until the
111125:     // flex container explicitly considers it.
  2301:     const nsStyleCoord &styleHeight = stylePos->mHeight;
  2301:     const nsStyleCoord &styleMinHeight = stylePos->mMinHeight;
  2301:     const nsStyleCoord &styleMaxHeight = stylePos->mMaxHeight;
111125: 
  2301:     if (styleHeight.GetUnit() != eStyleUnit_Auto ||
111125:         !(styleMinHeight.GetUnit() == eStyleUnit_Auto || 
111125:           (styleMinHeight.GetUnit() == eStyleUnit_Coord &&
111125:            styleMinHeight.GetCoordValue() == 0)) ||
  2301:         styleMaxHeight.GetUnit() != eStyleUnit_None) {
  2301: 
  2301:       nsSize ratio = aFrame->GetIntrinsicRatio();
  2301: 
  2301:       if (ratio.height != 0) {
119018:         nscoord heightTakenByBoxSizing = 0;
119018:         switch (boxSizing) {
119018:         case NS_STYLE_BOX_SIZING_BORDER: {
119018:           const nsStyleBorder* styleBorder = aFrame->GetStyleBorder();
119018:           heightTakenByBoxSizing +=
119018:             styleBorder->GetComputedBorder().TopBottom();
119018:           // fall through
119018:         }
119018:         case NS_STYLE_BOX_SIZING_PADDING: {
119018:           const nsStylePadding* stylePadding = aFrame->GetStylePadding();
119018:           nscoord pad;
119018:           if (GetAbsoluteCoord(stylePadding->mPadding.GetTop(), pad) ||
119018:               GetPercentHeight(stylePadding->mPadding.GetTop(), aFrame, pad)) {
119018:             heightTakenByBoxSizing += pad;
119018:           }
119018:           if (GetAbsoluteCoord(stylePadding->mPadding.GetBottom(), pad) ||
119018:               GetPercentHeight(stylePadding->mPadding.GetBottom(), aFrame, pad)) {
119018:             heightTakenByBoxSizing += pad;
119018:           }
119018:           // fall through
119018:         }
119018:         case NS_STYLE_BOX_SIZING_CONTENT:
119018:         default:
119018:           break;
119018:         }
  2301: 
  2301:         nscoord h;
 16031:         if (GetAbsoluteCoord(styleHeight, h) ||
 16031:             GetPercentHeight(styleHeight, aFrame, h)) {
119018:           h = NS_MAX(0, h - heightTakenByBoxSizing);
  2301:           result =
  2301:             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
  2301:         }
  2301: 
 16031:         if (GetAbsoluteCoord(styleMaxHeight, h) ||
 16031:             GetPercentHeight(styleMaxHeight, aFrame, h)) {
119018:           h = NS_MAX(0, h - heightTakenByBoxSizing);
119059:           nscoord maxWidth =
119018:             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
119059:           if (maxWidth < result)
119059:             result = maxWidth;
  2301:         }
  2301: 
 16031:         if (GetAbsoluteCoord(styleMinHeight, h) ||
 16031:             GetPercentHeight(styleMinHeight, aFrame, h)) {
119018:           h = NS_MAX(0, h - heightTakenByBoxSizing);
119059:           nscoord minWidth =
119018:             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
119059:           if (minWidth > result)
119059:             result = minWidth;
  2301:         }
  2301:       }
  2301:     }
     1:   }
     1: 
     1:   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
     1:     // Tables can't shrink smaller than their intrinsic minimum width,
     1:     // no matter what.
     1:     min = aFrame->GetMinWidth(aRenderingContext);
     1:   }
     1: 
     1:   // We also need to track what has been added on outside of the box
     1:   // (controlled by 'box-sizing') where 'width', 'min-width' and
     1:   // 'max-width' are applied.  We have to account for these properties
     1:   // after getting all the offsets (margin, border, padding) because
     1:   // percentages do not operate linearly.
     1:   // Doing this is ok because although percentages aren't handled
     1:   // linearly, they are handled monotonically.
     1:   nscoord coordOutsideWidth = offsets.hPadding;
     1:   float pctOutsideWidth = offsets.hPctPadding;
     1: 
     1:   float pctTotal = 0.0f;
     1: 
     1:   if (boxSizing == NS_STYLE_BOX_SIZING_PADDING) {
     1:     min += coordOutsideWidth;
  6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
     1:     pctTotal += pctOutsideWidth;
     1: 
     1:     coordOutsideWidth = 0;
     1:     pctOutsideWidth = 0.0f;
     1:   }
     1: 
     1:   coordOutsideWidth += offsets.hBorder;
     1: 
     1:   if (boxSizing == NS_STYLE_BOX_SIZING_BORDER) {
     1:     min += coordOutsideWidth;
  6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
     1:     pctTotal += pctOutsideWidth;
     1: 
     1:     coordOutsideWidth = 0;
     1:     pctOutsideWidth = 0.0f;
     1:   }
     1: 
     1:   coordOutsideWidth += offsets.hMargin;
     1:   pctOutsideWidth += offsets.hPctMargin;
     1: 
     1:   min += coordOutsideWidth;
  6254:   result = NSCoordSaturatingAdd(result, coordOutsideWidth);
     1:   pctTotal += pctOutsideWidth;
     1: 
     1:   nscoord w;
 16031:   if (GetAbsoluteCoord(styleWidth, w) ||
  1068:       GetIntrinsicCoord(styleWidth, aRenderingContext, aFrame,
  1068:                         PROP_WIDTH, w)) {
     1:     result = AddPercents(aType, w + coordOutsideWidth, pctOutsideWidth);
     1:   }
 49566:   else if (aType == MIN_WIDTH &&
 49566:            // The only cases of coord-percent-calc() units that
 49566:            // GetAbsoluteCoord didn't handle are percent and calc()s
 49566:            // containing percent.
 49566:            styleWidth.IsCoordPercentCalcUnit() &&
     1:            aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
     1:     // A percentage width on replaced elements means they can shrink to 0.
     1:     result = 0; // let |min| handle padding/border/margin
     1:   }
     1:   else {
 49566:     // NOTE: We could really do a lot better for percents and for some
 49566:     // cases of calc() containing percent (certainly including any where
 49566:     // the coefficient on the percent is positive and there are no max()
 49566:     // expressions).  However, doing better for percents wouldn't be
 49566:     // backwards compatible.
     1:     result = AddPercents(aType, result, pctTotal);
     1:   }
     1: 
 51407:   if (haveFixedMaxWidth ||
  1068:       GetIntrinsicCoord(styleMaxWidth, aRenderingContext, aFrame,
  1068:                         PROP_MAX_WIDTH, maxw)) {
     1:     maxw = AddPercents(aType, maxw + coordOutsideWidth, pctOutsideWidth);
     1:     if (result > maxw)
     1:       result = maxw;
     1:   }
     1: 
 51407:   if (haveFixedMinWidth ||
  1068:       GetIntrinsicCoord(styleMinWidth, aRenderingContext, aFrame,
  1068:                         PROP_MIN_WIDTH, minw)) {
     1:     minw = AddPercents(aType, minw + coordOutsideWidth, pctOutsideWidth);
     1:     if (result < minw)
     1:       result = minw;
     1:   }
     1: 
     1:   min = AddPercents(aType, min, pctTotal);
     1:   if (result < min)
     1:     result = min;
     1: 
     1:   const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
     1:   if (aFrame->IsThemed(disp)) {
 23738:     nsIntSize size(0, 0);
 79445:     bool canOverride = true;
   238:     nsPresContext *presContext = aFrame->PresContext();
     1:     presContext->GetTheme()->
     1:       GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
     1:                            &size, &canOverride);
     1: 
     1:     nscoord themeWidth = presContext->DevPixelsToAppUnits(size.width);
     1: 
     1:     // GMWS() returns a border-box width
     1:     themeWidth += offsets.hMargin;
     1:     themeWidth = AddPercents(aType, themeWidth, offsets.hPctMargin);
     1: 
     1:     if (themeWidth > result || !canOverride)
     1:       result = themeWidth;
     1:   }
     1: 
     1: #ifdef DEBUG_INTRINSIC_WIDTH
     1:   nsFrame::IndentBy(stdout, gNoiseIndent);
  3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
     1:   printf(" %s intrinsic width for container is %d twips.\n",
     1:          aType == MIN_WIDTH ? "min" : "pref", result);
     1: #endif
     1: 
     1:   return result;
     1: }
     1: 
     1: /* static */ nscoord
     1: nsLayoutUtils::ComputeWidthDependentValue(
     1:                  nscoord              aContainingBlockWidth,
     1:                  const nsStyleCoord&  aCoord)
     1: {
 46369:   NS_WARN_IF_FALSE(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
 46369:                    "have unconstrained width; this should only result from "
 46369:                    "very large sizes, not attempts at intrinsic width "
 46369:                    "calculation");
     1: 
 51403:   if (aCoord.IsCoordPercentCalcUnit()) {
 51403:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockWidth);
     1:   }
  1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
  1068:                aCoord.GetUnit() == eStyleUnit_Auto,
  1068:                "unexpected width value");
     1:   return 0;
     1: }
     1: 
     1: /* static */ nscoord
  1068: nsLayoutUtils::ComputeWidthValue(
 68481:                  nsRenderingContext* aRenderingContext,
  1068:                  nsIFrame*            aFrame,
  1068:                  nscoord              aContainingBlockWidth,
  1068:                  nscoord              aContentEdgeToBoxSizing,
  1068:                  nscoord              aBoxSizingToMarginEdge,
  1068:                  const nsStyleCoord&  aCoord)
  1068: {
  1068:   NS_PRECONDITION(aFrame, "non-null frame expected");
  1068:   NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
 34267:   NS_WARN_IF_FALSE(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
 34267:                    "have unconstrained width; this should only result from "
 34267:                    "very large sizes, not attempts at intrinsic width "
 34267:                    "calculation");
  1068:   NS_PRECONDITION(aContainingBlockWidth >= 0,
  1068:                   "width less than zero");
  1068: 
  1068:   nscoord result;
 49566:   if (aCoord.IsCoordPercentCalcUnit()) {
108742:     result = nsRuleNode::ComputeCoordPercentCalc(aCoord, 
108742:                                                  aContainingBlockWidth);
 49566:     // The result of a calc() expression might be less than 0; we
 49566:     // should clamp at runtime (below).  (Percentages and coords that
 49566:     // are less than 0 have already been dropped by the parser.)
  1068:     result -= aContentEdgeToBoxSizing;
108742:   } else {
108742:     MOZ_ASSERT(eStyleUnit_Enumerated == aCoord.GetUnit());
 88122:     // If aFrame is a container for font size inflation, then shrink
 88122:     // wrapping inside of it should not apply font size inflation.
 98992:     AutoMaybeDisableFontInflation an(aFrame);
 88122: 
108991:     int32_t val = aCoord.GetIntValue();
  1068:     switch (val) {
  8046:       case NS_STYLE_WIDTH_MAX_CONTENT:
  1068:         result = aFrame->GetPrefWidth(aRenderingContext);
  1068:         NS_ASSERTION(result >= 0, "width less than zero");
  1068:         break;
  8046:       case NS_STYLE_WIDTH_MIN_CONTENT:
  1068:         result = aFrame->GetMinWidth(aRenderingContext);
  1068:         NS_ASSERTION(result >= 0, "width less than zero");
  1068:         break;
  8046:       case NS_STYLE_WIDTH_FIT_CONTENT:
  1068:         {
  1068:           nscoord pref = aFrame->GetPrefWidth(aRenderingContext),
  1068:                    min = aFrame->GetMinWidth(aRenderingContext),
  1068:                   fill = aContainingBlockWidth -
  1068:                          (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
 32531:           result = NS_MAX(min, NS_MIN(pref, fill));
  1068:           NS_ASSERTION(result >= 0, "width less than zero");
  1068:         }
  1068:         break;
  8046:       case NS_STYLE_WIDTH_AVAILABLE:
  1068:         result = aContainingBlockWidth -
  1068:                  (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
  1068:     }
108742:   }
108742: 
108742:   return NS_MAX(0, result);
108742: }
  1068: 
  1068: /* static */ nscoord
     1: nsLayoutUtils::ComputeHeightDependentValue(
     1:                  nscoord              aContainingBlockHeight,
     1:                  const nsStyleCoord&  aCoord)
     1: {
     1:   // XXXldb Some callers explicitly check aContainingBlockHeight
 51403:   // against NS_AUTOHEIGHT *and* unit against eStyleUnit_Percent or
 51403:   // calc()s containing percents before calling this function.
 51403:   // However, it would be much more likely to catch problems without
 51403:   // the unit conditions.
     1:   // XXXldb Many callers pass a non-'auto' containing block height when
     1:   // according to CSS2.1 they should be passing 'auto'.
 51403:   NS_PRECONDITION(NS_AUTOHEIGHT != aContainingBlockHeight ||
 51404:                   !aCoord.HasPercent(),
 51403:                   "unexpected containing block height");
 51403: 
 51403:   if (aCoord.IsCoordPercentCalcUnit()) {
 51403:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockHeight);
 51403:   }
 51403: 
  1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
  1068:                aCoord.GetUnit() == eStyleUnit_Auto,
  1068:                "unexpected height value");
     1:   return 0;
     1: }
     1: 
108991: #define MULDIV(a,b,c) (nscoord(int64_t(a) * int64_t(b) / int64_t(c)))
     1: 
     1: /* static */ nsSize
     1: nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
 68481:                    nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
  8147:                    const nsIFrame::IntrinsicSize& aIntrinsicSize,
  8142:                    nsSize aIntrinsicRatio, nsSize aCBSize,
  1068:                    nsSize aMargin, nsSize aBorder, nsSize aPadding)
     1: {
     1:   const nsStylePosition* stylePos = aFrame->GetStylePosition();
111204: 
111204:   // If we're a flex item, we'll compute our size a bit differently.
111204:   const nsStyleCoord* widthStyleCoord = &(stylePos->mWidth);
111204:   const nsStyleCoord* heightStyleCoord = &(stylePos->mHeight);
111204: 
111204:   bool isFlexItem = aFrame->IsFlexItem();
111204:   bool isHorizontalFlexItem = false;
111204: 
111204: #ifdef MOZ_FLEXBOX
111204:   if (isFlexItem) {
111204:     // Flex items use their "flex-basis" property in place of their main-size
111204:     // property (e.g. "width") for sizing purposes, *unless* they have
111204:     // "flex-basis:auto", in which case they use their main-size property after
111204:     // all.
111204:     uint32_t flexDirection =
111204:       aFrame->GetParent()->GetStylePosition()->mFlexDirection;
111204:     isHorizontalFlexItem =
111204:       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW ||
111204:       flexDirection == NS_STYLE_FLEX_DIRECTION_ROW_REVERSE;
111204: 
119147:     // NOTE: The logic here should match the similar chunk for determining
119147:     // widthStyleCoord and heightStyleCoord in nsFrame::ComputeSize().
119147:     const nsStyleCoord* flexBasis = &(stylePos->mFlexBasis);
119147:     if (flexBasis->GetUnit() != eStyleUnit_Auto) {
111204:       if (isHorizontalFlexItem) {
119147:         widthStyleCoord = flexBasis;
111204:       } else {
119147:         // One caveat for vertical flex items: We don't support enumerated
119147:         // values (e.g. "max-content") for height properties yet. So, if our
119147:         // computed flex-basis is an enumerated value, we'll just behave as if
119147:         // it were "auto", which means "use the main-size property after all"
119147:         // (which is "height", in this case).
119147:         // NOTE: Once we support intrinsic sizing keywords for "height",
119147:         // we should remove this check.
119147:         if (flexBasis->GetUnit() != eStyleUnit_Enumerated) {
119147:           heightStyleCoord = flexBasis;
119147:         }
111204:       }
111204:     }
111204:   }
111204: #endif // MOZ_FLEXBOX
111204: 
111204: 
     1:   // Handle intrinsic sizes and their interaction with
     1:   // {min-,max-,}{width,height} according to the rules in
     1:   // http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
     1: 
     1:   // Note: throughout the following section of the function, I avoid
     1:   // a * (b / c) because of its reduced accuracy relative to a * b / c
     1:   // or (a * b) / c (which are equivalent).
     1: 
111204:   const bool isAutoWidth = widthStyleCoord->GetUnit() == eStyleUnit_Auto;
111204:   const bool isAutoHeight = IsAutoHeight(*heightStyleCoord, aCBSize.height);
     1: 
     1:   nsSize boxSizingAdjust(0,0);
     1:   switch (stylePos->mBoxSizing) {
     1:     case NS_STYLE_BOX_SIZING_BORDER:
     1:       boxSizingAdjust += aBorder;
     1:       // fall through
     1:     case NS_STYLE_BOX_SIZING_PADDING:
     1:       boxSizingAdjust += aPadding;
     1:   }
  1068:   nscoord boxSizingToMarginEdgeWidth =
  1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
     1: 
     1:   nscoord width, minWidth, maxWidth, height, minHeight, maxHeight;
     1: 
     1:   if (!isAutoWidth) {
  1068:     width = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
  1068:               aFrame, aCBSize.width, boxSizingAdjust.width,
111204:               boxSizingToMarginEdgeWidth, *widthStyleCoord);
     1:   }
     1: 
111205:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None &&
111205:       !(isFlexItem && isHorizontalFlexItem)) {
  1068:     maxWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
  1068:                  aFrame, aCBSize.width, boxSizingAdjust.width,
  1068:                  boxSizingToMarginEdgeWidth, stylePos->mMaxWidth);
     1:   } else {
     1:     maxWidth = nscoord_MAX;
     1:   }
     1: 
111205:   // NOTE: Flex items ignore their min & max sizing properties in their
111205:   // flex container's main-axis.  (Those properties get applied later in
111205:   // the flexbox algorithm.)
111205:   if (stylePos->mMinWidth.GetUnit() != eStyleUnit_Auto &&
111205:       !(isFlexItem && isHorizontalFlexItem)) {
  1068:     minWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
  1068:                  aFrame, aCBSize.width, boxSizingAdjust.width,
  1068:                  boxSizingToMarginEdgeWidth, stylePos->mMinWidth);
111124:   } else {
111124:     // Treat "min-width: auto" as 0.
111124:     // NOTE: Technically, "auto" is supposed to behave like "min-content" on
111124:     // flex items. However, we don't need to worry about that here, because
111124:     // flex items' min-sizes are intentionally ignored until the flex
111124:     // container explicitly considers them during space distribution.
111124:     minWidth = 0;
111124:   }
     1: 
     1:   if (!isAutoHeight) {
108742:     height = nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
108742:                 boxSizingAdjust.height, 
111204:                 *heightStyleCoord);
     1:   }
     1: 
111205:   if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height) &&
111205:       !(isFlexItem && !isHorizontalFlexItem)) {
108742:     maxHeight = nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
108742:                   boxSizingAdjust.height, 
108742:                   stylePos->mMaxHeight);
     1:   } else {
     1:     maxHeight = nscoord_MAX;
     1:   }
     1: 
111205:   if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height) &&
111205:       !(isFlexItem && !isHorizontalFlexItem)) {
108742:     minHeight = nsLayoutUtils::ComputeHeightValue(aCBSize.height, 
108742:                   boxSizingAdjust.height,
108742:                   stylePos->mMinHeight);
     1:   } else {
     1:     minHeight = 0;
     1:   }
     1: 
  8142:   // Resolve percentage intrinsic width/height as necessary:
  8142: 
  8142:   NS_ASSERTION(aCBSize.width != NS_UNCONSTRAINEDSIZE,
  8142:                "Our containing block must not have unconstrained width!");
  8142: 
 79445:   bool hasIntrinsicWidth, hasIntrinsicHeight;
  8142:   nscoord intrinsicWidth, intrinsicHeight;
  8142: 
 71655:   if (aIntrinsicSize.width.GetUnit() == eStyleUnit_Coord) {
 80486:     hasIntrinsicWidth = true;
 71655:     intrinsicWidth = aIntrinsicSize.width.GetCoordValue();
 71655:     if (intrinsicWidth < 0)
 71655:       intrinsicWidth = 0;
  8142:   } else {
 71655:     NS_ASSERTION(aIntrinsicSize.width.GetUnit() == eStyleUnit_None,
 71655:                  "unexpected unit");
 80486:     hasIntrinsicWidth = false;
  8142:     intrinsicWidth = 0;
  8142:   }
  8142: 
 71655:   if (aIntrinsicSize.height.GetUnit() == eStyleUnit_Coord) {
 80486:     hasIntrinsicHeight = true;
 71655:     intrinsicHeight = aIntrinsicSize.height.GetCoordValue();
  8142:     if (intrinsicHeight < 0)
  8142:       intrinsicHeight = 0;
  8142:   } else {
 71655:     NS_ASSERTION(aIntrinsicSize.height.GetUnit() == eStyleUnit_None,
 71655:                  "unexpected unit");
 80486:     hasIntrinsicHeight = false;
  8142:     intrinsicHeight = 0;
  8142:   }
  8142: 
  8142:   NS_ASSERTION(aIntrinsicRatio.width >= 0 && aIntrinsicRatio.height >= 0,
  8142:                "Intrinsic ratio has a negative component!");
  8142: 
  8142:   // Now calculate the used values for width and height:
  8142: 
     1:   if (isAutoWidth) {
     1:     if (isAutoHeight) {
     1: 
     1:       // 'auto' width, 'auto' height
  8142: 
  8142:       // Get tentative values - CSS 2.1 sections 10.3.2 and 10.6.2:
  8142: 
  8142:       nscoord tentWidth, tentHeight;
  8142: 
  8142:       if (hasIntrinsicWidth) {
  8142:         tentWidth = intrinsicWidth;
  8142:       } else if (hasIntrinsicHeight && aIntrinsicRatio.height > 0) {
  8142:         tentWidth = MULDIV(intrinsicHeight, aIntrinsicRatio.width, aIntrinsicRatio.height);
  8142:       } else if (aIntrinsicRatio.width > 0) {
  8142:         tentWidth = aCBSize.width - boxSizingToMarginEdgeWidth; // XXX scrollbar?
  8142:         if (tentWidth < 0) tentWidth = 0;
  8142:       } else {
  8142:         tentWidth = nsPresContext::CSSPixelsToAppUnits(300);
  8142:       }
  8142: 
  8142:       if (hasIntrinsicHeight) {
  8142:         tentHeight = intrinsicHeight;
  8142:       } else if (aIntrinsicRatio.width > 0) {
  8142:         tentHeight = MULDIV(tentWidth, aIntrinsicRatio.height, aIntrinsicRatio.width);
  8142:       } else {
  8142:         tentHeight = nsPresContext::CSSPixelsToAppUnits(150);
  8142:       }
  8142: 
 74937:       return ComputeAutoSizeWithIntrinsicDimensions(minWidth, minHeight,
 74937:                                                     maxWidth, maxHeight,
 74937:                                                     tentWidth, tentHeight);
 74937:     } else {
 74937: 
 74937:       // 'auto' width, non-'auto' height
 74937:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
 74937:       if (aIntrinsicRatio.height > 0) {
 74937:         width = MULDIV(height, aIntrinsicRatio.width, aIntrinsicRatio.height);
 74937:       } else if (hasIntrinsicWidth) {
 74937:         width = intrinsicWidth;
 74937:       } else {
 74937:         width = nsPresContext::CSSPixelsToAppUnits(300);
 74937:       }
 74937:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
 74937: 
 74937:     }
 74937:   } else {
 74937:     if (isAutoHeight) {
 74937: 
 74937:       // non-'auto' width, 'auto' height
 74937:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
 74937:       if (aIntrinsicRatio.width > 0) {
 74937:         height = MULDIV(width, aIntrinsicRatio.height, aIntrinsicRatio.width);
 74937:       } else if (hasIntrinsicHeight) {
 74937:         height = intrinsicHeight;
 74937:       } else {
 74937:         height = nsPresContext::CSSPixelsToAppUnits(150);
 74937:       }
 74937:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
 74937: 
 74937:     } else {
 74937: 
 74937:       // non-'auto' width, non-'auto' height
 74937:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
 74937:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
 74937: 
 74937:     }
 74937:   }
 74937: 
 74937:   return nsSize(width, height);
 74937: }
 74937: 
 74937: nsSize
 74937: nsLayoutUtils::ComputeAutoSizeWithIntrinsicDimensions(nscoord minWidth, nscoord minHeight,
 74937:                                                       nscoord maxWidth, nscoord maxHeight,
 74937:                                                       nscoord tentWidth, nscoord tentHeight)
 74937: {
  8142:   // Now apply min/max-width/height - CSS 2.1 sections 10.4 and 10.7:
  8142: 
     1:   if (minWidth > maxWidth)
     1:     maxWidth = minWidth;
     1:   if (minHeight > maxHeight)
     1:     maxHeight = minHeight;
     1: 
     1:   nscoord heightAtMaxWidth, heightAtMinWidth,
     1:           widthAtMaxHeight, widthAtMinHeight;
  8142: 
  8142:   if (tentWidth > 0) {
  8142:     heightAtMaxWidth = MULDIV(maxWidth, tentHeight, tentWidth);
     1:     if (heightAtMaxWidth < minHeight)
     1:       heightAtMaxWidth = minHeight;
  8142:     heightAtMinWidth = MULDIV(minWidth, tentHeight, tentWidth);
     1:     if (heightAtMinWidth > maxHeight)
     1:       heightAtMinWidth = maxHeight;
     1:   } else {
 76754:     heightAtMaxWidth = heightAtMinWidth = NS_CSS_MINMAX(tentHeight, minHeight, maxHeight);
     1:   }
     1: 
  8142:   if (tentHeight > 0) {
  8142:     widthAtMaxHeight = MULDIV(maxHeight, tentWidth, tentHeight);
     1:     if (widthAtMaxHeight < minWidth)
     1:       widthAtMaxHeight = minWidth;
  8142:     widthAtMinHeight = MULDIV(minHeight, tentWidth, tentHeight);
     1:     if (widthAtMinHeight > maxWidth)
     1:       widthAtMinHeight = maxWidth;
     1:   } else {
 76754:     widthAtMaxHeight = widthAtMinHeight = NS_CSS_MINMAX(tentWidth, minWidth, maxWidth);
     1:   }
     1: 
  8142:   // The table at http://www.w3.org/TR/CSS21/visudet.html#min-max-widths :
  8142: 
 74937:   nscoord width, height;
 74937: 
  8142:   if (tentWidth > maxWidth) {
  8142:     if (tentHeight > maxHeight) {
108991:       if (int64_t(maxWidth) * int64_t(tentHeight) <=
108991:           int64_t(maxHeight) * int64_t(tentWidth)) {
     1:         width = maxWidth;
     1:         height = heightAtMaxWidth;
     1:       } else {
  8142:         width = widthAtMaxHeight;
     1:         height = maxHeight;
     1:       }
     1:     } else {
  8142:       // This also covers "(w > max-width) and (h < min-height)" since in
  8142:       // that case (max-width/w < 1), and with (h < min-height):
  8142:       //   max(max-width * h/w, min-height) == min-height
     1:       width = maxWidth;
     1:       height = heightAtMaxWidth;
     1:     }
  8142:   } else if (tentWidth < minWidth) {
  8142:     if (tentHeight < minHeight) {
108991:       if (int64_t(minWidth) * int64_t(tentHeight) <=
108991:           int64_t(minHeight) * int64_t(tentWidth)) {
  8142:         width = widthAtMinHeight;
     1:         height = minHeight;
     1:       } else {
     1:         width = minWidth;
     1:         height = heightAtMinWidth;
     1:       }
     1:     } else {
  8142:       // This also covers "(w < min-width) and (h > max-height)" since in
  8142:       // that case (min-width/w > 1), and with (h > max-height):
  8142:       //   min(min-width * h/w, max-height) == max-height
     1:       width = minWidth;
     1:       height = heightAtMinWidth;
     1:     }
     1:   } else {
  8142:     if (tentHeight > maxHeight) {
  8142:       width = widthAtMaxHeight;
     1:       height = maxHeight;
  8142:     } else if (tentHeight < minHeight) {
  8142:       width = widthAtMinHeight;
     1:       height = minHeight;
     1:     } else {
  8142:       width = tentWidth;
  8142:       height = tentHeight;
     1:     }
     1:   }
     1: 
     1:   return nsSize(width, height);
     1: }
     1: 
     1: /* static */ nscoord
     1: nsLayoutUtils::MinWidthFromInline(nsIFrame* aFrame,
 68481:                                   nsRenderingContext* aRenderingContext)
     1: {
 88122:   NS_ASSERTION(!nsLayoutUtils::IsContainerForFontSizeInflation(aFrame),
 88122:                "should not be container for font size inflation");
 88122: 
     1:   nsIFrame::InlineMinWidthData data;
     1:   DISPLAY_MIN_WIDTH(aFrame, data.prevLines);
     1:   aFrame->AddInlineMinWidth(aRenderingContext, &data);
  2668:   data.ForceBreak(aRenderingContext);
     1:   return data.prevLines;
     1: }
     1: 
     1: /* static */ nscoord
     1: nsLayoutUtils::PrefWidthFromInline(nsIFrame* aFrame,
 68481:                                    nsRenderingContext* aRenderingContext)
     1: {
 88122:   NS_ASSERTION(!nsLayoutUtils::IsContainerForFontSizeInflation(aFrame),
 88122:                "should not be container for font size inflation");
 88122: 
     1:   nsIFrame::InlinePrefWidthData data;
     1:   DISPLAY_PREF_WIDTH(aFrame, data.prevLines);
     1:   aFrame->AddInlinePrefWidth(aRenderingContext, &data);
  2668:   data.ForceBreak(aRenderingContext);
     1:   return data.prevLines;
     1: }
     1: 
 72260: static nscolor
 72260: DarkenColor(nscolor aColor)
 72260: {
108991:   uint16_t  hue, sat, value;
108991:   uint8_t alpha;
 72260: 
 72260:   // convert the RBG to HSV so we can get the lightness (which is the v)
 72260:   NS_RGB2HSV(aColor, hue, sat, value, alpha);
 72260: 
 72260:   // The goal here is to send white to black while letting colored
 72260:   // stuff stay colored... So we adopt the following approach.
 72260:   // Something with sat = 0 should end up with value = 0.  Something
 72260:   // with a high sat can end up with a high value and it's ok.... At
 72260:   // the same time, we don't want to make things lighter.  Do
 72260:   // something simple, since it seems to work.
 72260:   if (value > sat) {
 72260:     value = sat;
 72260:     // convert this color back into the RGB color space.
 72260:     NS_HSV2RGB(aColor, hue, sat, value, alpha);
 72260:   }
 72260:   return aColor;
 72260: }
 72260: 
 75138: // Check whether we should darken text/decoration colors. We need to do this if
 72260: // background images and colors are being suppressed, because that means
 72260: // light text will not be visible against the (presumed light-colored) background.
 79445: static bool
 72260: ShouldDarkenColors(nsPresContext* aPresContext)
 72260: {
 72260:   return !aPresContext->GetBackgroundColorDraw() &&
 72260:          !aPresContext->GetBackgroundImageDraw();
 72260: }
 72260: 
 72260: nscolor
 75138: nsLayoutUtils::GetColor(nsIFrame* aFrame, nsCSSProperty aProperty)
 72260: {
 75138:   nscolor color = aFrame->GetVisitedDependentColor(aProperty);
 72260:   if (ShouldDarkenColors(aFrame->PresContext())) {
 72260:     color = DarkenColor(color);
 72260:   }
 72260:   return color;
 72260: }
 72260: 
 72990: gfxFloat
 72990: nsLayoutUtils::GetSnappedBaselineY(nsIFrame* aFrame, gfxContext* aContext,
 72990:                                    nscoord aY, nscoord aAscent)
 72990: {
 72990:   gfxFloat appUnitsPerDevUnit = aFrame->PresContext()->AppUnitsPerDevPixel();
 72990:   gfxFloat baseline = gfxFloat(aY) + aAscent;
 72990:   gfxRect putativeRect(0, baseline/appUnitsPerDevUnit, 1, 1);
 80486:   if (!aContext->UserToDevicePixelSnapped(putativeRect, true))
 72990:     return baseline;
 72990:   return aContext->DeviceToUser(putativeRect.TopLeft()).y * appUnitsPerDevUnit;
 72990: }
 72990: 
     1: void
     1: nsLayoutUtils::DrawString(const nsIFrame*      aFrame,
 68481:                           nsRenderingContext* aContext,
     1:                           const PRUnichar*     aString,
108991:                           int32_t              aLength,
 24995:                           nsPoint              aPoint,
108991:                           uint8_t              aDirection)
     1: {
     1: #ifdef IBMBIDI
     1:   nsresult rv = NS_ERROR_FAILURE;
   238:   nsPresContext* presContext = aFrame->PresContext();
     1:   if (presContext->BidiEnabled()) {
 24995:     if (aDirection == NS_STYLE_DIRECTION_INHERIT) {
 24995:       aDirection = aFrame->GetStyleVisibility()->mDirection;
 24995:     }
     1:     nsBidiDirection direction =
 24995:       (NS_STYLE_DIRECTION_RTL == aDirection) ?
     1:       NSBIDI_RTL : NSBIDI_LTR;
 73724:     rv = nsBidiPresUtils::RenderText(aString, aLength, direction,
 60677:                                      presContext, *aContext, *aContext,
     1:                                      aPoint.x, aPoint.y);
     1:   }
     1:   if (NS_FAILED(rv))
     1: #endif // IBMBIDI
     1:   {
 80486:     aContext->SetTextRunRTL(false);
     1:     aContext->DrawString(aString, aLength, aPoint.x, aPoint.y);
     1:   }
     1: }
     1: 
     1: nscoord
     1: nsLayoutUtils::GetStringWidth(const nsIFrame*      aFrame,
 68481:                               nsRenderingContext* aContext,
     1:                               const PRUnichar*     aString,
108991:                               int32_t              aLength)
     1: {
     1: #ifdef IBMBIDI
   238:   nsPresContext* presContext = aFrame->PresContext();
     1:   if (presContext->BidiEnabled()) {
     1:     const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
     1:     nsBidiDirection direction =
     1:       (NS_STYLE_DIRECTION_RTL == vis->mDirection) ?
     1:       NSBIDI_RTL : NSBIDI_LTR;
 73724:     return nsBidiPresUtils::MeasureTextWidth(aString, aLength,
     1:                                              direction, presContext, *aContext);
     1:   }
     1: #endif // IBMBIDI
 80486:   aContext->SetTextRunRTL(false);
 68484:   return aContext->GetWidth(aString, aLength);
     1: }
     1: 
 72827: /* static */ void
 72827: nsLayoutUtils::PaintTextShadow(const nsIFrame* aFrame,
 72827:                                nsRenderingContext* aContext,
 72827:                                const nsRect& aTextRect,
 72827:                                const nsRect& aDirtyRect,
 72827:                                const nscolor& aForegroundColor,
 72827:                                TextShadowCallback aCallback,
 72827:                                void* aCallbackData)
 72827: {
 72827:   const nsStyleText* textStyle = aFrame->GetStyleText();
107806:   if (!textStyle->HasTextShadow(aFrame))
 72827:     return;
 72827: 
 72827:   // Text shadow happens with the last value being painted at the back,
 72827:   // ie. it is painted first.
 72827:   gfxContext* aDestCtx = aContext->ThebesContext();
108991:   for (uint32_t i = textStyle->mTextShadow->Length(); i > 0; --i) {
 72827:     nsCSSShadowItem* shadowDetails = textStyle->mTextShadow->ShadowAt(i - 1);
 72827:     nsPoint shadowOffset(shadowDetails->mXOffset,
 72827:                          shadowDetails->mYOffset);
 72827:     nscoord blurRadius = NS_MAX(shadowDetails->mRadius, 0);
 72827: 
 72827:     nsRect shadowRect(aTextRect);
 72827:     shadowRect.MoveBy(shadowOffset);
 72827: 
 72827:     nsPresContext* presCtx = aFrame->PresContext();
 72827:     nsContextBoxBlur contextBoxBlur;
 72827:     gfxContext* shadowContext = contextBoxBlur.Init(shadowRect, 0, blurRadius,
 72827:                                                     presCtx->AppUnitsPerDevPixel(),
106838:                                                     aDestCtx, aDirtyRect, nullptr);
 72827:     if (!shadowContext)
 72827:       continue;
 72827: 
 72827:     nscolor shadowColor;
 72827:     if (shadowDetails->mHasColor)
 72827:       shadowColor = shadowDetails->mColor;
 72827:     else
 72827:       shadowColor = aForegroundColor;
 72827: 
 72827:     // Conjure an nsRenderingContext from a gfxContext for drawing the text
 72828:     // to blur.
 72827:     nsRefPtr<nsRenderingContext> renderingContext = new nsRenderingContext();
 72827:     renderingContext->Init(presCtx->DeviceContext(), shadowContext);
 72827: 
 72827:     aDestCtx->Save();
 72827:     aDestCtx->NewPath();
 72827:     aDestCtx->SetColor(gfxRGBA(shadowColor));
 72827: 
 72827:     // The callback will draw whatever we want to blur as a shadow.
 72827:     aCallback(renderingContext, shadowOffset, shadowColor, aCallbackData);
 72827: 
 72827:     contextBoxBlur.DoPaint();
 72827:     aDestCtx->Restore();
 72827:   }
 72827: }
 72827: 
 28519: /* static */ nscoord
 68493: nsLayoutUtils::GetCenteredFontBaseline(nsFontMetrics* aFontMetrics,
 28519:                                        nscoord         aLineHeight)
 28519: {
 68495:   nscoord fontAscent = aFontMetrics->MaxAscent();
 68495:   nscoord fontHeight = aFontMetrics->MaxHeight();
 28519: 
 28519:   nscoord leading = aLineHeight - fontHeight;
 28519:   return fontAscent + leading/2;
 28519: }
 28519: 
 28519: 
 79445: /* static */ bool
     1: nsLayoutUtils::GetFirstLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
     1: {
 27100:   LinePosition position;
 27100:   if (!GetFirstLinePosition(aFrame, &position))
 80486:     return false;
 27100:   *aResult = position.mBaseline;
 80486:   return true;
 27100: }
 27100: 
 79445: /* static */ bool
 27100: nsLayoutUtils::GetFirstLinePosition(const nsIFrame* aFrame,
 27100:                                     LinePosition* aResult)
 27100: {
 15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
 15909:   if (!block) {
     1:     // For the first-line baseline we also have to check for a table, and if
     1:     // so, use the baseline of its first row.
     1:     nsIAtom* fType = aFrame->GetType();
     1:     if (fType == nsGkAtoms::tableOuterFrame) {
 27100:       aResult->mTop = 0;
 27100:       aResult->mBaseline = aFrame->GetBaseline();
 27100:       // This is what we want for the list bullet caller; not sure if
 27100:       // other future callers will want the same.
 27100:       aResult->mBottom = aFrame->GetSize().height;
 80486:       return true;
     1:     }
     1: 
     1:     // For first-line baselines, we have to consider scroll frames.
     1:     if (fType == nsGkAtoms::scrollFrame) {
 23554:       nsIScrollableFrame *sFrame = do_QueryFrame(const_cast<nsIFrame*>(aFrame));
 23554:       if (!sFrame) {
     1:         NS_NOTREACHED("not scroll frame");
     1:       }
 27100:       LinePosition kidPosition;
 27100:       if (GetFirstLinePosition(sFrame->GetScrolledFrame(), &kidPosition)) {
     1:         // Consider only the border and padding that contributes to the
     1:         // kid's position, not the scrolling, so we get the initial
     1:         // position.
 27100:         *aResult = kidPosition + aFrame->GetUsedBorderAndPadding().top;
 80486:         return true;
 80486:       }
 80486:       return false;
     1:     }
     1: 
 48894:     if (fType == nsGkAtoms::fieldSetFrame) {
 48894:       LinePosition kidPosition;
 77154:       nsIFrame* kid = aFrame->GetFirstPrincipalChild();
 48894:       // kid might be a legend frame here, but that's ok.
 48894:       if (GetFirstLinePosition(kid, &kidPosition)) {
119239:         *aResult = kidPosition + (kid->GetPosition().y -
119239:                                   kid->GetRelativeOffset().y);
 80486:         return true;
 80486:       }
 80486:       return false;
 48894:     }
 48894: 
     1:     // No baseline.
 80486:     return false;
     1:   }
     1: 
     1:   for (nsBlockFrame::const_line_iterator line = block->begin_lines(),
     1:                                      line_end = block->end_lines();
     1:        line != line_end; ++line) {
     1:     if (line->IsBlock()) {
     1:       nsIFrame *kid = line->mFirstChild;
 27100:       LinePosition kidPosition;
 27100:       if (GetFirstLinePosition(kid, &kidPosition)) {
119239:         *aResult = kidPosition + (kid->GetPosition().y -
119239:                                   kid->GetRelativeOffset().y);
 80486:         return true;
     1:       }
     1:     } else {
     1:       // XXX Is this the right test?  We have some bogus empty lines
     1:       // floating around, but IsEmpty is perhaps too weak.
     1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
 27100:         nscoord top = line->mBounds.y;
 27100:         aResult->mTop = top;
 27100:         aResult->mBaseline = top + line->GetAscent();
 27100:         aResult->mBottom = top + line->GetHeight();
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
 79445: /* static */ bool
     1: nsLayoutUtils::GetLastLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
     1: {
 15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
 15909:   if (!block)
     1:     // No baseline.  (We intentionally don't descend into scroll frames.)
 80486:     return false;
     1: 
     1:   for (nsBlockFrame::const_reverse_line_iterator line = block->rbegin_lines(),
     1:                                              line_end = block->rend_lines();
     1:        line != line_end; ++line) {
     1:     if (line->IsBlock()) {
     1:       nsIFrame *kid = line->mFirstChild;
     1:       nscoord kidBaseline;
     1:       if (GetLastLineBaseline(kid, &kidBaseline)) {
119239:         // Ignore relative positioning for baseline calculations
119239:         *aResult = kidBaseline + kid->GetPosition().y -
119239:           kid->GetRelativeOffset().y;
 80486:         return true;
     1:       } else if (kid->GetType() == nsGkAtoms::scrollFrame) {
     1:         // Use the bottom of the scroll frame.
     1:         // XXX CSS2.1 really doesn't say what to do here.
119239:         *aResult = kid->GetRect().YMost() - kid->GetRelativeOffset().y;
 80486:         return true;
     1:       }
     1:     } else {
     1:       // XXX Is this the right test?  We have some bogus empty lines
     1:       // floating around, but IsEmpty is perhaps too weak.
     1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
     1:         *aResult = line->mBounds.y + line->GetAscent();
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
 14460: static nscoord
 14460: CalculateBlockContentBottom(nsBlockFrame* aFrame)
 14460: {
 14460:   NS_PRECONDITION(aFrame, "null ptr");
 14460: 
 14460:   nscoord contentBottom = 0;
 14460: 
 14460:   for (nsBlockFrame::line_iterator line = aFrame->begin_lines(),
 14460:                                    line_end = aFrame->end_lines();
 14460:        line != line_end; ++line) {
 14460:     if (line->IsBlock()) {
 14460:       nsIFrame* child = line->mFirstChild;
 14460:       nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
 31760:       contentBottom = NS_MAX(contentBottom,
 14460:                         nsLayoutUtils::CalculateContentBottom(child) + offset);
 14460:     }
 14460:     else {
 31760:       contentBottom = NS_MAX(contentBottom, line->mBounds.YMost());
 14460:     }
 14460:   }
 14460:   return contentBottom;
 14460: }
 14460: 
 14460: /* static */ nscoord
 14460: nsLayoutUtils::CalculateContentBottom(nsIFrame* aFrame)
 14460: {
 14460:   NS_PRECONDITION(aFrame, "null ptr");
 14460: 
 14460:   nscoord contentBottom = aFrame->GetRect().height;
 14460: 
 55040:   // We want scrollable overflow rather than visual because this
 55040:   // calculation is intended to affect layout.
 55040:   if (aFrame->GetScrollableOverflowRect().height > contentBottom) {
 77153:     nsIFrame::ChildListIDs skip(nsIFrame::kOverflowList |
 77153:                                 nsIFrame::kExcessOverflowContainersList |
 77153:                                 nsIFrame::kOverflowOutOfFlowList);
 14460:     nsBlockFrame* blockFrame = GetAsBlock(aFrame);
 77153:     if (blockFrame) {
 77153:       contentBottom =
 77153:         NS_MAX(contentBottom, CalculateBlockContentBottom(blockFrame));
 77153:       skip |= nsIFrame::kPrincipalList;
 77153:     }
 77153:     nsIFrame::ChildListIterator lists(aFrame);
 77153:     for (; !lists.IsDone(); lists.Next()) {
 77153:       if (!skip.Contains(lists.CurrentID())) {
 77153:         nsFrameList::Enumerator childFrames(lists.CurrentList()); 
 77153:         for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:           nsIFrame* child = childFrames.get();
 14460:           nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
 31760:           contentBottom = NS_MAX(contentBottom,
 14460:                                  CalculateContentBottom(child) + offset);
 14460:         }
 14460:       }
 77153:     }
 77153:   }
 14460:   return contentBottom;
 14460: }
 14460: 
     1: /* static */ nsIFrame*
     1: nsLayoutUtils::GetClosestLayer(nsIFrame* aFrame)
     1: {
     1:   nsIFrame* layer;
     1:   for (layer = aFrame; layer; layer = layer->GetParent()) {
107225:     if (layer->IsPositioned() ||
     1:         (layer->GetParent() &&
     1:           layer->GetParent()->GetType() == nsGkAtoms::scrollFrame))
     1:       break;
     1:   }
     1:   if (layer)
     1:     return layer;
   238:   return aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
     1: }
     1: 
 55321: GraphicsFilter
 27185: nsLayoutUtils::GetGraphicsFilterForFrame(nsIFrame* aForFrame)
 26926: {
 70831:   GraphicsFilter defaultFilter = gfxPattern::FILTER_GOOD;
 27185:   nsIFrame *frame = nsCSSRendering::IsCanvasFrame(aForFrame) ?
 35300:     nsCSSRendering::FindBackgroundStyleFrame(aForFrame) : aForFrame;
 27185: 
 27185:   switch (frame->GetStyleSVG()->mImageRendering) {
 26926:   case NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED:
 26926:     return gfxPattern::FILTER_FAST;
 26926:   case NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY:
 26926:     return gfxPattern::FILTER_BEST;
 26926:   case NS_STYLE_IMAGE_RENDERING_CRISPEDGES:
 26926:     return gfxPattern::FILTER_NEAREST;
 26926:   default:
 43454:     return defaultFilter;
 26926:   }
 26926: }
 26926: 
 21752: /**
 21752:  * Given an image being drawn into an appunit coordinate system, and
 21752:  * a point in that coordinate system, map the point back into image
 21752:  * pixel space.
 21752:  * @param aSize the size of the image, in pixels
 21752:  * @param aDest the rectangle that the image is being mapped into
 21752:  * @param aPt a point in the same coordinate system as the rectangle
 21752:  */
 21323: static gfxPoint
 22196: MapToFloatImagePixels(const gfxSize& aSize,
 22196:                       const gfxRect& aDest, const gfxPoint& aPt)
 21323: {
 68632:   return gfxPoint(((aPt.x - aDest.X())*aSize.width)/aDest.Width(),
 68632:                   ((aPt.y - aDest.Y())*aSize.height)/aDest.Height());
 21323: }
 21323: 
 21752: /**
 21752:  * Given an image being drawn into an pixel-based coordinate system, and
 21752:  * a point in image space, map the point into the pixel-based coordinate
 21752:  * system.
 21752:  * @param aSize the size of the image, in pixels
 21752:  * @param aDest the rectangle that the image is being mapped into
 21752:  * @param aPt a point in image space
 21752:  */
 21752: static gfxPoint
 22196: MapToFloatUserPixels(const gfxSize& aSize,
 21752:                      const gfxRect& aDest, const gfxPoint& aPt)
 21752: {
 68632:   return gfxPoint(aPt.x*aDest.Width()/aSize.width + aDest.X(),
 68632:                   aPt.y*aDest.Height()/aSize.height + aDest.Y());
 21752: }
 21752: 
 52135: /* static */ gfxRect
108991: nsLayoutUtils::RectToGfxRect(const nsRect& aRect, int32_t aAppUnitsPerDevPixel)
 46989: {
 46989:   return gfxRect(gfxFloat(aRect.x) / aAppUnitsPerDevPixel,
 46989:                  gfxFloat(aRect.y) / aAppUnitsPerDevPixel,
 46989:                  gfxFloat(aRect.width) / aAppUnitsPerDevPixel,
 46989:                  gfxFloat(aRect.height) / aAppUnitsPerDevPixel);
 46989: }
 46989: 
 46989: struct SnappedImageDrawingParameters {
 46989:   // A transform from either device space or user space (depending on mResetCTM)
 46989:   // to image space
 46989:   gfxMatrix mUserSpaceToImageSpace;
 46989:   // A device-space, pixel-aligned rectangle to fill
 46989:   gfxRect mFillRect;
 46989:   // A pixel rectangle in tiled image space outside of which gfx should not
 46989:   // sample (using EXTEND_PAD as necessary)
 46989:   nsIntRect mSubimage;
 46989:   // Whether there's anything to draw at all
 79445:   bool mShouldDraw;
 80486:   // true iff the CTM of the rendering context needs to be reset to the
 46989:   // identity matrix before drawing
 79445:   bool mResetCTM;
 46989: 
 46989:   SnappedImageDrawingParameters()
 80486:    : mShouldDraw(false)
 80486:    , mResetCTM(false)
 46989:   {}
 46989: 
 46989:   SnappedImageDrawingParameters(const gfxMatrix& aUserSpaceToImageSpace,
 46989:                                 const gfxRect&   aFillRect,
 46989:                                 const nsIntRect& aSubimage,
 79445:                                 bool             aResetCTM)
 46989:    : mUserSpaceToImageSpace(aUserSpaceToImageSpace)
 46989:    , mFillRect(aFillRect)
 46989:    , mSubimage(aSubimage)
 80486:    , mShouldDraw(true)
 46989:    , mResetCTM(aResetCTM)
 46989:   {}
 46989: };
 46989: 
 46989: /**
 46989:  * Given a set of input parameters, compute certain output parameters
 46989:  * for drawing an image with the image snapping algorithm.
 46989:  * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
 46989:  *
 46989:  *  @see nsLayoutUtils::DrawImage() for the descriptions of input parameters
 46989:  */
 46989: static SnappedImageDrawingParameters
 46989: ComputeSnappedImageDrawingParameters(gfxContext*     aCtx,
108991:                                      int32_t         aAppUnitsPerDevPixel,
 46989:                                      const nsRect    aDest,
 46989:                                      const nsRect    aFill,
 46989:                                      const nsPoint   aAnchor,
 46989:                                      const nsRect    aDirty,
 46989:                                      const nsIntSize aImageSize)
 46989: 
 46989: {
119733:   if (aDest.IsEmpty() || aFill.IsEmpty() || !aImageSize.width || !aImageSize.height)
 46989:     return SnappedImageDrawingParameters();
 46989: 
 52135:   gfxRect devPixelDest =
 52135:     nsLayoutUtils::RectToGfxRect(aDest, aAppUnitsPerDevPixel);
 52135:   gfxRect devPixelFill =
 52135:     nsLayoutUtils::RectToGfxRect(aFill, aAppUnitsPerDevPixel);
 52135:   gfxRect devPixelDirty =
 52135:     nsLayoutUtils::RectToGfxRect(aDirty, aAppUnitsPerDevPixel);
 46989: 
 79445:   bool ignoreScale = false;
 46989: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
 80486:   ignoreScale = true;
 46989: #endif
 46989:   gfxRect fill = devPixelFill;
 79445:   bool didSnap = aCtx->UserToDevicePixelSnapped(fill, ignoreScale);
114074:   gfxMatrix currentMatrix = aCtx->CurrentMatrix();
114074:   if (didSnap && currentMatrix.HasNonAxisAlignedTransform()) {
114074:     // currentMatrix must have some rotation by a multiple of 90 degrees.
114074:     didSnap = false;
114074:     fill = devPixelFill;
114074:   }
 46989: 
 46989:   gfxSize imageSize(aImageSize.width, aImageSize.height);
 46989: 
 46989:   // Compute the set of pixels that would be sampled by an ideal rendering
 46989:   gfxPoint subimageTopLeft =
 46989:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.TopLeft());
 46989:   gfxPoint subimageBottomRight =
 46989:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.BottomRight());
 46989:   nsIntRect intSubimage;
 46989:   intSubimage.MoveTo(NSToIntFloor(subimageTopLeft.x),
 46989:                      NSToIntFloor(subimageTopLeft.y));
 46989:   intSubimage.SizeTo(NSToIntCeil(subimageBottomRight.x) - intSubimage.x,
 46989:                      NSToIntCeil(subimageBottomRight.y) - intSubimage.y);
 46989: 
 46989:   // Compute the anchor point and compute final fill rect.
 46989:   // This code assumes that pixel-based devices have one pixel per
 46989:   // device unit!
 46989:   gfxPoint anchorPoint(gfxFloat(aAnchor.x)/aAppUnitsPerDevPixel,
 46989:                        gfxFloat(aAnchor.y)/aAppUnitsPerDevPixel);
 46989:   gfxPoint imageSpaceAnchorPoint =
 46989:     MapToFloatImagePixels(imageSize, devPixelDest, anchorPoint);
 46989: 
 46989:   if (didSnap) {
 46989:     imageSpaceAnchorPoint.Round();
 46989:     anchorPoint = imageSpaceAnchorPoint;
 46989:     anchorPoint = MapToFloatUserPixels(imageSize, devPixelDest, anchorPoint);
 46989:     anchorPoint = currentMatrix.Transform(anchorPoint);
 46989:     anchorPoint.Round();
 46989: 
 46989:     // This form of Transform is safe to call since non-axis-aligned
 46989:     // transforms wouldn't be snapped.
 46989:     devPixelDirty = currentMatrix.Transform(devPixelDirty);
 46989:   }
 46989: 
 46989:   gfxFloat scaleX = imageSize.width*aAppUnitsPerDevPixel/aDest.width;
 46989:   gfxFloat scaleY = imageSize.height*aAppUnitsPerDevPixel/aDest.height;
 46989:   if (didSnap) {
 46989:     // We'll reset aCTX to the identity matrix before drawing, so we need to
 46989:     // adjust our scales to match.
 46989:     scaleX /= currentMatrix.xx;
 46989:     scaleY /= currentMatrix.yy;
 46989:   }
 46989:   gfxFloat translateX = imageSpaceAnchorPoint.x - anchorPoint.x*scaleX;
 46989:   gfxFloat translateY = imageSpaceAnchorPoint.y - anchorPoint.y*scaleY;
 46989:   gfxMatrix transform(scaleX, 0, 0, scaleY, translateX, translateY);
 46989: 
 46989:   gfxRect finalFillRect = fill;
 46989:   // If the user-space-to-image-space transform is not a straight
 46989:   // translation by integers, then filtering will occur, and
 46989:   // restricting the fill rect to the dirty rect would change the values
 46989:   // computed for edge pixels, which we can't allow.
 46989:   // Also, if didSnap is false then rounding out 'devPixelDirty' might not
 46989:   // produce pixel-aligned coordinates, which would also break the values
 46989:   // computed for edge pixels.
 46989:   if (didSnap && !transform.HasNonIntegerTranslation()) {
 46989:     devPixelDirty.RoundOut();
 46989:     finalFillRect = fill.Intersect(devPixelDirty);
 46989:   }
 46989:   if (finalFillRect.IsEmpty())
 46989:     return SnappedImageDrawingParameters();
 46989: 
 46989:   return SnappedImageDrawingParameters(transform, finalFillRect, intSubimage,
 46989:                                        didSnap);
 46989: }
 46989: 
 46989: 
 24452: static nsresult
 68481: DrawImageInternal(nsRenderingContext* aRenderingContext,
 30479:                   imgIContainer*       aImage,
 55321:                   GraphicsFilter       aGraphicsFilter,
 21323:                   const nsRect&        aDest,
 21323:                   const nsRect&        aFill,
 21323:                   const nsPoint&       aAnchor,
 24452:                   const nsRect&        aDirty,
 32424:                   const nsIntSize&     aImageSize,
108991:                   uint32_t             aImageFlags)
     1: {
 95637:   if (aDest.Contains(aFill)) {
 95637:     aImageFlags |= imgIContainer::FLAG_CLAMP;
 95637:   }
108991:   int32_t appUnitsPerDevPixel = aRenderingContext->AppUnitsPerDevPixel();
 21323:   gfxContext* ctx = aRenderingContext->ThebesContext();
 21323: 
 46989:   SnappedImageDrawingParameters drawingParams =
 46989:     ComputeSnappedImageDrawingParameters(ctx, appUnitsPerDevPixel, aDest, aFill,
 46989:                                          aAnchor, aDirty, aImageSize);
 46989: 
 46989:   if (!drawingParams.mShouldDraw)
 46989:     return NS_OK;
 46989: 
 22177:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
 46989:   if (drawingParams.mResetCTM) {
 21323:     ctx->IdentityMatrix();
     1:   }
 21323: 
 46989:   aImage->Draw(ctx, aGraphicsFilter, drawingParams.mUserSpaceToImageSpace,
 52215:                drawingParams.mFillRect, drawingParams.mSubimage, aImageSize,
 52215:                aImageFlags);
 24452:   return NS_OK;
 24452: }
 24452: 
 50420: /* static */ void
 68481: nsLayoutUtils::DrawPixelSnapped(nsRenderingContext* aRenderingContext,
 50420:                                 gfxDrawable*         aDrawable,
 55321:                                 GraphicsFilter       aFilter,
 50420:                                 const nsRect&        aDest,
 50420:                                 const nsRect&        aFill,
 50420:                                 const nsPoint&       aAnchor,
 50420:                                 const nsRect&        aDirty)
 50420: {
108991:   int32_t appUnitsPerDevPixel = aRenderingContext->AppUnitsPerDevPixel();
 50420:   gfxContext* ctx = aRenderingContext->ThebesContext();
 50420:   gfxIntSize drawableSize = aDrawable->Size();
 50420:   nsIntSize imageSize(drawableSize.width, drawableSize.height);
 50420: 
 50420:   SnappedImageDrawingParameters drawingParams =
 50420:     ComputeSnappedImageDrawingParameters(ctx, appUnitsPerDevPixel, aDest, aFill,
 50420:                                          aAnchor, aDirty, imageSize);
 50420: 
 50420:   if (!drawingParams.mShouldDraw)
 50420:     return;
 50420: 
 50420:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
 50420:   if (drawingParams.mResetCTM) {
 50420:     ctx->IdentityMatrix();
 50420:   }
 50420: 
 50420:   gfxRect sourceRect =
 50420:     drawingParams.mUserSpaceToImageSpace.Transform(drawingParams.mFillRect);
 50420:   gfxRect imageRect(0, 0, imageSize.width, imageSize.height);
 50420:   gfxRect subimage(drawingParams.mSubimage.x, drawingParams.mSubimage.y,
 50420:                    drawingParams.mSubimage.width, drawingParams.mSubimage.height);
 50420: 
 50420:   NS_ASSERTION(!sourceRect.Intersect(subimage).IsEmpty(),
 50420:                "We must be allowed to sample *some* source pixels!");
 50420: 
 50420:   gfxUtils::DrawPixelSnapped(ctx, aDrawable,
 50420:                              drawingParams.mUserSpaceToImageSpace, subimage,
 50420:                              sourceRect, imageRect, drawingParams.mFillRect,
 50420:                              gfxASurface::ImageFormatARGB32, aFilter);
 50420: }
 50420: 
 30759: /* static */ nsresult
 68481: nsLayoutUtils::DrawSingleUnscaledImage(nsRenderingContext* aRenderingContext,
 30479:                                        imgIContainer*       aImage,
 55322:                                        GraphicsFilter       aGraphicsFilter,
 24452:                                        const nsPoint&       aDest,
 55322:                                        const nsRect*        aDirty,
108991:                                        uint32_t             aImageFlags,
 30759:                                        const nsRect*        aSourceArea)
 24452: {
 30759:   nsIntSize imageSize;
 30759:   aImage->GetWidth(&imageSize.width);
 30759:   aImage->GetHeight(&imageSize.height);
 30759:   NS_ENSURE_TRUE(imageSize.width > 0 && imageSize.height > 0, NS_ERROR_FAILURE);
 24452: 
 68668:   nscoord appUnitsPerCSSPixel = nsDeviceContext::AppUnitsPerCSSPixel();
 30759:   nsSize size(imageSize.width*appUnitsPerCSSPixel,
 30759:               imageSize.height*appUnitsPerCSSPixel);
 24452: 
 24452:   nsRect source;
 24452:   if (aSourceArea) {
 24452:     source = *aSourceArea;
 24452:   } else {
 24452:     source.SizeTo(size);
 24452:   }
 24452: 
 24452:   nsRect dest(aDest - source.TopLeft(), size);
 24452:   nsRect fill(aDest, source.Size());
 24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
 24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
 24452:   // translation but we don't want to actually tile the image.
 24452:   fill.IntersectRect(fill, dest);
 55322:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
 55322:                            dest, fill, aDest, aDirty ? *aDirty : dest,
 55322:                            imageSize, aImageFlags);
 30759: }
 30759: 
 30759: /* static */ nsresult
 68481: nsLayoutUtils::DrawSingleImage(nsRenderingContext* aRenderingContext,
 30479:                                imgIContainer*       aImage,
 55321:                                GraphicsFilter       aGraphicsFilter,
 24452:                                const nsRect&        aDest,
 24452:                                const nsRect&        aDirty,
108991:                                uint32_t             aImageFlags,
 30759:                                const nsRect*        aSourceArea)
 24452: {
 30759:   nsIntSize imageSize;
 52215:   if (aImage->GetType() == imgIContainer::TYPE_VECTOR) {
 52215:     imageSize.width  = nsPresContext::AppUnitsToIntCSSPixels(aDest.width);
 52215:     imageSize.height = nsPresContext::AppUnitsToIntCSSPixels(aDest.height);
 52215:   } else {
 30759:     aImage->GetWidth(&imageSize.width);
 30759:     aImage->GetHeight(&imageSize.height);
 52215:   }
 30759:   NS_ENSURE_TRUE(imageSize.width > 0 && imageSize.height > 0, NS_ERROR_FAILURE);
 24452: 
 24452:   nsRect source;
 24452:   if (aSourceArea) {
 24452:     source = *aSourceArea;
 24452:   } else {
 68668:     nscoord appUnitsPerCSSPixel = nsDeviceContext::AppUnitsPerCSSPixel();
 30759:     source.SizeTo(imageSize.width*appUnitsPerCSSPixel,
 30759:                   imageSize.height*appUnitsPerCSSPixel);
 30759:   }
 30759: 
 30759:   nsRect dest = nsLayoutUtils::GetWholeImageDestination(imageSize, source,
 24452:                                                         aDest);
 24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
 24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
 24452:   // transform but we don't want to actually tile the image.
 24452:   nsRect fill;
 24452:   fill.IntersectRect(aDest, dest);
 26926:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter, dest, fill,
 32424:                            fill.TopLeft(), aDirty, imageSize, aImageFlags);
 30759: }
 24452: 
 52215: /* static */ void
 52215: nsLayoutUtils::ComputeSizeForDrawing(imgIContainer *aImage,
 52215:                                      nsIntSize&     aImageSize, /*outparam*/
 75061:                                      nsSize&        aIntrinsicRatio, /*outparam*/
 75061:                                      bool&          aGotWidth,  /*outparam*/
 75061:                                      bool&          aGotHeight  /*outparam*/)
 52215: {
 52215:   aGotWidth  = NS_SUCCEEDED(aImage->GetWidth(&aImageSize.width));
 52215:   aGotHeight = NS_SUCCEEDED(aImage->GetHeight(&aImageSize.height));
 52215: 
 75061:   if (aGotWidth && aGotHeight) {
 75061:     aIntrinsicRatio = nsSize(aImageSize.width, aImageSize.height);
 52215:     return;
 52215:   }
 52215: 
 75061:   // If we failed to get width or height, we either have a vector image and
 75061:   // should return its intrinsic ratio, or we hit an error (say, because the
 75061:   // image failed to load or couldn't be decoded) and should return zero size.
 75061:   if (nsIFrame* rootFrame = aImage->GetRootLayoutFrame()) {
 75061:     aIntrinsicRatio = rootFrame->GetIntrinsicRatio();
 75061:   } else {
 75061:     aGotWidth = aGotHeight = true;
 75061:     aImageSize = nsIntSize(0, 0);
 75061:     aIntrinsicRatio = nsSize(0, 0);
 75061:   }
 75061: }
 75061: 
 75061: 
 75061: /* static */ nsresult
 75061: nsLayoutUtils::DrawBackgroundImage(nsRenderingContext* aRenderingContext,
 75061:                                    imgIContainer*      aImage,
 75061:                                    const nsIntSize&    aImageSize,
 75061:                                    GraphicsFilter      aGraphicsFilter,
 75061:                                    const nsRect&       aDest,
 75061:                                    const nsRect&       aFill,
 75061:                                    const nsPoint&      aAnchor,
 75061:                                    const nsRect&       aDirty,
108991:                                    uint32_t            aImageFlags)
 75061: {
 87692:   SAMPLE_LABEL("layout", "nsLayoutUtils::DrawBackgroundImage");
 95942: 
 95942:   if (UseBackgroundNearestFiltering()) {
 95942:     aGraphicsFilter = gfxPattern::FILTER_NEAREST;
 95942:   }
 95942: 
 75061:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
 75061:                            aDest, aFill, aAnchor, aDirty,
 75061:                            aImageSize, aImageFlags);
 75061: }
 52215: 
 24452: /* static */ nsresult
 68481: nsLayoutUtils::DrawImage(nsRenderingContext* aRenderingContext,
 24452:                          imgIContainer*       aImage,
 55321:                          GraphicsFilter       aGraphicsFilter,
 24452:                          const nsRect&        aDest,
 24452:                          const nsRect&        aFill,
 24452:                          const nsPoint&       aAnchor,
 32424:                          const nsRect&        aDirty,
108991:                          uint32_t             aImageFlags)
 24452: {
 24452:   nsIntSize imageSize;
 75061:   nsSize imageRatio;
 75061:   bool gotHeight, gotWidth;
 75061:   ComputeSizeForDrawing(aImage, imageSize, imageRatio, gotWidth, gotHeight);
 75061: 
 75061:   // XXX Dimensionless images shouldn't fall back to filled-area size -- the
 75061:   //     caller should provide the image size, a la DrawBackgroundImage.
 75061:   if (gotWidth != gotHeight) {
 75061:     if (!gotWidth) {
 75061:       if (imageRatio.height != 0) {
 75061:         imageSize.width =
 75061:           NSCoordSaturatingNonnegativeMultiply(imageSize.height,
 75061:                                                float(imageRatio.width) /
 75061:                                                float(imageRatio.height));
 75061:         gotWidth = true;
 75061:       }
 75061:     } else {
 75061:       if (imageRatio.width != 0) {
 75061:         imageSize.height =
 75061:           NSCoordSaturatingNonnegativeMultiply(imageSize.width,
 75061:                                                float(imageRatio.height) /
 75061:                                                float(imageRatio.width));
 75061:         gotHeight = true;
 75061:       }
 75061:     }
 75061:   }
 75061: 
 52215:   if (!gotWidth) {
 52215:     imageSize.width = nsPresContext::AppUnitsToIntCSSPixels(aFill.width);
 52215:   }
 52215:   if (!gotHeight) {
 52215:     imageSize.height = nsPresContext::AppUnitsToIntCSSPixels(aFill.height);
 52215:   }
 24452: 
 26926:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
 24452:                            aDest, aFill, aAnchor, aDirty,
 32424:                            imageSize, aImageFlags);
     1: }
     1: 
 21323: /* static */ nsRect
 21323: nsLayoutUtils::GetWholeImageDestination(const nsIntSize& aWholeImageSize,
 21323:                                         const nsRect& aImageSourceArea,
 21323:                                         const nsRect& aDestArea)
 21323: {
 21323:   double scaleX = double(aDestArea.width)/aImageSourceArea.width;
 21323:   double scaleY = double(aDestArea.height)/aImageSourceArea.height;
 21323:   nscoord destOffsetX = NSToCoordRound(aImageSourceArea.x*scaleX);
 21323:   nscoord destOffsetY = NSToCoordRound(aImageSourceArea.y*scaleY);
 68668:   nscoord appUnitsPerCSSPixel = nsDeviceContext::AppUnitsPerCSSPixel();
 21323:   nscoord wholeSizeX = NSToCoordRound(aWholeImageSize.width*appUnitsPerCSSPixel*scaleX);
 21323:   nscoord wholeSizeY = NSToCoordRound(aWholeImageSize.height*appUnitsPerCSSPixel*scaleY);
 21323:   return nsRect(aDestArea.TopLeft() - nsPoint(destOffsetX, destOffsetY),
 21323:                 nsSize(wholeSizeX, wholeSizeY));
     1: }
  1105: 
 79445: static bool NonZeroStyleCoord(const nsStyleCoord& aCoord)
  1345: {
 52281:   if (aCoord.IsCoordPercentCalcUnit()) {
 52281:     // Since negative results are clamped to 0, check > 0.
 52281:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, nscoord_MAX) > 0 ||
 52281:            nsRuleNode::ComputeCoordPercentCalc(aCoord, 0) > 0;
 52281:   }
 52281: 
 80486:   return true;
  1345: }
  1345: 
 79445: /* static */ bool
 20039: nsLayoutUtils::HasNonZeroCorner(const nsStyleCorners& aCorners)
  1345: {
 20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
 20039:     if (NonZeroStyleCoord(aCorners.Get(corner)))
 80486:       return true;
 80486:   }
 80486:   return false;
  1345: }
  1345: 
 28109: // aCorner is a "full corner" value, i.e. NS_CORNER_TOP_LEFT etc
115831: static bool IsCornerAdjacentToSide(uint8_t aCorner, css::Side aSide)
 28109: {
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_TOP == NS_CORNER_TOP_LEFT);
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_RIGHT == NS_CORNER_TOP_RIGHT);
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_BOTTOM == NS_CORNER_BOTTOM_RIGHT);
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_LEFT == NS_CORNER_BOTTOM_LEFT);
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_TOP == ((NS_CORNER_TOP_RIGHT - 1)&3));
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_RIGHT == ((NS_CORNER_BOTTOM_RIGHT - 1)&3));
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_BOTTOM == ((NS_CORNER_BOTTOM_LEFT - 1)&3));
 41419:   PR_STATIC_ASSERT((int)NS_SIDE_LEFT == ((NS_CORNER_TOP_LEFT - 1)&3));
 28109: 
 28109:   return aSide == aCorner || aSide == ((aCorner - 1)&3);
 28109: }
 28109: 
 79445: /* static */ bool
 28109: nsLayoutUtils::HasNonZeroCornerOnSide(const nsStyleCorners& aCorners,
115831:                                       css::Side aSide)
 28109: {
 28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT_X/2 == NS_CORNER_TOP_LEFT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT_Y/2 == NS_CORNER_TOP_LEFT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_RIGHT_X/2 == NS_CORNER_TOP_RIGHT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_RIGHT_Y/2 == NS_CORNER_TOP_RIGHT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_RIGHT_X/2 == NS_CORNER_BOTTOM_RIGHT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_RIGHT_Y/2 == NS_CORNER_BOTTOM_RIGHT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_LEFT_X/2 == NS_CORNER_BOTTOM_LEFT);
 28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_LEFT_Y/2 == NS_CORNER_BOTTOM_LEFT);
 28109: 
 28109:   NS_FOR_CSS_HALF_CORNERS(corner) {
 28109:     // corner is a "half corner" value, so dividing by two gives us a
 28109:     // "full corner" value.
 28109:     if (NonZeroStyleCoord(aCorners.Get(corner)) &&
 28109:         IsCornerAdjacentToSide(corner/2, aSide))
 80486:       return true;
 80486:   }
 80486:   return false;
 28109: }
 28109: 
 16601: /* static */ nsTransparencyMode
 31535: nsLayoutUtils::GetFrameTransparency(nsIFrame* aBackgroundFrame,
 31535:                                     nsIFrame* aCSSRootFrame) {
 31535:   if (aCSSRootFrame->GetStyleContext()->GetStyleDisplay()->mOpacity < 1.0f)
 16601:     return eTransparencyTransparent;
  1345: 
 31535:   if (HasNonZeroCorner(aCSSRootFrame->GetStyleContext()->GetStyleBorder()->mBorderRadius))
 16601:     return eTransparencyTransparent;
  1345: 
 56101:   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
 56101:     return eTransparencyGlass;
 56101: 
 56101:   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
 56101:     return eTransparencyBorderlessGlass;
 56101: 
 43487:   nsITheme::Transparency transparency;
 31535:   if (aCSSRootFrame->IsThemed(&transparency))
 43487:     return transparency == nsITheme::eTransparent
 43487:          ? eTransparencyTransparent
 43487:          : eTransparencyOpaque;
  1345: 
 24645:   // We need an uninitialized window to be treated as opaque because
 24645:   // doing otherwise breaks window display effects on some platforms,
 24645:   // specifically Vista. (bug 450322)
 31535:   if (aBackgroundFrame->GetType() == nsGkAtoms::viewportFrame &&
 77154:       !aBackgroundFrame->GetFirstPrincipalChild()) {
 24645:     return eTransparencyOpaque;
 24645:   }
 24645: 
 40177:   nsStyleContext* bgSC;
 31535:   if (!nsCSSRendering::FindBackground(aBackgroundFrame->PresContext(),
 40177:                                       aBackgroundFrame, &bgSC)) {
 16601:     return eTransparencyTransparent;
 31535:   }
 40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
 25276:   if (NS_GET_A(bg->mBackgroundColor) < 255 ||
 25276:       // bottom layer's clip is used for the color
 25276:       bg->BottomLayer().mClip != NS_STYLE_BG_CLIP_BORDER)
 16601:     return eTransparencyTransparent;
 16601:   return eTransparencyOpaque;
  1345: }
  4032: 
 87435: static bool IsPopupFrame(nsIFrame* aFrame)
 87435: {
 87435:   // aFrame is a popup it's the list control frame dropdown for a combobox.
 87435:   nsIAtom* frameType = aFrame->GetType();
 87435:   if (frameType == nsGkAtoms::listControlFrame) {
 87435:     nsListControlFrame* lcf = static_cast<nsListControlFrame*>(aFrame);
 87435:     return lcf->IsInDropDownMode();
 87435:   }
 87435: 
 87435:   // ... or if it's a XUL menupopup frame.
 87435:   return frameType == nsGkAtoms::menuPopupFrame;
 87435: }
 87435: 
 79445: /* static */ bool
 37081: nsLayoutUtils::IsPopup(nsIFrame* aFrame)
 37081: {
 87435:   // Optimization: the frame can't possibly be a popup if it has no view.
 87435:   if (!aFrame->HasView()) {
 87435:     NS_ASSERTION(!IsPopupFrame(aFrame), "popup frame must have a view");
 87435:     return false;
 87435:   }
 87435:   return IsPopupFrame(aFrame);
 37081: }
 37081: 
 37081: /* static */ nsIFrame*
 37081: nsLayoutUtils::GetDisplayRootFrame(nsIFrame* aFrame)
 37081: {
115304:   // We could use GetRootPresContext() here if the
115304:   // NS_FRAME_IN_POPUP frame bit is set.
 37081:   nsIFrame* f = aFrame;
 37081:   for (;;) {
115311:     if (!f->HasAnyStateBits(NS_FRAME_IN_POPUP)) {
115311:       f = f->PresContext()->FrameManager()->GetRootFrame();
115311:     } else if (IsPopup(f)) {
 37081:       return f;
115311:     }
 37081:     nsIFrame* parent = GetCrossDocParentFrame(f);
 37081:     if (!parent)
 37081:       return f;
 37081:     f = parent;
 37081:   }
 37081: }
 37081: 
108991: /* static */ uint32_t
  4032: nsLayoutUtils::GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
107217:                                        const nsStyleFont* aStyleFont,
107217:                                        nscoord aLetterSpacing)
  4032: {
108991:   uint32_t result = 0;
107217:   if (aLetterSpacing != 0) {
  4032:     result |= gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES;
  4032:   }
  4032:   switch (aStyleContext->GetStyleSVG()->mTextRendering) {
  4032:   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
  4032:     result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
  4032:     break;
  4032:   case NS_STYLE_TEXT_RENDERING_AUTO:
  4032:     if (aStyleFont->mFont.size <
  4032:         aStyleContext->PresContext()->GetAutoQualityMinFontSize()) {
  4032:       result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
  4032:     }
  4032:     break;
  4032:   default:
  4032:     break;
  4032:   }
  4032:   return result;
  4032: }
 11384: 
 11384: /* static */ void
 11384: nsLayoutUtils::GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
 11384:                                        nsRect* aHStrip, nsRect* aVStrip) {
 11384:   NS_ASSERTION(aR1.TopLeft() == aR2.TopLeft(),
 11384:                "expected rects at the same position");
 32531:   nsRect unionRect(aR1.x, aR1.y, NS_MAX(aR1.width, aR2.width),
 32531:                    NS_MAX(aR1.height, aR2.height));
 32531:   nscoord VStripStart = NS_MIN(aR1.width, aR2.width);
 32531:   nscoord HStripStart = NS_MIN(aR1.height, aR2.height);
 11384:   *aVStrip = unionRect;
 11384:   aVStrip->x += VStripStart;
 11384:   aVStrip->width -= VStripStart;
 11384:   *aHStrip = unionRect;
 11384:   aHStrip->y += HStripStart;
 11384:   aHStrip->height -= HStripStart;
 11384: }
 11384: 
 68668: nsDeviceContext*
 93485: nsLayoutUtils::GetDeviceContextForScreenInfo(nsPIDOMWindow* aWindow)
 16228: {
 95491:   if (!aWindow) {
106838:     return nullptr;
 95491:   }
 95491: 
 93485:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
 16228:   while (docShell) {
 16228:     // Now make sure our size is up to date.  That will mean that the device
 16228:     // context does the right thing on multi-monitor systems when we return it to
 16228:     // the caller.  It will also make sure that our prescontext has been created,
 16228:     // if we're supposed to have one.
 16228:     nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(docShell);
 16228:     if (!win) {
 16228:       // No reason to go on
106838:       return nullptr;
 16228:     }
 16228: 
 16228:     win->EnsureSizeUpToDate();
 16228: 
 32132:     nsRefPtr<nsPresContext> presContext;
 32132:     docShell->GetPresContext(getter_AddRefs(presContext));
 32132:     if (presContext) {
 68668:       nsDeviceContext* context = presContext->DeviceContext();
 32132:       if (context) {
 32132:         return context;
 32132:       }
 16228:     }
 16228: 
 16228:     nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryInterface(docShell);
 16228:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
 16228:     curItem->GetParent(getter_AddRefs(parentItem));
 16228:     docShell = do_QueryInterface(parentItem);
 16228:   }
 16228: 
106838:   return nullptr;
 16228: }
 16228: 
 79445: /* static */ bool
 21903: nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
 21903: {
 21903:   NS_PRECONDITION(aFrame->GetParent(),
 21903:                   "IsReallyFixedPos called on frame not in tree");
 21903:   NS_PRECONDITION(aFrame->GetStyleDisplay()->mPosition ==
 21903:                     NS_STYLE_POSITION_FIXED,
 21903:                   "IsReallyFixedPos called on non-'position:fixed' frame");
 21903: 
 23170:   nsIAtom *parentType = aFrame->GetParent()->GetType();
 23170:   return parentType == nsGkAtoms::viewportFrame ||
 23170:          parentType == nsGkAtoms::pageContentFrame;
 21903: }
 21903: 
 29572: nsLayoutUtils::SurfaceFromElementResult
100047: nsLayoutUtils::SurfaceFromElement(nsIImageLoadingContent* aElement,
108991:                                   uint32_t aSurfaceFlags)
 29572: {
 29572:   SurfaceFromElementResult result;
 29572:   nsresult rv;
 29572: 
 79445:   bool forceCopy = (aSurfaceFlags & SFE_WANT_NEW_SURFACE) != 0;
 79445:   bool wantImageSurface = (aSurfaceFlags & SFE_WANT_IMAGE_SURFACE) != 0;
 93959:   bool premultAlpha = (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA) == 0;
 93959: 
 93959:   if (!premultAlpha) {
 80486:     forceCopy = true;
 80486:     wantImageSurface = true;
 60418:   }
 60418: 
 61720:   // Push a null JSContext on the stack so that code that runs within
 61720:   // the below code doesn't think it's being called by JS. See bug
 61720:   // 604262.
 61720:   nsCxPusher pusher;
 61720:   pusher.PushNull();
 61720: 
 29572:   nsCOMPtr<imgIRequest> imgRequest;
100047:   rv = aElement->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
 29572:                             getter_AddRefs(imgRequest));
 29572:   if (NS_FAILED(rv) || !imgRequest)
 29572:     return result;
 29572: 
108991:   uint32_t status;
 29572:   imgRequest->GetImageStatus(&status);
 43798:   if ((status & imgIRequest::STATUS_LOAD_COMPLETE) == 0) {
 43798:     // Spec says to use GetComplete, but that only works on
 43798:     // nsIDOMHTMLImageElement, and we support all sorts of other stuff
 43798:     // here.  Do this for now pending spec clarification.
 43798:     result.mIsStillLoading = (status & imgIRequest::STATUS_ERROR) == 0;
 29572:     return result;
 43798:   }
 29572: 
 29572:   nsCOMPtr<nsIPrincipal> principal;
 29572:   rv = imgRequest->GetImagePrincipal(getter_AddRefs(principal));
119130:   if (NS_FAILED(rv))
 29572:     return result;
 29572: 
 30479:   nsCOMPtr<imgIContainer> imgContainer;
 29572:   rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
119130:   if (NS_FAILED(rv))
 29572:     return result;
 29572: 
108991:   uint32_t whichFrame = (aSurfaceFlags & SFE_WANT_FIRST_FRAME)
108991:                         ? (uint32_t) imgIContainer::FRAME_FIRST
108991:                         : (uint32_t) imgIContainer::FRAME_CURRENT;
108991:   uint32_t frameFlags = imgIContainer::FLAG_SYNC_DECODE;
 60418:   if (aSurfaceFlags & SFE_NO_COLORSPACE_CONVERSION)
 60418:     frameFlags |= imgIContainer::FLAG_DECODE_NO_COLORSPACE_CONVERSION;
 60418:   if (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA)
 60418:     frameFlags |= imgIContainer::FLAG_DECODE_NO_PREMULTIPLY_ALPHA;
 30479:   nsRefPtr<gfxASurface> framesurf;
 32424:   rv = imgContainer->GetFrame(whichFrame,
 60418:                               frameFlags,
 32424:                               getter_AddRefs(framesurf));
 29572:   if (NS_FAILED(rv))
 29572:     return result;
 29572: 
108991:   int32_t imgWidth, imgHeight;
 30479:   rv = imgContainer->GetWidth(&imgWidth);
106850:   nsresult rv2 = imgContainer->GetHeight(&imgHeight);
106850:   if (NS_FAILED(rv) || NS_FAILED(rv2))
 29572:     return result;
 29572: 
 30479:   if (wantImageSurface && framesurf->GetType() != gfxASurface::SurfaceTypeImage) {
 80486:     forceCopy = true;
 29572:   }
 29572: 
 30479:   nsRefPtr<gfxASurface> gfxsurf = framesurf;
 30479:   if (forceCopy) {
 29572:     if (wantImageSurface) {
 29572:       gfxsurf = new gfxImageSurface (gfxIntSize(imgWidth, imgHeight), gfxASurface::ImageFormatARGB32);
 29572:     } else {
 29572:       gfxsurf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(imgWidth, imgHeight),
 54253:                                                                    gfxASurface::CONTENT_COLOR_ALPHA);
 29572:     }
 29572: 
 29572:     nsRefPtr<gfxContext> ctx = new gfxContext(gfxsurf);
 29572: 
 29572:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 30479:     ctx->SetSource(framesurf);
 29572:     ctx->Paint();
 29572:   }
 29572: 
108991:   int32_t corsmode;
 78159:   if (NS_SUCCEEDED(imgRequest->GetCORSMode(&corsmode))) {
 78159:     result.mCORSUsed = (corsmode != imgIRequest::CORS_NONE);
 78159:   }
 78159: 
 29572:   result.mSurface = gfxsurf;
 29572:   result.mSize = gfxIntSize(imgWidth, imgHeight);
 63836:   result.mPrincipal = principal.forget();
 84921:   // no images, including SVG images, can load content from another domain.
 84921:   result.mIsWriteOnly = false;
 63836:   result.mImageRequest = imgRequest.forget();
 29572: 
 29572:   return result;
 29572: }
 29572: 
100047: nsLayoutUtils::SurfaceFromElementResult
100047: nsLayoutUtils::SurfaceFromElement(nsHTMLImageElement *aElement,
108991:                                   uint32_t aSurfaceFlags)
100047: {
100047:   return SurfaceFromElement(static_cast<nsIImageLoadingContent*>(aElement),
100047:                             aSurfaceFlags);
100047: }
100047: 
100047: nsLayoutUtils::SurfaceFromElementResult
100047: nsLayoutUtils::SurfaceFromElement(nsHTMLCanvasElement* aElement,
108991:                                   uint32_t aSurfaceFlags)
100047: {
100047:   SurfaceFromElementResult result;
100047:   nsresult rv;
100047: 
100047:   bool forceCopy = (aSurfaceFlags & SFE_WANT_NEW_SURFACE) != 0;
100047:   bool wantImageSurface = (aSurfaceFlags & SFE_WANT_IMAGE_SURFACE) != 0;
100047:   bool premultAlpha = (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA) == 0;
100047: 
100047:   if (!premultAlpha) {
100047:     forceCopy = true;
100047:     wantImageSurface = true;
100047:   }
100047: 
100047:   gfxIntSize size = aElement->GetSize();
100047: 
100047:   nsRefPtr<gfxASurface> surf;
100047: 
100047:   if (!forceCopy && aElement->CountContexts() == 1) {
100047:     nsICanvasRenderingContextInternal *srcCanvas = aElement->GetContextAtIndex(0);
100047:     rv = srcCanvas->GetThebesSurface(getter_AddRefs(surf));
100047: 
100047:     if (NS_FAILED(rv))
106838:       surf = nullptr;
100047:   }
100047: 
100047:   if (surf && wantImageSurface && surf->GetType() != gfxASurface::SurfaceTypeImage)
106838:     surf = nullptr;
100047: 
100047:   if (!surf) {
100047:     if (wantImageSurface) {
100047:       surf = new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
100047:     } else {
100047:       surf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(size, gfxASurface::CONTENT_COLOR_ALPHA);
100047:     }
100047: 
100047:     nsRefPtr<gfxContext> ctx = new gfxContext(surf);
100047:     // XXX shouldn't use the external interface, but maybe we can layerify this
108991:     uint32_t flags = premultAlpha ? nsHTMLCanvasElement::RenderFlagPremultAlpha : 0;
100047:     rv = aElement->RenderContextsExternal(ctx, gfxPattern::FILTER_NEAREST, flags);
100047:     if (NS_FAILED(rv))
100047:       return result;
100047:   }
100047: 
100047:   // Ensure that any future changes to the canvas trigger proper invalidation,
100047:   // in case this is being used by -moz-element()
100047:   aElement->MarkContextClean();
100047: 
100047:   result.mSurface = surf;
100047:   result.mSize = size;
100047:   result.mPrincipal = aElement->NodePrincipal();
100047:   result.mIsWriteOnly = aElement->IsWriteOnly();
100047: 
100047:   return result;
100047: }
100047: 
100047: nsLayoutUtils::SurfaceFromElementResult
100047: nsLayoutUtils::SurfaceFromElement(nsHTMLVideoElement* aElement,
108991:                                   uint32_t aSurfaceFlags)
100047: {
100047:   SurfaceFromElementResult result;
100047: 
100047:   bool wantImageSurface = (aSurfaceFlags & SFE_WANT_IMAGE_SURFACE) != 0;
100047:   bool premultAlpha = (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA) == 0;
100047: 
100047:   if (!premultAlpha) {
100047:     wantImageSurface = true;
100047:   }
100047: 
108991:   uint16_t readyState;
100047:   if (NS_SUCCEEDED(aElement->GetReadyState(&readyState)) &&
100047:       (readyState == nsIDOMHTMLMediaElement::HAVE_NOTHING ||
100047:        readyState == nsIDOMHTMLMediaElement::HAVE_METADATA)) {
100047:     result.mIsStillLoading = true;
100047:     return result;
100047:   }
100047: 
100047:   // If it doesn't have a principal, just bail
100047:   nsCOMPtr<nsIPrincipal> principal = aElement->GetCurrentPrincipal();
100047:   if (!principal)
100047:     return result;
100047: 
100047:   ImageContainer *container = aElement->GetImageContainer();
100047:   if (!container)
100047:     return result;
100047: 
100047:   gfxIntSize size;
100047:   nsRefPtr<gfxASurface> surf = container->GetCurrentAsSurface(&size);
100047:   if (!surf)
100047:     return result;
100047: 
100047:   if (wantImageSurface && surf->GetType() != gfxASurface::SurfaceTypeImage) {
100047:     nsRefPtr<gfxImageSurface> imgSurf =
100047:       new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
100047: 
100047:     nsRefPtr<gfxContext> ctx = new gfxContext(imgSurf);
100047:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
100047:     ctx->DrawSurface(surf, size);
100047:     surf = imgSurf;
100047:   }
100047: 
100047:   result.mCORSUsed = aElement->GetCORSMode() != CORS_NONE;
100047:   result.mSurface = surf;
100047:   result.mSize = size;
100047:   result.mPrincipal = principal.forget();
100047:   result.mIsWriteOnly = false;
100047: 
100047:   return result;
100047: }
100047: 
100047: nsLayoutUtils::SurfaceFromElementResult
100047: nsLayoutUtils::SurfaceFromElement(dom::Element* aElement,
108991:                                   uint32_t aSurfaceFlags)
100047: {
100047:   // If it's a <canvas>, we may be able to just grab its internal surface
100047:   if (nsHTMLCanvasElement* canvas = nsHTMLCanvasElement::FromContent(aElement)) {
100047:     return SurfaceFromElement(canvas, aSurfaceFlags);
100047:   }
100047: 
100047: #ifdef MOZ_MEDIA
100047:   // Maybe it's <video>?
100047:   if (nsHTMLVideoElement* video = nsHTMLVideoElement::FromContent(aElement)) {
100047:     return SurfaceFromElement(video, aSurfaceFlags);
100047:   }
100047: #endif
100047: 
100047:   // Finally, check if it's a normal image
100047:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(aElement);
100047: 
100047:   if (!imageLoader) {
100047:     return SurfaceFromElementResult();
100047:   }
100047: 
100047:   return SurfaceFromElement(imageLoader, aSurfaceFlags);
100047: }
100047: 
 41068: /* static */
 41068: nsIContent*
 41068: nsLayoutUtils::GetEditableRootContentByContentEditable(nsIDocument* aDocument)
 41068: {
 41068:   // If the document is in designMode we should return NULL.
 41068:   if (!aDocument || aDocument->HasFlag(NODE_IS_EDITABLE)) {
106838:     return nullptr;
 41068:   }
 41068: 
 41068:   // contenteditable only works with HTML document.
 41068:   // Note: Use nsIDOMHTMLDocument rather than nsIHTMLDocument for getting the
 41068:   //       body node because nsIDOMHTMLDocument::GetBody() does something
 41068:   //       additional work for some cases and nsEditor uses them.
 41068:   nsCOMPtr<nsIDOMHTMLDocument> domHTMLDoc = do_QueryInterface(aDocument);
 41068:   if (!domHTMLDoc) {
106838:     return nullptr;
 41068:   }
 41068: 
 41634:   Element* rootElement = aDocument->GetRootElement();
 41634:   if (rootElement && rootElement->IsEditable()) {
 41634:     return rootElement;
 41068:   }
 41068: 
 41068:   // If there are no editable root element, check its <body> element.
 41068:   // Note that the body element could be <frameset> element.
 41068:   nsCOMPtr<nsIDOMHTMLElement> body;
 41068:   nsresult rv = domHTMLDoc->GetBody(getter_AddRefs(body));
 41068:   nsCOMPtr<nsIContent> content = do_QueryInterface(body);
 41068:   if (NS_SUCCEEDED(rv) && content && content->IsEditable()) {
 41068:     return content;
 41068:   }
106838:   return nullptr;
 41068: }
 41068: 
 60338: #ifdef DEBUG
 60338: /* static */ void
 60338: nsLayoutUtils::AssertNoDuplicateContinuations(nsIFrame* aContainer,
 60338:                                               const nsFrameList& aFrameList)
 60338: {
 60338:   for (nsIFrame* f = aFrameList.FirstChild(); f ; f = f->GetNextSibling()) {
 60338:     // Check only later continuations of f; we deal with checking the
 60338:     // earlier continuations when we hit those earlier continuations in
 60338:     // the frame list.
 60338:     for (nsIFrame *c = f; (c = c->GetNextInFlow());) {
 60338:       NS_ASSERTION(c->GetParent() != aContainer ||
 60338:                    !aFrameList.ContainsFrame(c),
 60338:                    "Two continuations of the same frame in the same "
 60338:                    "frame list");
 60338:     }
 60338:   }
 60338: }
 60341: 
 60341: // Is one of aFrame's ancestors a letter frame?
 60341: static bool
 60341: IsInLetterFrame(nsIFrame *aFrame)
 60341: {
 60341:   for (nsIFrame *f = aFrame->GetParent(); f; f = f->GetParent()) {
 60341:     if (f->GetType() == nsGkAtoms::letterFrame) {
 60341:       return true;
 60341:     }
 60341:   }
 60341:   return false;
 60341: }
 60341: 
 60341: /* static */ void
 60341: nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(nsIFrame *aSubtreeRoot)
 60341: {
 60341:   NS_ASSERTION(aSubtreeRoot->GetPrevInFlow(),
 60341:                "frame tree not empty, but caller reported complete status");
 60341: 
 60341:   // Also assert that text frames map no text.
108991:   int32_t start, end;
 60341:   nsresult rv = aSubtreeRoot->GetOffsets(start, end);
 60341:   NS_ASSERTION(NS_SUCCEEDED(rv), "GetOffsets failed");
 60341:   // In some cases involving :first-letter, we'll partially unlink a
 60341:   // continuation in the middle of a continuation chain from its
 60341:   // previous and next continuations before destroying it, presumably so
 60341:   // that we don't also destroy the later continuations.  Once we've
 60341:   // done this, GetOffsets returns incorrect values.
 60341:   // For examples, see list of tests in
 60341:   // https://bugzilla.mozilla.org/show_bug.cgi?id=619021#c29
 60341:   NS_ASSERTION(start == end || IsInLetterFrame(aSubtreeRoot),
 60341:                "frame tree not empty, but caller reported complete status");
 60341: 
 77153:   nsIFrame::ChildListIterator lists(aSubtreeRoot);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(childFrames.get());
 77153:     }
 77153:   }
 60341: }
 60338: #endif
 60338: 
 60450: /* static */
 71908: nsresult
 71908: nsLayoutUtils::GetFontFacesForFrames(nsIFrame* aFrame,
 71908:                                      nsFontFaceList* aFontFaceList)
 71908: {
 71908:   NS_PRECONDITION(aFrame, "NULL frame pointer");
 71908: 
 71908:   if (aFrame->GetType() == nsGkAtoms::textFrame) {
115367:     return GetFontFacesForText(aFrame, 0, INT32_MAX, false,
 71908:                                aFontFaceList);
 71908:   }
 71908: 
 71908:   while (aFrame) {
 77153:     nsIFrame::ChildListID childLists[] = { nsIFrame::kPrincipalList,
 77153:                                            nsIFrame::kPopupList };
 85981:     for (size_t i = 0; i < ArrayLength(childLists); ++i) {
 71908:       nsFrameList children(aFrame->GetChildList(childLists[i]));
 71908:       for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
 71908:         nsIFrame* child = e.get();
 71908:         if (child->GetPrevContinuation()) {
 71908:           continue;
 71908:         }
 71908:         child = nsPlaceholderFrame::GetRealFrameFor(child);
 71908:         nsresult rv = GetFontFacesForFrames(child, aFontFaceList);
 71908:         NS_ENSURE_SUCCESS(rv, rv);
 71908:       }
 71908:     }
 71908:     aFrame = GetNextContinuationOrSpecialSibling(aFrame);
 71908:   }
 71908: 
 71908:   return NS_OK;
 71908: }
 71908: 
 71908: /* static */
 71908: nsresult
 71908: nsLayoutUtils::GetFontFacesForText(nsIFrame* aFrame,
108991:                                    int32_t aStartOffset, int32_t aEndOffset,
 79445:                                    bool aFollowContinuations,
 71908:                                    nsFontFaceList* aFontFaceList)
 71908: {
 71908:   NS_PRECONDITION(aFrame, "NULL frame pointer");
 71908: 
 71908:   if (aFrame->GetType() != nsGkAtoms::textFrame) {
 71908:     return NS_OK;
 71908:   }
 71908: 
 71908:   nsTextFrame* curr = static_cast<nsTextFrame*>(aFrame);
 71908:   do {
108991:     int32_t fstart = NS_MAX(curr->GetContentOffset(), aStartOffset);
108991:     int32_t fend = NS_MIN(curr->GetContentEnd(), aEndOffset);
 71908:     if (fstart >= fend) {
 71908:       continue;
 71908:     }
 71908: 
 71908:     // overlapping with the offset we want
 82675:     gfxSkipCharsIterator iter = curr->EnsureTextRun(nsTextFrame::eInflated);
 82675:     gfxTextRun* textRun = curr->GetTextRun(nsTextFrame::eInflated);
 71908:     NS_ENSURE_TRUE(textRun, NS_ERROR_OUT_OF_MEMORY);
 71908: 
108991:     uint32_t skipStart = iter.ConvertOriginalToSkipped(fstart);
108991:     uint32_t skipEnd = iter.ConvertOriginalToSkipped(fend);
 71908:     aFontFaceList->AddFontsFromTextRun(textRun,
 80704:                                        skipStart,
 80704:                                        skipEnd - skipStart,
 71909:                                        curr);
 71908:   } while (aFollowContinuations &&
 71908:            (curr = static_cast<nsTextFrame*>(curr->GetNextContinuation())));
 71908: 
 71908:   return NS_OK;
 71908: }
 71908: 
 71908: /* static */
 82849: size_t
 82849: nsLayoutUtils::SizeOfTextRunsForFrames(nsIFrame* aFrame,
 82849:                                        nsMallocSizeOfFun aMallocSizeOf,
 82849:                                        bool clear)
 80375: {
 80375:   NS_PRECONDITION(aFrame, "NULL frame pointer");
 80375: 
 82849:   size_t total = 0;
 82849: 
 80375:   if (aFrame->GetType() == nsGkAtoms::textFrame) {
 80375:     nsTextFrame* textFrame = static_cast<nsTextFrame*>(aFrame);
108991:     for (uint32_t i = 0; i < 2; ++i) {
 82675:       gfxTextRun *run = textFrame->GetTextRun(
 82675:         (i != 0) ? nsTextFrame::eInflated : nsTextFrame::eNotInflated);
 80375:       if (run) {
 82849:         if (clear) {
 82849:           run->ResetSizeOfAccountingFlags();
 80375:         } else {
 82849:           total += run->MaybeSizeOfIncludingThis(aMallocSizeOf);
 82849:         }
 82849:       }
 82849:     }
 82849:     return total;
 80375:   }
 80375: 
 80375:   nsAutoTArray<nsIFrame::ChildList,4> childListArray;
 80375:   aFrame->GetChildLists(&childListArray);
 80375: 
 80375:   for (nsIFrame::ChildListArrayIterator childLists(childListArray);
 80375:        !childLists.IsDone(); childLists.Next()) {
 80375:     for (nsFrameList::Enumerator e(childLists.CurrentList());
 80375:          !e.AtEnd(); e.Next()) {
 82849:       total += SizeOfTextRunsForFrames(e.get(), aMallocSizeOf, clear);
 82849:     }
 82849:   }
 82849:   return total;
 80375: }
 80375: 
 80375: /* static */
 60450: void
 82670: nsLayoutUtils::Initialize()
 82670: {
119442:   Preferences::AddUintVarCache(&sFontSizeInflationMaxRatio,
119442:                                "font.size.inflation.maxRatio");
115831:   Preferences::AddUintVarCache(&sFontSizeInflationEmPerLine,
 82670:                                "font.size.inflation.emPerLine");
115831:   Preferences::AddUintVarCache(&sFontSizeInflationMinTwips,
 82670:                                "font.size.inflation.minTwips");
115831:   Preferences::AddUintVarCache(&sFontSizeInflationLineThreshold,
 95532:                                "font.size.inflation.lineThreshold");
115831:   Preferences::AddIntVarCache(&sFontSizeInflationMappingIntercept,
108158:                               "font.size.inflation.mappingIntercept");
115873: 
115873: #ifdef MOZ_FLEXBOX
115873:   Preferences::RegisterCallback(FlexboxEnabledPrefChangeCallback,
115873:                                 FLEXBOX_ENABLED_PREF_NAME);
115873:   FlexboxEnabledPrefChangeCallback(FLEXBOX_ENABLED_PREF_NAME, nullptr);
115873: #endif // MOZ_FLEXBOX
 82670: }
 82670: 
 82670: /* static */
 82670: void
 60450: nsLayoutUtils::Shutdown()
 60450: {
 60450:   if (sContentMap) {
 60450:     delete sContentMap;
115831:     sContentMap = nullptr;
 60450:   }
115873: 
115873: #ifdef MOZ_FLEXBOX
115873:   Preferences::UnregisterCallback(FlexboxEnabledPrefChangeCallback,
115873:                                   FLEXBOX_ENABLED_PREF_NAME);
115873: #endif // MOZ_FLEXBOX
 60450: }
 60450: 
 82098: /* static */
 82098: void
 82098: nsLayoutUtils::RegisterImageRequest(nsPresContext* aPresContext,
 82098:                                     imgIRequest* aRequest,
 82098:                                     bool* aRequestRegistered)
 82098: {
 82098:   if (!aPresContext) {
 82098:     return;
 82098:   }
 82098: 
 82098:   if (aRequestRegistered && *aRequestRegistered) {
 82098:     // Our request is already registered with the refresh driver, so
 82098:     // no need to register it again.
 82098:     return;
 82098:   }
 82098: 
 82098:   if (aRequest) {
 82098:     if (!aPresContext->RefreshDriver()->AddImageRequest(aRequest)) {
 82098:       NS_WARNING("Unable to add image request");
 82098:       return;
 82098:     }
 82098: 
 82098:     if (aRequestRegistered) {
 82098:       *aRequestRegistered = true;
 82098:     }
 82098:   }
 82098: }
 82098: 
 82098: /* static */
 82098: void
 82098: nsLayoutUtils::RegisterImageRequestIfAnimated(nsPresContext* aPresContext,
 82098:                                               imgIRequest* aRequest,
 82098:                                               bool* aRequestRegistered)
 82098: {
 82098:   if (!aPresContext) {
 82098:     return;
 82098:   }
 82098: 
 82098:   if (aRequestRegistered && *aRequestRegistered) {
 82098:     // Our request is already registered with the refresh driver, so
 82098:     // no need to register it again.
 82098:     return;
 82098:   }
 82098: 
 82098:   if (aRequest) {
 82098:     nsCOMPtr<imgIContainer> image;
119130:     if (NS_SUCCEEDED(aRequest->GetImage(getter_AddRefs(image)))) {
 82098:       // Check to verify that the image is animated. If so, then add it to the
 82098:       // list of images tracked by the refresh driver.
 82098:       bool isAnimated = false;
 82098:       nsresult rv = image->GetAnimated(&isAnimated);
 82098:       if (NS_SUCCEEDED(rv) && isAnimated) {
 82098:         if (!aPresContext->RefreshDriver()->AddImageRequest(aRequest)) {
 82098:           NS_WARNING("Unable to add image request");
 82098:           return;
 82098:         }
 82098: 
 82098:         if (aRequestRegistered) {
 82098:           *aRequestRegistered = true;
 82098:         }
 82098:       }
 82098:     }
 82098:   }
 82098: }
 82098: 
 82098: /* static */
 82098: void
 82098: nsLayoutUtils::DeregisterImageRequest(nsPresContext* aPresContext,
 82098:                                       imgIRequest* aRequest,
 82098:                                       bool* aRequestRegistered)
 82098: {
 82098:   if (!aPresContext) {
 82098:     return;
 82098:   }
 82098: 
 82098:   // Deregister our imgIRequest with the refresh driver to
 82098:   // complete tear-down, but only if it has been registered
 82098:   if (aRequestRegistered && !*aRequestRegistered) {
 82098:     return;
 82098:   }
 82098: 
 82098:   if (aRequest) {
 82098:     nsCOMPtr<imgIContainer> image;
119130:     if (NS_SUCCEEDED(aRequest->GetImage(getter_AddRefs(image)))) {
 82098:       aPresContext->RefreshDriver()->RemoveImageRequest(aRequest);
 82098: 
 82098:       if (aRequestRegistered) {
 82098:         *aRequestRegistered = false;
 82098:       }
 82098:     }
 82098:   }
 82098: }
 82098: 
 98711: /* static */
 98711: void
 98711: nsLayoutUtils::PostRestyleEvent(Element* aElement,
 98711:                                 nsRestyleHint aRestyleHint,
 98711:                                 nsChangeHint aMinChangeHint)
 98711: {
 98711:   nsIDocument* doc = aElement->GetCurrentDoc();
 98711:   if (doc) {
 98711:     nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
 98711:     if (presShell) {
 98711:       presShell->FrameConstructor()->PostRestyleEvent(
 98711:         aElement, aRestyleHint, aMinChangeHint);
 98711:     }
 98711:   }
 98711: }
 98711: 
 14319: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
 14319:                                      const nsAString& aValue)
 14319:   : mContent(aContent),
 14319:     mAttrName(aAttrName),
 14319:     mValue(aValue)
 14319: {
 14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
 14319: }
 14319: 
 41743: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
108991:                                      int32_t aValue)
 41743:   : mContent(aContent),
 41743:     mAttrName(aAttrName)
 41743: {
 41743:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
 41743:   mValue.AppendInt(aValue);
 41743: }
 41743: 
 14319: NS_IMETHODIMP
 14319: nsSetAttrRunnable::Run()
 14319: {
 80486:   return mContent->SetAttr(kNameSpaceID_None, mAttrName, mValue, true);
 14319: }
 14319: 
 14319: nsUnsetAttrRunnable::nsUnsetAttrRunnable(nsIContent* aContent,
 14319:                                          nsIAtom* aAttrName)
 14319:   : mContent(aContent),
 14319:     mAttrName(aAttrName)
 14319: {
 14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
 14319: }
 14319: 
 14319: NS_IMETHODIMP
 14319: nsUnsetAttrRunnable::Run()
 14319: {
 80486:   return mContent->UnsetAttr(kNameSpaceID_None, mAttrName, true);
 14319: }
 23933: 
 23933: nsReflowFrameRunnable::nsReflowFrameRunnable(nsIFrame* aFrame,
 23933:                           nsIPresShell::IntrinsicDirty aIntrinsicDirty,
 23933:                           nsFrameState aBitToAdd)
 23933:   : mWeakFrame(aFrame),
 23933:     mIntrinsicDirty(aIntrinsicDirty),
 23933:     mBitToAdd(aBitToAdd)
 23933: {
 23933: }
 23933: 
 23933: NS_IMETHODIMP
 23933: nsReflowFrameRunnable::Run()
 23933: {
 23933:   if (mWeakFrame.IsAlive()) {
 23933:     mWeakFrame->PresContext()->PresShell()->
 23933:       FrameNeedsReflow(mWeakFrame, mIntrinsicDirty, mBitToAdd);
 23933:   }
 23933:   return NS_OK;
 23933: }
 82670: 
 82670: /**
 82670:  * Compute the minimum font size inside of a container with the given
 82670:  * width, such that **when the user zooms the container to fill the full
 82670:  * width of the device**, the fonts satisfy our minima.
 82670:  */
 82670: static nscoord
 82670: MinimumFontSizeFor(nsPresContext* aPresContext, nscoord aContainerWidth)
 82670: {
101113:   nsIPresShell* presShell = aPresContext->PresShell();
101113: 
108991:   uint32_t emPerLine = presShell->FontSizeInflationEmPerLine();
108991:   uint32_t minTwips = presShell->FontSizeInflationMinTwips();
 97801:   if (emPerLine == 0 && minTwips == 0) {
 82670:     return 0;
 82670:   }
 85975: 
 85975:   // Clamp the container width to the device dimensions
 85975:   nscoord iFrameWidth = aPresContext->GetVisibleArea().width;
 85975:   nscoord effectiveContainerWidth = NS_MIN(iFrameWidth, aContainerWidth);
 85975: 
 82670:   nscoord byLine = 0, byInch = 0;
 97801:   if (emPerLine != 0) {
 97801:     byLine = effectiveContainerWidth / emPerLine;
 97801:   }
 97801:   if (minTwips != 0) {
 82670:     // REVIEW: Is this giving us app units and sizes *not* counting
 82670:     // viewport scaling?
 82670:     float deviceWidthInches =
 97799:       aPresContext->ScreenWidthInchesForFontInflation();
 85975:     byInch = NSToCoordRound(effectiveContainerWidth /
 82670:                             (deviceWidthInches * 1440 /
 97801:                              minTwips ));
 82670:   }
 82670:   return NS_MAX(byLine, byInch);
 82670: }
 82670: 
 82670: /* static */ float
 82670: nsLayoutUtils::FontSizeInflationInner(const nsIFrame *aFrame,
 82670:                                       nscoord aMinFontSize)
 82670: {
 82670:   // Note that line heights should be inflated by the same ratio as the
 82670:   // font size of the same text; thus we operate only on the font size
 82670:   // even when we're scaling a line height.
 82670:   nscoord styleFontSize = aFrame->GetStyleFont()->mFont.size;
 82670:   if (styleFontSize <= 0) {
 82670:     // Never scale zero font size.
 82670:     return 1.0;
 82670:   }
 82670: 
 82670:   if (aMinFontSize <= 0) {
 82670:     // No need to scale.
 82670:     return 1.0;
 82670:   }
 82670: 
 95343:   // If between this current frame and its font inflation container there is a
 95343:   // non-inline element with fixed width or height, then we should not inflate
 95343:   // fonts for this frame.
 95343:   for (const nsIFrame* f = aFrame;
 95343:        f && !IsContainerForFontSizeInflation(f);
 95343:        f = f->GetParent()) {
 95343:     nsIContent* content = f->GetContent();
101087:     nsIAtom* fType = f->GetType();
 95343:     // Also, if there is more than one frame corresponding to a single
 95343:     // content node, we want the outermost one.
 97702:     if (!(f->GetParent() && f->GetParent()->GetContent() == content) &&
101087:         // ignore width/height on inlines since they don't apply
101087:         fType != nsGkAtoms::inlineFrame &&
101087:         // ignore width on radios and checkboxes since we enlarge them and
101087:         // they have width/height in ua.css
101087:         fType != nsGkAtoms::formControlFrame) {
 95343:       nsStyleCoord stylePosWidth = f->GetStylePosition()->mWidth;
 95343:       nsStyleCoord stylePosHeight = f->GetStylePosition()->mHeight;
 95343:       if (stylePosWidth.GetUnit() != eStyleUnit_Auto ||
 95343:           stylePosHeight.GetUnit() != eStyleUnit_Auto) {
 95343: 
 95343:         return 1.0;
 95343:       }
 95343:     }
 95343:   }
 95343: 
108991:   int32_t interceptParam = nsLayoutUtils::FontSizeInflationMappingIntercept();
119442:   float maxRatio = (float)nsLayoutUtils::FontSizeInflationMaxRatio() / 100.0f;
108158: 
 82670:   float ratio = float(styleFontSize) / float(aMinFontSize);
119442:   float inflationRatio;
108158: 
108158:   // Given a minimum inflated font size m, a specified font size s, we want to
108158:   // find the inflated font size i and then return the ratio of i to s (i/s).
108158:   if (interceptParam >= 0) {
108158:     // Since the mapping intercept parameter P is greater than zero, we use it
108158:     // to determine the point where our mapping function intersects the i=s
108158:     // line. This means that we have an equation of the form:
108158:     //
108158:     // i = m + s·(P/2)/(1 + P/2), if s <= (1 + P/2)·m
108158:     // i = s, if s >= (1 + P/2)·m
108158: 
108158:     float intercept = 1 + float(interceptParam)/2.0f;
108158:     if (ratio >= intercept) {
108158:       // If we're already at 1+P/2 or more times the minimum, don't scale.
 82670:       return 1.0;
 82670:     }
 82670: 
108158:     // The point (intercept, intercept) is where the part of the i vs. s graph
108158:     // that's not slope 1 meets the i=s line.  (This part of the
108158:     // graph is a line from (0, m), to that point). We calculate the
108158:     // intersection point to be ((1+P/2)m, (1+P/2)m), where P is the
108158:     // intercept parameter above. We then need to return i/s.
119442:     inflationRatio = (1.0f + (ratio * (intercept - 1) / intercept)) / ratio;
108158:   } else {
108158:     // This is the case where P is negative. We essentially want to implement
108158:     // the case for P=infinity here, so we make i = s + m, which means that
108158:     // i/s = s/s + m/s = 1 + 1/ratio
119442:     inflationRatio = 1 + 1.0f / ratio;
119442:   }
119442: 
119442:   if (maxRatio > 1.0 && inflationRatio > maxRatio) {
119442:     return maxRatio;
119442:   } else {
119442:     return inflationRatio;
108158:   }
 82670: }
 82670: 
 82670: static bool
 82670: ShouldInflateFontsForContainer(const nsIFrame *aFrame)
 82670: {
 82670:   // We only want to inflate fonts for text that is in a place
 82670:   // with room to expand.  The question is what the best heuristic for
 82670:   // that is...
 82670:   // For now, we're going to use NS_FRAME_IN_CONSTRAINED_HEIGHT, which
 82670:   // indicates whether the frame is inside something with a constrained
 82670:   // height (propagating down the tree), but the propagation stops when
 82670:   // we hit overflow-y: scroll or auto.
 91426:   const nsStyleText* styleText = aFrame->GetStyleText();
 91426: 
 91426:   return styleText->mTextSizeAdjust != NS_STYLE_TEXT_SIZE_ADJUST_NONE &&
 91426:          !(aFrame->GetStateBits() & NS_FRAME_IN_CONSTRAINED_HEIGHT) &&
 91426:          // We also want to disable font inflation for containers that have
 91426:          // preformatted text.
 98993:          styleText->WhiteSpaceCanWrap();
 82670: }
 82670: 
 82670: nscoord
 98995: nsLayoutUtils::InflationMinFontSizeFor(const nsIFrame *aFrame)
 82670: {
 98992:   nsPresContext *presContext = aFrame->PresContext();
 98992:   if (!FontSizeInflationEnabled(presContext) ||
 98992:       presContext->mInflationDisabledForShrinkWrap) {
 82670:     return 0;
 82670:   }
 82670: 
 82670:   for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
 82670:     if (IsContainerForFontSizeInflation(f)) {
 82670:       if (!ShouldInflateFontsForContainer(f)) {
 82670:         return 0;
 82670:       }
 82670: 
 98993:       nsFontInflationData *data =
 98993:         nsFontInflationData::FindFontInflationDataFor(aFrame);
 98993:       // FIXME: The need to null-check here is sort of a bug, and might
 98993:       // lead to incorrect results.
 98993:       if (!data || !data->InflationEnabled()) {
 98993:         return 0;
 98993:       }
 98993: 
 82670:       return MinimumFontSizeFor(aFrame->PresContext(),
 98993:                                 data->EffectiveWidth());
 82670:     }
 82670:   }
 82670: 
 82670:   NS_ABORT_IF_FALSE(false, "root should always be container");
 82670: 
 82670:   return 0;
 82670: }
 82670: 
 82670: float
 98995: nsLayoutUtils::FontSizeInflationFor(const nsIFrame *aFrame)
 82670: {
 82670:   if (!FontSizeInflationEnabled(aFrame->PresContext())) {
 82670:     return 1.0;
 82670:   }
 82670: 
 98995:   return FontSizeInflationInner(aFrame, InflationMinFontSizeFor(aFrame));
 82670: }
 82670: 
 82670: /* static */ bool
 82670: nsLayoutUtils::FontSizeInflationEnabled(nsPresContext *aPresContext)
 82670: {
101113:   nsIPresShell* presShell = aPresContext->GetPresShell();
101113: 
101113:   if (!presShell ||
101113:       (presShell->FontSizeInflationEmPerLine() == 0 &&
101113:        presShell->FontSizeInflationMinTwips() == 0) ||
 88583:        aPresContext->IsChrome()) {
 88583:     return false;
 88583:   }
 88583: 
114646:   // XXXjwir3:
114646:   // See bug 706918, comment 23 for more information on this particular section
114646:   // of the code. We're using "screen size" in place of the size of the content
114646:   // area, because on mobile, these are close or equal. This will work for our
114646:   // purposes (bug 706198), but it will need to be changed in the future to be
114646:   // more correct when we bring the rest of the viewport code into platform.
114646:   // We actually want the size of the content area, in the event that we don't
114646:   // have any metadata about the width and/or height. On mobile, the screen size
114646:   // and the size of the content area are very close, or the same value.
114646:   // In XUL fennec, the content area is the size of the <browser> widget, but
114646:   // in native fennec, the content area is the size of the Gecko LayerView
114646:   // object.
114646: 
114646:   // TODO:
114646:   // Once bug 716575 has been resolved, this code should be changed so that it
114646:   // does the right thing on all platforms.
114646:   nsresult rv;
114646:   nsCOMPtr<nsIScreenManager> screenMgr =
114646:     do_GetService("@mozilla.org/gfx/screenmanager;1", &rv);
115179:   NS_ENSURE_SUCCESS(rv, false);
114646: 
114646:   nsCOMPtr<nsIScreen> screen;
114646:   screenMgr->GetPrimaryScreen(getter_AddRefs(screen));
114646:   if (screen) {
114646:     int32_t screenLeft, screenTop, screenWidth, screenHeight;
114646:     screen->GetRect(&screenLeft, &screenTop, &screenWidth, &screenHeight);
114646: 
 88583:     ViewportInfo vInf =
114646:       nsContentUtils::GetViewportInfo(aPresContext->PresShell()->GetDocument(),
114646:                                       screenWidth, screenHeight);
 88583: 
 88583:     if (vInf.defaultZoom >= 1.0 || vInf.autoSize) {
 88583:       return false;
 88583:     }
114646:   }
 88583: 
 88583:   return true;
 88583: }
