 38891: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 16807: /* vim:expandtab:shiftwidth=4:tabstop=4:
 16807:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 16807: 
 80467: #include "mozilla/Util.h"
108556: 
 94111: #include <QApplication>
 94111: #include <QDesktopWidget>
 38955: #include <QtGui/QCursor>
 94111: #include <QIcon>
 94111: #include <QGraphicsScene>
 94111: #include <QGraphicsView>
 94111: #include <QGraphicsSceneContextMenuEvent>
 94111: #include <QGraphicsSceneDragDropEvent>
 94111: #include <QGraphicsSceneMouseEvent>
 94111: #include <QGraphicsSceneHoverEvent>
 94111: #include <QGraphicsSceneWheelEvent>
 94111: #include <QGraphicsSceneResizeEvent>
 94111: #include <QStyleOptionGraphicsItem>
 40747: #include <QPaintEngine>
 94111: #include <QMimeData>
108556: #include "mozqglwidgetwrapper.h"
 38955: 
 38955: #include <QtCore/QDebug>
 38955: #include <QtCore/QEvent>
 38955: #include <QtCore/QVariant>
 39368: #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 39368: #include <QPinchGesture>
 55246: #include <QGestureRecognizer>
 55246: #include "mozSwipeGesture.h"
 55246: static Qt::GestureType gSwipeGestureId = Qt::CustomGesture;
 55246: 
 55246: // How many milliseconds mouseevents are blocked after receiving
 55246: // multitouch.
 55246: static const float GESTURES_BLOCK_MOUSE_FOR = 200;
 63422: #ifdef MOZ_ENABLE_QTMOBILITY
 63422: #include <QtSensors/QOrientationSensor>
 63422: using namespace QtMobility;
 63422: #endif // MOZ_ENABLE_QTMOBILITY
 63422: #endif // QT version check 4.6
 38955: 
 51523: #ifdef MOZ_X11
 51523: #include <X11/Xlib.h>
 51523: #endif //MOZ_X11
 51523: 
 46725: #include "nsXULAppAPI.h"
 46725: 
 16807: #include "prlink.h"
 16807: 
 38147: #include "nsWindow.h"
 38147: #include "mozqwidget.h"
 16807: 
 63422: #ifdef MOZ_ENABLE_QTMOBILITY
 63422: #include "mozqorientationsensorfilter.h"
 63422: #endif
 63422: 
 40944: #include "nsIdleService.h"
 68481: #include "nsRenderingContext.h"
 16807: #include "nsIRollupListener.h"
 16807: #include "nsWidgetsCID.h"
 16807: #include "nsQtKeyUtils.h"
 42314: #include "mozilla/Services.h"
 71384: #include "mozilla/Preferences.h"
120353: #include "mozilla/Likely.h"
120920: #include "LayersTypes.h"
108457: #include "nsIWidgetListener.h"
 71384: 
 16807: #include "nsIStringBundle.h"
 16807: #include "nsGfxCIID.h"
 16807: 
 16807: #include "imgIContainer.h"
 16807: #include "nsGfxCIID.h"
 16807: #include "nsIInterfaceRequestorUtils.h"
 16807: #include "nsAutoPtr.h"
 16807: 
 16881: #include "gfxQtPlatform.h"
 77137: #ifdef MOZ_X11
 16807: #include "gfxXlibSurface.h"
 77137: #endif
 16842: #include "gfxQPainterSurface.h"
 16807: #include "gfxContext.h"
 42185: #include "gfxImageSurface.h"
 16807: 
 39368: #include "nsIDOMSimpleGestureEvent.h" //Gesture support
108073: #include "nsIDOMWheelEvent.h"
 39368: 
 51787: #if MOZ_PLATFORM_MAEMO > 5
 51787: #include "nsIDOMWindow.h"
 51787: #include "nsIDOMElement.h"
 51787: #include "nsIFocusManager.h"
 51787: #endif
 51787: 
 51523: #ifdef MOZ_X11
 51523: #include "keysym2ucs.h"
 77986: #if MOZ_PLATFORM_MAEMO == 6
 77986: #include <X11/Xatom.h>
106838: static Atom sPluginIMEAtom = nullptr;
 77986: #define PLUGIN_VKB_REQUEST_PROP "_NPAPI_PLUGIN_REQUEST_VKB"
 79990: #include <QThread>
 77986: #endif
 51523: #endif //MOZ_X11
 51523: 
120920: #include "gfxUtils.h"
 46147: #include "Layers.h"
120920: #include "GLContextProvider.h"
108556: #include "BasicLayers.h"
 46147: #include "LayerManagerOGL.h"
 81001: #include "nsFastStartupQt.h"
 46147: 
 78855: // If embedding clients want to create widget without real parent window
 78855: // then nsIBaseWindow->Init() should have parent argument equal to PARENTLESS_WIDGET
 78855: #define PARENTLESS_WIDGET (void*)0x13579
 78855: 
 56628: #include "nsShmImage.h"
 56628: extern "C" {
 84270: #define PIXMAN_DONT_DEFINE_STDINT
 56628: #include "pixman.h"
 56628: }
 56628: 
 56628: using namespace mozilla;
 82840: using namespace mozilla::widget;
120920: using mozilla::gl::GLContext;
120920: using mozilla::layers::LayerManagerOGL;
 56628: 
 43497: // Cached offscreen surface
 43497: static nsRefPtr<gfxASurface> gBufferSurface;
 56628: #ifdef MOZ_HAVE_SHMIMAGE
 56628: // If we're using xshm rendering, mThebesSurface wraps gShmImage
 56628: nsRefPtr<nsShmImage> gShmImage;
 56628: #endif
 42351: 
 38320: static int gBufferPixmapUsageCount = 0;
 40747: static gfxIntSize gBufferMaxSize(0, 0);
 16808: 
 16807: // initialization static functions 
 16807: static nsresult    initialize_prefs        (void);
 16807: 
 16807: static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
 16807: 
 16807: #define NS_WINDOW_TITLE_MAX_LENGTH 4095
 16807: 
 16807: #define kWindowPositionSlop 20
 16807: 
 38147: // Qt
 16807: static const int WHEEL_DELTA = 120;
 79445: static bool gGlobalsInitialized = false;
 16961: 
 38147: static bool
 38147: is_mouse_in_window (MozQWidget* aWindow, double aMouseX, double aMouseY);
 16961: 
 61584: static bool sAltGrModifier = false;
 61584: 
 63422: #ifdef MOZ_ENABLE_QTMOBILITY
106838: static QOrientationSensor *gOrientation = nullptr;
 63422: static MozQOrientationSensorFilter gOrientationFilter;
 63422: #endif
 63422: 
 79445: static bool
 16884: isContextMenuKeyEvent(const QKeyEvent *qe)
 16807: {
108991:     uint32_t kc = QtKeyCodeToDOMKeyCode(qe->key());
 16884:     if (qe->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier))
 80486:         return false;
 16884: 
 79445:     bool isShift = qe->modifiers() & Qt::ShiftModifier;
 16884:     return (kc == NS_VK_F10 && isShift) ||
 16884:         (kc == NS_VK_CONTEXT_MENU && !isShift);
 16807: }
 16807: 
 16884: static void
 16884: InitKeyEvent(nsKeyEvent &aEvent, QKeyEvent *aQEvent)
 16807: {
 96893:     aEvent.InitBasicModifiers(aQEvent->modifiers() & Qt::ControlModifier,
 96893:                               aQEvent->modifiers() & Qt::AltModifier,
 96893:                               aQEvent->modifiers() & Qt::ShiftModifier,
 96893:                               aQEvent->modifiers() & Qt::MetaModifier);
 97480: 
 97480:     // TODO: Needs to set .location for desktop Qt build.
 97480: #ifdef MOZ_PLATFORM_MAEMO
 97480:     aEvent.location  = nsIDOMKeyEvent::DOM_KEY_LOCATION_MOBILE;
 97480: #endif
 16884:     aEvent.time      = 0;
 16884: 
 61584:     if (sAltGrModifier) {
 96893:         aEvent.modifiers |= (widget::MODIFIER_CONTROL | widget::MODIFIER_ALT);
 61584:     }
 61584: 
 38147:     // The transformations above and in qt for the keyval are not invertible
 38147:     // so link to the QKeyEvent (which will vanish soon after return from the
 16884:     // event callback) to give plugins access to hardware_keycode and state.
 38147:     // (An XEvent would be nice but the QKeyEvent is good enough.)
 34743:     aEvent.pluginEvent = (void *)aQEvent;
 16807: }
 16807: 
 16807: nsWindow::nsWindow()
 16807: {
 16915:     LOG(("%s [%p]\n", __PRETTY_FUNCTION__, (void *)this));
 16915: 
 80486:     mIsTopLevel       = false;
 80486:     mIsDestroyed      = false;
 80486:     mIsShown          = false;
 80486:     mEnabled          = true;
106838:     mWidget              = nullptr;
 80486:     mIsVisible           = false;
 80486:     mActivatePending     = false;
 16807:     mWindowType          = eWindowType_child;
 16807:     mSizeState           = nsSizeMode_Normal;
 42934:     mLastSizeMode        = nsSizeMode_Normal;
 16807:     mPluginType          = PluginType_NONE;
 16807:     mQCursor             = Qt::ArrowCursor;
 80486:     mNeedsResize         = false;
 80486:     mNeedsMove           = false;
 80486:     mListenForResizes    = false;
 80486:     mNeedsShow           = false;
 80486:     mGesturesCancelled   = false;
 80486:     mTimerStarted        = false;
 60755:     mPinchEvent.needDispatch = false;
 60755:     mMoveEvent.needDispatch = false;
 16807:     
 16807:     if (!gGlobalsInitialized) {
 93721:         gfxPlatform::GetPlatform();
 80486:         gGlobalsInitialized = true;
 16807: 
 77986: #if defined(MOZ_X11) && (MOZ_PLATFORM_MAEMO == 6)
 79990:         // This cannot be called on non-main thread
 79990:         if (QThread::currentThread() == qApp->thread()) {
 94111:             sPluginIMEAtom = XInternAtom(mozilla::DefaultXDisplay(), PLUGIN_VKB_REQUEST_PROP, False);
 79990:         }
 77986: #endif
 16807:         // It's OK if either of these fail, but it may not be one day.
 16807:         initialize_prefs();
 16807:     }
 16807: 
 16807:     memset(mKeyDownFlags, 0, sizeof(mKeyDownFlags));
 16807: 
 80486:     mIsTransparent = false;
 16913: 
 16807:     mCursor = eCursor_standard;
 38320: 
 38320:     gBufferPixmapUsageCount++;
 55246: 
 55246: #if (QT_VERSION > QT_VERSION_CHECK(4,6,0))
 55246:     if (gSwipeGestureId == Qt::CustomGesture) {
 55246:         // QGestureRecognizer takes ownership
 55246:         MozSwipeGestureRecognizer* swipeRecognizer = new MozSwipeGestureRecognizer;
 55246:         gSwipeGestureId = QGestureRecognizer::registerRecognizer(swipeRecognizer);
 55246:     }
 55246: #endif
 38320: }
 38320: 
 38320: static inline gfxASurface::gfxImageFormat
108991: _depth_to_gfximage_format(int32_t aDepth)
 38320: {
 38320:     switch (aDepth) {
 38320:     case 32:
 38320:         return gfxASurface::ImageFormatARGB32;
 38320:     case 24:
 38320:         return gfxASurface::ImageFormatRGB24;
 43558:     case 16:
 43558:         return gfxASurface::ImageFormatRGB16_565;
 38320:     default:
 38320:         return gfxASurface::ImageFormatUnknown;
 38320:     }
 38320: }
 38320: 
 40747: static inline QImage::Format
 42185: _gfximage_to_qformat(gfxASurface::gfxImageFormat aFormat)
 38320: {
 42185:     switch (aFormat) {
 42185:     case gfxASurface::ImageFormatARGB32:
 43558:         return QImage::Format_ARGB32_Premultiplied;
 42185:     case gfxASurface::ImageFormatRGB24:
 40747:         return QImage::Format_ARGB32;
 43558:     case gfxASurface::ImageFormatRGB16_565:
 43558:         return QImage::Format_RGB16;
 40747:     default:
 40747:         return QImage::Format_Invalid;
 38320:     }
 40747: }
 38320: 
 38320: static bool
106838: UpdateOffScreenBuffers(int aDepth, QSize aSize, QWidget* aWidget = nullptr)
 38320: {
 38320:     gfxIntSize size(aSize.width(), aSize.height());
 43497:     if (gBufferSurface) {
 40747:         if (gBufferMaxSize.width < size.width ||
 40747:             gBufferMaxSize.height < size.height) {
106838:             gBufferSurface = nullptr;
 38320:         } else
 38320:             return true;
 38320:     }
 38320: 
 72496:     gBufferMaxSize.width = NS_MAX(gBufferMaxSize.width, size.width);
 72496:     gBufferMaxSize.height = NS_MAX(gBufferMaxSize.height, size.height);
 38320: 
 38320:     // Check if system depth has related gfxImage format
 38320:     gfxASurface::gfxImageFormat format =
 40747:         _depth_to_gfximage_format(aDepth);
 42185: 
 42185:     // Use fallback RGB24 format, Qt will do conversion for us
 42185:     if (format == gfxASurface::ImageFormatUnknown)
 40747:         format = gfxASurface::ImageFormatRGB24;
 42185: 
 56628: #ifdef MOZ_HAVE_SHMIMAGE
 56628:     if (aWidget) {
 56628:         if (gfxPlatform::GetPlatform()->ScreenReferenceSurface()->GetType() ==
 56628:             gfxASurface::SurfaceTypeImage) {
 56628:             gShmImage = nsShmImage::Create(gBufferMaxSize,
 94111:                                            DefaultVisualOfScreen(gfxQtPlatform::GetXScreen(aWidget)),
 56628:                                            aDepth);
 56628:             gBufferSurface = gShmImage->AsSurface();
 56628:             return true;
 56628:         }
 56628:     }
 56628: #endif
 56628: 
 43497:     gBufferSurface = gfxPlatform::GetPlatform()->
 54253:         CreateOffscreenSurface(gBufferMaxSize, gfxASurface::ContentFromFormat(format));
 56628: 
 38320:     return true;
 16807: }
 16807: 
 16807: nsWindow::~nsWindow()
 16807: {
 16915:     LOG(("%s [%p]\n", __PRETTY_FUNCTION__, (void *)this));
 16807: 
 16807:     Destroy();
 16807: }
 16807: 
 16807: /* static */ void
 16807: nsWindow::ReleaseGlobals()
 16807: {
 16807: }
 16782: 
 16915: NS_IMPL_ISUPPORTS_INHERITED1(nsWindow, nsBaseWidget, nsISupportsWeakReference)
 16782: 
 16807: NS_IMETHODIMP
 31136: nsWindow::ConfigureChildren(const nsTArray<nsIWidget::Configuration>& aConfigurations)
 31136: {
108991:     for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
 31136:         const Configuration& configuration = aConfigurations[i];
 31136: 
 31136:         nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
 31136:         NS_ASSERTION(w->GetParent() == this,
 31136:                      "Configured widget is not a child");
 31136: 
 31136:         if (w->mBounds.Size() != configuration.mBounds.Size()) {
 31136:             w->Resize(configuration.mBounds.x, configuration.mBounds.y,
 31136:                       configuration.mBounds.width, configuration.mBounds.height,
 80486:                       true);
 31136:         } else if (w->mBounds.TopLeft() != configuration.mBounds.TopLeft()) {
 31136:             w->Move(configuration.mBounds.x, configuration.mBounds.y);
 31136:         }
 31136:     }
 31136:     return NS_OK;
 31136: }
 31136: 
 31136: NS_IMETHODIMP
 16807: nsWindow::Destroy(void)
 16807: {
 30337:     if (mIsDestroyed || !mWidget)
 16807:         return NS_OK;
 16807: 
 16807:     LOG(("nsWindow::Destroy [%p]\n", (void *)this));
 80486:     mIsDestroyed = true;
 16807: 
 38320:     if (gBufferPixmapUsageCount &&
 38320:         --gBufferPixmapUsageCount == 0) {
 38320: 
106838:         gBufferSurface = nullptr;
 56628: #ifdef MOZ_HAVE_SHMIMAGE
106838:         gShmImage = nullptr;
 56628: #endif
 63422: #ifdef MOZ_ENABLE_QTMOBILITY
 63422:         if (gOrientation) {
 63422:             gOrientation->removeFilter(&gOrientationFilter);
 63422:             gOrientation->stop();
 63422:             delete gOrientation;
106838:             gOrientation = nullptr;
 63422:         }
 63422: #endif
 38320:     }
 38320: 
120920:     /** Need to clean our LayerManager up while still alive */
120920:     if (mLayerManager) {
120920:         nsRefPtr<GLContext> gl = nullptr;
120920:         if (mLayerManager->GetBackendType() == mozilla::layers::LAYERS_OPENGL) {
120920:             LayerManagerOGL *ogllm = static_cast<LayerManagerOGL*>(mLayerManager.get());
120920:             gl = ogllm->gl();
120920:         }
120920: 
120920:         mLayerManager->Destroy();
120920: 
120920:         if (gl) {
120920:             gl->MarkDestroyed();
120920:         }
120920:     }
120920:     mLayerManager = nullptr;
120920: 
120920:     // It is safe to call DestroyeCompositor several times (here and 
120920:     // in the parent class) since it will take effect only once.
120920:     // The reason we call it here is because on gtk platforms we need 
120920:     // to destroy the compositor before we destroy the gdk window (which
120920:     // destroys the the gl context attached to it).
120920:     DestroyCompositor();
120920: 
120920:     ClearCachedResources();
120920: 
120177:     nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
123327:     if (rollupListener) {
120177:     nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
123327:         if (static_cast<nsIWidget *>(this) == rollupWidget) {
120177:         rollupListener->Rollup(0, nullptr);
123327:         }
123327:     }
 52407: 
 80486:     Show(false);
 16807: 
 16807:     // walk the list of children and call destroy on them.  Have to be
 16807:     // careful, though -- calling destroy on a kid may actually remove
 16807:     // it from our child list, losing its sibling links.
 16807:     for (nsIWidget* kid = mFirstChild; kid; ) {
 16807:         nsIWidget* next = kid->GetNextSibling();
 16807:         kid->Destroy();
 16807:         kid = next;
 16807:     }
 16807: 
 16807:     // Destroy thebes surface now. Badness can happen if we destroy
 16807:     // the surface after its X Window.
106838:     mThebesSurface = nullptr;
106838: 
106838:     QWidget *view = nullptr;
106838:     QGraphicsScene *scene = nullptr;
 30337:     if (mWidget) {
 39016:         if (mIsTopLevel) {
 39016:             view = GetViewWidget();
 39016:             scene = mWidget->scene();
 39016:         }
 39016: 
 30337:         mWidget->dropReceiver();
 16884: 
 16884:         // Call deleteLater instead of delete; Qt still needs the object
 16884:         // to be valid even after sending it a Close event.  We could
 16884:         // also set WA_DeleteOnClose, but this gives us more control.
 30337:         mWidget->deleteLater();
 16884:     }
106838:     mWidget = nullptr;
 16807: 
 16807:     OnDestroy();
 16807: 
 38147:     // tear down some infrastructure after all event handling is finished
 39016:     delete scene;
 38147:     delete view;
 38147: 
 16807:     return NS_OK;
 16807: }
 16807: 
120920: void
120920: nsWindow::ClearCachedResources()
120920: {
120920:     if (mLayerManager &&
120920:         mLayerManager->GetBackendType() == mozilla::layers::LAYERS_BASIC) {
120920:         static_cast<mozilla::layers::BasicLayerManager*> (mLayerManager.get())->
120920:             ClearCachedResources();
120920:     }
120920:     for (nsIWidget* kid = mFirstChild; kid; ) {
120920:         nsIWidget* next = kid->GetNextSibling();
120920:         static_cast<nsWindow*>(kid)->ClearCachedResources();
120920:         kid = next;
120920:     }
120920: }
120920: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetParent(nsIWidget *aNewParent)
 16807: {
 16807:     NS_ENSURE_ARG_POINTER(aNewParent);
 30337:     nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 30337:     nsIWidget* parent = GetParent();
 30337:     if (parent) {
 30337:         parent->RemoveChild(this);
 16807:     }
 54312:     ReparentNativeWidget(aNewParent);
 54312:     aNewParent->AddChild(this);
 54312:     return NS_OK;
 54312: }
 54312: 
 54312: NS_IMETHODIMP
 54312: nsWindow::ReparentNativeWidget(nsIWidget *aNewParent)
 54312: {
 54312:     NS_PRECONDITION(aNewParent, "");
 30337: 
 38147:     MozQWidget* newParent = static_cast<MozQWidget*>(aNewParent->GetNativeData(NS_NATIVE_WINDOW));
 30337:     NS_ASSERTION(newParent, "Parent widget has a null native window handle");
 30337:     if (mWidget) {
 38147:         mWidget->setParentItem(newParent);
 30337:     }
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 79445: nsWindow::SetModal(bool aModal)
 16807: {
 30337:     LOG(("nsWindow::SetModal [%p] %d, widget[%p]\n", (void *)this, aModal, mWidget));
 38147:     if (mWidget)
 38147:         mWidget->setModal(aModal);
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
105772: bool
105772: nsWindow::IsVisible() const
 16807: {
105772:     return mIsShown;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
108991: nsWindow::ConstrainPosition(bool aAllowSlop, int32_t *aX, int32_t *aY)
 16807: {
 30337:     if (mWidget) {
108991:         int32_t screenWidth  = QApplication::desktop()->width();
108991:         int32_t screenHeight = QApplication::desktop()->height();
 38147: 
 16807:         if (aAllowSlop) {
 16807:             if (*aX < (kWindowPositionSlop - mBounds.width))
 16807:                 *aX = kWindowPositionSlop - mBounds.width;
 16807:             if (*aX > (screenWidth - kWindowPositionSlop))
 16807:                 *aX = screenWidth - kWindowPositionSlop;
 16807:             if (*aY < (kWindowPositionSlop - mBounds.height))
 16807:                 *aY = kWindowPositionSlop - mBounds.height;
 16807:             if (*aY > (screenHeight - kWindowPositionSlop))
 16807:                 *aY = screenHeight - kWindowPositionSlop;
 16807:         } else {
 16807:             if (*aX < 0)
 16807:                 *aX = 0;
 16807:             if (*aX > (screenWidth - mBounds.width))
 16807:                 *aX = screenWidth - mBounds.width;
 16807:             if (*aY < 0)
 16807:                 *aY = 0;
 16807:             if (*aY > (screenHeight - mBounds.height))
 16807:                 *aY = screenHeight - mBounds.height;
 16807:         }
 16807:     }
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
108991: nsWindow::Move(int32_t aX, int32_t aY)
 16807: {
 16807:     LOG(("nsWindow::Move [%p] %d %d\n", (void *)this,
 16807:          aX, aY));
 16807: 
 39507:     if (mIsTopLevel) {
 34488:         SetSizeMode(nsSizeMode_Normal);
 34488:     }
 34488: 
 38147:     if (aX == mBounds.x && aY == mBounds.y)
 16807:         return NS_OK;
 16807: 
 80486:     mNeedsMove = false;
 16807: 
 38147:     // update the bounds
 38147:     QPointF pos( aX, aY );
 61829:     if (mIsTopLevel) {
 61829:         QWidget *widget = GetViewWidget();
 61829:         NS_ENSURE_TRUE(widget, NS_OK);
 61829:         widget->move(aX, aY);
 61829:     }
 61829:     else if (mWidget) {
 38147:         // the position of the widget is set relative to the parent
 38147:         // so we map the coordinates accordingly
 38147:         pos = mWidget->mapFromScene(pos);
 38147:         pos = mWidget->mapToParent(pos);
 38147:         mWidget->setPos(pos);
 16807:     }
 16807: 
 16807:     mBounds.x = pos.x();
 16807:     mBounds.y = pos.y();
 16807: 
120177:     NotifyRollupGeometryChange();
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement  aPlacement,
 16807:                       nsIWidget                  *aWidget,
 79445:                       bool                        aActivate)
 16807: {
 16807:     return NS_ERROR_NOT_IMPLEMENTED;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
108991: nsWindow::SetSizeMode(int32_t aMode)
 16807: {
 16807:     nsresult rv;
 16807: 
 16807:     LOG(("nsWindow::SetSizeMode [%p] %d\n", (void *)this, aMode));
 69448:     if (aMode != nsSizeMode_Minimized) {
 69448:         GetViewWidget()->activateWindow();
 69448:     }
 16807: 
 16807:     // Save the requested state.
 16807:     rv = nsBaseWidget::SetSizeMode(aMode);
 16807: 
 16807:     // return if there's no shell or our current state is the same as
 16807:     // the mode we were just set to.
 30337:     if (!mWidget || mSizeState == mSizeMode) {
 16807:         return rv;
 16807:     }
 16807: 
 39446:     QWidget *widget = GetViewWidget();
 39446:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 39446: 
 16807:     switch (aMode) {
 16807:     case nsSizeMode_Maximized:
 39446:         widget->showMaximized();
 16807:         break;
 16807:     case nsSizeMode_Minimized:
 39446:         widget->showMinimized();
 16807:         break;
 37898:     case nsSizeMode_Fullscreen:
 39446:         widget->showFullScreen();
 37898:         break;
 37898: 
 16807:     default:
 16807:         // nsSizeMode_Normal, really.
 39446:         widget->showNormal();
 16807:         break;
 16807:     }
 16807: 
 16807:     mSizeState = mSizeMode;
 16807: 
 16807:     return rv;
 16807: }
 16807: 
 38147: // Helper function to recursively find the first parent item that
 38147: // is still visible (QGraphicsItem can be hidden even if they are
 38147: // set to visible if one of their ancestors is invisible)
 38147: static void find_first_visible_parent(QGraphicsItem* aItem, QGraphicsItem*& aVisibleItem)
 38147: {
114160:     NS_ENSURE_TRUE_VOID(aItem);
 39841: 
106838:     aVisibleItem = nullptr;
106838:     QGraphicsItem* parItem = nullptr;
 39841:     while (!aVisibleItem) {
 39841:         if (aItem->isVisible())
 38147:             aVisibleItem = aItem;
 39841:         else {
 39841:             parItem = aItem->parentItem();
 39841:             if (parItem)
 39841:                 aItem = parItem;
 39841:             else {
 39841:                 aItem->setVisible(true);
 39841:                 aVisibleItem = aItem;
 39841:             }
 39841:         }
 39841:     }
 38147: }
 38147: 
 16807: NS_IMETHODIMP
 79445: nsWindow::SetFocus(bool aRaise)
 16807: {
 16807:     // Make sure that our owning widget has focus.  If it doesn't try to
 16807:     // grab it.  Note that we don't set our focus flag in this case.
 16807:     LOGFOCUS(("  SetFocus [%p]\n", (void *)this));
 16807: 
 30337:     if (!mWidget)
 16807:         return NS_ERROR_FAILURE;
 38147: 
 39841:     if (mWidget->hasFocus())
 39841:         return NS_OK;
 39841: 
 38147:     // Because QGraphicsItem cannot get the focus if they are
 38147:     // invisible, we look up the chain, for the lowest visible
 38147:     // parent and focus that one
106838:     QGraphicsItem* realFocusItem = nullptr;
 38147:     find_first_visible_parent(mWidget, realFocusItem);
 38147: 
 38147:     if (!realFocusItem || realFocusItem->hasFocus())
 30337:         return NS_OK;
 16807: 
 38708:     if (aRaise) {
 38708:         // the raising has to happen on the view widget
 39446:         QWidget *widget = GetViewWidget();
 39446:         if (widget)
 39446:             widget->raise();
 38147:         realFocusItem->setFocus(Qt::ActiveWindowFocusReason);
 38708:     }
 38147:     else
 38147:         realFocusItem->setFocus(Qt::OtherFocusReason);
 38147: 
108457:     // XXXndeakin why is this here? It should dispatch only when the OS
108457:     // notifies us.
 38147:     DispatchActivateEvent();
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 24924: nsWindow::GetScreenBounds(nsIntRect &aRect)
 16807: {
 61829:     aRect = nsIntRect(nsIntPoint(0, 0), mBounds.Size());
 61829:     if (mIsTopLevel) {
 61829:         QWidget *widget = GetViewWidget();
 61829:         NS_ENSURE_TRUE(widget, NS_OK);
 61829:         QPoint pos = widget->pos();
 61829:         aRect.MoveTo(pos.x(), pos.y());
 61829:     }
 61829:     else {
 61829:         aRect.MoveTo(WidgetToScreenOffset());
 61829:     }
 16807:     LOG(("GetScreenBounds %d %d | %d %d | %d %d\n",
 16807:          aRect.x, aRect.y,
 16807:          mBounds.width, mBounds.height,
 16807:          aRect.width, aRect.height));
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetForegroundColor(const nscolor &aColor)
 16807: {
 16807:     return NS_ERROR_NOT_IMPLEMENTED;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetBackgroundColor(const nscolor &aColor)
 16807: {
 16807:     return NS_ERROR_NOT_IMPLEMENTED;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetCursor(nsCursor aCursor)
 16807: {
 59841:     if (mCursor == aCursor)
 59841:         return NS_OK;
 59841: 
 16807:     mCursor = aCursor;
 30337:     if (mWidget)
 30337:         mWidget->SetCursor(mCursor);
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetCursor(imgIContainer* aCursor,
108991:                     uint32_t aHotspotX, uint32_t aHotspotY)
 16807: {
 38147:     return NS_ERROR_NOT_AVAILABLE;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 87336: nsWindow::Invalidate(const nsIntRect &aRect)
 16807: {
 87336:     LOGDRAW(("Invalidate (rect) [%p,%p]: %d %d %d %d\n", (void *)this,
 87336:              (void*)mWidget,aRect.x, aRect.y, aRect.width, aRect.height));
 30337: 
 30337:     if (!mWidget)
 16807:         return NS_OK;
 16807: 
 39841:     mDirtyScrollArea = mDirtyScrollArea.united(QRect(aRect.x, aRect.y, aRect.width, aRect.height));
 39841: 
 30337:     mWidget->update(aRect.x, aRect.y, aRect.width, aRect.height);
 38147: 
 16807:     return NS_OK;
 16807: }
 16807: 
 39016: // Returns the graphics view widget for this nsWindow by iterating
 39016: // the chain of parents until a toplevel window with a view/scene is found.
 39016: // (This function always returns something or asserts if the precondition
 39016: // is not met)
 38147: QWidget* nsWindow::GetViewWidget()
 38147: {
 39016:     NS_ASSERTION(mWidget, "Calling GetViewWidget without mWidget created");
 51211:     if (!mWidget || !mWidget->scene() || !mWidget->scene()->views().size())
106838:         return nullptr;
 38147: 
 39016:     NS_ASSERTION(mWidget->scene()->views().size() == 1, "Not exactly one view for our scene!");
 39016:     return mWidget->scene()->views()[0];
 38147: }
 38147: 
 16807: void*
108991: nsWindow::GetNativeData(uint32_t aDataType)
 16807: {
 16807:     switch (aDataType) {
 16807:     case NS_NATIVE_WINDOW:
 16807:     case NS_NATIVE_WIDGET: {
 30337:         if (!mWidget)
106838:             return nullptr;
 16807: 
 30337:         return mWidget;
 16807:         break;
 16807:     }
 16807: 
 16807:     case NS_NATIVE_PLUGIN_PORT:
 16807:         return SetupPluginPort();
 16807:         break;
 16807: 
 16807:     case NS_NATIVE_DISPLAY:
 39505:         {
 77137: #ifdef MOZ_X11
 94111:             return gfxQtPlatform::GetXDisplay(GetViewWidget());
 77137: #else
106838:             return nullptr;
 77137: #endif
 39505:         }
 16807:         break;
 16807: 
 16807:     case NS_NATIVE_GRAPHIC: {
106838:         return nullptr;
 16807:         break;
 16807:     }
 16807: 
 46147:     case NS_NATIVE_SHELLWIDGET: {
106838:         QWidget* widget = nullptr;
 46147:         if (mWidget && mWidget->scene())
 46147:             widget = mWidget->scene()->views()[0]->viewport();
 46147:         return (void *) widget;
 46147:     }
 77658: 
 77658:     case NS_NATIVE_SHAREABLE_WINDOW: {
 77658:         QWidget *widget = GetViewWidget();
106838:         return widget ? (void*)widget->winId() : nullptr;
 77658:     }
 77658: 
 16807:     default:
 16807:         NS_WARNING("nsWindow::GetNativeData called with bad value");
106838:         return nullptr;
 16807:     }
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetTitle(const nsAString& aTitle)
 16807: {
 16957:     QString qStr(QString::fromUtf16(aTitle.BeginReading(), aTitle.Length()));
 39446:     if (mIsTopLevel) {
 39446:         QWidget *widget = GetViewWidget();
 39446:         if (widget)
 39446:             widget->setWindowTitle(qStr);
 39446:     }
 38147:     else if (mWidget)
 30337:         mWidget->setWindowTitle(qStr);
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetIcon(const nsAString& aIconSpec)
 16807: {
 30337:     if (!mWidget)
 16807:         return NS_OK;
 16807: 
101111:     nsCOMPtr<nsIFile> iconFile;
110974:     nsAutoCString path;
 24031:     nsTArray<nsCString> iconList;
 16807: 
 16807:     // Look for icons with the following suffixes appended to the base name.
 16807:     // The last two entries (for the old XPM format) will be ignored unless
 16807:     // no icons are found using the other suffixes. XPM icons are depricated.
 16807: 
 16807:     const char extensions[6][7] = { ".png", "16.png", "32.png", "48.png",
 16807:                                     ".xpm", "16.xpm" };
 16807: 
108991:     for (uint32_t i = 0; i < ArrayLength(extensions); i++) {
 16807:         // Don't bother looking for XPM versions if we found a PNG.
 80467:         if (i == ArrayLength(extensions) - 2 && iconList.Length())
 16807:             break;
 16807: 
 16807:         nsAutoString extension;
 16807:         extension.AppendASCII(extensions[i]);
 16807: 
 16807:         ResolveIconName(aIconSpec, extension, getter_AddRefs(iconFile));
 16807:         if (iconFile) {
 16807:             iconFile->GetNativePath(path);
 24031:             iconList.AppendElement(path);
 16807:         }
 16807:     }
 16807: 
 16807:     // leave the default icon intact if no matching icons were found
 24031:     if (iconList.Length() == 0)
 16807:         return NS_OK;
 16807: 
 16807:     return SetWindowIconList(iconList);
 16807: }
 16807: 
 25183: nsIntPoint
 25183: nsWindow::WidgetToScreenOffset()
 16807: {
 30337:     NS_ENSURE_TRUE(mWidget, nsIntPoint(0,0));
 25183: 
 38147:     QPointF origin(0, 0);
 38147:     origin = mWidget->mapToScene(origin);
 16884: 
 25183:     return nsIntPoint(origin.x(), origin.y());
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 79445: nsWindow::EnableDragDrop(bool aEnable)
 16807: {
 30337:     mWidget->setAcceptDrops(aEnable);
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 79445: nsWindow::CaptureMouse(bool aCapture)
 16807: {
 16807:     LOG(("CaptureMouse %p\n", (void *)this));
 16807: 
 30337:     if (!mWidget)
 16807:         return NS_OK;
 39446: 
 39446:     QWidget *widget = GetViewWidget();
 39446:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 39446: 
 16888:     if (aCapture)
 39446:         widget->grabMouse();
 16888:     else
 39446:         widget->releaseMouse();
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 16807: nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
120177:                               bool               aDoCapture)
 16807: {
 30337:     if (!mWidget)
 16807:         return NS_OK;
 16807: 
 16807:     LOG(("CaptureRollupEvents %p\n", (void *)this));
 16961: 
120177:     gRollupListener = aDoCapture ? aListener : nullptr;
 16807:     return NS_OK;
 16807: }
 16807: 
 79445: bool
120177: nsWindow::CheckForRollup(double aMouseX, double aMouseY,
 79445:                          bool aIsWheel)
 16961: {
123327:     nsIRollupListener* rollupListener = GetActiveRollupListener();
123327:     nsCOMPtr<nsIWidget> rollupWidget;
123327:     if (rollupListener) {
123327:         rollupWidget = rollupListener->GetRollupWidget();
123327:     }
123327:     if (!rollupWidget) {
123327:         nsBaseWidget::gRollupListener = nullptr;
123327:         return false;
123327:     }
123327: 
 79445:     bool retVal = false;
 38147:         MozQWidget *currentPopup =
 38147:             (MozQWidget *)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 16961:         if (!is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
 79445:             bool rollup = true;
 16961:             if (aIsWheel) {
120177:                 rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
 80486:                 retVal = true;
 16961:             }
 16961:             // if we're dealing with menus, we probably have submenus and
 16961:             // we don't want to rollup if the clickis in a parent menu of
 16961:             // the current submenu
115367:             uint32_t popupsToRollup = UINT32_MAX;
120177:             if (rollupListener) {
 16961:                 nsAutoTArray<nsIWidget*, 5> widgetChain;
120177:                 uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
108991:                 for (uint32_t i=0; i<widgetChain.Length(); ++i) {
 16961:                     nsIWidget* widget =  widgetChain[i];
 38147:                     MozQWidget* currWindow =
 38147:                         (MozQWidget*) widget->GetNativeData(NS_NATIVE_WINDOW);
 16961:                     if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
 29148:                       if (i < sameTypeCount) {
 80486:                         rollup = false;
 29148:                       }
 29148:                       else {
 29148:                         popupsToRollup = sameTypeCount;
 29148:                       }
 16961:                       break;
 16961:                     }
 16961:                 } // foreach parent menu widget
 16961:             } // if rollup listener knows about menus
 16961: 
 16961:             // if we've determined that we should still rollup, do it.
 16961:             if (rollup) {
120177:                 retVal = rollupListener->Rollup(popupsToRollup, nullptr);
 16961:             }
 16961:         }
 16961: 
 16961:     return retVal;
 16961: }
 16961: 
 16961: /* static */
 38147: bool
 38147: is_mouse_in_window (MozQWidget* aWindow, double aMouseX, double aMouseY)
 16961: {
 38147:     return aWindow->geometry().contains( aMouseX, aMouseY );
 16961: }
 16961: 
 16807: NS_IMETHODIMP
108991: nsWindow::GetAttention(int32_t aCycleCount)
 16807: {
 16807:     LOG(("nsWindow::GetAttention [%p]\n", (void *)this));
 38147:     return NS_ERROR_NOT_IMPLEMENTED;
 16807: }
 16807: 
 56628: #ifdef MOZ_X11
 56628: static already_AddRefed<gfxASurface>
 56628: GetSurfaceForQWidget(QWidget* aDrawable)
 56628: {
 56628:     gfxASurface* result =
 94111:         new gfxXlibSurface(gfxQtPlatform::GetXDisplay(aDrawable),
 94111:                            aDrawable->winId(),
 94111:                            DefaultVisualOfScreen(gfxQtPlatform::GetXScreen(aDrawable)),
 56628:                            gfxIntSize(aDrawable->size().width(),
 56628:                            aDrawable->size().height()));
 56628:     NS_IF_ADDREF(result);
 56628:     return result;
 56628: }
 56628: #endif
 56628: 
108457: bool
 56628: nsWindow::DoPaint(QPainter* aPainter, const QStyleOptionGraphicsItem* aOption, QWidget* aWidget)
 16807: {
 16807:     if (mIsDestroyed) {
 16807:         LOG(("Expose event on destroyed window [%p] window %p\n",
 30337:              (void *)this, mWidget));
108457:         return false;
108457:     }
108457: 
108457:     // Call WillPaintWindow to allow scripts etc. to run before we paint
 93518:     {
108457:         if (mWidgetListener)
108457:             mWidgetListener->WillPaintWindow(this, true);
 93518:     }
 93518: 
 30337:     if (!mWidget)
108457:         return false;
 16807: 
 38147:     QRectF r;
 38147:     if (aOption)
 38147:         r = aOption->exposedRect;
 38147:     else
 38147:         r = mWidget->boundingRect();
 16807: 
 39232:     if (r.isEmpty())
 39232:         return nsEventStatus_eIgnore;
 39232: 
 39046:     if (!mDirtyScrollArea.isEmpty())
 38726:         mDirtyScrollArea = QRegion();
 16807: 
108457:     bool painted = false;
 46147:     nsIntRect rect(r.x(), r.y(), r.width(), r.height());
 46147: 
 81001:     nsFastStartup* startup = nsFastStartup::GetSingleton();
 81001:     if (startup) {
 81001:         startup->RemoveFakeLayout();
 81001:     }
 81001: 
106838:     if (GetLayerManager(nullptr)->GetBackendType() == mozilla::layers::LAYERS_OPENGL) {
 93518:         aPainter->beginNativePainting();
108457:         nsIntRegion region(rect);
106838:         static_cast<mozilla::layers::LayerManagerOGL*>(GetLayerManager(nullptr))->
108457:             SetClippingRegion(region);
 63422: 
 63422:         gfxMatrix matr;
 63422:         matr.Translate(gfxPoint(aPainter->transform().dx(), aPainter->transform().dy()));
 63422: #ifdef MOZ_ENABLE_QTMOBILITY
 63422:         // This is needed for rotate transformation on MeeGo
 63422:         // This will work very slow if pixman does not handle rotation very well
 63422:         matr.Rotate((M_PI/180) * gOrientationFilter.GetWindowRotationAngle());
106838:         static_cast<mozilla::layers::LayerManagerOGL*>(GetLayerManager(nullptr))->
 63422:             SetWorldTransform(matr);
 63422: #endif //MOZ_ENABLE_QTMOBILITY
 63422: 
108457:         if (mWidgetListener)
118895:           painted = mWidgetListener->PaintWindow(this, region, nsIWidgetListener::SENT_WILL_PAINT | nsIWidgetListener::WILL_SEND_DID_PAINT);
 93518:         aPainter->endNativePainting();
108457:         if (mWidgetListener)
108457:           mWidgetListener->DidPaintWindow();
108457:         return painted;
 46147:     }
 46147: 
 38320:     gfxQtPlatform::RenderMode renderMode = gfxQtPlatform::GetPlatform()->GetRenderMode();
 40747:     int depth = aPainter->device()->depth();
 42185: 
106838:     nsRefPtr<gfxASurface> targetSurface = nullptr;
 42185:     if (renderMode == gfxQtPlatform::RENDER_BUFFERED) {
 42185:         // Prepare offscreen buffers iamge or xlib, depends from paintEngineType
 43497:         if (!UpdateOffScreenBuffers(depth, QSize(r.width(), r.height())))
108457:             return false;
 38320: 
 43497:         targetSurface = gBufferSurface;
 42185: 
 54932: #ifdef CAIRO_HAS_QT_SURFACE
 38320:     } else if (renderMode == gfxQtPlatform::RENDER_QPAINTER) {
 38320:         targetSurface = new gfxQPainterSurface(aPainter);
 54932: #endif
 56628:     } else if (renderMode == gfxQtPlatform::RENDER_DIRECT) {
 56628:         if (!UpdateOffScreenBuffers(depth, aWidget->size(), aWidget)) {
108457:             return false;
 56628:         }
 56628:         targetSurface = gBufferSurface;
 38320:     }
 38320: 
120353:     if (MOZ_UNLIKELY(!targetSurface))
108457:         return false;
 38320: 
 16842:     nsRefPtr<gfxContext> ctx = new gfxContext(targetSurface);
 16842: 
 39232:     // We will paint to 0, 0 position in offscrenn buffer
 56628:     if (renderMode == gfxQtPlatform::RENDER_BUFFERED) {
 39232:         ctx->Translate(gfxPoint(-r.x(), -r.y()));
 56628:     }
 60918:     else if (renderMode == gfxQtPlatform::RENDER_DIRECT) {
 60918:       gfxMatrix matr;
 60918:       matr.Translate(gfxPoint(aPainter->transform().dx(), aPainter->transform().dy()));
 63422: #ifdef MOZ_ENABLE_QTMOBILITY
 63422:          // This is needed for rotate transformation on MeeGo
 63422:          // This will work very slow if pixman does not handle rotation very well
 63422:          matr.Rotate((M_PI/180) * gOrientationFilter.GetWindowRotationAngle());
 63422:          NS_ASSERTION(PIXMAN_VERSION > PIXMAN_VERSION_ENCODE(0, 21, 2) ||
 63422:                       !gOrientationFilter.GetWindowRotationAngle(),
 63422:                       "Old pixman and rotate transform, it is going to be slow");
 63422: #endif //MOZ_ENABLE_QTMOBILITY
 63422: 
 60918:       ctx->SetMatrix(matr);
 58013:     }
 39232: 
 38805:     {
 47746:         AutoLayerManagerSetup
106914:             setupLayerManager(this, ctx, mozilla::layers::BUFFER_NONE);
108457:         if (mWidgetListener) {
108457:           nsIntRegion region(rect);
118895:           painted = mWidgetListener->PaintWindow(this, region, nsIWidgetListener::SENT_WILL_PAINT | nsIWidgetListener::WILL_SEND_DID_PAINT);
108457:         }
 38805:     }
 16807: 
 16807:     // DispatchEvent can Destroy us (bug 378273), avoid doing any paint
 16807:     // operations below if that happened - it will lead to XError and exit().
120353:     if (MOZ_UNLIKELY(mIsDestroyed))
108457:         return painted;
108457: 
108457:     if (!painted)
108457:         return false;
 16888: 
 16888:     LOGDRAW(("[%p] draw done\n", this));
 16888: 
 42185:     // Handle buffered painting mode
 42185:     if (renderMode == gfxQtPlatform::RENDER_BUFFERED) {
 94111: #if defined(MOZ_X11) && defined(Q_WS_X11)
 43497:         if (gBufferSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
 40747:             // Paint offscreen pixmap to QPainter
 43497:             static QPixmap gBufferPixmap;
 43497:             Drawable draw = static_cast<gfxXlibSurface*>(gBufferSurface.get())->XDrawable();
 43497:             if (gBufferPixmap.handle() != draw)
 43497:                 gBufferPixmap = QPixmap::fromX11Pixmap(draw, QPixmap::ExplicitlyShared);
 43497:             XSync(static_cast<gfxXlibSurface*>(gBufferSurface.get())->XDisplay(), False);
 43497:             aPainter->drawPixmap(QPoint(rect.x, rect.y), gBufferPixmap,
 39507:                                  QRect(0, 0, rect.width, rect.height));
 40747: 
 77137:         } else
 77137: #endif
 77137:         if (gBufferSurface->GetType() == gfxASurface::SurfaceTypeImage) {
 38726:             // in raster mode we can just wrap gBufferImage as QImage and paint directly
 43497:             gfxImageSurface *imgs = static_cast<gfxImageSurface*>(gBufferSurface.get());
 43497:             QImage img(imgs->Data(),
 43497:                        imgs->Width(),
 43497:                        imgs->Height(),
 43497:                        imgs->Stride(),
 43497:                        _gfximage_to_qformat(imgs->Format()));
 38726:             aPainter->drawImage(QPoint(rect.x, rect.y), img,
 39232:                                 QRect(0, 0, rect.width, rect.height));
 38726:         }
 56628:     } else if (renderMode == gfxQtPlatform::RENDER_DIRECT) {
 56628:         QRect trans = aPainter->transform().mapRect(r).toRect();
 77137: #ifdef MOZ_X11
 56628:         if (gBufferSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
 56628:             nsRefPtr<gfxASurface> widgetSurface = GetSurfaceForQWidget(aWidget);
 56628:             nsRefPtr<gfxContext> ctx = new gfxContext(widgetSurface);
 56628:             ctx->SetSource(gBufferSurface);
 80486:             ctx->Rectangle(gfxRect(trans.x(), trans.y(), trans.width(), trans.height()), true);
 56628:             ctx->Clip();
 56628:             ctx->Fill();
 77137:         } else
 77137: #endif
 77137:         if (gBufferSurface->GetType() == gfxASurface::SurfaceTypeImage) {
 56628: #ifdef MOZ_HAVE_SHMIMAGE
 56628:             if (gShmImage) {
 56628:                 gShmImage->Put(aWidget, trans);
 56628:             } else
 56628: #endif
 77137:             {
 77137:                 // Qt should take care about optimized rendering on QImage into painter device (gl/fb/image et.c.)
 77137:                 gfxImageSurface *imgs = static_cast<gfxImageSurface*>(gBufferSurface.get());
 77137:                 QImage img(imgs->Data(),
 77137:                            imgs->Width(),
 77137:                            imgs->Height(),
 77137:                            imgs->Stride(),
 77137:                           _gfximage_to_qformat(imgs->Format()));
 77137:                 aPainter->drawImage(trans, img, trans);
 56628:             }
 56628:         }
 38726:     }
 38320: 
106838:     ctx = nullptr;
106838:     targetSurface = nullptr;
108457:     if (mWidgetListener)
108457:       mWidgetListener->DidPaintWindow();
 16807: 
 16807:     // check the return value!
108457:     return painted;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnMoveEvent(QGraphicsSceneHoverEvent *aEvent)
 16807: {
 16807:     LOG(("configure event [%p] %d %d\n", (void *)this,
 16807:         aEvent->pos().x(),  aEvent->pos().y()));
 16807: 
 16807:     // can we shortcut?
108457:     if (!mWidget || !mWidgetListener)
 16916:         return nsEventStatus_eIgnore;
 16916: 
 16916:     if ((mBounds.x == aEvent->pos().x() &&
 16916:          mBounds.y == aEvent->pos().y()))
 16884:     {
 16884:         return nsEventStatus_eIgnore;
 16884:     }
 16807: 
108457:     bool moved = mWidgetListener->WindowMoved(this, aEvent->pos().x(), aEvent->pos().y());
108457:     return moved ? nsEventStatus_eConsumeNoDefault : nsEventStatus_eIgnore;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnResizeEvent(QGraphicsSceneResizeEvent *aEvent)
 16807: {
 24924:     nsIntRect rect;
 16807: 
 16807:     // Generate XPFE resize event
 16807:     GetBounds(rect);
 16807: 
 38147:     rect.width = aEvent->newSize().width();
 38147:     rect.height = aEvent->newSize().height();
 16807: 
 16807:     mBounds.width = rect.width;
 16807:     mBounds.height = rect.height;
 16807: 
 16807:     nsEventStatus status;
 16807:     DispatchResizeEvent(rect, status);
 16884:     return status;
 16807: }
 16807: 
 16884: nsEventStatus
 16916: nsWindow::OnCloseEvent(QCloseEvent *aEvent)
 16807: {
108457:     if (!mWidgetListener)
108457:         return nsEventStatus_eIgnore;
108457:     mWidgetListener->RequestWindowClose(this);
108457:     return nsEventStatus_eConsumeNoDefault;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnEnterNotifyEvent(QGraphicsSceneHoverEvent *aEvent)
 16807: {
 80486:     nsMouseEvent event(true, NS_MOUSE_ENTER, this, nsMouseEvent::eReal);
 16807: 
 38147:     event.refPoint.x = nscoord(aEvent->pos().x());
 38147:     event.refPoint.y = nscoord(aEvent->pos().y());
 16807: 
 16807:     LOG(("OnEnterNotify: %p\n", (void *)this));
 16807: 
 16884:     return DispatchEvent(&event);
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnLeaveNotifyEvent(QGraphicsSceneHoverEvent *aEvent)
 16807: {
 80486:     nsMouseEvent event(true, NS_MOUSE_EXIT, this, nsMouseEvent::eReal);
 16807: 
 38147:     event.refPoint.x = nscoord(aEvent->pos().x());
 38147:     event.refPoint.y = nscoord(aEvent->pos().y());
 16807: 
 16807:     LOG(("OnLeaveNotify: %p\n", (void *)this));
 16807: 
 16884:     return DispatchEvent(&event);
 16807: }
 16807: 
 55246: // Block the mouse events if user was recently executing gestures;
 55246: // otherwise there will be also some panning during/after gesture
 55246: #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 55246: #define CHECK_MOUSE_BLOCKED { \
 55246: if (mLastMultiTouchTime.isValid()) { \
 55246:     if (mLastMultiTouchTime.elapsed() < GESTURES_BLOCK_MOUSE_FOR) \
 55246:         return nsEventStatus_eIgnore; \
 55246:     else \
 55246:         mLastMultiTouchTime = QTime(); \
 55246:    } \
 55246: }
 55246: #else
 55246: define CHECK_MOUSE_BLOCKED {}
 55246: #endif
 55246: 
 16884: nsEventStatus
 61879: nsWindow::OnMotionNotifyEvent(QPointF aPos,  Qt::KeyboardModifiers aModifiers)
 16807: {
 55246:     UserActivity();
 55246: 
 55246:     CHECK_MOUSE_BLOCKED
 39368: 
 61879:     mMoveEvent.pos = aPos;
 61879:     mMoveEvent.modifiers = aModifiers;
 60755:     mMoveEvent.needDispatch = true;
 60755:     DispatchMotionToMainThread();
 60755: 
 60755:     return nsEventStatus_eIgnore;
 16807: }
 16807: 
 16807: void
 38147: nsWindow::InitButtonEvent(nsMouseEvent &aMoveEvent,
 38147:                           QGraphicsSceneMouseEvent *aEvent, int aClickCount)
 16807: {
 38147:     aMoveEvent.refPoint.x = nscoord(aEvent->pos().x());
 38147:     aMoveEvent.refPoint.y = nscoord(aEvent->pos().y());
 16807: 
 96893:     aMoveEvent.InitBasicModifiers(aEvent->modifiers() & Qt::ControlModifier,
 96893:                                   aEvent->modifiers() & Qt::AltModifier,
 96893:                                   aEvent->modifiers() & Qt::ShiftModifier,
 96893:                                   aEvent->modifiers() & Qt::MetaModifier);
 38147:     aMoveEvent.clickCount      = aClickCount;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnButtonPressEvent(QGraphicsSceneMouseEvent *aEvent)
 16807: {
 40944:     // The user has done something.
 40944:     UserActivity();
 40944: 
 55246:     CHECK_MOUSE_BLOCKED
 55246: 
 38147:     QPointF pos = aEvent->pos();
 38147: 
 38147:     // we check against the widgets geometry, so use parent coordinates
 38147:     // for the check
 38147:     if (mWidget)
 38147:         pos = mWidget->mapToParent(pos);
 38147: 
120177:     if (CheckForRollup( pos.x(), pos.y(), false))
 16961:         return nsEventStatus_eIgnore;
 16961: 
108991:     uint16_t      domButton;
 16807:     switch (aEvent->button()) {
 16807:     case Qt::MidButton:
 16807:         domButton = nsMouseEvent::eMiddleButton;
 16807:         break;
 16807:     case Qt::RightButton:
 16807:         domButton = nsMouseEvent::eRightButton;
 16807:         break;
 16807:     default:
 16807:         domButton = nsMouseEvent::eLeftButton;
 16807:         break;
 16807:     }
 16807: 
 80486:     nsMouseEvent event(true, NS_MOUSE_BUTTON_DOWN, this, nsMouseEvent::eReal);
 16807:     event.button = domButton;
 16807:     InitButtonEvent(event, aEvent, 1);
 16807: 
 16888:     LOG(("%s [%p] button: %d\n", __PRETTY_FUNCTION__, (void*)this, domButton));
 16888: 
 16884:     nsEventStatus status = DispatchEvent(&event);
 16807: 
 16807:     // right menu click on linux should also pop up a context menu
 16807:     if (domButton == nsMouseEvent::eRightButton &&
120353:         MOZ_LIKELY(!mIsDestroyed)) {
 80486:         nsMouseEvent contextMenuEvent(true, NS_CONTEXTMENU, this,
 16807:                                       nsMouseEvent::eReal);
 16812:         InitButtonEvent(contextMenuEvent, aEvent, 1);
 16807:         DispatchEvent(&contextMenuEvent, status);
 16807:     }
 16807: 
 16884:     return status;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnButtonReleaseEvent(QGraphicsSceneMouseEvent *aEvent)
 16807: {
 55246:     UserActivity();
 55246:     CHECK_MOUSE_BLOCKED
 55246: 
 40944:     // The user has done something.
 40944:     UserActivity();
 40944: 
108991:     uint16_t domButton;
 16807: 
 16807:     switch (aEvent->button()) {
 16807:     case Qt::MidButton:
 16807:         domButton = nsMouseEvent::eMiddleButton;
 16807:         break;
 16807:     case Qt::RightButton:
 16807:         domButton = nsMouseEvent::eRightButton;
 16807:         break;
 16807:     default:
 16807:         domButton = nsMouseEvent::eLeftButton;
 16807:         break;
 16807:     }
 16807: 
 16888:     LOG(("%s [%p] button: %d\n", __PRETTY_FUNCTION__, (void*)this, domButton));
 16888: 
 80486:     nsMouseEvent event(true, NS_MOUSE_BUTTON_UP, this, nsMouseEvent::eReal);
 16807:     event.button = domButton;
 16812:     InitButtonEvent(event, aEvent, 1);
 16807: 
 16888:     nsEventStatus status = DispatchEvent(&event);
 16888: 
 16888:     return status;
 16807: }
 16807: 
 16884: nsEventStatus
 41201: nsWindow::OnMouseDoubleClickEvent(QGraphicsSceneMouseEvent *aEvent)
 16807: {
108991:     uint32_t eventType;
 16807: 
 38147:     switch (aEvent->button()) {
 16807:     case Qt::MidButton:
 16807:         eventType = nsMouseEvent::eMiddleButton;
 16807:         break;
 16807:     case Qt::RightButton:
 16807:         eventType = nsMouseEvent::eRightButton;
 16807:         break;
 16807:     default:
 16807:         eventType = nsMouseEvent::eLeftButton;
 16807:         break;
 16807:     }
 16807: 
 80486:     nsMouseEvent event(true, NS_MOUSE_DOUBLECLICK, this, nsMouseEvent::eReal);
 16807:     event.button = eventType;
 16807: 
 38147:     InitButtonEvent(event, aEvent, 2);
 16807:     //pressed
 16884:     return DispatchEvent(&event);
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnFocusInEvent(QEvent *aEvent)
 16807: {
 16916:     LOGFOCUS(("OnFocusInEvent [%p]\n", (void *)this));
 48346: 
 30337:     if (!mWidget)
 16884:         return nsEventStatus_eIgnore;
 16807: 
 48346:     DispatchActivateEventOnTopLevelWindow();
 16807: 
 16807:     LOGFOCUS(("Events sent from focus in event [%p]\n", (void *)this));
 16884:     return nsEventStatus_eIgnore;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnFocusOutEvent(QEvent *aEvent)
 16807: {
 16916:     LOGFOCUS(("OnFocusOutEvent [%p]\n", (void *)this));
 16807: 
 48346:     if (!mWidget)
 48346:         return nsEventStatus_eIgnore;
 48346: 
 51831: #if MOZ_PLATFORM_MAEMO > 5
 51787:     if (((QFocusEvent*)aEvent)->reason() == Qt::OtherFocusReason
 51787:          && mWidget->isVKBOpen()) {
 51787:         // We assume that the VKB was open in this case, because of the focus
 51787:         // reason and clear the focus in the active window.
 51787:         nsCOMPtr<nsIFocusManager> fm = do_GetService("@mozilla.org/focus-manager;1");
 51787:         if (fm) {
 51787:             nsCOMPtr<nsIDOMWindow> domWindow;
 51787:             fm->GetActiveWindow(getter_AddRefs(domWindow));
 51787:             fm->ClearFocus(domWindow);
 51787:         }
 51787: 
 51787:         return nsEventStatus_eIgnore;
 51787:     }
 51787: #endif
 51787: 
 48346:     DispatchDeactivateEventOnTopLevelWindow();
 16807: 
 16807:     LOGFOCUS(("Done with container focus out [%p]\n", (void *)this));
 16884:     return nsEventStatus_eIgnore;
 16807: }
 16807: 
 79445: inline bool
 16807: is_latin_shortcut_key(quint32 aKeyval)
 16807: {
 16807:     return ((Qt::Key_0 <= aKeyval && aKeyval <= Qt::Key_9) ||
 16807:             (Qt::Key_A <= aKeyval && aKeyval <= Qt::Key_Z));
 16807: }
 16807: 
 73807: nsEventStatus
 16807: nsWindow::DispatchCommandEvent(nsIAtom* aCommand)
 16807: {
 80486:     nsCommandEvent event(true, nsGkAtoms::onAppCommand, aCommand, this);
 16884: 
 73807:     nsEventStatus status;
 73807:     DispatchEvent(&event, status);
 73807: 
 73807:     return status;
 73807: }
 73807: 
 73807: nsEventStatus
108991: nsWindow::DispatchContentCommandEvent(int32_t aMsg)
 73807: {
 80486:     nsContentCommandEvent event(true, aMsg, this);
 73807: 
 73807:     nsEventStatus status;
 73807:     DispatchEvent(&event, status);
 73807: 
 73807:     return status;
 16807: }
 16807: 
 16884: nsEventStatus
 16807: nsWindow::OnKeyPressEvent(QKeyEvent *aEvent)
 16807: {
 16807:     LOGFOCUS(("OnKeyPressEvent [%p]\n", (void *)this));
 16807: 
 40944:     // The user has done something.
 40944:     UserActivity();
 40944: 
 79445:     bool setNoDefault = false;
 16807: 
 61584:     if (aEvent->key() == Qt::Key_AltGr) {
 61584:         sAltGrModifier = true;
 61584:     }
 61584: 
 51523: #ifdef MOZ_X11
 16807:     // before we dispatch a key, check if it's the context menu key.
 16807:     // If so, send a context menu key event instead.
 16884:     if (isContextMenuKeyEvent(aEvent)) {
 80486:         nsMouseEvent contextMenuEvent(true, NS_CONTEXTMENU, this,
 16807:                                       nsMouseEvent::eReal,
 16807:                                       nsMouseEvent::eContextMenuKey);
 16884:         //keyEventToContextMenuEvent(&event, &contextMenuEvent);
 16884:         return DispatchEvent(&contextMenuEvent);
 16807:     }
 16884: 
108991:     uint32_t domCharCode = 0;
108991:     uint32_t domKeyCode = QtKeyCodeToDOMKeyCode(aEvent->key());
 16884: 
 51523:     // get keymap and modifier map from the Xserver
 94111:     Display *display = mozilla::DefaultXDisplay();
 51523:     int x_min_keycode = 0, x_max_keycode = 0, xkeysyms_per_keycode;
 51523:     XDisplayKeycodes(display, &x_min_keycode, &x_max_keycode);
 51523:     XModifierKeymap *xmodmap = XGetModifierMapping(display);
 59118:     if (!xmodmap)
 59118:         return nsEventStatus_eIgnore;
 59118: 
 51523:     KeySym *xkeymap = XGetKeyboardMapping(display, x_min_keycode, x_max_keycode - x_min_keycode,
 51523:                                           &xkeysyms_per_keycode);
 59118:     if (!xkeymap) {
 59118:         XFreeModifiermap(xmodmap);
 59118:         return nsEventStatus_eIgnore;
 59118:     }
 51523: 
 51523:     // create modifier masks
 51523:     qint32 shift_mask = 0, shift_lock_mask = 0, caps_lock_mask = 0, num_lock_mask = 0;
 51523: 
 51523:     for (int i = 0; i < 8 * xmodmap->max_keypermod; ++i) {
 51523:         qint32 maskbit = 1 << (i / xmodmap->max_keypermod);
 51523:         KeyCode modkeycode = xmodmap->modifiermap[i];
 51523:         if (modkeycode == NoSymbol) {
 51523:             continue;
 51523:         }
 51523: 
 51523:         quint32 mapindex = (modkeycode - x_min_keycode) * xkeysyms_per_keycode;
 51523:         for (int j = 0; j < xkeysyms_per_keycode; ++j) {
 51523:             KeySym modkeysym = xkeymap[mapindex + j];
 51523:             switch (modkeysym) {
 51523:                 case XK_Num_Lock:
 51523:                     num_lock_mask |= maskbit;
 51523:                     break;
 51523:                 case XK_Caps_Lock:
 51523:                     caps_lock_mask |= maskbit;
 51523:                     break;
 51523:                 case XK_Shift_Lock:
 51523:                     shift_lock_mask |= maskbit;
 51523:                     break;
 51523:                 case XK_Shift_L:
 51523:                 case XK_Shift_R:
 51523:                     shift_mask |= maskbit;
 51523:                     break;
 51523:             }
 51523:         }
 51523:     }
 51523:     // indicate whether is down or not
 79445:     bool shift_state = ((shift_mask & aEvent->nativeModifiers()) != 0) ^
 51523:                           (bool)(shift_lock_mask & aEvent->nativeModifiers());
 79445:     bool capslock_state = (bool)(caps_lock_mask & aEvent->nativeModifiers());
 51523: 
 51523:     // try to find a keysym that we can translate to a DOMKeyCode
 51523:     // this is needed because some of Qt's keycodes cannot be translated
 51523:     // TODO: use US keyboard keymap instead of localised keymap
 51523:     if (!domKeyCode &&
 51523:         aEvent->nativeScanCode() >= (quint32)x_min_keycode &&
 51523:         aEvent->nativeScanCode() <= (quint32)x_max_keycode) {
 51523:         int index = (aEvent->nativeScanCode() - x_min_keycode) * xkeysyms_per_keycode;
 51523:         for(int i = 0; (i < xkeysyms_per_keycode) && (domKeyCode == (quint32)NoSymbol); ++i) {
 51523:             domKeyCode = QtKeyCodeToDOMKeyCode(xkeymap[index + i]);
 51523:         }
 51523:     }
 51523: 
 51523:     // store character in domCharCode
 16884:     if (aEvent->text().length() && aEvent->text()[0].isPrint())
108991:         domCharCode = (int32_t) aEvent->text()[0].unicode();
 16884: 
 16884:     // If the key isn't autorepeat, we need to send the initial down event
 16884:     if (!aEvent->isAutoRepeat() && !IsKeyDown(domKeyCode)) {
 16884:         // send the key down event
 16884: 
 16884:         SetKeyDownFlag(domKeyCode);
 16884: 
 80486:         nsKeyEvent downEvent(true, NS_KEY_DOWN, this);
 16884:         InitKeyEvent(downEvent, aEvent);
 16884: 
 41166:         downEvent.keyCode = domKeyCode;
 16884: 
 16884:         nsEventStatus status = DispatchEvent(&downEvent);
 16884: 
 51523:         // DispatchEvent can Destroy us (bug 378273)
120353:         if (MOZ_UNLIKELY(mIsDestroyed)) {
 51523:             qWarning() << "Returning[" << __LINE__ << "]: " << "Window destroyed";
 51523:             return status;
 51523:         }
 51523: 
 16884:         // If prevent default on keydown, do same for keypress
 16884:         if (status == nsEventStatus_eConsumeNoDefault)
 80486:             setNoDefault = true;
 16884:     }
 16884: 
 51523:     // Don't pass modifiers as NS_KEY_PRESS events.
 51523:     // Instead of selectively excluding some keys from NS_KEY_PRESS events,
 51523:     // we instead selectively include (as per MSDN spec
 51523:     // ( http://msdn.microsoft.com/en-us/library/system.windows.forms.control.keypress%28VS.71%29.aspx );
 51523:     // no official spec covers KeyPress events).
 51523:     if (aEvent->key() == Qt::Key_Shift   ||
 51523:         aEvent->key() == Qt::Key_Control ||
 51523:         aEvent->key() == Qt::Key_Meta    ||
 51523:         aEvent->key() == Qt::Key_Alt     ||
 51523:         aEvent->key() == Qt::Key_AltGr) {
 51523: 
 51523:         return setNoDefault ?
 51523:             nsEventStatus_eConsumeNoDefault :
 51523:             nsEventStatus_eIgnore;
 51523:     }
 51523: 
 73807:     // Look for specialized app-command keys
 73807:     switch (aEvent->key()) {
 73807:         case Qt::Key_Back:
 80435:             return DispatchCommandEvent(nsGkAtoms::Back);
 73807:         case Qt::Key_Forward:
 80435:             return DispatchCommandEvent(nsGkAtoms::Forward);
 73807:         case Qt::Key_Refresh:
 80435:             return DispatchCommandEvent(nsGkAtoms::Reload);
 73807:         case Qt::Key_Stop:
 80435:             return DispatchCommandEvent(nsGkAtoms::Stop);
 73807:         case Qt::Key_Search:
 80435:             return DispatchCommandEvent(nsGkAtoms::Search);
 73807:         case Qt::Key_Favorites:
 80435:             return DispatchCommandEvent(nsGkAtoms::Bookmarks);
 73807:         case Qt::Key_HomePage:
 80435:             return DispatchCommandEvent(nsGkAtoms::Home);
 73807:         case Qt::Key_Copy:
 73807:         case Qt::Key_F16: // F16, F20, F18, F14 are old keysyms for Copy Cut Paste Undo
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_COPY);
 73807:         case Qt::Key_Cut:
 73807:         case Qt::Key_F20:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_CUT);
 73807:         case Qt::Key_Paste:
 73807:         case Qt::Key_F18:
 73807:         case Qt::Key_F9:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_PASTE);
 73807:         case Qt::Key_F14:
 73807:             return DispatchContentCommandEvent(NS_CONTENT_COMMAND_UNDO);
 73807:     }
 73807: 
 73807:     // Qt::Key_Redo and Qt::Key_Undo are not available yet.
 73807:     if (aEvent->nativeVirtualKey() == 0xff66) {
 73807:         return DispatchContentCommandEvent(NS_CONTENT_COMMAND_REDO);
 73807:     }
 73807:     if (aEvent->nativeVirtualKey() == 0xff65) {
 73807:         return DispatchContentCommandEvent(NS_CONTENT_COMMAND_UNDO);
 73807:     }
 73807: 
 80486:     nsKeyEvent event(true, NS_KEY_PRESS, this);
 16884:     InitKeyEvent(event, aEvent);
 16884: 
 51523:     // If prevent default on keydown, do same for keypress
 51523:     if (setNoDefault) {
 51523:         event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 51523:     }
 51523: 
 51523:     // If there is no charcode attainable from the text, try to
 51523:     // generate it from the keycode. Check shift state for case
 51523:     // Also replace the charcode if ControlModifier is the only
 51523:     // pressed Modifier
 51523:     if ((!domCharCode) &&
 51523:         (QApplication::keyboardModifiers() &
 51523:         (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier))) {
 51523: 
 51523:         // get a character from X11 key map
 51523:         KeySym keysym = aEvent->nativeVirtualKey();
 51523:         if (keysym) {
108991:             domCharCode = (uint32_t) keysym2ucs(keysym);
 51523:             if (domCharCode == -1 || !QChar((quint32)domCharCode).isPrint()) {
 51523:                 domCharCode = 0;
 51523:             }
 51523:         }
 51523: 
 51523:         // if Ctrl is pressed and domCharCode is not a ASCII character
 51523:         if (domCharCode > 0xFF && (QApplication::keyboardModifiers() & Qt::ControlModifier)) {
 51523:             // replace Unicode character
 51523:             int index = (aEvent->nativeScanCode() - x_min_keycode) * xkeysyms_per_keycode;
 51523:             for (int i = 0; i < xkeysyms_per_keycode; ++i) {
 51523:                 if (xkeymap[index + i] <= 0xFF && !shift_state) {
108991:                     domCharCode = (uint32_t) QChar::toLower((uint) xkeymap[index + i]);
 51523:                     break;
 51523:                 }
 51523:             }
 51523:         }
 51523: 
 51523:     } else { // The key event should cause a character input.
 51523:              // At that time, we need to reset the modifiers
 51523:              // because nsEditor will not accept a key event
 51523:              // for text input if one or more modifiers are set.
 96893:         event.modifiers &= ~(widget::MODIFIER_CONTROL |
 96893:                              widget::MODIFIER_ALT |
 96893:                              widget::MODIFIER_META);
 51523:     }
 51523: 
 51523:     KeySym keysym = NoSymbol;
 51523:     int index = (aEvent->nativeScanCode() - x_min_keycode) * xkeysyms_per_keycode;
 51523:     for (int i = 0; i < xkeysyms_per_keycode; ++i) {
 51523:         if (xkeymap[index + i] == aEvent->nativeVirtualKey()) {
 51523:             if ((i % 2) == 0) { // shifted char
 51523:                 keysym = xkeymap[index + i + 1];
 51523:                 break;
 51523:             } else { // unshifted char
 51523:                 keysym = xkeymap[index + i - 1];
 51523:                 break;
 51523:             }
 51523:         }
 51523:         if (xkeysyms_per_keycode - 1 == i) {
 51523:             qWarning() << "Symbol '" << aEvent->nativeVirtualKey() << "' not found";
 51523:         }
 51523:     }
 51523:     QChar unshiftedChar(domCharCode);
 51523:     long ucs = keysym2ucs(keysym);
 51523:     ucs = ucs == -1 ? 0 : ucs;
 51523:     QChar shiftedChar((uint)ucs);
 51523: 
 51523:     // append alternativeCharCodes if modifier is pressed
 51523:     // append an additional alternativeCharCodes if domCharCode is not a Latin character
 51523:     // and if one of these modifiers is pressed (i.e. Ctrl, Alt, Meta)
 51523:     if (domCharCode &&
 51523:         (QApplication::keyboardModifiers() &
 51523:         (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier))) {
 51523: 
 16884:         event.charCode = domCharCode;
 51523:         event.keyCode = 0;
 51523:         nsAlternativeCharCode altCharCode(0, 0);
 51523:         // if character has a lower and upper representation
 51523:         if ((unshiftedChar.isUpper() || unshiftedChar.isLower()) &&
 51523:             unshiftedChar.toLower() == shiftedChar.toLower()) {
 51523:             if (shift_state ^ capslock_state) {
108991:                 altCharCode.mUnshiftedCharCode = (uint32_t) QChar::toUpper((uint)domCharCode);
108991:                 altCharCode.mShiftedCharCode = (uint32_t) QChar::toLower((uint)domCharCode);
 51523:             } else {
108991:                 altCharCode.mUnshiftedCharCode = (uint32_t) QChar::toLower((uint)domCharCode);
108991:                 altCharCode.mShiftedCharCode = (uint32_t) QChar::toUpper((uint)domCharCode);
 51523:             }
 51523:         } else {
108991:             altCharCode.mUnshiftedCharCode = (uint32_t) unshiftedChar.unicode();
108991:             altCharCode.mShiftedCharCode = (uint32_t) shiftedChar.unicode();
 51523:         }
 51523: 
 51523:         // append alternative char code to event
 51523:         if ((altCharCode.mUnshiftedCharCode && altCharCode.mUnshiftedCharCode != domCharCode) ||
 51523:             (altCharCode.mShiftedCharCode && altCharCode.mShiftedCharCode != domCharCode)) {
 51523:             event.alternativeCharCodes.AppendElement(altCharCode);
 51523:         }
 51523: 
 51523:         // check if the alternative char codes are latin-1
 51523:         if (altCharCode.mUnshiftedCharCode > 0xFF || altCharCode.mShiftedCharCode > 0xFF) {
 51523:             altCharCode.mUnshiftedCharCode = altCharCode.mShiftedCharCode = 0;
 51523: 
 51523:             // find latin char for keycode
 51523:             KeySym keysym = NoSymbol;
 51523:             int index = (aEvent->nativeScanCode() - x_min_keycode) * xkeysyms_per_keycode;
 51523:             // find first shifted and unshifted Latin-Char in XKeyMap
 51523:             for (int i = 0; i < xkeysyms_per_keycode; ++i) {
 51523:                 keysym = xkeymap[index + i];
 51523:                 if (keysym && keysym <= 0xFF) {
 51523:                     if ((shift_state && (i % 2 == 1)) ||
 51523:                         (!shift_state && (i % 2 == 0))) {
 51523:                         altCharCode.mUnshiftedCharCode = altCharCode.mUnshiftedCharCode ?
 51523:                             altCharCode.mUnshiftedCharCode :
 51523:                             keysym;
 51523:                     } else {
 51523:                         altCharCode.mShiftedCharCode = altCharCode.mShiftedCharCode ?
 51523:                             altCharCode.mShiftedCharCode :
 51523:                             keysym;
 51523:                     }
 51523:                     if (altCharCode.mUnshiftedCharCode && altCharCode.mShiftedCharCode) {
 51523:                         break;
 51523:                     }
 51523:                 }
 51523:             }
 51523: 
 51523:             if (altCharCode.mUnshiftedCharCode || altCharCode.mShiftedCharCode) {
 51523:                 event.alternativeCharCodes.AppendElement(altCharCode);
 51523:             }
 51523:         }
 51523:     } else {
 51523:         event.charCode = domCharCode;
 51523:     }
 51523: 
 51523:     if (xmodmap) {
 51523:         XFreeModifiermap(xmodmap);
 51523:     }
 51523:     if (xkeymap) {
 51523:         XFree(xkeymap);
 51523:     }
 51523: 
 51523:     event.keyCode = domCharCode ? 0 : domKeyCode;
 51523:     // send the key press event
 51523:     return DispatchEvent(&event);
 51523: #else
 51523: 
 51523:     //:TODO: fix shortcuts hebrew for non X11,
 51523:     //see Bug 562195##51
 51523: 
 51523:     // before we dispatch a key, check if it's the context menu key.
 51523:     // If so, send a context menu key event instead.
 51523:     if (isContextMenuKeyEvent(aEvent)) {
 80486:         nsMouseEvent contextMenuEvent(true, NS_CONTEXTMENU, this,
 51523:                                       nsMouseEvent::eReal,
 51523:                                       nsMouseEvent::eContextMenuKey);
 51523:         //keyEventToContextMenuEvent(&event, &contextMenuEvent);
 51523:         return DispatchEvent(&contextMenuEvent);
 51523:     }
 51523: 
108991:     uint32_t domCharCode = 0;
108991:     uint32_t domKeyCode = QtKeyCodeToDOMKeyCode(aEvent->key());
 51523: 
 51523:     if (aEvent->text().length() && aEvent->text()[0].isPrint())
108991:         domCharCode = (int32_t) aEvent->text()[0].unicode();
 51523: 
 51523:     // If the key isn't autorepeat, we need to send the initial down event
 51523:     if (!aEvent->isAutoRepeat() && !IsKeyDown(domKeyCode)) {
 51523:         // send the key down event
 51523: 
 51523:         SetKeyDownFlag(domKeyCode);
 51523: 
 80486:         nsKeyEvent downEvent(true, NS_KEY_DOWN, this);
 51523:         InitKeyEvent(downEvent, aEvent);
 51523: 
 51523:         downEvent.keyCode = domKeyCode;
 51523: 
 51523:         nsEventStatus status = DispatchEvent(&downEvent);
 51523: 
 51523:         // If prevent default on keydown, do same for keypress
 51523:         if (status == nsEventStatus_eConsumeNoDefault)
 80486:             setNoDefault = true;
 80486:     }
 80486: 
 80486:     nsKeyEvent event(true, NS_KEY_PRESS, this);
 51523:     InitKeyEvent(event, aEvent);
 51523: 
 51523:     event.charCode = domCharCode;
 51523: 
 16884:     event.keyCode = domCharCode ? 0 : domKeyCode;
 16884: 
 16884:     if (setNoDefault)
 16884:         event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
 16884: 
 16807:     // send the key press event
 16884:     return DispatchEvent(&event);
 51523: #endif
 51523: }
 16807: 
 16884: nsEventStatus
 16807: nsWindow::OnKeyReleaseEvent(QKeyEvent *aEvent)
 16807: {
 16807:     LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void *)this));
 16807: 
 40944:     // The user has done something.
 40944:     UserActivity();
 40944: 
 16884:     if (isContextMenuKeyEvent(aEvent)) {
 16884:         // er, what do we do here? DoDefault or NoDefault?
 16884:         return nsEventStatus_eConsumeDoDefault;
 16884:     }
 16884: 
108991:     uint32_t domKeyCode = QtKeyCodeToDOMKeyCode(aEvent->key());
 16884: 
 51523: #ifdef MOZ_X11
 51523:     if (!domKeyCode) {
 51523:         // get keymap from the Xserver
 94111:         Display *display = mozilla::DefaultXDisplay();
 51523:         int x_min_keycode = 0, x_max_keycode = 0, xkeysyms_per_keycode;
 51523:         XDisplayKeycodes(display, &x_min_keycode, &x_max_keycode);
 51523:         KeySym *xkeymap = XGetKeyboardMapping(display, x_min_keycode, x_max_keycode - x_min_keycode,
 51523:                                               &xkeysyms_per_keycode);
 51523: 
 51523:         if (aEvent->nativeScanCode() >= (quint32)x_min_keycode &&
 51523:             aEvent->nativeScanCode() <= (quint32)x_max_keycode) {
 51523:             int index = (aEvent->nativeScanCode() - x_min_keycode) * xkeysyms_per_keycode;
 51523:             for(int i = 0; (i < xkeysyms_per_keycode) && (domKeyCode == (quint32)NoSymbol); ++i) {
 51523:                 domKeyCode = QtKeyCodeToDOMKeyCode(xkeymap[index + i]);
 51523:             }
 51523:         }
 51523: 
 51523:         if (xkeymap) {
 51523:             XFree(xkeymap);
 51523:         }
 51523:     }
 51523: #endif // MOZ_X11
 51523: 
 16807:     // send the key event as a key up event
 80486:     nsKeyEvent event(true, NS_KEY_UP, this);
 16807:     InitKeyEvent(event, aEvent);
 16807: 
 61584:     if (aEvent->key() == Qt::Key_AltGr) {
 61584:         sAltGrModifier = false;
 61584:     }
 61584: 
 41166:     event.keyCode = domKeyCode;
 16884: 
 16807:     // unset the key down flag
 16807:     ClearKeyDownFlag(event.keyCode);
 16807: 
 16884:     return DispatchEvent(&event);
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnScrollEvent(QGraphicsSceneWheelEvent *aEvent)
 16807: {
 16807:     // check to see if we should rollup
108073:     WheelEvent wheelEvent(true, NS_WHEEL_WHEEL, this);
108073:     wheelEvent.deltaMode = nsIDOMWheelEvent::DOM_DELTA_LINE;
108073: 
108073:     // negative values for aEvent->delta indicate downward scrolling;
108073:     // this is opposite Gecko usage.
108073:     // TODO: Store the unused delta values due to fraction round and add it
108073:     //       to next event.  The stored values should be reset by other
108073:     //       direction scroll event.
108991:     int32_t delta = (int)(aEvent->delta() / WHEEL_DELTA) * -3;
 16807: 
 16807:     switch (aEvent->orientation()) {
 16807:     case Qt::Vertical:
108073:         wheelEvent.deltaY = wheelEvent.lineOrPageDeltaY = delta;
 16807:         break;
 16807:     case Qt::Horizontal:
108073:         wheelEvent.deltaX = wheelEvent.lineOrPageDeltaX = delta;
 16807:         break;
 16807:     default:
 16807:         Q_ASSERT(0);
 16807:         break;
 16807:     }
 16884: 
108073:     wheelEvent.refPoint.x = nscoord(aEvent->scenePos().x());
108073:     wheelEvent.refPoint.y = nscoord(aEvent->scenePos().y());
108073: 
108073:     wheelEvent.InitBasicModifiers(aEvent->modifiers() & Qt::ControlModifier,
 96893:                                   aEvent->modifiers() & Qt::AltModifier,
 96893:                                   aEvent->modifiers() & Qt::ShiftModifier,
 96893:                                   aEvent->modifiers() & Qt::MetaModifier);
108073:     wheelEvent.time = 0;
108073: 
108073:     return DispatchEvent(&wheelEvent);
 16807: }
 16807: 
 16807: 
 16884: nsEventStatus
 16807: nsWindow::showEvent(QShowEvent *)
 16807: {
 16807:     LOG(("%s [%p]\n", __PRETTY_FUNCTION__,(void *)this));
 80486:     mIsVisible = true;
 16884:     return nsEventStatus_eConsumeDoDefault;
 16807: }
 16807: 
 16884: nsEventStatus
 16807: nsWindow::hideEvent(QHideEvent *)
 16807: {
 16807:     LOG(("%s [%p]\n", __PRETTY_FUNCTION__,(void *)this));
 80486:     mIsVisible = false;
 16884:     return nsEventStatus_eConsumeDoDefault;
 16807: }
 16807: 
 39368: //Gestures are only supported in 4.6.0 >
 39368: #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 79445: nsEventStatus nsWindow::OnTouchEvent(QTouchEvent *event, bool &handled)
 39368: {
 80486:     handled = false;
 39368:     const QList<QTouchEvent::TouchPoint> &touchPoints = event->touchPoints();
 39368: 
 39368:     if (event->type() == QEvent::TouchBegin) {
 80486:         handled = true;
 39368:         for (int i = touchPoints.count() -1; i >= 0; i--) {
 39368:             QPointF fpos = touchPoints[i].pos();
 80486:             nsGestureNotifyEvent gestureNotifyEvent(true, NS_GESTURENOTIFY_EVENT_START, this);
 39368:             gestureNotifyEvent.refPoint = nsIntPoint(fpos.x(), fpos.y());
 39368:             DispatchEvent(&gestureNotifyEvent);
 39368:         }
 39368:     }
 55246:     else if (event->type() == QEvent::TouchEnd) {
 80486:         mGesturesCancelled = false;
 60755:         mPinchEvent.needDispatch = false;
 55246:     }
 55246: 
 60755:     if (touchPoints.count() > 0) {
 60755:         // Remember start touch point in order to use it for
 60755:         // distance calculation in NS_SIMPLE_GESTURE_MAGNIFY_UPDATE
 63420:         mPinchEvent.touchPoint = touchPoints.at(0).pos();
 55246:     }
 39368: 
 39368:     return nsEventStatus_eIgnore;
 39368: }
 39368: 
 55246: nsEventStatus
 79445: nsWindow::OnGestureEvent(QGestureEvent* event, bool &handled) {
 55246: 
 80486:     handled = false;
 55246:     if (mGesturesCancelled) {
 55246:         return nsEventStatus_eIgnore;
 55246:     }
 55246: 
 55246:     nsEventStatus result = nsEventStatus_eIgnore;
 55246: 
 55246:     QGesture* gesture = event->gesture(Qt::PinchGesture);
 55246: 
 55246:     if (gesture) {
 39368:         QPinchGesture* pinch = static_cast<QPinchGesture*>(gesture);
 80486:         handled = true;
 39368: 
 60755:         mPinchEvent.centerPoint =
 55248:             mWidget->mapFromScene(event->mapToGraphicsScene(pinch->centerPoint()));
 60755:         nsIntPoint centerPoint(mPinchEvent.centerPoint.x(),
 60755:                                mPinchEvent.centerPoint.y());
 39368: 
 39368:         if (pinch->state() == Qt::GestureStarted) {
 55246:             event->accept();
 60755:             mPinchEvent.startDistance = DistanceBetweenPoints(mPinchEvent.centerPoint, mPinchEvent.touchPoint) * 2;
 60755:             mPinchEvent.prevDistance = mPinchEvent.startDistance;
 55246:             result = DispatchGestureEvent(NS_SIMPLE_GESTURE_MAGNIFY_START,
 55246:                                           0, 0, centerPoint);
 55246:         }
 55246:         else if (pinch->state() == Qt::GestureUpdated) {
 63419:             mPinchEvent.needDispatch = true;
 60755:             mPinchEvent.delta = 0;
 60755:             DispatchMotionToMainThread();
 60755:         }
 55246:         else if (pinch->state() == Qt::GestureFinished) {
 60755:             double distance = DistanceBetweenPoints(mPinchEvent.centerPoint, mPinchEvent.touchPoint) * 2;
 60755:             double delta = distance - mPinchEvent.startDistance;
 55246:             result = DispatchGestureEvent(NS_SIMPLE_GESTURE_MAGNIFY,
 55246:                                           0, delta, centerPoint);
 60755:             mPinchEvent.needDispatch = false;
 55246:         }
 55246:         else {
 55246:             handled = false;
 55246:         }
 55246: 
 60755:         //Disable mouse events when gestures are used, because they cause problems with
 60755:         //Fennec
 60755:         mLastMultiTouchTime.start();
 55246:     }
 55246: 
 55246:     gesture = event->gesture(gSwipeGestureId);
 55246:     if (gesture) {
 55246:         if (gesture->state() == Qt::GestureStarted) {
 39368:             event->accept();
 39368:         }
 55246:         if (gesture->state() == Qt::GestureFinished) {
 55246:             event->accept();
 80486:             handled = true;
 55246: 
 55246:             MozSwipeGesture* swipe = static_cast<MozSwipeGesture*>(gesture);
 55246:             nsIntPoint hotspot;
 55246:             hotspot.x = swipe->hotSpot().x();
 55246:             hotspot.y = swipe->hotSpot().y();
 55246: 
 55246:             // Cancel pinch gesture
 80486:             mGesturesCancelled = true;
 60755:             mPinchEvent.needDispatch = false;
 60755: 
 60755:             double distance = DistanceBetweenPoints(swipe->hotSpot(), mPinchEvent.touchPoint) * 2;
107847:             double delta = distance - mPinchEvent.startDistance;
 60755: 
 55246:             DispatchGestureEvent(NS_SIMPLE_GESTURE_MAGNIFY, 0, delta / 2, hotspot);
 55246: 
 55246:             result = DispatchGestureEvent(NS_SIMPLE_GESTURE_SWIPE,
 55246:                                           swipe->Direction(), 0, hotspot);
 41049:         }
 60755:         mLastMultiTouchTime.start();
 39368:     }
 55246: 
 55246:     return result;
 39368: }
 41049: 
 55246: nsEventStatus
108991: nsWindow::DispatchGestureEvent(uint32_t aMsg, uint32_t aDirection,
 55246:                                double aDelta, const nsIntPoint& aRefPoint)
 55246: {
 80486:     nsSimpleGestureEvent mozGesture(true, aMsg, this, 0, 0.0);
 55246:     mozGesture.direction = aDirection;
 55246:     mozGesture.delta = aDelta;
 55246:     mozGesture.refPoint = aRefPoint;
 55246: 
 39368:     Qt::KeyboardModifiers modifiers = QApplication::keyboardModifiers();
 39368: 
 96893:     mozGesture.InitBasicModifiers(modifiers & Qt::ControlModifier,
 96893:                                   modifiers & Qt::AltModifier,
 96893:                                   modifiers & Qt::ShiftModifier,
 96893:                                   false);
 39368:     mozGesture.button    = 0;
 39368:     mozGesture.time      = 0;
 39368: 
 39368:     return DispatchEvent(&mozGesture);
 39368: }
 55246: 
 39368: 
 39368: double
 39368: nsWindow::DistanceBetweenPoints(const QPointF &aFirstPoint, const QPointF &aSecondPoint)
 39368: {
 39368:     double result = 0;
 39368:     double deltaX = abs(aFirstPoint.x() - aSecondPoint.x());
 39368:     double deltaY = abs(aFirstPoint.y() - aSecondPoint.y());
 39368:     result = sqrt(deltaX*deltaX + deltaY*deltaY);
 39368:     return result;
 39368: }
 39368: 
 39368: #endif //qt version check
 39368: 
 16807: void
 16807: nsWindow::ThemeChanged()
 16807: {
108452:     NotifyThemeChanged();
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnDragMotionEvent(QGraphicsSceneDragDropEvent *aEvent)
 16807: {
 16807:     LOG(("nsWindow::OnDragMotionSignal\n"));
 16807: 
 80486:     nsMouseEvent event(true, NS_DRAGDROP_OVER, 0,
 16807:                        nsMouseEvent::eReal);
 16884:     return nsEventStatus_eIgnore;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnDragLeaveEvent(QGraphicsSceneDragDropEvent *aEvent)
 16807: {
 16807:     // XXX Do we want to pass this on only if the event's subwindow is null?
 16807:     LOG(("nsWindow::OnDragLeaveSignal(%p)\n", this));
 80486:     nsMouseEvent event(true, NS_DRAGDROP_EXIT, this, nsMouseEvent::eReal);
 16807: 
 16884:     return DispatchEvent(&event);
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnDragDropEvent(QGraphicsSceneDragDropEvent *aDropEvent)
 16807: {
 16848:     if (aDropEvent->proposedAction() == Qt::CopyAction)
 16848:     {
 16848:         printf("text version of the data: %s\n", aDropEvent->mimeData()->text().toAscii().data());
 16848:         aDropEvent->acceptProposedAction();
 16848:     }
 16848: 
 16807:     LOG(("nsWindow::OnDragDropSignal\n"));
 80486:     nsMouseEvent event(true, NS_DRAGDROP_OVER, 0,
 16807:                        nsMouseEvent::eReal);
 16884:     return nsEventStatus_eIgnore;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::OnDragEnter(QGraphicsSceneDragDropEvent *aDragEvent)
 16807: {
 16848:     // Is it some format we think we can support?
 16848:     if ( aDragEvent->mimeData()->hasFormat(kURLMime)
 16848:       || aDragEvent->mimeData()->hasFormat(kURLDataMime)
 16848:       || aDragEvent->mimeData()->hasFormat(kURLDescriptionMime)
 16848:       || aDragEvent->mimeData()->hasFormat(kHTMLMime)
 16848:       || aDragEvent->mimeData()->hasFormat(kUnicodeMime)
 16848:       || aDragEvent->mimeData()->hasFormat(kTextMime)
 16848:        )
 16848:     {
 16848:         aDragEvent->acceptProposedAction();
 16848:     }
 16848: 
 16807:     // XXX Do we want to pass this on only if the event's subwindow is null?
 16807: 
 16807:     LOG(("nsWindow::OnDragEnter(%p)\n", this));
 16807: 
 80486:     nsMouseEvent event(true, NS_DRAGDROP_ENTER, this, nsMouseEvent::eReal);
 16884:     return DispatchEvent(&event);
 16807: }
 16807: 
 16807: static void
 16807: GetBrandName(nsXPIDLString& brandName)
 16807: {
 16807:     nsCOMPtr<nsIStringBundleService> bundleService =
 42314:         mozilla::services::GetStringBundleService();
 16807: 
 16807:     nsCOMPtr<nsIStringBundle> bundle;
 16807:     if (bundleService)
 16807:         bundleService->CreateBundle(
 16807:             "chrome://branding/locale/brand.properties",
 16807:             getter_AddRefs(bundle));
 16807: 
 16807:     if (bundle)
 16807:         bundle->GetStringFromName(
 16807:             NS_LITERAL_STRING("brandShortName").get(),
 16807:             getter_Copies(brandName));
 16807: 
 16807:     if (brandName.IsEmpty())
 16807:         brandName.Assign(NS_LITERAL_STRING("Mozilla"));
 16807: }
 16807: 
 16807: 
 16807: nsresult
 33013: nsWindow::Create(nsIWidget        *aParent,
 16807:                  nsNativeWidget    aNativeParent,
 24924:                  const nsIntRect  &aRect,
 68668:                  nsDeviceContext *aContext,
 16807:                  nsWidgetInitData *aInitData)
 16807: {
 38147:     // only set the base parent if we're not going to be a dialog or a
 16807:     // toplevel
 38147:     nsIWidget *baseParent = aParent;
 38147: 
 38147:     if (aInitData &&
 16807:         (aInitData->mWindowType == eWindowType_dialog ||
 16807:          aInitData->mWindowType == eWindowType_toplevel ||
 38147:          aInitData->mWindowType == eWindowType_invisible)) {
 38147: 
106838:         baseParent = nullptr;
 38147:         // also drop native parent for toplevel windows
106838:         aNativeParent = nullptr;
 38147:     }
 16807: 
 16807:     // initialize all the common bits of this class
108460:     BaseCreate(baseParent, aRect, aContext, aInitData);
 16807: 
 16807:     // and do our common creation
 16915:     mParent = aParent;
 16807: 
 16807:     // save our bounds
 16807:     mBounds = aRect;
 16807: 
 38147:     // find native parent
106838:     MozQWidget *parent = nullptr;
106838: 
106838:     if (aParent != nullptr)
 38147:         parent = static_cast<MozQWidget*>(aParent->GetNativeData(NS_NATIVE_WIDGET));
 16807: 
 38147:     // ok, create our QGraphicsWidget
 78855:     mWidget = createQWidget(parent, aNativeParent, aInitData);
 30337: 
 38147:     if (!mWidget)
 38147:         return NS_ERROR_OUT_OF_MEMORY;
 25042: 
 30337:     LOG(("Create: nsWindow [%p] [%p]\n", (void *)this, (void *)mWidget));
 16807: 
 16807:     // resize so that everything is set to the right dimensions
 80486:     Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, false);
 16807: 
 39689:     // check if we should listen for resizes
 39689:     mListenForResizes = (aNativeParent ||
 39689:                          (aInitData && aInitData->mListenForResizes));
 39689: 
 16807:     return NS_OK;
 16807: }
 16807: 
 51781: already_AddRefed<nsIWidget>
 51781: nsWindow::CreateChild(const nsIntRect&  aRect,
 68668:                       nsDeviceContext* aContext,
 51781:                       nsWidgetInitData* aInitData,
 79445:                       bool              /*aForceUseIWidgetParent*/)
 51781: {
 51781:     //We need to force parent widget, otherwise GetTopLevelWindow doesn't work
 51781:     return nsBaseWidget::CreateChild(aRect,
 51781:                                      aContext,
 51781:                                      aInitData,
 80486:                                      true); // Force parent
 51781: }
 51781: 
 51781: 
 16807: NS_IMETHODIMP
 16807: nsWindow::SetWindowClass(const nsAString &xulWinType)
 16807: {
 30337:     if (!mWidget)
 16807:       return NS_ERROR_FAILURE;
 16807: 
 16807:     nsXPIDLString brandName;
 16807:     GetBrandName(brandName);
 16807: 
 77137: #ifdef MOZ_X11
 16807:     XClassHint *class_hint = XAllocClassHint();
 16807:     if (!class_hint)
 16807:       return NS_ERROR_OUT_OF_MEMORY;
 16807:     const char *role = NULL;
 16807:     class_hint->res_name = ToNewCString(xulWinType);
 16807:     if (!class_hint->res_name) {
 16807:       XFree(class_hint);
 16807:       return NS_ERROR_OUT_OF_MEMORY;
 16807:     }
 16807:     class_hint->res_class = ToNewCString(brandName);
 16807:     if (!class_hint->res_class) {
 16807:       nsMemory::Free(class_hint->res_name);
 16807:       XFree(class_hint);
 16807:       return NS_ERROR_OUT_OF_MEMORY;
 16807:     }
 16807: 
 16807:     // Parse res_name into a name and role. Characters other than
 16807:     // [A-Za-z0-9_-] are converted to '_'. Anything after the first
 16807:     // colon is assigned to role; if there's no colon, assign the
 16807:     // whole thing to both role and res_name.
 16807:     for (char *c = class_hint->res_name; *c; c++) {
 16807:       if (':' == *c) {
 16807:         *c = 0;
 16807:         role = c + 1;
 16807:       }
 16807:       else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
 16807:         *c = '_';
 16807:     }
 16807:     class_hint->res_name[0] = toupper(class_hint->res_name[0]);
 16807:     if (!role) role = class_hint->res_name;
 16807: 
 39232:     QWidget *widget = GetViewWidget();
 39232:     // If widget not show, handle might be null
 94111:     if (widget && widget->winId())
 94111:         XSetClassHint(gfxQtPlatform::GetXDisplay(widget),
 94111:                       widget->winId(),
 16807:                       class_hint);
 38147: 
 16807:     nsMemory::Free(class_hint->res_class);
 16807:     nsMemory::Free(class_hint->res_name);
 16807:     XFree(class_hint);
 77137: #endif
 16900: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: void
108991: nsWindow::NativeResize(int32_t aWidth, int32_t aHeight, bool    aRepaint)
 16807: {
 16807:     LOG(("nsWindow::NativeResize [%p] %d %d\n", (void *)this,
 16807:          aWidth, aHeight));
 16807: 
 80486:     mNeedsResize = false;
 39689: 
 61828:     if (mIsTopLevel) {
 86093:         QGraphicsView *widget = qobject_cast<QGraphicsView*>(GetViewWidget());
114160:         NS_ENSURE_TRUE_VOID(widget);
 86093:         // map from in-scene widget to scene, from scene to view.
 86093:         QRect r = widget->mapFromScene(mWidget->mapToScene(QRect(0, 0, aWidth, aHeight))).boundingRect();
 86093:         // going from QPolygon to QRect includes the points, adding one to width and height
 86093:         r.adjust(0, 0, -1, -1);
 86093:         widget->resize(r.width(), r.height());
 51211:     }
 61829:     else {
 30337:         mWidget->resize(aWidth, aHeight);
 61829:     }
 46955: 
 46955:     if (aRepaint)
 46955:         mWidget->update();
 16807: }
 16807: 
 16807: void
108991: nsWindow::NativeResize(int32_t aX, int32_t aY,
108991:                        int32_t aWidth, int32_t aHeight,
 79445:                        bool    aRepaint)
 16807: {
 16807:     LOG(("nsWindow::NativeResize [%p] %d %d %d %d\n", (void *)this,
 16807:          aX, aY, aWidth, aHeight));
 16807: 
 80486:     mNeedsResize = false;
 80486:     mNeedsMove = false;
 39689: 
 42334:     if (mIsTopLevel) {
 86093:         QGraphicsView *widget = qobject_cast<QGraphicsView*>(GetViewWidget());
114160:         NS_ENSURE_TRUE_VOID(widget);
 86093:         // map from in-scene widget to scene, from scene to view.
 86093:         QRect r = widget->mapFromScene(mWidget->mapToScene(QRect(aX, aY, aWidth, aHeight))).boundingRect();
 86093:         // going from QPolygon to QRect includes the points, adding one to width and height
 86093:         r.adjust(0, 0, -1, -1);
 86093:         widget->setGeometry(r.x(), r.y(), r.width(), r.height());
 51211:     }
 61829:     else {
 38147:         mWidget->setGeometry(aX, aY, aWidth, aHeight);
 61829:     }
 46955: 
 46955:     if (aRepaint)
 46955:         mWidget->update();
 16807: }
 16807: 
 31136: void
 79445: nsWindow::NativeShow(bool aAction)
 31136: {
 39446:     if (aAction) {
 39446:         QWidget *widget = GetViewWidget();
 46725:         // On e10s, we never want the child process or plugin process
 46725:         // to go fullscreen because if we do the window because visible
 46725:         // do to disabled Qt-Xembed
 60437:         if (widget &&
 60437:             !widget->isVisible())
 39446:             MakeFullScreen(mSizeMode == nsSizeMode_Fullscreen);
 31136:         mWidget->show();
 39689: 
 39689:         // unset our flag now that our window has been shown
 80486:         mNeedsShow = false;
 39446:     }
 31136:     else
 31136:         mWidget->hide();
 31136: }
 31136: 
 16807: NS_IMETHODIMP
 79445: nsWindow::SetHasTransparentBackground(bool aTransparent)
 16807: {
 16884:     return NS_ERROR_NOT_IMPLEMENTED;
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 79445: nsWindow::GetHasTransparentBackground(bool& aTransparent)
 16807: {
 16807:     aTransparent = mIsTransparent;
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: void *
 16807: nsWindow::SetupPluginPort(void)
 16807: {
 41059:     NS_WARNING("Not implemented");
106838:     return nullptr;
 16807: }
 16807: 
 16807: nsresult
 24031: nsWindow::SetWindowIconList(const nsTArray<nsCString> &aIconList)
 16807: {
 38147:     QIcon icon;
 38147: 
108991:     for (uint32_t i = 0; i < aIconList.Length(); ++i) {
 38147:         const char *path = aIconList[i].get();
 38147:         LOG(("window [%p] Loading icon from %s\n", (void *)this, path));
 38147:         icon.addFile(path);
 38147:     }
 38147: 
 39446:     QWidget *widget = GetViewWidget();
 39446:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 39446:     widget->setWindowIcon(icon);
 38147: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: void
 16807: nsWindow::SetDefaultIcon(void)
 16807: {
 16807:     SetIcon(NS_LITERAL_STRING("default"));
 16807: }
 16807: 
 28944: void nsWindow::QWidgetDestroyed()
 28944: {
106838:     mWidget = nullptr;
 28944: }
 28944: 
 16807: NS_IMETHODIMP
 79445: nsWindow::MakeFullScreen(bool aFullScreen)
 16807: {
 39446:     QWidget *widget = GetViewWidget();
 39446:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 37898:     if (aFullScreen) {
 37898:         if (mSizeMode != nsSizeMode_Fullscreen)
 37898:             mLastSizeMode = mSizeMode;
 37898: 
 37898:         mSizeMode = nsSizeMode_Fullscreen;
 39446:         widget->showFullScreen();
 37898:     }
 37898:     else {
 37898:         mSizeMode = mLastSizeMode;
 37898: 
 37898:         switch (mSizeMode) {
 37898:         case nsSizeMode_Maximized:
 39446:             widget->showMaximized();
 37898:             break;
 37898:         case nsSizeMode_Minimized:
 39446:             widget->showMinimized();
 37898:             break;
 37898:         case nsSizeMode_Normal:
 39446:             widget->showNormal();
 39446:             break;
 39446:         default:
 39446:             widget->showNormal();
 37898:             break;
 37898:         }
 37898:     }
 37898: 
 37898:     NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
 37898:                  "mLastSizeMode should never be fullscreen");
 39841:     return nsBaseWidget::MakeFullScreen(aFullScreen);
 16807: }
 16807: 
 16807: NS_IMETHODIMP
 79445: nsWindow::HideWindowChrome(bool aShouldHide)
 16807: {
 30337:     if (!mWidget) {
 48237:         // Nothing to hide
 16807:         return NS_ERROR_FAILURE;
 16807:     }
 16807: 
 16807:     // Sawfish, metacity, and presumably other window managers get
 16807:     // confused if we change the window decorations while the window
 16807:     // is visible.
 79445:     bool wasVisible = false;
 30337:     if (mWidget->isVisible()) {
 80486:         NativeShow(false);
 80486:         wasVisible = true;
 16807:     }
 16807: 
 16807:     if (wasVisible) {
 80486:         NativeShow(true);
 16807:     }
 16807: 
 16807:     // For some window managers, adding or removing window decorations
 16807:     // requires unmapping and remapping our toplevel window.  Go ahead
 16807:     // and flush the queue here so that we don't end up with a BadWindow
 16807:     // error later when this happens (when the persistence timer fires
 16807:     // and GetWindowPos is called)
 39446:     QWidget *widget = GetViewWidget();
 39446:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
 77137: #ifdef MOZ_X11
 94111:     XSync(gfxQtPlatform::GetXDisplay(widget), False);
 77137: #endif
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16807: //////////////////////////////////////////////////////////////////////
 16807: // These are all of our drag and drop operations
 16807: 
 16807: void
 16807: nsWindow::InitDragEvent(nsMouseEvent &aEvent)
 16807: {
 16807:     // set the keyboard modifiers
 16807: }
 16807: 
 16807: // This will update the drag action based on the information in the
 38147: // drag context.
 16807: 
 16807: /* static */
 16807: nsresult
 16807: initialize_prefs(void)
 16807: {
 16807:     // check to see if we should set our raise pref
 16807:     return NS_OK;
 16807: }
 16807: 
 79445: inline bool
 16807: is_context_menu_key(const nsKeyEvent& aKeyEvent)
 16807: {
 96893:     return ((aKeyEvent.keyCode == NS_VK_F10 && aKeyEvent.IsShift() &&
 96893:              !aKeyEvent.IsControl() && !aKeyEvent.IsMeta() &&
 96893:              !aKeyEvent.IsAlt()) ||
 96893:             (aKeyEvent.keyCode == NS_VK_CONTEXT_MENU && !aKeyEvent.IsShift() &&
 96893:              !aKeyEvent.IsControl() && !aKeyEvent.IsMeta() &&
 96893:              !aKeyEvent.IsAlt()));
 16807: }
 16807: 
 16807: void
 16807: key_event_to_context_menu_event(nsMouseEvent &aEvent,
 16807:                                 QKeyEvent *aGdkEvent)
 16807: {
 24924:     aEvent.refPoint = nsIntPoint(0, 0);
 96893:     aEvent.modifiers = 0;
 16807:     aEvent.time = 0;
 16807:     aEvent.clickCount = 1;
 16807: }
 16807: 
 16807: // nsChildWindow class
 16807: 
 16807: nsChildWindow::nsChildWindow()
 16807: {
 16807: }
 16807: 
 16807: nsChildWindow::~nsChildWindow()
 16807: {
 16807: }
 16807: 
 16807: nsPopupWindow::nsPopupWindow()
 16807: {
 54256: #ifdef DEBUG_WIDGETS
 16807:     qDebug("===================== popup!");
 54256: #endif
 16807: }
 16807: 
 16807: nsPopupWindow::~nsPopupWindow()
 16782: {
 16782: }
 16782: 
 95241: NS_IMETHODIMP_(bool)
 95241: nsWindow::HasGLContext()
 95241: {
108556:     return MozQGLWidgetWrapper::hasGLContext(qobject_cast<QGraphicsView*>(GetViewWidget()));
 95241: }
 95241: 
 30337: MozQWidget*
 78855: nsWindow::createQWidget(MozQWidget *parent,
 78855:                         nsNativeWidget nativeParent,
 78855:                         nsWidgetInitData *aInitData)
 16782: {
 16884:     const char *windowName = NULL;
 61829:     Qt::WindowFlags flags = Qt::Widget;
 61829:     QWidget *parentWidget = (parent && parent->getReceiver()) ?
106838:             parent->getReceiver()->GetViewWidget() : nullptr;
 16884: 
 16782: #ifdef DEBUG_WIDGETS
 16782:     qDebug("NEW WIDGET\n\tparent is %p (%s)", (void*)parent,
 16782:            parent ? qPrintable(parent->objectName()) : "null");
 16782: #endif
 30337: 
 16782:     // ok, create our windows
 16782:     switch (mWindowType) {
 16782:     case eWindowType_dialog:
 16884:         windowName = "topLevelDialog";
 80486:         mIsTopLevel = true;
 61829:         flags |= Qt::Dialog;
 16884:         break;
 16782:     case eWindowType_popup:
 16884:         windowName = "topLevelPopup";
 16884:         break;
 16782:     case eWindowType_toplevel:
 16884:         windowName = "topLevelWindow";
 80486:         mIsTopLevel = true;
 16884:         break;
 16884:     case eWindowType_invisible:
 16884:         windowName = "topLevelInvisible";
 16884:         break;
 16884:     case eWindowType_child:
 33357:     case eWindowType_plugin:
 33357:     default: // sheet
 16884:         windowName = "paintArea";
 16884:         break;
 16782:     }
 16884: 
106838:     MozQWidget* parentQWidget = nullptr;
 78855:     if (parent) {
 78855:         parentQWidget = parent;
 78855:     } else if (nativeParent && nativeParent != PARENTLESS_WIDGET) {
 78855:         parentQWidget = static_cast<MozQWidget*>(nativeParent);
 78855:     }
 78855:     MozQWidget * widget = new MozQWidget(this, parentQWidget);
 38147:     if (!widget)
106838:         return nullptr;
120920:     widget->setObjectName(QString(windowName));
 38147: 
 38708:     // make only child and plugin windows focusable
 38708:     if (eWindowType_child == mWindowType || eWindowType_plugin == mWindowType) {
 38708:         widget->setFlag(QGraphicsItem::ItemIsFocusable);
 38708:         widget->setFocusPolicy(Qt::WheelFocus);
 38708:     }
 38708: 
 38147:     // create a QGraphicsView if this is a new toplevel window
 38147: 
 39366:     if (mIsTopLevel) {
 81001:         QGraphicsView* newView =
 81001:             nsFastStartup::GetStartupGraphicsView(parentWidget, widget);
 81001: 
 61829:         if (mWindowType == eWindowType_dialog) {
 61829:             newView->setWindowModality(Qt::WindowModal);
 61829:         }
 61829: 
 96882: #if defined(MOZ_PLATFORM_MAEMO) || defined(MOZ_GL_PROVIDER)
122281:         if (ComputeShouldAccelerate(mUseLayersAcceleration)) {
 81001:             // Only create new OGL widget if it is not yet installed
 95241:             if (!HasGLContext()) {
 96882:                 MozQGraphicsView *qview = qobject_cast<MozQGraphicsView*>(newView);
 96882:                 if (qview) {
 96882:                     qview->setGLWidgetEnabled(true);
 96882:                 }
 53937:             }
 81001:         }
 77137: #endif
 38147: 
 56628:         if (gfxQtPlatform::GetPlatform()->GetRenderMode() == gfxQtPlatform::RENDER_DIRECT) {
 56628:             // Disable double buffer and system background rendering
 94111: #if defined(MOZ_X11) && (QT_VERSION < QT_VERSION_CHECK(5,0,0))
 56628:             newView->viewport()->setAttribute(Qt::WA_PaintOnScreen, true);
 77137: #endif
 56628:             newView->viewport()->setAttribute(Qt::WA_NoSystemBackground, true);
 56628:         }
 39368:         // Enable gestures:
 39368: #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 77325: #if defined MOZ_ENABLE_MEEGOTOUCH
 77325:         // Disable default Gesture filters (speedup filtering)
 77325:         newView->viewport()->ungrabGesture(Qt::PanGesture);
 77325:         newView->viewport()->ungrabGesture(Qt::TapGesture);
 77325:         newView->viewport()->ungrabGesture(Qt::TapAndHoldGesture);
 77325:         newView->viewport()->ungrabGesture(Qt::SwipeGesture);
 77325: #endif
 77325: 
 77325:         // Enable required filters
 39368:         newView->viewport()->grabGesture(Qt::PinchGesture);
 55246:         newView->viewport()->grabGesture(gSwipeGestureId);
 39368: #endif
 38147:         newView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
 38147:         newView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
 38147: 
 38726: #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 38726:         // Top level widget is just container, and should not be painted
 38726:         widget->setFlag(QGraphicsItem::ItemHasNoContents);
 38726: #endif
 59839: 
 59839: #ifdef MOZ_X11
 63004:         if (newView->effectiveWinId()) {
 94111:             XSetWindowBackgroundPixmap(mozilla::DefaultXDisplay(),
 59839:                                        newView->effectiveWinId(), None);
 63004:         }
 59839: #endif
 61829:     }
 16884: 
 16807:     if (mWindowType == eWindowType_popup) {
 38147:         widget->setZValue(100);
 16884: 
 16884:         // XXX is this needed for Qt?
 16807:         // gdk does not automatically set the cursor for "temporary"
 16807:         // windows, which are what gtk uses for popups.
 16807:         SetCursor(eCursor_standard);
 16884:     } else if (mIsTopLevel) {
 16884:         SetDefaultIcon();
 16807:     }
 55246: #if (QT_VERSION >= QT_VERSION_CHECK(4, 6, 0))
 77325: #if defined MOZ_ENABLE_MEEGOTOUCH
 77325:     // Disable default Gesture filters (speedup filtering)
 77325:     widget->ungrabGesture(Qt::PanGesture);
 77325:     widget->ungrabGesture(Qt::TapGesture);
 77325:     widget->ungrabGesture(Qt::TapAndHoldGesture);
 77325:     widget->ungrabGesture(Qt::SwipeGesture);
 77325: #endif
 55246:     widget->grabGesture(Qt::PinchGesture);
 55246:     widget->grabGesture(gSwipeGestureId);
 55246: #endif
 16884: 
 30337:     return widget;
 16782: }
 16782: 
 16807: // return the gfxASurface for rendering to this widget
 16782: gfxASurface*
 16782: nsWindow::GetThebesSurface()
 16782: {
 16932:     /* This is really a dummy surface; this is only used when doing reflow, because
 16932:      * we need a RenderingContext to measure text against.
 16932:      */
 38320:     if (mThebesSurface)
 38320:         return mThebesSurface;
 38320: 
 56628: #ifdef CAIRO_HAS_QT_SURFACE
 38320:     gfxQtPlatform::RenderMode renderMode = gfxQtPlatform::GetPlatform()->GetRenderMode();
 38320:     if (renderMode == gfxQtPlatform::RENDER_QPAINTER) {
 38320:         mThebesSurface = new gfxQPainterSurface(gfxIntSize(1, 1), gfxASurface::CONTENT_COLOR);
 38320:     }
 54932: #endif
 38320:     if (!mThebesSurface) {
 38320:         gfxASurface::gfxImageFormat imageFormat = gfxASurface::ImageFormatRGB24;
 38320:         mThebesSurface = new gfxImageSurface(gfxIntSize(1, 1), imageFormat);
 38320:     }
 16782: 
 16782:     return mThebesSurface;
 16782: }
 16782: 
 16807: NS_IMETHODIMP
108991: nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, int32_t aHorizontal, int32_t aVertical)
 16782: {
 16807:     NS_ENSURE_ARG_POINTER(aEvent);
 16807: 
 16807:     if (aEvent->eventStructType != NS_MOUSE_EVENT) {
 16807:         // you can only begin a resize drag with a mouse event
 16807:         return NS_ERROR_INVALID_ARG;
 16782:     }
 16782: 
 16807:     nsMouseEvent* mouse_event = static_cast<nsMouseEvent*>(aEvent);
 16807: 
 16807:     if (mouse_event->button != nsMouseEvent::eLeftButton) {
 16807:         // you can only begin a resize drag with the left mouse button
 16807:         return NS_ERROR_INVALID_ARG;
 16807:     }
 16807: 
 16807:     return NS_OK;
 16807: }
 16807: 
 16884: nsEventStatus
 38147: nsWindow::contextMenuEvent(QGraphicsSceneContextMenuEvent *)
 16782: {
 16884:     return nsEventStatus_eIgnore;
 16782: }
 16782: 
 16884: nsEventStatus
 79445: nsWindow::imComposeEvent(QInputMethodEvent *event, bool &handled)
 16782: {
 78624:     // XXX Needs to check whether this widget has been destroyed or not after
 78624:     //     each DispatchEvent().
 78624: 
 80486:     nsCompositionEvent start(true, NS_COMPOSITION_START, this);
 57930:     DispatchEvent(&start);
 57930: 
 78624:     nsAutoString compositionStr(event->commitString().utf16());
 78624: 
 78624:     if (!compositionStr.IsEmpty()) {
 80486:       nsCompositionEvent update(true, NS_COMPOSITION_UPDATE, this);
 78624:       update.data = compositionStr;
 78624:       DispatchEvent(&update);
 78624:     }
 78624: 
 80486:     nsTextEvent text(true, NS_TEXT_TEXT, this);
 78624:     text.theText = compositionStr;
 57930:     DispatchEvent(&text);
 57930: 
 80486:     nsCompositionEvent end(true, NS_COMPOSITION_END, this);
 78624:     end.data = compositionStr;
 57930:     DispatchEvent(&end);
 57930: 
 16884:     return nsEventStatus_eIgnore;
 16782: }
 16912: 
 16912: nsIWidget *
 16912: nsWindow::GetParent(void)
 16912: {
 16912:     return mParent;
 16912: }
 16912: 
 50783: float
 50783: nsWindow::GetDPI()
 50783: {
 50783:     QDesktopWidget* rootWindow = QApplication::desktop();
 50783:     double heightInches = rootWindow->heightMM()/25.4;
 50783:     if (heightInches < 0.25) {
 50783:         // Something's broken, but we'd better not crash.
 50783:         return 96.0f;
 50783:     }
 50783: 
 50783:     return float(rootWindow->height()/heightInches);
 50783: }
 50783: 
 16912: void
 16912: nsWindow::DispatchActivateEvent(void)
 16912: {
108457:     if (mWidgetListener)
108457:       mWidgetListener->WindowActivated();
 16912: }
 16912: 
 16912: void
 16912: nsWindow::DispatchDeactivateEvent(void)
 16912: {
108457:     if (mWidgetListener)
108457:       mWidgetListener->WindowDeactivated();
 16912: }
 16912: 
 16912: void
 48346: nsWindow::DispatchActivateEventOnTopLevelWindow(void)
 48346: {
 48346:     nsWindow * topLevelWindow = static_cast<nsWindow*>(GetTopLevelWidget());
106838:     if (topLevelWindow != nullptr)
 48346:          topLevelWindow->DispatchActivateEvent();
 48346: }
 48346: 
 48346: void
 48346: nsWindow::DispatchDeactivateEventOnTopLevelWindow(void)
 48346: {
 48346:     nsWindow * topLevelWindow = static_cast<nsWindow*>(GetTopLevelWidget());
106838:     if (topLevelWindow != nullptr)
 48346:          topLevelWindow->DispatchDeactivateEvent();
 48346: }
 48346: 
 48346: void
 24924: nsWindow::DispatchResizeEvent(nsIntRect &aRect, nsEventStatus &aStatus)
 16912: {
108457:     aStatus = nsEventStatus_eIgnore;
108457:     if (mWidgetListener &&
108457:         mWidgetListener->WindowResized(this, aRect.width, aRect.height))
108457:       aStatus = nsEventStatus_eConsumeNoDefault;
 16912: }
 16912: 
 16912: NS_IMETHODIMP
108460: nsWindow::DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus)
 16912: {
 16912: #ifdef DEBUG
 16912:     debug_DumpEvent(stdout, aEvent->widget, aEvent,
110974:                     nsAutoCString("something"), 0);
 16912: #endif
 16912: 
 16912:     aStatus = nsEventStatus_eIgnore;
 16912: 
 16912:     // send it to the standard callback
108460:     if (mWidgetListener)
108460:       aStatus = mWidgetListener->HandleEvent(aEvent, mUseAttachedEvents);
 16912: 
 16912:     return NS_OK;
 16912: }
 16912: 
 16912: NS_IMETHODIMP
 79445: nsWindow::Show(bool aState)
 16912: {
 16915:     LOG(("nsWindow::Show [%p] state %d\n", (void *)this, aState));
120920:     if (aState == mIsShown)
120920:         return NS_OK;
120920: 
120920:     // Clear our cached resources when the window is hidden.
120920:     if (mIsShown && !aState) {
120920:         ClearCachedResources();
120920:     }
 16915: 
 16912:     mIsShown = aState;
 16912: 
 69191: #ifdef MOZ_ENABLE_QTMOBILITY
 69191:     if (mWidget &&
 69191:         (mWindowType == eWindowType_toplevel ||
 69191:          mWindowType == eWindowType_dialog ||
 69191:          mWindowType == eWindowType_popup))
 69191:     {
 69191:         if (!gOrientation) {
 69191:             gOrientation = new QOrientationSensor();
 69191:             gOrientation->addFilter(&gOrientationFilter);
 69191:             gOrientation->start();
 69191:             if (!gOrientation->isActive()) {
 69191:                 qWarning("Orientationsensor didn't start!");
 69191:             }
 69191:             gOrientationFilter.filter(gOrientation->reading());
 69191: 
 69191:             QObject::connect((QObject*) &gOrientationFilter, SIGNAL(orientationChanged()),
 69191:                              mWidget, SLOT(orientationChanged()));
 69191:         }
 69191:     }
 69191: #endif
 69191: 
 39689:     if ((aState && !AreBoundsSane()) || !mWidget) {
 39689:         LOG(("\tbounds are insane or window hasn't been created yet\n"));
 80486:         mNeedsShow = true;
 16912:         return NS_OK;
 39689:     }
 39689: 
 39689:     if (aState) {
 39689:         if (mNeedsMove) {
 39689:             NativeResize(mBounds.x, mBounds.y, mBounds.width, mBounds.height,
 80486:                          false);
 39689:         } else if (mNeedsResize) {
 80486:             NativeResize(mBounds.width, mBounds.height, false);
 39689:         }
 39689:     }
 39689:     else
 39689:         // If someone is hiding this widget, clear any needing show flag.
 80486:         mNeedsShow = false;
 39689: 
 39689:     NativeShow(aState);
 16912: 
 16912:     return NS_OK;
 16912: }
 16912: 
 16912: NS_IMETHODIMP
108991: nsWindow::Resize(int32_t aWidth, int32_t aHeight, bool aRepaint)
 16912: {
 16912:     mBounds.width = aWidth;
 16912:     mBounds.height = aHeight;
 16912: 
 30337:     if (!mWidget)
 16912:         return NS_OK;
 16912: 
 39689:     if (mIsShown) {
 39689:         if (AreBoundsSane()) {
 39689:             if (mIsTopLevel || mNeedsShow)
 39689:                 NativeResize(mBounds.x, mBounds.y,
 39689:                              mBounds.width, mBounds.height, aRepaint);
 39689:             else
 39689:                 NativeResize(mBounds.width, mBounds.height, aRepaint);
 39689: 
 39689:             // Does it need to be shown because it was previously insane?
 39689:             if (mNeedsShow)
 80486:                 NativeShow(true);
 38147:         }
 39689:         else {
 39689:             // If someone has set this so that the needs show flag is false
 39689:             // and it needs to be hidden, update the flag and hide the
 39689:             // window.  This flag will be cleared the next time someone
 39689:             // hides the window or shows it.  It also prevents us from
 80486:             // calling NativeShow(false) excessively on the window which
 39689:             // causes unneeded X traffic.
 39689:             if (!mNeedsShow) {
 80486:                 mNeedsShow = true;
 80486:                 NativeShow(false);
 39689:             }
 39689:         }
 39689:     }
 39689:     else if (AreBoundsSane() && mListenForResizes) {
 39689:         // For widgets that we listen for resizes for (widgets created
 39689:         // with native parents) we apparently _always_ have to resize.  I
 39689:         // dunno why, but apparently we're lame like that.
 39689:         NativeResize(aWidth, aHeight, aRepaint);
 39689:     }
 39689:     else {
 80486:         mNeedsResize = true;
 39689:     }
 39689: 
 39689:     // synthesize a resize event if this isn't a toplevel
 39689:     if (mIsTopLevel || mListenForResizes) {
 39689:         nsIntRect rect(mBounds.x, mBounds.y, aWidth, aHeight);
 39689:         nsEventStatus status;
 39689:         DispatchResizeEvent(rect, status);
 39689:     }
 16912: 
120177:     NotifyRollupGeometryChange();
 16912:     return NS_OK;
 16912: }
 16912: 
 16912: NS_IMETHODIMP
108991: nsWindow::Resize(int32_t aX, int32_t aY, int32_t aWidth, int32_t aHeight,
 79445:                  bool aRepaint)
 16912: {
 16912:     mBounds.x = aX;
 16912:     mBounds.y = aY;
 16912:     mBounds.width = aWidth;
 16912:     mBounds.height = aHeight;
 16912: 
 80486:     mPlaced = true;
 16912: 
 30337:     if (!mWidget)
 16912:         return NS_OK;
 16912: 
 39689:     // Has this widget been set to visible?
 39689:     if (mIsShown) {
 39689:         // Are the bounds sane?
 39689:         if (AreBoundsSane()) {
 39689:             // Yep?  Resize the window
 39689:             NativeResize(aX, aY, aWidth, aHeight, aRepaint);
 39689:             // Does it need to be shown because it was previously insane?
 39689:             if (mNeedsShow)
 80486:                 NativeShow(true);
 39689:         }
 39689:         else {
 39689:             // If someone has set this so that the needs show flag is false
 39689:             // and it needs to be hidden, update the flag and hide the
 39689:             // window.  This flag will be cleared the next time someone
 39689:             // hides the window or shows it.  It also prevents us from
 80486:             // calling NativeShow(false) excessively on the window which
 39689:             // causes unneeded X traffic.
 39689:             if (!mNeedsShow) {
 80486:                 mNeedsShow = true;
 80486:                 NativeShow(false);
 39689:             }
 39689:         }
 39689:     }
 39689:     // If the widget hasn't been shown, mark the widget as needing to be
 39689:     // resized before it is shown
 39689:     else if (AreBoundsSane() && mListenForResizes) {
 39689:         // For widgets that we listen for resizes for (widgets created
 39689:         // with native parents) we apparently _always_ have to resize.  I
 39689:         // dunno why, but apparently we're lame like that.
 39689:         NativeResize(aX, aY, aWidth, aHeight, aRepaint);
 39689:     }
 39689:     else {
 80486:         mNeedsResize = true;
 80486:         mNeedsMove = true;
 39689:     }
 39689: 
 39689:     if (mIsTopLevel || mListenForResizes) {
 39689:         // synthesize a resize event
 39689:         nsIntRect rect(aX, aY, aWidth, aHeight);
 39689:         nsEventStatus status;
 39689:         DispatchResizeEvent(rect, status);
 38147:     }
 46955: 
 46955:     if (aRepaint)
 46955:         mWidget->update();
 46955: 
120177:     NotifyRollupGeometryChange();
 16912:     return NS_OK;
 16912: }
 16912: 
 16912: NS_IMETHODIMP
 79445: nsWindow::Enable(bool aState)
 16912: {
 16912:     mEnabled = aState;
 16912: 
 16912:     return NS_OK;
 16912: }
 16912: 
106103: bool
106103: nsWindow::IsEnabled() const
 16912: {
106103:     return mEnabled;
 16912: }
 16912: 
 16912: void
 16912: nsWindow::OnDestroy(void)
 16912: {
 16912:     if (mOnDestroyCalled)
 16912:         return;
 16912: 
 80486:     mOnDestroyCalled = true;
 16912: 
 80842:     // release references to children and device context
 16912:     nsBaseWidget::OnDestroy();
 16912: 
 16912:     // let go of our parent
106838:     mParent = nullptr;
 16912: 
 16912:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
108456:     NotifyWindowDestroyed();
 16912: }
 16912: 
 79445: bool
 16912: nsWindow::AreBoundsSane(void)
 16912: {
 16912:     if (mBounds.width > 0 && mBounds.height > 0)
 80486:         return true;
 80486: 
 80486:     return false;
 16912: }
 39367: 
 77986: #if defined(MOZ_X11) && (MOZ_PLATFORM_MAEMO == 6)
 77986: typedef enum {
 77986:     VKBUndefined,
 77986:     VKBOpen,
 77986:     VKBClose
 77986: } PluginVKBState;
 77986: 
 77986: static QCoreApplication::EventFilter previousEventFilter = NULL;
 77986: 
 77986: static PluginVKBState
 77986: GetPluginVKBState(Window aWinId)
 77986: {
 77986:     // Set default value as unexpected error
 77986:     PluginVKBState imeState = VKBUndefined;
 94111:     Display *display = mozilla::DefaultXDisplay();
 77986: 
 77986:     Atom actualType;
 77986:     int actualFormat;
 77986:     unsigned long nitems;
 77986:     unsigned long bytes;
 77986:     union {
 77986:         unsigned char* asUChar;
 77986:         unsigned long* asLong;
 77986:     } data = {0};
 77986:     int status = XGetWindowProperty(display, aWinId, sPluginIMEAtom,
 77986:                                     0, 1, False, AnyPropertyType,
 77986:                                     &actualType, &actualFormat, &nitems,
 77986:                                     &bytes, &data.asUChar);
 77986: 
 77986:     if (status == Success && actualType == XA_CARDINAL && actualFormat == 32 && nitems == 1) {
 77986:         // Assume that plugin set value false - close VKB, true - open VKB
 77986:         imeState = data.asLong[0] ? VKBOpen : VKBClose;
 77986:     }
 77986: 
 77986:     if (status == Success) {
 77986:         XFree(data.asUChar);
 77986:     }
 77986: 
 77986:     return imeState;
 77986: }
 77986: 
 77986: static void
 77986: SetVKBState(Window aWinId, PluginVKBState aState)
 77986: {
 94111:     Display *display = mozilla::DefaultXDisplay();
 77986:     if (aState != VKBUndefined) {
 77986:         unsigned long isOpen = aState == VKBOpen ? 1 : 0;
 77986:         XChangeProperty(display, aWinId, sPluginIMEAtom, XA_CARDINAL, 32,
 77986:                         PropModeReplace, (unsigned char *) &isOpen, 1);
 77986:     } else {
 77986:         XDeleteProperty(display, aWinId, sPluginIMEAtom);
 77986:     }
 77986:     XSync(display, False);
 77986: }
 77986: 
 77986: static bool
 77986: x11EventFilter(void* message, long* result)
 77986: {
 77986:     XEvent* event = static_cast<XEvent*>(message);
 77986:     if (event->type == PropertyNotify) {
 77986:         if (event->xproperty.atom == sPluginIMEAtom) {
 77986:             PluginVKBState state = GetPluginVKBState(event->xproperty.window);
 77986:             if (state == VKBOpen) {
 77986:                 MozQWidget::requestVKB();
 77986:             } else if (state == VKBClose) {
 77986:                 MozQWidget::hideVKB();
 77986:             }
 77986:             return true;
 77986:         }
 77986:     }
 77986:     if (previousEventFilter) {
 77986:         return previousEventFilter(message, result);
 77986:     }
 77986: 
 77986:     return false;
 77986: }
 77986: #endif
 77986: 
 82841: NS_IMETHODIMP_(void)
 82841: nsWindow::SetInputContext(const InputContext& aContext,
 82841:                           const InputContextAction& aAction)
 39367: {
114160:     NS_ENSURE_TRUE_VOID(mWidget);
 39367: 
 82840:     // SetSoftwareKeyboardState uses mInputContext,
 82840:     // so, before calling that, record aContext in mInputContext.
 82840:     mInputContext = aContext;
 76710: 
 77986: #if defined(MOZ_X11) && (MOZ_PLATFORM_MAEMO == 6)
 79990:     if (sPluginIMEAtom) {
 77986:         static QCoreApplication::EventFilter currentEventFilter = NULL;
 82842:         if (mInputContext.mIMEState.mEnabled == IMEState::PLUGIN &&
 82840:             currentEventFilter != x11EventFilter) {
 77986:             // Install event filter for listening Plugin IME state changes
 77986:             previousEventFilter = QCoreApplication::instance()->setEventFilter(x11EventFilter);
 77986:             currentEventFilter = x11EventFilter;
 82842:         } else if (mInputContext.mIMEState.mEnabled != IMEState::PLUGIN &&
 82840:                    currentEventFilter == x11EventFilter) {
 77986:             // Remove event filter
 77986:             QCoreApplication::instance()->setEventFilter(previousEventFilter);
 77986:             currentEventFilter = previousEventFilter;
 77986:             previousEventFilter = NULL;
 77986:             QWidget* view = GetViewWidget();
 77986:             if (view) {
 77986:                 SetVKBState(view->winId(), VKBUndefined);
 77986:             }
 77986:         }
 79990:     }
 77986: #endif
 77986: 
 82842:     switch (mInputContext.mIMEState.mEnabled) {
 82842:         case IMEState::ENABLED:
 82842:         case IMEState::PASSWORD:
 82842:         case IMEState::PLUGIN:
 82841:             SetSoftwareKeyboardState(true, aAction);
 39367:             break;
 39367:         default:
 82841:             SetSoftwareKeyboardState(false, aAction);
 39367:             break;
 39367:     }
 82841: }
 82841: 
 82841: NS_IMETHODIMP_(InputContext)
 82841: nsWindow::GetInputContext()
 39367: {
 82842:     mInputContext.mIMEState.mOpen = IMEState::OPEN_STATE_NOT_SUPPORTED;
120231:     // Our qt widget looks like using only one context per process.
120231:     // However, it's better to set the context's pointer.
120231:     mInputContext.mNativeIMEContext = qApp->inputContext();
 82841:     return mInputContext;
 39367: }
 39367: 
 40944: void
 82841: nsWindow::SetSoftwareKeyboardState(bool aOpen,
 82841:                                    const InputContextAction& aAction)
 77986: {
 77986:     if (aOpen) {
 82842:         NS_ENSURE_TRUE(mInputContext.mIMEState.mEnabled != IMEState::DISABLED,);
 77986: 
 77986:         // Ensure that opening the virtual keyboard is allowed for this specific
 82840:         // InputContext depending on the content.ime.strict.policy pref
 82842:         if (mInputContext.mIMEState.mEnabled != IMEState::PLUGIN &&
 82841:             Preferences::GetBool("content.ime.strict_policy", false) &&
 82844:             !aAction.ContentGotFocusByTrustedCause() &&
 82844:             !aAction.UserMightRequestOpenVKB()) {
 77986:             return;
 77986:         }
 77986: #if defined(MOZ_X11) && (MOZ_PLATFORM_MAEMO == 6)
 77986:         // doen't open VKB if plugin did set closed state
 79990:         else if (sPluginIMEAtom) {
 77986:             QWidget* view = GetViewWidget();
 77986:             if (view && GetPluginVKBState(view->winId()) == VKBClose) {
 77986:                 return;
 77986:             }
 77986:         }
 77986: #endif
 77986:     }
 77986: 
 77986:     if (aOpen) {
 77986:         // VKB open need to be delayed in order to give
 77986:         // to plugins chance prevent VKB from opening
108991:         int32_t openDelay =
 77986:             Preferences::GetInt("ui.vkb.open.delay", 200);
 77986:         MozQWidget::requestVKB(openDelay, mWidget);
 77986:     } else {
 77986:         MozQWidget::hideVKB();
 77986:     }
 77986:     return;
 77986: }
 77986: 
 77986: void
 40944: nsWindow::UserActivity()
 40944: {
 40944:   if (!mIdleService) {
 40944:     mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
 40944:   }
 40944: 
 40944:   if (mIdleService) {
103224:     mIdleService->ResetIdleTimeOut(0);
 40944:   }
 40944: }
 90743: 
108991: uint32_t
 90743: nsWindow::GetGLFrameBufferFormat()
 90743: {
 90743:     if (mLayerManager &&
105710:         mLayerManager->GetBackendType() == mozilla::layers::LAYERS_OPENGL) {
108556:         return MozQGLWidgetWrapper::isRGBAContext() ? LOCAL_GL_RGBA : LOCAL_GL_RGB;
 90743:     }
 90743:     return LOCAL_GL_NONE;
 90743: }
 90743: 
