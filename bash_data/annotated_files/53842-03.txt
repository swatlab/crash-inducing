29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS symbol tables.
    1:  */
32777: #include <new>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h"
    1: #include "jsbit.h"
    1: #include "jsclist.h"
    1: #include "jsdhash.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
    1: #include "jsdbgapi.h"
40405: #include "jsfun.h"      /* for JS_ARGS_LENGTH_MAX */
    1: #include "jslock.h"
    1: #include "jsnum.h"
40405: #include "jsobj.h"
    1: #include "jsscope.h"
    1: #include "jsstr.h"
32777: #include "jstracer.h"
    1: 
47497: #include "jsobjinlines.h"
34349: #include "jsscopeinlines.h"
34349: 
37741: using namespace js;
37741: 
30258: uint32
30258: js_GenerateShape(JSContext *cx, bool gcLocked)
30258: {
30258:     JSRuntime *rt;
30258:     uint32 shape;
30258: 
30258:     rt = cx->runtime;
30258:     shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
30258:     JS_ASSERT(shape != 0);
30258:     if (shape >= SHAPE_OVERFLOW_BIT) {
30258:         /*
30258:          * FIXME bug 440834: The shape id space has overflowed. Currently we
30258:          * cope badly with this and schedule the GC on the every call. But
30258:          * first we make sure that increments from other threads would not
30258:          * have a chance to wrap around shapeGen to zero.
30258:          */
30258:         rt->shapeGen = SHAPE_OVERFLOW_BIT;
32735:         shape = SHAPE_OVERFLOW_BIT;
53592:         
53592: #ifdef JS_THREADSAFE
53592:         Conditionally<AutoLockGC> lockIf(!gcLocked, rt);
53592: #endif
53592:         TriggerGC(rt);
30258:     }
30258:     return shape;
30258: }
30258: 
52503: bool
52503: JSObject::ensureClassReservedSlotsForEmptyObject(JSContext *cx)
    1: {
52503:     JS_ASSERT(nativeEmpty());
28353: 
36435:     /*
52503:      * Subtle rule: objects that call JSObject::ensureInstanceReservedSlots
53650:      * must either:
47497:      *
53650:      * (a) never escape anywhere an ad-hoc property could be set on them; or
52503:      *
53650:      * (b) protect their instance-reserved slots with shapes, at least a custom
53652:      * empty shape with the right slotSpan member.
52503:      *
52503:      * Block objects are the only objects that fall into category (a). While
52503:      * Call objects cannot escape, they can grow ad-hoc properties via eval
53650:      * of a var declaration, or due to a function statement being evaluated,
53650:      * but they have slots mapped by compiler-created shapes, and thus (b) no
53650:      * problem predicting first ad-hoc property slot. Bound Function objects
53650:      * have a custom empty shape.
52503:      *
53650:      * (Note that Block, Call, and bound Function objects are the only native
53650:      * class objects that are allowed to call ensureInstanceReservedSlots.)
36435:      */
52503:     uint32 nfixed = JSSLOT_FREE(getClass());
52503:     if (nfixed > numSlots() && !allocSlots(cx, nfixed))
52503:         return false;
47497: 
52503:     return true;
    1: }
    1: 
52503: #define PROPERTY_TABLE_NBYTES(n) ((n) * sizeof(Shape *))
    1: 
35453: #ifdef DEBUG
35453: JS_FRIEND_DATA(JSScopeStats) js_scope_stats = {0};
35453: 
35453: # define METER(x)       JS_ATOMIC_INCREMENT(&js_scope_stats.x)
35453: #else
35453: # define METER(x)       /* nothing */
35453: #endif
35453: 
30258: bool
52509: PropertyTable::init(JSContext *cx, Shape *lastProp)
    1: {
    1:     int sizeLog2;
    1: 
52503:     if (entryCount > HASH_THRESHOLD) {
    1:         /*
12307:          * Either we're creating a table for a large scope that was populated
12307:          * via property cache hit logic under JSOP_INITPROP, JSOP_SETNAME, or
12307:          * JSOP_SETPROP; or else calloc failed at least once already. In any
12307:          * event, let's try to grow, overallocating to hold at least twice the
12307:          * current population.
    1:          */
30258:         sizeLog2 = JS_CeilingLog2(2 * entryCount);
    1:     } else {
52503:         JS_ASSERT(hashShift == JS_DHASH_BITS - MIN_SIZE_LOG2);
52503:         sizeLog2 = MIN_SIZE_LOG2;
    1:     }
    1: 
52503:     entries = (Shape **) js_calloc(JS_BIT(sizeLog2) * sizeof(Shape *));
52503:     if (!entries) {
35453:         METER(tableAllocFails);
30258:         return false;
    1:     }
53592:     cx->runtime->updateMallocCounter(JS_BIT(sizeLog2) * sizeof(Shape *));
    1: 
30258:     hashShift = JS_DHASH_BITS - sizeLog2;
52503:     for (Shape::Range r = lastProp->all(); !r.empty(); r.popFront()) {
52503:         const Shape &shape = r.front();
52503:         METER(searches);
52503:         METER(initSearches);
52503:         Shape **spp = search(shape.id, true);
52503:         SHAPE_STORE_PRESERVING_COLLISION(spp, &shape);
    1:     }
30258:     return true;
    1: }
    1: 
52503: bool
52509: Shape::maybeHash(JSContext *cx)
    1: {
52503:     JS_ASSERT(!table);
52509:     uint32 nentries = entryCount();
52509:     if (nentries >= PropertyTable::HASH_THRESHOLD) {
52509:         table = cx->create<PropertyTable>(nentries);
52509:         return table && table->init(cx, this);
    1:     }
52509:     return true;
30645: }
30645: 
35453: #ifdef DEBUG
10217: # include "jsprf.h"
10217: # define LIVE_SCOPE_METER(cx,expr) JS_LOCK_RUNTIME_VOID(cx->runtime,expr)
10217: #else
10217: # define LIVE_SCOPE_METER(cx,expr) /* nothing */
10217: #endif
10217: 
37766: /* static */
37766: bool
52503: Shape::initRuntimeState(JSContext *cx)
37766: {
40405:     JSRuntime *rt = cx->runtime;
40405: 
52503: #define SHAPE(Name) rt->empty##Name##Shape
47497: #define CLASP(Name) &js_##Name##Class
47497: 
52503: #define INIT_EMPTY_SHAPE(Name,NAME)                                           \
52503:     INIT_EMPTY_SHAPE_WITH_CLASS(Name, NAME, CLASP(Name))
47497: 
52503: #define INIT_EMPTY_SHAPE_WITH_CLASS(Name,NAME,clasp)                          \
52503:     JS_BEGIN_MACRO                                                            \
52503:         SHAPE(Name) = EmptyShape::create(cx, clasp);                          \
52503:         if (!SHAPE(Name))                                                     \
47497:             return false;                                                     \
52503:         JS_ASSERT(SHAPE(Name)->shape == Shape::EMPTY_##NAME##_SHAPE);         \
52503:     JS_END_MACRO
40405: 
40405:     /*
40405:      * NewArguments allocates dslots to have enough room for the argc of the
40405:      * particular arguments object being created.
40405:      * never mutated, it's safe to pretend to have all the slots possible.
40405:      *
48470:      * Note how the fast paths in jsinterp.cpp for JSOP_LENGTH and JSOP_GETELEM
40405:      * bypass resolution of scope properties for length and element indices on
40405:      * arguments objects. This helps ensure that any arguments object needing
40405:      * its own mutable scope (with unique shape) is a rare event.
40405:      */
52503:     INIT_EMPTY_SHAPE(Arguments, ARGUMENTS);
40405: 
52503:     INIT_EMPTY_SHAPE(Block, BLOCK);
43221: 
43221:     /*
43221:      * Initialize the shared scope for all empty Call objects so gets for args
43221:      * and vars do not force the creation of a mutable scope for the particular
43221:      * call object being accessed.
43221:      */
52503:     INIT_EMPTY_SHAPE(Call, CALL);
47497: 
47497:     /* A DeclEnv object holds the name binding for a named function expression. */
52503:     INIT_EMPTY_SHAPE(DeclEnv, DECL_ENV);
47497: 
47497:     /* Non-escaping native enumerator objects share this empty scope. */
52503:     INIT_EMPTY_SHAPE_WITH_CLASS(Enumerator, ENUMERATOR, &js_IteratorClass);
47497: 
47497:     /* Same drill for With objects. */
52503:     INIT_EMPTY_SHAPE(With, WITH);
47497: 
52503: #undef SHAPE
47497: #undef CLASP
52503: #undef INIT_EMPTY_SHAPE
52503: #undef INIT_EMPTY_SHAPE_WITH_CLASS
43221: 
40405:     return true;
37766: }
37766: 
37766: /* static */
37766: void
52503: Shape::finishRuntimeState(JSContext *cx)
37766: {
37766:     JSRuntime *rt = cx->runtime;
47497: 
52503:     rt->emptyArgumentsShape = NULL;
52503:     rt->emptyBlockShape = NULL;
52503:     rt->emptyCallShape = NULL;
52503:     rt->emptyDeclEnvShape = NULL;
52503:     rt->emptyEnumeratorShape = NULL;
52503:     rt->emptyWithShape = NULL;
    1: }
    1: 
 3328: JS_STATIC_ASSERT(sizeof(JSHashNumber) == 4);
 3328: JS_STATIC_ASSERT(sizeof(jsid) == JS_BYTES_PER_WORD);
 3328: 
 3328: #if JS_BYTES_PER_WORD == 4
48470: # define HASH_ID(id) ((JSHashNumber)(JSID_BITS(id)))
 3328: #elif JS_BYTES_PER_WORD == 8
48470: # define HASH_ID(id) ((JSHashNumber)(JSID_BITS(id)) ^ (JSHashNumber)((JSID_BITS(id)) >> 32))
 3328: #else
 3328: # error "Unsupported configuration"
 3328: #endif
 3328: 
    1: /*
    1:  * Double hashing needs the second hash code to be relatively prime to table
    1:  * size, so we simply make hash2 odd.  The inputs to multiplicative hash are
 3328:  * the golden ratio, expressed as a fixed-point 32 bit fraction, and the id
 3328:  * itself.
    1:  */
52503: #define HASH0(id)               (HASH_ID(id) * JS_GOLDEN_RATIO)
52503: #define HASH1(hash0,shift)      ((hash0) >> (shift))
52503: #define HASH2(hash0,log2,shift) ((((hash0) << (log2)) >> (shift)) | 1)
    1: 
52503: Shape **
52503: PropertyTable::search(jsid id, bool adding)
    1: {
    1:     JSHashNumber hash0, hash1, hash2;
30258:     int sizeLog2;
52503:     Shape *stored, *shape, **spp, **firstRemoved;
    1:     uint32 sizeMask;
    1: 
52503:     JS_ASSERT(entries);
48470:     JS_ASSERT(!JSID_IS_VOID(id));
    1: 
12307:     /* Compute the primary hash address. */
 3230:     METER(hashes);
52503:     hash0 = HASH0(id);
52503:     hash1 = HASH1(hash0, hashShift);
52503:     spp = entries + hash1;
    1: 
    1:     /* Miss: return space for a new entry. */
    1:     stored = *spp;
52503:     if (SHAPE_IS_FREE(stored)) {
    1:         METER(misses);
52503:         METER(hashMisses);
    1:         return spp;
    1:     }
    1: 
    1:     /* Hit: return entry. */
52503:     shape = SHAPE_CLEAR_COLLISION(stored);
52503:     if (shape && shape->id == id) {
    1:         METER(hits);
52503:         METER(hashHits);
    1:         return spp;
    1:     }
    1: 
    1:     /* Collision: double hash. */
    1:     sizeLog2 = JS_DHASH_BITS - hashShift;
52503:     hash2 = HASH2(hash0, sizeLog2, hashShift);
    1:     sizeMask = JS_BITMASK(sizeLog2);
    1: 
35465: #ifdef DEBUG
52503:     jsuword collision_flag = SHAPE_COLLISION;
35465: #endif
35465: 
    1:     /* Save the first removed entry pointer so we can recycle it if adding. */
52503:     if (SHAPE_IS_REMOVED(stored)) {
    1:         firstRemoved = spp;
    1:     } else {
    1:         firstRemoved = NULL;
52503:         if (adding && !SHAPE_HAD_COLLISION(stored))
52503:             SHAPE_FLAG_COLLISION(spp, shape);
35465: #ifdef DEBUG
52503:         collision_flag &= jsuword(*spp) & SHAPE_COLLISION;
35465: #endif
    1:     }
    1: 
    1:     for (;;) {
    1:         METER(steps);
    1:         hash1 -= hash2;
    1:         hash1 &= sizeMask;
52503:         spp = entries + hash1;
    1: 
    1:         stored = *spp;
52503:         if (SHAPE_IS_FREE(stored)) {
52503:             METER(misses);
    1:             METER(stepMisses);
    1:             return (adding && firstRemoved) ? firstRemoved : spp;
    1:         }
    1: 
52503:         shape = SHAPE_CLEAR_COLLISION(stored);
52503:         if (shape && shape->id == id) {
52503:             METER(hits);
    1:             METER(stepHits);
35465:             JS_ASSERT(collision_flag);
    1:             return spp;
    1:         }
    1: 
52503:         if (SHAPE_IS_REMOVED(stored)) {
    1:             if (!firstRemoved)
    1:                 firstRemoved = spp;
    1:         } else {
52503:             if (adding && !SHAPE_HAD_COLLISION(stored))
52503:                 SHAPE_FLAG_COLLISION(spp, shape);
35465: #ifdef DEBUG
52503:             collision_flag &= jsuword(*spp) & SHAPE_COLLISION;
35465: #endif
    1:         }
    1:     }
    1: 
    1:     /* NOTREACHED */
    1:     return NULL;
    1: }
    1: 
30258: bool
52509: PropertyTable::change(JSContext *cx, int change)
    1: {
    1:     int oldlog2, newlog2;
    1:     uint32 oldsize, newsize, nbytes;
52503:     Shape **newTable, **oldTable, **spp, **oldspp, *shape;
    1: 
52503:     JS_ASSERT(entries);
12307: 
52503:     /* Grow, shrink, or compress by changing this->entries. */
30258:     oldlog2 = JS_DHASH_BITS - hashShift;
    1:     newlog2 = oldlog2 + change;
    1:     oldsize = JS_BIT(oldlog2);
    1:     newsize = JS_BIT(newlog2);
52503:     nbytes = PROPERTY_TABLE_NBYTES(newsize);
52509:     newTable = (Shape **) cx->calloc(nbytes);
52503:     if (!newTable) {
35453:         METER(tableAllocFails);
30258:         return false;
35453:     }
    1: 
52503:     /* Now that we have newTable allocated, update members. */
30258:     hashShift = JS_DHASH_BITS - newlog2;
30258:     removedCount = 0;
52503:     oldTable = entries;
52503:     entries = newTable;
    1: 
52509:     /* Treat the above calloc as a JS_malloc, to match CreateScopeTable. */
53592:     cx->runtime->updateMallocCounter(nbytes);
52509: 
    1:     /* Copy only live entries, leaving removed and free ones behind. */
52503:     for (oldspp = oldTable; oldsize != 0; oldspp++) {
52503:         shape = SHAPE_FETCH(oldspp);
52503:         if (shape) {
52503:             METER(searches);
52503:             METER(changeSearches);
52503:             spp = search(shape->id, true);
52503:             JS_ASSERT(SHAPE_IS_FREE(*spp));
52503:             *spp = shape;
    1:         }
    1:         oldsize--;
    1:     }
    1: 
52503:     /* Finally, free the old entries storage. */
52509:     cx->free(oldTable);
30258:     return true;
    1: }
    1: 
52503: Shape *
52503: Shape::getChild(JSContext *cx, const js::Shape &child, Shape **listp)
52503: {
52503:     JS_ASSERT(!JSID_IS_VOID(child.id));
52503:     JS_ASSERT(!child.inDictionary());
52503: 
52503:     if (inDictionary()) {
52503:         if (newDictionaryShape(cx, child, listp))
52503:             return *listp;
52503:         return NULL;
52503:     }
52503: 
52503:     Shape *shape = JS_PROPERTY_TREE(cx).getChild(cx, this, child);
52503:     if (shape) {
52503:         JS_ASSERT(shape->parent == this);
52503:         JS_ASSERT(this == *listp);
52503:         *listp = shape;
52503:     }
52503:     return shape;
52503: }
52503: 
35453: /*
35453:  * Get or create a property-tree or dictionary child property of parent, which
35453:  * must be lastProp if inDictionaryMode(), else parent must be one of lastProp
35453:  * or lastProp->parent.
35453:  */
52503: Shape *
52503: JSObject::getChildProperty(JSContext *cx, Shape *parent, Shape &child)
35453: {
48470:     JS_ASSERT(!JSID_IS_VOID(child.id));
38562:     JS_ASSERT(!child.inDictionary());
35453: 
35453:     /*
35453:      * Aliases share another property's slot, passed in the |slot| parameter.
35453:      * Shared properties have no slot. Unshared properties that do not alias
35453:      * another property's slot allocate a slot here, but may lose it due to a
35453:      * JS_ClearScope call.
35453:      */
38562:     if (!child.isAlias()) {
35453:         if (child.attrs & JSPROP_SHARED) {
52503:             child.slot = SHAPE_INVALID_SLOT;
35453:         } else {
35453:             /*
53650:              * We may have set slot from a nearly-matching shape, above. If so,
53650:              * we're overwriting that nearly-matching shape, so we can reuse
53650:              * its slot -- we don't need to allocate a new one. Similarly, we
53650:              * use a specific slot if provided by the caller.
35453:              */
52503:             if (child.slot == SHAPE_INVALID_SLOT && !allocSlot(cx, &child.slot))
35453:                 return NULL;
35453:         }
35453:     }
35453: 
53650:     Shape *shape;
53650: 
35453:     if (inDictionaryMode()) {
35453:         JS_ASSERT(parent == lastProp);
52503:         if (parent->frozen()) {
52503:             parent = Shape::newDictionaryList(cx, &lastProp);
52503:             if (!parent)
52503:                 return NULL;
52503:             JS_ASSERT(!parent->frozen());
52503:         }
53650:         shape = Shape::newDictionaryShape(cx, child, &lastProp);
53650:         if (!shape)
35453:             return NULL;
53650:     } else {
53650:         shape = JS_PROPERTY_TREE(cx).getChild(cx, parent, child);
52503:         if (shape) {
52503:             JS_ASSERT(shape->parent == parent);
52503:             JS_ASSERT_IF(parent != lastProp, parent == lastProp->parent);
52503:             setLastProperty(shape);
53650:         }
53650:     }
53650: 
52503:     updateFlags(shape);
35453:     updateShape(cx);
52503:     return shape;
35453: }
35453: 
30258: void
52503: JSObject::reportReadOnlyScope(JSContext *cx)
    1: {
    1:     JSString *str;
    1:     const char *bytes;
    1: 
52503:     str = js_ValueToString(cx, ObjectValue(*this));
    1:     if (!str)
    1:         return;
    1:     bytes = js_GetStringBytes(cx, str);
    1:     if (!bytes)
    1:         return;
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_READ_ONLY, bytes);
    1: }
    1: 
52503: Shape *
52503: Shape::newDictionaryShape(JSContext *cx, const Shape &child, Shape **listp)
52503: {
52503:     Shape *dprop = JS_PROPERTY_TREE(cx).newShape(cx);
52503:     if (!dprop)
52503:         return NULL;
52503: 
52503:     new (dprop) Shape(child.id, child.rawGetter, child.rawSetter, child.slot, child.attrs,
53650:                       (child.flags & ~FROZEN) | IN_DICTIONARY, child.shortid,
53652:                       js_GenerateShape(cx, false), child.slotSpan);
52503: 
52503:     dprop->listp = NULL;
52503:     dprop->insertIntoDictionary(listp);
52503: 
52503:     JS_RUNTIME_METER(cx->runtime, liveDictModeNodes);
52503:     return dprop;
52503: }
52503: 
52503: Shape *
52503: Shape::newDictionaryList(JSContext *cx, Shape **listp)
52503: {
52503:     Shape *shape = *listp;
52503:     Shape *list = shape;
52503: 
52503:     Shape **childp = listp;
52503:     *childp = NULL;
52503: 
52503:     while (shape) {
52503:         JS_ASSERT(!shape->inDictionary());
52503: 
52503:         Shape *dprop = Shape::newDictionaryShape(cx, *shape, childp);
52503:         if (!dprop) {
52503:             METER(toDictFails);
52503:             *listp = list;
52503:             return NULL;
52503:         }
52503: 
52503:         JS_ASSERT(!dprop->table);
52503:         childp = &dprop->parent;
52503:         shape = shape->parent;
52503:     }
52503: 
52503:     list = *listp;
52503:     JS_ASSERT(list->inDictionary());
52509:     list->maybeHash(cx);
52503:     return list;
52503: }
52503: 
52503: bool
52503: JSObject::toDictionaryMode(JSContext *cx)
52503: {
52503:     JS_ASSERT(!inDictionaryMode());
52503:     if (!Shape::newDictionaryList(cx, &lastProp))
52503:         return false;
52503: 
52503:     clearOwnShape();
52503:     return true;
52503: }
52503: 
52503: /*
52503:  * Normalize stub getter and setter values for faster is-stub testing in the
52503:  * SHAPE_CALL_[GS]ETTER macros.
52503:  */
52503: static inline bool
52503: NormalizeGetterAndSetter(JSContext *cx, JSObject *obj,
52503:                          jsid id, uintN attrs, uintN flags,
52503:                          PropertyOp &getter,
52503:                          PropertyOp &setter)
52503: {
52503:     if (setter == PropertyStub) {
52503:         JS_ASSERT(!(attrs & JSPROP_SETTER));
52503:         setter = NULL;
52503:     }
52503:     if (flags & Shape::METHOD) {
52503:         /* Here, getter is the method, a function object reference. */
52503:         JS_ASSERT(getter);
52503:         JS_ASSERT(!setter || setter == js_watch_set);
52503:         JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
52503:     } else {
52503:         if (getter == PropertyStub) {
52503:             JS_ASSERT(!(attrs & JSPROP_GETTER));
52503:             getter = NULL;
52503:         }
52503:     }
52503: 
52503:     /*
52503:      * Check for a watchpoint on a deleted property; if one exists, change
52503:      * setter to js_watch_set or js_watch_set_wrapper.
52503:      * XXXbe this could get expensive with lots of watchpoints...
52503:      */
52503:     if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList) &&
52503:         js_FindWatchPoint(cx->runtime, obj, id)) {
52503:         setter = js_WrapWatchedSetter(cx, id, attrs, setter);
52503:         if (!setter) {
52503:             METER(wrapWatchFails);
52503:             return false;
52503:         }
52503:     }
52503:     return true;
52503: }
52503: 
53651: #ifdef DEBUG
53651: # define CHECK_SHAPE_CONSISTENCY(obj) obj->checkShapeConsistency()
53651: 
53651: void
53651: JSObject::checkShapeConsistency()
53651: {
53651:     static int throttle = -1;
53651:     if (throttle < 0) {
53651:         if (const char *var = getenv("JS_CHECK_SHAPE_THROTTLE"))
53651:             throttle = atoi(var);
53651:         if (throttle < 0)
53651:             throttle = 0;
53651:     }
53651:     if (throttle == 0)
53651:         return;
53651: 
53651:     JS_ASSERT(isNative());
53651:     if (hasOwnShape())
53651:         JS_ASSERT(objShape != lastProp->shape);
53651:     else
53651:         JS_ASSERT(objShape == lastProp->shape);
53651: 
53651:     Shape *shape = lastProp;
53651:     Shape *prev = NULL;
53651: 
53651:     if (inDictionaryMode()) {
53651:         if (PropertyTable *table = shape->table) {
53652:             for (uint32 fslot = table->freelist; fslot != SHAPE_INVALID_SLOT;
53651:                  fslot = getSlotRef(fslot).toPrivateUint32()) {
53652:                 JS_ASSERT(fslot < shape->slotSpan);
53651:             }
53651: 
53651:             for (int n = throttle; --n >= 0 && shape->parent; shape = shape->parent) {
53651:                 JS_ASSERT_IF(shape != lastProp, !shape->table);
53651: 
53651:                 Shape **spp = table->search(shape->id, false);
53651:                 JS_ASSERT(SHAPE_FETCH(spp) == shape);
53651:             }
53651:         } else {
53651:             shape = shape->parent;
53651:             for (int n = throttle; --n >= 0 && shape; shape = shape->parent)
53651:                 JS_ASSERT(!shape->table);
53651:         }
53651: 
53651:         shape = lastProp;
53651:         for (int n = throttle; --n >= 0 && shape; shape = shape->parent) {
53652:             JS_ASSERT_IF(shape->slot != SHAPE_INVALID_SLOT, shape->slot < shape->slotSpan);
53651:             if (!prev) {
53651:                 JS_ASSERT(shape == lastProp);
53651:                 JS_ASSERT(shape->listp == &lastProp);
53651:             } else {
53651:                 JS_ASSERT(shape->listp == &prev->parent);
53652:                 JS_ASSERT(prev->slotSpan >= shape->slotSpan);
53651:             }
53651:             prev = shape;
53651:         }
53651:     } else {
53651:         for (int n = throttle; --n >= 0 && shape->parent; shape = shape->parent) {
53651:             if (PropertyTable *table = shape->table) {
53651:                 JS_ASSERT(shape->parent);
53651:                 for (Shape::Range r(shape); !r.empty(); r.popFront()) {
53651:                     Shape **spp = table->search(r.front().id, false);
53651:                     JS_ASSERT(SHAPE_FETCH(spp) == &r.front());
53651:                 }
53651:             }
53651:             if (prev) {
53652:                 JS_ASSERT(prev->slotSpan >= shape->slotSpan);
53651:                 if (shape->kids.isShape()) {
53651:                     JS_ASSERT(shape->kids.toShape() == prev);
53651:                 } else if (shape->kids.isChunk()) {
53651:                     bool found = false;
53651:                     for (KidsChunk *chunk = shape->kids.toChunk(); chunk; chunk = chunk->next) {
53651:                         for (uintN i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
53651:                             if (!chunk->kids[i]) {
53651:                                 JS_ASSERT(!chunk->next);
53651:                                 for (uintN j = i + 1; j < MAX_KIDS_PER_CHUNK; j++)
53651:                                     JS_ASSERT(!chunk->kids[j]);
53651:                                 JS_ASSERT(found);
53651:                             }
53651:                             if (chunk->kids[i] == prev) {
53651:                                 JS_ASSERT(!found);
53651:                                 found = true;
53651:                             }
53651:                         }
53651:                     }
53651:                 } else {
53651:                     JS_ASSERT(shape->kids.isHash());
53651:                     KidsHash *hash = shape->kids.toHash();
53651:                     KidsHash::Ptr ptr = hash->lookup(prev);
53651:                     JS_ASSERT(*ptr == prev);
53651:                 }
53651:             }
53651:             prev = shape;
53651:         }
53651: 
53651:         if (throttle == 0) {
53651:             JS_ASSERT(!shape->table);
53651:             JS_ASSERT(JSID_IS_EMPTY(shape->id));
53651:             JS_ASSERT(shape->slot == SHAPE_INVALID_SLOT);
53651:         }
53651:     }
53651: }
53651: #else
53651: # define CHECK_SHAPE_CONSISTENCY(obj) ((void)0)
53651: #endif
53651: 
52503: const Shape *
52503: JSObject::addProperty(JSContext *cx, jsid id,
52503:                       PropertyOp getter, PropertyOp setter,
52503:                       uint32 slot, uintN attrs,
52503:                       uintN flags, intN shortid)
52503: {
52503:     JS_ASSERT(!JSID_IS_VOID(id));
52503: 
52503:     /*
52503:      * You can't add properties to a sealed object. But note well that you can
52503:      * change property attributes in a sealed object, even though that replaces
52503:      * a Shape * in the scope's hash table -- but no id is added, so the object
52503:      * remains sealed.
52503:      */
52503:     if (sealed()) {
52503:         reportReadOnlyScope(cx);
52503:         return NULL;
52503:     }
52503: 
52503:     NormalizeGetterAndSetter(cx, this, id, attrs, flags, getter, setter);
52503: 
52503:     /* Search for id with adding = true in order to claim its entry. */
52503:     Shape **spp = nativeSearch(id, true);
52503:     JS_ASSERT(!SHAPE_FETCH(spp));
52503:     return addPropertyCommon(cx, id, getter, setter, slot, attrs, flags, shortid, spp);
52503: }
52503: 
52503: const uint32 MAX_PROPERTY_TREE_HEIGHT = 64;
52503: 
52503: const Shape *
52503: JSObject::addPropertyCommon(JSContext *cx, jsid id,
52503:                             PropertyOp getter, PropertyOp setter,
52503:                             uint32 slot, uintN attrs,
52503:                             uintN flags, intN shortid,
52503:                             Shape **spp)
52503: {
52503:     PropertyTable *table = NULL;
52503:     if (!inDictionaryMode()) {
52503:         if (lastProp->entryCount() > MAX_PROPERTY_TREE_HEIGHT) {
52503:             if (!toDictionaryMode(cx))
52503:                 return NULL;
52503:             spp = nativeSearch(id, true);
52503:             table = lastProp->table;
52503:         }
52503:     } else if ((table = lastProp->table) != NULL) {
52503:         /* Check whether we need to grow, if the load factor is >= .75. */
52503:         uint32 size = table->capacity();
52503:         if (table->entryCount + table->removedCount >= size - (size >> 2)) {
52503:             int change = table->removedCount < size >> 2;
52503:             if (!change)
52503:                 METER(compresses);
52503:             else
52503:                 METER(grows);
52509:             if (!table->change(cx, change) && table->entryCount + table->removedCount == size - 1)
52503:                 return NULL;
52503:             METER(searches);
52503:             METER(changeSearches);
52503:             spp = table->search(id, true);
52503:             JS_ASSERT(!SHAPE_FETCH(spp));
52503:         }
52503:     }
52503: 
52503:     /* Find or create a property tree node labeled by our arguments. */
52503:     const Shape *shape;
52503:     {
52503:         Shape child(id, getter, setter, slot, attrs, flags, shortid);
52503:         shape = getChildProperty(cx, lastProp, child);
52503:     }
52503: 
52503:     if (shape) {
52503:         JS_ASSERT(shape == lastProp);
52503: 
52503:         if (table) {
52503:             /* Store the tree node pointer in the table entry for id. */
52503:             SHAPE_STORE_PRESERVING_COLLISION(spp, shape);
52503:             ++table->entryCount;
52503: 
52503:             /* Pass the table along to the new lastProp, namely shape. */
52503:             JS_ASSERT(shape->parent->table == table);
52503:             shape->parent->setTable(NULL);
52503:             shape->setTable(table);
52503:         }
52503: #ifdef DEBUG
52503:         LIVE_SCOPE_METER(cx, ++cx->runtime->liveObjectProps);
52503:         JS_RUNTIME_METER(cx->runtime, totalObjectProps);
52503: #endif
52503: 
52509:         /*
52509:          * If we reach the hashing threshold, try to allocate lastProp->table.
52509:          * If we can't (a rare event, preceded by swapping to death on most
52509:          * modern OSes), stick with linear search rather than whining about
52509:          * this little set-back.  Therefore we must test !lastProp->table and
52509:          * entry count >= PropertyTable::HASH_THRESHOLD, not merely whether the
52509:          * entry count just reached the threshold.
52509:          */
52509:         if (!lastProp->table)
52509:             lastProp->maybeHash(cx);
52509: 
53651:         CHECK_SHAPE_CONSISTENCY(this);
52503:         METER(adds);
52503:         return shape;
52503:     }
52503: 
53651:     CHECK_SHAPE_CONSISTENCY(this);
52503:     METER(addFails);
52503:     return NULL;
52503: }
52503: 
52503: const Shape *
52503: JSObject::putProperty(JSContext *cx, jsid id,
52503:                       PropertyOp getter, PropertyOp setter,
52503:                       uint32 slot, uintN attrs,
52503:                       uintN flags, intN shortid)
52503: {
52503:     Shape **spp, *shape, *overwriting;
52503: 
52503:     JS_ASSERT(!JSID_IS_VOID(id));
52503: 
52503:     if (sealed()) {
52503:         reportReadOnlyScope(cx);
52503:         return NULL;
52503:     }
52503: 
52503:     NormalizeGetterAndSetter(cx, this, id, attrs, flags, getter, setter);
52503: 
52503:     /* Search for id in order to claim its entry if table has been allocated. */
52503:     spp = nativeSearch(id, true);
52503:     shape = SHAPE_FETCH(spp);
52503:     if (!shape)
52503:         return addPropertyCommon(cx, id, getter, setter, slot, attrs, flags, shortid, spp);
52503: 
52503:     /* Property exists: search must have returned a valid *spp. */
52503:     JS_ASSERT(!SHAPE_IS_REMOVED(*spp));
52503:     overwriting = shape;
52503: 
52503:     /*
52503:      * If all property members match, this is a redundant add and we can
52503:      * return early.  If the caller wants to allocate a slot, but doesn't
52503:      * care which slot, copy shape->slot into slot so we can match shape,
52503:      * if all other members match.
52503:      */
52503:     if (!(attrs & JSPROP_SHARED) && slot == SHAPE_INVALID_SLOT && containsSlot(shape->slot))
52503:         slot = shape->slot;
52503:     if (shape->matchesParamsAfterId(getter, setter, slot, attrs, flags, shortid)) {
52503:         METER(redundantPuts);
52503:         return shape;
52503:     }
52503: 
52503:     PropertyTable *table = inDictionaryMode() ? lastProp->table : NULL;
52503: 
52503:     /*
52503:      * If we are clearing shape to force the existing property that it
52503:      * describes to be overwritten, then we have to unlink shape from the
52503:      * ancestor line at lastProp->lastProp.
52503:      *
52503:      * If shape is not lastProp and this scope is not in dictionary mode,
52503:      * we must switch to dictionary mode so we can unlink the non-terminal
52503:      * shape without breaking anyone sharing the property lineage via our
52503:      * prototype's property tree.
52503:      */
52503:     Shape *oldLastProp = lastProp;
52503:     if (shape == lastProp && !inDictionaryMode()) {
52503:         removeLastProperty();
52503:     } else {
52503:         if (!inDictionaryMode()) {
52503:             if (!toDictionaryMode(cx))
52503:                 return NULL;
53651: 
52503:             spp = nativeSearch(id);
52503:             shape = SHAPE_FETCH(spp);
53651:             table = lastProp->table;
53651:             oldLastProp = lastProp;
52503:         }
52503:         shape->removeFromDictionary(this);
52503:     }
52503: 
53650: #ifdef DEBUG
53650:     if (shape == oldLastProp) {
53652:         JS_ASSERT(lastProp->slotSpan <= shape->slotSpan);
53650:         if (shape->hasSlot())
53652:             JS_ASSERT(shape->slot < shape->slotSpan);
53652:         if (lastProp->slotSpan < numSlots())
53652:             getSlotRef(lastProp->slotSpan).setUndefined();
53650:     }
53650: #endif
53650: 
52503:     /*
52503:      * If we fail later on trying to find or create a new shape, we will
52503:      * restore *spp from |overwriting|. Note that we don't bother to keep
52503:      * table->removedCount in sync, because we will fix up both *spp and
52503:      * table->entryCount shortly.
52503:      */
52503:     if (table)
52503:         SHAPE_STORE_PRESERVING_COLLISION(spp, NULL);
52503: 
52503:     {
52503:         /* Find or create a property tree node labeled by our arguments. */
52503:         Shape child(id, getter, setter, slot, attrs, flags, shortid);
52503:         shape = getChildProperty(cx, lastProp, child);
52503:     }
52503: 
52503:     if (shape) {
52503:         JS_ASSERT(shape == lastProp);
52503: 
52503:         if (table) {
52503:             /* Store the tree node pointer in the table entry for id. */
52503:             SHAPE_STORE_PRESERVING_COLLISION(spp, shape);
52503: 
52503:             /* Move table from oldLastProp to the new lastProp, aka shape. */
52503:             JS_ASSERT(oldLastProp->table == table);
52503:             oldLastProp->setTable(NULL);
52503:             shape->setTable(table);
52503:         }
52503: 
52509:         if (!lastProp->table) {
52509:             /* See comment in JSObject::addPropertyCommon about ignoring OOM here. */
52509:             lastProp->maybeHash(cx);
52509:         }
52509: 
53651:         CHECK_SHAPE_CONSISTENCY(this);
52503:         METER(puts);
52503:         return shape;
52503:     }
52503: 
52503:     if (table)
52503:         SHAPE_STORE_PRESERVING_COLLISION(spp, overwriting);
53651:     CHECK_SHAPE_CONSISTENCY(this);
52503:     METER(putFails);
52503:     return NULL;
52503: }
52503: 
52503: const Shape *
52503: JSObject::changeProperty(JSContext *cx, const Shape *shape, uintN attrs, uintN mask,
52503:                          PropertyOp getter, PropertyOp setter)
52503: {
52503:     const Shape *newShape;
52503: 
52503:     JS_ASSERT(!JSID_IS_VOID(shape->id));
52503:     JS_ASSERT(nativeContains(*shape));
52503: 
52503:     attrs |= shape->attrs & mask;
52503: 
53650:     /* Allow only shared (slotless) => unshared (slotful) transition. */
52503:     JS_ASSERT(!((attrs ^ shape->attrs) & JSPROP_SHARED) ||
52503:               !(attrs & JSPROP_SHARED));
52503: 
52503:     /* Don't allow method properties to be changed to have a getter. */
52503:     JS_ASSERT_IF(getter != shape->rawGetter, !shape->isMethod());
52503: 
52503:     if (getter == PropertyStub)
52503:         getter = NULL;
52503:     if (setter == PropertyStub)
52503:         setter = NULL;
52503:     if (shape->attrs == attrs && shape->getter() == getter && shape->setter() == setter)
52503:         return shape;
52503: 
52503:     Shape child(shape->id, getter, setter, shape->slot, attrs, shape->flags, shape->shortid);
53650: 
52503:     if (inDictionaryMode()) {
52503:         shape->removeFromDictionary(this);
52503:         newShape = Shape::newDictionaryShape(cx, child, &lastProp);
52503:         if (newShape) {
52503:             JS_ASSERT(newShape == lastProp);
52503: 
53651:             /*
53651:              * Let tableShape be the shape with non-null table, either the one
53651:              * we removed or the parent of lastProp.
53651:              */
53651:             const Shape *tableShape = shape->table ? shape : lastProp->parent;
53651: 
53651:             if (PropertyTable *table = tableShape->table) {
53651:                 /* Overwrite shape with newShape in the property table. */
52503:                 Shape **spp = table->search(shape->id, true);
52503:                 SHAPE_STORE_PRESERVING_COLLISION(spp, newShape);
52503: 
53651:                 /* Hand the table off from tableShape to newShape. */
53651:                 tableShape->setTable(NULL);
52503:                 newShape->setTable(table);
52503:             }
52503: 
52503:             updateFlags(newShape);
52503:             updateShape(cx);
52503:         }
52503:     } else if (shape == lastProp) {
52503:         newShape = getChildProperty(cx, shape->parent, child);
52503: #ifdef DEBUG
52503:         if (newShape) {
52503:             JS_ASSERT(newShape == lastProp);
52503:             if (newShape->table) {
52503:                 Shape **spp = nativeSearch(shape->id);
52503:                 JS_ASSERT(SHAPE_FETCH(spp) == newShape);
52503:             }
52503:         }
52503: #endif
52503:     } else {
52503:         /*
52503:          * Let JSObject::putProperty handle this |overwriting| case, including
52503:          * the conservation of shape->slot (if it's valid). We must not call
52503:          * JSObject::removeProperty because it will free a valid shape->slot and
52503:          * JSObject::putProperty won't re-allocate it.
52503:          */
52503:         newShape = putProperty(cx, child.id, child.rawGetter, child.rawSetter, child.slot,
52503:                                child.attrs, child.flags, child.shortid);
52503:     }
52503: 
52503: #ifdef DEBUG
53651:     CHECK_SHAPE_CONSISTENCY(this);
52503:     if (newShape)
52503:         METER(changes);
52503:     else
52503:         METER(changeFails);
52503: #endif
52503:     return newShape;
52503: }
52503: 
52503: bool
52503: JSObject::removeProperty(JSContext *cx, jsid id)
52503: {
52503:     if (sealed()) {
52503:         reportReadOnlyScope(cx);
52503:         return false;
52503:     }
52503: 
52503:     Shape **spp = nativeSearch(id);
52503:     Shape *shape = SHAPE_FETCH(spp);
52503:     if (!shape) {
52503:         METER(uselessRemoves);
52503:         return true;
52503:     }
52503: 
52503:     /* If shape is not the last property added, switch to dictionary mode. */
52503:     if (shape != lastProp) {
52503:         if (!inDictionaryMode()) {
52503:             if (!toDictionaryMode(cx))
52503:                 return false;
52503:             spp = nativeSearch(shape->id);
52503:             shape = SHAPE_FETCH(spp);
52503:         }
52503:         JS_ASSERT(SHAPE_FETCH(spp) == shape);
52503:     }
52503: 
52503:     /* First, if shape is unshared and not cleared, free its slot number. */
53650:     bool hadSlot = !shape->isAlias() && containsSlot(shape->slot);
53650:     if (hadSlot) {
52503:         freeSlot(cx, shape->slot);
52503:         JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
52503:     }
52503: 
52503:     /*
52503:      * Next, consider removing id from lastProp->table if in dictionary mode,
52503:      * by setting its entry to a removed or free sentinel.
52503:      */
52503:     if (inDictionaryMode()) {
52503:         PropertyTable *table = lastProp->table;
52503: 
52503:         if (SHAPE_HAD_COLLISION(*spp)) {
52503:             JS_ASSERT(table);
52503:             *spp = SHAPE_REMOVED;
52503:             ++table->removedCount;
52503:             --table->entryCount;
52503:         } else {
52503:             METER(removeFrees);
52503:             if (table) {
52503:                 *spp = NULL;
52503:                 --table->entryCount;
52503: 
52503: #ifdef DEBUG
52503:                 /*
52503:                  * Check the consistency of the table but limit the number of
52503:                  * checks not to alter significantly the complexity of the
52503:                  * delete in debug builds, see bug 534493.
52503:                  */
52503:                 const Shape *aprop = lastProp;
53651:                 for (int n = 50; --n >= 0 && aprop->parent; aprop = aprop->parent)
52503:                     JS_ASSERT_IF(aprop != shape, nativeContains(*aprop));
52503: #endif
52503:             }
52503:         }
52503: 
52503:         /*
52503:          * Remove shape from its non-circular doubly linked list, setting this
53842:          * object's shape first so the updateShape(cx) after this if-else will
53842:          * generate a fresh shape for this scope. We need a fresh shape for all
53842:          * deletions, even of lastProp. Otherwise, a shape number can replay
53842:          * and caches may return get deleted DictionaryShapes! See bug 595365.
52503:          */
52503:         setOwnShape(lastProp->shape);
53650: 
53650:         Shape *oldLastProp = lastProp;
52503:         shape->removeFromDictionary(this);
53650:         if (table) {
53650:             if (shape == oldLastProp) {
53650:                 JS_ASSERT(shape->table == table);
53650:                 JS_ASSERT(shape->parent == lastProp);
53652:                 JS_ASSERT(shape->slotSpan >= lastProp->slotSpan);
53652:                 JS_ASSERT_IF(hadSlot, shape->slot + 1 <= shape->slotSpan);
53650: 
53650:                 /*
53650:                  * If the dictionary table's freelist is non-empty, we must
53652:                  * preserve lastProp->slotSpan. We can't reduce slotSpan even
53652:                  * by one or we might lose non-decreasing slotSpan order.
53650:                  */
53652:                 if (table->freelist != SHAPE_INVALID_SLOT)
53652:                     lastProp->slotSpan = shape->slotSpan;
53650:             }
53650: 
53650:             /* Hand off table from old to new lastProp. */
53650:             oldLastProp->setTable(NULL);
52503:             lastProp->setTable(table);
53650:         }
52503:     } else {
52503:         /*
52503:          * Non-dictionary-mode property tables are shared immutables, so all we
52503:          * need do is retract lastProp and we'll either get or else lazily make
52503:          * via a later maybeHash the exact table for the new property lineage.
52503:          */
52503:         JS_ASSERT(shape == lastProp);
52503:         removeLastProperty();
52503:     }
52503:     updateShape(cx);
52503: 
52503:     /* Last, consider shrinking table if its load factor is <= .25. */
52503:     if (PropertyTable *table = lastProp->table) {
52503:         uint32 size = table->capacity();
52503:         if (size > PropertyTable::MIN_SIZE && table->entryCount <= size >> 2) {
52503:             METER(shrinks);
52509:             (void) table->change(cx, -1);
52503:         }
52503:     }
52503: 
53651:     CHECK_SHAPE_CONSISTENCY(this);
52503:     LIVE_SCOPE_METER(cx, --cx->runtime->liveObjectProps);
52503:     METER(removes);
52503:     return true;
52503: }
52503: 
30733: void
52503: JSObject::clear(JSContext *cx)
52503: {
52503:     LIVE_SCOPE_METER(cx, cx->runtime->liveObjectProps -= propertyCount());
52503: 
52503:     Shape *shape = lastProp;
52503:     JS_ASSERT(inDictionaryMode() == shape->inDictionary());
52503: 
52503:     while (shape->parent) {
52503:         shape = shape->parent;
52503:         JS_ASSERT(inDictionaryMode() == shape->inDictionary());
52503:     }
52503:     JS_ASSERT(shape->isEmptyShape());
52503: 
52503:     if (inDictionaryMode())
52503:         shape->listp = &lastProp;
52503: 
52503:     /*
52503:      * We have rewound to a uniquely-shaped empty scope, so we don't need an
52503:      * override for this object's shape.
52503:      */
52503:     clearOwnShape();
52503:     setMap(shape);
52503: 
52503:     LeaveTraceIfGlobalObject(cx, this);
52503:     JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
53651:     CHECK_SHAPE_CONSISTENCY(this);
52503: }
52503: 
52503: void
52503: JSObject::generateOwnShape(JSContext *cx)
30258: {
33560: #ifdef JS_TRACER
53545:     JS_ASSERT_IF(!parent && JS_ON_TRACE(cx), cx->bailExit);
52503:      LeaveTraceIfGlobalObject(cx, this);
30733: 
33560:     /*
33560:      * If we are recording, here is where we forget already-guarded shapes.
33560:      * Any subsequent property operation upon object on the trace currently
33560:      * being recorded will re-guard (and re-memoize).
33560:      */
37741:     TraceMonitor *tm = &JS_TRACE_MONITOR(cx);
33560:     if (TraceRecorder *tr = tm->recorder)
52503:         tr->forgetGuardedShapesForObject(this);
33560: #endif
33560: 
52503:     setOwnShape(js_GenerateShape(cx, false));
    1: }
    1: 
    1: void
52503: JSObject::deletingShapeChange(JSContext *cx, const Shape &shape)
    1: {
52503:     JS_ASSERT(!JSID_IS_VOID(shape.id));
30733:     generateOwnShape(cx);
30258: }
30258: 
32658: bool
52503: JSObject::methodShapeChange(JSContext *cx, const Shape &shape)
32658: {
52503:     JS_ASSERT(!JSID_IS_VOID(shape.id));
52503:     if (shape.isMethod()) {
32658: #ifdef DEBUG
52503:         const Value &prev = lockedGetSlot(shape.slot);
52503:         JS_ASSERT(&shape.methodObject() == &prev.toObject());
52503:         JS_ASSERT(canHaveMethodBarrier());
32658:         JS_ASSERT(hasMethodBarrier());
52503:         JS_ASSERT(!shape.rawSetter || shape.rawSetter == js_watch_set);
32658: #endif
32658: 
32658:         /*
52503:          * Pass null to make a stub getter, but pass along shape.rawSetter to
52503:          * preserve watchpoints. Clear Shape::METHOD from flags as we are
52503:          * despecializing from a method memoized in the property tree to a
32658:          * plain old function-valued property.
32658:          */
52503:         if (!putProperty(cx, shape.id, NULL, shape.rawSetter, shape.slot,
52503:                          shape.attrs,
52503:                          shape.getFlags() & ~Shape::METHOD,
52503:                          shape.shortid)) {
32658:             return false;
32658:         }
52503:     }
32658: 
32658:     generateOwnShape(cx);
32658:     return true;
32658: }
32658: 
32658: bool
52503: JSObject::methodShapeChange(JSContext *cx, uint32 slot)
30258: {
32658:     if (!hasMethodBarrier()) {
30733:         generateOwnShape(cx);
32658:     } else {
52503:         for (Shape::Range r = lastProp->all(); !r.empty(); r.popFront()) {
52503:             const Shape &shape = r.front();
52503:             JS_ASSERT(!JSID_IS_VOID(shape.id));
52503:             if (shape.slot == slot)
52503:                 return methodShapeChange(cx, shape);
32658:         }
32658:     }
32658:     return true;
30258: }
30258: 
30258: void
52503: JSObject::protoShapeChange(JSContext *cx)
30258: {
30733:     generateOwnShape(cx);
30258: }
30258: 
30258: void
52503: JSObject::shadowingShapeChange(JSContext *cx, const Shape &shape)
30258: {
52503:     JS_ASSERT(!JSID_IS_VOID(shape.id));
30733:     generateOwnShape(cx);
30258: }
30258: 
40871: bool
52503: JSObject::globalObjectOwnShapeChange(JSContext *cx)
40871: {
40871:     generateOwnShape(cx);
40871:     return !js_IsPropertyCacheDisabled(cx);
40871: }
40871: 
  583: #ifdef DEBUG
  583: static void
  583: PrintPropertyGetterOrSetter(JSTracer *trc, char *buf, size_t bufsize)
  583: {
52503:     Shape *shape;
 4529:     jsid id;
  583:     size_t n;
  583:     const char *name;
  583: 
  583:     JS_ASSERT(trc->debugPrinter == PrintPropertyGetterOrSetter);
52503:     shape = (Shape *)trc->debugPrintArg;
52503:     id = shape->id;
48470:     JS_ASSERT(!JSID_IS_VOID(id));
  583:     name = trc->debugPrintIndex ? js_setter_str : js_getter_str;
  583: 
 8367:     if (JSID_IS_ATOM(id)) {
  583:         n = js_PutEscapedString(buf, bufsize - 1,
48470:                                 JSID_TO_STRING(id), 0);
 4529:         if (n < bufsize - 1)
 8367:             JS_snprintf(buf + n, bufsize - n, " %s", name);
52503:     } else if (JSID_IS_INT(shape->id)) {
 4529:         JS_snprintf(buf, bufsize, "%d %s", JSID_TO_INT(id), name);
  583:     } else {
  583:         JS_snprintf(buf, bufsize, "<object> %s", name);
  583:     }
  583: }
32658: 
32658: static void
32658: PrintPropertyMethod(JSTracer *trc, char *buf, size_t bufsize)
32658: {
52503:     Shape *shape;
32658:     jsid id;
32658:     size_t n;
32658: 
32658:     JS_ASSERT(trc->debugPrinter == PrintPropertyMethod);
52503:     shape = (Shape *)trc->debugPrintArg;
52503:     id = shape->id;
48470:     JS_ASSERT(!JSID_IS_VOID(id));
32658: 
32658:     JS_ASSERT(JSID_IS_ATOM(id));
48470:     n = js_PutEscapedString(buf, bufsize - 1, JSID_TO_STRING(id), 0);
32658:     if (n < bufsize - 1)
32658:         JS_snprintf(buf + n, bufsize - n, " method");
32658: }
  583: #endif
  583: 
    1: void
52503: Shape::trace(JSTracer *trc) const
    1: {
 5975:     if (IS_GC_MARKING_TRACER(trc))
38562:         mark();
52503: 
48470:     MarkId(trc, id, "id");
    1: 
30258:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
39894:         if ((attrs & JSPROP_GETTER) && rawGetter) {
30258:             JS_SET_TRACING_DETAILS(trc, PrintPropertyGetterOrSetter, this, 0);
48470:             Mark(trc, getterObject(), JSTRACE_OBJECT);
    1:         }
39894:         if ((attrs & JSPROP_SETTER) && rawSetter) {
30258:             JS_SET_TRACING_DETAILS(trc, PrintPropertyGetterOrSetter, this, 1);
48470:             Mark(trc, setterObject(), JSTRACE_OBJECT);
    1:         }
    1:     }
32658: 
32658:     if (isMethod()) {
32658:         JS_SET_TRACING_DETAILS(trc, PrintPropertyMethod, this, 0);
48470:         Mark(trc, &methodObject(), JSTRACE_OBJECT);
32658:     }
    1: }
