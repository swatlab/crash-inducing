   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* vim: set ts=2 sw=2 et tw=78: */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
   1:  *   Mike Pinkerton (pinkerton@netscape.com)
   1:  *   Dean Tessman <dean_tessman@hotmail.com>
   1:  *   Ben Goodger <ben@netscape.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: 
   1: #include "nsMenuPopupFrame.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsIContent.h"
 998: #include "nsContentUtils.h"
   1: #include "prtypes.h"
   1: #include "nsIAtom.h"
   1: #include "nsPresContext.h"
   1: #include "nsStyleContext.h"
   1: #include "nsCSSRendering.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsIViewManager.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsMenuFrame.h"
   1: #include "nsIPopupSetFrame.h"
   1: #include "nsPIDOMWindow.h"
   1: #include "nsIDOMScreen.h"
   1: #include "nsIPresShell.h"
   1: #include "nsFrameManager.h"
   1: #include "nsIDocument.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsRect.h"
   1: #include "nsIDOMXULDocument.h"
   1: #include "nsILookAndFeel.h"
   1: #include "nsIComponentManager.h"
   1: #include "nsBoxLayoutState.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsIScrollableFrame.h"
   1: #include "nsGUIEvent.h"
   1: #include "nsIRootBox.h"
   1: #include "nsIDocShellTreeItem.h"
   1: #include "nsReadableUtils.h"
   1: #include "nsUnicharUtils.h"
   1: #include "nsCSSFrameConstructor.h"
   1: #include "nsIBoxLayout.h"
   1: #include "nsIPopupBoxObject.h"
   1: #include "nsIReflowCallback.h"
   1: #ifdef XP_WIN
   1: #include "nsISound.h"
   1: #endif
   1: 
   1: const PRInt32 kMaxZ = 0x7fffffff; //XXX: Shouldn't there be a define somewhere for MaxInt for PRInt32
   1: 
   1: 
   1: static nsIPopupSetFrame*
   1: GetPopupSetFrame(nsPresContext* aPresContext)
   1: {
   1:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresContext->PresShell());
   1:   if (!rootBox)
   1:     return nsnull;
   1: 
   1:   nsIFrame* popupSetFrame = rootBox->GetPopupSetFrame();
   1:   if (!popupSetFrame)
   1:     return nsnull;
   1: 
   1:   nsIPopupSetFrame* popupSet = nsnull;
   1:   CallQueryInterface(popupSetFrame, &popupSet);
   1:   return popupSet;
   1: }
   1: 
   1: 
   1: // NS_NewMenuPopupFrame
   1: //
   1: // Wrapper for creating a new menu popup container
   1: //
   1: nsIFrame*
   1: NS_NewMenuPopupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsMenuPopupFrame (aPresShell, aContext);
   1: }
   1: 
   1: NS_IMETHODIMP_(nsrefcnt) 
   1: nsMenuPopupFrame::AddRef(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP_(nsrefcnt) 
   1: nsMenuPopupFrame::Release(void)
   1: {
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: //
   1: // QueryInterface
   1: //
   1: NS_INTERFACE_MAP_BEGIN(nsMenuPopupFrame)
   1:   NS_INTERFACE_MAP_ENTRY(nsIMenuParent)
   1: NS_INTERFACE_MAP_END_INHERITING(nsBoxFrame)
   1: 
   1: 
   1: //
   1: // nsMenuPopupFrame ctor
   1: //
   1: nsMenuPopupFrame::nsMenuPopupFrame(nsIPresShell* aShell, nsStyleContext* aContext)
   1:   :nsBoxFrame(aShell, aContext),
   1:   mCurrentMenu(nsnull),
   1:   mTimerMenu(nsnull),
   1:   mCloseTimer(nsnull),
   1:   mMenuCanOverlapOSBar(PR_FALSE),
   1:   mShouldAutoPosition(PR_TRUE),
   1:   mShouldRollup(PR_TRUE),
 677:   mConsumeRollupEvent(nsIPopupBoxObject::ROLLUP_DEFAULT),
 677:   mInContentShell(PR_TRUE)
   1: {
   1:   SetIsContextMenu(PR_FALSE);   // we're not a context menu by default
   1: } // ctor
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::Init(nsIContent*      aContent,
   1:                        nsIFrame*        aParent,
   1:                        nsIFrame*        aPrevInFlow)
   1: {
   1:   nsresult rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
1412:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Set up a mediator which can be used for callbacks on this frame.
   1:   mTimerMediator = new nsMenuPopupTimerMediator(this);
   1:   if (NS_UNLIKELY(!mTimerMediator))
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
 238:   nsPresContext* presContext = PresContext();
   1: 
   1:   // lookup if we're allowed to overlap the OS bar (menubar/taskbar) from the
   1:   // look&feel object
   1:   PRBool tempBool;
   1:   presContext->LookAndFeel()->
   1:     GetMetric(nsILookAndFeel::eMetric_MenusCanOverlapOSBar, tempBool);
   1:   mMenuCanOverlapOSBar = tempBool;
   1: 
1412:   rv = CreateViewForFrame(presContext, this, GetStyleContext(), PR_TRUE);
1412:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Now that we've made a view, remove it and insert it at the correct
   1:   // position in the view hierarchy (as the root view).  We do this so that we
   1:   // can draw the menus outside the confines of the window.
   1:   nsIView* ourView = GetView();
   1:   nsIViewManager* viewManager = ourView->GetViewManager();
   1: 
   1:   // Remove the view from its old position.
   1:   viewManager->RemoveChild(ourView);
   1: 
   1:   // Reinsert ourselves as the root view with a maximum z-index.
   1:   nsIView* rootView;
   1:   viewManager->GetRootView(rootView);
   1:   viewManager->SetViewZIndex(ourView, PR_FALSE, kMaxZ);
   1:   viewManager->InsertChild(rootView, ourView, nsnull, PR_TRUE);
   1: 
   1:   // XXX Hack. The menu's view should float above all other views,
   1:   // so we use the nsIView::SetFloating() to tell the view manager
   1:   // about that constraint.
   1:   viewManager->SetViewFloating(ourView, PR_TRUE);
   1: 
 677:   nsCOMPtr<nsISupports> cont = PresContext()->GetContainer();
 677:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
 677:   PRInt32 type = -1;
 677:   if (dsti && NS_SUCCEEDED(dsti->GetItemType(&type)) &&
 677:       type == nsIDocShellTreeItem::typeChrome)
 677:     mInContentShell = PR_FALSE;
 677: 
   1:   // XXX make sure we are hidden (shouldn't this be done automatically?)
   1:   viewManager->SetViewVisibility(ourView, nsViewVisibility_kHide);
   1:   if (!ourView->HasWidget()) {
   1:     CreateWidgetForView(ourView);
   1:   }
   1: 
   1:   MoveToAttributePosition();
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsMenuPopupFrame::CreateWidgetForView(nsIView* aView)
   1: {
   1:   // Create a widget for ourselves.
   1:   nsWidgetInitData widgetData;
   1:   widgetData.mWindowType = eWindowType_popup;
   1:   widgetData.mBorderStyle = eBorderStyle_default;
   1:   widgetData.clipSiblings = PR_TRUE;
   1: 
1345:   PRBool viewHasTransparentContent = !mInContentShell &&
1345:                                      nsLayoutUtils::FrameHasTransparency(this);
   1:   nsIContent* parentContent = GetContent()->GetParent();
   1:   nsIAtom *tag = nsnull;
   1:   if (parentContent)
   1:     tag = parentContent->Tag();
   1:   widgetData.mDropShadow = !(viewHasTransparentContent || tag == nsGkAtoms::menulist);
   1:   
   1: #if defined(XP_MACOSX) || defined(XP_BEOS)
   1:   static NS_DEFINE_IID(kCPopupCID,  NS_POPUP_CID);
   1:   aView->CreateWidget(kCPopupCID, &widgetData, nsnull, PR_TRUE, PR_TRUE, 
   1:                       eContentTypeUI);
   1: #else
   1:   static NS_DEFINE_IID(kCChildCID,  NS_CHILD_CID);
   1:   aView->CreateWidget(kCChildCID, &widgetData, nsnull, PR_TRUE, PR_TRUE);
   1: #endif
   1:   aView->GetWidget()->SetWindowTranslucency(viewHasTransparentContent);
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::InvalidateInternal(const nsRect& aDamageRect,
   1:                                      nscoord aX, nscoord aY, nsIFrame* aForChild,
   1:                                      PRBool aImmediate)
   1: {
   1:   InvalidateRoot(aDamageRect, aX, aY, aImmediate);
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::GetLayoutFlags(PRUint32& aFlags)
   1: {
   1:   aFlags = NS_FRAME_NO_SIZE_VIEW | NS_FRAME_NO_MOVE_VIEW | NS_FRAME_NO_VISIBILITY;
   1: }
   1: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // GetViewOffset
   1: //   Retrieves the offset of the given view with the root view, in the 
   1: //   coordinate system of the root view. 
   1: void
   1: nsMenuPopupFrame::GetViewOffset(nsIView* aView, nsPoint& aPoint)
   1: {
   1:   // Notes:
   1:   //   1) The root view is the client area of the toplevel window that
   1:   //      this popup is anchored to. 
   1:   //   2) Each menupopup is a child of the root view (see 
   1:   //      nsMenuPopupFrame::Init())
   1:   //   3) The coordinates that we return are the total distance between 
   1:   //      the top left of the start view and the origin of the root view.
   1:   
   1:   // Keep track of the root view so that we know to stop there
   1:   nsIView* rootView;
   1:   aView->GetViewManager()->GetRootView(rootView);
   1:   aPoint = aView->GetOffsetTo(rootView);
   1: }
   1: 
   1: ///////////////////////////////////////////////////////////////////////////////
   1: // GetRootViewForPopup
   1: //   Retrieves the view for the popup widget that contains the given frame. 
   1: //   If the given frame is not contained by a popup widget, return the
   1: //   root view.  This is the root view of the pres context's
   1: //   viewmanager if aStopAtViewManagerRoot is true; otherwise it's the
   1: //   root view of the root viewmanager.
   1: void
   1: nsMenuPopupFrame::GetRootViewForPopup(nsIFrame* aStartFrame,
   1:                                       PRBool    aStopAtViewManagerRoot,
   1:                                       nsIView** aResult)
   1: {
   1:   *aResult = nsnull;
   1: 
   1:   nsIView* view = aStartFrame->GetClosestView();
   1:   NS_ASSERTION(view, "frame must have a closest view!");
   1:   if (view) {
   1:     nsIView* rootView = nsnull;
   1:     if (aStopAtViewManagerRoot) {
   1:       view->GetViewManager()->GetRootView(rootView);
   1:     }
   1:     
   1:     while (view) {
   1:       // Walk up the view hierarchy looking for a view whose widget has a 
   1:       // window type of eWindowType_popup - in other words a popup window
   1:       // widget. If we find one, this is the view we want. 
   1:       nsIWidget* widget = view->GetWidget();
   1:       if (widget) {
   1:         nsWindowType wtype;
   1:         widget->GetWindowType(wtype);
   1:         if (wtype == eWindowType_popup) {
   1:           *aResult = view;
   1:           return;
   1:         }
   1:       }
   1: 
   1:       if (aStopAtViewManagerRoot && view == rootView) {
   1:         *aResult = view;
   1:         return;
   1:       }
   1: 
   1:       nsIView* temp = view->GetParent();
   1:       if (!temp) {
   1:         // Otherwise, we've walked all the way up to the root view and not
   1:         // found a view for a popup window widget. Just return the root view.
   1:         *aResult = view;
   1:       }
   1:       view = temp;
   1:     }
   1:   }
   1: }
   1: 
   1: 
   1: //
   1: // AdjustClientXYForNestedDocuments
   1: // 
   1: // almost certainly, the document where the mouse was clicked is not
   1: // the document that contains the popup, especially if we're viewing a page
   1: // with frames. Thus we need to make adjustments to the client coordinates to
   1: // take this into account and get them back into the relative coordinates of
   1: // this document.
   1: //
   1: void
   1: nsMenuPopupFrame::AdjustClientXYForNestedDocuments ( nsIDOMXULDocument* inPopupDoc, nsIPresShell* inPopupShell, 
   1:                                                          PRInt32 inClientX, PRInt32 inClientY, 
   1:                                                          PRInt32* outAdjX, PRInt32* outAdjY )
   1: {
   1:   if ( !inPopupDoc || !outAdjX || !outAdjY )
   1:     return;
   1: 
   1:   // Find the widget associated with the popup's document
   1:   nsIWidget* popupDocumentWidget = nsnull;
   1:   nsIViewManager* viewManager = inPopupShell->GetViewManager();
   1:   if ( viewManager ) {  
   1:     nsIView* rootView;
   1:     viewManager->GetRootView(rootView);
   1:     if ( rootView )
   1:       popupDocumentWidget = rootView->GetNearestWidget(nsnull);
   1:   }
   1:   NS_ASSERTION(popupDocumentWidget, "ACK, BAD WIDGET");
   1:   
   1:   // Find the widget associated with the target's document.
   1:   // For tooltips, we check the document's tooltipNode (which is set by
   1:   // nsXULTooltipListener).  For regular popups, use popupNode (set by
   1:   // nsXULPopupListener).
   1: 
   1:   nsCOMPtr<nsIDOMNode> targetNode;
   1:   if (mContent->Tag() == nsGkAtoms::tooltip)
   1:     inPopupDoc->TrustedGetTooltipNode(getter_AddRefs(targetNode));
   1:   else
   1:     inPopupDoc->TrustedGetPopupNode(getter_AddRefs(targetNode));
   1: 
   1:   //NS_ASSERTION(targetNode, "no popup/tooltip node on document!");
   1:   nsCOMPtr<nsIContent> targetAsContent ( do_QueryInterface(targetNode) );
   1:   nsIWidget* targetDocumentWidget = nsnull;
   1:   if ( targetAsContent ) {
   1:     nsCOMPtr<nsIDocument> targetDocument = targetAsContent->GetDocument();
   1:     if (targetDocument) {
 981:       nsIPresShell *shell = targetDocument->GetPrimaryShell();
   1:       if ( shell ) {
   1:         // We might be inside a popup widget. If so, we need to use that widget and
   1:         // not the root view's widget.
   1:         nsIFrame* targetFrame = shell->GetPrimaryFrameFor(targetAsContent);
   1:         nsIView* parentView = nsnull;
   1:         if (targetFrame) {
   1:           GetRootViewForPopup(targetFrame, PR_TRUE, &parentView);
   1:           if (parentView) {
   1:             targetDocumentWidget = parentView->GetNearestWidget(nsnull);
   1:           }
   1:         }
   1:         if (!targetDocumentWidget) {
   1:           // We aren't inside a popup. This means we should use the root view's
   1:           // widget.
   1:           nsIViewManager* viewManagerTarget = shell->GetViewManager();
   1:           if ( viewManagerTarget ) {
   1:             nsIView* rootViewTarget;
   1:             viewManagerTarget->GetRootView(rootViewTarget);
   1:             if ( rootViewTarget ) {
   1:               targetDocumentWidget = rootViewTarget->GetNearestWidget(nsnull);
   1:             }
   1:           }
   1:         }
   1:       }
   1:     }
   1:   }
   1:   //NS_ASSERTION(targetDocumentWidget, "ACK, BAD TARGET");
   1: 
   1:   // the offset we need is the difference between the upper left corner of the two widgets. Use
   1:   // screen coordinates to find the global offset between them.
   1:   nsRect popupDocTopLeft;
   1:   if ( popupDocumentWidget ) {
   1:     nsRect topLeftClient ( 0, 0, 10, 10 );
   1:     popupDocumentWidget->WidgetToScreen ( topLeftClient, popupDocTopLeft );
   1:   }
   1:   nsRect targetDocTopLeft;
   1:   if ( targetDocumentWidget ) {
   1:     nsRect topLeftClient ( 0, 0, 10, 10 );
   1:     targetDocumentWidget->WidgetToScreen ( topLeftClient, targetDocTopLeft );
   1:   }
   1:   nsPoint pixelOffset ( targetDocTopLeft.x - popupDocTopLeft.x, targetDocTopLeft.y - popupDocTopLeft.y );
   1: 
 238:   nsPresContext* context = PresContext();
   1:   *outAdjX = nsPresContext::CSSPixelsToAppUnits(inClientX) +
   1:              context->DevPixelsToAppUnits(pixelOffset.x);
   1:   *outAdjY = nsPresContext::CSSPixelsToAppUnits(inClientY) +
   1:              context->DevPixelsToAppUnits(pixelOffset.y);
   1:   
   1: } // AdjustClientXYForNestedDocuments
   1: 
   1: 
   1: //
   1: // AdjustPositionForAnchorAlign
   1: // 
   1: // Uses the |popupanchor| and |popupalign| attributes on the popup to move the popup around and
   1: // anchor it to its parent. |outFlushWithTopBottom| will be TRUE if the popup is flush with either
   1: // the top or bottom edge of its parent, and FALSE if it is flush with the left or right edge of
   1: // the parent.
   1: // 
   1: void
   1: nsMenuPopupFrame::AdjustPositionForAnchorAlign ( PRInt32* ioXPos, PRInt32* ioYPos, const nsRect & inParentRect,
   1:                                                     const nsString& aPopupAnchor, const nsString& aPopupAlign,
   1:                                                     PRBool* outFlushWithTopBottom )
   1: {
   1:   nsAutoString popupAnchor(aPopupAnchor);
   1:   nsAutoString popupAlign(aPopupAlign);
   1: 
   1:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
   1:     if (popupAnchor.EqualsLiteral("topright"))
   1:       popupAnchor.AssignLiteral("topleft");
   1:     else if (popupAnchor.EqualsLiteral("topleft"))
   1:       popupAnchor.AssignLiteral("topright");
   1:     else if (popupAnchor.EqualsLiteral("bottomleft"))
   1:       popupAnchor.AssignLiteral("bottomright");
   1:     else if (popupAnchor.EqualsLiteral("bottomright"))
   1:       popupAnchor.AssignLiteral("bottomleft");
   1: 
   1:     if (popupAlign.EqualsLiteral("topright"))
   1:       popupAlign.AssignLiteral("topleft");
   1:     else if (popupAlign.EqualsLiteral("topleft"))
   1:       popupAlign.AssignLiteral("topright");
   1:     else if (popupAlign.EqualsLiteral("bottomleft"))
   1:       popupAlign.AssignLiteral("bottomright");
   1:     else if (popupAnchor.EqualsLiteral("bottomright"))
   1:       popupAlign.AssignLiteral("bottomleft");
   1:   }
   1: 
   1:   // Adjust position for margins at the aligned corner
   1:   nsMargin margin;
   1:   GetStyleMargin()->GetMargin(margin);
   1:   if (popupAlign.EqualsLiteral("topleft")) {
   1:     *ioXPos += margin.left;
   1:     *ioYPos += margin.top;
   1:   } else if (popupAlign.EqualsLiteral("topright")) {
   1:     *ioXPos += margin.right;
   1:     *ioYPos += margin.top;
   1:   } else if (popupAlign.EqualsLiteral("bottomleft")) {
   1:     *ioXPos += margin.left;
   1:     *ioYPos += margin.bottom;
   1:   } else if (popupAlign.EqualsLiteral("bottomright")) {
   1:     *ioXPos += margin.right;
   1:     *ioYPos += margin.bottom;
   1:   }
   1:   
   1:   if (popupAnchor.EqualsLiteral("topright") && popupAlign.EqualsLiteral("topleft")) {
   1:     *ioXPos += inParentRect.width;
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("topleft") && popupAlign.EqualsLiteral("topleft")) {
   1:     *outFlushWithTopBottom = PR_TRUE;
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("topright") && popupAlign.EqualsLiteral("bottomright")) {
   1:     *ioXPos -= (mRect.width - inParentRect.width);
   1:     *ioYPos -= mRect.height;
   1:     *outFlushWithTopBottom = PR_TRUE;
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("bottomright") && popupAlign.EqualsLiteral("bottomleft")) {
   1:     *ioXPos += inParentRect.width;
   1:     *ioYPos -= (mRect.height - inParentRect.height);
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("bottomright") && popupAlign.EqualsLiteral("topright")) {
   1:     *ioXPos -= (mRect.width - inParentRect.width);
   1:     *ioYPos += inParentRect.height;
   1:     *outFlushWithTopBottom = PR_TRUE;
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("topleft") && popupAlign.EqualsLiteral("topright")) {
   1:     *ioXPos -= mRect.width;
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("topleft") && popupAlign.EqualsLiteral("bottomleft")) {
   1:     *ioYPos -= mRect.height;
   1:     *outFlushWithTopBottom = PR_TRUE;
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("bottomleft") && popupAlign.EqualsLiteral("bottomright")) {
   1:     *ioXPos -= mRect.width;
   1:     *ioYPos -= (mRect.height - inParentRect.height);
   1:   }
   1:   else if (popupAnchor.EqualsLiteral("bottomleft") && popupAlign.EqualsLiteral("topleft")) {
   1:     *ioYPos += inParentRect.height;
   1:     *outFlushWithTopBottom = PR_TRUE;
   1:   }
   1:   else
   1:     NS_WARNING ( "Hmmm, looks like you've hit a anchor/align case we weren't setup for." );
   1: 
   1: } // AdjustPositionForAnchorAlign
   1: 
   1: 
   1: //
   1: // IsMoreRoomOnOtherSideOfParent
   1: //
   1: // Determine if there is more room on the screen for the popup to live if it was positioned
   1: // on the flip side of the parent from the side it is flush against (ie, if it's top edge was
   1: // flush against the bottom, is there more room if its bottom edge were flush against the top)
   1: //
   1: PRBool
   1: nsMenuPopupFrame::IsMoreRoomOnOtherSideOfParent ( PRBool inFlushAboveBelow, PRInt32 inScreenViewLocX, PRInt32 inScreenViewLocY,
   1:                                                      const nsRect & inScreenParentFrameRect, PRInt32 inScreenTopTwips, PRInt32 inScreenLeftTwips,
   1:                                                      PRInt32 inScreenBottomTwips, PRInt32 inScreenRightTwips )
   1: {
   1:   PRBool switchSides = PR_FALSE;
   1:   if ( inFlushAboveBelow ) {
   1:     PRInt32 availAbove = inScreenParentFrameRect.y - inScreenTopTwips;
   1:     PRInt32 availBelow = inScreenBottomTwips - (inScreenParentFrameRect.y + inScreenParentFrameRect.height) ;
   1:     if ( inScreenViewLocY > inScreenParentFrameRect.y )       // view is now below parent
   1:       switchSides = availAbove > availBelow;
   1:     else
   1:       switchSides = availBelow > availAbove;
   1:   }
   1:   else {
   1:     PRInt32 availLeft = inScreenParentFrameRect.x - inScreenLeftTwips;
   1:     PRInt32 availRight = inScreenRightTwips - (inScreenParentFrameRect.x + inScreenParentFrameRect.width) ;
   1:     if ( inScreenViewLocX > inScreenParentFrameRect.x )       // view is now to the right of parent
   1:       switchSides = availLeft > availRight;
   1:     else
   1:       switchSides = availRight > availLeft;           
   1:   }
   1: 
   1:   return switchSides;
   1:   
   1: } // IsMoreRoomOnOtherSideOfParent
   1: 
   1: 
   1: //
   1: // MovePopupToOtherSideOfParent
   1: //
   1: // Move the popup to the other side of the parent (ie, if it the popup's top edge is flush against the
   1: // bottom of its parent, move the popup so that its bottom edge is now flush against the top of its
   1: // parent...same idea for left/right).
   1: //
   1: // NOTE: In moving the popup, it may need to change size in order to stay on the screen. This will
   1: //       have the side effect of touching |mRect|.
   1: //
   1: void
   1: nsMenuPopupFrame::MovePopupToOtherSideOfParent ( PRBool inFlushAboveBelow, PRInt32* ioXPos, PRInt32* ioYPos, 
   1:                                                  PRInt32* ioScreenViewLocX, PRInt32* ioScreenViewLocY,
   1:                                                  const nsRect & inScreenParentFrameRect, PRInt32 inScreenTopTwips, PRInt32 inScreenLeftTwips,
   1:                                                  PRInt32 inScreenBottomTwips, PRInt32 inScreenRightTwips )
   1: {
   1:   if ( inFlushAboveBelow ) {
   1:     if ( *ioScreenViewLocY > inScreenParentFrameRect.y ) {     // view is currently below parent
   1:       // move it above.
   1:       PRInt32 shiftDistY = inScreenParentFrameRect.height + mRect.height;
   1:       *ioYPos -= shiftDistY;
   1:       *ioScreenViewLocY -= shiftDistY;
   1:       // trim it to fit.
   1:       if ( *ioScreenViewLocY < inScreenTopTwips ) {
   1:         PRInt32 trimY = inScreenTopTwips - *ioScreenViewLocY;
   1:         *ioYPos += trimY;
   1:         *ioScreenViewLocY += trimY;
   1:         mRect.height -= trimY;
   1:       }
   1:     }
   1:     else {                                               // view is currently above parent
   1:       // move it below
   1:       PRInt32 shiftDistY = inScreenParentFrameRect.height + mRect.height;
   1:       *ioYPos += shiftDistY;
   1:       *ioScreenViewLocY += shiftDistY;
   1:     }
   1:   }
   1:   else {
   1:     if ( *ioScreenViewLocX > inScreenParentFrameRect.x ) {     // view is currently to the right of the parent
   1:       // move it to the left.
   1:       PRInt32 shiftDistX = inScreenParentFrameRect.width + mRect.width;
   1:       *ioXPos -= shiftDistX;
   1:       *ioScreenViewLocX -= shiftDistX;
   1:       // trim it to fit.
   1:       if ( *ioScreenViewLocX < inScreenLeftTwips ) {
   1:         PRInt32 trimX = inScreenLeftTwips - *ioScreenViewLocX;
   1:         *ioXPos += trimX;
   1:         *ioScreenViewLocX += trimX;
   1:         mRect.width -= trimX;
   1:       }
   1:     }
   1:     else {                                               // view is currently to the right of the parent
   1:       // move it to the right
   1:       PRInt32 shiftDistX = inScreenParentFrameRect.width + mRect.width;
   1:       *ioXPos += shiftDistX;
   1:       *ioScreenViewLocX += shiftDistX;
   1:     }               
   1:   }
   1: 
   1: } // MovePopupToOtherSideOfParent
   1: 
   1: class nsASyncMenuActivation : public nsIReflowCallback
   1: {
   1: public:
   1:   nsASyncMenuActivation(nsIContent* aContent)
   1:     : mContent(aContent)
   1:   {
   1:   }
   1: 
   1:   virtual PRBool ReflowFinished() {
   1:     PRBool shouldFlush = PR_FALSE;
   1:     if (mContent &&
   1:         !mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menuactive,
   1:                                nsGkAtoms::_true, eCaseMatters) &&
   1:         mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menutobedisplayed,
   1:                               nsGkAtoms::_true, eCaseMatters)) {
   1:       mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::menuactive,
   1:                         NS_LITERAL_STRING("true"), PR_TRUE);
   1:       shouldFlush = PR_TRUE;
   1:     }
   1: 
   1:     delete this;
   1:     return shouldFlush;
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> mContent;
   1: };
   1: 
   1: nsresult 
   1: nsMenuPopupFrame::SyncViewWithFrame(nsPresContext* aPresContext,
   1:                                     const nsString& aPopupAnchor,
   1:                                     const nsString& aPopupAlign,
   1:                                     nsIFrame* aFrame, 
   1:                                     PRInt32 aXPos, PRInt32 aYPos)
   1: {
   1:   NS_ENSURE_ARG(aPresContext);
   1:   NS_ENSURE_ARG(aFrame);
   1: 
 677:   if (!mShouldAutoPosition && !mInContentShell) 
   1:     return NS_OK;
   1: 
   1:   // |containingView|
   1:   //   The view that contains the frame that is invoking this popup. This is 
   1:   //   the canvas view inside the scrollport view. It can have negative bounds
   1:   //   if the canvas is scrolled so that part is off screen.
   1:   nsIView* containingView = nsnull;
   1:   nsPoint offset;
   1:   nsMargin margin;
   1:   containingView = aFrame->GetClosestView(&offset);
   1:   if (!containingView)
   1:     return NS_OK;
   1: 
   1:   // |view|
   1:   //   The root view for the popup window widget associated with this frame,
   1:   //   or, the view associated with this frame. 
   1:   nsIView* view = GetView();
   1: 
   1:   // |parentPos|
   1:   //   The distance between the containingView and the root view. This provides
   1:   //   a hint as to where to position the menu relative to the window. 
   1:   nsPoint parentPos;
   1:   GetViewOffset(containingView, parentPos);
   1: 
   1:   // |parentRect|
   1:   //   The dimensions of the frame invoking the popup. 
   1:   nsRect parentRect = aFrame->GetRect();
   1: 
   1:   // get the document and the global script object
   1:   nsIPresShell *presShell = aPresContext->PresShell();
   1:   nsIDocument *document = presShell->GetDocument();
   1: 
   1:   PRBool sizedToPopup = (mContent->Tag() != nsGkAtoms::tooltip) &&
   1:     (nsMenuFrame::IsSizedToPopup(aFrame->GetContent(), PR_FALSE));
   1: 
   1:   // If we stick to our parent's width, set it here before we move the
   1:   // window around, because moving is done with respect to the width...
   1:   if (sizedToPopup) {
   1:     mRect.width = parentRect.width;
   1:   }
   1: 
   1:   // |xpos| and |ypos| hold the x and y positions of where the popup will be moved to,
   1:   // in _twips_, in the coordinate system of the _parent view_.
   1:   PRInt32 xpos = 0, ypos = 0;
   1: 
   1:   // if we are anchored to our parent, there are certain things we don't want to do
   1:   // when repositioning the view to fit on the screen, such as end up positioned over
   1:   // the parent. When doing this reposition, we want to move the popup to the side with
   1:   // the most room. The combination of anchor and alignment dictate if we readjst 
   1:   // above/below or to the left/right.
   1:   PRBool anchoredToParent = PR_FALSE;
   1:   PRBool readjustAboveBelow = PR_FALSE;
   1: 
   1:   if ( aXPos != -1 || aYPos != -1 ) {
   1:   
   1:     // for this case, we've been handed a specific x/y location (in client coordinates) for
   1:     // the popup. However, we may be deeply nested in a frameset, etc and so the client coordinates
   1:     // need some adjusting. 
   1:     nsCOMPtr<nsIDOMXULDocument> xulDoc ( do_QueryInterface(document) );
   1:     AdjustClientXYForNestedDocuments ( xulDoc, presShell, aXPos, aYPos, &xpos, &ypos );
   1: 
   1:     // Add in the top and left margins
   1:     GetStyleMargin()->GetMargin(margin);
   1: 
   1:     xpos += margin.left;
   1:     ypos += margin.top;
   1:   } 
   1:   else {
   1:     anchoredToParent = PR_TRUE;
   1: 
   1:     xpos = parentPos.x + offset.x;
   1:     ypos = parentPos.y + offset.y;
   1:     
   1:     // move the popup according to the anchor/alignment attributes. This will also tell us
   1:     // which axis the popup is flush against in case we have to move it around later.
   1:     AdjustPositionForAnchorAlign ( &xpos, &ypos, parentRect, aPopupAnchor, aPopupAlign, &readjustAboveBelow );    
   1:   }
   1:   
   1:   // Compute info about the screen dimensions. Because of multiple monitor systems,
   1:   // the left or top sides of the screen may be in negative space (main monitor is on the
   1:   // right, etc). We need to be sure to do the right thing.
   1:   nsPIDOMWindow *window = document->GetWindow();
   1:   if (!window)
   1:     return NS_OK;
   1: 
 238:   nsIDeviceContext* devContext = PresContext()->DeviceContext();
   1:   nsRect rect;
   1:   if ( mMenuCanOverlapOSBar ) {
   1:     devContext->GetRect(rect);
   1:   }
   1:   else {
   1:     devContext->GetClientRect(rect);
   1:   }
   1: 
   1:   // keep 3px margin to the right and bottom of the screen for WinXP dropshadow
   1:   rect.width  -= nsPresContext::CSSPixelsToAppUnits(3);
   1:   rect.height -= nsPresContext::CSSPixelsToAppUnits(3);
   1: 
 677:   // for content shells, clip to the client area rather than the screen area
 677:   if (mInContentShell) {
 677:     nsRect rootScreenRect = presShell->GetRootFrame()->GetScreenRect();
 677:     rootScreenRect.ScaleRoundIn(aPresContext->AppUnitsPerDevPixel());
 677:     rect.IntersectRect(rect, rootScreenRect);
 677:   }
 677: 
   1:   PRInt32 screenLeftTwips   = rect.x;
   1:   PRInt32 screenTopTwips    = rect.y;
   1:   PRInt32 screenWidthTwips  = rect.width;
   1:   PRInt32 screenHeightTwips = rect.height;
   1:   PRInt32 screenRightTwips  = rect.XMost();
   1:   PRInt32 screenBottomTwips = rect.YMost();
   1:   
   1:   // Recall that |xpos| and |ypos| are in the coordinate system of the parent view. In
   1:   // order to determine the screen coordinates of where our view will end up, we
   1:   // need to find the x/y position of the parent view in screen coords. That is done
   1:   // by getting the widget associated with the parent view and determining the offset 
   1:   // based on converting (0,0) in its coordinate space to screen coords. We then
   1:   // offset that point by (|xpos|,|ypos|) to get the true screen coordinates of
   1:   // the view. *whew*
   1: 
   1:   // |parentView|
   1:   //   The root view for the window that contains the frame, for frames inside 
   1:   //   menupopups this is the first view inside the popup window widget, for 
   1:   //   frames inside a toplevel window, this is the root view of the toplevel
   1:   //   window.
   1:   nsIView* parentView = nsnull;
   1:   GetRootViewForPopup(aFrame, PR_FALSE, &parentView);
   1:   if (!parentView)
   1:     return NS_OK;
   1: 
   1:   // Use containingView instead of parentView, to account for the scrollarrows
   1:   // that a parent menu might have.
   1: 
   1:   nsPoint parentViewWidgetOffset;
   1:   nsIWidget* parentViewWidget = containingView->GetNearestWidget(&parentViewWidgetOffset);
   1:   nsRect localParentWidgetRect(0,0,0,0), screenParentWidgetRect;
   1:   parentViewWidget->WidgetToScreen ( localParentWidgetRect, screenParentWidgetRect );
   1:   PRInt32 screenViewLocX = aPresContext->DevPixelsToAppUnits(screenParentWidgetRect.x) +
   1:     (xpos - parentPos.x) + parentViewWidgetOffset.x;
   1:   PRInt32 screenViewLocY = aPresContext->DevPixelsToAppUnits(screenParentWidgetRect.y) +
   1:     (ypos - parentPos.y) + parentViewWidgetOffset.y;
   1: 
   1:   if ( anchoredToParent ) {
   1:     
   1:     //
   1:     // Popup is anchored to the parent, guarantee that it does not cover the parent. We
   1:     // shouldn't do anything funky if it will already fit on the screen as is.
   1:     //
   1: 
   1:     ///////////////////////////////////////////////////////////////////////////////
   1:     //
   1:     //                +------------------------+          
   1:     //                |           /\           |
   1:     // parentPos -> - +------------------------+
   1:     //              | |                        |
   1:     //       offset | |                        |
   1:     //              | |                        |
   1:     //              | |                        | (screenViewLocX,screenViewLocY)
   1:     //              - |========================|+--------------
   1:     //                | parentRect           > ||
   1:     //                |========================||
   1:     //                |                        || Submenu 
   1:     //                +------------------------+|  ( = mRect )
   1:     //                |           \/           ||
   1:     //                +------------------------+
   1: 
   1: 
   1: 
   1:     // compute screen coordinates of parent frame so we can play with it. Make sure we put it
   1:     // into twips as everything else is as well.
   1:     nsRect screenParentFrameRect (aPresContext->AppUnitsToDevPixels(offset.x), aPresContext->AppUnitsToDevPixels(offset.y),
   1:                                     parentRect.width, parentRect.height );
   1:     parentViewWidget->WidgetToScreen ( screenParentFrameRect, screenParentFrameRect );
   1:     screenParentFrameRect.x = aPresContext->DevPixelsToAppUnits(screenParentFrameRect.x);
   1:     screenParentFrameRect.y = aPresContext->DevPixelsToAppUnits(screenParentFrameRect.y);
   1: 
   1:     // Don't let it spill off the screen to the top
   1:     if (screenViewLocY < screenTopTwips) {
   1:       PRInt32 moveDist = screenTopTwips - screenViewLocY;
   1:       screenViewLocY = screenTopTwips;
   1:       ypos += moveDist;
   1:     }
   1:     
   1:     // if it doesn't fit on the screen, do our magic.
   1:     if ( (screenViewLocX + mRect.width) > screenRightTwips ||
   1:            screenViewLocX < screenLeftTwips ||
   1:           (screenViewLocY + mRect.height) > screenBottomTwips ) {
   1:       
   1:       // figure out which side of the parent has the most free space so we can move/resize
   1:       // the popup there. This should still work if the parent frame is partially screen.
   1:       PRBool switchSides = IsMoreRoomOnOtherSideOfParent ( readjustAboveBelow, screenViewLocX, screenViewLocY,
   1:                                                             screenParentFrameRect, screenTopTwips, screenLeftTwips,
   1:                                                             screenBottomTwips, screenRightTwips );
   1:       
   1:       // move the popup to the correct side, if necessary. Note that MovePopupToOtherSideOfParent() 
   1:       // can change width/height of |mRect|.
   1:       if ( switchSides )
   1:         MovePopupToOtherSideOfParent ( readjustAboveBelow, &xpos, &ypos, &screenViewLocX, &screenViewLocY, 
   1:                                         screenParentFrameRect, screenTopTwips, screenLeftTwips,
   1:                                         screenBottomTwips, screenRightTwips );
   1:                                         
   1:       // We are allowed to move the popup along the axis to which we're not anchored to the parent
   1:       // in order to get it to not spill off the screen.
   1:       if ( readjustAboveBelow ) {
   1:         // move left to be on screen, but don't let it go off the screen at the left
   1:         if ( (screenViewLocX + mRect.width) > screenRightTwips ) {
   1:           PRInt32 moveDistX = (screenViewLocX + mRect.width) - screenRightTwips;
   1:           if ( screenViewLocX - moveDistX < screenLeftTwips )
   1:             moveDistX = screenViewLocX - screenLeftTwips;          
   1:           screenViewLocX -= moveDistX;
   1:           xpos -= moveDistX;
   1:         } else if (screenViewLocX < screenLeftTwips) {
   1:           // move right to be on screen, but don't let it go off the screen at the right
   1:           PRInt32 moveDistX = screenLeftTwips - screenViewLocX;
   1:           if ( (screenViewLocX + mRect.width + moveDistX) > screenRightTwips )
   1:             moveDistX = screenRightTwips - screenViewLocX - mRect.width;
   1:           screenViewLocX += moveDistX;
   1:           xpos += moveDistX;
   1:         }
   1:       }
   1:       else {
   1:         // move it up to be on screen, but don't let it go off the screen at the top
   1:         /*
   1:          *  |
   1:          *  |
   1:          *  |+----  screenViewLocY
   1:          *  ||
   1:          *  ||  Submenu ( = mRect )
   1:          * -+|
   1:          *   |
   1:          *   |
   1:          * - - - - - - - - - - screenBottomTwips (bottom of the screen)
   1:          *   |    \ 
   1:          *   |     }  moveDistY
   1:          *   |    / 
   1:          *   +----  screenViewLocY + mRect.height
   1:          */
   1: 
   1:         if ( (screenViewLocY + mRect.height) > screenBottomTwips ) {
   1:           // XXX Bug 84121 comment 48 says the next line has to use screenHeightTwips, why not screenBottomTwips?
   1:           PRInt32 moveDistY = (screenViewLocY + mRect.height) - screenHeightTwips;
   1:           if ( screenViewLocY - moveDistY < screenTopTwips )
   1:             moveDistY = screenViewLocY - screenTopTwips;          
   1:           screenViewLocY -= moveDistY;
   1:           ypos -= moveDistY; 
   1:         } 
   1:       }
   1:       
   1:       // Resize it to fit on the screen. By this point, we've given the popup as much
   1:       // room as we can w/out covering the parent. If it still can't be as big
   1:       // as it wants to be, well, it just has to suck up and deal. 
   1:       //
   1:       // ySpillage is calculated the same way as moveDistY above. see picture there.
   1: 
   1:       PRInt32 xSpillage = (screenViewLocX + mRect.width) - screenRightTwips;
   1:       if ( xSpillage > 0 )
   1:         mRect.width -= xSpillage;
   1:       PRInt32 ySpillage = (screenViewLocY + mRect.height) - screenBottomTwips;
   1:       if ( ySpillage > 0 )
   1:         mRect.height -= ySpillage;
   1: 
   1:       // shrink to fit onto the screen, vertically and horizontally
   1:       if(mRect.width > screenWidthTwips) 
   1:           mRect.width = screenWidthTwips;    
   1:       if(mRect.height > screenHeightTwips)
   1:           mRect.height = screenHeightTwips;   
   1: 
   1:     } // if it doesn't fit on screen
   1:   } // if anchored to parent
   1:   else {
   1:   
   1:     //
   1:     // Popup not anchored to anything, just make sure it's on the screen by any
   1:     // means necessary
   1:     //
   1: 
   1:     // If you decide to mess with this code in some way other than just
   1:     // converting it to be just like the anchored codepath, please make sure to
   1:     // not regress bug 120226, bug 172530, bug 245163.
   1: 
   1:     // XXXbz this is really silly.  We should be able to anchor popups to a
   1:     // point or rect, not a frame, and we should be doing so with context
   1:     // menus.  Furthermore, we should not be adding in pixels manually to
   1:     // adjust position (in XULPopupListenerImpl::LaunchPopup comes to mind,
   1:     // though ConvertPosition in the same file has some 21-px bogosity in the
   1:     // y-direction too).
   1: 
   1:     // shrink to fit onto the screen, vertically and horizontally
   1:     if(mRect.width > screenWidthTwips) 
   1:         mRect.width = screenWidthTwips;    
   1:     if(mRect.height > screenHeightTwips)
   1:         mRect.height = screenHeightTwips;   
   1: 
   1:     // First, adjust the X position.  For the X position, we slide the popup
   1:     // left or right as needed to get it on screen.
   1:     if ( screenViewLocX < screenLeftTwips ) {
   1:       PRInt32 moveDistX = screenLeftTwips - screenViewLocX;
   1:       xpos += moveDistX;
   1:       screenViewLocX += moveDistX;
   1:     }
   1:     if ( (screenViewLocX + mRect.width) > screenRightTwips )
   1:       xpos -= (screenViewLocX + mRect.width) - screenRightTwips;
   1: 
   1:     // Now the Y position.  If the popup is up too high, slide it down so it's
   1:     // on screen.
   1:     if ( screenViewLocY < screenTopTwips ) {
   1:       PRInt32 moveDistY = screenTopTwips - screenViewLocY;
   1:       ypos += moveDistY;
   1:       screenViewLocY += moveDistY;
   1:     }
   1: 
   1:     // Now if the popup extends down too far, either resize it or flip it to be
   1:     // above the anchor point and resize it to fit above, depending on where we
   1:     // have more room.
   1:     if ( (screenViewLocY + mRect.height) > screenBottomTwips ) {
   1:       // XXXbz it'd be good to make use of IsMoreRoomOnOtherSideOfParent and
   1:       // such here, but that's really focused on having a nonempty parent
   1:       // rect...
   1:       if (screenBottomTwips - screenViewLocY >
   1:           screenViewLocY - screenTopTwips) {
   1:         // More space below our desired point.  Resize to fit in this space.
   1:         // Note that this is making mRect smaller; othewise we would not have
   1:         // reached this code.
   1:         mRect.height = screenBottomTwips - screenViewLocY;
   1:       } else {
   1:         // More space above our desired point.  Flip and resize to fit in this
   1:         // space.
   1:         if (mRect.height > screenViewLocY - screenTopTwips) {
   1:           // We wouldn't fit.  Shorten before flipping.
   1:           mRect.height = screenViewLocY - screenTopTwips;
   1:         }
   1:         ypos -= (mRect.height + margin.top + margin.bottom);
   1:       }
   1:     }
   1:   }  
   1: 
   1:   aPresContext->GetViewManager()->MoveViewTo(view, xpos, ypos); 
   1: 
   1:   // Now that we've positioned the view, sync up the frame's origin.
   1:   nsPoint frameOrigin = GetPosition();
   1:   nsPoint offsetToView;
   1:   GetOriginToViewOffset(offsetToView, nsnull);
   1:   frameOrigin -= offsetToView;
   1:   nsBoxFrame::SetPosition(frameOrigin);
   1: 
   1:   if (sizedToPopup) {
 238:       nsBoxLayoutState state(PresContext());
   1:       SetBounds(state, nsRect(mRect.x, mRect.y, parentRect.width, mRect.height));
   1:   }
   1:     
   1:   if (!mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menuactive,
   1:                              nsGkAtoms::_true, eCaseMatters) &&
   1:       mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menutobedisplayed,
   1:                             nsGkAtoms::_true, eCaseMatters)) {
   1:     nsIReflowCallback* cb = new nsASyncMenuActivation(mContent);
   1:     NS_ENSURE_TRUE(cb, NS_ERROR_OUT_OF_MEMORY);
 238:     PresContext()->PresShell()->PostReflowCallback(cb);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: static void GetInsertionPoint(nsIPresShell* aShell, nsIFrame* aFrame, nsIFrame* aChild,
   1:                               nsIFrame** aResult)
   1: {
   1:   nsIContent* child = nsnull;
   1:   if (aChild)
   1:     child = aChild->GetContent();
   1:   aShell->FrameConstructor()->GetInsertionPoint(aFrame, child, aResult);
   1: }
   1: 
   1: /* virtual */ nsIMenuFrame*
   1: nsMenuPopupFrame::GetNextMenuItem(nsIMenuFrame* aStart)
   1: {
   1:   nsIFrame* immediateParent = nsnull;
 238:   GetInsertionPoint(PresContext()->PresShell(), this, nsnull,
   1:                     &immediateParent);
   1:   if (!immediateParent)
   1:     immediateParent = this;
   1: 
   1:   nsIFrame* currFrame = nsnull;
   1:   nsIFrame* startFrame = nsnull;
   1:   if (aStart) {
   1:     aStart->QueryInterface(NS_GET_IID(nsIFrame), (void**)&currFrame); 
   1:     if (currFrame) {
   1:       startFrame = currFrame;
   1:       currFrame = currFrame->GetNextSibling();
   1:     }
   1:   }
   1:   else 
   1:     currFrame = immediateParent->GetFirstChild(nsnull);
   1:   
   1:   while (currFrame) {
   1:     // See if it's a menu item.
   1:     if (IsValidItem(currFrame->GetContent())) {
   1:       nsIMenuFrame *menuFrame;
   1:       if (NS_FAILED(CallQueryInterface(currFrame, &menuFrame)))
   1:         menuFrame = nsnull;
   1:       return menuFrame;
   1:     }
   1:     currFrame = currFrame->GetNextSibling();
   1:   }
   1: 
   1:   currFrame = immediateParent->GetFirstChild(nsnull);
   1: 
   1:   // Still don't have anything. Try cycling from the beginning.
   1:   while (currFrame && currFrame != startFrame) {
   1:     // See if it's a menu item.
   1:     if (IsValidItem(currFrame->GetContent())) {
   1:       nsIMenuFrame *menuFrame;
   1:       if (NS_FAILED(CallQueryInterface(currFrame, &menuFrame)))
   1:         menuFrame = nsnull;
   1:       return menuFrame;
   1:     }
   1: 
   1:     currFrame = currFrame->GetNextSibling();
   1:   }
   1: 
   1:   // No luck. Just return our start value.
   1:   return aStart;
   1: }
   1: 
   1: /* virtual */ nsIMenuFrame*
   1: nsMenuPopupFrame::GetPreviousMenuItem(nsIMenuFrame* aStart)
   1: {
   1:   nsIFrame* immediateParent = nsnull;
 238:   GetInsertionPoint(PresContext()->PresShell(), this, nsnull,
   1:                     &immediateParent);
   1:   if (!immediateParent)
   1:     immediateParent = this;
   1: 
   1:   nsFrameList frames(immediateParent->GetFirstChild(nsnull));
   1:                               
   1:   nsIFrame* currFrame = nsnull;
   1:   nsIFrame* startFrame = nsnull;
   1:   if (aStart) {
   1:     aStart->QueryInterface(NS_GET_IID(nsIFrame), (void**)&currFrame);
   1:     if (currFrame) {
   1:       startFrame = currFrame;
   1:       currFrame = frames.GetPrevSiblingFor(currFrame);
   1:     }
   1:   }
   1:   else currFrame = frames.LastChild();
   1: 
   1:   while (currFrame) {
   1:     // See if it's a menu item.
   1:     if (IsValidItem(currFrame->GetContent())) {
   1:       nsIMenuFrame *menuFrame;
   1:       if (NS_FAILED(CallQueryInterface(currFrame, &menuFrame)))
   1:         menuFrame = nsnull;
   1:       return menuFrame;
   1:     }
   1:     currFrame = frames.GetPrevSiblingFor(currFrame);
   1:   }
   1: 
   1:   currFrame = frames.LastChild();
   1: 
   1:   // Still don't have anything. Try cycling from the end.
   1:   while (currFrame && currFrame != startFrame) {
   1:     // See if it's a menu item.
   1:     if (IsValidItem(currFrame->GetContent())) {
   1:       nsIMenuFrame *menuFrame;
   1:       if (NS_FAILED(CallQueryInterface(currFrame, &menuFrame)))
   1:         menuFrame = nsnull;
   1:       return menuFrame;
   1:     }
   1: 
   1:     currFrame = frames.GetPrevSiblingFor(currFrame);
   1:   }
   1: 
   1:   // No luck. Just return our start value.
   1:   return aStart;
   1: }
   1: 
   1: /* virtual */ nsIMenuFrame*
   1: nsMenuPopupFrame::GetCurrentMenuItem()
   1: {
   1:   return mCurrentMenu;
   1: }
   1: 
   1: NS_IMETHODIMP nsMenuPopupFrame::ConsumeOutsideClicks(PRBool& aConsumeOutsideClicks)
   1: {
   1:   /*
   1:    * When this popup is open, should clicks outside of it be consumed?
   1:    * Return PR_TRUE if the popup hould rollup on an outside click, 
   1:    * but consume that click so it can't be used for anything else.
   1:    * Return PR_FALSE to allow clicks outside the popup to activate content 
   1:    * even when the popup is open.
   1:    * ---------------------------------------------------------------------
   1:    * 
   1:    * Should clicks outside of a popup be eaten?
   1:    *
   1:    *       Menus     Autocomplete     Comboboxes
   1:    * Mac     Eat           No              Eat
   1:    * Win     No            No              Eat     
   1:    * Unix    Eat           No              Eat
   1:    *
   1:    */
   1: 
   1:   // If the popup has explicitly set a consume mode, honor that.
   1:   if (mConsumeRollupEvent != nsIPopupBoxObject::ROLLUP_DEFAULT) {
   1:     aConsumeOutsideClicks = mConsumeRollupEvent == nsIPopupBoxObject::ROLLUP_CONSUME;
   1:     return NS_OK;
   1:   }
   1: 
   1:   aConsumeOutsideClicks = PR_TRUE;
   1: 
   1:   nsCOMPtr<nsIContent> parentContent = mContent->GetParent();
   1: 
   1:   if (parentContent) {
   1:     nsIAtom *parentTag = parentContent->Tag();
   1:     if (parentTag == nsGkAtoms::menulist)
   1:       return NS_OK;  // Consume outside clicks for combo boxes on all platforms
   1:     if (parentTag == nsGkAtoms::menu || parentTag == nsGkAtoms::popupset) {
   1: #if defined(XP_WIN) || defined(XP_OS2)
   1:       // Don't consume outside clicks for menus in Windows
   1:       aConsumeOutsideClicks = PR_FALSE;
   1: #endif
   1:       return NS_OK;
   1:     }
   1:     if (parentTag == nsGkAtoms::textbox) {
   1:       // Don't consume outside clicks for autocomplete widget
   1:       if (parentContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
   1:                                      nsGkAtoms::autocomplete, eCaseMatters))
   1:         aConsumeOutsideClicks = PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: static nsIScrollableView* GetScrollableViewForFrame(nsIFrame* aFrame)
   1: {
   1:   nsIScrollableFrame* sf;
   1:   nsresult rv = CallQueryInterface(aFrame, &sf);
   1:   if (NS_FAILED(rv))
   1:     return nsnull;
   1:   return sf->GetScrollableView();
   1: }
   1: 
   1: // XXXroc this is megalame. Fossicking around for a view of the right
   1: // type is a recipe for disaster in the long term.
   1: nsIScrollableView* nsMenuPopupFrame::GetScrollableView(nsIFrame* aStart)
   1: {
   1:   if ( ! aStart )
   1:     return nsnull;  
   1: 
   1:   nsIFrame* currFrame;
   1:   nsIScrollableView* scrollableView=nsnull;
   1: 
   1:   // try start frame and siblings
   1:   currFrame=aStart;
   1:   do {
   1:     scrollableView = GetScrollableViewForFrame(currFrame);
   1:     if ( scrollableView )
   1:       return scrollableView;
   1:     currFrame = currFrame->GetNextSibling();
   1:   } while ( currFrame );
   1: 
   1:   // try children
   1:   nsIFrame* childFrame;
   1:   currFrame=aStart;
   1:   do {
   1:     childFrame = currFrame->GetFirstChild(nsnull);
   1:     scrollableView=GetScrollableView(childFrame);
   1:     if ( scrollableView )
   1:       return scrollableView;
   1:     currFrame = currFrame->GetNextSibling();
   1:   } while ( currFrame );
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: void nsMenuPopupFrame::EnsureMenuItemIsVisible(nsIMenuFrame* aMenuItem)
   1: {
   1:   nsIFrame* frame=nsnull;
   1:   aMenuItem->QueryInterface(NS_GET_IID(nsIFrame), (void**)&frame);
   1:   if ( frame ) {
   1:     nsIFrame* childFrame=nsnull;
   1:     childFrame = GetFirstChild(nsnull);
   1:     nsIScrollableView *scrollableView;
   1:     scrollableView=GetScrollableView(childFrame);
   1:     if ( scrollableView ) {
   1:       nscoord scrollX, scrollY;
   1: 
   1:       nsRect viewRect = scrollableView->View()->GetBounds();
   1:       nsRect itemRect = frame->GetRect();
   1:       scrollableView->GetScrollPosition(scrollX, scrollY);
   1:   
   1:       // scroll down
   1:       if ( itemRect.y + itemRect.height > scrollY + viewRect.height )
   1:         scrollableView->ScrollTo(scrollX, itemRect.y + itemRect.height - viewRect.height, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
   1:       
   1:       // scroll up
   1:       else if ( itemRect.y < scrollY )
   1:         scrollableView->ScrollTo(scrollX, itemRect.y, NS_SCROLL_PROPERTY_ALWAYS_BLIT);
   1:     }
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP nsMenuPopupFrame::SetCurrentMenuItem(nsIMenuFrame* aMenuItem)
   1: {
   1:   // When a context menu is open, the current menu is locked, and no change
   1:   // to the menu is allowed.
   1:   nsIMenuParent *contextMenu = GetContextMenu();
   1:   if (contextMenu)
   1:     return NS_OK;
   1: 
   1:   if (mCurrentMenu == aMenuItem)
   1:     return NS_OK;
   1:   
   1:   // Unset the current child.
   1:   if (mCurrentMenu) {
   1:     PRBool isOpen = PR_FALSE;
   1:     mCurrentMenu->MenuIsOpen(isOpen);
   1:     mCurrentMenu->SelectMenu(PR_FALSE);
   1:     // XXX bug 294183 sometimes mCurrentMenu gets cleared
   1:     if (mCurrentMenu && isOpen) {
   1:       // Don't close up immediately.
   1:       // Kick off a close timer.
   1:       KillCloseTimer(); // Ensure we don't have another stray waiting closure.
   1:       PRInt32 menuDelay = 300;   // ms
   1: 
 238:       PresContext()->LookAndFeel()->
   1:         GetMetric(nsILookAndFeel::eMetric_SubmenuDelay, menuDelay);
   1: 
   1:       // Kick off the timer.
   1:       mCloseTimer = do_CreateInstance("@mozilla.org/timer;1");
   1:       mCloseTimer->InitWithCallback(mTimerMediator, menuDelay, nsITimer::TYPE_ONE_SHOT);
   1:       mTimerMenu = mCurrentMenu;
   1:     }
   1:   }
   1: 
   1:   // Set the new child.
   1:   if (aMenuItem) {
   1:     EnsureMenuItemIsVisible(aMenuItem);
   1:     aMenuItem->SelectMenu(PR_TRUE);
   1:   }
   1: 
   1:   mCurrentMenu = aMenuItem;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::Escape(PRBool& aHandledFlag)
   1: {
   1:   mIncrementalString.Truncate();
   1: 
   1:   // See if we have a context menu open.
   1:   nsIMenuParent* contextMenu = GetContextMenu();
   1:   if (contextMenu) {
   1:     // Get the context menu parent.
   1:     nsIFrame* childFrame;
   1:     CallQueryInterface(contextMenu, &childFrame);
 238:     nsIPopupSetFrame* popupSetFrame = GetPopupSetFrame(PresContext());
   1:     if (popupSetFrame)
   1:       // Destroy the popup.
   1:       popupSetFrame->DestroyPopup(childFrame, PR_FALSE);
   1:     aHandledFlag = PR_TRUE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   if (!mCurrentMenu)
   1:     return NS_OK;
   1: 
   1:   // See if our menu is open.
   1:   PRBool isOpen = PR_FALSE;
   1:   mCurrentMenu->MenuIsOpen(isOpen);
   1:   if (isOpen) {
   1:     // Let the child menu handle this.
   1:     mCurrentMenu->Escape(aHandledFlag);
   1:     if (!aHandledFlag) {
   1:       // We should close up.
   1:       mCurrentMenu->OpenMenu(PR_FALSE);
   1:       // SelectMenu() so DOMMenuItemActive is fired for accessibility
   1:       mCurrentMenu->SelectMenu(PR_TRUE);
   1:       aHandledFlag = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::Enter()
   1: {
   1:   mIncrementalString.Truncate();
   1: 
   1:   // See if we have a context menu open.
   1:   nsIMenuParent *contextMenu = GetContextMenu();
   1:   if (contextMenu)
   1:     return contextMenu->Enter();
   1: 
   1:   // Give it to the child.
   1:   if (mCurrentMenu)
   1:     mCurrentMenu->Enter();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsIMenuParent*
   1: nsMenuPopupFrame::GetContextMenu()
   1: {
   1:   if (mIsContextMenu)
   1:     return nsnull;
   1: 
   1:   return nsMenuFrame::GetContextMenu();
   1: }
   1: 
   1: nsIMenuFrame*
   1: nsMenuPopupFrame::FindMenuWithShortcut(nsIDOMKeyEvent* aKeyEvent, PRBool& doAction)
   1: {
   1:   PRUint32 charCode, keyCode;
   1:   aKeyEvent->GetCharCode(&charCode);
   1:   aKeyEvent->GetKeyCode(&keyCode);
   1: 
   1:   doAction = PR_FALSE;
   1: 
   1:   // Enumerate over our list of frames.
   1:   nsIFrame* immediateParent = nsnull;
 238:   GetInsertionPoint(PresContext()->PresShell(), this, nsnull,
   1:                     &immediateParent);
   1:   if (!immediateParent)
   1:     immediateParent = this;
   1: 
   1:   PRUint32 matchCount = 0, matchShortcutCount = 0;
   1:   PRBool foundActive = PR_FALSE;
   1:   PRBool isShortcut;
   1:   nsIMenuFrame* frameBefore = nsnull;
   1:   nsIMenuFrame* frameAfter = nsnull;
   1:   nsIMenuFrame* frameShortcut = nsnull;
   1: 
   1:   nsIContent* parentContent = mContent->GetParent();
   1: 
   1:   PRBool isMenu =
   1:     parentContent && parentContent->Tag() != nsGkAtoms::menulist;
   1: 
   1:   static DOMTimeStamp lastKeyTime = 0;
   1:   DOMTimeStamp keyTime;
   1:   aKeyEvent->GetTimeStamp(&keyTime);
   1: 
   1:   if (charCode == 0) {
   1:     if (keyCode == NS_VK_BACK) {
   1:       if (!isMenu && !mIncrementalString.IsEmpty()) {
   1:         mIncrementalString.SetLength(mIncrementalString.Length() - 1);
   1:         return nsnull;
   1:       }
   1:       else {
   1: #ifdef XP_WIN
   1:         nsCOMPtr<nsISound> soundInterface = do_CreateInstance("@mozilla.org/sound;1");
   1:         if (soundInterface)
   1:           soundInterface->Beep();
   1: #endif  // #ifdef XP_WIN
   1:       }
   1:     }
   1:     return nsnull;
   1:   }
   1:   else {
   1:     PRUnichar uniChar = ToLowerCase(NS_STATIC_CAST(PRUnichar, charCode));
   1:     if (isMenu || // Menu supports only first-letter navigation
   1:         keyTime - lastKeyTime > INC_TYP_INTERVAL) // Interval too long, treat as new typing
   1:       mIncrementalString = uniChar;
   1:     else {
   1:       mIncrementalString.Append(uniChar);
   1:     }
   1:   }
   1: 
   1:   // See bug 188199 & 192346, if all letters in incremental string are same, just try to match the first one
   1:   nsAutoString incrementalString(mIncrementalString);
   1:   PRUint32 charIndex = 1, stringLength = incrementalString.Length();
   1:   while (charIndex < stringLength && incrementalString[charIndex] == incrementalString[charIndex - 1]) {
   1:     charIndex++;
   1:   }
   1:   if (charIndex == stringLength) {
   1:     incrementalString.Truncate(1);
   1:     stringLength = 1;
   1:   }
   1: 
   1:   lastKeyTime = keyTime;
   1: 
   1:   nsIFrame* currFrame;
   1:   // NOTE: If you crashed here due to a bogus |immediateParent| it is 
   1:   //       possible that the menu whose shortcut is being looked up has 
   1:   //       been destroyed already.  One strategy would be to 
   1:   //       setTimeout(<func>,0) as detailed in:
   1:   //       <http://bugzilla.mozilla.org/show_bug.cgi?id=126675#c32>
   1:   currFrame = immediateParent->GetFirstChild(nsnull);
   1: 
   1:   // We start searching from first child. This process is divided into two parts
   1:   //   -- before current and after current -- by the current item
   1:   while (currFrame) {
   1:     nsIContent* current = currFrame->GetContent();
   1:     
   1:     // See if it's a menu item.
   1:     if (IsValidItem(current)) {
   1:       nsAutoString textKey;
   1:       // Get the shortcut attribute.
   1:       current->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, textKey);
   1:       if (textKey.IsEmpty()) { // No shortcut, try first letter
   1:         isShortcut = PR_FALSE;
   1:         current->GetAttr(kNameSpaceID_None, nsGkAtoms::label, textKey);
   1:         if (textKey.IsEmpty()) // No label, try another attribute (value)
   1:           current->GetAttr(kNameSpaceID_None, nsGkAtoms::value, textKey);
   1:       }
   1:       else
   1:         isShortcut = PR_TRUE;
   1: 
   1:       if (StringBeginsWith(textKey, incrementalString,
   1:                            nsCaseInsensitiveStringComparator())) {
   1:         // mIncrementalString is a prefix of textKey
   1:         nsIMenuFrame* menuFrame;
   1:         if (NS_SUCCEEDED(CallQueryInterface(currFrame, &menuFrame))) {
   1:           // There is one match
   1:           matchCount++;
   1:           if (isShortcut) {
   1:             // There is one shortcut-key match
   1:             matchShortcutCount++;
   1:             // Record the matched item. If there is only one matched shortcut item, do it
   1:             frameShortcut = menuFrame;
   1:           }
   1:           if (!foundActive) {
   1:             // It's a first candidate item located before/on the current item
   1:             if (!frameBefore)
   1:               frameBefore = menuFrame;
   1:           }
   1:           else {
   1:             // It's a first candidate item located after the current item
   1:             if (!frameAfter)
   1:               frameAfter = menuFrame;
   1:           }
   1:         }
   1:         else
   1:           return nsnull;
   1:       }
   1: 
   1:       // Get the active status
   1:       if (current->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menuactive,
   1:                                nsGkAtoms::_true, eCaseMatters)) {
   1:         foundActive = PR_TRUE;
   1:         if (stringLength > 1) {
   1:           // If there is more than one char typed, the current item has highest priority,
   1:           //   otherwise the item next to current has highest priority
   1:           nsIMenuFrame* menuFrame;
   1:           if (NS_SUCCEEDED(CallQueryInterface(currFrame, &menuFrame)) &&
   1:               menuFrame == frameBefore) {
   1:             return frameBefore;
   1:           }
   1:         }
   1:       }
   1:     }
   1:     currFrame = currFrame->GetNextSibling();
   1:   }
   1: 
   1:   doAction = (isMenu && (matchCount == 1 || matchShortcutCount == 1));
   1: 
   1:   if (matchShortcutCount == 1) // We have one matched shortcut item
   1:     return frameShortcut;
   1:   if (frameAfter) // If we have matched item after the current, use it
   1:     return frameAfter;
   1:   else if (frameBefore) // If we haven't, use the item before the current
   1:     return frameBefore;
   1: 
   1:   // If we don't match anything, rollback the last typing
   1:   mIncrementalString.SetLength(mIncrementalString.Length() - 1);
   1: 
   1:   // didn't find a matching menu item
   1: #ifdef XP_WIN
   1:   // behavior on Windows - this item is in a menu popup off of the
   1:   // menu bar, so beep and do nothing else
   1:   if (isMenu) {
   1:     nsCOMPtr<nsISound> soundInterface = do_CreateInstance("@mozilla.org/sound;1");
   1:     if (soundInterface)
   1:       soundInterface->Beep();
   1:   }
   1: #endif  // #ifdef XP_WIN
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsMenuPopupFrame::ShortcutNavigation(nsIDOMKeyEvent* aKeyEvent, PRBool& aHandledFlag)
   1: {
   1:   // See if we have a context menu open.
   1:   nsIMenuParent *contextMenu = GetContextMenu();
   1:   if (contextMenu)
   1:     return contextMenu->ShortcutNavigation(aKeyEvent, aHandledFlag);
   1: 
   1:   if (mCurrentMenu) {
   1:     PRBool isOpen = PR_FALSE;
   1:     mCurrentMenu->MenuIsOpen(isOpen);
   1:     if (isOpen) {
   1:       // No way this applies to us. Give it to our child.
   1:       mCurrentMenu->ShortcutNavigation(aKeyEvent, aHandledFlag);
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   // This applies to us. Let's see if one of the shortcuts applies
   1:   PRBool action;
   1:   nsIMenuFrame* result = FindMenuWithShortcut(aKeyEvent, action);
   1:   if (result) {
   1:     // We got one!
   1:     nsIFrame* frame = nsnull;
   1:     CallQueryInterface(result, &frame);
   1:     nsWeakFrame weakResult(frame);
   1:     aHandledFlag = PR_TRUE;
   1:     SetCurrentMenuItem(result);
   1:     if (action && weakResult.IsAlive()) {
   1:       result->Enter();
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::KeyboardNavigation(PRUint32 aKeyCode, PRBool& aHandledFlag)
   1: {
   1:   // See if we have a context menu open.
   1:   nsIMenuParent *contextMenu = GetContextMenu();
   1:   if (contextMenu)
   1:     return contextMenu->KeyboardNavigation(aKeyCode, aHandledFlag);
   1: 
   1:   nsNavigationDirection theDirection;
   1:   NS_DIRECTION_FROM_KEY_CODE(theDirection, aKeyCode);
   1: 
   1:   mIncrementalString.Truncate();
   1: 
   1:   // This method only gets called if we're open.
   1:   if (!mCurrentMenu && NS_DIRECTION_IS_INLINE(theDirection)) {
   1:     // We've been opened, but we haven't had anything selected.
   1:     // We can handle End, but our parent handles Start.
   1:     if (theDirection == eNavigationDirection_End) {
   1:       nsIMenuFrame* nextItem = GetNextMenuItem(nsnull);
   1:       if (nextItem) {
   1:         aHandledFlag = PR_TRUE;
   1:         SetCurrentMenuItem(nextItem);
   1:       }
   1:     }
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRBool isContainer = PR_FALSE;
   1:   PRBool isOpen = PR_FALSE;
   1:   PRBool isDisabled = PR_FALSE;
   1:   nsWeakFrame weakFrame(this);
   1:   if (mCurrentMenu) {
   1:     mCurrentMenu->MenuIsContainer(isContainer);
   1:     mCurrentMenu->MenuIsOpen(isOpen);
   1:     mCurrentMenu->MenuIsDisabled(isDisabled);
   1: 
   1:     if (isOpen) {
   1:       // Give our child a shot.
   1:       mCurrentMenu->KeyboardNavigation(aKeyCode, aHandledFlag);
   1:       NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
   1:     }
   1:     else if (theDirection == eNavigationDirection_End &&
   1:              isContainer && !isDisabled) {
   1:       // The menu is not yet open. Open it and select the first item.
   1:       aHandledFlag = PR_TRUE;
   1:       nsIFrame* frame = nsnull;
   1:       CallQueryInterface(mCurrentMenu, &frame);
   1:       nsWeakFrame weakCurrentFrame(frame);
   1:       mCurrentMenu->OpenMenu(PR_TRUE);
   1:       NS_ENSURE_TRUE(weakCurrentFrame.IsAlive(), NS_OK);
   1:       mCurrentMenu->SelectFirstItem();
   1:       NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
   1:     }
   1:   }
   1: 
   1:   if (aHandledFlag)
   1:     return NS_OK; // The child menu took it for us.
   1: 
   1:   // For block progression, we can move in either direction
   1:   if (NS_DIRECTION_IS_BLOCK(theDirection) ||
   1:       NS_DIRECTION_IS_BLOCK_TO_EDGE(theDirection)) {
   1: 
   1:     nsIMenuFrame* nextItem;
   1:     
   1:     if (theDirection == eNavigationDirection_Before)
   1:       nextItem = GetPreviousMenuItem(mCurrentMenu);
   1:     else if (theDirection == eNavigationDirection_After)
   1:       nextItem = GetNextMenuItem(mCurrentMenu);
   1:     else if (theDirection == eNavigationDirection_First)
   1:       nextItem = GetNextMenuItem(nsnull);
   1:     else
   1:       nextItem = GetPreviousMenuItem(nsnull);
   1: 
   1:     if (nextItem) {
   1:       aHandledFlag = PR_TRUE;
   1:       SetCurrentMenuItem(nextItem);
   1:     }
   1:   }
   1:   else if (mCurrentMenu && isContainer && isOpen) {
   1:     if (theDirection == eNavigationDirection_Start) {
   1:       // Close it up.
   1:       mCurrentMenu->OpenMenu(PR_FALSE);
   1:       NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
   1:       // SelectMenu() so DOMMenuItemActive is fired for accessibility
   1:       mCurrentMenu->SelectMenu(PR_TRUE);
   1:       aHandledFlag = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::GetParentPopup(nsIMenuParent** aMenuParent)
   1: {
   1:   *aMenuParent = nsnull;
   1:   nsIFrame* parent = GetParent();
   1:   while (parent) {
   1:     nsCOMPtr<nsIMenuParent> menuParent = do_QueryInterface(parent);
   1:     if (menuParent) {
   1:       *aMenuParent = menuParent.get();
   1:       NS_ADDREF(*aMenuParent);
   1:       return NS_OK;
   1:     }
   1:     parent = parent->GetParent();
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::HideChain()
   1: {
   1:   if (!mShouldRollup)
   1:     return NS_OK;
   1: 
   1:   // Stop capturing rollups
   1:   // (must do this during Hide, which happens before the menu item is executed,
   1:   // since this reinstates normal event handling.)
   1:   nsMenuDismissalListener::Shutdown();
   1:   
   1:   nsIFrame* frame = GetParent();
   1:   if (frame) {
   1:     nsWeakFrame weakMenu(frame);
   1:     nsIMenuFrame* menuFrame;
   1:     if (NS_FAILED(CallQueryInterface(frame, &menuFrame))) {
 238:       nsIPopupSetFrame* popupSetFrame = GetPopupSetFrame(PresContext());
   1:       if (popupSetFrame)
   1:         // Hide the popup.
   1:         popupSetFrame->HidePopup(this);
   1:       return NS_OK;
   1:     }
   1:    
   1:     menuFrame->ActivateMenu(PR_FALSE);
   1:     NS_ENSURE_TRUE(weakMenu.IsAlive(), NS_OK);
   1:     menuFrame->SelectMenu(PR_FALSE);
   1:     NS_ENSURE_TRUE(weakMenu.IsAlive(), NS_OK);
   1: 
   1:     // Get the parent.
   1:     nsIMenuParent *menuParent = menuFrame->GetMenuParent();
   1:     if (menuParent)
   1:       menuParent->HideChain();
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::DismissChain()
   1: {
   1:   if (!mShouldRollup)
   1:     return NS_OK;
   1: 
   1:   // Stop capturing rollups
   1:   nsMenuDismissalListener::Shutdown();
   1:   
   1:   // Get our menu parent.
   1:   nsIFrame* frame = GetParent();
   1:   if (frame) {
   1:     nsIMenuFrame *menuFrame = nsnull;
   1:     CallQueryInterface(frame, &menuFrame);
   1:     if (!menuFrame) {
 238:       nsIPopupSetFrame* popupSetFrame = GetPopupSetFrame(PresContext());
   1:       if (popupSetFrame) {
   1:         // make sure the menu is not highlighted
   1:         if (mCurrentMenu) {
   1:           PRBool wasOpen;
   1:           mCurrentMenu->MenuIsOpen(wasOpen);
   1:           if (wasOpen)
   1:             mCurrentMenu->OpenMenu(PR_FALSE);
   1:           mCurrentMenu->SelectMenu(PR_FALSE);
   1:         }
   1:         // Destroy the popup.
   1:         popupSetFrame->DestroyPopup(this, PR_TRUE);
   1:       }
   1:       return NS_OK;
   1:     }
   1:   
   1:     menuFrame->OpenMenu(PR_FALSE);
   1: 
   1:     // Get the parent.
   1:     nsIMenuParent* menuParent = menuFrame->GetMenuParent();
   1:     if (menuParent)
   1:       menuParent->DismissChain();
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::GetWidget(nsIWidget **aWidget)
   1: {
   1:   // Get parent view
   1:   nsIView * view = nsnull;
   1:   // XXX should this be passing PR_FALSE or PR_TRUE for aStopAtViewManagerRoot?
   1:   nsMenuPopupFrame::GetRootViewForPopup(this, PR_FALSE, &view);
   1:   if (!view)
   1:     return NS_OK;
   1: 
   1:   *aWidget = view->GetWidget();
   1:   NS_IF_ADDREF(*aWidget);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::AttachedDismissalListener()
   1: {
   1:   mConsumeRollupEvent = nsIPopupBoxObject::ROLLUP_DEFAULT;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::InstallKeyboardNavigator()
   1: {
   1:   if (mKeyboardNavigator)
   1:     return NS_OK;
   1: 
1373:   nsCOMPtr<nsIDOMEventReceiver> target = do_QueryInterface(mContent->GetDocument());
   1:   
   1:   mTarget = target;
   1:   mKeyboardNavigator = new nsMenuListener(this);
   1:   NS_IF_ADDREF(mKeyboardNavigator);
   1: 
   1:   target->AddEventListener(NS_LITERAL_STRING("keypress"), (nsIDOMKeyListener*)mKeyboardNavigator, PR_TRUE); 
   1:   target->AddEventListener(NS_LITERAL_STRING("keydown"), (nsIDOMKeyListener*)mKeyboardNavigator, PR_TRUE);  
   1:   target->AddEventListener(NS_LITERAL_STRING("keyup"), (nsIDOMKeyListener*)mKeyboardNavigator, PR_TRUE);   
   1: 
 998:   nsContentUtils::NotifyInstalledMenuKeyboardListener(PR_TRUE);
 998: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::RemoveKeyboardNavigator()
   1: {
   1:   if (!mKeyboardNavigator)
   1:     return NS_OK;
   1: 
   1:   mTarget->RemoveEventListener(NS_LITERAL_STRING("keypress"), (nsIDOMKeyListener*)mKeyboardNavigator, PR_TRUE);
   1:   mTarget->RemoveEventListener(NS_LITERAL_STRING("keydown"), (nsIDOMKeyListener*)mKeyboardNavigator, PR_TRUE);
   1:   mTarget->RemoveEventListener(NS_LITERAL_STRING("keyup"), (nsIDOMKeyListener*)mKeyboardNavigator, PR_TRUE);
   1: 
   1:   NS_IF_RELEASE(mKeyboardNavigator);
   1: 
 998:   nsContentUtils::NotifyInstalledMenuKeyboardListener(PR_FALSE);
 998: 
   1:   return NS_OK;
   1: }
   1: 
   1: // helpers /////////////////////////////////////////////////////////////
   1: 
   1: PRBool 
   1: nsMenuPopupFrame::IsValidItem(nsIContent* aContent)
   1: {
   1:   nsIAtom *tag = aContent->Tag();
   1:   
   1:   PRBool skipNavigatingDisabledMenuItem;
 238:   PresContext()->LookAndFeel()->
   1:     GetMetric(nsILookAndFeel::eMetric_SkipNavigatingDisabledMenuItem,
   1:               skipNavigatingDisabledMenuItem);
   1: 
   1:   PRBool result = (tag == nsGkAtoms::menu ||
   1:                    tag == nsGkAtoms::menuitem ||
   1:                    tag == nsGkAtoms::option);
   1:   if (skipNavigatingDisabledMenuItem)
   1:     result = result && !IsDisabled(aContent);
   1: 
   1:   return result;
   1: }
   1: 
   1: PRBool 
   1: nsMenuPopupFrame::IsDisabled(nsIContent* aContent)
   1: {
   1:   return aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
   1:                                nsGkAtoms::_true, eCaseMatters);
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsMenuPopupFrame::AttributeChanged(PRInt32 aNameSpaceID,
   1:                                    nsIAtom* aAttribute,
   1:                                    PRInt32 aModType)
   1: 
   1: {
   1:   nsresult rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute,
   1:                                              aModType);
   1:   
   1:   if (aAttribute == nsGkAtoms::left || aAttribute == nsGkAtoms::top)
   1:     MoveToAttributePosition();
   1:   
   1:   return rv;
   1: }
   1: 
   1: void 
   1: nsMenuPopupFrame::MoveToAttributePosition()
   1: {
   1:   // Move the widget around when the user sets the |left| and |top| attributes. 
   1:   // Note that this is not the best way to move the widget, as it results in lots
   1:   // of FE notifications and is likely to be slow as molasses. Use |moveTo| on
   1:   // nsIPopupBoxObject if possible. 
   1:   nsAutoString left, top;
   1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::left, left);
   1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::top, top);
   1:   PRInt32 err1, err2, xPos, yPos;
   1:   xPos = left.ToInteger(&err1);
   1:   yPos = top.ToInteger(&err2);
   1: 
   1:   if (NS_SUCCEEDED(err1) && NS_SUCCEEDED(err2)) {
   1:     MoveToInternal(xPos, yPos);
   1:   }
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP 
   1: nsMenuPopupFrame::HandleEvent(nsPresContext* aPresContext, 
   1:                               nsGUIEvent*     aEvent,
   1:                               nsEventStatus*  aEventStatus)
   1: {
   1:   return nsBoxFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::Destroy()
   1: {
   1:   // Null out the pointer to this frame in the mediator wrapper so that it 
   1:   // doesn't try to interact with a deallocated frame.
   1:   mTimerMediator->ClearFrame();
   1: 
   1:   if (mCloseTimer)
   1:     mCloseTimer->Cancel();
   1: 
 238:   nsPresContext* rootPresContext = PresContext()->RootPresContext();
   1:   if (rootPresContext->ContainsActivePopup(this)) {
   1:     rootPresContext->NotifyRemovedActivePopup(this);
   1:   }
   1: 
   1:   RemoveKeyboardNavigator();
   1:   nsBoxFrame::Destroy();
   1: }
   1: 
   1: // REVIEW: The override here was doing nothing at all since nsBoxFrame is our
   1: // parent class
   1: //
   1: // Notify
   1: //
   1: // The item selection timer has fired, we might have to readjust the 
   1: // selected item. There are two cases here that we are trying to deal with:
   1: //   (1) diagonal movement from a parent menu to a submenu passing briefly over
   1: //       other items, and
   1: //   (2) moving out from a submenu to a parent or grandparent menu.
   1: // In both cases, |mTimerMenu| is the menu item that might have an open submenu and
   1: // |mCurrentMenu| is the item the mouse is currently over, which could be none of them.
   1: //
   1: // case (1):
   1: //  As the mouse moves from the parent item of a submenu (we'll call 'A') diagonally into the
   1: //  submenu, it probably passes through one or more sibilings (B). As the mouse passes
   1: //  through B, it becomes the current menu item and the timer is set and mTimerMenu is 
   1: //  set to A. Before the timer fires, the mouse leaves the menu containing A and B and
   1: //  enters the submenus. Now when the timer fires, |mCurrentMenu| is null (!= |mTimerMenu|)
   1: //  so we have to see if anything in A's children is selected (recall that even disabled
   1: //  items are selected, the style just doesn't show it). If that is the case, we need to
   1: //  set the selected item back to A.
   1: //
   1: // case (2);
   1: //  Item A has an open submenu, and in it there is an item (B) which also has an open
   1: //  submenu (so there are 3 menus displayed right now). The mouse then leaves B's child
   1: //  submenu and selects an item that is a sibling of A, call it C. When the mouse enters C,
   1: //  the timer is set and |mTimerMenu| is A and |mCurrentMenu| is C. As the timer fires,
   1: //  the mouse is still within C. The correct behavior is to set the current item to C
   1: //  and close up the chain parented at A.
   1: //
   1: //  This brings up the question of is the logic of case (1) enough? The answer is no,
   1: //  and is discussed in bugzilla bug 29400. Case (1) asks if A's submenu has a selected
   1: //  child, and if it does, set the selected item to A. Because B has a submenu open, it
   1: //  is selected and as a result, A is set to be the selected item even though the mouse
   1: //  rests in C -- very wrong. 
   1: //
   1: //  The solution is to use the same idea, but instead of only checking one level, 
   1: //  drill all the way down to the deepest open submenu and check if it has something 
   1: //  selected. Since the mouse is in a grandparent, it won't, and we know that we can
   1: //  safely close up A and all its children.
   1: //
   1: // The code below melds the two cases together.
   1: //
   1: nsresult
   1: nsMenuPopupFrame::Notify(nsITimer* aTimer)
   1: {
   1:   // Our timer has fired. 
   1:   if (aTimer == mCloseTimer.get()) {
   1:     PRBool menuOpen = PR_FALSE;
   1:     mTimerMenu->MenuIsOpen(menuOpen);
   1:     if (menuOpen)
   1:       mTimerMenu->OpenMenu(PR_FALSE);
   1: 
   1:     if (mCloseTimer)
   1:       mCloseTimer->Cancel();
   1:   }
   1:   
   1:   mCloseTimer = nsnull;
   1:   mTimerMenu = nsnull;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::KillCloseTimer()
   1: {
   1:   if (mCloseTimer && mTimerMenu) {
   1:     PRBool menuOpen = PR_FALSE;
   1:     mTimerMenu->MenuIsOpen(menuOpen);
   1:     if (menuOpen) {
   1:       mTimerMenu->OpenMenu(PR_FALSE);
   1:     }
   1:     mCloseTimer->Cancel();
   1:     mCloseTimer = nsnull;
   1:     mTimerMenu = nsnull;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::KillPendingTimers ( )
   1: {
   1:   return KillCloseTimer();
   1: 
   1: } // KillPendingTimers
   1: 
   1: NS_IMETHODIMP
   1: nsMenuPopupFrame::CancelPendingTimers()
   1: {
   1:   if (mCloseTimer && mTimerMenu) {
   1:     if (mTimerMenu != mCurrentMenu) {
   1:       SetCurrentMenuItem(mTimerMenu);
   1:     }
   1:     mCloseTimer->Cancel();
   1:     mCloseTimer = nsnull;
   1:     mTimerMenu = nsnull;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::MoveTo(PRInt32 aLeft, PRInt32 aTop)
   1: {
   1:   // Set the 'left' and 'top' attributes
   1:   nsAutoString left, top;
   1:   left.AppendInt(aLeft);
   1:   top.AppendInt(aTop);
   1: 
   1:   nsWeakFrame weakFrame(this);
   1:   mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::left, left, PR_FALSE);
   1:   if (!weakFrame.IsAlive()) {
   1:     return;
   1:   }
   1:   mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::top, top, PR_FALSE);
   1:   if (!weakFrame.IsAlive()) {
   1:     return;
   1:   }
   1: 
   1:   MoveToInternal(aLeft, aTop);
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::MoveToInternal(PRInt32 aLeft, PRInt32 aTop)
   1: {
 677:   // just don't support moving popups for content shells
 677:   if (mInContentShell)
 677:     return;
 677: 
   1:   nsIView* view = GetView();
   1:   NS_ASSERTION(view->GetParent(), "Must have parent!");
   1:   
   1:   // Retrieve screen position of parent view
   1:   nsIntPoint screenPos = view->GetParent()->GetScreenPosition();
   1: 
   1:   // Move the widget
   1:   // XXXbz don't we want screenPos to be the parent _widget_'s position, then?
   1:   view->GetWidget()->Move(aLeft - screenPos.x, aTop - screenPos.y);
   1: }
   1: 
   1: void 
   1: nsMenuPopupFrame::GetAutoPosition(PRBool* aShouldAutoPosition)
   1: {
   1:   *aShouldAutoPosition = mShouldAutoPosition;
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::SetAutoPosition(PRBool aShouldAutoPosition)
   1: {
   1:   mShouldAutoPosition = aShouldAutoPosition;
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::EnableRollup(PRBool aShouldRollup)
   1: {
   1:   if (!nsMenuDismissalListener::sInstance ||
   1:        nsMenuDismissalListener::sInstance->GetCurrentMenuParent() != this)
   1:     return;
   1: 
   1:   if (aShouldRollup)
   1:     nsMenuDismissalListener::sInstance->Register();
   1:   else
   1:     nsMenuDismissalListener::sInstance->Unregister();
   1: }
   1: 
   1: void
   1: nsMenuPopupFrame::SetConsumeRollupEvent(PRUint32 aConsumeMode)
   1: {
   1:   mConsumeRollupEvent = aConsumeMode;
   1: }
   1: 
   1: // nsMenuPopupTimerMediator implementation.
   1: NS_IMPL_ISUPPORTS1(nsMenuPopupTimerMediator, nsITimerCallback)
   1: 
   1: /**
   1:  * Constructs a wrapper around an nsMenuFrame.
   1:  * @param aFrame nsMenuFrame to create a wrapper around.
   1:  */
   1: nsMenuPopupTimerMediator::nsMenuPopupTimerMediator(nsMenuPopupFrame *aFrame) :
   1:   mFrame(aFrame)
   1: {
   1:   NS_ASSERTION(mFrame, "Must have frame");
   1: }
   1: 
   1: nsMenuPopupTimerMediator::~nsMenuPopupTimerMediator()
   1: {
   1: }
   1: 
   1: /**
   1:  * Delegates the notification to the contained frame if it has not been destroyed.
   1:  * @param aTimer Timer which initiated the callback.
   1:  * @return NS_ERROR_FAILURE if the frame has been destroyed.
   1:  */
   1: NS_IMETHODIMP nsMenuPopupTimerMediator::Notify(nsITimer* aTimer)
   1: {
   1:   if (!mFrame)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   return mFrame->Notify(aTimer);
   1: }
   1: 
   1: /**
   1:  * Clear the pointer to the contained nsMenuFrame. This should be called
   1:  * when the contained nsMenuFrame is destroyed.
   1:  */
   1: void nsMenuPopupTimerMediator::ClearFrame()
   1: {
   1:   mFrame = nsnull;
   1: }
