    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
    1:  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef Window_h__
    1: #define Window_h__
    1: 
    1: #include "nsBaseWidget.h"
    1: #include "nsdefs.h"
    1: #include "nsSwitchToUIThread.h"
    1: #include "nsToolkit.h"
    1: 
    1: #include "nsIEventListener.h"
    1: #include "nsString.h"
    1: 
14476: #include "nsTArray.h"
    1: 
    1: class nsNativeDragTarget;
    1: class nsIRollupListener;
    1: 
    1: class nsIFile;
    1: 
    1: class imgIContainer;
    1: 
14476: struct nsAlternativeCharCode;
14962: struct nsFakeCharMessage;
14476: 
    1: #ifdef ACCESSIBILITY
    1: #include "OLEACC.H"
    1: #include "nsIAccessible.h"
    1: #endif
    1: 
  268: #include "gfxWindowsSurface.h"
  268: 
26874: #include "nsWinGesture.h"
26874: 
24836: // Text Services Framework support
24836: #ifndef WINCE
24836: #define NS_ENABLE_TSF
24836: #endif //WINCE
24836: 
    1: #define IME_MAX_CHAR_POS       64
    1: 
    1: #define NSRGB_2_COLOREF(color) \
    1:             RGB(NS_GET_R(color),NS_GET_G(color),NS_GET_B(color))
    1: #define COLOREF_2_NSRGB(color) \
    1:             NS_RGB(GetRValue(color), GetGValue(color), GetBValue(color))
    1: 
 4313: #define WIN2K_VERSION   0x500
 4313: #define WINXP_VERSION   0x501
 4313: #define WIN2K3_VERSION  0x502
 4313: #define VISTA_VERSION   0x600
23788: #define WIN7_VERSION    0x601
 4313: 
 4313: PRInt32 GetWindowsVersion();
 4313: 
    1: /*
    1:  * ::: IMPORTANT :::
    1:  * External apps and drivers depend on window class names.
    1:  * For example, changing the window classes
    1:  * could break touchpad scrolling or screen readers.
    1:  */
    1: const PRUint32 kMaxClassNameLength    = 40;
23186: const LPCWSTR kClassNameHidden       = L"MozillaHiddenWindowClass";
23186: const LPCWSTR kClassNameUI           = L"MozillaUIWindowClass";
23186: const LPCWSTR kClassNameContent      = L"MozillaContentWindowClass";
23186: const LPCWSTR kClassNameContentFrame = L"MozillaContentFrameWindowClass";
23186: const LPCWSTR kClassNameGeneral      = L"MozillaWindowClass";
23186: const LPCWSTR kClassNameDialog       = L"MozillaDialogClass";
    1: 
18536: typedef enum
18536: {
18536:     TRI_UNKNOWN = -1,
18536:     TRI_FALSE = 0,
18536:     TRI_TRUE = 1
18536: } TriStateBool;
18536: 
    1: /**
    1:  * Native WIN32 window wrapper.
    1:  */
    1: 
    1: class nsWindow : public nsSwitchToUIThread,
15919:                  public nsBaseWidget
    1: {
    1: public:
    1:   nsWindow();
    1:   virtual ~nsWindow();
    1: 
 4345:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIWidget interface
    1:   NS_IMETHOD              Create(nsIWidget *aParent,
23738:                                  const nsIntRect &aRect,
    1:                                  EVENT_CALLBACK aHandleEventFunction,
    1:                                  nsIDeviceContext *aContext,
    1:                                  nsIAppShell *aAppShell = nsnull,
    1:                                  nsIToolkit *aToolkit = nsnull,
    1:                                  nsWidgetInitData *aInitData = nsnull);
    1:   NS_IMETHOD              Create(nsNativeWidget aParent,
23738:                                  const nsIntRect &aRect,
    1:                                  EVENT_CALLBACK aHandleEventFunction,
    1:                                  nsIDeviceContext *aContext,
    1:                                  nsIAppShell *aAppShell = nsnull,
    1:                                  nsIToolkit *aToolkit = nsnull,
    1:                                  nsWidgetInitData *aInitData = nsnull);
    1: 
    1:   // Utility method for implementing both Create(nsIWidget ...) and
    1:   // Create(nsNativeWidget...)
    1: 
    1:   virtual nsresult        StandardWindowCreate(nsIWidget *aParent,
23738:                                                const nsIntRect &aRect,
    1:                                                EVENT_CALLBACK aHandleEventFunction,
    1:                                                nsIDeviceContext *aContext,
    1:                                                nsIAppShell *aAppShell,
    1:                                                nsIToolkit *aToolkit,
    1:                                                nsWidgetInitData *aInitData,
    1:                                                nsNativeWidget aNativeParent = nsnull);
    1: 
    1:   NS_IMETHOD              Destroy();
    1:   NS_IMETHOD              SetParent(nsIWidget *aNewParent);
    1:   virtual nsIWidget*      GetParent(void);
    1:   NS_IMETHOD              Show(PRBool bState);
    1:   NS_IMETHOD              IsVisible(PRBool & aState);
    1:   NS_IMETHOD              PlaceBehind(nsTopLevelWidgetZPlacement aPlacement, nsIWidget *aWidget, PRBool aActivate);
    1:   NS_IMETHOD              SetSizeMode(PRInt32 aMode);
    1:   NS_IMETHOD              CaptureMouse(PRBool aCapture);
    1:   NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY);
    1:   NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
    1:   NS_IMETHOD              Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
    1:   NS_IMETHOD              Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
    1:   NS_IMETHOD              Enable(PRBool aState);
    1:   NS_IMETHOD              IsEnabled(PRBool *aState);
    1:   NS_IMETHOD              SetFocus(PRBool aRaise);
23738:   NS_IMETHOD              GetBounds(nsIntRect &aRect);
23738:   NS_IMETHOD              GetClientBounds(nsIntRect &aRect);
23738:   NS_IMETHOD              GetScreenBounds(nsIntRect &aRect);
    1:   NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
    1:   NS_IMETHOD              SetCursor(nsCursor aCursor);
    1:   NS_IMETHOD              SetCursor(imgIContainer* aCursor,
    1:                                     PRUint32 aHotspotX, PRUint32 aHotspotY);
    1:   NS_IMETHOD              HideWindowChrome(PRBool aShouldHide);
    1:   NS_IMETHOD              Validate();
    1:   NS_IMETHOD              Invalidate(PRBool aIsSynchronous);
23738:   NS_IMETHOD              Invalidate(const nsIntRect & aRect, PRBool aIsSynchronous);
    1:   NS_IMETHOD              Update();
    1:   virtual void*           GetNativeData(PRUint32 aDataType);
    1:   virtual void            FreeNativeData(void * data, PRUint32 aDataType);//~~~
23738:   NS_IMETHOD              Scroll(PRInt32 aDx, PRInt32 aDy, nsIntRect *aClipRect);
    1:   NS_IMETHOD              SetTitle(const nsAString& aTitle);
    1:   NS_IMETHOD              SetIcon(const nsAString& aIconSpec);
25183:   virtual nsIntPoint      WidgetToScreenOffset();
    1:   NS_IMETHOD              BeginResizingChildren(void);
    1:   NS_IMETHOD              EndResizingChildren(void);
    1:   NS_IMETHOD              DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus);
    1:   NS_IMETHOD              EnableDragDrop(PRBool aEnable);
    1: 
    1:   virtual void            SetUpForPaint(HDC aHDC);
    1: 
    1:   NS_IMETHOD              CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent);
    1: 
    1:   NS_IMETHOD              GetAttention(PRInt32 aCycleCount);
26911:   NS_IMETHOD              GetLastInputEventTime(PRUint32& aTime);
19016: 
19016:   // Note that the result of GetTopLevelWindow method can be different from the
19016:   // result of GetTopLevelHWND method.  The result can be non-floating window.
19016:   // Because our top level window may be contained in another window which is
19016:   // not managed by us.
19016:   nsWindow*               GetTopLevelWindow(PRBool aStopOnDialogOrPopup);
    1: 
    1:   gfxASurface             *GetThebesSurface();
    1: 
    1: #ifdef MOZ_XUL
16601:   virtual void            SetTransparencyMode(nsTransparencyMode aMode);
16601:   virtual nsTransparencyMode GetTransparencyMode();
    1: private:
16601:   void                    SetWindowTranslucencyInner(nsTransparencyMode aMode);
16601:   nsTransparencyMode      GetWindowTranslucencyInner() const { return mTransparencyMode; }
    1:   void                    ResizeTranslucentWindow(PRInt32 aNewWidth, PRInt32 aNewHeight, PRBool force = PR_FALSE);
    1:   nsresult                UpdateTranslucentWindow();
16601:   void                    SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode);
    1: public:
    1: #endif
    1: 
    1:   NS_IMETHOD ResetInputState();
    1:   NS_IMETHOD SetIMEOpenState(PRBool aState);
    1:   NS_IMETHOD GetIMEOpenState(PRBool* aState);
  539:   NS_IMETHOD SetIMEEnabled(PRUint32 aState);
  539:   NS_IMETHOD GetIMEEnabled(PRUint32* aState);
    1:   NS_IMETHOD CancelIMEComposition();
 2475:   NS_IMETHOD GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState);
    1: 
24836: #ifdef NS_ENABLE_TSF
24836:   NS_IMETHOD OnIMEFocusChange(PRBool aFocus);
24836:   NS_IMETHOD OnIMETextChange(PRUint32 aStart, PRUint32 aOldEnd, PRUint32 aNewEnd);
24836:   NS_IMETHOD OnIMESelectionChange(void);
24836: #endif //NS_ENABLE_TSF
24836: 
    1:   PRBool IMEMouseHandling(PRInt32 aAction, LPARAM lParam);
    1:   PRBool IMECompositionHitTest(POINT * ptPos);
    1:   PRBool HandleMouseActionOfIME(PRInt32 aAction, POINT* ptPos);
    1: 
    1:   // nsSwitchToUIThread interface
    1:   virtual BOOL            CallMethod(MethodInfo *info);
    1: 
    1:   HWND                    GetWindowHandle() { return mWnd; }
    1:   WNDPROC                 GetPrevWindowProc() { return mPrevWndProc; }
    1: 
    1:   virtual PRBool          DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam,
    1:                                              LPARAM lParam,
    1:                                              PRBool aIsContextMenuKey = PR_FALSE,
    1:                                              PRInt16 aButton = nsMouseEvent::eLeftButton);
24836:   virtual PRBool          DispatchWindowEvent(nsGUIEvent* event);
24836:   virtual PRBool          DispatchWindowEvent(nsGUIEvent*event, nsEventStatus &aStatus);
    1: #ifdef ACCESSIBILITY
23738:   virtual PRBool          DispatchAccessibleEvent(PRUint32 aEventType, nsIAccessible** aAccessible, nsIntPoint* aPoint = nsnull);
    1:   already_AddRefed<nsIAccessible> GetRootAccessible();
    1: #endif
    1:   virtual PRBool          AutoErase();
23738:   nsIntPoint*             GetLastPoint() { return &mLastPoint; }
    1: 
    1:   PRInt32                 GetNewCmdMenuId() { mMenuCmdId++; return mMenuCmdId; }
    1: 
23738:   void                    InitEvent(nsGUIEvent& event, nsIntPoint* aPoint = nsnull);
    1: 
    1:   void                    SuppressBlurEvents(PRBool aSuppress);
    1:   PRBool                  BlurEventsSuppressed();
    1: 
    1: protected:
    1: 
    1:   // special callback hook methods for pop ups
    1:   static LRESULT CALLBACK MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam);
    1:   static LRESULT CALLBACK MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam);
    1:   static LRESULT CALLBACK MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam);
    1:   static VOID    CALLBACK HookTimerForPopups( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );
    1:   static void             ScheduleHookTimer(HWND aWnd, UINT aMsgId);
    1: 
    1:   static void             RegisterSpecialDropdownHooks();
    1:   static void             UnregisterSpecialDropdownHooks();
    1: 
    1:   static void             PostSleepWakeNotification(const char* aNotification);
    1: 
    1:   static BOOL             DealWithPopups (HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult);
    1: 
    1:   static PRBool           EventIsInsideWindow(UINT Msg, nsWindow* aWindow);
    1: 
    1:   static nsWindow*        GetNSWindowPtr(HWND aWnd);
    1:   static BOOL             SetNSWindowPtr(HWND aWnd, nsWindow * ptr);
27505:   nsWindow*               GetParentWindow(PRBool aIncludeOwner);
    1: 
    1:   void                    DispatchPendingEvents();
    1:   virtual PRBool          ProcessMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *aRetValue);
26874:   virtual PRBool          ProcessGestureMessage(WPARAM wParam, LPARAM lParam);
22788: 
22788:   /**
22788:    * The result means whether this method processed the native event for
22788:    * plugin. If false, the native event should be processed by the caller self.
22788:    */
22788:   PRBool                  ProcessMessageForPlugin(const MSG &aMsg,
22788:                             LRESULT *aRetValue, PRBool &aCallDefWndProc);
22788: 
22788:   LRESULT                 ProcessCharMessage(const MSG &aMsg,
22788:                                              PRBool *aEventDispatched);
22788:   LRESULT                 ProcessKeyUpMessage(const MSG &aMsg,
22788:                                               PRBool *aEventDispatched);
22788:   LRESULT                 ProcessKeyDownMessage(const MSG &aMsg,
22788:                                                 PRBool *aEventDispatched);
22788: 
    1:    // Allow Derived classes to modify the height that is passed
    1:    // when the window is created or resized.
    1:   virtual PRInt32         GetHeight(PRInt32 aProposedHeight);
23186:   virtual LPCWSTR         WindowClass();
23186:   virtual LPCWSTR         WindowPopupClass();
    1:   virtual DWORD           WindowStyle();
    1:   virtual DWORD           WindowExStyle();
    1: 
    1:   virtual void            SubclassWindow(BOOL bState);
    1: 
    1:   virtual void            OnDestroy();
    1:   virtual PRBool          OnMove(PRInt32 aX, PRInt32 aY);
    1:   virtual PRBool          OnPaint(HDC aDC = nsnull);
23738:   virtual PRBool          OnResize(nsIntRect &aWindowRect);
    1:   
14962:   void                    SetupModKeyState();
22788:   void                    RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg, UINT aLastMsg);
22788: 
22788:   LRESULT                 OnChar(const MSG &aMsg, PRBool *aEventDispatched,
22788:                                  PRUint32 aFlags = 0);
22788:   LRESULT                 OnKeyDown(const MSG &aMsg, PRBool *aEventDispatched,
14962:                                     nsFakeCharMessage* aFakeCharMessage);
22788:   LRESULT                 OnKeyUp(const MSG &aMsg, PRBool *aEventDispatched);
22788: 
22788:   LRESULT                 OnCharRaw(UINT charCode, UINT aScanCode,
22788:                                     PRUint32 aFlags = 0,
22788:                                     const MSG *aMsg = nsnull,
22788:                                     PRBool *aEventDispatched = nsnull);
22788: 
    1:   UINT                    MapFromNativeToDOM(UINT aNativeKeyCode);
    1: 
    1: 
22411:   BOOL                    OnInputLangChange(HKL aHKL);
22788:   BOOL                    OnIMEChar(wchar_t uniChar, LPARAM aKeyState);
    1:   BOOL                    OnIMEComposition(LPARAM  aGCS);
    1:   BOOL                    OnIMECompositionFull();
    1:   BOOL                    OnIMEEndComposition();
22788:   BOOL                    OnIMENotify(WPARAM  aIMN, LPARAM aData);
    1:   BOOL                    OnIMERequest(WPARAM  aIMR, LPARAM aData, LRESULT *oResult);
    1:   BOOL                    OnIMESelect(BOOL  aSelected, WORD aLangID);
    1:   BOOL                    OnIMESetContext(BOOL aActive, LPARAM& aISC);
    1:   BOOL                    OnIMEStartComposition();
    1:   BOOL                    OnIMEReconvert(LPARAM aData, LRESULT *oResult);
    1:   BOOL                    OnIMEQueryCharPosition(LPARAM aData, LRESULT *oResult);
    1: 
21031:   void                    GetCompositionString(HIMC aHIMC, DWORD aIndex);
16603: 
16603:   /**
16603:    *  ResolveIMECaretPos
16603:    *  Convert the caret rect of a composition event to another widget's
16603:    *  coordinate system.
16603:    *
16603:    *  @param aReferenceWidget The origin widget of aCursorRect.
16603:    *                          Typically, this is mReferenceWidget of the
16603:    *                          composing events. If the aCursorRect is in screen
16603:    *                          coordinates, set nsnull.
16603:    *  @param aCursorRect      The cursor rect.
16603:    *  @param aNewOriginWidget aOutRect will be in this widget's coordinates. If
16603:    *                          this is nsnull, aOutRect will be in screen
16603:    *                          coordinates.
16603:    *  @param aOutRect         The converted cursor rect.
16603:    */
16603:   void                    ResolveIMECaretPos(nsIWidget* aReferenceWidget,
23738:                                              nsIntRect& aCursorRect,
16603:                                              nsIWidget* aNewOriginWidget,
23738:                                              nsIntRect& aOutRect);
    1: 
22411:   PRBool                  ConvertToANSIString(const nsAFlatString& aStr,
22411:                                               UINT aCodePage,
22411:                                               nsACString& aANSIStr);
22411: 
14328:   virtual PRBool          DispatchKeyEvent(PRUint32 aEventType, WORD aCharCode,
14476:                             const nsTArray<nsAlternativeCharCode>* aAlternativeChars,
22788:                             UINT aVirtualCharCode, const MSG *aMsg,
14328:                             PRUint32 aFlags = 0);
    1: 
22788:   PRBool                  DispatchPluginEvent(const MSG &aMsg);
22788: 
    1:   virtual PRBool          DispatchFocus(PRUint32 aEventType, PRBool isMozWindowTakingFocus);
    1:   virtual PRBool          OnScroll(UINT scrollCode, int cPos);
    1:   virtual HBRUSH          OnControlColor();
    1: 
    1:   static LRESULT CALLBACK WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    1: 
    1:   // Convert nsEventStatus value to a windows boolean
    1:   static PRBool ConvertStatus(nsEventStatus aStatus)
    1:                        { return aStatus == nsEventStatus_eConsumeNoDefault; }
    1: 
    1:   PRBool DispatchStandardEvent(PRUint32 aMsg);
    1:   PRBool DispatchCommandEvent(PRUint32 aEventCommand);
    1:   void RelayMouseEvent(UINT aMsg, WPARAM wParam, LPARAM lParam);
    1: 
23738:   void GetNonClientBounds(nsIntRect &aRect);
    1:   void HandleTextEvent(HIMC hIMEContext, PRBool aCheckAttr = PR_TRUE);
25732:   void HandleStartComposition(HIMC hIMEContext);
25732:   void HandleEndComposition();
    1:   void GetTextRangeList(PRUint32* textRangeListLengthResult, nsTextRangeArray* textRangeListResult);
25732:   PRBool GetCharacterRectOfSelectedTextAt(PRInt32 aOffset,
25732:                                           nsIntRect &aCharRect);
25732:   PRBool GetCaretRect(nsIntRect &aCaretRect);
25732:   PRBool SetIMERelatedWindowsPos(HIMC aIMEContext);
    1: 
    1:   void ConstrainZLevel(HWND *aAfter);
    1: 
    1:   LPARAM lParamToScreen(LPARAM lParam);
    1:   LPARAM lParamToClient(LPARAM lParam);
    1: 
    1:   PRBool CanTakeFocus();
    1: 
14998:   virtual nsresult SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
14962:                                             PRInt32 aNativeKeyCode,
14962:                                             PRUint32 aModifierFlags,
14962:                                             const nsAString& aCharacters,
14962:                                             const nsAString& aUnmodifiedCharacters);
14962: 
22788:   PRBool PluginHasFocus()
22788:   {
22788:     return mIMEEnabled == nsIWidget::IME_STATUS_PLUGIN;
22788:   }
22788: 
22788:   MSG InitMSG(UINT aMessage, WPARAM wParam, LPARAM lParam)
22788:   {
22788:     MSG msg;
22788:     msg.message = aMessage;
22788:     msg.wParam  = wParam;
22788:     msg.lParam  = lParam;
22788:     return msg;
22788:   }
26576: 
26576:   // XP and Vista theming support for windows with rounded edges.
26576:   void ClearThemeRegion();
26576:   void SetThemeRegion();
26616: 
26616:   void StopFlashing();
    1: private:
    1: 
    1: #ifdef DEBUG
    1:   void DebugPrintEvent(nsGUIEvent& aEvent, HWND aWnd);
    1: #endif
    1: 
    1: protected:
    1:   // Count of nsWindow instances. Used to manage IME buffers
    1:   static PRUint32   sInstanceCount;
    1: 
    1:   // For Input Method Support
    1:   // Only one set of IME buffers is needed for a process.
    1:   static PRBool     sIMEIsComposing;
    1:   static PRBool     sIMEIsStatusChanged;
    1: 
    1:   static nsString*  sIMECompUnicode;
    1:   static PRUint8*   sIMEAttributeArray;
    1:   static PRInt32    sIMEAttributeArrayLength;
    1:   static PRInt32    sIMEAttributeArraySize;
    1:   static PRUint32*  sIMECompClauseArray;
    1:   static PRInt32    sIMECompClauseArrayLength;
    1:   static PRInt32    sIMECompClauseArraySize;
    1:   static long       sIMECursorPosition;
25732:   static PRBool     sIMENativeCaretIsCreated;
    1: 
    1:   // For describing composing frame
25732:   // XXX mnakano -  We should remove this, because its value may be wrong in
25732:   // some cases, and we should query it when it is needed.
    1:   static RECT*      sIMECompCharPos;
    1: 
18536:   static TriStateBool sCanQuit;
 4465: 
23738:   nsIntSize     mLastSize;
    1:   static        nsWindow* gCurrentWindow;
23738:   nsIntPoint    mLastPoint;
    1:   HWND          mWnd;
    1:   HDC           mPaintDC; // only set during painting
    1: #if 0
    1:   HPALETTE      mPalette;
    1: #endif
    1:   WNDPROC       mPrevWndProc;
    1:   HBRUSH        mBrush;
    1: 
    1: #ifdef MOZ_XUL
    1:   // use layered windows to support full 256 level alpha translucency
 9499:   nsRefPtr<gfxWindowsSurface> mTransparentSurface;
 5253: 
    1:   HDC           mMemoryDC;
16601:   nsTransparencyMode mTransparencyMode;
    1: #endif
    1:   PRPackedBool  mIsTopWidgetWindow;
    1:   PRPackedBool  mHas3DBorder;
    1:   PRPackedBool  mIsShiftDown;
    1:   PRPackedBool  mIsControlDown;
    1:   PRPackedBool  mIsAltDown;
    1:   PRPackedBool  mIsDestroying;
    1:   PRPackedBool  mIsVisible;
    1:   PRPackedBool  mIsInMouseCapture;
    1:   PRPackedBool  mIsInMouseWheelProcessing;
    1:   PRPackedBool  mUnicodeWidget;
21999:   PRPackedBool  mIsPluginWindow;
    1: 
    1:   PRPackedBool  mPainting;
    1:   char          mLeadByte;
    1:   PRUint32      mBlurEventSuppressionLevel;
    1:   nsContentType mContentType;
    1: 
    1:   PRInt32       mPreferredWidth;
    1:   PRInt32       mPreferredHeight;
    1: 
    1:   PRInt32       mMenuCmdId;
    1: 
    1:   // Window styles used by this window before chrome was hidden
25349:   DWORD_PTR     mOldStyle;
25349:   DWORD_PTR     mOldExStyle;
    1: 
    1:   // To enable/disable IME
    1:   HIMC          mOldIMC;
  539:   PRUint32      mIMEEnabled;
    1: 
    1:   static PRBool gSwitchKeyboardLayout;
    1: 
    1:   HKL           mLastKeyboardLayout;
    1: 
26576:   nsPopupType   mPopupType;
26576: 
    1:   // Drag & Drop
    1:   nsNativeDragTarget * mNativeDragTarget;
    1: 
26874:   // Win7 Gesture processing and management
26874:   nsWinGesture mGesture;
26874: 
    1:   // Enumeration of the methods which are accessible on the "main GUI thread"
    1:   // via the CallMethod(...) mechanism...
    1:   // see nsSwitchToUIThread
    1:   enum {
    1:     CREATE = 0x0101,
    1:     CREATE_NATIVE,
    1:     DESTROY,
    1:     SET_FOCUS,
    1:     SET_CURSOR,
    1:     CREATE_HACK
    1:   };
    1: 
    1:   static BOOL   sIsRegistered;
    1:   static BOOL   sIsPopupClassRegistered;
 7271:   static BOOL   sIsOleInitialized; // OLE is needed for clipboard and drag & drop support
    1: 
    1:   HDWP mDeferredPositioner;
    1:   static UINT   uWM_MSIME_MOUSE;     // mouse message for MSIME
    1: 
    1:   // Heap dump
    1:   static UINT   uWM_HEAP_DUMP;       // Dump heap to a file
    1: 
    1:   // Cursor caching
    1:   static HCURSOR        gHCursor;
    1:   static imgIContainer* gCursorImgContainer;
    1: 
    1: #ifdef ACCESSIBILITY
    1:   static BOOL gIsAccessibilityOn;
    1:   static HINSTANCE gmAccLib;
    1:   static LPFNLRESULTFROMOBJECT gmLresultFromObject;
    1:   static STDMETHODIMP_(LRESULT) LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN pAcc);
    1: #endif
    1: 
    1:   static BOOL CALLBACK BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg);
    1:   static BOOL CALLBACK BroadcastMsg(HWND aTopWindow, LPARAM aMsg);
    1:   static BOOL CALLBACK DispatchStarvedPaints(HWND aTopWindow, LPARAM aMsg);
 7640:   static BOOL CALLBACK InvalidateForeignChildWindows(HWND aWnd, LPARAM aMsg);
    1: 
    1: public:
    1:   static void GlobalMsgWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
19016:   // Note that the result of GetTopLevelHWND can be different from the result
19016:   // of GetTopLevelWindow method.  Because this is checking whether the window
19016:   // is top level only in Win32 window system.  Therefore, the result window
19016:   // may not be managed by us.
19016:   static HWND GetTopLevelHWND(HWND aWnd,
19016:                               PRBool aStopOnDialogOrPopup = PR_FALSE);
    1: };
    1: 
    1: //
    1: // A child window is a window with different style
    1: //
    1: class ChildWindow : public nsWindow {
    1: 
    1: public:
    1:   ChildWindow() {}
    1:   PRBool DispatchMouseEvent(PRUint32 aEventType, WPARAM wParam, LPARAM lParam,
    1:                             PRBool aIsContextMenuKey = PR_FALSE,
    1:                             PRInt16 aButton = nsMouseEvent::eLeftButton);
    1: 
    1: protected:
    1:   virtual DWORD WindowStyle();
    1: };
    1: 
    1: 
    1: #endif // Window_h__
