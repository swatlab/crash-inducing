    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Aaron Leventhal (aaronl@netscape.com)
    1:  *   Kyle Yuan (kyle.yuan@sun.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
41384: #include "nsXULFormControlAccessible.h"
41384: 
41384: #include "nsAccessibilityAtoms.h"
41384: #include "nsAccUtils.h"
41384: #include "nsAccTreeWalker.h"
41384: #include "nsCoreUtils.h"
57413: #include "nsDocAccessible.h"
41384: #include "nsRelUtils.h"
67790: #include "States.h"
41384: 
    1: // NOTE: alphabetically ordered
    1: #include "nsHTMLFormControlAccessible.h"
    1: #include "nsXULMenuAccessible.h"
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIDOMNSEditableElement.h"
    1: #include "nsIDOMXULButtonElement.h"
    1: #include "nsIDOMXULCheckboxElement.h"
    1: #include "nsIDOMXULMenuListElement.h"
    1: #include "nsIDOMXULSelectCntrlItemEl.h"
    1: #include "nsIDOMXULTextboxElement.h"
 4625: #include "nsIEditor.h"
    1: #include "nsIFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsITextControlFrame.h"
    1: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible
34719: ////////////////////////////////////////////////////////////////////////////////
    1: 
34719: nsXULButtonAccessible::
43504:   nsXULButtonAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible: nsISupports
34719: 
34719: NS_IMPL_ISUPPORTS_INHERITED0(nsXULButtonAccessible, nsAccessible)
34719: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible: nsIAccessible
34719: 
34719: NS_IMETHODIMP
34719: nsXULButtonAccessible::GetNumActions(PRUint8 *aCount)
    1: {
34719:   NS_ENSURE_ARG_POINTER(aCount);
34719: 
34719:   *aCount = 1;
    1:   return NS_OK;
    1: }
    1: 
34719: NS_IMETHODIMP
34719: nsXULButtonAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     aName.AssignLiteral("press"); 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
34719: NS_IMETHODIMP
34719: nsXULButtonAccessible::DoAction(PRUint8 aIndex)
    1: {
37481:   if (aIndex != 0)
37481:     return NS_ERROR_INVALID_ARG;
34719: 
37481:   DoCommand();
37481:   return NS_OK;
    1: }
    1: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible: nsAccessNode
34719: 
43538: PRBool
34719: nsXULButtonAccessible::Init()
34719: {
43538:   if (!nsAccessibleWrap::Init())
43538:     return PR_FALSE;
34719: 
34719:   if (ContainsMenu())
43504:     nsCoreUtils::GeneratePopupTree(mContent);
34719: 
43538:   return PR_TRUE;
34719: }
34719: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible: nsAccessible
34719: 
52027: PRUint32
52027: nsXULButtonAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_PUSHBUTTON;
    1: }
    1: 
67790: PRUint64
67790: nsXULButtonAccessible::NativeState()
    1: {
34719:   // Possible states: focused, focusable, unavailable(disabled).
34719: 
    1:   // get focus and disable status from base class
67790:   PRUint64 state = nsAccessible::NativeState();
    1: 
    1:   PRBool disabled = PR_FALSE;
43504:   nsCOMPtr<nsIDOMXULControlElement> xulFormElement(do_QueryInterface(mContent));
    1:   if (xulFormElement) {
    1:     xulFormElement->GetDisabled(&disabled);
    1:     if (disabled)
67790:       state |= states::UNAVAILABLE;
    1:     else 
67790:       state |= states::FOCUSABLE;
    1:   }
    1: 
    1:   // Buttons can be checked -- they simply appear pressed in rather than checked
43504:   nsCOMPtr<nsIDOMXULButtonElement> xulButtonElement(do_QueryInterface(mContent));
    1:   if (xulButtonElement) {
 1157:     nsAutoString type;
 1157:     xulButtonElement->GetType(type);
 1157:     if (type.EqualsLiteral("checkbox") || type.EqualsLiteral("radio")) {
67790:       state |= states::CHECKABLE;
    1:       PRBool checked = PR_FALSE;
    1:       PRInt32 checkState = 0;
    1:       xulButtonElement->GetChecked(&checked);
    1:       if (checked) {
67790:         state |= states::PRESSED;
    1:         xulButtonElement->GetCheckState(&checkState);
 1157:         if (checkState == nsIDOMXULButtonElement::CHECKSTATE_MIXED) { 
67790:           state |= states::MIXED;
    1:         }
    1:       }
 1157:     }
 1157:   }
    1: 
34719:   if (ContainsMenu())
67790:     state |= states::HASPOPUP;
34719: 
43504:   if (mContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::_default))
67790:     state |= states::DEFAULT;
    1: 
67790:   return state;
    1: }
    1: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible: nsAccessible protected
34719: 
34719: void
34719: nsXULButtonAccessible::CacheChildren()
    1: {
34719:   // In general XUL button has not accessible children. Nevertheless menu
34719:   // buttons can have button (@type="menu-button") and popup accessibles
34719:   // (@type="menu-button" or @type="menu").
34719: 
34719:   // XXX: no children until the button is menu button. Probably it's not
34719:   // totally correct but in general AT wants to have leaf buttons.
43504:   PRBool isMenu = mContent->AttrValueIs(kNameSpaceID_None,
34719:                                        nsAccessibilityAtoms::type,
34719:                                        nsAccessibilityAtoms::menu,
34719:                                        eCaseMatters);
34719: 
34719:   PRBool isMenuButton = isMenu ?
34719:     PR_FALSE :
43504:     mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
34719:                           nsAccessibilityAtoms::menuButton, eCaseMatters);
34719: 
34719:   if (!isMenu && !isMenuButton)
34719:     return;
34719: 
64506:   nsAccessible* menupopup = nsnull;
64506:   nsAccessible* button = nsnull;
34719: 
43504:   nsAccTreeWalker walker(mWeakShell, mContent, PR_TRUE);
34719: 
64506:   nsAccessible* child = nsnull;
64506:   while ((child = walker.NextChild())) {
52089:     PRUint32 role = child->Role();
34719: 
34719:     if (role == nsIAccessibleRole::ROLE_MENUPOPUP) {
64506:       // Get an accessible for menupopup or panel elements.
64506:       menupopup = child;
34719: 
34719:     } else if (isMenuButton && role == nsIAccessibleRole::ROLE_PUSHBUTTON) {
34719:       // Button type="menu-button" contains a real button. Get an accessible
64506:       // for it. Ignore dropmarker button which is placed as a last child.
64506:       button = child;
34719:       break;
57413: 
57413:     } else {
57413:       // Unbind rejected accessible from document.
57413:       GetDocAccessible()->UnbindFromDocument(child);
34719:     }
    1:   }
    1: 
64506:   if (!menupopup)
34719:     return;
    1: 
64506:   AppendChild(menupopup);
64506:   if (button)
64506:     AppendChild(button);
    1: }
    1: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULButtonAccessible protected
34719: 
34719: PRBool
34719: nsXULButtonAccessible::ContainsMenu()
34719: {
34719:   static nsIContent::AttrValuesArray strings[] =
34719:     {&nsAccessibilityAtoms::menu, &nsAccessibilityAtoms::menuButton, nsnull};
34719: 
43504:   return mContent->FindAttrValueIn(kNameSpaceID_None,
43504:                                    nsAccessibilityAtoms::type,
34719:                                    strings, eCaseMatters) >= 0;
34719: }
34719: 
34719: ////////////////////////////////////////////////////////////////////////////////
34719: // nsXULDropmarkerAccessible
34719: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsXULDropmarkerAccessible::
43504:   nsXULDropmarkerAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsFormControlAccessible(aContent, aShell)
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsXULDropmarkerAccessible::GetNumActions(PRUint8 *aResult)
    1: {
    1:   *aResult = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsXULDropmarkerAccessible::DropmarkerOpen(PRBool aToggleOpen)
    1: {
    1:   PRBool isOpen = PR_FALSE;
    1: 
43504:   nsCOMPtr<nsIDOMXULButtonElement> parentButtonElement =
43504:     do_QueryInterface(mContent->GetParent());
    1: 
    1:   if (parentButtonElement) {
    1:     parentButtonElement->GetOpen(&isOpen);
    1:     if (aToggleOpen)
    1:       parentButtonElement->SetOpen(!isOpen);
    1:   }
    1:   else {
43504:     nsCOMPtr<nsIDOMXULMenuListElement> parentMenuListElement =
43504:       do_QueryInterface(parentButtonElement);
    1:     if (parentMenuListElement) {
    1:       parentMenuListElement->GetOpen(&isOpen);
    1:       if (aToggleOpen)
    1:         parentMenuListElement->SetOpen(!isOpen);
    1:     }
    1:   }
    1: 
    1:   return isOpen;
    1: }
    1: 
    1: /**
    1:   * Return the name of our only action
    1:   */
    1: NS_IMETHODIMP nsXULDropmarkerAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     if (DropmarkerOpen(PR_FALSE))
    1:       aName.AssignLiteral("close");
    1:     else
    1:       aName.AssignLiteral("open");
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: /**
20072:   * Tell the Dropmarker to do its action
    1:   */
    1: NS_IMETHODIMP nsXULDropmarkerAccessible::DoAction(PRUint8 index)
    1: {
    1:   if (index == eAction_Click) {
    1:     DropmarkerOpen(PR_TRUE); // Reverse the open attribute
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
52027: PRUint32
52027: nsXULDropmarkerAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_PUSHBUTTON;
    1: }
    1: 
67790: PRUint64
67790: nsXULDropmarkerAccessible::NativeState()
    1: {
68037: 
68037:   if (IsDefunct())
68037:     return states::DEFUNCT;
68037: 
67790:   return DropmarkerOpen(PR_FALSE) ? states::PRESSED : 0;
    1: }
    1: 
    1:                       
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULCheckboxAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsXULCheckboxAccessible::
43504:   nsXULCheckboxAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsFormControlAccessible(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsXULCheckboxAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_CHECKBUTTON;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULCheckboxAccessible::GetNumActions(PRUint8 *_retval)
    1: {
    1:   *_retval = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * Return the name of our only action
    1:   */
    1: NS_IMETHODIMP nsXULCheckboxAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     // check or uncheck
    1: 
67790:     if (NativeState() & states::CHECKED)
    1:       aName.AssignLiteral("uncheck");
    1:     else
    1:       aName.AssignLiteral("check");
    1: 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: /**
    1:   * Tell the checkbox to do its only action -- check( or uncheck) itself
    1:   */
37481: NS_IMETHODIMP
37481: nsXULCheckboxAccessible::DoAction(PRUint8 aIndex)
    1: {
37481:   if (aIndex != eAction_Click)
    1:     return NS_ERROR_INVALID_ARG;
37481: 
37481:   DoCommand();
37481:   return NS_OK;
    1: }
    1: 
67790: PRUint64
67790: nsXULCheckboxAccessible::NativeState()
    1: {
67790:   // Possible states: focused, focusable, unavailable(disabled), checked
    1:   // Get focus and disable status from base class
67790:   PRUint64 state = nsFormControlAccessible::NativeState();
    1:   
67790:   state |= states::CHECKABLE;
 1157:   
    1:   // Determine Checked state
43504:   nsCOMPtr<nsIDOMXULCheckboxElement> xulCheckboxElement =
43504:     do_QueryInterface(mContent);
    1:   if (xulCheckboxElement) {
    1:     PRBool checked = PR_FALSE;
    1:     xulCheckboxElement->GetChecked(&checked);
    1:     if (checked) {
67790:       state |= states::CHECKED;
    1:       PRInt32 checkState = 0;
    1:       xulCheckboxElement->GetCheckState(&checkState);
    1:       if (checkState == nsIDOMXULCheckboxElement::CHECKSTATE_MIXED)
67790:         state |= states::MIXED;
    1:     }
    1:   }
    1: 
67790:   return state;
    1: }
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULGroupboxAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsXULGroupboxAccessible::
43504:   nsXULGroupboxAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsXULGroupboxAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_GROUPING;
    1: }
    1: 
20246: nsresult
20246: nsXULGroupboxAccessible::GetNameInternal(nsAString& aName)
    1: {
24822:   // XXX: we use the first related accessible only.
24822:   nsCOMPtr<nsIAccessible> label =
24822:     nsRelUtils::GetRelatedAccessible(this, nsIAccessibleRelation::RELATION_LABELLED_BY);
24822: 
 2985:   if (label) {
 2985:     return label->GetName(aName);
 2985:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2985: NS_IMETHODIMP
24822: nsXULGroupboxAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                            nsIAccessibleRelation **aRelation)
    1: {
24822:   nsresult rv = nsAccessibleWrap::GetRelationByType(aRelationType, aRelation);
24822:   NS_ENSURE_SUCCESS(rv, rv);
 2985: 
 2985:   if (aRelationType == nsIAccessibleRelation::RELATION_LABELLED_BY) {
 2985:     // The label for xul:groupbox is generated from xul:label that is
 2985:     // inside the anonymous content of the xul:caption.
 2985:     // The xul:label has an accessible object but the xul:caption does not
40990:     PRInt32 childCount = GetChildCount();
40990:     for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
40990:       nsAccessible *childAcc = GetChildAt(childIdx);
52089:       if (childAcc->Role() == nsIAccessibleRole::ROLE_LABEL) {
 2985:         // Ensure that it's our label
24822:         // XXX: we'll fail if group accessible expose more than one relation
24822:         // targets.
24822:         nsCOMPtr<nsIAccessible> testGroupboxAccessible =
40990:           nsRelUtils::GetRelatedAccessible(childAcc,
24822:                                            nsIAccessibleRelation::RELATION_LABEL_FOR);
24822: 
 2985:         if (testGroupboxAccessible == this) {
 2985:           // The <label> points back to this groupbox
24822:           return nsRelUtils::
40990:             AddTarget(aRelationType, aRelation, childAcc);
    1:         }
    1:       }
    1:     }
    1:   }
 2985: 
    1:   return NS_OK;
    1: }
    1: 
27829: ////////////////////////////////////////////////////////////////////////////////
27829: // nsXULProgressMeterAccessible
27829: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsXULProgressMeterAccessible::
43504:   nsXULProgressMeterAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsFormControlAccessible(aContent, aShell)
43504: {
43504: }
43504: 
27829: NS_IMPL_ISUPPORTS_INHERITED1(nsXULProgressMeterAccessible,
27829:                              nsFormControlAccessible,
27829:                              nsIAccessibleValue)
27829: 
27829: // nsAccessible
27829: 
52027: PRUint32
52027: nsXULProgressMeterAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_PROGRESSBAR;
    1: }
    1: 
27829: // nsIAccessibleValue
27829: 
27829: NS_IMETHODIMP
27829: nsXULProgressMeterAccessible::GetValue(nsAString& aValue)
    1: {
27829:   nsresult rv = nsFormControlAccessible::GetValue(aValue);
27829:   NS_ENSURE_SUCCESS(rv, rv);
27829: 
27829:   if (!aValue.IsEmpty())
27829:     return NS_OK;
27829: 
27829:   double maxValue = 0;
27829:   rv = GetMaximumValue(&maxValue);
27829:   NS_ENSURE_SUCCESS(rv, rv);
27829: 
27829:   if (maxValue != 1) {
27829:     double curValue = 0;
27829:     rv = GetCurrentValue(&curValue);
27829:     NS_ENSURE_SUCCESS(rv, rv);
27829: 
27829:     double percentValue = (curValue / maxValue) * 100;
27829:     nsAutoString value;
27829:     value.AppendFloat(percentValue); // AppendFloat isn't available on nsAString
27829:     value.AppendLiteral("%");
27829:     aValue = value;
    1:     return NS_OK;
    1:   }
27829: 
43504:   mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::value, aValue);
27829:   if (aValue.IsEmpty())
 1313:     aValue.AppendLiteral("0");  // Empty value for progress meter = 0%
27829: 
    1:   aValue.AppendLiteral("%");
    1:   return NS_OK;
    1: }
    1: 
27829: NS_IMETHODIMP
27829: nsXULProgressMeterAccessible::GetMaximumValue(double *aMaximumValue)
    1: {
27829:   nsresult rv = nsFormControlAccessible::GetMaximumValue(aMaximumValue);
27829:   if (rv != NS_OK_NO_ARIA_VALUE)
27829:     return rv;
27829: 
27829:   nsAutoString value;
43504:   if (mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::max, value)) {
27829:     PRInt32 result = NS_OK;
63877:     *aMaximumValue = value.ToDouble(&result);
27829:     return result;
27829:   }
27829: 
    1:   *aMaximumValue = 1; // 100% = 1;
    1:   return NS_OK;
    1: }
    1: 
27829: NS_IMETHODIMP
27829: nsXULProgressMeterAccessible::GetMinimumValue(double *aMinimumValue)
    1: {
27829:   nsresult rv = nsFormControlAccessible::GetMinimumValue(aMinimumValue);
27829:   if (rv != NS_OK_NO_ARIA_VALUE)
27829:     return rv;
27829: 
    1:   *aMinimumValue = 0;
    1:   return NS_OK;
    1: }
    1: 
27829: NS_IMETHODIMP
27829: nsXULProgressMeterAccessible::GetMinimumIncrement(double *aMinimumIncrement)
    1: {
27829:   nsresult rv = nsFormControlAccessible::GetMinimumIncrement(aMinimumIncrement);
27829:   if (rv != NS_OK_NO_ARIA_VALUE)
27829:     return rv;
27829: 
    1:   *aMinimumIncrement = 0;
    1:   return NS_OK;
    1: }
    1: 
27829: NS_IMETHODIMP
27829: nsXULProgressMeterAccessible::GetCurrentValue(double *aCurrentValue)
    1: {
27829:   nsresult rv = nsFormControlAccessible::GetCurrentValue(aCurrentValue);
27829:   if (rv != NS_OK_NO_ARIA_VALUE)
27829:     return rv;
27829: 
28024:   nsAutoString attrValue;
43504:   mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::value, attrValue);
 1313: 
28024:   // Return zero value if there is no attribute or its value is empty.
28024:   if (attrValue.IsEmpty())
28024:     return NS_OK;
27829: 
28024:   PRInt32 error = NS_OK;
63877:   double value = attrValue.ToDouble(&error);
28024:   if (NS_FAILED(error))
28024:     return NS_OK; // Zero value because of wrong markup.
28024: 
28024:   // If no max value then value is between 0 and 1 (refer to GetMaximumValue()
28024:   // method where max value is assumed to be equal to 1 in this case).
43504:   if (!mContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::max))
28024:     value /= 100;
28024: 
28024:   *aCurrentValue = value;
28024:   return NS_OK;
    1: }
    1: 
27829: NS_IMETHODIMP
27829: nsXULProgressMeterAccessible::SetCurrentValue(double aValue)
    1: {
    1:   return NS_ERROR_FAILURE; // Progress meters are readonly!
    1: }
    1: 
    1: 
36879: ////////////////////////////////////////////////////////////////////////////////
36879: // nsXULRadioButtonAccessible
36879: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsXULRadioButtonAccessible::
43504:   nsXULRadioButtonAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsRadioButtonAccessible(aContent, aShell)
    1: {
    1: }
    1: 
    1: /** We are Focusable and can be Checked and focused */
67790: PRUint64
67790: nsXULRadioButtonAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsFormControlAccessible::NativeState();
  262: 
67790:   state |= states::CHECKABLE;
 1157:   
    1:   PRBool selected = PR_FALSE;   // Radio buttons can be selected
    1: 
43504:   nsCOMPtr<nsIDOMXULSelectControlItemElement> radioButton =
43504:     do_QueryInterface(mContent);
    1:   if (radioButton) {
    1:     radioButton->GetSelected(&selected);
    1:     if (selected) {
67790:       state |= states::CHECKED;
    1:     }
    1:   }
    1: 
67790:   return state;
    1: }
    1: 
36879: void
36879: nsXULRadioButtonAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet,
36879:                                                        PRInt32 *aSetSize)
  144: {
43504:   nsAccUtils::GetPositionAndSizeForXULSelectControlItem(mContent, aPosInSet,
36879:                                                         aSetSize);
36879: }
  144: 
  144: 
36879: ////////////////////////////////////////////////////////////////////////////////
36879: // nsXULRadioGroupAccessible
36879: ////////////////////////////////////////////////////////////////////////////////
  144: 
    1: /**
    1:   * XUL Radio Group
    1:   *   The Radio Group proxies for the Radio Buttons themselves. The Group gets
    1:   *   focus whereas the Buttons do not. So we only have an accessible object for
    1:   *   this for the purpose of getting the proper RadioButton. Need this here to 
    1:   *   avoid circular reference problems when navigating the accessible tree and
    1:   *   for getting to the radiobuttons.
    1:   */
    1: 
43504: nsXULRadioGroupAccessible::
43504:   nsXULRadioGroupAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsXULSelectableAccessible(aContent, aShell)
    1: { 
    1: }
    1: 
52027: PRUint32
52027: nsXULRadioGroupAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_GROUPING;
    1: }
    1: 
67790: PRUint64
67790: nsXULRadioGroupAccessible::NativeState()
    1: {
21984:   // The radio group is not focusable. Sometimes the focus controller will
21984:   // report that it is focused. That means that the actual selected radio button
21984:   // should be considered focused.
67790:   return nsAccessible::NativeState() & ~(states::FOCUSABLE | states::FOCUSED);
    1: }
    1: 
43504:                       
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULStatusBarAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsXULStatusBarAccessible::
43504:   nsXULStatusBarAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsXULStatusBarAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_STATUSBAR;
    1: }
    1: 
43504: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULToolbarButtonAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsXULToolbarButtonAccessible::
43504:   nsXULToolbarButtonAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsXULButtonAccessible(aContent, aShell)
 3325: {
 3325: }
 3325: 
36879: void
36879: nsXULToolbarButtonAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet,
36879:                                                          PRInt32 *aSetSize)
 3325: {
 3325:   PRInt32 setSize = 0;
 3325:   PRInt32 posInSet = 0;
 3325: 
36989:   nsAccessible* parent(GetParent());
36989:   NS_ENSURE_TRUE(parent,);
36989: 
36989:   PRInt32 childCount = parent->GetChildCount();
36989:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
36989:     nsAccessible* child = parent->GetChildAt(childIdx);
36989:     if (IsSeparator(child)) { // end of a group of buttons
 3325:       if (posInSet)
 3325:         break; // we've found our group, so we're done
36989: 
 3325:       setSize = 0; // not our group, so start a new group
36989: 
 3325:     } else {
 3325:       setSize++; // another button in the group
36989: 
36989:       if (child == this)
 3325:         posInSet = setSize; // we've found our button
 3325:     }
 3325:   }
 3325: 
36879:   *aPosInSet = posInSet;
36879:   *aSetSize = setSize;
 3325: }
 3325: 
 3325: PRBool
36989: nsXULToolbarButtonAccessible::IsSeparator(nsAccessible *aAccessible)
 3325: {
 3325:   nsCOMPtr<nsIDOMNode> domNode;
36989:   aAccessible->GetDOMNode(getter_AddRefs(domNode));
 3325:   nsCOMPtr<nsIContent> contentDomNode(do_QueryInterface(domNode));
 3325: 
 3325:   if (!contentDomNode)
 3325:     return PR_FALSE;
 3325: 
 3325:   return (contentDomNode->Tag() == nsAccessibilityAtoms::toolbarseparator) ||
 3325:          (contentDomNode->Tag() == nsAccessibilityAtoms::toolbarspacer) ||
 3325:          (contentDomNode->Tag() == nsAccessibilityAtoms::toolbarspring);
 3325: }
 3325: 
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULToolbarAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsXULToolbarAccessible::
43504:   nsXULToolbarAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsXULToolbarAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_TOOLBAR;
    1: }
    1: 
42193: nsresult
42193: nsXULToolbarAccessible::GetNameInternal(nsAString& aName)
42193: {
42193:   nsAutoString name;
43504:   if (mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::toolbarname,
42193:                         name)) {
42193:     name.CompressWhitespace();
42193:     aName = name;
42193:   }
42193: 
42193:   return NS_OK;
42193: }
42193: 
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULToolbarAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsXULToolbarSeparatorAccessible::
43504:   nsXULToolbarSeparatorAccessible(nsIContent *aContent,
43504:                                   nsIWeakReference *aShell) :
43504:   nsLeafAccessible(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsXULToolbarSeparatorAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_SEPARATOR;
    1: }
    1: 
67790: PRUint64
67790: nsXULToolbarSeparatorAccessible::NativeState()
    1: {
68037:   return IsDefunct() ? states::DEFUNCT : 0;
    1: }
    1: 
37797: ////////////////////////////////////////////////////////////////////////////////
37797: // nsXULTextFieldAccessible
37797: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsXULTextFieldAccessible::
43504:  nsXULTextFieldAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:  nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
 7766: NS_IMPL_ISUPPORTS_INHERITED3(nsXULTextFieldAccessible, nsAccessible, nsHyperTextAccessible, nsIAccessibleText, nsIAccessibleEditableText)
 7766: 
37797: ////////////////////////////////////////////////////////////////////////////////
37797: // nsXULTextFieldAccessible: nsIAccessible
37797: 
    1: NS_IMETHODIMP nsXULTextFieldAccessible::GetValue(nsAString& aValue)
    1: {
67790:   PRUint64 state = NativeState();
21256: 
67790:   if (state & states::PROTECTED)    // Don't return password text!
    1:     return NS_ERROR_FAILURE;
    1: 
43504:   nsCOMPtr<nsIDOMXULTextBoxElement> textBox(do_QueryInterface(mContent));
    1:   if (textBox) {
    1:     return textBox->GetValue(aValue);
    1:   }
43504:   nsCOMPtr<nsIDOMXULMenuListElement> menuList(do_QueryInterface(mContent));
    1:   if (menuList) {
    1:     return menuList->GetLabel(aValue);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
67790: void
67790: nsXULTextFieldAccessible::ApplyARIAState(PRUint64* aState)
29565: {
67790:   nsHyperTextAccessibleWrap::ApplyARIAState(aState);
29565: 
67790:   nsStateMapEntry::MapToStates(mContent, aState, eARIAAutoComplete);
29565: 
29565: }
29565: 
67790: PRUint64
67790: nsXULTextFieldAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsHyperTextAccessibleWrap::NativeState();
    1: 
43504:   nsCOMPtr<nsIContent> inputField(GetInputField());
67790:   NS_ENSURE_TRUE(inputField, state);
  262: 
67790:   // Create a temporary accessible from the HTML text field to get
67790:   // the accessible state from. Doesn't add to cache into document cache.
67789:   nsRefPtr<nsHTMLTextFieldAccessible> tempAccessible =
  732:     new nsHTMLTextFieldAccessible(inputField, mWeakShell);
  732:   if (!tempAccessible)
67790:     return state;
67789: 
67790:   state |= tempAccessible->NativeState();
  262: 
43504:   if (gLastFocusedNode == mContent)
67790:     state |= states::FOCUSED;
    1: 
43504:   nsCOMPtr<nsIDOMXULMenuListElement> menuList(do_QueryInterface(mContent));
    1:   if (menuList) {
    1:     // <xul:menulist droppable="false">
43504:     if (!mContent->AttrValueIs(kNameSpaceID_None,
43504:                                nsAccessibilityAtoms::editable,
    1:                                nsAccessibilityAtoms::_true, eIgnoreCase)) {
67790:       state |= states::READONLY;
    1:     }
    1:   }
  262: 
67790:   return state;
    1: }
    1: 
52027: PRUint32
52027: nsXULTextFieldAccessible::NativeRole()
    1: {
43504:   if (mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
43504:                             nsAccessibilityAtoms::password, eIgnoreCase))
52027:     return nsIAccessibleRole::ROLE_PASSWORD_TEXT;
52027:   return nsIAccessibleRole::ROLE_ENTRY;
    1: }
    1: 
    1: 
    1: /**
    1:   * Only one actions available
    1:   */
    1: NS_IMETHODIMP nsXULTextFieldAccessible::GetNumActions(PRUint8 *_retval)
    1: {
    1:   *_retval = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * Return the name of our only action
    1:   */
    1: NS_IMETHODIMP nsXULTextFieldAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     aName.AssignLiteral("activate"); 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: /**
20072:   * Tell the button to do its action
    1:   */
    1: NS_IMETHODIMP nsXULTextFieldAccessible::DoAction(PRUint8 index)
    1: {
    1:   if (index == 0) {
43504:     nsCOMPtr<nsIDOMXULElement> element(do_QueryInterface(mContent));
    1:     if (element)
    1:     {
    1:       element->Focus();
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
29320: PRBool
29320: nsXULTextFieldAccessible::GetAllowsAnonChildAccessibles()
    1: {
29320:   return PR_FALSE;
    1: }
    1: 
 4625: NS_IMETHODIMP nsXULTextFieldAccessible::GetAssociatedEditor(nsIEditor **aEditor)
    1: {
 4625:   *aEditor = nsnull;
43504: 
43504:   nsCOMPtr<nsIContent> inputField = GetInputField();
    1:   nsCOMPtr<nsIDOMNSEditableElement> editableElt(do_QueryInterface(inputField));
 4625:   NS_ENSURE_TRUE(editableElt, NS_ERROR_FAILURE);
 4625:   return editableElt->GetEditor(aEditor);
    1: }
37797: 
37797: ////////////////////////////////////////////////////////////////////////////////
37797: // nsXULTextFieldAccessible: nsAccessible protected
37797: 
37797: void
37797: nsXULTextFieldAccessible::CacheChildren()
37797: {
37797:   // Create child accessibles for native anonymous content of underlying HTML
37797:   // input element.
43504:   nsCOMPtr<nsIContent> inputContent(GetInputField());
37797:   if (!inputContent)
37797:     return;
37797: 
38358:   nsAccTreeWalker walker(mWeakShell, inputContent, PR_FALSE);
37797: 
64506:   nsAccessible* child = nsnull;
64506:   while ((child = walker.NextChild()) && AppendChild(child));
37797: }
43504: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsXULTextFieldAccessible protected
43504: 
43504: already_AddRefed<nsIContent>
43504: nsXULTextFieldAccessible::GetInputField() const
43504: {
43504:   nsCOMPtr<nsIDOMNode> inputFieldDOMNode;
43504:   nsCOMPtr<nsIDOMXULTextBoxElement> textBox = do_QueryInterface(mContent);
43504:   if (textBox) {
43504:     textBox->GetInputField(getter_AddRefs(inputFieldDOMNode));
43504: 
43504:   } else {
43504:     // <xul:menulist droppable="false">
43504:     nsCOMPtr<nsIDOMXULMenuListElement> menuList = do_QueryInterface(mContent);
43504:     if (menuList)
43504:       menuList->GetInputField(getter_AddRefs(inputFieldDOMNode));
43504:   }
43504: 
43504:   NS_ASSERTION(inputFieldDOMNode, "No input field for nsXULTextFieldAccessible");
43504: 
43504:   nsIContent* inputField = nsnull;
43504:   if (inputFieldDOMNode)
43504:     CallQueryInterface(inputFieldDOMNode, &inputField);
43504: 
43504:   return inputField;
43504: }
