    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
34352:  * vim: set ts=4 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsinterp_h___
    1: #define jsinterp_h___
    1: /*
    1:  * JS interpreter interface.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
16072: #include "jsfun.h"
11377: #include "jsopcode.h"
16072: #include "jsscript.h"
48470: #include "jsvalue.h"
    1: 
53840: struct JSFrameRegs
53840: {
55479:     STATIC_SKIP_INFERENCE
52557:     js::Value       *sp;                  /* stack pointer */
51444:     jsbytecode      *pc;                  /* program counter */
51446:     JSStackFrame    *fp;                  /* active frame */
42714: };
37777: 
53840: /* Flags to toggle js::Interpret() execution. */
56201: enum JSInterpMode
53840: {
56201:     JSINTERP_NORMAL            =     0, /* Interpreter is running normally. */
56201:     JSINTERP_RECORD            =     1, /* interpreter has been started to record/run traces */
56551:     JSINTERP_SAFEPOINT         =     2, /* interpreter should leave on a method JIT safe point */
56551:     JSINTERP_PROFILE           =     3  /* interpreter should profile a loop */
53626: };
53626: 
53840: /* Flags used in JSStackFrame::flags_ */
53840: enum JSFrameFlags
53840: {
53840:     /* Primary frame type */
53840:     JSFRAME_GLOBAL             =     0x1, /* frame pushed for a global script */
53840:     JSFRAME_FUNCTION           =     0x2, /* frame pushed for a scripted call */
53840:     JSFRAME_DUMMY              =     0x4, /* frame pushed for bookkeeping */
53840: 
53840:     /* Frame subtypes */
53840:     JSFRAME_EVAL               =     0x8, /* frame pushed by js::Execute */
53840:     JSFRAME_DEBUGGER           =    0x10, /* frame pushed by JS_EvaluateInStackFrame */
53840:     JSFRAME_GENERATOR          =    0x20, /* frame is associated with a generator */
53840:     JSFRAME_FLOATING_GENERATOR =    0x40, /* frame is is in generator obj, not on stack */
53840:     JSFRAME_CONSTRUCTING       =    0x80, /* frame is for a constructor invocation */
53840: 
53840:     /* Temporary frame states */
53840:     JSFRAME_ASSIGNING          =   0x100, /* not-JOF_ASSIGNING op is assigning */
53840:     JSFRAME_YIELDING           =   0x200, /* js::Interpret dispatched JSOP_YIELD */
56201:     JSFRAME_FINISHED_IN_INTERPRETER = 0x400, /* set if frame finished in Interpret() */
53840: 
53840:     /* Concerning function arguments */
53840:     JSFRAME_OVERRIDE_ARGS      =  0x1000, /* overridden arguments local variable */
53840:     JSFRAME_OVERFLOW_ARGS      =  0x2000, /* numActualArgs > numFormalArgs */
53840:     JSFRAME_UNDERFLOW_ARGS     =  0x4000, /* numActualArgs < numFormalArgs */
53840: 
53840:     /* Lazy frame initialization */
53840:     JSFRAME_HAS_IMACRO_PC      =   0x8000, /* frame has imacpc value available */
54832:     JSFRAME_HAS_CALL_OBJ       =  0x10000, /* frame has a callobj reachable from scopeChain_ */
53840:     JSFRAME_HAS_ARGS_OBJ       =  0x20000, /* frame has an argsobj in JSStackFrame::args */
53840:     JSFRAME_HAS_HOOK_DATA      =  0x40000, /* frame has hookData_ set */
54832:     JSFRAME_HAS_ANNOTATION     =  0x80000, /* frame has annotation_ set */
55483:     JSFRAME_HAS_RVAL           = 0x100000, /* frame has rval_ set */
55483:     JSFRAME_HAS_SCOPECHAIN     = 0x200000, /* frame has scopeChain_ set */
55483:     JSFRAME_HAS_PREVPC         = 0x400000  /* frame has prevpc_ set */
53840: };
53590: 
    1: /*
53840:  * A stack frame is a part of a stack segment (see js::StackSegment) which is
53840:  * on the per-thread VM stack (see js::StackSpace).
    1:  */
42714: struct JSStackFrame
42714: {
50510:   private:
55483:     mutable uint32      flags_;         /* bits described by JSFrameFlags */
53840:     union {                             /* describes what code is executing in a */
53840:         JSScript        *script;        /*   global frame */
53840:         JSFunction      *fun;           /*   function frame, pre GetScopeChain */
53840:     } exec;
53840:     union {                             /* describes the arguments of a function */
53840:         uintN           nactual;        /*   pre GetArgumentsObject */
53840:         JSObject        *obj;           /*   post GetArgumentsObject */
53840:         JSScript        *script;        /* eval has no args, but needs a script */
53840:     } args;
55483:     mutable JSObject    *scopeChain_;   /* current scope chain */
53840:     JSStackFrame        *prev_;         /* previous cx->regs->fp */
54832:     void                *ncode_;        /* return address for method JIT */
53840: 
53840:     /* Lazily initialized */
54832:     js::Value           rval_;          /* return value of the frame */
54832:     jsbytecode          *prevpc_;       /* pc of previous frame*/
53840:     jsbytecode          *imacropc_;     /* pc of macro caller */
53840:     void                *hookData_;     /* closure returned by call hook */
53840:     void                *annotation_;   /* perhaps remove with bug 546848 */
53840: 
53840:     friend class js::StackSpace;
53840:     friend class js::FrameRegsIter;
53840:     friend struct JSContext;
53840: 
55517:     inline void initPrev(JSContext *cx);
55517: 
53840:   public:
53840:     /*
53840:      * Stack frame sort (see JSStackFrame comment above)
53840:      *
53840:      * A stack frame may have one of three types, which determines which
53840:      * members of the frame may be accessed and other invariants:
53840:      *
53840:      *  global frame:   execution of global code or an eval in global code
53840:      *  function frame: execution of function code or an eval in a function
53840:      *  dummy frame:    bookkeeping frame (read: hack)
53840:      *
53840:      * As noted, global and function frames may optionally be 'eval frames', which
53840:      * further restricts the stack frame members which may be used. Namely, the
53840:      * argument-related members of function eval frames are not valid, since an eval
53840:      * shares its containing function's arguments rather than having its own.
53840:      */
53840: 
53840:     bool isFunctionFrame() const {
53840:         return !!(flags_ & JSFRAME_FUNCTION);
53840:     }
53840: 
53840:     bool isGlobalFrame() const {
53840:         return !!(flags_ & JSFRAME_GLOBAL);
53840:     }
53840: 
53840:     bool isDummyFrame() const {
53840:         return !!(flags_ & JSFRAME_DUMMY);
53840:     }
53840: 
53840:     bool isScriptFrame() const {
53840:         return !!(flags_ & (JSFRAME_FUNCTION | JSFRAME_GLOBAL));
53840:     }
53840: 
53840:     bool isEvalFrame() const {
53840:         JS_ASSERT_IF(flags_ & JSFRAME_EVAL, isScriptFrame());
53840:         return flags_ & JSFRAME_EVAL;
53840:     }
53004: 
56201:     bool isExecuteFrame() const {
56201:         return !!(flags_ & (JSFRAME_GLOBAL | JSFRAME_EVAL));
56201:     }
56201: 
53004:     /*
53840:      * Frame initialization
53004:      *
53840:      * After acquiring a pointer to an uninitialized stack frame on the VM
53840:      * stack from js::StackSpace, these members are used to initialize the
53840:      * stack frame before officially pushing the frame into the context.
53840:      * Collecting frame initialization into a set of inline helpers allows
53840:      * simpler reasoning and makes call-optimization easier.
53840:      */
53840: 
53840:     /* Used for Invoke, Interpret, trace-jit LeaveTree, and method-jit stubs. */
53840:     inline void initCallFrame(JSContext *cx, JSObject &callee, JSFunction *fun,
53840:                               uint32 nactual, uint32 flags);
53840: 
55565:     /* Used for SessionInvoke. */
55565:     inline void resetInvokeCallFrame();
55565: 
53840:     /* Called by method-jit stubs and serve as a specification for jit-code. */
55483:     inline void initCallFrameCallerHalf(JSContext *cx, uint32 nactual, uint32 flags);
53840:     inline void initCallFrameEarlyPrologue(JSFunction *fun, void *ncode);
53840:     inline void initCallFrameLatePrologue();
53840: 
53840:     /* Used for eval. */
55517:     inline void initEvalFrame(JSContext *cx, JSScript *script, JSStackFrame *prev,
55517:                               uint32 flags);
53840:     inline void initGlobalFrame(JSScript *script, JSObject &chain, uint32 flags);
53840: 
53840:     /* Used when activating generators. */
53840:     inline void stealFrameAndSlots(js::Value *vp, JSStackFrame *otherfp,
53840:                                    js::Value *othervp, js::Value *othersp);
53840: 
53840:     /* Perhaps one fine day we will remove dummy frames. */
53840:     inline void initDummyFrame(JSContext *cx, JSObject &chain);
53840: 
53840:     /*
53840:      * Previous frame
53004:      *
53840:      * A frame's 'prev' frame is either null or the previous frame pointed to
53840:      * by cx->regs->fp when this frame was pushed. Often, given two prev-linked
53840:      * frames, the next-frame is a function or eval that was called by the
53840:      * prev-frame, but not always: the prev-frame may have called a native that
53840:      * reentered the VM through JS_CallFunctionValue on the same context
53840:      * (without calling JS_SaveFrameChain) which pushed the next-frame. Thus,
53840:      * 'prev' has little semantic meaning and basically just tells the VM what
53840:      * to set cx->regs->fp to when this frame is popped.
53004:      */
50510: 
53840:     JSStackFrame *prev() const {
53840:         return prev_;
53840:     }
26238: 
55517:     inline void resetGeneratorPrev(JSContext *cx);
51054: 
53840:     /*
53840:      * Frame slots
53840:      *
53840:      * A frame's 'slots' are the fixed slots associated with the frame (like
53840:      * local variables) followed by an expression stack holding temporary
53840:      * values. A frame's 'base' is the base of the expression stack.
53840:      */
42714: 
48470:     js::Value *slots() const {
48470:         return (js::Value *)(this + 1);
42714:     }
42714: 
48470:     js::Value *base() const {
53840:         return slots() + script()->nfixed;
48470:     }
48470: 
53840:     /*
53840:      * Script
53840:      *
53840:      * All function and global frames have an associated JSScript which holds
53840:      * the bytecode being executed for the frame.
53840:      */
50510: 
54832:     /*
54832:      * Get the frame's current bytecode, assuming |this| is in |cx|.
54832:      * next is frame whose prev == this, NULL if not known or if this == cx->fp().
54832:      */
54832:     jsbytecode *pc(JSContext *cx, JSStackFrame *next = NULL);
54832: 
54832:     jsbytecode *prevpc() {
54832:         JS_ASSERT((prev_ != NULL) && (flags_ & JSFRAME_HAS_PREVPC));
54832:         return prevpc_;
54832:     }
53840: 
53840:     JSScript *script() const {
53840:         JS_ASSERT(isScriptFrame());
53840:         return isFunctionFrame()
53840:                ? isEvalFrame() ? args.script : fun()->script()
53840:                : exec.script;
50510:     }
50510: 
53840:     JSScript *functionScript() const {
53840:         JS_ASSERT(isFunctionFrame());
53840:         return isEvalFrame() ? args.script : fun()->script();
50510:     }
50510: 
53840:     JSScript *globalScript() const {
53840:         JS_ASSERT(isGlobalFrame());
53840:         return exec.script;
50510:     }
50510: 
53840:     JSScript *maybeScript() const {
53840:         return isScriptFrame() ? script() : NULL;
50510:     }
50510: 
53840:     size_t numFixed() const {
53840:         return script()->nfixed;
50510:     }
50510: 
53840:     size_t numSlots() const {
53840:         return script()->nslots;
53840:     }
53840: 
53840:     size_t numGlobalVars() const {
53840:         JS_ASSERT(isGlobalFrame());
53840:         return exec.script->nfixed;
53840:     }
53840: 
53840:     /*
53840:      * Function
53840:      *
53840:      * All function frames have an associated interpreted JSFunction.
53840:      */
53840: 
53840:     JSFunction* fun() const {
53840:         JS_ASSERT(isFunctionFrame());
53840:         return exec.fun;
53840:     }
53840: 
53840:     JSFunction* maybeFun() const {
53840:         return isFunctionFrame() ? fun() : NULL;
53840:     }
53840: 
53840:     /*
53840:      * Arguments
53840:      *
53840:      * Only non-eval function frames have arguments. A frame follows its
53840:      * arguments contiguously in memory. The arguments pushed by the caller are
53840:      * the 'actual' arguments. The declared arguments of the callee are the
53840:      * 'formal' arguments. When the caller passes less or equal actual
53840:      * arguments, the actual and formal arguments are the same array (but with
53840:      * different extents). When the caller passes too many arguments, the
53840:      * formal subset of the actual arguments is copied onto the top of the
53840:      * stack. This allows the engine to maintain a jit-time constant offset of
53840:      * arguments from the frame pointer. Since the formal subset of the actual
53840:      * arguments is potentially on the stack twice, it is important for all
53840:      * reads/writes to refer to the same canonical memory location.
53840:      *
53840:      * An arguments object (the object returned by the 'arguments' keyword) is
53840:      * lazily created, so a given function frame may or may not have one.
53840:      */
53840: 
55516:     /* True if this frame has arguments. Contrast with hasArgsObj. */
55516:     bool hasArgs() const {
55516:         return isFunctionFrame() && !isEvalFrame();
55516:     }
55516: 
53840:     uintN numFormalArgs() const {
55516:         JS_ASSERT(hasArgs());
53840:         return fun()->nargs;
53840:     }
53840: 
53840:     js::Value &formalArg(uintN i) const {
53840:         JS_ASSERT(i < numFormalArgs());
53840:         return formalArgs()[i];
53840:     }
53840: 
53840:     js::Value *formalArgs() const {
55516:         JS_ASSERT(hasArgs());
53840:         return (js::Value *)this - numFormalArgs();
53840:     }
53840: 
53840:     js::Value *formalArgsEnd() const {
55516:         JS_ASSERT(hasArgs());
53840:         return (js::Value *)this;
53840:     }
53840: 
53840:     js::Value *maybeFormalArgs() const {
53840:         return (flags_ & (JSFRAME_FUNCTION | JSFRAME_EVAL)) == JSFRAME_FUNCTION
53840:                ? formalArgs()
53840:                : NULL;
53840:     }
53840: 
53840:     inline uintN numActualArgs() const;
53840:     inline js::Value *actualArgs() const;
53840:     inline js::Value *actualArgsEnd() const;
53840: 
53840:     inline js::Value &canonicalActualArg(uintN i) const;
53840:     template <class Op> inline void forEachCanonicalActualArg(Op op);
53840:     template <class Op> inline void forEachFormalArg(Op op);
50510: 
55565:     inline void clearMissingArgs();
55565: 
50510:     bool hasArgsObj() const {
53840:         return !!(flags_ & JSFRAME_HAS_ARGS_OBJ);
50510:     }
50510: 
53840:     JSObject &argsObj() const {
50510:         JS_ASSERT(hasArgsObj());
51444:         JS_ASSERT(!isEvalFrame());
53840:         return *args.obj;
50510:     }
50510: 
50510:     JSObject *maybeArgsObj() const {
53840:         return hasArgsObj() ? &argsObj() : NULL;
50510:     }
50510: 
54832:     inline void setArgsObj(JSObject &obj);
54832:     inline void clearArgsObj();
53840: 
53840:     /*
53840:      * This value
53840:      *
53840:      * Every frame has a this value although, until 'this' is computed, the
53840:      * value may not be the semantically-correct 'this' value.
53840:      *
53840:      * The 'this' value is stored before the formal arguments for function
53840:      * frames and directly before the frame for global frames. The *Args
53840:      * members assert !isEvalFrame(), so we implement specialized inline
53840:      * methods for accessing 'this'. When the caller has static knowledge that
53840:      * a frame is a function or global frame, 'functionThis' and 'globalThis',
53840:      * respectively, allow more efficient access.
53840:      */
53840: 
53840:     js::Value &functionThis() const {
53840:         JS_ASSERT(isFunctionFrame());
53840:         if (isEvalFrame())
53840:             return ((js::Value *)this)[-1];
53840:         return formalArgs()[-1];
50510:     }
50510: 
53840:     JSObject &constructorThis() const {
55516:         JS_ASSERT(hasArgs());
53840:         return formalArgs()[-1].toObject();
50510:     }
50510: 
53840:     js::Value &globalThis() const {
53840:         JS_ASSERT(isGlobalFrame());
53840:         return ((js::Value *)this)[-1];
53840:     }
53840: 
53840:     js::Value &thisValue() const {
53840:         if (flags_ & (JSFRAME_EVAL | JSFRAME_GLOBAL))
53840:             return ((js::Value *)this)[-1];
53840:         return formalArgs()[-1];
53840:     }
53840: 
55713:     inline bool computeThis(JSContext *cx);
53840: 
53840:     /*
53840:      * Callee
53840:      *
53840:      * Only function frames have a callee. An eval frame in a function has the
53840:      * same caller as its containing function frame.
53840:      */
53840: 
53840:     js::Value &calleeValue() const {
53840:         JS_ASSERT(isFunctionFrame());
53840:         if (isEvalFrame())
53840:             return ((js::Value *)this)[-2];
53840:         return formalArgs()[-2];
53840:     }
53840: 
53840:     JSObject &callee() const {
53840:         JS_ASSERT(isFunctionFrame());
53840:         return calleeValue().toObject();
53840:     }
53840: 
53840:     JSObject *maybeCallee() const {
53840:         return isFunctionFrame() ? &callee() : NULL;
50510:     }
50510: 
51052:     /*
53840:      * getValidCalleeObject is a fallible getter to compute the correct callee
53840:      * function object, which may require deferred cloning due to the JSObject
53840:      * methodReadBarrier. For a non-function frame, return true with *vp set
53840:      * from calleeValue, which may not be an object (it could be undefined).
53840:      */
53840:     bool getValidCalleeObject(JSContext *cx, js::Value *vp);
53840: 
53840:     /*
53840:      * Scope chain
51052:      *
53840:      * Every frame has a scopeChain which, when traversed via the 'parent' link
53840:      * to the root, indicates the current global object. A 'call object' is a
53840:      * node on a scope chain representing a function's activation record. A
53840:      * call object is used for dynamically-scoped name lookup and lexically-
53840:      * scoped upvar access. The call object holds the values of locals and
53840:      * arguments when a function returns (and its stack frame is popped). For
53840:      * performance reasons, call objects are created lazily for 'lightweight'
53840:      * functions, i.e., functions which are not statically known to require a
53840:      * call object. Thus, a given function frame may or may not have a call
53840:      * object. When a function does have a call object, it is found by walking
53840:      * up the scope chain until the first call object. Thus, it is important,
53840:      * when setting the scope chain, to indicate whether the new scope chain
53840:      * contains a new call object and thus changes the 'hasCallObj' state.
51052:      */
51052: 
53840:     JSObject &scopeChain() const {
55483:         JS_ASSERT_IF(!(flags_ & JSFRAME_HAS_SCOPECHAIN), isFunctionFrame());
55483:         if (!(flags_ & JSFRAME_HAS_SCOPECHAIN)) {
55483:             scopeChain_ = callee().getParent();
55483:             flags_ |= JSFRAME_HAS_SCOPECHAIN;
55483:         }
53840:         return *scopeChain_;
51052:     }
51052: 
53840:     bool hasCallObj() const {
53840:         return !!(flags_ & JSFRAME_HAS_CALL_OBJ);
51052:     }
51052: 
53840:     inline JSObject &callObj() const;
53840:     inline JSObject *maybeCallObj() const;
53840:     inline void setScopeChainNoCallObj(JSObject &obj);
53840:     inline void setScopeChainAndCallObj(JSObject &obj);
54832:     inline void clearCallObj();
53840: 
53840:     /*
53840:      * Imacropc
53840:      *
53840:      * A frame's IMacro pc is the bytecode address when an imacro started
53840:      * executing (guaranteed non-null). An imacro does not push a frame, so
53840:      * when the imacro finishes, the frame's IMacro pc becomes the current pc.
53840:      */
53840: 
53840:     bool hasImacropc() const {
53840:         return flags_ & JSFRAME_HAS_IMACRO_PC;
53590:     }
53590: 
53840:     jsbytecode *imacropc() const {
53840:         JS_ASSERT(hasImacropc());
53840:         return imacropc_;
51056:     }
51056: 
53840:     jsbytecode *maybeImacropc() const {
53840:         return hasImacropc() ? imacropc() : NULL;
51056:     }
51056: 
53840:     void clearImacropc() {
53840:         flags_ &= ~JSFRAME_HAS_IMACRO_PC;
51054:     }
51054: 
53840:     void setImacropc(jsbytecode *pc) {
53840:         JS_ASSERT(pc);
53840:         JS_ASSERT(!(flags_ & JSFRAME_HAS_IMACRO_PC));
53840:         imacropc_ = pc;
53840:         flags_ |= JSFRAME_HAS_IMACRO_PC;
51054:     }
51054: 
53840:     /* Annotation (will be removed after bug 546848) */
53840: 
53840:     void* annotation() const {
53840:         return (flags_ & JSFRAME_HAS_ANNOTATION) ? annotation_ : NULL;
51054:     }
51054: 
51054:     void setAnnotation(void *annot) {
53840:         flags_ |= JSFRAME_HAS_ANNOTATION;
53840:         annotation_ = annot;
51054:     }
51054: 
53840:     /* Debugger hook data */
53840: 
53840:     bool hasHookData() const {
53840:         return !!(flags_ & JSFRAME_HAS_HOOK_DATA);
53590:     }
53590: 
53840:     void* hookData() const {
51054:         JS_ASSERT(hasHookData());
53840:         return hookData_;
51054:     }
51054: 
51054:     void* maybeHookData() const {
53840:         return hasHookData() ? hookData_ : NULL;
51054:     }
51054: 
53840:     void setHookData(void *v) {
53840:         hookData_ = v;
53840:         flags_ |= JSFRAME_HAS_HOOK_DATA;
51054:     }
51054: 
53840:     /* Return value */
53631: 
53840:     const js::Value &returnValue() {
55483:         if (!(flags_ & JSFRAME_HAS_RVAL))
55483:             rval_.setUndefined();
53840:         return rval_;
51056:     }
51056: 
55483:     void markReturnValue() {
55483:         flags_ |= JSFRAME_HAS_RVAL;
55483:     }
55483: 
51056:     void setReturnValue(const js::Value &v) {
53840:         rval_ = v;
55483:         markReturnValue();
51056:     }
51056: 
51056:     void clearReturnValue() {
53840:         rval_.setUndefined();
55483:         markReturnValue();
54832:     }
54832: 
53840:     /* Native-code return address */
53840: 
53840:     void *nativeReturnAddress() const {
53840:         return ncode_;
51055:     }
51055: 
54832:     void setNativeReturnAddress(void *addr) {
54832:         ncode_ = addr;
54832:     }
54832: 
53840:     void **addressOfNativeReturnAddress() {
53840:         return &ncode_;
48676:     }
48676: 
48676:     /*
53840:      * Generator-specific members
53840:      *
53840:      * A non-eval function frame may optionally be the activation of a
53840:      * generator. For the most part, generator frames act like ordinary frames.
53840:      * For exceptions, see js_FloatingFrameIfGenerator.
48676:      */
48676: 
53840:     bool isGeneratorFrame() const {
53840:         return !!(flags_ & JSFRAME_GENERATOR);
48676:     }
48676: 
53840:     bool isFloatingGenerator() const {
53840:         JS_ASSERT_IF(flags_ & JSFRAME_FLOATING_GENERATOR, isGeneratorFrame());
53840:         return !!(flags_ & JSFRAME_FLOATING_GENERATOR);
53840:     }
53840: 
53840:     void initFloatingGenerator() {
53840:         JS_ASSERT(!(flags_ & JSFRAME_GENERATOR));
53840:         flags_ |= (JSFRAME_GENERATOR | JSFRAME_FLOATING_GENERATOR);
53840:     }
53840: 
53840:     void unsetFloatingGenerator() {
53840:         flags_ &= ~JSFRAME_FLOATING_GENERATOR;
53840:     }
53840: 
53840:     void setFloatingGenerator() {
53840:         flags_ |= JSFRAME_FLOATING_GENERATOR;
31939:     }
37777: 
37777:     /*
53840:      * Other flags
37777:      */
37777: 
53840:     bool isConstructing() const {
53840:         return !!(flags_ & JSFRAME_CONSTRUCTING);
42714:     }
47498: 
53840:     uint32 isConstructingFlag() const {
53840:         JS_ASSERT(isFunctionFrame());
53840:         JS_ASSERT((flags_ & ~(JSFRAME_CONSTRUCTING | JSFRAME_FUNCTION)) == 0);
53840:         return flags_;
53840:     }
51056: 
53840:     bool isDebuggerFrame() const {
53840:         return !!(flags_ & JSFRAME_DEBUGGER);
53840:     }
53439: 
53840:     bool isEvalOrDebuggerFrame() const {
53840:         return !!(flags_ & (JSFRAME_EVAL | JSFRAME_DEBUGGER));
53840:     }
53840: 
53840:     bool hasOverriddenArgs() const {
53840:         return !!(flags_ & JSFRAME_OVERRIDE_ARGS);
53840:     }
53840: 
53840:     bool hasOverflowArgs() const {
53840:         return !!(flags_ & JSFRAME_OVERFLOW_ARGS);
53840:     }
53840: 
53840:     void setOverriddenArgs() {
53840:         flags_ |= JSFRAME_OVERRIDE_ARGS;
53840:     }
53840: 
53840:     bool isAssigning() const {
53840:         return !!(flags_ & JSFRAME_ASSIGNING);
53840:     }
53840: 
53840:     void setAssigning() {
53840:         flags_ |= JSFRAME_ASSIGNING;
53840:     }
53840: 
53840:     void clearAssigning() {
53840:         flags_ &= ~JSFRAME_ASSIGNING;
53840:     }
53840: 
53840:     bool isYielding() {
53840:         return !!(flags_ & JSFRAME_YIELDING);
53840:     }
53840: 
53840:     void setYielding() {
53840:         flags_ |= JSFRAME_YIELDING;
53840:     }
53840: 
53840:     void clearYielding() {
53840:         flags_ &= ~JSFRAME_YIELDING;
53840:     }
53840: 
56201:     void setFinishedInInterpreter() {
56201:         flags_ |= JSFRAME_FINISHED_IN_INTERPRETER;
53840:     }
53840: 
56201:     bool finishedInInterpreter() const {
56201:         return !!(flags_ & JSFRAME_FINISHED_IN_INTERPRETER);
53840:     }
53840: 
53840:     /*
53840:      * Variables object accessors
53840:      *
53840:      * A stack frame's 'varobj' refers to the 'variables object' (ES3 term)
53840:      * associated with the Execution Context's VariableEnvironment (ES5 10.3).
53840:      *
53840:      * To compute the frame's varobj, the caller must supply the segment
53840:      * containing the frame (see js::StackSegment comment). As an abbreviation,
53840:      * the caller may pass the context if the frame is contained in that
53840:      * context's active segment.
53840:      */
53840: 
53840:     inline JSObject &varobj(js::StackSegment *seg) const;
53840:     inline JSObject &varobj(JSContext *cx) const;
53840: 
53840:     /* Access to privates from the jits. */
53840: 
53840:     static size_t offsetOfFlags() {
53840:         return offsetof(JSStackFrame, flags_);
53840:     }
53840: 
53840:     static size_t offsetOfExec() {
53840:         return offsetof(JSStackFrame, exec);
53840:     }
53840: 
53840:     void *addressOfArgs() {
53840:         return &args;
53840:     }
53840: 
53840:     static size_t offsetOfScopeChain() {
53840:         return offsetof(JSStackFrame, scopeChain_);
53840:     }
53840: 
53840:     JSObject **addressOfScopeChain() {
55483:         JS_ASSERT(flags_ & JSFRAME_HAS_SCOPECHAIN);
53840:         return &scopeChain_;
53840:     }
53840: 
53840:     static size_t offsetOfPrev() {
53840:         return offsetof(JSStackFrame, prev_);
53840:     }
53840: 
53840:     static size_t offsetOfReturnValue() {
53840:         return offsetof(JSStackFrame, rval_);
53840:     }
53840: 
53840:     static ptrdiff_t offsetOfncode() {
53840:         return offsetof(JSStackFrame, ncode_);
53840:     }
53840: 
53840:     static ptrdiff_t offsetOfCallee(JSFunction *fun) {
53840:         JS_ASSERT(fun != NULL);
53840:         return -(fun->nargs + 2) * sizeof(js::Value);
53840:     }
53840: 
53840:     static ptrdiff_t offsetOfThis(JSFunction *fun) {
53840:         return fun == NULL
53855:                ? -1 * ptrdiff_t(sizeof(js::Value))
53855:                : -(fun->nargs + 1) * ptrdiff_t(sizeof(js::Value));
53840:     }
53840: 
53840:     static ptrdiff_t offsetOfFormalArg(JSFunction *fun, uintN i) {
53840:         JS_ASSERT(i < fun->nargs);
53840:         return (-(int)fun->nargs + i) * sizeof(js::Value);
53840:     }
53840: 
53840:     static size_t offsetOfFixed(uintN i) {
53840:         return sizeof(JSStackFrame) + i * sizeof(js::Value);
53840:     }
53840: 
53840:     /* Workaround for static asserts on private members. */
53840: 
53840:     void staticAsserts() {
53840:         JS_STATIC_ASSERT(offsetof(JSStackFrame, rval_) % sizeof(js::Value) == 0);
53840:         JS_STATIC_ASSERT(sizeof(JSStackFrame) % sizeof(js::Value) == 0);
53840:     }
53840: 
53840:     void methodjitStaticAsserts();
53840: 
53840: #ifdef DEBUG
53840:     /* Poison scopeChain value set before a frame is flushed. */
53840:     static JSObject *const sInvalidScopeChain;
53840: #endif
    1: };
    1: 
42714: namespace js {
42714: 
48470: static const size_t VALUES_PER_STACK_FRAME = sizeof(JSStackFrame) / sizeof(Value);
42714: 
51056: } /* namespace js */
42714: 
16072: 
54855: extern JSObject *
54855: js_GetBlockChain(JSContext *cx, JSStackFrame *fp);
54855: 
54855: extern JSObject *
54855: js_GetBlockChainFast(JSContext *cx, JSStackFrame *fp, JSOp op, size_t oplen);
54855: 
    1: /*
    1:  * Refresh and return fp->scopeChain.  It may be stale if block scopes are
    1:  * active but not yet reflected by objects in the scope chain.  If a block
    1:  * scope contains a with, eval, XML filtering predicate, or similar such
    1:  * dynamically scoped construct, then compile-time block scope at fp->blocks
    1:  * must reflect at runtime.
    1:  */
    1: extern JSObject *
    1: js_GetScopeChain(JSContext *cx, JSStackFrame *fp);
    1: 
54855: extern JSObject *
54855: js_GetScopeChainFast(JSContext *cx, JSStackFrame *fp, JSOp op, size_t oplen);
54855: 
55711: namespace js {
55711: 
    1: /*
55711:  * Report an error that the this value passed as |this| in the given arguments
55711:  * vector is not compatible with the specified class.
 4127:  */
55750: void
55711: ReportIncompatibleMethod(JSContext *cx, Value *vp, Class *clasp);
48470: 
55711: /*
55711:  * Given a context and a vector of [callee, this, args...] for a function
55711:  * whose JSFUN_PRIMITIVE_THIS flag is set, set |*v| to the primitive value
55711:  * of |this|. If |this| is an object, insist that it be an instance of the
55711:  * appropriate wrapper class for T, and set |*v| to its private slot value.
55711:  * If |this| is a primitive, unbox it into |*v| if it's of the required
55711:  * type, and throw an error otherwise.
55711:  */
55711: template <typename T>
55711: bool GetPrimitiveThis(JSContext *cx, Value *vp, T *v);
 4127: 
53840: inline void
53840: PutActivationObjects(JSContext *cx, JSStackFrame *fp);
53840: 
 4127: /*
 2383:  * For a call with arguments argv including argv[-1] (nominal |this|) and
53004:  * argv[-2] (callee) replace null |this| with callee's parent and replace
53004:  * primitive values with the equivalent wrapper objects. argv[-1] must
53004:  * not be JSVAL_VOID or an activation object.
    1:  */
53081: extern bool
48470: ComputeThisFromArgv(JSContext *cx, js::Value *argv);
    1: 
48470: JS_ALWAYS_INLINE JSObject *
48470: ComputeThisFromVp(JSContext *cx, js::Value *vp)
48470: {
53081:     extern bool ComputeThisFromArgv(JSContext *, js::Value *);
53081:     return ComputeThisFromArgv(cx, vp + 2) ? &vp[1].toObject() : NULL;
53081: }
53081: 
53081: JS_ALWAYS_INLINE bool
53081: ComputeThisFromVpInPlace(JSContext *cx, js::Value *vp)
53081: {
53081:     extern bool ComputeThisFromArgv(JSContext *, js::Value *);
48470:     return ComputeThisFromArgv(cx, vp + 2);
48470: }
12551: 
55711: /* Return true if |fun| would accept |v| as its |this|, without being wrapped. */
48470: JS_ALWAYS_INLINE bool
48470: PrimitiveThisTest(JSFunction *fun, const Value &v)
48470: {
55711:     return !v.isPrimitive() || fun->acceptsPrimitiveThis();
48470: }
12551: 
12551: /*
50468:  * Abstracts the layout of the stack passed to natives from the engine and from
50468:  * natives to js::Invoke.
50468:  */
50468: struct CallArgs
50468: {
50468:     Value *argv_;
50468:     uintN argc_;
50468:   protected:
50468:     CallArgs() {}
50468:     CallArgs(Value *argv, uintN argc) : argv_(argv), argc_(argc) {}
50468:   public:
50468:     Value *base() const { return argv_ - 2; }
50468:     Value &callee() const { return argv_[-2]; }
50468:     Value &thisv() const { return argv_[-1]; }
50468:     Value &operator[](unsigned i) const { JS_ASSERT(i < argc_); return argv_[i]; }
50468:     Value *argv() const { return argv_; }
50468:     uintN argc() const { return argc_; }
50468:     Value &rval() const { return argv_[-2]; }
50468: 
53382:     bool computeThis(JSContext *cx) const {
50468:         return ComputeThisFromArgv(cx, argv_);
50468:     }
50468: };
50468: 
50468: /*
42714:  * The js::InvokeArgumentsGuard passed to js_Invoke must come from an
42714:  * immediately-enclosing successful call to js::StackSpace::pushInvokeArgs,
42714:  * i.e., there must have been no un-popped pushes to cx->stack(). Furthermore,
42714:  * |args.getvp()[0]| should be the callee, |args.getvp()[1]| should be |this|,
42714:  * and the range [args.getvp() + 2, args.getvp() + 2 + args.getArgc()) should
42714:  * be initialized actual arguments.
    1:  */
48470: extern JS_REQUIRES_STACK bool
53840: Invoke(JSContext *cx, const CallArgs &args, uint32 flags);
48470: 
    1: /*
55565:  * Natives like sort/forEach/replace call Invoke repeatedly with the same
55565:  * callee, this, and number of arguments. To optimize this, such natives can
55565:  * start an "invoke session" to factor out much of the dynamic setup logic
55565:  * required by a normal Invoke. Usage is:
55565:  *
55565:  *   InvokeSessionGuard session(cx);
55565:  *   if (!session.start(cx, callee, thisp, argc, &session))
55565:  *     ...
55565:  *
55565:  *   while (...) {
55565:  *     // write actual args (not callee, this)
55565:  *     session[0] = ...
55565:  *     ...
55565:  *     session[argc - 1] = ...
55565:  *
55565:  *     if (!session.invoke(cx, session))
55565:  *       ...
55565:  *
55565:  *     ... = session.rval();
55565:  *   }
55565:  *
55565:  *   // session ended by ~InvokeSessionGuard
55565:  */
55565: class InvokeSessionGuard;
55565: 
55565: /*
    1:  * Consolidated js_Invoke flags simply rename certain JSFRAME_* flags, so that
    1:  * we can share bits stored in JSStackFrame.flags and passed to:
    1:  *
    1:  *   js_Invoke
    1:  *   js_InternalInvoke
    1:  *   js_ValueToFunction
    1:  *   js_ValueToFunctionObject
    1:  *   js_ValueToCallableObject
    1:  *   js_ReportIsNotFunction
    1:  *
    1:  * See jsfun.h for the latter four and flag renaming macros.
    1:  */
    1: #define JSINVOKE_CONSTRUCT      JSFRAME_CONSTRUCTING
    1: 
    1: /*
    1:  * Mask to isolate construct and iterator flags for use with jsfun.h functions.
    1:  */
43211: #define JSINVOKE_FUNFLAGS       JSINVOKE_CONSTRUCT
    1: 
    1: /*
53557:  * "External" calls may come from C or C++ code using a JSContext on which no
    1:  * JS is running (!cx->fp), so they may need to push a dummy JSStackFrame.
    1:  */
53557: 
53557: extern bool
53557: ExternalInvoke(JSContext *cx, const Value &thisv, const Value &fval,
48470:                uintN argc, Value *argv, Value *rval);
    1: 
48470: static JS_ALWAYS_INLINE bool
53557: ExternalInvoke(JSContext *cx, JSObject *obj, const Value &fval,
48470:                uintN argc, Value *argv, Value *rval)
48470: {
53557:     return ExternalInvoke(cx, ObjectOrNullValue(obj), fval, argc, argv, rval);
48470: }
    1: 
48470: extern bool
53557: ExternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, const Value &fval,
48470:                  JSAccessMode mode, uintN argc, Value *argv, Value *rval);
    1: 
53557: /*
53557:  * These two functions invoke a function called from a constructor context
53557:  * (e.g. 'new'). InvokeConstructor handles the general case where a new object
53557:  * needs to be created for/by the constructor. ConstructWithGivenThis directly
53557:  * calls the constructor with the given 'this', hence the caller must
53557:  * understand the semantics of the constructor call.
53557:  */
53557: 
53557: extern JS_REQUIRES_STACK bool
53557: InvokeConstructor(JSContext *cx, const CallArgs &args);
53557: 
53557: extern JS_REQUIRES_STACK bool
53557: InvokeConstructorWithGivenThis(JSContext *cx, JSObject *thisobj, const Value &fval,
53557:                                uintN argc, Value *argv, Value *rval);
53557: 
53557: /*
53557:  * Executes a script with the given scope chain in the context of the given
53557:  * frame.
53557:  */
48470: extern JS_FORCES_STACK bool
48470: Execute(JSContext *cx, JSObject *chain, JSScript *script,
53840:         JSStackFrame *prev, uintN flags, Value *result);
    1: 
53557: /*
53557:  * Execute the caller-initialized frame for a user-defined script or function
53557:  * pointed to by cx->fp until completion or error.
53557:  */
54407: extern JS_REQUIRES_STACK JS_NEVER_INLINE bool
56201: Interpret(JSContext *cx, JSStackFrame *stopFp, uintN inlineCallCount = 0, JSInterpMode mode = JSINTERP_NORMAL);
48474: 
52558: extern JS_REQUIRES_STACK bool
55503: RunScript(JSContext *cx, JSScript *script, JSStackFrame *fp);
12551: 
12551: #define JSPROP_INITIALIZER 0x100   /* NB: Not a valid property attribute. */
12551: 
48470: extern bool
48470: CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                    JSObject **objp, JSProperty **propp);
    1: 
48470: extern bool
48470: StrictlyEqual(JSContext *cx, const Value &lval, const Value &rval);
    1: 
32760: /* === except that NaN is the same as NaN and -0 is not the same as +0. */
48470: extern bool
48470: SameValue(const Value &v1, const Value &v2, JSContext *cx);
32760: 
48470: extern JSType
48470: TypeOfValue(JSContext *cx, const Value &v);
48470: 
48470: inline bool
48470: InstanceOf(JSContext *cx, JSObject *obj, Class *clasp, Value *argv)
48470: {
48470:     if (obj && obj->getClass() == clasp)
48470:         return true;
48470:     extern bool InstanceOfSlow(JSContext *, JSObject *, Class *, Value *);
48470:     return InstanceOfSlow(cx, obj, clasp, argv);
48470: }
48470: 
48529: extern JSBool
48547: HasInstance(JSContext *cx, JSObject *obj, const js::Value *v, JSBool *bp);
48529: 
48470: inline void *
48470: GetInstancePrivate(JSContext *cx, JSObject *obj, Class *clasp, Value *argv)
48470: {
48470:     if (!InstanceOf(cx, obj, clasp, argv))
48470:         return NULL;
48470:     return obj->getPrivate();
48470: }
48470: 
48470: extern bool
48470: ValueToId(JSContext *cx, const Value &v, jsid *idp);
48470: 
15996: /*
48582:  * @param closureLevel      The static level of the closure that the cookie
48582:  *                          pertains to.
48582:  * @param cookie            Level amount is a "skip" (delta) value from the
48582:  *                          closure level.
48582:  * @return  The value of the upvar.
27169:  */
48470: extern const js::Value &
48582: GetUpvar(JSContext *cx, uintN level, js::UpvarCookie cookie);
48582: 
48582: } /* namespace js */
27169: 
27169: /*
15996:  * JS_LONE_INTERPRET indicates that the compiler should see just the code for
15996:  * the js_Interpret function when compiling jsinterp.cpp. The rest of the code
15996:  * from the file should be visible only when compiling jsinvoke.cpp. It allows
15996:  * platform builds to optimize selectively js_Interpret when the granularity
15996:  * of the optimizations with the given compiler is a compilation unit.
15996:  *
15996:  * JS_STATIC_INTERPRET is the modifier for functions defined in jsinterp.cpp
15996:  * that only js_Interpret calls. When JS_LONE_INTERPRET is true all such
15996:  * functions are declared below.
15996:  */
15996: #ifndef JS_LONE_INTERPRET
15996: # ifdef _MSC_VER
15996: #  define JS_LONE_INTERPRET 0
15996: # else
15996: #  define JS_LONE_INTERPRET 1
15996: # endif
15996: #endif
15996: 
33933: #define JS_MAX_INLINE_CALL_COUNT 3000
33933: 
15996: #if !JS_LONE_INTERPRET
15996: # define JS_STATIC_INTERPRET    static
15996: #else
15996: # define JS_STATIC_INTERPRET
15996: 
22652: extern JS_REQUIRES_STACK JSBool
55527: js_EnterWith(JSContext *cx, jsint stackIndex, JSOp op, size_t oplen);
12551: 
22652: extern JS_REQUIRES_STACK void
12551: js_LeaveWith(JSContext *cx);
12551: 
12551: /*
12611:  * Find the results of incrementing or decrementing *vp. For pre-increments,
12611:  * both *vp and *vp2 will contain the result on return. For post-increments,
12611:  * vp will contain the original value converted to a number and vp2 will get
12611:  * the result. Both vp and vp2 must be roots.
12611:  */
12611: extern JSBool
48470: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, js::Value *vp, js::Value *vp2);
12611: 
12611: /*
15453:  * Opcode tracing helper. When len is not 0, cx->fp->regs->pc[-len] gives the
15453:  * previous opcode.
15453:  */
22652: extern JS_REQUIRES_STACK void
56604: js_LogOpcode(JSContext *cx);
15453: 
15453: /*
12551:  * JS_OPMETER helper functions.
12551:  */
12551: extern void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2);
12551: 
12551: extern void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot);
    1: 
15996: #endif /* JS_LONE_INTERPRET */
52657: /*
52657:  * Unwind block and scope chains to match the given depth. The function sets
52657:  * fp->sp on return to stackDepth.
52657:  */
52657: extern JS_REQUIRES_STACK JSBool
52657: js_UnwindScope(JSContext *cx, jsint stackDepth, JSBool normalUnwind);
52657: 
52657: extern JSBool
52657: js_OnUnknownMethod(JSContext *cx, js::Value *vp);
52657: 
53125: extern JS_REQUIRES_STACK js::Class *
53125: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth);
53125: 
    1: #endif /* jsinterp_h___ */
