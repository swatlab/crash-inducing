    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Shell Service.
    1:  *
    1:  * The Initial Developer of the Original Code is mozilla.org.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Ben Goodger    <ben@mozilla.org>       (Clients, Mail, New Default Browser)
    1:  *  Joe Hewitt     <hewitt@netscape.com>   (Set Background)
 3818:  *  Blake Ross     <blake@cs.stanford.edu> (Desktop Color, DDE support)
    1:  *  Jungshik Shin  <jshin@mailaps.org>     (I18N)
 6438:  *  Robert Strong  <robert.bugzilla@gmail.com>
    1:  *  Asaf Romano    <mano@mozilla.com>
 3818:  *  Ryan Jones     <sciguyryan@gmail.com>
31003:  *  Paul O'Shannessy <paul@oshannessy.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgIContainer.h"
    1: #include "imgIRequest.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefLocalizedString.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsNetUtil.h"
    1: #include "nsShellService.h"
    1: #include "nsWindowsShellService.h"
    1: #include "nsIProcess.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsBrowserCompsCID.h"
    1: #include "nsDirectoryServiceUtils.h"
    1: #include "nsAppDirectoryServiceDefs.h"
 6438: #include "nsDirectoryServiceDefs.h"
    1: #include "nsIWindowsRegKey.h"
 3818: #include "nsUnicharUtils.h"
    1: 
    1: #include "windows.h"
    1: #include "shellapi.h"
14683: 
14683: #ifdef _WIN32_WINNT
14683: #undef _WIN32_WINNT
14683: #endif
14683: #define _WIN32_WINNT 0x0600
14683: #define INITGUID
14683: #include <shlobj.h>
    1: 
    1: #include <mbstring.h>
    1: 
    1: #ifndef MAX_BUF
    1: #define MAX_BUF 4096
    1: #endif
    1: 
    1: #define REG_SUCCEEDED(val) \
    1:   (val == ERROR_SUCCESS)
    1: 
    1: #define REG_FAILED(val) \
    1:   (val != ERROR_SUCCESS)
    1: 
30081: #ifndef WINCE
    1: NS_IMPL_ISUPPORTS2(nsWindowsShellService, nsIWindowsShellService, nsIShellService)
30081: #else
30081: NS_IMPL_ISUPPORTS1(nsWindowsShellService, nsIShellService)
30081: #endif
    1: 
    1: static nsresult
 6438: OpenKeyForReading(HKEY aKeyRoot, const nsAString& aKeyName, HKEY* aKey)
    1: {
 3818:   const nsString &flatName = PromiseFlatString(aKeyName);
    1: 
 6438:   DWORD res = ::RegOpenKeyExW(aKeyRoot, flatName.get(), 0, KEY_READ, aKey);
 3818:   switch (res) {
    1:   case ERROR_SUCCESS:
    1:     break;
    1:   case ERROR_ACCESS_DENIED:
    1:     return NS_ERROR_FILE_ACCESS_DENIED;
    1:   case ERROR_FILE_NOT_FOUND:
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
30081: #ifdef WINCE
30081: static nsresult
30081: OpenKeyForWriting(HKEY aStartKey, const nsAString& aKeyName, HKEY* aKey)
30081: {
30081:   const nsString &flatName = PromiseFlatString(aKeyName);
30081: 
30081:   DWORD dwDisp = 0;
30081:   DWORD res = ::RegCreateKeyExW(aStartKey, flatName.get(), 0, NULL,
30081:                                 0, KEY_READ | KEY_WRITE, NULL, aKey,
30081:                                 &dwDisp);
30081:   switch (res) {
30081:   case ERROR_SUCCESS:
30081:     break;
30081:   case ERROR_ACCESS_DENIED:
30081:     return NS_ERROR_FILE_ACCESS_DENIED;
30081:   case ERROR_FILE_NOT_FOUND:
30081:     res = ::RegCreateKeyExW(aStartKey, flatName.get(), 0, NULL,
30081:                             0, KEY_READ | KEY_WRITE, NULL, aKey,
30081:                             NULL);
30081:     if (res != ERROR_SUCCESS)
30081:       return NS_ERROR_FILE_ACCESS_DENIED;
30081:   }
30081: 
30081:   return NS_OK;
30081: }
30081: #endif
30081: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // Default Browser Registry Settings
    1: //
 6438: // The setting of these values are made by an external binary since writing
 6438: // these values may require elevation.
 6438: //
    1: // - File Extension Mappings
    1: //   -----------------------
    1: //   The following file extensions:
    1: //    .htm .html .shtml .xht .xhtml 
    1: //   are mapped like so:
    1: //
    1: //   HKCU\SOFTWARE\Classes\.<ext>\      (default)         REG_SZ     FirefoxHTML
    1: //
    1: //   as aliases to the class:
    1: //
    1: //   HKCU\SOFTWARE\Classes\FirefoxHTML\
    1: //     DefaultIcon                      (default)         REG_SZ     <apppath>,1
 3321: //     shell\open\command               (default)         REG_SZ     <apppath> -requestPending -osint -url "%1"
    1: //     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
    1: //     shell\open\ddeexec               NoActivateHandler REG_SZ
    1: //                       \Application   (default)         REG_SZ     Firefox
    1: //                       \Topic         (default)         REG_SZ     WWW_OpenURL
    1: //
    1: // - Windows Vista Protocol Handler
    1: //
    1: //   HKCU\SOFTWARE\Classes\FirefoxURL\  (default)         REG_SZ     <appname> URL
    1: //                                      EditFlags         REG_DWORD  2
    1: //                                      FriendlyTypeName  REG_SZ     <appname> URL
  769: //     DefaultIcon                      (default)         REG_SZ     <apppath>,1
 3321: //     shell\open\command               (default)         REG_SZ     <apppath> -requestPending -osint -url "%1"
    1: //     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
    1: //     shell\open\ddeexec               NoActivateHandler REG_SZ
    1: //                       \Application   (default)         REG_SZ     Firefox
    1: //                       \Topic         (default)         REG_SZ     WWW_OpenURL
    1: //
    1: // - Protocol Mappings
    1: //   -----------------
    1: //   The following protocols:
 3569: //    HTTP, HTTPS, FTP
    1: //   are mapped like so:
    1: //
    1: //   HKCU\SOFTWARE\Classes\<protocol>\
  769: //     DefaultIcon                      (default)         REG_SZ     <apppath>,1
 3321: //     shell\open\command               (default)         REG_SZ     <apppath> -requestPending -osint -url "%1"
    1: //     shell\open\ddeexec               (default)         REG_SZ     "%1",,0,0,,,,
    1: //     shell\open\ddeexec               NoActivateHandler REG_SZ
    1: //                       \Application   (default)         REG_SZ     Firefox
    1: //                       \Topic         (default)         REG_SZ     WWW_OpenURL
    1: //
    1: // - Windows Start Menu (Win2K SP2, XP SP1, and newer)
    1: //   -------------------------------------------------
    1: //   The following keys are set to make Firefox appear in the Start Menu as the
    1: //   browser:
    1: //   
    1: //   HKCU\SOFTWARE\Clients\StartMenuInternet\FIREFOX.EXE\
    1: //                                      (default)         REG_SZ     <appname>
    1: //     DefaultIcon                      (default)         REG_SZ     <apppath>,0
    1: //     InstallInfo                      HideIconsCommand  REG_SZ     <uninstpath> /HideShortcuts
    1: //     InstallInfo                      IconsVisible      REG_DWORD  1
    1: //     InstallInfo                      ReinstallCommand  REG_SZ     <uninstpath> /SetAsDefaultAppGlobal
    1: //     InstallInfo                      ShowIconsCommand  REG_SZ     <uninstpath> /ShowShortcuts
    1: //     shell\open\command               (default)         REG_SZ     <apppath>
    1: //     shell\properties                 (default)         REG_SZ     <appname> &Options
    1: //     shell\properties\command         (default)         REG_SZ     <apppath> -preferences
    1: //     shell\safemode                   (default)         REG_SZ     <appname> &Safe Mode
    1: //     shell\safemode\command           (default)         REG_SZ     <apppath> -safe-mode
    1: //
    1: 
    1: typedef struct {
    1:   char* keyName;
    1:   char* valueName;
    1:   char* valueData;
    1: } SETTING;
    1: 
30081: #ifndef WINCE
    1: #define APP_REG_NAME L"Firefox"
30081: #define CLS_HTML "FirefoxHTML"
30081: #define CLS_URL "FirefoxURL"
32067: #define CPL_DESKTOP L"Control Panel\\Desktop"
30081: #define VAL_OPEN "\"%APPPATH%\" -requestPending -osint -url \"%1\""
30081: #define VAL_FILE_ICON "%APPPATH%,1"
30081: #else
32067: #define CPL_DESKTOP L"ControlPanel\\Desktop"
30081: #define VAL_OPEN "\"%APPPATH%\" -osint -url \"%1\""
30081: #define VAL_FILE_ICON "%APPPATH%,-2"
30081: #endif
30081: 
    1: #define DI "\\DefaultIcon"
    1: #define SOP "\\shell\\open\\command"
    1: 
    1: 
    1: #define MAKE_KEY_NAME1(PREFIX, MID) \
    1:   PREFIX MID
    1: 
 6438: // The DefaultIcon registry key value should never be used when checking if
30081: // Firefox is the default browser for file handlers since other applications
30081: // (e.g. MS Office) may modify the DefaultIcon registry key value to add Icon
30081: // Handlers. see http://msdn2.microsoft.com/en-us/library/aa969357.aspx for
30081: // more info.
    1: static SETTING gSettings[] = {
30081: #ifndef WINCE
30081:   // File Handler Class
25014:   { MAKE_KEY_NAME1(CLS_HTML, SOP), "", VAL_OPEN },
    1: 
    1:   // Protocol Handler Class - for Vista and above
25014:   { MAKE_KEY_NAME1(CLS_URL, SOP), "", VAL_OPEN },
30081: #else
30081:   { MAKE_KEY_NAME1("FTP", DI), "", VAL_FILE_ICON },
30081:   { MAKE_KEY_NAME1("FTP", SOP), "", VAL_OPEN },
30081: 
30081:   // File handlers for Windows CE
30081:   { MAKE_KEY_NAME1("bmpfile", DI), "", VAL_FILE_ICON },
30081:   { MAKE_KEY_NAME1("bmpfile", SOP), "", VAL_OPEN },
30081:   { MAKE_KEY_NAME1("giffile", DI), "", VAL_FILE_ICON },
30081:   { MAKE_KEY_NAME1("giffile", SOP), "", VAL_OPEN },
30081:   { MAKE_KEY_NAME1("jpegfile", DI), "", VAL_FILE_ICON },
30081:   { MAKE_KEY_NAME1("jpegfile", SOP), "", VAL_OPEN },
30081:   { MAKE_KEY_NAME1("pngfile", DI), "", VAL_FILE_ICON },
30081:   { MAKE_KEY_NAME1("pngfile", SOP), "", VAL_OPEN },
30081:   { MAKE_KEY_NAME1("htmlfile", DI), "", VAL_FILE_ICON },
30081:   { MAKE_KEY_NAME1("htmlfile", SOP), "", VAL_OPEN },
30081: #endif
    1: 
    1:   // Protocol Handlers
25014:   { MAKE_KEY_NAME1("HTTP", DI),    "", VAL_FILE_ICON },
25014:   { MAKE_KEY_NAME1("HTTP", SOP),   "", VAL_OPEN },
25014:   { MAKE_KEY_NAME1("HTTPS", DI),   "", VAL_FILE_ICON },
25014:   { MAKE_KEY_NAME1("HTTPS", SOP),  "", VAL_OPEN }
    1: };
    1: 
30081: #ifndef WINCE
    1: PRBool
16387: nsWindowsShellService::IsDefaultBrowserVista(PRBool* aIsDefaultBrowser)
    1: {
27958: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
    1:   IApplicationAssociationRegistration* pAAR;
    1:   
14683:   HRESULT hr = CoCreateInstance(CLSID_ApplicationAssociationRegistration,
    1:                                 NULL,
    1:                                 CLSCTX_INPROC,
14683:                                 IID_IApplicationAssociationRegistration,
    1:                                 (void**)&pAAR);
    1: 
 3818:   if (SUCCEEDED(hr)) {
    1:     hr = pAAR->QueryAppIsDefaultAll(AL_EFFECTIVE,
    1:                                     APP_REG_NAME,
    1:                                     aIsDefaultBrowser);
    1: 
    1:     pAAR->Release();
    1:     return PR_TRUE;
    1:   }
14683: #endif  
    1:   return PR_FALSE;
    1: }
30081: #endif
    1: 
    1: NS_IMETHODIMP
 3818: nsWindowsShellService::IsDefaultBrowser(PRBool aStartupCheck,
 3818:                                         PRBool* aIsDefaultBrowser)
    1: {
 6438:   // If this is the first browser window, maintain internal state that we've
 6438:   // checked this session (so that subsequent window opens don't show the 
 6438:   // default browser dialog).
 6438:   if (aStartupCheck)
 6438:     mCheckedThisSession = PR_TRUE;
    1: 
    1:   SETTING* settings;
    1:   SETTING* end = gSettings + sizeof(gSettings)/sizeof(SETTING);
    1: 
    1:   *aIsDefaultBrowser = PR_TRUE;
    1: 
 3818:   PRUnichar exePath[MAX_BUF];
 3818:   if (!::GetModuleFileNameW(0, exePath, MAX_BUF))
    1:     return NS_ERROR_FAILURE;
    1: 
24930: #ifndef WINCE
25014:   // Convert the path to a long path since GetModuleFileNameW returns the path
25014:   // that was used to launch Firefox which is not necessarily a long path.
25014:   if (!::GetLongPathNameW(exePath, exePath, MAX_BUF))
    1:     return NS_ERROR_FAILURE;
24930: #endif
    1: 
25014:   nsAutoString appLongPath(exePath);
    1: 
25014:   nsresult rv;
 3818:   PRUnichar currValue[MAX_BUF];
    1:   for (settings = gSettings; settings < end; ++settings) {
 3818:     NS_ConvertUTF8toUTF16 dataLongPath(settings->valueData);
 3818:     NS_ConvertUTF8toUTF16 key(settings->keyName);
 3818:     NS_ConvertUTF8toUTF16 value(settings->valueName);
    1:     PRInt32 offset = dataLongPath.Find("%APPPATH%");
    1:     dataLongPath.Replace(offset, 9, appLongPath);
    1: 
    1:     ::ZeroMemory(currValue, sizeof(currValue));
    1:     HKEY theKey;
 6438:     rv = OpenKeyForReading(HKEY_CLASSES_ROOT, key, &theKey);
16387:     if (NS_FAILED(rv)) {
16387:       *aIsDefaultBrowser = PR_FALSE;
16388:       return NS_OK;
16387:     }
16387: 
    1:     DWORD len = sizeof currValue;
 3818:     DWORD res = ::RegQueryValueExW(theKey, PromiseFlatString(value).get(),
 3818:                                    NULL, NULL, (LPBYTE)currValue, &len);
    1:     // Close the key we opened.
    1:     ::RegCloseKey(theKey);
 3818:     if (REG_FAILED(res) ||
25014:         !dataLongPath.Equals(currValue, CaseInsensitiveCompare)) {
16387:       // Key wasn't set, or was set to something other than our registry entry
    1:       *aIsDefaultBrowser = PR_FALSE;
 6438:       return NS_OK;
    1:     }
    1:   }
    1: 
30081: #ifndef WINCE
 6438:   // Only check if Firefox is the default browser on Vista if the previous
 6438:   // checks show that Firefox is the default browser.
16387:   if (*aIsDefaultBrowser)
16387:     IsDefaultBrowserVista(aIsDefaultBrowser);
30081: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::SetDefaultBrowser(PRBool aClaimAllTypes, PRBool aForAllUsers)
    1: {
30081: #ifndef WINCE
 6438:   nsresult rv;
 6438:   nsCOMPtr<nsIProperties> directoryService = 
 6438:     do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
 6438:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6438:   nsCOMPtr<nsILocalFile> appHelper;
 6438:   rv = directoryService->Get(NS_XPCOM_CURRENT_PROCESS_DIR, NS_GET_IID(nsILocalFile), getter_AddRefs(appHelper));
 6438:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6438:   rv = appHelper->AppendNative(NS_LITERAL_CSTRING("uninstall"));
 6438:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6438:   rv = appHelper->AppendNative(NS_LITERAL_CSTRING("helper.exe"));
 6438:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
16387:   nsAutoString appHelperPath;
16387:   rv = appHelper->GetPath(appHelperPath);
 6438:   NS_ENSURE_SUCCESS(rv, rv);
 6438: 
 6438:   if (aForAllUsers) {
 6438:     appHelperPath.AppendLiteral(" /SetAsDefaultAppGlobal");
 6438:   } else {
 6438:     appHelperPath.AppendLiteral(" /SetAsDefaultAppUser");
 6438:   }
 6438: 
16387:   STARTUPINFOW si = {sizeof(si), 0};
 6438:   PROCESS_INFORMATION pi = {0};
 6438: 
16387:   BOOL ok = CreateProcessW(NULL, (LPWSTR)appHelperPath.get(), NULL, NULL,
 6438:                            FALSE, 0, NULL, NULL, &si, &pi);
 6438: 
 6438:   if (!ok)
    1:     return NS_ERROR_FAILURE;
    1: 
 6438:   CloseHandle(pi.hProcess);
 6438:   CloseHandle(pi.hThread);
30081: #else
30081:   SETTING* settings;
30081:   SETTING* end = gSettings + sizeof(gSettings)/sizeof(SETTING);
30081: 
30081:   PRUnichar exePath[MAX_BUF];
30081:   if (!::GetModuleFileNameW(0, exePath, MAX_BUF))
30081:     return NS_ERROR_FAILURE;
30081: 
30081:   nsAutoString appLongPath(exePath);
30081: 
30081:   // The .png registry key isn't present by default so also add Content Type.
30081:   SetRegKey(NS_LITERAL_STRING(".png"), EmptyString(),
30081:             NS_LITERAL_STRING("pngfile"));
30081:   SetRegKey(NS_LITERAL_STRING(".png"), NS_LITERAL_STRING("Content Type"),
30081:             NS_LITERAL_STRING("image/png"));
30081: 
30081:   // Set these keys to their default value for a clean install in case another
30081:   // app has changed these keys.
30081:   SetRegKey(NS_LITERAL_STRING(".htm"), EmptyString(),
30081:             NS_LITERAL_STRING("htmlfile"));
30081:   SetRegKey(NS_LITERAL_STRING(".html"), EmptyString(),
30081:             NS_LITERAL_STRING("htmlfile"));
30081:   SetRegKey(NS_LITERAL_STRING(".bmp"), EmptyString(),
30081:             NS_LITERAL_STRING("bmpfile"));
30081:   SetRegKey(NS_LITERAL_STRING(".gif"), EmptyString(),
30081:             NS_LITERAL_STRING("giffile"));
30081:   SetRegKey(NS_LITERAL_STRING(".jpe"), EmptyString(),
30081:             NS_LITERAL_STRING("jpegfile"));
30081:   SetRegKey(NS_LITERAL_STRING(".jpg"), EmptyString(),
30081:             NS_LITERAL_STRING("jpegfile"));
30081:   SetRegKey(NS_LITERAL_STRING(".jpeg"), EmptyString(),
30081:             NS_LITERAL_STRING("jpegfile"));
30081: 
30081:   for (settings = gSettings; settings < end; ++settings) {
30081:     NS_ConvertUTF8toUTF16 dataLongPath(settings->valueData);
30081:     NS_ConvertUTF8toUTF16 key(settings->keyName);
30081:     NS_ConvertUTF8toUTF16 value(settings->valueName);
30081:     PRInt32 offset = dataLongPath.Find("%APPPATH%");
30081:     dataLongPath.Replace(offset, 9, appLongPath);
30081:     SetRegKey(key, value, dataLongPath);
30081:   }
30081:   // On Windows CE RegFlushKey can negatively impact performance if there are a
30081:   // lot of pending writes to the HKEY_CLASSES_ROOT registry hive but it is
30081:   // necessary to save the values in the case where the user performs a hard
30081:   // power off of the device.
30081:   ::RegFlushKey(HKEY_CLASSES_ROOT);
30081: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
30081: #ifdef WINCE
30081: void
30081: nsWindowsShellService::SetRegKey(const nsString& aKeyName,
30081:                                  const nsString& aValueName,
30081:                                  const nsString& aValue)
30081: {
30081:   PRUnichar buf[MAX_BUF];
30081:   DWORD len = sizeof buf;
30081: 
30081:   HKEY theKey;
30081:   nsresult rv = OpenKeyForWriting(HKEY_CLASSES_ROOT, aKeyName, &theKey);
30081:   if (NS_FAILED(rv))
30081:     return;
30081: 
30081:   // Get the current value.
30081:   DWORD res = ::RegQueryValueExW(theKey, PromiseFlatString(aValueName).get(),
30081:                                  NULL, NULL, (LPBYTE)buf, &len);
30081: 
30081:   // Set the new value if it doesn't exist or it is different than the current
30081:   // value.
30081:   nsAutoString current(buf);
30081:   if (REG_FAILED(res) || !current.Equals(aValue)) {
30081:     const nsString &flatValue = PromiseFlatString(aValue);
30081: 
30081:     ::RegSetValueExW(theKey, PromiseFlatString(aValueName).get(),
30081:                      0, REG_SZ, (const BYTE *)flatValue.get(),
30081:                      (flatValue.Length() + 1) * sizeof(PRUnichar));
30081:   }
30081: 
30081:   // Close the key we opened.
30081:   ::RegCloseKey(theKey);
30081: }
30081: #endif
30081: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetShouldCheckDefaultBrowser(PRBool* aResult)
    1: {
    1:   // If we've already checked, the browser has been started and this is a 
    1:   // new window open, and we don't want to check again.
    1:   if (mCheckedThisSession) {
    1:     *aResult = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefs;
    1:   nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   if (pserve)
    1:     pserve->GetBranch("", getter_AddRefs(prefs));
    1: 
    1:   prefs->GetBoolPref(PREF_CHECKDEFAULTBROWSER, aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::SetShouldCheckDefaultBrowser(PRBool aShouldCheck)
    1: {
    1:   nsCOMPtr<nsIPrefBranch> prefs;
    1:   nsCOMPtr<nsIPrefService> pserve(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   if (pserve)
    1:     pserve->GetBranch("", getter_AddRefs(prefs));
    1: 
    1:   prefs->SetBoolPref(PREF_CHECKDEFAULTBROWSER, aShouldCheck);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
30479: WriteBitmap(nsIFile* aFile, imgIContainer* aImage)
    1: {
30479:   nsRefPtr<gfxImageSurface> image;
32424:   nsresult rv = aImage->CopyFrame(imgIContainer::FRAME_FIRST,
32424:                                   imgIContainer::FLAG_SYNC_DECODE,
32424:                                   getter_AddRefs(image));
30479:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
30479:   PRInt32 width = image->Width();
30479:   PRInt32 height = image->Height();
    1: 
30479:   PRUint8* bits = image->Data();
30479:   PRUint32 length = image->GetDataSize();
30479:   PRUint32 bpr = PRUint32(image->Stride());
    1:   PRInt32 bitCount = bpr/width;
    1: 
    1:   // initialize these bitmap structs which we will later
    1:   // serialize directly to the head of the bitmap file
    1:   BITMAPINFOHEADER bmi;
    1:   bmi.biSize = sizeof(BITMAPINFOHEADER);
    1:   bmi.biWidth = width;
    1:   bmi.biHeight = height;
    1:   bmi.biPlanes = 1;
    1:   bmi.biBitCount = (WORD)bitCount*8;
    1:   bmi.biCompression = BI_RGB;
    1:   bmi.biSizeImage = length;
    1:   bmi.biXPelsPerMeter = 0;
    1:   bmi.biYPelsPerMeter = 0;
    1:   bmi.biClrUsed = 0;
    1:   bmi.biClrImportant = 0;
    1: 
    1:   BITMAPFILEHEADER bf;
    1:   bf.bfType = 0x4D42; // 'BM'
    1:   bf.bfReserved1 = 0;
    1:   bf.bfReserved2 = 0;
    1:   bf.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
    1:   bf.bfSize = bf.bfOffBits + bmi.biSizeImage;
    1: 
    1:   // get a file output stream
    1:   nsCOMPtr<nsIOutputStream> stream;
30479:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(stream), aFile);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // write the bitmap headers and rgb pixel data to the file
    1:   rv = NS_ERROR_FAILURE;
    1:   if (stream) {
    1:     PRUint32 written;
    1:     stream->Write((const char*)&bf, sizeof(BITMAPFILEHEADER), &written);
    1:     if (written == sizeof(BITMAPFILEHEADER)) {
    1:       stream->Write((const char*)&bmi, sizeof(BITMAPINFOHEADER), &written);
    1:       if (written == sizeof(BITMAPINFOHEADER)) {
    1:         // write out the image data backwards because the desktop won't
    1:         // show bitmaps with negative heights for top-to-bottom
    1:         PRUint32 i = length;
    1:         do {
    1:           i -= bpr;
    1:           stream->Write(((const char*)bits) + i, bpr, &written);
    1:           if (written == bpr) {
    1:             rv = NS_OK;
    1:           } else {
    1:             rv = NS_ERROR_FAILURE;
    1:             break;
    1:           }
    1:         } while (i != 0);
    1:       }
    1:     }
    1: 
    1:     stream->Close();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::SetDesktopBackground(nsIDOMElement* aElement, 
    1:                                             PRInt32 aPosition)
    1: {
    1:   nsresult rv;
    1: 
30479:   nsCOMPtr<imgIContainer> container;
    1:   nsCOMPtr<nsIDOMHTMLImageElement> imgElement(do_QueryInterface(aElement));
    1:   if (!imgElement) {
    1:     // XXX write background loading stuff!
35665:     return NS_ERROR_NOT_AVAILABLE;
    1:   } 
    1:   else {
 3818:     nsCOMPtr<nsIImageLoadingContent> imageContent =
 3818:       do_QueryInterface(aElement, &rv);
 3818:     if (!imageContent)
 3818:       return rv;
    1: 
    1:     // get the image container
    1:     nsCOMPtr<imgIRequest> request;
    1:     rv = imageContent->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                                   getter_AddRefs(request));
 3818:     if (!request)
 3818:       return rv;
    1:     rv = request->GetImage(getter_AddRefs(container));
    1:     if (!container)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // get the file name from localized strings
    1:   nsCOMPtr<nsIStringBundleService>
    1:     bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIStringBundle> shellBundle;
    1:   rv = bundleService->CreateBundle(SHELLSERVICE_PROPERTIES,
    1:                                    getter_AddRefs(shellBundle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:  
    1:   // e.g. "Desktop Background.bmp"
    1:   nsString fileLeafName;
    1:   rv = shellBundle->GetStringFromName
    1:                       (NS_LITERAL_STRING("desktopBackgroundLeafNameWin").get(),
    1:                        getter_Copies(fileLeafName));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // get the profile root directory
    1:   nsCOMPtr<nsIFile> file;
    1:   rv = NS_GetSpecialDirectory(NS_APP_APPLICATION_REGISTRY_DIR,
    1:                               getter_AddRefs(file));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // eventually, the path is "%APPDATA%\Mozilla\Firefox\Desktop Background.bmp"
    1:   rv = file->Append(fileLeafName);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3818:   nsAutoString path;
 3818:   rv = file->GetPath(path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // write the bitmap to a file in the profile directory
30479:   rv = WriteBitmap(file, container);
    1: 
    1:   // if the file was written successfully, set it as the system wallpaper
    1:   if (NS_SUCCEEDED(rv)) {
    1:      PRBool result = PR_FALSE;
    1:      DWORD  dwDisp = 0;
    1:      HKEY   key;
31003:      // Try to create/open a subkey under HKCU.
31003:      DWORD res = ::RegCreateKeyExW(HKEY_CURRENT_USER, CPL_DESKTOP,
 3818:                                    0, NULL, REG_OPTION_NON_VOLATILE,
 3818:                                    KEY_WRITE, NULL, &key, &dwDisp);
 3818:     if (REG_SUCCEEDED(res)) {
31003: #ifndef WINCE
 3818:       PRUnichar tile[2], style[2];
 3818:       switch (aPosition) {
 3818:         case BACKGROUND_TILE:
    1:           tile[0] = '1';
    1:           style[0] = '1';
 3818:           break;
 3818:         case BACKGROUND_CENTER:
    1:           tile[0] = '0';
    1:           style[0] = '0';
 3818:           break;
 3818:         case BACKGROUND_STRETCH:
    1:           tile[0] = '0';
    1:           style[0] = '2';
 3818:           break;
    1:       }
    1:       tile[1] = '\0';
    1:       style[1] = '\0';
 3818: 
 3818:       // The size is always 3 unicode characters.
 3818:       PRInt32 size = 3 * sizeof(PRUnichar);
 3818:       ::RegSetValueExW(key, L"TileWallpaper",
 3818:                        0, REG_SZ, (const BYTE *)tile, size);
 3818:       ::RegSetValueExW(key, L"WallpaperStyle",
 3818:                        0, REG_SZ, (const BYTE *)style, size);
 3818:       ::SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, (PVOID)path.get(),
24930:                               SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
31003: #else
31003:       DWORD tile = (aPosition == BACKGROUND_TILE);
31003:       ::RegSetValueExW(key, L"Tile",
31003:                        0, REG_DWORD, (const BYTE *)&tile, sizeof(DWORD));
31003:       // On WinCE SPI_SETDESKWALLPAPER isn't available, so set the registry
31003:       // entry ourselves and then broadcast UI change
31003:       PRInt32 size = (path.Length() + 1) * sizeof(PRUnichar);
31003:       ::RegSetValueExW(key, L"Wallpaper",
31003:                        0, REG_SZ, (const BYTE *)path.get(), size);
31003:       ::SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, NULL, 0);
31003: #endif
31003: 
    1:       // Close the key we opened.
    1:       ::RegCloseKey(key);
31003: 
31003: #ifdef WINCE
31003:       // Ensure that the writes are flushed in case of hard reboot
31003:       ::RegFlushKey(HKEY_CURRENT_USER);
31003: #endif
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::OpenApplication(PRInt32 aApplication)
    1: {
 3818:   nsAutoString application;
    1:   switch (aApplication) {
    1:   case nsIShellService::APPLICATION_MAIL:
 3818:     application.AssignLiteral("Mail");
    1:     break;
    1:   case nsIShellService::APPLICATION_NEWS:
 3818:     application.AssignLiteral("News");
    1:     break;
    1:   }
    1: 
    1:   // The Default Client section of the Windows Registry looks like this:
    1:   // 
    1:   // Clients\aClient\
    1:   //  e.g. aClient = "Mail"...
    1:   //        \Mail\(default) = Client Subkey Name
    1:   //             \Client Subkey Name
    1:   //             \Client Subkey Name\shell\open\command\ 
    1:   //             \Client Subkey Name\shell\open\command\(default) = path to exe
    1:   //
    1: 
    1:   // Find the default application for this class.
    1:   HKEY theKey;
 6438:   nsresult rv = OpenKeyForReading(HKEY_CLASSES_ROOT, application, &theKey);
 3818:   if (NS_FAILED(rv))
 3818:     return rv;
    1: 
 3818:   PRUnichar buf[MAX_BUF];
    1:   DWORD type, len = sizeof buf;
 3818:   DWORD res = ::RegQueryValueExW(theKey, EmptyString().get(), 0,
 3818:                                  &type, (LPBYTE)&buf, &len);
 3818: 
 3818:   if (REG_FAILED(res) || !*buf)
    1:     return NS_OK;
    1: 
    1:   // Close the key we opened.
    1:   ::RegCloseKey(theKey);
    1: 
    1:   // Find the "open" command
 6438:   application.AppendLiteral("\\");
 6438:   application.Append(buf);
 6438:   application.AppendLiteral("\\shell\\open\\command");
    1: 
 6438:   rv = OpenKeyForReading(HKEY_CLASSES_ROOT, application, &theKey);
 3818:   if (NS_FAILED(rv))
 3818:     return rv;
    1: 
    1:   ::ZeroMemory(buf, sizeof(buf));
    1:   len = sizeof buf;
 3818:   res = ::RegQueryValueExW(theKey, EmptyString().get(), 0,
 3818:                            &type, (LPBYTE)&buf, &len);
 3818:   if (REG_FAILED(res) || !*buf)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Close the key we opened.
    1:   ::RegCloseKey(theKey);
    1: 
    1:   // Look for any embedded environment variables and substitute their 
 3818:   // values, as |::CreateProcessW| is unable to do this.
 3818:   nsAutoString path(buf);
    1:   PRInt32 end = path.Length();
    1:   PRInt32 cursor = 0, temp = 0;
    1:   ::ZeroMemory(buf, sizeof(buf));
    1:   do {
    1:     cursor = path.FindChar('%', cursor);
    1:     if (cursor < 0) 
    1:       break;
    1: 
    1:     temp = path.FindChar('%', cursor + 1);
    1:     ++cursor;
    1: 
    1:     ::ZeroMemory(&buf, sizeof(buf));
 3818: 
 3818:     ::GetEnvironmentVariableW(nsAutoString(Substring(path, cursor, temp - cursor)).get(),
    1:                               buf, sizeof(buf));
    1:     
    1:     // "+ 2" is to subtract the extra characters used to delimit the environment
    1:     // variable ('%').
 3818:     path.Replace((cursor - 1), temp - cursor + 2, nsDependentString(buf));
    1: 
    1:     ++cursor;
    1:   }
    1:   while (cursor < end);
    1: 
 3818:   STARTUPINFOW si;
    1:   PROCESS_INFORMATION pi;
    1: 
 3818:   ::ZeroMemory(&si, sizeof(STARTUPINFOW));
    1:   ::ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    1: 
 3818:   BOOL success = ::CreateProcessW(NULL, (LPWSTR)path.get(), NULL,
 3818:                                   NULL, FALSE, 0, NULL,  NULL,
 3818:                                   &si, &pi);
    1:   if (!success)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetDesktopBackgroundColor(PRUint32* aColor)
    1: {
    1:   PRUint32 color = ::GetSysColor(COLOR_DESKTOP);
    1:   *aColor = (GetRValue(color) << 16) | (GetGValue(color) << 8) | GetBValue(color);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::SetDesktopBackgroundColor(PRUint32 aColor)
    1: {
    1:   int aParameters[2] = { COLOR_BACKGROUND, COLOR_DESKTOP };
    1:   BYTE r = (aColor >> 16);
    1:   BYTE g = (aColor << 16) >> 24;
    1:   BYTE b = (aColor << 24) >> 24;
    1:   COLORREF colors[2] = { RGB(r,g,b), RGB(r,g,b) };
    1: 
    1:   ::SetSysColors(sizeof(aParameters) / sizeof(int), aParameters, colors);
    1: 
31003:   // SetSysColors is persisting across sessions on Windows CE, so no need to
31003:   // write to registry
31003: #ifndef WINCE
    1:   PRBool result = PR_FALSE;
    1:   DWORD  dwDisp = 0;
    1:   HKEY   key;
31003:   // Try to create/open a subkey under HKCU.
 3818:   DWORD rv = ::RegCreateKeyExW(HKEY_CURRENT_USER,
 3818:                                L"Control Panel\\Colors", 0, NULL,
 3818:                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
 3818:                                &key, &dwDisp);
 3818: 
 3818:   if (REG_SUCCEEDED(rv)) {
 3818:     char rgb[12];
    1:     sprintf((char*)rgb, "%u %u %u\0", r, g, b);
 3818:     NS_ConvertUTF8toUTF16 backColor(rgb);
 3818: 
 3818:     ::RegSetValueExW(key, L"Background",
 3818:                      0, REG_SZ, (const BYTE *)backColor.get(),
 3818:                      (backColor.Length() + 1) * sizeof(PRUnichar));
    1:   }
    1:   
    1:   // Close the key we opened.
    1:   ::RegCloseKey(key);
31003: #endif
    1:   return NS_OK;
    1: }
    1: 
30081: #ifndef WINCE
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetUnreadMailCount(PRUint32* aCount)
    1: {
    1:   *aCount = 0;
    1: 
    1:   HKEY accountKey;
    1:   if (GetMailAccountKey(&accountKey)) {
    1:     DWORD type, unreadCount;
    1:     DWORD len = sizeof unreadCount;
 3818:     DWORD res = ::RegQueryValueExW(accountKey, L"MessageCount", 0,
 3818:                                    &type, (LPBYTE)&unreadCount, &len);
 3818:     if (REG_SUCCEEDED(res))
    1:       *aCount = unreadCount;
    1: 
    1:     // Close the key we opened.
    1:     ::RegCloseKey(accountKey);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsWindowsShellService::GetMailAccountKey(HKEY* aResult)
    1: {
 3818:   NS_NAMED_LITERAL_STRING(unread,
 3818:     "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnreadMail\\");
 3818: 
    1:   HKEY mailKey;
 3818:   DWORD res = ::RegOpenKeyExW(HKEY_CURRENT_USER, unread.get(), 0,
 3818:                               KEY_ENUMERATE_SUB_KEYS, &mailKey);
    1: 
    1:   PRInt32 i = 0;
    1:   do {
 3818:     PRUnichar subkeyName[MAX_BUF];
    1:     DWORD len = sizeof subkeyName;
 3818:     res = ::RegEnumKeyExW(mailKey, i++, subkeyName, &len, NULL, NULL,
 3818:                           NULL, NULL);
 3818:     if (REG_SUCCEEDED(res)) {
    1:       HKEY accountKey;
 3818:       res = ::RegOpenKeyExW(mailKey, PromiseFlatString(subkeyName).get(),
 3818:                             0, KEY_READ, &accountKey);
 3818:       if (REG_SUCCEEDED(res)) {
    1:         *aResult = accountKey;
    1:     
    1:         // Close the key we opened.
    1:         ::RegCloseKey(mailKey);
    1: 	 
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:     else
    1:       break;
    1:   }
    1:   while (1);
    1: 
    1:   // Close the key we opened.
    1:   ::RegCloseKey(mailKey);
    1:   return PR_FALSE;
    1: }
30081: #endif
    1: 
    1: NS_IMETHODIMP
 3818: nsWindowsShellService::OpenApplicationWithURI(nsILocalFile* aApplication,
 3818:                                               const nsACString& aURI)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIProcess> process = 
    1:     do_CreateInstance("@mozilla.org/process/util;1", &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
    1:   rv = process->Init(aApplication);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
    1:   const nsCString spec(aURI);
    1:   const char* specStr = spec.get();
25944:   return process->Run(PR_FALSE, &specStr, 1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowsShellService::GetDefaultFeedReader(nsILocalFile** _retval)
    1: {
    1:   *_retval = nsnull;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWindowsRegKey> regKey =
    1:     do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CLASSES_ROOT,
    1:                     NS_LITERAL_STRING("feed\\shell\\open\\command"),
    1:                     nsIWindowsRegKey::ACCESS_READ);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString path;
    1:   rv = regKey->ReadStringValue(EmptyString(), path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (path.IsEmpty())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (path.First() == '"') {
    1:     // Everything inside the quotes
    1:     path = Substring(path, 1, path.FindChar('"', 1) - 1);
    1:   }
    1:   else {
    1:     // Everything up to the first space
    1:     path = Substring(path, 0, path.FindChar(' '));
    1:   }
    1: 
    1:   nsCOMPtr<nsILocalFile> defaultReader =
    1:     do_CreateInstance("@mozilla.org/file/local;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = defaultReader->InitWithPath(path);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool exists;
    1:   rv = defaultReader->Exists(&exists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!exists)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*_retval = defaultReader);
    1:   return NS_OK;
    1: }
