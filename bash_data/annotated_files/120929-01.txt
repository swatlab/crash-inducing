     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 46517: #include "base/basictypes.h"
110521: #include "ipc/IPCMessageUtils.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsDOMUIEvent.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIInterfaceRequestorUtils.h"
 73870: #include "nsIDOMWindow.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIContent.h"
     1: #include "nsContentUtils.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsIFrame.h"
     1: #include "nsIScrollableFrame.h"
 86062: #include "DictionaryHelpers.h"
 96887: #include "mozilla/Util.h"
 96887: #include "mozilla/Assertions.h"
105904: #include "nsDOMClassInfoID.h"
 96887: 
 96887: using namespace mozilla;
     1: 
     1: nsDOMUIEvent::nsDOMUIEvent(nsPresContext* aPresContext, nsGUIEvent* aEvent)
     1:   : nsDOMEvent(aPresContext, aEvent ?
  3233:                static_cast<nsEvent *>(aEvent) :
 80486:                static_cast<nsEvent *>(new nsUIEvent(false, 0, 0)))
 98161:   , mClientPoint(0, 0), mLayerPoint(0, 0), mPagePoint(0, 0), mMovementPoint(0, 0)
 95203:   , mIsPointerLocked(nsEventStateManager::sIsPointerLocked)
 95203:   , mLastClientPoint(nsEventStateManager::sLastClientPoint)
     1: {
     1:   if (aEvent) {
 80486:     mEventIsInternal = false;
     1:   }
     1:   else {
 80486:     mEventIsInternal = true;
     1:     mEvent->time = PR_Now();
     1:   }
     1:   
     1:   // Fill mDetail and mView according to the mEvent (widget-generated
     1:   // event) we've got
     1:   switch(mEvent->eventStructType)
     1:   {
     1:     case NS_UI_EVENT:
     1:     {
  3233:       nsUIEvent *event = static_cast<nsUIEvent*>(mEvent);
     1:       mDetail = event->detail;
     1:       break;
     1:     }
     1: 
     1:     case NS_SCROLLPORT_EVENT:
     1:     {
  3233:       nsScrollPortEvent* scrollEvent = static_cast<nsScrollPortEvent*>(mEvent);
108991:       mDetail = (int32_t)scrollEvent->orient;
     1:       break;
     1:     }
     1: 
     1:     default:
     1:       mDetail = 0;
     1:       break;
     1:   }
     1: 
106838:   mView = nullptr;
     1:   if (mPresContext)
     1:   {
     1:     nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
     1:     if (container)
     1:     {
 73870:        nsCOMPtr<nsIDOMWindow> window = do_GetInterface(container);
     1:        if (window)
     1:           mView = do_QueryInterface(window);
     1:     }
     1:   }
     1: }
     1: 
  2792: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMUIEvent)
  2792: 
  2792: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMUIEvent, nsDOMEvent)
  2792:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mView)
  2792: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
  2792: 
  2792: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMUIEvent, nsDOMEvent)
  2792:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mView)
  2792: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
  2792: 
     1: NS_IMPL_ADDREF_INHERITED(nsDOMUIEvent, nsDOMEvent)
     1: NS_IMPL_RELEASE_INHERITED(nsDOMUIEvent, nsDOMEvent)
     1: 
 40490: DOMCI_DATA(UIEvent, nsDOMUIEvent)
 40490: 
  2792: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMUIEvent)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMUIEvent)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(UIEvent)
     1: NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)
     1: 
102505: static nsIntPoint
102505: DevPixelsToCSSPixels(const nsIntPoint& aPoint, nsPresContext* aContext)
102505: {
102505:   return nsIntPoint(aContext->DevPixelsToIntCSSPixels(aPoint.x),
102505:                     aContext->DevPixelsToIntCSSPixels(aPoint.y));
102505: }
102505: 
 23738: nsIntPoint
 95203: nsDOMUIEvent::GetMovementPoint()
 23738: {
 98161:   if (mPrivateDataDuplicated) {
 98161:     return mMovementPoint;
 98161:   }
 98161: 
     1:   if (!mEvent ||
102505:       !((nsGUIEvent*)mEvent)->widget ||
     1:        (mEvent->eventStructType != NS_MOUSE_EVENT &&
     1:         mEvent->eventStructType != NS_POPUP_EVENT &&
     1:         mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
108049:         mEvent->eventStructType != NS_WHEEL_EVENT &&
 25058:         mEvent->eventStructType != NS_DRAG_EVENT &&
 25058:         mEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT)) {
 23738:     return nsIntPoint(0, 0);
     1:   }
     1: 
102505:   // Calculate the delta between the last screen point and the current one.
102505:   nsIntPoint current = DevPixelsToCSSPixels(mEvent->refPoint, mPresContext);
102505:   nsIntPoint last = DevPixelsToCSSPixels(mEvent->lastRefPoint, mPresContext);
102505:   return current - last;
     1: }
     1: 
 23738: nsIntPoint
 23738: nsDOMUIEvent::GetClientPoint()
 23738: {
 95203:   if (mIsPointerLocked) {
 95203:     return mLastClientPoint;
     1:   }
     1: 
 95203:   return CalculateClientPoint(mPresContext, mEvent, &mClientPoint);
     1: }
     1: 
     1: NS_IMETHODIMP
 69169: nsDOMUIEvent::GetView(nsIDOMWindow** aView)
     1: {
     1:   *aView = mView;
     1:   NS_IF_ADDREF(*aView);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetDetail(int32_t* aDetail)
     1: {
     1:   *aDetail = mDetail;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 69169: nsDOMUIEvent::InitUIEvent(const nsAString& typeArg,
 79445:                           bool canBubbleArg,
 79445:                           bool cancelableArg,
 69169:                           nsIDOMWindow* viewArg,
108991:                           int32_t detailArg)
     1: {
120929:   if (viewArg) {
120929:     nsCOMPtr<nsPIDOMWindow> view = do_QueryInterface(viewArg);
120929:     NS_ENSURE_TRUE(view, NS_ERROR_INVALID_ARG);
120929:   }
     1:   nsresult rv = nsDOMEvent::InitEvent(typeArg, canBubbleArg, cancelableArg);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
     1:   mDetail = detailArg;
     1:   mView = viewArg;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 84569: nsresult
 86062: nsDOMUIEvent::InitFromCtor(const nsAString& aType,
 86062:                            JSContext* aCx, jsval* aVal)
 84569: {
 86062:   mozilla::dom::UIEventInit d;
 86062:   nsresult rv = d.Init(aCx, aVal);
 84569:   NS_ENSURE_SUCCESS(rv, rv);
 86062:   return InitUIEvent(aType, d.bubbles, d.cancelable, d.view, d.detail);
 84569: }
 84569: 
     1: // ---- nsDOMNSUIEvent implementation -------------------
 23738: nsIntPoint
     1: nsDOMUIEvent::GetPagePoint()
     1: {
 15901:   if (mPrivateDataDuplicated) {
 15901:     return mPagePoint;
 15901:   }
 15901: 
 23738:   nsIntPoint pagePoint = GetClientPoint();
 15901: 
 15901:   // If there is some scrolling, add scroll info to client point.
 15901:   if (mPresContext && mPresContext->GetPresShell()) {
 12466:     nsIPresShell* shell = mPresContext->GetPresShell();
  7864:     nsIScrollableFrame* scrollframe = shell->GetRootScrollFrameAsScrollable();
 15901:     if (scrollframe) {
 15901:       nsPoint pt = scrollframe->GetScrollPosition();
 23738:       pagePoint += nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(pt.x),
     1:                               nsPresContext::AppUnitsToIntCSSPixels(pt.y));
     1:     }
     1:   }
     1: 
 15901:   return pagePoint;
 15901: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetPageX(int32_t* aPageX)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPageX);
 87650:   if (mPrivateDataDuplicated) {
 87650:     *aPageX = mPagePoint.x;
 87650:   } else {
 87650:     *aPageX = nsDOMEvent::GetPageCoords(mPresContext,
 87650:                                         mEvent,
 87650:                                         mEvent->refPoint,
 87650:                                         mClientPoint).x;
 87650:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetPageY(int32_t* aPageY)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPageY);
 87650:   if (mPrivateDataDuplicated) {
 87650:     *aPageY = mPagePoint.y;
 87650:   } else {
 87650:     *aPageY = nsDOMEvent::GetPageCoords(mPresContext,
 87650:                                         mEvent,
 87650:                                         mEvent->refPoint,
 87650:                                         mClientPoint).y;
 87650:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetWhich(uint32_t* aWhich)
     1: {
 77226:   return Which(aWhich);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsDOMUIEvent::GetRangeParent(nsIDOMNode** aRangeParent)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aRangeParent);
106838:   nsIFrame* targetFrame = nullptr;
     1: 
     1:   if (mPresContext) {
 68780:     targetFrame = mPresContext->EventStateManager()->GetEventTarget();
     1:   }
     1: 
106838:   *aRangeParent = nullptr;
     1: 
     1:   if (targetFrame) {
     1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent,
     1:                                                               targetFrame);
     1:     nsCOMPtr<nsIContent> parent = targetFrame->GetContentOffsetsFromPoint(pt).content;
     1:     if (parent) {
118445:       if (parent->ChromeOnlyAccess() &&
 61588:           !nsContentUtils::CanAccessNativeAnon()) {
 61588:         return NS_OK;
 61588:       }
     1:       return CallQueryInterface(parent, aRangeParent);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetRangeOffset(int32_t* aRangeOffset)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aRangeOffset);
106838:   nsIFrame* targetFrame = nullptr;
     1: 
     1:   if (mPresContext) {
 68780:     targetFrame = mPresContext->EventStateManager()->GetEventTarget();
     1:   }
     1: 
     1:   if (targetFrame) {
     1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent,
     1:                                                               targetFrame);
     1:     *aRangeOffset = targetFrame->GetContentOffsetsFromPoint(pt).offset;
     1:     return NS_OK;
     1:   }
     1:   *aRangeOffset = 0;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDOMUIEvent::GetCancelBubble(bool* aCancelBubble)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aCancelBubble);
     1:   *aCancelBubble =
 80486:     (mEvent->flags & NS_EVENT_FLAG_STOP_DISPATCH) ? true : false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDOMUIEvent::SetCancelBubble(bool aCancelBubble)
     1: {
     1:   if (aCancelBubble) {
     1:     mEvent->flags |= NS_EVENT_FLAG_STOP_DISPATCH;
     1:   } else {
     1:     mEvent->flags &= ~NS_EVENT_FLAG_STOP_DISPATCH;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 23738: nsIntPoint
 23738: nsDOMUIEvent::GetLayerPoint()
 23738: {
     1:   if (!mEvent ||
     1:       (mEvent->eventStructType != NS_MOUSE_EVENT &&
 18737:        mEvent->eventStructType != NS_POPUP_EVENT &&
 18737:        mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
108049:        mEvent->eventStructType != NS_WHEEL_EVENT &&
 87650:        mEvent->eventStructType != NS_TOUCH_EVENT &&
 25058:        mEvent->eventStructType != NS_DRAG_EVENT &&
 25058:        mEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT) ||
  7852:       !mPresContext ||
  7852:       mEventIsInternal) {
  7852:     return mLayerPoint;
     1:   }
     1:   // XXX I'm not really sure this is correct; it's my best shot, though
 68780:   nsIFrame* targetFrame = mPresContext->EventStateManager()->GetEventTarget();
     1:   if (!targetFrame)
  7852:     return mLayerPoint;
     1:   nsIFrame* layer = nsLayoutUtils::GetClosestLayer(targetFrame);
     1:   nsPoint pt(nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent, layer));
 23738:   return nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(pt.x),
 23738:                     nsPresContext::AppUnitsToIntCSSPixels(pt.y));
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetLayerX(int32_t* aLayerX)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aLayerX);
     1:   *aLayerX = GetLayerPoint().x;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsDOMUIEvent::GetLayerY(int32_t* aLayerY)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aLayerY);
     1:   *aLayerY = GetLayerPoint().y;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsDOMUIEvent::GetIsChar(bool* aIsChar)
     1: {
     1:   switch(mEvent->eventStructType)
     1:   {
     1:     case NS_KEY_EVENT:
     1:       *aIsChar = ((nsKeyEvent*)mEvent)->isChar;
     1:       return NS_OK;
     1:     case NS_TEXT_EVENT:
     1:       *aIsChar = ((nsTextEvent*)mEvent)->isChar;
     1:       return NS_OK;
     1:     default:
 80486:       *aIsChar = false;
     1:       return NS_OK;
     1:   }
     1: }
     1: 
101616: NS_IMETHODIMP
  7852: nsDOMUIEvent::DuplicatePrivateData()
  7852: {
 87650:   mClientPoint = nsDOMEvent::GetClientCoords(mPresContext,
 87650:                                              mEvent,
 87650:                                              mEvent->refPoint,
 87650:                                              mClientPoint);
 98161:   mMovementPoint = GetMovementPoint();
 87650:   mLayerPoint = GetLayerPoint();
 87650:   mPagePoint = nsDOMEvent::GetPageCoords(mPresContext,
 87650:                                          mEvent,
 87650:                                          mEvent->refPoint,
 87650:                                          mClientPoint);
 87650:   // GetScreenPoint converts mEvent->refPoint to right coordinates.
 87650:   nsIntPoint screenPoint = nsDOMEvent::GetScreenCoords(mPresContext,
 87650:                                                        mEvent,
 87650:                                                        mEvent->refPoint);
  7852:   nsresult rv = nsDOMEvent::DuplicatePrivateData();
  7852:   if (NS_SUCCEEDED(rv)) {
  7852:     mEvent->refPoint = screenPoint;
  7852:   }
  7852:   return rv;
  7852: }
  7852: 
101616: NS_IMETHODIMP_(void)
 79445: nsDOMUIEvent::Serialize(IPC::Message* aMsg, bool aSerializeInterfaceType)
 46517: {
 46517:   if (aSerializeInterfaceType) {
 46517:     IPC::WriteParam(aMsg, NS_LITERAL_STRING("uievent"));
 46517:   }
 46517: 
 80486:   nsDOMEvent::Serialize(aMsg, false);
 46517: 
108991:   int32_t detail = 0;
 46517:   GetDetail(&detail);
 46517:   IPC::WriteParam(aMsg, detail);
 46517: }
 46517: 
101616: NS_IMETHODIMP_(bool)
 46517: nsDOMUIEvent::Deserialize(const IPC::Message* aMsg, void** aIter)
 46517: {
 80486:   NS_ENSURE_TRUE(nsDOMEvent::Deserialize(aMsg, aIter), false);
 80486:   NS_ENSURE_TRUE(IPC::ReadParam(aMsg, aIter, &mDetail), false);
 80486:   return true;
 46517: }
 46517: 
 96887: // XXX Following struct and array are used only in
 96887: //     nsDOMUIEvent::ComputeModifierState(), but if we define them in it,
 96887: //     we fail to build on Mac at calling mozilla::ArrayLength().
 96887: struct nsModifierPair
 96887: {
 96887:   mozilla::widget::Modifier modifier;
 96887:   const char* name;
 96887: };
 96887: static const nsModifierPair kPairs[] = {
 96887:   { widget::MODIFIER_ALT,        NS_DOM_KEYNAME_ALT },
 96887:   { widget::MODIFIER_ALTGRAPH,   NS_DOM_KEYNAME_ALTGRAPH },
 96887:   { widget::MODIFIER_CAPSLOCK,   NS_DOM_KEYNAME_CAPSLOCK },
 96887:   { widget::MODIFIER_CONTROL,    NS_DOM_KEYNAME_CONTROL },
 96887:   { widget::MODIFIER_FN,         NS_DOM_KEYNAME_FN },
 96887:   { widget::MODIFIER_META,       NS_DOM_KEYNAME_META },
 96887:   { widget::MODIFIER_NUMLOCK,    NS_DOM_KEYNAME_NUMLOCK },
103761:   { widget::MODIFIER_SCROLLLOCK, NS_DOM_KEYNAME_SCROLLLOCK },
 96887:   { widget::MODIFIER_SHIFT,      NS_DOM_KEYNAME_SHIFT },
 96887:   { widget::MODIFIER_SYMBOLLOCK, NS_DOM_KEYNAME_SYMBOLLOCK },
103761:   { widget::MODIFIER_OS,         NS_DOM_KEYNAME_OS }
 96887: };
 96887: 
 96887: /* static */
 96887: mozilla::widget::Modifiers
 96887: nsDOMUIEvent::ComputeModifierState(const nsAString& aModifiersList)
 96887: {
 96887:   if (aModifiersList.IsEmpty()) {
 96887:     return 0;
 96887:   }
 96887: 
 96887:   // Be careful about the performance.  If aModifiersList is too long,
 96887:   // parsing it needs too long time.
 96887:   // XXX Should we abort if aModifiersList is too long?
 96887: 
 96887:   Modifiers modifiers = 0;
 96887: 
 96887:   nsAString::const_iterator listStart, listEnd;
 96887:   aModifiersList.BeginReading(listStart);
 96887:   aModifiersList.EndReading(listEnd);
 96887: 
108991:   for (uint32_t i = 0; i < mozilla::ArrayLength(kPairs); i++) {
 96887:     nsAString::const_iterator start(listStart), end(listEnd);
 96887:     if (!FindInReadable(NS_ConvertASCIItoUTF16(kPairs[i].name), start, end)) {
 96887:       continue;
 96887:     }
 96887: 
 96887:     if ((start != listStart && !NS_IsAsciiWhitespace(*(--start))) ||
 96887:         (end != listEnd && !NS_IsAsciiWhitespace(*(end)))) {
 96887:       continue;
 96887:     }
 96887:     modifiers |= kPairs[i].modifier;
 96887:   }
 96887: 
 96887:   return modifiers;
 96887: }
 96887: 
 96887: bool
 96887: nsDOMUIEvent::GetModifierStateInternal(const nsAString& aKey)
 96887: {
 96892:   nsInputEvent* inputEvent = static_cast<nsInputEvent*>(mEvent);
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_SHIFT)) {
 96892:     return inputEvent->IsShift();
 96887:   }
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_CONTROL)) {
 96892:     return inputEvent->IsControl();
 96887:   }
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_META)) {
 96892:     return inputEvent->IsMeta();
 96887:   }
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_ALT)) {
 96892:     return inputEvent->IsAlt();
 96887:   }
 96887: 
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_ALTGRAPH)) {
 96892:     return inputEvent->IsAltGraph();
 96887:   }
103761:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_OS)) {
103761:     return inputEvent->IsOS();
 96887:   }
 96887: 
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_CAPSLOCK)) {
 96892:     return inputEvent->IsCapsLocked();
 96887:   }
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_NUMLOCK)) {
 96892:     return inputEvent->IsNumLocked();
 96887:   }
 96887: 
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_FN)) {
 96892:     return inputEvent->IsFn();
 96887:   }
103761:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_SCROLLLOCK)) {
 96892:     return inputEvent->IsScrollLocked();
 96887:   }
 96887:   if (aKey.EqualsLiteral(NS_DOM_KEYNAME_SYMBOLLOCK)) {
 96892:     return inputEvent->IsSymbolLocked();
 96887:   }
 96887:   return false;
 96887: }
 96887: 
 96887: 
     1: nsresult NS_NewDOMUIEvent(nsIDOMEvent** aInstancePtrResult,
     1:                           nsPresContext* aPresContext,
     1:                           nsGUIEvent *aEvent) 
     1: {
     1:   nsDOMUIEvent* it = new nsDOMUIEvent(aPresContext, aEvent);
     1:   return CallQueryInterface(it, aInstancePtrResult);
     1: }
