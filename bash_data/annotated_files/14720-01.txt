    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is TableBackgroundPainter implementation.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Elika J. Etemad ("fantasai") <fantasai@inkedblade.net>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsTableFrame.h"
    1: #include "nsTableRowGroupFrame.h"
    1: #include "nsTableRowFrame.h"
    1: #include "nsTableColGroupFrame.h"
    1: #include "nsTableColFrame.h"
    1: #include "nsTableCellFrame.h"
    1: #include "nsTablePainter.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsDisplayList.h"
    1: 
    1: /* ~*~ Table Background Painting ~*~
    1: 
    1:    Mozilla's Table Background painting follows CSS2.1:17.5.1
    1:    That section does not, however, describe the effect of
    1:    borders on background image positioning. What we do is:
    1: 
    1:      - in separate borders, the borders are passed in so that
    1:        their width figures in image positioning, even for rows/cols, which
    1:        don't have visible borders. This is done to allow authors
    1:        to position row backgrounds by, for example, aligning the
    1:        top left corner with the top left padding corner of the
    1:        top left table cell in the row in cases where all cells
    1:        have consistent border widths. If we didn't honor these
    1:        invisible borders, there would be no way to align
    1:        backgrounds with the padding edges, and designs would be
    1:        lost underneath the border.
    1: 
    1:      - in collapsing borders, because the borders collapse, we
    1:        use the -continuous border- width to synthesize a border
    1:        style and pass that in instead of using the element's
    1:        assigned style directly.
    1: 
    1:        The continuous border on a given edge of an element is
    1:        the collapse of all borders guaranteed to be continuous
    1:        along that edge. Cell borders are ignored (because, for
    1:        example, setting a thick border on the leftmost cell
    1:        should not shift the row background over; this way a
    1:        striped background set on <tr> will line up across rows
    1:        even if the cells are assigned arbitrary border widths.
    1: 
    1:        For example, the continuous border on the top edge of a
    1:        row group is the collapse of any row group, row, and
    1:        table borders involved. (The first row group's top would
    1:        be [table-top + row group top + first row top]. It's bottom
    1:        would be [row group bottom + last row bottom + next row
    1:        top + next row group top].)
    1:        The top edge of a column group likewise includes the
    1:        table top, row group top, and first row top borders. However,
    1:        it *also* includes its own top border, since that is guaranteed
    1:        to be continuous. It does not include column borders because
    1:        those are not guaranteed to be continuous: there may be two
    1:        columns with different borders in a single column group.
    1: 
    1:        An alternative would be to define the continuous border as
    1:          [table? + row group + row] for horizontal
    1:          [table? + col group + col] for vertical
    1:        This makes it easier to line up backgrounds across elements
    1:        despite varying border widths, but it does not give much
    1:        flexibility in aligning /to/ those border widths.
    1: */
    1: 
    1: 
    1: /* ~*~ TableBackgroundPainter ~*~
    1: 
    1:    The TableBackgroundPainter is created and destroyed in one painting call.
    1:    Its principal function is PaintTable, which paints all table element
    1:    backgrounds. The initial code in that method sets up an array of column
    1:    data that caches the background styles and the border sizes for the
    1:    columns and colgroups in TableBackgroundData structs in mCols. Data for
    1:    BC borders are calculated and stashed in a synthesized border style struct
    1:    in the data struct since collapsed borders aren't the same width as style-
    1:    assigned borders. The data struct optimizes by only doing this if there's
    1:    an image background; otherwise we don't care. //XXX should also check background-origin
    1:    The class then loops through the row groups, rows, and cells. It uses
    1:    the mRowGroup and mRow TableBackgroundData structs to cache data for
    1:    the current frame in the loop. At the cell level, it paints the backgrounds,
    1:    one over the other, inside the cell rect.
    1: 
    1:    The exception to this pattern is when a table element creates a (pseudo)
    1:    stacking context. Elements with stacking contexts (e.g., 'opacity' applied)
    1:    are <dfn>passed through</dfn>, which means their data (and their
    1:    descendants' data) are not cached. The full loop is still executed, however,
    1:    so that underlying layers can get painted at the cell level.
    1: 
    1:    The TableBackgroundPainter is then destroyed.
    1: 
    1:    Elements with stacking contexts set up their own painter to finish the
    1:    painting process, since they were skipped. They call the appropriate
    1:    sub-part of the loop (e.g. PaintRow) which will paint the frame and
    1:    descendants. Note that it is permissible according to CSS2.1 to ignore'
    1:    'position:relative' (and implicitly, 'opacity') on table parts so that
    1:    table parts can never create stacking contexts; if we want to, we can
    1:    implement that, and then we won't have to deal with TableBackgroundPainter
    1:    being used anywhere but from the nsTableFrame.
    1:    
    1:    XXX views are going 
    1:  */
    1: 
    1: TableBackgroundPainter::TableBackgroundData::TableBackgroundData()
    1:   : mFrame(nsnull),
    1:     mBackground(nsnull),
    1:     mBorder(nsnull),
    1:     mSynthBorder(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(TableBackgroundData);
    1: }
    1: 
    1: TableBackgroundPainter::TableBackgroundData::~TableBackgroundData()
    1: {
    1:   NS_ASSERTION(!mSynthBorder, "must call Destroy before dtor");
    1:   MOZ_COUNT_DTOR(TableBackgroundData);
    1: }
    1: 
    1: void
    1: TableBackgroundPainter::TableBackgroundData::Destroy(nsPresContext* aPresContext)
    1: {
    1:   NS_PRECONDITION(aPresContext, "null prescontext");
    1:   if (mSynthBorder) {
    1:     mSynthBorder->Destroy(aPresContext);
    1:     mSynthBorder = nsnull;
    1:   }
    1: }
    1: 
    1: void
    1: TableBackgroundPainter::TableBackgroundData::Clear()
    1: {
    1:   mRect.Empty();
    1:   mFrame = nsnull;
    1:   mBorder = nsnull;
    1:   mBackground = nsnull;
    1: }
    1: 
    1: void
    1: TableBackgroundPainter::TableBackgroundData::SetFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1:   mFrame = aFrame;
    1:   mRect = aFrame->GetRect();
    1: }
    1: 
    1: void
    1: TableBackgroundPainter::TableBackgroundData::SetData()
    1: {
    1:   NS_PRECONDITION(mFrame, "null frame");
    1:   if (mFrame->IsVisibleForPainting()) {
    1:     mBackground = mFrame->GetStyleBackground();
    1:     mBorder = mFrame->GetStyleBorder();
    1:   }
    1: }
    1: 
    1: void
    1: TableBackgroundPainter::TableBackgroundData::SetFull(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1:   SetFrame(aFrame);
    1:   SetData();
    1: }
    1: 
    1: inline PRBool
    1: TableBackgroundPainter::TableBackgroundData::ShouldSetBCBorder()
    1: {
    1:   /* we only need accurate border data when positioning background images*/
    1:   return mBackground && !(mBackground->mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE);
    1: }
    1: 
    1: nsresult
    1: TableBackgroundPainter::TableBackgroundData::SetBCBorder(nsMargin& aBorder,
    1:                                                          TableBackgroundPainter* aPainter)
    1: {
    1:   NS_PRECONDITION(aPainter, "null painter");
    1:   if (!mSynthBorder) {
    1:     mSynthBorder = new (aPainter->mPresContext)
    1:                         nsStyleBorder(aPainter->mZeroBorder);
    1:     if (!mSynthBorder) return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_FOR_CSS_SIDES(side) {
    1:     mSynthBorder->SetBorderWidth(side, aBorder.side(side));
    1:   }
    1:   
    1:   mBorder = mSynthBorder;
    1:   return NS_OK;
    1: }
    1: 
    1: TableBackgroundPainter::TableBackgroundPainter(nsTableFrame*        aTableFrame,
    1:                                                Origin               aOrigin,
    1:                                                nsPresContext*       aPresContext,
    1:                                                nsIRenderingContext& aRenderingContext,
13405:                                                const nsRect&        aDirtyRect,
13405:                                                const nsPoint&       aRenderPt)
    1:   : mPresContext(aPresContext),
    1:     mRenderingContext(aRenderingContext),
13405:     mRenderPt(aRenderPt),
    1:     mDirtyRect(aDirtyRect),
    1:     mOrigin(aOrigin),
    1:     mCols(nsnull),
    1:     mZeroBorder(aPresContext)
    1: {
    1:   MOZ_COUNT_CTOR(TableBackgroundPainter);
    1: 
    1:   NS_FOR_CSS_SIDES(side) {
    1:     mZeroBorder.SetBorderStyle(side, NS_STYLE_BORDER_STYLE_SOLID);
    1:     mZeroBorder.SetBorderWidth(side, 0);
    1:   }
    1: 
    1:   mZeroPadding.RecalcData();
    1: 
    1:   mIsBorderCollapse = aTableFrame->IsBorderCollapse();
    1: #ifdef DEBUG
    1:   mCompatMode = mPresContext->CompatibilityMode();
    1: #endif
    1:   mNumCols = aTableFrame->GetColCount();
    1: }
    1: 
    1: TableBackgroundPainter::~TableBackgroundPainter()
    1: {
    1:   if (mCols) {
    1:     TableBackgroundData* lastColGroup = nsnull;
    1:     for (PRUint32 i = 0; i < mNumCols; i++) {
    1:       if (mCols[i].mColGroup != lastColGroup) {
    1:         lastColGroup = mCols[i].mColGroup;
    1:         NS_ASSERTION(mCols[i].mColGroup, "colgroup data should not be null - bug 237421");
    1:         // we need to wallpaper a over zero pointer deref, bug 237421 will have the real fix
    1:         if(lastColGroup)
    1:           lastColGroup->Destroy(mPresContext);
    1:         delete lastColGroup;
    1:       }
    1:       mCols[i].mColGroup = nsnull;
    1:       mCols[i].mCol.Destroy(mPresContext);
    1:     }
    1:     delete [] mCols;
    1:   }
    1:   mRowGroup.Destroy(mPresContext);
    1:   mRow.Destroy(mPresContext);
    1:   MOZ_COUNT_DTOR(TableBackgroundPainter);
    1: }
    1: 
    1: nsresult
    1: TableBackgroundPainter::PaintTableFrame(nsTableFrame*         aTableFrame,
    1:                                         nsTableRowGroupFrame* aFirstRowGroup,
    1:                                         nsTableRowGroupFrame* aLastRowGroup,
    1:                                         nsMargin*             aDeflate)
    1: {
    1:   NS_PRECONDITION(aTableFrame, "null frame");
    1:   TableBackgroundData tableData;
    1:   tableData.SetFull(aTableFrame);
    1:   tableData.mRect.MoveTo(0,0); //using table's coords
    1:   if (aDeflate) {
    1:     tableData.mRect.Deflate(*aDeflate);
    1:   }
    1:   if (mIsBorderCollapse && tableData.ShouldSetBCBorder()) {
    1:     if (aFirstRowGroup && aLastRowGroup && mNumCols > 0) {
    1:       //only handle non-degenerate tables; we need a more robust BC model
    1:       //to make degenerate tables' borders reasonable to deal with
    1:       nsMargin border, tempBorder;
    1:       nsTableColFrame* colFrame = aTableFrame->GetColFrame(mNumCols - 1);
    1:       if (colFrame) {
    1:         colFrame->GetContinuousBCBorderWidth(tempBorder);
    1:       }
    1:       border.right = tempBorder.right;
    1: 
    1:       aLastRowGroup->GetContinuousBCBorderWidth(tempBorder);
    1:       border.bottom = tempBorder.bottom;
    1: 
    1:       nsTableRowFrame* rowFrame = aFirstRowGroup->GetFirstRow();
    1:       if (rowFrame) {
    1:         rowFrame->GetContinuousBCBorderWidth(tempBorder);
    1:         border.top = tempBorder.top;
    1:       }
    1: 
    1:       border.left = aTableFrame->GetContinuousLeftBCBorderWidth();
    1: 
    1:       nsresult rv = tableData.SetBCBorder(border, this);
    1:       if (NS_FAILED(rv)) {
    1:         tableData.Destroy(mPresContext);
    1:         return rv;
    1:       }
    1:     }
    1:   }
    1:   if (tableData.IsVisible()) {
    1:     nsCSSRendering::PaintBackgroundWithSC(mPresContext, mRenderingContext,
    1:                                           tableData.mFrame, mDirtyRect,
13405:                                           tableData.mRect + mRenderPt,
    1:                                           *tableData.mBackground,
    1:                                           *tableData.mBorder,
    1:                                           mZeroPadding, PR_TRUE);
    1:   }
    1:   tableData.Destroy(mPresContext);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: TableBackgroundPainter::TranslateContext(nscoord aDX,
    1:                                          nscoord aDY)
    1: {
13405:   mRenderPt += nsPoint(aDX, aDY);
    1:   if (mCols) {
    1:     TableBackgroundData* lastColGroup = nsnull;
    1:     for (PRUint32 i = 0; i < mNumCols; i++) {
    1:       mCols[i].mCol.mRect.MoveBy(-aDX, -aDY);
    1:       if (lastColGroup != mCols[i].mColGroup) {
    1:         NS_ASSERTION(mCols[i].mColGroup, "colgroup data should not be null - bug 237421");
    1:         // we need to wallpaper a over zero pointer deref, bug 237421 will have the real fix
    1:         if (!mCols[i].mColGroup)
    1:           return;
    1:         mCols[i].mColGroup->mRect.MoveBy(-aDX, -aDY);
    1:         lastColGroup = mCols[i].mColGroup;
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: TableBackgroundPainter::PaintTable(nsTableFrame* aTableFrame,
    1:                                    nsMargin*     aDeflate)
    1: {
    1:   NS_PRECONDITION(aTableFrame, "null table frame");
    1: 
 2141:   nsTableFrame::RowGroupArray rowGroups;
 2141:   aTableFrame->OrderRowGroups(rowGroups);
    1: 
 2141:   if (rowGroups.Length() < 1) { //degenerate case
    1:     PaintTableFrame(aTableFrame, nsnull, nsnull, nsnull);
    1:     /* No cells; nothing else to paint */
    1:     return NS_OK;
    1:   }
    1: 
 2141:   PaintTableFrame(aTableFrame, rowGroups[0], rowGroups[rowGroups.Length() - 1],
    1:                   aDeflate);
    1: 
    1:   /*Set up column background/border data*/
    1:   if (mNumCols > 0) {
    1:     nsFrameList& colGroupList = aTableFrame->GetColGroups();
    1:     NS_ASSERTION(colGroupList.FirstChild(), "table should have at least one colgroup");
    1: 
    1:     mCols = new ColData[mNumCols];
    1:     if (!mCols) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     TableBackgroundData* cgData = nsnull;
    1:     nsMargin border;
    1:     /* BC left borders aren't stored on cols, but the previous column's
    1:        right border is the next one's left border.*/
    1:     //Start with table's left border.
    1:     nscoord lastLeftBorder = aTableFrame->GetContinuousLeftBCBorderWidth();
 3233:     for (nsTableColGroupFrame* cgFrame = static_cast<nsTableColGroupFrame*>(colGroupList.FirstChild());
 3233:          cgFrame; cgFrame = static_cast<nsTableColGroupFrame*>(cgFrame->GetNextSibling())) {
    1: 
    1:       if (cgFrame->GetColCount() < 1) {
    1:         //No columns, no cells, so no need for data
    1:         continue;
    1:       }
    1: 
    1:       /*Create data struct for column group*/
    1:       cgData = new TableBackgroundData;
    1:       if (!cgData) return NS_ERROR_OUT_OF_MEMORY;
    1:       cgData->SetFull(cgFrame);
    1:       if (mIsBorderCollapse && cgData->ShouldSetBCBorder()) {
    1:         border.left = lastLeftBorder;
    1:         cgFrame->GetContinuousBCBorderWidth(border);
    1:         nsresult rv = cgData->SetBCBorder(border, this);
    1:         if (NS_FAILED(rv)) {
    1:           cgData->Destroy(mPresContext);
    1:           delete cgData;
    1:           return rv;
    1:         }
    1:       }
    1: 
    1:       // Boolean that indicates whether mCols took ownership of cgData
    1:       PRBool cgDataOwnershipTaken = PR_FALSE;
    1:       
    1:       /*Loop over columns in this colgroup*/
    1:       for (nsTableColFrame* col = cgFrame->GetFirstColumn(); col;
 3233:            col = static_cast<nsTableColFrame*>(col->GetNextSibling())) {
    1:         /*Create data struct for column*/
    1:         PRUint32 colIndex = col->GetColIndex();
    1:         NS_ASSERTION(colIndex < mNumCols, "prevent array boundary violation");
    1:         if (mNumCols <= colIndex)
    1:           break;
    1:         mCols[colIndex].mCol.SetFull(col);
    1:         //Bring column mRect into table's coord system
    1:         mCols[colIndex].mCol.mRect.MoveBy(cgData->mRect.x, cgData->mRect.y);
    1:         //link to parent colgroup's data
    1:         mCols[colIndex].mColGroup = cgData;
    1:         cgDataOwnershipTaken = PR_TRUE;
    1:         if (mIsBorderCollapse) {
    1:           border.left = lastLeftBorder;
    1:           lastLeftBorder = col->GetContinuousBCBorderWidth(border);
    1:           if (mCols[colIndex].mCol.ShouldSetBCBorder()) {
    1:             nsresult rv = mCols[colIndex].mCol.SetBCBorder(border, this);
    1:             if (NS_FAILED(rv)) return rv;
    1:           }
    1:         }
    1:       }
    1: 
    1:       if (!cgDataOwnershipTaken) {
    1:         cgData->Destroy(mPresContext);
    1:         delete cgData;
    1:       }
    1:     }
    1:   }
    1: 
 2141:   for (PRUint32 i = 0; i < rowGroups.Length(); i++) {
 2141:     nsTableRowGroupFrame* rg = rowGroups[i];
    1:     mRowGroup.SetFrame(rg);
    1:     // Need to compute the right rect via GetOffsetTo, since the row
    1:     // group may not be a child of the table.
    1:     mRowGroup.mRect.MoveTo(rg->GetOffsetTo(aTableFrame));
13405:     if (mRowGroup.mRect.Intersects(mDirtyRect - mRenderPt)) {
    1:       nsresult rv = PaintRowGroup(rg, rg->IsPseudoStackingContextFromStyle());
    1:       if (NS_FAILED(rv)) return rv;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: TableBackgroundPainter::PaintRowGroup(nsTableRowGroupFrame* aFrame,
    1:                                       PRBool                aPassThrough)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1: 
    1:   if (!mRowGroup.mFrame) {
    1:     mRowGroup.SetFrame(aFrame);
    1:   }
    1: 
    1:   nsTableRowFrame* firstRow = aFrame->GetFirstRow();
    1: 
    1:   /* Load row group data */
    1:   if (!aPassThrough) {
    1:     mRowGroup.SetData();
    1:     if (mIsBorderCollapse && mRowGroup.ShouldSetBCBorder()) {
    1:       nsMargin border;
    1:       if (firstRow) {
    1:         //pick up first row's top border (= rg top border)
    1:         firstRow->GetContinuousBCBorderWidth(border);
    1:         /* (row group doesn't store its top border) */
    1:       }
    1:       //overwrite sides+bottom borders with rg's own
    1:       aFrame->GetContinuousBCBorderWidth(border);
    1:       nsresult res = mRowGroup.SetBCBorder(border, this);
    1:       if (!NS_SUCCEEDED(res)) {
    1:         return res;
    1:       }
    1:     }
    1:     aPassThrough = !mRowGroup.IsVisible();
    1:   }
    1: 
    1:   /* translate everything into row group coord system*/
    1:   if (eOrigin_TableRowGroup != mOrigin) {
    1:     TranslateContext(mRowGroup.mRect.x, mRowGroup.mRect.y);
    1:   }
    1:   nsRect rgRect = mRowGroup.mRect;
    1:   mRowGroup.mRect.MoveTo(0, 0);
    1: 
    1:   /* Find the right row to start with */
    1:   nscoord ignored; // We don't care about overflow above, since what we really
    1:                    // care about are backgrounds and overflow above doesn't
    1:                    // correspond to backgrounds, since cells can't span up from
    1:                    // their originating row.  We do care about overflow below,
    1:                    // however, since that can be due to rowspans.
    1: 
13405:   // Note that mDirtyRect  - mRenderPt is guaranteed to be in the row
13405:   // group's coordinate system here, so passing its .y to
13405:   // GetFirstRowContaining is ok.
13405:   nsIFrame* cursor = aFrame->GetFirstRowContaining(mDirtyRect.y - mRenderPt.y, &ignored);
    1: 
    1:   // Sadly, it seems like there may be non-row frames in there... or something?
    1:   // There are certainly null-checks in GetFirstRow() and GetNextRow().  :(
    1:   while (cursor && cursor->GetType() != nsGkAtoms::tableRowFrame) {
    1:     cursor = cursor->GetNextSibling();
    1:   }
    1: 
    1:   // It's OK if cursor is null here.
 3233:   nsTableRowFrame* row = static_cast<nsTableRowFrame*>(cursor);  
    1:   if (!row) {
    1:     // No useful cursor; just start at the top.  Don't bother to set up a
    1:     // cursor; if we've gotten this far then we've already built the display
    1:     // list for the rowgroup, so not having a cursor means that there's some
    1:     // good reason we don't have a cursor and we shouldn't create one here.
    1:     row = firstRow;
    1:   }
    1:   
    1:   /* Finally paint */
    1:   for (; row; row = row->GetNextRow()) {
    1:     mRow.SetFrame(row);
13405:     if (mDirtyRect.YMost() - mRenderPt.y < mRow.mRect.y) { // Intersect wouldn't handle
    1:                                              // rowspans.
    1: 
    1:       // All done; cells originating in later rows can't intersect mDirtyRect.
    1:       break;
    1:     }
    1:     
    1:     nsresult rv = PaintRow(row, aPassThrough || row->IsPseudoStackingContextFromStyle());
    1:     if (NS_FAILED(rv)) return rv;
    1:   }
    1: 
    1:   /* translate back into table coord system */
    1:   if (eOrigin_TableRowGroup != mOrigin) {
    1:     TranslateContext(-rgRect.x, -rgRect.y);
    1:   }
    1:   
    1:   /* unload rg data */
    1:   mRowGroup.Clear();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: TableBackgroundPainter::PaintRow(nsTableRowFrame* aFrame,
    1:                                  PRBool           aPassThrough)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1: 
    1:   if (!mRow.mFrame) {
    1:     mRow.SetFrame(aFrame);
    1:   }
    1: 
    1:   /* Load row data */
    1:   if (!aPassThrough) {
    1:     mRow.SetData();
    1:     if (mIsBorderCollapse && mRow.ShouldSetBCBorder()) {
    1:       nsMargin border;
    1:       nsTableRowFrame* nextRow = aFrame->GetNextRow();
    1:       if (nextRow) { //outer top below us is inner bottom for us
    1:         border.bottom = nextRow->GetOuterTopContBCBorderWidth();
    1:       }
    1:       else { //acquire rg's bottom border
 3233:         nsTableRowGroupFrame* rowGroup = static_cast<nsTableRowGroupFrame*>(aFrame->GetParent());
    1:         rowGroup->GetContinuousBCBorderWidth(border);
    1:       }
    1:       //get the rest of the borders; will overwrite all but bottom
    1:       aFrame->GetContinuousBCBorderWidth(border);
    1: 
    1:       nsresult res = mRow.SetBCBorder(border, this);
    1:       if (!NS_SUCCEEDED(res)) {
    1:         return res;
    1:       }
    1:     }
    1:     aPassThrough = !mRow.IsVisible();
    1:   }
    1: 
    1:   /* Translate */
    1:   if (eOrigin_TableRow == mOrigin) {
    1:     /* If we originate from the row, then make the row the origin. */
    1:     mRow.mRect.MoveTo(0, 0);
    1:   }
    1:   //else: Use row group's coord system -> no translation necessary
    1: 
    1:   for (nsTableCellFrame* cell = aFrame->GetFirstCell(); cell; cell = cell->GetNextCell()) {
    1:     //Translate to use the same coord system as mRow.
13406:     mCellRect = cell->GetRect() + mRow.mRect.TopLeft() + mRenderPt;
13406:     if (mCellRect.Intersects(mDirtyRect)) {
    1:       nsresult rv = PaintCell(cell, aPassThrough || cell->IsPseudoStackingContextFromStyle());
    1:       if (NS_FAILED(rv)) return rv;
    1:     }
    1:   }
    1: 
    1:   /* Unload row data */
    1:   mRow.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: TableBackgroundPainter::PaintCell(nsTableCellFrame* aCell,
    1:                                   PRBool aPassSelf)
    1: {
    1:   NS_PRECONDITION(aCell, "null frame");
    1: 
    1:   const nsStyleTableBorder* cellTableStyle;
    1:   cellTableStyle = aCell->GetStyleTableBorder();
    1:   if (!(NS_STYLE_TABLE_EMPTY_CELLS_SHOW == cellTableStyle->mEmptyCells ||
    1:         NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND == cellTableStyle->mEmptyCells)
    1:       && aCell->GetContentEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRInt32 colIndex;
    1:   aCell->GetColIndex(colIndex);
14720:   NS_ASSERTION(colIndex < mNumCols, "prevent array boundary violation");
14720:   if (mNumCols <= colIndex)
14720:     return NS_OK;
    1: 
    1:   //Paint column group background
    1:   if (mCols && mCols[colIndex].mColGroup && mCols[colIndex].mColGroup->IsVisible()) {
    1:     nsCSSRendering::PaintBackgroundWithSC(mPresContext, mRenderingContext,
    1:                                           mCols[colIndex].mColGroup->mFrame, mDirtyRect,
13405:                                           mCols[colIndex].mColGroup->mRect + mRenderPt,
    1:                                           *mCols[colIndex].mColGroup->mBackground,
    1:                                           *mCols[colIndex].mColGroup->mBorder,
    1:                                           mZeroPadding, PR_TRUE, &mCellRect);
    1:   }
    1: 
    1:   //Paint column background
    1:   if (mCols && mCols[colIndex].mCol.IsVisible()) {
    1:     nsCSSRendering::PaintBackgroundWithSC(mPresContext, mRenderingContext,
    1:                                           mCols[colIndex].mCol.mFrame, mDirtyRect,
13405:                                           mCols[colIndex].mCol.mRect + mRenderPt,
    1:                                           *mCols[colIndex].mCol.mBackground,
    1:                                           *mCols[colIndex].mCol.mBorder,
    1:                                           mZeroPadding, PR_TRUE, &mCellRect);
    1:   }
    1: 
    1:   //Paint row group background
    1:   if (mRowGroup.IsVisible()) {
    1:     nsCSSRendering::PaintBackgroundWithSC(mPresContext, mRenderingContext,
13405:                                           mRowGroup.mFrame, mDirtyRect,
13405:                                           mRowGroup.mRect + mRenderPt,
    1:                                           *mRowGroup.mBackground, *mRowGroup.mBorder,
    1:                                           mZeroPadding, PR_TRUE, &mCellRect);
    1:   }
    1: 
    1:   //Paint row background
    1:   if (mRow.IsVisible()) {
    1:     nsCSSRendering::PaintBackgroundWithSC(mPresContext, mRenderingContext,
13405:                                           mRow.mFrame, mDirtyRect,
13405:                                           mRow.mRect + mRenderPt,
    1:                                           *mRow.mBackground, *mRow.mBorder,
    1:                                           mZeroPadding, PR_TRUE, &mCellRect);
    1:   }
    1: 
    1:   //Paint cell background in border-collapse unless we're just passing
    1:   if (mIsBorderCollapse && !aPassSelf) {
13405:     aCell->PaintCellBackground(mRenderingContext, mDirtyRect,
13406:                                mCellRect.TopLeft());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
