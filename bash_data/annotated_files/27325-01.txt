    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Brian Ryner <bryner@brianryner.com>  (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNativeTheme.h"
26846: #include "nsIWidget.h"
    1: #include "nsIDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsIFrame.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsString.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsThemeConstants.h"
    1: #include "nsIComponentManager.h"
24447: #include "nsIDOMNSHTMLInputElement.h"
    1: 
    1: nsNativeTheme::nsNativeTheme()
    1: {
    1: }
    1: 
    1: nsIPresShell *
    1: nsNativeTheme::GetPresShell(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return nsnull;
    1: 
    1:   // this is a workaround for the egcs 1.1.2 not inliningg
    1:   // aFrame->GetPresContext(), which causes an undefined symbol
    1:   nsPresContext *context = aFrame->GetStyleContext()->GetRuleNode()->GetPresContext();
    1:   return context ? context->GetPresShell() : nsnull;
    1: }
    1: 
    1: PRInt32
    1: nsNativeTheme::GetContentState(nsIFrame* aFrame, PRUint8 aWidgetType)
    1: {
    1:   if (!aFrame)
    1:     return 0;
    1: 
    1:   PRBool isXULCheckboxRadio = 
 1321:     (aWidgetType == NS_THEME_CHECKBOX ||
21220:      aWidgetType == NS_THEME_RADIO) &&
    1:     aFrame->GetContent()->IsNodeOfType(nsINode::eXUL);
    1:   if (isXULCheckboxRadio)
    1:     aFrame = aFrame->GetParent();
    1: 
27325:   if (!aFrame->GetContent())
27325:     return 0;
27325: 
    1:   nsIPresShell *shell = GetPresShell(aFrame);
    1:   if (!shell)
    1:     return 0;
    1: 
    1:   PRInt32 flags = 0;
    1:   shell->GetPresContext()->EventStateManager()->GetContentState(aFrame->GetContent(), flags);
    1:   
21220:   if (isXULCheckboxRadio && aWidgetType == NS_THEME_RADIO) {
    1:     if (IsFocused(aFrame))
    1:       flags |= NS_EVENT_STATE_FOCUS;
    1:   }
    1:   
    1:   return flags;
    1: }
    1: 
    1: PRBool
    1: nsNativeTheme::CheckBooleanAttr(nsIFrame* aFrame, nsIAtom* aAtom)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
    1:   nsIContent* content = aFrame->GetContent();
27325:   if (!content)
27325:     return PR_FALSE;
27325: 
    1:   if (content->IsNodeOfType(nsINode::eHTML))
    1:     return content->HasAttr(kNameSpaceID_None, aAtom);
    1: 
    1:   // For XML/XUL elements, an attribute must be equal to the literal
    1:   // string "true" to be counted as true.  An empty string should _not_
    1:   // be counted as true.
    1:   return content->AttrValueIs(kNameSpaceID_None, aAtom,
    1:                               NS_LITERAL_STRING("true"), eCaseMatters);
    1: }
    1: 
    1: PRInt32
13622: nsNativeTheme::CheckIntAttr(nsIFrame* aFrame, nsIAtom* aAtom, PRInt32 defaultValue)
    1: {
    1:   if (!aFrame)
13622:     return defaultValue;
    1: 
    1:   nsAutoString attr;
    1:   aFrame->GetContent()->GetAttr(kNameSpaceID_None, aAtom, attr);
    1:   PRInt32 err, value = attr.ToInteger(&err);
13622:   if (attr.IsEmpty() || NS_FAILED(err))
13622:     return defaultValue;
    1: 
    1:   return value;
    1: }
    1: 
    1: PRBool
    1: nsNativeTheme::GetCheckedOrSelected(nsIFrame* aFrame, PRBool aCheckSelected)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
    1:   nsIContent* content = aFrame->GetContent();
    1: 
    1:   if (content->IsNodeOfType(nsINode::eXUL)) {
    1:     // For a XUL checkbox or radio button, the state of the parent determines
    1:     // the checked state
    1:     aFrame = aFrame->GetParent();
    1:   } else {
    1:     // Check for an HTML input element
    1:     nsCOMPtr<nsIDOMHTMLInputElement> inputElt = do_QueryInterface(content);
    1:     if (inputElt) {
    1:       PRBool checked;
    1:       inputElt->GetChecked(&checked);
    1:       return checked;
    1:     }
    1:   }
    1: 
    1:   return CheckBooleanAttr(aFrame, aCheckSelected ? nsWidgetAtoms::selected
    1:                                                  : nsWidgetAtoms::checked);
    1: }
    1: 
    1: PRBool
24447: nsNativeTheme::GetIndeterminate(nsIFrame* aFrame)
24447: {
24447:   if (!aFrame)
24447:     return PR_FALSE;
24447: 
24447:   nsIContent* content = aFrame->GetContent();
24447: 
24447:   if (content->IsNodeOfType(nsINode::eXUL)) {
24447:     // For a XUL checkbox or radio button, the state of the parent determines
24447:     // the state
24447:     return CheckBooleanAttr(aFrame->GetParent(), nsWidgetAtoms::indeterminate);
24447:   }
24447: 
24447:   // Check for an HTML input element
24447:   nsCOMPtr<nsIDOMNSHTMLInputElement> inputElt = do_QueryInterface(content);
24447:   if (inputElt) {
24447:     PRBool indeterminate;
24447:     inputElt->GetIndeterminate(&indeterminate);
24447:     return indeterminate;
24447:   }
24447: 
24447:   return PR_FALSE;
24447: }
24447: 
24447: PRBool
    1: nsNativeTheme::IsWidgetStyled(nsPresContext* aPresContext, nsIFrame* aFrame,
    1:                               PRUint8 aWidgetType)
    1: {
    1:   // Check for specific widgets to see if HTML has overridden the style.
 6734:   return aFrame &&
 6734:          (aWidgetType == NS_THEME_BUTTON ||
    1:           aWidgetType == NS_THEME_TEXTFIELD ||
 1191:           aWidgetType == NS_THEME_TEXTFIELD_MULTILINE ||
 2686:           aWidgetType == NS_THEME_LISTBOX ||
 6734:           aWidgetType == NS_THEME_DROPDOWN) &&
 6734:          aFrame->GetContent()->IsNodeOfType(nsINode::eHTML) &&
14697:          aPresContext->HasAuthorSpecifiedRules(aFrame,
14697:                                                NS_AUTHOR_SPECIFIED_BORDER |
26801:                                                NS_AUTHOR_SPECIFIED_BACKGROUND);
    1: }
    1: 
22055: PRBool
22055: nsNativeTheme::IsFrameRTL(nsIFrame* aFrame)
22055: {
22055:   return aFrame && aFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
22055: }
22055: 
10223: // scrollbar button:
10223: PRInt32
10223: nsNativeTheme::GetScrollbarButtonType(nsIFrame* aFrame)
10223: {
10223:   if (!aFrame)
10223:     return 0;
10223: 
10223:   static nsIContent::AttrValuesArray strings[] =
10223:     {&nsWidgetAtoms::scrollbarDownBottom, &nsWidgetAtoms::scrollbarDownTop,
10223:      &nsWidgetAtoms::scrollbarUpBottom, &nsWidgetAtoms::scrollbarUpTop,
10223:      nsnull};
10223: 
10223:   switch (aFrame->GetContent()->FindAttrValueIn(kNameSpaceID_None,
10223:                                                 nsWidgetAtoms::sbattr,
10223:                                                 strings, eCaseMatters)) {
10223:     case 0: return eScrollbarButton_Down | eScrollbarButton_Bottom;
10223:     case 1: return eScrollbarButton_Down;
10223:     case 2: return eScrollbarButton_Bottom;
10223:     case 3: return eScrollbarButton_UpTop;
10223:   }
10223: 
10223:   return 0;
10223: }
10223: 
    1: // treeheadercell:
    1: nsNativeTheme::TreeSortDirection
    1: nsNativeTheme::GetTreeSortDirection(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return eTreeSortDirection_Natural;
    1: 
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsWidgetAtoms::descending, &nsWidgetAtoms::ascending, nsnull};
    1:   switch (aFrame->GetContent()->FindAttrValueIn(kNameSpaceID_None,
    1:                                                 nsWidgetAtoms::sortdirection,
    1:                                                 strings, eCaseMatters)) {
    1:     case 0: return eTreeSortDirection_Descending;
    1:     case 1: return eTreeSortDirection_Ascending;
    1:   }
    1: 
    1:   return eTreeSortDirection_Natural;
    1: }
    1: 
22055: PRBool
22055: nsNativeTheme::IsLastTreeHeaderCell(nsIFrame* aFrame)
22055: {
22055:   if (!aFrame)
22055:     return PR_FALSE;
22055: 
22055:   // A tree column picker is always the last header cell.
22055:   if (aFrame->GetContent()->Tag() == nsWidgetAtoms::treecolpicker)
22055:     return PR_TRUE;
22055: 
22055:   // Find the parent tree.
22055:   nsIContent* parent = aFrame->GetContent()->GetParent();
22055:   while (parent && parent->Tag() != nsWidgetAtoms::tree) {
22055:     parent = parent->GetParent();
22055:   }
22055: 
22055:   // If the column picker is visible, this can't be the last column.
22055:   if (parent && !parent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::hidecolumnpicker,
22055:                                      NS_LITERAL_STRING("true"), eCaseMatters))
22055:     return PR_FALSE;
22055: 
22055:   while ((aFrame = aFrame->GetNextSibling())) {
22055:     if (aFrame->GetRect().width > 0)
22055:       return PR_FALSE;
22055:   }
22055:   return PR_TRUE;
22055: }
22055: 
    1: // tab:
    1: PRBool
    1: nsNativeTheme::IsBottomTab(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
    1:   nsAutoString classStr;
    1:   aFrame->GetContent()->GetAttr(kNameSpaceID_None, nsWidgetAtoms::_class, classStr);
    1:   return !classStr.IsEmpty() && classStr.Find("tab-bottom") != kNotFound;
    1: }
    1: 
    1: PRBool
    1: nsNativeTheme::IsFirstTab(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
23267:   nsIFrame* first = aFrame->GetParent()->GetFirstChild(nsnull);
23267:   while (first) {
23267:     if (first->GetRect().width > 0 && first->GetContent()->Tag() == nsWidgetAtoms::tab)
23267:       return (first == aFrame);
23267:     first = first->GetNextSibling();
23267:   }
23267:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsNativeTheme::IsLastTab(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
23267:   while ((aFrame = aFrame->GetNextSibling())) {
23267:     if (aFrame->GetRect().width > 0 && aFrame->GetContent()->Tag() == nsWidgetAtoms::tab)
23267:       return PR_FALSE;
23267:   }
23267:   return PR_TRUE;
    1: }
    1: 
 9586: PRBool
 9586: nsNativeTheme::IsHorizontal(nsIFrame* aFrame)
 9586: {
 9586:   if (!aFrame)
 9586:     return PR_FALSE;
 9586:     
 9586:   return !aFrame->GetContent()->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::orient,
 9586:                                             nsWidgetAtoms::vertical, 
 9586:                                             eCaseMatters);
 9586: }
 9586: 
22056: PRBool
22056: nsNativeTheme::IsNextToSelectedTab(nsIFrame* aFrame, PRInt32 aOffset)
22056: {
22056:   if (!aFrame)
22056:     return PR_FALSE;
22056: 
22056:   if (aOffset == 0)
22056:     return IsSelectedTab(aFrame);
22056: 
22056:   PRInt32 thisTabIndex = -1, selectedTabIndex = -1;
22056: 
22056:   nsIFrame* currentTab = aFrame->GetParent()->GetFirstChild(NULL);
22056:   for (PRInt32 i = 0; currentTab; currentTab = currentTab->GetNextSibling()) {
22056:     if (currentTab->GetRect().width == 0)
22056:       continue;
22056:     if (aFrame == currentTab)
22056:       thisTabIndex = i;
22056:     if (IsSelectedTab(currentTab))
22056:       selectedTabIndex = i;
22056:     ++i;
22056:   }
22056: 
22056:   if (thisTabIndex == -1 || selectedTabIndex == -1)
22056:     return PR_FALSE;
22056: 
22056:   return (thisTabIndex - selectedTabIndex == aOffset);
22056: }
22056: 
    1: // progressbar:
    1: PRBool
    1: nsNativeTheme::IsIndeterminateProgress(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
    1:   return aFrame->GetContent()->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::mode,
    1:                                            NS_LITERAL_STRING("undetermined"),
    1:                                            eCaseMatters);
    1: }
23557: 
23557: // menupopup:
23557: PRBool
23557: nsNativeTheme::IsSubmenu(nsIFrame* aFrame, PRBool* aLeftOfParent)
23557: {
23557:   if (!aFrame)
23557:     return PR_FALSE;
23557: 
23557:   nsIContent* parentContent = aFrame->GetContent()->GetParent();
23557:   if (!parentContent || parentContent->Tag() != nsWidgetAtoms::menu)
23557:     return PR_FALSE;
23557: 
23557:   nsIFrame* parent = aFrame;
23557:   while ((parent = parent->GetParent())) {
23557:     if (parent->GetContent() == parentContent) {
23557:       if (aLeftOfParent) {
23738:         nsIntRect selfBounds, parentBounds;
23557:         aFrame->GetWindow()->GetScreenBounds(selfBounds);
23557:         parent->GetWindow()->GetScreenBounds(parentBounds);
23557:         *aLeftOfParent = selfBounds.x < parentBounds.x;
23557:       }
23557:       return PR_TRUE;
23557:     }
23557:   }
23557: 
23557:   return PR_FALSE;
23557: }
