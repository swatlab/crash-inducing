   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998-1999
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Pierre Phaneuf <pp@ludusdesign.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "PlaceholderTxn.h"
   1: #include "nsEditor.h"
   1: #include "IMETextTxn.h"
   1: 
   1: PlaceholderTxn::PlaceholderTxn() :  EditAggregateTxn(), 
   1:                                     mAbsorb(PR_TRUE), 
   1:                                     mForwarding(nsnull),
   1:                                     mIMETextTxn(nsnull),
   1:                                     mCommitted(PR_FALSE),
   1:                                     mStartSel(nsnull),
   1:                                     mEndSel(),
   1:                                     mEditor(nsnull)
   1: {
   1: }
   1: 
   1: 
   1: NS_IMPL_ISUPPORTS_INHERITED2(PlaceholderTxn, EditAggregateTxn,
   1:                              nsIAbsorbingTransaction, nsISupportsWeakReference)
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::Init(nsIAtom *aName, nsSelectionState *aSelState, nsIEditor *aEditor)
   1: {
   1:   if (!aEditor || !aSelState) return NS_ERROR_NULL_POINTER;
   1: 
   1:   mName = aName;
   1:   mStartSel = aSelState;
   1:   mEditor = aEditor;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::DoTransaction(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::UndoTransaction(void)
   1: {
   1:   // undo txns
   1:   nsresult res = EditAggregateTxn::UndoTransaction();
   1:   if (NS_FAILED(res)) return res;
   1:   
   1:   if (!mStartSel) return NS_ERROR_NULL_POINTER;
   1: 
   1:   // now restore selection
   1:   nsCOMPtr<nsISelection> selection;
   1:   res = mEditor->GetSelection(getter_AddRefs(selection));
   1:   if (NS_FAILED(res)) return res;
   1:   if (!selection) return NS_ERROR_NULL_POINTER;
   1:   return mStartSel->RestoreSelection(selection);
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::RedoTransaction(void)
   1: {
   1:   // redo txns
   1:   nsresult res = EditAggregateTxn::RedoTransaction();
   1:   if (NS_FAILED(res)) return res;
   1:   
   1:   // now restore selection
   1:   nsCOMPtr<nsISelection> selection;
   1:   res = mEditor->GetSelection(getter_AddRefs(selection));
   1:   if (NS_FAILED(res)) return res;
   1:   if (!selection) return NS_ERROR_NULL_POINTER;
   1:   return mEndSel.RestoreSelection(selection);
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::Merge(nsITransaction *aTransaction, PRBool *aDidMerge)
   1: {
   1:   if (!aDidMerge || !aTransaction) return NS_ERROR_NULL_POINTER;
   1: 
   1:   // set out param default value
   1:   *aDidMerge=PR_FALSE;
   1:     
   1:   if (mForwarding) 
   1:   {
   1:     NS_NOTREACHED("tried to merge into a placeholder that was in forwarding mode!");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   // check to see if aTransaction is one of the editor's
   1:   // private transactions. If not, we want to avoid merging
   1:   // the foreign transaction into our placeholder since we
   1:   // don't know what it does.
   1: 
   1:   nsCOMPtr<nsPIEditorTransaction> pTxn = do_QueryInterface(aTransaction);
   1:   if (!pTxn) return NS_OK; // it's foreign so just bail!
   1: 
   1:   EditTxn *editTxn = (EditTxn*)aTransaction;  //XXX: hack, not safe!  need nsIEditTransaction!
   1:   // determine if this incoming txn is a placeholder txn
   1:   nsCOMPtr<nsIAbsorbingTransaction> plcTxn;// = do_QueryInterface(editTxn);
   1:   // can't do_QueryInterface() above due to our broken transaction interfaces.
   1:   // instead have to brute it below. ugh. 
   1:   editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
   1: 
   1:   // we are absorbing all txn's if mAbsorb is lit.
   1:   if (mAbsorb)
   1:   { 
3030:     nsRefPtr<IMETextTxn> otherTxn;
3030:     if (NS_SUCCEEDED(aTransaction->QueryInterface(IMETextTxn::GetCID(), getter_AddRefs(otherTxn))) && otherTxn)
   1:     {
   1:       // special handling for IMETextTxn's: they need to merge with any previous
   1:       // IMETextTxn in this placeholder, if possible.
   1:       if (!mIMETextTxn) 
   1:       {
   1:         // this is the first IME txn in the placeholder
   1:         mIMETextTxn =otherTxn;
   1:         AppendChild(editTxn);
   1:       }
   1:       else  
   1:       {
   1:         PRBool didMerge;
   1:         mIMETextTxn->Merge(otherTxn, &didMerge);
   1:         if (!didMerge)
   1:         {
   1:           // it wouldn't merge.  Earlier IME txn is already commited and will 
   1:           // not absorb further IME txns.  So just stack this one after it
   1:           // and remember it as a candidate for further merges.
   1:           mIMETextTxn =otherTxn;
   1:           AppendChild(editTxn);
   1:         }
   1:       }
   1:     }
   1:     else if (!plcTxn)  // see bug 171243: just drop incoming placeholders on the floor.
   1:     {                  // their children will be swallowed by this preexisting one.
   1:       AppendChild(editTxn);
   1:     }
   1:     *aDidMerge = PR_TRUE;
   1: //  RememberEndingSelection();
   1: //  efficiency hack: no need to remember selection here, as we haven't yet 
   1: //  finished the inital batch and we know we will be told when the batch ends.
   1: //  we can remeber the selection then.
   1:   }
   1:   else
   1:   { // merge typing or IME or deletion transactions if the selection matches
   1:     if (((mName.get() == nsEditor::gTypingTxnName) ||
   1:          (mName.get() == nsEditor::gIMETxnName)    ||
   1:          (mName.get() == nsEditor::gDeleteTxnName)) 
   1:          && !mCommitted ) 
   1:     {
   1:       nsCOMPtr<nsIAbsorbingTransaction> plcTxn;// = do_QueryInterface(editTxn);
   1:       // can't do_QueryInterface() above due to our broken transaction interfaces.
   1:       // instead have to brute it below. ugh. 
   1:       editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
   1:       if (plcTxn)
   1:       {
   1:         nsCOMPtr<nsIAtom> atom;
   1:         plcTxn->GetTxnName(getter_AddRefs(atom));
   1:         if (atom && (atom == mName))
   1:         {
   1:           // check if start selection of next placeholder matches
   1:           // end selection of this placeholder
   1:           PRBool isSame;
   1:           plcTxn->StartSelectionEquals(&mEndSel, &isSame);
   1:           if (isSame)
   1:           {
   1:             mAbsorb = PR_TRUE;  // we need to start absorbing again
   1:             plcTxn->ForwardEndBatchTo(this);
   1:             // AppendChild(editTxn);
   1:             // see bug 171243: we don't need to merge placeholders
   1:             // into placeholders.  We just reactivate merging in the pre-existing
   1:             // placeholder and drop the new one on the floor.  The EndPlaceHolderBatch()
   1:             // call on the new placeholder will be forwarded to this older one.
   1:             RememberEndingSelection();
   1:             *aDidMerge = PR_TRUE;
   1:           }
   1:         }
   1:       }
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::GetTxnDescription(nsAString& aString)
   1: {
   1:   aString.AssignLiteral("PlaceholderTxn: ");
   1: 
   1:   if (mName)
   1:   {
   1:     nsAutoString name;
   1:     mName->ToString(name);
   1:     aString += name;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::GetTxnName(nsIAtom **aName)
   1: {
   1:   return GetName(aName);
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::StartSelectionEquals(nsSelectionState *aSelState, PRBool *aResult)
   1: {
   1:   // determine if starting selection matches the given selection state.
   1:   // note that we only care about collapsed selections.
   1:   if (!aResult || !aSelState) return NS_ERROR_NULL_POINTER;
   1:   if (!mStartSel->IsCollapsed() || !aSelState->IsCollapsed())
   1:   {
   1:     *aResult = PR_FALSE;
   1:     return NS_OK;
   1:   }
   1:   *aResult = mStartSel->IsEqual(aSelState);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::EndPlaceHolderBatch()
   1: {
   1:   mAbsorb = PR_FALSE;
   1:   
   1:   if (mForwarding) 
   1:   {
   1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryReferent(mForwarding);
   1:     if (plcTxn) plcTxn->EndPlaceHolderBatch();
   1:   }
   1:   
   1:   // remember our selection state.
   1:   return RememberEndingSelection();
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::ForwardEndBatchTo(nsIAbsorbingTransaction *aForwardingAddress)
   1: {   
   1:   mForwarding = do_GetWeakReference(aForwardingAddress);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::Commit()
   1: {
   1:   mCommitted = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP PlaceholderTxn::RememberEndingSelection()
   1: {
   1:   nsCOMPtr<nsISelection> selection;
   1:   nsresult res = mEditor->GetSelection(getter_AddRefs(selection));
   1:   if (NS_FAILED(res)) return res;
   1:   if (!selection) return NS_ERROR_NULL_POINTER;
   1:   return mEndSel.SaveSelection(selection);
   1: }
   1: 
