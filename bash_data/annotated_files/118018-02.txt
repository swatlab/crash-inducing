 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS number type and wrapper class.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: #include "mozilla/RangedPtr.h"
 95341: 
 95341: #include "double-conversion.h"
 95341: // Avoid warnings about ASSERT being defined by the assembler as well.
 95341: #undef ASSERT
 95341: 
 26750: #ifdef XP_OS2
 26750: #define _PC_53  PC_53
 26750: #define _MCW_EM MCW_EM
 26750: #define _MCW_PC MCW_PC
 26750: #endif
     1: #include <locale.h>
     1: #include <limits.h>
     1: #include <math.h>
     1: #include <stdlib.h>
     1: #include <string.h>
 74600: 
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsapi.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsdtoa.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
     1: #include "jsprf.h"
 12581: #include "jsscope.h"
     1: #include "jsstr.h"
 73082: #include "jslibmath.h"
 40901: 
 78912: #include "vm/GlobalObject.h"
 97045: #include "vm/NumericConversions.h"
 93300: #include "vm/StringBuffer.h"
 78912: 
 74908: #include "jsatominlines.h"
 77343: #include "jsinferinlines.h"
 72078: #include "jsnuminlines.h"
 40901: #include "jsobjinlines.h"
 40899: 
 78915: #include "vm/NumberObject-inl.h"
 72107: #include "vm/String-inl.h"
 72107: 
 39941: using namespace js;
 77343: using namespace js::types;
 32758: 
 48629: /*
 48629:  * If we're accumulating a decimal number and the number is >= 2^53, then the
 48629:  * fast result from the loop in GetPrefixInteger may be inaccurate. Call
 48629:  * js_strtod_harder to get the correct answer.
 48629:  */
 56593: static bool
 90955: ComputeAccurateDecimalInteger(JSContext *cx, const jschar *start, const jschar *end, double *dp)
 48629: {
 48629:     size_t length = end - start;
110934:     char *cstr = cx->pod_malloc<char>(length + 1);
 48629:     if (!cstr)
 48629:         return false;
 48629: 
 48629:     for (size_t i = 0; i < length; i++) {
 48629:         char c = char(start[i]);
 48629:         JS_ASSERT(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'));
 48629:         cstr[i] = c;
 48629:     }
 48629:     cstr[length] = 0;
 48629: 
 48629:     char *estr;
 48629:     int err = 0;
 88135:     *dp = js_strtod_harder(cx->runtime->dtoaState, cstr, &estr, &err);
 48629:     if (err == JS_DTOA_ENOMEM) {
 48629:         JS_ReportOutOfMemory(cx);
110933:         js_free(cstr);
 48629:         return false;
 48629:     }
 48629:     if (err == JS_DTOA_ERANGE && *dp == HUGE_VAL)
 48629:         *dp = js_PositiveInfinity;
110933:     js_free(cstr);
 48629:     return true;
 48629: }
 48629: 
 48629: class BinaryDigitReader
 48629: {
 48629:     const int base;      /* Base of number; must be a power of 2 */
 48629:     int digit;           /* Current digit value in radix given by base */
 48629:     int digitMask;       /* Mask to extract the next bit from digit */
 48629:     const jschar *start; /* Pointer to the remaining digits */
 48629:     const jschar *end;   /* Pointer to first non-digit */
 48629: 
 48629:   public:
 48629:     BinaryDigitReader(int base, const jschar *start, const jschar *end)
 48629:       : base(base), digit(0), digitMask(0), start(start), end(end)
 48629:     {
 48629:     }
 48629: 
 48629:     /* Return the next binary digit from the number, or -1 if done. */
 48629:     int nextDigit() {
 48629:         if (digitMask == 0) {
 48629:             if (start == end)
 48629:                 return -1;
 48629: 
 48629:             int c = *start++;
 48629:             JS_ASSERT(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'));
 48629:             if ('0' <= c && c <= '9')
 48629:                 digit = c - '0';
 48629:             else if ('a' <= c && c <= 'z')
 48629:                 digit = c - 'a' + 10;
 48629:             else
 48629:                 digit = c - 'A' + 10;
 48629:             digitMask = base >> 1;
 48629:         }
 48629: 
 48629:         int bit = (digit & digitMask) != 0;
 48629:         digitMask >>= 1;
 48629:         return bit;
 48629:     }
 48629: };
 48629: 
 48629: /*
 48629:  * The fast result might also have been inaccurate for power-of-two bases. This
 48629:  * happens if the addition in value * 2 + digit causes a round-down to an even
 48629:  * least significant mantissa bit when the first dropped bit is a one.  If any
 48629:  * of the following digits in the number (which haven't been added in yet) are
 48629:  * nonzero, then the correct action would have been to round up instead of
 48629:  * down.  An example occurs when reading the number 0x1000000000000081, which
 48629:  * rounds to 0x1000000000000000 instead of 0x1000000000000100.
 48629:  */
 90955: static double
115733: ComputeAccurateBinaryBaseInteger(const jschar *start, const jschar *end, int base)
 48629: {
 48629:     BinaryDigitReader bdr(base, start, end);
 48629: 
 48629:     /* Skip leading zeroes. */
 48629:     int bit;
 48629:     do {
 48629:         bit = bdr.nextDigit();
 48629:     } while (bit == 0);
 48629: 
 48629:     JS_ASSERT(bit == 1); // guaranteed by GetPrefixInteger
 48629: 
 48629:     /* Gather the 53 significant bits (including the leading 1). */
 90955:     double value = 1.0;
 48629:     for (int j = 52; j > 0; j--) {
 48629:         bit = bdr.nextDigit();
 48629:         if (bit < 0)
 48629:             return value;
 48629:         value = value * 2 + bit;
 48629:     }
 48629: 
 48629:     /* bit2 is the 54th bit (the first dropped from the mantissa). */
 48629:     int bit2 = bdr.nextDigit();
 48629:     if (bit2 >= 0) {
 90955:         double factor = 2.0;
 48629:         int sticky = 0;  /* sticky is 1 if any bit beyond the 54th is 1 */
 48629:         int bit3;
 48629: 
 48629:         while ((bit3 = bdr.nextDigit()) >= 0) {
 48629:             sticky |= bit3;
 48629:             factor *= 2;
 48629:         }
 48629:         value += bit2 & (bit | sticky);
 48629:         value *= factor;
 48629:     }
 48629: 
 48629:     return value;
 48629: }
 48629: 
 48629: namespace js {
 48629: 
 48629: bool
 48629: GetPrefixInteger(JSContext *cx, const jschar *start, const jschar *end, int base,
 90955:                  const jschar **endp, double *dp)
 48629: {
 48629:     JS_ASSERT(start <= end);
 48629:     JS_ASSERT(2 <= base && base <= 36);
 48629: 
 48629:     const jschar *s = start;
 90955:     double d = 0.0;
 48629:     for (; s < end; s++) {
 48629:         int digit;
 48629:         jschar c = *s;
 48629:         if ('0' <= c && c <= '9')
 48629:             digit = c - '0';
 48629:         else if ('a' <= c && c <= 'z')
 48629:             digit = c - 'a' + 10;
 48629:         else if ('A' <= c && c <= 'Z')
 48629:             digit = c - 'A' + 10;
 48629:         else
 48629:             break;
 48629:         if (digit >= base)
 48629:             break;
 48629:         d = d * base + digit;
 48629:     }
 48629: 
 48629:     *endp = s;
 48629:     *dp = d;
 48629: 
 48629:     /* If we haven't reached the limit of integer precision, we're done. */
 48629:     if (d < DOUBLE_INTEGRAL_PRECISION_LIMIT)
 48629:         return true;
 48629: 
 48629:     /*
 48629:      * Otherwise compute the correct integer from the prefix of valid digits
 48629:      * if we're computing for base ten or a power of two.  Don't worry about
 48629:      * other bases; see 15.1.2.2 step 13.
 48629:      */
 48629:     if (base == 10)
 48629:         return ComputeAccurateDecimalInteger(cx, start, s, dp);
 48629:     if ((base & (base - 1)) == 0)
115733:         *dp = ComputeAccurateBinaryBaseInteger(start, s, base);
 48629: 
 48629:     return true;
 48629: }
 48629: 
 48629: } // namespace js
 48629: 
     1: static JSBool
 91237: num_isNaN(JSContext *cx, unsigned argc, Value *vp)
     1: {
 16519:     if (argc == 0) {
 48470:         vp->setBoolean(true);
 16519:         return JS_TRUE;
 16519:     }
 90955:     double x;
 73894:     if (!ToNumber(cx, vp[2], &x))
 40828:         return false;
 95341:     vp->setBoolean(MOZ_DOUBLE_IS_NaN(x));
     1:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 91237: num_isFinite(JSContext *cx, unsigned argc, Value *vp)
     1: {
 16519:     if (argc == 0) {
 48470:         vp->setBoolean(false);
 16519:         return JS_TRUE;
 16519:     }
 90955:     double x;
 73894:     if (!ToNumber(cx, vp[2], &x))
     1:         return JS_FALSE;
 95341:     vp->setBoolean(MOZ_DOUBLE_IS_FINITE(x));
     1:     return JS_TRUE;
     1: }
     1: 
 20408: static JSBool
 91237: num_parseFloat(JSContext *cx, unsigned argc, Value *vp)
     1: {
     1:     JSString *str;
 90955:     double d;
  4718:     const jschar *bp, *end, *ep;
     1: 
 16519:     if (argc == 0) {
 48470:         vp->setDouble(js_NaN);
 16519:         return JS_TRUE;
 16519:     }
 84160:     str = ToString(cx, vp[2]);
     1:     if (!str)
     1:         return JS_FALSE;
 59890:     bp = str->getChars(cx);
 59890:     if (!bp)
 59890:         return JS_FALSE;
 59890:     end = bp + str->length();
  4718:     if (!js_strtod(cx, bp, end, &ep, &d))
     1:         return JS_FALSE;
     1:     if (ep == bp) {
 48470:         vp->setDouble(js_NaN);
     1:         return JS_TRUE;
     1:     }
 48470:     vp->setNumber(d);
 48470:     return JS_TRUE;
     1: }
     1: 
 56593: static bool
 53297: ParseIntStringHelper(JSContext *cx, const jschar *ws, const jschar *end, int maybeRadix,
 90955:                      bool stripPrefix, double *dp)
 48629: {
 48640:     JS_ASSERT(maybeRadix == 0 || (2 <= maybeRadix && maybeRadix <= 36));
 48629:     JS_ASSERT(ws <= end);
 48629: 
 74434:     const jschar *s = SkipSpace(ws, end);
 48629:     JS_ASSERT(ws <= s);
 48629:     JS_ASSERT(s <= end);
 48629: 
 48629:     /* 15.1.2.2 steps 3-4. */
 48629:     bool negative = (s != end && s[0] == '-');
 48629: 
 48629:     /* 15.1.2.2 step 5. */
 48629:     if (s != end && (s[0] == '-' || s[0] == '+'))
 48629:         s++;
 48629: 
 48640:     /* 15.1.2.2 step 9. */
 48640:     int radix = maybeRadix;
 48640:     if (radix == 0) {
 48640:         if (end - s >= 2 && s[0] == '0' && (s[1] != 'x' && s[1] != 'X')) {
 48640:             /*
 48640:              * Non-standard: ES5 requires that parseInt interpret leading-zero
 48640:              * strings not starting with "0x" or "0X" as decimal (absent an
 48640:              * explicitly specified non-zero radix), but we continue to
 48809:              * interpret such strings as octal, as per ES3 and web practice.
 48640:              */
 48809:             radix = 8;
 48640:         } else {
 48640:             radix = 10;
 48640:         }
 48640:     }
 48640: 
 48629:     /* 15.1.2.2 step 10. */
 48629:     if (stripPrefix) {
 48640:         if (end - s >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
 48629:             s += 2;
 48629:             radix = 16;
 48629:         }
 48629:     }
 48629: 
 48629:     /* 15.1.2.2 steps 11-14. */
 48629:     const jschar *actualEnd;
 48629:     if (!GetPrefixInteger(cx, s, end, radix, &actualEnd, dp))
 48629:         return false;
 48629:     if (s == actualEnd)
 48629:         *dp = js_NaN;
 48629:     else if (negative)
 48629:         *dp = -*dp;
 48629:     return true;
 48629: }
 48629: 
     1: /* See ECMA 15.1.2.2. */
 86581: JSBool
 91237: js::num_parseInt(JSContext *cx, unsigned argc, Value *vp)
     1: {
 84053:     CallArgs args = CallArgsFromVp(argc, vp);
 84053: 
 48629:     /* Fast paths and exceptional cases. */
 84053:     if (args.length() == 0) {
 84053:         args.rval().setDouble(js_NaN);
 48629:         return true;
 16519:     }
 48629: 
 84053:     if (args.length() == 1 ||
 84053:         (args[1].isInt32() && (args[1].toInt32() == 0 || args[1].toInt32() == 10))) {
 84053:         if (args[0].isInt32()) {
106862:             args.rval().set(args[0]);
 48629:             return true;
 48629:         }
 69653:         /*
 69653:          * Step 1 is |inputString = ToString(string)|. When string >=
 69653:          * 1e21, ToString(string) is in the form "NeM". 'e' marks the end of
 69653:          * the word, which would mean the result of parseInt(string) should be |N|.
 69653:          *
 69653:          * To preserve this behaviour, we can't use the fast-path when string >
 69653:          * 1e21, or else the result would be |NeM|.
 84053:          *
 84053:          * The same goes for values smaller than 1.0e-6, because the string would be in
 84053:          * the form of "Ne-M".
 69653:          */
 84053:         if (args[0].isDouble()) {
 84053:             double d = args[0].toDouble();
 84053:             if (1.0e-6 < d && d < 1.0e21) {
 84053:                 args.rval().setNumber(floor(d));
 48629:                 return true;
 48629:             }
 84053:             if (-1.0e21 < d && d < -1.0e-6) {
 84053:                 args.rval().setNumber(-floor(-d));
 84053:                 return true;
 84053:             }
 84053:             if (d == 0.0) {
 84053:                 args.rval().setInt32(0);
 84053:                 return true;
 84053:             }
 84053:         }
 48629:     }
 48629: 
 48629:     /* Step 1. */
107557:     RootedString inputString(cx, ToString(cx, args[0]));
 48629:     if (!inputString)
 48629:         return false;
 84053:     args[0].setString(inputString);
 48629: 
 48640:     /* 15.1.2.2 steps 6-8. */
 48629:     bool stripPrefix = true;
 84755:     int32_t radix = 0;
 84053:     if (args.length() > 1) {
 84161:         if (!ToInt32(cx, args[1], &radix))
 48629:             return false;
 48629:         if (radix != 0) {
 48629:             if (radix < 2 || radix > 36) {
 84053:                 args.rval().setDouble(js_NaN);
 48629:                 return true;
 48629:             }
 48629:             if (radix != 16)
 48629:                 stripPrefix = false;
     1:         }
     1:     }
     1: 
 48640:     /* Steps 2-5, 9-14. */
 59890:     const jschar *ws = inputString->getChars(cx);
 59890:     if (!ws)
 59890:         return false;
 59890:     const jschar *end = ws + inputString->length();
 12605: 
 90955:     double number;
 48629:     if (!ParseIntStringHelper(cx, ws, end, radix, stripPrefix, &number))
 48629:         return false;
 48629: 
 48629:     /* Step 15. */
 84053:     args.rval().setNumber(number);
 48629:     return true;
     1: }
     1: 
     1: static JSFunctionSpec number_functions[] = {
 16519:     JS_FN(js_isNaN_str,         num_isNaN,           1,0),
 16519:     JS_FN(js_isFinite_str,      num_isFinite,        1,0),
 82643:     JS_FN(js_parseFloat_str,    num_parseFloat,      1,0),
 82643:     JS_FN(js_parseInt_str,      num_parseInt,        2,0),
  4127:     JS_FS_END
     1: };
     1: 
 77817: Class js::NumberClass = {
     1:     js_Number_str,
 31452:     JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_HAS_CACHED_PROTO(JSProto_Number),
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub
     1: };
     1: 
     1: static JSBool
 91237: Number(JSContext *cx, unsigned argc, Value *vp)
     1: {
 53557:     /* Sample JS_CALLEE before clobbering. */
 53557:     bool isConstructing = IsConstructing(vp);
 53557: 
 53557:     if (argc > 0) {
 73894:         if (!ToNumber(cx, &vp[2]))
 53557:             return false;
 53557:         vp[0] = vp[2];
 12850:     } else {
 53557:         vp[0].setInt32(0);
 12850:     }
 53557: 
 53557:     if (!isConstructing)
 53557:         return true;
 53557: 
 90338:     JSObject *obj = NumberObject::create(cx, vp[0].toNumber());
 53557:     if (!obj)
 53557:         return false;
 53557:     vp->setObject(*obj);
 31452:     return true;
     1: }
     1: 
108554: JS_ALWAYS_INLINE bool
105479: IsNumber(const Value &v)
105479: {
105479:     return v.isNumber() || (v.isObject() && v.toObject().hasClass(&NumberClass));
105479: }
105479: 
105479: inline double
105479: Extract(const Value &v)
105479: {
105479:     if (v.isNumber())
105479:         return v.toNumber();
105479:     return v.toObject().asNumber().unbox();
105479: }
105479: 
     1: #if JS_HAS_TOSOURCE
108554: JS_ALWAYS_INLINE bool
105479: num_toSource_impl(JSContext *cx, CallArgs args)
     1: {
105479:     double d = Extract(args.thisv());
     1: 
 84052:     StringBuffer sb(cx);
105479:     if (!sb.append("(new Number(") ||
105479:         !NumberValueToStringBuffer(cx, NumberValue(d), sb) ||
 84052:         !sb.append("))"))
 84052:     {
 55711:         return false;
     1:     }
 55711: 
 84052:     JSString *str = sb.finishString();
     1:     if (!str)
 55711:         return false;
 79387:     args.rval().setString(str);
 55711:     return true;
     1: }
105479: 
105479: static JSBool
105479: num_toSource(JSContext *cx, unsigned argc, Value *vp)
105479: {
105479:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_toSource_impl>(cx, args);
105479: }
     1: #endif
     1: 
 53852: ToCStringBuf::ToCStringBuf() :dbuf(NULL)
 53852: {
 53852:     JS_STATIC_ASSERT(sbufSize >= DTOSTR_STANDARD_BUFFER_SIZE);
 53852: }
 53852: 
 53852: ToCStringBuf::~ToCStringBuf()
 53852: {
 53852:     if (dbuf)
110933:         js_free(dbuf);
 53852: }
 53852: 
114424: JSFlatString *
102228: js::Int32ToString(JSContext *cx, int32_t si)
 57735: {
 84755:     uint32_t ui;
 57735:     if (si >= 0) {
 78537:         if (StaticStrings::hasInt(si))
 78537:             return cx->runtime->staticStrings.getInt(si);
 57735:         ui = si;
 57735:     } else {
 84755:         ui = uint32_t(-si);
 84755:         JS_ASSERT_IF(si == INT32_MIN, ui == uint32_t(INT32_MAX) + 1);
 57735:     }
 57735: 
 61432:     JSCompartment *c = cx->compartment;
114424:     if (JSFlatString *str = c->dtoaCache.lookup(10, si))
 61432:         return str;
 57735: 
 57735:     JSShortString *str = js_NewGCShortString(cx);
 57735:     if (!str)
 57735:         return NULL;
 57735: 
110550:     jschar buffer[JSShortString::MAX_SHORT_LENGTH + 1];
110550:     RangedPtr<jschar> end(buffer + JSShortString::MAX_SHORT_LENGTH,
110550:                           buffer, JSShortString::MAX_SHORT_LENGTH + 1);
 74908:     *end = '\0';
 74908:     RangedPtr<jschar> start = BackfillIndexInCharBuffer(ui, end);
 57735:     if (si < 0)
 74908:         *--start = '-';
 57735: 
110550:     jschar *dst = str->init(end - start);
110550:     PodCopy(dst, start.get(), end - start + 1);
 57735: 
 64345:     c->dtoaCache.cache(10, si, str);
 64345:     return str;
 57735: }
 57735: 
 53852: /* Returns a non-NULL pointer to inside cbuf.  */
 23700: static char *
 91450: IntToCString(ToCStringBuf *cbuf, int i, int base = 10)
     1: {
 91612:     unsigned u = (i < 0) ? -i : i;
     1: 
 74908:     RangedPtr<char> cp(cbuf->sbuf + cbuf->sbufSize - 1, cbuf->sbuf, cbuf->sbufSize);
 74908:     *cp = '\0';
     1: 
 74908:     /* Build the string from behind. */
 20898:     switch (base) {
 20898:     case 10:
 74908:       cp = BackfillIndexInCharBuffer(u, cp);
 20898:       break;
 20898:     case 16:
 20898:       do {
 91612:           unsigned newu = u / 16;
 20898:           *--cp = "0123456789abcdef"[u - newu * 16];
 20898:           u = newu;
 20898:       } while (u != 0);
 20898:       break;
 20898:     default:
 20898:       JS_ASSERT(base >= 2 && base <= 36);
 20898:       do {
 91612:           unsigned newu = u / base;
 20898:           *--cp = "0123456789abcdefghijklmnopqrstuvwxyz"[u - newu * base];
 20898:           u = newu;
 20898:       } while (u != 0);
 20898:       break;
 20898:     }
     1:     if (i < 0)
     1:         *--cp = '-';
     1: 
 74908:     return cp.get();
     1: }
     1: 
 33937: static JSString * JS_FASTCALL
 91450: js_NumberToStringWithBase(JSContext *cx, double d, int base);
 33937: 
108554: JS_ALWAYS_INLINE bool
105479: num_toString_impl(JSContext *cx, CallArgs args)
     1: {
105479:     JS_ASSERT(IsNumber(args.thisv()));
 79387: 
105479:     double d = Extract(args.thisv());
 55711: 
 84755:     int32_t base = 10;
 91388:     if (args.hasDefined(0)) {
 90955:         double d2;
 79387:         if (!ToInteger(cx, args[0], &d2))
 69230:             return false;
 40828: 
 69230:         if (d2 < 2 || d2 > 36) {
 69230:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_RADIX);
 69230:             return false;
     1:         }
 69230: 
 84755:         base = int32_t(d2);
     1:     }
 48470:     JSString *str = js_NumberToStringWithBase(cx, d, base);
 33937:     if (!str) {
     1:         JS_ReportOutOfMemory(cx);
 79779:         return false;
     1:     }
 79387:     args.rval().setString(str);
 79779:     return true;
 79779: }
 79779: 
 79779: static JSBool
105479: num_toString(JSContext *cx, unsigned argc, Value *vp)
 79779: {
104198:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_toString_impl>(cx, args);
105479: }
104198: 
108554: JS_ALWAYS_INLINE bool
105479: num_toLocaleString_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsNumber(args.thisv()));
105479: 
105479:     double d = Extract(args.thisv());
104198: 
104198:     Rooted<JSString*> str(cx, js_NumberToStringWithBase(cx, d, 10));
104198:     if (!str) {
104198:         JS_ReportOutOfMemory(cx);
104198:         return false;
     1:     }
     1: 
     1:     /*
     1:      * Create the string, move back to bytes to make string twiddling
     1:      * a bit easier and so we can insert platform charset seperators.
     1:      */
104198:     JSAutoByteString numBytes(cx, str);
 57812:     if (!numBytes)
104197:         return false;
104197:     const char *num = numBytes.ptr();
     1:     if (!num)
104197:         return false;
     1: 
 16181:     /*
 16181:      * Find the first non-integer value, whether it be a letter as in
 16183:      * 'Infinity', a decimal point, or an 'e' from exponential notation.
 16181:      */
104197:     const char *nint = num;
 16181:     if (*nint == '-')
 16181:         nint++;
 16181:     while (*nint >= '0' && *nint <= '9')
 16181:         nint++;
104197:     int digits = nint - num;
104197:     const char *end = num + digits;
104198:     if (!digits) {
106862:         args.rval().setString(str);
104197:         return true;
104198:     }
     1: 
104197:     JSRuntime *rt = cx->runtime;
104197:     size_t thousandsLength = strlen(rt->thousandsSeparator);
104197:     size_t decimalLength = strlen(rt->decimalSeparator);
     1: 
     1:     /* Figure out how long resulting string will be. */
104197:     int buflen = strlen(num);
 16181:     if (*nint == '.')
 59978:         buflen += decimalLength - 1; /* -1 to account for existing '.' */
     1: 
104197:     const char *numGrouping;
104197:     const char *tmpGroup;
     1:     numGrouping = tmpGroup = rt->numGrouping;
104197:     int remainder = digits;
     1:     if (*num == '-')
     1:         remainder--;
     1: 
     1:     while (*tmpGroup != CHAR_MAX && *tmpGroup != '\0') {
     1:         if (*tmpGroup >= remainder)
     1:             break;
 59918:         buflen += thousandsLength;
     1:         remainder -= *tmpGroup;
     1:         tmpGroup++;
     1:     }
104197: 
104197:     int nrepeat;
     1:     if (*tmpGroup == '\0' && *numGrouping != '\0') {
     1:         nrepeat = (remainder - 1) / tmpGroup[-1];
 59918:         buflen += thousandsLength * nrepeat;
     1:         remainder -= nrepeat * tmpGroup[-1];
     1:     } else {
     1:         nrepeat = 0;
     1:     }
     1:     tmpGroup--;
     1: 
110934:     char *buf = cx->pod_malloc<char>(buflen + 1);
     1:     if (!buf)
104197:         return false;
     1: 
104197:     char *tmpDest = buf;
104197:     const char *tmpSrc = num;
     1: 
 59978:     while (*tmpSrc == '-' || remainder--) {
 59978:         JS_ASSERT(tmpDest - buf < buflen);
     1:         *tmpDest++ = *tmpSrc++;
 59978:     }
     1:     while (tmpSrc < end) {
 59978:         JS_ASSERT(tmpDest - buf + ptrdiff_t(thousandsLength) <= buflen);
     1:         strcpy(tmpDest, rt->thousandsSeparator);
     1:         tmpDest += thousandsLength;
 59978:         JS_ASSERT(tmpDest - buf + *tmpGroup <= buflen);
 87623:         js_memcpy(tmpDest, tmpSrc, *tmpGroup);
     1:         tmpDest += *tmpGroup;
     1:         tmpSrc += *tmpGroup;
     1:         if (--nrepeat < 0)
     1:             tmpGroup--;
     1:     }
     1: 
 16181:     if (*nint == '.') {
 59978:         JS_ASSERT(tmpDest - buf + ptrdiff_t(decimalLength) <= buflen);
     1:         strcpy(tmpDest, rt->decimalSeparator);
     1:         tmpDest += decimalLength;
 59978:         JS_ASSERT(tmpDest - buf + ptrdiff_t(strlen(nint + 1)) <= buflen);
 16181:         strcpy(tmpDest, nint + 1);
     1:     } else {
 59978:         JS_ASSERT(tmpDest - buf + ptrdiff_t(strlen(nint)) <= buflen);
 16181:         strcpy(tmpDest, nint);
     1:     }
     1: 
 59027:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUnicode) {
104198:         Rooted<Value> v(cx, StringValue(str));
104198:         bool ok = !!cx->localeCallbacks->localeToUnicode(cx, buf, v.address());
104198:         if (ok)
106862:             args.rval().set(v);
110933:         js_free(buf);
 59027:         return ok;
 59027:     }
     1: 
104198:     str = js_NewStringCopyN(cx, buf, buflen);
110933:     js_free(buf);
 58975:     if (!str)
104197:         return false;
     1: 
106862:     args.rval().setString(str);
104197:     return true;
     1: }
     1: 
108554: JSBool
105479: num_toLocaleString(JSContext *cx, unsigned argc, Value *vp)
105479: {
105479:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_toLocaleString_impl>(cx, args);
105479: }
105479: 
108554: JS_ALWAYS_INLINE bool
105479: num_valueOf_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsNumber(args.thisv()));
105479:     args.rval().setNumber(Extract(args.thisv()));
105479:     return true;
105479: }
105479: 
 56216: JSBool
 91237: js_num_valueOf(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79387:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_valueOf_impl>(cx, args);
     1: }
     1: 
104196: const unsigned MAX_PRECISION = 100;
     1: 
104196: static bool
104196: ComputePrecisionInRange(JSContext *cx, int minPrecision, int maxPrecision, const Value &v,
104196:                         int *precision)
     1: {
104196:     double prec;
104196:     if (!ToInteger(cx, v, &prec))
 69230:         return false;
104196:     if (minPrecision <= prec && prec <= maxPrecision) {
104196:         *precision = int(prec);
104196:         return true;
104196:     }
116051: 
 53852:     ToCStringBuf cbuf;
116051:     if (char *numStr = NumberToCString(cx, &cbuf, prec, 10))
     1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_PRECISION_RANGE, numStr);
104196:     return false;
     1: }
     1: 
104196: static bool
104196: DToStrResult(JSContext *cx, double d, JSDToStrMode mode, int precision, CallArgs args)
104196: {
104196:     char buf[DTOSTR_VARIABLE_BUFFER_SIZE(MAX_PRECISION + 1)];
104196:     char *numStr = js_dtostr(cx->runtime->dtoaState, buf, sizeof buf, mode, precision, d);
     1:     if (!numStr) {
     1:         JS_ReportOutOfMemory(cx);
104196:         return false;
     1:     }
 48563:     JSString *str = js_NewStringCopyZ(cx, numStr);
     1:     if (!str)
104196:         return false;
106862:     args.rval().setString(str);
104196:     return true;
     1: }
     1: 
  4127: /*
  4127:  * In the following three implementations, we allow a larger range of precision
  4127:  * than ECMA requires; this is permitted by ECMA-262.
  4127:  */
108554: JS_ALWAYS_INLINE bool
105479: num_toFixed_impl(JSContext *cx, CallArgs args)
     1: {
105479:     JS_ASSERT(IsNumber(args.thisv()));
104196: 
104196:     int precision;
104196:     if (args.length() == 0) {
104196:         precision = 0;
104196:     } else {
104196:         if (!ComputePrecisionInRange(cx, -20, MAX_PRECISION, args[0], &precision))
104196:             return false;
104196:     }
104196: 
105479:     return DToStrResult(cx, Extract(args.thisv()), DTOSTR_FIXED, precision, args);
     1: }
     1: 
108554: JSBool
105479: num_toFixed(JSContext *cx, unsigned argc, Value *vp)
     1: {
104196:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_toFixed_impl>(cx, args);
105479: }
104196: 
108554: JS_ALWAYS_INLINE bool
105479: num_toExponential_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsNumber(args.thisv()));
104196: 
104196:     JSDToStrMode mode;
104196:     int precision;
104196:     if (args.length() == 0) {
104196:         mode = DTOSTR_STANDARD_EXPONENTIAL;
104196:         precision = 0;
104196:     } else {
104196:         mode = DTOSTR_EXPONENTIAL;
104196:         if (!ComputePrecisionInRange(cx, 0, MAX_PRECISION, args[0], &precision))
104196:             return false;
104196:     }
104196: 
105479:     return DToStrResult(cx, Extract(args.thisv()), mode, precision + 1, args);
     1: }
     1: 
108554: JSBool
105479: num_toExponential(JSContext *cx, unsigned argc, Value *vp)
     1: {
 91388:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_toExponential_impl>(cx, args);
105479: }
104196: 
108554: JS_ALWAYS_INLINE bool
105479: num_toPrecision_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsNumber(args.thisv()));
105479: 
105479:     double d = Extract(args.thisv());
104196: 
104196:     if (!args.hasDefined(0)) {
104196:         JSString *str = js_NumberToStringWithBase(cx, d, 10);
104196:         if (!str) {
104196:             JS_ReportOutOfMemory(cx);
104196:             return false;
104196:         }
104196:         args.rval().setString(str);
104196:         return true;
104196:     }
104196: 
104196:     JSDToStrMode mode;
104196:     int precision;
104196:     if (args.length() == 0) {
104196:         mode = DTOSTR_STANDARD;
104196:         precision = 0;
104196:     } else {
104196:         mode = DTOSTR_PRECISION;
104196:         if (!ComputePrecisionInRange(cx, 1, MAX_PRECISION, args[0], &precision))
104196:             return false;
104196:     }
104196: 
104196:     return DToStrResult(cx, d, mode, precision, args);
     1: }
     1: 
108554: JSBool
105479: num_toPrecision(JSContext *cx, unsigned argc, Value *vp)
105479: {
105479:     CallArgs args = CallArgsFromVp(argc, vp);
108554:     return CallNonGenericMethod<IsNumber, num_toPrecision_impl>(cx, args);
105479: }
105479: 
     1: static JSFunctionSpec number_methods[] = {
     1: #if JS_HAS_TOSOURCE
 59941:     JS_FN(js_toSource_str,       num_toSource,          0, 0),
     1: #endif
 82643:     JS_FN(js_toString_str,       num_toString,          1, 0),
 59941:     JS_FN(js_toLocaleString_str, num_toLocaleString,    0, 0),
 59941:     JS_FN(js_valueOf_str,        js_num_valueOf,        0, 0),
 59941:     JS_FN("toFixed",             num_toFixed,           1, 0),
 59941:     JS_FN("toExponential",       num_toExponential,     1, 0),
 59941:     JS_FN("toPrecision",         num_toPrecision,       1, 0),
  4127:     JS_FS_END
     1: };
     1: 
100155: 
100155: // ES6 draft ES6 15.7.3.10
100155: static JSBool
100155: Number_isNaN(JSContext *cx, unsigned argc, Value *vp)
100155: {
100155:     CallArgs args = CallArgsFromVp(argc, vp);
100155:     if (args.length() < 1 || !args[0].isDouble()) {
100155:         args.rval().setBoolean(false);
100155:         return true;
100155:     }
100155:     args.rval().setBoolean(MOZ_DOUBLE_IS_NaN(args[0].toDouble()));
100155:     return true;
100155: }
100155: 
101311: // ES6 draft ES6 15.7.3.11
101311: static JSBool
101311: Number_isFinite(JSContext *cx, unsigned argc, Value *vp)
101311: {
101311:     CallArgs args = CallArgsFromVp(argc, vp);
101311:     if (args.length() < 1 || !args[0].isNumber()) {
101311:         args.rval().setBoolean(false);
101311:         return true;
101311:     }
101311:     args.rval().setBoolean(args[0].isInt32() ||
101311:                            MOZ_DOUBLE_IS_FINITE(args[0].toDouble()));
101311:     return true;
101311: }
101311: 
101312: // ES6 draft ES6 15.7.3.12
101312: static JSBool
101312: Number_isInteger(JSContext *cx, unsigned argc, Value *vp)
101312: {
101312:     CallArgs args = CallArgsFromVp(argc, vp);
101312:     if (args.length() < 1 || !args[0].isNumber()) {
101312:         args.rval().setBoolean(false);
101312:         return true;
101312:     }
101312:     Value val = args[0];
101312:     args.rval().setBoolean(val.isInt32() ||
101312:                            (MOZ_DOUBLE_IS_FINITE(val.toDouble()) &&
101312:                             ToInteger(val.toDouble()) == val.toDouble()));
101312:     return true;
101312: }
101312: 
101312: // ES6 drafult ES6 15.7.3.13
101312: static JSBool
101312: Number_toInteger(JSContext *cx, unsigned argc, Value *vp)
101312: {
101312:     CallArgs args = CallArgsFromVp(argc, vp);
101312:     if (args.length() < 1) {
101312:         args.rval().setInt32(0);
101312:         return true;
101312:     }
101312:     double asint;
101312:     if (!ToInteger(cx, args[0], &asint))
101312:         return false;
101312:     args.rval().setNumber(asint);
101312:     return true;
101312: }
101312: 
100155: 
100155: static JSFunctionSpec number_static_methods[] = {
101311:     JS_FN("isFinite", Number_isFinite, 1, 0),
101312:     JS_FN("isInteger", Number_isInteger, 1, 0),
100155:     JS_FN("isNaN", Number_isNaN, 1, 0),
101312:     JS_FN("toInteger", Number_toInteger, 1, 0),
100155:     JS_FS_END
100155: };
100155: 
100155: 
     1: /* NB: Keep this in synch with number_constants[]. */
     1: enum nc_slot {
     1:     NC_NaN,
     1:     NC_POSITIVE_INFINITY,
     1:     NC_NEGATIVE_INFINITY,
     1:     NC_MAX_VALUE,
     1:     NC_MIN_VALUE,
     1:     NC_LIMIT
     1: };
     1: 
     1: /*
     1:  * Some to most C compilers forbid spelling these at compile time, or barf
 72090:  * if you try, so all but MAX_VALUE are set up by InitRuntimeNumberState
     1:  * using union jsdpun.
     1:  */
     1: static JSConstDoubleSpec number_constants[] = {
 93382:     {0,                         "NaN",               0,{0,0,0}},
     1:     {0,                         "POSITIVE_INFINITY", 0,{0,0,0}},
     1:     {0,                         "NEGATIVE_INFINITY", 0,{0,0,0}},
     1:     {1.7976931348623157E+308,   "MAX_VALUE",         0,{0,0,0}},
     1:     {0,                         "MIN_VALUE",         0,{0,0,0}},
     1:     {0,0,0,{0,0,0}}
     1: };
     1: 
 90955: double js_NaN;
 90955: double js_PositiveInfinity;
 90955: double js_NegativeInfinity;
 32599: 
 39733: #if (defined __GNUC__ && defined __i386__) || \
 39733:     (defined __SUNPRO_CC && defined __i386)
     1: 
     1: /*
     1:  * Set the exception mask to mask all exceptions and set the FPU precision
 32599:  * to 53 bit mantissa (64 bit doubles).
     1:  */
 32599: inline void FIX_FPU() {
 32599:     short control;
 32599:     asm("fstcw %0" : "=m" (control) : );
 32599:     control &= ~0x300; // Lower bits 8 and 9 (precision control).
 32599:     control |= 0x2f3;  // Raise bits 0-5 (exception masks) and 9 (64-bit precision).
 32599:     asm("fldcw %0" : : "m" (control) );
 32599: }
     1: 
     1: #else
     1: 
     1: #define FIX_FPU() ((void)0)
     1: 
     1: #endif
     1: 
 72090: namespace js {
 72090: 
 72090: bool
 72090: InitRuntimeNumberState(JSRuntime *rt)
     1: {
     1:     FIX_FPU();
     1: 
 95341:     double d;
     1: 
 95341:     /*
 95341:      * Our NaN must be one particular canonical value, because we rely on NaN
 95341:      * encoding for our value representation.  See jsval.h.
 95341:      */
 95341:     d = MOZ_DOUBLE_SPECIFIC_NaN(0, 0x8000000000000ULL);
 95341:     number_constants[NC_NaN].dval = js_NaN = d;
 95341:     rt->NaNValue.setDouble(d);
     1: 
 95341:     d = MOZ_DOUBLE_POSITIVE_INFINITY();
 95341:     number_constants[NC_POSITIVE_INFINITY].dval = js_PositiveInfinity = d;
 95341:     rt->positiveInfinityValue.setDouble(d);
     1: 
 95341:     d = MOZ_DOUBLE_NEGATIVE_INFINITY();
 95341:     number_constants[NC_NEGATIVE_INFINITY].dval = js_NegativeInfinity = d;
 95341:     rt->negativeInfinityValue.setDouble(d);
 95341: 
 95341:     number_constants[NC_MIN_VALUE].dval = MOZ_DOUBLE_MIN_VALUE();
     1: 
 72090:     /* Copy locale-specific separators into the runtime strings. */
 72090:     const char *thousandsSeparator, *decimalPoint, *grouping;
 72090: #ifdef HAVE_LOCALECONV
 72090:     struct lconv *locale = localeconv();
 72090:     thousandsSeparator = locale->thousands_sep;
 72090:     decimalPoint = locale->decimal_point;
 72090:     grouping = locale->grouping;
 72090: #else
 72090:     thousandsSeparator = getenv("LOCALE_THOUSANDS_SEP");
 72090:     decimalPoint = getenv("LOCALE_DECIMAL_POINT");
 72090:     grouping = getenv("LOCALE_GROUPING");
 72090: #endif
 72090:     if (!thousandsSeparator)
 72090:         thousandsSeparator = "'";
 72090:     if (!decimalPoint)
 72090:         decimalPoint = ".";
 72090:     if (!grouping)
 72090:         grouping = "\3\0";
 59872: 
 72090:     /*
 72090:      * We use single malloc to get the memory for all separator and grouping
 72090:      * strings.
 72090:      */
 72090:     size_t thousandsSeparatorSize = strlen(thousandsSeparator) + 1;
 72090:     size_t decimalPointSize = strlen(decimalPoint) + 1;
 72090:     size_t groupingSize = strlen(grouping) + 1;
     1: 
110934:     char *storage = js_pod_malloc<char>(thousandsSeparatorSize +
 72090:                                         decimalPointSize +
110934:                                         groupingSize);
 72090:     if (!storage)
 72090:         return false;
 72090: 
 87623:     js_memcpy(storage, thousandsSeparator, thousandsSeparatorSize);
 72090:     rt->thousandsSeparator = storage;
 72090:     storage += thousandsSeparatorSize;
 72090: 
 87623:     js_memcpy(storage, decimalPoint, decimalPointSize);
 72090:     rt->decimalSeparator = storage;
 72090:     storage += decimalPointSize;
 72090: 
 87623:     js_memcpy(storage, grouping, groupingSize);
 72090:     rt->numGrouping = grouping;
 72090:     return true;
     1: }
     1: 
     1: void
 72090: FinishRuntimeNumberState(JSRuntime *rt)
     1: {
 72090:     /*
 72090:      * The free also releases the memory for decimalSeparator and numGrouping
 72090:      * strings.
 72090:      */
 72090:     char *storage = const_cast<char *>(rt->thousandsSeparator);
110933:     js_free(storage);
 72090: }
     1: 
 72090: } /* namespace js */
     1: 
     1: JSObject *
114748: js_InitNumberClass(JSContext *cx, HandleObject obj)
     1: {
 78912:     JS_ASSERT(obj->isNative());
     1: 
     1:     /* XXX must do at least once per new thread, so do it per JSContext... */
     1:     FIX_FPU();
     1: 
 99421:     Rooted<GlobalObject*> global(cx, &obj->asGlobal());
 78912: 
 99421:     RootedObject numberProto(cx, global->createBlankPrototype(cx, &NumberClass));
 78912:     if (!numberProto)
     1:         return NULL;
 86483:     numberProto->asNumber().setPrimitiveValue(0);
 77343: 
114199:     RootedFunction ctor(cx);
114207:     ctor = global->createConstructor(cx, Number, cx->names().Number, 1);
 78912:     if (!ctor)
 77343:         return NULL;
 77343: 
 78912:     if (!LinkConstructorAndPrototype(cx, ctor, numberProto))
 78912:         return NULL;
 78912: 
 78912:     /* Add numeric constants (MAX_VALUE, NaN, &c.) to the Number constructor. */
     1:     if (!JS_DefineConstDoubles(cx, ctor, number_constants))
     1:         return NULL;
     1: 
100155:     if (!DefinePropertiesAndBrand(cx, ctor, NULL, number_static_methods))
100155:         return NULL;
100155: 
 78912:     if (!DefinePropertiesAndBrand(cx, numberProto, NULL, number_methods))
 78912:         return NULL;
 78912: 
 78912:     if (!JS_DefineFunctions(cx, global, number_functions))
 78912:         return NULL;
 78912: 
106862:     RootedValue valueNaN(cx, cx->runtime->NaNValue);
106862:     RootedValue valueInfinity(cx, cx->runtime->positiveInfinityValue);
106862: 
 78912:     /* ES5 15.1.1.1, 15.1.1.2 */
114207:     if (!DefineNativeProperty(cx, global, cx->names().NaN, valueNaN,
106862:                               JS_PropertyStub, JS_StrictPropertyStub,
 78912:                               JSPROP_PERMANENT | JSPROP_READONLY, 0, 0) ||
114207:         !DefineNativeProperty(cx, global, cx->names().Infinity, valueInfinity,
 62395:                               JS_PropertyStub, JS_StrictPropertyStub,
 78912:                               JSPROP_PERMANENT | JSPROP_READONLY, 0, 0))
 78912:     {
     1:         return NULL;
     1:     }
     1: 
 78912:     if (!DefineConstructorAndPrototype(cx, global, JSProto_Number, ctor, numberProto))
     1:         return NULL;
 78912: 
 78912:     return numberProto;
     1: }
     1: 
 53852: namespace js {
 53852: 
 23700: static char *
 91450: FracNumberToCString(JSContext *cx, ToCStringBuf *cbuf, double d, int base = 10)
 53852: {
 53852: #ifdef DEBUG
 53852:     {
 53855:         int32_t _;
 95341:         JS_ASSERT(!MOZ_DOUBLE_IS_INT32(d, &_));
 53852:     }
 53852: #endif
 54164: 
 54164:     char* numStr;
 54164:     if (base == 10) {
 54164:         /*
 54164:          * This is V8's implementation of the algorithm described in the
 54164:          * following paper:
 54164:          *
 54164:          *   Printing floating-point numbers quickly and accurately with integers.
 54164:          *   Florian Loitsch, PLDI 2010.
 54164:          */
 95281:         const double_conversion::DoubleToStringConverter &converter
 95281:             = double_conversion::DoubleToStringConverter::EcmaScriptConverter();
 95281:         double_conversion::StringBuilder builder(cbuf->sbuf, cbuf->sbufSize);
 95281:         converter.ToShortest(d, &builder);
 95281:         numStr = builder.Finalize();
 54164:     } else {
 88135:         numStr = cbuf->dbuf = js_dtobasestr(cx->runtime->dtoaState, base, d);
 54164:     }
 54164:     return numStr;
 53852: }
 53852: 
 53852: char *
 91450: NumberToCString(JSContext *cx, ToCStringBuf *cbuf, double d, int base/* = 10*/)
     1: {
 48470:     int32_t i;
 95341:     return MOZ_DOUBLE_IS_INT32(d, &i)
 53852:            ? IntToCString(cbuf, i, base)
 53852:            : FracNumberToCString(cx, cbuf, d, base);
 53852: }
     1: 
     1: }
     1: 
 33937: static JSString * JS_FASTCALL
 91450: js_NumberToStringWithBase(JSContext *cx, double d, int base)
 20409: {
 53852:     ToCStringBuf cbuf;
 20409:     char *numStr;
 20409: 
 33937:     /*
 33937:      * Caller is responsible for error reporting. When called from trace,
 33937:      * returning NULL here will cause us to fall of trace and then retry
 33937:      * from the interpreter (which will report the error).
 33937:      */
 20898:     if (base < 2 || base > 36)
 20898:         return NULL;
 33937: 
 61432:     JSCompartment *c = cx->compartment;
 61432: 
 48470:     int32_t i;
 95341:     if (MOZ_DOUBLE_IS_INT32(d, &i)) {
 78537:         if (base == 10 && StaticStrings::hasInt(i))
 78537:             return cx->runtime->staticStrings.getInt(i);
 91612:         if (unsigned(i) < unsigned(base)) {
 33937:             if (i < 10)
 78537:                 return cx->runtime->staticStrings.getInt(i);
 64345:             jschar c = 'a' + i - 10;
 78537:             JS_ASSERT(StaticStrings::hasUnit(c));
 78537:             return cx->runtime->staticStrings.getUnit(c);
 33937:         }
 53852: 
 64345:         if (JSFlatString *str = c->dtoaCache.lookup(base, d))
 61432:             return str;
 53852: 
 53852:         numStr = IntToCString(&cbuf, i, base);
 53852:         JS_ASSERT(!cbuf.dbuf && numStr >= cbuf.sbuf && numStr < cbuf.sbuf + cbuf.sbufSize);
 53852:     } else {
 64345:         if (JSFlatString *str = c->dtoaCache.lookup(base, d))
 61432:             return str;
 53852: 
 53852:         numStr = FracNumberToCString(cx, &cbuf, d, base);
 53852:         if (!numStr) {
 53852:             JS_ReportOutOfMemory(cx);
 20409:             return NULL;
 53852:         }
 53852:         JS_ASSERT_IF(base == 10,
 53852:                      !cbuf.dbuf && numStr >= cbuf.sbuf && numStr < cbuf.sbuf + cbuf.sbufSize);
 53852:         JS_ASSERT_IF(base != 10,
 53852:                      cbuf.dbuf && cbuf.dbuf == numStr);
 53852:     }
 53852: 
114424:     JSFlatString *s = js_NewStringCopyZ(cx, numStr);
 61432:     c->dtoaCache.cache(base, d, s);
 23700:     return s;
 20409: }
 20409: 
112429: JSString *
 90955: js_NumberToString(JSContext *cx, double d)
     1: {
 33937:     return js_NumberToStringWithBase(cx, d, 10);
     1: }
     1: 
 60571: namespace js {
 60571: 
114424: JSFlatString *
 90955: NumberToString(JSContext *cx, double d)
 59890: {
 59890:     if (JSString *str = js_NumberToStringWithBase(cx, d, 10))
114424:         return &str->asFlat();
 59890:     return NULL;
 59890: }
 59890: 
114424: JSFlatString *
 84755: IndexToString(JSContext *cx, uint32_t index)
 74600: {
 78537:     if (StaticStrings::hasUint(index))
 78537:         return cx->runtime->staticStrings.getUint(index);
 74600: 
 74600:     JSCompartment *c = cx->compartment;
114424:     if (JSFlatString *str = c->dtoaCache.lookup(10, index))
 74600:         return str;
 74600: 
 74600:     JSShortString *str = js_NewGCShortString(cx);
 74600:     if (!str)
 74600:         return NULL;
 74600: 
110550:     jschar buffer[JSShortString::MAX_SHORT_LENGTH + 1];
110550:     RangedPtr<jschar> end(buffer + JSShortString::MAX_SHORT_LENGTH,
110550:                           buffer, JSShortString::MAX_SHORT_LENGTH + 1);
 74908:     *end = '\0';
 74908:     RangedPtr<jschar> start = BackfillIndexInCharBuffer(index, end);
 74600: 
110550:     jschar *dst = str->init(end - start);
110550:     PodCopy(dst, start.get(), end - start + 1);
 74600: 
 74815:     c->dtoaCache.cache(10, index, str);
 74600:     return str;
 74600: }
 74600: 
 60571: bool JS_FASTCALL
 60571: NumberValueToStringBuffer(JSContext *cx, const Value &v, StringBuffer &sb)
 30023: {
 30023:     /* Convert to C-string. */
 53852:     ToCStringBuf cbuf;
 30023:     const char *cstr;
 48470:     if (v.isInt32()) {
 53852:         cstr = IntToCString(&cbuf, v.toInt32());
 30023:     } else {
 53852:         cstr = NumberToCString(cx, &cbuf, v.toDouble());
 53852:         if (!cstr) {
 53852:             JS_ReportOutOfMemory(cx);
 53852:             return JS_FALSE;
 30023:         }
 53852:     }
 30023: 
 30023:     /*
 30023:      * Inflate to jschar string.  The input C-string characters are < 127, so
 30023:      * even if jschars are UTF-8, all chars should map to one jschar.
 30023:      */
 30023:     size_t cstrlen = strlen(cstr);
 53852:     JS_ASSERT(!cbuf.dbuf && cstrlen < cbuf.sbufSize);
 60571:     return sb.appendInflated(cstr, cstrlen);
 30023: }
 30023: 
118018: #if defined(_MSC_VER)
118018: # pragma optimize("g", off)
118018: #endif
 94326: JS_PUBLIC_API(bool)
 73894: ToNumberSlow(JSContext *cx, Value v, double *out)
     1: {
116159:     AssertCanGC();
 97353: #ifdef DEBUG
 97603:     /*
 97603:      * MSVC bizarrely miscompiles this, complaining about the first brace below
 97603:      * being unmatched (!).  The error message points at both this opening brace
 97603:      * and at the corresponding SkipRoot constructor.  The error seems to derive
 97603:      * from the presence guard-object macros on the SkipRoot class/constructor,
 97603:      * which seems well in the weeds for an unmatched-brace syntax error.
 97603:      * Otherwise the problem is inscrutable, and I haven't found a workaround.
 97603:      * So for now just disable it when compiling with MSVC -- not ideal, but at
 97603:      * least Windows debug shell builds complete again.
 97603:      */
 97603: #ifndef _MSC_VER
 97353:     {
 97353:         SkipRoot skip(cx, &v);
 97353:         MaybeCheckStackRoots(cx);
 97353:     }
 97353: #endif
 97603: #endif
 97353: 
 48470:     JS_ASSERT(!v.isNumber());
 40828:     goto skip_int_double;
 40828:     for (;;) {
 48470:         if (v.isNumber()) {
 48470:             *out = v.toNumber();
 48470:             return true;
 40828:         }
 40828:       skip_int_double:
 59890:         if (v.isString())
 90955:             return StringToNumberType<double>(cx, v.toString(), out);
 48470:         if (v.isBoolean()) {
 48470:             if (v.toBoolean()) {
 40828:                 *out = 1.0;
 48470:                 return true;
 39942:             }
 40828:             *out = 0.0;
 48470:             return true;
 12850:         }
 48470:         if (v.isNull()) {
 40828:             *out = 0.0;
 48470:             return true;
 12694:         }
 48470:         if (v.isUndefined())
 12694:             break;
 12694: 
 48470:         JS_ASSERT(v.isObject());
 72054:         if (!ToPrimitive(cx, JSTYPE_NUMBER, &v))
 48470:             return false;
 48470:         if (v.isObject())
 12694:             break;
 12694:     }
 12694: 
 40828:     *out = js_NaN;
 48470:     return true;
 12581: }
118018: #if defined(_MSC_VER)
118018: # pragma optimize("", on)
118018: #endif
 12581: 
107392: /*
107392:  * Convert a value to an int64_t, according to the WebIDL rules for long long
107392:  * conversion. Return converted value in *out on success, false on failure.
107392:  */
107392: JS_PUBLIC_API(bool)
107392: ToInt64Slow(JSContext *cx, const Value &v, int64_t *out)
107392: {
107392:     JS_ASSERT(!v.isInt32());
107392:     double d;
107392:     if (v.isDouble()) {
107392:         d = v.toDouble();
107392:     } else {
107392:         if (!ToNumberSlow(cx, v, &d))
107392:             return false;
107392:     }
107392:     *out = ToInt64(d);
107392:     return true;
107392: }
107392: 
107392: /*
107392:  * Convert a value to an uint64_t, according to the WebIDL rules for unsigned long long
107392:  * conversion. Return converted value in *out on success, false on failure.
107392:  */
107392: JS_PUBLIC_API(bool)
107392: ToUint64Slow(JSContext *cx, const Value &v, uint64_t *out)
107392: {
107392:     JS_ASSERT(!v.isInt32());
107392:     double d;
107392:     if (v.isDouble()) {
107392:         d = v.toDouble();
107392:     } else {
107392:         if (!ToNumberSlow(cx, v, &d))
107392:             return false;
107392:     }
107392:     *out = ToUint64(d);
107392:     return true;
107392: }
107392: 
 94326: JS_PUBLIC_API(bool)
 84161: ToInt32Slow(JSContext *cx, const Value &v, int32_t *out)
     1: {
 48470:     JS_ASSERT(!v.isInt32());
 90955:     double d;
 48470:     if (v.isDouble()) {
 48470:         d = v.toDouble();
 12681:     } else {
 73894:         if (!ToNumberSlow(cx, v, &d))
 40828:             return false;
 12681:     }
 97045:     *out = ToInt32(d);
 40828:     return true;
     1: }
     1: 
107246: JS_PUBLIC_API(bool)
 84161: ToUint32Slow(JSContext *cx, const Value &v, uint32_t *out)
     1: {
 48470:     JS_ASSERT(!v.isInt32());
 90955:     double d;
 48470:     if (v.isDouble()) {
 48470:         d = v.toDouble();
 12681:     } else {
 73894:         if (!ToNumberSlow(cx, v, &d))
 40828:             return false;
 12681:     }
 97045:     *out = ToUint32(d);
 40828:     return true;
     1: }
     1: 
107246: JS_PUBLIC_API(bool)
107246: ToUint16Slow(JSContext *cx, const Value &v, uint16_t *out)
     1: {
 48470:     JS_ASSERT(!v.isInt32());
 90955:     double d;
 48470:     if (v.isDouble()) {
 48470:         d = v.toDouble();
 73894:     } else if (!ToNumberSlow(cx, v, &d)) {
 40828:         return false;
 40828:     }
     1: 
 95341:     if (d == 0 || !MOZ_DOUBLE_IS_FINITE(d)) {
 40828:         *out = 0;
 40828:         return true;
 40828:     }
 12850: 
 84755:     uint16_t u = (uint16_t) d;
 90955:     if ((double)u == d) {
 40828:         *out = u;
 40828:         return true;
 40828:     }
 40828: 
 40828:     bool neg = (d < 0);
     1:     d = floor(neg ? -d : d);
     1:     d = neg ? -d : d;
 91612:     unsigned m = JS_BIT(16);
     1:     d = fmod(d, (double) m);
     1:     if (d < 0)
     1:         d += m;
 40828:     *out = (uint16_t) d;
 40828:     return true;
 12850: }
 40828: 
 40828: }  /* namespace js */
     1: 
     1: JSBool
  4281: js_strtod(JSContext *cx, const jschar *s, const jschar *send,
 90955:           const jschar **ep, double *dp)
     1: {
 74434:     size_t i;
     1:     char cbuf[32];
     1:     char *cstr, *istr, *estr;
     1:     JSBool negative;
 90955:     double d;
  4281: 
 74434:     const jschar *s1 = SkipSpace(s, send);
 74434:     size_t length = send - s1;
     1: 
     1:     /* Use cbuf to avoid malloc */
     1:     if (length >= sizeof cbuf) {
 64560:         cstr = (char *) cx->malloc_(length + 1);
     1:         if (!cstr)
     1:            return JS_FALSE;
     1:     } else {
     1:         cstr = cbuf;
     1:     }
     1: 
  4281:     for (i = 0; i != length; i++) {
  4281:         if (s1[i] >> 8)
     1:             break;
     1:         cstr[i] = (char)s1[i];
     1:     }
  4281:     cstr[i] = 0;
     1: 
     1:     istr = cstr;
     1:     if ((negative = (*istr == '-')) != 0 || *istr == '+')
     1:         istr++;
 93382:     if (*istr == 'I' && !strncmp(istr, "Infinity", 8)) {
 34372:         d = negative ? js_NegativeInfinity : js_PositiveInfinity;
     1:         estr = istr + 8;
     1:     } else {
     1:         int err;
 88135:         d = js_strtod_harder(cx->runtime->dtoaState, cstr, &estr, &err);
     1:         if (d == HUGE_VAL)
 34372:             d = js_PositiveInfinity;
     1:         else if (d == -HUGE_VAL)
 34372:             d = js_NegativeInfinity;
     1:     }
     1: 
     1:     i = estr - cstr;
     1:     if (cstr != cbuf)
110933:         js_free(cstr);
     1:     *ep = i ? s1 + i : s;
     1:     *dp = d;
     1:     return JS_TRUE;
     1: }
