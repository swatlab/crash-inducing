    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsXMLHttpRequest_h__
    1: #define nsXMLHttpRequest_h__
    1: 
    1: #include "nsIXMLHttpRequest.h"
    1: #include "nsISupportsUtils.h"
    1: #include "nsString.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIURI.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIDocument.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsWeakReference.h"
    1: #include "jsapi.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIChannelEventSink.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIHttpHeaderVisitor.h"
    1: #include "nsIProgressEventSink.h"
    1: #include "nsCOMArray.h"
    1: #include "nsJSUtils.h"
    1: #include "nsTArray.h"
 8947: #include "nsIJSNativeInitializer.h"
    1: #include "nsIDOMLSProgressEvent.h"
16665: #include "nsIDOMNSEvent.h"
20640: #include "nsITimer.h"
16665: #include "nsIPrivateDOMEvent.h"
16665: #include "nsDOMProgressEvent.h"
89667: #include "nsDOMEventTargetHelper.h"
63932: #include "nsContentUtils.h"
88536: #include "nsDOMFile.h"
88536: #include "nsDOMBlobBuilder.h"
94512: #include "nsIPrincipal.h"
94512: #include "nsIScriptObjectPrincipal.h"
94512: #include "mozilla/dom/bindings/XMLHttpRequestBinding.h"
94512: #include "mozilla/dom/bindings/XMLHttpRequestUploadBinding.h"
94512: 
94512: #include "mozilla/Assertions.h"
    1: 
    1: class nsILoadGroup;
48889: class AsyncVerifyRedirectCallbackForwarder;
78800: class nsIUnicodeDecoder;
94307: class nsIDOMFormData;
    1: 
94512: #define IMPL_EVENT_HANDLER(_lowercase, _capitalized)                    \
94512:   JSObject* GetOn##_lowercase()                                         \
94512:   {                                                                     \
94512:     return GetListenerAsJSObject(mOn##_capitalized##Listener);          \
94512:   }                                                                     \
94512:   void SetOn##_lowercase(JSContext* aCx, JSObject* aCallback, nsresult& aRv) \
94512:   {                                                                     \
94512:     aRv = SetJSObjectListener(aCx, NS_LITERAL_STRING(#_lowercase),      \
94512:                               mOn##_capitalized##Listener,              \
94512:                               aCallback);                               \
94512:   }
94512: 
89667: class nsXHREventTarget : public nsDOMEventTargetHelper,
43831:                          public nsIXMLHttpRequestEventTarget
16665: {
16665: public:
94512:   typedef mozilla::dom::bindings::prototypes::XMLHttpRequestResponseType::value
94512:           XMLHttpRequestResponseType;
94512: 
43831:   virtual ~nsXHREventTarget() {}
29226:   NS_DECL_ISUPPORTS_INHERITED
43831:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsXHREventTarget,
89667:                                            nsDOMEventTargetHelper)
16665:   NS_DECL_NSIXMLHTTPREQUESTEVENTTARGET
29226:   NS_FORWARD_NSIDOMEVENTTARGET(nsDOMEventTargetHelper::)
79469: 
94512:   IMPL_EVENT_HANDLER(loadstart, LoadStart)
94512:   IMPL_EVENT_HANDLER(progress, Progress)
94512:   IMPL_EVENT_HANDLER(abort, Abort)
94512:   IMPL_EVENT_HANDLER(error, Error)
94512:   IMPL_EVENT_HANDLER(load, Load)
94512:   IMPL_EVENT_HANDLER(timeout, Timeout)
94512:   IMPL_EVENT_HANDLER(loadend, Loadend)
94307:   
92083:   virtual void DisconnectFromOwner();
79469: protected:
94307:   static inline JSObject* GetListenerAsJSObject(nsDOMEventListenerWrapper* aWrapper)
94307:   {
94538:     if (!aWrapper) {
94538:       return nsnull;
94538:     }
94538: 
94307:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder =
94307:         do_QueryInterface(aWrapper->GetInner());
94307:     JSObject* obj;
94307:     return holder && NS_SUCCEEDED(holder->GetJSObject(&obj)) ? obj : nsnull;
94307:   }
94512:   inline nsresult SetJSObjectListener(JSContext* aCx,
94512:                                       const nsAString& aType,
94307:                                       nsRefPtr<nsDOMEventListenerWrapper>& aWrapper,
94307:                                       JSObject* aCallback)
94307:   {
94307:     nsCOMPtr<nsIDOMEventListener> listener;
94307:     if (aCallback) {
94512:       nsresult rv =
94512:         nsContentUtils::XPConnect()->WrapJS(aCx,
94307:                                             aCallback,
94307:                                             NS_GET_IID(nsIDOMEventListener),
94307:                                             getter_AddRefs(listener));
94307:       NS_ENSURE_SUCCESS(rv, rv);
94307:     }
94307: 
94307:     return RemoveAddEventListener(aType, aWrapper, listener);
94307:   }
94307: 
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnLoadListener;
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnErrorListener;
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnAbortListener;
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnLoadStartListener;
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnProgressListener;
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnLoadendListener;
88284:   nsRefPtr<nsDOMEventListenerWrapper> mOnTimeoutListener;
16665: };
16665: 
16665: class nsXMLHttpRequestUpload : public nsXHREventTarget,
16665:                                public nsIXMLHttpRequestUpload
16665: {
16665: public:
92083:   nsXMLHttpRequestUpload(nsDOMEventTargetHelper* aOwner)
19701:   {
92083:     BindToOwner(aOwner);
94512:     SetIsDOMBinding();
19701:   }                                         
16665:   NS_DECL_ISUPPORTS_INHERITED
16665:   NS_FORWARD_NSIXMLHTTPREQUESTEVENTTARGET(nsXHREventTarget::)
16665:   NS_FORWARD_NSIDOMEVENTTARGET(nsXHREventTarget::)
16665:   NS_DECL_NSIXMLHTTPREQUESTUPLOAD
19953: 
94512:   virtual JSObject* WrapObject(JSContext *cx, JSObject *scope,
94512:                                bool *triedToWrap)
94512:   {
94512:     return mozilla::dom::bindings::prototypes::XMLHttpRequestUpload::Wrap(cx, scope, this, triedToWrap);
94512:   }
94512:   nsISupports* GetParentObject()
94512:   {
94512:     return GetOwner();
94512:   }
94512: 
79445:   bool HasListeners()
19953:   {
19953:     return mListenerManager && mListenerManager->HasListeners();
19953:   }
16665: };
16665: 
16665: class nsXMLHttpRequest : public nsXHREventTarget,
16665:                          public nsIXMLHttpRequest,
    1:                          public nsIJSXMLHttpRequest,
    1:                          public nsIStreamListener,
    1:                          public nsIChannelEventSink,
    1:                          public nsIProgressEventSink,
    1:                          public nsIInterfaceRequestor,
 8947:                          public nsSupportsWeakReference,
20640:                          public nsIJSNativeInitializer,
20640:                          public nsITimerCallback
    1: {
82543:   friend class nsXHRParseEndListener;
    1: public:
    1:   nsXMLHttpRequest();
    1:   virtual ~nsXMLHttpRequest();
    1: 
94512:   virtual JSObject* WrapObject(JSContext *cx, JSObject *scope,
94512:                                bool *triedToWrap)
94512:   {
94512:     return mozilla::dom::bindings::prototypes::XMLHttpRequest::Wrap(cx, scope, this, triedToWrap);
94512:   }
94512:   nsISupports* GetParentObject()
94512:   {
94512:     return GetOwner();
94512:   }
94512: 
94512:   // The WebIDL parser converts constructors into methods called _Constructor.
94512:   static already_AddRefed<nsXMLHttpRequest>
94512:   _Constructor(nsISupports* aGlobal, nsresult& aRv)
94512:   {
94512:     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aGlobal);
94512:     nsCOMPtr<nsIScriptObjectPrincipal> principal = do_QueryInterface(aGlobal);
94512:     if (!window || ! principal) {
94512:       aRv = NS_ERROR_FAILURE;
94512:       return NULL;
94512:     }
94512: 
94512:     nsRefPtr<nsXMLHttpRequest> req = new nsXMLHttpRequest();
94512:     req->Construct(principal->GetPrincipal(), window);
94512:     return req.forget();
94512:   }
94512: 
94512:   void Construct(nsIPrincipal* aPrincipal,
94512:                  nsPIDOMWindow* aOwnerWindow,
94512:                  nsIURI* aBaseURI = NULL)
94512:   {
94512:     MOZ_ASSERT(aPrincipal);
94512:     MOZ_ASSERT_IF(aOwnerWindow, aOwnerWindow->IsInnerWindow());
94512:     mPrincipal = aPrincipal;
94512:     BindToOwner(aOwnerWindow);
94512:     mBaseURI = aBaseURI;
94512:   }
94512: 
16665:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIXMLHttpRequest
    1:   NS_DECL_NSIXMLHTTPREQUEST
    1: 
    1:   // nsIJSXMLHttpRequest
79469:   NS_IMETHOD GetOnuploadprogress(nsIDOMEventListener** aOnuploadprogress);
79469:   NS_IMETHOD SetOnuploadprogress(nsIDOMEventListener* aOnuploadprogress);
    1: 
16665:   NS_FORWARD_NSIXMLHTTPREQUESTEVENTTARGET(nsXHREventTarget::)
16664: 
    1:   // nsIStreamListener
    1:   NS_DECL_NSISTREAMLISTENER
    1: 
    1:   // nsIRequestObserver
    1:   NS_DECL_NSIREQUESTOBSERVER
    1: 
    1:   // nsIChannelEventSink
    1:   NS_DECL_NSICHANNELEVENTSINK
    1: 
    1:   // nsIProgressEventSink
    1:   NS_DECL_NSIPROGRESSEVENTSINK
    1: 
    1:   // nsIInterfaceRequestor
    1:   NS_DECL_NSIINTERFACEREQUESTOR
    1: 
20640:   // nsITimerCallback
20640:   NS_DECL_NSITIMERCALLBACK
20640: 
 8947:   // nsIJSNativeInitializer
 8947:   NS_IMETHOD Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
 8947:                        PRUint32 argc, jsval* argv);
 8947: 
29226:   NS_FORWARD_NSIDOMEVENTTARGET(nsXHREventTarget::)
16664: 
94307: #ifdef DEBUG
94307:   void StaticAssertions();
94307: #endif
94307: 
94307:   // event handler
94512:   IMPL_EVENT_HANDLER(readystatechange, Readystatechange)
94307: 
94307:   // states
94307:   uint16_t GetReadyState();
94307: 
94307:   // request
94307:   void Open(const nsAString& aMethod, const nsAString& aUrl, bool aAsync,
94307:             const nsAString& aUser, const nsAString& aPassword, nsresult& aRv)
94307:   {
94307:     aRv = Open(NS_ConvertUTF16toUTF8(aMethod), NS_ConvertUTF16toUTF8(aUrl),
94307:                aAsync, aUser, aPassword);
94307:   }
94307:   void SetRequestHeader(const nsAString& aHeader, const nsAString& aValue,
94307:                         nsresult& aRv)
94307:   {
94307:     aRv = SetRequestHeader(NS_ConvertUTF16toUTF8(aHeader),
94307:                            NS_ConvertUTF16toUTF8(aValue));
94307:   }
94307:   uint32_t GetTimeout()
94307:   {
94307:     return mTimeoutMilliseconds;
94307:   }
94307:   void SetTimeout(uint32_t aTimeout, nsresult& aRv);
94307:   bool GetWithCredentials();
94307:   void SetWithCredentials(bool aWithCredentials, nsresult& aRv);
94307:   nsXMLHttpRequestUpload* GetUpload();
94307: 
94307: private:
94307:   class RequestBody
94307:   {
94307:   public:
94307:     RequestBody() : mType(Uninitialized)
94307:     {
94307:     }
94307:     RequestBody(JSObject* aArrayBuffer) : mType(ArrayBuffer)
94307:     {
94307:       mValue.mArrayBuffer = aArrayBuffer;
94307:     }
94307:     RequestBody(nsIDOMBlob* aBlob) : mType(Blob)
94307:     {
94307:       mValue.mBlob = aBlob;
94307:     }
94307:     RequestBody(nsIDocument* aDocument) : mType(Document)
94307:     {
94307:       mValue.mDocument = aDocument;
94307:     }
94307:     RequestBody(const nsAString& aString) : mType(DOMString)
94307:     {
94307:       mValue.mString = &aString;
94307:     }
94307:     RequestBody(nsIDOMFormData* aFormData) : mType(FormData)
94307:     {
94307:       mValue.mFormData = aFormData;
94307:     }
94307:     RequestBody(nsIInputStream* aStream) : mType(InputStream)
94307:     {
94307:       mValue.mStream = aStream;
94307:     }
94307: 
94307:     enum Type {
94307:       Uninitialized,
94307:       ArrayBuffer,
94307:       Blob,
94307:       Document,
94307:       DOMString,
94307:       FormData,
94307:       InputStream
94307:     };
94307:     union Value {
94307:       JSObject* mArrayBuffer;
94307:       nsIDOMBlob* mBlob;
94307:       nsIDocument* mDocument;
94307:       const nsAString* mString;
94307:       nsIDOMFormData* mFormData;
94307:       nsIInputStream* mStream;
94307:     };
94307: 
94307:     Type GetType() const
94307:     {
94307:       MOZ_ASSERT(mType != Uninitialized);
94307:       return mType;
94307:     }
94307:     Value GetValue() const
94307:     {
94307:       MOZ_ASSERT(mType != Uninitialized);
94307:       return mValue;
94307:     }
94307: 
94307:   private:
94307:     Type mType;
94307:     Value mValue;
94307:   };
94307: 
94307:   static nsresult GetRequestBody(nsIVariant* aVariant,
94512:                                  const Nullable<RequestBody>& aBody,
94307:                                  nsIInputStream** aResult,
94307:                                  nsACString& aContentType,
94307:                                  nsACString& aCharset);
94307: 
94512:   nsresult Send(nsIVariant* aVariant, const Nullable<RequestBody>& aBody);
94512:   nsresult Send(const Nullable<RequestBody>& aBody)
94512:   {
94512:     return Send(nsnull, aBody);
94512:   }
94307:   nsresult Send(const RequestBody& aBody)
94307:   {
94512:     return Send(Nullable<RequestBody>(aBody));
94307:   }
94307: 
94307: public:
94307:   void Send(nsresult& aRv)
94307:   {
94512:     aRv = Send(Nullable<RequestBody>());
94307:   }
94307:   void Send(JSObject* aArrayBuffer, nsresult& aRv)
94307:   {
94307:     NS_ASSERTION(aArrayBuffer, "Null should go to string version");
94307:     aRv = Send(RequestBody(aArrayBuffer));
94307:   }
94307:   void Send(nsIDOMBlob* aBlob, nsresult& aRv)
94307:   {
94307:     NS_ASSERTION(aBlob, "Null should go to string version");
94307:     aRv = Send(RequestBody(aBlob));
94307:   }
94307:   void Send(nsIDocument* aDoc, nsresult& aRv)
94307:   {
94307:     NS_ASSERTION(aDoc, "Null should go to string version");
94307:     aRv = Send(RequestBody(aDoc));
94307:   }
94307:   void Send(const nsAString& aString, nsresult& aRv)
94307:   {
94307:     if (DOMStringIsNull(aString)) {
94307:       Send(aRv);
94307:     }
94307:     else {
94307:       aRv = Send(RequestBody(aString));
94307:     }
94307:   }
94307:   void Send(nsIDOMFormData* aFormData, nsresult& aRv)
94307:   {
94307:     NS_ASSERTION(aFormData, "Null should go to string version");
94307:     aRv = Send(RequestBody(aFormData));
94307:   }
94307:   void Send(nsIInputStream* aStream, nsresult& aRv)
94307:   {
94307:     NS_ASSERTION(aStream, "Null should go to string version");
94307:     aRv = Send(RequestBody(aStream));
94307:   }
94307:   void SendAsBinary(const nsAString& aBody, nsresult& aRv);
94307: 
94307:   void Abort();
94307: 
94307:   // response
94307:   uint32_t GetStatus();
94307:   void GetStatusText(nsString& aStatusText);
94307:   void GetResponseHeader(const nsACString& aHeader, nsACString& aResult,
94307:                          nsresult& aRv);
94307:   void GetResponseHeader(const nsAString& aHeader, nsString& aResult,
94307:                          nsresult& aRv)
94307:   {
94307:     nsCString result;
94307:     GetResponseHeader(NS_ConvertUTF16toUTF8(aHeader), result, aRv);
94307:     if (result.IsVoid()) {
94307:       aResult.SetIsVoid(true);
94307:     }
94307:     else {
94307:       // We use UTF8ToNewUnicode here because it truncates after invalid UTF-8
94307:       // characters, CopyUTF8toUTF16 just doesn't copy in that case.
94307:       PRUint32 length;
94307:       PRUnichar* chars = UTF8ToNewUnicode(result, &length);
94307:       aResult.Adopt(chars, length);
94307:     }
94307:   }
94307:   void GetAllResponseHeaders(nsString& aResponseHeaders);
94307:   void OverrideMimeType(const nsAString& aMimeType)
94307:   {
94307:     // XXX Should we do some validation here?
94307:     mOverrideMimeType = aMimeType;
94307:   }
94512:   XMLHttpRequestResponseType GetResponseType()
94512:   {
94512:     return XMLHttpRequestResponseType(mResponseType);
94512:   }
94512:   void SetResponseType(XMLHttpRequestResponseType aType, nsresult& aRv);
94307:   JS::Value GetResponse(JSContext* aCx, nsresult& aRv);
94307:   void GetResponseText(nsString& aResponseText, nsresult& aRv);
94307:   nsIDocument* GetResponseXML(nsresult& aRv);
94307: 
94307:   bool GetMozBackgroundRequest();
94307:   void SetMozBackgroundRequest(bool aMozBackgroundRequest, nsresult& aRv);
94307:   bool GetMultipart();
94307:   void SetMultipart(bool aMultipart, nsresult& aRv);
94307: 
94307:   nsIChannel* GetChannel()
94307:   {
94307:     return mChannel;
94307:   }
94307: 
94512:   // We need a GetInterface callable from JS for chrome JS
94512:   JS::Value GetInterface(JSContext*aCx, nsIJSIID* aIID, nsresult& aRv);
94512: 
16665:   // This creates a trusted readystatechange event, which is not cancelable and
16665:   // doesn't bubble.
16665:   static nsresult CreateReadystatechangeEvent(nsIDOMEvent** aDOMEvent);
16665:   // For backwards compatibility aPosition should contain the headers for upload
16665:   // and aTotalSize is LL_MAXUINT when unknown. Both those values are
16665:   // used by nsXMLHttpProgressEvent. Normal progress event should not use
16665:   // headers in aLoaded and aTotal is 0 when unknown.
72322:   void DispatchProgressEvent(nsDOMEventTargetHelper* aTarget,
16665:                              const nsAString& aType,
16665:                              // Whether to use nsXMLHttpProgressEvent,
16665:                              // which implements LS Progress Event.
79445:                              bool aUseLSEventWrapper,
79445:                              bool aLengthComputable,
16665:                              // For Progress Events
16665:                              PRUint64 aLoaded, PRUint64 aTotal,
16665:                              // For LS Progress Events
16665:                              PRUint64 aPosition, PRUint64 aTotalSize);
72322:   void DispatchProgressEvent(nsDOMEventTargetHelper* aTarget,
16665:                              const nsAString& aType,
79445:                              bool aLengthComputable,
16665:                              PRUint64 aLoaded, PRUint64 aTotal)
16665:   {
80486:     DispatchProgressEvent(aTarget, aType, false,
16665:                           aLengthComputable, aLoaded, aTotal,
16665:                           aLoaded, aLengthComputable ? aTotal : LL_MAXUINT);
16665:   }
16665: 
78799:   // Dispatch the "progress" event on the XHR or XHR.upload object if we've
78799:   // received data since the last "progress" event. Also dispatches
78799:   // "uploadprogress" as needed.
79445:   void MaybeDispatchProgressEvents(bool aFinalProgress);
78799: 
 8947:   // This is called by the factory constructor.
 8947:   nsresult Init();
 8947: 
19944:   void SetRequestObserver(nsIRequestObserver* aObserver);
19944: 
88267:   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_INHERITED(nsXMLHttpRequest,
16665:                                                                    nsXHREventTarget)
79445:   bool AllowUploadProgress();
70838:   void RootResultArrayBuffer();
19953: 
92083:   virtual void DisconnectFromOwner();
    1: protected:
19152:   friend class nsMultipartProxyListener;
19152: 
78800:   nsresult DetectCharset();
78800:   nsresult AppendToResponseText(const char * aBuffer, PRUint32 aBufferLen);
    1:   static NS_METHOD StreamReaderFunc(nsIInputStream* in,
    1:                 void* closure,
    1:                 const char* fromRawSegment,
    1:                 PRUint32 toOffset,
    1:                 PRUint32 count,
    1:                 PRUint32 *writeCount);
78115:   nsresult CreateResponseParsedJSON(JSContext* aCx);
88536:   nsresult CreatePartialBlob(void);
88536:   bool CreateDOMFile(nsIRequest *request);
    1:   // Change the state of the object with this. The broadcast argument
    1:   // determines if the onreadystatechange listener should be called.
79445:   nsresult ChangeState(PRUint32 aState, bool aBroadcast = true);
77186:   already_AddRefed<nsILoadGroup> GetLoadGroup() const;
20560:   nsIURI *GetBaseURI();
    1: 
16664:   nsresult RemoveAddEventListener(const nsAString& aType,
16664:                                   nsRefPtr<nsDOMEventListenerWrapper>& aCurrent,
16664:                                   nsIDOMEventListener* aNew);
    1: 
16664:   nsresult GetInnerEventListener(nsRefPtr<nsDOMEventListenerWrapper>& aWrapper,
16664:                                  nsIDOMEventListener** aListener);
16664: 
    1:   already_AddRefed<nsIHttpChannel> GetCurrentHttpChannel();
    1: 
75263:   bool IsSystemXHR();
63932: 
82543:   void ChangeStateToDone();
82543: 
 4064:   /**
19951:    * Check if aChannel is ok for a cross-site request by making sure no
 4064:    * inappropriate headers are set, and no username/password is set.
 4064:    *
 4064:    * Also updates the XML_HTTP_REQUEST_USE_XSITE_AC bit.
 4064:    */
19951:   nsresult CheckChannelForCrossSiteRequest(nsIChannel* aChannel);
 4064: 
20640:   void StartProgressEventTimer();
20640: 
48889:   friend class AsyncVerifyRedirectCallbackForwarder;
48889:   void OnRedirectVerifyCallback(nsresult result);
48889: 
94307:   nsresult Open(const nsACString& method, const nsACString& url, bool async,
94307:                 const nsAString& user, const nsAString& password);
94307: 
    1:   nsCOMPtr<nsISupports> mContext;
 3028:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1:   nsCOMPtr<nsIChannel> mChannel;
 4106:   // mReadRequest is different from mChannel for multipart requests
    1:   nsCOMPtr<nsIRequest> mReadRequest;
94307:   nsCOMPtr<nsIDocument> mResponseXML;
64070:   nsCOMPtr<nsIChannel> mCORSPreflightChannel;
64070:   nsTArray<nsCString> mCORSUnsafeHeaders;
    1: 
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnUploadProgressListener;
79469:   nsRefPtr<nsDOMEventListenerWrapper> mOnReadystatechangeListener;
79469: 
    1:   nsCOMPtr<nsIStreamListener> mXMLParserStreamListener;
    1: 
    1:   // used to implement getAllResponseHeaders()
    1:   class nsHeaderVisitor : public nsIHttpHeaderVisitor {
    1:   public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIHTTPHEADERVISITOR
    1:     nsHeaderVisitor() { }
    1:     virtual ~nsHeaderVisitor() {}
    1:     const nsACString &Headers() { return mHeaders; }
    1:   private:
    1:     nsCString mHeaders;
    1:   };
    1: 
78800:   // The bytes of our response body. Only used for DEFAULT, ARRAYBUFFER and
78800:   // BLOB responseTypes
    1:   nsCString mResponseBody;
    1: 
78800:   // The text version of our response body. This is incrementally decoded into
78800:   // as we receive network data. However for the DEFAULT responseType we
78800:   // lazily decode into this from mResponseBody only when .responseText is
78800:   // accessed.
78800:   // Only used for DEFAULT and TEXT responseTypes.
78800:   nsString mResponseText;
78800:   
78800:   // For DEFAULT responseType we use this to keep track of how far we've
78800:   // lazily decoded from mResponseBody to mResponseText
78800:   PRUint32 mResponseBodyDecodedPos;
78800: 
78800:   // Decoder used for decoding into mResponseText
78800:   // Only used for DEFAULT, TEXT and JSON responseTypes.
78800:   // In cases where we've only received half a surrogate, the decoder itself
78800:   // carries the state to remember this. Next time we receive more data we
78800:   // simply feed the new data into the decoder which will handle the second
78800:   // part of the surrogate.
78800:   nsCOMPtr<nsIUnicodeDecoder> mDecoder;
78800: 
78800:   nsCString mResponseCharset;
41199: 
94307:   enum ResponseType {
69662:     XML_HTTP_RESPONSE_TYPE_DEFAULT,
69662:     XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER,
69662:     XML_HTTP_RESPONSE_TYPE_BLOB,
69662:     XML_HTTP_RESPONSE_TYPE_DOCUMENT,
94307:     XML_HTTP_RESPONSE_TYPE_JSON,
78115:     XML_HTTP_RESPONSE_TYPE_TEXT,
78801:     XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT,
88536:     XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER,
88536:     XML_HTTP_RESPONSE_TYPE_MOZ_BLOB
94307:   };
94307: 
94307:   void SetResponseType(nsXMLHttpRequest::ResponseType aType, nsresult& aRv);
94307: 
94307:   ResponseType mResponseType;
69662: 
88536:   // It is either a cached blob-response from the last call to GetResponse,
88536:   // but is also explicitly set in OnStopRequest.
69662:   nsCOMPtr<nsIDOMBlob> mResponseBlob;
88536:   // Non-null only when we are able to get a os-file representation of the
88536:   // response, i.e. when loading from a file, or when the http-stream
88536:   // caches into a file or is reading from a cached file.
88536:   nsRefPtr<nsDOMFileBase> mDOMFile;
88536:   // We stream data to mBuilder when response type is "blob" or "moz-blob"
88536:   // and mDOMFile is null.
88536:   nsRefPtr<nsDOMBlobBuilder> mBuilder;
69662: 
94307:   nsString mOverrideMimeType;
    1: 
    1:   /**
    1:    * The notification callbacks the channel had when Send() was
    1:    * called.  We want to forward things here as needed.
    1:    */
    1:   nsCOMPtr<nsIInterfaceRequestor> mNotificationCallbacks;
    1:   /**
    1:    * Sink interfaces that we implement that mNotificationCallbacks may
    1:    * want to also be notified for.  These are inited lazily if we're
    1:    * asked for the relevant interface.
    1:    */
    1:   nsCOMPtr<nsIChannelEventSink> mChannelEventSink;
    1:   nsCOMPtr<nsIProgressEventSink> mProgressEventSink;
    1: 
19944:   nsIRequestObserver* mRequestObserver;
19944: 
23201:   nsCOMPtr<nsIURI> mBaseURI;
23201: 
    1:   PRUint32 mState;
 4064: 
16665:   nsRefPtr<nsXMLHttpRequestUpload> mUpload;
20714:   PRUint64 mUploadTransferred;
20714:   PRUint64 mUploadTotal;
79445:   bool mUploadLengthComputable;
79445:   bool mUploadComplete;
79445:   bool mProgressSinceLastProgressEvent;
20640:   PRUint64 mUploadProgress; // For legacy
20640:   PRUint64 mUploadProgressMax; // For legacy
16665: 
88284:   // Timeout support
88284:   PRTime mRequestSentTime;
88284:   PRUint32 mTimeoutMilliseconds;
88284:   nsCOMPtr<nsITimer> mTimeoutTimer;
88284:   void StartTimeoutTimer();
88284:   void HandleTimeoutCallback();
88284: 
79445:   bool mErrorLoad;
90244:   bool mWaitingForOnStopRequest;
88284:   bool mProgressTimerIsActive;
79445:   bool mProgressEventWasDelayed;
82543:   bool mIsHtml;
82543:   bool mWarnAboutMultipartHtml;
82543:   bool mWarnAboutSyncHtml;
88284:   bool mLoadLengthComputable;
20792:   PRUint64 mLoadTotal; // 0 if not known.
78799:   PRUint64 mLoadTransferred;
20640:   nsCOMPtr<nsITimer> mProgressNotifier;
88284:   void HandleProgressTimerCallback();
88284: 
88284:   /**
88284:    * Close the XMLHttpRequest's channels and dispatch appropriate progress
88284:    * events.
88284:    *
88284:    * @param aType The progress event type.
88284:    * @param aFlag A XML_HTTP_REQUEST_* state flag defined in
88284:    *              nsXMLHttpRequest.cpp.
88284:    */
88284:   void CloseRequestWithError(const nsAString& aType, const PRUint32 aFlag);
20640: 
79445:   bool mFirstStartRequestSeen;
79445:   bool mInLoadProgressEvent;
48889:   
48889:   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
48889:   nsCOMPtr<nsIChannel> mNewRedirectChannel;
70838:   
78115:   jsval mResultJSON;
70838:   JSObject* mResultArrayBuffer;
72497: 
78799:   void ResetResponse();
78799: 
72497:   struct RequestHeader
72497:   {
72497:     nsCString header;
72497:     nsCString value;
72497:   };
72497:   nsTArray<RequestHeader> mModifiedRequestHeaders;
    1: };
    1: 
94512: #undef IMPL_EVENT_HANDLER
94512: 
    1: // helper class to expose a progress DOM Event
    1: 
16665: class nsXMLHttpProgressEvent : public nsIDOMProgressEvent,
16665:                                public nsIDOMLSProgressEvent,
16665:                                public nsIDOMNSEvent,
16665:                                public nsIPrivateDOMEvent
    1: {
    1: public:
16665:   nsXMLHttpProgressEvent(nsIDOMProgressEvent* aInner,
16665:                          PRUint64 aCurrentProgress,
79614:                          PRUint64 aMaxProgress,
79614:                          nsPIDOMWindow* aWindow);
    1:   virtual ~nsXMLHttpProgressEvent();
    1: 
16665:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
16665:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsXMLHttpProgressEvent, nsIDOMNSEvent)
16665:   NS_FORWARD_NSIDOMEVENT(mInner->)
16665:   NS_FORWARD_NSIDOMNSEVENT(mInner->)
16665:   NS_FORWARD_NSIDOMPROGRESSEVENT(mInner->)
    1:   NS_DECL_NSIDOMLSPROGRESSEVENT
16665:   // nsPrivateDOMEvent
16665:   NS_IMETHOD DuplicatePrivateData()
16665:   {
16665:     return mInner->DuplicatePrivateData();
16665:   }
16665:   NS_IMETHOD SetTarget(nsIDOMEventTarget* aTarget)
16665:   {
16665:     return mInner->SetTarget(aTarget);
16665:   }
79445:   NS_IMETHOD_(bool) IsDispatchStopped()
16665:   {
20234:     return mInner->IsDispatchStopped();
16665:   }
20234:   NS_IMETHOD_(nsEvent*) GetInternalNSEvent()
16665:   {
20234:     return mInner->GetInternalNSEvent();
16665:   }
79445:   NS_IMETHOD SetTrusted(bool aTrusted)
16665:   {
16665:     return mInner->SetTrusted(aTrusted);
16665:   }
46517:   virtual void Serialize(IPC::Message* aMsg,
79445:                          bool aSerializeInterfaceType)
46517:   {
46517:     mInner->Serialize(aMsg, aSerializeInterfaceType);
46517:   }
79445:   virtual bool Deserialize(const IPC::Message* aMsg, void** aIter)
46517:   {
46517:     return mInner->Deserialize(aMsg, aIter);
46517:   }
    1: 
    1: protected:
79614:   void WarnAboutLSProgressEvent(nsIDocument::DeprecatedOperations);
79614: 
16665:   // Use nsDOMProgressEvent so that we can forward
16665:   // most of the method calls easily.
16665:   nsRefPtr<nsDOMProgressEvent> mInner;
79614:   nsCOMPtr<nsPIDOMWindow> mWindow;
    1:   PRUint64 mCurProgress;
    1:   PRUint64 mMaxProgress;
    1: };
    1: 
82543: class nsXHRParseEndListener : public nsIDOMEventListener
82543: {
82543: public:
82543:   NS_DECL_ISUPPORTS
82543:   NS_IMETHOD HandleEvent(nsIDOMEvent *event)
82543:   {
82543:     nsCOMPtr<nsIXMLHttpRequest> xhr = do_QueryReferent(mXHR);
82543:     if (xhr) {
82543:       static_cast<nsXMLHttpRequest*>(xhr.get())->ChangeStateToDone();
82543:     }
82543:     mXHR = nsnull;
82543:     return NS_OK;
82543:   }
82543:   nsXHRParseEndListener(nsIXMLHttpRequest* aXHR)
82543:     : mXHR(do_GetWeakReference(aXHR)) {}
82543:   virtual ~nsXHRParseEndListener() {}
82543: private:
82543:   nsWeakPtr mXHR;
82543: };
82543: 
    1: #endif
