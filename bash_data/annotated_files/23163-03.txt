    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
 6350:  *   L. David Baron <dbaron@dbaron.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * a node in the lexicographic tree of rules that match an element,
    1:  * responsible for converting the rules' information into computed style
    1:  */
    1: 
    1: #ifndef nsRuleNode_h___
    1: #define nsRuleNode_h___
    1: 
    1: #include "nsPresContext.h"
    1: #include "nsStyleStruct.h"
    1: 
    1: class nsStyleContext;
    1: struct PLDHashTable;
    1: class nsILanguageAtomService;
    1: struct nsRuleData;
    1: class nsIStyleRule;
    1: struct nsCSSStruct;
15699: struct nsCSSValueList;
    1: // Copy of typedef that's in nsCSSStruct.h, for compilation speed.
    1: typedef nsCSSStruct nsRuleDataStruct;
    1: 
    1: struct nsRuleDataFont;
    1: class nsCSSValue;
 3133: struct nsCSSRect;
    1: 
    1: struct nsInheritedStyleData
    1: {
    1: 
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args) \
    1:   nsStyle##name * m##name##Data;
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_INHERITED
    1: #undef STYLE_STRUCT_RESET
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
  731:   }
    1: 
    1:   void ClearInheritedData(PRUint32 aBits) {
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args) \
    1:     if (m##name##Data && (aBits & NS_STYLE_INHERIT_BIT(name))) \
    1:       m##name##Data = nsnull;
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_INHERITED
    1: #undef STYLE_STRUCT_RESET
  731:   }
    1: 
    1:   void Destroy(PRUint32 aBits, nsPresContext* aContext) {
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args) \
    1:     if (m##name##Data && !(aBits & NS_STYLE_INHERIT_BIT(name))) \
    1:       m##name##Data->Destroy(aContext);
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_INHERITED
    1: #undef STYLE_STRUCT_RESET
    1: 
    1:     aContext->FreeToShell(sizeof(nsInheritedStyleData), this);
  731:   }
    1: 
    1:   nsInheritedStyleData() {
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args) \
    1:     m##name##Data = nsnull;
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_INHERITED
    1: #undef STYLE_STRUCT_RESET
    1: 
  731:   }
    1: };
    1: 
    1: struct nsResetStyleData
    1: {
    1:   nsResetStyleData()
    1:   {
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args) \
    1:     m##name##Data = nsnull;
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_RESET
    1: #undef STYLE_STRUCT_INHERITED
  731:   }
    1: 
    1:   void* operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:     return aContext->AllocateFromShell(sz);
    1:   }
    1: 
    1:   void ClearInheritedData(PRUint32 aBits) {
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args) \
    1:     if (m##name##Data && (aBits & NS_STYLE_INHERIT_BIT(name))) \
    1:       m##name##Data = nsnull;
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_RESET
    1: #undef STYLE_STRUCT_INHERITED
  731:   }
    1: 
    1:   void Destroy(PRUint32 aBits, nsPresContext* aContext) {
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args) \
    1:     if (m##name##Data && !(aBits & NS_STYLE_INHERIT_BIT(name))) \
    1:       m##name##Data->Destroy(aContext);
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_RESET
    1: #undef STYLE_STRUCT_INHERITED
    1: 
    1:     aContext->FreeToShell(sizeof(nsResetStyleData), this);
  731:   }
    1: 
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args) \
    1:   nsStyle##name * m##name##Data;
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_RESET
    1: #undef STYLE_STRUCT_INHERITED
    1: 
    1: };
    1: 
    1: struct nsCachedStyleData
    1: {
    1:   struct StyleStructInfo {
    1:     ptrdiff_t mCachedStyleDataOffset;
    1:     ptrdiff_t mInheritResetOffset;
    1:     PRBool    mIsReset;
    1:   };
    1: 
    1:   static StyleStructInfo gInfo[];
    1: 
    1:   nsInheritedStyleData* mInheritedData;
    1:   nsResetStyleData* mResetData;
    1: 
    1:   static PRBool IsReset(const nsStyleStructID& aSID) {
    1:     return gInfo[aSID].mIsReset;
  731:   }
    1: 
    1:   static PRUint32 GetBitForSID(const nsStyleStructID& aSID) {
    1:     return 1 << aSID;
  731:   }
    1: 
10152:   NS_HIDDEN_(void*) NS_FASTCALL GetStyleData(const nsStyleStructID& aSID) {
    1:     // Each struct is stored at this.m##type##Data->m##name##Data where
    1:     // |type| is either Inherit or Reset, and |name| is the name of the
    1:     // style struct.  The |gInfo| stores the offset of the appropriate
    1:     // m##type##Data for the struct within nsCachedStyleData (|this|)
    1:     // and the offset of the appropriate m##name##Data within the
    1:     // m##type##Data.  Note that if we don't have any reset structs,
    1:     // then mResetData is null, and likewise for mInheritedData.  This
    1:     // saves us from having to go through the long if-else cascade into
    1:     // which most compilers will turn a case statement.
    1: 
    1:     // NOTE:  nsStyleContext::SetStyle works roughly the same way.
    1: 
    1:     const StyleStructInfo& info = gInfo[aSID];
    1: 
    1:     // Get either &mInheritedData or &mResetData.
 3233:     char* resetOrInheritSlot = reinterpret_cast<char*>(this) + info.mCachedStyleDataOffset;
    1: 
    1:     // Get either mInheritedData or mResetData.
 3233:     char* resetOrInherit = reinterpret_cast<char*>(*reinterpret_cast<void**>(resetOrInheritSlot));
    1: 
10152:     void* data = nsnull;
    1:     if (resetOrInherit) {
    1:       // If we have the mInheritedData or mResetData, then we might have
    1:       // the struct, so get it.
    1:       char* dataSlot = resetOrInherit + info.mInheritResetOffset;
10152:       data = *reinterpret_cast<void**>(dataSlot);
    1:     }
    1:     return data;
  731:   }
    1: 
    1:   // Typesafe and faster versions of the above
    1:   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)       \
    1:     NS_HIDDEN_(nsStyle##name_ *) NS_FASTCALL GetStyle##name_ () {        \
    1:       return mInheritedData ? mInheritedData->m##name_##Data : nsnull;   \
    1:     }
    1:   #define STYLE_STRUCT_RESET(name_, checkdata_cb_, ctor_args_)           \
    1:     NS_HIDDEN_(nsStyle##name_ *) NS_FASTCALL GetStyle##name_ () {        \
    1:       return mResetData ? mResetData->m##name_##Data : nsnull;           \
    1:     }
    1:   #include "nsStyleStructList.h"
    1:   #undef STYLE_STRUCT_RESET
    1:   #undef STYLE_STRUCT_INHERITED
    1: 
    1:   NS_HIDDEN_(void) ClearInheritedData(PRUint32 aBits) {
    1:     if (mResetData)
    1:       mResetData->ClearInheritedData(aBits);
    1:     if (mInheritedData)
    1:       mInheritedData->ClearInheritedData(aBits);
    1:   }
    1: 
    1:   NS_HIDDEN_(void) Destroy(PRUint32 aBits, nsPresContext* aContext) {
    1:     if (mResetData)
    1:       mResetData->Destroy(aBits, aContext);
    1:     if (mInheritedData)
    1:       mInheritedData->Destroy(aBits, aContext);
    1:     mResetData = nsnull;
    1:     mInheritedData = nsnull;
    1:   }
    1: 
  731:   nsCachedStyleData() :mInheritedData(nsnull), mResetData(nsnull) {}
  731:   ~nsCachedStyleData() {}
    1: };
    1: 
    1: /**
    1:  * nsRuleNode is a node in a lexicographic tree (the "rule tree")
    1:  * indexed by style rules (implementations of nsIStyleRule).
    1:  *
    1:  * The rule tree is owned by the nsStyleSet and is destroyed when the
    1:  * presentation of the document goes away.  It is garbage-collected
    1:  * (using mark-and-sweep garbage collection) during the lifetime of the
    1:  * document (when dynamic changes cause the destruction of enough style
    1:  * contexts).  Rule nodes are marked if they are pointed to by a style
    1:  * context or one of their descendants is.
    1:  *
    1:  * An nsStyleContext, which represents the computed style data for an
    1:  * element, points to an nsRuleNode.  The path from the root of the rule
    1:  * tree to the nsStyleContext's mRuleNode gives the list of the rules
    1:  * matched, from least important in the cascading order to most
    1:  * important in the cascading order.
    1:  *
    1:  * The reason for using a lexicographic tree is that it allows for
    1:  * sharing of style data, which saves both memory (for storing the
    1:  * computed style data) and time (for computing them).  This sharing
    1:  * depends on the computed style data being stored in structs (nsStyle*)
    1:  * that contain only properties that are inherited by default
    1:  * ("inherited structs") or structs that contain only properties that
    1:  * are not inherited by default ("reset structs").  The optimization
    1:  * depends on the normal case being that style rules specify relatively
    1:  * few properties and even that elements generally have relatively few
    1:  * properties specified.  This allows sharing in the following ways:
    1:  *   1. [mainly reset structs] When a style data struct will contain the
    1:  *      same computed value for any elements that match the same set of
    1:  *      rules (common for reset structs), it can be stored on the
    1:  *      nsRuleNode instead of on the nsStyleContext.
    1:  *   2. [only? reset structs] When (1) occurs, and an nsRuleNode doesn't
    1:  *      have any rules that change the values in the struct, the
    1:  *      nsRuleNode can share that struct with its parent nsRuleNode.
    1:  *   3. [mainly inherited structs] When an element doesn't match any
    1:  *      rules that change the value of a property (or, in the edge case,
    1:  *      when all the values specified are 'inherit'), the nsStyleContext
    1:  *      can use the same nsStyle* struct as its parent nsStyleContext.
    1:  *
    1:  * Since the data represented by an nsIStyleRule are immutable, the data
 6350:  * represented by an nsRuleNode are also immutable.
    1:  */
    1: 
    1: class nsRuleNode {
    1: public:
    1:   enum RuleDetail {
    1:     eRuleNone, // No props have been specified at all.
    1:     eRulePartialReset, // At least one prop with a non-"inherit" value
    1:                        // has been specified.  No props have been
    1:                        // specified with an "inherit" value.  At least
    1:                        // one prop remains unspecified.
    1:     eRulePartialMixed, // At least one prop with a non-"inherit" value
    1:                        // has been specified.  Some props may also have
    1:                        // been specified with an "inherit" value.  At
    1:                        // least one prop remains unspecified.
    1:     eRulePartialInherited, // Only props with "inherit" values have
    1:                            // have been specified.  At least one prop
    1:                            // remains unspecified.
    1:     eRuleFullReset, // All props have been specified.  None has an
    1:                     // "inherit" value.
    1:     eRuleFullMixed, // All props have been specified.  At least one has
    1:                     // a non-"inherit" value.
    1:     eRuleFullInherited  // All props have been specified with "inherit"
    1:                         // values.
    1:   };
    1: 
    1: private:
    1:   nsPresContext* mPresContext; // Our pres context.
    1: 
    1:   nsRuleNode* mParent; // A pointer to the parent node in the tree.
    1:                        // This enables us to walk backwards from the
    1:                        // most specific rule matched to the least
    1:                        // specific rule (which is the optimal order to
    1:                        // use for lookups of style properties.
    1:   nsIStyleRule* mRule; // [STRONG] A pointer to our specific rule.
    1: 
15903:   nsRuleNode* mNextSibling; // This value should be used only by the
15903:                             // parent, since the parent may store
15903:                             // children in a hash, which means this
15903:                             // pointer is not meaningful.  Order of
15903:                             // siblings is also not meaningful.
15903: 
 1539:   struct Key {
 1539:     nsIStyleRule* mRule;
 1539:     PRUint8 mLevel;
 1539:     PRPackedBool mIsImportantRule;
 1539: 
 1539:     Key(nsIStyleRule* aRule, PRUint8 aLevel, PRPackedBool aIsImportantRule)
 1539:       : mRule(aRule), mLevel(aLevel), mIsImportantRule(aIsImportantRule)
 1539:     {}
 1539: 
 1539:     PRBool operator==(const Key& aOther) const
 1539:     {
 1539:       return mRule == aOther.mRule &&
 1539:              mLevel == aOther.mLevel &&
 1539:              mIsImportantRule == aOther.mIsImportantRule;
 1539:     }
 1539: 
 1539:     PRBool operator!=(const Key& aOther) const
 1539:     {
 1539:       return !(*this == aOther);
 1539:     }
 1539:   };
 1539: 
20261:   static PLDHashNumber
 1539:   ChildrenHashHashKey(PLDHashTable *aTable, const void *aKey);
 1539: 
20261:   static PRBool
 1539:   ChildrenHashMatchEntry(PLDHashTable *aTable,
 1539:                          const PLDHashEntryHdr *aHdr,
 1539:                          const void *aKey);
 1539: 
 1539:   static PLDHashTableOps ChildrenHashOps;
 1539: 
20261:   static PLDHashOperator
15904:   EnqueueRuleNodeChildren(PLDHashTable *table, PLDHashEntryHdr *hdr,
15904:                           PRUint32 number, void *arg);
15904: 
 1539:   Key GetKey() const {
 1539:     return Key(mRule, GetLevel(), IsImportantRule());
 1539:   }
 1539: 
    1:   // The children of this node are stored in either a hashtable or list
    1:   // that maps from rules to our nsRuleNode children.  When matching
    1:   // rules, we use this mapping to transition from node to node
    1:   // (constructing new nodes as needed to flesh out the tree).
    1: 
20114:   union {
20114:     void* asVoid;
20114:     nsRuleNode* asList;
20114:     PLDHashTable* asHash;
20114:   } mChildren; // Accessed only through the methods below.
    1: 
    1:   enum {
    1:     kTypeMask = 0x1,
    1:     kListType = 0x0,
    1:     kHashType = 0x1
    1:   };
    1:   enum {
    1:     // Maximum to have in a list before converting to a hashtable.
    1:     // XXX Need to optimize this.
    1:     kMaxChildrenInList = 32
    1:   };
    1: 
23163:   PRBool HaveChildren() const {
20114:     return mChildren.asVoid != nsnull;
    1:   }
    1:   PRBool ChildrenAreHashed() {
20114:     return (PRWord(mChildren.asVoid) & kTypeMask) == kHashType;
    1:   }
15903:   nsRuleNode* ChildrenList() {
20114:     return mChildren.asList;
    1:   }
15903:   nsRuleNode** ChildrenListPtr() {
20114:     return &mChildren.asList;
    1:   }
    1:   PLDHashTable* ChildrenHash() {
20114:     return (PLDHashTable*) (PRWord(mChildren.asHash) & ~PRWord(kTypeMask));
    1:   }
15903:   void SetChildrenList(nsRuleNode *aList) {
    1:     NS_ASSERTION(!(PRWord(aList) & kTypeMask),
    1:                  "pointer not 2-byte aligned");
20114:     mChildren.asList = aList;
    1:   }
    1:   void SetChildrenHash(PLDHashTable *aHashtable) {
    1:     NS_ASSERTION(!(PRWord(aHashtable) & kTypeMask),
    1:                  "pointer not 2-byte aligned");
20114:     mChildren.asHash = (PLDHashTable*)(PRWord(aHashtable) | kHashType);
    1:   }
    1:   void ConvertChildrenToHash();
    1: 
    1:   nsCachedStyleData mStyleData;   // Any data we cached on the rule node.
    1: 
    1:   PRUint32 mDependentBits; // Used to cache the fact that we can look up
    1:                            // cached data under a parent rule.
    1: 
    1:   PRUint32 mNoneBits; // Used to cache the fact that the branch to this
    1:                       // node specifies no non-inherited data for a
    1:                       // given struct type.  (This usually implies that
    1:                       // the entire branch specifies no non-inherited
    1:                       // data, although not necessarily, if a
    1:                       // non-inherited value is overridden by an
    1:                       // explicit 'inherit' value.)  For example, if an
    1:                       // entire rule branch specifies no color
    1:                       // information, then a bit will be set along every
    1:                       // rule node on that branch, so that you can break
    1:                       // out of the rule tree early and just inherit
    1:                       // from the parent style context.  The presence of
    1:                       // this bit means we should just get inherited
    1:                       // data from the parent style context, and it is
    1:                       // never used for reset structs since their
    1:                       // Compute*Data functions don't initialize from
    1:                       // inherited data.
    1: 
    1: public:
    1:   // Overloaded new operator. Initializes the memory to 0 and relies on an arena
    1:   // (which comes from the presShell) to perform the allocation.
    1:   NS_HIDDEN_(void*) operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW;
15904:   NS_HIDDEN_(void) Destroy() { DestroyInternal(nsnull); }
    1:   static NS_HIDDEN_(nsILanguageAtomService*) gLangService;
    1: 
    1: protected:
15904:   NS_HIDDEN_(void) DestroyInternal(nsRuleNode ***aDestroyQueueTail);
    1:   NS_HIDDEN_(void) PropagateDependentBit(PRUint32 aBit,
    1:                                          nsRuleNode* aHighestNode);
    1:   NS_HIDDEN_(void) PropagateNoneBit(PRUint32 aBit, nsRuleNode* aHighestNode);
    1:   
10152:   NS_HIDDEN_(const void*) SetDefaultOnRoot(const nsStyleStructID aSID,
    1:                                                  nsStyleContext* aContext);
    1: 
10152:   NS_HIDDEN_(const void*)
    1:     WalkRuleTree(const nsStyleStructID aSID, nsStyleContext* aContext, 
    1:                  nsRuleData* aRuleData, nsRuleDataStruct* aSpecificData);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeDisplayData(void* aStartStruct,
    1:                        const nsRuleDataStruct& aData,
    1:                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                        RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeVisibilityData(void* aStartStruct,
    1:                           const nsRuleDataStruct& aData,
    1:                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                           RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeFontData(void* aStartStruct,
    1:                     const nsRuleDataStruct& aData,
    1:                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                     RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeColorData(void* aStartStruct,
    1:                      const nsRuleDataStruct& aData,
    1:                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                      RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeBackgroundData(void* aStartStruct,
    1:                           const nsRuleDataStruct& aData, 
    1:                           nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                           RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeMarginData(void* aStartStruct,
    1:                       const nsRuleDataStruct& aData, 
    1:                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                       RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeBorderData(void* aStartStruct,
    1:                       const nsRuleDataStruct& aData, 
    1:                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                       RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputePaddingData(void* aStartStruct,
    1:                        const nsRuleDataStruct& aData, 
    1:                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                        RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeOutlineData(void* aStartStruct,
    1:                        const nsRuleDataStruct& aData, 
    1:                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                        RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeListData(void* aStartStruct,
    1:                     const nsRuleDataStruct& aData,
    1:                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                     RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputePositionData(void* aStartStruct,
    1:                         const nsRuleDataStruct& aData, 
    1:                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                         RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeTableData(void* aStartStruct,
    1:                      const nsRuleDataStruct& aData, 
    1:                      nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                      RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeTableBorderData(void* aStartStruct,
    1:                            const nsRuleDataStruct& aData, 
    1:                            nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                            RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeContentData(void* aStartStruct,
    1:                        const nsRuleDataStruct& aData,
    1:                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                        RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeQuotesData(void* aStartStruct,
    1:                       const nsRuleDataStruct& aData, 
    1:                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                       RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeTextData(void* aStartStruct,
    1:                     const nsRuleDataStruct& aData, 
    1:                     nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                     RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeTextResetData(void* aStartStruct,
    1:                          const nsRuleDataStruct& aData,
    1:                          nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                          RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeUserInterfaceData(void* aStartStruct,
    1:                              const nsRuleDataStruct& aData, 
    1:                              nsStyleContext* aContext,
    1:                              nsRuleNode* aHighestNode,
 3748:                              RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeUIResetData(void* aStartStruct,
    1:                        const nsRuleDataStruct& aData,
    1:                        nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                        RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeXULData(void* aStartStruct,
    1:                    const nsRuleDataStruct& aData, 
    1:                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                    RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeColumnData(void* aStartStruct,
    1:                       const nsRuleDataStruct& aData,
    1:                       nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                       RuleDetail aRuleDetail, PRBool aInherited);
    1: 
    1: #ifdef MOZ_SVG
10152:   NS_HIDDEN_(const void*)
10152:     ComputeSVGData(void* aStartStruct,
    1:                    const nsRuleDataStruct& aData, 
    1:                    nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                    RuleDetail aRuleDetail, PRBool aInherited);
    1: 
10152:   NS_HIDDEN_(const void*)
10152:     ComputeSVGResetData(void* aStartStruct,
    1:                         const nsRuleDataStruct& aData, 
    1:                         nsStyleContext* aContext, nsRuleNode* aHighestNode,
 3748:                         RuleDetail aRuleDetail, PRBool aInherited);
    1: #endif
    1: 
    1:   // helpers for |ComputeFontData| that need access to |mNoneBits|:
10073:   static NS_HIDDEN_(void) SetFontSize(nsPresContext* aPresContext,
10073:                                       const nsRuleDataFont& aFontData,
10073:                                       const nsStyleFont* aFont,
10073:                                       const nsStyleFont* aParentFont,
10073:                                       nscoord* aSize,
10073:                                       const nsFont& aSystemFont,
10073:                                       nscoord aParentSize,
10073:                                       nscoord aScriptLevelAdjustedParentSize,
10073:                                       PRBool aUsedStartStruct,
10073:                                       PRBool& aInherited);
10073: 
    1:   static NS_HIDDEN_(void) SetFont(nsPresContext* aPresContext,
    1:                                   nsStyleContext* aContext,
    1:                                   nscoord aMinFontSize,
 3987:                                   PRUint8 aGenericFontID,
    1:                                   const nsRuleDataFont& aFontData,
    1:                                   const nsStyleFont* aParentFont,
10073:                                   nsStyleFont* aFont,
10073:                                   PRBool aStartStruct, PRBool& aInherited);
    1: 
    1:   static NS_HIDDEN_(void) SetGenericFont(nsPresContext* aPresContext,
    1:                                          nsStyleContext* aContext,
    1:                                          PRUint8 aGenericFontID,
    1:                                          nscoord aMinFontSize,
    1:                                          nsStyleFont* aFont);
    1: 
    1:   NS_HIDDEN_(void) AdjustLogicalBoxProp(nsStyleContext* aContext,
    1:                                         const nsCSSValue& aLTRSource,
    1:                                         const nsCSSValue& aRTLSource,
    1:                                         const nsCSSValue& aLTRLogicalValue,
    1:                                         const nsCSSValue& aRTLLogicalValue,
    1:                                         PRUint8 aSide,
 3133:                                         nsCSSRect& aValueRect,
    1:                                         PRBool& aInherited);
    1: 
    1:   inline RuleDetail CheckSpecifiedProperties(const nsStyleStructID aSID, const nsRuleDataStruct& aRuleDataStruct);
    1: 
10152:   NS_HIDDEN_(const void*) GetParentData(const nsStyleStructID aSID);
    1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
    1:     NS_HIDDEN_(const nsStyle##name_*) GetParent##name_();
    1:   #include "nsStyleStructList.h"
    1:   #undef STYLE_STRUCT  
    1: 
10152:   NS_HIDDEN_(const void*) GetDisplayData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetVisibilityData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetFontData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetColorData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetBackgroundData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetMarginData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetBorderData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetPaddingData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetOutlineData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetListData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetPositionData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetTableData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetTableBorderData(nsStyleContext* aContext);
    1: 
10152:   NS_HIDDEN_(const void*) GetContentData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetQuotesData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetTextData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetTextResetData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetUserInterfaceData(nsStyleContext* aContext);
    1: 
10152:   NS_HIDDEN_(const void*) GetUIResetData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetXULData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetColumnData(nsStyleContext* aContext);
    1: #ifdef MOZ_SVG
10152:   NS_HIDDEN_(const void*) GetSVGData(nsStyleContext* aContext);
10152:   NS_HIDDEN_(const void*) GetSVGResetData(nsStyleContext* aContext);
    1: #endif
    1: 
15699:   NS_HIDDEN_(already_AddRefed<nsCSSShadowArray>)
15699:                           GetShadowData(nsCSSValueList* aList,
15699:                                         nsStyleContext* aContext,
15699:                                         PRBool aUsesSpread,
15699:                                         PRBool& inherited);
15699: 
    1: private:
 1539:   nsRuleNode(nsPresContext* aPresContext, nsRuleNode* aParent,
 1539:              nsIStyleRule* aRule, PRUint8 aLevel, PRBool aIsImportant)
 1539:     NS_HIDDEN;
    1:   ~nsRuleNode() NS_HIDDEN;
    1: 
    1: public:
    1:   static NS_HIDDEN_(nsRuleNode*) CreateRootNode(nsPresContext* aPresContext);
    1: 
 1539:   NS_HIDDEN_(nsRuleNode*) Transition(nsIStyleRule* aRule, PRUint8 aLevel,
 1539:                                      PRPackedBool aIsImportantRule);
    1:   nsRuleNode* GetParent() const { return mParent; }
    1:   PRBool IsRoot() const { return mParent == nsnull; }
    1: 
 1539:   // These PRUint8s are really nsStyleSet::sheetType values.
 1539:   PRUint8 GetLevel() const { 
 1539:     NS_ASSERTION(!IsRoot(), "can't call on root");
 1539:     return (mDependentBits & NS_RULE_NODE_LEVEL_MASK) >>
 1539:              NS_RULE_NODE_LEVEL_SHIFT;
 1539:   }
 1539:   PRBool IsImportantRule() const {
 1539:     NS_ASSERTION(!IsRoot(), "can't call on root");
 1539:     return (mDependentBits & NS_RULE_NODE_IS_IMPORTANT) != 0;
 1539:   }
 1539: 
    1:   // NOTE:  Does not |AddRef|.
    1:   nsIStyleRule* GetRule() const { return mRule; }
    1:   // NOTE: Does not |AddRef|.
    1:   nsPresContext* GetPresContext() const { return mPresContext; }
    1: 
10152:   NS_HIDDEN_(const void*) GetStyleData(nsStyleStructID aSID, 
    1:                                        nsStyleContext* aContext,
    1:                                        PRBool aComputeData);
    1: 
    1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
    1:     NS_HIDDEN_(const nsStyle##name_*)                                         \
    1:       GetStyle##name_(nsStyleContext* aContext,                               \
    1:                       PRBool aComputeData);
    1:   #include "nsStyleStructList.h"
    1:   #undef STYLE_STRUCT  
    1: 
    1:   /*
    1:    * Garbage collection.  Mark walks up the tree, marking any unmarked
    1:    * ancestors until it reaches a marked one.  Sweep recursively sweeps
    1:    * the children, destroys any that are unmarked, and clears marks,
    1:    * returning true if the node on which it was called was destroyed.
    1:    */
    1:   NS_HIDDEN_(void) Mark();
    1:   NS_HIDDEN_(PRBool) Sweep();
 6734: 
 6734:   static PRBool
14697:     HasAuthorSpecifiedRules(nsStyleContext* aStyleContext, PRUint32 ruleTypeMask);
16222: 
16222:   // Expose this so media queries can use it
16222:   static nscoord CalcLengthWithInitialFont(nsPresContext* aPresContext,
16222:                                            const nsCSSValue& aValue);
19214:   // Expose this so nsTransformFunctions can use it.
19214:   static nscoord CalcLength(const nsCSSValue& aValue,
19214:                             nsStyleContext* aStyleContext,
19214:                             nsPresContext* aPresContext,
19214:                             PRBool& aInherited);
23163: 
23163:   // Return whether the rule tree for which this node is the root has
23163:   // cached data such that we need to do dynamic change handling for
23163:   // changes that change the results of media queries or require
23163:   // rebuilding all style data.
23163:   PRBool TreeHasCachedData() const {
23163:     NS_ASSERTION(IsRoot(), "should only be called on root of rule tree");
23163:     return HaveChildren() || mStyleData.mInheritedData || mStyleData.mResetData;
23163:   }
    1: };
    1: 
    1: #endif
