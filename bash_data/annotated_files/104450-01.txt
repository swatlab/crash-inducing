  3863: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  3863: 
 79570: #include "mozilla/dom/CrashReporterChild.h"
 80922: #include "mozilla/Services.h"
 80922: #include "nsIObserverService.h"
 80467: #include "mozilla/Util.h"
 80467: 
 79570: #include "nsXULAppAPI.h"
 79570: 
  4389: #include "nsExceptionHandler.h"
 79570: #include "nsThreadUtils.h"
  3863: 
  3879: #if defined(XP_WIN32)
  3863: #ifdef WIN32_LEAN_AND_MEAN
  3863: #undef WIN32_LEAN_AND_MEAN
  3863: #endif
  3863: 
 38030: #include "nsIWindowsRegKey.h"
 37203: #include "client/windows/crash_generation/crash_generation_server.h"
  3863: #include "client/windows/handler/exception_handler.h"
 37203: #include <DbgHelp.h>
  3863: #include <string.h>
104355: #include "nsDirectoryServiceUtils.h"
 97427: 
 97427: #include "nsWindowsDllInterceptor.h"
  3879: #elif defined(XP_MACOSX)
 50679: #include "client/mac/crash_generation/client_info.h"
 50679: #include "client/mac/crash_generation/crash_generation_server.h"
  3879: #include "client/mac/handler/exception_handler.h"
  3879: #include <string>
  3879: #include <Carbon/Carbon.h>
 43879: #include <CoreFoundation/CoreFoundation.h>
 54878: #include <crt_externs.h>
  3879: #include <fcntl.h>
 51563: #include <mach/mach.h>
  3916: #include <sys/types.h>
 54878: #include <spawn.h>
  3916: #include <unistd.h>
  3908: #include "mac_utils.h"
  3892: #elif defined(XP_LINUX)
 38030: #include "nsDirectoryServiceDefs.h"
 38030: #include "nsIINIParser.h"
 48719: #include "common/linux/linux_libc_support.h"
 48719: #include "common/linux/linux_syscall_support.h"
 37382: #include "client/linux/crash_generation/client_info.h"
 37203: #include "client/linux/crash_generation/crash_generation_server.h"
  3892: #include "client/linux/handler/exception_handler.h"
 58170: #include "client/linux/minidump_writer/linux_dumper.h"
 58170: #include "client/linux/minidump_writer/minidump_writer.h"
  3892: #include <fcntl.h>
  3916: #include <sys/types.h>
  3916: #include <unistd.h>
 13348: #elif defined(XP_SOLARIS)
 13348: #include "client/solaris/handler/exception_handler.h"
 13348: #include <fcntl.h>
 13348: #include <sys/types.h>
 13348: #include <unistd.h>
  3866: #else
  3866: #error "Not yet implemented for this platform"
  3879: #endif // defined(XP_WIN32)
  3866: 
103451: #ifdef MOZ_CRASHREPORTER_INJECTOR
103451: #include "InjectCrashReporter.h"
103451: using mozilla::InjectCrashRunnable;
103451: #endif
103451: 
  3863: #include <stdlib.h>
  3934: #include <time.h>
  3863: #include <prenv.h>
  3927: #include <prio.h>
  7861: #include <prmem.h>
 37382: #include "mozilla/Mutex.h"
  3863: #include "nsDebug.h"
  3866: #include "nsCRT.h"
101111: #include "nsIFile.h"
 37382: #include "nsIFileStreams.h"
 37382: #include "nsInterfaceHashtable.h"
 37208: #include "prprf.h"
 38030: #include "nsIXULAppInfo.h"
 58170: #include <map>
 56284: #include <vector>
  3863: 
 88073: #include "mozilla/mozalloc_oom.h"
103475: #include "mozilla/mozPoisonWrite.h"
 88073: 
 43879: #if defined(XP_MACOSX)
 43879: CFStringRef reporterClientAppID = CFSTR("org.mozilla.crashreporter");
 43879: #endif
 43879: 
 43880: #include "nsIUUIDGenerator.h"
 43880: 
 37203: using google_breakpad::CrashGenerationServer;
 37203: using google_breakpad::ClientInfo;
 80467: using namespace mozilla;
 79570: using mozilla::dom::CrashReporterChild;
 79570: using mozilla::dom::PCrashReporterChild;
 37203: 
  3879: namespace CrashReporter {
  3879: 
  3871: #ifdef XP_WIN32
  3879: typedef wchar_t XP_CHAR;
 39791: typedef std::wstring xpstring;
  3879: #define CONVERT_UTF16_TO_XP_CHAR(x) x
 26867: #define CONVERT_XP_CHAR_TO_UTF16(x) x
  3879: #define XP_STRLEN(x) wcslen(x)
 50349: #define my_strlen strlen
  3871: #define CRASH_REPORTER_FILENAME "crashreporter.exe"
  3871: #define PATH_SEPARATOR "\\"
  3879: #define XP_PATH_SEPARATOR L"\\"
  3879: // sort of arbitrary, but MAX_PATH is kinda small
  3879: #define XP_PATH_MAX 4096
  3879: // "<reporter path>" "<minidump path>"
  3879: #define CMDLINE_SIZE ((XP_PATH_MAX * 2) + 6)
  5437: #ifdef _USE_32BIT_TIME_T
  5437: #define XP_TTOA(time, buffer, base) ltoa(time, buffer, base)
  5437: #else
  5437: #define XP_TTOA(time, buffer, base) _i64toa(time, buffer, base)
  5437: #endif
 88073: #define XP_STOA(size, buffer, base) _ui64toa(size, buffer, base)
  3871: #else
  3879: typedef char XP_CHAR;
 39791: typedef std::string xpstring;
  3879: #define CONVERT_UTF16_TO_XP_CHAR(x) NS_ConvertUTF16toUTF8(x)
 26867: #define CONVERT_XP_CHAR_TO_UTF16(x) NS_ConvertUTF8toUTF16(x)
  3871: #define CRASH_REPORTER_FILENAME "crashreporter"
  3871: #define PATH_SEPARATOR "/"
  3879: #define XP_PATH_SEPARATOR "/"
  3879: #define XP_PATH_MAX PATH_MAX
 48719: #ifdef XP_LINUX
 48719: #define XP_STRLEN(x) my_strlen(x)
 88073: #define XP_TTOA(time, buffer, base) my_inttostring(time, buffer, sizeof(buffer))
 88073: #define XP_STOA(size, buffer, base) my_inttostring(size, buffer, sizeof(buffer))
 48719: #else
 48719: #define XP_STRLEN(x) strlen(x)
  5437: #define XP_TTOA(time, buffer, base) sprintf(buffer, "%ld", time)
 88073: #define XP_STOA(size, buffer, base) sprintf(buffer, "%zu", size)
 50349: #define my_strlen strlen
 48719: #define sys_close close
 48719: #define sys_fork fork
 48719: #define sys_open open
 48719: #define sys_write write
 48719: #endif
  3879: #endif // XP_WIN32
  3871: 
  3879: static const XP_CHAR dumpFileExtension[] = {'.', 'd', 'm', 'p',
  3879:                                             '\0'}; // .dmp
  3879: static const XP_CHAR extraFileExtension[] = {'.', 'e', 'x', 't',
  3866:                                              'r', 'a', '\0'}; // .extra
  3866: 
  3869: static google_breakpad::ExceptionHandler* gExceptionHandler = nsnull;
  3866: 
104355: static XP_CHAR* pendingDirectory;
  3879: static XP_CHAR* crashReporterPath;
  3866: 
  3881: // if this is false, we don't launch the crash reporter
  3881: static bool doReport = true;
  3881: 
  3908: // if this is true, we pass the exception on to the OS crash reporter
  3908: static bool showOSCrashReporter = false;
  3908: 
  5437: // The time of the last recorded crash, as a time_t value.
  5437: static time_t lastCrashTime = 0;
  5437: // The pathname of a file to store the crash time in
  5437: static XP_CHAR lastCrashTimeFilename[XP_PATH_MAX] = {0};
  5437: 
  5437: // these are just here for readability
  5437: static const char kCrashTimeParameter[] = "CrashTime=";
  5437: static const int kCrashTimeParameterLen = sizeof(kCrashTimeParameter)-1;
  5437: 
  5437: static const char kTimeSinceLastCrashParameter[] = "SecondsSinceLastCrash=";
  5437: static const int kTimeSinceLastCrashParameterLen =
  5437:                                      sizeof(kTimeSinceLastCrashParameter)-1;
  5437: 
 59605: static const char kSysMemoryParameter[] = "SystemMemoryUsePercentage=";
 59605: static const int kSysMemoryParameterLen = sizeof(kSysMemoryParameter)-1;
 59605: 
 59605: static const char kTotalVirtualMemoryParameter[] = "TotalVirtualMemory=";
 59605: static const int kTotalVirtualMemoryParameterLen =
 59605:   sizeof(kTotalVirtualMemoryParameter)-1;
 59605: 
 59605: static const char kAvailableVirtualMemoryParameter[] = "AvailableVirtualMemory=";
 59605: static const int kAvailableVirtualMemoryParameterLen =
 59605:   sizeof(kAvailableVirtualMemoryParameter)-1;
 59605: 
 88073: static const char kOOMAllocationSizeParameter[] = "OOMAllocationSize=";
 88073: static const int kOOMAllocationSizeParameterLen =
 88073:   sizeof(kOOMAllocationSizeParameter)-1;
 88073: 
 88186: static const char kAvailablePageFileParameter[] = "AvailablePageFile=";
 88186: static const int kAvailablePageFileParameterLen =
 88186:   sizeof(kAvailablePageFileParameter)-1;
 88186: 
 88186: static const char kAvailablePhysicalMemoryParameter[] = "AvailablePhysicalMemory=";
 88186: static const int kAvailablePhysicalMemoryParameterLen =
 88186:   sizeof(kAvailablePhysicalMemoryParameter)-1;
 88186: 
  3866: // this holds additional data sent via the API
 82630: static Mutex* crashReporterAPILock;
 88178: static Mutex* notesFieldLock;
 39792: static AnnotationTable* crashReporterAPIData_Hash;
  3871: static nsCString* crashReporterAPIData = nsnull;
 16248: static nsCString* notesField = nsnull;
  3866: 
 37203: // OOP crash reporting
 37203: static CrashGenerationServer* crashServer; // chrome process has this
 37203: 
 50679: #  if defined(XP_WIN) || defined(XP_MACOSX)
 37203: // If crash reporting is disabled, we hand out this "null" pipe to the
 37203: // child process and don't attempt to connect to a parent server.
 37203: static const char kNullNotifyPipe[] = "-";
 37208: static char* childCrashNotifyPipe;
 37203: 
 37203: #  elif defined(XP_LINUX)
 37203: static int serverSocketFd = -1;
 37203: static int clientSocketFd = -1;
 56695: static const int kMagicChildCrashReportFd = 4;
 50679: 
 37203: #  endif
 37382: 
 37382: // |dumpMapLock| must protect all access to |pidToMinidump|.
 37382: static Mutex* dumpMapLock;
104355: struct ChildProcessData : public nsUint32HashKey
104355: {
104355:   ChildProcessData(KeyTypePointer aKey)
104355:     : nsUint32HashKey(aKey)
104355:     , sequence(0)
104355: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355:     , callback(NULL)
104355: #endif
104355:   { }
104355: 
104355:   nsCOMPtr<nsIFile> minidump;
104355:   // Each crashing process is assigned an increasing sequence number to
104355:   // indicate which process crashed first.
104355:   PRUint32 sequence;
104355: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355:   InjectorCrashCallback* callback;
104355: #endif
104355: };
104355: 
104355: typedef nsTHashtable<ChildProcessData> ChildMinidumpMap;
 37382: static ChildMinidumpMap* pidToMinidump;
104355: static PRUint32 crashSequence;
104355: static bool OOPInitialized();
 37382: 
103451: #ifdef MOZ_CRASHREPORTER_INJECTOR
103451: static nsIThread* sInjectorThread;
103451: 
103451: class ReportInjectedCrash : public nsRunnable
103451: {
103451: public:
103451:   ReportInjectedCrash(PRUint32 pid) : mPID(pid) { }
103451: 
103451:   NS_IMETHOD Run();
103451: 
103451: private:
103451:   PRUint32 mPID;
103451: };
103451: #endif // MOZ_CRASHREPORTER_INJECTOR
103451: 
 39791: // Crashreporter annotations that we don't send along in subprocess
 39791: // reports
 39791: static const char* kSubprocessBlacklist[] = {
 39791:   "FramePoisonBase",
 39791:   "FramePoisonSize",
 39791:   "StartupTime",
 39791:   "URL"
 39791: };
 39791: 
 79570: // If annotations are attempted before the crash reporter is enabled,
 79570: // they queue up here.
 79570: class DelayedNote;
 79570: nsTArray<nsAutoPtr<DelayedNote> >* gDelayedAnnotations;
 39791: 
 97427: #if defined(XP_WIN)
 97427: // the following are used to prevent other DLLs reverting the last chance
 97427: // exception handler to the windows default. Any attempt to change the 
 97427: // unhandled exception filter or to reset it is ignored and our crash
 97427: // reporter is loaded instead (in case it became unloaded somehow)
 97427: typedef LPTOP_LEVEL_EXCEPTION_FILTER (WINAPI *SetUnhandledExceptionFilter_func)
 97427:   (LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
 97427: static SetUnhandledExceptionFilter_func stub_SetUnhandledExceptionFilter = 0;
 97427: static WindowsDllInterceptor gKernel32Intercept;
 97427: static bool gBlockUnhandledExceptionFilter = true;
 97427: 
 97427: static LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
 97427: patched_SetUnhandledExceptionFilter (LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
 97427: {
 97427:   if (!gBlockUnhandledExceptionFilter ||
 97427:       lpTopLevelExceptionFilter == google_breakpad::ExceptionHandler::HandleException) {
 97427:     // don't intercept
 97427:     return stub_SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);
 97427:   }
 97427: 
 97427:   // intercept attempts to change the filter
 97427:   return NULL;
 97427: }
 97427: #endif
 97427: 
 54878: #ifdef XP_MACOSX
 54878: static cpu_type_t pref_cpu_types[2] = {
 54878: #if defined(__i386__)
 54878:                                  CPU_TYPE_X86,
 54878: #elif defined(__x86_64__)
 54878:                                  CPU_TYPE_X86_64,
 54878: #elif defined(__ppc__)
 54878:                                  CPU_TYPE_POWERPC,
 54878: #endif
 54878:                                  CPU_TYPE_ANY };
 54878: 
 54878: static posix_spawnattr_t spawnattr;
 54878: #endif
 54878: 
 56284: #if defined(__ANDROID__)
 56284: // Android builds use a custom library loader,
 56284: // so the embedding will provide a list of shared
 56284: // libraries that are mapped into anonymous mappings.
 56284: typedef struct {
 56284:   std::string name;
 56284:   std::string debug_id;
 56284:   uintptr_t   start_address;
 56284:   size_t      length;
 56284:   size_t      file_offset;
 56284: } mapping_info;
 56284: static std::vector<mapping_info> library_mappings;
 58170: typedef std::map<PRUint32,google_breakpad::MappingList> MappingMap;
 58170: static MappingMap child_library_mappings;
 56284: 
 56284: void FileIDToGUID(const char* file_id, u_int8_t guid[sizeof(MDGUID)])
 56284: {
 56284:   for (int i = 0; i < sizeof(MDGUID); i++) {
 56284:     int c;
 56284:     sscanf(file_id, "%02X", &c);
 56284:     guid[i] = (u_int8_t)(c & 0xFF);
 56284:     file_id += 2;
 56284:   }
 56368:   // GUIDs are stored in network byte order.
 56368:   uint32_t* data1 = reinterpret_cast<uint32_t*>(guid);
 56368:   *data1 = htonl(*data1);
 56368:   uint16_t* data2 = reinterpret_cast<uint16_t*>(guid + 4);
 56368:   *data2 = htons(*data2);
 56368:   uint16_t* data3 = reinterpret_cast<uint16_t*>(guid + 6);
 56368:   *data3 = htons(*data3);
 56284: }
 56284: #endif
 56284: 
 50349: #ifdef XP_LINUX
 50349: inline void
 88073: my_inttostring(intmax_t t, char* buffer, size_t buffer_length)
 50349: {
 50349:   my_memset(buffer, 0, buffer_length);
 50349:   my_itos(buffer, t, my_int_len(t));
 50349: }
 50349: #endif
 50349: 
 39791: #ifdef XP_WIN
 39791: static void
101111: CreateFileFromPath(const xpstring& path, nsIFile** file)
 39791: {
 80486:   NS_NewLocalFile(nsDependentString(path.c_str()), false, file);
 39791: }
 39791: #else
 39791: static void
101111: CreateFileFromPath(const xpstring& path, nsIFile** file)
 39791: {
 80486:   NS_NewNativeLocalFile(nsDependentCString(path.c_str()), false, file);
 39791: }
 39791: #endif
 39791: 
  3879: static XP_CHAR*
  3879: Concat(XP_CHAR* str, const XP_CHAR* toAppend, int* size)
  3879: {
  3879:   int appendLen = XP_STRLEN(toAppend);
  3879:   if (appendLen >= *size) appendLen = *size - 1;
  3879: 
  3879:   memcpy(str, toAppend, appendLen * sizeof(XP_CHAR));
  3879:   str += appendLen;
  3879:   *str = '\0';
  3879:   *size -= appendLen;
  3879: 
  3879:   return str;
  3879: }
  3879: 
 88073: static size_t gOOMAllocationSize = 0;
 88073: 
 88073: void AnnotateOOMAllocationSize(size_t size)
 88073: {
 88073:   gOOMAllocationSize = size;
 88073: }
 88073: 
  3879: bool MinidumpCallback(const XP_CHAR* dump_path,
  3879:                       const XP_CHAR* minidump_id,
  3869:                       void* context,
  3879: #ifdef XP_WIN32
  3869:                       EXCEPTION_POINTERS* exinfo,
  3869:                       MDRawAssertionInfo* assertion,
  3879: #endif
  3869:                       bool succeeded)
  3863: {
  3908:   bool returnValue = showOSCrashReporter ? false : succeeded;
  3894: 
 62059:   static XP_CHAR minidumpPath[XP_PATH_MAX];
  3879:   int size = XP_PATH_MAX;
  3879:   XP_CHAR* p = Concat(minidumpPath, dump_path, &size);
  3879:   p = Concat(p, XP_PATH_SEPARATOR, &size);
  3879:   p = Concat(p, minidump_id, &size);
  3879:   Concat(p, dumpFileExtension, &size);
  3866: 
 62059:   static XP_CHAR extraDataPath[XP_PATH_MAX];
  3879:   size = XP_PATH_MAX;
  3879:   p = Concat(extraDataPath, dump_path, &size);
  3879:   p = Concat(p, XP_PATH_SEPARATOR, &size);
  3879:   p = Concat(p, minidump_id, &size);
  3879:   Concat(p, extraFileExtension, &size);
  3866: 
 88073:   char oomAllocationSizeBuffer[32];
 88073:   int oomAllocationSizeBufferLen = 0;
 88073:   if (gOOMAllocationSize) {
 88073:     XP_STOA(gOOMAllocationSize, oomAllocationSizeBuffer, 10);
 88073:     oomAllocationSizeBufferLen = my_strlen(oomAllocationSizeBuffer);
 88073:   }
 88073: 
  5437:   // calculate time since last crash (if possible), and store
  5437:   // the time of this crash.
 48719:   time_t crashTime;
 48719: #ifdef XP_LINUX
 48719:   struct kernel_timeval tv;
 48719:   sys_gettimeofday(&tv, NULL);
 48719:   crashTime = tv.tv_sec;
 48719: #else
 48719:   crashTime = time(NULL);
 48719: #endif
  5437:   time_t timeSinceLastCrash = 0;
  5437:   // stringified versions of the above
  5437:   char crashTimeString[32];
  5437:   int crashTimeStringLen = 0;
  5437:   char timeSinceLastCrashString[32];
  5437:   int timeSinceLastCrashStringLen = 0;
  5437: 
  5437:   XP_TTOA(crashTime, crashTimeString, 10);
 50349:   crashTimeStringLen = my_strlen(crashTimeString);
  5437:   if (lastCrashTime != 0) {
  5437:     timeSinceLastCrash = crashTime - lastCrashTime;
  5437:     XP_TTOA(timeSinceLastCrash, timeSinceLastCrashString, 10);
 50349:     timeSinceLastCrashStringLen = my_strlen(timeSinceLastCrashString);
  5437:   }
  5437:   // write crash time to file
  5437:   if (lastCrashTimeFilename[0] != 0) {
  5437: #if defined(XP_WIN32)
  5437:     HANDLE hFile = CreateFile(lastCrashTimeFilename, GENERIC_WRITE, 0,
  5437:                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
  5437:                               NULL);
  5437:     if(hFile != INVALID_HANDLE_VALUE) {
  5437:       DWORD nBytes;
  5437:       WriteFile(hFile, crashTimeString, crashTimeStringLen, &nBytes, NULL);
  5437:       CloseHandle(hFile);
  5437:     }
  5437: #elif defined(XP_UNIX)
 48719:     int fd = sys_open(lastCrashTimeFilename,
  5437:                       O_WRONLY | O_CREAT | O_TRUNC,
  5437:                       0600);
  5437:     if (fd != -1) {
 48719:       ssize_t ignored = sys_write(fd, crashTimeString, crashTimeStringLen);
 37382:       (void)ignored;
 48719:       sys_close(fd);
  5437:     }
  5437: #endif
  5437:   }
  5437: 
  5437: #if defined(XP_WIN32)
  3879:   XP_CHAR cmdLine[CMDLINE_SIZE];
  3879:   size = CMDLINE_SIZE;
  3879:   p = Concat(cmdLine, L"\"", &size);
  3879:   p = Concat(p, crashReporterPath, &size);
  3879:   p = Concat(p, L"\" \"", &size);
  3879:   p = Concat(p, minidumpPath, &size);
  3879:   Concat(p, L"\"", &size);
  3879: 
  3871:   if (!crashReporterAPIData->IsEmpty()) {
  3866:     // write out API data
  3879:     HANDLE hFile = CreateFile(extraDataPath, GENERIC_WRITE, 0,
  3866:                               NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
  3866:                               NULL);
  3866:     if(hFile != INVALID_HANDLE_VALUE) {
  3866:       DWORD nBytes;
  3871:       WriteFile(hFile, crashReporterAPIData->get(),
  3871:                 crashReporterAPIData->Length(), &nBytes, NULL);
  5437:       WriteFile(hFile, kCrashTimeParameter, kCrashTimeParameterLen,
  5437:                 &nBytes, NULL);
  5437:       WriteFile(hFile, crashTimeString, crashTimeStringLen, &nBytes, NULL);
  5437:       WriteFile(hFile, "\n", 1, &nBytes, NULL);
  5437:       if (timeSinceLastCrash != 0) {
  5437:         WriteFile(hFile, kTimeSinceLastCrashParameter,
  5437:                   kTimeSinceLastCrashParameterLen, &nBytes, NULL);
  5437:         WriteFile(hFile, timeSinceLastCrashString, timeSinceLastCrashStringLen,
  5437:                   &nBytes, NULL);
  5437:         WriteFile(hFile, "\n", 1, &nBytes, NULL);
  5437:       }
 88186: 
 59605:       // Try to get some information about memory.
 59605:       MEMORYSTATUSEX statex;
 59605:       statex.dwLength = sizeof(statex);
 59605:       if (GlobalMemoryStatusEx(&statex)) {
 59605:         char buffer[128];
 59605:         int bufferLen;
 88186: 
 88186: #define WRITE_STATEX_FIELD(field, paramName, conversionFunc)  \
 88186:         WriteFile(hFile, k##paramName##Parameter,             \
 88186:                   k##paramName##ParameterLen, &nBytes, NULL); \
 88186:         conversionFunc(statex.field, buffer, 10);             \
 88186:         bufferLen = strlen(buffer);                           \
 88186:         WriteFile(hFile, buffer, bufferLen, &nBytes, NULL);   \
 59605:         WriteFile(hFile, "\n", 1, &nBytes, NULL);
 88186: 
 88186:         WRITE_STATEX_FIELD(dwMemoryLoad, SysMemory, ltoa);
 88186:         WRITE_STATEX_FIELD(ullTotalVirtual, TotalVirtualMemory, _ui64toa);
 88186:         WRITE_STATEX_FIELD(ullAvailVirtual, AvailableVirtualMemory, _ui64toa);
 88186:         WRITE_STATEX_FIELD(ullAvailPageFile, AvailablePageFile, _ui64toa);
 88186:         WRITE_STATEX_FIELD(ullAvailPhys, AvailablePhysicalMemory, _ui64toa);
 88186: 
 88186: #undef WRITE_STATEX_FIELD
 59605:       }
 88186: 
 88073:       if (oomAllocationSizeBufferLen) {
 88073:         WriteFile(hFile, kOOMAllocationSizeParameter,
 88073:                   kOOMAllocationSizeParameterLen, &nBytes, NULL);
 88073:         WriteFile(hFile, oomAllocationSizeBuffer, oomAllocationSizeBufferLen,
 88073:                   &nBytes, NULL);
 88073:         WriteFile(hFile, "\n", 1, &nBytes, NULL);
 88073:       }
  3866:       CloseHandle(hFile);
  3866:     }
  3866:   }
  3866: 
  3881:   if (!doReport) {
  3908:     return returnValue;
  3881:   }
  3881: 
  3863:   STARTUPINFO si;
  3863:   PROCESS_INFORMATION pi;
  3863: 
  3863:   ZeroMemory(&si, sizeof(si));
  3863:   si.cb = sizeof(si);
  3863:   si.dwFlags = STARTF_USESHOWWINDOW;
  3863:   si.wShowWindow = SW_SHOWNORMAL;
  3863:   ZeroMemory(&pi, sizeof(pi));
  3863: 
  3879:   if (CreateProcess(NULL, (LPWSTR)cmdLine, NULL, NULL, FALSE, 0,
  3866:                     NULL, NULL, &si, &pi)) {
  3863:     CloseHandle( pi.hProcess );
  3863:     CloseHandle( pi.hThread );
  3863:   }
  3863:   // we're not really in a position to do anything if the CreateProcess fails
  3863:   TerminateProcess(GetCurrentProcess(), 1);
  3879: #elif defined(XP_UNIX)
  3879:   if (!crashReporterAPIData->IsEmpty()) {
  3879:     // write out API data
 48719:     int fd = sys_open(extraDataPath,
  3879:                       O_WRONLY | O_CREAT | O_TRUNC,
  3879:                       0666);
  3879: 
  3879:     if (fd != -1) {
  3879:       // not much we can do in case of error
 48719:       ssize_t ignored = sys_write(fd, crashReporterAPIData->get(),
 37382:                                   crashReporterAPIData->Length());
 48719:       ignored = sys_write(fd, kCrashTimeParameter, kCrashTimeParameterLen);
 48719:       ignored = sys_write(fd, crashTimeString, crashTimeStringLen);
 48719:       ignored = sys_write(fd, "\n", 1);
  5437:       if (timeSinceLastCrash != 0) {
 48719:         ignored = sys_write(fd, kTimeSinceLastCrashParameter,
 37382:                         kTimeSinceLastCrashParameterLen);
 48719:         ignored = sys_write(fd, timeSinceLastCrashString,
 37382:                         timeSinceLastCrashStringLen);
 48719:         ignored = sys_write(fd, "\n", 1);
  5437:       }
 88073:       if (oomAllocationSizeBufferLen) {
 88073:         sys_write(fd, kOOMAllocationSizeParameter,
 88073:                   kOOMAllocationSizeParameterLen);
 88073:         sys_write(fd, oomAllocationSizeBuffer, oomAllocationSizeBufferLen);
 88073:         sys_write(fd, "\n", 1);
 88073:       }        
 48719:       sys_close(fd);
  3879:     }
  3863:   }
  3863: 
  3881:   if (!doReport) {
  3908:     return returnValue;
  3881:   }
  3881: 
 54878: #ifdef XP_MACOSX
 54878:   char* const my_argv[] = {
 54878:     crashReporterPath,
 54878:     minidumpPath,
 54878:     NULL
 54878:   };
 54878: 
 54878:   char **env = NULL;
 54878:   char ***nsEnv = _NSGetEnviron();
 54878:   if (nsEnv)
 54878:     env = *nsEnv;
 54878:   int result = posix_spawnp(NULL,
 54878:                             my_argv[0],
 54878:                             NULL,
 54878:                             &spawnattr,
 54878:                             my_argv,
 54878:                             env);
 54878: 
 54878:   if (result != 0)
 54878:     return false;
 54878: 
 54878: #else // !XP_MACOSX
 48719:   pid_t pid = sys_fork();
  3866: 
  3879:   if (pid == -1)
  3879:     return false;
  3879:   else if (pid == 0) {
 56279: #if !defined(__ANDROID__)
  8842:     // need to clobber this, as libcurl might load NSS,
  8842:     // and we want it to load the system NSS.
  8842:     unsetenv("LD_LIBRARY_PATH");
  3879:     (void) execl(crashReporterPath,
  3879:                  crashReporterPath, minidumpPath, (char*)0);
 56279: #else
 56279:     // Invoke the reportCrash activity using am
 56279:     (void) execlp("/system/bin/am",
 56279:                  "/system/bin/am",
 56279:                  "start",
 56279:                  "-a", "org.mozilla.gecko.reportCrash",
 56279:                  "-n", crashReporterPath,
 56279:                  "--es", "minidumpPath", minidumpPath,
 56279:                  (char*)0);
 56279: #endif
  3879:     _exit(1);
  3879:   }
 54878: #endif // XP_MACOSX
 54878: #endif // XP_UNIX
  3866: 
  3908:  return returnValue;
  3866: }
  3866: 
 37103: #ifdef XP_WIN
 37103: /**
 37103:  * Filters out floating point exceptions which are handled by nsSigHandlers.cpp
 37103:  * and should not be handled as crashes.
 37103:  */
 37103: static bool FPEFilter(void* context, EXCEPTION_POINTERS* exinfo,
 37103:                       MDRawAssertionInfo* assertion)
 37103: {
 41916:   if (!exinfo)
 41916:     return true;
 41916: 
 37103:   PEXCEPTION_RECORD e = (PEXCEPTION_RECORD)exinfo->ExceptionRecord;
 37103:   switch (e->ExceptionCode) {
 37103:     case STATUS_FLOAT_DENORMAL_OPERAND:
 37103:     case STATUS_FLOAT_DIVIDE_BY_ZERO:
 37103:     case STATUS_FLOAT_INEXACT_RESULT:
 37103:     case STATUS_FLOAT_INVALID_OPERATION:
 37103:     case STATUS_FLOAT_OVERFLOW:
 37103:     case STATUS_FLOAT_STACK_CHECK:
 37103:     case STATUS_FLOAT_UNDERFLOW:
 37103:     case STATUS_FLOAT_MULTIPLE_FAULTS:
 37103:     case STATUS_FLOAT_MULTIPLE_TRAPS:
 37103:       return false; // Don't write minidump, continue exception search
 37103:   }
 37103:   return true;
 37103: }
 37103: #endif // XP_WIN
 37103: 
 39791: static bool ShouldReport()
 39791: {
 39791:   // this environment variable prevents us from launching
 39791:   // the crash reporter client
 39791:   const char *envvar = PR_GetEnv("MOZ_CRASHREPORTER_NO_REPORT");
 39791:   return !(envvar && *envvar);
 39791: }
 39791: 
103475: namespace {
103475:   bool Filter(void* context) {
103475:     mozilla::DisableWritePoisoning();
103475:     return true;
103475:   }
103475: }
103475: 
103475: 
101111: nsresult SetExceptionHandler(nsIFile* aXREDirectory,
 26867:                              bool force/*=false*/)
  3866: {
  3866:   nsresult rv;
  3866: 
  3866:   if (gExceptionHandler)
  3863:     return NS_ERROR_ALREADY_INITIALIZED;
  3863: 
  3912:   const char *envvar = PR_GetEnv("MOZ_CRASHREPORTER_DISABLE");
 26867:   if (envvar && *envvar && !force)
  3912:     return NS_OK;
  3912: 
  3881:   // this environment variable prevents us from launching
  3881:   // the crash reporter client
 39791:   doReport = ShouldReport();
  3881: 
  3871:   // allocate our strings
  3871:   crashReporterAPIData = new nsCString();
  3871:   NS_ENSURE_TRUE(crashReporterAPIData, NS_ERROR_OUT_OF_MEMORY);
  3871: 
 82630:   NS_ASSERTION(!crashReporterAPILock, "Shouldn't have a lock yet");
 82630:   crashReporterAPILock = new Mutex("crashReporterAPILock");
 88178:   NS_ASSERTION(!notesFieldLock, "Shouldn't have a lock yet");
 88178:   notesFieldLock = new Mutex("notesFieldLock");
 82630: 
  3872:   crashReporterAPIData_Hash =
  3872:     new nsDataHashtable<nsCStringHashKey,nsCString>();
  3872:   NS_ENSURE_TRUE(crashReporterAPIData_Hash, NS_ERROR_OUT_OF_MEMORY);
  3872: 
 98908:   crashReporterAPIData_Hash->Init();
  3872: 
 16248:   notesField = new nsCString();
 16248:   NS_ENSURE_TRUE(notesField, NS_ERROR_OUT_OF_MEMORY);
 16248: 
  3866:   // locate crashreporter executable
  3893:   nsCOMPtr<nsIFile> exePath;
  3893:   rv = aXREDirectory->Clone(getter_AddRefs(exePath));
  3893:   NS_ENSURE_SUCCESS(rv, rv);
  3866: 
  3894: #if defined(XP_MACOSX)
  3894:   exePath->Append(NS_LITERAL_STRING("crashreporter.app"));
  3894:   exePath->Append(NS_LITERAL_STRING("Contents"));
  3894:   exePath->Append(NS_LITERAL_STRING("MacOS"));
  3894: #endif
  3894: 
  5892:   exePath->AppendNative(NS_LITERAL_CSTRING(CRASH_REPORTER_FILENAME));
  3871: 
  5892: #ifdef XP_WIN32
  3893:   nsString crashReporterPath_temp;
104355: 
  3893:   exePath->GetPath(crashReporterPath_temp);
  5892:   crashReporterPath = ToNewUnicode(crashReporterPath_temp);
 56279: #elif !defined(__ANDROID__)
  5892:   nsCString crashReporterPath_temp;
104355: 
  5892:   exePath->GetNativePath(crashReporterPath_temp);
  5892:   crashReporterPath = ToNewCString(crashReporterPath_temp);
 56279: #else
 56279:   // On Android, we launch using the application package name
 59589:   // instead of a filename, so use ANDROID_PACKAGE_NAME to do that here.
 56279:   //TODO: don't hardcode org.mozilla here, so other vendors can
 56279:   // ship XUL apps with different package names on Android?
 59589:   nsCString package(ANDROID_PACKAGE_NAME "/.CrashReporter");
 56279:   crashReporterPath = ToNewCString(package);
  5892: #endif
  3866: 
  3866:   // get temp path to use for minidump path
  5892: #if defined(XP_WIN32)
  3866:   nsString tempPath;
  5892: 
  3866:   // first figure out buffer size
  3866:   int pathLen = GetTempPath(0, NULL);
  3866:   if (pathLen == 0)
  3863:     return NS_ERROR_FAILURE;
  3863: 
  3866:   tempPath.SetLength(pathLen);
  3866:   GetTempPath(pathLen, (LPWSTR)tempPath.BeginWriting());
  3879: #elif defined(XP_MACOSX)
  5892:   nsCString tempPath;
  3879:   FSRef fsRef;
  3879:   OSErr err = FSFindFolder(kUserDomain, kTemporaryFolderType,
  3879:                            kCreateFolder, &fsRef);
  3879:   if (err != noErr)
  3879:     return NS_ERROR_FAILURE;
  3879: 
  3880:   char path[PATH_MAX];
  3880:   OSStatus status = FSRefMakePath(&fsRef, (UInt8*)path, PATH_MAX);
  3879:   if (status != noErr)
  3879:     return NS_ERROR_FAILURE;
  5892: 
  5892:   tempPath = path;
  3880: 
 56279: #elif defined(__ANDROID__)
 56279:   // GeckoAppShell sets this in the environment
 56279:   const char *tempenv = PR_GetEnv("TMPDIR");
 56279:   if (!tempenv)
 56279:     return NS_ERROR_FAILURE;
 56279:   nsCString tempPath(tempenv);
 56279: 
  3892: #elif defined(XP_UNIX)
  3892:   // we assume it's always /tmp on unix systems
  5892:   nsCString tempPath = NS_LITERAL_CSTRING("/tmp/");
  3879: #else
  5892: #error "Implement this for your platform"
  3866: #endif
  3866: 
 54878: #ifdef XP_MACOSX
 54878:   // Initialize spawn attributes, since this calls malloc.
 54878:   if (posix_spawnattr_init(&spawnattr) != 0) {
 54878:     return NS_ERROR_FAILURE;
 54878:   }
 54878: 
 54878:   // Set spawn attributes.
 80467:   size_t attr_count = ArrayLength(pref_cpu_types);
 54878:   size_t attr_ocount = 0;
 54878:   if (posix_spawnattr_setbinpref_np(&spawnattr,
 54878:                                     attr_count,
 54878:                                     pref_cpu_types,
 54878:                                     &attr_ocount) != 0 ||
 54878:       attr_ocount != attr_count) {
 54878:     posix_spawnattr_destroy(&spawnattr);
 54878:     return NS_ERROR_FAILURE;
 54878:   }
 54878: #endif
 54878: 
 61785: #ifdef XP_WIN32
 61785:   MINIDUMP_TYPE minidump_type = MiniDumpNormal;
 61785: 
 60513:   // Try to determine what version of dbghelp.dll we're using.
 60513:   // MinidumpWithFullMemoryInfo is only available in 6.1.x or newer.
 61785: 
 60513:   DWORD version_size = GetFileVersionInfoSizeW(L"dbghelp.dll", NULL);
 60513:   if (version_size > 0) {
 60513:     std::vector<BYTE> buffer(version_size);
 60513:     if (GetFileVersionInfoW(L"dbghelp.dll",
 60513:                             0,
 60513:                             version_size,
 60513:                             &buffer[0])) {
 60513:       UINT len;
 60513:       VS_FIXEDFILEINFO* file_info;
 60513:       VerQueryValue(&buffer[0], L"\\", (void**)&file_info, &len);
 60513:       WORD major = HIWORD(file_info->dwFileVersionMS),
 60513:            minor = LOWORD(file_info->dwFileVersionMS),
 60513:            revision = HIWORD(file_info->dwFileVersionLS);
 60513:       if (major > 6 || (major == 6 && minor > 1) ||
 60513:           (major == 6 && minor == 1 && revision >= 7600)) {
 60513:         minidump_type = MiniDumpWithFullMemoryInfo;
 60513:       }
 60513:     }
 60513:   }
 61785: #endif // XP_WIN32
 60513: 
  3883:   // now set the exception handler
  3879:   gExceptionHandler = new google_breakpad::
  5892:     ExceptionHandler(tempPath.get(),
 37103: #ifdef XP_WIN
 37103:                      FPEFilter,
 37103: #else
103475:                      Filter,
 37103: #endif
  3866:                      MinidumpCallback,
  3863:                      nsnull,
  3924: #if defined(XP_WIN32)
 60513:                      google_breakpad::ExceptionHandler::HANDLER_ALL,
 60513:                      minidump_type,
103448:                      (const wchar_t*) NULL,
 60513:                      NULL);
  3924: #else
 50678:                      true
 50678: #if defined(XP_MACOSX)
 50678:                        , NULL
 50678: #endif
 50678:                       );
 50679: #endif // XP_WIN32
  3863: 
  3866:   if (!gExceptionHandler)
  3863:     return NS_ERROR_OUT_OF_MEMORY;
  3863: 
 60402: #ifdef XP_WIN
 60402:   gExceptionHandler->set_handle_debug_exceptions(true);
 97427:   
 97427:   // protect the crash reporter from being unloaded
 97427:   gKernel32Intercept.Init("kernel32.dll");
 97427:   bool ok = gKernel32Intercept.AddHook("SetUnhandledExceptionFilter",
 97427:           reinterpret_cast<intptr_t>(patched_SetUnhandledExceptionFilter),
 97427:           (void**) &stub_SetUnhandledExceptionFilter);
 97427: 
 97427: #ifdef DEBUG
 97427:   if (!ok)
 97427:     printf_stderr ("SetUnhandledExceptionFilter hook failed; crash reporter is vulnerable.\n");
 97427: #endif
 60402: #endif
 60402: 
  9612:   // store application start time
  9612:   char timeString[32];
 50349:   time_t startupTime = time(NULL);
 50349:   XP_TTOA(startupTime, timeString, 10);
  9612:   AnnotateCrashReport(NS_LITERAL_CSTRING("StartupTime"),
  9612:                       nsDependentCString(timeString));
  9612: 
  3908: #if defined(XP_MACOSX)
  3908:   // On OS X, many testers like to see the OS crash reporting dialog
  3908:   // since it offers immediate stack traces.  We allow them to set
  3908:   // a default to pass exceptions to the OS handler.
 43879:   Boolean keyExistsAndHasValidFormat = false;
 43879:   Boolean prefValue = ::CFPreferencesGetAppBooleanValue(CFSTR("OSCrashReporter"),
 43879:                                                         kCFPreferencesCurrentApplication,
 43879:                                                         &keyExistsAndHasValidFormat);
 43879:   if (keyExistsAndHasValidFormat)
 43879:     showOSCrashReporter = prefValue;
  3908: #endif
  3908: 
 56284: #if defined(__ANDROID__)
 56284:   for (unsigned int i = 0; i < library_mappings.size(); i++) {
 56284:     u_int8_t guid[sizeof(MDGUID)];
 56284:     FileIDToGUID(library_mappings[i].debug_id.c_str(), guid);
 56284:     gExceptionHandler->AddMappingInfo(library_mappings[i].name,
 56284:                                       guid,
 56284:                                       library_mappings[i].start_address,
 56284:                                       library_mappings[i].length,
 56284:                                       library_mappings[i].file_offset);
 56284:   }
 56284: #endif
 56284: 
 88073:   mozalloc_set_oom_abort_handler(AnnotateOOMAllocationSize);
 88073: 
  3863:   return NS_OK;
  3863: }
  3863: 
 26867: bool GetEnabled()
 26867: {
 79570:   return gExceptionHandler != nsnull;
 26867: }
 26867: 
 26867: bool GetMinidumpPath(nsAString& aPath)
 26867: {
 26867:   if (!gExceptionHandler)
 26867:     return false;
 26867: 
 26867:   aPath = CONVERT_XP_CHAR_TO_UTF16(gExceptionHandler->dump_path().c_str());
 26867:   return true;
 26867: }
 26867: 
  3866: nsresult SetMinidumpPath(const nsAString& aPath)
  3863: {
  3866:   if (!gExceptionHandler)
  3863:     return NS_ERROR_NOT_INITIALIZED;
  3863: 
  3879:   gExceptionHandler->set_dump_path(CONVERT_UTF16_TO_XP_CHAR(aPath).BeginReading());
  3866: 
  3863:   return NS_OK;
  3863: }
  3863: 
  3927: static nsresult
  3927: WriteDataToFile(nsIFile* aFile, const nsACString& data)
  3927: {
  5892:   PRFileDesc* fd;
101111:   nsresult rv = aFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE, 00600, &fd);
  3927:   NS_ENSURE_SUCCESS(rv, rv);
  3927: 
  3927:   rv = NS_OK;
  3927:   if (PR_Write(fd, data.Data(), data.Length()) == -1) {
  3927:     rv = NS_ERROR_FAILURE;
  3927:   }
  3927:   PR_Close(fd);
  3927:   return rv;
  3927: }
  3927: 
  3927: static nsresult
  3927: GetFileContents(nsIFile* aFile, nsACString& data)
  3927: {
  5892:   PRFileDesc* fd;
101111:   nsresult rv = aFile->OpenNSPRFileDesc(PR_RDONLY, 0, &fd);
  3927:   NS_ENSURE_SUCCESS(rv, rv);
  3927: 
  3927:   rv = NS_OK;
  3927:   PRInt32 filesize = PR_Available(fd);
  3927:   if (filesize <= 0) {
  3927:     rv = NS_ERROR_FILE_NOT_FOUND;
  3927:   }
  3927:   else {
  3927:     data.SetLength(filesize);
  3927:     if (PR_Read(fd, data.BeginWriting(), filesize) == -1) {
  3927:       rv = NS_ERROR_FAILURE;
  3927:     }
  3927:   }
  3927:   PR_Close(fd);
  3927:   return rv;
  3927: }
  3927: 
  3927: // Function typedef for initializing a piece of data that we
  3927: // don't already have.
  3927: typedef nsresult (*InitDataFunc)(nsACString&);
  3927: 
  3927: // Attempt to read aFile's contents into aContents, if aFile
  3927: // does not exist, create it and initialize its contents
  3927: // by calling aInitFunc for the data.
  3927: static nsresult
  5892: GetOrInit(nsIFile* aDir, const nsACString& filename,
  3934:           nsACString& aContents, InitDataFunc aInitFunc)
  3927: {
 79445:   bool exists;
  3934: 
  3934:   nsCOMPtr<nsIFile> dataFile;
  3934:   nsresult rv = aDir->Clone(getter_AddRefs(dataFile));
  3934:   NS_ENSURE_SUCCESS(rv, rv);
  3934: 
  5892:   rv = dataFile->AppendNative(filename);
  3934:   NS_ENSURE_SUCCESS(rv, rv);
  3934: 
  3934:   rv = dataFile->Exists(&exists);
  3927:   NS_ENSURE_SUCCESS(rv, rv);
  3927: 
  3927:   if (!exists) {
  5437:     if (aInitFunc) {
  3927:       // get the initial value and write it to the file
  3927:       rv = aInitFunc(aContents);
  3927:       NS_ENSURE_SUCCESS(rv, rv);
  3934:       rv = WriteDataToFile(dataFile, aContents);
  3934:     }
  3934:     else {
  5437:       // didn't pass in an init func
  5437:       rv = NS_ERROR_FAILURE;
  5437:     }
  5437:   }
  5437:   else {
  3934:     // just get the file's contents
  3934:     rv = GetFileContents(dataFile, aContents);
  3927:   }
  3927: 
  3934:   return rv;
  3927: }
  3927: 
  3934: // Init the "install time" data.  We're taking an easy way out here
  3934: // and just setting this to "the time when this version was first run".
  3934: static nsresult
  3934: InitInstallTime(nsACString& aInstallTime)
  3934: {
  3934:   time_t t = time(NULL);
  3934:   char buf[16];
  3934:   sprintf(buf, "%ld", t);
  3934:   aInstallTime = buf;
  3934: 
  3934:   return NS_OK;
  3934: }
  3934: 
  5437: // Annotate the crash report with a Unique User ID and time
  5437: // since install.  Also do some prep work for recording
  5437: // time since last crash, which must be calculated at
  5437: // crash time.
  3927: // If any piece of data doesn't exist, initialize it first.
101111: nsresult SetupExtraData(nsIFile* aAppDataDirectory,
  3934:                         const nsACString& aBuildID)
  3927: {
  5437:   nsCOMPtr<nsIFile> dataDirectory;
  5437:   nsresult rv = aAppDataDirectory->Clone(getter_AddRefs(dataDirectory));
  5437:   NS_ENSURE_SUCCESS(rv, rv);
  5437: 
  5892:   rv = dataDirectory->AppendNative(NS_LITERAL_CSTRING("Crash Reports"));
  3927:   NS_ENSURE_SUCCESS(rv, rv);
  3927: 
 79445:   bool exists;
  5656:   rv = dataDirectory->Exists(&exists);
  5656:   NS_ENSURE_SUCCESS(rv, rv);
  5656: 
  5656:   if (!exists) {
  5668:     rv = dataDirectory->Create(nsIFile::DIRECTORY_TYPE, 0700);
  5656:     NS_ENSURE_SUCCESS(rv, rv);
  5656:   }
  5656: 
 15508: #if defined(XP_WIN32)
 15508:   nsAutoString dataDirEnv(NS_LITERAL_STRING("MOZ_CRASHREPORTER_DATA_DIRECTORY="));
  6338: 
  6338:   nsAutoString dataDirectoryPath;
  6338:   rv = dataDirectory->GetPath(dataDirectoryPath);
  6338:   NS_ENSURE_SUCCESS(rv, rv);
  6338: 
 15508:   dataDirEnv.Append(dataDirectoryPath);
 15508: 
 15508:   _wputenv(dataDirEnv.get());
  6338: #else
 15508:   // Save this path in the environment for the crash reporter application.
 15508:   nsCAutoString dataDirEnv("MOZ_CRASHREPORTER_DATA_DIRECTORY=");
 15508: 
  6338:   nsCAutoString dataDirectoryPath;
  6338:   rv = dataDirectory->GetNativePath(dataDirectoryPath);
  6338:   NS_ENSURE_SUCCESS(rv, rv);
  6338: 
  6338:   dataDirEnv.Append(dataDirectoryPath);
  6338: 
  6338:   char* env = ToNewCString(dataDirEnv);
  6338:   NS_ENSURE_TRUE(env, NS_ERROR_OUT_OF_MEMORY);
  6338: 
  6338:   PR_SetEnv(env);
 15508: #endif
  6338: 
  3934:   nsCAutoString data;
  5437:   if(NS_SUCCEEDED(GetOrInit(dataDirectory,
  5892:                             NS_LITERAL_CSTRING("InstallTime") + aBuildID,
  3934:                             data, InitInstallTime)))
  3934:     AnnotateCrashReport(NS_LITERAL_CSTRING("InstallTime"), data);
  3934: 
  5437:   // this is a little different, since we can't init it with anything,
  5437:   // since it's stored at crash time, and we can't annotate the
  5437:   // crash report with the stored value, since we really want
  5437:   // (now - LastCrash), so we just get a value if it exists,
  5437:   // and store it in a time_t value.
  5892:   if(NS_SUCCEEDED(GetOrInit(dataDirectory, NS_LITERAL_CSTRING("LastCrash"),
  5437:                             data, NULL))) {
  5437:     lastCrashTime = (time_t)atol(data.get());
  5437:   }
  5437: 
  5437:   // not really the best place to init this, but I have the path I need here
  5437:   nsCOMPtr<nsIFile> lastCrashFile;
  5437:   rv = dataDirectory->Clone(getter_AddRefs(lastCrashFile));
  5437:   NS_ENSURE_SUCCESS(rv, rv);
  5437: 
  5892:   rv = lastCrashFile->AppendNative(NS_LITERAL_CSTRING("LastCrash"));
  5437:   NS_ENSURE_SUCCESS(rv, rv);
  5437:   memset(lastCrashTimeFilename, 0, sizeof(lastCrashTimeFilename));
  5437: 
  5437: #if defined(XP_WIN32)
  5437:   nsAutoString filename;
  5437:   rv = lastCrashFile->GetPath(filename);
  5437:   NS_ENSURE_SUCCESS(rv, rv);
  5437: 
  5437:   if (filename.Length() < XP_PATH_MAX)
  5437:     wcsncpy(lastCrashTimeFilename, filename.get(), filename.Length());
  5437: #else
  5437:   nsCAutoString filename;
  5437:   rv = lastCrashFile->GetNativePath(filename);
  5437:   NS_ENSURE_SUCCESS(rv, rv);
  5437: 
  5437:   if (filename.Length() < XP_PATH_MAX)
  5437:     strncpy(lastCrashTimeFilename, filename.get(), filename.Length());
  5437: #endif
  5437: 
  3927:   return NS_OK;
  3927: }
  3927: 
 37385: static void OOPDeinit();
 37385: 
  3866: nsresult UnsetExceptionHandler()
  3863: {
 97427: #ifdef XP_WIN
 97427:   // allow SetUnhandledExceptionFilter
 97427:   gBlockUnhandledExceptionFilter = false;
 97427: #endif
 97427: 
 30610:   delete gExceptionHandler;
 30610: 
  3871:   // do this here in the unlikely case that we succeeded in allocating
  3871:   // our strings but failed to allocate gExceptionHandler.
  3872:   delete crashReporterAPIData_Hash;
  3872:   crashReporterAPIData_Hash = nsnull;
  7157: 
 82630:   delete crashReporterAPILock;
 82630:   crashReporterAPILock = nsnull;
 82630: 
 88178:   delete notesFieldLock;
 88178:   notesFieldLock = nsnull;
 88178: 
  7157:   delete crashReporterAPIData;
  7157:   crashReporterAPIData = nsnull;
  7157: 
 16248:   delete notesField;
 16248:   notesField = nsnull;
 16248: 
104355:   if (pendingDirectory) {
104355:     NS_Free(pendingDirectory);
104355:     pendingDirectory = nsnull;
104355:   }
104355: 
  3879:   if (crashReporterPath) {
  3879:     NS_Free(crashReporterPath);
  3879:     crashReporterPath = nsnull;
  3879:   }
  3871: 
 54878: #ifdef XP_MACOSX
 54878:   posix_spawnattr_destroy(&spawnattr);
 54878: #endif
 54878: 
  3866:   if (!gExceptionHandler)
  3863:     return NS_ERROR_NOT_INITIALIZED;
  3863: 
  3866:   gExceptionHandler = nsnull;
  3866: 
 37385:   OOPDeinit();
 37385: 
  3863:   return NS_OK;
  3863: }
  3866: 
  3866: static void ReplaceChar(nsCString& str, const nsACString& character,
  3866:                         const nsACString& replacement)
  3866: {
  3866:   nsCString::const_iterator start, end;
  3866: 
  3866:   str.BeginReading(start);
  3866:   str.EndReading(end);
  3866: 
  3866:   while (FindInReadable(character, start, end)) {
  3866:     PRInt32 pos = end.size_backward();
  3866:     str.Replace(pos - 1, 1, replacement);
  3866: 
  3866:     str.BeginReading(start);
  3866:     start.advance(pos + replacement.Length() - 1);
  3866:     str.EndReading(end);
  3866:   }
  3866: }
  3866: 
 79445: static bool DoFindInReadable(const nsACString& str, const nsACString& value)
  3866: {
  3866:   nsACString::const_iterator start, end;
  3866:   str.BeginReading(start);
  3866:   str.EndReading(end);
  3866: 
  3866:   return FindInReadable(value, start, end);
  3866: }
  3866: 
 20261: static PLDHashOperator EnumerateEntries(const nsACString& key,
  3872:                                         nsCString entry,
  3872:                                         void* userData)
  3872: {
  3872:   crashReporterAPIData->Append(key + NS_LITERAL_CSTRING("=") + entry +
  3872:                                NS_LITERAL_CSTRING("\n"));
  3872:   return PL_DHASH_NEXT;
  3872: }
  3872: 
 79574: // This function is miscompiled with MSVC 2005/2008 when PGO is on.
 79574: #ifdef _MSC_VER
 79574: #pragma optimize("", off)
 79574: #endif
 79570: static nsresult
 79570: EscapeAnnotation(const nsACString& key, const nsACString& data, nsCString& escapedData)
  3866: {
  3866:   if (DoFindInReadable(key, NS_LITERAL_CSTRING("=")) ||
  3866:       DoFindInReadable(key, NS_LITERAL_CSTRING("\n")))
  3866:     return NS_ERROR_INVALID_ARG;
  3866: 
  3870:   if (DoFindInReadable(data, NS_LITERAL_CSTRING("\0")))
  3870:     return NS_ERROR_INVALID_ARG;
  3870: 
 79570:   escapedData = data;
 72771: 
  3866:   // escape backslashes
 72771:   ReplaceChar(escapedData, NS_LITERAL_CSTRING("\\"),
  3866:               NS_LITERAL_CSTRING("\\\\"));
  3866:   // escape newlines
 72771:   ReplaceChar(escapedData, NS_LITERAL_CSTRING("\n"),
  3866:               NS_LITERAL_CSTRING("\\n"));
 79570:   return NS_OK;
 79570: }
 79574: #ifdef _MSC_VER
 79574: #pragma optimize("", on)
 79574: #endif
  3866: 
 79570: class DelayedNote
 79570: {
 79570:  public:
 79570:   DelayedNote(const nsACString& aKey, const nsACString& aData)
 79570:   : mKey(aKey), mData(aData), mType(Annotation) {}
 79570: 
 79570:   DelayedNote(const nsACString& aData)
 79570:   : mData(aData), mType(AppNote) {}
 79570: 
 79570:   void Run()
 79570:   {
 79570:     if (mType == Annotation) {
 79570:       AnnotateCrashReport(mKey, mData);
 79570:     } else {
 79570:       AppendAppNotesToCrashReport(mData);
 79570:     }
 79570:   }
 79570:   
 79570:  private:
 79570:   nsCString mKey;
 79570:   nsCString mData;
 79570:   enum AnnotationType { Annotation, AppNote } mType;
 79570: };
 79570: 
 79570: static void
 79570: EnqueueDelayedNote(DelayedNote* aNote)
 79570: {
 79570:   if (!gDelayedAnnotations) {
 79570:     gDelayedAnnotations = new nsTArray<nsAutoPtr<DelayedNote> >();
 79570:   }
 79570:   gDelayedAnnotations->AppendElement(aNote);
 79570: }
 79570: 
 79570: nsresult AnnotateCrashReport(const nsACString& key, const nsACString& data)
 79570: {
 79570:   if (!GetEnabled())
 79570:     return NS_ERROR_NOT_INITIALIZED;
 79570: 
 79570:   nsCString escapedData;
 79570:   nsresult rv = EscapeAnnotation(key, data, escapedData);
 79570:   if (NS_FAILED(rv))
 79570:     return rv;
 79570: 
 79570:   if (XRE_GetProcessType() != GeckoProcessType_Default) {
 82630:     if (!NS_IsMainThread()) {
 82630:       NS_ERROR("Cannot call AnnotateCrashReport in child processes from non-main thread.");
 82630:       return NS_ERROR_FAILURE;
 82630:     }
 79570:     PCrashReporterChild* reporter = CrashReporterChild::GetCrashReporter();
 79570:     if (!reporter) {
 79570:       EnqueueDelayedNote(new DelayedNote(key, data));
 79570:       return NS_OK;
 79570:     }
 79570:     if (!reporter->SendAnnotateCrashReport(nsCString(key), escapedData))
 79570:       return NS_ERROR_FAILURE;
 79570:     return NS_OK;
 79570:   }
 79570: 
 82630:   MutexAutoLock lock(*crashReporterAPILock);
 82630: 
 98908:   crashReporterAPIData_Hash->Put(key, escapedData);
  3872: 
  3872:   // now rebuild the file contents
  3872:   crashReporterAPIData->Truncate(0);
  3872:   crashReporterAPIData_Hash->EnumerateRead(EnumerateEntries,
  3872:                                            crashReporterAPIData);
  3872: 
  3866:   return NS_OK;
  3866: }
  3866: 
 16248: nsresult AppendAppNotesToCrashReport(const nsACString& data)
 16248: {
 55779:   if (!GetEnabled())
 16248:     return NS_ERROR_NOT_INITIALIZED;
 16248: 
 16248:   if (DoFindInReadable(data, NS_LITERAL_CSTRING("\0")))
 16248:     return NS_ERROR_INVALID_ARG;
 16248: 
 79570:   if (XRE_GetProcessType() != GeckoProcessType_Default) {
 88178:     if (!NS_IsMainThread()) {
 88178:       NS_ERROR("Cannot call AnnotateCrashReport in child processes from non-main thread.");
 88178:       return NS_ERROR_FAILURE;
 88178:     }
 79570:     PCrashReporterChild* reporter = CrashReporterChild::GetCrashReporter();
 79570:     if (!reporter) {
 79570:       EnqueueDelayedNote(new DelayedNote(data));
 79570:       return NS_OK;
 79570:     }
 79570: 
 79570:     // Since we don't go through AnnotateCrashReport in the parent process,
 79570:     // we must ensure that the data is escaped and valid before the parent
 79570:     // sees it.
 79570:     nsCString escapedData;
 79570:     nsresult rv = EscapeAnnotation(NS_LITERAL_CSTRING("Notes"), data, escapedData);
 79570:     if (NS_FAILED(rv))
 79570:       return rv;
 79570: 
 79570:     if (!reporter->SendAppendAppNotes(escapedData))
 79570:       return NS_ERROR_FAILURE;
 79570:     return NS_OK;
 79570:   }
 79570: 
 88178:   MutexAutoLock lock(*notesFieldLock);
 88178: 
 16248:   notesField->Append(data);
 16248:   return AnnotateCrashReport(NS_LITERAL_CSTRING("Notes"), *notesField);
 16248: }
 16248: 
 16248: // Returns true if found, false if not found.
 16248: bool GetAnnotation(const nsACString& key, nsACString& data)
 16248: {
 16248:   if (!gExceptionHandler)
 26867:     return false;
 16248: 
 16248:   nsCAutoString entry;
 16248:   if (!crashReporterAPIData_Hash->Get(key, &entry))
 16248:     return false;
 16248: 
 16248:   data = entry;
 16248:   return true;
 16248: }
 16248: 
 73558: nsresult RegisterAppMemory(void* ptr, size_t length)
 73558: {
 73558:   if (!GetEnabled())
 73558:     return NS_ERROR_NOT_INITIALIZED;
 73558: 
 73558: #if defined(XP_LINUX) || defined(XP_WIN32)
 73558:   gExceptionHandler->RegisterAppMemory(ptr, length);
 73558:   return NS_OK;
 73558: #else
 73558:   return NS_ERROR_NOT_IMPLEMENTED;
 73558: #endif
 73558: }
 73558: 
 73558: nsresult UnregisterAppMemory(void* ptr)
 73558: {
 73558:   if (!GetEnabled())
 73558:     return NS_ERROR_NOT_INITIALIZED;
 73558: 
 73558: #if defined(XP_LINUX) || defined(XP_WIN32)
 73558:   gExceptionHandler->UnregisterAppMemory(ptr);
 73558:   return NS_OK;
 73558: #else
 73558:   return NS_ERROR_NOT_IMPLEMENTED;
 73558: #endif
 73558: }
 73558: 
 26867: bool GetServerURL(nsACString& aServerURL)
 26867: {
 26867:   if (!gExceptionHandler)
 26867:     return false;
 26867: 
 26867:   return GetAnnotation(NS_LITERAL_CSTRING("ServerURL"), aServerURL);
 26867: }
 26867: 
 26867: nsresult SetServerURL(const nsACString& aServerURL)
 26867: {
 26867:   // store server URL with the API data
 26867:   // the client knows to handle this specially
 26867:   return AnnotateCrashReport(NS_LITERAL_CSTRING("ServerURL"),
 26867:                              aServerURL);
 26867: }
 26867: 
  3900: nsresult
  3900: SetRestartArgs(int argc, char** argv)
  3900: {
  3912:   if (!gExceptionHandler)
  3912:     return NS_OK;
  3912: 
  3900:   int i;
  3900:   nsCAutoString envVar;
  3901:   char *env;
102443:   char *argv0 = getenv("MOZ_APP_LAUNCHER");
  3900:   for (i = 0; i < argc; i++) {
  3900:     envVar = "MOZ_CRASHREPORTER_RESTART_ARG_";
  3900:     envVar.AppendInt(i);
  3900:     envVar += "=";
102443:     if (argv0 && i == 0) {
102443:       // Is there a request to suppress default binary launcher?
102443:       envVar += argv0;
102443:     } else {
  3900:       envVar += argv[i];
  9608:     }
  3901: 
  3901:     // PR_SetEnv() wants the string to be available for the lifetime
  3901:     // of the app, so dup it here
  3901:     env = ToNewCString(envVar);
  3901:     if (!env)
  3901:       return NS_ERROR_OUT_OF_MEMORY;
  3901: 
  3901:     PR_SetEnv(env);
  3900:   }
  3900: 
  3900:   // make sure the arg list is terminated
  3900:   envVar = "MOZ_CRASHREPORTER_RESTART_ARG_";
  3900:   envVar.AppendInt(i);
  3900:   envVar += "=";
  3900: 
  3901:   // PR_SetEnv() wants the string to be available for the lifetime
  3901:   // of the app, so dup it here
  3901:   env = ToNewCString(envVar);
  3901:   if (!env)
  3901:     return NS_ERROR_OUT_OF_MEMORY;
  3901: 
  3901:   PR_SetEnv(env);
  3900: 
  3921:   // make sure we save the info in XUL_APP_FILE for the reporter
  3921:   const char *appfile = PR_GetEnv("XUL_APP_FILE");
  3921:   if (appfile && *appfile) {
  3921:     envVar = "MOZ_CRASHREPORTER_RESTART_XUL_APP_FILE=";
  3921:     envVar += appfile;
  3921:     env = ToNewCString(envVar);
  3921:     PR_SetEnv(env);
  3921:   }
  3921: 
  3900:   return NS_OK;
  3900: }
 11440: 
 11440: #ifdef XP_WIN32
 11440: nsresult WriteMinidumpForException(EXCEPTION_POINTERS* aExceptionInfo)
 11440: {
 11440:   if (!gExceptionHandler)
 11440:     return NS_ERROR_NOT_INITIALIZED;
 11440: 
 11440:   return gExceptionHandler->WriteMinidumpForException(aExceptionInfo) ? NS_OK : NS_ERROR_FAILURE;
 11440: }
 11440: #endif
 11440: 
 18492: #ifdef XP_MACOSX
 18492: nsresult AppendObjCExceptionInfoToAppNotes(void *inException)
 18492: {
 18492:   nsCAutoString excString;
 18492:   GetObjCExceptionInfo(inException, excString);
 18492:   AppendAppNotesToCrashReport(excString);
 18492:   return NS_OK;
 18492: }
 18492: #endif
 18492: 
 38030: /*
 38030:  * Combined code to get/set the crash reporter submission pref on
 38030:  * different platforms.
 38030:  */
 79445: static nsresult PrefSubmitReports(bool* aSubmitReports, bool writePref)
 38030: {
 38030:   nsresult rv;
 38030: #if defined(XP_WIN32)
 38030:   /*
 38030:    * NOTE! This needs to stay in sync with the preference checking code
 38030:    *       in toolkit/crashreporter/client/crashreporter_win.cpp
 38030:    */
 38030:   nsCOMPtr<nsIXULAppInfo> appinfo =
 38030:     do_GetService("@mozilla.org/xre/app-info;1", &rv);
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030: 
 38030:   nsCAutoString appVendor, appName;
 38030:   rv = appinfo->GetVendor(appVendor);
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030:   rv = appinfo->GetName(appName);
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030: 
 38030:   nsCOMPtr<nsIWindowsRegKey> regKey
 38030:     (do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv));
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030: 
 38030:   nsCAutoString regPath;
 38030: 
 38030:   regPath.AppendLiteral("Software\\");
104161: 
104161:   // We need to ensure the registry keys are created so we can properly
104161:   // write values to it
104161:   
104161:   // Create appVendor key
 38030:   if(!appVendor.IsEmpty()) {
 38030:     regPath.Append(appVendor);
104161:     regKey->Create(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
104161:                    NS_ConvertUTF8toUTF16(regPath),
104161:                    nsIWindowsRegKey::ACCESS_SET_VALUE);
 38030:     regPath.AppendLiteral("\\");
 38030:   }
104161: 
104161:   // Create appName key
 38030:   regPath.Append(appName);
104161:   regKey->Create(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
104161:                  NS_ConvertUTF8toUTF16(regPath),
104161:                  nsIWindowsRegKey::ACCESS_SET_VALUE);
104161:   regPath.AppendLiteral("\\");
104161: 
104161:   // Create Crash Reporter key
104161:   regPath.AppendLiteral("Crash Reporter");
104161:   regKey->Create(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
104161:                  NS_ConvertUTF8toUTF16(regPath),
104161:                  nsIWindowsRegKey::ACCESS_SET_VALUE);
 38030: 
 38030:   // If we're saving the pref value, just write it to ROOT_KEY_CURRENT_USER
 38030:   // and we're done.
 38030:   if (writePref) {
 38030:     rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
 38030:                       NS_ConvertUTF8toUTF16(regPath),
 38030:                       nsIWindowsRegKey::ACCESS_SET_VALUE);
 38030:     NS_ENSURE_SUCCESS(rv, rv);
 38030: 
 38030:     PRUint32 value = *aSubmitReports ? 1 : 0;
 38030:     rv = regKey->WriteIntValue(NS_LITERAL_STRING("SubmitCrashReport"), value);
 38030:     regKey->Close();
 38030:     return rv;
 38030:   }
 38030: 
 38030:   // We're reading the pref value, so we need to first look under
 38030:   // ROOT_KEY_LOCAL_MACHINE to see if it's set there, and then fall back to
 38030:   // ROOT_KEY_CURRENT_USER. If it's not set in either place, the pref defaults
 38030:   // to "true".
 38030:   PRUint32 value;
 38030:   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
 38030:                     NS_ConvertUTF8toUTF16(regPath),
 38030:                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
 38030:   if (NS_SUCCEEDED(rv)) {
 38030:     rv = regKey->ReadIntValue(NS_LITERAL_STRING("SubmitCrashReport"), &value);
 38030:     regKey->Close();
 38030:     if (NS_SUCCEEDED(rv)) {
 38030:       *aSubmitReports = !!value;
 38030:       return NS_OK;
 38030:     }
 38030:   }
 38030: 
 38030:   rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER,
 38030:                     NS_ConvertUTF8toUTF16(regPath),
 38030:                     nsIWindowsRegKey::ACCESS_QUERY_VALUE);
 38030:   if (NS_FAILED(rv)) {
 80486:     *aSubmitReports = true;
 38030:     return NS_OK;
 38030:   }
 38030:   
 38030:   rv = regKey->ReadIntValue(NS_LITERAL_STRING("SubmitCrashReport"), &value);
 38030:   // default to true on failure
 38030:   if (NS_FAILED(rv)) {
 38030:     value = 1;
 38030:     rv = NS_OK;
 38030:   }
 38030:   regKey->Close();
 38030: 
 38030:   *aSubmitReports = !!value;
 38030:   return NS_OK;
 38036: #elif defined(XP_MACOSX)
 43879:   rv = NS_OK;
 43879:   if (writePref) {
 43879:     CFPropertyListRef cfValue = (CFPropertyListRef)(*aSubmitReports ? kCFBooleanTrue : kCFBooleanFalse);
 43879:     ::CFPreferencesSetAppValue(CFSTR("submitReport"),
 43879:                                cfValue,
 43879:                                reporterClientAppID);
 43879:     if (!::CFPreferencesAppSynchronize(reporterClientAppID))
 43879:       rv = NS_ERROR_FAILURE;
 43879:   }
 43879:   else {
 80486:     *aSubmitReports = true;
 43879:     Boolean keyExistsAndHasValidFormat = false;
 43879:     Boolean prefValue = ::CFPreferencesGetAppBooleanValue(CFSTR("submitReport"),
 43879:                                                           reporterClientAppID,
 43879:                                                           &keyExistsAndHasValidFormat);
 43879:     if (keyExistsAndHasValidFormat)
 43879:       *aSubmitReports = !!prefValue;
 43879:   }
 43879:   return rv;
 38030: #elif defined(XP_UNIX)
 38030:   /*
 38030:    * NOTE! This needs to stay in sync with the preference checking code
 38030:    *       in toolkit/crashreporter/client/crashreporter_linux.cpp
 38030:    */
 38030:   nsCOMPtr<nsIFile> reporterINI;
 38030:   rv = NS_GetSpecialDirectory("UAppData", getter_AddRefs(reporterINI));
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030:   reporterINI->AppendNative(NS_LITERAL_CSTRING("Crash Reports"));
 38030:   reporterINI->AppendNative(NS_LITERAL_CSTRING("crashreporter.ini"));
 38030: 
 79445:   bool exists;
 38030:   rv = reporterINI->Exists(&exists);
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030:   if (!exists) {
 38030:     if (!writePref) {
 38030:         // If reading the pref, default to true if .ini doesn't exist.
 80486:         *aSubmitReports = true;
 38030:         return NS_OK;
 38030:     }
 38030:     // Create the file so the INI processor can write to it.
 38030:     rv = reporterINI->Create(nsIFile::NORMAL_FILE_TYPE, 0600);
 38030:     NS_ENSURE_SUCCESS(rv, rv);
 38030:   }
 38030: 
 38030:   nsCOMPtr<nsIINIParserFactory> iniFactory =
 38030:     do_GetService("@mozilla.org/xpcom/ini-processor-factory;1", &rv);
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030: 
 38030:   nsCOMPtr<nsIINIParser> iniParser;
101111:   rv = iniFactory->CreateINIParser(reporterINI,
 38030:                                    getter_AddRefs(iniParser));
 38030:   NS_ENSURE_SUCCESS(rv, rv);
 38030: 
 38030:   // If we're writing the pref, just set and we're done.
 38030:   if (writePref) {
 38030:     nsCOMPtr<nsIINIParserWriter> iniWriter = do_QueryInterface(iniParser);
 38030:     NS_ENSURE_TRUE(iniWriter, NS_ERROR_FAILURE);
 38030: 
 38030:     rv = iniWriter->SetString(NS_LITERAL_CSTRING("Crash Reporter"),
 38030:                               NS_LITERAL_CSTRING("SubmitReport"),
 38030:                               *aSubmitReports ?  NS_LITERAL_CSTRING("1") :
 38030:                                                  NS_LITERAL_CSTRING("0"));
 38030:     NS_ENSURE_SUCCESS(rv, rv);
 99241:     rv = iniWriter->WriteFile(NULL, 0);
 38030:     return rv;
 38030:   }
 38030:   
 38030:   nsCAutoString submitReportValue;
 38030:   rv = iniParser->GetString(NS_LITERAL_CSTRING("Crash Reporter"),
 38030:                             NS_LITERAL_CSTRING("SubmitReport"),
 38030:                             submitReportValue);
 38030: 
 38030:   // Default to "true" if the pref can't be found.
 38030:   if (NS_FAILED(rv))
 80486:     *aSubmitReports = true;
 38030:   else if (submitReportValue.EqualsASCII("0"))
 80486:     *aSubmitReports = false;
 38030:   else
 80486:     *aSubmitReports = true;
 38030: 
 38030:   return NS_OK;
 38030: #else
 38030:   return NS_ERROR_NOT_IMPLEMENTED;
 38030: #endif
 38030: }
 38030: 
 79445: nsresult GetSubmitReports(bool* aSubmitReports)
 38030: {
 38030:     return PrefSubmitReports(aSubmitReports, false);
 38030: }
 38030: 
 79445: nsresult SetSubmitReports(bool aSubmitReports)
 38030: {
 80922:     nsresult rv;
 80922: 
 80922:     nsCOMPtr<nsIObserverService> obsServ =
 80922:       mozilla::services::GetObserverService();
 80922:     if (!obsServ) {
 80922:       return NS_ERROR_FAILURE;
 80922:     }
 80922: 
 80922:     rv = PrefSubmitReports(&aSubmitReports, true);
 80922:     if (NS_FAILED(rv)) {
 80922:       return rv;
 80922:     }
 80922: 
 80922:     obsServ->NotifyObservers(nsnull, "submit-reports-pref-changed", nsnull);
 80922:     return NS_OK;
 38030: }
 38030: 
 39792: // The "pending" dir is Crash Reports/pending, from which minidumps
104355: // can be submitted. Because this method may be called off the main thread,
104355: // we store the pending directory as a path.
 39792: static bool
101111: GetPendingDir(nsIFile** dir)
 39792: {
104355:   MOZ_ASSERT(OOPInitialized());
104355:   if (!pendingDirectory) {
 39792:     return false;
104355:   }
104355: 
104355:   nsCOMPtr<nsIFile> pending = do_CreateInstance(NS_LOCAL_FILE_CONTRACTID);
104450:   if (!pending) {
104450:     NS_WARNING("Can't set up pending directory during shutdown.");
104450:     return false;
104450:   }
104355: #ifdef XP_WIN
104355:   pending->InitWithPath(nsDependentString(pendingDirectory));
104355: #else
104355:   pending->InitWithNativePath(nsDependentCString(pendingDirectory));
104355: #endif
104355:   pending.swap(*dir);
 39792:   return true;
 39792: }
 38030: 
 39792: // The "limbo" dir is where minidumps go to wait for something else to
 39792: // use them.  If we're |ShouldReport()|, then the "something else" is
 39792: // a minidump submitter, and they're coming from the 
 39792: // Crash Reports/pending/ dir.  Otherwise, we don't know what the
 39792: // "somthing else" is, but the minidumps stay in [profile]/minidumps/
 39792: // limbo.
 39792: static bool
101111: GetMinidumpLimboDir(nsIFile** dir)
 39792: {
 39792:   if (ShouldReport()) {
 39792:     return GetPendingDir(dir);
 39792:   }
 39792:   else {
 39792:     CreateFileFromPath(gExceptionHandler->dump_path(), dir);
 39792:     return NULL != *dir;
 39792:   }
 39792: }
 39791: 
 39792: bool
101111: GetMinidumpForID(const nsAString& id, nsIFile** minidump)
 39792: {
 39792:   if (!GetMinidumpLimboDir(minidump))
 39792:     return false;
 39792:   (*minidump)->Append(id + NS_LITERAL_STRING(".dmp")); 
 39792:   return true;
 39792: }
 39792: 
 39792: bool
101111: GetIDFromMinidump(nsIFile* minidump, nsAString& id)
 39792: {
 39792:   if (NS_SUCCEEDED(minidump->GetLeafName(id))) {
 39792:     id.Replace(id.Length() - 4, 4, NS_LITERAL_STRING(""));
 39792:     return true;
 39792:   }
 39792:   return false;
 39792: }
 39792: 
 39792: bool
101111: GetExtraFileForID(const nsAString& id, nsIFile** extraFile)
 39792: {
 39792:   if (!GetMinidumpLimboDir(extraFile))
 39792:     return false;
 39792:   (*extraFile)->Append(id + NS_LITERAL_STRING(".extra"));
 39792:   return true;
 39792: }
 39792: 
 39792: bool
101111: GetExtraFileForMinidump(nsIFile* minidump, nsIFile** extraFile)
 39792: {
 39792:   nsAutoString leafName;
 39792:   nsresult rv = minidump->GetLeafName(leafName);
 39792:   if (NS_FAILED(rv))
 39792:     return false;
 39792: 
 39792:   nsCOMPtr<nsIFile> extraF;
 39792:   rv = minidump->Clone(getter_AddRefs(extraF));
 39792:   if (NS_FAILED(rv))
 39792:     return false;
 39792: 
 39792:   leafName.Replace(leafName.Length() - 3, 3,
 39792:                    NS_LITERAL_STRING("extra"));
101111:   rv = extraF->SetLeafName(leafName);
 39792:   if (NS_FAILED(rv))
 39792:     return false;
 39792: 
 39792:   *extraFile = NULL;
101111:   extraF.swap(*extraFile);
 39792:   return true;
 39792: }
 39792: 
 39792: bool
 39792: AppendExtraData(const nsAString& id, const AnnotationTable& data)
 39792: {
101111:   nsCOMPtr<nsIFile> extraFile;
 39792:   if (!GetExtraFileForID(id, getter_AddRefs(extraFile)))
 39792:     return false;
 39792:   return AppendExtraData(extraFile, data);
 39792: }
 39792: 
 39792: //-----------------------------------------------------------------------------
 39792: // Helpers for AppendExtraData()
 39792: //
 39791: struct Blacklist {
 39791:   Blacklist() : mItems(NULL), mLen(0) { }
 39791:   Blacklist(const char** items, int len) : mItems(items), mLen(len) { }
 39791: 
 39791:   bool Contains(const nsACString& key) const {
 39791:     for (int i = 0; i < mLen; ++i)
 39791:       if (key.EqualsASCII(mItems[i]))
 39791:         return true;
 39791:     return false;
 39791:   }
 39791: 
 39791:   const char** mItems;
 39791:   const int mLen;
 39791: };
 39791: 
 39791: struct EnumerateAnnotationsContext {
 39791:   const Blacklist& blacklist;
 39791:   PRFileDesc* fd;
 39791: };
 39791: 
 39792: static void
 39792: WriteAnnotation(PRFileDesc* fd, const nsACString& key, const nsACString& value)
 39792: {
 39792:   PR_Write(fd, key.BeginReading(), key.Length());
 39792:   PR_Write(fd, "=", 1);
 39792:   PR_Write(fd, value.BeginReading(), value.Length());
 39792:   PR_Write(fd, "\n", 1);
 39792: }
 39792: 
 39791: static PLDHashOperator
 39791: EnumerateAnnotations(const nsACString& key,
 37382:                      nsCString entry,
 37382:                      void* userData)
 37382: {
 39791:   EnumerateAnnotationsContext* ctx =
 39791:     static_cast<EnumerateAnnotationsContext*>(userData);
 39791:   const Blacklist& blacklist = ctx->blacklist;
 37382: 
 37382:   // skip entries in the blacklist
 39791:   if (blacklist.Contains(key))
 37382:       return PL_DHASH_NEXT;
 37382: 
 39792:   WriteAnnotation(ctx->fd, key, entry);
 39791: 
 37382:   return PL_DHASH_NEXT;
 37382: }
 37382: 
 38028: static bool
101111: WriteExtraData(nsIFile* extraFile,
 39792:                const AnnotationTable& data,
 39792:                const Blacklist& blacklist,
 39792:                bool writeCrashTime=false,
 39792:                bool truncate=false)
 39792: {
 39792:   PRFileDesc* fd;
 39792:   PRIntn truncOrAppend = truncate ? PR_TRUNCATE : PR_APPEND;
 39792:   nsresult rv = 
 39792:     extraFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | truncOrAppend,
 39792:                                 0600, &fd);
 39792:   if (NS_FAILED(rv))
 39792:     return false;
 39792: 
 39792:   EnumerateAnnotationsContext ctx = { blacklist, fd };
 39792:   data.EnumerateRead(EnumerateAnnotations, &ctx);
 39792: 
 39792:   if (writeCrashTime) {
 39792:     time_t crashTime = time(NULL);
 39792:     char crashTimeString[32];
 39792:     XP_TTOA(crashTime, crashTimeString, 10);
 39792: 
 39792:     WriteAnnotation(fd,
 39792:                     nsDependentCString("CrashTime"),
 39792:                     nsDependentCString(crashTimeString));
 39792:   }
 39792: 
 39792:   PR_Close(fd);
 39792:   return true;
 39792: }
 39792: 
 39792: bool
101111: AppendExtraData(nsIFile* extraFile, const AnnotationTable& data)
 39792: {
 39792:   return WriteExtraData(extraFile, data, Blacklist());
 39792: }
 39792: 
 39792: 
 39792: static bool
101111: WriteExtraForMinidump(nsIFile* minidump,
 39791:                       const Blacklist& blacklist,
101111:                       nsIFile** extraFile)
 39791: {
101111:   nsCOMPtr<nsIFile> extra;
 39792:   if (!GetExtraFileForMinidump(minidump, getter_AddRefs(extra)))
 39791:     return false;
 39791: 
 39792:   if (!WriteExtraData(extra, *crashReporterAPIData_Hash,
 39792:                       blacklist,
 39792:                       true /*write crash time*/,
 39792:                       true /*truncate*/))
 39791:     return false;
 39791: 
 39791:   *extraFile = NULL;
 39791:   extra.swap(*extraFile);
 39791: 
 39791:   return true;
 39791: }
 39791: 
 39792: // It really only makes sense to call this function when
 39792: // ShouldReport() is true.
 39791: static bool
 38028: MoveToPending(nsIFile* dumpFile, nsIFile* extraFile)
 38028: {
101111:   nsCOMPtr<nsIFile> pendingDir;
 39792:   if (!GetPendingDir(getter_AddRefs(pendingDir)))
 38028:     return false;
 38028: 
 39792:   return NS_SUCCEEDED(dumpFile->MoveTo(pendingDir, EmptyString())) &&
 39792:     NS_SUCCEEDED(extraFile->MoveTo(pendingDir, EmptyString()));
 38028: }
 38028: 
 37203: static void
 37203: OnChildProcessDumpRequested(void* aContext,
 50679: #ifdef XP_MACOSX
 50679:                             const ClientInfo& aClientInfo,
 50679:                             const xpstring& aFilePath
 50679: #else
 37203:                             const ClientInfo* aClientInfo,
 50679:                             const xpstring* aFilePath
 50679: #endif
 50679:                             )
 37203: {
101111:   nsCOMPtr<nsIFile> minidump;
101111:   nsCOMPtr<nsIFile> extraFile;
 37382: 
 50679:   CreateFileFromPath(
 50679: #ifdef XP_MACOSX
 50679:                      aFilePath,
 50679: #else
 50679:                      *aFilePath,
 50679: #endif
 50679:                      getter_AddRefs(minidump));
 37382: 
 58170: #if defined(__ANDROID__)
 58170:   // Do dump generation here since the CrashGenerationServer doesn't
 58170:   // have access to the library mappings.
 58170:   MappingMap::const_iterator iter = 
 58170:     child_library_mappings.find(aClientInfo->pid_);
 73558:   google_breakpad::AppMemoryList a;
 58170:   if (iter == child_library_mappings.end()) {
 58170:     NS_WARNING("No library mappings found for child, can't write minidump!");
 58170:     return;
 58170:   }
 58170: 
 58170:   if (!google_breakpad::WriteMinidump(aFilePath->c_str(),
 58170:                                       aClientInfo->pid_,
 58170:                                       aClientInfo->crash_context,
 58170:                                       aClientInfo->crash_context_size,
 73558:                                       iter->second,
 73558:                                       a))
 58170:     return;
 58170: #endif
 58170: 
 39791:   if (!WriteExtraForMinidump(minidump,
 39791:                              Blacklist(kSubprocessBlacklist,
 80467:                                        ArrayLength(kSubprocessBlacklist)),
 39791:                              getter_AddRefs(extraFile)))
 37382:     return;
 37382: 
 39791:   if (ShouldReport())
 39791:     MoveToPending(minidump, extraFile);
 38028: 
 37382:   {
 50679:     PRUint32 pid =
 50679: #ifdef XP_MACOSX
 50679:       aClientInfo.pid();
 50679: #else
 50679:       aClientInfo->pid();
 50679: #endif
 39791: 
104355: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355:     bool runCallback;
104355: #endif
103451:     {
 37382:       MutexAutoLock lock(*dumpMapLock);
104355:       ChildProcessData* pd = pidToMinidump->PutEntry(pid);
104355:       MOZ_ASSERT(!pd->minidump);
104355:       pd->minidump = minidump;
104355:       pd->sequence = ++crashSequence;
104355: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355:       runCallback = NULL != pd->callback;
104355: #endif
 37382:     }
103451: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355:     if (runCallback)
103451:       NS_DispatchToMainThread(new ReportInjectedCrash(pid));
103451: #endif
103451:   }
 38028: }
 37203: 
 37203: static bool
 37203: OOPInitialized()
 37203: {
 40723:   return pidToMinidump != NULL;
 37203: }
 37203: 
103475: static bool ChildFilter(void *context) {
103475:   mozilla::DisableWritePoisoning();
103475:   return true;
103475: }
103475: 
104355: void
 37203: OOPInit()
 37203: {
104355:   if (OOPInitialized())
104355:     return;
104355: 
104355:   MOZ_ASSERT(NS_IsMainThread());
104355: 
 37203:   NS_ABORT_IF_FALSE(gExceptionHandler != NULL,
 37203:                     "attempt to initialize OOP crash reporter before in-process crashreporter!");
 37203: 
 37203: #if defined(XP_WIN)
 37203:   childCrashNotifyPipe =
 37208:     PR_smprintf("\\\\.\\pipe\\gecko-crash-server-pipe.%i",
 37208:                 static_cast<int>(::GetCurrentProcessId()));
 37203: 
 37203:   const std::wstring dumpPath = gExceptionHandler->dump_path();
 37203:   crashServer = new CrashGenerationServer(
 37208:     NS_ConvertASCIItoUTF16(childCrashNotifyPipe).get(),
 37203:     NULL,                       // default security attributes
 37203:     NULL, NULL,                 // we don't care about process connect here
 37203:     OnChildProcessDumpRequested, NULL,
 37203:     NULL, NULL,                 // we don't care about process exit here
 37203:     true,                       // automatically generate dumps
 37203:     &dumpPath);
 37203: 
 37203: #elif defined(XP_LINUX)
 37203:   if (!CrashGenerationServer::CreateReportChannel(&serverSocketFd,
 37203:                                                   &clientSocketFd))
 37203:     NS_RUNTIMEABORT("can't create crash reporter socketpair()");
 37203: 
 37203:   const std::string dumpPath = gExceptionHandler->dump_path();
 58170:   bool generateDumps = true;
 58170: #if defined(__ANDROID__)
 58170:   // On Android, the callback will do dump generation, since it needs
 58170:   // to pass the library mappings.
 58170:   generateDumps = false;
 58170: #endif
 37203:   crashServer = new CrashGenerationServer(
 37203:     serverSocketFd,
 37203:     OnChildProcessDumpRequested, NULL,
 37203:     NULL, NULL,                 // we don't care about process exit here
 58170:     generateDumps,
 37203:     &dumpPath);
 50679: 
 50679: #elif defined(XP_MACOSX)
 50679:   childCrashNotifyPipe =
 50679:     PR_smprintf("gecko-crash-server-pipe.%i",
 50679:                 static_cast<int>(getpid()));
 50679:   const std::string dumpPath = gExceptionHandler->dump_path();
 50679: 
 50679:   crashServer = new CrashGenerationServer(
 50679:     childCrashNotifyPipe,
103475:     ChildFilter,
103475:     NULL,
 50679:     OnChildProcessDumpRequested, NULL,
 50679:     NULL, NULL,
 50679:     true, // automatically generate dumps
 50679:     dumpPath);
 37203: #endif
 37203: 
 37203:   if (!crashServer->Start())
 37203:     NS_RUNTIMEABORT("can't start crash reporter server()");
 37382: 
 37382:   pidToMinidump = new ChildMinidumpMap();
 37382:   pidToMinidump->Init();
 37382: 
 37382:   dumpMapLock = new Mutex("CrashReporter::dumpMapLock");
104355: 
104355:   nsCOMPtr<nsIFile> pendingDir;
104355:   nsresult rv = NS_GetSpecialDirectory("UAppData", getter_AddRefs(pendingDir));
104355:   if (NS_FAILED(rv)) {
104355:     NS_WARNING("Couldn't get the user appdata directory, crash dumps will go in an unusual location");
104355:   }
104355:   else {
104355:     pendingDir->Append(NS_LITERAL_STRING("Crash Reports"));
104355:     pendingDir->Append(NS_LITERAL_STRING("pending"));
104355: 
104355: #ifdef XP_WIN
104355:     nsString path;
104355:     pendingDir->GetPath(path);
104355:     pendingDirectory = ToNewUnicode(path);
104355: #else
104355:     nsCString path;
104355:     pendingDir->GetNativePath(path);
104355:     pendingDirectory = ToNewCString(path);
104355: #endif
104355:   }
 37203: }
 37203: 
 37385: static void
 37385: OOPDeinit()
 37385: {
 37385:   if (!OOPInitialized()) {
 37385:     NS_WARNING("OOPDeinit() without successful OOPInit()");
 37385:     return;
 37385:   }
 37385: 
103451: #ifdef MOZ_CRASHREPORTER_INJECTOR
103451:   if (sInjectorThread) {
103451:     sInjectorThread->Shutdown();
103451:     NS_RELEASE(sInjectorThread);
103451:   }
103451: #endif
103451: 
 37385:   delete crashServer;
 37385:   crashServer = NULL;
 37385: 
 37385:   delete dumpMapLock;
 37385:   dumpMapLock = NULL;
 37385: 
 37385:   delete pidToMinidump;
 37385:   pidToMinidump = NULL;
 37385: 
 37385: #if defined(XP_WIN)
 37385:   PR_Free(childCrashNotifyPipe);
 37385:   childCrashNotifyPipe = NULL;
 37385: #endif
 37385: }
 37385: 
 50679: #if defined(XP_WIN) || defined(XP_MACOSX)
 37203: // Parent-side API for children
 37208: const char*
 37203: GetChildNotificationPipe()
 37203: {
 37203:   if (!GetEnabled())
 37208:     return kNullNotifyPipe;
 37203: 
104355:   MOZ_ASSERT(OOPInitialized());
 37203: 
 37208:   return childCrashNotifyPipe;
 37203: }
 50679: #endif
 37203: 
103451: #ifdef MOZ_CRASHREPORTER_INJECTOR
103451: void
103451: InjectCrashReporterIntoProcess(DWORD processID, InjectorCrashCallback* cb)
103451: {
103451:   if (!GetEnabled())
103451:     return;
103451: 
103451:   if (!OOPInitialized())
103451:     OOPInit();
103451: 
103451:   if (!sInjectorThread) {
103451:     if (NS_FAILED(NS_NewThread(&sInjectorThread)))
103451:       return;
103451:   }
103451: 
104355:   {
104355:     MutexAutoLock lock(*dumpMapLock);
104355:     ChildProcessData* pd = pidToMinidump->PutEntry(processID);
104355:     MOZ_ASSERT(!pd->minidump && !pd->callback);
104355:     pd->callback = cb;
104355:   }
103451: 
103451:   nsCOMPtr<nsIRunnable> r = new InjectCrashRunnable(processID);
103451:   sInjectorThread->Dispatch(r, nsIEventTarget::DISPATCH_NORMAL);
103451: }
103451: 
103451: NS_IMETHODIMP
103451: ReportInjectedCrash::Run()
103451: {
103451:   // Crash reporting may have been disabled after this method was dispatched
104355:   if (!OOPInitialized())
103451:     return NS_OK;
103451: 
104355:   InjectorCrashCallback* cb;
104355:   {
104355:     MutexAutoLock lock(*dumpMapLock);
104355:     ChildProcessData* pd = pidToMinidump->GetEntry(mPID);
104355:     if (!pd || !pd->callback)
103451:       return NS_OK;
103451: 
104355:     MOZ_ASSERT(pd->minidump);
104355: 
104355:     cb = pd->callback;
103451:   }
103451: 
104355:   cb->OnCrash(mPID);
103451:   return NS_OK;
103451: }
103451: 
103451: void
103451: UnregisterInjectorCallback(DWORD processID)
103451: {
103451:   if (!OOPInitialized())
103451:     return;
103451: 
104355:   MutexAutoLock lock(*dumpMapLock);
104355:   pidToMinidump->RemoveEntry(processID);
103451: }
103451: 
103451: #endif // MOZ_CRASHREPORTER_INJECTOR
103451: 
 50679: #if defined(XP_WIN)
 37203: // Child-side API
 37203: bool
 37203: SetRemoteExceptionHandler(const nsACString& crashPipe)
 37203: {
 37203:   // crash reporting is disabled
 37203:   if (crashPipe.Equals(kNullNotifyPipe))
 37203:     return true;
 37203: 
 37203:   NS_ABORT_IF_FALSE(!gExceptionHandler, "crash client already init'd");
 37203: 
 37203:   gExceptionHandler = new google_breakpad::
 37203:     ExceptionHandler(L"",
 79571:                      FPEFilter,
 37203:                      NULL,    // no minidump callback
 37203:                      NULL,    // no callback context
 37203:                      google_breakpad::ExceptionHandler::HANDLER_ALL,
 37203:                      MiniDumpNormal,
 37203:                      NS_ConvertASCIItoUTF16(crashPipe).BeginReading(),
 37203:                      NULL);
 60402: #ifdef XP_WIN
 60402:   gExceptionHandler->set_handle_debug_exceptions(true);
 60402: #endif
 37203: 
 37203:   // we either do remote or nothing, no fallback to regular crash reporting
 37203:   return gExceptionHandler->IsOutOfProcess();
 37203: }
 37203: 
 37203: //--------------------------------------------------
 40006: #elif defined(XP_LINUX)
 37203: 
 37203: // Parent-side API for children
 37203: bool
 37203: CreateNotificationPipeForChild(int* childCrashFd, int* childCrashRemapFd)
 37203: {
 37203:   if (!GetEnabled()) {
 37203:     *childCrashFd = -1;
 37203:     *childCrashRemapFd = -1;
 37203:     return true;
 37203:   }
 37203: 
104355:   MOZ_ASSERT(OOPInitialized());
 37203: 
 37203:   *childCrashFd = clientSocketFd;
 37203:   *childCrashRemapFd = kMagicChildCrashReportFd;
 37203: 
 37203:   return true;
 37203: }
 37203: 
 37203: // Child-side API
 37203: bool
 37203: SetRemoteExceptionHandler()
 37203: {
 37203:   NS_ABORT_IF_FALSE(!gExceptionHandler, "crash client already init'd");
 37203: 
 37203:   gExceptionHandler = new google_breakpad::
 37203:     ExceptionHandler("",
 37203:                      NULL,    // no filter callback
 37203:                      NULL,    // no minidump callback
 37203:                      NULL,    // no callback context
 37203:                      true,    // install signal handlers
 37203:                      kMagicChildCrashReportFd);
 37203: 
 79570:   if (gDelayedAnnotations) {
 79570:     for (PRUint32 i = 0; i < gDelayedAnnotations->Length(); i++) {
 79570:       gDelayedAnnotations->ElementAt(i)->Run();
 79570:     }
 79570:     delete gDelayedAnnotations;
 79570:   }
 79570: 
 37203:   // we either do remote or nothing, no fallback to regular crash reporting
 37203:   return gExceptionHandler->IsOutOfProcess();
 37203: }
 37203: 
 40723: //--------------------------------------------------
 40723: #elif defined(XP_MACOSX)
 50679: // Child-side API
 50679: bool
 50679: SetRemoteExceptionHandler(const nsACString& crashPipe)
 40723: {
 50679:   // crash reporting is disabled
 50679:   if (crashPipe.Equals(kNullNotifyPipe))
 50679:     return true;
 50679: 
 50679:   NS_ABORT_IF_FALSE(!gExceptionHandler, "crash client already init'd");
 50679: 
 50679:   gExceptionHandler = new google_breakpad::
 50679:     ExceptionHandler("",
103475:                      Filter,
 50679:                      NULL,    // no minidump callback
 50679:                      NULL,    // no callback context
 50679:                      true,    // install signal handlers
 50679:                      crashPipe.BeginReading());
 50679: 
 50679:   // we either do remote or nothing, no fallback to regular crash reporting
 50679:   return gExceptionHandler->IsOutOfProcess();
 40723: }
 37204: #endif  // XP_WIN
 37203: 
 37203: 
 37203: bool
104355: TakeMinidumpForChild(PRUint32 childPid, nsIFile** dump, PRUint32* aSequence)
 37382: {
 37382:   if (!GetEnabled())
 37382:     return false;
 37382: 
 37382:   MutexAutoLock lock(*dumpMapLock);
 39618: 
104355:   ChildProcessData* pd = pidToMinidump->GetEntry(childPid);
104355:   if (!pd)
104355:     return false;
 39618: 
104355:   NS_IF_ADDREF(*dump = pd->minidump);
104355:   if (aSequence) {
104355:     *aSequence = pd->sequence;
104355:   }
 39618:   
104355:   pidToMinidump->RemoveEntry(childPid);
104355: 
104355:   return !!*dump;
 37382: }
 37382: 
 39791: //-----------------------------------------------------------------------------
 39791: // CreatePairedMinidumps() and helpers
 39791: //
 39791: struct PairedDumpContext {
101111:   nsCOMPtr<nsIFile>* minidump;
101111:   nsCOMPtr<nsIFile>* extra;
 39791:   const Blacklist& blacklist;
 39791: };
 39791: 
 39791: static bool
 39791: PairedDumpCallback(const XP_CHAR* dump_path,
 39791:                    const XP_CHAR* minidump_id,
 39791:                    void* context,
 39791: #ifdef XP_WIN32
 39791:                    EXCEPTION_POINTERS* /*unused*/,
 39791:                    MDRawAssertionInfo* /*unused*/,
 39791: #endif
 39791:                    bool succeeded)
 39791: {
 39791:   PairedDumpContext* ctx = static_cast<PairedDumpContext*>(context);
101111:   nsCOMPtr<nsIFile>& minidump = *ctx->minidump;
101111:   nsCOMPtr<nsIFile>& extra = *ctx->extra;
 39791:   const Blacklist& blacklist = ctx->blacklist;
 39791: 
 39792:   xpstring dump(dump_path);
 39792:   dump += XP_PATH_SEPARATOR;
 39792:   dump += minidump_id;
 39792:   dump += dumpFileExtension;
 39791: 
 39792:   CreateFileFromPath(dump, getter_AddRefs(minidump));
 39791:   return WriteExtraForMinidump(minidump, blacklist, getter_AddRefs(extra));
 39791: }
 39791: 
 40022: ThreadId
 40022: CurrentThreadId()
 40022: {
 40022: #if defined(XP_WIN)
 40022:   return ::GetCurrentThreadId();
 40022: #elif defined(XP_LINUX)
 40022:   return sys_gettid();
 40022: #elif defined(XP_MACOSX)
 51563:   // Just return an index, since Mach ports can't be directly serialized
 51563:   thread_act_port_array_t   threads_for_task;
 51563:   mach_msg_type_number_t    thread_count;
 51563: 
 51563:   if (task_threads(mach_task_self(), &threads_for_task, &thread_count))
 51563:     return -1;
 51563: 
 51563:   for (unsigned int i = 0; i < thread_count; ++i) {
 51563:     if (threads_for_task[i] == mach_thread_self())
 51563:       return i;
 51563:   }
 61098:   abort();
 40022: #else
 40022: #  error "Unsupported platform"
 40022: #endif
 40022: }
 40022: 
 39791: bool
 39791: CreatePairedMinidumps(ProcessHandle childPid,
 40023:                       ThreadId childBlamedThread,
 39791:                       nsAString* pairGUID,
101111:                       nsIFile** childDump,
101111:                       nsIFile** parentDump)
 39791: {
 39791:   if (!GetEnabled())
 39791:     return false;
 39791: 
 39791:   // create the UUID for the hang dump as a pair
 39791:   nsresult rv;
 39791:   nsCOMPtr<nsIUUIDGenerator> uuidgen =
 39791:     do_GetService("@mozilla.org/uuid-generator;1", &rv);
 39791:   NS_ENSURE_SUCCESS(rv, false);  
 39791: 
 39791:   nsID id;
 39791:   rv = uuidgen->GenerateUUIDInPlace(&id);
 39791:   NS_ENSURE_SUCCESS(rv, false);
 39791:   
 39791:   char chars[NSID_LENGTH];
 39791:   id.ToProvidedString(chars);
 39791:   CopyASCIItoUTF16(chars, *pairGUID);
 39791: 
 39791:   // trim off braces
 39791:   pairGUID->Cut(0, 1);
 39791:   pairGUID->Cut(pairGUID->Length()-1, 1);
 39791: 
 51563: #ifdef XP_MACOSX
 51563:   mach_port_t childThread = MACH_PORT_NULL;
 51563:   thread_act_port_array_t   threads_for_task;
 51563:   mach_msg_type_number_t    thread_count;
 51563: 
 51563:   if (task_threads(childPid, &threads_for_task, &thread_count)
 51563:       == KERN_SUCCESS && childBlamedThread < thread_count) {
 51563:     childThread = threads_for_task[childBlamedThread];
 51563:   }
 51563: #else
 51563:   ThreadId childThread = childBlamedThread;
 51563: #endif
 51563: 
 39791:   // dump the child
101111:   nsCOMPtr<nsIFile> childMinidump;
101111:   nsCOMPtr<nsIFile> childExtra;
 39791:   Blacklist childBlacklist(kSubprocessBlacklist,
 80467:                            ArrayLength(kSubprocessBlacklist));
 39791:   PairedDumpContext childCtx =
 39791:     { &childMinidump, &childExtra, childBlacklist };
 39791:   if (!google_breakpad::ExceptionHandler::WriteMinidumpForChild(
 39791:          childPid,
 51563:          childThread,
 39791:          gExceptionHandler->dump_path(),
 39791:          PairedDumpCallback,
 39791:          &childCtx))
 39791:     return false;
 39791: 
 39791:   // dump the parent
101111:   nsCOMPtr<nsIFile> parentMinidump;
101111:   nsCOMPtr<nsIFile> parentExtra;
 39791:   // nothing's blacklisted for this process
 39791:   Blacklist parentBlacklist;
 39791:   PairedDumpContext parentCtx =
 39791:     { &parentMinidump, &parentExtra, parentBlacklist };
 39791:   if (!google_breakpad::ExceptionHandler::WriteMinidump(
 39791:          gExceptionHandler->dump_path(),
 40025:          true,                  // write exception stream
 39791:          PairedDumpCallback,
 39791:          &parentCtx))
 39791:     return false;
 39791: 
 39791:   // success
 39791:   if (ShouldReport()) {
 39791:     MoveToPending(childMinidump, childExtra);
 39791:     MoveToPending(parentMinidump, parentExtra);
 39791:   }
 39791: 
 39791:   *childDump = NULL;
 39791:   *parentDump = NULL;
 39791:   childMinidump.swap(*childDump);
 39791:   parentMinidump.swap(*parentDump);
 39791: 
 39791:   return true;
 39791: }
 39791: 
 37382: bool
 37203: UnsetRemoteExceptionHandler()
 37203: {
 37203:   delete gExceptionHandler;
 37203:   gExceptionHandler = NULL;
 37203:   return true;
 37203: }
 37203: 
 56284: #if defined(__ANDROID__)
 56284: void AddLibraryMapping(const char* library_name,
 56284:                        const char* file_id,
 56284:                        uintptr_t   start_address,
 56284:                        size_t      mapping_length,
 56284:                        size_t      file_offset)
 56284: {
 56284:   if (!gExceptionHandler) {
 56284:     mapping_info info;
 56284:     info.name = library_name;
 56284:     info.debug_id = file_id;
 56284:     info.start_address = start_address;
 56284:     info.length = mapping_length;
 56284:     info.file_offset = file_offset;
 56284:     library_mappings.push_back(info);
 56284:   }
 56284:   else {
 56284:     u_int8_t guid[sizeof(MDGUID)];
 56284:     FileIDToGUID(file_id, guid);
 56284:     gExceptionHandler->AddMappingInfo(library_name,
 56284:                                       guid,
 56284:                                       start_address,
 56284:                                       mapping_length,
 56284:                                       file_offset);
 56284:   }
 56284: }
 58170: 
 58170: void AddLibraryMappingForChild(PRUint32    childPid,
 58170:                                const char* library_name,
 58170:                                const char* file_id,
 58170:                                uintptr_t   start_address,
 58170:                                size_t      mapping_length,
 58170:                                size_t      file_offset)
 58170: {
 58170:   if (child_library_mappings.find(childPid) == child_library_mappings.end())
 58170:     child_library_mappings[childPid] = google_breakpad::MappingList();
 58170:   google_breakpad::MappingInfo info;
 58170:   info.start_addr = start_address;
 58170:   info.size = mapping_length;
 58170:   info.offset = file_offset;
 58170:   strcpy(info.name, library_name);
 58170:  
 58170:   std::pair<google_breakpad::MappingInfo, u_int8_t[sizeof(MDGUID)]> mapping;
 58170:   mapping.first = info;
 58170:   u_int8_t guid[sizeof(MDGUID)];
 58170:   FileIDToGUID(file_id, guid);
 58170:   memcpy(mapping.second, guid, sizeof(MDGUID));
 58170:   child_library_mappings[childPid].push_back(mapping);
 58170: }
 58170: 
 58170: void RemoveLibraryMappingsForChild(PRUint32 childPid)
 58170: {
 58170:   MappingMap::iterator iter = child_library_mappings.find(childPid);
 58170:   if (iter != child_library_mappings.end())
 58170:     child_library_mappings.erase(iter);
 58170: }
 58170: #endif
 56284: 
  3866: } // namespace CrashReporter
