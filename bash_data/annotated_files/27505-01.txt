    1: /* -*- Mode: C++; tab-width: 2; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Paul Ashford <arougthopher@lizardland.net>
    1:  *   Sergei Dolgov <sergei_d@fi.tartu.ee>
    1:  *   Fredrik Holmqvist <thesuckiestemail@yahoo.se>
 3368:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDebug.h"
    1: #include "nsWindow.h"
    1: #include "nsIAppShell.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsFont.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIDragService.h"
    1: #include "nsIDragSessionBeOS.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsRect.h"
    1: #include "nsIRegion.h"
    1: #include "nsTransform2D.h"
    1: #include "nsGfxCIID.h"
    1: #include "resource.h"
    1: #include "prtime.h"
    1: #include "nsReadableUtils.h"
25381: #include "nsTPtrArray.h"
    1: #include "nsIProxyObjectManager.h"
    1: 
    1: #include <Application.h>
    1: #include <InterfaceDefs.h>
    1: #include <Region.h>
    1: #include <ScrollBar.h>
    1: #include <app/Message.h>
    1: #include <support/String.h>
    1: #include <Screen.h>
    1: 
    1: #include <nsBeOSCursors.h>
    1: #if defined(BeIME)
    1: #include <Input.h>
    1: #include <InputServerMethod.h>
    1: #include <String.h>
    1: #endif
    1: #include "nsIRollupListener.h"
    1: #include "nsIMenuRollup.h"
    1: 
    1: #include "gfxBeOSSurface.h"
    1: #include "gfxContext.h"
    1: 
    1: // See comments in nsWindow.h as to why we override these calls from nsBaseWidget
    1: NS_IMPL_THREADSAFE_ADDREF(nsWindow)
    1: NS_IMPL_THREADSAFE_RELEASE(nsWindow)
    1: 
    1: static NS_DEFINE_IID(kIWidgetIID,       NS_IWIDGET_IID);
    1: static NS_DEFINE_IID(kRegionCID, NS_REGION_CID);
    1: static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
    1: //-------------------------------------------------------------------------
    1: // Global Definitions
    1: //-------------------------------------------------------------------------
    1: 
    1: // Rollup Listener - static variable defintions
    1: static nsIRollupListener * gRollupListener           = nsnull;
    1: static nsIWidget         * gRollupWidget             = nsnull;
    1: static PRBool              gRollupConsumeRollupEvent = PR_FALSE;
    1: // Tracking last activated BWindow
    1: static BWindow           * gLastActiveWindow = NULL;
    1: 
    1: // BCursor objects can't be created until they are used.  Some mozilla utilities, 
    1: // such as regxpcom, do not create a BApplication object, and therefor fail to run.,
    1: // since a BCursor requires a vaild BApplication (see Bug#129964).  But, we still want
    1: // to cache them for performance.  Currently, there are 17 cursors available;
25381: static nsTPtrArray<BCursor> gCursorArray(21);
    1: // Used in contrain position.  Specifies how much of a window must remain on screen
    1: #define kWindowPositionSlop 20
    1: // BeOS does not provide this information, so we must hard-code it
    1: #define kWindowBorderWidth 5
    1: #define kWindowTitleBarHeight 24
    1: 
    1: // TODO: make a #def for using OutLine view or not (see TODO below)
    1: #if defined(BeIME)
    1: #include "nsUTF8Utils.h"
    1: static inline uint32 utf8_str_len(const char* ustring, int32 length) 
    1: {
    1: 	CalculateUTF8Length cutf8;
    1: 	cutf8.write(ustring, length);
    1: 	return cutf8.Length();       
    1: }
    1: 
    1: nsIMEBeOS::nsIMEBeOS()
    1: 	: imeTarget(NULL)
    1: 	, imeState(NS_COMPOSITION_END), imeWidth(14)
    1: {
    1: }
    1: /* placeholder for possible cleanup
    1: nsIMEBeOS::~nsIMEBeOS()
    1: {
    1: }
    1: */								
    1: void nsIMEBeOS::RunIME(uint32 *args, nsWindow *target, BView *fView)
    1: {
    1: 	BMessage msg;
    1: 	msg.Unflatten((const char*)args);
    1: 
    1: 	switch (msg.FindInt32("be:opcode")) 
    1: 	{
    1: 	case B_INPUT_METHOD_CHANGED:
    1: 		if (msg.HasString("be:string")) 
    1: 		{
    1: 			const char* src = msg.FindString("be:string");
    1: 			CopyUTF8toUTF16(src, imeText);
    1:  
    1:     		if (msg.FindBool("be:confirmed")) 
    1:     		{	
    1:     			if (imeState != NS_COMPOSITION_END)
    1:    					DispatchText(imeText, 0, NULL);
    1:    			}
    1:    			else 
    1:    			{
    1:    				nsTextRange txtRuns[2];
    1:    				PRUint32 txtCount = 2;
    1: 
    1: 	 	    	int32 select[2];
    1:  				select[0] = msg.FindInt32("be:selection", int32(0));
    1: 				select[1] = msg.FindInt32("be:selection", 1);
    1: 
    1: 	 			txtRuns[0].mStartOffset = (select[0] == select[1]) ? 0 : utf8_str_len(src, select[1]);
    1: 	 			txtRuns[0].mEndOffset	= imeText.Length();
    1: 				txtRuns[0].mRangeType	= NS_TEXTRANGE_CONVERTEDTEXT;
    1: 				if (select[0] == select[1])
    1: 					txtCount = 1;
    1: 				else 
    1: 				{
    1: 	 				txtRuns[1].mStartOffset = utf8_str_len(src, select[0]);
    1: 	 				txtRuns[1].mEndOffset	= utf8_str_len(src, select[1]);
    1: 	 				txtRuns[1].mRangeType	= NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
    1: 	 			}
    1: 	 			imeTarget = target;
    1: 				DispatchText(imeText, txtCount, txtRuns);
    1: 			}	
    1: 		}	
    1: 		break;
    1: 
    1: 	case B_INPUT_METHOD_LOCATION_REQUEST:
    1: 		if (fView && fView->LockLooper()) 
    1: 		{
    1: 			BPoint caret(imeCaret);
    1: 			DispatchIME(NS_COMPOSITION_QUERY);
    1: 			if (caret.x > imeCaret.x) 
    1: 				caret.x = imeCaret.x - imeWidth * imeText.Length();	/* back */
    1: 
    1: 			BMessage reply(B_INPUT_METHOD_EVENT);
    1: 			reply.AddInt32("be:opcode", B_INPUT_METHOD_LOCATION_REQUEST);
    1: 			for (int32 s= 0; imeText[s]; s++) 
    1: 			{ 
    1: 				reply.AddPoint("be:location_reply", fView->ConvertToScreen(caret));
    1: 				reply.AddFloat("be:height_reply", imeHeight);
    1: 				caret.x += imeWidth;
    1: 			}
    1: 			imeMessenger.SendMessage(&reply);
    1: 			fView->UnlockLooper();
    1: 		}
    1: 		break;
    1: 
    1: 	case B_INPUT_METHOD_STARTED:
    1: 		imeTarget = target;
    1: 		DispatchIME(NS_COMPOSITION_START);
    1: 		DispatchIME(NS_COMPOSITION_QUERY);
    1: 
    1: 		msg.FindMessenger("be:reply_to", &imeMessenger);
    1: 		break;
    1: 	
    1: 	case B_INPUT_METHOD_STOPPED:
    1: 		if (imeState != NS_COMPOSITION_END)
    1: 			DispatchIME(NS_COMPOSITION_END);
    1: 		imeText.Truncate();
    1: 		break;
    1: 	};
    1: }
    1: 
    1: void nsIMEBeOS::DispatchText(nsString &text, PRUint32 txtCount, nsTextRange* txtRuns)
    1: {
    1: 	nsTextEvent textEvent(PR_TRUE,NS_TEXT_TEXT, imeTarget);
    1: 
    1: 	textEvent.time 		= 0;
    1: 	textEvent.isShift   = 
    1: 	textEvent.isControl =
    1: 	textEvent.isAlt 	= 
    1: 	textEvent.isMeta 	= PR_FALSE;
    1:   
    1: 	textEvent.refPoint.x	= 
    1: 	textEvent.refPoint.y	= 0;
    1: 
    1: 	textEvent.theText 	= text.get();
    1: 	textEvent.isChar	= PR_TRUE;
    1: 	textEvent.rangeCount= txtCount;
    1: 	textEvent.rangeArray= txtRuns;
    1: 
    1: 	DispatchWindowEvent(&textEvent);
    1: }
    1: 
    1: void nsIMEBeOS::DispatchCancelIME()
    1: {
    1: 	if (imeText.Length() && imeState != NS_COMPOSITION_END) 
    1: 	{
    1: 		BMessage reply(B_INPUT_METHOD_EVENT);
    1: 		reply.AddInt32("be:opcode", B_INPUT_METHOD_STOPPED);
    1: 		imeMessenger.SendMessage(&reply);
    1: 
    1: 		DispatchText(imeText, 0, NULL);
    1: 		DispatchIME(NS_COMPOSITION_END);
    1: 
    1: 		imeText.Truncate();
    1: 	}
    1: }
    1: 
    1: void nsIMEBeOS::DispatchIME(PRUint32 what)
    1: {
    1: 	nsCompositionEvent compEvent(PR_TRUE, what, imeTarget);
    1: 
    1: 	compEvent.refPoint.x =
    1: 	compEvent.refPoint.y = 0;
    1: 	compEvent.time 	 = 0;
    1: 
    1: 	DispatchWindowEvent(&compEvent);
    1: 	imeState = what;
    1: 
    1: 	if (what == NS_COMPOSITION_QUERY) 
    1: 	{
    1: 		imeCaret.Set(compEvent.theReply.mCursorPosition.x,
    1: 		           compEvent.theReply.mCursorPosition.y);
    1: 		imeHeight = compEvent.theReply.mCursorPosition.height+4;
    1: 	}
    1: }
    1: 
    1: PRBool nsIMEBeOS::DispatchWindowEvent(nsGUIEvent* event)
    1: {
    1: 	nsEventStatus status;
    1: 	imeTarget->DispatchEvent(event, status);
    1: 	return PR_FALSE;
    1: }
    1: // There is only one IME instance per app, actually it may be set as global
    1: nsIMEBeOS *nsIMEBeOS::GetIME()
    1: {
    1: 	if(beosIME == 0)
    1: 		beosIME = new nsIMEBeOS();
    1: 	return beosIME;
    1: }
    1: nsIMEBeOS *nsIMEBeOS::beosIME = 0;
    1: #endif
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsWindow constructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsWindow::nsWindow() : nsBaseWidget()
    1: {
    1: 	mView               = 0;
    1: 	mPreferredWidth     = 0;
    1: 	mPreferredHeight    = 0;
    1: 	mFontMetrics        = nsnull;
27505: 	mIsShiftDown        = PR_FALSE;
27505: 	mIsControlDown      = PR_FALSE;
27505: 	mIsAltDown          = PR_FALSE;
27505: 	mIsDestroying       = PR_FALSE;
    1: 	mIsVisible          = PR_FALSE;
    1: 	mEnabled            = PR_TRUE;
    1: 	mIsScrolling        = PR_FALSE;
    1: 	mParent             = nsnull;
    1: 	mWindowParent       = nsnull;
    1: 	mUpdateArea = do_CreateInstance(kRegionCID);
    1: 	mForeground = NS_RGBA(0xFF,0xFF,0xFF,0xFF);
    1: 	mBackground = mForeground;
    1: 	mBWindowFeel        = B_NORMAL_WINDOW_FEEL;
    1: 	mBWindowLook        = B_NO_BORDER_WINDOW_LOOK;
    1: 
    1: 	if (mUpdateArea)
    1: 	{
    1: 		mUpdateArea->Init();
    1: 		mUpdateArea->SetTo(0, 0, 0, 0);
    1: 	}
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsWindow destructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsWindow::~nsWindow()
    1: {
    1: 	mIsDestroying = PR_TRUE;
    1: 
    1: 	// If the widget was released without calling Destroy() then the native
    1: 	// window still exists, and we need to destroy it
    1: 	if (NULL != mView) 
    1: 	{
    1: 		Destroy();
    1: 	}
    1: 	NS_IF_RELEASE(mFontMetrics);
    1: }
    1: 
    1: NS_METHOD nsWindow::BeginResizingChildren(void)
    1: {
    1: 	// HideKids(PR_TRUE) may be used here
    1: 	NS_NOTYETIMPLEMENTED("BeginResizingChildren not yet implemented"); // to be implemented
    1: 	return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::EndResizingChildren(void)
    1: {
    1: 	// HideKids(PR_FALSE) may be used here
    1: 	NS_NOTYETIMPLEMENTED("EndResizingChildren not yet implemented"); // to be implemented
    1: 	return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::WidgetToScreen(const nsRect& aOldRect, nsRect& aNewRect)
    1: {
    1: 	BPoint	point;
    1: 	point.x = aOldRect.x;
    1: 	point.y = aOldRect.y;
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		mView->ConvertToScreen(&point);
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	aNewRect.x = nscoord(point.x);
    1: 	aNewRect.y = nscoord(point.y);
    1: 	aNewRect.width = aOldRect.width;
    1: 	aNewRect.height = aOldRect.height;
    1: 	return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::ScreenToWidget(const nsRect& aOldRect, nsRect& aNewRect)
    1: {
    1: 	BPoint	point;
    1: 	point.x = aOldRect.x;
    1: 	point.y = aOldRect.y;
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		mView->ConvertFromScreen(&point);
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	aNewRect.x = nscoord(point.x);
    1: 	aNewRect.y = nscoord(point.y);
    1: 	aNewRect.width = aOldRect.width;
    1: 	aNewRect.height = aOldRect.height;
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Initialize an event to dispatch
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsWindow::InitEvent(nsGUIEvent& event, nsPoint* aPoint)
    1: {
    1: 	NS_ADDREF(event.widget);
    1: 
    1: 	if (nsnull == aPoint) // use the point from the event
    1: 	{
    1: 		// get the message position in client coordinates and in twips
    1: 		event.refPoint.x = 0;
    1: 		event.refPoint.y = 0;
    1: 	}
    1: 	else // use the point override if provided
    1: 	{
    1: 		event.refPoint.x = aPoint->x;
    1: 		event.refPoint.y = aPoint->y;
    1: 	}
    1: 	event.time = PR_IntervalNow();
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invokes callback and  ProcessEvent method on Event Listener object
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus)
    1: {
    1: 	aStatus = nsEventStatus_eIgnore;
    1: 
    1: 	nsCOMPtr <nsIWidget> mWidget = event->widget;
    1: 
    1: 	if (mEventCallback)
    1: 		aStatus = (*mEventCallback)(event);
    1: 
    1: 	if ((aStatus != nsEventStatus_eIgnore) && (mEventListener))
    1: 		aStatus = mEventListener->ProcessEvent(*event);
    1: 
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Dispatch Window Event
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchWindowEvent(nsGUIEvent* event)
    1: {
    1: 	nsEventStatus status;
    1: 	DispatchEvent(event, status);
    1: 	return ConvertStatus(status);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Dispatch standard event
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: PRBool nsWindow::DispatchStandardEvent(PRUint32 aMsg)
    1: {
    1: 	nsGUIEvent event(PR_TRUE, aMsg, this);
    1: 	InitEvent(event);
    1: 
    1: 	PRBool result = DispatchWindowEvent(&event);
    1: 	NS_RELEASE(event.widget);
    1: 	return result;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::PreCreateWidget(nsWidgetInitData *aInitData)
    1: {
    1: 	if ( nsnull == aInitData)
    1: 		return NS_ERROR_FAILURE;
    1: 	
    1: 	SetWindowType(aInitData->mWindowType);
    1: 	SetBorderStyle(aInitData->mBorderStyle);
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Utility method for implementing both Create(nsIWidget ...) and
    1: // Create(nsNativeWidget...)
    1: //-------------------------------------------------------------------------
    1: nsresult nsWindow::StandardWindowCreate(nsIWidget *aParent,
    1:                                         const nsRect &aRect,
    1:                                         EVENT_CALLBACK aHandleEventFunction,
    1:                                         nsIDeviceContext *aContext,
    1:                                         nsIAppShell *aAppShell,
    1:                                         nsIToolkit *aToolkit,
    1:                                         nsWidgetInitData *aInitData,
    1:                                         nsNativeWidget aNativeParent)
    1: {
    1: 
    1: 	//Do as little as possible for invisible windows, why are these needed?
    1: 	if (aInitData->mWindowType == eWindowType_invisible)
    1: 		return NS_ERROR_FAILURE;
    1: 		
    1: 	NS_ASSERTION(aInitData->mWindowType == eWindowType_dialog
    1: 		|| aInitData->mWindowType == eWindowType_toplevel,
    1: 		"The windowtype is not handled by this class.");
    1: 
    1: 	mIsTopWidgetWindow = PR_TRUE;
    1: 	
    1: 	BaseCreate(nsnull, aRect, aHandleEventFunction, aContext,
    1: 	           aAppShell, aToolkit, aInitData);
    1: 
    1: 	mListenForResizes = aNativeParent ? PR_TRUE : aInitData->mListenForResizes;
    1: 		
    1: 	mParent = aParent;
    1: 	// Useful shortcut, wondering if we can use it also in GetParent() instead
    1: 	// nsIWidget* type mParent.
    1: 	mWindowParent = (nsWindow *)aParent;
    1: 	SetBounds(aRect);
    1: 
    1: 	// Default mode for window, everything switched off.
    1: 	uint32 flags = B_NOT_RESIZABLE | B_NOT_MINIMIZABLE | B_NOT_ZOOMABLE
    1: 		| B_NOT_CLOSABLE | B_ASYNCHRONOUS_CONTROLS;
    1: 
    1: 	//eBorderStyle_default is to ask the OS to handle it as it sees best.
    1: 	//eBorderStyle_all is same as top_level window default.
    1: 	if (eBorderStyle_default == mBorderStyle || eBorderStyle_all & mBorderStyle)
    1: 	{
    1: 		//(Firefox prefs doesn't go this way, so apparently it wants titlebar, zoom, 
    1: 		//resize and close.)
    1: 
    1: 		//Look and feel for others are set ok at init.
    1: 		if (eWindowType_toplevel==mWindowType)
    1: 		{
    1: 			mBWindowLook = B_TITLED_WINDOW_LOOK;
    1: 			flags = B_ASYNCHRONOUS_CONTROLS;
    1: 		}
    1: 	}
    1: 	else
    1: 	{
    1: 		if (eBorderStyle_border & mBorderStyle)
    1: 			mBWindowLook = B_MODAL_WINDOW_LOOK;
    1: 
    1: 		if (eBorderStyle_resizeh & mBorderStyle)
    1: 		{
    1: 			//Resize demands at least border
    1: 			mBWindowLook = B_MODAL_WINDOW_LOOK;
    1: 			flags &= !B_NOT_RESIZABLE;
    1: 		}
    1: 
    1: 		//We don't have titlebar menus, so treat like title as it demands titlebar.
    1: 		if (eBorderStyle_title & mBorderStyle || eBorderStyle_menu & mBorderStyle)
    1: 			mBWindowLook = B_TITLED_WINDOW_LOOK;
    1: 
    1: 		if (eBorderStyle_minimize & mBorderStyle)
    1: 			flags &= !B_NOT_MINIMIZABLE;
    1: 
    1: 		if (eBorderStyle_maximize & mBorderStyle)
    1: 			flags &= !B_NOT_ZOOMABLE;
    1: 
    1: 		if (eBorderStyle_close & mBorderStyle)
    1: 			flags &= !B_NOT_CLOSABLE;
    1: 	}
    1: 
    1: 	nsWindowBeOS * w = new nsWindowBeOS(this, 
    1: 		BRect(aRect.x, aRect.y, aRect.x + aRect.width - 1, aRect.y + aRect.height - 1),
    1: 		"", mBWindowLook, mBWindowFeel, flags);
    1: 	if (!w)
    1: 		return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1: 	mView = new nsViewBeOS(this, w->Bounds(), "Toplevel view", B_FOLLOW_ALL, 0);
    1: 
    1: 	if (!mView)
    1: 		return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1: 	w->AddChild(mView);
    1: 	// I'm wondering if we can move part of that code to above
    1: 	if (eWindowType_dialog == mWindowType && mWindowParent) 
    1: 	{
    1: 		nsWindow *topparent = mWindowParent;
    1: 		while (topparent->mWindowParent)
    1: 			topparent = topparent->mWindowParent;
    1: 		// may be got via mView and mView->Window() of topparent explicitly	
    1: 		BWindow* subsetparent = (BWindow *)
    1: 			topparent->GetNativeData(NS_NATIVE_WINDOW);
    1: 		if (subsetparent)
    1: 		{
    1: 			mBWindowFeel = B_FLOATING_SUBSET_WINDOW_FEEL;
    1: 			w->SetFeel(mBWindowFeel);
    1: 			w->AddToSubset(subsetparent);
    1: 		}
    1: 	} 
    1: 	// Run Looper. No proper destroy without it.
    1: 	w->Run();
    1: 	DispatchStandardEvent(NS_CREATE);
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Create the proper widget
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Create(nsIWidget *aParent,
    1:                            const nsRect &aRect,
    1:                            EVENT_CALLBACK aHandleEventFunction,
    1:                            nsIDeviceContext *aContext,
    1:                            nsIAppShell *aAppShell,
    1:                            nsIToolkit *aToolkit,
    1:                            nsWidgetInitData *aInitData)
    1: {
    1: 	// Switch to the "main gui thread" if necessary... This method must
    1: 	// be executed on the "gui thread"...
    1: 
    1: 	nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1: 	if (toolkit && !toolkit->IsGuiThread())
    1: 	{
    1: 		nsCOMPtr<nsIWidget> widgetProxy;
    1: 		nsresult rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1: 										NS_GET_IID(nsIWidget),
    1: 										this, 
    1: 										NS_PROXY_SYNC | NS_PROXY_ALWAYS, 
    1: 										getter_AddRefs(widgetProxy));
    1: 	
    1: 		if (NS_FAILED(rv))
    1: 			return rv;
    1: 		return widgetProxy->Create(aParent, aRect, aHandleEventFunction, aContext,
    1:                            			aAppShell, aToolkit, aInitData);
    1: 	}
    1: 	return(StandardWindowCreate(aParent, aRect, aHandleEventFunction,
    1: 	                            aContext, aAppShell, aToolkit, aInitData,
    1: 	                            nsnull));
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // create with a native parent
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_METHOD nsWindow::Create(nsNativeWidget aParent,
    1:                            const nsRect &aRect,
    1:                            EVENT_CALLBACK aHandleEventFunction,
    1:                            nsIDeviceContext *aContext,
    1:                            nsIAppShell *aAppShell,
    1:                            nsIToolkit *aToolkit,
    1:                            nsWidgetInitData *aInitData)
    1: {
    1: 	// Switch to the "main gui thread" if necessary... This method must
    1: 	// be executed on the "gui thread"...
    1: 
    1: 	nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1: 	if (toolkit && !toolkit->IsGuiThread())
    1: 	{
    1: 		nsCOMPtr<nsIWidget> widgetProxy;
    1: 		nsresult rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1: 										NS_GET_IID(nsIWidget),
    1: 										this, 
    1: 										NS_PROXY_SYNC | NS_PROXY_ALWAYS, 
    1: 										getter_AddRefs(widgetProxy));
    1: 	
    1: 		if (NS_FAILED(rv))
    1: 			return rv;
    1: 		return widgetProxy->Create(aParent, aRect, aHandleEventFunction, aContext,
    1:                            			aAppShell, aToolkit, aInitData);
    1: 	}
    1: 	return(StandardWindowCreate(nsnull, aRect, aHandleEventFunction,
    1: 	                            aContext, aAppShell, aToolkit, aInitData,
    1: 	                            aParent));
    1: }
    1: 
    1: gfxASurface*
    1: nsWindow::GetThebesSurface()
    1: {
    1: 	mThebesSurface = nsnull;
    1: 	if (!mThebesSurface) {
    1: 		mThebesSurface = new gfxBeOSSurface(mView);
    1: 	}
    1: 	return mThebesSurface;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Close this nsWindow
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Destroy()
    1: {
    1: 	// Switch to the "main gui thread" if necessary... This method must
    1: 	// be executed on the "gui thread"...
    1: 	nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1: 	if (toolkit != nsnull && !toolkit->IsGuiThread())
    1: 	{
    1: 		nsCOMPtr<nsIWidget> widgetProxy;
    1: 		nsresult rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1: 										NS_GET_IID(nsIWidget),
    1: 										this, 
    1: 										NS_PROXY_SYNC | NS_PROXY_ALWAYS, 
    1: 										getter_AddRefs(widgetProxy));
    1: 	
    1: 		if (NS_FAILED(rv))
    1: 			return rv;
    1: 		return widgetProxy->Destroy();
    1: 	}
    1: 	// Ok, now tell the nsBaseWidget class to clean up what it needs to
    1: 	if (!mIsDestroying)
    1: 	{
    1: 		nsBaseWidget::Destroy();
    1: 	}	
    1: 	//our windows can be subclassed by
    1: 	//others and these namless, faceless others
    1: 	//may not let us know about WM_DESTROY. so,
    1: 	//if OnDestroy() didn't get called, just call
    1: 	//it now.
    1: 	if (PR_FALSE == mOnDestroyCalled)
    1: 		OnDestroy();
    1: 	
    1: 	// Destroy the BView, if no mView, it is probably destroyed before
    1: 	// automatically with BWindow::Quit()
    1: 	if (mView)
    1: 	{
    1: 		// prevent the widget from causing additional events
    1: 		mEventCallback = nsnull;
    1: 	
    1: 		if (mView->LockLooper())
    1: 		{
    1: 			while(mView->ChildAt(0))
    1: 				mView->RemoveChild(mView->ChildAt(0));
    1: 			// destroy from inside
    1: 			BWindow	*w = mView->Window();
    1: 			// if no window, it was destroyed as result of B_QUIT_REQUESTED and 
    1: 			// took also all its children away
    1: 			if (w)
    1: 			{
    1: 				w->Sync();
    1: 				if (mView->Parent())
    1: 				{
    1: 					mView->Parent()->RemoveChild(mView);
    1: 					if (eWindowType_child != mWindowType)
    1: 						w->Quit();
    1: 					else
    1: 					w->Unlock();
    1: 				}
    1: 				else
    1: 				{
    1: 					w->RemoveChild(mView);
    1: 					w->Quit();
    1: 				}
    1: 			}
    1: 			else
    1: 				mView->RemoveSelf();
    1: 
    1: 			delete mView;
    1: 		}
    1: 
    1: 		// window is already gone
    1: 		mView = NULL;
    1: 	}
    1: 	mParent = nsnull;
    1: 	mWindowParent = nsnull;
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this nsWindow parent
    1: //
    1: //-------------------------------------------------------------------------
    1: nsIWidget* nsWindow::GetParent(void)
    1: {
    1: 	//We cannot addref mParent directly
    1: 	nsIWidget	*widget = 0;
    1: 	if (mIsDestroying || mOnDestroyCalled)
    1: 		return nsnull;
    1: 	widget = (nsIWidget *)mParent;
    1: 	return  widget;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Hide or show this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Show(PRBool bState)
    1: {
    1: 	if (!mEnabled)
    1: 		return NS_OK;
    1: 		
    1: 
    1: 	if (!mView || !mView->LockLooper())
    1: 		return NS_OK;
    1: 		
    1: 	//We need to do the IsHidden() checks
    1: 	//because BeOS counts no of Hide()
    1: 	//and Show() checks. BeBook:
    1: 	// If Hide() is called more than once, you'll need to call Show()
    1: 	// an equal number of times for the window to become visible again.
    1: 	if (bState == PR_FALSE)
    1: 	{
    1: 		if (mView->Window() && !mView->Window()->IsHidden())
    1: 			mView->Window()->Hide();
    1: 	}
    1: 	else
    1: 	{
    1: 		if (mView->Window() && mView->Window()->IsHidden())
    1: 			mView->Window()->Show();
    1: 	}
    1: 
    1: 	mView->UnlockLooper();
    1: 	mIsVisible = bState;	
    1: 	
    1: 	return NS_OK;
    1: }
    1: //-------------------------------------------------------------------------
    1: // Set/unset mouse capture
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::CaptureMouse(PRBool aCapture)
    1: {
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		if (PR_TRUE == aCapture)
    1: 			mView->SetEventMask(B_POINTER_EVENTS);
    1: 		else
    1: 			mView->SetEventMask(0);
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	return NS_OK;
    1: }
    1: //-------------------------------------------------------------------------
    1: // Capture Roolup Events
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::CaptureRollupEvents(nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent)
    1: {
    1: 	if (!mEnabled)
    1: 		return NS_OK;
    1: 		
    1: 	if (aDoCapture) 
    1: 	{
    1: 		// we haven't bothered carrying a weak reference to gRollupWidget because
    1: 		// we believe lifespan is properly scoped. this next assertion helps 
    1: 		// assure that remains true.
    1: 		NS_ASSERTION(!gRollupWidget, "rollup widget reassigned before release");
    1: 		gRollupConsumeRollupEvent = aConsumeRollupEvent;
    1: 		NS_IF_RELEASE(gRollupListener);
    1: 		NS_IF_RELEASE(gRollupWidget);
    1: 		gRollupListener = aListener;
    1: 		NS_ADDREF(aListener);
    1: 		gRollupWidget = this;
    1: 		NS_ADDREF(this);
    1: 	} 
    1: 	else 
    1: 	{
    1: 		NS_IF_RELEASE(gRollupListener);
    1: 		NS_IF_RELEASE(gRollupWidget);
    1: 	}
    1: 
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // Check if event happened inside the given nsWindow
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::EventIsInsideWindow(nsWindow* aWindow, nsPoint pos)
    1: {
    1: 	BRect r;
    1: 	BWindow *window = (BWindow *)aWindow->GetNativeData(NS_NATIVE_WINDOW);
    1: 	if (window)
    1: 	{
    1: 		r = window->Frame();
    1: 	}
    1: 	else
    1: 	{
    1: 		// Bummer!
    1: 		return PR_FALSE;
    1: 	}
    1: 
    1: 	if (pos.x < r.left || pos.x > r.right ||
    1: 	    pos.y < r.top || pos.y > r.bottom)
    1: 	{
    1: 		return PR_FALSE;
    1: 	}
    1: 
    1: 	return PR_TRUE;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: // DealWithPopups
    1: //
    1: // Handle events that may cause a popup (combobox, XPMenu, etc) to need to rollup.
    1: //-------------------------------------------------------------------------
    1: PRBool
    1: nsWindow::DealWithPopups(uint32 methodID, nsPoint pos)
    1: {
    1: 	if (gRollupListener && gRollupWidget) 
    1: 	{
    1: 		// Rollup if the event is outside the popup.
    1: 		PRBool rollup = !nsWindow::EventIsInsideWindow((nsWindow*)gRollupWidget, pos);
    1: 
    1: 		// If we're dealing with menus, we probably have submenus and we don't
    1: 		// want to rollup if the click is in a parent menu of the current submenu.
    1: 		if (rollup) 
    1: 		{
    1: 			nsCOMPtr<nsIMenuRollup> menuRollup ( do_QueryInterface(gRollupListener) );
    1: 			if ( menuRollup ) 
    1: 			{
10352: 				nsAutoTArray<nsIWidget*, 5> widgetChain;
10352: 				menuRollup->GetSubmenuWidgetChain(&widgetChain);
10352: 
10352: 				for ( PRUint32 i = 0; i < widgetChain.Length(); ++i ) 
    1: 				{
10352: 					nsIWidget* widget = widgetChain[i];
10352: 					if ( nsWindow::EventIsInsideWindow((nsWindow*)widget, pos) ) 
    1: 					{
    1: 						rollup = PR_FALSE;
    1: 						break;
    1: 					}
    1: 				} // foreach parent menu widget
    1: 			} // if rollup listener knows about menus
    1: 		} // if rollup
    1: 
    1: 		if (rollup) 
    1: 		{
    1: 			gRollupListener->Rollup();
    1: 
    1: 			if (gRollupConsumeRollupEvent) 
    1: 			{
    1: 				return PR_TRUE;
    1: 			}
    1: 		}
    1: 	} // if rollup listeners registered
    1: 
    1: 	return PR_FALSE;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // IsVisible
    1: //
    1: // Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::IsVisible(PRBool & bState)
    1: {
    1: 	bState = mIsVisible && mView && mView->Visible();
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Hide window borders/decorations for this widget
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::HideWindowChrome(PRBool aShouldHide)
    1: {
    1: 	if(mWindowType == eWindowType_child || mView == 0 || mView->Window() == 0)
    1: 		return NS_ERROR_FAILURE;
    1: 	// B_BORDERED 
    1: 	if (aShouldHide)
    1: 		mView->Window()->SetLook(B_NO_BORDER_WINDOW_LOOK);
    1: 	else
    1: 		mView->Window()->SetLook(mBWindowLook);
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Sanity check potential move coordinates
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY)
    1: {
    1: 	if (mIsTopWidgetWindow && mView->Window()) 
    1: 	{
    1: 		BScreen screen;
    1: 		// If no valid screen, just return
    1: 		if (! screen.IsValid()) return NS_OK;
    1: 		
    1: 		BRect screen_rect = screen.Frame();
    1: 		BRect win_bounds = mView->Window()->Frame();
    1: 
    1: #ifdef DEBUG_CONSTRAIN_POSITION
    1: 		printf("ConstrainPosition: allowSlop=%s, x=%d, y=%d\n\tScreen :", (aAllowSlop?"T":"F"),*aX,*aY);
    1: 		screen_rect.PrintToStream();
    1: 		printf("\tWindow: ");
    1: 		win_bounds.PrintToStream();
    1: #endif
    1: 		
    1: 		if (aAllowSlop) 
    1: 		{
    1: 			if (*aX < kWindowPositionSlop - win_bounds.IntegerWidth() + kWindowBorderWidth)
    1: 				*aX = kWindowPositionSlop - win_bounds.IntegerWidth() + kWindowBorderWidth;
    1: 			else if (*aX > screen_rect.IntegerWidth() - kWindowPositionSlop - kWindowBorderWidth)
    1: 				*aX = screen_rect.IntegerWidth() - kWindowPositionSlop - kWindowBorderWidth;
    1: 				
    1: 			if (*aY < kWindowPositionSlop - win_bounds.IntegerHeight() + kWindowTitleBarHeight)
    1: 				*aY = kWindowPositionSlop - win_bounds.IntegerHeight() + kWindowTitleBarHeight;
    1: 			else if (*aY > screen_rect.IntegerHeight() - kWindowPositionSlop - kWindowBorderWidth)
    1: 				*aY = screen_rect.IntegerHeight() - kWindowPositionSlop - kWindowBorderWidth;
    1: 				
    1: 		} 
    1: 		else 
    1: 		{
    1: 			
    1: 			if (*aX < kWindowBorderWidth)
    1: 				*aX = kWindowBorderWidth;
    1: 			else if (*aX > screen_rect.IntegerWidth() - win_bounds.IntegerWidth() - kWindowBorderWidth)
    1: 				*aX = screen_rect.IntegerWidth() - win_bounds.IntegerWidth() - kWindowBorderWidth;
    1: 				
    1: 			if (*aY < kWindowTitleBarHeight)
    1: 				*aY = kWindowTitleBarHeight;
    1: 			else if (*aY > screen_rect.IntegerHeight() - win_bounds.IntegerHeight() - kWindowBorderWidth)
    1: 				*aY = screen_rect.IntegerHeight() - win_bounds.IntegerHeight() - kWindowBorderWidth;
    1: 		}
    1: 	}
    1: 	return NS_OK;
    1: }
    1: 
    1: void nsWindow::HideKids(PRBool state)	
    1: {
    1: 	for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) 
    1: 	{
 3233: 		nsWindow *childWidget = static_cast<nsWindow*>(kid);
    1: 		nsRect kidrect = ((nsWindow *)kid)->mBounds;
    1: 		//Don't bother about invisible
    1: 		if (mBounds.Intersects(kidrect))
    1: 		{	
    1: 			childWidget->Show(!state);
    1: 		}
    1: 	}
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Move this component
    1: //
    1: //-------------------------------------------------------------------------
    1: nsresult nsWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
    1: 	// Only perform this check for non-popup windows, since the positioning can
    1: 	// in fact change even when the x/y do not.  We always need to perform the
    1: 	// check. See bug #97805 for details.
    1: 	if (mWindowType != eWindowType_popup && (mBounds.x == aX) && (mBounds.y == aY))
    1: 	{
    1: 		// Nothing to do, since it is already positioned correctly.
    1: 		return NS_OK;    
    1: 	}
    1: 
    1: 
    1: 	// Set cached value for lightweight and printing
    1: 	mBounds.x = aX;
    1: 	mBounds.y = aY;
    1: 
    1: 	// We may reset children visibility here, but it needs special care 
    1: 	// - see comment 18 in Bug 311651. More sofisticated code needed.
    1: 
    1: 	// until we lack separate window and widget, we "cannot" move BWindow without BView
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		if (mView->Parent() || !mView->Window())
    1: 			mView->MoveTo(aX, aY);
    1: 		else
    1: 			((nsWindowBeOS *)mView->Window())->MoveTo(aX, aY);
    1: 			
    1: 		mView->UnlockLooper();
    1: 	}
    1: 
    1: 	OnMove(aX,aY);
    1: 
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Resize this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
    1: 
    1: 	if (aWidth < 0 || aHeight < 0)
    1: 		return NS_OK;
    1: 
    1: 	mBounds.width  = aWidth;
    1: 	mBounds.height = aHeight;
    1: 	
    1: 	// until we lack separate window and widget, we "cannot" resize BWindow without BView
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		if (mView->Parent() || !mView->Window())
    1: 			mView->ResizeTo(aWidth - 1, aHeight - 1);
    1: 		else
    1: 			((nsWindowBeOS *)mView->Window())->ResizeTo(aWidth - 1, aHeight - 1);
    1: 
    1: 		mView->UnlockLooper();
    1: 	}
    1: 
    1: 
    1: 	OnResize(mBounds);
    1: 	if (aRepaint)
    1: 		Update();
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Resize this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Resize(PRInt32 aX,
    1:                            PRInt32 aY,
    1:                            PRInt32 aWidth,
    1:                            PRInt32 aHeight,
    1:                            PRBool   aRepaint)
    1: {
    1: 	Move(aX,aY);
    1: 	Resize(aWidth,aHeight,aRepaint);
    1: 	return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::SetModal(PRBool aModal)
    1: {
    1: 	if(!(mView && mView->Window()))
    1: 		return NS_ERROR_FAILURE;
    1: 	if(aModal)
    1: 	{
    1: 		window_feel newfeel;
    1: 		switch(mBWindowFeel)
    1: 		{
    1: 			case B_FLOATING_SUBSET_WINDOW_FEEL:
    1: 				newfeel = B_MODAL_SUBSET_WINDOW_FEEL;
    1: 				break;
    1:  			case B_FLOATING_APP_WINDOW_FEEL:
    1: 				newfeel = B_MODAL_APP_WINDOW_FEEL;
    1: 				break;
    1:  			case B_FLOATING_ALL_WINDOW_FEEL:
    1: 				newfeel = B_MODAL_ALL_WINDOW_FEEL;
    1: 				break;				
    1: 			default:
    1: 				return NS_OK;
    1: 		}
    1: 		mView->Window()->SetFeel(newfeel);
    1: 	}
    1: 	else
    1: 	{
    1: 		mView->Window()->SetFeel(mBWindowFeel);
    1: 	}
    1: 	return NS_OK;
    1: }
    1: //-------------------------------------------------------------------------
    1: //
    1: // Enable/disable this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Enable(PRBool aState)
    1: {
    1: 	//TODO: Needs real corect implementation in future
    1: 	mEnabled = aState;
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: NS_METHOD nsWindow::IsEnabled(PRBool *aState)
    1: {
    1: 	NS_ENSURE_ARG_POINTER(aState);
    1: 	// looks easy enough, but...
    1: 	*aState = mEnabled;
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Give the focus to this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::SetFocus(PRBool aRaise)
    1: {
    1: 	//
    1: 	// Switch to the "main gui thread" if necessary... This method must
    1: 	// be executed on the "gui thread"...
    1: 	//
    1: 	nsToolkit* toolkit = (nsToolkit *)mToolkit;
    1: 	if (toolkit && !toolkit->IsGuiThread()) 
    1: 	{
    1: 		nsCOMPtr<nsIWidget> widgetProxy;
    1: 		nsresult rv = NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1: 										NS_GET_IID(nsIWidget),
    1: 										this, 
    1: 										NS_PROXY_SYNC | NS_PROXY_ALWAYS, 
    1: 										getter_AddRefs(widgetProxy));
    1: 	
    1: 		if (NS_FAILED(rv))
    1: 			return rv;
    1: 		return widgetProxy->SetFocus(aRaise);
    1: 	}
    1: 	
    1: 	// Don't set focus on disabled widgets or popups
    1: 	if (!mEnabled || eWindowType_popup == mWindowType)
    1: 		return NS_OK;
    1: 		
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		if (mView->Window() && 
    1: 		    aRaise == PR_TRUE &&
    1: 		    eWindowType_popup != mWindowType && 
    1: 			  !mView->Window()->IsActive() && 
    1: 			  gLastActiveWindow != mView->Window())
    1: 			mView->Window()->Activate(true);
    1: 			
    1: 		mView->MakeFocus(true);
    1: 		mView->UnlockLooper();
    1: 		DispatchFocus(NS_GOTFOCUS);
    1: 	}
    1: 
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Get this component size and position in screen coordinates
    1: //
    1: //-------------------------------------------------------------------------    
    1: NS_IMETHODIMP nsWindow::GetScreenBounds(nsRect &aRect)
    1: {
    1: 	// A window's Frame() value is cached, so locking is not needed
    1: 	if (mView && mView->Window()) 
    1: 	{
    1: 		BRect r = mView->Window()->Frame();
    1: 		aRect.x = nscoord(r.left);
    1: 		aRect.y = nscoord(r.top);
    1: 		aRect.width  = r.IntegerWidth()+1;
    1: 		aRect.height = r.IntegerHeight()+1;
    1: 	} 
    1: 	else 
    1: 	{
    1: 		aRect = mBounds;
    1: 	}
    1: 	return NS_OK;
    1: }  
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set the background/foreground color
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::SetBackgroundColor(const nscolor &aColor)
    1: {
    1: 	nsBaseWidget::SetBackgroundColor(aColor);
    1: 
    1: 	// We set the background of toplevel windows so that resizing doesn't show thru
    1: 	// to Desktop and resizing artifacts. Child windows has transparent background.
    1: 	if (!mIsTopWidgetWindow)
    1: 		return NS_OK;
    1: 
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		mView->SetViewColor(NS_GET_R(aColor), NS_GET_G(aColor), NS_GET_B(aColor), NS_GET_A(aColor));
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set this component cursor
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
    1: {
    1: 	if (!mView)
    1: 		return NS_ERROR_FAILURE;
    1: 
    1: 	// Only change cursor if it's changing
    1: 	if (aCursor != mCursor) 
    1: 	{
    1: 		BCursor const *newCursor = B_CURSOR_SYSTEM_DEFAULT;
10445: 		if (be_app->IsCursorHidden())
10445: 			be_app->ShowCursor();
    1: 		
    1: 		// Check to see if the array has been loaded, if not, do it.
25381: 		if (gCursorArray.Length() == 0) 
    1: 		{
25381: 			gCursorArray.InsertElementAt(0 , new BCursor(cursorHyperlink));
25381: 			gCursorArray.InsertElementAt(1 , new BCursor(cursorHorizontalDrag));
25381: 			gCursorArray.InsertElementAt(2 , new BCursor(cursorVerticalDrag));
25381: 			gCursorArray.InsertElementAt(3 , new BCursor(cursorUpperLeft));
25381: 			gCursorArray.InsertElementAt(4 , new BCursor(cursorLowerRight));
25381: 			gCursorArray.InsertElementAt(5 , new BCursor(cursorUpperRight));
25381: 			gCursorArray.InsertElementAt(6 , new BCursor(cursorLowerLeft));
25381: 			gCursorArray.InsertElementAt(7 , new BCursor(cursorCrosshair));
25381: 			gCursorArray.InsertElementAt(8 , new BCursor(cursorHelp));
25381: 			gCursorArray.InsertElementAt(9 , new BCursor(cursorGrab));
25381: 			gCursorArray.InsertElementAt(10, new BCursor(cursorGrabbing));
25381: 			gCursorArray.InsertElementAt(11, new BCursor(cursorCopy));
25381: 			gCursorArray.InsertElementAt(12, new BCursor(cursorAlias));
25381: 			gCursorArray.InsertElementAt(13, new BCursor(cursorWatch2));
25381: 			gCursorArray.InsertElementAt(14, new BCursor(cursorCell));
25381: 			gCursorArray.InsertElementAt(15, new BCursor(cursorZoomIn));
25381: 			gCursorArray.InsertElementAt(16, new BCursor(cursorZoomOut));
25381: 			gCursorArray.InsertElementAt(17, new BCursor(cursorLeft));
25381: 			gCursorArray.InsertElementAt(18, new BCursor(cursorRight));
25381: 			gCursorArray.InsertElementAt(19, new BCursor(cursorTop));
25381: 			gCursorArray.InsertElementAt(20, new BCursor(cursorBottom));
    1: 		}
    1: 
    1: 		switch (aCursor) 
    1: 		{
    1: 			case eCursor_standard:
    1: 			case eCursor_move:
    1: 				newCursor = B_CURSOR_SYSTEM_DEFAULT;
    1: 				break;
    1: 	
    1: 			case eCursor_select:
    1: 				newCursor = B_CURSOR_I_BEAM;
    1: 				break;
    1: 	
    1: 			case eCursor_hyperlink:
25381: 				newCursor = gCursorArray.SafeElementAt(0);
    1: 				break;
    1: 	
    1: 			case eCursor_n_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(19);
    1: 				break;
    1: 
    1: 			case eCursor_s_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(20);
    1: 				break;
    1: 	
    1: 			case eCursor_w_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(17);
    1: 				break;
    1: 
    1: 			case eCursor_e_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(18);
    1: 				break;
    1: 	
    1: 			case eCursor_nw_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(3);
    1: 				break;
    1: 	
    1: 			case eCursor_se_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(4);
    1: 				break;
    1: 	
    1: 			case eCursor_ne_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(5);
    1: 				break;
    1: 	
    1: 			case eCursor_sw_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(6);
    1: 				break;
    1: 	
    1: 			case eCursor_crosshair:
25381: 				newCursor = gCursorArray.SafeElementAt(7);
    1: 				break;
    1: 	
    1: 			case eCursor_help:
25381: 				newCursor = gCursorArray.SafeElementAt(8);
    1: 				break;
    1: 	
    1: 			case eCursor_copy:
25381: 				newCursor = gCursorArray.SafeElementAt(11);
    1: 				break;
    1: 	
    1: 			case eCursor_alias:
25381: 				newCursor = gCursorArray.SafeElementAt(12);
    1: 				break;
    1: 
    1: 			case eCursor_context_menu:
    1: 				// XXX: No suitable cursor, needs implementing
    1: 				break;
    1: 				
    1: 			case eCursor_cell:
25381: 				newCursor = gCursorArray.SafeElementAt(14);
    1: 				break;
    1: 
    1: 			case eCursor_grab:
25381: 				newCursor = gCursorArray.SafeElementAt(9);
    1: 				break;
    1: 	
    1: 			case eCursor_grabbing:
25381: 				newCursor = gCursorArray.SafeElementAt(10);
    1: 				break;
    1: 	
    1: 			case eCursor_wait:
    1: 			case eCursor_spinning:
25381: 				newCursor = gCursorArray.SafeElementAt(13);
    1: 				break;
    1: 	
    1: 			case eCursor_zoom_in:
25381: 				newCursor = gCursorArray.SafeElementAt(15);
    1: 				break;
    1: 
    1: 			case eCursor_zoom_out:
25381: 				newCursor = gCursorArray.SafeElementAt(16);
    1: 				break;
    1: 
    1: 			case eCursor_not_allowed:
    1: 			case eCursor_no_drop:
    1: 				// XXX: No suitable cursor, needs implementing
    1: 				break;
    1: 
    1: 			case eCursor_col_resize:
    1: 				// XXX not 100% appropriate perhaps
25381: 				newCursor = gCursorArray.SafeElementAt(1);
    1: 				break;
    1: 
    1: 			case eCursor_row_resize:
    1: 				// XXX not 100% appropriate perhaps
25381: 				newCursor = gCursorArray.SafeElementAt(2);
    1: 				break;
    1: 
    1: 			case eCursor_vertical_text:
    1: 				// XXX not 100% appropriate perhaps
    1: 				newCursor = B_CURSOR_I_BEAM;
    1: 				break;
    1: 
    1: 			case eCursor_all_scroll:
    1: 				// XXX: No suitable cursor, needs implementing
    1: 				break;
    1: 
    1: 			case eCursor_nesw_resize:
    1: 				// XXX not 100% appropriate perhaps
25381: 				newCursor = gCursorArray.SafeElementAt(1);
    1: 				break;
    1: 
    1: 			case eCursor_nwse_resize:
    1: 				// XXX not 100% appropriate perhaps
25381: 				newCursor = gCursorArray.SafeElementAt(1);
    1: 				break;
    1: 
    1: 			case eCursor_ns_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(2);
    1: 				break;
    1: 
    1: 			case eCursor_ew_resize:
25381: 				newCursor = gCursorArray.SafeElementAt(1);
    1: 				break;
    1: 
10405: 			case eCursor_none:
10445: 				be_app->HideCursor();
10405: 				break;
10405: 
    1: 			default:
    1: 				NS_ASSERTION(0, "Invalid cursor type");
    1: 				break;
    1: 		}
    1: 		NS_ASSERTION(newCursor != nsnull, "Cursor not stored in array properly!");
    1: 		mCursor = aCursor;
    1: 		be_app->SetCursor(newCursor, true);
    1: 	}
    1: 	return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invalidate this component visible area
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Invalidate(PRBool aIsSynchronous)
    1: {
    1: 	nsresult rv = NS_ERROR_FAILURE;
    1: 	// Asynchronous painting is performed with via nsViewBeOS::Draw() call and its message queue. 
    1: 	// All update rects are collected in nsViewBeOS member  "paintregion".
    1: 	// Flushing of paintregion happens in nsViewBeOS::GetPaintRegion(),
    1: 	// cleanup  - in nsViewBeOS::Validate(), called in OnPaint().
    1: 	BRegion reg;
    1: 	reg.MakeEmpty();
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		if (PR_TRUE == aIsSynchronous)
    1: 		{
    1: 			mView->paintregion.Include(mView->Bounds());
    1: 			reg.Include(mView->Bounds());
    1: 		}
    1: 		else
    1: 		{
    1: 			mView->Draw(mView->Bounds());
    1: 			rv = NS_OK;
    1: 		}
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	// Instant repaint.
    1: 	if (PR_TRUE == aIsSynchronous)
    1: 		rv = OnPaint(&reg);
    1: 	return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invalidate this component visible area
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Invalidate(const nsRect & aRect, PRBool aIsSynchronous)
    1: {
    1: 	nsresult rv = NS_ERROR_FAILURE;
    1: 	// Very temporary region for double accounting.
    1: 	BRegion reg;
    1: 	reg.MakeEmpty();
    1: 	if (mView && mView->LockLooper()) 
    1: 	{
    1: 		BRect	r(aRect.x, 
    1: 				aRect.y, 
    1: 				aRect.x + aRect.width - 1, 
    1: 				aRect.y + aRect.height - 1);
    1: 		if (PR_TRUE == aIsSynchronous)
    1: 		{
    1: 			mView->paintregion.Include(r);
    1: 			reg.Include(r);
    1: 		}
    1: 		else
    1: 		{
    1: 			// we use Draw() instead direct addition to paintregion,
    1: 			// as it sets queue of notification messages for painting.
    1: 			mView->Draw(r);
    1: 			rv = NS_OK;
    1: 		}
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	// Instant repaint - for given rect only. 
    1: 	// Don't repaint area which isn't marked here for synchronous repaint explicitly.
    1: 	// BRegion "reg" (equal to aRect) will be substracted from paintregion in OnPaint().
    1: 	if (PR_TRUE == aIsSynchronous)
    1: 		rv = OnPaint(&reg);
    1: 	return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Invalidate this component visible area
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsWindow::InvalidateRegion(const nsIRegion *aRegion, PRBool aIsSynchronous)
    1: {
    1: 	
    1: 	nsRegionRectSet *rectSet = nsnull;
    1: 	if (!aRegion)
    1: 		return NS_ERROR_FAILURE;
    1: 	nsresult rv = ((nsIRegion *)aRegion)->GetRects(&rectSet);
    1: 	if (NS_FAILED(rv))
    1: 		return rv;
    1: 	BRegion reg;
    1: 	reg.MakeEmpty();
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		for (PRUint32 i=0; i< rectSet->mRectsLen; ++i)
    1: 		{
    1: 			BRect br(rectSet->mRects[i].x, rectSet->mRects[i].y,
    1: 					rectSet->mRects[i].x + rectSet->mRects[i].width-1,
    1: 					rectSet->mRects[i].y + rectSet->mRects[i].height -1);
    1: 			if (PR_TRUE == aIsSynchronous)
    1: 			{
    1: 				mView->paintregion.Include(br);
    1: 				reg.Include(br);
    1: 			}
    1: 			else
    1: 			{
    1: 				mView->Draw(br);
    1: 				rv = NS_OK;
    1: 			}
    1: 		}
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	// Instant repaint - for given region only. 
    1: 	// BRegion "reg"(equal to aRegion) will be substracted from paintregion in OnPaint().
    1: 	if (PR_TRUE == aIsSynchronous)
    1: 		rv = OnPaint(&reg);
    1: 
    1: 	return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Force a synchronous repaint of the window
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP nsWindow::Update()
    1: {
    1: 	nsresult rv = NS_ERROR_FAILURE;
    1: 	//Switching scrolling trigger off
    1: 	mIsScrolling = PR_FALSE;
    1: 	if (mWindowType == eWindowType_child)
    1: 		return NS_OK;
    1: 	BRegion reg;
    1: 	reg.MakeEmpty();
    1: 	if(mView && mView->LockLooper())
    1: 	{
    1: 		//Flushing native pending updates if any
    1: 		if (mView->Window())
    1: 			mView->Window()->UpdateIfNeeded();
    1: 		// Let app_server to invalidate
    1: 		mView->Invalidate();
    1: 		bool nonempty = mView->GetPaintRegion(&reg);
    1: 		mView->UnlockLooper();
    1: 		// Look if native update calls above filled update region and paint it
    1: 		if (nonempty)
    1: 			rv = OnPaint(&reg);
    1: 	}
    1: 	return rv;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Return some native data according to aDataType
    1: //
    1: //-------------------------------------------------------------------------
    1: void* nsWindow::GetNativeData(PRUint32 aDataType)
    1: {
    1: 	if (!mView)
    1: 		return NULL;	
    1: 	switch(aDataType) 
    1: 	{
    1: 		case NS_NATIVE_WINDOW:
    1: 			return (void *)(mView->Window());
    1: 		case NS_NATIVE_WIDGET:
    1: 		case NS_NATIVE_PLUGIN_PORT:
    1: 			return (void *)((nsViewBeOS *)mView);
    1: 		case NS_NATIVE_GRAPHIC:
    1: 			return (void *)((BView *)mView);
    1: 		case NS_NATIVE_COLORMAP:
    1: 		default:
    1: 			break;
    1: 	}
    1: 	return NULL;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Set the colormap of the window
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::SetColorMap(nsColorMap *aColorMap)
    1: {
    1: 	NS_WARNING("nsWindow::SetColorMap - not implemented");
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Scroll the bits of a window
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Scroll(PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect)
    1: {
    1: 	// Switching trigger on
    1: 	mIsScrolling = PR_TRUE;
    1: 	//Preventing main view invalidation loop-chain  when children are moving
    1: 	//by by hiding children nsWidgets.
    1: 	//Maybe this method must be used wider, in move and resize chains
    1: 	// and implemented in BeginResizingChildren or in Reset*Visibility() methods
    1: 	//Children will be unhidden in ::Update() when called by other than gkview::Scroll() method.
    1: 	HideKids(PR_TRUE);
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		// Kill any attempt to invalidate until scroll is finished
    1: 		mView->SetVisible(false);
    1: 		
    1: 		BRect src;
    1: 		BRect b = mView->Bounds();
    1: 
    1: 		if (aClipRect)
    1: 		{
    1: 			src.left = aClipRect->x;
    1: 			src.top = aClipRect->y;
    1: 			src.right = aClipRect->XMost() - 1;
    1: 			src.bottom = aClipRect->YMost() - 1;
    1: 		}
    1: 		else
    1: 		{
    1: 			src = b;
    1: 		}
    1: 		// Restricting source by on-screen part of BView
    1: 		if (mView->Window())
    1: 		{
    1: 			BRect screenframe = mView->ConvertFromScreen(BScreen(mView->Window()).Frame());
    1: 			src = src & screenframe;
    1: 			if (mView->Parent())
    1: 			{
    1: 				BRect parentframe = mView->ConvertFromParent(mView->Parent()->Frame());
    1: 				src = src & parentframe;
    1: 			}
    1: 		}
    1: 
    1: 		BRegion	invalid;
    1: 		invalid.Include(src);
    1: 		// Next source clipping check, for same level siblings
    1: 		if ( BView *v = mView->Parent() )
    1: 		{
    1: 			for (BView *child = v->ChildAt(0); child; child = child->NextSibling() )
    1: 			{
    1: 				BRect siblingframe = mView->ConvertFromParent(child->Frame());
    1: 				if (child != mView && child->Parent() != mView)
    1: 				{
    1: 					invalid.Exclude(siblingframe);
    1: 					mView->paintregion.Exclude(siblingframe);
    1: 				}
    1: 			}
    1: 			src = invalid.Frame();
    1: 		}
    1: 
    1: 		// make sure we only reference visible bits
    1: 		// so we don't trigger a BView invalidate
    1: 
    1: 		if (src.left + aDx < 0)
    1: 			src.left = -aDx;
    1: 		if (src.right + aDx > b.right)
    1: 			src.right = b.right - aDx;
    1: 		if (src.top + aDy < 0)
    1: 			src.top = -aDy;
    1: 		if (src.bottom + aDy > b.bottom)
    1: 			src.bottom = b.bottom - aDy;
    1: 		
    1: 		BRect dest = src.OffsetByCopy(aDx, aDy);
    1: 		mView->ConstrainClippingRegion(&invalid);
    1: 		// Moving visible content 
    1: 		if (src.IsValid() && dest.IsValid())
    1: 			mView->CopyBits(src, dest);
    1: 
    1: 		invalid.Exclude(dest);	
    1: 		// Native paintregion needs shifting too, it is very important action
    1: 		// (as app_server doesn't know about Mozilla viewmanager tricks) -
    1: 		// it allows proper update after scroll for areas covered by other windows.
    1: 		mView->paintregion.OffsetBy(aDx, aDy);
    1: 		mView->ConstrainClippingRegion(&invalid);
    1: 		// Time to silently move now invisible children
    1: 		for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) 
    1: 		{
 3233: 			nsWindow *childWidget = static_cast<nsWindow*>(kid);
    1: 			// No need to Lock/UnlockLooper with GetBounds() and Move() methods
    1: 			// using cached values and native MoveBy() instead
    1: 			nsRect bounds = childWidget->mBounds;
    1: 			bounds.x += aDx;
    1: 			bounds.y += aDy; 
    1: 			childWidget->Move(bounds.x, bounds.y);
    1: 			BView *child = ((BView *)kid->GetNativeData(NS_NATIVE_WIDGET));
    1: 			if (child)
    1: 				mView->paintregion.Exclude(child->Frame());
    1: 		}
    1: 		
    1: 		// Painting calculated region now,
    1: 		// letting Update() to paint remaining content of paintregion
    1: 		OnPaint(&invalid);
    1: 		HideKids(PR_FALSE);
    1: 		// re-allow updates
    1: 		mView->SetVisible(true);
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Every function that needs a thread switch goes through this function
    1: // by calling SendMessage (..WM_CALLMETHOD..) in nsToolkit::CallMethod.
    1: //
    1: //-------------------------------------------------------------------------
    1: bool nsWindow::CallMethod(MethodInfo *info)
    1: {
    1: 	bool bRet = TRUE;
    1: 
    1: 	switch (info->methodId)
    1: 	{
    1: 	case nsSwitchToUIThread::CLOSEWINDOW :
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1: 			if (eWindowType_popup != mWindowType && eWindowType_child != mWindowType)
    1: 				DealWithPopups(nsSwitchToUIThread::CLOSEWINDOW,nsPoint(0,0));
    1: 
    1: 			// Bit more Kung-fu. We do care ourselves about children destroy notofication.
    1: 			// Including those floating dialogs we added to Gecko hierarchy in StandardWindowCreate()
    1: 
    1: 			for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) 
    1: 			{
 3233: 				nsWindow *childWidget = static_cast<nsWindow*>(kid);
    1: 				BWindow* kidwindow = (BWindow *)kid->GetNativeData(NS_NATIVE_WINDOW);
    1: 				if (kidwindow)
    1: 				{
    1: 					// PostMessage() is unsafe, so using BMessenger
    1: 					BMessenger bm(kidwindow);
    1: 					bm.SendMessage(B_QUIT_REQUESTED);
    1: 				}
    1: 			}
    1: 			DispatchStandardEvent(NS_DESTROY);
    1: 		}
    1: 		break;
    1: 
    1: #ifdef DEBUG_FOCUS
    1: 	case nsSwitchToUIThread::GOT_FOCUS:
    1: 		NS_ASSERTION(info->nArgs == 1, "Wrong number of arguments to CallMethod");
    1: 		if (!mEnabled)
    1: 			return false;
    1: 		if ((uint32)info->args[0] != (uint32)mView)
    1: 			printf("Wrong view to get focus\n");*/
    1: 		break;
    1: #endif
    1: 	case nsSwitchToUIThread::KILL_FOCUS:
    1: 		NS_ASSERTION(info->nArgs == 1, "Wrong number of arguments to CallMethod");
    1: 		if ((uint32)info->args[0] == (uint32)mView)
    1: 			DispatchFocus(NS_LOSTFOCUS);
    1: #ifdef DEBUG_FOCUS
    1: 		else
    1: 			printf("Wrong view to de-focus\n");
    1: #endif
    1: #if defined BeIME
    1: 		nsIMEBeOS::GetIME()->DispatchCancelIME();
    1: 		if (mView && mView->LockLooper())
    1:  		{
    1:  			mView->SetFlags(mView->Flags() & ~B_NAVIGABLE);
    1:  			mView->UnlockLooper();
    1:  		}
    1: #endif
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::BTNCLICK :
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 6, "Wrong number of arguments to CallMethod");
    1: 			if (!mEnabled)
    1: 				return false;
    1: 			// close popup when clicked outside of the popup window
    1: 			uint32 eventID = ((int32 *)info->args)[0];
    1: 			PRBool rollup = PR_FALSE;
    1: 
    1: 			if (eventID == NS_MOUSE_BUTTON_DOWN &&
    1: 			        mView && mView->LockLooper())
    1: 			{
    1: 				BPoint p(((int32 *)info->args)[1], ((int32 *)info->args)[2]);
    1: 				mView->ConvertToScreen(&p);
    1: 				rollup = DealWithPopups(nsSwitchToUIThread::ONMOUSE, nsPoint(p.x, p.y));
    1: 				mView->UnlockLooper();
    1: 			}
    1: 			// Drop click event - bug 314330
    1: 			if (rollup)
    1: 				return false;
    1: 			DispatchMouseEvent(((int32 *)info->args)[0],
    1: 			                   nsPoint(((int32 *)info->args)[1], ((int32 *)info->args)[2]),
    1: 			                   ((int32 *)info->args)[3],
    1: 			                   ((int32 *)info->args)[4],
    1: 			                   ((int32 *)info->args)[5]);
    1: 
    1: 			if (((int32 *)info->args)[0] == NS_MOUSE_BUTTON_DOWN &&
    1: 			    ((int32 *)info->args)[5] == nsMouseEvent::eRightButton)
    1: 			{
    1: 				DispatchMouseEvent (NS_CONTEXTMENU,
    1: 				                    nsPoint(((int32 *)info->args)[1], ((int32 *)info->args)[2]),
    1: 				                    ((int32 *)info->args)[3],
    1: 				                    ((int32 *)info->args)[4],
    1: 				                    ((int32 *)info->args)[5]);
    1: 			}
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONWHEEL :
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 1, "Wrong number of arguments to CallMethod");
    1: 			// avoid mistargeting
    1: 			if ((uint32)info->args[0] != (uint32)mView)
    1: 				return false;
    1: 			BPoint cursor(0,0);
    1: 			uint32 buttons;
    1: 			BPoint delta;
    1: 			if (mView && mView->LockLooper())
    1: 			{
    1: 				mView->GetMouse(&cursor, &buttons, false);
    1: 				delta = mView->GetWheel();
    1: 				mView->UnlockLooper();
    1: 			}
    1: 			else
    1: 				return false;
    1: 			// BeOS TwoWheel input-filter is bit buggy atm, generating sometimes X-wheel with no reason,
    1: 			// so we're setting priority for Y-wheel.
    1: 			// Also hardcoding here _system_ scroll-step value to 3 lines.
    1: 			if (nscoord(delta.y) != 0)
    1: 			{
    1: 				OnWheel(nsMouseScrollEvent::kIsVertical, buttons, cursor, nscoord(delta.y)*3);
    1: 			}
    1: 			else if(nscoord(delta.x) != 0)
    1: 				OnWheel(nsMouseScrollEvent::kIsHorizontal, buttons, cursor, nscoord(delta.x)*3);
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONKEY :
    1: 		NS_ASSERTION(info->nArgs == 6, "Wrong number of arguments to CallMethod");
    1: 		if (((int32 *)info->args)[0] == NS_KEY_DOWN)
    1: 		{
    1: 			OnKeyDown(((int32 *)info->args)[0],
    1: 			          (const char *)(&((uint32 *)info->args)[1]), ((int32 *)info->args)[2],
    1: 			          ((uint32 *)info->args)[3], ((uint32 *)info->args)[4], ((int32 *)info->args)[5]);
    1: 		}
    1: 		else
    1: 		{
    1: 			if (((int32 *)info->args)[0] == NS_KEY_UP)
    1: 			{
    1: 				OnKeyUp(((int32 *)info->args)[0],
    1: 				        (const char *)(&((uint32 *)info->args)[1]), ((int32 *)info->args)[2],
    1: 				        ((uint32 *)info->args)[3], ((uint32 *)info->args)[4], ((int32 *)info->args)[5]);
    1: 			}
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONPAINT :
    1: 		NS_ASSERTION(info->nArgs == 1, "Wrong number of arguments to CallMethod");
    1: 		{
    1: 			if ((uint32)mView != ((uint32 *)info->args)[0])
    1: 				return false;
    1: 			BRegion reg;
    1: 			reg.MakeEmpty();
    1: 			if(mView && mView->LockLooper())
    1: 			{
    1: 				bool nonempty = mView->GetPaintRegion(&reg);
    1: 				mView->UnlockLooper();
    1: 				if (nonempty)
    1: 					OnPaint(&reg);
    1: 			}
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONRESIZE :
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1: 			if (eWindowType_popup != mWindowType && eWindowType_child != mWindowType)
    1: 				DealWithPopups(nsSwitchToUIThread::ONRESIZE,nsPoint(0,0));
    1: 			// This should be called only from BWindow::FrameResized()
    1: 			if (!mIsTopWidgetWindow  || !mView  || !mView->Window())
    1: 				return false;
    1: 			
    1: 			nsRect r(mBounds);
    1: 			if (mView->LockLooper())
    1: 			{
    1: 				BRect br = mView->Frame();
    1: 				r.x = nscoord(br.left);
    1: 				r.y = nscoord(br.top);
    1: 				r.width  = br.IntegerWidth() + 1;
    1: 				r.height = br.IntegerHeight() + 1;
    1: 				((nsWindowBeOS *)mView->Window())->fJustGotBounds = true;
    1: 				mView->UnlockLooper();
    1: 			}
    1: 			OnResize(r);
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONMOUSE :
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 4, "Wrong number of arguments to CallMethod");
    1: 			if (!mEnabled)
    1: 				return false;
    1: 			DispatchMouseEvent(((int32 *)info->args)[0],
    1: 			                   nsPoint(((int32 *)info->args)[1], ((int32 *)info->args)[2]),
    1: 			                   0,
    1: 		    	               ((int32 *)info->args)[3]);
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONDROP :
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 4, "Wrong number of arguments to CallMethod");
    1: 
18445: 			nsDragEvent event(PR_TRUE, (int32)  info->args[0], this);
    1: 			nsPoint point(((int32 *)info->args)[1], ((int32 *)info->args)[2]);
    1: 			InitEvent (event, &point);
    1: 			uint32 mod = (uint32) info->args[3];
    1: 			event.isShift   = mod & B_SHIFT_KEY;
    1: 			event.isControl = mod & B_CONTROL_KEY;
    1: 			event.isAlt     = mod & B_COMMAND_KEY;
    1: 			event.isMeta     = mod & B_OPTION_KEY;
    1: 
    1: 			// Setting drag action, must be done before event dispatch
    1: 			nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1: 			if (dragService)
    1: 			{
    1: 				nsCOMPtr<nsIDragSession> dragSession;
    1: 				dragService->GetCurrentSession(getter_AddRefs(dragSession));
    1: 				if (dragSession)
    1: 				{
    1: 					// Original action mask stored in dragsession.
    1: 					// For native events such mask must be set in nsDragServiceBeOS::UpdateDragMessageIfNeeded()
    1: 	
    1: 					PRUint32 action_mask = 0;
    1: 					dragSession->GetDragAction(&action_mask);
    1: 					PRUint32 action = nsIDragService::DRAGDROP_ACTION_MOVE;
    1: 					if (mod & B_OPTION_KEY)
    1: 					{
    1: 						if (mod & B_COMMAND_KEY)
    1: 							action = nsIDragService::DRAGDROP_ACTION_LINK & action_mask;
    1: 						else
    1: 							action = nsIDragService::DRAGDROP_ACTION_COPY & action_mask;
    1: 					}
    1: 					dragSession->SetDragAction(action);
    1: 				}
    1: 			}
    1: 			DispatchWindowEvent(&event);
    1: 			NS_RELEASE(event.widget);
    1: 
    1: 			if (dragService)
  482: 				dragService->EndDragSession(PR_TRUE);
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONACTIVATE:
    1: 		NS_ASSERTION(info->nArgs == 2, "Wrong number of arguments to CallMethod");
    1: 		if (!mEnabled || eWindowType_popup == mWindowType || 0 == mView->Window())
    1: 			return false;
    1: 		if ((BWindow *)info->args[1] != mView->Window())
    1: 			return false;
    1: 		if (mEventCallback || eWindowType_child == mWindowType )
    1: 		{
    1: 			bool active = (bool)info->args[0];
    1: 			if (!active) 
    1: 			{
    1: 				if (eWindowType_dialog == mWindowType || 
    1: 				    eWindowType_toplevel == mWindowType)
    1: 					DealWithPopups(nsSwitchToUIThread::ONACTIVATE,nsPoint(0,0));
    1: 				//Testing if BWindow is really deactivated.
    1: 				if (!mView->Window()->IsActive())
    1: 				{
    1: 					// BeOS is poor in windows hierarchy and variations support. In lot of aspects.
    1: 					// Here is workaround for flacky Activate() handling for B_FLOATING windows.
    1: 					// We should force parent (de)activation to allow main window to regain control after closing floating dialog.
    1: 					if (mWindowParent &&  mView->Window()->IsFloating())
    1: 						mWindowParent->DispatchFocus(NS_ACTIVATE);
    1: 
    1: 					DispatchFocus(NS_DEACTIVATE);
    1: #if defined(BeIME)
    1: 					nsIMEBeOS::GetIME()->DispatchCancelIME();
    1: #endif
    1: 				}
    1: 			} 
    1: 			else 
    1: 			{
    1: 
    1: 				if (mView->Window()->IsActive())
    1: 				{
    1: 					// See comment above.
    1: 					if (mWindowParent &&  mView->Window()->IsFloating())
    1: 						mWindowParent->DispatchFocus(NS_DEACTIVATE);
    1: 					
    1: 					DispatchFocus(NS_ACTIVATE);
    1: 					if (mView && mView->Window())
    1: 						gLastActiveWindow = mView->Window();
    1: 				}
    1: 			}
    1: 		}
    1: 		break;
    1: 
    1: 	case nsSwitchToUIThread::ONMOVE:
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 0, "Wrong number of arguments to CallMethod");
    1: 			nsRect r;
    1: 			// We use this only for tracking whole window moves
    1: 			GetScreenBounds(r);		
    1: 			if (eWindowType_popup != mWindowType && eWindowType_child != mWindowType)
    1: 				DealWithPopups(nsSwitchToUIThread::ONMOVE,nsPoint(0,0));
    1: 			OnMove(r.x, r.y);
    1: 		}
    1: 		break;
    1: 		
    1: 	case nsSwitchToUIThread::ONWORKSPACE:
    1: 		{
    1: 			NS_ASSERTION(info->nArgs == 2, "Wrong number of arguments to CallMethod");
    1: 			if (eWindowType_popup != mWindowType && eWindowType_child != mWindowType)
    1: 				DealWithPopups(nsSwitchToUIThread::ONWORKSPACE,nsPoint(0,0));
    1: 		}
    1: 		break;
    1: 
    1: #if defined(BeIME)
    1:  	case nsSwitchToUIThread::ONIME:
    1:  		//No assertion used, as number of arguments varies here
    1:  		if (mView && mView->LockLooper())
    1:  		{
    1:  			mView->SetFlags(mView->Flags() | B_NAVIGABLE);
    1:  			mView->UnlockLooper();
    1:  		}
    1:  		nsIMEBeOS::GetIME()->RunIME(info->args, this, mView);
    1:  		break;
    1: #endif
    1: 		default:
    1: 			bRet = FALSE;
    1: 			break;
    1: 		
    1: 	}
    1: 
    1: 	return bRet;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Key code translation related data
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: struct nsKeyConverter {
    1: 	int vkCode; // Platform independent key code
    1: 	char bekeycode; // BeOS key code
    1: };
    1: 
    1: //
    1: // Netscape keycodes are defined in widget/public/nsGUIEvent.h
    1: // BeOS keycodes can be viewd at
    1: // http://www.be.com/documentation/be_book/Keyboard/KeyboardKeyCodes.html
    1: //
    1: 
    1: struct nsKeyConverter nsKeycodesBeOS[] = {
    1: 	        //  { NS_VK_CANCEL,     GDK_Cancel },
    1: 	        { NS_VK_BACK,       0x1e },
    1: 	        { NS_VK_TAB,        0x26 },
    1: 	        //  { NS_VK_TAB,        GDK_ISO_Left_Tab },
    1: 	        //  { NS_VK_CLEAR,      GDK_Clear },
    1: 	        { NS_VK_RETURN,     0x47 },
    1: 	        { NS_VK_SHIFT,      0x4b },
    1: 	        { NS_VK_SHIFT,      0x56 },
    1: 	        { NS_VK_CONTROL,    0x5c },
    1: 	        { NS_VK_CONTROL,    0x60 },
    1: 	        { NS_VK_ALT,        0x5d },
    1: 	        { NS_VK_ALT,        0x5f },
    1: 	        { NS_VK_PAUSE,      0x22 },
    1: 	        { NS_VK_CAPS_LOCK,  0x3b },
    1: 	        { NS_VK_ESCAPE,     0x1 },
    1: 	        { NS_VK_SPACE,      0x5e },
    1: 	        { NS_VK_PAGE_UP,    0x21 },
    1: 	        { NS_VK_PAGE_DOWN,  0x36 },
    1: 	        { NS_VK_END,        0x35 },
    1: 	        { NS_VK_HOME,       0x20 },
    1: 	        { NS_VK_LEFT,       0x61 },
    1: 	        { NS_VK_UP,         0x57 },
    1: 	        { NS_VK_RIGHT,      0x63 },
    1: 	        { NS_VK_DOWN,       0x62 },
    1: 	        { NS_VK_PRINTSCREEN, 0xe },
    1: 	        { NS_VK_INSERT,     0x1f },
    1: 	        { NS_VK_DELETE,     0x34 },
    1: 
    1: 	        // The "Windows Key"
    1: 	        { NS_VK_META,       0x66 },
    1: 	        { NS_VK_META,       0x67 },
    1: 
    1: 	        // keypad keys (constant keys)
    1: 	        { NS_VK_MULTIPLY,   0x24 },
    1: 	        { NS_VK_ADD,        0x3a },
    1: 	        //  { NS_VK_SEPARATOR,   }, ???
    1: 	        { NS_VK_SUBTRACT,   0x25 },
    1: 	        { NS_VK_DIVIDE,     0x23 },
    1: 	        { NS_VK_RETURN,     0x5b },
    1: 
    1: 	        { NS_VK_COMMA,      0x53 },
    1: 	        { NS_VK_PERIOD,     0x54 },
    1: 	        { NS_VK_SLASH,      0x55 },
    1: 	        { NS_VK_BACK_SLASH, 0x33 },
    1: 	        { NS_VK_BACK_SLASH, 0x6a }, // got this code on japanese keyboard
    1: 	        { NS_VK_BACK_SLASH, 0x6b }, // got this code on japanese keyboard
    1: 	        { NS_VK_BACK_QUOTE, 0x11 },
    1: 	        { NS_VK_OPEN_BRACKET, 0x31 },
    1: 	        { NS_VK_CLOSE_BRACKET, 0x32 },
    1: 	        { NS_VK_SEMICOLON, 0x45 },
    1: 	        { NS_VK_QUOTE, 0x46 },
    1: 
    1: 	        // NS doesn't have dash or equals distinct from the numeric keypad ones,
    1: 	        // so we'll use those for now.  See bug 17008:
    1: 	        { NS_VK_SUBTRACT, 0x1c },
    1: 	        { NS_VK_EQUALS, 0x1d },
    1: 
    1: 	        { NS_VK_F1, B_F1_KEY },
    1: 	        { NS_VK_F2, B_F2_KEY },
    1: 	        { NS_VK_F3, B_F3_KEY },
    1: 	        { NS_VK_F4, B_F4_KEY },
    1: 	        { NS_VK_F5, B_F5_KEY },
    1: 	        { NS_VK_F6, B_F6_KEY },
    1: 	        { NS_VK_F7, B_F7_KEY },
    1: 	        { NS_VK_F8, B_F8_KEY },
    1: 	        { NS_VK_F9, B_F9_KEY },
    1: 	        { NS_VK_F10, B_F10_KEY },
    1: 	        { NS_VK_F11, B_F11_KEY },
    1: 	        { NS_VK_F12, B_F12_KEY },
    1: 
    1: 	        { NS_VK_1, 0x12 },
    1: 	        { NS_VK_2, 0x13 },
    1: 	        { NS_VK_3, 0x14 },
    1: 	        { NS_VK_4, 0x15 },
    1: 	        { NS_VK_5, 0x16 },
    1: 	        { NS_VK_6, 0x17 },
    1: 	        { NS_VK_7, 0x18 },
    1: 	        { NS_VK_8, 0x19 },
    1: 	        { NS_VK_9, 0x1a },
    1: 	        { NS_VK_0, 0x1b },
    1: 
    1: 	        { NS_VK_A, 0x3c },
    1: 	        { NS_VK_B, 0x50 },
    1: 	        { NS_VK_C, 0x4e },
    1: 	        { NS_VK_D, 0x3e },
    1: 	        { NS_VK_E, 0x29 },
    1: 	        { NS_VK_F, 0x3f },
    1: 	        { NS_VK_G, 0x40 },
    1: 	        { NS_VK_H, 0x41 },
    1: 	        { NS_VK_I, 0x2e },
    1: 	        { NS_VK_J, 0x42 },
    1: 	        { NS_VK_K, 0x43 },
    1: 	        { NS_VK_L, 0x44 },
    1: 	        { NS_VK_M, 0x52 },
    1: 	        { NS_VK_N, 0x51 },
    1: 	        { NS_VK_O, 0x2f },
    1: 	        { NS_VK_P, 0x30 },
    1: 	        { NS_VK_Q, 0x27 },
    1: 	        { NS_VK_R, 0x2a },
    1: 	        { NS_VK_S, 0x3d },
    1: 	        { NS_VK_T, 0x2b },
    1: 	        { NS_VK_U, 0x2d },
    1: 	        { NS_VK_V, 0x4f },
    1: 	        { NS_VK_W, 0x28 },
    1: 	        { NS_VK_X, 0x4d },
    1: 	        { NS_VK_Y, 0x2c },
    1: 	        { NS_VK_Z, 0x4c }
    1:         };
    1: 
    1: // keycode of keypad when num-locked
    1: struct nsKeyConverter nsKeycodesBeOSNumLock[] = {
    1: 	        { NS_VK_NUMPAD0, 0x64 },
    1: 	        { NS_VK_NUMPAD1, 0x58 },
    1: 	        { NS_VK_NUMPAD2, 0x59 },
    1: 	        { NS_VK_NUMPAD3, 0x5a },
    1: 	        { NS_VK_NUMPAD4, 0x48 },
    1: 	        { NS_VK_NUMPAD5, 0x49 },
    1: 	        { NS_VK_NUMPAD6, 0x4a },
    1: 	        { NS_VK_NUMPAD7, 0x37 },
    1: 	        { NS_VK_NUMPAD8, 0x38 },
    1: 	        { NS_VK_NUMPAD9, 0x39 },
    1: 	        { NS_VK_DECIMAL, 0x65 }
    1:         };
    1: 
    1: // keycode of keypad when not num-locked
    1: struct nsKeyConverter nsKeycodesBeOSNoNumLock[] = {
    1: 	        { NS_VK_LEFT,       0x48 },
    1: 	        { NS_VK_RIGHT,      0x4a },
    1: 	        { NS_VK_UP,         0x38 },
    1: 	        { NS_VK_DOWN,       0x59 },
    1: 	        { NS_VK_PAGE_UP,    0x39 },
    1: 	        { NS_VK_PAGE_DOWN,  0x5a },
    1: 	        { NS_VK_HOME,       0x37 },
    1: 	        { NS_VK_END,        0x58 },
    1: 	        { NS_VK_INSERT,     0x64 },
    1: 	        { NS_VK_DELETE,     0x65 }
    1:         };
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Translate key code
    1: // Input is BeOS keyboard key-code; output is in NS_VK format
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: static int TranslateBeOSKeyCode(int32 bekeycode, bool isnumlock)
    1: {
    1: #ifdef KB_DEBUG
    1: 	printf("TranslateBeOSKeyCode: bekeycode = 0x%x\n",bekeycode);
    1: #endif
    1: 	int i;
    1: 	int length = sizeof(nsKeycodesBeOS) / sizeof(struct nsKeyConverter);
    1: 	int length_numlock = sizeof(nsKeycodesBeOSNumLock) / sizeof(struct nsKeyConverter);
    1: 	int length_nonumlock = sizeof(nsKeycodesBeOSNoNumLock) / sizeof(struct nsKeyConverter);
    1: 
    1: 	// key code conversion
    1: 	for (i = 0; i < length; i++)
    1: 	{
    1: 		if (nsKeycodesBeOS[i].bekeycode == bekeycode)
    1: 			return(nsKeycodesBeOS[i].vkCode);
    1: 	}
    1: 	// numpad keycode vary with numlock
    1: 	if (isnumlock)
    1: 	{
    1: 		for (i = 0; i < length_numlock; i++)
    1: 		{
    1: 			if (nsKeycodesBeOSNumLock[i].bekeycode == bekeycode)
    1: 				return(nsKeycodesBeOSNumLock[i].vkCode);
    1: 		}
    1: 	}
    1: 	else
    1: 	{
    1: 		for (i = 0; i < length_nonumlock; i++)
    1: 		{
    1: 			if (nsKeycodesBeOSNoNumLock[i].bekeycode == bekeycode)
    1: 				return(nsKeycodesBeOSNoNumLock[i].vkCode);
    1: 		}
    1: 	}
    1: #ifdef KB_DEBUG
    1: 	printf("TranslateBeOSKeyCode: ####### Translation not Found #######\n");
    1: #endif
    1: 	return((int)0);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // OnKeyDown
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnKeyDown(PRUint32 aEventType, const char *bytes,
    1:                            int32 numBytes, PRUint32 mod, PRUint32 bekeycode, int32 rawcode)
    1: {
    1: 	PRUint32 aTranslatedKeyCode;
    1: 	PRBool noDefault = PR_FALSE;
    1: 
    1: 	mIsShiftDown   = (mod & B_SHIFT_KEY) ? PR_TRUE : PR_FALSE;
    1: 	mIsControlDown = (mod & B_CONTROL_KEY) ? PR_TRUE : PR_FALSE;
    1: 	mIsAltDown     = ((mod & B_COMMAND_KEY) && !(mod & B_RIGHT_OPTION_KEY))? PR_TRUE : PR_FALSE;
    1: 	mIsMetaDown    = (mod & B_LEFT_OPTION_KEY) ? PR_TRUE : PR_FALSE;	
    1: 	bool IsNumLocked = ((mod & B_NUM_LOCK) != 0);
    1: 
    1: 	aTranslatedKeyCode = TranslateBeOSKeyCode(bekeycode, IsNumLocked);
    1: 
    1: 	if (numBytes <= 1)
    1: 	{
    1: 		noDefault  = DispatchKeyEvent(NS_KEY_DOWN, 0, aTranslatedKeyCode);
    1: 	}
    1: 	else
    1: 	{
    1: 		//   non ASCII chars
    1: 	}
    1: 
    1: 	// ------------  On Char  ------------
    1: 	PRUint32	uniChar;
    1: 
    1: 	if ((mIsControlDown || mIsAltDown || mIsMetaDown) && rawcode >= 'a' && rawcode <= 'z')
    1: 	{
    1: 		if (mIsShiftDown)
    1: 			uniChar = rawcode + 'A' - 'a';
    1: 		else
    1: 			uniChar = rawcode;
    1: 		aTranslatedKeyCode = 0;
    1: 	} 
    1: 	else
    1: 	{
    1: 		if (numBytes == 0) // deal with unmapped key
    1: 			return noDefault;
    1: 
    1: 		switch((unsigned char)bytes[0])
    1: 		{
    1: 		case 0xc8://System Request
    1: 		case 0xca://Break
    1: 			return noDefault;// do not send 'KEY_PRESS' message
    1: 
    1: 		case B_INSERT:
    1: 		case B_ESCAPE:
    1: 		case B_FUNCTION_KEY:
    1: 		case B_HOME:
    1: 		case B_PAGE_UP:
    1: 		case B_END:
    1: 		case B_PAGE_DOWN:
    1: 		case B_UP_ARROW:
    1: 		case B_LEFT_ARROW:
    1: 		case B_DOWN_ARROW:
    1: 		case B_RIGHT_ARROW:
    1: 		case B_TAB:
    1: 		case B_DELETE:
    1: 		case B_BACKSPACE:
    1: 		case B_ENTER:
    1: 			uniChar = 0;
    1: 			break;
    1: 
    1: 		default:
    1: 			// UTF-8 to unicode conversion
    1: 			if (numBytes >= 1 && (bytes[0] & 0x80) == 0)
    1: 			{
    1: 				// 1 byte utf-8 char
    1: 				uniChar = bytes[0];
    1: 			} 
    1: 			else
    1: 			{
    1: 				if (numBytes >= 2 && (bytes[0] & 0xe0) == 0xc0)
    1: 				{
    1: 					// 2 byte utf-8 char
    1: 					uniChar = ((uint16)(bytes[0] & 0x1f) << 6) | (uint16)(bytes[1] & 0x3f);
    1: 				}
    1: 				else
    1: 				{
    1: 					if (numBytes >= 3 && (bytes[0] & 0xf0) == 0xe0)
    1: 					{
    1: 						// 3 byte utf-8 char
    1: 						uniChar = ((uint16)(bytes[0] & 0x0f) << 12) | ((uint16)(bytes[1] & 0x3f) << 6)
    1: 						          | (uint16)(bytes[2] & 0x3f);
    1: 					}
    1: 					else
    1: 					{
    1: 						//error
    1: 						uniChar = 0;
    1: 						NS_WARNING("nsWindow::OnKeyDown() error: bytes[] has not enough chars.");
    1: 					}
    1: 				}
    1: 			}
    1: 			aTranslatedKeyCode = 0;
    1: 			break;
    1: 		}
    1: 	}
    1: 
    1: 	// If prevent default set for onkeydown, do the same for onkeypress
    1: 	PRUint32 extraFlags = (noDefault ? NS_EVENT_FLAG_NO_DEFAULT : 0);
    1: 	return DispatchKeyEvent(NS_KEY_PRESS, uniChar, aTranslatedKeyCode, extraFlags) && noDefault;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // OnKeyUp
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnKeyUp(PRUint32 aEventType, const char *bytes,
    1:                          int32 numBytes, PRUint32 mod, PRUint32 bekeycode, int32 rawcode)
    1: {
    1: 	PRUint32 aTranslatedKeyCode;
    1: 	bool IsNumLocked = ((mod & B_NUM_LOCK) != 0);
    1: 
    1: 	mIsShiftDown   = (mod & B_SHIFT_KEY) ? PR_TRUE : PR_FALSE;
    1: 	mIsControlDown = (mod & B_CONTROL_KEY) ? PR_TRUE : PR_FALSE;
    1: 	mIsAltDown     = ((mod & B_COMMAND_KEY) && !(mod & B_RIGHT_OPTION_KEY))? PR_TRUE : PR_FALSE;
    1: 	mIsMetaDown    = (mod & B_LEFT_OPTION_KEY) ? PR_TRUE : PR_FALSE;	
    1: 
    1: 	aTranslatedKeyCode = TranslateBeOSKeyCode(bekeycode, IsNumLocked);
    1: 
    1: 	PRBool result = DispatchKeyEvent(NS_KEY_UP, 0, aTranslatedKeyCode);
    1: 	return result;
    1: 
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // DispatchKeyEvent
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: PRBool nsWindow::DispatchKeyEvent(PRUint32 aEventType, PRUint32 aCharCode,
    1:                                   PRUint32 aKeyCode, PRUint32 aFlags)
    1: {
    1: 	nsKeyEvent event(PR_TRUE, aEventType, this);
    1: 	nsPoint point;
    1: 
    1: 	point.x = 0;
    1: 	point.y = 0;
    1: 
    1: 	InitEvent(event, &point); // this add ref's event.widget
    1: 
    1: 	event.flags |= aFlags;
    1: 	event.charCode = aCharCode;
    1: 	event.keyCode  = aKeyCode;
    1: 
    1: #ifdef KB_DEBUG
    1: 	static int cnt=0;
    1: 	printf("%d DispatchKE Type: %s charCode 0x%x  keyCode 0x%x ", cnt++,
    1: 	       (NS_KEY_PRESS == aEventType)?"PRESS":(aEventType == NS_KEY_UP?"Up":"Down"),
    1: 	       event.charCode, event.keyCode);
    1: 	printf("Shift: %s Control %s Alt: %s Meta: %s\n",  
    1: 	       (mIsShiftDown?"D":"U"), 
    1: 	       (mIsControlDown?"D":"U"), 
    1: 	       (mIsAltDown?"D":"U"),
    1: 	       (mIsMetaDown?"D":"U"));
    1: #endif
    1: 
    1: 	event.isShift   = mIsShiftDown;
    1: 	event.isControl = mIsControlDown;
    1: 	event.isMeta   =  mIsMetaDown;
    1: 	event.isAlt     = mIsAltDown;
    1: 
    1: 	PRBool result = DispatchWindowEvent(&event);
    1: 	NS_RELEASE(event.widget);
    1: 
    1: 	return result;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // WM_DESTROY has been called
    1: //
    1: //-------------------------------------------------------------------------
    1: void nsWindow::OnDestroy()
    1: {
    1: 	mOnDestroyCalled = PR_TRUE;
    1: 
    1: 	// release references to children, device context, toolkit, and app shell
    1: 	nsBaseWidget::OnDestroy();
    1: 
    1: 	// dispatch the event
    1: 	if (!mIsDestroying) 
    1: 	{
    1: 		// dispatching of the event may cause the reference count to drop to 0
    1: 		// and result in this object being destroyed. To avoid that, add a reference
    1: 		// and then release it after dispatching the event
    1: 		AddRef();
    1: 		DispatchStandardEvent(NS_DESTROY);
    1: 		Release();
    1: 	}
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Move
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnMove(PRInt32 aX, PRInt32 aY)
    1: {
    1: 	nsGUIEvent event(PR_TRUE, NS_MOVE, this);
    1: 	InitEvent(event);
    1: 	event.refPoint.x = aX;
    1: 	event.refPoint.y = aY;
    1: 
    1: 	PRBool result = DispatchWindowEvent(&event);
    1: 	NS_RELEASE(event.widget);
    1: 	return result;
    1: }
    1: 
    1: void nsWindow::OnWheel(PRInt32 aDirection, uint32 aButtons, BPoint aPoint, nscoord aDelta)
    1: {
    1: 		// we don't use the mIsXDown bools because
    1: 		// they get reset on Gecko reload (makes it harder
    1: 		// to use stuff like Alt+Wheel)
    1: 
    1: 		nsMouseScrollEvent scrollEvent(PR_TRUE, NS_MOUSE_SCROLL, this);
    1: 		uint32 mod (modifiers());
    1: 		scrollEvent.isControl = mod & B_CONTROL_KEY;
    1: 		scrollEvent.isShift = mod & B_SHIFT_KEY;
    1: 		scrollEvent.isAlt   = mod & B_COMMAND_KEY;
    1: 		scrollEvent.isMeta  = mod & B_OPTION_KEY;
    1: 						
    1: 		scrollEvent.scrollFlags = aDirection;
    1: 		scrollEvent.delta = aDelta;
    1: 		scrollEvent.time      = PR_IntervalNow();
    1: 		scrollEvent.refPoint.x = nscoord(aPoint.x);
    1: 		scrollEvent.refPoint.y = nscoord(aPoint.y);
    1: 
    1: 		nsEventStatus rv;
    1: 		DispatchEvent (&scrollEvent, rv);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Paint
    1: //
    1: //-------------------------------------------------------------------------
    1: nsresult nsWindow::OnPaint(BRegion *breg)
    1: {
    1: 	nsresult rv = NS_ERROR_FAILURE;
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		// Substracting area from paintregion
    1: 		mView->Validate(breg);
    1: 		// looks like it should be done by Mozilla via nsRenderingContext methods,
    1: 		// but we saw in some cases how it follows Win32 ideas and don't care about clipping there
    1: 		mView->ConstrainClippingRegion(breg);
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	else
    1: 		return rv;
    1: 	BRect br = breg->Frame();
    1: 	if (!br.IsValid() || !mEventCallback || !mView  || (eWindowType_child != mWindowType && eWindowType_popup != mWindowType))
    1: 		return rv;
    1: 	nsRect nsr(nscoord(br.left), nscoord(br.top), 
    1: 			nscoord(br.IntegerWidth() + 1), nscoord(br.IntegerHeight() + 1));
    1: 	mUpdateArea->SetTo(0,0,0,0);
    1: 	int numrects = breg->CountRects();
    1: 	for (int i = 0; i< numrects; i++)
    1: 	{
    1: 		BRect br = breg->RectAt(i);
    1: 		mUpdateArea->Union(int(br.left), int(br.top), 
    1: 							br.IntegerWidth() + 1, br.IntegerHeight() + 1);
    1: 	}	
    1: 
    1: 	nsIRenderingContext* rc = GetRenderingContext();
 3368: 	if (NS_UNLIKELY(!rc)) {
 3368: 		return NS_ERROR_FAILURE;
 3368: 	}
 3368: 
    1: 	// Double buffering for cairo builds is done here
 9438: 	nsRefPtr<gfxContext> ctx = rc->ThebesContext();
    1: 	ctx->Save();
    1: 
    1: 	// Clip
    1: 	ctx->NewPath();
    1: 	for (int i = 0; i< numrects; i++)
    1: 	{
    1: 		BRect br = breg->RectAt(i);
    1: 		ctx->Rectangle(gfxRect(int(br.left), int(br.top), 
    1: 			       br.IntegerWidth() + 1, br.IntegerHeight() + 1));
    1: 	}
    1: 	ctx->Clip();
    1: 
    1: 	// double buffer
    1: 	ctx->PushGroup(gfxContext::CONTENT_COLOR);
    1: 
    1: 	nsPaintEvent event(PR_TRUE, NS_PAINT, this);
    1: 
    1: 	InitEvent(event);
    1: 	event.region = mUpdateArea;
    1: 	event.rect = &nsr;
    1: 	event.renderingContext = rc;
    1: 	if (event.renderingContext != nsnull)
    1: 	{
    1: 		// TODO: supply nsRenderingContextBeOS with font, colors and other state variables here.
    1: 		// It will help toget rid of some hacks in LockAndUpdateView and
    1: 		// allow non-permanent nsDrawingSurface for BeOS - currently it fails for non-bitmapped BViews/widgets.
    1: 		// Something like this:
    1: 		//if (mFontMetrics)
    1: 		//	event.renderingContext->SetFont(mFontMetrics);
    1: 		rv = DispatchWindowEvent(&event) ? NS_OK : NS_ERROR_FAILURE;
    1: 		NS_RELEASE(event.renderingContext);
    1: 	}
    1: 
    1: 	NS_RELEASE(event.widget);
    1: 
    1: 	// The second half of double buffering
    1: 	if (rv == NS_OK) {
    1: 		ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
    1: 		ctx->PopGroupToSource();
    1: 		ctx->Paint();
    1: 	} else {
    1: 		// ignore
    1: 		ctx->PopGroup();
    1: 	}
    1: 
    1: 	ctx->Restore();
    1: 
    1: 	return rv;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Send a resize message to the listener
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::OnResize(nsRect &aWindowRect)
    1: {
    1: 	// call the event callback
    1: 	if (mEventCallback)
    1: 	{
    1: 		nsSizeEvent event(PR_TRUE, NS_SIZE, this);
    1: 		InitEvent(event);
    1: 		event.windowSize = &aWindowRect;
    1: 		// We have same size for windows rect and "client area" rect
    1: 		event.mWinWidth  = aWindowRect.width;
    1: 		event.mWinHeight = aWindowRect.height;
    1: 		PRBool result = DispatchWindowEvent(&event);
    1: 		NS_RELEASE(event.widget);
    1: 		return result;
    1: 	}
    1: 	return PR_FALSE;
    1: }
    1: 
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with all sort of mouse event
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchMouseEvent(PRUint32 aEventType, nsPoint aPoint, PRUint32 clicks, PRUint32 mod,
    1:                                     PRUint16 aButton)
    1: {
    1: 	PRBool result = PR_FALSE;
18401: 	if (nsnull != mEventCallback)
    1: 	{
    1: 		nsMouseEvent event(PR_TRUE, aEventType, this, nsMouseEvent::eReal);
    1: 		InitEvent (event, &aPoint);
    1: 		event.isShift   = mod & B_SHIFT_KEY;
    1: 		event.isControl = mod & B_CONTROL_KEY;
    1: 		event.isAlt     = mod & B_COMMAND_KEY;
    1: 		event.isMeta     = mod & B_OPTION_KEY;
    1: 		event.clickCount = clicks;
    1: 		event.button = aButton;
    1: 
    1: 		// call the event callback
    1:     result = DispatchWindowEvent(&event);
    1:     NS_RELEASE(event.widget);
    1:     return result;
    1: 	}
    1: 
    1: 	return PR_FALSE;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Deal with focus messages
    1: //
    1: //-------------------------------------------------------------------------
    1: PRBool nsWindow::DispatchFocus(PRUint32 aEventType)
    1: {
    1: 	// call the event callback
    1: 	if (mEventCallback)
    1: 		return(DispatchStandardEvent(aEventType));
    1: 
    1: 	return PR_FALSE;
    1: }
    1: 
    1: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
    1: {
    1: 	if (mView && mView->LockLooper())
    1: 	{
    1: 		mView->Window()->SetTitle(NS_ConvertUTF16toUTF8(aTitle).get());
    1: 		mView->UnlockLooper();
    1: 	}
    1: 	return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------
    1: //
    1: // Get/Set the preferred size
    1: //
    1: //----------------------------------------------------
    1: NS_METHOD nsWindow::GetPreferredSize(PRInt32& aWidth, PRInt32& aHeight)
    1: {
    1: 	// TODO:  Check to see how often this is called.  If too much, leave as is,
    1: 	// otherwise, call mView->GetPreferredSize
    1: 	aWidth  = mPreferredWidth;
    1: 	aHeight = mPreferredHeight;
    1: 	return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_METHOD nsWindow::SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight)
    1: {
    1: 	mPreferredWidth  = aWidth;
    1: 	mPreferredHeight = aHeight;
    1: 	return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------
    1: // Special Sub-Class
    1: //----------------------------------------------------
    1: nsIWidgetStore::nsIWidgetStore( nsIWidget *aWidget )
    1: 		: mWidget( aWidget )
    1: {
    1: 	// NS_ADDREF/NS_RELEASE is not needed here.
    1: 	// This class is used as internal (BeOS native) object of nsWindow,
    1: 	// so it must not addref/release nsWindow here.
    1: 	// Otherwise, nsWindow object will leak. (Makoto Hamanaka)
    1: }
    1: 
    1: nsIWidgetStore::~nsIWidgetStore()
    1: {
    1: }
    1: 
    1: nsIWidget *nsIWidgetStore::GetMozillaWidget(void)
    1: {
    1: 	return mWidget;
    1: }
    1: 
    1: //----------------------------------------------------
    1: // BeOS Sub-Class Window
    1: //----------------------------------------------------
    1: 
    1: nsWindowBeOS::nsWindowBeOS( nsIWidget *aWidgetWindow, BRect aFrame, const char *aName, window_look aLook,
    1:                             window_feel aFeel, int32 aFlags, int32 aWorkspace )
    1: 		: BWindow( aFrame, aName, aLook, aFeel, aFlags, aWorkspace ),
    1: 		nsIWidgetStore( aWidgetWindow )
    1: {
    1: 	fJustGotBounds = true;
    1: }
    1: 
    1: nsWindowBeOS::~nsWindowBeOS()
    1: {
    1: 	//placeholder for clean up
    1: }
    1: 
    1: bool nsWindowBeOS::QuitRequested( void )
    1: {
    1: 	if (CountChildren() != 0)
    1: 	{
    1: 		nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 		nsToolkit	*t;
    1: 		if (w && (t = w->GetToolkit()) != 0)
    1: 		{
    1: 			MethodInfo *info = nsnull;
    1: 			if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::CLOSEWINDOW)))
    1: 				t->CallMethodAsync(info);
    1: 		}
    1: 	}
    1: 	return true;
    1: }
    1: 
    1: void nsWindowBeOS::MessageReceived(BMessage *msg)
    1: {
    1: 	// Temp replacement for real DnD. Supports file drop onto window.
    1: 	if (msg->what == B_SIMPLE_DATA)
    1: 	{
    1: 		printf("BWindow::SIMPLE_DATA\n");
    1: 		be_app_messenger.SendMessage(msg);
    1: 	}
    1: 	BWindow::MessageReceived(msg);
    1: }
    1: 
    1: // This function calls KeyDown() for Alt+whatever instead of app_server,
    1: // also used for Destroy workflow 
    1: void nsWindowBeOS::DispatchMessage(BMessage *msg, BHandler *handler)
    1: {
    1: 	if (msg->what == B_KEY_DOWN && modifiers() & B_COMMAND_KEY)
    1: 	{
    1: 		BString bytes;
    1: 		if (B_OK == msg->FindString("bytes", &bytes))
    1: 		{
    1: 			BView *view = this->CurrentFocus();
    1: 			if (view)
    1: 				view->KeyDown(bytes.String(), bytes.Length());
    1: 		}
    1: 		if (strcmp(bytes.String(),"w") && strcmp(bytes.String(),"W"))
    1: 			BWindow::DispatchMessage(msg, handler);
    1: 	}
    1: 	// In some cases the message don't reach QuitRequested() hook,
    1: 	// so do it here
    1: 	else if(msg->what == B_QUIT_REQUESTED)
    1: 	{
    1: 		// tells nsWindow to kill me
    1: 		nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 		nsToolkit	*t;
    1: 		if (w && (t = w->GetToolkit()) != 0)
    1: 		{
    1: 			MethodInfo *info = nsnull;
    1: 			if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::CLOSEWINDOW)))
    1: 				t->CallMethodAsync(info);
    1: 		}		
    1: 	}
    1: 	else
    1: 		BWindow::DispatchMessage(msg, handler);
    1: }
    1: 
    1: //This method serves single purpose here - allows Mozilla to save current window position,
    1: //and restore position on new start. 
    1: void nsWindowBeOS::FrameMoved(BPoint origin)
    1: {	
    1: 
    1: 	//determine if the window position actually changed
    1: 	if (origin.x == lastWindowPoint.x && origin.x == lastWindowPoint.x) 
    1: 	{
    1: 		//it didn't - don't bother
    1: 		return;
    1: 	}
    1: 	lastWindowPoint = origin;
    1: 	nsWindow  *w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit *t;
    1: 	if (w && (t = w->GetToolkit()) != 0) 
    1: 	{
    1: 		MethodInfo *info = nsnull;
    1: 		if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONMOVE)))
    1: 			t->CallMethodAsync(info);
    1: 	}
    1: }
    1: 
    1: void nsWindowBeOS::WindowActivated(bool active)
    1: {
    1: // Calls method ONACTIVATE to dispatch focus ACTIVATE messages
    1: 	nsWindow        *w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		uint32	args[2];
    1: 		args[0] = (uint32)active;
    1: 		args[1] = (uint32)this;
    1: 		MethodInfo *info = nsnull;
    1: 		if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONACTIVATE, 2, args)))
    1: 			t->CallMethodAsync(info);
    1: 	}
    1: }
    1: 
    1: void  nsWindowBeOS::WorkspacesChanged(uint32 oldworkspace, uint32 newworkspace)
    1: {
    1: 	if (oldworkspace == newworkspace)
    1: 		return;
    1: 	nsWindow        *w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		uint32	args[2];
    1: 		args[0] = newworkspace;
    1: 		args[1] = oldworkspace;
    1: 		MethodInfo *info = nsnull;
    1: 		if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONWORKSPACE, 2, args)))
    1: 			t->CallMethodAsync(info);
    1: 	}	
    1: }
    1: 
    1: void  nsWindowBeOS::FrameResized(float width, float height)
    1: {
    1: 	// We have send message already, and Mozilla still didn't get it
    1: 	// so don't poke it endlessly with no reason
    1: 	if (!fJustGotBounds)
    1: 		return;
    1: 	nsWindow        *w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		MethodInfo *info = nsnull;
    1: 		if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONRESIZE)))
    1: 		{
    1: 			//Memorize fact of sending message
    1: 			if (t->CallMethodAsync(info))
    1: 				fJustGotBounds = false;
    1: 		}
    1: 	}	
    1: }
    1: 
    1: //----------------------------------------------------
    1: // BeOS Sub-Class View
    1: //----------------------------------------------------
    1: 
    1: nsViewBeOS::nsViewBeOS(nsIWidget *aWidgetWindow, BRect aFrame, const char *aName, uint32 aResizingMode, uint32 aFlags)
    1: 	: BView(aFrame, aName, aResizingMode, aFlags), nsIWidgetStore(aWidgetWindow), wheel(.0,.0)
    1: {
    1: 	SetViewColor(B_TRANSPARENT_COLOR);
    1: 	paintregion.MakeEmpty();	
    1: 	buttons = 0;
    1: 	fRestoreMouseMask = false;
    1: 	fJustValidated = true;
    1: 	fWheelDispatched = true;
    1: 	fVisible = true;
    1: }
    1: 
    1: void nsViewBeOS::SetVisible(bool visible)
    1: {
    1: 	if (visible)
    1: 		SetFlags(Flags() | B_WILL_DRAW);
    1: 	else
    1: 		SetFlags(Flags() & ~B_WILL_DRAW);
    1: 	fVisible = visible;
    1: }
    1: 
    1: inline bool nsViewBeOS::Visible()
    1: {
    1: 	return fVisible;
    1: }
    1:  
    1: void nsViewBeOS::Draw(BRect updateRect)
    1: {
    1: 	// Ignore all, we are scrolling.
    1: 	if (!fVisible)
    1: 		return;
    1: 
    1: 	paintregion.Include(updateRect);
    1: 
    1: 	// We have send message already, and Mozilla still didn't get it
    1: 	// so don't poke it endlessly with no reason. Also don't send message
    1: 	// if update region is empty.
    1: 	if (paintregion.CountRects() == 0 || !paintregion.Frame().IsValid() || !fJustValidated)
    1: 		return;
    1: 	uint32	args[1];
    1: 	args[0] = (uint32)this;
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		MethodInfo *info = nsnull;
    1: 		info = new MethodInfo(w, w, nsSwitchToUIThread::ONPAINT, 1, args);
    1: 		if (info)
    1: 		{
    1: 			//Memorize fact of sending message
    1: 			if (t->CallMethodAsync(info))
    1: 				fJustValidated = false;
    1: 		}
    1: 	}
    1: }
    1: 
    1: // Method to get update rects for asynchronous drawing.
    1: bool nsViewBeOS::GetPaintRegion(BRegion *r)
    1: {
    1: 
    1: 	// Mozilla got previous ONPAINT message,
    1: 	// ready for next event.
    1: 	fJustValidated = true;
    1: 	if (paintregion.CountRects() == 0)
    1: 		return false;
    1: 	r->Include(&paintregion);
    1: 	return true;
    1: }
    1: 
    1: // Method to remove painted rects from pending update region
    1: void nsViewBeOS::Validate(BRegion *reg)
    1: {
    1: 	paintregion.Exclude(reg);
    1: }
    1: 
    1: BPoint nsViewBeOS::GetWheel()
    1: {
    1: 	BPoint retvalue = wheel;
    1: 	// Mozilla got wheel event, so setting flag and cleaning delta storage
    1: 	fWheelDispatched = true;
    1: 	wheel.x = 0;
    1: 	wheel.y = 0;
    1: 	return retvalue;
    1: }
    1: 
    1: void nsViewBeOS::MouseDown(BPoint point)
    1: {
    1: 	if (!fRestoreMouseMask)
    1: 		mouseMask = SetMouseEventMask(B_POINTER_EVENTS);
    1: 	fRestoreMouseMask = true;
    1: 	
    1: 	//To avoid generating extra mouseevents when there is no change in pos.
    1: 	mousePos = point;
    1: 
    1: 	uint32 clicks = 0;
    1: 	BMessage *msg = Window()->CurrentMessage();
    1: 	msg->FindInt32("buttons", (int32 *) &buttons);
    1: 	msg->FindInt32("clicks", (int32 *) &clicks);
    1: 
    1: 	if (0 == buttons)
    1: 		return;
    1: 
    1: 	nsWindow	*w = (nsWindow *) GetMozillaWidget();
    1: 	if (w == NULL)
    1: 		return;
    1: 		
    1: 	nsToolkit	*t = w->GetToolkit();
    1: 	if (t == NULL)
    1: 		return;
    1: 
    1: 	PRUint16 eventButton =
    1: 	  (buttons & B_PRIMARY_MOUSE_BUTTON) ? nsMouseEvent::eLeftButton :
    1: 	    ((buttons & B_SECONDARY_MOUSE_BUTTON) ? nsMouseEvent::eRightButton :
    1: 	      nsMouseEvent::eMiddleButton);
    1: 	uint32	args[6];
    1: 	args[0] = NS_MOUSE_BUTTON_DOWN;
    1: 	args[1] = (uint32) point.x;
    1: 	args[2] = (uint32) point.y;
    1: 	args[3] = clicks;
    1: 	args[4] = modifiers();
    1: 	args[5] = eventButton;
    1: 	MethodInfo *info = nsnull;
    1: 	if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::BTNCLICK, 6, args)))
    1: 		t->CallMethodAsync(info);
    1: }
    1: 
    1: void nsViewBeOS::MouseMoved(BPoint point, uint32 transit, const BMessage *msg)
    1: {
    1: 	//To avoid generating extra mouseevents when there is no change in pos.
    1: 	//and not entering exiting view.
    1: 	if (mousePos == point && (transit == B_INSIDE_VIEW || transit == B_OUTSIDE_VIEW))
    1: 		return;
    1: 
    1: 	mousePos = point;
    1: 		
    1: 	//We didn't start the mouse down and there is no drag in progress, so ignore.
    1: 	if (NULL == msg && !fRestoreMouseMask && buttons)
    1: 		return;
    1: 		
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	if (w == NULL)
    1: 		return;
 2955: 	nsToolkit	*t = w->GetToolkit();
    1: 	if (t == NULL)
    1: 		return;
    1: 	uint32	args[4];
    1: 	args[1] = (int32) point.x;
    1: 	args[2] = (int32) point.y;
    1: 	args[3] = modifiers();
    1: 
    1: 	switch (transit)
    1:  	{
    1:  	case B_ENTERED_VIEW:
    1: 		{
    1: 			args[0] = NULL != msg ? NS_DRAGDROP_ENTER : NS_MOUSE_ENTER;
    1: 			if (msg == NULL)
    1: 				break;
    1: 			nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1: 			dragService->StartDragSession();
    1: 			//As it may have come from the outside we need to update this.
    1: 			nsCOMPtr<nsIDragSessionBeOS> dragSessionBeOS = do_QueryInterface(dragService);
    1: 			dragSessionBeOS->UpdateDragMessageIfNeeded(new BMessage(*msg));
    1: 		}
    1: 		break;
    1: 	case B_EXITED_VIEW:
    1: 		{
    1: 			args[0] = NULL != msg ? NS_DRAGDROP_EXIT : NS_MOUSE_EXIT;
    1: 			if (msg == NULL)
    1: 				break;
    1: 			nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
  482: 			dragService->EndDragSession(PR_FALSE);
    1: 		}
    1: 		break;
    1: 	default:
    1: 		args[0]= msg == NULL ? NS_MOUSE_MOVE : NS_DRAGDROP_OVER;
  482:         // fire the drag event at the source
  482:         if (msg != NULL) {
  482: 			nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
  482: 			dragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
  482:         }
    1:  	}
    1:  	
    1: 	MethodInfo *moveInfo = nsnull;
    1: 	if (nsnull != (moveInfo = new MethodInfo(w, w, nsSwitchToUIThread::ONMOUSE, 4, args)))
    1: 		t->CallMethodAsync(moveInfo);
    1: }
    1: 
    1: void nsViewBeOS::MouseUp(BPoint point)
    1: {
    1: 	if (fRestoreMouseMask) 
    1: 	{
    1: 		SetMouseEventMask(mouseMask);
    1: 		fRestoreMouseMask = false;
    1: 	}
    1: 	
    1: 	//To avoid generating extra mouseevents when there is no change in pos.
    1: 	mousePos = point;
    1: 
    1: 	PRUint16 eventButton =
    1: 	  (buttons & B_PRIMARY_MOUSE_BUTTON) ? nsMouseEvent::eLeftButton :
    1: 	    ((buttons & B_SECONDARY_MOUSE_BUTTON) ? nsMouseEvent::eRightButton :
    1: 	      nsMouseEvent::eMiddleButton);
    1: 	
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	if (w == NULL)
    1: 		return;
 2955: 	nsToolkit	*t = w->GetToolkit();
    1: 	if (t == NULL)
    1: 		return;
    1: 
    1: 
    1: 	uint32	args[6];
    1: 	args[0] = NS_MOUSE_BUTTON_UP;
    1: 	args[1] = (uint32) point.x;
    1: 	args[2] = (int32) point.y;
    1: 	args[3] = 0;
    1: 	args[4] = modifiers();
    1: 	args[5] = eventButton;
    1: 	MethodInfo *info = nsnull;
    1: 	if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::BTNCLICK, 6, args)))
    1: 		t->CallMethodAsync(info);
    1: }
    1: 
    1: void nsViewBeOS::MessageReceived(BMessage *msg)
    1: {
    1: 	if(msg->WasDropped())
    1: 	{
    1: 		nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 		if (w == NULL)
    1: 			return;
 2955: 		nsToolkit	*t = w->GetToolkit();
    1: 		if (t == NULL)
    1: 			return;
    1: 
    1: 		uint32	args[4];
    1: 		args[0] = NS_DRAGDROP_DROP;
    1: 
    1: 		//Drop point is in screen-cordinates
    1: 		BPoint aPoint = ConvertFromScreen(msg->DropPoint()); 
    1: 	
    1: 		args[1] = (uint32) aPoint.x;
    1: 		args[2] = (uint32) aPoint.y;
    1: 		args[3] = modifiers();
    1: 
    1: 		MethodInfo *info = new MethodInfo(w, w, nsSwitchToUIThread::ONDROP, 4, args);
    1: 		t->CallMethodAsync(info);
    1: 		BView::MessageReceived(msg);
    1: 		return;
    1: 	}
    1: 
    1: 	switch(msg->what)
    1: 	{
    1: 	//Native drag'n'drop negotiation
    1: 	case B_COPY_TARGET:
    1: 	case B_MOVE_TARGET:
    1: 	case B_LINK_TARGET:
    1: 	case B_TRASH_TARGET:
    1: 		{
    1: 			nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1: 			nsCOMPtr<nsIDragSessionBeOS> dragSessionBeOS = do_QueryInterface(dragService);
    1: 			dragSessionBeOS->TransmitData(new BMessage(*msg));
    1: 		}
    1: 		break;
    1: 	case B_UNMAPPED_KEY_DOWN:
    1: 		//printf("unmapped_key_down\n");
    1: 		KeyDown(NULL, 0);
    1: 		break;
    1: 
    1: 	case B_UNMAPPED_KEY_UP:
    1: 		//printf("unmapped_key_up\n");
    1: 		KeyUp(NULL, 0);
    1: 		break;
    1: 
    1: 	case B_MOUSE_WHEEL_CHANGED:
    1: 		{
    1: 			float wheel_y;
    1: 			float wheel_x;
    1: 
    1: 			msg->FindFloat ("be:wheel_delta_y", &wheel_y);
    1: 			msg->FindFloat ("be:wheel_delta_x", &wheel_x);
    1: 			wheel.x += wheel_x;
    1: 			wheel.y += wheel_y;
    1: 
    1: 			if(!fWheelDispatched || (nscoord(wheel_x) == 0 && nscoord(wheel_y) == 0))
    1: 				return;
    1: 			uint32	args[1];
    1: 			args[0] = (uint32)this;
    1: 			nsWindow    *w = (nsWindow *)GetMozillaWidget();
    1: 			nsToolkit   *t;
    1: 
    1: 			if (w && (t = w->GetToolkit()) != 0)
    1: 			{
    1: 					
    1: 				MethodInfo *info = nsnull;
    1: 				if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONWHEEL, 1, args)))
    1: 				{
    1: 					if (t->CallMethodAsync(info))
    1: 						fWheelDispatched = false;
    1: 					
    1: 				}
    1: 			}
    1: 		}
    1: 		break;
    1: 		
    1: #if defined(BeIME)
    1: 	case B_INPUT_METHOD_EVENT:
    1: 		DoIME(msg);
    1: 		break;
    1: #endif
    1: 	default :
    1: 		BView::MessageReceived(msg);
    1: 		break;
    1: 	}
    1: }
    1: 
    1: void nsViewBeOS::KeyDown(const char *bytes, int32 numBytes)
    1: {
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	int32 keycode = 0;
    1: 	int32 rawcode = 0;
    1: 
    1: 	BMessage *msg = this->Window()->CurrentMessage();
    1: 	if (msg)
    1: 	{
    1: 		msg->FindInt32("key", &keycode);
    1: 		msg->FindInt32("raw_char", &rawcode);
    1: 	}
    1: 
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		uint32 bytebuf = 0;
    1: 		uint8 *byteptr = (uint8 *)&bytebuf;
    1: 		for(int32 i = 0; i < numBytes; i++)
    1: 			byteptr[i] = bytes[i];
    1: 
    1: 		uint32	args[6];
    1: 		args[0] = NS_KEY_DOWN;
    1: 		args[1] = bytebuf;
    1: 		args[2] = numBytes;
    1: 		args[3] = modifiers();
    1: 		args[4] = keycode;
    1: 		args[5] = rawcode;
    1: 		MethodInfo *info = nsnull;
    1: 		if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONKEY, 6, args)))
    1: 			t->CallMethodAsync(info);
    1: 	}
    1: }
    1: 
    1: void nsViewBeOS::KeyUp(const char *bytes, int32 numBytes)
    1: {
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	int32 keycode = 0;
    1: 	int32 rawcode = 0;
    1: 	BMessage *msg = this->Window()->CurrentMessage();
    1: 	if (msg)
    1: 	{
    1: 		msg->FindInt32("key", &keycode);
    1: 		msg->FindInt32("raw_char", &rawcode);
    1: 	}
    1: 
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		uint32 bytebuf = 0;
    1: 		uint8 *byteptr = (uint8 *)&bytebuf;
    1: 		for(int32 i = 0; i < numBytes; i++)
    1: 			byteptr[i] = bytes[i];
    1: 
    1: 		uint32	args[6];
    1: 		args[0] = NS_KEY_UP;
    1: 		args[1] = (int32)bytebuf;
    1: 		args[2] = numBytes;
    1: 		args[3] = modifiers();
    1: 		args[4] = keycode;
    1: 		args[5] = rawcode;
    1: 		MethodInfo *info = nsnull;
    1: 		if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::ONKEY, 6, args)))
    1: 			t->CallMethodAsync(info);
    1: 	}
    1: }
    1: 
    1: void nsViewBeOS::MakeFocus(bool focused)
    1: {
    1: 	if (!IsFocus() && focused)
    1: 		BView::MakeFocus(focused);
    1: 	uint32	args[1];
    1: 	args[0] = (uint32)this;
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 	if (w && (t = w->GetToolkit()) != 0)
    1: 	{
    1: 		MethodInfo *info = nsnull;
    1: 		if (!focused)
    1: 		{
    1: 			if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::KILL_FOCUS, 1, args)))
    1: 				t->CallMethodAsync(info);
    1: 		}
    1: #ifdef DEBUG_FOCUS
    1: 		else
    1: 		{
    1: 			if (nsnull != (info = new MethodInfo(w, w, nsSwitchToUIThread::GOT_FOCUS, 1, args)))
    1: 				t->CallMethodAsync(info);
    1: 		}
    1: #endif		
    1: 	}
    1: }
    1: 
    1: #if defined(BeIME)
    1: // Inline Input Method implementation
    1: void nsViewBeOS::DoIME(BMessage *msg)
    1: {
    1: 	nsWindow	*w = (nsWindow *)GetMozillaWidget();
    1: 	nsToolkit	*t;
    1: 
    1: 	if(w && (t = w->GetToolkit()) != 0) 
    1: 	{
    1: 		ssize_t size = msg->FlattenedSize();
    1: 		int32		argc = (size+3)/4;
    1: 		uint32 *args = new uint32[argc];
    1: 		if (args) 
    1: 		{
    1: 			msg->Flatten((char*)args, size);
    1: 			MethodInfo *info = new MethodInfo(w, w, nsSwitchToUIThread::ONIME, argc, args);
    1: 			if (info) 
    1: 			{
    1: 				t->CallMethodAsync(info);
    1: 				NS_RELEASE(t);
    1: 			}
    1: 			delete[] args;
    1: 		}	
    1: 	}
    1: }
    1: #endif
