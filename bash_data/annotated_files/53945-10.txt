28484: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
22840: /* ***** BEGIN LICENSE BLOCK *****
22840:  * 
22840:  * Copyright (c) 2008, Mozilla Corporation
22840:  * All rights reserved.
22840:  * 
22840:  * Redistribution and use in source and binary forms, with or without
22840:  * modification, are permitted provided that the following conditions are met:
22840:  * 
22840:  * * Redistributions of source code must retain the above copyright notice, this
22840:  *   list of conditions and the following disclaimer.
22840:  * * Redistributions in binary form must reproduce the above copyright notice,
22840:  *   this list of conditions and the following disclaimer in the documentation
22840:  *   and/or other materials provided with the distribution.
22840:  * * Neither the name of the Mozilla Corporation nor the names of its
22840:  *   contributors may be used to endorse or promote products derived from this
22840:  *   software without specific prior written permission.
22840:  * 
22840:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
22840:  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
22840:  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22840:  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
22840:  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
22840:  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
22840:  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
22840:  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
22840:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
22840:  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
22840:  * 
22840:  * Contributor(s):
22840:  *   Josh Aas <josh@mozilla.com>
26700:  *   Michael Ventnor <mventnor@mozilla.com>
22840:  * 
22840:  * ***** END LICENSE BLOCK ***** */
22840: 
22840: #include "nptest_platform.h"
26700: #include "npapi.h"
41053: #include <pthread.h>
26700: #include <gdk/gdk.h>
26700: #ifdef MOZ_X11
26700: #include <gdk/gdkx.h>
30508: #include <X11/extensions/shape.h>
26700: #endif
41053: #include <glib.h>
26802: #include <gtk/gtk.h>
41053: #include <unistd.h>
26700: 
33639:  using namespace std;
33639: 
28484: struct _PlatformData {
33821: #ifdef MOZ_X11
28484:   Display* display;
33821:   Visual* visual;
33821:   Colormap colormap;
33821: #endif
28484:   GtkWidget* plug;
28484: };
28484: 
26802: bool
26802: pluginSupportsWindowMode()
26802: {
26802:   return true;
26802: }
26802: 
26802: bool
26802: pluginSupportsWindowlessMode()
26802: {
26802:   return true;
26802: }
22840: 
22840: NPError
22840: pluginInstanceInit(InstanceData* instanceData)
22840: {
26700: #ifdef MOZ_X11
28484:   instanceData->platformData = static_cast<PlatformData*>
28484:     (NPN_MemAlloc(sizeof(PlatformData)));
28484:   if (!instanceData->platformData)
28484:     return NPERR_OUT_OF_MEMORY_ERROR;
28484: 
33821:   instanceData->platformData->display = NULL;
33821:   instanceData->platformData->visual = NULL;
33821:   instanceData->platformData->colormap = None;  
33821:   instanceData->platformData->plug = NULL;
28484: 
22840:   return NPERR_NO_ERROR;
26700: #else
26700:   // we only support X11 here, since thats what the plugin system uses
26700:   return NPERR_INCOMPATIBLE_VERSION_ERROR;
26700: #endif
22840: }
22840: 
26802: void
26802: pluginInstanceShutdown(InstanceData* instanceData)
22840: {
28484:   if (instanceData->hasWidget) {
28484:     Window window = reinterpret_cast<XID>(instanceData->window.window);
28484: 
28484:     if (window != None) {
28484:       // This window XID should still be valid.
28484:       // See bug 429604 and bug 454756.
28484:       XWindowAttributes attributes;
28484:       if (!XGetWindowAttributes(instanceData->platformData->display, window,
28484:                                 &attributes))
28484:         g_error("XGetWindowAttributes failed at plugin instance shutdown");
28484:     }
28484:   }
28484: 
28484:   GtkWidget* plug = instanceData->platformData->plug;
26802:   if (plug) {
28484:     instanceData->platformData->plug = 0;
41489:     if (instanceData->cleanupWidget) {
41489:       // Default/tidy behavior
26802:       gtk_widget_destroy(plug);
41489:     } else {
41489:       // Flash Player style: let the GtkPlug destroy itself on disconnect.
41489:       g_signal_handlers_disconnect_matched(plug, G_SIGNAL_MATCH_DATA, 0, 0,
41489:                                            NULL, NULL, instanceData);
41489:     }
28484:   }
28484: 
28484:   NPN_MemFree(instanceData->platformData);
26802:   instanceData->platformData = 0;
26802: }
26700: 
26700: static void 
26700: SetCairoRGBA(cairo_t* cairoWindow, PRUint32 rgba)
26700: {
26700:   float b = (rgba & 0xFF) / 255.0;
26700:   float g = ((rgba & 0xFF00) >> 8) / 255.0;
26700:   float r = ((rgba & 0xFF0000) >> 16) / 255.0;
26700:   float a = ((rgba & 0xFF000000) >> 24) / 255.0;
26700: 
26700:   cairo_set_source_rgba(cairoWindow, r, g, b, a);
26700: }
26700: 
26802: static void
26802: pluginDrawSolid(InstanceData* instanceData, GdkDrawable* gdkWindow,
26802:                 int x, int y, int width, int height)
26700: {
26700:   cairo_t* cairoWindow = gdk_cairo_create(gdkWindow);
26700: 
27843:   if (!instanceData->hasWidget) {
27843:     NPRect* clip = &instanceData->window.clipRect;
27843:     cairo_rectangle(cairoWindow, clip->left, clip->top,
27843:                     clip->right - clip->left, clip->bottom - clip->top);
27843:     cairo_clip(cairoWindow);
27843:   }
27843: 
26802:   GdkRectangle windowRect = { x, y, width, height };
26700:   gdk_cairo_rectangle(cairoWindow, &windowRect);
26700:   SetCairoRGBA(cairoWindow, instanceData->scriptableObject->drawColor);
26700: 
26700:   cairo_fill(cairoWindow);
26700:   cairo_destroy(cairoWindow);
22840: }
22840: 
26802: static void
36768: pluginDrawWindow(InstanceData* instanceData, GdkDrawable* gdkWindow,
36768:                  const GdkRectangle& invalidRect)
22840: {
26802:   NPWindow& window = instanceData->window;
26802:   // When we have a widget, window.x/y are meaningless since our
26802:   // widget is always positioned correctly and we just draw into it at 0,0
26802:   int x = instanceData->hasWidget ? 0 : window.x;
26802:   int y = instanceData->hasWidget ? 0 : window.y;
26802:   int width = window.width;
26802:   int height = window.height;
26802: 
26802:   if (instanceData->scriptableObject->drawMode == DM_SOLID_COLOR) {
26802:     // drawing a solid color for reftests
36768:     pluginDrawSolid(instanceData, gdkWindow,
36768:                     invalidRect.x, invalidRect.y,
36768:                     invalidRect.width, invalidRect.height);
53945:     notifyDidPaint(instanceData);
26700:     return;
26802:   }
26700: 
26700:   NPP npp = instanceData->npp;
26700:   if (!npp)
26700:     return;
26700: 
26700:   const char* uaString = NPN_UserAgent(npp);
26700:   if (!uaString)
26700:     return;
26700: 
26700:   GdkGC* gdkContext = gdk_gc_new(gdkWindow);
26942:   if (!gdkContext)
26942:     return;
26700: 
27843:   if (!instanceData->hasWidget) {
27843:     NPRect* clip = &window.clipRect;
27843:     GdkRectangle gdkClip = { clip->left, clip->top, clip->right - clip->left,
27843:                              clip->bottom - clip->top };
27843:     gdk_gc_set_clip_rectangle(gdkContext, &gdkClip);
27843:   }
27843: 
26700:   // draw a grey background for the plugin frame
26700:   GdkColor grey;
26700:   grey.red = grey.blue = grey.green = 32767;
26700:   gdk_gc_set_rgb_fg_color(gdkContext, &grey);
26802:   gdk_draw_rectangle(gdkWindow, gdkContext, TRUE, x, y, width, height);
26700: 
26700:   // draw a 3-pixel-thick black frame around the plugin
26700:   GdkColor black;
26700:   black.red = black.green = black.blue = 0;
26700:   gdk_gc_set_rgb_fg_color(gdkContext, &black);
26700:   gdk_gc_set_line_attributes(gdkContext, 3, GDK_LINE_SOLID, GDK_CAP_NOT_LAST, GDK_JOIN_MITER);
26802:   gdk_draw_rectangle(gdkWindow, gdkContext, FALSE, x + 1, y + 1,
26802:                      width - 3, height - 3);
26700: 
26700:   // paint the UA string
26700:   PangoContext* pangoContext = gdk_pango_context_get();
26700:   PangoLayout* pangoTextLayout = pango_layout_new(pangoContext);
26802:   pango_layout_set_width(pangoTextLayout, (width - 10) * PANGO_SCALE);
26700:   pango_layout_set_text(pangoTextLayout, uaString, -1);
26802:   gdk_draw_layout(gdkWindow, gdkContext, x + 5, y + 5, pangoTextLayout);
26700:   g_object_unref(pangoTextLayout);
26700: 
26700:   g_object_unref(gdkContext);
53945: 
53945:   notifyDidPaint(instanceData);
26802: }
26802: 
26802: static gboolean
26802: ExposeWidget(GtkWidget* widget, GdkEventExpose* event,
26802:              gpointer user_data)
26802: {
26802:   InstanceData* instanceData = static_cast<InstanceData*>(user_data);
36768:   pluginDrawWindow(instanceData, event->window, event->area);
26802:   return TRUE;
26802: }
26802: 
28484: static gboolean
31130: MotionEvent(GtkWidget* widget, GdkEventMotion* event,
31130:             gpointer user_data)
31130: {
31130:   InstanceData* instanceData = static_cast<InstanceData*>(user_data);
31130:   instanceData->lastMouseX = event->x;
31130:   instanceData->lastMouseY = event->y;
31130:   return TRUE;
31130: }
31130: 
31130: static gboolean
31130: ButtonEvent(GtkWidget* widget, GdkEventButton* event,
31130:             gpointer user_data)
31130: {
31130:   InstanceData* instanceData = static_cast<InstanceData*>(user_data);
31130:   instanceData->lastMouseX = event->x;
31130:   instanceData->lastMouseY = event->y;
31130:   return TRUE;
31130: }
31130: 
31130: static gboolean
28484: DeleteWidget(GtkWidget* widget, GdkEvent* event, gpointer user_data)
28484: {
28484:   InstanceData* instanceData = static_cast<InstanceData*>(user_data);
28484:   // Some plugins do not expect the plug to be removed from the socket before
28484:   // the plugin instance is destroyed.  e.g. bug 485125
28484:   if (instanceData->platformData->plug)
28484:     g_error("plug removed"); // this aborts
28484: 
28484:   return FALSE;
28484: }
28484: 
26802: void
26942: pluginDoSetWindow(InstanceData* instanceData, NPWindow* newWindow)
26942: {
26942:   instanceData->window = *newWindow;
28484: 
33821: #ifdef MOZ_X11
28484:   NPSetWindowCallbackStruct *ws_info =
28484:     static_cast<NPSetWindowCallbackStruct*>(newWindow->ws_info);
28484:   instanceData->platformData->display = ws_info->display;
33821:   instanceData->platformData->visual = ws_info->visual;
33821:   instanceData->platformData->colormap = ws_info->colormap;
33821: #endif
26942: }
26942: 
26942: void
26802: pluginWidgetInit(InstanceData* instanceData, void* oldWindow)
26802: {
26802: #ifdef MOZ_X11
28484:   GtkWidget* oldPlug = instanceData->platformData->plug;
26802:   if (oldPlug) {
28484:     instanceData->platformData->plug = 0;
26802:     gtk_widget_destroy(oldPlug);
26802:   }
26802: 
26802:   GdkNativeWindow nativeWinId =
26802:     reinterpret_cast<XID>(instanceData->window.window);
26802: 
26802:   /* create a GtkPlug container */
26802:   GtkWidget* plug = gtk_plug_new(nativeWinId);
26802: 
41543:   // Test for bugs 539138 and 561308
41543:   if (!plug->window)
41543:     g_error("Plug has no window"); // aborts
41543: 
26802:   /* make sure the widget is capable of receiving focus */
26802:   GTK_WIDGET_SET_FLAGS (GTK_WIDGET(plug), GTK_CAN_FOCUS);
26802: 
26802:   /* all the events that our widget wants to receive */
31130:   gtk_widget_add_events(plug, GDK_EXPOSURE_MASK | GDK_POINTER_MOTION_MASK |
31130:                               GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK);
28484:   g_signal_connect(G_OBJECT(plug), "expose-event", G_CALLBACK(ExposeWidget),
28484:                    instanceData);
31130:   g_signal_connect(G_OBJECT(plug), "motion_notify_event", G_CALLBACK(MotionEvent),
31130:                    instanceData);
31130:   g_signal_connect(G_OBJECT(plug), "button_press_event", G_CALLBACK(ButtonEvent),
31130:                    instanceData);
31130:   g_signal_connect(G_OBJECT(plug), "button_release_event", G_CALLBACK(ButtonEvent),
31130:                    instanceData);
28484:   g_signal_connect(G_OBJECT(plug), "delete-event", G_CALLBACK(DeleteWidget),
26802:                    instanceData);
26802:   gtk_widget_show(plug);
26802: 
28484:   instanceData->platformData->plug = plug;
26802: #endif
26802: }
26802: 
26802: int16_t
26802: pluginHandleEvent(InstanceData* instanceData, void* event)
26802: {
26802: #ifdef MOZ_X11
26802:   XEvent* nsEvent = (XEvent*)event;
26802: 
31130:   switch (nsEvent->type) {
31130:   case GraphicsExpose: {
36768:     const XGraphicsExposeEvent& expose = nsEvent->xgraphicsexpose;
36768:     NPWindow& window = instanceData->window;
36768:     window.window = (void*)(expose.drawable);
26802: 
36768:     GdkNativeWindow nativeWinId = reinterpret_cast<XID>(window.window);
33821: 
36768:     GdkDisplay* gdkDisplay = gdk_x11_lookup_xdisplay(expose.display);
33821:     if (!gdkDisplay) {
33821:       g_warning("Display not opened by GDK");
33821:       return 0;
33821:     }
33821:     // gdk_pixmap_foreign_new() doesn't check whether a GdkPixmap already
33821:     // exists, so check first.
33821:     // https://bugzilla.gnome.org/show_bug.cgi?id=590690
33821:     GdkPixmap* gdkDrawable =
33821:       GDK_DRAWABLE(gdk_pixmap_lookup_for_display(gdkDisplay, nativeWinId));
33821:     // If there is no existing GdkPixmap or it doesn't have a colormap then
33821:     // create our own.
33821:     if (gdkDrawable) {
33821:       GdkColormap* gdkColormap = gdk_drawable_get_colormap(gdkDrawable);
33821:       if (!gdkColormap) {
33821:         g_warning("No GdkColormap on GdkPixmap");
33821:         return 0;
33821:       }
33821:       if (gdk_x11_colormap_get_xcolormap(gdkColormap)
33821:           != instanceData->platformData->colormap) {
33821:         g_warning("wrong Colormap");
33821:         return 0;
33821:       }
33821:       if (gdk_x11_visual_get_xvisual(gdk_colormap_get_visual(gdkColormap))
33821:           != instanceData->platformData->visual) {
33821:         g_warning("wrong Visual");
33821:         return 0;
33821:       }
33821:       g_object_ref(gdkDrawable);
33821:     } else {
33821:       gdkDrawable =
33821:         GDK_DRAWABLE(gdk_pixmap_foreign_new_for_display(gdkDisplay,
33821:                                                         nativeWinId));
33821:       VisualID visualID = instanceData->platformData->visual->visualid;
33821:       GdkVisual* gdkVisual =
33821:         gdk_x11_screen_lookup_visual(gdk_drawable_get_screen(gdkDrawable),
33821:                                      visualID);
33821:       GdkColormap* gdkColormap =
33821:         gdk_x11_colormap_foreign_new(gdkVisual,
33821:                                      instanceData->platformData->colormap);
33821:       gdk_drawable_set_colormap(gdkDrawable, gdkColormap);
33821:       g_object_unref(G_OBJECT(gdkColormap));
33821:     }
33821: 
36768:     const NPRect& clip = window.clipRect;
36768:     if (expose.x < clip.left || expose.y < clip.top ||
36768:         expose.x + expose.width > clip.right ||
36768:         expose.y + expose.height > clip.bottom) {
36768:       g_warning("expose rectangle not in clip rectangle");
36768:       return 0;
36768:     }
36768:     if (expose.x < window.x || expose.y < window.y ||
36768:         expose.x + expose.width > window.x + int32_t(window.width) ||
36768:         expose.y + expose.height > window.y + int32_t(window.height)) {
36768:       g_warning("expose rectangle not in plugin rectangle");
36768:       return 0;
36768:     }      
36768: 
36768:     GdkRectangle invalidRect =
36768:       { expose.x, expose.y, expose.width, expose.height };
36768:     pluginDrawWindow(instanceData, gdkDrawable, invalidRect);
33821:     g_object_unref(gdkDrawable);
31130:     break;
31130:   }
31130:   case MotionNotify: {
31130:     XMotionEvent* motion = &nsEvent->xmotion;
31130:     instanceData->lastMouseX = motion->x;
31130:     instanceData->lastMouseY = motion->y;
31130:     break;
31130:   }
31130:   case ButtonPress:
31130:   case ButtonRelease: {
31130:     XButtonEvent* button = &nsEvent->xbutton;
31130:     instanceData->lastMouseX = button->x;
31130:     instanceData->lastMouseY = button->y;
31130:     break;
31130:   }
31130:   default:
31130:     break;
31130:   }
26700: #endif
31130: 
26802:   return 0;
26700: }
26942: 
26942: int32_t pluginGetEdge(InstanceData* instanceData, RectEdge edge)
26942: {
26942:   if (!instanceData->hasWidget)
26942:     return NPTEST_INT32_ERROR;
28484:   GtkWidget* plug = instanceData->platformData->plug;
26942:   if (!plug)
26942:     return NPTEST_INT32_ERROR;
26942:   GdkWindow* plugWnd = plug->window;
26942:   if (!plugWnd)
26942:     return NPTEST_INT32_ERROR;
29988: 
29988:   GdkWindow* toplevelGdk = 0;
29988: #ifdef MOZ_X11
29988:   Window toplevel = 0;
29988:   NPN_GetValue(instanceData->npp, NPNVnetscapeWindow, &toplevel);
29988:   if (!toplevel)
29988:     return NPTEST_INT32_ERROR;
29988:   toplevelGdk = gdk_window_foreign_new(toplevel);
29988: #endif
29988:   if (!toplevelGdk)
26942:     return NPTEST_INT32_ERROR;
26942: 
29988:   GdkRectangle toplevelFrameExtents;
29988:   gdk_window_get_frame_extents(toplevelGdk, &toplevelFrameExtents);
29988:   g_object_unref(toplevelGdk);
29988: 
29988:   gint pluginWidth, pluginHeight;
29988:   gdk_drawable_get_size(GDK_DRAWABLE(plugWnd), &pluginWidth, &pluginHeight);
29988:   gint pluginOriginX, pluginOriginY;
29988:   gdk_window_get_origin(plugWnd, &pluginOriginX, &pluginOriginY);
29988:   gint pluginX = pluginOriginX - toplevelFrameExtents.x;
29988:   gint pluginY = pluginOriginY - toplevelFrameExtents.y;
26942: 
26942:   switch (edge) {
26942:   case EDGE_LEFT:
29988:     return pluginX;
26942:   case EDGE_TOP:
29988:     return pluginY;
26942:   case EDGE_RIGHT:
29988:     return pluginX + pluginWidth;
26942:   case EDGE_BOTTOM:
29988:     return pluginY + pluginHeight;
26942:   }
29988: 
26942:   return NPTEST_INT32_ERROR;
26942: }
26942: 
30508: #ifdef MOZ_X11
30508: static void intersectWithShapeRects(Display* display, Window window,
30508:                                     int kind, GdkRegion* region)
30508: {
30508:   int count = -1, order;
30508:   XRectangle* shapeRects =
30508:     XShapeGetRectangles(display, window, kind, &count, &order);
30508:   // The documentation says that shapeRects will be NULL when the
30508:   // extension is not supported. Unfortunately XShapeGetRectangles
30508:   // also returns NULL when the region is empty, so we can't treat
30508:   // NULL as failure. I hope this way is OK.
30508:   if (count < 0)
30508:     return;
30508: 
30508:   GdkRegion* shapeRegion = gdk_region_new();
30508:   if (!shapeRegion) {
30508:     XFree(shapeRects);
30508:     return;
30508:   }
30508: 
30508:   for (int i = 0; i < count; ++i) {
30508:     XRectangle* r = &shapeRects[i];
30508:     GdkRectangle rect = { r->x, r->y, r->width, r->height };
30508:     gdk_region_union_with_rect(shapeRegion, &rect);
30508:   }
30508:   XFree(shapeRects);
30508: 
30508:   gdk_region_intersect(region, shapeRegion);
30508:   gdk_region_destroy(shapeRegion);
30508: }
30508: #endif
30508: 
29988: static GdkRegion* computeClipRegion(InstanceData* instanceData)
29988: {
29988:   if (!instanceData->hasWidget)
29988:     return 0;
29988: 
29988:   GtkWidget* plug = instanceData->platformData->plug;
29988:   if (!plug)
29988:     return 0;
29988:   GdkWindow* plugWnd = plug->window;
29988:   if (!plugWnd)
29988:     return 0;
29988: 
29988:   gint plugWidth, plugHeight;
29988:   gdk_drawable_get_size(GDK_DRAWABLE(plugWnd), &plugWidth, &plugHeight);
29988:   GdkRectangle pluginRect = { 0, 0, plugWidth, plugHeight };
29988:   GdkRegion* region = gdk_region_rectangle(&pluginRect);
29988:   if (!region)
29988:     return 0;
29988: 
29988:   int pluginX = 0, pluginY = 0;
29988: 
29988: #ifdef MOZ_X11
29988:   Display* display = GDK_WINDOW_XDISPLAY(plugWnd);
29988:   Window window = GDK_WINDOW_XWINDOW(plugWnd);
29988: 
29988:   Window toplevel = 0;
29988:   NPN_GetValue(instanceData->npp, NPNVnetscapeWindow, &toplevel);
29988:   if (!toplevel)
29988:     return 0;
29988: 
29988:   for (;;) {
29988:     Window root;
29988:     int x, y;
29988:     unsigned int width, height, border_width, depth;
29988:     if (!XGetGeometry(display, window, &root, &x, &y, &width, &height,
29988:                       &border_width, &depth)) {
29988:       gdk_region_destroy(region);
29988:       return 0;
29988:     }
29988: 
30508:     GdkRectangle windowRect = { 0, 0, width, height };
29988:     GdkRegion* windowRgn = gdk_region_rectangle(&windowRect);
29988:     if (!windowRgn) {
29988:       gdk_region_destroy(region);
29988:       return 0;
29988:     }
30508:     intersectWithShapeRects(display, window, ShapeBounding, windowRgn);
30508:     intersectWithShapeRects(display, window, ShapeClip, windowRgn);
30508:     gdk_region_offset(windowRgn, -pluginX, -pluginY);
30172:     gdk_region_intersect(region, windowRgn);
29988:     gdk_region_destroy(windowRgn);
29988: 
29988:     // Stop now if we've reached the toplevel. Stopping here means
29988:     // clipping performed by the toplevel window is taken into account.
29988:     if (window == toplevel)
29988:       break;
29988: 
29988:     Window parent;
29988:     Window* children;
29988:     unsigned int nchildren;
29988:     if (!XQueryTree(display, window, &root, &parent, &children, &nchildren)) {
29988:       gdk_region_destroy(region);
29988:       return 0;
29988:     }
29988:     XFree(children);
29988: 
29988:     pluginX += x;
29988:     pluginY += y;
29988: 
29988:     window = parent;
29988:   }
29988: #endif
29988:   // pluginX and pluginY are now relative to the toplevel. Make them
29988:   // relative to the window frame top-left.
29988:   GdkWindow* toplevelGdk = gdk_window_foreign_new(window);
29988:   if (!toplevelGdk)
29988:     return 0;
29988:   GdkRectangle toplevelFrameExtents;
29988:   gdk_window_get_frame_extents(toplevelGdk, &toplevelFrameExtents);
29988:   gint toplevelOriginX, toplevelOriginY;
29988:   gdk_window_get_origin(toplevelGdk, &toplevelOriginX, &toplevelOriginY);
29988:   g_object_unref(toplevelGdk);
29988: 
29988:   pluginX += toplevelOriginX - toplevelFrameExtents.x;
29988:   pluginY += toplevelOriginY - toplevelFrameExtents.y;
29988: 
29988:   gdk_region_offset(region, pluginX, pluginY);
29988:   return region;
29988: }
29988: 
26942: int32_t pluginGetClipRegionRectCount(InstanceData* instanceData)
26942: {
29988:   GdkRegion* region = computeClipRegion(instanceData);
29988:   if (!region)
26942:     return NPTEST_INT32_ERROR;
29988: 
29988:   GdkRectangle* rects;
29988:   gint nrects;
29988:   gdk_region_get_rectangles(region, &rects, &nrects);
29988:   gdk_region_destroy(region);
29988:   g_free(rects);
29988:   return nrects;
26942: }
26942: 
26942: int32_t pluginGetClipRegionRectEdge(InstanceData* instanceData, 
26942:     int32_t rectIndex, RectEdge edge)
26942: {
29988:   GdkRegion* region = computeClipRegion(instanceData);
29988:   if (!region)
26942:     return NPTEST_INT32_ERROR;
26942: 
29988:   GdkRectangle* rects;
29988:   gint nrects;
29988:   gdk_region_get_rectangles(region, &rects, &nrects);
29988:   gdk_region_destroy(region);
29988:   if (rectIndex >= nrects) {
29988:     g_free(rects);
26942:     return NPTEST_INT32_ERROR;
26942:   }
26942: 
29988:   GdkRectangle rect = rects[rectIndex];
29988:   g_free(rects);
26942: 
26942:   switch (edge) {
26942:   case EDGE_LEFT:
26942:     return rect.x;
26942:   case EDGE_TOP:
26942:     return rect.y;
26942:   case EDGE_RIGHT:
26942:     return rect.x + rect.width;
26942:   case EDGE_BOTTOM:
26942:     return rect.y + rect.height;
26942:   }
26942:   return NPTEST_INT32_ERROR;
26942: }
33358: 
33358: void pluginDoInternalConsistencyCheck(InstanceData* instanceData, string& error)
33358: {
33358: }
38686: 
38686: string
38686: pluginGetClipboardText(InstanceData* instanceData)
38686: {
38686:   GtkClipboard* cb = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);
38686:   // XXX this is a BAD WAY to interact with GtkClipboard.  We use this
38686:   // deprecated interface only to test nested event loop handling.
38686:   gchar* text = gtk_clipboard_wait_for_text(cb);
38686:   string retText = text ? text : "";
38686: 
38686:   g_free(text);
38686: 
38686:   return retText;
38686: }
41053: 
41053: //-----------------------------------------------------------------------------
41053: // NB: this test is quite gross in that it's not only
41053: // nondeterministic, but dependent on the guts of the nested glib
41053: // event loop handling code in PluginModule.  We first sleep long
41053: // enough to make sure that the "detection timer" will be pending when
41053: // we enter the nested glib loop, then similarly for the "process browser
41053: // events" timer.  Then we "schedule" the crasher thread to run at about the
41053: // same time we expect that the PluginModule "process browser events" task
41053: // will run.  If all goes well, the plugin process will crash and generate the
41053: // XPCOM "plugin crashed" task, and the browser will run that task while still
41053: // in the "process some events" loop.
41053: 
41053: static void*
41053: CrasherThread(void* data)
41053: {
41053:   // Give the parent thread a chance to send the message.
41053:   usleep(200);
41053: 
41053:   // Exit (without running atexit hooks) rather than crashing with a signal
41053:   // so as to make timing more reliable.  The process terminates immediately
41053:   // rather than waiting for a thread in the parent process to attach and
41053:   // generate a minidump.
41053:   _exit(1);
41053: 
41053:   // not reached
41053:   return(NULL);
41053: }
41053: 
41053: bool
41053: pluginCrashInNestedLoop(InstanceData* instanceData)
41053: {
41053:   // wait at least long enough for nested loop detector task to be pending ...
41053:   sleep(1);
41053: 
41053:   // Run the nested loop detector by processing all events that are waiting.
41053:   bool found_event = false;
41053:   while (g_main_context_iteration(NULL, FALSE)) {
41053:     found_event = true;
41053:   }
41053:   if (!found_event) {
41053:     g_warning("DetectNestedEventLoop did not fire");
41053:     return true; // trigger a test failure
41053:   }
41053: 
41053:   // wait at least long enough for the "process browser events" task to be
41053:   // pending ...
41053:   sleep(1);
41053: 
41053:   // we'll be crashing soon, note that fact now to avoid messing with
41053:   // timing too much
41053:   NoteIntentionalCrash();
41053: 
41053:   // schedule the crasher thread ...
41053:   pthread_t crasherThread;
41053:   if (0 != pthread_create(&crasherThread, NULL, CrasherThread, NULL)) {
41053:     g_warning("Failed to create thread");
41053:     return true; // trigger a test failure
41053:   }
41053: 
41053:   // .. and hope it crashes at about the same time as the "process browser
41053:   // events" task (that should run in this loop) is being processed in the
41053:   // parent.
41053:   found_event = false;
41053:   while (g_main_context_iteration(NULL, FALSE)) {
41053:     found_event = true;
41053:   }
41053:   if (found_event) {
41053:     g_warning("Should have crashed in ProcessBrowserEvents");
41053:   } else {
41053:     g_warning("ProcessBrowserEvents did not fire");
41053:   }
41053: 
41053:   // if we get here without crashing, then we'll trigger a test failure
41053:   return true;
41053: }
