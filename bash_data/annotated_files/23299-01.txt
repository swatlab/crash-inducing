    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim:cindent:ts=2:et:sw=2:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation. Modifications made by IBM 
    1:  * described herein are Copyright (c) International Business Machines Corporation, 2000.
    1:  * Modifications to Mozilla code or documentation identified per MPL Section 3.3
    1:  *
    1:  * Date             Modified by     Description of modification
    1:  * 04/20/2000       IBM Corp.      OS/2 VisualAge build.
    1:  */
    1: 
    1: /* storage of the frame tree and information about it */
    1: 
    1: #include "nscore.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsStyleSet.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsCOMPtr.h"
    1: #include "prthread.h"
    1: #include "plhash.h"
    1: #include "nsPlaceholderFrame.h"
 7863: #include "nsContainerFrame.h"
 7046: #include "nsBlockFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #ifdef NS_DEBUG
    1: #include "nsISupportsArray.h"
    1: #include "nsIStyleRule.h"
    1: #endif
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsPresState.h"
    1: #include "nsIContent.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIScrollableFrame.h"
    1: 
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsIForm.h"
    1: #include "nsContentUtils.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "imgIRequest.h"
16232: #include "nsStyleStructInlines.h"
    1: 
    1: #include "nsFrameManager.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleEvent.h"
    1: #endif
    1: 
    1:   #ifdef DEBUG
    1:     //#define NOISY_DEBUG
    1:     //#define DEBUG_UNDISPLAYED_MAP
    1:   #else
    1:     #undef NOISY_DEBUG
    1:     #undef DEBUG_UNDISPLAYED_MAP
    1:   #endif
    1: 
    1:   #ifdef NOISY_DEBUG
    1:     #define NOISY_TRACE(_msg) \
    1:       printf("%s",_msg);
    1:     #define NOISY_TRACE_FRAME(_msg,_frame) \
    1:       printf("%s ",_msg); nsFrame::ListTag(stdout,_frame); printf("\n");
    1:   #else
    1:     #define NOISY_TRACE(_msg);
    1:     #define NOISY_TRACE_FRAME(_msg,_frame);
    1:   #endif
    1: 
    1: // IID's
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: struct PlaceholderMapEntry : public PLDHashEntryHdr {
    1:   // key (the out of flow frame) can be obtained through placeholder frame
    1:   nsPlaceholderFrame *placeholderFrame;
    1: };
    1: 
20261: static PRBool
    1: PlaceholderMapMatchEntry(PLDHashTable *table, const PLDHashEntryHdr *hdr,
    1:                          const void *key)
    1: {
    1:   const PlaceholderMapEntry *entry =
 3233:     static_cast<const PlaceholderMapEntry*>(hdr);
    1:   NS_ASSERTION(entry->placeholderFrame->GetOutOfFlowFrame() !=
    1:                (void*)0xdddddddd,
    1:                "Dead placeholder in placeholder map");
    1:   return entry->placeholderFrame->GetOutOfFlowFrame() == key;
    1: }
    1: 
    1: static PLDHashTableOps PlaceholderMapOps = {
    1:   PL_DHashAllocTable,
    1:   PL_DHashFreeTable,
    1:   PL_DHashVoidPtrKeyStub,
    1:   PlaceholderMapMatchEntry,
    1:   PL_DHashMoveEntryStub,
    1:   PL_DHashClearEntryStub,
    1:   PL_DHashFinalizeStub,
    1:   NULL
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: struct PrimaryFrameMapEntry : public PLDHashEntryHdr {
    1:   // key (the content node) can almost always be obtained through the
    1:   // frame.  If it weren't for the way image maps (mis)used the primary
    1:   // frame map, we'd be able to have a 2 word entry instead of a 3 word
    1:   // entry.
    1:   nsIContent *content;
    1:   nsIFrame *frame;
    1: };
    1: 
    1:   // These ops should be used if/when we switch back to a 2-word entry.
    1:   // See comment in |PrimaryFrameMapEntry| above.
    1: #if 0
20261: static PRBool
    1: PrimaryFrameMapMatchEntry(PLDHashTable *table, const PLDHashEntryHdr *hdr,
    1:                          const void *key)
    1: {
    1:   const PrimaryFrameMapEntry *entry =
 3233:     static_cast<const PrimaryFrameMapEntry*>(hdr);
    1:   return entry->frame->GetContent() == key;
    1: }
    1: 
    1: static PLDHashTableOps PrimaryFrameMapOps = {
    1:   PL_DHashAllocTable,
    1:   PL_DHashFreeTable,
    1:   PL_DHashVoidPtrKeyStub,
    1:   PrimaryFrameMapMatchEntry,
    1:   PL_DHashMoveEntryStub,
    1:   PL_DHashClearEntryStub,
    1:   PL_DHashFinalizeStub,
    1:   NULL
    1: };
    1: #endif /* 0 */
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // XXXldb This seems too complicated for what I think it's doing, and it
    1: // should also be using pldhash rather than plhash to use less memory.
    1: 
    1: class UndisplayedNode {
    1: public:
    1:   UndisplayedNode(nsIContent* aContent, nsStyleContext* aStyle)
    1:     : mContent(aContent),
    1:       mStyle(aStyle),
    1:       mNext(nsnull)
    1:   {
    1:     MOZ_COUNT_CTOR(UndisplayedNode);
    1:   }
    1: 
    1:   NS_HIDDEN ~UndisplayedNode()
    1:   {
    1:     MOZ_COUNT_DTOR(UndisplayedNode);
21193: 
21193:     // Delete mNext iteratively to avoid blowing up the stack (bug 460461).
21193:     UndisplayedNode *cur = mNext;
21193:     while (cur) {
21193:       UndisplayedNode *next = cur->mNext;
21193:       cur->mNext = nsnull;
21193:       delete cur;
21193:       cur = next;
21193:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent>      mContent;
    1:   nsRefPtr<nsStyleContext>  mStyle;
    1:   UndisplayedNode*          mNext;
    1: };
    1: 
    1: class nsFrameManagerBase::UndisplayedMap {
    1: public:
    1:   UndisplayedMap(PRUint32 aNumBuckets = 16) NS_HIDDEN;
    1:   ~UndisplayedMap(void) NS_HIDDEN;
    1: 
    1:   NS_HIDDEN_(UndisplayedNode*) GetFirstNode(nsIContent* aParentContent);
    1: 
    1:   NS_HIDDEN_(nsresult) AddNodeFor(nsIContent* aParentContent,
    1:                                   nsIContent* aChild, nsStyleContext* aStyle);
    1: 
    1:   NS_HIDDEN_(void) RemoveNodeFor(nsIContent* aParentContent,
    1:                                  UndisplayedNode* aNode);
    1: 
    1:   NS_HIDDEN_(void) RemoveNodesFor(nsIContent* aParentContent);
    1: 
    1:   // Removes all entries from the hash table
    1:   NS_HIDDEN_(void)  Clear(void);
    1: 
    1: protected:
    1:   NS_HIDDEN_(PLHashEntry**) GetEntryFor(nsIContent* aParentContent);
    1:   NS_HIDDEN_(void)          AppendNodeFor(UndisplayedNode* aNode,
    1:                                           nsIContent* aParentContent);
    1: 
    1:   PLHashTable*  mTable;
    1:   PLHashEntry** mLastLookup;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsFrameManager::nsFrameManager()
    1: {
    1: }
    1: 
    1: nsFrameManager::~nsFrameManager()
    1: {
    1:   NS_ASSERTION(!mPresShell, "nsFrameManager::Destroy never called");
    1: }
    1: 
    1: nsresult
    1: nsFrameManager::Init(nsIPresShell* aPresShell,
    1:                      nsStyleSet*  aStyleSet)
    1: {
    1:   if (!aPresShell) {
    1:     NS_ERROR("null pres shell");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (!aStyleSet) {
    1:     NS_ERROR("null style set");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mPresShell = aPresShell;
    1:   mStyleSet = aStyleSet;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManager::Destroy()
    1: {
    1:   NS_ASSERTION(mPresShell, "Frame manager already shut down.");
    1: 
    1:   // Destroy the frame hierarchy.
    1:   mPresShell->SetIgnoreFrameDestruction(PR_TRUE);
    1: 
20348:   mIsDestroying = PR_TRUE;  // This flag prevents GetPrimaryFrameFor from returning pointers to destroyed frames
    1: 
    1:   // Unregister all placeholders before tearing down the frame tree
    1:   nsFrameManager::ClearPlaceholderFrameMap();
    1: 
    1:   if (mRootFrame) {
    1:     mRootFrame->Destroy();
    1:     mRootFrame = nsnull;
    1:   }
    1:   
    1:   nsFrameManager::ClearPrimaryFrameMap();
    1:   delete mUndisplayedMap;
    1:   mUndisplayedMap = nsnull;
    1: 
    1:   mPresShell = nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: nsFrameManager::GetCanvasFrame()
    1: {
    1:   if (mRootFrame) {
    1:     // walk the children of the root frame looking for a frame with type==canvas
    1:     // start at the root
    1:     nsIFrame* childFrame = mRootFrame;
    1:     while (childFrame) {
    1:       // get each sibling of the child and check them, startig at the child
    1:       nsIFrame *siblingFrame = childFrame;
    1:       while (siblingFrame) {
    1:         if (siblingFrame->GetType() == nsGkAtoms::canvasFrame) {
    1:           // this is it
    1:           return siblingFrame;
    1:         } else {
    1:           siblingFrame = siblingFrame->GetNextSibling();
    1:         }
    1:       }
    1:       // move on to the child's child
    1:       childFrame = childFrame->GetFirstChild(nsnull);
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Primary frame functions
    1: nsIFrame*
    1: nsFrameManager::GetPrimaryFrameFor(nsIContent* aContent,
    1:                                    PRInt32 aIndexHint)
    1: {
20348:   NS_ASSERTION(!mIsDestroyingFrames,
20348:                "GetPrimaryFrameFor() called while frames are being destroyed!");
    1:   NS_ENSURE_TRUE(aContent, nsnull);
    1: 
20348:   if (mIsDestroying) {
20348:     NS_ERROR("GetPrimaryFrameFor() called while nsFrameManager is being destroyed!");
    1:     return nsnull;
    1:   }
    1: 
    1:   if (!aContent->MayHaveFrame()) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (mPrimaryFrameMap.ops) {
 3233:     PrimaryFrameMapEntry *entry = static_cast<PrimaryFrameMapEntry*>
 3233:                                              (PL_DHashTableOperate(&mPrimaryFrameMap, aContent, PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:       return entry->frame;
    1:     }
    1: 
    1:     // XXX: todo:  Add a lookup into the undisplay map to skip searches 
    1:     //             if we already know the content has no frame.
    1:     //             nsCSSFrameConstructor calls SetUndisplayedContent() for every
    1:     //             content node that has display: none.
    1:     //             Today, the undisplay map doesn't quite support what we need.
    1:     //             We need to see if we can add a method to make a search for aContent 
    1:     //             very fast in the embedded hash table.
    1:     //             This would almost completely remove the lookup penalty for things
    1:     //             like <SCRIPT> and comments in very large documents.
    1:     // XXX with the nsIContent::MayHaveFrame bit, is that really necessary now?
    1: 
    1:     // Give the frame construction code the opportunity to return the
    1:     // frame that maps the content object
    1: 
    1:     // if the prev sibling of aContent has a cached primary frame,
    1:     // pass that data in to the style set to speed things up
    1:     // if any methods in here fail, don't report that failure
    1:     // we're just trying to enhance performance here, not test for correctness
    1:     nsFindFrameHint hint;
    1:     nsIContent* parent = aContent->GetParent();
    1:     if (parent)
    1:     {
    1:       PRInt32 index = aIndexHint >= 0 ? aIndexHint : parent->IndexOf(aContent);
    1:       if (index > 0)  // no use looking if it's the first child
    1:       {
    1:         nsIContent *prevSibling;
    1:         do {
    1:           prevSibling = parent->GetChildAt(--index);
    1:         } while (index &&
    1:                  (prevSibling->IsNodeOfType(nsINode::eTEXT) ||
    1:                   prevSibling->IsNodeOfType(nsINode::eCOMMENT) ||
    1:                   prevSibling->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)));
    1:         if (prevSibling) {
 3233:           entry = static_cast<PrimaryFrameMapEntry*>
 3233:                              (PL_DHashTableOperate(&mPrimaryFrameMap, prevSibling,
    1:                                                PL_DHASH_LOOKUP));
    1:           if (PL_DHASH_ENTRY_IS_BUSY(entry))
    1:             hint.mPrimaryFrameForPrevSibling = entry->frame;
    1:         }
    1:       }
    1:     }
    1: 
    1:     // walk the frame tree to find the frame that maps aContent.  
    1:     // Use the hint if we have it.
    1:     nsIFrame *result;
    1: 
    1:     mPresShell->FrameConstructor()->
    1:       FindPrimaryFrameFor(this, aContent, &result, 
    1:                           hint.mPrimaryFrameForPrevSibling ? &hint : nsnull);
    1: 
    1:     return result;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsFrameManager::SetPrimaryFrameFor(nsIContent* aContent,
    1:                                    nsIFrame*   aPrimaryFrame)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aContent);
    1:   NS_ASSERTION(aPrimaryFrame && aPrimaryFrame->GetParent(),
    1:                "BOGUS!");
    1: 
    1:   // This code should be used if/when we switch back to a 2-word entry
    1:   // in the primary frame map.
    1: #if 0
    1:   NS_PRECONDITION(aPrimaryFrame->GetContent() == aContent, "wrong content");
    1: #endif
    1: 
    1:   // Create a new hashtable if necessary
    1:   if (!mPrimaryFrameMap.ops) {
    1:     if (!PL_DHashTableInit(&mPrimaryFrameMap, PL_DHashGetStubOps(), nsnull,
    1:                            sizeof(PrimaryFrameMapEntry), 16)) {
    1:       mPrimaryFrameMap.ops = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   // Add a mapping to the hash table
 3233:   PrimaryFrameMapEntry *entry = static_cast<PrimaryFrameMapEntry*>
 3233:                                            (PL_DHashTableOperate(&mPrimaryFrameMap, aContent, PL_DHASH_ADD));
    1: #ifdef DEBUG_dbaron
    1:   if (entry->frame) {
    1:     NS_WARNING("already have primary frame for content");
    1:   }
    1: #endif
    1:   entry->frame = aPrimaryFrame;
    1:   entry->content = aContent;
    1:     
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManager::RemoveAsPrimaryFrame(nsIContent* aContent,
    1:                                      nsIFrame* aPrimaryFrame)
    1: {
    1:   NS_PRECONDITION(aPrimaryFrame, "Must have a frame");
    1:   if (aContent && mPrimaryFrameMap.ops) {
 3233:     PrimaryFrameMapEntry *entry = static_cast<PrimaryFrameMapEntry*>
 3233:                                              (PL_DHashTableOperate(&mPrimaryFrameMap, aContent, PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry) && entry->frame == aPrimaryFrame) {
    1:       // Don't use PL_DHashTableRawRemove, since we want the table to
    1:       // shrink as needed.
    1:       PL_DHashTableOperate(&mPrimaryFrameMap, aContent, PL_DHASH_REMOVE);
    1:     }
    1:   }
    1: 
    1:   aPrimaryFrame->RemovedAsPrimaryFrame();
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearPrimaryFrameMap()
    1: {
    1:   if (mPrimaryFrameMap.ops) {
    1:     PL_DHashTableFinish(&mPrimaryFrameMap);
    1:     mPrimaryFrameMap.ops = nsnull;
    1:   }
    1: }
    1: 
    1: // Placeholder frame functions
    1: nsPlaceholderFrame*
    1: nsFrameManager::GetPlaceholderFrameFor(nsIFrame*  aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "null param unexpected");
    1: 
    1:   if (mPlaceholderMap.ops) {
 3233:     PlaceholderMapEntry *entry = static_cast<PlaceholderMapEntry*>
 3233:                                             (PL_DHashTableOperate(const_cast<PLDHashTable*>(&mPlaceholderMap),
    1:                                 aFrame, PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:       return entry->placeholderFrame;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsFrameManager::RegisterPlaceholderFrame(nsPlaceholderFrame* aPlaceholderFrame)
    1: {
    1:   NS_PRECONDITION(aPlaceholderFrame, "null param unexpected");
    1:   NS_PRECONDITION(nsGkAtoms::placeholderFrame == aPlaceholderFrame->GetType(),
    1:                   "unexpected frame type");
    1:   if (!mPlaceholderMap.ops) {
    1:     if (!PL_DHashTableInit(&mPlaceholderMap, &PlaceholderMapOps, nsnull,
    1:                            sizeof(PlaceholderMapEntry), 16)) {
    1:       mPlaceholderMap.ops = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
 3233:   PlaceholderMapEntry *entry = static_cast<PlaceholderMapEntry*>(PL_DHashTableOperate(&mPlaceholderMap,
    1:                               aPlaceholderFrame->GetOutOfFlowFrame(),
    1:                               PL_DHASH_ADD));
    1:   if (!entry)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ASSERTION(!entry->placeholderFrame, "Registering a placeholder for a frame that already has a placeholder!");
    1:   entry->placeholderFrame = aPlaceholderFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManager::UnregisterPlaceholderFrame(nsPlaceholderFrame* aPlaceholderFrame)
    1: {
    1:   NS_PRECONDITION(aPlaceholderFrame, "null param unexpected");
    1:   NS_PRECONDITION(nsGkAtoms::placeholderFrame == aPlaceholderFrame->GetType(),
    1:                   "unexpected frame type");
    1: 
    1:   if (mPlaceholderMap.ops) {
    1:     PL_DHashTableOperate(&mPlaceholderMap,
    1:                          aPlaceholderFrame->GetOutOfFlowFrame(),
    1:                          PL_DHASH_REMOVE);
    1:   }
    1: }
    1: 
20261: static PLDHashOperator
    1: UnregisterPlaceholders(PLDHashTable* table, PLDHashEntryHdr* hdr,
    1:                        PRUint32 number, void* arg)
    1: {
 3233:   PlaceholderMapEntry* entry = static_cast<PlaceholderMapEntry*>(hdr);
    1:   entry->placeholderFrame->SetOutOfFlowFrame(nsnull);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearPlaceholderFrameMap()
    1: {
    1:   if (mPlaceholderMap.ops) {
    1:     PL_DHashTableEnumerate(&mPlaceholderMap, UnregisterPlaceholders, nsnull);
    1:     PL_DHashTableFinish(&mPlaceholderMap);
    1:     mPlaceholderMap.ops = nsnull;
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsStyleContext*
    1: nsFrameManager::GetUndisplayedContent(nsIContent* aContent)
    1: {
    1:   if (!aContent || !mUndisplayedMap)
    1:     return nsnull;
    1: 
    1:   nsIContent* parent = aContent->GetParent();
    1:   if (!parent)
    1:     return nsnull;
    1: 
    1:   for (UndisplayedNode* node = mUndisplayedMap->GetFirstNode(parent);
    1:          node; node = node->mNext) {
    1:     if (node->mContent == aContent)
    1:       return node->mStyle;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1:   
    1: void
    1: nsFrameManager::SetUndisplayedContent(nsIContent* aContent, 
    1:                                       nsStyleContext* aStyleContext)
    1: {
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("SetUndisplayedContent(%d): p=%p \n", i++, (void *)aContent);
    1: #endif
    1: 
    1:   NS_ASSERTION(!GetUndisplayedContent(aContent),
    1:                "Already have an undisplayed context entry for aContent");
    1: 
    1:   if (! mUndisplayedMap) {
    1:     mUndisplayedMap = new UndisplayedMap;
    1:   }
    1:   if (mUndisplayedMap) {
    1:     nsIContent* parent = aContent->GetParent();
    1:     NS_ASSERTION(parent, "undisplayed content must have a parent");
    1:     if (parent) {
    1:       mUndisplayedMap->AddNodeFor(parent, aContent, aStyleContext);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::ChangeUndisplayedContent(nsIContent* aContent, 
    1:                                          nsStyleContext* aStyleContext)
    1: {
    1:   NS_ASSERTION(mUndisplayedMap, "no existing undisplayed content");
    1:   
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:    static int i = 0;
    1:    printf("ChangeUndisplayedContent(%d): p=%p \n", i++, (void *)aContent);
    1: #endif
    1: 
    1:   for (UndisplayedNode* node = mUndisplayedMap->GetFirstNode(aContent->GetParent());
    1:          node; node = node->mNext) {
    1:     if (node->mContent == aContent) {
    1:       node->mStyle = aStyleContext;
    1:       return;
    1:     }
    1:   }
    1: 
    1:   NS_NOTREACHED("no existing undisplayed content");
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearUndisplayedContentIn(nsIContent* aContent,
    1:                                           nsIContent* aParentContent)
    1: {
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("ClearUndisplayedContent(%d): content=%p parent=%p --> ", i++, (void *)aContent, (void*)aParentContent);
    1: #endif
    1:   
    1:   if (mUndisplayedMap) {
    1:     UndisplayedNode* node = mUndisplayedMap->GetFirstNode(aParentContent);
    1:     while (node) {
    1:       if (node->mContent == aContent) {
    1:         mUndisplayedMap->RemoveNodeFor(aParentContent, node);
    1: 
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:         printf( "REMOVED!\n");
    1: #endif
    1: #ifdef DEBUG
    1:         // make sure that there are no more entries for the same content
    1:         nsStyleContext *context = GetUndisplayedContent(aContent);
    1:         NS_ASSERTION(context == nsnull, "Found more undisplayed content data after removal");
    1: #endif
    1:         return;
    1:       }
    1:       node = node->mNext;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearAllUndisplayedContentIn(nsIContent* aParentContent)
    1: {
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("ClearAllUndisplayedContentIn(%d): parent=%p \n", i++, (void*)aParentContent);
    1: #endif
    1: 
    1:   if (mUndisplayedMap) {
    1:     mUndisplayedMap->RemoveNodesFor(aParentContent);
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::ClearUndisplayedContentMap()
    1: {
    1: #ifdef DEBUG_UNDISPLAYED_MAP
    1:   static int i = 0;
    1:   printf("ClearUndisplayedContentMap(%d)\n", i++);
    1: #endif
    1: 
    1:   if (mUndisplayedMap) {
    1:     mUndisplayedMap->Clear();
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsFrameManager::InsertFrames(nsIFrame*       aParentFrame,
    1:                              nsIAtom*        aListName,
    1:                              nsIFrame*       aPrevFrame,
    1:                              nsIFrame*       aFrameList)
    1: {
 7863:   NS_PRECONDITION(!aPrevFrame || (!aPrevFrame->GetNextContinuation()
 7863:                   || IS_TRUE_OVERFLOW_CONTAINER(aPrevFrame->GetNextContinuation()))
 7863:                   && !IS_TRUE_OVERFLOW_CONTAINER(aPrevFrame),
    1:                   "aPrevFrame must be the last continuation in its chain!");
    1: 
    1:   return aParentFrame->InsertFrames(aListName, aPrevFrame, aFrameList);
    1: }
    1: 
    1: nsresult
    1: nsFrameManager::RemoveFrame(nsIFrame*       aParentFrame,
    1:                             nsIAtom*        aListName,
    1:                             nsIFrame*       aOldFrame)
    1: {
20348:   PRBool wasDestroyingFrames = mIsDestroyingFrames;
20348:   mIsDestroyingFrames = PR_TRUE;
22726: 
    1:   // In case the reflow doesn't invalidate anything since it just leaves
    1:   // a gap where the old frame was, we invalidate it here.  (This is
    1:   // reasonably likely to happen when removing a last child in a way
    1:   // that doesn't change the size of the parent.)
    1:   // This has to sure to invalidate the entire overflow rect; this
    1:   // is important in the presence of absolute positioning
    1:   aOldFrame->Invalidate(aOldFrame->GetOverflowRect());
    1: 
20348:   nsresult rv = aParentFrame->RemoveFrame(aListName, aOldFrame);
22726: 
20348:   mIsDestroyingFrames = wasDestroyingFrames;
22726: 
20348:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: void
    1: nsFrameManager::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
    1:   // We've already removed from the primary frame map once, but we're
    1:   // going to try to do it again here to fix callers of GetPrimaryFrameFor
    1:   // during frame destruction, since this problem keeps coming back to
    1:   // bite us.  We may want to remove the previous caller.
    1:   if (mPrimaryFrameMap.ops) {
 3233:     PrimaryFrameMapEntry *entry = static_cast<PrimaryFrameMapEntry*>
 3233:                                              (PL_DHashTableOperate(&mPrimaryFrameMap, aFrame->GetContent(), PL_DHASH_LOOKUP));
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry) && entry->frame == aFrame) {
    1:       NS_NOTREACHED("frame was not removed from primary frame map before "
    1:                     "destruction or was readded to map after being removed");
    1:       PL_DHashTableRawRemove(&mPrimaryFrameMap, entry);
    1:     }
    1:   }
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: static void
    1: DumpContext(nsIFrame* aFrame, nsStyleContext* aContext)
    1: {
    1:   if (aFrame) {
    1:     fputs("frame: ", stdout);
    1:     nsAutoString  name;
    1:     nsIFrameDebug*  frameDebug;
    1: 
    1:     if (NS_SUCCEEDED(aFrame->QueryInterface(NS_GET_IID(nsIFrameDebug), (void**)&frameDebug))) {
    1:       frameDebug->GetFrameName(name);
    1:       fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
    1:     }
 3233:     fprintf(stdout, " (%p)", static_cast<void*>(aFrame));
    1:   }
    1:   if (aContext) {
 3233:     fprintf(stdout, " style: %p ", static_cast<void*>(aContext));
    1: 
    1:     nsIAtom* pseudoTag = aContext->GetPseudoType();
    1:     if (pseudoTag) {
    1:       nsAutoString  buffer;
    1:       pseudoTag->ToString(buffer);
    1:       fputs(NS_LossyConvertUTF16toASCII(buffer).get(), stdout);
    1:       fputs(" ", stdout);
    1:     }
    1: 
    1: /* XXXdwh fix debugging here.  Need to add a List method to nsRuleNode
    1:    and have the context call list on its rule node.
    1:     PRInt32 count = aContext->GetStyleRuleCount();
    1:     if (0 < count) {
    1:       fputs("{\n", stdout);
    1:       nsISupportsArray* rules = aContext->GetStyleRules();
    1:       PRInt32 ix;
    1:       for (ix = 0; ix < count; ix++) {
    1:         nsIStyleRule* rule = (nsIStyleRule*)rules->ElementAt(ix);
    1:         rule->List(stdout, 1);
    1:         NS_RELEASE(rule);
    1:       }
    1:       NS_RELEASE(rules);
    1:       fputs("}\n", stdout);
    1:     }
    1:     else 
    1:     */
    1:     {
    1:       fputs("{}\n", stdout);
    1:     }
    1:   }
    1: }
    1: 
    1: static void
    1: VerifySameTree(nsStyleContext* aContext1, nsStyleContext* aContext2)
    1: {
    1:   nsStyleContext* top1 = aContext1;
    1:   nsStyleContext* top2 = aContext2;
    1:   nsStyleContext* parent;
    1:   for (;;) {
    1:     parent = top1->GetParent();
    1:     if (!parent)
    1:       break;
    1:     top1 = parent;
    1:   }
    1:   for (;;) {
    1:     parent = top2->GetParent();
    1:     if (!parent)
    1:       break;
    1:     top2 = parent;
    1:   }
 6739:   NS_ASSERTION(top1 == top2,
 6739:                "Style contexts are not in the same style context tree");
    1: }
    1: 
    1: static void
    1: VerifyContextParent(nsPresContext* aPresContext, nsIFrame* aFrame, 
    1:                     nsStyleContext* aContext, nsStyleContext* aParentContext)
    1: {
    1:   // get the contexts not provided
    1:   if (!aContext) {
    1:     aContext = aFrame->GetStyleContext();
    1:   }
    1: 
    1:   if (!aParentContext) {
    1:     // Get the correct parent context from the frame
    1:     //  - if the frame is a placeholder, we get the out of flow frame's context 
    1:     //    as the parent context instead of asking the frame
    1: 
    1:     // get the parent context from the frame (indirectly)
    1:     nsIFrame* providerFrame = nsnull;
    1:     PRBool providerIsChild;
    1:     aFrame->GetParentStyleContextFrame(aPresContext,
    1:                                        &providerFrame, &providerIsChild);
    1:     if (providerFrame)
    1:       aParentContext = providerFrame->GetStyleContext();
    1:     // aParentContext could still be null
    1:   }
    1: 
    1:   NS_ASSERTION(aContext, "Failure to get required contexts");
    1:   nsStyleContext* actualParentContext = aContext->GetParent();
    1: 
    1:   if (aParentContext) {
    1:     if (aParentContext != actualParentContext) {
    1:       DumpContext(aFrame, aContext);
    1:       if (aContext == aParentContext) {
 6739:         NS_ERROR("Using parent's style context");
    1:       }
    1:       else {
 6739:         NS_ERROR("Wrong parent style context");
    1:         fputs("Wrong parent style context: ", stdout);
    1:         DumpContext(nsnull, actualParentContext);
    1:         fputs("should be using: ", stdout);
    1:         DumpContext(nsnull, aParentContext);
    1:         VerifySameTree(actualParentContext, aParentContext);
    1:         fputs("\n", stdout);
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     if (actualParentContext) {
 6739:       NS_ERROR("Have parent context and shouldn't");
    1:       DumpContext(aFrame, aContext);
    1:       fputs("Has parent context: ", stdout);
    1:       DumpContext(nsnull, actualParentContext);
    1:       fputs("Should be null\n\n", stdout);
    1:     }
    1:   }
    1: }
    1: 
    1: static void
    1: VerifyStyleTree(nsPresContext* aPresContext, nsIFrame* aFrame,
    1:                 nsStyleContext* aParentContext)
    1: {
    1:   nsStyleContext*  context = aFrame->GetStyleContext();
    1:   VerifyContextParent(aPresContext, aFrame, context, nsnull);
    1: 
    1:   PRInt32 listIndex = 0;
    1:   nsIAtom* childList = nsnull;
    1:   nsIFrame* child;
    1: 
    1:   do {
    1:     child = aFrame->GetFirstChild(childList);
    1:     while (child) {
 6521:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 6521:           || (child->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 7656:         // only do frames that don't have placeholders
    1:         if (nsGkAtoms::placeholderFrame == child->GetType()) { 
    1:           // placeholder: first recurse and verify the out of flow frame,
    1:           // then verify the placeholder's context
    1:           nsIFrame* outOfFlowFrame =
    1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1: 
    1:           // recurse to out of flow frame, letting the parent context get resolved
    1:           VerifyStyleTree(aPresContext, outOfFlowFrame, nsnull);
    1: 
    1:           // verify placeholder using the parent frame's context as
    1:           // parent context
    1:           VerifyContextParent(aPresContext, child, nsnull, nsnull);
    1:         }
    1:         else { // regular frame
    1:           VerifyStyleTree(aPresContext, child, nsnull);
    1:         }
    1:       }
    1:       child = child->GetNextSibling();
    1:     }
    1: 
    1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:   } while (childList);
    1:   
    1:   // do additional contexts 
    1:   PRInt32 contextIndex = -1;
    1:   while (1) {
    1:     nsStyleContext* extraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
    1:     if (extraContext) {
    1:       VerifyContextParent(aPresContext, aFrame, extraContext, context);
    1:     }
    1:     else {
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::DebugVerifyStyleTree(nsIFrame* aFrame)
    1: {
    1:   if (aFrame) {
    1:     nsStyleContext* context = aFrame->GetStyleContext();
    1:     nsStyleContext* parentContext = context->GetParent();
    1:     VerifyStyleTree(GetPresContext(), aFrame, parentContext);
    1:   }
    1: }
    1: 
    1: #endif // DEBUG
    1: 
    1: nsresult
    1: nsFrameManager::ReParentStyleContext(nsIFrame* aFrame)
    1: {
 7656:   if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
 7656:     // Also reparent the out-of-flow
 7656:     nsIFrame* outOfFlow =
 7656:       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
 7656:     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
 7656: 
 7656:     ReParentStyleContext(outOfFlow);
 7656:   }
 7656: 
    1:   // DO NOT verify the style tree before reparenting.  The frame
    1:   // tree has already been changed, so this check would just fail.
    1:   nsStyleContext* oldContext = aFrame->GetStyleContext();
    1:   // XXXbz can oldContext really ever be null?
    1:   if (oldContext) {
    1:     nsPresContext *presContext = GetPresContext();
    1:     nsRefPtr<nsStyleContext> newContext;
    1:     nsIFrame* providerFrame = nsnull;
    1:     PRBool providerIsChild = PR_FALSE;
    1:     nsIFrame* providerChild = nsnull;
    1:     aFrame->GetParentStyleContextFrame(presContext, &providerFrame,
    1:                                        &providerIsChild);
    1:     nsStyleContext* newParentContext = nsnull;
    1:     if (providerIsChild) {
    1:       ReParentStyleContext(providerFrame);
    1:       newParentContext = providerFrame->GetStyleContext();
    1:       providerChild = providerFrame;
    1:     } else if (providerFrame) {
    1:       newParentContext = providerFrame->GetStyleContext();
    1:     } else {
    1:       NS_NOTREACHED("Reparenting something that has no usable parent? "
    1:                     "Shouldn't happen!");
    1:     }
    1:     // XXX need to do something here to produce the correct style context
    1:     // for an IB split whose first inline part is inside a first-line frame.
    1:     // Currently the IB anonymous block's style context takes the first part's
    1:     // style context as parent, which is wrong since first-line style should
    1:     // not apply to the anonymous block.
    1: 
    1:     newContext = mStyleSet->ReParentStyleContext(presContext, oldContext,
    1:                                                  newParentContext);
    1:     if (newContext) {
    1:       if (newContext != oldContext) {
 7656:         // Make sure to call CalcStyleDifference so that the new context ends
 7656:         // up resolving all the structs the old context resolved.
 7656:         nsChangeHint styleChange = oldContext->CalcStyleDifference(newContext);
 7656:         // The style change is always 0 because we have the same rulenode and
 7656:         // CalcStyleDifference optimizes us away.  That's OK, though:
 7656:         // reparenting should never trigger a frame reconstruct, and whenever
 7656:         // it's happening we already plan to reflow and repaint the frames.
 7656:         NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
 7656:                      "Our frame tree is likely to be bogus!");
 7656:         
    1:         PRInt32 listIndex = 0;
    1:         nsIAtom* childList = nsnull;
    1:         nsIFrame* child;
    1:           
    1:         aFrame->SetStyleContext(newContext);
    1: 
    1:         do {
    1:           child = aFrame->GetFirstChild(childList);
    1:           while (child) {
 7656:             // only do frames that don't have placeholders
 7656:             if ((!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW) ||
 7656:                  (child->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) &&
 7656:                 child != providerChild) {
 7656: #ifdef DEBUG
    1:               if (nsGkAtoms::placeholderFrame == child->GetType()) {
    1:                 nsIFrame* outOfFlowFrame =
    1:                   nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1:                 NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
    1: 
    1:                 NS_ASSERTION(outOfFlowFrame != providerChild,
    1:                              "Out of flow provider?");
 7656:               }
 7656: #endif
    1: 
    1:               ReParentStyleContext(child);
    1:             }
    1: 
    1:             child = child->GetNextSibling();
    1:           }
    1: 
    1:           childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:         } while (childList);
    1: 
    1:         // If this frame is part of an IB split, then the style context of
    1:         // the next part of the split might be a child of our style context.
    1:         // Reparent its style context just in case one of our ancestors
    1:         // (split or not) hasn't done so already). It's not a problem to
    1:         // reparent the same frame twice because the "if (newContext !=
    1:         // oldContext)" check will prevent us from redoing work.
    1:         if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) &&
    1:             !aFrame->GetPrevInFlow()) {
 3233:           nsIFrame* sib = static_cast<nsIFrame*>(aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling));
    1:           if (sib) {
    1:             ReParentStyleContext(sib);
    1:           }
    1:         }
    1: 
    1:         // do additional contexts 
    1:         PRInt32 contextIndex = -1;
    1:         while (1) {
    1:           nsStyleContext* oldExtraContext =
    1:             aFrame->GetAdditionalStyleContext(++contextIndex);
    1:           if (oldExtraContext) {
    1:             nsRefPtr<nsStyleContext> newExtraContext;
    1:             newExtraContext = mStyleSet->ReParentStyleContext(presContext,
    1:                                                               oldExtraContext,
    1:                                                               newContext);
    1:             if (newExtraContext) {
 7656:               if (newExtraContext != oldExtraContext) {
 7656:                 // Make sure to call CalcStyleDifference so that the new
 7656:                 // context ends up resolving all the structs the old context
 7656:                 // resolved.
 7656:                 styleChange =
 7656:                   oldExtraContext->CalcStyleDifference(newExtraContext);
 7656:                 // The style change is always 0 because we have the same
 7656:                 // rulenode and CalcStyleDifference optimizes us away.  That's
 7656:                 // OK, though: reparenting should never trigger a frame
 7656:                 // reconstruct, and whenever it's happening we already plan to
 7656:                 // reflow and repaint the frames.
 7656:                 NS_ASSERTION(!(styleChange & nsChangeHint_ReconstructFrame),
 7656:                              "Our frame tree is likely to be bogus!");
 7656:               }
 7656:               
    1:               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
    1:             }
    1:           }
    1:           else {
    1:             break;
    1:           }
    1:         }
    1: #ifdef DEBUG
    1:         VerifyStyleTree(GetPresContext(), aFrame, newParentContext);
    1: #endif
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: static nsChangeHint
    1: CaptureChange(nsStyleContext* aOldContext, nsStyleContext* aNewContext,
    1:               nsIFrame* aFrame, nsIContent* aContent,
    1:               nsStyleChangeList* aChangeList, nsChangeHint aMinChange,
    1:               nsChangeHint aChangeToAssume)
    1: {
    1:   nsChangeHint ourChange = aOldContext->CalcStyleDifference(aNewContext);
    1:   NS_UpdateHint(ourChange, aChangeToAssume);
    1:   if (NS_UpdateHint(aMinChange, ourChange)) {
    1:     aChangeList->AppendChange(aFrame, aContent, ourChange);
    1:   }
    1:   return aMinChange;
    1: }
    1: 
21023: static PRBool
21023: ShouldStopImage(imgIRequest *aOldImage, imgIRequest *aNewImage)
21023: {
21023:   if (!aOldImage)
21023:     return PR_FALSE;
21023: 
21023:   PRBool stopImages = !aNewImage;
21023:   if (!stopImages) {
21023:     nsCOMPtr<nsIURI> oldURI, newURI;
21023:     aOldImage->GetURI(getter_AddRefs(oldURI));
21023:     aNewImage->GetURI(getter_AddRefs(newURI));
21023:     PRBool equal;
21023:     stopImages =
21023:       NS_FAILED(oldURI->Equals(newURI, &equal)) || !equal;
21023:   }
21023:   return stopImages;
21023: }
21023: 
23168: /**
23168:  * Recompute style for aFrame and accumulate changes into aChangeList
23168:  * given that aMinChange is already accumulated for an ancestor.
23168:  * aParentContent is the content node used to resolve the parent style
23168:  * context.  This means that, for pseudo-elements, it is the content
23168:  * that should be used for selector matching (rather than the fake
23168:  * content node attached to the frame).
23168:  */
    1: nsChangeHint
    1: nsFrameManager::ReResolveStyleContext(nsPresContext     *aPresContext,
    1:                                       nsIFrame          *aFrame,
    1:                                       nsIContent        *aParentContent,
    1:                                       nsStyleChangeList *aChangeList, 
    1:                                       nsChangeHint       aMinChange)
    1: {
23299:   NS_ASSERTION(aFrame->GetContent() ||
23299:                (!aFrame->GetParent() && !aParentContent),
23168:                "frame must have content (unless viewport)");
    1:   // XXXldb get new context from prev-in-flow if possible, to avoid
    1:   // duplication.  (Or should we just let |GetContext| handle that?)
    1:   // Getting the hint would be nice too, but that's harder.
    1: 
    1:   // XXXbryner we may be able to avoid some of the refcounting goop here.
    1:   // We do need a reference to oldContext for the lifetime of this function, and it's possible
    1:   // that the frame has the last reference to it, so AddRef it here.
    1: 
    1:   nsChangeHint assumeDifferenceHint = NS_STYLE_HINT_NONE;
 6632:   // XXXbz oldContext should just be an nsRefPtr
    1:   nsStyleContext* oldContext = aFrame->GetStyleContext();
    1:   nsStyleSet* styleSet = aPresContext->StyleSet();
    1: #ifdef ACCESSIBILITY
20615:   PRBool isVisible = aFrame->GetStyleVisibility()->IsVisible();
    1: #endif
    1: 
 6632:   // XXXbz the nsIFrame constructor takes an nsStyleContext, so how
 6632:   // could oldContext be null?
    1:   if (oldContext) {
    1:     oldContext->AddRef();
    1:     nsIAtom* const pseudoTag = oldContext->GetPseudoType();
    1:     nsIContent* localContent = aFrame->GetContent();
23168:     // |content| is the node that we used for rule matching of
23168:     // normal elements (not pseudo-elements) and for which we generate
23168:     // framechange hints if we need them.
23168:     // XXXldb Why does it make sense to use aParentContent
    1:     nsIContent* content = localContent ? localContent : aParentContent;
    1: 
    1:     nsStyleContext* parentContext;
    1:     nsIFrame* resolvedChild = nsnull;
    1:     // Get the frame providing the parent style context.  If it is a
    1:     // child, then resolve the provider first.
    1:     nsIFrame* providerFrame = nsnull;
    1:     PRBool providerIsChild = PR_FALSE;
    1:     aFrame->GetParentStyleContextFrame(aPresContext,
    1:                                        &providerFrame, &providerIsChild); 
    1:     if (!providerIsChild) {
    1:       if (providerFrame)
    1:         parentContext = providerFrame->GetStyleContext();
    1:       else
    1:         parentContext = nsnull;
    1:     }
    1:     else {
    1:       // resolve the provider here (before aFrame below).
    1: 
    1:       // assumeDifferenceHint forces the parent's change to be also
    1:       // applied to this frame, no matter what
10152:       // nsStyleContext::CalcStyleDifference says. CalcStyleDifference
    1:       // can't be trusted because it assumes any changes to the parent
    1:       // style context provider will be automatically propagated to
    1:       // the frame(s) with child style contexts.
    1:       assumeDifferenceHint = ReResolveStyleContext(aPresContext, providerFrame,
23168:                                                    aParentContent, aChangeList,
23168:                                                    aMinChange);
    1: 
    1:       // The provider's new context becomes the parent context of
    1:       // aFrame's context.
    1:       parentContext = providerFrame->GetStyleContext();
    1:       // Set |resolvedChild| so we don't bother resolving the
    1:       // provider again.
    1:       resolvedChild = providerFrame;
    1:     }
    1:     
    1:     // do primary context
 6632:     // XXXbz newContext should just be an nsRefPtr
    1:     nsStyleContext* newContext = nsnull;
    1:     if (pseudoTag == nsCSSAnonBoxes::mozNonElement) {
    1:       NS_ASSERTION(localContent,
    1:                    "non pseudo-element frame without content node");
    1:       newContext = styleSet->ResolveStyleForNonElement(parentContext).get();
    1:     }
    1:     else if (pseudoTag) {
23162:       // XXXldb This choice of pseudoContent seems incorrect for anon
23162:       // boxes and perhaps other cases.
    1:       nsIContent* pseudoContent =
    1:           aParentContent ? aParentContent : localContent;
    1:       if (pseudoTag == nsCSSPseudoElements::before ||
    1:           pseudoTag == nsCSSPseudoElements::after) {
    1:         // XXX what other pseudos do we need to treat like this?
    1:         newContext = styleSet->ProbePseudoStyleFor(pseudoContent,
    1:                                                    pseudoTag,
    1:                                                    parentContext).get();
    1:         if (!newContext) {
    1:           // This pseudo should no longer exist; gotta reframe
    1:           NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
    1:           aChangeList->AppendChange(aFrame, pseudoContent,
    1:                                     nsChangeHint_ReconstructFrame);
    1:           // We're reframing anyway; just keep the same context
    1:           newContext = oldContext;
    1:           newContext->AddRef();
    1:         }
    1:       } else {
 7046:         if (pseudoTag == nsCSSPseudoElements::firstLetter) {
 7046:           NS_ASSERTION(aFrame->GetType() == nsGkAtoms::letterFrame, 
 7046:                        "firstLetter pseudoTag without a nsFirstLetterFrame");
 7046:           nsBlockFrame* block = nsBlockFrame::GetNearestAncestorBlock(aFrame);
 7046:           pseudoContent = block->GetContent();
23162:         } else if (pseudoTag == nsCSSAnonBoxes::pageBreak) {
23162:           pseudoContent = nsnull;
 7046:         }
    1:         newContext = styleSet->ResolvePseudoStyleFor(pseudoContent,
    1:                                                      pseudoTag,
    1:                                                      parentContext).get();
    1:       }
    1:     }
    1:     else {
    1:       NS_ASSERTION(localContent,
    1:                    "non pseudo-element frame without content node");
    1:       newContext = styleSet->ResolveStyleFor(content, parentContext).get();
    1:     }
    1:     NS_ASSERTION(newContext, "failed to get new style context");
    1:     if (newContext) {
    1:       if (!parentContext) {
    1:         if (oldContext->GetRuleNode() == newContext->GetRuleNode()) {
    1:           // We're the root of the style context tree and the new style
    1:           // context returned has the same rule node.  This means that
    1:           // we can use FindChildWithRules to keep a lot of the old
    1:           // style contexts around.  However, we need to start from the
    1:           // same root.
    1:           newContext->Release();
    1:           newContext = oldContext;
    1:           newContext->AddRef();
    1:         }
    1:       }
    1: 
    1:       if (newContext != oldContext) {
    1:         aMinChange = CaptureChange(oldContext, newContext, aFrame,
    1:                                    content, aChangeList, aMinChange,
    1:                                    assumeDifferenceHint);
    1:         if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:           // if frame gets regenerated, let it keep old context
    1:           aFrame->SetStyleContext(newContext);
    1:         }
21023:         // if old context had image and new context does not have the same image, 
21023:         // stop the image load for the frame
21023:         if (ShouldStopImage(
21023:               oldContext->GetStyleBackground()->mBackgroundImage,
21023:               newContext->GetStyleBackground()->mBackgroundImage)) {
21023:           // stop the image loading for the frame, the image has changed
21023:           aPresContext->StopBackgroundImageFor(aFrame);
21023:         }
21023: 
21023:         imgIRequest *newBorderImage =
21023:           newContext->GetStyleBorder()->GetBorderImage();
21023:         if (ShouldStopImage(oldContext->GetStyleBorder()->GetBorderImage(),
21023:                             newBorderImage)) {
21023:           // stop the image loading for the frame, the image has changed
21023:           aPresContext->StopBorderImageFor(aFrame);
21023:         }
21023: 
21023:         // Since the CalcDifference call depended on the result of
21023:         // GetActualBorder() and that result depends on whether the
21023:         // image has loaded, start the image load now so that we'll get
21023:         // notified when it completes loading and can do a restyle.
21023:         // Otherwise, the image might finish loading from the network
21023:         // before we start listening to its notifications, and then
21023:         // we'll never know that it's finished loading.
21023:         if (newBorderImage) {
21023:           aPresContext->LoadBorderImage(newBorderImage, aFrame);
21023:         }
    1:       }
    1:       oldContext->Release();
    1:     }
    1:     else {
    1:       NS_ERROR("resolve style context failed");
    1:       newContext = oldContext;  // new context failed, recover... (take ref)
    1:       oldContext = nsnull;
    1:     }
    1: 
    1:     // do additional contexts 
    1:     PRInt32 contextIndex = -1;
    1:     while (1 == 1) {
    1:       nsStyleContext* oldExtraContext = nsnull;
    1:       oldExtraContext = aFrame->GetAdditionalStyleContext(++contextIndex);
    1:       if (oldExtraContext) {
    1:         nsStyleContext* newExtraContext = nsnull;
    1:         nsIAtom* const extraPseudoTag = oldExtraContext->GetPseudoType();
    1:         NS_ASSERTION(extraPseudoTag &&
    1:                      extraPseudoTag != nsCSSAnonBoxes::mozNonElement,
    1:                      "extra style context is not pseudo element");
    1:         newExtraContext = styleSet->ResolvePseudoStyleFor(content,
    1:                                                           extraPseudoTag,
    1:                                                           newContext).get();
    1:         if (newExtraContext) {
    1:           if (oldExtraContext != newExtraContext) {
    1:             aMinChange = CaptureChange(oldExtraContext, newExtraContext,
    1:                                        aFrame, content, aChangeList,
    1:                                        aMinChange, assumeDifferenceHint);
    1:             if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:               aFrame->SetAdditionalStyleContext(contextIndex, newExtraContext);
    1:             }
    1:           }
    1:           newExtraContext->Release();
    1:         }
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1: 
    1:     // now look for undisplayed child content and pseudos
 6632:     if (!pseudoTag && localContent && mUndisplayedMap) {
    1:       for (UndisplayedNode* undisplayed =
    1:                                    mUndisplayedMap->GetFirstNode(localContent);
    1:            undisplayed; undisplayed = undisplayed->mNext) {
    1:         nsRefPtr<nsStyleContext> undisplayedContext;
    1:         nsIAtom* const undisplayedPseudoTag = undisplayed->mStyle->GetPseudoType();
    1:         if (!undisplayedPseudoTag) {  // child content
    1:           undisplayedContext = styleSet->ResolveStyleFor(undisplayed->mContent,
    1:                                                          newContext);
    1:         }
    1:         else if (undisplayedPseudoTag == nsCSSAnonBoxes::mozNonElement) {
    1:           undisplayedContext = styleSet->ResolveStyleForNonElement(newContext);
    1:         }
    1:         else {  // pseudo element
    1:           NS_NOTREACHED("no pseudo elements in undisplayed map");
    1:           NS_ASSERTION(undisplayedPseudoTag, "pseudo element without tag");
    1:           undisplayedContext = styleSet->ResolvePseudoStyleFor(localContent,
    1:                                                                undisplayedPseudoTag,
    1:                                                                newContext);
    1:         }
    1:         if (undisplayedContext) {
    1:           const nsStyleDisplay* display = undisplayedContext->GetStyleDisplay();
    1:           if (display->mDisplay != NS_STYLE_DISPLAY_NONE) {
    1:             aChangeList->AppendChange(nsnull,
    1:                                       undisplayed->mContent
 3233:                                       ? static_cast<nsIContent*>
 3233:                                                    (undisplayed->mContent)
    1:                                       : localContent, 
    1:                                       NS_STYLE_HINT_FRAMECHANGE);
    1:             // The node should be removed from the undisplayed map when
    1:             // we reframe it.
    1:           } else {
    1:             // update the undisplayed node with the new context
    1:             undisplayed->mStyle = undisplayedContext;
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:       // Make sure not to do this for pseudo-frames -- those can't have :before
    1:       // or :after content.  Neither can non-elements or leaf frames.
    1:       if (!pseudoTag && localContent &&
    1:           localContent->IsNodeOfType(nsINode::eELEMENT) &&
    1:           !aFrame->IsLeaf()) {
    1:         // Check for a new :before pseudo and an existing :before
    1:         // frame, but only if the frame is the first continuation.
    1:         nsIFrame* prevContinuation = aFrame->GetPrevContinuation();
    1:         if (!prevContinuation) {
    1:           // Checking for a :before frame is cheaper than getting the
    1:           // :before style context.
    1:           if (!nsLayoutUtils::GetBeforeFrame(aFrame) &&
    1:               nsLayoutUtils::HasPseudoStyle(localContent, newContext,
    1:                                             nsCSSPseudoElements::before,
    1:                                             aPresContext)) {
    1:             // Have to create the new :before frame
    1:             NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
    1:             aChangeList->AppendChange(aFrame, content,
    1:                                       nsChangeHint_ReconstructFrame);
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     
    1:     if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:       // Make sure not to do this for pseudo-frames -- those can't have :before
    1:       // or :after content.  Neither can non-elements or leaf frames.
    1:       if (!pseudoTag && localContent &&
    1:           localContent->IsNodeOfType(nsINode::eELEMENT) &&
    1:           !aFrame->IsLeaf()) {
    1:         // Check for new :after content, but only if the frame is the
    1:         // last continuation.
    1:         nsIFrame* nextContinuation = aFrame->GetNextContinuation();
    1: 
    1:         if (!nextContinuation) {
    1:           // Getting the :after frame is more expensive than getting the pseudo
    1:           // context, so get the pseudo context first.
    1:           if (nsLayoutUtils::HasPseudoStyle(localContent, newContext,
    1:                                             nsCSSPseudoElements::after,
    1:                                             aPresContext) &&
    1:               !nsLayoutUtils::GetAfterFrame(aFrame)) {
    1:             // have to create the new :after frame
    1:             NS_UpdateHint(aMinChange, nsChangeHint_ReconstructFrame);
    1:             aChangeList->AppendChange(aFrame, content,
    1:                                       nsChangeHint_ReconstructFrame);
    1:           }
    1:         }      
    1:       }
    1:     }
    1:     
    1:     if (!(aMinChange & nsChangeHint_ReconstructFrame)) {
    1:       
    1:       // There is no need to waste time crawling into a frame's children on a frame change.
    1:       // The act of reconstructing frames will force new style contexts to be resolved on all
    1:       // of this frame's descendants anyway, so we want to avoid wasting time processing
    1:       // style contexts that we're just going to throw away anyway. - dwh
    1: 
    1:       // now do children
    1:       PRInt32 listIndex = 0;
    1:       nsIAtom* childList = nsnull;
    1: 
    1:       do {
    1:         nsIFrame* child = aFrame->GetFirstChild(childList);
    1:         while (child) {
 6521:           if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 6521:               || (child->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 6521:             // only do frames that don't have placeholders
    1:             if (nsGkAtoms::placeholderFrame == child->GetType()) { // placeholder
    1:               // get out of flow frame and recur there
    1:               nsIFrame* outOfFlowFrame =
    1:                 nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
    1:               NS_ASSERTION(outOfFlowFrame, "no out-of-flow frame");
    1:               NS_ASSERTION(outOfFlowFrame != resolvedChild,
    1:                            "out-of-flow frame not a true descendant");
    1: 
    1:               // Note that the out-of-flow may not be a geometric descendant of
    1:               // the frame where we started the reresolve.  Therefore, even if
    1:               // aMinChange already includes nsChangeHint_ReflowFrame we don't
    1:               // want to pass that on to the out-of-flow reresolve, since that
    1:               // can lead to the out-of-flow not getting reflown when it should
    1:               // be (eg a reresolve starting at <body> that involves reflowing
    1:               // the <body> would miss reflowing fixed-pos nodes that also need
    1:               // reflow).  In the cases when the out-of-flow _is_ a geometric
    1:               // descendant of a frame we already have a reflow hint for,
    1:               // reflow coalescing should keep us from doing the work twice.
    1: 
    1:               // |nsFrame::GetParentStyleContextFrame| checks being out
    1:               // of flow so that this works correctly.
    1:               ReResolveStyleContext(aPresContext, outOfFlowFrame,
    1:                                     content, aChangeList,
    1:                                     NS_SubtractHint(aMinChange,
    1:                                                     nsChangeHint_ReflowFrame));
    1: 
    1:               // reresolve placeholder's context under the same parent
    1:               // as the out-of-flow frame
    1:               ReResolveStyleContext(aPresContext, child, content,
    1:                                     aChangeList, aMinChange);
    1:             }
    1:             else {  // regular child frame
    1:               if (child != resolvedChild) {
    1:                 ReResolveStyleContext(aPresContext, child, content,
    1:                                       aChangeList, aMinChange);
    1:               } else {
    1:                 NOISY_TRACE_FRAME("child frame already resolved as descendant, skipping",aFrame);
    1:               }
    1:             }
    1:           }
    1:           child = child->GetNextSibling();
    1:         }
    1: 
    1:         childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:       } while (childList);
    1:       // XXX need to do overflow frames???
    1:     }
    1: 
    1:     newContext->Release();
    1:   }
    1: 
    1: #ifdef ACCESSIBILITY
20615:   if (mPresShell->IsAccessibilityActive() &&
 4637:       aFrame->GetStyleVisibility()->IsVisible() != isVisible &&
 4637:       !aFrame->GetPrevContinuation()) { // Primary frames only
    1:     // XXX Visibility does not affect descendents with visibility set
    1:     // Work on a separate, accurate mechanism for dealing with visibility changes.
    1:     // A significant enough change occured that this part
    1:     // of the accessible tree is no longer valid.
    1:     nsCOMPtr<nsIAccessibilityService> accService = 
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
20615:       PRUint32 event = isVisible ?
20615:         PRUint32(nsIAccessibleEvent::EVENT_ASYNCH_HIDE) :
20615:         PRUint32(nsIAccessibleEvent::EVENT_ASYNCH_SHOW);
20615:       accService->InvalidateSubtreeFor(mPresShell, aFrame->GetContent(), event);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return aMinChange;
    1: }
    1: 
11409: void
    1: nsFrameManager::ComputeStyleChangeFor(nsIFrame          *aFrame, 
    1:                                       nsStyleChangeList *aChangeList,
    1:                                       nsChangeHint       aMinChange)
    1: {
11409:   if (aMinChange) {
11409:     aChangeList->AppendChange(aFrame, aFrame->GetContent(), aMinChange);
11409:   }
11409: 
    1:   nsChangeHint topLevelChange = aMinChange;
    1: 
    1:   nsIFrame* frame = aFrame;
    1:   nsIFrame* frame2 = aFrame;
    1: 
    1:   NS_ASSERTION(!frame->GetPrevContinuation(), "must start with the first in flow");
    1: 
    1:   // We want to start with this frame and walk all its next-in-flows,
    1:   // as well as all its special siblings and their next-in-flows,
    1:   // reresolving style on all the frames we encounter in this walk.
    1: 
    1:   nsPropertyTable *propTable = GetPresContext()->PropertyTable();
    1: 
    1:   do {
    1:     // Outer loop over special siblings
    1:     do {
    1:       // Inner loop over next-in-flows of the current frame
    1:       nsChangeHint frameChange =
    1:         ReResolveStyleContext(GetPresContext(), frame, nsnull,
    1:                               aChangeList, topLevelChange);
    1:       NS_UpdateHint(topLevelChange, frameChange);
    1: 
    1:       if (topLevelChange & nsChangeHint_ReconstructFrame) {
    1:         // If it's going to cause a framechange, then don't bother
    1:         // with the continuations or special siblings since they'll be
    1:         // clobbered by the frame reconstruct anyway.
    1:         NS_ASSERTION(!frame->GetPrevContinuation(),
    1:                      "continuing frame had more severe impact than first-in-flow");
11409:         return;
    1:       }
    1: 
    1:       frame = frame->GetNextContinuation();
    1:     } while (frame);
    1: 
    1:     // Might we have special siblings?
    1:     if (!(frame2->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
    1:       // nothing more to do here
11409:       return;
    1:     }
    1:     
 3233:     frame2 = static_cast<nsIFrame*>
 3233:                         (propTable->GetProperty(frame2, nsGkAtoms::IBSplitSpecialSibling));
    1:     frame = frame2;
    1:   } while (frame2);
    1: }
    1: 
    1: 
    1: nsReStyleHint
    1: nsFrameManager::HasAttributeDependentStyle(nsIContent *aContent,
    1:                                            nsIAtom *aAttribute,
 3410:                                            PRInt32 aModType,
 3410:                                            PRUint32 aStateMask)
    1: {
    1:   nsReStyleHint hint = mStyleSet->HasAttributeDependentStyle(GetPresContext(),
    1:                                                              aContent,
    1:                                                              aAttribute,
 3410:                                                              aModType,
 3410:                                                              aStateMask);
    1: 
    1:   if (aAttribute == nsGkAtoms::style) {
    1:     // Perhaps should check that it's XUL, SVG, (or HTML) namespace, but
    1:     // it doesn't really matter.  Or we could even let
    1:     // HTMLCSSStyleSheetImpl::HasAttributeDependentStyle handle it.
    1:     hint = nsReStyleHint(hint | eReStyle_Self);
    1:   }
    1: 
    1:   return hint;
    1: }
    1: 
    1: // Capture state for a given frame.
    1: // Accept a content id here, in some cases we may not have content (scroll position)
    1: void
    1: nsFrameManager::CaptureFrameStateFor(nsIFrame* aFrame,
    1:                                      nsILayoutHistoryState* aState,
    1:                                      nsIStatefulFrame::SpecialStateID aID)
    1: {
    1:   if (!aFrame || !aState) {
    1:     NS_WARNING("null frame, or state");
    1:     return;
    1:   }
    1: 
    1:   // Only capture state for stateful frames
    1:   nsIStatefulFrame* statefulFrame;
    1:   CallQueryInterface(aFrame, &statefulFrame);
    1: 
    1:   if (!statefulFrame) {
    1:     return;
    1:   }
    1: 
    1:   // Capture the state, exit early if we get null (nothing to save)
    1:   nsAutoPtr<nsPresState> frameState;
    1:   nsresult rv = statefulFrame->SaveState(aID, getter_Transfers(frameState));
    1:   if (!frameState) {
    1:     return;
    1:   }
    1: 
    1:   // Generate the hash key to store the state under
    1:   // Exit early if we get empty key
    1:   nsCAutoString stateKey;
    1:   nsIContent* content = aFrame->GetContent();
    1:   nsIDocument* doc = content ? content->GetCurrentDoc() : nsnull;
    1:   rv = nsContentUtils::GenerateStateKey(content, doc, aID, stateKey);
    1:   if(NS_FAILED(rv) || stateKey.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Store the state
    1:   rv = aState->AddState(stateKey, frameState);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // aState owns frameState now.
    1:     frameState.forget();
    1:   }
    1: }
    1: 
    1: void
    1: nsFrameManager::CaptureFrameState(nsIFrame* aFrame,
    1:                                   nsILayoutHistoryState* aState)
    1: {
    1:   NS_PRECONDITION(nsnull != aFrame && nsnull != aState, "null parameters passed in");
    1: 
    1:   CaptureFrameStateFor(aFrame, aState);
    1: 
    1:   // Now capture state recursively for the frame hierarchy rooted at aFrame
    1:   nsIAtom*  childListName = nsnull;
    1:   PRInt32   childListIndex = 0;
    1:   do {    
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
    1:     while (childFrame) {             
    1:       CaptureFrameState(childFrame, aState);
    1:       // Get the next sibling child frame
    1:       childFrame = childFrame->GetNextSibling();
    1:     }
    1:     childListName = aFrame->GetAdditionalChildListName(childListIndex++);
    1:   } while (childListName);
    1: }
    1: 
    1: // Restore state for a given frame.
    1: // Accept a content id here, in some cases we may not have content (scroll position)
    1: void
    1: nsFrameManager::RestoreFrameStateFor(nsIFrame* aFrame,
    1:                                      nsILayoutHistoryState* aState,
    1:                                      nsIStatefulFrame::SpecialStateID aID)
    1: {
    1:   if (!aFrame || !aState) {
    1:     NS_WARNING("null frame or state");
    1:     return;
    1:   }
    1: 
22262:   // Only restore state for stateful frames
    1:   nsIStatefulFrame* statefulFrame;
    1:   CallQueryInterface(aFrame, &statefulFrame);
    1:   if (!statefulFrame) {
    1:     return;
    1:   }
    1: 
    1:   // Generate the hash key the state was stored under
    1:   // Exit early if we get empty key
    1:   nsIContent* content = aFrame->GetContent();
    1:   // If we don't have content, we can't generate a hash
    1:   // key and there's probably no state information for us.
    1:   if (!content) {
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString stateKey;
    1:   nsIDocument* doc = content->GetCurrentDoc();
    1:   nsresult rv = nsContentUtils::GenerateStateKey(content, doc, aID, stateKey);
    1:   if (NS_FAILED(rv) || stateKey.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Get the state from the hash
    1:   nsPresState *frameState;
    1:   rv = aState->GetState(stateKey, &frameState);
    1:   if (!frameState) {
    1:     return;
    1:   }
    1: 
    1:   // Restore it
    1:   rv = statefulFrame->RestoreState(frameState);
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   // If we restore ok, remove the state from the state table
    1:   aState->RemoveState(stateKey);
    1: }
    1: 
    1: void
    1: nsFrameManager::RestoreFrameState(nsIFrame* aFrame,
    1:                                   nsILayoutHistoryState* aState)
    1: {
    1:   NS_PRECONDITION(nsnull != aFrame && nsnull != aState, "null parameters passed in");
    1:   
    1:   RestoreFrameStateFor(aFrame, aState);
    1: 
    1:   // Now restore state recursively for the frame hierarchy rooted at aFrame
    1:   nsIAtom*  childListName = nsnull;
    1:   PRInt32   childListIndex = 0;
    1:   do {    
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
    1:     while (childFrame) {
    1:       RestoreFrameState(childFrame, aState);
    1:       // Get the next sibling child frame
    1:       childFrame = childFrame->GetNextSibling();
    1:     }
    1:     childListName = aFrame->GetAdditionalChildListName(childListIndex++);
    1:   } while (childListName);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: static PLHashNumber
    1: HashKey(void* key)
    1: {
    1:   return NS_PTR_TO_INT32(key);
    1: }
    1: 
    1: static PRIntn
    1: CompareKeys(void* key1, void* key2)
    1: {
    1:   return key1 == key2;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsFrameManagerBase::UndisplayedMap::UndisplayedMap(PRUint32 aNumBuckets)
    1: {
    1:   MOZ_COUNT_CTOR(nsFrameManagerBase::UndisplayedMap);
    1:   mTable = PL_NewHashTable(aNumBuckets, (PLHashFunction)HashKey,
    1:                            (PLHashComparator)CompareKeys,
    1:                            (PLHashComparator)nsnull,
    1:                            nsnull, nsnull);
    1:   mLastLookup = nsnull;
    1: }
    1: 
    1: nsFrameManagerBase::UndisplayedMap::~UndisplayedMap(void)
    1: {
    1:   MOZ_COUNT_DTOR(nsFrameManagerBase::UndisplayedMap);
    1:   Clear();
    1:   PL_HashTableDestroy(mTable);
    1: }
    1: 
    1: PLHashEntry**  
    1: nsFrameManagerBase::UndisplayedMap::GetEntryFor(nsIContent* aParentContent)
    1: {
    1:   if (mLastLookup && (aParentContent == (*mLastLookup)->key)) {
    1:     return mLastLookup;
    1:   }
    1:   PLHashNumber hashCode = NS_PTR_TO_INT32(aParentContent);
    1:   PLHashEntry** entry = PL_HashTableRawLookup(mTable, hashCode, aParentContent);
    1:   if (*entry) {
    1:     mLastLookup = entry;
    1:   }
    1:   return entry;
    1: }
    1: 
    1: UndisplayedNode* 
    1: nsFrameManagerBase::UndisplayedMap::GetFirstNode(nsIContent* aParentContent)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   if (*entry) {
    1:     return (UndisplayedNode*)((*entry)->value);
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::AppendNodeFor(UndisplayedNode* aNode,
    1:                                                   nsIContent* aParentContent)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   if (*entry) {
    1:     UndisplayedNode*  node = (UndisplayedNode*)((*entry)->value);
    1:     while (node->mNext) {
    1:       if (node->mContent == aNode->mContent) {
    1:         // We actually need to check this in optimized builds because
    1:         // there are some callers that do this.  See bug 118014, bug
    1:         // 136704, etc.
    1:         NS_NOTREACHED("node in map twice");
    1:         delete aNode;
    1:         return;
    1:       }
    1:       node = node->mNext;
    1:     }
    1:     node->mNext = aNode;
    1:   }
    1:   else {
    1:     PLHashNumber hashCode = NS_PTR_TO_INT32(aParentContent);
    1:     PL_HashTableRawAdd(mTable, entry, hashCode, aParentContent, aNode);
    1:     mLastLookup = nsnull; // hashtable may have shifted bucket out from under us
    1:   }
    1: }
    1: 
    1: nsresult 
    1: nsFrameManagerBase::UndisplayedMap::AddNodeFor(nsIContent* aParentContent,
    1:                                                nsIContent* aChild, 
    1:                                                nsStyleContext* aStyle)
    1: {
    1:   UndisplayedNode*  node = new UndisplayedNode(aChild, aStyle);
    1:   if (! node) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   AppendNodeFor(node, aParentContent);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::RemoveNodeFor(nsIContent* aParentContent,
    1:                                                   UndisplayedNode* aNode)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   NS_ASSERTION(*entry, "content not in map");
    1:   if (*entry) {
    1:     if ((UndisplayedNode*)((*entry)->value) == aNode) {  // first node
    1:       if (aNode->mNext) {
    1:         (*entry)->value = aNode->mNext;
    1:         aNode->mNext = nsnull;
    1:       }
    1:       else {
    1:         PL_HashTableRawRemove(mTable, entry, *entry);
    1:         mLastLookup = nsnull; // hashtable may have shifted bucket out from under us
    1:       }
    1:     }
    1:     else {
    1:       UndisplayedNode*  node = (UndisplayedNode*)((*entry)->value);
    1:       while (node->mNext) {
    1:         if (node->mNext == aNode) {
    1:           node->mNext = aNode->mNext;
    1:           aNode->mNext = nsnull;
    1:           break;
    1:         }
    1:         node = node->mNext;
    1:       }
    1:     }
    1:   }
    1:   delete aNode;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::RemoveNodesFor(nsIContent* aParentContent)
    1: {
    1:   PLHashEntry** entry = GetEntryFor(aParentContent);
    1:   NS_ASSERTION(entry, "content not in map");
    1:   if (*entry) {
    1:     UndisplayedNode*  node = (UndisplayedNode*)((*entry)->value);
    1:     NS_ASSERTION(node, "null node for non-null entry in UndisplayedMap");
    1:     delete node;
    1:     PL_HashTableRawRemove(mTable, entry, *entry);
    1:     mLastLookup = nsnull; // hashtable may have shifted bucket out from under us
    1:   }
    1: }
    1: 
20261: static PRIntn
    1: RemoveUndisplayedEntry(PLHashEntry* he, PRIntn i, void* arg)
    1: {
    1:   UndisplayedNode*  node = (UndisplayedNode*)(he->value);
    1:   delete node;
    1:   // Remove and free this entry and continue enumerating
    1:   return HT_ENUMERATE_REMOVE | HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: void
    1: nsFrameManagerBase::UndisplayedMap::Clear(void)
    1: {
    1:   mLastLookup = nsnull;
    1:   PL_HashTableEnumerateEntries(mTable, RemoveUndisplayedEntry, 0);
    1: }
