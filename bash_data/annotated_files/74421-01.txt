    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
39468:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsHTMLEditor.h"
    1: #include "nsHTMLEditRules.h"
    1: #include "nsTextEditUtils.h"
    1: #include "nsHTMLEditUtils.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMKeyListener.h" 
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseEvent.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "TypeInState.h"
    1: 
    1: #include "nsIEnumerator.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsAttrName.h"
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::AddDefaultProperty(nsIAtom *aProperty, 
    1:                                             const nsAString & aAttribute, 
    1:                                             const nsAString & aValue)
    1: {
    1:   nsString outValue;
    1:   PRInt32 index;
    1:   nsString attr(aAttribute);
    1:   if (TypeInState::FindPropInList(aProperty, attr, &outValue, mDefaultStyles, index))
    1:   {
27986:     PropItem *item = mDefaultStyles[index];
    1:     item->value = aValue;
    1:   }
    1:   else
    1:   {
    1:     nsString value(aValue);
    1:     PropItem *propItem = new PropItem(aProperty, attr, value);
27986:     mDefaultStyles.AppendElement(propItem);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveDefaultProperty(nsIAtom *aProperty, 
    1:                                    const nsAString & aAttribute, 
    1:                                    const nsAString & aValue)
    1: {
    1:   nsString outValue;
    1:   PRInt32 index;
    1:   nsString attr(aAttribute);
    1:   if (TypeInState::FindPropInList(aProperty, attr, &outValue, mDefaultStyles, index))
    1:   {
27986:     delete mDefaultStyles[index];
    1:     mDefaultStyles.RemoveElementAt(index);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveAllDefaultProperties()
    1: {
27986:   PRUint32 j, defcon = mDefaultStyles.Length();
    1:   for (j=0; j<defcon; j++)
    1:   {
27986:     delete mDefaultStyles[j];
    1:   }
    1:   mDefaultStyles.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // Add the CSS style corresponding to the HTML inline style defined
    1: // by aProperty aAttribute and aValue to the selection
    1: NS_IMETHODIMP nsHTMLEditor::SetCSSInlineProperty(nsIAtom *aProperty, 
    1:                             const nsAString & aAttribute, 
    1:                             const nsAString & aValue)
    1: {
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1:   if (useCSS) {
    1:     return SetInlineProperty(aProperty, aAttribute, aValue);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::SetInlineProperty(nsIAtom *aProperty, 
    1:                             const nsAString & aAttribute, 
    1:                             const nsAString & aValue)
    1: {
    1:   if (!aProperty) { return NS_ERROR_NULL_POINTER; }
    1:   if (!mRules) { return NS_ERROR_NOT_INITIALIZED; }
    1:   ForceCompositionEnd();
    1: 
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
    1:   PRBool isCollapsed;
    1:   selection->GetIsCollapsed(&isCollapsed);
    1:   if (isCollapsed)
    1:   {
    1:     // manipulating text attributes on a collapsed selection only sets state for the next text insertion
    1:     nsString tAttr(aAttribute);//MJUDGE SCC NEED HELP
    1:     nsString tVal(aValue);//MJUDGE SCC NEED HELP
    1:     return mTypeInState->SetProp(aProperty, tAttr, tVal);
    1:   }
    1:   
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertElement, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1:   
    1:   PRBool cancel, handled;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kSetTextProperty);
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!cancel && !handled)
    1:   {
    1:     // get selection range enumerator
    1:     nsCOMPtr<nsIEnumerator> enumerator;
    1:     res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:     // loop thru the ranges in the selection
    1:     enumerator->First(); 
    1:     nsCOMPtr<nsISupports> currentItem;
    1:     while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
    1:     {
    1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
    1:       
    1:       nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1: 
    1:       // adjust range to include any ancestors who's children are entirely selected
    1:       res = PromoteInlineRange(range);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       
    1:       // check for easy case: both range endpoints in same text node
    1:       nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:       res = range->GetStartContainer(getter_AddRefs(startNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = range->GetEndContainer(getter_AddRefs(endNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if ((startNode == endNode) && IsTextNode(startNode))
    1:       {
    1:         PRInt32 startOffset, endOffset;
    1:         range->GetStartOffset(&startOffset);
    1:         range->GetEndOffset(&endOffset);
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:         res = SetInlinePropertyOnTextNode(nodeAsText, startOffset, endOffset, aProperty, &aAttribute, &aValue);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       else
    1:       {
    1:         // not the easy case.  range not contained in single text node. 
    1:         // there are up to three phases here.  There are all the nodes
    1:         // reported by the subtree iterator to be processed.  And there
    1:         // are potentially a starting textnode and an ending textnode
    1:         // which are only partially contained by the range.
    1:         
    1:         // lets handle the nodes reported by the iterator.  These nodes
    1:         // are entirely contained in the selection range.  We build up
    1:         // a list of them (since doing operations on the document during
    1:         // iteration would perturb the iterator).
    1: 
    1:         nsCOMPtr<nsIContentIterator> iter =
    1:           do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
43805:         NS_ENSURE_SUCCESS(res, res);
43806:         NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
    1: 
    1:         nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         
    1:         // iterate range and build up array
    1:         res = iter->Init(range);
    1:         // init returns an error if no nodes in range.
    1:         // this can easily happen with the subtree 
    1:         // iterator if the selection doesn't contain
    1:         // any *whole* nodes.
    1:         if (NS_SUCCEEDED(res))
    1:         {
    1:           while (!iter->IsDone())
    1:           {
    1:             node = do_QueryInterface(iter->GetCurrentNode());
43807:             NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:             if (IsEditable(node))
    1:             { 
    1:               arrayOfNodes.AppendObject(node);
    1:             }
    1: 
    1:             iter->Next();
    1:           }
    1:         }
    1:         // first check the start parent of the range to see if it needs to 
    1:         // be separately handled (it does if it's a text node, due to how the
    1:         // subtree iterator works - it will not have reported it).
    1:         if (IsTextNode(startNode) && IsEditable(startNode))
    1:         {
    1:           nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:           PRInt32 startOffset;
    1:           PRUint32 textLen;
    1:           range->GetStartOffset(&startOffset);
    1:           nodeAsText->GetLength(&textLen);
    1:           res = SetInlinePropertyOnTextNode(nodeAsText, startOffset, textLen, aProperty, &aAttribute, &aValue);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         
    1:         // then loop through the list, set the property on each node
    1:         PRInt32 listCount = arrayOfNodes.Count();
    1:         PRInt32 j;
    1:         for (j = 0; j < listCount; j++)
    1:         {
    1:           node = arrayOfNodes[j];
    1:           res = SetInlinePropertyOnNode(node, aProperty, &aAttribute, &aValue);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         arrayOfNodes.Clear();
    1:         
    1:         // last check the end parent of the range to see if it needs to 
    1:         // be separately handled (it does if it's a text node, due to how the
    1:         // subtree iterator works - it will not have reported it).
    1:         if (IsTextNode(endNode) && IsEditable(endNode))
    1:         {
    1:           nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(endNode);
    1:           PRInt32 endOffset;
    1:           range->GetEndOffset(&endOffset);
    1:           res = SetInlinePropertyOnTextNode(nodeAsText, 0, endOffset, aProperty, &aAttribute, &aValue);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:       enumerator->Next();
    1:     }
    1:   }
    1:   if (!cancel)
    1:   {
    1:     // post-process
    1:     res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::SetInlinePropertyOnTextNode( nsIDOMCharacterData *aTextNode, 
    1:                                             PRInt32 aStartOffset,
    1:                                             PRInt32 aEndOffset,
    1:                                             nsIAtom *aProperty, 
    1:                                             const nsAString *aAttribute,
    1:                                             const nsAString *aValue)
    1: {
43806:   NS_ENSURE_TRUE(aTextNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   nsresult res = aTextNode->GetParentNode(getter_AddRefs(parent));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   nsAutoString tagString;
    1:   aProperty->ToString(tagString);
    1:   if (!CanContainTag(parent, tagString)) return NS_OK;
    1:   
    1:   // don't need to do anything if no characters actually selected
    1:   if (aStartOffset == aEndOffset) return NS_OK;
    1:   
    1:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aTextNode);
    1:   
    1:   // don't need to do anything if property already set on node
    1:   PRBool bHasProp;
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1: 
    1:   if (useCSS &&
    1:       mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty, aAttribute)) {
    1:     // the HTML styles defined by aProperty/aAttribute has a CSS equivalence
    1:     // in this implementation for node; let's check if it carries those css styles
    1:     nsAutoString value;
    1:     if (aValue) value.Assign(*aValue);
    1:     mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node, aProperty, aAttribute,
    1:                                                        bHasProp, value,
    1:                                                        COMPUTED_STYLE_TYPE);
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> styleNode;
    1:     IsTextPropertySetByContent(node, aProperty, aAttribute, aValue, bHasProp, getter_AddRefs(styleNode));
    1:   }
    1: 
    1:   if (bHasProp) return NS_OK;
    1:   
    1:   // do we need to split the text node?
    1:   PRUint32 textLen;
    1:   aTextNode->GetLength(&textLen);
    1:   
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   if ( (PRUint32)aEndOffset != textLen )
    1:   {
    1:     // we need to split off back of text node
    1:     res = SplitNode(node, aEndOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     node = tmp;  // remember left node
    1:   }
    1:   if ( aStartOffset )
    1:   {
    1:     // we need to split off front of text node
    1:     res = SplitNode(node, aStartOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   // look for siblings that are correct type of node
    1:   nsCOMPtr<nsIDOMNode> sibling;
    1:   GetPriorHTMLSibling(node, address_of(sibling));
    1:   if (sibling && NodeIsType(sibling, aProperty) &&         
    1:       HasAttrVal(sibling, aAttribute, aValue) &&
    1:       IsOnlyAttribute(sibling, aAttribute) )
    1:   {
    1:     // previous sib is already right kind of inline node; slide this over into it
    1:     res = MoveNode(node, sibling, -1);
    1:     return res;
    1:   }
    1:   sibling = nsnull;
    1:   GetNextHTMLSibling(node, address_of(sibling));
    1:   if (sibling && NodeIsType(sibling, aProperty) &&         
    1:       HasAttrVal(sibling, aAttribute, aValue) &&
    1:       IsOnlyAttribute(sibling, aAttribute) )
    1:   {
    1:     // following sib is already right kind of inline node; slide this over into it
    1:     res = MoveNode(node, sibling, 0);
    1:     return res;
    1:   }
    1:   
    1:   // reparent the node inside inline node with appropriate {attribute,value}
    1:   return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::SetInlinePropertyOnNode( nsIDOMNode *aNode,
    1:                                        nsIAtom *aProperty, 
    1:                                        const nsAString *aAttribute,
    1:                                        const nsAString *aValue)
    1: {
43806:   NS_ENSURE_TRUE(aNode && aProperty, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   nsAutoString tag;
    1:   aProperty->ToString(tag);
    1:   ToLowerCase(tag);
    1:   
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1: 
    1:   if (useCSS)
    1:   {
    1:     // we are in CSS mode
    1:     if (mHTMLCSSUtils->IsCSSEditableProperty(aNode, aProperty, aAttribute))
    1:     {
    1:       // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:       // in this implementation for the node aNode
    1:       nsCOMPtr<nsIDOMNode> tmp = aNode;
    1:       if (IsTextNode(tmp))
    1:       {
    1:         // we are working on a text node and need to create a span container
    1:         // that will carry the styles
    1:         InsertContainerAbove( aNode, 
    1:                               address_of(tmp), 
    1:                               NS_LITERAL_STRING("span"),
    1:                               nsnull,
    1:                               nsnull);
    1:       }
    1:       nsCOMPtr<nsIDOMElement>element;
    1:       element = do_QueryInterface(tmp);
    1:       // first we have to remove occurences of the same style hint in the
    1:       // children of the aNode
    1:       res = RemoveStyleInside(tmp, aProperty, aAttribute, PR_TRUE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       PRInt32 count;
    1:       // then we add the css styles corresponding to the HTML style request
    1:       res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(element, aProperty, aAttribute, aValue, &count, PR_FALSE);
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       nsCOMPtr<nsIDOMNode> nextSibling, previousSibling;
    1:       GetNextHTMLSibling(tmp, address_of(nextSibling));
    1:       GetPriorHTMLSibling(tmp, address_of(previousSibling));
    1:       if (nextSibling || previousSibling)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> mergeParent;
    1:         res = tmp->GetParentNode(getter_AddRefs(mergeParent));
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (previousSibling &&
    1:             nsEditor::NodeIsType(previousSibling, nsEditProperty::span) &&
    1:             NodesSameType(tmp, previousSibling))
    1:         {
    1:           res = JoinNodes(previousSibling, tmp, mergeParent);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         if (nextSibling &&
    1:             nsEditor::NodeIsType(nextSibling, nsEditProperty::span) &&
    1:             NodesSameType(tmp, nextSibling))
    1:         {
    1:           res = JoinNodes(tmp, nextSibling, mergeParent);
    1:         }
    1:       }
    1:       return res;
    1:     }
    1:   }
    1:   
    1:   // don't need to do anything if property already set on node
    1:   PRBool bHasProp;
    1:   nsCOMPtr<nsIDOMNode> styleNode;
    1:   IsTextPropertySetByContent(aNode, aProperty, aAttribute, aValue, bHasProp, getter_AddRefs(styleNode));
    1:   if (bHasProp) return NS_OK;
    1: 
    1:   // is it already the right kind of node, but with wrong attribute?
    1:   if (NodeIsType(aNode, aProperty))
    1:   {
    1:     // just set the attribute on it.
    1:     // but first remove any contrary style in it's children.
    1:     res = RemoveStyleInside(aNode, aProperty, aAttribute, PR_TRUE);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
    1:     return SetAttribute(elem, *aAttribute, *aValue);
    1:   }
    1:   
    1:   // can it be put inside inline node?
    1:   if (TagCanContain(tag, aNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> priorNode, nextNode;
    1:     // is either of it's neighbors the right kind of node?
    1:     GetPriorHTMLSibling(aNode, address_of(priorNode));
    1:     GetNextHTMLSibling(aNode, address_of(nextNode));
    1:     if (priorNode && NodeIsType(priorNode, aProperty) && 
    1:         HasAttrVal(priorNode, aAttribute, aValue)     &&
    1:         IsOnlyAttribute(priorNode, aAttribute) )
    1:     {
    1:       // previous sib is already right kind of inline node; slide this over into it
    1:       res = MoveNode(aNode, priorNode, -1);
    1:     }
    1:     else if (nextNode && NodeIsType(nextNode, aProperty) && 
    1:              HasAttrVal(nextNode, aAttribute, aValue)    &&
    1:              IsOnlyAttribute(priorNode, aAttribute) )
    1:     {
    1:       // following sib is already right kind of inline node; slide this over into it
    1:       res = MoveNode(aNode, nextNode, 0);
    1:     }
    1:     else
    1:     {
    1:       // ok, chuck it in it's very own container
    1:       res = InsertContainerAbove(aNode, address_of(tmp), tag, aAttribute, aValue);
    1:     }
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     return RemoveStyleInside(aNode, aProperty, aAttribute);
    1:   }
    1:   // none of the above?  then cycle through the children.
    1:   nsCOMPtr<nsIDOMNodeList> childNodes;
    1:   res = aNode->GetChildNodes(getter_AddRefs(childNodes));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (childNodes)
    1:   {
    1:     PRInt32 j;
    1:     PRUint32 childCount;
    1:     childNodes->GetLength(&childCount);
    1:     if (childCount)
    1:     {
    1:       nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:       nsCOMPtr<nsIDOMNode> node;
    1:       
    1:       // populate the list
    1:       for (j=0 ; j < (PRInt32)childCount; j++)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> childNode;
    1:         res = childNodes->Item(j, getter_AddRefs(childNode));
    1:         if ((NS_SUCCEEDED(res)) && (childNode) && IsEditable(childNode))
    1:         {
    1:           arrayOfNodes.AppendObject(childNode);
    1:         }
    1:       }
    1:       
    1:       // then loop through the list, set the property on each node
    1:       PRInt32 listCount = arrayOfNodes.Count();
    1:       for (j = 0; j < listCount; j++)
    1:       {
    1:         node = arrayOfNodes[j];
    1:         res = SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       arrayOfNodes.Clear();
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult nsHTMLEditor::SplitStyleAboveRange(nsIDOMRange *inRange, 
    1:                                             nsIAtom *aProperty, 
    1:                                             const nsAString *aAttribute)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode, origStartNode;
    1:   PRInt32 startOffset, endOffset, origStartOffset;
    1:   
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   origStartNode = startNode;
    1:   origStartOffset = startOffset;
    1:   
    1:   // split any matching style nodes above the start of range
    1:   {
    1:     nsAutoTrackDOMPoint tracker(mRangeUpdater, address_of(endNode), &endOffset);
    1:     res = SplitStyleAbovePoint(address_of(startNode), &startOffset, aProperty, aAttribute);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   // second verse, same as the first...
    1:   res = SplitStyleAbovePoint(address_of(endNode), &endOffset, aProperty, aAttribute);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // reset the range
    1:   res = inRange->SetStart(startNode, startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(endNode, endOffset);
    1:   return res;
    1: }
    1: 
    1: nsresult nsHTMLEditor::SplitStyleAbovePoint(nsCOMPtr<nsIDOMNode> *aNode,
    1:                                            PRInt32 *aOffset,
    1:                                            nsIAtom *aProperty,          // null here means we split all properties
    1:                                            const nsAString *aAttribute,
    1:                                            nsCOMPtr<nsIDOMNode> *outLeftNode,
    1:                                            nsCOMPtr<nsIDOMNode> *outRightNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode && *aNode && aOffset, NS_ERROR_NULL_POINTER);
    1:   if (outLeftNode)  *outLeftNode  = nsnull;
    1:   if (outRightNode) *outRightNode = nsnull;
    1:   // split any matching style nodes above the node/offset
    1:   nsCOMPtr<nsIDOMNode> parent, tmp = *aNode;
    1:   PRInt32 offset;
    1: 
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1: 
    1:   PRBool isSet;
    1:   while (tmp && !IsBlockNode(tmp))
    1:   {
    1:     isSet = PR_FALSE;
    1:     if (useCSS && mHTMLCSSUtils->IsCSSEditableProperty(tmp, aProperty, aAttribute)) {
    1:       // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:       // in this implementation for the node tmp; let's check if it carries those css styles
    1:       nsAutoString firstValue;
    1:       mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(tmp, aProperty, aAttribute,
    1:                                                          isSet, firstValue,
    1:                                                          SPECIFIED_STYLE_TYPE);
    1:     }
    1:     if ( (aProperty && NodeIsType(tmp, aProperty)) ||   // node is the correct inline prop
    1:          (aProperty == nsEditProperty::href && nsHTMLEditUtils::IsLink(tmp)) ||
    1:                                                         // node is href - test if really <a href=...
    1:          (!aProperty && NodeIsProperty(tmp)) ||         // or node is any prop, and we asked to split them all
    1:          isSet)                                         // or the style is specified in the style attribute
    1:     {
    1:       // found a style node we need to split
39468:       nsresult rv = SplitNodeDeep(tmp, *aNode, *aOffset, &offset, PR_FALSE,
39468:                                   outLeftNode, outRightNode);
39468:       NS_ENSURE_SUCCESS(rv, rv);
    1:       // reset startNode/startOffset
    1:       tmp->GetParentNode(getter_AddRefs(*aNode));
    1:       *aOffset = offset;
    1:     }
    1:     tmp->GetParentNode(getter_AddRefs(parent));
    1:     tmp = parent;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsHTMLEditor::NodeIsProperty(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, PR_FALSE);
    1:   if (!IsContainer(aNode))  return PR_FALSE;
    1:   if (!IsEditable(aNode))   return PR_FALSE;
    1:   if (IsBlockNode(aNode))   return PR_FALSE;
    1:   if (NodeIsType(aNode, nsEditProperty::a)) return PR_FALSE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult nsHTMLEditor::ApplyDefaultProperties()
    1: {
    1:   nsresult res = NS_OK;
27986:   PRUint32 j, defcon = mDefaultStyles.Length();
    1:   for (j=0; j<defcon; j++)
    1:   {
27986:     PropItem *propItem = mDefaultStyles[j];
43807:     NS_ENSURE_TRUE(propItem, NS_ERROR_NULL_POINTER);
    1:     res = SetInlineProperty(propItem->tag, propItem->attr, propItem->value);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult nsHTMLEditor::RemoveStyleInside(nsIDOMNode *aNode, 
    1:                                    nsIAtom *aProperty,   // null here means remove all properties
    1:                                    const nsAString *aAttribute, 
    1:                                    PRBool aChildrenOnly)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1:   if (IsTextNode(aNode)) return NS_OK;
    1:   nsresult res = NS_OK;
    1: 
    1:   // first process the children
    1:   nsCOMPtr<nsIDOMNode> child, tmp;
    1:   aNode->GetFirstChild(getter_AddRefs(child));
    1:   while (child)
    1:   {
    1:     // cache next sibling since we might remove child
    1:     child->GetNextSibling(getter_AddRefs(tmp));
    1:     res = RemoveStyleInside(child, aProperty, aAttribute);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     child = tmp;
    1:   }
    1: 
    1:   // then process the node itself
    1:   if ( !aChildrenOnly && 
    1:         (aProperty && NodeIsType(aNode, aProperty) || // node is prop we asked for
    1:         (aProperty == nsEditProperty::href && nsHTMLEditUtils::IsLink(aNode)) || // but check for link (<a href=...)
    1:         (aProperty == nsEditProperty::name && nsHTMLEditUtils::IsNamedAnchor(aNode))) || // and for named anchors
    1:         (!aProperty && NodeIsProperty(aNode)))  // or node is any prop and we asked for that
    1:   {
    1:     // if we weren't passed an attribute, then we want to 
    1:     // remove any matching inlinestyles entirely
    1:     if (!aAttribute || aAttribute->IsEmpty())
    1:     {
    1:       NS_NAMED_LITERAL_STRING(styleAttr, "style");
    1:       NS_NAMED_LITERAL_STRING(classAttr, "class");
    1:       PRBool hasStyleAttr = HasAttr(aNode, &styleAttr);
    1:       PRBool hasClassAtrr = HasAttr(aNode, &classAttr);
    1:       if (aProperty &&
    1:           (hasStyleAttr || hasClassAtrr)) {
    1:         // aNode carries inline styles or a class attribute so we can't
    1:         // just remove the element... We need to create above the element
    1:         // a span that will carry those styles or class, then we can delete
    1:         // the node.
    1:         nsCOMPtr<nsIDOMNode> spanNode;
    1:         res = InsertContainerAbove(aNode, address_of(spanNode),
    1:                                    NS_LITERAL_STRING("span"));
43808:         NS_ENSURE_SUCCESS(res, res);
    1:         res = CloneAttribute(styleAttr, spanNode, aNode);
43808:         NS_ENSURE_SUCCESS(res, res);
    1:         res = CloneAttribute(classAttr, spanNode, aNode);
43808:         NS_ENSURE_SUCCESS(res, res);
    1:         if (hasStyleAttr)
    1:         {
    1:           // we need to remove the styles property corresponding to
    1:           // aProperty (bug 215406)
    1:           nsAutoString propertyValue;
    1:           mHTMLCSSUtils->RemoveCSSEquivalentToHTMLStyle(spanNode,
    1:                                                         aProperty,
    1:                                                         aAttribute,
    1:                                                         &propertyValue,
    1:                                                         PR_FALSE);
    1:           // remove the span if it's useless
    1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(spanNode);
    1:           res = RemoveElementIfNoStyleOrIdOrClass(element, nsEditProperty::span);
    1:         }
    1:       }
    1:       res = RemoveContainer(aNode);
    1:     }
    1:     // otherwise we just want to eliminate the attribute
    1:     else
    1:     {
    1:       if (HasAttr(aNode, aAttribute))
    1:       {
    1:         // if this matching attribute is the ONLY one on the node,
    1:         // then remove the whole node.  Otherwise just nix the attribute.
    1:         if (IsOnlyAttribute(aNode, aAttribute))
    1:         {
    1:           res = RemoveContainer(aNode);
    1:         }
    1:         else
    1:         {
    1:           nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
43806:           NS_ENSURE_TRUE(elem, NS_ERROR_NULL_POINTER);
    1:           res = RemoveAttribute(elem, *aAttribute);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     PRBool useCSS;
    1:     GetIsCSSEnabled(&useCSS);
    1: 
    1:     if (!aChildrenOnly
    1:         && useCSS && mHTMLCSSUtils->IsCSSEditableProperty(aNode, aProperty, aAttribute)) {
    1:       // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:       // in this implementation for the node aNode; let's check if it carries those css styles
    1:       nsAutoString propertyValue;
    1:       PRBool isSet;
    1:       mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(aNode, aProperty, aAttribute,
    1:                                                          isSet, propertyValue,
    1:                                                          SPECIFIED_STYLE_TYPE);
    1:       if (isSet) {
    1:         // yes, tmp has the corresponding css declarations in its style attribute
    1:         // let's remove them
    1:         mHTMLCSSUtils->RemoveCSSEquivalentToHTMLStyle(aNode,
    1:                                                       aProperty,
    1:                                                       aAttribute,
    1:                                                       &propertyValue,
    1:                                                       PR_FALSE);
    1:         // remove the node if it is a span, if its style attribute is empty or absent,
    1:         // and if it does not have a class nor an id
    1:         nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
    1:         res = RemoveElementIfNoStyleOrIdOrClass(element, nsEditProperty::span);
    1:       }
    1:     }
    1:   }  
    1:   if ( aProperty == nsEditProperty::font &&    // or node is big or small and we are setting font size
    1:        (nsHTMLEditUtils::IsBig(aNode) || nsHTMLEditUtils::IsSmall(aNode)) &&
74420:        aAttribute && aAttribute->LowerCaseEqualsLiteral("size"))       
    1:   {
    1:     res = RemoveContainer(aNode);  // if we are setting font size, remove any nested bigs and smalls
    1:   }
    1:   return res;
    1: }
    1: 
    1: PRBool nsHTMLEditor::IsOnlyAttribute(nsIDOMNode *aNode, 
    1:                                      const nsAString *aAttribute)
    1: {
43806:   NS_ENSURE_TRUE(aNode && aAttribute, PR_FALSE);  // ooops
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
43806:   NS_ENSURE_TRUE(content, PR_FALSE);  // ooops
    1:   
    1:   PRUint32 i, attrCount = content->GetAttrCount();
    1:   for (i = 0; i < attrCount; ++i) {
    1:     nsAutoString attrString;
    1:     const nsAttrName* name = content->GetAttrNameAt(i);
    1:     if (!name->NamespaceEquals(kNameSpaceID_None)) {
    1:       return PR_FALSE;
    1:     }
    1:     name->LocalName()->ToString(attrString);
    1:     // if it's the attribute we know about, or a special _moz attribute,
    1:     // keep looking
    1:     if (!attrString.Equals(*aAttribute, nsCaseInsensitiveStringComparator()) &&
    1:         !StringBeginsWith(attrString, NS_LITERAL_STRING("_moz"))) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1:   // if we made it through all of them without finding a real attribute
    1:   // other than aAttribute, then return PR_TRUE
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool nsHTMLEditor::HasAttr(nsIDOMNode *aNode, 
    1:                              const nsAString *aAttribute)
    1: {
43806:   NS_ENSURE_TRUE(aNode, PR_FALSE);
    1:   if (!aAttribute || aAttribute->IsEmpty()) return PR_TRUE;  // everybody has the 'null' attribute
    1:   
    1:   // get element
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
43806:   NS_ENSURE_TRUE(elem, PR_FALSE);
    1:   
    1:   // get attribute node
    1:   nsCOMPtr<nsIDOMAttr> attNode;
    1:   nsresult res = elem->GetAttributeNode(*aAttribute, getter_AddRefs(attNode));
    1:   if ((NS_FAILED(res)) || !attNode) return PR_FALSE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: PRBool nsHTMLEditor::HasAttrVal(nsIDOMNode *aNode, 
    1:                                 const nsAString *aAttribute, 
    1:                                 const nsAString *aValue)
    1: {
43806:   NS_ENSURE_TRUE(aNode, PR_FALSE);
    1:   if (!aAttribute || aAttribute->IsEmpty()) return PR_TRUE;  // everybody has the 'null' attribute
    1:   
    1:   // get element
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
43806:   NS_ENSURE_TRUE(elem, PR_FALSE);
    1:   
    1:   // get attribute node
    1:   nsCOMPtr<nsIDOMAttr> attNode;
    1:   nsresult res = elem->GetAttributeNode(*aAttribute, getter_AddRefs(attNode));
    1:   if ((NS_FAILED(res)) || !attNode) return PR_FALSE;
    1:   
    1:   // check if attribute has a value
    1:   PRBool isSet;
    1:   attNode->GetSpecified(&isSet);
    1:   // if no value, and that's what we wanted, then return true
    1:   if (!isSet && (!aValue || aValue->IsEmpty())) return PR_TRUE; 
    1:   
    1:   // get attribute value
    1:   nsAutoString attrVal;
    1:   attNode->GetValue(attrVal);
    1:   
    1:   // do values match?
    1:   if (attrVal.Equals(*aValue,nsCaseInsensitiveStringComparator())) return PR_TRUE;
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult nsHTMLEditor::PromoteRangeIfStartsOrEndsInNamedAnchor(nsIDOMRange *inRange)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode, parent, tmp;
    1:   PRInt32 startOffset, endOffset, tmpOffset;
    1:   
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   tmp = startNode;
    1:   while ( tmp && 
    1:           !nsTextEditUtils::IsBody(tmp) &&
    1:           !nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     tmp = parent;
    1:   }
43806:   NS_ENSURE_TRUE(tmp, NS_ERROR_NULL_POINTER);
    1:   if (nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     startNode = parent;
    1:     startOffset = tmpOffset;
    1:   }
    1: 
    1:   tmp = endNode;
    1:   while ( tmp && 
    1:           !nsTextEditUtils::IsBody(tmp) &&
    1:           !nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     tmp = parent;
    1:   }
43806:   NS_ENSURE_TRUE(tmp, NS_ERROR_NULL_POINTER);
    1:   if (nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     endNode = parent;
    1:     endOffset = tmpOffset + 1;
    1:   }
    1: 
    1:   res = inRange->SetStart(startNode, startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(endNode, endOffset);
    1:   return res;
    1: }
    1: 
    1: nsresult nsHTMLEditor::PromoteInlineRange(nsIDOMRange *inRange)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode, parent;
    1:   PRInt32 startOffset, endOffset;
    1:   
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   while ( startNode && 
    1:           !nsTextEditUtils::IsBody(startNode) && 
30676:           IsEditable(startNode) &&
    1:           IsAtFrontOfNode(startNode, startOffset) )
    1:   {
    1:     res = GetNodeLocation(startNode, address_of(parent), &startOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     startNode = parent;
    1:   }
43806:   NS_ENSURE_TRUE(startNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   while ( endNode && 
    1:           !nsTextEditUtils::IsBody(endNode) && 
30676:           IsEditable(endNode) &&
    1:           IsAtEndOfNode(endNode, endOffset) )
    1:   {
    1:     res = GetNodeLocation(endNode, address_of(parent), &endOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     endNode = parent;
    1:     endOffset++;  // we are AFTER this node
    1:   }
43806:   NS_ENSURE_TRUE(endNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   res = inRange->SetStart(startNode, startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(endNode, endOffset);
    1:   return res;
    1: }
    1: 
    1: PRBool nsHTMLEditor::IsAtFrontOfNode(nsIDOMNode *aNode, PRInt32 aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aNode, PR_FALSE);  // oops
73978:   if (!aOffset) {
73978:     return PR_TRUE;
73978:   }
    1: 
    1:   if (IsTextNode(aNode))
    1:   {
    1:     return PR_FALSE;
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> firstNode;
    1:     GetFirstEditableChild(aNode, address_of(firstNode));
43806:     NS_ENSURE_TRUE(firstNode, PR_TRUE); 
    1:     PRInt32 offset;
    1:     nsEditor::GetChildOffset(firstNode, aNode, offset);
    1:     if (offset < aOffset) return PR_FALSE;
    1:     return PR_TRUE;
    1:   }
    1: }
    1: 
    1: PRBool nsHTMLEditor::IsAtEndOfNode(nsIDOMNode *aNode, PRInt32 aOffset)
    1: {
43806:   NS_ENSURE_TRUE(aNode, PR_FALSE);  // oops
    1:   PRUint32 len;
    1:   GetLengthOfDOMNode(aNode, len);
    1:   if (aOffset == (PRInt32)len) return PR_TRUE;
    1:   
    1:   if (IsTextNode(aNode))
    1:   {
    1:     return PR_FALSE;
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> lastNode;
    1:     GetLastEditableChild(aNode, address_of(lastNode));
43806:     NS_ENSURE_TRUE(lastNode, PR_TRUE); 
    1:     PRInt32 offset;
    1:     nsEditor::GetChildOffset(lastNode, aNode, offset);
    1:     if (offset < aOffset) return PR_TRUE;
    1:     return PR_FALSE;
    1:   }
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::GetInlinePropertyBase(nsIAtom *aProperty, 
    1:                              const nsAString *aAttribute,
    1:                              const nsAString *aValue,
    1:                              PRBool *aFirst, 
    1:                              PRBool *aAny, 
    1:                              PRBool *aAll,
    1:                              nsAString *outValue,
    1:                              PRBool aCheckDefaults)
    1: {
43807:   NS_ENSURE_TRUE(aProperty, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult result;
    1:   *aAny=PR_FALSE;
    1:   *aAll=PR_TRUE;
    1:   *aFirst=PR_FALSE;
    1:   PRBool first=PR_TRUE;
    1: 
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1: 
    1:   nsCOMPtr<nsISelection>selection;
    1:   result = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(result, result);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
    1:   PRBool isCollapsed;
    1:   selection->GetIsCollapsed(&isCollapsed);
    1:   nsCOMPtr<nsIDOMNode> collapsedNode;
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   result = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:   NS_ENSURE_SUCCESS(result, result);
43806:   NS_ENSURE_TRUE(enumerator, NS_ERROR_NULL_POINTER);
    1: 
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   result = enumerator->CurrentItem(getter_AddRefs(currentItem));
    1:   // XXX: should be a while loop, to get each separate range
    1:   // XXX: ERROR_HANDLING can currentItem be null?
    1:   if ((NS_SUCCEEDED(result)) && currentItem)
    1:   {
    1:     PRBool firstNodeInRange = PR_TRUE; // for each range, set a flag 
    1:     nsCOMPtr<nsIDOMRange> range(do_QueryInterface(currentItem));
    1: 
    1:     if (isCollapsed)
    1:     {
    1:       range->GetStartContainer(getter_AddRefs(collapsedNode));
43806:       NS_ENSURE_TRUE(collapsedNode, NS_ERROR_FAILURE);
    1:       PRBool isSet, theSetting;
    1:       if (aAttribute)
    1:       {
    1:         nsString tString(*aAttribute); //MJUDGE SCC NEED HELP
    1:         nsString tOutString;//MJUDGE SCC NEED HELP
    1:         nsString *tPassString=nsnull;
    1:         if (outValue)
    1:             tPassString = &tOutString;
    1:         mTypeInState->GetTypingState(isSet, theSetting, aProperty, tString, &tOutString);
    1:         if (outValue)
    1:           outValue->Assign(tOutString);
    1:       }
    1:       else
    1:         mTypeInState->GetTypingState(isSet, theSetting, aProperty);
    1:       if (isSet) 
    1:       {
    1:         *aFirst = *aAny = *aAll = theSetting;
    1:         return NS_OK;
    1:       }
    1:       if (!useCSS) {
    1:         nsCOMPtr<nsIDOMNode> resultNode;
    1:         IsTextPropertySetByContent(collapsedNode, aProperty, aAttribute, aValue,
    1:                                    isSet, getter_AddRefs(resultNode), outValue);
    1:         *aFirst = *aAny = *aAll = isSet;
    1:         
    1:         if (!isSet && aCheckDefaults) 
    1:         {
    1:           // style not set, but if it is a default then it will appear if 
    1:           // content is inserted, so we should report it as set (analogous to TypeInState).
    1:           PRInt32 index;
74421:           if (aAttribute &&
74421:               TypeInState::FindPropInList(aProperty, *aAttribute, outValue, mDefaultStyles, index))
    1:           {
    1:             *aFirst = *aAny = *aAll = PR_TRUE;
    1:             if (outValue)
27986:               outValue->Assign(mDefaultStyles[index]->value);
    1:           }
    1:         }
    1:         return NS_OK;
    1:       }
    1:     }
    1: 
    1:     // non-collapsed selection
    1:     nsCOMPtr<nsIContentIterator> iter =
    1:             do_CreateInstance("@mozilla.org/content/post-content-iterator;1");
43806:     NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
    1: 
    1:     iter->Init(range);
    1:     nsAutoString firstValue, theValue;
    1: 
    1:     nsCOMPtr<nsIDOMNode> endNode;
    1:     PRInt32 endOffset;
    1:     result = range->GetEndContainer(getter_AddRefs(endNode));
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     result = range->GetEndOffset(&endOffset);
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     while (!iter->IsDone())
    1:     {
20503:       nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
    1: 
    1:       nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
    1: 
    1:       if (node && nsTextEditUtils::IsBody(node))
    1:         break;
    1: 
    1:       nsCOMPtr<nsIDOMCharacterData>text;
    1:       text = do_QueryInterface(content);
    1:       
    1:       PRBool skipNode = PR_FALSE;
    1:       
    1:       // just ignore any non-editable nodes
    1:       if (text && !IsEditable(text))
    1:       {
    1:         skipNode = PR_TRUE;
    1:       }
    1:       else if (text)
    1:       {
    1:         if (!isCollapsed && first && firstNodeInRange)
    1:         {
    1:           firstNodeInRange = PR_FALSE;
    1:           PRInt32 startOffset;
    1:           range->GetStartOffset(&startOffset);
    1:           PRUint32 count;
    1:           text->GetLength(&count);
    1:           if (startOffset==(PRInt32)count) 
    1:           {
    1:             skipNode = PR_TRUE;
    1:           }
    1:         }
    1:         else if (node == endNode && !endOffset)
    1:         {
    1:           skipNode = PR_TRUE;
    1:         }
    1:       }
41645:       else if (content->IsElement())
    1:       { // handle non-text leaf nodes here
    1:         skipNode = PR_TRUE;
    1:       }
    1:       if (!skipNode)
    1:       {
    1:         if (node)
    1:         {
    1:           PRBool isSet = PR_FALSE;
    1:           nsCOMPtr<nsIDOMNode>resultNode;
    1:           if (first)
    1:           {
    1:             if (useCSS &&
    1:                 mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty, aAttribute)) {
    1:               // the HTML styles defined by aProperty/aAttribute has a CSS equivalence
    1:               // in this implementation for node; let's check if it carries those css styles
    1:               if (aValue) firstValue.Assign(*aValue);
    1:               mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node, aProperty, aAttribute,
    1:                                                                  isSet, firstValue,
    1:                                                                  COMPUTED_STYLE_TYPE);
    1:             }
    1:             else {
    1:               IsTextPropertySetByContent(node, aProperty, aAttribute, aValue, isSet,
    1:                                          getter_AddRefs(resultNode), &firstValue);
    1:             }
    1:             *aFirst = isSet;
    1:             first = PR_FALSE;
    1:             if (outValue) *outValue = firstValue;
    1:           }
    1:           else
    1:           {
    1:             if (useCSS &&
    1:                 mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty, aAttribute)) {
    1:               // the HTML styles defined by aProperty/aAttribute has a CSS equivalence
    1:               // in this implementation for node; let's check if it carries those css styles
    1:               if (aValue) theValue.Assign(*aValue);
    1:               mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node, aProperty, aAttribute,
    1:                                                                  isSet, theValue,
    1:                                                                  COMPUTED_STYLE_TYPE);
    1:             }
    1:             else {
    1:               IsTextPropertySetByContent(node, aProperty, aAttribute, aValue, isSet,
    1:                                          getter_AddRefs(resultNode), &theValue);
    1:             }
    1:             if (firstValue != theValue)
    1:               *aAll = PR_FALSE;
    1:           }
    1:           
    1:           if (isSet) {
    1:             *aAny = PR_TRUE;
    1:           }
    1:           else {
    1:             *aAll = PR_FALSE;
    1:           }
    1:         }
    1:       }
    1: 
    1:       iter->Next();
    1:     }
    1:   }
    1:   if (!*aAny) 
    1:   { // make sure that if none of the selection is set, we don't report all is set
    1:     *aAll = PR_FALSE;
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::GetInlineProperty(nsIAtom *aProperty, 
    1:                                               const nsAString &aAttribute, 
    1:                                               const nsAString &aValue,
    1:                                               PRBool *aFirst, 
    1:                                               PRBool *aAny, 
    1:                                               PRBool *aAll)
    1: {
43807:   NS_ENSURE_TRUE(aProperty && aFirst && aAny && aAll, NS_ERROR_NULL_POINTER);
    1:   const nsAString *att = nsnull;
    1:   if (!aAttribute.IsEmpty())
    1:     att = &aAttribute;
    1:   const nsAString *val = nsnull;
    1:   if (!aValue.IsEmpty())
    1:     val = &aValue;
    1:   return GetInlinePropertyBase( aProperty, att, val, aFirst, aAny, aAll, nsnull);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::GetInlinePropertyWithAttrValue(nsIAtom *aProperty, 
    1:                                               const nsAString &aAttribute, 
    1:                                               const nsAString &aValue,
    1:                                               PRBool *aFirst, 
    1:                                               PRBool *aAny, 
    1:                                               PRBool *aAll,
    1:                                               nsAString &outValue)
    1: {
43807:   NS_ENSURE_TRUE(aProperty && aFirst && aAny && aAll, NS_ERROR_NULL_POINTER);
    1:   const nsAString *att = nsnull;
    1:   if (!aAttribute.IsEmpty())
    1:     att = &aAttribute;
    1:   const nsAString *val = nsnull;
    1:   if (!aValue.IsEmpty())
    1:     val = &aValue;
    1:   return GetInlinePropertyBase( aProperty, att, val, aFirst, aAny, aAll, &outValue);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveAllInlineProperties()
    1: {
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpResetTextProperties, nsIEditor::eNext);
    1: 
    1:   nsresult res = RemoveInlinePropertyImpl(nsnull, nsnull);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   return ApplyDefaultProperties();
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveInlineProperty(nsIAtom *aProperty, const nsAString &aAttribute)
    1: {
    1:   return RemoveInlinePropertyImpl(aProperty, &aAttribute);
    1: }
    1: 
    1: nsresult nsHTMLEditor::RemoveInlinePropertyImpl(nsIAtom *aProperty, const nsAString *aAttribute)
    1: {
43806:   NS_ENSURE_TRUE(mRules, NS_ERROR_NOT_INITIALIZED);
    1:   ForceCompositionEnd();
    1: 
    1:   nsresult res;
    1:   nsCOMPtr<nsISelection>selection;
    1:   res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
    1:   PRBool isCollapsed;
    1:   selection->GetIsCollapsed(&isCollapsed);
    1: 
    1:   PRBool useCSS;
    1:   GetIsCSSEnabled(&useCSS);
    1: 
    1:   if (isCollapsed)
    1:   {
    1:     // manipulating text attributes on a collapsed selection only sets state for the next text insertion
    1: 
    1:     // For links, aProperty uses "href", use "a" instead
    1:     if (aProperty == nsEditProperty::href ||
    1:         aProperty == nsEditProperty::name)
    1:       aProperty = nsEditProperty::a;
    1: 
    1:     if (aProperty) return mTypeInState->ClearProp(aProperty, nsAutoString(*aAttribute));
    1:     else return mTypeInState->ClearAllProps();
    1:   }
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpRemoveTextProperty, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1:   
    1:   PRBool cancel, handled;
    1:   nsTextRulesInfo ruleInfo(nsTextEditRules::kRemoveTextProperty);
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!cancel && !handled)
    1:   {
    1:     // get selection range enumerator
    1:     nsCOMPtr<nsIEnumerator> enumerator;
    1:     res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:     // loop thru the ranges in the selection
    1:     enumerator->First(); 
    1:     nsCOMPtr<nsISupports> currentItem;
    1:     while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
    1:     {
    1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
    1:       
    1:       nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1: 
    1:       if (aProperty == nsEditProperty::name)
    1:       {
    1:         // promote range if it starts or end in a named anchor and we
    1:         // want to remove named anchors
    1:         res = PromoteRangeIfStartsOrEndsInNamedAnchor(range);
    1:       }
    1:       else {
    1:         // adjust range to include any ancestors who's children are entirely selected
    1:         res = PromoteInlineRange(range);
    1:       }
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // remove this style from ancestors of our range endpoints, 
    1:       // splitting them as appropriate
    1:       res = SplitStyleAboveRange(range, aProperty, aAttribute);
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // check for easy case: both range endpoints in same text node
    1:       nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:       res = range->GetStartContainer(getter_AddRefs(startNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = range->GetEndContainer(getter_AddRefs(endNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if ((startNode == endNode) && IsTextNode(startNode))
    1:       {
    1:         // we're done with this range!
    1:         if (useCSS && mHTMLCSSUtils->IsCSSEditableProperty(startNode, aProperty, aAttribute)) {
    1:           // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:           // in this implementation for startNode
    1:           nsAutoString cssValue;
    1:           PRBool isSet = PR_FALSE;
    1:           mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(startNode,
    1:                                                     aProperty,
    1:                                                     aAttribute,
    1:                                                     isSet ,
    1:                                                     cssValue,
    1:                                                     COMPUTED_STYLE_TYPE);
    1:           if (isSet) {
    1:             // startNode's computed style indicates the CSS equivalence to the HTML style to
    1:             // remove is applied; but we found no element in the ancestors of startNode
    1:             // carrying specified styles; assume it comes from a rule and let's try to
    1:             // insert a span "inverting" the style
    1:             nsAutoString value; value.AssignLiteral("-moz-editor-invert-value");
    1:             PRInt32 startOffset, endOffset;
    1:             range->GetStartOffset(&startOffset);
    1:             range->GetEndOffset(&endOffset);
    1:             nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:             if (mHTMLCSSUtils->IsCSSInvertable(aProperty, aAttribute)) {
    1:               SetInlinePropertyOnTextNode(nodeAsText, startOffset, endOffset, aProperty, aAttribute, &value);
    1:             }
    1:           }
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // not the easy case.  range not contained in single text node. 
    1:         nsCOMPtr<nsIContentIterator> iter =
    1:           do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
43805:         NS_ENSURE_SUCCESS(res, res);
43806:         NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
    1: 
    1:         nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         
    1:         // iterate range and build up array
    1:         iter->Init(range);
    1:         while (!iter->IsDone())
    1:         {
    1:           node = do_QueryInterface(iter->GetCurrentNode());
43807:           NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:           if (IsEditable(node))
    1:           { 
    1:             arrayOfNodes.AppendObject(node);
    1:           }
    1: 
    1:           iter->Next();
    1:         }
    1:         
    1:         // loop through the list, remove the property on each node
    1:         PRInt32 listCount = arrayOfNodes.Count();
    1:         PRInt32 j;
    1:         for (j = 0; j < listCount; j++)
    1:         {
    1:           node = arrayOfNodes[j];
    1:           res = RemoveStyleInside(node, aProperty, aAttribute);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           if (useCSS && mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty, aAttribute)) {
    1:             // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:             // in this implementation for node
    1:             nsAutoString cssValue;
    1:             PRBool isSet = PR_FALSE;
    1:             mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node,
    1:                                                                aProperty,
    1:                                                                aAttribute,
    1:                                                                isSet ,
    1:                                                                cssValue,
    1:                                                                COMPUTED_STYLE_TYPE);
    1:             if (isSet) {
    1:               // startNode's computed style indicates the CSS equivalence to the HTML style to
    1:               // remove is applied; but we found no element in the ancestors of startNode
    1:               // carrying specified styles; assume it comes from a rule and let's try to
    1:               // insert a span "inverting" the style
    1:               if (mHTMLCSSUtils->IsCSSInvertable(aProperty, aAttribute)) {
    1:                 nsAutoString value; value.AssignLiteral("-moz-editor-invert-value");
    1:                 SetInlinePropertyOnNode(node, aProperty, aAttribute, &value);
    1:               }
    1:             }
    1:           }
    1:         }
    1:         arrayOfNodes.Clear();
    1:       }
    1:       enumerator->Next();
    1:     }
    1:   }
    1:   if (!cancel)
    1:   {
    1:     // post-process 
    1:     res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::IncreaseFontSize()
    1: {
    1:   return RelativeFontChange(1);
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::DecreaseFontSize()
    1: {
    1:   return RelativeFontChange(-1);
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RelativeFontChange( PRInt32 aSizeChange)
    1: {
    1:   // Can only change font size by + or - 1
    1:   if ( !( (aSizeChange==1) || (aSizeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   
    1:   ForceCompositionEnd();
    1: 
    1:   // Get the selection 
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));  
    1:   // Is the selection collapsed?
    1:   PRBool bCollapsed;
    1:   res = selection->GetIsCollapsed(&bCollapsed);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // if it's collapsed set typing state
    1:   if (bCollapsed)
    1:   {
    1:     nsCOMPtr<nsIAtom> atom;
    1:     if (aSizeChange==1) atom = nsEditProperty::big;
    1:     else                atom = nsEditProperty::small;
    1: 
    1:     // Let's see in what kind of element the selection is
    1:     PRInt32 offset;
    1:     nsCOMPtr<nsIDOMNode> selectedNode;
43518:     res = GetStartNodeAndOffset(selection, getter_AddRefs(selectedNode), &offset);
    1:     if (IsTextNode(selectedNode)) {
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       res = selectedNode->GetParentNode(getter_AddRefs(parent));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       selectedNode = parent;
    1:     }
    1:     nsAutoString tag;
    1:     atom->ToString(tag);
    1:     if (!CanContainTag(selectedNode, tag)) return NS_OK;
    1: 
    1:     // manipulating text attributes on a collapsed selection only sets state for the next text insertion
    1:     return mTypeInState->SetProp(atom, EmptyString(), EmptyString());
    1:   }
    1:   
    1:   // wrap with txn batching, rules sniffing, and selection preservation code
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpSetTextProperty, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1: 
    1:   // get selection range enumerator
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:   // loop thru the ranges in the selection
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
    1:   {
    1:     res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
    1:     
    1:     nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1: 
    1:     // adjust range to include any ancestors who's children are entirely selected
    1:     res = PromoteInlineRange(range);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // check for easy case: both range endpoints in same text node
    1:     nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:     res = range->GetStartContainer(getter_AddRefs(startNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = range->GetEndContainer(getter_AddRefs(endNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if ((startNode == endNode) && IsTextNode(startNode))
    1:     {
    1:       PRInt32 startOffset, endOffset;
    1:       range->GetStartOffset(&startOffset);
    1:       range->GetEndOffset(&endOffset);
    1:       nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:       res = RelativeFontChangeOnTextNode(aSizeChange, nodeAsText, startOffset, endOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else
    1:     {
    1:       // not the easy case.  range not contained in single text node. 
    1:       // there are up to three phases here.  There are all the nodes
    1:       // reported by the subtree iterator to be processed.  And there
    1:       // are potentially a starting textnode and an ending textnode
    1:       // which are only partially contained by the range.
    1:       
    1:       // lets handle the nodes reported by the iterator.  These nodes
    1:       // are entirely contained in the selection range.  We build up
    1:       // a list of them (since doing operations on the document during
    1:       // iteration would perturb the iterator).
    1: 
    1:       nsCOMPtr<nsIContentIterator> iter =
    1:         do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:       nsCOMPtr<nsIDOMNode> node;
    1:       
    1:       // iterate range and build up array
    1:       res = iter->Init(range);
    1:       if (NS_SUCCEEDED(res))
    1:       {
    1:         while (!iter->IsDone())
    1:         {
    1:           node = do_QueryInterface(iter->GetCurrentNode());
43807:           NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:           if (IsEditable(node))
    1:           { 
    1:             arrayOfNodes.AppendObject(node);
    1:           }
    1: 
    1:           iter->Next();
    1:         }
    1:         
    1:         // now that we have the list, do the font size change on each node
    1:         PRInt32 listCount = arrayOfNodes.Count();
    1:         PRInt32 j;
    1:         for (j = 0; j < listCount; j++)
    1:         {
    1:           node = arrayOfNodes[j];
    1:           res = RelativeFontChangeOnNode(aSizeChange, node);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         arrayOfNodes.Clear();
    1:       }
    1:       // now check the start and end parents of the range to see if they need to 
    1:       // be separately handled (they do if they are text nodes, due to how the
    1:       // subtree iterator works - it will not have reported them).
    1:       if (IsTextNode(startNode) && IsEditable(startNode))
    1:       {
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:         PRInt32 startOffset;
    1:         PRUint32 textLen;
    1:         range->GetStartOffset(&startOffset);
    1:         nodeAsText->GetLength(&textLen);
    1:         res = RelativeFontChangeOnTextNode(aSizeChange, nodeAsText, startOffset, textLen);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       if (IsTextNode(endNode) && IsEditable(endNode))
    1:       {
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(endNode);
    1:         PRInt32 endOffset;
    1:         range->GetEndOffset(&endOffset);
    1:         res = RelativeFontChangeOnTextNode(aSizeChange, nodeAsText, 0, endOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     enumerator->Next();
    1:   }
    1:   
    1:   return res;  
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RelativeFontChangeOnTextNode( PRInt32 aSizeChange, 
    1:                                             nsIDOMCharacterData *aTextNode, 
    1:                                             PRInt32 aStartOffset,
    1:                                             PRInt32 aEndOffset)
    1: {
    1:   // Can only change font size by + or - 1
    1:   if ( !( (aSizeChange==1) || (aSizeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
43806:   NS_ENSURE_TRUE(aTextNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   // don't need to do anything if no characters actually selected
    1:   if (aStartOffset == aEndOffset) return NS_OK;
    1:   
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   res = aTextNode->GetParentNode(getter_AddRefs(parent));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!CanContainTag(parent, NS_LITERAL_STRING("big"))) return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMNode> tmp, node = do_QueryInterface(aTextNode);
    1: 
    1:   // do we need to split the text node?
    1:   PRUint32 textLen;
    1:   aTextNode->GetLength(&textLen);
    1:   
    1:   // -1 is a magic value meaning to the end of node
    1:   if (aEndOffset == -1) aEndOffset = textLen;
    1:   
    1:   if ( (PRUint32)aEndOffset != textLen )
    1:   {
    1:     // we need to split off back of text node
    1:     res = SplitNode(node, aEndOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     node = tmp;  // remember left node
    1:   }
    1:   if ( aStartOffset )
    1:   {
    1:     // we need to split off front of text node
    1:     res = SplitNode(node, aStartOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   NS_NAMED_LITERAL_STRING(bigSize, "big");
    1:   NS_NAMED_LITERAL_STRING(smallSize, "small");
 3233:   const nsAString& nodeType = (aSizeChange==1) ? static_cast<const nsAString&>(bigSize) : static_cast<const nsAString&>(smallSize);
    1:   // look for siblings that are correct type of node
    1:   nsCOMPtr<nsIDOMNode> sibling;
    1:   GetPriorHTMLSibling(node, address_of(sibling));
    1:   if (sibling && NodeIsType(sibling, (aSizeChange==1) ? nsEditProperty::big : nsEditProperty::small))
    1:   {
    1:     // previous sib is already right kind of inline node; slide this over into it
    1:     res = MoveNode(node, sibling, -1);
    1:     return res;
    1:   }
    1:   sibling = nsnull;
    1:   GetNextHTMLSibling(node, address_of(sibling));
    1:   if (sibling && NodeIsType(sibling, (aSizeChange==1) ? nsEditProperty::big : nsEditProperty::small))
    1:   {
    1:     // following sib is already right kind of inline node; slide this over into it
    1:     res = MoveNode(node, sibling, 0);
    1:     return res;
    1:   }
    1:   
    1:   // else reparent the node inside font node with appropriate relative size
    1:   res = InsertContainerAbove(node, address_of(tmp), nodeType);
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::RelativeFontChangeHelper( PRInt32 aSizeChange, 
    1:                                         nsIDOMNode *aNode)
    1: {
    1:   /*  This routine looks for all the font nodes in the tree rooted by aNode,
    1:       including aNode itself, looking for font nodes that have the size attr
    1:       set.  Any such nodes need to have big or small put inside them, since
    1:       they override any big/small that are above them.
    1:   */
    1:   
    1:   // Can only change font size by + or - 1
    1:   if ( !( (aSizeChange==1) || (aSizeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult res = NS_OK;
    1:   nsAutoString tag;
    1:   if (aSizeChange == 1) tag.AssignLiteral("big");
    1:   else tag.AssignLiteral("small");
    1:   nsCOMPtr<nsIDOMNodeList> childNodes;
    1:   PRInt32 j;
    1:   PRUint32 childCount;
    1:   nsCOMPtr<nsIDOMNode> childNode;
    1:   
    1:   // if this is a font node with size, put big/small inside it
    1:   NS_NAMED_LITERAL_STRING(attr, "size");
    1:   if (NodeIsType(aNode, nsEditProperty::font) && HasAttr(aNode, &attr))
    1:   {
    1:     // cycle through children and adjust relative font size
    1:     res = aNode->GetChildNodes(getter_AddRefs(childNodes));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (childNodes)
    1:     {
    1:       childNodes->GetLength(&childCount);
    1:       for (j=childCount-1; j>=0; j--)
    1:       {
    1:         res = childNodes->Item(j, getter_AddRefs(childNode));
    1:         if ((NS_SUCCEEDED(res)) && (childNode))
    1:         {
    1:           res = RelativeFontChangeOnNode(aSizeChange, childNode);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   childNodes = nsnull;
    1:   // now cycle through the children.
    1:   res = aNode->GetChildNodes(getter_AddRefs(childNodes));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (childNodes)
    1:   {
    1:     childNodes->GetLength(&childCount);
    1:     for (j=childCount-1; j>=0; j--)
    1:     {
    1:       res = childNodes->Item(j, getter_AddRefs(childNode));
    1:       if ((NS_SUCCEEDED(res)) && (childNode))
    1:       {
    1:         res = RelativeFontChangeHelper(aSizeChange, childNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::RelativeFontChangeOnNode( PRInt32 aSizeChange, 
    1:                                         nsIDOMNode *aNode)
    1: {
    1:   // Can only change font size by + or - 1
    1:   if ( !( (aSizeChange==1) || (aSizeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1:   nsAutoString tag;
    1:   if (aSizeChange == 1) tag.AssignLiteral("big");
    1:   else tag.AssignLiteral("small");
    1:   
    1:   // is it the opposite of what we want?  
    1:   if ( ((aSizeChange == 1) && nsHTMLEditUtils::IsSmall(aNode)) || 
    1:        ((aSizeChange == -1) &&  nsHTMLEditUtils::IsBig(aNode)) )
    1:   {
    1:     // first populate any nested font tags that have the size attr set
    1:     res = RelativeFontChangeHelper(aSizeChange, aNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // in that case, just remove this node and pull up the children
    1:     res = RemoveContainer(aNode);
    1:     return res;
    1:   }
    1:   // can it be put inside a "big" or "small"?
    1:   if (TagCanContain(tag, aNode))
    1:   {
    1:     // first populate any nested font tags that have the size attr set
    1:     res = RelativeFontChangeHelper(aSizeChange, aNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     // ok, chuck it in.
    1:     // first look at siblings of aNode for matching bigs or smalls.
    1:     // if we find one, move aNode into it.
    1:     nsCOMPtr<nsIDOMNode> sibling;
    1:     GetPriorHTMLSibling(aNode, address_of(sibling));
    1:     if (sibling && nsEditor::NodeIsType(sibling, (aSizeChange==1 ? nsEditProperty::big : nsEditProperty::small)))
    1:     {
    1:       // previous sib is already right kind of inline node; slide this over into it
    1:       res = MoveNode(aNode, sibling, -1);
    1:       return res;
    1:     }
    1:     sibling = nsnull;
    1:     GetNextHTMLSibling(aNode, address_of(sibling));
    1:     if (sibling && nsEditor::NodeIsType(sibling, (aSizeChange==1 ? nsEditProperty::big : nsEditProperty::small)))
    1:     {
    1:       // following sib is already right kind of inline node; slide this over into it
    1:       res = MoveNode(aNode, sibling, 0);
    1:       return res;
    1:     }
    1:     // else insert it above aNode
    1:     res = InsertContainerAbove(aNode, address_of(tmp), tag);
    1:     return res;
    1:   }
    1:   // none of the above?  then cycle through the children.
    1:   // MOOSE: we should group the children together if possible
    1:   // into a single "big" or "small".  For the moment they are
    1:   // each getting their own.  
    1:   nsCOMPtr<nsIDOMNodeList> childNodes;
    1:   res = aNode->GetChildNodes(getter_AddRefs(childNodes));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (childNodes)
    1:   {
    1:     PRInt32 j;
    1:     PRUint32 childCount;
    1:     childNodes->GetLength(&childCount);
    1:     for (j=childCount-1; j>=0; j--)
    1:     {
    1:       nsCOMPtr<nsIDOMNode> childNode;
    1:       res = childNodes->Item(j, getter_AddRefs(childNode));
    1:       if ((NS_SUCCEEDED(res)) && (childNode))
    1:       {
    1:         res = RelativeFontChangeOnNode(aSizeChange, childNode);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetFontFaceState(PRBool *aMixed, nsAString &outFace)
    1: {
43807:   NS_ENSURE_TRUE(aMixed, NS_ERROR_FAILURE);
    1:   *aMixed = PR_TRUE;
    1:   outFace.Truncate();
    1: 
    1:   nsresult res;
    1:   PRBool first, any, all;
    1:   
    1:   NS_NAMED_LITERAL_STRING(attr, "face");
    1:   res = GetInlinePropertyBase(nsEditProperty::font, &attr, nsnull, &first, &any, &all, &outFace);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (any && !all) return res; // mixed
    1:   if (all)
    1:   {
    1:     *aMixed = PR_FALSE;
    1:     return res;
    1:   }
    1:   
    1:   // if there is no font face, check for tt
    1:   res = GetInlinePropertyBase(nsEditProperty::tt, nsnull, nsnull, &first, &any, &all,nsnull);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (any && !all) return res; // mixed
    1:   if (all)
    1:   {
    1:     *aMixed = PR_FALSE;
    1:     nsEditProperty::tt->ToString(outFace);
    1:   }
    1:   
    1:   if (!any)
    1:   {
    1:     // there was no font face attrs of any kind.  We are in normal font.
    1:     outFace.Truncate();
    1:     *aMixed = PR_FALSE;
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLEditor::GetFontColorState(PRBool *aMixed, nsAString &aOutColor)
    1: {
43807:   NS_ENSURE_TRUE(aMixed, NS_ERROR_NULL_POINTER);
    1:   *aMixed = PR_TRUE;
    1:   aOutColor.Truncate();
    1:   
    1:   nsresult res;
    1:   NS_NAMED_LITERAL_STRING(colorStr, "color");
    1:   PRBool first, any, all;
    1:   
    1:   res = GetInlinePropertyBase(nsEditProperty::font, &colorStr, nsnull, &first, &any, &all, &aOutColor);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (any && !all) return res; // mixed
    1:   if (all)
    1:   {
    1:     *aMixed = PR_FALSE;
    1:     return res;
    1:   }
    1:   
    1:   if (!any)
    1:   {
    1:     // there was no font color attrs of any kind..
    1:     aOutColor.Truncate();
    1:     *aMixed = PR_FALSE;
    1:   }
    1:   return res;
    1: }
    1: 
    1: // the return value is true only if the instance of the HTML editor we created
    1: // can handle CSS styles (for instance, Composer can, Messenger can't) and if
    1: // the CSS preference is checked
    1: nsresult
    1: nsHTMLEditor::GetIsCSSEnabled(PRBool *aIsCSSEnabled)
    1: {
    1:   *aIsCSSEnabled = PR_FALSE;
    1:   if (mCSSAware) {
    1:     // TBD later : removal of mCSSAware and use only the presence of mHTMLCSSUtils
    1:     if (mHTMLCSSUtils) {
    1:       *aIsCSSEnabled = mHTMLCSSUtils->IsCSSPrefChecked();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::HasStyleOrIdOrClass(nsIDOMElement * aElement, PRBool *aHasStyleOrIdOrClass)
    1: {
    1:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> node  = do_QueryInterface(aElement);
    1: 
    1: 
    1:   // remove the node if its style attribute is empty or absent,
    1:   // and if it does not have a class nor an id
    1:   nsAutoString styleVal;
    1:   PRBool isStyleSet;
    1:   *aHasStyleOrIdOrClass = PR_TRUE;
    1:   nsresult res = GetAttributeValue(aElement,  NS_LITERAL_STRING("style"), styleVal, &isStyleSet);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!isStyleSet || styleVal.IsEmpty()) {
    1:     res = mHTMLCSSUtils->HasClassOrID(aElement, *aHasStyleOrIdOrClass);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RemoveElementIfNoStyleOrIdOrClass(nsIDOMElement * aElement, nsIAtom * aTag)
    1: {
    1:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> node  = do_QueryInterface(aElement);
    1: 
    1:   // early way out if node is not the right kind of element
    1:   if (!NodeIsType(node, aTag)) {
    1:     return NS_OK;
    1:   }
    1:   PRBool hasStyleOrIdOrClass;
    1:   nsresult res = HasStyleOrIdOrClass(aElement, &hasStyleOrIdOrClass);
    1:   if (!hasStyleOrIdOrClass) {
    1:     res = RemoveContainer(node);
    1:   }
    1:   return res;
    1: }
