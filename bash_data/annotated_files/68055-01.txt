41954: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
41954: /* vim:set ts=2 sw=2 sts=2 et cindent: */
41954: /* ***** BEGIN LICENSE BLOCK *****
41954:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41954:  *
41954:  * The contents of this file are subject to the Mozilla Public License Version
41954:  * 1.1 (the "License"); you may not use this file except in compliance with
41954:  * the License. You may obtain a copy of the License at
41954:  * http://www.mozilla.org/MPL/
41954:  *
41954:  * Software distributed under the License is distributed on an "AS IS" basis,
41954:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41954:  * for the specific language governing rights and limitations under the
41954:  * License.
41954:  *
41954:  * The Original Code is Mozilla code.
41954:  *
41954:  * The Initial Developer of the Original Code is the Mozilla Corporation.
41954:  * Portions created by the Initial Developer are Copyright (C) 2007
41954:  * the Initial Developer. All Rights Reserved.
41954:  *
41954:  * Contributor(s):
41954:  *  Chris Double <chris.double@double.co.nz>
41954:  *  Chris Pearce <chris@pearce.org.nz>
41954:  *
41954:  * Alternatively, the contents of this file may be used under the terms of
41954:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41954:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41954:  * in which case the provisions of the GPL or the LGPL are applicable instead
41954:  * of those above. If you wish to allow use of your version of this file only
41954:  * under the terms of either the GPL or the LGPL, and not to allow others to
41954:  * use your version of this file under the terms of the MPL, indicate your
41954:  * decision by deleting the provisions above and replace them with the notice
41954:  * and other provisions required by the GPL or the LGPL. If you do not delete
41954:  * the provisions above, a recipient may use your version of this file under
41954:  * the terms of any one of the MPL, the GPL or the LGPL.
41954:  *
41954:  * ***** END LICENSE BLOCK ***** */
41954: #include "nsError.h"
41954: #include "nsBuiltinDecoderStateMachine.h"
41954: #include "nsBuiltinDecoder.h"
41954: #include "nsOggReader.h"
41954: #include "VideoUtils.h"
41954: #include "theora/theoradec.h"
51394: #include "nsTimeRanges.h"
63612: #include "mozilla/TimeStamp.h"
41954: 
41954: using namespace mozilla;
41954: 
41954: // Un-comment to enable logging of seek bisections.
41954: //#define SEEK_LOGGING
41954: 
41954: #ifdef PR_LOGGING
41954: extern PRLogModuleInfo* gBuiltinDecoderLog;
41954: #define LOG(type, msg) PR_LOG(gBuiltinDecoderLog, type, msg)
41954: #ifdef SEEK_LOGGING
41954: #define SEEK_LOG(type, msg) PR_LOG(gBuiltinDecoderLog, type, msg)
41954: #else
41954: #define SEEK_LOG(type, msg)
41954: #endif
41954: #else
41954: #define LOG(type, msg)
41954: #define SEEK_LOG(type, msg)
41954: #endif
41954: 
50947: // If we don't have a Theora video stream, then during seeking, if a seek
50947: // target is less than SEEK_DECODE_MARGIN ahead of the current playback
50947: // position, we'll just decode forwards rather than performing a bisection
50947: // search. If we have Theora video we use the maximum keyframe interval as
50947: // this value, rather than SEEK_DECODE_MARGIN. This makes small seeks faster.
64570: #define SEEK_DECODE_MARGIN 2000
50947: 
64570: // The number of milliseconds of "fuzz" we use in a bisection search over
50947: // HTTP. When we're seeking with fuzz, we'll stop the search if a bisection
64570: // lands between the seek target and SEEK_FUZZ_MS milliseconds before the
50947: // seek target.  This is becaue it's usually quicker to just keep downloading
50947: // from an exisiting connection than to do another bisection inside that
50947: // small range, which would open a new HTTP connetion.
64570: #define SEEK_FUZZ_MS 500
50947: 
50947: enum PageSyncResult {
50947:   PAGE_SYNC_ERROR = 1,
50947:   PAGE_SYNC_END_OF_RANGE= 2,
50947:   PAGE_SYNC_OK = 3
50947: };
50947: 
50947: // Reads a page from the media stream.
50947: static PageSyncResult
50947: PageSync(nsMediaStream* aStream,
50947:          ogg_sync_state* aState,
50947:          PRBool aCachedDataOnly,
50947:          PRInt64 aOffset,
50947:          PRInt64 aEndOffset,
50947:          ogg_page* aPage,
50947:          int& aSkippedBytes);
50947: 
41954: // Chunk size to read when reading Ogg files. Average Ogg page length
41954: // is about 4300 bytes, so we read the file in chunks larger than that.
41954: static const int PAGE_STEP = 8192;
41954: 
41954: nsOggReader::nsOggReader(nsBuiltinDecoder* aDecoder)
41954:   : nsBuiltinDecoderReader(aDecoder),
41954:     mTheoraState(nsnull),
41954:     mVorbisState(nsnull),
50947:     mSkeletonState(nsnull),
59429:     mVorbisSerial(0),
59429:     mTheoraSerial(0),
41954:     mPageOffset(0),
41954:     mTheoraGranulepos(-1),
41954:     mVorbisGranulepos(-1)
41954: {
41954:   MOZ_COUNT_CTOR(nsOggReader);
41954: }
41954: 
41954: nsOggReader::~nsOggReader()
41954: {
41954:   ogg_sync_clear(&mOggState);
41954:   MOZ_COUNT_DTOR(nsOggReader);
41954: }
41954: 
54993: nsresult nsOggReader::Init(nsBuiltinDecoderReader* aCloneDonor) {
41954:   PRBool init = mCodecStates.Init();
41954:   NS_ASSERTION(init, "Failed to initialize mCodecStates");
41954:   if (!init) {
41954:     return NS_ERROR_FAILURE;
41954:   }
41954:   int ret = ogg_sync_init(&mOggState);
41954:   NS_ENSURE_TRUE(ret == 0, NS_ERROR_FAILURE);
41954:   return NS_OK;
41954: }
41954: 
41954: nsresult nsOggReader::ResetDecode()
41954: {
41954:   nsresult res = NS_OK;
41954: 
41954:   // Clear the Theora/Vorbis granulepos capture status, so that the next
41954:   // decode calls recaptures the granulepos.
41954:   mTheoraGranulepos = -1;
41954:   mVorbisGranulepos = -1;
41954: 
41954:   if (NS_FAILED(nsBuiltinDecoderReader::ResetDecode())) {
41954:     res = NS_ERROR_FAILURE;
41954:   }
41954: 
41954:   {
41954:     MonitorAutoEnter mon(mMonitor);
41954: 
41954:     // Discard any previously buffered packets/pages.
41954:     ogg_sync_reset(&mOggState);
41954:     if (mVorbisState && NS_FAILED(mVorbisState->Reset())) {
41954:       res = NS_ERROR_FAILURE;
41954:     }
41954:     if (mTheoraState && NS_FAILED(mTheoraState->Reset())) {
41954:       res = NS_ERROR_FAILURE;
41954:     }
41954:   }
41954: 
41954:   return res;
41954: }
41954: 
41954: // Returns PR_TRUE when all bitstreams in aBitstreams array have finished
41954: // reading their headers.
41954: static PRBool DoneReadingHeaders(nsTArray<nsOggCodecState*>& aBitstreams) {
41954:   for (PRUint32 i = 0; i < aBitstreams .Length(); i++) {
41954:     if (!aBitstreams [i]->DoneReadingHeaders()) {
41954:       return PR_FALSE;
41954:     }
41954:   }
41954:   return PR_TRUE;
41954: }
41954: 
63857: nsresult nsOggReader::ReadMetadata(nsVideoInfo* aInfo)
41954: {
41954:   NS_ASSERTION(mDecoder->OnStateMachineThread(), "Should be on play state machine thread.");
41954:   MonitorAutoEnter mon(mMonitor);
41954: 
41954:   // We read packets until all bitstreams have read all their header packets.
41954:   // We record the offset of the first non-header page so that we know
41954:   // what page to seek to when seeking to the media start.
41954: 
41954:   ogg_page page;
41954:   PRInt64 pageOffset;
41954:   nsAutoTArray<nsOggCodecState*,4> bitstreams;
41954:   PRBool readAllBOS = PR_FALSE;
41954:   mDataOffset = 0;
41954:   while (PR_TRUE) {
41954:     if (readAllBOS && DoneReadingHeaders(bitstreams)) {
41954:       if (mDataOffset == 0) {
41954:         // We've previously found the start of the first non-header packet.
41954:         mDataOffset = mPageOffset;
41954:       }
41954:       break;
41954:     }
41954:     pageOffset = ReadOggPage(&page);
41954:     if (pageOffset == -1) {
41954:       // Some kind of error...
41954:       break;
41954:     }
41954: 
41954:     int ret = 0;
41954:     int serial = ogg_page_serialno(&page);
41954:     nsOggCodecState* codecState = 0;
41954: 
41954:     if (ogg_page_bos(&page)) {
41954:       NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
41954:       codecState = nsOggCodecState::Create(&page);
64059: 
64059: #ifdef DEBUG
64059:       PRBool r =
64059: #endif
64059:         mCodecStates.Put(serial, codecState);
41954:       NS_ASSERTION(r, "Failed to insert into mCodecStates");
41954:       bitstreams.AppendElement(codecState);
59429:       mKnownStreams.AppendElement(serial);
41954:       if (codecState &&
41954:           codecState->GetType() == nsOggCodecState::TYPE_VORBIS &&
41954:           !mVorbisState)
41954:       {
41954:         // First Vorbis bitstream, we'll play this one. Subsequent Vorbis
41954:         // bitstreams will be ignored.
41954:         mVorbisState = static_cast<nsVorbisState*>(codecState);
41954:       }
41954:       if (codecState &&
41954:           codecState->GetType() == nsOggCodecState::TYPE_THEORA &&
41954:           !mTheoraState)
41954:       {
41954:         // First Theora bitstream, we'll play this one. Subsequent Theora
41954:         // bitstreams will be ignored.
41954:         mTheoraState = static_cast<nsTheoraState*>(codecState);
41954:       }
50947:       if (codecState &&
50947:           codecState->GetType() == nsOggCodecState::TYPE_SKELETON &&
50947:           !mSkeletonState)
50947:       {
50947:         mSkeletonState = static_cast<nsSkeletonState*>(codecState);
50947:       }
41954:     } else {
41954:       // We've encountered the a non Beginning Of Stream page. No more
41954:       // BOS pages can follow in this Ogg segment, so there will be no other
41954:       // bitstreams in the Ogg (unless it's invalid).
41954:       readAllBOS = PR_TRUE;
41954:     }
41954: 
41954:     mCodecStates.Get(serial, &codecState);
41954:     NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
41954: 
41954:     // Add a complete page to the bitstream
41954:     ret = ogg_stream_pagein(&codecState->mState, &page);
41954:     NS_ENSURE_TRUE(ret == 0, NS_ERROR_FAILURE);
41954: 
41954:     // Process all available header packets in the stream.
41954:     ogg_packet packet;
41954:     if (codecState->DoneReadingHeaders() && mDataOffset == 0)
41954:     {
41954:       // Stream has read all header packets, but now there's more data in
41954:       // (presumably) a non-header page, we must have finished header packets.
41954:       // This can happen in incorrectly chopped streams.
41954:       mDataOffset = pageOffset;
41954:       continue;
41954:     }
41954:     while (!codecState->DoneReadingHeaders() &&
41954:            (ret = ogg_stream_packetout(&codecState->mState, &packet)) != 0)
41954:     {
41954:       if (ret == -1) {
41954:         // Sync lost, we've probably encountered the continuation of a packet
41954:         // in a chopped video.
41954:         continue;
41954:       }
41954:       // A packet is available. If it is not a header packet we'll break.
41954:       // If it is a header packet, process it as normal.
41954:       codecState->DecodeHeader(&packet);
41954:     }
41954:     if (ogg_stream_packetpeek(&codecState->mState, &packet) != 0 &&
41954:         mDataOffset == 0)
41954:     {
41954:       // We're finished reading headers for this bitstream, but there's still
41954:       // packets in the bitstream to read. The bitstream is probably poorly
41954:       // muxed, and includes the last header packet on a page with non-header
41954:       // packets. We need to ensure that this is the media start page offset.
41954:       mDataOffset = pageOffset;
41954:     }
41954:   }
41954:   // Deactivate any non-primary bitstreams.
41954:   for (PRUint32 i = 0; i < bitstreams.Length(); i++) {
41954:     nsOggCodecState* s = bitstreams[i];
50947:     if (s != mVorbisState && s != mTheoraState && s != mSkeletonState) {
41954:       s->Deactivate();
41954:     }
41954:   }
41954: 
41954:   // Initialize the first Theora and Vorbis bitstreams. According to the
41954:   // Theora spec these can be considered the 'primary' bitstreams for playback.
41954:   // Extract the metadata needed from these streams.
42438:   // Set a default callback period for if we have no video data
53767:   if (mTheoraState && mTheoraState->Init()) {
41954:     gfxIntSize sz(mTheoraState->mInfo.pic_width,
41954:                   mTheoraState->mInfo.pic_height);
63612:     mDecoder->SetVideoData(sz, mTheoraState->mPixelAspectRatio, nsnull, TimeStamp::Now());
41954:   }
41954:   if (mVorbisState) {
41954:     mVorbisState->Init();
41954:   }
41954: 
50947:   if (!HasAudio() && !HasVideo() && mSkeletonState) {
50947:     // We have a skeleton track, but no audio or video, may as well disable
50947:     // the skeleton, we can't do anything useful with this media.
50947:     mSkeletonState->Deactivate();
50947:   }
50947: 
42438:   mInfo.mHasAudio = HasAudio();
42438:   mInfo.mHasVideo = HasVideo();
41954:   if (HasAudio()) {
42438:     mInfo.mAudioRate = mVorbisState->mInfo.rate;
42438:     mInfo.mAudioChannels = mVorbisState->mInfo.channels;
41954:   }
41954:   if (HasVideo()) {
42580:     mInfo.mPixelAspectRatio = mTheoraState->mPixelAspectRatio;
61490:     mInfo.mPicture = nsIntRect(mTheoraState->mInfo.pic_x,
61490:                                mTheoraState->mInfo.pic_y,
61490:                                mTheoraState->mInfo.pic_width,
61490:                                mTheoraState->mInfo.pic_height);
61490:     mInfo.mFrame = nsIntSize(mTheoraState->mInfo.frame_width,
61490:                              mTheoraState->mInfo.frame_height);
61490:     mInfo.mDisplay = nsIntSize(mInfo.mPicture.width,
61490:                                mInfo.mPicture.height);
41954:   }
42438:   mInfo.mDataOffset = mDataOffset;
41954: 
50947:   if (mSkeletonState && mSkeletonState->HasIndex()) {
50947:     // Extract the duration info out of the index, so we don't need to seek to
50947:     // the end of stream to get it.
50947:     nsAutoTArray<PRUint32, 2> tracks;
50947:     if (HasVideo()) {
50947:       tracks.AppendElement(mTheoraState->mSerial);
50947:     }
50947:     if (HasAudio()) {
50947:       tracks.AppendElement(mVorbisState->mSerial);
50947:     }
50947:     PRInt64 duration = 0;
50947:     if (NS_SUCCEEDED(mSkeletonState->GetDuration(tracks, duration))) {
50947:       MonitorAutoExit exitReaderMon(mMonitor);
50947:       MonitorAutoEnter decoderMon(mDecoder->GetMonitor());
50947:       mDecoder->GetStateMachine()->SetDuration(duration);
50947:       LOG(PR_LOG_DEBUG, ("Got duration from Skeleton index %lld", duration));
50947:     }
50947:   }
50947: 
59429:   // Copy Vorbis and Theora info data for time computations on other threads.
59429:   if (mVorbisState) {
59429:     memcpy(&mVorbisInfo, &mVorbisState->mInfo, sizeof(mVorbisInfo));
59429:     mVorbisInfo.codec_setup = NULL;
59429:     mVorbisSerial = mVorbisState->mSerial;
59429:   }
59429: 
59429:   if (mTheoraState) {
59429:     memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
59429:     mTheoraSerial = mTheoraState->mSerial;
59429:   }
59429: 
63857:   *aInfo = mInfo;
63857: 
41954:   LOG(PR_LOG_DEBUG, ("Done loading headers, data offset %lld", mDataOffset));
41954: 
41954:   return NS_OK;
41954: }
41954: 
53829: nsresult nsOggReader::DecodeVorbis(nsTArray<nsAutoPtr<SoundData> >& aChunks,
41954:                                    ogg_packet* aPacket)
41954: {
41954:   // Successfully read a packet.
41954:   if (vorbis_synthesis(&mVorbisState->mBlock, aPacket) != 0) {
41954:     return NS_ERROR_FAILURE;
41954:   }
41954:   if (vorbis_synthesis_blockin(&mVorbisState->mDsp,
41954:                                &mVorbisState->mBlock) != 0)
41954:   {
41954:     return NS_ERROR_FAILURE;
41954:   }
41954: 
56070:   VorbisPCMValue** pcm = 0;
50359:   PRInt32 samples = 0;
41954:   PRUint32 channels = mVorbisState->mInfo.channels;
41954:   while ((samples = vorbis_synthesis_pcmout(&mVorbisState->mDsp, &pcm)) > 0) {
56070:     SoundDataValue* buffer = new SoundDataValue[samples * channels];
56070:     for (PRUint32 j = 0; j < channels; ++j) {
56070:       VorbisPCMValue* channel = pcm[j];
53765:       for (PRUint32 i = 0; i < PRUint32(samples); ++i) {
56070:         buffer[i*channels + j] = MOZ_CONVERT_VORBIS_SAMPLE(channel[i]);
41954:       }
41954:     }
41954: 
41954:     PRInt64 duration = mVorbisState->Time((PRInt64)samples);
64570:     PRInt64 startTime = (mVorbisGranulepos != -1) ?
64570:       mVorbisState->Time(mVorbisGranulepos) : -1;
41954:     SoundData* s = new SoundData(mPageOffset,
41954:                                  startTime,
41954:                                  duration,
41954:                                  samples,
41954:                                  buffer,
41954:                                  channels);
41954:     if (mVorbisGranulepos != -1) {
41954:       mVorbisGranulepos += samples;
41954:     }
53829:     if (!aChunks.AppendElement(s)) {
53829:       delete s;
53829:     }
41954:     if (vorbis_synthesis_read(&mVorbisState->mDsp, samples) != 0) {
41954:       return NS_ERROR_FAILURE;
41954:     }
41954:   }
41954:   return NS_OK;
41954: }
41954: 
41954: PRBool nsOggReader::DecodeAudioData()
41954: {
41954:   MonitorAutoEnter mon(mMonitor);
41954:   NS_ASSERTION(mDecoder->OnStateMachineThread() || mDecoder->OnDecodeThread(),
41954:                "Should be on playback or decode thread.");
41954:   NS_ASSERTION(mVorbisState!=0, "Need Vorbis state to decode audio");
41954:   ogg_packet packet;
41954:   packet.granulepos = -1;
41954: 
41954:   PRBool endOfStream = PR_FALSE;
41954: 
53829:   nsAutoTArray<nsAutoPtr<SoundData>, 64> chunks;
41954:   if (mVorbisGranulepos == -1) {
41954:     // Not captured Vorbis granulepos, read up until we get a granulepos, and
41954:     // back propagate the granulepos.
41954: 
41954:     // We buffer the packets' pcm samples until we reach a packet with a granulepos.
41954:     // This will be the last packet in a page. Then using that granulepos to 
41954:     // calculate the packet's end time, we calculate all the packets' start times by
41954:     // subtracting their durations.
41954: 
41954:     // Ensure we've got Vorbis packets; read one more Vorbis page if necessary.
41954:     while (packet.granulepos <= 0 && !endOfStream) {
41954:       if (!ReadOggPacket(mVorbisState, &packet)) {
41954:         endOfStream = PR_TRUE;
41954:         break;
41954:       }
41954:       if (packet.e_o_s != 0) {
41954:         // This packet marks the logical end of the Vorbis bitstream. It may
41954:         // still contain sound samples, so we must still decode it.
41954:         endOfStream = PR_TRUE;
41954:       }
41954: 
41954:       if (NS_FAILED(DecodeVorbis(chunks, &packet))) {
41954:         NS_WARNING("Failed to decode Vorbis packet");
41954:       }
41954:     }
41954: 
41954:     if (packet.granulepos > 0) {
41954:       // Successfully read up to a non -1 granulepos.
41954:       // Calculate the timestamps of the sound samples.
41954:       PRInt64 granulepos = packet.granulepos; // Represents end time of last sample.
41954:       mVorbisGranulepos = packet.granulepos;
41954:       for (int i = chunks.Length() - 1; i >= 0; --i) {
41954:         SoundData* s = chunks[i];
41954:         PRInt64 startGranule = granulepos - s->mSamples;
41954:         s->mTime = mVorbisState->Time(startGranule);
41954:         granulepos = startGranule;
41954:       }
41954:     }
41954:   } else {
41954:     // We have already captured the granulepos. The next packet's granulepos
41954:     // is its number of samples, plus the previous granulepos.
41954:     if (!ReadOggPacket(mVorbisState, &packet)) {
41954:       endOfStream = PR_TRUE;
41954:     } else {
41954:       // Successfully read a packet from the file. Decode it.
41954:       endOfStream = packet.e_o_s != 0;
41954: 
41954:       // Try to decode any packet we've read.
41954:       if (NS_FAILED(DecodeVorbis(chunks, &packet))) {
41954:         NS_WARNING("Failed to decode Vorbis packet");
41954:       }
41954: 
41954:       if (packet.granulepos != -1 && packet.granulepos != mVorbisGranulepos) {
41954:         // If the packet's granulepos doesn't match our running sample total,
41954:         // it's likely the bitstream has been damaged somehow, or perhaps
41954:         // oggz-chopped. Just assume the packet's granulepos is correct...
41954:         mVorbisGranulepos = packet.granulepos;
41954:       }
41954:     }
41954:   }
41954: 
41954:   // We've successfully decoded some sound chunks. Push them onto the audio
41954:   // queue.
41954:   for (PRUint32 i = 0; i < chunks.Length(); ++i) {
53829:     mAudioQueue.Push(chunks[i].forget());
41954:   }
41954: 
41954:   if (endOfStream) {
41954:     // We've encountered an end of bitstream packet, or we've hit the end of
41954:     // file while trying to decode, so inform the audio queue that there'll
41954:     // be no more samples.
41954:     mAudioQueue.Finish();
41954:     return PR_FALSE;
41954:   }
41954: 
41954:   return PR_TRUE;
41954: }
41954: 
41954: // Returns 1 if the Theora info struct is decoding a media of Theora
41954: // verion (maj,min,sub) or later, otherwise returns 0.
41954: static int
41954: TheoraVersion(th_info* info,
41954:               unsigned char maj,
41954:               unsigned char min,
41954:               unsigned char sub)
41954: {
41954:   ogg_uint32_t ver = (maj << 16) + (min << 8) + sub;
41954:   ogg_uint32_t th_ver = (info->version_major << 16) +
41954:                         (info->version_minor << 8) +
41954:                         info->version_subminor;
41954:   return (th_ver >= ver) ? 1 : 0;
41954: }
41954: 
41954: #ifdef DEBUG
41954: // Ensures that all the VideoData in aFrames array are stored in increasing
41954: // order by timestamp. Used in assertions in debug builds.
41954: static PRBool
53829: AllFrameTimesIncrease(nsTArray<nsAutoPtr<VideoData> >& aFrames)
41954: {
41954:   PRInt64 prevTime = -1;
41954:   PRInt64 prevGranulepos = -1;
41954:   for (PRUint32 i = 0; i < aFrames.Length(); i++) {
41954:     VideoData* f = aFrames[i];
41954:     if (f->mTime < prevTime) {
41954:       return PR_FALSE;
41954:     }
41954:     prevTime = f->mTime;
41954:     prevGranulepos = f->mTimecode;
41954:   }
41954: 
41954:   return PR_TRUE;
41954: }
41954: #endif
41954: 
53829: nsresult nsOggReader::DecodeTheora(nsTArray<nsAutoPtr<VideoData> >& aFrames,
41954:                                    ogg_packet* aPacket)
41954: {
41954:   int ret = th_decode_packetin(mTheoraState->mCtx, aPacket, 0);
41954:   if (ret != 0 && ret != TH_DUPFRAME) {
41954:     return NS_ERROR_FAILURE;
41954:   }
64570:   PRInt64 time = (aPacket->granulepos != -1)
64570:     ? mTheoraState->StartTime(aPacket->granulepos) : -1;
64570:   PRInt64 endTime = time != -1 ? time + mTheoraState->mFrameDuration : -1;
41954:   if (ret == TH_DUPFRAME) {
53829:     VideoData* v = VideoData::CreateDuplicate(mPageOffset,
41954:                                               time,
47961:                                               endTime,
53829:                                               aPacket->granulepos);
53829:     if (!aFrames.AppendElement(v)) {
53829:       delete v;
53829:     }
41954:   } else if (ret == 0) {
41954:     th_ycbcr_buffer buffer;
41954:     ret = th_decode_ycbcr_out(mTheoraState->mCtx, buffer);
41954:     NS_ASSERTION(ret == 0, "th_decode_ycbcr_out failed");
41954:     PRBool isKeyframe = th_packet_iskeyframe(aPacket) == 1;
41954:     VideoData::YCbCrBuffer b;
41954:     for (PRUint32 i=0; i < 3; ++i) {
41954:       b.mPlanes[i].mData = buffer[i].data;
41954:       b.mPlanes[i].mHeight = buffer[i].height;
41954:       b.mPlanes[i].mWidth = buffer[i].width;
41954:       b.mPlanes[i].mStride = buffer[i].stride;
41954:     }
63857: 
63857:     // Need the monitor to be held to be able to use mInfo. This
63857:     // is held by our caller.
63857:     mMonitor.AssertCurrentThreadIn();
42438:     VideoData *v = VideoData::Create(mInfo,
42438:                                      mDecoder->GetImageContainer(),
42438:                                      mPageOffset,
41954:                                      time,
47961:                                      endTime,
41954:                                      b,
41954:                                      isKeyframe,
41954:                                      aPacket->granulepos);
41954:     if (!v) {
42438:       // There may be other reasons for this error, but for
42438:       // simplicity just assume the worst case: out of memory.
41954:       NS_WARNING("Failed to allocate memory for video frame");
41954:       return NS_ERROR_OUT_OF_MEMORY;
41954:     }
53829:     if (!aFrames.AppendElement(v)) {
53829:       delete v;
53829:     }
41954:   }
41954:   return NS_OK;
41954: }
41954: 
41954: PRBool nsOggReader::DecodeVideoFrame(PRBool &aKeyframeSkip,
41954:                                      PRInt64 aTimeThreshold)
41954: {
41954:   MonitorAutoEnter mon(mMonitor);
41954:   NS_ASSERTION(mDecoder->OnStateMachineThread() || mDecoder->OnDecodeThread(),
41954:                "Should be on state machine or AV thread.");
63611: 
63611:   // Record number of frames decoded and parsed. Automatically update the
63611:   // stats counters using the AutoNotifyDecoded stack-based class.
63611:   PRUint32 parsed = 0, decoded = 0;
63611:   nsMediaDecoder::AutoNotifyDecoded autoNotify(mDecoder, parsed, decoded);
63611: 
41954:   // We chose to keep track of the Theora granulepos ourselves, rather than
41954:   // rely on th_decode_packetin() to do it for us. This is because
41954:   // th_decode_packetin() simply works by incrementing a counter every time
41954:   // it's called, so if we drop frames and don't call it, subsequent granulepos
41954:   // will be wrong. Whenever we read a packet which has a granulepos, we use
41954:   // its granulepos, otherwise we increment the previous packet's granulepos.
41954: 
53829:   nsAutoTArray<nsAutoPtr<VideoData>, 8> frames;
41954:   ogg_packet packet;
41954:   PRBool endOfStream = PR_FALSE;
41954:   if (mTheoraGranulepos == -1) {
41954:     // We've not read a Theora packet with a granulepos, so we don't know what
41954:     // timestamp to assign to Theora frames we decode. This will only happen
41954:     // the first time we read, or after a seek. We must read and buffer up to
41954:     // the first Theora packet with a granulepos, and back-propagate its 
41954:     // granulepos to calculate the buffered frames' granulepos.
41954:     do {
41954:       if (!ReadOggPacket(mTheoraState, &packet)) {
41954:         // Failed to read another page, must be the end of file. We can't have
41954:         // already encountered an end of bitstream packet, else we wouldn't be
41954:         // here, so this bitstream must be missing its end of stream packet, or
41954:         // is otherwise corrupt (oggz-chop can output files like this). Inform
41954:         // the queue that there will be no more frames.
41954:         mVideoQueue.Finish();
41954:         return PR_FALSE;
41954:       }
63611:       parsed++;
41954: 
41954:       if (packet.granulepos > 0) {
41954:         // We've found a packet with a granulepos, we can now determine the
41954:         // buffered packet's timestamps, as well as the timestamps for any
41954:         // packets we read subsequently.
41954:         mTheoraGranulepos = packet.granulepos;
41954:       }
41954: 
41954:       if (DecodeTheora(frames, &packet) == NS_ERROR_OUT_OF_MEMORY) {
41954:         NS_WARNING("Theora decode memory allocation failure!");
41954:         return PR_FALSE;
41954:       }
41954: 
41954:     } while (packet.granulepos <= 0 && !endOfStream);
41954: 
41954:     if (packet.granulepos > 0) {
64548:       // Reconstruct the granulepos (and thus timestamps) of the decoded
64548:       // frames. Granulepos are stored as ((keyframe<<shift)+offset). We
64548:       // know the granulepos of the last frame in the list, so we can infer
64548:       // the granulepos of the intermediate frames using their frame numbers.
64548:       ogg_int64_t shift = mTheoraState->mInfo.keyframe_granule_shift;
64548:       ogg_int64_t version_3_2_1 = TheoraVersion(&mTheoraState->mInfo,3,2,1);
64548:       ogg_int64_t lastFrame = th_granule_frame(mTheoraState->mCtx,
64548:                                                packet.granulepos) + version_3_2_1;
64548:       ogg_int64_t firstFrame = lastFrame - frames.Length() + 1;
64548: 
64548:       // Until we encounter a keyframe, we'll assume that the "keyframe"
64548:       // segment of the granulepos is the first frame, or if that causes
64548:       // the "offset" segment to overflow, we assume the required
64548:       // keyframe is maximumally offset. Until we encounter a keyframe
64548:       // the granulepos will probably be wrong, but we can't decode the
64548:       // frame anyway (since we don't have its keyframe) so it doesn't really
64548:       // matter.
64548:       ogg_int64_t keyframe = packet.granulepos >> shift;
64548: 
64548:       // The lastFrame, firstFrame, keyframe variables, as well as the frame
64548:       // variable in the loop below, store the frame number for Theora
64548:       // version >= 3.2.1 streams, and store the frame index for Theora
64548:       // version < 3.2.1 streams.
64548:       for (PRUint32 i = 0; i < frames.Length() - 1; ++i) {
64548:         ogg_int64_t frame = firstFrame + i;
64548:         ogg_int64_t granulepos;
41954:         if (frames[i]->mKeyframe) {
64548:           granulepos = frame << shift;
64548:           keyframe = frame;
64548:         } else if (frame >= keyframe &&
64548:                    frame - keyframe < ((ogg_int64_t)1 << shift))
64548:         {
64548:           // (frame - keyframe) won't overflow the "offset" segment of the
64548:           // granulepos, so it's safe to calculate the granulepos.
64548:           granulepos = (keyframe << shift) + (frame - keyframe);
64548:         } else {
64548:           // (frame - keyframeno) will overflow the "offset" segment of the
64548:           // granulepos, so we take "keyframe" to be the max possible offset
64548:           // frame instead.
64548:           ogg_int64_t k = NS_MAX(frame - (((ogg_int64_t)1 << shift) - 1), version_3_2_1);
64548:           granulepos = (k << shift) + (frame - k);
64548:         }
41954:         // Theora 3.2.1+ granulepos store frame number [1..N], so granulepos
41954:         // should be > 0.
41954:         // Theora 3.2.0 granulepos store the frame index [0..(N-1)], so
41954:         // granulepos should be >= 0. 
64548:         NS_ASSERTION(granulepos >= version_3_2_1,
64548:                      "Invalid granulepos for Theora version");
64548: 
64548:         // Check that the frame's granule number is one more than the
64548:         // previous frame's.
64548:         NS_ASSERTION(i == 0 ||
64548:                      th_granule_frame(mTheoraState->mCtx, granulepos) ==
64548:                      th_granule_frame(mTheoraState->mCtx, frames[i-1]->mTimecode) + 1,
41954:                      "Granulepos calculation is incorrect!");
64548: 
41954:         frames[i]->mTime = mTheoraState->StartTime(granulepos);
64570:         frames[i]->mEndTime = frames[i]->mTime + mTheoraState->mFrameDuration;
47961:         NS_ASSERTION(frames[i]->mEndTime >= frames[i]->mTime, "Frame must start before it ends.");
41954:         frames[i]->mTimecode = granulepos;
41954:       }
41954:       NS_ASSERTION(AllFrameTimesIncrease(frames), "All frames must have granulepos");
64548: 
64548:       // Check that the second to last frame's granule number is one less than
64548:       // the last frame's (the known granule number). If not our granulepos
64548:       // recovery missed a beat.
64548:       NS_ASSERTION(frames.Length() < 2 ||
64548:         th_granule_frame(mTheoraState->mCtx, frames[frames.Length()-2]->mTimecode) + 1 ==
64548:         th_granule_frame(mTheoraState->mCtx, packet.granulepos),
64548:         "Granulepos recovery should catch up with packet.granulepos!");
41954:     }
41954:   } else {
41954:     
41954:     NS_ASSERTION(mTheoraGranulepos > 0, "We must Theora granulepos!");
41954:     
41954:     if (!ReadOggPacket(mTheoraState, &packet)) {
41954:       // Failed to read from file, so EOF or other premature failure.
41954:       // Inform the queue that there will be no more frames.
41954:       mVideoQueue.Finish();
41954:       return PR_FALSE;
41954:     }
63611:     parsed++;
41954: 
41954:     endOfStream = packet.e_o_s != 0;
41954: 
41954:     // Maintain the Theora granulepos. We must do this even if we drop frames,
41954:     // otherwise our clock will be wrong after we've skipped frames.
41954:     if (packet.granulepos != -1) {
41954:       // Incoming packet has a granulepos, use that as it's granulepos.
41954:       mTheoraGranulepos = packet.granulepos;
41954:     } else {
41954:       // Increment the previous Theora granulepos.
41954:       PRInt64 granulepos = 0;
41954:       int shift = mTheoraState->mInfo.keyframe_granule_shift;
41954:       // Theora 3.2.1+ bitstreams granulepos store frame number; [1..N]
41954:       // Theora 3.2.0 bitstreams store the frame index; [0..(N-1)]
41954:       if (!th_packet_iskeyframe(&packet)) {
41954:         granulepos = mTheoraGranulepos + 1;
41954:       } else {
41954:         ogg_int64_t frameindex = th_granule_frame(mTheoraState->mCtx,
41954:                                                   mTheoraGranulepos);
41954:         ogg_int64_t granule = frameindex +
41954:                               TheoraVersion(&mTheoraState->mInfo,3,2,1) + 1;
41954:         NS_ASSERTION(granule > 0, "Must have positive granulepos");
41954:         granulepos = granule << shift;
41954:       }
41954: 
41954:       NS_ASSERTION(th_granule_frame(mTheoraState->mCtx, mTheoraGranulepos) + 1 == 
41954:                    th_granule_frame(mTheoraState->mCtx, granulepos),
41954:                    "Frame number must increment by 1");
41954:       packet.granulepos = mTheoraGranulepos = granulepos;
41954:     }
41954: 
41954:     PRInt64 time = mTheoraState->StartTime(mTheoraGranulepos);
41954:     NS_ASSERTION(packet.granulepos != -1, "Must know packet granulepos");
63854: 
41954:     if (!aKeyframeSkip ||
41954:         (th_packet_iskeyframe(&packet) == 1 && time >= aTimeThreshold))
41954:     {
41954:       if (DecodeTheora(frames, &packet) == NS_ERROR_OUT_OF_MEMORY) {
41954:         NS_WARNING("Theora decode memory allocation failure");
41954:         return PR_FALSE;
41954:       }
41954:     }
41954:   }
41954: 
41954:   // Push decoded data into the video frame queue.
41954:   for (PRUint32 i = 0; i < frames.Length(); i++) {
53829:     nsAutoPtr<VideoData> data(frames[i].forget());
63854:     // Don't use the frame if it's outside the bounds of the presentation
63854:     // start time in the skeleton track.
63854:     if (!mSkeletonState || mSkeletonState->IsPresentable(data->mTime)) {
53829:       if (aKeyframeSkip && data->mKeyframe) {
41954:         aKeyframeSkip = PR_FALSE;
41954:       }
53829:  
63620:       if (!aKeyframeSkip && data->mEndTime >= aTimeThreshold) {
53829:         mVideoQueue.Push(data.forget());
63611:         decoded++;
41954:       }
41954:     }
63854:   }
41954: 
41954:   if (endOfStream) {
41954:     // We've encountered an end of bitstream packet. Inform the queue that
41954:     // there will be no more frames.
41954:     mVideoQueue.Finish();
41954:   }
41954: 
41954:   return !endOfStream;
41954: }
41954: 
41954: PRInt64 nsOggReader::ReadOggPage(ogg_page* aPage)
41954: {
41954:   NS_ASSERTION(mDecoder->OnStateMachineThread() || mDecoder->OnDecodeThread(),
41954:                "Should be on play state machine or decode thread.");
41954:   mMonitor.AssertCurrentThreadIn();
41954: 
41954:   int ret = 0;
41954:   while((ret = ogg_sync_pageseek(&mOggState, aPage)) <= 0) {
41954:     if (ret < 0) {
41954:       // Lost page sync, have to skip up to next page.
41954:       mPageOffset += -ret;
41954:       continue;
41954:     }
41954:     // Returns a buffer that can be written too
41954:     // with the given size. This buffer is stored
41954:     // in the ogg synchronisation structure.
41954:     char* buffer = ogg_sync_buffer(&mOggState, 4096);
41954:     NS_ASSERTION(buffer, "ogg_sync_buffer failed");
41954: 
41954:     // Read from the stream into the buffer
41954:     PRUint32 bytesRead = 0;
41954: 
41954:     nsresult rv = mDecoder->GetCurrentStream()->Read(buffer, 4096, &bytesRead);
41954:     if (NS_FAILED(rv) || (bytesRead == 0 && ret == 0)) {
41954:       // End of file.
41954:       return -1;
41954:     }
41954: 
41954:     mDecoder->NotifyBytesConsumed(bytesRead);
41954:     // Update the synchronisation layer with the number
41954:     // of bytes written to the buffer
41954:     ret = ogg_sync_wrote(&mOggState, bytesRead);
41954:     NS_ENSURE_TRUE(ret == 0, -1);    
41954:   }
41954:   PRInt64 offset = mPageOffset;
41954:   mPageOffset += aPage->header_len + aPage->body_len;
41954:   
41954:   return offset;
41954: }
41954: 
41954: PRBool nsOggReader::ReadOggPacket(nsOggCodecState* aCodecState,
41954:                                   ogg_packet* aPacket)
41954: {
41954:   NS_ASSERTION(mDecoder->OnStateMachineThread() || mDecoder->OnDecodeThread(),
41954:                "Should be on play state machine or decode thread.");
41954:   mMonitor.AssertCurrentThreadIn();
41954: 
41954:   if (!aCodecState || !aCodecState->mActive) {
41954:     return PR_FALSE;
41954:   }
41954: 
41954:   int ret = 0;
41954:   while ((ret = ogg_stream_packetout(&aCodecState->mState, aPacket)) != 1) {
41954:     ogg_page page;
41954: 
41954:     if (aCodecState->PageInFromBuffer()) {
41954:       // The codec state has inserted a previously buffered page into its
41954:       // ogg_stream_state, no need to read a page from the channel.
41954:       continue;
41954:     }
41954: 
41954:     // The codec state does not have any buffered pages, so try to read another
41954:     // page from the channel.
41954:     if (ReadOggPage(&page) == -1) {
41954:       return PR_FALSE;
41954:     }
41954: 
41954:     PRUint32 serial = ogg_page_serialno(&page);
41954:     nsOggCodecState* codecState = nsnull;
41954:     mCodecStates.Get(serial, &codecState);
41954: 
41954:     if (serial == aCodecState->mSerial) {
41954:       // This page is from our target bitstream, insert it into the
41954:       // codec state's ogg_stream_state so we can read a packet.
41954:       ret = ogg_stream_pagein(&codecState->mState, &page);
41954:       NS_ENSURE_TRUE(ret == 0, PR_FALSE);
41954:     } else if (codecState && codecState->mActive) {
41954:       // Page is for another active bitstream, add the page to its codec
41954:       // state's buffer for later consumption when that stream next tries
41954:       // to read a packet.
41954:       codecState->AddToBuffer(&page);
41954:     }
41954:   }
41954: 
41954:   return PR_TRUE;
41954: }
41954: 
41954: // Returns an ogg page's checksum.
41954: static ogg_uint32_t
41954: GetChecksum(ogg_page* page)
41954: {
41954:   if (page == 0 || page->header == 0 || page->header_len < 25) {
41954:     return 0;
41954:   }
41954:   const unsigned char* p = page->header + 22;
41954:   PRUint32 c =  p[0] +
41954:                (p[1] << 8) + 
41954:                (p[2] << 16) +
41954:                (p[3] << 24);
41954:   return c;
41954: }
41954: 
42513: VideoData* nsOggReader::FindStartTime(PRInt64 aOffset,
42513:                                       PRInt64& aOutStartTime)
42513: {
48904:   NS_ASSERTION(mDecoder->OnStateMachineThread(),
48904:                "Should be on state machine thread.");
42513:   nsMediaStream* stream = mDecoder->GetCurrentStream();
48904:   NS_ENSURE_TRUE(stream != nsnull, nsnull);
48904:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET, aOffset);
48904:   NS_ENSURE_SUCCESS(res, nsnull);
42513:   return nsBuiltinDecoderReader::FindStartTime(aOffset, aOutStartTime);
42513: }
42513: 
41954: PRInt64 nsOggReader::FindEndTime(PRInt64 aEndOffset)
41954: {
41954:   MonitorAutoEnter mon(mMonitor);
48904:   NS_ASSERTION(mDecoder->OnStateMachineThread(),
48904:                "Should be on state machine thread.");
48904:   NS_ASSERTION(mDataOffset > 0,
48904:                "Should have offset of first non-header page");
63616:   PRInt64 endTime = FindEndTime(mDataOffset, aEndOffset, PR_FALSE, &mOggState);
63616:   // Reset read head to start of media data.
48904:   nsMediaStream* stream = mDecoder->GetCurrentStream();
48904:   NS_ENSURE_TRUE(stream != nsnull, -1);
48904:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET, mDataOffset);
48904:   NS_ENSURE_SUCCESS(res, -1);
48904:   return endTime;
48904: }
41954: 
63616: PRInt64 nsOggReader::FindEndTime(PRInt64 aStartOffset,
63616:                                  PRInt64 aEndOffset,
48904:                                  PRBool aCachedDataOnly,
48904:                                  ogg_sync_state* aState)
48904: {
41954:   nsMediaStream* stream = mDecoder->GetCurrentStream();
48904:   ogg_sync_reset(aState);
41954: 
41954:   // We need to find the last page which ends before aEndOffset that
41954:   // has a granulepos that we can convert to a timestamp. We do this by
41954:   // backing off from aEndOffset until we encounter a page on which we can
41954:   // interpret the granulepos. If while backing off we encounter a page which
41954:   // we've previously encountered before, we'll either backoff again if we
41954:   // haven't found an end time yet, or return the last end time found.
41954:   const int step = 5000;
48904:   PRInt64 readStartOffset = aEndOffset;
48904:   PRInt64 readHead = aEndOffset;
41954:   PRInt64 endTime = -1;
41954:   PRUint32 checksumAfterSeek = 0;
41954:   PRUint32 prevChecksumAfterSeek = 0;
41954:   PRBool mustBackOff = PR_FALSE;
41954:   while (PR_TRUE) {
41954:     ogg_page page;    
48904:     int ret = ogg_sync_pageseek(aState, &page);
41954:     if (ret == 0) {
41954:       // We need more data if we've not encountered a page we've seen before,
41954:       // or we've read to the end of file.
63616:       if (mustBackOff || readHead == aEndOffset || readHead == aStartOffset) {
53767:         if (endTime != -1 || readStartOffset == 0) {
41954:           // We have encountered a page before, or we're at the end of file.
41954:           break;
41954:         }
41954:         mustBackOff = PR_FALSE;
41954:         prevChecksumAfterSeek = checksumAfterSeek;
41954:         checksumAfterSeek = 0;
48904:         ogg_sync_reset(aState);
48904:         readStartOffset = NS_MAX(static_cast<PRInt64>(0), readStartOffset - step);
63616:         readHead = NS_MAX(aStartOffset, readStartOffset);
41954:       }
41954: 
41954:       PRInt64 limit = NS_MIN(static_cast<PRInt64>(PR_UINT32_MAX),
48904:                              aEndOffset - readHead);
41954:       limit = NS_MAX(static_cast<PRInt64>(0), limit);
41954:       limit = NS_MIN(limit, static_cast<PRInt64>(step));
41954:       PRUint32 bytesToRead = static_cast<PRUint32>(limit);
41954:       PRUint32 bytesRead = 0;
48904:       char* buffer = ogg_sync_buffer(aState, bytesToRead);
41954:       NS_ASSERTION(buffer, "Must have buffer");
48904:       nsresult res;
48904:       if (aCachedDataOnly) {
48904:         res = stream->ReadFromCache(buffer, readHead, bytesToRead);
63616:         NS_ENSURE_SUCCESS(res, -1);
48904:         bytesRead = bytesToRead;
48904:       } else {
48904:         NS_ASSERTION(readHead < aEndOffset,
48904:                      "Stream pos must be before range end");
48904:         res = stream->Seek(nsISeekableStream::NS_SEEK_SET, readHead);
63616:         NS_ENSURE_SUCCESS(res, -1);
48904:         res = stream->Read(buffer, bytesToRead, &bytesRead);
63616:         NS_ENSURE_SUCCESS(res, -1);
48904:       }
48904:       readHead += bytesRead;
41954: 
41954:       // Update the synchronisation layer with the number
41954:       // of bytes written to the buffer
48904:       ret = ogg_sync_wrote(aState, bytesRead);
41954:       if (ret != 0) {
41954:         endTime = -1;
41954:         break;
41954:       }
41954: 
41954:       continue;
41954:     }
41954: 
41954:     if (ret < 0 || ogg_page_granulepos(&page) < 0) {
41954:       continue;
41954:     }
41954: 
41954:     PRUint32 checksum = GetChecksum(&page);
41954:     if (checksumAfterSeek == 0) {
41954:       // This is the first page we've decoded after a backoff/seek. Remember
41954:       // the page checksum. If we backoff further and encounter this page
41954:       // again, we'll know that we won't find a page with an end time after
41954:       // this one, so we'll know to back off again.
41954:       checksumAfterSeek = checksum;
41954:     }
41954:     if (checksum == prevChecksumAfterSeek) {
41954:       // This page has the same checksum as the first page we encountered
41954:       // after the last backoff/seek. Since we've already scanned after this
41954:       // page and failed to find an end time, we may as well backoff again and
41954:       // try to find an end time from an earlier page.
41954:       mustBackOff = PR_TRUE;
41954:       continue;
41954:     }
41954: 
41954:     PRInt64 granulepos = ogg_page_granulepos(&page);
41954:     int serial = ogg_page_serialno(&page);
41954: 
41954:     nsOggCodecState* codecState = nsnull;
41954:     mCodecStates.Get(serial, &codecState);
41954: 
41954:     if (!codecState) {
41954:       // This page is from a bitstream which we haven't encountered yet.
41954:       // It's probably from a new "link" in a "chained" ogg. Don't
41954:       // bother even trying to find a duration...
47254:       endTime = -1;
41954:       break;
41954:     }
41954: 
47254:     PRInt64 t = codecState->Time(granulepos);
41954:     if (t != -1) {
41954:       endTime = t;
41954:     }
41954:   }
41954: 
48904:   ogg_sync_reset(aState);
42513: 
41954:   return endTime;
41954: }
41954: 
63625: nsresult nsOggReader::GetSeekRanges(nsTArray<SeekRange>& aRanges)
63625: {
63625:   NS_ASSERTION(mDecoder->OnStateMachineThread(),
63625:                "Should be on state machine thread.");
63625:   mMonitor.AssertCurrentThreadIn();
63628:   nsTArray<nsByteRange> cached;
63628:   nsresult res = mDecoder->GetCurrentStream()->GetCachedRanges(cached);
63628:   NS_ENSURE_SUCCESS(res, res);
63628: 
68055:   for (PRUint32 index = 0; index < cached.Length(); index++) {
63628:     nsByteRange& range = cached[index];
63625:     PRInt64 startTime = -1;
63625:     PRInt64 endTime = -1;
63625:     if (NS_FAILED(ResetDecode())) {
63625:       return NS_ERROR_FAILURE;
63625:     }
63628:     // Ensure the offsets are after the header pages.
63628:     PRInt64 startOffset = NS_MAX(cached[index].mStart, mDataOffset);
63628:     PRInt64 endOffset = NS_MAX(cached[index].mEnd, mDataOffset);
63628: 
63625:     FindStartTime(startOffset, startTime);
63625:     if (startTime != -1 &&
63625:         ((endTime = FindEndTime(endOffset)) != -1))
63625:     {
63625:       NS_ASSERTION(startTime < endTime,
63625:                    "Start time must be before end time");
63625:       aRanges.AppendElement(SeekRange(startOffset,
63625:                                       endOffset,
63625:                                       startTime,
63625:                                       endTime));
63625:      }
63625:   }
63625:   if (NS_FAILED(ResetDecode())) {
63625:     return NS_ERROR_FAILURE;
63625:   }
63625:   return NS_OK;
63625: }
63625: 
63625: nsOggReader::SeekRange
63625: nsOggReader::SelectSeekRange(const nsTArray<SeekRange>& ranges,
63625:                              PRInt64 aTarget,
63625:                              PRInt64 aStartTime,
63625:                              PRInt64 aEndTime,
63625:                              PRBool aExact)
63625: {
63625:   NS_ASSERTION(mDecoder->OnStateMachineThread(),
63625:                "Should be on state machine thread.");
63625:   PRInt64 so = mDataOffset;
63625:   PRInt64 eo = mDecoder->GetCurrentStream()->GetLength();
63625:   PRInt64 st = aStartTime;
63625:   PRInt64 et = aEndTime;
63625:   for (PRUint32 i = 0; i < ranges.Length(); i++) {
63625:     const SeekRange &r = ranges[i];
63625:     if (r.mTimeStart < aTarget) {
63625:       so = r.mOffsetStart;
63625:       st = r.mTimeStart;
63625:     }
63625:     if (r.mTimeEnd >= aTarget && r.mTimeEnd < et) {
63625:       eo = r.mOffsetEnd;
63625:       et = r.mTimeEnd;
63625:     }
63625: 
63625:     if (r.mTimeStart < aTarget && aTarget <= r.mTimeEnd) {
63625:       // Target lies exactly in this range.
63625:       return ranges[i];
63625:     }
63625:   }
63625:   return aExact ? SeekRange() : SeekRange(so, eo, st, et);
63625: }
63625: 
50947: nsOggReader::IndexedSeekResult nsOggReader::RollbackIndexedSeek(PRInt64 aOffset)
41954: {
50947:   mSkeletonState->Deactivate();
41954:   nsMediaStream* stream = mDecoder->GetCurrentStream();
50947:   NS_ENSURE_TRUE(stream != nsnull, SEEK_FATAL_ERROR);
50947:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET, aOffset);
50947:   NS_ENSURE_SUCCESS(res, SEEK_FATAL_ERROR);
50947:   return SEEK_INDEX_FAIL;
41954: }
41954:  
50947: nsOggReader::IndexedSeekResult nsOggReader::SeekToKeyframeUsingIndex(PRInt64 aTarget)
50947: {
50947:   nsMediaStream* stream = mDecoder->GetCurrentStream();
50947:   NS_ENSURE_TRUE(stream != nsnull, SEEK_FATAL_ERROR);
50947:   if (!HasSkeleton() || !mSkeletonState->HasIndex()) {
50947:     return SEEK_INDEX_FAIL;
50947:   }
50947:   // We have an index from the Skeleton track, try to use it to seek.
50947:   nsAutoTArray<PRUint32, 2> tracks;
50947:   if (HasVideo()) {
50947:     tracks.AppendElement(mTheoraState->mSerial);
50947:   }
50947:   if (HasAudio()) {
50947:     tracks.AppendElement(mVorbisState->mSerial);
50947:   }
50947:   nsSkeletonState::nsSeekTarget keyframe;
50947:   if (NS_FAILED(mSkeletonState->IndexedSeekTarget(aTarget,
50947:                                                   tracks,
50947:                                                   keyframe)))
50947:   {
50947:     // Could not locate a keypoint for the target in the index.
50947:     return SEEK_INDEX_FAIL;
50947:   }
41954: 
50947:   // Remember original stream read cursor position so we can rollback on failure.
50947:   PRInt64 tell = stream->Tell();
50947: 
50947:   // Seek to the keypoint returned by the index.
50947:   if (keyframe.mKeyPoint.mOffset > stream->GetLength() ||
50947:       keyframe.mKeyPoint.mOffset < 0)
50947:   {
50947:     // Index must be invalid.
50947:     return RollbackIndexedSeek(tell);
50947:   }
50947:   LOG(PR_LOG_DEBUG, ("Seeking using index to keyframe at offset %lld\n",
50947:                      keyframe.mKeyPoint.mOffset));
50947:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET,
50947:                               keyframe.mKeyPoint.mOffset);
50947:   NS_ENSURE_SUCCESS(res, SEEK_FATAL_ERROR);
50947:   mPageOffset = keyframe.mKeyPoint.mOffset;
50947: 
50947:   // We've moved the read set, so reset decode.
50947:   res = ResetDecode();
50947:   NS_ENSURE_SUCCESS(res, SEEK_FATAL_ERROR);
50947: 
50947:   // Check that the page the index thinks is exactly here is actually exactly
50947:   // here. If not, the index is invalid.
50947:   ogg_page page;
50947:   int skippedBytes = 0;
50947:   PageSyncResult syncres = PageSync(stream,
50947:                                     &mOggState,
50947:                                     PR_FALSE,
50947:                                     mPageOffset,
50947:                                     stream->GetLength(),
50947:                                     &page,
50947:                                     skippedBytes);
50947:   NS_ENSURE_TRUE(syncres != PAGE_SYNC_ERROR, SEEK_FATAL_ERROR);
50947:   if (syncres != PAGE_SYNC_OK || skippedBytes != 0) {
50947:     LOG(PR_LOG_DEBUG, ("Indexed-seek failure: Ogg Skeleton Index is invalid "
50947:                        "or sync error after seek"));
50947:     return RollbackIndexedSeek(tell);
50947:   }
50947:   PRUint32 serial = ogg_page_serialno(&page);
50947:   if (serial != keyframe.mSerial) {
50947:     // Serialno of page at offset isn't what the index told us to expect.
50947:     // Assume the index is invalid.
50947:     return RollbackIndexedSeek(tell);
50947:   }
50947:   nsOggCodecState* codecState = nsnull;
50947:   mCodecStates.Get(serial, &codecState);
50947:   if (codecState &&
50947:       codecState->mActive &&
50947:       ogg_stream_pagein(&codecState->mState, &page) != 0)
50947:   {
50947:     // Couldn't insert page into the ogg stream, or somehow the stream
50947:     // is no longer active.
50947:     return RollbackIndexedSeek(tell);
50947:   }      
50947:   mPageOffset = keyframe.mKeyPoint.mOffset + page.header_len + page.body_len;
50947:   return SEEK_OK;
50947: }
50947: 
50947: nsresult nsOggReader::SeekInBufferedRange(PRInt64 aTarget,
50947:                                           PRInt64 aStartTime,
50947:                                           PRInt64 aEndTime,
63625:                                           const nsTArray<SeekRange>& aRanges,
63625:                                           const SeekRange& aRange)
50947: {
50947:   LOG(PR_LOG_DEBUG, ("%p Seeking in buffered data to %lldms using bisection search", mDecoder, aTarget));
50947: 
50947:   // We know the exact byte range in which the target must lie. It must
50947:   // be buffered in the media cache. Seek there.
50947:   nsresult res = SeekBisection(aTarget, aRange, 0);
50947:   if (NS_FAILED(res) || !HasVideo()) {
50947:     return res;
50947:   }
50947: 
41954:   // We have an active Theora bitstream. Decode the next Theora frame, and
41954:   // extract its keyframe's time.
41954:   PRBool eof;
41954:   do {
41954:     PRBool skip = PR_FALSE;
41954:     eof = !DecodeVideoFrame(skip, 0);
41954:     {
41954:       MonitorAutoExit exitReaderMon(mMonitor);
41954:       MonitorAutoEnter decoderMon(mDecoder->GetMonitor());
41954:       if (mDecoder->GetDecodeState() == nsBuiltinDecoderStateMachine::DECODER_STATE_SHUTDOWN) {
41954:         return NS_ERROR_FAILURE;
41954:       }
41954:     }
41954:   } while (!eof &&
41954:            mVideoQueue.GetSize() == 0);
41954: 
41954:   VideoData* video = mVideoQueue.PeekFront();
41954:   if (video && !video->mKeyframe) {
41954:     // First decoded frame isn't a keyframe, seek back to previous keyframe,
41954:     // otherwise we'll get visual artifacts.
41954:     NS_ASSERTION(video->mTimecode != -1, "Must have a granulepos");
41954:     int shift = mTheoraState->mInfo.keyframe_granule_shift;
41954:     PRInt64 keyframeGranulepos = (video->mTimecode >> shift) << shift;
41954:     PRInt64 keyframeTime = mTheoraState->StartTime(keyframeGranulepos);
41954:     SEEK_LOG(PR_LOG_DEBUG, ("Keyframe for %lld is at %lld, seeking back to it",
41954:                             video->mTime, keyframeTime));
63625:     SeekRange k = SelectSeekRange(aRanges,
41954:                                   keyframeTime,
41954:                                   aStartTime,
41954:                                   aEndTime,
41954:                                   PR_FALSE);
64570:     res = SeekBisection(keyframeTime, k, SEEK_FUZZ_MS);
41954:     NS_ASSERTION(mTheoraGranulepos == -1, "SeekBisection must reset Theora decode");
41954:     NS_ASSERTION(mVorbisGranulepos == -1, "SeekBisection must reset Vorbis decode");
41954:   }
50947:   return res;
41954: }
41954: 
50947: PRBool nsOggReader::CanDecodeToTarget(PRInt64 aTarget,
50947:                                       PRInt64 aCurrentTime)
50947: {
50947:   // We can decode to the target if the target is no further than the
50947:   // maximum keyframe offset ahead of the current playback position, if
50947:   // we have video, or SEEK_DECODE_MARGIN if we don't have video.
50947:   PRInt64 margin = HasVideo() ? mTheoraState->MaxKeyframeOffset() : SEEK_DECODE_MARGIN;
50947:   return aTarget >= aCurrentTime &&
50947:          aTarget - aCurrentTime < margin;
50947: }
41954: 
50947: nsresult nsOggReader::SeekInUnbuffered(PRInt64 aTarget,
50947:                                        PRInt64 aStartTime,
50947:                                        PRInt64 aEndTime,
63625:                                        const nsTArray<SeekRange>& aRanges)
50947: {
50947:   LOG(PR_LOG_DEBUG, ("%p Seeking in unbuffered data to %lldms using bisection search", mDecoder, aTarget));
41954:   
41954:   // If we've got an active Theora bitstream, determine the maximum possible
64570:   // time in ms which a keyframe could be before a given interframe. We
41954:   // subtract this from our seek target, seek to the new target, and then
50947:   // will decode forward to the original seek target. We should encounter a
41954:   // keyframe in that interval. This prevents us from needing to run two
41954:   // bisections; one for the seek target frame, and another to find its
41954:   // keyframe. It's usually faster to just download this extra data, rather
41954:   // tham perform two bisections to find the seek target's keyframe. We
50947:   // don't do this offsetting when seeking in a buffered range,
42263:   // as the extra decoding causes a noticeable speed hit when all the data
50947:   // is buffered (compared to just doing a bisection to exactly find the
50947:   // keyframe).
41954:   PRInt64 keyframeOffsetMs = 0;
41954:   if (HasVideo() && mTheoraState) {
41954:     keyframeOffsetMs = mTheoraState->MaxKeyframeOffset();
41954:   }
41954:   PRInt64 seekTarget = NS_MAX(aStartTime, aTarget - keyframeOffsetMs);
50947:   // Minimize the bisection search space using the known timestamps from the
50947:   // buffered ranges.
63625:   SeekRange k = SelectSeekRange(aRanges, seekTarget, aStartTime, aEndTime, PR_FALSE);
64570:   nsresult res = SeekBisection(seekTarget, k, SEEK_FUZZ_MS);
41954:   NS_ASSERTION(mTheoraGranulepos == -1, "SeekBisection must reset Theora decode");
41954:   NS_ASSERTION(mVorbisGranulepos == -1, "SeekBisection must reset Vorbis decode");
50947:   return res;
50761: }
50947: 
50947: nsresult nsOggReader::Seek(PRInt64 aTarget,
50947:                            PRInt64 aStartTime,
50947:                            PRInt64 aEndTime,
50947:                            PRInt64 aCurrentTime)
50947: {
50947:   MonitorAutoEnter mon(mMonitor);
50947:   NS_ASSERTION(mDecoder->OnStateMachineThread(),
50947:                "Should be on state machine thread.");
50947:   LOG(PR_LOG_DEBUG, ("%p About to seek to %lldms", mDecoder, aTarget));
50947:   nsresult res;
50947:   nsMediaStream* stream = mDecoder->GetCurrentStream();
50947:   NS_ENSURE_TRUE(stream != nsnull, NS_ERROR_FAILURE);
50947: 
50947:   if (aTarget == aStartTime) {
50947:     // We've seeked to the media start. Just seek to the offset of the first
50947:     // content page.
50947:     res = stream->Seek(nsISeekableStream::NS_SEEK_SET, mDataOffset);
50947:     NS_ENSURE_SUCCESS(res,res);
50947: 
50947:     mPageOffset = mDataOffset;
50947:     res = ResetDecode();
50947:     NS_ENSURE_SUCCESS(res,res);
50947: 
50947:     NS_ASSERTION(aStartTime != -1, "mStartTime should be known");
50947:     {
50947:       MonitorAutoExit exitReaderMon(mMonitor);
50947:       MonitorAutoEnter decoderMon(mDecoder->GetMonitor());
50947:       mDecoder->UpdatePlaybackPosition(aStartTime);
50761:     }
50947:   } else if (CanDecodeToTarget(aTarget, aCurrentTime)) {
50947:     LOG(PR_LOG_DEBUG, ("%p Seek target (%lld) is close to current time (%lld), "
50947:         "will just decode to it", mDecoder, aCurrentTime, aTarget));
50947:   } else {
50947:     IndexedSeekResult sres = SeekToKeyframeUsingIndex(aTarget);
50947:     NS_ENSURE_TRUE(sres != SEEK_FATAL_ERROR, NS_ERROR_FAILURE);
50947:     if (sres == SEEK_INDEX_FAIL) {
50947:       // No index or other non-fatal index-related failure. Try to seek
50947:       // using a bisection search. Determine the already downloaded data
50947:       // in the media cache, so we can try to seek in the cached data first.
63625:       nsAutoTArray<SeekRange, 16> ranges;
63625:       res = GetSeekRanges(ranges);
50947:       NS_ENSURE_SUCCESS(res,res);
50947: 
50947:       // Figure out if the seek target lies in a buffered range.
63625:       SeekRange r = SelectSeekRange(ranges, aTarget, aStartTime, aEndTime, PR_TRUE);
50947: 
50947:       if (!r.IsNull()) {
50947:         // We know the buffered range in which the seek target lies, do a
50947:         // bisection search in that buffered range.
50947:         res = SeekInBufferedRange(aTarget, aStartTime, aEndTime, ranges, r);
50947:         NS_ENSURE_SUCCESS(res,res);
50947:       } else {
50947:         // The target doesn't lie in a buffered range. Perform a bisection
50947:         // search over the whole media, using the known buffered ranges to
50947:         // reduce the search space.
50947:         res = SeekInUnbuffered(aTarget, aStartTime, aEndTime, ranges);
50947:         NS_ENSURE_SUCCESS(res,res);
50947:       }
50947:     }
50947:   }
50947: 
50947:   // The decode position must now be either close to the seek target, or
50947:   // we've seeked to before the keyframe before the seek target. Decode
50947:   // forward to the seek target frame.
50761:   return DecodeToTarget(aTarget);
41954: }
50751: 
41954: // Reads a page from the media stream.
41954: static PageSyncResult
48904: PageSync(nsMediaStream* aStream,
48904:          ogg_sync_state* aState,
48904:          PRBool aCachedDataOnly,
48904:          PRInt64 aOffset,
41954:          PRInt64 aEndOffset,
41954:          ogg_page* aPage,
41954:          int& aSkippedBytes)
41954: {
41954:   aSkippedBytes = 0;
41954:   // Sync to the next page.
41954:   int ret = 0;
41954:   PRUint32 bytesRead = 0;
48904:   PRInt64 readHead = aOffset;
41954:   while (ret <= 0) {
41954:     ret = ogg_sync_pageseek(aState, aPage);
41954:     if (ret == 0) {
41954:       char* buffer = ogg_sync_buffer(aState, PAGE_STEP);
41954:       NS_ASSERTION(buffer, "Must have a buffer");
41954: 
41954:       // Read from the file into the buffer
63624:       PRUint32 bytesToRead =
63624:         static_cast<PRUint32>(NS_MIN(static_cast<PRInt64>(PAGE_STEP),
63624:                                      aEndOffset - readHead));
41954:       if (bytesToRead <= 0) {
41954:         return PAGE_SYNC_END_OF_RANGE;
41954:       }
48904:       nsresult rv = NS_OK;
48904:       if (aCachedDataOnly) {
48904:         rv = aStream->ReadFromCache(buffer, readHead, bytesToRead);
48904:         NS_ENSURE_SUCCESS(rv,PAGE_SYNC_ERROR);
48904:         bytesRead = bytesToRead;
48904:       } else {
48904:         rv = aStream->Seek(nsISeekableStream::NS_SEEK_SET, readHead);
48904:         NS_ENSURE_SUCCESS(rv,PAGE_SYNC_ERROR);
48904:         rv = aStream->Read(buffer,
41954:                            static_cast<PRUint32>(bytesToRead),
41954:                            &bytesRead);
48904:         NS_ENSURE_SUCCESS(rv,PAGE_SYNC_ERROR);
41954:       }
41954:       if (bytesRead == 0 && NS_SUCCEEDED(rv)) {
41954:         // End of file.
41954:         return PAGE_SYNC_END_OF_RANGE;
41954:       }
48904:       readHead += bytesRead;
41954: 
41954:       // Update the synchronisation layer with the number
41954:       // of bytes written to the buffer
41954:       ret = ogg_sync_wrote(aState, bytesRead);
41954:       NS_ENSURE_TRUE(ret == 0, PAGE_SYNC_ERROR);    
41954:       continue;
41954:     }
41954: 
41954:     if (ret < 0) {
41954:       NS_ASSERTION(aSkippedBytes >= 0, "Offset >= 0");
41954:       aSkippedBytes += -ret;
41954:       NS_ASSERTION(aSkippedBytes >= 0, "Offset >= 0");
41954:       continue;
41954:     }
41954:   }
41954:   
41954:   return PAGE_SYNC_OK;
41954: }
41954: 
41954: nsresult nsOggReader::SeekBisection(PRInt64 aTarget,
63625:                                     const SeekRange& aRange,
41954:                                     PRUint32 aFuzz)
41954: {
41954:   NS_ASSERTION(mDecoder->OnStateMachineThread(),
41954:                "Should be on state machine thread.");
48904:   nsresult res;
41954:   nsMediaStream* stream = mDecoder->GetCurrentStream();
41954: 
41954:   if (aTarget == aRange.mTimeStart) {
41954:     if (NS_FAILED(ResetDecode())) {
41954:       return NS_ERROR_FAILURE;
41954:     }
48904:     res = stream->Seek(nsISeekableStream::NS_SEEK_SET, mDataOffset);
48904:     NS_ENSURE_SUCCESS(res,res);
41954:     mPageOffset = mDataOffset;
41954:     return NS_OK;
41954:   }
41954: 
41954:   // Bisection search, find start offset of last page with end time less than
41954:   // the seek target.
41954:   ogg_int64_t startOffset = aRange.mOffsetStart;
41954:   ogg_int64_t startTime = aRange.mTimeStart;
62622:   ogg_int64_t startLength = 0; // Length of the page at startOffset.
41954:   ogg_int64_t endOffset = aRange.mOffsetEnd;
41954:   ogg_int64_t endTime = aRange.mTimeEnd;
41954: 
41954:   ogg_int64_t seekTarget = aTarget;
41954:   PRInt64 seekLowerBound = NS_MAX(static_cast<PRInt64>(0), aTarget - aFuzz);
41954:   int hops = 0;
41954:   ogg_int64_t previousGuess = -1;
62622:   int backsteps = 0;
41954:   const int maxBackStep = 10;
41954:   NS_ASSERTION(static_cast<PRUint64>(PAGE_STEP) * pow(2.0, maxBackStep) < PR_INT32_MAX,
41954:                "Backstep calculation must not overflow");
62622: 
62622:   // Seek via bisection search. Loop until we find the offset where the page
62622:   // before the offset is before the seek target, and the page after the offset
62622:   // is after the seek target.
41954:   while (PR_TRUE) {
41954:     ogg_int64_t duration = 0;
41954:     double target = 0;
41954:     ogg_int64_t interval = 0;
41954:     ogg_int64_t guess = 0;
41954:     ogg_page page;
41954:     int skippedBytes = 0;
41954:     ogg_int64_t pageOffset = 0;
41954:     ogg_int64_t pageLength = 0;
41954:     ogg_int64_t granuleTime = -1;
62622:     PRBool mustBackoff = PR_FALSE;
41954: 
41954:     // Guess where we should bisect to, based on the bit rate and the time
62622:     // remaining in the interval. Loop until we can determine the time at
62622:     // the guess offset.
41954:     while (PR_TRUE) {
41954:   
41954:       // Discard any previously buffered packets/pages.
41954:       if (NS_FAILED(ResetDecode())) {
41954:         return NS_ERROR_FAILURE;
41954:       }
41954: 
62622:       interval = endOffset - startOffset - startLength;
62622:       if (interval == 0) {
62622:         // Our interval is empty, we've found the optimal seek point, as the
62622:         // page at the start offset is before the seek target, and the page
62622:         // at the end offset is after the seek target.
62622:         SEEK_LOG(PR_LOG_DEBUG, ("Interval narrowed, terminating bisection."));
62622:         break;
62622:       }
62622: 
41954:       // Guess bisection point.
41954:       duration = endTime - startTime;
41954:       target = (double)(seekTarget - startTime) / (double)duration;
41954:       guess = startOffset + startLength +
62622:               static_cast<ogg_int64_t>((double)interval * target);
41954:       guess = NS_MIN(guess, endOffset - PAGE_STEP);
62622:       if (mustBackoff) {
62622:         // We previously failed to determine the time at the guess offset,
62622:         // probably because we ran out of data to decode. This usually happens
62622:         // when we guess very close to the end offset. So reduce the guess
62622:         // offset using an exponential backoff until we determine the time.
62622:         SEEK_LOG(PR_LOG_DEBUG, ("Backing off %d bytes, backsteps=%d",
62622:           static_cast<PRInt32>(PAGE_STEP * pow(2.0, backsteps)), backsteps));
63624:         guess -= PAGE_STEP * static_cast<ogg_int64_t>(pow(2.0, backsteps));
62622:         backsteps = NS_MIN(backsteps + 1, maxBackStep);
62622:         // We reset mustBackoff. If we still need to backoff further, it will
62622:         // be set to PR_TRUE again.
62622:         mustBackoff = PR_FALSE;
62622:       } else {
62622:         backsteps = 0;
62622:       }
41954:       guess = NS_MAX(guess, startOffset + startLength);
41954: 
62622:       SEEK_LOG(PR_LOG_DEBUG, ("Seek loop start[o=%lld..%lld t=%lld] "
62622:                               "end[o=%lld t=%lld] "
62622:                               "interval=%lld target=%lf guess=%lld",
62622:                               startOffset, (startOffset+startLength), startTime,
62622:                               endOffset, endTime, interval, target, guess));
41954: 
41954:       NS_ASSERTION(guess >= startOffset + startLength, "Guess must be after range start");
41954:       NS_ASSERTION(guess < endOffset, "Guess must be before range end");
41954:       NS_ASSERTION(guess != previousGuess, "Guess should be differnt to previous");
41954:       previousGuess = guess;
41954: 
41954:       hops++;
41954:     
48904:       // Locate the next page after our seek guess, and then figure out the
48904:       // granule time of the audio and video bitstreams there. We can then
48904:       // make a bisection decision based on our location in the media.
48904:       PageSyncResult res = PageSync(stream,
48904:                                     &mOggState,
48904:                                     PR_FALSE,
48904:                                     guess,
41954:                                     endOffset,
41954:                                     &page,
41954:                                     skippedBytes);
50947:       NS_ENSURE_TRUE(res != PAGE_SYNC_ERROR, NS_ERROR_FAILURE);
41954: 
41954:       // We've located a page of length |ret| at |guess + skippedBytes|.
41954:       // Remember where the page is located.
41954:       pageOffset = guess + skippedBytes;
41954:       pageLength = page.header_len + page.body_len;
41954:       mPageOffset = pageOffset + pageLength;
41954: 
62622:       if (res == PAGE_SYNC_END_OF_RANGE) {
41954:         // Our guess was too close to the end, we've ended up reading the end
41954:         // page. Backoff exponentially from the end point, in case the last
41954:         // page/frame/sample is huge.
62622:         mustBackoff = PR_TRUE;
62622:         SEEK_LOG(PR_LOG_DEBUG, ("Hit the end of range, backing off"));
41954:         continue;
41954:       }
41954: 
41954:       // Read pages until we can determine the granule time of the audio and 
41954:       // video bitstream.
41954:       ogg_int64_t audioTime = -1;
41954:       ogg_int64_t videoTime = -1;
62622:       do {
41954:         // Add the page to its codec state, determine its granule time.
41954:         PRUint32 serial = ogg_page_serialno(&page);
41954:         nsOggCodecState* codecState = nsnull;
41954:         mCodecStates.Get(serial, &codecState);
41954:         if (codecState && codecState->mActive) {
62622:           int ret = ogg_stream_pagein(&codecState->mState, &page);
41954:           NS_ENSURE_TRUE(ret == 0, NS_ERROR_FAILURE);
41954:         }
41954: 
41954:         ogg_int64_t granulepos = ogg_page_granulepos(&page);
41954: 
41954:         if (HasAudio() &&
41954:             granulepos != -1 &&
41954:             serial == mVorbisState->mSerial &&
41954:             audioTime == -1) {
41954:           audioTime = mVorbisState->Time(granulepos);
41954:         }
41954:         
41954:         if (HasVideo() &&
41954:             granulepos != -1 &&
41954:             serial == mTheoraState->mSerial &&
41954:             videoTime == -1) {
41954:           videoTime = mTheoraState->StartTime(granulepos);
41954:         }
41954: 
62622:         if (mPageOffset == endOffset) {
62622:           // Hit end of readable data.
62622:           break;
62622:         }
62622: 
41954:         if (ReadOggPage(&page) == -1) {
41954:           break;
41954:         }
62622:         
62622:       } while ((mVorbisState && audioTime == -1) ||
62622:                (mTheoraState && videoTime == -1));
62622: 
62622:       NS_ASSERTION(mPageOffset <= endOffset, "Page read cursor should be inside range");
41954: 
41954:       if ((HasAudio() && audioTime == -1) ||
41954:           (HasVideo() && videoTime == -1)) 
41954:       {
62622:         // We don't have timestamps for all active tracks...
62622:         if (pageOffset == startOffset + startLength && mPageOffset == endOffset) {
62622:           // We read the entire interval without finding timestamps for all
62622:           // active tracks. We know the interval start offset is before the seek
62622:           // target, and the interval end is after the seek target, and we can't
62622:           // terminate inside the interval, so we terminate the seek at the
62622:           // start of the interval.
62622:           interval = 0;
62622:           break;
62622:         }
62622: 
62622:         // We should backoff; cause the guess to back off from the end, so
62622:         // that we've got more room to capture.
62622:         mustBackoff = PR_TRUE;
41954:         continue;
41954:       }
41954: 
41954:       // We've found appropriate time stamps here. Proceed to bisect
41954:       // the search space.
41954:       granuleTime = NS_MAX(audioTime, videoTime);
41954:       NS_ASSERTION(granuleTime > 0, "Must get a granuletime");
41954:       break;
62622:     } // End of "until we determine time at guess offset" loop.
41954: 
41954:     if (interval == 0) {
41954:       // Seek termination condition; we've found the page boundary of the
41954:       // last page before the target, and the first page after the target.
62622:       SEEK_LOG(PR_LOG_DEBUG, ("Terminating seek at offset=%lld", startOffset));
41954:       NS_ASSERTION(startTime < aTarget, "Start time must always be less than target");
48904:       res = stream->Seek(nsISeekableStream::NS_SEEK_SET, startOffset);
48904:       NS_ENSURE_SUCCESS(res,res);
41954:       mPageOffset = startOffset;
41954:       if (NS_FAILED(ResetDecode())) {
41954:         return NS_ERROR_FAILURE;
41954:       }
41954:       break;
41954:     }
41954: 
41954:     SEEK_LOG(PR_LOG_DEBUG, ("Time at offset %lld is %lldms", guess, granuleTime));
41954:     if (granuleTime < seekTarget && granuleTime > seekLowerBound) {
41954:       // We're within the fuzzy region in which we want to terminate the search.
62622:       res = stream->Seek(nsISeekableStream::NS_SEEK_SET, pageOffset);
48904:       NS_ENSURE_SUCCESS(res,res);
62622:       mPageOffset = pageOffset;
41954:       if (NS_FAILED(ResetDecode())) {
41954:         return NS_ERROR_FAILURE;
41954:       }
62622:       SEEK_LOG(PR_LOG_DEBUG, ("Terminating seek at offset=%lld", mPageOffset));
41954:       break;
41954:     }
41954: 
41954:     if (granuleTime >= seekTarget) {
41954:       // We've landed after the seek target.
47700:       NS_ASSERTION(pageOffset < endOffset, "offset_end must decrease");
41954:       endOffset = pageOffset;
41954:       endTime = granuleTime;
41954:     } else if (granuleTime < seekTarget) {
41954:       // Landed before seek target.
47700:       NS_ASSERTION(pageOffset > startOffset, "offset_start must increase");
41954:       startOffset = pageOffset;
41954:       startLength = pageLength;
41954:       startTime = granuleTime;
41954:     }
41954:     NS_ASSERTION(startTime < seekTarget, "Must be before seek target");
41954:     NS_ASSERTION(endTime >= seekTarget, "End must be after seek target");
41954:   }
41954: 
41954:   SEEK_LOG(PR_LOG_DEBUG, ("Seek complete in %d bisections.", hops));
41954: 
41954:   return NS_OK;
41954: }
41954: 
51394: nsresult nsOggReader::GetBuffered(nsTimeRanges* aBuffered, PRInt64 aStartTime)
48902: {
53767:   // HasAudio and HasVideo are not used here as they take a lock and cause
53767:   // a deadlock. Accessing mInfo doesn't require a lock - it doesn't change
53767:   // after metadata is read and GetBuffered isn't called before metadata is
53767:   // read.
53767:   if (!mInfo.mHasVideo && !mInfo.mHasAudio) {
53767:     // No need to search through the file if there are no audio or video tracks
53767:     return NS_OK;
53767:   }
53767: 
48904:   nsMediaStream* stream = mDecoder->GetCurrentStream();
63628:   nsTArray<nsByteRange> ranges;
63628:   nsresult res = stream->GetCachedRanges(ranges);
63628:   NS_ENSURE_SUCCESS(res, res);
48904: 
48904:   // Traverse across the buffered byte ranges, determining the time ranges
48904:   // they contain. nsMediaStream::GetNextCachedData(offset) returns -1 when
48904:   // offset is after the end of the media stream, or there's no more cached
48904:   // data after the offset. This loop will run until we've checked every
48904:   // buffered range in the media, in increasing order of offset.
48904:   ogg_sync_state state;
48904:   ogg_sync_init(&state);
63628:   for (PRUint32 index = 0; index < ranges.Length(); index++) {
63628:     // Ensure the offsets are after the header pages.
63628:     PRInt64 startOffset = NS_MAX(ranges[index].mStart, mDataOffset);
63628:     PRInt64 endOffset = NS_MAX(ranges[index].mEnd, mDataOffset);
48904: 
48904:     // Because the granulepos time is actually the end time of the page,
48904:     // we special-case (startOffset == mDataOffset) so that the first
63628:     // buffered range always appears to be buffered from the media start
63628:     // time, rather than from the end-time of the first page.
63628:     PRInt64 startTime = (startOffset == mDataOffset) ? aStartTime : -1;
63628: 
63628:     // Find the start time of the range. Read pages until we find one with a
63628:     // granulepos which we can convert into a timestamp to use as the time of
63628:     // the start of the buffered range.
48904:     ogg_sync_reset(&state);
48904:     while (startTime == -1) {
48904:       ogg_page page;
48904:       PRInt32 discard;
48904:       PageSyncResult res = PageSync(stream,
48904:                                     &state,
48904:                                     PR_TRUE,
48904:                                     startOffset,
48904:                                     endOffset,
48904:                                     &page,
48904:                                     discard);
48904:       if (res == PAGE_SYNC_ERROR) {
48904:         // If we don't clear the sync state before exit we'll leak.
48904:         ogg_sync_clear(&state);
48904:         return NS_ERROR_FAILURE;
48904:       } else if (res == PAGE_SYNC_END_OF_RANGE) {
48904:         // Hit the end of range without reading a page, give up trying to
48904:         // find a start time for this buffered range, skip onto the next one.
48904:         break;
48904:       }
48904: 
48904:       PRInt64 granulepos = ogg_page_granulepos(&page);
48904:       if (granulepos == -1) {
48904:         // Page doesn't have an end time, advance to the next page
48904:         // until we find one.
48904:         startOffset += page.header_len + page.body_len;
48904:         continue;
48904:       }
48904: 
48904:       PRUint32 serial = ogg_page_serialno(&page);
62621:       if (mVorbisState && serial == mVorbisSerial) {
59429:         startTime = nsVorbisState::Time(&mVorbisInfo, granulepos) - aStartTime;
48904:         NS_ASSERTION(startTime > 0, "Must have positive start time");
48904:       }
62621:       else if (mTheoraState && serial == mTheoraSerial) {
59429:         startTime = nsTheoraState::Time(&mTheoraInfo, granulepos) - aStartTime;
59429:         NS_ASSERTION(startTime > 0, "Must have positive start time");
59429:       }
59429:       else if (IsKnownStream(serial)) {
59429:         // Stream is not the theora or vorbis stream we're playing,
59429:         // but is one that we have header data for.
53767:         startOffset += page.header_len + page.body_len;
53767:         continue;
53767:       }
53767:       else {
53767:         // Page is for a stream we don't know about (possibly a chained
53767:         // ogg), return an error.
63628:         ogg_sync_clear(&state);
53767:         return PAGE_SYNC_ERROR;
53767:       }
48904:     }
48904: 
48904:     if (startTime != -1) {
48904:       // We were able to find a start time for that range, see if we can
48904:       // find an end time.
63616:       PRInt64 endTime = FindEndTime(startOffset, endOffset, PR_TRUE, &state);
48904:       if (endTime != -1) {
64570:         endTime -= aStartTime;
64570:         aBuffered->Add(static_cast<double>(startTime) / 1000.0,
64570:                        static_cast<double>(endTime) / 1000.0);
48904:       }
48904:     }
48904:   }
48904: 
48904:   // If we don't clear the sync state before exit we'll leak.
48904:   ogg_sync_clear(&state);
48904: 
48902:   return NS_OK;
48902: }
59429: 
59429: PRBool nsOggReader::IsKnownStream(PRUint32 aSerial)
59429: {
59429:   for (PRUint32 i = 0; i < mKnownStreams.Length(); i++) {
59429:     PRUint32 serial = mKnownStreams[i];
59429:     if (serial == aSerial) {
59429:       return PR_TRUE;
59429:     }
59429:   }
59429: 
59429:   return PR_FALSE;
59429: }
