43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2002
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@netscape.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsHttpConnectionMgr.h"
43113: #include "nsHttpConnection.h"
43113: #include "nsHttpPipeline.h"
43113: #include "nsHttpHandler.h"
43113: #include "nsAutoLock.h"
43113: #include "nsNetCID.h"
43113: #include "nsCOMPtr.h"
58439: #include "nsNetUtil.h"
43113: 
43113: #include "nsIServiceManager.h"
43113: 
55822: #include "nsIObserverService.h"
55822: 
43113: // defined by the socket transport service while active
43113: extern PRThread *gSocketThread;
43113: 
43113: static NS_DEFINE_CID(kSocketTransportServiceCID, NS_SOCKETTRANSPORTSERVICE_CID);
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
55822: 
55822: NS_IMPL_THREADSAFE_ISUPPORTS1(nsHttpConnectionMgr, nsIObserver)
55822: 
43113: static void
43113: InsertTransactionSorted(nsTArray<nsHttpTransaction*> &pendingQ, nsHttpTransaction *trans)
43113: {
43113:     // insert into queue with smallest valued number first.  search in reverse
43113:     // order under the assumption that many of the existing transactions will
43113:     // have the same priority (usually 0).
43113: 
43113:     for (PRInt32 i=pendingQ.Length()-1; i>=0; --i) {
43113:         nsHttpTransaction *t = pendingQ[i];
43113:         if (trans->Priority() >= t->Priority()) {
43113:             pendingQ.InsertElementAt(i+1, trans);
43113:             return;
43113:         }
43113:     }
43113:     pendingQ.InsertElementAt(0, trans);
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpConnectionMgr::nsHttpConnectionMgr()
43113:     : mRef(0)
43113:     , mMonitor(nsAutoMonitor::NewMonitor("nsHttpConnectionMgr"))
43113:     , mMaxConns(0)
43113:     , mMaxConnsPerHost(0)
43113:     , mMaxConnsPerProxy(0)
43113:     , mMaxPersistConnsPerHost(0)
43113:     , mMaxPersistConnsPerProxy(0)
58545:     , mIsShuttingDown(PR_FALSE)
43113:     , mNumActiveConns(0)
43113:     , mNumIdleConns(0)
55822:     , mTimeOfNextWakeUp(LL_MAXUINT)
43113: {
43113:     LOG(("Creating nsHttpConnectionMgr @%x\n", this));
43113: }
43113: 
43113: nsHttpConnectionMgr::~nsHttpConnectionMgr()
43113: {
43113:     LOG(("Destroying nsHttpConnectionMgr @%x\n", this));
43113:  
43113:     if (mMonitor)
43113:         nsAutoMonitor::DestroyMonitor(mMonitor);
43113: }
43113: 
43113: nsresult
58439: nsHttpConnectionMgr::EnsureSocketThreadTargetIfOnline()
58439: {
58439:     nsresult rv;
58439:     nsCOMPtr<nsIEventTarget> sts;
58439:     nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
58439:     if (NS_SUCCEEDED(rv)) {
58439:         PRBool offline = PR_TRUE;
58439:         ioService->GetOffline(&offline);
58439: 
58439:         if (!offline) {
58439:             sts = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &rv);
58439:         }
58439:     }
58439: 
58439:     nsAutoMonitor mon(mMonitor);
58439: 
58439:     // do nothing if already initialized or if we've shut down
58439:     if (mSocketThreadTarget || mIsShuttingDown)
58439:         return NS_OK;
58439: 
58439:     mSocketThreadTarget = sts;
58439: 
58439:     return rv;
58439: }
58439: 
58439: nsresult
43113: nsHttpConnectionMgr::Init(PRUint16 maxConns,
43113:                           PRUint16 maxConnsPerHost,
43113:                           PRUint16 maxConnsPerProxy,
43113:                           PRUint16 maxPersistConnsPerHost,
43113:                           PRUint16 maxPersistConnsPerProxy,
43113:                           PRUint16 maxRequestDelay,
43113:                           PRUint16 maxPipelinedRequests)
43113: {
43113:     LOG(("nsHttpConnectionMgr::Init\n"));
43113: 
58439:     {
43113:         nsAutoMonitor mon(mMonitor);
43113: 
43113:         mMaxConns = maxConns;
43113:         mMaxConnsPerHost = maxConnsPerHost;
43113:         mMaxConnsPerProxy = maxConnsPerProxy;
43113:         mMaxPersistConnsPerHost = maxPersistConnsPerHost;
43113:         mMaxPersistConnsPerProxy = maxPersistConnsPerProxy;
43113:         mMaxRequestDelay = maxRequestDelay;
43113:         mMaxPipelinedRequests = maxPipelinedRequests;
43113: 
58439:         mIsShuttingDown = PR_FALSE;
58439:     }
58439: 
58439:     return EnsureSocketThreadTargetIfOnline();
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::Shutdown()
43113: {
43113:     LOG(("nsHttpConnectionMgr::Shutdown\n"));
43113: 
43113:     nsAutoMonitor mon(mMonitor);
43113: 
43113:     // do nothing if already shutdown
43113:     if (!mSocketThreadTarget)
43113:         return NS_OK;
43113: 
43113:     nsresult rv = PostEvent(&nsHttpConnectionMgr::OnMsgShutdown);
43113: 
43113:     // release our reference to the STS to prevent further events
43113:     // from being posted.  this is how we indicate that we are
43113:     // shutting down.
58439:     mIsShuttingDown = PR_TRUE;
43113:     mSocketThreadTarget = 0;
43113: 
43113:     if (NS_FAILED(rv)) {
43113:         NS_WARNING("unable to post SHUTDOWN message");
43113:         return rv;
43113:     }
43113: 
43113:     // wait for shutdown event to complete
43113:     mon.Wait();
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::PostEvent(nsConnEventHandler handler, PRInt32 iparam, void *vparam)
43113: {
58439:     // This object doesn't get reinitialized if the offline state changes, so our
58439:     // socket thread target might be uninitialized if we were offline when this
58439:     // object was being initialized, and we go online later on.  This call takes
58439:     // care of initializing the socket thread target if that's the case.
58439:     EnsureSocketThreadTargetIfOnline();
58439: 
43113:     nsAutoMonitor mon(mMonitor);
43113: 
43113:     nsresult rv;
43113:     if (!mSocketThreadTarget) {
43113:         NS_WARNING("cannot post event if not initialized");
43113:         rv = NS_ERROR_NOT_INITIALIZED;
43113:     }
43113:     else {
43113:         nsRefPtr<nsIRunnable> event = new nsConnEvent(this, handler, iparam, vparam);
43113:         if (!event)
43113:             rv = NS_ERROR_OUT_OF_MEMORY;
43113:         else
43113:             rv = mSocketThreadTarget->Dispatch(event, NS_DISPATCH_NORMAL);
43113:     }
43113:     return rv;
43113: }
43113: 
55822: void
55822: nsHttpConnectionMgr::PruneDeadConnectionsAfter(PRUint32 timeInSeconds)
55822: {
55822:     LOG(("nsHttpConnectionMgr::PruneDeadConnectionsAfter\n"));
55822: 
55822:     if(!mTimer)
55822:         mTimer = do_CreateInstance("@mozilla.org/timer;1");
55822: 
55822:     // failure to create a timer is not a fatal error, but idle connections
55822:     // will not be cleaned up until we try to use them.
55822:     if (mTimer) {
55822:         mTimeOfNextWakeUp = timeInSeconds + NowInSeconds();
55822:         mTimer->Init(this, timeInSeconds*1000, nsITimer::TYPE_ONE_SHOT);
55822:     } else {
55822:         NS_WARNING("failed to create: timer for pruning the dead connections!");
55822:     }
55822: }
55822: 
55822: void
55822: nsHttpConnectionMgr::StopPruneDeadConnectionsTimer()
55822: {
55822:     LOG(("nsHttpConnectionMgr::StopPruneDeadConnectionsTimer\n"));
55822: 
56650:     // Reset mTimeOfNextWakeUp so that we can find a new shortest value.
56650:     mTimeOfNextWakeUp = LL_MAXUINT;
55822:     if (mTimer) {
55822:         mTimer->Cancel();
55822:         mTimer = NULL;
55822:     }
55822: }
55822: 
55822: //-----------------------------------------------------------------------------
55822: // nsHttpConnectionMgr::nsIObserver
55822: //-----------------------------------------------------------------------------
55822: 
55822: NS_IMETHODIMP
55822: nsHttpConnectionMgr::Observe(nsISupports *subject,
55822:                              const char *topic,
55822:                              const PRUnichar *data)
55822: {
55822:     LOG(("nsHttpConnectionMgr::Observe [topic=\"%s\"]\n", topic));
55822: 
55822:     if (0 == strcmp(topic, "timer-callback")) {
55822:         // prune dead connections
55822:         PruneDeadConnections();
55822: #ifdef DEBUG
55822:         nsCOMPtr<nsITimer> timer = do_QueryInterface(subject);
55822:         NS_ASSERTION(timer == mTimer, "unexpected timer-callback");
55822: #endif
55822:     }
55822: 
55822:     return NS_OK;
55822: }
55822: 
55822: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::AddTransaction(nsHttpTransaction *trans, PRInt32 priority)
43113: {
43113:     LOG(("nsHttpConnectionMgr::AddTransaction [trans=%x %d]\n", trans, priority));
43113: 
43113:     NS_ADDREF(trans);
43113:     nsresult rv = PostEvent(&nsHttpConnectionMgr::OnMsgNewTransaction, priority, trans);
43113:     if (NS_FAILED(rv))
43113:         NS_RELEASE(trans);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::RescheduleTransaction(nsHttpTransaction *trans, PRInt32 priority)
43113: {
43113:     LOG(("nsHttpConnectionMgr::RescheduleTransaction [trans=%x %d]\n", trans, priority));
43113: 
43113:     NS_ADDREF(trans);
43113:     nsresult rv = PostEvent(&nsHttpConnectionMgr::OnMsgReschedTransaction, priority, trans);
43113:     if (NS_FAILED(rv))
43113:         NS_RELEASE(trans);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::CancelTransaction(nsHttpTransaction *trans, nsresult reason)
43113: {
43113:     LOG(("nsHttpConnectionMgr::CancelTransaction [trans=%x reason=%x]\n", trans, reason));
43113: 
43113:     NS_ADDREF(trans);
43113:     nsresult rv = PostEvent(&nsHttpConnectionMgr::OnMsgCancelTransaction, reason, trans);
43113:     if (NS_FAILED(rv))
43113:         NS_RELEASE(trans);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::PruneDeadConnections()
43113: {
43113:     return PostEvent(&nsHttpConnectionMgr::OnMsgPruneDeadConnections);
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::GetSocketThreadTarget(nsIEventTarget **target)
43113: {
58439:     // This object doesn't get reinitialized if the offline state changes, so our
58439:     // socket thread target might be uninitialized if we were offline when this
58439:     // object was being initialized, and we go online later on.  This call takes
58439:     // care of initializing the socket thread target if that's the case.
58439:     EnsureSocketThreadTargetIfOnline();
58439: 
43113:     nsAutoMonitor mon(mMonitor);
43113:     NS_IF_ADDREF(*target = mSocketThreadTarget);
43113:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::AddTransactionToPipeline(nsHttpPipeline *pipeline)
43113: {
43113:     LOG(("nsHttpConnectionMgr::AddTransactionToPipeline [pipeline=%x]\n", pipeline));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     nsRefPtr<nsHttpConnectionInfo> ci;
43113:     pipeline->GetConnectionInfo(getter_AddRefs(ci));
43113:     if (ci) {
43113:         nsCStringKey key(ci->HashKey());
43113:         nsConnectionEntry *ent = (nsConnectionEntry *) mCT.Get(&key);
43113:         if (ent) {
43113:             // search for another request to pipeline...
43113:             PRInt32 i, count = ent->mPendingQ.Length();
43113:             for (i=0; i<count; ++i) {
43113:                 nsHttpTransaction *trans = ent->mPendingQ[i];
43113:                 if (trans->Caps() & NS_HTTP_ALLOW_PIPELINING) {
43113:                     pipeline->AddTransaction(trans);
43113: 
43113:                     // remove transaction from pending queue
43113:                     ent->mPendingQ.RemoveElementAt(i);
43113:                     NS_RELEASE(trans);
43113:                     break;
43113:                 }
43113:             }
43113:         }
43113:     }
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::ReclaimConnection(nsHttpConnection *conn)
43113: {
43113:     LOG(("nsHttpConnectionMgr::ReclaimConnection [conn=%x]\n", conn));
43113: 
43113:     NS_ADDREF(conn);
43113:     nsresult rv = PostEvent(&nsHttpConnectionMgr::OnMsgReclaimConnection, 0, conn);
43113:     if (NS_FAILED(rv))
43113:         NS_RELEASE(conn);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::UpdateParam(nsParamName name, PRUint16 value)
43113: {
43113:     PRUint32 param = (PRUint32(name) << 16) | PRUint32(value);
43113:     return PostEvent(&nsHttpConnectionMgr::OnMsgUpdateParam, 0, (void *) param);
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::ProcessPendingQ(nsHttpConnectionInfo *ci)
43113: {
43113:     LOG(("nsHttpConnectionMgr::ProcessPendingQ [ci=%s]\n", ci->HashKey().get()));
43113: 
43113:     NS_ADDREF(ci);
43113:     nsresult rv = PostEvent(&nsHttpConnectionMgr::OnMsgProcessPendingQ, 0, ci);
43113:     if (NS_FAILED(rv))
43113:         NS_RELEASE(ci);
43113:     return rv;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // enumeration callbacks
43113: 
43113: PRIntn
43113: nsHttpConnectionMgr::ProcessOneTransactionCB(nsHashKey *key, void *data, void *closure)
43113: {
43113:     nsHttpConnectionMgr *self = (nsHttpConnectionMgr *) closure;
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) data;
43113: 
43113:     if (self->ProcessPendingQForEntry(ent))
43113:         return kHashEnumerateStop;
43113: 
43113:     return kHashEnumerateNext;
43113: }
43113: 
57969: // If the global number of idle connections is preventing the opening of
57969: // new connections to a host without idle connections, then
57969: // close them regardless of their TTL
43113: PRIntn
57969: nsHttpConnectionMgr::PurgeExcessIdleConnectionsCB(nsHashKey *key,
57969:                                                   void *data, void *closure)
43113: {
43113:     nsHttpConnectionMgr *self = (nsHttpConnectionMgr *) closure;
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) data;
43113: 
57969:     while (self->mNumIdleConns + self->mNumActiveConns + 1 >= self->mMaxConns) {
57969:         if (!ent->mIdleConns.Length()) {
57969:             // There are no idle conns left in this connection entry
57969:             return kHashEnumerateNext;
57969:         }
43113:         nsHttpConnection *conn = ent->mIdleConns[0];
43113:         ent->mIdleConns.RemoveElementAt(0);
43113:         conn->Close(NS_ERROR_ABORT);
43113:         NS_RELEASE(conn);
43113:         self->mNumIdleConns--;
55822:         if (0 == self->mNumIdleConns)
55822:             self->StopPruneDeadConnectionsTimer();
57969:     }
43113:     return kHashEnumerateStop;
43113: }
43113: 
43113: PRIntn
43113: nsHttpConnectionMgr::PruneDeadConnectionsCB(nsHashKey *key, void *data, void *closure)
43113: {
43113:     nsHttpConnectionMgr *self = (nsHttpConnectionMgr *) closure;
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) data;
43113: 
43113:     LOG(("  pruning [ci=%s]\n", ent->mConnInfo->HashKey().get()));
43113: 
55822:     // Find out how long it will take for next idle connection to not be reusable
55822:     // anymore.
55822:     PRUint32 timeToNextExpire = PR_UINT32_MAX;
43113:     PRInt32 count = ent->mIdleConns.Length();
43113:     if (count > 0) {
43113:         for (PRInt32 i=count-1; i>=0; --i) {
43113:             nsHttpConnection *conn = ent->mIdleConns[i];
43113:             if (!conn->CanReuse()) {
43113:                 ent->mIdleConns.RemoveElementAt(i);
43113:                 conn->Close(NS_ERROR_ABORT);
43113:                 NS_RELEASE(conn);
43113:                 self->mNumIdleConns--;
55822:             } else {
55822:                 timeToNextExpire = PR_MIN(timeToNextExpire, conn->TimeToLive());
43113:             }
43113:         }
43113:     }
43113: 
55822:     // If time to next expire found is shorter than time to next wake-up, we need to
55822:     // change the time for next wake-up.
56650:     PRUint32 now = NowInSeconds();
55822:     if (0 < ent->mIdleConns.Length()) {
55822:         PRUint64 timeOfNextExpire = now + timeToNextExpire;
55822:         // If pruning of dead connections is not already scheduled to happen
55822:         // or time found for next connection to expire is is before
55822:         // mTimeOfNextWakeUp, we need to schedule the pruning to happen
55822:         // after timeToNextExpire.
55822:         if (!self->mTimer || timeOfNextExpire < self->mTimeOfNextWakeUp) {
55822:             self->PruneDeadConnectionsAfter(timeToNextExpire);
55822:         }
55822:     } else if (0 == self->mNumIdleConns) {
55822:         self->StopPruneDeadConnectionsTimer();
55822:     }
43113: #ifdef DEBUG
43113:     count = ent->mActiveConns.Length();
43113:     if (count > 0) {
43113:         for (PRInt32 i=count-1; i>=0; --i) {
43113:             nsHttpConnection *conn = ent->mActiveConns[i];
43113:             LOG(("    active conn [%x] with trans [%x]\n", conn, conn->Transaction()));
43113:         }
43113:     }
43113: #endif
43113: 
43113:     // if this entry is empty, then we can remove it.
43113:     if (ent->mIdleConns.Length()   == 0 &&
43113:         ent->mActiveConns.Length() == 0 &&
43113:         ent->mPendingQ.Length()    == 0) {
43113:         LOG(("    removing empty connection entry\n"));
43113:         delete ent;
43113:         return kHashEnumerateRemove;
43113:     }
43113: 
43113:     // else, use this opportunity to compact our arrays...
43113:     ent->mIdleConns.Compact();
43113:     ent->mActiveConns.Compact();
43113:     ent->mPendingQ.Compact();
43113: 
43113:     return kHashEnumerateNext;
43113: }
43113: 
43113: PRIntn
43113: nsHttpConnectionMgr::ShutdownPassCB(nsHashKey *key, void *data, void *closure)
43113: {
43113:     nsHttpConnectionMgr *self = (nsHttpConnectionMgr *) closure;
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) data;
43113: 
43113:     nsHttpTransaction *trans;
43113:     nsHttpConnection *conn;
43113: 
43113:     // close all active connections
43113:     while (ent->mActiveConns.Length()) {
43113:         conn = ent->mActiveConns[0];
43113: 
43113:         ent->mActiveConns.RemoveElementAt(0);
43113:         self->mNumActiveConns--;
43113: 
43113:         conn->Close(NS_ERROR_ABORT);
43113:         NS_RELEASE(conn);
43113:     }
43113: 
43113:     // close all idle connections
43113:     while (ent->mIdleConns.Length()) {
43113:         conn = ent->mIdleConns[0];
43113: 
43113:         ent->mIdleConns.RemoveElementAt(0);
43113:         self->mNumIdleConns--;
43113: 
43113:         conn->Close(NS_ERROR_ABORT);
43113:         NS_RELEASE(conn);
43113:     }
55822:     // If all idle connections are removed,
55822:     // we can stop pruning dead connections.
55822:     if (0 == self->mNumIdleConns)
55822:         self->StopPruneDeadConnectionsTimer();
43113: 
43113:     // close all pending transactions
43113:     while (ent->mPendingQ.Length()) {
43113:         trans = ent->mPendingQ[0];
43113: 
43113:         ent->mPendingQ.RemoveElementAt(0);
43113: 
43113:         trans->Close(NS_ERROR_ABORT);
43113:         NS_RELEASE(trans);
43113:     }
43113: 
43113:     delete ent;
43113:     return kHashEnumerateRemove;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: PRBool
43113: nsHttpConnectionMgr::ProcessPendingQForEntry(nsConnectionEntry *ent)
43113: {
43113:     LOG(("nsHttpConnectionMgr::ProcessPendingQForEntry [ci=%s]\n",
43113:         ent->mConnInfo->HashKey().get()));
43113: 
43113:     PRInt32 i, count = ent->mPendingQ.Length();
43113:     if (count > 0) {
43113:         LOG(("  pending-count=%u\n", count));
43113:         nsHttpTransaction *trans = nsnull;
43113:         nsHttpConnection *conn = nsnull;
43113:         for (i=0; i<count; ++i) {
43113:             trans = ent->mPendingQ[i];
43113:             GetConnection(ent, trans->Caps(), &conn);
43113:             if (conn)
43113:                 break;
43113:         }
43113:         if (conn) {
43113:             LOG(("  dispatching pending transaction...\n"));
43113: 
43113:             // remove pending transaction
43113:             ent->mPendingQ.RemoveElementAt(i);
43113: 
43113:             nsresult rv = DispatchTransaction(ent, trans, trans->Caps(), conn);
43113:             if (NS_SUCCEEDED(rv))
43113:                 NS_RELEASE(trans);
43113:             else {
43113:                 LOG(("  DispatchTransaction failed [rv=%x]\n", rv));
43113:                 // on failure, just put the transaction back
43113:                 ent->mPendingQ.InsertElementAt(i, trans);
43113:                 // might be something wrong with the connection... close it.
43113:                 conn->Close(rv);
43113:             }
43113: 
43113:             NS_RELEASE(conn);
43113:             return PR_TRUE;
43113:         }
43113:     }
43113:     return PR_FALSE;
43113: }
43113: 
43113: // we're at the active connection limit if any one of the following conditions is true:
43113: //  (1) at max-connections
43113: //  (2) keep-alive enabled and at max-persistent-connections-per-server/proxy
43113: //  (3) keep-alive disabled and at max-connections-per-server
43113: PRBool
43113: nsHttpConnectionMgr::AtActiveConnectionLimit(nsConnectionEntry *ent, PRUint8 caps)
43113: {
43113:     nsHttpConnectionInfo *ci = ent->mConnInfo;
43113: 
43113:     LOG(("nsHttpConnectionMgr::AtActiveConnectionLimit [ci=%s caps=%x]\n",
43113:         ci->HashKey().get(), caps));
43113: 
56650:     // If we have more active connections than the limit, then we're done --
56650:     // purging idle connections won't get us below it.
43113:     if (mNumActiveConns >= mMaxConns) {
43113:         LOG(("  num active conns == max conns\n"));
43113:         return PR_TRUE;
43113:     }
43113: 
43113:     nsHttpConnection *conn;
43113:     PRInt32 i, totalCount, persistCount = 0;
43113:     
43113:     totalCount = ent->mActiveConns.Length();
43113: 
43113:     // count the number of persistent connections
43113:     for (i=0; i<totalCount; ++i) {
43113:         conn = ent->mActiveConns[i];
43113:         if (conn->IsKeepAlive()) // XXX make sure this is thread-safe
43113:             persistCount++;
43113:     }
43113: 
43113:     LOG(("   total=%d, persist=%d\n", totalCount, persistCount));
43113: 
43113:     PRUint16 maxConns;
43113:     PRUint16 maxPersistConns;
43113: 
43113:     if (ci->UsingHttpProxy() && !ci->UsingSSL()) {
43113:         maxConns = mMaxConnsPerProxy;
43113:         maxPersistConns = mMaxPersistConnsPerProxy;
43113:     }
43113:     else {
43113:         maxConns = mMaxConnsPerHost;
43113:         maxPersistConns = mMaxPersistConnsPerHost;
43113:     }
43113: 
43113:     // use >= just to be safe
43113:     return (totalCount >= maxConns) || ( (caps & NS_HTTP_ALLOW_KEEPALIVE) &&
43113:                                          (persistCount >= maxPersistConns) );
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::GetConnection(nsConnectionEntry *ent, PRUint8 caps,
43113:                                    nsHttpConnection **result)
43113: {
43113:     LOG(("nsHttpConnectionMgr::GetConnection [ci=%s caps=%x]\n",
43113:         ent->mConnInfo->HashKey().get(), PRUint32(caps)));
43113: 
57969:     // First, see if an idle persistent connection may be reused instead of
57969:     // establishing a new socket. We do not need to check the connection limits
57969:     // yet as they govern the maximum number of open connections and reusing
57969:     // an old connection never increases that.
57969: 
43113:     *result = nsnull;
43113: 
43113:     nsHttpConnection *conn = nsnull;
43113: 
43113:     if (caps & NS_HTTP_ALLOW_KEEPALIVE) {
57969:         // search the idle connection list. Each element in the list
57969:         // has a reference, so if we remove it from the list into a local
57969:         // ptr, that ptr now owns the reference
43113:         while (!conn && (ent->mIdleConns.Length() > 0)) {
43113:             conn = ent->mIdleConns[0];
43113:             // we check if the connection can be reused before even checking if
43113:             // it is a "matching" connection.
43113:             if (!conn->CanReuse()) {
43113:                 LOG(("   dropping stale connection: [conn=%x]\n", conn));
43113:                 conn->Close(NS_ERROR_ABORT);
43113:                 NS_RELEASE(conn);
43113:             }
43113:             else
43113:                 LOG(("   reusing connection [conn=%x]\n", conn));
43113:             ent->mIdleConns.RemoveElementAt(0);
43113:             mNumIdleConns--;
56650: 
56650:             // If there are no idle connections left at all, we need to make
56650:             // sure that we are not pruning dead connections anymore.
56650:             if (0 == mNumIdleConns)
56650:                 StopPruneDeadConnectionsTimer();
43113:         }
43113:     }
43113: 
43113:     if (!conn) {
56650:         // Check if we need to purge an idle connection. Note that we may have
56650:         // removed one above; if so, this will be a no-op. We do this before
56650:         // checking the active connection limit to catch the case where we do
56650:         // have an idle connection, but the purge timer hasn't fired yet.
56650:         // XXX this just purges a random idle connection.  we should instead
56650:         // enumerate the entire hash table to find the eldest idle connection.
56650:         if (mNumIdleConns && mNumIdleConns + mNumActiveConns + 1 >= mMaxConns)
57969:             mCT.Enumerate(PurgeExcessIdleConnectionsCB, this);
56650: 
56650:         // Need to make a new TCP connection. First, we check if we've hit
56650:         // either the maximum connection limit globally or for this particular
56650:         // host or proxy. If we have, we're done.
56650:         if (AtActiveConnectionLimit(ent, caps)) {
56650:             LOG(("  at active connection limit!\n"));
56650:             return;
56650:         }
55822: 
43113:         conn = new nsHttpConnection();
43113:         NS_ADDREF(conn);
43113:         nsresult rv = conn->Init(ent->mConnInfo, mMaxRequestDelay);
43113:         if (NS_FAILED(rv)) {
43113:             NS_RELEASE(conn);
43113:             return;
43113:         }
43113:     }
43113: 
43113:     *result = conn;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::DispatchTransaction(nsConnectionEntry *ent,
43113:                                          nsAHttpTransaction *trans,
43113:                                          PRUint8 caps,
43113:                                          nsHttpConnection *conn)
43113: {
43113:     LOG(("nsHttpConnectionMgr::DispatchTransaction [ci=%s trans=%x caps=%x conn=%x]\n",
43113:         ent->mConnInfo->HashKey().get(), trans, caps, conn));
43113: 
43113:     nsConnectionHandle *handle = new nsConnectionHandle(conn);
43113:     if (!handle)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     NS_ADDREF(handle);
43113: 
43113:     nsHttpPipeline *pipeline = nsnull;
43113:     if (conn->SupportsPipelining() && (caps & NS_HTTP_ALLOW_PIPELINING)) {
43113:         LOG(("  looking to build pipeline...\n"));
43113:         if (BuildPipeline(ent, trans, &pipeline))
43113:             trans = pipeline;
43113:     }
43113: 
43113:     // hold an owning ref to this connection
43113:     ent->mActiveConns.AppendElement(conn);
43113:     mNumActiveConns++;
43113:     NS_ADDREF(conn);
43113: 
43113:     // give the transaction the indirect reference to the connection.
43113:     trans->SetConnection(handle);
43113: 
43113:     nsresult rv = conn->Activate(trans, caps);
43113: 
43113:     if (NS_FAILED(rv)) {
43113:         LOG(("  conn->Activate failed [rv=%x]\n", rv));
43113:         ent->mActiveConns.RemoveElement(conn);
43113:         mNumActiveConns--;
43113:         // sever back references to connection, and do so without triggering
43113:         // a call to ReclaimConnection ;-)
43113:         trans->SetConnection(nsnull);
43113:         NS_RELEASE(handle->mConn);
43113:         // destroy the connection
43113:         NS_RELEASE(conn);
43113:     }
43113: 
43113:     // if we were unable to activate the pipeline, then this will destroy
43113:     // the pipeline, which will cause each the transactions owned by the 
43113:     // pipeline to be restarted.
43113:     NS_IF_RELEASE(pipeline);
43113: 
43113:     NS_RELEASE(handle);
43113:     return rv;
43113: }
43113: 
43113: PRBool
43113: nsHttpConnectionMgr::BuildPipeline(nsConnectionEntry *ent,
43113:                                    nsAHttpTransaction *firstTrans,
43113:                                    nsHttpPipeline **result)
43113: {
43113:     if (mMaxPipelinedRequests < 2)
43113:         return PR_FALSE;
43113: 
43113:     nsHttpPipeline *pipeline = nsnull;
43113:     nsHttpTransaction *trans;
43113: 
43113:     PRUint32 i = 0, numAdded = 0;
43113:     while (i < ent->mPendingQ.Length()) {
43113:         trans = ent->mPendingQ[i];
43113:         if (trans->Caps() & NS_HTTP_ALLOW_PIPELINING) {
43113:             if (numAdded == 0) {
43113:                 pipeline = new nsHttpPipeline;
43113:                 if (!pipeline)
43113:                     return PR_FALSE;
43113:                 pipeline->AddTransaction(firstTrans);
43113:                 numAdded = 1;
43113:             }
43113:             pipeline->AddTransaction(trans);
43113: 
43113:             // remove transaction from pending queue
43113:             ent->mPendingQ.RemoveElementAt(i);
43113:             NS_RELEASE(trans);
43113: 
43113:             if (++numAdded == mMaxPipelinedRequests)
43113:                 break;
43113:         }
43113:         else
43113:             ++i; // skip to next pending transaction
43113:     }
43113: 
43113:     if (numAdded == 0)
43113:         return PR_FALSE;
43113: 
43113:     LOG(("  pipelined %u transactions\n", numAdded));
43113:     NS_ADDREF(*result = pipeline);
43113:     return PR_TRUE;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::ProcessNewTransaction(nsHttpTransaction *trans)
43113: {
43113:     // since "adds" and "cancels" are processed asynchronously and because
43113:     // various events might trigger an "add" directly on the socket thread,
43113:     // we must take care to avoid dispatching a transaction that has already
43113:     // been canceled (see bug 190001).
43113:     if (NS_FAILED(trans->Status())) {
43113:         LOG(("  transaction was canceled... dropping event!\n"));
43113:         return NS_OK;
43113:     }
43113: 
43113:     PRUint8 caps = trans->Caps();
43113:     nsHttpConnectionInfo *ci = trans->ConnectionInfo();
43113:     NS_ASSERTION(ci, "no connection info");
43113: 
43113:     nsCStringKey key(ci->HashKey());
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) mCT.Get(&key);
43113:     if (!ent) {
43113:         nsHttpConnectionInfo *clone = ci->Clone();
43113:         if (!clone)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         ent = new nsConnectionEntry(clone);
43113:         if (!ent)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         mCT.Put(&key, ent);
43113:     }
43113: 
43113:     nsHttpConnection *conn;
43113: 
43113:     // check if the transaction already has a sticky reference to a connection.
43113:     // if so, then we can just use it directly.  XXX check if alive??
43113:     // XXX add a TakeConnection method or something to make this clearer!
43113:     nsConnectionHandle *handle = (nsConnectionHandle *) trans->Connection();
43113:     if (handle) {
43113:         NS_ASSERTION(caps & NS_HTTP_STICKY_CONNECTION, "unexpected caps");
43113:         NS_ASSERTION(handle->mConn, "no connection");
43113: 
43113:         // steal reference from connection handle.
43113:         // XXX prevent SetConnection(nsnull) from calling ReclaimConnection
43113:         conn = handle->mConn;
43113:         handle->mConn = nsnull;
43113: 
43113:         // destroy connection handle.
43113:         trans->SetConnection(nsnull);
43113: 
43113:         // remove sticky connection from active connection list; we'll add it
43113:         // right back in DispatchTransaction.
43113:         if (ent->mActiveConns.RemoveElement(conn))
43113:             mNumActiveConns--;
43113:         else {
43113:             NS_ERROR("sticky connection not found in active list");
43113:             return NS_ERROR_UNEXPECTED;
43113:         }
43113:     }
43113:     else
43113:         GetConnection(ent, caps, &conn);
43113: 
43113:     nsresult rv;
43113:     if (!conn) {
43113:         LOG(("  adding transaction to pending queue [trans=%x pending-count=%u]\n",
43113:             trans, ent->mPendingQ.Length()+1));
43113:         // put this transaction on the pending queue...
43113:         InsertTransactionSorted(ent->mPendingQ, trans);
43113:         NS_ADDREF(trans);
43113:         rv = NS_OK;
43113:     }
43113:     else {
43113:         rv = DispatchTransaction(ent, trans, caps, conn);
43113:         NS_RELEASE(conn);
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgShutdown(PRInt32, void *)
43113: {
43113:     LOG(("nsHttpConnectionMgr::OnMsgShutdown\n"));
43113: 
43113:     mCT.Reset(ShutdownPassCB, this);
43113: 
43113:     // signal shutdown complete
43113:     nsAutoMonitor mon(mMonitor);
43113:     mon.Notify();
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgNewTransaction(PRInt32 priority, void *param)
43113: {
43113:     LOG(("nsHttpConnectionMgr::OnMsgNewTransaction [trans=%p]\n", param));
43113: 
43113:     nsHttpTransaction *trans = (nsHttpTransaction *) param;
43113:     trans->SetPriority(priority);
43113:     nsresult rv = ProcessNewTransaction(trans);
43113:     if (NS_FAILED(rv))
43113:         trans->Close(rv); // for whatever its worth
43113:     NS_RELEASE(trans);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgReschedTransaction(PRInt32 priority, void *param)
43113: {
43113:     LOG(("nsHttpConnectionMgr::OnMsgNewTransaction [trans=%p]\n", param));
43113: 
43113:     nsHttpTransaction *trans = (nsHttpTransaction *) param;
43113:     trans->SetPriority(priority);
43113: 
43113:     nsHttpConnectionInfo *ci = trans->ConnectionInfo();
43113:     nsCStringKey key(ci->HashKey());
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) mCT.Get(&key);
43113:     if (ent) {
43113:         PRInt32 index = ent->mPendingQ.IndexOf(trans);
43113:         if (index >= 0) {
43113:             ent->mPendingQ.RemoveElementAt(index);
43113:             InsertTransactionSorted(ent->mPendingQ, trans);
43113:         }
43113:     }
43113: 
43113:     NS_RELEASE(trans);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgCancelTransaction(PRInt32 reason, void *param)
43113: {
43113:     LOG(("nsHttpConnectionMgr::OnMsgCancelTransaction [trans=%p]\n", param));
43113: 
43113:     nsHttpTransaction *trans = (nsHttpTransaction *) param;
43113:     //
43113:     // if the transaction owns a connection and the transaction is not done,
43113:     // then ask the connection to close the transaction.  otherwise, close the
43113:     // transaction directly (removing it from the pending queue first).
43113:     //
43113:     nsAHttpConnection *conn = trans->Connection();
43113:     if (conn && !trans->IsDone())
43113:         conn->CloseTransaction(trans, reason);
43113:     else {
43113:         nsHttpConnectionInfo *ci = trans->ConnectionInfo();
43113:         nsCStringKey key(ci->HashKey());
43113:         nsConnectionEntry *ent = (nsConnectionEntry *) mCT.Get(&key);
43113:         if (ent) {
43113:             PRInt32 index = ent->mPendingQ.IndexOf(trans);
43113:             if (index >= 0) {
43113:                 ent->mPendingQ.RemoveElementAt(index);
43113:                 nsHttpTransaction *temp = trans;
43113:                 NS_RELEASE(temp); // b/c NS_RELEASE nulls its argument!
43113:             }
43113:         }
43113:         trans->Close(reason);
43113:     }
43113:     NS_RELEASE(trans);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgProcessPendingQ(PRInt32, void *param)
43113: {
43113:     nsHttpConnectionInfo *ci = (nsHttpConnectionInfo *) param;
43113: 
43113:     LOG(("nsHttpConnectionMgr::OnMsgProcessPendingQ [ci=%s]\n", ci->HashKey().get()));
43113: 
43113:     // start by processing the queue identified by the given connection info.
43113:     nsCStringKey key(ci->HashKey());
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) mCT.Get(&key);
43113:     if (!(ent && ProcessPendingQForEntry(ent))) {
43113:         // if we reach here, it means that we couldn't dispatch a transaction
43113:         // for the specified connection info.  walk the connection table...
43113:         mCT.Enumerate(ProcessOneTransactionCB, this);
43113:     }
43113: 
43113:     NS_RELEASE(ci);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgPruneDeadConnections(PRInt32, void *)
43113: {
43113:     LOG(("nsHttpConnectionMgr::OnMsgPruneDeadConnections\n"));
43113: 
56650:     // Reset mTimeOfNextWakeUp so that we can find a new shortest value.
56650:     mTimeOfNextWakeUp = LL_MAXUINT;
43113:     if (mNumIdleConns > 0) 
43113:         mCT.Enumerate(PruneDeadConnectionsCB, this);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgReclaimConnection(PRInt32, void *param)
43113: {
43113:     LOG(("nsHttpConnectionMgr::OnMsgReclaimConnection [conn=%p]\n", param));
43113: 
43113:     nsHttpConnection *conn = (nsHttpConnection *) param;
43113: 
43113:     // 
43113:     // 1) remove the connection from the active list
43113:     // 2) if keep-alive, add connection to idle list
43113:     // 3) post event to process the pending transaction queue
43113:     //
43113: 
43113:     nsHttpConnectionInfo *ci = conn->ConnectionInfo();
43113:     NS_ADDREF(ci);
43113: 
43113:     nsCStringKey key(ci->HashKey());
43113:     nsConnectionEntry *ent = (nsConnectionEntry *) mCT.Get(&key);
43113: 
43113:     NS_ASSERTION(ent, "no connection entry");
43113:     if (ent) {
57969:         // If the connection is in the active list, remove that entry
57969:         // and the reference held by the mActiveConns list.
57969:         // This is never the final reference on conn as the event context
57969:         // is also holding one that is released at the end of this function.
57969:         if (ent->mActiveConns.RemoveElement(conn)) {
57969:             nsHttpConnection *temp = conn;
57969:             NS_RELEASE(temp);
43113:             mNumActiveConns--;
57969:         }
57969: 
43113:         if (conn->CanReuse()) {
43113:             LOG(("  adding connection to idle list\n"));
43113:             // hold onto this connection in the idle list.  we push it to
43113:             // the end of the list so as to ensure that we'll visit older
43113:             // connections first before getting to this one.
57969:             NS_ADDREF(conn);
43113:             ent->mIdleConns.AppendElement(conn);
43113:             mNumIdleConns++;
55822:             // If the added connection was first idle connection or has shortest
55822:             // time to live among the idle connections, pruning dead
55822:             // connections needs to be done when it can't be reused anymore.
55822:             PRUint32 timeToLive = conn->TimeToLive();
55822:             if(!mTimer || NowInSeconds() + timeToLive < mTimeOfNextWakeUp)
55822:                 PruneDeadConnectionsAfter(timeToLive);
43113:         }
43113:         else {
43113:             LOG(("  connection cannot be reused; closing connection\n"));
43113:             // make sure the connection is closed and release our reference.
43113:             conn->Close(NS_ERROR_ABORT);
43113:         }
43113:     }
43113:  
43113:     OnMsgProcessPendingQ(NS_OK, ci); // releases |ci|
43113:     NS_RELEASE(conn);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::OnMsgUpdateParam(PRInt32, void *param)
43113: {
43113:     PRUint16 name  = (NS_PTR_TO_INT32(param) & 0xFFFF0000) >> 16;
43113:     PRUint16 value =  NS_PTR_TO_INT32(param) & 0x0000FFFF;
43113: 
43113:     switch (name) {
43113:     case MAX_CONNECTIONS:
43113:         mMaxConns = value;
43113:         break;
43113:     case MAX_CONNECTIONS_PER_HOST:
43113:         mMaxConnsPerHost = value;
43113:         break;
43113:     case MAX_CONNECTIONS_PER_PROXY:
43113:         mMaxConnsPerProxy = value;
43113:         break;
43113:     case MAX_PERSISTENT_CONNECTIONS_PER_HOST:
43113:         mMaxPersistConnsPerHost = value;
43113:         break;
43113:     case MAX_PERSISTENT_CONNECTIONS_PER_PROXY:
43113:         mMaxPersistConnsPerProxy = value;
43113:         break;
43113:     case MAX_REQUEST_DELAY:
43113:         mMaxRequestDelay = value;
43113:         break;
43113:     case MAX_PIPELINED_REQUESTS:
43113:         mMaxPipelinedRequests = value;
43113:         break;
43113:     default:
43113:         NS_NOTREACHED("unexpected parameter name");
43113:     }
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnectionMgr::nsConnectionHandle
43113: 
43113: nsHttpConnectionMgr::nsConnectionHandle::~nsConnectionHandle()
43113: {
43113:     if (mConn) {
43113:         gHttpHandler->ReclaimConnection(mConn);
43113:         NS_RELEASE(mConn);
43113:     }
43113: }
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS0(nsHttpConnectionMgr::nsConnectionHandle)
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::nsConnectionHandle::OnHeadersAvailable(nsAHttpTransaction *trans,
43113:                                                             nsHttpRequestHead *req,
43113:                                                             nsHttpResponseHead *resp,
43113:                                                             PRBool *reset)
43113: {
43113:     return mConn->OnHeadersAvailable(trans, req, resp, reset);
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::nsConnectionHandle::ResumeSend()
43113: {
43113:     return mConn->ResumeSend();
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::nsConnectionHandle::ResumeRecv()
43113: {
43113:     return mConn->ResumeRecv();
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::nsConnectionHandle::CloseTransaction(nsAHttpTransaction *trans, nsresult reason)
43113: {
43113:     mConn->CloseTransaction(trans, reason);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::nsConnectionHandle::GetConnectionInfo(nsHttpConnectionInfo **result)
43113: {
43113:     mConn->GetConnectionInfo(result);
43113: }
43113: 
43113: void
43113: nsHttpConnectionMgr::nsConnectionHandle::GetSecurityInfo(nsISupports **result)
43113: {
43113:     mConn->GetSecurityInfo(result);
43113: }
43113: 
43113: PRBool
43113: nsHttpConnectionMgr::nsConnectionHandle::IsPersistent()
43113: {
43113:     return mConn->IsPersistent();
43113: }
43113: 
43113: PRBool
43113: nsHttpConnectionMgr::nsConnectionHandle::IsReused()
43113: {
43113:     return mConn->IsReused();
43113: }
43113: 
43113: nsresult
43113: nsHttpConnectionMgr::nsConnectionHandle::PushBack(const char *buf, PRUint32 bufLen)
43113: {
43113:     return mConn->PushBack(buf, bufLen);
43113: }
55822: 
