59900: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52873:  * vim: set ts=4 sw=4 et tw=99:
52873:  *
52873:  * ***** BEGIN LICENSE BLOCK *****
52873:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52873:  *
52873:  * The contents of this file are subject to the Mozilla Public License Version
52873:  * 1.1 (the "License"); you may not use this file except in compliance with
52873:  * the License. You may obtain a copy of the License at
52873:  * http://www.mozilla.org/MPL/
52873:  *
52873:  * Software distributed under the License is distributed on an "AS IS" basis,
52873:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52873:  * for the specific language governing rights and limitations under the
52873:  * License.
52873:  *
52873:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52873:  * May 28, 2008.
52873:  *
52873:  * The Initial Developer of the Original Code is
52873:  *   Brendan Eich <brendan@mozilla.org>
52873:  *
52873:  * Contributor(s):
52873:  *   David Anderson <danderson@mozilla.com>
52873:  *   David Mandelin <dmandelin@mozilla.com>
52873:  *
52873:  * Alternatively, the contents of this file may be used under the terms of
52873:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52873:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52873:  * in which case the provisions of the GPL or the LGPL are applicable instead
52873:  * of those above. If you wish to allow use of your version of this file only
52873:  * under the terms of either the GPL or the LGPL, and not to allow others to
52873:  * use your version of this file under the terms of the MPL, indicate your
52873:  * decision by deleting the provisions above and replace them with the notice
52873:  * and other provisions required by the GPL or the LGPL. If you do not delete
52873:  * the provisions above, a recipient may use your version of this file under
52873:  * the terms of any one of the MPL, the GPL or the LGPL.
52873:  *
52873:  * ***** END LICENSE BLOCK ***** */
52873: 
52873: #include "jscntxt.h"
52873: #include "jsscope.h"
52873: #include "jsobj.h"
52873: #include "jslibmath.h"
52873: #include "jsiter.h"
52873: #include "jsnum.h"
52873: #include "jsxml.h"
52873: #include "jsstaticcheck.h"
52873: #include "jsbool.h"
52873: #include "assembler/assembler/MacroAssemblerCodeRef.h"
53133: #include "assembler/assembler/CodeLocation.h"
52873: #include "jsiter.h"
52873: #include "jstypes.h"
52873: #include "methodjit/StubCalls.h"
52873: #include "jstracer.h"
52873: #include "jspropertycache.h"
53133: #include "methodjit/MonoIC.h"
56602: #include "jsanalyze.h"
58063: #include "methodjit/BaseCompiler.h"
60591: #include "methodjit/ICRepatcher.h"
53133: 
53840: #include "jsinterpinlines.h"
52873: #include "jspropertycacheinlines.h"
52873: #include "jsscopeinlines.h"
52873: #include "jsscriptinlines.h"
52873: #include "jsstrinlines.h"
52873: #include "jsobjinlines.h"
52873: #include "jscntxtinlines.h"
52873: #include "jsatominlines.h"
54832: #include "StubCalls-inl.h"
62574: #include "MethodJIT-inl.h"
52873: 
52873: #include "jsautooplen.h"
52873: 
52873: using namespace js;
52873: using namespace js::mjit;
52873: using namespace JSC;
52873: 
60591: using ic::Repatcher;
60591: 
52873: static jsbytecode *
52873: FindExceptionHandler(JSContext *cx)
52873: {
69223:     StackFrame *fp = cx->fp();
53840:     JSScript *script = fp->script();
52873: 
52873: top:
60211:     if (cx->isExceptionPending() && JSScript::isValidOffset(script->trynotesOffset)) {
52873:         // The PC is updated before every stub call, so we can use it here.
69223:         unsigned offset = cx->regs().pc - script->main;
52873: 
52873:         JSTryNoteArray *tnarray = script->trynotes();
52873:         for (unsigned i = 0; i < tnarray->length; ++i) {
52873:             JSTryNote *tn = &tnarray->vector[i];
57782: 
53496:             // The following if condition actually tests two separate conditions:
53496:             //   (1) offset - tn->start >= tn->length
53496:             //       means the PC is not in the range of this try note, so we
53496:             //       should continue searching, after considering:
53496:             //   (2) offset - tn->start == tn->length
53496:             //       means the PC is at the first op of the exception handler
53496:             //       for this try note. This happens when an exception is thrown
53496:             //       during recording: the interpreter sets the PC to the handler
53496:             //       and then exits. In this case, we are in fact at the right
53496:             //       exception handler. 
53496:             //      
53496:             //       Hypothetically, the op we are at might have thrown an
53496:             //       exception, in which case this would not be the right handler.
53496:             //       But the first ops of exception handlers generated by our
53496:             //       bytecode compiler cannot throw, so this is not possible.
53496:             if (offset - tn->start > tn->length)
52873:                 continue;
69223:             if (tn->stackDepth > cx->regs().sp - fp->base())
52873:                 continue;
52873: 
52873:             jsbytecode *pc = script->main + tn->start + tn->length;
52873:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
69223:             JS_ASSERT(cx->regs().sp == fp->base() + tn->stackDepth);
52873: 
52873:             switch (tn->kind) {
52873:                 case JSTRY_CATCH:
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENTERBLOCK);
52873: 
52873: #if JS_HAS_GENERATORS
52873:                   /* Catch cannot intercept the closing of a generator. */
60211:                   if (JS_UNLIKELY(cx->getPendingException().isMagic(JS_GENERATOR_CLOSING)))
52873:                       break;
52873: #endif
52873: 
52873:                   /*
52873:                    * Don't clear cx->throwing to save cx->exception from GC
52873:                    * until it is pushed to the stack via [exception] in the
52873:                    * catch block.
52873:                    */
52873:                   return pc;
52873: 
52873:                 case JSTRY_FINALLY:
52873:                   /*
52873:                    * Push (true, exception) pair for finally to indicate that
52873:                    * [retsub] should rethrow the exception.
52873:                    */
69223:                   cx->regs().sp[0].setBoolean(true);
69223:                   cx->regs().sp[1] = cx->getPendingException();
69223:                   cx->regs().sp += 2;
60211:                   cx->clearPendingException();
52873:                   return pc;
52873: 
52873:                 case JSTRY_ITER:
52873:                 {
52873:                   /*
52873:                    * This is similar to JSOP_ENDITER in the interpreter loop,
52873:                    * except the code now uses the stack slot normally used by
52873:                    * JSOP_NEXTITER, namely regs.sp[-1] before the regs.sp -= 2
52873:                    * adjustment and regs.sp[1] after, to save and restore the
52873:                    * pending exception.
52873:                    */
60211:                   Value v = cx->getPendingException();
53840:                   JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == JSOP_ENDITER);
60211:                   cx->clearPendingException();
69223:                   ok = !!js_CloseIterator(cx, &cx->regs().sp[-1].toObject());
69223:                   cx->regs().sp -= 1;
52873:                   if (!ok)
52873:                       goto top;
60211:                   cx->setPendingException(v);
52873:                 }
52873:             }
52873:         }
52873:     }
52873: 
52873:     return NULL;
52873: }
52873: 
54832: /*
68952:  * Clean up a frame and return.
68952:  */
68952: static void
68952: InlineReturn(VMFrame &f)
68952: {
76020:     JS_ASSERT(f.cx->fp() != f.entryfp);
76020:     JS_ASSERT(!js_IsActiveWithOrBlock(f.cx, &f.cx->fp()->scopeChain(), 0));
69223:     f.cx->stack.popInlineFrame();
68952: }
68952: 
68952: void JS_FASTCALL
68952: stubs::SlowCall(VMFrame &f, uint32 argc)
68952: {
68952:     Value *vp = f.regs.sp - (argc + 2);
68952: 
69223:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:         THROW();
68952: }
68952: 
68952: void JS_FASTCALL
68952: stubs::SlowNew(VMFrame &f, uint32 argc)
68952: {
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952: 
69223:     if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:         THROW();
68952: }
68952: 
68952: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: static inline void
69223: RemovePartialFrame(JSContext *cx, StackFrame *fp)
53590: {
69223:     cx->stack.popInlineFrame();
53590: }
53590: 
76020: static inline bool
76020: CheckStackQuota(VMFrame &f)
76020: {
76020:     /* Include extra space for any inline frames. */
76020:     uint32 nvals = f.fp()->script()->nslots + VALUES_PER_STACK_FRAME + StackSpace::STACK_EXTRA;
76020:     if ((Value *)f.fp() + nvals >= f.stackLimit) {
76020:         StackSpace &space = f.cx->stack.space();
76020:         if (!space.bumpLimitWithinQuota(NULL, f.entryfp, f.regs.sp, nvals, &f.stackLimit)) {
76020:             /* Remove the current partially-constructed frame before throwing. */
76020:             RemovePartialFrame(f.cx, f.fp());
76020:             js_ReportOverRecursed(f.cx);
76020:             return false;
76020:         }
76020:     }
76020:     return true;
76020: }
76020: 
53840: /*
53840:  * HitStackQuota is called after the early prologue pushing the new frame would
53840:  * overflow f.stackLimit.
53840:  */
53590: void JS_FASTCALL
53840: stubs::HitStackQuota(VMFrame &f)
53590: {
76020:     if (!CheckStackQuota(f))
53590:         THROW();
53590: }
53590: 
53840: /*
53840:  * This function must only be called after the early prologue, since it depends
53840:  * on fp->exec.fun.
53840:  */
53590: void * JS_FASTCALL
53840: stubs::FixupArity(VMFrame &f, uint32 nactual)
53590: {
53590:     JSContext *cx = f.cx;
69223:     StackFrame *oldfp = f.fp();
53590: 
53840:     JS_ASSERT(nactual != oldfp->numFormalArgs());
53590: 
53590:     /*
53590:      * Grossssss! *move* the stack frame. If this ends up being perf-critical,
53840:      * we can figure out how to spot-optimize it. Be careful to touch only the
53840:      * members that have been initialized by initCallFrameCallerHalf and the
53840:      * early prologue.
53590:      */
53840:     uint32 flags         = oldfp->isConstructingFlag();
53840:     JSFunction *fun      = oldfp->fun();
53840:     void *ncode          = oldfp->nativeReturnAddress();
53590: 
53590:     /* Pop the inline frame. */
69223:     f.regs.popPartialFrame((Value *)oldfp);
53590: 
53840:     /* Reserve enough space for a callee frame. */
69223:     StackFrame *newfp = cx->stack.getInlineFrameWithinLimit(cx, (Value*) oldfp, nactual,
53840:                                                             fun, fun->script(), &flags,
76020:                                                             f.entryfp, &f.stackLimit, ncode);
76020:     if (!newfp)
53840:         THROWV(NULL);
53590: 
53840:     /* Reset the part of the stack frame set by the caller. */
57715:     newfp->initCallFrameCallerHalf(cx, flags, ncode);
53590: 
53840:     /* Reset the part of the stack frame set by the prologue up to now. */
57715:     newfp->initCallFrameEarlyPrologue(fun, nactual);
53590: 
53840:     /* The caller takes care of assigning fp to regs. */
53590:     return newfp;
53590: }
53590: 
76143: struct ResetStubRejoin {
76143:     VMFrame &f;
76143:     ResetStubRejoin(VMFrame &f) : f(f) {}
76143:     ~ResetStubRejoin() { f.stubRejoin = 0; }
76143: };
76143: 
53590: void * JS_FASTCALL
76143: stubs::CompileFunction(VMFrame &f, uint32 argc)
53590: {
53590:     /*
76020:      * Note: the stubRejoin kind for the frame was written before the call, and
76020:      * needs to be cleared out on all return paths (doing this directly in the
76020:      * IC stub will not handle cases where we recompiled or threw).
76010:      */
76020:     JS_ASSERT_IF(f.cx->typeInferenceEnabled(), f.stubRejoin);
76143:     ResetStubRejoin reset(f);
76010: 
76143:     bool isConstructing = f.fp()->isConstructing();
76143:     f.regs.popPartialFrame((Value *)f.fp());
53590: 
76143:     return isConstructing ? UncachedNew(f, argc) : UncachedCall(f, argc);
53590: }
53590: 
68952: static inline bool
76061: UncachedInlineCall(VMFrame &f, uint32 flags, void **pret, bool *unjittable, uint32 argc)
68952: {
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952:     JSObject &callee = vp->toObject();
68952:     JSFunction *newfun = callee.getFunctionPrivate();
68952:     JSScript *newscript = newfun->script();
68952: 
76001:     bool newType = (flags & StackFrame::CONSTRUCTING) && cx->typeInferenceEnabled() &&
75864:         types::UseNewType(cx, f.script(), f.pc());
75788: 
75975:     CallArgs args = CallArgsFromVp(argc, vp);
76020:     cx->typeMonitorCall(args, flags & StackFrame::CONSTRUCTING);
75636: 
68952:     /* Get pointer to new frame/slots, prepare arguments. */
69223:     StackFrame *newfp = cx->stack.getInlineFrameWithinLimit(cx, f.regs.sp, argc,
68952:                                                             newfun, newscript, &flags,
76020:                                                             f.entryfp, &f.stackLimit, NULL);
68952:     if (JS_UNLIKELY(!newfp))
68952:         return false;
68952: 
68952:     /* Initialize frame, locals. */
68952:     newfp->initCallFrame(cx, callee, newfun, argc, flags);
68952:     SetValueRangeToUndefined(newfp->slots(), newscript->nfixed);
68952: 
76041:     /*
76041:      * Preserve f.regs.fp while pushing the new frame, for the invariant that
76041:      * f.regs reflects the state when we entered the stub call.
76041:      */
76041:     FrameRegs regs = f.regs;
76041:     PreserveRegsGuard regsGuard(cx, regs);
76041: 
68952:     /* Officially push the frame. */
76020:     cx->stack.pushInlineFrame(newscript, newfp, regs);
68952: 
68952:     /* Scope with a call object parented by callee's parent. */
68952:     if (newfun->isHeavyweight() && !js::CreateFunCallObject(cx, newfp))
68952:         return false;
68952: 
68952:     /* Try to compile if not already compiled. */
68952:     if (newscript->getJITStatus(newfp->isConstructing()) == JITScript_None) {
68952:         CompileStatus status = CanMethodJIT(cx, newscript, newfp, CompileRequest_Interpreter);
68952:         if (status == Compile_Error) {
68952:             /* A runtime exception was thrown, get out. */
68952:             InlineReturn(f);
68952:             return false;
68952:         }
68952:         if (status == Compile_Abort)
68952:             *unjittable = true;
68952:     }
68952: 
75788:     /*
75788:      * If newscript was successfully compiled, run it. Skip for calls which
75788:      * will be constructing a new type object for 'this'.
75788:      */
75788:     if (!newType) {
68952:         if (JITScript *jit = newscript->getJIT(newfp->isConstructing())) {
68952:             *pret = jit->invokeEntry;
75956: 
75956:             /*
75956:              * Keep the old fp around and let the JIT code repush it. If we are
75956:              * rejoining into a recompiled frame then the code patching up
75956:              * doubles needs to see the calling script's frame.
75956:              */
76020:             regs.popFrame((Value *) regs.fp());
68952:             return true;
68952:         }
75788:     }
68952: 
68952:     /* Otherwise, run newscript in the interpreter. */
68952:     bool ok = !!Interpret(cx, cx->fp());
68952:     InlineReturn(f);
68952: 
68952:     *pret = NULL;
68952:     return ok;
68952: }
68952: 
68952: void * JS_FASTCALL
68952: stubs::UncachedNew(VMFrame &f, uint32 argc)
68952: {
68952:     UncachedCallResult ucr;
76061:     UncachedNewHelper(f, argc, &ucr);
68952:     return ucr.codeAddr;
68952: }
68952: 
68952: void
76061: stubs::UncachedNewHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
68952: {
68952:     ucr->init();
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952:     /* Try to do a fast inline call before the general Invoke path. */
68964:     if (IsFunctionObject(*vp, &ucr->fun) && ucr->fun->isInterpretedConstructor()) {
68952:         ucr->callee = &vp->toObject();
76061:         if (!UncachedInlineCall(f, StackFrame::CONSTRUCTING, &ucr->codeAddr, &ucr->unjittable, argc))
68952:             THROW();
68952:     } else {
69223:         if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:             THROW();
68952:     }
68952: }
68952: 
68952: void * JS_FASTCALL
68952: stubs::UncachedCall(VMFrame &f, uint32 argc)
68952: {
68952:     UncachedCallResult ucr;
76061:     UncachedCallHelper(f, argc, &ucr);
68952:     return ucr.codeAddr;
68952: }
68952: 
56775: void JS_FASTCALL
56775: stubs::Eval(VMFrame &f, uint32 argc)
56775: {
56775:     Value *vp = f.regs.sp - (argc + 2);
56775: 
69223:     if (!IsBuiltinEvalForScope(&f.fp()->scopeChain(), *vp)) {
69223:         if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
56775:             THROW();
56775:         return;
56775:     }
56775: 
69223:     JS_ASSERT(f.fp() == f.cx->fp());
68894:     if (!DirectEval(f.cx, CallArgsFromVp(argc, vp)))
56775:         THROW();
68894: 
68894:     f.regs.sp = vp + 1;
56775: }
56775: 
68952: void
76061: stubs::UncachedCallHelper(VMFrame &f, uint32 argc, UncachedCallResult *ucr)
68952: {
68952:     ucr->init();
68952: 
68952:     JSContext *cx = f.cx;
68952:     Value *vp = f.regs.sp - (argc + 2);
68952: 
68952:     if (IsFunctionObject(*vp, &ucr->callee)) {
68952:         ucr->callee = &vp->toObject();
68952:         ucr->fun = GET_FUNCTION_PRIVATE(cx, ucr->callee);
68952: 
68952:         if (ucr->fun->isInterpreted()) {
76061:             if (!UncachedInlineCall(f, 0, &ucr->codeAddr, &ucr->unjittable, argc))
68952:                 THROW();
68952:             return;
68952:         }
68952: 
68952:         if (ucr->fun->isNative()) {
68952:             if (!CallJSNative(cx, ucr->fun->u.n.native, argc, vp))
68952:                 THROW();
68952:             return;
68952:         }
68952:     }
68952: 
69223:     if (!Invoke(f.cx, InvokeArgsAlreadyOnTheStack(argc, vp)))
68952:         THROW();
68952: 
68952:     return;
68952: }
68952: 
52873: void JS_FASTCALL
53840: stubs::PutActivationObjects(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->hasCallObj() || f.fp()->hasArgsObj());
69223:     f.fp()->putActivationObjects();
52873: }
52873: 
76067: static void
76067: RemoveOrphanedNative(JSContext *cx, StackFrame *fp)
76067: {
76067:     /*
76067:      * Remove fp from the list of frames holding a reference on the orphaned
76067:      * native pools. If all the references have been removed, release all the
76067:      * pools. We don't release pools piecemeal as a pool can be referenced by
76067:      * multiple frames.
76067:      */
76067:     JaegerCompartment *jc = cx->compartment->jaegerCompartment;
76067:     if (jc->orphanedNativeFrames.empty())
76067:         return;
76067:     for (unsigned i = 0; i < jc->orphanedNativeFrames.length(); i++) {
76067:         if (fp == jc->orphanedNativeFrames[i]) {
76067:             jc->orphanedNativeFrames[i] = jc->orphanedNativeFrames.back();
76067:             jc->orphanedNativeFrames.popBack();
76067:             break;
76067:         }
76067:     }
76067:     if (jc->orphanedNativeFrames.empty()) {
76067:         for (unsigned i = 0; i < jc->orphanedNativePools.length(); i++)
76067:             jc->orphanedNativePools[i]->release();
76067:         jc->orphanedNativePools.clear();
76067:     }
76067: }
76067: 
52873: extern "C" void *
52873: js_InternalThrow(VMFrame &f)
52873: {
52873:     JSContext *cx = f.cx;
52873: 
76067:     // The current frame may have an associated orphaned native, if the native
76067:     // or SplatApplyArgs threw an exception.
76067:     RemoveOrphanedNative(cx, f.fp());
76067: 
60540:     // It's possible that from within RunTracer(), Interpret() returned with
60540:     // an error and finished the frame (i.e., called ScriptEpilogue), but has
60540:     // not yet performed an inline return.
60540:     //
60540:     // In this case, RunTracer() has no choice but to propagate the error
60540:     // up to the method JIT, and thus to this function. But ScriptEpilogue()
60540:     // has already been called. Detect this, and avoid double-finishing the
60540:     // frame. See HandleErrorInExcessFrame() and bug 624100.
60540:     if (f.fp()->finishedInInterpreter()) {
60540:         // If it's the last frame, just propagate the failure up again.
60540:         if (f.fp() == f.entryfp)
60540:             return NULL;
60540: 
60540:         InlineReturn(f);
60540:     }
60540: 
52873:     // Make sure sp is up to date.
69223:     JS_ASSERT(&cx->regs() == &f.regs);
52873: 
53410:     // Call the throw hook if necessary
53410:     JSThrowHook handler = f.cx->debugHooks->throwHook;
53410:     if (handler) {
53410:         Value rval;
75864:         switch (handler(cx, f.script(), f.pc(), Jsvalify(&rval), cx->debugHooks->throwHookData)) {
53410:           case JSTRAP_ERROR:
60211:             cx->clearPendingException();
53410:             return NULL;
53410: 
53410:           case JSTRAP_RETURN:
60211:             cx->clearPendingException();
53482:             cx->fp()->setReturnValue(rval);
67899:             return cx->jaegerCompartment()->forceReturnFromExternC();
53410: 
53410:           case JSTRAP_THROW:
60211:             cx->setPendingException(rval);
53410:             break;
53410: 
53410:           default:
53410:             break;
53410:         }
53410:     }
53410: 
52873:     jsbytecode *pc = NULL;
52873:     for (;;) {
52873:         pc = FindExceptionHandler(cx);
52873:         if (pc)
52873:             break;
52873: 
60540:         // The JIT guarantees that ScriptEpilogue() has always been run
60540:         // upon exiting to its caller. This is important for consistency,
60540:         // where execution modes make similar guarantees about prologues
60540:         // and epilogues. RunTracer(), Interpret(), and Invoke() all
60540:         // rely on this property.
60540:         JS_ASSERT(!f.fp()->finishedInInterpreter());
60211:         js_UnwindScope(cx, 0, cx->isExceptionPending());
56201:         ScriptEpilogue(f.cx, f.fp(), false);
56201: 
60540:         // Don't remove the last frame, this is the responsibility of
60540:         // JaegerShot()'s caller. We only guarantee that ScriptEpilogue()
60540:         // has been run.
60540:         if (f.entryfp == f.fp())
52873:             break;
52873: 
69223:         JS_ASSERT(f.regs.sp == cx->regs().sp);
56201:         InlineReturn(f);
52873:     }
52873: 
69223:     JS_ASSERT(f.regs.sp == cx->regs().sp);
52873: 
53626:     if (!pc)
52873:         return NULL;
52873: 
69223:     StackFrame *fp = cx->fp();
55503:     JSScript *script = fp->script();
76020: 
76020:     if (!fp->jit()) {
76020:         /*
76020:          * This frame had JIT code at one point, but it has since been
76020:          * discarded due to a recompilation. Recompile it now. This can only
76020:          * fail due to OOM, in which case that OOM will propagate above the
76020:          * JaegerShot activation.
76020:          */
76020:         CompileStatus status = TryCompile(cx, fp);
76020:         if (status != Compile_Okay)
76020:             return NULL;
76020:     }
76020: 
55520:     return script->nativeCodeForPC(fp->isConstructing(), pc);
52873: }
52873: 
52873: void JS_FASTCALL
64364: stubs::CreateFunCallObject(VMFrame &f)
52873: {
53840:     JS_ASSERT(f.fp()->fun()->isHeavyweight());
64364:     if (!js::CreateFunCallObject(f.cx, f.fp()))
52873:         THROW();
52873: }
52873: 
55503: void JS_FASTCALL
55503: stubs::CreateThis(VMFrame &f, JSObject *proto)
55503: {
55503:     JSContext *cx = f.cx;
69223:     StackFrame *fp = f.fp();
55503:     JSObject *callee = &fp->callee();
55503:     JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
55503:     if (!obj)
55503:         THROW();
55503:     fp->formalArgs()[-1].setObject(*obj);
55503: }
55503: 
56201: void JS_FASTCALL
64363: stubs::ScriptDebugPrologue(VMFrame &f)
53133: {
64363:     js::ScriptDebugPrologue(f.cx, f.fp());
56201: }
56201: 
56201: void JS_FASTCALL
64363: stubs::ScriptDebugEpilogue(VMFrame &f)
56201: {
64363:     if (!js::ScriptDebugEpilogue(f.cx, f.fp(), JS_TRUE))
56201:         THROW();
56201: }
53133: 
53133: #ifdef JS_TRACER
53133: 
56201: /*
56201:  * Called when an error is in progress and the topmost frame could not handle
56201:  * it. This will unwind to a given frame, or find and align to an exception
56201:  * handler in the process.
56201:  */
53133: static inline bool
69223: HandleErrorInExcessFrame(VMFrame &f, StackFrame *stopFp, bool searchedTopmostFrame = true)
53133: {
53133:     JSContext *cx = f.cx;
53133: 
54736:     /*
54736:      * Callers of this called either Interpret() or JaegerShot(), which would
54736:      * have searched for exception handlers already. If we see stopFp, just
54736:      * return false. Otherwise, pop the frame, since it's guaranteed useless.
56201:      *
56201:      * Note that this also guarantees ScriptEpilogue() has been called.
54736:      */
69223:     StackFrame *fp = cx->fp();
56201:     if (searchedTopmostFrame) {
60540:         /*
60540:          * This is a special case meaning that fp->finishedInInterpreter() is
60540:          * true. If so, and fp == stopFp, our only choice is to propagate this
60540:          * error up, back to the method JIT, and then to js_InternalThrow,
60540:          * where this becomes a special case. See the comment there and bug
60540:          * 624100.
60540:          */
54736:         if (fp == stopFp)
54736:             return false;
54736: 
60540:         /*
60540:          * Otherwise, the protocol here (like Invoke) is to assume that the
60540:          * execution mode finished the frame, and to just pop it.
60540:          */
56201:         InlineReturn(f);
56201:     }
54736: 
54727:     /* Remove the bottom frame. */
56201:     bool returnOK = false;
54727:     for (;;) {
54736:         fp = cx->fp();
54723: 
54736:         /* Clear imacros. */
54736:         if (fp->hasImacropc()) {
69223:             cx->regs().pc = fp->imacropc();
53840:             fp->clearImacropc();
53133:         }
53840:         JS_ASSERT(!fp->hasImacropc());
53133: 
53133:         /* If there's an exception and a handler, set the pc and leave. */
60211:         if (cx->isExceptionPending()) {
53133:             jsbytecode *pc = FindExceptionHandler(cx);
53133:             if (pc) {
69223:                 cx->regs().pc = pc;
54736:                 returnOK = true;
53133:                 break;
53133:             }
54736:         }
53133: 
53133:         /* Don't unwind if this was the entry frame. */
53133:         if (fp == stopFp)
53133:             break;
53133: 
53133:         /* Unwind and return. */
60211:         returnOK &= bool(js_UnwindScope(cx, 0, returnOK || cx->isExceptionPending()));
56201:         returnOK = ScriptEpilogue(cx, fp, returnOK);
56201:         InlineReturn(f);
53133:     }
53133: 
69223:     JS_ASSERT(&f.regs == &cx->regs());
54739:     JS_ASSERT_IF(!returnOK, cx->fp() == stopFp);
53133: 
54736:     return returnOK;
53133: }
53133: 
56201: /* Returns whether the current PC has method JIT'd code. */
55520: static inline void *
53133: AtSafePoint(JSContext *cx)
53133: {
69223:     StackFrame *fp = cx->fp();
53840:     if (fp->hasImacropc())
68902:         return NULL;
53133: 
53840:     JSScript *script = fp->script();
69223:     return script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs().pc);
53133: }
53133: 
56201: /*
56201:  * Interprets until either a safe point is reached that has method JIT'd
56201:  * code, or the current frame tries to return.
56201:  */
53133: static inline JSBool
53428: PartialInterpret(VMFrame &f)
53133: {
53428:     JSContext *cx = f.cx;
69223:     StackFrame *fp = cx->fp();
53133: 
55503: #ifdef DEBUG
55520:     JSScript *script = fp->script();
56201:     JS_ASSERT(!fp->finishedInInterpreter());
55520:     JS_ASSERT(fp->hasImacropc() ||
69223:               !script->maybeNativeCodeForPC(fp->isConstructing(), cx->regs().pc));
55503: #endif
53133: 
53133:     JSBool ok = JS_TRUE;
53626:     ok = Interpret(cx, fp, 0, JSINTERP_SAFEPOINT);
53133: 
53133:     return ok;
53133: }
53133: 
53133: JS_STATIC_ASSERT(JSOP_NOP == 0);
53133: 
63239: /*
63239:  * Returns whether the current PC would return, or if the frame has already
63239:  * been completed. This distinction avoids re-entering the interpreter or JIT
63239:  * to complete a JSOP_RETURN. Instead, that edge case is handled in
63239:  * HandleFinishedFrame. We could consider reducing complexity, and making this
63239:  * function return only "finishedInInterpreter", and always using the full VM
63239:  * machinery to fully finish frames.
63239:  */
63239: static inline bool
53133: FrameIsFinished(JSContext *cx)
53133: {
69223:     JSOp op = JSOp(*cx->regs().pc);
53133:     return (op == JSOP_RETURN ||
53133:             op == JSOP_RETRVAL ||
53133:             op == JSOP_STOP)
63239:         ? true
63239:         : cx->fp()->finishedInInterpreter();
53133: }
53133: 
56201: 
56201: /* Simulate an inline_return by advancing the pc. */
56201: static inline void
56201: AdvanceReturnPC(JSContext *cx)
56201: {
69223:     JS_ASSERT(*cx->regs().pc == JSOP_CALL ||
69223:               *cx->regs().pc == JSOP_NEW ||
69223:               *cx->regs().pc == JSOP_EVAL ||
69223:               *cx->regs().pc == JSOP_FUNCALL ||
69223:               *cx->regs().pc == JSOP_FUNAPPLY);
69223:     cx->regs().pc += JSOP_CALL_LENGTH;
56201: }
56201: 
56201: 
56201: /*
56201:  * Given a frame that is about to return, make sure its return value and
56201:  * activation objects are fixed up. Then, pop the frame and advance the
56201:  * current PC. Note that while we could enter the JIT at this point, the
56201:  * logic would still be necessary for the interpreter, so it's easier
56201:  * (and faster) to finish frames in C++ even if at a safe point here.
56201:  */
56201: static bool
69223: HandleFinishedFrame(VMFrame &f, StackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
56201: 
56201:     JS_ASSERT(FrameIsFinished(cx));
56201: 
56201:     /*
56201:      * This is the most difficult and complicated piece of the tracer
56201:      * integration, and historically has been very buggy. The problem is that
56201:      * although this frame has to be popped (see RemoveExcessFrames), it may
56201:      * be at a JSOP_RETURN opcode, and it might not have ever been executed.
56201:      * That is, fp->rval may not be set to the top of the stack, and if it
56201:      * has, the stack has already been decremented. Note that fp->rval is not
56201:      * the only problem: the epilogue may never have been executed.
56201:      *
56201:      * Here are the edge cases and whether the frame has been exited cleanly:
56201:      *  1. No: A trace exited directly before a RETURN op, and the
56201:      *         interpreter never ran.
56201:      *  2. Yes: The interpreter exited cleanly.
56201:      *  3. No: The interpreter exited on a safe point. LEAVE_ON_SAFE_POINT
56201:      *         is not used in between JSOP_RETURN and advancing the PC,
56201:      *         therefore, it cannot have been run if at a safe point.
56201:      *  4. No: Somewhere in the RunTracer call tree, we removed a frame,
56201:      *         and we returned to a JSOP_RETURN opcode. Note carefully
56201:      *         that in this situation, FrameIsFinished() returns true!
63239:      *  5. Yes: The function exited in the method JIT, during
63239:      *         FinishExcessFrames() However, in this case, we'll never enter
63239:      *         HandleFinishedFrame(): we always immediately pop JIT'd frames.
56201:      *
56201:      * Since the only scenario where this fixup is NOT needed is a normal exit
56201:      * from the interpreter, we can cleanly check for this scenario by checking
56201:      * a bit it sets in the frame.
56201:      */
56201:     bool returnOK = true;
56201:     if (!cx->fp()->finishedInInterpreter()) {
69223:         if (JSOp(*cx->regs().pc) == JSOP_RETURN)
56201:             cx->fp()->setReturnValue(f.regs.sp[-1]);
56201: 
56201:         returnOK = ScriptEpilogue(cx, cx->fp(), true);
56201:     }
56201: 
56201:     if (cx->fp() != entryFrame) {
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:     }
56201: 
56201:     return returnOK;
56201: }
56201: 
56201: /*
56201:  * Given a frame newer than the entry frame, try to finish it. If it's at a
56201:  * return position, pop the frame. If it's at a safe point, execute it in
56201:  * Jaeger code. Otherwise, try to interpret until a safe point.
56201:  *
56201:  * While this function is guaranteed to make progress, it may not actually
56201:  * finish or pop the current frame. It can either:
56201:  *   1) Finalize a finished frame, or
56201:  *   2) Finish and finalize the frame in the Method JIT, or
56201:  *   3) Interpret, which can:
56201:  *     a) Propagate an error, or
56201:  *     b) Finish the frame, but not finalize it, or
56201:  *     c) Abruptly leave at any point in the frame, or in a newer frame
56201:  *        pushed by a call, that has method JIT'd code.
56201:  */
56201: static bool
69223: EvaluateExcessFrame(VMFrame &f, StackFrame *entryFrame)
56201: {
56201:     JSContext *cx = f.cx;
69223:     StackFrame *fp = cx->fp();
56201: 
56201:     /*
56201:      * A "finished" frame is when the interpreter rested on a STOP,
56201:      * RETURN, RETRVAL, etc. We check for finished frames BEFORE looking
56201:      * for a safe point. If the frame was finished, we could have already
56201:      * called ScriptEpilogue(), and entering the JIT could call it twice.
56201:      */
56201:     if (!fp->hasImacropc() && FrameIsFinished(cx))
56201:         return HandleFinishedFrame(f, entryFrame);
56201: 
56201:     if (void *ncode = AtSafePoint(cx)) {
56201:         if (!JaegerShotAtSafePoint(cx, ncode))
56201:             return false;
56201:         InlineReturn(f);
56201:         AdvanceReturnPC(cx);
56201:         return true;
56201:     }
56201: 
56201:     return PartialInterpret(f);
56201: }
56201: 
56201: /*
56201:  * Evaluate frames newer than the entry frame until all are gone. This will
56201:  * always leave f.regs.fp == entryFrame.
56201:  */
53133: static bool
69223: FinishExcessFrames(VMFrame &f, StackFrame *entryFrame)
53133: {
53133:     JSContext *cx = f.cx;
56201: 
56033:     while (cx->fp() != entryFrame || entryFrame->hasImacropc()) {
56201:         if (!EvaluateExcessFrame(f, entryFrame)) {
56201:             if (!HandleErrorInExcessFrame(f, entryFrame))
56033:                 return false;
53133:         }
53133:     }
53133: 
53133:     return true;
53133: }
53133: 
60591: #if defined JS_MONOIC
53133: static void
58063: UpdateTraceHintSingle(Repatcher &repatcher, JSC::CodeLocationJump jump, JSC::CodeLocationLabel target)
53133: {
53133:     /*
53133:      * Hack: The value that will be patched is before the executable address,
53133:      * so to get protection right, just unprotect the general region around
53133:      * the jump.
53133:      */
58063:     repatcher.relink(jump, target);
53277: 
53277:     JaegerSpew(JSpew_PICs, "relinking trace hint %p to %p\n",
54160:                jump.executableAddress(), target.executableAddress());
53277: }
54160: 
54160: static void
61056: DisableTraceHint(JITScript *jit, ic::TraceICInfo &ic)
54160: {
61056:     Repatcher repatcher(jit);
75716:     UpdateTraceHintSingle(repatcher, ic.traceHint, ic.fastTarget);
54160: 
60567:     if (ic.hasSlowTraceHint)
75716:         UpdateTraceHintSingle(repatcher, ic.slowTraceHint, ic.slowTarget);
56217: }
54160: 
56217: static void
60567: ResetTraceHintAt(JSScript *script, js::mjit::JITScript *jit,
60567:                  jsbytecode *pc, uint16_t index, bool full)
56217: {
59742:     if (index >= jit->nTraceICs)
59742:         return;
62075:     ic::TraceICInfo &ic = jit->traceICs()[index];
60567:     if (!ic.initialized)
59742:         return;
56217:     
60567:     JS_ASSERT(ic.jumpTargetPC == pc);
56217: 
56217:     JaegerSpew(JSpew_PICs, "Enabling trace IC %u in script %p\n", index, script);
56217: 
58063:     Repatcher repatcher(jit);
58063: 
60567:     UpdateTraceHintSingle(repatcher, ic.traceHint, ic.stubEntry);
56217: 
60567:     if (ic.hasSlowTraceHint)
60567:         UpdateTraceHintSingle(repatcher, ic.slowTraceHint, ic.stubEntry);
60567: 
60567:     if (full) {
60567:         ic.traceData = NULL;
60567:         ic.loopCounterStart = 1;
60567:         ic.loopCounter = ic.loopCounterStart;
60567:     }
53133: }
53133: #endif
53133: 
56217: void
60567: js::mjit::ResetTraceHint(JSScript *script, jsbytecode *pc, uint16_t index, bool full)
56217: {
56217: #if JS_MONOIC
56217:     if (script->jitNormal)
60567:         ResetTraceHintAt(script, script->jitNormal, pc, index, full);
56217: 
56217:     if (script->jitCtor)
60567:         ResetTraceHintAt(script, script->jitCtor, pc, index, full);
56217: #endif
56217: }
56217: 
53133: #if JS_MONOIC
53133: void *
60567: RunTracer(VMFrame &f, ic::TraceICInfo &ic)
53133: #else
53133: void *
53133: RunTracer(VMFrame &f)
53133: #endif
53133: {
53133:     JSContext *cx = f.cx;
69223:     StackFrame *entryFrame = f.fp();
53133:     TracePointAction tpa;
53133: 
53133:     /* :TODO: nuke PIC? */
54175:     if (!cx->traceJitEnabled)
53133:         return NULL;
53133: 
55483:     /*
55483:      * Force initialization of the entry frame's scope chain and return value,
55483:      * if necessary.  The tracer can query the scope chain without needing to
55483:      * check the HAS_SCOPECHAIN flag, and the frame is guaranteed to have the
55483:      * correct return value stored if we trace/interpret through to the end
55483:      * of the frame.
55483:      */
55483:     entryFrame->scopeChain();
55483:     entryFrame->returnValue();
55483: 
53133:     bool blacklist;
53422:     uintN inlineCallCount = 0;
56551:     void **traceData;
56551:     uintN *traceEpoch;
60534:     uint32 *loopCounter;
60534:     uint32 hits;
56551: #if JS_MONOIC
60567:     traceData = &ic.traceData;
60567:     traceEpoch = &ic.traceEpoch;
60567:     loopCounter = &ic.loopCounter;
60534:     *loopCounter = 1;
60567:     hits = ic.loopCounterStart;
56551: #else
56551:     traceData = NULL;
56551:     traceEpoch = NULL;
60534:     loopCounter = NULL;
60534:     hits = 1;
56551: #endif
75933: 
75933:     {
75933:         /*
75933:          * While the tracer is running, redirect the regs to a local variable here.
75933:          * If the tracer exits during an inlined frame, it will synthesize those
75933:          * frames, point f.regs.fp at them and then enter the interpreter. If the
75933:          * interpreter pops the frames it will not be reflected here as a local
75933:          * set of regs is used by the interpreter, and f->regs end up pointing at
75933:          * garbage, confusing the recompiler.
75933:          */
76001:         FrameRegs regs = f.regs;
75933:         PreserveRegsGuard regsGuard(cx, regs);
75933: 
60534:         tpa = MonitorTracePoint(f.cx, inlineCallCount, &blacklist, traceData, traceEpoch,
60534:                                 loopCounter, hits);
53133:         JS_ASSERT(!TRACE_RECORDER(cx));
75933:     }
53133: 
53133: #if JS_MONOIC
60567:     ic.loopCounterStart = *loopCounter;
53133:     if (blacklist)
61056:         DisableTraceHint(entryFrame->jit(), ic);
53133: #endif
53133: 
56201:     // Even though ExecuteTree() bypasses the interpreter, it should propagate
56201:     // error failures correctly.
60211:     JS_ASSERT_IF(cx->isExceptionPending(), tpa == TPA_Error);
53133: 
56201:     JS_ASSERT(f.fp() == cx->fp());
53133:     switch (tpa) {
53133:       case TPA_Nothing:
53133:         return NULL;
53133: 
53133:       case TPA_Error:
56201:         if (!HandleErrorInExcessFrame(f, entryFrame, f.fp()->finishedInInterpreter()))
53133:             THROWV(NULL);
53840:         JS_ASSERT(!cx->fp()->hasImacropc());
53133:         break;
53133: 
53133:       case TPA_RanStuff:
53133:       case TPA_Recorded:
53133:         break;
53133:     }
53133: 
53133:     /*
53133:      * The tracer could have dropped us off on any frame at any position.
53133:      * Well, it could not have removed frames (recursion is disabled).
53133:      *
53471:      * Frames after the entryFrame cannot be entered via JaegerShotAtSafePoint()
53471:      * unless each is at a safe point. We can JaegerShotAtSafePoint these
53471:      * frames individually, but we must unwind to the entryFrame.
53471:      *
53471:      * Note carefully that JaegerShotAtSafePoint can resume methods at
53471:      * arbitrary safe points whereas JaegerShot cannot.
53133:      *
53133:      * If we land on entryFrame without a safe point in sight, we'll end up
53133:      * at the RETURN op. This is an edge case with two paths:
53133:      *
53133:      * 1) The entryFrame is the last inline frame. If it fell on a RETURN,
53133:      *    move the return value down.
53133:      * 2) The entryFrame is NOT the last inline frame. Pop the frame.
53133:      *
64365:      * In both cases, we hijack the stub to return to the force-return
64365:      * trampoline. This trampoline simulates the frame-popping portion of
64365:      * emitReturn (except without the benefit of the FrameState) and will
64365:      * produce the necessary register state to return to the caller.
53133:      */
53133: 
53133:   restart:
54736:     /* Step 1. Finish frames created after the entry frame. */
54736:     if (!FinishExcessFrames(f, entryFrame))
53133:         THROWV(NULL);
53133: 
53626:     /* IMacros are guaranteed to have been removed by now. */
56201:     JS_ASSERT(f.fp() == entryFrame);
53840:     JS_ASSERT(!entryFrame->hasImacropc());
53133: 
56201:     /* Step 2. If entryFrame is done, use a special path to return to EnterMethodJIT(). */
56201:     if (FrameIsFinished(cx)) {
56201:         if (!HandleFinishedFrame(f, entryFrame))
53133:             THROWV(NULL);
67899:         *f.returnAddressLocation() = cx->jaegerCompartment()->forceReturnFromFastCall();
53133:         return NULL;
53133:     }
53133: 
56201:     /* Step 3. If entryFrame is at a safe point, just leave. */
56201:     if (void *ncode = AtSafePoint(cx))
56201:         return ncode;
56201: 
53626:     /* Step 4. Do a partial interp, then restart the whole process. */
53428:     if (!PartialInterpret(f)) {
56201:         if (!HandleErrorInExcessFrame(f, entryFrame))
53133:             THROWV(NULL);
53133:     }
53133: 
53133:     goto restart;
53133: }
53133: 
53133: #endif /* JS_TRACER */
53133: 
53136: #if defined JS_TRACER
53136: # if defined JS_MONOIC
53133: void *JS_FASTCALL
60567: stubs::InvokeTracer(VMFrame &f, ic::TraceICInfo *ic)
53133: {
60567:     return RunTracer(f, *ic);
53133: }
53133: 
53133: # else
53133: 
53133: void *JS_FASTCALL
53133: stubs::InvokeTracer(VMFrame &f)
53133: {
53133:     return RunTracer(f);
53133: }
53136: # endif /* JS_MONOIC */
53136: #endif /* JS_TRACER */
53133: 
76020: /* :XXX: common out with identical copy in Compiler.cpp */
76020: #if defined(JS_METHODJIT_SPEW)
76020: static const char *OpcodeNames[] = {
76020: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) #name,
76020: # include "jsopcode.tbl"
76020: # undef OPDEF
76020: };
76020: #endif
76020: 
76020: static void
76020: FinishVarIncOp(VMFrame &f, RejoinState rejoin, Value ov, Value nv, Value *vp)
76020: {
76020:     /* Finish an increment operation on a LOCAL or ARG. These do not involve property accesses. */
76020:     JS_ASSERT(rejoin == REJOIN_POS || rejoin == REJOIN_BINARY);
76020: 
76020:     JSContext *cx = f.cx;
76020: 
76122:     JSOp op = js_GetOpcode(cx, f.script(), f.pc());
76020:     const JSCodeSpec *cs = &js_CodeSpec[op];
76020: 
76020:     unsigned i = GET_SLOTNO(f.pc());
76020:     Value *var = (JOF_TYPE(cs->format) == JOF_LOCAL) ? f.fp()->slots() + i : &f.fp()->formalArg(i);
76020: 
76020:     if (rejoin == REJOIN_POS) {
76020:         double d = ov.toNumber();
76020:         double N = (cs->format & JOF_INC) ? 1 : -1;
76020:         if (!nv.setNumber(d + N))
76020:             f.script()->typeMonitorOverflow(cx, f.pc());
76020:     }
76020: 
76020:     *var = nv;
76020:     *vp = (cs->format & JOF_POST) ? ov : nv;
76020: }
76020: 
76020: static bool
76020: FinishObjIncOp(VMFrame &f, RejoinState rejoin, Value objv, Value ov, Value nv, Value *vp)
76020: {
76020:     /*
76020:      * Finish a property access increment operation on a GNAME, NAME or PROP. We don't need
76020:      * to handle ELEM as these are always stubbed.
76020:      */
76020:     JS_ASSERT(rejoin == REJOIN_BINDNAME || rejoin == REJOIN_GETTER ||
76020:               rejoin == REJOIN_POS || rejoin == REJOIN_BINARY);
76020: 
76020:     JSContext *cx = f.cx;
76020: 
76020:     JSObject *obj = ValueToObject(cx, &objv);
76020:     if (!obj)
76020:         return false;
76020: 
76122:     JSOp op = js_GetOpcode(cx, f.script(), f.pc());
76020:     const JSCodeSpec *cs = &js_CodeSpec[op];
76020:     JS_ASSERT(JOF_TYPE(cs->format) == JOF_ATOM);
76020: 
76020:     jsid id = ATOM_TO_JSID(f.script()->getAtom(GET_SLOTNO(f.pc())));
76020: 
76020:     if (rejoin == REJOIN_BINDNAME && !obj->getProperty(cx, id, &ov))
76020:         return false;
76020: 
76020:     if (rejoin == REJOIN_BINDNAME || rejoin == REJOIN_GETTER) {
76020:         double d;
76020:         if (!ValueToNumber(cx, ov, &d))
76020:             return false;
76020:         ov.setNumber(d);
76020:     }
76020: 
76020:     if (rejoin == REJOIN_BINDNAME || rejoin == REJOIN_GETTER || rejoin == REJOIN_POS) {
76020:         double d = ov.toNumber();
76020:         double N = (cs->format & JOF_INC) ? 1 : -1;
76020:         if (!nv.setNumber(d + N))
76020:             f.script()->typeMonitorOverflow(cx, f.pc());
76020:     }
76020: 
76020:     uint32 setPropFlags = (cs->format & JOF_NAME)
76020:                           ? JSRESOLVE_ASSIGNING
76020:                           : JSRESOLVE_ASSIGNING | JSRESOLVE_QUALIFIED;
76020: 
76020:     {
76020:         JSAutoResolveFlags rf(cx, setPropFlags);
76020:         if (!obj->setProperty(cx, id, &nv, f.script()->strictModeCode))
76020:             return false;
76020:     }
76020: 
76020:     *vp = (cs->format & JOF_POST) ? ov : nv;
76020:     return true;
76020: }
76020: 
76020: extern "C" void *
76020: js_InternalInterpret(void *returnData, void *returnType, void *returnReg, js::VMFrame &f)
76020: {
76020:     JSRejoinState jsrejoin = f.fp()->rejoin();
76020:     RejoinState rejoin;
76020:     if (jsrejoin & 0x1) {
76020:         /* Rejoin after a scripted call finished. Restore f.regs.pc and f.regs.inlined (NULL) */
76020:         uint32 pcOffset = jsrejoin >> 1;
76020:         f.regs.pc = f.fp()->script()->code + pcOffset;
76020:         f.regs.clearInlined();
76020:         rejoin = REJOIN_SCRIPTED;
76020:     } else {
76020:         rejoin = (RejoinState) (jsrejoin >> 1);
76020:     }
76020: 
76020:     JSContext *cx = f.cx;
76020:     StackFrame *fp = f.regs.fp();
76020:     JSScript *script = fp->script();
76020: 
76020:     jsbytecode *pc = f.regs.pc;
76020:     analyze::UntrapOpcode untrap(cx, script, pc);
76020: 
76020:     JSOp op = JSOp(*pc);
76020:     const JSCodeSpec *cs = &js_CodeSpec[op];
76020: 
76020:     analyze::AutoEnterAnalysis enter(cx);
76020: 
76020:     analyze::ScriptAnalysis *analysis = script->analysis(cx);
76020:     if (analysis && !analysis->ranBytecode())
76020:         analysis->analyzeBytecode(cx);
76020:     if (!analysis || analysis->OOM()) {
76020:         js_ReportOutOfMemory(cx);
76020:         return js_InternalThrow(f);
76020:     }
76020: 
76020:     /*
76020:      * f.regs.sp is not normally maintained by stubs (except for call prologues
76020:      * where it indicates the new frame), so is not expected to be coherent
76020:      * here. Update it to its value at the start of the opcode.
76020:      */
76020:     Value *oldsp = f.regs.sp;
76020:     f.regs.sp = fp->base() + analysis->getCode(pc).stackDepth;
76020: 
76020:     jsbytecode *nextpc = pc + analyze::GetBytecodeLength(pc);
76020:     Value *nextsp = NULL;
76020:     if (nextpc != script->code + script->length)
76020:         nextsp = fp->base() + analysis->getCode(nextpc).stackDepth;
76020: 
76020:     JS_ASSERT(&cx->regs() == &f.regs);
76020: 
76020: #ifdef JS_METHODJIT_SPEW
76020:     JaegerSpew(JSpew_Recompile, "interpreter rejoin (file \"%s\") (line \"%d\") (op %s)\n",
76020:                script->filename, script->lineno, OpcodeNames[op]);
76020: #endif
76020: 
76087:     uint32 nextDepth = uint32(-1);
76087: 
76081:     InterpMode interpMode = JSINTERP_REJOIN;
76020: 
76096:     if ((cs->format & (JOF_INC | JOF_DEC)) &&
76142:         rejoin != REJOIN_FALLTHROUGH &&
76142:         rejoin != REJOIN_RESUME &&
76142:         rejoin != REJOIN_THIS_PROTOTYPE &&
76142:         rejoin != REJOIN_CHECK_ARGUMENTS) {
76096:         /* We may reenter the interpreter while finishing the INC/DEC operation. */
76096:         nextDepth = analysis->getCode(nextpc).stackDepth;
76096:         untrap.retrap();
76096:         enter.leave();
76096: 
76020:         switch (op) {
76020:           case JSOP_INCLOCAL:
76020:           case JSOP_DECLOCAL:
76020:           case JSOP_LOCALINC:
76020:           case JSOP_LOCALDEC:
76020:           case JSOP_INCARG:
76020:           case JSOP_DECARG:
76020:           case JSOP_ARGINC:
76020:           case JSOP_ARGDEC:
76020:             if (rejoin != REJOIN_BINARY || !analysis->incrementInitialValueObserved(pc)) {
76020:                 /* Stack layout is 'V', 'N' or 'N+1' (only if the N is not needed) */
76020:                 FinishVarIncOp(f, rejoin, nextsp[-1], nextsp[-1], &nextsp[-1]);
76020:             } else {
76020:                 /* Stack layout is 'N N+1' */
76020:                 FinishVarIncOp(f, rejoin, nextsp[-1], nextsp[0], &nextsp[-1]);
76020:             }
76020:             break;
76020: 
76020:           case JSOP_INCGNAME:
76020:           case JSOP_DECGNAME:
76020:           case JSOP_GNAMEINC:
76020:           case JSOP_GNAMEDEC:
76020:           case JSOP_INCNAME:
76020:           case JSOP_DECNAME:
76020:           case JSOP_NAMEINC:
76020:           case JSOP_NAMEDEC:
76020:           case JSOP_INCPROP:
76020:           case JSOP_DECPROP:
76020:           case JSOP_PROPINC:
76020:           case JSOP_PROPDEC:
76020:             if (rejoin != REJOIN_BINARY || !analysis->incrementInitialValueObserved(pc)) {
76020:                 /* Stack layout is 'OBJ V', 'OBJ N' or 'OBJ N+1' (only if the N is not needed) */
76020:                 if (!FinishObjIncOp(f, rejoin, nextsp[-1], nextsp[0], nextsp[0], &nextsp[-1]))
76020:                     return js_InternalThrow(f);
76020:             } else {
76020:                 /* Stack layout is 'N OBJ N+1' */
76020:                 if (!FinishObjIncOp(f, rejoin, nextsp[0], nextsp[-1], nextsp[1], &nextsp[-1]))
76020:                     return js_InternalThrow(f);
76020:             }
76020:             break;
76020: 
76020:           default:
76020:             JS_NOT_REACHED("Bad op");
76020:         }
76020:         rejoin = REJOIN_FALLTHROUGH;
76020:     }
76020: 
76020:     switch (rejoin) {
76020:       case REJOIN_SCRIPTED: {
76020: #ifdef JS_NUNBOX32
76051:         uint64 rvalBits = ((uint64)returnType << 32) | (uint32)returnData;
76020: #elif JS_PUNBOX64
76051:         uint64 rvalBits = (uint64)returnType | (uint64)returnData;
76020: #else
76020: #error "Unknown boxing format"
76020: #endif
76020:         nextsp[-1].setRawBits(rvalBits);
76020:         f.regs.pc = nextpc;
76020:         break;
76020:       }
76020: 
76020:       case REJOIN_NONE:
76020:         JS_NOT_REACHED("Unpossible rejoin!");
76020:         break;
76020: 
76020:       case REJOIN_RESUME:
76020:         break;
76020: 
76020:       case REJOIN_TRAP:
76020:         /* Watch out for the case where the TRAP removed itself. */
76081:         interpMode = untrap.trap ? JSINTERP_SKIP_TRAP : JSINTERP_REJOIN;
76020:         break;
76020: 
76020:       case REJOIN_FALLTHROUGH:
76020:         f.regs.pc = nextpc;
76020:         break;
76020: 
76020:       case REJOIN_NATIVE:
76020:       case REJOIN_NATIVE_LOWERED: {
76020:         /*
76020:          * We don't rejoin until after the native stub finishes execution, in
76020:          * which case it will have already loaded the return value into the
76020:          * return register pair, as for a scripted call. We need to release the
76020:          * reference on the compartment's orphaned native pools first, though.
76020:          */
76067:         RemoveOrphanedNative(cx, fp);
76020:         if (rejoin == REJOIN_NATIVE_LOWERED) {
76020:             /*
76020:              * Lowered natives return like other native calls, but store their
76020:              * return values in the 'this' value's slot.
76020:              */
76020:             nextsp[-1] = nextsp[0];
76020:         }
76020:         f.regs.pc = nextpc;
76020:         break;
76020:       }
76020: 
76020:       case REJOIN_PUSH_BOOLEAN:
76020:         nextsp[-1].setBoolean(returnReg != NULL);
76020:         f.regs.pc = nextpc;
76020:         break;
76020: 
76020:       case REJOIN_PUSH_OBJECT:
76020:         nextsp[-1].setObject(* (JSObject *) returnReg);
76020:         f.regs.pc = nextpc;
76020:         break;
76020: 
76020:       case REJOIN_DEFLOCALFUN:
76020:         fp->slots()[GET_SLOTNO(pc)].setObject(* (JSObject *) returnReg);
76020:         f.regs.pc = nextpc;
76020:         break;
76020: 
76020:       case REJOIN_THIS_PROTOTYPE: {
76020:         JSObject *callee = &fp->callee();
76020:         JSObject *proto = f.regs.sp[0].isObject() ? &f.regs.sp[0].toObject() : NULL;
76020:         JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
76020:         if (!obj)
76020:             return js_InternalThrow(f);
76020:         fp->formalArgs()[-1].setObject(*obj);
76020: 
76020:         if (script->debugMode || Probes::callTrackingActive(cx))
76020:             js::ScriptDebugPrologue(cx, fp);
76020:         break;
76020:       }
76020: 
76020:       case REJOIN_CHECK_ARGUMENTS: {
76020:         /*
76020:          * Do all the work needed in arity check JIT prologues after the
76020:          * arguments check occurs (FixupArity has been called if needed, but
76020:          * the stack check and late prologue have not been performed.
76020:          */
76020:         if (!CheckStackQuota(f))
76020:             return js_InternalThrow(f);
76020:         if (fp->fun()->isHeavyweight()) {
76020:             if (!js::CreateFunCallObject(cx, fp))
76020:                 return js_InternalThrow(f);
76020:         }
76020:         fp->initCallFrameLatePrologue();
76020: 
76020:         /*
76020:          * Use the normal interpreter mode, which will construct the 'this'
76020:          * object if this is a constructor frame.
76020:          */
76020:         interpMode = JSINTERP_NORMAL;
76020:         break;
76020:       }
76020: 
76020:       case REJOIN_CALL_PROLOGUE:
76020:       case REJOIN_CALL_PROLOGUE_LOWERED_CALL:
76020:       case REJOIN_CALL_PROLOGUE_LOWERED_APPLY:
76020:         if (returnReg) {
76020:             uint32 argc = 0;
76020:             if (rejoin == REJOIN_CALL_PROLOGUE)
76020:                 argc = GET_ARGC(pc);
76020:             else if (rejoin == REJOIN_CALL_PROLOGUE_LOWERED_CALL)
76020:                 argc = GET_ARGC(pc) - 1;
76020:             else
76020:                 argc = f.u.call.dynamicArgc;
76020: 
76020:             /*
76020:              * The caller frame's code was discarded, but we still need to
76020:              * execute the callee and have a JIT code pointer to do so.
76020:              * Set the argc and frame registers as the call path does, but set
76020:              * the callee frame's return address to jump back into the
76020:              * Interpoline, and change the caller frame's rejoin to reflect the
76020:              * state after the call.
76020:              */
76020:             f.regs.restorePartialFrame(oldsp); /* f.regs.sp stored the new frame */
76020:             f.scratch = (void *) argc;         /* The interpoline will load f.scratch into argc */
76020:             f.fp()->setNativeReturnAddress(JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted));
76020:             fp->setRejoin(REJOIN_SCRIPTED | ((pc - script->code) << 1));
76020:             return returnReg;
76020:         } else {
76020:             /*
76020:              * The call has already finished, and the return value is on the
76020:              * stack. For lowered call/apply, the return value has been stored
76020:              * in the wrong slot, so adjust it here.
76020:              */
76020:             f.regs.pc = nextpc;
76020:             if (rejoin != REJOIN_CALL_PROLOGUE) {
76020:                 /* Same offset return value as for lowered native calls. */
76020:                 nextsp[-1] = nextsp[0];
76020:             }
76020:         }
76020:         break;
76020: 
76020:       case REJOIN_CALL_SPLAT: {
76087:         /* Leave analysis early and do the Invoke which SplatApplyArgs prepared. */
76087:         nextDepth = analysis->getCode(nextpc).stackDepth;
76087:         untrap.retrap();
76087:         enter.leave();
76020:         f.regs.sp = nextsp + 2 + f.u.call.dynamicArgc;
76020:         if (!Invoke(cx, InvokeArgsAlreadyOnTheStack(f.u.call.dynamicArgc, nextsp)))
76020:             return js_InternalThrow(f);
76020:         nextsp[-1] = nextsp[0];
76020:         f.regs.pc = nextpc;
76020:         break;
76020:       }
76020: 
76020:       case REJOIN_GETTER:
76020:         /*
76020:          * Match the PC to figure out whether this property fetch is part of a
76020:          * fused opcode which needs to be finished.
76020:          */
76020:         switch (op) {
76020:           case JSOP_NAME:
76020:           case JSOP_GETGNAME:
76020:           case JSOP_GETGLOBAL:
76020:           case JSOP_GETPROP:
76061:           case JSOP_GETXPROP:
76020:           case JSOP_LENGTH:
76020:             /* Non-fused opcode, state is already correct for the next op. */
76020:             f.regs.pc = nextpc;
76020:             break;
76020: 
76020:           case JSOP_CALLGNAME:
76020:             if (!ComputeImplicitThis(cx, &fp->scopeChain(), nextsp[-2], &nextsp[-1]))
76020:                 return js_InternalThrow(f);
76020:             f.regs.pc = nextpc;
76020:             break;
76020: 
76032:           case JSOP_CALLGLOBAL:
76032:             /* |this| is always undefined for CALLGLOBAL. */
76032:             nextsp[-1].setUndefined();
76032:             f.regs.pc = nextpc;
76032:             break;
76032: 
76020:           case JSOP_CALLPROP: {
76020:             /*
76020:              * CALLPROP is compiled in terms of GETPROP for known strings.
76020:              * In such cases the top two entries are in place, but are swapped.
76020:              */
76020:             JS_ASSERT(nextsp[-2].isString());
76020:             Value tmp = nextsp[-2];
76020:             nextsp[-2] = nextsp[-1];
76020:             nextsp[-1] = tmp;
76020:             f.regs.pc = nextpc;
76020:             break;
76020:           }
76020: 
76020:           case JSOP_INSTANCEOF: {
76020:             /*
76020:              * If we recompiled from a getprop used within JSOP_INSTANCEOF,
76020:              * the stack looks like 'LHS RHS protov'. Inline the remaining
76020:              * portion of fun_hasInstance.
76020:              */
76020:             if (f.regs.sp[0].isPrimitive()) {
76020:                 js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE, -1, f.regs.sp[-1], NULL);
76020:                 return js_InternalThrow(f);
76020:             }
76020:             nextsp[-1].setBoolean(js_IsDelegate(cx, &f.regs.sp[0].toObject(), f.regs.sp[-2]));
76020:             f.regs.pc = nextpc;
76020:             break;
76020:           }
76020: 
76020:           default:
76020:             JS_NOT_REACHED("Bad rejoin getter op");
76020:         }
76020:         break;
76020: 
76020:       case REJOIN_POS:
76020:         /* Convert-to-number which might be part of an INC* op. */
76020:         JS_ASSERT(op == JSOP_POS);
76020:         f.regs.pc = nextpc;
76020:         break;
76020: 
76020:       case REJOIN_BINARY:
76020:         /* Binary arithmetic op which might be part of an INC* op. */
76020:         JS_ASSERT(op == JSOP_ADD || op == JSOP_SUB || op == JSOP_MUL || op == JSOP_DIV);
76020:         f.regs.pc = nextpc;
76020:         break;
76020: 
76020:       case REJOIN_BRANCH: {
76020:         /*
76020:          * This must be an opcode fused with IFNE/IFEQ. Unfused IFNE/IFEQ are
76020:          * implemented in terms of ValueToBoolean, which is infallible and
76020:          * cannot trigger recompilation.
76020:          */
76020:         bool takeBranch = false;
76122:         analyze::UntrapOpcode untrap(cx, script, nextpc);
76020:         switch (JSOp(*nextpc)) {
76020:           case JSOP_IFNE:
76020:           case JSOP_IFNEX:
76020:             takeBranch = returnReg != NULL;
76020:             break;
76020:           case JSOP_IFEQ:
76020:           case JSOP_IFEQX:
76020:             takeBranch = returnReg == NULL;
76020:             break;
76020:           default:
76020:             JS_NOT_REACHED("Bad branch op");
76020:         }
76020:         if (takeBranch)
76020:             f.regs.pc = nextpc + GET_JUMP_OFFSET(nextpc);
76020:         else
76020:             f.regs.pc = nextpc + analyze::GetBytecodeLength(nextpc);
76020:         break;
76020:       }
76020: 
76020:       default:
76020:         JS_NOT_REACHED("Missing rejoin");
76020:     }
76020: 
76087:     if (nextDepth == uint32(-1))
76087:         nextDepth = analysis->getCode(f.regs.pc).stackDepth;
76087:     f.regs.sp = fp->base() + nextDepth;
76020: 
76020:     /* Reinsert any trap before resuming in the interpreter. */
76020:     untrap.retrap();
76020: 
76087:     /* Release lock on analysis data before resuming. */
76087:     enter.leave();
76087: 
76020:     if (!Interpret(cx, NULL, 0, interpMode))
76020:         return js_InternalThrow(f);
76020: 
76081:     /* The interpreter should have finished its entry frame. */
76081:     JS_ASSERT(f.regs.fp() == fp);
76081: 
76020:     /* Force construction of the frame's return value, if it was not set. */
76020:     fp->returnValue();
76020: 
76020:     /*
76020:      * The frame is done, but if it finished in the interpreter the call/args
76020:      * objects need to be detached from the frame.
76020:      */
76020:     fp->putActivationObjects();
76020: 
76020:     return fp->nativeReturnAddress();
76020: }
