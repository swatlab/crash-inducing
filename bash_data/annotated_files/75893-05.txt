52560: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52560:  * vim: set ts=4 sw=4 et tw=99:
52560:  *
52560:  * ***** BEGIN LICENSE BLOCK *****
52560:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52560:  *
52560:  * The contents of this file are subject to the Mozilla Public License Version
52560:  * 1.1 (the "License"); you may not use this file except in compliance with
52560:  * the License. You may obtain a copy of the License at
52560:  * http://www.mozilla.org/MPL/
52560:  *
52560:  * Software distributed under the License is distributed on an "AS IS" basis,
52560:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52560:  * for the specific language governing rights and limitations under the
52560:  * License.
52560:  *
52560:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52560:  * May 28, 2008.
52560:  *
52560:  * The Initial Developer of the Original Code is
52560:  *   Brendan Eich <brendan@mozilla.org>
52560:  *
52560:  * Contributor(s):
52560:  *   David Anderson <danderson@mozilla.com>
52560:  *   David Mandelin <dmandelin@mozilla.com>
52560:  *
52560:  * Alternatively, the contents of this file may be used under the terms of
52560:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52560:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52560:  * in which case the provisions of the GPL or the LGPL are applicable instead
52560:  * of those above. If you wish to allow use of your version of this file only
52560:  * under the terms of either the GPL or the LGPL, and not to allow others to
52560:  * use your version of this file under the terms of the MPL, indicate your
52560:  * decision by deleting the provisions above and replace them with the notice
52560:  * and other provisions required by the GPL or the LGPL. If you do not delete
52560:  * the provisions above, a recipient may use your version of this file under
52560:  * the terms of any one of the MPL, the GPL or the LGPL.
52560:  *
52560:  * ***** END LICENSE BLOCK ***** */
52734: #include "jsbool.h"
58056: #include "jscntxt.h"
58056: #include "jsemit.h"
52842: #include "jslibmath.h"
52808: #include "jsnum.h"
53228: #include "jsscope.h"
53531: #include "jsobjinlines.h"
59968: #include "jsscriptinlines.h"
59968: 
52606: #include "methodjit/MethodJIT.h"
52606: #include "methodjit/Compiler.h"
52608: #include "methodjit/StubCalls.h"
52618: #include "methodjit/FrameState-inl.h"
52560: 
52560: #include "jsautooplen.h"
52560: 
52560: using namespace js;
52608: using namespace js::mjit;
52560: 
53230: typedef JSC::MacroAssembler::RegisterID RegisterID;
53230: 
53230: void
75630: mjit::Compiler::ensureInteger(FrameEntry *fe, Uses uses)
53230: {
75630:     if (fe->isConstant()) {
75630:         if (!fe->isType(JSVAL_TYPE_INT32)) {
75630:             JS_ASSERT(fe->isType(JSVAL_TYPE_DOUBLE));
75630:             fe->convertConstantDoubleToInt32(cx);
75630:         }
75630:     } else if (fe->isType(JSVAL_TYPE_DOUBLE)) {
75630:         FPRegisterID fpreg = frame.tempFPRegForData(fe);
75826:         FPRegisterID fptemp = frame.allocFPReg();
75630:         RegisterID data = frame.allocReg();
75630:         Jump truncateGuard = masm.branchTruncateDoubleToInt32(fpreg, data);
53230: 
75826:         Label syncPath = stubcc.syncExitAndJump(uses);
75826:         stubcc.linkExitDirect(truncateGuard, stubcc.masm.label());
53230: 
75826:         /*
75826:          * Try an OOL path to convert doubles representing integers within 2^32
75826:          * of a signed integer, by adding/subtracting 2^32 and then trying to
75826:          * convert to int32. This has to be an exact conversion, as otherwise
75826:          * the truncation works incorrectly on the modified value.
75826:          */
53230: 
75826:         stubcc.masm.zeroDouble(fptemp);
75826:         Jump positive = stubcc.masm.branchDouble(Assembler::DoubleGreaterThan, fpreg, fptemp);
75826:         stubcc.masm.slowLoadConstantDouble(double(4294967296.0), fptemp);
75826:         Jump skip = stubcc.masm.jump();
75826:         positive.linkTo(stubcc.masm.label(), &stubcc.masm);
75826:         stubcc.masm.slowLoadConstantDouble(double(-4294967296.0), fptemp);
75826:         skip.linkTo(stubcc.masm.label(), &stubcc.masm);
75826: 
75826:         JumpList isDouble;
75826:         stubcc.masm.addDouble(fpreg, fptemp);
75826:         stubcc.masm.branchConvertDoubleToInt32(fptemp, data, isDouble, Registers::FPConversionTemp);
53230:         stubcc.crossJump(stubcc.masm.jump(), masm.label());
75826:         isDouble.linkTo(syncPath, &stubcc.masm);
53230: 
75826:         frame.freeReg(fptemp);
75630:         frame.learnType(fe, JSVAL_TYPE_INT32, data);
75630:     } else if (!fe->isType(JSVAL_TYPE_INT32)) {
75630:         RegisterID typeReg = frame.tempRegForType(fe);
75630:         frame.pinReg(typeReg);
75748:         RegisterID dataReg = frame.copyDataIntoReg(fe);
75630:         frame.unpinReg(typeReg);
53230: 
75630:         Jump intGuard = masm.testInt32(Assembler::Equal, typeReg);
75630:         Jump doubleGuard = masm.testDouble(Assembler::NotEqual, typeReg);
75630:         stubcc.linkExit(doubleGuard, uses);
53230: 
75630:         FPRegisterID fpreg = frame.allocFPReg();
75630:         frame.loadDouble(fe, fpreg, masm);
75748:         Jump truncateGuard = masm.branchTruncateDoubleToInt32(fpreg, dataReg);
75630:         stubcc.linkExit(truncateGuard, uses);
75630:         intGuard.linkTo(masm.label(), &masm);
53230: 
75647:         frame.freeReg(fpreg);
75748:         frame.learnType(fe, JSVAL_TYPE_INT32, dataReg);
53230:     }
53230: }
53230: 
53230: void
52724: mjit::Compiler::jsop_bitnot()
52724: {
52724:     FrameEntry *top = frame.peek(-1);
52724: 
52724:     /* We only want to handle integers here. */
53025:     if (top->isTypeKnown() && top->getKnownType() != JSVAL_TYPE_INT32) {
53087:         prepareStubCall(Uses(1));
57766:         INLINE_STUBCALL(stubs::BitNot);
52724:         frame.pop();
75630:         frame.pushSynced(JSVAL_TYPE_INT32);
52724:         return;
52724:     }
52724:            
52724:     /* Test the type. */
52724:     bool stubNeeded = false;
52724:     if (!top->isTypeKnown()) {
52824:         Jump intFail = frame.testInt32(Assembler::NotEqual, top);
53088:         stubcc.linkExit(intFail, Uses(1));
53025:         frame.learnType(top, JSVAL_TYPE_INT32);
52724:         stubNeeded = true;
52724:     }
52724: 
52724:     if (stubNeeded) {
52724:         stubcc.leave();
57766:         OOL_STUBCALL(stubs::BitNot);
52724:     }
52724: 
52724:     RegisterID reg = frame.ownRegForData(top);
52724:     masm.not32(reg);
52724:     frame.pop();
53025:     frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52724: 
52724:     if (stubNeeded)
53088:         stubcc.rejoin(Changes(1));
52724: }
52724: 
52724: void
52617: mjit::Compiler::jsop_bitop(JSOp op)
52617: {
52617:     FrameEntry *rhs = frame.peek(-1);
52617:     FrameEntry *lhs = frame.peek(-2);
52617: 
52685:     VoidStub stub;
52685:     switch (op) {
52721:       case JSOP_BITOR:
52721:         stub = stubs::BitOr;
52721:         break;
52685:       case JSOP_BITAND:
52685:         stub = stubs::BitAnd;
52685:         break;
52718:       case JSOP_BITXOR:
52718:         stub = stubs::BitXor;
52718:         break;
52685:       case JSOP_LSH:
52685:         stub = stubs::Lsh;
52685:         break;
75862:       case JSOP_RSH:
75862:         stub = stubs::Rsh;
75862:         break;
53581:       case JSOP_URSH:
53581:         stub = stubs::Ursh;
53581:         break;
52685:       default:
52685:         JS_NOT_REACHED("wat");
52722:         return;
52685:     }
52685: 
53613:     bool lhsIntOrDouble = !(lhs->isNotType(JSVAL_TYPE_DOUBLE) && 
53613:                             lhs->isNotType(JSVAL_TYPE_INT32));
53613:     
53613:     /* Fast-path double to int conversion. */
53613:     if (!lhs->isConstant() && rhs->isConstant() && lhsIntOrDouble &&
53613:         rhs->isType(JSVAL_TYPE_INT32) && rhs->getValue().toInt32() == 0 &&
53613:         (op == JSOP_BITOR || op == JSOP_LSH)) {
75630:         ensureInteger(lhs, Uses(2));
53613:         RegisterID reg = frame.copyDataIntoReg(lhs);
53613: 
53613:         stubcc.leave();
57766:         OOL_STUBCALL(stub);
53613: 
53613:         frame.popn(2);
53613:         frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
75630: 
53613:         stubcc.rejoin(Changes(1));
53613:         return;
53613:     }
53613: 
75656:     /* Convert a double RHS to integer if it's constant for the test below. */
75656:     if (rhs->isConstant() && rhs->getValue().isDouble())
75656:         rhs->convertConstantDoubleToInt32(cx);
75656: 
52617:     /* We only want to handle integers here. */
75630:     if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_DOUBLE)) ||
75630:         (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_DOUBLE)) ||
53581:         (op == JSOP_URSH && rhs->isConstant() && rhs->getValue().toInt32() % 32 == 0)) {
53087:         prepareStubCall(Uses(2));
57766:         INLINE_STUBCALL(stub);
52617:         frame.popn(2);
75630:         frame.pushSynced(op != JSOP_URSH ? JSVAL_TYPE_INT32 : knownPushedType(0));
52617:         return;
52617:     }
52617: 
75630:     ensureInteger(lhs, Uses(2));
75630:     ensureInteger(rhs, Uses(2));
52617: 
52620:     if (lhs->isConstant() && rhs->isConstant()) {
53081:         int32 L = lhs->getValue().toInt32();
53081:         int32 R = rhs->getValue().toInt32();
52620: 
52620:         frame.popn(2);
52620:         switch (op) {
52721:           case JSOP_BITOR:
53081:             frame.push(Int32Value(L | R));
52840:             return;
52718:           case JSOP_BITXOR:
53081:             frame.push(Int32Value(L ^ R));
52840:             return;
52620:           case JSOP_BITAND:
53081:             frame.push(Int32Value(L & R));
52620:             return;
52685:           case JSOP_LSH:
75862:             frame.push(Int32Value(L << (R & 31)));
75862:             return;
75862:           case JSOP_RSH:
75862:             frame.push(Int32Value(L >> (R & 31)));
52685:             return;
53581:           case JSOP_URSH:
53581:           {
53581:             uint32 unsignedL;
53581:             if (ValueToECMAUint32(cx, lhs->getValue(), (uint32_t*)&unsignedL)) {
75668:                 Value v = NumberValue(uint32(unsignedL >> (R & 31)));
75668:                 JS_ASSERT(v.isInt32());
75668:                 frame.push(v);
53581:                 return;
53581:             }
53581:             break;
53581:           }
52620:           default:
52620:             JS_NOT_REACHED("say wat");
52620:         }
52617:     }
52617: 
52620:     RegisterID reg;
52620: 
52620:     switch (op) {
52721:       case JSOP_BITOR:
52718:       case JSOP_BITXOR:
52620:       case JSOP_BITAND:
52620:       {
52620:         /* Commutative, and we're guaranteed both are ints. */
52620:         if (lhs->isConstant()) {
52620:             JS_ASSERT(!rhs->isConstant());
52620:             FrameEntry *temp = rhs;
52620:             rhs = lhs;
52620:             lhs = temp;
52620:         }
52620: 
52620:         reg = frame.ownRegForData(lhs);
52620:         if (rhs->isConstant()) {
52718:             if (op == JSOP_BITAND)
53081:                 masm.and32(Imm32(rhs->getValue().toInt32()), reg);
52718:             else if (op == JSOP_BITXOR)
53081:                 masm.xor32(Imm32(rhs->getValue().toInt32()), reg);
52721:             else
53081:                 masm.or32(Imm32(rhs->getValue().toInt32()), reg);
52620:         } else if (frame.shouldAvoidDataRemat(rhs)) {
52718:             if (op == JSOP_BITAND)
52620:                 masm.and32(masm.payloadOf(frame.addressOf(rhs)), reg);
52718:             else if (op == JSOP_BITXOR)
52718:                 masm.xor32(masm.payloadOf(frame.addressOf(rhs)), reg);
52721:             else
52721:                 masm.or32(masm.payloadOf(frame.addressOf(rhs)), reg);
52620:         } else {
52620:             RegisterID rhsReg = frame.tempRegForData(rhs);
52718:             if (op == JSOP_BITAND)
52620:                 masm.and32(rhsReg, reg);
52718:             else if (op == JSOP_BITXOR)
52718:                 masm.xor32(rhsReg, reg);
52721:             else
52721:                 masm.or32(rhsReg, reg);
52620:         }
52620: 
52620:         break;
52620:       }
52620: 
52685:       case JSOP_LSH:
75862:       case JSOP_RSH:
53581:       case JSOP_URSH:
52685:       {
52685:         /* Not commutative. */
52685:         if (rhs->isConstant()) {
53230:             RegisterID reg = frame.ownRegForData(lhs);
53230:             int shift = rhs->getValue().toInt32() & 0x1F;
52783: 
75630:             stubcc.leave();
75631:             OOL_STUBCALL(stub);
75630: 
53581:             if (shift) {
53581:                 if (op == JSOP_LSH)
52685:                     masm.lshift32(Imm32(shift), reg);
75862:                 else if (op == JSOP_RSH)
75862:                     masm.rshift32(Imm32(shift), reg);
53581:                 else
53581:                     masm.urshift32(Imm32(shift), reg);
53581:             }
53581:             frame.popn(2);
53230:             
53581:             /* x >>> 0 may result in a double, handled above. */
53581:             JS_ASSERT_IF(op == JSOP_URSH, shift >= 1);
53230:             frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
53258: 
53258:             stubcc.rejoin(Changes(1));
53230:             return;
52685:         }
52685: #if defined(JS_CPU_X86) || defined(JS_CPU_X64)
52685:         /* Grosssssss! RHS _must_ be in ECX, on x86 */
53230:         RegisterID rr = frame.tempRegInMaskForData(rhs,
75864:                                                    Registers::maskReg(JSC::X86Registers::ecx)).reg();
52685: #else
52685:         RegisterID rr = frame.tempRegForData(rhs);
52685: #endif
52685: 
56538:         if (frame.haveSameBacking(lhs, rhs)) {
56538:             // It's okay to allocReg(). If |rr| is evicted, it won't result in
56538:             // a load, and |rr == reg| is fine since this is (x << x).
56538:             reg = frame.allocReg();
56538:             if (rr != reg)
56538:                 masm.move(rr, reg);
56538:         } else {
56538:             frame.pinReg(rr);
55486:             if (lhs->isConstant()) {
52685:                 reg = frame.allocReg();
53081:                 masm.move(Imm32(lhs->getValue().toInt32()), reg);
52685:             } else {
53581:                 reg = frame.copyDataIntoReg(lhs);
52685:             }
56538:             frame.unpinReg(rr);
56538:         }
52685:         
53581:         if (op == JSOP_LSH) {
52685:             masm.lshift32(rr, reg);
75862:         } else if (op == JSOP_RSH) {
75862:             masm.rshift32(rr, reg);
53581:         } else {
53581:             masm.urshift32(rr, reg);
53581:             
53581:             Jump isNegative = masm.branch32(Assembler::LessThan, reg, Imm32(0));
53581:             stubcc.linkExit(isNegative, Uses(2));
53581:         }
52685:         break;
52685:       }
52685: 
52620:       default:
52620:         JS_NOT_REACHED("NYI");
52620:         return;
52620:     }
52620: 
53581:     stubcc.leave();
57766:     OOL_STUBCALL(stub);
53581: 
52620:     frame.pop();
52620:     frame.pop();
53581: 
75622:     JSValueType type = knownPushedType(0);
75622: 
75630:     if (type != JSVAL_TYPE_UNKNOWN && type != JSVAL_TYPE_DOUBLE)
75622:         frame.pushTypedPayload(type, reg);
75622:     else if (op == JSOP_URSH)
53581:         frame.pushNumber(reg, true);
53581:     else
53025:         frame.pushTypedPayload(JSVAL_TYPE_INT32, reg);
52620: 
53088:     stubcc.rejoin(Changes(1));
52620: }
52620: 
52842: static inline bool
53025: CheckNullOrUndefined(FrameEntry *fe)
52879: {
52879:     if (!fe->isTypeKnown())
52879:         return false;
53025:     JSValueType type = fe->getKnownType();
53025:     return type == JSVAL_TYPE_NULL || type == JSVAL_TYPE_UNDEFINED;
52879: }
52879: 
56766: bool
52879: mjit::Compiler::jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
52879: {
52879:     FrameEntry *rhs = frame.peek(-1);
52879:     FrameEntry *lhs = frame.peek(-2);
52879: 
52879:     /* The compiler should have handled constant folding. */
52879:     JS_ASSERT(!(rhs->isConstant() && lhs->isConstant()));
52879: 
52879:     bool lhsTest;
53025:     if ((lhsTest = CheckNullOrUndefined(lhs)) || CheckNullOrUndefined(rhs)) {
52879:         /* What's the other mask? */
52879:         FrameEntry *test = lhsTest ? rhs : lhs;
52879: 
56766:         if (test->isTypeKnown())
56766:             return emitStubCmpOp(stub, target, fused);
52879: 
52879:         /* The other side must be null or undefined. */
52879:         RegisterID reg = frame.ownRegForType(test);
52954:         frame.pop();
52954:         frame.pop();
52879: 
52954:         /*
52954:          * :FIXME: Easier test for undefined || null?
52954:          * Maybe put them next to each other, subtract, do a single compare?
52954:          */
52879: 
52879:         if (target) {
54719:             frame.syncAndForgetEverything();
52879: 
52954:             if ((op == JSOP_EQ && fused == JSOP_IFNE) ||
52954:                 (op == JSOP_NE && fused == JSOP_IFEQ)) {
56217:                 /*
56217:                  * It would be easier to just have two jumpAndTrace calls here, but since
56217:                  * each jumpAndTrace creates a TRACE IC, and since we want the bytecode
56217:                  * to have a reference to the TRACE IC at the top of the loop, it's much
56217:                  * better to have only one TRACE IC per loop, and hence at most one
56217:                  * jumpAndTrace.
56217:                  */
56217:                 Jump b1 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
56217:                 Jump b2 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_NULL));
56217:                 Jump j1 = masm.jump();
56217:                 b1.linkTo(masm.label(), &masm);
56217:                 b2.linkTo(masm.label(), &masm);
56217:                 Jump j2 = masm.jump();
56766:                 if (!jumpAndTrace(j2, target))
56766:                     return false;
56217:                 j1.linkTo(masm.label(), &masm);
52879:             } else {
53162:                 Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53162:                 Jump j2 = masm.branchPtr(Assembler::NotEqual, reg, ImmType(JSVAL_TYPE_NULL));
56766:                 if (!jumpAndTrace(j2, target))
56766:                     return false;
52954:                 j.linkTo(masm.label(), &masm);
52954:             }
52954:         } else {
53162:             Jump j = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_UNDEFINED));
53162:             Jump j2 = masm.branchPtr(Assembler::Equal, reg, ImmType(JSVAL_TYPE_NULL));
52954:             masm.move(Imm32(op == JSOP_NE), reg);
52954:             Jump j3 = masm.jump();
52954:             j2.linkTo(masm.label(), &masm);
52954:             j.linkTo(masm.label(), &masm);
52954:             masm.move(Imm32(op == JSOP_EQ), reg);
52954:             j3.linkTo(masm.label(), &masm);
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52879:         }
56766:         return true;
52879:     }
52879: 
75833:     if (cx->typeInferenceEnabled() &&
75833:         lhs->isType(JSVAL_TYPE_OBJECT) && rhs->isType(JSVAL_TYPE_OBJECT)) {
75833:         /*
75833:          * Handle equality between two objects. We have to ensure there is no
75833:          * special equality operator on either object, if that passes then
75833:          * this is a pointer comparison.
75833:          */
75833:         types::TypeSet *lhsTypes = frame.getTypeSet(lhs);
75833:         types::TypeSet *rhsTypes = frame.getTypeSet(rhs);
75833:         types::ObjectKind lhsKind =
75893:             lhsTypes ? lhsTypes->getKnownObjectKind(cx) : types::OBJECT_UNKNOWN;
75833:         types::ObjectKind rhsKind =
75893:             rhsTypes ? rhsTypes->getKnownObjectKind(cx) : types::OBJECT_UNKNOWN;
75833: 
75833:         if (lhsKind != types::OBJECT_UNKNOWN && rhsKind != types::OBJECT_UNKNOWN) {
75833:             /* :TODO: Merge with jsop_relational_int? */
75833:             JS_ASSERT_IF(!target, fused != JSOP_IFEQ);
75846:             frame.forgetConstantData(lhs);
75846:             frame.forgetConstantData(rhs);
75833:             Assembler::Condition cond = GetCompareCondition(op, fused);
75833:             if (target) {
75833:                 fixDoubleTypes(Uses(2));
75833:                 if (!frame.syncForBranch(target, Uses(2)))
75833:                     return false;
75863:                 RegisterID lreg = frame.tempRegForData(lhs);
75863:                 frame.pinReg(lreg);
75863:                 RegisterID rreg = frame.tempRegForData(rhs);
75863:                 frame.unpinReg(lreg);
75863:                 Jump fast = masm.branchPtr(cond, lreg, rreg);
75833:                 frame.popn(2);
75833:                 return jumpAndTrace(fast, target);
75833:             } else {
75863:                 RegisterID result = frame.allocReg();
75833:                 RegisterID lreg = frame.tempRegForData(lhs);
75863:                 frame.pinReg(lreg);
75833:                 RegisterID rreg = frame.tempRegForData(rhs);
75863:                 frame.unpinReg(lreg);
75833:                 masm.branchValue(cond, lreg, rreg, result);
75833: 
75833:                 frame.popn(2);
75833:                 frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
75833:                 return true;
75833:             }
75833:         }
75833:     }
75833: 
56766:     return emitStubCmpOp(stub, target, fused);
52879: }
52879: 
56766: bool
52653: mjit::Compiler::jsop_relational(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
52651: {
52652:     FrameEntry *rhs = frame.peek(-1);
52652:     FrameEntry *lhs = frame.peek(-2);
52652: 
52653:     /* The compiler should have handled constant folding. */
52653:     JS_ASSERT(!(rhs->isConstant() && lhs->isConstant()));
52653: 
52653:     /* Always slow path... */
54160:     if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_DOUBLE) &&
54160:          lhs->isNotType(JSVAL_TYPE_STRING)) ||
54160:         (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_DOUBLE) &&
54160:          rhs->isNotType(JSVAL_TYPE_STRING))) {
52879:         if (op == JSOP_EQ || op == JSOP_NE)
56766:             return jsop_equality(op, stub, target, fused);
56766:         return emitStubCmpOp(stub, target, fused);
52653:     }
52653: 
53201:     if (op == JSOP_EQ || op == JSOP_NE) {
54160:         if ((lhs->isNotType(JSVAL_TYPE_INT32) && lhs->isNotType(JSVAL_TYPE_STRING)) ||
54160:             (rhs->isNotType(JSVAL_TYPE_INT32) && rhs->isNotType(JSVAL_TYPE_STRING))) {
56766:             return emitStubCmpOp(stub, target, fused);
54160:         } else if (!target && (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING))) {
56766:             return emitStubCmpOp(stub, target, fused);
54717:         } else if (frame.haveSameBacking(lhs, rhs)) {
56766:             return emitStubCmpOp(stub, target, fused);
54160:         } else {
56766:             return jsop_equality_int_string(op, stub, target, fused);
54160:         }
52651:     }
52651: 
53201:     if (frame.haveSameBacking(lhs, rhs)) {
56766:         return jsop_relational_self(op, stub, target, fused);
54160:     } else if (lhs->isType(JSVAL_TYPE_STRING) || rhs->isType(JSVAL_TYPE_STRING)) {
56766:         return emitStubCmpOp(stub, target, fused);
53201:     } else if (lhs->isType(JSVAL_TYPE_DOUBLE) || rhs->isType(JSVAL_TYPE_DOUBLE)) {
56766:         return jsop_relational_double(op, stub, target, fused);
75649:     } else if (lhs->isType(JSVAL_TYPE_INT32) && rhs->isType(JSVAL_TYPE_INT32)) {
75649:         return jsop_relational_int(op, target, fused);
52653:     } else {
56766:         return jsop_relational_full(op, stub, target, fused);
52653:     }
52653: }
52653: 
52713: void
52734: mjit::Compiler::jsop_not()
52734: {
52734:     FrameEntry *top = frame.peek(-1);
52734: 
52734:     if (top->isConstant()) {
52734:         const Value &v = top->getValue();
52734:         frame.pop();
53081:         frame.push(BooleanValue(!js_ValueToBoolean(v)));
52734:         return;
52734:     }
52734: 
52734:     if (top->isTypeKnown()) {
53025:         JSValueType type = top->getKnownType();
53025:         switch (type) {
53025:           case JSVAL_TYPE_INT32:
52975:           {
75647:             RegisterID data = frame.allocReg(Registers::SingleByteRegs).reg();
52975:             if (frame.shouldAvoidDataRemat(top))
53144:                 masm.loadPayload(frame.addressOf(top), data);
52975:             else
52975:                 masm.move(frame.tempRegForData(top), data);
52975: 
52975:             masm.set32(Assembler::Equal, data, Imm32(0), data);
52975: 
52975:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, data);
52975:             break;
52975:           }
52975: 
53025:           case JSVAL_TYPE_BOOLEAN:
52734:           {
52734:             RegisterID reg = frame.ownRegForData(top);
52975: 
52975:             masm.xor32(Imm32(1), reg);
52975: 
52734:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734: 
53025:           case JSVAL_TYPE_OBJECT:
52734:           {
52734:             frame.pop();
53081:             frame.push(BooleanValue(false));
52734:             break;
52734:           }
52734: 
52734:           default:
52734:           {
53087:             prepareStubCall(Uses(1));
57766:             INLINE_STUBCALL(stubs::ValueToBoolean);
52975: 
52975:             RegisterID reg = Registers::ReturnReg;
52734:             frame.takeReg(reg);
52975:             masm.xor32(Imm32(1), reg);
52975: 
52734:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
52734:             break;
52734:           }
52734:         }
52734: 
52734:         return;
52734:     }
52734: 
75647:     RegisterID data = frame.allocReg(Registers::SingleByteRegs).reg();
52956:     if (frame.shouldAvoidDataRemat(top))
53144:         masm.loadPayload(frame.addressOf(top), data);
52956:     else
52956:         masm.move(frame.tempRegForData(top), data);
52956:     RegisterID type = frame.tempRegForType(top);
53088:     Label syncTarget = stubcc.syncExitAndJump(Uses(1));
52734: 
52975: 
52975:     /* Inline path is for booleans. */
52975:     Jump jmpNotBool = masm.testBoolean(Assembler::NotEqual, type);
52975:     masm.xor32(Imm32(1), data);
52975: 
52975: 
52975:     /* OOL path is for int + object. */
52975:     Label lblMaybeInt32 = stubcc.masm.label();
52975: 
52975:     Jump jmpNotInt32 = stubcc.masm.testInt32(Assembler::NotEqual, type);
52975:     stubcc.masm.set32(Assembler::Equal, data, Imm32(0), data);
52975:     Jump jmpInt32Exit = stubcc.masm.jump();
52975: 
52975:     Label lblMaybeObject = stubcc.masm.label();
52975:     Jump jmpNotObject = stubcc.masm.testPrimitive(Assembler::Equal, type);
52975:     stubcc.masm.move(Imm32(0), data);
52975:     Jump jmpObjectExit = stubcc.masm.jump();
52975: 
52975: 
52975:     /* Rejoin location. */
52975:     Label lblRejoin = masm.label();
52975: 
52975:     /* Patch up jumps. */
52975:     stubcc.linkExitDirect(jmpNotBool, lblMaybeInt32);
52975: 
52975:     jmpNotInt32.linkTo(lblMaybeObject, &stubcc.masm);
52975:     stubcc.crossJump(jmpInt32Exit, lblRejoin);
52975: 
52975:     jmpNotObject.linkTo(syncTarget, &stubcc.masm);
52975:     stubcc.crossJump(jmpObjectExit, lblRejoin);
52975:     
52975: 
52975:     /* Leave. */
52734:     stubcc.leave();
57766:     OOL_STUBCALL(stubs::Not);
52734: 
52734:     frame.pop();
53025:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, data);
52734: 
53088:     stubcc.rejoin(Changes(1));
52734: }
52734: 
52738: void
52738: mjit::Compiler::jsop_typeof()
52738: {
52738:     FrameEntry *fe = frame.peek(-1);
52738: 
52738:     if (fe->isTypeKnown()) {
52738:         JSRuntime *rt = cx->runtime;
52738: 
52738:         JSAtom *atom = NULL;
53025:         switch (fe->getKnownType()) {
53025:           case JSVAL_TYPE_STRING:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_STRING];
52738:             break;
53025:           case JSVAL_TYPE_UNDEFINED:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_VOID];
52738:             break;
53025:           case JSVAL_TYPE_NULL:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_OBJECT];
52738:             break;
53025:           case JSVAL_TYPE_OBJECT:
52738:             atom = NULL;
52738:             break;
53025:           case JSVAL_TYPE_BOOLEAN:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_BOOLEAN];
52738:             break;
52738:           default:
52738:             atom = rt->atomState.typeAtoms[JSTYPE_NUMBER];
52738:             break;
52738:         }
52738: 
52738:         if (atom) {
75849:             RegisterID reg = frame.allocReg();
75857:             masm.move(ImmPtr(atom), reg);
52738:             frame.pop();
75849:             frame.pushTypedPayload(JSVAL_TYPE_STRING, reg);
52738:             return;
52738:         }
52738:     }
52738: 
58690:     JSOp fused = JSOp(PC[JSOP_TYPEOF_LENGTH]);
58690:     if (fused == JSOP_STRING && !fe->isTypeKnown()) {
58690:         JSOp op = JSOp(PC[JSOP_TYPEOF_LENGTH + JSOP_STRING_LENGTH]);
58690: 
58690:         if (op == JSOP_STRICTEQ || op == JSOP_EQ || op == JSOP_STRICTNE || op == JSOP_NE) {
58690:             JSAtom *atom = script->getAtom(fullAtomIndex(PC + JSOP_TYPEOF_LENGTH));
58690:             JSRuntime *rt = cx->runtime;
60244:             JSValueType type = JSVAL_TYPE_BOXED;
58690:             Assembler::Condition cond = (op == JSOP_STRICTEQ || op == JSOP_EQ)
58690:                                         ? Assembler::Equal
58690:                                         : Assembler::NotEqual;
58690:             
58690:             if (atom == rt->atomState.typeAtoms[JSTYPE_VOID]) {
58690:                 type = JSVAL_TYPE_UNDEFINED;
58690:             } else if (atom == rt->atomState.typeAtoms[JSTYPE_STRING]) {
58690:                 type = JSVAL_TYPE_STRING;
58690:             } else if (atom == rt->atomState.typeAtoms[JSTYPE_BOOLEAN]) {
58690:                 type = JSVAL_TYPE_BOOLEAN;
58690:             } else if (atom == rt->atomState.typeAtoms[JSTYPE_NUMBER]) {
58690:                 type = JSVAL_TYPE_INT32;
58690: 
58690:                 /* JSVAL_TYPE_DOUBLE is 0x0 and JSVAL_TYPE_INT32 is 0x1, use <= or > to match both */
58690:                 cond = (cond == Assembler::Equal) ? Assembler::BelowOrEqual : Assembler::Above;
58690:             }
58690: 
60244:             if (type != JSVAL_TYPE_BOXED) {
58690:                 PC += JSOP_STRING_LENGTH;;
58690:                 PC += JSOP_EQ_LENGTH;
58690: 
75657:                 RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
58690: 
58690: #if defined JS_NUNBOX32
58690:                 if (frame.shouldAvoidTypeRemat(fe))
58690:                     masm.set32(cond, masm.tagOf(frame.addressOf(fe)), ImmType(type), result);
58690:                 else
58690:                     masm.set32(cond, frame.tempRegForType(fe), ImmType(type), result);
58690: #elif defined JS_PUNBOX64
58690:                 masm.setPtr(cond, frame.tempRegForType(fe), ImmType(type), result);
58690: #endif
58690: 
58690:                 frame.pop();
58690:                 frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
58690:                 return;
58690:             }
58690:         }
58690:     }
58690: 
53087:     prepareStubCall(Uses(1));
57766:     INLINE_STUBCALL(stubs::TypeOf);
52738:     frame.pop();
52738:     frame.takeReg(Registers::ReturnReg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_STRING, Registers::ReturnReg);
52738: }
52738: 
56766: bool
53102: mjit::Compiler::booleanJumpScript(JSOp op, jsbytecode *target)
53086: {
53086:     FrameEntry *fe = frame.peek(-1);
53086: 
53086:     MaybeRegisterID type;
53086:     MaybeRegisterID data;
53086: 
53185:     if (!fe->isTypeKnown() && !frame.shouldAvoidTypeRemat(fe))
53185:         type.setReg(frame.copyTypeIntoReg(fe));
75630:     if (!fe->isType(JSVAL_TYPE_DOUBLE))
53185:         data.setReg(frame.copyDataIntoReg(fe));
53086: 
54719:     frame.syncAndForgetEverything();
53086: 
53102:     Assembler::Condition cond = (op == JSOP_IFNE || op == JSOP_OR)
53086:                                 ? Assembler::NonZero
53086:                                 : Assembler::Zero;
53102:     Assembler::Condition ncond = (op == JSOP_IFNE || op == JSOP_OR)
53086:                                  ? Assembler::Zero
53086:                                  : Assembler::NonZero;
53086: 
53086:     /* Inline path: Boolean guard + call script. */
53086:     MaybeJump jmpNotBool;
53086:     MaybeJump jmpNotExecScript;
53086:     if (type.isSet()) {
53152:         jmpNotBool.setJump(masm.testBoolean(Assembler::NotEqual, type.reg()));
53086:     } else {
53086:         if (!fe->isTypeKnown()) {
53086:             jmpNotBool.setJump(masm.testBoolean(Assembler::NotEqual,
53086:                                                 frame.addressOf(fe)));
53204:         } else if (fe->isNotType(JSVAL_TYPE_BOOLEAN) &&
53204:                    fe->isNotType(JSVAL_TYPE_INT32)) {
53086:             jmpNotBool.setJump(masm.jump());
53086:         }
53086:     }
53086: 
53086:     /* 
53086:      * TODO: We don't need the second jump if
53086:      * jumpInScript() can go from ool path to inline path.
53086:      */
75630:     if (!fe->isType(JSVAL_TYPE_DOUBLE))
53152:         jmpNotExecScript.setJump(masm.branchTest32(ncond, data.reg(), data.reg()));
53086:     Label lblExecScript = masm.label();
53086:     Jump j = masm.jump();
53086: 
53086: 
53086:     /* OOL path: Conversion to boolean. */
53086:     MaybeJump jmpCvtExecScript;
53086:     MaybeJump jmpCvtRejoin;
53086:     Label lblCvtPath = stubcc.masm.label();
53086: 
53204:     if (!fe->isTypeKnown() ||
53204:         !(fe->isType(JSVAL_TYPE_BOOLEAN) || fe->isType(JSVAL_TYPE_INT32))) {
57766:         stubcc.masm.infallibleVMCall(JS_FUNC_TO_DATA_PTR(void *, stubs::ValueToBoolean),
75864:                                      frame.totalDepth());
53086: 
53086:         jmpCvtExecScript.setJump(stubcc.masm.branchTest32(cond, Registers::ReturnReg,
53086:                                                           Registers::ReturnReg));
53086:         jmpCvtRejoin.setJump(stubcc.masm.jump());
53086:     }
53086: 
53086:     /* Rejoin tag. */
53086:     Label lblAfterScript = masm.label();
53086: 
53086:     /* Patch up jumps. */
53086:     if (jmpNotBool.isSet())
53086:         stubcc.linkExitDirect(jmpNotBool.getJump(), lblCvtPath);
53086:     if (jmpNotExecScript.isSet())
53086:         jmpNotExecScript.getJump().linkTo(lblAfterScript, &masm);
53086: 
53086:     if (jmpCvtExecScript.isSet())
53086:         stubcc.crossJump(jmpCvtExecScript.getJump(), lblExecScript);
53086:     if (jmpCvtRejoin.isSet())
53086:         stubcc.crossJump(jmpCvtRejoin.getJump(), lblAfterScript);
53086: 
53086:     frame.pop();
53133: 
56766:     return jumpAndTrace(j, target);
53086: }
53086: 
56766: bool
53102: mjit::Compiler::jsop_ifneq(JSOp op, jsbytecode *target)
53102: {
53102:     FrameEntry *fe = frame.peek(-1);
53102: 
53102:     if (fe->isConstant()) {
53102:         JSBool b = js_ValueToBoolean(fe->getValue());
53102: 
53133:         frame.pop();
53133: 
53102:         if (op == JSOP_IFEQ)
53102:             b = !b;
53102:         if (b) {
75649:             fixDoubleTypes(Uses(0));
75649:             if (!frame.syncForBranch(target, Uses(0)))
75649:                 return false;
56766:             if (!jumpAndTrace(masm.jump(), target))
56766:                 return false;
75649:         } else {
75649:             if (target < PC && !finishLoop(target))
75649:                 return Compile_Error;
53102:         }
56766:         return true;
53102:     }
53102: 
56766:     return booleanJumpScript(op, target);
53102: }
53102: 
56766: bool
53102: mjit::Compiler::jsop_andor(JSOp op, jsbytecode *target)
53102: {
53102:     FrameEntry *fe = frame.peek(-1);
53102: 
53102:     if (fe->isConstant()) {
53102:         JSBool b = js_ValueToBoolean(fe->getValue());
53102:         
53102:         /* Short-circuit. */
53102:         if ((op == JSOP_OR && b == JS_TRUE) ||
53102:             (op == JSOP_AND && b == JS_FALSE)) {
75649:             fixDoubleTypes(Uses(0));
75649:             if (!frame.syncForBranch(target, Uses(0)))
75649:                 return false;
56766:             if (!jumpAndTrace(masm.jump(), target))
56766:                 return false;
53102:         }
53102: 
53102:         frame.pop();
56766:         return true;
53102:     }
53102: 
56766:     return booleanJumpScript(op, target);
53102: }
53102: 
75668: bool
52808: mjit::Compiler::jsop_localinc(JSOp op, uint32 slot, bool popped)
52808: {
75649:     JSValueType type = knownLocalType(slot);
58289: 
58721:     if (popped || (op == JSOP_INCLOCAL || op == JSOP_DECLOCAL)) {
58721:         int amt = (op == JSOP_LOCALINC || op == JSOP_INCLOCAL) ? -1 : 1;
52808: 
58721:         // Before: 
58721:         // After:  V
75790:         frame.pushLocal(slot, type);
52808: 
58721:         // Before: V
58721:         // After:  V 1
58721:         frame.push(Int32Value(amt));
52808: 
58721:         // Note, SUB will perform integer conversion for us.
58721:         // Before: V 1
58721:         // After:  N+1
75851:         if (!jsop_binary(JSOP_SUB, stubs::Sub, type, localTypeSet(slot)))
75668:             return false;
52808: 
58721:         // Before: N+1
58721:         // After:  N+1
75790:         frame.storeLocal(slot, type, popped, true);
52808: 
53346:         if (popped)
52808:             frame.pop();
58721:     } else {
58721:         int amt = (op == JSOP_LOCALINC || op == JSOP_INCLOCAL) ? 1 : -1;
52808: 
58721:         // Before:
58721:         // After: V
75790:         frame.pushLocal(slot, type);
58721: 
58721:         // Before: V
58721:         // After:  N
58721:         jsop_pos();
58721: 
58721:         // Before: N
58721:         // After:  N N
58721:         frame.dup();
58721: 
58721:         // Before: N N
58721:         // After:  N N 1
58721:         frame.push(Int32Value(amt));
58721: 
58721:         // Before: N N 1
58721:         // After:  N N+1
75851:         if (!jsop_binary(JSOP_ADD, stubs::Add, type, localTypeSet(slot)))
75668:             return false;
58721: 
58721:         // Before: N N+1
58721:         // After:  N N+1
75790:         frame.storeLocal(slot, type, true, true);
58721: 
58721:         // Before: N N+1
58721:         // After:  N
58721:         frame.pop();
58721:     }
75668: 
75668:     return true;
52808: }
52808: 
75668: bool
52804: mjit::Compiler::jsop_arginc(JSOp op, uint32 slot, bool popped)
52804: {
75643:     JSValueType type = knownArgumentType(slot);
75643: 
57787:     if (popped || (op == JSOP_INCARG || op == JSOP_DECARG)) {
57787:         int amt = (op == JSOP_ARGINC || op == JSOP_INCARG) ? -1 : 1;
52804: 
57787:         // Before: 
57787:         // After:  V
75790:         frame.pushArg(slot, type);
57787: 
57787:         // Before: V
57787:         // After:  V 1
57787:         frame.push(Int32Value(amt));
57787: 
57787:         // Note, SUB will perform integer conversion for us.
57787:         // Before: V 1
57787:         // After:  N+1
75851:         if (!jsop_binary(JSOP_SUB, stubs::Sub, type, argTypeSet(slot)))
75668:             return false;
57787: 
57787:         // Before: N+1
57787:         // After:  N+1
75790:         frame.storeArg(slot, type, popped);
57787: 
57787:         if (popped)
57787:             frame.pop();
57787:     } else {
57787:         int amt = (op == JSOP_ARGINC || op == JSOP_INCARG) ? 1 : -1;
57787: 
57787:         // Before:
57787:         // After: V
75790:         frame.pushArg(slot, type);
57787: 
57787:         // Before: V
57787:         // After:  N
57787:         jsop_pos();
57787: 
57787:         // Before: N
57787:         // After:  N N
52804:         frame.dup();
52804: 
57787:         // Before: N N
57787:         // After:  N N 1
57787:         frame.push(Int32Value(amt));
52804: 
57787:         // Before: N N 1
57787:         // After:  N N+1
75851:         if (!jsop_binary(JSOP_ADD, stubs::Add, type, argTypeSet(slot)))
75668:             return false;
57787: 
57787:         // Before: N N+1
57787:         // After:  N N+1
75790:         frame.storeArg(slot, type, true);
57787: 
57787:         // Before: N N+1
57787:         // After:  N
52804:         frame.pop();
57787:     }
75668: 
75668:     return true;
52804: }
52804: 
57671: static inline bool
57671: IsCacheableSetElem(FrameEntry *obj, FrameEntry *id, FrameEntry *value)
57671: {
57671:     if (obj->isNotType(JSVAL_TYPE_OBJECT))
57671:         return false;
57671:     if (id->isNotType(JSVAL_TYPE_INT32))
57671:         return false;
75832:     if (id->isConstant()) {
75832:         if (id->getValue().toInt32() < 0)
57671:             return false;
75832:         if (id->getValue().toInt32() + 1 < 0)  // watch for overflow in hole paths
75832:             return false;
75832:     }
57671: 
57671:     // obj[obj] * is not allowed, since it will never optimize.
57671:     // obj[id] = id is allowed.
57671:     // obj[id] = obj is allowed.
57671:     if (obj->hasSameBacking(id))
57671:         return false;
57671: 
57671:     return true;
57671: }
57671: 
75625: void
75625: mjit::Compiler::jsop_setelem_dense()
75625: {
75625:     FrameEntry *obj = frame.peek(-3);
75625:     FrameEntry *id = frame.peek(-2);
75625:     FrameEntry *value = frame.peek(-1);
75625: 
75625:     // We might not know whether this is an object, but if it is an object we
75625:     // know it is a dense array.
75625:     if (!obj->isTypeKnown()) {
75625:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
75625:         stubcc.linkExit(guard, Uses(3));
75625:     }
75625: 
75625:     // Test for integer index.
75625:     if (!id->isTypeKnown()) {
75625:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
75625:         stubcc.linkExit(guard, Uses(3));
75625:     }
75625: 
75625:     // Allocate registers.
75625: 
75625:     ValueRemat vr;
75625:     frame.pinEntry(value, vr);
75625: 
75625:     Int32Key key = id->isConstant()
75625:                  ? Int32Key::FromConstant(id->getValue().toInt32())
75625:                  : Int32Key::FromRegister(frame.tempRegForData(id));
75625:     if (!key.isConstant() && !frame.haveSameBacking(id, value))
75625:         frame.pinReg(key.reg());
75625: 
75627:     RegisterID objReg;
75627:     if (frame.haveSameBacking(obj, value)) {
75627:         objReg = frame.allocReg();
75627:         masm.move(vr.dataReg(), objReg);
75627:     } else if (frame.haveSameBacking(obj, id)) {
75627:         objReg = frame.allocReg();
75627:         masm.move(key.reg(), objReg);
75627:     } else {
75627:         objReg = frame.copyDataIntoReg(obj);
75627:     }
75625: 
75625:     frame.unpinEntry(vr);
75625:     if (!key.isConstant() && !frame.haveSameBacking(id, value))
75625:         frame.unpinReg(key.reg());
75625: 
75625:     Label syncTarget = stubcc.syncExitAndJump(Uses(3));
75625: 
75625:     // Check against initialized length.  This always need to be done.
75625:     Jump initlenGuard = masm.guardArrayExtent(offsetof(JSObject, initializedLength),
75625:                                               objReg, key, Assembler::BelowOrEqual);
75625: 
75625:     // Make an OOL path for setting exactly the initialized length.
75625:     {
75625:         stubcc.linkExitDirect(initlenGuard, stubcc.masm.label());
75625: 
75625:         // Recheck for an exact initialized length.
75625:         // :TODO: would be nice to reuse the condition bits from the previous test.
75625:         Jump exactlenGuard = stubcc.masm.guardArrayExtent(offsetof(JSObject, initializedLength),
75625:                                                           objReg, key, Assembler::NotEqual);
75625:         exactlenGuard.linkTo(syncTarget, &stubcc.masm);
75625: 
75625:         // Check array capacity.
75625:         Jump capacityGuard = stubcc.masm.guardArrayExtent(offsetof(JSObject, capacity),
75625:                                                           objReg, key, Assembler::BelowOrEqual);
75625:         capacityGuard.linkTo(syncTarget, &stubcc.masm);
75625: 
75625:         // Bump the index for setting the array length.  The above guard ensures this
75625:         // won't overflow.
75625:         stubcc.masm.bumpKey(key, 1);
75625: 
75625:         // Update the initialized length.
75625:         stubcc.masm.storeKey(key, Address(objReg, offsetof(JSObject, initializedLength)));
75625: 
75625:         // Update the array length if needed.
75625:         Jump lengthGuard = stubcc.masm.guardArrayExtent(offsetof(JSObject, privateData),
75625:                                                         objReg, key, Assembler::AboveOrEqual);
75625:         stubcc.masm.storeKey(key, Address(objReg, offsetof(JSObject, privateData)));
75625:         lengthGuard.linkTo(stubcc.masm.label(), &stubcc.masm);
75625: 
75625:         // Restore the index.
75625:         stubcc.masm.bumpKey(key, -1);
75625: 
75625:         // Jump back to the inline path.
75625:         Jump initlenExit = stubcc.masm.jump();
75625:         stubcc.crossJump(initlenExit, masm.label());
75625:     }
75625: 
75625:     // Fully store the value. :TODO: don't need to do this in the non-initlen case
75625:     // if the array is packed and monomorphic.
75625:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
75625:     if (key.isConstant())
75625:         masm.storeValue(vr, Address(objReg, key.index() * sizeof(Value)));
75625:     else
75625:         masm.storeValue(vr, BaseIndex(objReg, key.reg(), masm.JSVAL_SCALE));
75625: 
75625:     stubcc.leave();
75631:     OOL_STUBCALL(STRICT_VARIANT(stubs::SetElem));
75625: 
75625:     frame.freeReg(objReg);
75625:     frame.shimmy(2);
75625:     stubcc.rejoin(Changes(2));
75810: 
75810:     if (recompiling) {
75810:         OOL_STUBCALL(STRICT_VARIANT(ic::SetElement));
75810:         stubcc.rejoin(Changes(2));
75810:     }
75625: }
75625: 
57671: bool
60164: mjit::Compiler::jsop_setelem(bool popGuaranteed)
52838: {
52838:     FrameEntry *obj = frame.peek(-3);
52838:     FrameEntry *id = frame.peek(-2);
57671:     FrameEntry *value = frame.peek(-1);
52838: 
75708:     if (!IsCacheableSetElem(obj, id, value) || monitored(PC)) {
52838:         jsop_setelem_slow();
57671:         return true;
52838:     }
52838: 
75846:     frame.forgetConstantData(obj);
75846: 
75720:     if (cx->typeInferenceEnabled()) {
75790:         types::TypeSet *types = frame.getTypeSet(obj);
75864:         types::ObjectKind kind = types
75893:             ? types->getKnownObjectKind(cx)
75864:             : types::OBJECT_UNKNOWN;
75625:         if (id->mightBeType(JSVAL_TYPE_INT32) &&
75625:             (kind == types::OBJECT_DENSE_ARRAY || kind == types::OBJECT_PACKED_ARRAY) &&
75677:             !arrayPrototypeHasIndexedProperty()) {
75720:             // This is definitely a dense array, generate code directly without
75625:             // using an inline cache.
75625:             jsop_setelem_dense();
75625:             return true;
75625:         }
75720:     }
75625: 
57671:     SetElementICInfo ic = SetElementICInfo(JSOp(*PC));
57671: 
57671:     // One by one, check if the most important stack entries have registers,
57671:     // and if so, pin them. This is to avoid spilling and reloading from the
57671:     // stack as we incrementally allocate other registers.
57671:     MaybeRegisterID pinnedValueType = frame.maybePinType(value);
57671:     MaybeRegisterID pinnedValueData = frame.maybePinData(value);
57671: 
57671:     // Pin |obj| if it doesn't share a backing with |value|.
57671:     MaybeRegisterID pinnedObjData;
57671:     if (!obj->hasSameBacking(value))
57671:         pinnedObjData = frame.maybePinData(obj);
57671: 
57671:     // Pin |id| if it doesn't share a backing with |value|.
57671:     MaybeRegisterID pinnedIdData;
57671:     if (!id->hasSameBacking(value))
57671:         pinnedIdData = frame.maybePinData(id);
57671: 
57671:     // Note: The fact that |obj| and |value|, or |id| and |value| can be
57671:     // copies, is a little complicated, but it is safe. Explanations
57671:     // follow at each point. Keep in mind two points:
57671:     //  1) maybePin() never allocates a register, it only pins if a register
57671:     //     already existed.
57671:     //  2) tempRegForData() will work fine on a pinned register.
57671:  
57671:     // Guard that the object is an object.
57671:     if (!obj->isTypeKnown()) {
57671:         Jump j = frame.testObject(Assembler::NotEqual, obj);
57671:         stubcc.linkExit(j, Uses(3));
57671:     }
57671: 
57671:     // Guard that the id is int32.
52838:     if (!id->isTypeKnown()) {
52838:         Jump j = frame.testInt32(Assembler::NotEqual, id);
53088:         stubcc.linkExit(j, Uses(3));
52838:     }
52838: 
57671:     // Grab a register for the object. It's safe to unpin |obj| because it
57671:     // won't have been pinned if it shares a backing with |value|. However,
57671:     // it would not be safe to copyDataIntoReg() if the value was pinned,
57671:     // since this could evict the register. So we special case.
57671:     frame.maybeUnpinReg(pinnedObjData);
57671:     if (obj->hasSameBacking(value) && pinnedValueData.isSet()) {
57671:         ic.objReg = frame.allocReg();
57671:         masm.move(pinnedValueData.reg(), ic.objReg);
57671:     } else {
57671:         ic.objReg = frame.copyDataIntoReg(obj);
52838:     }
52838: 
57671:     // pinEntry() will ensure pinned registers for |value|. To avoid a
57671:     // double-pin assert, first unpin any registers that |value| had.
57671:     frame.maybeUnpinReg(pinnedValueType);
57671:     frame.maybeUnpinReg(pinnedValueData);
57671:     frame.pinEntry(value, ic.vr);
52838: 
57671:     // Store rematerialization information about the key. This is the final
57671:     // register we allocate, and thus it can use tempRegForData() without
57671:     // the worry of being spilled. Once again, this is safe even if |id|
57671:     // shares a backing with |value|, because tempRegForData() will work on
57671:     // the pinned register, and |pinnedIdData| will not double-pin.
57671:     frame.maybeUnpinReg(pinnedIdData);
57671:     if (id->isConstant())
57671:         ic.key = Int32Key::FromConstant(id->getValue().toInt32());
57671:     else
57671:         ic.key = Int32Key::FromRegister(frame.tempRegForData(id));
53227: 
57671:     // Unpin the value since register allocation is complete.
57671:     frame.unpinEntry(ic.vr);
57671: 
57671:     // Now it's also safe to grab remat info for obj (all exits that can
57671:     // generate stubs must have the same register state).
57671:     ic.objRemat = frame.dataRematInfo(obj);
57671: 
57671:     // All patchable guards must occur after this point.
60597:     RESERVE_IC_SPACE(masm);
57671:     ic.fastPathStart = masm.label();
57671: 
57671:     // Create the common out-of-line sync block, taking care to link previous
57671:     // guards here after.
60597:     RESERVE_OOL_SPACE(stubcc.masm);
57671:     ic.slowPathStart = stubcc.syncExit(Uses(3));
57671: 
57671:     // Guard obj is a dense array.
57671:     ic.claspGuard = masm.testObjClass(Assembler::NotEqual, ic.objReg, &js_ArrayClass);
57671:     stubcc.linkExitDirect(ic.claspGuard, ic.slowPathStart);
57671: 
75625:     // Guard in range of initialized length.
75625:     Jump initlenGuard = masm.guardArrayExtent(offsetof(JSObject, initializedLength),
75625:                                               ic.objReg, ic.key, Assembler::BelowOrEqual);
75625:     stubcc.linkExitDirect(initlenGuard, ic.slowPathStart);
57671: 
57671:     // Load the dynamic slots vector.
57671:     masm.loadPtr(Address(ic.objReg, offsetof(JSObject, slots)), ic.objReg);
57671: 
57671:     // Guard there's no hole, then store directly to the slot.
57671:     if (ic.key.isConstant()) {
57671:         Address slot(ic.objReg, ic.key.index() * sizeof(Value));
57671:         ic.holeGuard = masm.guardNotHole(slot);
57671:         masm.storeValue(ic.vr, slot);
53227:     } else {
57671:         BaseIndex slot(ic.objReg, ic.key.reg(), Assembler::JSVAL_SCALE);
57671:         ic.holeGuard = masm.guardNotHole(slot);
57671:         masm.storeValue(ic.vr, slot);
53227:     }
57671:     stubcc.linkExitDirect(ic.holeGuard, ic.slowPathStart);
52838: 
52838:     stubcc.leave();
60598: #if defined JS_POLYIC
57671:     passICAddress(&ic);
57766:     ic.slowPathCall = OOL_STUBCALL(STRICT_VARIANT(ic::SetElement));
57671: #else
57766:     OOL_STUBCALL(STRICT_VARIANT(stubs::SetElem));
53162: #endif
53228: 
57671:     ic.fastPathRejoin = masm.label();
53228: 
60164:     // When generating typed array stubs, it may be necessary to call
60164:     // js_DoubleToECMAInt32(), which would clobber registers. To deal with
60164:     // this, we tell the IC exactly which registers need to be saved
60164:     // across calls.
62019:     ic.volatileMask = frame.regsInUse();
60164: 
60164:     // If the RHS will be popped, and doesn't overlap any live values, then
60164:     // there's no need to save it across calls. Note that this is not true of
60164:     // |obj| or |key|, which will be used to compute the LHS reference for
60164:     // assignment.
60164:     //
60164:     // Note that the IC wants to clobber |vr.dataReg| to convert for typed
60164:     // arrays. If this clobbering is necessary, we must preserve dataReg,
60164:     // even if it's not in a volatile register.
60164:     if (popGuaranteed &&
60164:         !ic.vr.isConstant() &&
60164:         !value->isCopy() &&
60164:         !frame.haveSameBacking(value, obj) &&
60164:         !frame.haveSameBacking(value, id))
60164:     {
60164:         ic.volatileMask &= ~Registers::maskReg(ic.vr.dataReg());
60164:         if (!ic.vr.isTypeKnown())
60164:             ic.volatileMask &= ~Registers::maskReg(ic.vr.typeReg());
60164:     } else if (!ic.vr.isConstant()) {
60164:         ic.volatileMask |= Registers::maskReg(ic.vr.dataReg());
60164:     }
60164: 
57671:     frame.freeReg(ic.objReg);
57671:     frame.shimmy(2);
57671:     stubcc.rejoin(Changes(2));
53228: 
60598: #if defined JS_POLYIC
57671:     if (!setElemICs.append(ic))
57671:         return false;
75636: 
75636:     if (recompiling) {
75636:         OOL_STUBCALL(STRICT_VARIANT(stubs::SetElem));
75636:         stubcc.rejoin(Changes(2));
75636:     }
57671: #endif
53228: 
56831:     return true;
56831: }
56831: 
56766: static inline bool
56766: IsCacheableGetElem(FrameEntry *obj, FrameEntry *id)
56766: {
56766:     if (obj->isTypeKnown() && obj->getKnownType() != JSVAL_TYPE_OBJECT)
56766:         return false;
53137:     if (id->isTypeKnown() &&
53137:         !(id->getKnownType() == JSVAL_TYPE_INT32
60598: #if defined JS_POLYIC
53137:           || id->getKnownType() == JSVAL_TYPE_STRING
53137: #endif
53137:          )) {
56766:         return false;
53137:     }
53137: 
53137:     if (id->isTypeKnown() && id->getKnownType() == JSVAL_TYPE_INT32 && id->isConstant() &&
53137:         id->getValue().toInt32() < 0) {
56766:         return false;
56766:     }
56766: 
57671:     // obj[obj] is not allowed, since it will never optimize.
57671:     if (obj->hasSameBacking(id))
57671:         return false;
57671: 
56766:     return true;
56766: }
56766: 
75625: void
75625: mjit::Compiler::jsop_getelem_dense(bool isPacked)
75625: {
75625:     FrameEntry *obj = frame.peek(-2);
75625:     FrameEntry *id = frame.peek(-1);
75625: 
75625:     // We might not know whether this is an object, but if it is an object we
75625:     // know it is a dense array.
75625:     if (!obj->isTypeKnown()) {
75625:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
75625:         stubcc.linkExit(guard, Uses(2));
75625:     }
75625: 
75625:     // Test for integer index.
75625:     if (!id->isTypeKnown()) {
75625:         Jump guard = frame.testInt32(Assembler::NotEqual, id);
75625:         stubcc.linkExit(guard, Uses(2));
75625:     }
75625: 
75625:     JSValueType type = knownPushedType(0);
75625: 
75625:     // Allocate registers.
75625: 
75625:     RegisterID objReg = frame.tempRegForData(obj);
75625:     frame.pinReg(objReg);
75625: 
75625:     Int32Key key = id->isConstant()
75625:                  ? Int32Key::FromConstant(id->getValue().toInt32())
75625:                  : Int32Key::FromRegister(frame.tempRegForData(id));
75625:     if (!key.isConstant() && !frame.haveSameBacking(id, obj))
75625:         frame.pinReg(key.reg());
75625: 
75625:     RegisterID dataReg = frame.allocReg();
75625: 
75625:     MaybeRegisterID typeReg;
75630:     if (!isPacked || type == JSVAL_TYPE_UNKNOWN || type == JSVAL_TYPE_DOUBLE)
75625:         typeReg = frame.allocReg();
75625: 
75625:     frame.unpinReg(objReg);
75625:     if (!key.isConstant() && !frame.haveSameBacking(id, obj))
75625:         frame.unpinReg(key.reg());
75625: 
75677:     // If we know the result of the GETELEM may be undefined, then misses on the
75677:     // initialized length or hole checks can just produce an undefined value.
75677:     // We checked in the caller that prototypes do not have indexed properties.
75677:     bool allowUndefined = mayPushUndefined(0);
75677: 
75625:     // Guard on the array's initialized length.
75625:     Jump initlenGuard = masm.guardArrayExtent(offsetof(JSObject, initializedLength),
75625:                                               objReg, key, Assembler::BelowOrEqual);
75677:     if (!allowUndefined)
75625:         stubcc.linkExit(initlenGuard, Uses(2));
75625: 
75625:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), dataReg);
75625: 
75625:     // Get the slot, skipping the hole check if the array is known to be packed.
75625:     Jump holeCheck;
75625:     if (key.isConstant()) {
75625:         Address slot(dataReg, key.index() * sizeof(Value));
75625:         holeCheck = masm.fastArrayLoadSlot(slot, !isPacked, typeReg, dataReg);
75625:     } else {
75625:         JS_ASSERT(key.reg() != dataReg);
75625:         BaseIndex slot(dataReg, key.reg(), masm.JSVAL_SCALE);
75625:         holeCheck = masm.fastArrayLoadSlot(slot, !isPacked, typeReg, dataReg);
75625:     }
75625: 
75625:     if (!isPacked) {
75677:         if (!allowUndefined)
75625:             stubcc.linkExit(holeCheck, Uses(2));
75630:         if (type != JSVAL_TYPE_UNKNOWN && type != JSVAL_TYPE_DOUBLE)
75625:             frame.freeReg(typeReg.reg());
75625:     }
75625: 
75625:     stubcc.leave();
75631:     OOL_STUBCALL(stubs::GetElem);
75625: 
75625:     frame.popn(2);
75625: 
75630:     if (type == JSVAL_TYPE_UNKNOWN || type == JSVAL_TYPE_DOUBLE)
75790:         frame.pushRegs(typeReg.reg(), dataReg, type);
75630:     else
75790:         frame.pushTypedPayload(type, dataReg);
75625: 
75625:     stubcc.rejoin(Changes(2));
75677: 
75677:     if (allowUndefined) {
75677:         stubcc.linkExitDirect(initlenGuard, stubcc.masm.label());
75677:         if (!isPacked)
75677:             stubcc.linkExitDirect(holeCheck, stubcc.masm.label());
75677:         JS_ASSERT(type == JSVAL_TYPE_UNKNOWN || type == JSVAL_TYPE_UNDEFINED);
75677:         if (type == JSVAL_TYPE_UNDEFINED)
75677:             stubcc.masm.loadValuePayload(UndefinedValue(), dataReg);
75677:         else
75677:             stubcc.masm.loadValueAsComponents(UndefinedValue(), typeReg.reg(), dataReg);
75677:         stubcc.linkRejoin(stubcc.masm.jump());
75677:     }
75817: 
75817:     if (recompiling) {
75817:         OOL_STUBCALL(ic::GetElement);
75817:         stubcc.rejoin(Changes(1));
75817:     }
75625: }
75625: 
56766: bool
57723: mjit::Compiler::jsop_getelem(bool isCall)
56766: {
56766:     FrameEntry *obj = frame.peek(-2);
56766:     FrameEntry *id = frame.peek(-1);
56766: 
56766:     if (!IsCacheableGetElem(obj, id)) {
57723:         if (isCall)
57723:             jsop_callelem_slow();
57723:         else
53137:             jsop_getelem_slow();
56037:         return true;
53137:     }
53137: 
75846:     frame.forgetConstantData(obj);
75846: 
75720:     if (cx->typeInferenceEnabled()) {
75790:         types::TypeSet *types = frame.getTypeSet(obj);
75864:         types::ObjectKind kind = types
75893:             ? types->getKnownObjectKind(cx)
75864:             : types::OBJECT_UNKNOWN;
75625:         if (!isCall && id->mightBeType(JSVAL_TYPE_INT32) &&
75677:             (kind == types::OBJECT_DENSE_ARRAY || kind == types::OBJECT_PACKED_ARRAY) &&
75677:             !arrayPrototypeHasIndexedProperty()) {
75625:             // this is definitely a dense array, generate code directly without
75625:             // using an inline cache.
75625:             jsop_getelem_dense(kind == types::OBJECT_PACKED_ARRAY);
75625:             return true;
75625:         }
75720:     }
75625: 
56738:     GetElementICInfo ic = GetElementICInfo(JSOp(*PC));
56738: 
56738:     // Pin the top of the stack to avoid spills, before allocating registers.
56738:     MaybeRegisterID pinnedIdData = frame.maybePinData(id);
56738:     MaybeRegisterID pinnedIdType = frame.maybePinType(id);
56738: 
56738:     MaybeJump objTypeGuard;
56738:     if (!obj->isTypeKnown()) {
56738:         // Test the type of the object without spilling the payload.
56738:         MaybeRegisterID pinnedObjData = frame.maybePinData(obj);
56738:         Jump guard = frame.testObject(Assembler::NotEqual, obj);
56738:         frame.maybeUnpinReg(pinnedObjData);
56738: 
56738:         // Create a sync path, which we'll rejoin manually later. This is safe
56738:         // as long as the IC does not build a stub; it won't, because |obj|
56738:         // won't be an object. If we extend this IC to support strings, all
56738:         // that needs to change is a little code movement.
56738:         stubcc.linkExit(guard, Uses(2));
56738:         objTypeGuard = stubcc.masm.jump();
53137:     }
53137: 
56738:     // Get a mutable register for the object. This will be the data reg.
56738:     ic.objReg = frame.copyDataIntoReg(obj);
56738: 
57723:     // For potential dense array calls, grab an extra reg to save the
57723:     // outgoing object.
57723:     MaybeRegisterID thisReg;
57723:     if (isCall && id->mightBeType(JSVAL_TYPE_INT32)) {
57723:         thisReg = frame.allocReg();
57723:         masm.move(ic.objReg, thisReg.reg());
57723:     }
57723: 
56738:     // Get a mutable register for pushing the result type. We kill two birds
56738:     // with one stone by making sure, if the key type is not known, to be loaded
56738:     // into this register. In this case it is both an input and an output.
56738:     frame.maybeUnpinReg(pinnedIdType);
56738:     if (id->isConstant() || id->isTypeKnown())
56738:         ic.typeReg = frame.allocReg();
56738:     else
56738:         ic.typeReg = frame.copyTypeIntoReg(id);
56738: 
56738:     // Fill in the id value.
56738:     frame.maybeUnpinReg(pinnedIdData);
56738:     if (id->isConstant()) {
56738:         ic.id = ValueRemat::FromConstant(id->getValue());
53137:     } else {
56738:         RegisterID dataReg = frame.tempRegForData(id);
56738:         if (id->isTypeKnown())
56738:             ic.id = ValueRemat::FromKnownType(id->getKnownType(), dataReg);
56738:         else
56738:             ic.id = ValueRemat::FromRegisters(ic.typeReg, dataReg);
53137:     }
53137: 
60597:     RESERVE_IC_SPACE(masm);
56738:     ic.fastPathStart = masm.label();
56738: 
56738:     // Note: slow path here is safe, since the frame will not be modified.
60597:     RESERVE_OOL_SPACE(stubcc.masm);
56738:     ic.slowPathStart = stubcc.masm.label();
56738:     frame.sync(stubcc.masm, Uses(2));
56738: 
56738:     if (id->mightBeType(JSVAL_TYPE_INT32)) {
56738:         // Always test the type first (see comment in PolyIC.h).
56738:         if (!id->isTypeKnown()) {
56738:             ic.typeGuard = masm.testInt32(Assembler::NotEqual, ic.typeReg);
56738:             stubcc.linkExitDirect(ic.typeGuard.get(), ic.slowPathStart);
56738:         }
56738: 
56738:         // Guard on the clasp.
56738:         ic.claspGuard = masm.testObjClass(Assembler::NotEqual, ic.objReg, &js_ArrayClass);
56738:         stubcc.linkExitDirect(ic.claspGuard, ic.slowPathStart);
56738: 
56738:         Int32Key key = id->isConstant()
56738:                        ? Int32Key::FromConstant(id->getValue().toInt32())
56738:                        : Int32Key::FromRegister(ic.id.dataReg());
56738: 
56738:         Assembler::FastArrayLoadFails fails =
56738:             masm.fastArrayLoad(ic.objReg, key, ic.typeReg, ic.objReg);
56738: 
57723:         // Store the object back to sp[-1] for calls. This must occur after
57723:         // all guards because otherwise sp[-1] will be clobbered.
57723:         if (isCall) {
57723:             Address thisSlot = frame.addressOf(id);
57723:             masm.storeValueFromComponents(ImmType(JSVAL_TYPE_OBJECT), thisReg.reg(), thisSlot);
57723:             frame.freeReg(thisReg.reg());
57723:         }
57723: 
56738:         stubcc.linkExitDirect(fails.rangeCheck, ic.slowPathStart);
56738:         stubcc.linkExitDirect(fails.holeCheck, ic.slowPathStart);
56738:     } else {
56738:         // The type is known to not be dense-friendly ahead of time, so always
56738:         // fall back to a slow path.
56738:         ic.claspGuard = masm.jump();
56738:         stubcc.linkExitDirect(ic.claspGuard, ic.slowPathStart);
56738:     }
56738: 
56738:     stubcc.leave();
56738:     if (objTypeGuard.isSet())
56738:         objTypeGuard.get().linkTo(stubcc.masm.label(), &stubcc.masm);
60598: #ifdef JS_POLYIC
56738:     passICAddress(&ic);
57723:     if (isCall)
57766:         ic.slowPathCall = OOL_STUBCALL(ic::CallElement);
57723:     else
57766:         ic.slowPathCall = OOL_STUBCALL(ic::GetElement);
56738: #else
57723:     if (isCall)
57766:         ic.slowPathCall = OOL_STUBCALL(stubs::CallElem);
57723:     else
57766:         ic.slowPathCall = OOL_STUBCALL(stubs::GetElem);
56738: #endif
56738: 
56738:     ic.fastPathRejoin = masm.label();
56738: 
56738:     frame.popn(2);
75790:     frame.pushRegs(ic.typeReg, ic.objReg, knownPushedType(0));
57723:     if (isCall)
75630:         frame.pushSynced(knownPushedType(1));
56738: 
56738:     stubcc.rejoin(Changes(2));
53137: 
60598: #ifdef JS_POLYIC
56738:     if (!getElemICs.append(ic))
56738:         return false;
75779: 
75779:     if (recompiling) {
75779:         OOL_STUBCALL(isCall ? stubs::CallElem : stubs::GetElem);
75779:         stubcc.rejoin(Changes(2));
75779:     }
56738: #endif
56738: 
56735:     return true;
53137: }
52843: 
52855: static inline bool
53025: ReallySimpleStrictTest(FrameEntry *fe)
52855: {
52855:     if (!fe->isTypeKnown())
52855:         return false;
53025:     JSValueType type = fe->getKnownType();
53025:     return type == JSVAL_TYPE_NULL || type == JSVAL_TYPE_UNDEFINED;
52855: }
52855: 
52856: static inline bool
52856: BooleanStrictTest(FrameEntry *fe)
52856: {
53025:     return fe->isConstant() && fe->getKnownType() == JSVAL_TYPE_BOOLEAN;
52856: }
52856: 
52855: void
52855: mjit::Compiler::jsop_stricteq(JSOp op)
52855: {
52855:     FrameEntry *rhs = frame.peek(-1);
52855:     FrameEntry *lhs = frame.peek(-2);
52855: 
52855:     Assembler::Condition cond = (op == JSOP_STRICTEQ) ? Assembler::Equal : Assembler::NotEqual;
52855: 
53513:     /*
53513:      * NB: x64 can do full-Value comparisons. This is beneficial
53513:      * to do if the payload/type are not yet in registers.
53513:      */
53513: 
53513:     /* Constant-fold. */
53513:     if (lhs->isConstant() && rhs->isConstant()) {
59890:         JSBool b;
59890:         StrictlyEqual(cx, lhs->getValue(), rhs->getValue(), &b);
53513:         frame.popn(2);
53513:         frame.push(BooleanValue((op == JSOP_STRICTEQ) ? b : !b));
53513:         return;
53513:     }
53513: 
53513:     if (frame.haveSameBacking(lhs, rhs)) {
75666:         RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
75666: 
53513:         /* False iff NaN. */
53513:         if (lhs->isTypeKnown() && lhs->isNotType(JSVAL_TYPE_DOUBLE)) {
53513:             frame.popn(2);
75666: 
75666:             masm.move(Imm32(op == JSOP_STRICTEQ), result);
75666:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
62019:             return;
62019:         }
62019: 
75738:         if (lhs->isType(JSVAL_TYPE_DOUBLE)) {
75738:             FPRegisterID reg = frame.tempFPRegForData(lhs);
75738: 
75738:             bool equalValue = (op == JSOP_STRICTEQ);
75738:             masm.move(Imm32(equalValue), result);
75738:             Jump j = masm.branchDouble(Assembler::DoubleEqual, reg, reg);
75738:             masm.move(Imm32(!equalValue), result);
75738:             j.linkTo(masm.label(), &masm);
75738: 
75738:             frame.popn(2);
75738:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
53513:             return;
53513:         }
53513: 
53521:         /* Assume NaN is in canonical form. */
53521:         RegisterID treg = frame.tempRegForType(lhs);
53521: 
53521:         Assembler::Condition oppositeCond = (op == JSOP_STRICTEQ) ? Assembler::NotEqual : Assembler::Equal;
53521: 
53521: #if defined JS_CPU_X86 || defined JS_CPU_ARM
53521:         static const int CanonicalNaNType = 0x7FF80000;
53521:         masm.setPtr(oppositeCond, treg, Imm32(CanonicalNaNType), result);
53521: #elif defined JS_CPU_X64
53521:         static const void *CanonicalNaNType = (void *)0x7FF8000000000000; 
53521:         masm.move(ImmPtr(CanonicalNaNType), JSC::X86Registers::r11);
53521:         masm.setPtr(oppositeCond, treg, JSC::X86Registers::r11, result);
53521: #endif
53521: 
53521:         frame.popn(2);
53521:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
53521:         return;
53513:     }
53513: 
52855:     /* Comparison against undefined or null is super easy. */
52855:     bool lhsTest;
53025:     if ((lhsTest = ReallySimpleStrictTest(lhs)) || ReallySimpleStrictTest(rhs)) {
52855:         FrameEntry *test = lhsTest ? rhs : lhs;
53513:         FrameEntry *known = lhsTest ? lhs : rhs;
75666:         RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
52855: 
52855:         if (test->isTypeKnown()) {
52855:             frame.popn(2);
75666: 
75666:             masm.move(Imm32((test->getKnownType() == known->getKnownType()) ==
75666:                             (op == JSOP_STRICTEQ)), result);
75666:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52855:             return;
52855:         }
52855: 
52855:         /* This is only true if the other side is |null|. */
53215: #if defined JS_CPU_X86 || defined JS_CPU_ARM
53162:         JSValueTag mask = known->getKnownTag();
52855:         if (frame.shouldAvoidTypeRemat(test))
52856:             masm.set32(cond, masm.tagOf(frame.addressOf(test)), Imm32(mask), result);
52855:         else
52855:             masm.set32(cond, frame.tempRegForType(test), Imm32(mask), result);
53162: #elif defined JS_CPU_X64
53162:         RegisterID maskReg = frame.allocReg();
56004:         masm.move(ImmTag(known->getKnownTag()), maskReg);
55742: 
53162:         RegisterID r = frame.tempRegForType(test);
53162:         masm.setPtr(cond, r, maskReg, result);
55514: 
53162:         frame.freeReg(maskReg);
53162: #endif
52855:         frame.popn(2);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52855:         return;
52855:     }
52855: 
52856:     /* Hardcoded booleans are easy too. */
52856:     if ((lhsTest = BooleanStrictTest(lhs)) || BooleanStrictTest(rhs)) {
52856:         FrameEntry *test = lhsTest ? rhs : lhs;
52856: 
53513:         if (test->isTypeKnown() && test->isNotType(JSVAL_TYPE_BOOLEAN)) {
75666:             RegisterID result = frame.allocReg(Registers::SingleByteRegs).reg();
52856:             frame.popn(2);
75666: 
75666:             masm.move(Imm32(op == JSOP_STRICTNE), result);
75666:             frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52856:             return;
52856:         }
52856: 
52856:         if (test->isConstant()) {
52856:             frame.popn(2);
52856:             const Value &L = lhs->getValue();
52856:             const Value &R = rhs->getValue();
53081:             frame.push(BooleanValue((L.toBoolean() == R.toBoolean()) == (op == JSOP_STRICTEQ)));
52856:             return;
52856:         }
52856: 
58289:         RegisterID data = frame.copyDataIntoReg(test);
52856: 
58289:         RegisterID result = data;
58289:         if (!(Registers::maskReg(data) & Registers::SingleByteRegs))
75647:             result = frame.allocReg(Registers::SingleByteRegs).reg();
58289:         
52856:         Jump notBoolean;
52856:         if (!test->isTypeKnown())
52856:            notBoolean = frame.testBoolean(Assembler::NotEqual, test);
52856: 
52856:         /* Do a dynamic test. */
53081:         bool val = lhsTest ? lhs->getValue().toBoolean() : rhs->getValue().toBoolean();
57781:         masm.set32(cond, data, Imm32(val), result);
52856: 
52856:         if (!test->isTypeKnown()) {
52856:             Jump done = masm.jump();
52856:             notBoolean.linkTo(masm.label(), &masm);
52856:             masm.move(Imm32((op == JSOP_STRICTNE)), result);
52856:             done.linkTo(masm.label(), &masm);
52856:         }
52856: 
58289:         if (data != result)
58289:             frame.freeReg(data);
58289: 
52856:         frame.popn(2);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, result);
52856:         return;
52856:     }
52856: 
53513:     /* Is it impossible that both Values are ints? */
53513:     if ((lhs->isTypeKnown() && lhs->isNotType(JSVAL_TYPE_INT32)) ||
53513:         (rhs->isTypeKnown() && rhs->isNotType(JSVAL_TYPE_INT32))) {
53087:         prepareStubCall(Uses(2));
53513: 
52855:         if (op == JSOP_STRICTEQ)
57766:             INLINE_STUBCALL(stubs::StrictEq);
52855:         else
57766:             INLINE_STUBCALL(stubs::StrictNe);
53513: 
52855:         frame.popn(2);
75630:         frame.pushSynced(JSVAL_TYPE_BOOLEAN);
53513:         return;
53513:     }
53513: 
53513: #ifndef JS_CPU_ARM
53513:     /* Try an integer fast-path. */
53513:     bool needStub = false;
53513:     if (!lhs->isTypeKnown()) {
53513:         Jump j = frame.testInt32(Assembler::NotEqual, lhs);
53513:         stubcc.linkExit(j, Uses(2));
53513:         needStub = true;
53513:     }
53513: 
53513:     if (!rhs->isTypeKnown() && !frame.haveSameBacking(lhs, rhs)) {
53513:         Jump j = frame.testInt32(Assembler::NotEqual, rhs);
53513:         stubcc.linkExit(j, Uses(2));
53513:         needStub = true;
53513:     }
53513: 
53513:     FrameEntry *test  = lhs->isConstant() ? rhs : lhs;
53513:     FrameEntry *other = lhs->isConstant() ? lhs : rhs;
53513: 
53513:     /* ReturnReg is safely usable with set32, since %ah can be accessed. */
53513:     RegisterID resultReg = Registers::ReturnReg;
53513:     frame.takeReg(resultReg);
53513:     RegisterID testReg = frame.tempRegForData(test);
53513:     frame.pinReg(testReg);
53513: 
53513:     JS_ASSERT(resultReg != testReg);
53513: 
53513:     /* Set boolean in resultReg. */
53513:     if (other->isConstant()) {
53513:         masm.set32(cond, testReg, Imm32(other->getValue().toInt32()), resultReg);
53513:     } else if (frame.shouldAvoidDataRemat(other)) {
53513:         masm.set32(cond, testReg, frame.addressOf(other), resultReg);
53513:     } else {
53513:         RegisterID otherReg = frame.tempRegForData(other);
53513: 
53513:         JS_ASSERT(otherReg != resultReg);
53513:         JS_ASSERT(otherReg != testReg);
53513: 
53513:         masm.set32(cond, testReg, otherReg, resultReg);
53513:     }
53513: 
53513:     frame.unpinReg(testReg);
53513: 
53513:     if (needStub) {
53513:         stubcc.leave();
53513:         if (op == JSOP_STRICTEQ)
57766:             OOL_STUBCALL(stubs::StrictEq);
53513:         else
57766:             OOL_STUBCALL(stubs::StrictNe);
53513:     }
53513: 
53513:     frame.popn(2);
53513:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, resultReg);
53513: 
53513:     if (needStub)
53513:         stubcc.rejoin(Changes(1));
53513: #else
53513:     /* TODO: Port set32() logic to ARM. */
53513:     prepareStubCall(Uses(2));
53513: 
53513:     if (op == JSOP_STRICTEQ)
57766:         INLINE_STUBCALL(stubs::StrictEq);
53513:     else
57766:         INLINE_STUBCALL(stubs::StrictNe);
53513: 
53513:     frame.popn(2);
53513:     frame.pushSyncedType(JSVAL_TYPE_BOOLEAN);
53513:     return;
53513: #endif
52855: }
52855: 
52916: void
52916: mjit::Compiler::jsop_pos()
52916: {
52916:     FrameEntry *top = frame.peek(-1);
52916: 
52916:     if (top->isTypeKnown()) {
53025:         if (top->getKnownType() <= JSVAL_TYPE_INT32)
52916:             return;
53087:         prepareStubCall(Uses(1));
57766:         INLINE_STUBCALL(stubs::Pos);
52916:         frame.pop();
75630:         frame.pushSynced(knownPushedType(0));
52916:         return;
52916:     }
52916: 
53052:     frame.giveOwnRegs(top);
53052: 
52916:     Jump j;
52916:     if (frame.shouldAvoidTypeRemat(top))
53052:         j = masm.testNumber(Assembler::NotEqual, frame.addressOf(top));
52916:     else
53052:         j = masm.testNumber(Assembler::NotEqual, frame.tempRegForType(top));
53088:     stubcc.linkExit(j, Uses(1));
52916: 
52916:     stubcc.leave();
57766:     OOL_STUBCALL(stubs::Pos);
52916: 
53088:     stubcc.rejoin(Changes(1));
52916: }
52916: 
58056: void
58056: mjit::Compiler::jsop_initmethod()
58056: {
58061: #ifdef DEBUG
58056:     FrameEntry *obj = frame.peek(-2);
58061: #endif
58056:     JSAtom *atom = script->getAtom(fullAtomIndex(PC));
58056: 
58056:     /* Initializers with INITMETHOD are not fast yet. */
58056:     JS_ASSERT(!obj->initializerObject());
58056: 
58056:     prepareStubCall(Uses(2));
58056:     masm.move(ImmPtr(atom), Registers::ArgReg1);
58056:     INLINE_STUBCALL(stubs::InitMethod);
58056: }
58056: 
58056: void
58056: mjit::Compiler::jsop_initprop()
58056: {
58056:     FrameEntry *obj = frame.peek(-2);
58056:     FrameEntry *fe = frame.peek(-1);
58056:     JSAtom *atom = script->getAtom(fullAtomIndex(PC));
58056: 
58056:     JSObject *baseobj = obj->initializerObject();
58056: 
75798:     if (!baseobj || monitored(PC)) {
58056:         prepareStubCall(Uses(2));
58056:         masm.move(ImmPtr(atom), Registers::ArgReg1);
58056:         INLINE_STUBCALL(stubs::InitProp);
58056:         return;
58056:     }
58056: 
58056:     JSObject *holder;
58056:     JSProperty *prop = NULL;
58056: #ifdef DEBUG
58056:     int res =
58056: #endif
58056:     js_LookupPropertyWithFlags(cx, baseobj, ATOM_TO_JSID(atom),
58056:                                JSRESOLVE_QUALIFIED, &holder, &prop);
58056:     JS_ASSERT(res >= 0 && prop && holder == baseobj);
58056: 
58056:     RegisterID objReg = frame.copyDataIntoReg(obj);
58056:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
58056: 
58056:     /* Perform the store. */
58056:     Shape *shape = (Shape *) prop;
58056:     frame.storeTo(fe, Address(objReg, shape->slot * sizeof(Value)));
58056:     frame.freeReg(objReg);
58056: }
58056: 
58056: void
58056: mjit::Compiler::jsop_initelem()
58056: {
58056:     FrameEntry *obj = frame.peek(-3);
58056:     FrameEntry *id = frame.peek(-2);
58056:     FrameEntry *fe = frame.peek(-1);
58056: 
58056:     /*
58056:      * The initialized index is always a constant, but we won't remember which
58056:      * constant if there are branches inside the code computing the initializer
58056:      * expression (e.g. the expression uses the '?' operator).  Slow path those
58056:      * cases, as well as those where INITELEM is used on an object initializer
58056:      * or a non-fast array initializer.
58056:      */
58056:     if (!id->isConstant() || !obj->initializerArray()) {
58056:         JSOp next = JSOp(PC[JSOP_INITELEM_LENGTH]);
58056: 
58056:         prepareStubCall(Uses(3));
58056:         masm.move(Imm32(next == JSOP_ENDINIT ? 1 : 0), Registers::ArgReg1);
58056:         INLINE_STUBCALL(stubs::InitElem);
58056:         return;
58056:     }
58056: 
75639:     int32 idx = id->getValue().toInt32();
58056: 
58056:     RegisterID objReg = frame.copyDataIntoReg(obj);
75639: 
75639:     /* Update the initialized length. */
75639:     masm.store32(Imm32(idx + 1), Address(objReg, offsetof(JSObject, initializedLength)));
58056: 
58056:     /* Perform the store. */
75639:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
75639:     frame.storeTo(fe, Address(objReg, idx * sizeof(Value)));
58056:     frame.freeReg(objReg);
58056: }
