74209: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
74209:  * vim: sw=2 ts=2 et lcs=trail\:.,tab\:>~ :
74209:  * ***** BEGIN LICENSE BLOCK *****
74209:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
74209:  *
74209:  * The contents of this file are subject to the Mozilla Public License Version
74209:  * 1.1 (the "License"); you may not use this file except in compliance with
74209:  * the License. You may obtain a copy of the License at
74209:  * http://www.mozilla.org/MPL/
74209:  *
74209:  * Software distributed under the License is distributed on an "AS IS" basis,
74209:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
74209:  * for the specific language governing rights and limitations under the
74209:  * License.
74209:  *
74209:  * The Original Code is Oracle Corporation code.
74209:  *
74209:  * The Initial Developer of the Original Code is
74209:  *  Oracle Corporation
74209:  * Portions created by the Initial Developer are Copyright (C) 2011
74209:  * the Initial Developer. All Rights Reserved.
74209:  *
74209:  * Contributor(s):
74209:  *   Taras Glek <tglek@mozilla.com>
74209:  *
74209:  * Alternatively, the contents of this file may be used under the terms of
74209:  * either the GNU General Public License Version 2 or later (the "GPL"), or
74209:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
74209:  * in which case the provisions of the GPL or the LGPL are applicable instead
74209:  * of those above. If you wish to allow use of your version of this file only
74209:  * under the terms of either the GPL or the LGPL, and not to allow others to
74209:  * use your version of this file under the terms of the MPL, indicate your
74209:  * decision by deleting the provisions above and replace them with the notice
74209:  * and other provisions required by the GPL or the LGPL. If you do not delete
74209:  * the provisions above, a recipient may use your version of this file under
74209:  * the terms of any one of the MPL, the GPL or the LGPL.
74209:  *
74209:  * ***** END LICENSE BLOCK ***** */
74209: 
74419: #include <string.h>
74209: #include "mozilla/Telemetry.h"
74209: #include "sqlite3.h"
74419: #include "nsThreadUtils.h"
77255: #include "mozilla/Util.h"
74209: 
74209: namespace {
74209: 
74209: using namespace mozilla;
74209: 
74209: struct Histograms {
74209:   const char *name;
74830:   const Telemetry::ID readB;
74830:   const Telemetry::ID writeB;
74830:   const Telemetry::ID readMS;
74830:   const Telemetry::ID writeMS;
74830:   const Telemetry::ID syncMS;
74209: };
74209: 
74830: #define SQLITE_TELEMETRY(FILENAME, HGRAM) \
74830:   { FILENAME, \
74830:     Telemetry::MOZ_SQLITE_ ## HGRAM ## _READ_B, \
74830:     Telemetry::MOZ_SQLITE_ ## HGRAM ## _WRITE_B, \
74830:     Telemetry::MOZ_SQLITE_ ## HGRAM ## _READ_MS, \
74830:     Telemetry::MOZ_SQLITE_ ## HGRAM ## _WRITE_MS, \
74830:     Telemetry::MOZ_SQLITE_ ## HGRAM ## _SYNC_MS \
74830:   }
74830: 
74209: Histograms gHistograms[] = {
74830:   SQLITE_TELEMETRY("places.sqlite", PLACES),
74830:   SQLITE_TELEMETRY("urlclassifier3.sqlite", URLCLASSIFIER),
74830:   SQLITE_TELEMETRY("cookies.sqlite", COOKIES),
82143:   SQLITE_TELEMETRY("webappsstore.sqlite", WEBAPPS),
74830:   SQLITE_TELEMETRY(NULL, OTHER)
74830: };
74830: #undef SQLITE_TELEMETRY
74209: 
74830: /** RAII class for measuring how long io takes on/off main thread
74830:  */
74419: class IOThreadAutoTimer {
74419: public:
74830:   /** 
74830:    * IOThreadAutoTimer measures time spent in IO. Additionally it
74830:    * automatically determines whether IO is happening on the main
74830:    * thread and picks an appropriate histogram.
74830:    *
74830:    * @param id takes a telemetry histogram id. The id+1 must be an
74830:    * equivalent histogram for the main thread. Eg, MOZ_SQLITE_OPEN_MS 
74830:    * is followed by MOZ_SQLITE_OPEN_MAIN_THREAD_MS.
74830:    */
74830:   IOThreadAutoTimer(Telemetry::ID id)
74830:     : start(TimeStamp::Now()),
74830:       id(id)
74419:   {
74419:   }
74419: 
74419:   ~IOThreadAutoTimer() {
74830:     PRUint32 mainThread = NS_IsMainThread() ? 1 : 0;
80425:     Telemetry::AccumulateTimeDelta(static_cast<Telemetry::ID>(id + mainThread),
80425:                                    start);
74419:   }
74419: 
74419: private:
74419:   const TimeStamp start;
74830:   const Telemetry::ID id;
74419: };
74419: 
74209: struct telemetry_file {
74209:   sqlite3_file base;        // Base class.  Must be first
74209:   Histograms *histograms;   // histograms pertaining to this file
74209:   sqlite3_file pReal[1];    // This contains the vfs that actually does work
74209: };
74209: 
74209: /*
74209: ** Close a telemetry_file.
74209: */
74209: int
74209: xClose(sqlite3_file *pFile)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xClose(p->pReal);
74209:   if( rc==SQLITE_OK ){
74209:     delete p->base.pMethods;
74209:     p->base.pMethods = NULL;
74209:   }
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Read data from a telemetry_file.
74209: */
74209: int
74209: xRead(sqlite3_file *pFile, void *zBuf, int iAmt, sqlite_int64 iOfst)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74830:   IOThreadAutoTimer ioTimer(p->histograms->readMS);
74209:   int rc;
74209:   rc = p->pReal->pMethods->xRead(p->pReal, zBuf, iAmt, iOfst);
74209:   // sqlite likes to read from empty files, this is normal, ignore it.
74209:   if (rc != SQLITE_IOERR_SHORT_READ)
74209:     Telemetry::Accumulate(p->histograms->readB, rc == SQLITE_OK ? iAmt : 0);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Write data to a telemetry_file.
74209: */
74209: int
74209: xWrite(sqlite3_file *pFile, const void *zBuf, int iAmt, sqlite_int64 iOfst)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74830:   IOThreadAutoTimer ioTimer(p->histograms->writeMS);
74209:   int rc;
74209:   rc = p->pReal->pMethods->xWrite(p->pReal, zBuf, iAmt, iOfst);
74209:   Telemetry::Accumulate(p->histograms->writeB, rc == SQLITE_OK ? iAmt : 0);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Truncate a telemetry_file.
74209: */
74209: int
74209: xTruncate(sqlite3_file *pFile, sqlite_int64 size)
74209: {
74830:   IOThreadAutoTimer ioTimer(Telemetry::MOZ_SQLITE_TRUNCATE_MS);
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74830:   Telemetry::AutoTimer<Telemetry::MOZ_SQLITE_TRUNCATE_MS> timer;
74209:   rc = p->pReal->pMethods->xTruncate(p->pReal, size);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Sync a telemetry_file.
74209: */
74209: int
74209: xSync(sqlite3_file *pFile, int flags)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74830:   IOThreadAutoTimer ioTimer(p->histograms->syncMS);
74830:   return p->pReal->pMethods->xSync(p->pReal, flags);
74209: }
74209: 
74209: /*
74209: ** Return the current file-size of a telemetry_file.
74209: */
74209: int
74209: xFileSize(sqlite3_file *pFile, sqlite_int64 *pSize)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xFileSize(p->pReal, pSize);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Lock a telemetry_file.
74209: */
74209: int
74209: xLock(sqlite3_file *pFile, int eLock)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xLock(p->pReal, eLock);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Unlock a telemetry_file.
74209: */
74209: int
74209: xUnlock(sqlite3_file *pFile, int eLock)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xUnlock(p->pReal, eLock);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Check if another file-handle holds a RESERVED lock on a telemetry_file.
74209: */
74209: int
74209: xCheckReservedLock(sqlite3_file *pFile, int *pResOut)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc = p->pReal->pMethods->xCheckReservedLock(p->pReal, pResOut);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** File control method. For custom operations on a telemetry_file.
74209: */
74209: int
74209: xFileControl(sqlite3_file *pFile, int op, void *pArg)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc = p->pReal->pMethods->xFileControl(p->pReal, op, pArg);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Return the sector-size in bytes for a telemetry_file.
74209: */
74209: int
74209: xSectorSize(sqlite3_file *pFile)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xSectorSize(p->pReal);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Return the device characteristic flags supported by a telemetry_file.
74209: */
74209: int
74209: xDeviceCharacteristics(sqlite3_file *pFile)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xDeviceCharacteristics(p->pReal);
74209:   return rc;
74209: }
74209: 
74209: /*
74209: ** Shared-memory operations.
74209: */
74209: int
74209: xShmLock(sqlite3_file *pFile, int ofst, int n, int flags)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   return p->pReal->pMethods->xShmLock(p->pReal, ofst, n, flags);
74209: }
74209: 
74209: int
74209: xShmMap(sqlite3_file *pFile, int iRegion, int szRegion, int isWrite, void volatile **pp)
74209: {
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xShmMap(p->pReal, iRegion, szRegion, isWrite, pp);
74209:   return rc;
74209: }
74209: 
74209: void
74209: xShmBarrier(sqlite3_file *pFile){
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   p->pReal->pMethods->xShmBarrier(p->pReal);
74209: }
74209: 
74209: int
74209: xShmUnmap(sqlite3_file *pFile, int delFlag){
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   int rc;
74209:   rc = p->pReal->pMethods->xShmUnmap(p->pReal, delFlag);
74209:   return rc;
74209: }
74209:  
74209: int
74209: xOpen(sqlite3_vfs* vfs, const char *zName, sqlite3_file* pFile,
74209:           int flags, int *pOutFlags)
74209: {
74830:   IOThreadAutoTimer ioTimer(Telemetry::MOZ_SQLITE_OPEN_MS);
74830:   Telemetry::AutoTimer<Telemetry::MOZ_SQLITE_OPEN_MS> timer;
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   int rc;
74209:   telemetry_file *p = (telemetry_file *)pFile;
74209:   Histograms *h = NULL;
74209:   // check if the filename is one we are probing for
74209:   for(size_t i = 0;i < sizeof(gHistograms)/sizeof(gHistograms[0]);i++) {
74209:     h = &gHistograms[i];
74209:     // last probe is the fallback probe
74209:     if (!h->name)
74209:       break;
74209:     if (!zName)
74209:       continue;
74209:     const char *match = strstr(zName, h->name);
74209:     if (!match)
74209:       continue;
74209:     char c = match[strlen(h->name)];
74209:     // include -wal/-journal too
74209:     if (!c || c == '-')
74209:       break;
74209:   }
74209:   p->histograms = h;
74209:   rc = orig_vfs->xOpen(orig_vfs, zName, p->pReal, flags, pOutFlags);
88712:   if( rc != SQLITE_OK )
88712:     return rc;
74209:   if( p->pReal->pMethods ){
74209:     sqlite3_io_methods *pNew = new sqlite3_io_methods;
74209:     const sqlite3_io_methods *pSub = p->pReal->pMethods;
74209:     memset(pNew, 0, sizeof(*pNew));
74209:     pNew->iVersion = pSub->iVersion;
74209:     pNew->xClose = xClose;
74209:     pNew->xRead = xRead;
74209:     pNew->xWrite = xWrite;
74209:     pNew->xTruncate = xTruncate;
74209:     pNew->xSync = xSync;
74209:     pNew->xFileSize = xFileSize;
74209:     pNew->xLock = xLock;
74209:     pNew->xUnlock = xUnlock;
74209:     pNew->xCheckReservedLock = xCheckReservedLock;
74209:     pNew->xFileControl = xFileControl;
74209:     pNew->xSectorSize = xSectorSize;
74209:     pNew->xDeviceCharacteristics = xDeviceCharacteristics;
74209:     if( pNew->iVersion>=2 ){
74209:       pNew->xShmMap = pSub->xShmMap ? xShmMap : 0;
74209:       pNew->xShmLock = pSub->xShmLock ? xShmLock : 0;
74209:       pNew->xShmBarrier = pSub->xShmBarrier ? xShmBarrier : 0;
74209:       pNew->xShmUnmap = pSub->xShmUnmap ? xShmUnmap : 0;
74209:     }
74209:     pFile->pMethods = pNew;
74209:   }
74209:   return rc;
74209: }
74209: 
74209: int
74209: xDelete(sqlite3_vfs* vfs, const char *zName, int syncDir)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xDelete(orig_vfs, zName, syncDir);
74209: }
74209: 
74209: int
74209: xAccess(sqlite3_vfs *vfs, const char *zName, int flags, int *pResOut)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xAccess(orig_vfs, zName, flags, pResOut);
74209: }
74209: 
74209: int
74209: xFullPathname(sqlite3_vfs *vfs, const char *zName, int nOut, char *zOut)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xFullPathname(orig_vfs, zName, nOut, zOut);
74209: }
74209: 
74209: void*
74209: xDlOpen(sqlite3_vfs *vfs, const char *zFilename)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xDlOpen(orig_vfs, zFilename);
74209: }
74209: 
74209: void
74209: xDlError(sqlite3_vfs *vfs, int nByte, char *zErrMsg)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   orig_vfs->xDlError(orig_vfs, nByte, zErrMsg);
74209: }
74209: 
74209: void 
74209: (*xDlSym(sqlite3_vfs *vfs, void *pHdle, const char *zSym))(void){
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xDlSym(orig_vfs, pHdle, zSym);
74209: }
74209: 
74209: void
74209: xDlClose(sqlite3_vfs *vfs, void *pHandle)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   orig_vfs->xDlClose(orig_vfs, pHandle);
74209: }
74209: 
74209: int
74209: xRandomness(sqlite3_vfs *vfs, int nByte, char *zOut)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xRandomness(orig_vfs, nByte, zOut);
74209: }
74209: 
74209: int
74209: xSleep(sqlite3_vfs *vfs, int microseconds)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xSleep(orig_vfs, microseconds);
74209: }
74209: 
74209: int
74209: xCurrentTime(sqlite3_vfs *vfs, double *prNow)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xCurrentTime(orig_vfs, prNow);
74209: }
74209: 
74209: int
74209: xGetLastError(sqlite3_vfs *vfs, int nBuf, char *zBuf)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xGetLastError(orig_vfs, nBuf, zBuf);
74209: }
74209: 
74209: int
74209: xCurrentTimeInt64(sqlite3_vfs *vfs, sqlite3_int64 *piNow)
74209: {
74209:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
74209:   return orig_vfs->xCurrentTimeInt64(orig_vfs, piNow);
74209: }
74209: 
77255: static
77255: int
77255: xSetSystemCall(sqlite3_vfs *vfs, const char *zName, sqlite3_syscall_ptr pFunc)
77255: {
77255:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
77255:   return orig_vfs->xSetSystemCall(orig_vfs, zName, pFunc);
77255: }
77255: 
77255: static
77255: sqlite3_syscall_ptr
77255: xGetSystemCall(sqlite3_vfs *vfs, const char *zName)
77255: {
77255:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
77255:   return orig_vfs->xGetSystemCall(orig_vfs, zName);
77255: }
77255: 
77255: static
77255: const char *
77255: xNextSystemCall(sqlite3_vfs *vfs, const char *zName)
77255: {
77255:   sqlite3_vfs *orig_vfs = static_cast<sqlite3_vfs*>(vfs->pAppData);
77255:   return orig_vfs->xNextSystemCall(orig_vfs, zName);
77255: }
77255: 
74209: }
74209: 
74209: namespace mozilla {
74209: namespace storage {
74209: 
74209: sqlite3_vfs* ConstructTelemetryVFS()
74209: {
74209: #if defined(XP_WIN)
74209: #define EXPECTED_VFS "win32"
74209: #else
74209: #define EXPECTED_VFS "unix"
74209: #endif
74209: 
74209:   sqlite3_vfs *vfs = sqlite3_vfs_find(NULL);
74209:   const bool expected_vfs = vfs->zName && !strcmp(vfs->zName, EXPECTED_VFS);
74209:   if (!expected_vfs) {
74209:     return NULL;
74209:   }
74209: 
74209:   sqlite3_vfs *tvfs = new ::sqlite3_vfs;
74209:   memset(tvfs, 0, sizeof(::sqlite3_vfs));
77255:   tvfs->iVersion = 3;
77255:   // If the SQLite VFS version is updated, this shim must be updated as well.
77255:   MOZ_ASSERT(vfs->iVersion == tvfs->iVersion);
74209:   tvfs->szOsFile = sizeof(telemetry_file) - sizeof(sqlite3_file) + vfs->szOsFile;
74209:   tvfs->mxPathname = vfs->mxPathname;
74209:   tvfs->zName = "telemetry-vfs";
74209:   tvfs->pAppData = vfs;
74209:   tvfs->xOpen = xOpen;
74209:   tvfs->xDelete = xDelete;
74209:   tvfs->xAccess = xAccess;
74209:   tvfs->xFullPathname = xFullPathname;
74209:   tvfs->xDlOpen = xDlOpen;
74209:   tvfs->xDlError = xDlError;
74209:   tvfs->xDlSym = xDlSym;
74209:   tvfs->xDlClose = xDlClose;
74209:   tvfs->xRandomness = xRandomness;
74209:   tvfs->xSleep = xSleep;
74209:   tvfs->xCurrentTime = xCurrentTime;
74209:   tvfs->xGetLastError = xGetLastError;
77255:   // Added in version 2.
74209:   tvfs->xCurrentTimeInt64 = xCurrentTimeInt64;
77255:   // Added in version 3.
77255:   tvfs->xSetSystemCall = xSetSystemCall;
77255:   tvfs->xGetSystemCall = xGetSystemCall;
77255:   tvfs->xNextSystemCall = xNextSystemCall;
77255: 
74209:   return tvfs;
74209: }
74209: 
74209: }
74209: }
