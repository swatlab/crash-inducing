     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsAccessNodeWrap.h"
 41384: 
 41384: #include "AccessibleApplication.h"
 96920: #include "ApplicationAccessibleWrap.h"
     1: #include "ISimpleDOMNode_i.c"
 41384: 
 83479: #include "Compatibility.h"
 41384: #include "nsAccessibilityService.h"
106800: #include "nsAccUtils.h"
 41384: #include "nsCoreUtils.h"
 54220: #include "nsWinUtils.h"
 97643: #include "RootAccessible.h"
 79538: #include "Statistics.h"
 41384: 
  2074: #include "nsAttrName.h"
     1: #include "nsIDOMNodeList.h"
 81041: #include "nsIDOMHTMLElement.h"
     1: #include "nsIFrame.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIServiceManager.h"
     1: 
 71199: using namespace mozilla;
 79538: using namespace mozilla::a11y;
 71199: 
 51377: AccTextChangeEvent* nsAccessNodeWrap::gTextEvent = nsnull;
  1392: 
 43504: ////////////////////////////////////////////////////////////////////////////////
 43504: // nsAccessNodeWrap
 43504: ////////////////////////////////////////////////////////////////////////////////
     1: 
 43504: nsAccessNodeWrap::
 99568:   nsAccessNodeWrap(nsIContent* aContent, DocAccessible* aDoc) :
 89799:   nsAccessNode(aContent, aDoc)
     1: {
     1: }
     1: 
     1: nsAccessNodeWrap::~nsAccessNodeWrap()
     1: {
     1: }
     1: 
   966: //-----------------------------------------------------
   966: // nsISupports methods
   966: //-----------------------------------------------------
   966: 
   966: NS_IMPL_ISUPPORTS_INHERITED1(nsAccessNodeWrap, nsAccessNode, nsIWinAccessNode);
   966: 
   966: //-----------------------------------------------------
   966: // nsIWinAccessNode methods
   966: //-----------------------------------------------------
   966: 
   966: NS_IMETHODIMP
   966: nsAccessNodeWrap::QueryNativeInterface(REFIID aIID, void** aInstancePtr)
   966: {
  1000:   return QueryInterface(aIID, aInstancePtr);
   966: }
     1: 
     1: //-----------------------------------------------------
     1: // IUnknown interface methods - see iunknown.h for documentation
     1: //-----------------------------------------------------
     1: 
     1: STDMETHODIMP nsAccessNodeWrap::QueryInterface(REFIID iid, void** ppv)
     1: {
     1:   *ppv = nsnull;
     1: 
 79538:   if (IID_IUnknown == iid) {
  3233:     *ppv = static_cast<ISimpleDOMNode*>(this);
 79538:   } else if (IID_ISimpleDOMNode == iid) {
 79538:     statistics::ISimpleDOMUsed();
 79538:     *ppv = static_cast<ISimpleDOMNode*>(this);
 79538:   } else {
     1:     return E_NOINTERFACE;      //iid not supported.
 79538:   }
     1:    
  3233:   (reinterpret_cast<IUnknown*>(*ppv))->AddRef(); 
     1:   return S_OK;
     1: }
     1: 
  5753: STDMETHODIMP
  5753: nsAccessNodeWrap::QueryService(REFGUID guidService, REFIID iid, void** ppv)
  5753: {
 54665:   *ppv = nsnull;
 54665: 
 54665:   // Provide a special service ID for getting the accessible for the browser tab
 54665:   // document that contains this accessible object. If this accessible object
 54665:   // is not inside a browser tab then the service fails with E_NOINTERFACE.
 54665:   // A use case for this is for screen readers that need to switch context or
 54665:   // 'virtual buffer' when focus moves from one browser tab area to another.
103830:   static const GUID SID_IAccessibleContentDocument =
103830:     { 0xa5d8e1f3,0x3571,0x4d8f,0x95,0x21,0x07,0xed,0x28,0xfb,0x07,0x2e };
 54665:   if (guidService == SID_IAccessibleContentDocument) {
 54665:     if (iid != IID_IAccessible)
 54665:       return E_NOINTERFACE;
 54665: 
 54665:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem = 
 54665:       nsCoreUtils::GetDocShellTreeItemFor(mContent);
 54665:     if (!docShellTreeItem)
 54665:       return E_UNEXPECTED;
 54665: 
 54665:     // Walk up the parent chain without crossing the boundary at which item
 54665:     // types change, preventing us from walking up out of tab content.
 54665:     nsCOMPtr<nsIDocShellTreeItem> root;
 54665:     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
 54665:     if (!root)
 54665:       return E_UNEXPECTED;
 54665: 
 54665: 
 54665:     // If the item type is typeContent, we assume we are in browser tab content.
 54665:     // Note this includes content such as about:addons, for consistency.
 54665:     PRInt32 itemType;
 54665:     root->GetItemType(&itemType);
 54665:     if (itemType != nsIDocShellTreeItem::typeContent)
 54665:       return E_NOINTERFACE;
 54665: 
 54665:     // Make sure this is a document.
 99568:     DocAccessible* docAcc = nsAccUtils::GetDocAccessibleFor(root);
 54665:     if (!docAcc)
 54665:       return E_UNEXPECTED;
 54665: 
 54665:     *ppv = static_cast<IAccessible*>(docAcc);
 54665: 
 54665:     (reinterpret_cast<IUnknown*>(*ppv))->AddRef();
 54665:     return NS_OK;
 54665:   }
 54665: 
  5753:   // Can get to IAccessibleApplication from any node via QS
103830:   if (guidService == IID_IAccessibleApplication) {
 96920:     ApplicationAccessible* applicationAcc = GetApplicationAccessible();
 39600:     if (!applicationAcc)
 39600:       return E_NOINTERFACE;
 39600: 
 39600:     nsresult rv = applicationAcc->QueryNativeInterface(iid, ppv);
  5753:     return NS_SUCCEEDED(rv) ? S_OK : E_NOINTERFACE;
  5753:   }
  5753: 
  5753:   /**
  5753:    * To get an ISimpleDOMNode, ISimpleDOMDocument, ISimpleDOMText
  5753:    * or any IAccessible2 interface on should use IServiceProvider like this:
  5753:    * -----------------------------------------------------------------------
  5753:    * ISimpleDOMDocument *pAccDoc = NULL;
  5753:    * IServiceProvider *pServProv = NULL;
  5753:    * pAcc->QueryInterface(IID_IServiceProvider, (void**)&pServProv);
  5753:    * if (pServProv) {
  5753:    *   const GUID unused;
  5753:    *   pServProv->QueryService(unused, IID_ISimpleDOMDocument, (void**)&pAccDoc);
  5753:    *   pServProv->Release();
  5753:    * }
  5753:    */
  5753: 
103830:   static const GUID IID_SimpleDOMDeprecated =
103830:     { 0x0c539790,0x12e4,0x11cf,0xb6,0x61,0x00,0xaa,0x00,0x4c,0xd6,0xd8 };
103830:   if (guidService == IID_ISimpleDOMNode ||
103830:       guidService == IID_SimpleDOMDeprecated ||
103830:       guidService == IID_IAccessible ||  guidService == IID_IAccessible2)
  5753:     return QueryInterface(iid, ppv);
103830: 
103830:   return E_INVALIDARG;
  5753: }
  5753: 
     1: //-----------------------------------------------------
     1: // ISimpleDOMNode methods
     1: //-----------------------------------------------------
     1: 
     1: STDMETHODIMP nsAccessNodeWrap::get_nodeInfo( 
     1:     /* [out] */ BSTR __RPC_FAR *aNodeName,
     1:     /* [out] */ short __RPC_FAR *aNameSpaceID,
     1:     /* [out] */ BSTR __RPC_FAR *aNodeValue,
     1:     /* [out] */ unsigned int __RPC_FAR *aNumChildren,
     1:     /* [out] */ unsigned int __RPC_FAR *aUniqueID,
     1:     /* [out] */ unsigned short __RPC_FAR *aNodeType)
     1: {
 11593: __try{
  2074:   *aNodeName = nsnull;
  2074:   *aNodeValue = nsnull;
  2074: 
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
     1:     return E_FAIL;
     1: 
 94274:   nsCOMPtr<nsIDOMNode> DOMNode(do_QueryInterface(node));
     1: 
     1:   PRUint16 nodeType = 0;
 43504:   DOMNode->GetNodeType(&nodeType);
  3233:   *aNodeType=static_cast<unsigned short>(nodeType);
     1: 
     1:   if (*aNodeType !=  NODETYPE_TEXT) {
     1:     nsAutoString nodeName;
 43504:     DOMNode->GetNodeName(nodeName);
     1:     *aNodeName =   ::SysAllocString(nodeName.get());
     1:   }
     1: 
     1:   nsAutoString nodeValue;
     1: 
 43504:   DOMNode->GetNodeValue(nodeValue);
     1:   *aNodeValue = ::SysAllocString(nodeValue.get());
 43504: 
 43504:   *aNameSpaceID = IsContent() ?
 43504:     static_cast<short>(mContent->GetNameSpaceID()) : 0;
     1: 
     1:   // This is a unique ID for every content node.  The 3rd party
     1:   // accessibility application can compare this to the childID we
     1:   // return for events such as focus events, to correlate back to
     1:   // data nodes in their internal object model.
 56292:   *aUniqueID = - NS_PTR_TO_INT32(UniqueID());
     1: 
 94274:   *aNumChildren = node->GetChildCount();
     1: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1:   return S_OK;
     1: }
     1: 
     1: 
     1:        
     1: STDMETHODIMP nsAccessNodeWrap::get_attributes( 
     1:     /* [in] */ unsigned short aMaxAttribs,
     1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aAttribNames,
     1:     /* [length_is][size_is][out] */ short __RPC_FAR *aNameSpaceIDs,
     1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aAttribValues,
     1:     /* [out] */ unsigned short __RPC_FAR *aNumAttribs)
     1: {
 11593: __try{
     1:   *aNumAttribs = 0;
     1: 
 94274:   if (!mContent || IsDocumentNode())
     1:     return E_FAIL;
     1: 
 43504:   PRUint32 numAttribs = mContent->GetAttrCount();
     1:   if (numAttribs > aMaxAttribs)
     1:     numAttribs = aMaxAttribs;
  3233:   *aNumAttribs = static_cast<unsigned short>(numAttribs);
     1: 
     1:   for (PRUint32 index = 0; index < numAttribs; index++) {
     1:     aNameSpaceIDs[index] = 0; aAttribValues[index] = aAttribNames[index] = nsnull;
     1:     nsAutoString attributeValue;
     1: 
 43504:     const nsAttrName* name = mContent->GetAttrNameAt(index);
  3233:     aNameSpaceIDs[index] = static_cast<short>(name->NamespaceID());
 39100:     aAttribNames[index] = ::SysAllocString(name->LocalName()->GetUTF16String());
 43504:     mContent->GetAttr(name->NamespaceID(), name->LocalName(), attributeValue);
     1:     aAttribValues[index] = ::SysAllocString(attributeValue.get());
     1:   }
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK; 
     1: }
     1:         
     1: 
     1: STDMETHODIMP nsAccessNodeWrap::get_attributesForNames( 
     1:     /* [in] */ unsigned short aNumAttribs,
     1:     /* [length_is][size_is][in] */ BSTR __RPC_FAR *aAttribNames,
     1:     /* [length_is][size_is][in] */ short __RPC_FAR *aNameSpaceID,
     1:     /* [length_is][size_is][retval] */ BSTR __RPC_FAR *aAttribValues)
     1: {
 11593: __try {
 94274:   if (!mContent || !IsElement())
     1:     return E_FAIL;
     1: 
 43504:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(mContent));
     1:   nsCOMPtr<nsINameSpaceManager> nameSpaceManager =
     1:     do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
     1: 
     1:   PRInt32 index;
     1: 
     1:   for (index = 0; index < aNumAttribs; index++) {
     1:     aAttribValues[index] = nsnull;
     1:     if (aAttribNames[index]) {
     1:       nsAutoString attributeValue, nameSpaceURI;
  3233:       nsAutoString attributeName(nsDependentString(static_cast<PRUnichar*>(aAttribNames[index])));
     1:       nsresult rv;
     1: 
     1:       if (aNameSpaceID[index]>0 && 
     1:         NS_SUCCEEDED(nameSpaceManager->GetNameSpaceURI(aNameSpaceID[index], nameSpaceURI)))
     1:           rv = domElement->GetAttributeNS(nameSpaceURI, attributeName, attributeValue);
     1:       else 
     1:         rv = domElement->GetAttribute(attributeName, attributeValue);
     1: 
     1:       if (NS_SUCCEEDED(rv))
     1:         aAttribValues[index] = ::SysAllocString(attributeValue.get());
     1:     }
     1:   }
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK; 
     1: }
     1: 
     1: /* To do: use media type if not null */
     1: STDMETHODIMP nsAccessNodeWrap::get_computedStyle( 
     1:     /* [in] */ unsigned short aMaxStyleProperties,
     1:     /* [in] */ boolean aUseAlternateView,
     1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleProperties,
     1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleValues,
     1:     /* [out] */ unsigned short __RPC_FAR *aNumStyleProperties)
     1: {
 11593: __try{
 19322:   *aNumStyleProperties = 0;
 19322: 
 94274:   if (!mContent || IsDocumentNode())
     1:     return E_FAIL;
     1: 
 43504:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl =
 92156:     nsWinUtils::GetComputedStyleDeclaration(mContent);
     1:   NS_ENSURE_TRUE(cssDecl, E_FAIL);
     1: 
     1:   PRUint32 length;
     1:   cssDecl->GetLength(&length);
     1: 
     1:   PRUint32 index, realIndex;
     1:   for (index = realIndex = 0; index < length && realIndex < aMaxStyleProperties; index ++) {
     1:     nsAutoString property, value;
     1:     if (NS_SUCCEEDED(cssDecl->Item(index, property)) && property.CharAt(0) != '-')  // Ignore -moz-* properties
     1:       cssDecl->GetPropertyValue(property, value);  // Get property value
     1:     if (!value.IsEmpty()) {
     1:       aStyleProperties[realIndex] =   ::SysAllocString(property.get());
     1:       aStyleValues[realIndex]     =   ::SysAllocString(value.get());
     1:       ++realIndex;
     1:     }
     1:   }
  3233:   *aNumStyleProperties = static_cast<unsigned short>(realIndex);
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
     1: 
     1: STDMETHODIMP nsAccessNodeWrap::get_computedStyleForProperties( 
     1:     /* [in] */ unsigned short aNumStyleProperties,
     1:     /* [in] */ boolean aUseAlternateView,
     1:     /* [length_is][size_is][in] */ BSTR __RPC_FAR *aStyleProperties,
     1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleValues)
     1: {
 11593: __try {
 94274:   if (!mContent || IsDocumentNode())
     1:     return E_FAIL;
     1:  
 43504:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl =
 92156:     nsWinUtils::GetComputedStyleDeclaration(mContent);
     1:   NS_ENSURE_TRUE(cssDecl, E_FAIL);
     1: 
     1:   PRUint32 index;
     1:   for (index = 0; index < aNumStyleProperties; index ++) {
     1:     nsAutoString value;
     1:     if (aStyleProperties[index])
  3233:       cssDecl->GetPropertyValue(nsDependentString(static_cast<PRUnichar*>(aStyleProperties[index])), value);  // Get property value
     1:     aStyleValues[index] = ::SysAllocString(value.get());
     1:   }
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
     1: STDMETHODIMP nsAccessNodeWrap::scrollTo(/* [in] */ boolean aScrollTopLeft)
     1: {
 11593: __try {
   497:   PRUint32 scrollType =
   497:     aScrollTopLeft ? nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT :
   497:                      nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT;
   497: 
 95103:   nsCoreUtils::ScrollTo(mDoc->PresShell(), mContent, scrollType);
     1:   return S_OK;
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return E_FAIL;
     1: }
     1: 
 43504: ISimpleDOMNode*
 43504: nsAccessNodeWrap::MakeAccessNode(nsINode *aNode)
 20256: {
 43504:   if (!aNode)
 20256:     return NULL;
 20256: 
 20256:   nsAccessNodeWrap *newNode = NULL;
 20256: 
 20256:   ISimpleDOMNode *iNode = NULL;
 99648:   Accessible* acc = mDoc->GetAccessible(aNode);
 41227:   if (acc) {
 41227:     IAccessible *msaaAccessible = nsnull;
 41227:     acc->GetNativeInterface((void**)&msaaAccessible); // addrefs
 20256:     msaaAccessible->QueryInterface(IID_ISimpleDOMNode, (void**)&iNode); // addrefs
 20256:     msaaAccessible->Release(); // Release IAccessible
 20256:   }
 20256:   else {
 43504:     nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
 43504:     if (!content) {
 43504:       NS_NOTREACHED("The node is a document which is not accessible!");
 43504:       return NULL;
 43504:     }
 43504: 
 89799:     newNode = new nsAccessNodeWrap(content, mDoc);
 20256:     if (!newNode)
 20256:       return NULL;
 20256: 
 20256:     iNode = static_cast<ISimpleDOMNode*>(newNode);
 20256:     iNode->AddRef();
 20256:   }
 20256: 
 20256:   return iNode;
 20256: }
 20256: 
 20256: 
 20256: STDMETHODIMP nsAccessNodeWrap::get_parentNode(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
     1: {
 11593: __try {
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
 20256:     return E_FAIL;
     1: 
 94274:   *aNode = MakeAccessNode(node->GetNodeParent());
 43504: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
 20256: STDMETHODIMP nsAccessNodeWrap::get_firstChild(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
     1: {
 11593: __try {
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
 20256:     return E_FAIL;
     1: 
 94274:   *aNode = MakeAccessNode(node->GetFirstChild());
 43504: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
 20256: STDMETHODIMP nsAccessNodeWrap::get_lastChild(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
     1: {
 11593: __try {
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
 20256:     return E_FAIL;
     1: 
 94274:   *aNode = MakeAccessNode(node->GetLastChild());
 43504: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
 20256: STDMETHODIMP nsAccessNodeWrap::get_previousSibling(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
     1: {
 11593: __try {
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
 20256:     return E_FAIL;
     1: 
 94274:   *aNode = MakeAccessNode(node->GetPreviousSibling());
 43504: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
 20256: STDMETHODIMP nsAccessNodeWrap::get_nextSibling(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
     1: {
 11593: __try {
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
 20256:     return E_FAIL;
     1: 
 94274:   *aNode = MakeAccessNode(node->GetNextSibling());
 43504: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
     1: STDMETHODIMP 
     1: nsAccessNodeWrap::get_childAt(unsigned aChildIndex,
     1:                               ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
     1: {
 11593: __try {
 20256:   *aNode = nsnull;
     1: 
 94274:   nsINode* node = GetNode();
 94274:   if (!node)
 43504:     return E_FAIL;
     1: 
 94274:   *aNode = MakeAccessNode(node->GetChildAt(aChildIndex));
 20256: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
     1: STDMETHODIMP 
     1: nsAccessNodeWrap::get_innerHTML(BSTR __RPC_FAR *aInnerHTML)
     1: {
 11593: __try {
     1:   *aInnerHTML = nsnull;
     1: 
 81041:   nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(GetNode());
 81041:   if (!htmlElement)
     1:     return E_FAIL; // Node already shut down
     1: 
     1:   nsAutoString innerHTML;
 81041:   htmlElement->GetInnerHTML(innerHTML);
 13128:   if (innerHTML.IsEmpty())
 13128:     return S_FALSE;
 13128: 
 13128:   *aInnerHTML = ::SysAllocStringLen(innerHTML.get(), innerHTML.Length());
 13128:   if (!*aInnerHTML)
 13128:     return E_OUTOFMEMORY;
 13128: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1: 
     1:   return S_OK;
     1: }
     1: 
     1: STDMETHODIMP 
     1: nsAccessNodeWrap::get_language(BSTR __RPC_FAR *aLanguage)
     1: {
 11593: __try {
 13128:   *aLanguage = NULL;
  2074: 
  1751:   nsAutoString language;
 89598:   Language(language);
 13128:   if (language.IsEmpty())
 13128:     return S_FALSE;
 13128: 
 13128:   *aLanguage = ::SysAllocStringLen(language.get(), language.Length());
 13128:   if (!*aLanguage)
 13128:     return E_OUTOFMEMORY;
 13128: 
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
 11593: 
     1:   return S_OK;
     1: }
     1: 
     1: STDMETHODIMP 
     1: nsAccessNodeWrap::get_localInterface( 
     1:     /* [out] */ void __RPC_FAR *__RPC_FAR *localInterface)
     1: {
 11593: __try {
 89598:   *localInterface = static_cast<nsAccessNode*>(this);
     1:   NS_ADDREF_THIS();
 11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
     1:   return S_OK;
     1: }
     1:  
     1: void nsAccessNodeWrap::InitAccessibility()
     1: {
 83479:   Compatibility::Init();
 16515: 
 64004:   nsWinUtils::MaybeStartWindowEmulation();
     1: }
     1: 
     1: void nsAccessNodeWrap::ShutdownAccessibility()
     1: {
  1392:   NS_IF_RELEASE(gTextEvent);
  2395:   ::DestroyCaret();
  1392: 
 64004:   nsWinUtils::ShutdownWindowEmulation();
 54220: 
     1:   nsAccessNode::ShutdownXPAccessibility();
     1: }
 11440: 
 11440: int nsAccessNodeWrap::FilterA11yExceptions(unsigned int aCode, EXCEPTION_POINTERS *aExceptionInfo)
 11440: {
 11440:   if (aCode == EXCEPTION_ACCESS_VIOLATION) {
 11440: #ifdef MOZ_CRASHREPORTER
 11440:     // MSAA swallows crashes (because it is COM-based)
 11440:     // but we still need to learn about those crashes so we can fix them
 11440:     // Make sure to pass them to the crash reporter
 11440:     nsCOMPtr<nsICrashReporter> crashReporter =
 11440:       do_GetService("@mozilla.org/toolkit/crash-reporter;1");
 11440:     if (crashReporter) {
 11440:       crashReporter->WriteMinidumpForException(aExceptionInfo);
 11440:     }
 11440: #endif
 11440:   }
 11440:   else {
 11440:     NS_NOTREACHED("We should only be catching crash exceptions");
 11440:   }
 11440:   return EXCEPTION_CONTINUE_SEARCH;
 11440: }
 13730: 
 13730: HRESULT
 13730: GetHRESULT(nsresult aResult)
 13730: {
 13730:   switch (aResult) {
 13730:     case NS_OK:
 13730:       return S_OK;
 13730: 
 13730:     case NS_ERROR_INVALID_ARG: case NS_ERROR_INVALID_POINTER:
 13730:       return E_INVALIDARG;
 13730: 
 13730:     case NS_ERROR_OUT_OF_MEMORY:
 13730:       return E_OUTOFMEMORY;
 13730: 
 13730:     case NS_ERROR_NOT_IMPLEMENTED:
 13730:       return E_NOTIMPL;
 13730: 
 13730:     default:
 13730:       return E_FAIL;
 13730:   }
 13730: }
 13730: 
 99568: nsRefPtrHashtable<nsPtrHashKey<void>, DocAccessible> nsAccessNodeWrap::sHWNDCache;
 54220: 
 54220: LRESULT CALLBACK
 54220: nsAccessNodeWrap::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 54220: {
 80208:   // Note, this window's message handling should not invoke any call that
 80208:   // may result in a cross-process ipc call. Doing so may violate RPC
 80208:   // message semantics.
 80208: 
 54220:   switch (msg) {
 54220:     case WM_GETOBJECT:
 54220:     {
 54220:       if (lParam == OBJID_CLIENT) {
 99568:         DocAccessible* document = sHWNDCache.GetWeak(static_cast<void*>(hWnd));
 54220:         if (document) {
 54220:           IAccessible* msaaAccessible = NULL;
 54220:           document->GetNativeInterface((void**)&msaaAccessible); // does an addref
 54220:           if (msaaAccessible) {
 89333:             LRESULT result = ::LresultFromObject(IID_IAccessible, wParam,
 54220:                                                  msaaAccessible); // does an addref
 54220:             msaaAccessible->Release(); // release extra addref
 54220:             return result;
 54220:           }
 54220:         }
 54220:       }
 54220:       return 0;
 54220:     }
 63261:     case WM_NCHITTEST:
 63261:     {
 63261:       LRESULT lRet = ::DefWindowProc(hWnd, msg, wParam, lParam);
 63261:       if (HTCLIENT == lRet)
 63261:         lRet = HTTRANSPARENT;
 63261:       return lRet;
 63261:     }
 54220:   }
 54220: 
 54220:   return ::DefWindowProcW(hWnd, msg, wParam, lParam);
 54220: }
