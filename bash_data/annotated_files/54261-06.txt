    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
16226:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* a presentation of a document, part 1 */
    1: 
    1: #ifndef nsPresContext_h___
    1: #define nsPresContext_h___
    1: 
    1: #include "nsISupports.h"
    1: #include "nsColor.h"
    1: #include "nsCoord.h"
    1: #include "nsAString.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIPresShell.h"
    1: #include "nsRect.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsFont.h"
    1: #include "nsIWeakReference.h"
    1: #include "nsITheme.h"
    1: #include "nsILanguageAtomService.h"
    1: #include "nsIObserver.h"
    1: #include "nsITimer.h"
    1: #include "nsCRT.h"
    1: #include "nsIPrintSettings.h"
39965: #include "FramePropertyTable.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDocument.h"
25231: #include "nsRefPtrHashtable.h"
 4484: #include "nsCycleCollectionParticipant.h"
11409: #include "nsChangeHint.h"
15687: // This also pulls in gfxTypes.h, which we cannot include directly.
15687: #include "gfxRect.h"
19380: #include "nsRegion.h"
21925: #include "nsTArray.h"
21925: #include "nsAutoPtr.h"
25116: #include "nsThreadUtils.h"
29087: #include "nsContentUtils.h"
30522: #include "nsIWidget.h"
33393: #include "mozilla/TimeStamp.h"
36653: #include "nsIContent.h"
19962: 
    1: class nsImageLoader;
    1: #ifdef IBMBIDI
    1: class nsBidiPresUtils;
    1: #endif // IBMBIDI
    1: 
    1: struct nsRect;
    1: 
    1: class imgIRequest;
    1: 
    1: class nsIFontMetrics;
    1: class nsIFrame;
    1: class nsFrameManager;
    1: class nsILinkHandler;
    1: class nsStyleContext;
    1: class nsIAtom;
    1: class nsIEventStateManager;
    1: class nsIURI;
    1: class nsILookAndFeel;
    1: class nsICSSPseudoComparator;
    1: class nsIAtom;
    1: struct nsStyleBackground;
25231: struct nsStyleBorder;
    1: class nsIRunnable;
19962: class gfxUserFontSet;
23932: class nsUserFontSet;
21983: struct nsFontFaceRuleContainer;
30522: class nsObjectFrame;
33649: class nsTransitionManager;
36615: class nsRefreshDriver;
35581: class imgIContainer;
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1: class nsIRenderingContext;
    1: #endif
    1: 
    1: enum nsWidgetType {
    1:   eWidgetType_Button  	= 1,
    1:   eWidgetType_Checkbox	= 2,
    1:   eWidgetType_Radio			= 3,
    1:   eWidgetType_Text			= 4
    1: };
    1: 
    1: enum nsLanguageSpecificTransformType {
    1:   eLanguageSpecificTransformType_Unknown = -1,
    1:   eLanguageSpecificTransformType_None = 0,
    1:   eLanguageSpecificTransformType_Japanese
    1: };
    1: 
    1: // supported values for cached bool types
    1: enum nsPresContext_CachedBoolPrefType {
    1:   kPresContext_UseDocumentColors = 1,
    1:   kPresContext_UseDocumentFonts,
    1:   kPresContext_UnderlineLinks
    1: };
    1: 
    1: // supported values for cached integer pref types
    1: enum nsPresContext_CachedIntPrefType {
    1:   kPresContext_MinimumFontSize = 1,
    1:   kPresContext_ScrollbarSide,
    1:   kPresContext_BidiDirection
    1: };
    1: 
    1: // IDs for the default variable and fixed fonts (not to be changed, see nsFont.h)
    1: // To be used for Get/SetDefaultFont(). The other IDs in nsFont.h are also supported.
    1: const PRUint8 kPresContext_DefaultVariableFont_ID = 0x00; // kGenericFont_moz_variable
    1: const PRUint8 kPresContext_DefaultFixedFont_ID    = 0x01; // kGenericFont_moz_fixed
    1: 
    1: #ifdef DEBUG
    1: struct nsAutoLayoutPhase;
    1: 
    1: enum nsLayoutPhase {
    1:   eLayoutPhase_Paint,
    1:   eLayoutPhase_Reflow,
    1:   eLayoutPhase_FrameC,
    1:   eLayoutPhase_COUNT
    1: };
    1: #endif
    1: 
32894: class nsInvalidateRequestList {
32894: public:
32894:   struct Request {
32894:     nsRect   mRect;
32894:     PRUint32 mFlags;
32894:   };
32894: 
32894:   nsTArray<Request> mRequests;
32894: };
32894: 
14697: /* Used by nsPresContext::HasAuthorSpecifiedRules */
14697: #define NS_AUTHOR_SPECIFIED_BACKGROUND      (1 << 0)
14697: #define NS_AUTHOR_SPECIFIED_BORDER          (1 << 1)
14697: #define NS_AUTHOR_SPECIFIED_PADDING         (1 << 2)
14697: 
30514: class nsRootPresContext;
30514: 
    1: // An interface for presentation contexts. Presentation contexts are
    1: // objects that provide an outer context for a presentation shell.
    1: 
    1: class nsPresContext : public nsIObserver {
    1: public:
39965:   typedef mozilla::FramePropertyTable FramePropertyTable;
39965: 
 4484:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1:   NS_DECL_NSIOBSERVER
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
 4484:   NS_DECL_CYCLE_COLLECTION_CLASS(nsPresContext)
    1: 
    1:   enum nsPresContextType {
    1:     eContext_Galley,       // unpaginated screen presentation
    1:     eContext_PrintPreview, // paginated screen presentation
    1:     eContext_Print,        // paginated printer presentation
    1:     eContext_PageLayout    // paginated & editable.
    1:   };
    1: 
    1:   nsPresContext(nsIDocument* aDocument, nsPresContextType aType) NS_HIDDEN;
    1: 
    1:   /**
    1:    * Initialize the presentation context from a particular device.
    1:    */
    1:   NS_HIDDEN_(nsresult) Init(nsIDeviceContext* aDeviceContext);
    1: 
    1:   /**
    1:    * Set the presentation shell that this context is bound to.
    1:    * A presentation context may only be bound to a single shell.
    1:    */
    1:   NS_HIDDEN_(void) SetShell(nsIPresShell* aShell);
    1: 
    1: 
    1:   NS_HIDDEN_(nsPresContextType) Type() const { return mType; }
    1: 
    1:   /**
    1:    * Get the PresentationShell that this context is bound to.
    1:    */
    1:   nsIPresShell* PresShell() const
    1:   {
    1:     NS_ASSERTION(mShell, "Null pres shell");
    1:     return mShell;
    1:   }
    1: 
    1:   nsIPresShell* GetPresShell() const { return mShell; }
    1: 
37502:   /**
37502:    * Return the presentation context for the root of the view manager
37502:    * hierarchy that contains this presentation context, or nsnull if it can't
37502:    * be found (e.g. it's detached).
37502:    */
37502:   nsRootPresContext* GetRootPresContext();
37502:   virtual PRBool IsRoot() { return PR_FALSE; }
    1: 
    1:   nsIDocument* Document() const
    1:   {
    1:       NS_ASSERTION(!mShell || !mShell->GetDocument() ||
    1:                    mShell->GetDocument() == mDocument,
    1:                    "nsPresContext doesn't have the same document as nsPresShell!");
    1:       return mDocument;
    1:   }
    1: 
    1: #ifdef _IMPL_NS_LAYOUT
    1:   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
    1: 
    1:   nsFrameManager* FrameManager()
    1:     { return GetPresShell()->FrameManager(); } 
33649: 
33649:   nsTransitionManager* TransitionManager() { return mTransitionManager; }
33649: 
36615:   nsRefreshDriver* RefreshDriver() { return mRefreshDriver; }
    1: #endif
    1: 
22339:   /**
22339:    * Rebuilds all style data by throwing out the old rule tree and
22339:    * building a new one, and additionally applying aExtraHint (which
22339:    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
22339:    * Also rebuild the user font set.
22339:    */
11409:   void RebuildAllStyleData(nsChangeHint aExtraHint);
22339:   /**
22339:    * Just like RebuildAllStyleData, except (1) asynchronous and (2) it
22339:    * doesn't rebuild the user font set.
22339:    */
22339:   void PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint);
10073: 
16226:   void MediaFeatureValuesChanged(PRBool aCallerWillRebuildStyleData);
16226:   void PostMediaFeatureValuesChangedEvent();
16226:   NS_HIDDEN_(void) HandleMediaFeatureValuesChangedEvent();
16226:   void FlushPendingMediaFeatureValuesChanged() {
16226:     if (mPendingMediaFeatureValuesChanged)
16226:       MediaFeatureValuesChanged(PR_FALSE);
16226:   }
16226: 
    1:   /**
    1:    * Access compatibility mode for this context.  This is the same as
    1:    * our document's compatibility mode.
    1:    */
    1:   nsCompatibility CompatibilityMode() const {
    1:     return Document()->GetCompatibilityMode();
    1:   }
    1:   /**
    1:    * Notify the context that the document's compatibility mode has changed
    1:    */
    1:   NS_HIDDEN_(void) CompatibilityModeChanged();
    1: 
    1:   /**
    1:    * Access the image animation mode for this context
    1:    */
    1:   PRUint16     ImageAnimationMode() const { return mImageAnimationMode; }
    1:   virtual NS_HIDDEN_(void) SetImageAnimationModeExternal(PRUint16 aMode);
    1:   NS_HIDDEN_(void) SetImageAnimationModeInternal(PRUint16 aMode);
    1: #ifdef _IMPL_NS_LAYOUT
    1:   void SetImageAnimationMode(PRUint16 aMode)
    1:   { SetImageAnimationModeInternal(aMode); }
    1: #else
    1:   void SetImageAnimationMode(PRUint16 aMode)
    1:   { SetImageAnimationModeExternal(aMode); }
    1: #endif
    1: 
    1:   /**
    1:    * Get cached look and feel service.  This is faster than obtaining it
    1:    * through the service manager.
    1:    */
    1:   nsILookAndFeel* LookAndFeel() { return mLookAndFeel; }
    1: 
    1:   /** 
    1:    * Get medium of presentation
    1:    */
    1:   nsIAtom* Medium() { return mMedium; }
    1: 
    1:   void* AllocateFromShell(size_t aSize)
    1:   {
    1:     if (mShell)
31620:       return mShell->AllocateMisc(aSize);
    1:     return nsnull;
    1:   }
    1: 
    1:   void FreeToShell(size_t aSize, void* aFreeChunk)
    1:   {
24429:     NS_ASSERTION(mShell, "freeing after shutdown");
    1:     if (mShell)
31620:       mShell->FreeMisc(aSize, aFreeChunk);
    1:   }
    1: 
    1:   /**
    1:    * Get the font metrics for a given font.
23846:    *
23846:    * If aUseUserFontSet is false, don't build or use the user font set.
23846:    * This is intended only for nsRuleNode::CalcLengthWithInitialFont
23846:    * (which is used from media query matching, which is in turn called
23846:    * when building the user font set).
    1:    */
    1:   NS_HIDDEN_(already_AddRefed<nsIFontMetrics>)
23846:   GetMetricsFor(const nsFont& aFont, PRBool aUseUserFontSet = PR_TRUE);
    1: 
    1:   /**
    1:    * Get the default font corresponding to the given ID.  This object is
    1:    * read-only, you must copy the font to modify it.
 3987:    * 
 3987:    * When aFontID is kPresContext_DefaultVariableFontID or
 3987:    * kPresContext_DefaultFixedFontID (which equals
 3987:    * kGenericFont_moz_fixed, which is used for the -moz-fixed generic),
 3987:    * the nsFont returned has its name as a CSS generic family (serif or
 3987:    * sans-serif for the former, monospace for the latter), and its size
 3987:    * as the default font size for variable or fixed fonts for the pres
 3987:    * context's language group.
 3987:    *
 3987:    * For aFontID corresponds to a CSS Generic, the nsFont returned has
 3987:    * its name as the name or names of the fonts in the user's
 3987:    * preferences for the given generic and the pres context's language
 3987:    * group, and its size set to the default variable font size.
    1:    */
20218:   NS_HIDDEN_(const nsFont*) GetDefaultFont(PRUint8 aFontID) const;
    1: 
    1:   /** Get a cached boolean pref, by its type */
    1:   // *  - initially created for bugs 31816, 20760, 22963
    1:   PRBool GetCachedBoolPref(nsPresContext_CachedBoolPrefType aPrefType) const
    1:   {
    1:     // If called with a constant parameter, the compiler should optimize
    1:     // this switch statement away.
    1:     switch (aPrefType) {
    1:     case kPresContext_UseDocumentFonts:
    1:       return mUseDocumentFonts;
    1:     case kPresContext_UseDocumentColors:
    1:       return mUseDocumentColors;
    1:     case kPresContext_UnderlineLinks:
    1:       return mUnderlineLinks;
    1:     default:
    1:       NS_ERROR("Invalid arg passed to GetCachedBoolPref");
    1:     }
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   /** Get a cached integer pref, by its type */
    1:   // *  - initially created for bugs 30910, 61883, 74186, 84398
    1:   PRInt32 GetCachedIntPref(nsPresContext_CachedIntPrefType aPrefType) const
    1:   {
    1:     // If called with a constant parameter, the compiler should optimize
    1:     // this switch statement away.
    1:     switch (aPrefType) {
    1:     case kPresContext_MinimumFontSize:
    1:       return mMinimumFontSize;
    1:     case kPresContext_ScrollbarSide:
    1:       return mPrefScrollbarSide;
    1:     case kPresContext_BidiDirection:
    1:       return mPrefBidiDirection;
    1:     default:
    1:       NS_ERROR("invalid arg passed to GetCachedIntPref");
    1:     }
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   /**
    1:    * Access Nav's magic font scaler value
    1:    */
    1:   PRInt32 FontScaler() const { return mFontScaler; }
    1: 
    1:   /** 
    1:    * Get the default colors
    1:    */
    1:   const nscolor DefaultColor() const { return mDefaultColor; }
    1:   const nscolor DefaultBackgroundColor() const { return mBackgroundColor; }
    1:   const nscolor DefaultLinkColor() const { return mLinkColor; }
    1:   const nscolor DefaultActiveLinkColor() const { return mActiveLinkColor; }
    1:   const nscolor DefaultVisitedLinkColor() const { return mVisitedLinkColor; }
    1:   const nscolor FocusBackgroundColor() const { return mFocusBackgroundColor; }
    1:   const nscolor FocusTextColor() const { return mFocusTextColor; }
    1: 
    1:   PRBool GetUseFocusColors() const { return mUseFocusColors; }
    1:   PRUint8 FocusRingWidth() const { return mFocusRingWidth; }
    1:   PRBool GetFocusRingOnAnything() const { return mFocusRingOnAnything; }
20177:   PRUint8 GetFocusRingStyle() const { return mFocusRingStyle; }
    1: 
25231:   /**
25231:    * The types of image load types that the pres context needs image
25231:    * loaders to track invalidation for.
25231:    */
25231:   enum ImageLoadType {
25231:     BACKGROUND_IMAGE,
25231:     BORDER_IMAGE,
25231:     IMAGE_LOAD_TYPE_COUNT
25231:   };
    1: 
    1:   /**
25231:    * Set the list of image loaders that track invalidation for a
25231:    * specific frame and type of image.  This list will replace any
25231:    * previous list for that frame and image type (and null will remove
25231:    * any previous list).
    1:    */
25231:   NS_HIDDEN_(void) SetImageLoaders(nsIFrame* aTargetFrame,
25231:                                    ImageLoadType aType,
25231:                                    nsImageLoader* aImageLoaders);
25231: 
25220:   /**
25231:    * Make an appropriate SetImageLoaders call (including potentially
25231:    * with null aImageLoaders) given that aFrame draws its background
25231:    * based on aStyleBackground.
25220:    */
25231:   NS_HIDDEN_(void) SetupBackgroundImageLoaders(nsIFrame* aFrame,
25231:                                                const nsStyleBackground*
25231:                                                  aStyleBackground);
25206: 
25231:   /**
25231:    * Make an appropriate SetImageLoaders call (including potentially
25231:    * with null aImageLoaders) given that aFrame draws its border
25231:    * based on aStyleBorder.
25231:    */
25231:   NS_HIDDEN_(void) SetupBorderImageLoaders(nsIFrame* aFrame,
25231:                                            const nsStyleBorder* aStyleBorder);
25162: 
    1:   /**
    1:    * This method is called when a frame is being destroyed to
25231:    * ensure that the image loads get disassociated from the prescontext
    1:    */
    1:   NS_HIDDEN_(void) StopImagesFor(nsIFrame* aTargetFrame);
    1: 
    1:   NS_HIDDEN_(void) SetContainer(nsISupports* aContainer);
    1: 
 8088:   virtual NS_HIDDEN_(already_AddRefed<nsISupports>) GetContainerExternal() const;
 8088:   NS_HIDDEN_(already_AddRefed<nsISupports>) GetContainerInternal() const;
    1: #ifdef _IMPL_NS_LAYOUT
 8088:   already_AddRefed<nsISupports> GetContainer() const
    1:   { return GetContainerInternal(); }
    1: #else
 8088:   already_AddRefed<nsISupports> GetContainer() const
    1:   { return GetContainerExternal(); }
    1: #endif
    1: 
    1:   // XXX this are going to be replaced with set/get container
    1:   void SetLinkHandler(nsILinkHandler* aHandler) { mLinkHandler = aHandler; }
    1:   nsILinkHandler* GetLinkHandler() { return mLinkHandler; }
    1: 
    1:   /**
    1:    * Get the visible area associated with this presentation context.
22527:    * This is the size of the visible area that is used for
    1:    * presenting the document. The returned value is in the standard
    1:    * nscoord units (as scaled by the device context).
    1:    */
    1:   nsRect GetVisibleArea() { return mVisibleArea; }
    1: 
    1:   /**
    1:    * Set the currently visible area. The units for r are standard
    1:    * nscoord units (as scaled by the device context).
    1:    */
16226:   void SetVisibleArea(const nsRect& r) {
23169:     if (!r.IsExactEqual(mVisibleArea)) {
16226:       mVisibleArea = r;
23166:       // Visible area does not affect media queries when paginated.
23166:       if (!IsPaginated() && HasCachedStyleData())
16226:         PostMediaFeatureValuesChangedEvent();
16226:     }
23169:   }
    1: 
    1:   /**
    1:    * Return true if this presentation context is a paginated
    1:    * context.
    1:    */
    1:   PRBool IsPaginated() const { return mPaginated; }
    1:   
    1:   /**
    1:    * Sets whether the presentation context can scroll for a paginated
    1:    * context.
    1:    */
    1:   NS_HIDDEN_(void) SetPaginatedScrolling(PRBool aResult);
    1: 
    1:   /**
    1:    * Return true if this presentation context can scroll for paginated
    1:    * context.
    1:    */
    1:   PRBool HasPaginatedScrolling() const { return mCanPaginatedScroll; }
    1: 
    1:   /**
    1:    * Get/set the size of a page
    1:    */
    1:   nsSize GetPageSize() { return mPageSize; }
    1:   void SetPageSize(nsSize aSize) { mPageSize = aSize; }
    1: 
    1:   /**
    1:    * Get/set whether this document should be treated as having real pages
    1:    * XXX This raises the obvious question of why a document that isn't a page
    1:    *     is paginated; there isn't a good reason except history
    1:    */
    1:   PRBool IsRootPaginatedDocument() { return mIsRootPaginatedDocument; }
    1:   void SetIsRootPaginatedDocument(PRBool aIsRootPaginatedDocument)
    1:     { mIsRootPaginatedDocument = aIsRootPaginatedDocument; }
    1: 
    1:   /**
    1:   * Get/set the print scaling level; used by nsPageFrame to scale up
    1:   * pages.  Set safe to call before reflow, get guaranteed to be set
    1:   * properly after reflow.
    1:   */
    1: 
    1:   float GetPageScale() { return mPageScale; }
    1:   void SetPageScale(float aScale) { mPageScale = aScale; }
    1: 
    1:   /**
    1:   * Get/set the scaling facor to use when rendering the pages for print preview.
    1:   * Only safe to get after print preview set up; safe to set anytime.
    1:   * This is a scaling factor for the display of the print preview.  It
    1:   * does not affect layout.  It only affects the size of the onscreen pages
    1:   * in print preview.
    1:   * XXX Temporary: see http://wiki.mozilla.org/Gecko:PrintPreview
    1:   */
    1:   float GetPrintPreviewScale() { return mPPScale; }
    1:   void SetPrintPreviewScale(float aScale) { mPPScale = aScale; }
    1: 
    1:   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
    1:   nsIEventStateManager* EventStateManager() { return mEventManager; }
38747:   nsIAtom* GetLanguageFromCharset() { return mLanguage; }
    1: 
    1:   float TextZoom() { return mTextZoom; }
 4003:   void SetTextZoom(float aZoom) {
23826:     if (aZoom == mTextZoom)
23826:       return;
23826: 
    1:     mTextZoom = aZoom;
23826:     if (HasCachedStyleData()) {
23826:       // Media queries could have changed since we changed the meaning
23826:       // of 'em' units in them.
23826:       MediaFeatureValuesChanged(PR_TRUE);
11409:       RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
    1:     }
23826:   }
 4003: 
 4359:   float GetFullZoom() { return mFullZoom; }
 4003:   void SetFullZoom(float aZoom);
    1: 
 4032:   nscoord GetAutoQualityMinFontSize() {
 4032:     return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
 4032:   }
 4032:   
    1:   static PRInt32 AppUnitsPerCSSPixel() { return nsIDeviceContext::AppUnitsPerCSSPixel(); }
    1:   PRInt32 AppUnitsPerDevPixel() const  { return mDeviceContext->AppUnitsPerDevPixel(); }
50791:   static PRInt32 AppUnitsPerCSSInch() { return nsIDeviceContext::AppUnitsPerCSSInch(); }
    1: 
    1:   static nscoord CSSPixelsToAppUnits(PRInt32 aPixels)
    1:   { return NSIntPixelsToAppUnits(aPixels,
    1:                                  nsIDeviceContext::AppUnitsPerCSSPixel()); }
    1: 
    1:   static nscoord CSSPixelsToAppUnits(float aPixels)
    1:   { return NSFloatPixelsToAppUnits(aPixels,
20559:              float(nsIDeviceContext::AppUnitsPerCSSPixel())); }
    1: 
    1:   static PRInt32 AppUnitsToIntCSSPixels(nscoord aAppUnits)
    1:   { return NSAppUnitsToIntPixels(aAppUnits,
20559:              float(nsIDeviceContext::AppUnitsPerCSSPixel())); }
    1: 
    1:   static float AppUnitsToFloatCSSPixels(nscoord aAppUnits)
    1:   { return NSAppUnitsToFloatPixels(aAppUnits,
20559:              float(nsIDeviceContext::AppUnitsPerCSSPixel())); }
    1: 
    1:   nscoord DevPixelsToAppUnits(PRInt32 aPixels) const
    1:   { return NSIntPixelsToAppUnits(aPixels,
    1:                                  mDeviceContext->AppUnitsPerDevPixel()); }
    1: 
    1:   PRInt32 AppUnitsToDevPixels(nscoord aAppUnits) const
    1:   { return NSAppUnitsToIntPixels(aAppUnits,
20559:              float(mDeviceContext->AppUnitsPerDevPixel())); }
    1: 
29322:   PRInt32 CSSPixelsToDevPixels(PRInt32 aPixels)
29322:   { return AppUnitsToDevPixels(CSSPixelsToAppUnits(aPixels)); }
29322: 
29322:   float CSSPixelsToDevPixels(float aPixels)
29322:   {
29322:     return NSAppUnitsToFloatPixels(CSSPixelsToAppUnits(aPixels),
29322:                                    float(mDeviceContext->AppUnitsPerDevPixel()));
29322:   }
29322: 
29322:   PRInt32 DevPixelsToIntCSSPixels(PRInt32 aPixels)
29322:   { return AppUnitsToIntCSSPixels(DevPixelsToAppUnits(aPixels)); }
29322: 
29322:   float DevPixelsToFloatCSSPixels(PRInt32 aPixels)
29322:   { return AppUnitsToFloatCSSPixels(DevPixelsToAppUnits(aPixels)); }
29322: 
11780:   // If there is a remainder, it is rounded to nearest app units.
11780:   nscoord GfxUnitsToAppUnits(gfxFloat aGfxUnits) const
11780:   { return mDeviceContext->GfxUnitsToAppUnits(aGfxUnits); }
11780: 
 5147:   gfxFloat AppUnitsToGfxUnits(nscoord aAppUnits) const
 5147:   { return mDeviceContext->AppUnitsToGfxUnits(aAppUnits); }
 5147: 
15687:   gfxRect AppUnitsToGfxUnits(const nsRect& aAppRect) const
15687:   { return gfxRect(AppUnitsToGfxUnits(aAppRect.x),
15687:                    AppUnitsToGfxUnits(aAppRect.y),
15687:                    AppUnitsToGfxUnits(aAppRect.width),
15687:                    AppUnitsToGfxUnits(aAppRect.height)); }
15687: 
50791:   static nscoord CSSTwipsToAppUnits(float aTwips)
50786:   { return NSToCoordRoundWithClamp(
50791:       nsIDeviceContext::AppUnitsPerCSSInch() * NS_TWIPS_TO_INCHES(aTwips)); }
    1: 
13309:   // Margin-specific version, since they often need TwipsToAppUnits
50791:   static nsMargin CSSTwipsToAppUnits(const nsIntMargin &marginInTwips)
51145:   { return nsMargin(CSSTwipsToAppUnits(float(marginInTwips.left)), 
51145:                     CSSTwipsToAppUnits(float(marginInTwips.top)),
51145:                     CSSTwipsToAppUnits(float(marginInTwips.right)),
51145:                     CSSTwipsToAppUnits(float(marginInTwips.bottom))); }
13309: 
50791:   static nscoord CSSPointsToAppUnits(float aPoints)
50791:   { return NSToCoordRound(aPoints * nsIDeviceContext::AppUnitsPerCSSInch() /
14015:                           POINTS_PER_INCH_FLOAT); }
    1: 
 4628:   nscoord RoundAppUnitsToNearestDevPixels(nscoord aAppUnits) const
 4628:   { return DevPixelsToAppUnits(AppUnitsToDevPixels(aAppUnits)); }
 4628: 
    1:   struct ScrollbarStyles {
    1:     // Always one of NS_STYLE_OVERFLOW_SCROLL, NS_STYLE_OVERFLOW_HIDDEN,
    1:     // or NS_STYLE_OVERFLOW_AUTO.
    1:     PRUint8 mHorizontal, mVertical;
    1:     ScrollbarStyles(PRUint8 h, PRUint8 v) : mHorizontal(h), mVertical(v) {}
    1:     ScrollbarStyles() {}
37057:     PRBool operator==(const ScrollbarStyles& aStyles) const {
37057:       return aStyles.mHorizontal == mHorizontal && aStyles.mVertical == mVertical;
37057:     }
37057:     PRBool operator!=(const ScrollbarStyles& aStyles) const {
37057:       return aStyles.mHorizontal != mHorizontal || aStyles.mVertical != mVertical;
37057:     }
    1:   };
    1:   void SetViewportOverflowOverride(PRUint8 aX, PRUint8 aY)
    1:   {
    1:     mViewportStyleOverflow.mHorizontal = aX;
    1:     mViewportStyleOverflow.mVertical = aY;
    1:   }
    1:   ScrollbarStyles GetViewportOverflowOverride()
    1:   {
    1:     return mViewportStyleOverflow;
    1:   }
    1: 
    1:   /**
    1:    * Set and get methods for controlling the background drawing
    1:   */
    1:   PRBool GetBackgroundImageDraw() const { return mDrawImageBackground; }
    1:   void   SetBackgroundImageDraw(PRBool aCanDraw)
    1:   {
    1:     NS_ASSERTION(!(aCanDraw & ~1), "Value must be true or false");
    1:     mDrawImageBackground = aCanDraw;
    1:   }
    1: 
    1:   PRBool GetBackgroundColorDraw() const { return mDrawColorBackground; }
    1:   void   SetBackgroundColorDraw(PRBool aCanDraw)
    1:   {
    1:     NS_ASSERTION(!(aCanDraw & ~1), "Value must be true or false");
    1:     mDrawColorBackground = aCanDraw;
    1:   }
    1: 
    1: #ifdef IBMBIDI
    1:   /**
    1:    *  Check if bidi enabled (set depending on the presence of RTL
    1:    *  characters or when default directionality is RTL).
    1:    *  If enabled, we should apply the Unicode Bidi Algorithm
    1:    *
    1:    *  @lina 07/12/2000
    1:    */
42355:   virtual PRBool BidiEnabledExternal() const { return BidiEnabledInternal(); }
42355:   PRBool BidiEnabledInternal() const { return Document()->GetBidiEnabled(); }
    1: #ifdef _IMPL_NS_LAYOUT
    1:   PRBool BidiEnabled() const { return BidiEnabledInternal(); }
    1: #else
    1:   PRBool BidiEnabled() const { return BidiEnabledExternal(); }
    1: #endif
    1: 
    1:   /**
    1:    *  Set bidi enabled. This means we should apply the Unicode Bidi Algorithm
    1:    *
    1:    *  @lina 07/12/2000
    1:    */
15376:   NS_HIDDEN_(void) SetBidiEnabled() const;
    1: 
    1:   /**
    1:    *  Set visual or implicit mode into the pres context.
    1:    *
    1:    *  Visual directionality is a presentation method that displays text
    1:    *  as if it were a uni-directional, according to the primary display
    1:    *  direction only. 
    1:    *
    1:    *  Implicit directionality is a presentation method in which the
    1:    *  direction is determined by the Bidi algorithm according to the
    1:    *  category of the characters and the category of the adjacent
    1:    *  characters, and according to their primary direction.
    1:    *
    1:    *  @lina 05/02/2000
    1:    */
    1:   void SetVisualMode(PRBool aIsVisual)
    1:   {
    1:     NS_ASSERTION(!(aIsVisual & ~1), "Value must be true or false");
    1:     mIsVisual = aIsVisual;
    1:   }
    1: 
    1:   /**
    1:    *  Check whether the content should be treated as visual.
    1:    *
    1:    *  @lina 05/02/2000
    1:    */
    1:   PRBool IsVisualMode() const { return mIsVisual; }
    1: 
    1: //Mohamed
    1: 
    1:   /**
    1:    * Get a Bidi presentation utilities object
    1:    */
    1:   NS_HIDDEN_(nsBidiPresUtils*) GetBidiUtils();
    1: 
    1:   /**
    1:    * Set the Bidi options for the presentation context
    1:    */  
    1:   NS_HIDDEN_(void) SetBidi(PRUint32 aBidiOptions,
10073:                            PRBool aForceRestyle = PR_FALSE);
    1: 
    1:   /**
    1:    * Get the Bidi options for the presentation context
    1:    * Not inline so consumers of nsPresContext are not forced to
    1:    * include nsIDocument.
    1:    */  
    1:   NS_HIDDEN_(PRUint32) GetBidi() const;
42982: 
42982:   PRUint32 GetBidiMemoryUsed();
42982: #else
42982:   PRUint32 GetBidiMemoryUsed() { return 0; }
    1: #endif // IBMBIDI
    1: 
    1:   /**
    1:    * Render only Selection
    1:    */
    1:   void SetIsRenderingOnlySelection(PRBool aResult)
    1:   {
    1:     NS_ASSERTION(!(aResult & ~1), "Value must be true or false");
    1:     mIsRenderingOnlySelection = aResult;
    1:   }
    1: 
    1:   PRBool IsRenderingOnlySelection() const { return mIsRenderingOnlySelection; }
    1: 
39698:   NS_HIDDEN_(PRBool) IsTopLevelWindowInactive();
39698: 
    1:   /*
    1:    * Obtain a native them for rendering our widgets (both form controls and html)
    1:    */
    1:   NS_HIDDEN_(nsITheme*) GetTheme();
    1: 
    1:   /*
    1:    * Notify the pres context that the theme has changed.  An internal switch
    1:    * means it's one of our Mozilla themes that changed (e.g., Modern to Classic).
    1:    * Otherwise, the OS is telling us that the native theme for the platform
    1:    * has changed.
    1:    */
    1:   NS_HIDDEN_(void) ThemeChanged();
    1: 
    1:   /*
    1:    * Notify the pres context that a system color has changed
    1:    */
    1:   NS_HIDDEN_(void) SysColorChanged();
    1: 
    1:   /** Printing methods below should only be used for Medium() == print **/
    1:   NS_HIDDEN_(void) SetPrintSettings(nsIPrintSettings *aPrintSettings);
    1: 
    1:   nsIPrintSettings* GetPrintSettings() { return mPrintSettings; }
    1: 
    1:   /* Accessor for table of frame properties */
39965:   FramePropertyTable* PropertyTable() { return &mPropertyTable; }
    1: 
    1:   /* Helper function that ensures that this prescontext is shown in its
    1:      docshell if it's the most recent prescontext for the docshell.  Returns
    1:      whether the prescontext is now being shown.
    1:   */
29018:   NS_HIDDEN_(PRBool) EnsureVisible();
    1:   
    1: #ifdef MOZ_REFLOW_PERF
    1:   NS_HIDDEN_(void) CountReflows(const char * aName,
    1:                                 nsIFrame * aFrame);
    1: #endif
    1: 
    1:   /**
    1:    * This table maps border-width enums 'thin', 'medium', 'thick'
    1:    * to actual nscoord values.
    1:    */
    1:   const nscoord* GetBorderWidthTable() { return mBorderWidthTable; }
    1: 
  731:   PRBool IsDynamic() { return (mType == eContext_PageLayout || mType == eContext_Galley); }
    1:   PRBool IsScreen() { return (mMedium == nsGkAtoms::screen ||
    1:                               mType == eContext_PageLayout ||
  731:                               mType == eContext_PrintPreview); }
    1: 
 1540:   // Is this presentation in a chrome docshell?
42557:   PRBool IsChrome() const
40739:   {
40739:     return mIsChromeIsCached ? mIsChrome : IsChromeSlow();
40739:   }
40739: 
40739:   virtual void InvalidateIsChromeCacheExternal();
42557:   void InvalidateIsChromeCacheInternal() { mIsChromeIsCached = PR_FALSE; }
40739: #ifdef _IMPL_NS_LAYOUT
40739:   void InvalidateIsChromeCache()
40739:   { InvalidateIsChromeCacheInternal(); }
40739: #else
40739:   void InvalidateIsChromeCache()
40739:   { InvalidateIsChromeCacheExternal(); }
40739: #endif
 1540: 
 6734:   // Public API for native theme code to get style internals.
42557:   virtual PRBool HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const;
 6734: 
 8088:   // Is it OK to let the page specify colors and backgrounds?
42557:   PRBool UseDocumentColors() const {
 8088:     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
 8088:   }
 8088: 
10872:   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
10872:   
22335:   virtual NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetExternal();
22335:   NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetInternal();
22335: #ifdef _IMPL_NS_LAYOUT
22335:   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetInternal(); }
22335: #else
22335:   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetExternal(); }
22335: #endif
22335: 
21925:   void FlushUserFontSet();
21925:   void RebuildUserFontSet(); // asynchronously
19962: 
22507:   // Should be called whenever the set of fonts available in the user
22507:   // font set changes (e.g., because a new font loads, or because the
22507:   // user font set is changed and fonts become unavailable).
22507:   void UserFontSetUpdated();
22507: 
36786:   // Ensure that it is safe to hand out CSS rules outside the layout
36786:   // engine by ensuring that all CSS style sheets have unique inners
36786:   // and, if necessary, synchronously rebuilding all style data.
36786:   // Returns true on success and false on failure (not safe).
36786:   PRBool EnsureSafeToHandOutCSSRules();
36786: 
32894:   void NotifyInvalidation(const nsRect& aRect, PRUint32 aFlags);
37083:   void NotifyInvalidateForScrolling(const nsRegion& aBlitRegion,
37083:                                     const nsRegion& aInvalidateRegion);
19380:   void FireDOMPaintEvent();
23350:   PRBool IsDOMPaintEventPending() {
32894:     return !mInvalidateRequests.mRequests.IsEmpty();
23350:   }
19380: 
25579:   void ClearMozAfterPaintEvents() {
32894:     mInvalidateRequests.mRequests.Clear();
25579:   }
25579: 
38816:   PRBool IsProcessingRestyles() const {
38816:     return mProcessingRestyles;
38816:   }
38816: 
38816:   void SetProcessingRestyles(PRBool aProcessing) {
38816:     NS_ASSERTION(aProcessing != PRBool(mProcessingRestyles),
38816:                  "should never nest");
38816:     mProcessingRestyles = aProcessing;
38816:   }
38816: 
32401:   PRBool IsProcessingAnimationStyleChange() const {
32401:     return mProcessingAnimationStyleChange;
32401:   }
32401: 
32401:   void SetProcessingAnimationStyleChange(PRBool aProcessing) {
32907:     NS_ASSERTION(aProcessing != PRBool(mProcessingAnimationStyleChange),
32401:                  "should never nest");
32401:     mProcessingAnimationStyleChange = aProcessing;
32401:   }
32401: 
27993:   /**
27993:    * Notify the prescontext that the presshell is about to reflow a reflow root.
27993:    * The single argument indicates whether this reflow should be interruptible.
27993:    * If aInterruptible is false then CheckForInterrupt and HasPendingInterrupt
27993:    * will always return false. If aInterruptible is true then CheckForInterrupt
27993:    * will return true when a pending event is detected.  This is for use by the
27993:    * presshell only.  Reflow code wanting to prevent interrupts should use
27993:    * InterruptPreventer.
27993:    */
27993:   void ReflowStarted(PRBool aInterruptible);
27993: 
27993:   /**
27993:    * A class that can be used to temporarily disable reflow interruption.
27993:    */
27993:   class InterruptPreventer;
27993:   friend class InterruptPreventer;
27993:   class NS_STACK_CLASS InterruptPreventer {
27993:   public:
27993:     InterruptPreventer(nsPresContext* aCtx) :
27993:       mCtx(aCtx),
27993:       mInterruptsEnabled(aCtx->mInterruptsEnabled),
27993:       mHasPendingInterrupt(aCtx->mHasPendingInterrupt)
27993:     {
27993:       mCtx->mInterruptsEnabled = PR_FALSE;
27993:       mCtx->mHasPendingInterrupt = PR_FALSE;
27993:     }
27993:     ~InterruptPreventer() {
27993:       mCtx->mInterruptsEnabled = mInterruptsEnabled;
27993:       mCtx->mHasPendingInterrupt = mHasPendingInterrupt;
27993:     }
27993: 
27993:   private:
27993:     nsPresContext* mCtx;
27993:     PRBool mInterruptsEnabled;
27993:     PRBool mHasPendingInterrupt;
27993:   };
27993:     
27993:   /**
27993:    * Check for interrupts. This may return true if a pending event is
29172:    * detected. Once it has returned true, it will keep returning true
29172:    * until ReflowStarted is called. In all cases where this returns true,
29172:    * the passed-in frame (which should be the frame whose reflow will be
29172:    * interrupted if true is returned) will be passed to
27993:    * nsIPresShell::FrameNeedsToContinueReflow.
27993:    */
27993:   PRBool CheckForInterrupt(nsIFrame* aFrame);
27993:   /**
27993:    * Returns true if CheckForInterrupt has returned true since the last
29172:    * ReflowStarted call. Cannot itself trigger an interrupt check.
27993:    */
27993:   PRBool HasPendingInterrupt() { return mHasPendingInterrupt; }
27993: 
36653:   /**
36653:    * If we have a presshell, and if the given content's current
36653:    * document is the same as our presshell's document, return the
36653:    * content's primary frame.  Otherwise, return null.  Only use this
36653:    * if you care about which presshell the primary frame is in.
36653:    */
36653:   nsIFrame* GetPrimaryFrameFor(nsIContent* aContent) {
36653:     NS_PRECONDITION(aContent, "Don't do that");
36653:     if (GetPresShell() &&
36653:         GetPresShell()->GetDocument() == aContent->GetCurrentDoc()) {
36653:       return aContent->GetPrimaryFrame();
36653:     }
36653:     return nsnull;
36653:   }
36653: 
47756:   void NotifyDestroyingFrame(nsIFrame* aFrame)
47756:   {
47756:     PropertyTable()->DeleteAllFor(aFrame);
47756:   }
47756:   inline void ForgetUpdatePluginGeometryFrame(nsIFrame* aFrame);
47756: 
47756:   void SetContainsUpdatePluginGeometryFrame(PRBool aValue)
47756:   {
47756:     mContainsUpdatePluginGeometryFrame = aValue;
47756:   }
47756: 
47742:   PRBool MayHaveFixedBackgroundFrames() { return mMayHaveFixedBackgroundFrames; }
47742:   void SetHasFixedBackgroundFrame() { mMayHaveFixedBackgroundFrames = PR_TRUE; }
47742: 
42982:   PRUint32 EstimateMemoryUsed() {
42982:     PRUint32 result = 0;
42982: 
42982:     result += sizeof(nsPresContext);
42982:     result += GetBidiMemoryUsed();
42982: 
42982:     return result;
42982:   }
42982: 
52488:   PRBool IsRootContentDocument();
52488: 
    1: protected:
    1:   friend class nsRunnableMethod<nsPresContext>;
    1:   NS_HIDDEN_(void) ThemeChangedInternal();
    1:   NS_HIDDEN_(void) SysColorChangedInternal();
    1: 
    1:   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
23697: #ifdef MOZ_SMIL
23697:   NS_HIDDEN_(void) SetSMILAnimations(nsIDocument *aDoc, PRUint16 aNewMode,
23697:                                      PRUint16 aOldMode);
23697: #endif // MOZ_SMIL
    1:   NS_HIDDEN_(void) GetDocumentColorPreferences();
    1: 
    1:   NS_HIDDEN_(void) PreferenceChanged(const char* aPrefName);
20261:   static NS_HIDDEN_(int) PrefChangedCallback(const char*, void*);
    1: 
    1:   NS_HIDDEN_(void) UpdateAfterPreferencesChanged();
20261:   static NS_HIDDEN_(void) PrefChangedUpdateTimerCallback(nsITimer *aTimer, void *aClosure);
    1: 
    1:   NS_HIDDEN_(void) GetUserPreferences();
    1:   NS_HIDDEN_(void) GetFontPreferences();
    1: 
    1:   NS_HIDDEN_(void) UpdateCharSet(const nsAFlatCString& aCharSet);
    1: 
37083:   PRBool MayHavePaintEventListener();
37083:   void NotifyInvalidateRegion(const nsRegion& aRegion, nsPoint aOffset,
37083:                               PRUint32 aFlags);
37083: 
21925:   void HandleRebuildUserFontSet() {
21925:     mPostedFlushUserFontSet = PR_FALSE;
21925:     FlushUserFontSet();
21925:   }
21925: 
27993:   PRBool HavePendingInputEvent();
27993: 
23163:   // Can't be inline because we can't include nsStyleSet.h.
23163:   PRBool HasCachedStyleData();
23163: 
42557:   PRBool IsChromeSlow() const;
40739: 
    1:   // IMPORTANT: The ownership implicit in the following member variables
    1:   // has been explicitly checked.  If you add any members to this class,
    1:   // please make the ownership explicit (pinkerton, scc).
    1:   
    1:   nsPresContextType     mType;
    1:   nsIPresShell*         mShell;         // [WEAK]
    1:   nsCOMPtr<nsIDocument> mDocument;
    1:   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
    1:                                         // better safe than sorry.
    1:                                         // Cannot reintroduce cycles
    1:                                         // since there is no dependency
    1:                                         // from gfx back to layout.
    1:   nsIEventStateManager* mEventManager;  // [STRONG]
    1:   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
36615:   nsRefPtr<nsRefreshDriver> mRefreshDriver;
36616:   nsRefPtr<nsTransitionManager> mTransitionManager;
    1:   nsIAtom*              mMedium;        // initialized by subclass ctors;
    1:                                         // weak pointer to static atom
    1: 
    1:   nsILinkHandler*       mLinkHandler;   // [WEAK]
38492: 
38492:   // Formerly mLangGroup; moving from charset-oriented langGroup to
38492:   // maintaining actual language settings everywhere (see bug 524107).
38492:   // This may in fact hold a langGroup such as x-western rather than
38492:   // a specific language, however (e.g, if it is inferred from the
38492:   // charset rather than explicitly specified as a lang attribute).
38492:   nsIAtom*              mLanguage;      // [STRONG]
    1: 
25231:   nsRefPtrHashtable<nsVoidPtrHashKey, nsImageLoader>
25231:                         mImageLoaders[IMAGE_LOAD_TYPE_COUNT];
25231: 
    1:   nsWeakPtr             mContainer;
    1: 
    1:   float                 mTextZoom;      // Text zoom, defaults to 1.0
 4359:   float                 mFullZoom;      // Page zoom, defaults to 1.0
10872: 
 5249:   PRInt32               mCurAppUnitsPerDevPixel;
 4032:   PRInt32               mAutoQualityMinFontSizePixelsPref;
    1: 
    1: #ifdef IBMBIDI
    1:   nsBidiPresUtils*      mBidiUtils;
    1: #endif
    1: 
    1:   nsCOMPtr<nsITheme> mTheme;
    1:   nsCOMPtr<nsILanguageAtomService> mLangService;
    1:   nsCOMPtr<nsIPrintSettings> mPrintSettings;
    1:   nsCOMPtr<nsITimer>    mPrefChangedTimer;
    1: 
39965:   FramePropertyTable    mPropertyTable;
    1: 
32894:   nsInvalidateRequestList mInvalidateRequests;
19380: 
19962:   // container for per-context fonts (downloadable, SVG, etc.)
23932:   nsUserFontSet*        mUserFontSet;
21925:   // The list of @font-face rules that we put into mUserFontSet
21983:   nsTArray<nsFontFaceRuleContainer> mFontFaceRules;
19962:   
    1:   PRInt32               mFontScaler;
    1:   nscoord               mMinimumFontSize;
    1: 
    1:   nsRect                mVisibleArea;
    1:   nsSize                mPageSize;
    1:   float                 mPageScale;
    1:   float                 mPPScale;
    1: 
    1:   nscolor               mDefaultColor;
    1:   nscolor               mBackgroundColor;
    1: 
    1:   nscolor               mLinkColor;
    1:   nscolor               mActiveLinkColor;
    1:   nscolor               mVisitedLinkColor;
    1: 
    1:   nscolor               mFocusBackgroundColor;
    1:   nscolor               mFocusTextColor;
    1: 
    1:   ScrollbarStyles       mViewportStyleOverflow;
    1:   PRUint8               mFocusRingWidth;
    1: 
    1:   PRUint16              mImageAnimationMode;
    1:   PRUint16              mImageAnimationModePref;
    1: 
    1:   nsFont                mDefaultVariableFont;
    1:   nsFont                mDefaultFixedFont;
    1:   nsFont                mDefaultSerifFont;
    1:   nsFont                mDefaultSansSerifFont;
    1:   nsFont                mDefaultMonospaceFont;
    1:   nsFont                mDefaultCursiveFont;
    1:   nsFont                mDefaultFantasyFont;
    1: 
    1:   nscoord               mBorderWidthTable[3];
    1: 
27993:   PRUint32              mInterruptChecksToSkip;
27993: 
33393:   mozilla::TimeStamp    mReflowStartTime;
33393: 
27993:   unsigned              mHasPendingInterrupt : 1;
27993:   unsigned              mInterruptsEnabled : 1;
    1:   unsigned              mUseDocumentFonts : 1;
    1:   unsigned              mUseDocumentColors : 1;
    1:   unsigned              mUnderlineLinks : 1;
    1:   unsigned              mUseFocusColors : 1;
    1:   unsigned              mFocusRingOnAnything : 1;
20177:   unsigned              mFocusRingStyle : 1;
    1:   unsigned              mDrawImageBackground : 1;
    1:   unsigned              mDrawColorBackground : 1;
    1:   unsigned              mNeverAnimate : 1;
    1:   unsigned              mIsRenderingOnlySelection : 1;
    1:   unsigned              mPaginated : 1;
    1:   unsigned              mCanPaginatedScroll : 1;
    1:   unsigned              mDoScaledTwips : 1;
    1:   unsigned              mEnableJapaneseTransform : 1;
    1:   unsigned              mIsRootPaginatedDocument : 1;
    1:   unsigned              mPrefBidiDirection : 1;
    1:   unsigned              mPrefScrollbarSide : 2;
    1:   unsigned              mPendingSysColorChanged : 1;
    1:   unsigned              mPendingThemeChanged : 1;
16226:   unsigned              mPendingMediaFeatureValuesChanged : 1;
11409:   unsigned              mPrefChangePendingNeedsReflow : 1;
47742:   unsigned              mMayHaveFixedBackgroundFrames : 1;
21925: 
21925:   // Is the current mUserFontSet valid?
21924:   unsigned              mUserFontSetDirty : 1;
21925:   // Has GetUserFontSet() been called?
21925:   unsigned              mGetUserFontSetCalled : 1;
21925:   // Do we currently have an event posted to call FlushUserFontSet?
21925:   unsigned              mPostedFlushUserFontSet : 1;
    1: 
42263:   // resize reflow is suppressed when the only change has been to zoom
10872:   // the document rather than to change the document's dimensions
10872:   unsigned              mSupressResizeReflow : 1;
10872: 
    1:   unsigned              mIsVisual : 1;
    1: 
38816:   unsigned              mProcessingRestyles : 1;
32401:   unsigned              mProcessingAnimationStyleChange : 1;
32401: 
47756:   unsigned              mContainsUpdatePluginGeometryFrame : 1;
47756: 
40739:   // Cache whether we are chrome or not because it is expensive.  
40739:   // mIsChromeIsCached tells us if mIsChrome is valid or we need to get the
40739:   // value the slow way.
42557:   mutable unsigned      mIsChromeIsCached : 1;
42557:   mutable unsigned      mIsChrome : 1;
40739: 
    1: #ifdef DEBUG
    1:   PRBool                mInitialized;
    1: #endif
    1: 
    1: 
    1: protected:
    1: 
30514:   virtual ~nsPresContext() NS_HIDDEN;
    1: 
    1:   // these are private, use the list in nsFont.h if you want a public list
    1:   enum {
    1:     eDefaultFont_Variable,
    1:     eDefaultFont_Fixed,
    1:     eDefaultFont_Serif,
    1:     eDefaultFont_SansSerif,
    1:     eDefaultFont_Monospace,
    1:     eDefaultFont_Cursive,
    1:     eDefaultFont_Fantasy,
    1:     eDefaultFont_COUNT
    1:   };
    1: 
    1: #ifdef DEBUG
    1: private:
    1:   friend struct nsAutoLayoutPhase;
    1:   PRUint32 mLayoutPhaseCount[eLayoutPhase_COUNT];
    1: public:
    1:   PRUint32 LayoutPhaseCount(nsLayoutPhase aPhase) {
    1:     return mLayoutPhaseCount[aPhase];
    1:   }
    1: #endif
    1: 
    1: };
    1: 
30514: class nsRootPresContext : public nsPresContext {
30514: public:
30514:   nsRootPresContext(nsIDocument* aDocument, nsPresContextType aType) NS_HIDDEN;
30522:   virtual ~nsRootPresContext();
30522: 
30522:   /**
30522:    * Registers a plugin to receive geometry updates (position and clip
30522:    * region) so it can update its widget.
30522:    * Callers must call UnregisterPluginForGeometryUpdates before
30522:    * the aPlugin frame is destroyed.
30522:    */
30522:   void RegisterPluginForGeometryUpdates(nsObjectFrame* aPlugin);
30522:   /**
30522:    * Stops a plugin receiving geometry updates (position and clip
30522:    * region). If the plugin was not already registered, this does
30522:    * nothing.
30522:    */
30522:   void UnregisterPluginForGeometryUpdates(nsObjectFrame* aPlugin);
30522: 
30522:   /**
30522:    * Iterate through all plugins that are registered for geometry updates
30522:    * and update their position and clip region to match the current frame
47756:    * tree.
30522:    */
47756:   void UpdatePluginGeometry();
30522: 
30522:   /**
30522:    * Iterate through all plugins that are registered for geometry updates
30522:    * and compute their position and clip region according to the
30522:    * current frame tree. Only frames at or under aChangedRoot can have
30522:    * changed their geometry. The computed positions and clip regions are
30522:    * appended to aConfigurations.
30522:    */
30522:   void GetPluginGeometryUpdates(nsIFrame* aChangedRoot,
30522:                                 nsTArray<nsIWidget::Configuration>* aConfigurations);
30522: 
30524:   /**
30524:    * When all geometry updates have been applied, call this function
30524:    * in case the nsObjectFrames have work to do after the widgets
30524:    * have been updated.
30524:    */
30524:   void DidApplyPluginGeometryUpdates();
30524: 
37502:   virtual PRBool IsRoot() { return PR_TRUE; }
37502: 
47756:   /**
47756:    * This method is called off an event to force the plugin geometry to
47756:    * be updated. First we try to paint, since updating plugin geometry
47756:    * during paint is best for keeping plugins in sync with content.
47756:    * But we also force geometry updates in case painting doesn't work.
47756:    */
47756:   void ForcePluginGeometryUpdate();
47756: 
47756:   /**
47756:    * Call this after reflow and scrolling to ensure that the geometry
47756:    * of any windowed plugins is updated. aFrame is the root of the
47756:    * frame subtree whose geometry has changed.
47756:    */
47756:   void RequestUpdatePluginGeometry(nsIFrame* aFrame);
47756: 
47756:   /**
47756:    * Call this when a frame is being destroyed and
47756:    * mContainsUpdatePluginGeometryFrame is set in the frame's prescontext.
47756:    */
47756:   void RootForgetUpdatePluginGeometryFrame(nsIFrame* aFrame);
47756: 
54261:   /**
54261:    * Increment DOM-modification generation counter to indicate that
54261:    * the DOM has changed in a way that might lead to style changes/
54261:    * reflows/frame creation and destruction.
54261:    */
54261:   void IncrementDOMGeneration() { mDOMGeneration++; }
54261: 
54261:   /**
54261:    * Get the current DOM generation counter.
54261:    */
54261:   PRUint32 GetDOMGeneration() { return mDOMGeneration; }
54261: 
30522: private:
30522:   nsTHashtable<nsPtrHashKey<nsObjectFrame> > mRegisteredPlugins;
47960:   // if mNeedsToUpdatePluginGeometry is set, then this is the frame to
47960:   // use as the root of the subtree to search for plugin updates, or
47960:   // null to use the root frame of this prescontext
47756:   nsIFrame* mUpdatePluginGeometryForFrame;
54261:   PRUint32 mDOMGeneration;
47756:   PRPackedBool mNeedsToUpdatePluginGeometry;
30514: };
30514: 
47756: inline void
47756: nsPresContext::ForgetUpdatePluginGeometryFrame(nsIFrame* aFrame)
47756: {
47756:   if (mContainsUpdatePluginGeometryFrame) {
47756:     nsRootPresContext* rootPC = GetRootPresContext();
47756:     if (rootPC) {
47756:       rootPC->RootForgetUpdatePluginGeometryFrame(aFrame);
47756:     }
47756:   }
47756: }
47756: 
    1: #ifdef DEBUG
    1: 
    1: struct nsAutoLayoutPhase {
    1:   nsAutoLayoutPhase(nsPresContext* aPresContext, nsLayoutPhase aPhase)
    1:     : mPresContext(aPresContext), mPhase(aPhase), mCount(0)
    1:   {
    1:     Enter();
    1:   }
    1: 
    1:   ~nsAutoLayoutPhase()
    1:   {
    1:     Exit();
    1:     NS_ASSERTION(mCount == 0, "imbalanced");
    1:   }
    1: 
    1:   void Enter()
    1:   {
    1:     switch (mPhase) {
    1:       case eLayoutPhase_Paint:
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Paint] == 0,
    1:                      "recurring into paint");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Reflow] == 0,
    1:                      "painting in the middle of reflow");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_FrameC] == 0,
    1:                      "painting in the middle of frame construction");
    1:         break;
    1:       case eLayoutPhase_Reflow:
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Paint] == 0,
    1:                      "reflowing in the middle of a paint");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Reflow] == 0,
    1:                      "recurring into reflow");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_FrameC] == 0,
    1:                      "reflowing in the middle of frame construction");
    1:         break;
    1:       case eLayoutPhase_FrameC:
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Paint] == 0,
    1:                      "constructing frames in the middle of a paint");
 3138:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Reflow] == 0,
    1:                      "constructing frames in the middle of reflow");
33001:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_FrameC] == 0,
    1:                      "recurring into frame construction");
29087:         NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
29087:                      "constructing frames and scripts are not blocked");
    1:         break;
    1:       default:
    1:         break;
    1:     }
    1:     ++(mPresContext->mLayoutPhaseCount[mPhase]);
    1:     ++mCount;
    1:   }
    1: 
    1:   void Exit()
    1:   {
    1:     NS_ASSERTION(mCount > 0 && mPresContext->mLayoutPhaseCount[mPhase] > 0,
    1:                  "imbalanced");
    1:     --(mPresContext->mLayoutPhaseCount[mPhase]);
    1:     --mCount;
    1:   }
    1: 
    1: private:
    1:   nsPresContext *mPresContext;
    1:   nsLayoutPhase mPhase;
    1:   PRUint32 mCount;
    1: };
    1: 
    1: #define AUTO_LAYOUT_PHASE_ENTRY_POINT(pc_, phase_) \
    1:   nsAutoLayoutPhase autoLayoutPhase((pc_), (eLayoutPhase_##phase_))
    1: #define LAYOUT_PHASE_TEMP_EXIT() \
    1:   PR_BEGIN_MACRO \
    1:     autoLayoutPhase.Exit(); \
    1:   PR_END_MACRO
    1: #define LAYOUT_PHASE_TEMP_REENTER() \
    1:   PR_BEGIN_MACRO \
    1:     autoLayoutPhase.Enter(); \
    1:   PR_END_MACRO
    1: 
    1: #else
    1: 
    1: #define AUTO_LAYOUT_PHASE_ENTRY_POINT(pc_, phase_) \
    1:   PR_BEGIN_MACRO PR_END_MACRO
    1: #define LAYOUT_PHASE_TEMP_EXIT() \
    1:   PR_BEGIN_MACRO PR_END_MACRO
    1: #define LAYOUT_PHASE_TEMP_REENTER() \
    1:   PR_BEGIN_MACRO PR_END_MACRO
    1: 
    1: #endif
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1: 
    1: #define DO_GLOBAL_REFLOW_COUNT(_name) \
    1:   aPresContext->CountReflows((_name), (nsIFrame*)this); 
    1: #else
    1: #define DO_GLOBAL_REFLOW_COUNT(_name)
    1: #endif // MOZ_REFLOW_PERF
    1: 
    1: #endif /* nsPresContext_h___ */
