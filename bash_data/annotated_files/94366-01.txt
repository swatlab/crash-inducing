87729: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
87729: /* vim: set sw=2 ts=2 et tw=80 : */
87729: /* ***** BEGIN LICENSE BLOCK *****
87729:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
87729:  *
87729:  * The contents of this file are subject to the Mozilla Public License Version
87729:  * 1.1 (the "License"); you may not use this file except in compliance with
87729:  * the License. You may obtain a copy of the License at
87729:  * http://www.mozilla.org/MPL/
87729:  *
87729:  * Software distributed under the License is distributed on an "AS IS" basis,
87729:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
87729:  * for the specific language governing rights and limitations under the
87729:  * License.
87729:  *
87729:  * The Original Code is Mozilla Content App.
87729:  *
87729:  * The Initial Developer of the Original Code is
87729:  *   The Mozilla Foundation.
87729:  * Portions created by the Initial Developer are Copyright (C) 2011
87729:  * the Initial Developer. All Rights Reserved.
87729:  *
87729:  * Contributor(s):
87729:  *   Benoit Girard <bgirard@mozilla.com>
87729:  *   Ali Juma <ajuma@mozilla.com>
87729:  *
87729:  * Alternatively, the contents of this file may be used under the terms of
87729:  * either the GNU General Public License Version 2 or later (the "GPL"), or
87729:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
87729:  * in which case the provisions of the GPL or the LGPL are applicable instead
87729:  * of those above. If you wish to allow use of your version of this file only
87729:  * under the terms of either the GPL or the LGPL, and not to allow others to
87729:  * use your version of this file under the terms of the MPL, indicate your
87729:  * decision by deleting the provisions above and replace them with the notice
87729:  * and other provisions required by the GPL or the LGPL. If you do not delete
87729:  * the provisions above, a recipient may use your version of this file under
87729:  * the terms of any one of the MPL, the GPL or the LGPL.
87729:  *
87729:  * ***** END LICENSE BLOCK ***** */
87729: 
87729: #include "CompositorParent.h"
91562: #include "RenderTrace.h"
87729: #include "ShadowLayersParent.h"
87729: #include "LayerManagerOGL.h"
87729: #include "nsIWidget.h"
92853: #include "nsGkAtoms.h"
92950: #include "RenderTrace.h"
87729: 
92781: #if defined(MOZ_WIDGET_ANDROID)
92781: #include "AndroidBridge.h"
92814: #include <android/log.h>
92781: #endif
87729: 
93083: using base::Thread;
93083: 
87729: namespace mozilla {
87729: namespace layers {
87729: 
93083: CompositorParent::CompositorParent(nsIWidget* aWidget, base::Thread* aCompositorThread)
93083:   : mCompositorThread(aCompositorThread)
93083:   , mWidget(aWidget)
92818:   , mCurrentCompositeTask(NULL)
92837:   , mPaused(false)
93058:   , mIsFirstPaint(false)
93545:   , mLayersUpdated(false)
87729: {
87729:   MOZ_COUNT_CTOR(CompositorParent);
87729: }
87729: 
87729: CompositorParent::~CompositorParent()
87729: {
87729:   MOZ_COUNT_DTOR(CompositorParent);
87729: }
87729: 
87729: void
87729: CompositorParent::Destroy()
87729: {
87729:   NS_ABORT_IF_FALSE(ManagedPLayersParent().Length() == 0,
87729:                     "CompositorParent destroyed before managed PLayersParent");
87729: 
94366:   // Ensure that the layer manager is destructed on the compositor thread.
87729:   mLayerManager = NULL;
87729: }
87729: 
87729: bool
94366: CompositorParent::RecvWillStop()
94366: {
94366:   mPaused = true;
94366: 
94366:   // Ensure that the layer manager is destroyed before CompositorChild.
94366:   mLayerManager->Destroy();
94366: 
94366:   return true;
94366: }
94366: 
94366: bool
87729: CompositorParent::RecvStop()
87729: {
87729:   Destroy();
87729:   return true;
87729: }
87729: 
94309: bool
94309: CompositorParent::RecvPause()
94309: {
94309:   PauseComposition();
94309:   return true;
94309: }
94309: 
94309: bool
94309: CompositorParent::RecvResume()
94309: {
94309:   ResumeComposition();
94309:   return true;
94309: }
94309: 
87729: void
93083: CompositorParent::ScheduleRenderOnCompositorThread()
92813: {
93083:   CancelableTask *renderTask = NewRunnableMethod(this, &CompositorParent::ScheduleComposition);
93083:   mCompositorThread->message_loop()->PostTask(FROM_HERE, renderTask);
92813: }
92813: 
92813: void
92816: CompositorParent::PauseComposition()
92816: {
93083:   NS_ABORT_IF_FALSE(mCompositorThread->thread_id() == PlatformThread::CurrentId(),
93083:                     "PauseComposition() can only be called on the compositor thread");
92820:   if (!mPaused) {
92816:     mPaused = true;
92816: 
92816: #ifdef MOZ_WIDGET_ANDROID
92820:     static_cast<LayerManagerOGL*>(mLayerManager.get())->gl()->ReleaseSurface();
92816: #endif
92816:   }
92820: }
92816: 
92816: void
92816: CompositorParent::ResumeComposition()
92816: {
93083:   NS_ABORT_IF_FALSE(mCompositorThread->thread_id() == PlatformThread::CurrentId(),
93083:                     "ResumeComposition() can only be called on the compositor thread");
92816:   mPaused = false;
92816: 
92816: #ifdef MOZ_WIDGET_ANDROID
92823:   static_cast<LayerManagerOGL*>(mLayerManager.get())->gl()->RenewSurface();
92816: #endif
92816: }
92816: 
92816: void
93083: CompositorParent::SchedulePauseOnCompositorThread()
92816: {
92816:   CancelableTask *pauseTask = NewRunnableMethod(this,
92816:                                                 &CompositorParent::PauseComposition);
93083:   mCompositorThread->message_loop()->PostTask(FROM_HERE, pauseTask);
92816: }
92816: 
92816: void
93083: CompositorParent::ScheduleResumeOnCompositorThread()
92816: {
92816:   CancelableTask *resumeTask = NewRunnableMethod(this,
92816:                                                  &CompositorParent::ResumeComposition);
93083:   mCompositorThread->message_loop()->PostTask(FROM_HERE, resumeTask);
92816: }
92816: 
92816: void
87729: CompositorParent::ScheduleComposition()
87729: {
92818:   if (mCurrentCompositeTask) {
92818:     return;
92818:   }
91562: 
92848:   bool initialComposition = mLastCompose.IsNull();
92848:   TimeDuration delta;
92848:   if (!initialComposition)
92848:     delta = mozilla::TimeStamp::Now() - mLastCompose;
92819: 
92862: #ifdef COMPOSITOR_PERFORMANCE_WARNING
92862:   mExpectedComposeTime = mozilla::TimeStamp::Now() + TimeDuration::FromMilliseconds(15);
91562: #endif
91562: 
92818:   mCurrentCompositeTask = NewRunnableMethod(this, &CompositorParent::Composite);
93083: 
93083:   // Since 60 fps is the maximum frame rate we can acheive, scheduling composition
93083:   // events less than 15 ms apart wastes computation..
92848:   if (!initialComposition && delta.ToMilliseconds() < 15) {
92862: #ifdef COMPOSITOR_PERFORMANCE_WARNING
92862:     mExpectedComposeTime = mozilla::TimeStamp::Now() + TimeDuration::FromMilliseconds(15 - delta.ToMilliseconds());
92862: #endif
92819:     MessageLoop::current()->PostDelayedTask(FROM_HERE, mCurrentCompositeTask, 15 - delta.ToMilliseconds());
92819:   } else {
92818:     MessageLoop::current()->PostTask(FROM_HERE, mCurrentCompositeTask);
92819:   }
92793: }
92793: 
92793: void
92793: CompositorParent::SetTransformation(float aScale, nsIntPoint aScrollOffset)
92793: {
92793:   mXScale = aScale;
92793:   mYScale = aScale;
92793:   mScrollOffset = aScrollOffset;
87729: }
87729: 
87729: void
87729: CompositorParent::Composite()
87729: {
93083:   NS_ABORT_IF_FALSE(mCompositorThread->thread_id() == PlatformThread::CurrentId(),
93083:                     "Composite can only be called on the compositor thread");
92818:   mCurrentCompositeTask = NULL;
92818: 
92862:   mLastCompose = mozilla::TimeStamp::Now();
92862: 
93097:   if (mPaused || !mLayerManager || !mLayerManager->GetRoot()) {
87729:     return;
87729:   }
87729: 
92818: #ifdef MOZ_WIDGET_ANDROID
92904:   TransformShadowTree();
92837: #endif
92818: 
92950:   Layer* aLayer = mLayerManager->GetRoot();
92950:   mozilla::layers::RenderTraceLayers(aLayer, "0000");
92950: 
87729:   mLayerManager->EndEmptyTransaction();
92862: 
92862: #ifdef COMPOSITOR_PERFORMANCE_WARNING
92862:   if (mExpectedComposeTime + TimeDuration::FromMilliseconds(15) < mozilla::TimeStamp::Now()) {
93042:     printf_stderr("Compositor: Composite took %i ms.\n",
93042:                   15 + (int)(mozilla::TimeStamp::Now() - mExpectedComposeTime).ToMilliseconds());
87729:   }
92862: #endif
87729: }
87729: 
92837: #ifdef MOZ_WIDGET_ANDROID
92924: // Do a breadth-first search to find the first layer in the tree that is
92924: // scrollable.
92828: Layer*
92828: CompositorParent::GetPrimaryScrollableLayer()
92828: {
92828:   Layer* root = mLayerManager->GetRoot();
92828: 
92828:   nsTArray<Layer*> queue;
92828:   queue.AppendElement(root);
93083:   while (queue.Length()) {
93083:     ContainerLayer* containerLayer = queue[0]->AsContainerLayer();
93083:     queue.RemoveElementAt(0);
92828:     if (!containerLayer) {
92828:       continue;
92828:     }
92828: 
92828:     const FrameMetrics& frameMetrics = containerLayer->GetFrameMetrics();
92924:     if (frameMetrics.IsScrollable()) {
92828:       return containerLayer;
92828:     }
92828: 
92828:     Layer* child = containerLayer->GetFirstChild();
92828:     while (child) {
92828:       queue.AppendElement(child);
92828:       child = child->GetNextSibling();
92828:     }
92828:   }
92828: 
92828:   return root;
92828: }
92837: #endif
87729: 
87729: // Go down shadow layer tree, setting properties to match their non-shadow
87729: // counterparts.
87729: static void
87729: SetShadowProperties(Layer* aLayer)
87729: {
87729:   // FIXME: Bug 717688 -- Do these updates in ShadowLayersParent::RecvUpdate.
87729:   ShadowLayer* shadow = aLayer->AsShadowLayer();
87729:   shadow->SetShadowTransform(aLayer->GetTransform());
87729:   shadow->SetShadowVisibleRegion(aLayer->GetVisibleRegion());
87729:   shadow->SetShadowClipRect(aLayer->GetClipRect());
87729: 
87729:   for (Layer* child = aLayer->GetFirstChild();
87729:       child; child = child->GetNextSibling()) {
87729:     SetShadowProperties(child);
87729:   }
87729: }
87729: 
92904: void
92904: CompositorParent::TransformShadowTree()
92793: {
92908: #ifdef MOZ_WIDGET_ANDROID
92904:   Layer* layer = GetPrimaryScrollableLayer();
92904:   ShadowLayer* shadow = layer->AsShadowLayer();
92904:   ContainerLayer* container = layer->AsContainerLayer();
92793: 
92904:   const FrameMetrics* metrics = &container->GetFrameMetrics();
93060:   const gfx3DMatrix& rootTransform = mLayerManager->GetRoot()->GetTransform();
92904:   const gfx3DMatrix& currentTransform = layer->GetTransform();
92793: 
93083:   float rootScaleX = rootTransform.GetXScale();
93083:   float rootScaleY = rootTransform.GetYScale();
93060: 
93060:   if (mIsFirstPaint && metrics) {
93060:     nsIntPoint scrollOffset = metrics->mViewportScrollOffset;
93060:     mContentSize = metrics->mContentSize;
93060:     mozilla::AndroidBridge::Bridge()->SetFirstPaintViewport(scrollOffset.x, scrollOffset.y,
93060:                                                             1/rootScaleX, mContentSize.width,
93060:                                                             mContentSize.height);
93060:     mIsFirstPaint = false;
93060:   } else if (metrics && (metrics->mContentSize != mContentSize)) {
93060:     mContentSize = metrics->mContentSize;
93060:     mozilla::AndroidBridge::Bridge()->SetPageSize(1/rootScaleX, mContentSize.width,
93060:                                                   mContentSize.height);
93060:   }
93060: 
93398:   // We synchronise the viewport information with Java after sending the above
93398:   // notifications, so that Java can take these into account in its response.
93544:   if (metrics) {
93544:     // Calculate the absolute display port to send to Java
93544:     nsIntRect displayPort = metrics->mDisplayPort;
93544:     nsIntPoint scrollOffset = metrics->mViewportScrollOffset;
93544:     displayPort.x += scrollOffset.x;
93544:     displayPort.y += scrollOffset.y;
93544: 
93545:     mozilla::AndroidBridge::Bridge()->SyncViewportInfo(displayPort, 1/rootScaleX, mLayersUpdated,
93545:                                                        mScrollOffset, mXScale, mYScale);
93545:     mLayersUpdated = false;
93544:   }
93060: 
93060:   // Handle transformations for asynchronous panning and zooming. We determine the
93060:   // zoom used by Gecko from the transformation set on the root layer, and we
93060:   // determine the scroll offset used by Gecko from the frame metrics of the
93060:   // primary scrollable layer. We compare this to the desired zoom and scroll
93060:   // offset in the view transform we obtained from Java in order to compute the
93060:   // transformation we need to apply.
92924:   if (metrics && metrics->IsScrollable()) {
93060:     float tempScaleDiffX = rootScaleX * mXScale;
93060:     float tempScaleDiffY = rootScaleY * mYScale;
92793: 
92793:     nsIntPoint metricsScrollOffset = metrics->mViewportScrollOffset;
92793: 
92793:     nsIntPoint scrollCompensation(
92904:       (mScrollOffset.x / tempScaleDiffX - metricsScrollOffset.x) * mXScale,
92904:       (mScrollOffset.y / tempScaleDiffY - metricsScrollOffset.y) * mYScale);
93060:     ViewTransform treeTransform(-scrollCompensation, mXScale, mYScale);
93060:     shadow->SetShadowTransform(gfx3DMatrix(treeTransform) * currentTransform);
92924:   } else {
93060:     ViewTransform treeTransform(nsIntPoint(0,0), mXScale, mYScale);
93060:     shadow->SetShadowTransform(gfx3DMatrix(treeTransform) * currentTransform);
92924:   }
92908: #endif
92793: }
92793: 
87729: void
93058: CompositorParent::ShadowLayersUpdated(bool isFirstPaint)
87729: {
93058:   mIsFirstPaint = mIsFirstPaint || isFirstPaint;
93545:   mLayersUpdated = true;
87729:   const nsTArray<PLayersParent*>& shadowParents = ManagedPLayersParent();
87729:   NS_ABORT_IF_FALSE(shadowParents.Length() <= 1,
87729:                     "can only support at most 1 ShadowLayersParent");
87729:   if (shadowParents.Length()) {
87729:     Layer* root = static_cast<ShadowLayersParent*>(shadowParents[0])->GetRoot();
87729:     mLayerManager->SetRoot(root);
87729:     SetShadowProperties(root);
87729:   }
87729:   ScheduleComposition();
87729: }
87729: 
87729: PLayersParent*
87729: CompositorParent::AllocPLayers(const LayersBackend &backendType)
87729: {
87729:   if (backendType == LayerManager::LAYERS_OPENGL) {
87729:     nsRefPtr<LayerManagerOGL> layerManager = new LayerManagerOGL(mWidget);
87729:     mWidget = NULL;
87729:     mLayerManager = layerManager;
87729: 
87729:     if (!layerManager->Initialize()) {
87729:       NS_ERROR("Failed to init OGL Layers");
87729:       return NULL;
87729:     }
87729: 
87729:     ShadowLayerManager* slm = layerManager->AsShadowManager();
87729:     if (!slm) {
87729:       return NULL;
87729:     }
87729:     return new ShadowLayersParent(slm, this);
87729:   } else {
87729:     NS_ERROR("Unsupported backend selected for Async Compositor");
87729:     return NULL;
87729:   }
87729: }
87729: 
87729: bool
87729: CompositorParent::DeallocPLayers(PLayersParent* actor)
87729: {
87729:   delete actor;
87729:   return true;
87729: }
87729: 
87729: } // namespace layers
87729: } // namespace mozilla
87729: 
