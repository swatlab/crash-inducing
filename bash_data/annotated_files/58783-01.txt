    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *   Chris Saari <saari@netscape.com>
    1:  *   Asko Tontti <atontti@cc.hut.fi>
    1:  *   Arron Mogge <paper@animecity.nu>
    1:  *   Andrew Smith
 7009:  *   Federico Mena-Quintero <federico@novell.com>
32424:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsComponentManagerUtils.h"
    1: #include "imgIContainerObserver.h"
 7009: #include "ImageErrors.h"
51248: #include "Decoder.h"
 7009: #include "imgIDecoderObserver.h"
50551: #include "RasterImage.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsAutoPtr.h"
 7009: #include "nsStringStream.h"
 7009: #include "prmem.h"
 7009: #include "prlog.h"
 7009: #include "prenv.h"
32424: #include "nsTime.h"
32424: #include "ImageLogging.h"
    1: 
51234: #include "nsPNGDecoder.h"
51234: #include "nsGIFDecoder2.h"
51234: #include "nsJPEGDecoder.h"
51234: #include "nsBMPDecoder.h"
51234: #include "nsICODecoder.h"
51234: #include "nsIconDecoder.h"
51234: 
    1: #include "gfxContext.h"
    1: 
50547: using namespace mozilla::imagelib;
50547: 
 7009: /* Accounting for compressed data */
 7009: #if defined(PR_LOGGING)
 7009: static PRLogModuleInfo *gCompressedImageAccountingLog = PR_NewLogModule ("CompressedImageAccounting");
 7009: #else
 7009: #define gCompressedImageAccountingLog
 7009: #endif
 7009: 
51590: // Tweakable progressive decoding parameters
51590: static PRUint32 gDecodeBytesAtATime = 200000;
51590: static PRUint32 gMaxMSBeforeYield = 400;
51595: static PRUint32 gMaxBytesForSyncDecode = 150000;
51590: 
51590: void
51590: RasterImage::SetDecodeBytesAtATime(PRUint32 aBytesAtATime)
51590: {
51590:   gDecodeBytesAtATime = aBytesAtATime;
51590: }
51590: void
51590: RasterImage::SetMaxMSBeforeYield(PRUint32 aMaxMS)
51590: {
51590:   gMaxMSBeforeYield = aMaxMS;
51590: }
51595: void
51595: RasterImage::SetMaxBytesForSyncDecode(PRUint32 aMaxBytes)
51595: {
51595:   gMaxBytesForSyncDecode = aMaxBytes;
51595: }
51590: 
32424: /* We define our own error checking macros here for 2 reasons:
32424:  *
32424:  * 1) Most of the failures we encounter here will (hopefully) be
32424:  * the result of decoding failures (ie, bad data) and not code
32424:  * failures. As such, we don't want to clutter up debug consoles
32424:  * with spurious messages about NS_ENSURE_SUCCESS failures.
32424:  *
32424:  * 2) We want to set the internal error flag, shutdown properly,
32424:  * and end up in an error state.
32424:  *
32424:  * So this macro should be called when the desired failure behavior
32424:  * is to put the container into an error state and return failure.
32424:  * It goes without saying that macro won't compile outside of a
50549:  * non-static RasterImage method.
32424:  */
32424: #define LOG_CONTAINER_ERROR                      \
32424:   PR_BEGIN_MACRO                                 \
32424:   PR_LOG (gImgLog, PR_LOG_ERROR,                 \
50549:           ("RasterImage: [this=%p] Error "      \
32424:            "detected at line %u for image of "   \
32424:            "type %s\n", this, __LINE__,          \
32424:            mSourceDataMimeType.get()));          \
32424:   PR_END_MACRO
32424: 
32424: #define CONTAINER_ENSURE_SUCCESS(status)      \
32424:   PR_BEGIN_MACRO                              \
32424:   nsresult _status = status; /* eval once */  \
32424:   if (_status) {                              \
32424:     LOG_CONTAINER_ERROR;                      \
32424:     DoError();                                \
32424:     return _status;                           \
32424:   }                                           \
32424:  PR_END_MACRO
32424: 
32424: #define CONTAINER_ENSURE_TRUE(arg, rv)  \
32424:   PR_BEGIN_MACRO                        \
32424:   if (!(arg)) {                         \
32424:     LOG_CONTAINER_ERROR;                \
32424:     DoError();                          \
32424:     return rv;                          \
32424:   }                                     \
32424:   PR_END_MACRO
32424: 
32424: 
32424: 
32424: static int num_containers;
32424: static int num_discardable_containers;
32424: static PRInt64 total_source_bytes;
32424: static PRInt64 discardable_source_bytes;
32424: 
32424: /* Are we globally disabling image discarding? */
32424: static PRBool
32424: DiscardingEnabled()
32424: {
32424:   static PRBool inited;
32424:   static PRBool enabled;
32424: 
32424:   if (!inited) {
32424:     inited = PR_TRUE;
32424: 
32424:     enabled = (PR_GetEnv("MOZ_DISABLE_IMAGE_DISCARD") == nsnull);
32424:   }
32424: 
32424:   return enabled;
32424: }
32424: 
50549: namespace mozilla {
50549: namespace imagelib {
50549: 
52150: #ifndef DEBUG
50549: NS_IMPL_ISUPPORTS4(RasterImage, imgIContainer, nsITimerCallback, nsIProperties,
32424:                    nsISupportsWeakReference)
52150: #else
52150: NS_IMPL_ISUPPORTS5(RasterImage, imgIContainer, nsITimerCallback, nsIProperties,
52150:                    imgIContainerDebug, nsISupportsWeakReference)
52150: #endif
    1: 
    1: //******************************************************************************
51296: RasterImage::RasterImage(imgStatusTracker* aStatusTracker) :
51296:   Image(aStatusTracker), // invoke superclass's constructor
    1:   mSize(0,0),
    1:   mAnim(nsnull),
    1:   mLoopCount(-1),
 7009:   mObserver(nsnull),
42233:   mLockCount(0),
42233:   mDecoder(nsnull),
42233:   mWorker(nsnull),
42233:   mBytesDecoded(0),
52150: #ifdef DEBUG
52150:   mFramesNotified(0),
52150: #endif
42233:   mHasSize(PR_FALSE),
32424:   mDecodeOnDraw(PR_FALSE),
32424:   mMultipart(PR_FALSE),
 7009:   mDiscardable(PR_FALSE),
32424:   mHasSourceData(PR_FALSE),
32424:   mDecoded(PR_FALSE),
33531:   mHasBeenDecoded(PR_FALSE),
32424:   mWorkerPending(PR_FALSE),
32424:   mInDecoder(PR_FALSE),
52149:   mAnimationFinished(PR_FALSE)
    1: {
46991:   // Set up the discard tracker node.
46991:   mDiscardTrackerNode.curr = this;
46991:   mDiscardTrackerNode.prev = mDiscardTrackerNode.next = nsnull;
46991: 
32424:   // Statistics
32424:   num_containers++;
    1: }
    1: 
    1: //******************************************************************************
50549: RasterImage::~RasterImage()
    1: {
    1:   if (mAnim)
    1:     delete mAnim;
 7009: 
30479:   for (unsigned int i = 0; i < mFrames.Length(); ++i)
30479:     delete mFrames[i];
30479: 
32424:   // Discardable statistics
32424:   if (mDiscardable) {
32424:     num_discardable_containers--;
32424:     discardable_source_bytes -= mSourceData.Length();
 7009: 
 7009:     PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
50549:             ("CompressedImageAccounting: destroying RasterImage %p.  "
32424:              "Total Containers: %d, Discardable containers: %d, "
32424:              "Total source bytes: %lld, Source bytes for discardable containers %lld",
 7009:              this,
32424:              num_containers,
32424:              num_discardable_containers,
32424:              total_source_bytes,
32424:              discardable_source_bytes));
 7009:   }
 7009: 
50547:   DiscardTracker::Remove(&mDiscardTrackerNode);
32424: 
32424:   // If we have a decoder open, shut it down
32424:   if (mDecoder) {
32424:     nsresult rv = ShutdownDecoder(eShutdownIntent_Interrupted);
32424:     if (NS_FAILED(rv))
32424:       NS_WARNING("Failed to shut down decoder in destructor!");
    1:   }
    1: 
32424:   // Total statistics
32424:   num_containers--;
32424:   total_source_bytes -= mSourceData.Length();
32424: }
32424: 
50555: nsresult
50550: RasterImage::Init(imgIDecoderObserver *aObserver,
32424:                   const char* aMimeType,
53660:                   const char* aURIString,
32424:                   PRUint32 aFlags)
    1: {
32424:   // We don't support re-initialization
32424:   if (mInitialized)
32424:     return NS_ERROR_ILLEGAL_VALUE;
32424: 
32424:   // Not sure an error can happen before init, but be safe
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ENSURE_ARG_POINTER(aMimeType);
32424: 
32424:   // We must be non-discardable and non-decode-on-draw for
32424:   // multipart channels
32424:   NS_ABORT_IF_FALSE(!(aFlags & INIT_FLAG_MULTIPART) ||
32424:                     (!(aFlags & INIT_FLAG_DISCARDABLE) &&
32424:                      !(aFlags & INIT_FLAG_DECODE_ON_DRAW)),
32424:                     "Can't be discardable or decode-on-draw for multipart");
32424: 
32424:   // Store initialization data
32424:   mObserver = do_GetWeakReference(aObserver);
32424:   mSourceDataMimeType.Assign(aMimeType);
53660:   mURIString.Assign(aURIString);
42808:   mDiscardable = !!(aFlags & INIT_FLAG_DISCARDABLE);
42808:   mDecodeOnDraw = !!(aFlags & INIT_FLAG_DECODE_ON_DRAW);
42808:   mMultipart = !!(aFlags & INIT_FLAG_MULTIPART);
32424: 
32424:   // Statistics
32424:   if (mDiscardable) {
32424:     num_discardable_containers++;
32424:     discardable_source_bytes += mSourceData.Length();
32424:   }
32424: 
32424:   // If we're being called from ExtractFrame (used by borderimage),
32424:   // we don't actually do any decoding. Bail early.
32424:   // XXX - This should be removed when we fix borderimage
32424:   if (mSourceDataMimeType.Length() == 0) {
32424:     mInitialized = PR_TRUE;
32424:     return NS_OK;
32424:   }
32424: 
32424:   // Instantiate the decoder
51244:   //
51244:   // If we're doing decode-on-draw, we want to do a quick first pass to get
51244:   // the size but nothing else. We instantiate another decoder later to do
51244:   // the full decoding.
51244:   nsresult rv = InitDecoder(/* aDoSizeDecode = */ mDecodeOnDraw);
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
32424:   // Mark us as initialized
32424:   mInitialized = PR_TRUE;
32424: 
32424:   return NS_OK;
32424: }
32424: 
32424: //******************************************************************************
32424: /* [noscript] imgIContainer extractFrame(PRUint32 aWhichFrame,
32424:  *                                       [const] in nsIntRect aRegion,
32424:  *                                       in PRUint32 aFlags); */
50550: NS_IMETHODIMP
50550: RasterImage::ExtractFrame(PRUint32 aWhichFrame,
32424:                           const nsIntRect &aRegion,
32424:                           PRUint32 aFlags,
32424:                           imgIContainer **_retval)
32424: {
32424:   NS_ENSURE_ARG_POINTER(_retval);
32424: 
32424:   nsresult rv;
32424: 
32424:   if (aWhichFrame > FRAME_MAX_VALUE)
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
48223:   // Disallowed in the API
48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
48223:     return NS_ERROR_FAILURE;
48223: 
32424:   // Make a new container. This should switch to another class with bug 505959.
50549:   nsRefPtr<RasterImage> img(new RasterImage());
32424:   NS_ENSURE_TRUE(img, NS_ERROR_OUT_OF_MEMORY);
32424: 
32424:   // We don't actually have a mimetype in this case. The empty string tells the
32424:   // init routine not to try to instantiate a decoder. This should be fixed in
32424:   // bug 505959.
53660:   img->Init(nsnull, "", "", INIT_FLAG_NONE);
32424:   img->SetSize(aRegion.width, aRegion.height);
32424:   img->mDecoded = PR_TRUE; // Also, we need to mark the image as decoded
33531:   img->mHasBeenDecoded = PR_TRUE;
32424: 
32424:   // If a synchronous decode was requested, do it
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     rv = SyncDecode();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Get the frame. If it's not there, it's probably the caller's fault for
32424:   // not waiting for the data to be loaded from the network or not passing
32424:   // FLAG_SYNC_DECODE
32424:   PRUint32 frameIndex = (aWhichFrame == FRAME_FIRST) ?
32424:                         0 : GetCurrentImgFrameIndex();
34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
32424:   if (!frame) {
32424:     *_retval = nsnull;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
30479:   // The frame can be smaller than the image. We want to extract only the part
30479:   // of the frame that actually exists.
30479:   nsIntRect framerect = frame->GetRect();
30479:   framerect.IntersectRect(framerect, aRegion);
30479: 
31137:   if (framerect.IsEmpty())
31137:     return NS_ERROR_NOT_AVAILABLE;
31137: 
30479:   nsAutoPtr<imgFrame> subframe;
32424:   rv = frame->Extract(framerect, getter_Transfers(subframe));
30479:   if (NS_FAILED(rv))
30479:     return rv;
30479: 
30479:   img->mFrames.AppendElement(subframe.forget());
30479: 
51296:   img->mStatusTracker->RecordLoaded();
51296:   img->mStatusTracker->RecordDecoded();
48320: 
30479:   *_retval = img.forget().get();
30479: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* readonly attribute PRInt32 width; */
50550: NS_IMETHODIMP
50550: RasterImage::GetWidth(PRInt32 *aWidth)
    1: {
13362:   NS_ENSURE_ARG_POINTER(aWidth);
    1: 
54975:   if (mError) {
54975:     *aWidth = 0;
32424:     return NS_ERROR_FAILURE;
54975:   }
32424: 
    1:   *aWidth = mSize.width;
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* readonly attribute PRInt32 height; */
50550: NS_IMETHODIMP
50550: RasterImage::GetHeight(PRInt32 *aHeight)
    1: {
13362:   NS_ENSURE_ARG_POINTER(aHeight);
    1: 
54975:   if (mError) {
54975:     *aHeight = 0;
32424:     return NS_ERROR_FAILURE;
54975:   }
32424: 
    1:   *aHeight = mSize.height;
    1:   return NS_OK;
    1: }
    1: 
50552: //******************************************************************************
50552: /* unsigned short GetType(); */
50552: NS_IMETHODIMP
50552: RasterImage::GetType(PRUint16 *aType)
50552: {
50552:   NS_ENSURE_ARG_POINTER(aType);
50552: 
58783:   *aType = GetType();
50552:   return NS_OK;
50552: }
50552: 
58783: //******************************************************************************
58783: /* [noscript, notxpcom] PRUint16 GetType(); */
58783: NS_IMETHODIMP_(PRUint16)
58783: RasterImage::GetType()
58783: {
58783:   return imgIContainer::TYPE_RASTER;
58783: }
58783: 
50550: imgFrame*
50550: RasterImage::GetImgFrame(PRUint32 framenum)
 7009: {
32424:   nsresult rv = WantDecodedFrames();
32424:   CONTAINER_ENSURE_TRUE(NS_SUCCEEDED(rv), nsnull);
 7009: 
30479:   if (!mAnim) {
30479:     NS_ASSERTION(framenum == 0, "Don't ask for a frame > 0 if we're not animated!");
30479:     return mFrames.SafeElementAt(0, nsnull);
30479:   }
30479:   if (mAnim->lastCompositedFrameIndex == PRInt32(framenum))
13362:     return mAnim->compositingFrame;
30479:   return mFrames.SafeElementAt(framenum, nsnull);
30479: }
30479: 
50550: imgFrame*
50550: RasterImage::GetDrawableImgFrame(PRUint32 framenum)
34809: {
34809:   imgFrame *frame = GetImgFrame(framenum);
34809: 
34809:   // We will return a paletted frame if it's not marked as compositing failed
34809:   // so we can catch crashes for reasons we haven't investigated.
34809:   if (frame && frame->GetCompositingFailed())
34809:     return nsnull;
34809:   return frame;
34809: }
34809: 
50550: PRUint32
50550: RasterImage::GetCurrentImgFrameIndex() const
30479: {
30479:   if (mAnim)
30479:     return mAnim->currentAnimationFrameIndex;
30479: 
30479:   return 0;
30479: }
30479: 
50550: imgFrame*
50550: RasterImage::GetCurrentImgFrame()
30479: {
30479:   return GetImgFrame(GetCurrentImgFrameIndex());
 7009: }
 7009: 
50550: imgFrame*
50550: RasterImage::GetCurrentDrawableImgFrame()
34809: {
34809:   return GetDrawableImgFrame(GetCurrentImgFrameIndex());
34809: }
34809: 
    1: //******************************************************************************
30479: /* readonly attribute boolean currentFrameIsOpaque; */
50550: NS_IMETHODIMP
50550: RasterImage::GetCurrentFrameIsOpaque(PRBool *aIsOpaque)
    1: {
30479:   NS_ENSURE_ARG_POINTER(aIsOpaque);
 7009: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // See if we can get an image frame
30479:   imgFrame *curframe = GetCurrentImgFrame();
32424: 
32424:   // If we don't get a frame, the safe answer is "not opaque"
32424:   if (!curframe)
32424:     *aIsOpaque = PR_FALSE;
32424: 
32424:   // Otherwise, we can make a more intelligent decision
32424:   else {
30479:     *aIsOpaque = !curframe->GetNeedsBackground();
30479: 
30479:     // We are also transparent if the current frame's size doesn't cover our
30479:     // entire area.
30479:     nsIntRect framerect = curframe->GetRect();
30479:     *aIsOpaque = *aIsOpaque && (framerect != nsIntRect(0, 0, mSize.width, mSize.height));
32424:   }
30479: 
30479:   return NS_OK;
30479: }
30479: 
51294: void
50550: RasterImage::GetCurrentFrameRect(nsIntRect& aRect)
30479: {
32424:   // Get the current frame
30479:   imgFrame* curframe = GetCurrentImgFrame();
32424: 
32424:   // If we have the frame, use that rectangle
51294:   if (curframe) {
30479:     aRect = curframe->GetRect();
51294:   } else {
32424:     // If the frame doesn't exist, we pass the empty rectangle. It's not clear
32424:     // whether this is appropriate in general, but at the moment the only
51294:     // consumer of this method is imgStatusTracker (when it wants to figure out
51294:     // dirty rectangles to send out batched observer updates). This should
51294:     // probably be revisited when we fix bug 503973.
32424:     aRect.MoveTo(0, 0);
32424:     aRect.SizeTo(0, 0);
32424:   }
30479: }
30479: 
51231: PRUint32
51231: RasterImage::GetCurrentFrameIndex()
30479: {
51231:   return GetCurrentImgFrameIndex();
    1: }
    1: 
51231: PRUint32
51231: RasterImage::GetNumFrames()
    1: {
51231:   return mFrames.Length();
    1: }
    1: 
    1: //******************************************************************************
30479: /* readonly attribute boolean animated; */
50550: NS_IMETHODIMP
50550: RasterImage::GetAnimated(PRBool *aAnimated)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(aAnimated);
30479: 
33531:   // If we have mAnim, we can know for sure
33531:   if (mAnim) {
33531:     *aAnimated = PR_TRUE;
33531:     return NS_OK;
33531:   }
33531: 
33531:   // Otherwise, we need to have been decoded to know for sure, since if we were
33531:   // decoded at least once mAnim would have been created for animated images
33531:   if (!mHasBeenDecoded)
33531:     return NS_ERROR_NOT_AVAILABLE;
33531: 
33531:   // We know for sure
33531:   *aAnimated = PR_FALSE;
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: 
30479: //******************************************************************************
32424: /* [noscript] gfxImageSurface copyFrame(in PRUint32 aWhichFrame,
32424:  *                                      in PRUint32 aFlags); */
50550: NS_IMETHODIMP
50550: RasterImage::CopyFrame(PRUint32 aWhichFrame,
32424:                        PRUint32 aFlags,
32424:                        gfxImageSurface **_retval)
    1: {
32424:   if (aWhichFrame > FRAME_MAX_VALUE)
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
48223:   // Disallowed in the API
48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
48223:     return NS_ERROR_FAILURE;
48223: 
32424:   nsresult rv;
32424: 
32424:   // If requested, synchronously flush any data we have lying around to the decoder
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     rv = SyncDecode();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
13362:   NS_ENSURE_ARG_POINTER(_retval);
 7009: 
32424:   // Get the frame. If it's not there, it's probably the caller's fault for
32424:   // not waiting for the data to be loaded from the network or not passing
32424:   // FLAG_SYNC_DECODE
32424:   PRUint32 frameIndex = (aWhichFrame == FRAME_FIRST) ?
32424:                         0 : GetCurrentImgFrameIndex();
34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
32424:   if (!frame) {
32424:     *_retval = nsnull;
32424:     return NS_ERROR_FAILURE;
32424:   }
30479: 
30479:   nsRefPtr<gfxPattern> pattern;
30479:   frame->GetPattern(getter_AddRefs(pattern));
30479:   nsIntRect intframerect = frame->GetRect();
30479:   gfxRect framerect(intframerect.x, intframerect.y, intframerect.width, intframerect.height);
30479: 
30479:   // Create a 32-bit image surface of our size, but draw using the frame's
30479:   // rect, implicitly padding the frame out to the image's size.
30479:   nsRefPtr<gfxImageSurface> imgsurface = new gfxImageSurface(gfxIntSize(mSize.width, mSize.height),
30479:                                                              gfxASurface::ImageFormatARGB32);
30479:   gfxContext ctx(imgsurface);
30479:   ctx.SetOperator(gfxContext::OPERATOR_SOURCE);
30479:   ctx.SetPattern(pattern);
30479:   ctx.Rectangle(framerect);
30479:   ctx.Fill();
30479: 
30479:   *_retval = imgsurface.forget().get();
 3538:   return NS_OK;
30479: }
 3538: 
30479: //******************************************************************************
32424: /* [noscript] gfxASurface getFrame(in PRUint32 aWhichFrame,
32424:  *                                 in PRUint32 aFlags); */
50550: NS_IMETHODIMP
50550: RasterImage::GetFrame(PRUint32 aWhichFrame,
32424:                       PRUint32 aFlags,
32424:                       gfxASurface **_retval)
30479: {
32424:   if (aWhichFrame > FRAME_MAX_VALUE)
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
48223:   // Disallowed in the API
48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
48223:     return NS_ERROR_FAILURE;
48223: 
32424:   nsresult rv = NS_OK;
32424: 
32424:   // If the caller requested a synchronous decode, do it
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     rv = SyncDecode();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Get the frame. If it's not there, it's probably the caller's fault for
32424:   // not waiting for the data to be loaded from the network or not passing
32424:   // FLAG_SYNC_DECODE
32424:   PRUint32 frameIndex = (aWhichFrame == FRAME_FIRST) ?
32424:                           0 : GetCurrentImgFrameIndex();
34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
32424:   if (!frame) {
32424:     *_retval = nsnull;
32424:     return NS_ERROR_FAILURE;
32424:   }
 7009: 
30479:   nsRefPtr<gfxASurface> framesurf;
 3538: 
30479:   // If this frame covers the entire image, we can just reuse its existing
30479:   // surface.
30479:   nsIntRect framerect = frame->GetRect();
30479:   if (framerect.x == 0 && framerect.y == 0 &&
30479:       framerect.width == mSize.width &&
30479:       framerect.height == mSize.height)
30479:     rv = frame->GetSurface(getter_AddRefs(framesurf));
    1: 
30479:   // The image doesn't have a surface because it's been optimized away. Create
30479:   // one.
30479:   if (!framesurf) {
30479:     nsRefPtr<gfxImageSurface> imgsurf;
32424:     rv = CopyFrame(aWhichFrame, aFlags, getter_AddRefs(imgsurf));
30479:     framesurf = imgsurf;
30479:   }
30479: 
30479:   *_retval = framesurf.forget().get();
30479: 
30479:   return rv;
30479: }
30479: 
51231: PRUint32
50550: RasterImage::GetDecodedDataSize()
42553: {
42553:   PRUint32 val = 0;
32424:   for (PRUint32 i = 0; i < mFrames.Length(); ++i) {
32424:     imgFrame *frame = mFrames.SafeElementAt(i, nsnull);
32424:     NS_ABORT_IF_FALSE(frame, "Null frame in frame array!");
42553:     val += frame->EstimateMemoryUsed();
    1:   }
    1: 
42553:   return val;
42553: }
42553: 
50550: PRUint32
50550: RasterImage::GetSourceDataSize()
42553: {
54949:   PRUint32 sourceDataSize = mSourceData.Length();
54949:   
54949:   NS_ABORT_IF_FALSE(StoringSourceData() || (sourceDataSize == 0),
54949:                     "Non-zero source data size when we aren't storing it?");
54949:   return sourceDataSize;
30479: }
30479: 
50550: void
50550: RasterImage::DeleteImgFrame(PRUint32 framenum)
39120: {
39120:   NS_ABORT_IF_FALSE(framenum < mFrames.Length(), "Deleting invalid frame!");
39120: 
39120:   delete mFrames[framenum];
39120:   mFrames[framenum] = nsnull;
39120: }
39120: 
50550: nsresult
50550: RasterImage::InternalAddFrameHelper(PRUint32 framenum, imgFrame *aFrame,
30479:                                     PRUint8 **imageData, PRUint32 *imageLength,
30479:                                     PRUint32 **paletteData, PRUint32 *paletteLength)
30479: {
32424:   NS_ABORT_IF_FALSE(framenum <= mFrames.Length(), "Invalid frame index!");
32424:   if (framenum > mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   nsAutoPtr<imgFrame> frame(aFrame);
30479: 
30479:   if (paletteData && paletteLength)
30479:     frame->GetPaletteData(paletteData, paletteLength);
30479: 
30479:   frame->GetImageData(imageData, imageLength);
30479: 
38698:   // We are in the middle of decoding. This will be unlocked when we finish the
38698:   // decoder->Write() call.
38698:   frame->LockImageData();
38698: 
30479:   mFrames.InsertElementAt(framenum, frame.forget());
 7009: 
    1:   return NS_OK;
    1: }
    1:                                   
50550: nsresult
50550: RasterImage::InternalAddFrame(PRUint32 framenum,
30479:                               PRInt32 aX, PRInt32 aY,
30479:                               PRInt32 aWidth, PRInt32 aHeight,
30479:                               gfxASurface::gfxImageFormat aFormat,
30479:                               PRUint8 aPaletteDepth,
30479:                               PRUint8 **imageData,
30479:                               PRUint32 *imageLength,
30479:                               PRUint32 **paletteData,
30479:                               PRUint32 *paletteLength)
30479: {
38698:   // We assume that we're in the middle of decoding because we unlock the
38698:   // previous frame when we create a new frame, and only when decoding do we
38698:   // lock frames.
38698:   NS_ABORT_IF_FALSE(mInDecoder, "Only decoders may add frames!");
38698: 
32424:   NS_ABORT_IF_FALSE(framenum <= mFrames.Length(), "Invalid frame index!");
32424:   if (framenum > mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   nsAutoPtr<imgFrame> frame(new imgFrame());
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_OUT_OF_MEMORY);
30479: 
30479:   nsresult rv = frame->Init(aX, aY, aWidth, aHeight, aFormat, aPaletteDepth);
30479:   NS_ENSURE_SUCCESS(rv, rv);
30479: 
38698:   // We know we are in a decoder. Therefore, we must unlock the previous frame
38698:   // when we move on to decoding into the next frame.
38698:   if (mFrames.Length() > 0) {
38698:     imgFrame *prevframe = mFrames.ElementAt(mFrames.Length() - 1);
38698:     prevframe->UnlockImageData();
38698:   }
38698: 
30479:   if (mFrames.Length() == 0) {
30479:     return InternalAddFrameHelper(framenum, frame.forget(), imageData, imageLength, 
30479:                                   paletteData, paletteLength);
30479:   }
30479: 
30479:   if (mFrames.Length() == 1) {
 7089:     // Since we're about to add our second frame, initialize animation stuff
    1:     if (!ensureAnimExists())
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     // If we dispose of the first frame by clearing it, then the
    1:     // First Frame's refresh area is all of itself.
    1:     // RESTORE_PREVIOUS is invalid (assumed to be DISPOSE_CLEAR)
30479:     PRInt32 frameDisposalMethod = mFrames[0]->GetFrameDisposalMethod();
50553:     if (frameDisposalMethod == kDisposeClear ||
50553:         frameDisposalMethod == kDisposeRestorePrevious)
30479:       mAnim->firstFrameRefreshArea = mFrames[0]->GetRect();
    1:   }
    1: 
    1:   // Calculate firstFrameRefreshArea
    1:   // Some gifs are huge but only have a small area that they animate
    1:   // We only need to refresh that small area when Frame 0 comes around again
30479:   nsIntRect frameRect = frame->GetRect();
    1:   mAnim->firstFrameRefreshArea.UnionRect(mAnim->firstFrameRefreshArea, 
30479:                                          frameRect);
    1:   
30479:   rv = InternalAddFrameHelper(framenum, frame.forget(), imageData, imageLength,
30479:                               paletteData, paletteLength);
 7009:   
52149:   // We may be able to start animating, if we now have enough frames
52149:   EvaluateAnimation();
    1:   
30479:   return rv;
30479: }
30479: 
50553: nsresult
50550: RasterImage::AppendFrame(PRInt32 aX, PRInt32 aY, PRInt32 aWidth,
30479:                          PRInt32 aHeight,
30479:                          gfxASurface::gfxImageFormat aFormat,
30479:                          PRUint8 **imageData,
30479:                          PRUint32 *imageLength)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(imageData);
30479:   NS_ENSURE_ARG_POINTER(imageLength);
30479: 
32424:   return InternalAddFrame(mFrames.Length(), aX, aY, aWidth, aHeight, aFormat, 
30479:                           /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                           /* aPaletteData = */ nsnull, 
30479:                           /* aPaletteLength = */ nsnull);
30479: }
30479: 
50553: nsresult
50550: RasterImage::AppendPalettedFrame(PRInt32 aX, PRInt32 aY,
30479:                                  PRInt32 aWidth, PRInt32 aHeight,
30479:                                  gfxASurface::gfxImageFormat aFormat,
30479:                                  PRUint8 aPaletteDepth,
30479:                                  PRUint8 **imageData,
30479:                                  PRUint32 *imageLength,
30479:                                  PRUint32 **paletteData,
30479:                                  PRUint32 *paletteLength)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(imageData);
30479:   NS_ENSURE_ARG_POINTER(imageLength);
30479:   NS_ENSURE_ARG_POINTER(paletteData);
30479:   NS_ENSURE_ARG_POINTER(paletteLength);
30479: 
32424:   return InternalAddFrame(mFrames.Length(), aX, aY, aWidth, aHeight, aFormat, 
30479:                           aPaletteDepth, imageData, imageLength,
30479:                           paletteData, paletteLength);
30479: }
30479: 
50553: nsresult
50550: RasterImage::SetSize(PRInt32 aWidth, PRInt32 aHeight)
32424: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Ensure that we have positive values
32424:   // XXX - Why isn't the size unsigned? Should this be changed?
32424:   if ((aWidth < 0) || (aHeight < 0))
32424:     return NS_ERROR_INVALID_ARG;
32424: 
32424:   // if we already have a size, check the new size against the old one
32424:   if (mHasSize &&
32424:       ((aWidth != mSize.width) || (aHeight != mSize.height))) {
32424: 
32424:     // Alter the warning depending on whether the channel is multipart
32424:     if (!mMultipart)
32424:       NS_WARNING("Image changed size on redecode! This should not happen!");
32424:     else
32424:       NS_WARNING("Multipart channel sent an image of a different size");
32424: 
32424:     DoError();
32424:     return NS_ERROR_UNEXPECTED;
32424:   }
32424: 
32424:   // Set the size and flag that we have it
32424:   mSize.SizeTo(aWidth, aHeight);
32424:   mHasSize = PR_TRUE;
32424: 
32424:   return NS_OK;
32424: }
32424: 
50553: nsresult
50550: RasterImage::EnsureCleanFrame(PRUint32 aFrameNum, PRInt32 aX, PRInt32 aY,
30479:                               PRInt32 aWidth, PRInt32 aHeight,
30479:                               gfxASurface::gfxImageFormat aFormat,
30479:                               PRUint8 **imageData, PRUint32 *imageLength)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
30479:   NS_ENSURE_ARG_POINTER(imageData);
30479:   NS_ENSURE_ARG_POINTER(imageLength);
32424:   NS_ABORT_IF_FALSE(aFrameNum <= mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum > mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   // Adding a frame that doesn't already exist.
32424:   if (aFrameNum == mFrames.Length())
30479:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
30479:                             /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                             /* aPaletteData = */ nsnull, 
30479:                             /* aPaletteLength = */ nsnull);
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
30479:   if (!frame)
30479:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
30479:                             /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                             /* aPaletteData = */ nsnull, 
30479:                             /* aPaletteLength = */ nsnull);
30479: 
30479:   // See if we can re-use the frame that already exists.
30479:   nsIntRect rect = frame->GetRect();
30479:   if (rect.x != aX || rect.y != aY || rect.width != aWidth || rect.height != aHeight ||
30479:       frame->GetFormat() != aFormat) {
39120:     DeleteImgFrame(aFrameNum);
30479:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
30479:                             /* aPaletteDepth = */ 0, imageData, imageLength,
30479:                             /* aPaletteData = */ nsnull, 
30479:                             /* aPaletteLength = */ nsnull);
30479:   }
30479: 
30479:   // We can re-use the frame.
30479:   frame->GetImageData(imageData, imageLength);
30479: 
30479:   return NS_OK;
30479: }
30479: 
30479: 
51592: void
50550: RasterImage::FrameUpdated(PRUint32 aFrameNum, nsIntRect &aUpdatedRect)
30479: {
51591:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling FrameUpdated on frame that doesn't exist!");
30479: 
30479:   frame->ImageUpdated(aUpdatedRect);
30479: }
30479: 
50553: nsresult
50553: RasterImage::SetFrameDisposalMethod(PRUint32 aFrameNum,
50553:                                     PRInt32 aDisposalMethod)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame,
32424:                     "Calling SetFrameDisposalMethod on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetFrameDisposalMethod(aDisposalMethod);
30479: 
30479:   return NS_OK;
30479: }
30479: 
50553: nsresult
50550: RasterImage::SetFrameTimeout(PRUint32 aFrameNum, PRInt32 aTimeout)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameTimeout on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetTimeout(aTimeout);
30479: 
30479:   return NS_OK;
30479: }
30479: 
50553: nsresult
50550: RasterImage::SetFrameBlendMethod(PRUint32 aFrameNum, PRInt32 aBlendMethod)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameBlendMethod on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetBlendMethod(aBlendMethod);
30479: 
30479:   return NS_OK;
30479: }
30479: 
50553: nsresult
50550: RasterImage::SetFrameHasNoAlpha(PRUint32 aFrameNum)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
32424:   if (aFrameNum >= mFrames.Length())
30479:     return NS_ERROR_INVALID_ARG;
30479: 
30479:   imgFrame *frame = GetImgFrame(aFrameNum);
32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameHasNoAlpha on frame that doesn't exist!");
30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30479: 
30479:   frame->SetHasNoAlpha();
30479: 
    1:   return NS_OK;
    1: }
    1: 
50553: nsresult
50550: RasterImage::DecodingComplete()
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Flag that we're done decoding.
32424:   // XXX - these should probably be combined when we fix animated image
32424:   // discarding with bug 500402.
32424:   mDecoded = PR_TRUE;
33531:   mHasBeenDecoded = PR_TRUE;
30479: 
32424:   nsresult rv;
32424: 
32424:   // We now have one of the qualifications for discarding. Re-evaluate.
32424:   if (CanDiscard()) {
46991:     NS_ABORT_IF_FALSE(!DiscardingActive(),
32424:                       "We shouldn't have been discardable before this");
50547:     rv = DiscardTracker::Reset(&mDiscardTrackerNode);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If there's only 1 frame, optimize it. Optimizing animated images
32424:   // is not supported.
32424:   //
32424:   // We don't optimize the frame for multipart images because we reuse
32424:   // the frame.
32424:   if ((mFrames.Length() == 1) && !mMultipart) {
32424:     rv = mFrames[0]->Optimize();
32424:     NS_ENSURE_SUCCESS(rv, rv);
32424:   }
30479: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
52149: /* void StartAnimation () */
52149: nsresult
50550: RasterImage::StartAnimation()
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
52149:   NS_ABORT_IF_FALSE(ShouldAnimate(), "Should not animate!");
52149: 
    1:   if (!ensureAnimExists())
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
52149:   NS_ABORT_IF_FALSE(mAnim && !mAnim->timer, "Anim must exist and not have a timer yet");
52149:   
13362:   // Default timeout to 100: the timer notify code will do the right
13362:   // thing, so just get that started.
13362:   PRInt32 timeout = 100;
30479:   imgFrame *currentFrame = GetCurrentImgFrame();
    1:   if (currentFrame) {
30479:     timeout = currentFrame->GetTimeout();
52149:     if (timeout < 0) { // -1 means display this frame forever
52149:       mAnimationFinished = PR_TRUE;
52149:       return NS_ERROR_ABORT;
52149:     }
52149:   }
52149:   
52149:   mAnim->timer = do_CreateInstance("@mozilla.org/timer;1");
52149:   NS_ENSURE_TRUE(mAnim->timer, NS_ERROR_OUT_OF_MEMORY);
52149:   mAnim->timer->InitWithCallback(static_cast<nsITimerCallback*>(this),
52149:                                  timeout, nsITimer::TYPE_REPEATING_SLACK);
52149:   
    1:   return NS_OK;
13362: }
    1: 
    1: //******************************************************************************
    1: /* void stopAnimation (); */
52149: nsresult
50550: RasterImage::StopAnimation()
    1: {
52149:   NS_ABORT_IF_FALSE(mAnimating, "Should be animating!");
52149: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
52149:   if (mAnim->timer) {
    1:     mAnim->timer->Cancel();
    1:     mAnim->timer = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* void resetAnimation (); */
50550: NS_IMETHODIMP
50550: RasterImage::ResetAnimation()
    1: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
    1:   if (mAnimationMode == kDontAnimMode || 
 6617:       !mAnim || mAnim->currentAnimationFrameIndex == 0)
    1:     return NS_OK;
    1: 
52149:   if (mAnimating)
52149:     StopAnimation();
    1: 
    1:   mAnim->lastCompositedFrameIndex = -1;
    1:   mAnim->currentAnimationFrameIndex = 0;
32424: 
32424:   // Note - We probably want to kick off a redecode somewhere around here when
32424:   // we fix bug 500402.
32424: 
32424:   // Update display if we were animating before
    1:   nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
52149:   if (mAnimating && observer)
30479:     observer->FrameChanged(this, &(mAnim->firstFrameRefreshArea));
    1: 
52149:   if (ShouldAnimate())
52149:     StartAnimation();
52149: 
    1:   return NS_OK;
    1: }
    1: 
50553: void
50550: RasterImage::SetLoopCount(PRInt32 aLoopCount)
    1: {
32424:   if (mError)
50553:     return;
32424: 
    1:   // -1  infinite
    1:   //  0  no looping, one iteration
    1:   //  1  one loop, two iterations
    1:   //  ...
    1:   mLoopCount = aLoopCount;
    1: }
    1: 
50553: nsresult
50550: RasterImage::AddSourceData(const char *aBuffer, PRUint32 aCount)
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   NS_ENSURE_ARG_POINTER(aBuffer);
32424:   nsresult rv = NS_OK;
32424: 
32424:   // We should not call this if we're not initialized
32424:   NS_ABORT_IF_FALSE(mInitialized, "Calling AddSourceData() on uninitialized "
50549:                                   "RasterImage!");
32424: 
32424:   // We should not call this if we're already finished adding source data
32424:   NS_ABORT_IF_FALSE(!mHasSourceData, "Calling AddSourceData() after calling "
32424:                                      "sourceDataComplete()!");
32424: 
32424:   // This call should come straight from necko - no reentrancy allowed
32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Re-entrant call to AddSourceData!");
32424: 
32424:   // If we're not storing source data, write it directly to the decoder
32424:   if (!StoringSourceData()) {
32424:     rv = WriteToDecoder(aBuffer, aCount);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
51593: 
51593:     // We're not storing source data, so this data is probably coming straight
51593:     // from the network. In this case, we want to display data as soon as we
51593:     // get it, so we want to flush invalidations after every write.
51593:     mInDecoder = PR_TRUE;
51593:     mDecoder->FlushInvalidations();
51593:     mInDecoder = PR_FALSE;
 7009:   }
 7009: 
32424:   // Otherwise, we're storing data in the source buffer
32424:   else {
32424: 
32424:     // Store the data
32424:     char *newElem = mSourceData.AppendElements(aBuffer, aCount);
32424:     if (!newElem)
32424:       return NS_ERROR_OUT_OF_MEMORY;
32424: 
32424:     // If there's a decoder open, that means we want to do more decoding.
32424:     // Wake up the worker if it's not up already
32424:     if (mDecoder && !mWorkerPending) {
32424:       NS_ABORT_IF_FALSE(mWorker, "We should have a worker here!");
32424:       rv = mWorker->Run();
32424:       CONTAINER_ENSURE_SUCCESS(rv);
 7009:     }
 7009:   }
 7009: 
32424:   // Statistics
32424:   total_source_bytes += aCount;
32424:   if (mDiscardable)
32424:     discardable_source_bytes += aCount;
 7009:   PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
50549:           ("CompressedImageAccounting: Added compressed data to RasterImage %p (%s). "
32424:            "Total Containers: %d, Discardable containers: %d, "
32424:            "Total source bytes: %lld, Source bytes for discardable containers %lld",
 7009:            this,
32424:            mSourceDataMimeType.get(),
32424:            num_containers,
32424:            num_discardable_containers,
32424:            total_source_bytes,
32424:            discardable_source_bytes));
 7009: 
 7009:   return NS_OK;
 7009: }
 7009: 
 7009: /* Note!  buf must be declared as char buf[9]; */
 7009: // just used for logging and hashing the header
 7009: static void
 7009: get_header_str (char *buf, char *data, PRSize data_len)
 7009: {
 7009:   int i;
 7009:   int n;
 7009:   static char hex[] = "0123456789abcdef";
 7009: 
 7009:   n = data_len < 4 ? data_len : 4;
 7009: 
 7009:   for (i = 0; i < n; i++) {
 7009:     buf[i * 2]     = hex[(data[i] >> 4) & 0x0f];
 7009:     buf[i * 2 + 1] = hex[data[i] & 0x0f];
 7009:   }
 7009: 
 7009:   buf[i * 2] = 0;
 7009: }
 7009: 
50553: nsresult
50550: RasterImage::SourceDataComplete()
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // If we've been called before, ignore. Otherwise, flag that we have everything
32424:   if (mHasSourceData)
 7009:     return NS_OK;
32424:   mHasSourceData = PR_TRUE;
32424: 
32424:   // This call should come straight from necko - no reentrancy allowed
32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Re-entrant call to AddSourceData!");
32424: 
32424:   // If we're not storing any source data, then all the data was written
32424:   // directly to the decoder in the AddSourceData() calls. This means we're
32424:   // done, so we can shut down the decoder.
32424:   if (!StoringSourceData()) {
32424:     nsresult rv = ShutdownDecoder(eShutdownIntent_Done);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If there's a decoder open, we need to wake up the worker if it's not
32424:   // already. This is so the worker can account for the fact that the source
32424:   // data is complete. For some decoders, DecodingComplete() is only called
32424:   // when the decoder is Close()-ed, and thus the SourceDataComplete() call
32424:   // is the only way we can transition to a 'decoded' state. Furthermore,
32424:   // it's always possible for any image type to have the data stream stop
32424:   // abruptly at any point, in which case we need to trigger an error.
32424:   if (mDecoder && !mWorkerPending) {
32424:     NS_ABORT_IF_FALSE(mWorker, "We should have a worker here!");
32424:     nsresult rv = mWorker->Run();
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Free up any extra space in the backing buffer
32424:   mSourceData.Compact();
32424: 
32424:   // Log header information
 7009:   if (PR_LOG_TEST(gCompressedImageAccountingLog, PR_LOG_DEBUG)) {
 7009:     char buf[9];
32424:     get_header_str(buf, mSourceData.Elements(), mSourceData.Length());
 7009:     PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
50549:             ("CompressedImageAccounting: RasterImage::SourceDataComplete() - data "
32424:              "is done for container %p (%s) - header %p is 0x%s (length %d)",
 7009:              this,
32424:              mSourceDataMimeType.get(),
32424:              mSourceData.Elements(),
 7009:              buf,
32424:              mSourceData.Length()));
 7009:   }
 7009: 
32424:   // We now have one of the qualifications for discarding. Re-evaluate.
32424:   if (CanDiscard()) {
50547:     nsresult rv = DiscardTracker::Reset(&mDiscardTrackerNode);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424:   return NS_OK;
32424: }
32424: 
50553: nsresult
50550: RasterImage::NewSourceData()
32424: {
32424:   nsresult rv;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // The source data should be complete before calling this
32424:   NS_ABORT_IF_FALSE(mHasSourceData,
32424:                     "Calling NewSourceData before SourceDataComplete!");
32424:   if (!mHasSourceData)
32424:     return NS_ERROR_ILLEGAL_VALUE;
32424: 
32424:   // Only supported for multipart channels. It wouldn't be too hard to change this,
32424:   // but it would involve making sure that things worked for decode-on-draw and
32424:   // discarding. Presently there's no need for this, so we don't.
32424:   NS_ABORT_IF_FALSE(mMultipart, "NewSourceData not supported for multipart");
32424:   if (!mMultipart)
32424:     return NS_ERROR_ILLEGAL_VALUE;
32424: 
32424:   // We're multipart, so we shouldn't be storing source data
32424:   NS_ABORT_IF_FALSE(!StoringSourceData(),
32424:                     "Shouldn't be storing source data for multipart");
32424: 
32424:   // We're not storing the source data and we got SourceDataComplete. We should
32424:   // have shut down the previous decoder
32424:   NS_ABORT_IF_FALSE(!mDecoder, "Shouldn't have a decoder in NewSourceData");
32424: 
32424:   // The decoder was shut down and we didn't flag an error, so we should be decoded
32424:   NS_ABORT_IF_FALSE(mDecoded, "Should be decoded in NewSourceData");
32424: 
32424:   // Reset some flags
32424:   mDecoded = PR_FALSE;
32424:   mHasSourceData = PR_FALSE;
32424: 
32424:   // We're decode-on-load here. Open up a new decoder just like what happens when
32424:   // we call Init() for decode-on-load images.
51244:   rv = InitDecoder(/* aDoSizeDecode = */ false);
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
32424:   return NS_OK;
 7009: }
 7009: 
50553: nsresult
50550: RasterImage::SetSourceSizeHint(PRUint32 sizeHint)
46235: {
46235:   if (sizeHint && StoringSourceData())
46235:     mSourceData.SetCapacity(sizeHint);
46235:   return NS_OK;
46235: }
46235: 
46235: //******************************************************************************
    1: /* void notify(in nsITimer timer); */
50550: NS_IMETHODIMP
50550: RasterImage::Notify(nsITimer *timer)
    1: {
52150: #ifdef DEBUG
52150:   mFramesNotified++;
52150: #endif
52150: 
    1:   // This should never happen since the timer is only set up in StartAnimation()
    1:   // after mAnim is checked to exist.
52149:   NS_ABORT_IF_FALSE(mAnim, "Need anim for Notify()");
52149:   NS_ABORT_IF_FALSE(timer, "Need timer for Notify()");
52149:   NS_ABORT_IF_FALSE(mAnim->timer == timer,
50549:                     "RasterImage::Notify() called with incorrect timer");
    1: 
52149:   if (!mAnimating || !ShouldAnimate())
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
    1:   if (!observer) {
    1:     // the imgRequest that owns us is dead, we should die now too.
52149:     NS_ABORT_IF_FALSE(mAnimationConsumers == 0,
52149:                       "If no observer, should have no consumers");
52149:     if (mAnimating)
    1:       StopAnimation();
    1:     return NS_OK;
    1:   }
    1: 
32424:   if (mFrames.Length() == 0)
    1:     return NS_OK;
    1:   
30479:   imgFrame *nextFrame = nsnull;
    1:   PRInt32 previousFrameIndex = mAnim->currentAnimationFrameIndex;
32424:   PRUint32 nextFrameIndex = mAnim->currentAnimationFrameIndex + 1;
    1:   PRInt32 timeout = 0;
    1: 
53666:   // Figure out if we have the next full frame. This is more complicated than
53666:   // just checking for mFrames.Length() because decoders append their frames
53666:   // before they're filled in.
53666:   NS_ABORT_IF_FALSE(mDecoder || nextFrameIndex <= mFrames.Length(),
53666:                     "How did we get 2 indicies too far by incrementing?");
53666:   bool haveFullNextFrame = !mDecoder || nextFrameIndex < mDecoder->GetCompleteFrameCount();
53666: 
53666:   // If we don't have the next full frame, it had better be in the pipe.
53666:   NS_ABORT_IF_FALSE(haveFullNextFrame ||
53666:                     (mDecoder && mFrames.Length() > mDecoder->GetCompleteFrameCount()),
53666:                     "What is the next frame supposed to be?");
53666: 
    1:   // If we're done decoding the next frame, go ahead and display it now and
    1:   // reinit the timer with the next frame's delay time.
53666:   if (haveFullNextFrame) {
32424:     if (mFrames.Length() == nextFrameIndex) {
    1:       // End of Animation
    1: 
    1:       // If animation mode is "loop once", it's time to stop animating
    1:       if (mAnimationMode == kLoopOnceAnimMode || mLoopCount == 0) {
52149:         mAnimationFinished = PR_TRUE;
52149:         EvaluateAnimation();
    1:         return NS_OK;
    1:       } else {
    1:         // We may have used compositingFrame to build a frame, and then copied
    1:         // it back into mFrames[..].  If so, delete composite to save memory
    1:         if (mAnim->compositingFrame && mAnim->lastCompositedFrameIndex == -1)
    1:           mAnim->compositingFrame = nsnull;
    1:       }
    1: 
    1:       nextFrameIndex = 0;
    1:       if (mLoopCount > 0)
    1:         mLoopCount--;
    1:     }
    1: 
    1:     if (!(nextFrame = mFrames[nextFrameIndex])) {
    1:       // something wrong with the next frame, skip it
    1:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:       mAnim->timer->SetDelay(100);
    1:       return NS_OK;
    1:     }
30479:     timeout = nextFrame->GetTimeout();
    1: 
53666:   } else {
    1:     // Uh oh, the frame we want to show is currently being decoded (partial)
    1:     // Wait a bit and try again
    1:     mAnim->timer->SetDelay(100);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (timeout > 0)
    1:     mAnim->timer->SetDelay(timeout);
52149:   else {
52149:     mAnimationFinished = PR_TRUE;
52149:     EvaluateAnimation();
52149:   }
    1: 
    1:   nsIntRect dirtyRect;
30479:   imgFrame *frameToUse = nsnull;
    1: 
    1:   if (nextFrameIndex == 0) {
    1:     frameToUse = nextFrame;
    1:     dirtyRect = mAnim->firstFrameRefreshArea;
    1:   } else {
30479:     imgFrame *prevFrame = mFrames[previousFrameIndex];
    1:     if (!prevFrame)
    1:       return NS_OK;
    1: 
    1:     // Change frame and announce it
    1:     if (NS_FAILED(DoComposite(&frameToUse, &dirtyRect, prevFrame,
    1:                               nextFrame, nextFrameIndex))) {
    1:       // something went wrong, move on to next
50549:       NS_WARNING("RasterImage::Notify(): Composing Frame Failed\n");
34809:       nextFrame->SetCompositingFailed(PR_TRUE);
    1:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:       return NS_OK;
34809:     } else {
34809:       nextFrame->SetCompositingFailed(PR_FALSE);
    1:     }
    1:   }
    1:   // Set currentAnimationFrameIndex at the last possible moment
    1:   mAnim->currentAnimationFrameIndex = nextFrameIndex;
    1:   // Refreshes the screen
30479:   observer->FrameChanged(this, &dirtyRect);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: // DoComposite gets called when the timer for animation get fired and we have to
    1: // update the composited frame of the animation.
50550: nsresult
50550: RasterImage::DoComposite(imgFrame** aFrameToUse,
    1:                          nsIntRect* aDirtyRect,
30479:                          imgFrame* aPrevFrame,
30479:                          imgFrame* aNextFrame,
    1:                          PRInt32 aNextFrameIndex)
    1: {
13362:   NS_ENSURE_ARG_POINTER(aDirtyRect);
13362:   NS_ENSURE_ARG_POINTER(aPrevFrame);
13362:   NS_ENSURE_ARG_POINTER(aNextFrame);
13362:   NS_ENSURE_ARG_POINTER(aFrameToUse);
    1: 
30479:   PRInt32 prevFrameDisposalMethod = aPrevFrame->GetFrameDisposalMethod();
50553:   if (prevFrameDisposalMethod == kDisposeRestorePrevious &&
    1:       !mAnim->compositingPrevFrame)
50553:     prevFrameDisposalMethod = kDisposeClear;
30479: 
30479:   nsIntRect prevFrameRect = aPrevFrame->GetRect();
    1:   PRBool isFullPrevFrame = (prevFrameRect.x == 0 && prevFrameRect.y == 0 &&
    1:                             prevFrameRect.width == mSize.width &&
    1:                             prevFrameRect.height == mSize.height);
    1: 
 7671:   // Optimization: DisposeClearAll if the previous frame is the same size as
    1:   //               container and it's clearing itself
 7671:   if (isFullPrevFrame && 
50553:       (prevFrameDisposalMethod == kDisposeClear))
50553:     prevFrameDisposalMethod = kDisposeClearAll;
    1: 
30479:   PRInt32 nextFrameDisposalMethod = aNextFrame->GetFrameDisposalMethod();
30479:   nsIntRect nextFrameRect = aNextFrame->GetRect();
    1:   PRBool isFullNextFrame = (nextFrameRect.x == 0 && nextFrameRect.y == 0 &&
    1:                             nextFrameRect.width == mSize.width &&
    1:                             nextFrameRect.height == mSize.height);
    1: 
30479:   if (!aNextFrame->GetIsPaletted()) {
 7671:     // Optimization: Skip compositing if the previous frame wants to clear the
 7671:     //               whole image
50553:     if (prevFrameDisposalMethod == kDisposeClearAll) {
 7671:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
 7671:       *aFrameToUse = aNextFrame;
 7671:       return NS_OK;
 7671:     }
    1:   
    1:     // Optimization: Skip compositing if this frame is the same size as the
    1:     //               container and it's fully drawing over prev frame (no alpha)
    1:     if (isFullNextFrame &&
50553:         (nextFrameDisposalMethod != kDisposeRestorePrevious) &&
30479:         !aNextFrame->GetHasAlpha()) {
    1:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
    1:       *aFrameToUse = aNextFrame;
    1:       return NS_OK;
    1:     }
 7671:   }
    1: 
    1:   // Calculate area that needs updating
    1:   switch (prevFrameDisposalMethod) {
    1:     default:
50553:     case kDisposeNotSpecified:
50553:     case kDisposeKeep:
    1:       *aDirtyRect = nextFrameRect;
    1:       break;
    1: 
50553:     case kDisposeClearAll:
 7671:       // Whole image container is cleared
 7671:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
 7671:       break;
 7671: 
50553:     case kDisposeClear:
    1:       // Calc area that needs to be redrawn (the combination of previous and
    1:       // this frame)
    1:       // XXX - This could be done with multiple framechanged calls
    1:       //       Having prevFrame way at the top of the image, and nextFrame
    1:       //       way at the bottom, and both frames being small, we'd be
    1:       //       telling framechanged to refresh the whole image when only two
    1:       //       small areas are needed.
    1:       aDirtyRect->UnionRect(nextFrameRect, prevFrameRect);
    1:       break;
    1: 
50553:     case kDisposeRestorePrevious:
    1:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
    1:       break;
    1:   }
    1: 
    1:   // Optimization:
    1:   //   Skip compositing if the last composited frame is this frame
    1:   //   (Only one composited frame was made for this animation.  Example:
    1:   //    Only Frame 3 of a 10 frame image required us to build a composite frame
    1:   //    On the second loop, we do not need to rebuild the frame
    1:   //    since it's still sitting in compositingFrame)
    1:   if (mAnim->lastCompositedFrameIndex == aNextFrameIndex) {
    1:     *aFrameToUse = mAnim->compositingFrame;
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRBool needToBlankComposite = PR_FALSE;
    1: 
    1:   // Create the Compositing Frame
    1:   if (!mAnim->compositingFrame) {
30479:     mAnim->compositingFrame = new imgFrame();
30479:     if (!mAnim->compositingFrame) {
    1:       NS_WARNING("Failed to init compositingFrame!\n");
30479:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
30479:     nsresult rv = mAnim->compositingFrame->Init(0, 0, mSize.width, mSize.height,
30479:                                                 gfxASurface::ImageFormatARGB32);
35021:     if (NS_FAILED(rv)) {
35021:       mAnim->compositingFrame = nsnull;
35021:       return rv;
35021:     }
    1:     needToBlankComposite = PR_TRUE;
43684:   } else if (aNextFrameIndex != mAnim->lastCompositedFrameIndex+1) {
43684: 
52105:     // If we are not drawing on top of last composited frame, 
52105:     // then we are building a new composite frame, so let's clear it first.
 9540:     needToBlankComposite = PR_TRUE;
    1:   }
    1: 
 7671:   // More optimizations possible when next frame is not transparent
52105:   // But if the next frame has kDisposeRestorePrevious,
52105:   // this "no disposal" optimization is not possible, 
52105:   // because the frame in "after disposal operation" state 
52105:   // needs to be stored in compositingFrame, so it can be 
52105:   // copied into compositingPrevFrame later.
 7671:   PRBool doDisposal = PR_TRUE;
52105:   if (!aNextFrame->GetHasAlpha() &&
52105:       nextFrameDisposalMethod != kDisposeRestorePrevious) {
 7671:     if (isFullNextFrame) {
 7671:       // Optimization: No need to dispose prev.frame when 
 7671:       // next frame is full frame and not transparent.
 7671:       doDisposal = PR_FALSE;
 7671:       // No need to blank the composite frame
 7671:       needToBlankComposite = PR_FALSE;
    1:     } else {
 7671:       if ((prevFrameRect.x >= nextFrameRect.x) &&
 7671:           (prevFrameRect.y >= nextFrameRect.y) &&
 7671:           (prevFrameRect.x + prevFrameRect.width <= nextFrameRect.x + nextFrameRect.width) &&
 7671:           (prevFrameRect.y + prevFrameRect.height <= nextFrameRect.y + nextFrameRect.height)) {
 7671:         // Optimization: No need to dispose prev.frame when 
 7671:         // next frame fully overlaps previous frame.
 7671:         doDisposal = PR_FALSE;  
 7671:       }
    1:     }      
    1:   }
    1: 
 7671:   if (doDisposal) {
 7671:     // Dispose of previous: clear, restore, or keep (copy)
    1:     switch (prevFrameDisposalMethod) {
50553:       case kDisposeClear:
    1:         if (needToBlankComposite) {
    1:           // If we just created the composite, it could have anything in it's
 7671:           // buffer. Clear whole frame
 2200:           ClearFrame(mAnim->compositingFrame);
    1:         } else {
 7671:           // Only blank out previous frame area (both color & Mask/Alpha)
 2200:           ClearFrame(mAnim->compositingFrame, prevFrameRect);
    1:         }
    1:         break;
    1:   
50553:       case kDisposeClearAll:
 7671:         ClearFrame(mAnim->compositingFrame);
 7671:         break;
 7671:   
50553:       case kDisposeRestorePrevious:
    1:         // It would be better to copy only the area changed back to
    1:         // compositingFrame.
    1:         if (mAnim->compositingPrevFrame) {
    1:           CopyFrameImage(mAnim->compositingPrevFrame, mAnim->compositingFrame);
    1:   
    1:           // destroy only if we don't need it for this frame's disposal
50553:           if (nextFrameDisposalMethod != kDisposeRestorePrevious)
    1:             mAnim->compositingPrevFrame = nsnull;
    1:         } else {
 2200:           ClearFrame(mAnim->compositingFrame);
    1:         }
    1:         break;
 7671:       
 7671:       default:
 7671:         // Copy previous frame into compositingFrame before we put the new frame on top
 7671:         // Assumes that the previous frame represents a full frame (it could be
 7671:         // smaller in size than the container, as long as the frame before it erased
 7671:         // itself)
 7671:         // Note: Frame 1 never gets into DoComposite(), so (aNextFrameIndex - 1) will
 7671:         // always be a valid frame number.
 7671:         if (mAnim->lastCompositedFrameIndex != aNextFrameIndex - 1) {
32163:           if (isFullPrevFrame && !aPrevFrame->GetIsPaletted()) {
 7671:             // Just copy the bits
 7671:             CopyFrameImage(aPrevFrame, mAnim->compositingFrame);
 7671:           } else {
 7671:             if (needToBlankComposite) {
 7671:               // Only blank composite when prev is transparent or not full.
30479:               if (aPrevFrame->GetHasAlpha() || !isFullPrevFrame) {
 7671:                 ClearFrame(mAnim->compositingFrame);
 7671:               }
 7671:             }
 7671:             DrawFrameTo(aPrevFrame, mAnim->compositingFrame, prevFrameRect);
 7671:           }
 7671:         }
32163:     }
 7671:   } else if (needToBlankComposite) {
 7671:     // If we just created the composite, it could have anything in it's
 7671:     // buffers. Clear them
 7671:     ClearFrame(mAnim->compositingFrame);
    1:   }
    1: 
    1:   // Check if the frame we are composing wants the previous image restored afer
 7108:   // it is done. Don't store it (again) if last frame wanted its image restored
    1:   // too
50553:   if ((nextFrameDisposalMethod == kDisposeRestorePrevious) &&
50553:       (prevFrameDisposalMethod != kDisposeRestorePrevious)) {
    1:     // We are storing the whole image.
    1:     // It would be better if we just stored the area that nextFrame is going to
    1:     // overwrite.
    1:     if (!mAnim->compositingPrevFrame) {
30479:       mAnim->compositingPrevFrame = new imgFrame();
30479:       if (!mAnim->compositingPrevFrame) {
52105:         NS_WARNING("Failed to init compositingPrevFrame!\n");
30479:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
30479:       nsresult rv = mAnim->compositingPrevFrame->Init(0, 0, mSize.width, mSize.height,
30479:                                                       gfxASurface::ImageFormatARGB32);
35021:       if (NS_FAILED(rv)) {
35021:         mAnim->compositingPrevFrame = nsnull;
35021:         return rv;
35021:       }
30479:     }
30479: 
    1:     CopyFrameImage(mAnim->compositingFrame, mAnim->compositingPrevFrame);
    1:   }
    1: 
    1:   // blit next frame into it's correct spot
 5275:   DrawFrameTo(aNextFrame, mAnim->compositingFrame, nextFrameRect);
30479: 
    1:   // Set timeout of CompositeFrame to timeout of frame we just composed
    1:   // Bug 177948
30479:   PRInt32 timeout = aNextFrame->GetTimeout();
    1:   mAnim->compositingFrame->SetTimeout(timeout);
    1: 
 7671:   // Tell the image that it is fully 'downloaded'.
30479:   nsresult rv = mAnim->compositingFrame->ImageUpdated(mAnim->compositingFrame->GetRect());
19117:   if (NS_FAILED(rv)) {
19117:     return rv;
19117:   }
 7671: 
52105:   // We don't want to keep composite images for 8bit frames.
52105:   // Also this optimization won't work if the next frame has 
52105:   // kDisposeRestorePrevious, because it would need to be restored 
52105:   // into "after prev disposal but before next blend" state, 
52105:   // not into empty frame.
 7671:   if (isFullNextFrame && mAnimationMode == kNormalAnimMode && mLoopCount != 0 &&
52105:       nextFrameDisposalMethod != kDisposeRestorePrevious &&
30479:       !aNextFrame->GetIsPaletted()) {
    1:     // We have a composited full frame
    1:     // Store the composited frame into the mFrames[..] so we don't have to
    1:     // continuously re-build it
    1:     // Then set the previous frame's disposal to CLEAR_ALL so we just draw the
    1:     // frame next time around
    1:     if (CopyFrameImage(mAnim->compositingFrame, aNextFrame)) {
50553:       aPrevFrame->SetFrameDisposalMethod(kDisposeClearAll);
    1:       mAnim->lastCompositedFrameIndex = -1;
    1:       *aFrameToUse = aNextFrame;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   mAnim->lastCompositedFrameIndex = aNextFrameIndex;
    1:   *aFrameToUse = mAnim->compositingFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
 2200: // Fill aFrame with black. Does also clears the mask.
50550: void
50550: RasterImage::ClearFrame(imgFrame *aFrame)
    1: {
    1:   if (!aFrame)
    1:     return;
    1: 
35020:   nsresult rv = aFrame->LockImageData();
35020:   if (NS_FAILED(rv))
35020:     return;
30479: 
    1:   nsRefPtr<gfxASurface> surf;
30479:   aFrame->GetSurface(getter_AddRefs(surf));
    1: 
 2200:   // Erase the surface to transparent
 2200:   gfxContext ctx(surf);
 2200:   ctx.SetOperator(gfxContext::OPERATOR_CLEAR);
 2200:   ctx.Paint();
30479: 
30479:   aFrame->UnlockImageData();
    1: }
    1: 
 2200: //******************************************************************************
50550: void
50550: RasterImage::ClearFrame(imgFrame *aFrame, nsIntRect &aRect)
 2200: {
30479:   if (!aFrame || aRect.width <= 0 || aRect.height <= 0)
 2200:     return;
 2200: 
35020:   nsresult rv = aFrame->LockImageData();
35020:   if (NS_FAILED(rv))
35020:     return;
30479: 
 2200:   nsRefPtr<gfxASurface> surf;
30479:   aFrame->GetSurface(getter_AddRefs(surf));
 2200: 
 2200:   // Erase the destination rectangle to transparent
 2200:   gfxContext ctx(surf);
 2200:   ctx.SetOperator(gfxContext::OPERATOR_CLEAR);
 2200:   ctx.Rectangle(gfxRect(aRect.x, aRect.y, aRect.width, aRect.height));
 2200:   ctx.Fill();
30479: 
30479:   aFrame->UnlockImageData();
 2200: }
 2200: 
    1: 
    1: //******************************************************************************
    1: // Whether we succeed or fail will not cause a crash, and there's not much
    1: // we can do about a failure, so there we don't return a nsresult
50550: PRBool
50550: RasterImage::CopyFrameImage(imgFrame *aSrcFrame,
30479:                             imgFrame *aDstFrame)
    1: {
    1:   PRUint8* aDataSrc;
    1:   PRUint8* aDataDest;
    1:   PRUint32 aDataLengthSrc;
    1:   PRUint32 aDataLengthDest;
    1: 
    1:   if (!aSrcFrame || !aDstFrame)
    1:     return PR_FALSE;
    1: 
    1:   if (NS_FAILED(aDstFrame->LockImageData()))
    1:     return PR_FALSE;
    1: 
    1:   // Copy Image Over
    1:   aSrcFrame->GetImageData(&aDataSrc, &aDataLengthSrc);
    1:   aDstFrame->GetImageData(&aDataDest, &aDataLengthDest);
    1:   if (!aDataDest || !aDataSrc || aDataLengthDest != aDataLengthSrc) {
    1:     aDstFrame->UnlockImageData();
    1:     return PR_FALSE;
    1:   }
    1:   memcpy(aDataDest, aDataSrc, aDataLengthSrc);
    1:   aDstFrame->UnlockImageData();
    1: 
    1:   return PR_TRUE;
    1: }
 2663: 
 5275: //******************************************************************************
10521: /* 
10521:  * aSrc is the current frame being drawn,
10521:  * aDst is the composition frame where the current frame is drawn into.
10521:  * aSrcRect is the size of the current frame, and the position of that frame
10521:  *          in the composition frame.
10521:  */
50550: nsresult
50550: RasterImage::DrawFrameTo(imgFrame *aSrc,
30479:                          imgFrame *aDst,
10521:                          nsIntRect& aSrcRect)
 5275: {
10521:   NS_ENSURE_ARG_POINTER(aSrc);
10521:   NS_ENSURE_ARG_POINTER(aDst);
 5275: 
30479:   nsIntRect dstRect = aDst->GetRect();
 7671: 
10521:   // According to both AGIF and APNG specs, offsets are unsigned
10521:   if (aSrcRect.x < 0 || aSrcRect.y < 0) {
50549:     NS_WARNING("RasterImage::DrawFrameTo: negative offsets not allowed");
10521:     return NS_ERROR_FAILURE;
10521:   }
10521:   // Outside the destination frame, skip it
10521:   if ((aSrcRect.x > dstRect.width) || (aSrcRect.y > dstRect.height)) {
10521:     return NS_OK;
10521:   }
30479: 
30479:   if (aSrc->GetIsPaletted()) {
 8118:     // Larger than the destination frame, clip it
10521:     PRInt32 width = PR_MIN(aSrcRect.width, dstRect.width - aSrcRect.x);
10521:     PRInt32 height = PR_MIN(aSrcRect.height, dstRect.height - aSrcRect.y);
 8118: 
10521:     // The clipped image must now fully fit within destination image frame
10521:     NS_ASSERTION((aSrcRect.x >= 0) && (aSrcRect.y >= 0) &&
10521:                  (aSrcRect.x + width <= dstRect.width) &&
10521:                  (aSrcRect.y + height <= dstRect.height),
50549:                 "RasterImage::DrawFrameTo: Invalid aSrcRect");
10521: 
10521:     // clipped image size may be smaller than source, but not larger
10521:     NS_ASSERTION((width <= aSrcRect.width) && (height <= aSrcRect.height),
50549:                  "RasterImage::DrawFrameTo: source must be smaller than dest");
 7671: 
 7671:     if (NS_FAILED(aDst->LockImageData()))
 7671:       return NS_ERROR_FAILURE;
30479: 
 7671:     // Get pointers to image data
 7671:     PRUint32 size;
 7671:     PRUint8 *srcPixels;
30479:     PRUint32 *colormap;
30479:     PRUint32 *dstPixels;
 7671: 
 7671:     aSrc->GetImageData(&srcPixels, &size);
30479:     aSrc->GetPaletteData(&colormap, &size);
 7671:     aDst->GetImageData((PRUint8 **)&dstPixels, &size);
 7671:     if (!srcPixels || !dstPixels || !colormap) {
 7671:       aDst->UnlockImageData();
 7671:       return NS_ERROR_FAILURE;
 7671:     }
 7671: 
 7671:     // Skip to the right offset
10521:     dstPixels += aSrcRect.x + (aSrcRect.y * dstRect.width);
30479:     if (!aSrc->GetHasAlpha()) {
 9592:       for (PRInt32 r = height; r > 0; --r) {
 9592:         for (PRInt32 c = 0; c < width; c++) {
 9592:           dstPixels[c] = colormap[srcPixels[c]];
 7671:         }
 9592:         // Go to the next row in the source resp. destination image
10521:         srcPixels += aSrcRect.width;
 9592:         dstPixels += dstRect.width;
 7671:       }
 7671:     } else {
 9592:       for (PRInt32 r = height; r > 0; --r) {
 9592:         for (PRInt32 c = 0; c < width; c++) {
 9592:           const PRUint32 color = colormap[srcPixels[c]];
 7671:           if (color)
 9592:             dstPixels[c] = color;
 7671:         }
 9592:         // Go to the next row in the source resp. destination image
10521:         srcPixels += aSrcRect.width;
 9592:         dstPixels += dstRect.width;
 7671:       }
 7671:     }
30479: 
 7671:     aDst->UnlockImageData();
 7671:     return NS_OK;
 7671:   }
 7671: 
12652:   nsRefPtr<gfxPattern> srcPatt;
30479:   aSrc->GetPattern(getter_AddRefs(srcPatt));
 5275: 
30479:   aDst->LockImageData();
 5275:   nsRefPtr<gfxASurface> dstSurf;
30479:   aDst->GetSurface(getter_AddRefs(dstSurf));
 5275: 
 5275:   gfxContext dst(dstSurf);
10521:   dst.Translate(gfxPoint(aSrcRect.x, aSrcRect.y));
10521:   dst.Rectangle(gfxRect(0, 0, aSrcRect.width, aSrcRect.height), PR_TRUE);
 7108:   
 7108:   // first clear the surface if the blend flag says so
30479:   PRInt32 blendMethod = aSrc->GetBlendMethod();
50553:   if (blendMethod == kBlendSource) {
 7108:     gfxContext::GraphicsOperator defaultOperator = dst.CurrentOperator();
 7108:     dst.SetOperator(gfxContext::OPERATOR_CLEAR);
 7108:     dst.Fill();
10521:     dst.SetOperator(defaultOperator);
 7108:   }
12652:   dst.SetPattern(srcPatt);
 5275:   dst.Paint();
 5275: 
30479:   aDst->UnlockImageData();
30479: 
 5275:   return NS_OK;
 5275: }
 5275: 
 5275: 
 2663: /********* Methods to implement lazy allocation of nsIProperties object *************/
50550: NS_IMETHODIMP
50550: RasterImage::Get(const char *prop, const nsIID & iid, void * *result)
 2663: {
 2663:   if (!mProperties)
 2663:     return NS_ERROR_FAILURE;
 2663:   return mProperties->Get(prop, iid, result);
 2663: }
 2663: 
50550: NS_IMETHODIMP
50550: RasterImage::Set(const char *prop, nsISupports *value)
 2663: {
 2663:   if (!mProperties)
 2663:     mProperties = do_CreateInstance("@mozilla.org/properties;1");
 2663:   if (!mProperties)
 2663:     return NS_ERROR_OUT_OF_MEMORY;
 2663:   return mProperties->Set(prop, value);
 2663: }
 2663: 
50550: NS_IMETHODIMP
50550: RasterImage::Has(const char *prop, PRBool *_retval)
 2663: {
 2663:   NS_ENSURE_ARG_POINTER(_retval);
 2663:   if (!mProperties) {
 2663:     *_retval = PR_FALSE;
 2663:     return NS_OK;
 2663:   }
 2663:   return mProperties->Has(prop, _retval);
 2663: }
 2663: 
50550: NS_IMETHODIMP
50550: RasterImage::Undefine(const char *prop)
 2663: {
 2663:   if (!mProperties)
 2663:     return NS_ERROR_FAILURE;
 2663:   return mProperties->Undefine(prop);
 2663: }
 2663: 
50550: NS_IMETHODIMP
50550: RasterImage::GetKeys(PRUint32 *count, char ***keys)
 2663: {
 2663:   if (!mProperties) {
 2663:     *count = 0;
 2663:     *keys = nsnull;
 2663:     return NS_OK;
 2663:   }
 2663:   return mProperties->GetKeys(count, keys);
 2663: }
 7009: 
46991: void
50549: RasterImage::Discard()
 7009: {
32424:   // We should be ok for discard
46991:   NS_ABORT_IF_FALSE(CanDiscard(), "Asked to discard but can't!");
32424: 
32424:   // We should never discard when we have an active decoder
46991:   NS_ABORT_IF_FALSE(!mDecoder, "Asked to discard with open decoder!");
32424: 
32424:   // As soon as an image becomes animated, it becomes non-discardable and any
32424:   // timers are cancelled.
46991:   NS_ABORT_IF_FALSE(!mAnim, "Asked to discard for animated image!");
32424: 
32424:   // For post-operation logging
46991:   int old_frame_count = mFrames.Length();
 7009: 
32424:   // Delete all the decoded frames, then clear the array.
30479:   for (int i = 0; i < old_frame_count; ++i)
46991:     delete mFrames[i];
46991:   mFrames.Clear();
 7009: 
32424:   // Flag that we no longer have decoded frames for this image
46991:   mDecoded = PR_FALSE;
32424: 
32424:   // Notify that we discarded
46991:   nsCOMPtr<imgIDecoderObserver> observer(do_QueryReferent(mObserver));
32424:   if (observer)
32424:     observer->OnDiscard(nsnull);
32424: 
32424:   // Log
 7009:   PR_LOG(gCompressedImageAccountingLog, PR_LOG_DEBUG,
32424:          ("CompressedImageAccounting: discarded uncompressed image "
50549:           "data from RasterImage %p (%s) - %d frames (cached count: %d); "
32424:           "Total Containers: %d, Discardable containers: %d, "
32424:           "Total source bytes: %lld, Source bytes for discardable containers %lld",
46991:           this,
46991:           mSourceDataMimeType.get(),
 7009:           old_frame_count,
46991:           mFrames.Length(),
32424:           num_containers,
32424:           num_discardable_containers,
32424:           total_source_bytes,
32424:           discardable_source_bytes));
 7009: }
 7009: 
32424: // Helper method to determine if we can discard an image
32424: PRBool
50549: RasterImage::CanDiscard() {
32424:   return (DiscardingEnabled() && // Globally enabled...
32424:           mDiscardable &&        // ...Enabled at creation time...
32424:           (mLockCount == 0) &&   // ...not temporarily disabled...
32424:           mHasSourceData &&      // ...have the source data...
32424:           mDecoded);             // ...and have something to discard.
32424: }
32424: 
46991: // Helper method to tell us whether the clock is currently running for
46991: // discarding this image. Mainly for assertions.
46991: PRBool
50549: RasterImage::DiscardingActive() {
46991:   return !!(mDiscardTrackerNode.prev || mDiscardTrackerNode.next);
46991: }
46991: 
32424: // Helper method to determine if we're storing the source data in a buffer
32424: // or just writing it directly to the decoder
32424: PRBool
50549: RasterImage::StoringSourceData() {
32424:   return (mDecodeOnDraw || mDiscardable);
32424: }
32424: 
32424: 
32424: // Sets up a decoder for this image. It is an error to call this function
32424: // when decoding is already in process (ie - when mDecoder is non-null).
 7009: nsresult
51244: RasterImage::InitDecoder(bool aDoSizeDecode)
 7009: {
32424:   // Ensure that the decoder is not already initialized
32424:   NS_ABORT_IF_FALSE(!mDecoder, "Calling InitDecoder() while already decoding!");
32424:   
32424:   // We shouldn't be firing up a decoder if we already have the frames decoded
32424:   NS_ABORT_IF_FALSE(!mDecoded, "Calling InitDecoder() but already decoded!");
32424: 
32424:   // Since we're not decoded, we should not have a discard timer active
46991:   NS_ABORT_IF_FALSE(!DiscardingActive(), "Discard Timer active in InitDecoder()!");
32424: 
51234:   // Figure out which decoder we want
51234:   eDecoderType type = GetDecoderType(mSourceDataMimeType.get());
51234:   CONTAINER_ENSURE_TRUE(type != eDecoderType_unknown, NS_IMAGELIB_ERROR_NO_DECODER);
51234: 
51234:   // Instantiate the appropriate decoder
51234:   switch (type) {
51234:     case eDecoderType_png:
51234:       mDecoder = new nsPNGDecoder();
51234:       break;
51234:     case eDecoderType_gif:
51234:       mDecoder = new nsGIFDecoder2();
51234:       break;
51234:     case eDecoderType_jpeg:
51234:       mDecoder = new nsJPEGDecoder();
51234:       break;
51234:     case eDecoderType_bmp:
51234:       mDecoder = new nsBMPDecoder();
51234:       break;
51234:     case eDecoderType_ico:
51234:       mDecoder = new nsICODecoder();
51234:       break;
51234:     case eDecoderType_icon:
51234:       mDecoder = new nsIconDecoder();
51234:       break;
51234:     default:
51234:       NS_ABORT_IF_FALSE(0, "Shouldn't get here!");
51234:   }
51215: 
32424:   // Initialize the decoder
32424:   nsCOMPtr<imgIDecoderObserver> observer(do_QueryReferent(mObserver));
51244:   mDecoder->SetSizeDecode(aDoSizeDecode);
53672:   mDecoder->Init(this, observer);
53672:   CONTAINER_ENSURE_SUCCESS(mDecoder->GetDecoderError());
32424: 
32424:   // Create a decode worker
32424:   mWorker = new imgDecodeWorker(this);
32424:   CONTAINER_ENSURE_TRUE(mWorker, NS_ERROR_OUT_OF_MEMORY);
 7009: 
 7009:   return NS_OK;
 7009: }
 7009: 
32424: // Flushes, closes, and nulls-out a decoder. Cleans up any related decoding
32424: // state. It is an error to call this function when there is no initialized
32424: // decoder.
32424: // 
32424: // aIntent specifies the intent of the shutdown. If aIntent is
32424: // eShutdownIntent_Done, an error is flagged if we didn't get what we should
32424: // have out of the decode. If aIntent is eShutdownIntent_Interrupted, we don't
32424: // check this. If aIntent is eShutdownIntent_Error, we shut down in error mode.
32424: nsresult
50549: RasterImage::ShutdownDecoder(eShutdownIntent aIntent)
32424: {
32424:   // Ensure that our intent is valid
32424:   NS_ABORT_IF_FALSE((aIntent >= 0) || (aIntent < eShutdownIntent_AllCount),
32424:                     "Invalid shutdown intent");
32424: 
32424:   // Ensure that the decoder is initialized
32424:   NS_ABORT_IF_FALSE(mDecoder, "Calling ShutdownDecoder() with no active decoder!");
32424: 
51244:   // Figure out what kind of decode we were doing before we get rid of our decoder
51244:   bool wasSizeDecode = mDecoder->IsSizeDecode();
51244: 
53671:   // Finalize the decoder
51215:   mInDecoder = PR_TRUE;
53671:   mDecoder->Finish();
51215:   mInDecoder = PR_FALSE;
32424: 
32424:   // null out the decoder, _then_ check for errors on the close (otherwise the
32424:   // error routine might re-invoke ShutdownDecoder)
53671:   nsresult decoderStatus = mDecoder->GetDecoderError();
32424:   mDecoder = nsnull;
53671:   if (NS_FAILED(decoderStatus)) {
32424:     DoError();
53671:     return decoderStatus;
32424:   }
32424: 
32424:   // Kill off the worker
32424:   mWorker = nsnull;
32424: 
32424:   // We just shut down the decoder. If we didn't get what we want, but expected
32424:   // to, flag an error
32424:   PRBool failed = PR_FALSE;
51244:   if (wasSizeDecode && !mHasSize)
32424:     failed = PR_TRUE;
51244:   if (!wasSizeDecode && !mDecoded)
32424:     failed = PR_TRUE;
32424:   if ((aIntent == eShutdownIntent_Done) && failed) {
32424:     DoError();
32424:     return NS_ERROR_FAILURE;
32424:   }
32424: 
32424:   // Reset number of decoded bytes
32424:   mBytesDecoded = 0;
32424: 
32424:   return NS_OK;
32424: }
32424: 
33898: // Writes the data to the decoder, updating the total number of bytes written.
32424: nsresult
50549: RasterImage::WriteToDecoder(const char *aBuffer, PRUint32 aCount)
32424: {
32424:   // We should have a decoder
32424:   NS_ABORT_IF_FALSE(mDecoder, "Trying to write to null decoder!");
32424: 
38698:   // The decoder will start decoding into the current frame (if we have one).
38698:   // When it needs to add another frame, we will unlock this frame and lock the
38698:   // new frame.
38698:   // Our invariant is that, while in the decoder, the last frame is always
38698:   // locked, and all others are unlocked.
38698:   if (mFrames.Length() > 0) {
38698:     imgFrame *curframe = mFrames.ElementAt(mFrames.Length() - 1);
38698:     curframe->LockImageData();
38698:   }
38698: 
32424:   // Write
32424:   mInDecoder = PR_TRUE;
53672:   mDecoder->Write(aBuffer, aCount);
32424:   mInDecoder = PR_FALSE;
38698: 
38698:   // We unlock the current frame, even if that frame is different from the
38698:   // frame we entered the decoder with. (See above.)
38698:   if (mFrames.Length() > 0) {
38698:     imgFrame *curframe = mFrames.ElementAt(mFrames.Length() - 1);
38698:     curframe->UnlockImageData();
38698:   }
38698: 
53672:   CONTAINER_ENSURE_SUCCESS(mDecoder->GetDecoderError());
32424: 
32424:   // Keep track of the total number of bytes written over the lifetime of the
32424:   // decoder
32424:   mBytesDecoded += aCount;
32424: 
32424:   return NS_OK;
32424: }
32424: 
32424: // This function is called in situations where it's clear that we want the
32424: // frames in decoded form (Draw, GetFrame, CopyFrame, ExtractFrame, etc).
32424: // If we're completely decoded, this method resets the discard timer (if
32424: // we're discardable), since wanting the frames now is a good indicator of
32424: // wanting them again soon. If we're not decoded, this method kicks off
32424: // asynchronous decoding to generate the frames.
32424: nsresult
50549: RasterImage::WantDecodedFrames()
32424: {
32424:   nsresult rv;
32424: 
46991:   // If we can discard, the clock should be running. Reset it.
32424:   if (CanDiscard()) {
46991:     NS_ABORT_IF_FALSE(DiscardingActive(),
46991:                       "Decoded and discardable but discarding not activated!");
50547:     rv = DiscardTracker::Reset(&mDiscardTrackerNode);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Request a decode (no-op if we're decoded)
32424:   return RequestDecode();
32424: }
32424: 
30479: //******************************************************************************
32424: /* void requestDecode() */
32424: NS_IMETHODIMP
50549: RasterImage::RequestDecode()
32424: {
32424:   nsresult rv;
32424: 
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // If we're not storing source data, we have nothing to do
32424:   if (!StoringSourceData())
32424:     return NS_OK;
32424: 
32424:   // If we're fully decoded, we have nothing to do
32424:   if (mDecoded)
32424:     return NS_OK;
32424: 
32884:   // If we've already got a full decoder running, we have nothing to do
51244:   if (mDecoder && !mDecoder->IsSizeDecode())
32884:     return NS_OK;
32884: 
51244:   // If our callstack goes through a size decoder, we have a problem.
51244:   // We need to shutdown the size decode and replace it with  a full
32884:   // decoder, but can't do that from within the decoder itself. Thus, we post
32884:   // an asynchronous event to the event loop to do it later. Since
32884:   // RequestDecode() is an asynchronous function this works fine (though it's
32884:   // a little slower).
32424:   if (mInDecoder) {
32424:     nsRefPtr<imgDecodeRequestor> requestor = new imgDecodeRequestor(this);
32424:     if (!requestor)
32424:       return NS_ERROR_OUT_OF_MEMORY;
32424:     return NS_DispatchToCurrentThread(requestor);
32424:   }
32424: 
32424: 
51244:   // If we have a size decode open, interrupt it and shut it down
51244:   if (mDecoder && mDecoder->IsSizeDecode()) {
32424:     rv = ShutdownDecoder(eShutdownIntent_Interrupted);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If we don't have a decoder, create one 
32424:   if (!mDecoder) {
32424:     NS_ABORT_IF_FALSE(mFrames.IsEmpty(), "Trying to decode to non-empty frame-array");
51244:     rv = InitDecoder(/* aDoSizeDecode = */ false);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If we already have a pending worker, we're done
32424:   if (mWorkerPending)
32424:     return NS_OK;
32424: 
32424:   // If we've read all the data we have, we're done
32424:   if (mBytesDecoded == mSourceData.Length())
32424:     return NS_OK;
32424: 
51595:   // If it's a smallish image, it's not worth it to do things async
51595:   if (!mDecoded && !mInDecoder && mHasSourceData && (mSourceData.Length() < gMaxBytesForSyncDecode))
51595:     return SyncDecode();
51595: 
32424:   // If we get this far, dispatch the worker. We do this instead of starting
48321:   // any immediate decoding to guarantee that all our decode notifications are
48321:   // dispatched asynchronously, and to ensure we stay responsive.
32424:   return mWorker->Dispatch();
32424: }
32424: 
32424: // Synchronously decodes as much data as possible
32424: nsresult
50549: RasterImage::SyncDecode()
32424: {
32424:   nsresult rv;
32424: 
32424:   // If we're decoded already, no worries
32424:   if (mDecoded)
32424:     return NS_OK;
32424: 
32424:   // If we're not storing source data, there isn't much to do here
32424:   if (!StoringSourceData())
32424:     return NS_OK;
32424: 
32424:   // We really have no good way of forcing a synchronous decode if we're being
32424:   // called in a re-entrant manner (ie, from an event listener fired by a
48223:   // decoder), because the decoding machinery is already tied up. We thus explicitly
48223:   // disallow this type of call in the API, and check for it in API methods.
32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Yikes, forcing sync in reentrant call!");
32424: 
51244:   // If we have a size decode open, shut it down
51244:   if (mDecoder && mDecoder->IsSizeDecode()) {
32424:     rv = ShutdownDecoder(eShutdownIntent_Interrupted);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // If we don't have a decoder, create one 
32424:   if (!mDecoder) {
32424:     NS_ABORT_IF_FALSE(mFrames.IsEmpty(), "Trying to decode to non-empty frame-array");
51244:     rv = InitDecoder(/* aDoSizeDecode = */ false);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // Write everything we have
32424:   rv = WriteToDecoder(mSourceData.Elements() + mBytesDecoded,
32424:                       mSourceData.Length() - mBytesDecoded);
32424:   CONTAINER_ENSURE_SUCCESS(rv);
32424: 
51593:   // When we're doing a sync decode, we want to get as much information from the
51593:   // image as possible. We've send the decoder all of our data, so now's a good
51593:   // time  to flush any invalidations (in case we don't have all the data and what
51593:   // we got left us mid-frame).
51593:   mInDecoder = PR_TRUE;
51593:   mDecoder->FlushInvalidations();
51593:   mInDecoder = PR_FALSE;
51593: 
32424:   // If we finished the decode, shutdown the decoder
32424:   if (IsDecodeFinished()) {
32424:     rv = ShutdownDecoder(eShutdownIntent_Done);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
32424:   // All good!
32424:   return NS_OK;
32424: }
32424: 
32424: //******************************************************************************
47231: /* [noscript] void draw(in gfxContext aContext,
47231:  *                      in gfxGraphicsFilter aFilter,
47231:  *                      [const] in gfxMatrix aUserSpaceToImageSpace,
47231:  *                      [const] in gfxRect aFill,
47231:  *                      [const] in nsIntRect aSubimage,
52215:  *                      [const] in nsIntSize aViewportSize,
32424:  *                      in PRUint32 aFlags); */
50550: NS_IMETHODIMP
50550: RasterImage::Draw(gfxContext *aContext,
47231:                   gfxPattern::GraphicsFilter aFilter,
47231:                   const gfxMatrix &aUserSpaceToImageSpace,
47231:                   const gfxRect &aFill,
47231:                   const nsIntRect &aSubimage,
52215:                   const nsIntSize& /*aViewportSize - ignored*/,
47231:                   PRUint32 aFlags)
30479: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
48223:   // Disallowed in the API
48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
48223:     return NS_ERROR_FAILURE;
48223: 
30479:   NS_ENSURE_ARG_POINTER(aContext);
30479: 
32424:   // If a synchronous draw is requested, flush anything that might be sitting around
32424:   if (aFlags & FLAG_SYNC_DECODE) {
32424:     nsresult rv = SyncDecode();
32424:     NS_ENSURE_SUCCESS(rv, rv);
32424:   }
32424: 
34809:   imgFrame *frame = GetCurrentDrawableImgFrame();
32424:   if (!frame) {
32424:     return NS_OK; // Getting the frame (above) touches the image and kicks off decoding
32424:   }
30479: 
30479:   nsIntRect framerect = frame->GetRect();
30479:   nsIntMargin padding(framerect.x, framerect.y, 
30479:                       mSize.width - framerect.XMost(),
30479:                       mSize.height - framerect.YMost());
30479: 
30479:   frame->Draw(aContext, aFilter, aUserSpaceToImageSpace, aFill, padding, aSubimage);
30479: 
30479:   return NS_OK;
30479: }
30479: 
32424: //******************************************************************************
52204: /* [notxpcom] nsIFrame GetRootLayoutFrame() */
52204: nsIFrame*
52204: RasterImage::GetRootLayoutFrame()
52204: {
52204:   return nsnull;
52204: }
52204: 
52204: //******************************************************************************
32424: /* void lockImage() */
32424: NS_IMETHODIMP
50549: RasterImage::LockImage()
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // Cancel the discard timer if it's there
50547:   DiscardTracker::Remove(&mDiscardTrackerNode);
 7009: 
32424:   // Increment the lock count
32424:   mLockCount++;
32424: 
 7009:   return NS_OK;
 7009: }
 7009: 
32424: //******************************************************************************
32424: /* void unlockImage() */
 7009: NS_IMETHODIMP
50549: RasterImage::UnlockImage()
 7009: {
32424:   if (mError)
32424:     return NS_ERROR_FAILURE;
32424: 
32424:   // It's an error to call this function if the lock count is 0
32424:   NS_ABORT_IF_FALSE(mLockCount > 0,
32424:                     "Calling UnlockImage with mLockCount == 0!");
32424:   if (mLockCount == 0)
32424:     return NS_ERROR_ABORT;
32424: 
46991:   // We're locked, so discarding should not be active
46991:   NS_ABORT_IF_FALSE(!DiscardingActive(), "Locked, but discarding activated");
32424: 
32424:   // Decrement our lock count
32424:   mLockCount--;
32424: 
32424:   // We now _might_ have one of the qualifications for discarding. Re-evaluate.
32424:   if (CanDiscard()) {
50547:     nsresult rv = DiscardTracker::Reset(&mDiscardTrackerNode);
32424:     CONTAINER_ENSURE_SUCCESS(rv);
32424:   }
32424: 
 7009:   return NS_OK;
 7009: }
 7009: 
32424: // Flushes up to aMaxBytes to the decoder.
32424: nsresult
50549: RasterImage::DecodeSomeData(PRUint32 aMaxBytes)
 7009: {
32424:   // We should have a decoder if we get here
32424:   NS_ABORT_IF_FALSE(mDecoder, "trying to decode without decoder!");
32424: 
32424:   // If we have nothing to decode, return
32424:   if (mBytesDecoded == mSourceData.Length())
32424:     return NS_OK;
32424: 
32424: 
32424:   // write the proper amount of data
32424:   PRUint32 bytesToDecode = PR_MIN(aMaxBytes,
32424:                                   mSourceData.Length() - mBytesDecoded);
32424:   nsresult rv = WriteToDecoder(mSourceData.Elements() + mBytesDecoded,
32424:                                bytesToDecode);
32424: 
32424:   return rv;
32424: }
32424: 
32424: // There are various indicators that tell us we're finished with the decode
32424: // task at hand and can shut down the decoder.
51243: //
51243: // This method may not be called if there is no decoder.
50550: PRBool
50550: RasterImage::IsDecodeFinished()
32424: {
51243:   // Precondition
51243:   NS_ABORT_IF_FALSE(mDecoder, "Can't call IsDecodeFinished() without decoder!");
51243: 
32424:   // Assume it's not finished
32424:   PRBool decodeFinished = PR_FALSE;
32424: 
32424:   // There shouldn't be any reason to call this if we're not storing
32424:   // source data
32424:   NS_ABORT_IF_FALSE(StoringSourceData(),
32424:                     "just shut down on SourceDataComplete!");
32424: 
32424:   // The decode is complete if we got what we wanted...
51244:   if (mDecoder->IsSizeDecode()) {
32424:     if (mHasSize)
32424:       decodeFinished = PR_TRUE;
32424:   }
32424:   else {
32424:     if (mDecoded)
32424:       decodeFinished = PR_TRUE;
32424:   }
32424: 
32424:   // ...or if we have all the source data and wrote all the source data.
32424:   //
32424:   // (NB - This can be distinct from the above case even for non-erroneous
32424:   // images because the decoder might not call DecodingComplete() until we
32424:   // call Close() in ShutdownDecoder())
32424:   if (mHasSourceData && (mBytesDecoded == mSourceData.Length()))
32424:     decodeFinished = PR_TRUE;
32424: 
32424:   return decodeFinished;
32424: }
32424: 
53671: // Indempotent error flagging routine. If a decoder is open, shuts it down.
50550: void
50550: RasterImage::DoError()
32424: {
32424:   // If we've flagged an error before, we have nothing to do
32424:   if (mError)
32424:     return;
32424: 
53671:   // If we're mid-decode, shut down the decoder.
53671:   if (mDecoder)
53671:     ShutdownDecoder(eShutdownIntent_Error);
32424: 
32424:   // Put the container in an error state
32424:   mError = PR_TRUE;
32424: 
32424:   // Log our error
32424:   LOG_CONTAINER_ERROR;
32424: }
32424: 
32424: // Decodes some data, then re-posts itself to the end of the event queue if
32424: // there's more processing to be done
50550: NS_IMETHODIMP
50550: imgDecodeWorker::Run()
32424: {
32424:   nsresult rv;
32424: 
32424:   // If we shutdown the decoder in this function, we could lose ourselves
32424:   nsCOMPtr<nsIRunnable> kungFuDeathGrip(this);
32424: 
32424:   // The container holds a strong reference to us. Cycles are bad.
32424:   nsCOMPtr<imgIContainer> iContainer(do_QueryReferent(mContainer));
32424:   if (!iContainer)
32424:     return NS_OK;
50556:   RasterImage* image = static_cast<RasterImage*>(iContainer.get());
50556: 
50556:   NS_ABORT_IF_FALSE(image->mInitialized,
32424:                     "Worker active for uninitialized container!");
32424: 
32424:   // If we were pending, we're not anymore
50556:   image->mWorkerPending = PR_FALSE;
32424: 
32424:   // If an error is flagged, it probably happened while we were waiting
32424:   // in the event queue. Bail early, but no need to bother the run queue
32424:   // by returning an error.
50556:   if (image->mError)
32424:     return NS_OK;
32424: 
32424:   // If we don't have a decoder, we must have finished already (for example,
32424:   // a synchronous decode request came while the worker was pending).
50556:   if (!image->mDecoder)
32424:     return NS_OK;
32424: 
51244:   // Size decodes are cheap and we more or less want them to be
32424:   // synchronous. Write all the data in that case, otherwise write a
32424:   // chunk
51244:   PRUint32 maxBytes = image->mDecoder->IsSizeDecode()
51590:     ? image->mSourceData.Length() : gDecodeBytesAtATime;
32424: 
32424:   // Loop control
32424:   PRBool haveMoreData = PR_TRUE;
51590:   nsTime deadline(PR_Now() + 1000 * gMaxMSBeforeYield);
32424: 
32424:   // We keep decoding chunks until one of three possible events occur:
32424:   // 1) We don't have any data left to decode
32424:   // 2) The decode completes
32424:   // 3) We hit the deadline and need to yield to keep the UI snappy
50556:   while (haveMoreData && !image->IsDecodeFinished() &&
32424:          (nsTime(PR_Now()) < deadline)) {
32424: 
32424:     // Decode a chunk of data
50556:     rv = image->DecodeSomeData(maxBytes);
32424:     if (NS_FAILED(rv)) {
50556:       image->DoError();
32424:       return rv;
32424:     }
32424: 
32424:     // Figure out if we still have more data
32424:     haveMoreData =
50556:       image->mSourceData.Length() > image->mBytesDecoded;
32424:   }
32424: 
51593:   // Flush invalidations _after_ we've written everything we're going to.
51594:   // Furthermore, if this is a redecode, we don't want to do progressive
51594:   // display at all. In that case, let Decoder::PostFrameStop() do the
51594:   // flush once the whole frame is ready.
51594:   if (!image->mHasBeenDecoded) {
51593:     image->mInDecoder = PR_TRUE;
51593:     image->mDecoder->FlushInvalidations();
51593:     image->mInDecoder = PR_FALSE;
51594:   }
51593: 
32424:   // If the decode finished, shutdown the decoder
50556:   if (image->IsDecodeFinished()) {
50556:     rv = image->ShutdownDecoder(RasterImage::eShutdownIntent_Done);
32424:     if (NS_FAILED(rv)) {
50556:       image->DoError();
32424:       return rv;
32424:     }
32424:   }
32424: 
32424:   // If Conditions 1 & 2 are still true, then the only reason we bailed was
32424:   // because we hit the deadline. Repost ourselves to the end of the event
32424:   // queue.
51243:   if (image->mDecoder && !image->IsDecodeFinished() && haveMoreData)
32424:     return this->Dispatch();
32424: 
32424:   // Otherwise, return success
 7009:   return NS_OK;
 7009: }
 7009: 
32424: // Queues the worker up at the end of the event queue
32424: NS_METHOD imgDecodeWorker::Dispatch()
 7009: {
32424:   // The container holds a strong reference to us. Cycles are bad.
32424:   nsCOMPtr<imgIContainer> iContainer(do_QueryReferent(mContainer));
32424:   if (!iContainer)
32424:     return NS_OK;
50556:   RasterImage* image = static_cast<RasterImage*>(iContainer.get());
32424: 
32424:   // We should not be called if there's already a pending worker
50556:   NS_ABORT_IF_FALSE(!image->mWorkerPending,
32424:                     "Trying to queue up worker with one already pending!");
32424: 
32424:   // Flag that we're pending
50556:   image->mWorkerPending = PR_TRUE;
32424: 
32424:   // Dispatch
32424:   return NS_DispatchToCurrentThread(this);
32424: }
32424: 
32424: // nsIInputStream callback to copy the incoming image data directly to the 
50556: // RasterImage without processing. The RasterImage is passed as the closure.
32424: // Always reads everything it gets, even if the data is erroneous.
32424: NS_METHOD
50556: RasterImage::WriteToRasterImage(nsIInputStream* /* unused */,
50556:                                 void*          aClosure,
50556:                                 const char*    aFromRawSegment,
50556:                                 PRUint32       /* unused */,
50556:                                 PRUint32       aCount,
50556:                                 PRUint32*      aWriteCount)
32424: {
50549:   // Retrieve the RasterImage
50556:   RasterImage* image = static_cast<RasterImage*>(aClosure);
32424: 
32424:   // Copy the source data. We squelch the return value here, because returning
32424:   // an error means that ReadSegments stops reading data, violating our
32424:   // invariant that we read everything we get.
50556:   (void) image->AddSourceData(aFromRawSegment, aCount);
32424: 
32424:   // We wrote everything we got
50556:   *aWriteCount = aCount;
32424: 
 7009:   return NS_OK;
 7009: }
50549: 
52149: PRBool
52149: RasterImage::ShouldAnimate()
52149: {
52149:   return Image::ShouldAnimate() && mFrames.Length() >= 2 &&
57656:          !mAnimationFinished;
52149: }
52149: 
52150: //******************************************************************************
52150: /* readonly attribute PRUint32 framesNotified; */
52150: #ifdef DEBUG
52150: NS_IMETHODIMP
52150: RasterImage::GetFramesNotified(PRUint32 *aFramesNotified)
52150: {
52150:   NS_ENSURE_ARG_POINTER(aFramesNotified);
52150: 
52150:   *aFramesNotified = mFramesNotified;
52150: 
52150:   return NS_OK;
52150: }
52150: #endif
52150: 
50549: } // namespace imagelib
50549: } // namespace mozilla
