69270: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
69270:  * vim: sw=2 ts=8 et :
69270:  */
69270: /* ***** BEGIN LICENSE BLOCK *****
69270:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69270:  *
69270:  * The contents of this file are subject to the Mozilla Public License Version
69270:  * 1.1 (the "License"); you may not use this file except in compliance with
69270:  * the License. You may obtain a copy of the License at:
69270:  * http://www.mozilla.org/MPL/
69270:  *
69270:  * Software distributed under the License is distributed on an "AS IS" basis,
69270:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69270:  * for the specific language governing rights and limitations under the
69270:  * License.
69270:  *
69270:  * The Original Code is Mozilla Code.
69270:  *
69270:  * The Initial Developer of the Original Code is
69270:  *   The Mozilla Foundation
69270:  * Portions created by the Initial Developer are Copyright (C) 2011
69270:  * the Initial Developer. All Rights Reserved.
69270:  *
69270:  * Contributor(s):
69270:  *
69270:  * Alternatively, the contents of this file may be used under the terms of
69270:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69270:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69270:  * in which case the provisions of the GPL or the LGPL are applicable instead
69270:  * of those above. If you wish to allow use of your version of this file only
69270:  * under the terms of either the GPL or the LGPL, and not to allow others to
69270:  * use your version of this file under the terms of the MPL, indicate your
69270:  * decision by deleting the provisions above and replace them with the notice
69270:  * and other provisions required by the GPL or the LGPL. If you do not delete
69270:  * the provisions above, a recipient may use your version of this file under
69270:  * the terms of any one of the MPL, the GPL or the LGPL.
69270:  *
69270:  * ***** END LICENSE BLOCK ***** */
69270: 
69270: #include <unistd.h>
69270: #include <sys/types.h>
69270: #include <sys/wait.h>
69270: #include <errno.h>
69270: #include "nsCRTGlue.h"
69270: #include "prenv.h"
69270: 
69270: #include "GfxInfoX11.h"
69270: 
70448: #ifdef MOZ_CRASHREPORTER
69270: #include "nsExceptionHandler.h"
69270: #include "nsICrashReporter.h"
69270: #endif
69270: 
69270: namespace mozilla {
69270: namespace widget {
69270: 
69270: // these global variables will be set when firing the glxtest process
69270: int glxtest_pipe = 0;
69270: pid_t glxtest_pid = 0;
69270: 
69270: nsresult
69270: GfxInfo::Init()
69270: {
69270:     mMajorVersion = 0;
69270:     mMinorVersion = 0;
69270:     mIsMesa = false;
69270:     mIsNVIDIA = false;
69270:     mIsFGLRX = false;
69270:     return GfxInfoBase::Init();
69270: }
69270: 
69270: void
69270: GfxInfo::GetData()
69270: {
69270:     // to understand this function, see bug 639842. We retrieve the OpenGL driver information in a
69270:     // separate process to protect against bad drivers.
69270: 
69270:     // if glxtest_pipe == 0, that means that we already read the information
69270:     if (!glxtest_pipe)
69270:         return;
69270: 
69270:     enum { buf_size = 1024 };
69270:     char buf[buf_size];
69270:     ssize_t bytesread = read(glxtest_pipe,
69270:                              &buf,
69270:                              buf_size-1); // -1 because we'll append a zero
69270:     close(glxtest_pipe);
69270:     glxtest_pipe = 0;
69270: 
69270:     // bytesread < 0 would mean that the above read() call failed. This should never happen.
69270:     if (bytesread < 0)
69270:         bytesread = 0;
69270: 
69270:     // let buf be a zero-terminated string
69270:     buf[bytesread] = 0;
69270: 
69270:     // Wait for the glxtest process to finish. This serves 2 purposes:
69270:     // * avoid having a zombie glxtest process laying around
69270:     // * get the glxtest process status info.
69270:     int glxtest_status = 0;
69270:     bool wait_for_glxtest_process = true;
69270:     bool waiting_for_glxtest_process_failed = false;
69270:     while(wait_for_glxtest_process) {
69270:         wait_for_glxtest_process = false;
69270:         if (waitpid(glxtest_pid, &glxtest_status, 0) == -1) {
69270:             if (errno == EINTR)
69270:                 wait_for_glxtest_process = true;
69270:             else
69270:                 waiting_for_glxtest_process_failed = true;
69270:         }
69270:     }
69270: 
69270:     bool exited_with_error_code = !waiting_for_glxtest_process_failed &&
69270:                                   WIFEXITED(glxtest_status) && 
69270:                                   WEXITSTATUS(glxtest_status) != EXIT_SUCCESS;
69270:     bool received_signal = !waiting_for_glxtest_process_failed &&
69270:                            WIFSIGNALED(glxtest_status);
69270: 
69270:     bool error = waiting_for_glxtest_process_failed || exited_with_error_code || received_signal;
69270: 
69270:     nsCString *stringToFill = nsnull;
69270:     char *bufptr = buf;
69270:     if (!error) {
69270:         while(true) {
69270:             char *line = NS_strtok("\n", &bufptr);
69270:             if (!line)
69270:                 break;
69270:             if (stringToFill) {
69270:                 stringToFill->Assign(line);
69270:                 stringToFill = nsnull;
69270:             }
69270:             else if(!strcmp(line, "VENDOR"))
69270:                 stringToFill = &mVendor;
69270:             else if(!strcmp(line, "RENDERER"))
69270:                 stringToFill = &mRenderer;
69270:             else if(!strcmp(line, "VERSION"))
69270:                 stringToFill = &mVersion;
69270:         }
69270:     }
69270: 
69270:     const char *spoofedVendor = PR_GetEnv("MOZ_GFX_SPOOF_GL_VENDOR");
69270:     if (spoofedVendor)
69270:         mVendor.Assign(spoofedVendor);
69270:     const char *spoofedRenderer = PR_GetEnv("MOZ_GFX_SPOOF_GL_RENDERER");
69270:     if (spoofedRenderer)
69270:         mRenderer.Assign(spoofedRenderer);
69270:     const char *spoofedVersion = PR_GetEnv("MOZ_GFX_SPOOF_GL_VERSION");
69270:     if (spoofedVersion)
69270:         mVersion.Assign(spoofedVersion);
69270: 
69270:     if (error ||
69270:         mVendor.IsEmpty() ||
69270:         mRenderer.IsEmpty() ||
69270:         mVersion.IsEmpty())
69270:     {
69270:         mAdapterDescription.AppendLiteral("GLXtest process failed");
69270:         if (waiting_for_glxtest_process_failed)
69270:             mAdapterDescription.AppendLiteral(" (waitpid failed)");
69270:         if (exited_with_error_code)
69270:             mAdapterDescription.AppendPrintf(" (exited with status %d)", WEXITSTATUS(glxtest_status));
69270:         if (received_signal)
69270:             mAdapterDescription.AppendPrintf(" (received signal %d)", WTERMSIG(glxtest_status));
69270:         if (bytesread) {
69270:             mAdapterDescription.AppendLiteral(": ");
69270:             mAdapterDescription.Append(nsDependentCString(buf));
69270:             mAdapterDescription.AppendLiteral("\n");
69270:         }
70448: #ifdef MOZ_CRASHREPORTER
69270:         CrashReporter::AppendAppNotesToCrashReport(mAdapterDescription);
69270: #endif
69270:         return;
69270:     }
69270: 
69270:     mAdapterDescription.Append(mVendor);
69270:     mAdapterDescription.AppendLiteral(" -- ");
69270:     mAdapterDescription.Append(mRenderer);
69270: 
69270:     nsCAutoString note;
69270:     note.Append("OpenGL: ");
69270:     note.Append(mAdapterDescription);
69270:     note.Append(" -- ");
69270:     note.Append(mVersion);
69270:     note.Append("\n");
70448: #ifdef MOZ_CRASHREPORTER
69270:     CrashReporter::AppendAppNotesToCrashReport(note);
69270: #endif
69270: 
69270:     // determine driver type (vendor) and where in the version string
69270:     // the actual driver version numbers should be expected to be found (whereToReadVersionNumbers)
69270:     const char *whereToReadVersionNumbers = nsnull;
69270:     const char *Mesa_in_version_string = strstr(mVersion.get(), "Mesa");
69270:     if (Mesa_in_version_string) {
69270:         mIsMesa = true;
69270:         // with Mesa, the version string contains "Mesa major.minor" and that's all the version information we get:
69270:         // there is no actual driver version info.
69270:         whereToReadVersionNumbers = Mesa_in_version_string + strlen("Mesa");
69270:     } else if (strstr(mVendor.get(), "NVIDIA Corporation")) {
69270:         mIsNVIDIA = true;
69270:         // with the NVIDIA driver, the version string contains "NVIDIA major.minor"
69270:         // note that here the vendor and version strings behave differently, that's why we don't put this above
69270:         // alongside Mesa_in_version_string.
69270:         const char *NVIDIA_in_version_string = strstr(mVersion.get(), "NVIDIA");
69270:         if (NVIDIA_in_version_string)
69270:             whereToReadVersionNumbers = NVIDIA_in_version_string + strlen("NVIDIA");
69270:     } else if (strstr(mVendor.get(), "ATI Technologies Inc")) {
69270:         mIsFGLRX = true;
69270:         // with the FGLRX driver, the version string only gives a OpenGL version :/ so let's return that.
69270:         // that can at least give a rough idea of how old the driver is.
69270:         whereToReadVersionNumbers = mVersion.get();
69270:     }
69270: 
69270:     // read major.minor version numbers
69270:     if (whereToReadVersionNumbers) {
69270:         // copy into writable buffer, for tokenization
69270:         strncpy(buf, whereToReadVersionNumbers, buf_size);
69270:         bufptr = buf;
69270: 
69270:         // now try to read major.minor version numbers. In case of failure, gracefully exit: these numbers have
69270:         // been initialized as 0 anyways
69270:         char *token = NS_strtok(".", &bufptr);
69270:         if (token) {
69270:             mMajorVersion = strtol(token, 0, 10);
69270:             token = NS_strtok(".", &bufptr);
69270:             if (token)
69270:                 mMinorVersion = strtol(token, 0, 10);
69270:         }
69270:     }
69270: }
69270: 
69270: static inline PRUint64 version(PRUint32 major, PRUint32 minor)
69270: {
69270:     return (PRUint64(major) << 32) + PRUint64(minor);
69270: }
69270: 
69270: nsresult
69270: GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature, PRInt32 *aStatus, nsAString & aSuggestedDriverVersion, GfxDriverInfo* aDriverInfo /* = nsnull */)
69270: {
69270:     GetData();
69270:     *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
69270:     aSuggestedDriverVersion.SetIsVoid(PR_TRUE);
69270: 
69270: #ifdef MOZ_PLATFORM_MAEMO
69270:     // on Maemo, the glxtest probe doesn't build, and we don't really need GfxInfo anyway
69270:     return NS_OK;
69270: #endif
69270: 
69270:     // whitelist the linux test slaves' current configuration.
69270:     // this is necessary as they're still using the slightly outdated 190.42 driver.
69270:     // this isn't a huge risk, as at least this is the exact setting in which we do continuous testing,
69270:     // and this only affects GeForce 9400 cards on linux on this precise driver version, which is very few users.
69270:     // We do the same thing on Windows XP, see in widget/src/windows/GfxInfo.cpp
69270:     if (mIsNVIDIA &&
69270:         !strcmp(mRenderer.get(), "GeForce 9400/PCI/SSE2") &&
69270:         !strcmp(mVersion.get(), "3.2.0 NVIDIA 190.42"))
69270:     {
69270:         return NS_OK;
69270:     }
69270: 
69270:     if (mIsMesa) {
69270:         if (version(mMajorVersion, mMinorVersion) < version(7,10)) {
69270:             *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
69270:             aSuggestedDriverVersion.AssignLiteral("Mesa 7.10");
69270:         }
69270:     } else if (mIsNVIDIA) {
69270:         if (version(mMajorVersion, mMinorVersion) < version(257,21)) {
69270:             *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
69270:             aSuggestedDriverVersion.AssignLiteral("NVIDIA 257.21");
69270:         }
69270:     } else if (mIsFGLRX) {
69270:         // FGLRX does not report a driver version number, so we have the OpenGL version instead.
69270:         // by requiring OpenGL 3, we effectively require recent drivers.
69270:         if (version(mMajorVersion, mMinorVersion) < version(3, 0)) {
69270:             *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
69270:         }
69270:     } else {
69270:         // like on windows, let's block unknown vendors. Think of virtual machines.
69270:         // Also, this case is hit whenever the GLXtest probe failed to get driver info or crashed.
69270:         *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
69270:     }
69270:   return NS_OK;
69270: }
69270: 
69270: 
69270: NS_IMETHODIMP
69270: GfxInfo::GetD2DEnabled(PRBool *aEnabled)
69270: {
69270:   return NS_ERROR_FAILURE;
69270: }
69270: 
69270: NS_IMETHODIMP
69270: GfxInfo::GetDWriteEnabled(PRBool *aEnabled)
69270: {
69270:   return NS_ERROR_FAILURE;
69270: }
69270: 
72430: NS_IMETHODIMP
72430: GfxInfo::GetAzureEnabled(PRBool *aEnabled)
72430: {
72430:   return NS_ERROR_FAILURE;
72430: }
72430: 
69270: /* readonly attribute DOMString DWriteVersion; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
69270: {
69270:   return NS_ERROR_FAILURE;
69270: }
69270: 
69664: /* readonly attribute DOMString cleartypeParameters; */
69664: NS_IMETHODIMP
69664: GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
69664: {
69664:   return NS_ERROR_FAILURE;
69664: }
69664: 
69270: /* readonly attribute DOMString adapterDescription; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
69270: {
69270:   GetData();
69270:   AppendASCIItoUTF16(mAdapterDescription, aAdapterDescription);
69270:   return NS_OK;
69270: }
69270: 
69270: /* readonly attribute DOMString adapterRAM; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
69270: {
69270:   aAdapterRAM.AssignLiteral("");
69270:   return NS_OK;
69270: }
69270: 
69270: /* readonly attribute DOMString adapterDriver; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
69270: {
69270:   aAdapterDriver.AssignLiteral("");
69270:   return NS_OK;
69270: }
69270: 
69270: /* readonly attribute DOMString adapterDriverVersion; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
69270: {
69270:   GetData();
69270:   CopyASCIItoUTF16(mVersion, aAdapterDriverVersion);
69270:   return NS_OK;
69270: }
69270: 
69270: /* readonly attribute DOMString adapterDriverDate; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
69270: {
69270:   aAdapterDriverDate.AssignLiteral("");
69270:   return NS_OK;
69270: }
69270: 
69270: /* readonly attribute unsigned long adapterVendorID; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterVendorID(PRUint32 *aAdapterVendorID)
69270: {
69270:   *aAdapterVendorID = 0;
69270:   return NS_OK;
69270: }
69270: 
69270: /* readonly attribute unsigned long adapterDeviceID; */
69270: NS_IMETHODIMP
69270: GfxInfo::GetAdapterDeviceID(PRUint32 *aAdapterDeviceID)
69270: {
69270:   *aAdapterDeviceID = 0;
69270:   return NS_OK;
69270: }
69270: 
69270: 
69270: } // end namespace widget
69270: } // end namespace mozilla
