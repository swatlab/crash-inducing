 29805: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 29805: /* vim: set ts=2 sw=2 et tw=78: */
 99753: /* This Source Code Form is subject to the terms of the Mozilla Public
 99753:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99753:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 29805: 
 29805: #include "nsHtml5TreeOperation.h"
 31420: #include "nsContentUtils.h"
136234: #include "nsDocElementCreatedNotificationRunner.h"
 29805: #include "nsNodeUtils.h"
 29805: #include "nsAttrName.h"
 29805: #include "nsHtml5TreeBuilder.h"
 31420: #include "nsIDOMMutationEvent.h"
 31420: #include "mozAutoDocUpdate.h"
 31420: #include "nsBindingManager.h"
 31420: #include "nsXBLBinding.h"
 32917: #include "nsHtml5DocumentMode.h"
 34978: #include "nsHtml5HtmlAttributes.h"
 34978: #include "nsContentCreatorFunctions.h"
 34978: #include "nsIScriptElement.h"
 34978: #include "nsIDTD.h"
189051: #include "nsISupportsImpl.h"
 34978: #include "nsIDOMHTMLFormElement.h"
 34978: #include "nsIFormControl.h"
 34978: #include "nsIStyleSheetLinkingElement.h"
 34978: #include "nsIDOMDocumentType.h"
 51669: #include "nsIObserverService.h"
 51669: #include "mozilla/Services.h"
 35600: #include "nsIMutationObserver.h"
 38730: #include "nsIFormProcessor.h"
 38730: #include "nsIServiceManager.h"
 48406: #include "nsEscape.h"
140150: #include "mozilla/dom/Comment.h"
 51351: #include "mozilla/dom/Element.h"
147821: #include "mozilla/dom/HTMLImageElement.h"
137419: #include "mozilla/dom/HTMLTemplateElement.h"
 47894: #include "nsHtml5SVGLoadDispatcher.h"
 81151: #include "nsIURI.h"
 81151: #include "nsIProtocolHandler.h"
 81151: #include "nsNetUtil.h"
103385: #include "nsIHTMLDocument.h"
120353: #include "mozilla/Likely.h"
140148: #include "nsTextNode.h"
 47894: 
169944: using namespace mozilla;
 51351: 
 38730: static NS_DEFINE_CID(kFormProcessorCID, NS_FORMPROCESSOR_CID);
 29805: 
 35591: /**
 35591:  * Helper class that opens a notification batch if the current doc
 35591:  * is different from the executor doc.
 35591:  */
140327: class MOZ_STACK_CLASS nsHtml5OtherDocUpdate {
 35591:   public:
 35591:     nsHtml5OtherDocUpdate(nsIDocument* aCurrentDoc, nsIDocument* aExecutorDoc)
 35591:     {
 35591:       NS_PRECONDITION(aCurrentDoc, "Node has no doc?");
 35591:       NS_PRECONDITION(aExecutorDoc, "Executor has no doc?");
120353:       if (MOZ_LIKELY(aCurrentDoc == aExecutorDoc)) {
106838:         mDocument = nullptr;
 35591:       } else {
 35591:         mDocument = aCurrentDoc;
 35591:         aCurrentDoc->BeginUpdate(UPDATE_CONTENT_MODEL);        
 35591:       }
 35591:     }
 35591: 
 35591:     ~nsHtml5OtherDocUpdate()
 35591:     {
120353:       if (MOZ_UNLIKELY(mDocument)) {
 35591:         mDocument->EndUpdate(UPDATE_CONTENT_MODEL);
 35591:       }
 35591:     }
 35591:   private:
210881:     nsCOMPtr<nsIDocument> mDocument;
 35591: };
 35591: 
 29805: nsHtml5TreeOperation::nsHtml5TreeOperation()
 34979:  : mOpCode(eTreeOpUninitialized)
 29805: {
 29805:   MOZ_COUNT_CTOR(nsHtml5TreeOperation);
 29805: }
 29805: 
 29805: nsHtml5TreeOperation::~nsHtml5TreeOperation()
 29805: {
 29805:   MOZ_COUNT_DTOR(nsHtml5TreeOperation);
 34979:   NS_ASSERTION(mOpCode != eTreeOpUninitialized, "Uninitialized tree op.");
 34978:   switch(mOpCode) {
 34978:     case eTreeOpAddAttributes:
 34978:       delete mTwo.attributes;
 34978:       break;
 43386:     case eTreeOpCreateElementNetwork:
 43386:     case eTreeOpCreateElementNotNetwork:
 34978:       delete mThree.attributes;
 34978:       break;
 35600:     case eTreeOpAppendDoctypeToDocument:
 34978:       delete mTwo.stringPair;
 34978:       break;
 35600:     case eTreeOpFosterParentText:
 35600:     case eTreeOpAppendText:
 35600:     case eTreeOpAppendComment:
 35600:     case eTreeOpAppendCommentToDocument:
 81151:     case eTreeOpAddViewSourceHref:
 34978:       delete[] mTwo.unicharPtr;
 34978:       break;
 81150:     case eTreeOpSetDocumentCharset:
 34979:     case eTreeOpNeedsCharsetSwitchTo:
 34979:       delete[] mOne.charPtr;
 34979:       break;
 38132:     case eTreeOpProcessOfflineManifest:
 38132:       nsMemory::Free(mOne.unicharPtr);
 38132:       break;
 34978:     default: // keep the compiler happy
 34978:       break;
 34978:   }
 29805: }
 29805: 
 29805: nsresult
179103: nsHtml5TreeOperation::AppendTextToTextNode(const char16_t* aBuffer,
108991:                                            uint32_t aLength,
 35600:                                            nsIContent* aTextNode,
190519:                                            nsHtml5DocumentBuilder* aBuilder)
 35600: {
 35600:   NS_PRECONDITION(aTextNode, "Got null text node.");
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
108991:   uint32_t oldLength = aTextNode->TextLength();
 35600:   CharacterDataChangeInfo info = {
 80486:     true,
 35600:     oldLength,
 35600:     oldLength,
 35600:     aLength
 35600:   };
 35600:   nsNodeUtils::CharacterDataWillChange(aTextNode, &info);
 35600: 
210881:   nsresult rv = aTextNode->AppendText(aBuffer, aLength, false);
 35600:   NS_ENSURE_SUCCESS(rv, rv);
 35600: 
 35600:   nsNodeUtils::CharacterDataChanged(aTextNode, &info);
 35600:   return rv;
 35600: }
 35600: 
 35600: 
 35600: nsresult
179103: nsHtml5TreeOperation::AppendText(const char16_t* aBuffer,
108991:                                  uint32_t aLength,
 35600:                                  nsIContent* aParent,
190519:                                  nsHtml5DocumentBuilder* aBuilder)
 35600: {
 35600:   nsresult rv = NS_OK;
 35600:   nsIContent* lastChild = aParent->GetLastChild();
 35600:   if (lastChild && lastChild->IsNodeOfType(nsINode::eTEXT)) {
 80526:     nsHtml5OtherDocUpdate update(aParent->OwnerDoc(),
 35600:                                  aBuilder->GetDocument());
 35600:     return AppendTextToTextNode(aBuffer, 
 35600:                                 aLength, 
 35600:                                 lastChild, 
 35600:                                 aBuilder);
 35600:   }
 35600: 
140148:   nsRefPtr<nsTextNode> text = new nsTextNode(aBuilder->GetNodeInfoManager());
 35600:   NS_ASSERTION(text, "Infallible malloc failed?");
 80486:   rv = text->SetText(aBuffer, aLength, false);
 35600:   NS_ENSURE_SUCCESS(rv, rv);
 35600: 
 35600:   return Append(text, aParent, aBuilder);
 35600: }
 35600: 
 35600: nsresult
 35600: nsHtml5TreeOperation::Append(nsIContent* aNode,
 35600:                              nsIContent* aParent,
190519:                              nsHtml5DocumentBuilder* aBuilder)
 35600: {
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
 35600:   nsresult rv = NS_OK;
210881:   nsHtml5OtherDocUpdate update(aParent->OwnerDoc(),
210881:                                aBuilder->GetDocument());
108991:   uint32_t childCount = aParent->GetChildCount();
 80486:   rv = aParent->AppendChildTo(aNode, false);
 74136:   if (NS_SUCCEEDED(rv)) {
210881:     aNode->SetParserHasNotified();
 42107:     nsNodeUtils::ContentAppended(aParent, aNode, childCount);
 74136:   }
 35600:   return rv;
 35600: }
 35600: 
 35600: nsresult
 35600: nsHtml5TreeOperation::AppendToDocument(nsIContent* aNode,
190519:                                        nsHtml5DocumentBuilder* aBuilder)
 35600: {
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->GetDocument() == aNode->OwnerDoc());
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
 35600:   nsresult rv = NS_OK;
210881: 
 35600:   nsIDocument* doc = aBuilder->GetDocument();
108991:   uint32_t childCount = doc->GetChildCount();
 80486:   rv = doc->AppendChildTo(aNode, false);
 35600:   NS_ENSURE_SUCCESS(rv, rv);
210881:   aNode->SetParserHasNotified();
 35600:   nsNodeUtils::ContentInserted(doc, aNode, childCount);
 51669: 
 51669:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 51669:                "Someone forgot to block scripts");
 67662:   if (aNode->IsElement()) {
 51669:     nsContentUtils::AddScriptRunner(
 51669:         new nsDocElementCreatedNotificationRunner(doc));
 67662:   }
 35600:   return rv;
 35600: }
 35600: 
171717: static bool
171717: IsElementOrTemplateContent(nsINode* aNode) {
171717:   if (aNode) {
171717:     if (aNode->IsElement()) {
171717:       return true;
171717:     } else if (aNode->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
171717:       // Check if the node is a template content.
171717:       mozilla::dom::DocumentFragment* frag =
171717:         static_cast<mozilla::dom::DocumentFragment*>(aNode);
171717:       nsIContent* fragHost = frag->GetHost();
171717:       if (fragHost && nsNodeUtils::IsTemplateElement(fragHost)) {
171717:         return true;
171717:       }
171717:     }
171717:   }
171717:   return false;
171717: }
171717: 
190518: void
190519: nsHtml5TreeOperation::Detach(nsIContent* aNode, nsHtml5DocumentBuilder* aBuilder)
 29805: {
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
190518:   nsCOMPtr<nsINode> parent = aNode->GetParentNode();
 29805:   if (parent) {
 80526:     nsHtml5OtherDocUpdate update(parent->OwnerDoc(),
 35591:         aBuilder->GetDocument());
190518:     int32_t pos = parent->IndexOf(aNode);
 29805:     NS_ASSERTION((pos >= 0), "Element not found as child of its parent");
 94359:     parent->RemoveChildAt(pos, true);
 29805:   }
 29805: }
190518: 
190518: nsresult
190518: nsHtml5TreeOperation::AppendChildrenToNewParent(nsIContent* aNode,
190518:                                                 nsIContent* aParent,
190519:                                                 nsHtml5DocumentBuilder* aBuilder)
190518: {
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
190518:   nsHtml5OtherDocUpdate update(aParent->OwnerDoc(),
 35591:                                aBuilder->GetDocument());
 35591: 
190518:   uint32_t childCount = aParent->GetChildCount();
 79445:   bool didAppend = false;
190518:   while (aNode->HasChildren()) {
190518:     nsCOMPtr<nsIContent> child = aNode->GetFirstChild();
190518:     aNode->RemoveChildAt(0, true);
190518:     nsresult rv = aParent->AppendChildTo(child, false);
 29805:     NS_ENSURE_SUCCESS(rv, rv);
 80486:     didAppend = true;
 29805:   }
 29805:   if (didAppend) {
190518:     nsNodeUtils::ContentAppended(aParent, aParent->GetChildAt(childCount),
 42107:                                  childCount);
 29805:   }
190518:   return NS_OK;
 29805: }
190518: 
190518: nsresult
190518: nsHtml5TreeOperation::FosterParent(nsIContent* aNode,
190518:                                    nsIContent* aParent,
190518:                                    nsIContent* aTable,
190519:                                    nsHtml5DocumentBuilder* aBuilder)
190518: {
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
190518:   nsIContent* foster = aTable->GetParent();
 35591: 
171717:   if (IsElementOrTemplateContent(foster)) {
 35591: 
 80526:     nsHtml5OtherDocUpdate update(foster->OwnerDoc(),
 35591:                                  aBuilder->GetDocument());
 35591: 
190518:     uint32_t pos = foster->IndexOf(aTable);
190518:     nsresult rv = foster->InsertChildAt(aNode, pos, false);
 29805:     NS_ENSURE_SUCCESS(rv, rv);
190518:     nsNodeUtils::ContentInserted(foster, aNode, pos);
 35591:     return rv;
 35591:   }
 35591: 
190518:   return Append(aNode, aParent, aBuilder);
 29805: }
 31420: 
190518: nsresult
190518: nsHtml5TreeOperation::AddAttributes(nsIContent* aNode,
190518:                                     nsHtml5HtmlAttributes* aAttributes,
190519:                                     nsHtml5DocumentBuilder* aBuilder)
190518: {
190518:   dom::Element* node = aNode->AsElement();
 80526:   nsHtml5OtherDocUpdate update(node->OwnerDoc(),
 35591:                                aBuilder->GetDocument());
 35591: 
190518:   int32_t len = aAttributes->getLength();
108991:   for (int32_t i = len; i > 0;) {
 37467:     --i;
 34978:     // prefix doesn't need regetting. it is always null or a static atom
 34978:     // local name is never null
115605:     nsCOMPtr<nsIAtom> localName =
190518:       Reget(aAttributes->getLocalNameNoBoundsCheck(i));
190518:     int32_t nsuri = aAttributes->getURINoBoundsCheck(i);
 34978:     if (!node->HasAttr(nsuri, localName)) {
 34978:       // prefix doesn't need regetting. it is always null or a static atom
 34978:       // local name is never null
115605:       node->SetAttr(nsuri,
115605:                     localName,
190518:                     aAttributes->getPrefixNoBoundsCheck(i),
190518:                     *(aAttributes->getValueNoBoundsCheck(i)),
115605:                     true);
 34978:       // XXX what to do with nsresult?
 29805:     }
 29805:   }
190518:   return NS_OK;
190518: }
190333: 
 34978: 
190518: nsIContent*
190518: nsHtml5TreeOperation::CreateElement(int32_t aNs,
190518:                                     nsIAtom* aName,
190518:                                     nsHtml5HtmlAttributes* aAttributes,
190520:                                     mozilla::dom::FromParser aFromParser,
190519:                                     nsHtml5DocumentBuilder* aBuilder)
190518: {
190518:   bool isKeygen = (aName == nsHtml5Atoms::keygen && aNs == kNameSpaceID_XHTML);
120353:   if (MOZ_UNLIKELY(isKeygen)) {
190518:     aName = nsHtml5Atoms::select;
 38730:   }
 38730: 
210881:   nsCOMPtr<dom::Element> newElement;
211644:   nsRefPtr<dom::NodeInfo> nodeInfo = aBuilder->GetNodeInfoManager()->
190518:     GetNodeInfo(aName, nullptr, aNs, nsIDOMNode::ELEMENT_NODE);
 34978:   NS_ASSERTION(nodeInfo, "Got null nodeinfo.");
210881:   NS_NewElement(getter_AddRefs(newElement),
 82294:                 nodeInfo.forget(),
190520:                 aFromParser);
210881:   NS_ASSERTION(newElement, "Element creation created null pointer.");
 34978: 
210881:   dom::Element* newContent = newElement;
210881:   aBuilder->HoldElement(newElement.forget());
 34978: 
190518:   if (MOZ_UNLIKELY(aName == nsHtml5Atoms::style || aName == nsHtml5Atoms::link)) {
 34991:     nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(newContent));
 34991:     if (ssle) {
 80486:       ssle->InitStyleLinkElement(false);
 80486:       ssle->SetEnableUpdates(false);
 34991:     }
120353:   } else if (MOZ_UNLIKELY(isKeygen)) {
 38730:     // Adapted from CNavDTD
190518:     nsresult rv;
 38730:     nsCOMPtr<nsIFormProcessor> theFormProcessor =
 38730:       do_GetService(kFormProcessorCID, &rv);
178285:     if (NS_FAILED(rv)) {
190518:       return newContent;
178285:     }
 38730: 
 38730:     nsTArray<nsString> theContent;
 38730:     nsAutoString theAttribute;
 38730: 
 38730:     (void) theFormProcessor->ProvideContent(NS_LITERAL_STRING("select"),
 38730:                                             theContent,
 38730:                                             theAttribute);
 38730: 
 38730:     newContent->SetAttr(kNameSpaceID_None,
 38730:                         nsGkAtoms::moztype,
106838:                         nullptr,
 38730:                         theAttribute,
 80486:                         false);
 38730: 
211644:     nsRefPtr<dom::NodeInfo> optionNodeInfo =
 38730:       aBuilder->GetNodeInfoManager()->GetNodeInfo(nsHtml5Atoms::option,
106838:                                                   nullptr,
 71770:                                                   kNameSpaceID_XHTML,
 71770:                                                   nsIDOMNode::ELEMENT_NODE);
 38730: 
108991:     for (uint32_t i = 0; i < theContent.Length(); ++i) {
174211:       nsCOMPtr<dom::Element> optionElt;
211644:       nsRefPtr<dom::NodeInfo> ni = optionNodeInfo;
 38730:       NS_NewElement(getter_AddRefs(optionElt),
 48124:                     ni.forget(),
190520:                     aFromParser);
140148:       nsRefPtr<nsTextNode> optionText =
140148:         new nsTextNode(aBuilder->GetNodeInfoManager());
 80486:       (void) optionText->SetText(theContent[i], false);
 80486:       optionElt->AppendChildTo(optionText, false);
 80486:       newContent->AppendChildTo(optionElt, false);
210881:       // XXXsmaug Shouldn't we call this after adding all the child nodes.
 80486:       newContent->DoneAddingChildren(false);
 38730:     }
 34991:   }
 34991: 
190518:   if (!aAttributes) {
190518:     return newContent;
 34978:   }
 34978: 
190518:   int32_t len = aAttributes->getLength();
108991:   for (int32_t i = len; i > 0;) {
 37467:     --i;
 34978:     // prefix doesn't need regetting. it is always null or a static atom
 34978:     // local name is never null
115605:     nsCOMPtr<nsIAtom> localName =
190518:       Reget(aAttributes->getLocalNameNoBoundsCheck(i));
190518:     nsCOMPtr<nsIAtom> prefix = aAttributes->getPrefixNoBoundsCheck(i);
190518:     int32_t nsuri = aAttributes->getURINoBoundsCheck(i);
188343: 
190518:     if (aNs == kNameSpaceID_XHTML &&
190518:         nsHtml5Atoms::a == aName &&
 48406:         nsHtml5Atoms::name == localName) {
 48406:       // This is an HTML5-incompliant Geckoism.
 48406:       // Remove when fixing bug 582361
190518:       NS_ConvertUTF16toUTF8 cname(*(aAttributes->getValueNoBoundsCheck(i)));
 48406:       NS_ConvertUTF8toUTF16 uv(nsUnescape(cname.BeginWriting()));
188343:       newContent->SetAttr(nsuri,
115605:                           localName,
188343:                           prefix,
115605:                           uv,
115605:                           false);
 48406:     } else {
190518:       nsString& value = *(aAttributes->getValueNoBoundsCheck(i));
188343:       newContent->SetAttr(nsuri,
115605:                           localName,
188343:                           prefix,
188343:                           value,
115605:                           false);
188343: 
188343:       // Custom element prototype swizzling may be needed if there is an
188343:       // "is" attribute.
188343:       if (kNameSpaceID_None == nsuri && !prefix && nsGkAtoms::is == localName) {
188343:         ErrorResult errorResult;
188343:         newContent->OwnerDoc()->SwizzleCustomElement(newContent,
188343:                                                      value,
188343:                                                      newContent->GetNameSpaceID(),
188343:                                                      errorResult);
188343:       }
 48406:     }
 34978:   }
190518:   return newContent;
190518: }
 38730: 
190518: void
190518: nsHtml5TreeOperation::SetFormElement(nsIContent* aNode, nsIContent* aParent)
190518: {
190518:   nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(aNode));
190518:   nsCOMPtr<nsIDOMHTMLImageElement> domImageElement = do_QueryInterface(aNode);
 34988:   // NS_ASSERTION(formControl, "Form-associated element did not implement nsIFormControl.");
 51301:   // TODO: uncomment the above line when <keygen> (bug 101019) is supported by Gecko
190518:   nsCOMPtr<nsIDOMHTMLFormElement> formElement(do_QueryInterface(aParent));
 34978:   NS_ASSERTION(formElement, "The form element doesn't implement nsIDOMHTMLFormElement.");
 51301:   // avoid crashing on <keygen>
 51301:   if (formControl &&
190518:       !aNode->HasAttr(kNameSpaceID_None, nsGkAtoms::form)) {
 34978:     formControl->SetForm(formElement);
147821:   } else if (domImageElement) {
147821:     nsRefPtr<dom::HTMLImageElement> imageElement =
147821:       static_cast<dom::HTMLImageElement*>(domImageElement.get());
147821:     MOZ_ASSERT(imageElement);
147821:     imageElement->SetForm(formElement);
 34978:   }
190518: }
190333: 
190518: nsresult
190519: nsHtml5TreeOperation::AppendIsindexPrompt(nsIContent* parent, nsHtml5DocumentBuilder* aBuilder)
190518: {
 44175:   nsXPIDLString prompt;
 44175:   nsresult rv =
 44175:       nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
 44175:                                          "IsIndexPromptWithSpace", prompt);
108991:   uint32_t len = prompt.Length();
 44175:   if (NS_FAILED(rv)) {
 44175:     return rv;
 44175:   }
 44175:   if (!len) {
 44175:     // Don't bother appending a zero-length text node.
 44175:     return NS_OK;
 44175:   }
 44175:   return AppendText(prompt.BeginReading(), len, parent, aBuilder);
 44175: }
190518: 
190518: nsresult
190518: nsHtml5TreeOperation::FosterParentText(nsIContent* aStackParent,
190518:                                        char16_t* aBuffer,
190518:                                        uint32_t aLength,
190518:                                        nsIContent* aTable,
190519:                                        nsHtml5DocumentBuilder* aBuilder)
190518: {
210881:   MOZ_ASSERT(aBuilder);
210881:   MOZ_ASSERT(aBuilder->IsInDocUpdate());
190518:   nsresult rv = NS_OK;
190518:   nsIContent* foster = aTable->GetParent();
 35600: 
171717:   if (IsElementOrTemplateContent(foster)) {
 80526:     nsHtml5OtherDocUpdate update(foster->OwnerDoc(),
 35600:                                  aBuilder->GetDocument());
 35600: 
190518:     uint32_t pos = foster->IndexOf(aTable);
 35600: 
190518:     nsIContent* previousSibling = aTable->GetPreviousSibling();
 35600:     if (previousSibling && previousSibling->IsNodeOfType(nsINode::eTEXT)) {
190518:       return AppendTextToTextNode(aBuffer,
190518:                                   aLength,
 35600:                                   previousSibling,
 35600:                                   aBuilder);
 35600:     }
 34978: 
140148:     nsRefPtr<nsTextNode> text =
140148:       new nsTextNode(aBuilder->GetNodeInfoManager());
 35600:     NS_ASSERTION(text, "Infallible malloc failed?");
190518:     rv = text->SetText(aBuffer, aLength, false);
 35600:     NS_ENSURE_SUCCESS(rv, rv);
 34978: 
 80486:     rv = foster->InsertChildAt(text, pos, false);
 35600:     NS_ENSURE_SUCCESS(rv, rv);
 35600:     nsNodeUtils::ContentInserted(foster, text, pos);
 34978:     return rv;
 34978:   }
 35600: 
190518:   return AppendText(aBuffer, aLength, aStackParent, aBuilder);
190518: }
190518: 
190518: nsresult
190518: nsHtml5TreeOperation::AppendComment(nsIContent* aParent,
190518:                                     char16_t* aBuffer,
190518:                                     int32_t aLength,
190519:                                     nsHtml5DocumentBuilder* aBuilder)
190518: {
190518:   nsRefPtr<dom::Comment> comment =
190518:     new dom::Comment(aBuilder->GetNodeInfoManager());
190518:   NS_ASSERTION(comment, "Infallible malloc failed?");
190518:   nsresult rv = comment->SetText(aBuffer, aLength, false);
190518:   NS_ENSURE_SUCCESS(rv, rv);
190518: 
190518:   return Append(comment, aParent, aBuilder);
190518: }
190518: 
190518: nsresult
190518: nsHtml5TreeOperation::AppendCommentToDocument(char16_t* aBuffer,
190518:                                               int32_t aLength,
190519:                                               nsHtml5DocumentBuilder* aBuilder)
190518: {
190518:   nsRefPtr<dom::Comment> comment =
190518:     new dom::Comment(aBuilder->GetNodeInfoManager());
190518:   NS_ASSERTION(comment, "Infallible malloc failed?");
190518:   nsresult rv = comment->SetText(aBuffer, aLength, false);
190518:   NS_ENSURE_SUCCESS(rv, rv);
190518: 
190518:   return AppendToDocument(comment, aBuilder);
190518: }
190518: 
190518: nsresult
190518: nsHtml5TreeOperation::AppendDoctypeToDocument(nsIAtom* aName,
190518:                                               const nsAString& aPublicId,
190518:                                               const nsAString& aSystemId,
190519:                                               nsHtml5DocumentBuilder* aBuilder)
190518: {
190518:   // Adapted from nsXMLContentSink
190518:   // Create a new doctype node
190518:   nsCOMPtr<nsIDOMDocumentType> docType;
190518:   nsAutoString voidString;
190518:   voidString.SetIsVoid(true);
190518:   NS_NewDOMDocumentType(getter_AddRefs(docType),
190518:                         aBuilder->GetNodeInfoManager(),
190518:                         aName,
190518:                         aPublicId,
190518:                         aSystemId,
190518:                         voidString);
190518:   NS_ASSERTION(docType, "Doctype creation failed.");
190518:   nsCOMPtr<nsIContent> asContent = do_QueryInterface(docType);
190518:   return AppendToDocument(asContent, aBuilder);
190518: }
190518: 
190518: nsIContent*
190518: nsHtml5TreeOperation::GetDocumentFragmentForTemplate(nsIContent* aNode)
190518: {
190518:   dom::HTMLTemplateElement* tempElem =
190518:     static_cast<dom::HTMLTemplateElement*>(aNode);
190518:   nsRefPtr<dom::DocumentFragment> frag = tempElem->Content();
190518:   return frag;
190518: }
190518: 
190518: void
190518: nsHtml5TreeOperation::PreventScriptExecution(nsIContent* aNode)
190518: {
190518:   nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(aNode);
190518:   MOZ_ASSERT(sele);
190518:   sele->PreventExecution();
190518: }
190518: 
190518: void
210881: nsHtml5TreeOperation::DoneAddingChildren(nsIContent* aNode)
190518: {
210881:   aNode->DoneAddingChildren(aNode->HasParserNotified());
190518: }
190518: 
190518: void
190518: nsHtml5TreeOperation::DoneCreatingElement(nsIContent* aNode)
190518: {
190518:   aNode->DoneCreatingElement();
190518: }
190518: 
190523: void
190523: nsHtml5TreeOperation::SvgLoad(nsIContent* aNode)
190523: {
190523:   nsCOMPtr<nsIRunnable> event = new nsHtml5SVGLoadDispatcher(aNode);
190523:   if (NS_FAILED(NS_DispatchToMainThread(event))) {
190523:     NS_WARNING("failed to dispatch svg load dispatcher");
190523:   }
190523: }
190523: 
190523: void
190523: nsHtml5TreeOperation::MarkMalformedIfScript(nsIContent* aNode)
190523: {
190523:   nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(aNode);
190523:   if (sele) {
190523:     // Make sure to serialize this script correctly, for nice round tripping.
190523:     sele->SetIsMalformed();
190523:   }
190523: }
190523: 
190518: nsresult
190518: nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
190518:                               nsIContent** aScriptElement)
190518: {
190518:   switch(mOpCode) {
190518:     case eTreeOpAppend: {
190518:       nsIContent* node = *(mOne.node);
190518:       nsIContent* parent = *(mTwo.node);
190518:       return Append(node, parent, aBuilder);
190518:     }
190518:     case eTreeOpDetach: {
190518:       nsIContent* node = *(mOne.node);
190518:       Detach(node, aBuilder);
190518:       return NS_OK;
190518:     }
190518:     case eTreeOpAppendChildrenToNewParent: {
190518:       nsCOMPtr<nsIContent> node = *(mOne.node);
190518:       nsIContent* parent = *(mTwo.node);
190518:       return AppendChildrenToNewParent(node, parent, aBuilder);
190518:     }
190518:     case eTreeOpFosterParent: {
190518:       nsIContent* node = *(mOne.node);
190518:       nsIContent* parent = *(mTwo.node);
190518:       nsIContent* table = *(mThree.node);
190518:       return FosterParent(node, parent, table, aBuilder);
190518:     }
190518:     case eTreeOpAppendToDocument: {
190518:       nsIContent* node = *(mOne.node);
190518:       return AppendToDocument(node, aBuilder);
190518:     }
190518:     case eTreeOpAddAttributes: {
190518:       nsIContent* node = *(mOne.node);
190518:       nsHtml5HtmlAttributes* attributes = mTwo.attributes;
190518:       return AddAttributes(node, attributes, aBuilder);
190518:     }
190518:     case eTreeOpCreateElementNetwork:
190518:     case eTreeOpCreateElementNotNetwork: {
190518:       nsIContent** target = mOne.node;
190518:       int32_t ns = mFour.integer;
190518:       nsCOMPtr<nsIAtom> name = Reget(mTwo.atom);
190518:       nsHtml5HtmlAttributes* attributes = mThree.attributes;
190518: 
190518:       *target = CreateElement(ns,
190518:                               name,
190518:                               attributes,
190520:                               mOpCode == eTreeOpCreateElementNetwork ?
190520:                                 dom::FROM_PARSER_NETWORK :
190520:                                 dom::FROM_PARSER_DOCUMENT_WRITE,
190518:                               aBuilder);
190518:       return NS_OK;
190518:     }
190518:     case eTreeOpSetFormElement: {
190518:       nsIContent* node = *(mOne.node);
190518:       nsIContent* parent = *(mTwo.node);
190518:       SetFormElement(node, parent);
190518:       return NS_OK;
190518:     }
190518:     case eTreeOpAppendText: {
190518:       nsIContent* parent = *mOne.node;
190518:       char16_t* buffer = mTwo.unicharPtr;
190518:       uint32_t length = mFour.integer;
190518:       return AppendText(buffer, length, parent, aBuilder);
190518:     }
190518:     case eTreeOpAppendIsindexPrompt: {
190518:       nsIContent* parent = *mOne.node;
190518:       return AppendIsindexPrompt(parent, aBuilder);
190518:     }
190518:     case eTreeOpFosterParentText: {
190518:       nsIContent* stackParent = *mOne.node;
190518:       char16_t* buffer = mTwo.unicharPtr;
190518:       uint32_t length = mFour.integer;
190518:       nsIContent* table = *mThree.node;
190518:       return FosterParentText(stackParent, buffer, length, table, aBuilder);
190322:     }
190333:     case eTreeOpAppendComment: {
190333:       nsIContent* parent = *mOne.node;
190333:       char16_t* buffer = mTwo.unicharPtr;
190333:       int32_t length = mFour.integer;
190518:       return AppendComment(parent, buffer, length, aBuilder);
190322:     }
190333:     case eTreeOpAppendCommentToDocument: {
190333:       char16_t* buffer = mTwo.unicharPtr;
190333:       int32_t length = mFour.integer;
190518:       return AppendCommentToDocument(buffer, length, aBuilder);
190322:     }
190333:     case eTreeOpAppendDoctypeToDocument: {
190333:       nsCOMPtr<nsIAtom> name = Reget(mOne.atom);
190333:       nsHtml5TreeOperationStringPair* pair = mTwo.stringPair;
190333:       nsString publicId;
190333:       nsString systemId;
190333:       pair->Get(publicId, systemId);
190518:       return AppendDoctypeToDocument(name, publicId, systemId, aBuilder);
190322:     }
190333:     case eTreeOpGetDocumentFragmentForTemplate: {
190518:       nsIContent* node = *(mOne.node);
190518:       *mTwo.node = GetDocumentFragmentForTemplate(node);
190518:       return NS_OK;
137419:     }
 80404:     case eTreeOpMarkAsBroken: {
 93652:       aBuilder->MarkAsBroken(NS_ERROR_OUT_OF_MEMORY);
190518:       return NS_OK;
 80404:     }
 34978:     case eTreeOpRunScript: {
 34978:       nsIContent* node = *(mOne.node);
 34979:       nsAHtml5TreeBuilderState* snapshot = mTwo.state;
 34979:       if (snapshot) {
 81160:         aBuilder->InitializeDocWriteParserState(snapshot, mFour.integer);
 34979:       }
 35590:       *aScriptElement = node;
190518:       return NS_OK;
 29805:     }
 35727:     case eTreeOpRunScriptAsyncDefer: {
 35727:       nsIContent* node = *(mOne.node);
 35727:       aBuilder->RunScript(node);
190518:       return NS_OK;
 35727:     }
104074:     case eTreeOpPreventScriptExecution: {
104074:       nsIContent* node = *(mOne.node);
190518:       PreventScriptExecution(node);
190518:       return NS_OK;
104074:     }
 29805:     case eTreeOpDoneAddingChildren: {
 34978:       nsIContent* node = *(mOne.node);
210881:       node->DoneAddingChildren(node->HasParserNotified());
190518:       return NS_OK;
 29805:     }
 29805:     case eTreeOpDoneCreatingElement: {
 34978:       nsIContent* node = *(mOne.node);
190518:       DoneCreatingElement(node);
190518:       return NS_OK;
 29805:     }
 81150:     case eTreeOpSetDocumentCharset: {
 81150:       char* str = mOne.charPtr;
108991:       int32_t charsetSource = mFour.integer;
 81150:       nsDependentCString dependentString(str);
 81150:       aBuilder->SetDocumentCharsetAndSource(dependentString, charsetSource);
190518:       return NS_OK;
 81150:     }
 34979:     case eTreeOpNeedsCharsetSwitchTo: {
 34979:       char* str = mOne.charPtr;
108991:       int32_t charsetSource = mFour.integer;
108991:       int32_t lineNumber = mTwo.integer;
108991:       aBuilder->NeedsCharsetSwitchTo(str, charsetSource, (uint32_t)lineNumber);
190518:       return NS_OK;
 34979:     }
 29805:     case eTreeOpUpdateStyleSheet: {
 34978:       nsIContent* node = *(mOne.node);
 34978:       aBuilder->UpdateStyleSheet(node);
190518:       return NS_OK;
 29805:     }
 29805:     case eTreeOpProcessMeta: {
 34978:       nsIContent* node = *(mOne.node);
190518:       return aBuilder->ProcessMETATag(node);
 29805:     }
 29805:     case eTreeOpProcessOfflineManifest: {
179103:       char16_t* str = mOne.unicharPtr;
 38132:       nsDependentString dependentString(str);
 38132:       aBuilder->ProcessOfflineManifest(dependentString);
190518:       return NS_OK;
 34978:     }
 34978:     case eTreeOpMarkMalformedIfScript: {
 34978:       nsIContent* node = *(mOne.node);
190523:       MarkMalformedIfScript(node);
190518:       return NS_OK;
 29805:     }
 34979:     case eTreeOpStreamEnded: {
 80486:       aBuilder->DidBuildModel(false); // this causes a notifications flush anyway
190518:       return NS_OK;
 34979:     }
 29805:     case eTreeOpStartLayout: {
 35590:       aBuilder->StartLayout(); // this causes a notification flush anyway
190518:       return NS_OK;
 29805:     }
 32917:     case eTreeOpDocumentMode: {
 40913:       aBuilder->SetDocumentMode(mOne.mode);
190518:       return NS_OK;
 32917:     }
 35294:     case eTreeOpSetStyleLineNumber: {
 35294:       nsIContent* node = *(mOne.node);
 35294:       nsCOMPtr<nsIStyleSheetLinkingElement> ssle = do_QueryInterface(node);
 35294:       NS_ASSERTION(ssle, "Node didn't QI to style.");
 81160:       ssle->SetLineNumber(mFour.integer);
190518:       return NS_OK;
 35294:     }
 35606:     case eTreeOpSetScriptLineNumberAndFreeze: {
 35294:       nsIContent* node = *(mOne.node);
 35294:       nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(node);
 35294:       NS_ASSERTION(sele, "Node didn't QI to script.");
 81160:       sele->SetScriptLineNumber(mFour.integer);
 35606:       sele->FreezeUriAsyncDefer();
190518:       return NS_OK;
 35294:     }
 47894:     case eTreeOpSvgLoad: {
 47894:       nsIContent* node = *(mOne.node);
190523:       SvgLoad(node);
190518:       return NS_OK;
 47894:     }
 94004:     case eTreeOpMaybeComplainAboutCharset: {
 94004:       char* msgId = mOne.charPtr;
 94004:       bool error = mTwo.integer;
108991:       int32_t lineNumber = mThree.integer;
108991:       aBuilder->MaybeComplainAboutCharset(msgId, error, (uint32_t)lineNumber);
190518:       return NS_OK;
 94004:     }
 81151:     case eTreeOpAddClass: {
 81151:       nsIContent* node = *(mOne.node);
179103:       char16_t* str = mTwo.unicharPtr;
 81151:       nsDependentString depStr(str);
 81164:       // See viewsource.css for the possible classes
 81152:       nsAutoString klass;
 81152:       node->GetAttr(kNameSpaceID_None, nsGkAtoms::_class, klass);
 81152:       if (!klass.IsEmpty()) {
 81152:         klass.Append(' ');
 81152:         klass.Append(depStr);
 81152:         node->SetAttr(kNameSpaceID_None, nsGkAtoms::_class, klass, true);
 81152:       } else {
 81151:         node->SetAttr(kNameSpaceID_None, nsGkAtoms::_class, depStr, true);
 81152:       }
190518:       return NS_OK;
 81151:     }
 81157:     case eTreeOpAddLineNumberId: {
 81157:       nsIContent* node = *(mOne.node);
108991:       int32_t lineNumber = mFour.integer;
 81157:       nsAutoString val(NS_LITERAL_STRING("line"));
 81157:       val.AppendInt(lineNumber);
 81157:       node->SetAttr(kNameSpaceID_None, nsGkAtoms::id, val, true);
190518:       return NS_OK;
 81157:     }
 81151:     case eTreeOpAddViewSourceHref: {
 81151:       nsIContent* node = *mOne.node;
179103:       char16_t* buffer = mTwo.unicharPtr;
108991:       int32_t length = mFour.integer;
 81151: 
 81151:       nsDependentString relative(buffer, length);
 81151: 
 81151:       nsIDocument* doc = aBuilder->GetDocument();
 81151: 
 81151:       const nsCString& charset = doc->GetDocumentCharacterSet();
 81151:       nsCOMPtr<nsIURI> uri;
190518:       nsresult rv = NS_NewURI(getter_AddRefs(uri),
 81151:                               relative,
 81151:                               charset.get(),
 81151:                               aBuilder->GetViewSourceBaseURI());
185546:       NS_ENSURE_SUCCESS(rv, NS_OK);
 81151: 
 81151:       // Reuse the fix for bug 467852
 81151:       // URLs that execute script (e.g. "javascript:" URLs) should just be
 81151:       // ignored.  There's nothing reasonable we can do with them, and allowing
 81151:       // them to execute in the context of the view-source window presents a
 81151:       // security risk.  Just return the empty string in this case.
 81151:       bool openingExecutesScript = false;
 81151:       rv = NS_URIChainHasFlags(uri,
 81151:                                nsIProtocolHandler::URI_OPENING_EXECUTES_SCRIPT,
 81151:                                &openingExecutesScript);
 81164:       if (NS_FAILED(rv) || openingExecutesScript) {
 81151:         return NS_OK;
 81151:       }
 81151: 
110974:       nsAutoCString viewSourceUrl;
 81151: 
 81151:       // URLs that return data (e.g. "http:" URLs) should be prefixed with
 81151:       // "view-source:".  URLs that don't return data should just be returned
 81151:       // undecorated.
 81151:       bool doesNotReturnData = false;
 81151:       rv = NS_URIChainHasFlags(uri,
 81151:                                nsIProtocolHandler::URI_DOES_NOT_RETURN_DATA,
 81151:                                &doesNotReturnData);
 81151:       NS_ENSURE_SUCCESS(rv, NS_OK);
 81151:       if (!doesNotReturnData) {
 81151:         viewSourceUrl.AssignLiteral("view-source:");
 81151:       }
 81151: 
110974:       nsAutoCString spec;
 81151:       uri->GetSpec(spec);
 81151: 
 81151:       viewSourceUrl.Append(spec);
 81151: 
 81151:       nsAutoString utf16;
 81151:       CopyUTF8toUTF16(viewSourceUrl, utf16);
 81151: 
 81151:       node->SetAttr(kNameSpaceID_None, nsGkAtoms::href, utf16, true);
 81151:       return rv;
 81151:     }
 81152:     case eTreeOpAddError: {
 81152:       nsIContent* node = *(mOne.node);
 81152:       char* msgId = mTwo.charPtr;
 81160:       nsCOMPtr<nsIAtom> atom = Reget(mThree.atom);
 81160:       nsCOMPtr<nsIAtom> otherAtom = Reget(mFour.atom);
 81164:       // See viewsource.css for the possible classes in addition to "error".
 81152:       nsAutoString klass;
 81152:       node->GetAttr(kNameSpaceID_None, nsGkAtoms::_class, klass);
 81152:       if (!klass.IsEmpty()) {
204654:         klass.AppendLiteral(" error");
 81152:         node->SetAttr(kNameSpaceID_None, nsGkAtoms::_class, klass, true);
 81152:       } else {
 81152:         node->SetAttr(kNameSpaceID_None,
 81152:                       nsGkAtoms::_class,
 81152:                       NS_LITERAL_STRING("error"),
 81152:                       true);
 81152:       }
 81152: 
190518:       nsresult rv;
 81152:       nsXPIDLString message;
 81160:       if (otherAtom) {
179103:         const char16_t* params[] = { atom->GetUTF16String(),
 81160:                                       otherAtom->GetUTF16String() };
 81160:         rv = nsContentUtils::FormatLocalizedString(
 91877:           nsContentUtils::eHTMLPARSER_PROPERTIES, msgId, params, message);
205079:         NS_ENSURE_SUCCESS(rv, NS_OK);
 81160:       } else if (atom) {
179103:         const char16_t* params[] = { atom->GetUTF16String() };
 81160:         rv = nsContentUtils::FormatLocalizedString(
 91877:           nsContentUtils::eHTMLPARSER_PROPERTIES, msgId, params, message);
205079:         NS_ENSURE_SUCCESS(rv, NS_OK);
 81160:       } else {
 81152:         rv = nsContentUtils::GetLocalizedString(
 81152:           nsContentUtils::eHTMLPARSER_PROPERTIES, msgId, message);
205079:         NS_ENSURE_SUCCESS(rv, NS_OK);
 81160:       }
 81152: 
 81152:       nsAutoString title;
 81152:       node->GetAttr(kNameSpaceID_None, nsGkAtoms::title, title);
 81152:       if (!title.IsEmpty()) {
 81160:         title.Append('\n');
 81152:         title.Append(message);
 81152:         node->SetAttr(kNameSpaceID_None, nsGkAtoms::title, title, true);
 81152:       } else {
 81152:         node->SetAttr(kNameSpaceID_None, nsGkAtoms::title, message, true);
 81152:       }
 81152:       return rv;
 81152:     }
 29805:     default: {
229863:       MOZ_CRASH("Bogus tree op");
 29805:     }
 29805:   }
190518:   return NS_OK; // keep compiler happy
 29805: }
