 97893: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 97198: /* This Source Code Form is subject to the terms of the Mozilla Public
 97198:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 97198:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 97198: 
 97198: #include "StreamBuffer.h"
136570: #include "prlog.h"
129543: #include <algorithm>
 97198: 
 97198: namespace mozilla {
 97198: 
135334: #ifdef PR_LOGGING
135334: extern PRLogModuleInfo* gMediaStreamGraphLog;
172276: #define LOG(type, msg) PR_LOG(gMediaStreamGraphLog, type, msg)
135334: #else
172276: #define LOG(type, msg)
135334: #endif
135334: 
135334: #ifdef DEBUG
135334: void
135334: StreamBuffer::DumpTrackInfo() const
135334: {
172276:   LOG(PR_LOG_ALWAYS, ("DumpTracks: mTracksKnownTime %lld", mTracksKnownTime));
135334:   for (uint32_t i = 0; i < mTracks.Length(); ++i) {
135334:     Track* track = mTracks[i];
135334:     if (track->IsEnded()) {
172276:       LOG(PR_LOG_ALWAYS, ("Track[%d] %d: ended", i, track->GetID()));
135334:     } else {
172276:       LOG(PR_LOG_ALWAYS, ("Track[%d] %d: %lld", i, track->GetID(),
135334:                           track->GetEndTimeRoundDown()));
135334:     }
135334:   }
135334: }
135334: #endif
135334: 
 97198: StreamTime
 97198: StreamBuffer::GetEnd() const
 97198: {
 97198:   StreamTime t = mTracksKnownTime;
108991:   for (uint32_t i = 0; i < mTracks.Length(); ++i) {
 97198:     Track* track = mTracks[i];
 97198:     if (!track->IsEnded()) {
129543:       t = std::min(t, track->GetEndTimeRoundDown());
 97198:     }
 97198:   }
 97198:   return t;
 97198: }
 97198: 
 97198: StreamBuffer::Track*
 97198: StreamBuffer::FindTrack(TrackID aID)
 97198: {
 97198:   if (aID == TRACK_NONE)
106838:     return nullptr;
108991:   for (uint32_t i = 0; i < mTracks.Length(); ++i) {
 97198:     Track* track = mTracks[i];
 97198:     if (track->GetID() == aID) {
 97198:       return track;
 97198:     }
 97198:   }
106838:   return nullptr;
 97198: }
 97198: 
 97198: void
 97198: StreamBuffer::ForgetUpTo(StreamTime aTime)
 97198: {
 97198:   // Round to nearest 50ms so we don't spend too much time pruning segments.
108787:   const MediaTime roundTo = MillisecondsToMediaTime(50);
 97198:   StreamTime forget = (aTime/roundTo)*roundTo;
 97198:   if (forget <= mForgottenTime) {
 97198:     return;
 97198:   }
 97198:   mForgottenTime = forget;
 97198: 
108991:   for (uint32_t i = 0; i < mTracks.Length(); ++i) {
 97198:     Track* track = mTracks[i];
 97198:     if (track->IsEnded() && track->GetEndTimeRoundDown() <= forget) {
 97198:       mTracks.RemoveElementAt(i);
 97198:       --i;
 97198:       continue;
 97198:     }
129543:     TrackTicks forgetTo = std::min(track->GetEnd() - 1, track->TimeToTicksRoundDown(forget));
 97198:     track->ForgetUpTo(forgetTo);
 97198:   }
 97198: }
 97198: 
 97198: }
