16222: /* vim: set shiftwidth=4 tabstop=8 autoindent cindent expandtab: */
16222: /* ***** BEGIN LICENSE BLOCK *****
16222:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
16222:  *
16222:  * The contents of this file are subject to the Mozilla Public License Version
16222:  * 1.1 (the "License"); you may not use this file except in compliance with
16222:  * the License. You may obtain a copy of the License at
16222:  * http://www.mozilla.org/MPL/
16222:  *
16222:  * Software distributed under the License is distributed on an "AS IS" basis,
16222:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16222:  * for the specific language governing rights and limitations under the
16222:  * License.
16222:  *
16222:  * The Original Code is nsMediaFeatures.
16222:  *
16222:  * The Initial Developer of the Original Code is the Mozilla Foundation.
16222:  * Portions created by the Initial Developer are Copyright (C) 2008
16222:  * the Initial Developer. All Rights Reserved.
16222:  *
16222:  * Contributor(s):
16222:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
16222:  *
16222:  * Alternatively, the contents of this file may be used under the terms of
16222:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16222:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16222:  * in which case the provisions of the GPL or the LGPL are applicable instead
16222:  * of those above. If you wish to allow use of your version of this file only
16222:  * under the terms of either the GPL or the LGPL, and not to allow others to
16222:  * use your version of this file under the terms of the MPL, indicate your
16222:  * decision by deleting the provisions above and replace them with the notice
16222:  * and other provisions required by the GPL or the LGPL. If you do not delete
16222:  * the provisions above, a recipient may use your version of this file under
16222:  * the terms of any one of the MPL, the GPL or the LGPL.
16222:  *
16222:  * ***** END LICENSE BLOCK ***** */
16222: 
16222: /* the features that media queries can test */
16222: 
16222: #include "nsMediaFeatures.h"
16222: #include "nsGkAtoms.h"
16222: #include "nsCSSKeywords.h"
16222: #include "nsStyleConsts.h"
16222: #include "nsPresContext.h"
16222: #include "nsIDeviceContext.h"
16222: #include "nsCSSValue.h"
16228: #include "nsIDocShell.h"
16228: #include "nsLayoutUtils.h"
16222: 
16222: static const PRInt32 kOrientationKeywords[] = {
16222:   eCSSKeyword_portrait,                 NS_STYLE_ORIENTATION_PORTRAIT,
16222:   eCSSKeyword_landscape,                NS_STYLE_ORIENTATION_LANDSCAPE,
16222:   eCSSKeyword_UNKNOWN,                  -1
16222: };
16222: 
16222: static const PRInt32 kScanKeywords[] = {
16222:   eCSSKeyword_progressive,              NS_STYLE_SCAN_PROGRESSIVE,
16222:   eCSSKeyword_interlace,                NS_STYLE_SCAN_INTERLACE,
16222:   eCSSKeyword_UNKNOWN,                  -1
16222: };
16222: 
23165: // A helper for four features below
22340: static nsSize
22340: GetSize(nsPresContext* aPresContext)
22340: {
22340:     nsSize size;
22340:     if (aPresContext->IsRootPaginatedDocument())
22340:         // We want the page size, including unprintable areas and margins.
22340:         size = aPresContext->GetPageSize();
22340:     else
22340:         size = aPresContext->GetVisibleArea().Size();
22340:     return size;
22340: }
22340: 
20261: static nsresult
16222: GetWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
22340:     nsSize size = GetSize(aPresContext);
22340:     float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(size.width);
16222:     aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
22340:     nsSize size = GetSize(aPresContext);
22340:     float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(size.height);
16222:     aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
16222:     return NS_OK;
16222: }
16222: 
31126: inline static nsIDeviceContext*
16228: GetDeviceContextFor(nsPresContext* aPresContext)
16228: {
31126:   // It would be nice to call
31126:   // nsLayoutUtils::GetDeviceContextForScreenInfo here, except for two
31126:   // things:  (1) it can flush, and flushing is bad here, and (2) it
31126:   // doesn't really get us consistency in multi-monitor situations
31126:   // *anyway*.
31126:   return aPresContext->DeviceContext();
16228: }
16228: 
22340: // A helper for three features below.
22340: static nsSize
22340: GetDeviceSize(nsPresContext* aPresContext)
22340: {
22340:     nsSize size;
22340:     if (aPresContext->IsRootPaginatedDocument())
22340:         // We want the page size, including unprintable areas and margins.
22340:         // XXX The spec actually says we want the "page sheet size", but
22340:         // how is that different?
22340:         size = aPresContext->GetPageSize();
22340:     else
22340:         GetDeviceContextFor(aPresContext)->
22340:             GetDeviceSurfaceDimensions(size.width, size.height);
22340:     return size;
22340: }
22340: 
20261: static nsresult
16222: GetDeviceWidth(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
22340:     nsSize size = GetDeviceSize(aPresContext);
22340:     float pixelWidth = aPresContext->AppUnitsToFloatCSSPixels(size.width);
16222:     aResult.SetFloatValue(pixelWidth, eCSSUnit_Pixel);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetDeviceHeight(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
22340:     nsSize size = GetDeviceSize(aPresContext);
22340:     float pixelHeight = aPresContext->AppUnitsToFloatCSSPixels(size.height);
16222:     aResult.SetFloatValue(pixelHeight, eCSSUnit_Pixel);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetOrientation(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
23165:     nsSize size = GetSize(aPresContext);
16222:     PRInt32 orientation;
16222:     if (size.width > size.height) {
16222:         orientation = NS_STYLE_ORIENTATION_LANDSCAPE;
16222:     } else {
16222:         // Per spec, square viewports should be 'portrait'
16222:         orientation = NS_STYLE_ORIENTATION_PORTRAIT;
16222:     }
16222: 
16222:     aResult.SetIntValue(orientation, eCSSUnit_Enumerated);
16222:     return NS_OK;
16222: }
16222: 
22340: // Helper for two features below
20261: static nsresult
22340: MakeArray(const nsSize& aSize, nsCSSValue& aResult)
16222: {
16222:     nsRefPtr<nsCSSValue::Array> a = nsCSSValue::Array::Create(2);
16222:     NS_ENSURE_TRUE(a, NS_ERROR_OUT_OF_MEMORY);
16222: 
22340:     a->Item(0).SetIntValue(aSize.width, eCSSUnit_Integer);
22340:     a->Item(1).SetIntValue(aSize.height, eCSSUnit_Integer);
16222: 
16222:     aResult.SetArrayValue(a, eCSSUnit_Array);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
22340: GetAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
22340: {
22340:     return MakeArray(GetSize(aPresContext), aResult);
22340: }
22340: 
22340: static nsresult
16222: GetDeviceAspectRatio(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
22340:     return MakeArray(GetDeviceSize(aPresContext), aResult);
16222: }
16222: 
16222: 
20261: static nsresult
16222: GetColor(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
16222:     // FIXME:  This implementation is bogus.  nsThebesDeviceContext
16222:     // doesn't provide reliable information (should be fixed in bug
16222:     // 424386).
16222:     // FIXME: On a monochrome device, return 0!
16228:     nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
16222:     PRUint32 depth;
16222:     dx->GetDepth(depth);
16222:     // The spec says to use bits *per color component*, so divide by 3,
16222:     // and round down, since the spec says to use the smallest when the
16222:     // color components differ.
16222:     depth /= 3;
16222:     aResult.SetIntValue(PRInt32(depth), eCSSUnit_Integer);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetColorIndex(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
16222:     // We should return zero if the device does not use a color lookup
16222:     // table.  Stuart says that our handling of displays with 8-bit
16222:     // color is bad enough that we never change the lookup table to
16222:     // match what we're trying to display, so perhaps we should always
16222:     // return zero.  Given that there isn't any better information
16222:     // exposed, we don't have much other choice.
16222:     aResult.SetIntValue(0, eCSSUnit_Integer);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetMonochrome(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
16222:     // For color devices we should return 0.
16222:     // FIXME: On a monochrome device, return the actual color depth, not
16222:     // 0!
16222:     aResult.SetIntValue(0, eCSSUnit_Integer);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetResolution(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
16222:     // Resolution values are in device pixels, not CSS pixels.
16228:     nsIDeviceContext *dx = GetDeviceContextFor(aPresContext);
16222:     float dpi = float(dx->AppUnitsPerInch()) / float(dx->AppUnitsPerDevPixel());
16222:     aResult.SetFloatValue(dpi, eCSSUnit_Inch);
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetScan(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
16222:     // Since Gecko doesn't support the 'tv' media type, the 'scan'
16222:     // feature is never present.
16222:     aResult.Reset();
16222:     return NS_OK;
16222: }
16222: 
20261: static nsresult
16222: GetGrid(nsPresContext* aPresContext, nsCSSValue& aResult)
16222: {
16222:     // Gecko doesn't support grid devices (e.g., ttys), so the 'grid'
16222:     // feature is always 0.
16222:     aResult.SetIntValue(0, eCSSUnit_Integer);
16222:     return NS_OK;
16222: }
16222: 
16226: /*
16226:  * Adding new media features requires (1) adding the new feature to this
16226:  * array, with appropriate entries (and potentially any new code needed
16226:  * to support new types in these entries and (2) ensuring that either
16226:  * nsPresContext::MediaFeatureValuesChanged or
16226:  * nsPresContext::PostMediaFeatureValuesChangedEvent is called when the
16226:  * value that would be returned by the entry's mGetter changes.
16226:  */
16226: 
16222: /* static */ const nsMediaFeature
16222: nsMediaFeatures::features[] = {
16222:     {
16222:         &nsGkAtoms::width,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eLength,
16222:         nsnull,
16222:         GetWidth
16222:     },
16222:     {
16222:         &nsGkAtoms::height,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eLength,
16222:         nsnull,
16222:         GetHeight
16222:     },
16222:     {
16222:         &nsGkAtoms::deviceWidth,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eLength,
16222:         nsnull,
16222:         GetDeviceWidth
16222:     },
16222:     {
16222:         &nsGkAtoms::deviceHeight,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eLength,
16222:         nsnull,
16222:         GetDeviceHeight
16222:     },
16222:     {
16222:         &nsGkAtoms::orientation,
16222:         nsMediaFeature::eMinMaxNotAllowed,
16222:         nsMediaFeature::eEnumerated,
16222:         kOrientationKeywords,
16222:         GetOrientation
16222:     },
16222:     {
16222:         &nsGkAtoms::aspectRatio,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eIntRatio,
16222:         nsnull,
16222:         GetAspectRatio
16222:     },
16222:     {
16222:         &nsGkAtoms::deviceAspectRatio,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eIntRatio,
16222:         nsnull,
16222:         GetDeviceAspectRatio
16222:     },
16222:     {
16222:         &nsGkAtoms::color,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eInteger,
16222:         nsnull,
16222:         GetColor
16222:     },
16222:     {
16222:         &nsGkAtoms::colorIndex,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eInteger,
16222:         nsnull,
16222:         GetColorIndex
16222:     },
16222:     {
16222:         &nsGkAtoms::monochrome,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eInteger,
16222:         nsnull,
16222:         GetMonochrome
16222:     },
16222:     {
16222:         &nsGkAtoms::resolution,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eResolution,
16222:         nsnull,
16222:         GetResolution
16222:     },
16222:     {
16222:         &nsGkAtoms::scan,
16222:         nsMediaFeature::eMinMaxNotAllowed,
16222:         nsMediaFeature::eEnumerated,
16222:         kScanKeywords,
16222:         GetScan
16222:     },
16222:     {
16222:         &nsGkAtoms::grid,
16222:         nsMediaFeature::eMinMaxNotAllowed,
18890:         nsMediaFeature::eBoolInteger,
16222:         nsnull,
16222:         GetGrid
16222:     },
16222:     // Null-mName terminator:
16222:     {
16222:         nsnull,
16222:         nsMediaFeature::eMinMaxAllowed,
16222:         nsMediaFeature::eInteger,
16222:         nsnull,
16222:         nsnull
16222:     },
16222: };
