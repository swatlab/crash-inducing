43426: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43426: /* ***** BEGIN LICENSE BLOCK *****
43426:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43426:  *
43426:  * The contents of this file are subject to the Mozilla Public License Version
43426:  * 1.1 (the "License"); you may not use this file except in compliance with
43426:  * the License. You may obtain a copy of the License at
43426:  * http://www.mozilla.org/MPL/
43426:  *
43426:  * Software distributed under the License is distributed on an "AS IS" basis,
43426:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43426:  * for the specific language governing rights and limitations under the
43426:  * License.
43426:  *
43426:  * The Original Code is mozilla.org code.
43426:  *
43426:  * The Initial Developer of the Original Code is
43426:  *   Mozilla Corporation.
43426:  * Portions created by the Initial Developer are Copyright (C) 2010
43426:  * the Initial Developer. All Rights Reserved.
43426:  *
43426:  * Contributor(s):
43426:  *   Vladimir Vukicevic <vladimir@pobox.com>
43426:  *   Mark Steele <mwsteele@gmail.com>
43426:  *   Bas Schouten <bschouten@mozilla.com>
43426:  *   Frederic Plourde <frederic.plourde@collabora.co.uk>
43426:  *
43426:  * Alternatively, the contents of this file may be used under the terms of
43426:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43426:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43426:  * in which case the provisions of the GPL or the LGPL are applicable instead
43426:  * of those above. If you wish to allow use of your version of this file only
43426:  * under the terms of either the GPL or the LGPL, and not to allow others to
43426:  * use your version of this file under the terms of the MPL, indicate your
43426:  * decision by deleting the provisions above and replace them with the notice
43426:  * and other provisions required by the GPL or the LGPL. If you do not delete
43426:  * the provisions above, a recipient may use your version of this file under
43426:  * the terms of any one of the MPL, the GPL or the LGPL.
43426:  *
43426:  * ***** END LICENSE BLOCK ***** */
43426: 
77137: #if defined(XP_UNIX)
43426: 
43426: #ifdef MOZ_WIDGET_GTK2
43426: #include <gdk/gdkx.h>
43426: // we're using default display for now
43426: #define GET_NATIVE_WINDOW(aWidget) (EGLNativeWindowType)GDK_WINDOW_XID((GdkWindow *) aWidget->GetNativeData(NS_NATIVE_WINDOW))
43426: #elif defined(MOZ_WIDGET_QT)
77137: #include <QtOpenGL/QGLContext>
44172: #define GLdouble_defined 1
43426: // we're using default display for now
77137: #define GET_NATIVE_WINDOW(aWidget) (EGLNativeWindowType)static_cast<QWidget*>(aWidget->GetNativeData(NS_NATIVE_SHELLWIDGET))->winId()
43426: #endif
43426: 
77137: #if defined(MOZ_X11)
43426: #include <X11/Xlib.h>
43426: #include <X11/Xutil.h>
47908: #include "mozilla/X11Util.h"
44173: #include "gfxXlibSurface.h"
77137: #endif
77137: 
77137: #if defined(ANDROID)
77137: /* from widget */
77137: #include "AndroidBridge.h"
77137: #define EGL_LIB "/system/lib/libEGL.so"
77137: #define GLES2_LIB "/system/lib/libGLESv2.so"
77137: #else
43426: #define EGL_LIB "/usr/lib/libEGL.so"
43426: #define GLES2_LIB "/usr/lib/libGLESv2.so"
77137: #endif
43426: 
43426: typedef void *EGLNativeDisplayType;
43426: typedef void *EGLNativePixmapType;
43426: typedef void *EGLNativeWindowType;
43426: 
49076: #elif defined(XP_WIN)
49076: 
71640: #include "mozilla/Preferences.h"
58583: #include "nsILocalFile.h"
49078: 
49076: #ifndef WIN32_LEAN_AND_MEAN
49076: #define WIN32_LEAN_AND_MEAN 1
49076: #endif
49076: 
49076: #include <windows.h>
49076: 
49076: typedef HDC EGLNativeDisplayType;
49076: typedef HBITMAP EGLNativePixmapType;
49076: typedef HWND EGLNativeWindowType;
49076: 
49076: #define GET_NATIVE_WINDOW(aWidget) ((EGLNativeWindowType)aWidget->GetNativeData(NS_NATIVE_WINDOW))
49076: 
49076: #define EGL_LIB "libEGL.dll"
49076: #define GLES2_LIB "libGLESv2.dll"
49076: 
49076: // a little helper
49076: class AutoDestroyHWND {
49076: public:
49076:     AutoDestroyHWND(HWND aWnd = NULL)
49076:         : mWnd(aWnd)
49076:     {
49076:     }
49076: 
49076:     ~AutoDestroyHWND() {
49076:         if (mWnd) {
49076:             ::DestroyWindow(mWnd);
49076:         }
49076:     }
49076: 
49076:     operator HWND() {
49076:         return mWnd;
49076:     }
49076: 
49076:     HWND forget() {
49076:         HWND w = mWnd;
49076:         mWnd = NULL;
49076:         return w;
49076:     }
49076: 
49076:     HWND operator=(HWND aWnd) {
49076:         if (mWnd && mWnd != aWnd) {
49076:             ::DestroyWindow(mWnd);
49076:         }
49076:         mWnd = aWnd;
49076:         return mWnd;
49076:     }
49076: 
49076:     HWND mWnd;
49076: };
49076: 
43426: #else
43426: 
43426: #error "Platform not recognized"
43426: 
43426: #endif
43426: 
60438: #include "gfxUtils.h"
77638: #include "gfxFailure.h"
44182: #include "gfxASurface.h"
53687: #include "gfxImageSurface.h"
46978: #include "gfxPlatform.h"
43426: #include "GLContextProvider.h"
43426: #include "nsDebug.h"
58301: #include "nsThreadUtils.h"
60068: #include "EGLUtils.h"
43426: 
43426: #include "nsIWidget.h"
43426: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
60438: #ifdef MOZ_PLATFORM_MAEMO
60438: static bool gUseBackingSurface = true;
60438: #else
58301: static bool gUseBackingSurface = false;
60438: #endif
58301: 
43426: namespace mozilla {
43426: namespace gl {
43426: 
43426: typedef int EGLint;
43426: typedef unsigned int EGLBoolean;
43426: typedef unsigned int EGLenum;
43426: typedef void *EGLConfig;
43426: typedef void *EGLContext;
43426: typedef void *EGLDisplay;
43426: typedef void *EGLSurface;
43426: typedef void *EGLClientBuffer;
43426: typedef void *EGLCastToRelevantPtr;
44173: typedef void *EGLImageKHR;
44173: typedef void *GLeglImageOES;
43426: 
43426: #define EGL_DEFAULT_DISPLAY  ((EGLNativeDisplayType)0)
43426: #define EGL_NO_CONTEXT       ((EGLContext)0)
43426: #define EGL_NO_DISPLAY       ((EGLDisplay)0)
43426: #define EGL_NO_SURFACE       ((EGLSurface)0)
43426: 
47908: #define EGL_DISPLAY()        sEGLLibrary.Display()
47908: 
60090: #define ADD_ATTR_2(_array, _k, _v) do {         \
60090:     (_array).AppendElement(_k);                 \
60090:     (_array).AppendElement(_v);                 \
60090: } while (0)
60090: 
60090: #define ADD_ATTR_1(_array, _k) do {             \
60090:     (_array).AppendElement(_k);                 \
60090: } while (0)
60090: 
59165: EGLSurface
59165: CreateSurfaceForWindow(nsIWidget *aWidget, EGLConfig config);
59165: EGLConfig
59165: CreateConfig();
60438: #ifdef MOZ_X11
74436: 
74436: #ifdef MOZ_EGL_XRENDER_COMPOSITE
74436: static EGLSurface
74436: CreateBasicEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig);
74436: #endif
74436: 
60438: static EGLConfig
71551: CreateEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig = nsnull, EGLenum aDepth = 0);
60438: #endif
59165: 
47908: static int
47908: next_power_of_two(int v)
47908: {
47908:     v--;
47908:     v |= v >> 1;
47908:     v |= v >> 2;
47908:     v |= v >> 4;
47908:     v |= v >> 8;
47908:     v |= v >> 16;
47908:     v++;
47908: 
47908:     return v;
47908: }
47908: 
47908: static bool
47908: is_power_of_two(int v)
47908: {
47908:     NS_ASSERTION(v >= 0, "bad value");
47908: 
47908:     if (v == 0)
47908:         return true;
47908: 
47908:     return (v & (v-1)) == 0;
47908: }
47908: 
43426: static class EGLLibrary
43426: {
43426: public:
47908:     EGLLibrary() 
54532:         : mInitialized(PR_FALSE),
54532:           mEGLLibrary(nsnull)
47908:     {
60089:         mIsANGLE = PR_FALSE;
47908:         mHave_EGL_KHR_image_base = PR_FALSE;
47908:         mHave_EGL_KHR_image_pixmap = PR_FALSE;
47908:         mHave_EGL_KHR_gl_texture_2D_image = PR_FALSE;
58301:         mHave_EGL_KHR_lock_surface = PR_FALSE;
74513:         mHave_EGL_ANGLE_surface_d3d_texture_2d_share_handle = PR_FALSE;
47908:     }
43426: 
49076:     typedef EGLDisplay (GLAPIENTRY * pfnGetDisplay)(void *display_id);
43426:     pfnGetDisplay fGetDisplay;
49076:     typedef EGLContext (GLAPIENTRY * pfnGetCurrentContext)(void);
43426:     pfnGetCurrentContext fGetCurrentContext;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnMakeCurrent)(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
43426:     pfnMakeCurrent fMakeCurrent;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnDestroyContext)(EGLDisplay dpy, EGLContext ctx);
43426:     pfnDestroyContext fDestroyContext;
49076:     typedef EGLContext (GLAPIENTRY * pfnCreateContext)(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list);
43426:     pfnCreateContext fCreateContext;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnDestroySurface)(EGLDisplay dpy, EGLSurface surface);
43426:     pfnDestroySurface fDestroySurface;
49076:     typedef EGLSurface (GLAPIENTRY * pfnCreateWindowSurface)(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list);
43426:     pfnCreateWindowSurface fCreateWindowSurface;
49076:     typedef EGLSurface (GLAPIENTRY * pfnCreatePbufferSurface)(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list);
43426:     pfnCreatePbufferSurface fCreatePbufferSurface;
49076:     typedef EGLSurface (GLAPIENTRY * pfnCreatePixmapSurface)(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list);
43426:     pfnCreatePixmapSurface fCreatePixmapSurface;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnBindAPI)(EGLenum api);
43426:     pfnBindAPI fBindAPI;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnInitialize)(EGLDisplay dpy, EGLint *major, EGLint *minor);
43426:     pfnInitialize fInitialize;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnChooseConfig)(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
43426:     pfnChooseConfig fChooseConfig;
49076:     typedef EGLint (GLAPIENTRY * pfnGetError)(void);
43426:     pfnGetError fGetError;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnGetConfigAttrib)(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value);
43426:     pfnGetConfigAttrib fGetConfigAttrib;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnGetConfigs)(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config);
43426:     pfnGetConfigs fGetConfigs;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnWaitNative)(EGLint engine);
43426:     pfnWaitNative fWaitNative;
49076:     typedef EGLCastToRelevantPtr (GLAPIENTRY * pfnGetProcAddress)(const char *procname);
43426:     pfnGetProcAddress fGetProcAddress;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnSwapBuffers)(EGLDisplay dpy, EGLSurface surface);
46261:     pfnSwapBuffers fSwapBuffers;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnCopyBuffers)(EGLDisplay dpy, EGLSurface surface,
46261:                                                      EGLNativePixmapType target);
46261:     pfnCopyBuffers fCopyBuffers;
49076:     typedef const GLubyte* (GLAPIENTRY * pfnQueryString)(EGLDisplay, EGLint name);
44173:     pfnQueryString fQueryString;
53687:     typedef EGLBoolean (GLAPIENTRY * pfnQueryContext)(EGLDisplay dpy, EGLContext ctx,
53687:                                                       EGLint attribute, EGLint *value);
53687:     pfnQueryContext fQueryContext;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnBindTexImage)(EGLDisplay, EGLSurface surface, EGLint buffer);
44173:     pfnBindTexImage fBindTexImage;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnReleaseTexImage)(EGLDisplay, EGLSurface surface, EGLint buffer);
44173:     pfnReleaseTexImage fReleaseTexImage;
49076:     typedef EGLImageKHR (GLAPIENTRY * pfnCreateImageKHR)(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list);
44173:     pfnCreateImageKHR fCreateImageKHR;
49076:     typedef EGLBoolean (GLAPIENTRY * pfnDestroyImageKHR)(EGLDisplay dpy, EGLImageKHR image);
44173:     pfnDestroyImageKHR fDestroyImageKHR;
53687: 
58301:     // New extension which allow us to lock texture and get raw image pointer
58301:     typedef EGLBoolean (GLAPIENTRY * pfnLockSurfaceKHR)(EGLDisplay dpy, EGLSurface surface, const EGLint *attrib_list);
58301:     pfnLockSurfaceKHR fLockSurfaceKHR;
58301:     typedef EGLBoolean (GLAPIENTRY * pfnUnlockSurfaceKHR)(EGLDisplay dpy, EGLSurface surface);
58301:     pfnUnlockSurfaceKHR fUnlockSurfaceKHR;
58301:     typedef EGLBoolean (GLAPIENTRY * pfnQuerySurface)(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value);
58301:     pfnQuerySurface fQuerySurface;
58301: 
60089:     typedef EGLBoolean (GLAPIENTRY * pfnQuerySurfacePointerANGLE)(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void **value);
60089:     pfnQuerySurfacePointerANGLE fQuerySurfacePointerANGLE;
60089: 
44173:     // This is EGL specific GL ext symbol "glEGLImageTargetTexture2DOES"
44173:     // Lets keep it here for now.
49076:     typedef void (GLAPIENTRY * pfnImageTargetTexture2DOES)(GLenum target, GLeglImageOES image);
44173:     pfnImageTargetTexture2DOES fImageTargetTexture2DOES;
43426: 
43426:     PRBool EnsureInitialized()
43426:     {
43426:         if (mInitialized) {
43426:             return PR_TRUE;
43426:         }
43426: 
63285:         mozilla::ScopedGfxFeatureReporter reporter("EGL");
63285: 
49078: #ifdef XP_WIN
58583:         // Allow for explicitly specifying the location of libEGL.dll and
58583:         // libGLESv2.dll.
49078:         do {
58583:             nsCOMPtr<nsILocalFile> eglFile, glesv2File;
71640:             nsresult rv = Preferences::GetComplex("gfx.angle.egl.path",
49078:                                                   NS_GET_IID(nsILocalFile),
58583:                                                   getter_AddRefs(eglFile));
58583:             if (NS_FAILED(rv) || !eglFile)
49078:                 break;
49078: 
49078:             nsCAutoString s;
49078: 
49078:             // note that we have to load the libs in this order, because libEGL.dll
58583:             // depends on libGLESv2.dll, but is not/may not be in our search path.
49078:             nsCOMPtr<nsIFile> f;
58583:             eglFile->Clone(getter_AddRefs(f));
49078:             glesv2File = do_QueryInterface(f);
49078:             if (!glesv2File)
49078:                 break;
49078: 
49078:             glesv2File->Append(NS_LITERAL_STRING("libGLESv2.dll"));
49078: 
49078:             PRLibrary *glesv2lib = nsnull; // this will be leaked on purpose
49078:             glesv2File->Load(&glesv2lib);
49078:             if (!glesv2lib)
49078:                 break;
49078: 
58583:             eglFile->Append(NS_LITERAL_STRING("libEGL.dll"));
58583:             eglFile->Load(&mEGLLibrary);
49078:         } while (false);
49078: #endif
49078: 
43426:         if (!mEGLLibrary) {
43426:             mEGLLibrary = PR_LoadLibrary(EGL_LIB);
58583:         }
58583: 
43426:         if (!mEGLLibrary) {
43426:             NS_WARNING("Couldn't load EGL LIB.");
43426:             return PR_FALSE;
43426:         }
58583: 
43426: #define SYMBOL(name) \
43426:     { (PRFuncPtr*) &f##name, { "egl" #name, NULL } }
43426: 
43426:         LibrarySymbolLoader::SymLoadStruct earlySymbols[] = {
43426:             SYMBOL(GetDisplay),
43426:             SYMBOL(GetCurrentContext),
43426:             SYMBOL(MakeCurrent),
43426:             SYMBOL(DestroyContext),
43426:             SYMBOL(CreateContext),
43426:             SYMBOL(DestroySurface),
43426:             SYMBOL(CreateWindowSurface),
43426:             SYMBOL(CreatePbufferSurface),
43426:             SYMBOL(CreatePixmapSurface),
43426:             SYMBOL(BindAPI),
43426:             SYMBOL(Initialize),
43426:             SYMBOL(ChooseConfig),
43426:             SYMBOL(GetError),
43426:             SYMBOL(GetConfigs),
43426:             SYMBOL(GetConfigAttrib),
43426:             SYMBOL(WaitNative),
43426:             SYMBOL(GetProcAddress),
46261:             SYMBOL(SwapBuffers),
46261:             SYMBOL(CopyBuffers),
44173:             SYMBOL(QueryString),
53687:             SYMBOL(QueryContext),
44173:             SYMBOL(BindTexImage),
44173:             SYMBOL(ReleaseTexImage),
58301:             SYMBOL(QuerySurface),
43426:             { NULL, { NULL } }
43426:         };
43426: 
43426:         if (!LibrarySymbolLoader::LoadSymbols(mEGLLibrary, &earlySymbols[0])) {
43426:             NS_WARNING("Couldn't find required entry points in EGL library (early init)");
43426:             return PR_FALSE;
43426:         }
43426: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:         mEGLDisplay = fGetDisplay((EGLNativeDisplayType) gdk_x11_get_default_xdisplay());
74436: #else
47908:         mEGLDisplay = fGetDisplay(EGL_DEFAULT_DISPLAY);
74436: #endif
47908:         if (!fInitialize(mEGLDisplay, NULL, NULL))
47908:             return PR_FALSE;
47908: 
70456:         const char *vendor = (const char*) fQueryString(mEGLDisplay, LOCAL_EGL_VENDOR);
70456:         if (vendor && strstr(vendor, "TransGaming") != 0) {
60089:             mIsANGLE = PR_TRUE;
60089:         }
60089:         
47908:         const char *extensions = (const char*) fQueryString(mEGLDisplay, LOCAL_EGL_EXTENSIONS);
49076:         if (!extensions)
49076:             extensions = "";
49076: 
49076:         printf_stderr("Extensions: %s 0x%02x\n", extensions, extensions[0]);
49076:         printf_stderr("Extensions length: %d\n", strlen(extensions));
47908: 
47908:         // note the extra space -- this ugliness tries to match
47908:         // EGL_KHR_image in the middle of the string, or right at the
47908:         // end.  It's a prefix for other extensions, so we have to do
47908:         // this...
58607:         PRBool hasKHRImage = PR_FALSE;
47908:         if (strstr(extensions, "EGL_KHR_image ") ||
47908:             (strlen(extensions) >= strlen("EGL_KHR_image") &&
47908:              strcmp(extensions+(strlen(extensions)-strlen("EGL_KHR_image")), "EGL_KHR_image")))
47908:         {
47908:             hasKHRImage = PR_TRUE;
47908:         }
47908: 
47908:         if (strstr(extensions, "EGL_KHR_image_base")) {
47908:             mHave_EGL_KHR_image_base = PR_TRUE;
47908:         }
47908:             
47908:         if (strstr(extensions, "EGL_KHR_image_pixmap")) {
47908:             mHave_EGL_KHR_image_pixmap = PR_TRUE;
47908:             
47908:         }
47908: 
47908:         if (strstr(extensions, "EGL_KHR_gl_texture_2D_image")) {
47908:             mHave_EGL_KHR_gl_texture_2D_image = PR_TRUE;
47908:         }
47908: 
58301:         if (strstr(extensions, "EGL_KHR_lock_surface")) {
58301:             mHave_EGL_KHR_lock_surface = PR_TRUE;
58301:         }
58301: 
47908:         if (hasKHRImage) {
44173:             LibrarySymbolLoader::SymLoadStruct khrSymbols[] = {
44173:                 { (PRFuncPtr*) &fCreateImageKHR, { "eglCreateImageKHR", NULL } },
44173:                 { (PRFuncPtr*) &fDestroyImageKHR, { "eglDestroyImageKHR", NULL } },
44173:                 { (PRFuncPtr*) &fImageTargetTexture2DOES, { "glEGLImageTargetTexture2DOES", NULL } },
44173:                 { NULL, { NULL } }
44173:             };
44173: 
47908:             LibrarySymbolLoader::LoadSymbols(mEGLLibrary, &khrSymbols[0],
47908:                                              (LibrarySymbolLoader::PlatformLookupFunction)fGetProcAddress);
60438:         }
47908: 
58301:         if (mHave_EGL_KHR_lock_surface) {
58301:             LibrarySymbolLoader::SymLoadStruct lockSymbols[] = {
58301:                 { (PRFuncPtr*) &fLockSurfaceKHR, { "eglLockSurfaceKHR", NULL } },
58301:                 { (PRFuncPtr*) &fUnlockSurfaceKHR, { "eglUnlockSurfaceKHR", NULL } },
58301:                 { NULL, { NULL } }
58301:             };
58301: 
58301:             LibrarySymbolLoader::LoadSymbols(mEGLLibrary, &lockSymbols[0],
58301:                                              (LibrarySymbolLoader::PlatformLookupFunction)fGetProcAddress);
58301:             if (!fLockSurfaceKHR) {
58301:                 mHave_EGL_KHR_lock_surface = PR_FALSE;
58301:             }
58301:         }
58301: 
47908:         if (!fCreateImageKHR) {
47908:             mHave_EGL_KHR_image_base = PR_FALSE;
47908:             mHave_EGL_KHR_image_pixmap = PR_FALSE;
47908:             mHave_EGL_KHR_gl_texture_2D_image = PR_FALSE;
47908:         }
47908: 
47908:         if (!fImageTargetTexture2DOES) {
47908:             mHave_EGL_KHR_gl_texture_2D_image = PR_FALSE;
44173:         }
44173: 
74513:         if (strstr(extensions, "EGL_ANGLE_surface_d3d_texture_2d_share_handle")) {
60089:             LibrarySymbolLoader::SymLoadStruct d3dSymbols[] = {
60089:                 { (PRFuncPtr*) &fQuerySurfacePointerANGLE, { "eglQuerySurfacePointerANGLE", NULL } },
60089:                 { NULL, { NULL } }
60089:             };
60089: 
60089:             LibrarySymbolLoader::LoadSymbols(mEGLLibrary, &d3dSymbols[0],
60089:                                              (LibrarySymbolLoader::PlatformLookupFunction)fGetProcAddress);
60089:             if (fQuerySurfacePointerANGLE) {
74513:                 mHave_EGL_ANGLE_surface_d3d_texture_2d_share_handle = PR_TRUE;
60089:             }
60089:         }
60089: 
43426:         mInitialized = PR_TRUE;
63285:         reporter.SetSuccessful();
43426:         return PR_TRUE;
43426:     }
43426: 
47908:     EGLDisplay Display() {
47908:         return mEGLDisplay;
47908:     }
47908: 
60089:     PRBool IsANGLE() {
60089:         return mIsANGLE;
60089:     }
60089: 
47908:     PRBool HasKHRImageBase() {
47908:         return mHave_EGL_KHR_image_base;
47908:     }
47908: 
47908:     PRBool HasKHRImagePixmap() {
60438:         return mHave_EGL_KHR_image_pixmap;
47908:     }
47908: 
47908:     PRBool HasKHRImageTexture2D() {
47908:         return mHave_EGL_KHR_gl_texture_2D_image;
47908:     }
47908: 
58301:     PRBool HasKHRLockSurface() {
58301:         return mHave_EGL_KHR_lock_surface;
58301:     }
58301: 
74513:     PRBool HasANGLESurfaceD3DTexture2DShareHandle() {
74513:         return mHave_EGL_ANGLE_surface_d3d_texture_2d_share_handle;
60089:     }
60089: 
47908:     void
47908:     DumpEGLConfig(EGLConfig cfg)
47908:     {
47908:         int attrval;
47908:         int err;
47908: 
47908: #define ATTR(_x) do {                                                   \
47908:             fGetConfigAttrib(mEGLDisplay, cfg, LOCAL_EGL_##_x, &attrval);  \
47908:             if ((err = fGetError()) != 0x3000) {                        \
53687:                 printf_stderr("  %s: ERROR (0x%04x)\n", #_x, err);        \
47908:             } else {                                                    \
53687:                 printf_stderr("  %s: %d (0x%04x)\n", #_x, attrval, attrval); \
47908:             }                                                           \
47908:         } while(0)
47908: 
53687:         printf_stderr("EGL Config: %d [%p]\n", (int)(intptr_t)cfg, cfg);
47908: 
47908:         ATTR(BUFFER_SIZE);
47908:         ATTR(ALPHA_SIZE);
47908:         ATTR(BLUE_SIZE);
47908:         ATTR(GREEN_SIZE);
47908:         ATTR(RED_SIZE);
47908:         ATTR(DEPTH_SIZE);
47908:         ATTR(STENCIL_SIZE);
47908:         ATTR(CONFIG_CAVEAT);
47908:         ATTR(CONFIG_ID);
47908:         ATTR(LEVEL);
47908:         ATTR(MAX_PBUFFER_HEIGHT);
47908:         ATTR(MAX_PBUFFER_PIXELS);
47908:         ATTR(MAX_PBUFFER_WIDTH);
47908:         ATTR(NATIVE_RENDERABLE);
47908:         ATTR(NATIVE_VISUAL_ID);
47908:         ATTR(NATIVE_VISUAL_TYPE);
47908:         ATTR(PRESERVED_RESOURCES);
47908:         ATTR(SAMPLES);
47908:         ATTR(SAMPLE_BUFFERS);
47908:         ATTR(SURFACE_TYPE);
47908:         ATTR(TRANSPARENT_TYPE);
47908:         ATTR(TRANSPARENT_RED_VALUE);
47908:         ATTR(TRANSPARENT_GREEN_VALUE);
47908:         ATTR(TRANSPARENT_BLUE_VALUE);
47908:         ATTR(BIND_TO_TEXTURE_RGB);
47908:         ATTR(BIND_TO_TEXTURE_RGBA);
47908:         ATTR(MIN_SWAP_INTERVAL);
47908:         ATTR(MAX_SWAP_INTERVAL);
47908:         ATTR(LUMINANCE_SIZE);
47908:         ATTR(ALPHA_MASK_SIZE);
47908:         ATTR(COLOR_BUFFER_TYPE);
47908:         ATTR(RENDERABLE_TYPE);
47908:         ATTR(CONFORMANT);
47908: 
47908: #undef ATTR
47908:     }
47908: 
61663:     void DumpEGLConfigs() {
61663:         int nc = 0;
61663:         fGetConfigs(mEGLDisplay, NULL, 0, &nc);
61663:         EGLConfig *ec = new EGLConfig[nc];
61663:         fGetConfigs(mEGLDisplay, ec, nc, &nc);
61663: 
61663:         for (int i = 0; i < nc; ++i) {
61663:             printf_stderr ("========= EGL Config %d ========\n");
61663:             DumpEGLConfig(ec[i]);
61663:         }
61663: 
61663:         delete [] ec;
61663:     }
61663: 
43426: private:
43426:     PRBool mInitialized;
43426:     PRLibrary *mEGLLibrary;
47908:     EGLDisplay mEGLDisplay;
47908: 
60089:     PRPackedBool mIsANGLE;
60089: 
47908:     PRPackedBool mHave_EGL_KHR_image_base;
47908:     PRPackedBool mHave_EGL_KHR_image_pixmap;
47908:     PRPackedBool mHave_EGL_KHR_gl_texture_2D_image;
58301:     PRPackedBool mHave_EGL_KHR_lock_surface;
74513:     PRPackedBool mHave_EGL_ANGLE_surface_d3d_texture_2d_share_handle;
43426: } sEGLLibrary;
43426: 
43426: class GLContextEGL : public GLContext
43426: {
46978:     friend class TextureImageEGL;
46978: 
71551:     static already_AddRefed<GLContextEGL>
71551:     CreateGLContext(const ContextFormat& format,
71551:                     EGLSurface surface,
71551:                     EGLConfig config,
71551:                     GLContextEGL *shareContext,
71551:                     PRBool aIsOffscreen = PR_FALSE)
71551:     {
71551:         EGLContext context;
71551:         static EGLint cxattribs[] = {
71551:             LOCAL_EGL_CONTEXT_CLIENT_VERSION, 2,
71551:             LOCAL_EGL_NONE
71551:         };
71551: 
71551:         context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
71551:                                              config,
71551:                                              shareContext ? shareContext->mContext : EGL_NO_CONTEXT,
71551:                                              cxattribs);
71551:         if (!context) {
71551:             if (shareContext) {
71551:                 shareContext = nsnull;
71551:                 context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
71551:                                                      config,
71551:                                                      EGL_NO_CONTEXT,
71551:                                                      cxattribs);
71551:                 if (!context) {
71551:                     NS_WARNING("Failed to create EGLContext!");
71551:                     return nsnull;
71551:                 }
71551:             }
71551:         }
71551: 
71551:         nsRefPtr<GLContextEGL> glContext =
71551:             new GLContextEGL(format, shareContext, config,
71551:                              surface, context, aIsOffscreen);
71551: 
71551:         if (!glContext->Init())
71551:             return nsnull;
71551: 
71551:         return glContext.forget();
71551:     }
71551: 
43426: public:
47908:     GLContextEGL(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  EGLConfig aConfig,
47908:                  EGLSurface aSurface,
47908:                  EGLContext aContext,
47908:                  PRBool aIsOffscreen = PR_FALSE)
47908:         : GLContext(aFormat, aIsOffscreen, aShareContext)
47908:         , mConfig(aConfig) 
44172:         , mSurface(aSurface), mContext(aContext)
77137:         , mPlatformContext(nsnull)
47908:         , mThebesSurface(nsnull)
44173:         , mBound(PR_FALSE)
47908:         , mIsPBuffer(PR_FALSE)
53687:         , mIsDoubleBuffered(PR_FALSE)
61663:         , mPBufferCanBindToTexture(PR_FALSE)
49076:     {
49076:         // any EGL contexts will always be GLESv2
49076:         SetIsGLES2(PR_TRUE);
53687: 
55263: #ifdef DEBUG
53687:         printf_stderr("Initializing context %p surface %p on display %p\n", mContext, mSurface, EGL_DISPLAY());
55263: #endif
49076:     }
43426: 
43426:     ~GLContextEGL()
43426:     {
54505:         MarkDestroyed();
49071: 
44172:         // If mGLWidget is non-null, then we've been given it by the GL context provider,
44172:         // and it's managed by the widget implementation. In this case, We can't destroy
44172:         // our contexts.
77137:         if (mPlatformContext)
44172:             return;
44172: 
55263: #ifdef DEBUG
53687:         printf_stderr("Destroying context %p surface %p on display %p\n", mContext, mSurface, EGL_DISPLAY());
55263: #endif
53687: 
47908:         sEGLLibrary.fDestroyContext(EGL_DISPLAY(), mContext);
77086:         if (mSurface) {
47908:             sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
47908:         }
77086:     }
47908: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeEGL;
43426:     }
43426: 
43426:     PRBool Init()
43426:     {
43426:         if (!OpenLibrary(GLES2_LIB)) {
43426:             NS_WARNING("Couldn't load EGL LIB.");
43426:             return PR_FALSE;
43426:         }
43426: 
77638:         PRBool current = MakeCurrent();
77638:         if (!current) {
77638:             gfx::LogFailure(NS_LITERAL_CSTRING(
77638:                 "Couldn't get device attachments for device."));
77638:             return PR_FALSE;
77638:         }
77638: 
53687:         PRBool ok = InitWithPrefix("gl", PR_TRUE);
53687: #if 0
53687:         if (ok) {
53687:             EGLint v;
53687:             sEGLLibrary.fQueryContext(EGL_DISPLAY(), mContext, LOCAL_EGL_RENDER_BUFFER, &v);
53687:             if (v == LOCAL_EGL_BACK_BUFFER)
53687:                 mIsDoubleBuffered = PR_TRUE;
53687:         }
53687: #endif
53687:         return ok;
53687:     }
53687: 
53687:     PRBool IsDoubleBuffered() {
53687:         return mIsDoubleBuffered;
53687:     }
53687: 
53687:     void SetIsDoubleBuffered(PRBool aIsDB) {
53687:         mIsDoubleBuffered = aIsDB;
43426:     }
43426: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:     gfxASurface* GetOffscreenPixmapSurface()
74436:     {
74436:       return mThebesSurface;
74436:     }
74436:     
74436:     virtual PRBool WaitNative() {
74436:       return sEGLLibrary.fWaitNative(LOCAL_EGL_CORE_NATIVE_ENGINE);
74436:     }
74436: #endif
74436: 
44173:     PRBool BindTexImage()
44173:     {
46146:         if (!mSurface)
44173:             return PR_FALSE;
44173: 
46146:         if (mBound && !ReleaseTexImage())
46146:             return PR_FALSE;
46146: 
47908:         EGLBoolean success = sEGLLibrary.fBindTexImage(EGL_DISPLAY(),
46146:             (EGLSurface)mSurface, LOCAL_EGL_BACK_BUFFER);
44173:         if (success == LOCAL_EGL_FALSE)
44173:             return PR_FALSE;
44173: 
44173:         mBound = PR_TRUE;
44173:         return PR_TRUE;
44173:     }
44173: 
44173:     PRBool ReleaseTexImage()
44173:     {
44173:         if (!mBound)
44173:             return PR_TRUE;
44173: 
47908:         if (!mSurface)
44173:             return PR_FALSE;
44173: 
44173:         EGLBoolean success;
47908:         success = sEGLLibrary.fReleaseTexImage(EGL_DISPLAY(),
47908:                                                (EGLSurface)mSurface,
47908:                                                LOCAL_EGL_BACK_BUFFER);
44173:         if (success == LOCAL_EGL_FALSE)
44173:             return PR_FALSE;
44173: 
44173:         mBound = PR_FALSE;
44173:         return PR_TRUE;
44173:     }
44173: 
55380:     PRBool MakeCurrentImpl(PRBool aForce = PR_FALSE) {
43426:         PRBool succeeded = PR_TRUE;
43426: 
43426:         // Assume that EGL has the same problem as WGL does,
43426:         // where MakeCurrent with an already-current context is
43426:         // still expensive.
77086: #ifndef MOZ_WIDGET_QT
77086:         if (!mSurface) {
77086:             EGLConfig config = CreateConfig();
77086:             mSurface = CreateSurfaceForWindow(NULL, config);
77284:             aForce = PR_TRUE;
77086:         }
77086: #endif
77284:         if (aForce || sEGLLibrary.fGetCurrentContext() != mContext) {
47908:             succeeded = sEGLLibrary.fMakeCurrent(EGL_DISPLAY(),
47908:                                                  mSurface, mSurface,
47908:                                                  mContext);
43426:             NS_ASSERTION(succeeded, "Failed to make GL context current!");
43426:         }
43426: 
43426:         return succeeded;
43426:     }
43426: 
59165: #ifdef MOZ_WIDGET_QT
59165:     virtual PRBool
59165:     RenewSurface() {
59165:         /* We don't support renewing on QT because we don't create the surface ourselves */
59165:         return PR_FALSE;
59165:     }
59165: #else
59165:     virtual PRBool
59165:     RenewSurface() {
77086:         ReleaseSurface();
59165:         EGLConfig config = CreateConfig();
59165:         mSurface = CreateSurfaceForWindow(NULL, config);
59165: 
59165:         return sEGLLibrary.fMakeCurrent(EGL_DISPLAY(),
59165:                                         mSurface, mSurface,
59165:                                         mContext);
59165:     }
59165: #endif
59165: 
77086: #ifndef MOZ_WIDGET_QT
77086:     virtual void
77086:     ReleaseSurface() {
77086:         if (mSurface) {
77086:             sEGLLibrary.fMakeCurrent(EGL_DISPLAY(), EGL_NO_SURFACE, EGL_NO_SURFACE,
77086:                                      EGL_NO_CONTEXT);
77086:             sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
77086:             mSurface = NULL;
77086:         }
77086:     }
77086: #endif
77086: 
43426:     PRBool SetupLookupFunction()
43426:     {
43426:         mLookupFunc = (PlatformLookupFunction)sEGLLibrary.fGetProcAddress;
43426:         return PR_TRUE;
43426:     }
43426: 
43426:     void *GetNativeData(NativeDataType aType)
43426:     {
43426:         switch (aType) {
43426:         case NativeGLContext:
43426:             return mContext;
43426: 
43426:         default:
43426:             return nsnull;
43426:         }
43426:     }
43426: 
46261:     PRBool SwapBuffers()
46261:     {
77086:         if (mSurface) {
47908:             return sEGLLibrary.fSwapBuffers(EGL_DISPLAY(), mSurface);
77086:         } else {
77086:             return PR_FALSE;
77086:         }
46261:     }
73465:     // GLContext interface - returns Tiled Texture Image in our case
46978:     virtual already_AddRefed<TextureImage>
46978:     CreateTextureImage(const nsIntSize& aSize,
46978:                        TextureImage::ContentType aContentType,
57421:                        GLenum aWrapMode,
46978:                        PRBool aUseNearestFilter=PR_FALSE);
46978: 
73465:     // a function to generate Tiles for Tiled Texture Image
73465:     virtual already_AddRefed<TextureImage>
73465:     TileGenFunc(const nsIntSize& aSize,
73465:                 TextureImage::ContentType aContentType,
73465:                 PRBool aUseNearestFilter = PR_FALSE);
47908:     // hold a reference to the given surface
47908:     // for the lifetime of this context.
47908:     void HoldSurface(gfxASurface *aSurf) {
47908:         mThebesSurface = aSurf;
47908:     }
47908: 
77137:     void SetPlatformContext(void *context) {
77137:         mPlatformContext = context;
47908:     }
47908: 
47908:     EGLContext Context() {
47908:         return mContext;
47908:     }
47908: 
47908:     PRBool BindTex2DOffscreen(GLContext *aOffscreen);
47908:     void UnbindTex2DOffscreen(GLContext *aOffscreen);
47908:     PRBool ResizeOffscreen(const gfxIntSize& aNewSize);
47908:     void BindOffscreenFramebuffer();
47908: 
47908:     static already_AddRefed<GLContextEGL>
47908:     CreateEGLPixmapOffscreenContext(const gfxIntSize& aSize,
71551:                                     const ContextFormat& aFormat,
71551:                                     PRBool aShare);
47908: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:     static already_AddRefed<GLContextEGL>
74436:     CreateBasicEGLPixmapOffscreenContext(const gfxIntSize& aSize,
74436:                                          const ContextFormat& aFormat);
74436: 
74436:     PRBool ResizeOffscreenPixmapSurface(const gfxIntSize& aNewSize);
74436: #endif
74436: 
47908:     static already_AddRefed<GLContextEGL>
47908:     CreateEGLPBufferOffscreenContext(const gfxIntSize& aSize,
47908:                                      const ContextFormat& aFormat);
47908: 
47908:     void SetOffscreenSize(const gfxIntSize &aRequestedSize,
47908:                           const gfxIntSize &aActualSize)
47908:     {
47908:         mOffscreenSize = aRequestedSize;
47908:         mOffscreenActualSize = aActualSize;
47908:     }
47908: 
60089:     void *GetD3DShareHandle() {
74513:         if (!sEGLLibrary.HasANGLESurfaceD3DTexture2DShareHandle()) {
60089:             return nsnull;
60089:         }
60089: 
60089:         void *h = nsnull;
60089: 
60089: #ifndef EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE
60089: #define EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE 0x3200
60089: #endif
60089: 
60089:         if (!sEGLLibrary.fQuerySurfacePointerANGLE(EGL_DISPLAY(), mSurface,
60089:                                                    EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE, (void**) &h))
60089:         {
60089:             return nsnull;
60089:         }
60089: 
60089:         return h;
60089:     }
60089: 
47908: protected:
47908:     friend class GLContextProviderEGL;
47908: 
43426:     EGLConfig  mConfig;
43426:     EGLSurface mSurface;
43426:     EGLContext mContext;
77137:     void *mPlatformContext;
47908:     nsRefPtr<gfxASurface> mThebesSurface;
44173:     PRBool mBound;
47908: 
47908:     PRPackedBool mIsPBuffer;
53687:     PRPackedBool mIsDoubleBuffered;
61663:     PRPackedBool mPBufferCanBindToTexture;
61664: 
61664:     static EGLSurface CreatePBufferSurfaceTryingPowerOfTwo(EGLConfig config,
61664:                                                            EGLenum bindToTextureFormat,
61664:                                                            gfxIntSize& pbsize)
61664:     {
61664:         nsTArray<EGLint> pbattrs(16);
61664:         EGLSurface surface = nsnull;
61664: 
61664:     TRY_AGAIN_POWER_OF_TWO:
61664:         pbattrs.Clear();
61664:         pbattrs.AppendElement(LOCAL_EGL_WIDTH); pbattrs.AppendElement(pbsize.width);
61664:         pbattrs.AppendElement(LOCAL_EGL_HEIGHT); pbattrs.AppendElement(pbsize.height);
61664: 
61664:         if (bindToTextureFormat != LOCAL_EGL_NONE) {
61664:             pbattrs.AppendElement(LOCAL_EGL_TEXTURE_TARGET);
61664:             pbattrs.AppendElement(LOCAL_EGL_TEXTURE_2D);
61664: 
61664:             pbattrs.AppendElement(LOCAL_EGL_TEXTURE_FORMAT);
61664:             pbattrs.AppendElement(bindToTextureFormat);
61664:         }
61664: 
61664:         pbattrs.AppendElement(LOCAL_EGL_NONE);
61664: 
61664:         surface = sEGLLibrary.fCreatePbufferSurface(EGL_DISPLAY(), config, &pbattrs[0]);
61664:         if (!surface) {
61664:             if (!is_power_of_two(pbsize.width) ||
61664:                 !is_power_of_two(pbsize.height))
61664:             {
61664:                 if (!is_power_of_two(pbsize.width))
61664:                     pbsize.width = next_power_of_two(pbsize.width);
61664:                 if (!is_power_of_two(pbsize.height))
61664:                     pbsize.height = next_power_of_two(pbsize.height);
61664: 
61664:                 NS_WARNING("Failed to create pbuffer, trying power of two dims");
61664:                 goto TRY_AGAIN_POWER_OF_TWO;
61664:             }
61664: 
61664:             NS_WARNING("Failed to create pbuffer surface");
61664:             return nsnull;
61664:         }
61664: 
61664:         return surface;
61664:     }
43426: };
43426: 
47908: PRBool
47908: GLContextEGL::BindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     if (aOffscreen->GetContextType() != ContextTypeEGL) {
47908:         NS_WARNING("non-EGL context");
47908:         return PR_FALSE;
47908:     }
47908: 
47908:     GLContextEGL *offs = static_cast<GLContextEGL*>(aOffscreen);
47908: 
61663:     if (offs->mIsPBuffer && offs->mPBufferCanBindToTexture) {
47908:         PRBool ok = sEGLLibrary.fBindTexImage(EGL_DISPLAY(),
47908:                                               offs->mSurface,
47908:                                               LOCAL_EGL_BACK_BUFFER);
47908:         return ok;
47908:     }
47908: 
47908:     if (offs->mOffscreenTexture) {
47908:         if (offs->GetSharedContext() != GLContextProviderEGL::GetGlobalContext())
47908:         {
47908:             NS_WARNING("offscreen FBO context can only be bound with context sharing!");
47908:             return PR_FALSE;
47908:         }
47908: 
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, offs->mOffscreenTexture);
47908:         return PR_TRUE;
47908:     }
47908: 
47908:     NS_WARNING("don't know how to bind this!");
47908: 
47908:     return PR_FALSE;
47908: }
47908: 
47908: void
47908: GLContextEGL::UnbindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     NS_ASSERTION(aOffscreen->GetContextType() == ContextTypeEGL, "wrong type");
47908: 
47908:     GLContextEGL *offs = static_cast<GLContextEGL*>(aOffscreen);
47908: 
61663:     if (offs->mIsPBuffer && offs->mPBufferCanBindToTexture) {
47908:         sEGLLibrary.fReleaseTexImage(EGL_DISPLAY(),
47908:                                      offs->mSurface,
47908:                                      LOCAL_EGL_BACK_BUFFER);
47908:     }
47908: }
47908: 
47908: PRBool
47908: GLContextEGL::ResizeOffscreen(const gfxIntSize& aNewSize)
47908: {
47908:     if (mIsPBuffer) {
47908:         gfxIntSize pbsize(aNewSize);
47908: 
61664:         EGLSurface surface =
61664:             CreatePBufferSurfaceTryingPowerOfTwo(mConfig,
61664:                                                  mPBufferCanBindToTexture
61664:                                                  ? (mCreationFormat.minAlpha
61664:                                                     ? LOCAL_EGL_TEXTURE_RGBA
61664:                                                     : LOCAL_EGL_TEXTURE_RGB)
61664:                                                  : LOCAL_EGL_NONE,
61664:                                                  pbsize);
47908:         if (!surface) {
47908:             NS_WARNING("Failed to resize pbuffer");
47908:             return nsnull;
47908:         }
47908: 
47908:         SetOffscreenSize(aNewSize, pbsize);
47908: 
77086:         if (mSurface) {
47908:             sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
77086:         }
47908: 
47908:         mSurface = surface;
47908: 
47908:         MakeCurrent(PR_TRUE);
47908:         ClearSafely();
47908: 
47908:         return PR_TRUE;
47908:     }
47908: 
71551: #ifdef MOZ_X11
71551:     if (gUseBackingSurface && mThebesSurface) {
71551:         if (aNewSize == mThebesSurface->GetSize()) {
71551:             return PR_TRUE;
71551:         }
71551: 
71551:         EGLNativePixmapType pixmap = 0;
71551:         nsRefPtr<gfxXlibSurface> xsurface =
71551:             gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()),
71551:                                    gfxXlibSurface::FindRenderFormat(DefaultXDisplay(),
71551:                                                                     gfxASurface::ImageFormatRGB24),
71551:                                    aNewSize);
71551:         // Make sure that pixmap created and ready for GL rendering
71551:         XSync(DefaultXDisplay(), False);
71551: 
71551:         if (xsurface->CairoStatus() != 0) {
71551:             return PR_FALSE;
71551:         }
77137:         pixmap = (EGLNativePixmapType)xsurface->XDrawable();
71551:         if (!pixmap) {
71551:             return PR_FALSE;
71551:         }
71551: 
71551:         EGLSurface surface;
71551:         EGLConfig config = 0;
71551:         int depth = gfxUtils::ImageFormatToDepth(gfxPlatform::GetPlatform()->GetOffscreenFormat());
71551:         surface = CreateEGLSurfaceForXSurface(xsurface, &config, depth);
71551:         if (!config) {
71551:             return PR_FALSE;
71551:         }
71551:         mThebesSurface = xsurface;
71551: 
71551:         return PR_TRUE;
71551:     }
71551: #endif
71551: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:     return ResizeOffscreenPixmapSurface(aNewSize);
74436: #endif
74436: 
47908:     return ResizeOffscreenFBO(aNewSize);
47908: }
47908: 
47908: 
47908: static GLContextEGL *
47908: GetGlobalContextEGL()
47908: {
47908:     return static_cast<GLContextEGL*>(GLContextProviderEGL::GetGlobalContext());
47908: }
47908: 
58301: static GLenum
58301: GLFormatForImage(gfxASurface::gfxImageFormat aFormat)
58301: {
58301:     switch (aFormat) {
58301:     case gfxASurface::ImageFormatARGB32:
58301:         return LOCAL_GL_RGBA;
58301:     case gfxASurface::ImageFormatRGB24:
58301:         // this often isn't correct, because we can't guarantee that
58301:         // the alpha byte will be 0xff coming from the image surface
58301:         NS_WARNING("Using GL_RGBA for ImageFormatRGB24, are you sure you know what you're doing?");
58301:         return LOCAL_GL_RGBA;
58301:     case gfxASurface::ImageFormatRGB16_565:
58301:         return LOCAL_GL_RGB;
58301:     default:
58301:         NS_WARNING("Unknown GL format for Image format");
58301:     }
58301:     return 0;
58301: }
58301: 
58301: static GLenum
58301: GLTypeForImage(gfxASurface::gfxImageFormat aFormat)
58301: {
58301:     switch (aFormat) {
58301:     case gfxASurface::ImageFormatARGB32:
58301:     case gfxASurface::ImageFormatRGB24:
58301:         return LOCAL_GL_UNSIGNED_BYTE;
58301:     case gfxASurface::ImageFormatRGB16_565:
58301:         return LOCAL_GL_UNSIGNED_SHORT_5_6_5;
58301:     default:
58301:         NS_WARNING("Unknown GL format for Image format");
58301:     }
58301:     return 0;
58301: }
58301: 
58301: class TextureImageEGL
58301:     : public TextureImage
46978: {
46978: public:
46978:     TextureImageEGL(GLuint aTexture,
46978:                     const nsIntSize& aSize,
57421:                     GLenum aWrapMode,
46978:                     ContentType aContentType,
58301:                     GLContext* aContext)
73465:         : TextureImage(aSize, aWrapMode, aContentType)
73465:         , mTexture(aTexture)
46978:         , mGLContext(aContext)
58301:         , mUpdateFormat(gfxASurface::ImageFormatUnknown)
58301:         , mSurface(nsnull)
58301:         , mConfig(nsnull)
58301:         , mImageKHR(nsnull)
74463:         , mTextureState(Created)
58301:         , mBound(PR_FALSE)
58301:         , mIsLocked(PR_FALSE)
58301:     {
58301:         mUpdateFormat = gfxASurface::FormatFromContent(GetContentType());
58301: 
60438:         if (gUseBackingSurface) {
60438:             if (mUpdateFormat == gfxASurface::ImageFormatRGB24) {
60438: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
60438:                 mUpdateFormat = gfxASurface::ImageFormatRGB16_565;
60438:                 mShaderType = RGBXLayerProgramType;
60438: #else
60438:                 mUpdateFormat = gfxASurface::ImageFormatARGB32;
60438:                 mShaderType = RGBALayerProgramType;
60438: #endif
60438:             } else {
60438:                 mShaderType = RGBALayerProgramType;
60438:             }
74836:             Resize(aSize);
60438:         } else {
58301:             // Convert RGB24 to either ARGB32 on mobile.  We can't
58301:             // generate GL_RGB data, so we'll always have an alpha byte
58301:             // for RGB24.  No easy way to upload that to GL.
58301:             // 
58301:             // Note that if we start using RGB565 here, we'll need to
58301:             // watch for a) setting mIsRGBFormat to TRUE; and b) getting
58301:             // the stride right.
58301:             if (mUpdateFormat == gfxASurface::ImageFormatRGB24) {
58301:                 mUpdateFormat = gfxASurface::ImageFormatARGB32;
58301:             }
59439:             // We currently always use BGRA type textures
59439:             mShaderType = BGRALayerProgramType;
58301:         }
60438:     }
46978: 
46978:     virtual ~TextureImageEGL()
46978:     {
58301:         GLContext *ctx = mGLContext;
58301:         if (ctx->IsDestroyed() || !NS_IsMainThread()) {
58301:             ctx = ctx->GetSharedContext();
58301:         }
58301: 
58301:         // If we have a context, then we need to delete the texture;
58301:         // if we don't have a context (either real or shared),
58301:         // then they went away when the contex was deleted, because it
58301:         // was the only one that had access to it.
58301:         if (ctx && !ctx->IsDestroyed()) {
60010:             ctx->MakeCurrent();
60010:             ctx->fDeleteTextures(1, &mTexture);
58301:             ReleaseTexImage();
58301:             DestroyEGLSurface();
58301:         }
46978:     }
46978: 
77141:     virtual void GetUpdateRegion(nsIntRegion& aForRegion)
46978:     {
74463:         if (mTextureState != Valid) {
58301:             // if the texture hasn't been initialized yet, force the
58301:             // client to paint everything
77141:             aForRegion = nsIntRect(nsIntPoint(0, 0), mSize);
77141:         } else if (!mBackingSurface) {
58301:             // We can only draw a rectangle, not subregions due to
58301:             // the way that our texture upload functions work.  If
58301:             // needed, we /could/ do multiple texture uploads if we have
58301:             // non-overlapping rects, but that's a tradeoff.
77141:             aForRegion = nsIntRegion(aForRegion.GetBounds());
60438:         }
60438:     }
58301: 
77141:     virtual gfxASurface* BeginUpdate(nsIntRegion& aRegion)
77141:     {
77141:         NS_ASSERTION(!mUpdateSurface, "BeginUpdate() without EndUpdate()?");
77141: 
77141:         // determine the region the client will need to repaint
77141:         GetUpdateRegion(aRegion);
77141:         mUpdateRect = aRegion.GetBounds();
77141: 
60438:         //printf_stderr("BeginUpdate with updateRect [%d %d %d %d]\n", mUpdateRect.x, mUpdateRect.y, mUpdateRect.width, mUpdateRect.height);
58301:         if (!nsIntRect(nsIntPoint(0, 0), mSize).Contains(mUpdateRect)) {
58301:             NS_ERROR("update outside of image");
58301:             return NULL;
53687:         }
53687: 
58301:         if (mBackingSurface) {
58301:             if (sEGLLibrary.HasKHRLockSurface()) {
60739:                 mUpdateSurface = GetLockSurface();
58301:             } else {
60739:                 mUpdateSurface = mBackingSurface;
60438:             }
60438: 
60739:             return mUpdateSurface;
46978:         }
46978: 
58301:         // if we get this far, then we're using Cairo's byte order
58301:         mIsRGBFormat = PR_FALSE;
58301: 
58301:         //printf_stderr("creating image surface %dx%d format %d\n", mUpdateRect.width, mUpdateRect.height, mUpdateFormat);
58301: 
60739:         mUpdateSurface =
58301:             new gfxImageSurface(gfxIntSize(mUpdateRect.width, mUpdateRect.height),
58301:                                 mUpdateFormat);
58301: 
60739:         mUpdateSurface->SetDeviceOffset(gfxPoint(-mUpdateRect.x, -mUpdateRect.y));
58301: 
60739:         return mUpdateSurface;
58301:     }
58301: 
60740:     virtual void EndUpdate()
46978:     {
60739:         NS_ASSERTION(!!mUpdateSurface, "EndUpdate() without BeginUpdate()?");
46978: 
58301:         if (mIsLocked) {
58301:             UnlockSurface();
74463:             mTextureState = Valid;
60739:             mUpdateSurface = nsnull;
60740:             return;
58301:         }
53687: 
60739:         if (mBackingSurface && mUpdateSurface == mBackingSurface) {
46978: #ifdef MOZ_X11
58301:             if (mBackingSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
58301:                 XSync(DefaultXDisplay(), False);
58301:             }
53687: #endif
46978: 
58301:             mBackingSurface->SetDeviceOffset(gfxPoint(0, 0));
74463:             mTextureState = Valid;
60739:             mUpdateSurface = nsnull;
60740:             return;
58301:         }
58301: 
58301:         //printf_stderr("EndUpdate: slow path");
58301: 
58301:         // This is the slower path -- we didn't have any way to set up
58301:         // a fast mapping between our cairo target surface and the GL
58301:         // texture, so we have to upload data.
58301: 
58301:         // Undo the device offset that BeginUpdate set; doesn't much
58301:         // matter for us here, but important if we ever do anything
58301:         // directly with the surface.
60739:         mUpdateSurface->SetDeviceOffset(gfxPoint(0, 0));
58301: 
58301:         nsRefPtr<gfxImageSurface> uploadImage = nsnull;
58301:         gfxIntSize updateSize(mUpdateRect.width, mUpdateRect.height);
58301: 
60739:         NS_ASSERTION(mUpdateSurface->GetType() == gfxASurface::SurfaceTypeImage &&
60739:                      mUpdateSurface->GetSize() == updateSize,
58301:                      "Upload image isn't an image surface when one is expected, or is wrong size!");
58301: 
60739:         uploadImage = static_cast<gfxImageSurface*>(mUpdateSurface.get());
58301: 
58301:         if (!uploadImage) {
60740:             return;
46978:         }
46978: 
53687:         mGLContext->MakeCurrent();
53687:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
57642: 
74463:         if (mTextureState != Valid) {
58301:             NS_ASSERTION(mUpdateRect.x == 0 && mUpdateRect.y == 0 &&
58301:                          mUpdateRect.Size() == mSize,
58301:                          "Bad initial update on non-created texture!");
58301: 
58301:             mGLContext->fTexImage2D(LOCAL_GL_TEXTURE_2D,
58301:                                     0,
58301:                                     GLFormatForImage(mUpdateFormat),
58301:                                     mUpdateRect.width,
58301:                                     mUpdateRect.height,
58301:                                     0,
58301:                                     GLFormatForImage(uploadImage->Format()),
58301:                                     GLTypeForImage(uploadImage->Format()),
58301:                                     uploadImage->Data());
58301:         } else {
57642:             mGLContext->fTexSubImage2D(LOCAL_GL_TEXTURE_2D,
57642:                                        0,
57642:                                        mUpdateRect.x,
57642:                                        mUpdateRect.y,
57642:                                        mUpdateRect.width,
57642:                                        mUpdateRect.height,
58301:                                        GLFormatForImage(uploadImage->Format()),
58301:                                        GLTypeForImage(uploadImage->Format()),
58301:                                        uploadImage->Data());
57642:         }
53687: 
60739:         mUpdateSurface = nsnull;
74463:         mTextureState = Valid;
60740:         return;         // mTexture is bound
53687:     }
53687: 
73465:     virtual bool DirectUpdate(gfxASurface* aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom /* = nsIntPoint(0, 0) */)
59443:     {
59443:         nsIntRect bounds = aRegion.GetBounds();
59443: 
60728:         nsIntRegion region;
74463:         if (mTextureState != Valid) {
59443:             bounds = nsIntRect(0, 0, mSize.width, mSize.height);
60728:             region = nsIntRegion(bounds);
60728:         } else {
60728:             region = aRegion;
59443:         }
59443: 
60438:         if (mBackingSurface && sEGLLibrary.HasKHRLockSurface()) {
60739:             mUpdateSurface = GetLockSurface();
60739:             if (mUpdateSurface) {
60739:                 nsRefPtr<gfxContext> ctx = new gfxContext(mUpdateSurface);
60739:                 gfxUtils::ClipToRegion(ctx, aRegion);
73465:                 ctx->SetSource(aSurf, gfxPoint(-aFrom.x, -aFrom.y));
60739:                 ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
60739:                 ctx->Paint();
60739:                 mUpdateSurface = nsnull;
60438:                 UnlockSurface();
60438:             }
60438:         } else {
59443:             mShaderType =
59443:               mGLContext->UploadSurfaceToTexture(aSurf,
60728:                                                  region,
59443:                                                  mTexture,
74463:                                                  mTextureState == Created,
73465:                                                  bounds.TopLeft() + aFrom,
59443:                                                  PR_FALSE);
60438:         }
60438: 
74463:         mTextureState = Valid;
59443:         return true;
59443:     }
59443: 
67635:     virtual void BindTexture(GLenum aTextureUnit)
67635:     {
74836:         // Ensure the texture is allocated before it is used.
74836:         if (mTextureState == Created) {
74836:             Resize(mSize);
74836:         }
74836: 
67635:         mGLContext->fActiveTexture(aTextureUnit);
73465:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
67635:         mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
67635:     }
67635: 
74836:     virtual GLuint GetTextureID() 
74836:     {
74836:         // Ensure the texture is allocated before it is used.
74836:         if (mTextureState == Created) {
74836:             Resize(mSize);
74836:         }
73465:         return mTexture;
73465:     };
73465: 
60739:     virtual PRBool InUpdate() const { return !!mUpdateSurface; }
48091: 
58301:     virtual void Resize(const nsIntSize& aSize)
58301:     {
60739:         NS_ASSERTION(!mUpdateSurface, "Resize() while in update?");
58301: 
74463:         if (mSize == aSize && mTextureState != Created)
58301:             return;
58301: 
60438:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
74462: 	
74462:         // Try to generate a backin surface first if we have the ability
74462:         if (gUseBackingSurface) {
58301:             CreateBackingSurface(gfxIntSize(aSize.width, aSize.height));
74462:         }
74462: 
74462:         if (!mBackingSurface) {
74462:             // If we don't have a backing surface or failed to obtain one,
74462:             // use the GL Texture failsafe
58301:             mGLContext->fTexImage2D(LOCAL_GL_TEXTURE_2D,
58301:                                     0,
58301:                                     GLFormatForImage(mUpdateFormat),
58301:                                     aSize.width,
58301:                                     aSize.height,
58301:                                     0,
58301:                                     GLFormatForImage(mUpdateFormat),
58301:                                     GLTypeForImage(mUpdateFormat),
58301:                                     NULL);
58301:         }
58301: 
74463:         mTextureState = Allocated;
58301:         mSize = aSize;
58301:     }
58301: 
58301:     PRBool BindTexImage()
58301:     {
58301:         if (mBound && !ReleaseTexImage())
58301:             return PR_FALSE;
58301: 
58301:         EGLBoolean success =
58301:             sEGLLibrary.fBindTexImage(EGL_DISPLAY(),
58301:                                       (EGLSurface)mSurface,
58301:                                       LOCAL_EGL_BACK_BUFFER);
58301: 
58301:         if (success == LOCAL_EGL_FALSE)
58301:             return PR_FALSE;
58301: 
58301:         mBound = PR_TRUE;
58301:         return PR_TRUE;
58301:     }
58301: 
58301:     PRBool ReleaseTexImage()
58301:     {
58301:         if (!mBound)
58301:             return PR_TRUE;
58301: 
58301:         EGLBoolean success =
58301:             sEGLLibrary.fReleaseTexImage(EGL_DISPLAY(),
58301:                                          (EGLSurface)mSurface,
58301:                                          LOCAL_EGL_BACK_BUFFER);
58301: 
58301:         if (success == LOCAL_EGL_FALSE)
58301:             return PR_FALSE;
58301: 
58301:         mBound = PR_FALSE;
58301:         return PR_TRUE;
58301:     }
58301: 
58301:     virtual already_AddRefed<gfxImageSurface> GetLockSurface()
58301:     {
58301:         if (mIsLocked) {
58301:             NS_WARNING("Can't lock surface twice");
58301:             return nsnull;
58301:         }
58301: 
58301:         if (!sEGLLibrary.HasKHRLockSurface()) {
58301:             NS_WARNING("GetLockSurface called, but no EGL_KHR_lock_surface extension!");
58301:             return nsnull;
58301:         }
58301: 
58301:         if (!CreateEGLSurface(mBackingSurface)) {
58301:             NS_WARNING("Failed to create EGL surface");
58301:             return nsnull;
58301:         }
58301: 
58301:         static EGLint lock_attribs[] = {
58301:             LOCAL_EGL_MAP_PRESERVE_PIXELS_KHR, LOCAL_EGL_TRUE,
58301:             LOCAL_EGL_LOCK_USAGE_HINT_KHR, LOCAL_EGL_READ_SURFACE_BIT_KHR | LOCAL_EGL_WRITE_SURFACE_BIT_KHR,
58301:             LOCAL_EGL_NONE
58301:         };
58301: 
58301:         sEGLLibrary.fLockSurfaceKHR(EGL_DISPLAY(), mSurface, lock_attribs);
58301: 
58301:         mIsLocked = PR_TRUE;
58301: 
58301:         unsigned char *data = nsnull;
58301:         int pitch = 0;
58301:         int pixsize = 0;
58301: 
58301:         sEGLLibrary.fQuerySurface(EGL_DISPLAY(), mSurface, LOCAL_EGL_BITMAP_POINTER_KHR, (EGLint*)&data);
58301:         sEGLLibrary.fQuerySurface(EGL_DISPLAY(), mSurface, LOCAL_EGL_BITMAP_PITCH_KHR, &pitch);
58301:         sEGLLibrary.fQuerySurface(EGL_DISPLAY(), mSurface, LOCAL_EGL_BITMAP_PIXEL_SIZE_KHR, &pixsize);
58301: 
58301:         nsRefPtr<gfxImageSurface> sharedImage =
58301:             new gfxImageSurface(data,
58301:                                 mBackingSurface->GetSize(),
58301:                                 pitch,
58301:                                 mUpdateFormat);
58301: 
58301:         return sharedImage.forget();
58301:     }
58301: 
58301:     virtual void UnlockSurface()
58301:     {
58301:         if (!mIsLocked) {
58301:             NS_WARNING("UnlockSurface called, surface not locked!");
58301:             return;
58301:         }
58301: 
58301:         sEGLLibrary.fUnlockSurfaceKHR(EGL_DISPLAY(), mSurface);
58301:         mIsLocked = PR_FALSE;
58301:     }
58301: 
58301:     virtual already_AddRefed<gfxASurface> GetBackingSurface()
58301:     {
58301:         if (mBackingSurface) {
58301:             NS_ADDREF(mBackingSurface);
58301:         }
58301:         return mBackingSurface.get();
58301:     }
58301: 
58301:     virtual PRBool CreateEGLSurface(gfxASurface* aSurface)
58301:     {
60438: #ifdef MOZ_X11
58301:         if (!aSurface) {
58301:             NS_WARNING("no surface");
58301:             return PR_FALSE;
58301:         }
58301: 
58301:         if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
58301:             NS_WARNING("wrong surface type, must be xlib");
58301:             return PR_FALSE;
58301:         }
58301: 
58301:         if (mSurface) {
58301:             return PR_TRUE;
58301:         }
58301: 
60438:         EGLSurface surface = CreateEGLSurfaceForXSurface(aSurface, &mConfig);
58301: 
58301:         if (!surface) {
58301:             NS_WARNING("couldn't find X config for surface");
58301:             return PR_FALSE;
58301:         }
58301: 
58301:         mSurface = surface;
58301:         return PR_TRUE;
58301: #else
58301:         return PR_FALSE;
58301: #endif
58301:     }
58301: 
58301:     virtual void DestroyEGLSurface(void)
58301:     {
58301:         if (!mSurface)
58301:             return;
58301: 
58301:         sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
58301:         mSurface = nsnull;
58301:     }
58301: 
58301:     virtual PRBool CreateBackingSurface(const gfxIntSize& aSize)
58301:     {
58301:         ReleaseTexImage();
58301:         DestroyEGLSurface();
58301:         mBackingSurface = nsnull;
58301: 
58301: #ifdef MOZ_X11
58301:         Display* dpy = DefaultXDisplay();
58301:         XRenderPictFormat* renderFMT =
58301:             gfxXlibSurface::FindRenderFormat(dpy, mUpdateFormat);
58301: 
58301:         nsRefPtr<gfxXlibSurface> xsurface =
58301:             gfxXlibSurface::Create(DefaultScreenOfDisplay(dpy),
58301:                                    renderFMT,
58301:                                    gfxIntSize(aSize.width, aSize.height));
58301: 
58301:         XSync(dpy, False);
58301:         mConfig = nsnull;
58301: 
58301:         if (sEGLLibrary.HasKHRImagePixmap() && sEGLLibrary.HasKHRImageTexture2D()) {
58301:             mImageKHR =
58301:                 sEGLLibrary.fCreateImageKHR(EGL_DISPLAY(),
58301:                                             EGL_NO_CONTEXT,
58301:                                             LOCAL_EGL_NATIVE_PIXMAP_KHR,
58301:                                             (EGLClientBuffer)xsurface->XDrawable(),
58301:                                             NULL);
58301: 
58301:             if (!mImageKHR) {
58301:                 printf_stderr("couldn't create EGL image: ERROR (0x%04x)\n", sEGLLibrary.fGetError());
58301:                 return PR_FALSE;
58301:             }
58301:             mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
58301:             sEGLLibrary.fImageTargetTexture2DOES(LOCAL_GL_TEXTURE_2D, mImageKHR);
58301:             sEGLLibrary.fDestroyImageKHR(EGL_DISPLAY(), mImageKHR);
58301:             mImageKHR = NULL;
58301:         } else {
58301:             if (!CreateEGLSurface(xsurface)) {
58301:                 printf_stderr("ProviderEGL Failed create EGL surface: ERROR (0x%04x)\n", sEGLLibrary.fGetError());
58301:                 return PR_FALSE;
58301:             }
58301: 
58301:             if (!BindTexImage()) {
58301:                 printf_stderr("ProviderEGL Failed to bind teximage: ERROR (0x%04x)\n", sEGLLibrary.fGetError());
58301:                 return PR_FALSE;
58301:             }
58301:         }
58301: 
58301:         mBackingSurface = xsurface;
58301:         mIsRGBFormat = PR_TRUE;
58301: #endif
58301: 
58301:         return mBackingSurface != nsnull;
58301:     }
58301: 
58301: protected:
58301:     typedef gfxASurface::gfxImageFormat ImageFormat;
58301: 
46978:     GLContext* mGLContext;
53687: 
53687:     nsIntRect mUpdateRect;
58301:     ImageFormat mUpdateFormat;
58301:     nsRefPtr<gfxASurface> mBackingSurface;
60739:     nsRefPtr<gfxASurface> mUpdateSurface;
58301:     EGLSurface mSurface;
58301:     EGLConfig mConfig;
73465:     GLuint mTexture;
58301:     EGLImageKHR mImageKHR;
74463:     TextureState mTextureState;
74463: 
58301:     PRPackedBool mBound;
58301:     PRPackedBool mIsLocked;
46978: };
46978: 
46978: already_AddRefed<TextureImage>
46978: GLContextEGL::CreateTextureImage(const nsIntSize& aSize,
46978:                                  TextureImage::ContentType aContentType,
57421:                                  GLenum aWrapMode,
46978:                                  PRBool aUseNearestFilter)
46978: {
73465:     nsRefPtr<TextureImage> t = new gl::TiledTextureImage(this, aSize, aContentType);
73465:     return t.forget();
73465: };
73465: 
73465: already_AddRefed<TextureImage>
73465: GLContextEGL::TileGenFunc(const nsIntSize& aSize,
73465:                                  TextureImage::ContentType aContentType,
73465:                                  PRBool aUseNearestFilter)
73465: {
46978:   MakeCurrent();
46978: 
46978:   GLuint texture;
46978:   fGenTextures(1, &texture);
46978: 
46978:   fActiveTexture(LOCAL_GL_TEXTURE0);
46978:   fBindTexture(LOCAL_GL_TEXTURE_2D, texture);
46978: 
58301:   nsRefPtr<TextureImageEGL> teximage =
73465:       new TextureImageEGL(texture, aSize, LOCAL_GL_CLAMP_TO_EDGE, aContentType, this);
58301: 
46978:   GLint texfilter = aUseNearestFilter ? LOCAL_GL_NEAREST : LOCAL_GL_LINEAR;
46978:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, texfilter);
46978:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, texfilter);
73465:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, LOCAL_GL_CLAMP_TO_EDGE);
73465:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, LOCAL_GL_CLAMP_TO_EDGE);
46978: 
46978:   return teximage.forget();
46978: }
46978: 
54904: static ContextFormat
54904: DepthToGLFormat(int aDepth)
54904: {
54904:     switch (aDepth) {
54904:         case 32:
54904:             return ContextFormat::BasicRGBA32;
54904:         case 24:
54904:             return ContextFormat::BasicRGB24;
54904:         case 16:
54904:             return ContextFormat::BasicRGB16_565;
54904:         default:
54904:             break;
54904:     }
54904:     return ContextFormat::BasicRGBA32;
54904: }
54904: 
54904: 
59165: #ifdef MOZ_WIDGET_QT
43426: already_AddRefed<GLContext>
47907: GLContextProviderEGL::CreateForWindow(nsIWidget *aWidget)
43426: {
43426:     if (!sEGLLibrary.EnsureInitialized()) {
43426:         return nsnull;
43426:     }
43426: 
77137:     QGLContext* context = const_cast<QGLContext*>(QGLContext::currentContext());
77137:     if (context && context->device()) {
44172:         // Qt widget viewport already have GL context created by Qt
44172:         // Create dummy GLContextEGL class
44172:         nsRefPtr<GLContextEGL> glContext =
77137:             new GLContextEGL(ContextFormat(DepthToGLFormat(context->device()->depth())),
47908:                              NULL,
47908:                              NULL, NULL,
71551:                              sEGLLibrary.fGetCurrentContext(),
71551:                              PR_FALSE);
71551: 
44172:         if (!glContext->Init())
44172:             return nsnull;
60438: 
77137:         glContext->SetIsDoubleBuffered(context->format().doubleBuffer());
77137: 
77137:         glContext->SetPlatformContext(context);
47908: 
47908:         return glContext.forget();
47908:     }
47908: 
44172:     // All Qt nsIWidget's have the same X-Window surface
44172:     // And EGL not allowing to create multiple GL context for the same window
44172:     // we should be able to create GL context for QGV viewport once, and reuse it for all child widgets
77137:     NS_ERROR("Failed to get QGLContext");
47908: 
44172:     // Switch to software rendering here
44172:     return nsnull;
59165: }
47908: 
47908: #else
44172: 
59165: EGLConfig
59165: CreateConfig()
59165: {
43426:     EGLConfig  config;
43426:     EGLint attribs[] = {
43426:         LOCAL_EGL_SURFACE_TYPE,    LOCAL_EGL_WINDOW_BIT,
43426:         LOCAL_EGL_RENDERABLE_TYPE, LOCAL_EGL_OPENGL_ES2_BIT,
46261: 
46261: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
46261:         LOCAL_EGL_RED_SIZE,        5,
46261:         LOCAL_EGL_GREEN_SIZE,      6,
46261:         LOCAL_EGL_BLUE_SIZE,       5,
46261:         LOCAL_EGL_ALPHA_SIZE,      0,
53687: #else
53687:         LOCAL_EGL_RED_SIZE,        8,
53687:         LOCAL_EGL_GREEN_SIZE,      8,
53687:         LOCAL_EGL_BLUE_SIZE,       8,
53687:         LOCAL_EGL_ALPHA_SIZE,      8,
46261: #endif
46261: 
43426:         LOCAL_EGL_NONE
43426:     };
43426: 
47908:     EGLConfig configs[64];
47908:     EGLint ncfg = 64;
53686:     if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(), attribs, configs, ncfg, &ncfg) ||
43426:         ncfg < 1)
43426:     {
43426:         return nsnull;
43426:     }
43426: 
47908:     config = 0;
47908: 
47908:     for (int i = 0; i < ncfg; ++i) {
53687:         EGLint r, g, b, a;
47908: 
47908:         sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), configs[i], LOCAL_EGL_RED_SIZE, &r);
47908:         sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), configs[i], LOCAL_EGL_GREEN_SIZE, &g);
47908:         sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), configs[i], LOCAL_EGL_BLUE_SIZE, &b);
53687:         sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), configs[i], LOCAL_EGL_ALPHA_SIZE, &a);
47908: 
53687: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
47908:         if (r == 5 && g == 6 && b == 5) {
47908:             config = configs[i];
53687:             break;
53687:         }
53687: #else
53687:         if (r == 8 && g == 8 && b == 8 && a == 8) {
53687:             config = configs[i];
53687:             break;
53687:         }
53687: #endif
53687:     }
53687: 
59165:     return config;
53687: }
53687: 
59165: EGLSurface
59165: CreateSurfaceForWindow(nsIWidget *aWidget, EGLConfig config)
59165: {
59165:     EGLSurface surface;
59165: 
59165: 
47908: #ifdef DEBUG
47908:     sEGLLibrary.DumpEGLConfig(config);
47908: #endif
47908: 
46261: #ifdef ANDROID
46261:     // On Android, we have to ask Java to make the eglCreateWindowSurface
46261:     // call for us.  See GLHelpers.java for a description of why.
46261:     //
46261:     // We also only have one true "window", so we just use it directly and ignore
46261:     // what was passed in.
53686:     printf_stderr("... requesting window surface from bridge\n");
46261:     surface = mozilla::AndroidBridge::Bridge()->
53686:         CallEglCreateWindowSurface(EGL_DISPLAY(), config,
46261:                                    mozilla::AndroidBridge::Bridge()->SurfaceView());
53686:     printf_stderr("got surface %p\n", surface);
46261: #else
53686:     surface = sEGLLibrary.fCreateWindowSurface(EGL_DISPLAY(), config, GET_NATIVE_WINDOW(aWidget), 0);
46261: #endif
46261: 
59165:     return surface;
59165: }
59165: 
60068: const char*
60068: GetVendor()
60068: {
60068:     if (!sEGLLibrary.EnsureInitialized()) {
60068:         return nsnull;
60068:     }
60068: 
60068:     return reinterpret_cast<const char*>(sEGLLibrary.fQueryString(EGL_DISPLAY(), LOCAL_EGL_VENDOR));
60068: }
60068: 
59165: already_AddRefed<GLContext>
59165: GLContextProviderEGL::CreateForWindow(nsIWidget *aWidget)
59165: {
59165:     EGLConfig config;
59165: 
59165:     if (!sEGLLibrary.EnsureInitialized()) {
59165:         return nsnull;
59165:     }
59165: 
59165:     config = CreateConfig();
59165: 
59165:     if (!config) {
59165:         printf_stderr("Failed to create EGL config!\n");
59165:         return nsnull;
59165:     }
59165: 
59165:     EGLSurface surface = CreateSurfaceForWindow(aWidget, config);
59165: 
43426:     if (!surface) {
43426:         return nsnull;
43426:     }
43426: 
46261:     if (!sEGLLibrary.fBindAPI(LOCAL_EGL_OPENGL_ES_API)) {
53686:         sEGLLibrary.fDestroySurface(EGL_DISPLAY(), surface);
46261:         return nsnull;
46261:     }
46261: 
47908:     GLContextEGL *shareContext = GetGlobalContextEGL();
47908: 
71551:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateGLContext(ContextFormat(ContextFormat::BasicRGB24),
71551:                                       surface,
47908:                                       config,
71551:                                       shareContext,
71551:                                       PR_FALSE);
47908: 
71551:     if (!glContext) {
43426:         return nsnull;
43426:     }
43426: 
60438: #if defined(XP_WIN) || defined(ANDROID) || defined(MOZ_PLATFORM_MAEMO)
53687:     glContext->SetIsDoubleBuffered(PR_TRUE);
53687: #endif
53687: 
47908:     return glContext.forget();
59165: }
47908: #endif
43426: 
61664: static void
61664: FillPBufferAttribs(nsTArray<EGLint>& aAttrs,
61664:                    const ContextFormat& aFormat,
61664:                    bool aCanBindToTexture,
61664:                    int aColorBitsOverride,
61664:                    int aDepthBitsOverride)
61664: {
61664:     aAttrs.Clear();
61664: 
61664: #define A1(_x)      do { aAttrs.AppendElement(_x); } while (0)
61664: #define A2(_x,_y)   do { A1(_x); A1(_y); } while (0)
61664: 
61664:     A2(LOCAL_EGL_RENDERABLE_TYPE, LOCAL_EGL_OPENGL_ES2_BIT);
61664: 
61664:     if (aColorBitsOverride == -1) {
61664:         A2(LOCAL_EGL_RED_SIZE, aFormat.red);
61664:         A2(LOCAL_EGL_GREEN_SIZE, aFormat.green);
61664:         A2(LOCAL_EGL_BLUE_SIZE, aFormat.blue);
61664:     } else {
61664:         A2(LOCAL_EGL_RED_SIZE, aColorBitsOverride);
61664:         A2(LOCAL_EGL_GREEN_SIZE, aColorBitsOverride);
61664:         A2(LOCAL_EGL_BLUE_SIZE, aColorBitsOverride);
61664:     }
61664: 
61664:     A2(LOCAL_EGL_ALPHA_SIZE, aFormat.alpha);
61664: 
61664:     if (aDepthBitsOverride == -1) {
61664:         A2(LOCAL_EGL_DEPTH_SIZE, aFormat.minDepth);
61664:     } else {
61664:         A2(LOCAL_EGL_DEPTH_SIZE, aDepthBitsOverride);
61664:     }
61664: 
61664:     A2(LOCAL_EGL_STENCIL_SIZE, aFormat.minStencil);
61664: 
61664:     if (aCanBindToTexture) {
61664:         A2(aFormat.minAlpha ? LOCAL_EGL_BIND_TO_TEXTURE_RGBA : LOCAL_EGL_BIND_TO_TEXTURE_RGB,
61664:            LOCAL_EGL_TRUE);
61664:     }
61664: 
61664:     A1(LOCAL_EGL_NONE);
61664: #undef A1
61664: #undef A2
61664: }
61664: 
47908: already_AddRefed<GLContextEGL>
47908: GLContextEGL::CreateEGLPBufferOffscreenContext(const gfxIntSize& aSize,
47908:                                                const ContextFormat& aFormat)
43426: {
43426:     EGLConfig config;
43426:     EGLSurface surface;
43426:     EGLContext context;
43426: 
61663:     bool configCanBindToTexture = true;
61663: 
61663:     EGLConfig configs[64];
61663:     int numConfigs = sizeof(configs)/sizeof(EGLConfig);
61663:     int foundConfigs = 0;
61663: 
61663:     // if we're running under ANGLE, we can't set BIND_TO_TEXTURE --
61663:     // it's not supported, and we have dx interop pbuffers anyway
61663:     if (sEGLLibrary.IsANGLE())
61663:         configCanBindToTexture = false;
61663: 
61664:     nsTArray<EGLint> attribs(32);
61664:     int attribAttempt = 0;
43426: 
61664: TRY_ATTRIBS_AGAIN:
61664:     switch (attribAttempt) {
61664:     case 0:
61664:         FillPBufferAttribs(attribs, aFormat, configCanBindToTexture, 8, 24);
61664:         break;
61664:     case 1:
61664:         FillPBufferAttribs(attribs, aFormat, configCanBindToTexture, -1, 24);
61664:         break;
61664:     case 2:
61664:         FillPBufferAttribs(attribs, aFormat, configCanBindToTexture, -1, -1);
61664:         break;
60089:     }
60089: 
47908:     if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(),
61664:                                    &attribs[0],
47908:                                    configs, numConfigs,
61663:                                    &foundConfigs)
61663:         || foundConfigs == 0)
47908:     {
61664:         if (attribAttempt < 3) {
61664:             attribAttempt++;
61664:             goto TRY_ATTRIBS_AGAIN;
61664:         }
61664: 
61663:         if (configCanBindToTexture) {
61663:             NS_WARNING("No pbuffer EGL configs that can bind to texture, trying without");
61663:             configCanBindToTexture = false;
61664:             attribAttempt = 0;
61664:             goto TRY_ATTRIBS_AGAIN;
61663:         }
61663: 
47908:         // no configs? no pbuffers!
43426:         return nsnull;
47908:     }
47908: 
61664:     // XXX do some smarter matching here, perhaps instead of the more complex
61664:     // minimum overrides above
47908:     config = configs[0];
47908: #ifdef DEBUG
47908:     sEGLLibrary.DumpEGLConfig(config);
47908: #endif
47908: 
47908:     gfxIntSize pbsize(aSize);
61664:     surface = GLContextEGL::CreatePBufferSurfaceTryingPowerOfTwo(config,
61664:                                                                  configCanBindToTexture
61664:                                                                  ? (aFormat.minAlpha
61664:                                                                     ? LOCAL_EGL_TEXTURE_RGBA
61664:                                                                     : LOCAL_EGL_TEXTURE_RGB)
61664:                                                                  : LOCAL_EGL_NONE,
61664:                                                                  pbsize);
61664:     if (!surface)
47908:         return nsnull;
43426: 
43426:     sEGLLibrary.fBindAPI(LOCAL_EGL_OPENGL_ES_API);
43426: 
43426:     EGLint cxattrs[] = {
43426:         LOCAL_EGL_CONTEXT_CLIENT_VERSION, 2,
43426:         LOCAL_EGL_NONE
43426:     };
43426: 
47908:     context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
47908:                                          config,
47908:                                          EGL_NO_CONTEXT,
47908:                                          cxattrs);
43426:     if (!context) {
47908:         NS_WARNING("Failed to create context");
47908:         sEGLLibrary.fDestroySurface(EGL_DISPLAY(), surface);
43426:         return nsnull;
43426:     }
43426: 
47908:     nsRefPtr<GLContextEGL> glContext = new GLContextEGL(aFormat, nsnull,
47908:                                                         config, surface, context,
47908:                                                         PR_TRUE);
43426: 
47908:     if (!glContext->Init()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     glContext->SetOffscreenSize(aSize, pbsize);
61663:     glContext->mIsPBuffer = PR_TRUE;
61663:     glContext->mPBufferCanBindToTexture = configCanBindToTexture;
47908: 
47908:     return glContext.forget();
47908: }
47908: 
54904: #ifdef MOZ_X11
60438: EGLSurface
71551: CreateEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig, EGLenum aDepth)
54904: {
54904:     gfxXlibSurface* xsurface = static_cast<gfxXlibSurface*>(aSurface);
60438:     PRBool opaque =
60438:         aSurface->GetContentType() == gfxASurface::CONTENT_COLOR;
60438: 
60438:     static EGLint pixmap_config_rgb[] = {
60438:         LOCAL_EGL_TEXTURE_TARGET,       LOCAL_EGL_TEXTURE_2D,
60438:         LOCAL_EGL_TEXTURE_FORMAT,       LOCAL_EGL_TEXTURE_RGB,
60438:         LOCAL_EGL_NONE
60438:     };
60438: 
60438:     static EGLint pixmap_config_rgba[] = {
60438:         LOCAL_EGL_TEXTURE_TARGET,       LOCAL_EGL_TEXTURE_2D,
60438:         LOCAL_EGL_TEXTURE_FORMAT,       LOCAL_EGL_TEXTURE_RGBA,
60438:         LOCAL_EGL_NONE
60438:     };
60438: 
60438:     EGLSurface surface = nsnull;
60438:     if (aConfig && *aConfig) {
60438:         if (opaque)
60438:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), *aConfig,
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
60438:                                                        pixmap_config_rgb);
60438:         else
60438:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), *aConfig,
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
60438:                                                        pixmap_config_rgba);
60438: 
60438:         if (surface != EGL_NO_SURFACE)
60438:             return surface;
60438:     }
54904: 
54904:     EGLConfig configs[32];
54904:     int numConfigs = 32;
54904: 
60438:     static EGLint pixmap_config[] = {
54904:         LOCAL_EGL_SURFACE_TYPE,         LOCAL_EGL_PIXMAP_BIT,
54904:         LOCAL_EGL_RENDERABLE_TYPE,      LOCAL_EGL_OPENGL_ES2_BIT,
71551:         LOCAL_EGL_DEPTH_SIZE,           aDepth,
54904:         LOCAL_EGL_BIND_TO_TEXTURE_RGB,  LOCAL_EGL_TRUE,
54904:         LOCAL_EGL_NONE
54904:     };
54904: 
60438:     static EGLint pixmap_lock_config[] = {
60438:         LOCAL_EGL_SURFACE_TYPE,         LOCAL_EGL_PIXMAP_BIT | LOCAL_EGL_LOCK_SURFACE_BIT_KHR,
60438:         LOCAL_EGL_RENDERABLE_TYPE,      LOCAL_EGL_OPENGL_ES2_BIT,
71551:         LOCAL_EGL_DEPTH_SIZE,           aDepth,
60438:         LOCAL_EGL_BIND_TO_TEXTURE_RGB,  LOCAL_EGL_TRUE,
54904:         LOCAL_EGL_NONE
54904:     };
54904: 
60438:     if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(),
60438:                                    sEGLLibrary.HasKHRLockSurface() ?
60438:                                        pixmap_lock_config : pixmap_config,
54904:                                    configs, numConfigs, &numConfigs))
54904:         return nsnull;
54904: 
54904:     if (numConfigs == 0)
54904:         return nsnull;
54904: 
54904:     int i = 0;
54904:     for (i = 0; i < numConfigs; ++i) {
54904:         if (opaque)
54904:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), configs[i],
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
54904:                                                        pixmap_config_rgb);
54904:         else
54904:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), configs[i],
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
54904:                                                        pixmap_config_rgba);
54904: 
54904:         if (surface != EGL_NO_SURFACE)
54904:             break;
54904:     }
54904: 
54904:     if (!surface) {
54904:         return nsnull;
54904:     }
54904: 
60438:     if (aConfig)
60438:         *aConfig = configs[i];
54904: 
60438:     return surface;
54904: }
54904: #endif
54904: 
47908: already_AddRefed<GLContextEGL>
47908: GLContextEGL::CreateEGLPixmapOffscreenContext(const gfxIntSize& aSize,
71551:                                               const ContextFormat& aFormat,
71551:                                               PRBool aShare)
47908: {
47908:     gfxASurface *thebesSurface = nsnull;
47908:     EGLNativePixmapType pixmap = 0;
47908: 
47908: #ifdef MOZ_X11
47908:     nsRefPtr<gfxXlibSurface> xsurface =
47908:         gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()),
47908:                                gfxXlibSurface::FindRenderFormat(DefaultXDisplay(),
47908:                                                                 gfxASurface::ImageFormatRGB24),
71551:                                gUseBackingSurface ? aSize : gfxIntSize(16, 16));
60438: 
60438:     // XSync required after gfxXlibSurface::Create, otherwise EGL will fail with BadDrawable error
60438:     XSync(DefaultXDisplay(), False);
47908:     if (xsurface->CairoStatus() != 0)
43426:         return nsnull;
43426: 
47908:     thebesSurface = xsurface;
77137:     pixmap = (EGLNativePixmapType)xsurface->XDrawable();
47908: #endif
47908: 
47908:     if (!pixmap) {
47908:         return nsnull;
47908:     }
47908: 
60090:     EGLSurface surface = 0;
47908:     EGLConfig config = 0;
47908: 
54904: #ifdef MOZ_X11
71551:     int depth = gfxUtils::ImageFormatToDepth(gfxPlatform::GetPlatform()->GetOffscreenFormat());
71551:     surface = CreateEGLSurfaceForXSurface(thebesSurface, &config, gUseBackingSurface ? depth : 0);
54904: #endif
54904:     if (!config) {
47908:         return nsnull;
47908:     }
47908: 
71551:     GLContextEGL *shareContext = aShare ? GetGlobalContextEGL() : nsnull;
47908: 
71551:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateGLContext(aFormat,
71551:                                       surface,
47908:                                       config,
71551:                                       shareContext,
47908:                                       PR_TRUE);
47908: 
47908:     glContext->HoldSurface(thebesSurface);
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: // Under EGL, if we're under X11, then we have to create a Pixmap
47908: // because Maemo's EGL implementation doesn't support pbuffers at all
47908: // for some reason.  On Android, pbuffers are supported fine, though
47908: // often without the ability to texture from them directly.
47908: already_AddRefed<GLContext>
47908: GLContextProviderEGL::CreateOffscreen(const gfxIntSize& aSize,
47908:                                       const ContextFormat& aFormat)
47908: {
47908:     if (!sEGLLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
60089: #if defined(ANDROID) || defined(XP_WIN)
47908:     return GLContextEGL::CreateEGLPBufferOffscreenContext(aSize, aFormat);
74436: #elif defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:   return GLContextEGL::CreateBasicEGLPixmapOffscreenContext(aSize, aFormat);
47908: #elif defined(MOZ_X11)
71551:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateEGLPixmapOffscreenContext(aSize, aFormat, PR_TRUE);
71551: 
71551:     if (!glContext) {
71551:         return nsnull;
71551:     }
71551:     if (!glContext->GetSharedContext()) {
71551:         // no point in returning anything if sharing failed, we can't
71551:         // render from this
71551:         return nsnull;
71551:     }
71551:     if (!gUseBackingSurface && !glContext->ResizeOffscreenFBO(aSize)) {
71551:         // we weren't able to create the initial
71551:         // offscreen FBO, so this is dead
71551:         return nsnull;
71551:     }
71551:     return glContext.forget();
47908: #else
47908:     return nsnull;
47908: #endif
43426: }
43426: 
54904: static ContextFormat
54904: ContentTypeToGLFormat(gfxASurface::gfxContentType aCType)
54904: {
54904:     switch (aCType) {
54904:         case gfxASurface::CONTENT_COLOR_ALPHA:
54904:             return ContextFormat::BasicRGBA32;
54904:         case gfxASurface::CONTENT_COLOR:
54904: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
54904:             return ContextFormat::BasicRGB16_565;
54904: #else
54904:             return ContextFormat::BasicRGB24;
54904: #endif
54904:         default:
54904:             break;
54904:     }
54904:     return ContextFormat::BasicRGBA32;
54904: }
54904: 
44173: already_AddRefed<GLContext>
47907: GLContextProviderEGL::CreateForNativePixmapSurface(gfxASurface* aSurface)
44173: {
44173:     if (!sEGLLibrary.EnsureInitialized())
44173:         return nsnull;
44173: 
44173: #ifdef MOZ_X11
72361:     EGLSurface surface = nsnull;
72361:     EGLConfig config = nsnull;
72361: 
44173:     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
44173:         // Not implemented
44173:         return nsnull;
44173:     }
44173: 
60438:     surface = CreateEGLSurfaceForXSurface(aSurface, &config);
54904:     if (!config) {
44173:         return nsnull;
44173:     }
44173: 
71551:     GLContextEGL *shareContext = GetGlobalContextEGL();
71551:     gfxXlibSurface* xsurface = static_cast<gfxXlibSurface*>(aSurface);
44173: 
44173:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateGLContext(DepthToGLFormat(xsurface->XRenderFormat()->depth),
71551:                                       surface, config, shareContext, PR_FALSE);
71551: 
54904:     glContext->HoldSurface(aSurface);
44173: 
44173:     return glContext.forget().get();
44173: #else
44173:     // Not implemented
44173:     return nsnull;
44173: #endif
44173: }
44173: 
47908: static nsRefPtr<GLContext> gGlobalContext;
47908: 
47908: GLContext *
47908: GLContextProviderEGL::GetGlobalContext()
47908: {
47908:     static bool triedToCreateContext = false;
47908:     if (!triedToCreateContext && !gGlobalContext) {
47908:         triedToCreateContext = true;
71551:         gGlobalContext =
71551:             GLContextEGL::CreateEGLPixmapOffscreenContext(gfxIntSize(16, 16),
71551:                                                           ContextFormat(ContextFormat::BasicRGB24),
71551:                                                           PR_FALSE);
49071:         if (gGlobalContext)
49071:             gGlobalContext->SetIsGlobalSharedContext(PR_TRUE);
47908:     }
47908: 
47908:     return gGlobalContext;
47908: }
47908: 
47967: void
47967: GLContextProviderEGL::Shutdown()
47967: {
54672:     gGlobalContext = nsnull;
47967: }
47967: 
74436: //------------------------------------------------------------------------------
74436: // The following methods exist to support an accelerated WebGL XRender composite
74436: // path for BasicLayers. This is a potentially temporary change that can be
74436: // removed when performance of GL layers is superior on mobile linux platforms.
74436: //------------------------------------------------------------------------------
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436: 
74436: EGLSurface
74436: CreateBasicEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig)
74436: {
74436:   gfxXlibSurface* xsurface = static_cast<gfxXlibSurface*>(aSurface);
74436: 
74436:   PRBool opaque =
74436:     aSurface->GetContentType() == gfxASurface::CONTENT_COLOR;
74436: 
74436:   EGLSurface surface = nsnull;
74436:   if (aConfig && *aConfig) {
74436:     surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), *aConfig,
74436:                                                xsurface->XDrawable(),
74436:                                                0);
74436: 
74436:     if (surface != EGL_NO_SURFACE)
74436:       return surface;
74436:   }
74436: 
74436:   EGLConfig configs[32];
74436:   int numConfigs = 32;
74436: 
74436:   static EGLint pixmap_config[] = {
74436:       LOCAL_EGL_SURFACE_TYPE,         LOCAL_EGL_PIXMAP_BIT,
74436:       LOCAL_EGL_RENDERABLE_TYPE,      LOCAL_EGL_OPENGL_ES2_BIT,
74436:       0x30E2, 0x30E3,
74436:       LOCAL_EGL_DEPTH_SIZE,           16,
74436:       LOCAL_EGL_NONE
74436:   };
74436: 
74436:   if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(),
74436:                                  pixmap_config,
74436:                                  configs, numConfigs, &numConfigs))
74436:       return nsnull;
74436: 
74436:   if (numConfigs == 0)
74436:       return nsnull;
74436: 
74436:   int i = 0;
74436:   for (i = 0; i < numConfigs; ++i) {
74436:     surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), configs[i],
74436:                                                xsurface->XDrawable(),
74436:                                                0);
74436: 
74436:     if (surface != EGL_NO_SURFACE)
74436:       break;
74436:   }
74436: 
74436:   if (!surface) {
74436:     return nsnull;
74436:   }
74436: 
74436:   if (aConfig)
74436:   {
74436:     *aConfig = configs[i];
74436:   }
74436: 
74436:   return surface;
74436: }
74436: 
74436: already_AddRefed<GLContextEGL>
74436: GLContextEGL::CreateBasicEGLPixmapOffscreenContext(const gfxIntSize& aSize,
74436:                                               const ContextFormat& aFormat)
74436: {
74436:   gfxASurface *thebesSurface = nsnull;
74436:   EGLNativePixmapType pixmap = 0;
74436: 
74436:   XRenderPictFormat* format = gfxXlibSurface::FindRenderFormat(DefaultXDisplay(), gfxASurface::ImageFormatARGB32);
74436: 
74436:   nsRefPtr<gfxXlibSurface> xsurface =
74436:     gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()), format, aSize);
74436: 
74436:   // XSync required after gfxXlibSurface::Create, otherwise EGL will fail with BadDrawable error
74436:   XSync(DefaultXDisplay(), False);
74436:   if (xsurface->CairoStatus() != 0)
74436:   {
74436:     return nsnull;
74436:   }
74436: 
74436:   thebesSurface = xsurface;
74436: 
74436:   pixmap = xsurface->XDrawable();
74436: 
74436:   if (!pixmap) {
74436:     return nsnull;
74436:   }
74436: 
74436:   EGLSurface surface = 0;
74436:   EGLConfig config = 0;
74436: 
74436:   surface = CreateBasicEGLSurfaceForXSurface(xsurface, &config);
74436: 
74436:   if (!config) {
74436:     return nsnull;
74436:   }
74436: 
74436:   EGLint cxattribs[] = {
74436:     LOCAL_EGL_CONTEXT_CLIENT_VERSION, 2,
74436:     LOCAL_EGL_NONE
74436:   };
74436: 
74436:   EGLContext context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
74436:                                                   config,
74436:                                                   EGL_NO_CONTEXT,
74436:                                                   cxattribs);
74436:   if (!context) {
74436:     sEGLLibrary.fDestroySurface(EGL_DISPLAY(), surface);
74436:     return nsnull;
74436:   }
74436: 
74436:   nsRefPtr<GLContextEGL> glContext = new GLContextEGL(aFormat, nsnull,
74436:                                                       config, surface, context,
74436:                                                       PR_TRUE);
74436: 
74436:   if (!glContext->Init())
74436:   {
74436:     return nsnull;
74436:   }
74436: 
74436:   glContext->HoldSurface(thebesSurface);
74436: 
74436:   return glContext.forget();
74436: }
74436: 
74436: PRBool GLContextEGL::ResizeOffscreenPixmapSurface(const gfxIntSize& aNewSize)
74436: {
74436:   gfxASurface *thebesSurface = nsnull;
74436:   EGLNativePixmapType pixmap = 0;
74436: 
74436:   XRenderPictFormat* format = gfxXlibSurface::FindRenderFormat(DefaultXDisplay(), gfxASurface::ImageFormatARGB32);
74436: 
74436:   nsRefPtr<gfxXlibSurface> xsurface =
74436:     gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()),
74436:                            format,
74436:                            aNewSize);
74436: 
74436:   // XSync required after gfxXlibSurface::Create, otherwise EGL will fail with BadDrawable error
74436:   XSync(DefaultXDisplay(), False);
74436:   if (xsurface->CairoStatus() != 0)
74436:     return nsnull;
74436: 
74436:   thebesSurface = xsurface;
74436: 
74436:   pixmap = xsurface->XDrawable();
74436: 
74436:   if (!pixmap) {
74436:     return nsnull;
74436:   }
74436: 
74436:   EGLSurface surface = 0;
74436:   EGLConfig config = 0;
74436:   surface = CreateBasicEGLSurfaceForXSurface(xsurface, &config);
74436:   if (!surface) {
74436:     NS_WARNING("Failed to resize pbuffer");
74436:     return nsnull;
74436:   }
74436: 
74436:   sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
74436: 
74436:   mSurface = surface;
74436:   HoldSurface(thebesSurface);
74436:   SetOffscreenSize(aNewSize, aNewSize);
74436:   MakeCurrent(PR_TRUE);
74436: 
74436:   return PR_TRUE;
74436: }
74436: 
74436: #endif
74436: 
43426: } /* namespace gl */
43426: } /* namespace mozilla */
43426: 
