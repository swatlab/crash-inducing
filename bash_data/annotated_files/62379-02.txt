52963: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52963:  * vim: set ts=4 sw=4 et tw=99:
52963:  *
52963:  * ***** BEGIN LICENSE BLOCK *****
52963:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52963:  *
52963:  * The contents of this file are subject to the Mozilla Public License Version
52963:  * 1.1 (the "License"); you may not use this file except in compliance with
52963:  * the License. You may obtain a copy of the License at
52963:  * http://www.mozilla.org/MPL/
52963:  *
52963:  * Software distributed under the License is distributed on an "AS IS" basis,
52963:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52963:  * for the specific language governing rights and limitations under the
52963:  * License.
52963:  *
52963:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52963:  * May 28, 2008.
52963:  *
52963:  * The Initial Developer of the Original Code is
52963:  *   Brendan Eich <brendan@mozilla.org>
52963:  *
52963:  * Contributor(s):
52963:  *   David Anderson <danderson@mozilla.com>
52963:  *   David Mandelin <dmandelin@mozilla.com>
52963:  *   Sean Stangl    <sstangl@mozilla.com>
52963:  *
52963:  * Alternatively, the contents of this file may be used under the terms of
52963:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52963:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52963:  * in which case the provisions of the GPL or the LGPL are applicable instead
52963:  * of those above. If you wish to allow use of your version of this file only
52963:  * under the terms of either the GPL or the LGPL, and not to allow others to
52963:  * use your version of this file under the terms of the MPL, indicate your
52963:  * decision by deleting the provisions above and replace them with the notice
52963:  * and other provisions required by the GPL or the LGPL. If you do not delete
52963:  * the provisions above, a recipient may use your version of this file under
52963:  * the terms of any one of the MPL, the GPL or the LGPL.
52963:  *
52963:  * ***** END LICENSE BLOCK ***** */
52963: #include "jsbool.h"
52963: #include "jslibmath.h"
52963: #include "jsnum.h"
52963: #include "methodjit/MethodJIT.h"
52963: #include "methodjit/Compiler.h"
52963: #include "methodjit/StubCalls.h"
52963: #include "methodjit/FrameState-inl.h"
52963: 
52963: using namespace js;
52963: using namespace js::mjit;
53156: using namespace JSC;
52963: 
53152: typedef JSC::MacroAssembler::FPRegisterID FPRegisterID;
53152: 
53318: bool
53318: mjit::Compiler::tryBinaryConstantFold(JSContext *cx, FrameState &frame, JSOp op,
53318:                                       FrameEntry *lhs, FrameEntry *rhs)
52963: {
52963:     if (!lhs->isConstant() || !rhs->isConstant())
52963:         return false;
52963: 
52963:     const Value &L = lhs->getValue();
52963:     const Value &R = rhs->getValue();
52963: 
52963:     if (!L.isPrimitive() || !R.isPrimitive() ||
52963:         (op == JSOP_ADD && (L.isString() || R.isString()))) {
52963:         return false;
52963:     }
52963: 
53318:     bool needInt;
53318:     switch (op) {
53318:       case JSOP_ADD:
53318:       case JSOP_SUB:
53318:       case JSOP_MUL:
53318:       case JSOP_DIV:
58069:         needInt = false;
58069:         break;
58069: 
53318:       case JSOP_MOD:
58069:         needInt = (L.isInt32() && R.isInt32() &&
58069:                    L.toInt32() >= 0 && R.toInt32() > 0);
53318:         break;
53318: 
53318:       case JSOP_RSH:
53318:         needInt = true;
53318:         break;
53318: 
53318:       default:
53318:         JS_NOT_REACHED("NYI");
53318:         needInt = false; /* Silence compiler warning. */
53318:         break;
53318:     }
53318: 
53318:     double dL = 0, dR = 0;
53320:     int32_t nL = 0, nR = 0;
53318:     /*
53318:      * We don't need to check for conversion failure, since primitive conversion
53318:      * is infallible.
53318:      */
53318:     if (needInt) {
53318:         ValueToECMAInt32(cx, L, &nL);
53318:         ValueToECMAInt32(cx, R, &nR);
53318:     } else {
52963:         ValueToNumber(cx, L, &dL);
52963:         ValueToNumber(cx, R, &dR);
53318:     }
52963: 
52963:     switch (op) {
52963:       case JSOP_ADD:
52963:         dL += dR;
52963:         break;
52963:       case JSOP_SUB:
52963:         dL -= dR;
52963:         break;
52963:       case JSOP_MUL:
52963:         dL *= dR;
52963:         break;
52963:       case JSOP_DIV:
52963:         if (dR == 0) {
52963: #ifdef XP_WIN
52963:             if (JSDOUBLE_IS_NaN(dR))
52963:                 dL = js_NaN;
52963:             else
52963: #endif
52963:             if (dL == 0 || JSDOUBLE_IS_NaN(dL))
52963:                 dL = js_NaN;
52963:             else if (JSDOUBLE_IS_NEG(dL) != JSDOUBLE_IS_NEG(dR))
53081:                 dL = cx->runtime->negativeInfinityValue.toDouble();
52963:             else
53081:                 dL = cx->runtime->positiveInfinityValue.toDouble();
52963:         } else {
52963:             dL /= dR;
52963:         }
52963:         break;
52963:       case JSOP_MOD:
58069:         if (needInt)
58069:             nL %= nR;
58069:         else if (dR == 0)
52963:             dL = js_NaN;
52963:         else
58069:             dL = js_fmod(dL, dR);
52963:         break;
52963: 
53318:       case JSOP_RSH:
53318:         nL >>= (nR & 31);
53318:         break;
53318: 
52963:       default:
52963:         JS_NOT_REACHED("NYI");
52963:         break;
52963:     }
52963: 
52963:     Value v;
53318:     if (needInt)
53318:         v.setInt32(nL);
53318:     else
52963:         v.setNumber(dL);
52963:     frame.popn(2);
52963:     frame.push(v);
52963: 
52963:     return true;
52963: }
52963: 
52963: void
52963: mjit::Compiler::slowLoadConstantDouble(Assembler &masm,
52963:                                        FrameEntry *fe, FPRegisterID fpreg)
52963: {
53183:     DoublePatch patch;
53025:     if (fe->getKnownType() == JSVAL_TYPE_INT32)
53183:         patch.d = (double)fe->getValue().toInt32();
52963:     else
53183:         patch.d = fe->getValue().toDouble();
53183:     patch.label = masm.loadDouble(NULL, fpreg);
53183:     patch.ool = &masm != &this->masm;
53183:     JS_ASSERT_IF(patch.ool, &masm == &stubcc.masm);
53183:     doubleList.append(patch);
52963: }
52963: 
52963: void
52963: mjit::Compiler::maybeJumpIfNotInt32(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                                     MaybeRegisterID &mreg)
52963: {
52963:     if (!fe->isTypeKnown()) {
52963:         if (mreg.isSet())
53152:             mj.setJump(masm.testInt32(Assembler::NotEqual, mreg.reg()));
52963:         else
52963:             mj.setJump(masm.testInt32(Assembler::NotEqual, frame.addressOf(fe)));
53025:     } else if (fe->getKnownType() != JSVAL_TYPE_INT32) {
52963:         mj.setJump(masm.jump());
52963:     }
52963: }
52963: 
52963: void
52963: mjit::Compiler::maybeJumpIfNotDouble(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                                     MaybeRegisterID &mreg)
52963: {
52963:     if (!fe->isTypeKnown()) {
52963:         if (mreg.isSet())
53152:             mj.setJump(masm.testDouble(Assembler::NotEqual, mreg.reg()));
52963:         else
52963:             mj.setJump(masm.testDouble(Assembler::NotEqual, frame.addressOf(fe)));
53025:     } else if (fe->getKnownType() != JSVAL_TYPE_DOUBLE) {
52963:         mj.setJump(masm.jump());
52963:     }
52963: }
52963: 
52963: void
52963: mjit::Compiler::jsop_binary(JSOp op, VoidStub stub)
52963: {
52963:     FrameEntry *rhs = frame.peek(-1);
52963:     FrameEntry *lhs = frame.peek(-2);
52963: 
53318:     if (tryBinaryConstantFold(cx, frame, op, lhs, rhs))
52963:         return;
52963: 
52963:     /*
52963:      * Bail out if there are unhandled types or ops.
52963:      * This is temporary while ops are still being implemented.
52963:      */
52971:     if ((op == JSOP_MOD) ||
53025:         (lhs->isTypeKnown() && (lhs->getKnownType() > JSVAL_UPPER_INCL_TYPE_OF_NUMBER_SET)) ||
53025:         (rhs->isTypeKnown() && (rhs->getKnownType() > JSVAL_UPPER_INCL_TYPE_OF_NUMBER_SET)) 
52963: #if defined(JS_CPU_ARM)
52963:         /* ARM cannot detect integer overflow with multiplication. */
52963:         || op == JSOP_MUL
52963: #endif /* JS_CPU_ARM */
52963:     ) {
52963:         bool isStringResult = (op == JSOP_ADD) &&
53374:                               (lhs->isType(JSVAL_TYPE_STRING) ||
53374:                                rhs->isType(JSVAL_TYPE_STRING));
53325: 
53087:         prepareStubCall(Uses(2));
57766:         INLINE_STUBCALL(stub);
52963:         frame.popn(2);
52963:         if (isStringResult)
53025:             frame.pushSyncedType(JSVAL_TYPE_STRING);
52963:         else
52963:             frame.pushSynced();
52963:         return;
52963:     }
52963: 
52971:     /* Can do int math iff there is no double constant and the op is not division. */
52971:     bool canDoIntMath = op != JSOP_DIV &&
53025:                         !((rhs->isTypeKnown() && rhs->getKnownType() == JSVAL_TYPE_DOUBLE) ||
53025:                           (lhs->isTypeKnown() && lhs->getKnownType() == JSVAL_TYPE_DOUBLE));
52963: 
53152:     if (canDoIntMath)
53152:         jsop_binary_full(lhs, rhs, op, stub);
53152:     else
53152:         jsop_binary_double(lhs, rhs, op, stub);
53152: }
52963: 
53152: static void
53152: EmitDoubleOp(JSOp op, FPRegisterID fpRight, FPRegisterID fpLeft, Assembler &masm)
53152: {
53152:     switch (op) {
53152:       case JSOP_ADD:
53152:         masm.addDouble(fpRight, fpLeft);
53152:         break;
53152: 
53152:       case JSOP_SUB:
53152:         masm.subDouble(fpRight, fpLeft);
53152:         break;
53152: 
53152:       case JSOP_MUL:
53152:         masm.mulDouble(fpRight, fpLeft);
53152:         break;
53152: 
53152:       case JSOP_DIV:
53152:         masm.divDouble(fpRight, fpLeft);
53152:         break;
53152: 
53152:       default:
53152:         JS_NOT_REACHED("unrecognized binary op");
52963:     }
53152: }
52963: 
53277: mjit::MaybeJump
53152: mjit::Compiler::loadDouble(FrameEntry *fe, FPRegisterID fpReg)
53152: {
53152:     MaybeJump notNumber;
53152: 
53152:     if (fe->isConstant()) {
53152:         slowLoadConstantDouble(masm, fe, fpReg);
53152:     } else if (!fe->isTypeKnown()) {
53153:         frame.tempRegForType(fe);
53152:         Jump j = frame.testDouble(Assembler::Equal, fe);
53152:         notNumber = frame.testInt32(Assembler::NotEqual, fe);
53152:         frame.convertInt32ToDouble(masm, fe, fpReg);
53152:         Jump converted = masm.jump();
53152:         j.linkTo(masm.label(), &masm);
53229:         // CANDIDATE
53152:         frame.loadDouble(fe, fpReg, masm);
53152:         converted.linkTo(masm.label(), &masm);
53152:     } else if (fe->getKnownType() == JSVAL_TYPE_INT32) {
53153:         frame.tempRegForData(fe);
53152:         frame.convertInt32ToDouble(masm, fe, fpReg);
53152:     } else {
53152:         JS_ASSERT(fe->getKnownType() == JSVAL_TYPE_DOUBLE);
53152:         frame.loadDouble(fe, fpReg, masm);
52963:     }
52963: 
53152:     return notNumber;
52963: }
52963: 
52963: /*
53152:  * This function emits a single fast-path for handling numerical arithmetic.
53152:  * Unlike jsop_binary_full(), all integers are converted to doubles.
52963:  */
53152: void
53152: mjit::Compiler::jsop_binary_double(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub)
52963: {
53152:     FPRegisterID fpLeft = FPRegisters::First;
53152:     FPRegisterID fpRight = FPRegisters::Second;
52963: 
53152:     MaybeJump lhsNotNumber = loadDouble(lhs, fpLeft);
53259:     if (lhsNotNumber.isSet())
53259:         stubcc.linkExit(lhsNotNumber.get(), Uses(2));
53152: 
53152:     MaybeJump rhsNotNumber;
53259:     if (frame.haveSameBacking(lhs, rhs)) {
53152:         masm.moveDouble(fpLeft, fpRight);
53259:     } else {
53152:         rhsNotNumber = loadDouble(rhs, fpRight);
53259:         if (rhsNotNumber.isSet())
53259:             stubcc.linkExit(rhsNotNumber.get(), Uses(2));
53259:     }
52963: 
53152:     EmitDoubleOp(op, fpRight, fpLeft, masm);
53349:     
53349:     MaybeJump done;
53349:     
53349:     /*
53349:      * Try to convert result to integer. Skip this for 1/x or -1/x, as the
53349:      * result is unlikely to fit in an int.
53349:      */
53349:     if (op == JSOP_DIV && !(lhs->isConstant() && lhs->isType(JSVAL_TYPE_INT32) &&
53349:         abs(lhs->getValue().toInt32()) == 1)) {
53349:         RegisterID reg = frame.allocReg();
53349:         JumpList isDouble;
53349:         masm.branchConvertDoubleToInt32(fpLeft, reg, isDouble, fpRight);
53349:         
54582:         masm.storeValueFromComponents(ImmType(JSVAL_TYPE_INT32), reg,
54582:                                       frame.addressOf(lhs));
53349:         
53349:         frame.freeReg(reg);
53349:         done.setJump(masm.jump());
53349:         isDouble.linkTo(masm.label(), &masm);
53349:     }
53349: 
53152:     masm.storeDouble(fpLeft, frame.addressOf(lhs));
52963: 
53349:     if (done.isSet())
53349:         done.getJump().linkTo(masm.label(), &masm);
53349: 
53259:     if (lhsNotNumber.isSet() || rhsNotNumber.isSet()) {
52963:         stubcc.leave();
57766:         OOL_STUBCALL(stub);
53259:     }
52963: 
52963:     frame.popn(2);
53153:     frame.pushNumber(MaybeRegisterID());
52963: 
53259:     if (lhsNotNumber.isSet() || rhsNotNumber.isSet())
53152:         stubcc.rejoin(Changes(1));
53152: }
53152: 
53152: /*
53152:  * Simpler version of jsop_binary_full() for when lhs == rhs.
53152:  */
53152: void
53152: mjit::Compiler::jsop_binary_full_simple(FrameEntry *fe, JSOp op, VoidStub stub)
53152: {
53152:     FrameEntry *lhs = frame.peek(-2);
53152: 
53152:     /* Easiest case: known double. Don't bother conversion back yet? */
53152:     if (fe->isTypeKnown() && fe->getKnownType() == JSVAL_TYPE_DOUBLE) {
53152:         loadDouble(fe, FPRegisters::First);
53152:         EmitDoubleOp(op, FPRegisters::First, FPRegisters::First, masm);
53152:         frame.popn(2);
53153:         frame.pushNumber(MaybeRegisterID());
53152:         return;
53152:     }
53152: 
53152:     /* Allocate all registers up-front. */
53152:     FrameState::BinaryAlloc regs;
53152:     frame.allocForSameBinary(fe, op, regs);
53152: 
53152:     MaybeJump notNumber;
53152:     MaybeJump doublePathDone;
53152:     if (!fe->isTypeKnown()) {
53152:         Jump notInt = masm.testInt32(Assembler::NotEqual, regs.lhsType.reg());
53152:         stubcc.linkExitDirect(notInt, stubcc.masm.label());
53152: 
53152:         notNumber = stubcc.masm.testDouble(Assembler::NotEqual, regs.lhsType.reg());
53152:         frame.loadDouble(fe, FPRegisters::First, stubcc.masm);
53152:         EmitDoubleOp(op, FPRegisters::First, FPRegisters::First, stubcc.masm);
53152: 
53152:         /* Force the double back to memory. */
53152:         Address result = frame.addressOf(lhs);
53152:         stubcc.masm.storeDouble(FPRegisters::First, result);
53152: 
53152:         /* Load the payload into the result reg so the rejoin is safe. */
53152:         stubcc.masm.loadPayload(result, regs.result);
53152: 
53152:         doublePathDone = stubcc.masm.jump();
53152:     }
53152: 
53152:     /* Okay - good to emit the integer fast-path. */
53152:     MaybeJump overflow;
53152:     switch (op) {
53152:       case JSOP_ADD:
53152:         overflow = masm.branchAdd32(Assembler::Overflow, regs.result, regs.result);
53152:         break;
53152: 
53152:       case JSOP_SUB:
53152:         overflow = masm.branchSub32(Assembler::Overflow, regs.result, regs.result);
53152:         break;
53152: 
53152: #if !defined(JS_CPU_ARM)
53152:       case JSOP_MUL:
53152:         overflow = masm.branchMul32(Assembler::Overflow, regs.result, regs.result);
53152:         break;
53152: #endif
53152: 
53152:       default:
53152:         JS_NOT_REACHED("unrecognized op");
53152:     }
53152:     
53152:     JS_ASSERT(overflow.isSet());
53152: 
53152:     /*
53152:      * Integer overflow path. Separate from the first double path, since we
53152:      * know never to try and convert back to integer.
53152:      */
53152:     MaybeJump overflowDone;
53152:     stubcc.linkExitDirect(overflow.get(), stubcc.masm.label());
53152:     {
53152:         if (regs.lhsNeedsRemat) {
53497:             Address address = masm.payloadOf(frame.addressForDataRemat(lhs));
53152:             stubcc.masm.convertInt32ToDouble(address, FPRegisters::First);
53152:         } else if (!lhs->isConstant()) {
53152:             stubcc.masm.convertInt32ToDouble(regs.lhsData.reg(), FPRegisters::First);
53152:         } else {
53152:             slowLoadConstantDouble(stubcc.masm, lhs, FPRegisters::First);
53152:         }
53152: 
53152:         EmitDoubleOp(op, FPRegisters::First, FPRegisters::First, stubcc.masm);
53152: 
53152:         Address address = frame.addressOf(lhs);
53152:         stubcc.masm.storeDouble(FPRegisters::First, address);
53152:         stubcc.masm.loadPayload(address, regs.result);
53152: 
53152:         overflowDone = stubcc.masm.jump();
53152:     }
53152: 
53152:     /* Slow paths funnel here. */
53152:     if (notNumber.isSet())
53152:         notNumber.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53152:     overflowDone.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53152: 
53194:     /* Slow call - use frame.sync to avoid erroneous jump repatching in stubcc. */
53194:     frame.sync(stubcc.masm, Uses(2));
53152:     stubcc.leave();
57766:     OOL_STUBCALL(stub);
53152: 
53152:     /* Finish up stack operations. */
53152:     frame.popn(2);
53181:     frame.pushNumber(regs.result, true);
53152: 
53152:     /* Merge back OOL double paths. */
53152:     if (doublePathDone.isSet())
53152:         stubcc.linkRejoin(doublePathDone.get());
53152:     stubcc.linkRejoin(overflowDone.get());
53152: 
53152:     stubcc.rejoin(Changes(1));
53152: }
53152: 
53152: /*
53152:  * This function emits multiple fast-paths for handling numerical arithmetic.
53152:  * Currently, it handles only ADD, SUB, and MUL, where both LHS and RHS are
53152:  * known not to be doubles.
53152:  *
53152:  * The control flow of the emitted code depends on which types are known.
53152:  * Given both types are unknown, the full spread looks like:
53152:  *
53152:  * Inline                              OOL
53152:  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
53152:  * Is LHS Int32?  ------ No -------->  Is LHS Double?  ----- No -------,
53152:  *                                     Sync LHS                        |
53152:  *                                     Load LHS into XMM1              |
53152:  *                                     Is RHS Double? ---- Yes --,     |
53152:  *                                       Is RHS Int32? ---- No --|-----|
53152:  *                                       Convert RHS into XMM0   |     |
53152:  *                                     Else  <-------------------'     |
53152:  *                                       Sync RHS                      |
53152:  *                                       Load RHS into XMM0            |
53152:  *                                     [Add,Sub,Mul] XMM0,XMM1         |
53152:  *                                     Jump ---------------------,     |
53152:  *                                                               |     |
53152:  * Is RHS Int32?  ------ No ------->   Is RHS Double? ----- No --|-----|
53152:  *                                     Sync RHS                  |     |
53152:  *                                     Load RHS into XMM0        |     |
53152:  *                                     Convert LHS into XMM1     |     |
53152:  *                                     [Add,Sub,Mul] XMM0,XMM1   |     |
53152:  *                                     Jump ---------------------|   Slow Call
53152:  *                                                               |
53152:  * [Add,Sub,Mul] RHS, LHS                                        |
53152:  * Overflow      ------ Yes ------->   Convert RHS into XMM0     |
53152:  *                                     Convert LHS into XMM1     |
53152:  *                                     [Add,Sub,Mul] XMM0,XMM1   |
53152:  *                                     Sync XMM1 to stack    <---'
53152:  *  <--------------------------------- Rejoin
53152:  */
53152: void
53152: mjit::Compiler::jsop_binary_full(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub)
53152: {
53152:     if (frame.haveSameBacking(lhs, rhs)) {
53152:         jsop_binary_full_simple(lhs, op, stub);
53152:         return;
53152:     }
53152: 
53152:     /* Allocate all registers up-front. */
53152:     FrameState::BinaryAlloc regs;
53152:     frame.allocForBinary(lhs, rhs, op, regs);
53152: 
53152:     /* Quick-test some invariants. */
53152:     JS_ASSERT_IF(lhs->isTypeKnown(), lhs->getKnownType() == JSVAL_TYPE_INT32);
53152:     JS_ASSERT_IF(rhs->isTypeKnown(), rhs->getKnownType() == JSVAL_TYPE_INT32);
53152: 
53152:     FPRegisterID fpLeft = FPRegisters::First;
53152:     FPRegisterID fpRight = FPRegisters::Second;
53152: 
53201:     MaybeJump lhsNotDouble, rhsNotNumber, lhsUnknownDone;
53201:     if (!lhs->isTypeKnown())
53201:         emitLeftDoublePath(lhs, rhs, regs, lhsNotDouble, rhsNotNumber, lhsUnknownDone);
53152: 
53152:     MaybeJump rhsNotNumber2;
53201:     if (!rhs->isTypeKnown())
53201:         emitRightDoublePath(lhs, rhs, regs, rhsNotNumber2);
53152: 
53152:     /* Perform the double addition. */
53152:     MaybeJump doublePathDone;
53152:     if (!rhs->isTypeKnown() || lhsUnknownDone.isSet()) {
53152:         /* If the LHS type was not known, link its path here. */
53152:         if (lhsUnknownDone.isSet())
53152:             lhsUnknownDone.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53152:         
53152:         /* Perform the double operation. */
53152:         EmitDoubleOp(op, fpRight, fpLeft, stubcc.masm);
53152: 
53152:         /* Force the double back to memory. */
53152:         Address result = frame.addressOf(lhs);
53152:         stubcc.masm.storeDouble(fpLeft, result);
53152: 
53152:         /* Load the payload into the result reg so the rejoin is safe. */
53152:         stubcc.masm.loadPayload(result, regs.result);
53152: 
53152:         /* We'll link this back up later, at the bottom of the op. */
53152:         doublePathDone = stubcc.masm.jump();
53152:     }
53152: 
53152:     /* Time to do the integer path. Figure out the immutable side. */
53152:     int32 value = 0;
53152:     JSOp origOp = op;
53152:     MaybeRegisterID reg;
57809:     MaybeJump preOverflow;
53152:     if (!regs.resultHasRhs) {
53152:         if (!regs.rhsData.isSet())
53152:             value = rhs->getValue().toInt32();
53152:         else
53152:             reg = regs.rhsData.reg();
53152:     } else {
53152:         if (!regs.lhsData.isSet())
53152:             value = lhs->getValue().toInt32();
53152:         else
53152:             reg = regs.lhsData.reg();
53152:         if (op == JSOP_SUB) {
57809:             // If the RHS is 0x80000000, the smallest negative value, neg does
57809:             // not work. Guard against this and treat it as an overflow.
57809:             preOverflow = masm.branch32(Assembler::Equal, regs.result, Imm32(0x80000000));
53152:             masm.neg32(regs.result);
53152:             op = JSOP_ADD;
53152:         }
53152:     }
53152: 
53152:     /* Okay - good to emit the integer fast-path. */
53432:     MaybeJump overflow, negZeroDone;
53152:     switch (op) {
53152:       case JSOP_ADD:
53152:         if (reg.isSet())
53152:             overflow = masm.branchAdd32(Assembler::Overflow, reg.reg(), regs.result);
53152:         else
53152:             overflow = masm.branchAdd32(Assembler::Overflow, Imm32(value), regs.result);
53152:         break;
53152: 
53152:       case JSOP_SUB:
53152:         if (reg.isSet())
53152:             overflow = masm.branchSub32(Assembler::Overflow, reg.reg(), regs.result);
53152:         else
53152:             overflow = masm.branchSub32(Assembler::Overflow, Imm32(value), regs.result);
53152:         break;
53152: 
53152: #if !defined(JS_CPU_ARM)
53152:       case JSOP_MUL:
53432:       {
53152:         JS_ASSERT(reg.isSet());
53432:         
53432:         MaybeJump storeNegZero;
53432:         bool maybeNegZero = true;
53432:         bool hasConstant = (lhs->isConstant() || rhs->isConstant());
53432:         
53432:         if (hasConstant) {
53432:             value = (lhs->isConstant() ? lhs : rhs)->getValue().toInt32();
53432:             RegisterID nonConstReg = lhs->isConstant() ? regs.rhsData.reg() : regs.lhsData.reg();
53432: 
53432:             if (value > 0)
53432:                 maybeNegZero = false;
53432:             else if (value < 0)
53432:                 storeNegZero = masm.branchTest32(Assembler::Zero, nonConstReg);
53432:             else
53432:                 storeNegZero = masm.branch32(Assembler::LessThan, nonConstReg, Imm32(0));
53432:         }
53152:         overflow = masm.branchMul32(Assembler::Overflow, reg.reg(), regs.result);
53432: 
53432:         if (maybeNegZero) {
53432:             if (!hasConstant) {
53432:                 Jump isZero = masm.branchTest32(Assembler::Zero, regs.result);
53432:                 stubcc.linkExitDirect(isZero, stubcc.masm.label());
53432:                 
53432:                 /* Restore original value. */
53432:                 if (regs.resultHasRhs) {
53432:                     if (regs.rhsNeedsRemat)
53497:                         stubcc.masm.loadPayload(frame.addressForDataRemat(rhs), regs.result);
53432:                     else
53432:                         stubcc.masm.move(regs.rhsData.reg(), regs.result);
53432:                 } else {
53432:                     if (regs.lhsNeedsRemat)
53497:                         stubcc.masm.loadPayload(frame.addressForDataRemat(lhs), regs.result);
53432:                     else
53432:                         stubcc.masm.move(regs.lhsData.reg(), regs.result);
53432:                 }
53432:                 storeNegZero = stubcc.masm.branchOr32(Assembler::Signed, reg.reg(), regs.result);
53432:                 stubcc.masm.xor32(regs.result, regs.result);
53432:                 stubcc.crossJump(stubcc.masm.jump(), masm.label());
53432:                 storeNegZero.getJump().linkTo(stubcc.masm.label(), &stubcc.masm);
53432:             } else {
53432:                 JS_ASSERT(storeNegZero.isSet());
53432:                 stubcc.linkExitDirect(storeNegZero.get(), stubcc.masm.label());
53432:             }
53432:             stubcc.masm.storeValue(DoubleValue(-0.0), frame.addressOf(lhs));
53432:             stubcc.masm.loadPayload(frame.addressOf(lhs), regs.result);
53432:             negZeroDone = stubcc.masm.jump();
53432:         }
53152:         break;
53432:       }
53152: #endif
53152: 
53152:       default:
53152:         JS_NOT_REACHED("unrecognized op");
53152:     }
53152:     op = origOp;
53152:     
53152:     JS_ASSERT(overflow.isSet());
53152: 
53152:     /*
53152:      * Integer overflow path. Separate from the first double path, since we
53152:      * know never to try and convert back to integer.
53152:      */
53152:     MaybeJump overflowDone;
57809:     if (preOverflow.isSet())
57809:         stubcc.linkExitDirect(preOverflow.get(), stubcc.masm.label());
53152:     stubcc.linkExitDirect(overflow.get(), stubcc.masm.label());
53152:     {
53152:         if (regs.lhsNeedsRemat) {
53497:             Address address = masm.payloadOf(frame.addressForDataRemat(lhs));
53152:             stubcc.masm.convertInt32ToDouble(address, fpLeft);
53152:         } else if (!lhs->isConstant()) {
53152:             stubcc.masm.convertInt32ToDouble(regs.lhsData.reg(), fpLeft);
53152:         } else {
53152:             slowLoadConstantDouble(stubcc.masm, lhs, fpLeft);
53152:         }
53152: 
53152:         if (regs.rhsNeedsRemat) {
53497:             Address address = masm.payloadOf(frame.addressForDataRemat(rhs));
53152:             stubcc.masm.convertInt32ToDouble(address, fpRight);
53152:         } else if (!rhs->isConstant()) {
53152:             stubcc.masm.convertInt32ToDouble(regs.rhsData.reg(), fpRight);
53152:         } else {
53152:             slowLoadConstantDouble(stubcc.masm, rhs, fpRight);
53152:         }
53152: 
53152:         EmitDoubleOp(op, fpRight, fpLeft, stubcc.masm);
53152: 
53152:         Address address = frame.addressOf(lhs);
53152:         stubcc.masm.storeDouble(fpLeft, address);
53152:         stubcc.masm.loadPayload(address, regs.result);
53152: 
53152:         overflowDone = stubcc.masm.jump();
53152:     }
53152: 
53152:     /* The register allocator creates at most one temporary. */
53152:     if (regs.extraFree.isSet())
53152:         frame.freeReg(regs.extraFree.reg());
53152: 
53152:     /* Slow paths funnel here. */
53152:     if (lhsNotDouble.isSet()) {
53152:         lhsNotDouble.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53152:         if (rhsNotNumber.isSet())
53152:             rhsNotNumber.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53152:     }
53152:     if (rhsNotNumber2.isSet())
53152:         rhsNotNumber2.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53152: 
53194:     /* Slow call - use frame.sync to avoid erroneous jump repatching in stubcc. */
53194:     frame.sync(stubcc.masm, Uses(2));
53152:     stubcc.leave();
57766:     OOL_STUBCALL(stub);
53152: 
53152:     /* Finish up stack operations. */
53152:     frame.popn(2);
53181:     frame.pushNumber(regs.result, true);
53152: 
53152:     /* Merge back OOL double paths. */
53152:     if (doublePathDone.isSet())
53152:         stubcc.linkRejoin(doublePathDone.get());
53432:     if (negZeroDone.isSet())
53432:         stubcc.linkRejoin(negZeroDone.get());
53152:     stubcc.linkRejoin(overflowDone.get());
53152: 
53088:     stubcc.rejoin(Changes(1));
52963: }
52963: 
53015: static const uint64 DoubleNegMask = 0x8000000000000000ULL;
52972: 
52969: void
52969: mjit::Compiler::jsop_neg()
52969: {
52969:     FrameEntry *fe = frame.peek(-1);
52969: 
53025:     if (fe->isTypeKnown() && fe->getKnownType() > JSVAL_UPPER_INCL_TYPE_OF_NUMBER_SET) {
53087:         prepareStubCall(Uses(1));
57766:         INLINE_STUBCALL(stubs::Neg);
52969:         frame.pop();
52969:         frame.pushSynced();
52969:         return;
52969:     }
52969: 
52969:     JS_ASSERT(!fe->isConstant());
52969: 
53389:     /* Load type information into register. */
52969:     MaybeRegisterID feTypeReg;
53014:     if (!fe->isTypeKnown() && !frame.shouldAvoidTypeRemat(fe)) {
52969:         /* Safe because only one type is loaded. */
52969:         feTypeReg.setReg(frame.tempRegForType(fe));
52972: 
52969:         /* Don't get clobbered by copyDataIntoReg(). */
53152:         frame.pinReg(feTypeReg.reg());
52969:     }
52969: 
52969:     RegisterID reg = frame.copyDataIntoReg(masm, fe);
53088:     Label feSyncTarget = stubcc.syncExitAndJump(Uses(1));
52969: 
52969:     /* Try a double path (inline). */
52969:     MaybeJump jmpNotDbl;
52969:     {
52969:         maybeJumpIfNotDouble(masm, jmpNotDbl, fe, feTypeReg);
52969: 
52969:         FPRegisterID fpreg = frame.copyEntryIntoFPReg(fe, FPRegisters::First);
53030: 
53209: #if defined JS_CPU_X86 || defined JS_CPU_X64
52969:         masm.loadDouble(&DoubleNegMask, FPRegisters::Second);
52969:         masm.xorDouble(FPRegisters::Second, fpreg);
53162: #elif defined JS_CPU_ARM
53191:         masm.negDouble(fpreg, fpreg);
53030: #endif
52969: 
52969:         /* Overwrite pushed frame's memory (before push). */
52969:         masm.storeDouble(fpreg, frame.addressOf(fe));
52969:     }
52969: 
52969:     /* Try an integer path (out-of-line). */
52969:     MaybeJump jmpNotInt;
52969:     MaybeJump jmpIntZero;
53208:     MaybeJump jmpMinInt;
52969:     MaybeJump jmpIntRejoin;
52969:     Label lblIntPath = stubcc.masm.label();
52969:     {
52969:         maybeJumpIfNotInt32(stubcc.masm, jmpNotInt, fe, feTypeReg);
52969: 
52969:         /* 0 (int) -> -0 (double). */
52969:         jmpIntZero.setJump(stubcc.masm.branch32(Assembler::Equal, reg, Imm32(0)));
53208:         /* int32 negation on (-2147483648) yields (-2147483648). */
53208:         jmpMinInt.setJump(stubcc.masm.branch32(Assembler::Equal, reg, Imm32(1 << 31)));
52969: 
52969:         stubcc.masm.neg32(reg);
52969: 
52969:         /* Sync back with double path. */
54582:         stubcc.masm.storeValueFromComponents(ImmType(JSVAL_TYPE_INT32), reg,
54582:                                              frame.addressOf(fe));
52969: 
52969:         jmpIntRejoin.setJump(stubcc.masm.jump());
52969:     }
52969: 
52972:     frame.freeReg(reg);
52969:     if (feTypeReg.isSet())
53152:         frame.unpinReg(feTypeReg.reg());
52969: 
52969:     stubcc.leave();
57766:     OOL_STUBCALL(stubs::Neg);
52969: 
52969:     frame.pop();
52969:     frame.pushSynced();
52969: 
52969:     /* Link jumps. */
52969:     if (jmpNotDbl.isSet())
52969:         stubcc.linkExitDirect(jmpNotDbl.getJump(), lblIntPath);
52969: 
52969:     if (jmpNotInt.isSet())
52969:         jmpNotInt.getJump().linkTo(feSyncTarget, &stubcc.masm);
52969:     if (jmpIntZero.isSet())
52969:         jmpIntZero.getJump().linkTo(feSyncTarget, &stubcc.masm);
53208:     if (jmpMinInt.isSet())
53208:         jmpMinInt.getJump().linkTo(feSyncTarget, &stubcc.masm);
52969:     if (jmpIntRejoin.isSet())
52969:         stubcc.crossJump(jmpIntRejoin.getJump(), masm.label());
52969: 
53088:     stubcc.rejoin(Changes(1));
52969: }
52969: 
53156: void
53156: mjit::Compiler::jsop_mod()
53156: {
53156: #if defined(JS_CPU_X86)
53156:     FrameEntry *lhs = frame.peek(-2);
53156:     FrameEntry *rhs = frame.peek(-1);
58069: 
58069:     if (tryBinaryConstantFold(cx, frame, JSOP_MOD, lhs, rhs))
58069:         return;
58069: 
53156:     if ((lhs->isTypeKnown() && lhs->getKnownType() != JSVAL_TYPE_INT32) ||
53156:         (rhs->isTypeKnown() && rhs->getKnownType() != JSVAL_TYPE_INT32))
53156: #endif
53156:     {
53156:         prepareStubCall(Uses(2));
57766:         INLINE_STUBCALL(stubs::Mod);
53156:         frame.popn(2);
53159:         frame.pushSynced();
53156:         return;
53156:     }
53156: 
53156: #if defined(JS_CPU_X86)
53156:     if (!lhs->isTypeKnown()) {
53156:         Jump j = frame.testInt32(Assembler::NotEqual, lhs);
53156:         stubcc.linkExit(j, Uses(2));
53156:     }
53156:     if (!rhs->isTypeKnown()) {
53156:         Jump j = frame.testInt32(Assembler::NotEqual, rhs);
53156:         stubcc.linkExit(j, Uses(2));
53156:     }
53156: 
53156:     /* LHS must be in EAX:EDX */
53156:     if (!lhs->isConstant()) {
53156:         frame.copyDataIntoReg(lhs, X86Registers::eax);
53156:     } else {
53156:         frame.takeReg(X86Registers::eax);
53156:         masm.move(Imm32(lhs->getValue().toInt32()), X86Registers::eax);
53156:     }
53156: 
53156:     /* Get RHS into anything but EDX - could avoid more spilling? */
53156:     MaybeRegisterID temp;
53156:     RegisterID rhsReg;
53156:     if (!rhs->isConstant()) {
53156:         uint32 mask = Registers::AvailRegs & ~Registers::maskReg(X86Registers::edx);
53156:         rhsReg = frame.tempRegInMaskForData(rhs, mask);
53156:         JS_ASSERT(rhsReg != X86Registers::edx);
53156:     } else {
53156:         rhsReg = frame.allocReg(Registers::AvailRegs & ~Registers::maskReg(X86Registers::edx));
53156:         JS_ASSERT(rhsReg != X86Registers::edx);
53156:         masm.move(Imm32(rhs->getValue().toInt32()), rhsReg);
53156:         temp = rhsReg;
53156:     }
53156:     frame.takeReg(X86Registers::edx);
53156:     frame.freeReg(X86Registers::eax);
53156: 
53156:     if (temp.isSet())
53156:         frame.freeReg(temp.reg());
53156: 
53156:     bool slowPath = !(lhs->isTypeKnown() && rhs->isTypeKnown());
53156:     if (rhs->isConstant() && rhs->getValue().toInt32() != 0) {
53156:         if (rhs->getValue().toInt32() == -1) {
53156:             /* Guard against -1 / INT_MIN which throws a hardware exception. */
53156:             Jump checkDivExc = masm.branch32(Assembler::Equal, X86Registers::eax,
53156:                                              Imm32(0x80000000));
53156:             stubcc.linkExit(checkDivExc, Uses(2));
53156:             slowPath = true;
53156:         }
53156:     } else {
53156:         Jump checkDivExc = masm.branch32(Assembler::Equal, X86Registers::eax, Imm32(0x80000000));
53156:         stubcc.linkExit(checkDivExc, Uses(2));
53156:         Jump checkZero = masm.branchTest32(Assembler::Zero, rhsReg, rhsReg);
53156:         stubcc.linkExit(checkZero, Uses(2));
53156:         slowPath = true;
53156:     }
53156: 
53156:     /* Perform division. */
53156:     masm.idiv(rhsReg);
53156: 
53220:     /* ECMA-262 11.5.3 requires the result to have the same sign as the lhs.
53220:      * Thus, if the remainder of the div instruction is zero and the lhs is
53220:      * negative, we must return negative 0. */
53220: 
53220:     bool lhsMaybeNeg = true;
53220:     bool lhsIsNeg = false;
53220:     if (lhs->isConstant()) {
53220:         /* This condition is established at the top of this function. */
53220:         JS_ASSERT(lhs->getValue().isInt32());
53220:         lhsMaybeNeg = lhsIsNeg = (lhs->getValue().toInt32() < 0);
53220:     }
53220: 
53220:     MaybeJump done;
53220:     if (lhsMaybeNeg) {
53313:         MaybeRegisterID lhsData;
53220:         if (!lhsIsNeg)
53220:             lhsData = frame.tempRegForData(lhs);
53156:         Jump negZero1 = masm.branchTest32(Assembler::NonZero, X86Registers::edx);
53220:         MaybeJump negZero2;
53220:         if (!lhsIsNeg)
53313:             negZero2 = masm.branchTest32(Assembler::Zero, lhsData.reg(), Imm32(0x80000000));
53156:         /* Darn, negative 0. */
53188:         masm.storeValue(DoubleValue(-0.0), frame.addressOf(lhs));
53156: 
53181:         /* :TODO: This is wrong, must load into EDX as well. */
53181: 
53220:         done = masm.jump();
53156:         negZero1.linkTo(masm.label(), &masm);
53220:         if (negZero2.isSet())
53220:             negZero2.getJump().linkTo(masm.label(), &masm);
53220:     }
53156: 
53156:     /* Better - integer. */
53156:     masm.storeTypeTag(ImmType(JSVAL_TYPE_INT32), frame.addressOf(lhs));
53156: 
53220:     if (done.isSet())
53220:         done.getJump().linkTo(masm.label(), &masm);
53156: 
53156:     if (slowPath) {
53156:         stubcc.leave();
57766:         OOL_STUBCALL(stubs::Mod);
53156:     }
53156: 
53156:     frame.popn(2);
53156:     frame.pushNumber(X86Registers::edx);
53156: 
53156:     if (slowPath)
53156:         stubcc.rejoin(Changes(1));
53156: #endif
53156: }
53156: 
56766: bool
54160: mjit::Compiler::jsop_equality_int_string(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
53201: {
53201:     FrameEntry *rhs = frame.peek(-1);
53201:     FrameEntry *lhs = frame.peek(-2);
53201: 
54160:     /* Swap the LHS and RHS if it makes register allocation better... or possible. */
54160:     if (lhs->isConstant() ||
54160:         (frame.shouldAvoidDataRemat(lhs) && !rhs->isConstant())) {
54160:         FrameEntry *temp = rhs;
54160:         rhs = lhs;
54160:         lhs = temp;
53201:     }
53201: 
54160:     bool lhsInt = lhs->isType(JSVAL_TYPE_INT32);
54160:     bool rhsInt = rhs->isType(JSVAL_TYPE_INT32);
54160: 
54160:     /* Invert the condition if fusing with an IFEQ branch. */
54160:     bool flipCondition = (target && fused == JSOP_IFEQ);
54160: 
54160:     /* Get the condition being tested. */
53201:     Assembler::Condition cond;
53201:     switch (op) {
53201:       case JSOP_EQ:
54160:         cond = flipCondition ? Assembler::NotEqual : Assembler::Equal;
53201:         break;
53201:       case JSOP_NE:
54160:         cond = flipCondition ? Assembler::Equal : Assembler::NotEqual;
53201:         break;
53201:       default:
53201:         JS_NOT_REACHED("wat");
56766:         return false;
53201:     }
53201: 
54160:     if (target) {
54579:         Value rval = UndefinedValue();  /* quiet gcc warning */
54160:         bool rhsConst = false;
54160:         if (rhs->isConstant()) {
54160:             rhsConst = true;
54160:             rval = rhs->getValue();
53201:         }
53201: 
54160:         ValueRemat lvr, rvr;
54160:         frame.pinEntry(lhs, lvr);
54160:         frame.pinEntry(rhs, rvr);
53201: 
54160:         /*
54160:          * Sync everything except the top two entries.
54160:          * We will handle the lhs/rhs in the stub call path.
54160:          */
57787:         frame.syncAndKill(Registers(Registers::AvailRegs), Uses(frame.frameSlots()), Uses(2));
53201: 
56192:         RegisterID tempReg = frame.allocReg();
53201: 
53201:         frame.pop();
53201:         frame.pop();
54719:         frame.discardFrame();
53201: 
62379:         JaegerSpew(JSpew_Insns, " ---- BEGIN STUB CALL CODE ---- \n");
62379: 
62379:         RESERVE_OOL_SPACE(stubcc.masm);
62379: 
54160:         /* Start of the slow path for equality stub call. */
56192:         Label stubEntry = stubcc.masm.label();
53201: 
54160:         /* The lhs/rhs need to be synced in the stub call path. */
56004:         frame.ensureValueSynced(stubcc.masm, lhs, lvr);
56004:         frame.ensureValueSynced(stubcc.masm, rhs, rvr);
53201: 
56192:         bool needStub = true;
56192:         
56192: #ifdef JS_MONOIC
56192:         EqualityGenInfo ic;
56192: 
56192:         ic.cond = cond;
56192:         ic.tempReg = tempReg;
56192:         ic.lvr = lvr;
56192:         ic.rvr = rvr;
56192:         ic.stubEntry = stubEntry;
56192:         ic.stub = stub;
56192: 
56192:         bool useIC = !addTraceHints || target >= PC;
56192: 
56192:         /* Call the IC stub, which may generate a fast path. */
56192:         if (useIC) {
56192:             /* Adjust for the two values just pushed. */
56192:             ic.addrLabel = stubcc.masm.moveWithPatch(ImmPtr(NULL), Registers::ArgReg1);
57787:             ic.stubCall = OOL_STUBCALL_LOCAL_SLOTS(ic::Equality,
57787:                                                    frame.stackDepth() + script->nfixed + 2);
56192:             needStub = false;
56192:         }
56192: #endif
56192: 
56192:         if (needStub)
57787:             OOL_STUBCALL_LOCAL_SLOTS(stub, frame.stackDepth() + script->nfixed + 2);
54160: 
53201:         /*
53201:          * The stub call has no need to rejoin, since state is synced.
53201:          * Instead, we can just test the return value.
53201:          */
54160:         Assembler::Condition ncond = (fused == JSOP_IFEQ)
53201:                                    ? Assembler::Zero
53201:                                    : Assembler::NonZero;
54160:         Jump stubBranch =
54160:             stubcc.masm.branchTest32(ncond, Registers::ReturnReg, Registers::ReturnReg);
54160:         Jump stubFallthrough = stubcc.masm.jump();
53201: 
54160:         JaegerSpew(JSpew_Insns, " ---- END STUB CALL CODE ---- \n");
62379:         CHECK_OOL_SPACE();
54160: 
56192:         Jump fast;
56192:         MaybeJump firstStubJump;
54160: 
56598:         if ((!lhs->isTypeKnown() || lhsInt) && (!rhs->isTypeKnown() || rhsInt)) {
54160:             if (!lhsInt) {
54160:                 Jump lhsFail = masm.testInt32(Assembler::NotEqual, lvr.typeReg());
56192:                 stubcc.linkExitDirect(lhsFail, stubEntry);
56192:                 firstStubJump = lhsFail;
54160:             }
54160:             if (!rhsInt) {
54160:                 Jump rhsFail = masm.testInt32(Assembler::NotEqual, rvr.typeReg());
56192:                 stubcc.linkExitDirect(rhsFail, stubEntry);
56192:                 if (!firstStubJump.isSet())
56192:                     firstStubJump = rhsFail;
54160:             }
54160: 
54160:             if (rhsConst)
54160:                 fast = masm.branch32(cond, lvr.dataReg(), Imm32(rval.toInt32()));
54160:             else
54160:                 fast = masm.branch32(cond, lvr.dataReg(), rvr.dataReg());
56192: 
56766:             if (!jumpInScript(fast, target))
56766:                 return false;
56192:         } else {
56192:             Jump j = masm.jump();
56192:             stubcc.linkExitDirect(j, stubEntry);
56192:             firstStubJump = j;
56192: 
56192:             /* This is just a dummy jump. */
56192:             fast = masm.jump();
54160:         }
54160: 
56192: #ifdef JS_MONOIC
56192:         ic.jumpToStub = firstStubJump;
56192:         if (useIC) {
56192:             ic.fallThrough = masm.label();
56192:             ic.jumpTarget = target;
56192:             equalityICs.append(ic);
56192:         }
56192: #endif
56192: 
56192:         /* Jump from the stub call fallthrough to here. */
54160:         stubcc.crossJump(stubFallthrough, masm.label());
53201: 
53201:         /*
53201:          * NB: jumpAndTrace emits to the OOL path, so make sure not to use it
53201:          * in the middle of an in-progress slow path.
53201:          */
56766:         if (!jumpAndTrace(fast, target, &stubBranch))
56766:             return false;
53201:     } else {
53201:         /* No fusing. Compare, set, and push a boolean. */
53201: 
54160:         /* Should have filtered these out in the caller. */
56192:         JS_ASSERT(!lhs->isType(JSVAL_TYPE_STRING) && !rhs->isType(JSVAL_TYPE_STRING));
54160: 
54160:         /* Test the types. */
56598:         if ((lhs->isTypeKnown() && !lhsInt) || (rhs->isTypeKnown() && !rhsInt)) {
56598:             stubcc.linkExit(masm.jump(), Uses(2));
56598:         } else {
54160:             if (!lhsInt) {
54160:                 Jump lhsFail = frame.testInt32(Assembler::NotEqual, lhs);
54160:                 stubcc.linkExit(lhsFail, Uses(2));
54160:             }
54160:             if (!rhsInt) {
54160:                 Jump rhsFail = frame.testInt32(Assembler::NotEqual, rhs);
54160:                 stubcc.linkExit(rhsFail, Uses(2));
54160:             }
56598:         }
54160: 
54160:         stubcc.leave();
57766:         OOL_STUBCALL(stub);
54160: 
53201:         RegisterID reg = frame.ownRegForData(lhs);
53201: 
53201:         /* x86/64's SET instruction can only take single-byte regs.*/
53201:         RegisterID resultReg = reg;
53201:         if (!(Registers::maskReg(reg) & Registers::SingleByteRegs))
53201:             resultReg = frame.allocReg(Registers::SingleByteRegs);
53201: 
53201:         /* Emit the compare & set. */
53201:         if (rhs->isConstant()) {
53201:             masm.set32(cond, reg, Imm32(rhs->getValue().toInt32()), resultReg);
53201:         } else if (frame.shouldAvoidDataRemat(rhs)) {
53201:             masm.set32(cond, reg,
53201:                        masm.payloadOf(frame.addressOf(rhs)),
53201:                        resultReg);
53201:         } else {
53201:             masm.set32(cond, reg, frame.tempRegForData(rhs), resultReg);
53201:         }
53201: 
53201:         /* Clean up and push a boolean. */
53201:         frame.pop();
53201:         frame.pop();
53201:         if (reg != resultReg)
53201:             frame.freeReg(reg);
53201:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, resultReg);
53201:         stubcc.rejoin(Changes(1));
53201:     }
56766:     return true;
53201: }
53201: 
53201: /*
53201:  * Emit an OOL path for a possibly double LHS, and possibly int32 or number RHS.
53201:  */
53201: void
53201: mjit::Compiler::emitLeftDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                                    MaybeJump &lhsNotDouble, MaybeJump &rhsNotNumber,
53201:                                    MaybeJump &lhsUnknownDone)
53201: {
53201:     FPRegisterID fpLeft = FPRegisters::First;
53201:     FPRegisterID fpRight = FPRegisters::Second;
53201: 
53201:     /* If the LHS is not a 32-bit integer, take OOL path. */
53201:     Jump lhsNotInt32 = masm.testInt32(Assembler::NotEqual, regs.lhsType.reg());
53201:     stubcc.linkExitDirect(lhsNotInt32, stubcc.masm.label());
53201: 
53201:     /* OOL path for LHS as a double - first test LHS is double. */
53201:     lhsNotDouble = stubcc.masm.testDouble(Assembler::NotEqual, regs.lhsType.reg());
53201: 
53201:     /* Ensure the RHS is a number. */
53201:     MaybeJump rhsIsDouble;
53201:     if (!rhs->isTypeKnown()) {
53201:         rhsIsDouble = stubcc.masm.testDouble(Assembler::Equal, regs.rhsType.reg());
53201:         rhsNotNumber = stubcc.masm.testInt32(Assembler::NotEqual, regs.rhsType.reg());
53201:     }
53201: 
53201:     /* If RHS is constant, convert now. */
53201:     if (rhs->isConstant())
53201:         slowLoadConstantDouble(stubcc.masm, rhs, fpRight);
53201:     else
53201:         stubcc.masm.convertInt32ToDouble(regs.rhsData.reg(), fpRight);
53201: 
53201:     if (!rhs->isTypeKnown()) {
53201:         /* Jump past double load, bind double type check. */
53201:         Jump converted = stubcc.masm.jump();
53201:         rhsIsDouble.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201: 
53201:         /* Load the double. */
53229:         frame.loadDouble(regs.rhsType.reg(), regs.rhsData.reg(),
53229:                          rhs, fpRight, stubcc.masm);
53201: 
53201:         converted.linkTo(stubcc.masm.label(), &stubcc.masm);
53201:     }
53201: 
53201:     /* Load the LHS. */
53229:     frame.loadDouble(regs.lhsType.reg(), regs.lhsData.reg(),
53229:                      lhs, fpLeft, stubcc.masm);
53201:     lhsUnknownDone = stubcc.masm.jump();
53201: }
53201: 
53201: /*
53201:  * Emit an OOL path for an integer LHS, possibly double RHS.
53201:  */
53201: void
53201: mjit::Compiler::emitRightDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                                     MaybeJump &rhsNotNumber2)
53201: {
53201:     FPRegisterID fpLeft = FPRegisters::First;
53201:     FPRegisterID fpRight = FPRegisters::Second;
53201: 
53201:     /* If the RHS is not a double, take OOL path. */
53201:     Jump notInt32 = masm.testInt32(Assembler::NotEqual, regs.rhsType.reg());
53201:     stubcc.linkExitDirect(notInt32, stubcc.masm.label());
53201: 
53201:     /* Now test if RHS is a double. */
53201:     rhsNotNumber2 = stubcc.masm.testDouble(Assembler::NotEqual, regs.rhsType.reg());
53201: 
53201:     /* We know LHS is an integer. */
53201:     if (lhs->isConstant())
53201:         slowLoadConstantDouble(stubcc.masm, lhs, fpLeft);
53201:     else
53201:         stubcc.masm.convertInt32ToDouble(regs.lhsData.reg(), fpLeft);
53201: 
53201:     /* Load the RHS. */
53229:     frame.loadDouble(regs.rhsType.reg(), regs.rhsData.reg(),
53229:                      rhs, fpRight, stubcc.masm);
53201: }
53201: 
53201: static inline Assembler::DoubleCondition
53201: DoubleCondForOp(JSOp op, JSOp fused)
53201: {
53201:     bool ifeq = fused == JSOP_IFEQ;
53201:     switch (op) {
53201:       case JSOP_GT:
53201:         return ifeq 
53201:                ? Assembler::DoubleLessThanOrEqualOrUnordered
53201:                : Assembler::DoubleGreaterThan;
53201:       case JSOP_GE:
53201:         return ifeq
53201:                ? Assembler::DoubleLessThanOrUnordered
53201:                : Assembler::DoubleGreaterThanOrEqual;
53201:       case JSOP_LT:
53201:         return ifeq
53201:                ? Assembler::DoubleGreaterThanOrEqualOrUnordered
53201:                : Assembler::DoubleLessThan;
53201:       case JSOP_LE:
53201:         return ifeq
53201:                ? Assembler::DoubleGreaterThanOrUnordered
53201:                : Assembler::DoubleLessThanOrEqual;
53201:       default:
53201:         JS_NOT_REACHED("unrecognized op");
53201:         return Assembler::DoubleLessThan;
53201:     }
53201: }
53201: 
56766: bool
53201: mjit::Compiler::jsop_relational_double(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
53201: {
53201:     FrameEntry *rhs = frame.peek(-1);
53201:     FrameEntry *lhs = frame.peek(-2);
53201: 
53201:     FPRegisterID fpLeft = FPRegisters::First;
53201:     FPRegisterID fpRight = FPRegisters::Second;
53201: 
53201:     JS_ASSERT_IF(!target, fused != JSOP_IFEQ);
53201: 
53201:     MaybeJump lhsNotNumber = loadDouble(lhs, fpLeft);
53201:     MaybeJump rhsNotNumber = loadDouble(rhs, fpRight);
53201: 
53201:     Assembler::DoubleCondition dblCond = DoubleCondForOp(op, fused);
53201: 
53201:     if (target) {
53201:         if (lhsNotNumber.isSet())
53201:             stubcc.linkExitForBranch(lhsNotNumber.get());
53201:         if (rhsNotNumber.isSet())
53201:             stubcc.linkExitForBranch(rhsNotNumber.get());
53201:         stubcc.leave();
57766:         OOL_STUBCALL(stub);
53201: 
53362:         frame.popn(2);
54719:         frame.syncAndForgetEverything();
53201: 
53201:         Jump j = masm.branchDouble(dblCond, fpLeft, fpRight);
53201: 
53201:         /*
53201:          * The stub call has no need to rejoin since the state is synced.
53201:          * Instead, we can just test the return value.
53201:          */
53201:         Assembler::Condition cond = (fused == JSOP_IFEQ)
53201:                                     ? Assembler::Zero
53201:                                     : Assembler::NonZero;
53201:         Jump sj = stubcc.masm.branchTest32(cond, Registers::ReturnReg, Registers::ReturnReg);
53201: 
53201:         /* Rejoin from the slow path. */
53277:         Jump j2 = stubcc.masm.jump();
53277:         stubcc.crossJump(j2, masm.label());
53201: 
53201:         /*
53201:          * NB: jumpAndTrace emits to the OOL path, so make sure not to use it
53201:          * in the middle of an in-progress slow path.
53201:          */
56766:         if (!jumpAndTrace(j, target, &sj))
56766:             return false;
53201:     } else {
53201:         if (lhsNotNumber.isSet())
53201:             stubcc.linkExit(lhsNotNumber.get(), Uses(2));
53201:         if (rhsNotNumber.isSet())
53201:             stubcc.linkExit(rhsNotNumber.get(), Uses(2));
53201:         stubcc.leave();
57766:         OOL_STUBCALL(stub);
53201: 
53201:         frame.popn(2);
53201: 
53201:         RegisterID reg = frame.allocReg();
53201:         Jump j = masm.branchDouble(dblCond, fpLeft, fpRight);
53201:         masm.move(Imm32(0), reg);
53201:         Jump skip = masm.jump();
53201:         j.linkTo(masm.label(), &masm);
53201:         masm.move(Imm32(1), reg);
53201:         skip.linkTo(masm.label(), &masm);
53201: 
53201:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, reg);
53201: 
53201:         stubcc.rejoin(Changes(1));
53201:     }
56766:     return true;
53201: }
53201: 
56766: bool
53201: mjit::Compiler::jsop_relational_self(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
53201: {
53201: #ifdef DEBUG
53201:     FrameEntry *rhs = frame.peek(-1);
53201:     FrameEntry *lhs = frame.peek(-2);
53201: 
53201:     JS_ASSERT(frame.haveSameBacking(lhs, rhs));
53201: #endif
53201: 
53201:     /* :TODO: optimize this?  */
56766:     return emitStubCmpOp(stub, target, fused);
53201: }
53201: 
53201: /* See jsop_binary_full() for more information on how this works. */
56766: bool
53201: mjit::Compiler::jsop_relational_full(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused)
53201: {
53201:     FrameEntry *rhs = frame.peek(-1);
53201:     FrameEntry *lhs = frame.peek(-2);
53201: 
53201:     /* Allocate all registers up-front. */
53201:     FrameState::BinaryAlloc regs;
53201:     frame.allocForBinary(lhs, rhs, op, regs, !target);
53201: 
53201:     FPRegisterID fpLeft = FPRegisters::First;
53201:     FPRegisterID fpRight = FPRegisters::Second;
53201: 
53201:     MaybeJump lhsNotDouble, rhsNotNumber, lhsUnknownDone;
53201:     if (!lhs->isTypeKnown())
53201:         emitLeftDoublePath(lhs, rhs, regs, lhsNotDouble, rhsNotNumber, lhsUnknownDone);
53201: 
53201:     MaybeJump rhsNotNumber2;
53201:     if (!rhs->isTypeKnown())
53201:         emitRightDoublePath(lhs, rhs, regs, rhsNotNumber2);
53201: 
53201:     /* Both double paths will join here. */
53201:     bool hasDoublePath = false;
53217:     if (!rhs->isTypeKnown() || lhsUnknownDone.isSet())
53201:         hasDoublePath = true;
53201: 
53201:     /* Integer path - figure out the immutable side. */
53201:     JSOp cmpOp = op;
53201:     int32 value = 0;
53201:     RegisterID cmpReg;
53201:     MaybeRegisterID reg;
53201:     if (regs.lhsData.isSet()) {
53201:         cmpReg = regs.lhsData.reg();
53201:         if (!regs.rhsData.isSet())
53201:             value = rhs->getValue().toInt32();
53201:         else
53201:             reg = regs.rhsData.reg();
53201:     } else {
53201:         cmpReg = regs.rhsData.reg();
53201:         value = lhs->getValue().toInt32();
53201:         switch (op) {
53201:           case JSOP_GT:
53201:             cmpOp = JSOP_LT;
53201:             break;
53201:           case JSOP_GE:
53201:             cmpOp = JSOP_LE;
53201:             break;
53201:           case JSOP_LT:
53201:             cmpOp = JSOP_GT;
53201:             break;
53201:           case JSOP_LE:
53201:             cmpOp = JSOP_GE;
53201:             break;
53201:           default:
53201:             JS_NOT_REACHED("unrecognized op");
53201:             break;
53201:         }
53201:     }
53201: 
53201:     /*
53201:      * Emit the actual comparisons. When a fusion is in play, it's faster to
53201:      * combine the comparison with the jump, so these two cases are implemented
53201:      * separately.
53201:      */
53201: 
53201:     if (target) {
53201:         /*
53201:          * Emit the double path now, necessary to complete the OOL fast-path
53201:          * before emitting the slow path.
53201:          *
53201:          * Note: doubles have not been swapped yet. Use original op.
53201:          */
53201:         MaybeJump doubleTest, doubleFall;
53201:         Assembler::DoubleCondition dblCond = DoubleCondForOp(op, fused);
53201:         if (hasDoublePath) {
53217:             if (lhsUnknownDone.isSet())
53217:                 lhsUnknownDone.get().linkTo(stubcc.masm.label(), &stubcc.masm);
57787:             frame.sync(stubcc.masm, Uses(frame.frameSlots()));
53201:             doubleTest = stubcc.masm.branchDouble(dblCond, fpLeft, fpRight);
53201:             doubleFall = stubcc.masm.jump();
53201: 
53201:             /* Link all incoming slow paths to here. */
53201:             if (lhsNotDouble.isSet()) {
53201:                 lhsNotDouble.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201:                 if (rhsNotNumber.isSet())
53201:                     rhsNotNumber.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201:             }
53201:             if (rhsNotNumber2.isSet())
53201:                 rhsNotNumber2.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201: 
53217:             /*
53217:              * For fusions, spill the tracker state. xmm* remain intact. Note
53217:              * that frame.sync() must be used directly, to avoid syncExit()'s
53217:              * jumping logic.
53217:              */
57787:             frame.sync(stubcc.masm, Uses(frame.frameSlots()));
53201:             stubcc.leave();
57766:             OOL_STUBCALL(stub);
53201:         }
53201: 
53201:         /* Forget the world, preserving data. */
53201:         frame.pinReg(cmpReg);
53201:         if (reg.isSet())
53201:             frame.pinReg(reg.reg());
53362:         
53362:         frame.popn(2);
54719: 
54719:         frame.syncAndKillEverything();
54719:         frame.unpinKilledReg(cmpReg);
54719:         if (reg.isSet())
54719:             frame.unpinKilledReg(reg.reg());
54719:         frame.syncAndForgetEverything();
53201:         
53201:         /* Operands could have been reordered, so use cmpOp. */
53201:         Assembler::Condition i32Cond;
53201:         bool ifeq = fused == JSOP_IFEQ;
53201:         switch (cmpOp) {
53201:           case JSOP_GT:
53201:             i32Cond = ifeq ? Assembler::LessThanOrEqual : Assembler::GreaterThan;
53201:             break;
53201:           case JSOP_GE:
53201:             i32Cond = ifeq ? Assembler::LessThan : Assembler::GreaterThanOrEqual;
53201:             break;
53201:           case JSOP_LT:
53201:             i32Cond = ifeq ? Assembler::GreaterThanOrEqual : Assembler::LessThan;
53201:             break;
53201:           case JSOP_LE:
53201:             i32Cond = ifeq ? Assembler::GreaterThan : Assembler::LessThanOrEqual;
53201:             break;
53201:           default:
53201:             JS_NOT_REACHED("unrecognized op");
56766:             return false;
53201:         }
53201: 
53201:         /* Emit the i32 path. */
53201:         Jump fast;
53201:         if (reg.isSet())
53201:             fast = masm.branch32(i32Cond, cmpReg, reg.reg());
53201:         else
53201:             fast = masm.branch32(i32Cond, cmpReg, Imm32(value));
53201: 
53201:         /*
53201:          * The stub call has no need to rejoin since state is synced. Instead,
53201:          * we can just test the return value.
53201:          */
53201:         Assembler::Condition cond = (fused == JSOP_IFEQ)
53201:                                     ? Assembler::Zero
53201:                                     : Assembler::NonZero;
53201:         Jump j = stubcc.masm.branchTest32(cond, Registers::ReturnReg, Registers::ReturnReg);
53201: 
53201:         /* Rejoin from the slow path. */
53277:         Jump j2 = stubcc.masm.jump();
53277:         stubcc.crossJump(j2, masm.label());
53201: 
53201:         /* :TODO: make double path invoke tracer. */
53277:         if (hasDoublePath) {
53277:             j.linkTo(stubcc.masm.label(), &stubcc.masm);
53277:             doubleTest.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53277:             j = stubcc.masm.jump();
53277:         }
53201: 
53201:         /*
53201:          * NB: jumpAndTrace emits to the OOL path, so make sure not to use it
53201:          * in the middle of an in-progress slow path.
53201:          */
56766:         if (!jumpAndTrace(fast, target, &j))
56766:             return false;
53201: 
53201:         /* Rejoin from the double path. */
53201:         if (hasDoublePath)
53201:             stubcc.crossJump(doubleFall.get(), masm.label());
53201:     } else {
53201:         /*
53201:          * Emit the double path now, necessary to complete the OOL fast-path
53201:          * before emitting the slow path.
53201:          */
53201:         MaybeJump doubleDone;
53201:         Assembler::DoubleCondition dblCond = DoubleCondForOp(op, JSOP_NOP);
53201:         if (hasDoublePath) {
53217:             if (lhsUnknownDone.isSet())
53217:                 lhsUnknownDone.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201:             /* :FIXME: Use SET if we can? */
53201:             Jump test = stubcc.masm.branchDouble(dblCond, fpLeft, fpRight);
53201:             stubcc.masm.move(Imm32(0), regs.result);
53201:             Jump skip = stubcc.masm.jump();
53201:             test.linkTo(stubcc.masm.label(), &stubcc.masm);
53201:             stubcc.masm.move(Imm32(1), regs.result);
53201:             skip.linkTo(stubcc.masm.label(), &stubcc.masm);
53201:             doubleDone = stubcc.masm.jump();
53201: 
53201:             /* Link all incoming slow paths to here. */
53201:             if (lhsNotDouble.isSet()) {
53201:                 lhsNotDouble.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201:                 if (rhsNotNumber.isSet())
53201:                     rhsNotNumber.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201:             }
53201:             if (rhsNotNumber2.isSet())
53201:                 rhsNotNumber2.get().linkTo(stubcc.masm.label(), &stubcc.masm);
53201: 
53201:             /* Emit the slow path - note full frame syncage. */
53348:             frame.sync(stubcc.masm, Uses(2));
53201:             stubcc.leave();
57766:             OOL_STUBCALL(stub);
53201:         }
53201: 
53201:         /* Get an integer comparison condition. */
53201:         Assembler::Condition i32Cond;
53201:         switch (cmpOp) {
53201:           case JSOP_GT:
53201:             i32Cond = Assembler::GreaterThan;
53201:             break;
53201:           case JSOP_GE:
53201:             i32Cond = Assembler::GreaterThanOrEqual;
53201:             break;
53201:           case JSOP_LT:
53201:             i32Cond = Assembler::LessThan;
53201:             break;
53201:           case JSOP_LE:
53201:             i32Cond = Assembler::LessThanOrEqual;
53201:             break;
53201:           default:
53201:             JS_NOT_REACHED("unrecognized op");
56766:             return false;
53201:         }
53201: 
53201:         /* Emit the compare & set. */
53201:         if (Registers::maskReg(regs.result) & Registers::SingleByteRegs) {
53201:             if (reg.isSet())
53201:                 masm.set32(i32Cond, cmpReg, reg.reg(), regs.result);
53201:             else
53201:                 masm.set32(i32Cond, cmpReg, Imm32(value), regs.result);
53201:         } else {
53201:             Jump j;
53201:             if (reg.isSet())
53201:                 j = masm.branch32(i32Cond, cmpReg, reg.reg());
53201:             else
53201:                 j = masm.branch32(i32Cond, cmpReg, Imm32(value));
53201:             masm.move(Imm32(0), regs.result);
53201:             Jump skip = masm.jump();
53201:             j.linkTo(masm.label(),  &masm);
53201:             masm.move(Imm32(1), regs.result);
53201:             skip.linkTo(masm.label(), &masm);
53201:         }
53201: 
53201:         frame.popn(2);
53201:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, regs.result);
53201: 
53201:         if (hasDoublePath)
53201:             stubcc.crossJump(doubleDone.get(), masm.label());
53201:         stubcc.rejoin(Changes(1));
53201:     }
56766:     return true;
53201: }
53201: 
