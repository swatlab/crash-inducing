     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsTableOuterFrame.h"
     1: #include "nsTableFrame.h"
125899: #include "nsTableCellFrame.h"
     1: #include "nsStyleContext.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsPresContext.h"
     1: #include "nsCSSRendering.h"
     1: #include "nsIContent.h"
     1: #include "prinrval.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsDisplayList.h"
     1: #include "nsLayoutUtils.h"
129543: #include <algorithm>
     1: 
 88122: using namespace mozilla;
 88122: using namespace mozilla::layout;
 88122: 
     1: /* ----------- nsTableCaptionFrame ---------- */
     1: 
 79486: #define NS_TABLE_FRAME_CAPTION_LIST_INDEX 1
     1: #define NO_SIDE 100
     1: 
     1: // caption frame
     1: nsTableCaptionFrame::nsTableCaptionFrame(nsStyleContext* aContext):
     1:   nsBlockFrame(aContext)
     1: {
     1:   // shrink wrap 
 23305:   SetFlags(NS_BLOCK_FLOAT_MGR);
     1: }
     1: 
     1: nsTableCaptionFrame::~nsTableCaptionFrame()
     1: {
     1: }
     1: 
     1: nsIAtom*
     1: nsTableCaptionFrame::GetType() const
     1: {
     1:   return nsGkAtoms::tableCaptionFrame;
     1: }
     1: 
     1: /* virtual */ nscoord
     1: nsTableOuterFrame::GetBaseline() const
     1: {
     1:   nsIFrame* kid = mFrames.FirstChild();
     1:   if (!kid) {
     1:     NS_NOTREACHED("no inner table");
 86231:     return nsContainerFrame::GetBaseline();
     1:   }
     1: 
     1:   return kid->GetBaseline() + kid->GetPosition().y;
     1: }
     1: 
     1: /* virtual */ nsSize
 68481: nsTableCaptionFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                                      nsSize aCBSize, nscoord aAvailableWidth,
     1:                                      nsSize aMargin, nsSize aBorder,
 79445:                                      nsSize aPadding, bool aShrinkWrap)
     1: {
     1:   nsSize result = nsBlockFrame::ComputeAutoSize(aRenderingContext, aCBSize,
     1:                     aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
 88122: 
 88122:   // If we're a container for font size inflation, then shrink
 88122:   // wrapping inside of us should not apply font size inflation.
 98992:   AutoMaybeDisableFontInflation an(this);
 88122: 
132812:   uint8_t captionSide = StyleTableBorder()->mCaptionSide;
 12309:   if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
 12309:       captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
     1:     result.width = GetMinWidth(aRenderingContext);
 12309:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 12309:              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
 12309:     // The outer frame constrains our available width to the width of
 12309:     // the table.  Grow if our min-width is bigger than that, but not
 12309:     // larger than the containing block width.  (It would really be nice
 12309:     // to transmit that information another way, so we could grow up to
 12309:     // the table's available width, but that's harder.)
 12309:     nscoord min = GetMinWidth(aRenderingContext);
 12309:     if (min > aCBSize.width)
 12309:       min = aCBSize.width;
 12309:     if (min > result.width)
 12309:       result.width = min;
     1:   }
     1:   return result;
     1: }
     1: 
 78202: nsIFrame*
 90155: nsTableCaptionFrame::GetParentStyleContextFrame() const
   706: {
  1270:   NS_PRECONDITION(mContent->GetParent(),
  1270:                   "How could we not have a parent here?");
  1270:     
   706:   // The caption's style context parent is the inner frame, unless
   706:   // it's anonymous.
   706:   nsIFrame* outerFrame = GetParent();
   706:   if (outerFrame && outerFrame->GetType() == nsGkAtoms::tableOuterFrame) {
 77154:     nsIFrame* innerFrame = outerFrame->GetFirstPrincipalChild();
   706:     if (innerFrame) {
 78202:       return nsFrame::CorrectStyleParentFrame(innerFrame,
132768:                                               StyleContext()->GetPseudo());
   706:     }
   706:   }
   706: 
   706:   NS_NOTREACHED("Where is our inner table frame?");
 78202:   return nsBlockFrame::GetParentStyleContextFrame();
   706: }
   706: 
  3151: #ifdef ACCESSIBILITY
118929: a11y::AccType
118929: nsTableCaptionFrame::AccessibleType()
  3151: {
  3151:   if (!GetRect().IsEmpty()) {
126218:     return a11y::eHTMLCaptionType;
  3151:   }
  3151: 
125637:   return a11y::eNoType;
  3151: }
  3151: #endif
  3151: 
102909: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsTableCaptionFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("Caption"), aResult);
     1: }
     1: #endif
     1: 
     1: nsIFrame* 
     1: NS_NewTableCaptionFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsTableCaptionFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableCaptionFrame)
 32423: 
     1: /* ----------- nsTableOuterFrame ---------- */
     1: 
     1: nsTableOuterFrame::nsTableOuterFrame(nsStyleContext* aContext):
 86231:   nsContainerFrame(aContext)
     1: {
     1: }
     1: 
     1: nsTableOuterFrame::~nsTableOuterFrame()
     1: {
     1: }
     1: 
 23554: NS_QUERYFRAME_HEAD(nsTableOuterFrame)
125899:   NS_QUERYFRAME_ENTRY(nsTableOuterFrame)
 86231: NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
     1: 
     1: #ifdef ACCESSIBILITY
118929: a11y::AccType
118929: nsTableOuterFrame::AccessibleType()
     1: {
126218:   return a11y::eHTMLTableType;
     1: }
     1: #endif
     1: 
     1: void
 36647: nsTableOuterFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
 79486:   DestroyAbsoluteFrames(aDestructRoot);
 36647:   mCaptionFrames.DestroyFramesFrom(aDestructRoot);
 86231:   nsContainerFrame::DestroyFrom(aDestructRoot);
     1: }
     1: 
 91756: const nsFrameList&
 77152: nsTableOuterFrame::GetChildList(ChildListID aListID) const
     1: {
 79483:   if (aListID == kCaptionList) {
 30783:     return mCaptionFrames;
     1:   }
 79483: 
 86231:   return nsContainerFrame::GetChildList(aListID);
 77152: }
     1: 
 77152: void
 77152: nsTableOuterFrame::GetChildLists(nsTArray<ChildList>* aLists) const
     1: {
 86231:   nsContainerFrame::GetChildLists(aLists);
 77152:   mCaptionFrames.AppendIfNonempty(aLists, kCaptionList);
     1: }
     1: 
     1: NS_IMETHODIMP 
 77154: nsTableOuterFrame::SetInitialChildList(ChildListID     aListID,
 30790:                                        nsFrameList&    aChildList)
     1: {
 77154:   if (kCaptionList == aListID) {
     1:     // the frame constructor already checked for table-caption display type
     1:     mCaptionFrames.SetFrames(aChildList);
     1:   }
     1:   else {
 77154:     NS_ASSERTION(aListID == kPrincipalList, "wrong childlist");
     1:     NS_ASSERTION(mFrames.IsEmpty(), "Frame leak!");
 78203:     NS_ASSERTION(aChildList.FirstChild() &&
 78203:                  nsGkAtoms::tableFrame == aChildList.FirstChild()->GetType(),
 78203:                  "expected a table frame");
     1:     mFrames.SetFrames(aChildList);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsTableOuterFrame::AppendFrames(ChildListID     aListID,
 30941:                                 nsFrameList&    aFrameList)
     1: {
     1:   nsresult rv;
     1: 
     1:   // We only have two child frames: the inner table and a caption frame.
     1:   // The inner frame is provided when we're initialized, and it cannot change
 77154:   if (kCaptionList == aListID) {
 30941:     NS_ASSERTION(aFrameList.IsEmpty() ||
 30941:                  aFrameList.FirstChild()->GetType() == nsGkAtoms::tableCaptionFrame,
     1:                  "appending non-caption frame to captionList");
     1:     mCaptionFrames.AppendFrames(this, aFrameList);
     1:     rv = NS_OK;
     1: 
     1:     // Reflow the new caption frame. It's already marked dirty, so
     1:     // just tell the pres shell.
   238:     PresContext()->PresShell()->
  1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
  1158:                        NS_FRAME_HAS_DIRTY_CHILDREN);
     1:   }
     1:   else {
 80486:     NS_PRECONDITION(false, "unexpected child list");
     1:     rv = NS_ERROR_UNEXPECTED;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsTableOuterFrame::InsertFrames(ChildListID     aListID,
     1:                                 nsIFrame*       aPrevFrame,
 30941:                                 nsFrameList&    aFrameList)
     1: {
 77154:   if (kCaptionList == aListID) {
     1:     NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
     1:                  "inserting after sibling frame with different parent");
 30941:     NS_ASSERTION(aFrameList.IsEmpty() ||
 30941:                  aFrameList.FirstChild()->GetType() == nsGkAtoms::tableCaptionFrame,
     1:                  "inserting non-caption frame into captionList");
106838:     mCaptionFrames.InsertFrames(nullptr, aPrevFrame, aFrameList);
  4195: 
  4195:     // Reflow the new caption frame. It's already marked dirty, so
  4195:     // just tell the pres shell.
  4195:     PresContext()->PresShell()->
  4195:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
  4195:                        NS_FRAME_HAS_DIRTY_CHILDREN);
     1:     return NS_OK;
     1:   }
     1:   else {
     1:     NS_PRECONDITION(!aPrevFrame, "invalid previous frame");
 77154:     return AppendFrames(aListID, aFrameList);
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsTableOuterFrame::RemoveFrame(ChildListID     aListID,
     1:                                nsIFrame*       aOldFrame)
     1: {
     1:   // We only have two child frames: the inner table and one caption frame.
     1:   // The inner frame can't be removed so this should be the caption
 77154:   NS_PRECONDITION(kCaptionList == aListID, "can't remove inner frame");
     1: 
 12309:   if (HasSideCaption()) {
     1:     // The old caption width had an effect on the inner table width so
     1:     // we're going to need to reflow it. Mark it dirty
 78204:     InnerTableFrame()->AddStateBits(NS_FRAME_IS_DIRTY);
     1:   }
     1: 
     1:   // Remove the frame and destroy it
     1:   mCaptionFrames.DestroyFrame(aOldFrame);
     1:   
   238:   PresContext()->PresShell()->
  1158:     FrameNeedsReflow(this, nsIPresShell::eTreeChange,
  1158:                      NS_FRAME_HAS_DIRTY_CHILDREN); // also means child removed
     1: 
     1:   return NS_OK;
     1: }
     1: 
132778: void
     1: nsTableOuterFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                     const nsRect&           aDirtyRect,
     1:                                     const nsDisplayListSet& aLists)
     1: {
     1:   // No border, background or outline are painted because they all belong
     1:   // to the inner table.
     1: 
     1:   // If there's no caption, take a short cut to avoid having to create
     1:   // the special display list set and then sort it.
132777:   if (mCaptionFrames.IsEmpty()) {
132777:     BuildDisplayListForInnerTable(aBuilder, aDirtyRect, aLists);
132778:     return;
132777:   }
     1: 
     1:   nsDisplayListCollection set;
132777:   BuildDisplayListForInnerTable(aBuilder, aDirtyRect, set);
     1:   
     1:   nsDisplayListSet captionSet(set, set.BlockBorderBackgrounds());
132777:   BuildDisplayListForChild(aBuilder, mCaptionFrames.FirstChild(),
 78204:                            aDirtyRect, captionSet);
     1:   
     1:   // Now we have to sort everything by content order, since the caption
     1:   // may be somewhere inside the table
     1:   set.SortAllByContentOrder(aBuilder, GetContent());
     1:   set.MoveTo(aLists);
     1: }
     1: 
132778: void
     1: nsTableOuterFrame::BuildDisplayListForInnerTable(nsDisplayListBuilder*   aBuilder,
     1:                                                  const nsRect&           aDirtyRect,
     1:                                                  const nsDisplayListSet& aLists)
     1: {
     1:   // Just paint the regular children, but the children's background is our
     1:   // true background (there should only be one, the real table)
     1:   nsIFrame* kid = mFrames.FirstChild();
     1:   // The children should be in content order
     1:   while (kid) {
132777:     BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
     1:     kid = kid->GetNextSibling();
     1:   }
     1: }
     1: 
 78202: nsIFrame*
 90155: nsTableOuterFrame::GetParentStyleContextFrame() const
     1: {
     1:   // The table outer frame and the (inner) table frame split the style
     1:   // data by giving the table frame the style context associated with
     1:   // the table content node and creating a style context for the outer
     1:   // frame that is a *child* of the table frame's style context,
     1:   // matching the ::-moz-table-outer pseudo-element.  html.css has a
     1:   // rule that causes that pseudo-element (and thus the outer table)
     1:   // to inherit *some* style properties from the table frame.  The
     1:   // children of the table inherit directly from the inner table, and
     1:   // the outer table's style context is a leaf.
     1: 
 78204:   return InnerTableFrame();
     1: }
     1: 
     1: // INCREMENTAL REFLOW HELPER FUNCTIONS 
     1: 
     1: void
     1: nsTableOuterFrame::InitChildReflowState(nsPresContext&    aPresContext,                     
     1:                                         nsHTMLReflowState& aReflowState)
     1:                                     
     1: {
     1:   nsMargin collapseBorder;
     1:   nsMargin collapsePadding(0,0,0,0);
106838:   nsMargin* pCollapseBorder  = nullptr;
106838:   nsMargin* pCollapsePadding = nullptr;
 78204:   if (aReflowState.frame == InnerTableFrame() &&
 78204:       InnerTableFrame()->IsBorderCollapse()) {
 78204:     collapseBorder  = InnerTableFrame()->GetIncludedOuterBCBorder();
     1:     pCollapseBorder = &collapseBorder;
     1:     pCollapsePadding = &collapsePadding;
     1:   }
     1:   aReflowState.Init(&aPresContext, -1, -1, pCollapseBorder, pCollapsePadding);
     1: }
     1: 
     1: // get the margin and padding data. nsHTMLReflowState doesn't handle the
     1: // case of auto margins
     1: void
 36583: nsTableOuterFrame::GetChildMargin(nsPresContext*           aPresContext,
     1:                                   const nsHTMLReflowState& aOuterRS,
     1:                                   nsIFrame*                aChildFrame,
     1:                                   nscoord                  aAvailWidth,
     1:                                   nsMargin&                aMargin)
     1: {
     1:   // construct a reflow state to compute margin and padding. Auto margins
     1:   // will not be computed at this time.
     1: 
     1:   // create and init the child reflow state
     1:   // XXX We really shouldn't construct a reflow state to do this.
     1:   nsHTMLReflowState childRS(aPresContext, aOuterRS, aChildFrame,
     1:                             nsSize(aAvailWidth, aOuterRS.availableHeight),
 80486:                             -1, -1, false);
     1:   InitChildReflowState(*aPresContext, childRS);
     1: 
     1:   aMargin = childRS.mComputedMargin;
     1: }
     1: 
     1: static nsSize
     1: GetContainingBlockSize(const nsHTMLReflowState& aOuterRS)
     1: {
     1:   nsSize size(0,0);
     1:   const nsHTMLReflowState* containRS =
     1:     aOuterRS.mCBReflowState;
     1: 
     1:   if (containRS) {
     1:     size.width = containRS->ComputedWidth();
     1:     if (NS_UNCONSTRAINEDSIZE == size.width) {
     1:       size.width = 0;
     1:     }
  4166:     size.height = containRS->ComputedHeight();
     1:     if (NS_UNCONSTRAINEDSIZE == size.height) {
     1:       size.height = 0;
     1:     }
     1:   }
     1:   return size;
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsTableOuterFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   nscoord width = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 78204:                     InnerTableFrame(), nsLayoutUtils::MIN_WIDTH);
     1:   DISPLAY_MIN_WIDTH(this, width);
 78204:   if (mCaptionFrames.NotEmpty()) {
     1:     nscoord capWidth =
 78204:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 78204:                                            mCaptionFrames.FirstChild(),
     1:                                            nsLayoutUtils::MIN_WIDTH);
 12309:     if (HasSideCaption()) {
     1:       width += capWidth;
 12309:     } else {
     1:       if (capWidth > width) {
     1:         width = capWidth;
     1:       }
     1:     }
     1:   }
     1:   return width;
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsTableOuterFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   nscoord maxWidth;
     1:   DISPLAY_PREF_WIDTH(this, maxWidth);
     1: 
     1:   maxWidth = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 78204:                InnerTableFrame(), nsLayoutUtils::PREF_WIDTH);
 78204:   if (mCaptionFrames.NotEmpty()) {
108991:     uint8_t captionSide = GetCaptionSide();
     1:     switch(captionSide) {
 12309:     case NS_STYLE_CAPTION_SIDE_LEFT:
 12309:     case NS_STYLE_CAPTION_SIDE_RIGHT:
     1:       {
     1:         nscoord capMin =
 78204:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 78204:                                                mCaptionFrames.FirstChild(),
     1:                                                nsLayoutUtils::MIN_WIDTH);
     1:         maxWidth += capMin;
     1:       }
     1:       break;
 12309:     default:
     1:       {
 12309:         nsLayoutUtils::IntrinsicWidthType iwt;
 12309:         if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 12309:             captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
 12309:           // Don't let the caption's pref width expand the table's pref
 12309:           // width.
 12309:           iwt = nsLayoutUtils::MIN_WIDTH;
 12309:         } else {
 12309:           NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
 12309:                        captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE,
 12309:                        "unexpected caption side");
 12309:           iwt = nsLayoutUtils::PREF_WIDTH;
 12309:         }
     1:         nscoord capPref =
 78204:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 78204:                                                mCaptionFrames.FirstChild(),
 12309:                                                iwt);
129543:         maxWidth = std::max(maxWidth, capPref);
     1:       }
 12309:       break;
     1:     }
     1:   }
     1:   return maxWidth;
     1: }
     1: 
 12402: // Compute the margin-box width of aChildFrame given the inputs.  If
 12402: // aMarginResult is non-null, fill it with the part of the margin-width
 12402: // that was contributed by the margin.
 12402: static nscoord
 68481: ChildShrinkWrapWidth(nsRenderingContext *aRenderingContext,
 12402:                      nsIFrame *aChildFrame,
 12402:                      nsSize aCBSize, nscoord aAvailableWidth,
106838:                      nscoord *aMarginResult = nullptr)
 12402: {
 98992:   AutoMaybeDisableFontInflation an(aChildFrame);
 88123: 
 12402:   nsCSSOffsetState offsets(aChildFrame, aRenderingContext, aCBSize.width);
 12402:   nsSize size = aChildFrame->ComputeSize(aRenderingContext, aCBSize,
 12402:                   aAvailableWidth,
 12402:                   nsSize(offsets.mComputedMargin.LeftRight(),
 12402:                          offsets.mComputedMargin.TopBottom()),
 12402:                   nsSize(offsets.mComputedBorderPadding.LeftRight() -
 12402:                            offsets.mComputedPadding.LeftRight(),
 12402:                          offsets.mComputedBorderPadding.TopBottom() -
 12402:                            offsets.mComputedPadding.TopBottom()),
 12402:                   nsSize(offsets.mComputedPadding.LeftRight(),
 12402:                          offsets.mComputedPadding.TopBottom()),
 80486:                   true);
 12402:   if (aMarginResult)
 12402:     *aMarginResult = offsets.mComputedMargin.LeftRight();
 12402:   return size.width + offsets.mComputedMargin.LeftRight() +
 12402:                       offsets.mComputedBorderPadding.LeftRight();
 12402: }
 12402: 
     1: /* virtual */ nsSize
 68481: nsTableOuterFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                                    nsSize aCBSize, nscoord aAvailableWidth,
     1:                                    nsSize aMargin, nsSize aBorder,
 79445:                                    nsSize aPadding, bool aShrinkWrap)
     1: {
 79490:   nscoord kidAvailableWidth = aAvailableWidth - aMargin.width;
 79490:   NS_ASSERTION(aBorder == nsSize(0, 0) &&
 79490:                aPadding == nsSize(0, 0),
 79490:                "Table outer frames cannot hae borders or paddings");
     1: 
     1:   // When we're shrink-wrapping, our auto size needs to wrap around the
     1:   // actual size of the table, which (if it is specified as a percent)
     1:   // could be something that is not reflected in our GetMinWidth and
     1:   // GetPrefWidth.  See bug 349457 for an example.
     1: 
 12402:   // Match the availableWidth logic in Reflow.
108991:   uint8_t captionSide = GetCaptionSide();
 12402:   nscoord width;
 12402:   if (captionSide == NO_SIDE) {
 78204:     width = ChildShrinkWrapWidth(aRenderingContext, InnerTableFrame(),
 79490:                                  aCBSize, kidAvailableWidth);
 12402:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
 12309:              captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
 78204:     nscoord capWidth = ChildShrinkWrapWidth(aRenderingContext,
 78204:                                             mCaptionFrames.FirstChild(),
 79490:                                             aCBSize, kidAvailableWidth);
 12402:     width = capWidth + ChildShrinkWrapWidth(aRenderingContext,
 78204:                                             InnerTableFrame(), aCBSize,
 79490:                                             kidAvailableWidth - capWidth);
 12402:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 12402:              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
 12402:     nscoord margin;
 78204:     width = ChildShrinkWrapWidth(aRenderingContext, InnerTableFrame(),
 79490:                                  aCBSize, kidAvailableWidth, &margin);
 12402:     nscoord capWidth = ChildShrinkWrapWidth(aRenderingContext,
 78204:                                             mCaptionFrames.FirstChild(), aCBSize,
 12402:                                             width - margin);
     1:     if (capWidth > width)
     1:       width = capWidth;
 12402:   } else {
 12402:     NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
 12402:                  captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE,
 12402:                  "unexpected caption-side");
 78204:     width = ChildShrinkWrapWidth(aRenderingContext, InnerTableFrame(),
 79490:                                  aCBSize, kidAvailableWidth);
 12402:     nscoord capWidth = ChildShrinkWrapWidth(aRenderingContext,
 78204:                                             mCaptionFrames.FirstChild(),
 79490:                                             aCBSize, kidAvailableWidth);
 12402:     if (capWidth > width)
 12402:       width = capWidth;
     1:   }
     1: 
     1:   return nsSize(width, NS_UNCONSTRAINEDSIZE);
     1: }
     1: 
108991: uint8_t
     1: nsTableOuterFrame::GetCaptionSide()
     1: {
 78204:   if (mCaptionFrames.NotEmpty()) {
132812:     return mCaptionFrames.FirstChild()->StyleTableBorder()->mCaptionSide;
     1:   }
     1:   else {
     1:     return NO_SIDE; // no caption
     1:   }
     1: }
     1: 
108991: uint8_t
     1: nsTableOuterFrame::GetCaptionVerticalAlign()
     1: {
 78204:   const nsStyleCoord& va =
132812:     mCaptionFrames.FirstChild()->StyleTextReset()->mVerticalAlign;
     1:   return (va.GetUnit() == eStyleUnit_Enumerated)
     1:            ? va.GetIntValue()
     1:            : NS_STYLE_VERTICAL_ALIGN_TOP;
     1: }
     1: 
     1: void
108991: nsTableOuterFrame::SetDesiredSize(uint8_t         aCaptionSide,
     1:                                   const nsMargin& aInnerMargin,
     1:                                   const nsMargin& aCaptionMargin,
     1:                                   nscoord&        aWidth,
     1:                                   nscoord&        aHeight)
     1: {
     1:   aWidth = aHeight = 0;
     1: 
 78204:   nsRect innerRect = InnerTableFrame()->GetRect();
     1:   nscoord innerWidth = innerRect.width;
     1: 
     1:   nsRect captionRect(0,0,0,0);
     1:   nscoord captionWidth = 0;
 78204:   if (mCaptionFrames.NotEmpty()) {
 78204:     captionRect = mCaptionFrames.FirstChild()->GetRect();
     1:     captionWidth = captionRect.width;
     1:   }
     1:   switch(aCaptionSide) {
 12309:     case NS_STYLE_CAPTION_SIDE_LEFT:
129543:       aWidth = std::max(aInnerMargin.left, aCaptionMargin.left + captionWidth + aCaptionMargin.right) +
     1:                innerWidth + aInnerMargin.right;
     1:       break;
 12309:     case NS_STYLE_CAPTION_SIDE_RIGHT:
129543:       aWidth = std::max(aInnerMargin.right, aCaptionMargin.left + captionWidth + aCaptionMargin.right) +
     1:                innerWidth + aInnerMargin.left;
     1:       break;
     1:     default:
     1:       aWidth = aInnerMargin.left + innerWidth + aInnerMargin.right;
129543:       aWidth = std::max(aWidth, captionRect.XMost() + aCaptionMargin.right);
     1:   }
     1:   aHeight = innerRect.YMost() + aInnerMargin.bottom;
 29651:   if (NS_STYLE_CAPTION_SIDE_BOTTOM != aCaptionSide) {
129543:     aHeight = std::max(aHeight, captionRect.YMost() + aCaptionMargin.bottom);
 29651:   }
 29651:   else {
129543:     aHeight = std::max(aHeight, captionRect.YMost() + aCaptionMargin.bottom +
 29651:                               aInnerMargin.bottom);
 29651:   }
     1: 
     1: }
     1: 
     1: nsresult 
108991: nsTableOuterFrame::GetCaptionOrigin(uint32_t         aCaptionSide,
     1:                                     const nsSize&    aContainBlockSize,
     1:                                     const nsSize&    aInnerSize, 
     1:                                     const nsMargin&  aInnerMargin,
     1:                                     const nsSize&    aCaptionSize,
     1:                                     nsMargin&        aCaptionMargin,
     1:                                     nsPoint&         aOrigin)
     1: {
     1:   aOrigin.x = aOrigin.y = 0;
     1:   if ((NS_UNCONSTRAINEDSIZE == aInnerSize.width) || (NS_UNCONSTRAINEDSIZE == aInnerSize.height) ||  
     1:       (NS_UNCONSTRAINEDSIZE == aCaptionSize.width) || (NS_UNCONSTRAINEDSIZE == aCaptionSize.height)) {
     1:     return NS_OK;
     1:   }
 78204:   if (mCaptionFrames.IsEmpty()) return NS_OK;
     1:   
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.left,   "The computed caption margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.top,    "The computed caption margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.bottom, "The computed caption margin is auto?");
 29651: 
 29651:   // horizontal computation
     1:   switch(aCaptionSide) {
 12309:   case NS_STYLE_CAPTION_SIDE_BOTTOM:
 12309:   case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
 29651:     // FIXME: Position relative to right edge for RTL.  (Based on table
 29651:     // direction or table parent direction?)
     1:     aOrigin.x = aCaptionMargin.left;
 12312:     if (aCaptionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
 12312:       // We placed the caption using only the table's width as available
 12312:       // width, and we should position it this way as well.
 12312:       aOrigin.x += aInnerMargin.left;
 12312:     }
 29651:   } break;
 29651:   case NS_STYLE_CAPTION_SIDE_LEFT: {
 29651:     aOrigin.x = aCaptionMargin.left;
 29651:   } break;
 29651:   case NS_STYLE_CAPTION_SIDE_RIGHT: {
 29651:     aOrigin.x = aInnerMargin.left + aInnerSize.width + aCaptionMargin.left;
 29651:   } break;
 29651:   default: { // top
 29651:     NS_ASSERTION(aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE,
 29651:                  "unexpected caption side");
 12312:     // FIXME: Position relative to right edge for RTL.  (Based on table
 12312:     // direction or table parent direction?)
 29651:     aOrigin.x = aCaptionMargin.left;
 29651:     if (aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP) {
 29651:       // We placed the caption using only the table's width as available
 29651:       // width, and we should position it this way as well.
 29651:       aOrigin.x += aInnerMargin.left;
     1:     }
 29651:     
     1:   } break;
     1:   }
 29651:   // vertical computation
 29651:   switch (aCaptionSide) {
 29651:     case NS_STYLE_CAPTION_SIDE_RIGHT:
 29651:     case NS_STYLE_CAPTION_SIDE_LEFT:
     1:       aOrigin.y = aInnerMargin.top;
     1:       switch (GetCaptionVerticalAlign()) {
     1:         case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
129543:           aOrigin.y = std::max(0, aInnerMargin.top + ((aInnerSize.height - aCaptionSize.height) / 2));
     1:           break;
     1:         case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
129543:           aOrigin.y = std::max(0, aInnerMargin.top + aInnerSize.height - aCaptionSize.height);
     1:           break;
     1:         default:
     1:           break;
     1:       }
 29651:       break;
 79490:     case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE:
 29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM: {
 29651:       aOrigin.y = aInnerMargin.top + aInnerSize.height + aCaptionMargin.top;
     1:     } break;
 79490:     case NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE:
 29651:     case NS_STYLE_CAPTION_SIDE_TOP: {
 29651:       aOrigin.y = aInnerMargin.top + aCaptionMargin.top;
 29651:     } break;
 29651:     default:
 29651:       NS_NOTREACHED("Unknown caption alignment type");
 29651:       break;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult 
108991: nsTableOuterFrame::GetInnerOrigin(uint32_t         aCaptionSide,
     1:                                   const nsSize&    aContainBlockSize,
     1:                                   const nsSize&    aCaptionSize, 
     1:                                   const nsMargin&  aCaptionMargin,
     1:                                   const nsSize&    aInnerSize,
     1:                                   nsMargin&        aInnerMargin,
     1:                                   nsPoint&         aOrigin)
     1: {
 29651:   
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.left,  "The computed caption margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.right, "The computed caption margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.left,    "The computed inner margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.right,   "The computed inner margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.top,     "The computed inner margin is auto?");
 29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.bottom,  "The computed inner margin is auto?");
 29651:   
     1:   aOrigin.x = aOrigin.y = 0;
     1:   if ((NS_UNCONSTRAINEDSIZE == aInnerSize.width) || (NS_UNCONSTRAINEDSIZE == aInnerSize.height) ||  
     1:       (NS_UNCONSTRAINEDSIZE == aCaptionSize.width) || (NS_UNCONSTRAINEDSIZE == aCaptionSize.height)) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nscoord minCapWidth = aCaptionSize.width;
 29651:   
     1:   minCapWidth += aCaptionMargin.left;
     1:   minCapWidth += aCaptionMargin.right;
     1: 
 29651:   // horizontal computation
     1:   switch (aCaptionSide) {
 12309:   case NS_STYLE_CAPTION_SIDE_LEFT: {
     1:     if (aInnerMargin.left < minCapWidth) {
     1:       // shift the inner table to get some place for the caption
     1:       aInnerMargin.right += aInnerMargin.left - minCapWidth;
129543:       aInnerMargin.right  = std::max(0, aInnerMargin.right);
     1:       aInnerMargin.left   = minCapWidth;
     1:     }
     1:     aOrigin.x = aInnerMargin.left;
 29651:   } break;
 29651:   default: {
 29651:     NS_ASSERTION(aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
 29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_BOTTOM ||
 29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE ||
 29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_RIGHT ||
 29651:                  aCaptionSide == NO_SIDE,
 29651:                  "unexpected caption side");
 29651:     aOrigin.x = aInnerMargin.left;
 29651:   } break;
     1:   }
 29651:   
 29651:   // vertical computation
 29651:   switch (aCaptionSide) {
 29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM:
 29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
 29651:       aOrigin.y = aInnerMargin.top;
 29651:     } break;
 29651:     case NS_STYLE_CAPTION_SIDE_LEFT:
 29651:     case NS_STYLE_CAPTION_SIDE_RIGHT: {
     1:       aOrigin.y = aInnerMargin.top;
     1:       switch (GetCaptionVerticalAlign()) {
     1:         case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
129543:           aOrigin.y = std::max(aInnerMargin.top, (aCaptionSize.height - aInnerSize.height) / 2);
     1:           break;
     1:         case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
129543:           aOrigin.y = std::max(aInnerMargin.top, aCaptionSize.height - aInnerSize.height);
     1:           break;
     1:         default:
     1:           break;
     1:       }
     1:     } break;
 29651:     case NO_SIDE:
 79490:     case NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE:
 29651:     case NS_STYLE_CAPTION_SIDE_TOP: {
 29651:       aOrigin.y = aInnerMargin.top + aCaptionMargin.top + aCaptionSize.height +
 29651:                   aCaptionMargin.bottom;
     1:     } break;
 29651:     default:
 29651:       NS_NOTREACHED("Unknown caption alignment type");
 29651:       break;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 12308: void
 12308: nsTableOuterFrame::OuterBeginReflowChild(nsPresContext*           aPresContext,
     1:                                          nsIFrame*                aChildFrame,
     1:                                          const nsHTMLReflowState& aOuterRS,
     1:                                          void*                    aChildRSSpace,
 12308:                                          nscoord                  aAvailWidth)
     1: { 
     1:   // work around pixel rounding errors, round down to ensure we don't exceed the avail height in
     1:   nscoord availHeight = aOuterRS.availableHeight;
     1:   if (NS_UNCONSTRAINEDSIZE != availHeight) {
 78204:     if (mCaptionFrames.FirstChild() == aChildFrame) {
  9571:       availHeight = NS_UNCONSTRAINEDSIZE;
  9571:     } else {
     1:       nsMargin margin;
 36583:       GetChildMargin(aPresContext, aOuterRS, aChildFrame,
 36583:                      aOuterRS.availableWidth, margin);
     1:     
     1:       NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.top, "No unconstrainedsize arithmetic, please");
     1:       availHeight -= margin.top;
     1:  
     1:       NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.bottom, "No unconstrainedsize arithmetic, please");
     1:       availHeight -= margin.bottom;
     1:     }
  9571:   }
     1:   nsSize availSize(aAvailWidth, availHeight);
     1:   // create and init the child reflow state, using placement new on
     1:   // stack space allocated by the caller, so that the caller can destroy
     1:   // it
     1:   nsHTMLReflowState &childRS = * new (aChildRSSpace)
     1:     nsHTMLReflowState(aPresContext, aOuterRS, aChildFrame, availSize,
 80486:                       -1, -1, false);
     1:   InitChildReflowState(*aPresContext, childRS);
     1: 
     1:   // see if we need to reset top of page due to a caption
 78204:   if (mCaptionFrames.NotEmpty()) {
108991:     uint8_t captionSide = GetCaptionSide();
 12309:     if (((captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM ||
 12309:           captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE) &&
 78204:          mCaptionFrames.FirstChild() == aChildFrame) || 
 12309:         ((captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 12309:           captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE) &&
 78204:          InnerTableFrame() == aChildFrame)) {
 80486:       childRS.mFlags.mIsTopOfPage = false;
     1:     }
     1:   }
     1: }
     1: 
 12308: nsresult
 12308: nsTableOuterFrame::OuterDoReflowChild(nsPresContext*             aPresContext,
 12308:                                       nsIFrame*                  aChildFrame,
 12308:                                       const nsHTMLReflowState&   aChildRS,
 12308:                                       nsHTMLReflowMetrics&       aMetrics,
 12308:                                       nsReflowStatus&            aStatus)
 12308: { 
 12308: 
     1:   // use the current position as a best guess for placement
     1:   nsPoint childPt = aChildFrame->GetPosition();
136175:   uint32_t flags = NS_FRAME_NO_MOVE_FRAME;
136175: 
136175:   // We don't want to delete our next-in-flow's child if it's an inner table
136175:   // frame, because outer table frames always assume that their inner table
136175:   // frames don't go away. If an outer table frame is removed because it is
136175:   // a next-in-flow of an already complete outer table frame, then it will
136175:   // take care of removing it's inner table frame.
136175:   if (aChildFrame == InnerTableFrame()) {
136175:     flags |= NS_FRAME_NO_DELETE_NEXT_IN_FLOW_CHILD;
136175:   }
136175: 
 12308:   return ReflowChild(aChildFrame, aPresContext, aMetrics, aChildRS,
136175:                      childPt.x, childPt.y, flags, aStatus);
     1: }
     1: 
     1: void 
108991: nsTableOuterFrame::UpdateReflowMetrics(uint8_t              aCaptionSide,
     1:                                        nsHTMLReflowMetrics& aMet,
     1:                                        const nsMargin&      aInnerMargin,
     1:                                        const nsMargin&      aCaptionMargin)
     1: {
     1:   SetDesiredSize(aCaptionSide, aInnerMargin, aCaptionMargin,
     1:                  aMet.width, aMet.height);
     1: 
 55039:   aMet.SetOverflowAreasToDesiredBounds();
 78204:   ConsiderChildOverflow(aMet.mOverflowAreas, InnerTableFrame());
 78204:   if (mCaptionFrames.NotEmpty()) {
 78204:     ConsiderChildOverflow(aMet.mOverflowAreas, mCaptionFrames.FirstChild());
     1:   }
     1: }
     1: 
     1: NS_METHOD nsTableOuterFrame::Reflow(nsPresContext*           aPresContext,
     1:                                     nsHTMLReflowMetrics&     aDesiredSize,
     1:                                     const nsHTMLReflowState& aOuterRS,
     1:                                     nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsTableOuterFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aOuterRS, aDesiredSize, aStatus);
     1: 
     1:   nsresult rv = NS_OK;
108991:   uint8_t captionSide = GetCaptionSide();
     1: 
     1:   // Initialize out parameters
     1:   aDesiredSize.width = aDesiredSize.height = 0;
     1:   aStatus = NS_FRAME_COMPLETE;
     1: 
     1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     1:     // Set up our kids.  They're already present, on an overflow list, 
     1:     // or there are none so we'll create them now
     1:     MoveOverflowToChildList(aPresContext);
     1:   }
     1: 
     1:   // Use longs to get more-aligned space.
     1:   #define LONGS_IN_HTMLRS \
     1:     ((sizeof(nsHTMLReflowState) + sizeof(long) - 1) / sizeof(long))
     1:   long captionRSSpace[LONGS_IN_HTMLRS];
 12308:   nsHTMLReflowState *captionRS =
 12308:     static_cast<nsHTMLReflowState*>((void*)captionRSSpace);
 12309:   long innerRSSpace[LONGS_IN_HTMLRS];
 12309:   nsHTMLReflowState *innerRS =
 12309:     static_cast<nsHTMLReflowState*>((void*) innerRSSpace);
 12309: 
115328:   nsRect origInnerRect = InnerTableFrame()->GetRect();
115328:   nsRect origInnerVisualOverflow = InnerTableFrame()->GetVisualOverflowRect();
115328:   bool innerFirstReflow =
115328:     (InnerTableFrame()->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
115328:   nsRect origCaptionRect;
115328:   nsRect origCaptionVisualOverflow;
115328:   bool captionFirstReflow;
115328:   if (mCaptionFrames.NotEmpty()) {
115328:     origCaptionRect = mCaptionFrames.FirstChild()->GetRect();
115328:     origCaptionVisualOverflow =
115328:       mCaptionFrames.FirstChild()->GetVisualOverflowRect();
115328:     captionFirstReflow =
115328:       (mCaptionFrames.FirstChild()->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
115328:   }
115328:   
 12402:   // ComputeAutoSize has to match this logic.
 12309:   if (captionSide == NO_SIDE) {
 12309:     // We don't have a caption.
 78204:     OuterBeginReflowChild(aPresContext, InnerTableFrame(), aOuterRS,
 12309:                           innerRSSpace, aOuterRS.ComputedWidth());
 12309:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
 12309:              captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
 12309:     // nsTableCaptionFrame::ComputeAutoSize takes care of making side
 12309:     // captions small.  Compute the caption's size first, and tell the
 12309:     // table to fit in what's left.
 78204:     OuterBeginReflowChild(aPresContext, mCaptionFrames.FirstChild(), aOuterRS,
 12308:                           captionRSSpace, aOuterRS.ComputedWidth());
 12309:     nscoord innerAvailWidth = aOuterRS.ComputedWidth() -
 12309:       (captionRS->ComputedWidth() + captionRS->mComputedMargin.LeftRight() +
 12309:        captionRS->mComputedBorderPadding.LeftRight());
 78204:     OuterBeginReflowChild(aPresContext, InnerTableFrame(), aOuterRS,
 12309:                           innerRSSpace, innerAvailWidth);
 12309: 
 12309:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
 12309:              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
 12309:     // Compute the table's size first, and then prevent the caption from
 12309:     // being wider unless it has to be.
 12309:     //
 12309:     // Note that CSS 2.1 (but not 2.0) says:
 12309:     //   The width of the anonymous box is the border-edge width of the
 12309:     //   table box inside it
 12309:     // We don't actually make our anonymous box that width (if we did,
 12309:     // it would break 'auto' margins), but this effectively does that.
 78204:     OuterBeginReflowChild(aPresContext, InnerTableFrame(), aOuterRS,
 12309:                           innerRSSpace, aOuterRS.ComputedWidth());
 12309:     // It's good that CSS 2.1 says not to include margins, since we
 12309:     // can't, since they already been converted so they exactly
 12309:     // fill the available width (ignoring the margin on one side if
 12312:     // neither are auto).  (We take advantage of that later when we call
 12312:     // GetCaptionOrigin, though.)
 12309:     nscoord innerBorderWidth = innerRS->ComputedWidth() +
 12309:                                innerRS->mComputedBorderPadding.LeftRight();
 78204:     OuterBeginReflowChild(aPresContext, mCaptionFrames.FirstChild(), aOuterRS,
 12309:                           captionRSSpace, innerBorderWidth);
 12309:   } else {
 12309:     NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
 12309:                  captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE,
 12309:                  "unexpected caption-side");
 12309:     // Size the table and the caption independently.
 78204:     OuterBeginReflowChild(aPresContext, mCaptionFrames.FirstChild(), aOuterRS,
 12309:                           captionRSSpace, aOuterRS.ComputedWidth());
 78204:     OuterBeginReflowChild(aPresContext, InnerTableFrame(), aOuterRS,
 12309:                           innerRSSpace, aOuterRS.ComputedWidth());
 12309:   }
 12309: 
 12309:   // First reflow the caption.
 12309:   nsHTMLReflowMetrics captionMet;
 12309:   nsSize captionSize;
 12309:   nsMargin captionMargin;
 78204:   if (mCaptionFrames.NotEmpty()) {
 12309:     nsReflowStatus capStatus; // don't let the caption cause incomplete
 78204:     rv = OuterDoReflowChild(aPresContext, mCaptionFrames.FirstChild(),
 78204:                             *captionRS, captionMet, capStatus);
     1:     if (NS_FAILED(rv)) return rv;
 12308:     captionSize.width = captionMet.width;
 12308:     captionSize.height = captionMet.height;
 12308:     captionMargin = captionRS->mComputedMargin;
 74400:     // Now that we know the height of the caption, reduce the available height
 74400:     // for the table frame if we are height constrained and the caption is above
 74400:     // or below the inner table.
 74400:     if (NS_UNCONSTRAINEDSIZE != aOuterRS.availableHeight) {
 74400:       nscoord captionHeight = 0;
 74400:       switch (captionSide) {
 74400:         case NS_STYLE_CAPTION_SIDE_TOP:
 79490:         case NS_STYLE_CAPTION_SIDE_BOTTOM:
 79490:         case NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE:
 79490:         case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
 74400:           captionHeight = captionSize.height + captionMargin.TopBottom();
 74400:           break;
 74400:         }
 74400:       }
 74400:       innerRS->availableHeight =
129543:         std::max(0, innerRS->availableHeight - captionHeight);
 74400:     }
     1:   } else {
     1:     captionSize.SizeTo(0,0);
     1:     captionMargin.SizeTo(0,0,0,0);
     1:   }
     1: 
     1:   // Then, now that we know how much to reduce the width of the inner
     1:   // table to account for side captions, reflow the inner table.
     1:   nsHTMLReflowMetrics innerMet;
 78204:   rv = OuterDoReflowChild(aPresContext, InnerTableFrame(), *innerRS,
 12308:                           innerMet, aStatus);
     1:   if (NS_FAILED(rv)) return rv;
 12309:   nsSize innerSize;
 12308:   innerSize.width = innerMet.width;
 12308:   innerSize.height = innerMet.height;
 12309:   nsMargin innerMargin = innerRS->mComputedMargin;
     1: 
     1:   nsSize   containSize = GetContainingBlockSize(aOuterRS);
     1: 
     1:   // Now that we've reflowed both we can place them.
     1:   // XXXldb Most of the input variables here are now uninitialized!
     1: 
     1:   // XXX Need to recompute inner table's auto margins for the case of side
     1:   // captions.  (Caption's are broken too, but that should be fixed earlier.)
     1: 
 78204:   if (mCaptionFrames.NotEmpty()) {
     1:     nsPoint captionOrigin;
     1:     GetCaptionOrigin(captionSide, containSize, innerSize, 
     1:                      innerMargin, captionSize, captionMargin, captionOrigin);
 78204:     FinishReflowChild(mCaptionFrames.FirstChild(), aPresContext, captionRS,
 78204:                       captionMet, captionOrigin.x, captionOrigin.y, 0);
     1:     captionRS->~nsHTMLReflowState();
     1:   }
     1:   // XXX If the height is constrained then we need to check whether
     1:   // everything still fits...
     1: 
     1:   nsPoint innerOrigin;
     1:   GetInnerOrigin(captionSide, containSize, captionSize, 
     1:                  captionMargin, innerSize, innerMargin, innerOrigin);
 78204:   FinishReflowChild(InnerTableFrame(), aPresContext, innerRS, innerMet,
     1:                     innerOrigin.x, innerOrigin.y, 0);
     1:   innerRS->~nsHTMLReflowState();
     1: 
115328:   nsTableFrame::InvalidateTableFrame(InnerTableFrame(), origInnerRect,
115328:                                      origInnerVisualOverflow, innerFirstReflow);
115328:   if (mCaptionFrames.NotEmpty()) {
115328:     nsTableFrame::InvalidateTableFrame(mCaptionFrames.FirstChild(), origCaptionRect,
115328:                                        origCaptionVisualOverflow,
115328:                                        captionFirstReflow);
115328:   }
115328: 
     1:   UpdateReflowMetrics(captionSide, aDesiredSize, innerMargin, captionMargin);
136175: 
136175:   if (GetPrevInFlow()) {
136175:     ReflowOverflowContainerChildren(aPresContext, aOuterRS,
136175:                                     aDesiredSize.mOverflowAreas, 0,
136175:                                     aStatus);
136175:   }
136175: 
 79486:   FinishReflowWithAbsoluteFrames(aPresContext, aDesiredSize, aOuterRS, aStatus);
     1: 
     1:   // Return our desired rect
     1: 
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aOuterRS, aDesiredSize);
     1:   return rv;
     1: }
     1: 
     1: nsIAtom*
     1: nsTableOuterFrame::GetType() const
     1: {
     1:   return nsGkAtoms::tableOuterFrame;
     1: }
     1: 
     1: /* ----- global methods ----- */
     1: 
125899: nsIContent*
125899: nsTableOuterFrame::GetCellAt(uint32_t aRowIdx, uint32_t aColIdx) const
     1: {
125899:   nsTableCellMap* cellMap = InnerTableFrame()->GetCellMap();
125899:   if (!cellMap) {
125899:     return nullptr;
     1:   }
     1: 
125899:   nsTableCellFrame* cell = cellMap->GetCellInfoAt(aRowIdx, aColIdx);
125899:   if (!cell) {
125899:     return nullptr;
     1:   }
 11311: 
125899:   return cell->GetContent();
 11311: }
 11311: 
     1: 
     1: nsIFrame*
     1: NS_NewTableOuterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsTableOuterFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableOuterFrame)
 32423: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsTableOuterFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("TableOuter"), aResult);
     1: }
     1: #endif
     1: 
