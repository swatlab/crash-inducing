    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // NOTE: alphabetically ordered
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsAccessibilityService.h"
20521: #include "nsCoreUtils.h"
20536: #include "nsAccUtils.h"
31732: #include "nsApplicationAccessibleWrap.h"
29269: #include "nsARIAGridAccessibleWrap.h"
 7830: #include "nsARIAMap.h"
12240: #include "nsIContentViewer.h"
    1: #include "nsCURILoader.h"
    1: #include "nsDocAccessible.h"
40461: #include "nsHTMLImageMapAccessible.h"
    1: #include "nsHTMLLinkAccessible.h"
    1: #include "nsHTMLSelectAccessible.h"
 1133: #include "nsHTMLTableAccessibleWrap.h"
    1: #include "nsHTMLTextAccessible.h"
  966: #include "nsHyperTextAccessibleWrap.h"
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleProvider.h"
67790: #include "States.h"
40461: 
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLOptGroupElement.h"
    1: #include "nsIDOMHTMLOptionElement.h"
    1: #include "nsIDOMXULElement.h"
40461: #include "nsIHTMLDocument.h"
69187: #include "nsImageFrame.h"
    1: #include "nsILink.h"
    1: #include "nsIObserverService.h"
70007: #include "nsNPAPIPluginInstance.h"
    1: #include "nsISupportsUtils.h"
    1: #include "nsObjectFrame.h"
    1: #include "nsOuterDocAccessible.h"
    1: #include "nsRootAccessibleWrap.h"
    1: #include "nsTextFragment.h"
41540: #include "mozilla/Services.h"
68780: #include "nsEventStates.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsXULAlertAccessible.h"
    1: #include "nsXULColorPickerAccessible.h"
32381: #include "nsXULComboboxAccessible.h"
    1: #include "nsXULFormControlAccessible.h"
32381: #include "nsXULListboxAccessibleWrap.h"
    1: #include "nsXULMenuAccessibleWrap.h"
 4274: #include "nsXULSliderAccessible.h"
    1: #include "nsXULTabAccessible.h"
    1: #include "nsXULTextAccessible.h"
32381: #include "nsXULTreeGridAccessibleWrap.h"
    1: #endif
    1: 
    1: // For native window support for object/embed/applet tags
    1: #ifdef XP_WIN
    1: #include "nsHTMLWin32ObjectAccessible.h"
    1: #endif
    1: 
69027: // For embedding plugin accessibles
69027: #ifdef MOZ_ACCESSIBILITY_ATK
69027: #include "AtkSocketAccessible.h"
69027: #endif
69027: 
    1: #ifndef DISABLE_XFORMS_HOOKS
    1: #include "nsXFormsFormControlsAccessible.h"
    1: #include "nsXFormsWidgetsAccessible.h"
    1: #endif
    1: 
42480: #include "mozilla/FunctionTimer.h"
64096: #include "mozilla/dom/Element.h"
42480: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsAccessibilityService
38359: ////////////////////////////////////////////////////////////////////////////////
38359: 
    1: nsAccessibilityService *nsAccessibilityService::gAccessibilityService = nsnull;
30820: PRBool nsAccessibilityService::gIsShutdown = PR_TRUE;
    1: 
43310: nsAccessibilityService::nsAccessibilityService() : nsAccDocManager()
    1: {
42480:   NS_TIME_FUNCTION;
    1: }
    1: 
    1: nsAccessibilityService::~nsAccessibilityService()
    1: {
30820:   NS_ASSERTION(gIsShutdown, "Accessibility wasn't shutdown!");
30820:   gAccessibilityService = nsnull;
    1: }
    1: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsISupports
    1: 
43310: NS_IMPL_ISUPPORTS_INHERITED3(nsAccessibilityService,
43310:                              nsAccDocManager,
43310:                              nsIAccessibilityService,
43310:                              nsIAccessibleRetrieval,
43310:                              nsIObserver)
38359: 
38359: ////////////////////////////////////////////////////////////////////////////////
    1: // nsIObserver
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibilityService::Observe(nsISupports *aSubject, const char *aTopic,
    1:                          const PRUnichar *aData)
    1: {
43310:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))
43310:     Shutdown();
30820: 
    1:   return NS_OK;
    1: }
    1: 
38359: // nsIAccessibilityService
41476: void
61201: nsAccessibilityService::NotifyOfAnchorJumpTo(nsIContent* aTargetNode)
34455: {
61201:   nsIDocument* documentNode = aTargetNode->GetCurrentDoc();
61201:   if (documentNode) {
61201:     nsDocAccessible* document = GetDocAccessible(documentNode);
61201:     if (document)
61201:       document->HandleAnchorJump(aTargetNode);
61201:   }
34455: }
34455: 
38359: // nsIAccessibilityService
54519: void
21255: nsAccessibilityService::FireAccessibleEvent(PRUint32 aEvent,
54519:                                             nsAccessible* aTarget)
21255: {
54519:   nsEventShell::FireEvent(aEvent, aTarget);
21255: }
21255: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsIAccessibilityService
    1: 
54519: nsAccessible*
54519: nsAccessibilityService::GetRootDocumentAccessible(nsIPresShell* aPresShell,
54519:                                                   PRBool aCanCreate)
54519: {
54519:   nsIDocument* documentNode = aPresShell->GetDocument();
54519:   if (documentNode) {
54519:     nsCOMPtr<nsISupports> container = documentNode->GetContainer();
54519:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
54519:     if (treeItem) {
54519:       nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
54519:       treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
54519:       if (treeItem != rootTreeItem) {
54519:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(rootTreeItem));
54519:         nsCOMPtr<nsIPresShell> presShell;
54519:         docShell->GetPresShell(getter_AddRefs(presShell));
54519:         documentNode = presShell->GetDocument();
54519:       }
54519: 
54519:       return aCanCreate ?
54519:         GetDocAccessible(documentNode) : GetDocAccessibleFromCache(documentNode);
54519:     }
54519:   }
54519:   return nsnull;
54519: }
54519: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateOuterDocAccessible(nsIContent* aContent,
46338:                                                  nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsOuterDocAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTML4ButtonAccessible(nsIContent* aContent,
46338:                                                     nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTML4ButtonAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLButtonAccessible(nsIContent* aContent,
46338:                                                    nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLButtonAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
38359: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLLIAccessible(nsIContent* aContent,
55763:                                                nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
55763:   nsAccessible* accessible = new nsHTMLLIAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
28316: }
28316: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHyperTextAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
46338: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHyperTextAccessibleWrap(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLCheckboxAccessible(nsIContent* aContent,
46338:                                                      nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLCheckboxAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLComboboxAccessible(nsIContent* aContent,
46338:                                                      nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLComboboxAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLImageAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
40461:   nsAutoString mapElmName;
64436:   aContent->GetAttr(kNameSpaceID_None,
64436:                     nsAccessibilityAtoms::usemap,
40461:                     mapElmName);
71031:   nsCOMPtr<nsIDOMHTMLMapElement> mapElm;
71031:   if (nsIDocument* document = aContent->GetCurrentDoc()) {
71031:     mapElm = do_QueryInterface(document->FindImageMap(mapElmName));
71031:   }
    1: 
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = mapElm ?
46338:     new nsHTMLImageMapAccessible(aContent, weakShell, mapElm) :
46338:     new nsHTMLImageAccessibleWrap(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLGroupboxAccessible(nsIContent* aContent,
46338:                                                      nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLGroupboxAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLListboxAccessible(nsIContent* aContent,
46338:                                                     nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLSelectListAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLMediaAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsEnumRoleAccessible(aContent, weakShell,
46338:                                                       nsIAccessibleRole::ROLE_GROUPING);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLObjectFrameAccessible(nsObjectFrame* aFrame,
46338:                                                         nsIContent* aContent,
46338:                                                         nsIPresShell* aPresShell)
27515: {
46338:   // We can have several cases here:
46338:   // 1) a text or html embedded document where the contentDocument variable in
46338:   //    the object element holds the content;
46338:   // 2) web content that uses a plugin, which means we will have to go to
46338:   //    the plugin to get the accessible content;
46338:   // 3) an image or imagemap, where the image frame points back to the object
46338:   //    element DOMNode.
27515: 
46338:   if (aFrame->GetRect().IsEmpty())
46338:     return nsnull;
27515: 
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
27515: 
    1:   // 1) for object elements containing either HTML or TXT documents
46338:   nsCOMPtr<nsIDOMHTMLObjectElement> obj(do_QueryInterface(aContent));
43504:   if (obj) {
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     obj->GetContentDocument(getter_AddRefs(domDoc));
46338:     if (domDoc)
46338:       return CreateOuterDocAccessible(aContent, aPresShell);
43504:   }
    1: 
69027: #if defined(XP_WIN) || defined(MOZ_ACCESSIBILITY_ATK)
    1:   // 2) for plugins
70007:   nsRefPtr<nsNPAPIPluginInstance> pluginInstance;
70007:   if (NS_SUCCEEDED(aFrame->GetPluginInstance(getter_AddRefs(pluginInstance))) &&
69027:       pluginInstance) {
69027: #ifdef XP_WIN
33872:     // Note: pluginPort will be null if windowless.
    1:     HWND pluginPort = nsnull;
    1:     aFrame->GetPluginPort(&pluginPort);
33872: 
46338:     nsAccessible* accessible = new nsHTMLWin32ObjectOwnerAccessible(aContent,
46338:                                                                     weakShell,
46338:                                                                     pluginPort);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
69027: 
69027: #elif MOZ_ACCESSIBILITY_ATK
69027:     if (!AtkSocketAccessible::gCanEmbed)
69027:       return nsnull;
69027: 
69027:     nsCString plugId;
69027:     nsresult rv = pluginInstance->GetValueFromPlugin(
69027:       NPPVpluginNativeAccessibleAtkPlugId, &plugId);
69027:     if (NS_SUCCEEDED(rv) && !plugId.IsVoid()) {
69027:       AtkSocketAccessible* socketAccessible =
69027:         new AtkSocketAccessible(aContent, weakShell, plugId);
69027: 
69027:       NS_IF_ADDREF(socketAccessible);
69027:       return socketAccessible;
69027:     }
69027: #endif
    1:   }
    1: #endif
    1: 
    1:   // 3) for images and imagemaps, or anything else with a child frame
    1:   // we have the object frame, get the image frame
23554:   nsIFrame* frame = aFrame->GetFirstChild(nsnull);
46338:   return frame ? frame->CreateAccessible() : nsnull;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLRadioButtonAccessible(nsIContent* aContent,
46338:                                                         nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLRadioButtonAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTableAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLTableAccessibleWrap(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
43504: }
43504: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTableCellAccessible(nsIContent* aContent,
46338:                                                       nsIPresShell* aPresShell)
43504: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLTableCellAccessibleWrap(aContent,
46338:                                                                weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
43504: }
43504: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTextAccessible(nsIContent* aContent,
46338:                                                  nsIPresShell* aPresShell)
43504: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLTextAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
43504: }
43504: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTextFieldAccessible(nsIContent* aContent,
46338:                                                       nsIPresShell* aPresShell)
43504: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLTextFieldAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLLabelAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLLabelAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLHRAccessible(nsIContent* aContent,
46338:                                                nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLHRAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLBRAccessible(nsIContent* aContent,
46338:                                                nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLBRAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLCaptionAccessible(nsIContent* aContent,
46338:                                                     nsIPresShell* aPresShell)
    1: {
46338:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
46338:   nsAccessible* accessible = new nsHTMLCaptionAccessible(aContent, weakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
 3151: }
 3151: 
43765: void
56292: nsAccessibilityService::ContentRangeInserted(nsIPresShell* aPresShell,
56292:                                              nsIContent* aContainer,
56292:                                              nsIContent* aStartChild,
56292:                                              nsIContent* aEndChild)
56292: {
56987: #ifdef DEBUG_CONTENTMUTATION
56292:   nsAutoString tag;
56292:   aStartChild->Tag()->ToString(tag);
56987: 
56987:   nsIAtom* atomid = aStartChild->GetID();
56987:   nsCAutoString id;
56987:   if (atomid)
56987:     atomid->ToUTF8String(id);
56987: 
56292:   nsAutoString ctag;
56987:   nsCAutoString cid;
56987:   nsIAtom* catomid = nsnull;
56987:   if (aContainer) {
56292:     aContainer->Tag()->ToString(ctag);
56987:     catomid = aContainer->GetID();
56987:     if (catomid)
56987:       catomid->ToUTF8String(cid);
56987:   }
56987: 
56292:   printf("\ncontent inserted: %s@id='%s', container: %s@id='%s', end node: %p\n\n",
56987:          NS_ConvertUTF16toUTF8(tag).get(), id.get(),
56987:          NS_ConvertUTF16toUTF8(ctag).get(), cid.get(), aEndChild);
56292: #endif
56292: 
56292:   nsDocAccessible* docAccessible = GetDocAccessible(aPresShell->GetDocument());
56292:   if (docAccessible)
60746:     docAccessible->ContentInserted(aContainer, aStartChild, aEndChild);
56292: }
56292: 
56292: void
56292: nsAccessibilityService::ContentRemoved(nsIPresShell* aPresShell,
56292:                                        nsIContent* aContainer,
56292:                                        nsIContent* aChild)
56292: {
56987: #ifdef DEBUG_CONTENTMUTATION
56987:   nsAutoString tag;
56987:   aChild->Tag()->ToString(tag);
56987: 
56987:   nsIAtom* atomid = aChild->GetID();
56987:   nsCAutoString id;
56987:   if (atomid)
56987:     atomid->ToUTF8String(id);
56987: 
56987:   nsAutoString ctag;
56987:   nsCAutoString cid;
56987:   nsIAtom* catomid = nsnull;
56987:   if (aContainer) {
56987:     aContainer->Tag()->ToString(ctag);
56987:     catomid = aContainer->GetID();
56987:     if (catomid)
56987:       catomid->ToUTF8String(cid);
56987:   }
56987: 
56987:   printf("\ncontent removed: %s@id='%s', container: %s@id='%s'\n\n",
56987:            NS_ConvertUTF16toUTF8(tag).get(), id.get(),
56987:            NS_ConvertUTF16toUTF8(ctag).get(), cid.get());
56292: #endif
56292: 
56292:   nsDocAccessible* docAccessible = GetDocAccessible(aPresShell->GetDocument());
56292:   if (docAccessible)
60746:     docAccessible->ContentRemoved(aContainer, aChild);
56292: }
56292: 
56292: void
61516: nsAccessibilityService::UpdateText(nsIPresShell* aPresShell,
61516:                                    nsIContent* aContent)
61516: {
61516:   nsDocAccessible* document = GetDocAccessible(aPresShell->GetDocument());
61516:   if (document)
61516:     document->UpdateText(aContent);
61516: }
61516: 
61516: void
64006: nsAccessibilityService::UpdateListBullet(nsIPresShell* aPresShell,
64006:                                          nsIContent* aHTMLListItemContent,
64006:                                          bool aHasBullet)
64006: {
64006:   nsDocAccessible* document = GetDocAccessible(aPresShell->GetDocument());
64006:   if (document) {
64006:     nsAccessible* accessible = document->GetAccessible(aHTMLListItemContent);
64006:     if (accessible) {
64006:       nsHTMLLIAccessible* listItem = accessible->AsHTMLListItem();
64006:       if (listItem)
64006:         listItem->UpdateBullet(aHasBullet);
64006:     }
64006:   }
64006: }
64006: 
64006: void
43765: nsAccessibilityService::PresShellDestroyed(nsIPresShell *aPresShell)
43765: {
43765:   // Presshell destruction will automatically destroy shells for descendant
43765:   // documents, so no need to worry about those. Just shut down the accessible
43765:   // for this one document. That keeps us from having bad behavior in case of
43765:   // deep bushy subtrees.
43765:   // When document subtree containing iframe is hidden then we don't get
43765:   // pagehide event for the iframe's underlying document and its presshell is
43765:   // destroyed before we're notified styles were changed. Shutdown the document
43765:   // accessible early.
43765:   nsIDocument* doc = aPresShell->GetDocument();
43765:   if (!doc)
43765:     return;
43765: 
43765:   NS_LOG_ACCDOCDESTROY("presshell destroyed", doc)
56639: 
56639:   nsDocAccessible* docAccessible = GetDocAccessibleFromCache(doc);
56639:   if (docAccessible)
56639:     docAccessible->Shutdown();
43765: }
43765: 
56292: void
63261: nsAccessibilityService::PresShellActivated(nsIPresShell* aPresShell)
63261: {
63261:   nsIDocument* DOMDoc = aPresShell->GetDocument();
63261:   if (DOMDoc) {
63261:     nsDocAccessible* document = GetDocAccessibleFromCache(DOMDoc);
63261:     if (document) {
63261:       nsRootAccessible* rootDocument = document->RootAccessible();
63261:       NS_ASSERTION(rootDocument, "Entirely broken tree: no root document!");
63261:       if (rootDocument)
63261:         rootDocument->DocumentActivated(document);
63261:     }
63261:   }
63261: }
63261: 
63261: void
56292: nsAccessibilityService::RecreateAccessible(nsIPresShell* aPresShell,
56292:                                            nsIContent* aContent)
56292: {
56292:   nsDocAccessible* document = GetDocAccessible(aPresShell->GetDocument());
61681:   if (document) {
61681:     document->HandleNotification<nsDocAccessible, nsIContent>
61681:       (document, &nsDocAccessible::RecreateAccessible, aContent);
61681:   }
56292: }
56292: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsIAccessibleRetrieval
38359: 
 2064: NS_IMETHODIMP
39600: nsAccessibilityService::GetApplicationAccessible(nsIAccessible **aAccessibleApplication)
39567: {
39600:   NS_ENSURE_ARG_POINTER(aAccessibleApplication);
39567: 
39600:   NS_IF_ADDREF(*aAccessibleApplication = nsAccessNode::GetApplicationAccessible());
39600:   return NS_OK;
39567: }
39567: 
39567: NS_IMETHODIMP
43504: nsAccessibilityService::GetAccessibleFor(nsIDOMNode *aNode,
43504:                                          nsIAccessible **aAccessible)
43504: {
43504:   NS_ENSURE_ARG_POINTER(aAccessible);
72710:   *aAccessible = nsnull;
72710:   if (!aNode)
72710:     return NS_OK;
43504: 
43504:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
43504:   NS_IF_ADDREF(*aAccessible = GetAccessible(node));
43504:   return NS_OK;
43504: }
43504: 
43504: NS_IMETHODIMP
 2064: nsAccessibilityService::GetStringRole(PRUint32 aRole, nsAString& aString)
 2064: {
 2064:   if ( aRole >= NS_ARRAY_LENGTH(kRoleNames)) {
 2064:     aString.AssignLiteral("unknown");
 2064:     return NS_OK;
 2064:   }
 2064: 
 2064:   CopyUTF8toUTF16(kRoleNames[aRole], aString);
 2064:   return NS_OK;
 2064: }
 2064: 
 2064: NS_IMETHODIMP
67790: nsAccessibilityService::GetStringStates(PRUint32 aState, PRUint32 aExtraState,
 2064:                                         nsIDOMDOMStringList **aStringStates)
 2064: {
 2064:   nsAccessibleDOMStringList *stringStates = new nsAccessibleDOMStringList();
 2064:   NS_ENSURE_TRUE(stringStates, NS_ERROR_OUT_OF_MEMORY);
 2064: 
67790:   PRUint64 state = nsAccUtils::To64State(aState, aExtraState);
67790: 
 2064:   // states
67790:   if (state & states::UNAVAILABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("unavailable"));
67790:   if (state & states::SELECTED)
 2064:     stringStates->Add(NS_LITERAL_STRING("selected"));
67790:   if (state & states::FOCUSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("focused"));
67790:   if (state & states::PRESSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("pressed"));
67790:   if (state & states::CHECKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("checked"));
67790:   if (state & states::MIXED)
 2064:     stringStates->Add(NS_LITERAL_STRING("mixed"));
67790:   if (state & states::READONLY)
 2064:     stringStates->Add(NS_LITERAL_STRING("readonly"));
67790:   if (state & states::HOTTRACKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("hottracked"));
67790:   if (state & states::DEFAULT)
 2064:     stringStates->Add(NS_LITERAL_STRING("default"));
67790:   if (state & states::EXPANDED)
 2064:     stringStates->Add(NS_LITERAL_STRING("expanded"));
67790:   if (state & states::COLLAPSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("collapsed"));
67790:   if (state & states::BUSY)
 2064:     stringStates->Add(NS_LITERAL_STRING("busy"));
67790:   if (state & states::FLOATING)
 2064:     stringStates->Add(NS_LITERAL_STRING("floating"));
67790:   if (state & states::ANIMATED)
 2064:     stringStates->Add(NS_LITERAL_STRING("animated"));
67790:   if (state & states::INVISIBLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("invisible"));
67790:   if (state & states::OFFSCREEN)
 2064:     stringStates->Add(NS_LITERAL_STRING("offscreen"));
67790:   if (state & states::SIZEABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("sizeable"));
67790:   if (state & states::MOVEABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("moveable"));
67790:   if (state & states::SELFVOICING)
 2064:     stringStates->Add(NS_LITERAL_STRING("selfvoicing"));
67790:   if (state & states::FOCUSABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("focusable"));
67790:   if (state & states::SELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("selectable"));
67790:   if (state & states::LINKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("linked"));
67790:   if (state & states::TRAVERSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("traversed"));
67790:   if (state & states::MULTISELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("multiselectable"));
67790:   if (state & states::EXTSELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("extselectable"));
67790:   if (state & states::PROTECTED)
 2064:     stringStates->Add(NS_LITERAL_STRING("protected"));
67790:   if (state & states::HASPOPUP)
 2064:     stringStates->Add(NS_LITERAL_STRING("haspopup"));
67790:   if (state & states::REQUIRED)
 2064:     stringStates->Add(NS_LITERAL_STRING("required"));
67790:   if (state & states::ALERT)
67790:     stringStates->Add(NS_LITERAL_STRING("alert"));
67790:   if (state & states::INVALID)
 2064:     stringStates->Add(NS_LITERAL_STRING("invalid"));
67790:   if (state & states::CHECKABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("checkable"));
 2064: 
 2064:   // extraStates
67790:   if (state & states::SUPPORTS_AUTOCOMPLETION)
 3513:     stringStates->Add(NS_LITERAL_STRING("autocompletion"));
67790:   if (state & states::DEFUNCT)
 3513:     stringStates->Add(NS_LITERAL_STRING("defunct"));
67790:   if (state & states::SELECTABLE_TEXT)
 2064:     stringStates->Add(NS_LITERAL_STRING("selectable text"));
67790:   if (state & states::EDITABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("editable"));
67790:   if (state & states::ACTIVE)
 2064:     stringStates->Add(NS_LITERAL_STRING("active"));
67790:   if (state & states::MODAL)
 2064:     stringStates->Add(NS_LITERAL_STRING("modal"));
67790:   if (state & states::MULTI_LINE)
 2064:     stringStates->Add(NS_LITERAL_STRING("multi line"));
67790:   if (state & states::HORIZONTAL)
 3513:     stringStates->Add(NS_LITERAL_STRING("horizontal"));
67790:   if (state & states::OPAQUE1)
 3513:     stringStates->Add(NS_LITERAL_STRING("opaque"));
67790:   if (state & states::SINGLE_LINE)
 2064:     stringStates->Add(NS_LITERAL_STRING("single line"));
67790:   if (state & states::TRANSIENT)
 2064:     stringStates->Add(NS_LITERAL_STRING("transient"));
67790:   if (state & states::VERTICAL)
 2064:     stringStates->Add(NS_LITERAL_STRING("vertical"));
67790:   if (state & states::STALE)
 3513:     stringStates->Add(NS_LITERAL_STRING("stale"));
67790:   if (state & states::ENABLED)
 3513:     stringStates->Add(NS_LITERAL_STRING("enabled"));
67790:   if (state & states::SENSITIVE)
 3513:     stringStates->Add(NS_LITERAL_STRING("sensitive"));
67790:   if (state & states::EXPANDABLE)
 3513:     stringStates->Add(NS_LITERAL_STRING("expandable"));
 2064: 
 2064:   //unknown states
 2064:   PRUint32 stringStatesLength = 0;
 2064:   stringStates->GetLength(&stringStatesLength);
 2064:   if (!stringStatesLength)
 2064:     stringStates->Add(NS_LITERAL_STRING("unknown"));
 2064: 
 2064:   NS_ADDREF(*aStringStates = stringStates);
 2064:   return NS_OK;
 2064: }
 2064: 
 5188: // nsIAccessibleRetrieval::getStringEventType()
 5188: NS_IMETHODIMP
 5188: nsAccessibilityService::GetStringEventType(PRUint32 aEventType,
 5188:                                            nsAString& aString)
 5188: {
 6284:   NS_ASSERTION(nsIAccessibleEvent::EVENT_LAST_ENTRY == NS_ARRAY_LENGTH(kEventTypeNames),
 6284:                "nsIAccessibleEvent constants are out of sync to kEventTypeNames");
 6284: 
 5188:   if (aEventType >= NS_ARRAY_LENGTH(kEventTypeNames)) {
 5188:     aString.AssignLiteral("unknown");
 5188:     return NS_OK;
 5188:   }
 5188: 
 5188:   CopyUTF8toUTF16(kEventTypeNames[aEventType], aString);
 5188:   return NS_OK;
 5188: }
 5188: 
 6812: // nsIAccessibleRetrieval::getStringRelationType()
 6812: NS_IMETHODIMP
 6812: nsAccessibilityService::GetStringRelationType(PRUint32 aRelationType,
 6812:                                               nsAString& aString)
 6812: {
 6812:   if (aRelationType >= NS_ARRAY_LENGTH(kRelationTypeNames)) {
 6812:     aString.AssignLiteral("unknown");
 6812:     return NS_OK;
 6812:   }
 6812: 
 6812:   CopyUTF8toUTF16(kRelationTypeNames[aRelationType], aString);
 6812:   return NS_OK;
 6812: }
 6812: 
43764: NS_IMETHODIMP
43764: nsAccessibilityService::GetAccessibleFromCache(nsIDOMNode* aNode,
43764:                                                nsIAccessible** aAccessible)
43764: {
43764:   NS_ENSURE_ARG_POINTER(aAccessible);
43764: 
43764:   // Search for an accessible in each of our per document accessible object
43764:   // caches. If we don't find it, and the given node is itself a document, check
43764:   // our cache of document accessibles (document cache). Note usually shutdown
43764:   // document accessibles are not stored in the document cache, however an
43764:   // "unofficially" shutdown document (i.e. not from nsAccDocManager) can still
43764:   // exist in the document cache.
43764:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
56292:   nsAccessible* accessible = FindAccessibleInCache(node);
43764:   if (!accessible) {
43764:     nsCOMPtr<nsIDocument> document(do_QueryInterface(node));
43764:     if (document)
43764:       accessible = GetDocAccessibleFromCache(document);
43764:   }
43764: 
43764:   NS_IF_ADDREF(*aAccessible = accessible);
43764:   return NS_OK;
43764: }
43764: 
43504: // nsIAccesibilityService
42313: nsAccessible*
46338: nsAccessibilityService::GetAccessibleInShell(nsINode* aNode,
42313:                                              nsIPresShell* aPresShell)
    1: {
42313:   if (!aNode || !aPresShell)
42313:     return nsnull;
 1440: 
    1:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
61359:   return GetAccessibleInWeakShell(aNode, weakShell);
    1: }
    1: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsAccessibilityService public
38359: 
42795: nsAccessible*
43504: nsAccessibilityService::GetAccessible(nsINode* aNode)
42795: {
70181:   NS_PRECONDITION(aNode, "Getting an accessible for null node! Crash.");
70181: 
61359:   nsDocAccessible* document = GetDocAccessible(aNode->GetOwnerDoc());
61461:   return document ? document->GetAccessible(aNode) : nsnull;
42795: }
42795: 
42795: nsAccessible*
61359: nsAccessibilityService::GetAccessibleOrContainer(nsINode* aNode,
61359:                                                  nsIWeakReference* aWeakShell)
42800: {
61462:   if (!aNode)
42800:     return nsnull;
42800: 
61462:   // XXX: weak shell is ignored until multiple shell documents are supported.
61462:   nsDocAccessible* document = GetDocAccessible(aNode->GetOwnerDoc());
61462:   return document ? document->GetAccessibleOrContainer(aNode) : nsnull;
42800: }
42800: 
10515: static PRBool HasRelatedContent(nsIContent *aContent)
10515: {
10515:   nsAutoString id;
20521:   if (!aContent || !nsCoreUtils::GetID(aContent, id) || id.IsEmpty()) {
10515:     return PR_FALSE;
10515:   }
10515: 
57890:   // If the given ID is referred by relation attribute then create an accessible
57890:   // for it. Take care of HTML elements only for now.
57890:   if (aContent->IsHTML() &&
57890:       nsAccUtils::GetDocAccessibleFor(aContent)->IsDependentID(id))
10515:     return PR_TRUE;
10515: 
10515:   nsIContent *ancestorContent = aContent;
10515:   while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
13716:     if (ancestorContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant)) {
10515:         // ancestor has activedescendant property, this content could be active
10515:       return PR_TRUE;
10515:     }
10515:   }
10515: 
10515:   return PR_FALSE;
10515: }
10515: 
64506: nsAccessible*
46469: nsAccessibilityService::GetOrCreateAccessible(nsINode* aNode,
    1:                                               nsIPresShell* aPresShell,
    1:                                               nsIWeakReference* aWeakShell,
57448:                                               bool* aIsSubtreeHidden)
    1: {
43538:   if (!aPresShell || !aWeakShell || !aNode || gIsShutdown)
38359:     return nsnull;
    1: 
57448:   if (aIsSubtreeHidden)
57448:     *aIsSubtreeHidden = false;
    1: 
38062:   // Check to see if we already have an accessible for this node in the cache.
61359:   nsAccessible* cachedAccessible = GetAccessibleInWeakShell(aNode, aWeakShell);
64506:   if (cachedAccessible)
43538:     return cachedAccessible;
    1: 
38359:   // No cache entry, so we must create the accessible.
38359: 
43504:   if (aNode->IsNodeOfType(nsINode::eDOCUMENT)) {
43310:     // If it's document node then ask accessible document loader for
43310:     // document accessible, otherwise return null.
43310:     nsCOMPtr<nsIDocument> document(do_QueryInterface(aNode));
64506:     return GetDocAccessible(document);
43310:   }
    1: 
38359:   // We have a content node.
43504:   if (!aNode->IsInDoc()) {
43310:     NS_WARNING("Creating accessible for node with no document");
38359:     return nsnull;
    1:   }
    1: 
43504:   if (aNode->GetOwnerDoc() != aPresShell->GetDocument()) {
38359:     NS_ERROR("Creating accessible for wrong pres shell");
38359:     return nsnull;
38359:   }
34904: 
43504:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
43504:   if (!content)
43504:     return nsnull;
43504: 
38359:   // Frames can be deallocated when we flush layout, or when we call into code
38359:   // that can flush layout, either directly, or via DOM manipulation, or some
38359:   // CSS styles like :hover. We use the weak frame checks to avoid calling
38359:   // methods on a dead frame pointer.
38359:   nsWeakFrame weakFrame = content->GetPrimaryFrame();
38359: 
57448:   // Check frame and its visibility. Note, hidden frame allows visible
57448:   // elements in subtree.
57448:   if (!weakFrame.GetFrame() || !weakFrame->GetStyleVisibility()->IsVisible()) {
57448:     if (aIsSubtreeHidden && !weakFrame.GetFrame())
57448:       *aIsSubtreeHidden = true;
38359: 
38359:     return nsnull;
    1:   }
38359: 
34904:   if (weakFrame.GetFrame()->GetContent() != content) {
40575:     // Not the main content for this frame. This happens because <area>
40575:     // elements return the image frame as their primary frame. The main content
40575:     // for the image frame is the image content. If the frame is not an image
40575:     // frame or the node is not an area element then null is returned.
43318:     // This setup will change when bug 135040 is fixed.
64506:     return GetAreaAccessible(weakFrame.GetFrame(), aNode, aWeakShell);
    1:   }
    1: 
57413:   nsDocAccessible* docAcc =
57413:     GetAccService()->GetDocAccessible(aNode->GetOwnerDoc());
57413:   if (!docAcc) {
64506:     NS_NOTREACHED("Node has no host document accessible!");
57413:     return nsnull;
57413:   }
57413: 
38359:   // Attempt to create an accessible based on what we know.
43310:   nsRefPtr<nsAccessible> newAcc;
61649: 
61649:   // Create accessible for visible text frames.
    1:   if (content->IsNodeOfType(nsINode::eTEXT)) {
61649:     nsAutoString text;
61649:     weakFrame->GetRenderedText(&text, nsnull, nsnull, 0, PR_UINT32_MAX);
61649:     if (text.IsEmpty()) {
57448:       if (aIsSubtreeHidden)
57448:         *aIsSubtreeHidden = true;
38359: 
38359:       return nsnull;
    1:     }
61649: 
61649:     newAcc = weakFrame->CreateAccessible();
61649:     if (docAcc->BindToDocument(newAcc, nsnull)) {
61649:       newAcc->AsTextLeaf()->SetText(text);
64506:       return newAcc;
38359:     }
35026: 
38359:     return nsnull;
    1:   }
    1: 
33329:   PRBool isHTML = content->IsHTML();
15308:   if (isHTML && content->Tag() == nsAccessibilityAtoms::map) {
15308:     // Create hyper text accessible for HTML map if it is used to group links
15308:     // (see http://www.w3.org/TR/WCAG10-HTML-TECHS/#group-bypass). If the HTML
15308:     // map doesn't have 'name' attribute (or has empty name attribute) then we
15308:     // suppose it is used for links grouping. Otherwise we think it is used in
15308:     // conjuction with HTML image element and in this case we don't create any
15308:     // accessible for it and don't walk into it. The accessibles for HTML area
15308:     // (nsHTMLAreaAccessible) the map contains are attached as children of the
15308:     // appropriate accessible for HTML image (nsHTMLImageAccessible).
15308:     nsAutoString name;
15308:     content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::name, name);
15308:     if (!name.IsEmpty()) {
57448:       if (aIsSubtreeHidden)
57448:         *aIsSubtreeHidden = true;
38359: 
38359:       return nsnull;
15308:     }
15308: 
43504:     newAcc = new nsHyperTextAccessibleWrap(content, aWeakShell);
57413:     if (docAcc->BindToDocument(newAcc, nsAccUtils::GetRoleMapEntry(aNode)))
64506:       return newAcc;
38359:     return nsnull;
15308:   }
15308: 
20536:   nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(aNode);
 7830:   if (roleMapEntry && !nsCRT::strcmp(roleMapEntry->roleString, "presentation") &&
 7830:       !content->IsFocusable()) { // For presentation only
 7830:     // Only create accessible for role of "presentation" if it is focusable --
    1:     // in that case we need an accessible in case it gets focused, we
    1:     // don't want focus ever to be 'lost'
38359:     return nsnull;
    1:   }
    1: 
34904:   if (weakFrame.IsAlive() && !newAcc && isHTML) {  // HTML accessibles
13731:     PRBool tryTagNameOrFrame = PR_TRUE;
13731: 
34904:     nsIAtom *frameType = weakFrame.GetFrame()->GetType();
28493: 
28493:     PRBool partOfHTMLTable =
28493:       frameType == nsAccessibilityAtoms::tableCaptionFrame ||
10869:       frameType == nsAccessibilityAtoms::tableCellFrame ||
10869:       frameType == nsAccessibilityAtoms::tableRowGroupFrame ||
28493:       frameType == nsAccessibilityAtoms::tableRowFrame;
28493: 
32474:     if (partOfHTMLTable) {
10869:       // Table-related frames don't get table-related roles
10869:       // unless they are inside a table, but they may still get generic
10869:       // accessibles
    1:       nsIContent *tableContent = content;
    1:       while ((tableContent = tableContent->GetParent()) != nsnull) {
36654:         nsIFrame *tableFrame = tableContent->GetPrimaryFrame();
10869:         if (!tableFrame)
10869:           continue;
32474: 
10869:         if (tableFrame->GetType() == nsAccessibilityAtoms::tableOuterFrame) {
42795:           nsAccessible *tableAccessible =
43504:             GetAccessibleInWeakShell(tableContent, aWeakShell);
32474: 
32474:           if (tableAccessible) {
32479:             if (!roleMapEntry) {
52089:               PRUint32 role = tableAccessible->Role();
32479:               if (role != nsIAccessibleRole::ROLE_TABLE &&
32479:                   role != nsIAccessibleRole::ROLE_TREE_TABLE) {
32479:                 // No ARIA role and not in table: override role. For example,
32479:                 // <table role="label"><td>content</td></table>
32474:                 roleMapEntry = &nsARIAMap::gEmptyRoleMap;
32474:               }
32479:             }
32474: 
32474:             break;
32474:           }
32474: 
10869: #ifdef DEBUG
20521:           nsRoleMapEntry *tableRoleMapEntry =
43504:             nsAccUtils::GetRoleMapEntry(tableContent);
11383:           NS_ASSERTION(tableRoleMapEntry &&
11383:                        !nsCRT::strcmp(tableRoleMapEntry->roleString, "presentation"),
10869:                        "No accessible for parent table and it didn't have role of presentation");
10869: #endif
32474: 
32474:           if (!roleMapEntry && !content->IsFocusable()) {
32474:             // Table-related descendants of presentation table are also
32474:             // presentation if they aren't focusable and have not explicit ARIA
32474:             // role (don't create accessibles for them unless they need to fire
32474:             // focus events).
38359:             return nsnull;
10869:           }
32474: 
32474:           // otherwise create ARIA based accessible.
32474:           tryTagNameOrFrame = PR_FALSE;
 6090:           break;
 6090:         }
32474: 
32474:         if (tableContent->Tag() == nsAccessibilityAtoms::table) {
10869:           // Stop before we are fooled by any additional table ancestors
10869:           // This table cell frameis part of a separate ancestor table.
13731:           tryTagNameOrFrame = PR_FALSE;
10421:           break;
 6090:         }
 6090:       }
13731: 
13731:       if (!tableContent)
13731:         tryTagNameOrFrame = PR_FALSE;
    1:     }
    1: 
29271:     if (roleMapEntry) {
29271:       // Create ARIA grid/treegrid accessibles if node is not of a child or
29271:       // valid child of HTML table and is not a HTML table.
29271:       if ((!partOfHTMLTable || !tryTagNameOrFrame) &&
29271:           frameType != nsAccessibilityAtoms::tableOuterFrame) {
29271: 
28493:         if (roleMapEntry->role == nsIAccessibleRole::ROLE_TABLE ||
28493:             roleMapEntry->role == nsIAccessibleRole::ROLE_TREE_TABLE) {
43504:           newAcc = new nsARIAGridAccessibleWrap(content, aWeakShell);
29271: 
28493:         } else if (roleMapEntry->role == nsIAccessibleRole::ROLE_GRID_CELL ||
28493:             roleMapEntry->role == nsIAccessibleRole::ROLE_ROWHEADER ||
28493:             roleMapEntry->role == nsIAccessibleRole::ROLE_COLUMNHEADER) {
43504:           newAcc = new nsARIAGridCellAccessibleWrap(content, aWeakShell);
28493:         }
28493:       }
29271:     }
28493: 
28493:     if (!newAcc && tryTagNameOrFrame) {
 6090:       // Prefer to use markup (mostly tag name, perhaps attributes) to
 6090:       // decide if and what kind of accessible to create.
 6090:       // The method creates accessibles for table related content too therefore
 6090:       // we do not call it if accessibles for table related content are
 6090:       // prevented above.
46338:       newAcc = CreateHTMLAccessibleByMarkup(weakFrame.GetFrame(), content,
46338:                                             aWeakShell);
    1: 
 6090:       if (!newAcc) {
 6090:         // Do not create accessible object subtrees for non-rendered table
 6090:         // captions. This could not be done in
 6090:         // nsTableCaptionFrame::GetAccessible() because the descendants of
 6090:         // the table caption would still be created. By setting
57448:         // *aIsSubtreeHidden = true we ensure that no descendant accessibles
57448:         // are created.
34904:         nsIFrame* f = weakFrame.GetFrame();
34904:         if (!f) {
34904:           f = aPresShell->GetRealPrimaryFrameFor(content);
34904:         }
34904:         if (f->GetType() == nsAccessibilityAtoms::tableCaptionFrame &&
34904:            f->GetRect().IsEmpty()) {
 6090:           // XXX This is not the ideal place for this code, but right now there
 6090:           // is no better place:
57448:           if (aIsSubtreeHidden)
57448:             *aIsSubtreeHidden = true;
38359: 
38359:           return nsnull;
 3151:         }
38359: 
38359:         // Try using frame to do it.
46338:         newAcc = f->CreateAccessible();
    1:       }
    1:     }
13731:   }
    1: 
 1477:   if (!newAcc) {
28493:     // Elements may implement nsIAccessibleProvider via XBL. This allows them to
28493:     // say what kind of accessible to create.
43504:     newAcc = CreateAccessibleByType(content, aWeakShell);
28493:   }
28493: 
28493:   if (!newAcc) {
28493:     // Create generic accessibles for SVG and MathML nodes.
28493:     if (content->GetNameSpaceID() == kNameSpaceID_SVG &&
28493:         content->Tag() == nsAccessibilityAtoms::svg) {
43504:       newAcc = new nsEnumRoleAccessible(content, aWeakShell,
28493:                                         nsIAccessibleRole::ROLE_DIAGRAM);
28493:     }
28493:     else if (content->GetNameSpaceID() == kNameSpaceID_MathML &&
28493:              content->Tag() == nsAccessibilityAtoms::math) {
43504:       newAcc = new nsEnumRoleAccessible(content, aWeakShell,
28493:                                         nsIAccessibleRole::ROLE_EQUATION);
28493:     }
28493:   }
28493: 
28493:   if (!newAcc) {
43504:     newAcc = CreateAccessibleForDeckChild(weakFrame.GetFrame(), content,
38359:                                           aWeakShell);
 1477:   }
 1477: 
    1:   // If no accessible, see if we need to create a generic accessible because
    1:   // of some property that makes this object interesting
    1:   // We don't do this for <body>, <html>, <window>, <dialog> etc. which 
    1:   // correspond to the doc accessible and will be created in any case
    1:   if (!newAcc && content->Tag() != nsAccessibilityAtoms::body && content->GetParent() && 
34904:       ((weakFrame.GetFrame() && weakFrame.GetFrame()->IsFocusable()) ||
37859:        (isHTML && nsCoreUtils::HasClickListener(content)) ||
39578:        HasUniversalAriaProperty(content) || roleMapEntry ||
20521:        HasRelatedContent(content) || nsCoreUtils::IsXLink(content))) {
    1:     // This content is focusable or has an interesting dynamic content accessibility property.
    1:     // If it's interesting we need it in the accessibility hierarchy so that events or
    1:     // other accessibles can point to it, or so that it can hold a state, etc.
 1672:     if (isHTML) {
    1:       // Interesting HTML container which may have selectable text and/or embedded objects
43504:       newAcc = new nsHyperTextAccessibleWrap(content, aWeakShell);
    1:     }
    1:     else {  // XUL, SVG, MathML etc.
    1:       // Interesting generic non-HTML container
43504:       newAcc = new nsAccessibleWrap(content, aWeakShell);
    1:     }
    1:   }
    1: 
64506:   return docAcc->BindToDocument(newAcc, roleMapEntry) ? newAcc : nsnull;
    1: }
    1: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccessibilityService private
43310: 
43310: PRBool
43310: nsAccessibilityService::Init()
43310: {
43310:   // Initialize accessible document manager.
43310:   if (!nsAccDocManager::Init())
43310:     return PR_FALSE;
43310: 
43310:   // Add observers.
43310:   nsCOMPtr<nsIObserverService> observerService =
43310:     mozilla::services::GetObserverService();
43310:   if (!observerService)
43310:     return PR_FALSE;
43310: 
43310:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_FALSE);
43310: 
43310:   // Initialize accessibility.
43310:   nsAccessNodeWrap::InitAccessibility();
43310: 
43310:   gIsShutdown = PR_FALSE;
43310:   return PR_TRUE;
43310: }
43310: 
43310: void
43310: nsAccessibilityService::Shutdown()
43310: {
43310:   // Remove observers.
43310:   nsCOMPtr<nsIObserverService> observerService =
43310:       mozilla::services::GetObserverService();
43310:   if (observerService)
43310:     observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
43310: 
43310:   // Stop accessible document loader.
43310:   nsAccDocManager::Shutdown();
43310: 
43310:   // Application is going to be closed, shutdown accessibility and mark
43310:   // accessibility service as shutdown to prevent calls of its methods.
43310:   // Don't null accessibility service static member at this point to be safe
43310:   // if someone will try to operate with it.
43310: 
43310:   NS_ASSERTION(!gIsShutdown, "Accessibility was shutdown already");
43310: 
43310:   gIsShutdown = PR_TRUE;
43310: 
43310:   nsAccessNodeWrap::ShutdownAccessibility();
43310: }
43310: 
 6279: PRBool
39578: nsAccessibilityService::HasUniversalAriaProperty(nsIContent *aContent)
 6279: {
39578:   // ARIA attributes that take token values (NMTOKEN, bool) are special cased
39578:   // because of special value "undefined" (see HasDefinedARIAToken).
23549:   return nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_atomic) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_busy) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_controls) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_describedby) ||
39578:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_disabled) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_dropeffect) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_flowto) ||
24911:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_grabbed) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_haspopup) ||
61469:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_hidden) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_invalid) ||
18793:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_label) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_labelledby) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_live) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_owns) ||
39578:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_relevant);
 6279: }
 6279: 
46469: nsAccessible*
40575: nsAccessibilityService::GetAreaAccessible(nsIFrame* aImageFrame,
43504:                                           nsINode* aAreaNode,
46469:                                           nsIWeakReference* aWeakShell,
46469:                                           nsAccessible** aImageAccessible)
40575: {
40575:   // Check if frame is an image frame, and content is <area>.
69187:   nsImageFrame *imageFrame = do_QueryFrame(aImageFrame);
40575:   if (!imageFrame)
40575:     return nsnull;
40575: 
40575:   nsCOMPtr<nsIDOMHTMLAreaElement> areaElmt = do_QueryInterface(aAreaNode);
40575:   if (!areaElmt)
40575:     return nsnull;
40575: 
40575:   // Try to get image map accessible from the global cache or create it
40575:   // if failed.
61359:   nsRefPtr<nsAccessible> image =
61359:     GetAccessibleInWeakShell(aImageFrame->GetContent(), aWeakShell);
57413:   if (!image) {
57413:     image = CreateHTMLImageAccessible(aImageFrame->GetContent(),
46338:                                       aImageFrame->PresContext()->PresShell());
40575: 
57413:     nsDocAccessible* document =
57413:       GetAccService()->GetDocAccessible(aAreaNode->GetOwnerDoc());
57413:     if (!document) {
57413:       NS_NOTREACHED("No document for accessible being created!");
57413:       return nsnull;
57413:     }
57413: 
57413:     if (!document->BindToDocument(image, nsnull))
40575:       return nsnull;
40575:   }
40575: 
46469:   if (aImageAccessible)
57413:     *aImageAccessible = image;
46469: 
40575:   // Make sure <area> accessible children of the image map are cached so
40575:   // that they should be available in global cache.
57413:   image->EnsureChildren();
40575: 
61359:   return GetAccessibleInWeakShell(aAreaNode, aWeakShell);
40575: }
40575: 
40575: already_AddRefed<nsAccessible>
43504: nsAccessibilityService::CreateAccessibleByType(nsIContent* aContent,
38359:                                                nsIWeakReference* aWeakShell)
    1: {
43504:   nsCOMPtr<nsIAccessibleProvider> accessibleProvider(do_QueryInterface(aContent));
 1477:   if (!accessibleProvider)
38359:     return nsnull;
    1: 
    1:   PRInt32 type;
 1477:   nsresult rv = accessibleProvider->GetAccessibleType(&type);
38359:   if (NS_FAILED(rv))
38359:     return nsnull;
    1: 
38359:   if (type == nsIAccessibleProvider::OuterDoc) {
46338:     nsAccessible* accessible = new nsOuterDocAccessible(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
38359:   }
    1: 
46338:   nsAccessible* accessible = nsnull;
    1:   switch (type)
    1:   {
    1: #ifdef MOZ_XUL
10594:     case nsIAccessibleProvider::NoAccessible:
38359:       return nsnull;
38359: 
    1:     // XUL controls
    1:     case nsIAccessibleProvider::XULAlert:
43504:       accessible = new nsXULAlertAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULButton:
43504:       accessible = new nsXULButtonAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULCheckbox:
43504:       accessible = new nsXULCheckboxAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULColorPicker:
43504:       accessible = new nsXULColorPickerAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULColorPickerTile:
43504:       accessible = new nsXULColorPickerTileAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULCombobox:
43504:       accessible = new nsXULComboboxAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULDropmarker:
43504:       accessible = new nsXULDropmarkerAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULGroupbox:
43504:       accessible = new nsXULGroupboxAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULImage:
    1:     {
43504:       // Don't include nameless images in accessible tree.
43504:       if (!aContent->HasAttr(kNameSpaceID_None,
43504:                              nsAccessibilityAtoms::tooltiptext))
38359:         return nsnull;
    1: 
43504:       accessible = new nsHTMLImageAccessibleWrap(aContent, aWeakShell);
    1:       break;
46338: 
    1:     }
    1:     case nsIAccessibleProvider::XULLink:
43504:       accessible = new nsXULLinkAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULListbox:
43504:       accessible = new nsXULListboxAccessibleWrap(aContent, aWeakShell);
    1:       break;
46338: 
11854:     case nsIAccessibleProvider::XULListCell:
43504:       accessible = new nsXULListCellAccessibleWrap(aContent, aWeakShell);
11854:       break;
46338: 
 6094:     case nsIAccessibleProvider::XULListHead:
43504:       accessible = new nsXULColumnsAccessible(aContent, aWeakShell);
 6094:       break;
46338: 
 6094:     case nsIAccessibleProvider::XULListHeader:
43504:       accessible = new nsXULColumnItemAccessible(aContent, aWeakShell);
 6094:       break;
46338: 
    1:     case nsIAccessibleProvider::XULListitem:
43504:       accessible = new nsXULListitemAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULMenubar:
43504:       accessible = new nsXULMenubarAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULMenuitem:
43504:       accessible = new nsXULMenuitemAccessibleWrap(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULMenupopup:
    1:     {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:       // ATK considers this node to be redundant when within menubars, and it makes menu
    1:       // navigation with assistive technologies more difficult
    1:       // XXX In the future we will should this for consistency across the nsIAccessible
    1:       // implementations on each platform for a consistent scripting environment, but
    1:       // then strip out redundant accessibles in the nsAccessibleWrap class for each platform.
43504:       nsIContent *parent = aContent->GetParent();
43504:       if (parent && parent->NodeInfo()->Equals(nsAccessibilityAtoms::menu,
43504:                                                kNameSpaceID_XUL))
38359:         return nsnull;
    1: #endif
43504:       accessible = new nsXULMenupopupAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     }
    1:     case nsIAccessibleProvider::XULMenuSeparator:
43504:       accessible = new nsXULMenuSeparatorAccessible(aContent, aWeakShell);
    1:       break;
46338: 
10594:     case nsIAccessibleProvider::XULPane:
43504:       accessible = new nsEnumRoleAccessible(aContent, aWeakShell,
38359:                                             nsIAccessibleRole::ROLE_PANE);
10594:       break;
46338: 
    1:     case nsIAccessibleProvider::XULProgressMeter:
69737:       accessible = new XULProgressMeterAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULStatusBar:
43504:       accessible = new nsXULStatusBarAccessible(aContent, aWeakShell);
    1:       break;
46338: 
 4274:     case nsIAccessibleProvider::XULScale:
43504:       accessible = new nsXULSliderAccessible(aContent, aWeakShell);
 4274:       break;
46338: 
    1:     case nsIAccessibleProvider::XULRadioButton:
43504:       accessible = new nsXULRadioButtonAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULRadioGroup:
43504:       accessible = new nsXULRadioGroupAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTab:
43504:       accessible = new nsXULTabAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTabs:
43504:       accessible = new nsXULTabsAccessible(aContent, aWeakShell);
    1:       break;
46338: 
42315:     case nsIAccessibleProvider::XULTabpanels:
43504:       accessible = new nsXULTabpanelsAccessible(aContent, aWeakShell);
42315:       break;
46338: 
    1:     case nsIAccessibleProvider::XULText:
43504:       accessible = new nsXULTextAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTextBox:
43504:       accessible = new nsXULTextFieldAccessible(aContent, aWeakShell);
    1:       break;
46338: 
 4274:     case nsIAccessibleProvider::XULThumb:
43504:       accessible = new nsXULThumbAccessible(aContent, aWeakShell);
 4274:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTree:
43504:       return CreateAccessibleForXULTree(aContent, aWeakShell);
38359: 
    1:     case nsIAccessibleProvider::XULTreeColumns:
43504:       accessible = new nsXULTreeColumnsAccessible(aContent, aWeakShell);
    1:       break;
46338: 
 6094:     case nsIAccessibleProvider::XULTreeColumnItem:
43504:       accessible = new nsXULColumnItemAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULToolbar:
43504:       accessible = new nsXULToolbarAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULToolbarSeparator:
43504:       accessible = new nsXULToolbarSeparatorAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTooltip:
43504:       accessible = new nsXULTooltipAccessible(aContent, aWeakShell);
    1:       break;
46338: 
 3325:     case nsIAccessibleProvider::XULToolbarButton:
43504:       accessible = new nsXULToolbarButtonAccessible(aContent, aWeakShell);
 3325:       break;
46338: 
    1: #endif // MOZ_XUL
    1: 
    1: #ifndef DISABLE_XFORMS_HOOKS
    1:     // XForms elements
    1:     case nsIAccessibleProvider::XFormsContainer:
43504:       accessible = new nsXFormsContainerAccessible(aContent, aWeakShell);
    1:       break;
    1: 
    1:     case nsIAccessibleProvider::XFormsLabel:
43504:       accessible = new nsXFormsLabelAccessible(aContent, aWeakShell);
    1:       break;
46338: 
42263:     case nsIAccessibleProvider::XFormsOutput:
43504:       accessible = new nsXFormsOutputAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsTrigger:
43504:       accessible = new nsXFormsTriggerAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsInput:
43504:       accessible = new nsXFormsInputAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsInputBoolean:
43504:       accessible = new nsXFormsInputBooleanAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsInputDate:
43504:       accessible = new nsXFormsInputDateAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSecret:
43504:       accessible = new nsXFormsSecretAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSliderRange:
43504:       accessible = new nsXFormsRangeAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSelect:
43504:       accessible = new nsXFormsSelectAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsChoices:
43504:       accessible = new nsXFormsChoicesAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSelectFull:
43504:       accessible = new nsXFormsSelectFullAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsItemCheckgroup:
43504:       accessible = new nsXFormsItemCheckgroupAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsItemRadiogroup:
43504:       accessible = new nsXFormsItemRadiogroupAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSelectCombobox:
43504:       accessible = new nsXFormsSelectComboboxAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsItemCombobox:
43504:       accessible = new nsXFormsItemComboboxAccessible(aContent, aWeakShell);
    1:       break;
    1: 
    1:     case nsIAccessibleProvider::XFormsDropmarkerWidget:
43504:       accessible = new nsXFormsDropmarkerWidgetAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsCalendarWidget:
43504:       accessible = new nsXFormsCalendarWidgetAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsComboboxPopupWidget:
43504:       accessible = new nsXFormsComboboxPopupWidgetAccessible(aContent, aWeakShell);
    1:       break;
46338: 
    1: #endif
    1: 
    1:     default:
38359:       return nsnull;
    1:   }
    1: 
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
46338: }
46338: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLAccessibleByMarkup(nsIFrame* aFrame,
46338:                                                      nsIContent* aContent,
46338:                                                      nsIWeakReference* aWeakShell)
46338: {
46338:   // This method assumes we're in an HTML namespace.
46338:   nsIAtom *tag = aContent->Tag();
46338:   if (tag == nsAccessibilityAtoms::legend) {
46338:     nsAccessible* accessible = new nsHTMLLegendAccessible(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::option) {
46338:     nsAccessible* accessible = new nsHTMLSelectOptionAccessible(aContent,
46338:                                                                 aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::optgroup) {
46338:     nsAccessible* accessible = new nsHTMLSelectOptGroupAccessible(aContent,
46338:                                                                   aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::ul || tag == nsAccessibilityAtoms::ol ||
46338:       tag == nsAccessibilityAtoms::dl) {
46338:     nsAccessible* accessible = new nsHTMLListAccessible(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::a) {
46338:     // Only some roles truly enjoy life as nsHTMLLinkAccessibles, for details
46338:     // see closed bug 494807.
46338:     nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(aContent);
46338:     if (roleMapEntry && roleMapEntry->role != nsIAccessibleRole::ROLE_NOTHING &&
46338:         roleMapEntry->role != nsIAccessibleRole::ROLE_LINK) {
46338:       nsAccessible* accessible = new nsHyperTextAccessibleWrap(aContent,
46338:                                                                aWeakShell);
46338:       NS_IF_ADDREF(accessible);
46338:       return accessible;
46338:     }
46338: 
46338:     nsAccessible* accessible = new nsHTMLLinkAccessible(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::dt ||
46338:       (tag == nsAccessibilityAtoms::li &&
46338:        aFrame->GetType() != nsAccessibilityAtoms::blockFrame)) {
46338:     // Normally for li, it is created by the list item frame (in nsBlockFrame)
46338:     // which knows about the bullet frame; however, in this case the list item
46338:     // must have been styled using display: foo
55763:     nsAccessible* accessible = new nsHTMLLIAccessible(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::abbr ||
46338:       tag == nsAccessibilityAtoms::acronym ||
46338:       tag == nsAccessibilityAtoms::blockquote ||
46338:       tag == nsAccessibilityAtoms::dd ||
46338:       tag == nsAccessibilityAtoms::form ||
46338:       tag == nsAccessibilityAtoms::h1 ||
46338:       tag == nsAccessibilityAtoms::h2 ||
46338:       tag == nsAccessibilityAtoms::h3 ||
46338:       tag == nsAccessibilityAtoms::h4 ||
46338:       tag == nsAccessibilityAtoms::h5 ||
46338:       tag == nsAccessibilityAtoms::h6 ||
46338:       tag == nsAccessibilityAtoms::q) {
46338:     nsAccessible* accessible = new nsHyperTextAccessibleWrap(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (tag == nsAccessibilityAtoms::tr) {
46338:     nsAccessible* accessible = new nsEnumRoleAccessible(aContent, aWeakShell,
46338:                                                         nsIAccessibleRole::ROLE_ROW);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (nsCoreUtils::IsHTMLTableHeader(aContent)) {
46338:     nsAccessible* accessible = new nsHTMLTableHeaderCellAccessibleWrap(aContent,
46338:                                                                        aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
54466:   if (tag == nsAccessibilityAtoms::output) {
54466:     nsAccessible* accessible = new nsHTMLOutputAccessible(aContent, aWeakShell);
54466:     NS_IF_ADDREF(accessible);
54466:     return accessible;
54466:   }
54466: 
69737:   if (tag == nsAccessibilityAtoms::progress) {
69737:     nsAccessible* accessible =
69737:       new HTMLProgressMeterAccessible(aContent, aWeakShell);
69737:     NS_IF_ADDREF(accessible);
69737:     return accessible;
69737:   }
69737: 
46338:   return nsnull;
38359:  }
    1: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsIAccessibilityService (DON'T put methods here)
    1: 
46207: nsAccessible*
46207: nsAccessibilityService::AddNativeRootAccessible(void* aAtkAccessible)
    1:  {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
39600:   nsApplicationAccessible* applicationAcc =
 2063:     nsAccessNode::GetApplicationAccessible();
46207:   if (!applicationAcc)
46207:     return nsnull;
 2063: 
57413:   nsRefPtr<nsNativeRootAccessibleWrap> nativeRootAcc =
46207:      new nsNativeRootAccessibleWrap((AtkObject*)aAtkAccessible);
46207:   if (!nativeRootAcc)
46207:     return nsnull;
    1: 
46207:   if (applicationAcc->AppendChild(nativeRootAcc))
46207:     return nativeRootAcc;
    1: #endif
46207: 
46207:   return nsnull;
    1:  }
    1: 
46207: void
46207: nsAccessibilityService::RemoveNativeRootAccessible(nsAccessible* aAccessible)
    1: {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
39600:   nsApplicationAccessible* applicationAcc =
 2063:     nsAccessNode::GetApplicationAccessible();
 2063: 
46207:   if (applicationAcc)
46207:     applicationAcc->RemoveChild(aAccessible);
    1: #endif
    1: }
    1: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // NS_GetAccessibilityService
38359: ////////////////////////////////////////////////////////////////////////////////
    1: 
37808: /**
37808:  * Return accessibility service; creating one if necessary.
37808:  */
    1: nsresult
37808: NS_GetAccessibilityService(nsIAccessibilityService** aResult)
    1: {
30820:   NS_ENSURE_TRUE(aResult, NS_ERROR_NULL_POINTER);
30820:   *aResult = nsnull;
    1:  
43310:   if (nsAccessibilityService::gAccessibilityService) {
43310:     NS_ADDREF(*aResult = nsAccessibilityService::gAccessibilityService);
43310:     return NS_OK;
    1:   }
30820: 
43310:   nsRefPtr<nsAccessibilityService> service = new nsAccessibilityService();
43310:   NS_ENSURE_TRUE(service, NS_ERROR_OUT_OF_MEMORY);
43310: 
43310:   if (!service->Init()) {
43310:     service->Shutdown();
43310:     return NS_ERROR_FAILURE;
43310:   }
43310: 
43310:   nsAccessibilityService::gAccessibilityService = service;
43310:   NS_ADDREF(*aResult = service);
43310: 
30820:   return NS_OK;
    1: }
30820: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsAccessibilityService private (DON'T put methods here)
38359: 
38359: already_AddRefed<nsAccessible>
38359: nsAccessibilityService::CreateAccessibleForDeckChild(nsIFrame* aFrame,
43504:                                                      nsIContent* aContent,
38359:                                                      nsIWeakReference* aWeakShell)
 1477: {
38359:   if (aFrame->GetType() == nsAccessibilityAtoms::boxFrame ||
38359:       aFrame->GetType() == nsAccessibilityAtoms::scrollFrame) {
 1477: 
38359:     nsIFrame* parentFrame = aFrame->GetParent();
 1477:     if (parentFrame && parentFrame->GetType() == nsAccessibilityAtoms::deckFrame) {
 7840:       // If deck frame is for xul:tabpanels element then the given node has
 7840:       // tabpanel accessible.
 7840:       nsCOMPtr<nsIContent> parentContent = parentFrame->GetContent();
15855: #ifdef MOZ_XUL
 7840:       if (parentContent->NodeInfo()->Equals(nsAccessibilityAtoms::tabpanels,
 7840:                                             kNameSpaceID_XUL)) {
46338:         nsAccessible* accessible = new nsXULTabpanelAccessible(aContent,
46338:                                                                aWeakShell);
46338:         NS_IF_ADDREF(accessible);
46338:         return accessible;
46338:       }
15855: #endif
46338:       nsAccessible* accessible = new nsEnumRoleAccessible(aContent, aWeakShell,
 7840:                                                           nsIAccessibleRole::ROLE_PROPERTYPAGE);
46338:       NS_IF_ADDREF(accessible);
46338:       return accessible;
 1477:     }
 1477:   }
 1477: 
46338:   return nsnull;
 1477: }
31673: 
31673: #ifdef MOZ_XUL
38359: already_AddRefed<nsAccessible>
43504: nsAccessibilityService::CreateAccessibleForXULTree(nsIContent* aContent,
38359:                                                    nsIWeakReference* aWeakShell)
31673: {
43504:   nsCOMPtr<nsITreeBoxObject> treeBoxObj = nsCoreUtils::GetTreeBoxObject(aContent);
31673:   if (!treeBoxObj)
38359:     return nsnull;
31673: 
31673:   nsCOMPtr<nsITreeColumns> treeColumns;
31673:   treeBoxObj->GetColumns(getter_AddRefs(treeColumns));
31673:   if (!treeColumns)
38359:     return nsnull;
38359: 
31673:   PRInt32 count = 0;
31673:   treeColumns->GetCount(&count);
31673: 
46338:   // Outline of list accessible.
46338:   if (count == 1) {
46338:     nsAccessible* accessible = new nsXULTreeAccessible(aContent, aWeakShell);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   // Table or tree table accessible.
46338:   nsAccessible* accessible = new nsXULTreeGridAccessibleWrap(aContent, aWeakShell);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
31673: }
31673: #endif
