    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsXPCOM.h"
    1: #include "nsMemoryImpl.h"
    1: #include "nsThreadUtils.h"
    1: 
32480: #include "nsIObserver.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsISupportsArray.h"
    1: 
    1: #include "prmem.h"
    1: #include "prcvar.h"
    1: #include "pratom.h"
    1: 
    1: #include "nsAlgorithm.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsString.h"
41540: #include "mozilla/Services.h"
    1: 
    1: static nsMemoryImpl sGlobalMemory;
    1: 
    1: NS_IMPL_QUERY_INTERFACE1(nsMemoryImpl, nsIMemory)
    1: 
    1: NS_IMETHODIMP_(void*)
    1: nsMemoryImpl::Alloc(PRSize size)
    1: {
    1:     return NS_Alloc(size);
    1: }
    1: 
    1: NS_IMETHODIMP_(void*)
    1: nsMemoryImpl::Realloc(void* ptr, PRSize size)
    1: {
    1:     return NS_Realloc(ptr, size);
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsMemoryImpl::Free(void* ptr)
    1: {
    1:     NS_Free(ptr);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsMemoryImpl::HeapMinimize(bool aImmediate)
    1: {
    1:     return FlushMemory(NS_LITERAL_STRING("heap-minimize").get(), aImmediate);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsMemoryImpl::IsLowMemory(bool *result)
    1: {
51934:     NS_ERROR("IsLowMemory is deprecated.  See bug 592308.");
80486:     *result = false;
    1:     return NS_OK;
    1: }
    1: 
    1: /*static*/ nsresult
    1: nsMemoryImpl::Create(nsISupports* outer, const nsIID& aIID, void **aResult)
    1: {
    1:     NS_ENSURE_NO_AGGREGATION(outer);
    1:     return sGlobalMemory.QueryInterface(aIID, aResult);
    1: }
    1: 
    1: nsresult
79445: nsMemoryImpl::FlushMemory(const PRUnichar* aReason, bool aImmediate)
    1: {
39333:     nsresult rv = NS_OK;
    1: 
    1:     if (aImmediate) {
    1:         // They've asked us to run the flusher *immediately*. We've
    1:         // got to be on the UI main thread for us to be able to do
    1:         // that...are we?
    1:         if (!NS_IsMainThread()) {
    1:             NS_ERROR("can't synchronously flush memory: not on UI thread");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
64101:     PRInt32 lastVal = PR_ATOMIC_SET(&sIsFlushing, 1);
    1:     if (lastVal)
    1:         return NS_OK;
    1: 
32480:     PRIntervalTime now = PR_IntervalNow();
32480: 
    1:     // Run the flushers immediately if we can; otherwise, proxy to the
    1:     // UI thread an run 'em asynchronously.
    1:     if (aImmediate) {
    1:         rv = RunFlushers(aReason);
    1:     }
    1:     else {
32505:         // Don't broadcast more than once every 1000ms to avoid being noisy
32505:         if (PR_IntervalToMicroseconds(now - sLastFlushTime) > 1000) {
    1:             sFlushEvent.mReason = aReason;
    1:             rv = NS_DispatchToMainThread(&sFlushEvent, NS_DISPATCH_NORMAL);
    1:         }
32480:     }
    1: 
32480:     sLastFlushTime = now;
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsMemoryImpl::RunFlushers(const PRUnichar* aReason)
    1: {
41540:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:     if (os) {
32480: 
32480:         // Instead of:
32480:         //  os->NotifyObservers(this, "memory-pressure", aReason);
32480:         // we are going to do this manually to see who/what is
32480:         // deallocating.
32480: 
32480:         nsCOMPtr<nsISimpleEnumerator> e;
32480:         os->EnumerateObservers("memory-pressure", getter_AddRefs(e));
32480: 
32480:         if ( e ) {
32480:           nsCOMPtr<nsIObserver> observer;
79445:           bool loop = true;
32480: 
32480:           while (NS_SUCCEEDED(e->HasMoreElements(&loop)) && loop) 
32480:           {
32480:               e->GetNext(getter_AddRefs(observer));
32480: 
32480:               if (!observer)
32480:                   continue;
32480: 
32480:               observer->Observe(observer, "memory-pressure", aReason);
32480:           }
32480:         }
    1:     }
    1: 
    1:     sIsFlushing = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: // XXX need NS_IMPL_STATIC_ADDREF/RELEASE
    1: NS_IMETHODIMP_(nsrefcnt) nsMemoryImpl::FlushEvent::AddRef() { return 2; }
    1: NS_IMETHODIMP_(nsrefcnt) nsMemoryImpl::FlushEvent::Release() { return 1; }
    1: NS_IMPL_QUERY_INTERFACE1(nsMemoryImpl::FlushEvent, nsIRunnable)
    1: 
    1: NS_IMETHODIMP
    1: nsMemoryImpl::FlushEvent::Run()
    1: {
    1:     sGlobalMemory.RunFlushers(mReason);
    1:     return NS_OK;
    1: }
    1: 
    1: PRInt32
    1: nsMemoryImpl::sIsFlushing = 0;
    1: 
32480: PRIntervalTime
32480: nsMemoryImpl::sLastFlushTime = 0;
32480: 
    1: nsMemoryImpl::FlushEvent
    1: nsMemoryImpl::sFlushEvent;
    1: 
    1: XPCOM_API(void*)
    1: NS_Alloc(PRSize size)
    1: {
89041:     if (size > PR_INT32_MAX)
89041:         return nsnull;
89041: 
89041:     void* result = moz_malloc(size);
89041:     if (! result) {
89041:         // Request an asynchronous flush
89041:         sGlobalMemory.FlushMemory(NS_LITERAL_STRING("alloc-failure").get(), false);
89041:     }
89041:     return result;
    1: }
    1: 
    1: XPCOM_API(void*)
    1: NS_Realloc(void* ptr, PRSize size)
    1: {
89041:     if (size > PR_INT32_MAX)
89041:         return nsnull;
89041: 
89041:     void* result = moz_realloc(ptr, size);
89041:     if (! result && size != 0) {
89041:         // Request an asynchronous flush
89041:         sGlobalMemory.FlushMemory(NS_LITERAL_STRING("alloc-failure").get(), false);
89041:     }
89041:     return result;
    1: }
    1: 
    1: XPCOM_API(void)
    1: NS_Free(void* ptr)
    1: {
38925:     moz_free(ptr);
    1: }
    1: 
    1: nsresult
    1: NS_GetMemoryManager(nsIMemory* *result)
    1: {
    1:     return sGlobalMemory.QueryInterface(NS_GET_IID(nsIMemory), (void**) result);
    1: }
