53414: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53414:  * vim: set ts=8 sw=4 et tw=79:
53414:  *
53414:  * ***** BEGIN LICENSE BLOCK *****
50491:  * Copyright (C) 2009, 2010 University of Szeged
50491:  * All rights reserved.
50491:  *
50491:  * Redistribution and use in source and binary forms, with or without
50491:  * modification, are permitted provided that the following conditions
50491:  * are met:
50491:  * 1. Redistributions of source code must retain the above copyright
50491:  *    notice, this list of conditions and the following disclaimer.
50491:  * 2. Redistributions in binary form must reproduce the above copyright
50491:  *    notice, this list of conditions and the following disclaimer in the
50491:  *    documentation and/or other materials provided with the distribution.
50491:  *
50491:  * THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF SZEGED ``AS IS'' AND ANY
50491:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
50491:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
50491:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL UNIVERSITY OF SZEGED OR
50491:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
50491:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
50491:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
50491:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
50491:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
50491:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
50491:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
53414:  * 
53414:  * ***** END LICENSE BLOCK ***** */
50491: 
50491: #ifndef ARMAssembler_h
50491: #define ARMAssembler_h
50491: 
50491: #include "assembler/wtf/Platform.h"
50491: 
50491: // Some debug code uses s(n)printf for instruction logging.
50491: #include <stdio.h>
50491: 
50491: #if ENABLE_ASSEMBLER && WTF_CPU_ARM_TRADITIONAL
50491: 
50491: #include "AssemblerBufferWithConstantPool.h"
50491: #include "assembler/wtf/Assertions.h"
50491: 
50491: #include "methodjit/Logging.h"
50491: #define IPFX    "        %s"
50491: #define ISPFX   "        "
50491: #ifdef JS_METHODJIT_SPEW
50491: # define MAYBE_PAD (isOOLPath ? ">  " : "")
50491: # define FIXME_INSN_PRINTING                                \
50491:     do {                                                   \
50491:         js::JaegerSpew(js::JSpew_Insns,                    \
50491:                        IPFX "FIXME insn printing %s:%d\n", \
50491:                        MAYBE_PAD,                          \
50491:                        __FILE__, __LINE__);                \
50491:     } while (0)
50491: #else
50491: # define MAYBE_PAD ""
50491: # define FIXME_INSN_PRINTING ((void) 0)
50491: #endif
50491: 
50491: // TODO: We don't print the condition code in our JaegerSpew lines. Doing this
50491: // is awkward whilst maintaining a consistent field width.
50491: 
50491: namespace JSC {
50491: 
50491:     typedef uint32_t ARMWord;
50491: 
50491:     namespace ARMRegisters {
50491:         typedef enum {
50491:             r0 = 0,
50491:             r1,
50491:             r2,
50491:             r3,
50491:             S0 = r3,
50491:             r4,
50491:             r5,
50491:             r6,
50491:             r7,
50491:             r8,
50491:             S1 = r8,
50491:             r9,
50491:             r10,
50491:             r11,
50491:             r12,
50491:             ip = r12,
50491:             r13,
50491:             sp = r13,
50491:             r14,
50491:             lr = r14,
50491:             r15,
50491:             pc = r15
50491:         } RegisterID;
50491: 
50491:         typedef enum {
50491:             d0,
50491:             d1,
50491:             d2,
50491:             d3,
50491:             SD0 = d3,
50491:             d4,
50491:             d5,
50491:             d6,
50491:             d7,
50491:             d8,
50491:             d9,
50491:             d10,
50491:             d11,
50491:             d12,
50491:             d13,
50491:             d14,
50491:             d15,
50491:             d16,
50491:             d17,
50491:             d18,
50491:             d19,
50491:             d20,
50491:             d21,
50491:             d22,
50491:             d23,
50491:             d24,
50491:             d25,
50491:             d26,
50491:             d27,
50491:             d28,
50491:             d29,
50491:             d30,
50491:             d31
50491:         } FPRegisterID;
50491: 
50491:     } // namespace ARMRegisters
50491: 
50491:     class ARMAssembler {
50491:     public:
50491:         
55524: #ifdef JS_METHODJIT_SPEW
50491:         bool isOOLPath;
50491:         // Assign a default value to keep Valgrind quiet.
50491:         ARMAssembler() : isOOLPath(false) { }
50491: #else
50491:         ARMAssembler() { }
50491: #endif
50491: 
50491:         typedef ARMRegisters::RegisterID RegisterID;
50491:         typedef ARMRegisters::FPRegisterID FPRegisterID;
50491:         typedef AssemblerBufferWithConstantPool<2048, 4, 4, ARMAssembler> ARMBuffer;
50491:         typedef SegmentedVector<int, 64> Jumps;
50491: 
50491:         unsigned char *buffer() const { return m_buffer.buffer(); }
56037:         bool oom() const { return m_buffer.oom(); }
50491: 
50491:         // ARM conditional constants
50491:         typedef enum {
50491:             EQ = 0x00000000, // Zero
50491:             NE = 0x10000000, // Non-zero
50491:             CS = 0x20000000,
50491:             CC = 0x30000000,
50491:             MI = 0x40000000,
50491:             PL = 0x50000000,
50491:             VS = 0x60000000,
50491:             VC = 0x70000000,
50491:             HI = 0x80000000,
50491:             LS = 0x90000000,
50491:             GE = 0xa0000000,
50491:             LT = 0xb0000000,
50491:             GT = 0xc0000000,
50491:             LE = 0xd0000000,
50491:             AL = 0xe0000000
50491:         } Condition;
50491: 
50491:         // ARM instruction constants
50491:         enum {
50491:             AND = (0x0 << 21),
50491:             EOR = (0x1 << 21),
50491:             SUB = (0x2 << 21),
50491:             RSB = (0x3 << 21),
50491:             ADD = (0x4 << 21),
50491:             ADC = (0x5 << 21),
50491:             SBC = (0x6 << 21),
50491:             RSC = (0x7 << 21),
50491:             TST = (0x8 << 21),
50491:             TEQ = (0x9 << 21),
50491:             CMP = (0xa << 21),
50491:             CMN = (0xb << 21),
50491:             ORR = (0xc << 21),
50491:             MOV = (0xd << 21),
50491:             BIC = (0xe << 21),
50491:             MVN = (0xf << 21),
50491:             MUL = 0x00000090,
50491:             MULL = 0x00c00090,
50491:             FCPYD = 0x0eb00b40,
50491:             FADDD = 0x0e300b00,
50491:             FNEGD = 0x0eb10b40,
50491:             FDIVD = 0x0e800b00,
50491:             FSUBD = 0x0e300b40,
50491:             FMULD = 0x0e200b00,
50491:             FCMPD = 0x0eb40b40,
50491:             FSQRTD = 0x0eb10bc0,
50491:             DTR = 0x05000000,
50491:             LDRH = 0x00100090,
50491:             STRH = 0x00000090,
50491:             STMDB = 0x09200000,
50491:             LDMIA = 0x08b00000,
50491:             FDTR = 0x0d000b00,
50491:             B = 0x0a000000,
50491:             BL = 0x0b000000
50491: #if WTF_ARM_ARCH_VERSION >= 5 || defined(__ARM_ARCH_4T__)
50491:            ,BX = 0x012fff10
50491: #endif
50491:            ,FMSR = 0x0e000a10,
50491:             FMRS = 0x0e100a10,
50491:             FSITOD = 0x0eb80bc0,
50491:             FTOSID = 0x0ebd0b40,
53379:             FTOSIZD = 0x0ebd0bc0,
50491:             FMSTAT = 0x0ef1fa10
50491: #if WTF_ARM_ARCH_VERSION >= 5
50491:            ,CLZ = 0x016f0f10,
50491:             BKPT = 0xe120070,
50491:             BLX = 0x012fff30
50491: #endif
50491: #if WTF_ARM_ARCH_VERSION >= 7
50491:            ,MOVW = 0x03000000,
50491:             MOVT = 0x03400000
50491: #endif
50491:         };
50491: 
50491:         enum {
50491:             OP2_IMM = (1 << 25),
50491:             OP2_IMMh = (1 << 22),
50491:             OP2_INV_IMM = (1 << 26),
50491:             SET_CC = (1 << 20),
50491:             OP2_OFSREG = (1 << 25),
50491:             DT_UP = (1 << 23),
50491:             DT_BYTE = (1 << 22),
50491:             DT_WB = (1 << 21),
50491:             // This flag is inlcuded in LDR and STR
50491:             DT_PRE = (1 << 24),
50491:             HDT_UH = (1 << 5),
50491:             DT_LOAD = (1 << 20)
50491:         };
50491: 
50491:         // Masks of ARM instructions
50491:         enum {
50491:             BRANCH_MASK = 0x00ffffff,
50491:             NONARM = 0xf0000000,
50491:             SDT_MASK = 0x0c000000,
50491:             SDT_OFFSET_MASK = 0xfff
50491:         };
50491: 
50491:         enum {
50491:             BOFFSET_MIN = -0x00800000,
50491:             BOFFSET_MAX = 0x007fffff,
50491:             SDT = 0x04000000
50491:         };
50491: 
50491:         enum {
50491:             padForAlign8  = 0x00,
50491:             padForAlign16 = 0x0000,
50491:             padForAlign32 = 0xee120070
50491:         };
50491: 
50491:         typedef enum {
50491:             LSL = 0,
50491:             LSR = 1,
50491:             ASR = 2,
50491:             ROR = 3
50491:         } Shift;
50491: 
50491:         static const ARMWord INVALID_IMM = 0xf0000000;
50491:         static const ARMWord InvalidBranchTarget = 0xffffffff;
50491:         static const int DefaultPrefetching = 2;
50491: 
50491:         class JmpSrc {
50491:             friend class ARMAssembler;
50491:         public:
50491:             JmpSrc()
50491:                 : m_offset(-1)
50491:             {
50491:             }
50491: 
50491:         private:
50491:             JmpSrc(int offset)
50491:                 : m_offset(offset)
50491:             {
50491:             }
50491: 
50491:             int m_offset;
50491:         };
50491: 
50491:         class JmpDst {
50491:             friend class ARMAssembler;
50491:         public:
50491:             JmpDst()
50491:                 : m_offset(-1)
50491:                 , m_used(false)
50491:             {
50491:             }
50491: 
50491:             bool isUsed() const { return m_used; }
50491:             void used() { m_used = true; }
50491:             bool isValid() const { return m_offset != -1; }
50491:         private:
50491:             JmpDst(int offset)
50491:                 : m_offset(offset)
50491:                 , m_used(false)
50491:             {
50491:                 ASSERT(m_offset == offset);
50491:             }
50491: 
50491:             int m_offset : 31;
50491:             int m_used : 1;
50491:         };
50491: 
50491:         // Instruction formating
50491: 
50491:         void emitInst(ARMWord op, int rd, int rn, ARMWord op2)
50491:         {
50491:             ASSERT ( ((op2 & ~OP2_IMM) <= 0xfff) || (((op2 & ~OP2_IMMh) <= 0xfff)) );
50491:             m_buffer.putInt(op | RN(rn) | RD(rd) | op2);
50491:         }
50491: 
50491:         void and_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("and", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | AND, rd, rn, op2);
50491:         }
50491: 
50491:         void ands_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("ands", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | AND | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void eor_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("eor", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | EOR, rd, rn, op2);
50491:         }
50491: 
50491:         void eors_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("eors", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | EOR | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void sub_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("sub", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | SUB, rd, rn, op2);
50491:         }
50491: 
50491:         void subs_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("subs", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | SUB | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void rsb_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("rsb", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | RSB, rd, rn, op2);
50491:         }
50491: 
50491:         void rsbs_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("rsbs", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | RSB | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void add_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("add", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | ADD, rd, rn, op2);
50491:         }
50491: 
50491:         void adds_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("adds", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | ADD | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void adc_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("adc", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | ADC, rd, rn, op2);
50491:         }
50491: 
50491:         void adcs_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("adcs", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | ADC | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void sbc_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("sbc", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | SBC, rd, rn, op2);
50491:         }
50491: 
50491:         void sbcs_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("sbcs", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | SBC | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void rsc_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("rsc", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | RSC, rd, rn, op2);
50491:         }
50491: 
50491:         void rscs_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("rscs", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | RSC | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void tst_r(int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("tst", cc, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | TST | SET_CC, 0, rn, op2);
50491:         }
50491: 
50491:         void teq_r(int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("teq", cc, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | TEQ | SET_CC, 0, rn, op2);
50491:         }
50491: 
50491:         void cmp_r(int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("cmp", cc, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | CMP | SET_CC, 0, rn, op2);
50491:         }
50491: 
53379:         void cmn_r(int rn, ARMWord op2, Condition cc = AL)
53379:         {
53379:             spewInsWithOp2("cmn", cc, rn, op2);
53379:             emitInst(static_cast<ARMWord>(cc) | CMN | SET_CC, 0, rn, op2);
53379:         }
53379: 
50491:         void orr_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("orr", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | ORR, rd, rn, op2);
50491:         }
50491: 
50491:         void orrs_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("orrs", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | ORR | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void mov_r(int rd, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("mov", cc, rd, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | MOV, rd, ARMRegisters::r0, op2);
50491:         }
50491: 
50491: #if WTF_ARM_ARCH_VERSION >= 7
50491:         void movw_r(int rd, ARMWord op2, Condition cc = AL)
50491:         {
50491:             ASSERT((op2 | 0xf0fff) == 0xf0fff);
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX    "%-15s %s, 0x%04x\n", MAYBE_PAD, "movw", nameGpReg(rd), (op2 & 0xfff) | ((op2 >> 4) & 0xf000));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | MOVW | RD(rd) | op2);
50491:         }
50491: 
50491:         void movt_r(int rd, ARMWord op2, Condition cc = AL)
50491:         {
50491:             ASSERT((op2 | 0xf0fff) == 0xf0fff);
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX    "%-15s %s, 0x%04x\n", MAYBE_PAD, "movt", nameGpReg(rd), (op2 & 0xfff) | ((op2 >> 4) & 0xf000));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | MOVT | RD(rd) | op2);
50491:         }
50491: #endif
50491: 
50491:         void movs_r(int rd, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("movs", cc, rd, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | MOV | SET_CC, rd, ARMRegisters::r0, op2);
50491:         }
50491: 
50491:         void bic_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("bic", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | BIC, rd, rn, op2);
50491:         }
50491: 
50491:         void bics_r(int rd, int rn, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("bics", cc, rd, rn, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | BIC | SET_CC, rd, rn, op2);
50491:         }
50491: 
50491:         void mvn_r(int rd, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("mvn", cc, rd, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | MVN, rd, ARMRegisters::r0, op2);
50491:         }
50491: 
50491:         void mvns_r(int rd, ARMWord op2, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("mvns", cc, rd, op2);
50491:             emitInst(static_cast<ARMWord>(cc) | MVN | SET_CC, rd, ARMRegisters::r0, op2);
50491:         }
50491: 
50491:         void mul_r(int rd, int rn, int rm, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("mul", cc, rd, rn, static_cast<ARMWord>(rm));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | MUL | RN(rd) | RS(rn) | RM(rm));
50491:         }
50491: 
50491:         void muls_r(int rd, int rn, int rm, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("muls", cc, rd, rn, static_cast<ARMWord>(rm));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | MUL | SET_CC | RN(rd) | RS(rn) | RM(rm));
50491:         }
50491: 
50491:         void mull_r(int rdhi, int rdlo, int rn, int rm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s, %s\n", MAYBE_PAD, "mull", nameGpReg(rdlo), nameGpReg(rdhi), nameGpReg(rn), nameGpReg(rm));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | MULL | RN(rdhi) | RD(rdlo) | RS(rn) | RM(rm));
50491:         }
50491: 
50491:         void fcpyd_r(int dd, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s\n", MAYBE_PAD, "vmov.f64", nameFpRegD(dd), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FCPYD, dd, dd, dm);
50491:         }
50491: 
50491:         void faddd_r(int dd, int dn, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s\n", MAYBE_PAD, "vadd.f64", nameFpRegD(dd), nameFpRegD(dn), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FADDD, dd, dn, dm);
50491:         }
50491: 
50491:         void fnegd_r(int dd, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s, %s\n", MAYBE_PAD, "fnegd", nameFpRegD(dd), nameFpRegD(dm));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | FNEGD | DD(dd) | DM(dm));
50491:         }
50491: 
50491:         void fdivd_r(int dd, int dn, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s\n", MAYBE_PAD, "vdiv.f64", nameFpRegD(dd), nameFpRegD(dn), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FDIVD, dd, dn, dm);
50491:         }
50491: 
50491:         void fsubd_r(int dd, int dn, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s\n", MAYBE_PAD, "vsub.f64", nameFpRegD(dd), nameFpRegD(dn), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FSUBD, dd, dn, dm);
50491:         }
50491: 
50491:         void fmuld_r(int dd, int dn, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s\n", MAYBE_PAD, "vmul.f64", nameFpRegD(dd), nameFpRegD(dn), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FMULD, dd, dn, dm);
50491:         }
50491: 
50491:         void fcmpd_r(int dd, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s\n", MAYBE_PAD, "vcmp.f64", nameFpRegD(dd), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FCMPD, dd, 0, dm);
50491:         }
50491: 
50491:         void fsqrtd_r(int dd, int dm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s\n", MAYBE_PAD, "vsqrt.f64", nameFpRegD(dd), nameFpRegD(dm));
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FSQRTD, dd, 0, dm);
50491:         }
50491: 
50491:         void ldr_imm(int rd, ARMWord imm, Condition cc = AL)
50491:         {
50491:             char mnemonic[16];
50491:             snprintf(mnemonic, 16, "ldr%s", nameCC(cc));
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX    "%-15s %s, =0x%x @ (%d) (reusable pool entry)\n", MAYBE_PAD, mnemonic, nameGpReg(rd), imm, static_cast<int32_t>(imm));
50491:             m_buffer.putIntWithConstantInt(static_cast<ARMWord>(cc) | DTR | DT_LOAD | DT_UP | RN(ARMRegisters::pc) | RD(rd), imm, true);
50491:         }
50491: 
50491:         void ldr_un_imm(int rd, ARMWord imm, Condition cc = AL)
50491:         {
50491:             char mnemonic[16];
50491:             snprintf(mnemonic, 16, "ldr%s", nameCC(cc));
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX    "%-15s %s, =0x%x @ (%d)\n", MAYBE_PAD, mnemonic, nameGpReg(rd), imm, static_cast<int32_t>(imm));
50491:             m_buffer.putIntWithConstantInt(static_cast<ARMWord>(cc) | DTR | DT_LOAD | DT_UP | RN(ARMRegisters::pc) | RD(rd), imm);
50491:         }
50491: 
50491:         // Data transfers like this:
50491:         //  LDR rd, [rb, +offset]
50491:         //  STR rd, [rb, +offset]
50491:         void dtr_u(bool isLoad, int rd, int rb, ARMWord offset, Condition cc = AL)
50491:         {
50491:             char const * mnemonic = (isLoad) ? ("ldr") : ("str");
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, #+%u]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), offset);
50491:             emitInst(static_cast<ARMWord>(cc) | DTR | (isLoad ? DT_LOAD : 0) | DT_UP, rd, rb, offset);
50491:         }
50491: 
50491:         // Data transfers like this:
50491:         //  LDR rd, [rb, +rm]
50491:         //  STR rd, [rb, +rm]
50491:         void dtr_ur(bool isLoad, int rd, int rb, int rm, Condition cc = AL)
50491:         {
50491:             char const * mnemonic = (isLoad) ? ("ldr") : ("str");
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, +%s]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), nameGpReg(rm));
50491:             emitInst(static_cast<ARMWord>(cc) | DTR | (isLoad ? DT_LOAD : 0) | DT_UP | OP2_OFSREG, rd, rb, rm);
50491:         }
50491: 
50491:         // Data transfers like this:
50491:         //  LDR rd, [rb, -offset]
50491:         //  STR rd, [rb, -offset]
50491:         void dtr_d(bool isLoad, int rd, int rb, ARMWord offset, Condition cc = AL)
50491:         {
50491:             char const * mnemonic = (isLoad) ? ("ldr") : ("str");
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, #-%u]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), offset);
50491:             emitInst(static_cast<ARMWord>(cc) | DTR | (isLoad ? DT_LOAD : 0), rd, rb, offset);
50491:         }
50491: 
50491:         // Data transfers like this:
50491:         //  LDR rd, [rb, -rm]
50491:         //  STR rd, [rb, -rm]
50491:         void dtr_dr(bool isLoad, int rd, int rb, int rm, Condition cc = AL)
50491:         {
50491:             char const * mnemonic = (isLoad) ? ("ldr") : ("str");
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, -%s]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), nameGpReg(rm));
50491:             emitInst(static_cast<ARMWord>(cc) | DTR | (isLoad ? DT_LOAD : 0) | OP2_OFSREG, rd, rb, rm);
50491:         }
50491: 
50693:         // Data transfers like this:
50693:         //  LDRB rd, [rb, +offset]
50693:         //  STRB rd, [rb, +offset]
50693:         void dtrb_u(bool isLoad, int rd, int rb, ARMWord offset, Condition cc = AL)
50693:         {
50693:             char const * mnemonic = (isLoad) ? ("ldrb") : ("strb");
50693:             js::JaegerSpew(js::JSpew_Insns,
50693:                     IPFX   "%-15s %s, [%s, #+%u]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), offset);
50693:             emitInst(static_cast<ARMWord>(cc) | DTR | DT_BYTE | (isLoad ? DT_LOAD : 0) | DT_UP, rd, rb, offset);
50693:         }
50693: 
50693:         // Data transfers like this:
50693:         //  LDRB rd, [rb, +rm]
50693:         //  STRB rd, [rb, +rm]
50693:         void dtrb_ur(bool isLoad, int rd, int rb, int rm, Condition cc = AL)
50693:         {
50693:             char const * mnemonic = (isLoad) ? ("ldrb") : ("strb");
50693:             js::JaegerSpew(js::JSpew_Insns,
50693:                     IPFX   "%-15s %s, [%s, +%s]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), nameGpReg(rm));
50693:             emitInst(static_cast<ARMWord>(cc) | DTR | DT_BYTE | (isLoad ? DT_LOAD : 0) | DT_UP | OP2_OFSREG, rd, rb, rm);
50693:         }
50693: 
50693:         // Data transfers like this:
50693:         //  LDRB rd, [rb, -offset]
50693:         //  STRB rd, [rb, -offset]
50693:         void dtrb_d(bool isLoad, int rd, int rb, ARMWord offset, Condition cc = AL)
50693:         {
50693:             char const * mnemonic = (isLoad) ? ("ldrb") : ("strb");
50693:             js::JaegerSpew(js::JSpew_Insns,
50693:                     IPFX   "%-15s %s, [%s, #-%u]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), offset);
50693:             emitInst(static_cast<ARMWord>(cc) | DTR | DT_BYTE | (isLoad ? DT_LOAD : 0), rd, rb, offset);
50693:         }
50693: 
50693:         // Data transfers like this:
50693:         //  LDRB rd, [rb, -rm]
50693:         //  STRB rd, [rb, -rm]
50693:         void dtrb_dr(bool isLoad, int rd, int rb, int rm, Condition cc = AL)
50693:         {
50693:             char const * mnemonic = (isLoad) ? ("ldrb") : ("strb");
50693:             js::JaegerSpew(js::JSpew_Insns,
50693:                     IPFX   "%-15s %s, [%s, -%s]\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rb), nameGpReg(rm));
50693:             emitInst(static_cast<ARMWord>(cc) | DTR | DT_BYTE | (isLoad ? DT_LOAD : 0) | OP2_OFSREG, rd, rb, rm);
50693:         }
50693: 
50491:         void ldrh_r(int rd, int rb, int rm, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, +%s]\n", MAYBE_PAD, "ldrh", nameGpReg(rd), nameGpReg(rb), nameGpReg(rm));
50491:             emitInst(static_cast<ARMWord>(cc) | LDRH | HDT_UH | DT_UP | DT_PRE, rd, rb, rm);
50491:         }
50491: 
50491:         void ldrh_d(int rd, int rb, ARMWord offset, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, #-%u]\n", MAYBE_PAD, "ldrh", nameGpReg(rd), nameGpReg(rb), offset);
50491:             emitInst(static_cast<ARMWord>(cc) | LDRH | HDT_UH | DT_PRE, rd, rb, offset);
50491:         }
50491: 
50491:         void ldrh_u(int rd, int rb, ARMWord offset, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, #+%u]\n", MAYBE_PAD, "ldrh", nameGpReg(rd), nameGpReg(rb), offset);
50491:             emitInst(static_cast<ARMWord>(cc) | LDRH | HDT_UH | DT_UP | DT_PRE, rd, rb, offset);
50491:         }
50491: 
50491:         void strh_r(int rb, int rm, int rd, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, [%s, +%s]\n", MAYBE_PAD, "strh", nameGpReg(rd), nameGpReg(rb), nameGpReg(rm));
50491:             emitInst(static_cast<ARMWord>(cc) | STRH | HDT_UH | DT_UP | DT_PRE, rd, rb, rm);
50491:         }
50491: 
50491:         void fdtr_u(bool isLoad, int dd, int rn, ARMWord offset, Condition cc = AL)
50491:         {
53379:             char const * ins = isLoad ? "vldr.f64" : "vstr.f64";
50491:             js::JaegerSpew(js::JSpew_Insns,
53379:                     IPFX   "%-15s %s, [%s, #+%u]\n", MAYBE_PAD, ins, nameFpRegD(dd), nameGpReg(rn), offset);
50491:             ASSERT(offset <= 0xff);
50491:             emitInst(static_cast<ARMWord>(cc) | FDTR | DT_UP | (isLoad ? DT_LOAD : 0), dd, rn, offset);
50491:         }
50491: 
50491:         void fdtr_d(bool isLoad, int dd, int rn, ARMWord offset, Condition cc = AL)
50491:         {
53379:             char const * ins = isLoad ? "vldr.f64" : "vstr.f64";
50491:             js::JaegerSpew(js::JSpew_Insns,
53379:                     IPFX   "%-15s %s, [%s, #-%u]\n", MAYBE_PAD, ins, nameFpRegD(dd), nameGpReg(rn), offset);
50491:             ASSERT(offset <= 0xff);
50491:             emitInst(static_cast<ARMWord>(cc) | FDTR | (isLoad ? DT_LOAD : 0), dd, rn, offset);
50491:         }
50491: 
50491:         void push_r(int reg, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s {%s}\n", MAYBE_PAD, "push", nameGpReg(reg));
50491:             ASSERT(ARMWord(reg) <= 0xf);
50491:             m_buffer.putInt(cc | DTR | DT_WB | RN(ARMRegisters::sp) | RD(reg) | 0x4);
50491:         }
50491: 
50491:         void pop_r(int reg, Condition cc = AL)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s {%s}\n", MAYBE_PAD, "pop", nameGpReg(reg));
50491:             ASSERT(ARMWord(reg) <= 0xf);
50491:             m_buffer.putInt(cc | (DTR ^ DT_PRE) | DT_LOAD | DT_UP | RN(ARMRegisters::sp) | RD(reg) | 0x4);
50491:         }
50491: 
50491:         inline void poke_r(int reg, Condition cc = AL)
50491:         {
50491:             dtr_d(false, ARMRegisters::sp, 0, reg, cc);
50491:         }
50491: 
50491:         inline void peek_r(int reg, Condition cc = AL)
50491:         {
50491:             dtr_u(true, reg, ARMRegisters::sp, 0, cc);
50491:         }
50491: 
50491:         void fmsr_r(int dd, int rn, Condition cc = AL)
50491:         {
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FMSR, rn, dd, 0);
50491:         }
50491: 
50491:         void fmrs_r(int rd, int dn, Condition cc = AL)
50491:         {
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FMRS, rd, dn, 0);
50491:         }
50491: 
50491:         void fsitod_r(int dd, int dm, Condition cc = AL)
50491:         {
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FSITOD, dd, 0, dm);
50491:         }
50491: 
50491:         void ftosid_r(int fd, int dm, Condition cc = AL)
50491:         {
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             emitInst(static_cast<ARMWord>(cc) | FTOSID, fd, 0, dm);
50491:         }
50491: 
53379:         void ftosizd_r(int fd, int dm, Condition cc = AL)
53379:         {
53379:             // TODO: emitInst doesn't work for VFP instructions, though it
53379:             // seems to work for current usage.
53379:             emitInst(static_cast<ARMWord>(cc) | FTOSIZD, fd, 0, dm);
53379:         }
53379: 
50491:         void fmstat(Condition cc = AL)
50491:         {
50491:             // TODO: emitInst doesn't work for VFP instructions, though it
50491:             // seems to work for current usage.
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | FMSTAT);
50491:         }
50491: 
50491: #if WTF_ARM_ARCH_VERSION >= 5
50491:         void clz_r(int rd, int rm, Condition cc = AL)
50491:         {
50491:             spewInsWithOp2("clz", cc, rd, static_cast<ARMWord>(rm));
50491:             m_buffer.putInt(static_cast<ARMWord>(cc) | CLZ | RD(rd) | RM(rm));
50491:         }
50491: #endif
50491: 
50491:         void bkpt(ARMWord value)
50491:         {
50491: #if WTF_ARM_ARCH_VERSION >= 5
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s #0x%04x\n", MAYBE_PAD, "bkpt", value);
50491:             m_buffer.putInt(BKPT | ((value & 0xfff0) << 4) | (value & 0xf));
50491: #else
50491:             // Cannot access to Zero memory address
50491:             dtr_dr(true, ARMRegisters::S0, ARMRegisters::S0, ARMRegisters::S0);
50491: #endif
50491:         }
50491: 
50491:         void bx(int rm, Condition cc = AL)
50491:         {
50491: #if WTF_ARM_ARCH_VERSION >= 5 || defined(__ARM_ARCH_4T__)
50491:             js::JaegerSpew(
50491:                     js::JSpew_Insns,
50491:                     IPFX    "bx%-13s %s\n", MAYBE_PAD, nameCC(cc), nameGpReg(rm));
50491:             emitInst(static_cast<ARMWord>(cc) | BX, 0, 0, RM(rm));
50491: #else
50491:             mov_r(ARMRegisters::pc, RM(rm), cc);
50491: #endif
50491:         }
50491: 
50491:         JmpSrc blx(int rm, Condition cc = AL)
50491:         {
50491: #if WTF_ARM_ARCH_AT_LEAST(5)
50491:             int s = m_buffer.uncheckedSize();
50491:             js::JaegerSpew(
50491:                     js::JSpew_Insns,
50491:                     IPFX    "blx%-12s %s\n", MAYBE_PAD, nameCC(cc), nameGpReg(rm));
50491:             emitInst(static_cast<ARMWord>(cc) | BLX, 0, 0, RM(rm));
50491: #else
50491:             ASSERT(rm != 14);
50491:             ensureSpace(2 * sizeof(ARMWord), 0);
50491:             mov_r(ARMRegisters::lr, ARMRegisters::pc, cc);
50491:             int s = m_buffer.uncheckedSize();
50491:             bx(rm, cc);
50491: #endif
50491:             return JmpSrc(s);
50491:         }
50491: 
50491:         static ARMWord lsl(int reg, ARMWord value)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             ASSERT(value <= 0x1f);
50491:             return reg | (value << 7) | (LSL << 5);
50491:         }
50491: 
50491:         static ARMWord lsr(int reg, ARMWord value)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             ASSERT(value <= 0x1f);
50491:             return reg | (value << 7) | (LSR << 5);
50491:         }
50491: 
50491:         static ARMWord asr(int reg, ARMWord value)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             ASSERT(value <= 0x1f);
50491:             return reg | (value << 7) | (ASR << 5);
50491:         }
50491: 
50491:         static ARMWord lsl_r(int reg, int shiftReg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             ASSERT(shiftReg <= ARMRegisters::pc);
50491:             return reg | (shiftReg << 8) | (LSL << 5) | 0x10;
50491:         }
50491: 
50491:         static ARMWord lsr_r(int reg, int shiftReg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             ASSERT(shiftReg <= ARMRegisters::pc);
50491:             return reg | (shiftReg << 8) | (LSR << 5) | 0x10;
50491:         }
50491: 
50491:         static ARMWord asr_r(int reg, int shiftReg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             ASSERT(shiftReg <= ARMRegisters::pc);
50491:             return reg | (shiftReg << 8) | (ASR << 5) | 0x10;
50491:         }
50491: 
50491:         // General helpers
50491: 
50491:         void forceFlushConstantPool()
50491:         {
50491:             m_buffer.flushWithoutBarrier(true);
50491:         }
50491: 
50491:         int size()
50491:         {
50491:             return m_buffer.size();
50491:         }
50491: 
50491:         void ensureSpace(int insnSpace, int constSpace)
50491:         {
50491:             m_buffer.ensureSpace(insnSpace, constSpace);
50491:         }
50491: 
50491:         int sizeOfConstantPool()
50491:         {
50491:             return m_buffer.sizeOfConstantPool();
50491:         }
50491: 
50491:         JmpDst label()
50491:         {
50491:             return JmpDst(m_buffer.size());
50491:         }
50491: 
50491:         JmpDst align(int alignment)
50491:         {
50491:             while (!m_buffer.isAligned(alignment))
50491:                 mov_r(ARMRegisters::r0, ARMRegisters::r0);
50491: 
50491:             return label();
50491:         }
50491: 
50491:         JmpSrc loadBranchTarget(int rd, Condition cc = AL, int useConstantPool = 0)
50491:         {
50491:             ensureSpace(sizeof(ARMWord), sizeof(ARMWord));
50491:             int s = m_buffer.uncheckedSize();
50491:             ldr_un_imm(rd, InvalidBranchTarget, cc);
50491:             m_jumps.append(s | (useConstantPool & 0x1));
50491:             return JmpSrc(s);
50491:         }
50491: 
50491:         JmpSrc jmp(Condition cc = AL, int useConstantPool = 0)
50491:         {
50491:             return loadBranchTarget(ARMRegisters::pc, cc, useConstantPool);
50491:         }
50491: 
50491:         void* executableCopy(ExecutablePool* allocator);
50491:         void* executableCopy(void* buffer);
50491:         void fixUpOffsets(void* buffer);
50491: 
50491:         // Patching helpers
50491: 
50491:         static ARMWord* getLdrImmAddress(ARMWord* insn)
50491:         {
50491: #if WTF_ARM_ARCH_AT_LEAST(5)
50491:             // Check for call
50491:             if ((*insn & 0x0f7f0000) != 0x051f0000) {
50491:                 // Must be BLX
50491:                 ASSERT((*insn & 0x012fff30) == 0x012fff30);
50491:                 insn--;
50491:             }
50491: #endif
50491:             // Must be an ldr ..., [pc +/- imm]
50491:             ASSERT((*insn & 0x0f7f0000) == 0x051f0000);
50491: 
50491:             ARMWord addr = reinterpret_cast<ARMWord>(insn) + DefaultPrefetching * sizeof(ARMWord);
50491:             if (*insn & DT_UP)
50491:                 return reinterpret_cast<ARMWord*>(addr + (*insn & SDT_OFFSET_MASK));
50491:             return reinterpret_cast<ARMWord*>(addr - (*insn & SDT_OFFSET_MASK));
50491:         }
50491: 
50491:         static ARMWord* getLdrImmAddressOnPool(ARMWord* insn, uint32_t* constPool)
50491:         {
50491:             // Must be an ldr ..., [pc +/- imm]
50491:             ASSERT((*insn & 0x0f7f0000) == 0x051f0000);
50491: 
50491:             if (*insn & 0x1)
50491:                 return reinterpret_cast<ARMWord*>(constPool + ((*insn & SDT_OFFSET_MASK) >> 1));
50491:             return getLdrImmAddress(insn);
50491:         }
50491: 
50491:         static void patchPointerInternal(intptr_t from, void* to)
50491:         {
50491:             ARMWord* insn = reinterpret_cast<ARMWord*>(from);
50491:             ARMWord* addr = getLdrImmAddress(insn);
50491:             *addr = reinterpret_cast<ARMWord>(to);
50491:         }
50491: 
50491:         static ARMWord patchConstantPoolLoad(ARMWord load, ARMWord value)
50491:         {
50491:             value = (value << 1) + 1;
50491:             ASSERT(!(value & ~0xfff));
50491:             return (load & ~0xfff) | value;
50491:         }
50491: 
50491:         static void patchConstantPoolLoad(void* loadAddr, void* constPoolAddr);
50491: 
50491:         // Patch pointers
50491: 
50491:         static void linkPointer(void* code, JmpDst from, void* to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##linkPointer     ((%p + %#x)) points to ((%p))\n",
50491:                            code, from.m_offset, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(code) + from.m_offset, to);
50491:         }
50491: 
50491:         static void repatchInt32(void* from, int32_t to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##repatchInt32    ((%p)) holds ((%p))\n",
50491:                            from, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(from), reinterpret_cast<void*>(to));
50491:         }
50491: 
50491:         static void repatchPointer(void* from, void* to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##repatchPointer  ((%p)) points to ((%p))\n",
50491:                            from, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(from), to);
50491:         }
50491: 
50491:         static void repatchLoadPtrToLEA(void* from)
50491:         {
50491:             // On arm, this is a patch from LDR to ADD. It is restricted conversion,
50491:             // from special case to special case, altough enough for its purpose
50491:             ARMWord* insn = reinterpret_cast<ARMWord*>(from);
50491:             ASSERT((*insn & 0x0ff00f00) == 0x05900000);
50491: 
50491:             *insn = (*insn & 0xf00ff0ff) | 0x02800000;
50491:             ExecutableAllocator::cacheFlush(insn, sizeof(ARMWord));
50491:         }
50491: 
50491:         static void repatchLEAToLoadPtr(void* from)
50491:         {
50491: 	    // Like repatchLoadPtrToLEA, this is specialized for our purpose.
50491:             ARMWord* insn = reinterpret_cast<ARMWord*>(from);
50491: 	    if ((*insn & 0x0ff00f00) == 0x05900000)
50491: 		return;
50491:             ASSERT((*insn & 0xf00ff0ff) == 0x02800000);
50491: 
50491:             *insn = (*insn &  0x0ff00f00) | 0x05900000;
50491:             ExecutableAllocator::cacheFlush(insn, sizeof(ARMWord));
50491:         }
50491: 
50491:         // Linkers
50491: 
50491:         void linkJump(JmpSrc from, JmpDst to)
50491:         {
50491:             ARMWord  code = reinterpret_cast<ARMWord>(m_buffer.data());
50491:             ARMWord* insn = reinterpret_cast<ARMWord*>(code + from.m_offset);
50491:             ARMWord* addr = getLdrImmAddressOnPool(insn, m_buffer.poolAddress());
50491: 
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            IPFX "##linkJump         ((%#x)) jumps to ((%#x))\n", MAYBE_PAD,
50491:                            from.m_offset, to.m_offset);
50491: 
50491:             *addr = to.m_offset;
50491:         }
50491: 
50491:         static void linkJump(void* code, JmpSrc from, void* to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##linkJump        ((%p + %#x)) jumps to ((%p))\n",
50491:                            code, from.m_offset, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(code) + from.m_offset, to);
50491:         }
50491: 
50491:         static void relinkJump(void* from, void* to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##relinkJump      ((%p)) jumps to ((%p))\n",
50491:                            from, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(from) - sizeof(ARMWord), to);
50491:         }
50491: 
50491:         static void linkCall(void* code, JmpSrc from, void* to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##linkCall        ((%p + %#x)) jumps to ((%p))\n",
50491:                            code, from.m_offset, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(code) + from.m_offset, to);
50491:         }
50491: 
50491:         static void relinkCall(void* from, void* to)
50491:         {
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                            ISPFX "##relinkCall      ((%p)) jumps to ((%p))\n",
50491:                            from, to);
50491: 
50491:             patchPointerInternal(reinterpret_cast<intptr_t>(from) - sizeof(ARMWord), to);
50491:         }
50491: 
50491:         // Address operations
50491: 
50491:         static void* getRelocatedAddress(void* code, JmpSrc jump)
50491:         {
50491:             return reinterpret_cast<void*>(reinterpret_cast<ARMWord*>(code) + jump.m_offset / sizeof(ARMWord) + 1);
50491:         }
50491: 
50491:         static void* getRelocatedAddress(void* code, JmpDst label)
50491:         {
50491:             return reinterpret_cast<void*>(reinterpret_cast<ARMWord*>(code) + label.m_offset / sizeof(ARMWord));
50491:         }
50491: 
50491:         // Address differences
50491: 
50491:         static int getDifferenceBetweenLabels(JmpDst from, JmpSrc to)
50491:         {
50491:             return (to.m_offset + sizeof(ARMWord)) - from.m_offset;
50491:         }
50491: 
50491:         static int getDifferenceBetweenLabels(JmpDst from, JmpDst to)
50491:         {
50491:             return to.m_offset - from.m_offset;
50491:         }
50491: 
50491:         static unsigned getCallReturnOffset(JmpSrc call)
50491:         {
50491:             return call.m_offset + sizeof(ARMWord);
50491:         }
50491: 
50491:         // Handle immediates
50491: 
50491:         static ARMWord getOp2Byte(ARMWord imm)
50491:         {
50491:             ASSERT(imm <= 0xff);
50491:             return OP2_IMMh | (imm & 0x0f) | ((imm & 0xf0) << 4) ;
50491:         }
50491: 
50491:         static ARMWord getOp2(ARMWord imm);
50491: 
50491: #if WTF_ARM_ARCH_VERSION >= 7
50491:         static ARMWord getImm16Op2(ARMWord imm)
50491:         {
50491:             if (imm <= 0xffff)
50491:                 return (imm & 0xf000) << 4 | (imm & 0xfff);
50491:             return INVALID_IMM;
50491:         }
50491: #endif
50491:         ARMWord getImm(ARMWord imm, int tmpReg, bool invert = false);
50491:         void moveImm(ARMWord imm, int dest);
50491:         ARMWord encodeComplexImm(ARMWord imm, int dest);
50491: 
50491:         ARMWord getOffsetForHalfwordDataTransfer(ARMWord imm, int tmpReg)
50491:         {
50491:             // Encode immediate data in the instruction if it is possible
50491:             if (imm <= 0xff)
50491:                 return getOp2Byte(imm);
50491:             // Otherwise, store the data in a temporary register
50491:             return encodeComplexImm(imm, tmpReg);
50491:         }
50491: 
50491:         // Memory load/store helpers
50491: 
50693:         void dataTransfer32(bool isLoad, RegisterID srcDst, RegisterID base, int32_t offset);
50693:         void dataTransfer8(bool isLoad, RegisterID srcDst, RegisterID base, int32_t offset);
50491:         void baseIndexTransfer32(bool isLoad, RegisterID srcDst, RegisterID base, RegisterID index, int scale, int32_t offset);
50491:         void doubleTransfer(bool isLoad, FPRegisterID srcDst, RegisterID base, int32_t offset);
50491: 
50491:         // Constant pool hnadlers
50491: 
50491:         static ARMWord placeConstantPoolBarrier(int offset)
50491:         {
50491:             offset = (offset - sizeof(ARMWord)) >> 2;
50491:             ASSERT((offset <= BOFFSET_MAX && offset >= BOFFSET_MIN));
50491:             return AL | B | (offset & BRANCH_MASK);
50491:         }
50491: 
50491:     private:
50491:         static char const * nameGpReg(int reg)
50491:         {
50491:             ASSERT(reg <= 16);
50491:             ASSERT(reg >= 0);
50491:             static char const * names[] = {
50491:                 "r0", "r1", "r2", "r3",
50491:                 "r4", "r5", "r6", "r7",
50491:                 "r8", "r9", "r10", "r11",
50491:                 "ip", "sp", "lr", "pc"
50491:             };
50491:             return names[reg];
50491:         }
50491: 
50491:         static char const * nameFpRegD(int reg)
50491:         {
50491:             ASSERT(reg <= 31);
50491:             ASSERT(reg >= 0);
50491:             static char const * names[] = {
50491:                  "d0",   "d1",   "d2",   "d3",
50491:                  "d4",   "d5",   "d6",   "d7",
50491:                  "d8",   "d9",  "d10",  "d11",
50491:                 "d12",  "d13",  "d14",  "d15",
50491:                 "d16",  "d17",  "d18",  "d19",
50491:                 "d20",  "d21",  "d22",  "d23",
50491:                 "d24",  "d25",  "d26",  "d27",
50491:                 "d28",  "d29",  "d30",  "d31"
50491:             };
50491:             return names[reg];
50491:         }
50491: 
50491:         static char const * nameCC(Condition cc)
50491:         {
50491:             ASSERT(cc <= AL);
50491:             ASSERT(cc >= 0);
50491:             ASSERT((cc & 0x0fffffff) == 0);
50491: 
50491:             uint32_t    ccIndex = cc >> 28;
50491:             static char const * names[] = {
50491:                 "eq", "ne",
50491:                 "cs", "cc",
50491:                 "mi", "pl",
50491:                 "vs", "vc",
50491:                 "hi", "ls",
50491:                 "ge", "lt",
50491:                 "gt", "le",
50491:                 "  "        // AL is the default, so don't show it.
50491:             };
50491:             return names[ccIndex];
50491:         }
50491: 
50491:         // Decodes operand 2 immediate values (for debug output and assertions).
50491:         inline uint32_t decOp2Imm(uint32_t op2)
50491:         {
50491:             ASSERT((op2 & ~0xfff) == 0);
50491: 
50491:             uint32_t    imm8 = op2 & 0xff;
53398:             uint32_t    rot = ((op2 >> 7) & 0x1e);
50491: 
53398:             // 'rot' is a right-rotate count.
53398: 
53398:             uint32_t    imm = (imm8 >> rot);
53398:             if (rot > 0) {
53398:                 imm |= (imm8 << (32-rot));
53398:             }
53398: 
53398:             return imm;
50491:         }
50491: 
50491:         // Format the operand 2 argument for debug spew. The operand can be
50491:         // either an immediate or a register specifier.
50491:         void fmtOp2(char * out, ARMWord op2)
50491:         {
50491:             static char const * const shifts[4] = {"LSL", "LSR", "ASR", "ROR"};
50491: 
50491:             if ((op2 & OP2_IMM) || (op2 & OP2_IMMh)) {
50491:                 // Immediate values.
50491:                 
50491:                 uint32_t    imm = decOp2Imm(op2 & ~(OP2_IMM | OP2_IMMh));
50491:                 sprintf(out, "#0x%x @ (%d)", imm, static_cast<int32_t>(imm));
50491:             } else {
50491:                 // Register values.
50491: 
50491:                 char const *    rm = nameGpReg(op2 & 0xf);
50491:                 Shift           type = static_cast<Shift>((op2 >> 5) & 0x3);
50491: 
50491:                 // Bit 4 specifies barrel-shifter parameters in operand 2.
50491:                 if (op2 & (1<<4)) {
50491:                     // Register-shifted register.
50491:                     // Example: "r0, LSL r6"
50491:                     char const *    rs = nameGpReg((op2 >> 8) & 0xf);
50491:                     sprintf(out, "%s, %s %s", rm, shifts[type], rs);
50491:                 } else {
50491:                     // Immediate-shifted register.
50491:                     // Example: "r0, ASR #31"
50491:                     uint32_t        imm = (op2 >> 7) & 0x1f;
50491:                     
50491:                     // Deal with special encodings.
50491:                     if ((type == LSL) && (imm == 0)) {
50491:                         // "LSL #0" doesn't shift at all (and is the default).
50491:                         sprintf(out, rm);
50491:                         return;
50491:                     }
50491: 
50491:                     if ((type == ROR) && (imm == 0)) {
50491:                         // "ROR #0" is a special case ("RRX").
50491:                         sprintf(out, "%s, RRX", rm);
50491:                         return;
50491:                     }
50491: 
50491:                     if (((type == LSR) || (type == ASR)) && (imm == 0)) {
50491:                         // Both LSR and ASR have a range of 1-32, with 32
50491:                         // encoded as 0.                  
50491:                         imm = 32;
50491:                     }
50491: 
50491:                     // Print the result.
50491: 
50491:                     sprintf(out, "%s, %s #%u", rm, shifts[type], imm);
50491:                 }
50491:             }
50491:         }
50491: 
50491:         void spewInsWithOp2(char const * ins, Condition cc, int rd, int rn, ARMWord op2)
50491:         {
50491:             char    mnemonic[16];
50491:             snprintf(mnemonic, 16, "%s%s", ins, nameCC(cc));
50491: 
50491:             char    op2_fmt[48];
50491:             fmtOp2(op2_fmt, op2);
50491: 
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s, %s\n", MAYBE_PAD, mnemonic, nameGpReg(rd), nameGpReg(rn), op2_fmt);
50491:         }
50491: 
50491:         void spewInsWithOp2(char const * ins, Condition cc, int r, ARMWord op2)
50491:         {
50491:             char    mnemonic[16];
50491:             snprintf(mnemonic, 16, "%s%s", ins, nameCC(cc));
50491: 
50491:             char    op2_fmt[48];
50491:             fmtOp2(op2_fmt, op2);
50491: 
50491:             js::JaegerSpew(js::JSpew_Insns,
50491:                     IPFX   "%-15s %s, %s\n", MAYBE_PAD, mnemonic, nameGpReg(r), op2_fmt);
50491:         }
50491: 
50491:         ARMWord RM(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             return reg;
50491:         }
50491: 
50491:         ARMWord RS(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             return reg << 8;
50491:         }
50491: 
50491:         ARMWord RD(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             return reg << 12;
50491:         }
50491: 
50491:         ARMWord RN(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::pc);
50491:             return reg << 16;
50491:         }
50491: 
50491:         ARMWord DD(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::d31);
50491:             // Endoded as bits [22,15:12].
50491:             return ((reg << 12) | (reg << 18)) & 0x0040f000;
50491:         }
50491: 
50491:         ARMWord DN(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::d31);
50491:             // Endoded as bits [7,19:16].
50491:             return ((reg << 16) | (reg << 3)) & 0x000f0080;
50491:         }
50491: 
50491:         ARMWord DM(int reg)
50491:         {
50491:             ASSERT(reg <= ARMRegisters::d31);
50491:             // Encoded as bits [5,3:0].
50491:             return ((reg << 1) & 0x20) | (reg & 0xf);
50491:         }
50491: 
50491:         static ARMWord getConditionalField(ARMWord i)
50491:         {
50491:             return i & 0xf0000000;
50491:         }
50491: 
50491:         int genInt(int reg, ARMWord imm, bool positive);
50491: 
50491:         ARMBuffer m_buffer;
50491:         Jumps m_jumps;
50491:     };
50491: 
50491: } // namespace JSC
50491: 
50491: #endif // ENABLE(ASSEMBLER) && CPU(ARM_TRADITIONAL)
50491: 
50491: #endif // ARMAssembler_h
