 99753: /* This Source Code Form is subject to the terms of the Mozilla Public
 99753:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99753:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 41549: 
 74689: "use strict";
 74689: 
 41549: const Cc = Components.classes;
 41549: const Ci = Components.interfaces;
 41549: const Cr = Components.results;
 41549: 
 63040: const PREF_BLOCKLIST_PINGCOUNTVERSION = "extensions.blocklist.pingCountVersion";
 41549: const PREF_EM_UPDATE_ENABLED          = "extensions.update.enabled";
 51288: const PREF_EM_LAST_APP_VERSION        = "extensions.lastAppVersion";
 70084: const PREF_EM_LAST_PLATFORM_VERSION   = "extensions.lastPlatformVersion";
 53775: const PREF_EM_AUTOUPDATE_DEFAULT      = "extensions.update.autoUpdateDefault";
 81115: const PREF_EM_STRICT_COMPATIBILITY    = "extensions.strictCompatibility";
 90139: const PREF_EM_CHECK_UPDATE_SECURITY   = "extensions.checkUpdateSecurity";
 91772: const PREF_EM_UPDATE_BACKGROUND_URL   = "extensions.update.background.url";
 84794: const PREF_APP_UPDATE_ENABLED         = "app.update.enabled";
 84794: const PREF_APP_UPDATE_AUTO            = "app.update.auto";
 84794: const PREF_EM_HOTFIX_ID               = "extensions.hotfix.id";
 84794: const PREF_EM_HOTFIX_LASTVERSION      = "extensions.hotfix.lastVersion";
 84794: const PREF_EM_HOTFIX_URL              = "extensions.hotfix.url";
 84796: const PREF_EM_CERT_CHECKATTRIBUTES    = "extensions.hotfix.cert.checkAttributes";
 84796: const PREF_EM_HOTFIX_CERTS            = "extensions.hotfix.certs.";
 84794: const PREF_MATCH_OS_LOCALE            = "intl.locale.matchOS";
 84794: const PREF_SELECTED_LOCALE            = "general.useragent.locale";
 84794: 
 84794: const UPDATE_REQUEST_VERSION          = 2;
 84794: const CATEGORY_UPDATE_PARAMS          = "extension-update-params";
 81115: 
 90139: const BRANCH_REGEXP                   = /^([^\.]+\.[0-9]+[a-z]*).*/gi;
 90139: const PREF_EM_CHECK_COMPATIBILITY_BASE = "extensions.checkCompatibility";
 90139: #ifdef MOZ_COMPATIBILITY_NIGHTLY
 90139: var PREF_EM_CHECK_COMPATIBILITY = PREF_EM_CHECK_COMPATIBILITY_BASE + ".nightly";
 90139: #else
 90139: var PREF_EM_CHECK_COMPATIBILITY;
 90139: #endif
 41549: 
 83133: const TOOLKIT_ID                      = "toolkit@mozilla.org";
 83133: 
 70152: const VALID_TYPES_REGEXP = /^[\w\-]+$/;
 70152: 
 41549: Components.utils.import("resource://gre/modules/Services.jsm");
 98217: Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
 98217: 
 98217: XPCOMUtils.defineLazyGetter(this, "CertUtils", function() {
 98217:   let certUtils = {};
 98217:   Components.utils.import("resource://gre/modules/CertUtils.jsm", certUtils);
 98217:   return certUtils;
 98217: });
 98217: 
 41549: 
 41549: var EXPORTED_SYMBOLS = [ "AddonManager", "AddonManagerPrivate" ];
 41549: 
 47339: const CATEGORY_PROVIDER_MODULE = "addon-provider-module";
 47339: 
 41549: // A list of providers to load by default
 47339: const DEFAULT_PROVIDERS = [
 41549:   "resource://gre/modules/XPIProvider.jsm",
 41549:   "resource://gre/modules/LightweightThemeManager.jsm"
 41549: ];
 41549: 
 41596: ["LOG", "WARN", "ERROR"].forEach(function(aName) {
 41596:   this.__defineGetter__(aName, function() {
 41596:     Components.utils.import("resource://gre/modules/AddonLogging.jsm");
 41549: 
 41596:     LogManager.getLogger("addons.manager", this);
 41596:     return this[aName];
 41596:   });
 41596: }, this);
 41549: 
 41549: /**
 41549:  * Calls a callback method consuming any thrown exception. Any parameters after
 41549:  * the callback parameter will be passed to the callback.
 41549:  *
 41584:  * @param  aCallback
 41549:  *         The callback method to call
 41549:  */
102413: function safeCall(aCallback, ...aArgs) {
 41549:   try {
102413:     aCallback.apply(null, aArgs);
 41549:   }
 41549:   catch (e) {
 57401:     WARN("Exception calling callback", e);
 41549:   }
 41549: }
 41549: 
 41549: /**
 41549:  * Calls a method on a provider if it exists and consumes any thrown exception.
 41549:  * Any parameters after the dflt parameter are passed to the provider's method.
 41549:  *
 41584:  * @param  aProvider
 41549:  *         The provider to call
 41584:  * @param  aMethod
 41549:  *         The method name to call
 41584:  * @param  aDefault
 41549:  *         A default return value if the provider does not implement the named
 41549:  *         method or throws an error.
 41549:  * @return the return value from the provider or dflt if the provider does not
 41549:  *         implement method or throws an error
 41549:  */
102413: function callProvider(aProvider, aMethod, aDefault, ...aArgs) {
 41584:   if (!(aMethod in aProvider))
 41584:     return aDefault;
 41549: 
 41549:   try {
102413:     return aProvider[aMethod].apply(aProvider, aArgs);
 57401:   }
 57401:   catch (e) {
 57401:     ERROR("Exception calling provider " + aMethod, e);
 41584:     return aDefault;
 41549:   }
 41549: }
 41549: 
 41549: /**
 84794:  * Gets the currently selected locale for display.
 84794:  * @return  the selected locale or "en-US" if none is selected
 84794:  */
 84794: function getLocale() {
 84794:   try {
 84794:     if (Services.prefs.getBoolPref(PREF_MATCH_OS_LOCALE))
 84794:       return Services.locale.getLocaleComponentForUserAgent();
 84794:   }
 84794:   catch (e) { }
 84794: 
 84794:   try {
 84794:     let locale = Services.prefs.getComplexValue(PREF_SELECTED_LOCALE,
 84794:                                                 Ci.nsIPrefLocalizedString);
 84794:     if (locale)
 84794:       return locale;
 84794:   }
 84794:   catch (e) { }
 84794: 
 84794:   try {
 84794:     return Services.prefs.getCharPref(PREF_SELECTED_LOCALE);
 84794:   }
 84794:   catch (e) { }
 84794: 
 84794:   return "en-US";
 84794: }
 84794: 
 84794: /**
 41549:  * A helper class to repeatedly call a listener with each object in an array
 41549:  * optionally checking whether the object has a method in it.
 41549:  *
 41584:  * @param  aObjects
 41549:  *         The array of objects to iterate through
 41584:  * @param  aMethod
 41549:  *         An optional method name, if not null any objects without this method
 41549:  *         will not be passed to the listener
 41584:  * @param  aListener
 41549:  *         A listener implementing nextObject and noMoreObjects methods. The
 41549:  *         former will be called with the AsyncObjectCaller as the first
 41549:  *         parameter and the object as the second. noMoreObjects will be passed
 41549:  *         just the AsyncObjectCaller
 41549:  */
 41584: function AsyncObjectCaller(aObjects, aMethod, aListener) {
 41584:   this.objects = aObjects.slice(0);
 41584:   this.method = aMethod;
 41584:   this.listener = aListener;
 41549: 
 41549:   this.callNext();
 41549: }
 41549: 
 41549: AsyncObjectCaller.prototype = {
 41549:   objects: null,
 41549:   method: null,
 41549:   listener: null,
 41549: 
 41549:   /**
 41549:    * Passes the next object to the listener or calls noMoreObjects if there
 41549:    * are none left.
 41549:    */
 41549:   callNext: function AOC_callNext() {
 41549:     if (this.objects.length == 0) {
 41549:       this.listener.noMoreObjects(this);
 41549:       return;
 41549:     }
 41549: 
 41549:     let object = this.objects.shift();
 41549:     if (!this.method || this.method in object)
 41549:       this.listener.nextObject(this, object);
 41549:     else
 41549:       this.callNext();
 41549:   }
 41549: };
 41549: 
 41549: /**
 51520:  * This represents an author of an add-on (e.g. creator or developer)
 51520:  *
 51520:  * @param  aName
 51520:  *         The name of the author
 51520:  * @param  aURL
 51520:  *         The URL of the author's profile page
 51520:  */
 51520: function AddonAuthor(aName, aURL) {
 51520:   this.name = aName;
 51520:   this.url = aURL;
 51520: }
 51520: 
 51520: AddonAuthor.prototype = {
 51520:   name: null,
 51520:   url: null,
 51520: 
 51520:   // Returns the author's name, defaulting to the empty string
 51520:   toString: function() {
 51520:     return this.name || "";
 51520:   }
 51520: }
 51520: 
 51520: /**
 51520:  * This represents an screenshot for an add-on
 51520:  *
 51520:  * @param  aURL
 51520:  *         The URL to the full version of the screenshot
 77865:  * @param  aWidth
 77865:  *         The width in pixels of the screenshot
 77865:  * @param  aHeight
 77865:  *         The height in pixels of the screenshot
 51520:  * @param  aThumbnailURL
 51520:  *         The URL to the thumbnail version of the screenshot
 77865:  * @param  aThumbnailWidth
 77865:  *         The width in pixels of the thumbnail version of the screenshot
 77865:  * @param  aThumbnailHeight
 77865:  *         The height in pixels of the thumbnail version of the screenshot
 51520:  * @param  aCaption
 51520:  *         The caption of the screenshot
 51520:  */
 77865: function AddonScreenshot(aURL, aWidth, aHeight, aThumbnailURL,
 77865:                          aThumbnailWidth, aThumbnailHeight, aCaption) {
 51520:   this.url = aURL;
 77865:   if (aWidth) this.width = aWidth;
 77865:   if (aHeight) this.height = aHeight;
 77865:   if (aThumbnailURL) this.thumbnailURL = aThumbnailURL;
 77865:   if (aThumbnailWidth) this.thumbnailWidth = aThumbnailWidth;
 77865:   if (aThumbnailHeight) this.thumbnailHeight = aThumbnailHeight;
 77865:   if (aCaption) this.caption = aCaption;
 51520: }
 51520: 
 51520: AddonScreenshot.prototype = {
 51520:   url: null,
 77865:   width: null,
 77865:   height: null,
 51520:   thumbnailURL: null,
 77865:   thumbnailWidth: null,
 77865:   thumbnailHeight: null,
 51520:   caption: null,
 51520: 
 51520:   // Returns the screenshot URL, defaulting to the empty string
 51520:   toString: function() {
 51520:     return this.url || "";
 51520:   }
 51520: }
 51520: 
 83133: 
 83133: /**
 83133:  * This represents a compatibility override for an addon.
 83133:  *
 83133:  * @param  aType
 83133:  *         Overrride type - "compatible" or "incompatible"
 83133:  * @param  aMinVersion
 83133:  *         Minimum version of the addon to match
 83133:  * @param  aMaxVersion
 83133:  *         Maximum version of the addon to match
 83133:  * @param  aAppID
 83133:  *         Application ID used to match appMinVersion and appMaxVersion
 83133:  * @param  aAppMinVersion
 83133:  *         Minimum version of the application to match
 83133:  * @param  aAppMaxVersion
 83133:  *         Maximum version of the application to match
 83133:  */
 83133: function AddonCompatibilityOverride(aType, aMinVersion, aMaxVersion, aAppID,
 83133:                                     aAppMinVersion, aAppMaxVersion) {
 83133:   this.type = aType;
 83133:   this.minVersion = aMinVersion;
 83133:   this.maxVersion = aMaxVersion;
 83133:   this.appID = aAppID;
 83133:   this.appMinVersion = aAppMinVersion;
 83133:   this.appMaxVersion = aAppMaxVersion;
 83133: }
 83133: 
 83133: AddonCompatibilityOverride.prototype = {
 83133:   /**
 83133:    * Type of override - "incompatible" or "compatible".
 83133:    * Only "incompatible" is supported for now.
 83133:    */
 83133:   type: null,
 83133: 
 83133:   /**
 83133:    * Min version of the addon to match.
 83133:    */
 83133:   minVersion: null,
 83133: 
 83133:   /**
 83133:    * Max version of the addon to match.
 83133:    */
 83133:   maxVersion: null,
 83133: 
 83133:   /**
 83133:    * Application ID to match.
 83133:    */
 83133:   appID: null,
 83133: 
 83133:   /**
 83133:    * Min version of the application to match.
 83133:    */
 83133:   appMinVersion: null,
 83133: 
 83133:   /**
 83133:    * Max version of the application to match.
 83133:    */
 83133:   appMaxVersion: null
 83133: };
 83133: 
 83133: 
 70152: /**
 70152:  * A type of add-on, used by the UI to determine how to display different types
 70152:  * of add-ons.
 70152:  *
 99760:  * @param  aID
 70152:  *         The add-on type ID
 70152:  * @param  aLocaleURI
 70152:  *         The URI of a localized properties file to get the displayable name
 70152:  *         for the type from
 70152:  * @param  aLocaleKey
 70152:  *         The key for the string in the properties file or the actual display
 70152:  *         name if aLocaleURI is null. Include %ID% to include the type ID in
 70152:  *         the key
 70152:  * @param  aViewType
 70152:  *         The optional type of view to use in the UI
 70152:  * @param  aUIPriority
 70152:  *         The priority is used by the UI to list the types in order. Lower
 70152:  *         values push the type higher in the list.
 70152:  * @param  aFlags
 70152:  *         An option set of flags that customize the display of the add-on in
 70152:  *         the UI.
 70152:  */
 99760: function AddonType(aID, aLocaleURI, aLocaleKey, aViewType, aUIPriority, aFlags) {
 99760:   if (!aID)
106954:     throw Components.Exception("An AddonType must have an ID", Cr.NS_ERROR_INVALID_ARG);
106954: 
 70152:   if (aViewType && aUIPriority === undefined)
106954:     throw Components.Exception("An AddonType with a defined view must have a set UI priority",
106954:                                Cr.NS_ERROR_INVALID_ARG);
106954: 
 70152:   if (!aLocaleKey)
106954:     throw Components.Exception("An AddonType must have a displayable name",
106954:                                Cr.NS_ERROR_INVALID_ARG);
 70152: 
 99760:   this.id = aID;
 70152:   this.uiPriority = aUIPriority;
 70152:   this.viewType = aViewType;
 70152:   this.flags = aFlags;
 70152: 
 70152:   if (aLocaleURI) {
 70152:     this.__defineGetter__("name", function() {
 70152:       delete this.name;
 70152:       let bundle = Services.strings.createBundle(aLocaleURI);
 99760:       this.name = bundle.GetStringFromName(aLocaleKey.replace("%ID%", aID));
 70152:       return this.name;
 70152:     });
 70152:   }
 70152:   else {
 70152:     this.name = aLocaleKey;
 70152:   }
 70152: }
 70152: 
 55435: var gStarted = false;
108520: var gStartupComplete = false;
 90139: var gCheckCompatibility = true;
 90139: var gStrictCompatibility = true;
 90139: var gCheckUpdateSecurityDefault = true;
 90139: var gCheckUpdateSecurity = gCheckUpdateSecurityDefault;
 90139: var gUpdateEnabled = true;
 90139: var gAutoUpdateDefault = true;
 98684: var gHotfixID = null;
 55435: 
 51520: /**
 41549:  * This is the real manager, kept here rather than in AddonManager to keep its
 41549:  * contents hidden from API users.
 41549:  */
 41549: var AddonManagerInternal = {
 90139:   managerListeners: [],
 55435:   installListeners: [],
 55435:   addonListeners: [],
 70152:   typeListeners: [],
 41549:   providers: [],
 70152:   types: {},
 72782:   startupChanges: {},
 70152: 
 70152:   // A read-only wrapper around the types dictionary
 70152:   typesProxy: Proxy.create({
 70152:     getOwnPropertyDescriptor: function(aName) {
 70152:       if (!(aName in AddonManagerInternal.types))
 70152:         return undefined;
 70152: 
 70152:       return {
 70152:         value: AddonManagerInternal.types[aName].type,
 70152:         writable: false,
 70152:         configurable: false,
 70152:         enumerable: true
 70152:       }
 70152:     },
 70152: 
 70152:     getPropertyDescriptor: function(aName) {
 70152:       return this.getOwnPropertyDescriptor(aName);
 70152:     },
 70152: 
 70152:     getOwnPropertyNames: function() {
 70152:       return Object.keys(AddonManagerInternal.types);
 70152:     },
 70152: 
 70152:     getPropertyNames: function() {
 70152:       return this.getOwnPropertyNames();
 70152:     },
 70152: 
 70152:     delete: function(aName) {
 70152:       // Not allowed to delete properties
 70152:       return false;
 70152:     },
 70152: 
 70152:     defineProperty: function(aName, aProperty) {
 70152:       // Ignore attempts to define properties
 70152:     },
 70152: 
 70152:     fix: function() {
 70152:       return undefined;
 70152:     },
 70152: 
 70152:     // Despite MDC's claims to the contrary, it is required that this trap
 70152:     // be defined
 70152:     enumerate: function() {
 70152:       // All properties are enumerable
 70152:       return this.getPropertyNames();
 70152:     }
 70152:   }),
 41549: 
 41549:   /**
 41549:    * Initializes the AddonManager, loading any known providers and initializing
 41549:    * them.
 41549:    */
 41549:   startup: function AMI_startup() {
 55435:     if (gStarted)
 41549:       return;
 41549: 
108520:     Services.obs.addObserver(this, "xpcom-shutdown", false);
108520: 
 51300:     let appChanged = undefined;
 41549: 
 70084:     let oldAppVersion = null;
 41549:     try {
 70084:       oldAppVersion = Services.prefs.getCharPref(PREF_EM_LAST_APP_VERSION);
 70084:       appChanged = Services.appinfo.version != oldAppVersion;
 70084:     }
 70084:     catch (e) { }
 70084: 
 70084:     let oldPlatformVersion = null;
 70084:     try {
 70084:       oldPlatformVersion = Services.prefs.getCharPref(PREF_EM_LAST_PLATFORM_VERSION);
 41549:     }
 41549:     catch (e) { }
 41549: 
 51300:     if (appChanged !== false) {
 41549:       LOG("Application has been upgraded");
 51288:       Services.prefs.setCharPref(PREF_EM_LAST_APP_VERSION,
 41549:                                  Services.appinfo.version);
 70084:       Services.prefs.setCharPref(PREF_EM_LAST_PLATFORM_VERSION,
 70084:                                  Services.appinfo.platformVersion);
 63040:       Services.prefs.setIntPref(PREF_BLOCKLIST_PINGCOUNTVERSION,
 60611:                                 (appChanged === undefined ? 0 : -1));
 41549:     }
 41549: 
 90139: #ifndef MOZ_COMPATIBILITY_NIGHTLY
 90139:     PREF_EM_CHECK_COMPATIBILITY = PREF_EM_CHECK_COMPATIBILITY_BASE + "." +
 90139:                                   Services.appinfo.version.replace(BRANCH_REGEXP, "$1");
 90139: #endif
 90139: 
 90139:     try {
 90139:       gCheckCompatibility = Services.prefs.getBoolPref(PREF_EM_CHECK_COMPATIBILITY);
 90139:     } catch (e) {}
 90139:     Services.prefs.addObserver(PREF_EM_CHECK_COMPATIBILITY, this, false);
 90139: 
 81115:     try {
 81115:       gStrictCompatibility = Services.prefs.getBoolPref(PREF_EM_STRICT_COMPATIBILITY);
 81115:     } catch (e) {}
 81115:     Services.prefs.addObserver(PREF_EM_STRICT_COMPATIBILITY, this, false);
 81115: 
 90139:     try {
 90139:       let defaultBranch = Services.prefs.getDefaultBranch("");
 90139:       gCheckUpdateSecurityDefault = defaultBranch.getBoolPref(PREF_EM_CHECK_UPDATE_SECURITY);
 90139:     } catch(e) {}
 90139: 
 90139:     try {
 90139:       gCheckUpdateSecurity = Services.prefs.getBoolPref(PREF_EM_CHECK_UPDATE_SECURITY);
 90139:     } catch (e) {}
 90139:     Services.prefs.addObserver(PREF_EM_CHECK_UPDATE_SECURITY, this, false);
 90139: 
 90139:     try {
 90139:       gUpdateEnabled = Services.prefs.getBoolPref(PREF_EM_UPDATE_ENABLED);
 90139:     } catch (e) {}
 90139:     Services.prefs.addObserver(PREF_EM_UPDATE_ENABLED, this, false);
 90139: 
 90139:     try {
 90139:       gAutoUpdateDefault = Services.prefs.getBoolPref(PREF_EM_AUTOUPDATE_DEFAULT);
 90139:     } catch (e) {}
 90139:     Services.prefs.addObserver(PREF_EM_AUTOUPDATE_DEFAULT, this, false);
 90139: 
 98684:     try {
 98684:       gHotfixID = Services.prefs.getCharPref(PREF_EM_HOTFIX_ID);
 98684:     } catch (e) {}
 98684:     Services.prefs.addObserver(PREF_EM_HOTFIX_ID, this, false);
 98684: 
 41549:     // Ensure all default providers have had a chance to register themselves
 47339:     DEFAULT_PROVIDERS.forEach(function(url) {
 41557:       try {
 41549:         Components.utils.import(url, {});
 41557:       }
 41557:       catch (e) {
 57401:         ERROR("Exception loading default provider \"" + url + "\"", e);
 41557:       }
 41549:     });
 41549: 
 47339:     // Load any providers registered in the category manager
 47339:     let catman = Cc["@mozilla.org/categorymanager;1"].
 47339:                  getService(Ci.nsICategoryManager);
 47339:     let entries = catman.enumerateCategory(CATEGORY_PROVIDER_MODULE);
 47339:     while (entries.hasMoreElements()) {
 47339:       let entry = entries.getNext().QueryInterface(Ci.nsISupportsCString).data;
 47339:       let url = catman.getCategoryEntry(CATEGORY_PROVIDER_MODULE, entry);
 47339: 
 47339:       try {
 47339:         Components.utils.import(url, {});
 47339:       }
 47339:       catch (e) {
 47339:         ERROR("Exception loading provider " + entry + " from category \"" +
 57401:               url + "\"", e);
 47339:       }
 47339:     }
 47339: 
108520:     // Once we start calling providers we must allow all normal methods to work.
108520:     gStarted = true;
108520: 
 99895:     this.callProviders("startup", appChanged, oldAppVersion,
 70084:                        oldPlatformVersion);
 72782: 
 72782:     // If this is a new profile just pretend that there were no changes
 72782:     if (appChanged === undefined) {
 72782:       for (let type in this.startupChanges)
 72782:         delete this.startupChanges[type];
 72782:     }
 72782: 
108520:     gStartupComplete = true;
 41549:   },
 41549: 
 41549:   /**
 41549:    * Registers a new AddonProvider.
 41549:    *
 41584:    * @param  aProvider
 41549:    *         The provider to register
 70152:    * @param  aTypes
 99760:    *         An optional array of add-on types
 41549:    */
 70152:   registerProvider: function AMI_registerProvider(aProvider, aTypes) {
 99760:     if (!aProvider || typeof aProvider != "object")
 99760:       throw Components.Exception("aProvider must be specified",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aTypes && !Array.isArray(aTypes))
 99760:       throw Components.Exception("aTypes must be an array or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 41584:     this.providers.push(aProvider);
 41549: 
 70152:     if (aTypes) {
 70152:       aTypes.forEach(function(aType) {
 70152:         if (!(aType.id in this.types)) {
 70152:           if (!VALID_TYPES_REGEXP.test(aType.id)) {
 70152:             WARN("Ignoring invalid type " + aType.id);
 70152:             return;
 70152:           }
 70152: 
 70152:           this.types[aType.id] = {
 70152:             type: aType,
 70152:             providers: [aProvider]
 70152:           };
 70152: 
 99895:           let typeListeners = this.typeListeners.slice(0);
 99895:           for (let listener of typeListeners) {
 70152:             safeCall(function() {
 99895:               listener.onTypeAdded(aType);
 70152:             });
 99895:           }
 70152:         }
 70152:         else {
 70152:           this.types[aType.id].providers.push(aProvider);
 70152:         }
 70152:       }, this);
 70152:     }
 70152: 
 41549:     // If we're registering after startup call this provider's startup.
 55435:     if (gStarted)
 41584:       callProvider(aProvider, "startup");
 41549:   },
 41549: 
 41549:   /**
 43745:    * Unregisters an AddonProvider.
 43745:    *
 43745:    * @param  aProvider
 43745:    *         The provider to unregister
 43745:    */
 43745:   unregisterProvider: function AMI_unregisterProvider(aProvider) {
 99760:     if (!aProvider || typeof aProvider != "object")
 99760:       throw Components.Exception("aProvider must be specified",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 55435:     let pos = 0;
 55435:     while (pos < this.providers.length) {
 55435:       if (this.providers[pos] == aProvider)
 55435:         this.providers.splice(pos, 1);
 55435:       else
 55435:         pos++;
 55435:     }
 43745: 
 70152:     for (let type in this.types) {
 70152:       this.types[type].providers = this.types[type].providers.filter(function(p) p != aProvider);
 70152:       if (this.types[type].providers.length == 0) {
 70152:         let oldType = this.types[type].type;
 70152:         delete this.types[type];
 70152: 
 99895:         let typeListeners = this.typeListeners.slice(0);
 99895:         for (let listener of typeListeners) {
 70152:           safeCall(function() {
 99895:             listener.onTypeRemoved(oldType);
 70152:           });
 99895:         }
 70152:       }
 70152:     }
 70152: 
 43745:     // If we're unregistering after startup call this provider's shutdown.
 55435:     if (gStarted)
 43745:       callProvider(aProvider, "shutdown");
 43745:   },
 43745: 
 43745:   /**
 99895:    * Calls a method on all registered providers if it exists and consumes any
 99895:    * thrown exception. Return values are ignored. Any parameters after the
 99895:    * method parameter are passed to the provider's method.
 99895:    *
 99895:    * @param  aMethod
 99895:    *         The method name to call
 99895:    * @see    callProvider
 99895:    */
 99895:   callProviders: function AMI_callProviders(aMethod, ...aArgs) {
 99895:     if (!aMethod || typeof aMethod != "string")
 99895:       throw Components.Exception("aMethod must be a non-empty string",
 99895:                                  Cr.NS_ERROR_INVALID_ARG);
 99895: 
 99895:     let providers = this.providers.slice(0);
 99895:     for (let provider of providers) {
 99895:       try {
 99895:         if (aMethod in provider)
 99895:           provider[aMethod].apply(provider, aArgs);
 99895:       }
 99895:       catch (e) {
 99895:         ERROR("Exception calling provider " + aMethod, e);
 99895:       }
 99895:     }
 99895:   },
 99895: 
 99895:   /**
 41549:    * Shuts down the addon manager and all registered providers, this must clean
 41549:    * up everything in order for automated tests to fake restarts.
 41549:    */
 72782:   shutdown: function AMI_shutdown() {
108520:     LOG("shutdown");
108520:     Services.obs.removeObserver(this, "xpcom-shutdown");
 90139:     Services.prefs.removeObserver(PREF_EM_CHECK_COMPATIBILITY, this);
 81115:     Services.prefs.removeObserver(PREF_EM_STRICT_COMPATIBILITY, this);
 90139:     Services.prefs.removeObserver(PREF_EM_CHECK_UPDATE_SECURITY, this);
 90139:     Services.prefs.removeObserver(PREF_EM_UPDATE_ENABLED, this);
 90139:     Services.prefs.removeObserver(PREF_EM_AUTOUPDATE_DEFAULT, this);
 98684:     Services.prefs.removeObserver(PREF_EM_HOTFIX_ID, this);
 81115: 
108520:     // Always clean up listeners, but only shutdown providers if they've been 
108520:     // started.
108520:     if (gStarted)
 99895:       this.callProviders("shutdown");
 41549: 
 90139:     this.managerListeners.splice(0, this.managerListeners.length);
 78670:     this.installListeners.splice(0, this.installListeners.length);
 78670:     this.addonListeners.splice(0, this.addonListeners.length);
 78670:     this.typeListeners.splice(0, this.typeListeners.length);
 72782:     for (let type in this.startupChanges)
 72782:       delete this.startupChanges[type];
 55435:     gStarted = false;
108520:     gStartupComplete = false;
 41549:   },
 41549: 
 41549:   /**
 81115:    * Notified when a preference we're interested in has changed.
 81115:    *
 81115:    * @see nsIObserver
 81115:    */
 81115:   observe: function AMI_observe(aSubject, aTopic, aData) {
108520:     if (aTopic == "xpcom-shutdown") {
108520:       this.shutdown();
108520:       return;
108520:     }
108520: 
 81115:     switch (aData) {
 90139:       case PREF_EM_CHECK_COMPATIBILITY: {
 90139:         let oldValue = gCheckCompatibility;
 90139:         try {
 90139:           gCheckCompatibility = Services.prefs.getBoolPref(PREF_EM_CHECK_COMPATIBILITY);
 90139:         } catch(e) {
 90139:           gCheckCompatibility = true;
 90139:         }
 90139: 
 90139:         this.callManagerListeners("onCompatibilityModeChanged");
 90139: 
 90139:         if (gCheckCompatibility != oldValue)
 90139:           this.updateAddonAppDisabledStates();
 90139: 
 90139:         break;
 90139:       }
 90139:       case PREF_EM_STRICT_COMPATIBILITY: {
 81115:         let oldValue = gStrictCompatibility;
 81115:         try {
 81115:           gStrictCompatibility = Services.prefs.getBoolPref(PREF_EM_STRICT_COMPATIBILITY);
 81115:         } catch(e) {
 90139:           gStrictCompatibility = true;
 81115:         }
 81115: 
 90139:         this.callManagerListeners("onCompatibilityModeChanged");
 90139: 
 81115:         if (gStrictCompatibility != oldValue)
 81115:           this.updateAddonAppDisabledStates();
 81115: 
 81115:         break;
 81115:       }
 90139:       case PREF_EM_CHECK_UPDATE_SECURITY: {
 90139:         let oldValue = gCheckUpdateSecurity;
 90139:         try {
 90139:           gCheckUpdateSecurity = Services.prefs.getBoolPref(PREF_EM_CHECK_UPDATE_SECURITY);
 90139:         } catch(e) {
 90139:           gCheckUpdateSecurity = true;
 90139:         }
 90139: 
 90139:         this.callManagerListeners("onCheckUpdateSecurityChanged");
 90139: 
 90139:         if (gCheckUpdateSecurity != oldValue)
 90139:           this.updateAddonAppDisabledStates();
 90139: 
 90139:         break;
 90139:       }
 90139:       case PREF_EM_UPDATE_ENABLED: {
 90139:         let oldValue = gUpdateEnabled;
 90139:         try {
 90139:           gUpdateEnabled = Services.prefs.getBoolPref(PREF_EM_UPDATE_ENABLED);
 90139:         } catch(e) {
 90139:           gUpdateEnabled = true;
 90139:         }
 90139: 
 90139:         this.callManagerListeners("onUpdateModeChanged");
 90139:         break;
 90139:       }
 90139:       case PREF_EM_AUTOUPDATE_DEFAULT: {
 90139:         let oldValue = gAutoUpdateDefault;
 90139:         try {
 90139:           gAutoUpdateDefault = Services.prefs.getBoolPref(PREF_EM_AUTOUPDATE_DEFAULT);
 90139:         } catch(e) {
 90139:           gAutoUpdateDefault = true;
 90139:         }
 90139: 
 90139:         this.callManagerListeners("onUpdateModeChanged");
 90139:         break;
 90139:       }
 98684:       case PREF_EM_HOTFIX_ID: {
 98684:         try {
 98684:           gHotfixID = Services.prefs.getCharPref(PREF_EM_HOTFIX_ID);
 98684:         } catch(e) {
 98684:           gHotfixID = null;
 98684:         }
 98684:         break;
 98684:       }
 90139:     }
 81115:   },
 81115: 
 81115:   /**
 84794:    * Replaces %...% strings in an addon url (update and updateInfo) with
 84794:    * appropriate values.
 84794:    *
 84794:    * @param  aAddon
 99760:    *         The Addon representing the add-on
 84794:    * @param  aUri
 99760:    *         The string representation of the URI to escape
 84794:    * @param  aAppVersion
 84794:    *         The optional application version to use for %APP_VERSION%
 99760:    * @return The appropriately escaped URI.
 84794:    */
 84794:   escapeAddonURI: function AMI_escapeAddonURI(aAddon, aUri, aAppVersion)
 84794:   {
 99760:     if (!aAddon || typeof aAddon != "object")
 99760:       throw Components.Exception("aAddon must be an Addon object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (!aUri || typeof aUri != "string")
 99760:       throw Components.Exception("aUri must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aAppVersion && typeof aAppVersion != "string")
 99760:       throw Components.Exception("aAppVersion must be a string or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 84794:     var addonStatus = aAddon.userDisabled || aAddon.softDisabled ? "userDisabled"
 84794:                                                                  : "userEnabled";
 84794: 
 84794:     if (!aAddon.isCompatible)
 84794:       addonStatus += ",incompatible";
 84794:     if (aAddon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED)
 84794:       addonStatus += ",blocklisted";
 84794:     if (aAddon.blocklistState == Ci.nsIBlocklistService.STATE_SOFTBLOCKED)
 84794:       addonStatus += ",softblocked";
 84794: 
 84794:     try {
 84794:       var xpcomABI = Services.appinfo.XPCOMABI;
 84794:     } catch (ex) {
 84794:       xpcomABI = UNKNOWN_XPCOM_ABI;
 84794:     }
 84794: 
 84794:     let uri = aUri.replace(/%ITEM_ID%/g, aAddon.id);
 84794:     uri = uri.replace(/%ITEM_VERSION%/g, aAddon.version);
 84794:     uri = uri.replace(/%ITEM_STATUS%/g, addonStatus);
 84794:     uri = uri.replace(/%APP_ID%/g, Services.appinfo.ID);
 84794:     uri = uri.replace(/%APP_VERSION%/g, aAppVersion ? aAppVersion :
 84794:                                                       Services.appinfo.version);
 84794:     uri = uri.replace(/%REQ_VERSION%/g, UPDATE_REQUEST_VERSION);
 84794:     uri = uri.replace(/%APP_OS%/g, Services.appinfo.OS);
 84794:     uri = uri.replace(/%APP_ABI%/g, xpcomABI);
 84794:     uri = uri.replace(/%APP_LOCALE%/g, getLocale());
 84794:     uri = uri.replace(/%CURRENT_APP_VERSION%/g, Services.appinfo.version);
 84794: 
 84794:     // Replace custom parameters (names of custom parameters must have at
 84794:     // least 3 characters to prevent lookups for something like %D0%C8)
 84794:     var catMan = null;
 84794:     uri = uri.replace(/%(\w{3,})%/g, function(aMatch, aParam) {
 84794:       if (!catMan) {
 84794:         catMan = Cc["@mozilla.org/categorymanager;1"].
 84794:                  getService(Ci.nsICategoryManager);
 84794:       }
 84794: 
 84794:       try {
 84794:         var contractID = catMan.getCategoryEntry(CATEGORY_UPDATE_PARAMS, aParam);
 84794:         var paramHandler = Cc[contractID].getService(Ci.nsIPropertyBag2);
 84794:         return paramHandler.getPropertyAsAString(aParam);
 84794:       }
 84794:       catch(e) {
 84794:         return aMatch;
 84794:       }
 84794:     });
 84794: 
 84794:     // escape() does not properly encode + symbols in any embedded FVF strings.
 84794:     return uri.replace(/\+/g, "%2B");
 84794:   },
 84794: 
 84794:   /**
 41549:    * Performs a background update check by starting an update for all add-ons
 41549:    * that can be updated.
 41549:    */
 41549:   backgroundUpdateCheck: function AMI_backgroundUpdateCheck() {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 98684:     let hotfixID = this.hotfixID;
 84794: 
 84794:     let checkHotfix = hotfixID &&
 84794:                       Services.prefs.getBoolPref(PREF_APP_UPDATE_ENABLED) &&
 84794:                       Services.prefs.getBoolPref(PREF_APP_UPDATE_AUTO);
 84794: 
 90139:     if (!this.updateEnabled && !checkHotfix)
 41549:       return;
 41549: 
 51520:     Services.obs.notifyObservers(null, "addons-background-update-start", null);
 84794: 
 84794:     // Start this from one to ensure the whole of this function completes before
 84794:     // we can send the complete notification. Some parts can in some cases
 84794:     // complete synchronously before later parts have a chance to increment
 84794:     // pendingUpdates.
 84794:     let pendingUpdates = 1;
 51520: 
 51520:     function notifyComplete() {
 83133:       if (--pendingUpdates == 0) {
 83133:         Services.obs.notifyObservers(null,
 83133:                                      "addons-background-update-complete",
 83133:                                      null);
 83133:       }
 51520:     }
 51520: 
 90139:     if (this.updateEnabled) {
 41571:       let scope = {};
 51520:       Components.utils.import("resource://gre/modules/AddonRepository.jsm", scope);
 41571:       Components.utils.import("resource://gre/modules/LightweightThemeManager.jsm", scope);
 41571:       scope.LightweightThemeManager.updateCurrentTheme();
 41571: 
 83192:       pendingUpdates++;
 41586:       this.getAllAddons(function getAddonsCallback(aAddons) {
 84794:         // If there is a known hotfix then exclude it from the list of add-ons to update.
 84794:         var ids = [a.id for each (a in aAddons) if (a.id != hotfixID)];
 84794: 
 83134:         // Repopulate repository cache first, to ensure compatibility overrides
 83134:         // are up to date before checking for addon updates.
 89165:         scope.AddonRepository.backgroundUpdateCheck(ids, function BUC_backgroundUpdateCheckCallback() {
 83134:           AddonManagerInternal.updateAddonRepositoryData(function BUC_updateAddonCallback() {
 63060: 
 51520:             pendingUpdates += aAddons.length;
 84794:             aAddons.forEach(function BUC_forEachCallback(aAddon) {
 84794:               if (aAddon.id == hotfixID) {
 84794:                 notifyComplete();
 84794:                 return;
 84794:               }
 53775: 
 41586:               // Check all add-ons for updates so that any compatibility updates will
 41586:               // be applied
 41584:               aAddon.findUpdates({
 41584:                 onUpdateAvailable: function BUC_onUpdateAvailable(aAddon, aInstall) {
 41586:                   // Start installing updates when the add-on can be updated and
 41586:                   // background updates should be applied.
 41586:                   if (aAddon.permissions & AddonManager.PERM_CAN_UPGRADE &&
 75342:                       AddonManager.shouldAutoUpdate(aAddon)) {
 41584:                     aInstall.install();
 41549:                   }
 51520:                 },
 51520: 
 51520:                 onUpdateFinished: notifyComplete
 41549:               }, AddonManager.UPDATE_WHEN_PERIODIC_UPDATE);
 41549:             });
 51520: 
 51520:             notifyComplete();
 41549:           });
 83134:         });
 83134:       });
 84794:     }
 84794: 
 84794:     if (checkHotfix) {
 84794:       var hotfixVersion = "";
 84794:       try {
 84794:         hotfixVersion = Services.prefs.getCharPref(PREF_EM_HOTFIX_LASTVERSION);
 84794:       }
 84794:       catch (e) { }
 84794: 
 84794:       let url = null;
 84794:       if (Services.prefs.getPrefType(PREF_EM_HOTFIX_URL) == Ci.nsIPrefBranch.PREF_STRING)
 84794:         url = Services.prefs.getCharPref(PREF_EM_HOTFIX_URL);
 84794:       else
 91772:         url = Services.prefs.getCharPref(PREF_EM_UPDATE_BACKGROUND_URL);
 84794: 
 84794:       // Build the URI from a fake add-on data.
 84794:       url = AddonManager.escapeAddonURI({
 84794:         id: hotfixID,
 84794:         version: hotfixVersion,
 84794:         userDisabled: false,
 84794:         appDisabled: false
 84794:       }, url);
 84794: 
 84794:       pendingUpdates++;
 84794:       Components.utils.import("resource://gre/modules/AddonUpdateChecker.jsm");
 84794:       AddonUpdateChecker.checkForUpdates(hotfixID, "extension", null, url, {
 84794:         onUpdateCheckComplete: function(aUpdates) {
 84794:           let update = AddonUpdateChecker.getNewestCompatibleUpdate(aUpdates);
 84794:           if (!update) {
 84794:             notifyComplete();
 84794:             return;
 84794:           }
 84794: 
 84794:           // If the available version isn't newer than the last installed
 84794:           // version then ignore it.
 84794:           if (Services.vc.compare(hotfixVersion, update.version) >= 0) {
 84794:             notifyComplete();
 84794:             return;
 84794:           }
 84794: 
 84794:           LOG("Downloading hotfix version " + update.version);
 84794:           AddonManager.getInstallForURL(update.updateURL, function(aInstall) {
 84794:             aInstall.addListener({
 84796:               onDownloadEnded: function(aInstall) {
 84796:                 try {
 84796:                   if (!Services.prefs.getBoolPref(PREF_EM_CERT_CHECKATTRIBUTES))
 84796:                     return;
 84796:                 }
 84796:                 catch (e) {
 84796:                   // By default don't do certificate checks.
 84796:                   return;
 84796:                 }
 84796: 
 84796:                 try {
 84796:                   CertUtils.validateCert(aInstall.certificate,
 84796:                                          CertUtils.readCertPrefs(PREF_EM_HOTFIX_CERTS));
 84796:                 }
 84796:                 catch (e) {
 84796:                   WARN("The hotfix add-on was not signed by the expected " +
 84796:                        "certificate and so will not be installed.");
 84796:                   aInstall.cancel();
 84796:                 }
 84796:               },
 84796: 
 84794:               onInstallEnded: function(aInstall) {
 84794:                 // Remember the last successfully installed version.
 84794:                 Services.prefs.setCharPref(PREF_EM_HOTFIX_LASTVERSION,
 84794:                                            aInstall.version);
 84794:               },
 84794: 
 84794:               onInstallCancelled: function(aInstall) {
 84794:                 // Revert to the previous version if the installation was
 84794:                 // cancelled.
 84794:                 Services.prefs.setCharPref(PREF_EM_HOTFIX_LASTVERSION,
 84794:                                            hotfixVersion);
 84794:               }
 84794:             });
 84794: 
 84794:             aInstall.install();
 84794: 
 84794:             notifyComplete();
 84794:           }, "application/x-xpinstall", update.updateHash, null,
 84794:              null, update.version);
 84794:         },
 84794: 
 84794:         onUpdateCheckError: notifyComplete
 84794:       });
 84794:     }
 84794: 
 84794:     notifyComplete();
 41549:   },
 41549: 
 41549:   /**
 72782:    * Adds a add-on to the list of detected changes for this startup. If
 72782:    * addStartupChange is called multiple times for the same add-on in the same
 72782:    * startup then only the most recent change will be remembered.
 72782:    *
 72782:    * @param  aType
 72782:    *         The type of change as a string. Providers can define their own
 72782:    *         types of changes or use the existing defined STARTUP_CHANGE_*
 72782:    *         constants
 72782:    * @param  aID
 72782:    *         The ID of the add-on
 72782:    */
 72782:   addStartupChange: function AMI_addStartupChange(aType, aID) {
 99760:     if (!aType || typeof aType != "string")
 99760:       throw Components.Exception("aType must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (!aID || typeof aID != "string")
 99760:       throw Components.Exception("aID must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
108520:     if (gStartupComplete)
 72782:       return;
 72782: 
 72782:     // Ensure that an ID is only listed in one type of change
 72782:     for (let type in this.startupChanges)
 72782:       this.removeStartupChange(type, aID);
 72782: 
 72782:     if (!(aType in this.startupChanges))
 72782:       this.startupChanges[aType] = [];
 72782:     this.startupChanges[aType].push(aID);
 72782:   },
 72782: 
 72782:   /**
 72782:    * Removes a startup change for an add-on.
 72782:    *
 72782:    * @param  aType
 72782:    *         The type of change
 72782:    * @param  aID
 72782:    *         The ID of the add-on
 72782:    */
 72782:   removeStartupChange: function AMI_removeStartupChange(aType, aID) {
 99760:     if (!aType || typeof aType != "string")
 99760:       throw Components.Exception("aType must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (!aID || typeof aID != "string")
 99760:       throw Components.Exception("aID must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
108520:     if (gStartupComplete)
 72782:       return;
 72782: 
 72782:     if (!(aType in this.startupChanges))
 72782:       return;
 72782: 
 72782:     this.startupChanges[aType] = this.startupChanges[aType].filter(function(aItem) aItem != aID);
 72782:   },
 72782: 
 72782:   /**
 90139:    * Calls all registered AddonManagerListeners with an event. Any parameters
 90139:    * after the method parameter are passed to the listener.
 90139:    *
 90139:    * @param  aMethod
 90139:    *         The method on the listeners to call
 90139:    */
102413:   callManagerListeners: function AMI_callManagerListeners(aMethod, ...aArgs) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aMethod || typeof aMethod != "string")
 99760:       throw Components.Exception("aMethod must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99895:     let managerListeners = this.managerListeners.slice(0);
 99895:     for (let listener of managerListeners) {
 90139:       try {
 90139:         if (aMethod in listener)
102413:           listener[aMethod].apply(listener, aArgs);
 90139:       }
 90139:       catch (e) {
 90139:         WARN("AddonManagerListener threw exception when calling " + aMethod, e);
 90139:       }
 99895:     }
 90139:   },
 90139: 
 90139:   /**
 41549:    * Calls all registered InstallListeners with an event. Any parameters after
 41549:    * the extraListeners parameter are passed to the listener.
 41549:    *
 41584:    * @param  aMethod
 41549:    *         The method on the listeners to call
 41584:    * @param  aExtraListeners
 99760:    *         An optional array of extra InstallListeners to also call
 41549:    * @return false if any of the listeners returned false, true otherwise
 41549:    */
102413:   callInstallListeners: function AMI_callInstallListeners(aMethod, aExtraListeners, ...aArgs) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aMethod || typeof aMethod != "string")
 99760:       throw Components.Exception("aMethod must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aExtraListeners && !Array.isArray(aExtraListeners))
 99760:       throw Components.Exception("aExtraListeners must be an array or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 41549:     let result = true;
 99895:     let listeners;
 41584:     if (aExtraListeners)
 99895:       listeners = aExtraListeners.concat(this.installListeners);
 99895:     else
 99895:       listeners = this.installListeners.slice(0);
 41549: 
 99895:     for (let listener of listeners) {
 41549:       try {
 41584:         if (aMethod in listener) {
102413:           if (listener[aMethod].apply(listener, aArgs) === false)
 41549:             result = false;
 41549:         }
 41549:       }
 41549:       catch (e) {
 57401:         WARN("InstallListener threw exception when calling " + aMethod, e);
 41549:       }
 99895:     }
 41549:     return result;
 41549:   },
 41549: 
 41549:   /**
 41549:    * Calls all registered AddonListeners with an event. Any parameters after
 41549:    * the method parameter are passed to the listener.
 41549:    *
 41584:    * @param  aMethod
 41549:    *         The method on the listeners to call
 41549:    */
102413:   callAddonListeners: function AMI_callAddonListeners(aMethod, ...aArgs) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aMethod || typeof aMethod != "string")
 99760:       throw Components.Exception("aMethod must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99895:     let addonListeners = this.addonListeners.slice(0);
 99895:     for (let listener of addonListeners) {
 41549:       try {
 41584:         if (aMethod in listener)
102413:           listener[aMethod].apply(listener, aArgs);
 41549:       }
 41549:       catch (e) {
 57401:         WARN("AddonListener threw exception when calling " + aMethod, e);
 41549:       }
 99895:     }
 41549:   },
 41549: 
 41549:   /**
 41549:    * Notifies all providers that an add-on has been enabled when that type of
 41549:    * add-on only supports a single add-on being enabled at a time. This allows
 41549:    * the providers to disable theirs if necessary.
 41549:    *
 99760:    * @param  aID
 99760:    *         The ID of the enabled add-on
 41584:    * @param  aType
 41549:    *         The type of the enabled add-on
 41584:    * @param  aPendingRestart
 41549:    *         A boolean indicating if the change will only take place the next
 41549:    *         time the application is restarted
 41549:    */
 99760:   notifyAddonChanged: function AMI_notifyAddonChanged(aID, aType, aPendingRestart) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (aID && typeof aID != "string")
 99760:       throw Components.Exception("aID must be a string or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (!aType || typeof aType != "string")
 99760:       throw Components.Exception("aType must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99895:     this.callProviders("addonChanged", aID, aType, aPendingRestart);
 41549:   },
 41549: 
 41549:   /**
 41589:    * Notifies all providers they need to update the appDisabled property for
 41589:    * their add-ons in response to an application change such as a blocklist
 41589:    * update.
 41589:    */
 41589:   updateAddonAppDisabledStates: function AMI_updateAddonAppDisabledStates() {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99895:     this.callProviders("updateAddonAppDisabledStates");
 41589:   },
 41589:   
 41589:   /**
 83133:    * Notifies all providers that the repository has updated its data for
 83133:    * installed add-ons.
 83133:    *
 83133:    * @param  aCallback
 83133:    *         Function to call when operation is complete.
 83133:    */
 83133:   updateAddonRepositoryData: function AMI_updateAddonRepositoryData(aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 83133:                                  Cr.NS_ERROR_INVALID_ARG);
 83133: 
 83133:     new AsyncObjectCaller(this.providers, "updateAddonRepositoryData", {
 83133:       nextObject: function(aCaller, aProvider) {
 83133:         callProvider(aProvider,
 83133:                      "updateAddonRepositoryData",
 83133:                      null,
 83133:                      aCaller.callNext.bind(aCaller));
 83133:       },
 83133:       noMoreObjects: function(aCaller) {
 83133:         safeCall(aCallback);
 83133:       }
 83133:     });
 83133:   },
 99760: 
 83133:   /**
 41549:    * Asynchronously gets an AddonInstall for a URL.
 41549:    *
 41584:    * @param  aUrl
 99760:    *         The string represenation of the URL the add-on is located at
 41584:    * @param  aCallback
 41549:    *         A callback to pass the AddonInstall to
 41584:    * @param  aMimetype
 41549:    *         The mimetype of the add-on
 41584:    * @param  aHash
 41549:    *         An optional hash of the add-on
 41584:    * @param  aName
 41549:    *         An optional placeholder name while the add-on is being downloaded
109142:    * @param  aIcons
109142:    *         Optional placeholder icons while the add-on is being downloaded
 41584:    * @param  aVersion
 41549:    *         An optional placeholder version while the add-on is being downloaded
 41584:    * @param  aLoadGroup
 41549:    *         An optional nsILoadGroup to associate any network requests with
 41584:    * @throws if the aUrl, aCallback or aMimetype arguments are not specified
 41549:    */
 41584:   getInstallForURL: function AMI_getInstallForURL(aUrl, aCallback, aMimetype,
109142:                                                   aHash, aName, aIcons,
 41584:                                                   aVersion, aLoadGroup) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aUrl || typeof aUrl != "string")
 99760:       throw Components.Exception("aURL must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (!aMimetype || typeof aMimetype != "string")
 99760:       throw Components.Exception("aMimetype must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aHash && typeof aHash != "string")
 99760:       throw Components.Exception("aHash must be a string or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aName && typeof aName != "string")
 99760:       throw Components.Exception("aName must be a string or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
109142:     if (aIcons) {
109142:       if (typeof aIcons == "string")
109142:         aIcons = { "32": aIcons };
109142:       else if (typeof aIcons != "object")
109142:         throw Components.Exception("aIcons must be a string, an object or null",
 99760:                                    Cr.NS_ERROR_INVALID_ARG);
109142:     } else {
109142:       aIcons = {};
109142:     }
 99760: 
 99760:     if (aVersion && typeof aVersion != "string")
 99760:       throw Components.Exception("aVersion must be a string or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aLoadGroup && (!(aLoadGroup instanceof Ci.nsILoadGroup)))
 99760:       throw Components.Exception("aLoadGroup must be a nsILoadGroup or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 99895:     let providers = this.providers.slice(0);
 99895:     for (let provider of providers) {
 99622:       if (callProvider(provider, "supportsMimetype", false, aMimetype)) {
 99622:         callProvider(provider, "getInstallForURL", null,
109142:                      aUrl, aHash, aName, aIcons, aVersion, aLoadGroup,
 41584:                      function(aInstall) {
 41584:           safeCall(aCallback, aInstall);
 41549:         });
 41549:         return;
 41549:       }
 41549:     }
 41584:     safeCall(aCallback, null);
 41549:   },
 41549: 
 41549:   /**
 41549:    * Asynchronously gets an AddonInstall for an nsIFile.
 41549:    *
 41584:    * @param  aFile
 99760:    *         The nsIFile where the add-on is located
 41584:    * @param  aCallback
 41549:    *         A callback to pass the AddonInstall to
 41584:    * @param  aMimetype
 41549:    *         An optional mimetype hint for the add-on
 41584:    * @throws if the aFile or aCallback arguments are not specified
 41549:    */
 41584:   getInstallForFile: function AMI_getInstallForFile(aFile, aCallback, aMimetype) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!(aFile instanceof Ci.nsIFile))
 99760:       throw Components.Exception("aFile must be a nsIFile",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aMimetype && typeof aMimetype != "string")
 99760:       throw Components.Exception("aMimetype must be a string or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 41549:     new AsyncObjectCaller(this.providers, "getInstallForFile", {
 41584:       nextObject: function(aCaller, aProvider) {
 41584:         callProvider(aProvider, "getInstallForFile", null, aFile,
 41584:                      function(aInstall) {
 41584:           if (aInstall)
 41584:             safeCall(aCallback, aInstall);
 41549:           else
 41584:             aCaller.callNext();
 41549:         });
 41549:       },
 41549: 
 41584:       noMoreObjects: function(aCaller) {
 41584:         safeCall(aCallback, null);
 41549:       }
 41549:     });
 41549:   },
 41549: 
 41549:   /**
 41549:    * Asynchronously gets all current AddonInstalls optionally limiting to a list
 41549:    * of types.
 41549:    *
 41584:    * @param  aTypes
 41549:    *         An optional array of types to retrieve. Each type is a string name
 41584:    * @param  aCallback
 41549:    *         A callback which will be passed an array of AddonInstalls
 99760:    * @throws If the aCallback argument is not specified
 41549:    */
 41585:   getInstallsByTypes: function AMI_getInstallsByTypes(aTypes, aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (aTypes && !Array.isArray(aTypes))
 99760:       throw Components.Exception("aTypes must be an array or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 41549:     let installs = [];
 41549: 
 41585:     new AsyncObjectCaller(this.providers, "getInstallsByTypes", {
 41584:       nextObject: function(aCaller, aProvider) {
 41585:         callProvider(aProvider, "getInstallsByTypes", null, aTypes,
 41584:                      function(aProviderInstalls) {
 41584:           installs = installs.concat(aProviderInstalls);
 41584:           aCaller.callNext();
 41549:         });
 41549:       },
 41549: 
 41584:       noMoreObjects: function(aCaller) {
 41584:         safeCall(aCallback, installs);
 41549:       }
 41549:     });
 41549:   },
 41549: 
 41549:   /**
 41585:    * Asynchronously gets all current AddonInstalls.
 41585:    *
 41585:    * @param  aCallback
 41585:    *         A callback which will be passed an array of AddonInstalls
 41585:    */
 41585:   getAllInstalls: function AMI_getAllInstalls(aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 41585:     this.getInstallsByTypes(null, aCallback);
 41585:   },
 41585: 
 41585:   /**
 41549:    * Checks whether installation is enabled for a particular mimetype.
 41549:    *
 41584:    * @param  aMimetype
 41549:    *         The mimetype to check
 41549:    * @return true if installation is enabled for the mimetype
 41549:    */
 41584:   isInstallEnabled: function AMI_isInstallEnabled(aMimetype) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aMimetype || typeof aMimetype != "string")
 99760:       throw Components.Exception("aMimetype must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99895:     let providers = this.providers.slice(0);
 99895:     for (let provider of providers) {
 99622:       if (callProvider(provider, "supportsMimetype", false, aMimetype) &&
 99622:           callProvider(provider, "isInstallEnabled"))
 41549:         return true;
 41549:     }
 41549:     return false;
 41549:   },
 41549: 
 41549:   /**
 41549:    * Checks whether a particular source is allowed to install add-ons of a
 41549:    * given mimetype.
 41549:    *
 41584:    * @param  aMimetype
 41549:    *         The mimetype of the add-on
 41584:    * @param  aURI
 99760:    *         The optional nsIURI of the source
 41549:    * @return true if the source is allowed to install this mimetype
 41549:    */
 41584:   isInstallAllowed: function AMI_isInstallAllowed(aMimetype, aURI) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aMimetype || typeof aMimetype != "string")
 99760:       throw Components.Exception("aMimetype must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aURI && !(aURI instanceof Ci.nsIURI))
 99760:       throw Components.Exception("aURI must be a nsIURI or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99895:     let providers = this.providers.slice(0);
 99895:     for (let provider of providers) {
 99622:       if (callProvider(provider, "supportsMimetype", false, aMimetype) &&
 99622:           callProvider(provider, "isInstallAllowed", null, aURI))
 41549:         return true;
 41549:     }
 41593:     return false;
 41549:   },
 41549: 
 41549:   /**
 41549:    * Starts installation of an array of AddonInstalls notifying the registered
 41549:    * web install listener of blocked or started installs.
 41549:    *
 41584:    * @param  aMimetype
 41549:    *         The mimetype of add-ons being installed
 41584:    * @param  aSource
 99760:    *         The optional nsIDOMWindow that started the installs
 41584:    * @param  aURI
 99760:    *         The optional nsIURI that started the installs
 41584:    * @param  aInstalls
 41549:    *         The array of AddonInstalls to be installed
 41549:    */
 41584:   installAddonsFromWebpage: function AMI_installAddonsFromWebpage(aMimetype,
 41584:                                                                   aSource,
 41584:                                                                   aURI,
 41584:                                                                   aInstalls) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aMimetype || typeof aMimetype != "string")
 99760:       throw Components.Exception("aMimetype must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aSource && !(aSource instanceof Ci.nsIDOMWindow))
 99760:       throw Components.Exception("aSource must be a nsIDOMWindow or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (aURI && !(aURI instanceof Ci.nsIURI))
 99760:       throw Components.Exception("aURI must be a nsIURI or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (!Array.isArray(aInstalls))
 99760:       throw Components.Exception("aInstalls must be an array",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 41549:     if (!("@mozilla.org/addons/web-install-listener;1" in Cc)) {
 41549:       WARN("No web installer available, cancelling all installs");
 41584:       aInstalls.forEach(function(aInstall) {
 41584:         aInstall.cancel();
 41549:       });
 41549:       return;
 41549:     }
 41549: 
 41549:     try {
 41549:       let weblistener = Cc["@mozilla.org/addons/web-install-listener;1"].
 41549:                         getService(Ci.amIWebInstallListener);
 41549: 
 58189:       if (!this.isInstallEnabled(aMimetype, aURI)) {
 58189:         weblistener.onWebInstallDisabled(aSource, aURI, aInstalls,
 58189:                                          aInstalls.length);
 58189:       }
 58189:       else if (!this.isInstallAllowed(aMimetype, aURI)) {
 41584:         if (weblistener.onWebInstallBlocked(aSource, aURI, aInstalls,
 41584:                                             aInstalls.length)) {
 41584:           aInstalls.forEach(function(aInstall) {
 41584:             aInstall.install();
 41549:           });
 41549:         }
 41549:       }
 41584:       else if (weblistener.onWebInstallRequested(aSource, aURI, aInstalls,
 41584:                                                    aInstalls.length)) {
 41584:         aInstalls.forEach(function(aInstall) {
 41584:           aInstall.install();
 41549:         });
 41549:       }
 41549:     }
 41549:     catch (e) {
 41549:       // In the event that the weblistener throws during instatiation or when
 41549:       // calling onWebInstallBlocked or onWebInstallRequested all of the
 41549:       // installs should get cancelled.
 57401:       WARN("Failure calling web installer", e);
 41584:       aInstalls.forEach(function(aInstall) {
 41584:         aInstall.cancel();
 41549:       });
 41549:     }
 41549:   },
 41549: 
 41549:   /**
 41549:    * Adds a new InstallListener if the listener is not already registered.
 41549:    *
 41584:    * @param  aListener
 41549:    *         The InstallListener to add
 41549:    */
 41584:   addInstallListener: function AMI_addInstallListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be a InstallListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760:     
 41584:     if (!this.installListeners.some(function(i) { return i == aListener; }))
 41584:       this.installListeners.push(aListener);
 41549:   },
 41549: 
 41549:   /**
 41549:    * Removes an InstallListener if the listener is registered.
 41549:    *
 41584:    * @param  aListener
 41549:    *         The InstallListener to remove
 41549:    */
 41584:   removeInstallListener: function AMI_removeInstallListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be a InstallListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 55435:     let pos = 0;
 55435:     while (pos < this.installListeners.length) {
 55435:       if (this.installListeners[pos] == aListener)
 55435:         this.installListeners.splice(pos, 1);
 55435:       else
 55435:         pos++;
 55435:     }
 41549:   },
 41549: 
 41549:   /**
 41549:    * Asynchronously gets an add-on with a specific ID.
 41549:    *
 99760:    * @param  aID
 41549:    *         The ID of the add-on to retrieve
 41584:    * @param  aCallback
 41549:    *         The callback to pass the retrieved add-on to
 99760:    * @throws if the aID or aCallback arguments are not specified
 41549:    */
 99760:   getAddonByID: function AMI_getAddonByID(aID, aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aID || typeof aID != "string")
 99760:       throw Components.Exception("aID must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 41585:     new AsyncObjectCaller(this.providers, "getAddonByID", {
 41584:       nextObject: function(aCaller, aProvider) {
 99760:         callProvider(aProvider, "getAddonByID", null, aID, function(aAddon) {
 41584:           if (aAddon)
 41584:             safeCall(aCallback, aAddon);
 41549:           else
 41584:             aCaller.callNext();
 41549:         });
 41549:       },
 41549: 
 41584:       noMoreObjects: function(aCaller) {
 41584:         safeCall(aCallback, null);
 41549:       }
 41549:     });
 41549:   },
 41549: 
 41549:   /**
 82404:    * Asynchronously get an add-on with a specific Sync GUID.
 82404:    *
 82404:    * @param  aGUID
 82404:    *         String GUID of add-on to retrieve
 82404:    * @param  aCallback
 82404:    *         The callback to pass the retrieved add-on to.
 82404:    * @throws if the aGUID or aCallback arguments are not specified
 82404:    */
 82404:   getAddonBySyncGUID: function AMI_getAddonBySyncGUID(aGUID, aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!aGUID || typeof aGUID != "string")
 99760:       throw Components.Exception("aGUID must be a non-empty string",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 82404: 
 82404:     new AsyncObjectCaller(this.providers, "getAddonBySyncGUID", {
 82404:       nextObject: function(aCaller, aProvider) {
 82404:         callProvider(aProvider, "getAddonBySyncGUID", null, aGUID, function(aAddon) {
 82404:           if (aAddon) {
 82404:             safeCall(aCallback, aAddon);
 82404:           } else {
 82404:             aCaller.callNext();
 82404:           }
 82404:         });
 82404:       },
 82404: 
 82404:       noMoreObjects: function(aCaller) {
 82404:         safeCall(aCallback, null);
 82404:       }
 82404:     });
 82404:   },
 82404: 
 82404:   /**
 41549:    * Asynchronously gets an array of add-ons.
 41549:    *
 99760:    * @param  aIDs
 41549:    *         The array of IDs to retrieve
 41584:    * @param  aCallback
 41549:    *         The callback to pass an array of Addons to
 99760:    * @throws if the aID or aCallback arguments are not specified
 41549:    */
 99760:   getAddonsByIDs: function AMI_getAddonsByIDs(aIDs, aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (!Array.isArray(aIDs))
 99760:       throw Components.Exception("aIDs must be an array",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 41549:     let addons = [];
 41549: 
 99760:     new AsyncObjectCaller(aIDs, null, {
 99760:       nextObject: function(aCaller, aID) {
 99760:         AddonManagerInternal.getAddonByID(aID, function(aAddon) {
 41584:           addons.push(aAddon);
 41584:           aCaller.callNext();
 41549:         });
 41549:       },
 41549: 
 41584:       noMoreObjects: function(aCaller) {
 41584:         safeCall(aCallback, addons);
 41549:       }
 41549:     });
 41549:   },
 41549: 
 41549:   /**
 41549:    * Asynchronously gets add-ons of specific types.
 41549:    *
 41584:    * @param  aTypes
 41549:    *         An optional array of types to retrieve. Each type is a string name
 41584:    * @param  aCallback
 41549:    *         The callback to pass an array of Addons to.
 41584:    * @throws if the aCallback argument is not specified
 41549:    */
 41584:   getAddonsByTypes: function AMI_getAddonsByTypes(aTypes, aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (aTypes && !Array.isArray(aTypes))
 99760:       throw Components.Exception("aTypes must be an array or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 41549:     let addons = [];
 41549: 
 41549:     new AsyncObjectCaller(this.providers, "getAddonsByTypes", {
 41584:       nextObject: function(aCaller, aProvider) {
 41584:         callProvider(aProvider, "getAddonsByTypes", null, aTypes,
 41584:                      function(aProviderAddons) {
 41584:           addons = addons.concat(aProviderAddons);
 41584:           aCaller.callNext();
 41549:         });
 41549:       },
 41549: 
 41584:       noMoreObjects: function(aCaller) {
 41584:         safeCall(aCallback, addons);
 41549:       }
 41549:     });
 41549:   },
 41549: 
 41549:   /**
 41585:    * Asynchronously gets all installed add-ons.
 41585:    *
 41585:    * @param  aCallback
 41585:    *         A callback which will be passed an array of Addons
 41585:    */
 41585:   getAllAddons: function AMI_getAllAddons(aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
108520:     if (typeof aCallback != "function")
108520:       throw Components.Exception("aCallback must be a function",
108520:                                  Cr.NS_ERROR_INVALID_ARG);
108520: 
 41585:     this.getAddonsByTypes(null, aCallback);
 41585:   },
 41585: 
 41585:   /**
 41549:    * Asynchronously gets add-ons that have operations waiting for an application
 41549:    * restart to complete.
 41549:    *
 41584:    * @param  aTypes
 41549:    *         An optional array of types to retrieve. Each type is a string name
 41584:    * @param  aCallback
 41549:    *         The callback to pass the array of Addons to
 41584:    * @throws if the aCallback argument is not specified
 41549:    */
 41585:   getAddonsWithOperationsByTypes:
 41585:   function AMI_getAddonsWithOperationsByTypes(aTypes, aCallback) {
108520:     if (!gStarted)
108520:       throw Components.Exception("AddonManager is not initialized",
108520:                                  Cr.NS_ERROR_NOT_INITIALIZED);
108520: 
 99760:     if (aTypes && !Array.isArray(aTypes))
 99760:       throw Components.Exception("aTypes must be an array or null",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 99760:     if (typeof aCallback != "function")
 99760:       throw Components.Exception("aCallback must be a function",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 41549: 
 41549:     let addons = [];
 41549: 
 41585:     new AsyncObjectCaller(this.providers, "getAddonsWithOperationsByTypes", {
 41584:       nextObject: function(aCaller, aProvider) {
 41585:         callProvider(aProvider, "getAddonsWithOperationsByTypes", null, aTypes,
 41584:                      function(aProviderAddons) {
 41584:           addons = addons.concat(aProviderAddons);
 41584:           aCaller.callNext();
 41549:         });
 41549:       },
 41549: 
 41549:       noMoreObjects: function(caller) {
 41584:         safeCall(aCallback, addons);
 41549:       }
 41549:     });
 41549:   },
 41549: 
 41549:   /**
 90139:    * Adds a new AddonManagerListener if the listener is not already registered.
 90139:    *
 90139:    * @param  aListener
 90139:    *         The listener to add
 90139:    */
 90139:   addManagerListener: function AMI_addManagerListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be an AddonManagerListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 90139:     if (!this.managerListeners.some(function(i) { return i == aListener; }))
 90139:       this.managerListeners.push(aListener);
 90139:   },
 90139: 
 90139:   /**
 90139:    * Removes an AddonManagerListener if the listener is registered.
 90139:    *
 90139:    * @param  aListener
 90139:    *         The listener to remove
 90139:    */
 90139:   removeManagerListener: function AMI_removeManagerListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be an AddonManagerListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 90139:     let pos = 0;
 90139:     while (pos < this.managerListeners.length) {
 90139:       if (this.managerListeners[pos] == aListener)
 90139:         this.managerListeners.splice(pos, 1);
 90139:       else
 90139:         pos++;
 90139:     }
 90139:   },
 90139: 
 90139:   /**
 41549:    * Adds a new AddonListener if the listener is not already registered.
 41549:    *
 41584:    * @param  aListener
 99760:    *         The AddonListener to add
 41549:    */
 41584:   addAddonListener: function AMI_addAddonListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be an AddonListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 41584:     if (!this.addonListeners.some(function(i) { return i == aListener; }))
 41584:       this.addonListeners.push(aListener);
 41549:   },
 41549: 
 41549:   /**
 41549:    * Removes an AddonListener if the listener is registered.
 41549:    *
 41584:    * @param  aListener
 99760:    *         The AddonListener to remove
 41549:    */
 41584:   removeAddonListener: function AMI_removeAddonListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be an AddonListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 55435:     let pos = 0;
 55435:     while (pos < this.addonListeners.length) {
 55435:       if (this.addonListeners[pos] == aListener)
 55435:         this.addonListeners.splice(pos, 1);
 55435:       else
 55435:         pos++;
 55435:     }
 53775:   },
 53775: 
 99760:   /**
 99760:    * Adds a new TypeListener if the listener is not already registered.
 99760:    *
 99760:    * @param  aListener
 99760:    *         The TypeListener to add
 99760:    */
 70152:   addTypeListener: function AMI_addTypeListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be a TypeListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 70152:     if (!this.typeListeners.some(function(i) { return i == aListener; }))
 70152:       this.typeListeners.push(aListener);
 70152:   },
 70152: 
 99760:   /**
 99760:    * Removes an TypeListener if the listener is registered.
 99760:    *
 99760:    * @param  aListener
 99760:    *         The TypeListener to remove
 99760:    */
 70152:   removeTypeListener: function AMI_removeTypeListener(aListener) {
 99760:     if (!aListener || typeof aListener != "object")
 99760:       throw Components.Exception("aListener must be a TypeListener object",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760: 
 70152:     let pos = 0;
 70152:     while (pos < this.typeListeners.length) {
 70152:       if (this.typeListeners[pos] == aListener)
 70152:         this.typeListeners.splice(pos, 1);
 70152:       else
 70152:         pos++;
 70152:     }
 70152:   },
 70152: 
 70152:   get addonTypes() {
 70152:     return this.typesProxy;
 70152:   },
 70152: 
 53775:   get autoUpdateDefault() {
 90139:     return gAutoUpdateDefault;
 90139:   },
 90139: 
 90139:   set autoUpdateDefault(aValue) {
 90139:     aValue = !!aValue;
 90139:     if (aValue != gAutoUpdateDefault)
 90139:       Services.prefs.setBoolPref(PREF_EM_AUTOUPDATE_DEFAULT, aValue);
 90139:     return aValue;
 90139:   },
 90139: 
 90139:   get checkCompatibility() {
 90139:     return gCheckCompatibility;
 90139:   },
 90139: 
 90139:   set checkCompatibility(aValue) {
 90139:     aValue = !!aValue;
 90139:     if (aValue != gCheckCompatibility) {
 90139:       if (!aValue)
 90139:         Services.prefs.setBoolPref(PREF_EM_CHECK_COMPATIBILITY, false);
 90139:       else
 90139:         Services.prefs.clearUserPref(PREF_EM_CHECK_COMPATIBILITY);
 90139:     }
 90139:     return aValue;
 81115:   },
 81115: 
 81115:   get strictCompatibility() {
 81115:     return gStrictCompatibility;
 90139:   },
 90139: 
 90139:   set strictCompatibility(aValue) {
 90139:     aValue = !!aValue;
 90139:     if (aValue != gStrictCompatibility)
 90139:       Services.prefs.setBoolPref(PREF_EM_STRICT_COMPATIBILITY, aValue);
 90139:     return aValue;
 90139:   },
 90139: 
 90139:   get checkUpdateSecurityDefault() {
 90139:     return gCheckUpdateSecurityDefault;
 90139:   },
 90139: 
 90139:   get checkUpdateSecurity() {
 90139:     return gCheckUpdateSecurity;
 90139:   },
 90139: 
 90139:   set checkUpdateSecurity(aValue) {
 90139:     aValue = !!aValue;
 90139:     if (aValue != gCheckUpdateSecurity) {
 90139:       if (aValue != gCheckUpdateSecurityDefault)
 90139:         Services.prefs.setBoolPref(PREF_EM_CHECK_UPDATE_SECURITY, aValue);
 90139:       else
 90139:         Services.prefs.clearUserPref(PREF_EM_CHECK_UPDATE_SECURITY);
 90139:     }
 90139:     return aValue;
 90139:   },
 90139: 
 90139:   get updateEnabled() {
 90139:     return gUpdateEnabled;
 90139:   },
 90139: 
 90139:   set updateEnabled(aValue) {
 90139:     aValue = !!aValue;
 90139:     if (aValue != gUpdateEnabled)
 90139:       Services.prefs.setBoolPref(PREF_EM_UPDATE_ENABLED, aValue);
 90139:     return aValue;
 98684:   },
 98684: 
 98684:   get hotfixID() {
 98684:     return gHotfixID;
 98684:   },
 41549: };
 41549: 
 41549: /**
 41549:  * Should not be used outside of core Mozilla code. This is a private API for
 41549:  * the startup and platform integration code to use. Refer to the methods on
 41549:  * AddonManagerInternal for documentation however note that these methods are
 41549:  * subject to change at any time.
 41549:  */
 41549: var AddonManagerPrivate = {
 41549:   startup: function AMP_startup() {
 41549:     AddonManagerInternal.startup();
 41549:   },
 41549: 
 70152:   registerProvider: function AMP_registerProvider(aProvider, aTypes) {
 70152:     AddonManagerInternal.registerProvider(aProvider, aTypes);
 41549:   },
 41549: 
 43745:   unregisterProvider: function AMP_unregisterProvider(aProvider) {
 43745:     AddonManagerInternal.unregisterProvider(aProvider);
 43745:   },
 43745: 
 41549:   backgroundUpdateCheck: function AMP_backgroundUpdateCheck() {
 41549:     AddonManagerInternal.backgroundUpdateCheck();
 41549:   },
 41549: 
 72782:   addStartupChange: function AMP_addStartupChange(aType, aID) {
 72782:     AddonManagerInternal.addStartupChange(aType, aID);
 72782:   },
 72782: 
 72782:   removeStartupChange: function AMP_removeStartupChange(aType, aID) {
 72782:     AddonManagerInternal.removeStartupChange(aType, aID);
 72782:   },
 72782: 
 99760:   notifyAddonChanged: function AMP_notifyAddonChanged(aID, aType, aPendingRestart) {
 99760:     AddonManagerInternal.notifyAddonChanged(aID, aType, aPendingRestart);
 41549:   },
 41549: 
 41589:   updateAddonAppDisabledStates: function AMP_updateAddonAppDisabledStates() {
 41589:     AddonManagerInternal.updateAddonAppDisabledStates();
 41589:   },
 41589: 
 84165:   updateAddonRepositoryData: function AMP_updateAddonRepositoryData(aCallback) {
 84165:     AddonManagerInternal.updateAddonRepositoryData(aCallback);
 84165:   },
 84165: 
102413:   callInstallListeners: function AMP_callInstallListeners(...aArgs) {
 41549:     return AddonManagerInternal.callInstallListeners.apply(AddonManagerInternal,
102413:                                                            aArgs);
 41549:   },
 41549: 
102413:   callAddonListeners: function AMP_callAddonListeners(...aArgs) {
102413:     AddonManagerInternal.callAddonListeners.apply(AddonManagerInternal, aArgs);
 51520:   },
 51520: 
 51520:   AddonAuthor: AddonAuthor,
 51520: 
 70152:   AddonScreenshot: AddonScreenshot,
 70152: 
 83133:   AddonCompatibilityOverride: AddonCompatibilityOverride,
 83133: 
 70152:   AddonType: AddonType
 41549: };
 41549: 
 41549: /**
 41549:  * This is the public API that UI and developers should be calling. All methods
 41549:  * just forward to AddonManagerInternal.
 41549:  */
 41549: var AddonManager = {
 41549:   // Constants for the AddonInstall.state property
 41549:   // The install is available for download.
 41549:   STATE_AVAILABLE: 0,
 41549:   // The install is being downloaded.
 41549:   STATE_DOWNLOADING: 1,
 41549:   // The install is checking for compatibility information.
 41549:   STATE_CHECKING: 2,
 41549:   // The install is downloaded and ready to install.
 41549:   STATE_DOWNLOADED: 3,
 41549:   // The download failed.
 41549:   STATE_DOWNLOAD_FAILED: 4,
 41549:   // The add-on is being installed.
 41549:   STATE_INSTALLING: 5,
 41549:   // The add-on has been installed.
 41549:   STATE_INSTALLED: 6,
 41549:   // The install failed.
 41549:   STATE_INSTALL_FAILED: 7,
 41549:   // The install has been cancelled.
 41549:   STATE_CANCELLED: 8,
 41549: 
 41549:   // Constants representing different types of errors while downloading an
 41549:   // add-on.
 41549:   // The download failed due to network problems.
 41549:   ERROR_NETWORK_FAILURE: -1,
 41549:   // The downloaded file did not match the provided hash.
 41549:   ERROR_INCORRECT_HASH: -2,
 41549:   // The downloaded file seems to be corrupted in some way.
 41549:   ERROR_CORRUPT_FILE: -3,
 43491:   // An error occured trying to write to the filesystem.
 43491:   ERROR_FILE_ACCESS: -4,
 41549: 
 43489:   // These must be kept in sync with AddonUpdateChecker.
 43489:   // No error was encountered.
 43489:   UPDATE_STATUS_NO_ERROR: 0,
 43489:   // The update check timed out
 43489:   UPDATE_STATUS_TIMEOUT: -1,
 43489:   // There was an error while downloading the update information.
 43489:   UPDATE_STATUS_DOWNLOAD_ERROR: -2,
 43489:   // The update information was malformed in some way.
 43489:   UPDATE_STATUS_PARSE_ERROR: -3,
 43489:   // The update information was not in any known format.
 43489:   UPDATE_STATUS_UNKNOWN_FORMAT: -4,
 43489:   // The update information was not correctly signed or there was an SSL error.
 43489:   UPDATE_STATUS_SECURITY_ERROR: -5,
 43489: 
 41549:   // Constants to indicate why an update check is being performed
 41549:   // Update check has been requested by the user.
 41549:   UPDATE_WHEN_USER_REQUESTED: 1,
 41549:   // Update check is necessary to see if the Addon is compatibile with a new
 41549:   // version of the application.
 41549:   UPDATE_WHEN_NEW_APP_DETECTED: 2,
 41549:   // Update check is necessary because a new application has been installed.
 41549:   UPDATE_WHEN_NEW_APP_INSTALLED: 3,
 41549:   // Update check is a regular background update check.
 41549:   UPDATE_WHEN_PERIODIC_UPDATE: 16,
 41549:   // Update check is needed to check an Addon that is being installed.
 41549:   UPDATE_WHEN_ADDON_INSTALLED: 17,
 41549: 
 41549:   // Constants for operations in Addon.pendingOperations
 41551:   // Indicates that the Addon has no pending operations.
 41551:   PENDING_NONE: 0,
 41549:   // Indicates that the Addon will be enabled after the application restarts.
 41549:   PENDING_ENABLE: 1,
 41549:   // Indicates that the Addon will be disabled after the application restarts.
 41549:   PENDING_DISABLE: 2,
 41549:   // Indicates that the Addon will be uninstalled after the application restarts.
 41549:   PENDING_UNINSTALL: 4,
 41549:   // Indicates that the Addon will be installed after the application restarts.
 41549:   PENDING_INSTALL: 8,
 41565:   PENDING_UPGRADE: 16,
 41549: 
 48205:   // Constants for operations in Addon.operationsRequiringRestart
 48205:   // Indicates that restart isn't required for any operation.
 48205:   OP_NEEDS_RESTART_NONE: 0,
 48205:   // Indicates that restart is required for enabling the addon.
 48205:   OP_NEEDS_RESTART_ENABLE: 1,
 48205:   // Indicates that restart is required for disabling the addon.
 48205:   OP_NEEDS_RESTART_DISABLE: 2,
 48205:   // Indicates that restart is required for uninstalling the addon.
 48205:   OP_NEEDS_RESTART_UNINSTALL: 4,
 48205:   // Indicates that restart is required for installing the addon.
 48205:   OP_NEEDS_RESTART_INSTALL: 8,
 48205: 
 41549:   // Constants for permissions in Addon.permissions.
 41549:   // Indicates that the Addon can be uninstalled.
 41549:   PERM_CAN_UNINSTALL: 1,
 41549:   // Indicates that the Addon can be enabled by the user.
 41549:   PERM_CAN_ENABLE: 2,
 41549:   // Indicates that the Addon can be disabled by the user.
 41549:   PERM_CAN_DISABLE: 4,
 41549:   // Indicates that the Addon can be upgraded.
 41549:   PERM_CAN_UPGRADE: 8,
 41549: 
 41579:   // General descriptions of where items are installed.
 41579:   // Installed in this profile.
 41579:   SCOPE_PROFILE: 1,
 41579:   // Installed for all of this user's profiles.
 41579:   SCOPE_USER: 2,
 41579:   // Installed and owned by the application.
 41579:   SCOPE_APPLICATION: 4,
 41579:   // Installed for all users of the computer.
 41579:   SCOPE_SYSTEM: 8,
 41579:   // The combination of all scopes.
 41579:   SCOPE_ALL: 15,
 41579: 
 70152:   // 1-15 are different built-in views for the add-on type
 70152:   VIEW_TYPE_LIST: "list",
 70152: 
 70152:   TYPE_UI_HIDE_EMPTY: 16,
 70152: 
 53775:   // Constants for Addon.applyBackgroundUpdates.
 53775:   // Indicates that the Addon should not update automatically.
 53775:   AUTOUPDATE_DISABLE: 0,
 53775:   // Indicates that the Addon should update automatically only if
 53775:   // that's the global default.
 53775:   AUTOUPDATE_DEFAULT: 1,
 53775:   // Indicates that the Addon should update automatically.
 53775:   AUTOUPDATE_ENABLE: 2,
 53775: 
 71220:   // Constants for how Addon options should be shown.
 71220:   // Options will be opened in a new window
 71220:   OPTIONS_TYPE_DIALOG: 1,
 71220:   // Options will be displayed within the AM detail view
 71220:   OPTIONS_TYPE_INLINE: 2,
 72001:   // Options will be displayed in a new tab, if possible
 72001:   OPTIONS_TYPE_TAB: 3,
 71220: 
 72782:   // Constants for getStartupChanges, addStartupChange and removeStartupChange
 72782:   // Add-ons that were detected as installed during startup. Doesn't include
 72782:   // add-ons that were pending installation the last time the application ran.
 72782:   STARTUP_CHANGE_INSTALLED: "installed",
 72782:   // Add-ons that were detected as changed during startup. This includes an
 72782:   // add-on moving to a different location, changing version or just having
 72782:   // been detected as possibly changed.
 72782:   STARTUP_CHANGE_CHANGED: "changed",
 72782:   // Add-ons that were detected as uninstalled during startup. Doesn't include
 72782:   // add-ons that were pending uninstallation the last time the application ran.
 72782:   STARTUP_CHANGE_UNINSTALLED: "uninstalled",
 72782:   // Add-ons that were detected as disabled during startup, normally because of
 72782:   // an application change making an add-on incompatible. Doesn't include
 72782:   // add-ons that were pending being disabled the last time the application ran.
 72782:   STARTUP_CHANGE_DISABLED: "disabled",
 72782:   // Add-ons that were detected as enabled during startup, normally because of
 72782:   // an application change making an add-on compatible. Doesn't include
 72782:   // add-ons that were pending being enabled the last time the application ran.
 72782:   STARTUP_CHANGE_ENABLED: "enabled",
 72782: 
108209: #ifdef MOZ_EM_DEBUG
108209:   get __AddonManagerInternal__() {
108209:     return AddonManagerInternal;
108209:   },
108209: #endif
108209: 
 41584:   getInstallForURL: function AM_getInstallForURL(aUrl, aCallback, aMimetype,
109142:                                                  aHash, aName, aIcons,
 41584:                                                  aVersion, aLoadGroup) {
 41584:     AddonManagerInternal.getInstallForURL(aUrl, aCallback, aMimetype, aHash,
109142:                                           aName, aIcons, aVersion, aLoadGroup);
 41549:   },
 41549: 
 41584:   getInstallForFile: function AM_getInstallForFile(aFile, aCallback, aMimetype) {
 41584:     AddonManagerInternal.getInstallForFile(aFile, aCallback, aMimetype);
 41549:   },
 41549: 
 72782:   /**
 72782:    * Gets an array of add-on IDs that changed during the most recent startup.
 72782:    *
 72782:    * @param  aType
 72782:    *         The type of startup change to get
 72782:    * @return An array of add-on IDs
 72782:    */
 72782:   getStartupChanges: function AM_getStartupChanges(aType) {
 72782:     if (!(aType in AddonManagerInternal.startupChanges))
 72782:       return [];
 72782:     return AddonManagerInternal.startupChanges[aType].slice(0);
 72782:   },
 72782: 
 99760:   getAddonByID: function AM_getAddonByID(aID, aCallback) {
 99760:     AddonManagerInternal.getAddonByID(aID, aCallback);
 41549:   },
 41549: 
 99760:   getAddonBySyncGUID: function AM_getAddonBySyncGUID(aGUID, aCallback) {
 99760:     AddonManagerInternal.getAddonBySyncGUID(aGUID, aCallback);
 82404:   },
 82404: 
 99760:   getAddonsByIDs: function AM_getAddonsByIDs(aIDs, aCallback) {
 99760:     AddonManagerInternal.getAddonsByIDs(aIDs, aCallback);
 41549:   },
 41549: 
 41585:   getAddonsWithOperationsByTypes:
 41585:   function AM_getAddonsWithOperationsByTypes(aTypes, aCallback) {
 41585:     AddonManagerInternal.getAddonsWithOperationsByTypes(aTypes, aCallback);
 41549:   },
 41549: 
 41584:   getAddonsByTypes: function AM_getAddonsByTypes(aTypes, aCallback) {
 41584:     AddonManagerInternal.getAddonsByTypes(aTypes, aCallback);
 41549:   },
 41549: 
 41585:   getAllAddons: function AM_getAllAddons(aCallback) {
 41585:     AddonManagerInternal.getAllAddons(aCallback);
 41585:   },
 41585: 
 41585:   getInstallsByTypes: function AM_getInstallsByTypes(aTypes, aCallback) {
 41585:     AddonManagerInternal.getInstallsByTypes(aTypes, aCallback);
 41585:   },
 41585: 
 41585:   getAllInstalls: function AM_getAllInstalls(aCallback) {
 41585:     AddonManagerInternal.getAllInstalls(aCallback);
 41549:   },
 41549: 
 41584:   isInstallEnabled: function AM_isInstallEnabled(aType) {
 41584:     return AddonManagerInternal.isInstallEnabled(aType);
 41549:   },
 41549: 
 41584:   isInstallAllowed: function AM_isInstallAllowed(aType, aUri) {
 41584:     return AddonManagerInternal.isInstallAllowed(aType, aUri);
 41549:   },
 41549: 
 41584:   installAddonsFromWebpage: function AM_installAddonsFromWebpage(aType, aSource,
 41584:                                                                  aUri, aInstalls) {
 41584:     AddonManagerInternal.installAddonsFromWebpage(aType, aSource, aUri, aInstalls);
 41549:   },
 41549: 
 90139:   addManagerListener: function AM_addManagerListener(aListener) {
 90139:     AddonManagerInternal.addManagerListener(aListener);
 90139:   },
 90139: 
 90139:   removeManagerListener: function AM_removeManagerListener(aListener) {
 90139:     AddonManagerInternal.removeManagerListener(aListener);
 90139:   },
 90139: 
 41584:   addInstallListener: function AM_addInstallListener(aListener) {
 41584:     AddonManagerInternal.addInstallListener(aListener);
 41549:   },
 41549: 
 41584:   removeInstallListener: function AM_removeInstallListener(aListener) {
 41584:     AddonManagerInternal.removeInstallListener(aListener);
 41549:   },
 41549: 
 41584:   addAddonListener: function AM_addAddonListener(aListener) {
 41584:     AddonManagerInternal.addAddonListener(aListener);
 41549:   },
 41549: 
 41584:   removeAddonListener: function AM_removeAddonListener(aListener) {
 41584:     AddonManagerInternal.removeAddonListener(aListener);
 53775:   },
 53775: 
 70152:   addTypeListener: function AM_addTypeListener(aListener) {
 70152:     AddonManagerInternal.addTypeListener(aListener);
 70152:   },
 70152: 
 70152:   removeTypeListener: function AM_removeTypeListener(aListener) {
 70152:     AddonManagerInternal.removeTypeListener(aListener);
 70152:   },
 70152: 
 70152:   get addonTypes() {
 70152:     return AddonManagerInternal.addonTypes;
 70152:   },
 70152: 
 99760:   /**
 99760:    * Determines whether an Addon should auto-update or not.
 99760:    *
 99760:    * @param  aAddon
 99760:    *         The Addon representing the add-on
 99760:    * @return true if the addon should auto-update, false otherwise.
 99760:    */
 75342:   shouldAutoUpdate: function AM_shouldAutoUpdate(aAddon) {
 99760:     if (!aAddon || typeof aAddon != "object")
 99760:       throw Components.Exception("aAddon must be specified",
 99760:                                  Cr.NS_ERROR_INVALID_ARG);
 99760:     
 75342:     if (!("applyBackgroundUpdates" in aAddon))
 75342:       return false;
 75342:     if (aAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_ENABLE)
 75342:       return true;
 75342:     if (aAddon.applyBackgroundUpdates == AddonManager.AUTOUPDATE_DISABLE)
 75342:       return false;
 75342:     return this.autoUpdateDefault;
 81115:   },
 81115: 
 90139:   get checkCompatibility() {
 90139:     return AddonManagerInternal.checkCompatibility;
 90139:   },
 90139: 
 90139:   set checkCompatibility(aValue) {
 90139:     AddonManagerInternal.checkCompatibility = aValue;
 90139:   },
 90139: 
 81115:   get strictCompatibility() {
 81115:     return AddonManagerInternal.strictCompatibility;
 84794:   },
 84794: 
 90139:   set strictCompatibility(aValue) {
 90139:     AddonManagerInternal.strictCompatibility = aValue;
 90139:   },
 90139: 
 90139:   get checkUpdateSecurityDefault() {
 90139:     return AddonManagerInternal.checkUpdateSecurityDefault;
 90139:   },
 90139: 
 90139:   get checkUpdateSecurity() {
 90139:     return AddonManagerInternal.checkUpdateSecurity;
 90139:   },
 90139: 
 90139:   set checkUpdateSecurity(aValue) {
 90139:     AddonManagerInternal.checkUpdateSecurity = aValue;
 90139:   },
 90139: 
 90139:   get updateEnabled() {
 90139:     return AddonManagerInternal.updateEnabled;
 90139:   },
 90139: 
 90139:   set updateEnabled(aValue) {
 90139:     AddonManagerInternal.updateEnabled = aValue;
 90139:   },
 90139: 
 90139:   get autoUpdateDefault() {
 90139:     return AddonManagerInternal.autoUpdateDefault;
 90139:   },
 90139: 
 90139:   set autoUpdateDefault(aValue) {
 90139:     AddonManagerInternal.autoUpdateDefault = aValue;
 90139:   },
 90139: 
 98684:   get hotfixID() {
 98684:     return AddonManagerInternal.hotfixID;
 98684:   },
 98684: 
 84794:   escapeAddonURI: function AM_escapeAddonURI(aAddon, aUri, aAppVersion) {
 84794:     return AddonManagerInternal.escapeAddonURI(aAddon, aUri, aAppVersion);
 41549:   }
 41549: };
 55435: 
 55435: Object.freeze(AddonManagerInternal);
 55435: Object.freeze(AddonManagerPrivate);
 55435: Object.freeze(AddonManager);
