    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   IBM Corporation
43003:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
 8980:  * rendering object for CSS display:block, inline-block, and list-item
 8980:  * boxes, also used for various anonymous boxes
    1:  */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsBlockReflowContext.h"
    1: #include "nsBlockReflowState.h"
    1: #include "nsBulletFrame.h"
    1: #include "nsLineBox.h"
    1: #include "nsInlineFrame.h"
    1: #include "nsLineLayout.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsFrameManager.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIView.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "prprf.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsFrameSelection.h"
23306: #include "nsFloatManager.h"
    1: #include "nsIntervalSet.h"
    1: #include "prenv.h"
    1: #include "plstr.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScrollableFrame.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsLayoutUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsContentErrors.h"
  691: #include "nsCSSAnonBoxes.h"
32841: #include "nsCSSFrameConstructor.h"
 4302: #include "nsCSSRendering.h"
51757: #include "FrameLayerBuilder.h"
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsBidiPresUtils.h"
    1: #endif // IBMBIDI
    1: 
    1: #include "nsIDOMHTMLBodyElement.h"
    1: #include "nsIDOMHTMLHtmlElement.h"
    1: 
    1: static const int MIN_LINES_NEEDING_CURSOR = 20;
    1: 
16580: #define DISABLE_FLOAT_BREAKING_IN_COLUMNS
16580: 
39965: using namespace mozilla;
39965: 
    1: #ifdef DEBUG
    1: #include "nsPrintfCString.h"
    1: #include "nsBlockDebugFlags.h"
    1: 
    1: PRBool nsBlockFrame::gLamePaintMetrics;
    1: PRBool nsBlockFrame::gLameReflowMetrics;
    1: PRBool nsBlockFrame::gNoisy;
    1: PRBool nsBlockFrame::gNoisyDamageRepair;
    1: PRBool nsBlockFrame::gNoisyIntrinsic;
    1: PRBool nsBlockFrame::gNoisyReflow;
    1: PRBool nsBlockFrame::gReallyNoisyReflow;
23305: PRBool nsBlockFrame::gNoisyFloatManager;
    1: PRBool nsBlockFrame::gVerifyLines;
    1: PRBool nsBlockFrame::gDisableResizeOpt;
    1: 
    1: PRInt32 nsBlockFrame::gNoiseIndent;
    1: 
    1: struct BlockDebugFlags {
    1:   const char* name;
    1:   PRBool* on;
    1: };
    1: 
    1: static const BlockDebugFlags gFlags[] = {
    1:   { "reflow", &nsBlockFrame::gNoisyReflow },
    1:   { "really-noisy-reflow", &nsBlockFrame::gReallyNoisyReflow },
    1:   { "intrinsic", &nsBlockFrame::gNoisyIntrinsic },
23305:   { "float-manager", &nsBlockFrame::gNoisyFloatManager },
    1:   { "verify-lines", &nsBlockFrame::gVerifyLines },
    1:   { "damage-repair", &nsBlockFrame::gNoisyDamageRepair },
    1:   { "lame-paint-metrics", &nsBlockFrame::gLamePaintMetrics },
    1:   { "lame-reflow-metrics", &nsBlockFrame::gLameReflowMetrics },
    1:   { "disable-resize-opt", &nsBlockFrame::gDisableResizeOpt },
    1: };
    1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
    1: 
    1: static void
    1: ShowDebugFlags()
    1: {
    1:   printf("Here are the available GECKO_BLOCK_DEBUG_FLAGS:\n");
    1:   const BlockDebugFlags* bdf = gFlags;
    1:   const BlockDebugFlags* end = gFlags + NUM_DEBUG_FLAGS;
    1:   for (; bdf < end; bdf++) {
    1:     printf("  %s\n", bdf->name);
    1:   }
    1:   printf("Note: GECKO_BLOCK_DEBUG_FLAGS is a comma separated list of flag\n");
    1:   printf("names (no whitespace)\n");
    1: }
    1: 
    1: void
    1: nsBlockFrame::InitDebugFlags()
    1: {
    1:   static PRBool firstTime = PR_TRUE;
    1:   if (firstTime) {
    1:     firstTime = PR_FALSE;
    1:     char* flags = PR_GetEnv("GECKO_BLOCK_DEBUG_FLAGS");
    1:     if (flags) {
    1:       PRBool error = PR_FALSE;
    1:       for (;;) {
    1:         char* cm = PL_strchr(flags, ',');
    1:         if (cm) *cm = '\0';
    1: 
    1:         PRBool found = PR_FALSE;
    1:         const BlockDebugFlags* bdf = gFlags;
    1:         const BlockDebugFlags* end = gFlags + NUM_DEBUG_FLAGS;
    1:         for (; bdf < end; bdf++) {
    1:           if (PL_strcasecmp(bdf->name, flags) == 0) {
    1:             *(bdf->on) = PR_TRUE;
    1:             printf("nsBlockFrame: setting %s debug flag on\n", bdf->name);
    1:             gNoisy = PR_TRUE;
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:         }
    1:         if (!found) {
    1:           error = PR_TRUE;
    1:         }
    1: 
    1:         if (!cm) break;
    1:         *cm = ',';
    1:         flags = cm + 1;
    1:       }
    1:       if (error) {
    1:         ShowDebugFlags();
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: #endif
    1: 
    1: // add in a sanity check for absurdly deep frame trees.  See bug 42138
    1: // can't just use IsFrameTreeTooDeep() because that method has side effects we don't want
    1: #define MAX_DEPTH_FOR_LIST_RENUMBERING 200  // 200 open displayable tags is pretty unrealistic
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Debugging support code
    1: 
    1: #ifdef DEBUG
    1: const char* nsBlockFrame::kReflowCommandType[] = {
    1:   "ContentChanged",
    1:   "StyleChanged",
    1:   "ReflowDirty",
    1:   "Timeout",
    1:   "UserDefined",
    1: };
    1: #endif
    1: 
    1: #ifdef REALLY_NOISY_FIRST_LINE
    1: static void
    1: DumpStyleGeneaology(nsIFrame* aFrame, const char* gap)
    1: {
    1:   fputs(gap, stdout);
    1:   nsFrame::ListTag(stdout, aFrame);
    1:   printf(": ");
    1:   nsStyleContext* sc = aFrame->GetStyleContext();
    1:   while (nsnull != sc) {
    1:     nsStyleContext* psc;
    1:     printf("%p ", sc);
    1:     psc = sc->GetParent();
    1:     sc = psc;
    1:   }
    1:   printf("\n");
    1: }
    1: #endif
    1: 
    1: #ifdef REFLOW_STATUS_COVERAGE
    1: static void
    1: RecordReflowStatus(PRBool aChildIsBlock, nsReflowStatus aFrameReflowStatus)
    1: {
    1:   static PRUint32 record[2];
    1: 
    1:   // 0: child-is-block
    1:   // 1: child-is-inline
    1:   PRIntn index = 0;
    1:   if (!aChildIsBlock) index |= 1;
    1: 
    1:   // Compute new status
    1:   PRUint32 newS = record[index];
    1:   if (NS_INLINE_IS_BREAK(aFrameReflowStatus)) {
    1:     if (NS_INLINE_IS_BREAK_BEFORE(aFrameReflowStatus)) {
    1:       newS |= 1;
    1:     }
    1:     else if (NS_FRAME_IS_NOT_COMPLETE(aFrameReflowStatus)) {
    1:       newS |= 2;
    1:     }
    1:     else {
    1:       newS |= 4;
    1:     }
    1:   }
    1:   else if (NS_FRAME_IS_NOT_COMPLETE(aFrameReflowStatus)) {
    1:     newS |= 8;
    1:   }
    1:   else {
    1:     newS |= 16;
    1:   }
    1: 
    1:   // Log updates to the status that yield different values
    1:   if (record[index] != newS) {
    1:     record[index] = newS;
    1:     printf("record(%d): %02x %02x\n", index, record[0], record[1]);
    1:   }
    1: }
    1: #endif
    1: 
39965: // Destructor function for the overflowLines frame property
39965: static void
39965: DestroyOverflowLines(void* aPropertyValue)
39965: {
39965:   NS_ERROR("Overflow lines should never be destroyed by the FramePropertyTable");
39965: }
39965: 
39965: NS_DECLARE_FRAME_PROPERTY(LineCursorProperty, nsnull)
39965: NS_DECLARE_FRAME_PROPERTY(OverflowLinesProperty, DestroyOverflowLines)
39965: NS_DECLARE_FRAME_PROPERTY(OverflowOutOfFlowsProperty,
39965:                           nsContainerFrame::DestroyFrameList)
39965: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsIFrame*
    1: NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags)
    1: {
    1:   nsBlockFrame* it = new (aPresShell) nsBlockFrame(aContext);
    1:   if (it) {
    1:     it->SetFlags(aFlags);
    1:   }
    1:   return it;
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsBlockFrame)
32423: 
    1: nsBlockFrame::~nsBlockFrame()
    1: {
    1: }
    1: 
    1: void
36647: nsBlockFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
36647:   mAbsoluteContainer.DestroyFrames(this, aDestructRoot);
    1:   // Outside bullets are not in our child-list so check for them here
    1:   // and delete them when present.
    1:   if (mBullet && HaveOutsideBullet()) {
36647:     mBullet->DestroyFrom(aDestructRoot);
    1:     mBullet = nsnull;
    1:   }
    1: 
36647:   mFloats.DestroyFramesFrom(aDestructRoot);
    1: 
  238:   nsPresContext* presContext = PresContext();
    1: 
36647:   nsLineBox::DeleteLineList(presContext, mLines, aDestructRoot);
33276:   // Now clear mFrames, since we've destroyed all the frames in it.
33276:   mFrames.Clear();
    1: 
50892:   nsFrameList* pushedFloats = RemovePushedFloats();
50892:   if (pushedFloats) {
50892:     pushedFloats->DestroyFrom(aDestructRoot);
50892:   }
50892: 
    1:   // destroy overflow lines now
    1:   nsLineList* overflowLines = RemoveOverflowLines();
    1:   if (overflowLines) {
36647:     nsLineBox::DeleteLineList(presContext, *overflowLines, aDestructRoot);
33259:     delete overflowLines;
    1:   }
    1: 
    1:   {
    1:     nsAutoOOFFrameList oofs(this);
36647:     oofs.mList.DestroyFramesFrom(aDestructRoot);
    1:     // oofs is now empty and will remove the frame list property
    1:   }
    1: 
36647:   nsBlockFrameSuper::DestroyFrom(aDestructRoot);
    1: }
    1: 
21112: /* virtual */ nsILineIterator*
21112: nsBlockFrame::GetLineIterator()
21112: {
21112:   nsLineIterator* it = new nsLineIterator;
21112:   if (!it)
21112:     return nsnull;
21112: 
21112:   const nsStyleVisibility* visibility = GetStyleVisibility();
21112:   nsresult rv = it->Init(mLines, visibility->mDirection == NS_STYLE_DIRECTION_RTL);
21112:   if (NS_FAILED(rv)) {
21112:     delete it;
21112:     return nsnull;
21112:   }
21112:   return it;
21112: }
21112: 
23554: NS_QUERYFRAME_HEAD(nsBlockFrame)
23554:   NS_QUERYFRAME_ENTRY(nsBlockFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBlockFrameSuper)
    1: 
    1: nsSplittableType
    1: nsBlockFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_SPLITTABLE_NON_RECTANGULAR;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_METHOD
    1: nsBlockFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
    1:   fprintf(out, " [parent=%p]", mParent);
    1: #endif
    1:   if (HasView()) {
 3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
    1:   }
32845:   if (GetNextSibling()) {
32845:     fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
    1:   }
    1: 
    1:   // Output the flow linkage
    1:   if (nsnull != GetPrevInFlow()) {
 3233:     fprintf(out, " prev-in-flow=%p", static_cast<void*>(GetPrevInFlow()));
    1:   }
    1:   if (nsnull != GetNextInFlow()) {
 3233:     fprintf(out, " next-in-flow=%p", static_cast<void*>(GetNextInFlow()));
    1:   }
    1: 
39965:   void* IBsibling = Properties().Get(IBSplitSpecialSibling());
34444:   if (IBsibling) {
34444:     fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
34444:   }
39965:   void* IBprevsibling = Properties().Get(IBSplitSpecialPrevSibling());
34444:   if (IBprevsibling) {
34444:     fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
34444:   }
34444: 
34444:   if (nsnull != mContent) {
34444:     fprintf(out, " [content=%p]", static_cast<void*>(mContent));
34444:   }
34444: 
    1:   // Output the rect and state
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
43479:     fprintf(out, " [state=%016llx]", mState);
    1:   }
 3233:   nsBlockFrame* f = const_cast<nsBlockFrame*>(this);
26950:   if (f->HasOverflowRect()) {
11909:     nsRect overflowArea = f->GetOverflowRect();
11909:     fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
11909:             overflowArea.width, overflowArea.height);
    1:   }
    1:   PRInt32 numInlineLines = 0;
    1:   PRInt32 numBlockLines = 0;
    1:   if (!mLines.empty()) {
20350:     const_line_iterator line = begin_lines(), line_end = end_lines();
20350:     for ( ; line != line_end; ++line) {
    1:       if (line->IsBlock())
    1:         numBlockLines++;
    1:       else
    1:         numInlineLines++;
    1:     }
    1:   }
    1:   fprintf(out, " sc=%p(i=%d,b=%d)",
 3233:           static_cast<void*>(mStyleContext), numInlineLines, numBlockLines);
34387:   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
    1:   if (pseudoTag) {
    1:     nsAutoString atomString;
    1:     pseudoTag->ToString(atomString);
    1:     fprintf(out, " pst=%s",
    1:             NS_LossyConvertUTF16toASCII(atomString).get());
    1:   }
    1:   fputs("<\n", out);
    1: 
    1:   aIndent++;
    1: 
    1:   // Output the lines
    1:   if (!mLines.empty()) {
20350:     const_line_iterator line = begin_lines(), line_end = end_lines();
20350:     for ( ; line != line_end; ++line) {
    1:       line->List(out, aIndent);
    1:     }
    1:   }
    1: 
20350:   // Output the overflow lines.
20350:   const nsLineList* overflowLines = GetOverflowLines();
20350:   if (overflowLines && !overflowLines->empty()) {
20350:     IndentBy(out, aIndent);
20350:     fputs("Overflow-lines<\n", out);
23483:     const_line_iterator line = overflowLines->begin(),
23483:                         line_end = overflowLines->end();
20350:     for ( ; line != line_end; ++line) {
20350:       line->List(out, aIndent + 1);
20350:     }
20350:     IndentBy(out, aIndent);
20350:     fputs(">\n", out);
20350:   }
20350: 
    1:   nsIAtom* listName = nsnull;
    1:   PRInt32 listIndex = 0;
    1:   for (;;) {
    1:     listName = GetAdditionalChildListName(listIndex++);
20350:     if (nsGkAtoms::overflowList == listName) {
20350:       continue; // skip the overflow list - we printed the overflow lines above
20350:     }
    1:     if (nsnull == listName) {
    1:       break;
    1:     }
    1:     nsIFrame* kid = GetFirstChild(listName);
    1:     if (kid) {
    1:       IndentBy(out, aIndent);
    1:       nsAutoString tmp;
    1:       if (nsnull != listName) {
    1:         listName->ToString(tmp);
    1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
    1:       }
    1:       fputs("<\n", out);
    1:       while (kid) {
31709:         kid->List(out, aIndent + 1);
    1:         kid = kid->GetNextSibling();
    1:       }
    1:       IndentBy(out, aIndent);
    1:       fputs(">\n", out);
    1:     }
    1:   }
    1: 
    1:   aIndent--;
    1:   IndentBy(out, aIndent);
    1:   fputs(">\n", out);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsFrameState)
    1: nsBlockFrame::GetDebugStateBits() const
    1: {
    1:   // We don't want to include our cursor flag in the bits the
    1:   // regression tester looks at
    1:   return nsBlockFrameSuper::GetDebugStateBits() & ~NS_BLOCK_HAS_LINE_CURSOR;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Block"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsBlockFrame::GetType() const
    1: {
    1:   return nsGkAtoms::blockFrame;
    1: }
    1: 
    1: void
    1: nsBlockFrame::InvalidateInternal(const nsRect& aDamageRect,
    1:                                  nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                  PRUint32 aFlags)
    1: {
    1:   // Optimize by suppressing invalidation of areas that are clipped out
51893:   // with CSS 'clip'. Don't suppress invalidation of *this* frame directly,
51893:   // because when 'clip' shrinks we need to invalidate this frame and
51893:   // be able to invalidate areas outside the 'clip'.
51893:   if (aForChild) {
    1:     const nsStyleDisplay* disp = GetStyleDisplay();
    1:     nsRect absPosClipRect;
  462:     if (GetAbsPosClipRect(disp, &absPosClipRect, GetSize())) {
    1:       // Restrict the invalidated area to abs-pos clip rect
    1:       // abs-pos clipping clips everything in the frame
    1:       nsRect r;
    1:       if (r.IntersectRect(aDamageRect, absPosClipRect - nsPoint(aX, aY))) {
19380:         nsBlockFrameSuper::InvalidateInternal(r, aX, aY, this, aFlags);
    1:       }
    1:       return;
    1:     }
51893:   }
    1: 
19380:   nsBlockFrameSuper::InvalidateInternal(aDamageRect, aX, aY, this, aFlags);
    1: }
    1: 
    1: nscoord
    1: nsBlockFrame::GetBaseline() const
    1: {
 1158:   NS_ASSERTION(!NS_SUBTREE_DIRTY(this), "frame must not be dirty");
    1:   nscoord result;
    1:   if (nsLayoutUtils::GetLastLineBaseline(this, &result))
    1:     return result;
    1:   return nsFrame::GetBaseline();
    1: }
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // Child frame enumeration
    1: 
30783: nsFrameList
30783: nsBlockFrame::GetChildList(nsIAtom* aListName) const
    1: {
 4205:   if (nsGkAtoms::absoluteList == aListName) {
30783:     return mAbsoluteContainer.GetChildList();
    1:   }
    1:   else if (nsnull == aListName) {
33276:     return mFrames;
    1:   }
    1:   else if (aListName == nsGkAtoms::overflowList) {
33276:     // XXXbz once we start using nsFrameList for our overflow list, we
33276:     // could switch GetChildList to returning a |const nsFrameList&|.
    1:     nsLineList* overflowLines = GetOverflowLines();
32846:     return overflowLines ? nsFrameList(overflowLines->front()->mFirstChild,
32846:                                        overflowLines->back()->LastChild())
32846:                          : nsFrameList::EmptyList();
    1:   }
    1:   else if (aListName == nsGkAtoms::overflowOutOfFlowList) {
33010:     const nsFrameList* list = GetOverflowOutOfFlows();
33010:     return list ? *list : nsFrameList::EmptyList();
    1:   }
50891:   else if (aListName == nsGkAtoms::pushedFloatsList) {
49010:     const nsFrameList* list = GetPushedFloats();
48990:     return list ? *list : nsFrameList::EmptyList();
48990:   }
    1:   else if (aListName == nsGkAtoms::floatList) {
30783:     return mFloats;
    1:   }
    1:   else if (aListName == nsGkAtoms::bulletList) {
32846:     return HaveOutsideBullet() ? nsFrameList(mBullet, mBullet)
32846:                                : nsFrameList::EmptyList();
 4006:   }
30783:   return nsContainerFrame::GetChildList(aListName);
 4006: }
 4006: 
 4006: #define NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX  (NS_CONTAINER_LIST_COUNT_INCL_OC + 0)
 4006: #define NS_BLOCK_FRAME_FLOAT_LIST_INDEX         (NS_CONTAINER_LIST_COUNT_INCL_OC + 1)
 4006: #define NS_BLOCK_FRAME_BULLET_LIST_INDEX        (NS_CONTAINER_LIST_COUNT_INCL_OC + 2)
 4006: #define NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX      (NS_CONTAINER_LIST_COUNT_INCL_OC + 3)
49010: #define NS_BLOCK_FRAME_PUSHED_FLOATS_LIST_INDEX (NS_CONTAINER_LIST_COUNT_INCL_OC + 4)
 4006: // If adding/removing lists, don't forget to update the count in nsBlockFrame.h
    1: 
    1: nsIAtom*
    1: nsBlockFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
 4006:   if (aIndex < NS_CONTAINER_LIST_COUNT_INCL_OC)
 4006:     return nsContainerFrame::GetAdditionalChildListName(aIndex);
 4006: 
    1:   switch (aIndex) {
    1:   case NS_BLOCK_FRAME_FLOAT_LIST_INDEX:
    1:     return nsGkAtoms::floatList;
    1:   case NS_BLOCK_FRAME_BULLET_LIST_INDEX:
    1:     return nsGkAtoms::bulletList;
    1:   case NS_BLOCK_FRAME_OVERFLOW_OOF_LIST_INDEX:
    1:     return nsGkAtoms::overflowOutOfFlowList;
    1:   case NS_BLOCK_FRAME_ABSOLUTE_LIST_INDEX:
 4205:     return nsGkAtoms::absoluteList;
49010:   case NS_BLOCK_FRAME_PUSHED_FLOATS_LIST_INDEX:
50891:     return nsGkAtoms::pushedFloatsList;
    1:   default:
    1:     return nsnull;
    1:   }
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsBlockFrame::IsContainingBlock() const
    1: {
15270:   // The block wrappers we use to wrap blocks inside inlines aren't
15270:   // described in the CSS spec.  We need to make them not be containing
15270:   // blocks for the cases where we care about the 'direction' property
15270:   // of an element's containing block.
15270:   // Since the parent of such a block is either a normal block or
15270:   // another such pseudo, this shouldn't cause anything bad to happen.
38904:   // Also the anonymous blocks inside table cells are not containing blocks.
34387:   nsIAtom *pseudoType = GetStyleContext()->GetPseudo();
15270:   return pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
38904:          pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock &&
38904:          pseudoType != nsCSSAnonBoxes::cellContent;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsBlockFrame::IsFloatContainingBlock() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: static void ReparentFrame(nsIFrame* aFrame, nsIFrame* aOldParent,
    1:                           nsIFrame* aNewParent) {
    1:   NS_ASSERTION(aOldParent == aFrame->GetParent(),
31974:                "Parent not consistent with expectations");
    1: 
    1:   aFrame->SetParent(aNewParent);
    1: 
    1:   // When pushing and pulling frames we need to check for whether any
    1:   // views need to be reparented
  238:   nsHTMLContainerFrame::ReparentFrameView(aFrame->PresContext(), aFrame,
    1:                                           aOldParent, aNewParent);
    1: }
    1:  
    1: //////////////////////////////////////////////////////////////////////
    1: // Frame structure methods
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: // Reflow methods
    1: 
    1: /* virtual */ void
    1: nsBlockFrame::MarkIntrinsicWidthsDirty()
    1: {
 5675:   nsBlockFrame* dirtyBlock = static_cast<nsBlockFrame*>(GetFirstContinuation());
 3786:   dirtyBlock->mMinWidth = NS_INTRINSIC_WIDTH_UNKNOWN;
 3786:   dirtyBlock->mPrefWidth = NS_INTRINSIC_WIDTH_UNKNOWN;
 6829:   if (!(GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)) {
 6829:     for (nsIFrame* frame = dirtyBlock; frame; 
 6829:          frame = frame->GetNextContinuation()) {
 6829:       frame->AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
 6829:     }
 6829:   }
    1: 
    1:   nsBlockFrameSuper::MarkIntrinsicWidthsDirty();
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsBlockFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
 3786:   nsIFrame* firstInFlow = GetFirstContinuation();
 3786:   if (firstInFlow != this)
 3786:     return firstInFlow->GetMinWidth(aRenderingContext);
 3786: 
    1:   DISPLAY_MIN_WIDTH(this, mMinWidth);
    1:   if (mMinWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
    1:     return mMinWidth;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyIntrinsic) {
    1:     IndentBy(stdout, gNoiseIndent);
    1:     ListTag(stdout);
    1:     printf(": GetMinWidth\n");
    1:   }
10895:   AutoNoisyIndenter indenter(gNoisyIntrinsic);
    1: #endif
    1: 
 6829:   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
 5590:     ResolveBidi();
    1:   InlineMinWidthData data;
 3786:   for (nsBlockFrame* curFrame = this; curFrame;
 5675:        curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
 3786:     for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
 2668:       line != line_end; ++line)
    1:     {
    1: #ifdef DEBUG
    1:       if (gNoisyIntrinsic) {
    1:         IndentBy(stdout, gNoiseIndent);
 2668:         printf("line (%s%s)\n",
    1:                line->IsBlock() ? "block" : "inline",
    1:                line->IsEmpty() ? ", empty" : "");
    1:       }
    1:       AutoNoisyIndenter lineindent(gNoisyIntrinsic);
    1: #endif
    1:       if (line->IsBlock()) {
 2668:         data.ForceBreak(aRenderingContext);
    1:         data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
    1:                         line->mFirstChild, nsLayoutUtils::MIN_WIDTH);
 2668:         data.ForceBreak(aRenderingContext);
    1:       } else {
 8006:         if (!curFrame->GetPrevContinuation() &&
 8006:             line == curFrame->begin_lines()) {
51778:           // Only add text-indent if it has no percentages; using a
51778:           // percentage basis of 0 unconditionally would give strange
51778:           // behavior for calc(10%-3px).
 2668:           const nsStyleCoord &indent = GetStyleText()->mTextIndent;
51778:           if (indent.ConvertsToLength())
51778:             data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
 2668:         }
 2668:         // XXX Bug NNNNNN Should probably handle percentage text-indent.
    1: 
 6029:         data.line = &line;
24819:         data.lineContainer = curFrame;
    1:         nsIFrame *kid = line->mFirstChild;
    1:         for (PRInt32 i = 0, i_end = line->GetChildCount(); i != i_end;
    1:              ++i, kid = kid->GetNextSibling()) {
    1:           kid->AddInlineMinWidth(aRenderingContext, &data);
    1:         }
    1:       }
    1: #ifdef DEBUG
    1:       if (gNoisyIntrinsic) {
    1:         IndentBy(stdout, gNoiseIndent);
    1:         printf("min: [prevLines=%d currentLine=%d]\n",
    1:                data.prevLines, data.currentLine);
    1:       }
    1: #endif
    1:     }
 3786:   }
 2668:   data.ForceBreak(aRenderingContext);
    1: 
    1:   mMinWidth = data.prevLines;
    1:   return mMinWidth;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsBlockFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
 3786:   nsIFrame* firstInFlow = GetFirstContinuation();
 3786:   if (firstInFlow != this)
 3786:     return firstInFlow->GetPrefWidth(aRenderingContext);
 3786: 
    1:   DISPLAY_PREF_WIDTH(this, mPrefWidth);
 3786: 
    1:   if (mPrefWidth != NS_INTRINSIC_WIDTH_UNKNOWN)
    1:     return mPrefWidth;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyIntrinsic) {
    1:     IndentBy(stdout, gNoiseIndent);
    1:     ListTag(stdout);
    1:     printf(": GetPrefWidth\n");
    1:   }
10895:   AutoNoisyIndenter indenter(gNoisyIntrinsic);
    1: #endif
    1: 
 6829:   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
 5590:     ResolveBidi();
    1:   InlinePrefWidthData data;
 3786:   for (nsBlockFrame* curFrame = this; curFrame;
 5675:        curFrame = static_cast<nsBlockFrame*>(curFrame->GetNextContinuation())) {
 3786:     for (line_iterator line = curFrame->begin_lines(), line_end = curFrame->end_lines();
 2668:          line != line_end; ++line)
    1:     {
    1: #ifdef DEBUG
    1:       if (gNoisyIntrinsic) {
    1:         IndentBy(stdout, gNoiseIndent);
 2668:         printf("line (%s%s)\n",
    1:                line->IsBlock() ? "block" : "inline",
    1:                line->IsEmpty() ? ", empty" : "");
    1:       }
    1:       AutoNoisyIndenter lineindent(gNoisyIntrinsic);
    1: #endif
    1:       if (line->IsBlock()) {
 2668:         data.ForceBreak(aRenderingContext);
    1:         data.currentLine = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
    1:                         line->mFirstChild, nsLayoutUtils::PREF_WIDTH);
 2668:         data.ForceBreak(aRenderingContext);
    1:       } else {
 8006:         if (!curFrame->GetPrevContinuation() &&
 8006:             line == curFrame->begin_lines()) {
51778:           // Only add text-indent if it has no percentages; using a
51778:           // percentage basis of 0 unconditionally would give strange
51778:           // behavior for calc(10%-3px).
 2668:           const nsStyleCoord &indent = GetStyleText()->mTextIndent;
51778:           if (indent.ConvertsToLength())
51778:             data.currentLine += nsRuleNode::ComputeCoordPercentCalc(indent, 0);
 2668:         }
 2668:         // XXX Bug NNNNNN Should probably handle percentage text-indent.
    1: 
 6029:         data.line = &line;
24819:         data.lineContainer = curFrame;
    1:         nsIFrame *kid = line->mFirstChild;
    1:         for (PRInt32 i = 0, i_end = line->GetChildCount(); i != i_end;
    1:              ++i, kid = kid->GetNextSibling()) {
    1:           kid->AddInlinePrefWidth(aRenderingContext, &data);
    1:         }
    1:       }
    1: #ifdef DEBUG
    1:       if (gNoisyIntrinsic) {
    1:         IndentBy(stdout, gNoiseIndent);
    1:         printf("pref: [prevLines=%d currentLine=%d]\n",
    1:                data.prevLines, data.currentLine);
    1:       }
    1: #endif
    1:     }
 3786:   }
 2668:   data.ForceBreak(aRenderingContext);
    1: 
    1:   mPrefWidth = data.prevLines;
    1:   return mPrefWidth;
    1: }
    1: 
 6862: nsRect
 6862: nsBlockFrame::ComputeTightBounds(gfxContext* aContext) const
 6862: {
 6862:   // be conservative
 6862:   if (GetStyleContext()->HasTextDecorations())
 6862:     return GetOverflowRect();
 6862:   return ComputeSimpleTightBounds(aContext);
 6862: }
 6862: 
28638: static PRBool
28638: AvailableSpaceShrunk(const nsRect& aOldAvailableSpace,
28638:                      const nsRect& aNewAvailableSpace)
28638: {
28638:   if (aNewAvailableSpace.width == 0) {
28638:     // Positions are not significant if the width is zero.
28638:     return aOldAvailableSpace.width != 0;
28638:   }
28638:   NS_ASSERTION(aOldAvailableSpace.x <= aNewAvailableSpace.x &&
28638:                aOldAvailableSpace.XMost() >= aNewAvailableSpace.XMost(),
28638:                "available space should never grow");
28638:   return aOldAvailableSpace.width != aNewAvailableSpace.width;
28638: }
28638: 
    1: static nsSize
    1: CalculateContainingBlockSizeForAbsolutes(const nsHTMLReflowState& aReflowState,
    1:                                          nsSize aFrameSize)
    1: {
    1:   // The issue here is that for a 'height' of 'auto' the reflow state
    1:   // code won't know how to calculate the containing block height
    1:   // because it's calculated bottom up. So we use our own computed
 8731:   // size as the dimensions.
    1:   nsIFrame* frame = aReflowState.frame;
    1: 
    1:   nsSize cbSize(aFrameSize);
    1:     // Containing block is relative to the padding edge
16011:   const nsMargin& border =
16011:     aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
16011:   cbSize.width -= border.LeftRight();
16011:   cbSize.height -= border.TopBottom();
    1: 
18953:   if (frame->GetParent()->GetContent() == frame->GetContent() &&
18953:       frame->GetParent()->GetType() != nsGkAtoms::canvasFrame) {
18953:     // We are a wrapped frame for the content (and the wrapper is not the
18953:     // canvas frame, whose size is not meaningful here).
18953:     // Use the container's dimensions, if they have been precomputed.
    1:     // XXX This is a hack! We really should be waiting until the outermost
    1:     // frame is fully reflowed and using the resulting dimensions, even
    1:     // if they're intrinsic.
    1:     // In fact we should be attaching absolute children to the outermost
    1:     // frame and not always sticking them in block frames.
    1: 
    1:     // First, find the reflow state for the outermost frame for this
    1:     // content.
    1:     const nsHTMLReflowState* aLastRS = &aReflowState;
    1:     const nsHTMLReflowState* lastButOneRS = &aReflowState;
    1:     while (aLastRS->parentReflowState &&
    1:            aLastRS->parentReflowState->frame->GetContent() == frame->GetContent()) {
    1:       lastButOneRS = aLastRS;
    1:       aLastRS = aLastRS->parentReflowState;
    1:     }
    1:     if (aLastRS != &aReflowState) {
    1:       // Scrollbars need to be specifically excluded, if present, because they are outside the
    1:       // padding-edge. We need better APIs for getting the various boxes from a frame.
23554:       nsIScrollableFrame* scrollFrame = do_QueryFrame(aLastRS->frame);
    1:       nsMargin scrollbars(0,0,0,0);
    1:       if (scrollFrame) {
14159:         scrollbars =
14159:           scrollFrame->GetDesiredScrollbarSizes(aLastRS->frame->PresContext(),
    1:                                                 aLastRS->rendContext);
 8731:         if (!lastButOneRS->mFlags.mAssumingHScrollbar) {
    1:           scrollbars.top = scrollbars.bottom = 0;
 8731:         }
    1:         if (!lastButOneRS->mFlags.mAssumingVScrollbar) {
    1:           scrollbars.left = scrollbars.right = 0;
    1:         }
    1:       }
    1:       // We found a reflow state for the outermost wrapping frame, so use
    1:       // its computed metrics if available
18953:       if (aLastRS->ComputedWidth() != NS_UNCONSTRAINEDSIZE) {
32531:         cbSize.width = NS_MAX(0,
    1:           aLastRS->ComputedWidth() + aLastRS->mComputedPadding.LeftRight() - scrollbars.LeftRight());
    1:       }
 4166:       if (aLastRS->ComputedHeight() != NS_UNCONSTRAINEDSIZE) {
32531:         cbSize.height = NS_MAX(0,
 4166:           aLastRS->ComputedHeight() + aLastRS->mComputedPadding.TopBottom() - scrollbars.TopBottom());
    1:       }
    1:     }
    1:   }
    1: 
    1:   return cbSize;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::Reflow(nsPresContext*           aPresContext,
    1:                      nsHTMLReflowMetrics&     aMetrics,
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsBlockFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     IndentBy(stdout, gNoiseIndent);
    1:     ListTag(stdout);
    1:     printf(": begin reflow availSize=%d,%d computedSize=%d,%d\n",
    1:            aReflowState.availableWidth, aReflowState.availableHeight,
 4166:            aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
    1:   }
    1:   AutoNoisyIndenter indent(gNoisy);
    1:   PRTime start = LL_ZERO; // Initialize these variablies to silence the compiler.
    1:   PRInt32 ctc = 0;        // We only use these if they are set (gLameReflowMetrics).
    1:   if (gLameReflowMetrics) {
    1:     start = PR_Now();
    1:     ctc = nsLineBox::GetCtorCount();
    1:   }
    1: #endif
    1: 
 8730:   // See comment below about oldSize. Use *only* for the
 8730:   // abs-pos-containing-block-size-change optimization!
    1:   nsSize oldSize = GetSize();
    1: 
23305:   // Should we create a float manager?
23305:   nsAutoFloatManager autoFloatManager(const_cast<nsHTMLReflowState &>(aReflowState));
23305: 
23305:   // XXXldb If we start storing the float manager in the frame rather
    1:   // than keeping it around only during reflow then we should create it
    1:   // only when there are actually floats to manage.  Otherwise things
    1:   // like tables will gain significant bloat.
23305:   PRBool needFloatManager = nsBlockFrame::BlockNeedsFloatManager(this);
23305:   if (needFloatManager)
23305:     autoFloatManager.CreateFloatManager(aPresContext);
    1: 
    1:   // OK, some lines may be reflowed. Blow away any saved line cursor because
    1:   // we may invalidate the nondecreasing combinedArea.y/yMost invariant,
    1:   // and we may even delete the line with the line cursor.
    1:   ClearLineCursor();
    1: 
    1:   if (IsFrameTreeTooDeep(aReflowState, aMetrics)) {
    1: #ifdef DEBUG_kipp
    1:     {
    1:       extern char* nsPresShell_ReflowStackPointerTop;
    1:       char marker;
    1:       char* newsp = (char*) &marker;
    1:       printf("XXX: frame tree is too deep; approx stack size = %d\n",
    1:              nsPresShell_ReflowStackPointerTop - newsp);
    1:     }
    1: #endif
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
32448:   PRBool marginRoot = BlockIsMarginRoot(this);
32448:   nsBlockReflowState state(aReflowState, aPresContext, this, aMetrics,
32448:                            marginRoot, marginRoot, needFloatManager);
32448: 
32448: #ifdef IBMBIDI
32448:   if (GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
32448:     static_cast<nsBlockFrame*>(GetFirstContinuation())->ResolveBidi();
32448: #endif // IBMBIDI
32448: 
32448:   if (RenumberLists(aPresContext)) {
32448:     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
32448:   }
32448: 
32448:   nsresult rv = NS_OK;
32448: 
32448:   // ALWAYS drain overflow. We never want to leave the previnflow's
32448:   // overflow lines hanging around; block reflow depends on the
32448:   // overflow line lists being cleared out between reflow passes.
32448:   DrainOverflowLines(state);
32448: 
29816:   // Handle paginated overflow (see nsContainerFrame.h)
32108:   nsRect ocBounds;
29816:   nsReflowStatus ocStatus = NS_FRAME_COMPLETE;
29816:   if (GetPrevInFlow()) {
32108:     ReflowOverflowContainerChildren(aPresContext, aReflowState, ocBounds, 0,
29816:                                     ocStatus);
29816:   }
29816: 
32448:   // Now that we're done cleaning up our overflow container lists, we can
32448:   // give |state| its nsOverflowContinuationTracker.
32448:   nsOverflowContinuationTracker tracker(aPresContext, this, PR_FALSE);
32448:   state.mOverflowTracker = &tracker;
32448: 
49010:   // Drain & handle pushed floats
49010:   DrainPushedFloats(state);
32108:   nsRect fcBounds;
32108:   nsReflowStatus fcStatus = NS_FRAME_COMPLETE;
49010:   rv = ReflowPushedFloats(state, fcBounds, fcStatus);
32108:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // If we're not dirty (which means we'll mark everything dirty later)
    1:   // and our width has changed, mark the lines dirty that we need to
    1:   // mark dirty for a resize reflow.
    1:   if (aReflowState.mFlags.mHResize)
    1:     PrepareResizeReflow(state);
    1: 
    1:   mState &= ~NS_FRAME_FIRST_REFLOW;
    1: 
    1:   // Now reflow...
    1:   rv = ReflowDirtyLines(state);
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "reflow dirty lines failed");
    1:   if (NS_FAILED(rv)) return rv;
    1: 
29816:   NS_MergeReflowStatusInto(&state.mReflowStatus, ocStatus);
32108:   NS_MergeReflowStatusInto(&state.mReflowStatus, fcStatus);
32108: 
32109:   // If we end in a BR with clear and affected floats continue,
32109:   // we need to continue, too.
32109:   if (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
32109:       NS_FRAME_IS_COMPLETE(state.mReflowStatus) &&
32109:       state.mFloatManager->ClearContinues(FindTrailingClear())) {
32109:     NS_FRAME_SET_INCOMPLETE(state.mReflowStatus);
32109:   }
32109: 
30231:   if (!NS_FRAME_IS_FULLY_COMPLETE(state.mReflowStatus)) {
49010:     if (GetOverflowLines() || GetPushedFloats()) {
    1:       state.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
    1:     }
    1: 
    1: #ifdef DEBUG_kipp
30231:     ListTag(stdout); printf(": block is not fully complete\n");
    1: #endif
    1:   }
    1: 
    1:   CheckFloats(state);
    1: 
    1:   // Place the "marker" (bullet) frame if it is placed next to a block
    1:   // child.
    1:   //
    1:   // According to the CSS2 spec, section 12.6.1, the "marker" box
    1:   // participates in the height calculation of the list-item box's
    1:   // first line box.
    1:   //
    1:   // There are exactly two places a bullet can be placed: near the
    1:   // first or second line. It's only placed on the second line in a
    1:   // rare case: an empty first line followed by a second line that
    1:   // contains a block (example: <LI>\n<P>... ). This is where
    1:   // the second case can happen.
11520:   if (mBullet && HaveOutsideBullet() && !mLines.empty() &&
11520:       (mLines.front()->IsBlock() ||
11520:        (0 == mLines.front()->mBounds.height &&
11520:         mLines.front() != mLines.back() &&
11520:         mLines.begin().next()->IsBlock()))) {
    1:     // Reflow the bullet
    1:     nsHTMLReflowMetrics metrics;
27100:     // XXX Use the entire line when we fix bug 25888.
27100:     nsLayoutUtils::LinePosition position;
27100:     PRBool havePosition = nsLayoutUtils::GetFirstLinePosition(this, &position);
27100:     nscoord lineTop = havePosition ? position.mTop
27100:                                    : aReflowState.mComputedBorderPadding.top;
27100:     ReflowBullet(state, metrics, lineTop);
32392:     NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,
32392:                  "empty bullet took up space");
32392: 
32392:     if (havePosition && !BulletIsEmpty()) {
 8602:       // We have some lines to align the bullet with.  
    1: 
    1:       // Doing the alignment using the baseline will also cater for
    1:       // bullets that are placed next to a child block (bug 92896)
    1:     
    1:       // Tall bullets won't look particularly nice here...
    1:       nsRect bbox = mBullet->GetRect();
27100:       bbox.y = position.mBaseline - metrics.ascent;
    1:       mBullet->SetRect(bbox);
    1:     }
 8602:     // Otherwise just leave the bullet where it is, up against our top padding.
 8602:   }
    1: 
    1:   // Compute our final size
23155:   nscoord bottomEdgeOfChildren;
23155:   ComputeFinalSize(aReflowState, state, aMetrics, &bottomEdgeOfChildren);
23155:   ComputeCombinedArea(aReflowState, aMetrics, bottomEdgeOfChildren);
 4006:   // Factor overflow container child bounds into the overflow area
32108:   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, ocBounds);
49010:   // Factor pushed float child bounds into the overflow area
32108:   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, fcBounds);
    1: 
    1:   // Let the absolutely positioned container reflow any absolutely positioned
    1:   // child frames that need to be reflowed, e.g., elements with a percentage
    1:   // based width/height
    1:   // We want to do this under either of two conditions:
    1:   //  1. If we didn't do the incremental reflow above.
    1:   //  2. If our size changed.
    1:   // Even though it's the padding edge that's the containing block, we
    1:   // can use our rect (the border edge) since if the border style
    1:   // changed, the reflow would have been targeted at us so we'd satisfy
    1:   // condition 1.
 8730:   // XXX checking oldSize is bogus, there are various reasons we might have
 8730:   // reflowed but our size might not have been changed to what we
 8730:   // asked for (e.g., we ended up being pushed to a new page)
 8730:   // When WillReflowAgainForClearance is true, we will reflow again without
 8730:   // resetting the size. Because of this, we must not reflow our abs-pos children
 8730:   // in that situation --- what we think is our "new size"
 8730:   // will not be our real new size. This also happens to be more efficient.
20511:   if (mAbsoluteContainer.HasAbsoluteFrames()) {
27993:     PRBool haveInterrupt = aPresContext->HasPendingInterrupt();
27993:     if (aReflowState.WillReflowAgainForClearance() ||
27993:         haveInterrupt) {
20511:       // Make sure that when we reflow again we'll actually reflow all the abs
27993:       // pos frames that might conceivably depend on our size (or all of them,
27993:       // if we're dirty right now and interrupted; in that case we also need
27993:       // to mark them all with NS_FRAME_IS_DIRTY).  Sadly, we can't do much
27993:       // better than that, because we don't really know what our size will be,
27993:       // and it might in fact not change on the followup reflow!
27993:       if (haveInterrupt && (GetStateBits() & NS_FRAME_IS_DIRTY)) {
27993:         mAbsoluteContainer.MarkAllFramesDirty();
27993:       } else {
20511:         mAbsoluteContainer.MarkSizeDependentFramesDirty();
27993:       }
20511:     } else {
    1:       nsRect childBounds;
20511:       nsSize containingBlockSize =
20511:         CalculateContainingBlockSizeForAbsolutes(aReflowState,
20511:                                                  nsSize(aMetrics.width,
20511:                                                         aMetrics.height));
    1: 
    1:       // Mark frames that depend on changes we just made to this frame as dirty:
    1:       // Now we can assume that the padding edge hasn't moved.
    1:       // We need to reflow the absolutes if one of them depends on
    1:       // its placeholder position, or the containing block size in a
    1:       // direction in which the containing block size might have
    1:       // changed.
    1:       PRBool cbWidthChanged = aMetrics.width != oldSize.width;
    1:       PRBool isRoot = !GetContent()->GetParent();
    1:       // If isRoot and we have auto height, then we are the initial
    1:       // containing block and the containing block height is the
    1:       // viewport height, which can't change during incremental
    1:       // reflow.
    1:       PRBool cbHeightChanged =
 4166:         !(isRoot && NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) &&
    1:         aMetrics.height != oldSize.height;
    1: 
    1:       rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState,
 6521:                                      state.mReflowStatus,
    1:                                      containingBlockSize.width,
 6528:                                      containingBlockSize.height, PR_TRUE,
    1:                                      cbWidthChanged, cbHeightChanged,
    1:                                      &childBounds);
    1: 
 3107:       //XXXfr Why isn't this rv (and others in this file) checked/returned?
 3107: 
    1:       // Factor the absolutely positioned child bounds into the overflow area
    1:       aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea, childBounds);
    1:     }
20511:   }
    1: 
    1:   // Determine if we need to repaint our border, background or outline
17140:   CheckInvalidateSizeChange(aMetrics);
    1: 
 1669:   FinishAndStoreOverflow(&aMetrics);
 1669: 
23305:   // Clear the float manager pointer in the block reflow state so we
    1:   // don't waste time translating the coordinate system back on a dead
23305:   // float manager.
23305:   if (needFloatManager)
23305:     state.mFloatManager = nsnull;
    1: 
    1:   aStatus = state.mReflowStatus;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     IndentBy(stdout, gNoiseIndent);
    1:     ListTag(stdout);
    1:     printf(": status=%x (%scomplete) metrics=%d,%d carriedMargin=%d",
    1:            aStatus, NS_FRAME_IS_COMPLETE(aStatus) ? "" : "not ",
    1:            aMetrics.width, aMetrics.height,
    1:            aMetrics.mCarriedOutBottomMargin.get());
26950:     if (HasOverflowRect()) {
    1:       printf(" combinedArea={%d,%d,%d,%d}",
    1:              aMetrics.mOverflowArea.x,
    1:              aMetrics.mOverflowArea.y,
    1:              aMetrics.mOverflowArea.width,
    1:              aMetrics.mOverflowArea.height);
    1:     }
    1:     printf("\n");
    1:   }
    1: 
    1:   if (gLameReflowMetrics) {
    1:     PRTime end = PR_Now();
    1: 
    1:     PRInt32 ectc = nsLineBox::GetCtorCount();
    1:     PRInt32 numLines = mLines.size();
    1:     if (!numLines) numLines = 1;
    1:     PRTime delta, perLineDelta, lines;
    1:     LL_I2L(lines, numLines);
    1:     LL_SUB(delta, end, start);
    1:     LL_DIV(perLineDelta, delta, lines);
    1: 
    1:     ListTag(stdout);
    1:     char buf[400];
    1:     PR_snprintf(buf, sizeof(buf),
    1:                 ": %lld elapsed (%lld per line) (%d lines; %d new lines)",
    1:                 delta, perLineDelta, numLines, ectc - ctc);
    1:     printf("%s\n", buf);
    1:   }
    1: #endif
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return rv;
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::CheckForCollapsedBottomMarginFromClearanceLine()
    1: {
    1:   line_iterator begin = begin_lines();
    1:   line_iterator line = end_lines();
    1: 
    1:   while (PR_TRUE) {
    1:     if (begin == line) {
    1:       return PR_FALSE;
    1:     }
    1:     --line;
    1:     if (line->mBounds.height != 0 || !line->CachedIsEmpty()) {
    1:       return PR_FALSE;
    1:     }
    1:     if (line->HasClearance()) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   // not reached
    1: }
    1: 
    1: void
    1: nsBlockFrame::ComputeFinalSize(const nsHTMLReflowState& aReflowState,
    1:                                nsBlockReflowState&      aState,
23155:                                nsHTMLReflowMetrics&     aMetrics,
23155:                                nscoord*                 aBottomEdgeOfChildren)
    1: {
    1:   const nsMargin& borderPadding = aState.BorderPadding();
    1: #ifdef NOISY_FINAL_SIZE
    1:   ListTag(stdout);
    1:   printf(": mY=%d mIsBottomMarginRoot=%s mPrevBottomMargin=%d bp=%d,%d\n",
    1:          aState.mY, aState.GetFlag(BRS_ISBOTTOMMARGINROOT) ? "yes" : "no",
    1:          aState.mPrevBottomMargin,
    1:          borderPadding.top, borderPadding.bottom);
    1: #endif
    1: 
    1:   // Compute final width
40764:   aMetrics.width =
40764:     NSCoordSaturatingAdd(NSCoordSaturatingAdd(borderPadding.left,
40764:                                               aReflowState.ComputedWidth()), 
40764:                          borderPadding.right);
    1: 
    1:   // Return bottom margin information
    1:   // rbs says he hit this assertion occasionally (see bug 86947), so
    1:   // just set the margin to zero and we'll figure out why later
    1:   //NS_ASSERTION(aMetrics.mCarriedOutBottomMargin.IsZero(),
    1:   //             "someone else set the margin");
    1:   nscoord nonCarriedOutVerticalMargin = 0;
    1:   if (!aState.GetFlag(BRS_ISBOTTOMMARGINROOT)) {
    1:     // Apply rule from CSS 2.1 section 8.3.1. If we have some empty
    1:     // line with clearance and a non-zero top margin and all
    1:     // subsequent lines are empty, then we do not allow our children's
    1:     // carried out bottom margin to be carried out of us and collapse
    1:     // with our own bottom margin.
    1:     if (CheckForCollapsedBottomMarginFromClearanceLine()) {
    1:       // Convert the children's carried out margin to something that
    1:       // we will include in our height
    1:       nonCarriedOutVerticalMargin = aState.mPrevBottomMargin.get();
    1:       aState.mPrevBottomMargin.Zero();
    1:     }
    1:     aMetrics.mCarriedOutBottomMargin = aState.mPrevBottomMargin;
    1:   } else {
    1:     aMetrics.mCarriedOutBottomMargin.Zero();
    1:   }
    1: 
23155:   nscoord bottomEdgeOfChildren = aState.mY + nonCarriedOutVerticalMargin;
23155:   // Shrink wrap our height around our contents.
23155:   if (aState.GetFlag(BRS_ISBOTTOMMARGINROOT) ||
23155:       NS_UNCONSTRAINEDSIZE != aReflowState.ComputedHeight()) {
23155:     // When we are a bottom-margin root make sure that our last
23155:     // childs bottom margin is fully applied. We also do this when
23155:     // we have a computed height, since in that case the carried out
23155:     // margin is not going to be applied anywhere, so we should note it
23155:     // here to be included in the overflow area.
23155:     // Apply the margin only if there's space for it.
23155:     if (bottomEdgeOfChildren < aState.mReflowState.availableHeight)
23155:     {
23155:       // Truncate bottom margin if it doesn't fit to our available height.
23155:       bottomEdgeOfChildren =
32531:         NS_MIN(bottomEdgeOfChildren + aState.mPrevBottomMargin.get(),
23155:                aState.mReflowState.availableHeight);
23155:     }
23155:   }
23305:   if (aState.GetFlag(BRS_FLOAT_MGR)) {
23305:     // Include the float manager's state to properly account for the
23155:     // bottom margin of any floated elements; e.g., inside a table cell.
23155:     nscoord floatHeight =
48987:       aState.ClearFloats(bottomEdgeOfChildren, NS_STYLE_CLEAR_LEFT_AND_RIGHT,
48987:                          nsnull, nsFloatManager::DONT_CLEAR_PUSHED_FLOATS);
32531:     bottomEdgeOfChildren = NS_MAX(bottomEdgeOfChildren, floatHeight);
23155:   }
23155: 
    1:   // Compute final height
 4166:   if (NS_UNCONSTRAINEDSIZE != aReflowState.ComputedHeight()) {
    1:     // Figure out how much of the computed height should be
    1:     // applied to this frame.
 4166:     nscoord computedHeightLeftOver = aReflowState.ComputedHeight();
    1:     if (GetPrevInFlow()) {
    1:       // Reduce the height by the computed height of prev-in-flows.
    1:       for (nsIFrame* prev = GetPrevInFlow(); prev; prev = prev->GetPrevInFlow()) {
    1:         computedHeightLeftOver -= prev->GetRect().height;
    1:       }
    1:       // We just subtracted our top-border padding, since it was included in the
    1:       // first frame's height. Add it back to get the content height.
    1:       computedHeightLeftOver += aReflowState.mComputedBorderPadding.top;
    1:       // We may have stretched the frame beyond its computed height. Oh well.
32531:       computedHeightLeftOver = NS_MAX(0, computedHeightLeftOver);
    1:     }
 6521:     NS_ASSERTION(!( IS_TRUE_OVERFLOW_CONTAINER(this)
 4006:                     && computedHeightLeftOver ),
 4006:                  "overflow container must not have computedHeightLeftOver");
 4006: 
40764:     aMetrics.height =
40764:       NSCoordSaturatingAdd(NSCoordSaturatingAdd(borderPadding.top,
40764:                                                 computedHeightLeftOver),
40764:                            borderPadding.bottom);
40764: 
 4006:     if (NS_FRAME_IS_NOT_COMPLETE(aState.mReflowStatus)
 4006:         && aMetrics.height < aReflowState.availableHeight) {
 4006:       // We ran out of height on this page but we're incomplete
 4006:       // Set status to complete except for overflow
 4006:       NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
 4006:     }
    1: 
    1:     if (NS_FRAME_IS_COMPLETE(aState.mReflowStatus)) {
    1:       if (computedHeightLeftOver > 0 &&
 4279:           NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
    1:           aMetrics.height > aReflowState.availableHeight) {
    1:         // We don't fit and we consumed some of the computed height,
    1:         // so we should consume all the available height and then
    1:         // break.  If our bottom border/padding straddles the break
    1:         // point, then this will increase our height and push the
    1:         // border/padding to the next page/column.
32531:         aMetrics.height = NS_MAX(aReflowState.availableHeight,
 3045:                                  aState.mY + nonCarriedOutVerticalMargin);
 4006:         NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
 4006:         if (!GetNextInFlow())
 4006:           aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
    1:       }
    1:     }
    1:     else {
    1:       // Use the current height; continuations will take up the rest.
    1:       // Do extend the height to at least consume the available
    1:       // height, otherwise our left/right borders (for example) won't
    1:       // extend all the way to the break.
32531:       aMetrics.height = NS_MAX(aReflowState.availableHeight,
    1:                                aState.mY + nonCarriedOutVerticalMargin);
    1:       // ... but don't take up more height than is available
32531:       aMetrics.height = NS_MIN(aMetrics.height,
    1:                                borderPadding.top + computedHeightLeftOver);
    1:       // XXX It's pretty wrong that our bottom border still gets drawn on
    1:       // on its own on the last-in-flow, even if we ran out of height
    1:       // here. We need GetSkipSides to check whether we ran out of content
    1:       // height in the current frame, not whether it's last-in-flow.
    1:     }
    1: 
    1:     // Don't carry out a bottom margin when our height is fixed.
    1:     aMetrics.mCarriedOutBottomMargin.Zero();
    1:   }
10596:   else if (NS_FRAME_IS_COMPLETE(aState.mReflowStatus)) {
23155:     nscoord autoHeight = bottomEdgeOfChildren;
    1:     autoHeight -= borderPadding.top;
    1:     nscoord oldAutoHeight = autoHeight;
    1:     aReflowState.ApplyMinMaxConstraints(nsnull, &autoHeight);
    1:     if (autoHeight != oldAutoHeight) {
    1:       // Our min-height or max-height made our height change.  Don't carry out
    1:       // our kids' bottom margins.
    1:       aMetrics.mCarriedOutBottomMargin.Zero();
    1:     }
    1:     autoHeight += borderPadding.top + borderPadding.bottom;
    1:     aMetrics.height = autoHeight;
    1:   }
10596:   else {
10596:     NS_ASSERTION(aReflowState.availableHeight != NS_UNCONSTRAINEDSIZE,
10596:       "Shouldn't be incomplete if availableHeight is UNCONSTRAINED.");
32531:     aMetrics.height = NS_MAX(aState.mY, aReflowState.availableHeight);
11033:     if (aReflowState.availableHeight == NS_UNCONSTRAINEDSIZE)
11033:       // This should never happen, but it does. See bug 414255
11033:       aMetrics.height = aState.mY;
10596:   }
    1: 
 6521:   if (IS_TRUE_OVERFLOW_CONTAINER(this) &&
 6521:       NS_FRAME_IS_NOT_COMPLETE(aState.mReflowStatus)) {
 6521:     // Overflow containers can only be overflow complete.
 6521:     // Note that auto height overflow containers have no normal children
 6521:     NS_ASSERTION(aMetrics.height == 0, "overflow containers must be zero-height");
 6521:     NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
 6521:   }
 6521: 
21990:   // Screen out negative heights --- can happen due to integer overflows :-(
32531:   aMetrics.height = NS_MAX(0, aMetrics.height);
23155:   *aBottomEdgeOfChildren = bottomEdgeOfChildren;
21990: 
    1: #ifdef DEBUG_blocks
    1:   if (CRAZY_WIDTH(aMetrics.width) || CRAZY_HEIGHT(aMetrics.height)) {
    1:     ListTag(stdout);
    1:     printf(": WARNING: desired:%d,%d\n", aMetrics.width, aMetrics.height);
    1:   }
    1: #endif
    1: }
    1: 
    1: void
    1: nsBlockFrame::ComputeCombinedArea(const nsHTMLReflowState& aReflowState,
23155:                                   nsHTMLReflowMetrics&     aMetrics,
23155:                                   nscoord                  aBottomEdgeOfChildren)
    1: {
    1:   // Compute the combined area of our children
    1:   // XXX_perf: This can be done incrementally.  It is currently one of
    1:   // the things that makes incremental reflow O(N^2).
    1:   nsRect area(0, 0, aMetrics.width, aMetrics.height);
15339: 
    1:   if (NS_STYLE_OVERFLOW_CLIP != aReflowState.mStyleDisplay->mOverflowX) {
15339:     PRBool inQuirks = (PresContext()->CompatibilityMode() == eCompatibility_NavQuirks);
    1:     for (line_iterator line = begin_lines(), line_end = end_lines();
    1:          line != line_end;
    1:          ++line) {
15339: 
15339:       // Text-shadow overflows
15339:       if (!inQuirks && line->IsInline()) {
15339:         nsRect shadowRect = nsLayoutUtils::GetTextShadowRectsUnion(line->GetCombinedArea(),
15339:                                                                    this);
15339:         area.UnionRect(area, shadowRect);
15339:       }
15339: 
    1:       area.UnionRect(area, line->GetCombinedArea());
    1:     }
    1: 
    1:     // Factor the bullet in; normally the bullet will be factored into
    1:     // the line-box's combined area. However, if the line is a block
    1:     // line then it won't; if there are no lines, it won't. So just
    1:     // factor it in anyway (it can't hurt if it was already done).
    1:     // XXXldb Can we just fix GetCombinedArea instead?
    1:     if (mBullet) {
    1:       area.UnionRect(area, mBullet->GetRect());
    1:     }
23155: 
23155:     // Factor in the bottom edge of the children. Child frames
23155:     // will be added to the overflow area as we iterate through the lines,
23155:     // but their margins won't, so we need to account for bottom margins
23155:     // here. If we're a scrolled block then we also need to account
23155:     // for the scrollframe's padding, which is logically below the
23155:     // bottom margins of the children.
23155:     nscoord bottomEdgeOfContents = aBottomEdgeOfChildren;
34387:     if (GetStyleContext()->GetPseudo() == nsCSSAnonBoxes::scrolledContent) {
23155:       // We're a scrolled frame; the scrollframe's padding should be added
23155:       // to the bottom edge of the children
23155:       bottomEdgeOfContents += aReflowState.mComputedPadding.bottom;
23155:     }
32531:     area.height = NS_MAX(area.YMost(), bottomEdgeOfContents) - area.y;
    1:   }
    1: #ifdef NOISY_COMBINED_AREA
    1:   ListTag(stdout);
    1:   printf(": ca=%d,%d,%d,%d\n", area.x, area.y, area.width, area.height);
    1: #endif
    1: 
    1:   aMetrics.mOverflowArea = area;
    1: }
    1: 
    1: nsresult
20345: nsBlockFrame::MarkLineDirty(line_iterator aLine, const nsLineList* aLineList)
    1: {
    1:   // Mark aLine dirty
    1:   aLine->MarkDirty();
 7719:   aLine->SetInvalidateTextRuns(PR_TRUE);
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     IndentBy(stdout, gNoiseIndent);
    1:     ListTag(stdout);
 3233:     printf(": mark line %p dirty\n", static_cast<void*>(aLine.get()));
    1:   }
    1: #endif
    1: 
    1:   // Mark previous line dirty if it's an inline line so that it can
    1:   // maybe pullup something from the line just affected.
    1:   // XXX We don't need to do this if aPrevLine ends in a break-after...
20345:   if (aLine != (aLineList ? aLineList : &mLines)->front() &&
    1:       aLine->IsInline() &&
    1:       aLine.prev()->IsInline()) {
    1:     aLine.prev()->MarkDirty();
 7719:     aLine.prev()->SetInvalidateTextRuns(PR_TRUE);
    1: #ifdef DEBUG
    1:     if (gNoisyReflow) {
    1:       IndentBy(stdout, gNoiseIndent);
    1:       ListTag(stdout);
    1:       printf(": mark prev-line %p dirty\n",
 3233:              static_cast<void*>(aLine.prev().get()));
    1:     }
    1: #endif
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBlockFrame::PrepareResizeReflow(nsBlockReflowState& aState)
    1: {
    1:   const nsStyleText* styleText = GetStyleText();
    1:   // See if we can try and avoid marking all the lines as dirty
    1:   PRBool tryAndSkipLines =
    1:       // The text must be left-aligned.
    1:       (NS_STYLE_TEXT_ALIGN_LEFT == styleText->mTextAlign ||
    1:        (NS_STYLE_TEXT_ALIGN_DEFAULT == styleText->mTextAlign &&
    1:         NS_STYLE_DIRECTION_LTR ==
24696:           aState.mReflowState.mStyleVisibility->mDirection) ||
24696:        (NS_STYLE_TEXT_ALIGN_END == styleText->mTextAlign &&
24696:         NS_STYLE_DIRECTION_RTL ==
    1:           aState.mReflowState.mStyleVisibility->mDirection)) &&
    1:       // The left content-edge must be a constant distance from the left
    1:       // border-edge.
51776:       !GetStylePadding()->mPadding.GetLeft().HasPercent();
    1: 
    1: #ifdef DEBUG
    1:   if (gDisableResizeOpt) {
    1:     tryAndSkipLines = PR_FALSE;
    1:   }
    1:   if (gNoisyReflow) {
    1:     if (!tryAndSkipLines) {
    1:       IndentBy(stdout, gNoiseIndent);
    1:       ListTag(stdout);
    1:       printf(": marking all lines dirty: availWidth=%d textAlign=%d\n",
    1:              aState.mReflowState.availableWidth,
    1:              styleText->mTextAlign);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   if (tryAndSkipLines) {
    1:     nscoord newAvailWidth = aState.mReflowState.mComputedBorderPadding.left +
    1:                             aState.mReflowState.ComputedWidth();
    1:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mReflowState.mComputedBorderPadding.left &&
    1:                  NS_UNCONSTRAINEDSIZE != aState.mReflowState.ComputedWidth(),
    1:                  "math on NS_UNCONSTRAINEDSIZE");
    1: 
    1: #ifdef DEBUG
    1:     if (gNoisyReflow) {
    1:       IndentBy(stdout, gNoiseIndent);
    1:       ListTag(stdout);
    1:       printf(": trying to avoid marking all lines dirty\n");
    1:     }
    1: #endif
    1: 
    1:     for (line_iterator line = begin_lines(), line_end = end_lines();
    1:          line != line_end;
    1:          ++line)
    1:     {
    1:       // We let child blocks make their own decisions the same
    1:       // way we are here.
    1:       if (line->IsBlock() ||
    1:           line->HasFloats() ||
30231:           ((line != mLines.back() || GetNextInFlow()) // not the last line
30231:            && !line->HasBreakAfter()) ||
    1:           line->ResizeReflowOptimizationDisabled() ||
    1:           line->IsImpactedByFloat() ||
    1:           (line->mBounds.XMost() > newAvailWidth)) {
    1:         line->MarkDirty();
    1:       }
    1: 
    1: #ifdef REALLY_NOISY_REFLOW
    1:       if (!line->IsBlock()) {
    1:         printf("PrepareResizeReflow thinks line %p is %simpacted by floats\n", 
    1:                line.get(), line->IsImpactedByFloat() ? "" : "not ");
    1:       }
    1: #endif
    1: #ifdef DEBUG
    1:       if (gNoisyReflow && !line->IsDirty()) {
    1:         IndentBy(stdout, gNoiseIndent + 1);
    1:         printf("skipped: line=%p next=%p %s %s%s%s breakTypeBefore/After=%d/%d xmost=%d\n",
 3233:            static_cast<void*>(line.get()),
 3233:            static_cast<void*>((line.next() != end_lines() ? line.next().get() : nsnull)),
    1:            line->IsBlock() ? "block" : "inline",
    1:            line->HasBreakAfter() ? "has-break-after " : "",
    1:            line->HasFloats() ? "has-floats " : "",
    1:            line->IsImpactedByFloat() ? "impacted " : "",
    1:            line->GetBreakTypeBefore(), line->GetBreakTypeAfter(),
    1:            line->mBounds.XMost());
    1:       }
    1: #endif
    1:     }
    1:   }
    1:   else {
    1:     // Mark everything dirty
    1:     for (line_iterator line = begin_lines(), line_end = end_lines();
    1:          line != line_end;
    1:          ++line)
    1:     {
    1:       line->MarkDirty();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: /**
    1:  * Propagate reflow "damage" from from earlier lines to the current
    1:  * line.  The reflow damage comes from the following sources:
    1:  *  1. The regions of float damage remembered during reflow.
    1:  *  2. The combination of nonzero |aDeltaY| and any impact by a float,
    1:  *     either the previous reflow or now.
    1:  *
    1:  * When entering this function, |aLine| is still at its old position and
    1:  * |aDeltaY| indicates how much it will later be slid (assuming it
    1:  * doesn't get marked dirty and reflowed entirely).
    1:  */
    1: void
    1: nsBlockFrame::PropagateFloatDamage(nsBlockReflowState& aState,
    1:                                    nsLineBox* aLine,
    1:                                    nscoord aDeltaY)
    1: {
23305:   nsFloatManager *floatManager = aState.mReflowState.mFloatManager;
 4831:   NS_ASSERTION((aState.mReflowState.parentReflowState &&
23305:                 aState.mReflowState.parentReflowState->mFloatManager == floatManager) ||
 4831:                 aState.mReflowState.mBlockDelta == 0, "Bad block delta passed in");
 4831: 
 4831:   // Check to see if there are any floats; if there aren't, there can't
 4831:   // be any float damage
23305:   if (!floatManager->HasAnyFloats())
 4831:     return;
    1: 
    1:   // Check the damage region recorded in the float damage.
23305:   if (floatManager->HasFloatDamage()) {
 7668:     // Need to check mBounds *and* mCombinedArea to find intersections 
 7668:     // with aLine's floats
    1:     nscoord lineYA = aLine->mBounds.y + aDeltaY;
    1:     nscoord lineYB = lineYA + aLine->mBounds.height;
 7668:     nscoord lineYCombinedA = aLine->GetCombinedArea().y + aDeltaY;
 7668:     nscoord lineYCombinedB = lineYCombinedA + aLine->GetCombinedArea().height;
23305:     if (floatManager->IntersectsDamage(lineYA, lineYB) ||
23305:         floatManager->IntersectsDamage(lineYCombinedA, lineYCombinedB)) {
    1:       aLine->MarkDirty();
    1:       return;
    1:     }
    1:   }
    1: 
23305:   // Check if the line is moving relative to the float manager
 4831:   if (aDeltaY + aState.mReflowState.mBlockDelta != 0) {
 4831:     if (aLine->IsBlock()) {
 4831:       // Unconditionally reflow sliding blocks; we only really need to reflow
23305:       // if there's a float impacting this block, but the current float manager
 4831:       // makes it difficult to check that.  Therefore, we let the child block
 4831:       // decide what it needs to reflow.
 4831:       aLine->MarkDirty();
 4831:     } else {
    1:       PRBool wasImpactedByFloat = aLine->IsImpactedByFloat();
27106:       nsFlowAreaRect floatAvailableSpace =
28638:         aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y + aDeltaY,
28638:                                                aLine->mBounds.height,
28638:                                                nsnull);
 4831: 
    1: #ifdef REALLY_NOISY_REFLOW
    1:     printf("nsBlockFrame::PropagateFloatDamage %p was = %d, is=%d\n", 
27106:            this, wasImpactedByFloat, floatAvailableSpace.mHasFloats);
    1: #endif
 4831: 
 4831:       // Mark the line dirty if it was or is affected by a float
 4831:       // We actually only really need to reflow if the amount of impact
 4831:       // changes, but that's not straightforward to check
27106:       if (wasImpactedByFloat || floatAvailableSpace.mHasFloats) {
    1:         aLine->MarkDirty();
    1:       }
    1:     }
    1:   }
 4831: }
    1: 
    1: static void PlaceFrameView(nsIFrame* aFrame);
    1: 
    1: static PRBool LineHasClear(nsLineBox* aLine) {
10895:   return aLine->IsBlock()
10895:     ? (aLine->GetBreakTypeBefore() ||
10895:        (aLine->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN) ||
10895:        !nsBlockFrame::BlockCanIntersectFloats(aLine->mFirstChild))
10895:     : aLine->HasFloatBreakAfter();
    1: }
    1: 
    1: 
    1: /**
    1:  * Reparent a whole list of floats from aOldParent to this block.  The
    1:  * floats might be taken from aOldParent's overflow list. They will be
    1:  * removed from the list. They end up appended to our mFloats list.
    1:  */
    1: void
    1: nsBlockFrame::ReparentFloats(nsIFrame* aFirstFrame,
  686:                              nsBlockFrame* aOldParent, PRBool aFromOverflow,
  686:                              PRBool aReparentSiblings) {
    1:   nsFrameList list;
32843:   aOldParent->CollectFloats(aFirstFrame, list, aFromOverflow, aReparentSiblings);
    1:   if (list.NotEmpty()) {
    1:     for (nsIFrame* f = list.FirstChild(); f; f = f->GetNextSibling()) {
    1:       ReparentFrame(f, aOldParent, this);
    1:     }
32843:     mFloats.AppendFrames(nsnull, list);
    1:   }
    1: }
    1: 
    1: static void DumpLine(const nsBlockReflowState& aState, nsLineBox* aLine,
    1:                      nscoord aDeltaY, PRInt32 aDeltaIndent) {
    1: #ifdef DEBUG
    1:   if (nsBlockFrame::gNoisyReflow) {
    1:     nsRect lca(aLine->GetCombinedArea());
    1:     nsBlockFrame::IndentBy(stdout, nsBlockFrame::gNoiseIndent + aDeltaIndent);
    1:     printf("line=%p mY=%d dirty=%s oldBounds={%d,%d,%d,%d} oldCombinedArea={%d,%d,%d,%d} deltaY=%d mPrevBottomMargin=%d childCount=%d\n",
 3233:            static_cast<void*>(aLine), aState.mY,
    1:            aLine->IsDirty() ? "yes" : "no",
    1:            aLine->mBounds.x, aLine->mBounds.y,
    1:            aLine->mBounds.width, aLine->mBounds.height,
    1:            lca.x, lca.y, lca.width, lca.height,
    1:            aDeltaY, aState.mPrevBottomMargin.get(), aLine->GetChildCount());
    1:   }
    1: #endif
    1: }
    1: 
    1: /**
    1:  * Reflow the dirty lines
    1:  */
    1: nsresult
    1: nsBlockFrame::ReflowDirtyLines(nsBlockReflowState& aState)
    1: {
    1:   nsresult rv = NS_OK;
    1:   PRBool keepGoing = PR_TRUE;
    1:   PRBool repositionViews = PR_FALSE; // should we really need this?
32109:   PRBool foundAnyClears = aState.mFloatBreakType != NS_STYLE_CLEAR_NONE;
 8457:   PRBool willReflowAgain = PR_FALSE;
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     IndentBy(stdout, gNoiseIndent);
    1:     ListTag(stdout);
    1:     printf(": reflowing dirty lines");
    1:     printf(" computedWidth=%d\n", aState.mReflowState.ComputedWidth());
    1:   }
    1:   AutoNoisyIndenter indent(gNoisyReflow);
    1: #endif
    1: 
    1:   PRBool selfDirty = (GetStateBits() & NS_FRAME_IS_DIRTY) ||
    1:                      (aState.mReflowState.mFlags.mVResize &&
    1:                       (GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT));
    1: 
30044:   // Reflow our last line if our availableHeight has increased
30044:   // so that we (and our last child) pull up content as necessary
30044:   if (aState.mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE
30044:       && GetNextInFlow() && aState.mReflowState.availableHeight > mRect.height) {
30044:     line_iterator lastLine = end_lines();
30044:     if (lastLine != begin_lines()) {
30044:       --lastLine;
30044:       lastLine->MarkDirty();
30044:     }
30044:   }
    1:     // the amount by which we will slide the current line if it is not
    1:     // dirty
    1:   nscoord deltaY = 0;
    1: 
    1:     // whether we did NOT reflow the previous line and thus we need to
    1:     // recompute the carried out margin before the line if we want to
    1:     // reflow it or if its previous margin is dirty
    1:   PRBool needToRecoverState = PR_FALSE;
49010:     // Float continuations were reflowed in ReflowPushedFloats
48989:   PRBool reflowedFloat = mFloats.NotEmpty() &&
49010:     (mFloats.FirstChild()->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT);
    1:   PRBool lastLineMovedUp = PR_FALSE;
    1:   // We save up information about BR-clearance here
32109:   PRUint8 inlineFloatBreakType = aState.mFloatBreakType;
    1: 
    1:   line_iterator line = begin_lines(), line_end = end_lines();
    1: 
    1:   // Reflow the lines that are already ours
    1:   for ( ; line != line_end; ++line, aState.AdvanceToNextLine()) {
    1:     DumpLine(aState, line, deltaY, 0);
    1: #ifdef DEBUG
    1:     AutoNoisyIndenter indent2(gNoisyReflow);
    1: #endif
    1: 
    1:     if (selfDirty)
    1:       line->MarkDirty();
    1: 
    1:     // This really sucks, but we have to look inside any blocks that have clear
    1:     // elements inside them.
    1:     // XXX what can we do smarter here?
    1:     if (!line->IsDirty() && line->IsBlock() &&
    1:         (line->mFirstChild->GetStateBits() & NS_BLOCK_HAS_CLEAR_CHILDREN)) {
    1:       line->MarkDirty();
    1:     }
    1: 
14910:     nsIFrame *replacedBlock = nsnull;
10895:     if (line->IsBlock() &&
10895:         !nsBlockFrame::BlockCanIntersectFloats(line->mFirstChild)) {
14910:       replacedBlock = line->mFirstChild;
10895:     }
10895: 
    1:     // We have to reflow the line if it's a block whose clearance
    1:     // might have changed, so detect that.
10895:     if (!line->IsDirty() &&
10895:         (line->GetBreakTypeBefore() != NS_STYLE_CLEAR_NONE ||
14910:          replacedBlock)) {
    1:       nscoord curY = aState.mY;
    1:       // See where we would be after applying any clearance due to
    1:       // BRs.
    1:       if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
    1:         curY = aState.ClearFloats(curY, inlineFloatBreakType);
    1:       }
    1: 
10895:       nscoord newY =
14910:         aState.ClearFloats(curY, line->GetBreakTypeBefore(), replacedBlock);
    1:       
    1:       if (line->HasClearance()) {
    1:         // Reflow the line if it might not have clearance anymore.
    1:         if (newY == curY
    1:             // aState.mY is the clearance point which should be the
    1:             // top border-edge of the block frame. If sliding the
    1:             // block by deltaY isn't going to put it in the predicted
    1:             // position, then we'd better reflow the line.
    1:             || newY != line->mBounds.y + deltaY) {
    1:           line->MarkDirty();
    1:         }
    1:       } else {
    1:         // Reflow the line if the line might have clearance now.
    1:         if (curY != newY) {
    1:           line->MarkDirty();
    1:         }
    1:       }
    1:     }
    1: 
    1:     // We might have to reflow a line that is after a clearing BR.
    1:     if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
    1:       aState.mY = aState.ClearFloats(aState.mY, inlineFloatBreakType);
    1:       if (aState.mY != line->mBounds.y + deltaY) {
    1:         // SlideLine is not going to put the line where the clearance
    1:         // put it. Reflow the line to be sure.
    1:         line->MarkDirty();
    1:       }
    1:       inlineFloatBreakType = NS_STYLE_CLEAR_NONE;
    1:     }
    1: 
    1:     PRBool previousMarginWasDirty = line->IsPreviousMarginDirty();
    1:     if (previousMarginWasDirty) {
    1:       // If the previous margin is dirty, reflow the current line
    1:       line->MarkDirty();
    1:       line->ClearPreviousMarginDirty();
    1:     } else if (line->mBounds.YMost() + deltaY > aState.mBottomEdge) {
    1:       // Lines that aren't dirty but get slid past our height constraint must
    1:       // be reflowed.
    1:       line->MarkDirty();
    1:     }
    1: 
49002:     // If we have a constrained height (i.e., breaking columns/pages),
49002:     // and the distance to the bottom might have changed, then we need
49002:     // to reflow any line that might have floats in it, both because the
49002:     // breakpoints within those floats may have changed and because we
49002:     // might have to push/pull the floats in their entirety.
49002:     // FIXME: What about a deltaY or height change that forces us to
49002:     // push lines?  Why does that work?
49002:     if (!line->IsDirty() &&
49002:         aState.mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE &&
49002:         (deltaY != 0 || aState.mReflowState.mFlags.mVResize) &&
49002:         (line->IsBlock() || line->HasFloats() || line->HadFloatPushed())) {
49002:       line->MarkDirty();
49002:     }
49002: 
    1:     if (!line->IsDirty()) {
    1:       // See if there's any reflow damage that requires that we mark the
    1:       // line dirty.
    1:       PropagateFloatDamage(aState, line, deltaY);
    1:     }
    1: 
    1:     if (needToRecoverState && line->IsDirty()) {
    1:       // We need to reconstruct the bottom margin only if we didn't
    1:       // reflow the previous line and we do need to reflow (or repair
    1:       // the top position of) the next line.
    1:       aState.ReconstructMarginAbove(line);
    1:     }
    1: 
30638:     PRBool reflowedPrevLine = !needToRecoverState;
    1:     if (needToRecoverState) {
    1:       needToRecoverState = PR_FALSE;
    1: 
    1:       // Update aState.mPrevChild as if we had reflowed all of the frames in
    1:       // this line.  This is expensive in some cases, since it requires
    1:       // walking |GetNextSibling|.
    1:       if (line->IsDirty())
    1:         aState.mPrevChild = line.prev()->LastChild();
    1:     }
    1: 
    1:     // Now repair the line and update |aState.mY| by calling
    1:     // |ReflowLine| or |SlideLine|.
 8512:     // If we're going to reflow everything again, then no need to reflow
 8512:     // the dirty line ... unless the line has floats, in which case we'd
 8512:     // better reflow it now to refresh its float cache, which may contain
 8512:     // dangling frame pointers! Ugh! This reflow of the line may be
 8512:     // incorrect because we skipped reflowing previous lines (e.g., floats
 8512:     // may be placed incorrectly), but that's OK because we'll mark the
 8512:     // line dirty below under "if (aState.mReflowState.mDiscoveredClearance..."
 8512:     if (line->IsDirty() && (line->HasFloats() || !willReflowAgain)) {
    1:       lastLineMovedUp = PR_TRUE;
    1: 
    1:       PRBool maybeReflowingForFirstTime =
    1:         line->mBounds.x == 0 && line->mBounds.y == 0 &&
    1:         line->mBounds.width == 0 && line->mBounds.height == 0;
    1: 
    1:       // Compute the dirty lines "before" YMost, after factoring in
    1:       // the running deltaY value - the running value is implicit in
    1:       // aState.mY.
    1:       nscoord oldY = line->mBounds.y;
    1:       nscoord oldYMost = line->mBounds.YMost();
    1: 
 8730:       NS_ASSERTION(!willReflowAgain || !line->IsBlock(),
 8730:                    "Don't reflow blocks while willReflowAgain is true, reflow of block abs-pos children depends on this");
 8730: 
    1:       // Reflow the dirty line. If it's an incremental reflow, then force
    1:       // it to invalidate the dirty area if necessary
    1:       rv = ReflowLine(aState, line, &keepGoing);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8730:       if (aState.mReflowState.WillReflowAgainForClearance()) {
 8457:         line->MarkDirty();
 8457:         willReflowAgain = PR_TRUE;
 8512:         // Note that once we've entered this state, every line that gets here
 8512:         // (e.g. because it has floats) gets marked dirty and reflowed again.
 8512:         // in the next pass. This is important, see above.
 8457:       }
 8457: 
    1:       if (line->HasFloats()) {
    1:         reflowedFloat = PR_TRUE;
    1:       }
    1: 
    1:       if (!keepGoing) {
    1:         DumpLine(aState, line, deltaY, -1);
    1:         if (0 == line->GetChildCount()) {
    1:           DeleteLine(aState, line, line_end);
    1:         }
    1:         break;
    1:       }
    1: 
    1:       // Test to see whether the margin that should be carried out
    1:       // to the next line (NL) might have changed. In ReflowBlockFrame
    1:       // we call nextLine->MarkPreviousMarginDirty if the block's
    1:       // actual carried-out bottom margin changed. So here we only
    1:       // need to worry about the following effects:
    1:       // 1) the line was just created, and it might now be blocking
    1:       // a carried-out bottom margin from previous lines that
    1:       // used to reach NL from reaching NL
    1:       // 2) the line used to be empty, and is now not empty,
    1:       // thus blocking a carried-out bottom margin from previous lines
    1:       // that used to reach NL from reaching NL
    1:       // 3) the line wasn't empty, but now is, so a carried-out
    1:       // bottom margin from previous lines that didn't used to reach NL
    1:       // now does
    1:       // 4) the line might have changed in a way that affects NL's
    1:       // ShouldApplyTopMargin decision. The three things that matter
    1:       // are the line's emptiness, its adjacency to the top of the block,
    1:       // and whether it has clearance (the latter only matters if the block
    1:       // was and is adjacent to the top and empty).
    1:       //
    1:       // If the line is empty now, we can't reliably tell if the line was empty
    1:       // before, so we just assume it was and do nextLine->MarkPreviousMarginDirty.
    1:       // This means the checks in 4) are redundant; if the line is empty now
    1:       // we don't need to check 4), but if the line is not empty now and we're sure
    1:       // it wasn't empty before, any adjacency and clearance changes are irrelevant
    1:       // to the result of nextLine->ShouldApplyTopMargin.
    1:       if (line.next() != end_lines()) {
 8048:         PRBool maybeWasEmpty = oldY == line.next()->mBounds.y;
13052:         PRBool isEmpty = line->CachedIsEmpty();
    1:         if (maybeReflowingForFirstTime /*1*/ ||
    1:             (isEmpty || maybeWasEmpty) /*2/3/4*/) {
    1:           line.next()->MarkPreviousMarginDirty();
    1:           // since it's marked dirty, nobody will care about |deltaY|
    1:         }
    1:       }
    1: 
    1:       // If the line was just reflowed for the first time, then its
    1:       // old mBounds cannot be trusted so this deltaY computation is
    1:       // bogus. But that's OK because we just did
    1:       // MarkPreviousMarginDirty on the next line which will force it
    1:       // to be reflowed, so this computation of deltaY will not be
    1:       // used.
    1:       deltaY = line->mBounds.YMost() - oldYMost;
30901: 
30901:       // Now do an interrupt check. We want to do this only in the case when we
30901:       // actually reflow the line, so that if we get back in here we'll get
30901:       // further on the reflow before interrupting.
30901:       aState.mPresContext->CheckForInterrupt(this);
    1:     } else {
32448:       aState.mOverflowTracker->Skip(line->mFirstChild, aState.mReflowStatus);
 4006:         // Nop except for blocks (we don't create overflow container
 4006:         // continuations for any inlines atm), so only checking mFirstChild
 4006:         // is enough
 4006: 
    1:       lastLineMovedUp = deltaY < 0;
    1: 
    1:       if (deltaY != 0)
    1:         SlideLine(aState, line, deltaY);
    1:       else
    1:         repositionViews = PR_TRUE;
    1: 
 8558:       NS_ASSERTION(!line->IsDirty() || !line->HasFloats(),
 8558:                    "Possibly stale float cache here!");
 8627:       if (willReflowAgain && line->IsBlock()) {
 8627:         // If we're going to reflow everything again, and this line is a block,
 8627:         // then there is no need to recover float state. The line may contain
 8627:         // other lines with floats, but in that case RecoverStateFrom would only
23305:         // add floats to the float manager. We don't need to do that because
 8627:         // everything's going to get reflowed again "for real". Calling
 8627:         // RecoverStateFrom in this situation could be lethal because the
 8627:         // block's descendant lines may have float caches containing dangling
 8627:         // frame pointers. Ugh!
 8627:         // If this line is inline, then we need to recover its state now
 8627:         // to make sure that we don't forget to move its floats by deltaY.
 8512:       } else {
    1:         // XXX EVIL O(N^2) EVIL
    1:         aState.RecoverStateFrom(line, deltaY);
 8512:       }
    1: 
    1:       // Keep mY up to date in case we're propagating reflow damage
    1:       // and also because our final height may depend on it. If the
    1:       // line is inlines, then only update mY if the line is not
    1:       // empty, because that's what PlaceLine does. (Empty blocks may
    1:       // want to update mY, e.g. if they have clearance.)
    1:       if (line->IsBlock() || !line->CachedIsEmpty()) {
    1:         aState.mY = line->mBounds.YMost();
    1:       }
    1: 
    1:       needToRecoverState = PR_TRUE;
30638: 
30638:       if (reflowedPrevLine && !line->IsBlock() &&
30638:           aState.mPresContext->HasPendingInterrupt()) {
30638:         // Need to make sure to pull overflows from any prev-in-flows
30638:         for (nsIFrame* inlineKid = line->mFirstChild; inlineKid;
30638:              inlineKid = inlineKid->GetFirstChild(nsnull)) {
30638:           inlineKid->PullOverflowsFromPrevInFlow();
30638:         }
30638:       }
    1:     }
    1: 
    1:     // Record if we need to clear floats before reflowing the next
    1:     // line. Note that inlineFloatBreakType will be handled and
    1:     // cleared before the next line is processed, so there is no
    1:     // need to combine break types here.
    1:     if (line->HasFloatBreakAfter()) {
    1:       inlineFloatBreakType = line->GetBreakTypeAfter();
    1:     }
    1: 
    1:     if (LineHasClear(line.get())) {
    1:       foundAnyClears = PR_TRUE;
    1:     }
    1: 
    1:     DumpLine(aState, line, deltaY, -1);
27993: 
30901:     if (aState.mPresContext->HasPendingInterrupt()) {
27993:       willReflowAgain = PR_TRUE;
27993:       // Another option here might be to leave |line| clean if
27993:       // !HasPendingInterrupt() before the CheckForInterrupt() call, since in
27993:       // that case the line really did reflow as it should have.  Not sure
27993:       // whether that would be safe, so doing this for now instead.  Also not
27993:       // sure whether we really want to mark all lines dirty after an
27993:       // interrupt, but until we get better at propagating float damage we
27993:       // really do need to do it this way; see comments inside MarkLineDirty.
27993:       MarkLineDirtyForInterrupt(line);
27993:     }
    1:   }
    1: 
    1:   // Handle BR-clearance from the last line of the block
    1:   if (inlineFloatBreakType != NS_STYLE_CLEAR_NONE) {
    1:     aState.mY = aState.ClearFloats(aState.mY, inlineFloatBreakType);
    1:   }
    1: 
    1:   if (needToRecoverState) {
    1:     // Is this expensive?
    1:     aState.ReconstructMarginAbove(line);
    1: 
    1:     // Update aState.mPrevChild as if we had reflowed all of the frames in
    1:     // the last line.  This is expensive in some cases, since it requires
    1:     // walking |GetNextSibling|.
    1:     aState.mPrevChild = line.prev()->LastChild();
    1:   }
    1: 
    1:   // Should we really have to do this?
    1:   if (repositionViews)
    1:     ::PlaceFrameView(this);
    1: 
27993:   // We can skip trying to pull up the next line if our height is constrained
27993:   // (so we can report being incomplete) and there is no next in flow or we
27993:   // were told not to or we know it will be futile, i.e.,
    1:   // -- the next in flow is not changing
    1:   // -- and we cannot have added more space for its first line to be
    1:   // pulled up into,
    1:   // -- it's an incremental reflow of a descendant
    1:   // -- and we didn't reflow any floats (so the available space
    1:   // didn't change)
 6260:   // -- my chain of next-in-flows either has no first line, or its first
 6260:   // line isn't dirty.
27993:   PRBool heightConstrained =
27993:     aState.mReflowState.availableHeight != NS_UNCONSTRAINEDSIZE;
27993:   PRBool skipPull = willReflowAgain && heightConstrained;
27993:   if (!skipPull && heightConstrained && aState.mNextInFlow &&
    1:       (aState.mReflowState.mFlags.mNextInFlowUntouched &&
    1:        !lastLineMovedUp && 
    1:        !(GetStateBits() & NS_FRAME_IS_DIRTY) &&
    1:        !reflowedFloat)) {
 6260:     // We'll place lineIter at the last line of this block, so that 
 6260:     // nsBlockInFlowLineIterator::Next() will take us to the first
 6260:     // line of my next-in-flow-chain.  (But first, check that I 
 6260:     // have any lines -- if I don't, just bail out of this
 6260:     // optimization.) 
 6260:     line_iterator lineIter = this->end_lines();
 6260:     if (lineIter != this->begin_lines()) {
 6260:       lineIter--; // I have lines; step back from dummy iterator to last line.
 6260:       nsBlockInFlowLineIterator bifLineIter(this, lineIter, PR_FALSE);
 6260: 
 6260:       // Check for next-in-flow-chain's first line.
 6260:       // (First, see if there is such a line, and second, see if it's clean)
 6260:       if (!bifLineIter.Next() ||                
 6260:           !bifLineIter.GetLine()->IsDirty()) {
27993:         skipPull=PR_TRUE;
27993:       }
27993:     }
27993:   }
27993: 
27993:   if (skipPull && aState.mNextInFlow) {
27993:     NS_ASSERTION(heightConstrained, "Height should be constrained here\n");
 6521:     if (IS_TRUE_OVERFLOW_CONTAINER(aState.mNextInFlow))
 6521:       NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
 6521:     else
 4006:       NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
 6260:   }
 6260:   
 6260:   if (!skipPull && aState.mNextInFlow) {
    1:     // Pull data from a next-in-flow if there's still room for more
    1:     // content here.
    1:     while (keepGoing && (nsnull != aState.mNextInFlow)) {
    1:       // Grab first line from our next-in-flow
    1:       nsBlockFrame* nextInFlow = aState.mNextInFlow;
    1:       line_iterator nifLine = nextInFlow->begin_lines();
    1:       nsLineBox *toMove;
33276:       PRBool toMoveIsOverflowLine;
    1:       if (nifLine != nextInFlow->end_lines()) {
    1:         toMove = nifLine;
    1:         nextInFlow->mLines.erase(nifLine);
33276:         toMoveIsOverflowLine = PR_FALSE;
    1:       } else {
    1:         // Grab an overflow line if there are any
    1:         nsLineList* overflowLines = nextInFlow->GetOverflowLines();
    1:         if (!overflowLines) {
    1:           aState.mNextInFlow =
 3233:             static_cast<nsBlockFrame*>(nextInFlow->GetNextInFlow());
    1:           continue;
    1:         }
    1:         nifLine = overflowLines->begin();
    1:         NS_ASSERTION(nifLine != overflowLines->end(),
    1:                      "Stored overflow line list should not be empty");
    1:         toMove = nifLine;
    1:         nextInFlow->RemoveOverflowLines();
    1:         nifLine = overflowLines->erase(nifLine);
    1:         if (nifLine != overflowLines->end()) {
    1:           // We need to this remove-and-put-back dance because we want
    1:           // to avoid making the overflow line list empty while it's
    1:           // stored in the property (because the property has the
    1:           // invariant that the list is never empty).
    1:           nextInFlow->SetOverflowLines(overflowLines);
33259:         } else {
33259:           delete overflowLines;
    1:         }
33276:         toMoveIsOverflowLine = PR_TRUE;
    1:       }
    1: 
    1:       if (0 == toMove->GetChildCount()) {
    1:         // The line is empty. Try the next one.
    1:         NS_ASSERTION(nsnull == toMove->mFirstChild, "bad empty line");
    1:         aState.FreeLineBox(toMove);
    1:         continue;
    1:       }
    1: 
    1:       // XXX move to a subroutine: run-in, overflow, pullframe and this do this
    1:       // Make the children in the line ours.
    1:       nsIFrame* frame = toMove->mFirstChild;
    1:       nsIFrame* lastFrame = nsnull;
    1:       PRInt32 n = toMove->GetChildCount();
    1:       while (--n >= 0) {
    1:         ReparentFrame(frame, nextInFlow, this);
    1:         lastFrame = frame;
    1:         frame = frame->GetNextSibling();
    1:       }
33276: 
33276:       NS_ASSERTION(lastFrame == toMove->LastChild(), "Unexpected lastFrame");
33276: 
33276:       NS_ASSERTION(aState.mPrevChild || mLines.empty(), "should have a prevchild here");
33276: 
33276:       NS_ASSERTION(aState.mPrevChild == mFrames.LastChild(),
33276:                    "Incorrect aState.mPrevChild before inserting line at end");
33276: 
33276:       // Shift toMove's frames into our mFrames list.
33276:       if (toMoveIsOverflowLine) {
33276:         // Pulling from an overflow list
33276:         // XXXbz If we switch overflow lines to nsFrameList, we should
33276:         // change this SetNextSibling call.
    1:         lastFrame->SetNextSibling(nsnull);
33276:       } else {
33276:         // Pulling from nextInFlow->mFrames
33276:         nsFrameList::FrameLinkEnumerator linkToBreak(nextInFlow->mFrames, lastFrame);
33276:         nextInFlow->mFrames.ExtractHead(linkToBreak);
33276:       }
33276:       nsFrameList newFrames(toMove->mFirstChild, lastFrame);
33276:       mFrames.AppendFrames(nsnull, newFrames);
33276: 
33276:       // Add line to our line list, and set its last child as our new prev-child
33276:       line = mLines.before_insert(end_lines(), toMove);
33276:       aState.mPrevChild = lastFrame;
33276: 
33276:       NS_ASSERTION(aState.mPrevChild == mFrames.LastChild(),
33276:                    "Incorrect aState.mPrevChild after inserting line at end");
    1: 
    1:       // Reparent floats whose placeholders are in the line.
33276:       ReparentFloats(toMove->mFirstChild, nextInFlow, toMoveIsOverflowLine, PR_TRUE);
    1: 
    1:       DumpLine(aState, toMove, deltaY, 0);
    1: #ifdef DEBUG
    1:       AutoNoisyIndenter indent2(gNoisyReflow);
    1: #endif
    1: 
27993:       if (aState.mPresContext->HasPendingInterrupt()) {
27993:         MarkLineDirtyForInterrupt(line);
27993:       } else {
    1:         // Now reflow it and any lines that it makes during it's reflow
29172:         // (we have to loop here because reflowing the line may cause a new
    1:         // line to be created; see SplitLine's callers for examples of
    1:         // when this happens).
    1:         while (line != end_lines()) {
    1:           rv = ReflowLine(aState, line, &keepGoing);
    1:           NS_ENSURE_SUCCESS(rv, rv);
42241: 
42241:           if (aState.mReflowState.WillReflowAgainForClearance()) {
42241:             line->MarkDirty();
42241:             keepGoing = PR_FALSE;
49007:             NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
42241:             break;
42241:           }
42241: 
    1:           DumpLine(aState, line, deltaY, -1);
    1:           if (!keepGoing) {
    1:             if (0 == line->GetChildCount()) {
    1:               DeleteLine(aState, line, line_end);
    1:             }
    1:             break;
    1:           }
    1: 
    1:           if (LineHasClear(line.get())) {
    1:             foundAnyClears = PR_TRUE;
    1:           }
    1: 
27993:           if (aState.mPresContext->CheckForInterrupt(this)) {
27993:             MarkLineDirtyForInterrupt(line);
27993:             break;
27993:           }
27993: 
    1:           // If this is an inline frame then its time to stop
    1:           ++line;
    1:           aState.AdvanceToNextLine();
    1:         }
    1:       }
27993:     }
    1: 
    1:     if (NS_FRAME_IS_NOT_COMPLETE(aState.mReflowStatus)) {
    1:       aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
 4006:     } //XXXfr shouldn't set this flag when nextinflow has no lines
    1:   }
    1: 
    1:   // Handle an odd-ball case: a list-item with no lines
    1:   if (mBullet && HaveOutsideBullet() && mLines.empty()) {
    1:     nsHTMLReflowMetrics metrics;
11520:     ReflowBullet(aState, metrics,
11520:                  aState.mReflowState.mComputedBorderPadding.top);
32392:     NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,
32392:                  "empty bullet took up space");
32392: 
32392:     if (!BulletIsEmpty()) {
    1:       // There are no lines so we have to fake up some y motion so that
    1:       // we end up with *some* height.
31325: 
31325:       if (metrics.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE &&
31325:           !nsLayoutUtils::GetFirstLineBaseline(mBullet, &metrics.ascent)) {
31325:         metrics.ascent = metrics.height;
31325:       }
31325: 
31325:       nsIRenderingContext *rc = aState.mReflowState.rendContext;
31325:       nsLayoutUtils::SetFontFromStyle(rc, GetStyleContext());
31325:       nsCOMPtr<nsIFontMetrics> fm;
31325:       rc->GetFontMetrics(*getter_AddRefs(fm));
31325: 
31325:       nscoord minAscent =
31325:         nsLayoutUtils::GetCenteredFontBaseline(fm, aState.mMinLineHeight);
31325:       nscoord minDescent = aState.mMinLineHeight - minAscent;
31325: 
32531:       aState.mY += NS_MAX(minAscent, metrics.ascent) +
32531:                    NS_MAX(minDescent, metrics.height - metrics.ascent);
31325: 
31325:       nscoord offset = minAscent - metrics.ascent;
31325:       if (offset > 0) {
31325:         mBullet->SetRect(mBullet->GetRect() + nsPoint(0, offset));
31325:       }
    1:     }
32392:   }
    1: 
    1:   if (foundAnyClears) {
    1:     AddStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
    1:   } else {
    1:     RemoveStateBits(NS_BLOCK_HAS_CLEAR_CHILDREN);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     IndentBy(stdout, gNoiseIndent - 1);
    1:     ListTag(stdout);
    1:     printf(": done reflowing dirty lines (status=%x)\n",
    1:            aState.mReflowStatus);
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
27993: static void MarkAllDescendantLinesDirty(nsBlockFrame* aBlock)
27993: {
27993:   nsLineList::iterator line = aBlock->begin_lines();
27993:   nsLineList::iterator endLine = aBlock->end_lines();
27993:   while (line != endLine) {
27993:     if (line->IsBlock()) {
27993:       nsIFrame* f = line->mFirstChild;
27993:       nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(f);
27993:       if (bf) {
27993:         MarkAllDescendantLinesDirty(bf);
27993:       }
27993:     }
27993:     line->MarkDirty();
27993:     ++line;
27993:   }
27993: }
27993: 
27993: void
27993: nsBlockFrame::MarkLineDirtyForInterrupt(nsLineBox* aLine)
27993: {
27993:   aLine->MarkDirty();
27993: 
27993:   // Just checking NS_FRAME_IS_DIRTY is ok, because we've already
27993:   // marked the lines that need to be marked dirty based on our
27993:   // vertical resize stuff.  So we'll definitely reflow all those kids;
27993:   // the only question is how they should behave.
27993:   if (GetStateBits() & NS_FRAME_IS_DIRTY) {
27993:     // Mark all our child frames dirty so we make sure to reflow them
27993:     // later.
27993:     PRInt32 n = aLine->GetChildCount();
27993:     for (nsIFrame* f = aLine->mFirstChild; n > 0;
27993:          f = f->GetNextSibling(), --n) {
27993:       f->AddStateBits(NS_FRAME_IS_DIRTY);
28163:     }
28163:     // And mark all the floats whose reflows we might be skipping dirty too.
28163:     if (aLine->HasFloats()) {
28163:       for (nsFloatCache* fc = aLine->GetFirstFloat(); fc; fc = fc->Next()) {
32107:         fc->mFloat->AddStateBits(NS_FRAME_IS_DIRTY);
27993:       }
27993:     }
27993:   } else {
27993:     // Dirty all the descendant lines of block kids to handle float damage,
27993:     // since our nsFloatManager will go away by the next time we're reflowing.
27993:     // XXXbz Can we do something more like what PropagateFloatDamage does?
27993:     // Would need to sort out the exact business with mBlockDelta for that....
27993:     // This marks way too much dirty.  If we ever make this better, revisit
27993:     // which lines we mark dirty in the interrupt case in ReflowDirtyLines.
27993:     nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(aLine->mFirstChild);
27993:     if (bf) {
27993:       MarkAllDescendantLinesDirty(bf);
27993:     }
27993:   }
27993: }
27993: 
    1: void
    1: nsBlockFrame::DeleteLine(nsBlockReflowState& aState,
    1:                          nsLineList::iterator aLine,
    1:                          nsLineList::iterator aLineEnd)
    1: {
    1:   NS_PRECONDITION(0 == aLine->GetChildCount(), "can't delete !empty line");
    1:   if (0 == aLine->GetChildCount()) {
    1:     NS_ASSERTION(aState.mCurrentLine == aLine,
    1:                  "using function more generally than designed, "
    1:                  "but perhaps OK now");
    1:     nsLineBox *line = aLine;
    1:     aLine = mLines.erase(aLine);
    1:     aState.FreeLineBox(line);
    1:     // Mark the previous margin of the next line dirty since we need to
    1:     // recompute its top position.
    1:     if (aLine != aLineEnd)
    1:       aLine->MarkPreviousMarginDirty();
    1:   }
    1: }
    1: 
    1: /**
    1:  * Reflow a line. The line will either contain a single block frame
    1:  * or contain 1 or more inline frames. aKeepReflowGoing indicates
    1:  * whether or not the caller should continue to reflow more lines.
    1:  */
    1: nsresult
    1: nsBlockFrame::ReflowLine(nsBlockReflowState& aState,
    1:                          line_iterator aLine,
    1:                          PRBool* aKeepReflowGoing)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   NS_ABORT_IF_FALSE(aLine->GetChildCount(), "reflowing empty line");
    1: 
    1:   // Setup the line-layout for the new line
    1:   aState.mCurrentLine = aLine;
    1:   aLine->ClearDirty();
    1:   aLine->InvalidateCachedIsEmpty();
49001:   aLine->ClearHadFloatPushed();
    1: 
    1:   // Now that we know what kind of line we have, reflow it
    1:   if (aLine->IsBlock()) {
    1:     nsRect oldBounds = aLine->mFirstChild->GetRect();
    1:     nsRect oldCombinedArea(aLine->GetCombinedArea());
    1:     rv = ReflowBlockFrame(aState, aLine, aKeepReflowGoing);
    1:     nsRect newBounds = aLine->mFirstChild->GetRect();
    1: 
    1:     // We expect blocks to damage any area inside their bounds that is
    1:     // dirty; however, if the frame changes size or position then we
    1:     // need to do some repainting.
    1:     // XXX roc --- the above statement is ambiguous about whether 'bounds'
    1:     // means the frame's bounds or overflowArea, and in fact this is a source
    1:     // of much confusion and bugs. Thus the following hack considers *both*
    1:     // overflowArea and bounds. This should be considered a temporary hack
    1:     // until we decide how it's really supposed to work.
13144:     // Note that we have a similar hack in nsTableFrame::InvalidateFrame.
    1:     nsRect lineCombinedArea(aLine->GetCombinedArea());
    1:     if (oldCombinedArea.TopLeft() != lineCombinedArea.TopLeft() ||
    1:         oldBounds.TopLeft() != newBounds.TopLeft()) {
    1:       // The block has moved, and so to be safe we need to repaint
    1:       // XXX We need to improve on this...
    1:       nsRect  dirtyRect;
    1:       dirtyRect.UnionRect(oldCombinedArea, lineCombinedArea);
    1: #ifdef NOISY_BLOCK_INVALIDATE
    1:       printf("%p invalidate 6 (%d, %d, %d, %d)\n",
    1:              this, dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
    1: #endif
    1:       Invalidate(dirtyRect);
51757:       FrameLayerBuilder::InvalidateThebesLayersInSubtree(aLine->mFirstChild);
    1:     } else {
    1:       nsRect combinedAreaHStrip, combinedAreaVStrip;
    1:       nsRect boundsHStrip, boundsVStrip;
11384:       nsLayoutUtils::GetRectDifferenceStrips(oldBounds, newBounds,
    1:                                              &boundsHStrip, &boundsVStrip);
11384:       nsLayoutUtils::GetRectDifferenceStrips(oldCombinedArea, lineCombinedArea,
11384:                                              &combinedAreaHStrip,
11384:                                              &combinedAreaVStrip);
    1: 
    1: #ifdef NOISY_BLOCK_INVALIDATE
    1:       printf("%p invalidate boundsVStrip (%d, %d, %d, %d)\n",
    1:              this, boundsVStrip.x, boundsVStrip.y, boundsVStrip.width, boundsVStrip.height);
    1:       printf("%p invalidate boundsHStrip (%d, %d, %d, %d)\n",
    1:              this, boundsHStrip.x, boundsHStrip.y, boundsHStrip.width, boundsHStrip.height);
    1:       printf("%p invalidate combinedAreaVStrip (%d, %d, %d, %d)\n",
    1:              this, combinedAreaVStrip.x, combinedAreaVStrip.y, combinedAreaVStrip.width, combinedAreaVStrip.height);
    1:       printf("%p invalidate combinedAreaHStrip (%d, %d, %d, %d)\n",
    1:              this, combinedAreaHStrip.x, combinedAreaHStrip.y, combinedAreaHStrip.width, combinedAreaHStrip.height);
    1: #endif
    1:       // The first thing Invalidate does is check if the rect is empty, so
    1:       // don't bother doing that here.
    1:       Invalidate(boundsVStrip);
    1:       Invalidate(boundsHStrip);
    1:       Invalidate(combinedAreaVStrip);
    1:       Invalidate(combinedAreaHStrip);
    1:     }
    1:   }
    1:   else {
    1:     nsRect oldCombinedArea(aLine->GetCombinedArea());
    1:     aLine->SetLineWrapped(PR_FALSE);
    1: 
    1:     rv = ReflowInlineFrames(aState, aLine, aKeepReflowGoing);
    1: 
    1:     // We don't really know what changed in the line, so use the union
    1:     // of the old and new combined areas
    1:     nsRect dirtyRect;
    1:     dirtyRect.UnionRect(oldCombinedArea, aLine->GetCombinedArea());
    1: #ifdef NOISY_BLOCK_INVALIDATE
    1:     printf("%p invalidate (%d, %d, %d, %d)\n",
    1:            this, dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
    1:     if (aLine->IsForceInvalidate())
51776:       printf("  dirty line is %p\n", static_cast<void*>(aLine.get()));
    1: #endif
    1:     Invalidate(dirtyRect);
51757:     if (GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT) {
51757:       PRInt32 childCount = aLine->GetChildCount();
51757:       for (nsIFrame* f = aLine->mFirstChild; childCount;
51757:            --childCount, f = f->GetNextSibling()) {
51757:         FrameLayerBuilder::InvalidateThebesLayersInSubtree(f);
51757:       }
51757:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
36987: nsIFrame*
    1: nsBlockFrame::PullFrame(nsBlockReflowState& aState,
36987:                         line_iterator       aLine)
    1: {
36987:   // First check our remaining lines.
    1:   if (end_lines() != aLine.next()) {
36987:     return PullFrameFrom(aState, aLine, this, PR_FALSE, aLine.next());
    1:   }
    1: 
    1:   NS_ASSERTION(!GetOverflowLines(),
    1:     "Our overflow lines should have been removed at the start of reflow");
    1: 
36987:   // Try each next-in-flow.
    1:   nsBlockFrame* nextInFlow = aState.mNextInFlow;
    1:   while (nextInFlow) {
    1:     // first normal lines, then overflow lines
    1:     if (!nextInFlow->mLines.empty()) {
36987:       return PullFrameFrom(aState, aLine, nextInFlow, PR_FALSE,
36987:                            nextInFlow->mLines.begin());
    1:     }
    1: 
    1:     nsLineList* overflowLines = nextInFlow->GetOverflowLines();
    1:     if (overflowLines) {
36987:       return PullFrameFrom(aState, aLine, nextInFlow, PR_TRUE,
36987:                            overflowLines->begin());
36987:     }
36987: 
36987:     nextInFlow = static_cast<nsBlockFrame*>(nextInFlow->GetNextInFlow());
    1:     aState.mNextInFlow = nextInFlow;
    1:   }
    1: 
36987:   return nsnull;
36987: }
36987: 
36987: nsIFrame*
    1: nsBlockFrame::PullFrameFrom(nsBlockReflowState&  aState,
    1:                             nsLineBox*           aLine,
    1:                             nsBlockFrame*        aFromContainer,
    1:                             PRBool               aFromOverflowLine,
36987:                             nsLineList::iterator aFromLine)
    1: {
    1:   nsLineBox* fromLine = aFromLine;
    1:   NS_ABORT_IF_FALSE(fromLine, "bad line to pull from");
    1:   NS_ABORT_IF_FALSE(fromLine->GetChildCount(), "empty line");
    1:   NS_ABORT_IF_FALSE(aLine->GetChildCount(), "empty line");
    1: 
 2829:   NS_ASSERTION(fromLine->IsBlock() == fromLine->mFirstChild->GetStyleDisplay()->IsBlockOutside(),
    1:                "Disagreement about whether it's a block or not");
    1: 
    1:   if (fromLine->IsBlock()) {
    1:     // If our line is not empty and the child in aFromLine is a block
    1:     // then we cannot pull up the frame into this line. In this case
    1:     // we stop pulling.
36987:     return nsnull;
36987:   }
    1:   // Take frame from fromLine
    1:   nsIFrame* frame = fromLine->mFirstChild;
32385:   nsIFrame* newFirstChild = frame->GetNextSibling();
    1: 
    1:   if (aFromContainer != this) {
32385:     NS_ASSERTION(aState.mPrevChild == aLine->LastChild(),
32385:       "mPrevChild should be the LastChild of the line we are adding to");
32385:     // The frame is being pulled from a next-in-flow; therefore we
32385:     // need to add it to our sibling list.
36451:     if (NS_LIKELY(!aFromOverflowLine)) {
36451:       NS_ASSERTION(aFromLine == aFromContainer->mLines.begin(),
36451:                    "should only pull from first line");
33276:       // Pulling from the next-in-flow's normal line list
33276:       aFromContainer->mFrames.RemoveFrame(frame);
33276:     } else {
33276:       // Pulling from the next-in-flow's overflow list
33276:       // XXXbz If we switch overflow lines to nsFrameList, we should
33276:       // change this SetNextSibling call.
32385:       frame->SetNextSibling(nsnull);
33276:     }
33276: 
33276:     // When pushing and pulling frames we need to check for whether any
33276:     // views need to be reparented
33276:     NS_ASSERTION(frame->GetParent() == aFromContainer, "unexpected parent frame");
33276: 
33276:     ReparentFrame(frame, aFromContainer, this);
33276:     mFrames.InsertFrame(nsnull, aState.mPrevChild, frame);
33276: 
33276:     // The frame might have (or contain) floats that need to be
33276:     // brought over too.
33276:     ReparentFloats(frame, aFromContainer, aFromOverflowLine, PR_TRUE);
    1:   }
    1:   // when aFromContainer is 'this', then aLine->LastChild()'s next sibling
    1:   // is already set correctly.
    1:   aLine->SetChildCount(aLine->GetChildCount() + 1);
    1:     
    1:   PRInt32 fromLineChildCount = fromLine->GetChildCount();
    1:   if (0 != --fromLineChildCount) {
    1:     // Mark line dirty now that we pulled a child
    1:     fromLine->SetChildCount(fromLineChildCount);
    1:     fromLine->MarkDirty();
32385:     fromLine->mFirstChild = newFirstChild;
    1:   }
    1:   else {
    1:     // Free up the fromLine now that it's empty
    1:     // Its bounds might need to be redrawn, though.
    1:     // XXX WHY do we invalidate the bounds AND the combined area? doesn't
    1:     // the combined area always enclose the bounds?
    1:     Invalidate(fromLine->mBounds);
    1:     nsLineList* fromLineList = aFromOverflowLine
    1:       ? aFromContainer->RemoveOverflowLines()
    1:       : &aFromContainer->mLines;
    1:     if (aFromLine.next() != fromLineList->end())
    1:       aFromLine.next()->MarkPreviousMarginDirty();
    1: 
    1:     Invalidate(fromLine->GetCombinedArea());
    1:     fromLineList->erase(aFromLine);
36689:     // aFromLine is now invalid
    1:     aState.FreeLineBox(fromLine);
    1: 
    1:     // Put any remaining overflow lines back.
33259:     if (aFromOverflowLine) {
33259:       if (!fromLineList->empty()) {
    1:         aFromContainer->SetOverflowLines(fromLineList);
33259:       } else {
33259:         delete fromLineList;
36689:         // Now any iterators into fromLineList are invalid (but
36689:         // aFromLine already was invalidated above)
33259:       }
    1:     }
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   VerifyLines(PR_TRUE);
    1: #endif
36987: 
36987:   return frame;
    1: }
    1: 
    1: static void
    1: PlaceFrameView(nsIFrame* aFrame)
    1: {
    1:   if (aFrame->HasView())
    1:     nsContainerFrame::PositionFrameView(aFrame);
    1:   else
    1:     nsContainerFrame::PositionChildViews(aFrame);
    1: }
    1: 
    1: void
    1: nsBlockFrame::SlideLine(nsBlockReflowState& aState,
    1:                         nsLineBox* aLine, nscoord aDY)
    1: {
    1:   NS_PRECONDITION(aDY != 0, "why slide a line nowhere?");
    1: 
    1:   Invalidate(aLine->GetCombinedArea());
    1:   // Adjust line state
    1:   aLine->SlideBy(aDY);
    1:   Invalidate(aLine->GetCombinedArea());
    1: 
    1:   // Adjust the frames in the line
    1:   nsIFrame* kid = aLine->mFirstChild;
    1:   if (!kid) {
    1:     return;
    1:   }
    1: 
    1:   if (aLine->IsBlock()) {
    1:     if (aDY) {
    1:       nsPoint p = kid->GetPosition();
    1:       p.y += aDY;
    1:       kid->SetPosition(p);
    1:     }
    1: 
    1:     // Make sure the frame's view and any child views are updated
    1:     ::PlaceFrameView(kid);
    1:   }
    1:   else {
    1:     // Adjust the Y coordinate of the frames in the line.
    1:     // Note: we need to re-position views even if aDY is 0, because
    1:     // one of our parent frames may have moved and so the view's position
    1:     // relative to its parent may have changed
    1:     PRInt32 n = aLine->GetChildCount();
    1:     while (--n >= 0) {
    1:       if (aDY) {
    1:         nsPoint p = kid->GetPosition();
    1:         p.y += aDY;
    1:         kid->SetPosition(p);
    1:       }
    1:       // Make sure the frame's view and any child views are updated
    1:       ::PlaceFrameView(kid);
    1:       kid = kid->GetNextSibling();
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsBlockFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                                nsIAtom*        aAttribute,
    1:                                PRInt32         aModType)
    1: {
    1:   nsresult rv = nsBlockFrameSuper::AttributeChanged(aNameSpaceID,
    1:                                                     aAttribute, aModType);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   if (nsGkAtoms::start == aAttribute) {
  238:     nsPresContext* presContext = PresContext();
    1: 
    1:     // XXX Not sure if this is necessary anymore
 1158:     if (RenumberLists(presContext)) {
    1:       presContext->PresShell()->
 1158:         FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                          NS_FRAME_HAS_DIRTY_CHILDREN);
 1158:     }
    1:   }
    1:   else if (nsGkAtoms::value == aAttribute) {
    1:     const nsStyleDisplay* styleDisplay = GetStyleDisplay();
    1:     if (NS_STYLE_DISPLAY_LIST_ITEM == styleDisplay->mDisplay) {
    1:       // Search for the closest ancestor that's a block frame. We
    1:       // make the assumption that all related list items share a
    1:       // common block parent.
    1:       // XXXldb I think that's a bad assumption.
    1:       nsBlockFrame* blockParent = nsLayoutUtils::FindNearestBlockAncestor(this);
    1: 
    1:       // Tell the enclosing block frame to renumber list items within
    1:       // itself
    1:       if (nsnull != blockParent) {
  238:         nsPresContext* presContext = PresContext();
    1:         // XXX Not sure if this is necessary anymore
 1158:         if (blockParent->RenumberLists(presContext)) {
    1:           presContext->PresShell()->
 1158:             FrameNeedsReflow(blockParent, nsIPresShell::eStyleChange,
 1158:                              NS_FRAME_HAS_DIRTY_CHILDREN);
 1158:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
12630: static inline PRBool
51406: IsNonAutoNonZeroHeight(const nsStyleCoord& aCoord)
51406: {
51406:   if (aCoord.GetUnit() == eStyleUnit_Auto)
51406:     return PR_FALSE;
51406:   if (aCoord.IsCoordPercentCalcUnit()) {
51406:     // If we evaluate the length/percent/calc at a percentage basis of
51406:     // both nscoord_MAX and 0, and it's zero both ways, then it's a zero
51406:     // length, percent, or combination thereof.  Test > 0 so we clamp
51406:     // negative calc() results to 0.
51406:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, nscoord_MAX) > 0 ||
51406:            nsRuleNode::ComputeCoordPercentCalc(aCoord, 0) > 0;
51406:   }
51406:   NS_ABORT_IF_FALSE(PR_FALSE, "unexpected unit for height or min-height");
51406:   return PR_TRUE;
51406: }
51406: 
    1: /* virtual */ PRBool
    1: nsBlockFrame::IsSelfEmpty()
    1: {
 7674:   // Blocks which are margin-roots (including inline-blocks) cannot be treated
 7674:   // as empty for margin-collapsing and other purposes. They're more like
 7674:   // replaced elements.
 7674:   if (GetStateBits() & NS_BLOCK_MARGIN_ROOT)
 7674:     return PR_FALSE;
 7674: 
    1:   const nsStylePosition* position = GetStylePosition();
    1: 
51406:   if (IsNonAutoNonZeroHeight(position->mMinHeight) ||
51406:       IsNonAutoNonZeroHeight(position->mHeight))
    1:     return PR_FALSE;
    1: 
    1:   const nsStyleBorder* border = GetStyleBorder();
    1:   const nsStylePadding* padding = GetStylePadding();
15992:   if (border->GetActualBorderWidth(NS_SIDE_TOP) != 0 ||
15992:       border->GetActualBorderWidth(NS_SIDE_BOTTOM) != 0 ||
51777:       !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetTop()) ||
51777:       !nsLayoutUtils::IsPaddingZero(padding->mPadding.GetBottom())) {
    1:     return PR_FALSE;
    1:   }
    1: 
32392:   if (HaveOutsideBullet() && !BulletIsEmpty()) {
31325:     return PR_FALSE;
31325:   }
31325: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::CachedIsEmpty()
    1: {
    1:   if (!IsSelfEmpty()) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   for (line_iterator line = begin_lines(), line_end = end_lines();
    1:        line != line_end;
    1:        ++line)
    1:   {
    1:     if (!line->CachedIsEmpty())
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::IsEmpty()
    1: {
    1:   if (!IsSelfEmpty()) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   for (line_iterator line = begin_lines(), line_end = end_lines();
    1:        line != line_end;
    1:        ++line)
    1:   {
    1:     if (!line->IsEmpty())
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::ShouldApplyTopMargin(nsBlockReflowState& aState,
    1:                                    nsLineBox* aLine)
    1: {
    1:   if (aState.GetFlag(BRS_APPLYTOPMARGIN)) {
    1:     // Apply short-circuit check to avoid searching the line list
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (!aState.IsAdjacentWithTop()) {
    1:     // If we aren't at the top Y coordinate then something of non-zero
    1:     // height must have been placed. Therefore the childs top-margin
    1:     // applies.
    1:     aState.SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Determine if this line is "essentially" the first line
    1:   line_iterator line = begin_lines();
    1:   if (aState.GetFlag(BRS_HAVELINEADJACENTTOTOP)) {
    1:     line = aState.mLineAdjacentToTop;
    1:   }
    1:   while (line != aLine) {
    1:     if (!line->CachedIsEmpty() || line->HasClearance()) {
    1:       // A line which precedes aLine is non-empty, or has clearance,
    1:       // so therefore the top margin applies.
    1:       aState.SetFlag(BRS_APPLYTOPMARGIN, PR_TRUE);
    1:       return PR_TRUE;
    1:     }
    1:     // No need to apply the top margin if the line has floats.  We
    1:     // should collapse anyway (bug 44419)
    1:     ++line;
    1:     aState.SetFlag(BRS_HAVELINEADJACENTTOTOP, PR_TRUE);
    1:     aState.mLineAdjacentToTop = line;
    1:   }
    1: 
    1:   // The line being reflowed is "essentially" the first line in the
    1:   // block. Therefore its top-margin will be collapsed by the
    1:   // generational collapsing logic with its parent (us).
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsBlockFrame::ReflowBlockFrame(nsBlockReflowState& aState,
    1:                                line_iterator aLine,
    1:                                PRBool* aKeepReflowGoing)
    1: {
    1:   NS_PRECONDITION(*aKeepReflowGoing, "bad caller");
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsIFrame* frame = aLine->mFirstChild;
    1:   if (!frame) {
    1:     NS_ASSERTION(PR_FALSE, "program error - unexpected empty line"); 
    1:     return NS_ERROR_NULL_POINTER; 
    1:   }
    1: 
    1:   // Prepare the block reflow engine
    1:   const nsStyleDisplay* display = frame->GetStyleDisplay();
    1:   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
    1: 
    1:   PRUint8 breakType = display->mBreakType;
    1:   if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
    1:     breakType = nsLayoutUtils::CombineBreakType(breakType,
    1:                                                 aState.mFloatBreakType);
    1:     aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
    1:   }
    1: 
    1:   // Clear past floats before the block if the clear style is not none
    1:   aLine->SetBreakTypeBefore(breakType);
    1: 
    1:   // See if we should apply the top margin. If the block frame being
    1:   // reflowed is a continuation (non-null prev-in-flow) then we don't
    1:   // apply its top margin because it's not significant. Otherwise, dig
    1:   // deeper.
    1:   PRBool applyTopMargin =
    1:     !frame->GetPrevInFlow() && ShouldApplyTopMargin(aState, aLine);
    1: 
    1:   if (applyTopMargin) {
    1:     // The HasClearance setting is only valid if ShouldApplyTopMargin
    1:     // returned PR_FALSE (in which case the top-margin-root set our
    1:     // clearance flag). Otherwise clear it now. We'll set it later on
    1:     // ourselves if necessary.
    1:     aLine->ClearHasClearance();
    1:   }
    1:   PRBool treatWithClearance = aLine->HasClearance();
10895: 
10895:   PRBool mightClearFloats = breakType != NS_STYLE_CLEAR_NONE;
14910:   nsIFrame *replacedBlock = nsnull;
10895:   if (!nsBlockFrame::BlockCanIntersectFloats(frame)) {
10895:     mightClearFloats = PR_TRUE;
14910:     replacedBlock = frame;
10895:   }
10895: 
    1:   // If our top margin was counted as part of some parents top-margin
    1:   // collapse and we are being speculatively reflowed assuming this
    1:   // frame DID NOT need clearance, then we need to check that
    1:   // assumption.
10895:   if (!treatWithClearance && !applyTopMargin && mightClearFloats &&
    1:       aState.mReflowState.mDiscoveredClearance) {
    1:     nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
14910:     nscoord clearY = aState.ClearFloats(curY, breakType, replacedBlock);
    1:     if (clearY != curY) {
    1:       // Looks like that assumption was invalid, we do need
    1:       // clearance. Tell our ancestor so it can reflow again. It is
    1:       // responsible for actually setting our clearance flag before
    1:       // the next reflow.
    1:       treatWithClearance = PR_TRUE;
    1:       // Only record the first frame that requires clearance
    1:       if (!*aState.mReflowState.mDiscoveredClearance) {
    1:         *aState.mReflowState.mDiscoveredClearance = frame;
    1:       }
34530:       aState.mPrevChild = frame;
    1:       // Exactly what we do now is flexible since we'll definitely be
    1:       // reflowed.
 8457:       return NS_OK;
    1:     }
    1:   }
    1:   if (treatWithClearance) {
    1:     applyTopMargin = PR_TRUE;
    1:   }
    1: 
    1:   nsIFrame* clearanceFrame = nsnull;
    1:   nscoord startingY = aState.mY;
    1:   nsCollapsingMargin incomingMargin = aState.mPrevBottomMargin;
    1:   nscoord clearance;
  375:   // Save the original position of the frame so that we can reposition
  375:   // its view as needed.
  375:   nsPoint originalPosition = frame->GetPosition();
    1:   while (PR_TRUE) {
    1:     // Save the frame's current position. We might need it later.
  375:     nscoord passOriginalY = frame->GetRect().y;
    1:     
    1:     clearance = 0;
    1:     nscoord topMargin = 0;
    1:     PRBool mayNeedRetry = PR_FALSE;
    1:     if (applyTopMargin) {
    1:       // Precompute the blocks top margin value so that we can get the
    1:       // correct available space (there might be a float that's
    1:       // already been placed below the aState.mPrevBottomMargin
    1: 
    1:       // Setup a reflowState to get the style computed margin-top
    1:       // value. We'll use a reason of `resize' so that we don't fudge
    1:       // any incremental reflow state.
    1:       
    1:       // The availSpace here is irrelevant to our needs - all we want
    1:       // out if this setup is the margin-top value which doesn't depend
    1:       // on the childs available space.
    1:       // XXX building a complete nsHTMLReflowState just to get the margin-top
    1:       // seems like a waste. And we do this for almost every block!
    1:       nsSize availSpace(aState.mContentArea.width, NS_UNCONSTRAINEDSIZE);
    1:       nsHTMLReflowState reflowState(aState.mPresContext, aState.mReflowState,
    1:                                     frame, availSpace);
    1:       
    1:       if (treatWithClearance) {
    1:         aState.mY += aState.mPrevBottomMargin.get();
    1:         aState.mPrevBottomMargin.Zero();
    1:       }
    1:       
    1:       // Now compute the collapsed margin-top value into aState.mPrevBottomMargin, assuming
    1:       // that all child margins collapse down to clearanceFrame.
    1:       nsBlockReflowContext::ComputeCollapsedTopMargin(reflowState,
    1:                                                       &aState.mPrevBottomMargin, clearanceFrame, &mayNeedRetry);
    1:       
    1:       // XXX optimization; we could check the collapsing children to see if they are sure
    1:       // to require clearance, and so avoid retrying them
    1:       
    1:       if (clearanceFrame) {
    1:         // Don't allow retries on the second pass. The clearance decisions for the
    1:         // blocks whose top-margins collapse with ours are now fixed.
    1:         mayNeedRetry = PR_FALSE;
    1:       }
    1:       
10895:       if (!treatWithClearance && !clearanceFrame && mightClearFloats) {
    1:         // We don't know if we need clearance and this is the first,
    1:         // optimistic pass.  So determine whether *this block* needs
    1:         // clearance. Note that we do not allow the decision for whether
    1:         // this block has clearance to change on the second pass; that
    1:         // decision is only allowed to be made under the optimistic
    1:         // first pass.
    1:         nscoord curY = aState.mY + aState.mPrevBottomMargin.get();
14910:         nscoord clearY = aState.ClearFloats(curY, breakType, replacedBlock);
    1:         if (clearY != curY) {
    1:           // Looks like we need clearance and we didn't know about it already. So
    1:           // recompute collapsed margin
    1:           treatWithClearance = PR_TRUE;
    1:           // Remember this decision, needed for incremental reflow
    1:           aLine->SetHasClearance();
    1:           
    1:           // Apply incoming margins
    1:           aState.mY += aState.mPrevBottomMargin.get();
    1:           aState.mPrevBottomMargin.Zero();
    1:           
    1:           // Compute the collapsed margin again, ignoring the incoming margin this time
    1:           mayNeedRetry = PR_FALSE;
    1:           nsBlockReflowContext::ComputeCollapsedTopMargin(reflowState,
    1:                                                           &aState.mPrevBottomMargin, clearanceFrame, &mayNeedRetry);
    1:         }
    1:       }
    1:       
    1:       // Temporarily advance the running Y value so that the
    1:       // GetAvailableSpace method will return the right available
    1:       // space. This undone as soon as the horizontal margins are
    1:       // computed.
    1:       topMargin = aState.mPrevBottomMargin.get();
    1:       
    1:       if (treatWithClearance) {
    1:         nscoord currentY = aState.mY;
    1:         // advance mY to the clear position.
14910:         aState.mY = aState.ClearFloats(aState.mY, breakType, replacedBlock);
    1:         
    1:         // Compute clearance. It's the amount we need to add to the top
    1:         // border-edge of the frame, after applying collapsed margins
    1:         // from the frame and its children, to get it to line up with
    1:         // the bottom of the floats. The former is currentY + topMargin,
    1:         // the latter is the current aState.mY.
    1:         // Note that negative clearance is possible
    1:         clearance = aState.mY - (currentY + topMargin);
    1:         
    1:         // Add clearance to our top margin while we compute available
    1:         // space for the frame
    1:         topMargin += clearance;
    1:         
    1:         // Note that aState.mY should stay where it is: at the top
    1:         // border-edge of the frame
    1:       } else {
    1:         // Advance aState.mY to the top border-edge of the frame.
    1:         aState.mY += topMargin;
    1:       }
    1:     }
    1:     
    1:     // Here aState.mY is the top border-edge of the block.
    1:     // Compute the available space for the block
27106:     nsFlowAreaRect floatAvailableSpace = aState.GetFloatAvailableSpace();
    1: #ifdef REALLY_NOISY_REFLOW
27103:     printf("setting line %p isImpacted to %s\n",
27106:            aLine.get(), floatAvailableSpace.mHasFloats?"true":"false");
    1: #endif
27106:     aLine->SetLineIsImpactedByFloat(floatAvailableSpace.mHasFloats);
    1:     nsRect availSpace;
27106:     aState.ComputeBlockAvailSpace(frame, display, floatAvailableSpace,
27103:                                   replacedBlock != nsnull, availSpace);
    1:     
    1:     // Now put the Y coordinate back to the top of the top-margin +
    1:     // clearance, and flow the block.
    1:     aState.mY -= topMargin;
    1:     availSpace.y -= topMargin;
    1:     if (NS_UNCONSTRAINEDSIZE != availSpace.height) {
    1:       availSpace.height += topMargin;
49006: 
49006:       // When there is a pushed float, clearance could equal
49006:       // NS_UNCONSTRAINEDSIZE (FIXME: is that really a good idea?), but
49006:       // we don't want that to change a constrained height to an
49006:       // unconstrained one.
49006:       if (NS_UNCONSTRAINEDSIZE == availSpace.height) {
49006:         --availSpace.height;
49006:       }
    1:     }
    1:     
    1:     // Reflow the block into the available space
    1:     // construct the html reflow state for the block. ReflowBlock 
    1:     // will initialize it
    1:     nsHTMLReflowState blockHtmlRS(aState.mPresContext, aState.mReflowState, frame, 
    1:                                   nsSize(availSpace.width, availSpace.height));
    1:     blockHtmlRS.mFlags.mHasClearance = aLine->HasClearance();
    1:     
23305:     nsFloatManager::SavedState floatManagerState;
    1:     if (mayNeedRetry) {
    1:       blockHtmlRS.mDiscoveredClearance = &clearanceFrame;
23305:       aState.mFloatManager->PushState(&floatManagerState);
    1:     } else if (!applyTopMargin) {
    1:       blockHtmlRS.mDiscoveredClearance = aState.mReflowState.mDiscoveredClearance;
    1:     }
    1:     
    1:     nsReflowStatus frameReflowStatus = NS_FRAME_COMPLETE;
    1:     rv = brc.ReflowBlock(availSpace, applyTopMargin, aState.mPrevBottomMargin,
14460:                          clearance, aState.IsAdjacentWithTop(),
 6521:                          aLine.get(), blockHtmlRS, frameReflowStatus, aState);
    1: 
    1:     // If this was a second-pass reflow and the block's vertical position
    1:     // changed, invalidates from the first pass might have happened in the
    1:     // wrong places.  Invalidate the entire overflow rect at the new position.
  375:     if (!mayNeedRetry && clearanceFrame &&
  375:         frame->GetRect().y != passOriginalY) {
    1:       Invalidate(frame->GetOverflowRect() + frame->GetPosition());
    1:     }
    1:     
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     if (mayNeedRetry && clearanceFrame) {
23305:       aState.mFloatManager->PopState(&floatManagerState);
    1:       aState.mY = startingY;
    1:       aState.mPrevBottomMargin = incomingMargin;
    1:       continue;
    1:     }
    1: 
32161:     aState.mPrevChild = frame;
32161: 
24805:     if (blockHtmlRS.WillReflowAgainForClearance()) {
24805:       // If an ancestor of ours is going to reflow for clearance, we
24805:       // need to avoid calling PlaceBlock, because it unsets dirty bits
24805:       // on the child block (both itself, and through its call to
24805:       // nsFrame::DidReflow), and those dirty bits imply dirtiness for
24805:       // all of the child block, including the lines it didn't reflow.
24805:       NS_ASSERTION(originalPosition == frame->GetPosition(),
24805:                    "we need to call PositionChildViews");
24805:       return NS_OK;
24805:     }
24805: 
    1: #if defined(REFLOW_STATUS_COVERAGE)
    1:     RecordReflowStatus(PR_TRUE, frameReflowStatus);
    1: #endif
    1:     
    1:     if (NS_INLINE_IS_BREAK_BEFORE(frameReflowStatus)) {
    1:       // None of the child block fits.
    1:       PushLines(aState, aLine.prev());
    1:       *aKeepReflowGoing = PR_FALSE;
 4006:       NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
    1:     }
    1:     else {
    1:       // Note: line-break-after a block is a nop
    1:       
    1:       // Try to place the child block.
    1:       // Don't force the block to fit if we have positive clearance, because
    1:       // pushing it to the next page would give it more room.
    1:       // Don't force the block to fit if it's impacted by a float. If it is,
    1:       // then pushing it to the next page would give it more room. Note that
    1:       // isImpacted doesn't include impact from the block's own floats.
    1:       PRBool forceFit = aState.IsAdjacentWithTop() && clearance <= 0 &&
27106:         !floatAvailableSpace.mHasFloats;
    1:       nsCollapsingMargin collapsedBottomMargin;
    1:       nsRect combinedArea(0,0,0,0);
    1:       *aKeepReflowGoing = brc.PlaceBlock(blockHtmlRS, forceFit, aLine.get(),
14460:                                          collapsedBottomMargin,
    1:                                          aLine->mBounds, combinedArea, frameReflowStatus);
    1:       if (aLine->SetCarriedOutBottomMargin(collapsedBottomMargin)) {
    1:         line_iterator nextLine = aLine;
    1:         ++nextLine;
    1:         if (nextLine != end_lines()) {
    1:           nextLine->MarkPreviousMarginDirty();
    1:         }
    1:       }
    1:       
    1:       aLine->SetCombinedArea(combinedArea);
    1:       if (*aKeepReflowGoing) {
    1:         // Some of the child block fit
    1:         
    1:         // Advance to new Y position
    1:         nscoord newY = aLine->mBounds.YMost();
    1:         aState.mY = newY;
    1:         
    1:         // Continue the block frame now if it didn't completely fit in
    1:         // the available space.
 4006:         if (!NS_FRAME_IS_FULLY_COMPLETE(frameReflowStatus)) {
    1:           PRBool madeContinuation;
    1:           rv = CreateContinuationFor(aState, nsnull, frame, madeContinuation);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1:           
    1:           nsIFrame* nextFrame = frame->GetNextInFlow();
 4006:           NS_ASSERTION(nextFrame, "We're supposed to have a next-in-flow by now");
 4006:           
 4006:           if (NS_FRAME_IS_NOT_COMPLETE(frameReflowStatus)) {
 4006:             // If nextFrame used to be an overflow container, make it a normal block
 4006:             if (!madeContinuation &&
 4006:                 (NS_FRAME_IS_OVERFLOW_CONTAINER & nextFrame->GetStateBits())) {
32448:               aState.mOverflowTracker->Finish(frame);
 4006:               nsContainerFrame* parent =
 4006:                 static_cast<nsContainerFrame*>(nextFrame->GetParent());
 4006:               rv = parent->StealFrame(aState.mPresContext, nextFrame);
 4006:               NS_ENSURE_SUCCESS(rv, rv);
 6800:               if (parent != this)
 4006:                 ReparentFrame(nextFrame, parent, this);
33276:               mFrames.InsertFrame(nsnull, frame, nextFrame);
 4006:               madeContinuation = PR_TRUE; // needs to be added to mLines
 4006:               nextFrame->RemoveStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 4006:               frameReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
 4006:             }
    1: 
    1:             // Push continuation to a new line, but only if we actually made one.
    1:             if (madeContinuation) {
    1:               nsLineBox* line = aState.NewLineBox(nextFrame, 1, PR_TRUE);
    1:               NS_ENSURE_TRUE(line, NS_ERROR_OUT_OF_MEMORY);
    1:               mLines.after_insert(aLine, line);
    1:             }
    1: 
    1:             PushLines(aState, aLine);
 4006:             NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
 4006: 
    1:             // If we need to reflow the continuation of the block child,
    1:             // then we'd better reflow our continuation
    1:             if (frameReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
    1:               aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
    1:               // We also need to make that continuation's line dirty so
    1:               // it gets reflowed when we reflow our next in flow. The
    1:               // nif's line must always be either a line of the nif's
    1:               // parent block (only if we didn't make a continuation) or
    1:               // else one of our own overflow lines. In the latter case
    1:               // the line is already marked dirty, so just handle the
    1:               // first case.
    1:               if (!madeContinuation) {
 9572:                 nsBlockFrame* nifBlock =
 9572:                   nsLayoutUtils::GetAsBlock(nextFrame->GetParent());
 9572:                 NS_ASSERTION(nifBlock,
    1:                              "A block's child's next in flow's parent must be a block!");
    1:                 for (line_iterator line = nifBlock->begin_lines(),
    1:                      line_end = nifBlock->end_lines(); line != line_end; ++line) {
    1:                   if (line->Contains(nextFrame)) {
    1:                     line->MarkDirty();
    1:                     break;
    1:                   }
    1:                 }
    1:               }
    1:             }
    1:             *aKeepReflowGoing = PR_FALSE;
    1:             
    1:             // The bottom margin for a block is only applied on the last
    1:             // flow block. Since we just continued the child block frame,
    1:             // we know that line->mFirstChild is not the last flow block
    1:             // therefore zero out the running margin value.
    1: #ifdef NOISY_VERTICAL_MARGINS
    1:             ListTag(stdout);
    1:             printf(": reflow incomplete, frame=");
    1:             nsFrame::ListTag(stdout, frame);
    1:             printf(" prevBottomMargin=%d, setting to zero\n",
    1:                    aState.mPrevBottomMargin);
    1: #endif
    1:             aState.mPrevBottomMargin.Zero();
    1:           }
 4006:           else { // frame is complete but its overflow is not complete
 4006:             // Disconnect the next-in-flow and put it in our overflow tracker
 4006:             if (!madeContinuation &&
 4006:                 !(NS_FRAME_IS_OVERFLOW_CONTAINER & nextFrame->GetStateBits())) {
 4006:               // It already exists, but as a normal next-in-flow, so we need
 4006:               // to dig it out of the child lists.
 4006:               nsContainerFrame* parent = static_cast<nsContainerFrame*>
 4006:                                            (nextFrame->GetParent());
 4006:               rv = parent->StealFrame(aState.mPresContext, nextFrame);
 4006:               NS_ENSURE_SUCCESS(rv, rv);
 4006:             }
 4006:             else if (madeContinuation) {
33388:               mFrames.RemoveFrame(nextFrame);
 4006:             }
 4006: 
 4006:             // Put it in our overflow list
32448:             aState.mOverflowTracker->Insert(nextFrame, frameReflowStatus);
15183:             NS_MergeReflowStatusInto(&aState.mReflowStatus, frameReflowStatus);
 4006: 
 4006: #ifdef NOISY_VERTICAL_MARGINS
 4006:             ListTag(stdout);
 4006:             printf(": reflow complete but overflow incomplete for ");
 4006:             nsFrame::ListTag(stdout, frame);
 4006:             printf(" prevBottomMargin=%d collapsedBottomMargin=%d\n",
 4006:                    aState.mPrevBottomMargin, collapsedBottomMargin.get());
 4006: #endif
 4006:             aState.mPrevBottomMargin = collapsedBottomMargin;
 4006:           }
 4006:         }
 4006:         else { // frame is fully complete
    1: #ifdef NOISY_VERTICAL_MARGINS
    1:           ListTag(stdout);
    1:           printf(": reflow complete for ");
    1:           nsFrame::ListTag(stdout, frame);
    1:           printf(" prevBottomMargin=%d collapsedBottomMargin=%d\n",
    1:                  aState.mPrevBottomMargin, collapsedBottomMargin.get());
    1: #endif
    1:           aState.mPrevBottomMargin = collapsedBottomMargin;
    1:         }
    1: #ifdef NOISY_VERTICAL_MARGINS
    1:         ListTag(stdout);
    1:         printf(": frame=");
    1:         nsFrame::ListTag(stdout, frame);
    1:         printf(" carriedOutBottomMargin=%d collapsedBottomMargin=%d => %d\n",
    1:                brc.GetCarriedOutBottomMargin(), collapsedBottomMargin.get(),
    1:                aState.mPrevBottomMargin);
    1: #endif
    1:       }
    1:       else {
    1:         // None of the block fits. Determine the correct reflow status.
30231:         if (aLine == mLines.front() && !GetPrevInFlow()) {
    1:           // If it's our very first line then we need to be pushed to
    1:           // our parents next-in-flow. Therefore, return break-before
    1:           // status for our reflow status.
    1:           aState.mReflowStatus = NS_INLINE_LINE_BREAK_BEFORE();
    1:         }
    1:         else {
    1:           // Push the line that didn't fit and any lines that follow it
    1:           // to our next-in-flow.
    1:           PushLines(aState, aLine.prev());
 4006:           NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
    1:         }
    1:       }
    1:     }
    1:     break; // out of the reflow retry loop
    1:   }
    1: 
  375:   // Now that we've got its final position all figured out, position any child
  375:   // views it may have.  Note that the case when frame has a view got handled
  375:   // by FinishReflowChild, but that function didn't have the coordinates needed
  375:   // to correctly decide whether to reposition child views.
  375:   if (originalPosition != frame->GetPosition() && !frame->HasView()) {
  375:     nsContainerFrame::PositionChildViews(frame);
  375:   }
  375:   
    1: #ifdef DEBUG
    1:   VerifyLines(PR_TRUE);
    1: #endif
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsBlockFrame::ReflowInlineFrames(nsBlockReflowState& aState,
    1:                                  line_iterator aLine,
    1:                                  PRBool* aKeepReflowGoing)
    1: {
    1:   nsresult rv = NS_OK;
    1:   *aKeepReflowGoing = PR_TRUE;
    1: 
28638:   aLine->SetLineIsImpactedByFloat(PR_FALSE);
28638: 
28638:   // Setup initial coordinate system for reflowing the inline frames
28638:   // into. Apply a previous block frame's bottom margin first.
28638:   if (ShouldApplyTopMargin(aState, aLine)) {
28638:     aState.mY += aState.mPrevBottomMargin.get();
28638:   }
28638:   nsFlowAreaRect floatAvailableSpace = aState.GetFloatAvailableSpace();
28638: 
    1: #ifdef DEBUG
    1:   PRInt32 spins = 0;
    1: #endif
48984:   LineReflowStatus lineReflowStatus;
    1:   do {
29265:     nscoord availableSpaceHeight = 0;
29265:     do {
    1:       PRBool allowPullUp = PR_TRUE;
    1:       nsIContent* forceBreakInContent = nsnull;
    1:       PRInt32 forceBreakOffset = -1;
16166:       gfxBreakPriority forceBreakPriority = eNoBreak;
    1:       do {
23305:         nsFloatManager::SavedState floatManagerState;
23305:         aState.mReflowState.mFloatManager->PushState(&floatManagerState);
    1: 
    1:         // Once upon a time we allocated the first 30 nsLineLayout objects
    1:         // on the stack, and then we switched to the heap.  At that time
    1:         // these objects were large (1100 bytes on a 32 bit system).
    1:         // Then the nsLineLayout object was shrunk to 156 bytes by
    1:         // removing some internal buffers.  Given that it is so much
    1:         // smaller, the complexity of 2 different ways of allocating
 5593:         // no longer makes sense.  Now we always allocate on the stack.
    1:         nsLineLayout lineLayout(aState.mPresContext,
23305:                                 aState.mReflowState.mFloatManager,
    1:                                 &aState.mReflowState, &aLine);
    1:         lineLayout.Init(&aState, aState.mMinLineHeight, aState.mLineNumber);
    1:         if (forceBreakInContent) {
    1:           lineLayout.ForceBreakAtPosition(forceBreakInContent, forceBreakOffset);
    1:         }
    1:         rv = DoReflowInlineFrames(aState, lineLayout, aLine,
29265:                                   floatAvailableSpace, availableSpaceHeight,
29265:                                   &floatManagerState, aKeepReflowGoing,
29265:                                   &lineReflowStatus, allowPullUp);
    1:         lineLayout.EndLineReflow();
    1: 
29265:         if (NS_FAILED(rv)) {
29265:           return rv;
29265:         }
29265: 
    1:         if (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus ||
28638:             LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus ||
    1:             LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
    1:           if (lineLayout.NeedsBackup()) {
    1:             NS_ASSERTION(!forceBreakInContent, "Backing up twice; this should never be necessary");
    1:             // If there is no saved break position, then this will set
    1:             // set forceBreakInContent to null and we won't back up, which is
    1:             // correct.
16166:             forceBreakInContent = lineLayout.GetLastOptionalBreakPosition(&forceBreakOffset, &forceBreakPriority);
    1:           } else {
    1:             forceBreakInContent = nsnull;
    1:           }
23305:           // restore the float manager state
23305:           aState.mReflowState.mFloatManager->PopState(&floatManagerState);
    1:           // Clear out float lists
    1:           aState.mCurrentLineFloats.DeleteAll();
    1:           aState.mBelowCurrentLineFloats.DeleteAll();
    1:         }
    1:         
    1:   #ifdef DEBUG
    1:         spins++;
    1:         if (1000 == spins) {
    1:           ListTag(stdout);
    1:           printf(": yikes! spinning on a line over 1000 times!\n");
    1:           NS_ABORT();
    1:         }
    1:   #endif
    1: 
    1:         // Don't allow pullup on a subsequent LINE_REFLOW_REDO_NO_PULL pass
    1:         allowPullUp = PR_FALSE;
29265:       } while (LINE_REFLOW_REDO_NO_PULL == lineReflowStatus);
29265:     } while (LINE_REFLOW_REDO_MORE_FLOATS == lineReflowStatus);
29265:   } while (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus);
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
48996: nsBlockFrame::PushTruncatedLine(nsBlockReflowState& aState,
    1:                                 line_iterator       aLine,
    1:                                 PRBool&             aKeepReflowGoing)
    1: {
    1:   line_iterator prevLine = aLine;
    1:   --prevLine;
    1:   PushLines(aState, prevLine);
    1:   aKeepReflowGoing = PR_FALSE;
 4006:   NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
    1: }
    1: 
    1: #ifdef DEBUG
    1: static const char* LineReflowStatusNames[] = {
    1:   "LINE_REFLOW_OK", "LINE_REFLOW_STOP", "LINE_REFLOW_REDO_NO_PULL",
28638:   "LINE_REFLOW_REDO_MORE_FLOATS",
    1:   "LINE_REFLOW_REDO_NEXT_BAND", "LINE_REFLOW_TRUNCATED"
    1: };
    1: #endif
    1: 
    1: nsresult
    1: nsBlockFrame::DoReflowInlineFrames(nsBlockReflowState& aState,
    1:                                    nsLineLayout& aLineLayout,
    1:                                    line_iterator aLine,
28638:                                    nsFlowAreaRect& aFloatAvailableSpace,
29265:                                    nscoord& aAvailableSpaceHeight,
28638:                                    nsFloatManager::SavedState*
28638:                                      aFloatStateBeforeLine,
    1:                                    PRBool* aKeepReflowGoing,
    1:                                    LineReflowStatus* aLineReflowStatus,
    1:                                    PRBool aAllowPullUp)
    1: {
    1:   // Forget all of the floats on the line
    1:   aLine->FreeFloats(aState.mFloatCacheFreeList);
    1:   aState.mFloatCombinedArea.SetRect(0, 0, 0, 0);
    1: 
28638:   // We need to set this flag on the line if any of our reflow passes
28638:   // are impacted by floats.
28638:   if (aFloatAvailableSpace.mHasFloats)
28638:     aLine->SetLineIsImpactedByFloat(PR_TRUE);
    1: #ifdef REALLY_NOISY_REFLOW
    1:   printf("nsBlockFrame::DoReflowInlineFrames %p impacted = %d\n",
28638:          this, aFloatAvailableSpace.mHasFloats);
    1: #endif
    1: 
49569:   nscoord x = aFloatAvailableSpace.mRect.x;
28638:   nscoord availWidth = aFloatAvailableSpace.mRect.width;
    1:   nscoord availHeight;
    1:   if (aState.GetFlag(BRS_UNCONSTRAINEDHEIGHT)) {
    1:     availHeight = NS_UNCONSTRAINEDSIZE;
    1:   }
    1:   else {
    1:     /* XXX get the height right! */
28638:     availHeight = aFloatAvailableSpace.mRect.height;
    1:   }
 1668: 
 1668:   // Make sure to enable resize optimization before we call BeginLineReflow
 1668:   // because it might get disabled there
 1668:   aLine->EnableResizeReflowOptimization();
 1668: 
    1:   aLineLayout.BeginLineReflow(x, aState.mY,
    1:                               availWidth, availHeight,
28638:                               aFloatAvailableSpace.mHasFloats,
    1:                               PR_FALSE /*XXX isTopOfPage*/);
    1: 
22003:   aState.SetFlag(BRS_LINE_LAYOUT_EMPTY, PR_FALSE);
22003: 
    1:   // XXX Unfortunately we need to know this before reflowing the first
    1:   // inline frame in the line. FIX ME.
    1:   if ((0 == aLineLayout.GetLineNumber()) &&
 8759:       (NS_BLOCK_HAS_FIRST_LETTER_CHILD & mState) &&
    1:       (NS_BLOCK_HAS_FIRST_LETTER_STYLE & mState)) {
    1:     aLineLayout.SetFirstLetterStyleOK(PR_TRUE);
    1:   }
36804:   NS_ASSERTION(!((NS_BLOCK_HAS_FIRST_LETTER_CHILD & mState) &&
36804:                  GetPrevContinuation()),
36804:                "first letter child bit should only be on first continuation");
    1: 
    1:   // Reflow the frames that are already on the line first
    1:   nsresult rv = NS_OK;
    1:   LineReflowStatus lineReflowStatus = LINE_REFLOW_OK;
    1:   PRInt32 i;
    1:   nsIFrame* frame = aLine->mFirstChild;
    1: 
28638:   if (aFloatAvailableSpace.mHasFloats) {
    1:     // There is a soft break opportunity at the start of the line, because
    1:     // we can always move this line down below float(s).
16166:     if (aLineLayout.NotifyOptionalBreakPosition(frame->GetContent(), 0, PR_TRUE, eNormalBreak)) {
    1:       lineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
    1:     }
    1:   }
    1: 
    1:   // need to repeatedly call GetChildCount here, because the child
    1:   // count can change during the loop!
    1:   for (i = 0; LINE_REFLOW_OK == lineReflowStatus && i < aLine->GetChildCount();
    1:        i++, frame = frame->GetNextSibling()) {
    1:     rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
    1:                            &lineReflowStatus);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (LINE_REFLOW_OK != lineReflowStatus) {
    1:       // It is possible that one or more of next lines are empty
    1:       // (because of DeleteNextInFlowChild). If so, delete them now
    1:       // in case we are finished.
    1:       ++aLine;
    1:       while ((aLine != end_lines()) && (0 == aLine->GetChildCount())) {
    1:         // XXX Is this still necessary now that DeleteNextInFlowChild
    1:         // uses DoRemoveFrame?
    1:         nsLineBox *toremove = aLine;
    1:         aLine = mLines.erase(aLine);
    1:         NS_ASSERTION(nsnull == toremove->mFirstChild, "bad empty line");
    1:         aState.FreeLineBox(toremove);
    1:       }
    1:       --aLine;
    1: 
48994:       NS_ASSERTION(lineReflowStatus != LINE_REFLOW_TRUNCATED,
48994:                    "ReflowInlineFrame should never determine that a line "
48994:                    "needs to go to the next page/column");
    1:     }
    1:   }
    1: 
    1:   // Don't pull up new frames into lines with continuation placeholders
32106:   if (aAllowPullUp) {
    1:     // Pull frames and reflow them until we can't
    1:     while (LINE_REFLOW_OK == lineReflowStatus) {
36987:       frame = PullFrame(aState, aLine);
36987:       if (!frame) {
    1:         break;
    1:       }
    1: 
    1:       while (LINE_REFLOW_OK == lineReflowStatus) {
    1:         PRInt32 oldCount = aLine->GetChildCount();
    1:         rv = ReflowInlineFrame(aState, aLineLayout, aLine, frame,
    1:                                &lineReflowStatus);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         if (aLine->GetChildCount() != oldCount) {
    1:           // We just created a continuation for aFrame AND its going
    1:           // to end up on this line (e.g. :first-letter
    1:           // situation). Therefore we have to loop here before trying
    1:           // to pull another frame.
    1:           frame = frame->GetNextSibling();
    1:         }
    1:         else {
    1:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
22003:   aState.SetFlag(BRS_LINE_LAYOUT_EMPTY, aLineLayout.LineIsEmpty());
22003: 
    1:   // We only need to backup if the line isn't going to be reflowed again anyway
    1:   PRBool needsBackup = aLineLayout.NeedsBackup() &&
    1:     (lineReflowStatus == LINE_REFLOW_STOP || lineReflowStatus == LINE_REFLOW_OK);
    1:   if (needsBackup && aLineLayout.HaveForcedBreakPosition()) {
    1:   	NS_WARNING("We shouldn't be backing up more than once! "
    1:                "Someone must have set a break opportunity beyond the available width, "
    1:                "even though there were better break opportunities before it");
    1:     needsBackup = PR_FALSE;
    1:   }
    1:   if (needsBackup) {
    1:     // We need to try backing up to before a text run
    1:     PRInt32 offset;
16166:     gfxBreakPriority breakPriority;
16166:     nsIContent* breakContent = aLineLayout.GetLastOptionalBreakPosition(&offset, &breakPriority);
    7:     // XXX It's possible, in fact not unusual, for the break opportunity to already
    7:     // be the end of the line. We should detect that and optimize to not
    7:     // re-do the line.
    1:     if (breakContent) {
    1:       // We can back up!
    1:       lineReflowStatus = LINE_REFLOW_REDO_NO_PULL;
    1:     }
    1:   } else {
    1:     // In case we reflow this line again, remember that we don't
    1:     // need to force any breaking
    1:     aLineLayout.ClearOptionalBreakPosition();
    1:   }
    1: 
    1:   if (LINE_REFLOW_REDO_NEXT_BAND == lineReflowStatus) {
    1:     // This happens only when we have a line that is impacted by
    1:     // floats and the first element in the line doesn't fit with
    1:     // the floats.
    1:     //
    1:     // What we do is to advance past the first float we find and
    1:     // then reflow the line all over again.
28638:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aFloatAvailableSpace.mRect.height,
    1:                  "unconstrained height on totally empty line");
    1: 
10895:     // See the analogous code for blocks in nsBlockReflowState::ClearFloats.
28638:     if (aFloatAvailableSpace.mRect.height > 0) {
28638:       NS_ASSERTION(aFloatAvailableSpace.mHasFloats,
 6777:                    "redo line on totally empty line with non-empty band...");
28638:       // We should never hit this case if we've placed floats on the
28638:       // line; if we have, then the GetFloatAvailableSpace call is wrong
28638:       // and needs to happen after the caller pops the space manager
28638:       // state.
28638:       aState.mFloatManager->AssertStateMatches(aFloatStateBeforeLine);
28638:       aState.mY += aFloatAvailableSpace.mRect.height;
28638:       aFloatAvailableSpace = aState.GetFloatAvailableSpace();
    1:     } else {
    1:       NS_ASSERTION(NS_UNCONSTRAINEDSIZE != aState.mReflowState.availableHeight,
    1:                    "We shouldn't be running out of height here");
    1:       if (NS_UNCONSTRAINEDSIZE == aState.mReflowState.availableHeight) {
    1:         // just move it down a bit to try to get out of this mess
    1:         aState.mY += 1;
28638:         // We should never hit this case if we've placed floats on the
28638:         // line; if we have, then the GetFloatAvailableSpace call is wrong
28638:         // and needs to happen after the caller pops the space manager
28638:         // state.
28638:         aState.mFloatManager->AssertStateMatches(aFloatStateBeforeLine);
28638:         aFloatAvailableSpace = aState.GetFloatAvailableSpace();
    1:       } else {
48994:         // There's nowhere to retry placing the line, so we want to push
48994:         // it to the next page/column where its contents can fit not
48994:         // next to a float.
    1:         lineReflowStatus = LINE_REFLOW_TRUNCATED;
    1:         // Push the line that didn't fit
48996:         PushTruncatedLine(aState, aLine, *aKeepReflowGoing);
    1:       }
    1:     }
    1: 
    1:     // XXX: a small optimization can be done here when paginating:
    1:     // if the new Y coordinate is past the end of the block then
    1:     // push the line and return now instead of later on after we are
    1:     // past the float.
    1:   }
28638:   else if (LINE_REFLOW_TRUNCATED != lineReflowStatus &&
28638:            LINE_REFLOW_REDO_NO_PULL != lineReflowStatus) {
    1:     // If we are propagating out a break-before status then there is
    1:     // no point in placing the line.
    1:     if (!NS_INLINE_IS_BREAK_BEFORE(aState.mReflowStatus)) {
28638:       if (!PlaceLine(aState, aLineLayout, aLine, aFloatStateBeforeLine,
29265:                      aFloatAvailableSpace.mRect, aAvailableSpaceHeight,
29265:                      aKeepReflowGoing)) {
28638:         lineReflowStatus = LINE_REFLOW_REDO_MORE_FLOATS;
28638:         // PlaceLine already called GetAvailableSpaceForHeight for us.
28638:       }
    1:     }
    1:   }
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     printf("Line reflow status = %s\n", LineReflowStatusNames[lineReflowStatus]);
    1:   }
    1: #endif
34500: 
34500:   if (aLineLayout.GetDirtyNextLine()) {
34500:     // aLine may have been pushed to the overflow lines.
34500:     nsLineList* overflowLines = GetOverflowLines();
34500:     // We can't just compare iterators front() to aLine here, since they may be in
34500:     // different lists.
34500:     PRBool pushedToOverflowLines = overflowLines &&
34500:       overflowLines->front() == aLine.get();
34500:     if (pushedToOverflowLines) {
34500:       // aLine is stale, it's associated with the main line list but it should
34500:       // be associated with the overflow line list now
34500:       aLine = overflowLines->begin();
34500:     }
34500:     nsBlockInFlowLineIterator iter(this, aLine, pushedToOverflowLines);
34500:     if (iter.Next() && iter.GetLine()->IsInline()) {
34500:       iter.GetLine()->MarkDirty();
34500:       if (iter.GetContainer() != this) {
34500:         aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
34500:       }
34500:     }
34500:   }
34500: 
    1:   *aLineReflowStatus = lineReflowStatus;
    1: 
    1:   return rv;
    1: }
    1: 
    1: /**
    1:  * Reflow an inline frame. The reflow status is mapped from the frames
    1:  * reflow status to the lines reflow status (not to our reflow status).
    1:  * The line reflow status is simple: PR_TRUE means keep placing frames
    1:  * on the line; PR_FALSE means don't (the line is done). If the line
    1:  * has some sort of breaking affect then aLine's break-type will be set
    1:  * to something other than NS_STYLE_CLEAR_NONE.
    1:  */
    1: nsresult
    1: nsBlockFrame::ReflowInlineFrame(nsBlockReflowState& aState,
    1:                                 nsLineLayout& aLineLayout,
    1:                                 line_iterator aLine,
    1:                                 nsIFrame* aFrame,
    1:                                 LineReflowStatus* aLineReflowStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFrame);
    1:   
    1:   *aLineReflowStatus = LINE_REFLOW_OK;
    1: 
    1: #ifdef NOISY_FIRST_LETTER
    1:   ListTag(stdout);
    1:   printf(": reflowing ");
    1:   nsFrame::ListTag(stdout, aFrame);
16409:   printf(" reflowingFirstLetter=%s\n",
16409:          aLineLayout.GetFirstLetterStyleOK() ? "on" : "off");
    1: #endif
    1: 
    1:   // Reflow the inline frame
    1:   nsReflowStatus frameReflowStatus;
    1:   PRBool         pushedFrame;
    1:   nsresult rv = aLineLayout.ReflowFrame(aFrame, frameReflowStatus,
    1:                                         nsnull, pushedFrame);
  709:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (frameReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
34500:     aLineLayout.SetDirtyNextLine();
    1:   }
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: #ifdef REALLY_NOISY_REFLOW_CHILD
    1:   nsFrame::ListTag(stdout, aFrame);
    1:   printf(": status=%x\n", frameReflowStatus);
    1: #endif
    1: 
    1: #if defined(REFLOW_STATUS_COVERAGE)
    1:   RecordReflowStatus(PR_FALSE, frameReflowStatus);
    1: #endif
    1: 
    1:   // Send post-reflow notification
    1:   aState.mPrevChild = aFrame;
    1: 
    1:    /* XXX
    1:       This is where we need to add logic to handle some odd behavior.
    1:       For one thing, we should usually place at least one thing next
    1:       to a left float, even when that float takes up all the width on a line.
    1:       see bug 22496
    1:    */
    1: 
    1:   // Process the child frames reflow status. There are 5 cases:
    1:   // complete, not-complete, break-before, break-after-complete,
    1:   // break-after-not-complete. There are two situations: we are a
    1:   // block or we are an inline. This makes a total of 10 cases
    1:   // (fortunately, there is some overlap).
    1:   aLine->SetBreakTypeAfter(NS_STYLE_CLEAR_NONE);
    1:   if (NS_INLINE_IS_BREAK(frameReflowStatus) || 
    1:       (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType)) {
    1:     // Always abort the line reflow (because a line break is the
    1:     // minimal amount of break we do).
    1:     *aLineReflowStatus = LINE_REFLOW_STOP;
    1: 
    1:     // XXX what should aLine's break-type be set to in all these cases?
    1:     PRUint8 breakType = NS_INLINE_GET_BREAK_TYPE(frameReflowStatus);
    1:     NS_ASSERTION((NS_STYLE_CLEAR_NONE != breakType) || 
    1:                  (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType), "bad break type");
    1:     NS_ASSERTION(NS_STYLE_CLEAR_PAGE != breakType, "no page breaks yet");
    1: 
    1:     if (NS_INLINE_IS_BREAK_BEFORE(frameReflowStatus)) {
    1:       // Break-before cases.
    1:       if (aFrame == aLine->mFirstChild) {
    1:         // If we break before the first frame on the line then we must
    1:         // be trying to place content where there's no room (e.g. on a
    1:         // line with wide floats). Inform the caller to reflow the
    1:         // line after skipping past a float.
    1:         *aLineReflowStatus = LINE_REFLOW_REDO_NEXT_BAND;
    1:       }
    1:       else {
    1:         // It's not the first child on this line so go ahead and split
    1:         // the line. We will see the frame again on the next-line.
    1:         rv = SplitLine(aState, aLineLayout, aLine, aFrame, aLineReflowStatus);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         // If we're splitting the line because the frame didn't fit and it
    1:         // was pushed, then mark the line as having word wrapped. We need to
    1:         // know that if we're shrink wrapping our width
    1:         if (pushedFrame) {
    1:           aLine->SetLineWrapped(PR_TRUE);
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       // If a float split and its prev-in-flow was followed by a <BR>, then combine 
    1:       // the <BR>'s break type with the inline's break type (the inline will be the very 
    1:       // next frame after the split float).
    1:       if (NS_STYLE_CLEAR_NONE != aState.mFloatBreakType) {
    1:         breakType = nsLayoutUtils::CombineBreakType(breakType,
    1:                                                     aState.mFloatBreakType);
    1:         aState.mFloatBreakType = NS_STYLE_CLEAR_NONE;
    1:       }
    1:       // Break-after cases
    1:       if (breakType == NS_STYLE_CLEAR_LINE) {
    1:         if (!aLineLayout.GetLineEndsInBR()) {
    1:           breakType = NS_STYLE_CLEAR_NONE;
    1:         }
    1:       }
    1:       aLine->SetBreakTypeAfter(breakType);
14049:       if (NS_FRAME_IS_COMPLETE(frameReflowStatus)) {
    1:         // Split line, but after the frame just reflowed
    1:         rv = SplitLine(aState, aLineLayout, aLine, aFrame->GetNextSibling(), aLineReflowStatus);
    1:         NS_ENSURE_SUCCESS(rv, rv);
31144: 
31144:         if (NS_INLINE_IS_BREAK_AFTER(frameReflowStatus) &&
31144:             !aLineLayout.GetLineEndsInBR()) {
34500:           aLineLayout.SetDirtyNextLine();
31144:         }
    1:       }
    1:     }
14049:   }
14049: 
32108:   if (!NS_FRAME_IS_FULLY_COMPLETE(frameReflowStatus)) {
    1:     // Create a continuation for the incomplete frame. Note that the
    1:     // frame may already have a continuation.
14049:     nsIAtom* frameType = aFrame->GetType();
14049: 
    1:     PRBool madeContinuation;
32106:     rv = CreateContinuationFor(aState, aLine, aFrame, madeContinuation);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Remember that the line has wrapped
    1:     if (!aLineLayout.GetLineEndsInBR()) {
    1:       aLine->SetLineWrapped(PR_TRUE);
    1:     }
    1:     
16409:     // If we just ended a first-letter frame or reflowed a placeholder then 
    1:     // don't split the line and don't stop the line reflow...
37869:     // But if we are going to stop anyways we'd better split the line.
37869:     if ((!(frameReflowStatus & NS_INLINE_BREAK_FIRST_LETTER_COMPLETE) && 
37869:          nsGkAtoms::placeholderFrame != frameType) ||
37869:         *aLineReflowStatus == LINE_REFLOW_STOP) {
    1:       // Split line after the current frame
    1:       *aLineReflowStatus = LINE_REFLOW_STOP;
    1:       rv = SplitLine(aState, aLineLayout, aLine, aFrame->GetNextSibling(), aLineReflowStatus);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBlockFrame::CreateContinuationFor(nsBlockReflowState& aState,
    1:                                     nsLineBox*          aLine,
    1:                                     nsIFrame*           aFrame,
    1:                                     PRBool&             aMadeNewFrame)
    1: {
    1:   aMadeNewFrame = PR_FALSE;
32841: 
32841:   if (!aFrame->GetNextInFlow()) {
32841:     nsIFrame* newFrame;
32841:     nsresult rv = aState.mPresContext->PresShell()->FrameConstructor()->
32841:       CreateContinuingFrame(aState.mPresContext, aFrame, this, &newFrame);
32841:     if (NS_FAILED(rv)) {
32841:       return rv;
32841:     }
32841: 
33276:     mFrames.InsertFrame(nsnull, aFrame, newFrame);
32841: 
    1:     if (aLine) { 
    1:       aLine->SetChildCount(aLine->GetChildCount() + 1);
    1:     }
32841: 
32841:     aMadeNewFrame = PR_TRUE;
    1:   }
    1: #ifdef DEBUG
    1:   VerifyLines(PR_FALSE);
    1: #endif
32841:   return NS_OK;
    1: }
    1: 
    1: nsresult
32108: nsBlockFrame::SplitFloat(nsBlockReflowState& aState,
32108:                          nsIFrame*           aFloat,
32108:                          nsReflowStatus      aFloatStatus)
    1: {
48989:   nsIFrame* nextInFlow = aFloat->GetNextInFlow();
48989:   if (nextInFlow) {
48989:     nsContainerFrame *oldParent =
48989:       static_cast<nsContainerFrame*>(nextInFlow->GetParent());
48989:     nsresult rv = oldParent->StealFrame(aState.mPresContext, nextInFlow);
48989:     NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failed");
48989:     if (oldParent != this) {
48989:       ReparentFrame(nextInFlow, oldParent, this);
48989:     }
48989:   } else {
32841:     nsresult rv = aState.mPresContext->PresShell()->FrameConstructor()->
32841:       CreateContinuingFrame(aState.mPresContext, aFloat, this, &nextInFlow);
    1:     NS_ENSURE_SUCCESS(rv, rv);
32841:   }
32108:   if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aFloatStatus))
32108:     aFloat->GetNextInFlow()->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
32108: 
48994:   // The containing block is now overflow-incomplete.
48994:   NS_FRAME_SET_OVERFLOW_INCOMPLETE(aState.mReflowStatus);
    1: 
48986:   if (aFloat->GetStyleDisplay()->mFloats == NS_STYLE_FLOAT_LEFT) {
48986:     aState.mFloatManager->SetSplitLeftFloatAcrossBreak();
48986:   } else {
48986:     NS_ABORT_IF_FALSE(aFloat->GetStyleDisplay()->mFloats ==
48986:                         NS_STYLE_FLOAT_RIGHT, "unexpected float side");
48986:     aState.mFloatManager->SetSplitRightFloatAcrossBreak();
48986:   }
48986: 
49010:   aState.AppendPushedFloat(nextInFlow);
    1:   return NS_OK;
    1: }
    1: 
    1: static nsFloatCache*
    1: GetLastFloat(nsLineBox* aLine)
    1: {
    1:   nsFloatCache* fc = aLine->GetFirstFloat();
    1:   while (fc && fc->Next()) {
    1:     fc = fc->Next();
    1:   }
    1:   return fc;
    1: }
    1: 
    1: static PRBool
    1: CheckPlaceholderInLine(nsIFrame* aBlock, nsLineBox* aLine, nsFloatCache* aFC)
    1: {
48989:   if (!aFC)
    1:     return PR_TRUE;
48989:   NS_ASSERTION(!aFC->mFloat->GetPrevContinuation(),
48989:                "float in a line should never be a continuation");
49010:   NS_ASSERTION(!(aFC->mFloat->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT),
48989:                "float in a line should never be a pushed float");
32107:   nsIFrame* ph = aBlock->PresContext()->FrameManager()->
32107:                    GetPlaceholderFrameFor(aFC->mFloat->GetFirstInFlow());
32107:   for (nsIFrame* f = ph; f; f = f->GetParent()) {
    1:     if (f->GetParent() == aBlock)
    1:       return aLine->Contains(f);
    1:   }
    1:   NS_ASSERTION(PR_FALSE, "aBlock is not an ancestor of aFrame!");
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsBlockFrame::SplitLine(nsBlockReflowState& aState,
    1:                         nsLineLayout& aLineLayout,
    1:                         line_iterator aLine,
    1:                         nsIFrame* aFrame,
    1:                         LineReflowStatus* aLineReflowStatus)
    1: {
    1:   NS_ABORT_IF_FALSE(aLine->IsInline(), "illegal SplitLine on block line");
    1: 
    1:   PRInt32 pushCount = aLine->GetChildCount() - aLineLayout.GetCurrentSpanCount();
    1:   NS_ABORT_IF_FALSE(pushCount >= 0, "bad push count"); 
    1: 
    1: #ifdef DEBUG
    1:   if (gNoisyReflow) {
    1:     nsFrame::IndentBy(stdout, gNoiseIndent);
    1:     printf("split line: from line=%p pushCount=%d aFrame=",
 3233:            static_cast<void*>(aLine.get()), pushCount);
    1:     if (aFrame) {
    1:       nsFrame::ListTag(stdout, aFrame);
    1:     }
    1:     else {
    1:       printf("(null)");
    1:     }
    1:     printf("\n");
    1:     if (gReallyNoisyReflow) {
    1:       aLine->List(stdout, gNoiseIndent+1);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   if (0 != pushCount) {
    1:     NS_ABORT_IF_FALSE(aLine->GetChildCount() > pushCount, "bad push");
    1:     NS_ABORT_IF_FALSE(nsnull != aFrame, "whoops");
50896: #ifdef DEBUG
50896:     {
50896:       nsIFrame *f = aFrame;
50896:       PRInt32 count = pushCount;
50896:       while (f && count > 0) {
50896:         f = f->GetNextSibling();
50896:         --count;
50896:       }
50896:       NS_ASSERTION(count == 0, "Not enough frames to push");
50896:     }
50896: #endif
    1: 
    1:     // Put frames being split out into their own line
    1:     nsLineBox* newLine = aState.NewLineBox(aFrame, pushCount, PR_FALSE);
    1:     if (!newLine) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     mLines.after_insert(aLine, newLine);
    1:     aLine->SetChildCount(aLine->GetChildCount() - pushCount);
    1: #ifdef DEBUG
    1:     if (gReallyNoisyReflow) {
    1:       newLine->List(stdout, gNoiseIndent+1);
    1:     }
    1: #endif
    1: 
    1:     // Let line layout know that some frames are no longer part of its
    1:     // state.
    1:     aLineLayout.SplitLineTo(aLine->GetChildCount());
    1: 
    1:     // If floats have been placed whose placeholders have been pushed to the new
    1:     // line, we need to reflow the old line again. We don't want to look at the
    1:     // frames in the new line, because as a large paragraph is laid out the 
    1:     // we'd get O(N^2) performance. So instead we just check that the last
    1:     // float and the last below-current-line float are still in aLine.
    1:     if (!CheckPlaceholderInLine(this, aLine, GetLastFloat(aLine)) ||
    1:         !CheckPlaceholderInLine(this, aLine, aState.mBelowCurrentLineFloats.Tail())) {
    1:       *aLineReflowStatus = LINE_REFLOW_REDO_NO_PULL;
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     VerifyLines(PR_TRUE);
    1: #endif
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::ShouldJustifyLine(nsBlockReflowState& aState,
    1:                                 line_iterator aLine)
    1: {
    1:   while (++aLine != end_lines()) {
    1:     // There is another line
    1:     if (0 != aLine->GetChildCount()) {
    1:       // If the next line is a block line then we must not justify
    1:       // this line because it means that this line is the last in a
    1:       // group of inline lines.
    1:       return !aLine->IsBlock();
    1:     }
    1:     // The next line is empty, try the next one
    1:   }
    1: 
    1:   // XXX Not sure about this part
    1:   // Try our next-in-flows lines to answer the question
    1:   nsBlockFrame* nextInFlow = (nsBlockFrame*) GetNextInFlow();
    1:   while (nsnull != nextInFlow) {
    1:     for (line_iterator line = nextInFlow->begin_lines(),
    1:                    line_end = nextInFlow->end_lines();
    1:          line != line_end;
    1:          ++line)
    1:     {
    1:       if (0 != line->GetChildCount())
    1:         return !line->IsBlock();
    1:     }
    1:     nextInFlow = (nsBlockFrame*) nextInFlow->GetNextInFlow();
    1:   }
    1: 
    1:   // This is the last line - so don't allow justification
    1:   return PR_FALSE;
    1: }
    1: 
28638: PRBool
    1: nsBlockFrame::PlaceLine(nsBlockReflowState& aState,
    1:                         nsLineLayout&       aLineLayout,
    1:                         line_iterator       aLine,
28638:                         nsFloatManager::SavedState *aFloatStateBeforeLine,
28638:                         nsRect&             aFloatAvailableSpace,
29265:                         nscoord&            aAvailableSpaceHeight,
    1:                         PRBool*             aKeepReflowGoing)
    1: {
    1:   // Trim extra white-space from the line before placing the frames
    1:   aLineLayout.TrimTrailingWhiteSpace();
    1: 
    1:   // Vertically align the frames on this line.
    1:   //
    1:   // According to the CSS2 spec, section 12.6.1, the "marker" box
    1:   // participates in the height calculation of the list-item box's
    1:   // first line box.
    1:   //
    1:   // There are exactly two places a bullet can be placed: near the
    1:   // first or second line. It's only placed on the second line in a
11520:   // rare case: when the first line is empty.
    1:   PRBool addedBullet = PR_FALSE;
11520:   if (mBullet && HaveOutsideBullet() &&
11520:       ((aLine == mLines.front() &&
11520:         (!aLineLayout.IsZeroHeight() || (aLine == mLines.back()))) ||
11520:        (mLines.front() != mLines.back() &&
11520:         0 == mLines.front()->mBounds.height &&
11520:         aLine == mLines.begin().next()))) {
    1:     nsHTMLReflowMetrics metrics;
11520:     ReflowBullet(aState, metrics, aState.mY);
32392:     NS_ASSERTION(!BulletIsEmpty() || metrics.height == 0,
32392:                  "empty bullet took up space");
    1:     aLineLayout.AddBulletFrame(mBullet, metrics);
    1:     addedBullet = PR_TRUE;
    1:   }
    1:   aLineLayout.VerticalAlignLine();
    1: 
28638:   // We want to compare to the available space that we would have had in
28638:   // the line's height *before* we placed any floats in the line itself.
28638:   // Floats that are in the line are handled during line reflow (and may
28638:   // result in floats being pushed to below the line or (I HOPE???) in a
28638:   // reflow with a forced break position).
28638:   nsRect oldFloatAvailableSpace(aFloatAvailableSpace);
29265:   // As we redo for floats, we can't reduce the amount of height we're
29265:   // checking.
32531:   aAvailableSpaceHeight = NS_MAX(aAvailableSpaceHeight, aLine->mBounds.height);
28638:   aFloatAvailableSpace = 
28638:     aState.GetFloatAvailableSpaceForHeight(aLine->mBounds.y,
29265:                                            aAvailableSpaceHeight,
28638:                                            aFloatStateBeforeLine).mRect;
28638:   NS_ASSERTION(aFloatAvailableSpace.y == oldFloatAvailableSpace.y, "yikes");
28638:   // Restore the height to the position of the next band.
28638:   aFloatAvailableSpace.height = oldFloatAvailableSpace.height;
28638:   // If the available space between the floats is smaller now that we
28638:   // know the height, return false (and cause another pass with
28638:   // LINE_REFLOW_REDO_MORE_FLOATS).
28638:   if (AvailableSpaceShrunk(oldFloatAvailableSpace, aFloatAvailableSpace)) {
28638:     return PR_FALSE;
28638:   }
28638: 
    1: #ifdef DEBUG
    1:   {
    1:     static nscoord lastHeight = 0;
    1:     if (CRAZY_HEIGHT(aLine->mBounds.y)) {
    1:       lastHeight = aLine->mBounds.y;
    1:       if (abs(aLine->mBounds.y - lastHeight) > CRAZY_H/10) {
    1:         nsFrame::ListTag(stdout);
    1:         printf(": line=%p y=%d line.bounds.height=%d\n",
 3233:                static_cast<void*>(aLine.get()),
    1:                aLine->mBounds.y, aLine->mBounds.height);
    1:       }
    1:     }
    1:     else {
    1:       lastHeight = 0;
    1:     }
    1:   }
    1: #endif
    1: 
    1:   // Only block frames horizontally align their children because
    1:   // inline frames "shrink-wrap" around their children (therefore
    1:   // there is no extra horizontal space).
    1:   const nsStyleText* styleText = GetStyleText();
    1:   PRBool allowJustify = NS_STYLE_TEXT_ALIGN_JUSTIFY == styleText->mTextAlign &&
    1:                         !aLineLayout.GetLineEndsInBR() &&
    1:                         ShouldJustifyLine(aState, aLine);
    1:   aLineLayout.HorizontalAlignFrames(aLine->mBounds, allowJustify);
    1:   // XXX: not only bidi: right alignment can be broken after
    1:   // RelativePositionFrames!!!
    1:   // XXXldb Is something here considering relatively positioned frames at
    1:   // other than their original positions?
    1: #ifdef IBMBIDI
    1:   // XXXldb Why don't we do this earlier?
    1:   if (aState.mPresContext->BidiEnabled()) {
28200:     if (!aState.mPresContext->IsVisualMode() ||
28200:         GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
    1:       nsBidiPresUtils* bidiUtils = aState.mPresContext->GetBidiUtils();
    1: 
    1:       if (bidiUtils && bidiUtils->IsSuccessful() ) {
 5423:         bidiUtils->ReorderFrames(aLine->mFirstChild, aLine->GetChildCount());
    1:       } // bidiUtils
    1:     } // not visual mode
    1:   } // bidi enabled
    1: #endif // IBMBIDI
    1: 
 8935:   // From here on, pfd->mBounds rectangles are incorrect because bidi
 8935:   // might have moved frames around!
    1:   nsRect combinedArea;
    1:   aLineLayout.RelativePositionFrames(combinedArea);  // XXXldb This returned width as -15, 2001-06-12, Bugzilla
    1:   aLine->SetCombinedArea(combinedArea);
    1:   if (addedBullet) {
    1:     aLineLayout.RemoveBulletFrame(mBullet);
    1:   }
    1: 
    1:   // Inline lines do not have margins themselves; however they are
    1:   // impacted by prior block margins. If this line ends up having some
    1:   // height then we zero out the previous bottom margin value that was
    1:   // already applied to the line's starting Y coordinate. Otherwise we
    1:   // leave it be so that the previous blocks bottom margin can be
    1:   // collapsed with a block that follows.
    1:   nscoord newY;
    1: 
    1:   if (!aLine->CachedIsEmpty()) {
    1:     // This line has some height. Therefore the application of the
    1:     // previous-bottom-margin should stick.
    1:     aState.mPrevBottomMargin.Zero();
    1:     newY = aLine->mBounds.YMost();
    1:   }
    1:   else {
    1:     // Don't let the previous-bottom-margin value affect the newY
    1:     // coordinate (it was applied in ReflowInlineFrames speculatively)
    1:     // since the line is empty.
    1:     // We already called |ShouldApplyTopMargin|, and if we applied it
    1:     // then BRS_APPLYTOPMARGIN is set.
    1:     nscoord dy = aState.GetFlag(BRS_APPLYTOPMARGIN)
    1:                    ? -aState.mPrevBottomMargin.get() : 0;
    1:     newY = aState.mY + dy;
    1:   }
    1: 
    1:   // See if the line fit. If it doesn't we need to push it. Our first
    1:   // line will always fit.
    1:   if (mLines.front() != aLine &&
    1:       newY > aState.mBottomEdge &&
    1:       aState.mBottomEdge != NS_UNCONSTRAINEDSIZE) {
    1:     // Push this line and all of its children and anything else that
    1:     // follows to our next-in-flow
    1:     NS_ASSERTION((aState.mCurrentLine == aLine), "oops");
    1:     PushLines(aState, aLine.prev());
    1: 
    1:     // Stop reflow and whack the reflow status if reflow hasn't
    1:     // already been stopped.
    1:     if (*aKeepReflowGoing) {
 4006:       NS_FRAME_SET_INCOMPLETE(aState.mReflowStatus);
    1:       *aKeepReflowGoing = PR_FALSE;
    1:     }
28638:     return PR_TRUE;
    1:   }
    1: 
    1:   aState.mY = newY;
    1:   
    1:   // Add the already placed current-line floats to the line
    1:   aLine->AppendFloats(aState.mCurrentLineFloats);
    1: 
    1:   // Any below current line floats to place?
    1:   if (aState.mBelowCurrentLineFloats.NotEmpty()) {
48995:     // Reflow the below-current-line floats, which places on the line's
48995:     // float list.
49001:     aState.PlaceBelowCurrentLineFloats(aState.mBelowCurrentLineFloats, aLine);
    1:     aLine->AppendFloats(aState.mBelowCurrentLineFloats);
    1:   }
    1: 
    1:   // When a line has floats, factor them into the combined-area
    1:   // computations.
    1:   if (aLine->HasFloats()) {
    1:     // Combine the float combined area (stored in aState) and the
    1:     // value computed by the line layout code.
    1:     nsRect lineCombinedArea(aLine->GetCombinedArea());
    1: #ifdef NOISY_COMBINED_AREA
    1:     ListTag(stdout);
    1:     printf(": lineCA=%d,%d,%d,%d floatCA=%d,%d,%d,%d\n",
    1:            lineCombinedArea.x, lineCombinedArea.y,
    1:            lineCombinedArea.width, lineCombinedArea.height,
    1:            aState.mFloatCombinedArea.x, aState.mFloatCombinedArea.y,
    1:            aState.mFloatCombinedArea.width,
    1:            aState.mFloatCombinedArea.height);
    1: #endif
    1:     lineCombinedArea.UnionRect(aState.mFloatCombinedArea, lineCombinedArea);
    1: 
    1:     aLine->SetCombinedArea(lineCombinedArea);
    1: #ifdef NOISY_COMBINED_AREA
    1:     printf("  ==> final lineCA=%d,%d,%d,%d\n",
    1:            lineCombinedArea.x, lineCombinedArea.y,
    1:            lineCombinedArea.width, lineCombinedArea.height);
    1: #endif
    1:   }
    1: 
    1:   // Apply break-after clearing if necessary
    1:   // This must stay in sync with |ReflowDirtyLines|.
    1:   if (aLine->HasFloatBreakAfter()) {
    1:     aState.mY = aState.ClearFloats(aState.mY, aLine->GetBreakTypeAfter());
    1:   }
28638:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsBlockFrame::PushLines(nsBlockReflowState&  aState,
    1:                         nsLineList::iterator aLineBefore)
    1: {
    1:   nsLineList::iterator overBegin(aLineBefore.next());
    1: 
    1:   // PushTruncatedPlaceholderLine sometimes pushes the first line.  Ugh.
    1:   PRBool firstLine = overBegin == begin_lines();
    1: 
    1:   if (overBegin != end_lines()) {
    1:     // Remove floats in the lines from mFloats
    1:     nsFrameList floats;
32843:     CollectFloats(overBegin->mFirstChild, floats, PR_FALSE, PR_TRUE);
    1: 
    1:     if (floats.NotEmpty()) {
    1:       // Push the floats onto the front of the overflow out-of-flows list
32843:       nsAutoOOFFrameList oofs(this);
32843:       oofs.mList.InsertFrames(nsnull, nsnull, floats);
    1:     }
    1: 
    1:     // overflow lines can already exist in some cases, in particular,
    1:     // when shrinkwrapping and we discover that the shrinkwap causes
    1:     // the height of some child block to grow which creates additional
    1:     // overflowing content. In such cases we must prepend the new
    1:     // overflow to the existing overflow.
    1:     nsLineList* overflowLines = RemoveOverflowLines();
    1:     if (!overflowLines) {
    1:       // XXXldb use presshell arena!
    1:       overflowLines = new nsLineList();
    1:     }
    1:     if (overflowLines) {
33276:       // First, remove the frames we're pushing from mFrames
33276:       nsIFrame* oldLastChild = mFrames.LastChild();
33276:       if (firstLine) {
33276:         mFrames.Clear();
33276:       } else {
33276:         mFrames.RemoveFramesAfter(aLineBefore->LastChild());
33276:       }
    1:       if (!overflowLines->empty()) {
33276:         // XXXbz If we switch overflow lines to nsFrameList, we should
33276:         // change this SetNextSibling call.
33276:         oldLastChild->SetNextSibling(overflowLines->front()->mFirstChild);
    1:       }
    1:       overflowLines->splice(overflowLines->begin(), mLines, overBegin,
    1:                             end_lines());
    1:       NS_ASSERTION(!overflowLines->empty(), "should not be empty");
    1:       // this takes ownership but it won't delete it immediately so we
    1:       // can keep using it.
    1:       SetOverflowLines(overflowLines);
    1:   
    1:       // Mark all the overflow lines dirty so that they get reflowed when
    1:       // they are pulled up by our next-in-flow.
    1: 
    1:       // XXXldb Can this get called O(N) times making the whole thing O(N^2)?
    1:       for (line_iterator line = overflowLines->begin(),
    1:              line_end = overflowLines->end();
    1:            line != line_end;
    1:            ++line)
    1:         {
    1:           line->MarkDirty();
    1:           line->MarkPreviousMarginDirty();
    1:           line->mBounds.SetRect(0, 0, 0, 0);
    1:           if (line->HasFloats()) {
    1:             line->FreeFloats(aState.mFloatCacheFreeList);
    1:           }
    1:         }
    1:     }
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   VerifyOverflowSituation();
    1: #endif
    1: }
    1: 
    1: // The overflowLines property is stored as a pointer to a line list,
    1: // which must be deleted.  However, the following functions all maintain
    1: // the invariant that the property is never set if the list is empty.
    1: 
    1: PRBool
    1: nsBlockFrame::DrainOverflowLines(nsBlockReflowState& aState)
    1: {
    1: #ifdef DEBUG
    1:   VerifyOverflowSituation();
    1: #endif
    1:   nsLineList* overflowLines = nsnull;
    1:   nsLineList* ourOverflowLines = nsnull;
    1: 
    1:   // First grab the prev-in-flows overflow lines
    1:   nsBlockFrame* prevBlock = (nsBlockFrame*) GetPrevInFlow();
    1:   if (prevBlock) {
    1:     overflowLines = prevBlock->RemoveOverflowLines();
    1:     if (overflowLines) {
    1:       NS_ASSERTION(! overflowLines->empty(),
    1:                    "overflow lines should never be set and empty");
    1:       // Make all the frames on the overflow line list mine
    1:       nsIFrame* frame = overflowLines->front()->mFirstChild;
    1:       while (nsnull != frame) {
    1:         ReparentFrame(frame, prevBlock, this);
    1: 
    1:         // Get the next frame
    1:         frame = frame->GetNextSibling();
    1:       }
    1: 
    1:       // make the overflow out-of-flow frames mine too
    1:       nsAutoOOFFrameList oofs(prevBlock);
    1:       if (oofs.mList.NotEmpty()) {
    1:         for (nsIFrame* f = oofs.mList.FirstChild(); f; f = f->GetNextSibling()) {
    1:           ReparentFrame(f, prevBlock, this);
    1:         }
30941:         mFloats.InsertFrames(nsnull, nsnull, oofs.mList);
    1:       }
    1:     }
    1:     
    1:     // The lines on the overflow list have already been marked dirty and their
    1:     // previous margins marked dirty also.
    1:   }
    1: 
    1:   // Don't need to reparent frames in our own overflow lines/oofs, because they're
    1:   // already ours. But we should put overflow floats back in mFloats.
    1:   ourOverflowLines = RemoveOverflowLines();
    1:   if (ourOverflowLines) {
    1:     nsAutoOOFFrameList oofs(this);
    1:     if (oofs.mList.NotEmpty()) {
    1:       // The overflow floats go after our regular floats
32843:       mFloats.AppendFrames(nsnull, oofs.mList);
    1:     }
    1:   }
    1: 
    1:   if (!overflowLines && !ourOverflowLines) {
    1:     // nothing to do; always the case for non-constrained-height reflows
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // Now join the line lists into mLines
    1:   if (overflowLines) {
    1:     if (!overflowLines->empty()) {
    1:       // Join the line lists
33276:       if (!mLines.empty()) {
    1:           // Remember to recompute the margins on the first line. This will
    1:           // also recompute the correct deltaY if necessary.
    1:           mLines.front()->MarkPreviousMarginDirty();
33276:       }
33276:       
    1:       // Join the sibling lists together
33276:       nsIFrame* firstFrame = overflowLines->front()->mFirstChild;
    1:       nsIFrame* lastFrame = overflowLines->back()->LastChild();
33276:       nsFrameList framesToInsert(firstFrame, lastFrame);
33276:       mFrames.InsertFrames(nsnull, nsnull, framesToInsert);
33276: 
    1:       // Place overflow lines at the front of our line list
    1:       mLines.splice(mLines.begin(), *overflowLines);
    1:       NS_ASSERTION(overflowLines->empty(), "splice should empty list");
    1:     }
    1:     delete overflowLines;
    1:   }
    1:   if (ourOverflowLines) {
    1:     if (!ourOverflowLines->empty()) {
33276:       nsIFrame* firstFrame = ourOverflowLines->front()->mFirstChild;
33276:       nsIFrame* lastFrame = ourOverflowLines->back()->LastChild();
33276:       nsFrameList framesToAppend(firstFrame, lastFrame);
33276:       mFrames.AppendFrames(nsnull, framesToAppend);
33276: 
    1:       // append the overflow to mLines
    1:       mLines.splice(mLines.end(), *ourOverflowLines);
    1:     }
    1:     delete ourOverflowLines;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
32108: // This function assumes our prev-in-flow has completed reflow and its
48989: // mFloats may contain frames at the end of its float list, marked with
49010: // NS_FRAME_IS_PUSHED_FLOAT, that should be pulled to this block.
32108: void
49010: nsBlockFrame::DrainPushedFloats(nsBlockReflowState& aState)
32108: {
48989:   // Take any continuations we need to take from our prev-in-flow.
32108:   nsBlockFrame* prevBlock = static_cast<nsBlockFrame*>(GetPrevInFlow());
32108:   if (!prevBlock)
32108:     return;
49010:   nsFrameList *list = prevBlock->RemovePushedFloats();
48990:   if (list) {
48990:     if (list->NotEmpty()) {
48992:       mFloats.InsertFrames(this, nsnull, *list);
48990:     }
48990:     delete list;
48989:   }
32108: 
32108: #ifdef DEBUG
32108:   for (nsIFrame* f = mFloats.FirstChild(); f ; f = f->GetNextSibling()) {
32108:     for (nsIFrame* c = f->GetFirstInFlow(); c ; c = c->GetNextInFlow()) {
32108:       NS_ASSERTION(c == f || c->GetParent() != this || !mFloats.ContainsFrame(c),
32108:                    "Two floats with same parent in same floats list, expect weird errors.");
32108:     }
32108:   }
32108: #endif
32108: }
32108: 
    1: nsLineList*
    1: nsBlockFrame::GetOverflowLines() const
    1: {
    1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_LINES)) {
    1:     return nsnull;
    1:   }
 3233:   nsLineList* lines = static_cast<nsLineList*>
39965:     (Properties().Get(OverflowLinesProperty()));
    1:   NS_ASSERTION(lines && !lines->empty(),
    1:                "value should always be stored and non-empty when state set");
    1:   return lines;
    1: }
    1: 
    1: nsLineList*
    1: nsBlockFrame::RemoveOverflowLines()
    1: {
    1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_LINES)) {
    1:     return nsnull;
    1:   }
 3233:   nsLineList* lines = static_cast<nsLineList*>
39965:     (Properties().Remove(OverflowLinesProperty()));
    1:   NS_ASSERTION(lines && !lines->empty(),
    1:                "value should always be stored and non-empty when state set");
    1:   RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_LINES);
    1:   return lines;
    1: }
    1: 
    1: // This takes ownership of aOverflowLines.
    1: // XXX We should allocate overflowLines from presShell arena!
    1: nsresult
    1: nsBlockFrame::SetOverflowLines(nsLineList* aOverflowLines)
    1: {
    1:   NS_ASSERTION(aOverflowLines, "null lines");
    1:   NS_ASSERTION(!aOverflowLines->empty(), "empty lines");
    1:   NS_ASSERTION(!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_LINES),
    1:                "Overwriting existing overflow lines");
    1: 
39965:   FrameProperties props = Properties();
39965:   // Verify that we won't overwrite an existing overflow list
39965:   NS_ASSERTION(!props.Get(OverflowLinesProperty()), "existing overflow list");
39965:   props.Set(OverflowLinesProperty(), aOverflowLines);
    1:   AddStateBits(NS_BLOCK_HAS_OVERFLOW_LINES);
39965:   return NS_OK;
    1: }
    1: 
33010: nsFrameList*
    1: nsBlockFrame::GetOverflowOutOfFlows() const
    1: {
    1:   if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
33010:     return nsnull;
33010:   }
33010:   nsFrameList* result =
39965:     GetPropTableFrames(PresContext(), OverflowOutOfFlowsProperty());
    1:   NS_ASSERTION(result, "value should always be non-empty when state set");
33010:   return result;
    1: }
    1: 
    1: // This takes ownership of the frames
    1: void
33010: nsBlockFrame::SetOverflowOutOfFlows(const nsFrameList& aList,
33010:                                     nsFrameList* aPropValue)
    1: {
33010:   NS_PRECONDITION(!!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS) ==
33010:                   !!aPropValue, "state does not match value");
33010: 
    1:   if (aList.IsEmpty()) {
    1:     if (!(GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS)) {
    1:       return;
    1:     }
33010:     nsFrameList* list =
33010:       RemovePropTableFrames(PresContext(),
39965:                             OverflowOutOfFlowsProperty());
33010:     NS_ASSERTION(aPropValue == list, "prop value mismatch");
33010:     delete list;
    1:     RemoveStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
33010:   }
33010:   else if (GetStateBits() & NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS) {
33010:     NS_ASSERTION(aPropValue == GetPropTableFrames(PresContext(),
39965:                                  OverflowOutOfFlowsProperty()),
33010:                  "prop value mismatch");
33010:     *aPropValue = aList;
33010:   }
33010:   else {
33010:     SetPropTableFrames(PresContext(), new nsFrameList(aList),
39965:                        OverflowOutOfFlowsProperty());
    1:     AddStateBits(NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS);
    1:   }
    1: }
    1: 
48990: nsFrameList*
49010: nsBlockFrame::GetPushedFloats() const
49010: {
49010:   if (!(GetStateBits() & NS_BLOCK_HAS_PUSHED_FLOATS)) {
48990:     return nsnull;
48990:   }
48990:   nsFrameList* result =
49010:     static_cast<nsFrameList*>(Properties().Get(PushedFloatProperty()));
48990:   NS_ASSERTION(result, "value should always be non-empty when state set");
48990:   return result;
48990: }
48990: 
48990: nsFrameList*
49010: nsBlockFrame::EnsurePushedFloats()
49010: {
49010:   nsFrameList *result = GetPushedFloats();
48990:   if (result)
48990:     return result;
48990: 
48990:   result = new nsFrameList;
49010:   Properties().Set(PushedFloatProperty(), result);
49010:   AddStateBits(NS_BLOCK_HAS_PUSHED_FLOATS);
48990: 
48990:   return result;
48990: }
48990: 
48990: nsFrameList*
49010: nsBlockFrame::RemovePushedFloats()
49010: {
49010:   if (!(GetStateBits() & NS_BLOCK_HAS_PUSHED_FLOATS)) {
48990:     return nsnull;
48990:   }
48990: 
48990:   nsFrameList *result =
49010:     static_cast<nsFrameList*>(Properties().Remove(PushedFloatProperty()));
49010:   RemoveStateBits(NS_BLOCK_HAS_PUSHED_FLOATS);
48990:   NS_ASSERTION(result, "value should always be non-empty when state set");
48990:   return result;
48990: }
48990: 
    1: //////////////////////////////////////////////////////////////////////
    1: // Frame list manipulation routines
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::AppendFrames(nsIAtom*  aListName,
30941:                            nsFrameList& aFrameList)
    1: {
30941:   if (aFrameList.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1:   if (aListName) {
 4205:     if (nsGkAtoms::absoluteList == aListName) {
    1:       return mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
    1:     }
    1:     else if (nsGkAtoms::floatList == aListName) {
    1:       mFloats.AppendFrames(nsnull, aFrameList);
    1:       return NS_OK;
    1:     }
    1:     else {
    1:       NS_ERROR("unexpected child list");
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:   }
    1: 
    1:   // Find the proper last-child for where the append should go
32843:   nsIFrame* lastKid = mLines.empty() ? nsnull : mLines.back()->LastChild();
    1: 
    1:   // Add frames after the last child
    1: #ifdef NOISY_REFLOW_REASON
    1:   ListTag(stdout);
    1:   printf(": append ");
    1:   nsFrame::ListTag(stdout, aFrameList);
    1:   if (lastKid) {
    1:     printf(" after ");
    1:     nsFrame::ListTag(stdout, lastKid);
    1:   }
    1:   printf("\n");
    1: #endif
    1:   nsresult rv = AddFrames(aFrameList, lastKid);
30941:   if (NS_FAILED(rv)) {
30941:     return rv;
30941:   }
30941:   aFrameList.Clear();
30941: 
  238:   PresContext()->PresShell()->
 1158:     FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                      NS_FRAME_HAS_DIRTY_CHILDREN); // XXX sufficient?
30941:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::InsertFrames(nsIAtom*  aListName,
    1:                            nsIFrame* aPrevFrame,
30941:                            nsFrameList& aFrameList)
    1: {
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                "inserting after sibling frame with different parent");
    1: 
    1:   if (aListName) {
 4205:     if (nsGkAtoms::absoluteList == aListName) {
    1:       return mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame,
    1:                                              aFrameList);
    1:     }
    1:     else if (nsGkAtoms::floatList == aListName) {
    1:       mFloats.InsertFrames(this, aPrevFrame, aFrameList);
    1:       return NS_OK;
    1:     }
    1: #ifdef IBMBIDI
    1:     else if (nsGkAtoms::nextBidi == aListName) {}
    1: #endif // IBMBIDI
    1:     else {
    1:       NS_ERROR("unexpected child list");
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:   }
    1: 
    1: #ifdef NOISY_REFLOW_REASON
    1:   ListTag(stdout);
    1:   printf(": insert ");
    1:   nsFrame::ListTag(stdout, aFrameList);
    1:   if (aPrevFrame) {
    1:     printf(" after ");
    1:     nsFrame::ListTag(stdout, aPrevFrame);
    1:   }
    1:   printf("\n");
    1: #endif
    1:   nsresult rv = AddFrames(aFrameList, aPrevFrame);
30941:   if (NS_FAILED(rv)) {
30941:     return rv;
30941:   }
    1: #ifdef IBMBIDI
    1:   if (aListName != nsGkAtoms::nextBidi)
    1: #endif // IBMBIDI
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                        NS_FRAME_HAS_DIRTY_CHILDREN); // XXX sufficient?
30941:   return NS_OK;
    1: }
    1: 
    1: static PRBool
    1: ShouldPutNextSiblingOnNewLine(nsIFrame* aLastFrame)
    1: {
    1:   nsIAtom* type = aLastFrame->GetType();
    1:   if (type == nsGkAtoms::brFrame)
    1:     return PR_TRUE;
    1:   if (type == nsGkAtoms::textFrame)
    1:     return aLastFrame->HasTerminalNewline() &&
16575:            aLastFrame->GetStyleText()->NewlineIsSignificant();
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
33276: nsBlockFrame::AddFrames(nsFrameList& aFrameList, nsIFrame* aPrevSibling)
    1: {
    1:   // Clear our line cursor, since our lines may change.
    1:   ClearLineCursor();
    1: 
30784:   if (aFrameList.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we're inserting at the beginning of our list and we have an
    1:   // inside bullet, insert after that bullet.
    1:   if (!aPrevSibling && mBullet && !HaveOutsideBullet()) {
30784:     NS_ASSERTION(!aFrameList.ContainsFrame(mBullet),
    1:                  "Trying to make mBullet prev sibling to itself");
    1:     aPrevSibling = mBullet;
    1:   }
    1:   
  238:   nsIPresShell *presShell = PresContext()->PresShell();
    1: 
    1:   // Attempt to find the line that contains the previous sibling
    1:   nsLineList::iterator prevSibLine = end_lines();
    1:   PRInt32 prevSiblingIndex = -1;
    1:   if (aPrevSibling) {
    1:     // XXX_perf This is technically O(N^2) in some cases, but by using
    1:     // RFind instead of Find, we make it O(N) in the most common case,
    1:     // which is appending content.
    1: 
    1:     // Find the line that contains the previous sibling
    1:     if (! nsLineBox::RFindLineContaining(aPrevSibling,
    1:                                          begin_lines(), prevSibLine,
33389:                                          mFrames.LastChild(),
    1:                                          &prevSiblingIndex)) {
    1:       // Note: defensive code! RFindLineContaining must not return
    1:       // false in this case, so if it does...
    1:       NS_NOTREACHED("prev sibling not in line list");
    1:       aPrevSibling = nsnull;
    1:       prevSibLine = end_lines();
    1:     }
    1:   }
    1: 
    1:   // Find the frame following aPrevSibling so that we can join up the
    1:   // two lists of frames.
    1:   if (aPrevSibling) {
    1:     // Split line containing aPrevSibling in two if the insertion
    1:     // point is somewhere in the middle of the line.
    1:     PRInt32 rem = prevSibLine->GetChildCount() - prevSiblingIndex - 1;
    1:     if (rem) {
    1:       // Split the line in two where the frame(s) are being inserted.
33276:       nsLineBox* line = NS_NewLineBox(presShell, aPrevSibling->GetNextSibling(), rem, PR_FALSE);
    1:       if (!line) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       mLines.after_insert(prevSibLine, line);
    1:       prevSibLine->SetChildCount(prevSibLine->GetChildCount() - rem);
 7719:       // Mark prevSibLine dirty and as needing textrun invalidation, since
 7719:       // we may be breaking up text in the line. Its previous line may also
 7719:       // need to be invalidated because it may be able to pull some text up.
 7719:       MarkLineDirty(prevSibLine);
 7719:       // The new line will also need its textruns recomputed because of the
 7719:       // frame changes.
28590:       line->MarkDirty();
 7719:       line->SetInvalidateTextRuns(PR_TRUE);
 6029:     }
    1:   }
    1:   else if (! mLines.empty()) {
28590:     mLines.front()->MarkDirty();
 6029:     mLines.front()->SetInvalidateTextRuns(PR_TRUE);
    1:   }
33276:   const nsFrameList::Slice& newFrames =
33276:     mFrames.InsertFrames(nsnull, aPrevSibling, aFrameList);
    1: 
    1:   // Walk through the new frames being added and update the line data
    1:   // structures to fit.
33276:   for (nsFrameList::Enumerator e(newFrames); !e.AtEnd(); e.Next()) {
33276:     nsIFrame* newFrame = e.get();
33276:     NS_ASSERTION(!aPrevSibling || aPrevSibling->GetNextSibling() == newFrame,
33276:                  "Unexpected aPrevSibling");
 3812:     NS_ASSERTION(newFrame->GetType() != nsGkAtoms::placeholderFrame ||
 3812:                  (!newFrame->GetStyleDisplay()->IsAbsolutelyPositioned() &&
 3812:                   !newFrame->GetStyleDisplay()->IsFloating()),
 3812:                  "Placeholders should not float or be positioned");
 3812: 
 2829:     PRBool isBlock = newFrame->GetStyleDisplay()->IsBlockOutside();
    1: 
    1:     // If the frame is a block frame, or if there is no previous line or if the
    1:     // previous line is a block line we need to make a new line.  We also make
32106:     // a new line, as an optimization, in the two cases we know we'll need it:
32106:     // if the previous line ended with a <br>, or if it has significant whitespace
32106:     // and ended in a newline.
    1:     if (isBlock || prevSibLine == end_lines() || prevSibLine->IsBlock() ||
    1:         (aPrevSibling && ShouldPutNextSiblingOnNewLine(aPrevSibling))) {
    1:       // Create a new line for the frame and add its line to the line
    1:       // list.
    1:       nsLineBox* line = NS_NewLineBox(presShell, newFrame, 1, isBlock);
    1:       if (!line) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       if (prevSibLine != end_lines()) {
    1:         // Append new line after prevSibLine
    1:         mLines.after_insert(prevSibLine, line);
    1:         ++prevSibLine;
    1:       }
    1:       else {
    1:         // New line is going before the other lines
    1:         mLines.push_front(line);
    1:         prevSibLine = begin_lines();
    1:       }
    1:     }
    1:     else {
    1:       prevSibLine->SetChildCount(prevSibLine->GetChildCount() + 1);
 7719:       // We're adding inline content to prevSibLine, so we need to mark it
 7719:       // dirty, ensure its textruns are recomputed, and possibly do the same
 7719:       // to its previous line since that line may be able to pull content up.
 7719:       MarkLineDirty(prevSibLine);
    1:     }
    1: 
    1:     aPrevSibling = newFrame;
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   VerifyLines(PR_TRUE);
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: nsBlockFrame::line_iterator
    1: nsBlockFrame::RemoveFloat(nsIFrame* aFloat) {
    1:   // Find which line contains the float, so we can update
    1:   // the float cache.
    1:   line_iterator line = begin_lines(), line_end = end_lines();
    1:   for ( ; line != line_end; ++line) {
    1:     if (line->IsInline() && line->RemoveFloat(aFloat)) {
    1:       break;
    1:     }
    1:   }
    1: 
    1:   // Try to destroy if it's in mFloats.
32844:   if (mFloats.DestroyFrameIfPresent(aFloat)) {
    1:     return line;
    1:   }
    1: 
    1:   // Try our overflow list
    1:   {
    1:     nsAutoOOFFrameList oofs(this);
32844:     if (oofs.mList.DestroyFrameIfPresent(aFloat)) {
    1:       return line_end;
    1:     }
    1:   }
    1: 
32108:   NS_ERROR("Destroying float without removing from a child list.");
    1:   return line_end;
    1: }
    1: 
23305: static void MarkSameFloatManagerLinesDirty(nsBlockFrame* aBlock)
    1: {
23305:   nsBlockFrame* blockWithFloatMgr = aBlock;
23305:   while (!(blockWithFloatMgr->GetStateBits() & NS_BLOCK_FLOAT_MGR)) {
23305:     nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(blockWithFloatMgr->GetParent());
15909:     if (!bf) {
    1:       break;
    1:     }
23305:     blockWithFloatMgr = bf;
    1:   }
    1:     
    1:   // Mark every line at and below the line where the float was
    1:   // dirty, and mark their lines dirty too. We could probably do
    1:   // something more efficient --- e.g., just dirty the lines that intersect
    1:   // the float vertically.
23305:   MarkAllDescendantLinesDirty(blockWithFloatMgr);
    1: }
    1: 
    1: /**
    1:  * Returns PR_TRUE if aFrame is a block that has one or more float children.
    1:  */
    1: static PRBool BlockHasAnyFloats(nsIFrame* aFrame)
    1: {
15909:   nsBlockFrame* block = nsLayoutUtils::GetAsBlock(aFrame);
15909:   if (!block)
    1:     return PR_FALSE;
    1:   if (block->GetFirstChild(nsGkAtoms::floatList))
    1:     return PR_TRUE;
    1:     
    1:   nsLineList::iterator line = block->begin_lines();
    1:   nsLineList::iterator endLine = block->end_lines();
    1:   while (line != endLine) {
    1:     if (line->IsBlock() && BlockHasAnyFloats(line->mFirstChild))
    1:       return PR_TRUE;
    1:     ++line;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::RemoveFrame(nsIAtom*  aListName,
    1:                           nsIFrame* aOldFrame)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1: #ifdef NOISY_REFLOW_REASON
    1:   ListTag(stdout);
    1:   printf(": remove ");
    1:   nsFrame::ListTag(stdout, aOldFrame);
    1:   printf("\n");
    1: #endif
    1: 
    1:   if (nsnull == aListName) {
    1:     PRBool hasFloats = BlockHasAnyFloats(aOldFrame);
22195:     rv = DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
    1:     if (hasFloats) {
23305:       MarkSameFloatManagerLinesDirty(this);
    1:     }
    1:   }
 4205:   else if (nsGkAtoms::absoluteList == aListName) {
32844:     mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
32844:     return NS_OK;
    1:   }
    1:   else if (nsGkAtoms::floatList == aListName) {
32111:     // Make sure to mark affected lines dirty for the float frame
 4772:     // we are removing; this way is a bit messy, but so is the rest of the code.
 4772:     // See bug 390762.
32111:     NS_ASSERTION(!aOldFrame->GetPrevContinuation(),
49010:                  "RemoveFrame should not be called on pushed floats.");
32111:     for (nsIFrame* f = aOldFrame;
32111:          f && !(f->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
32111:          f = f->GetNextContinuation()) {
32111:       MarkSameFloatManagerLinesDirty(static_cast<nsBlockFrame*>(f->GetParent()));
32111:     }
32111:     DoRemoveOutOfFlowFrame(aOldFrame);
    1:   }
    1: #ifdef IBMBIDI
    1:   else if (nsGkAtoms::nextBidi == aListName) {
    1:     // Skip the call to |FrameNeedsReflow| below by returning now.
22195:     return DoRemoveFrame(aOldFrame, REMOVE_FIXED_CONTINUATIONS);
    1:   }
    1: #endif // IBMBIDI
    1:   else {
    1:     NS_ERROR("unexpected child list");
    1:     rv = NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                        NS_FRAME_HAS_DIRTY_CHILDREN); // XXX sufficient?
    1:   }
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsBlockFrame::DoRemoveOutOfFlowFrame(nsIFrame* aFrame)
    1: {
 6521:   // The containing block is always the parent of aFrame.
 6521:   nsBlockFrame* block = (nsBlockFrame*)aFrame->GetParent();
 6521: 
 6521:   // Remove aFrame from the appropriate list.
 6521:   const nsStyleDisplay* display = aFrame->GetStyleDisplay();
 6521:   if (display->IsAbsolutelyPositioned()) {
 6521:     // This also deletes the next-in-flows
 6521:     block->mAbsoluteContainer.RemoveFrame(block,
 6521:                                           nsGkAtoms::absoluteList,
 6521:                                           aFrame);
 6521:   }
 6521:   else {
32108:     // First remove aFrame's next-in-flows
32108:     nsIFrame* nif = aFrame->GetNextInFlow();
32108:     if (nif) {
32108:       static_cast<nsContainerFrame*>(nif->GetParent())
32108:         ->DeleteNextInFlowChild(aFrame->PresContext(), nif, PR_FALSE);
    1:     }
    1:     // Now remove aFrame
    1:     // This also destroys the frame.
    1:     block->RemoveFloat(aFrame);
    1:   }
    1: }
    1: 
    1: /**
    1:  * This helps us iterate over the list of all normal + overflow lines
    1:  */
    1: void
    1: nsBlockFrame::TryAllLines(nsLineList::iterator* aIterator,
 6709:                           nsLineList::iterator* aStartIterator,
    1:                           nsLineList::iterator* aEndIterator,
    1:                           PRBool* aInOverflowLines) {
    1:   if (*aIterator == *aEndIterator) {
    1:     if (!*aInOverflowLines) {
    1:       *aInOverflowLines = PR_TRUE;
    1:       // Try the overflow lines
    1:       nsLineList* overflowLines = GetOverflowLines();
    1:       if (overflowLines) {
 6709:         *aStartIterator = overflowLines->begin();
 6709:         *aIterator = *aStartIterator;
    1:         *aEndIterator = overflowLines->end();
    1:       }
    1:     }
    1:   }
    1: }
    1: 
 5145: nsBlockInFlowLineIterator::nsBlockInFlowLineIterator(nsBlockFrame* aFrame,
10962:     line_iterator aLine, PRBool aInOverflow)
 5145:   : mFrame(aFrame), mLine(aLine), mInOverflowLines(nsnull)
 5145: {
 5145:   if (aInOverflow) {
 5145:     mInOverflowLines = aFrame->GetOverflowLines();
 5145:     NS_ASSERTION(mInOverflowLines, "How can we be in overflow if there isn't any?");
 5145:   }
 5145: }
 5145: 
12165: nsBlockInFlowLineIterator::nsBlockInFlowLineIterator(nsBlockFrame* aFrame,
12165:     PRBool* aFoundValidLine)
12165:   : mFrame(aFrame), mInOverflowLines(nsnull)
12165: {
12165:   mLine = aFrame->begin_lines();
12165:   *aFoundValidLine = FindValidLine();
12165: }
12165: 
12355: static nsIFrame*
12355: FindChildContaining(nsBlockFrame* aFrame, nsIFrame* aFindFrame)
12355: {
25229:   NS_ASSERTION(aFrame, "must have frame");
12355:   nsIFrame* child;
12355:   while (PR_TRUE) {
12355:     nsIFrame* block = aFrame;
25229:     do {
12355:       child = nsLayoutUtils::FindChildContainingDescendant(block, aFindFrame);
12355:       if (child)
12355:         break;
12355:       block = block->GetNextContinuation();
25229:     } while (block);
12355:     if (!child)
12355:       return nsnull;
12355:     if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW))
12355:       break;
12355:     aFindFrame = aFrame->PresContext()->FrameManager()->GetPlaceholderFrameFor(child);
12355:   }
12355: 
12355:   return child;
12355: }
12355: 
12355: nsBlockInFlowLineIterator::nsBlockInFlowLineIterator(nsBlockFrame* aFrame,
12355:     nsIFrame* aFindFrame, PRBool* aFoundValidLine)
12355:   : mFrame(aFrame), mInOverflowLines(nsnull)
12355: {
12355:   *aFoundValidLine = PR_FALSE;
12355: 
12355:   nsIFrame* child = FindChildContaining(aFrame, aFindFrame);
12355:   if (!child)
12355:     return;
12355: 
53721:   // Try to use the cursor if it exists, otherwise fall back to the first line
53721:   nsLineBox* cursor = static_cast<nsLineBox*>
53721:     (aFrame->Properties().Get(LineCursorProperty()));
53721:   if (!cursor) {
53721:     line_iterator iter = aFrame->begin_lines();
53721:     if (iter != aFrame->end_lines()) {
53721:       cursor = iter;
53721:     }
53721:   }
53721: 
53721:   if (cursor) {
53721:     // Perform a simultaneous forward and reverse search starting from the
53721:     // line cursor.
53721:     nsBlockFrame::line_iterator line = aFrame->line(cursor);
53721:     nsBlockFrame::reverse_line_iterator rline = aFrame->rline(cursor);
53721:     nsBlockFrame::line_iterator line_end = aFrame->end_lines();
53721:     nsBlockFrame::reverse_line_iterator rline_end = aFrame->rend_lines();
54260:     // rline is positioned on the line containing 'cursor', so it's not
54260:     // rline_end. So we can safely increment it (i.e. move it to one line
54260:     // earlier) to start searching there.
54260:     ++rline;
54260:     while (line != line_end || rline != rline_end) {
53721:       if (line != line_end) {
53721:         if (line->Contains(child)) {
53721:           *aFoundValidLine = PR_TRUE;
53721:           mLine = line;
53721:           return;
53721:         }
53721:         ++line;
53721:       }
53721:       if (rline != rline_end) {
53721:         if (rline->Contains(child)) {
53721:           *aFoundValidLine = PR_TRUE;
53721:           mLine = rline;
53721:           return;
53721:         }
53721:         ++rline;
53721:       }
53721:     }
54260:     // Didn't find the line
53721:   }
53721: 
53721:   // If we reach here, it means that we have not been able to find the
53721:   // desired frame in our in-flow lines.  So we should start looking at
53721:   // our overflow lines. In order to do that, we set mLine to the end
53721:   // iterator so that FindValidLine starts to look at overflow lines,
53721:   // if any.
53721: 
53721:   mLine = aFrame->end_lines();
53721: 
12355:   if (!FindValidLine())
12355:     return;
12355: 
12355:   do {
12355:     if (mLine->Contains(child)) {
12355:       *aFoundValidLine = PR_TRUE;
12355:       return;
12355:     }
12355:   } while (Next());
12355: }
12355: 
14246: nsBlockFrame::line_iterator
14246: nsBlockInFlowLineIterator::End()
14246: {
14246:   return mInOverflowLines ? mInOverflowLines->end() : mFrame->end_lines();
14246: }
14246: 
 5145: PRBool
10962: nsBlockInFlowLineIterator::IsLastLineInList()
10962: {
14246:   line_iterator end = End();
10962:   return mLine != end && mLine.next() == end;
10962: }
10962: 
10962: PRBool
 5145: nsBlockInFlowLineIterator::Next()
 5145: {
 5145:   ++mLine;
12165:   return FindValidLine();
12165: }
12165: 
12165: PRBool
12165: nsBlockInFlowLineIterator::Prev()
12165: {
12165:   line_iterator begin = mInOverflowLines ? mInOverflowLines->begin() : mFrame->begin_lines();
12165:   if (mLine != begin) {
12165:     --mLine;
12165:     return PR_TRUE;
12165:   }
12165:   PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;
12165:   while (PR_TRUE) {
12165:     if (currentlyInOverflowLines) {
20323:       mInOverflowLines = nsnull;
12165:       mLine = mFrame->end_lines();
12165:       if (mLine != mFrame->begin_lines()) {
12165:         --mLine;
12165:         return PR_TRUE;
12165:       }
12165:     } else {
12165:       mFrame = static_cast<nsBlockFrame*>(mFrame->GetPrevInFlow());
12165:       if (!mFrame)
12165:         return PR_FALSE;
12165:       mInOverflowLines = mFrame->GetOverflowLines();
12165:       if (mInOverflowLines) {
12165:         mLine = mInOverflowLines->end();
12165:         NS_ASSERTION(mLine != mInOverflowLines->begin(), "empty overflow line list?");
12165:         --mLine;
12165:         return PR_TRUE;
12165:       }
12165:     }
12165:     currentlyInOverflowLines = !currentlyInOverflowLines;
12165:   }
12165: }
12165: 
12165: PRBool
12165: nsBlockInFlowLineIterator::FindValidLine()
12165: {
 5145:   line_iterator end = mInOverflowLines ? mInOverflowLines->end() : mFrame->end_lines();
 5145:   if (mLine != end)
 5145:     return PR_TRUE;
 5145:   PRBool currentlyInOverflowLines = mInOverflowLines != nsnull;
 5145:   while (PR_TRUE) {
 5145:     if (currentlyInOverflowLines) {
 5145:       mFrame = static_cast<nsBlockFrame*>(mFrame->GetNextInFlow());
 5145:       if (!mFrame)
 5145:         return PR_FALSE;
 5145:       mInOverflowLines = nsnull;
 5145:       mLine = mFrame->begin_lines();
 5145:       if (mLine != mFrame->end_lines())
 5145:         return PR_TRUE;
 5145:     } else {
 5145:       mInOverflowLines = mFrame->GetOverflowLines();
 5145:       if (mInOverflowLines) {
 5145:         mLine = mInOverflowLines->begin();
 5145:         NS_ASSERTION(mLine != mInOverflowLines->end(), "empty overflow line list?");
 5145:         return PR_TRUE;
 5145:       }
 5145:     }
 5145:     currentlyInOverflowLines = !currentlyInOverflowLines;
 5145:   }
 5145: }
 5145: 
32106: static nsresult RemoveBlockChild(nsIFrame* aFrame,
 8520:                                  PRBool    aRemoveOnlyFluidContinuations)
    1: {
    1:   if (!aFrame)
    1:     return NS_OK;
    1: 
15909:   nsBlockFrame* nextBlock = nsLayoutUtils::GetAsBlock(aFrame->GetParent());
15909:   NS_ASSERTION(nextBlock,
    1:                "Our child's continuation's parent is not a block?");
22195:   return nextBlock->DoRemoveFrame(aFrame,
22195:       (aRemoveOnlyFluidContinuations ? 0 : nsBlockFrame::REMOVE_FIXED_CONTINUATIONS));
    1: }
    1: 
    1: // This function removes aDeletedFrame and all its continuations.  It
    1: // is optimized for deleting a whole series of frames. The easy
    1: // implementation would invoke itself recursively on
    1: // aDeletedFrame->GetNextContinuation, then locate the line containing
    1: // aDeletedFrame and remove aDeletedFrame from that line. But here we
    1: // start by locating aDeletedFrame and then scanning from that point
    1: // on looking for continuations.
    1: nsresult
22195: nsBlockFrame::DoRemoveFrame(nsIFrame* aDeletedFrame, PRUint32 aFlags)
    1: {
    1:   // Clear our line cursor, since our lines may change.
    1:   ClearLineCursor();
    1: 
 6521:   nsPresContext* presContext = PresContext();
32108:   if (aDeletedFrame->GetStateBits() &
32108:       (NS_FRAME_OUT_OF_FLOW | NS_FRAME_IS_OVERFLOW_CONTAINER)) {
32108:     if (!aDeletedFrame->GetPrevInFlow()) {
32108:       NS_ASSERTION(aDeletedFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
32108:                    "Expected out-of-flow frame");
32108:       DoRemoveOutOfFlowFrame(aDeletedFrame);
32108:     }
32108:     else {
32108:       nsContainerFrame::DeleteNextInFlowChild(presContext, aDeletedFrame,
22195:                                               (aFlags & FRAMES_ARE_EMPTY) != 0);
32108:     }
 6800:     return NS_OK;
 6521:   }
 6521: 
    1:   nsIPresShell* presShell = presContext->PresShell();
    1: 
33388:   // Find the line that contains deletedFrame
 6709:   nsLineList::iterator line_start = mLines.begin(),
    1:                        line_end = mLines.end();
 6709:   nsLineList::iterator line = line_start;
    1:   PRBool searchingOverflowList = PR_FALSE;
    1:   // Make sure we look in the overflow lines even if the normal line
    1:   // list is empty
 6709:   TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
    1:   while (line != line_end) {
33388:     if (line->Contains(aDeletedFrame)) {
33388:       break;
    1:     }
    1:     ++line;
 6709:     TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
    1:   }
33388: 
    1:   if (line == line_end) {
    1:     NS_ERROR("can't find deleted frame in lines");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
22195:   if (!(aFlags & FRAMES_ARE_EMPTY)) {
 6709:     if (line != line_start) {
28590:       line.prev()->MarkDirty();
 6029:       line.prev()->SetInvalidateTextRuns(PR_TRUE);
 6029:     }
 6709:     else if (searchingOverflowList && !mLines.empty()) {
28590:       mLines.back()->MarkDirty();
 6709:       mLines.back()->SetInvalidateTextRuns(PR_TRUE);
 6709:     }
22195:   }
 6029: 
    1:   while ((line != line_end) && (nsnull != aDeletedFrame)) {
    1:     NS_ASSERTION(this == aDeletedFrame->GetParent(), "messed up delete code");
    1:     NS_ASSERTION(line->Contains(aDeletedFrame), "frame not in line");
    1: 
22195:     if (!(aFlags & FRAMES_ARE_EMPTY)) {
28590:       line->MarkDirty();
 6029:       line->SetInvalidateTextRuns(PR_TRUE);
22195:     }
 6029: 
    1:     // If the frame being deleted is the last one on the line then
    1:     // optimize away the line->Contains(next-in-flow) call below.
    1:     PRBool isLastFrameOnLine = (1 == line->GetChildCount() ||
    1:                                 line->LastChild() == aDeletedFrame);
    1: 
    1:     // Remove aDeletedFrame from the line
    1:     nsIFrame* nextFrame = aDeletedFrame->GetNextSibling();
    1:     if (line->mFirstChild == aDeletedFrame) {
    1:       // We should be setting this to null if aDeletedFrame
    1:       // is the only frame on the line. HOWEVER in that case
    1:       // we will be removing the line anyway, see below.
    1:       line->mFirstChild = nextFrame;
    1:     }
    1: 
    1:     // Hmm, this won't do anything if we're removing a frame in the first
    1:     // overflow line... Hopefully doesn't matter
    1:     --line;
    1:     if (line != line_end && !line->IsBlock()) {
    1:       // Since we just removed a frame that follows some inline
    1:       // frames, we need to reflow the previous line.
    1:       line->MarkDirty();
    1:     }
    1:     ++line;
    1: 
    1:     // Take aDeletedFrame out of the sibling list. Note that
    1:     // prevSibling will only be nsnull when we are deleting the very
    1:     // first frame in the main or overflow list.
33276:     if (searchingOverflowList) {
33388:       nsIFrame* prevSibling = aDeletedFrame->GetPrevSibling();
    1:       if (prevSibling) {
33276:         // XXXbz If we switch overflow lines to nsFrameList, we should
33276:         // change this SetNextSibling call.
    1:         prevSibling->SetNextSibling(nextFrame);
    1:       }
36646:       aDeletedFrame->SetNextSibling(nsnull);
33276:     } else {
33388:       mFrames.RemoveFrame(aDeletedFrame);
33276:     }
    1: 
    1:     // Update the child count of the line to be accurate
    1:     PRInt32 lineChildCount = line->GetChildCount();
    1:     lineChildCount--;
    1:     line->SetChildCount(lineChildCount);
    1: 
    1:     // Destroy frame; capture its next continuation first in case we need
    1:     // to destroy that too.
22195:     nsIFrame* deletedNextContinuation = (aFlags & REMOVE_FIXED_CONTINUATIONS) ?
22195:         aDeletedFrame->GetNextContinuation() : aDeletedFrame->GetNextInFlow();
    1: #ifdef NOISY_REMOVE_FRAME
    1:     printf("DoRemoveFrame: %s line=%p frame=",
    1:            searchingOverflowList?"overflow":"normal", line.get());
    1:     nsFrame::ListTag(stdout, aDeletedFrame);
43003:     printf(" prevSibling=%p deletedNextContinuation=%p\n",
43003:            aDeletedFrame->GetPrevSibling(), deletedNextContinuation);
    1: #endif
    1: 
43003:     // If next-in-flow is an overflow container, must remove it first.
43003:     if (deletedNextContinuation &&
43003:         deletedNextContinuation->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
43003:       static_cast<nsContainerFrame*>(deletedNextContinuation->GetParent())
43003:         ->DeleteNextInFlowChild(presContext, deletedNextContinuation, PR_FALSE);
43003:       deletedNextContinuation = nsnull;
43003:     }
43003: 
    1:     aDeletedFrame->Destroy();
    1:     aDeletedFrame = deletedNextContinuation;
    1: 
    1:     PRBool haveAdvancedToNextLine = PR_FALSE;
    1:     // If line is empty, remove it now.
    1:     if (0 == lineChildCount) {
    1: #ifdef NOISY_REMOVE_FRAME
    1:         printf("DoRemoveFrame: %s line=%p became empty so it will be removed\n",
    1:                searchingOverflowList?"overflow":"normal", line.get());
    1: #endif
    1:       nsLineBox *cur = line;
    1:       if (!searchingOverflowList) {
    1:         line = mLines.erase(line);
    1:         // Invalidate the space taken up by the line.
    1:         // XXX We need to do this if we're removing a frame as a result of
    1:         // a call to RemoveFrame(), but we may not need to do this in all
    1:         // cases...
    1:         nsRect lineCombinedArea(cur->GetCombinedArea());
    1: #ifdef NOISY_BLOCK_INVALIDATE
    1:         printf("%p invalidate 10 (%d, %d, %d, %d)\n",
    1:                this, lineCombinedArea.x, lineCombinedArea.y,
    1:                lineCombinedArea.width, lineCombinedArea.height);
    1: #endif
    1:         Invalidate(lineCombinedArea);
    1:       } else {
    1:         nsLineList* lineList = RemoveOverflowLines();
    1:         line = lineList->erase(line);
    1:         if (!lineList->empty()) {
    1:           SetOverflowLines(lineList);
33259:         } else {
33259:           delete lineList;
36689:           // We just invalidated our iterators.  Since we were in
36689:           // the overflow lines list, which is now empty, set them
36689:           // so we're at the end of the regular line list.
36689:           line_start = mLines.begin();
36689:           line_end = mLines.end();
36689:           line = line_end;
    1:         }
    1:       }
    1:       cur->Destroy(presShell);
    1: 
    1:       // If we're removing a line, ReflowDirtyLines isn't going to
    1:       // know that it needs to slide lines unless something is marked
    1:       // dirty.  So mark the previous margin of the next line dirty if
    1:       // there is one.
    1:       if (line != line_end) {
    1:         line->MarkPreviousMarginDirty();
    1:       }
    1:       haveAdvancedToNextLine = PR_TRUE;
    1:     } else {
    1:       // Make the line that just lost a frame dirty, and advance to
    1:       // the next line.
    1:       if (!deletedNextContinuation || isLastFrameOnLine ||
    1:           !line->Contains(deletedNextContinuation)) {
    1:         line->MarkDirty();
    1:         ++line;
    1:         haveAdvancedToNextLine = PR_TRUE;
    1:       }
    1:     }
    1: 
    1:     if (deletedNextContinuation) {
    1:       // See if we should keep looking in the current flow's line list.
    1:       if (deletedNextContinuation->GetParent() != this) {
    1:         // The deceased frames continuation is not a child of the
    1:         // current block. So break out of the loop so that we advance
    1:         // to the next parent.
33783:         //
33783:         // If we have a continuation in a different block then all bets are
33783:         // off regarding whether we are deleting frames without actual content,
33783:         // so don't propagate FRAMES_ARE_EMPTY any further.
33783:         aFlags &= ~FRAMES_ARE_EMPTY;
    1:         break;
    1:       }
    1: 
    1:       // If we advanced to the next line then check if we should switch to the
    1:       // overflow line list.
    1:       if (haveAdvancedToNextLine) {
    1:         if (line != line_end && !searchingOverflowList &&
    1:             !line->Contains(deletedNextContinuation)) {
    1:           // We have advanced to the next *normal* line but the next-in-flow
    1:           // is not there - force a switch to the overflow line list.
    1:           line = line_end;
    1:         }
    1: 
 6709:         TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
    1: #ifdef NOISY_REMOVE_FRAME
33388:         printf("DoRemoveFrame: now on %s line=%p\n",
33388:                searchingOverflowList?"overflow":"normal", line.get());
    1: #endif
    1:       }
    1:     }
    1:   }
    1: 
22195:   if (!(aFlags & FRAMES_ARE_EMPTY) && line.next() != line_end) {
28590:     line.next()->MarkDirty();
 6029:     line.next()->SetInvalidateTextRuns(PR_TRUE);
 6029:   }
 6029: 
    1: #ifdef DEBUG
    1:   VerifyLines(PR_TRUE);
    1: #endif
    1: 
    1:   // Advance to next flow block if the frame has more continuations
32106:   return RemoveBlockChild(aDeletedFrame, !(aFlags & REMOVE_FIXED_CONTINUATIONS));
    1: }
    1: 
 4006: nsresult
 4006: nsBlockFrame::StealFrame(nsPresContext* aPresContext,
 4006:                          nsIFrame*      aChild,
 4006:                          PRBool         aForceNormal)
 4006: {
 4006:   NS_PRECONDITION(aPresContext && aChild, "null pointer");
 4006: 
32108:   if ((aChild->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
32108:       aChild->GetStyleDisplay()->IsFloating()) {
32844:     PRBool removed = mFloats.RemoveFrameIfPresent(aChild);
32108:     if (!removed) {
49010:       nsFrameList* list = GetPushedFloats();
32108:       if (list) {
32844:         removed = list->RemoveFrameIfPresent(aChild);
32844:       }
32844:     }
32844:     return removed ? NS_OK : NS_ERROR_UNEXPECTED;
32108:   }
32108: 
 4006:   if ((aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
 4006:       && !aForceNormal)
 4006:     return nsContainerFrame::StealFrame(aPresContext, aChild);
 4006: 
 4006:   // Find the line and the previous sibling that contains
 4006:   // aChild; we also find the pointer to the line.
 4006:   nsLineList::iterator line = mLines.begin(),
 6709:                        line_start = line,
 4006:                        line_end = mLines.end();
 4006:   PRBool searchingOverflowList = PR_FALSE;
 4006:   nsIFrame* prevSibling = nsnull;
 4006:   // Make sure we look in the overflow lines even if the normal line
 4006:   // list is empty
 6709:   TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
 4006:   while (line != line_end) {
 4006:     nsIFrame* frame = line->mFirstChild;
 4006:     PRInt32 n = line->GetChildCount();
 4006:     while (--n >= 0) {
 4006:       if (frame == aChild) {
 4006:         // Disconnect from sibling list
33276:         if (frame == line->mFirstChild) {
33276:           line->mFirstChild = frame->GetNextSibling();
33276:         }
33276:         if (searchingOverflowList) {
33276:           // XXXbz If we switch overflow lines to nsFrameList, we should
33276:           // change this SetNextSibling call.
 4006:           if (prevSibling)
 4006:             prevSibling->SetNextSibling(frame->GetNextSibling());
 4006:           frame->SetNextSibling(nsnull);
33276:         } else {
33388:           mFrames.RemoveFrame(frame);
33276:         }
 4006: 
 4006:         // Register removal with the line boxes
 4006:         PRInt32 count = line->GetChildCount();
 4006:         line->SetChildCount(--count);
 4006:         if (count > 0) {
 4006:            line->MarkDirty();
 4006:         }
 4006:         else {
 4006:           // Remove the line box
 4006:           nsLineBox* lineBox = line;
 4006:           if (searchingOverflowList) {
 4006:             // Erase line, but avoid making the overflow line list empty
 4006:             nsLineList* lineList = RemoveOverflowLines();
36689:             line = lineList->erase(line);
 4006:             if (!lineList->empty()) {
 4006:               nsresult rv = SetOverflowLines(lineList);
 4006:               NS_ENSURE_SUCCESS(rv, rv);
33259:             } else {
33259:               delete lineList;
36689:               // We just invalidated our iterators.  Since we were in
36689:               // the overflow lines list, which is now empty, set them
36689:               // so we're at the end of the regular line list.
36689:               line_start = mLines.begin();
36689:               line_end = mLines.end();
36689:               line = line_end;
 4006:             }
 4006:           }
 4006:           else {
36689:             line = mLines.erase(line);
 4006:           }
 4006:           lineBox->Destroy(aPresContext->PresShell());
 4006:           if (line != line_end) {
 4006:             // Line disappeared, so tell next line it may have to change position
 4006:             line->MarkPreviousMarginDirty();
 4006:           }
 4006:         }
 4006: 
 4006:         // Ok, we're done
 4006:         return NS_OK;
 4006:       }
 4006:       prevSibling = frame;
 4006:       frame = frame->GetNextSibling();
 4006:     }
 4006:     ++line;
 6709:     TryAllLines(&line, &line_start, &line_end, &searchingOverflowList);
33276:     if (prevSibling && !prevSibling->GetNextSibling()) {
33276:       // We just switched to the overflow list.  Null out prevSibling
33276:       prevSibling = nsnull;
33276:     }
 4006:   }
 4006:   return NS_ERROR_UNEXPECTED;
 4006: }
 4006: 
    1: void
    1: nsBlockFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
22195:                                     nsIFrame*      aNextInFlow,
22195:                                     PRBool         aDeletingEmptyFrames)
    1: {
19448:   NS_PRECONDITION(aNextInFlow->GetPrevInFlow(), "bad next-in-flow");
 4006: 
32111:   if (aNextInFlow->GetStateBits() &
32111:       (NS_FRAME_OUT_OF_FLOW | NS_FRAME_IS_OVERFLOW_CONTAINER)) {
22195:     nsContainerFrame::DeleteNextInFlowChild(aPresContext,
22195:         aNextInFlow, aDeletingEmptyFrames);
 4006:   }
 4006:   else {
22195:     DoRemoveFrame(aNextInFlow,
22195:         aDeletingEmptyFrames ? FRAMES_ARE_EMPTY : 0);
    1:   }
 4006: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // Float support
    1: 
15299: nsRect
27101: nsBlockFrame::AdjustFloatAvailableSpace(nsBlockReflowState& aState,
27101:                                         const nsRect& aFloatAvailableSpace,
15299:                                         nsIFrame* aFloatFrame)
    1: {
    1:   // Compute the available width. By default, assume the width of the
    1:   // containing block.
    1:   nscoord availWidth;
15299:   const nsStyleDisplay* floatDisplay = aFloatFrame->GetStyleDisplay();
    1: 
    1:   if (NS_STYLE_DISPLAY_TABLE != floatDisplay->mDisplay ||
    1:       eCompatibility_NavQuirks != aState.mPresContext->CompatibilityMode() ) {
    1:     availWidth = aState.mContentArea.width;
    1:   }
    1:   else {
    1:     // This quirk matches the one in nsBlockReflowState::FlowAndPlaceFloat
    1:     // give tables only the available space
    1:     // if they can shrink we may not be constrained to place
    1:     // them in the next line
27101:     availWidth = aFloatAvailableSpace.width;
    1:   }
    1: 
    1:   nscoord availHeight = NS_UNCONSTRAINEDSIZE == aState.mContentArea.height
    1:                         ? NS_UNCONSTRAINEDSIZE
49569:                         : NS_MAX(0, aState.mContentArea.YMost() - aState.mY);
    1: 
16580: #ifdef DISABLE_FLOAT_BREAKING_IN_COLUMNS
16580:   if (availHeight != NS_UNCONSTRAINEDSIZE &&
16580:       nsLayoutUtils::GetClosestFrameOfType(this, nsGkAtoms::columnSetFrame)) {
16580:     // Tell the float it has unrestricted height, so it won't break.
16580:     // If the float doesn't actually fit in the column it will fail to be
16580:     // placed, and either move to the top of the next column or just
16580:     // overflow.
16580:     availHeight = NS_UNCONSTRAINEDSIZE;
16580:   }
16580: #endif
16580: 
49569:   return nsRect(aState.mContentArea.x,
49569:                 aState.mContentArea.y,
    1:                 availWidth, availHeight);
15299: }
15299: 
15299: nscoord
15299: nsBlockFrame::ComputeFloatWidth(nsBlockReflowState& aState,
27101:                                 const nsRect&       aFloatAvailableSpace,
32107:                                 nsIFrame*           aFloat)
15299: {
32107:   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
32107:                   "aFloat must be an out-of-flow frame");
15299:   // Reflow the float.
27101:   nsRect availSpace = AdjustFloatAvailableSpace(aState, aFloatAvailableSpace,
32107:                                                 aFloat);
32107: 
32107:   nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState, aFloat, 
15299:                             nsSize(availSpace.width, availSpace.height));
15299:   return floatRS.ComputedWidth() + floatRS.mComputedBorderPadding.LeftRight() +
15299:     floatRS.mComputedMargin.LeftRight();
15299: }
15299: 
15299: nsresult
15299: nsBlockFrame::ReflowFloat(nsBlockReflowState& aState,
48980:                           const nsRect&       aAdjustedAvailableSpace,
32107:                           nsIFrame*           aFloat,
15299:                           nsMargin&           aFloatMargin,
48981:                           PRBool              aFloatPushedDown,
15299:                           nsReflowStatus&     aReflowStatus)
15299: {
32107:   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
32107:                   "aFloat must be an out-of-flow frame");
15299:   // Reflow the float.
15299:   aReflowStatus = NS_FRAME_COMPLETE;
15299: 
15299: #ifdef NOISY_FLOAT
15299:   printf("Reflow Float %p in parent %p, availSpace(%d,%d,%d,%d)\n",
32107:           aFloat, this, 
27101:           aFloatAvailableSpace.x, aFloatAvailableSpace.y, 
27101:           aFloatAvailableSpace.width, aFloatAvailableSpace.height
15299:   );
15299: #endif
15299: 
32107:   nsHTMLReflowState floatRS(aState.mPresContext, aState.mReflowState, aFloat,
48980:                             nsSize(aAdjustedAvailableSpace.width,
48980:                                    aAdjustedAvailableSpace.height));
    1: 
48981:   // Normally the mIsTopOfPage state is copied from the parent reflow
48981:   // state.  However, when reflowing a float, if we've placed other
48981:   // floats that force this float *down* or *narrower*, we should unset
48981:   // the mIsTopOfPage state.
48981:   // FIXME: This is somewhat redundant with the |isAdjacentWithTop|
48981:   // variable below, which has the exact same effect.  Perhaps it should
48981:   // be merged into that, except that the test for narrowing here is not
48981:   // about adjacency with the top, so it seems misleading.
48981:   if (floatRS.mFlags.mIsTopOfPage &&
48981:       (aFloatPushedDown ||
48981:        aAdjustedAvailableSpace.width != aState.mContentArea.width)) {
48981:     floatRS.mFlags.mIsTopOfPage = PR_FALSE;
48981:   }
48981: 
48981:   // Setup a block reflow context to reflow the float.
    1:   nsBlockReflowContext brc(aState.mPresContext, aState.mReflowState);
    1: 
    1:   // Reflow the float
    1:   PRBool isAdjacentWithTop = aState.IsAdjacentWithTop();
    1: 
    1:   nsIFrame* clearanceFrame = nsnull;
    1:   nsresult rv;
    1:   do {
    1:     nsCollapsingMargin margin;
    1:     PRBool mayNeedRetry = PR_FALSE;
    1:     floatRS.mDiscoveredClearance = nsnull;
    1:     // Only first in flow gets a top margin.
32107:     if (!aFloat->GetPrevInFlow()) {
    1:       nsBlockReflowContext::ComputeCollapsedTopMargin(floatRS, &margin,
    1:                                                       clearanceFrame, &mayNeedRetry);
    1: 
    1:       if (mayNeedRetry && !clearanceFrame) {
    1:         floatRS.mDiscoveredClearance = &clearanceFrame;
23305:         // We don't need to push the float manager state because the the block has its own
23305:         // float manager that will be destroyed and recreated
    1:       }
    1:     }
    1: 
48980:     rv = brc.ReflowBlock(aAdjustedAvailableSpace, PR_TRUE, margin,
    1:                          0, isAdjacentWithTop,
14460:                          nsnull, floatRS,
 6521:                          aReflowStatus, aState);
    1:   } while (NS_SUCCEEDED(rv) && clearanceFrame);
    1: 
    1:   // An incomplete reflow status means we should split the float 
    1:   // if the height is constrained (bug 145305). 
15299:   if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus) &&
48980:       (NS_UNCONSTRAINEDSIZE == aAdjustedAvailableSpace.height))
    1:     aReflowStatus = NS_FRAME_COMPLETE;
    1: 
    1:   if (aReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW) {
    1:     aState.mReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
    1:   }
    1: 
32107:   if (aFloat->GetType() == nsGkAtoms::letterFrame) {
    1:     // We never split floating first letters; an incomplete state for
    1:     // such frames simply means that there is more content to be
    1:     // reflowed on the line.
    1:     if (NS_FRAME_IS_NOT_COMPLETE(aReflowStatus)) 
    1:       aReflowStatus = NS_FRAME_COMPLETE;
    1:   }
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Capture the margin information for the caller
30321:   aFloatMargin = floatRS.mComputedMargin; // float margins don't collapse
    1: 
    1:   const nsHTMLReflowMetrics& metrics = brc.GetMetrics();
    1: 
    1:   // Set the rect, make sure the view is properly sized and positioned,
    1:   // and tell the frame we're done reflowing it
    1:   // XXXldb This seems like the wrong place to be doing this -- shouldn't
    1:   // we be doing this in nsBlockReflowState::FlowAndPlaceFloat after
    1:   // we've positioned the float, and shouldn't we be doing the equivalent
    1:   // of |::PlaceFrameView| here?
32107:   aFloat->SetSize(nsSize(metrics.width, metrics.height));
32107:   if (aFloat->HasView()) {
32107:     nsContainerFrame::SyncFrameViewAfterReflow(aState.mPresContext, aFloat,
32107:                                                aFloat->GetView(),
    1:                                                &metrics.mOverflowArea,
    1:                                                NS_FRAME_NO_MOVE_VIEW);
    1:   }
    1:   // Pass floatRS so the frame hierarchy can be used (redoFloatRS has the same hierarchy)  
32107:   aFloat->DidReflow(aState.mPresContext, &floatRS,
    1:                         NS_FRAME_REFLOW_FINISHED);
    1: 
    1: #ifdef NOISY_FLOAT
    1:   printf("end ReflowFloat %p, sized to %d,%d\n",
32107:          aFloat, metrics.width, metrics.height);
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
32109: PRUint8
32109: nsBlockFrame::FindTrailingClear()
32109: {
32109:   // find the break type of the last line
32109:   for (nsIFrame* b = this; b; b = b->GetPrevInFlow()) {
32109:     nsBlockFrame* block = static_cast<nsBlockFrame*>(b);
32109:     line_iterator endLine = block->end_lines();
32109:     if (endLine != block->begin_lines()) {
32109:       --endLine;
32109:       return endLine->GetBreakTypeAfter();
32109:     }
32109:   }
32247:   return NS_STYLE_CLEAR_NONE;
32109: }
32109: 
32108: nsresult
49010: nsBlockFrame::ReflowPushedFloats(nsBlockReflowState& aState,
32108:                                        nsRect&             aBounds,
32108:                                        nsReflowStatus&     aStatus)
32108: {
32108:   nsresult rv = NS_OK;
48993:   for (nsIFrame* f = mFloats.FirstChild(), *next;
49010:        f && (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT);
48993:        f = next) {
48993:     // save next sibling now, since reflowing could push the entire
48993:     // float, changing its siblings
48993:     next = f->GetNextSibling();
48993: 
32108:     if (NS_SUBTREE_DIRTY(f) || aState.mReflowState.ShouldReflowAllKids()) {
32108:       // Cache old bounds
32108:       nsRect oldRect = f->GetRect();
32108:       nsRect oldOverflow = f->GetOverflowRect();
32108: 
32108:       // Reflow
48997:       aState.FlowAndPlaceFloat(f);
32108: 
32108:       // Invalidate if there was a position or size change
32108:       nsRect rect = f->GetRect();
32108:       if (rect != oldRect) {
32108:         nsRect dirtyRect = oldOverflow;
32108:         dirtyRect.MoveBy(oldRect.x, oldRect.y);
32108:         Invalidate(dirtyRect);
32108: 
32108:         dirtyRect = f->GetOverflowRect();
32108:         dirtyRect.MoveBy(rect.x, rect.y);
32108:         Invalidate(dirtyRect);
32108:       }
32108:     }
32108:     else {
32108:       // Just reload the float region into the space manager
32108:       nsRect region = nsFloatManager::GetRegionFor(f);
32108:       aState.mFloatManager->AddFloat(f, region);
32108:       if (f->GetNextInFlow())
32108:         NS_MergeReflowStatusInto(&aStatus, NS_FRAME_OVERFLOW_INCOMPLETE);
32108:     }
32108: 
32108:     ConsiderChildOverflow(aBounds, f);
32108:   }
32108: 
32109:   // If there are continued floats, then we may need to continue BR clearance
32109:   if (0 != aState.ClearFloats(0, NS_STYLE_CLEAR_LEFT_AND_RIGHT)) {
32109:     aState.mFloatBreakType = static_cast<nsBlockFrame*>(GetPrevInFlow())
32109:                                ->FindTrailingClear();
32109:   }
32109: 
32108:   return rv;
32108: }
32108: 
32108: void
32108: nsBlockFrame::RecoverFloats(nsFloatManager& aFloatManager)
32108: {
32108:   // Recover our own floats
49010:   nsIFrame* stop = nsnull; // Stop before we reach pushed floats that
32108:                            // belong to our next-in-flow
32108:   for (nsIFrame* f = mFloats.FirstChild(); f && f != stop; f = f->GetNextSibling()) {
32108:     nsRect region = nsFloatManager::GetRegionFor(f);
32108:     aFloatManager.AddFloat(f, region);
32108:     if (!stop && f->GetNextInFlow())
32108:       stop = f->GetNextInFlow();
32108:   }
32108: 
32108:   // Recurse into our overflow container children
32108:   for (nsIFrame* oc = GetFirstChild(nsGkAtoms::overflowContainersList);
32108:        oc; oc = oc->GetNextSibling()) {
32108:     RecoverFloatsFor(oc, aFloatManager);
32108:   }
32108: 
32108:   // Recurse into our normal children
32108:   for (nsBlockFrame::line_iterator line = begin_lines(); line != end_lines(); ++line) {
32108:     if (line->IsBlock()) {
32108:       RecoverFloatsFor(line->mFirstChild, aFloatManager);
32108:     }
32108:   }
32108: }
32108: 
32108: void
32108: nsBlockFrame::RecoverFloatsFor(nsIFrame*       aFrame,
32108:                                nsFloatManager& aFloatManager)
32108: {
32108:   NS_PRECONDITION(aFrame, "null frame");
32108:   // Only blocks have floats
32108:   nsBlockFrame* block = nsLayoutUtils::GetAsBlock(aFrame);
32108:   // Don't recover any state inside a block that has its own space manager
32108:   // (we don't currently have any blocks like this, though, thanks to our
32108:   // use of extra frames for 'overflow')
32108:   if (block && !nsBlockFrame::BlockNeedsFloatManager(block)) {
32108:     // If the element is relatively positioned, then adjust x and y
32108:     // accordingly so that we consider relatively positioned frames
32108:     // at their original position.
32108:     nsPoint pos = block->GetPosition() - block->GetRelativeOffset();
32108:     aFloatManager.Translate(pos.x, pos.y);
32108:     block->RecoverFloats(aFloatManager);
32108:     aFloatManager.Translate(-pos.x, -pos.y);
32108:   }
32108: }
32108: 
    1: //////////////////////////////////////////////////////////////////////
    1: // Painting, event handling
    1: 
    1: PRIntn
    1: nsBlockFrame::GetSkipSides() const
    1: {
 6521:   if (IS_TRUE_OVERFLOW_CONTAINER(this))
 4006:     return (1 << NS_SIDE_TOP) | (1 << NS_SIDE_BOTTOM);
 4006: 
    1:   PRIntn skip = 0;
 4006:   if (GetPrevInFlow()) {
    1:     skip |= 1 << NS_SIDE_TOP;
    1:   }
 4006:   nsIFrame* nif = GetNextInFlow();
 6521:   if (nif && !IS_TRUE_OVERFLOW_CONTAINER(nif)) {
    1:     skip |= 1 << NS_SIDE_BOTTOM;
    1:   }
    1:   return skip;
    1: }
    1: 
    1: #ifdef DEBUG
    1: static void ComputeCombinedArea(nsLineList& aLines,
    1:                                 nscoord aWidth, nscoord aHeight,
    1:                                 nsRect& aResult)
    1: {
    1:   nscoord xa = 0, ya = 0, xb = aWidth, yb = aHeight;
    1:   for (nsLineList::iterator line = aLines.begin(), line_end = aLines.end();
    1:        line != line_end;
    1:        ++line) {
    1:     // Compute min and max x/y values for the reflowed frame's
    1:     // combined areas
    1:     nsRect lineCombinedArea(line->GetCombinedArea());
    1:     nscoord x = lineCombinedArea.x;
    1:     nscoord y = lineCombinedArea.y;
    1:     nscoord xmost = x + lineCombinedArea.width;
    1:     nscoord ymost = y + lineCombinedArea.height;
    1:     if (x < xa) {
    1:       xa = x;
    1:     }
    1:     if (xmost > xb) {
    1:       xb = xmost;
    1:     }
    1:     if (y < ya) {
    1:       ya = y;
    1:     }
    1:     if (ymost > yb) {
    1:       yb = ymost;
    1:     }
    1:   }
    1: 
    1:   aResult.x = xa;
    1:   aResult.y = ya;
    1:   aResult.width = xb - xa;
    1:   aResult.height = yb - ya;
    1: }
    1: #endif
    1: 
    1: PRBool
    1: nsBlockFrame::IsVisibleInSelection(nsISelection* aSelection)
    1: {
    1:   nsCOMPtr<nsIDOMHTMLHtmlElement> html(do_QueryInterface(mContent));
    1:   nsCOMPtr<nsIDOMHTMLBodyElement> body(do_QueryInterface(mContent));
    1:   if (html || body)
    1:     return PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
    1:   PRBool visible;
    1:   nsresult rv = aSelection->ContainsNode(node, PR_TRUE, &visible);
    1:   return NS_SUCCEEDED(rv) && visible;
    1: }
    1: 
    1: /* virtual */ void
15339: nsBlockFrame::PaintTextDecorationLine(gfxContext* aCtx, 
12989:                                       const nsPoint& aPt,
    1:                                       nsLineBox* aLine,
    1:                                       nscolor aColor, 
12989:                                       gfxFloat aOffset, 
12989:                                       gfxFloat aAscent, 
12989:                                       gfxFloat aSize,
 4302:                                       const PRUint8 aDecoration) 
    1: {
    1:   NS_ASSERTION(!aLine->IsBlock(), "Why did we ask for decorations on a block?");
    1: 
    1:   nscoord start = aLine->mBounds.x;
    1:   nscoord width = aLine->mBounds.width;
    1: 
32863:   AdjustForTextIndent(aLine, start, width);
32863:       
32863:   // Only paint if we have a positive width
32863:   if (width > 0) {
32863:     gfxPoint pt(PresContext()->AppUnitsToGfxUnits(start + aPt.x),
32863:                 PresContext()->AppUnitsToGfxUnits(aLine->mBounds.y + aPt.y));
32863:     gfxSize size(PresContext()->AppUnitsToGfxUnits(width), aSize);
32863:     nsCSSRendering::PaintDecorationLine(
32863:       aCtx, aColor, pt, size,
32863:       PresContext()->AppUnitsToGfxUnits(aLine->GetAscent()),
32863:       aOffset, aDecoration, nsCSSRendering::DECORATION_STYLE_SOLID);
32863:   }
32863: }
32863: 
32863: /*virtual*/ void
32863: nsBlockFrame::AdjustForTextIndent(const nsLineBox* aLine,
32863:                                   nscoord& start,
32863:                                   nscoord& width)
32863: {
 8006:   if (!GetPrevContinuation() && aLine == begin_lines().get()) {
    1:     // Adjust for the text-indent.  See similar code in
    1:     // nsLineLayout::BeginLineReflow.
51778:     const nsStyleCoord &textIndent = GetStyleText()->mTextIndent;
51778:     nscoord pctBasis = 0;
51778:     if (textIndent.HasPercent()) {
51778:       // Only work out the percentage basis if we need to.
    1:       // It's a percentage of the containing block width.
    1:       nsIFrame* containingBlock =
    1:         nsHTMLReflowState::GetContainingBlockFor(this);
    1:       NS_ASSERTION(containingBlock, "Must have containing block!");
51778:       pctBasis = containingBlock->GetContentRect().width;
51778:     }
51778:     nscoord indent = nsRuleNode::ComputeCoordPercentCalc(textIndent, pctBasis);
    1: 
    1:     // Adjust the start position and the width of the decoration by the
    1:     // value of the indent.  Note that indent can be negative; that's OK.
    1:     // It'll just increase the width (which can also happen to be
    1:     // negative!).
    1:     start += indent;
    1:     width -= indent;
    1:   }
    1: }
    1: 
    1: #ifdef DEBUG
    1: static void DebugOutputDrawLine(PRInt32 aDepth, nsLineBox* aLine, PRBool aDrawn) {
    1:   if (nsBlockFrame::gNoisyDamageRepair) {
    1:     nsFrame::IndentBy(stdout, aDepth+1);
    1:     nsRect lineArea = aLine->GetCombinedArea();
    1:     printf("%s line=%p bounds=%d,%d,%d,%d ca=%d,%d,%d,%d\n",
    1:            aDrawn ? "draw" : "skip",
 3233:            static_cast<void*>(aLine),
    1:            aLine->mBounds.x, aLine->mBounds.y,
    1:            aLine->mBounds.width, aLine->mBounds.height,
    1:            lineArea.x, lineArea.y,
    1:            lineArea.width, lineArea.height);
    1:   }
    1: }
    1: #endif
    1: 
    1: static nsresult
    1: DisplayLine(nsDisplayListBuilder* aBuilder, const nsRect& aLineArea,
    1:             const nsRect& aDirtyRect, nsBlockFrame::line_iterator& aLine,
    1:             PRInt32 aDepth, PRInt32& aDrawnLines, const nsDisplayListSet& aLists,
    1:             nsBlockFrame* aFrame) {
    1:   // If the line's combined area (which includes child frames that
    1:   // stick outside of the line's bounding box or our bounding box)
    1:   // intersects the dirty rect then paint the line.
    1:   PRBool intersect = aLineArea.Intersects(aDirtyRect);
    1: #ifdef DEBUG
    1:   if (nsBlockFrame::gLamePaintMetrics) {
    1:     aDrawnLines++;
    1:   }
    1:   DebugOutputDrawLine(aDepth, aLine.get(), intersect);
    1: #endif
    1:   // The line might contain a placeholder for a visible out-of-flow, in which
    1:   // case we need to descend into it. If there is such a placeholder, we will
    1:   // have NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO set.
    1:   if (!intersect &&
    1:       !(aFrame->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO))
    1:     return NS_OK;
    1: 
    1:   nsresult rv;
    1:   nsDisplayList aboveTextDecorations;
    1:   PRBool lineInline = aLine->IsInline();
    1:   if (lineInline) {
    1:     // Display the text-decoration for the hypothetical anonymous inline box
    1:     // that wraps these inlines
    1:     rv = aFrame->DisplayTextDecorations(aBuilder, aLists.Content(),
    1:                                         &aboveTextDecorations, aLine);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // Block-level child backgrounds go on the blockBorderBackgrounds list ...
    1:   // Inline-level child backgrounds go on the regular child content list.
    1:   nsDisplayListSet childLists(aLists,
    1:       lineInline ? aLists.Content() : aLists.BlockBorderBackgrounds());
    1:   nsIFrame* kid = aLine->mFirstChild;
    1:   PRInt32 n = aLine->GetChildCount();
    1:   while (--n >= 0) {
    1:     rv = aFrame->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, childLists,
    1:                                           lineInline ? nsIFrame::DISPLAY_CHILD_INLINE : 0);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   
    1:   aLists.Content()->AppendToTop(&aboveTextDecorations);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                const nsRect&           aDirtyRect,
    1:                                const nsDisplayListSet& aLists)
    1: {
    1:   PRInt32 drawnLines; // Will only be used if set (gLamePaintMetrics).
    1:   PRInt32 depth = 0;
    1: #ifdef DEBUG
    1:   if (gNoisyDamageRepair) {
    1:       depth = GetDepth();
    1:       nsRect ca;
    1:       ::ComputeCombinedArea(mLines, mRect.width, mRect.height, ca);
    1:       nsFrame::IndentBy(stdout, depth);
    1:       ListTag(stdout);
    1:       printf(": bounds=%d,%d,%d,%d dirty(absolute)=%d,%d,%d,%d ca=%d,%d,%d,%d\n",
    1:              mRect.x, mRect.y, mRect.width, mRect.height,
    1:              aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height,
    1:              ca.x, ca.y, ca.width, ca.height);
    1:   }
    1:   PRTime start = LL_ZERO; // Initialize these variables to silence the compiler.
    1:   if (gLamePaintMetrics) {
    1:     start = PR_Now();
    1:     drawnLines = 0;
    1:   }
    1: #endif
    1: 
    1:   DisplayBorderBackgroundOutline(aBuilder, aLists);
    1: 
 4006:   if (GetPrevInFlow()) {
 4006:     DisplayOverflowContainers(aBuilder, aDirtyRect, aLists);
32108:     for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
49010:       if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
32108:          BuildDisplayListForChild(aBuilder, f, aDirtyRect, aLists);
32108:     }
 4006:   }
 4006: 
30783:   aBuilder->MarkFramesForDisplayList(this, mFloats, aDirtyRect);
30783:   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetChildList(),
30783:                                      aDirtyRect);
    1: 
    1:   // Don't use the line cursor if we might have a descendant placeholder ...
    1:   // it might skip lines that contain placeholders but don't themselves
    1:   // intersect with the dirty area.
    1:   nsLineBox* cursor = GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
    1:     ? nsnull : GetFirstLineContaining(aDirtyRect.y);
    1:   line_iterator line_end = end_lines();
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (cursor) {
    1:     for (line_iterator line = mLines.begin(cursor);
    1:          line != line_end;
    1:          ++line) {
    1:       nsRect lineArea = line->GetCombinedArea();
    1:       if (!lineArea.IsEmpty()) {
    1:         // Because we have a cursor, the combinedArea.ys are non-decreasing.
    1:         // Once we've passed aDirtyRect.YMost(), we can never see it again.
    1:         if (lineArea.y >= aDirtyRect.YMost()) {
    1:           break;
    1:         }
    1:         rv = DisplayLine(aBuilder, lineArea, aDirtyRect, line, depth, drawnLines,
    1:                          aLists, this);
    1:         if (NS_FAILED(rv))
    1:           break;
    1:       }
    1:     }
    1:   } else {
    1:     PRBool nonDecreasingYs = PR_TRUE;
    1:     PRInt32 lineCount = 0;
    1:     nscoord lastY = PR_INT32_MIN;
    1:     nscoord lastYMost = PR_INT32_MIN;
    1:     for (line_iterator line = begin_lines();
    1:          line != line_end;
    1:          ++line) {
    1:       nsRect lineArea = line->GetCombinedArea();
    1:       rv = DisplayLine(aBuilder, lineArea, aDirtyRect, line, depth, drawnLines,
    1:                        aLists, this);
    1:       if (NS_FAILED(rv))
    1:         break;
    1:       if (!lineArea.IsEmpty()) {
    1:         if (lineArea.y < lastY
    1:             || lineArea.YMost() < lastYMost) {
    1:           nonDecreasingYs = PR_FALSE;
    1:         }
    1:         lastY = lineArea.y;
    1:         lastYMost = lineArea.YMost();
    1:       }
    1:       lineCount++;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(rv) && nonDecreasingYs && lineCount >= MIN_LINES_NEEDING_CURSOR) {
    1:       SetupLineCursor();
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv) && (nsnull != mBullet) && HaveOutsideBullet()) {
    1:     // Display outside bullets manually
    1:     rv = BuildDisplayListForChild(aBuilder, mBullet, aDirtyRect, aLists);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gLamePaintMetrics) {
    1:     PRTime end = PR_Now();
    1: 
    1:     PRInt32 numLines = mLines.size();
    1:     if (!numLines) numLines = 1;
    1:     PRTime lines, deltaPerLine, delta;
    1:     LL_I2L(lines, numLines);
    1:     LL_SUB(delta, end, start);
    1:     LL_DIV(deltaPerLine, delta, lines);
    1: 
    1:     ListTag(stdout);
    1:     char buf[400];
    1:     PR_snprintf(buf, sizeof(buf),
    1:                 ": %lld elapsed (%lld per line) lines=%d drawn=%d skip=%d",
    1:                 delta, deltaPerLine,
    1:                 numLines, drawnLines, numLines - drawnLines);
    1:     printf("%s\n", buf);
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsBlockFrame::CreateAccessible()
    1: {
    1:   nsCOMPtr<nsIAccessibilityService> accService = 
    1:     do_GetService("@mozilla.org/accessibilityService;1");
46338:   if (!accService) {
46338:     return nsnull;
46338:   }
46338: 
46338:   nsPresContext* presContext = PresContext();
    1: 
    1:   // block frame may be for <hr>
    1:   if (mContent->Tag() == nsGkAtoms::hr) {
46338:     return accService->CreateHTMLHRAccessible(mContent,
46338:                                               presContext->PresShell());
46338:   }
46338: 
46338:   if (!mBullet || !presContext) {
14517:     if (!mContent->GetParent()) {
    1:       // Don't create accessible objects for the root content node, they are redundant with
    1:       // the nsDocAccessible object created with the document node
46338:       return nsnull;
    1:     }
    1:     
    1:     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc =
    1:       do_QueryInterface(mContent->GetDocument());
    1:     if (htmlDoc) {
    1:       nsCOMPtr<nsIDOMHTMLElement> body;
    1:       htmlDoc->GetBody(getter_AddRefs(body));
    1:       if (SameCOMIdentity(body, mContent)) {
    1:         // Don't create accessible objects for the body, they are redundant with
    1:         // the nsDocAccessible object created with the document node
46338:         return nsnull;
    1:       }
    1:     }
    1: 
    1:     // Not a bullet, treat as normal HTML container
46338:     return accService->CreateHyperTextAccessible(mContent,
46338:                                                  presContext->PresShell());
    1:   }
    1: 
    1:   // Create special list bullet accessible
    1:   const nsStyleList* myList = GetStyleList();
    1:   nsAutoString bulletText;
35581:   if (myList->GetListStyleImage() ||
35581:       myList->mListStyleType == NS_STYLE_LIST_STYLE_DISC ||
    1:       myList->mListStyleType == NS_STYLE_LIST_STYLE_CIRCLE ||
    1:       myList->mListStyleType == NS_STYLE_LIST_STYLE_SQUARE) {
    1:     bulletText.Assign(PRUnichar(0x2022));; // Unicode bullet character
    1:   }
    1:   else if (myList->mListStyleType != NS_STYLE_LIST_STYLE_NONE) {
    1:     mBullet->GetListItemText(*myList, bulletText);
    1:   }
    1: 
46338:   return accService->CreateHTMLLIAccessible(mContent, presContext->PresShell(),
46338:                                             bulletText);
    1: }
    1: #endif
    1: 
32392: void nsBlockFrame::ClearLineCursor()
32392: {
    1:   if (!(GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR)) {
    1:     return;
    1:   }
    1: 
39965:   Properties().Delete(LineCursorProperty());
    1:   RemoveStateBits(NS_BLOCK_HAS_LINE_CURSOR);
    1: }
    1: 
32392: void nsBlockFrame::SetupLineCursor()
32392: {
    1:   if (GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR
    1:       || mLines.empty()) {
    1:     return;
    1:   }
    1:    
39965:   Properties().Set(LineCursorProperty(), mLines.front());
    1:   AddStateBits(NS_BLOCK_HAS_LINE_CURSOR);
    1: }
    1: 
32392: nsLineBox* nsBlockFrame::GetFirstLineContaining(nscoord y)
32392: {
    1:   if (!(GetStateBits() & NS_BLOCK_HAS_LINE_CURSOR)) {
    1:     return nsnull;
    1:   }
    1: 
39965:   FrameProperties props = Properties();
39965:   
 3233:   nsLineBox* property = static_cast<nsLineBox*>
39965:     (props.Get(LineCursorProperty()));
    1:   line_iterator cursor = mLines.begin(property);
    1:   nsRect cursorArea = cursor->GetCombinedArea();
    1: 
    1:   while ((cursorArea.IsEmpty() || cursorArea.YMost() > y)
    1:          && cursor != mLines.front()) {
    1:     cursor = cursor.prev();
    1:     cursorArea = cursor->GetCombinedArea();
    1:   }
    1:   while ((cursorArea.IsEmpty() || cursorArea.YMost() <= y)
    1:          && cursor != mLines.back()) {
    1:     cursor = cursor.next();
    1:     cursorArea = cursor->GetCombinedArea();
    1:   }
    1: 
    1:   if (cursor.get() != property) {
39965:     props.Set(LineCursorProperty(), cursor.get());
    1:   }
    1: 
    1:   return cursor.get();
    1: }
    1: 
    1: /* virtual */ void
    1: nsBlockFrame::ChildIsDirty(nsIFrame* aChild)
    1: {
    1:   // See if the child is absolutely positioned
    1:   if (aChild->GetStateBits() & NS_FRAME_OUT_OF_FLOW &&
    1:       aChild->GetStyleDisplay()->IsAbsolutelyPositioned()) {
    1:     // do nothing
    1:   } else if (aChild == mBullet && HaveOutsideBullet()) {
    1:     // The bullet lives in the first line, unless the first line has
    1:     // height 0 and there is a second line, in which case it lives
    1:     // in the second line.
    1:     line_iterator bulletLine = begin_lines();
    1:     if (bulletLine != end_lines() && bulletLine->mBounds.height == 0 &&
    1:         bulletLine != mLines.back()) {
    1:       bulletLine = bulletLine.next();
    1:     }
    1:     
    1:     if (bulletLine != end_lines()) {
    1:       MarkLineDirty(bulletLine);
    1:     }
    1:     // otherwise we have an empty line list, and ReflowDirtyLines
    1:     // will handle reflowing the bullet.
    1:   } else {
 6029:     // Mark the line containing the child frame dirty. We would rather do this
 6029:     // in MarkIntrinsicWidthsDirty but that currently won't tell us which
 6029:     // child is being dirtied.
12355:     PRBool isValid;
12355:     nsBlockInFlowLineIterator iter(this, aChild, &isValid);
12355:     if (isValid) {
20345:       iter.GetContainer()->MarkLineDirty(iter.GetLine(), iter.GetLineList());
    1:     }
 6029:   }
    1: 
    1:   nsBlockFrameSuper::ChildIsDirty(aChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::Init(nsIContent*      aContent,
    1:                    nsIFrame*        aParent,
    1:                    nsIFrame*        aPrevInFlow)
    1: {
    1:   if (aPrevInFlow) {
23296:     // Copy over the block frame type flags
    1:     nsBlockFrame*  blockFrame = (nsBlockFrame*)aPrevInFlow;
    1: 
36804:     // Don't copy NS_BLOCK_HAS_FIRST_LETTER_CHILD as that is set on the first
36804:     // continuation only.
    1:     SetFlags(blockFrame->mState &
36804:              (NS_BLOCK_FLAGS_MASK &
36804:                (~NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET &
36804:                 ~NS_BLOCK_HAS_FIRST_LETTER_CHILD)));
    1:   }
    1: 
    1:   nsresult rv = nsBlockFrameSuper::Init(aContent, aParent, aPrevInFlow);
    1: 
 6829:   if (!aPrevInFlow ||
 6829:       aPrevInFlow->GetStateBits() & NS_BLOCK_NEEDS_BIDI_RESOLUTION)
 5590:     AddStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
 5590: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBlockFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                   nsFrameList&    aChildList)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
 4205:   if (nsGkAtoms::absoluteList == aListName) {
    1:     mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
    1:   }
    1:   else if (nsGkAtoms::floatList == aListName) {
    1:     mFloats.SetFrames(aChildList);
    1:   }
    1:   else {
  238:     nsPresContext* presContext = PresContext();
    1: 
 1026: #ifdef DEBUG
 1026:     // The only times a block that is an anonymous box is allowed to have a
 1026:     // first-letter frame are when it's the block inside a non-anonymous cell,
 1026:     // the block inside a fieldset, a scrolled content block, or a column
 1026:     // content block.  Note that this means that blocks which are the anonymous
 8324:     // block in {ib} splits do NOT get first-letter frames.  Note that
 8324:     // NS_BLOCK_HAS_FIRST_LETTER_STYLE gets set on all continuations of the
 8324:     // block.
34387:     nsIAtom *pseudo = GetStyleContext()->GetPseudo();
 1026:     PRBool haveFirstLetterStyle =
 1026:       (!pseudo ||
 1026:        (pseudo == nsCSSAnonBoxes::cellContent &&
34387:         mParent->GetStyleContext()->GetPseudo() == nsnull) ||
 1026:        pseudo == nsCSSAnonBoxes::fieldsetContent ||
 1026:        pseudo == nsCSSAnonBoxes::scrolledContent ||
 1026:        pseudo == nsCSSAnonBoxes::columnContent) &&
 6818:       !IsFrameOfType(eMathML) &&
 1026:       nsRefPtr<nsStyleContext>(GetFirstLetterStyle(presContext)) != nsnull;
 1026:     NS_ASSERTION(haveFirstLetterStyle ==
  551:                  ((mState & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0),
  551:                  "NS_BLOCK_HAS_FIRST_LETTER_STYLE state out of sync");
 1026: #endif
    1:     
    1:     rv = AddFrames(aChildList, nsnull);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
43528:     // Create a list bullet if this is a list-item. Note that this is
43528:     // done here so that RenumberLists will work (it needs the bullets
43528:     // to store the bullet numbers).  Also note that due to various
43528:     // wrapper frames (scrollframes, columns) we want to use the
43528:     // outermost (primary, ideally, but it's not set yet when we get
43528:     // here) frame of our content for the display check.  On the other
43528:     // hand, we look at ourselves for the GetPrevInFlow() check, since
43528:     // for a columnset we don't want a bullet per column.  Note that
43528:     // the outermost frame for the content is the primary frame in
43528:     // most cases; the ones when it's not (like tables) can't be
43528:     // NS_STYLE_DISPLAY_LIST_ITEM).
43528:     nsIFrame* possibleListItem = this;
43528:     while (1) {
43528:       nsIFrame* parent = possibleListItem->GetParent();
43528:       if (parent->GetContent() != GetContent()) {
43528:         break;
43528:       }
43528:       possibleListItem = parent;
43528:     }
    1:     if ((nsnull == GetPrevInFlow()) &&
43528:         (NS_STYLE_DISPLAY_LIST_ITEM ==
43528:            possibleListItem->GetStyleDisplay()->mDisplay) &&
    1:         (nsnull == mBullet)) {
    1:       // Resolve style for the bullet frame
    1:       const nsStyleList* styleList = GetStyleList();
35554:       nsCSSPseudoElements::Type pseudoType;
    1:       switch (styleList->mListStyleType) {
    1:         case NS_STYLE_LIST_STYLE_DISC:
    1:         case NS_STYLE_LIST_STYLE_CIRCLE:
    1:         case NS_STYLE_LIST_STYLE_SQUARE:
35554:           pseudoType = nsCSSPseudoElements::ePseudo_mozListBullet;
    1:           break;
    1:         default:
35554:           pseudoType = nsCSSPseudoElements::ePseudo_mozListNumber;
    1:           break;
    1:       }
    1: 
    1:       nsIPresShell *shell = presContext->PresShell();
    1: 
 4200:       nsStyleContext* parentStyle =
35554:         CorrectStyleParentFrame(this,
35554:           nsCSSPseudoElements::GetPseudoAtom(pseudoType))->GetStyleContext();
    1:       nsRefPtr<nsStyleContext> kidSC = shell->StyleSet()->
41641:         ResolvePseudoElementStyle(mContent->AsElement(), pseudoType,
41641:                                   parentStyle);
    1: 
    1:       // Create bullet frame
    1:       nsBulletFrame* bullet = new (shell) nsBulletFrame(kidSC);
    1:       if (nsnull == bullet) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       bullet->Init(mContent, this, nsnull);
    1: 
    1:       // If the list bullet frame should be positioned inside then add
    1:       // it to the flow now.
    1:       if (NS_STYLE_LIST_STYLE_POSITION_INSIDE ==
    1:           styleList->mListStylePosition) {
33276:         nsFrameList bulletList(bullet, bullet);
33276:         AddFrames(bulletList, nsnull);
    1:         mState &= ~NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET;
    1:       }
    1:       else {
    1:         mState |= NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET;
    1:       }
    1: 
    1:       mBullet = bullet;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
32392: PRBool
32392: nsBlockFrame::BulletIsEmpty() const
32392: {
43604:   NS_ASSERTION(mContent->GetPrimaryFrame()->GetStyleDisplay()->mDisplay ==
43604:                  NS_STYLE_DISPLAY_LIST_ITEM &&
32392:                HaveOutsideBullet(),
32392:                "should only care when we have an outside bullet");
32392:   const nsStyleList* list = GetStyleList();
32392:   return list->mListStyleType == NS_STYLE_LIST_STYLE_NONE &&
35581:          !list->GetListStyleImage();
32392: }
32392: 
    1: // static
    1: PRBool
    1: nsBlockFrame::FrameStartsCounterScope(nsIFrame* aFrame)
    1: {
    1:   nsIContent* content = aFrame->GetContent();
33329:   if (!content || !content->IsHTML())
    1:     return PR_FALSE;
    1: 
    1:   nsIAtom *localName = content->NodeInfo()->NameAtom();
    1:   return localName == nsGkAtoms::ol ||
    1:          localName == nsGkAtoms::ul ||
    1:          localName == nsGkAtoms::dir ||
    1:          localName == nsGkAtoms::menu;
    1: }
    1: 
 1158: PRBool
    1: nsBlockFrame::RenumberLists(nsPresContext* aPresContext)
    1: {
    1:   if (!FrameStartsCounterScope(this)) {
    1:     // If this frame doesn't start a counter scope then we don't need
    1:     // to renumber child list items.
 1158:     return PR_FALSE;
    1:   }
    1: 
    1:   // Setup initial list ordinal value
    1:   // XXX Map html's start property to counter-reset style
    1:   PRInt32 ordinal = 1;
    1: 
    1:   nsGenericHTMLElement *hc = nsGenericHTMLElement::FromContent(mContent);
    1: 
    1:   if (hc) {
    1:     const nsAttrValue* attr = hc->GetParsedAttr(nsGkAtoms::start);
    1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
    1:       ordinal = attr->GetIntegerValue();
    1:     }
    1:   }
    1: 
    1:   // Get to first-in-flow
    1:   nsBlockFrame* block = (nsBlockFrame*) GetFirstInFlow();
 1158:   return RenumberListsInBlock(aPresContext, block, &ordinal, 0);
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::RenumberListsInBlock(nsPresContext* aPresContext,
    1:                                    nsBlockFrame* aBlockFrame,
    1:                                    PRInt32* aOrdinal,
    1:                                    PRInt32 aDepth)
    1: {
12165:   // Examine each line in the block
12165:   PRBool foundValidLine;
12165:   nsBlockInFlowLineIterator bifLineIter(aBlockFrame, &foundValidLine);
12165:   
12165:   if (!foundValidLine)
12165:     return PR_FALSE;
12165: 
    1:   PRBool renumberedABullet = PR_FALSE;
    1: 
12165:   do {
12165:     nsLineList::iterator line = bifLineIter.GetLine();
    1:     nsIFrame* kid = line->mFirstChild;
    1:     PRInt32 n = line->GetChildCount();
    1:     while (--n >= 0) {
    1:       PRBool kidRenumberedABullet = RenumberListsFor(aPresContext, kid, aOrdinal, aDepth);
    1:       if (kidRenumberedABullet) {
    1:         line->MarkDirty();
    1:         renumberedABullet = PR_TRUE;
    1:       }
    1:       kid = kid->GetNextSibling();
    1:     }
12165:   } while (bifLineIter.Next());
    1: 
    1:   return renumberedABullet;
    1: }
    1: 
    1: PRBool
    1: nsBlockFrame::RenumberListsFor(nsPresContext* aPresContext,
    1:                                nsIFrame* aKid,
    1:                                PRInt32* aOrdinal,
    1:                                PRInt32 aDepth)
    1: {
    1:   NS_PRECONDITION(aPresContext && aKid && aOrdinal, "null params are immoral!");
    1: 
    1:   // add in a sanity check for absurdly deep frame trees.  See bug 42138
    1:   if (MAX_DEPTH_FOR_LIST_RENUMBERING < aDepth)
    1:     return PR_FALSE;
    1: 
    1:   // if the frame is a placeholder, then get the out of flow frame
    1:   nsIFrame* kid = nsPlaceholderFrame::GetRealFrameFor(aKid);
    1: 
    1:   // drill down through any wrappers to the real frame
    1:   kid = kid->GetContentInsertionFrame();
    1: 
12165:   // possible there is no content insertion frame
12165:   if (!kid)
12165:     return PR_FALSE;
12165: 
12165:   PRBool kidRenumberedABullet = PR_FALSE;
12165: 
    1:   // If the frame is a list-item and the frame implements our
    1:   // block frame API then get its bullet and set the list item
    1:   // ordinal.
    1:   const nsStyleDisplay* display = kid->GetStyleDisplay();
    1:   if (NS_STYLE_DISPLAY_LIST_ITEM == display->mDisplay) {
    1:     // Make certain that the frame is a block frame in case
    1:     // something foreign has crept in.
15909:     nsBlockFrame* listItem = nsLayoutUtils::GetAsBlock(kid);
15909:     if (listItem) {
    1:       if (nsnull != listItem->mBullet) {
    1:         PRBool changed;
    1:         *aOrdinal = listItem->mBullet->SetListItemOrdinal(*aOrdinal,
    1:                                                           &changed);
    1:         if (changed) {
    1:           kidRenumberedABullet = PR_TRUE;
    1: 
20295:           // The ordinal changed - mark the bullet frame dirty.
20295:           listItem->ChildIsDirty(listItem->mBullet);
    1:         }
    1:       }
    1: 
    1:       // XXX temporary? if the list-item has child list-items they
    1:       // should be numbered too; especially since the list-item is
    1:       // itself (ASSUMED!) not to be a counter-resetter.
    1:       PRBool meToo = RenumberListsInBlock(aPresContext, listItem, aOrdinal, aDepth + 1);
    1:       if (meToo) {
    1:         kidRenumberedABullet = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   else if (NS_STYLE_DISPLAY_BLOCK == display->mDisplay) {
    1:     if (FrameStartsCounterScope(kid)) {
    1:       // Don't bother recursing into a block frame that is a new
    1:       // counter scope. Any list-items in there will be handled by
    1:       // it.
    1:     }
    1:     else {
    1:       // If the display=block element is a block frame then go ahead
    1:       // and recurse into it, as it might have child list-items.
15909:       nsBlockFrame* kidBlock = nsLayoutUtils::GetAsBlock(kid);
15909:       if (kidBlock) {
    1:         kidRenumberedABullet = RenumberListsInBlock(aPresContext, kidBlock, aOrdinal, aDepth + 1);
    1:       }
    1:     }
    1:   }
    1:   return kidRenumberedABullet;
    1: }
    1: 
    1: void
    1: nsBlockFrame::ReflowBullet(nsBlockReflowState& aState,
11520:                            nsHTMLReflowMetrics& aMetrics,
11520:                            nscoord aLineTop)
    1: {
    1:   const nsHTMLReflowState &rs = aState.mReflowState;
    1: 
    1:   // Reflow the bullet now
    1:   nsSize availSize;
    1:   // Make up a width since it doesn't really matter (XXX).
49569:   availSize.width = aState.mContentArea.width;
    1:   availSize.height = NS_UNCONSTRAINEDSIZE;
    1: 
    1:   // Get the reason right.
    1:   // XXXwaterson Should this look just like the logic in
    1:   // nsBlockReflowContext::ReflowBlock and nsLineLayout::ReflowFrame?
    1:   nsHTMLReflowState reflowState(aState.mPresContext, rs,
    1:                                 mBullet, availSize);
    1:   nsReflowStatus  status;
    1:   mBullet->WillReflow(aState.mPresContext);
    1:   mBullet->Reflow(aState.mPresContext, aMetrics, reflowState, status);
    1: 
27100:   // Get the float available space using our saved state from before we
27100:   // started reflowing the block, so that we ignore any floats inside
27100:   // the block.
27100:   // FIXME: aLineTop isn't actually set correctly by some callers, since
27100:   // they reposition the line.
27106:   nsRect floatAvailSpace =
48978:     aState.GetFloatAvailableSpaceWithState(aLineTop,
27106:                                            &aState.mFloatManagerStateBefore)
27106:           .mRect;
27100:   // FIXME (bug 25888): need to check the entire region that the first
27100:   // line overlaps, not just the top pixel.
27100: 
27100:   // Place the bullet now.  We want to place the bullet relative to the
27100:   // border-box of the associated block (using the right/left margin of
27100:   // the bullet frame as separation).  However, if a line box would be
27100:   // displaced by floats that are *outside* the associated block, we
27100:   // want to displace it by the same amount.  That is, we act as though
27100:   // the edge of the floats is the content-edge of the block, and place
27100:   // the bullet at a position offset from there by the block's padding,
27100:   // the block's border, and the bullet frame's margin.
27100:   nscoord x;
27100:   if (rs.mStyleVisibility->mDirection == NS_STYLE_DIRECTION_LTR) {
49569:     // The floatAvailSpace.x gives us the content/float edge. Then we
49569:     // subtract out the left border/padding and the bullet's width and
49569:     // margin to offset the position.
49569:     x = floatAvailSpace.x - rs.mComputedBorderPadding.left
49569:         - reflowState.mComputedMargin.right - aMetrics.width;
27100:   } else {
49569:     // The XMost() of the available space give us offsets from the left
49569:     // border edge.  Then we add the right border/padding and the
49569:     // bullet's margin to offset the position.
49569:     x = floatAvailSpace.XMost() + rs.mComputedBorderPadding.right
11520:         + reflowState.mComputedMargin.left;
27100:   }
    1: 
    1:   // Approximate the bullets position; vertical alignment will provide
    1:   // the final vertical location.
49569:   nscoord y = aState.mContentArea.y;
    1:   mBullet->SetRect(nsRect(x, y, aMetrics.width, aMetrics.height));
    1:   mBullet->DidReflow(aState.mPresContext, &aState.mReflowState, NS_FRAME_REFLOW_FINISHED);
    1: }
    1: 
    1: // This is used to scan frames for any float placeholders, add their
32843: // floats to the list represented by aList, and remove the
    1: // floats from whatever list they might be in. We don't search descendants
    1: // that are float containing blocks. The floats must be children of 'this'.
32843: void nsBlockFrame::CollectFloats(nsIFrame* aFrame, nsFrameList& aList,
  686:                                  PRBool aFromOverflow, PRBool aCollectSiblings) {
    1:   while (aFrame) {
    1:     // Don't descend into float containing blocks.
    1:     if (!aFrame->IsFloatContainingBlock()) {
34911:       nsIFrame *outOfFlowFrame =
34911:         aFrame->GetType() == nsGkAtoms::placeholderFrame ?
34911:           nsLayoutUtils::GetFloatFromPlaceholder(aFrame) : nsnull;
    1:       if (outOfFlowFrame) {
49010:         if (outOfFlowFrame->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT) {
48989:           if (outOfFlowFrame->GetParent() == this) {
49010:             nsFrameList* list = GetPushedFloats();
48989:             if (!list || !list->RemoveFrameIfPresent(outOfFlowFrame)) {
50897:               if (aFromOverflow) {
50897:                 nsAutoOOFFrameList oofs(this);
50897:                 oofs.mList.RemoveFrame(outOfFlowFrame);
50897:               } else {
48989:                 mFloats.RemoveFrame(outOfFlowFrame);
48989:               }
50897:             }
48989:             aList.AppendFrame(nsnull, outOfFlowFrame);
48989:           }
50897:           // FIXME: By not pulling floats whose parent is one of our
50897:           // later siblings, are we risking the pushed floats getting
50897:           // out-of-order?
48989:         } else {
    1:           // Make sure that its parent is us. Otherwise we don't want
    1:           // to mess around with it because it belongs to someone
    1:           // else. I think this could happen if the overflow lines
    1:           // contain a block descendant which owns its own floats.
    1:           NS_ASSERTION(outOfFlowFrame->GetParent() == this,
    1:                        "Out of flow frame doesn't have the expected parent");
    1:           if (aFromOverflow) {
    1:             nsAutoOOFFrameList oofs(this);
    1:             oofs.mList.RemoveFrame(outOfFlowFrame);
    1:           } else {
    1:             mFloats.RemoveFrame(outOfFlowFrame);
    1:           }
32843:           aList.AppendFrame(nsnull, outOfFlowFrame);
    1:         }
48989:       }
    1: 
 6261:       CollectFloats(aFrame->GetFirstChild(nsnull), 
32843:                     aList, aFromOverflow, PR_TRUE);
 6261:       // Note: Even though we're calling CollectFloats on aFrame's overflow
 6261:       // list, we'll pass down aFromOverflow unchanged because we're still
 6262:       // traversing the regular-children subtree of the 'this' frame.
 6261:       CollectFloats(aFrame->GetFirstChild(nsGkAtoms::overflowList), 
32843:                     aList, aFromOverflow, PR_TRUE);
  686:     }
  686:     if (!aCollectSiblings)
  686:       break;
    1:     aFrame = aFrame->GetNextSibling();
    1:   }
    1: }
    1: 
    1: void
    1: nsBlockFrame::CheckFloats(nsBlockReflowState& aState)
    1: {
    1: #ifdef DEBUG
 8457:   // If any line is still dirty, that must mean we're going to reflow this
 8457:   // block again soon (e.g. because we bailed out after noticing that
 8457:   // clearance was imposed), so don't worry if the floats are out of sync.
 8457:   PRBool anyLineDirty = PR_FALSE;
 8457: 
    1:   // Check that the float list is what we would have built
24551:   nsAutoTArray<nsIFrame*, 8> lineFloats;
    1:   for (line_iterator line = begin_lines(), line_end = end_lines();
    1:        line != line_end; ++line) {
    1:     if (line->HasFloats()) {
    1:       nsFloatCache* fc = line->GetFirstFloat();
    1:       while (fc) {
32107:         lineFloats.AppendElement(fc->mFloat);
    1:         fc = fc->Next();
    1:       }
    1:     }
 8457:     if (line->IsDirty()) {
 8457:       anyLineDirty = PR_TRUE;
 8457:     }
    1:   }
    1:   
24551:   nsAutoTArray<nsIFrame*, 8> storedFloats;
    1:   PRBool equal = PR_TRUE;
24551:   PRUint32 i = 0;
    1:   for (nsIFrame* f = mFloats.FirstChild(); f; f = f->GetNextSibling()) {
49010:     if (f->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT)
32108:       continue;
    1:     storedFloats.AppendElement(f);
24551:     if (i < lineFloats.Length() && lineFloats.ElementAt(i) != f) {
    1:       equal = PR_FALSE;
    1:     }
    1:     ++i;
    1:   }
    1: 
24551:   if ((!equal || lineFloats.Length() != storedFloats.Length()) && !anyLineDirty) {
    1:     NS_WARNING("nsBlockFrame::CheckFloats: Explicit float list is out of sync with float cache");
    1: #if defined(DEBUG_roc)
31709:     nsFrame::RootFrameList(PresContext(), stdout, 0);
24551:     for (i = 0; i < lineFloats.Length(); ++i) {
    1:       printf("Line float: %p\n", lineFloats.ElementAt(i));
    1:     }
24551:     for (i = 0; i < storedFloats.Length(); ++i) {
    1:       printf("Stored float: %p\n", storedFloats.ElementAt(i));
    1:     }
    1: #endif
    1:   }
    1: #endif
    1: 
33010:   const nsFrameList* oofs = GetOverflowOutOfFlows();
33010:   if (oofs && oofs->NotEmpty()) {
23305:     // Floats that were pushed should be removed from our float
23305:     // manager.  Otherwise the float manager's YMost or XMost might
    1:     // be larger than necessary, causing this block to get an
    1:     // incorrect desired height (or width).  Some of these floats
23305:     // may not actually have been added to the float manager because
    1:     // they weren't reflowed before being pushed; that's OK,
    1:     // RemoveRegions will ignore them. It is safe to do this here
23305:     // because we know from here on the float manager will only be
    1:     // used for its XMost and YMost, not to place new floats and
    1:     // lines.
33010:     aState.mFloatManager->RemoveTrailingRegions(oofs->FirstChild());
    1:   }
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: nsBlockFrame::BlockIsMarginRoot(nsIFrame* aBlock)
    1: {
    1:   NS_PRECONDITION(aBlock, "Must have a frame");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlock), "aBlock must be a block");
    1: 
    1:   nsIFrame* parent = aBlock->GetParent();
    1:   return (aBlock->GetStateBits() & NS_BLOCK_MARGIN_ROOT) ||
    1:     (parent && !parent->IsFloatContainingBlock() &&
    1:      parent->GetType() != nsGkAtoms::columnSetFrame);
    1: }
    1: 
    1: /* static */
    1: PRBool
23305: nsBlockFrame::BlockNeedsFloatManager(nsIFrame* aBlock)
    1: {
    1:   NS_PRECONDITION(aBlock, "Must have a frame");
15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlock), "aBlock must be a block");
    1: 
    1:   nsIFrame* parent = aBlock->GetParent();
23305:   return (aBlock->GetStateBits() & NS_BLOCK_FLOAT_MGR) ||
    1:     (parent && !parent->IsFloatContainingBlock());
    1: }
    1: 
 7046: /* static */
10895: PRBool
10895: nsBlockFrame::BlockCanIntersectFloats(nsIFrame* aFrame)
10895: {
10895:   return aFrame->IsFrameOfType(nsIFrame::eBlockFrame) &&
10895:          !aFrame->IsFrameOfType(nsIFrame::eReplaced) &&
23305:          !(aFrame->GetStateBits() & NS_BLOCK_FLOAT_MGR);
10895: }
10895: 
14324: // Note that this width can vary based on the vertical position.
14324: // However, the cases where it varies are the cases where the width fits
14324: // in the available space given, which means that variation shouldn't
14324: // matter.
14324: /* static */
14324: nsBlockFrame::ReplacedElementWidthToClear
14324: nsBlockFrame::WidthToClearPastFloats(nsBlockReflowState& aState,
27103:                                      const nsRect& aFloatAvailableSpace,
10895:                                      nsIFrame* aFrame)
10895: {
14324:   nscoord leftOffset, rightOffset;
14324:   nsCSSOffsetState offsetState(aFrame, aState.mReflowState.rendContext,
14324:                                aState.mContentArea.width);
14324: 
14324:   ReplacedElementWidthToClear result;
14324:   // A table outer frame is an exception in that it is a block child
14324:   // that is not a containing block for its children.
14324:   if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
14324:     nsIFrame *innerTable = aFrame->GetFirstChild(nsnull);
14324:     nsIFrame *caption = aFrame->GetFirstChild(nsGkAtoms::captionList);
14324: 
14324:     nsMargin tableMargin, captionMargin;
14324:     {
14324:       nsCSSOffsetState tableOS(innerTable, aState.mReflowState.rendContext,
14324:                                aState.mContentArea.width);
14324:       tableMargin = tableOS.mComputedMargin;
14324:     }
14324: 
14324:     if (caption) {
14324:       nsCSSOffsetState captionOS(caption, aState.mReflowState.rendContext,
14324:                                  aState.mContentArea.width);
14324:       captionMargin = captionOS.mComputedMargin;
14324:     }
14324: 
14324:     PRUint8 captionSide;
14324:     if (!caption ||
14324:         ((captionSide = caption->GetStyleTableBorder()->mCaptionSide)
14324:            == NS_STYLE_CAPTION_SIDE_TOP ||
14324:          captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM)) {
14324:       result.marginLeft = tableMargin.left;
14324:       result.marginRight = tableMargin.right;
14324:     } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
14324:                captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE) {
14324:       // FIXME:  This doesn't treat the caption and table independently,
14324:       // since we adjust by only the smaller margin, and the table outer
14324:       // frame doesn't know about it.
32531:       result.marginLeft  = NS_MIN(tableMargin.left,  captionMargin.left);
32531:       result.marginRight = NS_MIN(tableMargin.right, captionMargin.right);
14324:     } else {
14324:       NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
14324:                    captionSide == NS_STYLE_CAPTION_SIDE_RIGHT,
14324:                    "unexpected caption-side");
14324:       if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT) {
14324:         result.marginLeft = captionMargin.left;
14324:         result.marginRight = tableMargin.right;
14324:       } else {
14324:         result.marginLeft = tableMargin.left;
14324:         result.marginRight = captionMargin.right;
14324:       }
14324:     }
14324: 
27103:     aState.ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace,
27103:                                                 leftOffset, rightOffset,
14324:                                                 &result);
14324: 
14841:     // result.marginLeft has already been subtracted from leftOffset (etc.)
14841:     nscoord availWidth = aState.mContentArea.width - leftOffset - rightOffset;
14324:     // Force the outer frame to shrink-wrap (otherwise it just sizes to
14324:     // the available width unconditionally).
14324:     result.borderBoxWidth =
14324:       aFrame->ComputeSize(aState.mReflowState.rendContext,
14324:                           nsSize(aState.mContentArea.width,
14324:                                  NS_UNCONSTRAINEDSIZE),
14324:                           availWidth,
14324:                           nsSize(offsetState.mComputedMargin.LeftRight(),
14324:                                  offsetState.mComputedMargin.TopBottom()),
14324:                           nsSize(offsetState.mComputedBorderPadding.LeftRight() -
14324:                                    offsetState.mComputedPadding.LeftRight(),
14324:                                  offsetState.mComputedBorderPadding.TopBottom() -
14324:                                    offsetState.mComputedPadding.TopBottom()),
14324:                           nsSize(offsetState.mComputedPadding.LeftRight(),
14324:                                  offsetState.mComputedPadding.TopBottom()),
14324:                           PR_TRUE).width +
14324:       offsetState.mComputedBorderPadding.LeftRight() -
14324:       (result.marginLeft + result.marginRight);
14324:   } else {
27103:     aState.ComputeReplacedBlockOffsetsForFloats(aFrame, aFloatAvailableSpace,
27103:                                                 leftOffset, rightOffset);
14324:     nscoord availWidth = aState.mContentArea.width - leftOffset - rightOffset;
14324: 
14324:     // We actually don't want the min width here; see bug 427782; we only
14324:     // want to displace if the width won't compute to a value small enough
14324:     // to fit.
10895:     // All we really need here is the result of ComputeSize, and we
10895:     // could *almost* get that from an nsCSSOffsetState, except for the
10895:     // last argument.
14324:     nsSize availSpace(availWidth, NS_UNCONSTRAINEDSIZE);
14324:     nsHTMLReflowState reflowState(aState.mPresContext, aState.mReflowState,
10895:                                   aFrame, availSpace);
14324:     result.borderBoxWidth = reflowState.ComputedWidth() +
14324:                             reflowState.mComputedBorderPadding.LeftRight();
14324:     // Use the margins from offsetState rather than reflowState so that
14324:     // they aren't reduced by ignoring margins in overconstrained cases.
14324:     result.marginLeft  = offsetState.mComputedMargin.left;
14324:     result.marginRight = offsetState.mComputedMargin.right;
10895:   }
10895:   return result;
10895: }
10895:  
10895: /* static */
 7046: nsBlockFrame*
 7046: nsBlockFrame::GetNearestAncestorBlock(nsIFrame* aCandidate)
 7046: {
 7046:   nsBlockFrame* block = nsnull;
 7046:   while(aCandidate) {
15909:     block = nsLayoutUtils::GetAsBlock(aCandidate);
 7046:     if (block) { 
 7046:       // yay, candidate is a block!
 7046:       return block;
 7046:     }
 7046:     // Not a block. Check its parent next.
 7046:     aCandidate = aCandidate->GetParent();
 7046:   }
 7046:   NS_NOTREACHED("Fell off frame tree looking for ancestor block!");
 7046:   return nsnull;
 7046: }
 7046: 
    1: #ifdef IBMBIDI
 1920: nsresult
 1920: nsBlockFrame::ResolveBidi()
 1920: {
 5590:   NS_ASSERTION(!GetPrevInFlow(),
 5590:                "ResolveBidi called on non-first continuation");
 5590: 
 1920:   nsPresContext* presContext = PresContext();
 1920:   if (!presContext->BidiEnabled()) {
 1920:     return NS_OK;
 1920:   }
 1920: 
 1920:   nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
 1920:   if (!bidiUtils)
 5590:     return NS_ERROR_NULL_POINTER;
 5590: 
41312:   return bidiUtils->Resolve(this);
    1: }
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsBlockFrame::VerifyLines(PRBool aFinalCheckOK)
    1: {
    1:   if (!gVerifyLines) {
    1:     return;
    1:   }
    1:   if (mLines.empty()) {
    1:     return;
    1:   }
    1: 
    1:   // Add up the counts on each line. Also validate that IsFirstLine is
    1:   // set properly.
    1:   PRInt32 count = 0;
    1:   PRBool seenBlock = PR_FALSE;
    1:   line_iterator line, line_end;
    1:   for (line = begin_lines(), line_end = end_lines();
    1:        line != line_end;
    1:        ++line) {
    1:     if (aFinalCheckOK) {
    1:       NS_ABORT_IF_FALSE(line->GetChildCount(), "empty line");
    1:       if (line->IsBlock()) {
    1:         seenBlock = PR_TRUE;
    1:       }
    1:       if (line->IsBlock()) {
    1:         NS_ASSERTION(1 == line->GetChildCount(), "bad first line");
    1:       }
    1:     }
    1:     count += line->GetChildCount();
    1:   }
    1: 
    1:   // Then count the frames
    1:   PRInt32 frameCount = 0;
    1:   nsIFrame* frame = mLines.front()->mFirstChild;
    1:   while (frame) {
    1:     frameCount++;
    1:     frame = frame->GetNextSibling();
    1:   }
    1:   NS_ASSERTION(count == frameCount, "bad line list");
    1: 
    1:   // Next: test that each line has right number of frames on it
    1:   for (line = begin_lines(), line_end = end_lines();
    1:        line != line_end;
    1:         ) {
    1:     count = line->GetChildCount();
    1:     frame = line->mFirstChild;
    1:     while (--count >= 0) {
    1:       frame = frame->GetNextSibling();
    1:     }
    1:     ++line;
    1:     if ((line != line_end) && (0 != line->GetChildCount())) {
    1:       NS_ASSERTION(frame == line->mFirstChild, "bad line list");
    1:     }
    1:   }
    1: }
    1: 
    1: // Its possible that a frame can have some frames on an overflow
    1: // list. But its never possible for multiple frames to have overflow
    1: // lists. Check that this fact is actually true.
    1: void
    1: nsBlockFrame::VerifyOverflowSituation()
    1: {
    1:   nsBlockFrame* flow = (nsBlockFrame*) GetFirstInFlow();
    1:   while (nsnull != flow) {
    1:     nsLineList* overflowLines = GetOverflowLines();
    1:     if (nsnull != overflowLines) {
    1:       NS_ASSERTION(! overflowLines->empty(), "should not be empty if present");
    1:       NS_ASSERTION(overflowLines->front()->mFirstChild, "bad overflow list");
    1:     }
    1:     flow = (nsBlockFrame*) flow->GetNextInFlow();
    1:   }
    1: }
    1: 
    1: PRInt32
    1: nsBlockFrame::GetDepth() const
    1: {
    1:   PRInt32 depth = 0;
    1:   nsIFrame* parent = mParent;
    1:   while (parent) {
    1:     parent = parent->GetParent();
    1:     depth++;
    1:   }
    1:   return depth;
    1: }
    1: #endif
