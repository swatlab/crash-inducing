23697: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
23697: /* ***** BEGIN LICENSE BLOCK *****
23697:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23697:  *
23697:  * The contents of this file are subject to the Mozilla Public License Version
23697:  * 1.1 (the "License"); you may not use this file except in compliance with
23697:  * the License. You may obtain a copy of the License at
23697:  * http://www.mozilla.org/MPL/
23697:  *
23697:  * Software distributed under the License is distributed on an "AS IS" basis,
23697:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23697:  * for the specific language governing rights and limitations under the
23697:  * License.
23697:  *
23697:  * The Original Code is the Mozilla SMIL module.
23697:  *
23697:  * The Initial Developer of the Original Code is Brian Birtles.
23697:  * Portions created by the Initial Developer are Copyright (C) 2008
23697:  * the Initial Developer. All Rights Reserved.
23697:  *
23697:  * Contributor(s):
23697:  *   Brian Birtles <birtles@gmail.com>
23697:  *   Daniel Holbert <dholbert@mozilla.com>
23697:  *
23697:  * Alternatively, the contents of this file may be used under the terms of
23697:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23697:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23697:  * in which case the provisions of the GPL or the LGPL are applicable instead
23697:  * of those above. If you wish to allow use of your version of this file only
23697:  * under the terms of either the GPL or the LGPL, and not to allow others to
23697:  * use your version of this file under the terms of the MPL, indicate your
23697:  * decision by deleting the provisions above and replace them with the notice
23697:  * and other provisions required by the GPL or the LGPL. If you do not delete
23697:  * the provisions above, a recipient may use your version of this file under
23697:  * the terms of any one of the MPL, the GPL or the LGPL.
23697:  *
23697:  * ***** END LICENSE BLOCK ***** */
23697: 
23697: #ifndef NS_SMILANIMATIONCONTROLLER_H_
23697: #define NS_SMILANIMATIONCONTROLLER_H_
23697: 
23697: #include "nsAutoPtr.h"
23697: #include "nsCOMPtr.h"
23697: #include "nsTArray.h"
23697: #include "nsITimer.h"
23697: #include "nsTHashtable.h"
23697: #include "nsHashKeys.h"
23697: #include "nsSMILTimeContainer.h"
23697: #include "nsSMILCompositorTable.h"
37113: #include "nsSMILMilestone.h"
39626: #include "nsRefreshDriver.h"
23697: 
38346: struct nsSMILTargetIdentifier;
23697: class nsISMILAnimationElement;
23697: class nsIDocument;
23697: 
23697: //----------------------------------------------------------------------
23697: // nsSMILAnimationController
23697: //
23697: // The animation controller maintains the animation timer and determines the
23697: // sample times and sample rate for all SMIL animations in a document. There is
23697: // at most one animation controller per nsDocument so that frame-rate tuning can
23697: // be performed at a document-level.
23697: //
23697: // The animation controller can contain many child time containers (timed
23697: // document root objects) which may correspond to SVG document fragments within
23697: // a compound document. These time containers can be paused individually or
23697: // here, at the document level.
23697: //
39626: class nsSMILAnimationController : public nsSMILTimeContainer,
39626:                                   public nsARefreshObserver
23697: {
23697: public:
69077:   nsSMILAnimationController(nsIDocument* aDoc);
23697:   ~nsSMILAnimationController();
23697: 
69078:   // Clears mDocument pointer. (Called by our nsIDocument when it's going away)
69078:   void Disconnect();
69078: 
23697:   // nsSMILContainer
23697:   virtual void Pause(PRUint32 aType);
23697:   virtual void Resume(PRUint32 aType);
23697:   virtual nsSMILTime GetParentTime() const;
23697: 
39626:   // nsARefreshObserver
39626:   NS_IMETHOD_(nsrefcnt) AddRef();
39626:   NS_IMETHOD_(nsrefcnt) Release();
39626: 
39626:   virtual void WillRefresh(mozilla::TimeStamp aTime);
39626: 
23697:   // Methods for registering and enumerating animation elements
23697:   void RegisterAnimationElement(nsISMILAnimationElement* aAnimationElement);
23697:   void UnregisterAnimationElement(nsISMILAnimationElement* aAnimationElement);
23697: 
24029:   // Methods for resampling all animations
24029:   // (A resample performs the same operations as a sample but doesn't advance
24029:   // the current time and doesn't check if the container is paused)
92400:   // This will flush pending style changes for the document.
80486:   void Resample() { DoSample(false); }
84597: 
57170:   void SetResampleNeeded()
57170:   {
57170:     if (!mRunningSample) {
84597:       if (!mResampleNeeded) {
84597:         FlagDocumentNeedsFlush();
84597:       }
80486:       mResampleNeeded = true;
57170:     }
57170:   }
92400: 
92400:   // This will flush pending style changes for the document.
24029:   void FlushResampleRequests()
24029:   {
24029:     if (!mResampleNeeded)
24029:       return;
24029: 
37113:     Resample();
24029:   }
23697: 
23697:   // Methods for handling page transitions
23697:   void OnPageShow();
23697:   void OnPageHide();
23697: 
23697:   // Methods for supporting cycle-collection
23697:   void Traverse(nsCycleCollectionTraversalCallback* aCallback);
23697:   void Unlink();
23697: 
56137:   // Methods for relaying the availability of the refresh driver
56137:   void NotifyRefreshDriverCreated(nsRefreshDriver* aRefreshDriver);
56137:   void NotifyRefreshDriverDestroying(nsRefreshDriver* aRefreshDriver);
39626: 
52211:   // Helper to check if we have any animation elements at all
79445:   bool HasRegisteredAnimations()
52211:   { return mAnimationElementTable.Count() != 0; }
52211: 
23697: protected:
23697:   // Typedefs
23697:   typedef nsPtrHashKey<nsSMILTimeContainer> TimeContainerPtrKey;
23697:   typedef nsTHashtable<TimeContainerPtrKey> TimeContainerHashtable;
23697:   typedef nsPtrHashKey<nsISMILAnimationElement> AnimationElementPtrKey;
23697:   typedef nsTHashtable<AnimationElementPtrKey> AnimationElementHashtable;
23697: 
24029:   struct SampleTimeContainerParams
24029:   {
24029:     TimeContainerHashtable* mActiveContainers;
79445:     bool                    mSkipUnchangedContainers;
23697:   };
23697: 
23697:   struct SampleAnimationParams
23697:   {
23697:     TimeContainerHashtable* mActiveContainers;
23697:     nsSMILCompositorTable*  mCompositorTable;
23697:   };
23697: 
37113:   struct GetMilestoneElementsParams
37113:   {
37113:     nsTArray<nsRefPtr<nsISMILAnimationElement> > mElements;
37113:     nsSMILMilestone                              mMilestone;
37113:   };
37113: 
23697:   // Cycle-collection implementation helpers
23697:   PR_STATIC_CALLBACK(PLDHashOperator) CompositorTableEntryTraverse(
23697:       nsSMILCompositor* aCompositor, void* aArg);
23697: 
69079:   // Returns mDocument's refresh driver, if it's got one.
69079:   nsRefreshDriver* GetRefreshDriver();
69079: 
56137:   // Methods for controlling whether we're sampling
56137:   void StartSampling(nsRefreshDriver* aRefreshDriver);
56137:   void StopSampling(nsRefreshDriver* aRefreshDriver);
56137: 
64632:   // Wrapper for StartSampling that defers if no animations are registered.
64632:   void MaybeStartSampling(nsRefreshDriver* aRefreshDriver);
64632: 
23697:   // Sample-related callbacks and implementation helpers
23697:   virtual void DoSample();
79445:   void DoSample(bool aSkipUnchangedContainers);
47197: 
47197:   void RewindElements();
47197:   PR_STATIC_CALLBACK(PLDHashOperator) RewindNeeded(
47197:       TimeContainerPtrKey* aKey, void* aData);
47197:   PR_STATIC_CALLBACK(PLDHashOperator) RewindAnimation(
47197:       AnimationElementPtrKey* aKey, void* aData);
47197:   PR_STATIC_CALLBACK(PLDHashOperator) ClearRewindNeeded(
47197:       TimeContainerPtrKey* aKey, void* aData);
47197: 
37113:   void DoMilestoneSamples();
37113:   PR_STATIC_CALLBACK(PLDHashOperator) GetNextMilestone(
37113:       TimeContainerPtrKey* aKey, void* aData);
37113:   PR_STATIC_CALLBACK(PLDHashOperator) GetMilestoneElements(
37113:       TimeContainerPtrKey* aKey, void* aData);
47197: 
24029:   PR_STATIC_CALLBACK(PLDHashOperator) SampleTimeContainer(
23697:       TimeContainerPtrKey* aKey, void* aData);
23697:   PR_STATIC_CALLBACK(PLDHashOperator) SampleAnimation(
23697:       AnimationElementPtrKey* aKey, void* aData);
23697:   static void SampleTimedElement(nsISMILAnimationElement* aElement,
23697:                                  TimeContainerHashtable* aActiveContainers);
23697:   static void AddAnimationToCompositorTable(
23697:     nsISMILAnimationElement* aElement, nsSMILCompositorTable* aCompositorTable);
79445:   static bool GetTargetIdentifierForAnimation(
38346:       nsISMILAnimationElement* aAnimElem, nsSMILTargetIdentifier& aResult);
23697: 
23697:   // Methods for adding/removing time containers
23697:   virtual nsresult AddChild(nsSMILTimeContainer& aChild);
23697:   virtual void     RemoveChild(nsSMILTimeContainer& aChild);
23697: 
84597:   void FlagDocumentNeedsFlush();
84597: 
23697:   // Members
39626:   nsAutoRefCnt mRefCnt;
39626:   NS_DECL_OWNINGTHREAD
39626: 
23697:   AnimationElementHashtable  mAnimationElementTable;
23697:   TimeContainerHashtable     mChildContainerTable;
54303:   mozilla::TimeStamp         mCurrentSampleTime;
54303:   mozilla::TimeStamp         mStartTime;
58112: 
58112:   // Average time between samples from the refresh driver. This is used to
58112:   // detect large unexpected gaps between samples such as can occur when the
58112:   // computer sleeps. The nature of the SMIL model means that catching up these
58112:   // large gaps can be expensive as, for example, many events may need to be
58112:   // dispatched for the intervening time when no samples were received.
58112:   //
58112:   // In such cases, we ignore the intervening gap and continue sampling from
58112:   // when we were expecting the next sample to arrive.
58112:   //
58112:   // Note that we only do this for SMIL and not CSS transitions (which doesn't
58112:   // have so much work to do to catch up) nor scripted animations (which expect
58112:   // animation time to follow real time).
58112:   //
58112:   // This behaviour does not affect pausing (since we're not *expecting* any
58112:   // samples then) nor seeking (where the SMIL model behaves somewhat
58112:   // differently such as not dispatching events).
58112:   nsSMILTime                 mAvgTimeBetweenSamples;
58112: 
79445:   bool                       mResampleNeeded;
56136:   // If we're told to start sampling but there are no animation elements we just
56136:   // record the time, set the following flag, and then wait until we have an
56136:   // animation element. Then we'll reset this flag and actually start sampling.
79445:   bool                       mDeferredStartSampling;
79445:   bool                       mRunningSample;
23697: 
23697:   // Store raw ptr to mDocument.  It owns the controller, so controller
23697:   // shouldn't outlive it
23697:   nsIDocument* mDocument;
23697: 
23697:   // Contains compositors used in our last sample.  We keep this around
23697:   // so we can detect when an element/attribute used to be animated,
23697:   // but isn't anymore for some reason. (e.g. if its <animate> element is
23697:   // removed or retargeted)
23697:   nsAutoPtr<nsSMILCompositorTable> mLastCompositorTable;
23697: };
23697: 
23697: #endif // NS_SMILANIMATIONCONTROLLER_H_
