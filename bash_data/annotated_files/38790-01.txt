    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsBaseDragService.h"
    1: #include "nsITransferable.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsITransferable.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsSize.h"
    1: #include "nsIRegion.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIFrame.h"
    1: #include "nsIDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIDOMNode.h"
18445: #include "nsIDOMDragEvent.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsPresContext.h"
18445: #include "nsIDOMDataTransfer.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsICanvasElement.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "imgIContainer.h"
    1: #include "imgIRequest.h"
    1: #include "nsIViewObserver.h"
    1: #include "nsRegion.h"
  482: #include "nsGUIEvent.h"
 1528: #include "nsIPrefService.h"
    1: 
    1: #include "gfxContext.h"
27618: #include "gfxPlatform.h"
    1: 
 1528: #define DRAGIMAGES_PREF "nglayout.enable_drag_images"
 1528: 
    1: nsBaseDragService::nsBaseDragService()
34272:   : mCanDrop(PR_FALSE), mOnlyChromeDrop(PR_FALSE), mDoingDrag(PR_FALSE),
34272:     mHasImage(PR_FALSE), mUserCancelled(PR_FALSE),
    1:     mDragAction(DRAGDROP_ACTION_NONE), mTargetSize(0,0),
13279:     mImageX(0), mImageY(0), mScreenX(-1), mScreenY(-1), mSuppressLevel(0)
    1: {
    1: }
    1: 
    1: nsBaseDragService::~nsBaseDragService()
    1: {
    1: }
    1: 
 4345: NS_IMPL_ISUPPORTS2(nsBaseDragService, nsIDragService, nsIDragSession)
    1: 
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::SetCanDrop(PRBool aCanDrop)
    1: {
    1:   mCanDrop = aCanDrop;
    1:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetCanDrop(PRBool * aCanDrop)
    1: {
    1:   *aCanDrop = mCanDrop;
    1:   return NS_OK;
    1: }
34272: //---------------------------------------------------------
34272: NS_IMETHODIMP
34272: nsBaseDragService::SetOnlyChromeDrop(PRBool aOnlyChrome)
34272: {
34272:   mOnlyChromeDrop = aOnlyChrome;
34272:   return NS_OK;
34272: }
34272: 
34272: //---------------------------------------------------------
34272: NS_IMETHODIMP
34272: nsBaseDragService::GetOnlyChromeDrop(PRBool* aOnlyChrome)
34272: {
34272:   *aOnlyChrome = mOnlyChromeDrop;
34272:   return NS_OK;
34272: }
    1: 
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::SetDragAction(PRUint32 anAction)
    1: {
    1:   mDragAction = anAction;
    1:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetDragAction(PRUint32 * anAction)
    1: {
    1:   *anAction = mDragAction;
    1:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::SetTargetSize(nsSize aDragTargetSize)
    1: {
    1:   mTargetSize = aDragTargetSize;
    1:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetTargetSize(nsSize * aDragTargetSize)
    1: {
    1:   *aDragTargetSize = mTargetSize;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetNumDropItems(PRUint32 * aNumItems)
    1: {
    1:   *aNumItems = 0;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: //
    1: // GetSourceDocument
    1: //
    1: // Returns the DOM document where the drag was initiated. This will be
    1: // nsnull if the drag began outside of our application.
    1: //
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetSourceDocument(nsIDOMDocument** aSourceDocument)
    1: {
    1:   *aSourceDocument = mSourceDocument.get();
    1:   NS_IF_ADDREF(*aSourceDocument);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //
    1: // GetSourceNode
    1: //
    1: // Returns the DOM node where the drag was initiated. This will be
    1: // nsnull if the drag began outside of our application.
    1: //
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetSourceNode(nsIDOMNode** aSourceNode)
    1: {
    1:   *aSourceNode = mSourceNode.get();
    1:   NS_IF_ADDREF(*aSourceNode);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetData(nsITransferable * aTransferable,
    1:                            PRUint32 aItemIndex)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::IsDataFlavorSupported(const char *aDataFlavor,
    1:                                          PRBool *_retval)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
18445: NS_IMETHODIMP
18445: nsBaseDragService::GetDataTransfer(nsIDOMDataTransfer** aDataTransfer)
18445: {
18445:   *aDataTransfer = mDataTransfer;
18445:   NS_IF_ADDREF(*aDataTransfer);
18445:   return NS_OK;
18445: }
18445: 
18445: NS_IMETHODIMP
18445: nsBaseDragService::SetDataTransfer(nsIDOMDataTransfer* aDataTransfer)
18445: {
18445:   mDataTransfer = aDataTransfer;
18445:   return NS_OK;
18445: }
18445: 
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::InvokeDragSession(nsIDOMNode *aDOMNode,
    1:                                      nsISupportsArray* aTransferableArray,
    1:                                      nsIScriptableRegion* aDragRgn,
    1:                                      PRUint32 aActionType)
    1: {
    1:   NS_ENSURE_TRUE(aDOMNode, NS_ERROR_INVALID_ARG);
13279:   NS_ENSURE_TRUE(mSuppressLevel == 0, NS_ERROR_FAILURE);
    1: 
    1:   // stash the document of the dom node
    1:   aDOMNode->GetOwnerDocument(getter_AddRefs(mSourceDocument));
    1:   mSourceNode = aDOMNode;
27401:   mEndDragPoint = nsIntPoint(0, 0);
    1: 
    1:   // When the mouse goes down, the selection code starts a mouse
    1:   // capture. However, this gets in the way of determining drag
    1:   // feedback for things like trees because the event coordinates
32435:   // are in the wrong coord system, so turn off mouse capture.
32435:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(mSourceDocument);
    1:   if (doc) {
32435:     nsCOMPtr<nsIViewObserver> viewObserver = do_QueryInterface(doc->GetPrimaryShell());
32435:     if (viewObserver) {
32435:       viewObserver->ClearMouseCapture(nsnull);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBaseDragService::InvokeDragSessionWithImage(nsIDOMNode* aDOMNode,
    1:                                               nsISupportsArray* aTransferableArray,
    1:                                               nsIScriptableRegion* aRegion,
    1:                                               PRUint32 aActionType,
    1:                                               nsIDOMNode* aImage,
    1:                                               PRInt32 aImageX, PRInt32 aImageY,
18445:                                               nsIDOMDragEvent* aDragEvent,
18445:                                               nsIDOMDataTransfer* aDataTransfer)
    1: {
    1:   NS_ENSURE_TRUE(aDragEvent, NS_ERROR_NULL_POINTER);
18445:   NS_ENSURE_TRUE(aDataTransfer, NS_ERROR_NULL_POINTER);
13279:   NS_ENSURE_TRUE(mSuppressLevel == 0, NS_ERROR_FAILURE);
    1: 
18445:   mDataTransfer = aDataTransfer;
    1:   mSelection = nsnull;
    1:   mHasImage = PR_TRUE;
    1:   mImage = aImage;
    1:   mImageX = aImageX;
    1:   mImageY = aImageY;
    1: 
    1:   aDragEvent->GetScreenX(&mScreenX);
    1:   aDragEvent->GetScreenY(&mScreenY);
    1: 
    1:   return InvokeDragSession(aDOMNode, aTransferableArray, aRegion, aActionType);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBaseDragService::InvokeDragSessionWithSelection(nsISelection* aSelection,
    1:                                                   nsISupportsArray* aTransferableArray,
    1:                                                   PRUint32 aActionType,
18445:                                                   nsIDOMDragEvent* aDragEvent,
18445:                                                   nsIDOMDataTransfer* aDataTransfer)
    1: {
    1:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   NS_ENSURE_TRUE(aDragEvent, NS_ERROR_NULL_POINTER);
13279:   NS_ENSURE_TRUE(mSuppressLevel == 0, NS_ERROR_FAILURE);
    1: 
18445:   mDataTransfer = aDataTransfer;
    1:   mSelection = aSelection;
    1:   mHasImage = PR_TRUE;
    1:   mImage = nsnull;
    1:   mImageX = 0;
    1:   mImageY = 0;
    1: 
    1:   aDragEvent->GetScreenX(&mScreenX);
    1:   aDragEvent->GetScreenY(&mScreenY);
    1: 
    1:   // just get the focused node from the selection
18445:   // XXXndeakin this should actually be the deepest node that contains both
18445:   // endpoints of the selection
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   aSelection->GetFocusNode(getter_AddRefs(node));
    1: 
    1:   return InvokeDragSession(node, aTransferableArray, nsnull, aActionType);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::GetCurrentSession(nsIDragSession ** aSession)
    1: {
    1:   if (!aSession)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   // "this" also implements a drag session, so say we are one but only
    1:   // if there is currently a drag going on.
13279:   if (!mSuppressLevel && mDoingDrag) {
    1:     *aSession = this;
    1:     NS_ADDREF(*aSession);      // addRef because we're a "getter"
    1:   }
    1:   else
    1:     *aSession = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsBaseDragService::StartDragSession()
    1: {
    1:   if (mDoingDrag) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   mDoingDrag = PR_TRUE;
34272:   // By default dispatch drop also to content.
34272:   mOnlyChromeDrop = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: NS_IMETHODIMP
  482: nsBaseDragService::EndDragSession(PRBool aDoneDrag)
    1: {
    1:   if (!mDoingDrag) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
13279:   if (aDoneDrag && !mSuppressLevel)
  482:     FireDragEventAtSource(NS_DRAGDROP_END);
  482: 
    1:   mDoingDrag = PR_FALSE;
    1: 
    1:   // release the source we've been holding on to.
    1:   mSourceDocument = nsnull;
    1:   mSourceNode = nsnull;
    1:   mSelection = nsnull;
18445:   mDataTransfer = nsnull;
    1:   mHasImage = PR_FALSE;
25064:   mUserCancelled = PR_FALSE;
    1:   mImage = nsnull;
    1:   mImageX = 0;
    1:   mImageY = 0;
    1:   mScreenX = -1;
    1:   mScreenY = -1;
    1: 
    1:   return NS_OK;
    1: }
    1: 
  482: NS_IMETHODIMP
  482: nsBaseDragService::FireDragEventAtSource(PRUint32 aMsg)
  482: {
13279:   if (mSourceNode && !mSuppressLevel) {
  482:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mSourceDocument);
  482:     if (doc) {
  981:       nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
  482:       if (presShell) {
  482:         nsEventStatus status = nsEventStatus_eIgnore;
18445:         nsDragEvent event(PR_TRUE, aMsg, nsnull);
27257:         if (aMsg == NS_DRAGDROP_END) {
27257:           event.refPoint.x = mEndDragPoint.x;
27257:           event.refPoint.y = mEndDragPoint.y;
27257:           event.userCancelled = mUserCancelled;
27257:         }
  482: 
  482:         nsCOMPtr<nsIContent> content = do_QueryInterface(mSourceNode);
  482:         return presShell->HandleDOMEventWithTarget(content, &event, &status);
  482:       }
  482:     }
  482:   }
  482: 
  482:   return NS_OK;
  482: }
  482: 
    1: static nsIPresShell*
    1: GetPresShellForContent(nsIDOMNode* aDOMNode)
    1: {
  201:   nsCOMPtr<nsIContent> content = do_QueryInterface(aDOMNode);
38790:   if (!content)
38790:     return nsnull;
38790: 
  201:   nsCOMPtr<nsIDocument> document = content->GetCurrentDoc();
    1:   if (document) {
    1:     document->FlushPendingNotifications(Flush_Display);
    1: 
  981:     return document->GetPrimaryShell();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsBaseDragService::DrawDrag(nsIDOMNode* aDOMNode,
    1:                             nsIScriptableRegion* aRegion,
    1:                             PRInt32 aScreenX, PRInt32 aScreenY,
23738:                             nsIntRect* aScreenDragRect,
10025:                             gfxASurface** aSurface,
10025:                             nsPresContext** aPresContext)
    1: {
    1:   *aSurface = nsnull;
10025:   *aPresContext = nsnull;
    1: 
    1:   // use a default size, in case of an error.
    1:   aScreenDragRect->x = aScreenX - mImageX;
    1:   aScreenDragRect->y = aScreenY - mImageY;
    1:   aScreenDragRect->width = 20;
    1:   aScreenDragRect->height = 20;
    1: 
    1:   // if a drag image was specified, use that, otherwise, use the source node
    1:   nsCOMPtr<nsIDOMNode> dragNode = mImage ? mImage.get() : aDOMNode;
    1: 
    1:   // get the presshell for the node being dragged. If the drag image is not in
    1:   // a document or has no frame, get the presshell from the source drag node
    1:   nsIPresShell* presShell = GetPresShellForContent(dragNode);
    1:   if (!presShell && mImage)
    1:     presShell = GetPresShellForContent(aDOMNode);
    1:   if (!presShell)
    1:     return NS_ERROR_FAILURE;
    1: 
10025:   *aPresContext = presShell->GetPresContext();
10025: 
 1528:   // check if drag images are disabled
 1528:   PRBool enableDragImages = PR_TRUE;
 1528:   nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
 1528:   if (prefs)
 1528:     prefs->GetBoolPref(DRAGIMAGES_PREF, &enableDragImages);
 1528: 
    1:   // didn't want an image, so just set the screen rectangle to the frame size
 1528:   if (!enableDragImages || !mHasImage) {
    1:     // if a region was specified, set the screen rectangle to the area that
    1:     // the region occupies
    1:     if (aRegion) {
    1:       // the region's coordinates are relative to the root frame
    1:       nsIFrame* rootFrame = presShell->GetRootFrame();
10025:       if (rootFrame && *aPresContext) {
23738:         nsIntRect dragRect;
    1:         aRegion->GetBoundingBox(&dragRect.x, &dragRect.y, &dragRect.width, &dragRect.height);
28113:         dragRect = dragRect.ToAppUnits(nsPresContext::AppUnitsPerCSSPixel()).
28113:                             ToOutsidePixels((*aPresContext)->AppUnitsPerDevPixel());
    1: 
    1:         nsIntRect screenRect = rootFrame->GetScreenRectExternal();
    1:         aScreenDragRect->SetRect(screenRect.x + dragRect.x, screenRect.y + dragRect.y,
    1:                                  dragRect.width, dragRect.height);
    1:       }
    1:     }
    1:     else {
    1:       // otherwise, there was no region so just set the rectangle to
    1:       // the size of the primary frame of the content.
    1:       nsCOMPtr<nsIContent> content = do_QueryInterface(dragNode);
36657:       nsIFrame* frame = content->GetPrimaryFrame();
    1:       if (frame) {
    1:         nsIntRect screenRect = frame->GetScreenRectExternal();
    1:         aScreenDragRect->SetRect(screenRect.x, screenRect.y,
    1:                                  screenRect.width, screenRect.height);
    1:       }
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // draw the image for selections
    1:   if (mSelection) {
23738:     nsIntPoint pnt(aScreenDragRect->x, aScreenDragRect->y);
    1:     nsRefPtr<gfxASurface> surface = presShell->RenderSelection(mSelection, pnt, aScreenDragRect);
    1:     *aSurface = surface;
    1:     NS_IF_ADDREF(*aSurface);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if an custom image was specified, check if it is an image node and draw
    1:   // using the source rather than the displayed image. But if mImage isn't
    1:   // an image, fall through to RenderNode below.
    1:   if (mImage) {
19113:     nsCOMPtr<nsICanvasElement> canvas = do_QueryInterface(dragNode);
19113:     if (canvas) {
19113:       return DrawDragForImage(*aPresContext, nsnull, canvas, aScreenX,
19113:                               aScreenY, aScreenDragRect, aSurface);
19113:     }
19113: 
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(dragNode);
    1:     // for image nodes, create the drag image from the actual image data
    1:     if (imageLoader) {
19113:       return DrawDragForImage(*aPresContext, imageLoader, nsnull, aScreenX,
19113:                               aScreenY, aScreenDragRect, aSurface);
    1:     }
    1:   }
    1: 
    1:   // otherwise, just draw the node
    1:   nsCOMPtr<nsIRegion> clipRegion;
    1:   if (aRegion)
    1:     aRegion->GetRegion(getter_AddRefs(clipRegion));
    1: 
23738:   nsIntPoint pnt(aScreenDragRect->x, aScreenDragRect->y);
    1:   nsRefPtr<gfxASurface> surface = presShell->RenderNode(dragNode, clipRegion,
    1:                                                         pnt, aScreenDragRect);
    1: 
    1:   // if an image was specified, reposition the drag rectangle to
    1:   // the supplied offset in mImageX and mImageY.
    1:   if (mImage) {
    1:     aScreenDragRect->x = aScreenX - mImageX;
    1:     aScreenDragRect->y = aScreenY - mImageY;
    1:   }
    1: 
    1:   *aSurface = surface;
    1:   NS_IF_ADDREF(*aSurface);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBaseDragService::DrawDragForImage(nsPresContext* aPresContext,
    1:                                     nsIImageLoadingContent* aImageLoader,
19113:                                     nsICanvasElement* aCanvas,
    1:                                     PRInt32 aScreenX, PRInt32 aScreenY,
23738:                                     nsIntRect* aScreenDragRect,
    1:                                     gfxASurface** aSurface)
    1: {
30479:   nsCOMPtr<imgIContainer> imgContainer;
19113:   if (aImageLoader) {
    1:     nsCOMPtr<imgIRequest> imgRequest;
    1:     nsresult rv = aImageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                                           getter_AddRefs(imgRequest));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (!imgRequest)
    1:       return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (!imgContainer)
    1:       return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // use the size of the image as the size of the drag image
    1:     imgContainer->GetWidth(&aScreenDragRect->width);
    1:     imgContainer->GetHeight(&aScreenDragRect->height);
19113:   }
19113:   else {
19113:     NS_ASSERTION(aCanvas, "both image and canvas are null");
19113:     PRUint32 width, height;
19113:     aCanvas->GetSize(&width, &height);
19113:     aScreenDragRect->width = width;
19113:     aScreenDragRect->height = height;
19113:   }
    1: 
23738:   nsIntSize srcSize = aScreenDragRect->Size();
23738:   nsIntSize destSize = srcSize;
    1: 
21323:   if (destSize.width == 0 || destSize.height == 0)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // if the image is larger than half the screen size, scale it down. This
    1:   // scaling algorithm is the same as is used in nsPresShell::PaintRangePaintInfo
    1:   nsIDeviceContext* deviceContext = aPresContext->DeviceContext();
    1:   nsRect maxSize;
    1:   deviceContext->GetClientRect(maxSize);
    1:   nscoord maxWidth = aPresContext->AppUnitsToDevPixels(maxSize.width >> 1);
    1:   nscoord maxHeight = aPresContext->AppUnitsToDevPixels(maxSize.height >> 1);
21323:   if (destSize.width > maxWidth || destSize.height > maxHeight) {
    1:     float scale = 1.0;
21323:     if (destSize.width > maxWidth)
21323:       scale = PR_MIN(scale, float(maxWidth) / destSize.width);
21323:     if (destSize.height > maxHeight)
21323:       scale = PR_MIN(scale, float(maxHeight) / destSize.height);
    1: 
21323:     destSize.width = NSToIntFloor(float(destSize.width) * scale);
21323:     destSize.height = NSToIntFloor(float(destSize.height) * scale);
    1: 
    1:     aScreenDragRect->x = NSToIntFloor(aScreenX - float(mImageX) * scale);
    1:     aScreenDragRect->y = NSToIntFloor(aScreenY - float(mImageY) * scale);
21323:     aScreenDragRect->width = destSize.width;
21323:     aScreenDragRect->height = destSize.height;
    1:   }
    1: 
27618:   nsRefPtr<gfxASurface> surface =
27618:     gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(destSize.width, destSize.height),
27618:                                                        gfxASurface::ImageFormatARGB32);
    1:   if (!surface)
    1:     return NS_ERROR_FAILURE;
    1: 
21323:   nsRefPtr<gfxContext> ctx = new gfxContext(surface);
21323:   if (!ctx)
21323:     return NS_ERROR_FAILURE;
21323: 
    1:   *aSurface = surface;
    1:   NS_ADDREF(*aSurface);
    1: 
19113:   if (aImageLoader) {
21323:     gfxRect outRect(0, 0, destSize.width, destSize.height);
21323:     gfxMatrix scale =
21323:       gfxMatrix().Scale(srcSize.width/outRect.Width(), srcSize.height/outRect.Height());
30479:     nsIntRect imgSize(0, 0, srcSize.width, srcSize.height);
32424:     imgContainer->Draw(ctx, gfxPattern::FILTER_GOOD, scale, outRect, imgSize,
32424:                        imgIContainer::FLAG_SYNC_DECODE);
21323:     return NS_OK;
21323:   } else {
29302:     return aCanvas->RenderContexts(ctx, gfxPattern::FILTER_GOOD);
19113:   }
19113: }
10025: 
10025: void
10025: nsBaseDragService::ConvertToUnscaledDevPixels(nsPresContext* aPresContext,
10025:                                               PRInt32* aScreenX, PRInt32* aScreenY)
10025: {
10025:   PRInt32 adj = aPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel();
10025:   *aScreenX = nsPresContext::CSSPixelsToAppUnits(*aScreenX) / adj;
10025:   *aScreenY = nsPresContext::CSSPixelsToAppUnits(*aScreenY) / adj;
10025: }
10025: 
13279: NS_IMETHODIMP
13279: nsBaseDragService::Suppress()
13279: {
13279:   EndDragSession(PR_FALSE);
13279:   ++mSuppressLevel;
13279:   return NS_OK;
13279: }
13279: 
13279: NS_IMETHODIMP
13279: nsBaseDragService::Unsuppress()
13279: {
13279:   --mSuppressLevel;
13279:   return NS_OK;
13279: }
