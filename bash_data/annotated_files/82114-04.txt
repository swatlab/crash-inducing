51110: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
51110:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
51110:  *
51110:  * ***** BEGIN LICENSE BLOCK *****
51110:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51110:  *
51110:  * The contents of this file are subject to the Mozilla Public License Version
51110:  * 1.1 (the "License"); you may not use this file except in compliance with
51110:  * the License. You may obtain a copy of the License at
51110:  * http://www.mozilla.org/MPL/
51110:  *
51110:  * Software distributed under the License is distributed on an "AS IS" basis,
51110:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51110:  * for the specific language governing rights and limitations under the
51110:  * License.
51110:  *
51110:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
51110:  * June 12, 2009.
51110:  *
51110:  * The Initial Developer of the Original Code is
51110:  *   the Mozilla Corporation.
51110:  *
51110:  * Contributor(s):
51110:  *   Dave Herman <dherman@mozilla.com>
51110:  *
51110:  * Alternatively, the contents of this file may be used under the terms of
51110:  * either of the GNU General Public License Version 2 or later (the "GPL"),
51110:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51110:  * in which case the provisions of the GPL or the LGPL are applicable instead
51110:  * of those above. If you wish to allow use of your version of this file only
51110:  * under the terms of either the GPL or the LGPL, and not to allow others to
51110:  * use your version of this file under the terms of the MPL, indicate your
51110:  * decision by deleting the provisions above and replace them with the notice
51110:  * and other provisions required by the GPL or the LGPL. If you do not delete
51110:  * the provisions above, a recipient may use your version of this file under
51110:  * the terms of any one of the MPL, the GPL or the LGPL.
51110:  *
51110:  * ***** END LICENSE BLOCK ***** */
51110: 
51110: /*
51110:  * JS reflection package.
51110:  */
51110: #include <stdlib.h>
80468: 
80468: #include "mozilla/Util.h"
80468: 
51110: #include "jspubtd.h"
51110: #include "jsatom.h"
51110: #include "jsobj.h"
51110: #include "jsreflect.h"
51110: #include "jsprf.h"
51110: #include "jsiter.h"
51110: #include "jsbool.h"
51110: #include "jsval.h"
77343: #include "jsinferinlines.h"
51110: #include "jsobjinlines.h"
56211: #include "jsobj.h"
51110: #include "jsarray.h"
51110: #include "jsnum.h"
51110: 
80964: #include "frontend/BytecodeEmitter.h"
80506: #include "frontend/Parser.h"
80506: #include "frontend/TokenStream.h"
79981: #include "vm/RegExpObject.h"
79981: 
59968: #include "jsscriptinlines.h"
59968: 
80468: using namespace mozilla;
51110: using namespace js;
51110: 
51110: namespace js {
51110: 
51110: char const *aopNames[] = {
51110:     "=",    /* AOP_ASSIGN */
51110:     "+=",   /* AOP_PLUS */
51110:     "-=",   /* AOP_MINUS */
51110:     "*=",   /* AOP_STAR */
51110:     "/=",   /* AOP_DIV */
51110:     "%=",   /* AOP_MOD */
51110:     "<<=",  /* AOP_LSH */
51110:     ">>=",  /* AOP_RSH */
51110:     ">>>=", /* AOP_URSH */
51110:     "|=",   /* AOP_BITOR */
51110:     "^=",   /* AOP_BITXOR */
51110:     "&="    /* AOP_BITAND */
51110: };
51110: 
51110: char const *binopNames[] = {
51110:     "==",         /* BINOP_EQ */
51110:     "!=",         /* BINOP_NE */
51110:     "===",        /* BINOP_STRICTEQ */
51110:     "!==",        /* BINOP_STRICTNE */
51110:     "<",          /* BINOP_LT */
51110:     "<=",         /* BINOP_LE */
51110:     ">",          /* BINOP_GT */
51110:     ">=",         /* BINOP_GE */
51110:     "<<",         /* BINOP_LSH */
51110:     ">>",         /* BINOP_RSH */
51110:     ">>>",        /* BINOP_URSH */
51110:     "+",          /* BINOP_PLUS */
51110:     "-",          /* BINOP_MINUS */
51110:     "*",          /* BINOP_STAR */
51110:     "/",          /* BINOP_DIV */
51110:     "%",          /* BINOP_MOD */
51110:     "|",          /* BINOP_BITOR */
51110:     "^",          /* BINOP_BITXOR */
51110:     "&",          /* BINOP_BITAND */
51110:     "in",         /* BINOP_IN */
51110:     "instanceof", /* BINOP_INSTANCEOF */
51110:     "..",         /* BINOP_DBLDOT */
51110: };
51110: 
51110: char const *unopNames[] = {
51110:     "delete",  /* UNOP_DELETE */
51110:     "-",       /* UNOP_NEG */
51110:     "+",       /* UNOP_POS */
51110:     "!",       /* UNOP_NOT */
51110:     "~",       /* UNOP_BITNOT */
51110:     "typeof",  /* UNOP_TYPEOF */
51110:     "void"     /* UNOP_VOID */
51110: };
51110: 
51110: char const *nodeTypeNames[] = {
60150: #define ASTDEF(ast, str, method) str,
60150: #include "jsast.tbl"
60150: #undef ASTDEF
60150:     NULL
60150: };
60150: 
60150: char const *callbackNames[] = {
60150: #define ASTDEF(ast, str, method) method,
51110: #include "jsast.tbl"
51110: #undef ASTDEF
51110:     NULL
51110: };
51110: 
62067: typedef AutoValueVector NodeVector;
51110: 
51110: /*
80631:  * ParseNode is a somewhat intricate data structure, and its invariants have
51110:  * evolved, making it more likely that there could be a disconnect between the
51110:  * parser and the AST serializer. We use these macros to check invariants on a
51110:  * parse node and raise a dynamic error on failure.
51110:  */
51110: #define LOCAL_ASSERT(expr)                                                             \
51110:     JS_BEGIN_MACRO                                                                     \
51110:         JS_ASSERT(expr);                                                               \
51110:         if (!(expr)) {                                                                 \
51110:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PARSE_NODE);  \
51110:             return false;                                                              \
51110:         }                                                                              \
51110:     JS_END_MACRO
51110: 
51110: #define LOCAL_NOT_REACHED(expr)                                                        \
51110:     JS_BEGIN_MACRO                                                                     \
51110:         JS_NOT_REACHED(expr);                                                          \
51110:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PARSE_NODE);      \
51110:         return false;                                                                  \
51110:     JS_END_MACRO
51110: 
51110: 
51110: /*
51110:  * Builder class that constructs JavaScript AST node objects. See:
51110:  *
51110:  *     https://developer.mozilla.org/en/SpiderMonkey/Parser_API
59991:  *
59991:  * Bug 569487: generalize builder interface
51110:  */
51110: class NodeBuilder
51110: {
51110:     JSContext   *cx;
56211:     bool        saveLoc;               /* save source location information?     */
51110:     char const  *src;                  /* source filename or null               */
51110:     Value       srcval;                /* source filename JS value or null      */
60150:     Value       callbacks[AST_LIMIT];  /* user-specified callbacks              */
60150:     Value       userv;                 /* user-specified builder object or null */
51110: 
51110:   public:
56211:     NodeBuilder(JSContext *c, bool l, char const *s)
56211:         : cx(c), saveLoc(l), src(s) {
51110:     }
51110: 
60150:     bool init(JSObject *userobj = NULL) {
60150:         if (src) {
60150:             if (!atomValue(src, &srcval))
60150:                 return false;
60150:         } else {
51110:             srcval.setNull();
60150:         }
60150: 
60150:         if (!userobj) {
60150:             userv.setNull();
60150:             for (uintN i = 0; i < AST_LIMIT; i++) {
60150:                 callbacks[i].setNull();
60150:             }
51110:             return true;
51110:         }
51110: 
60150:         userv.setObject(*userobj);
60150: 
60150:         for (uintN i = 0; i < AST_LIMIT; i++) {
60150:             Value funv;
60150: 
60150:             const char *name = callbackNames[i];
70270:             JSAtom *atom = js_Atomize(cx, name, strlen(name));
60150:             if (!atom || !GetPropertyDefault(cx, userobj, ATOM_TO_JSID(atom), NullValue(), &funv))
60150:                 return false;
60150: 
60150:             if (funv.isNullOrUndefined()) {
60150:                 callbacks[i].setNull();
60150:                 continue;
60150:             }
60150: 
60150:             if (!funv.isObject() || !funv.toObject().isFunction()) {
60150:                 js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_NOT_FUNCTION,
60150:                                          JSDVG_SEARCH_STACK, funv, NULL, NULL, NULL);
60150:                 return false;
60150:             }
60150: 
60150:             callbacks[i] = funv;
60150:         }
60150: 
60150:         return true;
60150:     }
60150: 
51110:   private:
60150:     bool callback(Value fun, TokenPos *pos, Value *dst) {
60150:         if (saveLoc) {
60150:             Value loc;
60150:             if (!newNodeLoc(pos, &loc))
60150:                 return false;
60150:             Value argv[] = { loc };
80468:             return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:         }
60150: 
60150:         Value argv[] = { NullValue() }; /* no zero-length arrays allowed! */
76829:         return Invoke(cx, userv, fun, 0, argv, dst);
60150:     }
60150: 
60150:     bool callback(Value fun, Value v1, TokenPos *pos, Value *dst) {
60150:         if (saveLoc) {
60150:             Value loc;
60150:             if (!newNodeLoc(pos, &loc))
60150:                 return false;
60150:             Value argv[] = { v1, loc };
80468:             return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:         }
60150: 
60150:         Value argv[] = { v1 };
80468:         return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:     }
60150: 
60150:     bool callback(Value fun, Value v1, Value v2, TokenPos *pos, Value *dst) {
60150:         if (saveLoc) {
60150:             Value loc;
60150:             if (!newNodeLoc(pos, &loc))
60150:                 return false;
60150:             Value argv[] = { v1, v2, loc };
80468:             return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:         }
60150: 
60150:         Value argv[] = { v1, v2 };
80468:         return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:     }
60150: 
60150:     bool callback(Value fun, Value v1, Value v2, Value v3, TokenPos *pos, Value *dst) {
60150:         if (saveLoc) {
60150:             Value loc;
60150:             if (!newNodeLoc(pos, &loc))
60150:                 return false;
60150:             Value argv[] = { v1, v2, v3, loc };
80468:             return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:         }
60150: 
60150:         Value argv[] = { v1, v2, v3 };
80468:         return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:     }
60150: 
60150:     bool callback(Value fun, Value v1, Value v2, Value v3, Value v4, TokenPos *pos, Value *dst) {
60150:         if (saveLoc) {
60150:             Value loc;
60150:             if (!newNodeLoc(pos, &loc))
60150:                 return false;
60150:             Value argv[] = { v1, v2, v3, v4, loc };
80468:             return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:         }
60150: 
60150:         Value argv[] = { v1, v2, v3, v4 };
80468:         return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:     }
60150: 
60150:     bool callback(Value fun, Value v1, Value v2, Value v3, Value v4, Value v5,
60150:                   TokenPos *pos, Value *dst) {
60150:         if (saveLoc) {
60150:             Value loc;
60150:             if (!newNodeLoc(pos, &loc))
60150:                 return false;
60150:             Value argv[] = { v1, v2, v3, v4, v5, loc };
80468:             return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:         }
60150: 
60150:         Value argv[] = { v1, v2, v3, v4, v5 };
80468:         return Invoke(cx, userv, fun, ArrayLength(argv), argv, dst);
60150:     }
60150: 
60150:     Value opt(Value v) {
60150:         JS_ASSERT_IF(v.isMagic(), v.whyMagic() == JS_SERIALIZE_NO_NODE);
60150:         return v.isMagic(JS_SERIALIZE_NO_NODE) ? UndefinedValue() : v;
60150:     }
60150: 
51110:     bool atomValue(const char *s, Value *dst) {
51110:         /*
51110:          * Bug 575416: instead of js_Atomize, lookup constant atoms in tbl file
51110:          */
70270:         JSAtom *atom = js_Atomize(cx, s, strlen(s));
51110:         if (!atom)
51110:             return false;
51110: 
64345:         dst->setString(atom);
51110:         return true;
51110:     }
51110: 
51110:     bool newObject(JSObject **dst) {
77817:         JSObject *nobj = NewNonFunction<WithProto::Class>(cx, &ObjectClass, NULL, NULL);
51110:         if (!nobj)
51110:             return false;
51110: 
51110:         *dst = nobj;
51110:         return true;
51110:     }
51110: 
51110:     bool newArray(NodeVector &elts, Value *dst);
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos, JSObject **dst);
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos, Value *dst) {
51110:         JSObject *node;
51110:         return newNode(type, pos, &node) &&
51110:                setResult(node, dst);
51110:     }
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos, const char *childName, Value child, Value *dst) {
51110:         JSObject *node;
51110:         return newNode(type, pos, &node) &&
51110:                setProperty(node, childName, child) &&
51110:                setResult(node, dst);
51110:     }
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos,
51110:                  const char *childName1, Value child1,
51110:                  const char *childName2, Value child2,
51110:                  Value *dst) {
51110:         JSObject *node;
51110:         return newNode(type, pos, &node) &&
51110:                setProperty(node, childName1, child1) &&
51110:                setProperty(node, childName2, child2) &&
51110:                setResult(node, dst);
51110:     }
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos,
51110:                  const char *childName1, Value child1,
51110:                  const char *childName2, Value child2,
51110:                  const char *childName3, Value child3,
51110:                  Value *dst) {
51110:         JSObject *node;
51110:         return newNode(type, pos, &node) &&
51110:                setProperty(node, childName1, child1) &&
51110:                setProperty(node, childName2, child2) &&
51110:                setProperty(node, childName3, child3) &&
51110:                setResult(node, dst);
51110:     }
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos,
51110:                  const char *childName1, Value child1,
51110:                  const char *childName2, Value child2,
51110:                  const char *childName3, Value child3,
51110:                  const char *childName4, Value child4,
51110:                  Value *dst) {
51110:         JSObject *node;
51110:         return newNode(type, pos, &node) &&
51110:                setProperty(node, childName1, child1) &&
51110:                setProperty(node, childName2, child2) &&
51110:                setProperty(node, childName3, child3) &&
51110:                setProperty(node, childName4, child4) &&
51110:                setResult(node, dst);
51110:     }
51110: 
51110:     bool newNode(ASTType type, TokenPos *pos,
51110:                  const char *childName1, Value child1,
51110:                  const char *childName2, Value child2,
51110:                  const char *childName3, Value child3,
51110:                  const char *childName4, Value child4,
51110:                  const char *childName5, Value child5,
51110:                  Value *dst) {
51110:         JSObject *node;
51110:         return newNode(type, pos, &node) &&
51110:                setProperty(node, childName1, child1) &&
51110:                setProperty(node, childName2, child2) &&
51110:                setProperty(node, childName3, child3) &&
51110:                setProperty(node, childName4, child4) &&
51110:                setProperty(node, childName5, child5) &&
51110:                setResult(node, dst);
51110:     }
51110: 
60150:     bool listNode(ASTType type, const char *propName, NodeVector &elts, TokenPos *pos, Value *dst) {
51110:         Value array;
60150:         if (!newArray(elts, &array))
60150:             return false;
60150: 
60150:         Value cb = callbacks[type];
60150:         if (!cb.isNull())
60150:             return callback(cb, array, pos, dst);
60150: 
60150:         return newNode(type, pos, propName, array, dst);
51110:     }
51110: 
51110:     bool setProperty(JSObject *obj, const char *name, Value val) {
51110:         JS_ASSERT_IF(val.isMagic(), val.whyMagic() == JS_SERIALIZE_NO_NODE);
51110: 
51110:         /* Represent "no node" as null and ensure users are not exposed to magic values. */
51110:         if (val.isMagic(JS_SERIALIZE_NO_NODE))
51110:             val.setNull();
51110: 
51110:         /*
51110:          * Bug 575416: instead of js_Atomize, lookup constant atoms in tbl file
51110:          */
70270:         JSAtom *atom = js_Atomize(cx, name, strlen(name));
51110:         if (!atom)
51110:             return false;
51110: 
80624:         return obj->defineProperty(cx, atom->asPropertyName(), val);
51110:     }
51110: 
60150:     bool newNodeLoc(TokenPos *pos, Value *dst);
60150: 
51110:     bool setNodeLoc(JSObject *obj, TokenPos *pos);
51110: 
51110:     bool setResult(JSObject *obj, Value *dst) {
51110:         JS_ASSERT(obj);
51110:         dst->setObject(*obj);
51110:         return true;
51110:     }
51110: 
51110:   public:
51110:     /*
51110:      * All of the public builder methods take as their last two
51110:      * arguments a nullable token position and a non-nullable, rooted
51110:      * outparam.
51110:      *
51110:      * All Value arguments are rooted. Any Value arguments representing
51110:      * optional subnodes may be a JS_SERIALIZE_NO_NODE magic value.
51110:      */
51110: 
51110:     /*
51110:      * misc nodes
51110:      */
51110: 
51110:     bool program(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool literal(Value val, TokenPos *pos, Value *dst);
51110: 
51110:     bool identifier(Value name, TokenPos *pos, Value *dst);
51110: 
51110:     bool function(ASTType type, TokenPos *pos,
51110:                   Value id, NodeVector &args, Value body,
51110:                   bool isGenerator, bool isExpression, Value *dst);
51110: 
51110:     bool variableDeclarator(Value id, Value init, TokenPos *pos, Value *dst);
51110: 
51110:     bool switchCase(Value expr, NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool catchClause(Value var, Value guard, Value body, TokenPos *pos, Value *dst);
51110: 
51110:     bool propertyInitializer(Value key, Value val, PropKind kind, TokenPos *pos, Value *dst);
51110: 
51110: 
51110:     /*
51110:      * statements
51110:      */
51110: 
51110:     bool blockStatement(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool expressionStatement(Value expr, TokenPos *pos, Value *dst);
51110: 
51110:     bool emptyStatement(TokenPos *pos, Value *dst);
51110: 
51110:     bool ifStatement(Value test, Value cons, Value alt, TokenPos *pos, Value *dst);
51110: 
51110:     bool breakStatement(Value label, TokenPos *pos, Value *dst);
51110: 
51110:     bool continueStatement(Value label, TokenPos *pos, Value *dst);
51110: 
51110:     bool labeledStatement(Value label, Value stmt, TokenPos *pos, Value *dst);
51110: 
51110:     bool throwStatement(Value arg, TokenPos *pos, Value *dst);
51110: 
51110:     bool returnStatement(Value arg, TokenPos *pos, Value *dst);
51110: 
51110:     bool forStatement(Value init, Value test, Value update, Value stmt,
51110:                       TokenPos *pos, Value *dst);
51110: 
51110:     bool forInStatement(Value var, Value expr, Value stmt,
51110:                         bool isForEach, TokenPos *pos, Value *dst);
51110: 
51110:     bool withStatement(Value expr, Value stmt, TokenPos *pos, Value *dst);
51110: 
51110:     bool whileStatement(Value test, Value stmt, TokenPos *pos, Value *dst);
51110: 
51110:     bool doWhileStatement(Value stmt, Value test, TokenPos *pos, Value *dst);
51110: 
51110:     bool switchStatement(Value disc, NodeVector &elts, bool lexical, TokenPos *pos, Value *dst);
51110: 
51110:     bool tryStatement(Value body, NodeVector &catches, Value finally, TokenPos *pos, Value *dst);
51110: 
51110:     bool debuggerStatement(TokenPos *pos, Value *dst);
51110: 
53593:     bool letStatement(NodeVector &head, Value stmt, TokenPos *pos, Value *dst);
53593: 
51110:     /*
51110:      * expressions
51110:      */
51110: 
51110:     bool binaryExpression(BinaryOperator op, Value left, Value right, TokenPos *pos, Value *dst);
51110: 
51110:     bool unaryExpression(UnaryOperator op, Value expr, TokenPos *pos, Value *dst);
51110: 
51110:     bool assignmentExpression(AssignmentOperator op, Value lhs, Value rhs,
51110:                               TokenPos *pos, Value *dst);
51110: 
51110:     bool updateExpression(Value expr, bool incr, bool prefix, TokenPos *pos, Value *dst);
51110: 
51110:     bool logicalExpression(bool lor, Value left, Value right, TokenPos *pos, Value *dst);
51110: 
51110:     bool conditionalExpression(Value test, Value cons, Value alt, TokenPos *pos, Value *dst);
51110: 
51110:     bool sequenceExpression(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool newExpression(Value callee, NodeVector &args, TokenPos *pos, Value *dst);
51110: 
51110:     bool callExpression(Value callee, NodeVector &args, TokenPos *pos, Value *dst);
51110: 
51110:     bool memberExpression(bool computed, Value expr, Value member, TokenPos *pos, Value *dst);
51110: 
51110:     bool arrayExpression(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool objectExpression(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool thisExpression(TokenPos *pos, Value *dst);
51110: 
51110:     bool yieldExpression(Value arg, TokenPos *pos, Value *dst);
51110: 
51110:     bool comprehensionBlock(Value patt, Value src, bool isForEach, TokenPos *pos, Value *dst);
51110: 
51110:     bool comprehensionExpression(Value body, NodeVector &blocks, Value filter,
51110:                                  TokenPos *pos, Value *dst);
51110: 
51110:     bool generatorExpression(Value body, NodeVector &blocks, Value filter,
51110:                              TokenPos *pos, Value *dst);
51110: 
51110:     bool graphExpression(jsint idx, Value expr, TokenPos *pos, Value *dst);
51110: 
51110:     bool graphIndexExpression(jsint idx, TokenPos *pos, Value *dst);
51110: 
53593:     bool letExpression(NodeVector &head, Value expr, TokenPos *pos, Value *dst);
53593: 
51110:     /*
51110:      * declarations
51110:      */
51110: 
51110:     bool variableDeclaration(NodeVector &elts, VarDeclKind kind, TokenPos *pos, Value *dst);
51110: 
51110:     /*
51110:      * patterns
51110:      */
51110: 
51110:     bool arrayPattern(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool objectPattern(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool propertyPattern(Value key, Value patt, TokenPos *pos, Value *dst);
51110: 
51110:     /*
51110:      * xml
51110:      */
51110: 
51110:     bool xmlAnyName(TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlEscapeExpression(Value expr, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlDefaultNamespace(Value ns, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlFilterExpression(Value left, Value right, TokenPos *pos, Value *dst);
51110: 
64202:     bool xmlAttributeSelector(Value expr, bool computed, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlQualifiedIdentifier(Value left, Value right, bool computed, TokenPos *pos, Value *dst);
51110: 
53595:     bool xmlFunctionQualifiedIdentifier(Value right, bool computed, TokenPos *pos, Value *dst);
53595: 
51110:     bool xmlElement(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlText(Value text, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlList(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlStartTag(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlEndTag(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlPointTag(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlName(Value text, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlName(NodeVector &elts, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlAttribute(Value text, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlCdata(Value text, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlComment(Value text, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlPI(Value target, TokenPos *pos, Value *dst);
51110: 
51110:     bool xmlPI(Value target, Value content, TokenPos *pos, Value *dst);
51110: };
51110: 
51110: bool
51110: NodeBuilder::newNode(ASTType type, TokenPos *pos, JSObject **dst)
51110: {
51110:     JS_ASSERT(type > AST_ERROR && type < AST_LIMIT);
51110: 
51110:     Value tv;
51110: 
77817:     JSObject *node = NewNonFunction<WithProto::Class>(cx, &ObjectClass, NULL, NULL);
51110:     if (!node ||
51110:         !setNodeLoc(node, pos) ||
51110:         !atomValue(nodeTypeNames[type], &tv) ||
53599:         !setProperty(node, "type", tv)) {
51110:         return false;
53599:     }
51110: 
51110:     *dst = node;
51110:     return true;
51110: }
51110: 
51110: bool
51110: NodeBuilder::newArray(NodeVector &elts, Value *dst)
51110: {
59234:     JSObject *array = NewDenseEmptyArray(cx);
51110:     if (!array)
51110:         return false;
51110: 
51110:     const size_t len = elts.length();
51110:     for (size_t i = 0; i < len; i++) {
51110:         Value val = elts[i];
51110: 
51110:         JS_ASSERT_IF(val.isMagic(), val.whyMagic() == JS_SERIALIZE_NO_NODE);
51110: 
60150:         /* Represent "no node" as an array hole by not adding the value. */
51110:         if (val.isMagic(JS_SERIALIZE_NO_NODE))
60150:             continue;
60150: 
80625:         if (!array->setElement(cx, i, &val, false))
51110:             return false;
51110:     }
51110: 
51110:     dst->setObject(*array);
51110:     return true;
51110: }
51110: 
51110: bool
60150: NodeBuilder::newNodeLoc(TokenPos *pos, Value *dst)
51110: {
60150:     if (!pos) {
60150:         dst->setNull();
60150:         return true;
60150:     }
51110:  
51110:     JSObject *loc, *to;
51110:     Value tv;
51110: 
60150:     if (!newObject(&loc))
60150:         return false;
60150: 
60150:     dst->setObject(*loc);
60150: 
60150:     return newObject(&to) &&
51110:            setProperty(loc, "start", ObjectValue(*to)) &&
51110:            (tv.setNumber(pos->begin.lineno), true) &&
51110:            setProperty(to, "line", tv) &&
51110:            (tv.setNumber(pos->begin.index), true) &&
51110:            setProperty(to, "column", tv) &&
51110: 
51110:            newObject(&to) &&
51110:            setProperty(loc, "end", ObjectValue(*to)) &&
51110:            (tv.setNumber(pos->end.lineno), true) &&
51110:            setProperty(to, "line", tv) &&
51110:            (tv.setNumber(pos->end.index), true) &&
60150:            setProperty(to, "column", tv) &&
60150: 
60150:            setProperty(loc, "source", srcval);
60150: }
60150: 
60150: bool
60150: NodeBuilder::setNodeLoc(JSObject *node, TokenPos *pos)
60150: {
60150:     if (!saveLoc) {
60150:         setProperty(node, "loc", NullValue());
60150:         return true;
60150:     }
60150: 
60150:     Value loc;
60150:     return newNodeLoc(pos, &loc) &&
60150:            setProperty(node, "loc", loc);
51110: }
51110: 
51110: bool
51110: NodeBuilder::program(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_PROGRAM, "body", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::blockStatement(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_BLOCK_STMT, "body", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::expressionStatement(Value expr, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_EXPR_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, expr, pos, dst);
60150: 
51110:     return newNode(AST_EXPR_STMT, pos, "expression", expr, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::emptyStatement(TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_EMPTY_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, pos, dst);
60150: 
51110:     return newNode(AST_EMPTY_STMT, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::ifStatement(Value test, Value cons, Value alt, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_IF_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, test, cons, opt(alt), pos, dst);
60150: 
51110:     return newNode(AST_IF_STMT, pos,
51110:                    "test", test,
51110:                    "consequent", cons,
51110:                    "alternate", alt,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::breakStatement(Value label, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_BREAK_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, opt(label), pos, dst);
60150: 
51110:     return newNode(AST_BREAK_STMT, pos, "label", label, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::continueStatement(Value label, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_CONTINUE_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, opt(label), pos, dst);
60150: 
51110:     return newNode(AST_CONTINUE_STMT, pos, "label", label, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::labeledStatement(Value label, Value stmt, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_LAB_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, label, stmt, pos, dst);
60150: 
51110:     return newNode(AST_LAB_STMT, pos,
51110:                    "label", label,
51110:                    "body", stmt,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::throwStatement(Value arg, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_THROW_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, arg, pos, dst);
60150: 
51110:     return newNode(AST_THROW_STMT, pos, "argument", arg, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::returnStatement(Value arg, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_RETURN_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, opt(arg), pos, dst);
60150: 
51110:     return newNode(AST_RETURN_STMT, pos, "argument", arg, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::forStatement(Value init, Value test, Value update, Value stmt,
51110:                           TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_FOR_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, opt(init), opt(test), opt(update), stmt, pos, dst);
60150: 
51110:     return newNode(AST_FOR_STMT, pos,
51110:                    "init", init,
51110:                    "test", test,
51110:                    "update", update,
51110:                    "body", stmt,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::forInStatement(Value var, Value expr, Value stmt, bool isForEach,
51110:                             TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_FOR_IN_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, var, expr, stmt, BooleanValue(isForEach), pos, dst);
60150: 
51110:     return newNode(AST_FOR_IN_STMT, pos,
51110:                    "left", var,
51110:                    "right", expr,
51110:                    "body", stmt,
51110:                    "each", BooleanValue(isForEach),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::withStatement(Value expr, Value stmt, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_WITH_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, expr, stmt, pos, dst);
60150: 
51110:     return newNode(AST_WITH_STMT, pos,
51110:                    "object", expr,
51110:                    "body", stmt,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::whileStatement(Value test, Value stmt, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_WHILE_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, test, stmt, pos, dst);
60150: 
51110:     return newNode(AST_WHILE_STMT, pos,
51110:                    "test", test,
51110:                    "body", stmt,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::doWhileStatement(Value stmt, Value test, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_DO_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, stmt, test, pos, dst);
60150: 
51110:     return newNode(AST_DO_STMT, pos,
51110:                    "body", stmt,
51110:                    "test", test,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::switchStatement(Value disc, NodeVector &elts, bool lexical, TokenPos *pos, Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(elts, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_SWITCH_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, disc, array, BooleanValue(lexical), pos, dst);
60150: 
60150:     return newNode(AST_SWITCH_STMT, pos,
51110:                    "discriminant", disc,
51110:                    "cases", array,
51110:                    "lexical", BooleanValue(lexical),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::tryStatement(Value body, NodeVector &catches, Value finally,
51110:                           TokenPos *pos, Value *dst)
51110: {
73057:     Value handlers;
60150: 
60150:     Value cb = callbacks[AST_TRY_STMT];
60150:     if (!cb.isNull()) {
73057:         return newArray(catches, &handlers) &&
73057:                callback(cb, body, handlers, opt(finally), pos, dst);
60150:     }
60150: 
73057:     if (!newArray(catches, &handlers))
51110:         return false;
51110: 
51110:     return newNode(AST_TRY_STMT, pos,
51110:                    "block", body,
73057:                    "handlers", handlers,
51110:                    "finalizer", finally,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::debuggerStatement(TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_DEBUGGER_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, pos, dst);
60150: 
51110:     return newNode(AST_DEBUGGER_STMT, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::binaryExpression(BinaryOperator op, Value left, Value right, TokenPos *pos, Value *dst)
51110: {
51110:     JS_ASSERT(op > BINOP_ERR && op < BINOP_LIMIT);
51110: 
51110:     Value opName;
60150:     if (!atomValue(binopNames[op], &opName))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_BINARY_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, opName, left, right, pos, dst);
60150: 
60150:     return newNode(AST_BINARY_EXPR, pos,
51110:                    "operator", opName,
51110:                    "left", left,
51110:                    "right", right,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::unaryExpression(UnaryOperator unop, Value expr, TokenPos *pos, Value *dst)
51110: {
51110:     JS_ASSERT(unop > UNOP_ERR && unop < UNOP_LIMIT);
51110: 
51110:     Value opName;
60150:     if (!atomValue(unopNames[unop], &opName))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_UNARY_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, opName, expr, pos, dst);
60150: 
60150:     return newNode(AST_UNARY_EXPR, pos,
51110:                    "operator", opName,
51110:                    "argument", expr,
51110:                    "prefix", BooleanValue(true),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::assignmentExpression(AssignmentOperator aop, Value lhs, Value rhs,
51110:                                   TokenPos *pos, Value *dst)
51110: {
51110:     JS_ASSERT(aop > AOP_ERR && aop < AOP_LIMIT);
51110: 
51110:     Value opName;
60150:     if (!atomValue(aopNames[aop], &opName))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_ASSIGN_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, opName, lhs, rhs, pos, dst);
60150: 
60150:     return newNode(AST_ASSIGN_EXPR, pos,
51110:                    "operator", opName,
51110:                    "left", lhs,
51110:                    "right", rhs,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::updateExpression(Value expr, bool incr, bool prefix, TokenPos *pos, Value *dst)
51110: {
51110:     Value opName;
60150:     if (!atomValue(incr ? "++" : "--", &opName))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_UPDATE_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, expr, opName, BooleanValue(prefix), pos, dst);
60150: 
60150:     return newNode(AST_UPDATE_EXPR, pos,
51110:                    "operator", opName,
51110:                    "argument", expr,
51110:                    "prefix", BooleanValue(prefix),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::logicalExpression(bool lor, Value left, Value right, TokenPos *pos, Value *dst)
51110: {
51110:     Value opName;
60150:     if (!atomValue(lor ? "||" : "&&", &opName))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_LOGICAL_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, opName, left, right, pos, dst);
60150: 
60150:     return newNode(AST_LOGICAL_EXPR, pos,
51110:                    "operator", opName,
51110:                    "left", left,
51110:                    "right", right,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::conditionalExpression(Value test, Value cons, Value alt, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_COND_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, test, cons, alt, pos, dst);
60150: 
51110:     return newNode(AST_COND_EXPR, pos,
51110:                    "test", test,
51110:                    "consequent", cons,
51110:                    "alternate", alt,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::sequenceExpression(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_LIST_EXPR, "expressions", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::callExpression(Value callee, NodeVector &args, TokenPos *pos, Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(args, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_CALL_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, callee, array, pos, dst);
60150: 
60150:     return newNode(AST_CALL_EXPR, pos,
51110:                    "callee", callee,
51110:                    "arguments", array,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::newExpression(Value callee, NodeVector &args, TokenPos *pos, Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(args, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_NEW_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, callee, array, pos, dst);
60150: 
60150:     return newNode(AST_NEW_EXPR, pos,
51110:                    "callee", callee,
51110:                    "arguments", array,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::memberExpression(bool computed, Value expr, Value member, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_MEMBER_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, BooleanValue(computed), expr, member, pos, dst);
60150: 
51110:     return newNode(AST_MEMBER_EXPR, pos,
51110:                    "object", expr,
51110:                    "property", member,
51110:                    "computed", BooleanValue(computed),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::arrayExpression(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_ARRAY_EXPR, "elements", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::propertyPattern(Value key, Value patt, TokenPos *pos, Value *dst)
51110: {
51110:     Value kindName;
60150:     if (!atomValue("init", &kindName))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_PROP_PATT];
60150:     if (!cb.isNull())
60150:         return callback(cb, key, patt, pos, dst);
60150: 
60150:     return newNode(AST_PROP_PATT, pos,
51110:                    "key", key,
51110:                    "value", patt,
51110:                    "kind", kindName,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::propertyInitializer(Value key, Value val, PropKind kind, TokenPos *pos, Value *dst)
51110: {
51110:     Value kindName;
60150:     if (!atomValue(kind == PROP_INIT
51110:                    ? "init"
51110:                    : kind == PROP_GETTER
51110:                    ? "get"
60150:                    : "set", &kindName)) {
60150:         return false;
60150:     }
60150: 
60150:     Value cb = callbacks[AST_PROPERTY];
60150:     if (!cb.isNull())
60150:         return callback(cb, kindName, key, val, pos, dst);
60150: 
60150:     return newNode(AST_PROPERTY, pos,
51110:                    "key", key,
51110:                    "value", val,
51110:                    "kind", kindName,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::objectExpression(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_OBJECT_EXPR, "properties", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::thisExpression(TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_THIS_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, pos, dst);
60150: 
51110:     return newNode(AST_THIS_EXPR, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::yieldExpression(Value arg, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_YIELD_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, opt(arg), pos, dst);
60150: 
51110:     return newNode(AST_YIELD_EXPR, pos, "argument", arg, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::comprehensionBlock(Value patt, Value src, bool isForEach, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_COMP_BLOCK];
60150:     if (!cb.isNull())
60150:         return callback(cb, patt, src, BooleanValue(isForEach), pos, dst);
60150: 
51110:     return newNode(AST_COMP_BLOCK, pos,
51110:                    "left", patt,
51110:                    "right", src,
51110:                    "each", BooleanValue(isForEach),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::comprehensionExpression(Value body, NodeVector &blocks, Value filter,
51110:                                      TokenPos *pos, Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(blocks, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_COMP_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, body, array, opt(filter), pos, dst);
60150: 
60150:     return newNode(AST_COMP_EXPR, pos,
51110:                    "body", body,
51110:                    "blocks", array,
51110:                    "filter", filter,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::generatorExpression(Value body, NodeVector &blocks, Value filter, TokenPos *pos, Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(blocks, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_GENERATOR_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, body, array, opt(filter), pos, dst);
60150: 
60150:     return newNode(AST_GENERATOR_EXPR, pos,
51110:                    "body", body,
51110:                    "blocks", array,
51110:                    "filter", filter,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::graphExpression(jsint idx, Value expr, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_GRAPH_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, NumberValue(idx), pos, dst);
60150: 
51110:     return newNode(AST_GRAPH_EXPR, pos,
51110:                    "index", NumberValue(idx),
51110:                    "expression", expr,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::graphIndexExpression(jsint idx, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_GRAPH_IDX_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, NumberValue(idx), pos, dst);
60150: 
51110:     return newNode(AST_GRAPH_IDX_EXPR, pos, "index", NumberValue(idx), dst);
51110: }
51110: 
51110: bool
53593: NodeBuilder::letExpression(NodeVector &head, Value expr, TokenPos *pos, Value *dst)
53593: {
53593:     Value array;
60150:     if (!newArray(head, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_LET_EXPR];
60150:     if (!cb.isNull())
60150:         return callback(cb, array, expr, pos, dst);
60150: 
60150:     return newNode(AST_LET_EXPR, pos,
53593:                    "head", array,
53593:                    "body", expr,
53593:                    dst);
53593: }
53593: 
53593: bool
53593: NodeBuilder::letStatement(NodeVector &head, Value stmt, TokenPos *pos, Value *dst)
53593: {
53593:     Value array;
60150:     if (!newArray(head, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_LET_STMT];
60150:     if (!cb.isNull())
60150:         return callback(cb, array, stmt, pos, dst);
60150: 
60150:     return newNode(AST_LET_STMT, pos,
53593:                    "head", array,
53593:                    "body", stmt,
53593:                    dst);
53593: }
53593: 
53593: bool
51110: NodeBuilder::variableDeclaration(NodeVector &elts, VarDeclKind kind, TokenPos *pos, Value *dst)
51110: {
51110:     JS_ASSERT(kind > VARDECL_ERR && kind < VARDECL_LIMIT);
51110: 
51110:     Value array, kindName;
60150:     if (!newArray(elts, &array) ||
60150:         !atomValue(kind == VARDECL_CONST
51110:                    ? "const"
51110:                    : kind == VARDECL_LET
51110:                    ? "let"
60150:                    : "var", &kindName)) {
60150:         return false;
60150:     }
60150: 
60150:     Value cb = callbacks[AST_VAR_DECL];
60150:     if (!cb.isNull())
60150:         return callback(cb, kindName, array, pos, dst);
60150: 
60150:     return newNode(AST_VAR_DECL, pos,
60150:                    "kind", kindName,
59991:                    "declarations", array,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::variableDeclarator(Value id, Value init, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_VAR_DTOR];
60150:     if (!cb.isNull())
60150:         return callback(cb, id, opt(init), pos, dst);
60150: 
51110:     return newNode(AST_VAR_DTOR, pos, "id", id, "init", init, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::switchCase(Value expr, NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(elts, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[AST_CASE];
60150:     if (!cb.isNull())
60150:         return callback(cb, opt(expr), array, pos, dst);
60150: 
60150:     return newNode(AST_CASE, pos,
51110:                    "test", expr,
51110:                    "consequent", array,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::catchClause(Value var, Value guard, Value body, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_CATCH];
60150:     if (!cb.isNull())
60150:         return callback(cb, var, opt(guard), body, pos, dst);
60150: 
51110:     return newNode(AST_CATCH, pos,
51110:                    "param", var,
51110:                    "guard", guard,
51110:                    "body", body,
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::literal(Value val, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_LITERAL];
60150:     if (!cb.isNull())
60150:         return callback(cb, val, pos, dst);
60150: 
51110:     return newNode(AST_LITERAL, pos, "value", val, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::identifier(Value name, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_IDENTIFIER];
60150:     if (!cb.isNull())
60150:         return callback(cb, name, pos, dst);
60150: 
51110:     return newNode(AST_IDENTIFIER, pos, "name", name, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::objectPattern(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_OBJECT_PATT, "properties", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::arrayPattern(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_ARRAY_PATT, "elements", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::function(ASTType type, TokenPos *pos,
51110:                       Value id, NodeVector &args, Value body,
51110:                       bool isGenerator, bool isExpression,
51110:                       Value *dst)
51110: {
51110:     Value array;
60150:     if (!newArray(args, &array))
60150:         return false;
60150: 
60150:     Value cb = callbacks[type];
60150:     if (!cb.isNull()) {
60150:         return callback(cb, opt(id), array, body, BooleanValue(isGenerator),
60150:                         BooleanValue(isExpression), pos, dst);
60150:     }
60150: 
60150:     return newNode(type, pos,
51110:                    "id", id,
51110:                    "params", array,
51110:                    "body", body,
51110:                    "generator", BooleanValue(isGenerator),
51110:                    "expression", BooleanValue(isExpression),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlAnyName(TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLANYNAME];
60150:     if (!cb.isNull())
60150:         return callback(cb, pos, dst);
60150: 
51110:     return newNode(AST_XMLANYNAME, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlEscapeExpression(Value expr, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLESCAPE];
60150:     if (!cb.isNull())
60150:         return callback(cb, expr, pos, dst);
60150: 
51110:     return newNode(AST_XMLESCAPE, pos, "expression", expr, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlFilterExpression(Value left, Value right, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLFILTER];
60150:     if (!cb.isNull())
60150:         return callback(cb, left, right, pos, dst);
60150: 
51110:     return newNode(AST_XMLFILTER, pos, "left", left, "right", right, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlDefaultNamespace(Value ns, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLDEFAULT];
60150:     if (!cb.isNull())
60150:         return callback(cb, ns, pos, dst);
60150: 
51110:     return newNode(AST_XMLDEFAULT, pos, "namespace", ns, dst);
51110: }
51110: 
51110: bool
64202: NodeBuilder::xmlAttributeSelector(Value expr, bool computed, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLATTR_SEL];
60150:     if (!cb.isNull())
64202:         return callback(cb, expr, BooleanValue(computed), pos, dst);
64202: 
64202:     return newNode(AST_XMLATTR_SEL, pos,
64202:                    "attribute", expr,
64202:                    "computed", BooleanValue(computed),
64202:                    dst);
51110: }
51110: 
51110: bool
53595: NodeBuilder::xmlFunctionQualifiedIdentifier(Value right, bool computed, TokenPos *pos, Value *dst)
53595: {
60150:     Value cb = callbacks[AST_XMLFUNCQUAL];
60150:     if (!cb.isNull())
60150:         return callback(cb, right, BooleanValue(computed), pos, dst);
60150: 
53595:     return newNode(AST_XMLFUNCQUAL, pos,
53595:                    "right", right,
53595:                    "computed", BooleanValue(computed),
53595:                    dst);
53595: }
53595: 
53595: bool
51110: NodeBuilder::xmlQualifiedIdentifier(Value left, Value right, bool computed,
51110:                                     TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLQUAL];
60150:     if (!cb.isNull())
60150:         return callback(cb, left, right, BooleanValue(computed), pos, dst);
60150: 
51110:     return newNode(AST_XMLQUAL, pos,
51110:                    "left", left,
51110:                    "right", right,
51110:                    "computed", BooleanValue(computed),
51110:                    dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlElement(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_XMLELEM, "contents", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlText(Value text, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLTEXT];
60150:     if (!cb.isNull())
60150:         return callback(cb, text, pos, dst);
60150: 
51110:     return newNode(AST_XMLTEXT, pos, "text", text, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlList(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_XMLLIST, "contents", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlStartTag(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_XMLSTART, "contents", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlEndTag(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_XMLEND, "contents", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlPointTag(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_XMLPOINT, "contents", elts, pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlName(Value text, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLNAME];
60150:     if (!cb.isNull())
60150:         return callback(cb, text, pos, dst);
60150: 
51110:     return newNode(AST_XMLNAME, pos, "contents", text, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlName(NodeVector &elts, TokenPos *pos, Value *dst)
51110: {
60150:     return listNode(AST_XMLNAME, "contents", elts, pos ,dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlAttribute(Value text, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLATTR];
60150:     if (!cb.isNull())
60150:         return callback(cb, text, pos, dst);
60150: 
51110:     return newNode(AST_XMLATTR, pos, "value", text, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlCdata(Value text, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLCDATA];
60150:     if (!cb.isNull())
60150:         return callback(cb, text, pos, dst);
60150: 
51110:     return newNode(AST_XMLCDATA, pos, "contents", text, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlComment(Value text, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLCOMMENT];
60150:     if (!cb.isNull())
60150:         return callback(cb, text, pos, dst);
60150: 
51110:     return newNode(AST_XMLCOMMENT, pos, "contents", text, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlPI(Value target, TokenPos *pos, Value *dst)
51110: {
51110:     return xmlPI(target, NullValue(), pos, dst);
51110: }
51110: 
51110: bool
51110: NodeBuilder::xmlPI(Value target, Value contents, TokenPos *pos, Value *dst)
51110: {
60150:     Value cb = callbacks[AST_XMLPI];
60150:     if (!cb.isNull())
60150:         return callback(cb, target, contents, pos, dst);
60150: 
51110:     return newNode(AST_XMLPI, pos,
51110:                    "target", target,
51110:                    "contents", contents,
51110:                    dst);
51110: }
51110: 
51110: 
51110: /*
51110:  * Serialization of parse nodes to JavaScript objects.
51110:  *
80631:  * All serialization methods take a non-nullable ParseNode pointer.
51110:  */
51110: 
51110: class ASTSerializer
51110: {
51110:     JSContext     *cx;
80522:     Parser        *parser;
51110:     NodeBuilder   builder;
56211:     uint32        lineno;
51110: 
51110:     Value atomContents(JSAtom *atom) {
64345:         return StringValue(atom ? atom : cx->runtime->atomState.emptyAtom);
51110:     }
51110: 
82024:     BinaryOperator binop(ParseNodeKind kind, JSOp op);
82024:     UnaryOperator unop(ParseNodeKind kind, JSOp op);
51110:     AssignmentOperator aop(JSOp op);
51110: 
80631:     bool statements(ParseNode *pn, NodeVector &elts);
80631:     bool expressions(ParseNode *pn, NodeVector &elts);
80631:     bool xmls(ParseNode *pn, NodeVector &elts);
80631:     bool leftAssociate(ParseNode *pn, Value *dst);
80631:     bool functionArgs(ParseNode *pn, ParseNode *pnargs, ParseNode *pndestruct, ParseNode *pnbody,
80631:                       NodeVector &args);
80631: 
80631:     bool sourceElement(ParseNode *pn, Value *dst);
80631: 
80631:     bool declaration(ParseNode *pn, Value *dst);
80631:     bool variableDeclaration(ParseNode *pn, bool let, Value *dst);
80631:     bool variableDeclarator(ParseNode *pn, VarDeclKind *pkind, Value *dst);
80631:     bool letHead(ParseNode *pn, NodeVector &dtors);
80631: 
80631:     bool optStatement(ParseNode *pn, Value *dst) {
51110:         if (!pn) {
51110:             dst->setMagic(JS_SERIALIZE_NO_NODE);
51110:             return true;
51110:         }
51110:         return statement(pn, dst);
51110:     }
51110: 
80631:     bool forInit(ParseNode *pn, Value *dst);
80631:     bool statement(ParseNode *pn, Value *dst);
80631:     bool blockStatement(ParseNode *pn, Value *dst);
80631:     bool switchStatement(ParseNode *pn, Value *dst);
80631:     bool switchCase(ParseNode *pn, Value *dst);
80631:     bool tryStatement(ParseNode *pn, Value *dst);
80631:     bool catchClause(ParseNode *pn, Value *dst);
80631: 
80631:     bool optExpression(ParseNode *pn, Value *dst) {
51110:         if (!pn) {
51110:             dst->setMagic(JS_SERIALIZE_NO_NODE);
51110:             return true;
51110:         }
51110:         return expression(pn, dst);
51110:     }
51110: 
80631:     bool expression(ParseNode *pn, Value *dst);
80631: 
80631:     bool propertyName(ParseNode *pn, Value *dst);
80631:     bool property(ParseNode *pn, Value *dst);
51110: 
51110:     bool optIdentifier(JSAtom *atom, TokenPos *pos, Value *dst) {
51110:         if (!atom) {
51110:             dst->setMagic(JS_SERIALIZE_NO_NODE);
51110:             return true;
51110:         }
51110:         return identifier(atom, pos, dst);
51110:     }
51110: 
51110:     bool identifier(JSAtom *atom, TokenPos *pos, Value *dst);
80631:     bool identifier(ParseNode *pn, Value *dst);
80631:     bool literal(ParseNode *pn, Value *dst);
80631: 
80631:     bool pattern(ParseNode *pn, VarDeclKind *pkind, Value *dst);
80631:     bool arrayPattern(ParseNode *pn, VarDeclKind *pkind, Value *dst);
80631:     bool objectPattern(ParseNode *pn, VarDeclKind *pkind, Value *dst);
80631: 
80631:     bool function(ParseNode *pn, ASTType type, Value *dst);
80631:     bool functionArgsAndBody(ParseNode *pn, NodeVector &args, Value *body);
80631:     bool functionBody(ParseNode *pn, TokenPos *pos, Value *dst);
80631: 
80631:     bool comprehensionBlock(ParseNode *pn, Value *dst);
80631:     bool comprehension(ParseNode *pn, Value *dst);
80631:     bool generatorExpression(ParseNode *pn, Value *dst);
80631: 
80631:     bool xml(ParseNode *pn, Value *dst);
51110: 
51110:   public:
56211:     ASTSerializer(JSContext *c, bool l, char const *src, uint32 ln)
56211:         : cx(c), builder(c, l, src), lineno(ln) {
51110:     }
51110: 
60150:     bool init(JSObject *userobj) {
60150:         return builder.init(userobj);
51110:     }
51110: 
80522:     void setParser(Parser *p) {
80522:         parser = p;
80522:     }
80522: 
80631:     bool program(ParseNode *pn, Value *dst);
51110: };
51110: 
51110: AssignmentOperator
51110: ASTSerializer::aop(JSOp op)
51110: {
51110:     switch (op) {
51110:       case JSOP_NOP:
51110:         return AOP_ASSIGN;
51110:       case JSOP_ADD:
51110:         return AOP_PLUS;
51110:       case JSOP_SUB:
51110:         return AOP_MINUS;
51110:       case JSOP_MUL:
51110:         return AOP_STAR;
51110:       case JSOP_DIV:
51110:         return AOP_DIV;
51110:       case JSOP_MOD:
51110:         return AOP_MOD;
51110:       case JSOP_LSH:
51110:         return AOP_LSH;
51110:       case JSOP_RSH:
51110:         return AOP_RSH;
51110:       case JSOP_URSH:
51110:         return AOP_URSH;
51110:       case JSOP_BITOR:
51110:         return AOP_BITOR;
51110:       case JSOP_BITXOR:
51110:         return AOP_BITXOR;
51110:       case JSOP_BITAND:
51110:         return AOP_BITAND;
51110:       default:
51110:         return AOP_ERR;
51110:     }
51110: }
51110: 
51110: UnaryOperator
82024: ASTSerializer::unop(ParseNodeKind kind, JSOp op)
51110: {
82024:     if (kind == PNK_DELETE)
51110:         return UNOP_DELETE;
51110: 
51110:     switch (op) {
51110:       case JSOP_NEG:
51110:         return UNOP_NEG;
51110:       case JSOP_POS:
51110:         return UNOP_POS;
51110:       case JSOP_NOT:
51110:         return UNOP_NOT;
51110:       case JSOP_BITNOT:
51110:         return UNOP_BITNOT;
51110:       case JSOP_TYPEOF:
51110:       case JSOP_TYPEOFEXPR:
51110:         return UNOP_TYPEOF;
51110:       case JSOP_VOID:
51110:         return UNOP_VOID;
51110:       default:
51110:         return UNOP_ERR;
51110:     }
51110: }
51110: 
51110: BinaryOperator
82024: ASTSerializer::binop(ParseNodeKind kind, JSOp op)
51110: {
82024:     switch (kind) {
82024:       case PNK_LSH:
51110:         return BINOP_LSH;
82024:       case PNK_RSH:
51110:         return BINOP_RSH;
82024:       case PNK_URSH:
51110:         return BINOP_URSH;
82024:       case PNK_LT:
82019:         return BINOP_LT;
82024:       case PNK_LE:
82019:         return BINOP_LE;
82024:       case PNK_GT:
82019:         return BINOP_GT;
82024:       case PNK_GE:
82019:         return BINOP_GE;
82024:       case PNK_EQ:
82015:         return BINOP_EQ;
82024:       case PNK_NE:
82015:         return BINOP_NE;
82024:       case PNK_STRICTEQ:
82015:         return BINOP_STRICTEQ;
82024:       case PNK_STRICTNE:
82015:         return BINOP_STRICTNE;
82024:       case PNK_PLUS:
51110:         return BINOP_PLUS;
82024:       case PNK_MINUS:
51110:         return BINOP_MINUS;
82024:       case PNK_STAR:
51110:         return BINOP_STAR;
82024:       case PNK_DIV:
82021:         return BINOP_DIV;
82024:       case PNK_MOD:
82021:         return BINOP_MOD;
82024:       case PNK_BITOR:
51110:         return BINOP_BITOR;
82024:       case PNK_BITXOR:
51110:         return BINOP_BITXOR;
82024:       case PNK_BITAND:
51110:         return BINOP_BITAND;
82024:       case PNK_IN:
51110:         return BINOP_IN;
82024:       case PNK_INSTANCEOF:
51110:         return BINOP_INSTANCEOF;
82024:       case PNK_DBLDOT:
51110:         return BINOP_DBLDOT;
51110:       default:
51110:         return BINOP_ERR;
51110:     }
51110: }
51110: 
51110: bool
80631: ASTSerializer::statements(ParseNode *pn, NodeVector &elts)
51110: {
82024:     JS_ASSERT(pn->isKind(PNK_LC) && pn->isArity(PN_LIST));
51110: 
51110:     if (!elts.reserve(pn->pn_count))
51110:         return false;
51110: 
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
51110:         Value elt;
51110:         if (!sourceElement(next, &elt))
51110:             return false;
64229:         elts.infallibleAppend(elt);
51110:     }
51110: 
51110:     return true;
51110: }
51110: 
51110: bool
80631: ASTSerializer::expressions(ParseNode *pn, NodeVector &elts)
51110: {
51110:     if (!elts.reserve(pn->pn_count))
51110:         return false;
51110: 
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
51110:         Value elt;
51110:         if (!expression(next, &elt))
51110:             return false;
64229:         elts.infallibleAppend(elt);
51110:     }
51110: 
51110:     return true;
51110: }
51110: 
51110: bool
80631: ASTSerializer::xmls(ParseNode *pn, NodeVector &elts)
51110: {
51110:     if (!elts.reserve(pn->pn_count))
51110:         return false;
51110: 
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
51110:         Value elt;
51110:         if (!xml(next, &elt))
51110:             return false;
64229:         elts.infallibleAppend(elt);
51110:     }
51110: 
51110:     return true;
51110: }
51110: 
51110: bool
80631: ASTSerializer::blockStatement(ParseNode *pn, Value *dst)
51110: {
82024:     JS_ASSERT(pn->isKind(PNK_LC));
51110: 
51110:     NodeVector stmts(cx);
51110:     return statements(pn, stmts) &&
51110:            builder.blockStatement(stmts, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::program(ParseNode *pn, Value *dst)
51110: {
74286:     JS_ASSERT(pn->pn_pos.begin.lineno == lineno);
51110: 
51110:     NodeVector stmts(cx);
51110:     return statements(pn, stmts) &&
51110:            builder.program(stmts, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::sourceElement(ParseNode *pn, Value *dst)
51110: {
51110:     /* SpiderMonkey allows declarations even in pure statement contexts. */
51110:     return statement(pn, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::declaration(ParseNode *pn, Value *dst)
51110: {
82024:     JS_ASSERT(pn->isKind(PNK_FUNCTION) || pn->isKind(PNK_VAR) || pn->isKind(PNK_LET));
78294: 
78294:     switch (pn->getKind()) {
82024:       case PNK_FUNCTION:
51110:         return function(pn, AST_FUNC_DECL, dst);
51110: 
82024:       case PNK_VAR:
51110:         return variableDeclaration(pn, false, dst);
51110: 
51110:       default:
82024:         JS_ASSERT(pn->isKind(PNK_LET));
51110:         return variableDeclaration(pn, true, dst);
51110:     }
51110: }
51110: 
51110: bool
80631: ASTSerializer::variableDeclaration(ParseNode *pn, bool let, Value *dst)
51110: {
82024:     JS_ASSERT(let ? pn->isKind(PNK_LET) : pn->isKind(PNK_VAR));
51110: 
51110:     /* Later updated to VARDECL_CONST if we find a PND_CONST declarator. */
51110:     VarDeclKind kind = let ? VARDECL_LET : VARDECL_VAR;
51110: 
51110:     NodeVector dtors(cx);
51110: 
51110:     /* In a for-in context, variable declarations contain just a single pattern. */
51110:     if (pn->pn_xflags & PNX_FORINVAR) {
51110:         Value patt, child;
51110:         return pattern(pn->pn_head, &kind, &patt) &&
51110:                builder.variableDeclarator(patt, NullValue(), &pn->pn_head->pn_pos, &child) &&
51110:                dtors.append(child) &&
51110:                builder.variableDeclaration(dtors, kind, &pn->pn_pos, dst);
51110:     }
51110: 
64229:     if (!dtors.reserve(pn->pn_count))
64229:         return false;
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
51110:         Value child;
51110:         if (!variableDeclarator(next, &kind, &child))
51110:             return false;
64229:         dtors.infallibleAppend(child);
51110:     }
51110: 
51110:     return builder.variableDeclaration(dtors, kind, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::variableDeclarator(ParseNode *pn, VarDeclKind *pkind, Value *dst)
51110: {
82024:     /* A destructuring declarator is always a PNK_ASSIGN. */
82024:     JS_ASSERT(pn->isKind(PNK_NAME) || pn->isKind(PNK_ASSIGN));
51110: 
80631:     ParseNode *pnleft;
80631:     ParseNode *pnright;
51110: 
82024:     if (pn->isKind(PNK_NAME)) {
51110:         pnleft = pn;
78294:         pnright = pn->isUsed() ? NULL : pn->pn_expr;
51110:     } else {
82024:         JS_ASSERT(pn->isKind(PNK_ASSIGN));
51110:         pnleft = pn->pn_left;
51110:         pnright = pn->pn_right;
51110:     }
51110: 
51110:     Value left, right;
51110:     return pattern(pnleft, pkind, &left) &&
51110:            optExpression(pnright, &right) &&
51110:            builder.variableDeclarator(left, right, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::letHead(ParseNode *pn, NodeVector &dtors)
53593: {
53593:     if (!dtors.reserve(pn->pn_count))
53593:         return false;
53593: 
53593:     VarDeclKind kind = VARDECL_LET_HEAD;
53593: 
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
53593:         Value child;
53593:         /*
53593:          * Unlike in |variableDeclaration|, this does not update |kind|; since let-heads do
53593:          * not contain const declarations, declarators should never have PND_CONST set.
53593:          */
53593:         if (!variableDeclarator(next, &kind, &child))
53593:             return false;
64229:         dtors.infallibleAppend(child);
53593:     }
53593: 
53593:     return true;
53593: }
53593: 
53593: bool
80631: ASTSerializer::switchCase(ParseNode *pn, Value *dst)
51110: {
51110:     NodeVector stmts(cx);
51110: 
51110:     Value expr;
51110: 
51110:     return optExpression(pn->pn_left, &expr) &&
51110:            statements(pn->pn_right, stmts) &&
51110:            builder.switchCase(expr, stmts, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::switchStatement(ParseNode *pn, Value *dst)
51110: {
51110:     Value disc;
51110: 
51110:     if (!expression(pn->pn_left, &disc))
51110:         return false;
51110: 
80631:     ParseNode *listNode;
51110:     bool lexical;
51110: 
82024:     if (pn->pn_right->isKind(PNK_LEXICALSCOPE)) {
51110:         listNode = pn->pn_right->pn_expr;
51110:         lexical = true;
51110:     } else {
51110:         listNode = pn->pn_right;
51110:         lexical = false;
51110:     }
51110: 
51110:     NodeVector cases(cx);
51110:     if (!cases.reserve(listNode->pn_count))
51110:         return false;
51110: 
80631:     for (ParseNode *next = listNode->pn_head; next; next = next->pn_next) {
51110:         Value child;
60142: #ifdef __GNUC__ /* quell GCC overwarning */
60142:         child = UndefinedValue();
60142: #endif
51110:         if (!switchCase(next, &child))
51110:             return false;
64229:         cases.infallibleAppend(child);
51110:     }
51110: 
51110:     return builder.switchStatement(disc, cases, lexical, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::catchClause(ParseNode *pn, Value *dst)
51110: {
51110:     Value var, guard, body;
51110: 
51110:     return pattern(pn->pn_kid1, NULL, &var) &&
51110:            optExpression(pn->pn_kid2, &guard) &&
51110:            statement(pn->pn_kid3, &body) &&
51110:            builder.catchClause(var, guard, body, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::tryStatement(ParseNode *pn, Value *dst)
51110: {
51110:     Value body;
51110:     if (!statement(pn->pn_kid1, &body))
51110:         return false;
51110: 
51110:     NodeVector clauses(cx);
51110:     if (pn->pn_kid2) {
51110:         if (!clauses.reserve(pn->pn_kid2->pn_count))
51110:             return false;
51110: 
80631:         for (ParseNode *next = pn->pn_kid2->pn_head; next; next = next->pn_next) {
51110:             Value clause;
51110:             if (!catchClause(next->pn_expr, &clause))
51110:                 return false;
64229:             clauses.infallibleAppend(clause);
51110:         }
51110:     }
51110: 
51110:     Value finally;
51110:     return optStatement(pn->pn_kid3, &finally) &&
51110:            builder.tryStatement(body, clauses, finally, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::forInit(ParseNode *pn, Value *dst)
51110: {
51110:     if (!pn) {
51110:         dst->setMagic(JS_SERIALIZE_NO_NODE);
51110:         return true;
51110:     }
51110: 
82024:     return pn->isKind(PNK_VAR)
51110:            ? variableDeclaration(pn, false, dst)
82024:            : pn->isKind(PNK_LET)
51110:            ? variableDeclaration(pn, true, dst)
51110:            : expression(pn, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::statement(ParseNode *pn, Value *dst)
51110: {
72088:     JS_CHECK_RECURSION(cx, return false);
78294:     switch (pn->getKind()) {
82024:       case PNK_FUNCTION:
82024:       case PNK_VAR:
82024:       case PNK_LET:
51110:         return declaration(pn, dst);
51110: 
82024:       case PNK_NAME:
78294:         LOCAL_ASSERT(pn->isUsed());
53597:         return statement(pn->pn_lexdef, dst);
53597: 
82024:       case PNK_SEMI:
51110:         if (pn->pn_kid) {
51110:             Value expr;
51110:             return expression(pn->pn_kid, &expr) &&
51110:                    builder.expressionStatement(expr, &pn->pn_pos, dst);
51110:         }
51110:         return builder.emptyStatement(&pn->pn_pos, dst);
51110: 
82024:       case PNK_LEXICALSCOPE:
51110:         pn = pn->pn_expr;
82024:         if (pn->isKind(PNK_LET)) {
53593:             NodeVector dtors(cx);
53593:             Value stmt;
53593: 
53593:             return letHead(pn->pn_left, dtors) &&
53593:                    statement(pn->pn_right, &stmt) &&
53593:                    builder.letStatement(dtors, stmt, &pn->pn_pos, dst);
53593:         }
53593: 
82024:         if (!pn->isKind(PNK_LC))
51110:             return statement(pn, dst);
51110:         /* FALL THROUGH */
51110: 
82024:       case PNK_LC:
51110:         return blockStatement(pn, dst);
51110: 
82024:       case PNK_IF:
51110:       {
51110:         Value test, cons, alt;
51110: 
51110:         return expression(pn->pn_kid1, &test) &&
51110:                statement(pn->pn_kid2, &cons) &&
51110:                optStatement(pn->pn_kid3, &alt) &&
51110:                builder.ifStatement(test, cons, alt, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_SWITCH:
51110:         return switchStatement(pn, dst);
51110: 
82024:       case PNK_TRY:
51110:         return tryStatement(pn, dst);
51110: 
82024:       case PNK_WITH:
82024:       case PNK_WHILE:
51110:       {
51110:         Value expr, stmt;
51110: 
51110:         return expression(pn->pn_left, &expr) &&
51110:                statement(pn->pn_right, &stmt) &&
82024:                (pn->isKind(PNK_WITH)
51110:                 ? builder.withStatement(expr, stmt, &pn->pn_pos, dst)
80917:                 : builder.whileStatement(expr, stmt, &pn->pn_pos, dst));
51110:       }
51110: 
82024:       case PNK_DO:
51110:       {
51110:         Value stmt, test;
51110: 
51110:         return statement(pn->pn_left, &stmt) &&
51110:                expression(pn->pn_right, &test) &&
51110:                builder.doWhileStatement(stmt, test, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_FOR:
51110:       {
80631:         ParseNode *head = pn->pn_left;
51110: 
51110:         Value stmt;
51110:         if (!statement(pn->pn_right, &stmt))
51110:             return false;
51110: 
51110:         bool isForEach = pn->pn_iflags & JSITER_FOREACH;
51110: 
82024:         if (head->isKind(PNK_IN)) {
51110:             Value var, expr;
51110: 
74052:             return (!head->pn_kid1
74052:                     ? pattern(head->pn_kid2, NULL, &var)
74052:                     : variableDeclaration(head->pn_kid1,
82024:                                           head->pn_kid1->isKind(PNK_LET),
74052:                                           &var)) &&
74052:                    expression(head->pn_kid3, &expr) &&
51110:                    builder.forInStatement(var, expr, stmt, isForEach, &pn->pn_pos, dst);
51110:         }
51110: 
51110:         Value init, test, update;
51110: 
51110:         return forInit(head->pn_kid1, &init) &&
51110:                optExpression(head->pn_kid2, &test) &&
51110:                optExpression(head->pn_kid3, &update) &&
51110:                builder.forStatement(init, test, update, stmt, &pn->pn_pos, dst);
51110:       }
51110: 
53594:       /* Synthesized by the parser when a for-in loop contains a variable initializer. */
82024:       case PNK_SEQ:
53594:       {
53594:         LOCAL_ASSERT(pn->pn_count == 2);
53594: 
80631:         ParseNode *prelude = pn->pn_head;
80631:         ParseNode *loop = prelude->pn_next;
74052: 
82024:         LOCAL_ASSERT(prelude->isKind(PNK_VAR) && loop->isKind(PNK_FOR));
74052: 
53594:         Value var;
53594:         if (!variableDeclaration(prelude, false, &var))
53594:             return false;
53594: 
80631:         ParseNode *head = loop->pn_left;
82024:         JS_ASSERT(head->isKind(PNK_IN));
53594: 
53594:         bool isForEach = loop->pn_iflags & JSITER_FOREACH;
53594: 
53594:         Value expr, stmt;
53594: 
74052:         return expression(head->pn_kid3, &expr) &&
53594:                statement(loop->pn_right, &stmt) &&
53594:                builder.forInStatement(var, expr, stmt, isForEach, &pn->pn_pos, dst);
53594:       }
53594: 
82024:       case PNK_BREAK:
82024:       case PNK_CONTINUE:
51110:       {
51110:         Value label;
51110: 
51110:         return optIdentifier(pn->pn_atom, NULL, &label) &&
82024:                (pn->isKind(PNK_BREAK)
51110:                 ? builder.breakStatement(label, &pn->pn_pos, dst)
51110:                 : builder.continueStatement(label, &pn->pn_pos, dst));
51110:       }
51110: 
82024:       case PNK_COLON:
51110:       {
51110:         Value label, stmt;
51110: 
51110:         return identifier(pn->pn_atom, NULL, &label) &&
51110:                statement(pn->pn_expr, &stmt) &&
51110:                builder.labeledStatement(label, stmt, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_THROW:
82024:       case PNK_RETURN:
51110:       {
51110:         Value arg;
51110: 
51110:         return optExpression(pn->pn_kid, &arg) &&
82024:                (pn->isKind(PNK_THROW)
51110:                 ? builder.throwStatement(arg, &pn->pn_pos, dst)
51110:                 : builder.returnStatement(arg, &pn->pn_pos, dst));
51110:       }
51110: 
82024:       case PNK_DEBUGGER:
51110:         return builder.debuggerStatement(&pn->pn_pos, dst);
51110: 
51110: #if JS_HAS_XML_SUPPORT
82024:       case PNK_DEFAULT:
51110:       {
78294:         LOCAL_ASSERT(pn->isArity(PN_UNARY));
51110: 
51110:         Value ns;
51110: 
53596:         return expression(pn->pn_kid, &ns) &&
51110:                builder.xmlDefaultNamespace(ns, &pn->pn_pos, dst);
51110:       }
51110: #endif
51110: 
51110:       default:
51110:         LOCAL_NOT_REACHED("unexpected statement type");
51110:     }
51110: }
51110: 
51110: bool
80631: ASTSerializer::leftAssociate(ParseNode *pn, Value *dst)
51110: {
78294:     JS_ASSERT(pn->isArity(PN_LIST));
64247:     JS_ASSERT(pn->pn_count >= 1);
51110: 
82024:     ParseNodeKind kind = pn->getKind();
82024:     bool lor = kind == PNK_OR;
82024:     bool logop = lor || (kind == PNK_AND);
51110: 
80631:     ParseNode *head = pn->pn_head;
64201:     Value left;
64201:     if (!expression(head, &left))
64201:         return false;
80631:     for (ParseNode *next = head->pn_next; next; next = next->pn_next) {
51110:         Value right;
64201:         if (!expression(next, &right))
51110:             return false;
51110: 
80983:         TokenPos subpos = {pn->pn_pos.begin, next->pn_pos.end};
51110: 
51110:         if (logop) {
64201:             if (!builder.logicalExpression(lor, left, right, &subpos, &left))
51110:                 return false;
51110:         } else {
78294:             BinaryOperator op = binop(pn->getKind(), pn->getOp());
51110:             LOCAL_ASSERT(op > BINOP_ERR && op < BINOP_LIMIT);
51110: 
64201:             if (!builder.binaryExpression(op, left, right, &subpos, &left))
51110:                 return false;
51110:         }
64201:     }
64201: 
64201:     *dst = left;
51110:     return true;
51110: }
51110: 
51110: bool
80631: ASTSerializer::comprehensionBlock(ParseNode *pn, Value *dst)
51110: {
78294:     LOCAL_ASSERT(pn->isArity(PN_BINARY));
51110: 
80631:     ParseNode *in = pn->pn_left;
51110: 
82024:     LOCAL_ASSERT(in && in->isKind(PNK_IN));
51110: 
51110:     bool isForEach = pn->pn_iflags & JSITER_FOREACH;
51110: 
51110:     Value patt, src;
74052:     return pattern(in->pn_kid2, NULL, &patt) &&
74052:            expression(in->pn_kid3, &src) &&
51110:            builder.comprehensionBlock(patt, src, isForEach, &in->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::comprehension(ParseNode *pn, Value *dst)
51110: {
82024:     LOCAL_ASSERT(pn->isKind(PNK_FOR));
51110: 
51110:     NodeVector blocks(cx);
51110: 
80631:     ParseNode *next = pn;
82024:     while (next->isKind(PNK_FOR)) {
51110:         Value block;
53599:         if (!comprehensionBlock(next, &block) || !blocks.append(block))
51110:             return false;
51110:         next = next->pn_right;
51110:     }
51110: 
51110:     Value filter = MagicValue(JS_SERIALIZE_NO_NODE);
51110: 
82024:     if (next->isKind(PNK_IF)) {
51110:         if (!optExpression(next->pn_kid1, &filter))
51110:             return false;
51110:         next = next->pn_kid2;
82024:     } else if (next->isKind(PNK_LC) && next->pn_count == 0) {
80786:         /* FoldConstants optimized away the push. */
51110:         NodeVector empty(cx);
51110:         return builder.arrayExpression(empty, &pn->pn_pos, dst);
51110:     }
51110: 
82024:     LOCAL_ASSERT(next->isKind(PNK_ARRAYPUSH));
51110: 
51110:     Value body;
51110: 
51110:     return expression(next->pn_kid, &body) &&
51110:            builder.comprehensionExpression(body, blocks, filter, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::generatorExpression(ParseNode *pn, Value *dst)
51110: {
82024:     LOCAL_ASSERT(pn->isKind(PNK_FOR));
51110: 
51110:     NodeVector blocks(cx);
51110: 
80631:     ParseNode *next = pn;
82024:     while (next->isKind(PNK_FOR)) {
51110:         Value block;
53599:         if (!comprehensionBlock(next, &block) || !blocks.append(block))
51110:             return false;
51110:         next = next->pn_right;
51110:     }
51110: 
51110:     Value filter = MagicValue(JS_SERIALIZE_NO_NODE);
51110: 
82024:     if (next->isKind(PNK_IF)) {
51110:         if (!optExpression(next->pn_kid1, &filter))
51110:             return false;
51110:         next = next->pn_kid2;
51110:     }
51110: 
82024:     LOCAL_ASSERT(next->isKind(PNK_SEMI) &&
82024:                  next->pn_kid->isKind(PNK_YIELD) &&
51110:                  next->pn_kid->pn_kid);
51110: 
51110:     Value body;
51110: 
51110:     return expression(next->pn_kid->pn_kid, &body) &&
51110:            builder.generatorExpression(body, blocks, filter, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::expression(ParseNode *pn, Value *dst)
51110: {
72088:     JS_CHECK_RECURSION(cx, return false);
78294:     switch (pn->getKind()) {
82024:       case PNK_FUNCTION:
51110:         return function(pn, AST_FUNC_EXPR, dst);
51110: 
82024:       case PNK_COMMA:
51110:       {
51110:         NodeVector exprs(cx);
51110:         return expressions(pn, exprs) &&
51110:                builder.sequenceExpression(exprs, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_HOOK:
51110:       {
51110:         Value test, cons, alt;
51110: 
51110:         return expression(pn->pn_kid1, &test) &&
51110:                expression(pn->pn_kid2, &cons) &&
51110:                expression(pn->pn_kid3, &alt) &&
51110:                builder.conditionalExpression(test, cons, alt, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_OR:
82024:       case PNK_AND:
51110:       {
78294:         if (pn->isArity(PN_BINARY)) {
51110:             Value left, right;
51110:             return expression(pn->pn_left, &left) &&
51110:                    expression(pn->pn_right, &right) &&
82024:                    builder.logicalExpression(pn->isKind(PNK_OR), left, right, &pn->pn_pos, dst);
51110:         }
51110:         return leftAssociate(pn, dst);
51110:       }
51110: 
82024:       case PNK_INC:
82024:       case PNK_DEC:
51110:       {
82024:         bool incr = pn->isKind(PNK_INC);
78294:         bool prefix = pn->getOp() >= JSOP_INCNAME && pn->getOp() <= JSOP_DECELEM;
51110: 
51110:         Value expr;
51110:         return expression(pn->pn_kid, &expr) &&
51110:                builder.updateExpression(expr, incr, prefix, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_ASSIGN:
82024:       case PNK_ADDASSIGN:
82024:       case PNK_SUBASSIGN:
82024:       case PNK_BITORASSIGN:
82024:       case PNK_BITXORASSIGN:
82024:       case PNK_BITANDASSIGN:
82024:       case PNK_LSHASSIGN:
82024:       case PNK_RSHASSIGN:
82024:       case PNK_URSHASSIGN:
82024:       case PNK_MULASSIGN:
82024:       case PNK_DIVASSIGN:
82024:       case PNK_MODASSIGN:
51110:       {
78294:         AssignmentOperator op = aop(pn->getOp());
51110:         LOCAL_ASSERT(op > AOP_ERR && op < AOP_LIMIT);
51110: 
51110:         Value lhs, rhs;
51110:         return pattern(pn->pn_left, NULL, &lhs) &&
51110:                expression(pn->pn_right, &rhs) &&
51110:                builder.assignmentExpression(op, lhs, rhs, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_PLUS:
82024:       case PNK_MINUS:
82018:         if (pn->isArity(PN_UNARY))
82018:             goto unary_plusminus;
82018:         /* FALL THROUGH */
82024:       case PNK_STRICTEQ:
82024:       case PNK_EQ:
82024:       case PNK_STRICTNE:
82024:       case PNK_NE:
82024:       case PNK_LT:
82024:       case PNK_LE:
82024:       case PNK_GT:
82024:       case PNK_GE:
82024:       case PNK_LSH:
82024:       case PNK_RSH:
82024:       case PNK_URSH:
82024:       case PNK_STAR:
82024:       case PNK_DIV:
82024:       case PNK_MOD:
82024:       case PNK_BITOR:
82024:       case PNK_BITXOR:
82024:       case PNK_BITAND:
82024:       case PNK_IN:
82024:       case PNK_INSTANCEOF:
82024:       case PNK_DBLDOT:
78294:         if (pn->isArity(PN_BINARY)) {
78294:             BinaryOperator op = binop(pn->getKind(), pn->getOp());
51110:             LOCAL_ASSERT(op > BINOP_ERR && op < BINOP_LIMIT);
51110: 
51110:             Value left, right;
51110:             return expression(pn->pn_left, &left) &&
51110:                    expression(pn->pn_right, &right) &&
51110:                    builder.binaryExpression(op, left, right, &pn->pn_pos, dst);
51110:         }
51110:         return leftAssociate(pn, dst);
51110: 
82024:       case PNK_DELETE:
82024:       case PNK_TYPEOF:
82024:       case PNK_VOID:
82024:       case PNK_NOT:
82024:       case PNK_BITNOT:
82018:       unary_plusminus: {
78294:         UnaryOperator op = unop(pn->getKind(), pn->getOp());
51110:         LOCAL_ASSERT(op > UNOP_ERR && op < UNOP_LIMIT);
51110: 
51110:         Value expr;
51110:         return expression(pn->pn_kid, &expr) &&
51110:                builder.unaryExpression(op, expr, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_NEW:
82024:       case PNK_LP:
51110:       {
51110: #ifdef JS_HAS_GENERATOR_EXPRS
51110:         if (pn->isGeneratorExpr())
51110:             return generatorExpression(pn->generatorExpr(), dst);
51110: #endif
51110: 
80631:         ParseNode *next = pn->pn_head;
51110: 
51110:         Value callee;
51110:         if (!expression(next, &callee))
51110:             return false;
51110: 
51110:         NodeVector args(cx);
51110:         if (!args.reserve(pn->pn_count - 1))
51110:             return false;
51110: 
51110:         for (next = next->pn_next; next; next = next->pn_next) {
51110:             Value arg;
51110:             if (!expression(next, &arg))
51110:                 return false;
64229:             args.infallibleAppend(arg);
51110:         }
51110: 
82024:         return pn->isKind(PNK_NEW)
51110:                ? builder.newExpression(callee, args, &pn->pn_pos, dst)
51110:                : builder.callExpression(callee, args, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_DOT:
51110:       {
51110:         Value expr, id;
51110:         return expression(pn->pn_expr, &expr) &&
51110:                identifier(pn->pn_atom, NULL, &id) &&
51110:                builder.memberExpression(false, expr, id, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_LB:
51110:       {
51110:         Value left, right;
51110:         return expression(pn->pn_left, &left) &&
51110:                expression(pn->pn_right, &right) &&
82018:                builder.memberExpression(true, left, right, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_RB:
51110:       {
51110:         NodeVector elts(cx);
51110:         if (!elts.reserve(pn->pn_count))
51110:             return false;
51110: 
80631:         for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
82024:             if (next->isKind(PNK_COMMA)) {
64229:                 elts.infallibleAppend(MagicValue(JS_SERIALIZE_NO_NODE));
51110:             } else {
51110:                 Value expr;
51110:                 if (!expression(next, &expr))
51110:                     return false;
64229:                 elts.infallibleAppend(expr);
51110:             }
51110:         }
51110: 
51110:         return builder.arrayExpression(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_RC:
51110:       {
80522:         /* The parser notes any uninitialized properties by setting the PNX_DESTRUCT flag. */
80522:         if (pn->pn_xflags & PNX_DESTRUCT) {
80522:             parser->reportErrorNumber(pn, JSREPORT_ERROR, JSMSG_BAD_OBJECT_INIT);
80522:             return false;
80522:         }
51110:         NodeVector elts(cx);
51110:         if (!elts.reserve(pn->pn_count))
51110:             return false;
51110: 
80631:         for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
51110:             Value prop;
51110:             if (!property(next, &prop))
51110:                 return false;
64229:             elts.infallibleAppend(prop);
51110:         }
51110: 
51110:         return builder.objectExpression(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_NAME:
51110:         return identifier(pn, dst);
51110: 
82024:       case PNK_THIS:
82022:         return builder.thisExpression(&pn->pn_pos, dst);
82022: 
82024:       case PNK_STRING:
82024:       case PNK_REGEXP:
82024:       case PNK_NUMBER:
82024:       case PNK_TRUE:
82024:       case PNK_FALSE:
82024:       case PNK_NULL:
82022:         return literal(pn, dst);
51110: 
82024:       case PNK_YIELD:
51110:       {
51110:         Value arg;
51110:         return optExpression(pn->pn_kid, &arg) &&
51110:                builder.yieldExpression(arg, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_DEFSHARP:
51110:       {
51110:         Value expr;
51110:         return expression(pn->pn_kid, &expr) &&
51110:                builder.graphExpression(pn->pn_num, expr, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_USESHARP:
51110:         return builder.graphIndexExpression(pn->pn_num, &pn->pn_pos, dst);
51110: 
82024:       case PNK_ARRAYCOMP:
51110:         /* NB: it's no longer the case that pn_count could be 2. */
51110:         LOCAL_ASSERT(pn->pn_count == 1);
82024:         LOCAL_ASSERT(pn->pn_head->isKind(PNK_LEXICALSCOPE));
51110: 
51110:         return comprehension(pn->pn_head->pn_expr, dst);
51110: 
82024:       case PNK_LEXICALSCOPE:
53593:       {
53593:         pn = pn->pn_expr;
53593: 
53593:         NodeVector dtors(cx);
53593:         Value expr;
53593: 
53593:         return letHead(pn->pn_left, dtors) &&
53593:                expression(pn->pn_right, &expr) &&
53593:                builder.letExpression(dtors, expr, &pn->pn_pos, dst);
53593:       }
53593: 
51110: #ifdef JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
82114:         JS_ASSERT(pn->isOp(JSOP_XMLNAME) ||
82114:                   pn->isOp(JSOP_SETXMLNAME) ||
82114:                   pn->isOp(JSOP_BINDXMLNAME));
82114:         return expression(pn->pn_kid, dst);
82114: 
82024:       case PNK_ANYNAME:
51110:         return builder.xmlAnyName(&pn->pn_pos, dst);
51110: 
82024:       case PNK_DBLCOLON:
51110:       {
53595:         Value right;
51110: 
78294:         LOCAL_ASSERT(pn->isArity(PN_NAME) || pn->isArity(PN_BINARY));
51110: 
80631:         ParseNode *pnleft;
53595:         bool computed;
53595: 
78294:         if (pn->isArity(PN_BINARY)) {
53595:             computed = true;
53595:             pnleft = pn->pn_left;
53595:             if (!expression(pn->pn_right, &right))
53595:                 return false;
53595:         } else {
78294:             JS_ASSERT(pn->isArity(PN_NAME));
53595:             computed = false;
53595:             pnleft = pn->pn_expr;
53595:             if (!identifier(pn->pn_atom, NULL, &right))
53595:                 return false;
53595:         }
53595: 
82024:         if (pnleft->isKind(PNK_FUNCTION))
53595:             return builder.xmlFunctionQualifiedIdentifier(right, computed, &pn->pn_pos, dst);
53595: 
53595:         Value left;
53595:         return expression(pnleft, &left) &&
53595:                builder.xmlQualifiedIdentifier(left, right, computed, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_AT:
51110:       {
51110:         Value expr;
80631:         ParseNode *kid = pn->pn_kid;
82024:         bool computed = ((!kid->isKind(PNK_NAME) || !kid->isOp(JSOP_QNAMEPART)) &&
82024:                          !kid->isKind(PNK_DBLCOLON) &&
82024:                          !kid->isKind(PNK_ANYNAME));
64202:         return expression(kid, &expr) &&
64202:             builder.xmlAttributeSelector(expr, computed, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_FILTER:
51110:       {
51110:         Value left, right;
51110:         return expression(pn->pn_left, &left) &&
51110:                expression(pn->pn_right, &right) &&
51110:                builder.xmlFilterExpression(left, right, &pn->pn_pos, dst);
51110:       }
51110: 
51110:       default:
51110:         return xml(pn, dst);
51110: 
51110: #else
51110:       default:
51110:         LOCAL_NOT_REACHED("unexpected expression type");
51110: #endif
51110:     }
51110: }
51110: 
51110: bool
80631: ASTSerializer::xml(ParseNode *pn, Value *dst)
51110: {
72088:     JS_CHECK_RECURSION(cx, return false);
78294:     switch (pn->getKind()) {
51110: #ifdef JS_HAS_XML_SUPPORT
82024:       case PNK_LC:
51110:       {
51110:         Value expr;
51110:         return expression(pn->pn_kid, &expr) &&
51110:                builder.xmlEscapeExpression(expr, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_XMLELEM:
51110:       {
51110:         NodeVector elts(cx);
51110:         if (!xmls(pn, elts))
51110:             return false;
51110:         return builder.xmlElement(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_XMLLIST:
51110:       {
51110:         NodeVector elts(cx);
51110:         if (!xmls(pn, elts))
51110:             return false;
51110:         return builder.xmlList(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_XMLSTAGO:
51110:       {
51110:         NodeVector elts(cx);
51110:         if (!xmls(pn, elts))
51110:             return false;
51110:         return builder.xmlStartTag(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_XMLETAGO:
51110:       {
51110:         NodeVector elts(cx);
51110:         if (!xmls(pn, elts))
51110:             return false;
51110:         return builder.xmlEndTag(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_XMLPTAGC:
51110:       {
51110:         NodeVector elts(cx);
51110:         if (!xmls(pn, elts))
51110:             return false;
51110:         return builder.xmlPointTag(elts, &pn->pn_pos, dst);
51110:       }
51110: 
82024:       case PNK_XMLTEXT:
82024:       case PNK_XMLSPACE:
51110:         return builder.xmlText(atomContents(pn->pn_atom), &pn->pn_pos, dst);
51110: 
82024:       case PNK_XMLNAME:
78294:         if (pn->isArity(PN_NULLARY))
51110:             return builder.xmlName(atomContents(pn->pn_atom), &pn->pn_pos, dst);
51110: 
78294:         LOCAL_ASSERT(pn->isArity(PN_LIST));
51110: 
51110:         {
51110:             NodeVector elts(cx);
51110:             return xmls(pn, elts) &&
51110:                    builder.xmlName(elts, &pn->pn_pos, dst);
51110:         }
51110: 
82024:       case PNK_XMLATTR:
51110:         return builder.xmlAttribute(atomContents(pn->pn_atom), &pn->pn_pos, dst);
51110: 
82024:       case PNK_XMLCDATA:
51110:         return builder.xmlCdata(atomContents(pn->pn_atom), &pn->pn_pos, dst);
51110: 
82024:       case PNK_XMLCOMMENT:
51110:         return builder.xmlComment(atomContents(pn->pn_atom), &pn->pn_pos, dst);
51110: 
82024:       case PNK_XMLPI:
80443:         if (!pn->pn_pidata)
80443:             return builder.xmlPI(atomContents(pn->pn_pitarget), &pn->pn_pos, dst);
51110:         else
80443:             return builder.xmlPI(atomContents(pn->pn_pitarget),
80443:                                  atomContents(pn->pn_pidata),
51110:                                  &pn->pn_pos,
51110:                                  dst);
51110: #endif
51110: 
51110:       default:
51110:         LOCAL_NOT_REACHED("unexpected XML node type");
51110:     }
51110: }
51110: 
51110: bool
80631: ASTSerializer::propertyName(ParseNode *pn, Value *dst)
51110: {
82024:     if (pn->isKind(PNK_NAME))
51110:         return identifier(pn, dst);
51110: 
82024:     LOCAL_ASSERT(pn->isKind(PNK_STRING) || pn->isKind(PNK_NUMBER));
51110: 
51110:     return literal(pn, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::property(ParseNode *pn, Value *dst)
51110: {
51110:     PropKind kind;
78294:     switch (pn->getOp()) {
51110:       case JSOP_INITPROP:
51110:         kind = PROP_INIT;
51110:         break;
51110: 
51110:       case JSOP_GETTER:
51110:         kind = PROP_GETTER;
51110:         break;
51110: 
51110:       case JSOP_SETTER:
51110:         kind = PROP_SETTER;
51110:         break;
51110: 
51110:       default:
51110:         LOCAL_NOT_REACHED("unexpected object-literal property");
51110:     }
51110: 
51110:     Value key, val;
51110:     return propertyName(pn->pn_left, &key) &&
51110:            expression(pn->pn_right, &val) &&
51110:            builder.propertyInitializer(key, val, kind, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::literal(ParseNode *pn, Value *dst)
51110: {
51110:     Value val;
78294:     switch (pn->getKind()) {
82024:       case PNK_STRING:
64345:         val.setString(pn->pn_atom);
51110:         break;
51110: 
82024:       case PNK_REGEXP:
51110:       {
51110:         JSObject *re1 = pn->pn_objbox ? pn->pn_objbox->object : NULL;
51110:         LOCAL_ASSERT(re1 && re1->isRegExp());
51110: 
51110:         JSObject *proto;
53840:         if (!js_GetClassPrototype(cx, &cx->fp()->scopeChain(), JSProto_RegExp, &proto))
51110:             return false;
51110: 
51110:         JSObject *re2 = js_CloneRegExpObject(cx, re1, proto);
51110:         if (!re2)
51110:             return false;
51110: 
51110:         val.setObject(*re2);
51110:         break;
51110:       }
51110: 
82024:       case PNK_NUMBER:
51110:         val.setNumber(pn->pn_dval);
51110:         break;
51110: 
82024:       case PNK_NULL:
51110:         val.setNull();
82022:         break;
82022: 
82024:       case PNK_TRUE:
82022:         val.setBoolean(true);
82022:         break;
82022: 
82024:       case PNK_FALSE:
82022:         val.setBoolean(false);
51110:         break;
51110: 
51110:       default:
51110:         LOCAL_NOT_REACHED("unexpected literal type");
51110:     }
51110: 
51110:     return builder.literal(val, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::arrayPattern(ParseNode *pn, VarDeclKind *pkind, Value *dst)
51110: {
82024:     JS_ASSERT(pn->isKind(PNK_RB));
51110: 
51110:     NodeVector elts(cx);
51110:     if (!elts.reserve(pn->pn_count))
51110:         return false;
51110: 
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
82024:         if (next->isKind(PNK_COMMA)) {
64229:             elts.infallibleAppend(MagicValue(JS_SERIALIZE_NO_NODE));
51110:         } else {
51110:             Value patt;
51110:             if (!pattern(next, pkind, &patt))
51110:                 return false;
64229:             elts.infallibleAppend(patt);
51110:         }
51110:     }
51110: 
51110:     return builder.arrayPattern(elts, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::objectPattern(ParseNode *pn, VarDeclKind *pkind, Value *dst)
51110: {
82024:     JS_ASSERT(pn->isKind(PNK_RC));
51110: 
51110:     NodeVector elts(cx);
51110:     if (!elts.reserve(pn->pn_count))
51110:         return false;
51110: 
80631:     for (ParseNode *next = pn->pn_head; next; next = next->pn_next) {
78294:         LOCAL_ASSERT(next->isOp(JSOP_INITPROP));
51110: 
51110:         Value key, patt, prop;
51110:         if (!propertyName(next->pn_left, &key) ||
51110:             !pattern(next->pn_right, pkind, &patt) ||
53599:             !builder.propertyPattern(key, patt, &next->pn_pos, &prop)) {
51110:             return false;
53599:         }
51110: 
64229:         elts.infallibleAppend(prop);
51110:     }
51110: 
51110:     return builder.objectPattern(elts, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::pattern(ParseNode *pn, VarDeclKind *pkind, Value *dst)
51110: {
72088:     JS_CHECK_RECURSION(cx, return false);
78294:     switch (pn->getKind()) {
82024:       case PNK_RC:
51110:         return objectPattern(pn, pkind, dst);
51110: 
82024:       case PNK_RB:
51110:         return arrayPattern(pn, pkind, dst);
51110: 
82024:       case PNK_NAME:
51110:         if (pkind && (pn->pn_dflags & PND_CONST))
51110:             *pkind = VARDECL_CONST;
51110:         /* FALL THROUGH */
51110: 
51110:       default:
51110:         return expression(pn, dst);
51110:     }
51110: }
51110: 
51110: bool
51110: ASTSerializer::identifier(JSAtom *atom, TokenPos *pos, Value *dst)
51110: {
51110:     return builder.identifier(atomContents(atom), pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::identifier(ParseNode *pn, Value *dst)
51110: {
78294:     LOCAL_ASSERT(pn->isArity(PN_NAME) || pn->isArity(PN_NULLARY));
51110:     LOCAL_ASSERT(pn->pn_atom);
51110: 
51110:     return identifier(pn->pn_atom, &pn->pn_pos, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::function(ParseNode *pn, ASTType type, Value *dst)
51110: {
51110:     JSFunction *func = (JSFunction *)pn->pn_funbox->object;
51110: 
51110:     bool isGenerator =
51110: #ifdef JS_HAS_GENERATORS
51110:         pn->pn_funbox->tcflags & TCF_FUN_IS_GENERATOR;
51110: #else
51110:         false;
51110: #endif
51110: 
51110:     bool isExpression =
51110: #ifdef JS_HAS_EXPR_CLOSURES
51110:         func->flags & JSFUN_EXPR_CLOSURE;
51110: #else
51110:         false;
51110: #endif
51110: 
51110:     Value id;
51110:     if (!optIdentifier(func->atom, NULL, &id))
51110:         return false;
51110: 
51110:     NodeVector args(cx);
51110: 
82024:     ParseNode *argsAndBody = pn->pn_body->isKind(PNK_UPVARS)
51110:                              ? pn->pn_body->pn_tree
51110:                              : pn->pn_body;
51110: 
51110:     Value body;
51110:     return functionArgsAndBody(argsAndBody, args, &body) &&
51110:            builder.function(type, &pn->pn_pos, id, args, body, isGenerator, isExpression, dst);
51110: }
51110: 
51110: bool
80631: ASTSerializer::functionArgsAndBody(ParseNode *pn, NodeVector &args, Value *body)
51110: {
80631:     ParseNode *pnargs;
80631:     ParseNode *pnbody;
51110: 
51110:     /* Extract the args and body separately. */
82024:     if (pn->isKind(PNK_ARGSBODY)) {
51110:         pnargs = pn;
51110:         pnbody = pn->last();
51110:     } else {
51110:         pnargs = NULL;
51110:         pnbody = pn;
51110:     }
51110: 
80631:     ParseNode *pndestruct;
51110: 
51110:     /* Extract the destructuring assignments. */
78294:     if (pnbody->isArity(PN_LIST) && (pnbody->pn_xflags & PNX_DESTRUCT)) {
80631:         ParseNode *head = pnbody->pn_head;
82024:         LOCAL_ASSERT(head && head->isKind(PNK_SEMI));
51110: 
51110:         pndestruct = head->pn_kid;
82024:         LOCAL_ASSERT(pndestruct && pndestruct->isKind(PNK_VAR));
51110:     } else {
51110:         pndestruct = NULL;
51110:     }
51110: 
51110:     /* Serialize the arguments and body. */
78294:     switch (pnbody->getKind()) {
82024:       case PNK_RETURN: /* expression closure, no destructured args */
51110:         return functionArgs(pn, pnargs, NULL, pnbody, args) &&
51110:                expression(pnbody->pn_kid, body);
51110: 
82024:       case PNK_SEQ:    /* expression closure with destructured args */
51110:       {
80631:         ParseNode *pnstart = pnbody->pn_head->pn_next;
82024:         LOCAL_ASSERT(pnstart && pnstart->isKind(PNK_RETURN));
51110: 
51110:         return functionArgs(pn, pnargs, pndestruct, pnbody, args) &&
51110:                expression(pnstart->pn_kid, body);
51110:       }
51110: 
82024:       case PNK_LC:     /* statement closure */
51110:       {
80631:         ParseNode *pnstart = (pnbody->pn_xflags & PNX_DESTRUCT)
51110:                                ? pnbody->pn_head->pn_next
51110:                                : pnbody->pn_head;
51110: 
51110:         return functionArgs(pn, pnargs, pndestruct, pnbody, args) &&
51110:                functionBody(pnstart, &pnbody->pn_pos, body);
51110:       }
51110: 
51110:       default:
51110:         LOCAL_NOT_REACHED("unexpected function contents");
51110:     }
51110: }
51110: 
51110: bool
80631: ASTSerializer::functionArgs(ParseNode *pn, ParseNode *pnargs, ParseNode *pndestruct,
80631:                             ParseNode *pnbody, NodeVector &args)
51110: {
56211:     uint32 i = 0;
80631:     ParseNode *arg = pnargs ? pnargs->pn_head : NULL;
80631:     ParseNode *destruct = pndestruct ? pndestruct->pn_head : NULL;
51110:     Value node;
51110: 
51110:     /*
51110:      * Arguments are found in potentially two different places: 1) the
51110:      * argsbody sequence (which ends with the body node), or 2) a
51110:      * destructuring initialization at the beginning of the body. Loop
51110:      * |arg| through the argsbody and |destruct| through the initial
51110:      * destructuring assignments, stopping only when we've exhausted
51110:      * both.
51110:      */
51110:     while ((arg && arg != pnbody) || destruct) {
53599:         if (destruct && destruct->pn_right->frameSlot() == i) {
53599:             if (!pattern(destruct->pn_left, NULL, &node) || !args.append(node))
53599:                 return false;
53599:             destruct = destruct->pn_next;
53599:         } else if (arg && arg != pnbody) {
53599:             /*
53599:              * We don't check that arg->frameSlot() == i since we
53599:              * can't call that method if the arg def has been turned
53599:              * into a use, e.g.:
53599:              *
53599:              *     function(a) { function a() { } }
53599:              *
53599:              * There's no other way to ask a non-destructuring arg its
53599:              * index in the formals list, so we rely on the ability to
53599:              * ask destructuring args their index above.
53599:              */
53599:             if (!identifier(arg, &node) || !args.append(node))
51110:                 return false;
51110:             arg = arg->pn_next;
51110:         } else {
51110:             LOCAL_NOT_REACHED("missing function argument");
51110:         }
51110:         ++i;
51110:     }
51110: 
51110:     return true;
51110: }
51110: 
51110: bool
80631: ASTSerializer::functionBody(ParseNode *pn, TokenPos *pos, Value *dst)
51110: {
51110:     NodeVector elts(cx);
51110: 
51110:     /* We aren't sure how many elements there are up front, so we'll check each append. */
80631:     for (ParseNode *next = pn; next; next = next->pn_next) {
51110:         Value child;
53599:         if (!sourceElement(next, &child) || !elts.append(child))
51110:             return false;
51110:     }
51110: 
51110:     return builder.blockStatement(elts, pos, dst);
51110: }
51110: 
51110: } /* namespace js */
51110: 
51110: static JSBool
56211: reflect_parse(JSContext *cx, uint32 argc, jsval *vp)
51110: {
51110:     if (argc < 1) {
51110:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
51110:                              "Reflect.parse", "0", "s");
51110:         return JS_FALSE;
51110:     }
51110: 
78614:     JSString *src = js_ValueToString(cx, JS_ARGV(cx, vp)[0]);
51110:     if (!src)
51110:         return JS_FALSE;
51110: 
56211:     char *filename = NULL;
56211:     AutoReleaseNullablePtr filenamep(cx, filename);
56211:     uint32 lineno = 1;
56211:     bool loc = true;
56211: 
60150:     JSObject *builder = NULL;
60150: 
78614:     Value arg = argc > 1 ? JS_ARGV(cx, vp)[1] : UndefinedValue();
60150: 
60150:     if (!arg.isNullOrUndefined()) {
56211:         if (!arg.isObject()) {
56211:             js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_UNEXPECTED_TYPE,
56211:                                      JSDVG_SEARCH_STACK, arg, NULL, "not an object", NULL);
56211:             return JS_FALSE;
56211:         }
56211: 
56211:         JSObject *config = &arg.toObject();
56211: 
56211:         Value prop;
56211: 
56211:         /* config.loc */
56211:         if (!GetPropertyDefault(cx, config, ATOM_TO_JSID(cx->runtime->atomState.locAtom),
56211:                                 BooleanValue(true), &prop)) {
56211:             return JS_FALSE;
56211:         }
56211: 
56211:         loc = js_ValueToBoolean(prop);
56211: 
56211:         if (loc) {
56211:             /* config.source */
56211:             if (!GetPropertyDefault(cx, config, ATOM_TO_JSID(cx->runtime->atomState.sourceAtom),
56211:                                     NullValue(), &prop)) {
56211:                 return JS_FALSE;
56211:             }
56211: 
56211:             if (!prop.isNullOrUndefined()) {
56211:                 JSString *str = js_ValueToString(cx, prop);
51110:                 if (!str)
51110:                     return JS_FALSE;
56211: 
59890:                 size_t length = str->length();
59890:                 const jschar *chars = str->getChars(cx);
59890:                 if (!chars)
59890:                     return JS_FALSE;
59890: 
71337:                 filename = DeflateString(cx, chars, length);
56211:                 if (!filename)
56211:                     return JS_FALSE;
56211:                 filenamep.reset(filename);
51110:             }
51110: 
56211:             /* config.line */
56211:             if (!GetPropertyDefault(cx, config, ATOM_TO_JSID(cx->runtime->atomState.lineAtom),
56211:                                     Int32Value(1), &prop) ||
56211:                 !ValueToECMAUint32(cx, prop, &lineno)) {
51110:                 return JS_FALSE;
51110:             }
56211:         }
60150: 
60150:         /* config.builder */
60150:         if (!GetPropertyDefault(cx, config, ATOM_TO_JSID(cx->runtime->atomState.builderAtom),
60150:                                 NullValue(), &prop)) {
60150:             return JS_FALSE;
56211:         }
51110: 
60150:         if (!prop.isNullOrUndefined()) {
60150:             if (!prop.isObject()) {
60150:                 js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_UNEXPECTED_TYPE,
60150:                                          JSDVG_SEARCH_STACK, prop, NULL, "not an object", NULL);
60150:                 return JS_FALSE;
60150:             }
60150:             builder = &prop.toObject();
60150:         }
60150:     }
60150: 
60150:     /* Extract the builder methods first to report errors before parsing. */
60150:     ASTSerializer serialize(cx, loc, filename, lineno);
60150:     if (!serialize.init(builder))
60150:         return JS_FALSE;
60150: 
59890:     size_t length = src->length();
59890:     const jschar *chars = src->getChars(cx);
59890:     if (!chars)
59890:         return JS_FALSE;
51110: 
72098:     Parser parser(cx, NULL, NULL, false);
51110: 
61450:     if (!parser.init(chars, length, filename, lineno, cx->findVersion()))
51110:         return JS_FALSE;
51110: 
80522:     serialize.setParser(&parser);
80522: 
80631:     ParseNode *pn = parser.parse(NULL);
51110:     if (!pn)
51110:         return JS_FALSE;
51110: 
51110:     Value val;
51110:     if (!serialize.program(pn, &val)) {
51110:         JS_SET_RVAL(cx, vp, JSVAL_NULL);
51110:         return JS_FALSE;
51110:     }
51110: 
78614:     JS_SET_RVAL(cx, vp, val);
51110:     return JS_TRUE;
51110: }
51110: 
51110: static JSFunctionSpec static_methods[] = {
51110:     JS_FN("parse", reflect_parse, 1, 0),
51110:     JS_FS_END
51110: };
51110: 
51110: 
73063: JS_BEGIN_EXTERN_C
73063: 
73063: JS_PUBLIC_API(JSObject *)
73063: JS_InitReflect(JSContext *cx, JSObject *obj)
51110: {
77817:     JSObject *Reflect = NewNonFunction<WithProto::Class>(cx, &ObjectClass, NULL, obj);
77353:     if (!Reflect || !Reflect->setSingletonType(cx))
51110:         return NULL;
51110: 
73063:     if (!JS_DefineProperty(cx, obj, "Reflect", OBJECT_TO_JSVAL(Reflect),
62395:                            JS_PropertyStub, JS_StrictPropertyStub, 0)) {
51110:         return NULL;
53599:     }
51110: 
51110:     if (!JS_DefineFunctions(cx, Reflect, static_methods))
51110:         return NULL;
51110: 
51110:     return Reflect;
51110: }
73063: 
73063: JS_END_EXTERN_C
