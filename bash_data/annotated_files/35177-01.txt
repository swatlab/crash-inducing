    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
 6698:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
 6698: #include "nsPopupSetFrame.h"
    1: #include "nsGkAtoms.h"
 6698: #include "nsCOMPtr.h"
    1: #include "nsIContent.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsIRootBox.h"
    1: 
    1: nsPopupFrameList::nsPopupFrameList(nsIContent* aPopupContent, nsPopupFrameList* aNext)
    1: :mNextPopup(aNext), 
    1:  mPopupFrame(nsnull),
 3129:  mPopupContent(aPopupContent)
    1: {
    1: }
    1: 
    1: //
    1: // NS_NewPopupSetFrame
    1: //
    1: // Wrapper for creating a new menu popup container
    1: //
    1: nsIFrame*
    1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsPopupSetFrame (aPresShell, aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsPopupSetFrame)
32423: 
    1: NS_IMETHODIMP
    1: nsPopupSetFrame::Init(nsIContent*      aContent,
    1:                       nsIFrame*        aParent,
    1:                       nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult  rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
    1: 
22859:   // Normally the root box is our grandparent, but in case of wrapping
22859:   // it can be our great-grandparent.
22859:   nsIRootBox *rootBox = nsIRootBox::GetRootBox(PresContext()->GetPresShell());
22859:   if (rootBox) {
    1:     rootBox->SetPopupSetFrame(this);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 6698: nsIAtom*
 6698: nsPopupSetFrame::GetType() const
 6698: {
 6698:   return nsGkAtoms::popupSetFrame;
 6698: }
 6698: 
    1: NS_IMETHODIMP
    1: nsPopupSetFrame::AppendFrames(nsIAtom*        aListName,
30941:                               nsFrameList&    aFrameList)
    1: {
    1:   if (aListName == nsGkAtoms::popupList) {
30941:     return AddPopupFrameList(aFrameList);
    1:   }
    1:   return nsBoxFrame::AppendFrames(aListName, aFrameList);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPopupSetFrame::RemoveFrame(nsIAtom*        aListName,
    1:                              nsIFrame*       aOldFrame)
    1: {
    1:   if (aListName == nsGkAtoms::popupList) {
    1:     return RemovePopupFrame(aOldFrame);
    1:   }
    1:   return nsBoxFrame::RemoveFrame(aListName, aOldFrame);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPopupSetFrame::InsertFrames(nsIAtom*        aListName,
    1:                               nsIFrame*       aPrevFrame,
30941:                               nsFrameList&    aFrameList)
    1: {
    1:   if (aListName == nsGkAtoms::popupList) {
30941:     return AddPopupFrameList(aFrameList);
    1:   }
    1:   return nsBoxFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPopupSetFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                      nsFrameList&    aChildList)
    1: {
    1:   if (aListName == nsGkAtoms::popupList) {
    1:     return AddPopupFrameList(aChildList);
    1:   }
    1:   return nsBoxFrame::SetInitialChildList(aListName, aChildList);
    1: }
    1: 
    1: void
    1: nsPopupSetFrame::Destroy()
    1: {
 3129:   // remove each popup from the list as we go.
    1:   while (mPopupList) {
 7113:     if (mPopupList->mPopupFrame) {
 7113:       mPopupList->mPopupFrame->Destroy();
 7113:     }
    1:     nsPopupFrameList* temp = mPopupList;
    1:     mPopupList = mPopupList->mNextPopup;
    1:     delete temp;
    1:   }
    1: 
22859:   // Normally the root box is our grandparent, but in case of wrapping
22859:   // it can be our great-grandparent.
22859:   nsIRootBox *rootBox = nsIRootBox::GetRootBox(PresContext()->GetPresShell());
22859:   if (rootBox) {
    1:     rootBox->SetPopupSetFrame(nsnull);
    1:   }
    1: 
    1:   nsBoxFrame::Destroy();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPopupSetFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   // lay us out
    1:   nsresult rv = nsBoxFrame::DoLayout(aState);
    1: 
    1:   // lay out all of our currently open popups.
    1:   nsPopupFrameList* currEntry = mPopupList;
    1:   while (currEntry) {
 3129:     nsMenuPopupFrame* popupChild = currEntry->mPopupFrame;
 3129:     if (popupChild && popupChild->IsOpen()) {
    1:       // then get its preferred size
    1:       nsSize prefSize = popupChild->GetPrefSize(aState);
    1:       nsSize minSize = popupChild->GetMinSize(aState);
    1:       nsSize maxSize = popupChild->GetMaxSize(aState);
    1: 
 9862:       prefSize = BoundsCheck(minSize, prefSize, maxSize);
    1: 
 9482:       popupChild->SetPreferredBounds(aState, nsRect(0,0,prefSize.width, prefSize.height));
 3129:       popupChild->SetPopupPosition(nsnull);
    1: 
    1:       // is the new size too small? Make sure we handle scrollbars correctly
    1:       nsIBox* child = popupChild->GetChildBox();
    1: 
    1:       nsRect bounds(popupChild->GetRect());
    1: 
23554:       nsIScrollableFrame *scrollframe = do_QueryFrame(child);
    1:       if (scrollframe &&
    1:           scrollframe->GetScrollbarStyles().mVertical == NS_STYLE_OVERFLOW_AUTO) {
    1:         // if our pref height
    1:         if (bounds.height < prefSize.height) {
    1:           // layout the child
    1:           popupChild->Layout(aState);
    1: 
    1:           nsMargin scrollbars = scrollframe->GetActualScrollbarSizes();
    1:           if (bounds.width < prefSize.width + scrollbars.left + scrollbars.right)
    1:           {
    1:             bounds.width += scrollbars.left + scrollbars.right;
    1:             popupChild->SetBounds(aState, bounds);
    1:           }
    1:         }
    1:       }
    1: 
    1:       // layout the child
    1:       popupChild->Layout(aState);
 4870:       // if the width or height changed, readjust the popup position. This is a
 4870:       // special case for tooltips where the preferred height doesn't include the
 4870:       // real height for its inline element, but does once it is laid out.
 4870:       // This is bug 228673 which doesn't have a simple fix.
 4870:       if (popupChild->GetRect().width > bounds.width ||
 9482:           popupChild->GetRect().height > bounds.height) {
 9482:         // the size after layout was larger than the preferred size,
 9482:         // so set the preferred size accordingly
 9482:         popupChild->SetPreferredSize(popupChild->GetSize());
 4870:         popupChild->SetPopupPosition(nsnull);
 9482:       }
 3129:       popupChild->AdjustView();
    1:     }
    1: 
    1:     currEntry = currEntry->mNextPopup;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsPopupSetFrame::RemovePopupFrame(nsIFrame* aPopup)
    1: {
    1:   // This was called by the Destroy() method of the popup, so all we have to do is
    1:   // get the popup out of our list, so we don't reflow it later.
 7113: #ifdef DEBUG
 7113:   PRBool found = PR_FALSE;
 7113: #endif
    1:   nsPopupFrameList* currEntry = mPopupList;
    1:   nsPopupFrameList* temp = nsnull;
    1:   while (currEntry) {
    1:     if (currEntry->mPopupFrame == aPopup) {
    1:       // Remove this entry.
    1:       if (temp)
    1:         temp->mNextPopup = currEntry->mNextPopup;
    1:       else
    1:         mPopupList = currEntry->mNextPopup;
    1:       
 7113:       NS_ASSERTION((aPopup->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
 7113:                    aPopup->GetType() == nsGkAtoms::menuPopupFrame,
 7113:                    "found wrong type of frame in popupset's ::popupList");
    1:       // Destroy the frame.
 7113:       currEntry->mPopupFrame->Destroy();
    1: 
    1:       // Delete the entry.
    1:       currEntry->mNextPopup = nsnull;
    1:       delete currEntry;
 7113: #ifdef DEBUG
 7113:       found = PR_TRUE;
 7113: #endif
    1: 
    1:       // Break out of the loop.
    1:       break;
    1:     }
    1: 
    1:     temp = currEntry;
    1:     currEntry = currEntry->mNextPopup;
    1:   }
    1: 
 7113:   NS_ASSERTION(found, "frame to remove is not in our ::popupList");
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
30790: nsPopupSetFrame::AddPopupFrameList(nsFrameList& aPopupFrameList)
    1: {
35177:   while (!aPopupFrameList.IsEmpty()) {
35177:     nsIFrame* f = aPopupFrameList.FirstChild();
35177:     // Clears out prev/next sibling points appropriately. Every frame
35177:     // in our popup list has null next and prev pointers, they're logically
35177:     // each in their own list.
35177:     aPopupFrameList.RemoveFrame(f);
35177:     nsresult rv = AddPopupFrame(f);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPopupSetFrame::AddPopupFrame(nsIFrame* aPopup)
    1: {
 7113:   NS_ASSERTION((aPopup->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
 7113:                aPopup->GetType() == nsGkAtoms::menuPopupFrame,
 7113:                "adding wrong type of frame in popupset's ::popupList");
 3129: 
    1:   // The entry should already exist, but might not (if someone decided to make their
    1:   // popup visible straightaway, e.g., the autocomplete widget).
    1:   // First look for an entry by content.
    1:   nsIContent* content = aPopup->GetContent();
 3129:   nsPopupFrameList* entry = mPopupList;
 3129:   while (entry && entry->mPopupContent != content)
 3129:     entry = entry->mNextPopup;
    1:   if (!entry) {
    1:     entry = new nsPopupFrameList(content, mPopupList);
    1:     if (!entry)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     mPopupList = entry;
    1:   }
    1:   else {
    1:     NS_ASSERTION(!entry->mPopupFrame, "Leaking a popup frame");
    1:   }
    1: 
    1:   // Set the frame connection.
 3233:   entry->mPopupFrame = static_cast<nsMenuPopupFrame *>(aPopup);
    1:   
    1:   return NS_OK;
    1: }
 6698: 
 7113: #ifdef DEBUG
 7113: NS_IMETHODIMP
 7113: nsPopupSetFrame::List(FILE* out, PRInt32 aIndent) const
 6698: {
 7113:   IndentBy(out, aIndent);
 7113:   ListTag(out);
 7113: #ifdef DEBUG_waterson
 7113:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
 7113: #endif
 7113:   if (HasView()) {
 7113:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
 6698:   }
32845:   if (GetNextSibling()) {
32845:     fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
 7113:   }
 7113:   if (nsnull != GetPrevContinuation()) {
 7113:     fprintf(out, " prev-continuation=%p", static_cast<void*>(GetPrevContinuation()));
 7113:   }
 7113:   if (nsnull != GetNextContinuation()) {
 7113:     fprintf(out, " next-continuation=%p", static_cast<void*>(GetNextContinuation()));
 7113:   }
 7113:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
 7113:   if (0 != mState) {
 7113:     fprintf(out, " [state=%08x]", mState);
 7113:   }
 7113:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
 7113:   nsPopupSetFrame* f = const_cast<nsPopupSetFrame*>(this);
26950:   if (f->HasOverflowRect()) {
11909:     nsRect overflowArea = f->GetOverflowRect();
11909:     fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
11909:             overflowArea.width, overflowArea.height);
 7113:   }
 7113:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
34387:   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
 7113:   if (pseudoTag) {
 7113:     nsAutoString atomString;
 7113:     pseudoTag->ToString(atomString);
 7113:     fprintf(out, " pst=%s",
 7113:             NS_LossyConvertUTF16toASCII(atomString).get());
 7113:   }
 7113: 
 7113:   // Output the children
 7113:   nsIAtom* listName = nsnull;
 7113:   PRInt32 listIndex = 0;
 7113:   PRBool outputOneList = PR_FALSE;
 7113:   do {
 7113:     nsIFrame* kid = GetFirstChild(listName);
 7113:     if (nsnull != kid) {
 7113:       if (outputOneList) {
 7113:         IndentBy(out, aIndent);
 7113:       }
 7113:       outputOneList = PR_TRUE;
 7113:       nsAutoString tmp;
 7113:       if (nsnull != listName) {
 7113:         listName->ToString(tmp);
 7113:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
 7113:       }
 7113:       fputs("<\n", out);
 7113:       while (nsnull != kid) {
 7113:         // Verify the child frame's parent frame pointer is correct
 7113:         NS_ASSERTION(kid->GetParent() == (nsIFrame*)this, "bad parent frame pointer");
 7113: 
 7113:         // Have the child frame list
31709:         kid->List(out, aIndent + 1);
 7113:         kid = kid->GetNextSibling();
 7113:       }
 7113:       IndentBy(out, aIndent);
 7113:       fputs(">\n", out);
 7113:     }
 7113:     listName = GetAdditionalChildListName(listIndex++);
 7113:   } while(nsnull != listName);
 7113: 
 7113:   // XXXmats the above is copy-pasted from nsContainerFrame::List which is lame,
 7113:   // clean this up after bug 399111 is implemented.
 7113: 
 7113:   if (mPopupList) {
 7113:     fputs("<\n", out);
 7113:     ++aIndent;
 7113:     IndentBy(out, aIndent);
 7113:     nsAutoString tmp;
 7113:     nsGkAtoms::popupList->ToString(tmp);
 7113:     fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
 7113:     fputs(" for ", out);
 7113:     ListTag(out);
 7113:     fputs(" <\n", out);
 7113:     ++aIndent;
 7113:     for (nsPopupFrameList* l = mPopupList; l; l = l->mNextPopup) {
31709:       l->mPopupFrame->List(out, aIndent);
 7113:     }
 7113:     --aIndent;
 7113:     IndentBy(out, aIndent);
 7113:     fputs(">\n", out);
 7113:     --aIndent;
 7113:     IndentBy(out, aIndent);
 7113:     fputs(">\n", out);
 7113:     outputOneList = PR_TRUE;
 7113:   }
 7113: 
 7113:   if (!outputOneList) {
 7113:     fputs("<>\n", out);
 7113:   }
 7113: 
 7113:   return NS_OK;
 7113: }
 7113: #endif
