   1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Blake Ross <blaker@netscape.com>
   1:  *   Ben Goodger <ben@netscape.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: // Keeps track of ongoing downloads, in the form of nsIDownload's. 
   1: 
   1: #include "nsISupports.idl"
   1: 
   1: interface nsIURI;
   1: interface nsILocalFile;
   1: interface nsIDownload;
   1: interface nsICancelable;
   1: interface nsIMIMEInfo;
   1: interface nsIDownloadProgressListener;
1691: interface nsISimpleEnumerator;
1691: interface mozIStorageConnection;
   1: 
5352: [scriptable, uuid(05ed1d45-0aff-4ba0-9e2c-a9ef20383048)]
   1: interface nsIDownloadManager : nsISupports {
   1:   // Download States
   1:   const short DOWNLOAD_NOTSTARTED       = -1;
   1:   const short DOWNLOAD_DOWNLOADING      = 0;
   1:   const short DOWNLOAD_FINISHED         = 1;
   1:   const short DOWNLOAD_FAILED           = 2;
   1:   const short DOWNLOAD_CANCELED         = 3;
   1:   const short DOWNLOAD_PAUSED           = 4;
5176:   const short DOWNLOAD_QUEUED           = 5;
4862:   const short DOWNLOAD_BLOCKED          = 6;
5176:   const short DOWNLOAD_SCANNING         = 7;
   1: 
   1:   const short DOWNLOAD_TYPE_DOWNLOAD    = 0;
   1: 
   1:   /**
   1:    * Creates an nsIDownload and adds it to be managed by the download manager.
   1:    *
   1:    * @param aSource The source URI of the transfer. Must not be null.
   1:    *
   1:    * @param aTarget The target URI of the transfer. Must not be null.
   1:    *
   1:    * @param aDisplayName The user-readable description of the transfer.
   1:    *                     Can be empty.
   1:    *
   1:    * @param aMIMEInfo The MIME info associated with the target,
   1:    *                  including MIME type and helper app when appropriate.
   1:    *                  This parameter is optional.
   1:    *
   1:    * @param startTime Time when the download started
   1:    *
   1:    * @param aTempFile The location of a temporary file; i.e. a file in which
   1:    *                  the received data will be stored, but which is not
   1:    *                  equal to the target file. (will be moved to the real
   1:    *                  target by the caller, when the download is finished)
   1:    *                  May be null.
   1:    *
   1:    * @param aCancelable An object that can be used to abort the download.
   1:    *                    Must not be null.
   1:    *
   1:    * @return The newly created download item with the passed-in properties.
1691:    *
1691:    * @note This does not actually start a download.  If you want to add and
1691:    *       start a download, you need to create an nsIWebBrowserPersist, pass it
1691:    *       as the aCancelable object, call this method, set the progressListener
1691:    *       as the returned download object, then call saveURI.
   1:    */
   1:   nsIDownload addDownload(in short aDownloadType, 
   1:                           in nsIURI aSource,
   1:                           in nsIURI aTarget,
   1:                           in AString aDisplayName,
   1:                           in nsIMIMEInfo aMIMEInfo,
   1:                           in PRTime aStartTime,
   1:                           in nsILocalFile aTempFile,
   1:                           in nsICancelable aCancelable);
   1: 
   1:   /**
2330:    * Retrieves a download managed by the download manager.  This can be one that
2330:    * is in progress, or one that has completed in the past and is stored in the
2330:    * database.
   1:    *
1691:    * @param aID The unique ID of the download.
1691:    * @return The download with the specified ID.
2330:    * @throws NS_ERROR_NOT_AVAILABLE if the download is not in the database.
   1:    */
1691:   nsIDownload getDownload(in unsigned long aID);
   1: 
   1:   /**
1691:    * Cancels the download with the specified ID if it's currently in-progress.
1691:    * This calls cancel(NS_BINDING_ABORTED) on the nsICancelable provided by the
1691:    * download.
   1:    *
1691:    * @param aID The unique ID of the download.
1691:    * @throws NS_ERROR_FAILURE if the download is not in-progress.
   1:    */
1691:   void cancelDownload(in unsigned long aID);
   1: 
   1:   /**
1691:    * Removes the download with the specified id if it's not currently
1691:    * in-progress.  Whereas cancelDownload simply cancels the transfer, but
1691:    * retains information about it, removeDownload removes all knowledge of it.
   1:    *
1691:    * @param aID The unique ID of the download.
1691:    * @throws NS_ERROR_FAILURE if the download is active.
   1:    */
1691:   void removeDownload(in unsigned long aID);
   1: 
   1:   /**
   1:    * Pause the specified download.
1691:    *
1691:    * @param aID The unique ID of the download.
1691:    * @throws NS_ERROR_FAILURE if the download is not in-progress.
   1:    */
1691:   void pauseDownload(in unsigned long aID);
   1: 
   1:   /**
   1:    * Resume the specified download.
1691:    *
1691:    * @param aID The unique ID of the download.
1691:    * @throws NS_ERROR_FAILURE if the download is not in-progress.
   1:    */
1691:   void resumeDownload(in unsigned long aID);
   1: 
   1:   /**
2116:    * Retries a failed download.
2116:    *
2116:    * @param aID The unique ID of the download.
2116:    * @throws NS_ERROR_NOT_AVAILALE if the download id is not known.
2116:    * @throws NS_ERROR_FAILURE if the download is not in the following states:
2116:    *           nsIDownloadManager::DOWNLOAD_CANCELED
2116:    *           nsIDownloadManager::DOWNLOAD_FAILED
2116:    */
2116:   void retryDownload(in unsigned long aID);
2116: 
2116:   /**
1691:    * The database connection to the downloads database.
1691:    */
1691:   readonly attribute mozIStorageConnection DBConnection;
   1: 
   1:   /** 
   1:    * Whether or not there are downloads that can be cleaned up (removed)
   1:    * i.e. downloads that have completed, have failed or have been canceled. 
   1:    */
   1:   readonly attribute boolean canCleanUp;
   1: 
   1:   /** 
   1:    * Removes completed, failed, and canceled downloads from the list. 
   1:    */
   1:   void cleanUp();
   1: 
   1:   /** 
   1:    * The number of files currently being downloaded.
   1:    */
   1:   readonly attribute long activeDownloadCount;
   1: 
   1:   /**
1691:    * An enumeration of active nsIDownloads
   1:    */
1691:   readonly attribute nsISimpleEnumerator activeDownloads;
1877: 
1877:   /**
1877:    * Adds a listener from the download manager.
1877:    */
1877:   void addListener(in nsIDownloadProgressListener aListener);
1877: 
1877:   /**
1877:    * Removes a listener from the download manager.
1877:    */
1877:   void removeListener(in nsIDownloadProgressListener aListener);
4867: 
4867:   /**
4867:    * Returns the platform default downloads directory.
4867:    */
4867:   readonly attribute nsILocalFile defaultDownloadsDirectory;
4867: 
4867:   /**
4867:    * Returns the user configured downloads directory. 
4867:    * The path is dependent on two user configurable prefs
4867:    * set in preferences:
4867:    *
4867:    * browser.download.folderList
4867:    *   Indicates the location users wish to save downloaded 
4867:    *   files too.  
4867:    *   Values: 
4867:    *     0 - The desktop is the default download location. 
4867:    *     1 - The system's downloads folder is the default download location. 
4867:    *     2 - The default download location is elsewhere as specified in  
4867:    *         browser.download.dir. If invalid, userDownloadsDirectory
4867:    *         will fallback on defaultDownloadsDirectory.
4867:    *
4867:    * browser.download.dir - 
4867:    *   A local path the user may have selected at some point 
4867:    *   where downloaded files are saved. The use of which is
4867:    *   enabled when folderList equals 2. 
4867:    */
4867:   readonly attribute nsILocalFile userDownloadsDirectory;
   1: };
   1: 
   1: 
