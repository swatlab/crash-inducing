     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 56318: #include "IPC/IPCMessageUtils.h"
 56318: 
     1: #if defined(XP_UNIX) || defined(XP_BEOS)
     1: #include <unistd.h>
     1: #elif defined(XP_WIN)
     1: #include <windows.h>
     1: #elif defined(XP_OS2)
     1: #define INCL_DOSERRORS
     1: #include <os2.h>
     1: #else
     1: // XXX add necessary include file for ftruncate (or equivalent)
     1: #endif
     1: 
     1: #include "private/pprio.h"
     1: 
     1: #include "nsFileStreams.h"
     1: #include "nsXPIDLString.h"
     1: #include "prerror.h"
     1: #include "nsCRT.h"
     1: #include "nsIFile.h"
     1: #include "nsDirectoryIndexStream.h"
     1: #include "nsMimeTypes.h"
     1: #include "nsReadLine.h"
     1: #include "nsNetUtil.h"
 56318: #include "nsIClassInfoImpl.h"
     1: 
     1: #define NS_NO_INPUT_BUFFERING 1 // see http://bugzilla.mozilla.org/show_bug.cgi?id=41067
     1: 
     1: ////////////////////////////////////////////////////////////////////////////////
 99069: // nsFileStreamBase
     1: 
 99069: nsFileStreamBase::nsFileStreamBase()
     1:     : mFD(nsnull)
 63331:     , mBehaviorFlags(0)
 63331:     , mDeferredOpen(false)
     1: {
     1: }
     1: 
 99069: nsFileStreamBase::~nsFileStreamBase()
     1: {
     1:     Close();
     1: }
     1: 
 99069: NS_IMPL_THREADSAFE_ISUPPORTS1(nsFileStreamBase, nsISeekableStream)
     1: 
     1: NS_IMETHODIMP
 99069: nsFileStreamBase::Seek(PRInt32 whence, PRInt64 offset)
     1: {
 63331:     nsresult rv = DoPendingOpen();
 63331:     NS_ENSURE_SUCCESS(rv, rv);
 63331: 
     1:     if (mFD == nsnull)
     1:         return NS_BASE_STREAM_CLOSED;
     1: 
 64617:     PRInt64 cnt = PR_Seek64(mFD, offset, (PRSeekWhence)whence);
 64617:     if (cnt == PRInt64(-1)) {
     1:         return NS_ErrorAccordingToNSPR();
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 99069: nsFileStreamBase::Tell(PRInt64 *result)
     1: {
 63331:     nsresult rv = DoPendingOpen();
 63331:     NS_ENSURE_SUCCESS(rv, rv);
 63331: 
     1:     if (mFD == nsnull)
     1:         return NS_BASE_STREAM_CLOSED;
     1: 
 64617:     PRInt64 cnt = PR_Seek64(mFD, 0, PR_SEEK_CUR);
 64617:     if (cnt == PRInt64(-1)) {
     1:         return NS_ErrorAccordingToNSPR();
     1:     }
     1:     *result = cnt;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 99069: nsFileStreamBase::SetEOF()
     1: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
     1:     if (mFD == nsnull)
     1:         return NS_BASE_STREAM_CLOSED;
     1: 
     1: #if defined(XP_UNIX) || defined(XP_OS2) || defined(XP_BEOS)
     1:     // Some system calls require an EOF offset.
     1:     PRInt64 offset;
 99069:     rv = Tell(&offset);
     1:     if (NS_FAILED(rv)) return rv;
     1: #endif
     1: 
     1: #if defined(XP_UNIX) || defined(XP_BEOS)
     1:     if (ftruncate(PR_FileDesc2NativeHandle(mFD), offset) != 0) {
     1:         NS_ERROR("ftruncate failed");
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: #elif defined(XP_WIN)
     1:     if (!SetEndOfFile((HANDLE) PR_FileDesc2NativeHandle(mFD))) {
     1:         NS_ERROR("SetEndOfFile failed");
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: #elif defined(XP_OS2)
     1:     if (DosSetFileSize((HFILE) PR_FileDesc2NativeHandle(mFD), offset) != NO_ERROR) {
     1:         NS_ERROR("DosSetFileSize failed");
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: #else
     1:     // XXX not implemented
     1: #endif
     1: 
     1:     return NS_OK;
     1: }
     1: 
 63331: nsresult
 99069: nsFileStreamBase::Close()
 99069: {
 99069:     CleanUpOpen();
 99069: 
 99069:     nsresult rv = NS_OK;
 99069:     if (mFD) {
 99069:         if (PR_Close(mFD) == PR_FAILURE)
 99069:             rv = NS_BASE_STREAM_OSERROR;
 99069:         mFD = nsnull;
 99069:     }
 99069:     return rv;
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::Available(PRUint32* aResult)
 99069: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
 99069:     if (!mFD) {
 99069:         return NS_BASE_STREAM_CLOSED;
 99069:     }
 99069: 
 99069:     // PR_Available with files over 4GB returns an error, so we have to
 99069:     // use the 64-bit version of PR_Available.
 99069:     PRInt64 avail = PR_Available64(mFD);
 99069:     if (avail == -1) {
 99069:         return NS_ErrorAccordingToNSPR();
 99069:     }
 99069: 
 99069:     // If available is greater than 4GB, return 4GB
 99069:     *aResult = avail > PR_UINT32_MAX ? PR_UINT32_MAX : (PRUint32)avail;
 99069:     return NS_OK;
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::Read(char* aBuf, PRUint32 aCount, PRUint32* aResult)
 99069: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
 99069:     if (!mFD) {
 99069:         *aResult = 0;
 99069:         return NS_OK;
 99069:     }
 99069: 
 99069:     PRInt32 bytesRead = PR_Read(mFD, aBuf, aCount);
 99069:     if (bytesRead == -1) {
 99069:         return NS_ErrorAccordingToNSPR();
 99069:     }
 99069: 
 99069:     *aResult = bytesRead;
 99069:     return NS_OK;
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
 99069:                                PRUint32 aCount, PRUint32* aResult)
 99069: {
 99069:     // ReadSegments is not implemented because it would be inefficient when
 99069:     // the writer does not consume all data.  If you want to call ReadSegments,
 99069:     // wrap a BufferedInputStream around the file stream.  That will call
 99069:     // Read().
 99069: 
 99069:     // If this is ever implemented you might need to modify
 99069:     // nsPartialFileInputStream::ReadSegments
 99069: 
 99069:     return NS_ERROR_NOT_IMPLEMENTED;
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::IsNonBlocking(bool *aNonBlocking)
 99069: {
 99069:     *aNonBlocking = false;
 99069:     return NS_OK;
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::Flush(void)
 99069: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
 99069:     if (mFD == nsnull)
 99069:         return NS_BASE_STREAM_CLOSED;
 99069: 
 99069:     PRInt32 cnt = PR_Sync(mFD);
 99069:     if (cnt == -1) {
 99069:         return NS_ErrorAccordingToNSPR();
 99069:     }
 99069:     return NS_OK;
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::Write(const char *buf, PRUint32 count, PRUint32 *result)
 99069: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
 99069:     if (mFD == nsnull)
 99069:         return NS_BASE_STREAM_CLOSED;
 99069: 
 99069:     PRInt32 cnt = PR_Write(mFD, buf, count);
 99069:     if (cnt == -1) {
 99069:         return NS_ErrorAccordingToNSPR();
 99069:     }
 99069:     *result = cnt;
 99069:     return NS_OK;
 99069: }
 99069:     
 99069: nsresult
 99069: nsFileStreamBase::WriteFrom(nsIInputStream *inStr, PRUint32 count, PRUint32 *_retval)
 99069: {
 99069:     NS_NOTREACHED("WriteFrom (see source comment)");
 99069:     return NS_ERROR_NOT_IMPLEMENTED;
 99069:     // File streams intentionally do not support this method.
 99069:     // If you need something like this, then you should wrap
 99069:     // the file stream using nsIBufferedOutputStream
 99069: }
 99069: 
 99069: nsresult
 99069: nsFileStreamBase::WriteSegments(nsReadSegmentFun reader, void * closure, PRUint32 count, PRUint32 *_retval)
 99069: {
 99069:     return NS_ERROR_NOT_IMPLEMENTED;
 99069:     // File streams intentionally do not support this method.
 99069:     // If you need something like this, then you should wrap
 99069:     // the file stream using nsIBufferedOutputStream
 99069: }
 99069: 
 99069: nsresult
101111: nsFileStreamBase::MaybeOpen(nsIFile* aFile, PRInt32 aIoFlags,
 99069:                             PRInt32 aPerm, bool aDeferred)
 63331: {
101248:     NS_ENSURE_STATE(aFile);
101248: 
 63331:     mOpenParams.ioFlags = aIoFlags;
 63331:     mOpenParams.perm = aPerm;
 63331: 
 63331:     if (aDeferred) {
 63331:         // Clone the file, as it may change between now and the deferred open
 63331:         nsCOMPtr<nsIFile> file;
 63331:         nsresult rv = aFile->Clone(getter_AddRefs(file));
 63331:         NS_ENSURE_SUCCESS(rv, rv);
 63331: 
 63331:         mOpenParams.localFile = do_QueryInterface(file);
 63331:         NS_ENSURE_TRUE(mOpenParams.localFile, NS_ERROR_UNEXPECTED);
 63331: 
 63331:         mDeferredOpen = true;
 63331:         return NS_OK;
 63331:     }
 63331: 
 63331:     mOpenParams.localFile = aFile;
 63331: 
 63331:     return DoOpen();
 63331: }
 63331: 
 63331: void
 99069: nsFileStreamBase::CleanUpOpen()
 63331: {
 63331:     mOpenParams.localFile = nsnull;
 63331:     mDeferredOpen = false;
 63331: }
 63331: 
 63331: nsresult
 99069: nsFileStreamBase::DoOpen()
 63331: {
 63331:     NS_PRECONDITION(mOpenParams.localFile, "Must have a file to open");
 63331: 
 63331:     PRFileDesc* fd;
 63331:     nsresult rv = mOpenParams.localFile->OpenNSPRFileDesc(mOpenParams.ioFlags, mOpenParams.perm, &fd);
 63331:     CleanUpOpen();
 64486:     if (NS_FAILED(rv)) return rv;
 63331:     mFD = fd;
 63331: 
 63331:     return NS_OK;
 63331: }
 63331: 
 63331: nsresult
 99069: nsFileStreamBase::DoPendingOpen()
 63331: {
 63331:     if (!mDeferredOpen) {
 63331:         return NS_OK;
 63331:     }
 63331: 
 63331:     return DoOpen();
 63331: }
 63331: 
     1: ////////////////////////////////////////////////////////////////////////////////
     1: // nsFileInputStream
     1: 
 99069: NS_IMPL_ADDREF_INHERITED(nsFileInputStream, nsFileStreamBase)
 99069: NS_IMPL_RELEASE_INHERITED(nsFileInputStream, nsFileStreamBase)
 56318: 
 56318: NS_IMPL_CLASSINFO(nsFileInputStream, NULL, nsIClassInfo::THREADSAFE,
 56318:                   NS_LOCALFILEINPUTSTREAM_CID)
 56318: 
 56318: NS_INTERFACE_MAP_BEGIN(nsFileInputStream)
 56318:     NS_INTERFACE_MAP_ENTRY(nsIInputStream)
 56318:     NS_INTERFACE_MAP_ENTRY(nsIFileInputStream)
 56318:     NS_INTERFACE_MAP_ENTRY(nsILineInputStream)
 56318:     NS_INTERFACE_MAP_ENTRY(nsIIPCSerializable)
 56318:     NS_IMPL_QUERY_CLASSINFO(nsFileInputStream)
 99069: NS_INTERFACE_MAP_END_INHERITING(nsFileStreamBase)
 56318: 
 56318: NS_IMPL_CI_INTERFACE_GETTER5(nsFileInputStream,
     1:                              nsIInputStream,
     1:                              nsIFileInputStream,
 56318:                              nsISeekableStream,
 56318:                              nsILineInputStream,
 56318:                              nsIIPCSerializable)
     1: 
 46998: nsresult
     1: nsFileInputStream::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
     1: {
     1:     NS_ENSURE_NO_AGGREGATION(aOuter);
     1: 
     1:     nsFileInputStream* stream = new nsFileInputStream();
     1:     if (stream == nsnull)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     NS_ADDREF(stream);
     1:     nsresult rv = stream->QueryInterface(aIID, aResult);
     1:     NS_RELEASE(stream);
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsFileInputStream::Open(nsIFile* aFile, PRInt32 aIOFlags, PRInt32 aPerm)
     1: {   
     1:     nsresult rv = NS_OK;
     1: 
     1:     // If the previous file is open, close it
     1:     if (mFD) {
     1:         rv = Close();
     1:         if (NS_FAILED(rv)) return rv;
     1:     }
     1: 
     1:     // Open the file
     1:     if (aIOFlags == -1)
     1:         aIOFlags = PR_RDONLY;
     1:     if (aPerm == -1)
     1:         aPerm = 0;
     1: 
101111:     rv = MaybeOpen(aFile, aIOFlags, aPerm,
 63331:                    mBehaviorFlags & nsIFileInputStream::DEFER_OPEN);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     if (mBehaviorFlags & DELETE_ON_CLOSE) {
     1:         // POSIX compatible filesystems allow a file to be unlinked while a
     1:         // file descriptor is still referencing the file.  since we've already
     1:         // opened the file descriptor, we'll try to remove the file.  if that
     1:         // fails, then we'll just remember the nsIFile and remove it after we
     1:         // close the file descriptor.
 80486:         rv = aFile->Remove(false);
 56319:         if (NS_SUCCEEDED(rv)) {
 56319:           // No need to remove it later. Clear the flag.
 56319:           mBehaviorFlags &= ~DELETE_ON_CLOSE;
 56319:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFileInputStream::Init(nsIFile* aFile, PRInt32 aIOFlags, PRInt32 aPerm,
     1:                         PRInt32 aBehaviorFlags)
     1: {
     1:     NS_ENSURE_TRUE(!mFD, NS_ERROR_ALREADY_INITIALIZED);
 63331:     NS_ENSURE_TRUE(!mDeferredOpen, NS_ERROR_ALREADY_INITIALIZED);
     1: 
     1:     mBehaviorFlags = aBehaviorFlags;
     1: 
     1:     mFile = aFile;
     1:     mIOFlags = aIOFlags;
     1:     mPerm = aPerm;
     1: 
     1:     return Open(aFile, aIOFlags, aPerm);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFileInputStream::Close()
     1: {
     1:     // null out mLineBuffer in case Close() is called again after failing
     1:     PR_FREEIF(mLineBuffer);
 99069:     nsresult rv = nsFileStreamBase::Close();
     1:     if (NS_FAILED(rv)) return rv;
 56161:     if (mFile && (mBehaviorFlags & DELETE_ON_CLOSE)) {
 80486:         rv = mFile->Remove(false);
     1:         NS_ASSERTION(NS_SUCCEEDED(rv), "failed to delete file");
 56161:         // If we don't need to save the file for reopening, free it up
 56161:         if (!(mBehaviorFlags & REOPEN_ON_REWIND)) {
 56161:           mFile = nsnull;
     1:         }
 56161:     }
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 99069: nsFileInputStream::Read(char* aBuf, PRUint32 aCount, PRUint32* _retval)
     1: {
 99069:     nsresult rv = nsFileStreamBase::Read(aBuf, aCount, _retval);
 63331:     NS_ENSURE_SUCCESS(rv, rv);
 63331: 
 99069:     // Check if we're at the end of file and need to close
 99069:     if (mBehaviorFlags & CLOSE_ON_EOF && *_retval == 0) {
 99069:         Close();
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsFileInputStream::ReadLine(nsACString& aLine, bool* aResult)
     1: {
 63331:     nsresult rv = DoPendingOpen();
 63331:     NS_ENSURE_SUCCESS(rv, rv);
 63331: 
     1:     if (!mLineBuffer) {
     1:         nsresult rv = NS_InitLineBuffer(&mLineBuffer);
     1:         if (NS_FAILED(rv)) return rv;
     1:     }
     1:     return NS_ReadLine(this, mLineBuffer, aLine, aResult);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFileInputStream::Seek(PRInt32 aWhence, PRInt64 aOffset)
     1: {
 63331:     nsresult rv = DoPendingOpen();
 63331:     NS_ENSURE_SUCCESS(rv, rv);
 63331: 
     1:     PR_FREEIF(mLineBuffer); // this invalidates the line buffer
     1:     if (!mFD) {
     1:         if (mBehaviorFlags & REOPEN_ON_REWIND) {
     1:             nsresult rv = Reopen();
     1:             if (NS_FAILED(rv)) {
     1:                 return rv;
     1:             }
     1:         } else {
     1:             return NS_BASE_STREAM_CLOSED;
     1:         }
     1:     }
     1: 
 99069:     return nsFileStreamBase::Seek(aWhence, aOffset);
     1: }
     1: 
 79445: bool
 56318: nsFileInputStream::Read(const IPC::Message *aMsg, void **aIter)
 56318: {
 56318:     using IPC::ReadParam;
 56318: 
 56318:     nsCString path;
 79445:     bool followLinks;
 56318:     PRInt32 flags;
 56318:     if (!ReadParam(aMsg, aIter, &path) ||
 56318:         !ReadParam(aMsg, aIter, &followLinks) ||
 56318:         !ReadParam(aMsg, aIter, &flags))
 80486:         return false;
 56318: 
101111:     nsCOMPtr<nsIFile> file;
 56318:     nsresult rv = NS_NewNativeLocalFile(path, followLinks, getter_AddRefs(file));
 56318:     if (NS_FAILED(rv))
 80486:         return false;
 56318: 
 56318:     // IO flags = -1 means readonly, and
 56318:     // permissions are unimportant since we're reading
 56318:     rv = Init(file, -1, -1, flags);
 56318:     if (NS_FAILED(rv))
 80486:         return false;
 56318: 
 80486:     return true;
 56318: }
 56318: 
 56318: void
 56318: nsFileInputStream::Write(IPC::Message *aMsg)
 56318: {
 56318:     using IPC::WriteParam;
 56318: 
 56318:     nsCString path;
 56318:     mFile->GetNativePath(path);
 56318:     WriteParam(aMsg, path);
 79445:     bool followLinks;
101111:     mFile->GetFollowLinks(&followLinks);
 56318:     WriteParam(aMsg, followLinks);
 56318:     WriteParam(aMsg, mBehaviorFlags);
 56318: }
 56318: 
     1: ////////////////////////////////////////////////////////////////////////////////
 55459: // nsPartialFileInputStream
 55459: 
 55459: // Don't forward to nsFileInputStream as we don't want to QI to
 55459: // nsIFileInputStream
 55459: NS_IMPL_ISUPPORTS_INHERITED3(nsPartialFileInputStream,
 99069:                              nsFileStreamBase,
 55459:                              nsIInputStream,
 55459:                              nsIPartialFileInputStream,
 55459:                              nsILineInputStream)
 55459: 
 55459: nsresult
 55459: nsPartialFileInputStream::Create(nsISupports *aOuter, REFNSIID aIID,
 55459:                                  void **aResult)
 55459: {
 55459:     NS_ENSURE_NO_AGGREGATION(aOuter);
 55459: 
 55459:     nsPartialFileInputStream* stream = new nsPartialFileInputStream();
 55459: 
 55459:     NS_ADDREF(stream);
 55459:     nsresult rv = stream->QueryInterface(aIID, aResult);
 55459:     NS_RELEASE(stream);
 55459:     return rv;
 55459: }
 55459: 
 55459: NS_IMETHODIMP
 55459: nsPartialFileInputStream::Init(nsIFile* aFile, PRUint64 aStart,
 55459:                                PRUint64 aLength, PRInt32 aIOFlags,
 55459:                                PRInt32 aPerm, PRInt32 aBehaviorFlags)
 55459: {
 55459:     mStart = aStart;
 55459:     mLength = aLength;
 55459:     mPosition = 0;
 55459: 
 55459:     nsresult rv = nsFileInputStream::Init(aFile, aIOFlags, aPerm,
 55459:                                           aBehaviorFlags);
 55459:     NS_ENSURE_SUCCESS(rv, rv);
 55459:     
 55459:     return nsFileInputStream::Seek(NS_SEEK_SET, mStart);
 55459: }
 55459: 
 55459: NS_IMETHODIMP
 55459: nsPartialFileInputStream::Tell(PRInt64 *aResult)
 55459: {
 55459:     PRInt64 tell;
 55459:     nsresult rv = nsFileInputStream::Tell(&tell);
 55459:     if (NS_SUCCEEDED(rv)) {
 55459:         *aResult = tell - mStart;
 55459:     }
 55459:     return rv;
 55459: }
 55459: 
 55459: NS_IMETHODIMP
 55459: nsPartialFileInputStream::Available(PRUint32* aResult)
 55459: {
 55459:     PRUint32 available;
 55459:     nsresult rv = nsFileInputStream::Available(&available);
 55459:     if (NS_SUCCEEDED(rv)) {
 55459:         *aResult = TruncateSize(available);
 55459:     }
 55459:     return rv;
 55459: }
 55459: 
 55459: NS_IMETHODIMP
 55459: nsPartialFileInputStream::Read(char* aBuf, PRUint32 aCount, PRUint32* aResult)
 55459: {
 55459:     PRUint32 readsize = TruncateSize(aCount);
 55459:     if (readsize == 0 && mBehaviorFlags & CLOSE_ON_EOF) {
 55459:         Close();
 55459:         *aResult = 0;
 55459:         return NS_OK;
 55459:     }
 55459: 
 55459:     nsresult rv = nsFileInputStream::Read(aBuf, readsize, aResult);
 55459:     if (NS_SUCCEEDED(rv)) {
 55459:         mPosition += readsize;
 55459:     }
 55459:     return rv;
 55459: }
 55459: 
 55459: NS_IMETHODIMP
 55459: nsPartialFileInputStream::Seek(PRInt32 aWhence, PRInt64 aOffset)
 55459: {
 55459:     PRInt64 offset;
 55459:     switch (aWhence) {
 55459:         case NS_SEEK_SET:
 55459:             offset = mStart + aOffset;
 55459:             break;
 55459:         case NS_SEEK_CUR:
 55459:             offset = mStart + mPosition + aOffset;
 55459:             break;
 55459:         case NS_SEEK_END:
 55459:             offset = mStart + mLength + aOffset;
 55459:             break;
 55459:         default:
 55459:             return NS_ERROR_ILLEGAL_VALUE;
 55459:     }
 55459: 
 55459:     if (offset < (PRInt64)mStart || offset > (PRInt64)(mStart + mLength)) {
 55459:         return NS_ERROR_INVALID_ARG;
 55459:     }
 55459: 
 55459:     nsresult rv = nsFileInputStream::Seek(NS_SEEK_SET, offset);
 55459:     if (NS_SUCCEEDED(rv)) {
 55459:         mPosition = offset - mStart;
 55459:     }
 55459:     return rv;
 55459: }
 55459: 
 55459: ////////////////////////////////////////////////////////////////////////////////
     1: // nsFileOutputStream
     1: 
     1: NS_IMPL_ISUPPORTS_INHERITED2(nsFileOutputStream,
 99069:                              nsFileStreamBase,
     1:                              nsIOutputStream,
     1:                              nsIFileOutputStream)
     1:  
 46998: nsresult
     1: nsFileOutputStream::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
     1: {
     1:     NS_ENSURE_NO_AGGREGATION(aOuter);
     1: 
     1:     nsFileOutputStream* stream = new nsFileOutputStream();
     1:     if (stream == nsnull)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     NS_ADDREF(stream);
     1:     nsresult rv = stream->QueryInterface(aIID, aResult);
     1:     NS_RELEASE(stream);
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsFileOutputStream::Init(nsIFile* file, PRInt32 ioFlags, PRInt32 perm,
     1:                          PRInt32 behaviorFlags)
     1: {
     1:     NS_ENSURE_TRUE(mFD == nsnull, NS_ERROR_ALREADY_INITIALIZED);
 63331:     NS_ENSURE_TRUE(!mDeferredOpen, NS_ERROR_ALREADY_INITIALIZED);
 63331: 
 63331:     mBehaviorFlags = behaviorFlags;
     1: 
     1:     if (ioFlags == -1)
     1:         ioFlags = PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE;
     1:     if (perm <= 0)
     1:         perm = 0664;
     1: 
101111:     return MaybeOpen(file, ioFlags, perm,
 63331:                      mBehaviorFlags & nsIFileOutputStream::DEFER_OPEN);
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////////////
     1: // nsSafeFileOutputStream
     1: 
     1: NS_IMPL_ISUPPORTS_INHERITED3(nsSafeFileOutputStream,
     1:                              nsFileOutputStream,
     1:                              nsISafeOutputStream,
     1:                              nsIOutputStream,
     1:                              nsIFileOutputStream)
     1: 
     1: NS_IMETHODIMP
     1: nsSafeFileOutputStream::Init(nsIFile* file, PRInt32 ioFlags, PRInt32 perm,
     1:                              PRInt32 behaviorFlags)
     1: {
 63331:     return nsFileOutputStream::Init(file, ioFlags, perm, behaviorFlags);
 63331: }
 63331: 
 63331: nsresult
 63331: nsSafeFileOutputStream::DoOpen()
 63331: {
 63331:     // Make sure mOpenParams.localFile will be empty if we bail somewhere in
 63331:     // this function
101111:     nsCOMPtr<nsIFile> file;
 63331:     file.swap(mOpenParams.localFile);
     1: 
     1:     nsresult rv = file->Exists(&mTargetFileExists);
     1:     if (NS_FAILED(rv)) {
     1:         NS_ERROR("Can't tell if target file exists");
 80486:         mTargetFileExists = true; // Safer to assume it exists - we just do more work.
     1:     }
     1: 
     1:     // follow symlinks, for two reasons:
     1:     // 1) if a user has deliberately set up a profile file as a symlink, we honor it
     1:     // 2) to make the MoveToNative() in Finish() an atomic operation (which may not
     1:     //    be the case if moving across directories on different filesystems).
     1:     nsCOMPtr<nsIFile> tempResult;
     1:     rv = file->Clone(getter_AddRefs(tempResult));
     1:     if (NS_SUCCEEDED(rv)) {
101111:         tempResult->SetFollowLinks(true);
     1: 
     1:         // XP_UNIX ignores SetFollowLinks(), so we have to normalize.
     1:         tempResult->Normalize();
     1:     }
     1: 
     1:     if (NS_SUCCEEDED(rv) && mTargetFileExists) {
     1:         PRUint32 origPerm;
     1:         if (NS_FAILED(file->GetPermissions(&origPerm))) {
     1:             NS_ERROR("Can't get permissions of target file");
 63331:             origPerm = mOpenParams.perm;
     1:         }
     1:         // XXX What if |perm| is more restrictive then |origPerm|?
     1:         // This leaves the user supplied permissions as they were.
     1:         rv = tempResult->CreateUnique(nsIFile::NORMAL_FILE_TYPE, origPerm);
     1:     }
     1:     if (NS_SUCCEEDED(rv)) {
 63331:         // nsFileOutputStream::DoOpen will work on the temporary file, so we
 63331:         // prepare it and place it in mOpenParams.localFile.
101111:         mOpenParams.localFile = tempResult;
     1:         mTempFile = tempResult;
     1:         mTargetFile = file;
 63331:         rv = nsFileOutputStream::DoOpen();
     1:     }
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSafeFileOutputStream::Close()
     1: {
     1:     nsresult rv = nsFileOutputStream::Close();
     1: 
     1:     // the consumer doesn't want the original file overwritten -
     1:     // so clean up by removing the temp file.
     1:     if (mTempFile) {
 80486:         mTempFile->Remove(false);
     1:         mTempFile = nsnull;
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSafeFileOutputStream::Finish()
     1: {
 28263:     Flush();
     1:     nsresult rv = nsFileOutputStream::Close();
     1: 
     1:     // if there is no temp file, don't try to move it over the original target.
     1:     // It would destroy the targetfile if close() is called twice.
     1:     if (!mTempFile)
     1:         return rv;
     1: 
     1:     // Only overwrite if everything was ok, and the temp file could be closed.
     1:     if (NS_SUCCEEDED(mWriteResult) && NS_SUCCEEDED(rv)) {
     1:         NS_ENSURE_STATE(mTargetFile);
     1: 
     1:         if (!mTargetFileExists) {
     1:             // If the target file did not exist when we were initialized, then the
     1:             // temp file we gave out was actually a reference to the target file.
     1:             // since we succeeded in writing to the temp file (and hence succeeded
     1:             // in writing to the target file), there is nothing more to do.
     1: #ifdef DEBUG      
 79445:             bool equal;
     1:             if (NS_FAILED(mTargetFile->Equals(mTempFile, &equal)) || !equal)
     1:                 NS_ERROR("mTempFile not equal to mTargetFile");
     1: #endif
  1641:         }
  1641:         else {
 61865:             nsAutoString targetFilename;
 61865:             rv = mTargetFile->GetLeafName(targetFilename);
  1641:             if (NS_SUCCEEDED(rv)) {
  1641:                 // This will replace target.
 61865:                 rv = mTempFile->MoveTo(nsnull, targetFilename);
  1641:                 if (NS_FAILED(rv))
 80486:                     mTempFile->Remove(false);
  1641:             }
     1:         }
     1:     }
     1:     else {
 80486:         mTempFile->Remove(false);
     1: 
     1:         // if writing failed, propagate the failure code to the caller.
     1:         if (NS_FAILED(mWriteResult))
     1:             rv = mWriteResult;
     1:     }
     1:     mTempFile = nsnull;
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSafeFileOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *result)
     1: {
     1:     nsresult rv = nsFileOutputStream::Write(buf, count, result);
     1:     if (NS_SUCCEEDED(mWriteResult)) {
     1:         if (NS_FAILED(rv))
     1:             mWriteResult = rv;
     1:         else if (count != *result)
     1:             mWriteResult = NS_ERROR_LOSS_OF_SIGNIFICANT_DATA;
     1: 
     1:         if (NS_FAILED(mWriteResult) && count > 0)
     1:             NS_WARNING("writing to output stream failed! data may be lost");
     1:     } 
     1:     return rv;
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////////////
 99069: // nsFileStream
 99069: 
 99069: NS_IMPL_ISUPPORTS_INHERITED4(nsFileStream, 
 99069:                              nsFileStreamBase,
 99069:                              nsIInputStream,
 99069:                              nsIOutputStream,
 99069:                              nsIFileStream,
 99069:                              nsIFileMetadata)
 99069:  
 99069: NS_IMETHODIMP
 99069: nsFileStream::Init(nsIFile* file, PRInt32 ioFlags, PRInt32 perm,
 99069:                    PRInt32 behaviorFlags)
 99069: {
 99069:     NS_ENSURE_TRUE(mFD == nsnull, NS_ERROR_ALREADY_INITIALIZED);
 99069:     NS_ENSURE_TRUE(!mDeferredOpen, NS_ERROR_ALREADY_INITIALIZED);
 99069: 
 99069:     mBehaviorFlags = behaviorFlags;
 99069: 
 99069:     if (ioFlags == -1)
 99069:         ioFlags = PR_RDWR;
 99069:     if (perm <= 0)
 99069:         perm = 0;
 99069: 
101111:     return MaybeOpen(file, ioFlags, perm,
 99069:                      mBehaviorFlags & nsIFileStream::DEFER_OPEN);
 99069: }
 99069: 
 99069: NS_IMETHODIMP
 99069: nsFileStream::GetSize(PRInt64* _retval)
 99069: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
 99069:     if (!mFD) {
 99069:         return NS_BASE_STREAM_CLOSED;
 99069:     }
 99069: 
 99069:     PRFileInfo64 info;
 99069:     if (PR_GetOpenFileInfo64(mFD, &info) == PR_FAILURE) {
 99069:         return NS_BASE_STREAM_OSERROR;
 99069:     }
 99069: 
 99069:     *_retval = PRInt64(info.size);
 99069: 
 99069:     return NS_OK;
 99069: }
 99069: 
 99069: NS_IMETHODIMP
 99069: nsFileStream::GetLastModified(PRInt64* _retval)
 99069: {
 99069:     nsresult rv = DoPendingOpen();
 99069:     NS_ENSURE_SUCCESS(rv, rv);
 99069: 
 99069:     if (!mFD) {
 99069:         return NS_BASE_STREAM_CLOSED;
 99069:     }
 99069: 
 99069:     PRFileInfo64 info;
 99069:     if (PR_GetOpenFileInfo64(mFD, &info) == PR_FAILURE) {
 99069:         return NS_BASE_STREAM_OSERROR;
 99069:     }
 99069: 
 99069:     PRInt64 modTime = PRInt64(info.modifyTime);
 99069:     if (modTime == 0) {
 99069:         *_retval = 0;
 99069:     }
 99069:     else {
 99069:         *_retval = modTime / PRInt64(PR_USEC_PER_MSEC);
 99069:     }
 99069: 
 99069:     return NS_OK;
 99069: }
 99069: 
 99069: ////////////////////////////////////////////////////////////////////////////////
