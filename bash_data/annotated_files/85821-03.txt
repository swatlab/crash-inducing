    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Masatoshi Kimura <VYV03354@nifty.ne.jp>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxWindowsSurface.h"
43347: #include "gfxTextRunWordCache.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: 
71640: #include "mozilla/Preferences.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
    1: 
    1: #include "nsIWindowsRegKey.h"
19962: #include "nsILocalFile.h"
19962: #include "plbase64.h"
51658: #include "nsIXULRuntime.h"
    1: 
51736: #include "nsIGfxInfo.h"
51736: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
36949: #include "gfxGDIFontList.h"
39447: #include "gfxGDIFont.h"
71958: 
38782: #ifdef CAIRO_HAS_DWRITE_FONT
38727: #include "gfxDWriteFontList.h"
38727: #include "gfxDWriteFonts.h"
38727: #include "gfxDWriteCommon.h"
38727: #include <dwrite.h>
24104: #endif
24104: 
71986: #include "gfxUserFontSet.h"
71986: 
71986: #include <string>
71838: 
80467: using namespace mozilla;
72424: using namespace mozilla::gfx;
72424: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727: #include "gfxD2DSurface.h"
46438: 
50585: #include <d3d10_1.h>
75151: #include <dxgi.h>
50585: 
72424: #include "mozilla/gfx/2D.h"
72424: 
46438: #include "nsIMemoryReporter.h"
46438: #include "nsMemory.h"
71986: #endif
46438: 
71986: using namespace mozilla;
71986: 
71986: #ifdef CAIRO_HAS_D2D_SURFACE
72640: 
72640: NS_MEMORY_REPORTER_IMPLEMENT(
72640:     D2DCache,
72640:     "gfx-d2d-surfacecache",
72640:     KIND_OTHER,
72640:     UNITS_BYTES,
72640:     cairo_d2d_get_image_surface_cache_usage,
72640:     "Memory used by the Direct2D internal surface cache.")
72640: 
72640: namespace
46438: {
46438: 
72640: PRInt64 GetD2DSurfaceVramUsage() {
50875:   cairo_device_t *device =
50875:       gfxWindowsPlatform::GetPlatform()->GetD2DDevice();
50875:   if (device) {
72640:       return cairo_d2d_get_surface_vram_usage(device);
50875:   }
72640:   return 0;
50776: }
50776: 
72640: } // anonymous namespace
72640: 
72640: NS_MEMORY_REPORTER_IMPLEMENT(
72640:     D2DVram,
72640:     "gfx-d2d-surfacevram",
72640:     KIND_OTHER,
72640:     UNITS_BYTES,
72640:     GetD2DSurfaceVramUsage,
72640:     "Video memory used by D2D surfaces")
72640: 
38727: #endif
30086: 
42854: #define GFX_USE_CLEARTYPE_ALWAYS "gfx.font_rendering.cleartype.always_use_for_content"
42854: #define GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE "gfx.font_rendering.cleartype.use_for_downloadable_fonts"
42854: 
68738: #define GFX_CLEARTYPE_PARAMS           "gfx.font_rendering.cleartype_params."
68738: #define GFX_CLEARTYPE_PARAMS_GAMMA     "gfx.font_rendering.cleartype_params.gamma"
68738: #define GFX_CLEARTYPE_PARAMS_CONTRAST  "gfx.font_rendering.cleartype_params.enhanced_contrast"
68738: #define GFX_CLEARTYPE_PARAMS_LEVEL     "gfx.font_rendering.cleartype_params.cleartype_level"
68738: #define GFX_CLEARTYPE_PARAMS_STRUCTURE "gfx.font_rendering.cleartype_params.pixel_structure"
68738: #define GFX_CLEARTYPE_PARAMS_MODE      "gfx.font_rendering.cleartype_params.rendering_mode"
68738: 
38727: #ifdef CAIRO_HAS_DWRITE_FONT
38727: // DirectWrite is not available on all platforms, we need to use the function
38727: // pointer.
38727: typedef HRESULT (WINAPI*DWriteCreateFactoryFunc)(
81641:   DWRITE_FACTORY_TYPE factoryType,
81641:   REFIID iid,
81641:   IUnknown **factory
38727: );
38727: #endif
38727: 
50585: #ifdef CAIRO_HAS_D2D_SURFACE
50585: typedef HRESULT (WINAPI*D3D10CreateDevice1Func)(
50585:   IDXGIAdapter *pAdapter,
50585:   D3D10_DRIVER_TYPE DriverType,
50585:   HMODULE Software,
50585:   UINT Flags,
50585:   D3D10_FEATURE_LEVEL1 HardwareLevel,
50585:   UINT SDKVersion,
50585:   ID3D10Device1 **ppDevice
50585: );
75151: 
75151: typedef HRESULT(WINAPI*CreateDXGIFactory1Func)(
75151:   REFIID riid,
75151:   void **ppFactory
75151: );
50585: #endif
50585: 
13578: static __inline void
13578: BuildKeyNameFromFontName(nsAString &aName)
13578: {
13578:     if (aName.Length() >= LF_FACESIZE)
13578:         aName.Truncate(LF_FACESIZE - 1);
13578:     ToLowerCase(aName);
13578: }
13280: 
36949: gfxWindowsPlatform::gfxWindowsPlatform()
 5254: {
36949:     mPrefFonts.Init(50);
 5254: 
42854:     mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:     mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854: 
80486:     mUsingGDIFonts = false;
57104: 
51527:     /* 
51527:      * Initialize COM 
51527:      */ 
51527:     CoInitialize(NULL); 
51527: 
51035:     mScreenDC = GetDC(NULL);
51035: 
53984: #ifdef CAIRO_HAS_D2D_SURFACE
72640:     NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(D2DCache));
72640:     NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(D2DVram));
53984:     mD2DDevice = nsnull;
53984: #endif
53984: 
53984:     UpdateRenderMode();
53984: }
53984: 
53984: gfxWindowsPlatform::~gfxWindowsPlatform()
53984: {
53984:     ::ReleaseDC(NULL, mScreenDC);
53984:     // not calling FT_Done_FreeType because cairo may still hold references to
53984:     // these FT_Faces.  See bug 458169.
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     if (mD2DDevice) {
53984:         cairo_release_device(mD2DDevice);
53984:     }
53984: #endif
53984: 
53984:     /* 
53984:      * Uninitialize COM 
53984:      */ 
53984:     CoUninitialize();
53984: }
53984: 
53984: void
53984: gfxWindowsPlatform::UpdateRenderMode()
53984: {
71589: /* Pick the default render mode for
71589:  * desktop.
30087:  */
30087:     mRenderMode = RENDER_GDI;
30087: 
50585:     OSVERSIONINFOA versionInfo;
50585:     versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
50585:     ::GetVersionExA(&versionInfo);
50585:     bool isVistaOrHigher = versionInfo.dwMajorVersion >= 6;
50585: 
79445:     bool safeMode = false;
51751:     nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
51751:     if (xr)
51751:       xr->GetInSafeMode(&safeMode);
51751: 
79445:     mUseDirectWrite = Preferences::GetBool("gfx.font_rendering.directwrite.enabled", false);
53984: 
51736: #ifdef CAIRO_HAS_D2D_SURFACE
79445:     bool d2dDisabled = false;
79445:     bool d2dForceEnabled = false;
79445:     bool d2dBlocked = false;
51736: 
51736:     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
51736:     if (gfxInfo) {
51736:         PRInt32 status;
51736:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT2D, &status))) {
55059:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
80486:                 d2dDisabled = true;
55059:                 if (status == nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION ||
55059:                     status == nsIGfxInfo::FEATURE_BLOCKED_DEVICE)
54964:                 {
80486:                     d2dBlocked = true;
51736:                 }
51736:             }
51736:         }
51736:     }
51736: 
79445:     d2dDisabled = Preferences::GetBool("gfx.direct2d.disabled", false);
79445:     d2dForceEnabled = Preferences::GetBool("gfx.direct2d.force-enabled", false);
51656: 
53984:     bool tryD2D = !d2dBlocked || d2dForceEnabled;
53984:     
57104:     // Do not ever try if d2d is explicitly disabled,
57104:     // or if we're not using DWrite fonts.
57104:     if (d2dDisabled || mUsingGDIFonts) {
53984:         tryD2D = false;
53984:     }
53984: 
53984:     if (isVistaOrHigher  && !safeMode && tryD2D) {
53984:         VerifyD2DDevice(d2dForceEnabled);
53984:         if (mD2DDevice) {
53984:             mRenderMode = RENDER_DIRECT2D;
80486:             mUseDirectWrite = true;
53984:         }
53984:     } else {
53984:         mD2DDevice = nsnull;
53984:     }
53984: #endif
53984: 
53984: #ifdef CAIRO_HAS_DWRITE_FONT
53984:     // Enable when it's preffed on -and- we're using Vista or higher. Or when
53984:     // we're going to use D2D.
53984:     if (!mDWriteFactory && (mUseDirectWrite && isVistaOrHigher)) {
63285:         mozilla::ScopedGfxFeatureReporter reporter("DWrite");
53984:         DWriteCreateFactoryFunc createDWriteFactory = (DWriteCreateFactoryFunc)
53984:             GetProcAddress(LoadLibraryW(L"dwrite.dll"), "DWriteCreateFactory");
53984: 
53984:         if (createDWriteFactory) {
53984:             /**
53984:              * I need a direct pointer to be able to cast to IUnknown**, I also
53984:              * need to remember to release this because the nsRefPtr will
53984:              * AddRef it.
53984:              */
53984:             IDWriteFactory *factory;
53984:             HRESULT hr = createDWriteFactory(
53984:                 DWRITE_FACTORY_TYPE_SHARED,
53984:                 __uuidof(IDWriteFactory),
53984:                 reinterpret_cast<IUnknown**>(&factory));
53984:             mDWriteFactory = factory;
53984:             factory->Release();
63285: 
71640:             SetupClearTypeParams();
68738: 
63285:             if (hr == S_OK)
63285:               reporter.SetSuccessful();
53984:         }
53984:     }
53984: #endif
53984: }
53984: 
53984: void
79445: gfxWindowsPlatform::VerifyD2DDevice(bool aAttemptForce)
53984: {
53984: #ifdef CAIRO_HAS_D2D_SURFACE
53984:     if (mD2DDevice) {
53984:         ID3D10Device1 *device = cairo_d2d_device_get_device(mD2DDevice);
53984: 
53984:         if (SUCCEEDED(device->GetDeviceRemovedReason())) {
53984:             return;
53984:         }
53984:         mD2DDevice = nsnull;
53984:     }
53984: 
63285:     mozilla::ScopedGfxFeatureReporter reporter("D2D");
63285: 
50585:     HMODULE d3d10module = LoadLibraryA("d3d10_1.dll");
50585:     D3D10CreateDevice1Func createD3DDevice = (D3D10CreateDevice1Func)
50585:         GetProcAddress(d3d10module, "D3D10CreateDevice1");
50585:     nsRefPtr<ID3D10Device1> device;
50585: 
50585:     if (createD3DDevice) {
75151:         HMODULE dxgiModule = LoadLibraryA("dxgi.dll");
75151:         CreateDXGIFactory1Func createDXGIFactory1 = (CreateDXGIFactory1Func)
75151:             GetProcAddress(dxgiModule, "CreateDXGIFactory1");
75151: 
75151:         // Try to use a DXGI 1.1 adapter in order to share resources
75151:         // across processes.
75151:         nsRefPtr<IDXGIAdapter1> adapter1;
75151:         if (createDXGIFactory1) {
75151:             nsRefPtr<IDXGIFactory1> factory1;
75151:             HRESULT hr = createDXGIFactory1(__uuidof(IDXGIFactory1),
75151:                                             getter_AddRefs(factory1));
75151:     
75151:             nsRefPtr<IDXGIAdapter1> adapter1; 
75151:             hr = factory1->EnumAdapters1(0, getter_AddRefs(adapter1));
75151: 
75151:             if (SUCCEEDED(hr) && adapter1) {
75151:                 hr = adapter1->CheckInterfaceSupport(__uuidof(ID3D10Device1),
75151:                                                      nsnull);
75151:                 if (FAILED(hr)) {
75151:                     adapter1 = nsnull;
75151:                 }
75151:             }
75151:         }
75151: 
50585:         // We try 10.0 first even though we prefer 10.1, since we want to
50585:         // fail as fast as possible if 10.x isn't supported.
50585:         HRESULT hr = createD3DDevice(
75151:             adapter1, 
50585:             D3D10_DRIVER_TYPE_HARDWARE,
50585:             NULL,
50585:             D3D10_CREATE_DEVICE_BGRA_SUPPORT |
50585:             D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
50585:             D3D10_FEATURE_LEVEL_10_0,
50585:             D3D10_1_SDK_VERSION,
50585:             getter_AddRefs(device));
50585: 
50585:         if (SUCCEEDED(hr)) {
50585:             // We have 10.0, let's try 10.1.
50585:             // XXX - This adds an additional 10-20ms for people who are
50585:             // getting direct2d. We'd really like to do something more
50585:             // clever.
50585:             nsRefPtr<ID3D10Device1> device1;
50585:             hr = createD3DDevice(
75151:                 adapter1, 
50585:                 D3D10_DRIVER_TYPE_HARDWARE,
50585:                 NULL,
50585:                 D3D10_CREATE_DEVICE_BGRA_SUPPORT |
50585:                 D3D10_CREATE_DEVICE_PREVENT_INTERNAL_THREADING_OPTIMIZATIONS,
50585:                 D3D10_FEATURE_LEVEL_10_1,
50585:                 D3D10_1_SDK_VERSION,
50585:                 getter_AddRefs(device1));
50585: 
50585:             if (SUCCEEDED(hr)) {
50585:                 device = device1;
50585:             }
50585: 
50585:             mD2DDevice = cairo_d2d_create_device_from_d3d10device(device);
50585:         }
50585:     }
53984: 
53984:     if (!mD2DDevice && aAttemptForce) {
53984:         mD2DDevice = cairo_d2d_create_device();
50585:     }
63285: 
72424:     if (mD2DDevice) {
63285:         reporter.SetSuccessful();
72424:         mozilla::gfx::Factory::SetDirect3D10Device(cairo_d2d_device_get_device(mD2DDevice));
72424:     }
46438: #endif
38727: }
57104: 
63075: // bug 630201 - older pre-RTM versions of Direct2D/DirectWrite cause odd
63075: // crashers so blacklist them altogether
63075: 
63075: #ifdef CAIRO_HAS_DWRITE_FONT
63075: #define WINDOWS7_RTM_BUILD 7600
63075: 
79445: static bool
63075: AllowDirectWrite()
63075: {
63075:     PRInt32 winVers, buildNum;
63075: 
63075:     winVers = gfxWindowsPlatform::WindowsOSVersion(&buildNum);
63075:     if (winVers == gfxWindowsPlatform::kWindows7 &&
63075:         buildNum < WINDOWS7_RTM_BUILD)
63075:     {
63075:         // don't use Direct2D/DirectWrite on older versions of Windows 7
80486:         return false;
63075:     }
63075: 
80486:     return true;
63075: }
63075: #endif
63075: 
36949: gfxPlatformFontList*
36949: gfxWindowsPlatform::CreatePlatformFontList()
36949: {
80486:     mUsingGDIFonts = false;
57104:     gfxPlatformFontList *pfl;
38727: #ifdef CAIRO_HAS_DWRITE_FONT
63075:     if (AllowDirectWrite() && GetDWriteFactory()) {
57104:         pfl = new gfxDWriteFontList();
57104:         if (NS_SUCCEEDED(pfl->InitFontList())) {
57104:             return pfl;
57104:         }
57104:         // DWrite font initialization failed! Don't know why this would happen,
57104:         // but apparently it can - see bug 594865.
57104:         // So we're going to fall back to GDI fonts & rendering.
57104:         gfxPlatformFontList::Shutdown();
57104:         SetRenderMode(RENDER_GDI);
38727:     }
38727: #endif
57104:     pfl = new gfxGDIFontList();
80486:     mUsingGDIFonts = true;
57104: 
57104:     if (NS_SUCCEEDED(pfl->InitFontList())) {
57104:         return pfl;
57104:     }
57104: 
57104:     gfxPlatformFontList::Shutdown();
57104:     return nsnull;
36949: }
36949: 
    1: already_AddRefed<gfxASurface>
    1: gfxWindowsPlatform::CreateOffscreenSurface(const gfxIntSize& size,
54253:                                            gfxASurface::gfxContentType contentType)
    1: {
30087:     gfxASurface *surf = nsnull;
30087: 
30087: #ifdef CAIRO_HAS_WIN32_SURFACE
30087:     if (mRenderMode == RENDER_GDI)
54253:         surf = new gfxWindowsSurface(size, gfxASurface::FormatFromContent(contentType));
30086: #endif
30087: 
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:     if (mRenderMode == RENDER_DIRECT2D)
54253:         surf = new gfxD2DSurface(size, gfxASurface::FormatFromContent(contentType));
38727: #endif
38727: 
30087:     if (surf == nsnull)
54253:         surf = new gfxImageSurface(size, gfxASurface::FormatFromContent(contentType));
30087: 
    1:     NS_IF_ADDREF(surf);
30087: 
    1:     return surf;
    1: }
    1: 
72424: RefPtr<ScaledFont>
72424: gfxWindowsPlatform::GetScaledFontForFont(gfxFont *aFont)
72424: {
72424:   if(mUseDirectWrite) {
72424:     gfxDWriteFont *font = static_cast<gfxDWriteFont*>(aFont);
72424: 
72424:     NativeFont nativeFont;
72424:     nativeFont.mType = NATIVE_FONT_DWRITE_FONT_FACE;
72424:     nativeFont.mFont = font->GetFontFace();
72424:     RefPtr<ScaledFont> scaledFont =
72424:       mozilla::gfx::Factory::CreateScaledFontForNativeFont(nativeFont, font->GetAdjustedSize());
72424: 
72424:     return scaledFont;
72424:   }
72863: 
82414:   NativeFont nativeFont;
82414:   nativeFont.mType = NATIVE_FONT_GDI_FONT_FACE;
82414:   nativeFont.mFont = aFont;
82414:   RefPtr<ScaledFont> scaledFont =
82414:     Factory::CreateScaledFontForNativeFont(nativeFont, aFont->GetAdjustedSize());
82414: 
82414:   return scaledFont;
72424: }
72424: 
72424: already_AddRefed<gfxASurface>
72424: gfxWindowsPlatform::GetThebesSurfaceForDrawTarget(DrawTarget *aTarget)
72424: {
72424: #ifdef XP_WIN
72424:   if (aTarget->GetType() == BACKEND_DIRECT2D) {
85821:     if (!GetD2DDevice()) {
85821:       // We no longer have a D2D device, can't do this.
85821:       return NULL;
85821:     }
85821: 
72424:     RefPtr<ID3D10Texture2D> texture =
72424:       static_cast<ID3D10Texture2D*>(aTarget->GetNativeSurface(NATIVE_SURFACE_D3D10_TEXTURE));
72424: 
72424:     if (!texture) {
72424:       return gfxPlatform::GetThebesSurfaceForDrawTarget(aTarget);
72424:     }
72424: 
72424:     aTarget->Flush();
72424: 
72424:     nsRefPtr<gfxASurface> surf =
72424:       new gfxD2DSurface(texture, ContentForFormat(aTarget->GetFormat()));
72424: 
72424:     surf->SetData(&kDrawTarget, aTarget, NULL);
72424: 
72424:     return surf.forget();
72424:   }
72424: #endif
72424: 
72424:   return gfxPlatform::GetThebesSurfaceForDrawTarget(aTarget);
72424: }
72424: 
82417: bool
82417: gfxWindowsPlatform::SupportsAzure(BackendType& aBackend)
82417: {
82417: #ifdef CAIRO_HAS_D2D_SURFACE
82417:   if (mRenderMode == RENDER_DIRECT2D) {
82417:       aBackend = BACKEND_DIRECT2D;
82417:       return true;
82417:   }
82417: #endif
82417:   
82417:   if (Preferences::GetBool("gfx.canvas.azure.prefer-skia", false)) {
82417:     aBackend = BACKEND_SKIA;
82417:     return true;
82417:   }
82417:   return false;
82417: }
82417: 
    1: nsresult
38493: gfxWindowsPlatform::GetFontList(nsIAtom *aLangGroup,
    1:                                 const nsACString& aGenericFamily,
23904:                                 nsTArray<nsString>& aListOfFonts)
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->GetFontList(aLangGroup, aGenericFamily, aListOfFonts);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: static void
    1: RemoveCharsetFromFontSubstitute(nsAString &aName)
    1: {
    1:     PRInt32 comma = aName.FindChar(PRUnichar(','));
    1:     if (comma >= 0)
    1:         aName.Truncate(comma);
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::UpdateFontList()
    1: {
36949:     gfxPlatformFontList::PlatformFontList()->UpdateFontList();
12989: 
    1:     return NS_OK;
    1: }
    1: 
    1: struct ResolveData {
    1:     ResolveData(gfxPlatform::FontResolverCallback aCallback,
    1:                 gfxWindowsPlatform *aCaller, const nsAString *aFontName,
    1:                 void *aClosure) :
    1:         mFoundCount(0), mCallback(aCallback), mCaller(aCaller),
    1:         mFontName(aFontName), mClosure(aClosure) {}
    1:     PRUint32 mFoundCount;
    1:     gfxPlatform::FontResolverCallback mCallback;
    1:     gfxWindowsPlatform *mCaller;
    1:     const nsAString *mFontName;
    1:     void *mClosure;
    1: };
    1: 
    1: nsresult
    1: gfxWindowsPlatform::ResolveFontName(const nsAString& aFontName,
    1:                                     FontResolverCallback aCallback,
38727:                                     void *aClosure,
79445:                                     bool& aAborted)
    1: {
36949:     nsAutoString resolvedName;
36949:     if (!gfxPlatformFontList::PlatformFontList()->
36949:              ResolveFontName(aFontName, resolvedName)) {
80486:         aAborted = false;
36949:         return NS_OK;
36949:     }
36949:     aAborted = !(*aCallback)(resolvedName, aClosure);
    1:     return NS_OK;
    1: }
    1: 
36949: nsresult
36949: gfxWindowsPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
36949: {
36949:     gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName, aFamilyName);
    1:     return NS_OK;
    1: }
    1: 
  270: gfxFontGroup *
  270: gfxWindowsPlatform::CreateFontGroup(const nsAString &aFamilies,
19962:                                     const gfxFontStyle *aStyle,
19962:                                     gfxUserFontSet *aUserFontSet)
  270: {
39447:     return new gfxFontGroup(aFamilies, aStyle, aUserFontSet);
19962: }
19962: 
19962: gfxFontEntry* 
23273: gfxWindowsPlatform::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                     const nsAString& aFontName)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->LookupLocalFont(aProxyEntry, 
36949:                                                                     aFontName);
19962: }
19962: 
19962: gfxFontEntry* 
22397: gfxWindowsPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
21067:                                      const PRUint8 *aFontData, PRUint32 aLength)
19962: {
36949:     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aProxyEntry,
36949:                                                                      aFontData,
36949:                                                                      aLength);
19962: }
19962: 
79445: bool
19962: gfxWindowsPlatform::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
19962: {
23576:     // check for strange format flags
23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
23576:                  "strange font format hint set");
23576: 
23576:     // accept supported formats
32809:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_WOFF     |
32809:                         gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE)) {
80486:         return true;
23576:     }
23576: 
23576:     // reject all other formats, known and unknown
23576:     if (aFormatFlags != 0) {
80486:         return false;
19962:     }
19962: 
23576:     // no format hint set, need to look at data
80486:     return true;
  270: }
 1959: 
36949: gfxFontFamily *
13280: gfxWindowsPlatform::FindFontFamily(const nsAString& aName)
 1959: {
36949:     return gfxPlatformFontList::PlatformFontList()->FindFamily(aName);
13280: }
13280: 
36949: gfxFontEntry *
13578: gfxWindowsPlatform::FindFontEntry(const nsAString& aName, const gfxFontStyle& aFontStyle)
13280: {
36949:     nsRefPtr<gfxFontFamily> ff = FindFontFamily(aName);
13280:     if (!ff)
13280:         return nsnull;
13280: 
79445:     bool aNeedsBold;
36949:     return ff->FindFontForStyle(aFontStyle, aNeedsBold);
 1959: }
 3787: 
27035: qcms_profile*
 3787: gfxWindowsPlatform::GetPlatformCMSOutputProfile()
 3787: {
37454:     WCHAR str[MAX_PATH];
37454:     DWORD size = MAX_PATH;
37454:     BOOL res;
 3787: 
 3787:     HDC dc = GetDC(nsnull);
36860:     if (!dc)
36860:         return nsnull;
36860: 
37454: #if _MSC_VER
36860:     __try {
37454:         res = GetICMProfileW(dc, &size, (LPWSTR)&str);
36860:     } __except(GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION) {
37454:         res = FALSE;
36860:     }
37454: #else
37454:     res = GetICMProfileW(dc, &size, (LPWSTR)&str);
37454: #endif
36860: 
 3787:     ReleaseDC(nsnull, dc);
37454:     if (!res)
37454:         return nsnull;
 3787: 
64485:     qcms_profile* profile = qcms_profile_from_unicode_path(str);
 3787: #ifdef DEBUG_tor
 3787:     if (profile)
 3787:         fprintf(stderr,
 3787:                 "ICM profile read from %s successfully\n",
 3787:                 NS_ConvertUTF16toUTF8(str).get());
 3787: #endif
 3787:     return profile;
 3787: }
 5254: 
79445: bool
36949: gfxWindowsPlatform::GetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> > *array)
 5254: {
13280:     return mPrefFonts.Get(aKey, array);
 5254: }
 5254: 
 5254: void
36949: gfxWindowsPlatform::SetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<gfxFontEntry> >& array)
 5254: {
13280:     mPrefFonts.Put(aKey, array);
 5254: }
13877: 
79445: bool
42854: gfxWindowsPlatform::UseClearTypeForDownloadableFonts()
42854: {
42854:     if (mUseClearTypeForDownloadableFonts == UNINITIALIZED_VALUE) {
79445:         mUseClearTypeForDownloadableFonts = Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE, true);
42854:     }
42854: 
42854:     return mUseClearTypeForDownloadableFonts;
42854: }
42854: 
79445: bool
42854: gfxWindowsPlatform::UseClearTypeAlways()
42854: {
42854:     if (mUseClearTypeAlways == UNINITIALIZED_VALUE) {
79445:         mUseClearTypeAlways = Preferences::GetBool(GFX_USE_CLEARTYPE_ALWAYS, false);
42854:     }
42854: 
42854:     return mUseClearTypeAlways;
42854: }
42854: 
42854: PRInt32
63075: gfxWindowsPlatform::WindowsOSVersion(PRInt32 *aBuildNum)
42854: {
42854:     static PRInt32 winVersion = UNINITIALIZED_VALUE;
63075:     static PRInt32 buildNum = UNINITIALIZED_VALUE;
42854: 
42854:     OSVERSIONINFO vinfo;
42854: 
42854:     if (winVersion == UNINITIALIZED_VALUE) {
42854:         vinfo.dwOSVersionInfoSize = sizeof (vinfo);
42854:         if (!GetVersionEx(&vinfo)) {
42854:             winVersion = kWindowsUnknown;
63075:             buildNum = 0;
42854:         } else {
42854:             winVersion = PRInt32(vinfo.dwMajorVersion << 16) + vinfo.dwMinorVersion;
63075:             buildNum = PRInt32(vinfo.dwBuildNumber);
42854:         }
42854:     }
63075: 
63075:     if (aBuildNum) {
63075:         *aBuildNum = buildNum;
63075:     }
63075: 
42854:     return winVersion;
42854: }
42854: 
32950: void 
61526: gfxWindowsPlatform::GetDLLVersion(const PRUnichar *aDLLPath, nsAString& aVersion)
60493: {
60493:     DWORD versInfoSize, vers[4] = {0};
60493:     // version info not available case
60493:     aVersion.Assign(NS_LITERAL_STRING("0.0.0.0"));
60493:     versInfoSize = GetFileVersionInfoSizeW(aDLLPath, NULL);
60493:     nsAutoTArray<BYTE,512> versionInfo;
60493:     
62539:     if (versInfoSize == 0 ||
62539:         !versionInfo.AppendElements(PRUint32(versInfoSize)))
62539:     {
60493:         return;
60493:     }
60493: 
62539:     if (!GetFileVersionInfoW(aDLLPath, 0, versInfoSize, 
62539:            LPBYTE(versionInfo.Elements())))
62539:     {
62539:         return;
62539:     } 
62539: 
62539:     UINT len = 0;
62539:     VS_FIXEDFILEINFO *fileInfo = nsnull;
60493:     if (!VerQueryValue(LPBYTE(versionInfo.Elements()), TEXT("\\"),
62539:            (LPVOID *)&fileInfo, &len) ||
62539:         len == 0 ||
62539:         fileInfo == nsnull)
62539:     {
60493:         return;
60493:     }
60493: 
60493:     DWORD fileVersMS = fileInfo->dwFileVersionMS; 
60493:     DWORD fileVersLS = fileInfo->dwFileVersionLS;
60493: 
60493:     vers[0] = HIWORD(fileVersMS);
60493:     vers[1] = LOWORD(fileVersMS);
60493:     vers[2] = HIWORD(fileVersLS);
60493:     vers[3] = LOWORD(fileVersLS);
60493: 
60493:     char buf[256];
60493:     sprintf(buf, "%d.%d.%d.%d", vers[0], vers[1], vers[2], vers[3]);
60493:     aVersion.Assign(NS_ConvertUTF8toUTF16(buf));
60493: }
60493: 
60493: void 
69664: gfxWindowsPlatform::GetCleartypeParams(nsTArray<ClearTypeParameterInfo>& aParams)
69664: {
69664:     HKEY  hKey, subKey;
69664:     DWORD i, rv, size, type;
69664:     WCHAR displayName[256], subkeyName[256];
69664: 
69664:     aParams.Clear();
69664: 
69664:     // construct subkeys based on HKLM subkeys, assume they are same for HKCU
69664:     rv = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
69664:                        L"Software\\Microsoft\\Avalon.Graphics",
69664:                        0, KEY_READ, &hKey);
69664: 
69664:     if (rv != ERROR_SUCCESS) {
69664:         return;
69664:     }
69664: 
69664:     // enumerate over subkeys
69664:     for (i = 0, rv = ERROR_SUCCESS; rv != ERROR_NO_MORE_ITEMS; i++) {
80467:         size = ArrayLength(displayName);
69664:         rv = RegEnumKeyExW(hKey, i, displayName, &size, NULL, NULL, NULL, NULL);
69664:         if (rv != ERROR_SUCCESS) {
69664:             continue;
69664:         }
69664: 
69664:         ClearTypeParameterInfo ctinfo;
69664:         ctinfo.displayName.Assign(displayName);
69664: 
69664:         DWORD subrv, value;
69664:         bool foundData = false;
69664: 
80467:         swprintf_s(subkeyName, ArrayLength(subkeyName),
69664:                    L"Software\\Microsoft\\Avalon.Graphics\\%s", displayName);
69664: 
69664:         // subkey for gamma, pixel structure
69664:         subrv = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
69664:                               subkeyName, 0, KEY_QUERY_VALUE, &subKey);
69664: 
69664:         if (subrv == ERROR_SUCCESS) {
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"GammaLevel", NULL, &type,
69664:                                      (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.gamma = value;
69664:             }
69664: 
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"PixelStructure", NULL, &type,
69664:                                      (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.pixelStructure = value;
69664:             }
69664: 
69664:             RegCloseKey(subKey);
69664:         }
69664: 
69664:         // subkey for cleartype level, enhanced contrast
69664:         subrv = RegOpenKeyExW(HKEY_CURRENT_USER,
69664:                               subkeyName, 0, KEY_QUERY_VALUE, &subKey);
69664: 
69664:         if (subrv == ERROR_SUCCESS) {
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"ClearTypeLevel", NULL, &type,
69664:                                      (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.clearTypeLevel = value;
69664:             }
69664:       
69664:             size = sizeof(value);
69664:             subrv = RegQueryValueExW(subKey, L"EnhancedContrastLevel",
69664:                                      NULL, &type, (LPBYTE)&value, &size);
69664:             if (subrv == ERROR_SUCCESS && type == REG_DWORD) {
69664:                 foundData = true;
69664:                 ctinfo.enhancedContrast = value;
69664:             }
69664: 
69664:             RegCloseKey(subKey);
69664:         }
69664: 
69664:         if (foundData) {
69664:             aParams.AppendElement(ctinfo);
69664:         }
69664:     }
69664: 
69664:     RegCloseKey(hKey);
69664: }
69664: 
69664: void
71640: gfxWindowsPlatform::FontsPrefsChanged(const char *aPref)
42854: {
79445:     bool clearTextFontCaches = true;
42854: 
71640:     gfxPlatform::FontsPrefsChanged(aPref);
42854: 
42854:     if (!aPref) {
42854:         mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:         mUseClearTypeAlways = UNINITIALIZED_VALUE;
42854:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_USE_CLEARTYPE, aPref)) {
42854:         mUseClearTypeForDownloadableFonts = UNINITIALIZED_VALUE;
42854:     } else if (!strcmp(GFX_USE_CLEARTYPE_ALWAYS, aPref)) {
42854:         mUseClearTypeAlways = UNINITIALIZED_VALUE;
68738:     } else if (!strncmp(GFX_CLEARTYPE_PARAMS, aPref, strlen(GFX_CLEARTYPE_PARAMS))) {
71640:         SetupClearTypeParams();
42854:     } else {
80486:         clearTextFontCaches = false;
42854:     }
42854: 
43347:     if (clearTextFontCaches) {    
42854:         gfxFontCache *fc = gfxFontCache::GetCache();
43347:         if (fc) {
43347:             fc->Flush();
43347:         }
43347:         gfxTextRunWordCache::Flush();
42854:     }
50598: }
63228: 
68738: void
71640: gfxWindowsPlatform::SetupClearTypeParams()
68738: {
68738: #if CAIRO_HAS_DWRITE_FONT
68738:     if (GetDWriteFactory()) {
68738:         // any missing prefs will default to invalid (-1) and be ignored;
68738:         // out-of-range values will also be ignored
68738:         FLOAT gamma = -1.0;
68738:         FLOAT contrast = -1.0;
68738:         FLOAT level = -1.0;
68738:         int geometry = -1;
68738:         int mode = -1;
68738:         PRInt32 value;
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_GAMMA, &value))) {
68738:             if (value >= 1000 && value <= 2200) {
69664:                 gamma = FLOAT(value / 1000.0);
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_CONTRAST, &value))) {
68738:             if (value >= 0 && value <= 1000) {
69664:                 contrast = FLOAT(value / 100.0);
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_LEVEL, &value))) {
68738:             if (value >= 0 && value <= 100) {
69664:                 level = FLOAT(value / 100.0);
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_STRUCTURE, &value))) {
68738:             if (value >= 0 && value <= 2) {
68738:                 geometry = value;
68738:             }
68738:         }
71640: 
71640:         if (NS_SUCCEEDED(Preferences::GetInt(GFX_CLEARTYPE_PARAMS_MODE, &value))) {
68738:             if (value >= 0 && value <= 5) {
68738:                 mode = value;
68738:             }
68738:         }
71640: 
68738:         cairo_dwrite_set_cleartype_params(gamma, contrast, level, geometry, mode);
68738: 
68738:         switch (mode) {
68738:         case DWRITE_RENDERING_MODE_ALIASED:
68738:         case DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC:
68738:             mMeasuringMode = DWRITE_MEASURING_MODE_GDI_CLASSIC;
68738:             break;
68738:         case DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL:
68738:             mMeasuringMode = DWRITE_MEASURING_MODE_GDI_NATURAL;
68738:             break;
68738:         default:
68738:             mMeasuringMode = DWRITE_MEASURING_MODE_NATURAL;
68738:             break;
68738:         }
68738:     }
68738: #endif
68738: }
68738: 
63228: bool
63228: gfxWindowsPlatform::IsOptimus()
63228: {
63228:   return GetModuleHandleA("nvumdshim.dll");
63228: }
