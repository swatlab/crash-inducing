52558: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52558:  * vim: set ts=4 sw=4 et tw=99:
52558:  *
52558:  * ***** BEGIN LICENSE BLOCK *****
52558:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52558:  *
52558:  * The contents of this file are subject to the Mozilla Public License Version
52558:  * 1.1 (the "License"); you may not use this file except in compliance with
52558:  * the License. You may obtain a copy of the License at
52558:  * http://www.mozilla.org/MPL/
52558:  *
52558:  * Software distributed under the License is distributed on an "AS IS" basis,
52558:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52558:  * for the specific language governing rights and limitations under the
52558:  * License.
52558:  *
52558:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52558:  * May 28, 2008.
52558:  *
52558:  * The Initial Developer of the Original Code is
52558:  *   Brendan Eich <brendan@mozilla.org>
52558:  *
52558:  * Contributor(s):
52558:  *   David Anderson <danderson@mozilla.com>
52558:  *   David Mandelin <dmandelin@mozilla.com>
52558:  *
52558:  * Alternatively, the contents of this file may be used under the terms of
52558:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52558:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52558:  * in which case the provisions of the GPL or the LGPL are applicable instead
52558:  * of those above. If you wish to allow use of your version of this file only
52558:  * under the terms of either the GPL or the LGPL, and not to allow others to
52558:  * use your version of this file under the terms of the MPL, indicate your
52558:  * decision by deleting the provisions above and replace them with the notice
52558:  * and other provisions required by the GPL or the LGPL. If you do not delete
52558:  * the provisions above, a recipient may use your version of this file under
52558:  * the terms of any one of the MPL, the GPL or the LGPL.
52558:  *
52558:  * ***** END LICENSE BLOCK ***** */
52558: #if !defined jsjaeger_compiler_h__ && defined JS_METHODJIT
52558: #define jsjaeger_compiler_h__
52558: 
56602: #include "jsanalyze.h"
52558: #include "jscntxt.h"
52558: #include "jstl.h"
52558: #include "MethodJIT.h"
52606: #include "CodeGenIncludes.h"
55463: #include "BaseCompiler.h"
52608: #include "StubCompiler.h"
52831: #include "MonoIC.h"
52880: #include "PolyIC.h"
52558: 
52558: namespace js {
52558: namespace mjit {
52558: 
55463: class Compiler : public BaseCompiler
52558: {
57766:     friend class StubCompiler;
57766: 
52599:     struct BranchPatch {
52599:         BranchPatch(const Jump &j, jsbytecode *pc)
52599:           : jump(j), pc(pc)
52599:         { }
52599: 
52599:         Jump jump;
52599:         jsbytecode *pc;
52599:     };
52599: 
53119: #if defined JS_MONOIC
62386:     struct GlobalNameICInfo {
62385:         Label fastPathStart;
62386:         Call slowPathCall;
62386:         DataLabel32 shape;
62386:         DataLabelPtr addrLabel;
62386:         bool usePropertyCache;
62386: 
62386:         void copyTo(ic::GlobalNameIC &to, JSC::LinkBuffer &full, JSC::LinkBuffer &stub) {
62386:             to.fastPathStart = full.locationOf(fastPathStart);
62386: 
62386:             int offset = full.locationOf(shape) - to.fastPathStart;
62386:             to.shapeOffset = offset;
62386:             JS_ASSERT(to.shapeOffset == offset);
62386: 
62386:             to.slowPathCall = stub.locationOf(slowPathCall);
62386:             to.usePropertyCache = usePropertyCache;
62386:         }
62386:     };
62386: 
62386:     struct GetGlobalNameICInfo : public GlobalNameICInfo {
62386:         Label load;
62386:     };
62386: 
62386:     struct SetGlobalNameICInfo : public GlobalNameICInfo {
62385:         Label slowPathStart;
62385:         Label fastPathRejoin;
60637:         DataLabel32 store;
62385:         Jump shapeGuardJump;
62385:         ValueRemat vr;
62385:         RegisterID objReg;
62385:         RegisterID shapeReg;
62385:         bool objConst;
52826:     };
53590: 
56192:     struct EqualityGenInfo {
56192:         DataLabelPtr addrLabel;
56192:         Label stubEntry;
56192:         Call stubCall;
56192:         BoolStub stub;
56192:         MaybeJump jumpToStub;
56192:         Label fallThrough;
56192:         jsbytecode *jumpTarget;
56192:         ValueRemat lvr, rvr;
56192:         Assembler::Condition cond;
56192:         JSC::MacroAssembler::RegisterID tempReg;
56192:     };
56192:     
56217:     struct TraceGenInfo {
56220:         bool initialized;
56217:         Label stubEntry;
56217:         DataLabelPtr addrLabel;
56217:         jsbytecode *jumpTarget;
56217:         Jump traceHint;
56217:         MaybeJump slowTraceHint;
56220: 
56220:         TraceGenInfo() : initialized(false) {}
56217:     };
56217: 
53590:     /* InlineFrameAssembler wants to see this. */
68952:   public:
68952:     struct CallGenInfo {
68952:         CallGenInfo(jsbytecode *pc) : pc(pc) {}
68952: 
68952:         /*
68952:          * These members map to members in CallICInfo. See that structure for
68952:          * more comments.
68952:          */
68952:         jsbytecode   *pc;
68952:         DataLabelPtr funGuard;
68952:         Jump         funJump;
68952:         Jump         hotJump;
68952:         Call         oolCall;
68952:         Label        joinPoint;
68952:         Label        slowJoinPoint;
68952:         Label        slowPathStart;
68952:         Label        hotPathLabel;
68952:         DataLabelPtr addrLabel1;
68952:         DataLabelPtr addrLabel2;
68952:         Jump         oolJump;
68952:         Label        icCall;
68952:         RegisterID   funObjReg;
68952:         RegisterID   funPtrReg;
68952:         FrameSize    frameSize;
68952:     };
68952: 
53590:   private:
53119: #endif
52826: 
68952:     /*
68952:      * Writes of call return addresses which needs to be delayed until the final
68952:      * absolute address of the join point is known.
68952:      */
68952:     struct CallPatchInfo {
68952:         CallPatchInfo() : hasFastNcode(false), hasSlowNcode(false) {}
68952:         Label joinPoint;
68952:         DataLabelPtr fastNcodePatch;
68952:         DataLabelPtr slowNcodePatch;
68952:         bool hasFastNcode;
68952:         bool hasSlowNcode;
68952:     };
68952: 
56575:     struct BaseICInfo {
56738:         BaseICInfo(JSOp op) : op(op)
56738:         { }
56575:         Label fastPathStart;
56575:         Label fastPathRejoin;
56575:         Label slowPathStart;
56575:         Call slowPathCall;
56575:         DataLabelPtr paramAddr;
56738:         JSOp op;
56738: 
56738:         void copyTo(ic::BaseIC &to, JSC::LinkBuffer &full, JSC::LinkBuffer &stub) {
56738:             to.fastPathStart = full.locationOf(fastPathStart);
56738:             to.fastPathRejoin = full.locationOf(fastPathRejoin);
56738:             to.slowPathStart = stub.locationOf(slowPathStart);
56738:             to.slowPathCall = stub.locationOf(slowPathCall);
56738:             to.op = op;
56738:             JS_ASSERT(to.op == op);
56738:         }
56738:     };
56738: 
56738:     struct GetElementICInfo : public BaseICInfo {
56738:         GetElementICInfo(JSOp op) : BaseICInfo(op)
56738:         { }
56738:         RegisterID  typeReg;
56738:         RegisterID  objReg;
56738:         ValueRemat  id;
56738:         MaybeJump   typeGuard;
56738:         Jump        claspGuard;
56575:     };
56575: 
57671:     struct SetElementICInfo : public BaseICInfo {
57671:         SetElementICInfo(JSOp op) : BaseICInfo(op)
57671:         { }
57671:         RegisterID  objReg;
57671:         StateRemat  objRemat;
57671:         ValueRemat  vr;
57671:         Jump        capacityGuard;
57671:         Jump        claspGuard;
57671:         Jump        holeGuard;
57671:         Int32Key    key;
60164:         uint32      volatileMask;
57671:     };
57671: 
56575:     struct PICGenInfo : public BaseICInfo {
56738:         PICGenInfo(ic::PICInfo::Kind kind, JSOp op, bool usePropCache)
56738:           : BaseICInfo(op), kind(kind), usePropCache(usePropCache)
52880:         { }
52880:         ic::PICInfo::Kind kind;
52884:         Label typeCheck;
52880:         RegisterID shapeReg;
52880:         RegisterID objReg;
52884:         RegisterID typeReg;
56201:         bool usePropCache;
52880:         Label shapeGuard;
56551:         jsbytecode *pc;
52892:         JSAtom *atom;
52884:         bool hasTypeCheck;
52887:         ValueRemat vr;
60590: #ifdef JS_HAS_IC_LABELS
60590:         union {
60590:             ic::GetPropLabels getPropLabels_;
60590:             ic::SetPropLabels setPropLabels_;
60590:             ic::BindNameLabels bindNameLabels_;
60594:             ic::ScopeNameLabels scopeNameLabels_;
60590:         };
60590: 
60590:         ic::GetPropLabels &getPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::GET || kind == ic::PICInfo::CALL);
60590:             return getPropLabels_;
60590:         }
60590:         ic::SetPropLabels &setPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::SET || kind == ic::PICInfo::SETMETHOD);
60590:             return setPropLabels_;
60590:         }
60590:         ic::BindNameLabels &bindNameLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::BIND);
60590:             return bindNameLabels_;
60590:         }
60594:         ic::ScopeNameLabels &scopeNameLabels() {
71340:             JS_ASSERT(kind == ic::PICInfo::NAME || kind == ic::PICInfo::CALLNAME ||
71340:                       kind == ic::PICInfo::XNAME);
60594:             return scopeNameLabels_;
60594:         }
60590: #else
60590:         ic::GetPropLabels &getPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::GET || kind == ic::PICInfo::CALL);
60590:             return ic::PICInfo::getPropLabels_;
60590:         }
60590:         ic::SetPropLabels &setPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::SET || kind == ic::PICInfo::SETMETHOD);
60590:             return ic::PICInfo::setPropLabels_;
60590:         }
60590:         ic::BindNameLabels &bindNameLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::BIND);
60590:             return ic::PICInfo::bindNameLabels_;
60590:         }
60594:         ic::ScopeNameLabels &scopeNameLabels() {
71340:             JS_ASSERT(kind == ic::PICInfo::NAME || kind == ic::PICInfo::CALLNAME ||
71340:                       kind == ic::PICInfo::XNAME);
60594:             return ic::PICInfo::scopeNameLabels_;
60594:         }
53315: #endif
53137: 
60590:         void copySimpleMembersTo(ic::PICInfo &ic) {
56575:             ic.kind = kind;
56575:             ic.shapeReg = shapeReg;
56575:             ic.objReg = objReg;
56575:             ic.atom = atom;
56575:             ic.usePropCache = usePropCache;
56575:             if (ic.isSet()) {
56575:                 ic.u.vr = vr;
56575:             } else if (ic.isGet()) {
56575:                 ic.u.get.typeReg = typeReg;
56575:                 ic.u.get.hasTypeCheck = hasTypeCheck;
53137:             }
60590: #ifdef JS_HAS_IC_LABELS
60590:             if (ic.isGet())
60590:                 ic.setLabels(getPropLabels());
60590:             else if (ic.isSet())
60590:                 ic.setLabels(setPropLabels());
60593:             else if (ic.isBind())
60590:                 ic.setLabels(bindNameLabels());
60594:             else if (ic.isScopeName())
60594:                 ic.setLabels(scopeNameLabels());
60590: #endif
53137:         }
53137: 
52880:     };
52880: 
52611:     struct Defs {
52611:         Defs(uint32 ndefs)
52611:           : ndefs(ndefs)
52611:         { }
52611:         uint32 ndefs;
52611:     };
52611: 
53168:     struct InternalCallSite {
57766:         uint32 returnOffset;
53168:         jsbytecode *pc;
53168:         uint32 id;
57766:         bool call;
57766:         bool ool;
57766: 
57766:         InternalCallSite(uint32 returnOffset, jsbytecode *pc, uint32 id,
57766:                          bool call, bool ool)
57766:           : returnOffset(returnOffset), pc(pc), id(id), call(call), ool(ool)
57766:         { }
53168:     };
53168: 
53183:     struct DoublePatch {
53183:         double d;
53183:         DataLabelPtr label;
53183:         bool ool;
53183:     };
53183: 
59979:     struct JumpTable {
59979:         DataLabelPtr label;
59979:         size_t offsetIndex;
59979:     };
59979: 
69223:     StackFrame *fp;
52558:     JSScript *script;
52558:     JSObject *scopeChain;
52558:     JSObject *globalObj;
52560:     JSFunction *fun;
55503:     bool isConstructing;
56602:     analyze::Script *analysis;
52558:     Label *jumpMap;
57766:     bool *savedTraps;
52558:     jsbytecode *PC;
52608:     Assembler masm;
52560:     FrameState frame;
57679:     js::Vector<BranchPatch, 64, CompilerAllocPolicy> branchPatches;
53119: #if defined JS_MONOIC
62386:     js::Vector<GetGlobalNameICInfo, 16, CompilerAllocPolicy> getGlobalNames;
62386:     js::Vector<SetGlobalNameICInfo, 16, CompilerAllocPolicy> setGlobalNames;
68952:     js::Vector<CallGenInfo, 64, CompilerAllocPolicy> callICs;
57679:     js::Vector<EqualityGenInfo, 64, CompilerAllocPolicy> equalityICs;
57679:     js::Vector<TraceGenInfo, 64, CompilerAllocPolicy> traceICs;
53119: #endif
53119: #if defined JS_POLYIC
57679:     js::Vector<PICGenInfo, 16, CompilerAllocPolicy> pics;
57679:     js::Vector<GetElementICInfo, 16, CompilerAllocPolicy> getElemICs;
57679:     js::Vector<SetElementICInfo, 16, CompilerAllocPolicy> setElemICs;
53119: #endif
68952:     js::Vector<CallPatchInfo, 64, CompilerAllocPolicy> callPatches;
57679:     js::Vector<InternalCallSite, 64, CompilerAllocPolicy> callSites;
57679:     js::Vector<DoublePatch, 16, CompilerAllocPolicy> doubleList;
59979:     js::Vector<JumpTable, 16> jumpTables;
59979:     js::Vector<uint32, 16> jumpTableOffsets;
74731:     js::Vector<JSObject *, 0, CompilerAllocPolicy> rootedObjects;
52608:     StubCompiler stubcc;
52872:     Label invokeLabel;
53590:     Label arityLabel;
57766:     bool debugMode_;
53133:     bool addTraceHints;
57679:     bool oomInVector;       // True if we have OOM'd appending to a vector. 
57718:     enum { NoApplyTricks, LazyArgsObj } applyTricks;
69852: #ifdef DEBUG
69852:     int *pcProfile;
69852: #endif
52599: 
56774:     Compiler *thisFromCtor() { return this; }
57679: 
57679:     friend class CompilerAllocPolicy;
52558:   public:
69659:     // Special atom index used to indicate that the atom is 'length'. This
69659:     // follows interpreter usage in JSOP_LENGTH.
69659:     enum { LengthAtomIndex = uint32(-2) };
69659: 
69223:     Compiler(JSContext *cx, StackFrame *fp);
52558:     ~Compiler();
52558: 
55503:     CompileStatus compile();
52558: 
52608:     jsbytecode *getPC() { return PC; }
52611:     Label getLabel() { return masm.label(); }
52653:     bool knownJump(jsbytecode *pc);
52653:     Label labelOf(jsbytecode *target);
53168:     void *findCallSite(const CallSite &callSite);
57766:     void addCallSite(const InternalCallSite &callSite);
57766:     void addReturnSite(Label joinPoint, uint32 id);
57766:     bool loadOldTraps(const Vector<CallSite> &site);
57766: 
57766:     bool debugMode() { return debugMode_; }
52608: 
52558:   private:
55503:     CompileStatus performCompilation(JITScript **jitp);
52558:     CompileStatus generatePrologue();
52558:     CompileStatus generateMethod();
52558:     CompileStatus generateEpilogue();
55503:     CompileStatus finishThisUp(JITScript **jitp);
52560: 
52560:     /* Non-emitting helpers. */
52560:     uint32 fullAtomIndex(jsbytecode *pc);
56766:     bool jumpInScript(Jump j, jsbytecode *pc);
52651:     bool compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs);
57718:     bool canUseApplyTricks();
52560: 
52645:     /* Emitting helpers. */
53133:     void restoreFrameRegs(Assembler &masm);
56766:     bool emitStubCmpOp(BoolStub stub, jsbytecode *target, JSOp fused);
61055:     bool iter(uintN flags);
74052:     void iterNext(ptrdiff_t offset);
56766:     bool iterMore();
53404:     void iterEnd();
53152:     MaybeJump loadDouble(FrameEntry *fe, FPRegisterID fpReg);
55503: #ifdef JS_POLYIC
56738:     void passICAddress(BaseICInfo *ic);
55503: #endif
55503: #ifdef JS_MONOIC
62386:     void passMICAddress(GlobalNameICInfo &mic);
55503: #endif
56037:     bool constructThis();
52645: 
52560:     /* Opcode handlers. */
56766:     bool jumpAndTrace(Jump j, jsbytecode *target, Jump *slow = NULL);
60526:     void jsop_bindname(JSAtom *atom, bool usePropCache);
52560:     void jsop_setglobal(uint32 index);
52560:     void jsop_getglobal(uint32 index);
56202:     void jsop_getprop_slow(JSAtom *atom, bool usePropCache = true);
56586:     void jsop_getarg(uint32 slot);
56586:     void jsop_setarg(uint32 slot, bool popped);
52741:     void jsop_this();
54832:     void emitReturn(FrameEntry *fe);
54832:     void emitFinalReturn(Assembler &masm);
55503:     void loadReturnValue(Assembler *masm, FrameEntry *fe);
55503:     void emitReturnValue(Assembler *masm, FrameEntry *fe);
52847:     void dispatchCall(VoidPtrStubUInt32 stub, uint32 argc);
53223:     void interruptCheckHelper();
68952:     void emitUncachedCall(uint32 argc, bool callingNew);
68952:     void checkCallApplySpeculation(uint32 callImmArgc, uint32 speculatedArgc,
68952:                                    FrameEntry *origCallee, FrameEntry *origThis,
68952:                                    MaybeRegisterID origCalleeType, RegisterID origCalleeData,
68952:                                    MaybeRegisterID origThisType, RegisterID origThisData,
68952:                                    Jump *uncachedCallSlowRejoin, CallPatchInfo *uncachedCallPatch);
52850:     void inlineCallHelper(uint32 argc, bool callingNew);
55503:     void fixPrimitiveReturn(Assembler *masm, FrameEntry *fe);
53118:     void jsop_gnameinc(JSOp op, VoidStubAtom stub, uint32 index);
56037:     bool jsop_nameinc(JSOp op, VoidStubAtom stub, uint32 index);
56037:     bool jsop_propinc(JSOp op, VoidStubAtom stub, uint32 index);
52815:     void jsop_eleminc(JSOp op, VoidStub);
52826:     void jsop_getgname(uint32 index);
52826:     void jsop_getgname_slow(uint32 index);
63236:     void jsop_callgname_epilogue();
60526:     void jsop_setgname(JSAtom *atom, bool usePropertyCache);
60526:     void jsop_setgname_slow(JSAtom *atom, bool usePropertyCache);
52826:     void jsop_bindgname();
52838:     void jsop_setelem_slow();
52843:     void jsop_getelem_slow();
57723:     void jsop_callelem_slow();
52874:     void jsop_unbrand();
56201:     bool jsop_getprop(JSAtom *atom, bool typeCheck = true, bool usePropCache = true);
69659:     bool jsop_length();
56201:     bool jsop_setprop(JSAtom *atom, bool usePropCache = true);
56201:     void jsop_setprop_slow(JSAtom *atom, bool usePropCache = true);
52903:     bool jsop_callprop_slow(JSAtom *atom);
52903:     bool jsop_callprop(JSAtom *atom);
52903:     bool jsop_callprop_obj(JSAtom *atom);
52903:     bool jsop_callprop_str(JSAtom *atom);
52906:     bool jsop_callprop_generic(JSAtom *atom);
56037:     bool jsop_instanceof();
71340:     void jsop_name(JSAtom *atom, bool isCall);
56037:     bool jsop_xname(JSAtom *atom);
54840:     void enterBlock(JSObject *obj);
54840:     void leaveBlock();
56775:     void emitEval(uint32 argc);
57718:     void jsop_arguments();
61233:     bool jsop_tableswitch(jsbytecode *pc);
52611: 
52963:     /* Fast arithmetic. */
52963:     void jsop_binary(JSOp op, VoidStub stub);
53152:     void jsop_binary_full(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub);
53152:     void jsop_binary_full_simple(FrameEntry *fe, JSOp op, VoidStub stub);
53152:     void jsop_binary_double(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub);
52963:     void slowLoadConstantDouble(Assembler &masm, FrameEntry *fe,
52963:                                 FPRegisterID fpreg);
52963:     void maybeJumpIfNotInt32(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                              MaybeRegisterID &mreg);
52963:     void maybeJumpIfNotDouble(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                               MaybeRegisterID &mreg);
56766:     bool jsop_relational(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_relational_self(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_relational_full(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_relational_double(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
53201: 
53201:     void emitLeftDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                             MaybeJump &lhsNotDouble, MaybeJump &rhsNotNumber,
53201:                             MaybeJump &lhsUnknownDone);
53201:     void emitRightDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                              MaybeJump &rhsNotNumber2);
53318:     bool tryBinaryConstantFold(JSContext *cx, FrameState &frame, JSOp op,
53318:                                FrameEntry *lhs, FrameEntry *rhs);
52963: 
52617:     /* Fast opcodes. */
52617:     void jsop_bitop(JSOp op);
53230:     void jsop_rsh();
53230:     RegisterID rightRegForShift(FrameEntry *rhs);
53230:     void jsop_rsh_int_int(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_const_int(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_int_const(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_int_unknown(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_const_const(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_const_unknown(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_unknown_const(FrameEntry *lhs, FrameEntry *rhs);
53238:     void jsop_rsh_unknown_any(FrameEntry *lhs, FrameEntry *rhs);
53156:     void jsop_mod();
52713:     void jsop_neg();
52724:     void jsop_bitnot();
52734:     void jsop_not();
52738:     void jsop_typeof();
56766:     bool booleanJumpScript(JSOp op, jsbytecode *target);
56766:     bool jsop_ifneq(JSOp op, jsbytecode *target);
56766:     bool jsop_andor(JSOp op, jsbytecode *target);
52804:     void jsop_arginc(JSOp op, uint32 slot, bool popped);
52808:     void jsop_localinc(JSOp op, uint32 slot, bool popped);
58056:     void jsop_newinit();
58056:     void jsop_initmethod();
58056:     void jsop_initprop();
58056:     void jsop_initelem();
60164:     bool jsop_setelem(bool popGuaranteed);
57723:     bool jsop_getelem(bool isCall);
56775:     bool isCacheableBaseAndIndex(FrameEntry *obj, FrameEntry *id);
52855:     void jsop_stricteq(JSOp op);
56766:     bool jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_equality_int_string(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
52916:     void jsop_pos();
52617: 
52611:    
57766:     void prepareStubCall(Uses uses);
57766:     Call emitStubCall(void *ptr);
57766: };
52611: 
57766: // Given a stub call, emits the call into the inline assembly path. If
57766: // debug mode is on, adds the appropriate instrumentation for recompilation.
57766: #define INLINE_STUBCALL(stub)                                               \
57766:     do {                                                                    \
57766:         Call cl = emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)));        \
57766:         if (debugMode()) {                                                  \
57766:             InternalCallSite site(masm.callReturnOffset(cl), PC, __LINE__,  \
57766:                                   true, false);                             \
57766:             addCallSite(site);                                              \
57766:         }                                                                   \
57766:     } while (0)                                                             \
57766: 
57766: // Given a stub call, emits the call into the out-of-line assembly path. If
57766: // debug mode is on, adds the appropriate instrumentation for recompilation.
57766: // Unlike the INLINE_STUBCALL variant, this returns the Call offset.
57766: #define OOL_STUBCALL(stub)                                                      \
57766:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), __LINE__)          \
57766: 
57766: // Same as OOL_STUBCALL, but specifies a slot depth.
57787: #define OOL_STUBCALL_LOCAL_SLOTS(stub, slots)                                   \
57766:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), (slots), __LINE__) \
52558: 
52558: } /* namespace js */
52558: } /* namespace mjit */
52558: 
52558: #endif
52611: 
