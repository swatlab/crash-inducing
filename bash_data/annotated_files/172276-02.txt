131499: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/
131499: /* This Source Code Form is subject to the terms of the Mozilla Public
131499:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
131499:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
131499: 
131499: #ifndef MOZILLA_AUDIONODESTREAM_H_
131499: #define MOZILLA_AUDIONODESTREAM_H_
131499: 
131499: #include "MediaStreamGraph.h"
142233: #include "mozilla/dom/AudioNodeBinding.h"
159607: #include "AudioSegment.h"
131499: 
172276: #ifdef PR_LOGGING
172276: #define LOG(type, msg) PR_LOG(gMediaStreamGraphLog, type, msg)
172276: #else
172276: #define LOG(type, msg)
172276: #endif
172276: 
131499: namespace mozilla {
131499: 
135768: namespace dom {
135768: struct ThreeDPoint;
142514: class AudioParamTimeline;
162685: class DelayNodeEngine;
135768: }
135768: 
131499: class ThreadSharedFloatArrayBufferList;
159607: class AudioNodeEngine;
131499: 
131499: /**
131499:  * An AudioNodeStream produces one audio track with ID AUDIO_TRACK.
131499:  * The start time of the AudioTrack is aligned to the start time of the
131499:  * AudioContext's destination node stream, plus some multiple of BLOCK_SIZE
131499:  * samples.
131499:  *
131499:  * An AudioNodeStream has an AudioNodeEngine plugged into it that does the
131499:  * actual audio processing. AudioNodeStream contains the glue code that
131499:  * integrates audio processing with the MediaStreamGraph.
131499:  */
131499: class AudioNodeStream : public ProcessedMediaStream {
131499: public:
131499:   enum { AUDIO_TRACK = 1 };
131499: 
142677:   typedef nsAutoTArray<AudioChunk, 1> OutputChunks;
142677: 
131499:   /**
131499:    * Transfers ownership of aEngine to the new AudioNodeStream.
131499:    */
136389:   AudioNodeStream(AudioNodeEngine* aEngine,
145276:                   MediaStreamGraph::AudioNodeStreamKind aKind,
145276:                   TrackRate aSampleRate)
136389:     : ProcessedMediaStream(nullptr),
136389:       mEngine(aEngine),
145276:       mSampleRate(aSampleRate),
141208:       mKind(aKind),
142236:       mNumberOfInputChannels(2),
142514:       mMarkAsFinishedAfterThisBlock(false),
162685:       mAudioParamStream(false),
162685:       mMuted(false)
131499:   {
145276:     MOZ_ASSERT(NS_IsMainThread());
142904:     mChannelCountMode = dom::ChannelCountMode::Max;
142904:     mChannelInterpretation = dom::ChannelInterpretation::Speakers;
136819:     // AudioNodes are always producing data
136819:     mHasCurrentData = true;
138695:     MOZ_COUNT_CTOR(AudioNodeStream);
131499:   }
131499:   ~AudioNodeStream();
131499: 
131499:   // Control API
131499:   /**
131499:    * Sets a parameter that's a time relative to some stream's played time.
131499:    * This time is converted to a time relative to this stream when it's set.
131499:    */
131499:   void SetStreamTimeParameter(uint32_t aIndex, MediaStream* aRelativeToStream,
131499:                               double aStreamTime);
131499:   void SetDoubleParameter(uint32_t aIndex, double aValue);
131499:   void SetInt32Parameter(uint32_t aIndex, int32_t aValue);
131505:   void SetTimelineParameter(uint32_t aIndex, const dom::AudioParamTimeline& aValue);
135768:   void SetThreeDPointParameter(uint32_t aIndex, const dom::ThreeDPoint& aValue);
131499:   void SetBuffer(already_AddRefed<ThreadSharedFloatArrayBufferList> aBuffer);
144191:   // This consumes the contents of aData.  aData will be emptied after this returns.
144191:   void SetRawArrayData(nsTArray<float>& aData);
142233:   void SetChannelMixingParameters(uint32_t aNumberOfChannels,
142233:                                   dom::ChannelCountMode aChannelCountMoe,
142233:                                   dom::ChannelInterpretation aChannelInterpretation);
142514:   void SetAudioParamHelperStream()
142514:   {
142514:     MOZ_ASSERT(!mAudioParamStream, "Can only do this once");
142514:     mAudioParamStream = true;
142514:   }
131499: 
131499:   virtual AudioNodeStream* AsAudioNodeStream() { return this; }
131499: 
131499:   // Graph thread only
131499:   void SetStreamTimeParameterImpl(uint32_t aIndex, MediaStream* aRelativeToStream,
131499:                                   double aStreamTime);
142233:   void SetChannelMixingParametersImpl(uint32_t aNumberOfChannels,
142233:                                       dom::ChannelCountMode aChannelCountMoe,
142233:                                       dom::ChannelInterpretation aChannelInterpretation);
131499:   virtual void ProduceOutput(GraphTime aFrom, GraphTime aTo);
131499:   TrackTicks GetCurrentPosition();
142514:   bool IsAudioParamStream() const
142514:   {
142514:     return mAudioParamStream;
142514:   }
162685:   void Mute() {
162685:     mMuted = true;
162685:   }
162685: 
162685:   void Unmute() {
162685:     mMuted = false;
162685:   }
162685: 
142677:   const OutputChunks& LastChunks() const
142515:   {
142677:     return mLastChunks;
142515:   }
147977:   virtual bool MainThreadNeedsUpdates() const MOZ_OVERRIDE
147977:   {
147977:     // Only source and external streams need updates on the main thread.
147977:     return (mKind == MediaStreamGraph::SOURCE_STREAM && mFinished) ||
147977:            mKind == MediaStreamGraph::EXTERNAL_STREAM;
147977:   }
155434:   virtual bool IsIntrinsicallyConsumed() const MOZ_OVERRIDE
155434:   {
155434:     return true;
155434:   }
131499: 
131499:   // Any thread
131499:   AudioNodeEngine* Engine() { return mEngine; }
145276:   TrackRate SampleRate() const { return mSampleRate; }
131499: 
131499: protected:
155434:   void AdvanceOutputSegment();
131499:   void FinishOutput();
155434:   void AccumulateInputChunk(uint32_t aInputIndex, const AudioChunk& aChunk,
155434:                             AudioChunk* aBlock,
155434:                             nsTArray<float>* aDownmixBuffer);
155434:   void UpMixDownMixChunk(const AudioChunk* aChunk, uint32_t aOutputChannelCount,
155434:                          nsTArray<const void*>& aOutputChannels,
155434:                          nsTArray<float>& aDownmixBuffer);
131499: 
155434:   uint32_t ComputeFinalOuputChannelCount(uint32_t aInputChannelCount);
142677:   void ObtainInputBlock(AudioChunk& aTmpChunk, uint32_t aPortIndex);
131499: 
131499:   // The engine that will generate output for this node.
131499:   nsAutoPtr<AudioNodeEngine> mEngine;
131499:   // The last block produced by this node.
142677:   OutputChunks mLastChunks;
145276:   // The stream's sampling rate
145276:   const TrackRate mSampleRate;
136389:   // Whether this is an internal or external stream
136389:   MediaStreamGraph::AudioNodeStreamKind mKind;
141208:   // The number of input channels that this stream requires. 0 means don't care.
141208:   uint32_t mNumberOfInputChannels;
142233:   // The mixing modes
142904:   dom::ChannelCountMode mChannelCountMode;
142904:   dom::ChannelInterpretation mChannelInterpretation;
142236:   // Whether the stream should be marked as finished as soon
142236:   // as the current time range has been computed block by block.
142236:   bool mMarkAsFinishedAfterThisBlock;
142514:   // Whether the stream is an AudioParamHelper stream.
142514:   bool mAudioParamStream;
162685:   // Whether the stream is muted. Access only on the MediaStreamGraph thread.
162685:   bool mMuted;
131499: };
131499: 
131499: }
131499: 
131499: #endif /* MOZILLA_AUDIONODESTREAM_H_ */
