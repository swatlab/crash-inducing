146904: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
146904: /* This Source Code Form is subject to the terms of the Mozilla Public
146904:  * License, v. 2.0. If a copy of the MPL was not distributed with this
146904:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
146904: 
162733: #include "WebVTTListener.h"
146904: #include "mozilla/dom/TextTrackCue.h"
163092: #include "mozilla/dom/TextTrackRegion.h"
163092: #include "mozilla/dom/VTTRegionBinding.h"
159607: #include "mozilla/dom/HTMLTrackElement.h"
159846: #include "nsIInputStream.h"
162733: #include "nsIWebVTTParserWrapper.h"
162733: #include "nsComponentManagerUtils.h"
146904: 
146904: namespace mozilla {
146904: namespace dom {
146904: 
162733: NS_IMPL_CYCLE_COLLECTION_2(WebVTTListener, mElement, mParserWrapper)
146904: 
162733: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WebVTTListener)
162733:   NS_INTERFACE_MAP_ENTRY(nsIWebVTTListener)
146904:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
146904:   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
146904:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
162733:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebVTTListener)
146904: NS_INTERFACE_MAP_END
146904: 
162733: NS_IMPL_CYCLE_COLLECTING_ADDREF(WebVTTListener)
162733: NS_IMPL_CYCLE_COLLECTING_RELEASE(WebVTTListener)
146904: 
146904: #ifdef PR_LOGGING
146904: PRLogModuleInfo* gTextTrackLog;
172276: # define LOG(...) PR_LOG(gTextTrackLog, PR_LOG_DEBUG, (__VA_ARGS__))
146904: #else
172276: # define LOG(msg)
146904: #endif
146904: 
162733: WebVTTListener::WebVTTListener(HTMLTrackElement* aElement)
146904:   : mElement(aElement)
146904: {
146904:   MOZ_ASSERT(mElement, "Must pass an element to the callback");
146904: #ifdef PR_LOGGING
146904:   if (!gTextTrackLog) {
146904:     gTextTrackLog = PR_NewLogModule("TextTrack");
146904:   }
146904: #endif
172276:   LOG("WebVTTListener created.");
146904: }
146904: 
162733: WebVTTListener::~WebVTTListener()
146904: {
172276:   LOG("WebVTTListener destroyed.");
162733: }
162733: 
162733: NS_IMETHODIMP
162733: WebVTTListener::GetInterface(const nsIID &aIID,
162733:                              void** aResult)
162733: {
162733:   return QueryInterface(aIID, aResult);
146904: }
146904: 
146904: nsresult
162733: WebVTTListener::LoadResource()
146904: {
146904:   if (!HTMLTrackElement::IsWebVTTEnabled()) {
146904:     NS_WARNING("WebVTT support disabled."
146904:                " See media.webvtt.enabled in about:config. ");
146904:     return NS_ERROR_FAILURE;
146904:   }
162733:   nsresult rv;
162733:   mParserWrapper = do_CreateInstance(NS_WEBVTTPARSERWRAPPER_CONTRACTID, &rv);
162733:   NS_ENSURE_SUCCESS(rv, rv);
146904: 
162733:   nsPIDOMWindow* window = mElement->OwnerDoc()->GetWindow();
162733:   rv = mParserWrapper->LoadParser(window);
162733:   NS_ENSURE_SUCCESS(rv, rv);
162733: 
162733:   rv = mParserWrapper->Watch(this);
162733:   NS_ENSURE_SUCCESS(rv, rv);
146904: 
166895:   mElement->mTrack->SetReadyState(HTMLTrackElement::LOADING);
146904:   return NS_OK;
146904: }
146904: 
146904: NS_IMETHODIMP
162733: WebVTTListener::AsyncOnChannelRedirect(nsIChannel* aOldChannel,
162733:                                        nsIChannel* aNewChannel,
162733:                                        uint32_t aFlags,
162733:                                        nsIAsyncVerifyRedirectCallback* cb)
162733: {
162733:   if (mElement) {
162733:     mElement->OnChannelRedirect(aOldChannel, aNewChannel, aFlags);
162733:   }
162733:   return NS_OK;
162733: }
162733: 
162733: NS_IMETHODIMP
162733: WebVTTListener::OnStartRequest(nsIRequest* aRequest,
146904:                                nsISupports* aContext)
146904: {
146904:   return NS_OK;
146904: }
146904: 
146904: NS_IMETHODIMP
162733: WebVTTListener::OnStopRequest(nsIRequest* aRequest,
146904:                               nsISupports* aContext,
146904:                               nsresult aStatus)
146904: {
166895:   if (mElement->ReadyState() != HTMLTrackElement::ERROR) {
168067:     TextTrack* track = mElement->Track();
168067:     track->SetReadyState(HTMLTrackElement::LOADED);
147467:   }
162733:   // Attempt to parse any final data the parser might still have.
162733:   mParserWrapper->Flush();
162733:   return NS_OK;
162733: }
162733: 
162733: NS_METHOD
162733: WebVTTListener::ParseChunk(nsIInputStream* aInStream, void* aClosure,
162733:                            const char* aFromSegment, uint32_t aToOffset,
162733:                            uint32_t aCount, uint32_t* aWriteCount)
162733: {
162733:   nsCString buffer(aFromSegment, aCount);
162733:   WebVTTListener* listener = static_cast<WebVTTListener*>(aClosure);
162733: 
162733:   if (NS_FAILED(listener->mParserWrapper->Parse(buffer))) {
172276:     LOG("Unable to parse chunk of WEBVTT text. Aborting.");
162733:     *aWriteCount = 0;
162733:     return NS_ERROR_FAILURE;
162733:   }
162733: 
162733:   *aWriteCount = aCount;
146904:   return NS_OK;
146904: }
146904: 
146904: NS_IMETHODIMP
162733: WebVTTListener::OnDataAvailable(nsIRequest* aRequest,
146904:                                 nsISupports* aContext,
146904:                                 nsIInputStream* aStream,
146904:                                 uint64_t aOffset,
146904:                                 uint32_t aCount)
146904: {
146904:   uint32_t count = aCount;
146904:   while (count > 0) {
146904:     uint32_t read;
146904:     nsresult rv = aStream->ReadSegments(ParseChunk, this, count, &read);
146904:     NS_ENSURE_SUCCESS(rv, rv);
146904:     if (!read) {
146904:       return NS_ERROR_FAILURE;
146904:     }
146904:     count -= read;
146904:   }
146904: 
146904:   return NS_OK;
146904: }
146904: 
146904: NS_IMETHODIMP
162733: WebVTTListener::OnCue(const JS::Value &aCue, JSContext* aCx)
146904: {
162733:   if (!aCue.isObject()) {
162733:     return NS_ERROR_FAILURE;
146904:   }
162733: 
162733:   TextTrackCue* cue;
162733:   nsresult rv = UNWRAP_OBJECT(VTTCue, aCx, &aCue.toObject(), cue);
162733:   NS_ENSURE_SUCCESS(rv, rv);
162733: 
162733:   cue->SetTrackElement(mElement);
162733:   mElement->mTrack->AddCue(*cue);
162733: 
146904:   return NS_OK;
146904: }
146904: 
162733: 
162570: NS_IMETHODIMP
162733: WebVTTListener::OnRegion(const JS::Value &aRegion, JSContext* aCx)
162570: {
163092:   if (!aRegion.isObject()) {
163092:     return NS_ERROR_FAILURE;
163092:   }
163092: 
163092:   TextTrackRegion* region;
163092:   nsresult rv = UNWRAP_OBJECT(VTTRegion, aCx, &aRegion.toObject(),
163092:                               region);
163092:   NS_ENSURE_SUCCESS(rv, rv);
163092: 
163092:   mElement->mTrack->AddRegion(*region);
163092: 
146904:   return NS_OK;
146904: }
146904: 
146904: } // namespace dom
146904: } // namespace mozilla
