     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
     1: /* vim:set ts=4 sw=4 sts=4 ci et: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 36001: #include "base/basictypes.h"
 36001: 
 28510: #include "mozilla/XPCOM.h"
 35880: #include "nsXULAppAPI.h"
 28510: 
     1: #include "nsXPCOMPrivate.h"
     1: #include "nsXPCOMCIDInternal.h"
 28510: 
     1: #include "nsStaticComponents.h"
     1: #include "prlink.h"
 28510: 
     1: #include "nsObserverList.h"
     1: #include "nsObserverService.h"
     1: #include "nsProperties.h"
     1: #include "nsPersistentProperties.h"
     1: #include "nsScriptableInputStream.h"
     1: #include "nsBinaryStream.h"
     1: #include "nsStorageStream.h"
     1: #include "nsPipe.h"
 71463: #include "nsScriptableBase64Encoder.h"
     1: 
     1: #include "nsMemoryImpl.h"
     1: #include "nsDebugImpl.h"
     1: #include "nsTraceRefcntImpl.h"
     1: #include "nsErrorService.h"
     1: #include "nsByteBuffer.h"
     1: 
     1: #include "nsSupportsArray.h"
     1: #include "nsArray.h"
     1: #include "nsINIParserImpl.h"
     1: #include "nsSupportsPrimitives.h"
     1: #include "nsConsoleService.h"
     1: #include "nsExceptionService.h"
     1: 
     1: #include "nsComponentManager.h"
     1: #include "nsCategoryManagerUtils.h"
     1: #include "nsIServiceManager.h"
     1: 
     1: #include "nsThreadManager.h"
     1: #include "nsThreadPool.h"
     1: 
     1: #include "xptinfo.h"
     1: #include "nsIInterfaceInfoManager.h"
     1: #include "xptiprivate.h"
     1: 
     1: #include "nsTimerImpl.h"
     1: #include "TimerThread.h"
     1: 
     1: #include "nsThread.h"
     1: #include "nsProcess.h"
     1: #include "nsEnvironment.h"
     1: #include "nsVersionComparatorImpl.h"
     1: 
101111: #include "nsIFile.h"
     1: #include "nsLocalFile.h"
     1: #if defined(XP_UNIX) || defined(XP_OS2)
     1: #include "nsNativeCharsetUtils.h"
     1: #endif
     1: #include "nsDirectoryService.h"
     1: #include "nsDirectoryServiceDefs.h"
     1: #include "nsCategoryManager.h"
     1: #include "nsICategoryManager.h"
     1: #include "nsMultiplexInputStream.h"
     1: 
     1: #include "nsStringStream.h"
 46997: extern nsresult nsStringInputStreamConstructor(nsISupports *, REFNSIID, void **);
     1: 
     1: #include "nsAtomService.h"
     1: #include "nsAtomTable.h"
     1: #include "nsTraceRefcnt.h"
     1: 
     1: #include "nsHashPropertyBag.h"
     1: 
     1: #include "nsUnicharInputStream.h"
     1: #include "nsVariant.h"
     1: 
     1: #include "nsUUIDGenerator.h"
     1: 
 28080: #include "nsIOUtil.h"
 28080: 
     1: #include "SpecialSystemDirectory.h"
     1: 
 20187: #if defined(XP_WIN)
     1: #include "nsWindowsRegKey.h"
     1: #endif
     1: 
 77114: #ifdef MOZ_WIDGET_COCOA
     1: #include "nsMacUtilsImpl.h"
     1: #endif
     1: 
     1: #include "nsSystemInfo.h"
 12636: #include "nsMemoryReporterManager.h"
     1: 
     1: #include <locale.h>
 40716: #include "mozilla/Services.h"
 42480: #include "mozilla/FunctionTimer.h"
 49360: #include "mozilla/Omnijar.h"
 82631: #include "mozilla/HangMonitor.h"
 86967: #include "mozilla/Telemetry.h"
     1: 
 47005: #include "nsChromeRegistry.h"
 47005: #include "nsChromeProtocolHandler.h"
103475: #include "mozilla/mozPoisonWrite.h"
 47005: 
 51718: #include "mozilla/scache/StartupCache.h"
 51718: 
 35819: #include "base/at_exit.h"
 35819: #include "base/command_line.h"
 35819: #include "base/message_loop.h"
 35819: 
 37884: #include "mozilla/ipc/BrowserProcessSubThread.h"
 77979: #include "mozilla/MapsMemoryReporter.h"
 84687: #include "mozilla/AvailableMemoryTracker.h"
 88343: #include "mozilla/ClearOnShutdown.h"
 35878: 
101779: #include "mozilla/VisualEventTracer.h"
101779: 
 35819: using base::AtExitManager;
 35878: using mozilla::ipc::BrowserProcessSubThread;
 35819: 
 35819: namespace {
 35819: 
 35819: static AtExitManager* sExitManager;
 35819: static MessageLoop* sMessageLoop;
 35819: static bool sCommandLineWasInitialized;
 35878: static BrowserProcessSubThread* sIOThread;
 35819: 
 35819: } /* anonymous namespace */
 35819: 
     1: // Registry Factory creation function defined in nsRegistry.cpp
     1: // We hook into this function locally to create and register the registry
     1: // Since noone outside xpcom needs to know about this and nsRegistry.cpp
     1: // does not have a local include file, we are putting this definition
     1: // here rather than in nsIRegistry.h
     1: extern nsresult NS_RegistryGetFactory(nsIFactory** aFactory);
     1: extern nsresult NS_CategoryManagerGetFactory( nsIFactory** );
     1: 
 57087: #ifdef XP_WIN
 57089: extern nsresult ScheduleMediaCacheRemover();
 57087: #endif
 57087: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsProcess)
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsIDImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsStringImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsCStringImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRBoolImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint8Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint16Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint32Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint64Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRTimeImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsCharImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRInt16Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRInt32Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRInt64Impl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsFloatImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsDoubleImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsVoidImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsInterfacePointerImpl)
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsConsoleService, Init)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsAtomService)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsExceptionService)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsTimerImpl)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsBinaryOutputStream)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsBinaryInputStream)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsStorageStream)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsVersionComparatorImpl)
 71463: NS_GENERIC_FACTORY_CONSTRUCTOR(nsScriptableBase64Encoder)
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsVariant)
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsHashPropertyBag, Init)
     1: 
     1: NS_GENERIC_AGGREGATED_CONSTRUCTOR_INIT(nsProperties, Init)
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsUUIDGenerator, Init)
     1: 
 77114: #ifdef MOZ_WIDGET_COCOA
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsMacUtilsImpl)
     1: #endif
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsSystemInfo, Init)
     1: 
 33420: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMemoryReporterManager, Init)
 12636: 
 28080: NS_GENERIC_FACTORY_CONSTRUCTOR(nsIOUtil)
 28080: 
 46997: static nsresult
     1: nsThreadManagerGetSingleton(nsISupports* outer,
     1:                             const nsIID& aIID,
     1:                             void* *aInstancePtr)
     1: {
     1:     NS_ASSERTION(aInstancePtr, "null outptr");
     1:     NS_ENSURE_TRUE(!outer, NS_ERROR_NO_AGGREGATION);
     1: 
     1:     return nsThreadManager::get()->QueryInterface(aIID, aInstancePtr);
     1: }
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsThreadPool)
     1: 
 46997: static nsresult
     1: nsXPTIInterfaceInfoManagerGetSingleton(nsISupports* outer,
     1:                                        const nsIID& aIID,
     1:                                        void* *aInstancePtr)
     1: {
     1:     NS_ASSERTION(aInstancePtr, "null outptr");
     1:     NS_ENSURE_TRUE(!outer, NS_ERROR_NO_AGGREGATION);
     1: 
     1:     nsCOMPtr<nsIInterfaceInfoManager> iim
 43619:         (xptiInterfaceInfoManager::GetSingleton());
     1:     if (!iim)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     return iim->QueryInterface(aIID, aInstancePtr);
     1: }
     1: 
     1: nsComponentManagerImpl* nsComponentManagerImpl::gComponentManager = NULL;
 79445: bool gXPCOMShuttingDown = false;
     1: 
 46997: static NS_DEFINE_CID(kComponentManagerCID, NS_COMPONENTMANAGER_CID);
 46997: static NS_DEFINE_CID(kINIParserFactoryCID, NS_INIPARSERFACTORY_CID);
 46997: static NS_DEFINE_CID(kSimpleUnicharStreamFactoryCID, NS_SIMPLE_UNICHAR_STREAM_FACTORY_CID);
     1: 
 47005: NS_DEFINE_NAMED_CID(NS_CHROMEREGISTRY_CID);
 47005: NS_DEFINE_NAMED_CID(NS_CHROMEPROTOCOLHANDLER_CID);
     1: 
 47092: NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(nsChromeRegistry,
 47092:                                          nsChromeRegistry::GetSingleton)
 47005: NS_GENERIC_FACTORY_CONSTRUCTOR(nsChromeProtocolHandler)
     1: 
     1: #define NS_PERSISTENTPROPERTIES_CID NS_IPERSISTENTPROPERTIES_CID /* sigh */
     1: 
 46997: static already_AddRefed<nsIFactory>
 46997: CreateINIParserFactory(const mozilla::Module& module,
 46997:                        const mozilla::Module::CIDEntry& entry)
 46997: {
 46997:     nsIFactory* f = new nsINIParserFactory();
 46997:     f->AddRef();
 46997:     return f;
 46997: }
     1: 
 46997: static already_AddRefed<nsIFactory>
 46997: CreateUnicharStreamFactory(const mozilla::Module& module,
 46997:                            const mozilla::Module::CIDEntry& entry)
 46997: {
 46997:     return nsSimpleUnicharStreamFactory::GetInstance();
 46997: }
     1: 
 46997: #define COMPONENT(NAME, Ctor) static NS_DEFINE_CID(kNS_##NAME##_CID, NS_##NAME##_CID);
 46997: #include "XPCOMModule.inc"
     1: #undef COMPONENT
     1: 
 46997: #define COMPONENT(NAME, Ctor) { &kNS_##NAME##_CID, false, NULL, Ctor },
 46997: const mozilla::Module::CIDEntry kXPCOMCIDEntries[] = {
 46997:     { &kComponentManagerCID, true, NULL, nsComponentManagerImpl::Create },
 46997:     { &kINIParserFactoryCID, false, CreateINIParserFactory },
 46997:     { &kSimpleUnicharStreamFactoryCID, false, CreateUnicharStreamFactory },
 46997: #include "XPCOMModule.inc"
 47005:     { &kNS_CHROMEREGISTRY_CID, false, NULL, nsChromeRegistryConstructor },
 47005:     { &kNS_CHROMEPROTOCOLHANDLER_CID, false, NULL, nsChromeProtocolHandlerConstructor },
 46997:     { NULL }
 46997: };
 46997: #undef COMPONENT
 46997: 
 46997: #define COMPONENT(NAME, Ctor) { NS_##NAME##_CONTRACTID, &kNS_##NAME##_CID },
 46997: const mozilla::Module::ContractIDEntry kXPCOMContracts[] = {
 46997: #include "XPCOMModule.inc"
 47005:     { NS_CHROMEREGISTRY_CONTRACTID, &kNS_CHROMEREGISTRY_CID },
 47005:     { NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "chrome", &kNS_CHROMEPROTOCOLHANDLER_CID },
 47067:     { NS_INIPARSERFACTORY_CONTRACTID, &kINIParserFactoryCID },
 46997:     { NULL }
 46997: };
 46997: #undef COMPONENT
 46997: 
 46997: const mozilla::Module kXPCOMModule = { mozilla::Module::kVersion, kXPCOMCIDEntries, kXPCOMContracts };
     1: 
     1: // gDebug will be freed during shutdown.
106838: static nsIDebug* gDebug = nullptr;
     1: 
     1: EXPORT_XPCOM_API(nsresult)
     1: NS_GetDebug(nsIDebug** result)
     1: {
106838:     return nsDebugImpl::Create(nullptr, 
     1:                                NS_GET_IID(nsIDebug), 
     1:                                (void**) result);
     1: }
     1: 
     1: EXPORT_XPCOM_API(nsresult)
     1: NS_GetTraceRefcnt(nsITraceRefcnt** result)
     1: {
106838:     return nsTraceRefcntImpl::Create(nullptr, 
     1:                                      NS_GET_IID(nsITraceRefcnt), 
     1:                                      (void**) result);
     1: }
     1: 
     1: EXPORT_XPCOM_API(nsresult)
     1: NS_InitXPCOM(nsIServiceManager* *result,
     1:                              nsIFile* binDirectory)
     1: {
106838:     return NS_InitXPCOM2(result, binDirectory, nullptr);
     1: }
     1: 
     1: EXPORT_XPCOM_API(nsresult)
     1: NS_InitXPCOM2(nsIServiceManager* *result,
     1:               nsIFile* binDirectory,
     1:               nsIDirectoryServiceProvider* appFileLocationProvider)
     1: {
 42480:     NS_TIME_FUNCTION;
 42480: 
     1:     nsresult rv = NS_OK;
     1: 
     1:      // We are not shutting down
 80486:     gXPCOMShuttingDown = false;
     1: 
 94999:     NS_TIME_FUNCTION_MARK("Next: AvailableMemoryTracker Init()");
 94999: 
 94999:     // Initialize the available memory tracker before other threads have had a
 94999:     // chance to start up, because the initialization is not thread-safe.
 94999:     mozilla::AvailableMemoryTracker::Init();
 94999: 
 42480:     NS_TIME_FUNCTION_MARK("Next: log init");
 42480: 
 38951:     NS_LogInit();
 38951: 
 42480:     NS_TIME_FUNCTION_MARK("Next: IPC init");
 42480: 
 35819:     // Set up chromium libs
 35819:     NS_ASSERTION(!sExitManager && !sMessageLoop, "Bad logic!");
 35819: 
 35819:     if (!AtExitManager::AlreadyRegistered()) {
 35819:         sExitManager = new AtExitManager();
 35819:         NS_ENSURE_STATE(sExitManager);
 35819:     }
 35819: 
 35819:     if (!MessageLoop::current()) {
 37884:         sMessageLoop = new MessageLoopForUI(MessageLoop::TYPE_MOZILLA_UI);
 35819:         NS_ENSURE_STATE(sMessageLoop);
 35819:     }
 35878: 
 35880:     if (XRE_GetProcessType() == GeckoProcessType_Default &&
 35880:         !BrowserProcessSubThread::GetMessageLoop(BrowserProcessSubThread::IO)) {
 35878:         scoped_ptr<BrowserProcessSubThread> ioThread(
 35878:             new BrowserProcessSubThread(BrowserProcessSubThread::IO));
 35878:         NS_ENSURE_TRUE(ioThread.get(), NS_ERROR_OUT_OF_MEMORY);
 35878: 
 35878:         base::Thread::Options options;
 35878:         options.message_loop_type = MessageLoop::TYPE_IO;
 35878:         NS_ENSURE_TRUE(ioThread->StartWithOptions(options), NS_ERROR_FAILURE);
 35878: 
 35878:         sIOThread = ioThread.release();
 35878:     }
 35819: 
 42480:     NS_TIME_FUNCTION_MARK("Next: thread manager init");
 42480: 
     1:     // Establish the main thread here.
     1:     rv = nsThreadManager::get()->Init();
     1:     if (NS_FAILED(rv)) return rv;
     1: 
 42480:     NS_TIME_FUNCTION_MARK("Next: timer startup");
 42480: 
     1:     // Set up the timer globals/timer thread
     1:     rv = nsTimerImpl::Startup();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 69184: #ifndef ANDROID
 42480:     NS_TIME_FUNCTION_MARK("Next: setlocale");
 42480: 
     1:     // If the locale hasn't already been setup by our embedder,
     1:     // get us out of the "C" locale and into the system 
     1:     if (strcmp(setlocale(LC_ALL, NULL), "C") == 0)
     1:         setlocale(LC_ALL, "");
     1: #endif
     1: 
     1: #if defined(XP_UNIX) || defined(XP_OS2)
 42480:     NS_TIME_FUNCTION_MARK("Next: startup native charset utils");
 42480: 
     1:     NS_StartupNativeCharsetUtils();
     1: #endif
 49360: 
 42480:     NS_TIME_FUNCTION_MARK("Next: startup local file");
 42480: 
     1:     NS_StartupLocalFile();
     1: 
     1:     StartupSpecialSystemDirectory();
     1: 
     1:     rv = nsDirectoryService::RealInit();
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
 79445:     bool value;
     1: 
     1:     if (binDirectory)
     1:     {
     1:         rv = binDirectory->IsDirectory(&value);
     1: 
     1:         if (NS_SUCCEEDED(rv) && value) {
     1:             nsDirectoryService::gService->Set(NS_XPCOM_INIT_CURRENT_PROCESS_DIR, binDirectory);
     1:         }
     1:     }
     1: 
     1:     if (appFileLocationProvider) {
     1:         rv = nsDirectoryService::gService->RegisterProvider(appFileLocationProvider);
     1:         if (NS_FAILED(rv)) return rv;
     1:     }
     1: 
 74163:     nsCOMPtr<nsIFile> xpcomLib;
 74163: 
 74163:     nsDirectoryService::gService->Get(NS_GRE_DIR,
 74163:                                       NS_GET_IID(nsIFile),
 74163:                                       getter_AddRefs(xpcomLib));
 74163: 
 74163:     if (xpcomLib) {
 74163:         xpcomLib->AppendNative(nsDependentCString(XPCOM_DLL));
 74163:         nsDirectoryService::gService->Set(NS_XPCOM_LIBRARY_FILE, xpcomLib);
 74163:     }
 74163:     
 49360:     NS_TIME_FUNCTION_MARK("Next: Omnijar init");
 49360: 
 70010:     if (!mozilla::Omnijar::IsInitialized()) {
 70010:         mozilla::Omnijar::Init();
 49360:     }
 49360: 
 35889:     if ((sCommandLineWasInitialized = !CommandLine::IsInitialized())) {
 42480:         NS_TIME_FUNCTION_MARK("Next: IPC command line init");
 42480: 
 35889: #ifdef OS_WIN
106838:         CommandLine::Init(0, nullptr);
 35889: #else
 35889:         nsCOMPtr<nsIFile> binaryFile;
 35889:         nsDirectoryService::gService->Get(NS_XPCOM_CURRENT_PROCESS_DIR, 
 35889:                                           NS_GET_IID(nsIFile), 
 35889:                                           getter_AddRefs(binaryFile));
 35889:         NS_ENSURE_STATE(binaryFile);
 35889:         
 35889:         rv = binaryFile->AppendNative(NS_LITERAL_CSTRING("nonexistent-executable"));
 35889:         NS_ENSURE_SUCCESS(rv, rv);
 35889:         
 35889:         nsCString binaryPath;
 35889:         rv = binaryFile->GetNativePath(binaryPath);
 35889:         NS_ENSURE_SUCCESS(rv, rv);
 35889:         
 35889:         static char const *const argv = { strdup(binaryPath.get()) };
 35889:         CommandLine::Init(1, &argv);
 35889: #endif
 35889:     }
 35889: 
     1:     NS_ASSERTION(nsComponentManagerImpl::gComponentManager == NULL, "CompMgr not null at init");
     1: 
 42480:     NS_TIME_FUNCTION_MARK("Next: component manager init");
 42480: 
     1:     // Create the Component/Service Manager
 47005:     nsComponentManagerImpl::gComponentManager = new nsComponentManagerImpl();
 47005:     NS_ADDREF(nsComponentManagerImpl::gComponentManager);
 42480:     
   142:     rv = nsCycleCollector_startup();
   142:     if (NS_FAILED(rv)) return rv;
   142: 
 47005:     rv = nsComponentManagerImpl::gComponentManager->Init();
 43620:     if (NS_FAILED(rv))
     1:     {
 47005:         NS_RELEASE(nsComponentManagerImpl::gComponentManager);
     1:         return rv;
     1:     }
     1: 
 43620:     if (result) {
 47005:         NS_ADDREF(*result = nsComponentManagerImpl::gComponentManager);
 43620:     }
     1: 
 43620:     NS_TIME_FUNCTION_MARK("Next: cycle collector startup");
     1: 
 42480:     NS_TIME_FUNCTION_MARK("Next: interface info manager init");
 42480: 
 43620:     // The iimanager constructor searches and registers XPT files.
 46138:     // (We trigger the singleton's lazy construction here to make that happen.)
 46138:     (void) xptiInterfaceInfoManager::GetSingleton();
     1: 
 42480:     NS_TIME_FUNCTION_MARK("Next: register category providers");
 42480: 
     1:     // After autoreg, but before we actually instantiate any components,
     1:     // add any services listed in the "xpcom-directory-providers" category
     1:     // to the directory service.
     1:     nsDirectoryService::gService->RegisterCategoryProviders();
     1: 
 51718:     mozilla::scache::StartupCache::GetSingleton();
 94999:     mozilla::AvailableMemoryTracker::Activate();
 84687: 
 42480:     NS_TIME_FUNCTION_MARK("Next: create services from category");
 42480: 
     1:     // Notify observers of xpcom autoregistration start
 12777:     NS_CreateServicesFromCategory(NS_XPCOM_STARTUP_CATEGORY, 
106838:                                   nullptr,
     1:                                   NS_XPCOM_STARTUP_OBSERVER_ID);
 57087: #ifdef XP_WIN
 57089:     ScheduleMediaCacheRemover();
 57087: #endif
     1: 
 77979:     mozilla::MapsMemoryReporter::Init();
 77979: 
110922:     mozilla::Telemetry::Init();
110922: 
 82631:     mozilla::HangMonitor::Startup();
 82631: 
101779:     mozilla::eventtracer::Init();
101779: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: //
     1: // NS_ShutdownXPCOM()
     1: //
     1: // The shutdown sequence for xpcom would be
     1: //
     1: // - Notify "xpcom-shutdown" for modules to release primary (root) references
     1: // - Shutdown XPCOM timers
     1: // - Notify "xpcom-shutdown-threads" for thread joins
     1: // - Shutdown the event queues
     1: // - Release the Global Service Manager
     1: //   - Release all service instances held by the global service manager
     1: //   - Release the Global Service Manager itself
     1: // - Release the Component Manager
     1: //   - Release all factories cached by the Component Manager
     1: //   - Notify module loaders to shut down
     1: //   - Unload Libraries
     1: //   - Release Contractid Cache held by Component Manager
     1: //   - Release dll abstraction held by Component Manager
     1: //   - Release the Registry held by Component Manager
     1: //   - Finally, release the component manager itself
     1: //
     1: EXPORT_XPCOM_API(nsresult)
     1: NS_ShutdownXPCOM(nsIServiceManager* servMgr)
     1: {
 29281:     return mozilla::ShutdownXPCOM(servMgr);
 29281: }
 29281: 
 29281: namespace mozilla {
 29281: 
 29281: nsresult
 29281: ShutdownXPCOM(nsIServiceManager* servMgr)
 29281: {
 82631:     // Make sure the hang monitor is enabled for shutdown.
 82631:     HangMonitor::NotifyActivity();
 82631: 
     1:     NS_ENSURE_STATE(NS_IsMainThread());
     1: 
     1:     nsresult rv;
     1:     nsCOMPtr<nsISimpleEnumerator> moduleLoaders;
     1: 
     1:     // Notify observers of xpcom shutting down
     1:     {
     1:         // Block it so that the COMPtr will get deleted before we hit
     1:         // servicemanager shutdown
     1: 
     1:         nsCOMPtr<nsIThread> thread = do_GetCurrentThread();
     1:         NS_ENSURE_STATE(thread);
     1: 
     1:         nsRefPtr<nsObserverService> observerService;
     1:         CallGetService("@mozilla.org/observer-service;1",
     1:                        (nsObserverService**) getter_AddRefs(observerService));
     1: 
     1:         if (observerService)
     1:         {
 35179:             (void) observerService->
106838:                 NotifyObservers(nullptr, NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID,
106838:                                 nullptr);
 35179: 
     1:             nsCOMPtr<nsIServiceManager> mgr;
     1:             rv = NS_GetServiceManager(getter_AddRefs(mgr));
     1:             if (NS_SUCCEEDED(rv))
     1:             {
     1:                 (void) observerService->
     1:                     NotifyObservers(mgr, NS_XPCOM_SHUTDOWN_OBSERVER_ID,
106838:                                     nullptr);
     1:             }
     1:         }
     1: 
     1:         NS_ProcessPendingEvents(thread);
 51718:         mozilla::scache::StartupCache::DeleteSingleton();
     1:         if (observerService)
     1:             (void) observerService->
106838:                 NotifyObservers(nullptr, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID,
106838:                                 nullptr);
     1: 
 57794:         nsCycleCollector_shutdownThreads();
 57794: 
     1:         NS_ProcessPendingEvents(thread);
     1: 
     1:         // Shutdown the timer thread and all timers that might still be alive before
     1:         // shutting down the component manager
     1:         nsTimerImpl::Shutdown();
     1: 
     1:         NS_ProcessPendingEvents(thread);
     1: 
     1:         // Shutdown all remaining threads.  This method does not return until
     1:         // all threads created using the thread manager (with the exception of
     1:         // the main thread) have exited.
     1:         nsThreadManager::get()->Shutdown();
     1: 
     1:         NS_ProcessPendingEvents(thread);
     1: 
 82631:         HangMonitor::NotifyActivity();
 82631: 
     1:         // We save the "xpcom-shutdown-loaders" observers to notify after
     1:         // the observerservice is gone.
     1:         if (observerService) {
     1:             observerService->
     1:                 EnumerateObservers(NS_XPCOM_SHUTDOWN_LOADERS_OBSERVER_ID,
     1:                                    getter_AddRefs(moduleLoaders));
     1: 
     1:             observerService->Shutdown();
     1:         }
     1:     }
     1: 
 88343:     // Free ClearOnShutdown()'ed smart pointers.  This needs to happen *after*
 88343:     // we've finished notifying observers of XPCOM shutdown, because shutdown
 88343:     // observers themselves might call ClearOnShutdown().
 88343:     mozilla::KillClearOnShutdown();
 88343: 
     1:     // XPCOM is officially in shutdown mode NOW
     1:     // Set this only after the observers have been notified as this
     1:     // will cause servicemanager to become inaccessible.
 40716:     mozilla::services::Shutdown();
     1: 
     1: #ifdef DEBUG_dougt
     1:     fprintf(stderr, "* * * * XPCOM shutdown. Access will be denied * * * * \n");
     1: #endif
     1:     // We may have AddRef'd for the caller of NS_InitXPCOM, so release it
     1:     // here again:
     1:     NS_IF_RELEASE(servMgr);
     1: 
     1:     // Shutdown global servicemanager
     1:     if (nsComponentManagerImpl::gComponentManager) {
     1:         nsComponentManagerImpl::gComponentManager->FreeServices();
     1:     }
     1: 
     1:     // Release the directory service
     1:     NS_IF_RELEASE(nsDirectoryService::gService);
     1: 
     1:     nsCycleCollector_shutdown();
     1: 
103475:     mozilla::PoisonWrite();
103475: 
     1:     if (moduleLoaders) {
 79445:         bool more;
     1:         nsCOMPtr<nsISupports> el;
     1:         while (NS_SUCCEEDED(moduleLoaders->HasMoreElements(&more)) &&
     1:                more) {
     1:             moduleLoaders->GetNext(getter_AddRefs(el));
     1: 
     1:             // Don't worry about weak-reference observers here: there is
     1:             // no reason for weak-ref observers to register for
     1:             // xpcom-shutdown-loaders
     1: 
     1:             nsCOMPtr<nsIObserver> obs(do_QueryInterface(el));
     1:             if (obs)
106838:                 (void) obs->Observe(nullptr,
     1:                                     NS_XPCOM_SHUTDOWN_LOADERS_OBSERVER_ID,
106838:                                     nullptr);
     1:         }
     1: 
106838:         moduleLoaders = nullptr;
     1:     }
     1: 
     1:     // Shutdown nsLocalFile string conversion
     1:     NS_ShutdownLocalFile();
     1: #ifdef XP_UNIX
     1:     NS_ShutdownNativeCharsetUtils();
     1: #endif
     1: 
     1:     // Shutdown xpcom. This will release all loaders and cause others holding
     1:     // a refcount to the component manager to release it.
     1:     if (nsComponentManagerImpl::gComponentManager) {
     1:         rv = (nsComponentManagerImpl::gComponentManager)->Shutdown();
     1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Component Manager shutdown failed.");
     1:     } else
     1:         NS_WARNING("Component Manager was never created ...");
     1: 
     1:     // Release our own singletons
     1:     // Do this _after_ shutting down the component manager, because the
     1:     // JS component loader will use XPConnect to call nsIModule::canUnload,
     1:     // and that will spin up the InterfaceInfoManager again -- bad mojo
     1:     xptiInterfaceInfoManager::FreeInterfaceInfoManager();
     1: 
     1:     // Finally, release the component manager last because it unloads the
     1:     // libraries:
     1:     if (nsComponentManagerImpl::gComponentManager) {
     1:       nsrefcnt cnt;
     1:       NS_RELEASE2(nsComponentManagerImpl::gComponentManager, cnt);
     1:       NS_ASSERTION(cnt == 0, "Component Manager being held past XPCOM shutdown.");
     1:     }
106838:     nsComponentManagerImpl::gComponentManager = nullptr;
 46997:     nsCategoryManager::Destroy();
     1: 
     1:     NS_PurgeAtomTable();
     1: 
     1:     NS_IF_RELEASE(gDebug);
     1: 
 35878:     if (sIOThread) {
 35878:         delete sIOThread;
106838:         sIOThread = nullptr;
 35878:     }
 35819:     if (sMessageLoop) {
 35819:         delete sMessageLoop;
106838:         sMessageLoop = nullptr;
 35819:     }
 35819:     if (sCommandLineWasInitialized) {
 35819:         CommandLine::Terminate();
 35819:         sCommandLineWasInitialized = false;
 35819:     }
 35819:     if (sExitManager) {
 35819:         delete sExitManager;
106838:         sExitManager = nullptr;
 35819:     }
 35819: 
 82631:     Omnijar::CleanUp();
 82631: 
 82631:     HangMonitor::Shutdown();
 49360: 
101779:     eventtracer::Shutdown();
101779: 
 38951:     NS_LogTerm();
 38951: 
     1:     return NS_OK;
     1: }
 29281: 
 29281: } // namespace mozilla
