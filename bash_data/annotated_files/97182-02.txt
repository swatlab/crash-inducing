90966: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
90966:  * vim: set ts=8 sw=4 et tw=78:
90966:  *
90966:  * This Source Code Form is subject to the terms of the Mozilla Public
90966:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
90966:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
90966: 
90970: #include "mozilla/Assertions.h"
90970: #include "mozilla/Attributes.h"
90970: 
90970: #include "jsscope.h"
91557: #include "jsobjinlines.h"
90970: 
97091: #include "js/TemplateLib.h"
97091: 
97047: #include "Debugger.h"
90966: #include "ObjectImpl.h"
90966: 
93701: #include "gc/Barrier-inl.h"
93701: 
90970: #include "ObjectImpl-inl.h"
90970: 
90966: using namespace js;
90966: 
97048: PropDesc::PropDesc()
97048:   : pd_(UndefinedValue()),
97048:     value_(UndefinedValue()),
97048:     get_(UndefinedValue()),
97048:     set_(UndefinedValue()),
97048:     attrs(0),
97048:     hasGet_(false),
97048:     hasSet_(false),
97048:     hasValue_(false),
97048:     hasWritable_(false),
97048:     hasEnumerable_(false),
97048:     hasConfigurable_(false),
97048:     isUndefined_(true)
97048: {
97048: }
97048: 
97047: bool
97047: PropDesc::checkGetter(JSContext *cx)
97047: {
97048:     if (hasGet_) {
97048:         if (!js_IsCallable(get_) && !get_.isUndefined()) {
97047:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
97047:                                  js_getter_str);
97047:             return false;
97047:         }
97047:     }
97047:     return true;
97047: }
97047: 
97047: bool
97047: PropDesc::checkSetter(JSContext *cx)
97047: {
97048:     if (hasSet_) {
97048:         if (!js_IsCallable(set_) && !set_.isUndefined()) {
97047:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
97047:                                  js_setter_str);
97047:             return false;
97047:         }
97047:     }
97047:     return true;
97047: }
97047: 
97047: static bool
97047: CheckArgCompartment(JSContext *cx, JSObject *obj, const Value &v,
97047:                     const char *methodname, const char *propname)
97047: {
97047:     if (v.isObject() && v.toObject().compartment() != obj->compartment()) {
97047:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_COMPARTMENT_MISMATCH,
97047:                              methodname, propname);
97047:         return false;
97047:     }
97047:     return true;
97047: }
97047: 
97047: /*
97047:  * Convert Debugger.Objects in desc to debuggee values.
97047:  * Reject non-callable getters and setters.
97047:  */
97047: bool
97047: PropDesc::unwrapDebuggerObjectsInto(JSContext *cx, Debugger *dbg, JSObject *obj,
97047:                                     PropDesc *unwrapped) const
97047: {
97048:     MOZ_ASSERT(!isUndefined());
97048: 
97047:     *unwrapped = *this;
97047: 
97047:     if (unwrapped->hasValue()) {
97047:         if (!dbg->unwrapDebuggeeValue(cx, &unwrapped->value_) ||
97047:             !CheckArgCompartment(cx, obj, unwrapped->value_, "defineProperty", "value"))
97047:         {
97047:             return false;
97047:         }
97047:     }
97047: 
97047:     if (unwrapped->hasGet()) {
97047:         if (!dbg->unwrapDebuggeeValue(cx, &unwrapped->get_) ||
97047:             !CheckArgCompartment(cx, obj, unwrapped->get_, "defineProperty", "get"))
97047:         {
97047:             return false;
97047:         }
97047:     }
97047: 
97047:     if (unwrapped->hasSet()) {
97047:         if (!dbg->unwrapDebuggeeValue(cx, &unwrapped->set_) ||
97047:             !CheckArgCompartment(cx, obj, unwrapped->set_, "defineProperty", "set"))
97047:         {
97047:             return false;
97047:         }
97047:     }
97047: 
97047:     return true;
97047: }
97047: 
97047: /*
97047:  * Rewrap *idp and the fields of *desc for the current compartment.  Also:
97047:  * defining a property on a proxy requires pd_ to contain a descriptor object,
97047:  * so reconstitute desc->pd_ if needed.
97047:  */
97047: bool
97047: PropDesc::wrapInto(JSContext *cx, JSObject *obj, const jsid &id, jsid *wrappedId,
97047:                    PropDesc *desc) const
97047: {
97048:     MOZ_ASSERT(!isUndefined());
97048: 
97047:     JSCompartment *comp = cx->compartment;
97047: 
97047:     *wrappedId = id;
97047:     if (!comp->wrapId(cx, wrappedId))
97047:         return false;
97047: 
97047:     *desc = *this;
97047:     if (!comp->wrap(cx, &desc->value_))
97047:         return false;
97047:     if (!comp->wrap(cx, &desc->get_))
97047:         return false;
97047:     if (!comp->wrap(cx, &desc->set_))
97047:         return false;
97047:     return !obj->isProxy() || desc->makeObject(cx);
97047: }
97047: 
90966: static ObjectElements emptyElementsHeader(0, 0);
90966: 
90966: /* Objects with no elements share one empty set of elements. */
91146: HeapSlot *js::emptyObjectElements =
91146:     reinterpret_cast<HeapSlot *>(uintptr_t(&emptyElementsHeader) + sizeof(ObjectElements));
90970: 
93703: #ifdef DEBUG
93703: void
93703: js::ObjectImpl::checkShapeConsistency()
93703: {
93703:     static int throttle = -1;
93703:     if (throttle < 0) {
93703:         if (const char *var = getenv("JS_CHECK_SHAPE_THROTTLE"))
93703:             throttle = atoi(var);
93703:         if (throttle < 0)
93703:             throttle = 0;
93703:     }
93703:     if (throttle == 0)
93703:         return;
93703: 
93703:     MOZ_ASSERT(isNative());
93703: 
93703:     Shape *shape = lastProperty();
93703:     Shape *prev = NULL;
93703: 
93703:     if (inDictionaryMode()) {
93703:         MOZ_ASSERT(shape->hasTable());
93703: 
93703:         PropertyTable &table = shape->table();
93703:         for (uint32_t fslot = table.freelist; fslot != SHAPE_INVALID_SLOT;
93703:              fslot = getSlot(fslot).toPrivateUint32()) {
93703:             MOZ_ASSERT(fslot < slotSpan());
93703:         }
93703: 
93703:         for (int n = throttle; --n >= 0 && shape->parent; shape = shape->parent) {
93703:             MOZ_ASSERT_IF(shape != lastProperty(), !shape->hasTable());
93703: 
93703:             Shape **spp = table.search(shape->propid(), false);
93703:             MOZ_ASSERT(SHAPE_FETCH(spp) == shape);
93703:         }
93703: 
93703:         shape = lastProperty();
93703:         for (int n = throttle; --n >= 0 && shape; shape = shape->parent) {
93703:             MOZ_ASSERT_IF(shape->slot() != SHAPE_INVALID_SLOT, shape->slot() < slotSpan());
93703:             if (!prev) {
93703:                 MOZ_ASSERT(shape == lastProperty());
93703:                 MOZ_ASSERT(shape->listp == &shape_);
93703:             } else {
93703:                 MOZ_ASSERT(shape->listp == &prev->parent);
93703:             }
93703:             prev = shape;
93703:         }
93703:     } else {
93703:         for (int n = throttle; --n >= 0 && shape->parent; shape = shape->parent) {
93703:             if (shape->hasTable()) {
93703:                 PropertyTable &table = shape->table();
93703:                 MOZ_ASSERT(shape->parent);
93703:                 for (Shape::Range r(shape); !r.empty(); r.popFront()) {
93703:                     Shape **spp = table.search(r.front().propid(), false);
93703:                     MOZ_ASSERT(SHAPE_FETCH(spp) == &r.front());
93703:                 }
93703:             }
93703:             if (prev) {
93703:                 MOZ_ASSERT(prev->maybeSlot() >= shape->maybeSlot());
93703:                 shape->kids.checkConsistency(prev);
93703:             }
93703:             prev = shape;
93703:         }
93703:     }
93703: }
93703: #endif
93703: 
93701: void
94081: js::ObjectImpl::initSlotRange(uint32_t start, const Value *vector, uint32_t length)
93701: {
93701:     JSCompartment *comp = compartment();
93701:     HeapSlot *fixedStart, *fixedEnd, *slotsStart, *slotsEnd;
93701:     getSlotRange(start, length, &fixedStart, &fixedEnd, &slotsStart, &slotsEnd);
93701:     for (HeapSlot *sp = fixedStart; sp < fixedEnd; sp++)
93701:         sp->init(comp, this->asObjectPtr(), start++, *vector++);
93701:     for (HeapSlot *sp = slotsStart; sp < slotsEnd; sp++)
93701:         sp->init(comp, this->asObjectPtr(), start++, *vector++);
93701: }
93701: 
93701: void
94081: js::ObjectImpl::copySlotRange(uint32_t start, const Value *vector, uint32_t length)
93701: {
93701:     JSCompartment *comp = compartment();
93701:     HeapSlot *fixedStart, *fixedEnd, *slotsStart, *slotsEnd;
93701:     getSlotRange(start, length, &fixedStart, &fixedEnd, &slotsStart, &slotsEnd);
93701:     for (HeapSlot *sp = fixedStart; sp < fixedEnd; sp++)
93701:         sp->set(comp, this->asObjectPtr(), start++, *vector++);
93701:     for (HeapSlot *sp = slotsStart; sp < slotsEnd; sp++)
93701:         sp->set(comp, this->asObjectPtr(), start++, *vector++);
93701: }
93701: 
93701: #ifdef DEBUG
93701: bool
94081: js::ObjectImpl::slotInRange(uint32_t slot, SentinelAllowed sentinel) const
93701: {
94081:     uint32_t capacity = numFixedSlots() + numDynamicSlots();
93701:     if (sentinel == SENTINEL_ALLOWED)
93701:         return slot <= capacity;
93701:     return slot < capacity;
93701: }
93701: #endif /* DEBUG */
93701: 
90970: #if defined(_MSC_VER) && _MSC_VER >= 1500
90970: /*
90970:  * Work around a compiler bug in MSVC9 and above, where inlining this function
90970:  * causes stack pointer offsets to go awry and spp to refer to something higher
90970:  * up the stack.
90970:  */
90970: MOZ_NEVER_INLINE
90970: #endif
90970: const Shape *
90970: js::ObjectImpl::nativeLookup(JSContext *cx, jsid id)
90970: {
90970:     MOZ_ASSERT(isNative());
90970:     Shape **spp;
90970:     return Shape::search(cx, lastProperty(), id, &spp);
90970: }
91557: 
95355: #ifdef DEBUG
95355: const Shape *
95355: js::ObjectImpl::nativeLookupNoAllocation(JSContext *cx, jsid id)
95355: {
95355:     MOZ_ASSERT(isNative());
95355:     return Shape::searchNoAllocation(cx, lastProperty(), id);
95355: }
95355: #endif
95355: 
91557: void
91557: js::ObjectImpl::markChildren(JSTracer *trc)
91557: {
91557:     MarkTypeObject(trc, &type_, "type");
91557: 
91557:     MarkShape(trc, &shape_, "shape");
91557: 
91557:     Class *clasp = shape_->getObjectClass();
91557:     JSObject *obj = asObjectPtr();
91557:     if (clasp->trace)
91557:         clasp->trace(trc, obj);
91557: 
91557:     if (shape_->isNative())
91557:         MarkObjectSlots(trc, obj, 0, obj->slotSpan());
91557: }
94605: 
94605: bool
97091: DenseElementsHeader::getOwnElement(JSContext *cx, ObjectImpl *obj, uint32_t index, PropDesc *desc)
97091: {
97091:     MOZ_ASSERT(this == &obj->elementsHeader());
97091: 
97091:     uint32_t len = initializedLength();
97091:     if (index >= len) {
97091:         *desc = PropDesc::undefined();
97091:         return true;
97091:     }
97091: 
97091:     HeapSlot &slot = obj->elements[index];
97091:     if (slot.isMagic(JS_ARRAY_HOLE)) {
97091:         *desc = PropDesc::undefined();
97091:         return true;
97091:     }
97091: 
97091:     *desc = PropDesc(slot, PropDesc::Writable, PropDesc::Enumerable, PropDesc::Configurable);
97091:     return true;
97091: }
97091: 
97091: bool
97091: SparseElementsHeader::getOwnElement(JSContext *cx, ObjectImpl *obj, uint32_t index, PropDesc *desc)
97091: {
97091:     MOZ_ASSERT(this == &obj->elementsHeader());
97091: 
97091:     MOZ_NOT_REACHED("NYI");
97091:     return false;
97091: }
97091: 
97091: template<typename T>
97182: static Value
97182: ElementToValue(const T t)
97182: {
97182:     return NumberValue(t);
97182: }
97182: 
97182: template<>
97182: /* static */ Value
97182: ElementToValue(const uint8_clamped u)
97182: {
97182:     return NumberValue(uint8_t(u));
97182: }
97182: 
97182: template<typename T>
97091: bool
97091: TypedElementsHeader<T>::getOwnElement(JSContext *cx, ObjectImpl *obj, uint32_t index,
97091:                                       PropDesc *desc)
97091: {
97091:     MOZ_ASSERT(this == &obj->elementsHeader());
97091: 
97091:     if (index >= length()) {
97091:         *desc = PropDesc::undefined();
97091:         return true;
97091:     }
97091: 
97182:     *desc = PropDesc(ElementToValue(getElement(index)), PropDesc::Writable,
97091:                      PropDesc::Enumerable, PropDesc::Configurable);
97091:     return false;
97091: }
97091: 
97091: bool
97091: ArrayBufferElementsHeader::getOwnElement(JSContext *cx, ObjectImpl *obj, uint32_t index,
97091:                                          PropDesc *desc)
97091: {
97091:     MOZ_ASSERT(this == &obj->elementsHeader());
97091: 
97091:     MOZ_NOT_REACHED("NYI");
97091:     return false;
97091: }
97091: 
97091: bool
95382: SparseElementsHeader::defineElement(JSContext *cx, ObjectImpl *obj, uint32_t index,
95382:                                     const PropDesc &desc, bool shouldThrow, bool *succeeded)
94605: {
94605:     MOZ_ASSERT(this == &obj->elementsHeader());
94605: 
94605:     MOZ_NOT_REACHED("NYI");
94605:     return false;
94605: }
94605: 
94605: bool
95382: DenseElementsHeader::defineElement(JSContext *cx, ObjectImpl *obj, uint32_t index,
95382:                                    const PropDesc &desc, bool shouldThrow, bool *succeeded)
94605: {
94605:     MOZ_ASSERT(this == &obj->elementsHeader());
94605: 
97047:     MOZ_ASSERT_IF(desc.hasGet() || desc.hasSet(), !desc.hasValue() && !desc.hasWritable());
97047:     MOZ_ASSERT_IF(desc.hasValue() || desc.hasWritable(), !desc.hasGet() && !desc.hasSet());
95382: 
94605:     /*
95382:      * If desc is an accessor descriptor or a data descriptor with atypical
95382:      * attributes, convert to sparse and retry.
94605:      */
97047:     if (desc.hasGet() || desc.hasSet() ||
97047:         (desc.hasEnumerable() && !desc.enumerable()) ||
97047:         (desc.hasConfigurable() && !desc.configurable()) ||
97047:         (desc.hasWritable() && !desc.writable()))
94605:     {
94605:         if (!obj->makeElementsSparse(cx))
94605:             return false;
94605:         SparseElementsHeader &elts = obj->elementsHeader().asSparseElements();
95382:         return elts.defineElement(cx, obj, index, desc, shouldThrow, succeeded);
94605:     }
94605: 
95382:     /* Does the element exist?  All behavior depends upon this. */
94605:     uint32_t initLen = initializedLength();
94605:     if (index < initLen) {
95382:         HeapSlot &slot = obj->elements[index];
95382:         if (!slot.isMagic(JS_ARRAY_HOLE)) {
95382:             /*
95382:              * The element exists with attributes { [[Enumerable]]: true,
95382:              * [[Configurable]]: true, [[Writable]]: true, [[Value]]: slot }.
95382:              */
95382:             // XXX jwalden fill this in!
95382:         }
95382:     }
95382: 
95382:     /*
95382:      * If the element doesn't exist, we can only add it if the object is
95382:      * extensible.
95382:      */
95382:     if (!obj->isExtensible()) {
95382:         *succeeded = false;
95382:         if (!shouldThrow)
94605:             return true;
95382:         MOZ_ALWAYS_FALSE(js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_OBJECT_NOT_EXTENSIBLE,
95382:                                                   JSDVG_IGNORE_STACK,
97091:                                                   ObjectValue(*obj),
95382:                                                   NULL, NULL, NULL));
95382:         return false;
94605:     }
94605: 
94605:     /* Otherwise we ensure space for it exists and that it's initialized. */
94605:     ObjectImpl::DenseElementsResult res = obj->ensureDenseElementsInitialized(cx, index, 0);
94605: 
94605:     /* Propagate any error. */
94605:     if (res == ObjectImpl::Failure)
94605:         return false;
94605: 
94605:     /* Otherwise, if the index was too far out of range, go sparse. */
94605:     if (res == ObjectImpl::ConvertToSparse) {
94605:         if (!obj->makeElementsSparse(cx))
94605:             return false;
94605:         SparseElementsHeader &elts = obj->elementsHeader().asSparseElements();
95382:         return elts.defineElement(cx, obj, index, desc, shouldThrow, succeeded);
94605:     }
94605: 
94605:     /* But if we were able to ensure the element's existence, we're good. */
94605:     MOZ_ASSERT(res == ObjectImpl::Succeeded);
97047:     obj->elements[index].set(obj->asObjectPtr(), index, desc.value());
95382:     *succeeded = true;
94605:     return true;
94605: }
94605: 
94605: static JSObject *
94605: ArrayBufferDelegate(JSContext *cx, ObjectImpl *obj)
94605: {
94605:     MOZ_ASSERT(obj->hasClass(&ArrayBufferClass));
94605:     if (obj->getPrivate())
94605:         return static_cast<JSObject *>(obj->getPrivate());
94605:     JSObject *delegate = NewObjectWithGivenProto(cx, &ObjectClass, obj->getProto(), NULL);
94605:     obj->setPrivate(delegate);
94605:     return delegate;
94605: }
94605: 
94605: template <typename T>
94605: bool
95382: TypedElementsHeader<T>::defineElement(JSContext *cx, ObjectImpl *obj,
95382:                                       uint32_t index, const PropDesc &desc, bool shouldThrow,
95382:                                       bool *succeeded)
94605: {
95382:     /* XXX jwalden This probably isn't how typed arrays should behave... */
95382:     *succeeded = false;
94605:     js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_OBJECT_NOT_EXTENSIBLE,
95382:                              JSDVG_IGNORE_STACK,
97091:                              ObjectValue(*obj),
94605:                              NULL, NULL, NULL);
94605:     return false;
94605: }
94605: 
94605: bool
95382: ArrayBufferElementsHeader::defineElement(JSContext *cx, ObjectImpl *obj,
95382:                                          uint32_t index, const PropDesc &desc, bool shouldThrow,
95382:                                          bool *succeeded)
94605: {
94605:     MOZ_ASSERT(this == &obj->elementsHeader());
94605: 
94605:     JSObject *delegate = ArrayBufferDelegate(cx, obj);
94605:     if (!delegate)
94605:         return false;
95382:     return DefineElement(cx, delegate, index, desc, shouldThrow, succeeded);
94605: }
94605: 
94605: bool
97092: js::GetOwnElement(JSContext *cx, ObjectImpl *obj, uint32_t index, PropDesc *desc)
97092: {
97092:     ElementsHeader &header = obj->elementsHeader();
97092:     switch (header.kind()) {
97092:       case DenseElements:
97092:         return header.asDenseElements().getOwnElement(cx, obj, index, desc);
97092:       case SparseElements:
97092:         return header.asSparseElements().getOwnElement(cx, obj, index, desc);
97092:       case Uint8Elements:
97092:         return header.asUint8Elements().getOwnElement(cx, obj, index, desc);
97092:       case Int8Elements:
97092:         return header.asInt8Elements().getOwnElement(cx, obj, index, desc);
97092:       case Uint16Elements:
97092:         return header.asUint16Elements().getOwnElement(cx, obj, index, desc);
97092:       case Int16Elements:
97092:         return header.asInt16Elements().getOwnElement(cx, obj, index, desc);
97092:       case Uint32Elements:
97092:         return header.asUint32Elements().getOwnElement(cx, obj, index, desc);
97092:       case Int32Elements:
97092:         return header.asInt32Elements().getOwnElement(cx, obj, index, desc);
97092:       case Uint8ClampedElements:
97092:         return header.asUint8ClampedElements().getOwnElement(cx, obj, index, desc);
97092:       case Float32Elements:
97092:         return header.asFloat32Elements().getOwnElement(cx, obj, index, desc);
97092:       case Float64Elements:
97092:         return header.asFloat64Elements().getOwnElement(cx, obj, index, desc);
97092:       case ArrayBufferElements:
97092:         return header.asArrayBufferElements().getOwnElement(cx, obj, index, desc);
97092:     }
97092: 
97092:     MOZ_NOT_REACHED("bad elements kind!");
97092:     return false;
97092: }
97092: 
97092: bool
97091: js::GetElement(JSContext *cx, ObjectImpl *obj, ObjectImpl *receiver, uint32_t index,
97091:                Value *vp)
97091: {
97091:     NEW_OBJECT_REPRESENTATION_ONLY();
97091: 
97091:     do {
97091:         MOZ_ASSERT(obj);
97091: 
97091:         if (static_cast<JSObject *>(obj)->isProxy()) { // XXX
97091:             MOZ_NOT_REACHED("NYI: proxy [[GetP]]");
97091:             return false;
97091:         }
97091: 
97091:         PropDesc desc;
97092:         if (!GetOwnElement(cx, obj, index, &desc))
97091:             return false;
97091: 
97091:         /* No property?  Recur or bottom out. */
97091:         if (desc.isUndefined()) {
97091:             obj = obj->getProto();
97091:             if (obj)
97091:                 continue;
97091: 
97091:             vp->setUndefined();
97091:             return true;
97091:         }
97091: 
97091:         /* If it's a data property, return the value. */
97091:         if (desc.isDataDescriptor()) {
97091:             *vp = desc.value();
97091:             return true;
97091:         }
97091: 
97091:         /* If it's an accessor property, call its [[Get]] with the receiver. */
97091:         if (desc.isAccessorDescriptor()) {
97091:             Value get = desc.getterValue();
97091:             if (get.isUndefined()) {
97091:                 vp->setUndefined();
97091:                 return true;
97091:             }
97091: 
97091:             InvokeArgsGuard args;
97091:             if (!cx->stack.pushInvokeArgs(cx, 0, &args))
97091:                 return false;
97091: 
97092:             /* Push get, receiver, and no args. */
97091:             args.calleev() = get;
97091:             args.thisv() = ObjectValue(*receiver);
97091: 
97091:             bool ok = Invoke(cx, args);
97091:             *vp = args.rval();
97091:             return ok;
97091:         }
97091: 
97091:         /* Otherwise it's a PropertyOp-based property.  XXX handle this! */
97091:         MOZ_NOT_REACHED("NYI: handle PropertyOp'd properties here");
97091:         return false;
97091:     } while (false);
97091: }
97091: 
97091: bool
97093: js::HasElement(JSContext *cx, ObjectImpl *obj, uint32_t index, bool *found)
97093: {
97093:     NEW_OBJECT_REPRESENTATION_ONLY();
97093: 
97093:     do {
97093:         MOZ_ASSERT(obj);
97093: 
97093:         if (static_cast<JSObject *>(obj)->isProxy()) { // XXX
97093:             MOZ_NOT_REACHED("NYI: proxy [[HasProperty]]");
97093:             return false;
97093:         }
97093: 
97093:         PropDesc prop;
97093:         if (!GetOwnElement(cx, obj, index, &prop))
97093:             return false;
97093: 
97093:         if (!prop.isUndefined()) {
97093:             *found = true;
97093:             return true;
97093:         }
97093: 
97093:         obj = obj->getProto();
97093:         if (obj)
97093:             continue;
97093: 
97093:         *found = false;
97093:         return true;
97093:     } while (false);
97093: }
97093: 
97093: bool
95382: js::DefineElement(JSContext *cx, ObjectImpl *obj, uint32_t index, const PropDesc &desc,
95382:                   bool shouldThrow, bool *succeeded)
94605: {
94605:     NEW_OBJECT_REPRESENTATION_ONLY();
94605: 
94605:     ElementsHeader &header = obj->elementsHeader();
94605: 
94605:     switch (header.kind()) {
94605:       case DenseElements:
95382:         return header.asDenseElements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                       succeeded);
94605:       case SparseElements:
95382:         return header.asSparseElements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                        succeeded);
94605:       case Uint8Elements:
95382:         return header.asUint8Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                       succeeded);
94605:       case Int8Elements:
95382:         return header.asInt8Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                      succeeded);
94605:       case Uint16Elements:
95382:         return header.asUint16Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                        succeeded);
94605:       case Int16Elements:
95382:         return header.asInt16Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                       succeeded);
94605:       case Uint32Elements:
95382:         return header.asUint32Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                        succeeded);
94605:       case Int32Elements:
95382:         return header.asInt32Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                       succeeded);
94605:       case Uint8ClampedElements:
95382:         return header.asUint8ClampedElements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                              succeeded);
94605:       case Float32Elements:
95382:         return header.asFloat32Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                         succeeded);
94605:       case Float64Elements:
95382:         return header.asFloat64Elements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                         succeeded);
94605:       case ArrayBufferElements:
95382:         return header.asArrayBufferElements().defineElement(cx, obj, index, desc, shouldThrow,
95382:                                                             succeeded);
94605:     }
94605: 
94605:     MOZ_NOT_REACHED("bad elements kind!");
94605:     return false;
94605: }
97092: 
97092: bool
97092: SparseElementsHeader::setElement(JSContext *cx, ObjectImpl *obj, ObjectImpl *receiver,
97092:                                  uint32_t index, const Value &v, bool *succeeded)
97092: {
97092:     MOZ_ASSERT(this == &obj->elementsHeader());
97092: 
97092:     MOZ_NOT_REACHED("NYI");
97092:     return false;
97092: }
97092: 
97092: bool
97092: DenseElementsHeader::setElement(JSContext *cx, ObjectImpl *obj, ObjectImpl *receiver,
97092:                                 uint32_t index, const Value &v, bool *succeeded)
97092: {
97092:     MOZ_ASSERT(this == &obj->elementsHeader());
97092: 
97092:     MOZ_NOT_REACHED("NYI");
97092:     return false;
97092: }
97092: 
97092: template <typename T>
97092: bool
97092: TypedElementsHeader<T>::setElement(JSContext *cx, ObjectImpl *obj, ObjectImpl *receiver,
97092:                                    uint32_t index, const Value &v, bool *succeeded)
97092: {
97092:     MOZ_ASSERT(this == &obj->elementsHeader());
97092: 
97092:     uint32_t len = length();
97092:     if (index >= len) {
97092:         /*
97092:          * Silent ignore is better than an exception here, because at some
97092:          * point we may want to support other properties on these objects.
97092:          */
97092:         *succeeded = true;
97092:         return true;
97092:     }
97092: 
97092:     /* Convert the value being set to the element type. */
97092:     double d;
97092:     if (v.isNumber()) {
97092:         d = v.toNumber();
97092:     } else if (v.isNull()) {
97092:         d = 0.0;
97092:     } else if (v.isPrimitive()) {
97092:         if (v.isString()) {
97092:             if (!ToNumber(cx, v, &d))
97092:                 return false;
97092:         } else if (v.isUndefined()) {
97092:             d = js_NaN;
97092:         } else {
97092:             d = double(v.toBoolean());
97092:         }
97092:     } else {
97092:         // non-primitive assignments become NaN or 0 (for float/int arrays)
97092:         d = js_NaN;
97092:     }
97092: 
97092:     assign(index, d);
97092:     *succeeded = true;
97092:     return true;
97092: }
97092: 
97092: bool
97092: ArrayBufferElementsHeader::setElement(JSContext *cx, ObjectImpl *obj, ObjectImpl *receiver,
97092:                                       uint32_t index, const Value &v, bool *succeeded)
97092: {
97092:     MOZ_ASSERT(this == &obj->elementsHeader());
97092: 
97092:     JSObject *delegate = ArrayBufferDelegate(cx, obj);
97092:     if (!delegate)
97092:         return false;
97092:     return SetElement(cx, obj, receiver, index, v, succeeded);
97092: }
97092: 
97092: bool
97092: js::SetElement(JSContext *cx, ObjectImpl *obj, ObjectImpl *receiver, uint32_t index,
97092:                const Value &v, bool *succeeded)
97092: {
97092:     NEW_OBJECT_REPRESENTATION_ONLY();
97092: 
97092:     do {
97092:         MOZ_ASSERT(obj);
97092: 
97092:         if (static_cast<JSObject *>(obj)->isProxy()) { // XXX
97092:             MOZ_NOT_REACHED("NYI: proxy [[SetP]]");
97092:             return false;
97092:         }
97092: 
97092:         PropDesc ownDesc;
97092:         if (!GetOwnElement(cx, obj, index, &ownDesc))
97092:             return false;
97092: 
97092:         if (!ownDesc.isUndefined()) {
97092:             if (ownDesc.isDataDescriptor()) {
97092:                 if (!ownDesc.writable()) {
97092:                     *succeeded = false;
97092:                     return true;
97092:                 }
97092: 
97092:                 if (receiver == obj) {
97092:                     PropDesc updateDesc = PropDesc::valueOnly(v);
97092:                     return DefineElement(cx, receiver, index, updateDesc, false, succeeded);
97092:                 }
97092: 
97092:                 PropDesc newDesc;
97092:                 return DefineElement(cx, receiver, index, newDesc, false, succeeded);
97092:             }
97092: 
97092:             if (ownDesc.isAccessorDescriptor()) {
97092:                 Value setter = ownDesc.setterValue();
97092:                 if (setter.isUndefined()) {
97092:                     *succeeded = false;
97092:                     return true;
97092:                 }
97092: 
97092:                 InvokeArgsGuard args;
97092:                 if (!cx->stack.pushInvokeArgs(cx, 1, &args))
97092:                     return false;
97092: 
97092:                 /* Push set, receiver, and v as the sole argument. */
97092:                 args.calleev() = setter;
97092:                 args.thisv() = ObjectValue(*receiver);
97092:                 args[0] = v;
97092: 
97092:                 *succeeded = true;
97092:                 return Invoke(cx, args);
97092:             }
97092: 
97092:             MOZ_NOT_REACHED("NYI: setting PropertyOp-based property");
97092:             return false;
97092:         }
97092: 
97092:         obj = obj->getProto();
97092:         if (obj)
97092:             continue;
97092: 
97092:         PropDesc newDesc(v, PropDesc::Writable, PropDesc::Enumerable, PropDesc::Configurable);
97092:         return DefineElement(cx, receiver, index, newDesc, false, succeeded);
97092:     } while (false);
97092: }
