    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *   Mike Pinkerton (pinkerton@netscape.com)
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Ben Goodger <ben@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsMenuPopupFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIContent.h"
    1: #include "prtypes.h"
    1: #include "nsIAtom.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIViewManager.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsMenuFrame.h"
 3129: #include "nsMenuBarFrame.h"
 3129: #include "nsPopupSetFrame.h"
 3129: #include "nsEventDispatcher.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMScreen.h"
    1: #include "nsIPresShell.h"
    1: #include "nsFrameManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsRect.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRootBox.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
 3129: #include "nsLayoutUtils.h"
18972: #include "nsContentUtils.h"
    1: #include "nsCSSFrameConstructor.h"
 3129: #include "nsIEventStateManager.h"
    1: #include "nsIBoxLayout.h"
    1: #include "nsIPopupBoxObject.h"
49217: #include "nsPIWindowRoot.h"
    1: #include "nsIReflowCallback.h"
 3189: #include "nsBindingManager.h"
 8408: #include "nsIDocShellTreeOwner.h"
 8408: #include "nsIBaseWindow.h"
34005: #include "nsISound.h"
23206: #include "nsIRootBox.h"
28037: #include "nsIScreenManager.h"
28037: #include "nsIServiceManager.h"
36751: #include "nsThemeConstants.h"
    1: 
48254: PRInt8 nsMenuPopupFrame::sDefaultLevelIsTop = -1;
18972: 
    1: // NS_NewMenuPopupFrame
    1: //
    1: // Wrapper for creating a new menu popup container
    1: //
    1: nsIFrame*
    1: NS_NewMenuPopupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsMenuPopupFrame (aPresShell, aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsMenuPopupFrame)
32423: 
    1: //
    1: // nsMenuPopupFrame ctor
    1: //
    1: nsMenuPopupFrame::nsMenuPopupFrame(nsIPresShell* aShell, nsStyleContext* aContext)
    1:   :nsBoxFrame(aShell, aContext),
    1:   mCurrentMenu(nsnull),
28285:   mPrefSize(-1, -1),
28285:   mPopupType(ePopupTypePanel),
28285:   mPopupState(ePopupClosed),
 3129:   mPopupAlignment(POPUPALIGNMENT_NONE),
 3129:   mPopupAnchor(POPUPALIGNMENT_NONE),
55434:   mFlipBoth(PR_FALSE),
 3129:   mIsOpenChanged(PR_FALSE),
 3129:   mIsContextMenu(PR_FALSE),
14630:   mAdjustOffsetForContextMenu(PR_FALSE),
 3129:   mGeneratedChildren(PR_FALSE),
    1:   mMenuCanOverlapOSBar(PR_FALSE),
    1:   mShouldAutoPosition(PR_TRUE),
  677:   mConsumeRollupEvent(nsIPopupBoxObject::ROLLUP_DEFAULT),
36614:   mInContentShell(PR_TRUE),
41073:   mIsMenuLocked(PR_FALSE),
36614:   mHFlip(PR_FALSE),
36614:   mVFlip(PR_FALSE)
    1: {
48254:   // the preference name is backwards here. True means that the 'top' level is
48254:   // the default, and false means that the 'parent' level is the default.
48254:   if (sDefaultLevelIsTop >= 0)
18972:     return;
48254:   sDefaultLevelIsTop =
18972:     nsContentUtils::GetBoolPref("ui.panel.default_level_parent", PR_FALSE);
    1: } // ctor
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsMenuPopupFrame::Init(nsIContent*      aContent,
    1:                        nsIFrame*        aParent,
    1:                        nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
 1412:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   // lookup if we're allowed to overlap the OS bar (menubar/taskbar) from the
    1:   // look&feel object
    1:   PRBool tempBool;
    1:   presContext->LookAndFeel()->
    1:     GetMetric(nsILookAndFeel::eMetric_MenusCanOverlapOSBar, tempBool);
    1:   mMenuCanOverlapOSBar = tempBool;
    1: 
 3129:   rv = CreateViewForFrame(presContext, this, GetStyleContext(), PR_TRUE, PR_TRUE);
 1412:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3129:   // XXX Hack. The popup's view should float above all other views,
 3129:   // so we use the nsIView::SetFloating() to tell the view manager
 3129:   // about that constraint.
    1:   nsIView* ourView = GetView();
    1:   nsIViewManager* viewManager = ourView->GetViewManager();
 3129:   viewManager->SetViewFloating(ourView, PR_TRUE);
    1: 
 3129:   mPopupType = ePopupTypePanel;
 3129:   nsIDocument* doc = aContent->GetOwnerDoc();
 3129:   if (doc) {
 3129:     PRInt32 namespaceID;
 3129:     nsCOMPtr<nsIAtom> tag = doc->BindingManager()->ResolveTag(aContent, &namespaceID);
 3129:     if (namespaceID == kNameSpaceID_XUL) {
 3129:       if (tag == nsGkAtoms::menupopup || tag == nsGkAtoms::popup)
 3129:         mPopupType = ePopupTypeMenu;
 3129:       else if (tag == nsGkAtoms::tooltip)
 3129:         mPopupType = ePopupTypeTooltip;
 3129:     }
 3129:   }
    1: 
  677:   nsCOMPtr<nsISupports> cont = PresContext()->GetContainer();
  677:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
  677:   PRInt32 type = -1;
  677:   if (dsti && NS_SUCCEEDED(dsti->GetItemType(&type)) &&
  677:       type == nsIDocShellTreeItem::typeChrome)
  677:     mInContentShell = PR_FALSE;
  677: 
 3129:   // To improve performance, create the widget for the popup only if it is not
 3129:   // a leaf. Leaf popups such as menus will create their widgets later when
 3129:   // the popup opens.
 3129:   if (!IsLeaf() && !ourView->HasWidget()) {
    1:     CreateWidgetForView(ourView);
    1:   }
    1: 
23951:   if (aContent->NodeInfo()->Equals(nsGkAtoms::tooltip, kNameSpaceID_XUL) &&
23951:       aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::_default,
23951:                             nsGkAtoms::_true, eIgnoreCase)) {
23951:     nsIRootBox* rootBox =
23951:       nsIRootBox::GetRootBox(PresContext()->GetPresShell());
23951:     if (rootBox) {
23951:       rootBox->SetDefaultTooltip(aContent);
23951:     }
23951:   }
23951: 
 3129:   return rv;
 3129: }
 2946: 
 8408: PRBool
48254: nsMenuPopupFrame::IsNoAutoHide() const
 8408: {
 8408:   // Panels with noautohide="true" don't hide when the mouse is clicked
 8408:   // outside of them, or when another application is made active. Non-autohide
 8408:   // panels cannot be used in content windows.
 8408:   return (!mInContentShell && mPopupType == ePopupTypePanel &&
 8408:            mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautohide,
 8408:                                  nsGkAtoms::_true, eIgnoreCase));
 8408: }
 8408: 
48254: nsPopupLevel
48254: nsMenuPopupFrame::PopupLevel(PRBool aIsNoAutoHide) const
18972: {
48254:   // The popup level is determined as follows, in this order:
48254:   //   1. non-panels (menus and tooltips) are always topmost
48254:   //   2. any specified level attribute
48256:   //   3. if a titlebar attribute is set, use the 'floating' level
48256:   //   4. if this is a noautohide panel, use the 'parent' level
48256:   //   5. use the platform-specific default level
48254: 
48254:   // If this is not a panel, this is always a top-most popup.
18972:   if (mPopupType != ePopupTypePanel)
48254:     return ePopupLevelTop;
18972: 
48254:   // If the level attribute has been set, use that.
48254:   static nsIContent::AttrValuesArray strings[] =
48254:     {&nsGkAtoms::top, &nsGkAtoms::parent, &nsGkAtoms::floating, nsnull};
48254:   switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::level,
48254:                                     strings, eCaseMatters)) {
48254:     case 0:
48254:       return ePopupLevelTop;
48254:     case 1:
48254:       return ePopupLevelParent;
48254:     case 2:
48254:       return ePopupLevelFloating;
48254:   }
18972: 
48256:   // Panels with titlebars most likely want to be floating popups.
48256:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::titlebar))
48256:     return ePopupLevelFloating;
48256: 
48254:   // If this panel is a noautohide panel, the default is the parent level.
48254:   if (aIsNoAutoHide)
48254:     return ePopupLevelParent;
18972: 
18972:   // Otherwise, the result depends on the platform.
48254:   return sDefaultLevelIsTop ? ePopupLevelTop : ePopupLevelParent;
18972: }
18972: 
 3129: void
 3129: nsMenuPopupFrame::EnsureWidget()
 3129: {
 3129:   nsIView* ourView = GetView();
 3129:   if (!ourView->HasWidget()) {
 3129:     NS_ASSERTION(!mGeneratedChildren && !GetFirstChild(nsnull),
 3129:                  "Creating widget for MenuPopupFrame with children");
 3129:     CreateWidgetForView(ourView);
 3129:   }
    1: }
    1: 
    1: nsresult
    1: nsMenuPopupFrame::CreateWidgetForView(nsIView* aView)
    1: {
    1:   // Create a widget for ourselves.
    1:   nsWidgetInitData widgetData;
    1:   widgetData.mWindowType = eWindowType_popup;
    1:   widgetData.mBorderStyle = eBorderStyle_default;
    1:   widgetData.clipSiblings = PR_TRUE;
12796:   widgetData.mPopupHint = mPopupType;
48254:   widgetData.mNoAutoHide = IsNoAutoHide();
    1: 
48260:   nsAutoString title;
48256:   if (mContent && widgetData.mNoAutoHide) {
48256:     if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::titlebar,
48256:                               nsGkAtoms::normal, eCaseMatters)) {
48256:       widgetData.mBorderStyle = eBorderStyle_title;
48260: 
48260:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, title);
48261: 
48261:       if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::close,
48261:                                 nsGkAtoms::_true, eCaseMatters)) {
48261:         widgetData.mBorderStyle =
48261:           static_cast<enum nsBorderStyle>(widgetData.mBorderStyle | eBorderStyle_close);
48261:       }
48256:     }
48256:   }
48256: 
31535:   nsTransparencyMode mode = nsLayoutUtils::GetFrameTransparency(this, this);
 1345:   PRBool viewHasTransparentContent = !mInContentShell &&
16601:                                      (eTransparencyTransparent ==
19222:                                       mode);
    1:   nsIContent* parentContent = GetContent()->GetParent();
    1:   nsIAtom *tag = nsnull;
    1:   if (parentContent)
    1:     tag = parentContent->Tag();
    1:   widgetData.mDropShadow = !(viewHasTransparentContent || tag == nsGkAtoms::menulist);
48254:   widgetData.mPopupLevel = PopupLevel(widgetData.mNoAutoHide);
    1: 
48254:   // panels which have a parent level need a parent widget. This allows them to
18972:   // always appear in front of the parent window but behind other windows that
18972:   // should be in front of it.
 8408:   nsCOMPtr<nsIWidget> parentWidget;
48254:   if (widgetData.mPopupLevel != ePopupLevelTop) {
 8408:     nsCOMPtr<nsISupports> cont = PresContext()->GetContainer();
 8408:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
 8408:     if (!dsti)
 8408:       return NS_ERROR_FAILURE;
 8408: 
 8408:     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
 8408:     dsti->GetTreeOwner(getter_AddRefs(treeOwner));
 8408:     if (!treeOwner) return NS_ERROR_FAILURE;
 8408: 
 8408:     nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(treeOwner));
 8408:     if (baseWindow)
 8408:       baseWindow->GetMainWidget(getter_AddRefs(parentWidget));
 8408:   }
 8408: 
62901:   nsresult rv = aView->CreateWidgetForPopup(&widgetData, parentWidget,
54355:                                             PR_TRUE, PR_TRUE);
62901:   if (NS_FAILED(rv)) {
62901:     return rv;
62901:   }
51050: 
20467:   nsIWidget* widget = aView->GetWidget();
20653:   widget->SetTransparencyMode(mode);
36751:   widget->SetWindowShadowStyle(GetShadowStyle());
48260: 
48260:   // most popups don't have a title so avoid setting the title if there isn't one
48260:   if (!title.IsEmpty()) {
48260:     widget->SetTitle(title);
48260:   }
48260: 
    1:   return NS_OK;
    1: }
    1: 
36751: PRUint8
36751: nsMenuPopupFrame::GetShadowStyle()
36751: {
36751:   PRUint8 shadow = GetStyleUIReset()->mWindowShadow;
36751:   if (shadow != NS_STYLE_WINDOW_SHADOW_DEFAULT)
36751:     return shadow;
36751: 
36751:   switch (GetStyleDisplay()->mAppearance) {
36751:     case NS_THEME_TOOLTIP:
36751:       return NS_STYLE_WINDOW_SHADOW_TOOLTIP;
36751:     case NS_THEME_MENUPOPUP:
36751:       return NS_STYLE_WINDOW_SHADOW_MENU;
36751:   }
36751:   return NS_STYLE_WINDOW_SHADOW_DEFAULT;
36751: }
36751: 
49217: // this class is used for dispatching popupshown events asynchronously.
 3129: class nsXULPopupShownEvent : public nsRunnable
 3129: {
 3129: public:
 3129:   nsXULPopupShownEvent(nsIContent *aPopup, nsPresContext* aPresContext)
 3129:     : mPopup(aPopup), mPresContext(aPresContext)
 3129:   {
 3129:   }
 3129: 
 3129:   NS_IMETHOD Run()
 3129:   {
 3129:     nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_SHOWN, nsnull, nsMouseEvent::eReal);
 3129:     return nsEventDispatcher::Dispatch(mPopup, mPresContext, &event);                 
 3129:   }
 3129: 
 3129: private:
 3129:   nsCOMPtr<nsIContent> mPopup;
 3129:   nsRefPtr<nsPresContext> mPresContext;
 3129: };
 3129: 
 3129: NS_IMETHODIMP
 3129: nsMenuPopupFrame::SetInitialChildList(nsIAtom* aListName,
30790:                                       nsFrameList& aChildList)
 3129: {
 3129:   // unless the list is empty, indicate that children have been generated.
30790:   if (aChildList.NotEmpty())
 3129:     mGeneratedChildren = PR_TRUE;
 3129:   return nsBoxFrame::SetInitialChildList(aListName, aChildList);
 3129: }
 3129: 
 5921: PRBool
 5921: nsMenuPopupFrame::IsLeaf() const
 5921: {
 5921:   if (mGeneratedChildren)
 5921:     return PR_FALSE;
 5921: 
 5921:   if (mPopupType != ePopupTypeMenu) {
 5921:     // any panel with a type attribute, such as the autocomplete popup,
 5921:     // is always generated right away.
 5921:     return !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::type);
 5921:   }
 5921: 
 5921:   // menu popups generate their child frames lazily only when opened, so
 5921:   // behave like a leaf frame. However, generate child frames normally if
 5921:   // the parent menu has a sizetopopup attribute. In this case the size of
48256:   // the parent menu is dependent on the size of the popup, so the frames
 5921:   // need to exist in order to calculate this size.
 5921:   nsIContent* parentContent = mContent->GetParent();
 5921:   return (parentContent &&
 5921:           !parentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::sizetopopup));
 5921: }
 5921: 
 3129: void
42267: nsMenuPopupFrame::LayoutPopup(nsBoxLayoutState& aState, nsIFrame* aParentMenu, PRBool aSizedToPopup)
 9482: {
52061:   if (!mGeneratedChildren)
52061:     return;
52061: 
52061:   PRBool shouldPosition = PR_TRUE;
42267:   PRBool isOpen = IsOpen();
52061:   if (!isOpen) {
52061:     // if the popup is not open, only do layout while showing or if the menu
52061:     // is sized to the popup
52061:     shouldPosition = (mPopupState == ePopupShowing);
52061:     if (!shouldPosition && !aSizedToPopup)
42267:       return;
52061:   }
52061: 
52061:   // if the popup has just been opened, make sure the scrolled window is at 0,0
52061:   if (mIsOpenChanged) {
52061:     nsIScrollableFrame *scrollframe = do_QueryFrame(GetChildBox());
52061:     if (scrollframe) {
52061:       scrollframe->ScrollTo(nsPoint(0,0), nsIScrollableFrame::INSTANT);
52061:     }
52061:   }
42267: 
42267:   // get the preferred, minimum and maximum size. If the menu is sized to the
42267:   // popup, then the popup's width is the menu's width.
42267:   nsSize prefSize = GetPrefSize(aState);
42267:   nsSize minSize = GetMinSize(aState); 
42267:   nsSize maxSize = GetMaxSize(aState);
42267: 
42267:   if (aSizedToPopup) {
42267:     prefSize.width = aParentMenu->GetRect().width;
42267:   }
42267:   prefSize = BoundsCheck(minSize, prefSize, maxSize);
42267: 
42267:   // if the size changed then set the bounds to be the preferred size
42267:   PRBool sizeChanged = (mPrefSize != prefSize);
42267:   if (sizeChanged) {
42267:     SetBounds(aState, nsRect(0, 0, prefSize.width, prefSize.height), PR_FALSE);
42267:     mPrefSize = prefSize;
42267:   }
42267: 
52061:   if (shouldPosition) {
42267:     SetPopupPosition(aParentMenu, PR_FALSE);
42267:   }
42267: 
42267:   nsRect bounds(GetRect());
42267:   Layout(aState);
42267: 
42267:   // if the width or height changed, readjust the popup position. This is a
42267:   // special case for tooltips where the preferred height doesn't include the
42267:   // real height for its inline element, but does once it is laid out.
42267:   // This is bug 228673 which doesn't have a simple fix.
42267:   if (!aParentMenu) {
42267:     nsSize newsize = GetSize();
42267:     if (newsize.width > bounds.width || newsize.height > bounds.height) {
42267:       // the size after layout was larger than the preferred size,
42267:       // so set the preferred size accordingly
42267:       mPrefSize = newsize;
42267:       if (isOpen) {
42267:         SetPopupPosition(nsnull, PR_FALSE);
42267:       }
42267:     }
42267:   }
42267: 
52061:   nsPresContext* pc = PresContext();
42267:   if (isOpen) {
 3129:     nsIView* view = GetView();
 3129:     nsIViewManager* viewManager = view->GetViewManager();
 3129:     nsRect rect = GetRect();
 3129:     rect.x = rect.y = 0;
48256: 
48256:     // Increase the popup's view size to account for any titlebar or borders.
48256:     // XXXndeakin this should really be accounted for earlier in
48256:     // SetPopupPosition so that this extra size is accounted for when flipping
48256:     // or resizing the popup due to it being too large, but that can be a
48256:     // followup bug.
48256:     if (mPopupType == ePopupTypePanel && view) {
48256:       nsIWidget* widget = view->GetWidget();
48256:       if (widget) {
48256:         nsIntSize popupSize = nsIntSize(pc->AppUnitsToDevPixels(rect.width),
48256:                                         pc->AppUnitsToDevPixels(rect.height));
48256:         popupSize = widget->ClientToWindowSize(popupSize);
48256:         rect.width = pc->DevPixelsToAppUnits(popupSize.width);
48256:         rect.height = pc->DevPixelsToAppUnits(popupSize.height);
48256:       }
48256:     }
 3129:     viewManager->ResizeView(view, rect);
48256: 
 3129:     viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
 4234:     mPopupState = ePopupOpenAndVisible;
 3129:     nsContainerFrame::SyncFrameViewProperties(pc, this, nsnull, view, 0);
52061:   }
 3129: 
52061:   // finally, if the popup just opened, send a popupshown event
 3129:   if (mIsOpenChanged) {
 3129:     mIsOpenChanged = PR_FALSE;
 3129:     nsCOMPtr<nsIRunnable> event = new nsXULPopupShownEvent(GetContent(), pc);
 3129:     NS_DispatchToCurrentThread(event);
 3129:   }
 3129: }
 3129: 
52416: nsIContent*
52416: nsMenuPopupFrame::GetTriggerContent(nsMenuPopupFrame* aMenuPopupFrame)
52416: {
52416:   while (aMenuPopupFrame) {
52416:     if (aMenuPopupFrame->mTriggerContent)
52416:       return aMenuPopupFrame->mTriggerContent;
52416: 
52416:     // check up the menu hierarchy until a popup with a trigger node is found
52416:     nsMenuFrame* menuFrame = aMenuPopupFrame->GetParentMenu();
52416:     if (!menuFrame)
52416:       break;
52416: 
52416:     nsMenuParent* parentPopup = menuFrame->GetMenuParent();
52416:     if (!parentPopup || !parentPopup->IsMenu())
52416:       break;
52416: 
52416:     aMenuPopupFrame = static_cast<nsMenuPopupFrame *>(parentPopup);
52416:   }
52416: 
52416:   return nsnull;
52416: }
52416: 
 3129: void
 3129: nsMenuPopupFrame::InitPositionFromAnchorAlign(const nsAString& aAnchor,
 3129:                                               const nsAString& aAlign)
 3129: {
49217:   mTriggerContent = nsnull;
49217: 
 3129:   if (aAnchor.EqualsLiteral("topleft"))
 3129:     mPopupAnchor = POPUPALIGNMENT_TOPLEFT;
 3129:   else if (aAnchor.EqualsLiteral("topright"))
 3129:     mPopupAnchor = POPUPALIGNMENT_TOPRIGHT;
 3129:   else if (aAnchor.EqualsLiteral("bottomleft"))
 3129:     mPopupAnchor = POPUPALIGNMENT_BOTTOMLEFT;
 3129:   else if (aAnchor.EqualsLiteral("bottomright"))
 3129:     mPopupAnchor = POPUPALIGNMENT_BOTTOMRIGHT;
58647:   else if (aAnchor.EqualsLiteral("leftcenter"))
58647:     mPopupAnchor = POPUPALIGNMENT_LEFTCENTER;
58647:   else if (aAnchor.EqualsLiteral("rightcenter"))
58647:     mPopupAnchor = POPUPALIGNMENT_RIGHTCENTER;
58647:   else if (aAnchor.EqualsLiteral("topcenter"))
58647:     mPopupAnchor = POPUPALIGNMENT_TOPCENTER;
58647:   else if (aAnchor.EqualsLiteral("bottomcenter"))
58647:     mPopupAnchor = POPUPALIGNMENT_BOTTOMCENTER;
 3129:   else
 3129:     mPopupAnchor = POPUPALIGNMENT_NONE;
 3129: 
 3129:   if (aAlign.EqualsLiteral("topleft"))
 3129:     mPopupAlignment = POPUPALIGNMENT_TOPLEFT;
 3129:   else if (aAlign.EqualsLiteral("topright"))
 3129:     mPopupAlignment = POPUPALIGNMENT_TOPRIGHT;
 3129:   else if (aAlign.EqualsLiteral("bottomleft"))
 3129:     mPopupAlignment = POPUPALIGNMENT_BOTTOMLEFT;
 3129:   else if (aAlign.EqualsLiteral("bottomright"))
 3129:     mPopupAlignment = POPUPALIGNMENT_BOTTOMRIGHT;
 3129:   else
 3129:     mPopupAlignment = POPUPALIGNMENT_NONE;
 3129: }
 3129: 
 3129: void
 3129: nsMenuPopupFrame::InitializePopup(nsIContent* aAnchorContent,
49217:                                   nsIContent* aTriggerContent,
 3129:                                   const nsAString& aPosition,
 3129:                                   PRInt32 aXPos, PRInt32 aYPos,
 3129:                                   PRBool aAttributesOverride)
 3129: {
 3129:   EnsureWidget();
 3129: 
 4234:   mPopupState = ePopupShowing;
 3129:   mAnchorContent = aAnchorContent;
49217:   mTriggerContent = aTriggerContent;
 3129:   mXPos = aXPos;
 3129:   mYPos = aYPos;
14630:   mAdjustOffsetForContextMenu = PR_FALSE;
 3129: 
 3129:   // if aAttributesOverride is true, then the popupanchor, popupalign and
 3129:   // position attributes on the <popup> override those values passed in.
 3129:   // If false, those attributes are only used if the values passed in are empty
 3129:   if (aAnchorContent) {
55434:     nsAutoString anchor, align, position, flip;
 3129:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::popupanchor, anchor);
 3129:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::popupalign, align);
 3129:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::position, position);
55434:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::flip, flip);
 3129: 
 3129:     if (aAttributesOverride) {
 3129:       // if the attributes are set, clear the offset position. Otherwise,
 3129:       // the offset is used to adjust the position from the anchor point
 3129:       if (anchor.IsEmpty() && align.IsEmpty() && position.IsEmpty())
 3129:         position.Assign(aPosition);
 3129:       else
 3129:         mXPos = mYPos = 0;
 3129:     }
 3129:     else if (!aPosition.IsEmpty()) {
 3129:       position.Assign(aPosition);
 3129:     }
 3129: 
55434:     mFlipBoth = flip.EqualsLiteral("both");
55434: 
58647:     position.CompressWhitespace();
58647:     PRInt32 spaceIdx = position.FindChar(' ');
58647:     // if there is a space in the position, assume it is the anchor and
58647:     // alignment as two separate tokens.
58647:     if (spaceIdx >= 0) {
58647:       InitPositionFromAnchorAlign(Substring(position, 0, spaceIdx), Substring(position, spaceIdx + 1));
58647:     }
58647:     else if (position.EqualsLiteral("before_start")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_TOPLEFT;
 3129:       mPopupAlignment = POPUPALIGNMENT_BOTTOMLEFT;
 3129:     }
 3129:     else if (position.EqualsLiteral("before_end")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_TOPRIGHT;
 3129:       mPopupAlignment = POPUPALIGNMENT_BOTTOMRIGHT;
 3129:     }
 3129:     else if (position.EqualsLiteral("after_start")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_BOTTOMLEFT;
 3129:       mPopupAlignment = POPUPALIGNMENT_TOPLEFT;
 3129:     }
 3129:     else if (position.EqualsLiteral("after_end")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_BOTTOMRIGHT;
 3129:       mPopupAlignment = POPUPALIGNMENT_TOPRIGHT;
 3129:     }
 3129:     else if (position.EqualsLiteral("start_before")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_TOPLEFT;
 3129:       mPopupAlignment = POPUPALIGNMENT_TOPRIGHT;
 3129:     }
 3129:     else if (position.EqualsLiteral("start_after")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_BOTTOMLEFT;
 3129:       mPopupAlignment = POPUPALIGNMENT_BOTTOMRIGHT;
 3129:     }
 3129:     else if (position.EqualsLiteral("end_before")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_TOPRIGHT;
 3129:       mPopupAlignment = POPUPALIGNMENT_TOPLEFT;
 3129:     }
 3129:     else if (position.EqualsLiteral("end_after")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_BOTTOMRIGHT;
 3129:       mPopupAlignment = POPUPALIGNMENT_BOTTOMLEFT;
 3129:     }
 3129:     else if (position.EqualsLiteral("overlap")) {
 3129:       mPopupAnchor = POPUPALIGNMENT_TOPLEFT;
 3129:       mPopupAlignment = POPUPALIGNMENT_TOPLEFT;
 3129:     }
 3129:     else if (position.EqualsLiteral("after_pointer")) {
33500:       mPopupAnchor = POPUPALIGNMENT_TOPLEFT;
33500:       mPopupAlignment = POPUPALIGNMENT_TOPLEFT;
 3129:       // XXXndeakin this is supposed to anchor vertically after, but with the
 3129:       // horizontal position as the mouse pointer.
 3129:       mYPos += 21;
 3129:     }
 3129:     else {
 3129:       InitPositionFromAnchorAlign(anchor, align);
 3129:     }
 3129:   }
 3129: 
 3129:   mScreenXPos = -1;
 3129:   mScreenYPos = -1;
 3129: 
 3129:   if (aAttributesOverride) {
 3129:     // Use |left| and |top| dimension attributes to position the popup if
 3129:     // present, as they may have been persisted. 
 3129:     nsAutoString left, top;
 3129:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::left, left);
 3129:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::top, top);
 3129: 
 3129:     PRInt32 err;
 3129:     if (!left.IsEmpty()) {
 3129:       PRInt32 x = left.ToInteger(&err);
 3129:       if (NS_SUCCEEDED(err))
 3129:         mScreenXPos = x;
 3129:     }
 3129:     if (!top.IsEmpty()) {
 3129:       PRInt32 y = top.ToInteger(&err);
 3129:       if (NS_SUCCEEDED(err))
 3129:         mScreenYPos = y;
 3129:     }
 3129:   }
 3129: }
 3129: 
 3129: void
49217: nsMenuPopupFrame::InitializePopupAtScreen(nsIContent* aTriggerContent,
49217:                                           PRInt32 aXPos, PRInt32 aYPos,
14630:                                           PRBool aIsContextMenu)
 3129: {
 3129:   EnsureWidget();
 3129: 
 4234:   mPopupState = ePopupShowing;
 3129:   mAnchorContent = nsnull;
49217:   mTriggerContent = aTriggerContent;
 3129:   mScreenXPos = aXPos;
 3129:   mScreenYPos = aYPos;
55434:   mFlipBoth = PR_FALSE;
 3129:   mPopupAnchor = POPUPALIGNMENT_NONE;
 3129:   mPopupAlignment = POPUPALIGNMENT_NONE;
14630:   mIsContextMenu = aIsContextMenu;
14630:   mAdjustOffsetForContextMenu = aIsContextMenu;
 3129: }
 3129: 
 3129: void
 3129: nsMenuPopupFrame::InitializePopupWithAnchorAlign(nsIContent* aAnchorContent,
 3129:                                                  nsAString& aAnchor,
 3129:                                                  nsAString& aAlign,
 3129:                                                  PRInt32 aXPos, PRInt32 aYPos)
 3129: {
 3129:   EnsureWidget();
 3129: 
 4234:   mPopupState = ePopupShowing;
14630:   mAdjustOffsetForContextMenu = PR_FALSE;
55434:   mFlipBoth = PR_FALSE;
 3129: 
 3129:   // this popup opening function is provided for backwards compatibility
 3129:   // only. It accepts either coordinates or an anchor and alignment value
 3129:   // but doesn't use both together.
 3129:   if (aXPos == -1 && aYPos == -1) {
 3129:     mAnchorContent = aAnchorContent;
 3129:     mScreenXPos = -1;
 3129:     mScreenYPos = -1;
 3202:     mXPos = 0;
 3202:     mYPos = 0;
 3129:     InitPositionFromAnchorAlign(aAnchor, aAlign);
 3129:   }
 3129:   else {
 3129:     mAnchorContent = nsnull;
 3129:     mPopupAnchor = POPUPALIGNMENT_NONE;
 3129:     mPopupAlignment = POPUPALIGNMENT_NONE;
 3129:     mScreenXPos = aXPos;
 3129:     mScreenYPos = aYPos;
 3202:     mXPos = aXPos;
 3202:     mYPos = aYPos;
 3129:   }
 3129: }
 3129: 
20261: void
 3129: nsMenuPopupFrame::ShowPopup(PRBool aIsContextMenu, PRBool aSelectFirstItem)
 3129: {
 3129:   mIsContextMenu = aIsContextMenu;
 3129: 
 4234:   if (mPopupState == ePopupShowing) {
 4234:     mPopupState = ePopupOpen;
 3129:     mIsOpenChanged = PR_TRUE;
 3129: 
49217:     nsMenuFrame* menuFrame = GetParentMenu();
49217:     if (menuFrame) {
 3129:       nsWeakFrame weakFrame(this);
49217:       menuFrame->PopupOpened();
 3129:       if (!weakFrame.IsAlive())
52061:         return;
 3129:     }
 3129: 
52061:     // do we need an actual reflow here?
52061:     // is SetPopupPosition all that is needed?
52061:     PresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 3129:                                                  NS_FRAME_HAS_DIRTY_CHILDREN);
52061: 
22575:     if (mPopupType == ePopupTypeMenu) {
34005:       nsCOMPtr<nsISound> sound(do_CreateInstance("@mozilla.org/sound;1"));
34005:       if (sound)
34005:         sound->PlayEventSound(nsISound::EVENT_MENU_POPUP);
22575:     }
 3129:   }
 3129: 
 3129:   mShouldAutoPosition = PR_TRUE;
 3129: }
 3129: 
 3129: void
 4234: nsMenuPopupFrame::HidePopup(PRBool aDeselectMenu, nsPopupState aNewState)
 3129: {
 4234:   NS_ASSERTION(aNewState == ePopupClosed || aNewState == ePopupInvisible,
 4234:                "popup being set to unexpected state");
 4234: 
 4234:   // don't hide the popup when it isn't open
 4234:   if (mPopupState == ePopupClosed || mPopupState == ePopupShowing)
 4234:     return;
 4234: 
49217:   // clear the trigger content if the popup is being closed. But don't clear
49217:   // it if the popup is just being made invisible as a popuphiding or command
49217:   // event may want to retrieve it.
49217:   if (aNewState == ePopupClosed) {
49217:     // if the popup had a trigger node set, clear the global window popup node
49217:     // as well
49217:     if (mTriggerContent) {
49217:       nsIDocument* doc = mContent->GetCurrentDoc();
49217:       if (doc) {
49217:         nsPIDOMWindow* win = doc->GetWindow();
49217:         if (win) {
49217:           nsCOMPtr<nsPIWindowRoot> root = win->GetTopWindowRoot();
49217:           if (root) {
49217:             root->SetPopupNode(nsnull);
49217:           }
49217:         }
49217:       }
49217:     }
49217:     mTriggerContent = nsnull;
55434:     mAnchorContent = nsnull;
49217:   }
49217: 
 4234:   // when invisible and about to be closed, HidePopup has already been called,
 4234:   // so just set the new state to closed and return
 4234:   if (mPopupState == ePopupInvisible) {
 4234:     if (aNewState == ePopupClosed)
 4234:       mPopupState = ePopupClosed;
 4234:     return;
 4234:   }
 4234: 
 4234:   mPopupState = aNewState;
 4234: 
 3129:   if (IsMenu())
 3129:     SetCurrentMenuItem(nsnull);
 3129: 
 3129:   mIncrementalString.Truncate();
 3129: 
41073:   LockMenuUntilClosed(PR_FALSE);
41073: 
 3129:   mIsOpenChanged = PR_FALSE;
 3129:   mCurrentMenu = nsnull; // make sure no current menu is set
36614:   mHFlip = mVFlip = PR_FALSE;
 3129: 
 3129:   nsIView* view = GetView();
 3129:   nsIViewManager* viewManager = view->GetViewManager();
 3129:   viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
 3129:   viewManager->ResizeView(view, nsRect(0, 0, 0, 0));
 3129: 
 3129:   FireDOMEvent(NS_LITERAL_STRING("DOMMenuInactive"), mContent);
 3129: 
 3129:   // XXX, bug 137033, In Windows, if mouse is outside the window when the menupopup closes, no
 3129:   // mouse_enter/mouse_exit event will be fired to clear current hover state, we should clear it manually.
 3129:   // This code may not the best solution, but we can leave it here until we find the better approach.
 3129:   nsIEventStateManager *esm = PresContext()->EventStateManager();
 3129: 
56168:   nsEventStates state = esm->GetContentState(mContent);
 3129: 
56168:   if (state.HasState(NS_EVENT_STATE_HOVER))
 3129:     esm->SetContentState(nsnull, NS_EVENT_STATE_HOVER);
 3129: 
49217:   nsMenuFrame* menuFrame = GetParentMenu();
49217:   if (menuFrame) {
49217:     menuFrame->PopupClosed(aDeselectMenu);
 3129:   }
 3129: }
 3129: 
    1: void
    1: nsMenuPopupFrame::InvalidateInternal(const nsRect& aDamageRect,
    1:                                      nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                      PRUint32 aFlags)
    1: {
19380:   InvalidateRoot(aDamageRect + nsPoint(aX, aY), aFlags);
    1: }
    1: 
    1: void
    1: nsMenuPopupFrame::GetLayoutFlags(PRUint32& aFlags)
    1: {
    1:   aFlags = NS_FRAME_NO_SIZE_VIEW | NS_FRAME_NO_MOVE_VIEW | NS_FRAME_NO_VISIBILITY;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////
    1: // GetRootViewForPopup
    1: //   Retrieves the view for the popup widget that contains the given frame. 
    1: //   If the given frame is not contained by a popup widget, return the
    1: //   root view of the root viewmanager.
 3129: nsIView*
 5334: nsMenuPopupFrame::GetRootViewForPopup(nsIFrame* aStartFrame)
    1: {
    1:   nsIView* view = aStartFrame->GetClosestView();
    1:   NS_ASSERTION(view, "frame must have a closest view!");
    1:   while (view) {
    1:     // Walk up the view hierarchy looking for a view whose widget has a 
    1:     // window type of eWindowType_popup - in other words a popup window
    1:     // widget. If we find one, this is the view we want. 
    1:     nsIWidget* widget = view->GetWidget();
    1:     if (widget) {
    1:       nsWindowType wtype;
    1:       widget->GetWindowType(wtype);
    1:       if (wtype == eWindowType_popup) {
 3129:         return view;
    1:       }
    1:     }
    1: 
    1:     nsIView* temp = view->GetParent();
    1:     if (!temp) {
    1:       // Otherwise, we've walked all the way up to the root view and not
    1:       // found a view for a popup window widget. Just return the root view.
 3129:       return view;
    1:     }
    1:     view = temp;
    1:   }
 3129: 
 3129:   return nsnull;
 2946: }
 2944: 
22944: nsPoint
58647: nsMenuPopupFrame::AdjustPositionForAnchorAlign(nsRect& anchorRect,
55434:                                                FlipStyle& aHFlip, FlipStyle& aVFlip)
    1: {
22944:   // flip the anchor and alignment for right-to-left
 3129:   PRInt8 popupAnchor(mPopupAnchor);
 3129:   PRInt8 popupAlign(mPopupAlignment);
60441:   if (IsDirectionRTL()) {
58647:     // no need to flip the centered anchor types
58647:     if (popupAnchor < POPUPALIGNMENT_LEFTCENTER) {
 3129:       popupAnchor = -popupAnchor;
58647:     }
 3129:     popupAlign = -popupAlign;
    1:   }
    1: 
22944:   // first, determine at which corner of the anchor the popup should appear
22944:   nsPoint pnt;
22944:   switch (popupAnchor) {
58647:     case POPUPALIGNMENT_LEFTCENTER:
58647:       pnt = nsPoint(anchorRect.x, anchorRect.y + anchorRect.height / 2);
58647:       anchorRect.y = pnt.y;
58647:       anchorRect.height = 0;
58647:       break;
58647:     case POPUPALIGNMENT_RIGHTCENTER:
58647:       pnt = nsPoint(anchorRect.XMost(), anchorRect.y + anchorRect.height / 2);
58647:       anchorRect.y = pnt.y;
58647:       anchorRect.height = 0;
58647:       break;
58647:     case POPUPALIGNMENT_TOPCENTER:
58647:       pnt = nsPoint(anchorRect.x + anchorRect.width / 2, anchorRect.y);
58647:       anchorRect.x = pnt.x;
58647:       anchorRect.width = 0;
58647:       break;
58647:     case POPUPALIGNMENT_BOTTOMCENTER:
58647:       pnt = nsPoint(anchorRect.x + anchorRect.width / 2, anchorRect.YMost());
58647:       anchorRect.x = pnt.x;
58647:       anchorRect.width = 0;
58647:       break;
22944:     case POPUPALIGNMENT_TOPRIGHT:
22944:       pnt = anchorRect.TopRight();
22944:       break;
22944:     case POPUPALIGNMENT_BOTTOMLEFT:
22944:       pnt = anchorRect.BottomLeft();
22944:       break;
22944:     case POPUPALIGNMENT_BOTTOMRIGHT:
22944:       pnt = anchorRect.BottomRight();
22944:       break;
39251:     case POPUPALIGNMENT_TOPLEFT:
39251:     default:
39251:       pnt = anchorRect.TopLeft();
39251:       break;
22944:   }
22944: 
22944:   // If the alignment is on the right edge of the popup, move the popup left
22944:   // by the width. Similarly, if the alignment is on the bottom edge of the
22944:   // popup, move the popup up by the height. In addition, account for the
22944:   // margins of the popup on the edge on which it is aligned.
25062:   nsMargin margin(0, 0, 0, 0);
    1:   GetStyleMargin()->GetMargin(margin);
22944:   switch (popupAlign) {
22944:     case POPUPALIGNMENT_TOPRIGHT:
22944:       pnt.MoveBy(-mRect.width - margin.right, margin.top);
22944:       break;
22944:     case POPUPALIGNMENT_BOTTOMLEFT:
22944:       pnt.MoveBy(margin.left, -mRect.height - margin.bottom);
22944:       break;
22944:     case POPUPALIGNMENT_BOTTOMRIGHT:
22944:       pnt.MoveBy(-mRect.width - margin.right, -mRect.height - margin.bottom);
22944:       break;
39251:     case POPUPALIGNMENT_TOPLEFT:
39251:     default:
39251:       pnt.MoveBy(margin.left, margin.top);
39251:       break;
    1:   }
    1: 
34703:   // Flipping horizontally is allowed as long as the popup is above or below
34703:   // the anchor. This will happen if both the anchor and alignment are top or
34703:   // both are bottom, but different values. Similarly, flipping vertically is
22944:   // allowed if the popup is to the left or right of the anchor. In this case,
22944:   // the values of the constants are such that both must be positive or both
22944:   // must be negative. A special case, used for overlap, allows flipping
22944:   // vertically as well.
55434:   // If we are flipping in both directions, we want to set a flip style both
55434:   // horizontally and vertically. However, we want to flip on the inside edge
55434:   // of the anchor. Consider the example of a typical dropdown menu.
55434:   // Vertically, we flip the popup on the outside edges of the anchor menu,
55434:   // however horizontally, we want to to use the inside edges so the popup
55434:   // still appears underneath the anchor menu instead of floating off the
55434:   // side of the menu.
58647:   if (popupAnchor >= POPUPALIGNMENT_LEFTCENTER) {
58647:     if (popupAnchor == POPUPALIGNMENT_LEFTCENTER ||
58647:         popupAnchor == POPUPALIGNMENT_RIGHTCENTER) {
58647:       aHFlip = FlipStyle_Outside;
58647:       aVFlip = FlipStyle_Inside;
58647:     }
58647:     else {
58647:       aHFlip = FlipStyle_Inside;
58647:       aVFlip = FlipStyle_Outside;
58647:     }
58647:   }
58647:   else {
55434:     FlipStyle anchorEdge = mFlipBoth ? FlipStyle_Inside : FlipStyle_None;
55434:     aHFlip = (popupAnchor == -popupAlign) ? FlipStyle_Outside : anchorEdge;
55434:     if (((popupAnchor > 0) == (popupAlign > 0)) ||
55434:         (popupAnchor == POPUPALIGNMENT_TOPLEFT && popupAlign == POPUPALIGNMENT_TOPLEFT))
55434:       aVFlip = FlipStyle_Outside;
55434:     else
55434:       aVFlip = anchorEdge;
58647:   }
22944: 
22944:   return pnt;
    1: }
    1: 
22944: nscoord
22944: nsMenuPopupFrame::FlipOrResize(nscoord& aScreenPoint, nscoord aSize, 
22944:                                nscoord aScreenBegin, nscoord aScreenEnd,
22944:                                nscoord aAnchorBegin, nscoord aAnchorEnd,
22944:                                nscoord aMarginBegin, nscoord aMarginEnd,
55434:                                nscoord aOffsetForContextMenu, FlipStyle aFlip,
36614:                                PRPackedBool* aFlipSide)
22944: {
22944:   // all of the coordinates used here are in app units relative to the screen
22944:   nscoord popupSize = aSize;
22944:   if (aScreenPoint < aScreenBegin) {
22944:     // at its current position, the popup would extend past the left or top
22944:     // edge of the screen, so it will have to be moved or resized.
22944:     if (aFlip) {
55434:       // for inside flips, we flip on the opposite side of the anchor
55434:       nscoord startpos = aFlip == FlipStyle_Outside ? aAnchorBegin : aAnchorEnd;
55434:       nscoord endpos = aFlip == FlipStyle_Outside ? aAnchorEnd : aAnchorBegin;
55434: 
22944:       // check whether there is more room to the left and right (or top and
22944:       // bottom) of the anchor and put the popup on the side with more room.
55434:       if (startpos - aScreenBegin >= aScreenEnd - endpos) {
22944:         aScreenPoint = aScreenBegin;
55434:         popupSize = startpos - aScreenPoint - aMarginEnd;
    1:       }
    1:       else {
22944:         // flip such that the popup is to the right or bottom of the anchor
22944:         // point instead. However, when flipping use the same margin size.
36614:         *aFlipSide = PR_TRUE;
55434:         aScreenPoint = endpos + aMarginEnd;
22944:         // check if the new position is still off the right or bottom edge of
22944:         // the screen. If so, resize the popup.
23379:         if (aScreenPoint + aSize > aScreenEnd) {
22944:           popupSize = aScreenEnd - aScreenPoint;
22944:         }
22944:       }
23379:     }
22944:     else {
22944:       aScreenPoint = aScreenBegin;
22944:     }
22944:   }
22944:   else if (aScreenPoint + aSize > aScreenEnd) {
22944:     // at its current position, the popup would extend past the right or
22944:     // bottom edge of the screen, so it will have to be moved or resized.
22944:     if (aFlip) {
55434:       // for inside flips, we flip on the opposite side of the anchor
55434:       nscoord startpos = aFlip == FlipStyle_Outside ? aAnchorBegin : aAnchorEnd;
55434:       nscoord endpos = aFlip == FlipStyle_Outside ? aAnchorEnd : aAnchorBegin;
55434: 
22944:       // check whether there is more room to the left and right (or top and
22944:       // bottom) of the anchor and put the popup on the side with more room.
55434:       if (aScreenEnd - endpos >= startpos - aScreenBegin) {
23379:         if (mIsContextMenu) {
23379:           aScreenPoint = aScreenEnd - aSize;
23379:         }
23379:         else {
22944:           popupSize = aScreenEnd - aScreenPoint;
22944:         }
23379:       }
22944:       else {
22944:         // flip such that the popup is to the left or top of the anchor point
22944:         // instead.
36614:         *aFlipSide = PR_TRUE;
55434:         aScreenPoint = startpos - aSize - aMarginBegin - aOffsetForContextMenu;
55434: 
22944:         // check if the new position is still off the left or top edge of the
22944:         // screen. If so, resize the popup.
22944:         if (aScreenPoint < aScreenBegin) {
22944:           aScreenPoint = aScreenBegin;
23379:           if (!mIsContextMenu) {
55434:             popupSize = startpos - aScreenPoint - aMarginBegin;
23379:           }
22944:         }
22944:       }
22944:     }
22944:     else {
22944:       aScreenPoint = aScreenEnd - aSize;
22944:     }
    1:   }
    1: 
34703:   return popupSize;
    1: }
    1: 
 3129: nsresult
37792: nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame, PRBool aIsMove)
 2946: {
36614:   if (!mShouldAutoPosition)
 3129:     return NS_OK;
 3129: 
 3129:   nsPresContext* presContext = PresContext();
 5334:   nsIFrame* rootFrame = presContext->PresShell()->FrameManager()->GetRootFrame();
18884:   NS_ASSERTION(rootFrame->GetView() && GetView() &&
18884:                rootFrame->GetView() == GetView()->GetParent(),
18884:                "rootFrame's view is not our view's parent???");
 3129: 
22944:   // if the frame is not specified, use the anchor node passed to OpenPopup. If
 3129:   // that wasn't specified either, use the root frame. Note that mAnchorContent
 3129:   // might be a different document so its presshell must be used.
 3129:   if (!aAnchorFrame) {
 3129:     if (mAnchorContent) {
36656:       aAnchorFrame = mAnchorContent->GetPrimaryFrame();
 3129:     }
 2946: 
 4794:     if (!aAnchorFrame) {
 5334:       aAnchorFrame = rootFrame;
 3129:       if (!aAnchorFrame)
 3129:         return NS_OK;
 2946:     }
 4794:   }
 3612: 
22944:   PRBool sizedToPopup = PR_FALSE;
 3612:   if (aAnchorFrame->GetContent()) {
 3129:     // the popup should be the same size as the anchor menu, for example, a menulist.
 3129:     sizedToPopup = nsMenuFrame::IsSizedToPopup(aAnchorFrame->GetContent(), PR_FALSE);
 2946:   }
 2946: 
22944:   // the dimensions of the anchor in its app units
23738:   nsRect parentRect = aAnchorFrame->GetScreenRectInAppUnits();
 8291: 
 8291:   // the anchor may be in a different document with a different scale,
 8291:   // so adjust the size so that it is in the app units of the popup instead
47903:   // of the anchor.
47903:   parentRect = parentRect.ConvertAppUnitsRoundOut(
47903:     aAnchorFrame->PresContext()->AppUnitsPerDevPixel(),
47903:     presContext->AppUnitsPerDevPixel());
    1: 
 9482:   // Set the popup's size to the preferred size. Below, this size will be
 9482:   // adjusted to fit on the screen or within the content area. If the anchor
 9482:   // is sized to the popup, use the anchor's width instead of the preferred
 9482:   // width. The preferred size should already be set by the parent frame.
 9482:   NS_ASSERTION(mPrefSize.width >= 0 || mPrefSize.height >= 0,
 9482:                "preferred size of popup not set");
23738:   mRect.width = sizedToPopup ? parentRect.width : mPrefSize.width;
 9482:   mRect.height = mPrefSize.height;
    1: 
22944:   // the screen position in app units where the popup should appear
22944:   nsPoint screenPoint;
22944: 
22944:   // For anchored popups, the anchor rectangle. For non-anchored popups, the
22944:   // size will be 0.
23738:   nsRect anchorRect = parentRect;
22944: 
22944:   // indicators of whether the popup should be flipped or resized.
55434:   FlipStyle hFlip = FlipStyle_None, vFlip = FlipStyle_None;
22944: 
25062:   nsMargin margin(0, 0, 0, 0);
22944:   GetStyleMargin()->GetMargin(margin);
 5334: 
22944:   // the screen rectangle of the root frame, in dev pixels.
15364:   nsRect rootScreenRect = rootFrame->GetScreenRectInAppUnits();
 5334: 
22944:   nsIDeviceContext* devContext = presContext->DeviceContext();
14630:   nscoord offsetForContextMenu = 0;
22944:   // if mScreenXPos and mScreenYPos are -1, then we are anchored. If they
22944:   // have other values, then the popup appears unanchored at that screen
22944:   // coordinate.
 3129:   if (mScreenXPos == -1 && mScreenYPos == -1) {
22944:     // if we are anchored, there are certain things we don't want to do when
22944:     // repositioning the popup to fit on the screen, such as end up positioned
22944:     // over the anchor, for instance a popup appearing over the menu label.
22944:     // When doing this reposition, we want to move the popup to the side with
22944:     // the most room. The combination of anchor and alignment dictate if we 
22944:     // readjust above/below or to the left/right.
 3129:     if (mAnchorContent) {
22944:       // move the popup according to the anchor and alignment. This will also
22944:       // tell us which axis the popup is flush against in case we have to move
22944:       // it around later. The AdjustPositionForAnchorAlign method accounts for
22944:       // the popup's margin.
22944:       screenPoint = AdjustPositionForAnchorAlign(anchorRect, hFlip, vFlip);
 3129:     }
 3129:     else {
 5334:       // with no anchor, the popup is positioned relative to the root frame
22944:       anchorRect = rootScreenRect;
22944:       screenPoint = anchorRect.TopLeft() + nsPoint(margin.left, margin.top);
 3129:     }
 3129: 
22944:     // mXPos and mYPos specify an additonal offset passed to OpenPopup that
22944:     // should be added to the position
60441:     if (IsDirectionRTL())
25586:       screenPoint.x -= presContext->CSSPixelsToAppUnits(mXPos);
25586:     else
22944:       screenPoint.x += presContext->CSSPixelsToAppUnits(mXPos);
22944:     screenPoint.y += presContext->CSSPixelsToAppUnits(mYPos);
48254: 
48254:     // If this is a noautohide popup, set the screen coordinates of the popup.
48254:     // This way, the popup stays at the location where it was opened even when
48254:     // the window is moved. Popups at the parent level follow the parent
48254:     // window as it is moved and remained anchored, so we want to maintain the
48254:     // anchoring instead.
48254:     if (IsNoAutoHide() && PopupLevel(PR_TRUE) != ePopupLevelParent) {
48254:       // Account for the margin that will end up being added to the screen coordinate
48254:       // the next time SetPopupPosition is called.
48254:       mScreenXPos = presContext->AppUnitsToIntCSSPixels(screenPoint.x - margin.left);
48254:       mScreenYPos = presContext->AppUnitsToIntCSSPixels(screenPoint.y - margin.top);
48254:     }
 3129:   }
 3129:   else {
 8291:     // the popup is positioned at a screen coordinate.
 8291:     // first convert the screen position in mScreenXPos and mScreenYPos from
 8291:     // CSS pixels into device pixels, ignoring any scaling as mScreenXPos and
 8291:     // mScreenYPos are unscaled screen coordinates.
 8291:     PRInt32 factor = devContext->UnscaledAppUnitsPerDevPixel();
 8291: 
22944:     // context menus should be offset by two pixels so that they don't appear
22944:     // directly where the cursor is. Otherwise, it is too easy to have the
22944:     // context menu close up again.
14630:     if (mAdjustOffsetForContextMenu) {
14630:       PRInt32 offsetForContextMenuDev =
14630:         nsPresContext::CSSPixelsToAppUnits(2) / factor;
14630:       offsetForContextMenu = presContext->DevPixelsToAppUnits(offsetForContextMenuDev);
14630:     }
14630: 
22944:     // next, convert into app units accounting for the scaling
22944:     screenPoint.x = presContext->DevPixelsToAppUnits(
22944:                       nsPresContext::CSSPixelsToAppUnits(mScreenXPos) / factor);
22944:     screenPoint.y = presContext->DevPixelsToAppUnits(
22944:                       nsPresContext::CSSPixelsToAppUnits(mScreenYPos) / factor);
23379:     anchorRect = nsRect(screenPoint, nsSize(0, 0));
 3129: 
22944:     // add the margins on the popup
22944:     screenPoint.MoveBy(margin.left + offsetForContextMenu,
22944:                        margin.top + offsetForContextMenu);
22944: 
22944:     // screen positioned popups can be flipped vertically but never horizontally
55434:     vFlip = FlipStyle_Outside;
    1:   }
    1: 
37792:   // if a panel is being moved, don't flip it. But always do this for content
37792:   // shells, so that the popup doesn't extend outside the containing frame.
37792:   if (aIsMove && mPopupType == ePopupTypePanel && !mInContentShell) {
55434:     hFlip = vFlip = FlipStyle_None;
37792:   }
37792: 
48714:   nsRect screenRect = GetConstraintRect(anchorRect, rootScreenRect);
22944: 
22944:   // ensure that anchorRect is on screen
22944:   if (!anchorRect.IntersectRect(anchorRect, screenRect)) {
37075:     anchorRect.width = anchorRect.height = 0;
22944:     // if the anchor isn't within the screen, move it to the edge of the screen.
22944:     if (anchorRect.x < screenRect.x)
22944:       anchorRect.x = screenRect.x;
22944:     if (anchorRect.XMost() > screenRect.XMost())
22944:       anchorRect.x = screenRect.XMost();
22944:     if (anchorRect.y < screenRect.y)
22944:       anchorRect.y = screenRect.y;
22944:     if (anchorRect.YMost() > screenRect.YMost())
22944:       anchorRect.y = screenRect.YMost();
    1:   }
    1: 
22944:   // shrink the the popup down if it is larger than the screen size
22944:   if (mRect.width > screenRect.width)
22944:     mRect.width = screenRect.width;
22944:   if (mRect.height > screenRect.height)
22944:     mRect.height = screenRect.height;
    1: 
22944:   // at this point the anchor (anchorRect) is within the available screen
22944:   // area (screenRect) and the popup is known to be no larger than the screen.
22944:   // Next, check if there is enough space to show the popup at full size when
22944:   // positioned at screenPoint. If not, flip the popups to the opposite side
22944:   // of their anchor point, or resize them as necessary.
22944:   mRect.width = FlipOrResize(screenPoint.x, mRect.width, screenRect.x,
22944:                              screenRect.XMost(), anchorRect.x, anchorRect.XMost(),
36614:                              margin.left, margin.right, offsetForContextMenu, hFlip, &mHFlip);
36614: 
22944:   mRect.height = FlipOrResize(screenPoint.y, mRect.height, screenRect.y,
22944:                               screenRect.YMost(), anchorRect.y, anchorRect.YMost(),
36614:                               margin.top, margin.bottom, offsetForContextMenu, vFlip, &mVFlip);
  677: 
22944:   NS_ASSERTION(screenPoint.x >= screenRect.x && screenPoint.y >= screenRect.y &&
22944:                screenPoint.x + mRect.width <= screenRect.XMost() &&
22944:                screenPoint.y + mRect.height <= screenRect.YMost(),
22944:                "Popup is offscreen");
    1: 
22944:   // determine the x and y position of the view by subtracting the desired
22944:   // screen position from the screen position of the root frame.
22944:   nsPoint viewPoint = screenPoint - rootScreenRect.TopLeft();
62895: 
62895:   // snap the view's position to device pixels, see bug 622507
62895:   viewPoint.x = presContext->RoundAppUnitsToNearestDevPixels(viewPoint.x);
62895:   viewPoint.y = presContext->RoundAppUnitsToNearestDevPixels(viewPoint.y);
62895: 
48256:   nsIView* view = GetView();
48256:   NS_ASSERTION(view, "popup with no view");
26050:   presContext->GetPresShell()->GetViewManager()->
48256:     MoveViewTo(view, viewPoint.x, viewPoint.y);
48256: 
48256:   // Offset the position by the width and height of the borders and titlebar.
48256:   // Even though GetClientOffset should return (0, 0) when there is no
48256:   // titlebar or borders, we skip these calculations anyway for non-panels
48256:   // to save time since they will never have a titlebar.
48256:   nsIWidget* widget = view->GetWidget();
48256:   if (mPopupType == ePopupTypePanel && widget) {
48256:     nsIntPoint offset = widget->GetClientOffset();
48256:     viewPoint.x += presContext->DevPixelsToAppUnits(offset.x);
48256:     viewPoint.y += presContext->DevPixelsToAppUnits(offset.y);
48256:   }
    1: 
    1:   // Now that we've positioned the view, sync up the frame's origin.
22944:   nsBoxFrame::SetPosition(viewPoint - GetParent()->GetOffsetTo(rootFrame));
    1: 
    1:   if (sizedToPopup) {
  238:     nsBoxLayoutState state(PresContext());
22944:     // XXXndeakin can parentSize.width still extend outside?
23738:     SetBounds(state, nsRect(mRect.x, mRect.y, parentRect.width, mRect.height));
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 3129: /* virtual */ nsMenuFrame*
    1: nsMenuPopupFrame::GetCurrentMenuItem()
    1: {
    1:   return mCurrentMenu;
    1: }
    1: 
36614: nsRect
48714: nsMenuPopupFrame::GetConstraintRect(const nsRect& aAnchorRect,
48714:                                     const nsRect& aRootScreenRect)
36614: {
36614:   nsIntRect screenRectPixels;
36614:   nsPresContext* presContext = PresContext();
36614: 
36614:   // determine the available screen space. It will be reduced by the OS chrome
36614:   // such as menubars. It addition, for content shells, it will be the area of
36614:   // the content rather than the screen.
36614:   nsCOMPtr<nsIScreen> screen;
36614:   nsCOMPtr<nsIScreenManager> sm(do_GetService("@mozilla.org/gfx/screenmanager;1"));
36614:   if (sm) {
36614:     // for content shells, get the screen where the root frame is located.
36614:     // This is because we need to constrain the content to this content area,
36614:     // so we should use the same screen. Otherwise, use the screen where the
36614:     // anchor is located.
48714:     nsRect rect = mInContentShell ? aRootScreenRect : aAnchorRect;
48714:     PRInt32 width = rect.width > 0 ? presContext->AppUnitsToDevPixels(rect.width) : 1;
48714:     PRInt32 height = rect.height > 0 ? presContext->AppUnitsToDevPixels(rect.height) : 1;
48714:     sm->ScreenForRect(presContext->AppUnitsToDevPixels(rect.x),
48714:                       presContext->AppUnitsToDevPixels(rect.y),
48714:                       width, height, getter_AddRefs(screen));
36614:     if (screen) {
36614:       // get the total screen area if the popup is allowed to overlap it.
36614:       if (mMenuCanOverlapOSBar && !mInContentShell)
36614:         screen->GetRect(&screenRectPixels.x, &screenRectPixels.y,
36614:                         &screenRectPixels.width, &screenRectPixels.height);
36614:       else
36614:         screen->GetAvailRect(&screenRectPixels.x, &screenRectPixels.y,
36614:                              &screenRectPixels.width, &screenRectPixels.height);
36614:     }
36614:   }
36614: 
36614:   // keep a 3 pixel margin to the right and bottom of the screen for the WinXP dropshadow
36614:   screenRectPixels.SizeBy(-3, -3);
36614: 
36614:   nsRect screenRect = screenRectPixels.ToAppUnits(presContext->AppUnitsPerDevPixel());
36614:   if (mInContentShell) {
36614:     // for content shells, clip to the client area rather than the screen area
36614:     screenRect.IntersectRect(screenRect, aRootScreenRect);
36614:   }
36614: 
36614:   return screenRect;
36614: }
36614: 
36614: void nsMenuPopupFrame::CanAdjustEdges(PRInt8 aHorizontalSide, PRInt8 aVerticalSide, nsIntPoint& aChange)
36614: {
36614:   PRInt8 popupAlign(mPopupAlignment);
60441:   if (IsDirectionRTL()) {
36614:     popupAlign = -popupAlign;
36614:   }
36614: 
36614:   if (aHorizontalSide == (mHFlip ? NS_SIDE_RIGHT : NS_SIDE_LEFT)) {
36614:     if (popupAlign == POPUPALIGNMENT_TOPLEFT || popupAlign == POPUPALIGNMENT_BOTTOMLEFT) {
36614:       aChange.x = 0;
36614:     }
36614:   }
36614:   else if (aHorizontalSide == (mHFlip ? NS_SIDE_LEFT : NS_SIDE_RIGHT)) {
36614:     if (popupAlign == POPUPALIGNMENT_TOPRIGHT || popupAlign == POPUPALIGNMENT_BOTTOMRIGHT) {
36614:       aChange.x = 0;
36614:     }
36614:   }
36614: 
36614:   if (aVerticalSide == (mVFlip ? NS_SIDE_BOTTOM : NS_SIDE_TOP)) {
36614:     if (popupAlign == POPUPALIGNMENT_TOPLEFT || popupAlign == POPUPALIGNMENT_TOPRIGHT) {
36614:       aChange.y = 0;
36614:     }
36614:   }
36614:   else if (aVerticalSide == (mVFlip ? NS_SIDE_TOP : NS_SIDE_BOTTOM)) {
36614:     if (popupAlign == POPUPALIGNMENT_BOTTOMLEFT || popupAlign == POPUPALIGNMENT_BOTTOMRIGHT) {
36614:       aChange.y = 0;
36614:     }
36614:   }
36614: }
36614: 
 3129: PRBool nsMenuPopupFrame::ConsumeOutsideClicks()
    1: {
    1:   // If the popup has explicitly set a consume mode, honor that.
 3129:   if (mConsumeRollupEvent != nsIPopupBoxObject::ROLLUP_DEFAULT)
 3129:     return (mConsumeRollupEvent == nsIPopupBoxObject::ROLLUP_CONSUME);
    1: 
    1:   nsCOMPtr<nsIContent> parentContent = mContent->GetParent();
    1:   if (parentContent) {
 3129:     nsINodeInfo *ni = parentContent->NodeInfo();
 3129:     if (ni->Equals(nsGkAtoms::menulist, kNameSpaceID_XUL))
 3129:       return PR_TRUE;  // Consume outside clicks for combo boxes on all platforms
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1:     // Don't consume outside clicks for menus in Windows
 3129:     if (ni->Equals(nsGkAtoms::menu, kNameSpaceID_XUL) ||
 3129:        (ni->Equals(nsGkAtoms::popupset, kNameSpaceID_XUL)))
 3129:       return PR_FALSE;
    1: #endif
 3129:     if (ni->Equals(nsGkAtoms::textbox, kNameSpaceID_XUL)) {
    1:       // Don't consume outside clicks for autocomplete widget
    1:       if (parentContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
    1:                                      nsGkAtoms::autocomplete, eCaseMatters))
 3129:         return PR_FALSE;
    1:     }
    1:   }
    1: 
 3129:   return PR_TRUE;
    1: }
    1: 
37056: // XXXroc this is megalame. Fossicking around for a frame of the right
37056: // type is a recipe for disaster in the long term.
37056: nsIScrollableFrame* nsMenuPopupFrame::GetScrollFrame(nsIFrame* aStart)
37056: {
37056:   if (!aStart)
37056:     return nsnull;  
37056: 
37056:   // try start frame and siblings
37056:   nsIFrame* currFrame = aStart;
37056:   do {
37056:     nsIScrollableFrame* sf = do_QueryFrame(currFrame);
37056:     if (sf)
37056:       return sf;
37056:     currFrame = currFrame->GetNextSibling();
37056:   } while (currFrame);
37056: 
37056:   // try children
37056:   currFrame = aStart;
37056:   do {
37056:     nsIFrame* childFrame = currFrame->GetFirstChild(nsnull);
37056:     nsIScrollableFrame* sf = GetScrollFrame(childFrame);
37056:     if (sf)
37056:       return sf;
37056:     currFrame = currFrame->GetNextSibling();
37056:   } while (currFrame);
37056: 
37056:   return nsnull;
37056: }
37056: 
 3129: void nsMenuPopupFrame::EnsureMenuItemIsVisible(nsMenuFrame* aMenuItem)
    1: {
 3129:   if (aMenuItem) {
37079:     aMenuItem->PresContext()->PresShell()->
37079:       ScrollFrameRectIntoView(aMenuItem,
37079:                               nsRect(nsPoint(0,0), aMenuItem->GetRect().Size()),
37079:                               NS_PRESSHELL_SCROLL_ANYWHERE,
37079:                               NS_PRESSHELL_SCROLL_ANYWHERE,
38842:                               nsIPresShell::SCROLL_OVERFLOW_HIDDEN |
38842:                               nsIPresShell::SCROLL_FIRST_ANCESTOR_ONLY);
    1:   }
    1: }
    1: 
 3129: NS_IMETHODIMP nsMenuPopupFrame::SetCurrentMenuItem(nsMenuFrame* aMenuItem)
    1: {
 3129:   if (mCurrentMenu == aMenuItem)
 3129:     return NS_OK;
 3129: 
 3129:   if (mCurrentMenu) {
 3129:     mCurrentMenu->SelectMenu(PR_FALSE);
 3129:   }
 3129: 
 3129:   if (aMenuItem) {
 3129:     EnsureMenuItemIsVisible(aMenuItem);
 3129:     aMenuItem->SelectMenu(PR_TRUE);
 3129:   }
 3129: 
 3129:   mCurrentMenu = aMenuItem;
 3129: 
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: void
 3129: nsMenuPopupFrame::CurrentMenuIsBeingDestroyed()
 3129: {
 3129:   mCurrentMenu = nsnull;
 3129: }
 3129: 
 3129: NS_IMETHODIMP
 3129: nsMenuPopupFrame::ChangeMenuItem(nsMenuFrame* aMenuItem,
 3129:                                  PRBool aSelectFirstItem)
 3129: {
 3129:   if (mCurrentMenu == aMenuItem)
 3129:     return NS_OK;
 3129: 
 2946:   // When a context menu is open, the current menu is locked, and no change
 2946:   // to the menu is allowed.
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   if (!mIsContextMenu && pm && pm->HasContextMenu(this))
 2944:     return NS_OK;
 2944: 
    1:   // Unset the current child.
    1:   if (mCurrentMenu) {
    1:     mCurrentMenu->SelectMenu(PR_FALSE);
 3129:     nsMenuPopupFrame* popup = mCurrentMenu->GetPopup();
 3129:     if (popup) {
 3129:       if (mCurrentMenu->IsOpen()) {
 3129:         if (pm)
 3129:           pm->HidePopupAfterDelay(popup);
 3129:       }
    1:     }
    1:   }
    1: 
    1:   // Set the new child.
    1:   if (aMenuItem) {
    1:     EnsureMenuItemIsVisible(aMenuItem);
    1:     aMenuItem->SelectMenu(PR_TRUE);
    1:   }
    1: 
    1:   mCurrentMenu = aMenuItem;
    1: 
    1:   return NS_OK;
    1: }
    1: 
 3129: nsMenuFrame*
    1: nsMenuPopupFrame::Enter()
    1: {
    1:   mIncrementalString.Truncate();
    1: 
    1:   // Give it to the child.
    1:   if (mCurrentMenu)
 3129:     return mCurrentMenu->Enter();
    1: 
 3129:   return nsnull;
    1: }
    1: 
 3129: nsMenuFrame*
    1: nsMenuPopupFrame::FindMenuWithShortcut(nsIDOMKeyEvent* aKeyEvent, PRBool& doAction)
    1: {
    1:   PRUint32 charCode, keyCode;
    1:   aKeyEvent->GetCharCode(&charCode);
    1:   aKeyEvent->GetKeyCode(&keyCode);
    1: 
    1:   doAction = PR_FALSE;
    1: 
    1:   // Enumerate over our list of frames.
    1:   nsIFrame* immediateParent = nsnull;
 3129:   PresContext()->PresShell()->
 3129:     FrameConstructor()->GetInsertionPoint(this, nsnull, &immediateParent);
    1:   if (!immediateParent)
    1:     immediateParent = this;
    1: 
    1:   PRUint32 matchCount = 0, matchShortcutCount = 0;
    1:   PRBool foundActive = PR_FALSE;
    1:   PRBool isShortcut;
 3129:   nsMenuFrame* frameBefore = nsnull;
 3129:   nsMenuFrame* frameAfter = nsnull;
 3129:   nsMenuFrame* frameShortcut = nsnull;
    1: 
    1:   nsIContent* parentContent = mContent->GetParent();
    1: 
 3129:   PRBool isMenu = parentContent &&
 3129:                   !parentContent->NodeInfo()->Equals(nsGkAtoms::menulist, kNameSpaceID_XUL);
    1: 
    1:   static DOMTimeStamp lastKeyTime = 0;
    1:   DOMTimeStamp keyTime;
    1:   aKeyEvent->GetTimeStamp(&keyTime);
    1: 
    1:   if (charCode == 0) {
    1:     if (keyCode == NS_VK_BACK) {
    1:       if (!isMenu && !mIncrementalString.IsEmpty()) {
    1:         mIncrementalString.SetLength(mIncrementalString.Length() - 1);
    1:         return nsnull;
    1:       }
    1:       else {
34005: #ifdef XP_WIN
34005:         nsCOMPtr<nsISound> soundInterface = do_CreateInstance("@mozilla.org/sound;1");
34005:         if (soundInterface)
34005:           soundInterface->Beep();
34005: #endif  // #ifdef XP_WIN
    1:       }
    1:     }
    1:     return nsnull;
    1:   }
    1:   else {
 3233:     PRUnichar uniChar = ToLowerCase(static_cast<PRUnichar>(charCode));
    1:     if (isMenu || // Menu supports only first-letter navigation
    1:         keyTime - lastKeyTime > INC_TYP_INTERVAL) // Interval too long, treat as new typing
    1:       mIncrementalString = uniChar;
    1:     else {
    1:       mIncrementalString.Append(uniChar);
    1:     }
    1:   }
    1: 
    1:   // See bug 188199 & 192346, if all letters in incremental string are same, just try to match the first one
    1:   nsAutoString incrementalString(mIncrementalString);
    1:   PRUint32 charIndex = 1, stringLength = incrementalString.Length();
    1:   while (charIndex < stringLength && incrementalString[charIndex] == incrementalString[charIndex - 1]) {
    1:     charIndex++;
    1:   }
    1:   if (charIndex == stringLength) {
    1:     incrementalString.Truncate(1);
    1:     stringLength = 1;
    1:   }
    1: 
    1:   lastKeyTime = keyTime;
    1: 
    1:   nsIFrame* currFrame;
    1:   // NOTE: If you crashed here due to a bogus |immediateParent| it is 
    1:   //       possible that the menu whose shortcut is being looked up has 
    1:   //       been destroyed already.  One strategy would be to 
    1:   //       setTimeout(<func>,0) as detailed in:
    1:   //       <http://bugzilla.mozilla.org/show_bug.cgi?id=126675#c32>
    1:   currFrame = immediateParent->GetFirstChild(nsnull);
    1: 
 3129:   PRInt32 menuAccessKey = -1;
 3129:   nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
 3129: 
    1:   // We start searching from first child. This process is divided into two parts
    1:   //   -- before current and after current -- by the current item
    1:   while (currFrame) {
    1:     nsIContent* current = currFrame->GetContent();
    1:     
    1:     // See if it's a menu item.
 3129:     if (nsXULPopupManager::IsValidMenuItem(PresContext(), current, PR_TRUE)) {
    1:       nsAutoString textKey;
 3129:       if (menuAccessKey >= 0) {
    1:         // Get the shortcut attribute.
    1:         current->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, textKey);
 3129:       }
    1:       if (textKey.IsEmpty()) { // No shortcut, try first letter
    1:         isShortcut = PR_FALSE;
    1:         current->GetAttr(kNameSpaceID_None, nsGkAtoms::label, textKey);
    1:         if (textKey.IsEmpty()) // No label, try another attribute (value)
    1:           current->GetAttr(kNameSpaceID_None, nsGkAtoms::value, textKey);
    1:       }
    1:       else
    1:         isShortcut = PR_TRUE;
    1: 
    1:       if (StringBeginsWith(textKey, incrementalString,
    1:                            nsCaseInsensitiveStringComparator())) {
    1:         // mIncrementalString is a prefix of textKey
 3129:         if (currFrame->GetType() == nsGkAtoms::menuFrame) {
    1:           // There is one match
    1:           matchCount++;
    1:           if (isShortcut) {
    1:             // There is one shortcut-key match
    1:             matchShortcutCount++;
    1:             // Record the matched item. If there is only one matched shortcut item, do it
 3233:             frameShortcut = static_cast<nsMenuFrame *>(currFrame);
    1:           }
    1:           if (!foundActive) {
    1:             // It's a first candidate item located before/on the current item
    1:             if (!frameBefore)
 3233:               frameBefore = static_cast<nsMenuFrame *>(currFrame);
    1:           }
    1:           else {
    1:             // It's a first candidate item located after the current item
    1:             if (!frameAfter)
 3233:               frameAfter = static_cast<nsMenuFrame *>(currFrame);
    1:           }
    1:         }
    1:         else
    1:           return nsnull;
    1:       }
    1: 
    1:       // Get the active status
    1:       if (current->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menuactive,
    1:                                nsGkAtoms::_true, eCaseMatters)) {
    1:         foundActive = PR_TRUE;
    1:         if (stringLength > 1) {
    1:           // If there is more than one char typed, the current item has highest priority,
    1:           //   otherwise the item next to current has highest priority
 3129:           if (currFrame == frameBefore)
    1:             return frameBefore;
    1:         }
    1:       }
    1:     }
    1:     currFrame = currFrame->GetNextSibling();
    1:   }
    1: 
    1:   doAction = (isMenu && (matchCount == 1 || matchShortcutCount == 1));
    1: 
    1:   if (matchShortcutCount == 1) // We have one matched shortcut item
    1:     return frameShortcut;
    1:   if (frameAfter) // If we have matched item after the current, use it
    1:     return frameAfter;
    1:   else if (frameBefore) // If we haven't, use the item before the current
    1:     return frameBefore;
    1: 
    1:   // If we don't match anything, rollback the last typing
    1:   mIncrementalString.SetLength(mIncrementalString.Length() - 1);
    1: 
    1:   // didn't find a matching menu item
34005: #ifdef XP_WIN
34005:   // behavior on Windows - this item is in a menu popup off of the
34005:   // menu bar, so beep and do nothing else
    1:   if (isMenu) {
34005:     nsCOMPtr<nsISound> soundInterface = do_CreateInstance("@mozilla.org/sound;1");
34005:     if (soundInterface)
34005:       soundInterface->Beep();
    1:   }
34005: #endif  // #ifdef XP_WIN
    1: 
    1:   return nsnull;
    1: }
    1: 
41073: void
41073: nsMenuPopupFrame::LockMenuUntilClosed(PRBool aLock)
41073: {
41073:   mIsMenuLocked = aLock;
41073: 
41073:   // Lock / unlock the parent, too.
41073:   nsIFrame* parent = GetParent();
41073:   if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
41073:     nsMenuParent* parentParent = static_cast<nsMenuFrame*>(parent)->GetMenuParent();
41073:     if (parentParent) {
41073:       parentParent->LockMenuUntilClosed(aLock);
41073:     }
41073:   }
41073: }
41073: 
    1: NS_IMETHODIMP
    1: nsMenuPopupFrame::GetWidget(nsIWidget **aWidget)
    1: {
 5334:   nsIView * view = GetRootViewForPopup(this);
    1:   if (!view)
    1:     return NS_OK;
    1: 
    1:   *aWidget = view->GetWidget();
    1:   NS_IF_ADDREF(*aWidget);
    1:   return NS_OK;
    1: }
    1: 
 3129: void
    1: nsMenuPopupFrame::AttachedDismissalListener()
    1: {
    1:   mConsumeRollupEvent = nsIPopupBoxObject::ROLLUP_DEFAULT;
    1: }
    1: 
    1: // helpers /////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP 
    1: nsMenuPopupFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                                    nsIAtom* aAttribute,
    1:                                    PRInt32 aModType)
    1: 
    1: {
    1:   nsresult rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute,
    1:                                              aModType);
    1:   
    1:   if (aAttribute == nsGkAtoms::left || aAttribute == nsGkAtoms::top)
    1:     MoveToAttributePosition();
    1: 
48260:   if (aAttribute == nsGkAtoms::label) {
48260:     // set the label for the titlebar
48260:     nsIView* view = GetView();
48260:     if (view) {
48260:       nsIWidget* widget = view->GetWidget();
48260:       if (widget) {
48260:         nsAutoString title;
48260:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, title);
48260:         if (!title.IsEmpty()) {
48260:           widget->SetTitle(title);
48260:         }
48260:       }
48260:     }
48260:   }
48260: 
 3129:   // accessibility needs this to ensure the frames get constructed when the
 3129:   // menugenerated attribute is set, see bug 279703 comment 42 for discussion
 3129:   if (aAttribute == nsGkAtoms::menugenerated &&
 3129:       mFrames.IsEmpty() && !mGeneratedChildren) {
22941:     EnsureWidget();
52061: 
52061:     // indicate that the children have been generated and then generate them
52061:     mGeneratedChildren = PR_TRUE;
52061:     PresContext()->PresShell()->FrameConstructor()->GenerateChildFrames(this);
 3129:   }
 3129: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsMenuPopupFrame::MoveToAttributePosition()
    1: {
    1:   // Move the widget around when the user sets the |left| and |top| attributes. 
    1:   // Note that this is not the best way to move the widget, as it results in lots
    1:   // of FE notifications and is likely to be slow as molasses. Use |moveTo| on
    1:   // nsIPopupBoxObject if possible. 
    1:   nsAutoString left, top;
    1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::left, left);
    1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::top, top);
 3129:   PRInt32 err1, err2;
25062:   PRInt32 xpos = left.ToInteger(&err1);
25062:   PRInt32 ypos = top.ToInteger(&err2);
    1: 
 3129:   if (NS_SUCCEEDED(err1) && NS_SUCCEEDED(err2))
25062:     MoveTo(xpos, ypos, PR_FALSE);
    1: }
    1: 
    1: void
36647: nsMenuPopupFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
43886:   nsIFrame* parent = GetParent();
43886:   if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
43886:     // clear the open attribute on the parent menu
43886:     nsContentUtils::AddScriptRunner(
43886:       new nsUnsetAttrRunnable(parent->GetContent(), nsGkAtoms::open));
43886:   }
43886: 
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   if (pm)
 3129:     pm->PopupDestroyed(this);
    1: 
23206:   nsIRootBox* rootBox =
23206:     nsIRootBox::GetRootBox(PresContext()->GetPresShell());
23206:   if (rootBox && rootBox->GetDefaultTooltip() == mContent) {
23206:     rootBox->SetDefaultTooltip(nsnull);
23206:   }
23206: 
36647:   nsBoxFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: 
    1: void
25062: nsMenuPopupFrame::MoveTo(PRInt32 aLeft, PRInt32 aTop, PRBool aUpdateAttrs)
    1: {
48253:   if (mScreenXPos == aLeft && mScreenYPos == aTop)
48253:     return;
48253: 
25062:   // reposition the popup at the specified coordinates. Don't clear the anchor
25062:   // and position, because the popup can be reset to its anchor position by
48254:   // using (-1, -1) as coordinates. Subtract off the margin as it will be
48254:   // added to the position when SetPopupPosition is called.
48254:   nsMargin margin(0, 0, 0, 0);
48254:   GetStyleMargin()->GetMargin(margin);
48254:   nsPresContext* presContext = PresContext();
48254:   mScreenXPos = aLeft - presContext->AppUnitsToIntCSSPixels(margin.left);
48254:   mScreenYPos = aTop - presContext->AppUnitsToIntCSSPixels(margin.top);
    1: 
37792:   SetPopupPosition(nsnull, PR_TRUE);
    1: 
25062:   nsCOMPtr<nsIContent> popup = mContent;
25062:   if (aUpdateAttrs && (popup->HasAttr(kNameSpaceID_None, nsGkAtoms::left) ||
25062:                        popup->HasAttr(kNameSpaceID_None, nsGkAtoms::top)))
25062:   {
25062:     nsAutoString left, top;
25062:     left.AppendInt(aLeft);
25062:     top.AppendInt(aTop);
25062:     popup->SetAttr(kNameSpaceID_None, nsGkAtoms::left, left, PR_FALSE);
25062:     popup->SetAttr(kNameSpaceID_None, nsGkAtoms::top, top, PR_FALSE);
25062:   }
    1: }
    1: 
 8408: PRBool
 8408: nsMenuPopupFrame::GetAutoPosition()
    1: {
 8408:   return mShouldAutoPosition;
    1: }
    1: 
    1: void
    1: nsMenuPopupFrame::SetAutoPosition(PRBool aShouldAutoPosition)
    1: {
    1:   mShouldAutoPosition = aShouldAutoPosition;
    1: }
    1: 
    1: void
    1: nsMenuPopupFrame::SetConsumeRollupEvent(PRUint32 aConsumeMode)
    1: {
    1:   mConsumeRollupEvent = aConsumeMode;
    1: }
