    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* nsJARInputStream.cpp
    1:  * 
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Netscape Communicator source code. 
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mitch Stoltz <mstoltz@netscape.com>
31399:  *   Taras Glek <tglek@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsJARInputStream.h"
    1: #include "zipstruct.h"         // defines ZIP compression codes
    1: #include "nsZipArchive.h"
    1: 
    1: #include "nsNetUtil.h"
    1: #include "nsEscape.h"
    1: #include "nsIFile.h"
31399: #include "nsDebug.h"
    1: 
    1: /*---------------------------------------------
    1:  *  nsISupports implementation
    1:  *--------------------------------------------*/
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsJARInputStream, nsIInputStream)
    1: 
    1: /*----------------------------------------------------------
    1:  * nsJARInputStream implementation
    1:  *--------------------------------------------------------*/
    1: 
    1: nsresult
33443: nsJARInputStream::InitFile(nsJAR *aJar, nsZipItem *item)
    1: {
33443:     nsresult rv = NS_OK;
33443:     NS_ABORT_IF_FALSE(aJar, "Argument may not be null");
31399:     NS_ABORT_IF_FALSE(item, "Argument may not be null");
    1: 
    1:     // Mark it as closed, in case something fails in initialisation
33443:     mMode = MODE_CLOSED;
    1:     //-- prepare for the compression type
33990:     switch (item->Compression()) {
    1:        case STORED: 
33443:            mMode = MODE_COPY;
    1:            break;
    1: 
    1:        case DEFLATED:
33443:            rv = gZlibInit(&mZs);
33443:            NS_ENSURE_SUCCESS(rv, rv);
32208:     
33443:            mMode = MODE_INFLATE;
33990:            mInCrc = item->CRC32();
33443:            mOutCrc = crc32(0L, Z_NULL, 0);
    1:            break;
    1: 
    1:        default:
    1:            return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:    
33443:     // Must keep handle to filepointer and mmap structure as long as we need access to the mmapped data
33443:     mFd = aJar->mZip.GetFD();
33443:     mZs.next_in = aJar->mZip.GetData(item);
36792:     if (!mZs.next_in)
36792:         return NS_ERROR_FILE_CORRUPTED;
33990:     mZs.avail_in = item->Size();
33990:     mOutSize = item->RealSize();
33443:     mZs.total_out = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
31399: nsJARInputStream::InitDirectory(nsJAR* aJar,
    1:                                 const nsACString& aJarDirSpec,
    1:                                 const char* aDir)
    1: {
31399:     NS_ABORT_IF_FALSE(aJar, "Argument may not be null");
31399:     NS_ABORT_IF_FALSE(aDir, "Argument may not be null");
    1: 
    1:     // Mark it as closed, in case something fails in initialisation
33443:     mMode = MODE_CLOSED;
    1:     
    1:     // Keep the zipReader for getting the actual zipItems
31399:     mJar = aJar;
    1:     nsZipFind *find;
    1:     nsresult rv;
    1:     // We can get aDir's contents as strings via FindEntries
    1:     // with the following pattern (see nsIZipReader.findEntries docs)
    1:     // assuming dirName is properly escaped:
    1:     //
    1:     //   dirName + "?*~" + dirName + "?*/?*"
    1:     nsDependentCString dirName(aDir);
    1:     mNameLen = dirName.Length();
    1: 
    1:     // iterate through dirName and copy it to escDirName, escaping chars
    1:     // which are special at the "top" level of the regexp so FindEntries
    1:     // works correctly
    1:     nsCAutoString escDirName;
    1:     const char* curr = dirName.BeginReading();
    1:     const char* end  = dirName.EndReading();
    1:     while (curr != end) {
    1:         switch (*curr) {
    1:             case '*':
    1:             case '?':
    1:             case '$':
    1:             case '[':
    1:             case ']':
    1:             case '^':
    1:             case '~':
    1:             case '(':
    1:             case ')':
    1:             case '\\':
    1:                 escDirName.Append('\\');
    1:                 // fall through
    1:             default:
    1:                 escDirName.Append(*curr);
    1:         }
    1:         ++curr;
    1:     }
    1:     nsCAutoString pattern = escDirName + NS_LITERAL_CSTRING("?*~") +
    1:                             escDirName + NS_LITERAL_CSTRING("?*/?*");
31399:     rv = mJar->mZip.FindInit(pattern.get(), &find);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     const char *name;
33990:     PRUint16 nameLen;
33990:     while ((rv = find->FindNext( &name, &nameLen )) == NS_OK) {
33990:         // Must copy, to make it zero-terminated
33990:         mArray.AppendElement(nsCString(name,nameLen));
    1:     }
    1:     delete find;
    1: 
    1:     if (rv != NS_ERROR_FILE_TARGET_DOES_NOT_EXIST && NS_FAILED(rv)) {
    1:         return NS_ERROR_FAILURE;    // no error translation
    1:     }
    1: 
    1:     // Sort it
    1:     mArray.Sort();
    1: 
    1:     mBuffer.AssignLiteral("300: ");
    1:     mBuffer.Append(aJarDirSpec);
    1:     mBuffer.AppendLiteral("\n200: filename content-length last-modified file-type\n");
    1: 
    1:     // Open for reading
33443:     mMode = MODE_DIRECTORY;
33443:     mZs.total_out = 0;
    1:     mArrPos = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsJARInputStream::Available(PRUint32 *_retval)
    1: {
33443:     // A lot of callers don't check the error code.
33443:     // They just use the _retval value.
33443:     *_retval = 0;
33443: 
33443:     switch (mMode) {
33443:       case MODE_NOTINITED:
33443:         break;
33443: 
33443:       case MODE_CLOSED:
    1:         return NS_BASE_STREAM_CLOSED;
    1: 
33443:       case MODE_DIRECTORY:
    1:         *_retval = mBuffer.Length();
33443:         break;
33443: 
33443:       case MODE_INFLATE:
33443:       case MODE_COPY:
33443:         *_retval = mOutSize - mZs.total_out;
33443:         break;
33443:     }
33443: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::Read(char* aBuffer, PRUint32 aCount, PRUint32 *aBytesRead)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aBuffer);
    1:     NS_ENSURE_ARG_POINTER(aBytesRead);
    1: 
    1:     *aBytesRead = 0;
    1: 
32208:     nsresult rv = NS_OK;
33443:     switch (mMode) {
33443:       case MODE_NOTINITED:
33443:         return NS_OK;
    1: 
33443:       case MODE_CLOSED:
33443:         return NS_BASE_STREAM_CLOSED;
33443: 
33443:       case MODE_DIRECTORY:
33443:         return ReadDirectory(aBuffer, aCount, aBytesRead);
33443: 
33443:       case MODE_INFLATE:
33443:         if (mFd) {
32208:           rv = ContinueInflate(aBuffer, aCount, aBytesRead);
13296:         }
33443:         // be aggressive about releasing the file!
33443:         // note that sometimes, we will release  mFd before we've finished
33443:         // deflating - this is because zlib buffers the input
33443:         if (mZs.avail_in == 0) {
33443:             mFd = nsnull;
    1:         }
33443:         break;
33443: 
33443:       case MODE_COPY:
33443:         if (mFd) {
35670:           PRUint32 count = NS_MIN(aCount, mOutSize - PRUint32(mZs.total_out));
33443:           if (count) {
33443:               memcpy(aBuffer, mZs.next_in + mZs.total_out, count);
33443:               mZs.total_out += count;
32208:           }
33443:           *aBytesRead = count;
    1:         }
33443:         // be aggressive about releasing the file!
33443:         // note that sometimes, we will release mFd before we've finished copying.
33443:         if (mZs.total_out >= mOutSize) {
33443:             mFd = nsnull;
33443:         }
33443:         break;
    1:     }
32208:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::ReadSegments(nsWriteSegmentFun writer, void * closure, PRUint32 count, PRUint32 *_retval)
    1: {
    1:     // don't have a buffer to read from, so this better not be called!
    1:     NS_NOTREACHED("Consumers should be using Read()!");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::IsNonBlocking(PRBool *aNonBlocking)
    1: {
    1:     *aNonBlocking = PR_FALSE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJARInputStream::Close()
    1: {
33443:     mMode = MODE_CLOSED;
33443:     mFd = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsJARInputStream::ContinueInflate(char* aBuffer, PRUint32 aCount,
    1:                                   PRUint32* aBytesRead)
    1: {
    1:     // No need to check the args, ::Read did that, but assert them at least
    1:     NS_ASSERTION(aBuffer,"aBuffer parameter must not be null");
    1:     NS_ASSERTION(aBytesRead,"aBytesRead parameter must not be null");
    1: 
    1:     // Keep old total_out count
33443:     const PRUint32 oldTotalOut = mZs.total_out;
    1:     
    1:     // make sure we aren't reading too much
35670:     mZs.avail_out = NS_MIN(aCount, (mOutSize-oldTotalOut));
33443:     mZs.next_out = (unsigned char*)aBuffer;
    1: 
    1:     // now inflate
33443:     int zerr = inflate(&mZs, Z_SYNC_FLUSH);
    1:     if ((zerr != Z_OK) && (zerr != Z_STREAM_END))
    1:         return NS_ERROR_FILE_CORRUPTED;
    1: 
33443:     *aBytesRead = (mZs.total_out - oldTotalOut);
    1: 
    1:     // Calculate the CRC on the output
33443:     mOutCrc = crc32(mOutCrc, (unsigned char*)aBuffer, *aBytesRead);
    1: 
    1:     // be aggressive about ending the inflation
    1:     // for some reason we don't always get Z_STREAM_END
33443:     if (zerr == Z_STREAM_END || mZs.total_out == mOutSize) {
33443:         inflateEnd(&mZs);
    1: 
    1:         // stop returning valid data as soon as we know we have a bad CRC
33443:         if (mOutCrc != mInCrc) {
    1:             // asserting because while this rarely happens, you definitely
    1:             // want to catch it in debug builds!
    1:             NS_NOTREACHED(0);
    1:             return NS_ERROR_FILE_CORRUPTED;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJARInputStream::ReadDirectory(char* aBuffer, PRUint32 aCount, PRUint32 *aBytesRead)
    1: {
    1:     // No need to check the args, ::Read did that, but assert them at least
    1:     NS_ASSERTION(aBuffer,"aBuffer parameter must not be null");
    1:     NS_ASSERTION(aBytesRead,"aBytesRead parameter must not be null");
    1: 
    1:     // If the buffer contains data, copy what's there up to the desired amount
    1:     PRUint32 numRead = CopyDataToBuffer(aBuffer, aCount);
    1: 
    1:     if (aCount > 0) {
    1:         // empty the buffer and start writing directory entry lines to it
    1:         mBuffer.Truncate();
    1:         mCurPos = 0;
24031:         const PRUint32 arrayLen = mArray.Length();
    1: 
    1:         for ( ;aCount > mBuffer.Length(); mArrPos++) {
    1:             // have we consumed all the directory contents?
    1:             if (arrayLen <= mArrPos)
    1:                 break;
    1: 
24031:             const char * entryName = mArray[mArrPos].get();
24031:             PRUint32 entryNameLen = mArray[mArrPos].Length();
31399:             nsZipItem* ze = mJar->mZip.GetItem(entryName);
    1:             NS_ENSURE_TRUE(ze, NS_ERROR_FILE_TARGET_DOES_NOT_EXIST);
    1: 
    1:             // Last Modified Time
    1:             PRExplodedTime tm;
33990:             PR_ExplodeTime(GetModTime(ze->Date(), ze->Time()), PR_GMTParameters, &tm);
    1:             char itemLastModTime[65];
    1:             PR_FormatTimeUSEnglish(itemLastModTime,
    1:                                    sizeof(itemLastModTime),
    1:                                    " %a,%%20%d%%20%b%%20%Y%%20%H:%M:%S%%20GMT ",
    1:                                    &tm);
    1: 
    1:             // write a 201: line to the buffer for this item
    1:             // 200: filename content-length last-modified file-type
    1:             mBuffer.AppendLiteral("201: ");
    1: 
    1:             // Names must be escaped and relative, so use the pre-calculated length
    1:             // of the directory name as the offset into the string
    1:             // NS_EscapeURL adds the escaped URL to the give string buffer
    1:             NS_EscapeURL(entryName + mNameLen,
    1:                          entryNameLen - mNameLen, 
    1:                          esc_Minimal | esc_AlwaysCopy,
    1:                          mBuffer);
    1: 
    1:             mBuffer.Append(' ');
33990:             mBuffer.AppendInt(ze->RealSize(), 10);
    1:             mBuffer.Append(itemLastModTime); // starts/ends with ' '
33990:             if (ze->IsDirectory()) 
    1:                 mBuffer.AppendLiteral("DIRECTORY\n");
    1:             else
    1:                 mBuffer.AppendLiteral("FILE\n");
    1:         }
    1: 
    1:         // Copy up to the desired amount of data to buffer
    1:         numRead += CopyDataToBuffer(aBuffer, aCount);
    1:     }
    1: 
    1:     *aBytesRead = numRead;
    1:     return NS_OK;
    1: }
    1: 
    1: PRUint32
    1: nsJARInputStream::CopyDataToBuffer(char* &aBuffer, PRUint32 &aCount)
    1: {
35670:     const PRUint32 writeLength = NS_MIN(aCount, mBuffer.Length() - mCurPos);
    1: 
    1:     if (writeLength > 0) {
    1:         memcpy(aBuffer, mBuffer.get() + mCurPos, writeLength);
    1:         mCurPos += writeLength;
    1:         aCount  -= writeLength;
    1:         aBuffer += writeLength;
    1:     }
    1: 
    1:     // return number of bytes copied to the buffer so the
    1:     // Read method can return the number of bytes copied
    1:     return writeLength;
    1: }
