 48383: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 48383: // vim:set ts=2 sts=2 sw=2 et cin:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 48383: 
126057: #include <dlfcn.h>
 48383: #import <AppKit/AppKit.h>
 71284: #import <QuartzCore/QuartzCore.h>
 48383: #include "PluginUtilsOSX.h"
 48383: 
 48383: // Remove definitions for try/catch interfering with ObjCException macros.
 48383: #include "nsObjCExceptions.h"
 72639: #include "nsCocoaUtils.h"
 72639: 
 72639: #include "nsDebug.h"
 48383: 
115799: @interface CALayer (ContentsScale)
115799: - (double)contentsScale;
115799: - (void)setContentsScale:(double)scale;
115799: @end
115799: 
 48383: using namespace mozilla::plugins::PluginUtilsOSX;
 48383: 
 71284: @interface CGBridgeLayer : CALayer {
 71284:   DrawPluginFunc mDrawFunc;
 71284:   void* mPluginInstance;
 71284:   nsIntRect mUpdateRect;
126057:   BOOL mAvoidCGCrashes;
126057:   CGContextRef mLastCGContext;
 71284: }
126057: - (void)setDrawFunc:(DrawPluginFunc)aFunc
126057:      pluginInstance:(void*)aPluginInstance
126057:      avoidCGCrashes:(BOOL)aAvoidCGCrashes;
 71284: - (void)updateRect:(nsIntRect)aRect;
126057: - (void)protectLastCGContext;
 71284: 
 71284: @end
 71284: 
126057: // CGBitmapContextSetData() is an undocumented function present (with
126057: // the same signature) since at least OS X 10.5.  As the name suggests,
126057: // it's used to replace the "data" in a bitmap context that was
126057: // originally specified in a call to CGBitmapContextCreate() or
126057: // CGBitmapContextCreateWithData().
126057: typedef void (*CGBitmapContextSetDataFunc) (CGContextRef c,
126057:                                             size_t x,
126057:                                             size_t y,
126057:                                             size_t width,
126057:                                             size_t height,
126057:                                             void* data,
126057:                                             size_t bitsPerComponent,
126057:                                             size_t bitsPerPixel,
126057:                                             size_t bytesPerRow);
126057: CGBitmapContextSetDataFunc CGBitmapContextSetDataPtr = NULL;
126057: 
 71284: @implementation CGBridgeLayer
 71284: - (void) updateRect:(nsIntRect)aRect
 71284: {
 71284:    mUpdateRect.UnionRect(mUpdateRect, aRect);
 71284: }
 71284: 
126057: - (void) setDrawFunc:(DrawPluginFunc)aFunc
126057:       pluginInstance:(void*)aPluginInstance
126057:       avoidCGCrashes:(BOOL)aAvoidCGCrashes
 71284: {
 71284:   mDrawFunc = aFunc;
 71284:   mPluginInstance = aPluginInstance;
126057:   mAvoidCGCrashes = aAvoidCGCrashes;
126057:   mLastCGContext = nil;
126057: }
126057: 
126057: // The Flash plugin, in very unusual circumstances, can (in CoreGraphics
126057: // mode) try to access the CGContextRef from -[CGBridgeLayer drawInContext:]
126057: // outside of any call to NPP_HandleEvent(NPCocoaEventDrawRect).  This usually
126057: // crashes the plugin process (probably because it tries to access deleted
126057: // memory).  We stop these crashes from happening by holding a reference to
126057: // the CGContextRef, and also by ensuring that it's data won't get deleted.
126057: // The CGContextRef won't "work" in this form.  But this won't cause trouble
126057: // for plugins that do things correctly (that don't access this CGContextRef
126057: // outside of the call to NPP_HandleEvent() that passes it to the plugin).
126057: // The OS may reuse this CGContextRef (it may get passed to other calls to
126057: // -[CGBridgeLayer drawInContext:]).  But before each call the OS calls
126057: // CGBitmapContextSetData() to replace its data, which undoes the changes
126057: // we make here.  See bug 804606.
126057: - (void)protectLastCGContext
126057: {
126057:   if (!mAvoidCGCrashes || !mLastCGContext) {
126057:     return;
126057:   }
126057: 
126057:   static char ensuredData[128] = {0};
126057: 
126057:   if (!CGBitmapContextSetDataPtr) {
126057:     CGBitmapContextSetDataPtr = (CGBitmapContextSetDataFunc)
126057:       dlsym(RTLD_DEFAULT, "CGBitmapContextSetData");
126057:   }
126057: 
126057:   if (CGBitmapContextSetDataPtr && (GetContextType(mLastCGContext) == CG_CONTEXT_TYPE_BITMAP)) {
126057:     CGBitmapContextSetDataPtr(mLastCGContext, 0, 0, 1, 1, ensuredData, 8, 32, 64);
126057:   }
 71284: }
 71284: 
 71284: - (void)drawInContext:(CGContextRef)aCGContext
 71284: {
 71284:   ::CGContextSaveGState(aCGContext); 
 71284:   ::CGContextTranslateCTM(aCGContext, 0, self.bounds.size.height);
 71284:   ::CGContextScaleCTM(aCGContext, (CGFloat) 1, (CGFloat) -1);
 71284: 
 71284:   mDrawFunc(aCGContext, mPluginInstance, mUpdateRect);
 71284: 
 71284:   ::CGContextRestoreGState(aCGContext);
 71284: 
126057:   if (mAvoidCGCrashes) {
126057:     if (mLastCGContext) {
126057:       ::CGContextRelease(mLastCGContext);
126057:     }
126057:     mLastCGContext = aCGContext;
126057:     ::CGContextRetain(mLastCGContext);
126057:   }
126057: 
 71284:   mUpdateRect.SetEmpty();
 71284: }
 71284: 
126057: - (void)dealloc
126057: {
126057:   if (mLastCGContext) {
126057:     ::CGContextRelease(mLastCGContext);
126057:   }
126057:   [super dealloc];
126057: }
126057: 
 71284: @end
 71284: 
126057: void* mozilla::plugins::PluginUtilsOSX::GetCGLayer(DrawPluginFunc aFunc, void* aPluginInstance,
126057:                                                    bool aAvoidCGCrashes)
126057: {
 71284:   CGBridgeLayer *bridgeLayer = [[CGBridgeLayer alloc] init ];
126057:   [bridgeLayer setDrawFunc:aFunc
126057:             pluginInstance:aPluginInstance
126057:             avoidCGCrashes:aAvoidCGCrashes];
 71284:   return bridgeLayer;
 71284: }
 71284: 
 71284: void mozilla::plugins::PluginUtilsOSX::ReleaseCGLayer(void *cgLayer) {
 71284:   CGBridgeLayer *bridgeLayer = (CGBridgeLayer*)cgLayer;
 71284:   [bridgeLayer release];
 71284: }
 71284: 
 71284: void mozilla::plugins::PluginUtilsOSX::Repaint(void *caLayer, nsIntRect aRect) {
 71284:   CGBridgeLayer *bridgeLayer = (CGBridgeLayer*)caLayer;
 72865:   [CATransaction begin];
 71284:   [bridgeLayer updateRect:aRect];
 71284:   [bridgeLayer setNeedsDisplay];
 72865:   [bridgeLayer displayIfNeeded];
 72865:   [CATransaction commit];
126057:   [bridgeLayer protectLastCGContext];
 71284: }
 71284: 
 48383: @interface EventProcessor : NSObject {
 48383:   RemoteProcessEvents   aRemoteEvents;
 48383:   void                 *aPluginModule;
 48383: }
 48383: - (void)setRemoteEvents:(RemoteProcessEvents) remoteEvents pluginModule:(void*) pluginModule;
 48383: - (void)onTick;
 48383: @end
 48383: 
 48383: @implementation EventProcessor
 48383: - (void) onTick
 48383: {
 48383:     aRemoteEvents(aPluginModule);
 48383: }
 48383: 
 48383: - (void)setRemoteEvents:(RemoteProcessEvents) remoteEvents pluginModule:(void*) pluginModule
 48383: {
 48383:     aRemoteEvents = remoteEvents;
 48383:     aPluginModule = pluginModule;
 48383: }
 48383: @end
 48383: 
 48383: #define EVENT_PROCESS_DELAY 0.05 // 50 ms
 48383: 
 48383: NPError mozilla::plugins::PluginUtilsOSX::ShowCocoaContextMenu(void* aMenu, int aX, int aY, void* pluginModule, RemoteProcessEvents remoteEvent) 
 48383: {
 48383:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 48383: 
 70434:   // Set the native cursor to the OS default (an arrow) before displaying the
 70434:   // context menu.  Otherwise (if the plugin has changed the cursor) it may
 70434:   // stay as the plugin has set it -- which means it may be invisible.  We
 70434:   // need to do this because we display the context menu without making the
 70434:   // plugin process the foreground process.  If we did, the cursor would
 70434:   // change to an arrow cursor automatically -- as it does in Chrome.
 70434:   [[NSCursor arrowCursor] set];
 70434: 
 48383:   // Create a timer to process browser events while waiting
 48383:   // on the menu. This prevents the browser from hanging
 48383:   // during the lifetime of the menu.
 48383:   EventProcessor* eventProcessor = [[EventProcessor alloc] init];
 48383:   [eventProcessor setRemoteEvents:remoteEvent pluginModule:pluginModule];
 48383:   NSTimer *eventTimer = [NSTimer timerWithTimeInterval:EVENT_PROCESS_DELAY
 48383:                              target:eventProcessor selector:@selector(onTick) 
 48383:                              userInfo:nil repeats:TRUE];
 48383:   // Use NSEventTrackingRunLoopMode otherwise the timer will
 48383:   // not fire during the right click menu.
 48383:   [[NSRunLoop currentRunLoop] addTimer:eventTimer 
 48383:                               forMode:NSEventTrackingRunLoopMode];
 48383: 
 48383:   NSMenu* nsmenu = reinterpret_cast<NSMenu*>(aMenu);
 48383:   NSPoint screen_point = ::NSMakePoint(aX, aY);
 48383: 
 48383:   [nsmenu popUpMenuPositioningItem:nil atLocation:screen_point inView:nil];
 48383: 
 50645:   [eventTimer invalidate];
 50645:   [eventProcessor release];
 48383: 
 48383:   return NPERR_NO_ERROR;
 48383: 
 50645:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NPERR_GENERIC_ERROR);
 48383: }
 48383: 
 48383: void mozilla::plugins::PluginUtilsOSX::InvokeNativeEventLoop()
 48383: {
 48383:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 48383:   ::CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.0, true);
 48383:   NS_OBJC_END_TRY_ABORT_BLOCK;
 48383: }
 72639: 
 72639: 
 72639: #define UNDOCUMENTED_SESSION_CONSTANT ((int)-2)
 73755: namespace mozilla {
 73755: namespace plugins {
 73755: namespace PluginUtilsOSX {
 73755:   static void *sApplicationASN = NULL;
 73755:   static void *sApplicationInfoItem = NULL;
 73755: }
 73755: }
 73755: }
 72639: 
 72639: bool mozilla::plugins::PluginUtilsOSX::SetProcessName(const char* aProcessName) {
 72639:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 72639:   nsAutoreleasePool localPool;
 72639: 
 72639:   if (!aProcessName || strcmp(aProcessName, "") == 0) {
 72639:     return false;
 72639:   }
 72639: 
 72639:   NSString *currentName = [[[NSBundle mainBundle] localizedInfoDictionary] 
 72639:                               objectForKey:(NSString *)kCFBundleNameKey];
 72639: 
 72639:   char formattedName[1024];
 72639:   snprintf(formattedName, sizeof(formattedName), 
 72639:       "%s (%s)", [currentName UTF8String], aProcessName);
 72639: 
 72639:   aProcessName = formattedName;
 72639: 
 72639:   // This function is based on Chrome/Webkit's and relies on potentially dangerous SPI.
 72639:   typedef CFTypeRef (*LSGetASNType)();
 72639:   typedef OSStatus (*LSSetInformationItemType)(int, CFTypeRef,
 72639:                                                CFStringRef, 
 72639:                                                CFStringRef,
 72639:                                                CFDictionaryRef*);
 72639: 
 72639:   CFBundleRef launchServices = ::CFBundleGetBundleWithIdentifier(
 72639:                                           CFSTR("com.apple.LaunchServices"));
 72639:   if (!launchServices) {
 72639:     NS_WARNING("Failed to set process name: Could not open LaunchServices bundle");
 72639:     return false;
 72639:   }
 72639: 
 72639:   if (!sApplicationASN) {
 72639:     sApplicationASN = ::CFBundleGetFunctionPointerForName(launchServices, 
 72639:                                             CFSTR("_LSGetCurrentApplicationASN"));
 72639:   }
 72639: 
 72639:   LSGetASNType getASNFunc = reinterpret_cast<LSGetASNType>
 72639:                                           (sApplicationASN);
 72639: 
 72639:   if (!sApplicationInfoItem) {
 72639:     sApplicationInfoItem = ::CFBundleGetFunctionPointerForName(launchServices, 
 72639:                                             CFSTR("_LSSetApplicationInformationItem"));
 72639:   }
 72639: 
 72639:   LSSetInformationItemType setInformationItemFunc 
 72639:                                           = reinterpret_cast<LSSetInformationItemType>
 72639:                                           (sApplicationInfoItem);
 72639: 
 72639:   void * displayNameKeyAddr = ::CFBundleGetDataPointerForName(launchServices,
 72639:                                           CFSTR("_kLSDisplayNameKey"));
 72639: 
 72639:   CFStringRef displayNameKey = nil;
 72639:   if (displayNameKeyAddr) {
 72639:     displayNameKey = reinterpret_cast<CFStringRef>(*(CFStringRef*)displayNameKeyAddr);
 72639:   }
 72639: 
 72639:   // Rename will fail without this
 72639:   ProcessSerialNumber psn;
 72639:   if (::GetCurrentProcess(&psn) != noErr) {
 72639:     return false;
 72639:   }
 72639: 
 72639:   CFTypeRef currentAsn = getASNFunc();
 72639: 
 72639:   if (!getASNFunc || !setInformationItemFunc || 
 72639:       !displayNameKey || !currentAsn) {
 72639:     NS_WARNING("Failed to set process name: Accessing launchServices failed");
 72639:     return false;
 72639:   }
 72639: 
 72639:   CFStringRef processName = ::CFStringCreateWithCString(nil, 
 72639:                                                         aProcessName, 
 72639:                                                         kCFStringEncodingASCII);
 72639:   if (!processName) {
 72639:     NS_WARNING("Failed to set process name: Could not create CFStringRef");
 72639:     return false;
 72639:   }
 72639: 
 72639:   OSErr err = setInformationItemFunc(UNDOCUMENTED_SESSION_CONSTANT, currentAsn,
 72639:                                      displayNameKey, processName,
 72639:                                      nil); // Optional out param
 72639:   ::CFRelease(processName);
 72639:   if (err != noErr) {
 72639:     NS_WARNING("Failed to set process name: LSSetInformationItemType err");
 72639:     return false;
 72639:   }
 72639: 
 72639:   return true;
 72639:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(false);
 72639: }
 73761: 
 73761: namespace mozilla {
 73761: namespace plugins {
 73761: namespace PluginUtilsOSX {
 73761: 
 73761: size_t nsDoubleBufferCARenderer::GetFrontSurfaceWidth() {
 73761:   if (!HasFrontSurface()) {
 73761:     return 0;
 73761:   }
 73761: 
 73761:   return mFrontSurface->GetWidth();
 73761: }
 73761: 
 73761: size_t nsDoubleBufferCARenderer::GetFrontSurfaceHeight() {
 73761:   if (!HasFrontSurface()) {
 73761:     return 0;
 73761:   }
 73761: 
 73761:   return mFrontSurface->GetHeight();
 73761: }
 73761: 
119106: double nsDoubleBufferCARenderer::GetFrontSurfaceContentsScaleFactor() {
119106:   if (!HasFrontSurface()) {
119106:     return 1.0;
119106:   }
119106: 
119106:   return mFrontSurface->GetContentsScaleFactor();
119106: }
119106: 
 73761: size_t nsDoubleBufferCARenderer::GetBackSurfaceWidth() {
 73761:   if (!HasBackSurface()) {
 73761:     return 0;
 73761:   }
 73761: 
 73761:   return mBackSurface->GetWidth();
 73761: }
 73761: 
 73761: size_t nsDoubleBufferCARenderer::GetBackSurfaceHeight() {
 73761:   if (!HasBackSurface()) {
 73761:     return 0;
 73761:   }
 73761: 
 73761:   return mBackSurface->GetHeight();
 73761: }
 73761: 
119106: double nsDoubleBufferCARenderer::GetBackSurfaceContentsScaleFactor() {
119106:   if (!HasBackSurface()) {
119106:     return 1.0;
119106:   }
119106: 
119106:   return mBackSurface->GetContentsScaleFactor();
119106: }
119106: 
 73761: IOSurfaceID nsDoubleBufferCARenderer::GetFrontSurfaceID() {
 73761:   if (!HasFrontSurface()) {
 73761:     return 0;
 73761:   }
 73761: 
 73761:   return mFrontSurface->GetIOSurfaceID();
 73761: }
 73761: 
 73761: bool nsDoubleBufferCARenderer::HasBackSurface() {
 73761:   return !!mBackSurface;
 73761: }
 73761: 
 73761: bool nsDoubleBufferCARenderer::HasFrontSurface() {
 73761:   return !!mFrontSurface;
 73761: }
 73761: 
 73761: bool nsDoubleBufferCARenderer::HasCALayer() {
 73761:   return !!mCALayer;
 73761: }
 73761: 
 73761: void nsDoubleBufferCARenderer::SetCALayer(void *aCALayer) {
 73761:   mCALayer = aCALayer;
 73761: }
 73761: 
 80957: bool nsDoubleBufferCARenderer::InitFrontSurface(size_t aWidth, size_t aHeight,
115799:                                                 double aContentsScaleFactor,
 80957:                                                 AllowOfflineRendererEnum aAllowOfflineRenderer) {
 73761:   if (!mCALayer) {
 73761:     return false;
 73761:   }
 73761: 
115799:   mContentsScaleFactor = aContentsScaleFactor;
115799:   mFrontSurface = MacIOSurface::CreateIOSurface(aWidth, aHeight, mContentsScaleFactor);
 73761:   if (!mFrontSurface) {
106838:     mCARenderer = nullptr;
 73761:     return false;
 73761:   }
 73761: 
 82335:   if (!mCARenderer) {
 82335:     mCARenderer = new nsCARenderer();
 82335:     if (!mCARenderer) {
106838:       mFrontSurface = nullptr;
 73761:       return false;
 73761:     }
 73761: 
 82335:     mCARenderer->AttachIOSurface(mFrontSurface);
 82335: 
 82335:     nsresult result = mCARenderer->SetupRenderer(mCALayer,
 82335:                         mFrontSurface->GetWidth(),
 82335:                         mFrontSurface->GetHeight(),
115799:                         mContentsScaleFactor,
 82335:                         aAllowOfflineRenderer);
 82335: 
 82335:     if (result != NS_OK) {
106838:       mCARenderer = nullptr;
106838:       mFrontSurface = nullptr;
 73761:       return false;
 73761:     }
 82335:   } else {
 82335:     mCARenderer->AttachIOSurface(mFrontSurface);
 82335:   }
 73761: 
 82335:   return true;
 73761: }
 73761: 
 73761: void nsDoubleBufferCARenderer::Render() {
 82335:   if (!HasFrontSurface() || !mCARenderer) {
 73761:     return;
 73761:   }
 73761: 
115799:   mCARenderer->Render(GetFrontSurfaceWidth(), GetFrontSurfaceHeight(),
115799:                       mContentsScaleFactor, nullptr);
 73761: }
 73761: 
 73761: void nsDoubleBufferCARenderer::SwapSurfaces() {
106985:   RefPtr<MacIOSurface> prevFrontSurface = mFrontSurface;
 73761:   mFrontSurface = mBackSurface;
 73761:   mBackSurface = prevFrontSurface;
 73761: 
 82335:   if (mFrontSurface) {
 82335:     mCARenderer->AttachIOSurface(mFrontSurface);
 73761:   }
 73761: }
 73761: 
 73761: void nsDoubleBufferCARenderer::ClearFrontSurface() {
106838:   mFrontSurface = nullptr;
 82335:   if (!mFrontSurface && !mBackSurface) {
106838:     mCARenderer = nullptr;
 82335:   }
 73761: }
 73761: 
 73761: void nsDoubleBufferCARenderer::ClearBackSurface() {
106838:   mBackSurface = nullptr;
 82335:   if (!mFrontSurface && !mBackSurface) {
106838:     mCARenderer = nullptr;
 82335:   }
 73761: }
 73761: 
 73761: } //PluginUtilsOSX
 73761: } //plugins
 73761: } //mozilla
 73761: 
