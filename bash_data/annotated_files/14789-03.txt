    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
11377:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsinterp_h___
    1: #define jsinterp_h___
    1: /*
    1:  * JS interpreter interface.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
11377: #include "jsopcode.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
13168: typedef struct JSFrameRegs {
13168:     jsbytecode      *pc;            /* program counter */
13168:     jsval           *sp;            /* stack pointer */
13168: } JSFrameRegs;
13168: 
    1: /*
    1:  * JS stack frame, may be allocated on the C stack by native callers.  Always
    1:  * allocated on cx->stackPool for calls from the interpreter to an interpreted
    1:  * function.
    1:  *
    1:  * NB: This struct is manually initialized in jsinterp.c and jsiter.c.  If you
    1:  * add new members, update both files.  But first, try to remove members.  The
    1:  * sharp* and xml* members should be moved onto the stack as local variables
    1:  * with well-known slots, if possible.
    1:  */
    1: struct JSStackFrame {
13168:     JSFrameRegs     *regs;
12579:     jsval           *spbase;        /* operand stack base */
    1:     JSObject        *callobj;       /* lazily created Call object */
    1:     JSObject        *argsobj;       /* lazily created arguments object */
    1:     JSObject        *varobj;        /* variables object, where vars go */
 4127:     JSObject        *callee;        /* function or script object */
    1:     JSScript        *script;        /* script being interpreted */
    1:     JSFunction      *fun;           /* function being called or null */
    1:     JSObject        *thisp;         /* "this" pointer if in method */
    1:     uintN           argc;           /* actual argument count */
    1:     jsval           *argv;          /* base of argument stack slots */
    1:     jsval           rval;           /* function return value */
    1:     uintN           nvars;          /* local variable count */
    1:     jsval           *vars;          /* base of variable stack slots */
    1:     JSStackFrame    *down;          /* previous frame */
    1:     void            *annotation;    /* used by Java security */
    1:     JSObject        *scopeChain;    /* scope chain */
    1:     uintN           sharpDepth;     /* array/object initializer depth */
    1:     JSObject        *sharpArray;    /* scope for #n= initializer vars */
    1:     uint32          flags;          /* frame flags -- see below */
    1:     JSStackFrame    *dormantNext;   /* next dormant frame chain */
    1:     JSObject        *xmlNamespace;  /* null or default xml namespace in E4X */
    1:     JSObject        *blockChain;    /* active compile-time block scopes */
11377: #ifdef DEBUG
11377:     jsrefcount      pcDisabledSave; /* for balanced property cache control */
11377: #endif
    1: };
    1: 
    1: typedef struct JSInlineFrame {
    1:     JSStackFrame    frame;          /* base struct */
13168:     JSFrameRegs     callerRegs;     /* parent's frame registers */
    1:     void            *mark;          /* mark before inline frame */
    1:     void            *hookData;      /* debugger call hook data */
    1:     JSVersion       callerVersion;  /* dynamic version of calling script */
    1: } JSInlineFrame;
    1: 
    1: /* JS stack frame flags. */
    1: #define JSFRAME_CONSTRUCTING   0x01 /* frame is for a constructor invocation */
14721: #define JSFRAME_COMPUTED_THIS  0x02 /* frame.thisp was computed already */
 6040: #define JSFRAME_ASSIGNING      0x04 /* a complex (not simplex JOF_ASSIGNING) op
    1:                                        is currently assigning to a property */
 6040: #define JSFRAME_DEBUGGER       0x08 /* frame for JS_EvaluateInStackFrame */
 6040: #define JSFRAME_EVAL           0x10 /* frame for obj_eval */
 8444: #define JSFRAME_SCRIPT_OBJECT  0x20 /* compiling source for a Script object */
 8444: #define JSFRAME_YIELDING       0x40 /* js_Interpret dispatched JSOP_YIELD */
11672: #define JSFRAME_ITERATOR       0x80 /* trying to get an iterator for for-in */
11672: #define JSFRAME_POP_BLOCKS    0x100 /* scope chain contains blocks to pop */
11672: #define JSFRAME_GENERATOR     0x200 /* frame belongs to generator-iterator */
11672: #define JSFRAME_ROOTED_ARGV   0x400 /* frame.argv is rooted by the caller */
    1: 
    1: #define JSFRAME_OVERRIDE_SHIFT 24   /* override bit-set params; see jsfun.c */
    1: #define JSFRAME_OVERRIDE_BITS  8
    1: 
 8444: #define JSFRAME_SPECIAL       (JSFRAME_DEBUGGER | JSFRAME_EVAL)
 8444: 
11377: /*
11377:  * Property cache with structurally typed capabilities for invalidation, for
11377:  * polymorphic callsite method/get/set speedups.
11377:  *
11377:  * See bug https://bugzilla.mozilla.org/show_bug.cgi?id=365851.
11377:  */
11377: #define PROPERTY_CACHE_LOG2     12
11377: #define PROPERTY_CACHE_SIZE     JS_BIT(PROPERTY_CACHE_LOG2)
11377: #define PROPERTY_CACHE_MASK     JS_BITMASK(PROPERTY_CACHE_LOG2)
11377: 
11377: #define PROPERTY_CACHE_HASH(pc,kshape)                                        \
11377:     ((((jsuword)(pc) >> PROPERTY_CACHE_LOG2) ^ (jsuword)(pc) ^ (kshape)) &    \
11377:      PROPERTY_CACHE_MASK)
11377: 
11377: #define PROPERTY_CACHE_HASH_PC(pc,kshape)                                     \
11377:     PROPERTY_CACHE_HASH(pc, kshape)
11377: 
11377: #define PROPERTY_CACHE_HASH_ATOM(atom,obj,pobj)                               \
11377:     PROPERTY_CACHE_HASH((jsuword)(atom) >> 2, OBJ_SCOPE(obj)->shape)
11377: 
11377: /*
11377:  * Property cache value capability macros.
11377:  */
11377: #define PCVCAP_PROTOBITS        4
11377: #define PCVCAP_PROTOSIZE        JS_BIT(PCVCAP_PROTOBITS)
11377: #define PCVCAP_PROTOMASK        JS_BITMASK(PCVCAP_PROTOBITS)
11377: 
11377: #define PCVCAP_SCOPEBITS        4
11377: #define PCVCAP_SCOPESIZE        JS_BIT(PCVCAP_SCOPEBITS)
11377: #define PCVCAP_SCOPEMASK        JS_BITMASK(PCVCAP_SCOPEBITS)
11377: 
11377: #define PCVCAP_TAGBITS          (PCVCAP_PROTOBITS + PCVCAP_SCOPEBITS)
11377: #define PCVCAP_TAGMASK          JS_BITMASK(PCVCAP_TAGBITS)
11377: #define PCVCAP_TAG(t)           ((t) & PCVCAP_TAGMASK)
11377: 
11377: #define PCVCAP_MAKE(t,s,p)      (((t) << PCVCAP_TAGBITS) |                    \
11377:                                  ((s) << PCVCAP_PROTOBITS) |                  \
11377:                                  (p))
12307: #define PCVCAP_SHAPE(t)         ((t) >> PCVCAP_TAGBITS)
11377: 
11377: #define SHAPE_OVERFLOW_BIT      JS_BIT(32 - PCVCAP_TAGBITS)
11377: 
11377: extern uint32
14755: js_GenerateShape(JSContext *cx, JSBool gcLocked);
11377: 
11377: struct JSPropCacheEntry {
11377:     jsbytecode          *kpc;           /* pc if vcap tag is <= 1, else atom */
11377:     jsuword             kshape;         /* key shape if pc, else obj for atom */
11377:     jsuword             vcap;           /* value capability, see above */
11377:     jsuword             vword;          /* value word, see PCVAL_* below */
11377: };
11377: 
11377: #if defined DEBUG_brendan || defined DEBUG_brendaneich
11377: #define JS_PROPERTY_CACHE_METERING 1
11377: #endif
11377: 
11377: typedef struct JSPropertyCache {
11377:     JSPropCacheEntry    table[PROPERTY_CACHE_SIZE];
11377:     JSBool              empty;
11377:     jsrefcount          disabled;       /* signed for anti-underflow asserts */
11377: #ifdef JS_PROPERTY_CACHE_METERING
11377:     uint32              fills;          /* number of cache entry fills */
11377:     uint32              nofills;        /* couldn't fill (e.g. default get) */
11377:     uint32              rofills;        /* set on read-only prop can't fill */
11377:     uint32              disfills;       /* fill attempts on disabled cache */
11377:     uint32              oddfills;       /* fill attempt after setter deleted */
11377:     uint32              modfills;       /* fill that rehashed to a new entry */
11377:     uint32              brandfills;     /* scope brandings to type structural
11377:                                            method fills */
13342:     uint32              noprotos;       /* resolve-returned non-proto pobj */
11377:     uint32              longchains;     /* overlong scope and/or proto chain */
11377:     uint32              recycles;       /* cache entries recycled by fills */
11377:     uint32              pcrecycles;     /* pc-keyed entries recycled by atom-
11377:                                            keyed fills */
11377:     uint32              tests;          /* cache probes */
11377:     uint32              pchits;         /* fast-path polymorphic op hits */
11377:     uint32              protopchits;    /* pchits hitting immediate prototype */
12307:     uint32              initests;       /* cache probes from JSOP_INITPROP */
12307:     uint32              inipchits;      /* init'ing next property pchit case */
12307:     uint32              inipcmisses;    /* init'ing next property pc misses */
11377:     uint32              settests;       /* cache probes from JOF_SET opcodes */
11377:     uint32              addpchits;      /* adding next property pchit case */
11377:     uint32              setpchits;      /* setting existing property pchit */
11377:     uint32              setpcmisses;    /* setting/adding property pc misses */
12307:     uint32              slotchanges;    /* clasp->reserveSlots result variance-
12307:                                            induced slot changes */
11377:     uint32              setmisses;      /* JSOP_SET{NAME,PROP} total misses */
11377:     uint32              idmisses;       /* slow-path key id == atom misses */
11377:     uint32              komisses;       /* slow-path key object misses */
11377:     uint32              vcmisses;       /* value capability misses */
11377:     uint32              misses;         /* cache misses */
11377:     uint32              flushes;        /* cache flushes */
11377: # define PCMETER(x)     x
11377: #else
11541: # define PCMETER(x)     ((void)0)
11377: #endif
11377: } JSPropertyCache;
11377: 
11377: /*
11377:  * Property cache value tagging/untagging macros.
11377:  */
11377: #define PCVAL_OBJECT            0
11377: #define PCVAL_SLOT              1
11377: #define PCVAL_SPROP             2
11377: 
11377: #define PCVAL_TAGBITS           2
11377: #define PCVAL_TAGMASK           JS_BITMASK(PCVAL_TAGBITS)
11377: #define PCVAL_TAG(v)            ((v) & PCVAL_TAGMASK)
11377: #define PCVAL_CLRTAG(v)         ((v) & ~(jsuword)PCVAL_TAGMASK)
11377: #define PCVAL_SETTAG(v,t)       ((jsuword)(v) | (t))
11377: 
11377: #define PCVAL_NULL              0
11377: #define PCVAL_IS_NULL(v)        ((v) == PCVAL_NULL)
11377: 
11377: #define PCVAL_IS_OBJECT(v)      (PCVAL_TAG(v) == PCVAL_OBJECT)
11377: #define PCVAL_TO_OBJECT(v)      ((JSObject *) (v))
11377: #define OBJECT_TO_PCVAL(obj)    ((jsuword) (obj))
11377: 
11377: #define PCVAL_OBJECT_TO_JSVAL(v) OBJECT_TO_JSVAL(PCVAL_TO_OBJECT(v))
11377: #define JSVAL_OBJECT_TO_PCVAL(v) OBJECT_TO_PCVAL(JSVAL_TO_OBJECT(v))
11377: 
11377: #define PCVAL_IS_SLOT(v)        ((v) & PCVAL_SLOT)
11377: #define PCVAL_TO_SLOT(v)        ((jsuint)(v) >> 1)
11377: #define SLOT_TO_PCVAL(i)        (((jsuword)(i) << 1) | PCVAL_SLOT)
11377: 
11377: #define PCVAL_IS_SPROP(v)       (PCVAL_TAG(v) == PCVAL_SPROP)
11377: #define PCVAL_TO_SPROP(v)       ((JSScopeProperty *) PCVAL_CLRTAG(v))
11377: #define SPROP_TO_PCVAL(sprop)   PCVAL_SETTAG(sprop, PCVAL_SPROP)
11377: 
11377: /*
11377:  * Fill property cache entry for key cx->fp->pc, optimized value word computed
11377:  * from obj and sprop, and entry capability forged from OBJ_SCOPE(obj)->shape,
11377:  * scopeIndex, and protoIndex.
11377:  */
11377: extern void
11377: js_FillPropertyCache(JSContext *cx, JSObject *obj, jsuword kshape,
11377:                      uintN scopeIndex, uintN protoIndex,
11377:                      JSObject *pobj, JSScopeProperty *sprop,
11377:                      JSPropCacheEntry **entryp);
11377: 
11377: /*
11377:  * Property cache lookup macros. PROPERTY_CACHE_TEST is designed to inline the
11377:  * fast path in js_Interpret, so it makes "just-so" restrictions on parameters,
11377:  * e.g. pobj and obj should not be the same variable, since for JOF_PROP-mode
11377:  * opcodes, obj must not be changed because of a cache miss.
11377:  *
11377:  * On return from PROPERTY_CACHE_TEST, if atom is null then obj points to the
11377:  * scope chain element in which the property was found, pobj is locked, and
11377:  * entry is valid. If atom is non-null then no object is locked but entry is
11377:  * still set correctly for use, e.g., by js_FillPropertyCache and atom should
11377:  * be used as the id to find.
11377:  *
11377:  * We must lock pobj on a hit in order to close races with threads that might
11377:  * be deleting a property from its scope, or otherwise invalidating property
11377:  * caches (on all threads) by re-generating scope->shape.
11377:  */
11377: #define PROPERTY_CACHE_TEST(cx, pc, obj, pobj, entry, atom)                   \
11377:     do {                                                                      \
11377:         JSPropertyCache *cache_ = &JS_PROPERTY_CACHE(cx);                     \
11832:         uint32 kshape_ = (JS_ASSERT(OBJ_IS_NATIVE(obj)),                      \
11832:                           OBJ_SCOPE(obj)->shape);                             \
11377:         entry = &cache_->table[PROPERTY_CACHE_HASH_PC(pc, kshape_)];          \
11377:         PCMETER(cache_->tests++);                                             \
11377:         JS_ASSERT(&obj != &pobj);                                             \
11377:         if (entry->kpc == pc && entry->kshape == kshape_) {                   \
11377:             JSObject *tmp_;                                                   \
11377:             pobj = obj;                                                       \
11377:             JS_LOCK_OBJ(cx, pobj);                                            \
11377:             JS_ASSERT(PCVCAP_TAG(entry->vcap) <= 1);                          \
11377:             if (PCVCAP_TAG(entry->vcap) == 1 &&                               \
11999:                 (tmp_ = LOCKED_OBJ_GET_PROTO(pobj)) != NULL &&                \
11999:                 OBJ_IS_NATIVE(tmp_)) {                                        \
11377:                 JS_UNLOCK_OBJ(cx, pobj);                                      \
11377:                 pobj = tmp_;                                                  \
11377:                 JS_LOCK_OBJ(cx, pobj);                                        \
11377:             }                                                                 \
12307:             if (PCVCAP_SHAPE(entry->vcap) == OBJ_SCOPE(pobj)->shape) {        \
11377:                 PCMETER(cache_->pchits++);                                    \
11377:                 PCMETER(!PCVCAP_TAG(entry->vcap) || cache_->protopchits++);   \
11377:                 pobj = OBJ_SCOPE(pobj)->object;                               \
11377:                 atom = NULL;                                                  \
11377:                 break;                                                        \
11377:             }                                                                 \
11377:             JS_UNLOCK_OBJ(cx, pobj);                                          \
11377:         }                                                                     \
11377:         atom = js_FullTestPropertyCache(cx, pc, &obj, &pobj, &entry);         \
11377:         if (atom)                                                             \
11377:             PCMETER(cache_->misses++);                                        \
11377:     } while (0)
11377: 
11377: extern JSAtom *
11377: js_FullTestPropertyCache(JSContext *cx, jsbytecode *pc,
11377:                          JSObject **objp, JSObject **pobjp,
11377:                          JSPropCacheEntry **entryp);
11377: 
11377: extern void
11377: js_FlushPropertyCache(JSContext *cx);
11377: 
11377: extern void
11377: js_FlushPropertyCacheForScript(JSContext *cx, JSScript *script);
11377: 
11377: extern void
11377: js_DisablePropertyCache(JSContext *cx);
11377: 
11377: extern void
11377: js_EnablePropertyCache(JSContext *cx);
11377: 
11377: /*
11377:  * Interpreter stack arena-pool alloc and free functions.
11377:  */
    1: extern JS_FRIEND_API(jsval *)
    1: js_AllocStack(JSContext *cx, uintN nslots, void **markp);
    1: 
    1: extern JS_FRIEND_API(void)
    1: js_FreeStack(JSContext *cx, void *mark);
    1: 
12551: extern jsval *
12551: js_AllocRawStack(JSContext *cx, uintN nslots, void **markp);
12551: 
12551: extern void
12551: js_FreeRawStack(JSContext *cx, void *mark);
12551: 
    1: /*
    1:  * Refresh and return fp->scopeChain.  It may be stale if block scopes are
    1:  * active but not yet reflected by objects in the scope chain.  If a block
    1:  * scope contains a with, eval, XML filtering predicate, or similar such
    1:  * dynamically scoped construct, then compile-time block scope at fp->blocks
    1:  * must reflect at runtime.
    1:  */
    1: extern JSObject *
    1: js_GetScopeChain(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
 4127:  * Given a context and a vector of [callee, this, args...] for a function that
 4127:  * was specified with a JSFUN_THISP_PRIMITIVE flag, get the primitive value of
 4127:  * |this| into *thisvp. In doing so, if |this| is an object, insist it is an
 4127:  * instance of clasp and extract its private slot value to return via *thisvp.
 4127:  *
 4127:  * NB: this function loads and uses *vp before storing *thisvp, so the two may
 4127:  * alias the same jsval.
 4127:  */
 4127: extern JSBool
 4127: js_GetPrimitiveThis(JSContext *cx, jsval *vp, JSClass *clasp, jsval *thisvp);
 4127: 
 4127: /*
 2383:  * For a call with arguments argv including argv[-1] (nominal |this|) and
 2383:  * argv[-2] (callee) replace null |this| with callee's parent, replace
 2383:  * primitive values with the equivalent wrapper objects and censor activation
 2383:  * objects as, per ECMA-262, they may not be referred to by |this|. argv[-1]
 2383:  * must not be a JSVAL_VOID.
    1:  */
11774: extern JSObject *
11774: js_ComputeThis(JSContext *cx, JSBool lazy, jsval *argv);
    1: 
    1: /*
12551:  * ECMA requires "the global object", but in embeddings such as the browser,
12551:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
12551:  * we prefer fun's parent.  An example that causes this code to run:
12551:  *
12551:  *   // in window w1
12551:  *   function f() { return this }
12551:  *   function g() { return f }
12551:  *
12551:  *   // in window w2
12551:  *   var h = w1.g()
12551:  *   alert(h() == w1)
12551:  *
12551:  * The alert should display "true".
12551:  */
12551: JSObject *
12551: js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv);
12551: 
12551: extern const uint16 js_PrimitiveTestFlags[];
12551: 
12551: #define PRIMITIVE_THIS_TEST(fun,thisv)                                        \
12551:     (JS_ASSERT(thisv != JSVAL_VOID),                                          \
13702:      JSFUN_THISP_TEST(JSFUN_THISP_FLAGS((fun)->flags),                        \
12551:                       js_PrimitiveTestFlags[JSVAL_TAG(thisv) - 1]))
12551: 
12551: /*
    1:  * NB: js_Invoke requires that cx is currently running JS (i.e., that cx->fp
 6040:  * is non-null), and that vp points to the callee, |this| parameter, and
 6040:  * actual arguments of the call. [vp .. vp + 2 + argc) must belong to the last
11758:  * JS stack segment that js_AllocStack allocated. The function may use the
11758:  * space available after vp + 2 + argc in the stack segment for temporaries,
11758:  * so the caller should not use that space for values that must be preserved
11758:  * across the call.
    1:  */
    1: extern JS_FRIEND_API(JSBool)
 6040: js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags);
    1: 
    1: /*
    1:  * Consolidated js_Invoke flags simply rename certain JSFRAME_* flags, so that
    1:  * we can share bits stored in JSStackFrame.flags and passed to:
    1:  *
    1:  *   js_Invoke
    1:  *   js_InternalInvoke
    1:  *   js_ValueToFunction
    1:  *   js_ValueToFunctionObject
    1:  *   js_ValueToCallableObject
    1:  *   js_ReportIsNotFunction
    1:  *
    1:  * See jsfun.h for the latter four and flag renaming macros.
    1:  */
    1: #define JSINVOKE_CONSTRUCT      JSFRAME_CONSTRUCTING
    1: #define JSINVOKE_ITERATOR       JSFRAME_ITERATOR
    1: 
    1: /*
    1:  * Mask to isolate construct and iterator flags for use with jsfun.h functions.
    1:  */
    1: #define JSINVOKE_FUNFLAGS       (JSINVOKE_CONSTRUCT | JSINVOKE_ITERATOR)
    1: 
    1: /*
    1:  * "Internal" calls may come from C or C++ code using a JSContext on which no
    1:  * JS is running (!cx->fp), so they may need to push a dummy JSStackFrame.
    1:  */
    1: #define js_InternalCall(cx,obj,fval,argc,argv,rval)                           \
    1:     js_InternalInvoke(cx, obj, fval, 0, argc, argv, rval)
    1: 
    1: #define js_InternalConstruct(cx,obj,fval,argc,argv,rval)                      \
    1:     js_InternalInvoke(cx, obj, fval, JSINVOKE_CONSTRUCT, argc, argv, rval)
    1: 
    1: extern JSBool
    1: js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,
    1:                   uintN argc, jsval *argv, jsval *rval);
    1: 
    1: extern JSBool
    1: js_InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, jsval fval,
    1:                     JSAccessMode mode, uintN argc, jsval *argv, jsval *rval);
    1: 
    1: extern JSBool
    1: js_Execute(JSContext *cx, JSObject *chain, JSScript *script,
    1:            JSStackFrame *down, uintN flags, jsval *result);
    1: 
    1: extern JSBool
14789: js_InvokeConstructor(JSContext *cx, uintN argc, jsval *vp);
12551: 
12551: extern JSBool
12688: js_Interpret(JSContext *cx);
12551: 
12551: #define JSPROP_INITIALIZER 0x100   /* NB: Not a valid property attribute. */
12551: 
12551: extern JSBool
    1: js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                       JSObject **objp, JSProperty **propp);
    1: 
    1: extern JSBool
 9560: js_StrictlyEqual(JSContext *cx, jsval lval, jsval rval);
    1: 
    1: extern JSBool
12551: js_EnterWith(JSContext *cx, jsint stackIndex);
12551: 
12551: extern void
12551: js_LeaveWith(JSContext *cx);
12551: 
12551: extern JSClass *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth);
12551: 
12551: extern jsint
12551: js_CountWithBlocks(JSContext *cx, JSStackFrame *fp);
12551: 
12551: /*
12551:  * Unwind block and scope chains to match the given depth. The function sets
12551:  * fp->sp on return to stackDepth.
12551:  */
12551: extern JSBool
12551: js_UnwindScope(JSContext *cx, JSStackFrame *fp, jsint stackDepth,
12551:                JSBool normalUnwind);
    1: 
    1: extern JSBool
12551: js_InternNonIntElementId(JSContext *cx, JSObject *obj, jsval idval, jsid *idp);
12551: 
12551: extern JSBool
12551: js_ImportProperty(JSContext *cx, JSObject *obj, jsid id);
12551: 
12579: extern JSBool
12579: js_OnUnknownMethod(JSContext *cx, jsval *vp);
12579: 
12551: /*
12611:  * Find the results of incrementing or decrementing *vp. For pre-increments,
12611:  * both *vp and *vp2 will contain the result on return. For post-increments,
12611:  * vp will contain the original value converted to a number and vp2 will get
12611:  * the result. Both vp and vp2 must be roots.
12611:  */
12611: extern JSBool
12611: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, jsval *vp, jsval *vp2);
12611: 
12611: /*
12551:  * JS_OPMETER helper functions.
12551:  */
12551: extern void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2);
12551: 
12551: extern void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot);
    1: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsinterp_h___ */
