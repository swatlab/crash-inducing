62204: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
62204:  * ***** BEGIN LICENSE BLOCK *****
62204:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
62204:  *
62204:  * The contents of this file are subject to the Mozilla Public License Version
62204:  * 1.1 (the "License"); you may not use this file except in compliance with
62204:  * the License. You may obtain a copy of the License at
62204:  * http://www.mozilla.org/MPL/
62204:  *
62204:  * Software distributed under the License is distributed on an "AS IS" basis,
62204:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
62204:  * for the specific language governing rights and limitations under the
62204:  * License.
62204:  *
62204:  * The Original Code is Mozilla Corporation code.
62204:  *
62204:  * The Initial Developer of the Original Code is Mozilla Foundation.
62204:  * Portions created by the Initial Developer are Copyright (C) 2009
62204:  * the Initial Developer. All Rights Reserved.
62204:  *
62204:  * Contributor(s):
62204:  *   Bas Schouten <bschouten@mozilla.com>
62204:  *
62204:  * Alternatively, the contents of this file may be used under the terms of
62204:  * either the GNU General Public License Version 2 or later (the "GPL"), or
62204:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
62204:  * in which case the provisions of the GPL or the LGPL are applicable instead
62204:  * of those above. If you wish to allow use of your version of this file only
62204:  * under the terms of either the GPL or the LGPL, and not to allow others to
62204:  * use your version of this file under the terms of the MPL, indicate your
62204:  * decision by deleting the provisions above and replace them with the notice
62204:  * and other provisions required by the GPL or the LGPL. If you do not delete
62204:  * the provisions above, a recipient may use your version of this file under
62204:  * the terms of any one of the MPL, the GPL or the LGPL.
62204:  *
62204:  * ***** END LICENSE BLOCK ***** */
62204: 
62204: #include "ReadbackManagerD3D10.h"
62204: #include "ReadbackProcessor.h"
62204: 
62204: #include "nsIThread.h"
62204: #include "nsThreadUtils.h"
62204: #include "gfxImageSurface.h"
62204: 
62204: namespace mozilla {
62204: namespace layers {
62204: 
62204: // Structure that contains the information required to execute a readback task,
62204: // the only member accessed off the main thread here is mReadbackTexture. Since
62204: // mLayer may be released only on the main thread this object should always be
62204: // destroyed on the main thread!
62204: struct ReadbackTask {
62204:   // The texture that we copied the contents of the thebeslayer to.
62204:   nsRefPtr<ID3D10Texture2D> mReadbackTexture;
62204:   // This exists purely to keep the ReadbackLayer alive for the lifetime of
62204:   // mUpdate. Note that this addref and release should occur -solely- on the
62204:   // main thread.
62204:   nsRefPtr<ReadbackLayer> mLayer;
62204:   ReadbackProcessor::Update mUpdate;
62204:   // The origin in ThebesLayer coordinates of mReadbackTexture.
62204:   gfxPoint mOrigin;
62204:   // mLayer->GetBackgroundOffset() when the task is created.  We have
62204:   // to save this in the ReadbackTask because it might change before
62204:   // the update is delivered to the readback sink.
62204:   nsIntPoint mBackgroundOffset;
62204: };
62204: 
62204: // This class is created and dispatched from the Readback thread but it must be
62204: // destroyed by the main thread.
62204: class ReadbackResultWriter : public nsIRunnable
62204: {
62204:   NS_DECL_ISUPPORTS
62204: public:
62204:   ReadbackResultWriter(ReadbackTask *aTask) : mTask(aTask) {}
62204: 
62204:   NS_IMETHODIMP Run()
62204:   {
62204:     ReadbackProcessor::Update *update = &mTask->mUpdate;
62204: 
62204:     if (!update->mLayer->GetSink()) {
62204:       // This can happen when a plugin is destroyed.
62204:       return NS_OK;
62204:     }
62204: 
62204:     nsIntPoint offset = mTask->mBackgroundOffset;
62204: 
62204:     D3D10_TEXTURE2D_DESC desc;
62204:     mTask->mReadbackTexture->GetDesc(&desc);
62204: 
62204:     D3D10_MAPPED_TEXTURE2D mappedTex;
62204:     // We know this map will immediately succeed, as we've already mapped this
62204:     // copied data on our task thread.
62204:     HRESULT hr = mTask->mReadbackTexture->Map(0, D3D10_MAP_READ, 0, &mappedTex);
62204: 
62204:     if (FAILED(hr)) {
62204:       // If this fails we're never going to get our ThebesLayer content.
62204:       update->mLayer->GetSink()->SetUnknown(update->mSequenceCounter);
62204:       return NS_OK;
62204:     }
62204: 
62204:     nsRefPtr<gfxImageSurface> sourceSurface =
62204:       new gfxImageSurface((unsigned char*)mappedTex.pData,
62204:                           gfxIntSize(desc.Width, desc.Height),
62204:                           mappedTex.RowPitch,
62204:                           gfxASurface::ImageFormatRGB24);
62204: 
62204:     nsRefPtr<gfxContext> ctx =
62204:       update->mLayer->GetSink()->BeginUpdate(update->mUpdateRect + offset,
62204:                                              update->mSequenceCounter);
62204: 
62204:     if (ctx) {
62204:       ctx->Translate(gfxPoint(offset.x, offset.y));
62204:       ctx->SetSource(sourceSurface, gfxPoint(mTask->mOrigin.x,
62204:                                              mTask->mOrigin.y));
62204:       ctx->Paint();
62204: 
62204:       update->mLayer->GetSink()->EndUpdate(ctx, update->mUpdateRect + offset);
62204:     }
62204: 
62204:     mTask->mReadbackTexture->Unmap(0);
62204: 
62204:     return NS_OK;
62204:   }
62204: 
62204: private:
62204:   nsAutoPtr<ReadbackTask> mTask;
62204: };
62204: 
62204: NS_IMPL_THREADSAFE_ISUPPORTS1(ReadbackResultWriter, nsIRunnable)
62204: 
62204: DWORD WINAPI StartTaskThread(void *aManager)
62204: {
62204:   static_cast<ReadbackManagerD3D10*>(aManager)->ProcessTasks();
62204: 
62204:   return 0;
62204: }
62204: 
62204: ReadbackManagerD3D10::ReadbackManagerD3D10()
62204:   : mRefCnt(0)
62204: {
62204:   ::InitializeCriticalSection(&mTaskMutex);
63396:   mShutdownEvent = ::CreateEventA(NULL, FALSE, FALSE, NULL);
63396:   mTaskSemaphore = ::CreateSemaphoreA(NULL, 0, 1000000, NULL);
62204:   mTaskThread = ::CreateThread(NULL, 0, StartTaskThread, this, 0, 0);
62204: }
62204: 
62204: ReadbackManagerD3D10::~ReadbackManagerD3D10()
62204: {
62204:   ::SetEvent(mShutdownEvent);
62204: 
62204:   // This shouldn't take longer than 5 seconds, if it does we're going to choose
62204:   // to leak the thread and its synchronisation in favor of crashing or freezing
62204:   DWORD result = ::WaitForSingleObject(mTaskThread, 5000);
62204:   if (result != WAIT_TIMEOUT) {
62204:     ::DeleteCriticalSection(&mTaskMutex);
62204:     ::CloseHandle(mShutdownEvent);
62204:     ::CloseHandle(mTaskSemaphore);
62204:     ::CloseHandle(mTaskThread);
62204:   } else {
63365:     NS_RUNTIMEABORT("ReadbackManager: Task thread did not shutdown in 5 seconds.");
62204:   }
62204: }
62204: 
62204: void
62204: ReadbackManagerD3D10::PostTask(ID3D10Texture2D *aTexture, void *aUpdate, const gfxPoint &aOrigin)
62204: {
62204:   ReadbackTask *task = new ReadbackTask;
62204:   task->mReadbackTexture = aTexture;
62204:   task->mUpdate = *static_cast<ReadbackProcessor::Update*>(aUpdate);
62204:   task->mOrigin = aOrigin;
62204:   task->mLayer = task->mUpdate.mLayer;
62204:   task->mBackgroundOffset = task->mLayer->GetBackgroundLayerOffset();
62204: 
62204:   ::EnterCriticalSection(&mTaskMutex);
62204:   mPendingReadbackTasks.AppendElement(task);
62204:   ::LeaveCriticalSection(&mTaskMutex);
62204: 
62204:   ::ReleaseSemaphore(mTaskSemaphore, 1, NULL);
62204: }
62204: 
62204: HRESULT
62204: ReadbackManagerD3D10::QueryInterface(REFIID riid, void **ppvObject)
62204: {
62204:   if (!ppvObject) {
62204:     return E_POINTER;
62204:   }
62204: 
62204:   if (riid == IID_IUnknown) {
62204:     *ppvObject = this;
62204:   } else {
62204:     return E_NOINTERFACE;
62204:   }
62204: 
62204:   return S_OK;
62204: }
62204: 
62204: ULONG
62204: ReadbackManagerD3D10::AddRef()
62204: {
62204:   NS_ASSERTION(NS_IsMainThread(),
62204:     "ReadbackManagerD3D10 should only be refcounted on main thread.");
62204:   return ++mRefCnt;
62204: }
62204: 
62204: ULONG
62204: ReadbackManagerD3D10::Release()
62204: {
62204:   NS_ASSERTION(NS_IsMainThread(),
62204:     "ReadbackManagerD3D10 should only be refcounted on main thread.");
62204:   ULONG newRefCnt = --mRefCnt;
62204:   if (!newRefCnt) {
62204:     mRefCnt++;
62204:     delete this;
62204:   }
62204:   return newRefCnt;
62204: }
62204: 
62204: void
62204: ReadbackManagerD3D10::ProcessTasks()
62204: {
62204:   HANDLE handles[] = { mTaskSemaphore, mShutdownEvent };
62204:   
62204:   while (true) {
62204:     DWORD result = ::WaitForMultipleObjects(2, handles, FALSE, INFINITE);
62204:     if (result != WAIT_OBJECT_0) {
62204:       return;
62204:     }
62204: 
62204:     ::EnterCriticalSection(&mTaskMutex);
63365:     if (mPendingReadbackTasks.Length() == 0) {
63365:       NS_RUNTIMEABORT("Trying to read from an empty array, bad bad bad");
63365:     }
62204:     ReadbackTask *nextReadbackTask = mPendingReadbackTasks[0].forget();
62204:     mPendingReadbackTasks.RemoveElementAt(0);
62204:     ::LeaveCriticalSection(&mTaskMutex);
62204: 
62204:     // We want to block here until the texture contents are available, the
62204:     // easiest thing is to simply map and unmap.
62204:     D3D10_MAPPED_TEXTURE2D mappedTex;
62204:     nextReadbackTask->mReadbackTexture->Map(0, D3D10_MAP_READ, 0, &mappedTex);
62204:     nextReadbackTask->mReadbackTexture->Unmap(0);
62204: 
62204:     // We can only send the update to the sink on the main thread, so post an
62204:     // event there to do so. Ownership of the task is passed from
62204:     // mPendingReadbackTasks to ReadbackResultWriter here.
62204:     nsCOMPtr<nsIThread> thread = do_GetMainThread();
62204:     thread->Dispatch(new ReadbackResultWriter(nextReadbackTask),
62204:                      nsIEventTarget::DISPATCH_NORMAL);
62204:   }
62204: }
62204: 
62204: }
62204: }
