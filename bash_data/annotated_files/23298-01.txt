    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date         Modified by     Description of modification
    1:  * 05/03/2000   IBM Corp.       Observer related defines for reflow
    1:  */
    1: 
    1: /* a presentation of a document, part 2 */
    1: 
    1: #ifndef nsIPresShell_h___
    1: #define nsIPresShell_h___
    1: 
    1: #include "nsISupports.h"
    1: #include "nsCoord.h"
    1: #include "nsRect.h"
    1: #include "nsColor.h"
    1: #include "nsEvent.h"
    1: #include "nsCompatibility.h"
    1: #include "nsFrameManagerBase.h"
    1: #include "mozFlushType.h"
    1: #include "nsWeakReference.h"
    1: #include <stdio.h> // for FILE definition
    1: 
    1: class nsIAtom;
    1: class nsIContent;
    1: class nsIContentIterator;
    1: class nsIDocument;
    1: class nsIDocumentObserver;
    1: class nsIFrame;
    1: class nsPresContext;
    1: class nsStyleSet;
    1: class nsIViewManager;
    1: class nsIDeviceContext;
    1: class nsIRenderingContext;
    1: class nsIPageSequenceFrame;
    1: class nsString;
    1: class nsAString;
    1: class nsStringArray;
15969: class nsCaret;
    1: class nsStyleContext;
    1: class nsFrameSelection;
    1: class nsFrameManager;
    1: class nsILayoutHistoryState;
    1: class nsIReflowCallback;
 6939: class nsISupportsArray;
    1: class nsIDOMNode;
    1: class nsIRegion;
    1: class nsIStyleFrameConstruction;
    1: class nsIStyleSheet;
    1: class nsCSSFrameConstructor;
    1: class nsISelection;
    1: template<class E> class nsCOMArray;
    1: class nsWeakFrame;
    1: class nsIScrollableFrame;
    1: class gfxASurface;
 1735: class gfxContext;
    1: 
    1: typedef short SelectionType;
 1158: typedef PRUint32 nsFrameState;
    1: 
23298: // b5bc1dd3-9fd3-4fe7-8311-5dfca55ea371
    1: #define NS_IPRESSHELL_IID \
23298: { 0xb5bc1dd3, 0x9fd3, 0x4fe7, \
23298:   { 0x83, 0x11, 0x5d, 0xfc, 0xa5, 0x5e, 0xa3, 0x71 } }
    1: 
    1: // Constants for ScrollContentIntoView() function
    1: #define NS_PRESSHELL_SCROLL_TOP      0
    1: #define NS_PRESSHELL_SCROLL_BOTTOM   100
    1: #define NS_PRESSHELL_SCROLL_LEFT     0
    1: #define NS_PRESSHELL_SCROLL_RIGHT    100
    1: #define NS_PRESSHELL_SCROLL_CENTER   50
    1: #define NS_PRESSHELL_SCROLL_ANYWHERE -1
    1: #define NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE -2
    1: 
    1: // debug VerifyReflow flags
    1: #define VERIFY_REFLOW_ON              0x01
    1: #define VERIFY_REFLOW_NOISY           0x02
    1: #define VERIFY_REFLOW_ALL             0x04
    1: #define VERIFY_REFLOW_DUMP_COMMANDS   0x08
    1: #define VERIFY_REFLOW_NOISY_RC        0x10
    1: #define VERIFY_REFLOW_REALLY_NOISY_RC 0x20
    1: #define VERIFY_REFLOW_INCLUDE_SPACE_MANAGER 0x40
    1: #define VERIFY_REFLOW_DURING_RESIZE_REFLOW  0x80
    1: 
    1: /**
    1:  * Presentation shell interface. Presentation shells are the
    1:  * controlling point for managing the presentation of a document. The
    1:  * presentation shell holds a live reference to the document, the
    1:  * presentation context, the style manager, the style set and the root
    1:  * frame. <p>
    1:  *
    1:  * When this object is Release'd, it will release the document, the
    1:  * presentation context, the style manager, the style set and the root
    1:  * frame.
    1:  */
    1: 
    1: // hack to make egcs / gcc 2.95.2 happy
    1: class nsIPresShell_base : public nsISupports
    1: {
    1: public:
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IPRESSHELL_IID)
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsIPresShell_base, NS_IPRESSHELL_IID)
    1: 
    1: class nsIPresShell : public nsIPresShell_base
    1: {
    1: public:
    1:   NS_IMETHOD Init(nsIDocument* aDocument,
    1:                   nsPresContext* aPresContext,
    1:                   nsIViewManager* aViewManager,
    1:                   nsStyleSet* aStyleSet,
    1:                   nsCompatibility aCompatMode) = 0;
    1: 
    1:   /**
    1:    * All callers are responsible for calling |Destroy| after calling
    1:    * |EndObservingDocument|.  It needs to be separate only because form
    1:    * controls incorrectly store their data in the frames rather than the
    1:    * content model and printing calls |EndObservingDocument| multiple
    1:    * times to make form controls behave nicely when printed.
    1:    */
    1:   NS_IMETHOD Destroy() = 0;
    1:   
19948:   PRBool IsDestroying() { return mIsDestroying; }
19948: 
    1:   // All frames owned by the shell are allocated from an arena.  They are also recycled
    1:   // using free lists (separate free lists being maintained for each size_t).
    1:   // Methods for recycling frames.
    1:   virtual void* AllocateFrame(size_t aSize) = 0;
    1:   virtual void  FreeFrame(size_t aSize, void* aFreeChunk) = 0;
    1: 
    1:   /**
    1:    * Stack memory allocation:
    1:    *
    1:    * Callers who wish to allocate memory whose lifetime corresponds to
    1:    * the lifetime of a stack-allocated object can use this API.  The
    1:    * caller must use a pair of calls to PushStackMemory and
    1:    * PopStackMemory, such that all stack object lifetimes are either
    1:    * entirely between the calls or containing both calls.
    1:    *
    1:    * Then, between the calls, the caller can call AllocateStackMemory to
    1:    * allocate memory from an arena pool that will be freed by the call
    1:    * to PopStackMemory.
    1:    *
    1:    * The allocations cannot be for more than 4044 bytes.
    1:    */
    1:   virtual void PushStackMemory() = 0;
    1:   virtual void PopStackMemory() = 0;
    1:   virtual void* AllocateStackMemory(size_t aSize) = 0;
    1:   
    1:   nsIDocument* GetDocument() { return mDocument; }
    1: 
    1:   nsPresContext* GetPresContext() { return mPresContext; }
    1: 
    1:   nsIViewManager* GetViewManager() { return mViewManager; }
    1: 
    1: #ifdef _IMPL_NS_LAYOUT
    1:   nsStyleSet*  StyleSet() { return mStyleSet; }
    1: 
    1:   nsCSSFrameConstructor* FrameConstructor()
    1:   {
    1:     return mFrameConstructor;
    1:   }
    1: 
    1:   nsFrameManager* FrameManager() const {
 3233:     return reinterpret_cast<nsFrameManager*>
 3233:                            (&const_cast<nsIPresShell*>(this)->mFrameManager);
    1:   }
    1: 
    1: #endif
    1: 
    1:   /* Enable/disable author style level. Disabling author style disables the entire
    1:    * author level of the cascade, including the HTML preshint level.
    1:    */
    1:   // XXX these could easily be inlined, but there is a circular #include
    1:   // problem with nsStyleSet.
    1:   NS_HIDDEN_(void) SetAuthorStyleDisabled(PRBool aDisabled);
    1:   NS_HIDDEN_(PRBool) GetAuthorStyleDisabled();
    1: 
    1:   /*
    1:    * Called when stylesheets are added/removed/enabled/disabled to rebuild
    1:    * all style data for a given pres shell without necessarily reconstructing
    1:    * all of the frames.  This will not reconstruct style synchronously; if
    1:    * you need to do that, call FlushPendingNotifications to flush out style
    1:    * reresolves.
    1:    * // XXXbz why do we have this on the interface anyway?  The only consumer
    1:    * is calling AddOverrideStyleSheet/RemoveOverrideStyleSheet, and I think
    1:    * those should just handle reconstructing style data...
    1:    */
    1:   virtual NS_HIDDEN_(void) ReconstructStyleDataExternal();
    1:   NS_HIDDEN_(void) ReconstructStyleDataInternal();
    1: #ifdef _IMPL_NS_LAYOUT
    1:   void ReconstructStyleData() { ReconstructStyleDataInternal(); }
    1: #else
    1:   void ReconstructStyleData() { ReconstructStyleDataExternal(); }
    1: #endif
    1: 
    1:   /** Setup all style rules required to implement preferences
    1:    * - used for background/text/link colors and link underlining
    1:    *    may be extended for any prefs that are implemented via style rules
    1:    * - aForceReflow argument is used to force a full reframe to make the rules show
    1:    *   (only used when the current page needs to reflect changed pref rules)
    1:    *
    1:    * - initially created for bugs 31816, 20760, 22963
    1:    */
    1:   NS_IMETHOD SetPreferenceStyleRules(PRBool aForceReflow) = 0;
    1: 
    1:   /**
    1:    * FrameSelection will return the Frame based selection API.
    1:    * You cannot go back and forth anymore with QI between nsIDOM sel and
    1:    * nsIFrame sel.
    1:    */
 8295:   already_AddRefed<nsFrameSelection> FrameSelection();
 8295: 
 8295:   /**
 8295:    * ConstFrameSelection returns an object which methods are safe to use for
 8295:    * example in nsIFrame code.
 8295:    */
 8295:   const nsFrameSelection* ConstFrameSelection() { return mSelection; }
    1: 
 1416:   // Make shell be a document observer.  If called after Destroy() has
 1416:   // been called on the shell, this will be ignored.
    1:   NS_IMETHOD BeginObservingDocument() = 0;
    1: 
    1:   // Make shell stop being a document observer
    1:   NS_IMETHOD EndObservingDocument() = 0;
    1: 
    1:   /**
23164:    * Return whether InitialReflow() was previously called.
    1:    */
23164:   PRBool DidInitialReflow() const { return mDidInitialReflow; }
    1: 
    1:   /**
    1:    * Perform the initial reflow. Constructs the frame for the root content
    1:    * object and then reflows the frame model into the specified width and
    1:    * height.
    1:    *
 1416:    * The coordinates for aWidth and aHeight must be in standard nscoords.
 1416:    *
 1416:    * Callers of this method must hold a reference to this shell that
 1416:    * is guaranteed to survive through arbitrary script execution.
 1416:    * Calling InitialReflow can execute arbitrary script.
    1:    */
    1:   NS_IMETHOD InitialReflow(nscoord aWidth, nscoord aHeight) = 0;
    1: 
    1:   /**
    1:    * Reflow the frame model into a new width and height.  The
    1:    * coordinates for aWidth and aHeight must be in standard nscoord's.
    1:    */
    1:   NS_IMETHOD ResizeReflow(nscoord aWidth, nscoord aHeight) = 0;
    1: 
    1:   /**
    1:    * Reflow the frame model with a reflow reason of eReflowReason_StyleChange
    1:    */
    1:   NS_IMETHOD StyleChangeReflow() = 0;
    1: 
    1:   /**
    1:    * This calls through to the frame manager to get the root frame.
    1:    * Callers inside of gklayout should use FrameManager()->GetRootFrame()
    1:    * instead, as it's more efficient.
    1:    */
    1:   virtual NS_HIDDEN_(nsIFrame*) GetRootFrame() const;
    1: 
    1:   /*
    1:    * Get root scroll frame from FrameManager()->GetRootFrame().
    1:    */
    1:   nsIFrame* GetRootScrollFrame() const;
    1: 
    1:   /*
    1:    * The same as GetRootScrollFrame, but returns an nsIScrollableFrame
    1:    */
    1:   nsIScrollableFrame* GetRootScrollFrameAsScrollable() const;
    1: 
    1:   /**
    1:    * Returns the page sequence frame associated with the frame hierarchy.
    1:    * Returns NULL if not a paginated view.
    1:    */
    1:   NS_IMETHOD GetPageSequenceFrame(nsIPageSequenceFrame** aResult) const = 0;
    1: 
    1:   /**
    1:    * Gets the primary frame associated with the content object. This is a
    1:    * helper function that just forwards the request to the frame manager.
    1:    *
    1:    * The primary frame is the frame that is most closely associated with the
    1:    * content. A frame is more closely associated with the content that another
    1:    * frame if the one frame contains directly or indirectly the other frame (e.g.,
    1:    * when a frame is scrolled there is a scroll frame that contains the frame
    1:    * being scrolled). The primary frame is always the first-in-flow.
    1:    *
    1:    * In the case of absolutely positioned elements and floated elements,
10998:    * the primary frame is the placeholder frame.
10998:    */
10998:   virtual NS_HIDDEN_(nsIFrame*) GetPrimaryFrameFor(nsIContent* aContent) const = 0;
10998: 
10998:   /**
10998:    * Gets the real primary frame associated with the content object.
10998:    *
10998:    * In the case of absolutely positioned elements and floated elements,
10998:    * the real primary frame is the frame that is out of the flow and not the
    1:    * placeholder frame.
    1:    */
10998:   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const = 0;
    1: 
    1:   /**
    1:    * Gets the placeholder frame associated with the specified frame. This is
    1:    * a helper frame that forwards the request to the frame manager.
    1:    */
    1:   NS_IMETHOD GetPlaceholderFrameFor(nsIFrame*  aFrame,
    1:                                     nsIFrame** aPlaceholderFrame) const = 0;
    1: 
    1:   /**
 1158:    * Tell the pres shell that a frame needs to be marked dirty and needs
 1158:    * Reflow.  It's OK if this is an ancestor of the frame needing reflow as
 1158:    * long as the ancestor chain between them doesn't cross a reflow root.  The
 1205:    * bit to add should be either NS_FRAME_IS_DIRTY or
 1161:    * NS_FRAME_HAS_DIRTY_CHILDREN (but not both!).
    1:    */
    1:   enum IntrinsicDirty {
    1:     // XXXldb eResize should be renamed
    1:     eResize,     // don't mark any intrinsic widths dirty
    1:     eTreeChange, // mark intrinsic widths dirty on aFrame and its ancestors
    1:     eStyleChange // Do eTreeChange, plus all of aFrame's descendants
    1:   };
    1:   NS_IMETHOD FrameNeedsReflow(nsIFrame *aFrame,
 1158:                               IntrinsicDirty aIntrinsicDirty,
 1161:                               nsFrameState aBitToAdd) = 0;
    1: 
    1:   NS_IMETHOD CancelAllPendingReflows() = 0;
    1: 
    1:   /**
    1:    * Recreates the frames for a node
    1:    */
    1:   NS_IMETHOD RecreateFramesFor(nsIContent* aContent) = 0;
    1: 
15538:   void PostRecreateFramesFor(nsIContent* aContent);
15538:   
    1:   /**
    1:    * Determine if it is safe to flush all pending notifications
    1:    * @param aIsSafeToFlush PR_TRUE if it is safe, PR_FALSE otherwise.
    1:    * 
    1:    */
    1:   NS_IMETHOD IsSafeToFlush(PRBool& aIsSafeToFlush) = 0;
    1: 
    1:   /**
    1:    * Flush pending notifications of the type specified.  This method
    1:    * will not affect the content model; it'll just affect style and
    1:    * frames. Callers that actually want up-to-date presentation (other
    1:    * than the document itself) should probably be calling
    1:    * nsIDocument::FlushPendingNotifications.
    1:    *
    1:    * @param aType the type of notifications to flush
    1:    */
    1:   NS_IMETHOD FlushPendingNotifications(mozFlushType aType) = 0;
    1: 
    1:   /**
    1:    * Callbacks will be called even if reflow itself fails for
    1:    * some reason.
    1:    */
    1:   NS_IMETHOD PostReflowCallback(nsIReflowCallback* aCallback) = 0;
    1:   NS_IMETHOD CancelReflowCallback(nsIReflowCallback* aCallback) = 0;
    1: 
    1:   NS_IMETHOD ClearFrameRefs(nsIFrame* aFrame) = 0;
    1: 
    1:   /**
    1:    * Given a frame, create a rendering context suitable for use with
    1:    * the frame.
    1:    */
    1:   NS_IMETHOD CreateRenderingContext(nsIFrame *aFrame,
    1:                                     nsIRenderingContext** aContext) = 0;
    1: 
    1:   /**
    1:    * Informs the pres shell that the document is now at the anchor with
    1:    * the given name.  If |aScroll| is true, scrolls the view of the
    1:    * document so that the anchor with the specified name is displayed at
    1:    * the top of the window.  If |aAnchorName| is empty, then this informs
    1:    * the pres shell that there is no current target, and |aScroll| must
    1:    * be false.
    1:    */
    1:   NS_IMETHOD GoToAnchor(const nsAString& aAnchorName, PRBool aScroll) = 0;
    1: 
    1:   /**
12356:    * Tells the presshell to scroll again to the last anchor scrolled to by
12356:    * GoToAnchor, if any. This scroll only happens if the scroll
12356:    * position has not changed since the last GoToAnchor. This is called
12356:    * by nsDocumentViewer::LoadComplete. This clears the last anchor
12356:    * scrolled to by GoToAnchor (we don't want to keep it alive if it's
12356:    * removed from the DOM), so don't call this more than once.
12356:    */
12356:   NS_IMETHOD ScrollToAnchor() = 0;
12356: 
12356:   /**
    1:    * Scrolls the view of the document so that the primary frame of the content
    1:    * is displayed at the top of the window. Layout is flushed before scrolling.
    1:    *
    1:    * @param aContent  The content object of which primary frame should be
    1:    *                  scrolled into view.
    1:    * @param aVPercent How to align the frame vertically. A value of 0
    1:    *                  (NS_PRESSHELL_SCROLL_TOP) means the frame's upper edge is
    1:    *                  aligned with the top edge of the visible area. A value of
    1:    *                  100 (NS_PRESSHELL_SCROLL_BOTTOM) means the frame's bottom
    1:    *                  edge is aligned with the bottom edge of the visible area.
    1:    *                  For values in between, the point "aVPercent" down the frame
    1:    *                  is placed at the point "aVPercent" down the visible area. A
    1:    *                  value of 50 (NS_PRESSHELL_SCROLL_CENTER) centers the frame
    1:    *                  vertically. A value of NS_PRESSHELL_SCROLL_ANYWHERE means move
    1:    *                  the frame the minimum amount necessary in order for the entire
    1:    *                  frame to be visible vertically (if possible)
    1:    * @param aHPercent How to align the frame horizontally. A value of 0
    1:    *                  (NS_PRESSHELL_SCROLL_LEFT) means the frame's left edge is
    1:    *                  aligned with the left edge of the visible area. A value of
    1:    *                  100 (NS_PRESSHELL_SCROLL_RIGHT) means the frame's right
    1:    *                  edge is aligned with the right edge of the visible area.
    1:    *                  For values in between, the point "aVPercent" across the frame
    1:    *                  is placed at the point "aVPercent" across the visible area.
    1:    *                  A value of 50 (NS_PRESSHELL_SCROLL_CENTER) centers the frame
    1:    *                  horizontally . A value of NS_PRESSHELL_SCROLL_ANYWHERE means move
    1:    *                  the frame the minimum amount necessary in order for the entire
    1:    *                  frame to be visible horizontally (if possible)
    1:    */
    1:   NS_IMETHOD ScrollContentIntoView(nsIContent* aContent,
    1:                                    PRIntn      aVPercent,
    1:                                    PRIntn      aHPercent) const = 0;
    1: 
    1:   /**
    1:    * Suppress notification of the frame manager that frames are
    1:    * being destroyed.
    1:    */
    1:   NS_IMETHOD SetIgnoreFrameDestruction(PRBool aIgnore) = 0;
    1: 
    1:   /**
    1:    * Notification sent by a frame informing the pres shell that it is about to
    1:    * be destroyed.
    1:    * This allows any outstanding references to the frame to be cleaned up
    1:    */
    1:   NS_IMETHOD NotifyDestroyingFrame(nsIFrame* aFrame) = 0;
    1: 
    1:   /**
    1:    * Notify the Clipboard that we have something to copy.
    1:    */
    1:   NS_IMETHOD DoCopy() = 0;
    1: 
    1:   /**
    1:    * Get the selection of the focussed element (either the page selection,
    1:    * or the selection for a text field).
    1:    */
    1:   NS_IMETHOD GetSelectionForCopy(nsISelection** outSelection) = 0;
    1: 
    1:   /**
    1:    * Get link location.
    1:    */
    1:   NS_IMETHOD GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocation) = 0;
    1: 
    1:   /**
    1:    * Get the doc or the selection as text or html.
    1:    */
    1:   NS_IMETHOD DoGetContents(const nsACString& aMimeType, PRUint32 aFlags, PRBool aSelectionOnly, nsAString& outValue) = 0;
    1: 
    1:   /**
    1:    * Get the caret, if it exists. AddRefs it.
    1:    */
15969:   NS_IMETHOD GetCaret(nsCaret **aOutCaret) = 0;
    1: 
    1:   /**
    1:    * Invalidate the caret's current position if it's outside of its frame's
    1:    * boundaries. This function is useful if you're batching selection
    1:    * notifications and might remove the caret's frame out from under it.
    1:    */
    1:   NS_IMETHOD_(void) MaybeInvalidateCaretPosition() = 0;
    1: 
    1:   /**
 6232:    * Set the current caret to a new caret. To undo this, call RestoreCaret.
    1:    */
15969:   virtual void SetCaret(nsCaret *aNewCaret) = 0;
 6232: 
 6232:   /**
 6232:    * Restore the caret to the original caret that this pres shell was created
 6232:    * with.
 6232:    */
 6232:   virtual void RestoreCaret() = 0;
    1: 
    1:   /**
    1:    * Should the images have borders etc.  Actual visual effects are determined
    1:    * by the frames.  Visual effects may not effect layout, only display.
    1:    * Takes effect on next repaint, does not force a repaint itself.
    1:    *
    1:    * @param aEnabled  if PR_TRUE, visual selection effects are enabled
    1:    *                  if PR_FALSE visual selection effects are disabled
    1:    * @return  always NS_OK
    1:    */
    1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable) = 0;
    1: 
    1:   /** 
    1:     * Gets the current state of non text selection effects
    1:     * @param aEnabled  [OUT] set to the current state of non text selection,
    1:     *                  as set by SetDisplayNonTextSelection
    1:     * @return   if aOutEnabled==null, returns NS_ERROR_INVALID_ARG
    1:     *           else NS_OK
    1:     */
    1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnabled) = 0;
    1:   
    1:   virtual nsISelection* GetCurrentSelection(SelectionType aType) = 0;
    1: 
    1:   /**
    1:     * Interface to dispatch events via the presshell
   95:     * @note The caller must have a strong reference to the PresShell.
    1:     */
    1:   NS_IMETHOD HandleEventWithTarget(nsEvent* aEvent,
    1:                                    nsIFrame* aFrame,
    1:                                    nsIContent* aContent,
    1:                                    nsEventStatus* aStatus) = 0;
    1: 
    1:   /**
    1:    * Dispatch event to content only (NOT full processing)
   95:    * @note The caller must have a strong reference to the PresShell.
    1:    */
    1:   NS_IMETHOD HandleDOMEventWithTarget(nsIContent* aTargetContent,
    1:                                       nsEvent* aEvent,
    1:                                       nsEventStatus* aStatus) = 0;
    1: 
    1:   /**
    1:     * Gets the current target event frame from the PresShell
    1:     */
    1:   NS_IMETHOD GetEventTargetFrame(nsIFrame** aFrame) = 0;
    1: 
    1:   /**
    1:     * Gets the current target event frame from the PresShell
    1:     */
    1:   NS_IMETHOD GetEventTargetContent(nsEvent* aEvent, nsIContent** aContent) = 0;
    1: 
    1:   /**
    1:    * Get and set the history state for the current document 
    1:    */
    1: 
    1:   NS_IMETHOD CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState, PRBool aLeavingPage = PR_FALSE) = 0;
    1: 
    1:   /**
    1:    * Determine if reflow is currently locked
    1:    * @param aIsReflowLocked returns PR_TRUE if reflow is locked, PR_FALSE otherwise
    1:    */
    1:   NS_IMETHOD IsReflowLocked(PRBool* aIsLocked) = 0;  
    1: 
    1:   /**
    1:    * Called to find out if painting is suppressed for this presshell.  If it is suppressd,
    1:    * we don't allow the painting of any layer but the background, and we don't
    1:    * recur into our children.
    1:    */
    1:   NS_IMETHOD IsPaintingSuppressed(PRBool* aResult)=0;
    1: 
    1:   /**
    1:    * Unsuppress painting.
    1:    */
    1:   NS_IMETHOD UnsuppressPainting() = 0;
    1: 
    1:   /**
    1:    * Called to disable nsITheme support in a specific presshell.
    1:    */
    1:   NS_IMETHOD DisableThemeSupport() = 0;
    1: 
    1:   /**
    1:    * Indicates whether theme support is enabled.
    1:    */
    1:   virtual PRBool IsThemeSupportEnabled() = 0;
    1: 
    1:   /**
    1:    * Get the set of agent style sheets for this presentation
    1:    */
    1:   virtual nsresult GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets) = 0;
    1: 
    1:   /**
    1:    * Replace the set of agent style sheets
    1:    */
    1:   virtual nsresult SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets) = 0;
    1: 
    1:   /**
    1:    * Add an override style sheet for this presentation
    1:    */
    1:   virtual nsresult AddOverrideStyleSheet(nsIStyleSheet *aSheet) = 0;
    1: 
    1:   /**
    1:    * Remove an override style sheet
    1:    */
    1:   virtual nsresult RemoveOverrideStyleSheet(nsIStyleSheet *aSheet) = 0;
    1: 
    1:   /**
    1:    * Reconstruct frames for all elements in the document
    1:    */
    1:   virtual nsresult ReconstructFrames() = 0;
    1: 
    1:   /**
 5680:    * Given aFrame, the root frame of a stacking context, find its descendant
 5680:    * frame under the point aPt that receives a mouse event at that location,
 5680:    * or nsnull if there is no such frame.
 5680:    * @param aPt the point, relative to the frame origin
 5680:    */
 5680:   virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt) = 0;
 5680: 
 5680:   /**
    1:    * See if reflow verification is enabled. To enable reflow verification add
    1:    * "verifyreflow:1" to your NSPR_LOG_MODULES environment variable
    1:    * (any non-zero debug level will work). Or, call SetVerifyReflowEnable
    1:    * with PR_TRUE.
    1:    */
    1:   static PRBool GetVerifyReflowEnable();
    1: 
    1:   /**
    1:    * Set the verify-reflow enable flag.
    1:    */
    1:   static void SetVerifyReflowEnable(PRBool aEnabled);
    1: 
    1:   /**
    1:    * Get the flags associated with the VerifyReflow debug tool
    1:    */
    1:   static PRInt32 GetVerifyReflowFlags();
    1: 
10522:   virtual nsIFrame* GetAbsoluteContainingBlock(nsIFrame* aFrame);
10522: 
    1: #ifdef MOZ_REFLOW_PERF
    1:   NS_IMETHOD DumpReflows() = 0;
    1:   NS_IMETHOD CountReflows(const char * aName, nsIFrame * aFrame) = 0;
    1:   NS_IMETHOD PaintCount(const char * aName, 
    1:                         nsIRenderingContext* aRenderingContext, 
    1:                         nsPresContext * aPresContext, 
    1:                         nsIFrame * aFrame,
    1:                         PRUint32 aColor) = 0;
    1:   NS_IMETHOD SetPaintFrameCount(PRBool aOn) = 0;
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   // Debugging hooks
    1:   virtual void ListStyleContexts(nsIFrame *aRootFrame, FILE *out,
    1:                                  PRInt32 aIndent = 0) = 0;
    1: 
    1:   virtual void ListStyleSheets(FILE *out, PRInt32 aIndent = 0) = 0;
    1:   virtual void VerifyStyleTree() = 0;
    1: #endif
    1: 
 1071:   static PRBool gIsAccessibilityActive;
 1071:   static PRBool IsAccessibilityActive() { return gIsAccessibilityActive; }
    1: 
    1:   /**
    1:    * Stop all active elements (plugins and the caret) in this presentation and
    1:    * in the presentations of subdocuments.  Resets painting to a suppressed state.
    1:    * XXX this should include image animations
    1:    */
    1:   virtual void Freeze() = 0;
    1: 
    1:   /**
    1:    * Restarts active elements (plugins) in this presentation and in the
    1:    * presentations of subdocuments, then do a full invalidate of the content area.
    1:    */
    1:   virtual void Thaw() = 0;
    1: 
    1:   /**
    1:    * When this shell is disconnected from its containing docshell, we
    1:    * lose our container pointer.  However, we'd still like to be able to target
    1:    * user events at the docshell's parent.  This pointer allows us to do that.
    1:    * It should not be used for any other purpose.
    1:    */
    1:   void SetForwardingContainer(nsWeakPtr aContainer)
    1:   {
    1:     mForwardingContainer = aContainer;
    1:   }
    1:   
    1:   /**
 1735:    * Render the document into an arbitrary gfxContext
 1735:    * Designed for getting a picture of a document or a piece of a document
 1735:    * Note that callers will generally want to call FlushPendingNotifications
 1735:    * to get an up-to-date view of the document
    1:    * @param aRect is the region to capture into the offscreen buffer, in the
    1:    * root frame's coordinate system (if aIgnoreViewportScrolling is false)
    1:    * or in the root scrolled frame's coordinate system
 7683:    * (if aIgnoreViewportScrolling is true). The coordinates are in appunits.
22950:    * @param aFlags see below;
22950:    *   set RENDER_IS_UNTRUSTED if the contents may be passed to malicious
    1:    * agents. E.g. we might choose not to paint the contents of sensitive widgets
    1:    * such as the file name in a file upload widget, and we might choose not
    1:    * to paint themes.
22950:    *   set RENDER_IGNORE_VIEWPORT_SCROLLING to ignore
22950:    * clipping/scrolling/scrollbar painting due to scrolling in the viewport
22950:    *   set RENDER_CARET to draw the caret if one would be visible
22950:    * (by default the caret is never drawn)
    1:    * @param aBackgroundColor a background color to render onto
 7683:    * @param aRenderedContext the gfxContext to render to. We render so that
 7683:    * one CSS pixel in the source document is rendered to one unit in the current
 7683:    * transform.
    1:    */
22950:   enum {
22950:     RENDER_IS_UNTRUSTED = 0x01,
22950:     RENDER_IGNORE_VIEWPORT_SCROLLING = 0x02,
22950:     RENDER_CARET = 0x04
22950:   };
22950:   NS_IMETHOD RenderDocument(const nsRect& aRect, PRUint32 aFlags,
    1:                             nscolor aBackgroundColor,
 1735:                             gfxContext* aRenderedContext) = 0;
    1: 
    1:   /**
    1:    * Renders a node aNode to a surface and returns it. The aRegion may be used
    1:    * to clip the rendering. This region is measured in device pixels from the
    1:    * edge of the presshell area. The aPoint, aScreenRect and aSurface
    1:    * arguments function in a similar manner as RenderSelection.
    1:    */
    1:   virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
    1:                                                    nsIRegion* aRegion,
19835:                                                    nsPoint& aPoint,
19835:                                                    nsRect* aScreenRect) = 0;
    1: 
    1:   /*
    1:    * Renders a selection to a surface and returns it. This method is primarily
    1:    * intended to create the drag feedback when dragging a selection.
    1:    *
    1:    * aScreenRect will be filled in with the bounding rectangle of the
    1:    * selection area on screen.
    1:    *
    1:    * If the area of the selection is large, the image will be scaled down.
    1:    * The argument aPoint is used in this case as a reference point when
    1:    * determining the new screen rectangle after scaling. Typically, this
    1:    * will be the mouse position, so that the screen rectangle is positioned
    1:    * such that the mouse is over the same point in the scaled image as in
    1:    * the original. When scaling does not occur, the mouse point isn't used
    1:    * as the position can be determined from the displayed frames.
    1:    */
    1:   virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
19835:                                                         nsPoint& aPoint,
19835:                                                         nsRect* aScreenRect) = 0;
    1: 
    1:   void AddWeakFrame(nsWeakFrame* aWeakFrame);
    1:   void RemoveWeakFrame(nsWeakFrame* aWeakFrame);
    1: 
    1: #ifdef NS_DEBUG
    1:   nsIFrame* GetDrawEventTargetFrame() { return mDrawEventTargetFrame; }
    1: #endif
    1: 
    1: protected:
    1:   // IMPORTANT: The ownership implicit in the following member variables
    1:   // has been explicitly checked.  If you add any members to this class,
    1:   // please make the ownership explicit (pinkerton, scc).
    1: 
    1:   // these are the same Document and PresContext owned by the DocViewer.
    1:   // we must share ownership.
    1:   nsIDocument*              mDocument;      // [STRONG]
    1:   nsPresContext*            mPresContext;   // [STRONG]
    1:   nsStyleSet*               mStyleSet;      // [OWNS]
    1:   nsCSSFrameConstructor*    mFrameConstructor; // [OWNS]
    1:   nsIViewManager*           mViewManager;   // [WEAK] docViewer owns it so I don't have to
    1:   nsFrameSelection*         mSelection;
    1:   nsFrameManagerBase        mFrameManager;  // [OWNS]
    1:   nsWeakPtr                 mForwardingContainer;
    1: 
    1: #ifdef NS_DEBUG
    1:   nsIFrame*                 mDrawEventTargetFrame;
    1: #endif
    1: 
    1:   PRPackedBool              mStylesHaveChanged;
    1:   PRPackedBool              mDidInitialReflow;
    1:   PRPackedBool              mIsDestroying;
    1: 
    1: #ifdef ACCESSIBILITY
    1:   /**
    1:    * Call this when there have been significant changes in the rendering for
    1:    * a content subtree, so the matching accessibility subtree can be invalidated
    1:    */
    1:   void InvalidateAccessibleSubtree(nsIContent *aContent);
    1: #endif
    1: 
    1:   // Set to true when the accessibility service is being used to mirror
    1:   // the dom/layout trees
    1:   PRPackedBool              mIsAccessibilityActive;
    1: 
    1:   // A list of weak frames. This is a pointer to the last item in the list.
    1:   nsWeakFrame*              mWeakFrames;
    1: };
    1: 
    1: /**
    1:  * Create a new empty presentation shell. Upon success, call Init
    1:  * before attempting to use the shell.
    1:  */
    1: nsresult
    1: NS_NewPresShell(nsIPresShell** aInstancePtrResult);
    1: 
    1: #endif /* nsIPresShell_h___ */
