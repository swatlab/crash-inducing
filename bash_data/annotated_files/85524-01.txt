19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *   Josh Aas <josh@mozilla.com>
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
41059: #ifdef MOZ_WIDGET_QT
41059: #include <QX11Info>
41059: #endif
41059: 
36001: #include "base/basictypes.h"
36001: 
80467: /* This must occur *after* layers/PLayers.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
19246: #include "prtypes.h"
19246: #include "prmem.h"
35740: #include "prenv.h"
19246: #include "prclist.h"
38922: 
80748: #include "jscntxt.h"
79734: #include "jsfriendapi.h"
38922: 
70185: #include "nsPluginHost.h"
19246: #include "nsNPAPIPlugin.h"
19246: #include "nsNPAPIPluginInstance.h"
19246: #include "nsNPAPIPluginStreamListener.h"
19246: #include "nsIServiceManager.h"
19246: #include "nsThreadUtils.h"
24475: #include "nsIPrivateBrowsingService.h"
19246: 
19246: #include "nsIPluginStreamListener.h"
19246: #include "nsPluginsDir.h"
19246: #include "nsPluginSafety.h"
19246: #include "nsIPrefService.h"
19246: #include "nsIPrefBranch.h"
19246: #include "nsPluginLogging.h"
19246: 
19246: #include "nsIJSContextStack.h"
19246: 
19246: #include "nsIDOMElement.h"
19246: #include "nsIDOMDocument.h"
19246: #include "nsPIDOMWindow.h"
19246: #include "nsIDocument.h"
78254: #include "nsIContent.h"
19246: #include "nsIScriptGlobalObject.h"
19246: #include "nsIScriptContext.h"
78254: #include "nsIUnicodeNormalizer.h"
19246: #include "nsDOMJSUtils.h"
19246: #include "nsIPrincipal.h"
50621: #include "nsWildCard.h"
78254: #include "nsContentUtils.h"
19246: 
19246: #include "nsIXPConnect.h"
19246: 
19246: #include "nsIObserverService.h"
19246: #include <prinrval.h>
19246: 
72514: #ifdef MOZ_WIDGET_COCOA
19246: #include <Carbon/Carbon.h>
41147: #include <ApplicationServices/ApplicationServices.h>
41147: #include <OpenGL/OpenGL.h>
85524: #include "nsCocoaFeatures.h"
19246: #endif
19246: 
19246: // needed for nppdf plugin
19246: #ifdef MOZ_WIDGET_GTK2
19246: #include <gdk/gdk.h>
19246: #include <gdk/gdkx.h>
19246: #include "gtk2xtbin.h"
19246: #endif
19246: 
32955: #ifdef XP_OS2
32955: #define INCL_DOS
32955: #define INCL_DOSERRORS
32955: #include <os2.h>
32955: #endif
32955: 
19246: #include "nsJSNPRuntime.h"
23571: #include "nsIHttpAuthManager.h"
23571: #include "nsICookieService.h"
19246: 
57925: #include "nsNetUtil.h"
57925: 
64576: #include "mozilla/Mutex.h"
36010: #include "mozilla/PluginLibrary.h"
36010: using mozilla::PluginLibrary;
36010: 
36010: #include "mozilla/PluginPRLibrary.h"
36010: using mozilla::PluginPRLibrary;
35802: 
35893: #include "mozilla/plugins/PluginModuleParent.h"
35893: using mozilla::plugins::PluginModuleParent;
35740: 
43912: #ifdef MOZ_X11
43912: #include "mozilla/X11Util.h"
43912: #endif
43912: 
62857: #ifdef XP_WIN
62857: #include <windows.h>
62857: #endif
62857: 
82142: #ifdef MOZ_WIDGET_ANDROID
78424: #include "ANPBase.h"
78424: #include "AndroidBridge.h"
78424: #include <android/log.h>
78424: #define LOG(args...)  __android_log_print(ANDROID_LOG_INFO, "GeckoPlugins" , ## args)
78424: #endif
78424: 
64576: using namespace mozilla;
39850: using namespace mozilla::plugins::parent;
39850: 
39850: // We should make this const...
39850: static NPNetscapeFuncs sBrowserFuncs = {
39850:   sizeof(sBrowserFuncs),
39850:   (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR,
39850:   _geturl,
39850:   _posturl,
39850:   _requestread,
39850:   _newstream,
39850:   _write,
39850:   _destroystream,
39850:   _status,
39850:   _useragent,
39850:   _memalloc,
39850:   _memfree,
39850:   _memflush,
39850:   _reloadplugins,
39850:   _getJavaEnv,
39850:   _getJavaPeer,
39850:   _geturlnotify,
39850:   _posturlnotify,
39850:   _getvalue,
39850:   _setvalue,
39850:   _invalidaterect,
39850:   _invalidateregion,
39850:   _forceredraw,
39850:   _getstringidentifier,
39850:   _getstringidentifiers,
39850:   _getintidentifier,
39850:   _identifierisstring,
39850:   _utf8fromidentifier,
39850:   _intfromidentifier,
39850:   _createobject,
39850:   _retainobject,
39850:   _releaseobject,
39850:   _invoke,
39850:   _invokeDefault,
39850:   _evaluate,
39850:   _getproperty,
39850:   _setproperty,
39850:   _removeproperty,
39850:   _hasproperty,
39850:   _hasmethod,
39850:   _releasevariantvalue,
39850:   _setexception,
39850:   _pushpopupsenabledstate,
39850:   _poppopupsenabledstate,
39850:   _enumerate,
39850:   _pluginthreadasynccall,
39850:   _construct,
39850:   _getvalueforurl,
39850:   _setvalueforurl,
39850:   _getauthenticationinfo,
39850:   _scheduletimer,
39850:   _unscheduletimer,
39850:   _popupcontextmenu,
57157:   _convertpoint,
57157:   NULL, // handleevent, unimplemented
57157:   NULL, // unfocusinstance, unimplemented
60021:   _urlredirectresponse
39850: };
39850: 
64576: static Mutex *sPluginThreadAsyncCallLock = nsnull;
19246: static PRCList sPendingAsyncCalls = PR_INIT_STATIC_CLIST(&sPendingAsyncCalls);
19246: 
19246: // POST/GET stream type
19246: enum eNPPStreamTypeInternal {
19246:   eNPPStreamTypeInternal_Get,
19246:   eNPPStreamTypeInternal_Post
19246: };
19246: 
19246: static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
19246: 
19246: // This function sends a notification using the observer service to any object
19246: // registered to listen to the "experimental-notify-plugin-call" subject.
19246: // Each "experimental-notify-plugin-call" notification carries with it the run
19246: // time value in milliseconds that the call took to execute.
19246: void NS_NotifyPluginCall(PRIntervalTime startTime) 
19246: {
19246:   PRIntervalTime endTime = PR_IntervalNow() - startTime;
19246:   nsCOMPtr<nsIObserverService> notifyUIService =
41540:     mozilla::services::GetObserverService();
28733:   if (!notifyUIService)
28733:     return;
28733: 
19246:   float runTimeInSeconds = float(endTime) / PR_TicksPerSecond();
19246:   nsAutoString runTimeString;
19246:   runTimeString.AppendFloat(runTimeInSeconds);
19246:   const PRUnichar* runTime = runTimeString.get();
19246:   notifyUIService->NotifyObservers(nsnull, "experimental-notify-plugin-call",
19246:                                    runTime);
19246: }
19246: 
40564: static void CheckClassInitialized()
19246: {
79445:   static bool initialized = false;
19246: 
19246:   if (initialized)
19246:     return;
19246: 
20125:   if (!sPluginThreadAsyncCallLock)
64576:     sPluginThreadAsyncCallLock = new Mutex("nsNPAPIPlugin.sPluginThreadAsyncCallLock");
19246: 
79533:   initialized = true;
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN callbacks initialized\n"));
19246: }
19246: 
69716: NS_IMPL_ISUPPORTS0(nsNPAPIPlugin)
19246: 
40564: nsNPAPIPlugin::nsNPAPIPlugin()
19246: {
37780:   memset((void*)&mPluginFuncs, 0, sizeof(mPluginFuncs));
37780:   mPluginFuncs.size = sizeof(mPluginFuncs);
58535:   mPluginFuncs.version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
40564: 
37780:   mLibrary = nsnull;
19246: }
19246: 
30212: nsNPAPIPlugin::~nsNPAPIPlugin()
19246: {
37780:   delete mLibrary;
40564:   mLibrary = nsnull;
19246: }
19246: 
36304: void
39794: nsNPAPIPlugin::PluginCrashed(const nsAString& pluginDumpID,
39794:                              const nsAString& browserDumpID)
36304: {
36304:   nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
39794:   host->PluginCrashed(this, pluginDumpID, browserDumpID);
36304: }
35811: 
62890: #if defined(XP_MACOSX) && defined(__i386__)
40205: static PRInt32 OSXVersion()
40205: {
40205:   static PRInt32 gOSXVersion = 0x0;
40205:   if (gOSXVersion == 0x0) {
40205:     OSErr err = ::Gestalt(gestaltSystemVersion, (SInt32*)&gOSXVersion);
40205:     if (err != noErr) {
40205:       // This should probably be changed when our minimum version changes
40205:       NS_ERROR("Couldn't determine OS X version, assuming 10.5");
40205:       gOSXVersion = 0x00001050;
40205:     }
40205:   }
40205:   return gOSXVersion;
40205: }
41147: 
41147: // Detects machines with Intel GMA9xx GPUs.
41147: // kCGLRendererIDMatchingMask and kCGLRendererIntel900ID are only defined in the 10.6 SDK.
41147: #define CGLRendererIDMatchingMask 0x00FE7F00
41147: #define CGLRendererIntel900ID 0x00024000
79445: static bool GMA9XXGraphics()
41147: {
79533:   bool hasIntelGMA9XX = false;
41147:   CGLRendererInfoObj renderer = 0;
41147:   GLint rendererCount = 0;
41147:   if (::CGLQueryRendererInfo(0xffffffff, &renderer, &rendererCount) == kCGLNoError) {
41147:     for (GLint c = 0; c < rendererCount; c++) {
41147:       GLint rendProp = 0;
41147:       if (::CGLDescribeRenderer(renderer, c, kCGLRPRendererID, &rendProp) == kCGLNoError) {
41147:         if ((rendProp & CGLRendererIDMatchingMask) == CGLRendererIntel900ID) {
79533:           hasIntelGMA9XX = true;
41147:           break;
41147:         }
41147:       }
41147:     }
41147:     ::CGLDestroyRendererInfo(renderer);
41147:   }
41147:   return hasIntelGMA9XX;
41147: }
40205: #endif
40205: 
79445: bool
54127: nsNPAPIPlugin::RunPluginOOP(const nsPluginTag *aPluginTag)
35811: {
35811:   if (PR_GetEnv("MOZ_DISABLE_OOP_PLUGINS")) {
79533:     return false;
35811:   }
35811: 
55878:   if (!aPluginTag) {
79533:     return false;
55878:   }
55878: 
62890: #if defined(XP_MACOSX) && defined(__i386__)
40205:   // Only allow on Mac OS X 10.6 or higher.
40205:   if (OSXVersion() < 0x00001060) {
79533:     return false;
40205:   }
40216:   // Blacklist Flash 10.0 or lower since it may try to negotiate Carbon/Quickdraw
41147:   // which are not supported out of process. Also blacklist Flash 10.1 if this
41147:   // machine has an Intel GMA9XX GPU because Flash will negotiate Quickdraw graphics.
68442:   // Never blacklist Flash >= 10.2.
55878:   if (aPluginTag->mFileName.EqualsIgnoreCase("flash player.plugin")) {
40216:     // If the first '.' is before position 2 or the version 
40216:     // starts with 10.0 then we are dealing with Flash 10 or less.
40216:     if (aPluginTag->mVersion.FindChar('.') < 2) {
79533:       return false;
40216:     }
40216:     if (aPluginTag->mVersion.Length() >= 4) {
40216:       nsCString versionPrefix;
40216:       aPluginTag->mVersion.Left(versionPrefix, 4);
40216:       if (versionPrefix.EqualsASCII("10.0")) {
79533:         return false;
40216:       }
68442:       if (versionPrefix.EqualsASCII("10.1") && GMA9XXGraphics()) {
79533:         return false;
40216:       }
41147:     }
40216:   }
40205: #endif
40205: 
36981: #ifdef XP_WIN
36981:   OSVERSIONINFO osVerInfo = {0};
36981:   osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
36981:   GetVersionEx(&osVerInfo);
36981:   // Always disabled on 2K or less. (bug 536303)
36981:   if (osVerInfo.dwMajorVersion < 5 ||
36981:       (osVerInfo.dwMajorVersion == 5 && osVerInfo.dwMinorVersion == 0))
79533:     return false;
36981: #endif
36981: 
37609:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
37609:   if (!prefs) {
79533:     return false;
37609:   }
37609: 
37609:   // Get per-library whitelist/blacklist pref string
37609:   // "dom.ipc.plugins.enabled.filename.dll" and fall back to the default value
37609:   // of "dom.ipc.plugins.enabled"
50621:   // The "filename.dll" part can contain shell wildcard pattern
50621: 
64609:   nsCAutoString prefFile(aPluginTag->mFullPath.get());
50621:   PRInt32 slashPos = prefFile.RFindCharInSet("/\\");
37609:   if (kNotFound == slashPos)
79533:     return false;
50621:   prefFile.Cut(0, slashPos + 1);
50621:   ToLowerCase(prefFile);
50621: 
54674: #ifdef XP_MACOSX
54674: #if defined(__i386__)
54674:   nsCAutoString prefGroupKey("dom.ipc.plugins.enabled.i386.");
54674: #elif defined(__x86_64__)
54674:   nsCAutoString prefGroupKey("dom.ipc.plugins.enabled.x86_64.");
54674: #elif defined(__ppc__)
54674:   nsCAutoString prefGroupKey("dom.ipc.plugins.enabled.ppc.");
54674: #endif
54674: #else
50621:   nsCAutoString prefGroupKey("dom.ipc.plugins.enabled.");
54674: #endif
50621: 
55878:   // Java plugins include a number of different file names,
55878:   // so use the mime type (mIsJavaPlugin) and a special pref.
79445:   bool javaIsEnabled;
55878:   if (aPluginTag->mIsJavaPlugin &&
55878:       NS_SUCCEEDED(prefs->GetBoolPref("dom.ipc.plugins.java.enabled", &javaIsEnabled)) &&
55878:       !javaIsEnabled) {
79533:     return false;
55878:   }
55878: 
50621:   PRUint32 prefCount;
50621:   char** prefNames;
50621:   nsresult rv = prefs->GetChildList(prefGroupKey.get(),
50621:                                     &prefCount, &prefNames);
37609: 
79445:   bool oopPluginsEnabled = false;
79445:   bool prefSet = false;
50621: 
50621:   if (NS_SUCCEEDED(rv) && prefCount > 0) {
50621:     PRUint32 prefixLength = prefGroupKey.Length();
50621:     for (PRUint32 currentPref = 0; currentPref < prefCount; currentPref++) {
50621:       // Get the mask
50621:       const char* maskStart = prefNames[currentPref] + prefixLength;
79445:       bool match = false;
50621: 
50621:       int valid = NS_WildCardValid(maskStart);
50621:       if (valid == INVALID_SXP) {
50621:          continue;
50621:       }
50621:       else if(valid == NON_SXP) {
50621:         // mask is not a shell pattern, compare it as normal string
50621:         match = (strcmp(prefFile.get(), maskStart) == 0);
50621:       }
50621:       else {
50621:         match = (NS_WildCardMatch(prefFile.get(), maskStart, 0) == MATCH);
50621:       }
50621: 
50621:       if (match && NS_SUCCEEDED(prefs->GetBoolPref(prefNames[currentPref],
50621:                                                    &oopPluginsEnabled))) {
79533:         prefSet = true;
50621:         break;
50621:       }
50621:     }
50621:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
50621:   }
50621: 
50621:   if (!prefSet) {
79533:     oopPluginsEnabled = false;
54674: #ifdef XP_MACOSX
54674: #if defined(__i386__)
54674:     prefs->GetBoolPref("dom.ipc.plugins.enabled.i386", &oopPluginsEnabled);
54674: #elif defined(__x86_64__)
54674:     prefs->GetBoolPref("dom.ipc.plugins.enabled.x86_64", &oopPluginsEnabled);
54674: #elif defined(__ppc__)
54674:     prefs->GetBoolPref("dom.ipc.plugins.enabled.ppc", &oopPluginsEnabled);
54674: #endif
54674: #else
37609:     prefs->GetBoolPref("dom.ipc.plugins.enabled", &oopPluginsEnabled);
54674: #endif
50621:   }
50621: 
37609:   return oopPluginsEnabled;
35811: }
35811: 
36010: inline PluginLibrary*
54127: GetNewPluginLibrary(nsPluginTag *aPluginTag)
35811: {
54127:   if (!aPluginTag) {
54127:     return nsnull;
54127:   }
54127: 
54127:   if (nsNPAPIPlugin::RunPluginOOP(aPluginTag)) {
64609:     return PluginModuleParent::LoadModule(aPluginTag->mFullPath.get());
40216:   }
64609:   return new PluginPRLibrary(aPluginTag->mFullPath.get(), aPluginTag->mLibrary);
35811: }
35811: 
40564: // Creates an nsNPAPIPlugin object. One nsNPAPIPlugin object exists per plugin (not instance).
19246: nsresult
62174: nsNPAPIPlugin::CreatePlugin(nsPluginTag *aPluginTag, nsNPAPIPlugin** aResult)
19246: {
40564:   *aResult = nsnull;
40564: 
54127:   if (!aPluginTag) {
50781:     return NS_ERROR_FAILURE;
50781:   }
50781: 
19246:   CheckClassInitialized();
19246: 
40564:   nsRefPtr<nsNPAPIPlugin> plugin = new nsNPAPIPlugin();
40564:   if (!plugin)
40564:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
54127:   PluginLibrary* pluginLib = GetNewPluginLibrary(aPluginTag);
40564:   if (!pluginLib) {
19246:     return NS_ERROR_FAILURE;
19246:   }
19246: 
82142: #if defined(XP_MACOSX) || defined(MOZ_WIDGET_ANDROID)
40564:   if (!pluginLib->HasRequiredFunctions()) {
40564:     NS_WARNING("Not all necessary functions exposed by plugin, it will not load.");
19246:     return NS_ERROR_FAILURE;
19246:   }
40564: #endif
40564: 
40564:   plugin->mLibrary = pluginLib;
40564:   pluginLib->SetPlugin(plugin);
40564: 
40564:   NPError pluginCallError;
40564:   nsresult rv;
40564: 
40564: // Exchange NPAPI entry points.
40564: #if defined(XP_WIN) || defined(XP_OS2)
40564:   // NP_GetEntryPoints must be called before NP_Initialize on Windows.
40564:   rv = pluginLib->NP_GetEntryPoints(&plugin->mPluginFuncs, &pluginCallError);
40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
19246:     return NS_ERROR_FAILURE;
19246:   }
22811: 
40564:   // NP_Initialize must be called after NP_GetEntryPoints on Windows.
40564:   rv = pluginLib->NP_Initialize(&sBrowserFuncs, &pluginCallError);
40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
40564:     return NS_ERROR_FAILURE;
40564:   }
40564: #elif defined(XP_MACOSX)
40564:   // NP_Initialize must be called before NP_GetEntryPoints on Mac OS X.
40564:   // We need to match WebKit's behavior.
40564:   rv = pluginLib->NP_Initialize(&sBrowserFuncs, &pluginCallError);
40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
40564:     return NS_ERROR_FAILURE;
40564:   }
40564: 
40564:   rv = pluginLib->NP_GetEntryPoints(&plugin->mPluginFuncs, &pluginCallError);
40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
40564:     return NS_ERROR_FAILURE;
40564:   }
82142: #elif defined(MOZ_WIDGET_GONK)
40564: #else
40564:   rv = pluginLib->NP_Initialize(&sBrowserFuncs, &plugin->mPluginFuncs, &pluginCallError);
40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
40564:     return NS_ERROR_FAILURE;
40564:   }
19246: #endif
40564: 
40564:   *aResult = plugin.forget().get();
19246:   return NS_OK;
19246: }
19246: 
47965: PluginLibrary*
47965: nsNPAPIPlugin::GetLibrary()
47965: {
47965:   return mLibrary;
47965: }
47965: 
47965: NPPluginFuncs*
47965: nsNPAPIPlugin::PluginFuncs()
47965: {
47965:   return &mPluginFuncs;
47965: }
47965: 
69716: nsresult
70007: nsNPAPIPlugin::CreatePluginInstance(nsNPAPIPluginInstance **aResult)
19246: {
21231:   if (!aResult)
19246:     return NS_ERROR_NULL_POINTER;
19246: 
19246:   *aResult = NULL;
19246: 
47965:   nsRefPtr<nsNPAPIPluginInstance> inst = new nsNPAPIPluginInstance(this);
19246:   if (!inst)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
70007:   *aResult = inst;
78894:   NS_ADDREF(*aResult);
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult
37780: nsNPAPIPlugin::Shutdown()
19246: {
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
19246:                  ("NPP Shutdown to be called: this=%p\n", this));
19246: 
36010:   NPError shutdownError;
37780:   mLibrary->NP_Shutdown(&shutdownError);
69090: 
19246:   return NS_OK;
19246: }
19246: 
80593: nsresult
80593: nsNPAPIPlugin::RetainStream(NPStream *pstream, nsISupports **aRetainedPeer)
80593: {
80593:   if (!aRetainedPeer)
80593:     return NS_ERROR_NULL_POINTER;
80593: 
80593:   *aRetainedPeer = NULL;
80593: 
80593:   if (!pstream || !pstream->ndata)
80593:     return NPERR_INVALID_PARAM;
80593: 
80593:   nsNPAPIPluginStreamListener* listener =
80593:     static_cast<nsNPAPIPluginStreamListener*>(pstream->ndata);
80593:   nsPluginStreamListenerPeer* peer = listener->GetStreamListenerPeer();
80593: 
80593:   if (!peer)
80593:     return NPERR_GENERIC_ERROR;
80593: 
80593:   *aRetainedPeer = (nsISupports*) peer;
80593:   NS_ADDREF(*aRetainedPeer);
80593:   return NS_OK;
80593: }
80593: 
19246: // Create a new NPP GET or POST (given in the type argument) url
19246: // stream that may have a notify callback
19246: NPError
19246: MakeNewNPAPIStreamInternal(NPP npp, const char *relativeURL, const char *target,
19246:                           eNPPStreamTypeInternal type,
79445:                           bool bDoNotify = false,
19246:                           void *notifyData = nsnull, uint32_t len = 0,
79533:                           const char *buf = nsnull, NPBool file = false)
19246: {
19246:   if (!npp)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
39211:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
39211:   if (!inst || !inst->IsRunning())
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
70185:   if (!pluginHost) {
70185:     return NPERR_GENERIC_ERROR;
70185:   }
19246: 
19246:   nsCOMPtr<nsIPluginStreamListener> listener;
55320:   // Set aCallNotify here to false.  If pluginHost->GetURL or PostURL fail,
55320:   // the listener's destructor will do the notification while we are about to
55320:   // return a failure code.
60021:   // Call SetCallNotify(true) below after we are sure we cannot return a failure 
55320:   // code.
60021:   if (!target) {
60021:     inst->NewStreamListener(relativeURL, notifyData,
60021:                             getter_AddRefs(listener));
60021:     if (listener) {
79533:       static_cast<nsNPAPIPluginStreamListener*>(listener.get())->SetCallNotify(false);
60021:     }
60021:   }
19246: 
19246:   switch (type) {
19246:   case eNPPStreamTypeInternal_Get:
19246:     {
67851:       if (NS_FAILED(pluginHost->GetURL(inst, relativeURL, target, listener,
67851:                                        NULL, NULL, false)))
19246:         return NPERR_GENERIC_ERROR;
19246:       break;
19246:     }
19246:   case eNPPStreamTypeInternal_Post:
19246:     {
67851:       if (NS_FAILED(pluginHost->PostURL(inst, relativeURL, len, buf, file, target, listener, NULL, NULL, false, 0, NULL)))
19246:         return NPERR_GENERIC_ERROR;
19246:       break;
19246:     }
19246:   default:
31561:     NS_ERROR("how'd I get here");
19246:   }
19246: 
55320:   if (listener) {
55320:     // SetCallNotify(bDoNotify) here, see comment above.
60021:     static_cast<nsNPAPIPluginStreamListener*>(listener.get())->SetCallNotify(bDoNotify);
55320:   }
55320: 
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
69691: #if defined(MOZ_MEMORY_WINDOWS)
36125: extern "C" size_t malloc_usable_size(const void *ptr);
36125: #endif
36125: 
36125: namespace {
36125: 
36125: static char *gNPPException;
36125: 
36125: // A little helper class used to wrap up plugin manager streams (that is,
36125: // streams from the plugin to the browser).
36125: class nsNPAPIStreamWrapper : nsISupports
36125: {
36125: public:
36125:   NS_DECL_ISUPPORTS
36125: 
36125: protected:
36125:   nsIOutputStream *fStream;
36125:   NPStream        fNPStream;
36125: 
36125: public:
36125:   nsNPAPIStreamWrapper(nsIOutputStream* stream);
36125:   ~nsNPAPIStreamWrapper();
36125: 
36125:   void GetStream(nsIOutputStream* &result);
37780:   NPStream* GetNPStream() { return &fNPStream; }
36125: };
36125: 
36125: class nsPluginThreadRunnable : public nsRunnable,
36125:                                public PRCList
36125: {
36125: public:
36125:   nsPluginThreadRunnable(NPP instance, PluginThreadCallback func,
36125:                          void *userData);
36125:   virtual ~nsPluginThreadRunnable();
36125: 
36125:   NS_IMETHOD Run();
36125: 
79445:   bool IsForInstance(NPP instance)
36125:   {
36125:     return (mInstance == instance);
36125:   }
36125: 
36125:   void Invalidate()
36125:   {
36125:     mFunc = nsnull;
36125:   }
36125: 
79445:   bool IsValid()
36125:   {
36125:     return (mFunc != nsnull);
36125:   }
36125: 
36125: private:  
36125:   NPP mInstance;
36125:   PluginThreadCallback mFunc;
36125:   void *mUserData;
36125: };
36125: 
36125: static nsIDocument *
36125: GetDocumentFromNPP(NPP npp)
36125: {
36125:   NS_ENSURE_TRUE(npp, nsnull);
36125: 
36125:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
36125:   NS_ENSURE_TRUE(inst, nsnull);
36125: 
36125:   PluginDestructionGuard guard(inst);
36125: 
36125:   nsCOMPtr<nsIPluginInstanceOwner> owner;
36125:   inst->GetOwner(getter_AddRefs(owner));
36125:   NS_ENSURE_TRUE(owner, nsnull);
36125: 
36125:   nsCOMPtr<nsIDocument> doc;
36125:   owner->GetDocument(getter_AddRefs(doc));
36125: 
36125:   return doc;
36125: }
36125: 
36125: static JSContext *
36125: GetJSContextFromDoc(nsIDocument *doc)
36125: {
36125:   nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
36125:   NS_ENSURE_TRUE(sgo, nsnull);
36125: 
36125:   nsIScriptContext *scx = sgo->GetContext();
36125:   NS_ENSURE_TRUE(scx, nsnull);
36125: 
78415:   return scx->GetNativeContext();
36125: }
36125: 
36125: static JSContext *
36125: GetJSContextFromNPP(NPP npp)
36125: {
36125:   nsIDocument *doc = GetDocumentFromNPP(npp);
36125:   NS_ENSURE_TRUE(doc, nsnull);
36125: 
36125:   return GetJSContextFromDoc(doc);
36125: }
36125: 
36125: static NPIdentifier
36125: doGetIdentifier(JSContext *cx, const NPUTF8* name)
36125: {
36125:   NS_ConvertUTF8toUTF16 utf16name(name);
36125: 
36125:   JSString *str = ::JS_InternUCStringN(cx, (jschar *)utf16name.get(),
36125:                                        utf16name.Length());
36125: 
36125:   if (!str)
36125:     return NULL;
36125: 
70270:   return StringToNPIdentifier(cx, str);
36125: }
36125: 
69691: #if defined(MOZ_MEMORY_WINDOWS)
36125: BOOL
36125: InHeap(HANDLE hHeap, LPVOID lpMem)
36125: {
36125:   BOOL success = FALSE;
36125:   PROCESS_HEAP_ENTRY he;
36125:   he.lpData = NULL;
36125:   while (HeapWalk(hHeap, &he) != 0) {
36125:     if (he.lpData == lpMem) {
36125:       success = TRUE;
36125:       break;
36125:     }
36125:   }
36125:   HeapUnlock(hHeap);
36125:   return success;
36125: }
36125: #endif
36125: 
36125: } /* anonymous namespace */
36125: 
36125: NS_IMPL_ISUPPORTS1(nsNPAPIStreamWrapper, nsISupports)
36125: 
36125: nsNPAPIStreamWrapper::nsNPAPIStreamWrapper(nsIOutputStream* stream)
36125: : fStream(stream)
36125: {
36125:   NS_ASSERTION(stream, "bad stream");
36125: 
36125:   fStream = stream;
36125:   NS_ADDREF(fStream);
36125: 
36125:   memset(&fNPStream, 0, sizeof(fNPStream));
36125:   fNPStream.ndata = (void*) this;
36125: }
36125: 
37780: nsNPAPIStreamWrapper::~nsNPAPIStreamWrapper()
36125: {
36125:   fStream->Close();
36125:   NS_IF_RELEASE(fStream);
36125: }
36125: 
36125: void
36125: nsNPAPIStreamWrapper::GetStream(nsIOutputStream* &result)
36125: {
36125:   result = fStream;
36125:   NS_IF_ADDREF(fStream);
36125: }
36125: 
36125: NPPExceptionAutoHolder::NPPExceptionAutoHolder()
36125:   : mOldException(gNPPException)
36125: {
36125:   gNPPException = nsnull;
36125: }
36125: 
36125: NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
36125: {
36125:   NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
36125: 
36125:   gNPPException = mOldException;
36125: }
36125: 
36125: nsPluginThreadRunnable::nsPluginThreadRunnable(NPP instance,
36125:                                                PluginThreadCallback func,
36125:                                                void *userData)
36125:   : mInstance(instance), mFunc(func), mUserData(userData)
36125: {
36125:   if (!sPluginThreadAsyncCallLock) {
36125:     // Failed to create lock, not much we can do here then...
36125:     mFunc = nsnull;
36125: 
36125:     return;
36125:   }
36125: 
36125:   PR_INIT_CLIST(this);
36125: 
36125:   {
64576:     MutexAutoLock lock(*sPluginThreadAsyncCallLock);
36125: 
36125:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
36355:     if (!inst || !inst->IsRunning()) {
36125:       // The plugin was stopped, ignore this async call.
36125:       mFunc = nsnull;
36125: 
36125:       return;
36125:     }
36125: 
36125:     PR_APPEND_LINK(this, &sPendingAsyncCalls);
36125:   }
36125: }
36125: 
36125: nsPluginThreadRunnable::~nsPluginThreadRunnable()
36125: {
36125:   if (!sPluginThreadAsyncCallLock) {
36125:     return;
36125:   }
36125: 
36125:   {
64576:     MutexAutoLock lock(*sPluginThreadAsyncCallLock);
36125: 
36125:     PR_REMOVE_LINK(this);
36125:   }
36125: }
36125: 
36125: NS_IMETHODIMP
36125: nsPluginThreadRunnable::Run()
36125: {
36125:   if (mFunc) {
36125:     PluginDestructionGuard guard(mInstance);
36125: 
55810:     NS_TRY_SAFE_CALL_VOID(mFunc(mUserData), nsnull);
36125:   }
36125: 
36125:   return NS_OK;
36125: }
36125: 
36125: void
36125: OnPluginDestroy(NPP instance)
36125: {
36125:   if (!sPluginThreadAsyncCallLock) {
36125:     return;
36125:   }
36125: 
36125:   {
64576:     MutexAutoLock lock(*sPluginThreadAsyncCallLock);
36125: 
36125:     if (PR_CLIST_IS_EMPTY(&sPendingAsyncCalls)) {
36125:       return;
36125:     }
36125: 
36125:     nsPluginThreadRunnable *r =
36125:       (nsPluginThreadRunnable *)PR_LIST_HEAD(&sPendingAsyncCalls);
36125: 
36125:     do {
36125:       if (r->IsForInstance(instance)) {
36125:         r->Invalidate();
36125:       }
36125: 
36125:       r = (nsPluginThreadRunnable *)PR_NEXT_LINK(r);
36125:     } while (r != &sPendingAsyncCalls);
36125:   }
36125: }
36125: 
36125: void
36125: OnShutdown()
36125: {
36125:   NS_ASSERTION(PR_CLIST_IS_EMPTY(&sPendingAsyncCalls),
36125:                "Pending async plugin call list not cleaned up!");
36125: 
36125:   if (sPluginThreadAsyncCallLock) {
64576:     delete sPluginThreadAsyncCallLock;
36125: 
36125:     sPluginThreadAsyncCallLock = nsnull;
36125:   }
36125: }
36125: 
64576: AsyncCallbackAutoLock::AsyncCallbackAutoLock()
36125: {
67793:   if (sPluginThreadAsyncCallLock) {
64576:     sPluginThreadAsyncCallLock->Lock();
36125:   }
67793: }
64576: 
64576: AsyncCallbackAutoLock::~AsyncCallbackAutoLock()
64576: {
67793:   if (sPluginThreadAsyncCallLock) {
64576:     sPluginThreadAsyncCallLock->Unlock();
64568:   }
67793: }
64568: 
36125: 
36125: NPP NPPStack::sCurrentNPP = nsnull;
36125: 
36125: const char *
36125: PeekException()
36125: {
36125:   return gNPPException;
36125: }
36125: 
36125: void
36125: PopException()
36125: {
36125:   NS_ASSERTION(gNPPException, "Uh, no NPP exception to pop!");
36125: 
36125:   if (gNPPException) {
36125:     free(gNPPException);
36125: 
36125:     gNPPException = nsnull;
36125:   }
36125: }
36125: 
19246: //
19246: // Static callbacks that get routed back through the new C++ API
19246: //
19246: 
36125: namespace mozilla {
36125: namespace plugins {
36125: namespace parent {
36125: 
19246: NPError NP_CALLBACK
19246: _geturl(NPP npp, const char* relativeURL, const char* target)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturl called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
19246:    relativeURL));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   // Block Adobe Acrobat from loading URLs that are not http:, https:,
19246:   // or ftp: URLs if the given target is null.
21231:   if (!target && relativeURL &&
19246:       (strncmp(relativeURL, "http:", 5) != 0) &&
19246:       (strncmp(relativeURL, "https:", 6) != 0) &&
19246:       (strncmp(relativeURL, "ftp:", 4) != 0)) {
19246:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246: 
37525:     
41187:     const char *name = nsnull;
37525:     nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
37525:     host->GetPluginName(inst, &name);
19246: 
19246:     if (name && strstr(name, "Adobe") && strstr(name, "Acrobat")) {
19246:       return NPERR_NO_ERROR;
19246:     }
19246:   }
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
19246:                                     eNPPStreamTypeInternal_Get);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _geturlnotify(NPP npp, const char* relativeURL, const char* target,
19246:               void* notifyData)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturlnotify called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
19246:      target, notifyData, relativeURL));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
79533:                                     eNPPStreamTypeInternal_Get, true,
19246:                                     notifyData);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _posturlnotify(NPP npp, const char *relativeURL, const char *target,
19246:                uint32_t len, const char *buf, NPBool file, void *notifyData)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturlnotify called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
36110:   if (!buf)
36110:     return NPERR_INVALID_PARAM;
36110: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
19246:                   "notify=%p, url=%s, buf=%s\n",
19246:                   (void*)npp, target, len, file, notifyData, relativeURL,
19246:                   buf));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
79533:                                     eNPPStreamTypeInternal_Post, true,
19246:                                     notifyData, len, buf, file);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _posturl(NPP npp, const char *relativeURL, const char *target,
19246:          uint32_t len, const char *buf, NPBool file)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturl called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
19246:                   "buf=%s\n",
19246:                   (void*)npp, target, file, len, relativeURL, buf));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
79533:                                     eNPPStreamTypeInternal_Post, false, nsnull,
19246:                                     len, buf, file);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_newstream called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
19246:    (const char *)type, target));
19246: 
19246:   NPError err = NPERR_INVALID_INSTANCE_ERROR;
19246:   if (npp && npp->ndata) {
70007:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246: 
19246:     PluginDestructionGuard guard(inst);
19246: 
19246:     nsCOMPtr<nsIOutputStream> stream;
29834:     if (NS_SUCCEEDED(inst->NewStreamFromPlugin((const char*) type, target,
19246:                                                getter_AddRefs(stream)))) {
19246:       nsNPAPIStreamWrapper* wrapper = new nsNPAPIStreamWrapper(stream);
19246:       if (wrapper) {
19246:         (*result) = wrapper->GetNPStream();
19246:         err = NPERR_NO_ERROR;
19246:       } else {
19246:         err = NPERR_OUT_OF_MEMORY_ERROR;
19246:       }
19246:     } else {
19246:       err = NPERR_GENERIC_ERROR;
19246:     }
19246:   }
19246:   return err;
19246: }
19246: 
19246: int32_t NP_CALLBACK
19246: _write(NPP npp, NPStream *pstream, int32_t len, void *buffer)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
19246:     return 0;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
19246:                   pstream->url, len, (char*)buffer));
19246: 
19246:   // negative return indicates failure to the plugin
19246:   if (!npp)
19246:     return -1;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper*) pstream->ndata;
21231:   NS_ASSERTION(wrapper, "null stream");
21231:   if (!wrapper)
19246:     return -1;
19246: 
19246:   nsIOutputStream* stream;
19246:   wrapper->GetStream(stream);
19246: 
19246:   PRUint32 count = 0;
19246:   nsresult rv = stream->Write((char *)buffer, len, &count);
19246:   NS_RELEASE(stream);
19246: 
19246:   if (rv != NS_OK)
19246:     return -1;
19246: 
19246:   return (int32_t)count;
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _destroystream(NPP npp, NPStream *pstream, NPError reason)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
19246:                   pstream->url, (int)reason));
19246: 
19246:   if (!npp)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   nsCOMPtr<nsIPluginStreamListener> listener =
19246:     do_QueryInterface((nsISupports *)pstream->ndata);
19246: 
19246:   // DestroyStream can kill two kinds of streams: NPP derived and NPN derived.
19246:   // check to see if they're trying to kill a NPP stream
19246:   if (listener) {
19246:     // Tell the stream listner that the stream is now gone.
19246:     listener->OnStopBinding(nsnull, NS_BINDING_ABORTED);
19246: 
19246:     // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240131
19246:     //
19246:     // Is it ok to leave pstream->ndata set here, and who releases it
19246:     // (or is it even properly ref counted)? And who closes the stream
19246:     // etc?
19246:   } else {
19246:     nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper *)pstream->ndata;
21231:     NS_ASSERTION(wrapper, "null wrapper");
21231: 
21231:     if (!wrapper)
19246:       return NPERR_INVALID_PARAM;
19246: 
19246:     // This will release the wrapped nsIOutputStream.
39166:     // pstream should always be a subobject of wrapper.  See bug 548441.
39166:     NS_ASSERTION((char*)wrapper <= (char*)pstream && 
39166:                  ((char*)pstream) + sizeof(*pstream)
39166:                      <= ((char*)wrapper) + sizeof(*wrapper),
39166:                  "pstream is not a subobject of wrapper");
19246:     delete wrapper;
19246:   }
19246: 
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _status(NPP npp, const char *message)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_status called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
19246:                                      (void*)npp, message));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_status: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
29834:   inst->ShowStatus(message);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _memfree (void *ptr)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memfree called from the wrong thread\n"));
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
19246: 
19246:   if (ptr)
19246:     nsMemory::Free(ptr);
19246: }
19246: 
19246: uint32_t NP_CALLBACK
19246: _memflush(uint32_t size)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memflush called from the wrong thread\n"));
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
19246: 
79533:   nsMemory::HeapMinimize(true);
19246:   return 0;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _reloadplugins(NPBool reloadPages)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_reloadplugins called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
19246: 
29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
29574:   if (!pluginHost)
19246:     return;
19246: 
29574:   pluginHost->ReloadPlugins(reloadPages);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _invalidaterect(NPP npp, NPRect *invalidRect)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidaterect called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
19246:                   "right=%d\n", (void *)npp, invalidRect->top,
19246:                   invalidRect->left, invalidRect->bottom, invalidRect->right));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
32799:   inst->InvalidateRect((NPRect *)invalidRect);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _invalidateregion(NPP npp, NPRegion invalidRegion)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidateregion called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
19246:                   (void*)invalidRegion));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
32799:   inst->InvalidateRegion((NPRegion)invalidRegion);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _forceredraw(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_forceredraw called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_forceredraw: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
29603:   inst->ForceRedraw();
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _getwindowobject(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getwindowobject called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
19246:   JSContext *cx = GetJSContextFromNPP(npp);
19246:   NS_ENSURE_TRUE(cx, nsnull);
19246: 
19246:   // Using ::JS_GetGlobalObject(cx) is ok here since the window we
19246:   // want to return here is the outer window, *not* the inner (since
19246:   // we don't know what the plugin will do with it).
19246:   return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _getpluginelement(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getpluginelement called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
32369: 
32369:   nsNPAPIPluginInstance* inst = static_cast<nsNPAPIPluginInstance*>(npp->ndata);
32369:   if (!inst)
19246:     return nsnull;
32369: 
19246:   nsCOMPtr<nsIDOMElement> element;
32369:   inst->GetDOMElement(getter_AddRefs(element));
32369: 
32369:   if (!element)
32369:     return nsnull;
19246: 
19246:   JSContext *cx = GetJSContextFromNPP(npp);
19246:   NS_ENSURE_TRUE(cx, nsnull);
19246: 
19246:   nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
19246:   NS_ENSURE_TRUE(xpc, nsnull);
19246: 
19246:   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
19246:   xpc->WrapNative(cx, ::JS_GetGlobalObject(cx), element,
19246:                   NS_GET_IID(nsIDOMElement),
19246:                   getter_AddRefs(holder));
19246:   NS_ENSURE_TRUE(holder, nsnull);
19246: 
19246:   JSObject* obj = nsnull;
19246:   holder->GetJSObject(&obj);
19246:   NS_ENSURE_TRUE(obj, nsnull);
19246: 
19246:   return nsJSObjWrapper::GetNewOrUsed(npp, cx, obj);
19246: }
19246: 
19246: NPIdentifier NP_CALLBACK
19246: _getstringidentifier(const NPUTF8* name)
19246: {
19246:   if (!name) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifier: passed null name"));
19246:     return NULL;
19246:   }
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
19246:   }
19246: 
19246:   nsCOMPtr<nsIThreadJSContextStack> stack =
19246:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
19246:   if (!stack)
19246:     return NULL;
19246: 
19246:   JSContext *cx = nsnull;
19246:   stack->GetSafeJSContext(&cx);
19246:   if (!cx)
19246:     return NULL;
19246: 
19246:   JSAutoRequest ar(cx);
19246:   return doGetIdentifier(cx, name);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
19246:                       NPIdentifier *identifiers)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifiers called from the wrong thread\n"));
19246:   }
19246:   nsCOMPtr<nsIThreadJSContextStack> stack =
19246:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
19246:   if (!stack)
19246:     return;
19246: 
19246:   JSContext *cx = nsnull;
19246:   stack->GetSafeJSContext(&cx);
19246:   if (!cx)
19246:     return;
19246: 
19246:   JSAutoRequest ar(cx);
19246: 
19246:   for (int32_t i = 0; i < nameCount; ++i) {
19246:     if (names[i]) {
19246:       identifiers[i] = doGetIdentifier(cx, names[i]);
19246:     } else {
19246:       NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifiers: passed null name"));
19246:       identifiers[i] = NULL;
19246:     }
19246:   }
19246: }
19246: 
19246: NPIdentifier NP_CALLBACK
19246: _getintidentifier(int32_t intid)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
19246:   }
48470:   return IntToNPIdentifier(intid);
19246: }
19246: 
19246: NPUTF8* NP_CALLBACK
48470: _utf8fromidentifier(NPIdentifier id)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_utf8fromidentifier called from the wrong thread\n"));
19246:   }
48470:   if (!id)
19246:     return NULL;
19246: 
48470:   if (!NPIdentifierIsString(id)) {
19246:     return nsnull;
19246:   }
19246: 
48470:   JSString *str = NPIdentifierToString(id);
19246: 
19246:   return
59889:     ToNewUTF8String(nsDependentString(::JS_GetInternedStringChars(str),
19246:                                       ::JS_GetStringLength(str)));
19246: }
19246: 
19246: int32_t NP_CALLBACK
48470: _intfromidentifier(NPIdentifier id)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_intfromidentifier called from the wrong thread\n"));
19246:   }
48470: 
48470:   if (!NPIdentifierIsInt(id)) {
19246:     return PR_INT32_MIN;
19246:   }
19246: 
48470:   return NPIdentifierToInt(id);
19246: }
19246: 
19246: bool NP_CALLBACK
48470: _identifierisstring(NPIdentifier id)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_identifierisstring called from the wrong thread\n"));
19246:   }
48470: 
48470:   return NPIdentifierIsString(id);
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _createobject(NPP npp, NPClass* aClass)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_createobject called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
19246:   if (!npp) {
19246:     NS_ERROR("Null npp passed to _createobject()!");
19246: 
19246:     return nsnull;
19246:   }
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   if (!aClass) {
19246:     NS_ERROR("Null class passed to _createobject()!");
19246: 
19246:     return nsnull;
19246:   }
19246: 
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPObject *npobj;
19246: 
19246:   if (aClass->allocate) {
19246:     npobj = aClass->allocate(npp, aClass);
19246:   } else {
19246:     npobj = (NPObject *)PR_Malloc(sizeof(NPObject));
19246:   }
19246: 
19246:   if (npobj) {
19246:     npobj->_class = aClass;
19246:     npobj->referenceCount = 1;
36078:     NS_LOG_ADDREF(npobj, 1, "BrowserNPObject", sizeof(NPObject));
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("Created NPObject %p, NPClass %p\n", npobj, aClass));
19246: 
19246:   return npobj;
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _retainobject(NPObject* npobj)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_retainobject called from the wrong thread\n"));
19246:   }
19246:   if (npobj) {
61997: #ifdef NS_BUILD_REFCNT_LOGGING
61930:     int32_t refCnt =
61930: #endif
64101:       PR_ATOMIC_INCREMENT((PRInt32*)&npobj->referenceCount);
36078:     NS_LOG_ADDREF(npobj, refCnt, "BrowserNPObject", sizeof(NPObject));
19246:   }
19246: 
19246:   return npobj;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _releaseobject(NPObject* npobj)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releaseobject called from the wrong thread\n"));
19246:   }
19246:   if (!npobj)
19246:     return;
19246: 
64101:   int32_t refCnt = PR_ATOMIC_DECREMENT((PRInt32*)&npobj->referenceCount);
36078:   NS_LOG_RELEASE(npobj, refCnt, "BrowserNPObject");
19246: 
19246:   if (refCnt == 0) {
19246:     nsNPObjWrapper::OnDestroy(npobj);
19246: 
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                    ("Deleting NPObject %p, refcount hit 0\n", npobj));
19246: 
19246:     if (npobj->_class && npobj->_class->deallocate) {
19246:       npobj->_class->deallocate(npobj);
19246:     } else {
19246:       PR_Free(npobj);
19246:     }
19246:   }
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
19246:         uint32_t argCount, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invoke called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
19246:     return false;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
19246:                   npobj, method, argCount));
19246: 
19246:   return npobj->_class->invoke(npobj, method, args, argCount, result);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
19246:                uint32_t argCount, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invokedefault called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp,
19246:                   npobj, argCount));
19246: 
19246:   return npobj->_class->invokeDefault(npobj, args, argCount, result);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_evaluate called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp)
19246:     return false;
19246: 
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   nsIDocument *doc = GetDocumentFromNPP(npp);
19246:   NS_ENSURE_TRUE(doc, false);
19246: 
19246:   JSContext *cx = GetJSContextFromDoc(doc);
19246:   NS_ENSURE_TRUE(cx, false);
19246: 
36570:   nsCOMPtr<nsIScriptContext> scx = GetScriptContextFromJSContext(cx);
36570:   NS_ENSURE_TRUE(scx, false);
36570: 
60783:   JSAutoRequest req(cx);
60783: 
19246:   JSObject *obj =
19246:     nsNPObjWrapper::GetNewOrUsed(npp, cx, npobj);
19246: 
19246:   if (!obj) {
19246:     return false;
19246:   }
19246: 
79734:   obj = JS_ObjectToInnerObject(cx, obj);
82303:   NS_ABORT_IF_FALSE(obj,
82303:     "JS_ObjectToInnerObject should never return null with non-null input.");
50480: 
19246:   // Root obj and the rval (below).
19246:   jsval vec[] = { OBJECT_TO_JSVAL(obj), JSVAL_NULL };
80467:   js::AutoArrayRooter tvr(cx, ArrayLength(vec), vec);
19246:   jsval *rval = &vec[1];
19246: 
19246:   if (result) {
19246:     // Initialize the out param to void
19246:     VOID_TO_NPVARIANT(*result);
19246:   }
19246: 
22867:   if (!script || !script->UTF8Length || !script->UTF8Characters) {
19246:     // Nothing to evaluate.
19246: 
19246:     return true;
19246:   }
19246: 
22867:   NS_ConvertUTF8toUTF16 utf16script(script->UTF8Characters,
22867:                                     script->UTF8Length);
19246: 
19246:   nsIPrincipal *principal = doc->NodePrincipal();
19246: 
19246:   nsCAutoString specStr;
19246:   const char *spec;
19246: 
19246:   nsCOMPtr<nsIURI> uri;
19246:   principal->GetURI(getter_AddRefs(uri));
19246: 
19246:   if (uri) {
19246:     uri->GetSpec(specStr);
19246:     spec = specStr.get();
19246:   } else {
19246:     // No URI in a principal means it's the system principal. If the
19246:     // document URI is a chrome:// URI, pass that in as the URI of the
19246:     // script, else pass in null for the filename as there's no way to
19246:     // know where this document really came from. Passing in null here
19246:     // also means that the script gets treated by XPConnect as if it
19246:     // needs additional protection, which is what we want for unknown
19246:     // chrome code anyways.
19246: 
19246:     uri = doc->GetDocumentURI();
79445:     bool isChrome = false;
19246: 
19246:     if (uri && NS_SUCCEEDED(uri->SchemeIs("chrome", &isChrome)) && isChrome) {
19246:       uri->GetSpec(specStr);
19246:       spec = specStr.get();
19246:     } else {
19246:       spec = nsnull;
19246:     }
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
22867:                   npp, npobj, script->UTF8Characters));
19246: 
19246:   nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
19246:                                              spec, 0, 0, rval, nsnull);
19246: 
19246:   return NS_SUCCEEDED(rv) &&
19246:          (!result || JSValToNPVariant(npp, cx, *rval, result));
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
19246:              NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, property));
19246: 
57925:   if (!npobj->_class->getProperty(npobj, property, result))
57925:     return false;
57925: 
57925:   // If a Java plugin tries to get the document.URL or document.documentURI
57925:   // property from us, don't pass back a value that Java won't be able to
57925:   // understand -- one that will make the URL(String) constructor throw a
57925:   // MalformedURL exception.  Passing such a value causes Java Plugin2 to
57925:   // crash (to throw a RuntimeException in Plugin2Manager.getDocumentBase()).
57925:   // Also don't pass back a value that Java is likely to mishandle.
57925: 
57925:   nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*) npp->ndata;
57925:   if (!inst)
57925:     return false;
57925:   nsNPAPIPlugin* plugin = inst->GetPlugin();
57925:   if (!plugin)
57925:     return false;
57925:   nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
57925:   nsPluginTag* pluginTag = host->TagForPlugin(plugin);
57925:   if (!pluginTag->mIsJavaPlugin)
57925:     return true;
57925: 
57925:   if (!NPVARIANT_IS_STRING(*result))
57925:     return true;
57925: 
57925:   NPUTF8* propertyName = _utf8fromidentifier(property);
57925:   if (!propertyName)
57925:     return true;
57925:   bool notURL =
57925:     (PL_strcasecmp(propertyName, "URL") &&
57925:      PL_strcasecmp(propertyName, "documentURI"));
57925:   _memfree(propertyName);
57925:   if (notURL)
57925:     return true;
57925: 
57925:   NPObject* window_obj = _getwindowobject(npp);
57925:   if (!window_obj)
57925:     return true;
57925: 
57925:   NPVariant doc_v;
57925:   NPObject* document_obj = nsnull;
57925:   NPIdentifier doc_id = _getstringidentifier("document");
57925:   bool ok = npobj->_class->getProperty(window_obj, doc_id, &doc_v);
57925:   _releaseobject(window_obj);
57925:   if (ok) {
57925:     if (NPVARIANT_IS_OBJECT(doc_v)) {
57925:       document_obj = NPVARIANT_TO_OBJECT(doc_v);
57925:     } else {
57925:       _releasevariantvalue(&doc_v);
57925:       return true;
57925:     }
57925:   } else {
57925:     return true;
57925:   }
57925:   _releaseobject(document_obj);
57925:   if (document_obj != npobj)
57925:     return true;
57925: 
57925:   NPString urlnp = NPVARIANT_TO_STRING(*result);
57925:   nsXPIDLCString url;
57925:   url.Assign(urlnp.UTF8Characters, urlnp.UTF8Length);
57925: 
79445:   bool javaCompatible = false;
57925:   if (NS_FAILED(NS_CheckIsJavaCompatibleURLString(url, &javaCompatible)))
79533:     javaCompatible = false;
57925:   if (javaCompatible)
57925:     return true;
57925: 
57925:   // If Java won't be able to interpret the original value of document.URL or
57925:   // document.documentURI, or is likely to mishandle it, pass back something
57925:   // that Java will understand but won't be able to use to access the network,
57925:   // and for which same-origin checks will always fail.
57925: 
57925:   if (inst->mFakeURL.IsVoid()) {
57925:     // Abort (do an error return) if NS_MakeRandomInvalidURLString() fails.
57925:     if (NS_FAILED(NS_MakeRandomInvalidURLString(inst->mFakeURL))) {
57925:       _releasevariantvalue(result);
57925:       return false;
57925:     }
57925:   }
57925: 
57925:   _releasevariantvalue(result);
57925:   char* fakeurl = (char *) _memalloc(inst->mFakeURL.Length() + 1);
57925:   strcpy(fakeurl, inst->mFakeURL);
57925:   STRINGZ_TO_NPVARIANT(fakeurl, *result);
57925: 
57925:   return true;
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
19246:              const NPVariant *value)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, property));
19246: 
19246:   return npobj->_class->setProperty(npobj, property, value);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_removeproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, property));
19246: 
19246:   return npobj->_class->removeProperty(npobj, property);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, propertyName));
19246: 
19246:   return npobj->_class->hasProperty(npobj, propertyName);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasmethod called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, methodName));
19246: 
23760:   return npobj->_class->hasMethod(npobj, methodName);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
19246:            uint32_t *count)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_enumerate called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class)
19246:     return false;
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_Enumerate(npp %p, npobj %p) called\n", npp, npobj));
19246: 
19246:   if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
19246:       !npobj->_class->enumerate) {
19246:     *identifier = 0;
19246:     *count = 0;
19246:     return true;
19246:   }
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   return npobj->_class->enumerate(npobj, identifier, count);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _construct(NPP npp, NPObject* npobj, const NPVariant *args,
19246:                uint32_t argCount, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_construct called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class ||
19246:       !NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) ||
19246:       !npobj->_class->construct) {
19246:     return false;
19246:   }
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   return npobj->_class->construct(npobj, args, argCount, result);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _releasevariantvalue(NPVariant* variant)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releasevariantvalue called from the wrong thread\n"));
19246:   }
19246:   switch (variant->type) {
19246:   case NPVariantType_Void :
19246:   case NPVariantType_Null :
19246:   case NPVariantType_Bool :
19246:   case NPVariantType_Int32 :
19246:   case NPVariantType_Double :
19246:     break;
19246:   case NPVariantType_String :
19246:     {
19246:       const NPString *s = &NPVARIANT_TO_STRING(*variant);
19246: 
22867:       if (s->UTF8Characters) {
69691: #if defined(MOZ_MEMORY_WINDOWS)
22867:         if (malloc_usable_size((void *)s->UTF8Characters) != 0) {
22867:           PR_Free((void *)s->UTF8Characters);
19246:         } else {
22867:           void *p = (void *)s->UTF8Characters;
19246:           DWORD nheaps = 0;
19246:           nsAutoTArray<HANDLE, 50> heaps;
19246:           nheaps = GetProcessHeaps(0, heaps.Elements());
19246:           heaps.AppendElements(nheaps);
19246:           GetProcessHeaps(nheaps, heaps.Elements());
19246:           for (DWORD i = 0; i < nheaps; i++) {
19246:             if (InHeap(heaps[i], p)) {
19246:               HeapFree(heaps[i], 0, p);
19246:               break;
19246:             }
19246:           }
19246:         }
19246: #else
42122:         NS_Free((void *)s->UTF8Characters);
19246: #endif
19246:       }
19246:       break;
19246:     }
19246:   case NPVariantType_Object:
19246:     {
19246:       NPObject *npobj = NPVARIANT_TO_OBJECT(*variant);
19246: 
19246:       if (npobj)
19246:         _releaseobject(npobj);
19246: 
19246:       break;
19246:     }
19246:   default:
19246:     NS_ERROR("Unknown NPVariant type!");
19246:   }
19246: 
19246:   VOID_TO_NPVARIANT(*variant);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _setexception(NPObject* npobj, const NPUTF8 *message)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setexception called from the wrong thread\n"));
19246:     return;
19246:   }
19246: 
34415:   if (!message) return;
34415: 
19246:   if (gNPPException) {
19246:     // If a plugin throws multiple exceptions, we'll only report the
19246:     // last one for now.
19246:     free(gNPPException);
19246:   }
19246: 
19246:   gNPPException = strdup(message);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _getvalue(NPP npp, NPNVariable variable, void *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getvalue called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
19246:                                      (void*)npp, (int)variable));
19246: 
19246:   nsresult res;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   switch(variable) {
19246: #if defined(XP_UNIX) && !defined(XP_MACOSX)
19246:   case NPNVxDisplay : {
77137: #if defined(MOZ_X11)
19246:     if (npp) {
19246:       nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
79445:       bool windowless = false;
32799:       inst->IsWindowless(&windowless);
79533:       NPBool needXEmbed = false;
19246:       if (!windowless) {
63555:         res = inst->GetValueFromPlugin(NPPVpluginNeedsXEmbed, &needXEmbed);
63555:         // If the call returned an error code make sure we still use our default value.
63555:         if (NS_FAILED(res)) {
79533:           needXEmbed = false;
63555:         }
19246:       }
19246:       if (windowless || needXEmbed) {
43912:         (*(Display **)result) = mozilla::DefaultXDisplay();
19246:         return NPERR_NO_ERROR;
19246:       }
19246:     }
41059: #ifdef MOZ_WIDGET_GTK2
19246:     // adobe nppdf calls XtGetApplicationNameAndClass(display,
19246:     // &instance, &class) we have to init Xt toolkit before get
19246:     // XtDisplay just call gtk_xtbin_new(w,0) once
19246:     static GtkWidget *gtkXtBinHolder = 0;
19246:     if (!gtkXtBinHolder) {
27011:       gtkXtBinHolder = gtk_xtbin_new(gdk_get_default_root_window(),0);
19246:       // it crashes on destroy, let it leak
19246:       // gtk_widget_destroy(gtkXtBinHolder);
19246:     }
19246:     (*(Display **)result) =  GTK_XTBIN(gtkXtBinHolder)->xtdisplay;
19246:     return NPERR_NO_ERROR;
19246: #endif
41059: #endif
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVxtAppContext:
19246:     return NPERR_GENERIC_ERROR;
19246: #endif
19246: 
41059: #if defined(XP_WIN) || defined(XP_OS2) || defined(MOZ_WIDGET_GTK2) \
41059:  || defined(MOZ_WIDGET_QT)
19246:   case NPNVnetscapeWindow: {
19246:     if (!npp || !npp->ndata)
19246:       return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246: 
29834:     nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:     inst->GetOwner(getter_AddRefs(owner));
29834:     NS_ENSURE_TRUE(owner, nsnull);
29834: 
29834:     if (NS_SUCCEEDED(owner->GetNetscapeWindow(result))) {
19246:       return NPERR_NO_ERROR;
19246:     }
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: #endif
19246: 
19246:   case NPNVjavascriptEnabledBool: {
79533:     *(NPBool*)result = false;
19246:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
19246:     if (prefs) {
79445:       bool js = false;;
19246:       res = prefs->GetBoolPref("javascript.enabled", &js);
19246:       if (NS_SUCCEEDED(res))
19246:         *(NPBool*)result = js;
19246:     }
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
19246:   case NPNVasdEnabledBool:
79533:     *(NPBool*)result = false;
19246:     return NPERR_NO_ERROR;
19246: 
19246:   case NPNVisOfflineBool: {
79445:     bool offline = false;
19246:     nsCOMPtr<nsIIOService> ioservice =
19246:       do_GetService(NS_IOSERVICE_CONTRACTID, &res);
19246:     if (NS_SUCCEEDED(res))
19246:       res = ioservice->GetOffline(&offline);
19246:     if (NS_FAILED(res))
19246:       return NPERR_GENERIC_ERROR;
19246: 
19246:     *(NPBool*)result = offline;
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
19246:   case NPNVToolkit: {
19246: #ifdef MOZ_WIDGET_GTK2
19246:     *((NPNToolkitType*)result) = NPNVGtk2;
19246: #endif
19246: 
41059: #ifdef MOZ_WIDGET_QT
41059:     /* Fake toolkit so flash plugin works */
41059:     *((NPNToolkitType*)result) = NPNVGtk2;
41059: #endif
19246:     if (*(NPNToolkitType*)result)
19246:         return NPERR_NO_ERROR;
19246: 
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVSupportsXEmbedBool: {
19246: #ifdef MOZ_WIDGET_GTK2
79533:     *(NPBool*)result = true;
42531: #elif defined(MOZ_WIDGET_QT)
42531:     // Desktop Flash fail to initialize if browser does not support NPNVSupportsXEmbedBool
42531:     // even when wmode!=windowed, lets return fake support
42531:     fprintf(stderr, "Fake support for XEmbed plugins in Qt port\n");
79533:     *(NPBool*)result = true;
19246: #else
79533:     *(NPBool*)result = false;
19246: #endif
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
19246:   case NPNVWindowNPObject: {
19246:     *(NPObject **)result = _getwindowobject(npp);
19246: 
36128:     return *(NPObject **)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVPluginElementNPObject: {
19246:     *(NPObject **)result = _getpluginelement(npp);
19246: 
37830:     return *(NPObject **)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVSupportsWindowless: {
41059: #if defined(XP_WIN) || defined(XP_MACOSX) || \
41059:     (defined(MOZ_X11) && (defined(MOZ_WIDGET_GTK2) || defined(MOZ_WIDGET_QT)))
79533:     *(NPBool*)result = true;
19246: #else
79533:     *(NPBool*)result = false;
19246: #endif
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
24475:   case NPNVprivateModeBool: {
24475:     nsCOMPtr<nsIPrivateBrowsingService> pbs = do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
24475:     if (pbs) {
79445:       bool enabled;
24904:       pbs->GetPrivateBrowsingEnabled(&enabled);
24904:       *(NPBool*)result = (NPBool)enabled;
24475:       return NPERR_NO_ERROR;
24475:     }
24475:     return NPERR_GENERIC_ERROR;
24475:   }
24475: 
78254:   case NPNVdocumentOrigin: {
78254:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
78254:     if (!inst) {
78254:       return NPERR_GENERIC_ERROR;
78254:     }
78254: 
78254:     nsCOMPtr<nsIDOMElement> element;
78254:     inst->GetDOMElement(getter_AddRefs(element));
78254:     if (!element) {
78254:       return NPERR_GENERIC_ERROR;
78254:     }
78254: 
78254:     nsCOMPtr<nsIContent> content(do_QueryInterface(element));
78254:     if (!content) {
78254:       return NPERR_GENERIC_ERROR;
78254:     }
78254: 
78254:     nsIPrincipal* principal = content->NodePrincipal();
78254: 
78254:     nsAutoString utf16Origin;
78254:     res = nsContentUtils::GetUTFOrigin(principal, utf16Origin);
78254:     if (NS_FAILED(res)) {
78254:       return NPERR_GENERIC_ERROR;
78254:     }
78254: 
78254:     nsCOMPtr<nsIUnicodeNormalizer> normalizer = do_GetService(NS_UNICODE_NORMALIZER_CONTRACTID);
78254:     if (!normalizer) {
78254:       return NPERR_GENERIC_ERROR;
78254:     }
78254: 
78254:     nsAutoString normalizedUTF16Origin;
78254:     res = normalizer->NormalizeUnicodeNFKC(utf16Origin, normalizedUTF16Origin);
78254:     if (NS_FAILED(res)) {
78254:       return NPERR_GENERIC_ERROR;
78254:     }
78254: 
78254:     *(char**)result = ToNewUTF8String(normalizedUTF16Origin);
78254:     return *(char**)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
78254:   }
78254: 
19246: #ifdef XP_MACOSX
19246:   case NPNVpluginDrawingModel: {
19246:     if (npp) {
19246:       nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246:       if (inst) {
32799:         NPDrawingModel drawingModel;
32799:         inst->GetDrawingModel((PRInt32*)&drawingModel);
32799:         *(NPDrawingModel*)result = drawingModel;
19246:         return NPERR_NO_ERROR;
19246:       }
19246:     }
19246:     else {
19246:       return NPERR_GENERIC_ERROR;
19246:     }
19246:   }
19246: 
19246: #ifndef NP_NO_QUICKDRAW
19246:   case NPNVsupportsQuickDrawBool: {
79533:     *(NPBool*)result = true;
19246:     
19246:     return NPERR_NO_ERROR;
19246:   }
19246: #endif
19246: 
19246:   case NPNVsupportsCoreGraphicsBool: {
79533:     *(NPBool*)result = true;
19246:     
19246:     return NPERR_NO_ERROR;
19246:   }
32019: 
39757:    case NPNVsupportsCoreAnimationBool: {
85524:      *(NPBool*)result = nsCocoaFeatures::SupportCoreAnimationPlugins();
39757: 
39757:      return NPERR_NO_ERROR;
39757:    }
39757: 
43370:    case NPNVsupportsInvalidatingCoreAnimationBool: {
85524:      *(NPBool*)result = nsCocoaFeatures::SupportCoreAnimationPlugins();
43370: 
43370:      return NPERR_NO_ERROR;
43370:    }
43370: 
39757: 
32019: #ifndef NP_NO_CARBON
32019:   case NPNVsupportsCarbonBool: {
79533:     *(NPBool*)result = true;
32019: 
32019:     return NPERR_NO_ERROR;
32019:   }
32019: #endif
32019:   case NPNVsupportsCocoaBool: {
79533:     *(NPBool*)result = true;
32019: 
32019:     return NPERR_NO_ERROR;
32019:   }
61078: 
61078:   case NPNVsupportsUpdatedCocoaTextInputBool: {
61078:     *(NPBool*)result = true;
61078:     return NPERR_NO_ERROR;
61078:   }
19246: #endif
19246: 
82142: #ifdef MOZ_WIDGET_ANDROID
78424:     case kLogInterfaceV0_ANPGetValue: {
78424:       LOG("get log interface");
78424:       ANPLogInterfaceV0 *i = (ANPLogInterfaceV0 *) result;
78424:       InitLogInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kBitmapInterfaceV0_ANPGetValue: {
78424:       LOG("get bitmap interface");
78424:       ANPBitmapInterfaceV0 *i = (ANPBitmapInterfaceV0 *) result;
78424:       InitBitmapInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kMatrixInterfaceV0_ANPGetValue: {
78424:       LOG("get matrix interface");
78424:       ANPMatrixInterfaceV0 *i = (ANPMatrixInterfaceV0 *) result;
78424:       InitMatrixInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424:       
78424:     case kPathInterfaceV0_ANPGetValue: {
78424:       LOG("get path interface");
78424:       ANPPathInterfaceV0 *i = (ANPPathInterfaceV0 *) result;
78424:       InitPathInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424:       
78424:     case kTypefaceInterfaceV0_ANPGetValue: {
78424:       LOG("get typeface interface");
78424:       ANPTypefaceInterfaceV0 *i = (ANPTypefaceInterfaceV0 *) result;
78424:       InitTypeFaceInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kPaintInterfaceV0_ANPGetValue: {
78424:       LOG("get paint interface");
78424:       ANPPaintInterfaceV0 *i = (ANPPaintInterfaceV0 *) result;
78424:       InitPaintInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kCanvasInterfaceV0_ANPGetValue: {
78424:       LOG("get canvas interface");
78424:       ANPCanvasInterfaceV0 *i = (ANPCanvasInterfaceV0 *) result;
78424:       InitCanvasInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kWindowInterfaceV0_ANPGetValue: {
78424:       LOG("get window interface");
78424:       ANPWindowInterfaceV0 *i = (ANPWindowInterfaceV0 *) result;
78424:       InitWindowInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kAudioTrackInterfaceV0_ANPGetValue: {
78424:       LOG("get audio interface");
78424:       ANPAudioTrackInterfaceV0 *i = (ANPAudioTrackInterfaceV0 *) result;
78424:       InitAudioTrackInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kEventInterfaceV0_ANPGetValue: {
78424:       LOG("get event interface");
78424:       ANPEventInterfaceV0 *i = (ANPEventInterfaceV0 *) result;
78424:       InitEventInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kSystemInterfaceV0_ANPGetValue: {
78424:       LOG("get system interface");
78424:       ANPSystemInterfaceV0* i = reinterpret_cast<ANPSystemInterfaceV0*>(result);
78424:       InitSystemInterface(i);
78424:       LOG("done system interface");
78424:       return NPERR_NO_ERROR;
78424:     }
78424: 
78424:     case kSurfaceInterfaceV0_ANPGetValue: {
78424:       LOG("get surface interface");
78424:       ANPSurfaceInterfaceV0 *i = (ANPSurfaceInterfaceV0 *) result;
78424:       InitSurfaceInterface(i);
78424:       return NPERR_NO_ERROR;
78424:     }
78424:       
78424:     case kSupportedDrawingModel_ANPGetValue: {
78424:       LOG("get supported drawing model");
78424:       uint32_t* bits = reinterpret_cast<uint32_t*>(result);
78424:       *bits = kBitmap_ANPDrawingModel && kSurface_ANPDrawingModel;
78424:       return NPERR_NO_ERROR;
78424:     }  
78424: 
78424:     case kJavaContext_ANPGetValue: {
78424:       LOG("get context");
78424:       JNIEnv* env    = GetJNIForThread();
78424:       jclass cls     = env->FindClass("org/mozilla/gecko/GeckoApp");
78424:       jfieldID field = env->GetStaticFieldID(cls, "mAppContext",
78424:                                              "Lorg/mozilla/gecko/GeckoApp;");
78424:       jobject ret = env->GetStaticObjectField(cls, field);
78424:       int32_t* i  = reinterpret_cast<int32_t*>(result);
78424:       *i = reinterpret_cast<int32_t>(ret);
78424:       return NPERR_NO_ERROR;
78424:     }
78424: #endif
78424: 
69691:   // we no longer hand out any XPCOM objects
35279:   case NPNVDOMElement:
35279:     // fall through
35279:   case NPNVDOMWindow:
35279:     // fall through
35279:   case NPNVserviceManager:
35279:     // old XPCOM objects, no longer supported, but null out the out
35279:     // param to avoid crashing plugins that still try to use this.
35279:     *(nsISupports**)result = nsnull;
35279:     // fall through
19246:   default:
78424:     NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_getvalue unhandled get value: %d\n", variable));
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _setvalue(NPP npp, NPPVariable variable, void *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setvalue called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
19246:                                      (void*)npp, (int)variable));
19246: 
19246:   if (!npp)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246: 
21231:   NS_ASSERTION(inst, "null instance");
21231: 
21231:   if (!inst)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
19246:   switch (variable) {
19246: 
19246:     // we should keep backward compatibility with NPAPI where the
19246:     // actual pointer value is checked rather than its content
19246:     // when passing booleans
19246:     case NPPVpluginWindowBool: {
22548: #ifdef XP_MACOSX
22548:       // This setting doesn't apply to OS X (only to Windows and Unix/Linux).
22548:       // See https://developer.mozilla.org/En/NPN_SetValue#section_5.  Return
22548:       // NPERR_NO_ERROR here to conform to other browsers' behavior on OS X
22548:       // (e.g. Safari and Opera).
22548:       return NPERR_NO_ERROR;
22548: #else
19246:       NPBool bWindowless = (result == nsnull);
19246:       return inst->SetWindowless(bWindowless);
22548: #endif
19246:     }
19246:     case NPPVpluginTransparentBool: {
19246:       NPBool bTransparent = (result != nsnull);
19246:       return inst->SetTransparent(bTransparent);
19246:     }
19246: 
19246:     case NPPVjavascriptPushCallerBool:
19246:       {
19246:         nsresult rv;
19246:         nsCOMPtr<nsIJSContextStack> contextStack =
19246:           do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
19246:         if (NS_SUCCEEDED(rv)) {
19246:           NPBool bPushCaller = (result != nsnull);
19246:           if (bPushCaller) {
19246:             JSContext *cx;
29808:             rv = inst->GetJSContext(&cx);
19246:             if (NS_SUCCEEDED(rv))
19246:               rv = contextStack->Push(cx);
19246:           } else {
19246:             rv = contextStack->Pop(nsnull);
19246:           }
19246:         }
19246:         return NS_SUCCEEDED(rv) ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
19246:       }
19246: 
19246:     case NPPVpluginKeepLibraryInMemory: {
82172:       NPBool bCached = (result != nsnull);
82172:       return inst->SetCached(bCached);
19246:     }
19246: 
67677:     case NPPVpluginUsesDOMForCursorBool: {
79445:       bool useDOMForCursor = (result != nsnull);
67677:       return inst->SetUsesDOMForCursor(useDOMForCursor);
67677:     }
67677: 
19246: #ifdef XP_MACOSX
19246:     case NPPVpluginDrawingModel: {
19246:       if (inst) {
31406:         inst->SetDrawingModel((NPDrawingModel)NS_PTR_TO_INT32(result));
19246:         return NPERR_NO_ERROR;
19246:       }
19246:       else {
19246:         return NPERR_GENERIC_ERROR;
19246:       }
19246:     }
32019: 
32019:     case NPPVpluginEventModel: {
32019:       if (inst) {
32019:         inst->SetEventModel((NPEventModel)NS_PTR_TO_INT32(result));
32019:         return NPERR_NO_ERROR;
32019:       }
32019:       else {
32019:         return NPERR_GENERIC_ERROR;
32019:       }
32019:     }
19246: #endif
82142: #ifdef MOZ_WIDGET_ANDROID
78424:   case kRequestDrawingModel_ANPSetValue:
78424:     if (inst)
78424:       inst->SetDrawingModel(NS_PTR_TO_INT32(result));
78424:     return NPERR_NO_ERROR;
78424:   case kAcceptEvents_ANPSetValue:
78424:     return NPERR_NO_ERROR;
78424: #endif
19246:     default:
26261:       return NPERR_GENERIC_ERROR;
19246:   }
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _requestread(NPStream *pstream, NPByteRange *rangeList)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_requestread called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
19246:                                      (void*)pstream));
19246: 
19246: #ifdef PLUGIN_LOGGING
19246:   for(NPByteRange * range = rangeList; range != nsnull; range = range->next)
19246:     PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
19246:     ("%i-%i", range->offset, range->offset + range->length - 1));
19246: 
19246:   PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY, ("\n\n"));
19246:   PR_LogFlush();
19246: #endif
19246: 
19246:   if (!pstream || !rangeList || !pstream->ndata)
19246:     return NPERR_INVALID_PARAM;
19246: 
19246:   nsNPAPIPluginStreamListener* streamlistener = (nsNPAPIPluginStreamListener*)pstream->ndata;
19246: 
32799:   PRInt32 streamtype = NP_NORMAL;
19246: 
19246:   streamlistener->GetStreamType(&streamtype);
19246: 
32799:   if (streamtype != NP_SEEK)
19246:     return NPERR_STREAM_NOT_SEEKABLE;
19246: 
39118:   if (!streamlistener->mStreamInfo)
39118:     return NPERR_GENERIC_ERROR;
39118: 
39118:   nsresult rv = streamlistener->mStreamInfo
39118:     ->RequestRead((NPByteRange *)rangeList);
39118:   if (NS_FAILED(rv))
39118:     return NPERR_GENERIC_ERROR;
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: // Deprecated, only stubbed out
19246: void* NP_CALLBACK /* OJI type: JRIEnv* */
37780: _getJavaEnv()
19246: {
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
19246:   return NULL;
19246: }
19246: 
19246: const char * NP_CALLBACK
19246: _useragent(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_useragent called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
19246: 
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
70185:   if (!pluginHost) {
19246:     return nsnull;
70185:   }
19246: 
19246:   const char *retstr;
29574:   nsresult rv = pluginHost->UserAgent(&retstr);
19246:   if (NS_FAILED(rv))
19246:     return nsnull;
19246: 
19246:   return retstr;
19246: }
19246: 
19246: void * NP_CALLBACK
19246: _memalloc (uint32_t size)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN_memalloc called from the wrong thread\n"));
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
19246:   return nsMemory::Alloc(size);
19246: }
19246: 
19246: // Deprecated, only stubbed out
19246: void* NP_CALLBACK /* OJI type: jref */
19246: _getJavaPeer(NPP npp)
19246: {
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
19246:   return NULL;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _pushpopupsenabledstate(NPP npp, NPBool enabled)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_pushpopupsenabledstate called from the wrong thread\n"));
19246:     return;
19246:   }
38327:   nsNPAPIPluginInstance *inst = npp ? (nsNPAPIPluginInstance *)npp->ndata : NULL;
19246:   if (!inst)
19246:     return;
19246: 
19246:   inst->PushPopupsEnabledState(enabled);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _poppopupsenabledstate(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_poppopupsenabledstate called from the wrong thread\n"));
19246:     return;
19246:   }
38327:   nsNPAPIPluginInstance *inst = npp ? (nsNPAPIPluginInstance *)npp->ndata : NULL;
19246:   if (!inst)
19246:     return;
19246: 
19246:   inst->PopPopupsEnabledState();
19246: }
19246: 
19246: void NP_CALLBACK
19246: _pluginthreadasynccall(NPP instance, PluginThreadCallback func, void *userData)
19246: {
19246:   if (NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from the main thread\n"));
19246:   } else {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from a non main thread\n"));
19246:   }
19246:   nsRefPtr<nsPluginThreadRunnable> evt =
19246:     new nsPluginThreadRunnable(instance, func, userData);
19246: 
19246:   if (evt && evt->IsValid()) {
19246:     NS_DispatchToMainThread(evt);
19246:   }
19246: }
19246: 
23571: NPError NP_CALLBACK
23571: _getvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
23571:                 char **value, uint32_t *len)
23571: {
23571:   if (!instance) {
23571:     return NPERR_INVALID_PARAM;
23571:   }
23571: 
23571:   if (!url || !*url || !len) {
23571:     return NPERR_INVALID_URL;
23571:   }
23571: 
23571:   *len = 0;
23571: 
23571:   switch (variable) {
23571:   case NPNURLVProxy:
23571:     {
70185:       nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
70185:       nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
29574:       if (pluginHost && NS_SUCCEEDED(pluginHost->FindProxyForURL(url, value))) {
23571:         *len = *value ? PL_strlen(*value) : 0;
23571:         return NPERR_NO_ERROR;
23571:       }
23571:       break;
23571:     }
23571:   case NPNURLVCookie:
23571:     {
23571:       nsCOMPtr<nsICookieService> cookieService =
23571:         do_GetService(NS_COOKIESERVICE_CONTRACTID);
23571: 
23571:       if (!cookieService)
23571:         return NPERR_GENERIC_ERROR;
23571: 
23571:       // Make an nsURI from the url argument
23571:       nsCOMPtr<nsIURI> uri;
23571:       if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), nsDependentCString(url)))) {
23571:         return NPERR_GENERIC_ERROR;
23571:       }
23571: 
42122:       if (NS_FAILED(cookieService->GetCookieString(uri, nsnull, value)) ||
42122:           !*value) {
23571:         return NPERR_GENERIC_ERROR;
23571:       }
23571: 
42122:       *len = PL_strlen(*value);
23571:       return NPERR_NO_ERROR;
23571:     }
23571: 
23571:     break;
23571:   default:
23571:     // Fall through and return an error...
23571:     ;
23571:   }
23571: 
23571:   return NPERR_GENERIC_ERROR;
23571: }
23571: 
23571: NPError NP_CALLBACK
23571: _setvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
23571:                 const char *value, uint32_t len)
23571: {
23571:   if (!instance) {
23571:     return NPERR_INVALID_PARAM;
23571:   }
23571: 
23571:   if (!url || !*url) {
23571:     return NPERR_INVALID_URL;
23571:   }
23571: 
23571:   switch (variable) {
23571:   case NPNURLVCookie:
23571:     {
29204:       if (!url || !value || (0 >= len))
29204:         return NPERR_INVALID_PARAM;
29204: 
29204:       nsresult rv = NS_ERROR_FAILURE;
29204:       nsCOMPtr<nsIIOService> ioService(do_GetService(NS_IOSERVICE_CONTRACTID, &rv));
29204:       if (NS_FAILED(rv))
29204:         return NPERR_GENERIC_ERROR;
29204: 
29204:       nsCOMPtr<nsICookieService> cookieService = do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
29204:       if (NS_FAILED(rv))
29204:         return NPERR_GENERIC_ERROR;
29204: 
29204:       nsCOMPtr<nsIURI> uriIn;
29204:       rv = ioService->NewURI(nsDependentCString(url), nsnull, nsnull, getter_AddRefs(uriIn));
29204:       if (NS_FAILED(rv))
29204:         return NPERR_GENERIC_ERROR;
29204: 
29204:       nsCOMPtr<nsIPrompt> prompt;
29956:       nsPluginHost::GetPrompt(nsnull, getter_AddRefs(prompt));
29204: 
29204:       char *cookie = (char*)value;
29204:       char c = cookie[len];
29204:       cookie[len] = '\0';
29204:       rv = cookieService->SetCookieString(uriIn, prompt, cookie, nsnull);
29204:       cookie[len] = c;
29204:       if (NS_SUCCEEDED(rv))
23571:         return NPERR_NO_ERROR;
23571:     }
23571: 
23571:     break;
23571:   case NPNURLVProxy:
23571:     // We don't support setting proxy values, fall through...
23571:   default:
23571:     // Fall through and return an error...
23571:     ;
23571:   }
23571: 
23571:   return NPERR_GENERIC_ERROR;
23571: }
23571: 
23571: NPError NP_CALLBACK
23571: _getauthenticationinfo(NPP instance, const char *protocol, const char *host,
23571:                        int32_t port, const char *scheme, const char *realm,
23571:                        char **username, uint32_t *ulen, char **password,
23571:                        uint32_t *plen)
23571: {
23571:   if (!instance || !protocol || !host || !scheme || !realm || !username ||
23571:       !ulen || !password || !plen)
23571:     return NPERR_INVALID_PARAM;
23571: 
23571:   *username = nsnull;
23571:   *password = nsnull;
23571:   *ulen = 0;
23571:   *plen = 0;
23571: 
23571:   nsDependentCString proto(protocol);
23571: 
23571:   if (!proto.LowerCaseEqualsLiteral("http") &&
23571:       !proto.LowerCaseEqualsLiteral("https"))
23571:     return NPERR_GENERIC_ERROR;
23571: 
23571:   nsCOMPtr<nsIHttpAuthManager> authManager =
23571:     do_GetService("@mozilla.org/network/http-auth-manager;1");
23571:   if (!authManager)
23571:     return NPERR_GENERIC_ERROR;
23571: 
23571:   nsAutoString unused, uname16, pwd16;
23571:   if (NS_FAILED(authManager->GetAuthIdentity(proto, nsDependentCString(host),
23571:                                              port, nsDependentCString(scheme),
23571:                                              nsDependentCString(realm),
23571:                                              EmptyCString(), unused, uname16,
23571:                                              pwd16))) {
23571:     return NPERR_GENERIC_ERROR;
23571:   }
23571: 
23571:   NS_ConvertUTF16toUTF8 uname8(uname16);
23571:   NS_ConvertUTF16toUTF8 pwd8(pwd16);
23571: 
23571:   *username = ToNewCString(uname8);
23571:   *ulen = *username ? uname8.Length() : 0;
23571: 
23571:   *password = ToNewCString(pwd8);
23571:   *plen = *password ? pwd8.Length() : 0;
23571: 
23571:   return NPERR_NO_ERROR;
23571: }
23571: 
29937: uint32_t NP_CALLBACK
36125: _scheduletimer(NPP instance, uint32_t interval, NPBool repeat, PluginTimerFunc timerFunc)
29937: {
29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
29937:   if (!inst)
29937:     return 0;
29937: 
29937:   return inst->ScheduleTimer(interval, repeat, timerFunc);
29937: }
29937: 
29937: void NP_CALLBACK
29937: _unscheduletimer(NPP instance, uint32_t timerID)
29937: {
29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
29937:   if (!inst)
29937:     return;
29937: 
29937:   inst->UnscheduleTimer(timerID);
29937: }
29937: 
32019: NPError NP_CALLBACK
32019: _popupcontextmenu(NPP instance, NPMenu* menu)
32019: {
32019:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
32019:   if (!inst)
32019:     return NPERR_GENERIC_ERROR;
32019: 
32019:   return inst->PopUpContextMenu(menu);
32019: }
32019: 
32019: NPBool NP_CALLBACK
32019: _convertpoint(NPP instance, double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
32019:   if (!inst)
79533:     return false;
32019: 
32019:   return inst->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY, destSpace);
32019: }
32019: 
60021: void NP_CALLBACK
60021: _urlredirectresponse(NPP instance, void* notifyData, NPBool allow)
60021: {
60021:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
60021:   if (!inst) {
60021:     return;
60021:   }
60021: 
60021:   inst->URLRedirectResponse(notifyData, allow);
60021: }
60021: 
36125: } /* namespace parent */
36125: } /* namespace plugins */
36125: } /* namespace mozilla */
