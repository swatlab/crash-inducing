38727: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
38727:  * ***** BEGIN LICENSE BLOCK *****
38727:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38727:  *
38727:  * The contents of this file are subject to the Mozilla Public License Version
38727:  * 1.1 (the "License"); you may not use this file except in compliance with
38727:  * the License. You may obtain a copy of the License at
38727:  * http://www.mozilla.org/MPL/
38727:  *
38727:  * Software distributed under the License is distributed on an "AS IS" basis,
38727:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38727:  * for the specific language governing rights and limitations under the
38727:  * License.
38727:  *
38727:  * The Original Code is Mozilla Foundation code.
38727:  *
38727:  * The Initial Developer of the Original Code is Mozilla Foundation.
38727:  * Portions created by the Initial Developer are Copyright (C) 2010
38727:  * the Initial Developer. All Rights Reserved.
38727:  *
38727:  * Contributor(s):
38727:  *   Bas Schouten <bschouten@mozilla.com>
38727:  *
38727:  * Alternatively, the contents of this file may be used under the terms of
38727:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38727:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38727:  * in which case the provisions of the GPL or the LGPL are applicable instead
38727:  * of those above. If you wish to allow use of your version of this file only
38727:  * under the terms of either the GPL or the LGPL, and not to allow others to
38727:  * use your version of this file under the terms of the MPL, indicate your
38727:  * decision by deleting the provisions above and replace them with the notice
38727:  * and other provisions required by the GPL or the LGPL. If you do not delete
38727:  * the provisions above, a recipient may use your version of this file under
38727:  * the terms of any one of the MPL, the GPL or the LGPL.
38727:  *
38727:  * ***** END LICENSE BLOCK ***** */
38727: 
38727: #include "gfxDWriteFonts.h"
40504: #include "gfxDWriteShaper.h"
43527: #include "gfxHarfBuzzShaper.h"
38727: #include "gfxDWriteFontList.h"
38727: #include "gfxContext.h"
38727: #include <dwrite.h>
38727: 
38727: #include "gfxDWriteTextAnalysis.h"
38727: 
43526: #include "harfbuzz/hb-blob.h"
43526: 
38727: // Chosen this as to resemble DWrite's own oblique face style.
38727: #define OBLIQUE_SKEW_FACTOR 0.3
38727: 
43475: // This is also in gfxGDIFont.cpp. Would be nice to put it somewhere common,
43475: // but we can't declare it in the gfxFont.h or gfxFontUtils.h headers
43475: // because those are exported, and the cairo headers aren't.
43475: static inline cairo_antialias_t
43475: GetCairoAntialiasOption(gfxFont::AntialiasOption anAntialiasOption)
43475: {
43475:     switch (anAntialiasOption) {
43475:     default:
43475:     case gfxFont::kAntialiasDefault:
43475:         return CAIRO_ANTIALIAS_DEFAULT;
43475:     case gfxFont::kAntialiasNone:
43475:         return CAIRO_ANTIALIAS_NONE;
43475:     case gfxFont::kAntialiasGrayscale:
43475:         return CAIRO_ANTIALIAS_GRAY;
43475:     case gfxFont::kAntialiasSubpixel:
43475:         return CAIRO_ANTIALIAS_SUBPIXEL;
43475:     }
43475: }
43475: 
59850: // Code to determine whether Windows is set to use ClearType font smoothing;
59850: // based on private functions in cairo-win32-font.c
59850: 
59850: #ifndef SPI_GETFONTSMOOTHINGTYPE
59850: #define SPI_GETFONTSMOOTHINGTYPE 0x200a
59850: #endif
59850: #ifndef FE_FONTSMOOTHINGCLEARTYPE
59850: #define FE_FONTSMOOTHINGCLEARTYPE 2
59850: #endif
59850: 
59850: static bool
59850: HasClearType()
59850: {
59850:     OSVERSIONINFO versionInfo;
59850:     versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
59850: 
59850:     return (GetVersionEx(&versionInfo) &&
59850:             (versionInfo.dwMajorVersion > 5 ||
59850:              (versionInfo.dwMajorVersion == 5 &&
59850:               versionInfo.dwMinorVersion >= 1))); // XP or newer
59850: }
59850: 
59850: static bool
59850: UsingClearType()
59850: {
59850:     BOOL fontSmoothing;
59850:     if (!SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &fontSmoothing, 0) ||
59850:         !fontSmoothing)
59850:     {
59850:         return false;    
59850:     }
59850: 
59850:     if (!HasClearType()) {
59850:         return false;
59850:     }
59850: 
59850:     UINT type;
59850:     if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
59850:         type == FE_FONTSMOOTHINGCLEARTYPE)
59850:     {
59850:         return true;
59850:     }
59850:     return false;
59850: }
59850: 
38727: ////////////////////////////////////////////////////////////////////////////////
38727: // gfxDWriteFont
38727: gfxDWriteFont::gfxDWriteFont(gfxFontEntry *aFontEntry,
39306:                              const gfxFontStyle *aFontStyle,
43475:                              PRBool aNeedsBold,
43475:                              AntialiasOption anAAOption)
43475:     : gfxFont(aFontEntry, aFontStyle, anAAOption)
38727:     , mCairoFontFace(nsnull)
38727:     , mCairoScaledFont(nsnull)
61083:     , mMetrics(nsnull)
38727:     , mNeedsOblique(PR_FALSE)
43475:     , mNeedsBold(aNeedsBold)
61074:     , mUseSubpixelPositions(PR_FALSE)
38727: {
61422:     gfxDWriteFontEntry *fe =
61422:         static_cast<gfxDWriteFontEntry*>(aFontEntry);
61422:     nsresult rv;
61422:     DWRITE_FONT_SIMULATIONS sims = DWRITE_FONT_SIMULATIONS_NONE;
61422:     if ((GetStyle()->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) &&
61422:         !fe->IsItalic()) {
61422:             // For this we always use the font_matrix for uniformity. Not the
61422:             // DWrite simulation.
61422:             mNeedsOblique = PR_TRUE;
61422:     }
61422:     if (aNeedsBold) {
61422:         sims |= DWRITE_FONT_SIMULATIONS_BOLD;
61422:     }
61422: 
61422:     rv = fe->CreateFontFace(getter_AddRefs(mFontFace), sims);
61422: 
61422:     if (NS_FAILED(rv)) {
61422:         mIsValid = PR_FALSE;
61422:         return;
61422:     }
61422: 
61083:     if ((anAAOption == gfxFont::kAntialiasDefault && UsingClearType()) ||
61083:         anAAOption == gfxFont::kAntialiasSubpixel)
61083:     {
61083:         mUseSubpixelPositions = PR_TRUE;
61083:         // note that this may be reset to FALSE if we determine that a bitmap
61083:         // strike is going to be used
61083:     }
61083: 
61422:     ComputeMetrics();
61422: 
61083:     if (FontCanSupportHarfBuzz()) {
61083:         mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
61083:     }
61083: }
61083: 
61083: gfxDWriteFont::~gfxDWriteFont()
61083: {
61083:     if (mCairoFontFace) {
61083:         cairo_font_face_destroy(mCairoFontFace);
61083:     }
61083:     if (mCairoScaledFont) {
61083:         cairo_scaled_font_destroy(mCairoScaledFont);
61083:     }
61083:     delete mMetrics;
61083: }
61083: 
61083: gfxFont*
61083: gfxDWriteFont::CopyWithAntialiasOption(AntialiasOption anAAOption)
61083: {
61083:     return new gfxDWriteFont(static_cast<gfxDWriteFontEntry*>(mFontEntry.get()),
61083:                              &mStyle, mNeedsBold, anAAOption);
61083: }
61083: 
61083: void
43527: gfxDWriteFont::CreatePlatformShaper()
43527: {
43527:     mPlatformShaper = new gfxDWriteShaper(this);
43527: }
43527: 
38727: nsString
38727: gfxDWriteFont::GetUniqueName()
38727: {
38727:     return mFontEntry->Name();
38727: }
38727: 
38727: const gfxFont::Metrics&
38727: gfxDWriteFont::GetMetrics()
38727: {
61083:     return *mMetrics;
38727: }
38727: 
38727: void
38727: gfxDWriteFont::ComputeMetrics()
38727: {
38727:     DWRITE_FONT_METRICS fontMetrics;
38727:     mFontFace->GetMetrics(&fontMetrics);
38727: 
39352:     if (mStyle.sizeAdjust != 0.0) {
39352:         gfxFloat aspect = (gfxFloat)fontMetrics.xHeight /
39352:                    fontMetrics.designUnitsPerEm;
39352:         mAdjustedSize = mStyle.GetAdjustedSize(aspect);
39352:     } else {
39352:         mAdjustedSize = mStyle.size;
39352:     }
39352: 
61260:     gfxDWriteFontEntry *fe =
61260:         static_cast<gfxDWriteFontEntry*>(mFontEntry.get());
61260:     if (fe->IsCJKFont() && HasBitmapStrikeForSize(NS_lround(mAdjustedSize))) {
61074:         mAdjustedSize = NS_lround(mAdjustedSize);
61074:         mUseSubpixelPositions = PR_FALSE;
61104:         // if we have bitmaps, we need to tell Cairo NOT to use subpixel AA,
61104:         // to avoid the manual-subpixel codepath in cairo-d2d-surface.cpp
61104:         // which fails to render bitmap glyphs (see bug 626299)
61104:         if (mAntialiasOption == kAntialiasDefault && UsingClearType()) {
61104:             mAntialiasOption = kAntialiasGrayscale;
61104:         }
61074:     }
61074: 
61083:     mMetrics = new gfxFont::Metrics;
61083:     ::memset(mMetrics, 0, sizeof(*mMetrics));
61083: 
61083:     mMetrics->xHeight =
38727:         ((gfxFloat)fontMetrics.xHeight /
39352:                    fontMetrics.designUnitsPerEm) * mAdjustedSize;
40505: 
61083:     mMetrics->maxAscent = 
40505:         ceil(((gfxFloat)fontMetrics.ascent /
40505:                    fontMetrics.designUnitsPerEm) * mAdjustedSize);
61083:     mMetrics->maxDescent = 
40505:         ceil(((gfxFloat)fontMetrics.descent /
40505:                    fontMetrics.designUnitsPerEm) * mAdjustedSize);
61083:     mMetrics->maxHeight = mMetrics->maxAscent + mMetrics->maxDescent;
40505: 
61083:     mMetrics->emHeight = mAdjustedSize;
61083:     mMetrics->emAscent = mMetrics->emHeight *
61083:         mMetrics->maxAscent / mMetrics->maxHeight;
61083:     mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
40505: 
61083:     mMetrics->maxAdvance = mAdjustedSize;
40505: 
48914:     // try to get the true maxAdvance value from 'hhea'
48914:     PRUint8 *tableData;
48914:     PRUint32 len;
48914:     void *tableContext = NULL;
48914:     BOOL exists;
48914:     HRESULT hr =
48914:         mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('h', 'h', 'e', 'a'),
48914:                                    (const void**)&tableData,
48914:                                    &len,
48914:                                    &tableContext,
48914:                                    &exists);
48914:     if (SUCCEEDED(hr)) {
48914:         if (exists && len >= sizeof(mozilla::HheaTable)) {
48914:             const mozilla::HheaTable* hhea =
48914:                 reinterpret_cast<const mozilla::HheaTable*>(tableData);
61083:             mMetrics->maxAdvance = ((gfxFloat)PRUint16(hhea->advanceWidthMax) /
48914:                        fontMetrics.designUnitsPerEm) * mAdjustedSize;
48914:         }
48914:         mFontFace->ReleaseFontTable(tableContext);
48914:     }
48914: 
61083:     mMetrics->internalLeading = NS_MAX(mMetrics->maxHeight - mMetrics->emHeight, 0.0);
61083:     mMetrics->externalLeading = 
40505:         ceil(((gfxFloat)fontMetrics.lineGap /
40505:                    fontMetrics.designUnitsPerEm) * mAdjustedSize);
38727: 
38727:     UINT16 glyph = (PRUint16)GetSpaceGlyph();
38727:     DWRITE_GLYPH_METRICS metrics;
38727:     mFontFace->GetDesignGlyphMetrics(&glyph, 1, &metrics);
61083:     mMetrics->spaceWidth = 
38727:         ((gfxFloat)metrics.advanceWidth /
39352:                    fontMetrics.designUnitsPerEm) * mAdjustedSize;
48914: 
48914:     // try to get aveCharWidth from the OS/2 table, fall back to measuring 'x'
48914:     // if the table is not available
61083:     mMetrics->aveCharWidth = 0;
48914:     hr = mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('O', 'S', '/', '2'),
48914:                                     (const void**)&tableData,
48914:                                     &len,
48914:                                     &tableContext,
48914:                                     &exists);
48914:     if (SUCCEEDED(hr)) {
48914:         if (exists && len >= 4) {
48914:             // Not checking against sizeof(mozilla::OS2Table) here because older
48914:             // versions of the table have different sizes; we only need the first
48914:             // two 16-bit fields here.
48914:             const mozilla::OS2Table* os2 =
48914:                 reinterpret_cast<const mozilla::OS2Table*>(tableData);
61083:             mMetrics->aveCharWidth = ((gfxFloat)PRInt16(os2->xAvgCharWidth) /
48914:                        fontMetrics.designUnitsPerEm) * mAdjustedSize;
48914:         }
48914:         mFontFace->ReleaseFontTable(tableContext);
48914:     }
48914: 
48914:     UINT32 ucs;
61083:     if (mMetrics->aveCharWidth < 1) {
48914:         ucs = L'x';
38727:         if (SUCCEEDED(mFontFace->GetGlyphIndicesA(&ucs, 1, &glyph)) &&
38727:             SUCCEEDED(mFontFace->GetDesignGlyphMetrics(&glyph, 1, &metrics))) {    
61083:             mMetrics->aveCharWidth = 
38727:                 ((gfxFloat)metrics.advanceWidth /
39352:                            fontMetrics.designUnitsPerEm) * mAdjustedSize;
38727:         } else {
38727:             // Let's just assume the X is square.
61083:             mMetrics->aveCharWidth = 
38727:                 ((gfxFloat)fontMetrics.xHeight /
39352:                            fontMetrics.designUnitsPerEm) * mAdjustedSize;
38727:         }
48914:     }
48914: 
38727:     ucs = L'0';
46157:     if (SUCCEEDED(mFontFace->GetGlyphIndicesA(&ucs, 1, &glyph)) &&
38727:         SUCCEEDED(mFontFace->GetDesignGlyphMetrics(&glyph, 1, &metrics))) {
61083:         mMetrics->zeroOrAveCharWidth = 
38727:             ((gfxFloat)metrics.advanceWidth /
39352:                        fontMetrics.designUnitsPerEm) * mAdjustedSize;
38727:     } else {
61083:         mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
38727:     }
48914: 
61083:     mMetrics->underlineOffset = 
38727:         ((gfxFloat)fontMetrics.underlinePosition /
39352:                    fontMetrics.designUnitsPerEm) * mAdjustedSize;
61083:     mMetrics->underlineSize = 
38727:         ((gfxFloat)fontMetrics.underlineThickness /
39352:                    fontMetrics.designUnitsPerEm) * mAdjustedSize;
61083:     mMetrics->strikeoutOffset = 
38727:         ((gfxFloat)fontMetrics.strikethroughPosition /
39352:                    fontMetrics.designUnitsPerEm) * mAdjustedSize;
61083:     mMetrics->strikeoutSize = 
38727:         ((gfxFloat)fontMetrics.strikethroughThickness /
39352:                    fontMetrics.designUnitsPerEm) * mAdjustedSize;
61083:     mMetrics->superscriptOffset = 0;
61083:     mMetrics->subscriptOffset = 0;
38727: 
61083:     mFUnitsConvFactor = float(mAdjustedSize / fontMetrics.designUnitsPerEm);
43527: 
61083:     SanitizeMetrics(mMetrics, GetFontEntry()->mIsBadUnderlineFont);
40042: 
40042: #if 0
40042:     printf("Font: %p (%s) size: %f\n", this,
40042:            NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size);
61083:     printf("    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics->emHeight, mMetrics->emAscent, mMetrics->emDescent);
61083:     printf("    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics->maxAscent, mMetrics->maxDescent, mMetrics->maxAdvance);
61083:     printf("    internalLeading: %f externalLeading: %f\n", mMetrics->internalLeading, mMetrics->externalLeading);
48914:     printf("    spaceWidth: %f aveCharWidth: %f zeroOrAve: %f xHeight: %f\n",
61083:            mMetrics->spaceWidth, mMetrics->aveCharWidth, mMetrics->zeroOrAveCharWidth, mMetrics->xHeight);
40042:     printf("    uOff: %f uSize: %f stOff: %f stSize: %f supOff: %f subOff: %f\n",
61083:            mMetrics->underlineOffset, mMetrics->underlineSize, mMetrics->strikeoutOffset, mMetrics->strikeoutSize,
61083:            mMetrics->superscriptOffset, mMetrics->subscriptOffset);
40042: #endif
38727: }
38727: 
61074: using namespace mozilla; // for AutoSwap_* types
61074: 
61074: struct EBLCHeader {
61074:     AutoSwap_PRUint32 version;
61074:     AutoSwap_PRUint32 numSizes;
61074: };
61074: 
61074: struct SbitLineMetrics {
61074:     PRInt8  ascender;
61074:     PRInt8  descender;
61074:     PRUint8 widthMax;
61074:     PRInt8  caretSlopeNumerator;
61074:     PRInt8  caretSlopeDenominator;
61074:     PRInt8  caretOffset;
61074:     PRInt8  minOriginSB;
61074:     PRInt8  minAdvanceSB;
61074:     PRInt8  maxBeforeBL;
61074:     PRInt8  minAfterBL;
61074:     PRInt8  pad1;
61074:     PRInt8  pad2;
61074: };
61074: 
61074: struct BitmapSizeTable {
61074:     AutoSwap_PRUint32 indexSubTableArrayOffset;
61074:     AutoSwap_PRUint32 indexTablesSize;
61074:     AutoSwap_PRUint32 numberOfIndexSubTables;
61074:     AutoSwap_PRUint32 colorRef;
61074:     SbitLineMetrics   hori;
61074:     SbitLineMetrics   vert;
61074:     AutoSwap_PRUint16 startGlyphIndex;
61074:     AutoSwap_PRUint16 endGlyphIndex;
61074:     PRUint8           ppemX;
61074:     PRUint8           ppemY;
61074:     PRUint8           bitDepth;
61074:     PRUint8           flags;
61074: };
61074: 
61074: typedef EBLCHeader EBSCHeader;
61074: 
61074: struct BitmapScaleTable {
61074:     SbitLineMetrics   hori;
61074:     SbitLineMetrics   vert;
61074:     PRUint8           ppemX;
61074:     PRUint8           ppemY;
61074:     PRUint8           substitutePpemX;
61074:     PRUint8           substitutePpemY;
61074: };
61074: 
61074: PRBool
61074: gfxDWriteFont::HasBitmapStrikeForSize(PRUint32 aSize)
61074: {
61074:     PRUint8 *tableData;
61074:     PRUint32 len;
61074:     void *tableContext;
61074:     BOOL exists;
61074:     HRESULT hr =
61074:         mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('E', 'B', 'L', 'C'),
61074:                                    (const void**)&tableData, &len,
61074:                                    &tableContext, &exists);
61074:     if (FAILED(hr)) {
61074:         return PR_FALSE;
61074:     }
61074: 
61074:     PRBool hasStrike = PR_FALSE;
61074:     // not really a loop, but this lets us use 'break' to skip out of the block
61074:     // as soon as we know the answer, and skips it altogether if the table is
61074:     // not present
61074:     while (exists) {
61074:         if (len < sizeof(EBLCHeader)) {
61074:             break;
61074:         }
61074:         const EBLCHeader *hdr = reinterpret_cast<const EBLCHeader*>(tableData);
61074:         if (hdr->version != 0x00020000) {
61074:             break;
61074:         }
61074:         PRUint32 numSizes = hdr->numSizes;
61074:         if (numSizes > 0xffff) { // sanity-check, prevent overflow below
61074:             break;
61074:         }
61074:         if (len < sizeof(EBLCHeader) + numSizes * sizeof(BitmapSizeTable)) {
61074:             break;
61074:         }
61074:         const BitmapSizeTable *sizeTable =
61074:             reinterpret_cast<const BitmapSizeTable*>(hdr + 1);
61074:         for (PRUint32 i = 0; i < numSizes; ++i, ++sizeTable) {
61074:             if (sizeTable->ppemX == aSize && sizeTable->ppemY == aSize) {
61074:                 // we ignore a strike that contains fewer than 4 glyphs,
61074:                 // as that probably indicates a font such as Courier New
61074:                 // that provides bitmaps ONLY for the "shading" characters
61074:                 // U+2591..2593
61074:                 hasStrike = (PRUint16(sizeTable->endGlyphIndex) >=
61074:                              PRUint16(sizeTable->startGlyphIndex) + 3);
61074:                 break;
61074:             }
61074:         }
61074:         // if we reach here, we didn't find a strike; unconditionally break
61074:         // out of the while-loop block
61074:         break;
61074:     }
61074:     mFontFace->ReleaseFontTable(tableContext);
61074: 
61074:     if (hasStrike) {
61074:         return PR_TRUE;
61074:     }
61074: 
61074:     // if we didn't find a real strike, check if the font calls for scaling
61074:     // another bitmap to this size
61074:     hr = mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('E', 'B', 'S', 'C'),
61074:                                     (const void**)&tableData, &len,
61074:                                     &tableContext, &exists);
61074:     if (FAILED(hr)) {
61074:         return PR_FALSE;
61074:     }
61074: 
61074:     while (exists) {
61074:         if (len < sizeof(EBSCHeader)) {
61074:             break;
61074:         }
61074:         const EBSCHeader *hdr = reinterpret_cast<const EBSCHeader*>(tableData);
61074:         if (hdr->version != 0x00020000) {
61074:             break;
61074:         }
61074:         PRUint32 numSizes = hdr->numSizes;
61074:         if (numSizes > 0xffff) {
61074:             break;
61074:         }
61074:         if (len < sizeof(EBSCHeader) + numSizes * sizeof(BitmapScaleTable)) {
61074:             break;
61074:         }
61074:         const BitmapScaleTable *scaleTable =
61074:             reinterpret_cast<const BitmapScaleTable*>(hdr + 1);
61074:         for (PRUint32 i = 0; i < numSizes; ++i, ++scaleTable) {
61074:             if (scaleTable->ppemX == aSize && scaleTable->ppemY == aSize) {
61074:                 hasStrike = PR_TRUE;
61074:                 break;
61074:             }
61074:         }
61074:         break;
61074:     }
61074:     mFontFace->ReleaseFontTable(tableContext);
61074: 
61074:     return hasStrike;
61074: }
61074: 
38727: PRUint32
38727: gfxDWriteFont::GetSpaceGlyph()
38727: {
38727:     UINT32 ucs = L' ';
38727:     UINT16 glyph;
38727:     HRESULT hr;
38727:     hr = mFontFace->GetGlyphIndicesA(&ucs, 1, &glyph);
38727:     if (FAILED(hr)) {
38727:         return 0;
38727:     }
38727:     return glyph;
38727: }
38727: 
38727: PRBool
38727: gfxDWriteFont::SetupCairoFont(gfxContext *aContext)
38727: {
38727:     cairo_scaled_font_t *scaledFont = CairoScaledFont();
38727:     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
38727:         // Don't cairo_set_scaled_font as that would propagate the error to
38727:         // the cairo_t, precluding any further drawing.
38727:         return PR_FALSE;
38727:     }
38727:     cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
38727:     return PR_TRUE;
38727: }
38727: 
61083: PRBool
61083: gfxDWriteFont::IsValid()
61083: {
61083:     return mFontFace != NULL;
61083: }
61083: 
61083: IDWriteFontFace*
61083: gfxDWriteFont::GetFontFace()
61083: {
61083:     return  mFontFace.get();
61083: }
61083: 
38727: cairo_font_face_t *
38727: gfxDWriteFont::CairoFontFace()
38727: {
38727:     if (!mCairoFontFace) {
38727: #ifdef CAIRO_HAS_DWRITE_FONT
38727:         mCairoFontFace = 
38727:             cairo_dwrite_font_face_create_for_dwrite_fontface(
38727:             ((gfxDWriteFontEntry*)mFontEntry.get())->mFont, mFontFace);
38727: #endif
38727:     }
38727:     return mCairoFontFace;
38727: }
38727: 
38727: 
38727: cairo_scaled_font_t *
38727: gfxDWriteFont::CairoScaledFont()
38727: {
38727:     if (!mCairoScaledFont) {
38727:         cairo_matrix_t sizeMatrix;
38727:         cairo_matrix_t identityMatrix;
38727: 
39352:         cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
38727:         cairo_matrix_init_identity(&identityMatrix);
38727: 
38727:         cairo_font_options_t *fontOptions = cairo_font_options_create();
38727:         if (mNeedsOblique) {
38727:             double skewfactor = OBLIQUE_SKEW_FACTOR;
38727: 
38727:             cairo_matrix_t style;
38727:             cairo_matrix_init(&style,
38727:                               1,                //xx
38727:                               0,                //yx
38727:                               -1 * skewfactor,  //xy
38727:                               1,                //yy
38727:                               0,                //x0
38727:                               0);               //y0
38727:             cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
38727:         }
38727: 
43475:         if (mAntialiasOption != kAntialiasDefault) {
43475:             cairo_font_options_set_antialias(fontOptions,
43475:                 GetCairoAntialiasOption(mAntialiasOption));
43475:         }
43475: 
38727:         mCairoScaledFont = cairo_scaled_font_create(CairoFontFace(),
38727:                                                     &sizeMatrix,
38727:                                                     &identityMatrix,
38727:                                                     fontOptions);
38727:         cairo_font_options_destroy(fontOptions);
38727:     }
38727: 
39352:     NS_ASSERTION(mAdjustedSize == 0.0 ||
38727:                  cairo_scaled_font_status(mCairoScaledFont) 
38727:                    == CAIRO_STATUS_SUCCESS,
38727:                  "Failed to make scaled font");
38727: 
38727:     return mCairoScaledFont;
38727: }
43526: 
43526: // Access to font tables packaged in hb_blob_t form
43526: 
43526: // object attached to the Harfbuzz blob, used to release
43526: // the table when the blob is destroyed
43526: class FontTableRec {
43526: public:
43526:     FontTableRec(IDWriteFontFace *aFontFace, void *aContext)
43526:         : mFontFace(aFontFace), mContext(aContext)
43526:     { }
43526: 
43526:     ~FontTableRec() {
43526:         mFontFace->ReleaseFontTable(mContext);
43526:     }
43526: 
43526: private:
43526:     IDWriteFontFace *mFontFace;
43526:     void            *mContext;
43526: };
43526: 
43526: /*static*/ void
43526: gfxDWriteFont::DestroyBlobFunc(void* aUserData)
43526: {
43526:     FontTableRec *ftr = static_cast<FontTableRec*>(aUserData);
43526:     delete ftr;
43526: }
43526: 
43526: hb_blob_t *
43526: gfxDWriteFont::GetFontTable(PRUint32 aTag)
43526: {
43526:     const void *data;
43526:     UINT32      size;
43526:     void       *context;
43526:     BOOL        exists;
43526:     HRESULT hr = mFontFace->TryGetFontTable(NS_SWAP32(aTag),
43526:                                             &data, &size, &context, &exists);
43526:     if (SUCCEEDED(hr) && exists) {
43526:         FontTableRec *ftr = new FontTableRec(mFontFace, context);
43526:         return hb_blob_create(static_cast<const char*>(data), size,
43526:                               HB_MEMORY_MODE_READONLY,
43526:                               DestroyBlobFunc, ftr);
43526:     }
43526: 
55084:     if (mFontEntry->IsUserFont() && !mFontEntry->IsLocalUserFont()) {
55084:         // for downloaded fonts, there may be layout tables cached in the entry
55084:         // even though they're absent from the sanitized platform font
58944:         hb_blob_t *blob;
58944:         if (mFontEntry->GetExistingFontTable(aTag, &blob)) {
58944:             return blob;
58944:         }
55084:     }
55084: 
51967:     return nsnull;
43526: }
59850: 
61086: PRBool
61086: gfxDWriteFont::ProvidesGlyphWidths()
61086: {
61086:     return !mUseSubpixelPositions ||
61086:            (mFontFace->GetSimulations() & DWRITE_FONT_SIMULATIONS_BOLD);
61086: }
61086: 
59850: PRInt32
61073: gfxDWriteFont::GetGlyphWidth(gfxContext *aCtx, PRUint16 aGID)
59850: {
59850:     if (!mGlyphWidths.IsInitialized()) {
59850:         mGlyphWidths.Init(200);
59850:     }
59850: 
61073:     PRInt32 width = -1;
59850:     if (mGlyphWidths.Get(aGID, &width)) {
59850:         return width;
59850:     }
59850: 
59850:     DWRITE_GLYPH_METRICS glyphMetrics;
61073:     HRESULT hr;
61074:     if (mUseSubpixelPositions) {
61073:         hr = mFontFace->GetDesignGlyphMetrics(
61073:                   &aGID, 1, &glyphMetrics, FALSE);
61073:         if (SUCCEEDED(hr)) {
61073:             width =
61073:                 NS_lround(glyphMetrics.advanceWidth * mFUnitsConvFactor *
61073:                           65536.0);
61073:         }
61073:     } else {
61073:         hr = mFontFace->GetGdiCompatibleGlyphMetrics(
61083:                   FLOAT(mAdjustedSize), 1.0f, nsnull, FALSE,
59850:                   &aGID, 1, &glyphMetrics, FALSE);
61073:         if (SUCCEEDED(hr)) {
61073:             width =
61073:                 NS_lround(glyphMetrics.advanceWidth * mFUnitsConvFactor) << 16;
61073:         }
61073:     }
59850: 
59850:     mGlyphWidths.Put(aGID, width);
59850:     return width;
59850: }
