    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript bytecode interpreter.
    1:  */
    1: #include "jsstddef.h"
    1: #include <stdio.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
    1: #include "jsconfig.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058: #include "jsdtracef.h"
 7058: #endif
 7058: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
12551: #ifdef js_invoke_c__
12551: 
11377: uint32
14755: js_GenerateShape(JSContext *cx, JSBool gcLocked)
11377: {
11377:     JSRuntime *rt;
11377:     uint32 shape;
11377: 
11377:     rt = cx->runtime;
11377:     shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
11377:     JS_ASSERT(shape != 0);
11377:     if (shape & SHAPE_OVERFLOW_BIT) {
11377:         rt->gcPoke = JS_TRUE;
14755:         js_GC(cx, gcLocked ? GC_LOCK_HELD : GC_NORMAL);
11377:         shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
11377:         JS_ASSERT(shape != 0);
11377:         JS_ASSERT_IF(shape & SHAPE_OVERFLOW_BIT,
11377:                      JS_PROPERTY_CACHE(cx).disabled);
11377:     }
11377:     return shape;
11377: }
11377: 
11377: void
11377: js_FillPropertyCache(JSContext *cx, JSObject *obj, jsuword kshape,
11377:                      uintN scopeIndex, uintN protoIndex,
11377:                      JSObject *pobj, JSScopeProperty *sprop,
11377:                      JSPropCacheEntry **entryp)
11377: {
11377:     JSPropertyCache *cache;
11377:     jsbytecode *pc;
11377:     JSScope *scope;
11377:     JSOp op;
11377:     const JSCodeSpec *cs;
11377:     jsuword vword;
11377:     ptrdiff_t pcoff;
11377:     jsuword khash;
11377:     JSAtom *atom;
11377:     JSPropCacheEntry *entry;
11377: 
11377:     cache = &JS_PROPERTY_CACHE(cx);
13168:     pc = cx->fp->regs->pc;
11377:     if (cache->disabled) {
11377:         PCMETER(cache->disfills++);
11377:         *entryp = NULL;
11377:         return;
11377:     }
11377: 
11377:     /*
11377:      * Check for fill from js_SetPropertyHelper where the setter removed sprop
11377:      * from pobj's scope (via unwatch or delete, e.g.).
11377:      */
11377:     scope = OBJ_SCOPE(pobj);
11377:     JS_ASSERT(scope->object == pobj);
11377:     if (!SCOPE_HAS_PROPERTY(scope, sprop)) {
11377:         PCMETER(cache->oddfills++);
14174:         *entryp = NULL;
11377:         return;
11377:     }
11377: 
12472:     /*
12472:      * Check for overdeep scope and prototype chain. Because resolve, getter,
12472:      * and setter hooks can change the prototype chain using JS_SetPrototype
12472:      * after js_LookupPropertyWithFlags has returned the nominal protoIndex,
12472:      * we have to validate protoIndex if it is non-zero. If it is zero, then
12472:      * we know thanks to the SCOPE_HAS_PROPERTY test above, and from the fact
12472:      * that obj == pobj, that protoIndex is invariant.
12472:      *
12472:      * The scopeIndex can't be wrong. We require JS_SetParent calls to happen
12472:      * before any running script might consult a parent-linked scope chain. If
12472:      * this requirement is not satisfied, the fill in progress will never hit,
12472:      * but vcap vs. scope shape tests ensure nothing malfunctions.
12472:      */
12472:     JS_ASSERT_IF(scopeIndex == 0 && protoIndex == 0, obj == pobj);
12472:     if (protoIndex != 0) {
12472:         JSObject *tmp;
12472: 
12472:         JS_ASSERT(pobj != obj);
12472:         protoIndex = 1;
12472:         tmp = obj;
13342:         for (;;) {
13342:             tmp = OBJ_GET_PROTO(cx, tmp);
13342:             if (!tmp) {
13342:                 PCMETER(cache->noprotos++);
14174:                 *entryp = NULL;
13342:                 return;
13342:             }
12472:             if (tmp == pobj)
12472:                 break;
12472:             ++protoIndex;
12472:         }
12472:     }
11377:     if (scopeIndex > PCVCAP_SCOPEMASK || protoIndex > PCVCAP_PROTOMASK) {
11377:         PCMETER(cache->longchains++);
14174:         *entryp = NULL;
11377:         return;
11377:     }
11377: 
11377:     /*
11377:      * Optimize the cached vword based on our parameters and the current pc's
11377:      * opcode format flags.
11377:      */
11377:     op = (JSOp) *pc;
11377:     cs = &js_CodeSpec[op];
11377: 
11377:     do {
11377:         /*
11377:          * Check for a prototype "plain old method" callee computation. What
11377:          * is a plain old method? It's a function-valued property with stub
11377:          * getter and setter, so get of a function is idempotent and set is
11377:          * transparent.
11377:          */
11377:         if (cs->format & JOF_CALLOP) {
11377:             if (SPROP_HAS_STUB_GETTER(sprop) &&
11377:                 SPROP_HAS_VALID_SLOT(sprop, scope)) {
11377:                 jsval v;
11377: 
11377:                 v = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
11377:                 if (VALUE_IS_FUNCTION(cx, v)) {
11377:                     /*
11377:                      * Great, we have a function-valued prototype property
11377:                      * where the getter is JS_PropertyStub. The type id in
11377:                      * pobj's scope does not evolve with changes to property
11377:                      * values, however.
11377:                      *
11377:                      * So here, on first cache fill for this method, we brand
11377:                      * the scope with a new shape and set the SCOPE_BRANDED
11377:                      * flag.  Once this scope flag is set, any write that adds
11377:                      * or deletes a function-valued plain old property in
11377:                      * scope->object will result in shape being regenerated.
11377:                      */
11377:                     if (!SCOPE_IS_BRANDED(scope)) {
11377:                         PCMETER(cache->brandfills++);
11377: #ifdef DEBUG_notme
11377:                         fprintf(stderr,
11377:                             "branding %p (%s) for funobj %p (%s), kshape %lu\n",
11377:                             pobj, LOCKED_OBJ_GET_CLASS(pobj)->name,
11377:                             JSVAL_TO_OBJECT(v),
11377:                             JS_GetFunctionName(GET_FUNCTION_PRIVATE(cx,
11377:                                                  JSVAL_TO_OBJECT(v))),
11377:                             kshape);
11377: #endif
12307:                         SCOPE_MAKE_UNIQUE_SHAPE(cx, scope);
11377:                         SCOPE_SET_BRANDED(scope);
11377:                         kshape = scope->shape;
11377:                     }
11377:                     vword = JSVAL_OBJECT_TO_PCVAL(v);
11377:                     break;
11377:                 }
11377:             }
11377:         }
11377: 
11377:         /* If getting a value via a stub getter, we can cache the slot. */
11377:         if (!(cs->format & JOF_SET) &&
11377:             SPROP_HAS_STUB_GETTER(sprop) &&
11377:             SPROP_HAS_VALID_SLOT(sprop, scope)) {
11377:             /* Great, let's cache sprop's slot and use it on cache hit. */
11377:             vword = SLOT_TO_PCVAL(sprop->slot);
11377:         } else {
11377:             /* Best we can do is to cache sprop (still a nice speedup). */
11377:             vword = SPROP_TO_PCVAL(sprop);
11377:         }
11377:     } while (0);
11377: 
11377:     khash = PROPERTY_CACHE_HASH_PC(pc, kshape);
11377:     if (obj == pobj) {
11377:         JS_ASSERT(kshape != 0 || scope->shape != 0);
11377:         JS_ASSERT(scopeIndex == 0 && protoIndex == 0);
11377:         JS_ASSERT(OBJ_SCOPE(obj)->object == obj);
11377:         if (!(cs->format & JOF_SET))
11377:             kshape = scope->shape;
11377:     } else {
11377:         if (op == JSOP_LENGTH) {
11377:             atom = cx->runtime->atomState.lengthAtom;
11377:         } else {
11377:             pcoff = (JOF_TYPE(cs->format) == JOF_SLOTATOM) ? 2 : 0;
11377:             GET_ATOM_FROM_BYTECODE(cx->fp->script, pc, pcoff, atom);
11377:         }
11377:         JS_ASSERT_IF(scopeIndex == 0,
11377:                      protoIndex != 1 || OBJ_GET_PROTO(cx, obj) == pobj);
11377:         if (scopeIndex != 0 || protoIndex != 1) {
11377:             khash = PROPERTY_CACHE_HASH_ATOM(atom, obj, pobj);
11377:             PCMETER(if (PCVCAP_TAG(cache->table[khash].vcap) <= 1)
11377:                         cache->pcrecycles++);
11377:             pc = (jsbytecode *) atom;
11377:             kshape = (jsuword) obj;
11377:         }
11377:     }
11377: 
11377:     entry = &cache->table[khash];
11377:     PCMETER(if (entry != *entryp) cache->modfills++);
11377:     PCMETER(if (!PCVAL_IS_NULL(entry->vword)) cache->recycles++);
11377:     entry->kpc = pc;
11377:     entry->kshape = kshape;
11377:     entry->vcap = PCVCAP_MAKE(scope->shape, scopeIndex, protoIndex);
11377:     entry->vword = vword;
11377:     *entryp = entry;
11377: 
11377:     cache->empty = JS_FALSE;
11377:     PCMETER(cache->fills++);
11377: }
11377: 
11377: JSAtom *
11377: js_FullTestPropertyCache(JSContext *cx, jsbytecode *pc,
11377:                          JSObject **objp, JSObject **pobjp,
11377:                          JSPropCacheEntry **entryp)
11377: {
11377:     JSOp op;
11377:     const JSCodeSpec *cs;
11377:     ptrdiff_t pcoff;
11377:     JSAtom *atom;
11377:     JSObject *obj, *pobj, *tmp;
11377:     JSPropCacheEntry *entry;
11377:     uint32 vcap;
11377: 
11377:     JS_ASSERT(JS_UPTRDIFF(pc, cx->fp->script->code) < cx->fp->script->length);
11377: 
11377:     op = (JSOp) *pc;
11377:     cs = &js_CodeSpec[op];
11377:     if (op == JSOP_LENGTH) {
11377:         atom = cx->runtime->atomState.lengthAtom;
11377:     } else {
11377:         pcoff = (JOF_TYPE(cs->format) == JOF_SLOTATOM) ? 2 : 0;
11377:         GET_ATOM_FROM_BYTECODE(cx->fp->script, pc, pcoff, atom);
11377:     }
11377: 
11377:     obj = *objp;
11999:     JS_ASSERT(OBJ_IS_NATIVE(obj));
11377:     entry = &JS_PROPERTY_CACHE(cx).table[PROPERTY_CACHE_HASH_ATOM(atom, obj, NULL)];
11377:     *entryp = entry;
11377:     vcap = entry->vcap;
11377: 
11377:     if (entry->kpc != (jsbytecode *) atom) {
11377:         PCMETER(JS_PROPERTY_CACHE(cx).idmisses++);
11377: 
11377: #ifdef DEBUG_notme
11377:         entry = &JS_PROPERTY_CACHE(cx)
11377:                  .table[PROPERTY_CACHE_HASH_PC(pc, OBJ_SCOPE(obj)->shape)];
11377:         fprintf(stderr,
11377:                 "id miss for %s from %s:%u"
11377:                 " (pc %u, kpc %u, kshape %u, shape %u)\n",
11377:                 js_AtomToPrintableString(cx, atom),
11377:                 cx->fp->script->filename,
11377:                 js_PCToLineNumber(cx, cx->fp->script, pc),
11377:                 pc - cx->fp->script->code,
11377:                 entry->kpc - cx->fp->script->code,
11377:                 entry->kshape,
11377:                 OBJ_SCOPE(obj)->shape);
11377:                 js_Disassemble1(cx, cx->fp->script, pc,
11377:                         PTRDIFF(pc, cx->fp->script->code, jsbytecode),
11377:                         JS_FALSE, stderr);
11377: #endif
11377: 
11377:         return atom;
11377:     }
11377: 
11377:     if (entry->kshape != (jsuword) obj) {
11377:         PCMETER(JS_PROPERTY_CACHE(cx).komisses++);
11377:         return atom;
11377:     }
11377: 
11377:     pobj = obj;
11377:     JS_LOCK_OBJ(cx, pobj);
11377: 
11377:     if (JOF_MODE(cs->format) == JOF_NAME) {
11377:         while (vcap & (PCVCAP_SCOPEMASK << PCVCAP_PROTOBITS)) {
11377:             tmp = LOCKED_OBJ_GET_PARENT(pobj);
11999:             if (!tmp || !OBJ_IS_NATIVE(tmp))
11377:                 break;
11377:             JS_UNLOCK_OBJ(cx, pobj);
11377:             pobj = tmp;
11377:             JS_LOCK_OBJ(cx, pobj);
11377:             vcap -= PCVCAP_PROTOSIZE;
11377:         }
11377: 
11377:         *objp = pobj;
11377:     }
11377: 
11377:     while (vcap & PCVCAP_PROTOMASK) {
11377:         tmp = LOCKED_OBJ_GET_PROTO(pobj);
11999:         if (!tmp || !OBJ_IS_NATIVE(tmp))
11377:             break;
11377:         JS_UNLOCK_OBJ(cx, pobj);
11377:         pobj = tmp;
11377:         JS_LOCK_OBJ(cx, pobj);
11377:         --vcap;
11377:     }
11377: 
12307:     if (PCVCAP_SHAPE(vcap) == OBJ_SCOPE(pobj)->shape) {
11524: #ifdef DEBUG
11524:         jsid id = ATOM_TO_JSID(atom);
11524: 
11524:         CHECK_FOR_STRING_INDEX(id);
11524:         JS_ASSERT(SCOPE_GET_PROPERTY(OBJ_SCOPE(pobj), id));
11377:         JS_ASSERT(OBJ_SCOPE(pobj)->object == pobj);
11524: #endif
11377:         *pobjp = pobj;
11377:         return NULL;
11377:     }
11377: 
11377:     PCMETER(JS_PROPERTY_CACHE(cx).vcmisses++);
11377:     JS_UNLOCK_OBJ(cx, pobj);
11377:     return atom;
11377: }
11377: 
11377: #ifdef DEBUG
11377: #define ASSERT_CACHE_IS_EMPTY(cache)                                          \
11377:     JS_BEGIN_MACRO                                                            \
11377:         JSPropertyCache *cache_ = (cache);                                    \
11377:         uintN i_;                                                             \
11377:         JS_ASSERT(cache_->empty);                                             \
11377:         for (i_ = 0; i_ < PROPERTY_CACHE_SIZE; i_++) {                        \
11377:             JS_ASSERT(!cache_->table[i_].kpc);                                \
11377:             JS_ASSERT(!cache_->table[i_].kshape);                             \
11377:             JS_ASSERT(!cache_->table[i_].vcap);                               \
11377:             JS_ASSERT(!cache_->table[i_].vword);                              \
11377:         }                                                                     \
11377:     JS_END_MACRO
11377: #else
11377: #define ASSERT_CACHE_IS_EMPTY(cache) ((void)0)
11377: #endif
11377: 
11377: JS_STATIC_ASSERT(PCVAL_NULL == 0);
11377: 
11377: void
11377: js_FlushPropertyCache(JSContext *cx)
11377: {
11377:     JSPropertyCache *cache;
11377: 
11377:     cache = &JS_PROPERTY_CACHE(cx);
11377:     if (cache->empty) {
11377:         ASSERT_CACHE_IS_EMPTY(cache);
11377:         return;
11377:     }
11377: 
11377:     memset(cache->table, 0, sizeof cache->table);
11377:     cache->empty = JS_TRUE;
11377: 
11377: #ifdef JS_PROPERTY_CACHE_METERING
11377:   { static FILE *fp;
11377:     if (!fp)
11377:         fp = fopen("/tmp/propcache.stats", "w");
11377:     if (fp) {
11377:         fputs("Property cache stats for ", fp);
11377: #ifdef JS_THREADSAFE
11377:         fprintf(fp, "thread %lu, ", (unsigned long) cx->thread->id);
11377: #endif
11377:         fprintf(fp, "GC %u\n", cx->runtime->gcNumber);
11377: 
11377: # define P(mem) fprintf(fp, "%11s %10lu\n", #mem, (unsigned long)cache->mem)
11377:         P(fills);
11377:         P(nofills);
11377:         P(rofills);
11377:         P(disfills);
11377:         P(oddfills);
11377:         P(modfills);
11377:         P(brandfills);
13342:         P(noprotos);
11377:         P(longchains);
11377:         P(recycles);
11377:         P(pcrecycles);
11377:         P(tests);
11377:         P(pchits);
11377:         P(protopchits);
12307:         P(initests);
12307:         P(inipchits);
12307:         P(inipcmisses);
11377:         P(settests);
11377:         P(addpchits);
11377:         P(setpchits);
11377:         P(setpcmisses);
12307:         P(slotchanges);
11377:         P(setmisses);
11377:         P(idmisses);
11377:         P(komisses);
11377:         P(vcmisses);
11377:         P(misses);
11377:         P(flushes);
11377: # undef P
11377: 
12307:         fprintf(fp, "hit rates: pc %g%% (proto %g%%), set %g%%, ini %g%%, full %g%%\n",
11377:                 (100. * cache->pchits) / cache->tests,
11377:                 (100. * cache->protopchits) / cache->tests,
11377:                 (100. * (cache->addpchits + cache->setpchits))
11377:                 / cache->settests,
12307:                 (100. * cache->inipchits) / cache->initests,
11377:                 (100. * (cache->tests - cache->misses)) / cache->tests);
11377:         fflush(fp);
11377:     }
11377:   }
11377: #endif
11377: 
11377:     PCMETER(cache->flushes++);
11377: }
11377: 
11377: void
11377: js_FlushPropertyCacheForScript(JSContext *cx, JSScript *script)
11377: {
11377:     JSPropertyCache *cache;
11377:     JSPropCacheEntry *entry;
11377: 
11377:     cache = &JS_PROPERTY_CACHE(cx);
11377:     for (entry = cache->table; entry < cache->table + PROPERTY_CACHE_SIZE;
11377:          entry++) {
11377:         if (JS_UPTRDIFF(entry->kpc, script->code) < script->length) {
11377:             entry->kpc = NULL;
11377:             entry->kshape = 0;
11377: #ifdef DEBUG
11377:             entry->vcap = entry->vword = 0;
11377: #endif
11377:         }
11377:     }
11377: }
11377: 
11377: void
11377: js_DisablePropertyCache(JSContext *cx)
11377: {
11377:     JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled >= 0);
11377:     ++JS_PROPERTY_CACHE(cx).disabled;
11377: }
11377: 
11377: void
11377: js_EnablePropertyCache(JSContext *cx)
11377: {
11377:     --JS_PROPERTY_CACHE(cx).disabled;
11377:     JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled >= 0);
11377: }
11377: 
    1: /*
 6040:  * Check if the current arena has enough space to fit nslots after sp and, if
 6040:  * so, reserve the necessary space.
 6040:  */
 6040: static JSBool
 6040: AllocateAfterSP(JSContext *cx, jsval *sp, uintN nslots)
 6040: {
 6040:     uintN surplus;
 6040:     jsval *sp2;
 6040: 
 6040:     JS_ASSERT((jsval *) cx->stackPool.current->base <= sp);
 6040:     JS_ASSERT(sp <= (jsval *) cx->stackPool.current->avail);
 6040:     surplus = (jsval *) cx->stackPool.current->avail - sp;
 6040:     if (nslots <= surplus)
 6040:         return JS_TRUE;
 6040: 
 6040:     /*
 6040:      * No room before current->avail, check if the arena has enough space to
 6040:      * fit the missing slots before the limit.
 6040:      */
 6040:     if (nslots > (size_t) ((jsval *) cx->stackPool.current->limit - sp))
 6040:         return JS_FALSE;
 6040: 
 6040:     JS_ARENA_ALLOCATE_CAST(sp2, jsval *, &cx->stackPool,
 6040:                            (nslots - surplus) * sizeof(jsval));
 6040:     JS_ASSERT(sp2 == sp + surplus);
 6040:     return JS_TRUE;
 6040: }
 6040: 
12551: jsval *
12551: js_AllocRawStack(JSContext *cx, uintN nslots, void **markp)
    1: {
    1:     jsval *sp;
    1: 
10985:     if (!cx->stackPool.first.next) {
10985:         int64 *timestamp;
10985: 
12112:         JS_ARENA_ALLOCATE_CAST(timestamp, int64 *,
12112:                                &cx->stackPool, sizeof *timestamp);
10985:         if (!timestamp) {
10985:             js_ReportOutOfScriptQuota(cx);
10985:             return NULL;
10985:         }
10985:         *timestamp = JS_Now();
10985:     }
10985: 
    1:     if (markp)
    1:         *markp = JS_ARENA_MARK(&cx->stackPool);
    1:     JS_ARENA_ALLOCATE_CAST(sp, jsval *, &cx->stackPool, nslots * sizeof(jsval));
 8296:     if (!sp)
 8296:         js_ReportOutOfScriptQuota(cx);
    1:     return sp;
    1: }
    1: 
12551: void
12551: js_FreeRawStack(JSContext *cx, void *mark)
    1: {
    1:     JS_ARENA_RELEASE(&cx->stackPool, mark);
    1: }
    1: 
    1: JS_FRIEND_API(jsval *)
    1: js_AllocStack(JSContext *cx, uintN nslots, void **markp)
    1: {
 6040:     jsval *sp;
    1:     JSArena *a;
    1:     JSStackHeader *sh;
    1: 
    1:     /* Callers don't check for zero nslots: we do to avoid empty segments. */
    1:     if (nslots == 0) {
    1:         *markp = NULL;
 3164:         return (jsval *) JS_ARENA_MARK(&cx->stackPool);
    1:     }
    1: 
    1:     /* Allocate 2 extra slots for the stack segment header we'll likely need. */
12551:     sp = js_AllocRawStack(cx, 2 + nslots, markp);
    1:     if (!sp)
    1:         return NULL;
    1: 
    1:     /* Try to avoid another header if we can piggyback on the last segment. */
    1:     a = cx->stackPool.current;
    1:     sh = cx->stackHeaders;
    1:     if (sh && JS_STACK_SEGMENT(sh) + sh->nslots == sp) {
    1:         /* Extend the last stack segment, give back the 2 header slots. */
    1:         sh->nslots += nslots;
    1:         a->avail -= 2 * sizeof(jsval);
    1:     } else {
    1:         /*
 6040:          * Need a new stack segment, so allocate and push a stack segment
 6040:          * header from the 2 extra slots.
    1:          */
    1:         sh = (JSStackHeader *)sp;
    1:         sh->nslots = nslots;
    1:         sh->down = cx->stackHeaders;
    1:         cx->stackHeaders = sh;
    1:         sp += 2;
    1:     }
    1: 
    1:     /*
    1:      * Store JSVAL_NULL using memset, to let compilers optimize as they see
    1:      * fit, in case a caller allocates and pushes GC-things one by one, which
    1:      * could nest a last-ditch GC that will scan this segment.
    1:      */
    1:     memset(sp, 0, nslots * sizeof(jsval));
    1:     return sp;
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_FreeStack(JSContext *cx, void *mark)
    1: {
    1:     JSStackHeader *sh;
    1:     jsuword slotdiff;
    1: 
    1:     /* Check for zero nslots allocation special case. */
    1:     if (!mark)
    1:         return;
    1: 
    1:     /* We can assert because js_FreeStack always balances js_AllocStack. */
    1:     sh = cx->stackHeaders;
    1:     JS_ASSERT(sh);
    1: 
    1:     /* If mark is in the current segment, reduce sh->nslots, else pop sh. */
    1:     slotdiff = JS_UPTRDIFF(mark, JS_STACK_SEGMENT(sh)) / sizeof(jsval);
    1:     if (slotdiff < (jsuword)sh->nslots)
    1:         sh->nslots = slotdiff;
    1:     else
    1:         cx->stackHeaders = sh->down;
    1: 
    1:     /* Release the stackPool space allocated since mark was set. */
    1:     JS_ARENA_RELEASE(&cx->stackPool, mark);
    1: }
    1: 
    1: JSObject *
    1: js_GetScopeChain(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSObject *obj, *cursor, *clonedChild, *parent;
    1:     JSTempValueRooter tvr;
    1: 
    1:     obj = fp->blockChain;
    1:     if (!obj) {
    1:         /*
    1:          * Don't force a call object for a lightweight function call, but do
    1:          * insist that there is a call object for a heavyweight function call.
    1:          */
    1:         JS_ASSERT(!fp->fun ||
13702:                   !(fp->fun->flags & JSFUN_HEAVYWEIGHT) ||
    1:                   fp->callobj);
    1:         JS_ASSERT(fp->scopeChain);
    1:         return fp->scopeChain;
    1:     }
    1: 
    1:     /*
    1:      * We have one or more lexical scopes to reflect into fp->scopeChain, so
    1:      * make sure there's a call object at the current head of the scope chain,
    1:      * if this frame is a call frame.
    1:      */
    1:     if (fp->fun && !fp->callobj) {
    1:         JS_ASSERT(OBJ_GET_CLASS(cx, fp->scopeChain) != &js_BlockClass ||
10592:                   OBJ_GET_PRIVATE(cx, fp->scopeChain) != fp);
    1:         if (!js_GetCallObject(cx, fp, fp->scopeChain))
    1:             return NULL;
    1:     }
    1: 
    1:     /*
    1:      * Clone the block chain. To avoid recursive cloning we set the parent of
    1:      * the cloned child after we clone the parent. In the following loop when
    1:      * clonedChild is null it indicates the first iteration when no special GC
    1:      * rooting is necessary. On the second and the following iterations we
    1:      * have to protect cloned so far chain against the GC during cloning of
    1:      * the cursor object.
    1:      */
    1:     cursor = obj;
    1:     clonedChild = NULL;
    1:     for (;;) {
    1:         parent = OBJ_GET_PARENT(cx, cursor);
    1: 
    1:         /*
    1:          * We pass fp->scopeChain and not null even if we override the parent
    1:          * slot later as null triggers useless calculations of slot's value in
    1:          * js_NewObject that js_CloneBlockObject calls.
    1:          */
    1:         cursor = js_CloneBlockObject(cx, cursor, fp->scopeChain, fp);
    1:         if (!cursor) {
    1:             if (clonedChild)
    1:                 JS_POP_TEMP_ROOT(cx, &tvr);
    1:             return NULL;
    1:         }
    1:         if (!clonedChild) {
    1:             /*
    1:              * The first iteration. Check if other follow and root obj if so
    1:              * to protect the whole cloned chain against GC.
    1:              */
    1:             obj = cursor;
    1:             if (!parent)
    1:                 break;
    1:             JS_PUSH_TEMP_ROOT_OBJECT(cx, obj, &tvr);
    1:         } else {
    1:             /*
    1:              * Avoid OBJ_SET_PARENT overhead as clonedChild cannot escape to
    1:              * other threads.
    1:              */
    1:             STOBJ_SET_PARENT(clonedChild, cursor);
    1:             if (!parent) {
    1:                 JS_ASSERT(tvr.u.value == OBJECT_TO_JSVAL(obj));
    1:                 JS_POP_TEMP_ROOT(cx, &tvr);
    1:                 break;
    1:             }
    1:         }
    1:         clonedChild = cursor;
    1:         cursor = parent;
    1:     }
    1:     fp->flags |= JSFRAME_POP_BLOCKS;
    1:     fp->scopeChain = obj;
    1:     fp->blockChain = NULL;
    1:     return obj;
    1: }
    1: 
 2383: JSBool
 4127: js_GetPrimitiveThis(JSContext *cx, jsval *vp, JSClass *clasp, jsval *thisvp)
    1: {
 4127:     jsval v;
 4127:     JSObject *obj;
 4127: 
 4127:     v = vp[1];
 4127:     if (JSVAL_IS_OBJECT(v)) {
12470:         obj = JS_THIS_OBJECT(cx, vp);
 4127:         if (!JS_InstanceOf(cx, obj, clasp, vp + 2))
 4127:             return JS_FALSE;
 4127:         v = OBJ_GET_SLOT(cx, obj, JSSLOT_PRIVATE);
 4127:     }
 4127:     *thisvp = v;
 3739:     return JS_TRUE;
 4127: }
 4127: 
    1: /*
 4127:  * ECMA requires "the global object", but in embeddings such as the browser,
 4127:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
 4127:  * we prefer fun's parent.  An example that causes this code to run:
    1:  *
    1:  *   // in window w1
    1:  *   function f() { return this }
    1:  *   function g() { return f }
    1:  *
    1:  *   // in window w2
    1:  *   var h = w1.g()
    1:  *   alert(h() == w1)
    1:  *
    1:  * The alert should display "true".
    1:  */
12551: JSObject *
12551: js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv)
 4127: {
 4127:     JSObject *thisp;
 4127: 
    1:     if (JSVAL_IS_PRIMITIVE(argv[-2]) ||
    1:         !OBJ_GET_PARENT(cx, JSVAL_TO_OBJECT(argv[-2]))) {
    1:         thisp = cx->globalObject;
    1:     } else {
11774:         JSStackFrame *fp;
    1:         jsid id;
    1:         jsval v;
    1:         uintN attrs;
11774:         JSBool ok;
    1:         JSObject *parent;
    1: 
11774:         /*
11774:          * Walk up the parent chain, first checking that the running script
11774:          * has access to the callee's parent object. Note that if lazy, the
11774:          * running script whose principals we want to check is the script
11774:          * associated with fp->down, not with fp.
11774:          *
11774:          * FIXME: 417851 -- this access check should not be required, as it
12551:          * imposes a performance penalty on all js_ComputeGlobalThis calls,
12551:          * and it represents a maintenance hazard.
11774:          */
11774:         fp = cx->fp;    /* quell GCC overwarning */
11774:         if (lazy) {
12470:             JS_ASSERT(fp->argv == argv);
11774:             fp->dormantNext = cx->dormantFrameChain;
11774:             cx->dormantFrameChain = fp;
11774:             cx->fp = fp->down;
11774:             fp->down = NULL;
11774:         }
    1:         thisp = JSVAL_TO_OBJECT(argv[-2]);
    1:         id = ATOM_TO_JSID(cx->runtime->atomState.parentAtom);
11774: 
11774:         ok = OBJ_CHECK_ACCESS(cx, thisp, id, JSACC_PARENT, &v, &attrs);
11774:         if (lazy) {
11774:             cx->dormantFrameChain = fp->dormantNext;
11774:             fp->dormantNext = NULL;
11774:             fp->down = cx->fp;
11774:             cx->fp = fp;
11774:         }
11774:         if (!ok)
11774:             return NULL;
11774: 
11774:         thisp = JSVAL_IS_VOID(v)
    1:                 ? OBJ_GET_PARENT(cx, thisp)
    1:                 : JSVAL_TO_OBJECT(v);
11774:         while ((parent = OBJ_GET_PARENT(cx, thisp)) != NULL)
    1:             thisp = parent;
    1:     }
10987: 
12451:     OBJ_TO_OUTER_OBJECT(cx, thisp);
12451:     if (!thisp)
11989:         return NULL;
    1:     argv[-1] = OBJECT_TO_JSVAL(thisp);
11774:     return thisp;
11774: }
11774: 
11774: static JSObject *
11774: ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
 4127: {
 4127:     JSObject *thisp;
 4127: 
 4127:     JS_ASSERT(!JSVAL_IS_NULL(argv[-1]));
11774:     if (!JSVAL_IS_OBJECT(argv[-1])) {
11774:         if (!js_PrimitiveToObject(cx, &argv[-1]))
11774:             return NULL;
11774:         thisp = JSVAL_TO_OBJECT(argv[-1]);
11774:     } else {
 4127:         thisp = JSVAL_TO_OBJECT(argv[-1]);
 4127:         if (OBJ_GET_CLASS(cx, thisp) == &js_CallClass)
12551:             return js_ComputeGlobalThis(cx, lazy, argv);
11774: 
11774:         if (thisp->map->ops->thisObject) {
 4127:             /* Some objects (e.g., With) delegate 'this' to another object. */
 4127:             thisp = thisp->map->ops->thisObject(cx, thisp);
 4127:             if (!thisp)
11774:                 return NULL;
11774:         }
12451:         OBJ_TO_OUTER_OBJECT(cx, thisp);
12451:         if (!thisp)
12451:             return NULL;
 4127:         argv[-1] = OBJECT_TO_JSVAL(thisp);
11774:     }
11774:     return thisp;
11774: }
11774: 
11774: JSObject *
11774: js_ComputeThis(JSContext *cx, JSBool lazy, jsval *argv)
 4127: {
 4127:     if (JSVAL_IS_NULL(argv[-1]))
12551:         return js_ComputeGlobalThis(cx, lazy, argv);
11774:     return ComputeThis(cx, lazy, argv);
 4127: }
 4127: 
    1: #if JS_HAS_NO_SUCH_METHOD
    1: 
14789: #define JSSLOT_FOUND_FUNCTION   JSSLOT_PRIVATE
14789: #define JSSLOT_SAVED_ID         (JSSLOT_PRIVATE + 1)
14789: 
12579: JSClass js_NoSuchMethodClass = {
12579:     "NoSuchMethod",
12579:     JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS |
12579:     JSCLASS_HAS_CACHED_PROTO(JSProto_NoSuchMethod),
12579:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,   JS_PropertyStub,
12579:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,    JS_FinalizeStub,
12579:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
12579: };
12579: 
12579: JSObject*
12579: js_InitNoSuchMethodClass(JSContext *cx, JSObject* obj)
12579: {
12579:     JSObject *proto;
12579: 
12579:     proto = JS_InitClass(cx, obj, NULL, &js_NoSuchMethodClass, NULL, 0, NULL,
12579:                          NULL, NULL, NULL);
12579:     if (!proto)
12579:         return NULL;
12579: 
12579:     OBJ_SET_PROTO(cx, proto, NULL);
12579:     return proto;
12579: }
12579: 
12579: /*
12579:  * When JSOP_CALLPROP or JSOP_CALLELEM does not find the method property of
12579:  * the base object, we search for the __noSuchMethod__ method in the base.
12579:  * If it exists, we store the method and the property's id into an object of
12579:  * NoSuchMethod class and store this object into the callee's stack slot.
12579:  * Later, js_Invoke will recognise such an object and transfer control to
12579:  * NoSuchMethod that invokes the method like:
12579:  *
12579:  *   this.__noSuchMethod__(id, args)
12579:  *
12579:  * where id is the name of the method that this invocation attempted to
12579:  * call by name, and args is an Array containing this invocation's actual
12579:  * parameters.
12579:  */
12579: JSBool
12579: js_OnUnknownMethod(JSContext *cx, jsval *vp)
12579: {
12579:     JSObject *obj;
12610:     jsid id;
12579:     JSTempValueRooter tvr;
12579:     JSBool ok;
12579: 
12579:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
12579:     obj = JSVAL_TO_OBJECT(vp[1]);
12579:     JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &tvr);
12579: 
12579:     /* From here on, control must flow through label out:. */
12579:     id = ATOM_TO_JSID(cx->runtime->atomState.noSuchMethodAtom);
12579: #if JS_HAS_XML_SUPPORT
12579:     if (OBJECT_IS_XML(cx, obj)) {
12579:         JSXMLObjectOps *ops;
12579: 
12579:         ops = (JSXMLObjectOps *) obj->map->ops;
12579:         obj = ops->getMethod(cx, obj, id, &tvr.u.value);
12579:         if (!obj) {
12579:             ok = JS_FALSE;
12579:             goto out;
12579:         }
12579:         vp[1] = OBJECT_TO_JSVAL(obj);
12579:     } else
12579: #endif
12579:     {
12579:         ok = OBJ_GET_PROPERTY(cx, obj, id, &tvr.u.value);
12579:         if (!ok)
12579:             goto out;
12579:     }
12579:     if (JSVAL_IS_PRIMITIVE(tvr.u.value)) {
12579:         vp[0] = tvr.u.value;
12579:     } else {
12610: #if JS_HAS_XML_SUPPORT
12610:         /* Extract the function name from function::name qname. */
12610:         if (!JSVAL_IS_PRIMITIVE(vp[0])) {
12610:             obj = JSVAL_TO_OBJECT(vp[0]);
12610:             if (!js_IsFunctionQName(cx, obj, &id))
12610:                 return JS_FALSE;
12610:             if (id != 0)
12610:                 vp[0] = ID_TO_VALUE(id);
12610:         }
12610: #endif
13824:         obj = js_NewObject(cx, &js_NoSuchMethodClass, NULL, NULL, 0);
12579:         if (!obj) {
12579:             ok = JS_FALSE;
12579:             goto out;
12579:         }
14789:         obj->fslots[JSSLOT_FOUND_FUNCTION] = tvr.u.value;
14789:         obj->fslots[JSSLOT_SAVED_ID] = vp[0];
12579:         vp[0] = OBJECT_TO_JSVAL(obj);
12579:     }
12579:     ok = JS_TRUE;
12579: 
12579:   out:
12579:     JS_POP_TEMP_ROOT(cx, &tvr);
12579:     return ok;
12579: }
12579: 
    1: static JSBool
 6040: NoSuchMethod(JSContext *cx, uintN argc, jsval *vp, uint32 flags)
    1: {
14789:     jsval *invokevp;
14789:     void *mark;
14789:     JSBool ok;
14789:     JSObject *obj, *argsobj;
14789: 
14789:     invokevp = js_AllocStack(cx, 2 + 2, &mark);
14789:     if (!invokevp)
14789:         return JS_FALSE;
12579: 
12579:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[0]));
14789:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
12579:     obj = JSVAL_TO_OBJECT(vp[0]);
12579:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_NoSuchMethodClass);
14789: 
14789:     invokevp[0] = obj->fslots[JSSLOT_FOUND_FUNCTION];
14789:     invokevp[1] = vp[1];
14789:     invokevp[2] = obj->fslots[JSSLOT_SAVED_ID];
    1:     argsobj = js_NewArrayObject(cx, argc, vp + 2);
14789:     if (!argsobj) {
14789:         ok = JS_FALSE;
14789:     } else {
14789:         invokevp[3] = OBJECT_TO_JSVAL(argsobj);
14789:         ok = (flags & JSINVOKE_CONSTRUCT)
14789:              ? js_InvokeConstructor(cx, 2, invokevp)
14789:              : js_Invoke(cx, 2, invokevp, flags);
14789:         vp[0] = invokevp[0];
14789:     }
14789:     js_FreeStack(cx, mark);
14789:     return ok;
    1: }
    1: 
    1: #endif /* JS_HAS_NO_SUCH_METHOD */
    1: 
    1: /*
 4127:  * We check if the function accepts a primitive value as |this|. For that we
 4127:  * use a table that maps value's tag into the corresponding function flag.
 4127:  */
 4127: JS_STATIC_ASSERT(JSVAL_INT == 1);
 4127: JS_STATIC_ASSERT(JSVAL_DOUBLE == 2);
 4127: JS_STATIC_ASSERT(JSVAL_STRING == 4);
 4127: JS_STATIC_ASSERT(JSVAL_BOOLEAN == 6);
 4127: 
12551: const uint16 js_PrimitiveTestFlags[] = {
 4127:     JSFUN_THISP_NUMBER,     /* INT     */
 4127:     JSFUN_THISP_NUMBER,     /* DOUBLE  */
 4127:     JSFUN_THISP_NUMBER,     /* INT     */
 4127:     JSFUN_THISP_STRING,     /* STRING  */
 4127:     JSFUN_THISP_NUMBER,     /* INT     */
 4127:     JSFUN_THISP_BOOLEAN,    /* BOOLEAN */
 4127:     JSFUN_THISP_NUMBER      /* INT     */
 4127: };
 4127: 
    1: /*
    1:  * Find a function reference and its 'this' object implicit first parameter
    1:  * under argc arguments on cx's stack, and call the function.  Push missing
    1:  * required arguments, allocate declared local variables, and pop everything
    1:  * when done.  Then push the return value.
    1:  */
    1: JS_FRIEND_API(JSBool)
 6040: js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags)
    1: {
    1:     void *mark;
 6040:     JSStackFrame frame;
 6040:     jsval *sp, *argv, *newvp;
 6040:     jsval v;
 2383:     JSObject *funobj, *parent;
    1:     JSBool ok;
    1:     JSClass *clasp;
    1:     JSObjectOps *ops;
    1:     JSNative native;
    1:     JSFunction *fun;
    1:     JSScript *script;
 6114:     uintN nslots, nvars, i, skip;
 6040:     uint32 rootedArgsFlag;
    1:     JSInterpreterHook hook;
    1:     void *hookData;
    1: 
 6040:     /* [vp .. vp + 2 + argc) must belong to the last JS stack arena. */
 6040:     JS_ASSERT((jsval *) cx->stackPool.current->base <= vp);
 6040:     JS_ASSERT(vp + 2 + argc <= (jsval *) cx->stackPool.current->avail);
 6040: 
 6040:     /*
 6040:      * Mark the top of stack and load frequently-used registers. After this
 6040:      * point the control should flow through label out2: to return.
 6040:      */
 5971:     mark = JS_ARENA_MARK(&cx->stackPool);
    1:     v = *vp;
    1: 
12579:     if (JSVAL_IS_PRIMITIVE(v))
    1:         goto bad;
    1: 
    1:     funobj = JSVAL_TO_OBJECT(v);
    1:     parent = OBJ_GET_PARENT(cx, funobj);
    1:     clasp = OBJ_GET_CLASS(cx, funobj);
    1:     if (clasp != &js_FunctionClass) {
12579: #if JS_HAS_NO_SUCH_METHOD
12579:         if (clasp == &js_NoSuchMethodClass) {
12579:             ok = NoSuchMethod(cx, argc, vp, flags);
12579:             goto out2;
12579:         }
12579: #endif
12579: 
    1:         /* Function is inlined, all other classes use object ops. */
    1:         ops = funobj->map->ops;
    1: 
    1:         /*
    1:          * XXX this makes no sense -- why convert to function if clasp->call?
    1:          * XXX better to call that hook without converting
    1:          * XXX the only thing that needs fixing is liveconnect
    1:          *
    1:          * Try converting to function, for closure and API compatibility.
    1:          * We attempt the conversion under all circumstances for 1.2, but
    1:          * only if there is a call op defined otherwise.
    1:          */
    1:         if ((ops == &js_ObjectOps) ? clasp->call : ops->call) {
    1:             ok = clasp->convert(cx, funobj, JSTYPE_FUNCTION, &v);
    1:             if (!ok)
    1:                 goto out2;
    1: 
    1:             if (VALUE_IS_FUNCTION(cx, v)) {
    1:                 /* Make vp refer to funobj to keep it available as argv[-2]. */
    1:                 *vp = v;
    1:                 funobj = JSVAL_TO_OBJECT(v);
    1:                 parent = OBJ_GET_PARENT(cx, funobj);
    1:                 goto have_fun;
    1:             }
    1:         }
    1:         fun = NULL;
    1:         script = NULL;
    1:         nslots = nvars = 0;
    1: 
    1:         /* Try a call or construct native object op. */
 2383:         if (flags & JSINVOKE_CONSTRUCT) {
 2383:             if (!JSVAL_IS_OBJECT(vp[1])) {
 2383:                 ok = js_PrimitiveToObject(cx, &vp[1]);
 2383:                 if (!ok)
 2383:                     goto out2;
 2383:             }
 2383:             native = ops->construct;
 2383:         } else {
 2383:             native = ops->call;
 2383:         }
    1:         if (!native)
    1:             goto bad;
    1:     } else {
    1: have_fun:
    1:         /* Get private data and set derived locals from it. */
13691:         fun = GET_FUNCTION_PRIVATE(cx, funobj);
13702:         nslots = FUN_MINARGS(fun);
13702:         nslots = (nslots > argc) ? nslots - argc : 0;
13702:         if (FUN_INTERPRETED(fun)) {
    1:             native = NULL;
13702:             script = fun->u.i.script;
13702:             nvars = fun->u.i.nvars;
    1:         } else {
13702:             native = fun->u.n.native;
    1:             script = NULL;
    1:             nvars = 0;
13702:             nslots += fun->u.n.extra;
13702:         }
13702: 
13702:         if (JSFUN_BOUND_METHOD_TEST(fun->flags)) {
    1:             /* Handle bound method special case. */
 2383:             vp[1] = OBJECT_TO_JSVAL(parent);
 2383:         } else if (!JSVAL_IS_OBJECT(vp[1])) {
    1:             JS_ASSERT(!(flags & JSINVOKE_CONSTRUCT));
 4127:             if (PRIMITIVE_THIS_TEST(fun, vp[1]))
 6040:                 goto init_slots;
    1:         }
    1:     }
    1: 
    1:     if (flags & JSINVOKE_CONSTRUCT) {
 2383:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(vp[1]));
    1:     } else {
 4127:         /*
 4127:          * We must call js_ComputeThis in case we are not called from the
 4127:          * interpreter, where a prior bytecode has computed an appropriate
 4127:          * |this| already.
11843:          *
11848:          * But we need to compute |this| eagerly only for so-called "slow"
11848:          * (i.e., not fast) native functions. Fast natives must use either
11848:          * JS_THIS or JS_THIS_OBJECT, and scripted functions will go through
11848:          * the appropriate this-computing bytecode, e.g., JSOP_THIS.
 4127:          */
13702:         if (native && (!fun || !(fun->flags & JSFUN_FAST_NATIVE))) {
12470:             if (!js_ComputeThis(cx, JS_FALSE, vp + 2)) {
11774:                 ok = JS_FALSE;
    1:                 goto out2;
    1:             }
12470:             flags |= JSFRAME_COMPUTED_THIS;
12470:         }
11774:     }
    1: 
 6040:   init_slots:
 6040:     argv = vp + 2;
 6040:     sp = argv + argc;
 6040: 
 6040:     rootedArgsFlag = JSFRAME_ROOTED_ARGV;
 6040:     if (nslots != 0) {
 2383:         /*
 6040:          * The extra slots required by the function must be continues with the
 6040:          * arguments. Thus, when the last arena does not have room to fit
 6040:          * nslots right after sp and AllocateAfterSP fails, we have to copy
 6040:          * [vp..vp+2+argc) slots and clear rootedArgsFlag to root the copy.
 6040:          */
 6040:         if (!AllocateAfterSP(cx, sp, nslots)) {
 6040:             rootedArgsFlag = 0;
12551:             newvp = js_AllocRawStack(cx, 2 + argc + nslots, NULL);
 6040:             if (!newvp) {
 6040:                 ok = JS_FALSE;
 6040:                 goto out2;
 6040:             }
 6040:             memcpy(newvp, vp, (2 + argc) * sizeof(jsval));
 6040:             argv = newvp + 2;
 6040:             sp = argv + argc;
 6040:         }
 6040: 
 6040:         /* Push void to initialize missing args. */
 6040:         i = nslots;
 6040:         do {
12551:             *sp++ = JSVAL_VOID;
 6040:         } while (--i != 0);
 6040:     }
 6040: 
13702:     if (native && fun && (fun->flags & JSFUN_FAST_NATIVE)) {
 6040:         JSTempValueRooter tvr;
 6040: #ifdef DEBUG_NOT_THROWING
 6040:         JSBool alreadyThrowing = cx->throwing;
 6040: #endif
 6040: #if JS_HAS_LVALUE_RETURN
 6040:         /* Set by JS_SetCallReturnValue2, used to return reference types. */
 6040:         cx->rval2set = JS_FALSE;
 6040: #endif
 6114:         /* Root the slots that are not covered by [vp..vp+2+argc). */
 6114:         skip = rootedArgsFlag ? 2 + argc : 0;
 6114:         JS_PUSH_TEMP_ROOT(cx, 2 + argc + nslots - skip, argv - 2 + skip, &tvr);
 6040:         ok = ((JSFastNative) native)(cx, argc, argv - 2);
 6114: 
 6114:         /*
 6114:          * To avoid extra checks we always copy the result to *vp even if we
 6114:          * have not copied argv and vp == argv - 2.
 6114:          */
 6114:         *vp = argv[-2];
 6040:         JS_POP_TEMP_ROOT(cx, &tvr);
 6040: 
 6040:         JS_RUNTIME_METER(cx->runtime, nativeCalls);
 6040: #ifdef DEBUG_NOT_THROWING
 6040:         if (ok && !alreadyThrowing)
 6040:             ASSERT_NOT_THROWING(cx);
 6040: #endif
 6040:         goto out2;
 6040:     }
 6040: 
 6040:     /* Now allocate stack space for local variables of interpreted function. */
 6040:     if (nvars) {
 6040:         if (!AllocateAfterSP(cx, sp, nvars)) {
 6040:             /* NB: Discontinuity between argv and vars. */
12551:             sp = js_AllocRawStack(cx, nvars, NULL);
 6040:             if (!sp) {
 6040:                 ok = JS_FALSE;
 6040:                 goto out2;
 6040:             }
 6040:         }
 6040: 
 6040:         /* Push void to initialize local variables. */
 6040:         i = nvars;
 6040:         do {
12551:             *sp++ = JSVAL_VOID;
 6040:         } while (--i != 0);
 6040:     }
 6040: 
 6040:     /*
13168:      * Initialize the frame.
 2383:      *
 2383:      * To set thisp we use an explicit cast and not JSVAL_TO_OBJECT, as vp[1]
 4127:      * can be a primitive value here for those native functions specified with
 2383:      * JSFUN_THISP_(NUMBER|STRING|BOOLEAN) flags.
 2383:      */
 2383:     frame.thisp = (JSObject *)vp[1];
    1:     frame.varobj = NULL;
    1:     frame.callobj = frame.argsobj = NULL;
    1:     frame.script = script;
 4127:     frame.callee = funobj;
    1:     frame.fun = fun;
    1:     frame.argc = argc;
 6040:     frame.argv = argv;
 6040: 
 6040:     /* Default return value for a constructor is the new object. */
 6040:     frame.rval = (flags & JSINVOKE_CONSTRUCT) ? vp[1] : JSVAL_VOID;
    1:     frame.nvars = nvars;
 6040:     frame.vars = sp - nvars;
 6040:     frame.down = cx->fp;
    1:     frame.annotation = NULL;
    1:     frame.scopeChain = NULL;    /* set below for real, after cx->fp is set */
13168:     frame.regs = NULL;
    1:     frame.spbase = NULL;
    1:     frame.sharpDepth = 0;
    1:     frame.sharpArray = NULL;
 6040:     frame.flags = flags | rootedArgsFlag;
    1:     frame.dormantNext = NULL;
    1:     frame.xmlNamespace = NULL;
    1:     frame.blockChain = NULL;
    1: 
    1:     /* From here on, control must flow through label out: to return. */
    1:     cx->fp = &frame;
    1: 
    1:     /* Init these now in case we goto out before first hook call. */
 2433:     hook = cx->debugHooks->callHook;
    1:     hookData = NULL;
    1: 
    1:     /* call the hook if present */
    1:     if (hook && (native || script))
 2433:         hookData = hook(cx, &frame, JS_TRUE, 0, cx->debugHooks->callHookData);
    1: 
    1:     /* Call the function, either a native method or an interpreted script. */
    1:     if (native) {
    1: #ifdef DEBUG_NOT_THROWING
    1:         JSBool alreadyThrowing = cx->throwing;
    1: #endif
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:         /* Set by JS_SetCallReturnValue2, used to return reference types. */
    1:         cx->rval2set = JS_FALSE;
    1: #endif
    1: 
    1:         /* If native, use caller varobj and scopeChain for eval. */
 6114:         JS_ASSERT(!frame.varobj);
 6114:         JS_ASSERT(!frame.scopeChain);
 6114:         if (frame.down) {
 6114:             frame.varobj = frame.down->varobj;
 6114:             frame.scopeChain = frame.down->scopeChain;
 6040:         }
 3307: 
 3307:         /* But ensure that we have a scope chain. */
 3307:         if (!frame.scopeChain)
 3307:             frame.scopeChain = parent;
 4127: 
    1:         ok = native(cx, frame.thisp, argc, frame.argv, &frame.rval);
    1:         JS_RUNTIME_METER(cx->runtime, nativeCalls);
    1: #ifdef DEBUG_NOT_THROWING
    1:         if (ok && !alreadyThrowing)
    1:             ASSERT_NOT_THROWING(cx);
    1: #endif
    1:     } else if (script) {
    1:         /* Use parent scope so js_GetCallObject can find the right "Call". */
    1:         frame.scopeChain = parent;
13702:         if (JSFUN_HEAVYWEIGHT_TEST(fun->flags)) {
    1:             /* Scope with a call object parented by the callee's parent. */
    1:             if (!js_GetCallObject(cx, &frame, parent)) {
    1:                 ok = JS_FALSE;
    1:                 goto out;
    1:             }
    1:         }
12688:         ok = js_Interpret(cx);
    1:     } else {
    1:         /* fun might be onerror trying to report a syntax error in itself. */
    1:         frame.scopeChain = NULL;
    1:         ok = JS_TRUE;
    1:     }
    1: 
    1: out:
    1:     if (hookData) {
 2433:         hook = cx->debugHooks->callHook;
    1:         if (hook)
    1:             hook(cx, &frame, JS_FALSE, &ok, hookData);
    1:     }
    1: 
    1:     /* If frame has a call object, sync values and clear back-pointer. */
    1:     if (frame.callobj)
    1:         ok &= js_PutCallObject(cx, &frame);
    1: 
    1:     /* If frame has an arguments object, sync values and clear back-pointer. */
    1:     if (frame.argsobj)
    1:         ok &= js_PutArgsObject(cx, &frame);
    1: 
 6040:     *vp = frame.rval;
 6040: 
    1:     /* Restore cx->fp now that we're done releasing frame objects. */
 6040:     cx->fp = frame.down;
    1: 
    1: out2:
    1:     /* Pop everything we may have allocated off the stack. */
    1:     JS_ARENA_RELEASE(&cx->stackPool, mark);
 6040:     if (!ok)
 6040:         *vp = JSVAL_NULL;
    1:     return ok;
    1: 
    1: bad:
    1:     js_ReportIsNotFunction(cx, vp, flags & JSINVOKE_FUNFLAGS);
    1:     ok = JS_FALSE;
    1:     goto out2;
    1: }
    1: 
    1: JSBool
    1: js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,
    1:                   uintN argc, jsval *argv, jsval *rval)
    1: {
 6040:     jsval *invokevp;
    1:     void *mark;
    1:     JSBool ok;
    1: 
 6040:     invokevp = js_AllocStack(cx, 2 + argc, &mark);
 6040:     if (!invokevp)
 6040:         return JS_FALSE;
 6040: 
 6040:     invokevp[0] = fval;
 6040:     invokevp[1] = OBJECT_TO_JSVAL(obj);
 6040:     memcpy(invokevp + 2, argv, argc * sizeof *argv);
 6040: 
14721:     ok = js_Invoke(cx, argc, invokevp, flags);
    1:     if (ok) {
    1:         /*
    1:          * Store *rval in the a scoped local root if a scope is open, else in
    1:          * the lastInternalResult pigeon-hole GC root, solely so users of
    1:          * js_InternalInvoke and its direct and indirect (js_ValueToString for
    1:          * example) callers do not need to manage roots for local, temporary
    1:          * references to such results.
    1:          */
 6040:         *rval = *invokevp;
  583:         if (JSVAL_IS_GCTHING(*rval) && *rval != JSVAL_NULL) {
    1:             if (cx->localRootStack) {
    1:                 if (js_PushLocalRoot(cx, cx->localRootStack, *rval) < 0)
    1:                     ok = JS_FALSE;
    1:             } else {
    1:                 cx->weakRoots.lastInternalResult = *rval;
    1:             }
    1:         }
    1:     }
    1: 
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, jsval fval,
    1:                     JSAccessMode mode, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     /*
    1:      * js_InternalInvoke could result in another try to get or set the same id
    1:      * again, see bug 355497.
    1:      */
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     /*
    1:      * Check general (not object-ops/class-specific) access from the running
    1:      * script to obj.id only if id has a scripted getter or setter that we're
    1:      * about to invoke.  If we don't check this case, nothing else will -- no
    1:      * other native code has the chance to check.
    1:      *
    1:      * Contrast this non-native (scripted) case with native getter and setter
    1:      * accesses, where the native itself must do an access check, if security
    1:      * policies requires it.  We make a checkAccess or checkObjectAccess call
    1:      * back to the embedding program only in those cases where we're not going
    1:      * to call an embedding-defined native function, getter, setter, or class
    1:      * hook anyway.  Where we do call such a native, there's no need for the
    1:      * engine to impose a separate access check callback on all embeddings --
    1:      * many embeddings have no security policy at all.
    1:      */
    1:     JS_ASSERT(mode == JSACC_READ || mode == JSACC_WRITE);
    1:     if (cx->runtime->checkObjectAccess &&
    1:         VALUE_IS_FUNCTION(cx, fval) &&
13702:         FUN_INTERPRETED(GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(fval))) &&
    1:         !cx->runtime->checkObjectAccess(cx, obj, ID_TO_VALUE(id), mode,
    1:                                         &fval)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return js_InternalCall(cx, obj, fval, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_Execute(JSContext *cx, JSObject *chain, JSScript *script,
    1:            JSStackFrame *down, uintN flags, jsval *result)
    1: {
    1:     JSInterpreterHook hook;
    1:     void *hookData, *mark;
    1:     JSStackFrame *oldfp, frame;
    1:     JSObject *obj, *tmp;
    1:     JSBool ok;
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_EXECUTE_START_ENABLED())
 7058:         jsdtrace_execute_start(script);
 7058: #endif
 7058: 
 2433:     hook = cx->debugHooks->executeHook;
    1:     hookData = mark = NULL;
    1:     oldfp = cx->fp;
    1:     frame.script = script;
    1:     if (down) {
    1:         /* Propagate arg/var state for eval and the debugger API. */
    1:         frame.callobj = down->callobj;
    1:         frame.argsobj = down->argsobj;
    1:         frame.varobj = down->varobj;
 4127:         frame.callee = down->callee;
    1:         frame.fun = down->fun;
    1:         frame.thisp = down->thisp;
12502:         if (down->flags & JSFRAME_COMPUTED_THIS)
12502:             flags |= JSFRAME_COMPUTED_THIS;
    1:         frame.argc = down->argc;
    1:         frame.argv = down->argv;
    1:         frame.nvars = down->nvars;
    1:         frame.vars = down->vars;
    1:         frame.annotation = down->annotation;
    1:         frame.sharpArray = down->sharpArray;
    1:     } else {
    1:         frame.callobj = frame.argsobj = NULL;
    1:         obj = chain;
    1:         if (cx->options & JSOPTION_VAROBJFIX) {
    1:             while ((tmp = OBJ_GET_PARENT(cx, obj)) != NULL)
    1:                 obj = tmp;
    1:         }
    1:         frame.varobj = obj;
 4127:         frame.callee = NULL;
    1:         frame.fun = NULL;
    1:         frame.thisp = chain;
12503:         OBJ_TO_OUTER_OBJECT(cx, frame.thisp);
12503:         if (!frame.thisp) {
12503:             ok = JS_FALSE;
12503:             goto out;
12503:         }
12503:         flags |= JSFRAME_COMPUTED_THIS;
    1:         frame.argc = 0;
    1:         frame.argv = NULL;
 3235:         frame.nvars = script->ngvars;
 3235:         if (script->regexpsOffset != 0)
 3235:             frame.nvars += JS_SCRIPT_REGEXPS(script)->length;
 3235:         if (frame.nvars != 0) {
12551:             frame.vars = js_AllocRawStack(cx, frame.nvars, &mark);
 7058:             if (!frame.vars) {
 7058:                 ok = JS_FALSE;
 7058:                 goto out;
 7058:             }
    1:             memset(frame.vars, 0, frame.nvars * sizeof(jsval));
    1:         } else {
    1:             frame.vars = NULL;
    1:         }
    1:         frame.annotation = NULL;
    1:         frame.sharpArray = NULL;
    1:     }
    1:     frame.rval = JSVAL_VOID;
    1:     frame.down = down;
    1:     frame.scopeChain = chain;
13168:     frame.regs = NULL;
    1:     frame.spbase = NULL;
    1:     frame.sharpDepth = 0;
12502:     frame.flags = flags;
    1:     frame.dormantNext = NULL;
    1:     frame.xmlNamespace = NULL;
    1:     frame.blockChain = NULL;
    1: 
    1:     /*
    1:      * Here we wrap the call to js_Interpret with code to (conditionally)
    1:      * save and restore the old stack frame chain into a chain of 'dormant'
    1:      * frame chains.  Since we are replacing cx->fp, we were running into
    1:      * the problem that if GC was called under this frame, some of the GC
    1:      * things associated with the old frame chain (available here only in
    1:      * the C variable 'oldfp') were not rooted and were being collected.
    1:      *
    1:      * So, now we preserve the links to these 'dormant' frame chains in cx
    1:      * before calling js_Interpret and cleanup afterwards.  The GC walks
    1:      * these dormant chains and marks objects in the same way that it marks
    1:      * objects in the primary cx->fp chain.
    1:      */
    1:     if (oldfp && oldfp != down) {
    1:         JS_ASSERT(!oldfp->dormantNext);
    1:         oldfp->dormantNext = cx->dormantFrameChain;
    1:         cx->dormantFrameChain = oldfp;
    1:     }
    1: 
    1:     cx->fp = &frame;
 2433:     if (hook) {
 2433:         hookData = hook(cx, &frame, JS_TRUE, 0,
 2433:                         cx->debugHooks->executeHookData);
 2433:     }
    1: 
12688:     ok = js_Interpret(cx);
    1:     *result = frame.rval;
    1: 
    1:     if (hookData) {
 2433:         hook = cx->debugHooks->executeHook;
    1:         if (hook)
    1:             hook(cx, &frame, JS_FALSE, &ok, hookData);
    1:     }
    1:     if (mark)
12551:         js_FreeRawStack(cx, mark);
    1:     cx->fp = oldfp;
    1: 
    1:     if (oldfp && oldfp != down) {
    1:         JS_ASSERT(cx->dormantFrameChain == oldfp);
    1:         cx->dormantFrameChain = oldfp->dormantNext;
    1:         oldfp->dormantNext = NULL;
    1:     }
    1: 
 7058: out:
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_EXECUTE_DONE_ENABLED())
 7058:         jsdtrace_execute_done(script);
 7058: #endif
    1:     return ok;
    1: }
    1: 
    1: #if JS_HAS_EXPORT_IMPORT
    1: /*
    1:  * If id is JSVAL_VOID, import all exported properties from obj.
    1:  */
12551: JSBool
12551: js_ImportProperty(JSContext *cx, JSObject *obj, jsid id)
    1: {
    1:     JSBool ok;
    1:     JSIdArray *ida;
    1:     JSProperty *prop;
    1:     JSObject *obj2, *target, *funobj, *closure;
    1:     uintN attrs;
    1:     jsint i;
    1:     jsval value;
    1: 
    1:     if (JSVAL_IS_VOID(id)) {
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return JS_FALSE;
    1:         ok = JS_TRUE;
    1:         if (ida->length == 0)
    1:             goto out;
    1:     } else {
    1:         ida = NULL;
    1:         if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             js_ReportValueError(cx, JSMSG_NOT_DEFINED,
    1:                                 JSDVG_IGNORE_STACK, ID_TO_VALUE(id), NULL);
    1:             return JS_FALSE;
    1:         }
    1:         ok = OBJ_GET_ATTRIBUTES(cx, obj, id, prop, &attrs);
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         if (!ok)
    1:             return JS_FALSE;
    1:         if (!(attrs & JSPROP_EXPORTED)) {
    1:             js_ReportValueError(cx, JSMSG_NOT_EXPORTED,
    1:                                 JSDVG_IGNORE_STACK, ID_TO_VALUE(id), NULL);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     target = cx->fp->varobj;
    1:     i = 0;
    1:     do {
    1:         if (ida) {
    1:             id = ida->vector[i];
    1:             ok = OBJ_GET_ATTRIBUTES(cx, obj, id, NULL, &attrs);
    1:             if (!ok)
    1:                 goto out;
    1:             if (!(attrs & JSPROP_EXPORTED))
    1:                 continue;
    1:         }
    1:         ok = OBJ_CHECK_ACCESS(cx, obj, id, JSACC_IMPORT, &value, &attrs);
    1:         if (!ok)
    1:             goto out;
    1:         if (VALUE_IS_FUNCTION(cx, value)) {
    1:             funobj = JSVAL_TO_OBJECT(value);
13824:             closure = js_CloneFunctionObject(cx,
13824:                                              GET_FUNCTION_PRIVATE(cx, funobj),
13824:                                              obj);
    1:             if (!closure) {
    1:                 ok = JS_FALSE;
    1:                 goto out;
    1:             }
    1:             value = OBJECT_TO_JSVAL(closure);
    1:         }
    1: 
    1:         /*
    1:          * Handle the case of importing a property that refers to a local
    1:          * variable or formal parameter of a function activation.  These
    1:          * properties are accessed by opcodes using stack slot numbers
    1:          * generated by the compiler rather than runtime name-lookup.  These
    1:          * local references, therefore, bypass the normal scope chain lookup.
    1:          * So, instead of defining a new property in the activation object,
    1:          * modify the existing value in the stack slot.
    1:          */
    1:         if (OBJ_GET_CLASS(cx, target) == &js_CallClass) {
    1:             ok = OBJ_LOOKUP_PROPERTY(cx, target, id, &obj2, &prop);
    1:             if (!ok)
    1:                 goto out;
    1:         } else {
    1:             prop = NULL;
    1:         }
    1:         if (prop && target == obj2) {
    1:             ok = OBJ_SET_PROPERTY(cx, target, id, &value);
    1:         } else {
11819:             ok = OBJ_DEFINE_PROPERTY(cx, target, id, value,
11819:                                      JS_PropertyStub, JS_PropertyStub,
    1:                                      attrs & ~(JSPROP_EXPORTED |
    1:                                                JSPROP_GETTER |
    1:                                                JSPROP_SETTER),
    1:                                      NULL);
    1:         }
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         if (!ok)
    1:             goto out;
    1:     } while (ida && ++i < ida->length);
    1: 
    1: out:
    1:     if (ida)
    1:         JS_DestroyIdArray(cx, ida);
    1:     return ok;
    1: }
    1: #endif /* JS_HAS_EXPORT_IMPORT */
    1: 
    1: JSBool
    1: js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                       JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN oldAttrs, report;
    1:     JSBool isFunction;
    1:     jsval value;
    1:     const char *type, *name;
    1: 
    1:     if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (propp) {
    1:         *objp = obj2;
    1:         *propp = prop;
    1:     }
    1:     if (!prop)
    1:         return JS_TRUE;
    1: 
    1:     /*
    1:      * Use prop as a speedup hint to OBJ_GET_ATTRIBUTES, but drop it on error.
    1:      * An assertion at label bad: will insist that it is null.
    1:      */
    1:     if (!OBJ_GET_ATTRIBUTES(cx, obj2, id, prop, &oldAttrs)) {
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1: #ifdef DEBUG
    1:         prop = NULL;
    1: #endif
    1:         goto bad;
    1:     }
    1: 
    1:     /*
    1:      * From here, return true, or else goto bad on failure to null out params.
    1:      * If our caller doesn't want prop, drop it (we don't need it any longer).
    1:      */
    1:     if (!propp) {
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         prop = NULL;
    1:     }
    1: 
    1:     if (attrs == JSPROP_INITIALIZER) {
    1:         /* Allow the new object to override properties. */
    1:         if (obj2 != obj)
    1:             return JS_TRUE;
    1:         report = JSREPORT_WARNING | JSREPORT_STRICT;
    1:     } else {
    1:         /* We allow redeclaring some non-readonly properties. */
    1:         if (((oldAttrs | attrs) & JSPROP_READONLY) == 0) {
    1:             /*
    1:              * Allow redeclaration of variables and functions, but insist that
    1:              * the new value is not a getter if the old value was, ditto for
    1:              * setters -- unless prop is impermanent (in which case anyone
    1:              * could delete it and redefine it, willy-nilly).
    1:              */
    1:             if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
    1:                 return JS_TRUE;
    1:             if ((~(oldAttrs ^ attrs) & (JSPROP_GETTER | JSPROP_SETTER)) == 0)
    1:                 return JS_TRUE;
    1:             if (!(oldAttrs & JSPROP_PERMANENT))
    1:                 return JS_TRUE;
    1:         }
    1: 
    1:         report = JSREPORT_ERROR;
    1:         isFunction = (oldAttrs & (JSPROP_GETTER | JSPROP_SETTER)) != 0;
    1:         if (!isFunction) {
    1:             if (!OBJ_GET_PROPERTY(cx, obj, id, &value))
    1:                 goto bad;
    1:             isFunction = VALUE_IS_FUNCTION(cx, value);
    1:         }
    1:     }
    1: 
    1:     type = (attrs == JSPROP_INITIALIZER)
    1:            ? "property"
    1:            : (oldAttrs & attrs & JSPROP_GETTER)
    1:            ? js_getter_str
    1:            : (oldAttrs & attrs & JSPROP_SETTER)
    1:            ? js_setter_str
    1:            : (oldAttrs & JSPROP_READONLY)
    1:            ? js_const_str
    1:            : isFunction
    1:            ? js_function_str
    1:            : js_var_str;
    1:     name = js_ValueToPrintableString(cx, ID_TO_VALUE(id));
    1:     if (!name)
    1:         goto bad;
    1:     return JS_ReportErrorFlagsAndNumber(cx, report,
    1:                                         js_GetErrorMessage, NULL,
    1:                                         JSMSG_REDECLARED_VAR,
    1:                                         type, name);
    1: 
    1: bad:
    1:     if (propp) {
    1:         *objp = NULL;
    1:         *propp = NULL;
    1:     }
    1:     JS_ASSERT(!prop);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
 9560: js_StrictlyEqual(JSContext *cx, jsval lval, jsval rval)
    1: {
    1:     jsval ltag = JSVAL_TAG(lval), rtag = JSVAL_TAG(rval);
    1:     jsdouble ld, rd;
    1: 
    1:     if (ltag == rtag) {
    1:         if (ltag == JSVAL_STRING) {
    1:             JSString *lstr = JSVAL_TO_STRING(lval),
    1:                      *rstr = JSVAL_TO_STRING(rval);
    1:             return js_EqualStrings(lstr, rstr);
    1:         }
    1:         if (ltag == JSVAL_DOUBLE) {
    1:             ld = *JSVAL_TO_DOUBLE(lval);
    1:             rd = *JSVAL_TO_DOUBLE(rval);
    1:             return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:         }
 9560:         if (ltag == JSVAL_OBJECT &&
 9560:             lval != rval &&
 9560:             !JSVAL_IS_NULL(lval) &&
 9560:             !JSVAL_IS_NULL(rval)) {
 9560:             JSObject *lobj, *robj;
12674: 
12674:             lobj = js_GetWrappedObject(cx, JSVAL_TO_OBJECT(lval));
12674:             robj = js_GetWrappedObject(cx, JSVAL_TO_OBJECT(rval));
 9579:             lval = OBJECT_TO_JSVAL(lobj);
 9579:             rval = OBJECT_TO_JSVAL(robj);
 9579:         }
    1:         return lval == rval;
    1:     }
    1:     if (ltag == JSVAL_DOUBLE && JSVAL_IS_INT(rval)) {
    1:         ld = *JSVAL_TO_DOUBLE(lval);
    1:         rd = JSVAL_TO_INT(rval);
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
    1:     if (JSVAL_IS_INT(lval) && rtag == JSVAL_DOUBLE) {
    1:         ld = JSVAL_TO_INT(lval);
    1:         rd = *JSVAL_TO_DOUBLE(rval);
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
    1:     return lval == rval;
    1: }
    1: 
    1: JSBool
14789: js_InvokeConstructor(JSContext *cx, uintN argc, jsval *vp)
    1: {
 8367:     JSFunction *fun, *fun2;
    1:     JSObject *obj, *obj2, *proto, *parent;
    1:     jsval lval, rval;
 8367:     JSClass *clasp;
    1: 
    1:     fun = NULL;
    1:     obj2 = NULL;
    1:     lval = *vp;
    1:     if (!JSVAL_IS_OBJECT(lval) ||
    1:         (obj2 = JSVAL_TO_OBJECT(lval)) == NULL ||
    1:         /* XXX clean up to avoid special cases above ObjectOps layer */
    1:         OBJ_GET_CLASS(cx, obj2) == &js_FunctionClass ||
    1:         !obj2->map->ops->construct)
    1:     {
    1:         fun = js_ValueToFunction(cx, vp, JSV2F_CONSTRUCT);
    1:         if (!fun)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     clasp = &js_ObjectClass;
    1:     if (!obj2) {
    1:         proto = parent = NULL;
    1:         fun = NULL;
    1:     } else {
    1:         /*
    1:          * Get the constructor prototype object for this function.
    1:          * Use the nominal 'this' parameter slot, vp[1], as a local
    1:          * root to protect this prototype, in case it has no other
    1:          * strong refs.
    1:          */
    1:         if (!OBJ_GET_PROPERTY(cx, obj2,
    1:                               ATOM_TO_JSID(cx->runtime->atomState
    1:                                            .classPrototypeAtom),
    1:                               &vp[1])) {
    1:             return JS_FALSE;
    1:         }
    1:         rval = vp[1];
    1:         proto = JSVAL_IS_OBJECT(rval) ? JSVAL_TO_OBJECT(rval) : NULL;
    1:         parent = OBJ_GET_PARENT(cx, obj2);
    1: 
    1:         if (OBJ_GET_CLASS(cx, obj2) == &js_FunctionClass) {
13691:             fun2 = GET_FUNCTION_PRIVATE(cx, obj2);
13702:             if (!FUN_INTERPRETED(fun2) && fun2->u.n.clasp)
13702:                 clasp = fun2->u.n.clasp;
13702:         }
13702:     }
13824:     obj = js_NewObject(cx, clasp, proto, parent, 0);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
    1:     /* Now we have an object with a constructor method; call it. */
    1:     vp[1] = OBJECT_TO_JSVAL(obj);
 6040:     if (!js_Invoke(cx, argc, vp, JSINVOKE_CONSTRUCT)) {
    1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Check the return value and if it's primitive, force it to be obj. */
    1:     rval = *vp;
    1:     if (JSVAL_IS_PRIMITIVE(rval)) {
    1:         if (!fun) {
    1:             /* native [[Construct]] returning primitive is error */
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_NEW_RESULT,
    1:                                  js_ValueToPrintableString(cx, rval));
    1:             return JS_FALSE;
    1:         }
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:     }
    1: 
    1:     JS_RUNTIME_METER(cx->runtime, constructs);
    1:     return JS_TRUE;
    1: }
    1: 
12551: JSBool
12551: js_InternNonIntElementId(JSContext *cx, JSObject *obj, jsval idval, jsid *idp)
    1: {
    1:     JS_ASSERT(!JSVAL_IS_INT(idval));
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     if (!JSVAL_IS_PRIMITIVE(idval)) {
    1:         if (OBJECT_IS_XML(cx, obj)) {
    1:             *idp = OBJECT_JSVAL_TO_JSID(idval);
    1:             return JS_TRUE;
    1:         }
    1:         if (!js_IsFunctionQName(cx, JSVAL_TO_OBJECT(idval), idp))
    1:             return JS_FALSE;
    1:         if (*idp != 0)
    1:             return JS_TRUE;
    1:     }
    1: #endif
    1: 
10573:     return js_ValueToStringId(cx, idval, idp);
    1: }
    1: 
    1: /*
11672:  * Enter the new with scope using an object at sp[-1] and associate the depth
11672:  * of the with block with sp + stackIndex.
11672:  */
12551: JSBool
12551: js_EnterWith(JSContext *cx, jsint stackIndex)
11672: {
11672:     JSStackFrame *fp;
11672:     jsval *sp;
11672:     JSObject *obj, *parent, *withobj;
11672: 
11672:     fp = cx->fp;
13168:     sp = fp->regs->sp;
11672:     JS_ASSERT(stackIndex < 0);
11672:     JS_ASSERT(fp->spbase <= sp + stackIndex);
11672: 
11672:     if (!JSVAL_IS_PRIMITIVE(sp[-1])) {
11672:         obj = JSVAL_TO_OBJECT(sp[-1]);
11672:     } else {
11672:         obj = js_ValueToNonNullObject(cx, sp[-1]);
11672:         if (!obj)
11672:             return JS_FALSE;
11672:         sp[-1] = OBJECT_TO_JSVAL(obj);
11672:     }
11672: 
11672:     parent = js_GetScopeChain(cx, fp);
11672:     if (!parent)
11672:         return JS_FALSE;
11672: 
11672:     OBJ_TO_INNER_OBJECT(cx, obj);
11672:     if (!obj)
11672:         return JS_FALSE;
11672: 
11672:     withobj = js_NewWithObject(cx, obj, parent,
11672:                                sp + stackIndex - fp->spbase);
11672:     if (!withobj)
11672:         return JS_FALSE;
11672: 
11672:     fp->scopeChain = withobj;
11672:     js_DisablePropertyCache(cx);
11672:     return JS_TRUE;
11672: }
11672: 
12551: void
12551: js_LeaveWith(JSContext *cx)
11672: {
11672:     JSObject *withobj;
11672: 
11672:     withobj = cx->fp->scopeChain;
11672:     JS_ASSERT(OBJ_GET_CLASS(cx, withobj) == &js_WithClass);
11758:     JS_ASSERT(OBJ_GET_PRIVATE(cx, withobj) == cx->fp);
11758:     JS_ASSERT(OBJ_BLOCK_DEPTH(cx, withobj) >= 0);
11672:     cx->fp->scopeChain = OBJ_GET_PARENT(cx, withobj);
11672:     JS_SetPrivate(cx, withobj, NULL);
11672:     js_EnablePropertyCache(cx);
11672: }
11672: 
12551: JSClass *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth)
11758: {
11758:     JSClass *clasp;
11758: 
11758:     clasp = OBJ_GET_CLASS(cx, obj);
11758:     if ((clasp == &js_WithClass || clasp == &js_BlockClass) &&
11758:         OBJ_GET_PRIVATE(cx, obj) == cx->fp &&
11758:         OBJ_BLOCK_DEPTH(cx, obj) >= stackDepth) {
11758:         return clasp;
11758:     }
11758:     return NULL;
11758: }
11758: 
12551: jsint
12551: js_CountWithBlocks(JSContext *cx, JSStackFrame *fp)
11758: {
11758:     jsint n;
11758:     JSObject *obj;
11758:     JSClass *clasp;
11758: 
11758:     n = 0;
11758:     for (obj = fp->scopeChain;
12551:          (clasp = js_IsActiveWithOrBlock(cx, obj, 0)) != NULL;
11758:          obj = OBJ_GET_PARENT(cx, obj)) {
11758:         if (clasp == &js_WithClass)
11758:             ++n;
11758:     }
11758:     return n;
11758: }
11758: 
11758: /*
11758:  * Unwind block and scope chains to match the given depth. The function sets
11758:  * fp->sp on return to stackDepth.
11758:  */
12551: JSBool
12551: js_UnwindScope(JSContext *cx, JSStackFrame *fp, jsint stackDepth,
11758:                JSBool normalUnwind)
11758: {
11758:     JSObject *obj;
11758:     JSClass *clasp;
11758: 
11758:     JS_ASSERT(stackDepth >= 0);
13168:     JS_ASSERT(fp->spbase + stackDepth <= fp->regs->sp);
11758: 
11758:     for (obj = fp->blockChain; obj; obj = OBJ_GET_PARENT(cx, obj)) {
11758:         JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_BlockClass);
11758:         if (OBJ_BLOCK_DEPTH(cx, obj) < stackDepth)
11758:             break;
11758:     }
11758:     fp->blockChain = obj;
11758: 
11758:     for (;;) {
11758:         obj = fp->scopeChain;
12551:         clasp = js_IsActiveWithOrBlock(cx, obj, stackDepth);
11758:         if (!clasp)
11758:             break;
11758:         if (clasp == &js_BlockClass) {
11758:             /* Don't fail until after we've updated all stacks. */
11859:             normalUnwind &= js_PutBlockObject(cx, normalUnwind);
11758:         } else {
12551:             js_LeaveWith(cx);
11758:         }
11758:     }
11758: 
13168:     fp->regs->sp = fp->spbase + stackDepth;
11758:     return normalUnwind;
11758: }
11758: 
12611: JSBool
12611: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, jsval *vp, jsval *vp2)
12611: {
12611:     jsval v;
12611:     jsdouble d;
12611: 
12611:     v = *vp;
12611:     if (JSVAL_IS_DOUBLE(v)) {
12611:         d = *JSVAL_TO_DOUBLE(v);
12611:     } else if (JSVAL_IS_INT(v)) {
12611:         d = JSVAL_TO_INT(v);
12611:     } else {
12694:         d = js_ValueToNumber(cx, vp);
12694:         if (JSVAL_IS_NULL(*vp))
12611:             return JS_FALSE;
12850:         JS_ASSERT(JSVAL_IS_NUMBER(*vp) || *vp == JSVAL_TRUE);
12611: 
12611:         /* Store the result of v conversion back in vp for post increments. */
12850:         if ((cs->format & JOF_POST) &&
12850:             *vp == JSVAL_TRUE
12850:             && !js_NewNumberInRootedValue(cx, d, vp)) {
12611:             return JS_FALSE;
12611:         }
12850:     }
12611: 
12611:     (cs->format & JOF_INC) ? d++ : d--;
12850:     if (!js_NewNumberInRootedValue(cx, d, vp2))
12611:         return JS_FALSE;
12611: 
12611:     if (!(cs->format & JOF_POST))
12611:         *vp = *vp2;
12611:     return JS_TRUE;
12611: }
12611: 
12551: #ifdef JS_OPMETER
    1: 
    1: # include <stdlib.h>
    1: 
12551: # define HIST_NSLOTS            8
12551: 
    1: /*
    1:  * The second dimension is hardcoded at 256 because we know that many bits fit
    1:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
    1:  * any particular row.
    1:  */
    1: static uint32 succeeds[JSOP_LIMIT][256];
    1: static uint32 slot_ops[JSOP_LIMIT][HIST_NSLOTS];
    1: 
12551: void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2)
12551: {
12551:     if (op1 != JSOP_STOP)
12551:         ++succeeds[op1][op2];
12551: }
12551: 
12551: void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot)
12551: {
12551:     if (slot < HIST_NSLOTS)
12551:         ++slot_ops[op][slot];
12551: }
12551: 
    1: typedef struct Edge {
    1:     const char  *from;
    1:     const char  *to;
    1:     uint32      count;
    1: } Edge;
    1: 
    1: static int
    1: compare_edges(const void *a, const void *b)
    1: {
    1:     const Edge *ea = (const Edge *) a;
    1:     const Edge *eb = (const Edge *) b;
    1: 
    1:     return (int32)eb->count - (int32)ea->count;
    1: }
    1: 
    1: void
    1: js_DumpOpMeters()
    1: {
    1:     const char *name, *from, *style;
    1:     FILE *fp;
    1:     uint32 total, count;
    1:     uint32 i, j, nedges;
    1:     Edge *graph;
    1: 
    1:     name = getenv("JS_OPMETER_FILE");
    1:     if (!name)
    1:         name = "/tmp/ops.dot";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1: 
    1:     total = nedges = 0;
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0) {
    1:                 total += count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1: 
    1: # define SIGNIFICANT(count,total) (200. * (count) >= (total))
    1: 
    1:     graph = (Edge *) calloc(nedges, sizeof graph[0]);
    1:     for (i = nedges = 0; i < JSOP_LIMIT; i++) {
12410:         from = js_CodeName[i];
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0 && SIGNIFICANT(count, total)) {
    1:                 graph[nedges].from = from;
12410:                 graph[nedges].to = js_CodeName[j];
    1:                 graph[nedges].count = count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1:     qsort(graph, nedges, sizeof(Edge), compare_edges);
    1: 
    1: # undef SIGNIFICANT
    1: 
    1:     fputs("digraph {\n", fp);
    1:     for (i = 0, style = NULL; i < nedges; i++) {
    1:         JS_ASSERT(i == 0 || graph[i-1].count >= graph[i].count);
    1:         if (!style || graph[i-1].count != graph[i].count) {
    1:             style = (i > nedges * .75) ? "dotted" :
    1:                     (i > nedges * .50) ? "dashed" :
    1:                     (i > nedges * .25) ? "solid" : "bold";
    1:         }
    1:         fprintf(fp, "  %s -> %s [label=\"%lu\" style=%s]\n",
    1:                 graph[i].from, graph[i].to,
    1:                 (unsigned long)graph[i].count, style);
    1:     }
    1:     free(graph);
    1:     fputs("}\n", fp);
    1:     fclose(fp);
    1: 
    1:     name = getenv("JS_OPMETER_HIST");
    1:     if (!name)
    1:         name = "/tmp/ops.hist";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1:     fputs("bytecode", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fprintf(fp, "  slot %1u", (unsigned)j);
    1:     putc('\n', fp);
    1:     fputs("========", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fputs(" =======", fp);
    1:     putc('\n', fp);
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < HIST_NSLOTS; j++) {
    1:             if (slot_ops[i][j] != 0) {
    1:                 /* Reuse j in the next loop, since we break after. */
12410:                 fprintf(fp, "%-8.8s", js_CodeName[i]);
    1:                 for (j = 0; j < HIST_NSLOTS; j++)
    1:                     fprintf(fp, " %7lu", (unsigned long)slot_ops[i][j]);
    1:                 putc('\n', fp);
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     fclose(fp);
    1: }
    1: 
    1: #endif /* JS_OPSMETER */
    1: 
12551: #else /* !defined js_invoke_c__ */
12551: 
13168: #define PUSH(v)         (*regs.sp++ = (v))
12579: #define PUSH_OPND(v)    PUSH(v)
13168: #define STORE_OPND(n,v) (regs.sp[n] = (v))
13168: #define POP()           (*--regs.sp)
12551: #define POP_OPND()      POP()
13168: #define FETCH_OPND(n)   (regs.sp[n])
12551: 
12551: /*
12579:  * Push the jsdouble d using sp from the lexical environment. Try to convert d
12579:  * to a jsint that fits in a jsval, otherwise GC-alloc space for it and push a
12579:  * reference.
12551:  */
12551: #define STORE_NUMBER(cx, n, d)                                                \
12551:     JS_BEGIN_MACRO                                                            \
12551:         jsint i_;                                                             \
12551:                                                                               \
13168:         if (JSDOUBLE_IS_INT(d, i_) && INT_FITS_IN_JSVAL(i_))                  \
13168:             regs.sp[n] = INT_TO_JSVAL(i_);                                    \
13168:         else if (!js_NewDoubleInRootedValue(cx, d, &regs.sp[n]))              \
12551:             goto error;                                                       \
12551:     JS_END_MACRO
12551: 
12551: #define STORE_INT(cx, n, i)                                                   \
12551:     JS_BEGIN_MACRO                                                            \
13168:         if (INT_FITS_IN_JSVAL(i))                                             \
13168:             regs.sp[n] = INT_TO_JSVAL(i);                                     \
13168:         else if (!js_NewDoubleInRootedValue(cx, (jsdouble) (i), &regs.sp[n])) \
12551:             goto error;                                                       \
12551:     JS_END_MACRO
12551: 
12551: #define STORE_UINT(cx, n, u)                                                  \
12551:     JS_BEGIN_MACRO                                                            \
13168:         if ((u) <= JSVAL_INT_MAX)                                             \
13168:             regs.sp[n] = INT_TO_JSVAL(u);                                     \
13168:         else if (!js_NewDoubleInRootedValue(cx, (jsdouble) (u), &regs.sp[n])) \
12551:             goto error;                                                       \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_NUMBER(cx, n, d)                                                \
12551:     JS_BEGIN_MACRO                                                            \
12551:         jsval v_;                                                             \
12551:                                                                               \
12551:         v_ = FETCH_OPND(n);                                                   \
12694:         VALUE_TO_NUMBER(cx, n, v_, d);                                        \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_INT(cx, n, i)                                                   \
12551:     JS_BEGIN_MACRO                                                            \
12681:         jsval v_;                                                             \
12681:                                                                               \
12681:         v_= FETCH_OPND(n);                                                    \
12551:         if (JSVAL_IS_INT(v_)) {                                               \
12551:             i = JSVAL_TO_INT(v_);                                             \
12551:         } else {                                                              \
13168:             i = js_ValueToECMAInt32(cx, &regs.sp[n]);                         \
13168:             if (JSVAL_IS_NULL(regs.sp[n]))                                    \
12551:                 goto error;                                                   \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_UINT(cx, n, ui)                                                 \
12551:     JS_BEGIN_MACRO                                                            \
12681:         jsval v_;                                                             \
12681:                                                                               \
12681:         v_= FETCH_OPND(n);                                                    \
12681:         if (JSVAL_IS_INT(v_)) {                                               \
12681:             ui = (uint32) JSVAL_TO_INT(v_);                                   \
12551:         } else {                                                              \
13168:             ui = js_ValueToECMAUint32(cx, &regs.sp[n]);                       \
13168:             if (JSVAL_IS_NULL(regs.sp[n]))                                    \
12551:                 goto error;                                                   \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: /*
12551:  * Optimized conversion macros that test for the desired type in v before
12551:  * homing sp and calling a conversion function.
12551:  */
12694: #define VALUE_TO_NUMBER(cx, n, v, d)                                          \
12551:     JS_BEGIN_MACRO                                                            \
13168:         JS_ASSERT(v == regs.sp[n]);                                           \
12551:         if (JSVAL_IS_INT(v)) {                                                \
12551:             d = (jsdouble)JSVAL_TO_INT(v);                                    \
12551:         } else if (JSVAL_IS_DOUBLE(v)) {                                      \
12551:             d = *JSVAL_TO_DOUBLE(v);                                          \
12551:         } else {                                                              \
13168:             d = js_ValueToNumber(cx, &regs.sp[n]);                            \
13168:             if (JSVAL_IS_NULL(regs.sp[n]))                                    \
12551:                 goto error;                                                   \
13168:             JS_ASSERT(JSVAL_IS_NUMBER(regs.sp[n]) ||                          \
13168:                       regs.sp[n] == JSVAL_TRUE);                              \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: #define POP_BOOLEAN(cx, v, b)                                                 \
12551:     JS_BEGIN_MACRO                                                            \
12551:         v = FETCH_OPND(-1);                                                   \
12551:         if (v == JSVAL_NULL) {                                                \
12551:             b = JS_FALSE;                                                     \
12551:         } else if (JSVAL_IS_BOOLEAN(v)) {                                     \
12551:             b = JSVAL_TO_BOOLEAN(v);                                          \
12551:         } else {                                                              \
12551:             b = js_ValueToBoolean(v);                                         \
12551:         }                                                                     \
13168:         regs.sp--;                                                            \
12551:     JS_END_MACRO
12551: 
12551: #define VALUE_TO_OBJECT(cx, n, v, obj)                                        \
12551:     JS_BEGIN_MACRO                                                            \
12551:         if (!JSVAL_IS_PRIMITIVE(v)) {                                         \
12551:             obj = JSVAL_TO_OBJECT(v);                                         \
12551:         } else {                                                              \
12551:             obj = js_ValueToNonNullObject(cx, v);                             \
12551:             if (!obj)                                                         \
12551:                 goto error;                                                   \
12551:             STORE_OPND(n, OBJECT_TO_JSVAL(obj));                              \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
12551: #define FETCH_OBJECT(cx, n, v, obj)                                           \
12551:     JS_BEGIN_MACRO                                                            \
12551:         v = FETCH_OPND(n);                                                    \
12551:         VALUE_TO_OBJECT(cx, n, v, obj);                                       \
12551:     JS_END_MACRO
12551: 
12551: #define DEFAULT_VALUE(cx, n, hint, v)                                         \
12551:     JS_BEGIN_MACRO                                                            \
12551:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));                                    \
13168:         JS_ASSERT(v == regs.sp[n]);                                           \
13168:         if (!OBJ_DEFAULT_VALUE(cx, JSVAL_TO_OBJECT(v), hint, &regs.sp[n]))    \
12551:             goto error;                                                       \
13168:         v = regs.sp[n];                                                       \
12551:     JS_END_MACRO
12551: 
12551: /*
12611:  * Quickly test if v is an int from the [-2**29, 2**29) range, that is, when
12611:  * the lowest bit of v is 1 and the bits 30 and 31 are both either 0 or 1. For
12611:  * such v we can do increment or decrement via adding or subtracting two
12611:  * without checking that the result overflows JSVAL_INT_MIN or JSVAL_INT_MAX.
12611:  */
12611: #define CAN_DO_FAST_INC_DEC(v)     (((((v) << 1) ^ v) & 0x80000001) == 1)
12611: 
12611: JS_STATIC_ASSERT(JSVAL_INT == 1);
12611: JS_STATIC_ASSERT(JSVAL_INT & JSVAL_VOID);
12611: JS_STATIC_ASSERT(!CAN_DO_FAST_INC_DEC(JSVAL_VOID));
12611: JS_STATIC_ASSERT(!CAN_DO_FAST_INC_DEC(INT_TO_JSVAL(JSVAL_INT_MIN)));
12611: JS_STATIC_ASSERT(!CAN_DO_FAST_INC_DEC(INT_TO_JSVAL(JSVAL_INT_MAX)));
12611: 
12611: /*
12551:  * Conditional assert to detect failure to clear a pending exception that is
12551:  * suppressed (or unintentional suppression of a wanted exception).
12551:  */
12551: #if defined DEBUG_brendan || defined DEBUG_mrbkap || defined DEBUG_shaver
12551: # define DEBUG_NOT_THROWING 1
12551: #endif
12551: 
12551: #ifdef DEBUG_NOT_THROWING
12551: # define ASSERT_NOT_THROWING(cx) JS_ASSERT(!(cx)->throwing)
12551: #else
12551: # define ASSERT_NOT_THROWING(cx) /* nothing */
12551: #endif
12551: 
12551: /*
12551:  * Define JS_OPMETER to instrument bytecode succession, generating a .dot file
12551:  * on shutdown that shows the graph of significant predecessor/successor pairs
12551:  * executed, where the edge labels give the succession counts.  The .dot file
12551:  * is named by the JS_OPMETER_FILE envariable, and defaults to /tmp/ops.dot.
12551:  *
12551:  * Bonus feature: JS_OPMETER also enables counters for stack-addressing ops
12551:  * such as JSOP_GETVAR, JSOP_INCARG, via METER_SLOT_OP.  The resulting counts
12551:  * are written to JS_OPMETER_HIST, defaulting to /tmp/ops.hist.
12551:  */
12551: #ifndef JS_OPMETER
12551: # define METER_OP_INIT(op)      /* nothing */
12551: # define METER_OP_PAIR(op1,op2) /* nothing */
12551: # define METER_SLOT_OP(op,slot) /* nothing */
12551: #else
12551: 
12551: /*
12551:  * The second dimension is hardcoded at 256 because we know that many bits fit
12551:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
12551:  * any particular row.
12551:  */
12551: # define METER_OP_INIT(op)      ((op) = JSOP_STOP)
12551: # define METER_OP_PAIR(op1,op2) (js_MeterOpcodePair(op1, op2))
12551: # define METER_SLOT_OP(op,slot) (js_MeterSlotOpcode(op, slot))
12551: 
12551: #endif
12551: 
13872: #define MAX_INLINE_CALL_COUNT 3000
13872: 
12551: /*
12551:  * Threaded interpretation via computed goto appears to be well-supported by
12551:  * GCC 3 and higher.  IBM's C compiler when run with the right options (e.g.,
12551:  * -qlanglvl=extended) also supports threading.  Ditto the SunPro C compiler.
12551:  * Currently it's broken for JS_VERSION < 160, though this isn't worth fixing.
12551:  * Add your compiler support macros here.
12551:  */
12551: #ifndef JS_THREADED_INTERP
12551: # if JS_VERSION >= 160 && (                                                   \
12551:     __GNUC__ >= 3 ||                                                          \
12551:     (__IBMC__ >= 700 && defined __IBM_COMPUTED_GOTO) ||                       \
12551:     __SUNPRO_C >= 0x570)
12551: #  define JS_THREADED_INTERP 1
12551: # else
12551: #  define JS_THREADED_INTERP 0
12551: # endif
12551: #endif
12551: 
    1: /*
    1:  * Ensure that the intrepreter switch can close call-bytecode cases in the
    1:  * same way as non-call bytecodes.
    1:  */
    1: JS_STATIC_ASSERT(JSOP_NAME_LENGTH == JSOP_CALLNAME_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETGVAR_LENGTH == JSOP_CALLGVAR_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETVAR_LENGTH == JSOP_CALLVAR_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETARG_LENGTH == JSOP_CALLARG_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETLOCAL_LENGTH == JSOP_CALLLOCAL_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
    1: 
11377: /*
11377:  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
11377:  * remain distinct for the decompiler.
11377:  */
11377: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
11377: 
 8899: /* Ensure we can share deffun and closure code. */
 8899: JS_STATIC_ASSERT(JSOP_DEFFUN_LENGTH == JSOP_CLOSURE_LENGTH);
 8899: 
12681: 
12681: /* See comments in FETCH_SHIFT macro. */
12681: JS_STATIC_ASSERT((JSVAL_TO_INT(JSVAL_VOID) & 31) == 0);
12681: 
    1: JSBool
12688: js_Interpret(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     JSStackFrame *fp;
    1:     JSScript *script;
    1:     uintN inlineCallCount;
    1:     JSAtom **atoms;
12688:     JSVersion currentVersion, originalVersion;
12688:     void *mark;
13168:     JSFrameRegs regs;
    1:     JSObject *obj, *obj2, *parent;
    1:     JSBool ok, cond;
    1:     JSTrapHandler interruptHandler;
12579:     jsint len;
    1:     jsbytecode *endpc, *pc2;
    1:     JSOp op, op2;
 3235:     jsatomid index;
    1:     JSAtom *atom;
12423:     uintN argc, attrs, flags;
12423:     uint32 slot;
    1:     jsval *vp, lval, rval, ltmp, rtmp;
    1:     jsid id;
11672:     JSObject *iterobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSString *str, *str2;
    1:     jsint i, j;
    1:     jsdouble d, d2;
    1:     JSClass *clasp;
    1:     JSFunction *fun;
    1:     JSType type;
    1: #if !JS_THREADED_INTERP && defined DEBUG
    1:     FILE *tracefp = NULL;
    1: #endif
    1: #if JS_HAS_EXPORT_IMPORT
    1:     JSIdArray *ida;
    1: #endif
    1:     jsint low, high, off, npairs;
    1:     JSBool match;
    1: #if JS_HAS_GETTER_SETTER
    1:     JSPropertyOp getter, setter;
    1: #endif
    1: 
    1: #ifdef __GNUC__
    1: # define JS_EXTENSION __extension__
    1: # define JS_EXTENSION_(s) __extension__ ({ s; })
    1: #else
    1: # define JS_EXTENSION
    1: # define JS_EXTENSION_(s) s
    1: #endif
    1: 
    1: #if JS_THREADED_INTERP
    1:     static void *normalJumpTable[] = {
    1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
    1:         JS_EXTENSION &&L_##op,
    1: # include "jsopcode.tbl"
    1: # undef OPDEF
    1:     };
    1: 
    1:     static void *interruptJumpTable[] = {
    1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)              \
    1:         JS_EXTENSION &&interrupt,
    1: # include "jsopcode.tbl"
    1: # undef OPDEF
    1:     };
    1: 
    1:     register void **jumpTable = normalJumpTable;
    1: 
    1:     METER_OP_INIT(op);      /* to nullify first METER_OP_PAIR */
    1: 
    1: # define DO_OP()            JS_EXTENSION_(goto *jumpTable[op])
13168: # define DO_NEXT_OP(n)      do { METER_OP_PAIR(op, regs.pc[n]);               \
13168:                                  op = (JSOp) *(regs.pc += (n));               \
    1:                                  DO_OP(); } while (0)
    1: # define BEGIN_CASE(OP)     L_##OP:
    1: # define END_CASE(OP)       DO_NEXT_OP(OP##_LENGTH);
    1: # define END_VARLEN_CASE    DO_NEXT_OP(len);
13168: # define EMPTY_CASE(OP)     BEGIN_CASE(OP) op = (JSOp) *++regs.pc; DO_OP();
    1: #else
    1: # define DO_OP()            goto do_op
    1: # define DO_NEXT_OP(n)      goto advance_pc
    1: # define BEGIN_CASE(OP)     case OP:
    1: # define END_CASE(OP)       break;
    1: # define END_VARLEN_CASE    break;
    1: # define EMPTY_CASE(OP)     BEGIN_CASE(OP) END_CASE(OP)
    1: #endif
    1: 
11758:     /* Check for too deep a C stack. */
11758:     JS_CHECK_RECURSION(cx, return JS_FALSE);
11758: 
    1:     rt = cx->runtime;
    1: 
    1:     /* Set registerized frame pointer and derived script pointer. */
    1:     fp = cx->fp;
    1:     script = fp->script;
    1:     JS_ASSERT(script->length != 0);
    1: 
    1:     /* Count of JS function calls that nest in this C js_Interpret frame. */
    1:     inlineCallCount = 0;
    1: 
 3235:     /*
 3235:      * Initialize the index segment register used by LOAD_ATOM and
 3235:      * GET_FULL_INDEX macros bellow. As a register we use a pointer based on
 3235:      * the atom map to turn frequently executed LOAD_ATOM into simple array
 3235:      * access. For less frequent object and regexp loads we have to recover
 3235:      * the segment from atoms pointer first.
 3235:      */
    1:     atoms = script->atomMap.vector;
    1: 
 3235: #define LOAD_ATOM(PCOFF)                                                      \
 3235:     JS_BEGIN_MACRO                                                            \
 3235:         JS_ASSERT((size_t)(atoms - script->atomMap.vector) <                  \
13168:                   (size_t)(script->atomMap.length -                           \
13168:                            GET_INDEX(regs.pc + PCOFF)));                      \
13168:         atom = atoms[GET_INDEX(regs.pc + PCOFF)];                             \
 3235:     JS_END_MACRO
 3235: 
 3235: #define GET_FULL_INDEX(PCOFF)                                                 \
13168:     (atoms - script->atomMap.vector + GET_INDEX(regs.pc + PCOFF))
 3235: 
 3235: #define LOAD_OBJECT(PCOFF)                                                    \
 3235:     JS_GET_SCRIPT_OBJECT(script, GET_FULL_INDEX(PCOFF), obj)
 3235: 
 3235: #define LOAD_FUNCTION(PCOFF)                                                  \
13824:     JS_GET_SCRIPT_FUNCTION(script, GET_FULL_INDEX(PCOFF), fun)
    1: 
    1:     /*
11758:      * Prepare to call a user-supplied branch handler, and abort the script
11758:      * if it returns false.
11758:      */
11758: #define CHECK_BRANCH(len)                                                     \
11758:     JS_BEGIN_MACRO                                                            \
11758:         if (len <= 0 && (cx->operationCount -= JSOW_SCRIPT_JUMP) <= 0) {      \
11859:             if (!js_ResetOperationCount(cx))                                  \
11859:                 goto error;                                                   \
11758:         }                                                                     \
11758:     JS_END_MACRO
11758: 
11758:     /*
    1:      * Optimized Get and SetVersion for proper script language versioning.
    1:      *
    1:      * If any native method or JSClass/JSObjectOps hook calls js_SetVersion
    1:      * and changes cx->version, the effect will "stick" and we will stop
    1:      * maintaining currentVersion.  This is relied upon by testsuites, for
    1:      * the most part -- web browsers select version before compiling and not
    1:      * at run-time.
    1:      */
 3164:     currentVersion = (JSVersion) script->version;
 3164:     originalVersion = (JSVersion) cx->version;
    1:     if (currentVersion != originalVersion)
    1:         js_SetVersion(cx, currentVersion);
    1: 
11758:     ++cx->interpLevel;
11758: #ifdef DEBUG
11758:     fp->pcDisabledSave = JS_PROPERTY_CACHE(cx).disabled;
    1: #endif
    1: 
12688:     /*
13168:      * From this point control must flow through the label exit2.
11859:      *
12688:      * Load the debugger's interrupt hook here and after calling out to native
12688:      * functions (but not to getters, setters, or other native hooks), so we do
12688:      * not have to reload it each time through the interpreter loop -- we hope
12688:      * the compiler can keep it in a register when it is non-null.
12688:      */
12688: #if JS_THREADED_INTERP
12688: # define LOAD_JUMP_TABLE()                                                    \
12688:     (jumpTable = interruptHandler ? interruptJumpTable : normalJumpTable)
12688: #else
12688: # define LOAD_JUMP_TABLE()      ((void) 0)
12688: #endif
12688: 
12688: #define LOAD_INTERRUPT_HANDLER(cx)                                            \
12688:     JS_BEGIN_MACRO                                                            \
12688:         interruptHandler = (cx)->debugHooks->interruptHandler;                \
12688:         LOAD_JUMP_TABLE();                                                    \
12688:     JS_END_MACRO
12688: 
12688:     LOAD_INTERRUPT_HANDLER(cx);
12688: 
12688:      /*
12688:      * Initialize the pc register and allocate operand stack slots for the
12688:      * script's worst-case depth, unless we're resuming a generator.
    1:      */
    1:     if (JS_LIKELY(!fp->spbase)) {
11758:         ASSERT_NOT_THROWING(cx);
13168:         JS_ASSERT(!fp->regs);
12688:         fp->spbase = js_AllocRawStack(cx, script->depth, &mark);
12688:         if (!fp->spbase) {
    1:             ok = JS_FALSE;
13168:             goto exit2;
11758:         }
11758:         JS_ASSERT(mark);
13168:         regs.pc = script->code;
13168:         regs.sp = fp->spbase;
13168:         fp->regs = &regs;
    1:     } else {
13168:         JSGenerator *gen;
13168: 
11758:         JS_ASSERT(fp->flags & JSFRAME_GENERATOR);
11859:         mark = NULL;
13168:         gen = FRAME_TO_GENERATOR(fp);
13168:         JS_ASSERT(fp->regs == &gen->savedRegs);
13168:         regs = gen->savedRegs;
13168:         fp->regs = &regs;
13168:         JS_ASSERT((size_t) (regs.pc - script->code) <= script->length);
13168:         JS_ASSERT((size_t) (regs.sp - fp->spbase) <= script->depth);
11758:         JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled >= 0);
12551:         JS_PROPERTY_CACHE(cx).disabled += js_CountWithBlocks(cx, fp);
    1: 
    1:         /*
11758:          * To support generator_throw and to catch ignored exceptions,
11758:          * fail if cx->throwing is set.
    1:          */
11758:         if (cx->throwing) {
    1: #ifdef DEBUG_NOT_THROWING
11442:             if (cx->exception != JSVAL_ARETURN) {
    1:                 printf("JS INTERPRETER CALLED WITH PENDING EXCEPTION %lx\n",
    1:                        (unsigned long) cx->exception);
11442:             }
    1: #endif
11859:             goto error;
    1:         }
11758:     }
    1: 
    1: #if JS_THREADED_INTERP
    1: 
    1:     /*
    1:      * This is a loop, but it does not look like a loop.  The loop-closing
    1:      * jump is distributed throughout interruptJumpTable, and comes back to
    1:      * the interrupt label.  The dispatch on op is through normalJumpTable.
    1:      * The trick is LOAD_INTERRUPT_HANDLER setting jumpTable appropriately.
    1:      *
    1:      * It is important that "op" be initialized before the interrupt label
    1:      * because it is possible for "op" to be specially assigned during the
    1:      * normally processing of an opcode while looping (in particular, this
    1:      * happens in JSOP_TRAP while debugging).  We rely on DO_NEXT_OP to
    1:      * correctly manage "op" in all other cases.
    1:      */
13168:     op = (JSOp) *regs.pc;
    1:     if (interruptHandler) {
    1: interrupt:
13168:         switch (interruptHandler(cx, script, regs.pc, &rval,
12996:                                  cx->debugHooks->interruptHandlerData)) {
12996:           case JSTRAP_ERROR:
12996:             goto error;
12996:           case JSTRAP_CONTINUE:
12996:             break;
12996:           case JSTRAP_RETURN:
12996:             fp->rval = rval;
12996:             ok = JS_TRUE;
12996:             goto forced_return;
12996:           case JSTRAP_THROW:
12996:             cx->throwing = JS_TRUE;
12996:             cx->exception = rval;
12996:             goto error;
12996:           default:;
12996:         }
12996:         LOAD_INTERRUPT_HANDLER(cx);
12996:     }
12996: 
12996:     JS_ASSERT((uintN)op < (uintN)JSOP_LIMIT);
12996:     JS_EXTENSION_(goto *normalJumpTable[op]);
12996: 
12996: #else  /* !JS_THREADED_INTERP */
12996: 
12996:     for (;;) {
13168:         op = (JSOp) *regs.pc;
12996:       do_op:
12996:         len = js_CodeSpec[op].length;
12996: 
12996: #ifdef DEBUG
12996:         tracefp = (FILE *) cx->tracefp;
12996:         if (tracefp) {
12996:             intN nuses, n;
12996: 
13168:             fprintf(tracefp, "%4u: ", js_PCToLineNumber(cx, script, regs.pc));
13168:             js_Disassemble1(cx, script, regs.pc,
13168:                             PTRDIFF(regs.pc, script->code, jsbytecode),
13168:                             JS_FALSE, tracefp);
12996:             nuses = js_CodeSpec[op].nuses;
12996:             if (nuses) {
12996:                 for (n = -nuses; n < 0; n++) {
13168:                     char *bytes = js_DecompileValueGenerator(cx, n, regs.sp[n],
12996:                                                              NULL);
12996:                     if (bytes) {
12996:                         fprintf(tracefp, "%s %s",
12996:                                 (n == -nuses) ? "  inputs:" : ",",
12996:                                 bytes);
12996:                         JS_free(cx, bytes);
12996:                     }
12996:                 }
13168:                 fprintf(tracefp, " @ %d\n", regs.sp - fp->spbase);
12996:             }
12996:         }
12996: #endif /* DEBUG */
12996: 
12996:         if (interruptHandler) {
13168:             switch (interruptHandler(cx, script, regs.pc, &rval,
 2433:                                      cx->debugHooks->interruptHandlerData)) {
    1:               case JSTRAP_ERROR:
11859:                 goto error;
    1:               case JSTRAP_CONTINUE:
    1:                 break;
    1:               case JSTRAP_RETURN:
    1:                 fp->rval = rval;
11859:                 ok = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
    1:                 cx->throwing = JS_TRUE;
    1:                 cx->exception = rval;
11859:                 goto error;
    1:               default:;
    1:             }
 2433:             LOAD_INTERRUPT_HANDLER(cx);
    1:         }
    1: 
    1:         switch (op) {
    1: 
    1: #endif /* !JS_THREADED_INTERP */
    1: 
    1:           EMPTY_CASE(JSOP_NOP)
    1: 
    1:           EMPTY_CASE(JSOP_GROUP)
    1: 
13504:           /* EMPTY_CASE is not used here as JSOP_LINENO_LENGTH == 3. */
13504:           BEGIN_CASE(JSOP_LINENO)
13504:           END_CASE(JSOP_LINENO)
13504: 
    1:           BEGIN_CASE(JSOP_PUSH)
    1:             PUSH_OPND(JSVAL_VOID);
    1:           END_CASE(JSOP_PUSH)
    1: 
    1:           BEGIN_CASE(JSOP_POP)
13168:             regs.sp--;
    1:           END_CASE(JSOP_POP)
    1: 
 1227:           BEGIN_CASE(JSOP_POPN)
13168:             regs.sp -= GET_UINT16(regs.pc);
 1227: #ifdef DEBUG
13168:             JS_ASSERT(fp->spbase <= regs.sp);
 1227:             obj = fp->blockChain;
13168:             JS_ASSERT_IF(obj,
13168:                          OBJ_BLOCK_DEPTH(cx, obj) + OBJ_BLOCK_COUNT(cx, obj)
13168:                          <= (size_t) (regs.sp - fp->spbase));
 1227:             for (obj = fp->scopeChain; obj; obj = OBJ_GET_PARENT(cx, obj)) {
 1227:                 clasp = OBJ_GET_CLASS(cx, obj);
 1227:                 if (clasp != &js_BlockClass && clasp != &js_WithClass)
 1227:                     continue;
10592:                 if (OBJ_GET_PRIVATE(cx, obj) != fp)
 1227:                     break;
 1227:                 JS_ASSERT(fp->spbase + OBJ_BLOCK_DEPTH(cx, obj)
 1227:                                      + ((clasp == &js_BlockClass)
 1227:                                         ? OBJ_BLOCK_COUNT(cx, obj)
 1227:                                         : 1)
13168:                           <= regs.sp);
 1227:             }
 1227: #endif
 1227:           END_CASE(JSOP_POPN)
    1: 
    1:           BEGIN_CASE(JSOP_SWAP)
13168:             rtmp = regs.sp[-1];
13168:             regs.sp[-1] = regs.sp[-2];
13168:             regs.sp[-2] = rtmp;
    1:           END_CASE(JSOP_SWAP)
    1: 
12688:           BEGIN_CASE(JSOP_SETRVAL)
    1:           BEGIN_CASE(JSOP_POPV)
12688:             ASSERT_NOT_THROWING(cx);
12688:             fp->rval = POP_OPND();
    1:           END_CASE(JSOP_POPV)
    1: 
    1:           BEGIN_CASE(JSOP_ENTERWITH)
12551:             if (!js_EnterWith(cx, -1))
11859:                 goto error;
11672: 
11672:             /*
11672:              * We must ensure that different "with" blocks have different
11672:              * stack depth associated with them. This allows the try handler
11672:              * search to properly recover the scope chain. Thus we must keep
11672:              * the stack at least at the current level.
11672:              *
11672:              * We set sp[-1] to the current "with" object to help asserting
11672:              * the enter/leave balance in [leavewith].
11672:              */
13168:             regs.sp[-1] = OBJECT_TO_JSVAL(fp->scopeChain);
    1:           END_CASE(JSOP_ENTERWITH)
    1: 
    1:           BEGIN_CASE(JSOP_LEAVEWITH)
13168:             JS_ASSERT(regs.sp[-1] == OBJECT_TO_JSVAL(fp->scopeChain));
13168:             regs.sp--;
12551:             js_LeaveWith(cx);
    1:           END_CASE(JSOP_LEAVEWITH)
    1: 
    1:           BEGIN_CASE(JSOP_RETURN)
    1:             CHECK_BRANCH(-1);
    1:             fp->rval = POP_OPND();
    1:             /* FALL THROUGH */
    1: 
    1:           BEGIN_CASE(JSOP_RETRVAL)    /* fp->rval already set */
11758:           BEGIN_CASE(JSOP_STOP)
11859:             /*
11859:              * When the inlined frame exits with an exception or an error, ok
11859:              * will be false after the inline_return label.
11859:              */
    1:             ASSERT_NOT_THROWING(cx);
13168:             JS_ASSERT(regs.sp == fp->spbase);
11859:             ok = JS_TRUE;
    1:             if (inlineCallCount)
    1:           inline_return:
    1:             {
    1:                 JSInlineFrame *ifp = (JSInlineFrame *) fp;
    1:                 void *hookData = ifp->hookData;
    1: 
11758:                 JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled == fp->pcDisabledSave);
11758:                 JS_ASSERT(!fp->blockChain);
12551:                 JS_ASSERT(!js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
    1: 
    1:                 if (hookData) {
11859:                     JSInterpreterHook hook;
11859:                     JSBool status;
11859: 
11859:                     hook = cx->debugHooks->callHook;
    1:                     if (hook) {
11859:                         /*
11859:                          * Do not pass &ok directly as exposing the address
11859:                          * inhibits optimizations and uninitialised warnings.
11859:                          */
11859:                         status = ok;
11859:                         hook(cx, fp, JS_FALSE, &status, hookData);
11859:                         ok = status;
 2433:                         LOAD_INTERRUPT_HANDLER(cx);
    1:                     }
    1:                 }
    1: 
    1:                 /*
    1:                  * If fp has a call object, sync values and clear the back-
    1:                  * pointer. This can happen for a lightweight function if it
    1:                  * calls eval unexpectedly (in a way that is hidden from the
    1:                  * compiler). See bug 325540.
    1:                  */
13168:                 if (fp->callobj)
    1:                     ok &= js_PutCallObject(cx, fp);
13168: 
13168:                 if (fp->argsobj)
    1:                     ok &= js_PutArgsObject(cx, fp);
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:                 /* DTrace function return, inlines */
 7058:                 if (JAVASCRIPT_FUNCTION_RVAL_ENABLED())
 7058:                     jsdtrace_function_rval(cx, fp, fp->fun);
 7058:                 if (JAVASCRIPT_FUNCTION_RETURN_ENABLED())
 7058:                     jsdtrace_function_return(cx, fp, fp->fun);
 7058: #endif
 7058: 
    1:                 /* Restore context version only if callee hasn't set version. */
    1:                 if (JS_LIKELY(cx->version == currentVersion)) {
    1:                     currentVersion = ifp->callerVersion;
    1:                     if (currentVersion != cx->version)
    1:                         js_SetVersion(cx, currentVersion);
    1:                 }
    1: 
13168:                 /* Restore caller's registers. */
13168:                 regs = ifp->callerRegs;
13168: 
    1:                 /* Store the return value in the caller's operand frame. */
13168:                 regs.sp -= 1 + (size_t) ifp->frame.argc;
13168:                 regs.sp[-1] = fp->rval;
    1: 
    1:                 /* Restore cx->fp and release the inline frame's space. */
    1:                 cx->fp = fp = fp->down;
13168:                 JS_ASSERT(fp->regs == &ifp->callerRegs);
13168:                 fp->regs = &regs;
    1:                 JS_ARENA_RELEASE(&cx->stackPool, ifp->mark);
    1: 
    1:                 /* Restore the calling script's interpreter registers. */
    1:                 script = fp->script;
    1:                 atoms = script->atomMap.vector;
    1: 
    1:                 /* Resume execution in the calling frame. */
    1:                 inlineCallCount--;
    1:                 if (JS_LIKELY(ok)) {
13168:                     JS_ASSERT(js_CodeSpec[*regs.pc].length == JSOP_CALL_LENGTH);
    1:                     len = JSOP_CALL_LENGTH;
    1:                     DO_NEXT_OP(len);
    1:                 }
11859:                 goto error;
11758:             }
11758:             goto exit;
    1: 
    1:           BEGIN_CASE(JSOP_DEFAULT)
    1:             (void) POP();
    1:             /* FALL THROUGH */
    1:           BEGIN_CASE(JSOP_GOTO)
13168:             len = GET_JUMP_OFFSET(regs.pc);
    1:             CHECK_BRANCH(len);
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_IFEQ)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond == JS_FALSE) {
13168:                 len = GET_JUMP_OFFSET(regs.pc);
    1:                 CHECK_BRANCH(len);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_IFEQ)
    1: 
    1:           BEGIN_CASE(JSOP_IFNE)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond != JS_FALSE) {
13168:                 len = GET_JUMP_OFFSET(regs.pc);
    1:                 CHECK_BRANCH(len);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_IFNE)
    1: 
    1:           BEGIN_CASE(JSOP_OR)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond == JS_TRUE) {
13168:                 len = GET_JUMP_OFFSET(regs.pc);
    1:                 PUSH_OPND(rval);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_OR)
    1: 
    1:           BEGIN_CASE(JSOP_AND)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond == JS_FALSE) {
13168:                 len = GET_JUMP_OFFSET(regs.pc);
    1:                 PUSH_OPND(rval);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_AND)
    1: 
    1:           BEGIN_CASE(JSOP_DEFAULTX)
    1:             (void) POP();
    1:             /* FALL THROUGH */
    1:           BEGIN_CASE(JSOP_GOTOX)
13168:             len = GET_JUMPX_OFFSET(regs.pc);
    1:             CHECK_BRANCH(len);
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_IFEQX)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond == JS_FALSE) {
13168:                 len = GET_JUMPX_OFFSET(regs.pc);
    1:                 CHECK_BRANCH(len);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_IFEQX)
    1: 
    1:           BEGIN_CASE(JSOP_IFNEX)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond != JS_FALSE) {
13168:                 len = GET_JUMPX_OFFSET(regs.pc);
    1:                 CHECK_BRANCH(len);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_IFNEX)
    1: 
    1:           BEGIN_CASE(JSOP_ORX)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond == JS_TRUE) {
13168:                 len = GET_JUMPX_OFFSET(regs.pc);
    1:                 PUSH_OPND(rval);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_ORX)
    1: 
    1:           BEGIN_CASE(JSOP_ANDX)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             if (cond == JS_FALSE) {
13168:                 len = GET_JUMPX_OFFSET(regs.pc);
    1:                 PUSH_OPND(rval);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:           END_CASE(JSOP_ANDX)
    1: 
    1: /*
    1:  * If the index value at sp[n] is not an int that fits in a jsval, it could
    1:  * be an object (an XML QName, AttributeName, or AnyName), but only if we are
    1:  * compiling with JS_HAS_XML_SUPPORT.  Otherwise convert the index value to a
    1:  * string atom id.
    1:  */
    1: #define FETCH_ELEMENT_ID(obj, n, id)                                          \
    1:     JS_BEGIN_MACRO                                                            \
    1:         jsval idval_ = FETCH_OPND(n);                                         \
    1:         if (JSVAL_IS_INT(idval_)) {                                           \
    1:             id = INT_JSVAL_TO_JSID(idval_);                                   \
    1:         } else {                                                              \
12551:             if (!js_InternNonIntElementId(cx, obj, idval_, &id))              \
11859:                 goto error;                                                   \
13168:             regs.sp[n] = ID_TO_VALUE(id);                                     \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1:           BEGIN_CASE(JSOP_IN)
    1:             rval = FETCH_OPND(-1);
    1:             if (JSVAL_IS_PRIMITIVE(rval)) {
    1:                 js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rval, NULL);
11859:                 goto error;
    1:             }
    1:             obj = JSVAL_TO_OBJECT(rval);
    1:             FETCH_ELEMENT_ID(obj, -2, id);
11859:             if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
11859:                 goto error;
13168:             regs.sp--;
    1:             STORE_OPND(-1, BOOLEAN_TO_JSVAL(prop != NULL));
    1:             if (prop)
    1:                 OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:           END_CASE(JSOP_IN)
    1: 
    1:           BEGIN_CASE(JSOP_FOREACH)
    1:             flags = JSITER_ENUMERATE | JSITER_FOREACH;
    1:             goto value_to_iter;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:           BEGIN_CASE(JSOP_FOREACHKEYVAL)
    1:             flags = JSITER_ENUMERATE | JSITER_FOREACH | JSITER_KEYVALUE;
    1:             goto value_to_iter;
    1: #endif
    1: 
    1:           BEGIN_CASE(JSOP_FORIN)
    1:             /*
    1:              * Set JSITER_ENUMERATE to indicate that for-in loop should use
    1:              * the enumeration protocol's iterator for compatibility if an
    1:              * explicit iterator is not given via the optional __iterator__
    1:              * method.
    1:              */
    1:             flags = JSITER_ENUMERATE;
    1: 
    1:           value_to_iter:
13168:             JS_ASSERT(regs.sp > fp->spbase);
13168:             if (!js_ValueToIterator(cx, flags, &regs.sp[-1]))
13014:                 goto error;
13168:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(regs.sp[-1]));
    1:             JS_ASSERT(JSOP_FORIN_LENGTH == js_CodeSpec[op].length);
    1:           END_CASE(JSOP_FORIN)
    1: 
    1:           BEGIN_CASE(JSOP_FORPROP)
    1:             /*
    1:              * Handle JSOP_FORPROP first, so the cost of the goto do_forinloop
    1:              * is not paid for the more common cases.
    1:              */
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
    1:             i = -2;
    1:             goto do_forinloop;
    1: 
    1:           BEGIN_CASE(JSOP_FORNAME)
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
    1:             /* FALL THROUGH */
    1: 
    1:           BEGIN_CASE(JSOP_FORARG)
    1:           BEGIN_CASE(JSOP_FORVAR)
    1:           BEGIN_CASE(JSOP_FORCONST)
    1:           BEGIN_CASE(JSOP_FORLOCAL)
    1:             /*
    1:              * JSOP_FORARG and JSOP_FORVAR don't require any lval computation
    1:              * here, because they address slots on the stack (in fp->args and
    1:              * fp->vars, respectively).  Same applies to JSOP_FORLOCAL, which
    1:              * addresses fp->spbase.
    1:              */
    1:             /* FALL THROUGH */
    1: 
    1:           BEGIN_CASE(JSOP_FORELEM)
    1:             /*
    1:              * JSOP_FORELEM simply initializes or updates the iteration state
    1:              * and leaves the index expression evaluation and assignment to the
    1:              * enumerator until after the next property has been acquired, via
    1:              * a JSOP_ENUMELEM bytecode.
    1:              */
    1:             i = -1;
    1: 
    1:           do_forinloop:
    1:             /*
    1:              * Reach under the top of stack to find our property iterator, a
    1:              * JSObject that contains the iteration state.
    1:              */
13168:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(regs.sp[i]));
13168:             iterobj = JSVAL_TO_OBJECT(regs.sp[i]);
13168: 
11859:             if (!js_CallIteratorNext(cx, iterobj, &rval))
11859:                 goto error;
    1:             if (rval == JSVAL_HOLE) {
    1:                 rval = JSVAL_FALSE;
    1:                 goto end_forinloop;
    1:             }
    1: 
    1:             switch (op) {
    1:               case JSOP_FORARG:
13168:                 slot = GET_ARGNO(regs.pc);
13702:                 JS_ASSERT(slot < fp->fun->nargs);
    1:                 fp->argv[slot] = rval;
    1:                 break;
    1: 
    1:               case JSOP_FORVAR:
13168:                 slot = GET_VARNO(regs.pc);
13702:                 JS_ASSERT(slot < fp->fun->u.i.nvars);
    1:                 fp->vars[slot] = rval;
    1:                 break;
    1: 
    1:               case JSOP_FORCONST:
    1:                 /* Don't update the const slot. */
    1:                 break;
    1: 
    1:               case JSOP_FORLOCAL:
13168:                 slot = GET_UINT16(regs.pc);
12579:                 JS_ASSERT(slot < script->depth);
    1:                 vp = &fp->spbase[slot];
    1:                 GC_POKE(cx, *vp);
    1:                 *vp = rval;
    1:                 break;
    1: 
    1:               case JSOP_FORELEM:
    1:                 /* FORELEM is not a SET operation, it's more like BINDNAME. */
    1:                 PUSH_OPND(rval);
    1:                 break;
    1: 
    1:               case JSOP_FORPROP:
    1:                 /*
    1:                  * We fetch object here to ensure that the iterator is called
    1:                  * even if lval is null or undefined that throws in
    1:                  * FETCH_OBJECT. See bug 372331.
    1:                  */
    1:                 FETCH_OBJECT(cx, -1, lval, obj);
    1:                 goto set_for_property;
    1: 
11859:               default:
11859:                 JS_ASSERT(op == JSOP_FORNAME);
11859: 
    1:                 /*
    1:                  * We find property here after the iterator call to ensure
    1:                  * that we take into account side effects of the iterator
    1:                  * call. See bug 372331.
    1:                  */
    1: 
11859:                 if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
11859:                     goto error;
    1:                 if (prop)
    1:                     OBJ_DROP_PROPERTY(cx, obj2, prop);
    1: 
    1:               set_for_property:
    1:                 /* Set the variable obj[id] to refer to rval. */
    1:                 fp->flags |= JSFRAME_ASSIGNING;
    1:                 ok = OBJ_SET_PROPERTY(cx, obj, id, &rval);
    1:                 fp->flags &= ~JSFRAME_ASSIGNING;
    1:                 if (!ok)
11859:                     goto error;
    1:                 break;
    1:             }
    1: 
    1:             /* Push true to keep looping through properties. */
    1:             rval = JSVAL_TRUE;
    1: 
    1:           end_forinloop:
13168:             regs.sp += i + 1;
    1:             PUSH_OPND(rval);
    1:             len = js_CodeSpec[op].length;
    1:             DO_NEXT_OP(len);
    1: 
    1:           BEGIN_CASE(JSOP_DUP)
13168:             JS_ASSERT(regs.sp > fp->spbase);
12579:             rval = FETCH_OPND(-1);
    1:             PUSH(rval);
    1:           END_CASE(JSOP_DUP)
    1: 
    1:           BEGIN_CASE(JSOP_DUP2)
13168:             JS_ASSERT(regs.sp - 2 >= fp->spbase);
12579:             lval = FETCH_OPND(-2);
12579:             rval = FETCH_OPND(-1);
    1:             PUSH(lval);
    1:             PUSH(rval);
    1:           END_CASE(JSOP_DUP2)
    1: 
    1: #define PROPERTY_OP(n, call)                                                  \
    1:     JS_BEGIN_MACRO                                                            \
    1:         /* Fetch the left part and resolve it to a non-null object. */        \
    1:         FETCH_OBJECT(cx, n, lval, obj);                                       \
    1:                                                                               \
11859:         /* Get or set the property. */                                        \
11859:         if (!call)                                                            \
11859:             goto error;                                                       \
    1:     JS_END_MACRO
    1: 
    1: #define ELEMENT_OP(n, call)                                                   \
    1:     JS_BEGIN_MACRO                                                            \
    1:         /* Fetch the left part and resolve it to a non-null object. */        \
    1:         FETCH_OBJECT(cx, n - 1, lval, obj);                                   \
    1:                                                                               \
    1:         /* Fetch index and convert it to id suitable for use with obj. */     \
    1:         FETCH_ELEMENT_ID(obj, n, id);                                         \
    1:                                                                               \
11859:         /* Get or set the element. */                                         \
11859:         if (!call)                                                            \
11859:             goto error;                                                       \
    1:     JS_END_MACRO
    1: 
    1: #define NATIVE_GET(cx,obj,pobj,sprop,vp)                                      \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if (SPROP_HAS_STUB_GETTER(sprop)) {                                   \
    1:             /* Fast path for Object instance properties. */                   \
    1:             JS_ASSERT((sprop)->slot != SPROP_INVALID_SLOT ||                  \
    1:                       !SPROP_HAS_STUB_SETTER(sprop));                         \
    1:             *vp = ((sprop)->slot != SPROP_INVALID_SLOT)                       \
    1:                   ? LOCKED_OBJ_GET_SLOT(pobj, (sprop)->slot)                  \
    1:                   : JSVAL_VOID;                                               \
    1:         } else {                                                              \
11859:             if (!js_NativeGet(cx, obj, pobj, sprop, vp))                      \
11859:                 goto error;                                                   \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
11377: #define NATIVE_SET(cx,obj,sprop,vp)                                           \
11377:     JS_BEGIN_MACRO                                                            \
11377:         if (SPROP_HAS_STUB_SETTER(sprop) &&                                   \
11377:             (sprop)->slot != SPROP_INVALID_SLOT) {                            \
11377:             /* Fast path for, e.g., Object instance properties. */            \
11377:             LOCKED_OBJ_WRITE_BARRIER(cx, obj, (sprop)->slot, *vp);            \
11377:         } else {                                                              \
11859:             if (!js_NativeSet(cx, obj, sprop, vp))                            \
11859:                 goto error;                                                   \
11377:         }                                                                     \
11377:     JS_END_MACRO
11377: 
12036: /*
12036:  * Deadlocks or else bad races are likely if JS_THREADSAFE, so we must rely on
12036:  * single-thread DEBUG js shell testing to verify property cache hits.
12036:  */
12036: #if defined DEBUG && !defined JS_THREADSAFE
11377: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry)                \
11377:     do {                                                                      \
11377:         JSAtom *atom_;                                                        \
11377:         JSObject *obj_, *pobj_;                                               \
11377:         JSProperty *prop_;                                                    \
11377:         JSScopeProperty *sprop_;                                              \
11613:         uint32 sample_ = rt->gcNumber;                                        \
11377:         if (pcoff >= 0)                                                       \
13168:             GET_ATOM_FROM_BYTECODE(script, regs.pc, pcoff, atom_);            \
11377:         else                                                                  \
11377:             atom_ = rt->atomState.lengthAtom;                                 \
13168:         if (JOF_OPMODE(*regs.pc) == JOF_NAME) {                               \
11377:             ok = js_FindProperty(cx, ATOM_TO_JSID(atom_), &obj_, &pobj_,      \
11377:                                  &prop_);                                     \
11377:         } else {                                                              \
11377:             obj_ = obj;                                                       \
11377:             ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(atom_), &pobj_,      \
11377:                                    &prop_);                                   \
11377:         }                                                                     \
11377:         if (!ok)                                                              \
11859:             goto error;                                                       \
11613:         if (rt->gcNumber != sample_)                                          \
11613:             break;                                                            \
11377:         JS_ASSERT(prop_);                                                     \
11377:         JS_ASSERT(pobj_ == pobj);                                             \
11377:         sprop_ = (JSScopeProperty *) prop_;                                   \
11377:         if (PCVAL_IS_SLOT(entry->vword)) {                                    \
11377:             JS_ASSERT(PCVAL_TO_SLOT(entry->vword) == sprop_->slot);           \
11377:         } else if (PCVAL_IS_SPROP(entry->vword)) {                            \
11377:             JS_ASSERT(PCVAL_TO_SPROP(entry->vword) == sprop_);                \
11377:         } else {                                                              \
11377:             jsval v_;                                                         \
11377:             JS_ASSERT(PCVAL_IS_OBJECT(entry->vword));                         \
11377:             JS_ASSERT(entry->vword != PCVAL_NULL);                            \
11377:             JS_ASSERT(SCOPE_IS_BRANDED(OBJ_SCOPE(pobj)));                     \
11377:             JS_ASSERT(SPROP_HAS_STUB_GETTER(sprop_));                         \
11377:             JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop_, OBJ_SCOPE(pobj_)));        \
11377:             v_ = LOCKED_OBJ_GET_SLOT(pobj_, sprop_->slot);                    \
11377:             JS_ASSERT(VALUE_IS_FUNCTION(cx, v_));                             \
11377:             JS_ASSERT(PCVAL_TO_OBJECT(entry->vword) == JSVAL_TO_OBJECT(v_));  \
11377:         }                                                                     \
11377:         OBJ_DROP_PROPERTY(cx, pobj_, prop_);                                  \
11377:     } while (0)
11377: #else
12036: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry) ((void) 0)
11377: #endif
11377: 
    1:           BEGIN_CASE(JSOP_SETCONST)
    1:             LOAD_ATOM(0);
    1:             obj = fp->varobj;
    1:             rval = FETCH_OPND(-1);
11859:             if (!OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), rval,
11819:                                      JS_PropertyStub, JS_PropertyStub,
    1:                                      JSPROP_ENUMERATE | JSPROP_PERMANENT |
    1:                                      JSPROP_READONLY,
11859:                                      NULL)) {
11859:                 goto error;
11859:             }
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_SETCONST)
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:           BEGIN_CASE(JSOP_ENUMCONSTELEM)
    1:             rval = FETCH_OPND(-3);
    1:             FETCH_OBJECT(cx, -2, lval, obj);
    1:             FETCH_ELEMENT_ID(obj, -1, id);
11859:             if (!OBJ_DEFINE_PROPERTY(cx, obj, id, rval,
11819:                                      JS_PropertyStub, JS_PropertyStub,
    1:                                      JSPROP_ENUMERATE | JSPROP_PERMANENT |
    1:                                      JSPROP_READONLY,
11859:                                      NULL)) {
11859:                 goto error;
11859:             }
13168:             regs.sp -= 3;
    1:           END_CASE(JSOP_ENUMCONSTELEM)
    1: #endif
    1: 
    1:           BEGIN_CASE(JSOP_BINDNAME)
11832:             do {
11377:                 JSPropCacheEntry *entry;
11377: 
11377:                 obj = fp->scopeChain;
11832:                 if (JS_LIKELY(OBJ_IS_NATIVE(obj))) {
13168:                     PROPERTY_CACHE_TEST(cx, regs.pc, obj, obj2, entry, atom);
11377:                     if (!atom) {
11377:                         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
11377:                         JS_UNLOCK_OBJ(cx, obj2);
11832:                         break;
11832:                     }
11377:                 } else {
11832:                     entry = NULL;
11832:                     LOAD_ATOM(0);
11832:                 }
    1:                 id = ATOM_TO_JSID(atom);
11377:                 obj = js_FindIdentifierBase(cx, id, entry);
11859:                 if (!obj)
11859:                     goto error;
11832:             } while (0);
    1:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_BINDNAME)
    1: 
12681: #define BITWISE_OP(OP)                                                        \
    1:     JS_BEGIN_MACRO                                                            \
 6157:         FETCH_INT(cx, -2, i);                                                 \
    1:         FETCH_INT(cx, -1, j);                                                 \
    1:         i = i OP j;                                                           \
13168:         regs.sp--;                                                            \
    1:         STORE_INT(cx, -1, i);                                                 \
    1:     JS_END_MACRO
    1: 
    1:           BEGIN_CASE(JSOP_BITOR)
    1:             BITWISE_OP(|);
    1:           END_CASE(JSOP_BITOR)
    1: 
    1:           BEGIN_CASE(JSOP_BITXOR)
    1:             BITWISE_OP(^);
    1:           END_CASE(JSOP_BITXOR)
    1: 
    1:           BEGIN_CASE(JSOP_BITAND)
    1:             BITWISE_OP(&);
    1:           END_CASE(JSOP_BITAND)
    1: 
    1: #define RELATIONAL_OP(OP)                                                     \
    1:     JS_BEGIN_MACRO                                                            \
    1:         rval = FETCH_OPND(-1);                                                \
    1:         lval = FETCH_OPND(-2);                                                \
    1:         /* Optimize for two int-tagged operands (typical loop control). */    \
    1:         if ((lval & rval) & JSVAL_INT) {                                      \
    1:             ltmp = lval ^ JSVAL_VOID;                                         \
    1:             rtmp = rval ^ JSVAL_VOID;                                         \
    1:             if (ltmp && rtmp) {                                               \
    1:                 cond = JSVAL_TO_INT(lval) OP JSVAL_TO_INT(rval);              \
    1:             } else {                                                          \
    1:                 d  = ltmp ? JSVAL_TO_INT(lval) : *rt->jsNaN;                  \
    1:                 d2 = rtmp ? JSVAL_TO_INT(rval) : *rt->jsNaN;                  \
    1:                 cond = JSDOUBLE_COMPARE(d, OP, d2, JS_FALSE);                 \
    1:             }                                                                 \
    1:         } else {                                                              \
    1:             if (!JSVAL_IS_PRIMITIVE(lval))                                    \
    1:                 DEFAULT_VALUE(cx, -2, JSTYPE_NUMBER, lval);                   \
    1:             if (!JSVAL_IS_PRIMITIVE(rval))                                    \
    1:                 DEFAULT_VALUE(cx, -1, JSTYPE_NUMBER, rval);                   \
    1:             if (JSVAL_IS_STRING(lval) && JSVAL_IS_STRING(rval)) {             \
    1:                 str  = JSVAL_TO_STRING(lval);                                 \
    1:                 str2 = JSVAL_TO_STRING(rval);                                 \
    1:                 cond = js_CompareStrings(str, str2) OP 0;                     \
    1:             } else {                                                          \
12694:                 VALUE_TO_NUMBER(cx, -2, lval, d);                             \
12694:                 VALUE_TO_NUMBER(cx, -1, rval, d2);                            \
    1:                 cond = JSDOUBLE_COMPARE(d, OP, d2, JS_FALSE);                 \
    1:             }                                                                 \
    1:         }                                                                     \
13168:         regs.sp--;                                                            \
    1:         STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));                               \
    1:     JS_END_MACRO
    1: 
    1: /*
    1:  * NB: These macros can't use JS_BEGIN_MACRO/JS_END_MACRO around their bodies
    1:  * because they begin if/else chains, so callers must not put semicolons after
    1:  * the call expressions!
    1:  */
    1: #if JS_HAS_XML_SUPPORT
    1: #define XML_EQUALITY_OP(OP)                                                   \
    1:     if ((ltmp == JSVAL_OBJECT &&                                              \
    1:          (obj2 = JSVAL_TO_OBJECT(lval)) &&                                    \
    1:          OBJECT_IS_XML(cx, obj2)) ||                                          \
    1:         (rtmp == JSVAL_OBJECT &&                                              \
    1:          (obj2 = JSVAL_TO_OBJECT(rval)) &&                                    \
    1:          OBJECT_IS_XML(cx, obj2))) {                                          \
    1:         JSXMLObjectOps *ops;                                                  \
    1:                                                                               \
    1:         ops = (JSXMLObjectOps *) obj2->map->ops;                              \
    1:         if (obj2 == JSVAL_TO_OBJECT(rval))                                    \
    1:             rval = lval;                                                      \
11859:         if (!ops->equality(cx, obj2, rval, &cond))                            \
11859:             goto error;                                                       \
    1:         cond = cond OP JS_TRUE;                                               \
    1:     } else
    1: 
    1: #define EXTENDED_EQUALITY_OP(OP)                                              \
    1:     if (ltmp == JSVAL_OBJECT &&                                               \
    1:         (obj2 = JSVAL_TO_OBJECT(lval)) &&                                     \
    1:         ((clasp = OBJ_GET_CLASS(cx, obj2))->flags & JSCLASS_IS_EXTENDED)) {   \
    1:         JSExtendedClass *xclasp;                                              \
    1:                                                                               \
    1:         xclasp = (JSExtendedClass *) clasp;                                   \
11859:         if (!xclasp->equality(cx, obj2, rval, &cond))                         \
11859:             goto error;                                                       \
    1:         cond = cond OP JS_TRUE;                                               \
    1:     } else
    1: #else
    1: #define XML_EQUALITY_OP(OP)             /* nothing */
    1: #define EXTENDED_EQUALITY_OP(OP)        /* nothing */
    1: #endif
    1: 
    1: #define EQUALITY_OP(OP, IFNAN)                                                \
    1:     JS_BEGIN_MACRO                                                            \
    1:         rval = FETCH_OPND(-1);                                                \
    1:         lval = FETCH_OPND(-2);                                                \
    1:         ltmp = JSVAL_TAG(lval);                                               \
    1:         rtmp = JSVAL_TAG(rval);                                               \
    1:         XML_EQUALITY_OP(OP)                                                   \
    1:         if (ltmp == rtmp) {                                                   \
    1:             if (ltmp == JSVAL_STRING) {                                       \
    1:                 str  = JSVAL_TO_STRING(lval);                                 \
    1:                 str2 = JSVAL_TO_STRING(rval);                                 \
    1:                 cond = js_EqualStrings(str, str2) OP JS_TRUE;                 \
    1:             } else if (ltmp == JSVAL_DOUBLE) {                                \
    1:                 d  = *JSVAL_TO_DOUBLE(lval);                                  \
    1:                 d2 = *JSVAL_TO_DOUBLE(rval);                                  \
    1:                 cond = JSDOUBLE_COMPARE(d, OP, d2, IFNAN);                    \
    1:             } else {                                                          \
    1:                 EXTENDED_EQUALITY_OP(OP)                                      \
    1:                 /* Handle all undefined (=>NaN) and int combinations. */      \
    1:                 cond = lval OP rval;                                          \
    1:             }                                                                 \
    1:         } else {                                                              \
    1:             if (JSVAL_IS_NULL(lval) || JSVAL_IS_VOID(lval)) {                 \
    1:                 cond = (JSVAL_IS_NULL(rval) || JSVAL_IS_VOID(rval)) OP 1;     \
    1:             } else if (JSVAL_IS_NULL(rval) || JSVAL_IS_VOID(rval)) {          \
    1:                 cond = 1 OP 0;                                                \
    1:             } else {                                                          \
    1:                 if (ltmp == JSVAL_OBJECT) {                                   \
    1:                     DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);                 \
    1:                     ltmp = JSVAL_TAG(lval);                                   \
    1:                 } else if (rtmp == JSVAL_OBJECT) {                            \
    1:                     DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);                 \
    1:                     rtmp = JSVAL_TAG(rval);                                   \
    1:                 }                                                             \
    1:                 if (ltmp == JSVAL_STRING && rtmp == JSVAL_STRING) {           \
    1:                     str  = JSVAL_TO_STRING(lval);                             \
    1:                     str2 = JSVAL_TO_STRING(rval);                             \
    1:                     cond = js_EqualStrings(str, str2) OP JS_TRUE;             \
    1:                 } else {                                                      \
12694:                     VALUE_TO_NUMBER(cx, -2, lval, d);                         \
12694:                     VALUE_TO_NUMBER(cx, -1, rval, d2);                        \
    1:                     cond = JSDOUBLE_COMPARE(d, OP, d2, IFNAN);                \
    1:                 }                                                             \
    1:             }                                                                 \
    1:         }                                                                     \
13168:         regs.sp--;                                                            \
    1:         STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));                               \
    1:     JS_END_MACRO
    1: 
    1:           BEGIN_CASE(JSOP_EQ)
    1:             EQUALITY_OP(==, JS_FALSE);
    1:           END_CASE(JSOP_EQ)
    1: 
    1:           BEGIN_CASE(JSOP_NE)
    1:             EQUALITY_OP(!=, JS_TRUE);
    1:           END_CASE(JSOP_NE)
    1: 
    1: #define STRICT_EQUALITY_OP(OP)                                                \
    1:     JS_BEGIN_MACRO                                                            \
    1:         rval = FETCH_OPND(-1);                                                \
    1:         lval = FETCH_OPND(-2);                                                \
 9560:         cond = js_StrictlyEqual(cx, lval, rval) OP JS_TRUE;                   \
13168:         regs.sp--;                                                            \
    1:         STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));                               \
    1:     JS_END_MACRO
    1: 
    1:           BEGIN_CASE(JSOP_STRICTEQ)
    1:             STRICT_EQUALITY_OP(==);
    1:           END_CASE(JSOP_STRICTEQ)
    1: 
    1:           BEGIN_CASE(JSOP_STRICTNE)
    1:             STRICT_EQUALITY_OP(!=);
    1:           END_CASE(JSOP_STRICTNE)
    1: 
    1:           BEGIN_CASE(JSOP_CASE)
    1:             STRICT_EQUALITY_OP(==);
    1:             (void) POP();
    1:             if (cond) {
13168:                 len = GET_JUMP_OFFSET(regs.pc);
    1:                 CHECK_BRANCH(len);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:             PUSH(lval);
    1:           END_CASE(JSOP_CASE)
    1: 
    1:           BEGIN_CASE(JSOP_CASEX)
    1:             STRICT_EQUALITY_OP(==);
    1:             (void) POP();
    1:             if (cond) {
13168:                 len = GET_JUMPX_OFFSET(regs.pc);
    1:                 CHECK_BRANCH(len);
    1:                 DO_NEXT_OP(len);
    1:             }
    1:             PUSH(lval);
    1:           END_CASE(JSOP_CASEX)
    1: 
    1:           BEGIN_CASE(JSOP_LT)
    1:             RELATIONAL_OP(<);
    1:           END_CASE(JSOP_LT)
    1: 
    1:           BEGIN_CASE(JSOP_LE)
    1:             RELATIONAL_OP(<=);
    1:           END_CASE(JSOP_LE)
    1: 
    1:           BEGIN_CASE(JSOP_GT)
    1:             RELATIONAL_OP(>);
    1:           END_CASE(JSOP_GT)
    1: 
    1:           BEGIN_CASE(JSOP_GE)
    1:             RELATIONAL_OP(>=);
    1:           END_CASE(JSOP_GE)
    1: 
    1: #undef EQUALITY_OP
    1: #undef RELATIONAL_OP
    1: 
12681: /*
12681:  * We do not check for JSVAL_VOID here since ToInt32(undefined) == 0
12681:  * and (JSVAL_TO_INT(JSVAL_VOID) & 31) == 0. The static assert before
12681:  * js_Interpret ensures this.
12681:  */
12681: #define FETCH_SHIFT(shift)                                                    \
12681:     JS_BEGIN_MACRO                                                            \
12681:         jsval v_;                                                             \
12681:                                                                               \
12681:         v_ = FETCH_OPND(-1);                                                  \
12681:         if (v_ & JSVAL_INT) {                                                 \
12681:             shift = JSVAL_TO_INT(v_);                                         \
12681:         } else {                                                              \
13168:             shift = js_ValueToECMAInt32(cx, &regs.sp[-1]);                    \
13168:             if (JSVAL_IS_NULL(regs.sp[-1]))                                   \
12681:                 goto error;                                                   \
12681:         }                                                                     \
12681:         shift &= 31;                                                          \
12681:     JS_END_MACRO
12681: 
12681: #define SIGNED_SHIFT_OP(OP)                                                   \
12681:     JS_BEGIN_MACRO                                                            \
12681:         FETCH_INT(cx, -2, i);                                                 \
12681:         FETCH_SHIFT(j);                                                       \
12681:         i = i OP j;                                                           \
13168:         regs.sp--;                                                            \
12681:         STORE_INT(cx, -1, i);                                                 \
12681:     JS_END_MACRO
12681: 
    1:           BEGIN_CASE(JSOP_LSH)
    1:             SIGNED_SHIFT_OP(<<);
    1:           END_CASE(JSOP_LSH)
    1: 
    1:           BEGIN_CASE(JSOP_RSH)
    1:             SIGNED_SHIFT_OP(>>);
    1:           END_CASE(JSOP_RSH)
    1: 
    1:           BEGIN_CASE(JSOP_URSH)
    1:           {
    1:             uint32 u;
    1: 
 6157:             FETCH_UINT(cx, -2, u);
12681:             FETCH_SHIFT(j);
12681:             u >>= j;
13168:             regs.sp--;
    1:             STORE_UINT(cx, -1, u);
    1:           }
    1:           END_CASE(JSOP_URSH)
    1: 
    1: #undef BITWISE_OP
    1: #undef SIGNED_SHIFT_OP
    1: 
    1:           BEGIN_CASE(JSOP_ADD)
    1:             rval = FETCH_OPND(-1);
    1:             lval = FETCH_OPND(-2);
    1: #if JS_HAS_XML_SUPPORT
    1:             if (!JSVAL_IS_PRIMITIVE(lval) &&
    1:                 (obj2 = JSVAL_TO_OBJECT(lval), OBJECT_IS_XML(cx, obj2)) &&
    1:                 VALUE_IS_XML(cx, rval)) {
    1:                 JSXMLObjectOps *ops;
    1: 
    1:                 ops = (JSXMLObjectOps *) obj2->map->ops;
11859:                 if (!ops->concatenate(cx, obj2, rval, &rval))
11859:                     goto error;
13168:                 regs.sp--;
    1:                 STORE_OPND(-1, rval);
    1:             } else
    1: #endif
    1:             {
    1:                 if (!JSVAL_IS_PRIMITIVE(lval))
    1:                     DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);
    1:                 if (!JSVAL_IS_PRIMITIVE(rval))
    1:                     DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);
    1:                 if ((cond = JSVAL_IS_STRING(lval)) || JSVAL_IS_STRING(rval)) {
    1:                     if (cond) {
    1:                         str = JSVAL_TO_STRING(lval);
11859:                         str2 = js_ValueToString(cx, rval);
11859:                         if (!str2)
11859:                             goto error;
13168:                         regs.sp[-1] = STRING_TO_JSVAL(str2);
    1:                     } else {
    1:                         str2 = JSVAL_TO_STRING(rval);
11859:                         str = js_ValueToString(cx, lval);
11859:                         if (!str)
11859:                             goto error;
13168:                         regs.sp[-2] = STRING_TO_JSVAL(str);
    1:                     }
    1:                     str = js_ConcatStrings(cx, str, str2);
11859:                     if (!str)
11859:                         goto error;
13168:                     regs.sp--;
    1:                     STORE_OPND(-1, STRING_TO_JSVAL(str));
    1:                 } else {
12694:                     VALUE_TO_NUMBER(cx, -2, lval, d);
12694:                     VALUE_TO_NUMBER(cx, -1, rval, d2);
    1:                     d += d2;
13168:                     regs.sp--;
    1:                     STORE_NUMBER(cx, -1, d);
    1:                 }
    1:             }
    1:           END_CASE(JSOP_ADD)
    1: 
    1: #define BINARY_OP(OP)                                                         \
    1:     JS_BEGIN_MACRO                                                            \
    1:         FETCH_NUMBER(cx, -1, d2);                                             \
    1:         FETCH_NUMBER(cx, -2, d);                                              \
    1:         d = d OP d2;                                                          \
13168:         regs.sp--;                                                                 \
    1:         STORE_NUMBER(cx, -1, d);                                              \
    1:     JS_END_MACRO
    1: 
    1:           BEGIN_CASE(JSOP_SUB)
    1:             BINARY_OP(-);
    1:           END_CASE(JSOP_SUB)
    1: 
    1:           BEGIN_CASE(JSOP_MUL)
    1:             BINARY_OP(*);
    1:           END_CASE(JSOP_MUL)
    1: 
    1:           BEGIN_CASE(JSOP_DIV)
    1:             FETCH_NUMBER(cx, -1, d2);
    1:             FETCH_NUMBER(cx, -2, d);
13168:             regs.sp--;
    1:             if (d2 == 0) {
    1: #ifdef XP_WIN
    1:                 /* XXX MSVC miscompiles such that (NaN == 0) */
    1:                 if (JSDOUBLE_IS_NaN(d2))
    1:                     rval = DOUBLE_TO_JSVAL(rt->jsNaN);
    1:                 else
    1: #endif
    1:                 if (d == 0 || JSDOUBLE_IS_NaN(d))
    1:                     rval = DOUBLE_TO_JSVAL(rt->jsNaN);
    1:                 else if ((JSDOUBLE_HI32(d) ^ JSDOUBLE_HI32(d2)) >> 31)
    1:                     rval = DOUBLE_TO_JSVAL(rt->jsNegativeInfinity);
    1:                 else
    1:                     rval = DOUBLE_TO_JSVAL(rt->jsPositiveInfinity);
    1:                 STORE_OPND(-1, rval);
    1:             } else {
    1:                 d /= d2;
    1:                 STORE_NUMBER(cx, -1, d);
    1:             }
    1:           END_CASE(JSOP_DIV)
    1: 
    1:           BEGIN_CASE(JSOP_MOD)
    1:             FETCH_NUMBER(cx, -1, d2);
    1:             FETCH_NUMBER(cx, -2, d);
13168:             regs.sp--;
    1:             if (d2 == 0) {
    1:                 STORE_OPND(-1, DOUBLE_TO_JSVAL(rt->jsNaN));
    1:             } else {
    1: #ifdef XP_WIN
    1:               /* Workaround MS fmod bug where 42 % (1/0) => NaN, not 42. */
    1:               if (!(JSDOUBLE_IS_FINITE(d) && JSDOUBLE_IS_INFINITE(d2)))
    1: #endif
    1:                 d = fmod(d, d2);
    1:                 STORE_NUMBER(cx, -1, d);
    1:             }
    1:           END_CASE(JSOP_MOD)
    1: 
    1:           BEGIN_CASE(JSOP_NOT)
    1:             POP_BOOLEAN(cx, rval, cond);
    1:             PUSH_OPND(BOOLEAN_TO_JSVAL(!cond));
    1:           END_CASE(JSOP_NOT)
    1: 
    1:           BEGIN_CASE(JSOP_BITNOT)
    1:             FETCH_INT(cx, -1, i);
    1:             i = ~i;
    1:             STORE_INT(cx, -1, i);
    1:           END_CASE(JSOP_BITNOT)
    1: 
    1:           BEGIN_CASE(JSOP_NEG)
    1:             /*
    1:              * Optimize the case of an int-tagged operand by noting that
    1:              * INT_FITS_IN_JSVAL(i) => INT_FITS_IN_JSVAL(-i) unless i is 0
    1:              * when -i is the negative zero which is jsdouble.
    1:              */
    1:             rval = FETCH_OPND(-1);
    1:             if (JSVAL_IS_INT(rval) && (i = JSVAL_TO_INT(rval)) != 0) {
    1:                 i = -i;
    1:                 JS_ASSERT(INT_FITS_IN_JSVAL(i));
13168:                 regs.sp[-1] = INT_TO_JSVAL(i);
    1:             } else {
12694:                 if (JSVAL_IS_DOUBLE(rval)) {
    1:                     d = *JSVAL_TO_DOUBLE(rval);
12694:                 } else {
13168:                     d = js_ValueToNumber(cx, &regs.sp[-1]);
13168:                     if (JSVAL_IS_NULL(regs.sp[-1]))
13014:                         goto error;
13168:                     JS_ASSERT(JSVAL_IS_NUMBER(regs.sp[-1]) ||
13168:                               regs.sp[-1] == JSVAL_TRUE);
12694:                 }
    1: #ifdef HPUX
    1:                 /*
    1:                  * Negation of a zero doesn't produce a negative
    1:                  * zero on HPUX. Perform the operation by bit
    1:                  * twiddling.
    1:                  */
    1:                 JSDOUBLE_HI32(d) ^= JSDOUBLE_HI32_SIGNBIT;
    1: #else
    1:                 d = -d;
    1: #endif
13168:                 if (!js_NewNumberInRootedValue(cx, d, &regs.sp[-1]))
12694:                     goto error;
12694:             }
    1:           END_CASE(JSOP_NEG)
    1: 
    1:           BEGIN_CASE(JSOP_POS)
    1:             rval = FETCH_OPND(-1);
    1:             if (!JSVAL_IS_NUMBER(rval)) {
13168:                 d = js_ValueToNumber(cx, &regs.sp[-1]);
13168:                 rval = regs.sp[-1];
12850:                 if (JSVAL_IS_NULL(rval))
12850:                     goto error;
12850:                 if (rval == JSVAL_TRUE) {
13168:                     if (!js_NewNumberInRootedValue(cx, d, &regs.sp[-1]))
12850:                         goto error;
12850:                 } else {
12850:                     JS_ASSERT(JSVAL_IS_NUMBER(rval));
12850:                 }
    1:             }
    1:           END_CASE(JSOP_POS)
    1: 
    1:           BEGIN_CASE(JSOP_NEW)
    1:             /* Get immediate argc and find the constructor function. */
13168:             argc = GET_ARGC(regs.pc);
13168:             vp = regs.sp - (2 + argc);
    1:             JS_ASSERT(vp >= fp->spbase);
    1: 
14789:             if (!js_InvokeConstructor(cx, argc, vp))
11859:                 goto error;
13168:             regs.sp = vp + 1;
 2433:             LOAD_INTERRUPT_HANDLER(cx);
 8836:           END_CASE(JSOP_NEW)
    1: 
    1:           BEGIN_CASE(JSOP_DELNAME)
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
11859:             if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
11859:                 goto error;
    1: 
    1:             /* ECMA says to return true if name is undefined or inherited. */
13168:             PUSH_OPND(JSVAL_TRUE);
    1:             if (prop) {
    1:                 OBJ_DROP_PROPERTY(cx, obj2, prop);
13168:                 if (!OBJ_DELETE_PROPERTY(cx, obj, id, &regs.sp[-1]))
13014:                     goto error;
13014:             }
    1:           END_CASE(JSOP_DELNAME)
    1: 
    1:           BEGIN_CASE(JSOP_DELPROP)
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
11859:             PROPERTY_OP(-1, OBJ_DELETE_PROPERTY(cx, obj, id, &rval));
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_DELPROP)
    1: 
    1:           BEGIN_CASE(JSOP_DELELEM)
11859:             ELEMENT_OP(-1, OBJ_DELETE_PROPERTY(cx, obj, id, &rval));
13168:             regs.sp--;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_DELELEM)
    1: 
    1:           BEGIN_CASE(JSOP_TYPEOFEXPR)
    1:           BEGIN_CASE(JSOP_TYPEOF)
    1:             rval = FETCH_OPND(-1);
    1:             type = JS_TypeOfValue(cx, rval);
    1:             atom = rt->atomState.typeAtoms[type];
    1:             STORE_OPND(-1, ATOM_KEY(atom));
    1:           END_CASE(JSOP_TYPEOF)
    1: 
    1:           BEGIN_CASE(JSOP_VOID)
12579:             STORE_OPND(-1, JSVAL_VOID);
    1:           END_CASE(JSOP_VOID)
    1: 
    1:           BEGIN_CASE(JSOP_INCELEM)
    1:           BEGIN_CASE(JSOP_DECELEM)
    1:           BEGIN_CASE(JSOP_ELEMINC)
    1:           BEGIN_CASE(JSOP_ELEMDEC)
    1:             /*
    1:              * Delay fetching of id until we have the object to ensure
 8633:              * the proper evaluation order. See bug 372331.
    1:              */
    1:             id = 0;
    1:             i = -2;
    1:             goto fetch_incop_obj;
    1: 
    1:           BEGIN_CASE(JSOP_INCPROP)
    1:           BEGIN_CASE(JSOP_DECPROP)
    1:           BEGIN_CASE(JSOP_PROPINC)
    1:           BEGIN_CASE(JSOP_PROPDEC)
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
    1:             i = -1;
    1: 
    1:           fetch_incop_obj:
    1:             FETCH_OBJECT(cx, i, lval, obj);
    1:             if (id == 0)
    1:                 FETCH_ELEMENT_ID(obj, -1, id);
    1:             goto do_incop;
    1: 
    1:           BEGIN_CASE(JSOP_INCNAME)
    1:           BEGIN_CASE(JSOP_DECNAME)
    1:           BEGIN_CASE(JSOP_NAMEINC)
    1:           BEGIN_CASE(JSOP_NAMEDEC)
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
11859:             if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
11859:                 goto error;
    1:             if (!prop)
    1:                 goto atom_not_defined;
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1: 
    1:           do_incop:
    1:           {
    1:             const JSCodeSpec *cs;
12611:             jsval v;
12611: 
12611:             /*
12611:              * We need a root to store the value to leave on the stack until
12611:              * we have done with OBJ_SET_PROPERTY.
12611:              */
12611:             PUSH_OPND(JSVAL_NULL);
13168:             if (!OBJ_GET_PROPERTY(cx, obj, id, &regs.sp[-1]))
12611:                 goto error;
12611: 
    1:             cs = &js_CodeSpec[op];
12611:             JS_ASSERT(cs->ndefs == 1);
12611:             JS_ASSERT((cs->format & JOF_TMPSLOT_MASK) == JOF_TMPSLOT2);
13168:             v = regs.sp[-1];
12611:             if (JS_LIKELY(CAN_DO_FAST_INC_DEC(v))) {
12611:                 jsval incr;
12611: 
12611:                 incr = (cs->format & JOF_INC) ? 2 : -2;
    1:                 if (cs->format & JOF_POST) {
13168:                     regs.sp[-1] = v + incr;
    1:                 } else {
12611:                     v += incr;
13168:                     regs.sp[-1] = v;
12611:                 }
    1:                 fp->flags |= JSFRAME_ASSIGNING;
13168:                 ok = OBJ_SET_PROPERTY(cx, obj, id, &regs.sp[-1]);
    1:                 fp->flags &= ~JSFRAME_ASSIGNING;
    1:                 if (!ok)
11859:                     goto error;
12611: 
12611:                 /*
13168:                  * We must set regs.sp[-1] to v for both post and pre increments
13168:                  * as the setter overwrites regs.sp[-1].
13014:                  */
13168:                 regs.sp[-1] = v;
12611:             } else {
12611:                 /* We need an extra root for the result. */
12611:                 PUSH_OPND(JSVAL_NULL);
13168:                 if (!js_DoIncDec(cx, cs, &regs.sp[-2], &regs.sp[-1]))
12611:                     goto error;
12611:                 fp->flags |= JSFRAME_ASSIGNING;
13168:                 ok = OBJ_SET_PROPERTY(cx, obj, id, &regs.sp[-1]);
12611:                 fp->flags &= ~JSFRAME_ASSIGNING;
12611:                 if (!ok)
12611:                     goto error;
13168:                 regs.sp--;
12611:             }
12611: 
12611:             if (cs->nuses == 0) {
13168:                 /* regs.sp[-1] already contains the result of name increment. */
12611:             } else {
13168:                 rtmp = regs.sp[-1];
13168:                 regs.sp -= cs->nuses;
13168:                 regs.sp[-1] = rtmp;
12611:             }
    1:             len = cs->length;
    1:             DO_NEXT_OP(len);
    1:           }
    1: 
12611:           {
12611:             jsval incr, incr2;
12611: 
12611:             /* Position cases so the most frequent i++ does not need a jump. */
12611:           BEGIN_CASE(JSOP_DECARG)
12611:             incr = -2; incr2 = -2; goto do_arg_incop;
12611:           BEGIN_CASE(JSOP_ARGDEC)
12611:             incr = -2; incr2 =  0; goto do_arg_incop;
12611:           BEGIN_CASE(JSOP_INCARG)
12611:             incr =  2; incr2 =  2; goto do_arg_incop;
12611:           BEGIN_CASE(JSOP_ARGINC)
12611:             incr =  2; incr2 =  0;
12611: 
12611:           do_arg_incop:
13168:             slot = GET_ARGNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->nargs);
12611:             METER_SLOT_OP(op, slot);
12611:             vp = fp->argv + slot;
12611:             goto do_int_fast_incop;
12611: 
12611:           BEGIN_CASE(JSOP_DECLOCAL)
12611:             incr = -2; incr2 = -2; goto do_local_incop;
12611:           BEGIN_CASE(JSOP_LOCALDEC)
12611:             incr = -2; incr2 =  0; goto do_local_incop;
12611:           BEGIN_CASE(JSOP_INCLOCAL)
12611:             incr =  2; incr2 =  2; goto do_local_incop;
12611:           BEGIN_CASE(JSOP_LOCALINC)
12611:             incr =  2; incr2 =  0;
12611: 
12611:           do_local_incop:
13168:             slot = GET_UINT16(regs.pc);
12611:             JS_ASSERT(slot < script->depth);
12611:             vp = fp->spbase + slot;
12611:             goto do_int_fast_incop;
12611: 
12611:           BEGIN_CASE(JSOP_DECVAR)
12611:             incr = -2; incr2 = -2; goto do_var_incop;
12611:           BEGIN_CASE(JSOP_VARDEC)
12611:             incr = -2; incr2 =  0; goto do_var_incop;
12611:           BEGIN_CASE(JSOP_INCVAR)
12611:             incr =  2; incr2 =  2; goto do_var_incop;
12611:           BEGIN_CASE(JSOP_VARINC)
12611:             incr =  2; incr2 =  0;
12611: 
12611:           /*
12611:            * do_var_incop comes right before do_int_fast_incop as we want to
12611:            * avoid an extra jump for variable cases as var++ is more frequent
12611:            * than arg++ or local++;
12611:            */
12611:           do_var_incop:
13168:             slot = GET_VARNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->u.i.nvars);
12611:             METER_SLOT_OP(op, slot);
12611:             vp = fp->vars + slot;
12611: 
12611:           do_int_fast_incop:
12611:             rval = *vp;
12611:             if (JS_LIKELY(CAN_DO_FAST_INC_DEC(rval))) {
12611:                 *vp = rval + incr;
12611:                 PUSH_OPND(rval + incr2);
12611:             } else {
12611:                 PUSH_OPND(rval);
13168:                 if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-1], vp))
12611:                     goto error;
12611:             }
12611:             len = JSOP_INCARG_LENGTH;
12611:             JS_ASSERT(len == js_CodeSpec[op].length);
12611:             DO_NEXT_OP(len);
12611:           }
12611: 
    1: /* NB: This macro doesn't use JS_BEGIN_MACRO/JS_END_MACRO around its body. */
12611: #define FAST_GLOBAL_INCREMENT_OP(SLOWOP,INCR,INCR2)                           \
12611:     op2 = SLOWOP;                                                             \
12611:     incr = INCR;                                                              \
12611:     incr2 = INCR2;                                                            \
12611:     goto do_global_incop
12611: 
12611:           {
12611:             jsval incr, incr2;
12611: 
12611:           BEGIN_CASE(JSOP_DECGVAR)
12611:             FAST_GLOBAL_INCREMENT_OP(JSOP_DECNAME, -2, -2);
12611:           BEGIN_CASE(JSOP_GVARDEC)
12611:             FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEDEC, -2,  0);
    1:           BEGIN_CASE(JSOP_INCGVAR)
12611:               FAST_GLOBAL_INCREMENT_OP(JSOP_INCNAME,  2,  2);
    1:           BEGIN_CASE(JSOP_GVARINC)
12611:             FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEINC,  2,  0);
12611: 
12611: #undef FAST_GLOBAL_INCREMENT_OP
12611: 
12611:           do_global_incop:
12611:             JS_ASSERT((js_CodeSpec[op].format & JOF_TMPSLOT_MASK) ==
12611:                       JOF_TMPSLOT2);
13168:             slot = GET_VARNO(regs.pc);
12611:             JS_ASSERT(slot < fp->nvars);
12611:             METER_SLOT_OP(op, slot);
12611:             lval = fp->vars[slot];
12611:             if (JSVAL_IS_NULL(lval)) {
12611:                 op = op2;
12611:                 DO_OP();
12611:             }
12611:             slot = JSVAL_TO_INT(lval);
12611:             rval = OBJ_GET_SLOT(cx, fp->varobj, slot);
12611:             if (JS_LIKELY(CAN_DO_FAST_INC_DEC(rval))) {
12611:                 PUSH_OPND(rval + incr2);
12611:                 rval += incr;
12611:             } else {
12611:                 PUSH_OPND(rval);
12611:                 PUSH_OPND(JSVAL_NULL);  /* Extra root */
13168:                 if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-2], &regs.sp[-1]))
13014:                     goto error;
13168:                 rval = regs.sp[-1];
13168:                 --regs.sp;
12611:             }
12611:             OBJ_SET_SLOT(cx, fp->varobj, slot, rval);
    1:             len = JSOP_INCGVAR_LENGTH;  /* all gvar incops are same length */
    1:             JS_ASSERT(len == js_CodeSpec[op].length);
    1:             DO_NEXT_OP(len);
    1:           }
    1: 
12470: #define COMPUTE_THIS(cx, fp, obj)                                             \
12470:     JS_BEGIN_MACRO                                                            \
12470:         if (fp->flags & JSFRAME_COMPUTED_THIS) {                              \
12470:             obj = fp->thisp;                                                  \
12470:         } else {                                                              \
12470:             obj = js_ComputeThis(cx, JS_TRUE, fp->argv);                      \
12470:             if (!obj)                                                         \
12470:                 goto error;                                                   \
12470:             fp->thisp = obj;                                                  \
12470:             fp->flags |= JSFRAME_COMPUTED_THIS;                               \
12470:         }                                                                     \
12470:     JS_END_MACRO
12470: 
12470:           BEGIN_CASE(JSOP_THIS)
12470:             COMPUTE_THIS(cx, fp, obj);
12470:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
12470:           END_CASE(JSOP_THIS)
12470: 
    1:           BEGIN_CASE(JSOP_GETTHISPROP)
11377:             i = 0;
12470:             COMPUTE_THIS(cx, fp, obj);
11377:             PUSH(JSVAL_NULL);
11377:             len = JSOP_GETTHISPROP_LENGTH;
11377:             goto do_getprop_with_obj;
    1: 
12470: #undef COMPUTE_THIS
12470: 
    1:           BEGIN_CASE(JSOP_GETARGPROP)
11377:             i = ARGNO_LEN;
13168:             slot = GET_ARGNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->nargs);
    1:             PUSH_OPND(fp->argv[slot]);
    1:             len = JSOP_GETARGPROP_LENGTH;
    1:             goto do_getprop_body;
    1: 
    1:           BEGIN_CASE(JSOP_GETVARPROP)
11377:             i = VARNO_LEN;
13168:             slot = GET_VARNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->u.i.nvars);
    1:             PUSH_OPND(fp->vars[slot]);
    1:             len = JSOP_GETVARPROP_LENGTH;
    1:             goto do_getprop_body;
    1: 
    1:           BEGIN_CASE(JSOP_GETLOCALPROP)
11377:             i = UINT16_LEN;
13168:             slot = GET_UINT16(regs.pc);
12579:             JS_ASSERT(slot < script->depth);
    1:             PUSH_OPND(fp->spbase[slot]);
    1:             len = JSOP_GETLOCALPROP_LENGTH;
    1:             goto do_getprop_body;
    1: 
    1:           BEGIN_CASE(JSOP_GETPROP)
    1:           BEGIN_CASE(JSOP_GETXPROP)
11377:             i = 0;
    1:             len = JSOP_GETPROP_LENGTH;
    1: 
    1:           do_getprop_body:
    1:             lval = FETCH_OPND(-1);
11377: 
11377:           do_getprop_with_lval:
11377:             VALUE_TO_OBJECT(cx, -1, lval, obj);
11377: 
11377:           do_getprop_with_obj:
11377:             do {
11377:                 JSPropCacheEntry *entry;
11377: 
11377:                 if (JS_LIKELY(obj->map->ops->getProperty == js_GetProperty)) {
13168:                     PROPERTY_CACHE_TEST(cx, regs.pc, obj, obj2, entry, atom);
11377:                     if (!atom) {
11377:                         ASSERT_VALID_PROPERTY_CACHE_HIT(i, obj, obj2, entry);
11377:                         if (PCVAL_IS_OBJECT(entry->vword)) {
11377:                             rval = PCVAL_OBJECT_TO_JSVAL(entry->vword);
11377:                         } else if (PCVAL_IS_SLOT(entry->vword)) {
11377:                             slot = PCVAL_TO_SLOT(entry->vword);
11377:                             JS_ASSERT(slot < obj2->map->freeslot);
11377:                             rval = LOCKED_OBJ_GET_SLOT(obj2, slot);
11377:                         } else {
11377:                             JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
11377:                             sprop = PCVAL_TO_SPROP(entry->vword);
11377:                             NATIVE_GET(cx, obj, obj2, sprop, &rval);
11377:                         }
11377:                         JS_UNLOCK_OBJ(cx, obj2);
11377:                         break;
11377:                     }
11832:                 } else {
11832:                     entry = NULL;
11377:                     if (i < 0)
11377:                         atom = rt->atomState.lengthAtom;
11377:                     else
11377:                         LOAD_ATOM(i);
11377:                 }
11377:                 id = ATOM_TO_JSID(atom);
11859:                 if (entry
11859:                     ? !js_GetPropertyHelper(cx, obj, id, &rval, &entry)
11859:                     : !OBJ_GET_PROPERTY(cx, obj, id, &rval)) {
11859:                     goto error;
11859:                 }
11377:             } while (0);
11377: 
11377:             STORE_OPND(-1, rval);
11377:           END_VARLEN_CASE
11377: 
11377:           BEGIN_CASE(JSOP_LENGTH)
11377:             lval = FETCH_OPND(-1);
11377:             if (JSVAL_IS_STRING(lval)) {
    1:                 str = JSVAL_TO_STRING(lval);
13168:                 regs.sp[-1] = INT_TO_JSVAL(JSSTRING_LENGTH(str));
11377:             } else if (!JSVAL_IS_PRIMITIVE(lval) &&
11835:                        (obj = JSVAL_TO_OBJECT(lval), OBJ_IS_ARRAY(cx, obj))) {
11835:                 jsuint length;
11835: 
11377:                 /*
11377:                  * We know that the array is created with only its 'length'
11377:                  * private data in a fixed slot at JSSLOT_ARRAY_LENGTH. See
11377:                  * also JSOP_ARRAYPUSH, far below.
11377:                  */
11835:                 length = obj->fslots[JSSLOT_ARRAY_LENGTH];
11835:                 if (length <= JSVAL_INT_MAX) {
13168:                     regs.sp[-1] = INT_TO_JSVAL(length);
13168:                 } else if (!js_NewDoubleInRootedValue(cx, (jsdouble) length,
13168:                                                       &regs.sp[-1])) {
11859:                     goto error;
11835:                 }
    1:             } else {
11377:                 i = -1;
11377:                 len = JSOP_LENGTH_LENGTH;
11377:                 goto do_getprop_with_lval;
11377:             }
11377:           END_CASE(JSOP_LENGTH)
11377: 
11377:           BEGIN_CASE(JSOP_CALLPROP)
11377:           {
11848:             JSObject *aobj;
11377:             JSPropCacheEntry *entry;
11377: 
11377:             lval = FETCH_OPND(-1);
11377:             if (!JSVAL_IS_PRIMITIVE(lval)) {
11377:                 obj = JSVAL_TO_OBJECT(lval);
11377:             } else {
11377:                 if (JSVAL_IS_STRING(lval)) {
11377:                     i = JSProto_String;
11377:                 } else if (JSVAL_IS_NUMBER(lval)) {
11377:                     i = JSProto_Number;
11377:                 } else if (JSVAL_IS_BOOLEAN(lval)) {
11377:                     i = JSProto_Boolean;
11377:                 } else {
11377:                     JS_ASSERT(JSVAL_IS_NULL(lval) || JSVAL_IS_VOID(lval));
11377:                     js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
11859:                     goto error;
11859:                 }
11859: 
11859:                 if (!js_GetClassPrototype(cx, NULL, INT_TO_JSID(i), &obj))
11859:                     goto error;
    1:             }
11377: 
11848:             aobj = OBJ_IS_DENSE_ARRAY(cx, obj) ? OBJ_GET_PROTO(cx, obj) : obj;
11848:             if (JS_LIKELY(aobj->map->ops->getProperty == js_GetProperty)) {
13168:                 PROPERTY_CACHE_TEST(cx, regs.pc, aobj, obj2, entry, atom);
11377:                 if (!atom) {
11848:                     ASSERT_VALID_PROPERTY_CACHE_HIT(0, aobj, obj2, entry);
11377:                     if (PCVAL_IS_OBJECT(entry->vword)) {
11377:                         rval = PCVAL_OBJECT_TO_JSVAL(entry->vword);
11377:                     } else if (PCVAL_IS_SLOT(entry->vword)) {
11377:                         slot = PCVAL_TO_SLOT(entry->vword);
11377:                         JS_ASSERT(slot < obj2->map->freeslot);
11377:                         rval = LOCKED_OBJ_GET_SLOT(obj2, slot);
11377:                     } else {
11377:                         JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
11377:                         sprop = PCVAL_TO_SPROP(entry->vword);
11377:                         NATIVE_GET(cx, obj, obj2, sprop, &rval);
11377:                     }
11377:                     JS_UNLOCK_OBJ(cx, obj2);
    1:                     STORE_OPND(-1, rval);
11377:                     PUSH_OPND(lval);
12579:                     goto end_callprop;
11377:                 }
11832:             } else {
11832:                 entry = NULL;
11832:                 LOAD_ATOM(0);
11832:             }
11377: 
11377:             /*
11377:              * Cache miss: use the immediate atom that was loaded for us under
11377:              * PROPERTY_CACHE_TEST.
11377:              */
 8658:             id = ATOM_TO_JSID(atom);
 8658:             PUSH(JSVAL_NULL);
 8658:             if (!JSVAL_IS_PRIMITIVE(lval)) {
 8658: #if JS_HAS_XML_SUPPORT
 8658:                 /* Special-case XML object method lookup, per ECMA-357. */
 8658:                 if (OBJECT_IS_XML(cx, obj)) {
 8658:                     JSXMLObjectOps *ops;
 8658: 
 8658:                     ops = (JSXMLObjectOps *) obj->map->ops;
 8658:                     obj = ops->getMethod(cx, obj, id, &rval);
 8658:                     if (!obj)
11859:                         goto error;
 8658:                 } else
 8658: #endif
11859:                 if (JS_LIKELY(aobj->map->ops->getProperty == js_GetProperty)
11859:                     ? !js_GetPropertyHelper(cx, aobj, id, &rval, &entry)
11859:                     : !OBJ_GET_PROPERTY(cx, obj, id, &rval)) {
11859:                     goto error;
11859:                 }
 8658:                 STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
 8658:                 STORE_OPND(-2, rval);
 8658:             } else {
11377:                 JS_ASSERT(obj->map->ops->getProperty == js_GetProperty);
11859:                 if (!js_GetPropertyHelper(cx, obj, id, &rval, &entry))
11859:                     goto error;
 8658:                 STORE_OPND(-1, lval);
 8658:                 STORE_OPND(-2, rval);
11377:             }
11377: 
12579:           end_callprop:
 8658:             /* Wrap primitive lval in object clothing if necessary. */
11377:             if (JSVAL_IS_PRIMITIVE(lval)) {
11377:                 /* FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=412571 */
 8658:                 if (!VALUE_IS_FUNCTION(cx, rval) ||
 8658:                     (obj = JSVAL_TO_OBJECT(rval),
13691:                      fun = GET_FUNCTION_PRIVATE(cx, obj),
 8658:                      !PRIMITIVE_THIS_TEST(fun, lval))) {
13168:                     if (!js_PrimitiveToObject(cx, &regs.sp[-1]))
11859:                         goto error;
 8658:                 }
 8658:             }
12579: #if JS_HAS_NO_SUCH_METHOD
12579:             if (JS_UNLIKELY(rval == JSVAL_VOID)) {
12579:                 LOAD_ATOM(0);
13168:                 regs.sp[-2] = ATOM_KEY(atom);
13168:                 if (!js_OnUnknownMethod(cx, regs.sp - 2))
12579:                     goto error;
12579:             }
12579: #endif
11377:           }
 8658:           END_CASE(JSOP_CALLPROP)
 8658: 
11377:           BEGIN_CASE(JSOP_SETNAME)
    1:           BEGIN_CASE(JSOP_SETPROP)
11377:             rval = FETCH_OPND(-1);
11377:             lval = FETCH_OPND(-2);
11377:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(lval) || op == JSOP_SETPROP);
11377:             VALUE_TO_OBJECT(cx, -2, lval, obj);
11377: 
11377:             do {
11377:                 JSPropCacheEntry *entry;
11377: 
11377:                 entry = NULL;
11377:                 atom = NULL;
11377:                 if (JS_LIKELY(obj->map->ops->setProperty == js_SetProperty)) {
11377:                     JSPropertyCache *cache = &JS_PROPERTY_CACHE(cx);
11377:                     uint32 kshape = OBJ_SCOPE(obj)->shape;
11377: 
11377:                     /*
11377:                      * Open-code JS_PROPERTY_CACHE_TEST, specializing for two
11377:                      * important set-property cases. First:
11377:                      *
11377:                      *   function f(a, b, c) {
11377:                      *     var o = {p:a, q:b, r:c};
11377:                      *     return o;
11377:                      *   }
11377:                      *
11377:                      * or similar real-world cases, which evolve a newborn
11377:                      * native object predicatably through some bounded number
11377:                      * of property additions. And second:
11377:                      *
11377:                      *   o.p = x;
11377:                      *
11377:                      * in a frequently executed method or loop body, where p
11377:                      * will (possibly after the first iteration) always exist
11377:                      * in native object o.
11377:                      */
13168:                     entry = &cache->table[PROPERTY_CACHE_HASH_PC(regs.pc,
13168:                                                                  kshape)];
11377:                     PCMETER(cache->tests++);
11377:                     PCMETER(cache->settests++);
13168:                     if (entry->kpc == regs.pc && entry->kshape == kshape) {
11377:                         JSScope *scope;
11377: 
11377:                         JS_LOCK_OBJ(cx, obj);
11377:                         scope = OBJ_SCOPE(obj);
11377:                         if (scope->shape == kshape) {
11377:                             JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
11377:                             sprop = PCVAL_TO_SPROP(entry->vword);
11377:                             JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
14719:                             JS_ASSERT(!(sprop->attrs & JSPROP_SHARED));
11377:                             JS_ASSERT(!SCOPE_IS_SEALED(OBJ_SCOPE(obj)));
11377: 
11377:                             if (scope->object == obj) {
11377:                                 /*
11377:                                  * Fastest path: the cached sprop is already
11377:                                  * in scope. Just NATIVE_SET and break to get
11377:                                  * out of the do-while(0).
11377:                                  */
11377:                                 if (sprop == scope->lastProp ||
11377:                                     SCOPE_HAS_PROPERTY(scope, sprop)) {
11377:                                     PCMETER(cache->pchits++);
11377:                                     PCMETER(cache->setpchits++);
11377:                                     NATIVE_SET(cx, obj, sprop, &rval);
11442:                                     JS_UNLOCK_SCOPE(cx, scope);
11377:                                     break;
11377:                                 }
11377:                             } else {
11377:                                 scope = js_GetMutableScope(cx, obj);
12307:                                 if (!scope) {
12307:                                     JS_UNLOCK_OBJ(cx, obj);
11859:                                     goto error;
11377:                                 }
12307:                             }
11377: 
11377:                             if (sprop->parent == scope->lastProp &&
11377:                                 !SCOPE_HAD_MIDDLE_DELETE(scope) &&
11377:                                 SPROP_HAS_STUB_SETTER(sprop) &&
12307:                                 (slot = sprop->slot) == scope->map.freeslot) {
11377:                                 /*
11377:                                  * Fast path: adding a plain old property that
11377:                                  * was once at the frontier of the property
11377:                                  * tree, whose slot is next to claim among the
11377:                                  * allocated slots in obj, where scope->table
11377:                                  * has not been created yet.
11377:                                  *
11377:                                  * We may want to remove hazard conditions
11377:                                  * above and inline compensation code here,
11377:                                  * depending on real-world workloads.
11377:                                  */
11377:                                 JS_ASSERT(!(LOCKED_OBJ_GET_CLASS(obj)->flags &
11377:                                             JSCLASS_SHARE_ALL_PROPERTIES));
11377: 
11377:                                 PCMETER(cache->pchits++);
11377:                                 PCMETER(cache->addpchits++);
12307: 
12307:                                 /*
12307:                                  * Beware classes such as Function that use
12307:                                  * the reserveSlots hook to allocate a number
12307:                                  * of reserved slots that may vary with obj.
12307:                                  */
12307:                                 if (slot < STOBJ_NSLOTS(obj) &&
12307:                                     !OBJ_GET_CLASS(cx, obj)->reserveSlots) {
11377:                                     ++scope->map.freeslot;
11377:                                 } else {
12307:                                     if (!js_AllocSlot(cx, obj, &slot)) {
12307:                                         JS_UNLOCK_SCOPE(cx, scope);
12307:                                         goto error;
12307:                                     }
12307:                                 }
12307: 
12307:                                 /*
12307:                                  * If this obj's number of reserved slots
12307:                                  * differed, or if something created a hash
12307:                                  * table for scope, we must pay the price of
12307:                                  * js_AddScopeProperty.
12307:                                  *
12307:                                  * If slot does not match the cached sprop's
12307:                                  * slot, update the cache entry in the hope
12307:                                  * that obj and other instances with the same
12307:                                  * number of reserved slots are now "hot".
12307:                                  */
12307:                                 if (slot != sprop->slot || scope->table) {
12307:                                     JSScopeProperty *sprop2 =
12307:                                         js_AddScopeProperty(cx, scope,
12307:                                                             sprop->id,
12307:                                                             sprop->getter,
12307:                                                             sprop->setter,
12307:                                                             slot,
12307:                                                             sprop->attrs,
12307:                                                             sprop->flags,
12307:                                                             sprop->shortid);
12307:                                     if (!sprop2) {
12307:                                         js_FreeSlot(cx, obj, slot);
12307:                                         JS_UNLOCK_SCOPE(cx, scope);
12307:                                         goto error;
12307:                                     }
12307:                                     if (sprop2 != sprop) {
12307:                                         PCMETER(cache->slotchanges++);
12307:                                         JS_ASSERT(slot != sprop->slot &&
12307:                                                   slot == sprop2->slot &&
12307:                                                   sprop2->id == sprop->id);
12307:                                         entry->vword = SPROP_TO_PCVAL(sprop2);
12307:                                     }
12307:                                     sprop = sprop2;
12307:                                 } else {
12307:                                     SCOPE_EXTEND_SHAPE(cx, scope, sprop);
11377:                                     ++scope->entryCount;
11377:                                     scope->lastProp = sprop;
12307:                                 }
12307: 
11377:                                 GC_WRITE_BARRIER(cx, scope,
11377:                                                  LOCKED_OBJ_GET_SLOT(obj, slot),
11377:                                                  rval);
11377:                                 LOCKED_OBJ_SET_SLOT(obj, slot, rval);
11377:                                 JS_UNLOCK_SCOPE(cx, scope);
11377:                                 break;
11377:                             }
11377: 
11377:                             PCMETER(cache->setpcmisses++);
11377:                             atom = NULL;
11377:                         }
11377: 
11377:                         JS_UNLOCK_OBJ(cx, obj);
11377:                     }
11377: 
13168:                     atom = js_FullTestPropertyCache(cx, regs.pc, &obj, &obj2,
11859:                                                     &entry);
11377:                     if (atom) {
11377:                         PCMETER(cache->misses++);
11377:                         PCMETER(cache->setmisses++);
11377:                     } else {
11377:                         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
11377:                         if (obj == obj2) {
11377:                             if (PCVAL_IS_SLOT(entry->vword)) {
11377:                                 slot = PCVAL_TO_SLOT(entry->vword);
11377:                                 JS_ASSERT(slot < obj->map->freeslot);
11377:                                 LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, rval);
11377:                             } else if (PCVAL_IS_SPROP(entry->vword)) {
11377:                                 sprop = PCVAL_TO_SPROP(entry->vword);
11377:                                 JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
11377:                                 JS_ASSERT(!SCOPE_IS_SEALED(OBJ_SCOPE(obj2)));
11377:                                 NATIVE_SET(cx, obj, sprop, &rval);
11377:                             }
11377:                         }
11377:                         JS_UNLOCK_OBJ(cx, obj2);
11859:                         if (obj == obj2 && !PCVAL_IS_OBJECT(entry->vword))
11377:                             break;
11377:                     }
11377:                 }
11377: 
11377:                 if (!atom)
    1:                     LOAD_ATOM(0);
    1:                 id = ATOM_TO_JSID(atom);
11859:                 if (entry
11859:                     ? !js_SetPropertyHelper(cx, obj, id, &rval, &entry)
11859:                     : !OBJ_SET_PROPERTY(cx, obj, id, &rval)) {
11859:                     goto error;
11859:                 }
11377:             } while (0);
11377: 
13168:             regs.sp--;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_SETPROP)
    1: 
    1:           BEGIN_CASE(JSOP_GETELEM)
12231:             /* Open-coded ELEMENT_OP optimized for strings and dense arrays. */
12231:             lval = FETCH_OPND(-2);
12231:             rval = FETCH_OPND(-1);
12231:             if (JSVAL_IS_STRING(lval) && JSVAL_IS_INT(rval)) {
12231:                 str = JSVAL_TO_STRING(lval);
12231:                 i = JSVAL_TO_INT(rval);
12231:                 if ((size_t)i < JSSTRING_LENGTH(str)) {
12267:                     str = js_GetUnitString(cx, str, (size_t)i);
12231:                     if (!str)
12231:                         goto error;
12231:                     rval = STRING_TO_JSVAL(str);
12231:                     goto end_getelem;
12231:                 }
12231:             }
12267: 
12231:             VALUE_TO_OBJECT(cx, -2, lval, obj);
12231:             if (JSVAL_IS_INT(rval)) {
12231:                 if (OBJ_IS_DENSE_ARRAY(cx, obj)) {
12231:                     jsuint length;
12231: 
12231:                     length = ARRAY_DENSE_LENGTH(obj);
12231:                     i = JSVAL_TO_INT(rval);
12231:                     if ((jsuint)i < length &&
12231:                         i < obj->fslots[JSSLOT_ARRAY_LENGTH]) {
12231:                         rval = obj->dslots[i];
12231:                         if (rval != JSVAL_HOLE)
12231:                             goto end_getelem;
14667: 
14667:                         /* Reload rval from the stack in the rare hole case. */
14667:                         rval = FETCH_OPND(-1);
12231:                     }
12231:                 }
12231:                 id = INT_JSVAL_TO_JSID(rval);
12231:             } else {
12551:                 if (!js_InternNonIntElementId(cx, obj, rval, &id))
12231:                     goto error;
12231:             }
12267: 
12231:             if (!OBJ_GET_PROPERTY(cx, obj, id, &rval))
12231:                 goto error;
12231:           end_getelem:
13168:             regs.sp--;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_GETELEM)
    1: 
    1:           BEGIN_CASE(JSOP_CALLELEM)
    1:             /*
 4127:              * FIXME: JSOP_CALLELEM should call getMethod on XML objects as
 4127:              * CALLPROP does. See bug 362910.
    1:              */
11859:             ELEMENT_OP(-1, OBJ_GET_PROPERTY(cx, obj, id, &rval));
12579: #if JS_HAS_NO_SUCH_METHOD
12579:             if (JS_UNLIKELY(rval == JSVAL_VOID)) {
13168:                 regs.sp[-2] = regs.sp[-1];
13168:                 regs.sp[-1] = OBJECT_TO_JSVAL(obj);
13168:                 if (!js_OnUnknownMethod(cx, regs.sp - 2))
12579:                     goto error;
12579:             } else
12579: #endif
12579:             {
    1:                 STORE_OPND(-2, rval);
    1:                 STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
12579:             }
    1:           END_CASE(JSOP_CALLELEM)
    1: 
    1:           BEGIN_CASE(JSOP_SETELEM)
    1:             rval = FETCH_OPND(-1);
12231:             FETCH_OBJECT(cx, -3, lval, obj);
12231:             FETCH_ELEMENT_ID(obj, -2, id);
12231:             if (OBJ_IS_DENSE_ARRAY(cx, obj) && JSID_IS_INT(id)) {
12231:                 jsuint length;
12231: 
12231:                 length = ARRAY_DENSE_LENGTH(obj);
12231:                 i = JSID_TO_INT(id);
12231:                 if ((jsuint)i < length) {
12231:                     if (obj->dslots[i] == JSVAL_HOLE) {
12231:                         if (i >= obj->fslots[JSSLOT_ARRAY_LENGTH])
12231:                             obj->fslots[JSSLOT_ARRAY_LENGTH] = i + 1;
12231:                         obj->fslots[JSSLOT_ARRAY_COUNT]++;
12231:                     }
12231:                     obj->dslots[i] = rval;
12231:                     goto end_setelem;
12231:                 }
12231:             }
12231:             if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
12231:                 goto error;
12231:         end_setelem:
13168:             regs.sp -= 2;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_SETELEM)
    1: 
    1:           BEGIN_CASE(JSOP_ENUMELEM)
    1:             /* Funky: the value to set is under the [obj, id] pair. */
    1:             rval = FETCH_OPND(-3);
    1:             FETCH_OBJECT(cx, -2, lval, obj);
    1:             FETCH_ELEMENT_ID(obj, -1, id);
11859:             if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
11859:                 goto error;
13168:             regs.sp -= 3;
    1:           END_CASE(JSOP_ENUMELEM)
    1: 
    1:           BEGIN_CASE(JSOP_CALL)
    1:           BEGIN_CASE(JSOP_EVAL)
13168:             argc = GET_ARGC(regs.pc);
13168:             vp = regs.sp - (argc + 2);
    1:             lval = *vp;
 4127:             if (VALUE_IS_FUNCTION(cx, lval)) {
 4127:                 obj = JSVAL_TO_OBJECT(lval);
13691:                 fun = GET_FUNCTION_PRIVATE(cx, obj);
13702: 
13702:                 if (FUN_INTERPRETED(fun)) {
13168:                     uintN nframeslots, nvars, missing;
    1:                     JSArena *a;
13168:                     jsuword nbytes;
11859:                     void *newmark;
13168:                     jsval *newsp;
    1:                     JSInlineFrame *newifp;
    1:                     JSInterpreterHook hook;
    1: 
13872:                     /* Restrict recursion of lightweight functions. */
13872:                     if (inlineCallCount == MAX_INLINE_CALL_COUNT) {
13872:                         js_ReportOverRecursed(cx);
13872:                         goto error;
13872:                     }
13872: 
 4127:                     /* Compute the total number of stack slots needed by fun. */
 4127:                     nframeslots = JS_HOWMANY(sizeof(JSInlineFrame),
 4127:                                              sizeof(jsval));
13702:                     nvars = fun->u.i.nvars;
13702:                     script = fun->u.i.script;
    1:                     atoms = script->atomMap.vector;
13168:                     nbytes = (nframeslots + nvars + script->depth) *
13168:                              sizeof(jsval);
    1: 
 4127:                     /* Allocate missing expected args adjacent to actuals. */
    1:                     a = cx->stackPool.current;
13168:                     newmark = (void *) a->avail;
13702:                     if (fun->nargs <= argc) {
13168:                         missing = 0;
13168:                     } else {
13702:                         newsp = vp + 2 + fun->nargs;
13168:                         JS_ASSERT(newsp > regs.sp);
13168:                         if ((jsuword) newsp <= a->limit) {
13168:                             if ((jsuword) newsp > a->avail)
13168:                                 a->avail = (jsuword) newsp;
13168:                             do {
13168:                                 *--newsp = JSVAL_VOID;
13168:                             } while (newsp != regs.sp);
13168:                             missing = 0;
13168:                         } else {
13702:                             missing = fun->nargs - argc;
13702:                             nbytes += (2 + fun->nargs) * sizeof(jsval);
13168:                         }
13168:                     }
    1: 
 4127:                     /* Allocate the inline frame with its vars and operands. */
13168:                     if (a->avail + nbytes <= a->limit) {
13168:                         newsp = (jsval *) a->avail;
13168:                         a->avail += nbytes;
13168:                         JS_ASSERT(missing == 0);
    1:                     } else {
    1:                         JS_ARENA_ALLOCATE_CAST(newsp, jsval *, &cx->stackPool,
    1:                                                nbytes);
    1:                         if (!newsp) {
 8296:                             js_ReportOutOfScriptQuota(cx);
    1:                             goto bad_inline_call;
    1:                         }
13014: 
13014:                         /*
13168:                          * Move args if missing overflow arena a, then push
13168:                          * any missing args.
13014:                          */
    1:                         if (missing) {
    1:                             memcpy(newsp, vp, (2 + argc) * sizeof(jsval));
    1:                             vp = newsp;
13168:                             newsp = vp + 2 + argc;
    1:                             do {
13168:                                 *newsp++ = JSVAL_VOID;
    1:                             } while (--missing != 0);
    1:                         }
13168:                     }
    1: 
    1:                     /* Claim space for the stack frame and initialize it. */
    1:                     newifp = (JSInlineFrame *) newsp;
    1:                     newsp += nframeslots;
    1:                     newifp->frame.callobj = NULL;
    1:                     newifp->frame.argsobj = NULL;
    1:                     newifp->frame.varobj = NULL;
    1:                     newifp->frame.script = script;
 4127:                     newifp->frame.callee = obj;
    1:                     newifp->frame.fun = fun;
    1:                     newifp->frame.argc = argc;
    1:                     newifp->frame.argv = vp + 2;
    1:                     newifp->frame.rval = JSVAL_VOID;
    1:                     newifp->frame.nvars = nvars;
    1:                     newifp->frame.vars = newsp;
    1:                     newifp->frame.down = fp;
    1:                     newifp->frame.annotation = NULL;
    1:                     newifp->frame.scopeChain = parent = OBJ_GET_PARENT(cx, obj);
    1:                     newifp->frame.sharpDepth = 0;
    1:                     newifp->frame.sharpArray = NULL;
    1:                     newifp->frame.flags = 0;
    1:                     newifp->frame.dormantNext = NULL;
    1:                     newifp->frame.xmlNamespace = NULL;
    1:                     newifp->frame.blockChain = NULL;
11377: #ifdef DEBUG
11758:                     newifp->frame.pcDisabledSave =
11758:                         JS_PROPERTY_CACHE(cx).disabled;
11377: #endif
    1:                     newifp->mark = newmark;
    1: 
    1:                     /* Compute the 'this' parameter now that argv is set. */
13702:                     JS_ASSERT(!JSFUN_BOUND_METHOD_TEST(fun->flags));
11774:                     JS_ASSERT(JSVAL_IS_OBJECT(vp[1]));
 4127:                     newifp->frame.thisp = (JSObject *)vp[1];
    1: 
    1:                     /* Push void to initialize local variables. */
    1:                     while (nvars--)
13168:                         *newsp++ = JSVAL_VOID;
13168: 
13168:                     newifp->frame.regs = NULL;
13168:                     newifp->frame.spbase = NULL;
    1: 
    1:                     /* Call the debugger hook if present. */
 2433:                     hook = cx->debugHooks->callHook;
    1:                     if (hook) {
    1:                         newifp->hookData = hook(cx, &newifp->frame, JS_TRUE, 0,
 2433:                                                 cx->debugHooks->callHookData);
 2433:                         LOAD_INTERRUPT_HANDLER(cx);
    1:                     } else {
    1:                         newifp->hookData = NULL;
    1:                     }
    1: 
 4127:                     /* Scope with a call object parented by callee's parent. */
13702:                     if (JSFUN_HEAVYWEIGHT_TEST(fun->flags) &&
    1:                         !js_GetCallObject(cx, &newifp->frame, parent)) {
 2065:                         goto bad_inline_call;
    1:                     }
    1: 
 4127:                     /* Switch version if currentVersion wasn't overridden. */
 3164:                     newifp->callerVersion = (JSVersion) cx->version;
    1:                     if (JS_LIKELY(cx->version == currentVersion)) {
 3164:                         currentVersion = (JSVersion) script->version;
    1:                         if (currentVersion != cx->version)
    1:                             js_SetVersion(cx, currentVersion);
    1:                     }
    1: 
    1:                     /* Push the frame and set interpreter registers. */
13168:                     newifp->callerRegs = regs;
13168:                     fp->regs = &newifp->callerRegs;
13168:                     regs.sp = newifp->frame.spbase = newsp;
13168:                     regs.pc = script->code;
13168:                     newifp->frame.regs = &regs;
    1:                     cx->fp = fp = &newifp->frame;
13168: 
    1:                     inlineCallCount++;
    1:                     JS_RUNTIME_METER(rt, inlineCalls);
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:                     /* DTrace function entry, inlines */
 7058:                     if (JAVASCRIPT_FUNCTION_ENTRY_ENABLED())
 7058:                         jsdtrace_function_entry(cx, fp, fun);
 7058:                     if (JAVASCRIPT_FUNCTION_INFO_ENABLED())
 7058:                         jsdtrace_function_info(cx, fp, fp->down, fun);
 7058:                     if (JAVASCRIPT_FUNCTION_ARGS_ENABLED())
 7058:                         jsdtrace_function_args(cx, fp, fun);
 7058: #endif
 7058: 
 4127:                     /* Load first op and dispatch it (safe since JSOP_STOP). */
13168:                     op = (JSOp) *regs.pc;
    1:                     DO_OP();
    1: 
    1:                   bad_inline_call:
13168:                     JS_ASSERT(fp->regs == &regs);
    1:                     script = fp->script;
    1:                     atoms = script->atomMap.vector;
12551:                     js_FreeRawStack(cx, newmark);
11859:                     goto error;
    1:                 }
 3739: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:                 /* DTrace function entry, non-inlines */
 7058:                 if (VALUE_IS_FUNCTION(cx, lval)) {
 7058:                     if (JAVASCRIPT_FUNCTION_ENTRY_ENABLED())
 7058:                         jsdtrace_function_entry(cx, fp, fun);
 7058:                     if (JAVASCRIPT_FUNCTION_INFO_ENABLED())
 7058:                         jsdtrace_function_info(cx, fp, fp, fun);
 7058:                     if (JAVASCRIPT_FUNCTION_ARGS_ENABLED())
 7058:                         jsdtrace_function_args(cx, fp, fun);
 7058:                 }
 7058: #endif
 7058: 
13702:                 if (fun->flags & JSFUN_FAST_NATIVE) {
13702:                     JS_ASSERT(fun->u.n.extra == 0);
13702:                     if (argc < fun->u.n.minargs) {
 6917:                         uintN nargs;
 6917: 
 4127:                         /*
 4127:                          * If we can't fit missing args and local roots in
 4127:                          * this frame's operand stack, take the slow path.
 4127:                          */
13702:                         nargs = fun->u.n.minargs - argc;
13168:                         if (regs.sp + nargs > fp->spbase + script->depth)
 4127:                             goto do_invoke;
 4127:                         do {
12579:                             PUSH(JSVAL_VOID);
 4127:                         } while (--nargs != 0);
 4127:                     }
 4127: 
11774:                     JS_ASSERT(JSVAL_IS_OBJECT(vp[1]) ||
 4127:                               PRIMITIVE_THIS_TEST(fun, vp[1]));
 4127: 
13702:                     ok = ((JSFastNative) fun->u.n.native)(cx, argc, vp);
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:                     if (VALUE_IS_FUNCTION(cx, lval)) {
 7058:                         if (JAVASCRIPT_FUNCTION_RVAL_ENABLED())
 7058:                             jsdtrace_function_rval(cx, fp, fun);
 7058:                         if (JAVASCRIPT_FUNCTION_RETURN_ENABLED())
 7058:                             jsdtrace_function_return(cx, fp, fun);
 7058:                     }
 7058: #endif
 4127:                     if (!ok)
11859:                         goto error;
13168:                     regs.sp = vp + 1;
 4127:                     goto end_call;
 4127:                 }
 4127:             }
 4127: 
 4127:           do_invoke:
 6040:             ok = js_Invoke(cx, argc, vp, 0);
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:             /* DTrace function return, non-inlines */
 7058:             if (VALUE_IS_FUNCTION(cx, lval)) {
 7058:                 if (JAVASCRIPT_FUNCTION_RVAL_ENABLED())
 7058:                     jsdtrace_function_rval(cx, fp, fun);
 7058:                 if (JAVASCRIPT_FUNCTION_RETURN_ENABLED())
 7058:                     jsdtrace_function_return(cx, fp, fun);
 7058:             }
 7058: #endif
13168:             regs.sp = vp + 1;
 2433:             LOAD_INTERRUPT_HANDLER(cx);
    1:             if (!ok)
11859:                 goto error;
    1:             JS_RUNTIME_METER(rt, nonInlineCalls);
 4127: 
 4127:           end_call:
    1: #if JS_HAS_LVALUE_RETURN
    1:             if (cx->rval2set) {
    1:                 /*
    1:                  * Use the stack depth we didn't claim in our budget, but that
    1:                  * we know is there on account of [fun, this] already having
    1:                  * been pushed, at a minimum (if no args).  Those two slots
    1:                  * have been popped and [rval] has been pushed, which leaves
    1:                  * one more slot for rval2 before we might overflow.
    1:                  *
    1:                  * NB: rval2 must be the property identifier, and rval the
    1:                  * object from which to get the property.  The pair form an
    1:                  * ECMA "reference type", which can be used on the right- or
    1:                  * left-hand side of assignment ops.  Note well: only native
    1:                  * methods can return reference types.  See JSOP_SETCALL just
    1:                  * below for the left-hand-side case.
    1:                  */
    1:                 PUSH_OPND(cx->rval2);
11859:                 ELEMENT_OP(-1, OBJ_GET_PROPERTY(cx, obj, id, &rval));
    1: 
13168:                 regs.sp--;
    1:                 STORE_OPND(-1, rval);
    1:                 cx->rval2set = JS_FALSE;
    1:             }
    1: #endif /* JS_HAS_LVALUE_RETURN */
    1:           END_CASE(JSOP_CALL)
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:           BEGIN_CASE(JSOP_SETCALL)
13168:             argc = GET_ARGC(regs.pc);
13168:             vp = regs.sp - argc - 2;
 6040:             ok = js_Invoke(cx, argc, vp, 0);
13168:             regs.sp = vp + 1;
 2433:             LOAD_INTERRUPT_HANDLER(cx);
    1:             if (!ok)
11859:                 goto error;
    1:             if (!cx->rval2set) {
13386:                 op2 = (JSOp) regs.pc[JSOP_SETCALL_LENGTH];
13288:                 if (op2 != JSOP_DELELEM) {
13288:                     JS_ASSERT(!(js_CodeSpec[op2].format & JOF_DEL));
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                          JSMSG_BAD_LEFTSIDE_OF_ASS);
11859:                     goto error;
    1:                 }
13288: 
13288:                 /*
13288:                  * Store true as the result of the emulated delete of a
13288:                  * non-existent property. NB: We don't METER_OP_PAIR here;
13288:                  * it doesn't seem worth the code for this obscure case.
13288:                  */
13288:                 *vp = JSVAL_TRUE;
13288:                 regs.pc += JSOP_SETCALL_LENGTH + JSOP_DELELEM_LENGTH;
13288:                 op = (JSOp) *regs.pc;
13288:                 DO_OP();
13288:             }
    1:             PUSH_OPND(cx->rval2);
    1:             cx->rval2set = JS_FALSE;
    1:           END_CASE(JSOP_SETCALL)
    1: #endif
    1: 
    1:           BEGIN_CASE(JSOP_NAME)
    1:           BEGIN_CASE(JSOP_CALLNAME)
11377:           {
11377:             JSPropCacheEntry *entry;
11377: 
11377:             obj = fp->scopeChain;
11832:             if (JS_LIKELY(OBJ_IS_NATIVE(obj))) {
13168:                 PROPERTY_CACHE_TEST(cx, regs.pc, obj, obj2, entry, atom);
11377:                 if (!atom) {
11377:                     ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
11377:                     if (PCVAL_IS_OBJECT(entry->vword)) {
11377:                         rval = PCVAL_OBJECT_TO_JSVAL(entry->vword);
11377:                         JS_UNLOCK_OBJ(cx, obj2);
11377:                         goto do_push_rval;
11377:                     }
11377: 
11377:                     if (PCVAL_IS_SLOT(entry->vword)) {
11377:                         slot = PCVAL_TO_SLOT(entry->vword);
11377:                         JS_ASSERT(slot < obj2->map->freeslot);
11377:                         rval = LOCKED_OBJ_GET_SLOT(obj2, slot);
11377:                         JS_UNLOCK_OBJ(cx, obj2);
11377:                         goto do_push_rval;
11377:                     }
11377: 
11377:                     JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
11377:                     sprop = PCVAL_TO_SPROP(entry->vword);
11377:                     goto do_native_get;
11377:                 }
11832:             } else {
11832:                 entry = NULL;
11832:                 LOAD_ATOM(0);
11832:             }
11377: 
    1:             id = ATOM_TO_JSID(atom);
11859:             if (js_FindPropertyHelper(cx, id, &obj, &obj2, &prop, &entry) < 0)
11859:                 goto error;
    1:             if (!prop) {
    1:                 /* Kludge to allow (typeof foo == "undefined") tests. */
    1:                 len = JSOP_NAME_LENGTH;
    1:                 endpc = script->code + script->length;
13168:                 for (pc2 = regs.pc + len; pc2 < endpc; pc2++) {
    1:                     op2 = (JSOp)*pc2;
    1:                     if (op2 == JSOP_TYPEOF) {
    1:                         PUSH_OPND(JSVAL_VOID);
    1:                         DO_NEXT_OP(len);
    1:                     }
    1:                     if (op2 != JSOP_GROUP)
    1:                         break;
    1:                 }
    1:                 goto atom_not_defined;
    1:             }
    1: 
    1:             /* Take the slow path if prop was not found in a native object. */
    1:             if (!OBJ_IS_NATIVE(obj) || !OBJ_IS_NATIVE(obj2)) {
    1:                 OBJ_DROP_PROPERTY(cx, obj2, prop);
11859:                 if (!OBJ_GET_PROPERTY(cx, obj, id, &rval))
11859:                     goto error;
11377:                 entry = NULL;
    1:             } else {
    1:                 sprop = (JSScopeProperty *)prop;
11377:           do_native_get:
    1:                 NATIVE_GET(cx, obj, obj2, sprop, &rval);
11377:                 OBJ_DROP_PROPERTY(cx, obj2, (JSProperty *) sprop);
11377:             }
11377: 
11377:           do_push_rval:
    1:             PUSH_OPND(rval);
12470:             if (op == JSOP_CALLNAME)
    1:                 PUSH_OPND(OBJECT_TO_JSVAL(obj));
11774:           }
    1:           END_CASE(JSOP_NAME)
    1: 
    1:           BEGIN_CASE(JSOP_UINT16)
13168:             i = (jsint) GET_UINT16(regs.pc);
    1:             rval = INT_TO_JSVAL(i);
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_UINT16)
    1: 
    1:           BEGIN_CASE(JSOP_UINT24)
13168:             i = (jsint) GET_UINT24(regs.pc);
    1:             rval = INT_TO_JSVAL(i);
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_UINT24)
    1: 
 3328:           BEGIN_CASE(JSOP_INT8)
13168:             i = GET_INT8(regs.pc);
 3328:             rval = INT_TO_JSVAL(i);
 3328:             PUSH_OPND(rval);
 3328:           END_CASE(JSOP_INT8)
 3328: 
 3328:           BEGIN_CASE(JSOP_INT32)
13168:             i = GET_INT32(regs.pc);
 3328:             rval = INT_TO_JSVAL(i);
 3328:             PUSH_OPND(rval);
 3328:           END_CASE(JSOP_INT32)
 3328: 
 3235:           BEGIN_CASE(JSOP_INDEXBASE)
 3235:             /*
 3235:              * Here atoms can exceed script->atomMap.length as we use atoms
 3235:              * as a segment register for object literals as well.
 3235:              */
13168:             atoms += GET_INDEXBASE(regs.pc);
 3235:           END_CASE(JSOP_INDEXBASE)
 3235: 
 3235:           BEGIN_CASE(JSOP_INDEXBASE1)
 3235:           BEGIN_CASE(JSOP_INDEXBASE2)
 3235:           BEGIN_CASE(JSOP_INDEXBASE3)
 3235:             atoms += (op - JSOP_INDEXBASE1 + 1) << 16;
 3235:           END_CASE(JSOP_INDEXBASE3)
    1: 
    1:           BEGIN_CASE(JSOP_RESETBASE0)
    1:           BEGIN_CASE(JSOP_RESETBASE)
    1:             atoms = script->atomMap.vector;
    1:           END_CASE(JSOP_RESETBASE)
    1: 
 3328:           BEGIN_CASE(JSOP_DOUBLE)
    1:           BEGIN_CASE(JSOP_STRING)
    1:             LOAD_ATOM(0);
    1:             PUSH_OPND(ATOM_KEY(atom));
 3328:           END_CASE(JSOP_DOUBLE)
    1: 
 3235:           BEGIN_CASE(JSOP_OBJECT)
 3235:             LOAD_OBJECT(0);
 3235:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
 3235:           END_CASE(JSOP_OBJECT)
 3235: 
    1:           BEGIN_CASE(JSOP_REGEXP)
    1:           {
    1:             JSObject *funobj;
    1: 
    1:             /*
    1:              * Push a regexp object for the atom mapped by the bytecode at pc,
    1:              * cloning the literal's regexp object if necessary, to simulate in
    1:              * the pre-compile/execute-later case what ECMA specifies for the
    1:              * compile-and-go case: that scanning each regexp literal creates
    1:              * a single corresponding RegExp object.
    1:              *
    1:              * To support pre-compilation transparently, we must handle the
    1:              * case where a regexp object literal is used in a different global
    1:              * at execution time from the global with which it was scanned at
    1:              * compile time.  We do this by re-wrapping the JSRegExp private
    1:              * data struct with a cloned object having the right prototype and
    1:              * parent, and having its own lastIndex property value storage.
    1:              *
    1:              * Unlike JSOP_DEFFUN and other prolog bytecodes that may clone
    1:              * literal objects, we don't want to pay a script prolog execution
    1:              * price for all regexp literals in a script (many may not be used
    1:              * by a particular execution of that script, depending on control
    1:              * flow), so we initialize lazily here.
    1:              *
    1:              * XXX This code is specific to regular expression objects.  If we
    1:              * need a similar op for other kinds of object literals, we should
    1:              * push cloning down under JSObjectOps and reuse code here.
    1:              */
 3235:             index = GET_FULL_INDEX(0);
 3235:             JS_ASSERT(index < JS_SCRIPT_REGEXPS(script)->length);
 3235: 
 3235:             slot = index;
    1:             if (fp->fun) {
    1:                 /*
    1:                  * We're in function code, not global or eval code (in eval
 3235:                  * code, JSOP_REGEXP is never emitted). The cloned funobj
 3235:                  * contains script->regexps->nregexps reserved slot for the
 3235:                  * cloned regexps, see fun_reserveSlots, jsfun.c.
    1:                  */
 4127:                 funobj = fp->callee;
    1:                 slot += JSCLASS_RESERVED_SLOTS(&js_FunctionClass);
    1:                 if (!JS_GetReservedSlot(cx, funobj, slot, &rval))
    1:                     return JS_FALSE;
    1:                 if (JSVAL_IS_VOID(rval))
    1:                     rval = JSVAL_NULL;
    1:             } else {
    1:                 /*
    1:                  * We're in global code.  The code generator already arranged
 3235:                  * via script->nregexps to reserve a global variable slot
    1:                  * at cloneIndex.  All global variable slots are initialized
    1:                  * to null, not void, for faster testing in JSOP_*GVAR cases.
    1:                  */
 3235:                 slot += script->ngvars;
    1:                 rval = fp->vars[slot];
    1: #ifdef __GNUC__
    1:                 funobj = NULL;  /* suppress bogus gcc warnings */
    1: #endif
    1:             }
    1: 
    1:             if (JSVAL_IS_NULL(rval)) {
    1:                 /* Compute the current global object in obj2. */
    1:                 obj2 = fp->scopeChain;
    1:                 while ((parent = OBJ_GET_PARENT(cx, obj2)) != NULL)
    1:                     obj2 = parent;
    1: 
    1:                 /*
    1:                  * If obj's parent is not obj2, we must clone obj so that it
    1:                  * has the right parent, and therefore, the right prototype.
    1:                  *
    1:                  * Yes, this means we assume that the correct RegExp.prototype
    1:                  * to which regexp instances (including literals) delegate can
    1:                  * be distinguished solely by the instance's parent, which was
    1:                  * set to the parent of the RegExp constructor function object
    1:                  * when the instance was created.  In other words,
    1:                  *
    1:                  *   (/x/.__parent__ == RegExp.__parent__) implies
    1:                  *   (/x/.__proto__ == RegExp.prototype)
    1:                  *
    1:                  * (unless you assign a different object to RegExp.prototype
    1:                  * at runtime, in which case, ECMA doesn't specify operation,
    1:                  * and you get what you deserve).
    1:                  *
    1:                  * This same coupling between instance parent and constructor
    1:                  * parent turns up everywhere (see jsobj.c's FindClassObject,
    1:                  * js_ConstructObject, and js_NewObject).  It's fundamental to
    1:                  * the design of the language when you consider multiple global
    1:                  * objects and separate compilation and execution, even though
    1:                  * it is not specified fully in ECMA.
    1:                  */
 3235:                 JS_GET_SCRIPT_REGEXP(script, index, obj);
    1:                 if (OBJ_GET_PARENT(cx, obj) != obj2) {
    1:                     obj = js_CloneRegExpObject(cx, obj, obj2);
11859:                     if (!obj)
11859:                         goto error;
    1:                 }
    1:                 rval = OBJECT_TO_JSVAL(obj);
    1: 
    1:                 /* Store the regexp object value in its cloneIndex slot. */
    1:                 if (fp->fun) {
    1:                     if (!JS_SetReservedSlot(cx, funobj, slot, rval))
    1:                         return JS_FALSE;
    1:                 } else {
    1:                     fp->vars[slot] = rval;
    1:                 }
    1:             }
    1: 
    1:             PUSH_OPND(rval);
    1:           }
    1:           END_CASE(JSOP_REGEXP)
    1: 
    1:           BEGIN_CASE(JSOP_ZERO)
    1:             PUSH_OPND(JSVAL_ZERO);
    1:           END_CASE(JSOP_ZERO)
    1: 
    1:           BEGIN_CASE(JSOP_ONE)
    1:             PUSH_OPND(JSVAL_ONE);
    1:           END_CASE(JSOP_ONE)
    1: 
    1:           BEGIN_CASE(JSOP_NULL)
    1:             PUSH_OPND(JSVAL_NULL);
    1:           END_CASE(JSOP_NULL)
    1: 
    1:           BEGIN_CASE(JSOP_FALSE)
    1:             PUSH_OPND(JSVAL_FALSE);
    1:           END_CASE(JSOP_FALSE)
    1: 
    1:           BEGIN_CASE(JSOP_TRUE)
    1:             PUSH_OPND(JSVAL_TRUE);
    1:           END_CASE(JSOP_TRUE)
    1: 
    1:           BEGIN_CASE(JSOP_TABLESWITCH)
13168:             pc2 = regs.pc;
    1:             len = GET_JUMP_OFFSET(pc2);
    1: 
    1:             /*
    1:              * ECMAv2+ forbids conversion of discriminant, so we will skip to
    1:              * the default case if the discriminant isn't already an int jsval.
    1:              * (This opcode is emitted only for dense jsint-domain switches.)
    1:              */
    1:             rval = POP_OPND();
    1:             if (!JSVAL_IS_INT(rval))
    1:                 DO_NEXT_OP(len);
    1:             i = JSVAL_TO_INT(rval);
    1: 
    1:             pc2 += JUMP_OFFSET_LEN;
    1:             low = GET_JUMP_OFFSET(pc2);
    1:             pc2 += JUMP_OFFSET_LEN;
    1:             high = GET_JUMP_OFFSET(pc2);
    1: 
    1:             i -= low;
    1:             if ((jsuint)i < (jsuint)(high - low + 1)) {
    1:                 pc2 += JUMP_OFFSET_LEN + JUMP_OFFSET_LEN * i;
    1:                 off = (jsint) GET_JUMP_OFFSET(pc2);
    1:                 if (off)
    1:                     len = off;
    1:             }
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_TABLESWITCHX)
13168:             pc2 = regs.pc;
    1:             len = GET_JUMPX_OFFSET(pc2);
    1: 
    1:             /*
    1:              * ECMAv2+ forbids conversion of discriminant, so we will skip to
    1:              * the default case if the discriminant isn't already an int jsval.
    1:              * (This opcode is emitted only for dense jsint-domain switches.)
    1:              */
    1:             rval = POP_OPND();
    1:             if (!JSVAL_IS_INT(rval))
    1:                 DO_NEXT_OP(len);
    1:             i = JSVAL_TO_INT(rval);
    1: 
    1:             pc2 += JUMPX_OFFSET_LEN;
    1:             low = GET_JUMP_OFFSET(pc2);
    1:             pc2 += JUMP_OFFSET_LEN;
    1:             high = GET_JUMP_OFFSET(pc2);
    1: 
    1:             i -= low;
    1:             if ((jsuint)i < (jsuint)(high - low + 1)) {
    1:                 pc2 += JUMP_OFFSET_LEN + JUMPX_OFFSET_LEN * i;
    1:                 off = (jsint) GET_JUMPX_OFFSET(pc2);
    1:                 if (off)
    1:                     len = off;
    1:             }
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_LOOKUPSWITCHX)
    1:             off = JUMPX_OFFSET_LEN;
    1:             goto do_lookup_switch;
    1: 
    1:           BEGIN_CASE(JSOP_LOOKUPSWITCH)
    1:             off = JUMP_OFFSET_LEN;
    1: 
    1:           do_lookup_switch:
 3235:             /*
 3235:              * JSOP_LOOKUPSWITCH and JSOP_LOOKUPSWITCHX are never used if
 3235:              * any atom index in it would exceed 64K limit.
 3235:              */
 3235:             JS_ASSERT(atoms == script->atomMap.vector);
13168:             pc2 = regs.pc;
    1:             lval = POP_OPND();
    1: 
    1:             if (!JSVAL_IS_NUMBER(lval) &&
    1:                 !JSVAL_IS_STRING(lval) &&
    1:                 !JSVAL_IS_BOOLEAN(lval)) {
    1:                 goto end_lookup_switch;
    1:             }
    1: 
    1:             pc2 += off;
    1:             npairs = (jsint) GET_UINT16(pc2);
    1:             pc2 += UINT16_LEN;
    1:             JS_ASSERT(npairs);  /* empty switch uses JSOP_TABLESWITCH */
    1: 
    1: #define SEARCH_PAIRS(MATCH_CODE)                                              \
    1:     for (;;) {                                                                \
 3235:         JS_ASSERT(GET_INDEX(pc2) < script->atomMap.length);                   \
 3235:         atom = atoms[GET_INDEX(pc2)];                                         \
    1:         rval = ATOM_KEY(atom);                                                \
    1:         MATCH_CODE                                                            \
 3235:         pc2 += INDEX_LEN;                                                     \
    1:         if (match)                                                            \
    1:             break;                                                            \
    1:         pc2 += off;                                                           \
    1:         if (--npairs == 0) {                                                  \
13168:             pc2 = regs.pc;                                                    \
    1:             break;                                                            \
    1:         }                                                                     \
    1:     }
    1:             if (JSVAL_IS_STRING(lval)) {
    1:                 str = JSVAL_TO_STRING(lval);
    1:                 SEARCH_PAIRS(
    1:                     match = (JSVAL_IS_STRING(rval) &&
    1:                              ((str2 = JSVAL_TO_STRING(rval)) == str ||
    1:                               js_EqualStrings(str2, str)));
    1:                 )
    1:             } else if (JSVAL_IS_DOUBLE(lval)) {
    1:                 d = *JSVAL_TO_DOUBLE(lval);
    1:                 SEARCH_PAIRS(
    1:                     match = (JSVAL_IS_DOUBLE(rval) &&
    1:                              *JSVAL_TO_DOUBLE(rval) == d);
    1:                 )
    1:             } else {
    1:                 SEARCH_PAIRS(
    1:                     match = (lval == rval);
    1:                 )
    1:             }
    1: #undef SEARCH_PAIRS
    1: 
    1:           end_lookup_switch:
    1:             len = (op == JSOP_LOOKUPSWITCH)
    1:                   ? GET_JUMP_OFFSET(pc2)
    1:                   : GET_JUMPX_OFFSET(pc2);
    1:           END_VARLEN_CASE
    1: 
    1:           EMPTY_CASE(JSOP_CONDSWITCH)
    1: 
    1: #if JS_HAS_EXPORT_IMPORT
    1:           BEGIN_CASE(JSOP_EXPORTALL)
    1:             obj = fp->varobj;
    1:             ida = JS_Enumerate(cx, obj);
11859:             if (!ida)
11859:                 goto error;
11964:             ok = JS_TRUE;
11859:             for (i = 0; i != ida->length; i++) {
    1:                 id = ida->vector[i];
11964:                 ok = OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop);
11964:                 if (!ok)
    1:                     break;
    1:                 if (!prop)
    1:                     continue;
    1:                 ok = OBJ_GET_ATTRIBUTES(cx, obj, id, prop, &attrs);
    1:                 if (ok) {
    1:                     attrs |= JSPROP_EXPORTED;
    1:                     ok = OBJ_SET_ATTRIBUTES(cx, obj, id, prop, &attrs);
    1:                 }
    1:                 OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:                 if (!ok)
    1:                     break;
    1:             }
11964:             JS_ASSERT(ok == (i == ida->length));
    1:             JS_DestroyIdArray(cx, ida);
11964:             if (!ok)
11859:                 goto error;
    1:           END_CASE(JSOP_EXPORTALL)
    1: 
    1:           BEGIN_CASE(JSOP_EXPORTNAME)
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
    1:             obj = fp->varobj;
11859:             if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop))
11859:                 goto error;
    1:             if (!prop) {
11859:                 if (!OBJ_DEFINE_PROPERTY(cx, obj, id, JSVAL_VOID,
11819:                                          JS_PropertyStub, JS_PropertyStub,
11859:                                          JSPROP_EXPORTED, NULL)) {
11859:                     goto error;
11859:                 }
    1:             } else {
    1:                 ok = OBJ_GET_ATTRIBUTES(cx, obj, id, prop, &attrs);
    1:                 if (ok) {
    1:                     attrs |= JSPROP_EXPORTED;
    1:                     ok = OBJ_SET_ATTRIBUTES(cx, obj, id, prop, &attrs);
    1:                 }
    1:                 OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:                 if (!ok)
11859:                     goto error;
11859:             }
    1:           END_CASE(JSOP_EXPORTNAME)
    1: 
    1:           BEGIN_CASE(JSOP_IMPORTALL)
    1:             id = (jsid) JSVAL_VOID;
12551:             PROPERTY_OP(-1, js_ImportProperty(cx, obj, id));
13168:             regs.sp--;
    1:           END_CASE(JSOP_IMPORTALL)
    1: 
    1:           BEGIN_CASE(JSOP_IMPORTPROP)
    1:             /* Get an immediate atom naming the property. */
    1:             LOAD_ATOM(0);
    1:             id = ATOM_TO_JSID(atom);
12551:             PROPERTY_OP(-1, js_ImportProperty(cx, obj, id));
13168:             regs.sp--;
    1:           END_CASE(JSOP_IMPORTPROP)
    1: 
    1:           BEGIN_CASE(JSOP_IMPORTELEM)
12551:             ELEMENT_OP(-1, js_ImportProperty(cx, obj, id));
13168:             regs.sp -= 2;
    1:           END_CASE(JSOP_IMPORTELEM)
    1: #endif /* JS_HAS_EXPORT_IMPORT */
    1: 
    1:           BEGIN_CASE(JSOP_TRAP)
13168:             switch (JS_HandleTrap(cx, script, regs.pc, &rval)) {
    1:               case JSTRAP_ERROR:
11859:                 goto error;
    1:               case JSTRAP_CONTINUE:
    1:                 JS_ASSERT(JSVAL_IS_INT(rval));
    1:                 op = (JSOp) JSVAL_TO_INT(rval);
    1:                 JS_ASSERT((uintN)op < (uintN)JSOP_LIMIT);
 2433:                 LOAD_INTERRUPT_HANDLER(cx);
    1:                 DO_OP();
    1:               case JSTRAP_RETURN:
    1:                 fp->rval = rval;
11859:                 ok = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
    1:                 cx->throwing = JS_TRUE;
    1:                 cx->exception = rval;
11859:                 goto error;
    1:               default:;
    1:             }
 2433:             LOAD_INTERRUPT_HANDLER(cx);
    1:           END_CASE(JSOP_TRAP)
    1: 
    1:           BEGIN_CASE(JSOP_ARGUMENTS)
11859:             if (!js_GetArgsValue(cx, fp, &rval))
11859:                 goto error;
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_ARGUMENTS)
    1: 
    1:           BEGIN_CASE(JSOP_ARGSUB)
13168:             id = INT_TO_JSID(GET_ARGNO(regs.pc));
11859:             if (!js_GetArgsProperty(cx, fp, id, &rval))
11859:                 goto error;
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_ARGSUB)
    1: 
    1:           BEGIN_CASE(JSOP_ARGCNT)
    1:             id = ATOM_TO_JSID(rt->atomState.lengthAtom);
11859:             if (!js_GetArgsProperty(cx, fp, id, &rval))
11859:                 goto error;
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_ARGCNT)
    1: 
    1:           BEGIN_CASE(JSOP_GETARG)
    1:           BEGIN_CASE(JSOP_CALLARG)
13168:             slot = GET_ARGNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->nargs);
    1:             METER_SLOT_OP(op, slot);
    1:             PUSH_OPND(fp->argv[slot]);
    1:             if (op == JSOP_CALLARG)
11774:                 PUSH_OPND(JSVAL_NULL);
    1:           END_CASE(JSOP_GETARG)
    1: 
    1:           BEGIN_CASE(JSOP_SETARG)
13168:             slot = GET_ARGNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->nargs);
    1:             METER_SLOT_OP(op, slot);
    1:             vp = &fp->argv[slot];
    1:             GC_POKE(cx, *vp);
    1:             *vp = FETCH_OPND(-1);
    1:           END_CASE(JSOP_SETARG)
    1: 
    1:           BEGIN_CASE(JSOP_GETVAR)
    1:           BEGIN_CASE(JSOP_CALLVAR)
13168:             slot = GET_VARNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->u.i.nvars);
    1:             METER_SLOT_OP(op, slot);
    1:             PUSH_OPND(fp->vars[slot]);
    1:             if (op == JSOP_CALLVAR)
11774:                 PUSH_OPND(JSVAL_NULL);
    1:           END_CASE(JSOP_GETVAR)
    1: 
    1:           BEGIN_CASE(JSOP_SETVAR)
13168:             slot = GET_VARNO(regs.pc);
13702:             JS_ASSERT(slot < fp->fun->u.i.nvars);
    1:             METER_SLOT_OP(op, slot);
    1:             vp = &fp->vars[slot];
    1:             GC_POKE(cx, *vp);
    1:             *vp = FETCH_OPND(-1);
    1:           END_CASE(JSOP_SETVAR)
    1: 
    1:           BEGIN_CASE(JSOP_GETGVAR)
    1:           BEGIN_CASE(JSOP_CALLGVAR)
13168:             slot = GET_VARNO(regs.pc);
    1:             JS_ASSERT(slot < fp->nvars);
    1:             METER_SLOT_OP(op, slot);
    1:             lval = fp->vars[slot];
    1:             if (JSVAL_IS_NULL(lval)) {
    1:                 op = (op == JSOP_GETGVAR) ? JSOP_NAME : JSOP_CALLNAME;
    1:                 DO_OP();
    1:             }
    1:             slot = JSVAL_TO_INT(lval);
    1:             obj = fp->varobj;
    1:             rval = OBJ_GET_SLOT(cx, obj, slot);
    1:             PUSH_OPND(rval);
    1:             if (op == JSOP_CALLGVAR)
    1:                 PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_GETGVAR)
    1: 
    1:           BEGIN_CASE(JSOP_SETGVAR)
13168:             slot = GET_VARNO(regs.pc);
    1:             JS_ASSERT(slot < fp->nvars);
    1:             METER_SLOT_OP(op, slot);
    1:             rval = FETCH_OPND(-1);
    1:             lval = fp->vars[slot];
    1:             obj = fp->varobj;
    1:             if (JSVAL_IS_NULL(lval)) {
    1:                 /*
11377:                  * Inline-clone and deoptimize JSOP_SETNAME code here because
    1:                  * JSOP_SETGVAR has arity 1: [rval], not arity 2: [obj, rval]
    1:                  * as JSOP_SETNAME does, where [obj] is due to JSOP_BINDNAME.
    1:                  */
    1:                 LOAD_ATOM(0);
    1:                 id = ATOM_TO_JSID(atom);
11859:                 if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
11859:                     goto error;
    1:                 STORE_OPND(-1, rval);
    1:             } else {
    1:                 slot = JSVAL_TO_INT(lval);
11377:                 JS_LOCK_OBJ(cx, obj);
11377:                 LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, rval);
11377:                 JS_UNLOCK_OBJ(cx, obj);
    1:             }
    1:           END_CASE(JSOP_SETGVAR)
    1: 
    1:           BEGIN_CASE(JSOP_DEFCONST)
    1:           BEGIN_CASE(JSOP_DEFVAR)
13168:             index = GET_INDEX(regs.pc);
 3235:             atom = atoms[index];
 3235: 
 3235:             /*
 3235:              * index is relative to atoms at this point but for global var
 3235:              * code below we need the absolute value.
 3235:              */
 3235:             index += atoms - script->atomMap.vector;
    1:             obj = fp->varobj;
    1:             attrs = JSPROP_ENUMERATE;
    1:             if (!(fp->flags & JSFRAME_EVAL))
    1:                 attrs |= JSPROP_PERMANENT;
    1:             if (op == JSOP_DEFCONST)
    1:                 attrs |= JSPROP_READONLY;
    1: 
    1:             /* Lookup id in order to check for redeclaration problems. */
    1:             id = ATOM_TO_JSID(atom);
11859:             if (!js_CheckRedeclaration(cx, obj, id, attrs, &obj2, &prop))
11859:                 goto error;
    1: 
    1:             /* Bind a variable only if it's not yet defined. */
    1:             if (!prop) {
11859:                 if (!OBJ_DEFINE_PROPERTY(cx, obj, id, JSVAL_VOID,
11819:                                          JS_PropertyStub, JS_PropertyStub,
11859:                                          attrs, &prop)) {
11859:                     goto error;
11859:                 }
    1:                 JS_ASSERT(prop);
    1:                 obj2 = obj;
    1:             }
    1: 
    1:             /*
    1:              * Try to optimize a property we either just created, or found
    1:              * directly in the global object, that is permanent, has a slot,
    1:              * and has stub getter and setter, into a "fast global" accessed
    1:              * by the JSOP_*GVAR opcodes.
    1:              */
 3235:             if (index < script->ngvars &&
    1:                 (attrs & JSPROP_PERMANENT) &&
    1:                 obj2 == obj &&
    1:                 OBJ_IS_NATIVE(obj)) {
    1:                 sprop = (JSScopeProperty *) prop;
    1:                 if (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj)) &&
    1:                     SPROP_HAS_STUB_GETTER(sprop) &&
    1:                     SPROP_HAS_STUB_SETTER(sprop)) {
    1:                     /*
    1:                      * Fast globals use fp->vars to map the global name's
 3235:                      * atom index to the permanent fp->varobj slot number,
 3235:                      * tagged as a jsval.  The atom index for the global's
    1:                      * name literal is identical to its fp->vars index.
    1:                      */
 3235:                     fp->vars[index] = INT_TO_JSVAL(sprop->slot);
    1:                 }
    1:             }
    1: 
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:           END_CASE(JSOP_DEFVAR)
    1: 
    1:           BEGIN_CASE(JSOP_DEFFUN)
 3235:             LOAD_FUNCTION(0);
    1: 
    1:             /*
    1:              * We must be at top-level (either outermost block that forms a
    1:              * function's body, or a global) scope, not inside an expression
    1:              * (JSOP_{ANON,NAMED}FUNOBJ) or compound statement (JSOP_CLOSURE)
 8899:              * in the same compilation unit (ECMA Program). We also not inside
 8899:              * an eval script.
    1:              *
    1:              * If static link is not current scope, clone fun's object to link
    1:              * to the current scope via parent.  This clause exists to enable
    1:              * sharing of compiled functions among multiple equivalent scopes,
    1:              * splitting the cost of compilation evenly among the scopes and
    1:              * amortizing it over a number of executions.  Examples include XUL
    1:              * scripts and event handlers shared among Mozilla chrome windows,
    1:              * and server-side JS user-defined functions shared among requests.
    1:              *
    1:              * NB: The Script object exposes compile and exec in the language,
    1:              * such that this clause introduces an incompatible change from old
    1:              * JS versions that supported Script.  Such a JS version supported
    1:              * executing a script that defined and called functions scoped by
    1:              * the compile-time static link, not by the exec-time scope chain.
    1:              *
    1:              * We sacrifice compatibility, breaking such scripts, in order to
    1:              * promote compile-cost sharing and amortizing, and because Script
    1:              * is not and will not be standardized.
    1:              */
    1:             JS_ASSERT(!fp->blockChain);
 8899:             JS_ASSERT((fp->flags & JSFRAME_EVAL) == 0);
 8899:             JS_ASSERT(fp->scopeChain == fp->varobj);
    1:             obj2 = fp->scopeChain;
 8899: 
 8899:             /*
 8899:              * ECMA requires functions defined when entering Global code to be
 8899:              * permanent.
 8899:              */
 8899:             attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT;
 8899: 
 8899:           do_deffun:
13014:             /*
13168:              * The common code for JSOP_DEFFUN and JSOP_CLOSURE.
13168:              *
 8899:              * Clone the function object with the current scope chain as the
 8899:              * clone's parent.  The original function object is the prototype
 8899:              * of the clone.  Do this only if re-parenting; the compiler may
 8899:              * have seen the right parent already and created a sufficiently
 8899:              * well-scoped function object.
 8899:              */
13824:             obj = FUN_OBJECT(fun);
    1:             if (OBJ_GET_PARENT(cx, obj) != obj2) {
13824:                 obj = js_CloneFunctionObject(cx, fun, obj2);
11859:                 if (!obj)
11859:                     goto error;
    1:             }
    1: 
    1:             /*
    1:              * Protect obj from any GC hiding below OBJ_DEFINE_PROPERTY.  All
    1:              * paths from here must flow through the "Restore fp->scopeChain"
    1:              * code below the OBJ_DEFINE_PROPERTY call.
    1:              */
    1:             fp->scopeChain = obj;
    1:             rval = OBJECT_TO_JSVAL(obj);
    1: 
    1:             /*
    1:              * Load function flags that are also property attributes.  Getters
    1:              * and setters do not need a slot, their value is stored elsewhere
    1:              * in the property itself, not in obj slots.
    1:              */
13702:             flags = JSFUN_GSFLAG2ATTR(fun->flags);
    1:             if (flags) {
    1:                 attrs |= flags | JSPROP_SHARED;
    1:                 rval = JSVAL_VOID;
    1:             }
    1: 
    1:             /*
 8899:              * We define the function as a property of the variable object and
 8899:              * not the current scope chain even for the case of function
 8899:              * expression statements and functions defined by eval inside let
 8899:              * or with blocks.
 8899:              */
 8899:             parent = fp->varobj;
 8899: 
 8899:             /*
    1:              * Check for a const property of the same name -- or any kind
    1:              * of property if executing with the strict option.  We check
    1:              * here at runtime as well as at compile-time, to handle eval
    1:              * as well as multiple HTML script tags.
    1:              */
13702:             id = ATOM_TO_JSID(fun->atom);
    1:             ok = js_CheckRedeclaration(cx, parent, id, attrs, NULL, NULL);
    1:             if (ok) {
 8899:                 if (attrs == JSPROP_ENUMERATE) {
 8899:                     JS_ASSERT(fp->flags & JSFRAME_EVAL);
 8899:                     JS_ASSERT(op == JSOP_CLOSURE);
 8899:                     ok = OBJ_SET_PROPERTY(cx, parent, id, &rval);
 8899:                 } else {
    1:                     ok = OBJ_DEFINE_PROPERTY(cx, parent, id, rval,
    1:                                              (flags & JSPROP_GETTER)
    1:                                              ? JS_EXTENSION (JSPropertyOp) obj
11819:                                              : JS_PropertyStub,
    1:                                              (flags & JSPROP_SETTER)
    1:                                              ? JS_EXTENSION (JSPropertyOp) obj
11819:                                              : JS_PropertyStub,
    1:                                              attrs,
 8899:                                              NULL);
 8899:                 }
    1:             }
    1: 
    1:             /* Restore fp->scopeChain now that obj is defined in fp->varobj. */
    1:             fp->scopeChain = obj2;
 8899:             if (!ok) {
 8899:                 cx->weakRoots.newborn[GCX_OBJECT] = NULL;
11859:                 goto error;
 8899:             }
    1:           END_CASE(JSOP_DEFFUN)
    1: 
    1:           BEGIN_CASE(JSOP_DEFLOCALFUN)
 3235:             LOAD_FUNCTION(VARNO_LEN);
 3235: 
    1:             /*
    1:              * Define a local function (i.e., one nested at the top level of
    1:              * another function), parented by the current scope chain, and
    1:              * stored in a local variable slot that the compiler allocated.
    1:              * This is an optimization over JSOP_DEFFUN that avoids requiring
    1:              * a call object for the outer function's activation.
    1:              */
13168:             slot = GET_VARNO(regs.pc);
    1: 
    1:             parent = js_GetScopeChain(cx, fp);
11859:             if (!parent)
11859:                 goto error;
10466: 
13824:             obj = js_CloneFunctionObject(cx, fun, parent);
11859:             if (!obj)
11859:                 goto error;
    1: 
    1:             fp->vars[slot] = OBJECT_TO_JSVAL(obj);
    1:           END_CASE(JSOP_DEFLOCALFUN)
    1: 
    1:           BEGIN_CASE(JSOP_ANONFUNOBJ)
 3235:             /* Load the specified function object literal. */
 3235:             LOAD_FUNCTION(0);
    1: 
    1:             /* If re-parenting, push a clone of the function object. */
    1:             parent = js_GetScopeChain(cx, fp);
11859:             if (!parent)
11859:                 goto error;
13824:             obj = FUN_OBJECT(fun);
    1:             if (OBJ_GET_PARENT(cx, obj) != parent) {
13824:                 obj = js_CloneFunctionObject(cx, fun, parent);
11859:                 if (!obj)
11859:                     goto error;
    1:             }
    1:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_ANONFUNOBJ)
    1: 
    1:           BEGIN_CASE(JSOP_NAMEDFUNOBJ)
 3235:             LOAD_FUNCTION(0);
    1: 
    1:             /*
13824:              * ECMA ed. 3 FunctionExpression: function Identifier [etc.].
13824:              *
    1:              * 1. Create a new object as if by the expression new Object().
    1:              * 2. Add Result(1) to the front of the scope chain.
    1:              *
    1:              * Step 2 is achieved by making the new object's parent be the
    1:              * current scope chain, and then making the new object the parent
    1:              * of the Function object clone.
    1:              */
    1:             obj2 = js_GetScopeChain(cx, fp);
11859:             if (!obj2)
11859:                 goto error;
13824:             parent = js_NewObject(cx, &js_ObjectClass, NULL, obj2, 0);
11859:             if (!parent)
11859:                 goto error;
    1: 
    1:             /*
    1:              * 3. Create a new Function object as specified in section 13.2
    1:              * with [parameters and body specified by the function expression
    1:              * that was parsed by the compiler into a Function object, and
    1:              * saved in the script's atom map].
    1:              *
13824:              * Protect parent from the GC.
    1:              */
    1:             fp->scopeChain = parent;
13824:             obj = js_CloneFunctionObject(cx, fun, parent);
11859:             if (!obj)
11859:                 goto error;
    1: 
    1:             /*
    1:              * Protect obj from any GC hiding below OBJ_DEFINE_PROPERTY.  All
    1:              * paths from here must flow through the "Restore fp->scopeChain"
    1:              * code below the OBJ_DEFINE_PROPERTY call.
    1:              */
    1:             fp->scopeChain = obj;
    1:             rval = OBJECT_TO_JSVAL(obj);
    1: 
    1:             /*
    1:              * 4. Create a property in the object Result(1).  The property's
13702:              * name is [fun->atom, the identifier parsed by the compiler],
    1:              * value is Result(3), and attributes are { DontDelete, ReadOnly }.
    1:              */
13702:             attrs = JSFUN_GSFLAG2ATTR(fun->flags);
    1:             if (attrs) {
    1:                 attrs |= JSPROP_SHARED;
    1:                 rval = JSVAL_VOID;
    1:             }
13702:             ok = OBJ_DEFINE_PROPERTY(cx, parent, ATOM_TO_JSID(fun->atom), rval,
    1:                                      (attrs & JSPROP_GETTER)
    1:                                      ? JS_EXTENSION (JSPropertyOp) obj
11819:                                      : JS_PropertyStub,
    1:                                      (attrs & JSPROP_SETTER)
    1:                                      ? JS_EXTENSION (JSPropertyOp) obj
11819:                                      : JS_PropertyStub,
    1:                                      attrs |
    1:                                      JSPROP_ENUMERATE | JSPROP_PERMANENT |
    1:                                      JSPROP_READONLY,
    1:                                      NULL);
    1: 
    1:             /* Restore fp->scopeChain now that obj is defined in parent. */
    1:             fp->scopeChain = obj2;
    1:             if (!ok) {
    1:                 cx->weakRoots.newborn[GCX_OBJECT] = NULL;
11859:                 goto error;
    1:             }
    1: 
    1:             /*
    1:              * 5. Remove Result(1) from the front of the scope chain [no-op].
    1:              * 6. Return Result(3).
    1:              */
    1:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_NAMEDFUNOBJ)
    1: 
    1:           BEGIN_CASE(JSOP_CLOSURE)
    1:             /*
 8899:              * A top-level function inside eval or ECMA ed. 3 extension: a
 8899:              * named function expression statement in a compound statement
 8899:              * (not at the top statement level of global code, or at the top
 8899:              * level of a function body).
    1:              */
 3235:             LOAD_FUNCTION(0);
    1: 
    1:             /*
    1:              * Clone the function object with the current scope chain as the
 9481:              * clone's parent. Do this only if re-parenting; the compiler may
    1:              * have seen the right parent already and created a sufficiently
    1:              * well-scoped function object.
    1:              */
    1:             obj2 = js_GetScopeChain(cx, fp);
11859:             if (!obj2)
11859:                 goto error;
    1: 
    1:             /*
 8899:              * ECMA requires that functions defined when entering Eval code to
 8899:              * be impermanent.
    1:              */
 8899:             attrs = JSPROP_ENUMERATE;
 8899:             if (!(fp->flags & JSFRAME_EVAL))
 8899:                 attrs |= JSPROP_PERMANENT;
 8899: 
 8899:             goto do_deffun;
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:           BEGIN_CASE(JSOP_GETTER)
    1:           BEGIN_CASE(JSOP_SETTER)
    1:           do_getter_setter:
13168:             op2 = (JSOp) *++regs.pc;
    1:             switch (op2) {
 3235:               case JSOP_INDEXBASE:
13168:                 atoms += GET_INDEXBASE(regs.pc);
13168:                 regs.pc += JSOP_INDEXBASE_LENGTH - 1;
    1:                 goto do_getter_setter;
 3235:               case JSOP_INDEXBASE1:
 3235:               case JSOP_INDEXBASE2:
 3235:               case JSOP_INDEXBASE3:
 3235:                 atoms += (op2 - JSOP_INDEXBASE1 + 1) << 16;
    1:                 goto do_getter_setter;
    1: 
    1:               case JSOP_SETNAME:
    1:               case JSOP_SETPROP:
    1:                 LOAD_ATOM(0);
    1:                 id = ATOM_TO_JSID(atom);
    1:                 rval = FETCH_OPND(-1);
    1:                 i = -1;
    1:                 goto gs_pop_lval;
    1: 
    1:               case JSOP_SETELEM:
    1:                 rval = FETCH_OPND(-1);
    1:                 id = 0;
    1:                 i = -2;
    1:               gs_pop_lval:
    1:                 FETCH_OBJECT(cx, i - 1, lval, obj);
    1:                 break;
    1: 
    1:               case JSOP_INITPROP:
13168:                 JS_ASSERT(regs.sp - fp->spbase >= 2);
    1:                 rval = FETCH_OPND(-1);
    1:                 i = -1;
    1:                 LOAD_ATOM(0);
    1:                 id = ATOM_TO_JSID(atom);
    1:                 goto gs_get_lval;
    1: 
11720:               default:
11720:                 JS_ASSERT(op2 == JSOP_INITELEM);
11720: 
13168:                 JS_ASSERT(regs.sp - fp->spbase >= 3);
    1:                 rval = FETCH_OPND(-1);
    1:                 id = 0;
    1:                 i = -2;
    1:               gs_get_lval:
    1:                 lval = FETCH_OPND(i-1);
    1:                 JS_ASSERT(JSVAL_IS_OBJECT(lval));
    1:                 obj = JSVAL_TO_OBJECT(lval);
    1:                 break;
    1:             }
    1: 
    1:             /* Ensure that id has a type suitable for use with obj. */
    1:             if (id == 0)
    1:                 FETCH_ELEMENT_ID(obj, i, id);
    1: 
    1:             if (JS_TypeOfValue(cx, rval) != JSTYPE_FUNCTION) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_GETTER_OR_SETTER,
    1:                                      (op == JSOP_GETTER)
    1:                                      ? js_getter_str
    1:                                      : js_setter_str);
11859:                 goto error;
    1:             }
    1: 
    1:             /*
    1:              * Getters and setters are just like watchpoints from an access
    1:              * control point of view.
    1:              */
11859:             if (!OBJ_CHECK_ACCESS(cx, obj, id, JSACC_WATCH, &rtmp, &attrs))
11859:                 goto error;
    1: 
    1:             if (op == JSOP_GETTER) {
    1:                 getter = JS_EXTENSION (JSPropertyOp) JSVAL_TO_OBJECT(rval);
11819:                 setter = JS_PropertyStub;
    1:                 attrs = JSPROP_GETTER;
    1:             } else {
11819:                 getter = JS_PropertyStub;
    1:                 setter = JS_EXTENSION (JSPropertyOp) JSVAL_TO_OBJECT(rval);
    1:                 attrs = JSPROP_SETTER;
    1:             }
    1:             attrs |= JSPROP_ENUMERATE | JSPROP_SHARED;
    1: 
    1:             /* Check for a readonly or permanent property of the same name. */
11859:             if (!js_CheckRedeclaration(cx, obj, id, attrs, NULL, NULL))
11859:                 goto error;
11859: 
11859:             if (!OBJ_DEFINE_PROPERTY(cx, obj, id, JSVAL_VOID, getter, setter,
11859:                                      attrs, NULL)) {
11859:                 goto error;
11859:             }
    1: 
13168:             regs.sp += i;
    1:             if (js_CodeSpec[op2].ndefs)
    1:                 STORE_OPND(-1, rval);
    1:             len = js_CodeSpec[op2].length;
    1:             DO_NEXT_OP(len);
    1: #endif /* JS_HAS_GETTER_SETTER */
    1: 
    1:           BEGIN_CASE(JSOP_NEWINIT)
13168:             i = GET_INT8(regs.pc);
 8633:             JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
 8633:             obj = (i == JSProto_Array)
 8633:                   ? js_NewArrayObject(cx, 0, NULL)
13824:                   : js_NewObject(cx, &js_ObjectClass, NULL, NULL, 0);
 8633:             if (!obj)
11859:                 goto error;
 8633:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:             fp->sharpDepth++;
 8836:             LOAD_INTERRUPT_HANDLER(cx);
 8633:           END_CASE(JSOP_NEWINIT)
    1: 
    1:           BEGIN_CASE(JSOP_ENDINIT)
    1:             if (--fp->sharpDepth == 0)
    1:                 fp->sharpArray = NULL;
    1: 
    1:             /* Re-set the newborn root to the top of this object tree. */
13168:             JS_ASSERT(regs.sp - fp->spbase >= 1);
    1:             lval = FETCH_OPND(-1);
    1:             JS_ASSERT(JSVAL_IS_OBJECT(lval));
 5917:             cx->weakRoots.newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(lval);
    1:           END_CASE(JSOP_ENDINIT)
    1: 
    1:           BEGIN_CASE(JSOP_INITPROP)
12307:             /* Load the property's initial value into rval. */
13168:             JS_ASSERT(regs.sp - fp->spbase >= 2);
12307:             rval = FETCH_OPND(-1);
12307: 
12307:             /* Load the object being initialized into lval/obj. */
12307:             lval = FETCH_OPND(-2);
12307:             obj = JSVAL_TO_OBJECT(lval);
12307:             JS_ASSERT(OBJ_IS_NATIVE(obj));
12307:             JS_ASSERT(!OBJ_GET_CLASS(cx, obj)->reserveSlots);
12307:             JS_ASSERT(!(LOCKED_OBJ_GET_CLASS(obj)->flags &
12307:                         JSCLASS_SHARE_ALL_PROPERTIES));
12307: 
12307:             do {
12307:                 JSScope *scope;
12307:                 uint32 kshape;
12307:                 JSPropertyCache *cache;
12307:                 JSPropCacheEntry *entry;
12307: 
12307:                 JS_LOCK_OBJ(cx, obj);
12307:                 scope = OBJ_SCOPE(obj);
12307:                 JS_ASSERT(!SCOPE_IS_SEALED(scope));
12307:                 kshape = scope->shape;
12307:                 cache = &JS_PROPERTY_CACHE(cx);
13168:                 entry = &cache->table[PROPERTY_CACHE_HASH_PC(regs.pc, kshape)];
12307:                 PCMETER(cache->tests++);
12307:                 PCMETER(cache->initests++);
12307: 
13168:                 if (entry->kpc == regs.pc && entry->kshape == kshape) {
12307:                     PCMETER(cache->pchits++);
12307:                     PCMETER(cache->inipchits++);
12307: 
12307:                     JS_ASSERT(PCVAL_IS_SPROP(entry->vword));
12307:                     sprop = PCVAL_TO_SPROP(entry->vword);
12307:                     JS_ASSERT(!(sprop->attrs & JSPROP_READONLY));
12399: 
12399:                     /*
12399:                      * If this property has a non-stub setter, it must be
12399:                      * __proto__, __parent__, or another "shared prototype"
12399:                      * built-in. Force a miss to save code size here and let
12399:                      * the standard code path take care of business.
12399:                      */
12399:                     if (!SPROP_HAS_STUB_SETTER(sprop))
12399:                         goto do_initprop_miss;
12399: 
12307:                     if (scope->object != obj) {
12307:                         scope = js_GetMutableScope(cx, obj);
12307:                         if (!scope) {
12307:                             JS_UNLOCK_OBJ(cx, obj);
12307:                             goto error;
12307:                         }
12307:                     }
12307: 
12371:                     /*
12371:                      * Detect a repeated property name and force a miss to
12371:                      * share the strict warning code and cope with complexity
12371:                      * managed by js_AddScopeProperty.
12371:                      */
12371:                     if (sprop->parent != scope->lastProp)
12371:                         goto do_initprop_miss;
12371: 
12449:                     /*
12449:                      * Otherwise this entry must be for a direct property of
12449:                      * obj, not a proto-property, and there cannot have been
12449:                      * any deletions of prior properties.
12449:                      */
12449:                     JS_ASSERT(PCVCAP_MAKE(sprop->shape, 0, 0) == entry->vcap);
12307:                     JS_ASSERT(!SCOPE_HAD_MIDDLE_DELETE(scope));
12371:                     JS_ASSERT(!scope->table ||
12371:                               !SCOPE_HAS_PROPERTY(scope, sprop));
12307: 
12307:                     slot = sprop->slot;
12307:                     JS_ASSERT(slot == scope->map.freeslot);
12307:                     if (slot < STOBJ_NSLOTS(obj)) {
12307:                         ++scope->map.freeslot;
12307:                     } else {
12307:                         if (!js_AllocSlot(cx, obj, &slot)) {
12307:                             JS_UNLOCK_SCOPE(cx, scope);
12307:                             goto error;
12307:                         }
12307:                         JS_ASSERT(slot == sprop->slot);
12307:                     }
12307: 
12307:                     JS_ASSERT(!scope->lastProp ||
12307:                               scope->shape == scope->lastProp->shape);
12307:                     if (scope->table) {
12307:                         JSScopeProperty *sprop2 =
12307:                             js_AddScopeProperty(cx, scope, sprop->id,
12307:                                                 sprop->getter, sprop->setter,
12307:                                                 slot, sprop->attrs,
12307:                                                 sprop->flags, sprop->shortid);
12307:                         if (!sprop2) {
12307:                             js_FreeSlot(cx, obj, slot);
12307:                             JS_UNLOCK_SCOPE(cx, scope);
12307:                             goto error;
12307:                         }
12307:                         JS_ASSERT(sprop2 == sprop);
12307:                     } else {
12307:                         scope->shape = sprop->shape;
12307:                         ++scope->entryCount;
12307:                         scope->lastProp = sprop;
12307:                     }
12307: 
12307:                     GC_WRITE_BARRIER(cx, scope,
12307:                                      LOCKED_OBJ_GET_SLOT(obj, slot),
12307:                                      rval);
12307:                     LOCKED_OBJ_SET_SLOT(obj, slot, rval);
12307:                     JS_UNLOCK_SCOPE(cx, scope);
12307:                     break;
12307:                 }
12307: 
12371:               do_initprop_miss:
12307:                 PCMETER(cache->inipcmisses++);
12307:                 JS_UNLOCK_SCOPE(cx, scope);
12307: 
    1:                 /* Get the immediate property name into id. */
    1:                 LOAD_ATOM(0);
    1:                 id = ATOM_TO_JSID(atom);
12307: 
12307:                 /* Set the property named by obj[id] to rval. */
12307:                 if (!js_CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER,
12307:                                            NULL, NULL)) {
12307:                     goto error;
12307:                 }
12307:                 if (!js_SetPropertyHelper(cx, obj, id, &rval, &entry))
12307:                     goto error;
12307:             } while (0);
12307: 
12307:             /* Common tail for property cache hit and miss cases. */
13168:             regs.sp--;
12307:           END_CASE(JSOP_INITPROP);
    1: 
    1:           BEGIN_CASE(JSOP_INITELEM)
    1:             /* Pop the element's value into rval. */
13168:             JS_ASSERT(regs.sp - fp->spbase >= 3);
    1:             rval = FETCH_OPND(-1);
    1:             FETCH_ELEMENT_ID(obj, -2, id);
    1: 
    1:             /* Find the object being initialized at top of stack. */
12307:             lval = FETCH_OPND(-3);
12307:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(lval));
    1:             obj = JSVAL_TO_OBJECT(lval);
    1: 
    1:             /* Set the property named by obj[id] to rval. */
11859:             if (!js_CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER, NULL,
11859:                                        NULL)) {
11859:                 goto error;
11859:             }
11859:             if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
11859:                 goto error;
13168:             regs.sp -= 2;
12307:           END_CASE(JSOP_INITELEM);
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:           BEGIN_CASE(JSOP_DEFSHARP)
    1:             obj = fp->sharpArray;
    1:             if (!obj) {
    1:                 obj = js_NewArrayObject(cx, 0, NULL);
11859:                 if (!obj)
11859:                     goto error;
    1:                 fp->sharpArray = obj;
    1:             }
13168:             i = (jsint) GET_UINT16(regs.pc);
    1:             id = INT_TO_JSID(i);
    1:             rval = FETCH_OPND(-1);
    1:             if (JSVAL_IS_PRIMITIVE(rval)) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_SHARP_DEF, numBuf);
11859:                 goto error;
11859:             }
11859:             if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
11859:                 goto error;
    1:           END_CASE(JSOP_DEFSHARP)
    1: 
    1:           BEGIN_CASE(JSOP_USESHARP)
13168:             i = (jsint) GET_UINT16(regs.pc);
    1:             id = INT_TO_JSID(i);
    1:             obj = fp->sharpArray;
    1:             if (!obj) {
    1:                 rval = JSVAL_VOID;
    1:             } else {
11859:                 if (!OBJ_GET_PROPERTY(cx, obj, id, &rval))
11859:                     goto error;
    1:             }
    1:             if (!JSVAL_IS_OBJECT(rval)) {
    1:                 char numBuf[12];
13168: 
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_SHARP_USE, numBuf);
11859:                 goto error;
    1:             }
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_USESHARP)
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:           /* No-ops for ease of decompilation and jit'ing. */
    1:           EMPTY_CASE(JSOP_TRY)
    1:           EMPTY_CASE(JSOP_FINALLY)
    1: 
    1:           BEGIN_CASE(JSOP_GOSUB)
 1825:             PUSH(JSVAL_FALSE);
13168:             i = PTRDIFF(regs.pc, script->main, jsbytecode) + JSOP_GOSUB_LENGTH;
13168:             len = GET_JUMP_OFFSET(regs.pc);
    1:             PUSH(INT_TO_JSVAL(i));
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_GOSUBX)
 1825:             PUSH(JSVAL_FALSE);
13168:             i = PTRDIFF(regs.pc, script->main, jsbytecode) + JSOP_GOSUBX_LENGTH;
13168:             len = GET_JUMPX_OFFSET(regs.pc);
    1:             PUSH(INT_TO_JSVAL(i));
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_RETSUB)
    1:             rval = POP();
    1:             lval = POP();
 1825:             JS_ASSERT(JSVAL_IS_BOOLEAN(lval));
 1825:             if (JSVAL_TO_BOOLEAN(lval)) {
    1:                 /*
    1:                  * Exception was pending during finally, throw it *before* we
    1:                  * adjust pc, because pc indexes into script->trynotes.  This
    1:                  * turns out not to be necessary, but it seems clearer.  And
    1:                  * it points out a FIXME: 350509, due to Igor Bukanov.
    1:                  */
    1:                 cx->throwing = JS_TRUE;
 1825:                 cx->exception = rval;
11859:                 goto error;
    1:             }
 1825:             JS_ASSERT(JSVAL_IS_INT(rval));
    1:             len = JSVAL_TO_INT(rval);
13168:             regs.pc = script->main;
    1:           END_VARLEN_CASE
    1: 
    1:           BEGIN_CASE(JSOP_EXCEPTION)
    1:             JS_ASSERT(cx->throwing);
    1:             PUSH(cx->exception);
    1:             cx->throwing = JS_FALSE;
    1:           END_CASE(JSOP_EXCEPTION)
    1: 
    1:           BEGIN_CASE(JSOP_THROWING)
    1:             JS_ASSERT(!cx->throwing);
    1:             cx->throwing = JS_TRUE;
    1:             cx->exception = POP_OPND();
    1:           END_CASE(JSOP_THROWING)
    1: 
    1:           BEGIN_CASE(JSOP_THROW)
    1:             JS_ASSERT(!cx->throwing);
    1:             cx->throwing = JS_TRUE;
    1:             cx->exception = POP_OPND();
11859:             /* let the code at error try to catch the exception. */
11859:             goto error;
    1: 
    1:           BEGIN_CASE(JSOP_SETLOCALPOP)
    1:             /*
    1:              * The stack must have a block with at least one local slot below
    1:              * the exception object.
    1:              */
13168:             JS_ASSERT(regs.sp - fp->spbase >= 2);
13168:             slot = GET_UINT16(regs.pc);
12579:             JS_ASSERT(slot + 1 < script->depth);
    1:             fp->spbase[slot] = POP_OPND();
    1:           END_CASE(JSOP_SETLOCALPOP)
    1: 
    1:           BEGIN_CASE(JSOP_INSTANCEOF)
    1:             rval = FETCH_OPND(-1);
    1:             if (JSVAL_IS_PRIMITIVE(rval) ||
    1:                 !(obj = JSVAL_TO_OBJECT(rval))->map->ops->hasInstance) {
    1:                 js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
    1:                                     -1, rval, NULL);
11859:                 goto error;
    1:             }
    1:             lval = FETCH_OPND(-2);
    1:             cond = JS_FALSE;
11859:             if (!obj->map->ops->hasInstance(cx, obj, lval, &cond))
11859:                 goto error;
13168:             regs.sp--;
    1:             STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));
    1:           END_CASE(JSOP_INSTANCEOF)
    1: 
    1: #if JS_HAS_DEBUGGER_KEYWORD
    1:           BEGIN_CASE(JSOP_DEBUGGER)
    1:           {
 2433:             JSTrapHandler handler = cx->debugHooks->debuggerHandler;
    1:             if (handler) {
13168:                 switch (handler(cx, script, regs.pc, &rval,
 2433:                                 cx->debugHooks->debuggerHandlerData)) {
    1:                   case JSTRAP_ERROR:
11859:                     goto error;
    1:                   case JSTRAP_CONTINUE:
    1:                     break;
    1:                   case JSTRAP_RETURN:
    1:                     fp->rval = rval;
11859:                     ok = JS_TRUE;
11758:                     goto forced_return;
    1:                   case JSTRAP_THROW:
    1:                     cx->throwing = JS_TRUE;
    1:                     cx->exception = rval;
11859:                     goto error;
    1:                   default:;
    1:                 }
 2433:                 LOAD_INTERRUPT_HANDLER(cx);
    1:             }
    1:           }
    1:           END_CASE(JSOP_DEBUGGER)
    1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:           BEGIN_CASE(JSOP_DEFXMLNS)
    1:             rval = POP();
11859:             if (!js_SetDefaultXMLNamespace(cx, rval))
11859:                 goto error;
    1:           END_CASE(JSOP_DEFXMLNS)
    1: 
    1:           BEGIN_CASE(JSOP_ANYNAME)
11859:             if (!js_GetAnyName(cx, &rval))
11859:                 goto error;
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_ANYNAME)
    1: 
    1:           BEGIN_CASE(JSOP_QNAMEPART)
    1:             LOAD_ATOM(0);
    1:             PUSH_OPND(ATOM_KEY(atom));
    1:           END_CASE(JSOP_QNAMEPART)
    1: 
    1:           BEGIN_CASE(JSOP_QNAMECONST)
    1:             LOAD_ATOM(0);
    1:             rval = ATOM_KEY(atom);
    1:             lval = FETCH_OPND(-1);
    1:             obj = js_ConstructXMLQNameObject(cx, lval, rval);
11859:             if (!obj)
11859:                 goto error;
    1:             STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_QNAMECONST)
    1: 
    1:           BEGIN_CASE(JSOP_QNAME)
    1:             rval = FETCH_OPND(-1);
    1:             lval = FETCH_OPND(-2);
    1:             obj = js_ConstructXMLQNameObject(cx, lval, rval);
11859:             if (!obj)
11859:                 goto error;
13168:             regs.sp--;
    1:             STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_QNAME)
    1: 
    1:           BEGIN_CASE(JSOP_TOATTRNAME)
    1:             rval = FETCH_OPND(-1);
11859:             if (!js_ToAttributeName(cx, &rval))
11859:                 goto error;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_TOATTRNAME)
    1: 
    1:           BEGIN_CASE(JSOP_TOATTRVAL)
    1:             rval = FETCH_OPND(-1);
    1:             JS_ASSERT(JSVAL_IS_STRING(rval));
 9762:             str = js_EscapeAttributeValue(cx, JSVAL_TO_STRING(rval), JS_FALSE);
11859:             if (!str)
11859:                 goto error;
    1:             STORE_OPND(-1, STRING_TO_JSVAL(str));
    1:           END_CASE(JSOP_TOATTRVAL)
    1: 
    1:           BEGIN_CASE(JSOP_ADDATTRNAME)
    1:           BEGIN_CASE(JSOP_ADDATTRVAL)
    1:             rval = FETCH_OPND(-1);
    1:             lval = FETCH_OPND(-2);
    1:             str = JSVAL_TO_STRING(lval);
    1:             str2 = JSVAL_TO_STRING(rval);
    1:             str = js_AddAttributePart(cx, op == JSOP_ADDATTRNAME, str, str2);
11859:             if (!str)
11859:                 goto error;
13168:             regs.sp--;
    1:             STORE_OPND(-1, STRING_TO_JSVAL(str));
    1:           END_CASE(JSOP_ADDATTRNAME)
    1: 
    1:           BEGIN_CASE(JSOP_BINDXMLNAME)
    1:             lval = FETCH_OPND(-1);
11859:             if (!js_FindXMLProperty(cx, lval, &obj, &id))
11859:                 goto error;
    1:             STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
    1:             PUSH_OPND(ID_TO_VALUE(id));
    1:           END_CASE(JSOP_BINDXMLNAME)
    1: 
    1:           BEGIN_CASE(JSOP_SETXMLNAME)
    1:             obj = JSVAL_TO_OBJECT(FETCH_OPND(-3));
    1:             rval = FETCH_OPND(-1);
    1:             FETCH_ELEMENT_ID(obj, -2, id);
11859:             if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
11859:                 goto error;
13168:             regs.sp -= 2;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_SETXMLNAME)
    1: 
    1:           BEGIN_CASE(JSOP_CALLXMLNAME)
    1:           BEGIN_CASE(JSOP_XMLNAME)
    1:             lval = FETCH_OPND(-1);
11859:             if (!js_FindXMLProperty(cx, lval, &obj, &id))
11859:                 goto error;
11859:             if (!OBJ_GET_PROPERTY(cx, obj, id, &rval))
11859:                 goto error;
    1:             STORE_OPND(-1, rval);
12470:             if (op == JSOP_CALLXMLNAME)
    1:                 PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_XMLNAME)
    1: 
    1:           BEGIN_CASE(JSOP_DESCENDANTS)
    1:           BEGIN_CASE(JSOP_DELDESC)
    1:             FETCH_OBJECT(cx, -2, lval, obj);
    1:             rval = FETCH_OPND(-1);
11859:             if (!js_GetXMLDescendants(cx, obj, rval, &rval))
11859:                 goto error;
    1: 
    1:             if (op == JSOP_DELDESC) {
13168:                 regs.sp[-1] = rval;          /* set local root */
11859:                 if (!js_DeleteXMLListElements(cx, JSVAL_TO_OBJECT(rval)))
11859:                     goto error;
    1:                 rval = JSVAL_TRUE;      /* always succeed */
    1:             }
    1: 
13168:             regs.sp--;
    1:             STORE_OPND(-1, rval);
    1:           END_CASE(JSOP_DESCENDANTS)
    1: 
    1:           BEGIN_CASE(JSOP_FILTER)
11672:             /*
11672:              * We push the hole value before jumping to [enditer] so we can
11672:              * detect the first iteration and direct js_StepXMLListFilter to
11672:              * initialize filter's state.
11672:              */
11672:             PUSH_OPND(JSVAL_HOLE);
13168:             len = GET_JUMP_OFFSET(regs.pc);
11672:             JS_ASSERT(len > 0);
11672:           END_VARLEN_CASE
11672: 
11672:           BEGIN_CASE(JSOP_ENDFILTER)
13168:             cond = (regs.sp[-1] != JSVAL_HOLE);
11672:             if (cond) {
11672:                 /* Exit the "with" block left from the previous iteration. */
12551:                 js_LeaveWith(cx);
11672:             }
11859:             if (!js_StepXMLListFilter(cx, cond))
11859:                 goto error;
13168:             if (regs.sp[-1] != JSVAL_NULL) {
11672:                 /*
11672:                  * Decrease sp after EnterWith returns as we use sp[-1] there
11672:                  * to root temporaries.
11672:                  */
13168:                 JS_ASSERT(VALUE_IS_XML(cx, regs.sp[-1]));
12551:                 if (!js_EnterWith(cx, -2))
11859:                     goto error;
13168:                 regs.sp--;
13168:                 len = GET_JUMP_OFFSET(regs.pc);
11672:                 JS_ASSERT(len < 0);
11672:                 CHECK_BRANCH(len);
11672:                 DO_NEXT_OP(len);
11672:             }
13168:             regs.sp--;
11672:           END_CASE(JSOP_ENDFILTER);
    1: 
    1:           EMPTY_CASE(JSOP_STARTXML)
    1:           EMPTY_CASE(JSOP_STARTXMLEXPR)
    1: 
    1:           BEGIN_CASE(JSOP_TOXML)
    1:             rval = FETCH_OPND(-1);
    1:             obj = js_ValueToXMLObject(cx, rval);
11859:             if (!obj)
11859:                 goto error;
    1:             STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_TOXML)
    1: 
    1:           BEGIN_CASE(JSOP_TOXMLLIST)
    1:             rval = FETCH_OPND(-1);
    1:             obj = js_ValueToXMLListObject(cx, rval);
11859:             if (!obj)
11859:                 goto error;
    1:             STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_TOXMLLIST)
    1: 
    1:           BEGIN_CASE(JSOP_XMLTAGEXPR)
    1:             rval = FETCH_OPND(-1);
    1:             str = js_ValueToString(cx, rval);
11859:             if (!str)
11859:                 goto error;
    1:             STORE_OPND(-1, STRING_TO_JSVAL(str));
    1:           END_CASE(JSOP_XMLTAGEXPR)
    1: 
    1:           BEGIN_CASE(JSOP_XMLELTEXPR)
    1:             rval = FETCH_OPND(-1);
    1:             if (VALUE_IS_XML(cx, rval)) {
    1:                 str = js_ValueToXMLString(cx, rval);
    1:             } else {
    1:                 str = js_ValueToString(cx, rval);
    1:                 if (str)
    1:                     str = js_EscapeElementValue(cx, str);
    1:             }
11859:             if (!str)
11859:                 goto error;
    1:             STORE_OPND(-1, STRING_TO_JSVAL(str));
    1:           END_CASE(JSOP_XMLELTEXPR)
    1: 
    1:           BEGIN_CASE(JSOP_XMLOBJECT)
 3235:             LOAD_OBJECT(0);
 3235:             obj = js_CloneXMLObject(cx, obj);
11859:             if (!obj)
11859:                 goto error;
    1:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_XMLOBJECT)
    1: 
    1:           BEGIN_CASE(JSOP_XMLCDATA)
    1:             LOAD_ATOM(0);
    1:             str = ATOM_TO_STRING(atom);
    1:             obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_TEXT, NULL, str);
11859:             if (!obj)
11859:                 goto error;
    1:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_XMLCDATA)
    1: 
    1:           BEGIN_CASE(JSOP_XMLCOMMENT)
    1:             LOAD_ATOM(0);
    1:             str = ATOM_TO_STRING(atom);
    1:             obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_COMMENT, NULL, str);
11859:             if (!obj)
11859:                 goto error;
    1:             PUSH_OPND(OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_XMLCOMMENT)
    1: 
    1:           BEGIN_CASE(JSOP_XMLPI)
    1:             LOAD_ATOM(0);
    1:             str = ATOM_TO_STRING(atom);
    1:             rval = FETCH_OPND(-1);
    1:             str2 = JSVAL_TO_STRING(rval);
    1:             obj = js_NewXMLSpecialObject(cx,
    1:                                          JSXML_CLASS_PROCESSING_INSTRUCTION,
    1:                                          str, str2);
11859:             if (!obj)
11859:                 goto error;
    1:             STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
    1:           END_CASE(JSOP_XMLPI)
 8658: 
    1:           BEGIN_CASE(JSOP_GETFUNNS)
11859:             if (!js_GetFunctionNamespace(cx, &rval))
11859:                 goto error;
    1:             PUSH_OPND(rval);
    1:           END_CASE(JSOP_GETFUNNS)
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:           BEGIN_CASE(JSOP_ENTERBLOCK)
 3235:             LOAD_OBJECT(0);
13168:             JS_ASSERT(fp->spbase + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
13168:             vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
14167:             JS_ASSERT(regs.sp < vp);
12579:             JS_ASSERT(vp <= fp->spbase + script->depth);
13168:             while (regs.sp < vp) {
    1:                 STORE_OPND(0, JSVAL_VOID);
13168:                 regs.sp++;
    1:             }
    1: 
    1:             /*
    1:              * If this frame had to reflect the compile-time block chain into
    1:              * the runtime scope chain, we can't optimize block scopes out of
    1:              * runtime any longer, because an outer block that parents obj has
    1:              * been cloned onto the scope chain.  To avoid re-cloning such a
    1:              * parent and accumulating redundant clones via js_GetScopeChain,
    1:              * we must clone each block eagerly on entry, and push it on the
    1:              * scope chain, until this frame pops.
    1:              */
    1:             if (fp->flags & JSFRAME_POP_BLOCKS) {
    1:                 JS_ASSERT(!fp->blockChain);
10466:                 obj = js_CloneBlockObject(cx, obj, fp->scopeChain, fp);
11859:                 if (!obj)
11859:                     goto error;
    1:                 fp->scopeChain = obj;
    1:             } else {
    1:                 JS_ASSERT(!fp->blockChain ||
    1:                           OBJ_GET_PARENT(cx, obj) == fp->blockChain);
    1:                 fp->blockChain = obj;
    1:             }
    1:           END_CASE(JSOP_ENTERBLOCK)
    1: 
    1:           BEGIN_CASE(JSOP_LEAVEBLOCKEXPR)
    1:           BEGIN_CASE(JSOP_LEAVEBLOCK)
    1:           {
11859: #ifdef DEBUG
11859:             jsval *blocksp = fp->spbase + OBJ_BLOCK_DEPTH(cx,
11859:                                                           fp->blockChain
11859:                                                           ? fp->blockChain
11859:                                                           : fp->scopeChain);
11859: 
12579:             JS_ASSERT((size_t) (blocksp - fp->spbase) <= script->depth);
11859: #endif
11859:             if (fp->blockChain) {
11859:                 JS_ASSERT(OBJ_GET_CLASS(cx, fp->blockChain) == &js_BlockClass);
11859:                 fp->blockChain = OBJ_GET_PARENT(cx, fp->blockChain);
11859:             } else {
11859:                 /*
11859:                  * This block was cloned into fp->scopeChain, so clear its
11859:                  * private data and sync its locals to their property slots.
11859:                  */
11859:                 if (!js_PutBlockObject(cx, JS_TRUE))
11859:                     goto error;
11859:             }
11859: 
11859:             /*
11859:              * We will move the result of the expression to the new topmost
11859:              * stack slot.
11859:              */
    1:             if (op == JSOP_LEAVEBLOCKEXPR)
    1:                 rval = FETCH_OPND(-1);
13168:             regs.sp -= GET_UINT16(regs.pc);
11859:             if (op == JSOP_LEAVEBLOCKEXPR) {
13168:                 JS_ASSERT(blocksp == regs.sp - 1);
    1:                 STORE_OPND(-1, rval);
11859:             } else {
13168:                 JS_ASSERT(blocksp == regs.sp);
11859:             }
    1:           }
    1:           END_CASE(JSOP_LEAVEBLOCK)
    1: 
    1:           BEGIN_CASE(JSOP_GETLOCAL)
    1:           BEGIN_CASE(JSOP_CALLLOCAL)
13168:             slot = GET_UINT16(regs.pc);
12579:             JS_ASSERT(slot < script->depth);
    1:             PUSH_OPND(fp->spbase[slot]);
    1:             if (op == JSOP_CALLLOCAL)
11774:                 PUSH_OPND(JSVAL_NULL);
    1:           END_CASE(JSOP_GETLOCAL)
    1: 
    1:           BEGIN_CASE(JSOP_SETLOCAL)
13168:             slot = GET_UINT16(regs.pc);
12579:             JS_ASSERT(slot < script->depth);
    1:             vp = &fp->spbase[slot];
    1:             GC_POKE(cx, *vp);
    1:             *vp = FETCH_OPND(-1);
    1:           END_CASE(JSOP_SETLOCAL)
    1: 
    1:           BEGIN_CASE(JSOP_ENDITER)
    1:             /*
 3025:              * Decrease the stack pointer even when !ok, see comments in the
 3025:              * exception capturing code for details.
    1:              */
13168:             ok = js_CloseIterator(cx, regs.sp[-1]);
13168:             regs.sp--;
 3025:             if (!ok)
11859:                 goto error;
    1:           END_CASE(JSOP_ENDITER)
    1: 
    1: #if JS_HAS_GENERATORS
    1:           BEGIN_CASE(JSOP_GENERATOR)
11859:             ASSERT_NOT_THROWING(cx);
13168:             regs.pc += JSOP_GENERATOR_LENGTH;
    1:             obj = js_NewGenerator(cx, fp);
11859:             if (!obj)
11859:                 goto error;
    1:             JS_ASSERT(!fp->callobj && !fp->argsobj);
    1:             fp->rval = OBJECT_TO_JSVAL(obj);
11859:             ok = JS_TRUE;
11758:             if (inlineCallCount != 0)
11758:                 goto inline_return;
11758:             goto exit;
    1: 
    1:           BEGIN_CASE(JSOP_YIELD)
    1:             ASSERT_NOT_THROWING(cx);
    1:             if (FRAME_TO_GENERATOR(fp)->state == JSGEN_CLOSING) {
    1:                 js_ReportValueError(cx, JSMSG_BAD_GENERATOR_YIELD,
    1:                                     JSDVG_SEARCH_STACK, fp->argv[-2], NULL);
11859:                 goto error;
    1:             }
    1:             fp->rval = FETCH_OPND(-1);
    1:             fp->flags |= JSFRAME_YIELDING;
13168:             regs.pc += JSOP_YIELD_LENGTH;
11859:             ok = JS_TRUE;
11758:             goto exit;
    1: 
    1:           BEGIN_CASE(JSOP_ARRAYPUSH)
13168:             slot = GET_UINT16(regs.pc);
12579:             JS_ASSERT(slot < script->depth);
    1:             lval = fp->spbase[slot];
    1:             obj  = JSVAL_TO_OBJECT(lval);
    1:             JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_ArrayClass);
    1:             rval = FETCH_OPND(-1);
    1: 
 4127:             /*
 4127:              * We know that the array is created with only a 'length' private
 4127:              * data slot at JSSLOT_ARRAY_LENGTH, and that previous iterations
 4127:              * of the comprehension have added the only properties directly in
 4127:              * the array object.
 4127:              */
11835:             i = obj->fslots[JSSLOT_ARRAY_LENGTH];
 4127:             if (i == ARRAY_INIT_LIMIT) {
 4127:                 JS_ReportErrorNumberUC(cx, js_GetErrorMessage, NULL,
 4127:                                        JSMSG_ARRAY_INIT_TOO_BIG);
11859:                 goto error;
 4127:             }
    1:             id = INT_TO_JSID(i);
11859:             if (!OBJ_SET_PROPERTY(cx, obj, id, &rval))
11859:                 goto error;
13168:             regs.sp--;
    1:           END_CASE(JSOP_ARRAYPUSH)
    1: #endif /* JS_HAS_GENERATORS */
    1: 
 8656: #if JS_THREADED_INTERP
 8656:           L_JSOP_BACKPATCH:
 8656:           L_JSOP_BACKPATCH_POP:
 8656: 
    1: # if !JS_HAS_GENERATORS
    1:           L_JSOP_GENERATOR:
    1:           L_JSOP_YIELD:
    1:           L_JSOP_ARRAYPUSH:
    1: # endif
    1: 
    1: # if !JS_HAS_DESTRUCTURING
    1:           L_JSOP_FOREACHKEYVAL:
    1:           L_JSOP_ENUMCONSTELEM:
    1: # endif
    1: 
 8656: # if !JS_HAS_XML_SUPPORT
 8656:           L_JSOP_CALLXMLNAME:
 8656:           L_JSOP_STARTXMLEXPR:
 8656:           L_JSOP_STARTXML:
 8656:           L_JSOP_DELDESC:
 8656:           L_JSOP_GETFUNNS:
 8656:           L_JSOP_XMLPI:
 8656:           L_JSOP_XMLCOMMENT:
 8656:           L_JSOP_XMLCDATA:
 8656:           L_JSOP_XMLOBJECT:
 8656:           L_JSOP_XMLELTEXPR:
 8656:           L_JSOP_XMLTAGEXPR:
 8656:           L_JSOP_TOXMLLIST:
 8656:           L_JSOP_TOXML:
 8656:           L_JSOP_ENDFILTER:
 8656:           L_JSOP_FILTER:
 8656:           L_JSOP_DESCENDANTS:
 8656:           L_JSOP_XMLNAME:
 8656:           L_JSOP_SETXMLNAME:
 8656:           L_JSOP_BINDXMLNAME:
 8656:           L_JSOP_ADDATTRVAL:
 8656:           L_JSOP_ADDATTRNAME:
 8656:           L_JSOP_TOATTRVAL:
 8656:           L_JSOP_TOATTRNAME:
 8656:           L_JSOP_QNAME:
 8656:           L_JSOP_QNAMECONST:
 8656:           L_JSOP_QNAMEPART:
 8656:           L_JSOP_ANYNAME:
 8656:           L_JSOP_DEFXMLNS:
 8656: # endif
 8656: 
12343:           L_JSOP_UNUSED117:
12343: 
 8656: #else /* !JS_THREADED_INTERP */
    1:           default:
    1: #endif
    1:           {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%d", op);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_BYTECODE, numBuf);
11859:             goto error;
    1:           }
    1: 
    1: #if !JS_THREADED_INTERP
    1: 
    1:         } /* switch (op) */
    1: 
    1:     advance_pc:
13168:         regs.pc += len;
    1: 
    1: #ifdef DEBUG
    1:         if (tracefp) {
    1:             intN ndefs, n;
    1:             jsval *siter;
    1: 
11859:             /*
11859:              * op may be invalid here when a catch or finally handler jumps to
11859:              * advance_pc.
11859:              */
13168:             op = (JSOp) regs.pc[-len];
    1:             ndefs = js_CodeSpec[op].ndefs;
    1:             if (ndefs) {
13168:                 if (op == JSOP_FORELEM && regs.sp[-1] == JSVAL_FALSE)
    1:                     --ndefs;
    1:                 for (n = -ndefs; n < 0; n++) {
13168:                     char *bytes = js_DecompileValueGenerator(cx, n, regs.sp[n],
    1:                                                              NULL);
    1:                     if (bytes) {
    1:                         fprintf(tracefp, "%s %s",
    1:                                 (n == -ndefs) ? "  output:" : ",",
    1:                                 bytes);
    1:                         JS_free(cx, bytes);
    1:                     }
    1:                 }
13168:                 fprintf(tracefp, " @ %d\n", regs.sp - fp->spbase);
    1:             }
    1:             fprintf(tracefp, "  stack: ");
13168:             for (siter = fp->spbase; siter < regs.sp; siter++) {
    1:                 str = js_ValueToString(cx, *siter);
    1:                 if (!str)
    1:                     fputs("<null>", tracefp);
    1:                 else
    1:                     js_FileEscapedString(tracefp, str, 0);
    1:                 fputc(' ', tracefp);
    1:             }
    1:             fputc('\n', tracefp);
    1:         }
    1: #endif /* DEBUG */
    1:     }
    1: #endif /* !JS_THREADED_INTERP */
    1: 
11859:   error:
13168:     JS_ASSERT((size_t)(regs.pc - script->code) < script->length);
11859:     if (!cx->throwing) {
11859:         /* This is an error, not a catchable exception, quit the frame ASAP. */
11859:         ok = JS_FALSE;
11859:     } else {
 1825:         JSTrapHandler handler;
 1825:         JSTryNote *tn, *tnlimit;
 1825:         uint32 offset;
 1825: 
11758:         /* Call debugger throw hook if set. */
 2433:         handler = cx->debugHooks->throwHook;
    1:         if (handler) {
13168:             switch (handler(cx, script, regs.pc, &rval,
 2433:                             cx->debugHooks->throwHookData)) {
    1:               case JSTRAP_ERROR:
    1:                 cx->throwing = JS_FALSE;
11859:                 goto error;
    1:               case JSTRAP_RETURN:
    1:                 cx->throwing = JS_FALSE;
    1:                 fp->rval = rval;
11758:                 ok = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
    1:                 cx->exception = rval;
    1:               case JSTRAP_CONTINUE:
    1:               default:;
    1:             }
 2433:             LOAD_INTERRUPT_HANDLER(cx);
    1:         }
    1: 
    1:         /*
    1:          * Look for a try block in script that can catch this exception.
    1:          */
 3235:         if (script->trynotesOffset == 0)
 1825:             goto no_catch;
 1825: 
13168:         offset = (uint32)(regs.pc - script->main);
 3235:         tn = JS_SCRIPT_TRYNOTES(script)->vector;
 3235:         tnlimit = tn + JS_SCRIPT_TRYNOTES(script)->length;
 3025:         do {
 3025:             if (offset - tn->start >= tn->length)
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * We have a note that covers the exception pc but we must check
 3025:              * whether the interpreter has already executed the corresponding
 3025:              * handler. This is possible when the executed bytecode
 3025:              * implements break or return from inside a for-in loop.
 3025:              *
 3025:              * In this case the emitter generates additional [enditer] and
 3025:              * [gosub] opcodes to close all outstanding iterators and execute
 3025:              * the finally blocks. If such an [enditer] throws an exception,
 3025:              * its pc can still be inside several nested for-in loops and
 3025:              * try-finally statements even if we have already closed the
 3025:              * corresponding iterators and invoked the finally blocks.
 3025:              *
 3025:              * To address this, we make [enditer] always decrease the stack
 3025:              * even when its implementation throws an exception. Thus already
 3025:              * executed [enditer] and [gosub] opcodes will have try notes
 3025:              * with the stack depth exceeding the current one and this
 3025:              * condition is what we use to filter them out.
 3025:              */
13168:             if (tn->stackDepth > regs.sp - fp->spbase)
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * Set pc to the first bytecode after the the try note to point
 3025:              * to the beginning of catch or finally or to [enditer] closing
 3025:              * the for-in loop.
 1825:              */
13168:             regs.pc = (script)->main + tn->start + tn->length;
13168: 
12551:             ok = js_UnwindScope(cx, fp, tn->stackDepth, JS_TRUE);
13168:             JS_ASSERT(fp->regs->sp == fp->spbase + tn->stackDepth);
11758:             if (!ok) {
11758:                 /*
11758:                  * Restart the handler search with updated pc and stack depth
11758:                  * to properly notify the debugger.
11758:                  */
11859:                 goto error;
11758:             }
 1825: 
 3025:             switch (tn->kind) {
 3025:               case JSTN_CATCH:
13168:                 JS_ASSERT(*regs.pc == JSOP_ENTERBLOCK);
 3025: 
 3025: #if JS_HAS_GENERATORS
 3025:                 /* Catch cannot intercept the closing of a generator. */
 3025:                 if (JS_UNLIKELY(cx->exception == JSVAL_ARETURN))
 3025:                     break;
 3025: #endif
 3025: 
 1825:                 /*
 3025:                  * Don't clear cx->throwing to save cx->exception from GC
 3025:                  * until it is pushed to the stack via [exception] in the
 3025:                  * catch block.
 3025:                  */
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
 3025:               case JSTN_FINALLY:
 3025:                 /*
 3025:                  * Push (true, exception) pair for finally to indicate that
 1825:                  * [retsub] should rethrow the exception.
 1825:                  */
 1825:                 PUSH(JSVAL_TRUE);
 1825:                 PUSH(cx->exception);
 1825:                 cx->throwing = JS_FALSE;
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
 3025:               case JSTN_ITER:
 1825:                 /*
 3025:                  * This is similar to JSOP_ENDITER in the interpreter loop
 3025:                  * except the code now uses a reserved stack slot to save and
 3025:                  * restore the exception.
 1825:                  */
13168:                 JS_ASSERT(*regs.pc == JSOP_ENDITER);
 3025:                 PUSH(cx->exception);
 3025:                 cx->throwing = JS_FALSE;
13168:                 ok = js_CloseIterator(cx, regs.sp[-2]);
13168:                 regs.sp -= 2;
11859:                 if (!ok)
11859:                     goto error;
 3025:                 cx->throwing = JS_TRUE;
13168:                 cx->exception = regs.sp[1];
11859:             }
11859:         } while (++tn != tnlimit);
11859: 
11859:       no_catch:
 3025:         /*
11859:          * Propagate the exception or error to the caller unless the exception
11859:          * is an asynchronous return from a generator.
 3025:          */
 3025:         ok = JS_FALSE;
 1969: #if JS_HAS_GENERATORS
 3025:         if (JS_UNLIKELY(cx->throwing && cx->exception == JSVAL_ARETURN)) {
 1969:             cx->throwing = JS_FALSE;
 1969:             ok = JS_TRUE;
 1969:             fp->rval = JSVAL_VOID;
 1969:         }
 1969: #endif
    1:     }
    1: 
11758:   forced_return:
11758:     /*
11859:      * Unwind the scope making sure that ok stays false even when UnwindScope
11859:      * returns true.
11859:      *
11859:      * When a trap handler returns JSTRAP_RETURN, we jump here with ok set to
11859:      * true bypassing any finally blocks.
11758:      */
12551:     ok &= js_UnwindScope(cx, fp, 0, ok || cx->throwing);
13168:     JS_ASSERT(regs.sp == fp->spbase);
11758: 
11758:     if (inlineCallCount)
11758:         goto inline_return;
11758: 
11758:   exit:
    1:     /*
11377:      * At this point we are inevitably leaving an interpreted function or a
11377:      * top-level script, and returning to one of:
11758:      * (a) an "out of line" call made through js_Invoke;
11758:      * (b) a js_Execute activation;
11758:      * (c) a generator (SendToGenerator, jsiter.c).
11758:      *
11859:      * We must not be in an inline frame. The check above ensures that for the
11859:      * error case and for a normal return, the code jumps directly to parent's
11859:      * frame pc.
11377:      */
11758:     JS_ASSERT(inlineCallCount == 0);
13168: 
13168:     JS_ASSERT(fp->spbase);
13168:     JS_ASSERT(fp->regs == &regs);
    1:     if (JS_LIKELY(mark != NULL)) {
11758:         JS_ASSERT(!fp->blockChain);
12551:         JS_ASSERT(!js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
11758:         JS_ASSERT(!(fp->flags & JSFRAME_GENERATOR));
13168:         fp->spbase = NULL;
13168:         fp->regs = NULL;
12551:         js_FreeRawStack(cx, mark);
13168:     } else {
13168:         JS_ASSERT(fp->flags & JSFRAME_GENERATOR);
13168:         if (fp->flags & JSFRAME_YIELDING) {
13168:             JSGenerator *gen;
13168: 
13168:             gen = FRAME_TO_GENERATOR(fp);
13168:             gen->savedRegs = regs;
13168:             gen->frame.regs = &gen->savedRegs;
13168:             JS_PROPERTY_CACHE(cx).disabled -= js_CountWithBlocks(cx, fp);
13168:             JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled >= 0);
13168:         } else {
13168:             fp->regs = NULL;
13168:             fp->spbase = NULL;
13168:         }
13168:     }
13168: 
13168:   exit2:
13168:     JS_ASSERT(JS_PROPERTY_CACHE(cx).disabled == fp->pcDisabledSave);
    1:     if (cx->version == currentVersion && currentVersion != originalVersion)
    1:         js_SetVersion(cx, originalVersion);
    1:     cx->interpLevel--;
    1:     return ok;
    1: 
    1:   atom_not_defined:
    1:     {
11720:         const char *printable;
11720: 
11720:         printable = js_AtomToPrintableString(cx, atom);
    1:         if (printable)
    1:             js_ReportIsNotDefined(cx, printable);
11859:         goto error;
11859:     }
11859: }
12551: 
12551: #endif /* !defined js_invoke_c__ */
