46790: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
46790: /* vim: set sw=2 ts=8 et tw=80 : */
46790: 
46790: /* ***** BEGIN LICENSE BLOCK *****
46790:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
46790:  *
46790:  * The contents of this file are subject to the Mozilla Public License Version
46790:  * 1.1 (the "License"); you may not use this file except in compliance with
46790:  * the License. You may obtain a copy of the License at
46790:  * http://www.mozilla.org/MPL/
46790:  *
46790:  * Software distributed under the License is distributed on an "AS IS" basis,
46790:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
46790:  * for the specific language governing rights and limitations under the
46790:  * License.
46790:  *
46790:  * The Original Code is mozilla.org code.
46790:  *
46790:  * The Initial Developer of the Original Code is
46790:  *  The Mozilla Foundation.
46790:  * Portions created by the Initial Developer are Copyright (C) 2010
46790:  * the Initial Developer. All Rights Reserved.
46790:  *
46790:  * Contributor(s):
46790:  *   Daniel Witte <dwitte@mozilla.com>
46887:  *   Frederic Plourde <bugzillaFred@gmail.com>
46887:  *   Jason Duell <jduell.mcbugs@gmail.com>
46790:  *
46790:  * Alternatively, the contents of this file may be used under the terms of
46790:  * either the GNU General Public License Version 2 or later (the "GPL"), or
46790:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
46790:  * in which case the provisions of the GPL or the LGPL are applicable instead
46790:  * of those above. If you wish to allow use of your version of this file only
46790:  * under the terms of either the GPL or the LGPL, and not to allow others to
46790:  * use your version of this file under the terms of the MPL, indicate your
46790:  * decision by deleting the provisions above and replace them with the notice
46790:  * and other provisions required by the GPL or the LGPL. If you do not delete
46790:  * the provisions above, a recipient may use your version of this file under
46790:  * the terms of any one of the MPL, the GPL or the LGPL.
46790:  *
46790:  * ***** END LICENSE BLOCK ***** */
46790: 
46790: #include "mozilla/net/HttpBaseChannel.h"
46790: 
46790: #include "nsHttpHandler.h"
46790: #include "nsMimeTypes.h"
46790: #include "nsNetUtil.h"
46790: 
49375: #include "nsICachingChannel.h"
49375: #include "nsISeekableStream.h"
70188: #include "nsITimedChannel.h"
49375: #include "nsIEncodedChannel.h"
49375: #include "nsIResumableChannel.h"
49375: #include "nsIApplicationCacheChannel.h"
49379: #include "nsEscape.h"
49375: 
69351: #include "prnetdb.h"
69351: 
46790: namespace mozilla {
46790: namespace net {
46790: 
46790: HttpBaseChannel::HttpBaseChannel()
49379:   : mStartPos(LL_MAXUINT)
49379:   , mStatus(NS_OK)
46790:   , mLoadFlags(LOAD_NORMAL)
46793:   , mPriority(PRIORITY_NORMAL)
46790:   , mCaps(0)
46790:   , mRedirectionLimit(gHttpHandler->RedirectionLimit())
80486:   , mApplyConversion(true)
80486:   , mCanceled(false)
80486:   , mIsPending(false)
80486:   , mWasOpened(false)
80486:   , mResponseHeadersModified(false)
80486:   , mAllowPipelining(true)
80486:   , mForceAllowThirdPartyCookie(false)
80486:   , mUploadStreamHasHeaders(false)
80486:   , mInheritApplicationCache(true)
80486:   , mChooseApplicationCache(false)
80486:   , mLoadedFromApplicationCache(false)
80486:   , mChannelIsForDownload(false)
80486:   , mTracingEnabled(true)
80486:   , mTimingEnabled(false)
71646:   , mSuspendCount(0)
63794:   , mRedirectedCachekeys(nsnull)
46790: {
46790:   LOG(("Creating HttpBaseChannel @%x\n", this));
46790: 
46790:   // grab a reference to the handler to ensure that it doesn't go away.
46790:   NS_ADDREF(gHttpHandler);
71558: 
71558:   // Subfields of unions cannot be targeted in an initializer list
71558:   mSelfAddr.raw.family = PR_AF_UNSPEC;
71558:   mPeerAddr.raw.family = PR_AF_UNSPEC;
46790: }
46790: 
46790: HttpBaseChannel::~HttpBaseChannel()
46790: {
46790:   LOG(("Destroying HttpBaseChannel @%x\n", this));
46790: 
63794:   // Make sure we don't leak
63794:   CleanRedirectCacheChainIfNecessary();
63794: 
46808:   gHttpHandler->Release();
46790: }
46790: 
46790: nsresult
46790: HttpBaseChannel::Init(nsIURI *aURI,
46790:                       PRUint8 aCaps,
46790:                       nsProxyInfo *aProxyInfo)
46790: {
46790:   LOG(("HttpBaseChannel::Init [this=%p]\n", this));
46790: 
46790:   NS_PRECONDITION(aURI, "null uri");
46790: 
46790:   nsresult rv = nsHashPropertyBag::Init();
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   mURI = aURI;
46790:   mOriginalURI = aURI;
46790:   mDocumentURI = nsnull;
46790:   mCaps = aCaps;
46790: 
46790:   // Construct connection info object
46790:   nsCAutoString host;
46790:   PRInt32 port = -1;
79445:   bool usingSSL = false;
46790: 
46790:   rv = mURI->SchemeIs("https", &usingSSL);
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   rv = mURI->GetAsciiHost(host);
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   // Reject the URL if it doesn't specify a host
46790:   if (host.IsEmpty())
46790:     return NS_ERROR_MALFORMED_URI;
46790: 
46790:   rv = mURI->GetPort(&port);
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   LOG(("host=%s port=%d\n", host.get(), port));
46790: 
46790:   rv = mURI->GetAsciiSpec(mSpec);
46790:   if (NS_FAILED(rv)) return rv;
46790:   LOG(("uri=%s\n", mSpec.get()));
46790: 
46790:   mConnectionInfo = new nsHttpConnectionInfo(host, port,
46790:                                              aProxyInfo, usingSSL);
46790:   if (!mConnectionInfo)
46790:     return NS_ERROR_OUT_OF_MEMORY;
46790: 
46790:   // Set default request method
46790:   mRequestHead.SetMethod(nsHttp::Get);
46790: 
46790:   // Set request headers
46790:   nsCAutoString hostLine;
46790:   rv = nsHttpHandler::GenerateHostPort(host, port, hostLine);
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   rv = mRequestHead.SetHeader(nsHttp::Host, hostLine);
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   rv = gHttpHandler->
46790:       AddStandardRequestHeaders(&mRequestHead.Headers(), aCaps,
46790:                                 !mConnectionInfo->UsingSSL() &&
46790:                                 mConnectionInfo->UsingHttpProxy());
46790: 
46790:   return rv;
46790: }
46790: 
46790: //-----------------------------------------------------------------------------
46790: // HttpBaseChannel::nsISupports
46790: //-----------------------------------------------------------------------------
46790: 
70436: NS_IMPL_ISUPPORTS_INHERITED9(HttpBaseChannel,
46790:                              nsHashPropertyBag, 
46790:                              nsIRequest,
46790:                              nsIChannel,
53988:                              nsIEncodedChannel,
46790:                              nsIHttpChannel,
46793:                              nsIHttpChannelInternal,
46887:                              nsIUploadChannel,
46887:                              nsIUploadChannel2,
70436:                              nsISupportsPriority,
70436:                              nsITraceableChannel)
46790: 
46790: //-----------------------------------------------------------------------------
46790: // HttpBaseChannel::nsIRequest
46790: //-----------------------------------------------------------------------------
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetName(nsACString& aName)
46790: {
46790:   aName = mSpec;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::IsPending(bool *aIsPending)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aIsPending);
46790:   *aIsPending = mIsPending;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetStatus(nsresult *aStatus)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aStatus);
46790:   *aStatus = mStatus;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetLoadGroup(nsILoadGroup **aLoadGroup)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aLoadGroup);
46790:   *aLoadGroup = mLoadGroup;
46790:   NS_IF_ADDREF(*aLoadGroup);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetLoadGroup(nsILoadGroup *aLoadGroup)
46790: {
46790:   mLoadGroup = aLoadGroup;
46790:   mProgressSink = nsnull;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aLoadFlags);
46790:   *aLoadFlags = mLoadFlags;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetLoadFlags(nsLoadFlags aLoadFlags)
46790: {
46790:   mLoadFlags = aLoadFlags;
46790:   return NS_OK;
46790: }
46790: 
46790: //-----------------------------------------------------------------------------
46790: // HttpBaseChannel::nsIChannel
46790: //-----------------------------------------------------------------------------
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetOriginalURI(nsIURI **aOriginalURI)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aOriginalURI);
46790:   *aOriginalURI = mOriginalURI;
46790:   NS_ADDREF(*aOriginalURI);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetOriginalURI(nsIURI *aOriginalURI)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
46790:   NS_ENSURE_ARG_POINTER(aOriginalURI);
46790:   mOriginalURI = aOriginalURI;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetURI(nsIURI **aURI)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aURI);
46790:   *aURI = mURI;
46790:   NS_ADDREF(*aURI);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46805: HttpBaseChannel::GetOwner(nsISupports **aOwner)
46805: {
46805:   NS_ENSURE_ARG_POINTER(aOwner);
46805:   *aOwner = mOwner;
46805:   NS_IF_ADDREF(*aOwner);
46805:   return NS_OK;
46805: }
46805: 
46805: NS_IMETHODIMP
46805: HttpBaseChannel::SetOwner(nsISupports *aOwner)
46805: {
46805:   mOwner = aOwner;
46805:   return NS_OK;
46805: }
46805: 
46805: NS_IMETHODIMP
46790: HttpBaseChannel::GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks)
46790: {
46790:   *aCallbacks = mCallbacks;
46790:   NS_IF_ADDREF(*aCallbacks);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetNotificationCallbacks(nsIInterfaceRequestor *aCallbacks)
46790: {
46790:   mCallbacks = aCallbacks;
46790:   mProgressSink = nsnull;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetContentType(nsACString& aContentType)
46790: {
46790:   if (!mResponseHead) {
46790:     aContentType.Truncate();
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   }
46790: 
46790:   if (!mResponseHead->ContentType().IsEmpty()) {
46790:     aContentType = mResponseHead->ContentType();
46790:     return NS_OK;
46790:   }
46790: 
46790:   aContentType.AssignLiteral(UNKNOWN_CONTENT_TYPE);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetContentType(const nsACString& aContentType)
46790: {
46790:   if (mListener || mWasOpened) {
46790:     if (!mResponseHead)
46790:       return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:     nsCAutoString contentTypeBuf, charsetBuf;
79445:     bool hadCharset;
46790:     net_ParseContentType(aContentType, contentTypeBuf, charsetBuf, &hadCharset);
46790: 
46790:     mResponseHead->SetContentType(contentTypeBuf);
46790: 
46790:     // take care not to stomp on an existing charset
46790:     if (hadCharset)
46790:       mResponseHead->SetContentCharset(charsetBuf);
46790: 
46790:   } else {
46790:     // We are being given a content-type hint.
79445:     bool dummy;
46790:     net_ParseContentType(aContentType, mContentTypeHint, mContentCharsetHint,
46790:                          &dummy);
46790:   }
46790:   
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetContentCharset(nsACString& aContentCharset)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:   aContentCharset = mResponseHead->ContentCharset();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetContentCharset(const nsACString& aContentCharset)
46790: {
46790:   if (mListener) {
46790:     if (!mResponseHead)
46790:       return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:     mResponseHead->SetContentCharset(aContentCharset);
46790:   } else {
46790:     // Charset hint
46790:     mContentCharsetHint = aContentCharset;
46790:   }
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
78165: HttpBaseChannel::GetContentDisposition(PRUint32 *aContentDisposition)
78165: {
78165:   nsresult rv;
78165:   nsCString header;
78165: 
78165:   rv = GetContentDispositionHeader(header);
78165:   if (NS_FAILED(rv))
78165:     return rv;
78165: 
78165:   *aContentDisposition = NS_GetContentDispositionFromHeader(header, this);
78165: 
78165:   return NS_OK;
78165: }
78165: 
78165: NS_IMETHODIMP
78165: HttpBaseChannel::GetContentDispositionFilename(nsAString& aContentDispositionFilename)
78165: {
78165:   aContentDispositionFilename.Truncate();
78165: 
78165:   nsresult rv;
78165:   nsCString header;
78165: 
78165:   rv = GetContentDispositionHeader(header);
78165:   if (NS_FAILED(rv))
78165:     return rv;
78165: 
78165:   return NS_GetFilenameFromDisposition(aContentDispositionFilename,
78165:                                        header, mURI);
78165: }
78165: 
78165: NS_IMETHODIMP
78165: HttpBaseChannel::GetContentDispositionHeader(nsACString& aContentDispositionHeader)
78165: {
78165:   if (!mResponseHead)
78165:     return NS_ERROR_NOT_AVAILABLE;
78165: 
78165:   nsresult rv = mResponseHead->GetHeader(nsHttp::Content_Disposition,
78165:                                          aContentDispositionHeader);
78165:   if (NS_FAILED(rv) || aContentDispositionHeader.IsEmpty())
78165:     return NS_ERROR_NOT_AVAILABLE;
78165: 
78165:   return NS_OK;
78165: }
78165: 
78165: NS_IMETHODIMP
51740: HttpBaseChannel::GetContentLength(PRInt32 *aContentLength)
46790: {
51740:   NS_ENSURE_ARG_POINTER(aContentLength);
51740: 
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
51740:   // XXX truncates to 32 bit
46790:   *aContentLength = mResponseHead->ContentLength();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
51740: HttpBaseChannel::SetContentLength(PRInt32 value)
46790: {
53988:   NS_NOTYETIMPLEMENTED("HttpBaseChannel::SetContentLength");
46790:   return NS_ERROR_NOT_IMPLEMENTED;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::Open(nsIInputStream **aResult)
46790: {
46790:   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_IN_PROGRESS);
46790:   return NS_ImplementChannelOpen(this, aResult);
46790: }
46790: 
46790: //-----------------------------------------------------------------------------
46887: // HttpBaseChannel::nsIUploadChannel
46887: //-----------------------------------------------------------------------------
46887: 
46887: NS_IMETHODIMP
46887: HttpBaseChannel::GetUploadStream(nsIInputStream **stream)
46887: {
46887:   NS_ENSURE_ARG_POINTER(stream);
46887:   *stream = mUploadStream;
46887:   NS_IF_ADDREF(*stream);
46887:   return NS_OK;
46887: }
46887: 
46887: NS_IMETHODIMP
46887: HttpBaseChannel::SetUploadStream(nsIInputStream *stream,
46887:                                const nsACString &contentType,
46887:                                PRInt32 contentLength)
46887: {
46887:   // NOTE: for backwards compatibility and for compatibility with old style
46887:   // plugins, |stream| may include headers, specifically Content-Type and
46887:   // Content-Length headers.  in this case, |contentType| and |contentLength|
46887:   // would be unspecified.  this is traditionally the case of a POST request,
46887:   // and so we select POST as the request method if contentType and
46887:   // contentLength are unspecified.
46887: 
46887:   if (stream) {
46887:     if (contentType.IsEmpty()) {
80486:       mUploadStreamHasHeaders = true;
46887:       mRequestHead.SetMethod(nsHttp::Post); // POST request
46887:     } else {
46887:       if (contentLength < 0) {
46887:         // Not really kosher to assume Available == total length of
46887:         // stream, but apparently works for the streams we see here.
46887:         stream->Available((PRUint32 *) &contentLength);
46887:         if (contentLength < 0) {
46887:           NS_ERROR("unable to determine content length");
46887:           return NS_ERROR_FAILURE;
46887:         }
46887:       }
46887:       // SetRequestHeader propagates headers to chrome if HttpChannelChild 
46887:       nsCAutoString contentLengthStr;
46887:       contentLengthStr.AppendInt(PRInt64(contentLength));
46887:       SetRequestHeader(NS_LITERAL_CSTRING("Content-Length"), contentLengthStr, 
80486:                        false);
46887:       SetRequestHeader(NS_LITERAL_CSTRING("Content-Type"), contentType, 
80486:                        false);
80486:       mUploadStreamHasHeaders = false;
46887:       mRequestHead.SetMethod(nsHttp::Put); // PUT request
46887:     }
46887:   } else {
80486:     mUploadStreamHasHeaders = false;
46887:     mRequestHead.SetMethod(nsHttp::Get); // revert to GET request
46887:   }
46887:   mUploadStream = stream;
46887:   return NS_OK;
46887: }
46887: 
46887: //-----------------------------------------------------------------------------
46887: // HttpBaseChannel::nsIUploadChannel2
46887: //-----------------------------------------------------------------------------
46887: 
46887: NS_IMETHODIMP
46887: HttpBaseChannel::ExplicitSetUploadStream(nsIInputStream *aStream,
46887:                                        const nsACString &aContentType,
46887:                                        PRInt64 aContentLength,
46887:                                        const nsACString &aMethod,
79445:                                        bool aStreamHasHeaders)
46887: {
46887:   // Ensure stream is set and method is valid 
46887:   NS_ENSURE_TRUE(aStream, NS_ERROR_FAILURE);
46887: 
46887:   if (aContentLength < 0 && !aStreamHasHeaders) {
46887:     PRUint32 streamLength;
46887:     aStream->Available(&streamLength);
46887:     aContentLength = streamLength;
46887:     if (aContentLength < 0) {
46887:       NS_ERROR("unable to determine content length");
46887:       return NS_ERROR_FAILURE;
46887:     }
46887:   }
46887: 
46887:   nsresult rv = SetRequestMethod(aMethod);
46887:   NS_ENSURE_SUCCESS(rv, rv);
46887: 
46887:   if (!aStreamHasHeaders) {
46887:     // SetRequestHeader propagates headers to chrome if HttpChannelChild 
46887:     nsCAutoString contentLengthStr;
46887:     contentLengthStr.AppendInt(aContentLength);
46887:     SetRequestHeader(NS_LITERAL_CSTRING("Content-Length"), contentLengthStr, 
80486:                      false);
46887:     SetRequestHeader(NS_LITERAL_CSTRING("Content-Type"), aContentType, 
80486:                      false);
46887:   }
46887: 
46887:   mUploadStreamHasHeaders = aStreamHasHeaders;
46887:   mUploadStream = aStream;
46887:   return NS_OK;
46887: }
46887: 
71003: NS_IMETHODIMP
79445: HttpBaseChannel::GetUploadStreamHasHeaders(bool *hasHeaders)
71003: {
71003:   NS_ENSURE_ARG(hasHeaders);
71003: 
71003:   *hasHeaders = mUploadStreamHasHeaders;
71003:   return NS_OK;
71003: }
71003: 
46887: //-----------------------------------------------------------------------------
53988: // HttpBaseChannel::nsIEncodedChannel
53988: //-----------------------------------------------------------------------------
53988: 
53988: NS_IMETHODIMP
79445: HttpBaseChannel::GetApplyConversion(bool *value)
53988: {
53988:   *value = mApplyConversion;
53988:   return NS_OK;
53988: }
53988: 
53988: NS_IMETHODIMP
79445: HttpBaseChannel::SetApplyConversion(bool value)
53988: {
53988:   LOG(("HttpBaseChannel::SetApplyConversion [this=%p value=%d]\n", this, value));
53988:   mApplyConversion = value;
53988:   return NS_OK;
53988: }
53988: 
53990: nsresult
53990: HttpBaseChannel::ApplyContentConversions()
53990: {
53990:   if (!mResponseHead)
53990:     return NS_OK;
53990: 
55240:   LOG(("HttpBaseChannel::ApplyContentConversions [this=%p]\n", this));
53990: 
53990:   if (!mApplyConversion) {
53990:     LOG(("not applying conversion per mApplyConversion\n"));
53990:     return NS_OK;
53990:   }
53990: 
53990:   const char *val = mResponseHead->PeekHeader(nsHttp::Content_Encoding);
53990:   if (gHttpHandler->IsAcceptableEncoding(val)) {
53990:     nsCOMPtr<nsIStreamConverterService> serv;
53990:     nsresult rv = gHttpHandler->
53990:             GetStreamConverterService(getter_AddRefs(serv));
53990:     // we won't fail to load the page just because we couldn't load the
53990:     // stream converter service.. carry on..
53990:     if (NS_SUCCEEDED(rv)) {
53990:       nsCOMPtr<nsIStreamListener> converter;
53990:       nsCAutoString from(val);
53990:       ToLowerCase(from);
53990:       rv = serv->AsyncConvertData(from.get(),
53990:                                   "uncompressed",
53990:                                   mListener,
53990:                                   mListenerContext,
53990:                                   getter_AddRefs(converter));
53990:       if (NS_SUCCEEDED(rv)) {
53990:         LOG(("converter installed from \'%s\' to \'uncompressed\'\n", val));
53990:         mListener = converter;
53990:       }
53990:     }
53990:   } else if (val != nsnull) {
53990:     LOG(("Unknown content encoding '%s', ignoring\n", val));
53990:   }
53990: 
53990:   return NS_OK;
53990: }
53990: 
53988: NS_IMETHODIMP
53988: HttpBaseChannel::GetContentEncodings(nsIUTF8StringEnumerator** aEncodings)
53988: {
53988:   if (!mResponseHead) {
53988:     *aEncodings = nsnull;
53988:     return NS_OK;
53988:   }
53988:     
53988:   const char *encoding = mResponseHead->PeekHeader(nsHttp::Content_Encoding);
53988:   if (!encoding) {
53988:     *aEncodings = nsnull;
53988:     return NS_OK;
53988:   }
53988:   nsContentEncodings* enumerator = new nsContentEncodings(this, encoding);
53988:   NS_ADDREF(*aEncodings = enumerator);
53988:   return NS_OK;
53988: }
53988: 
53988: //-----------------------------------------------------------------------------
53988: // HttpBaseChannel::nsContentEncodings <public>
53988: //-----------------------------------------------------------------------------
53988: 
53988: HttpBaseChannel::nsContentEncodings::nsContentEncodings(nsIHttpChannel* aChannel,
53988:                                                         const char* aEncodingHeader)
53988:   : mEncodingHeader(aEncodingHeader)
53988:   , mChannel(aChannel)
80486:   , mReady(false)
53988: {
53988:   mCurEnd = aEncodingHeader + strlen(aEncodingHeader);
53988:   mCurStart = mCurEnd;
53988: }
53988:     
53988: HttpBaseChannel::nsContentEncodings::~nsContentEncodings()
53988: {
53988: }
53988: 
53988: //-----------------------------------------------------------------------------
53988: // HttpBaseChannel::nsContentEncodings::nsISimpleEnumerator
53988: //-----------------------------------------------------------------------------
53988: 
53988: NS_IMETHODIMP
79445: HttpBaseChannel::nsContentEncodings::HasMore(bool* aMoreEncodings)
53988: {
53988:   if (mReady) {
80486:     *aMoreEncodings = true;
53988:     return NS_OK;
53988:   }
53988: 
53988:   nsresult rv = PrepareForNext();
53988:   *aMoreEncodings = NS_SUCCEEDED(rv);
53988:   return NS_OK;
53988: }
53988: 
53988: NS_IMETHODIMP
53988: HttpBaseChannel::nsContentEncodings::GetNext(nsACString& aNextEncoding)
53988: {
53988:   aNextEncoding.Truncate();
53988:   if (!mReady) {
53988:     nsresult rv = PrepareForNext();
53988:     if (NS_FAILED(rv)) {
53988:       return NS_ERROR_FAILURE;
53988:     }
53988:   }
53988: 
53988:   const nsACString & encoding = Substring(mCurStart, mCurEnd);
53988: 
53988:   nsACString::const_iterator start, end;
53988:   encoding.BeginReading(start);
53988:   encoding.EndReading(end);
53988: 
79445:   bool haveType = false;
53988:   if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("gzip"), start, end)) {
53988:     aNextEncoding.AssignLiteral(APPLICATION_GZIP);
80486:     haveType = true;
53988:   }
53988: 
53988:   if (!haveType) {
53988:     encoding.BeginReading(start);
53988:     if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("compress"), start, end)) {
53988:       aNextEncoding.AssignLiteral(APPLICATION_COMPRESS);
80486:       haveType = true;
53988:     }
53988:   }
53988:     
53988:   if (!haveType) {
53988:     encoding.BeginReading(start);
53988:     if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("deflate"), start, end)) {
53988:       aNextEncoding.AssignLiteral(APPLICATION_ZIP);
80486:       haveType = true;
53988:     }
53988:   }
53988: 
53988:   // Prepare to fetch the next encoding
53988:   mCurEnd = mCurStart;
80486:   mReady = false;
53988:   
53988:   if (haveType)
53988:     return NS_OK;
53988: 
53988:   NS_WARNING("Unknown encoding type");
53988:   return NS_ERROR_FAILURE;
53988: }
53988: 
53988: //-----------------------------------------------------------------------------
53988: // HttpBaseChannel::nsContentEncodings::nsISupports
53988: //-----------------------------------------------------------------------------
53988: 
53988: NS_IMPL_ISUPPORTS1(HttpBaseChannel::nsContentEncodings, nsIUTF8StringEnumerator)
53988: 
53988: //-----------------------------------------------------------------------------
53988: // HttpBaseChannel::nsContentEncodings <private>
53988: //-----------------------------------------------------------------------------
53988: 
53988: nsresult
53988: HttpBaseChannel::nsContentEncodings::PrepareForNext(void)
53988: {
53988:   NS_ASSERTION(mCurStart == mCurEnd, "Indeterminate state");
53988:     
53988:   // At this point both mCurStart and mCurEnd point to somewhere
53988:   // past the end of the next thing we want to return
53988:     
53988:   while (mCurEnd != mEncodingHeader) {
53988:     --mCurEnd;
53988:     if (*mCurEnd != ',' && !nsCRT::IsAsciiSpace(*mCurEnd))
53988:       break;
53988:   }
53988:   if (mCurEnd == mEncodingHeader)
53988:     return NS_ERROR_NOT_AVAILABLE; // no more encodings
53988:   ++mCurEnd;
53988:         
53988:   // At this point mCurEnd points to the first char _after_ the
53988:   // header we want.  Furthermore, mCurEnd - 1 != mEncodingHeader
53988:     
53988:   mCurStart = mCurEnd - 1;
53988:   while (mCurStart != mEncodingHeader &&
53988:          *mCurStart != ',' && !nsCRT::IsAsciiSpace(*mCurStart))
53988:     --mCurStart;
53988:   if (*mCurStart == ',' || nsCRT::IsAsciiSpace(*mCurStart))
53988:     ++mCurStart; // we stopped because of a weird char, so move up one
53988:         
53988:   // At this point mCurStart and mCurEnd bracket the encoding string
53988:   // we want.  Check that it's not "identity"
53988:   if (Substring(mCurStart, mCurEnd).Equals("identity",
53988:                                            nsCaseInsensitiveCStringComparator())) {
53988:     mCurEnd = mCurStart;
53988:     return PrepareForNext();
53988:   }
53988:         
80486:   mReady = true;
53988:   return NS_OK;
53988: }
53988: 
53988: 
53988: //-----------------------------------------------------------------------------
46790: // HttpBaseChannel::nsIHttpChannel
46790: //-----------------------------------------------------------------------------
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetRequestMethod(nsACString& aMethod)
46790: {
78638:   aMethod = mRequestHead.Method();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetRequestMethod(const nsACString& aMethod)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
78638:   const nsCString& flatMethod = PromiseFlatCString(aMethod);
46790: 
46790:   // Method names are restricted to valid HTTP tokens.
78638:   if (!nsHttp::IsValidToken(flatMethod))
46790:     return NS_ERROR_INVALID_ARG;
46790: 
78638:   nsHttpAtom atom = nsHttp::ResolveAtom(flatMethod.get());
78638:   if (!atom)
78638:     return NS_ERROR_FAILURE;
46790: 
46790:   mRequestHead.SetMethod(atom);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetReferrer(nsIURI **referrer)
46790: {
46790:   NS_ENSURE_ARG_POINTER(referrer);
46790:   *referrer = mReferrer;
46790:   NS_IF_ADDREF(*referrer);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetReferrer(nsIURI *referrer)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
46790:   // clear existing referrer, if any
46790:   mReferrer = nsnull;
46790:   mRequestHead.ClearHeader(nsHttp::Referer);
46790: 
46790:   if (!referrer)
46790:       return NS_OK;
46790: 
46790:   // check referrer blocking pref
46790:   PRUint32 referrerLevel;
46790:   if (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI)
46790:     referrerLevel = 1; // user action
46790:   else
46790:     referrerLevel = 2; // inline content
46790:   if (gHttpHandler->ReferrerLevel() < referrerLevel)
46790:     return NS_OK;
46790: 
46790:   nsCOMPtr<nsIURI> referrerGrip;
46790:   nsresult rv;
79445:   bool match;
46790: 
46790:   //
46790:   // Strip off "wyciwyg://123/" from wyciwyg referrers.
46790:   //
46790:   // XXX this really belongs elsewhere since wyciwyg URLs aren't part of necko.
46790:   //     perhaps some sort of generic nsINestedURI could be used.  then, if an URI
46790:   //     fails the whitelist test, then we could check for an inner URI and try
46790:   //     that instead.  though, that might be too automatic.
46790:   // 
46790:   rv = referrer->SchemeIs("wyciwyg", &match);
46790:   if (NS_FAILED(rv)) return rv;
46790:   if (match) {
46790:     nsCAutoString path;
46790:     rv = referrer->GetPath(path);
46790:     if (NS_FAILED(rv)) return rv;
46790: 
46790:     PRUint32 pathLength = path.Length();
46790:     if (pathLength <= 2) return NS_ERROR_FAILURE;
46790: 
46790:     // Path is of the form "//123/http://foo/bar", with a variable number of digits.
46790:     // To figure out where the "real" URL starts, search path for a '/', starting at 
46790:     // the third character.
46790:     PRInt32 slashIndex = path.FindChar('/', 2);
46790:     if (slashIndex == kNotFound) return NS_ERROR_FAILURE;
46790: 
46790:     // Get the charset of the original URI so we can pass it to our fixed up URI.
46790:     nsCAutoString charset;
46790:     referrer->GetOriginCharset(charset);
46790: 
46790:     // Replace |referrer| with a URI without wyciwyg://123/.
46790:     rv = NS_NewURI(getter_AddRefs(referrerGrip),
46790:                    Substring(path, slashIndex + 1, pathLength - slashIndex - 1),
46790:                    charset.get());
46790:     if (NS_FAILED(rv)) return rv;
46790: 
46790:     referrer = referrerGrip.get();
46790:   }
46790: 
46790:   //
46790:   // block referrer if not on our white list...
46790:   //
46790:   static const char *const referrerWhiteList[] = {
46790:     "http",
46790:     "https",
46790:     "ftp",
46790:     "gopher",
46790:     nsnull
46790:   };
80486:   match = false;
46790:   const char *const *scheme = referrerWhiteList;
46790:   for (; *scheme && !match; ++scheme) {
46790:     rv = referrer->SchemeIs(*scheme, &match);
46790:     if (NS_FAILED(rv)) return rv;
46790:   }
46790:   if (!match)
46790:     return NS_OK; // kick out....
46790: 
46790:   //
46790:   // Handle secure referrals.
46790:   //
46790:   // Support referrals from a secure server if this is a secure site
46790:   // and (optionally) if the host names are the same.
46790:   //
46790:   rv = referrer->SchemeIs("https", &match);
46790:   if (NS_FAILED(rv)) return rv;
46790:   if (match) {
46790:     rv = mURI->SchemeIs("https", &match);
46790:     if (NS_FAILED(rv)) return rv;
46790:     if (!match)
46790:       return NS_OK;
46790: 
46790:     if (!gHttpHandler->SendSecureXSiteReferrer()) {
46790:       nsCAutoString referrerHost;
46790:       nsCAutoString host;
46790: 
46790:       rv = referrer->GetAsciiHost(referrerHost);
46790:       if (NS_FAILED(rv)) return rv;
46790: 
46790:       rv = mURI->GetAsciiHost(host);
46790:       if (NS_FAILED(rv)) return rv;
46790: 
46790:       // GetAsciiHost returns lowercase hostname.
46790:       if (!referrerHost.Equals(host))
46790:         return NS_OK;
46790:     }
46790:   }
46790: 
46790:   nsCOMPtr<nsIURI> clone;
46790:   //
46790:   // we need to clone the referrer, so we can:
46790:   //  (1) modify it
46790:   //  (2) keep a reference to it after returning from this function
46790:   //
70215:   // Use CloneIgnoringRef to strip away any fragment per RFC 2616 section 14.36
70215:   rv = referrer->CloneIgnoringRef(getter_AddRefs(clone));
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   // strip away any userpass; we don't want to be giving out passwords ;-)
70215:   rv = clone->SetUserPass(EmptyCString());
70215:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   nsCAutoString spec;
46790:   rv = clone->GetAsciiSpec(spec);
46790:   if (NS_FAILED(rv)) return rv;
46790: 
46790:   // finally, remember the referrer URI and set the Referer header.
46790:   mReferrer = clone;
46790:   mRequestHead.SetHeader(nsHttp::Referer, spec);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetRequestHeader(const nsACString& aHeader,
46790:                                   nsACString& aValue)
46790: {
46790:   // XXX might be better to search the header list directly instead of
46790:   // hitting the http atom hash table.
46790:   nsHttpAtom atom = nsHttp::ResolveAtom(aHeader);
46790:   if (!atom)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:   return mRequestHead.GetHeader(atom, aValue);
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetRequestHeader(const nsACString& aHeader,
46790:                                   const nsACString& aValue,
79445:                                   bool aMerge)
46790: {
46790:   const nsCString &flatHeader = PromiseFlatCString(aHeader);
46790:   const nsCString &flatValue  = PromiseFlatCString(aValue);
46790: 
46790:   LOG(("HttpBaseChannel::SetRequestHeader [this=%p header=\"%s\" value=\"%s\" merge=%u]\n",
46790:       this, flatHeader.get(), flatValue.get(), aMerge));
46790: 
46790:   // Header names are restricted to valid HTTP tokens.
46790:   if (!nsHttp::IsValidToken(flatHeader))
46790:     return NS_ERROR_INVALID_ARG;
46790:   
46790:   // Header values MUST NOT contain line-breaks.  RFC 2616 technically
46790:   // permits CTL characters, including CR and LF, in header values provided
46790:   // they are quoted.  However, this can lead to problems if servers do not
46790:   // interpret quoted strings properly.  Disallowing CR and LF here seems
46790:   // reasonable and keeps things simple.  We also disallow a null byte.
46790:   if (flatValue.FindCharInSet("\r\n") != kNotFound ||
46790:       flatValue.Length() != strlen(flatValue.get()))
46790:     return NS_ERROR_INVALID_ARG;
46790: 
46790:   nsHttpAtom atom = nsHttp::ResolveAtom(flatHeader.get());
46790:   if (!atom) {
46790:     NS_WARNING("failed to resolve atom");
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   }
46790: 
46790:   return mRequestHead.SetHeader(atom, flatValue, aMerge);
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::VisitRequestHeaders(nsIHttpHeaderVisitor *visitor)
46790: {
46790:   return mRequestHead.Headers().VisitHeaders(visitor);
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetResponseHeader(const nsACString &header, nsACString &value)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:   nsHttpAtom atom = nsHttp::ResolveAtom(header);
46790:   if (!atom)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:   return mResponseHead->GetHeader(atom, value);
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetResponseHeader(const nsACString& header, 
46790:                                    const nsACString& value, 
79445:                                    bool merge)
46790: {
46790:   LOG(("HttpBaseChannel::SetResponseHeader [this=%p header=\"%s\" value=\"%s\" merge=%u]\n",
46790:       this, PromiseFlatCString(header).get(), PromiseFlatCString(value).get(), merge));
46790: 
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:   nsHttpAtom atom = nsHttp::ResolveAtom(header);
46790:   if (!atom)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790: 
46790:   // these response headers must not be changed 
46790:   if (atom == nsHttp::Content_Type ||
46790:       atom == nsHttp::Content_Length ||
46790:       atom == nsHttp::Content_Encoding ||
46790:       atom == nsHttp::Trailer ||
46790:       atom == nsHttp::Transfer_Encoding)
46790:     return NS_ERROR_ILLEGAL_VALUE;
46790: 
80486:   mResponseHeadersModified = true;
46790: 
46790:   return mResponseHead->SetHeader(atom, value, merge);
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::VisitResponseHeaders(nsIHttpHeaderVisitor *visitor)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   return mResponseHead->Headers().VisitHeaders(visitor);
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::GetAllowPipelining(bool *value)
46790: {
46790:   NS_ENSURE_ARG_POINTER(value);
46790:   *value = mAllowPipelining;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::SetAllowPipelining(bool value)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
46790:   mAllowPipelining = value;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetRedirectionLimit(PRUint32 *value)
46790: {
46790:   NS_ENSURE_ARG_POINTER(value);
46790:   *value = mRedirectionLimit;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetRedirectionLimit(PRUint32 value)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
71173:   mRedirectionLimit = NS_MIN<PRUint32>(value, 0xff);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::IsNoStoreResponse(bool *value)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   *value = mResponseHead->NoStore();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::IsNoCacheResponse(bool *value)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   *value = mResponseHead->NoCache();
46790:   if (!*value)
46790:     *value = mResponseHead->ExpiresInPast();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetResponseStatus(PRUint32 *aValue)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   *aValue = mResponseHead->Status();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetResponseStatusText(nsACString& aValue)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   aValue = mResponseHead->StatusText();
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::GetRequestSucceeded(bool *aValue)
46790: {
46790:   if (!mResponseHead)
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   PRUint32 status = mResponseHead->Status();
46790:   *aValue = (status / 100 == 2);
46790:   return NS_OK;
46790: }
46790: 
46790: //-----------------------------------------------------------------------------
46790: // HttpBaseChannel::nsIHttpChannelInternal
46790: //-----------------------------------------------------------------------------
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetDocumentURI(nsIURI **aDocumentURI)
46790: {
46790:   NS_ENSURE_ARG_POINTER(aDocumentURI);
46790:   *aDocumentURI = mDocumentURI;
46790:   NS_IF_ADDREF(*aDocumentURI);
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetDocumentURI(nsIURI *aDocumentURI)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
46790:   mDocumentURI = aDocumentURI;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetRequestVersion(PRUint32 *major, PRUint32 *minor)
46790: {
46790:   nsHttpVersion version = mRequestHead.Version();
46790: 
46790:   if (major) { *major = version / 10; }
46790:   if (minor) { *minor = version % 10; }
46790: 
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::GetResponseVersion(PRUint32 *major, PRUint32 *minor)
46790: {
46790:   if (!mResponseHead)
46790:   {
46790:     *major = *minor = 0; // we should at least be kind about it
46790:     return NS_ERROR_NOT_AVAILABLE;
46790:   }
46790: 
46790:   nsHttpVersion version = mResponseHead->Version();
46790: 
46790:   if (major) { *major = version / 10; }
46790:   if (minor) { *minor = version % 10; }
46790: 
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
46790: HttpBaseChannel::SetCookie(const char *aCookieHeader)
46790: {
46790:   if (mLoadFlags & LOAD_ANONYMOUS)
46790:     return NS_OK;
46790: 
46790:   // empty header isn't an error
46790:   if (!(aCookieHeader && *aCookieHeader))
46790:     return NS_OK;
46790: 
46790:   nsICookieService *cs = gHttpHandler->GetCookieService();
46790:   NS_ENSURE_TRUE(cs, NS_ERROR_FAILURE);
46790: 
49378:   return cs->SetCookieStringFromHttp(mURI, nsnull, nsnull, aCookieHeader,
46790:                                      mResponseHead->PeekHeader(nsHttp::Date),
46790:                                      this);
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::GetForceAllowThirdPartyCookie(bool *aForce)
46790: {
46790:   *aForce = mForceAllowThirdPartyCookie;
46790:   return NS_OK;
46790: }
46790: 
46790: NS_IMETHODIMP
79445: HttpBaseChannel::SetForceAllowThirdPartyCookie(bool aForce)
46790: {
46790:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
46790: 
46790:   mForceAllowThirdPartyCookie = aForce;
46790:   return NS_OK;
46790: }
46790: 
48304: NS_IMETHODIMP
79445: HttpBaseChannel::GetCanceled(bool *aCanceled)
48304: {
48304:   *aCanceled = mCanceled;
48304:   return NS_OK;
48304: }
48304: 
52366: NS_IMETHODIMP
79445: HttpBaseChannel::GetChannelIsForDownload(bool *aChannelIsForDownload)
52366: {
52366:   *aChannelIsForDownload = mChannelIsForDownload;
52366:   return NS_OK;
52366: }
52366: 
52366: NS_IMETHODIMP
79445: HttpBaseChannel::SetChannelIsForDownload(bool aChannelIsForDownload)
52366: {
52366:   mChannelIsForDownload = aChannelIsForDownload;
52366:   return NS_OK;
52366: }
52366: 
63794: NS_IMETHODIMP
63794: HttpBaseChannel::SetCacheKeysRedirectChain(nsTArray<nsCString> *cacheKeys)
63794: {
63794:   mRedirectedCachekeys = cacheKeys;
63794:   return NS_OK;
63794: }
63794: 
69351: NS_IMETHODIMP
69351: HttpBaseChannel::GetLocalAddress(nsACString& addr)
69351: {
69351:   if (mSelfAddr.raw.family == PR_AF_UNSPEC)
69351:     return NS_ERROR_NOT_AVAILABLE;
69351: 
69351:   addr.SetCapacity(64);
69351:   PR_NetAddrToString(&mSelfAddr, addr.BeginWriting(), 64);
69351:   addr.SetLength(strlen(addr.BeginReading()));
69351: 
69351:   return NS_OK;
69351: }
69351: 
69351: NS_IMETHODIMP
69351: HttpBaseChannel::GetLocalPort(PRInt32* port)
69351: {
69351:   NS_ENSURE_ARG_POINTER(port);
69351: 
69351:   if (mSelfAddr.raw.family == PR_AF_INET) {
69351:     *port = (PRInt32)PR_ntohs(mSelfAddr.inet.port);
69351:   }
69351:   else if (mSelfAddr.raw.family == PR_AF_INET6) {
69351:     *port = (PRInt32)PR_ntohs(mSelfAddr.ipv6.port);
69351:   }
69351:   else
69351:     return NS_ERROR_NOT_AVAILABLE;
69351: 
69351:   return NS_OK;
69351: }
69351: 
69351: NS_IMETHODIMP
69351: HttpBaseChannel::GetRemoteAddress(nsACString& addr)
69351: {
69351:   if (mPeerAddr.raw.family == PR_AF_UNSPEC)
69351:     return NS_ERROR_NOT_AVAILABLE;
69351: 
69351:   addr.SetCapacity(64);
69351:   PR_NetAddrToString(&mPeerAddr, addr.BeginWriting(), 64);
69351:   addr.SetLength(strlen(addr.BeginReading()));
69351: 
69351:   return NS_OK;
69351: }
69351: 
69351: NS_IMETHODIMP
69351: HttpBaseChannel::GetRemotePort(PRInt32* port)
69351: {
69351:   NS_ENSURE_ARG_POINTER(port);
69351: 
69351:   if (mPeerAddr.raw.family == PR_AF_INET) {
69351:     *port = (PRInt32)PR_ntohs(mPeerAddr.inet.port);
69351:   }
69351:   else if (mPeerAddr.raw.family == PR_AF_INET6) {
69351:     *port = (PRInt32)PR_ntohs(mPeerAddr.ipv6.port);
69351:   }
69351:   else
69351:     return NS_ERROR_NOT_AVAILABLE;
69351: 
69351:   return NS_OK;
69351: }
69351: 
70090: NS_IMETHODIMP
70090: HttpBaseChannel::HTTPUpgrade(const nsACString &aProtocolName,
70090:                              nsIHttpUpgradeListener *aListener)
70090: {
70090:     NS_ENSURE_ARG(!aProtocolName.IsEmpty());
70090:     NS_ENSURE_ARG_POINTER(aListener);
70090:     
70090:     mUpgradeProtocol = aProtocolName;
70090:     mUpgradeProtocolCallback = aListener;
70090:     return NS_OK;
70090: }
70090: 
46793: //-----------------------------------------------------------------------------
46793: // HttpBaseChannel::nsISupportsPriority
46793: //-----------------------------------------------------------------------------
46793: 
46793: NS_IMETHODIMP
46793: HttpBaseChannel::GetPriority(PRInt32 *value)
46793: {
46793:   *value = mPriority;
46793:   return NS_OK;
46793: }
46793: 
46793: NS_IMETHODIMP
46793: HttpBaseChannel::AdjustPriority(PRInt32 delta)
46793: {
46793:   return SetPriority(mPriority + delta);
46793: }
46793: 
49379: //-----------------------------------------------------------------------------
49379: // HttpBaseChannel::nsIResumableChannel
49379: //-----------------------------------------------------------------------------
49379: 
49379: NS_IMETHODIMP
49379: HttpBaseChannel::GetEntityID(nsACString& aEntityID)
49379: {
49379:   // Don't return an entity ID for Non-GET requests which require
49379:   // additional data
49379:   if (mRequestHead.Method() != nsHttp::Get) {
49379:     return NS_ERROR_NOT_RESUMABLE;
49379:   }
49379: 
74732:   PRUint64 size = LL_MAXUINT;
74732:   nsCAutoString etag, lastmod;
74732:   if (mResponseHead) {
49379:     // Don't return an entity if the server sent the following header:
49379:     // Accept-Ranges: none
49379:     // Not sending the Accept-Ranges header means we can still try
49379:     // sending range requests.
49379:     const char* acceptRanges =
49379:         mResponseHead->PeekHeader(nsHttp::Accept_Ranges);
49379:     if (acceptRanges &&
49379:         !nsHttp::FindToken(acceptRanges, "bytes", HTTP_HEADER_VALUE_SEPS)) {
49379:       return NS_ERROR_NOT_RESUMABLE;
49379:     }
49379: 
49379:     size = mResponseHead->TotalEntitySize();
49379:     const char* cLastMod = mResponseHead->PeekHeader(nsHttp::Last_Modified);
49379:     if (cLastMod)
49379:       lastmod = cLastMod;
49379:     const char* cEtag = mResponseHead->PeekHeader(nsHttp::ETag);
49379:     if (cEtag)
49379:       etag = cEtag;
49379:   }
49379:   nsCString entityID;
49379:   NS_EscapeURL(etag.BeginReading(), etag.Length(), esc_AlwaysCopy |
49379:                esc_FileBaseName | esc_Forced, entityID);
49379:   entityID.Append('/');
49379:   entityID.AppendInt(PRInt64(size));
49379:   entityID.Append('/');
49379:   entityID.Append(lastmod);
49379:   // NOTE: Appending lastmod as the last part avoids having to escape it
49379: 
49379:   aEntityID = entityID;
49379: 
49379:   return NS_OK;
49379: }
49379: 
70436: //-----------------------------------------------------------------------------
70436: // nsStreamListenerWrapper <private>
70436: //-----------------------------------------------------------------------------
70436: 
70436: // Wrapper class to make replacement of nsHttpChannel's listener
70436: // from JavaScript possible. It is workaround for bug 433711.
70436: class nsStreamListenerWrapper : public nsIStreamListener
70436: {
70436: public:
70436:   nsStreamListenerWrapper(nsIStreamListener *listener);
70436: 
70436:   NS_DECL_ISUPPORTS
70436:   NS_FORWARD_NSIREQUESTOBSERVER(mListener->)
70436:   NS_FORWARD_NSISTREAMLISTENER(mListener->)
70436: 
70436: private:
70436:   ~nsStreamListenerWrapper() {}
70436:   nsCOMPtr<nsIStreamListener> mListener;
70436: };
70436: 
70436: nsStreamListenerWrapper::nsStreamListenerWrapper(nsIStreamListener *listener)
70436:   : mListener(listener)
70436: {
70436:   NS_ASSERTION(mListener, "no stream listener specified");
70436: }
70436: 
70436: NS_IMPL_ISUPPORTS2(nsStreamListenerWrapper,
70436:                    nsIStreamListener,
70436:                    nsIRequestObserver)
70436: 
70436: //-----------------------------------------------------------------------------
70436: // nsHttpChannel::nsITraceableChannel
70436: //-----------------------------------------------------------------------------
70436: 
70436: NS_IMETHODIMP
70436: HttpBaseChannel::SetNewListener(nsIStreamListener *aListener, nsIStreamListener **_retval)
70436: {
70436:   if (!mTracingEnabled)
70436:     return NS_ERROR_FAILURE;
70436: 
70436:   NS_ENSURE_ARG_POINTER(aListener);
70436: 
70436:   nsCOMPtr<nsIStreamListener> wrapper = new nsStreamListenerWrapper(mListener);
70436: 
70436:   wrapper.forget(_retval);
70436:   mListener = aListener;
70436:   return NS_OK;
70436: }
46790: 
46906: //-----------------------------------------------------------------------------
46906: // HttpBaseChannel helpers
46906: //-----------------------------------------------------------------------------
46906: 
46906: void
71646: HttpBaseChannel::DoNotifyListener()
71646: {
80486:   // Make sure mIsPending is set to false. At this moment we are done from
71646:   // the point of view of our consumer and we have to report our self
71646:   // as not-pending.
71646:   if (mListener) {
71646:     mListener->OnStartRequest(this, mListenerContext);
80486:     mIsPending = false;
71646:     mListener->OnStopRequest(this, mListenerContext, mStatus);
71646:     mListener = 0;
71646:     mListenerContext = 0;
71646:   } else {
80486:     mIsPending = false;
71646:   }
71646:   // We have to make sure to drop the reference to the callbacks too
71646:   mCallbacks = nsnull;
71646:   mProgressSink = nsnull;
71646: 
71646:   DoNotifyListenerCleanup();
71646: }
71646: 
71646: void
46906: HttpBaseChannel::AddCookiesToRequest()
46906: {
46906:   if (mLoadFlags & LOAD_ANONYMOUS) {
46906:     return;
46790:   }
46790: 
54895:   bool useCookieService = 
54895:     (XRE_GetProcessType() == GeckoProcessType_Default);
46906:   nsXPIDLCString cookie;
54895:   if (useCookieService) {
46906:     nsICookieService *cs = gHttpHandler->GetCookieService();
46906:     if (cs) {
46906:       cs->GetCookieStringFromHttp(mURI,
54895:                                   nsnull,
49378:                                   this, getter_Copies(cookie));
46906:     }
46906: 
46906:     if (cookie.IsEmpty()) {
46906:       cookie = mUserSetCookieHeader;
46906:     }
46906:     else if (!mUserSetCookieHeader.IsEmpty()) {
46906:       cookie.Append(NS_LITERAL_CSTRING("; ") + mUserSetCookieHeader);
46906:     }
54895:   }
54895:   else {
54895:     cookie = mUserSetCookieHeader;
54895:   }
46906: 
54895:   // If we are in the child process, we want the parent seeing any
54895:   // cookie headers that might have been set by SetRequestHeader()
80486:   SetRequestHeader(nsDependentCString(nsHttp::Cookie), cookie, false);
46906: }
46906: 
49375: static PLDHashOperator
49375: CopyProperties(const nsAString& aKey, nsIVariant *aData, void *aClosure)
49375: {
49375:   nsIWritablePropertyBag* bag = static_cast<nsIWritablePropertyBag*>
49375:                                            (aClosure);
49375:   bag->SetProperty(aKey, aData);
49375:   return PL_DHASH_NEXT;
49375: }
49375: 
80420: // Return whether upon a redirect code of httpStatus for method, the
80420: // request method should be rewritten to GET.
80420: //
80420: bool
80420: HttpBaseChannel::ShouldRewriteRedirectToGET(PRUint32 httpStatus,
80420:                                             nsHttpAtom method)
80420: {
80420:   // always rewrite for 301 and 302, but see bug 598304
80420:   // and  RFC 2616, Section 8.3.
80420:   if (httpStatus == 301 || httpStatus == 302)
80420:     return true;
80420: 
80420:   // always rewrite for 303
80420:   if (httpStatus == 303)
80420:     return true;
80420: 
80420:   // otherwise, such as for 307, do not rewrite
80420:   return false;
80420: }   
80420: 
80420: // Return whether the specified method is safe as per RFC 2616, Section 9.1.1.
80420: bool
80420: HttpBaseChannel::IsSafeMethod(nsHttpAtom method)
80420: {
80420:   // This code will need to be extended for new safe methods, otherwise
80420:   // they'll default to "not safe".
80420:   return method == nsHttp::Get ||
80420:          method == nsHttp::Head ||
80420:          method == nsHttp::Options ||
80420:          method == nsHttp::Propfind ||
80420:          method == nsHttp::Report ||
80420:          method == nsHttp::Search ||
80420:          method == nsHttp::Trace;
80420: }
80420: 
49375: nsresult
49375: HttpBaseChannel::SetupReplacementChannel(nsIURI       *newURI, 
49375:                                          nsIChannel   *newChannel,
79445:                                          bool          preserveMethod)
49375: {
49375:   LOG(("HttpBaseChannel::SetupReplacementChannel "
49375:      "[this=%p newChannel=%p preserveMethod=%d]",
49375:      this, newChannel, preserveMethod));
49375:   PRUint32 newLoadFlags = mLoadFlags | LOAD_REPLACE;
49375:   // if the original channel was using SSL and this channel is not using
49375:   // SSL, then no need to inhibit persistent caching.  however, if the
49375:   // original channel was not using SSL and has INHIBIT_PERSISTENT_CACHING
49375:   // set, then allow the flag to apply to the redirected channel as well.
49375:   // since we force set INHIBIT_PERSISTENT_CACHING on all HTTPS channels,
49375:   // we only need to check if the original channel was using SSL.
49375:   if (mConnectionInfo->UsingSSL())
49375:     newLoadFlags &= ~INHIBIT_PERSISTENT_CACHING;
49375: 
49375:   // Do not pass along LOAD_CHECK_OFFLINE_CACHE
49375:   newLoadFlags &= ~nsICachingChannel::LOAD_CHECK_OFFLINE_CACHE;
49375: 
49375:   newChannel->SetLoadGroup(mLoadGroup); 
49375:   newChannel->SetNotificationCallbacks(mCallbacks);
49375:   newChannel->SetLoadFlags(newLoadFlags);
49375: 
49375:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
49375:   if (!httpChannel)
49375:     return NS_OK; // no other options to set
49375: 
49375:   if (preserveMethod) {
49375:     nsCOMPtr<nsIUploadChannel> uploadChannel =
49375:       do_QueryInterface(httpChannel);
49375:     nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
49375:       do_QueryInterface(httpChannel);
49375:     if (mUploadStream && (uploadChannel2 || uploadChannel)) {
49375:       // rewind upload stream
49375:       nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
49375:       if (seekable)
49375:         seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
49375: 
49375:       // replicate original call to SetUploadStream...
49375:       if (uploadChannel2) {
49375:         const char *ctype = mRequestHead.PeekHeader(nsHttp::Content_Type);
49375:         if (!ctype)
49375:           ctype = "";
49375:         const char *clen  = mRequestHead.PeekHeader(nsHttp::Content_Length);
49375:         PRInt64 len = clen ? nsCRT::atoll(clen) : -1;
49375:         uploadChannel2->ExplicitSetUploadStream(
49378:                                   mUploadStream, nsDependentCString(ctype), len,
78638:                                   nsDependentCString(mRequestHead.Method()),
49375:                                   mUploadStreamHasHeaders);
49375:       } else {
49375:         if (mUploadStreamHasHeaders) {
49375:           uploadChannel->SetUploadStream(mUploadStream, EmptyCString(),
49375:                            -1);
49375:         } else {
49375:           const char *ctype =
49375:             mRequestHead.PeekHeader(nsHttp::Content_Type);
49375:           const char *clen =
49375:             mRequestHead.PeekHeader(nsHttp::Content_Length);
49375:           if (!ctype) {
49375:             ctype = "application/octet-stream";
49375:           }
49375:           if (clen) {
49375:             uploadChannel->SetUploadStream(mUploadStream,
49375:                                            nsDependentCString(ctype),
49375:                                            atoi(clen));
49375:           }
49375:         }
49375:       }
49375:     }
49375:     // since preserveMethod is true, we need to ensure that the appropriate 
49375:     // request method gets set on the channel, regardless of whether or not 
49375:     // we set the upload stream above. This means SetRequestMethod() will
49375:     // be called twice if ExplicitSetUploadStream() gets called above.
49375: 
78638:     httpChannel->SetRequestMethod(nsDependentCString(mRequestHead.Method()));
49375:   }
49375:   // convey the referrer if one was used for this channel to the next one
49375:   if (mReferrer)
49375:     httpChannel->SetReferrer(mReferrer);
49375:   // convey the mAllowPipelining flag
49375:   httpChannel->SetAllowPipelining(mAllowPipelining);
49375:   // convey the new redirection limit
49375:   httpChannel->SetRedirectionLimit(mRedirectionLimit - 1);
49375: 
49375:   nsCOMPtr<nsIHttpChannelInternal> httpInternal = do_QueryInterface(newChannel);
49375:   if (httpInternal) {
49375:     // convey the mForceAllowThirdPartyCookie flag
49375:     httpInternal->SetForceAllowThirdPartyCookie(mForceAllowThirdPartyCookie);
49375: 
49375:     // update the DocumentURI indicator since we are being redirected.
49375:     // if this was a top-level document channel, then the new channel
49375:     // should have its mDocumentURI point to newURI; otherwise, we
49375:     // just need to pass along our mDocumentURI to the new channel.
49375:     if (newURI && (mURI == mDocumentURI))
49375:       httpInternal->SetDocumentURI(newURI);
49375:     else
49375:       httpInternal->SetDocumentURI(mDocumentURI);
63794: 
63794:     // if there is a chain of keys for redirect-responses we transfer it to
63794:     // the new channel (see bug #561276)
63794:     if (mRedirectedCachekeys) {
63794:         LOG(("HttpBaseChannel::SetupReplacementChannel "
63794:              "[this=%p] transferring chain of redirect cache-keys", this));
63794:         httpInternal->SetCacheKeysRedirectChain(mRedirectedCachekeys);
63794:         mRedirectedCachekeys = nsnull;
63794:     }
49375:   }
49375:   
49375:   // transfer application cache information
49375:   nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
49375:     do_QueryInterface(newChannel);
49375:   if (appCacheChannel) {
49375:     appCacheChannel->SetApplicationCache(mApplicationCache);
49375:     appCacheChannel->SetInheritApplicationCache(mInheritApplicationCache);
49375:     // We purposely avoid transfering mChooseApplicationCache.
49375:   }
49375: 
49375:   // transfer any properties
49375:   nsCOMPtr<nsIWritablePropertyBag> bag(do_QueryInterface(newChannel));
49375:   if (bag)
49375:     mPropertyHash.EnumerateRead(CopyProperties, bag.get());
49375: 
70188:   // transfer timed channel enabled status
70188:   nsCOMPtr<nsITimedChannel> timed(do_QueryInterface(newChannel));
70188:   if (timed)
70188:     timed->SetTimingEnabled(mTimingEnabled);
70188: 
49375:   return NS_OK;
49375: }
49375: 
46906: //------------------------------------------------------------------------------
46906: 
46906: }  // namespace net
46906: }  // namespace mozilla
61190: 
