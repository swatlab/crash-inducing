20529: /* ***** BEGIN LICENSE BLOCK *****
20529:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
20529:  *
20529:  * The contents of this file are subject to the Mozilla Public License Version
20529:  * 1.1 (the "License"); you may not use this file except in compliance with
20529:  * the License. You may obtain a copy of the License at
20529:  * http://www.mozilla.org/MPL/
20529:  *
20529:  * Software distributed under the License is distributed on an "AS IS" basis,
20529:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
20529:  * for the specific language governing rights and limitations under the
20529:  * License.
20529:  *
20529:  * The Initial Developer of the Original Code is
20529:  * CSIRO
20529:  * Portions created by the Initial Developer are Copyright (C) 2007
20529:  * the Initial Developer. All Rights Reserved.
20529:  *
20529:  * Contributor(s): Marcin Lubonski 
20529:  *
20529:  * Alternatively, the contents of this file may be used under the terms of
20529:  * either the GNU General Public License Version 2 or later (the "GPL"), or
20529:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
20529:  * in which case the provisions of the GPL or the LGPL are applicable instead
20529:  * of those above. If you wish to allow use of your version of this file only
20529:  * under the terms of either the GPL or the LGPL, and not to allow others to
20529:  * use your version of this file under the terms of the MPL, indicate your
20529:  * decision by deleting the provisions above and replace them with the notice
20529:  * and other provisions required by the GPL or the LGPL. If you do not delete
20529:  * the provisions above, a recipient may use your version of this file under
20529:  * the terms of any one of the MPL, the GPL or the LGPL.
20529:  *
20529:  * ***** END LICENSE BLOCK ***** *
20529:  */
20529: 
20529: #include "sydney_audio.h"
20529: #include <stdio.h>
20529: #include <stdlib.h>
20529: 
20529: #include <windows.h>
20529: #include <mmreg.h>
20529: #include <mmsystem.h>
20529: #include <math.h>
20529: 
20529: 
20529: // FIX ME: block size and block should be determined based on the OggPlay offset 
20529: // for audio track
22785: #define BLOCK_SIZE  1024
20529: #define BLOCK_COUNT 32
20529: #define DEFAULT_DEVICE_NAME "Default WAVE Device"
20529: #define DEFAULT_DEVICE WAVE_MAPPER
20529: 
20529: #define VERBOSE_OUTPUT 1
20529: 
20529: // INFO: if you get weird compile errors make sure there is no extra chars pass '\' 
20529: #if defined(VERBOSE_OUTPUT)
20529: #define WAVE_ERROR_VERBOSE(error, message) \
20529:   switch (error) { \
20529:     case MMSYSERR_ALLOCATED: \
20529:       printf("[WAVE API] Device allocation error returned while executing %s\n", message); \
20529:       break; \
20529:     case MMSYSERR_BADDEVICEID: \
20529:       printf("[WAVE API] Wrong device ID error returned while executing %s\n", message); \
20529:       break; \
20529:     case MMSYSERR_NODRIVER: \
20529:       printf("[WAVE API] System driver not present error returned while executing %s\n", message); \
20529:       break; \
20529:     case MMSYSERR_INVALHANDLE: \
20529:       printf("[WAVE API] Invalid device handle error returned while executing %s\n", message); \
20529:       break; \
20529:     case MMSYSERR_NOMEM: \
20529:       printf("[WAVE API] No memory error returned while executing %s\n", message); \
20529:       break; \
20529:     case MMSYSERR_NOTSUPPORTED: \
20529:       printf("[WAVE API] Not supported error returned while executing %s\n", message); \
20529:       break; \
20529:     case WAVERR_BADFORMAT: \
20529:       printf("[WAVE API] Not valid audio format returned while executing %s\n", message); \
20529:       break; \
20529:     case WAVERR_SYNC: \
20529:       printf("[WAVE API] Device synchronous error returned while executing %s\n", message); \
20529:       break; \
20529:     default: \
20529:       printf("[WAVE API] Error while executing %s\n", message); \
20529:       break; \
20529:   }
20529: #else
20529: #define WAVE_ERROR_VERBOSE(error, message) \
20529:   do {} while(0)
20529: #endif
20529: 
20529: #define HANDLE_WAVE_ERROR(status, location) \
20529:   if (status != MMSYSERR_NOERROR) { \
20529:       WAVE_ERROR_VERBOSE(status, location); \
20529:       return getSAErrorCode(status); \
20529:   }
20529: 
20529: #define ERROR_IF_NO_INIT(handle) \
20529:   if (handle == NULL) { \
20529: 		return SA_ERROR_NO_INIT; \
20529: 	}
20529: 
20529: /* local implementation of the sa_stream_t type */
20529: struct sa_stream {   
20529:   char*           deviceName;
20529:   UINT				    device;
20529:   UINT				    channels;
20529:   UINT				    rate;
20529: 	
20529:   sa_mode_t			  rwMode;
20529:   sa_pcm_format_t	format;   
20529:  
20529:   HWAVEOUT			  hWaveOut;
20529:   HANDLE			    callbackEvent;
20529:   CRITICAL_SECTION  waveCriticalSection;  
20529:   WAVEHDR*			  waveBlocks;  
20529:   volatile int		waveFreeBlockCount;
20529:   int				      waveCurrentBlock;
20529: };
20529: 
20529: 
20529: /** Forward definitions of audio api specific functions */
20529: int allocateBlocks(int size, int count, WAVEHDR** blocks);
20529: int freeBlocks(WAVEHDR* blocks);
20529: int openAudio(sa_stream_t *s);
20529: int closeAudio(sa_stream_t * s);
20529: int writeAudio(sa_stream_t *s, LPSTR data, int bytes);
20529: int getSAErrorCode(int waveErrorCode);
20529: 
20529: void CALLBACK waveOutProc(HWAVEOUT hWaveOut, UINT uMsg, 
20529:     DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);
20529: 
20529: /** Normal way to open a PCM device */
20529: int sa_stream_create_pcm(sa_stream_t **s, 
20529:                          const char *client_name, 
20529:                          sa_mode_t mode, 
20529:                          sa_pcm_format_t format, 
20529:                          unsigned int rate, 
20529:                          unsigned int nchannels) {
20529:   sa_stream_t * _s = NULL;
20529:   
20529:   ERROR_IF_NO_INIT(s);
20529:   
20529:   *s = NULL;
20529:   
20529:   /* FIX ME: for formats different than PCM extend using WAVEFORMATEXTENSIBLE */
20529:   if (format != SA_PCM_FORMAT_S16_NE) {
20529:     return SA_ERROR_NOT_SUPPORTED;
20529:   }
20529: 
20529:   if (mode != SA_MODE_WRONLY) {
20529:     return SA_ERROR_NOT_SUPPORTED;
20529:   }
20529: 
25186:   if ((_s = (sa_stream_t*)calloc(1, sizeof(sa_stream_t))) == NULL) {
20529:     return SA_ERROR_OOM;
20529:   }
20529:    
20529:   _s->rwMode = mode;
20529:   _s->format = format;
20529:   _s->rate = rate;
20529:   _s->channels = nchannels;
20529:   _s->deviceName = DEFAULT_DEVICE_NAME;
20529:   _s->device = DEFAULT_DEVICE;
20529: 
20529:   *s = _s; 
20529:   return SA_SUCCESS;
20529: }
20529: 
20529: /** Initialise the device */
20529: int sa_stream_open(sa_stream_t *s) {  
20529:   int status = SA_SUCCESS;
20529: 
20529:   ERROR_IF_NO_INIT(s);
20529: 
20529:   switch (s->rwMode) {
20529:     case SA_MODE_WRONLY: 
20529:       status = openAudio(s);
20529:       break;
20529: 	default:
20529:       status = SA_ERROR_NOT_SUPPORTED;      
20529:       break;
20529:   }    
20529:   return status;
20529: }
20529: 
20529: /** Interleaved playback function */
20529: int sa_stream_write(sa_stream_t *s, const void *data, size_t nbytes) {
20529:   int status = SA_SUCCESS;
20529: 
20529:   ERROR_IF_NO_INIT(s);
20529: 
20529:   status = writeAudio(s, (LPSTR)data, nbytes);
20529: 
20529:   return status;
20529: }
20529: 
20529: /** Query how much can be written without blocking */
20529: int sa_stream_get_write_size(sa_stream_t *s, size_t *size) {
20529:   unsigned int avail;
20529:   WAVEHDR* current;
20529: 
20529:   ERROR_IF_NO_INIT(s);
20529: 
20529:   EnterCriticalSection(&(s->waveCriticalSection));
22785:   avail = (s->waveFreeBlockCount-1) * BLOCK_SIZE;
20529:   if (s->waveFreeBlockCount != BLOCK_COUNT) {
20529:     current = &(s->waveBlocks[s->waveCurrentBlock]);
20529:     avail += BLOCK_SIZE - current->dwUser;
20529:   }
20529:   LeaveCriticalSection(&(s->waveCriticalSection));
20529: 
20529:   *size = avail;
20529: 
20529:   return SA_SUCCESS;
20529: }
20529: 
20529: /** Close/destroy everything */
20529: int sa_stream_destroy(sa_stream_t *s) {
20529:   int status;
20529: 
20529:   ERROR_IF_NO_INIT(s);
20529:   /* close and release all allocated resources */
20529:   status = closeAudio(s);
20529: 
21269:   free(s);
21269: 
20529:   return status;
20529: }
20529: 
20529: #define LEFT_CHANNEL_MASK 0x0000FFFF
20529: #define RIGHT_CHANNEL_MASK 0xFFFF0000
20529: 
20529: /** 
20529:  * retrieved volume as an int in a scale from 0x0000 to 0xFFFF
20529:  * only one value for all channels
20529:  */
20529: int sa_stream_get_write_volume(sa_stream_t *s, int32_t vol[], unsigned int *n) {
20529:   int status;
20529: 	DWORD volume;
20529: 	WORD left;
20529: 	WORD right;
20529: 
20529: 	ERROR_IF_NO_INIT(s);
20529:   
20529: 	status = waveOutGetVolume(s->hWaveOut, &volume);
20529: 	HANDLE_WAVE_ERROR(status, "reading audio volume level");
20529: 
20529: 	left = volume & LEFT_CHANNEL_MASK;
20529: 	right = (volume & RIGHT_CHANNEL_MASK) >> 16;
20529:   vol[0] = (int32_t)(left + right /2);	
20529: 
20529: 	return SA_SUCCESS;
20529: 
20529: }
20529: 
20529: /** changes volume as an int in a scale from 0x0000 to 0xFFFF*/
20529: int sa_stream_change_write_volume(sa_stream_t *s, const int32_t vol[], unsigned int n) {
20529:   int status;
20529: 	DWORD volume;
20529: 	WORD left;
20529: 	WORD right;
20529: 	
20529: 	ERROR_IF_NO_INIT(s);
20529: 	
20529:   volume = (DWORD)vol[0];
20529: 	left = volume & LEFT_CHANNEL_MASK;	  
20529: 	right = left;	  
20529: 	volume =  (left << 16) | right;	
20529: 	
20529: 	status = waveOutSetVolume(s->hWaveOut, volume);
20529: 	HANDLE_WAVE_ERROR(status, "setting new audio volume level");	
20529: 
20529: 	return SA_SUCCESS;
20529: 
20529: 
20529: }
20529: 
20529: /** sync/timing */
20529: int sa_stream_get_position(sa_stream_t *s, sa_position_t position, int64_t *pos) {
20529: 	int status;
20529:   MMTIME  mm;
20529: 
20529:   ERROR_IF_NO_INIT(s);
20529: 
20529:   if (position != SA_POSITION_WRITE_HARDWARE) {
20529:     return SA_ERROR_NOT_SUPPORTED;
20529:   }
20529:   // request playback progress in bytes
20529:   mm.wType = TIME_BYTES;		
20529: 	status = waveOutGetPosition(s->hWaveOut, &mm, sizeof(MMTIME));
20529:   HANDLE_WAVE_ERROR(status, "reading audio buffer position");
20529:   *pos = (int64_t)mm.u.cb;
20529: 
20529: 	return SA_SUCCESS;
20529: }
20529: 
20529: /* Control/xrun */
20529: /** Resume playing after a pause */
20529: int sa_stream_resume(sa_stream_t *s) {
20529:   int status;  
20529:   
20529:   ERROR_IF_NO_INIT(s);
20529: 
20529:   status = waveOutRestart(s->hWaveOut);
20529:   HANDLE_WAVE_ERROR(status, "resuming audio playback");
20529: 
20529:   return SA_SUCCESS;
20529: }
20529: /** Pause audio playback (do not empty the buffer) */
20529: int sa_stream_pause(sa_stream_t *s) {
20529:   int status;
20529: 
20529:   ERROR_IF_NO_INIT(s);
20529:   
20529:   status = waveOutPause(s->hWaveOut);
20529:   HANDLE_WAVE_ERROR(status, "resuming audio playback");
20529: 
20529:   return SA_SUCCESS;
20529: }
20529: /** Block until all audio has been played */
20529: int sa_stream_drain(sa_stream_t *s) {
20529:   ERROR_IF_NO_INIT(s);
20529:   
20529:   /* wait for all blocks to complete */
20529:   EnterCriticalSection(&(s->waveCriticalSection));
20529:   while(s->waveFreeBlockCount < BLOCK_COUNT) {
20529:     LeaveCriticalSection(&(s->waveCriticalSection));
20529:     Sleep(10);
20529:     EnterCriticalSection(&(s->waveCriticalSection));
20529:   }
20529:   LeaveCriticalSection(&(s->waveCriticalSection));
20529: 
20529:   return SA_SUCCESS;
20529: }
20529: 
20529: /*
20529:  * -----------------------------------------------------------------------------
20529:  * Private WAVE API specific functions
20529:  * -----------------------------------------------------------------------------
20529:  */
20529: 
20529: /** 
20529:  * \brief - allocate buffer for writing to system WAVE audio device
20529:  * \param size - size of each audio block
20529:  * \param cound - number of blocks to be allocated
20529:  * \param blocks - pointer to the blocks buffer to be allocated
20529:  * \return - completion status
20529:  */
20529: int allocateBlocks(int size, int count, WAVEHDR** blocks)
20529: {
20529:   unsigned char* buffer;    
20529:   int i;    
20529:   WAVEHDR* headers;
20529:   DWORD totalBufferSize = (size + sizeof(WAVEHDR)) * count;
20529:     
20529:   /* allocate memory on heap for the entire set in one go  */    
20529:   if((buffer = HeapAlloc(
20529:      GetProcessHeap(), 
20529:      HEAP_ZERO_MEMORY, 
20529:      totalBufferSize
20529:      )) == NULL) {
20529:       printf("Memory allocation error\n");
20529:       return SA_ERROR_OOM;
20529:     }
20529: 
20529:   /* and set up the pointers to each bit */
20529:   headers = *blocks = (WAVEHDR*)buffer;
20529:   buffer += sizeof(WAVEHDR) * count;
20529:   for(i = 0; i < count; i++) {    
20529: 	  headers[i].dwBufferLength = size;
20529:     headers[i].lpData = buffer;
20529:     buffer += size;
20529:   }
20529:     
20529:   return SA_SUCCESS;
20529: }
20529: 
20529: /**
20529:  * \brief - free allocated audio buffer
20529:  * \param blocks - pointer to allocated the buffer of audio bloks
20529:  * \return - completion status
20529:  */
20529: int freeBlocks(WAVEHDR* blocks)
20529: {    
20529:   if (blocks == NULL) 
20529:     return SA_ERROR_INVALID;
20529: 
20529:   /* and this is why allocateBlocks works the way it does */     
20529:   HeapFree(GetProcessHeap(), 0, blocks);
20529:   blocks = NULL;
20529: 
20529:   return SA_SUCCESS;
20529: }
20529: 
20529: /** 
20529:  * \brief - open system default WAVE device
20529:  * \param s - sydney audio stream handle
20529:  * \return - completion status
20529:  */ 
20529: int openAudio(sa_stream_t *s) {
20529:   int status;
20529:   WAVEFORMATEX wfx;    
20529:   UINT supported = FALSE;
20529: 		  
20529:   status = allocateBlocks(BLOCK_SIZE, BLOCK_COUNT, &(s->waveBlocks));  
20529: 	HANDLE_WAVE_ERROR(status, "allocating audio buffer blocks");
20529:   
20529:   s->waveFreeBlockCount	= BLOCK_COUNT;
20529:   s->waveCurrentBlock	= 0;  
20529:   wfx.nSamplesPerSec	= (DWORD)s->rate;	/* sample rate */
20529:   wfx.wBitsPerSample	= 16;				/* sample size */
20529:   wfx.nChannels			= s->channels;	/* channels    */
20529:   wfx.cbSize			= 0;				/* size of _extra_ info */
20529:   wfx.wFormatTag		= WAVE_FORMAT_PCM;
20529:   wfx.nBlockAlign		= (wfx.wBitsPerSample * wfx.nChannels) >> 3;
20529:   wfx.nAvgBytesPerSec	= wfx.nBlockAlign * wfx.nSamplesPerSec;
20529: 
20529:   supported = waveOutOpen(NULL, WAVE_MAPPER, &wfx, (DWORD_PTR)0, (DWORD_PTR)0, 
20529: 				WAVE_FORMAT_QUERY);
20529:   if (supported == MMSYSERR_NOERROR) { // audio device opened sucessfully 
20529:     status = waveOutOpen((LPHWAVEOUT)&(s->hWaveOut), WAVE_MAPPER, &wfx, 
20529: 	  (DWORD_PTR)waveOutProc, (DWORD_PTR)s, CALLBACK_FUNCTION);
29958:     if (status != MMSYSERR_NOERROR) {
29958:       freeBlocks(s->waveBlocks);
29958:       s->waveBlocks = NULL;
20529:       HANDLE_WAVE_ERROR(status, "opening audio device for playback");
29958:     }
20529:   } 
20529:   else if (supported == WAVERR_BADFORMAT) {
29958:     printf("Requested format not supported.\n");
20529:     // clean up the memory
20529:     freeBlocks(s->waveBlocks);
29958:     s->waveBlocks = NULL;
20529:     return SA_ERROR_NOT_SUPPORTED;
20529:   } 
20529:   else {
29958:     printf("Error opening default audio device.\n");
20529:     // clean up the memory
20529:     freeBlocks(s->waveBlocks);
29958:     s->waveBlocks = NULL;
20529:     return SA_ERROR_SYSTEM;
20529:   }
20529:   // create notification for data written to a device
20529:   s->callbackEvent = CreateEvent(0, FALSE, FALSE, 0);
20529:   // initialise critical section for operations on waveFreeBlockCound variable
20529:   InitializeCriticalSection(&(s->waveCriticalSection));
20529: 
20529:   return SA_SUCCESS;
20529: }
20529: /**
20529:  * \brief - closes opened audio device handle
20529:  * \param s - sydney audio stream handle
20529:  * \return - completion status
20529:  */
20529: int closeAudio(sa_stream_t * s) {
26691:   int status, i, result;
26691:   
26691:   result = SA_SUCCESS;
20529: 
20529:   // reseting audio device and flushing buffers
20529:   status = waveOutReset(s->hWaveOut);    
26691:   if (status != MMSYSERR_NOERROR) {
26691:     result = getSAErrorCode(status);
26691:   }
20529:   
29958:   if (s->waveBlocks) {
20529:     /* wait for all blocks to complete */  
26691:     while(s->waveFreeBlockCount < BLOCK_COUNT) {
20529:       Sleep(10);
26691:     }
20529: 
20529:     /* unprepare any blocks that are still prepared */  
20529:     for(i = 0; i < s->waveFreeBlockCount; i++) {
20529:       if(s->waveBlocks[i].dwFlags & WHDR_PREPARED) {
20529: 	status = waveOutUnprepareHeader(s->hWaveOut, &(s->waveBlocks[i]), sizeof(WAVEHDR));
26691: 	if (status != MMSYSERR_NOERROR) {
26691: 	  result = getSAErrorCode(status);
26691: 	}
20529:       }
20529:     }    
20529: 
20529:     freeBlocks(s->waveBlocks);  
29958:     s->waveBlocks = NULL;
29958:   }
29958: 
20529:   status = waveOutClose(s->hWaveOut);    
26691:   if (status != MMSYSERR_NOERROR) {
26691:     result = getSAErrorCode(status);
26691:   }
20529: 
20529:   DeleteCriticalSection(&(s->waveCriticalSection));
20529:   CloseHandle(s->callbackEvent);
20529:   
26691:   return result;
20529: }
20529: /**
20529:  * \brief - writes PCM audio samples to audio device
20529:  * \param s - valid handle to opened sydney stream
20529:  * \param data - pointer to memory storing audio samples to be played
20529:  * \param nsamples - number of samples in the memory pointed by previous parameter
20529:  * \return - completion status
20529:  */
20529: int writeAudio(sa_stream_t *s, LPSTR data, int bytes) {    
20529:   UINT status;
20529:   WAVEHDR* current;	  
20529:   int remain;
20529: 
20529:   current = &(s->waveBlocks[s->waveCurrentBlock]);
20529: 
20529:   while(bytes > 0) {
22785:      /*
22785:      * wait for a block to become free
22785:      */
22785:     while (!(s->waveFreeBlockCount))
22785:       WaitForSingleObject(s->callbackEvent, INFINITE);
22785: 
20529:     /* first make sure the header we're going to use is unprepared */
20529:     if(current->dwFlags & WHDR_PREPARED) {      
20529:         status = waveOutUnprepareHeader(s->hWaveOut, current, sizeof(WAVEHDR));         
20529:         HANDLE_WAVE_ERROR(status, "preparing audio headers for writing");
20529:     }
20529: 		  
20529:     if(bytes < (int)(BLOCK_SIZE - current->dwUser)) {							  	    
20529: 		  memcpy(current->lpData + current->dwUser, data, bytes);
20529:       current->dwUser += bytes;
20529:       break;
20529:     }
20529: 
20529:     /* remain is even as BLOCK_SIZE and dwUser are even too */
20529:     remain = BLOCK_SIZE - current->dwUser;      
20529:   	memcpy(current->lpData + current->dwUser, data, remain);
20529:     bytes -= remain;
20529:     data += remain;
20529: 	  current->dwBufferLength = BLOCK_SIZE;
20529: 	  /* write to audio device */
20529:     waveOutPrepareHeader(s->hWaveOut, current, sizeof(WAVEHDR));
20529: 	  status = waveOutWrite(s->hWaveOut, current, sizeof(WAVEHDR));      
20529:     HANDLE_WAVE_ERROR(status, "writing audio to audio device");
20529:       
20529:     EnterCriticalSection(&(s->waveCriticalSection));
20529:     s->waveFreeBlockCount--;
20529:     LeaveCriticalSection(&(s->waveCriticalSection));
20529: 
20529:     /*
20529:      * point to the next block
20529:      */
20529:     (s->waveCurrentBlock)++;
20529:     (s->waveCurrentBlock) %= BLOCK_COUNT;		
20529: 
20529:     current = &(s->waveBlocks[s->waveCurrentBlock]);
20529:     current->dwUser = 0;
20529:   }
20529:   return SA_SUCCESS;
20529: }
20529: 
20529: /**
20529:  * \brief - audio callback function called when next WAVE header is played by audio device
20529:  */
20529: void CALLBACK waveOutProc(
20529:     HWAVEOUT hWaveOut, 
20529:     UINT uMsg, 
20529:     DWORD dwInstance,  
20529:     DWORD dwParam1,    
20529:     DWORD dwParam2     
20529: )
20529: {
20529:     /*
20529:      * pointer to free block counter
20529:      */
20529:     sa_stream_t* handle = (sa_stream_t*)dwInstance;
20529:     /*
20529:      * ignore calls that occur due to openining and closing the
20529:      * device.
20529:      */
20529:     if(uMsg != WOM_DONE)
20529:         return;
20529: 
20529:     EnterCriticalSection(&(handle->waveCriticalSection));
20529:     (handle->waveFreeBlockCount)++;
20529:     if ((handle->waveFreeBlockCount) == 1) 
20529:        SetEvent(handle->callbackEvent);
20529:     LeaveCriticalSection(&(handle->waveCriticalSection));	
20529: }
20529: 
20529: /**
20529:  * \brief - converts frequently reported WAVE error codes to Sydney audio API codes
20529:  */
20529: int getSAErrorCode(int waveErrorCode) {
20529:   int error = SA_ERROR_NOT_SUPPORTED;
20529: 
20529:   switch (waveErrorCode) {
20529:     case MMSYSERR_NOERROR: 
20529:       error = SA_SUCCESS;
20529:       break;
20529:     case MMSYSERR_ALLOCATED: 
20529:       error = SA_ERROR_SYSTEM;
20529:       break;
20529:     case MMSYSERR_BADDEVICEID:
20529:       error = SA_ERROR_INVALID;
20529:       break;
20529:     case MMSYSERR_NODRIVER:
20529:       error = SA_ERROR_NO_DRIVER;
20529:       break;
20529:     case MMSYSERR_NOTSUPPORTED:
20529:       error = SA_ERROR_NOT_SUPPORTED;
20529:       break;          
20529:     case MMSYSERR_NOMEM: 
20529:       error = SA_ERROR_OOM;
20529:       break;
20529:     case MMSYSERR_INVALHANDLE:
20529:       error = SA_ERROR_INVALID;
20529:       break;
20529:     case WAVERR_BADFORMAT: 
20529:       error = SA_ERROR_NOT_SUPPORTED;
20529:       break;
20529:     case WAVERR_SYNC: 
20529:       error = SA_ERROR_NOT_SUPPORTED;
20529:       break;    
20529:   }
20529:   return error;
20529: }
20529: 
20529: 
20529: /*
20529:  * -----------------------------------------------------------------------------
20529:  * Functions to be implemented next 
20529:  * -----------------------------------------------------------------------------
20529:  */
20529: 
20529: #define NOT_IMPLEMENTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
20529: 
20529: /* "Soft" params */
20529: NOT_IMPLEMENTED(int sa_stream_set_write_lower_watermark(sa_stream_t *s, size_t size))
20529: NOT_IMPLEMENTED(int sa_stream_set_read_lower_watermark(sa_stream_t *s, size_t size))
20529: NOT_IMPLEMENTED(int sa_stream_set_write_upper_watermark(sa_stream_t *s, size_t size))
20529: NOT_IMPLEMENTED(int sa_stream_set_read_upper_watermark(sa_stream_t *s, size_t size))
20529: 
20529: /** Set the mapping between channels and the loudspeakers */
20529: NOT_IMPLEMENTED(int sa_stream_set_channel_map(sa_stream_t *s, const sa_channel_t map[], unsigned int n))
20529: 
20529: /* Query functions */
20529: NOT_IMPLEMENTED(int sa_stream_get_mode(sa_stream_t *s, sa_mode_t *access_mode))
20529: NOT_IMPLEMENTED(int sa_stream_get_pcm_format(sa_stream_t *s, sa_pcm_format_t *format))
20529: NOT_IMPLEMENTED(int sa_stream_get_rate(sa_stream_t *s, unsigned int *rate))
20529: NOT_IMPLEMENTED(int sa_stream_get_nchannels(sa_stream_t *s, int *nchannels))
20529: NOT_IMPLEMENTED(int sa_stream_get_device(sa_stream_t *s, char *device_name, size_t *size))
20529: NOT_IMPLEMENTED(int sa_stream_get_write_lower_watermark(sa_stream_t *s, size_t *size))
20529: NOT_IMPLEMENTED(int sa_stream_get_read_lower_watermark(sa_stream_t *s, size_t *size))
20529: NOT_IMPLEMENTED(int sa_stream_get_write_upper_watermark(sa_stream_t *s, size_t *size))
20529: NOT_IMPLEMENTED(int sa_stream_get_read_upper_watermark(sa_stream_t *s, size_t *size))
20529: NOT_IMPLEMENTED(int sa_stream_get_channel_map(sa_stream_t *s, sa_channel_t map[], unsigned int *n))
20529: 
20529: /*
20529:  * -----------------------------------------------------------------------------
20529:  * Unsupported functions
20529:  * -----------------------------------------------------------------------------
20529:  */
20529: #define UNSUPPORTED(func)   func { return SA_ERROR_NOT_SUPPORTED; }
20529: 
20529: /** Create an opaque (e.g. AC3) codec stream */
20529: UNSUPPORTED(int sa_stream_create_opaque(sa_stream_t **s, const char *client_name, sa_mode_t mode, const char *codec))
20529: /** Whether xruns cause the card to reset */
20529: UNSUPPORTED(int sa_stream_set_xrun_mode(sa_stream_t *s, sa_xrun_mode_t mode))
20529: /** Set the device to non-interleaved mode */
20529: UNSUPPORTED(int sa_stream_set_non_interleaved(sa_stream_t *s, int enable))
20529: /** Require dynamic sample rate */
20529: UNSUPPORTED(int sa_stream_set_dynamic_rate(sa_stream_t *s, int enable))
20529: /** Select driver */
20529: UNSUPPORTED(int sa_stream_set_driver(sa_stream_t *s, const char *driver))
20529: /** Start callback */
20529: UNSUPPORTED(int sa_stream_start_thread(sa_stream_t *s, sa_event_callback_t callback))
20529: /** Stop callback */
20529: UNSUPPORTED(int sa_stream_stop_thread(sa_stream_t *s))
20529: /** Change the device connected to the stream */
20529: UNSUPPORTED(int sa_stream_change_device(sa_stream_t *s, const char *device_name))
20529: /** volume in hundreths of dB*/
20529: UNSUPPORTED(int sa_stream_change_read_volume(sa_stream_t *s, const int32_t vol[], unsigned int n))
20529: /** Change the sampling rate */
20529: UNSUPPORTED(int sa_stream_change_rate(sa_stream_t *s, unsigned int rate))
20529: /** Change some meta data that is attached to the stream */
20529: UNSUPPORTED(int sa_stream_change_meta_data(sa_stream_t *s, const char *name, const void *data, size_t size))
20529: /** Associate opaque user data */
20529: UNSUPPORTED(int sa_stream_change_user_data(sa_stream_t *s, const void *value))
20529: /* Hardware-related. This is implementation-specific and hardware specific. */
20529: UNSUPPORTED(int sa_stream_set_adjust_rate(sa_stream_t *s, sa_adjust_t direction))
20529: UNSUPPORTED(int sa_stream_set_adjust_nchannels(sa_stream_t *s, sa_adjust_t direction))
20529: UNSUPPORTED(int sa_stream_set_adjust_pcm_format(sa_stream_t *s, sa_adjust_t direction))
20529: UNSUPPORTED(int sa_stream_set_adjust_watermarks(sa_stream_t *s, sa_adjust_t direction))
20529: /* Query functions */
20529: UNSUPPORTED(int sa_stream_get_codec(sa_stream_t *s, char *codec, size_t *size))
20529: UNSUPPORTED(int sa_stream_get_user_data(sa_stream_t *s, void **value))
20529: 
20529: UNSUPPORTED(int sa_stream_get_xrun_mode(sa_stream_t *s, sa_xrun_mode_t *mode))
20529: UNSUPPORTED(int sa_stream_get_non_interleaved(sa_stream_t *s, int *enabled))
20529: UNSUPPORTED(int sa_stream_get_dynamic_rate(sa_stream_t *s, int *enabled))
20529: UNSUPPORTED(int sa_stream_get_driver(sa_stream_t *s, char *driver_name, size_t *size))            
20529: UNSUPPORTED(int sa_stream_get_read_volume(sa_stream_t *s, int32_t vol[], unsigned int *n))
20529: UNSUPPORTED(int sa_stream_get_meta_data(sa_stream_t *s, const char *name, void*data, size_t *size))
20529: UNSUPPORTED(int sa_stream_get_adjust_rate(sa_stream_t *s, sa_adjust_t *direction))
20529: UNSUPPORTED(int sa_stream_get_adjust_nchannels(sa_stream_t *s, sa_adjust_t *direction))
20529: UNSUPPORTED(int sa_stream_get_adjust_pcm_format(sa_stream_t *s, sa_adjust_t *direction))
20529: UNSUPPORTED(int sa_stream_get_adjust_watermarks(sa_stream_t *s, sa_adjust_t *direction))
20529: /** Get current state of the audio device */
20529: UNSUPPORTED(int sa_stream_get_state(sa_stream_t *s, sa_state_t *state))
20529: /** Obtain the error code */
20529: UNSUPPORTED(int sa_stream_get_event_error(sa_stream_t *s, sa_error_t *error))
20529: /** Obtain the notification code */
20529: UNSUPPORTED(int sa_stream_get_event_notify(sa_stream_t *s, sa_notify_t *notify))
20529: 
20529: /* Blocking IO calls */
20529: /** Interleaved capture function */
20529: UNSUPPORTED(int sa_stream_read(sa_stream_t *s, void *data, size_t nbytes))
20529: /** Non-interleaved capture function */
20529: UNSUPPORTED(int sa_stream_read_ni(sa_stream_t *s, unsigned int channel, void *data, size_t nbytes))
20529: 
20529: /** Non-interleaved playback function */
20529: UNSUPPORTED(int sa_stream_write_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes))
20529: /** Interleaved playback function with seek offset */
20529: UNSUPPORTED(int sa_stream_pwrite(sa_stream_t *s, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
20529: /** Non-interleaved playback function with seek offset */
20529: UNSUPPORTED(int sa_stream_pwrite_ni(sa_stream_t *s, unsigned int channel, const void *data, size_t nbytes, int64_t offset, sa_seek_t whence))
20529: 
20529: /** Query how much can be read without blocking */
20529: UNSUPPORTED(int sa_stream_get_read_size(sa_stream_t *s, size_t *size))
20529: 
20529: /** Return a human readable error */
20529: const char *sa_strerror(int code);
