 75615: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
 75615: /* vim: set ts=40 sw=4 et tw=99: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 75615: 
 75615: #include "jsapi.h"
 75615: #include "jsautooplen.h"
 75615: #include "jsbool.h"
 75615: #include "jsdate.h"
 75615: #include "jsexn.h"
 77404: #include "jsfriendapi.h"
 75637: #include "jsgc.h"
 75615: #include "jsinfer.h"
 75615: #include "jsmath.h"
 75615: #include "jsnum.h"
 75615: #include "jsobj.h"
 75615: #include "jsscript.h"
 75615: #include "jscntxt.h"
 75615: #include "jsscope.h"
 75615: #include "jsstr.h"
 75615: #include "jsiter.h"
 75615: 
 80506: #include "frontend/TokenStream.h"
 97569: #include "gc/Marking.h"
 86104: #include "js/MemoryMetrics.h"
 75636: #include "methodjit/MethodJIT.h"
 75636: #include "methodjit/Retcon.h"
 87590: #ifdef JS_METHODJIT
 87590: # include "assembler/assembler/MacroAssembler.h"
 87590: #endif
 75636: 
 75640: #include "jsatominlines.h"
 75948: #include "jsgcinlines.h"
 75615: #include "jsinferinlines.h"
 75615: #include "jsobjinlines.h"
 75615: #include "jsscriptinlines.h"
 76059: #include "vm/Stack-inl.h"
 75615: 
 75615: #ifdef JS_HAS_XML_SUPPORT
 75615: #include "jsxml.h"
 75615: #endif
 75615: 
 77389: #ifdef __SUNPRO_CC
 77389: #include <alloca.h>
 77389: #endif
 77389: 
 75987: using namespace js;
 75987: using namespace js::types;
 76059: using namespace js::analyze;
 75987: 
 75615: static inline jsid
 75615: id_prototype(JSContext *cx) {
 97828:     return NameToId(cx->runtime->atomState.classPrototypeAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id_arguments(JSContext *cx) {
 97828:     return NameToId(cx->runtime->atomState.argumentsAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id_length(JSContext *cx) {
 97828:     return NameToId(cx->runtime->atomState.lengthAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id___proto__(JSContext *cx) {
 97828:     return NameToId(cx->runtime->atomState.protoAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id_constructor(JSContext *cx) {
 97828:     return NameToId(cx->runtime->atomState.constructorAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id_caller(JSContext *cx) {
 97828:     return NameToId(cx->runtime->atomState.callerAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id_toString(JSContext *cx)
 75615: {
 97828:     return NameToId(cx->runtime->atomState.toStringAtom);
 75615: }
 75615: 
 75615: static inline jsid
 75615: id_toSource(JSContext *cx)
 75615: {
 97828:     return NameToId(cx->runtime->atomState.toSourceAtom);
 75615: }
 75615: 
 77353: #ifdef DEBUG
 75720: const char *
 75987: types::TypeIdStringImpl(jsid id)
 75720: {
 75720:     if (JSID_IS_VOID(id))
 75720:         return "(index)";
 75720:     if (JSID_IS_EMPTY(id))
 75720:         return "(new)";
 75720:     static char bufs[4][100];
 75720:     static unsigned which = 0;
 75720:     which = (which + 1) & 3;
 75720:     PutEscapedString(bufs[which], 100, JSID_TO_FLAT_STRING(id), 0);
 75720:     return bufs[which];
 75720: }
 77353: #endif
 75720: 
 75615: /////////////////////////////////////////////////////////////////////
 75638: // Logging
 75638: /////////////////////////////////////////////////////////////////////
 75638: 
 75638: static bool InferSpewActive(SpewChannel channel)
 75638: {
 75638:     static bool active[SPEW_COUNT];
 75638:     static bool checked = false;
 75638:     if (!checked) {
 75638:         checked = true;
 75638:         PodArrayZero(active);
 75638:         const char *env = getenv("INFERFLAGS");
 75638:         if (!env)
 75638:             return false;
 75638:         if (strstr(env, "ops"))
 75638:             active[ISpewOps] = true;
 75638:         if (strstr(env, "result"))
 75638:             active[ISpewResult] = true;
 75638:         if (strstr(env, "full")) {
 75638:             for (unsigned i = 0; i < SPEW_COUNT; i++)
 75638:                 active[i] = true;
 75638:         }
 75638:     }
 75638:     return active[channel];
 75638: }
 75638: 
 76186: #ifdef DEBUG
 76186: 
 76182: static bool InferSpewColorable()
 76182: {
 76182:     /* Only spew colors on xterm-color to not screw up emacs. */
 99812:     static bool colorable = false;
 99812:     static bool checked = false;
 99812:     if (!checked) {
 99812:         checked = true;
 76182:         const char *env = getenv("TERM");
 76182:         if (!env)
 76182:             return false;
 99812:         if (strcmp(env, "xterm-color") == 0 || strcmp(env, "xterm-256color") == 0)
 99812:             colorable = true;
 99812:     }
 99812:     return colorable;
 76182: }
 76182: 
 75640: const char *
 76184: types::InferSpewColorReset()
 76184: {
 76184:     if (!InferSpewColorable())
 76184:         return "";
 76184:     return "\x1b[0m";
 76184: }
 76184: 
 76184: const char *
 76182: types::InferSpewColor(TypeConstraint *constraint)
 76182: {
 76184:     /* Type constraints are printed out using foreground colors. */
 76182:     static const char *colors[] = { "\x1b[31m", "\x1b[32m", "\x1b[33m",
 76182:                                     "\x1b[34m", "\x1b[35m", "\x1b[36m",
 76182:                                     "\x1b[37m" };
 76182:     if (!InferSpewColorable())
 76182:         return "";
 76182:     return colors[DefaultHasher<TypeConstraint *>::hash(constraint) % 7];
 76182: }
 76182: 
 76182: const char *
 76182: types::InferSpewColor(TypeSet *types)
 76182: {
 76182:     /* Type sets are printed out using bold colors. */
 76182:     static const char *colors[] = { "\x1b[1;31m", "\x1b[1;32m", "\x1b[1;33m",
 76182:                                     "\x1b[1;34m", "\x1b[1;35m", "\x1b[1;36m",
 76182:                                     "\x1b[1;37m" };
 76182:     if (!InferSpewColorable())
 76182:         return "";
 76182:     return colors[DefaultHasher<TypeSet *>::hash(types) % 7];
 76182: }
 76182: 
 76182: const char *
 77353: types::TypeString(Type type)
 77353: {
 77353:     if (type.isPrimitive()) {
 77353:         switch (type.primitive()) {
 77353:           case JSVAL_TYPE_UNDEFINED:
 75640:             return "void";
 77353:           case JSVAL_TYPE_NULL:
 75640:             return "null";
 77353:           case JSVAL_TYPE_BOOLEAN:
 75640:             return "bool";
 77353:           case JSVAL_TYPE_INT32:
 75640:             return "int";
 77353:           case JSVAL_TYPE_DOUBLE:
 75640:             return "float";
 77353:           case JSVAL_TYPE_STRING:
 75640:             return "string";
 77353:           case JSVAL_TYPE_MAGIC:
 76128:             return "lazyargs";
 77353:           default:
 77353:             JS_NOT_REACHED("Bad type");
 77353:             return "";
 77353:         }
 77353:     }
 77353:     if (type.isUnknown())
 75640:         return "unknown";
 77353:     if (type.isAnyObject())
 77353:         return " object";
 77461: 
 77353:     static char bufs[4][40];
 77353:     static unsigned which = 0;
 77353:     which = (which + 1) & 3;
 77461: 
 77461:     if (type.isSingleObject())
 77353:         JS_snprintf(bufs[which], 40, "<0x%p>", (void *) type.singleObject());
 77461:     else
 77461:         JS_snprintf(bufs[which], 40, "[0x%p]", (void *) type.typeObject());
 77461: 
 77353:     return bufs[which];
 77353: }
 77461: 
 77461: const char *
 77461: types::TypeObjectString(TypeObject *type)
 77461: {
 77461:     return TypeString(Type::ObjectType(type));
 75640: }
 75640: 
 80026: unsigned JSScript::id() {
 80026:     if (!id_) {
 80026:         id_ = ++compartment()->types.scriptCount;
 80026:         InferSpew(ISpewOps, "script #%u: %p %s:%d",
 80026:                   id_, this, filename ? filename : "<null>", lineno);
 80026:     }
 80026:     return id_;
 80026: }
 80026: 
 75987: void
 75987: types::InferSpew(SpewChannel channel, const char *fmt, ...)
 75638: {
 75638:     if (!InferSpewActive(channel))
 75638:         return;
 75638: 
 75638:     va_list ap;
 75638:     va_start(ap, fmt);
 75638:     fprintf(stdout, "[infer] ");
 75638:     vfprintf(stdout, fmt, ap);
 75638:     fprintf(stdout, "\n");
 75638:     va_end(ap);
 75638: }
 75638: 
 75737: bool
 75987: types::TypeHasProperty(JSContext *cx, TypeObject *obj, jsid id, const Value &value)
 75737: {
 75737:     /*
 75737:      * Check the correctness of the type information in the object's property
 77353:      * against an actual value.
 75737:      */
 75919:     if (cx->typeInferenceEnabled() && !obj->unknownProperties() && !value.isUndefined()) {
 75737:         id = MakeTypeId(cx, id);
 75737: 
 75737:         /* Watch for properties which inference does not monitor. */
 75737:         if (id == id___proto__(cx) || id == id_constructor(cx) || id == id_caller(cx))
 75737:             return true;
 75737: 
 75737:         /*
 75737:          * If we called in here while resolving a type constraint, we may be in the
 75737:          * middle of resolving a standard class and the type sets will not be updated
 75737:          * until the outer TypeSet::add finishes.
 75737:          */
 75737:         if (cx->compartment->types.pendingCount)
 75737:             return true;
 75737: 
 77353:         Type type = GetValueType(cx, value);
 75737: 
 75737:         AutoEnterTypeInference enter(cx);
 75737: 
 77353:         /*
 77361:          * We don't track types for properties inherited from prototypes which
 77361:          * haven't yet been accessed during analysis of the inheriting object.
 77361:          * Don't do the property instantiation now.
 77353:          */
 77361:         TypeSet *types = obj->maybeGetProperty(cx, id);
 77361:         if (!types)
 77353:             return true;
 77353: 
 77361:         /*
 77361:          * If the types inherited from prototypes are not being propagated into
 77361:          * this set (because we haven't analyzed code which accesses the
 77361:          * property), skip.
 77361:          */
 77361:         if (!types->hasPropagatedProperty())
 77361:             return true;
 77361: 
 77361:         if (!types->hasType(type)) {
 75737:             TypeFailure(cx, "Missing type in object %s %s: %s",
 77461:                         TypeObjectString(obj), TypeIdString(id), TypeString(type));
 75737:         }
 75737:     }
 75737:     return true;
 75737: }
 75737: 
 75640: #endif
 75640: 
 75987: void
 75987: types::TypeFailure(JSContext *cx, const char *fmt, ...)
 75638: {
 76150:     char msgbuf[1024]; /* Larger error messages will be truncated */
 76150:     char errbuf[1024];
 76150: 
 75638:     va_list ap;
 75638:     va_start(ap, fmt);
 76150:     JS_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);
 75638:     va_end(ap);
 75638: 
 76150:     JS_snprintf(msgbuf, sizeof(msgbuf), "[infer failure] %s", errbuf);
 76150: 
 77440:     /* Dump type state, even if INFERFLAGS is unset. */
 77440:     cx->compartment->types.print(cx, true);
 75640: 
 76150:     /* Always active, even in release builds */
 90070:     MOZ_Assert(msgbuf, __FILE__, __LINE__);
 76150: 
 80884:     *((volatile int *)NULL) = 0;  /* Should never be reached */
 75640: }
 75638: 
 75638: /////////////////////////////////////////////////////////////////////
 75615: // TypeSet
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 76175: TypeSet *
 76175: TypeSet::make(JSContext *cx, const char *name)
 76175: {
 76175:     JS_ASSERT(cx->compartment->activeInference);
 76175: 
 79410:     TypeSet *res = cx->typeLifoAlloc().new_<TypeSet>();
 76175:     if (!res) {
 76175:         cx->compartment->types.setPendingNukeTypes(cx);
 76175:         return NULL;
 76175:     }
 76175: 
 76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s intermediate %s",
 76182:               InferSpewColor(res), res, InferSpewColorReset(),
 76182:               name);
 76175: 
 76175:     return res;
 76175: }
 76175: 
 75615: inline void
 75615: TypeSet::add(JSContext *cx, TypeConstraint *constraint, bool callExisting)
 75615: {
 76093:     if (!constraint) {
 76093:         /* OOM failure while constructing the constraint. */
 76093:         cx->compartment->types.setPendingNukeTypes(cx);
 76093:         return;
 76093:     }
 76093: 
 77353:     JS_ASSERT(cx->compartment->activeInference);
 75720: 
 76182:     InferSpew(ISpewOps, "addConstraint: %sT%p%s %sC%p%s %s",
 76182:               InferSpewColor(this), this, InferSpewColorReset(),
 76182:               InferSpewColor(constraint), constraint, InferSpewColorReset(),
 76182:               constraint->kind());
 75615: 
 75615:     JS_ASSERT(constraint->next == NULL);
 75615:     constraint->next = constraintList;
 75615:     constraintList = constraint;
 75615: 
 75615:     if (!callExisting)
 75615:         return;
 75615: 
 79813:     /* If any type is possible, there's no need to worry about specifics. */
 77361:     if (flags & TYPE_FLAG_UNKNOWN) {
 77353:         cx->compartment->types.addPending(cx, constraint, this, Type::UnknownType());
 79813:     } else {
 79813:         /* Enqueue type set members stored as bits. */
 77353:         for (TypeFlags flag = 1; flag < TYPE_FLAG_ANYOBJECT; flag <<= 1) {
 77361:             if (flags & flag) {
 77353:                 Type type = Type::PrimitiveType(TypeFlagPrimitive(flag));
 75615:                 cx->compartment->types.addPending(cx, constraint, this, type);
 75615:             }
 77353:         }
 77353: 
 79813:         /* If any object is possible, skip specifics. */
 77361:         if (flags & TYPE_FLAG_ANYOBJECT) {
 77353:             cx->compartment->types.addPending(cx, constraint, this, Type::AnyObjectType());
 79813:         } else {
 79813:             /* Enqueue specific object types. */
 75919:             unsigned count = getObjectCount();
 75919:             for (unsigned i = 0; i < count; i++) {
 77353:                 TypeObjectKey *object = getObject(i);
 75615:                 if (object)
 79813:                     cx->compartment->types.addPending(cx, constraint, this,
 79813:                                                       Type::ObjectType(object));
 79813:             }
 79813:         }
 75615:     }
 75615: 
 75615:     cx->compartment->types.resolvePending(cx);
 75615: }
 75615: 
 75615: void
 75638: TypeSet::print(JSContext *cx)
 75615: {
 77361:     if (flags & TYPE_FLAG_OWN_PROPERTY)
 75944:         printf(" [own]");
 77361:     if (flags & TYPE_FLAG_CONFIGURED_PROPERTY)
 75944:         printf(" [configured]");
 75944: 
 75948:     if (isDefiniteProperty())
 75948:         printf(" [definite:%d]", definiteSlot());
 75948: 
 77361:     if (baseFlags() == 0 && !baseObjectCount()) {
 75638:         printf(" missing");
 75615:         return;
 75615:     }
 75615: 
 77361:     if (flags & TYPE_FLAG_UNKNOWN)
 75638:         printf(" unknown");
 77361:     if (flags & TYPE_FLAG_ANYOBJECT)
 77353:         printf(" object");
 75615: 
 77361:     if (flags & TYPE_FLAG_UNDEFINED)
 75638:         printf(" void");
 77361:     if (flags & TYPE_FLAG_NULL)
 75638:         printf(" null");
 77361:     if (flags & TYPE_FLAG_BOOLEAN)
 75638:         printf(" bool");
 77361:     if (flags & TYPE_FLAG_INT32)
 75638:         printf(" int");
 77361:     if (flags & TYPE_FLAG_DOUBLE)
 75638:         printf(" float");
 77361:     if (flags & TYPE_FLAG_STRING)
 75638:         printf(" string");
 77361:     if (flags & TYPE_FLAG_LAZYARGS)
 76128:         printf(" lazyargs");
 75615: 
 84755:     uint32_t objectCount = baseObjectCount();
 75720:     if (objectCount) {
 75638:         printf(" object[%u]", objectCount);
 75615: 
 75919:         unsigned count = getObjectCount();
 75919:         for (unsigned i = 0; i < count; i++) {
 77353:             TypeObjectKey *object = getObject(i);
 75615:             if (object)
 77353:                 printf(" %s", TypeString(Type::ObjectType(object)));
 75615:         }
 75615:     }
 75615: }
 75615: 
 82129: bool
 82129: TypeSet::propertyNeedsBarrier(JSContext *cx, jsid id)
 82129: {
 82129:     id = MakeTypeId(cx, id);
 82129: 
 82129:     if (unknownObject())
 82129:         return true;
 82129: 
 82129:     for (unsigned i = 0; i < getObjectCount(); i++) {
 82129:         if (getSingleObject(i))
 82129:             return true;
 82129: 
 82129:         if (types::TypeObject *otype = getTypeObject(i)) {
 82129:             if (otype->unknownProperties())
 82129:                 return true;
 82129: 
 82129:             if (types::TypeSet *propTypes = otype->maybeGetProperty(cx, id)) {
 82129:                 if (propTypes->needsBarrier(cx))
 82129:                     return true;
 82129:             }
 82129:         }
 82129:     }
 82129: 
 82129:     addFreeze(cx);
 82129:     return false;
 82129: }
 82129: 
 76059: /////////////////////////////////////////////////////////////////////
 76059: // TypeSet constraints
 76059: /////////////////////////////////////////////////////////////////////
 75718: 
 75615: /* Standard subset constraint, propagate all types from one set to another. */
 75615: class TypeConstraintSubset : public TypeConstraint
 75615: {
 75615: public:
 75615:     TypeSet *target;
 75615: 
 77353:     TypeConstraintSubset(TypeSet *target)
 77353:         : TypeConstraint("subset"), target(target)
 75615:     {
 75615:         JS_ASSERT(target);
 75615:     }
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type)
 76059:     {
 76059:         /* Basic subset constraint, move all types to the target. */
 76059:         target->addType(cx, type);
 76059:     }
 75615: };
 75615: 
 75615: void
 77353: TypeSet::addSubset(JSContext *cx, TypeSet *target)
 77353: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintSubset>(target));
 75718: }
 75718: 
 75615: /* Constraints for reads/writes on object properties. */
 75615: class TypeConstraintProp : public TypeConstraint
 75615: {
 75615: public:
 77353:     JSScript *script;
 76103:     jsbytecode *pc;
 75615: 
 75615:     /*
 75615:      * If assign is true, the target is used to update a property of the object.
 75615:      * If assign is false, the target is assigned the value of the property.
 75615:      */
 75615:     bool assign;
 75615:     TypeSet *target;
 75615: 
 75615:     /* Property being accessed. */
 75615:     jsid id;
 75615: 
 76103:     TypeConstraintProp(JSScript *script, jsbytecode *pc,
 75708:                        TypeSet *target, jsid id, bool assign)
 77353:         : TypeConstraint("prop"), script(script), pc(pc),
 75708:           assign(assign), target(target), id(id)
 75615:     {
 77357:         JS_ASSERT(script && pc && target);
 75615:     }
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type);
 75615: };
 75615: 
 75615: void
 76103: TypeSet::addGetProperty(JSContext *cx, JSScript *script, jsbytecode *pc,
 75708:                         TypeSet *target, jsid id)
 75615: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintProp>(script, pc, target, id, false));
 75615: }
 75615: 
 75615: void
 76103: TypeSet::addSetProperty(JSContext *cx, JSScript *script, jsbytecode *pc,
 75708:                         TypeSet *target, jsid id)
 75615: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintProp>(script, pc, target, id, true));
 75615: }
 75615: 
 76136: /*
 76136:  * Constraints for updating the 'this' types of callees on CALLPROP/CALLELEM.
 76136:  * These are derived from the types on the properties themselves, rather than
 76136:  * those pushed in the 'this' slot at the call site, which allows us to retain
 76136:  * correlations between the type of the 'this' object and the associated
 76136:  * callee scripts at polymorphic call sites.
 76136:  */
 76136: class TypeConstraintCallProp : public TypeConstraint
 76136: {
 76136: public:
 77353:     JSScript *script;
 76136:     jsbytecode *callpc;
 76136: 
 76136:     /* Property being accessed. */
 76136:     jsid id;
 76136: 
 76136:     TypeConstraintCallProp(JSScript *script, jsbytecode *callpc, jsid id)
 77353:         : TypeConstraint("callprop"), script(script), callpc(callpc), id(id)
 76136:     {
 76136:         JS_ASSERT(script && callpc);
 76136:     }
 76136: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type);
 76136: };
 76136: 
 76136: void
 76136: TypeSet::addCallProperty(JSContext *cx, JSScript *script, jsbytecode *pc, jsid id)
 76136: {
 76136:     /*
 76136:      * For calls which will go through JSOP_NEW, don't add any constraints to
 76136:      * modify the 'this' types of callees. The initial 'this' value will be
 76136:      * outright ignored.
 76136:      */
 77391:     jsbytecode *callpc = script->analysis()->getCallPC(pc);
 76136:     if (JSOp(*callpc) == JSOP_NEW)
 76136:         return;
 76136: 
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintCallProp>(script, callpc, id));
 76136: }
 76136: 
 75615: /*
 77399:  * Constraints for generating 'set' property constraints on a SETELEM only if
 77399:  * the element type may be a number. For SETELEM we only account for integer
 77399:  * indexes, and if the element cannot be an integer (e.g. it must be a string)
 77399:  * then we lose precision by treating it like one.
 77399:  */
 77399: class TypeConstraintSetElement : public TypeConstraint
 77399: {
 77399: public:
 77399:     JSScript *script;
 77399:     jsbytecode *pc;
 77399: 
 77399:     TypeSet *objectTypes;
 77399:     TypeSet *valueTypes;
 77399: 
 77399:     TypeConstraintSetElement(JSScript *script, jsbytecode *pc,
 77399:                              TypeSet *objectTypes, TypeSet *valueTypes)
 77399:         : TypeConstraint("setelement"), script(script), pc(pc),
 77399:           objectTypes(objectTypes), valueTypes(valueTypes)
 77399:     {
 77399:         JS_ASSERT(script && pc);
 77399:     }
 77399: 
 77399:     void newType(JSContext *cx, TypeSet *source, Type type);
 77399: };
 77399: 
 77399: void
 77399: TypeSet::addSetElement(JSContext *cx, JSScript *script, jsbytecode *pc,
 77399:                        TypeSet *objectTypes, TypeSet *valueTypes)
 77399: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintSetElement>(script, pc, objectTypes,
 79410:                                                                valueTypes));
 77399: }
 77399: 
 77399: /*
 75615:  * Constraints for watching call edges as they are discovered and invoking native
 75615:  * function handlers, adding constraints for arguments, receiver objects and the
 75615:  * return value, and updating script foundOffsets.
 75615:  */
 75615: class TypeConstraintCall : public TypeConstraint
 75615: {
 75615: public:
 75615:     /* Call site being tracked. */
 75615:     TypeCallsite *callsite;
 75615: 
 75615:     TypeConstraintCall(TypeCallsite *callsite)
 77353:         : TypeConstraint("call"), callsite(callsite)
 75615:     {}
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type);
 75615: };
 75615: 
 75615: void
 75615: TypeSet::addCall(JSContext *cx, TypeCallsite *site)
 75615: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintCall>(site));
 75615: }
 75615: 
 75615: /* Constraints for arithmetic operations. */
 75615: class TypeConstraintArith : public TypeConstraint
 75615: {
 75615: public:
 93651:     JSScript *script;
 93651:     jsbytecode *pc;
 93651: 
 75615:     /* Type set receiving the result of the arithmetic. */
 75615:     TypeSet *target;
 75615: 
 75615:     /* For addition operations, the other operand. */
 75615:     TypeSet *other;
 75615: 
 93651:     TypeConstraintArith(JSScript *script, jsbytecode *pc, TypeSet *target, TypeSet *other)
 93651:         : TypeConstraint("arith"), script(script), pc(pc), target(target), other(other)
 75615:     {
 75615:         JS_ASSERT(target);
 75615:     }
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type);
 75615: };
 75615: 
 75615: void
 93651: TypeSet::addArith(JSContext *cx, JSScript *script, jsbytecode *pc, TypeSet *target, TypeSet *other)
 93651: {
 93651:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintArith>(script, pc, target, other));
 75615: }
 75615: 
 75615: /* Subset constraint which transforms primitive values into appropriate objects. */
 75615: class TypeConstraintTransformThis : public TypeConstraint
 75615: {
 75615: public:
 77353:     JSScript *script;
 75615:     TypeSet *target;
 75615: 
 75708:     TypeConstraintTransformThis(JSScript *script, TypeSet *target)
 77353:         : TypeConstraint("transformthis"), script(script), target(target)
 75615:     {}
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type);
 75615: };
 75615: 
 75615: void
 75708: TypeSet::addTransformThis(JSContext *cx, JSScript *script, TypeSet *target)
 75615: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintTransformThis>(script, target));
 75615: }
 75615: 
 76103: /*
 76103:  * Constraint which adds a particular type to the 'this' types of all
 76103:  * discovered scripted functions.
 76103:  */
 76103: class TypeConstraintPropagateThis : public TypeConstraint
 76103: {
 76103: public:
 77353:     JSScript *script;
 76136:     jsbytecode *callpc;
 77353:     Type type;
 78457:     TypeSet *types;
 78457: 
 78457:     TypeConstraintPropagateThis(JSScript *script, jsbytecode *callpc, Type type, TypeSet *types)
 78457:         : TypeConstraint("propagatethis"), script(script), callpc(callpc), type(type), types(types)
 76103:     {}
 76103: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type);
 76103: };
 76103: 
 76103: void
 78457: TypeSet::addPropagateThis(JSContext *cx, JSScript *script, jsbytecode *pc, Type type, TypeSet *types)
 76103: {
 76136:     /* Don't add constraints when the call will be 'new' (see addCallProperty). */
 77391:     jsbytecode *callpc = script->analysis()->getCallPC(pc);
 76103:     if (JSOp(*callpc) == JSOP_NEW)
 76103:         return;
 76136: 
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintPropagateThis>(script, callpc, type, types));
 76103: }
 76103: 
 75615: /* Subset constraint which filters out primitive types. */
 75615: class TypeConstraintFilterPrimitive : public TypeConstraint
 75615: {
 75615: public:
 75615:     TypeSet *target;
 77884:     TypeSet::FilterKind filter;
 77884: 
 77884:     TypeConstraintFilterPrimitive(TypeSet *target, TypeSet::FilterKind filter)
 77884:         : TypeConstraint("filter"), target(target), filter(filter)
 75615:     {}
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type)
 76059:     {
 77884:         switch (filter) {
 77884:           case TypeSet::FILTER_ALL_PRIMITIVES:
 77884:             if (type.isPrimitive())
 77884:                 return;
 77884:             break;
 77884: 
 77884:           case TypeSet::FILTER_NULL_VOID:
 77353:             if (type.isPrimitive(JSVAL_TYPE_NULL) || type.isPrimitive(JSVAL_TYPE_UNDEFINED))
 76059:                 return;
 77884:             break;
 77884: 
 77884:           case TypeSet::FILTER_VOID:
 77884:             if (type.isPrimitive(JSVAL_TYPE_UNDEFINED))
 76059:                 return;
 77884:             break;
 77884: 
 77884:           default:
 77884:             JS_NOT_REACHED("Bad filter");
 76059:         }
 76059: 
 76059:         target->addType(cx, type);
 76059:     }
 75615: };
 75615: 
 75615: void
 77884: TypeSet::addFilterPrimitives(JSContext *cx, TypeSet *target, FilterKind filter)
 77884: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintFilterPrimitive>(target, filter));
 75615: }
 75615: 
 77461: /* If id is a normal slotful 'own' property of an object, get its shape. */
 77461: static inline const Shape *
 78194: GetSingletonShape(JSContext *cx, JSObject *obj, jsid id)
 78194: {
 78194:     const Shape *shape = obj->nativeLookup(cx, id);
 94227:     if (shape && shape->hasDefaultGetter() && shape->hasSlot())
 77461:         return shape;
 77461:     return NULL;
 77461: }
 77461: 
 76087: void
 84755: ScriptAnalysis::pruneTypeBarriers(JSContext *cx, uint32_t offset)
 76087: {
 76087:     TypeBarrier **pbarrier = &getCode(offset).typeBarriers;
 76087:     while (*pbarrier) {
 76087:         TypeBarrier *barrier = *pbarrier;
 76087:         if (barrier->target->hasType(barrier->type)) {
 76087:             /* Barrier is now obsolete, it can be removed. */
 76087:             *pbarrier = barrier->next;
 77460:             continue;
 77460:         }
 77460:         if (barrier->singleton) {
 77460:             JS_ASSERT(barrier->type.isPrimitive(JSVAL_TYPE_UNDEFINED));
 78194:             const Shape *shape = GetSingletonShape(cx, barrier->singleton, barrier->singletonId);
 83221:             if (shape && !barrier->singleton->nativeGetSlot(shape->slot()).isUndefined()) {
 77460:                 /*
 77460:                  * When we analyzed the script the singleton had an 'own'
 77460:                  * property which was undefined (probably a 'var' variable
 77460:                  * added to a global object), but now it is defined. The only
 77460:                  * way it can become undefined again is if an explicit assign
 77460:                  * or deletion on the property occurs, which will update the
 77460:                  * type set for the property directly and trigger construction
 77460:                  * of a normal type barrier.
 77460:                  */
 77460:                 *pbarrier = barrier->next;
 77460:                 continue;
 77460:             }
 77460:         }
 76103:         pbarrier = &barrier->next;
 76103:     }
 76103: }
 76103: 
 76103: /*
 76103:  * Cheesy limit on the number of objects we will tolerate in an observed type
 76103:  * set before refusing to add new type barriers for objects.
 76103:  * :FIXME: this heuristic sucks, and doesn't handle calls.
 76103:  */
 84755: static const uint32_t BARRIER_OBJECT_LIMIT = 10;
 84755: 
 84755: void ScriptAnalysis::breakTypeBarriers(JSContext *cx, uint32_t offset, bool all)
 76103: {
 78194:     pruneTypeBarriers(cx, offset);
 77461: 
 79985:     bool resetResolving = !cx->compartment->types.resolving;
 79985:     if (resetResolving)
 79985:         cx->compartment->types.resolving = true;
 79985: 
 76103:     TypeBarrier **pbarrier = &getCode(offset).typeBarriers;
 76103:     while (*pbarrier) {
 76103:         TypeBarrier *barrier = *pbarrier;
 77463:         if (barrier->target->hasType(barrier->type) ) {
 77463:             /*
 77463:              * Barrier is now obsolete, it can be removed. This is not
 77463:              * redundant with the pruneTypeBarriers() call above, as breaking
 77463:              * previous type barriers may have modified the target type set.
 77463:              */
 77463:             *pbarrier = barrier->next;
 77463:         } else if (all) {
 76087:             /* Force removal of the barrier. */
 76103:             barrier->target->addType(cx, barrier->type);
 76087:             *pbarrier = barrier->next;
 77353:         } else if (!barrier->type.isUnknown() &&
 77353:                    !barrier->type.isAnyObject() &&
 77353:                    barrier->type.isObject() &&
 77353:                    barrier->target->getObjectCount() >= BARRIER_OBJECT_LIMIT) {
 77353:             /* Maximum number of objects in the set exceeded. */
 77353:             barrier->target->addType(cx, barrier->type);
 77353:             *pbarrier = barrier->next;
 76087:         } else {
 76087:             pbarrier = &barrier->next;
 76087:         }
 76087:     }
 79985: 
 79985:     if (resetResolving) {
 79985:         cx->compartment->types.resolving = false;
 79985:         cx->compartment->types.resolvePending(cx);
 79985:     }
 76087: }
 76087: 
 76103: void ScriptAnalysis::breakTypeBarriersSSA(JSContext *cx, const SSAValue &v)
 76103: {
 76103:     if (v.kind() != SSAValue::PUSHED)
 76103:         return;
 76103: 
 84755:     uint32_t offset = v.pushedOffset();
 76103:     if (JSOp(script->code[offset]) == JSOP_GETPROP)
 76103:         breakTypeBarriersSSA(cx, poppedValue(offset, 0));
 76103: 
 76103:     breakTypeBarriers(cx, offset, true);
 76103: }
 76103: 
 76087: /*
 76087:  * Subset constraint for property reads and argument passing which can add type
 76087:  * barriers on the read instead of passing types along.
 76087:  */
 76087: class TypeConstraintSubsetBarrier : public TypeConstraint
 75615: {
 75615: public:
 77353:     JSScript *script;
 76103:     jsbytecode *pc;
 75615:     TypeSet *target;
 75615: 
 76103:     TypeConstraintSubsetBarrier(JSScript *script, jsbytecode *pc, TypeSet *target)
 77353:         : TypeConstraint("subsetBarrier"), script(script), pc(pc), target(target)
 77439:     {}
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type)
 76059:     {
 80025:         if (!target->hasType(type))
 77391:             script->analysis()->addTypeBarrier(cx, pc, target, type);
 76059:     }
 75615: };
 75615: 
 75615: void
 76103: TypeSet::addSubsetBarrier(JSContext *cx, JSScript *script, jsbytecode *pc, TypeSet *target)
 75615: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintSubsetBarrier>(script, pc, target));
 75615: }
 75615: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // TypeConstraint
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75615: /* Get the object to use for a property access on type. */
 75615: static inline TypeObject *
 77353: GetPropertyObject(JSContext *cx, JSScript *script, Type type)
 77353: {
 77353:     if (type.isTypeObject())
 77353:         return type.typeObject();
 77353: 
 77353:     /* Force instantiation of lazy types for singleton objects. */
 77353:     if (type.isSingleObject())
 77353:         return type.singleObject()->getType(cx);
 75615: 
 75615:     /*
 75615:      * Handle properties attached to primitive types, treating this access as a
 75615:      * read on the primitive's new object.
 75615:      */
 75720:     TypeObject *object = NULL;
 77353:     switch (type.primitive()) {
 77353: 
 77353:       case JSVAL_TYPE_INT32:
 77353:       case JSVAL_TYPE_DOUBLE:
 77391:         object = TypeScript::StandardType(cx, script, JSProto_Number);
 75720:         break;
 75615: 
 77353:       case JSVAL_TYPE_BOOLEAN:
 77391:         object = TypeScript::StandardType(cx, script, JSProto_Boolean);
 75720:         break;
 75615: 
 77353:       case JSVAL_TYPE_STRING:
 77391:         object = TypeScript::StandardType(cx, script, JSProto_String);
 75720:         break;
 75615: 
 75615:       default:
 76130:         /* undefined, null and lazy arguments do not have properties. */
 75615:         return NULL;
 75615:     }
 75720: 
 75720:     if (!object)
 75720:         cx->compartment->types.setPendingNukeTypes(cx);
 75720:     return object;
 75615: }
 75615: 
 76175: static inline bool
 76175: UsePropertyTypeBarrier(jsbytecode *pc)
 76175: {
 76175:     /*
 76175:      * At call opcodes, type barriers can only be added for the call bindings,
 76175:      * which TypeConstraintCall will add barrier constraints for directly.
 76175:      */
 84755:     uint32_t format = js_CodeSpec[*pc].format;
 76175:     return (format & JOF_TYPESET) && !(format & JOF_INVOKE);
 76175: }
 76175: 
 76128: static inline void
 76128: MarkPropertyAccessUnknown(JSContext *cx, JSScript *script, jsbytecode *pc, TypeSet *target)
 76128: {
 76175:     if (UsePropertyTypeBarrier(pc))
 77391:         script->analysis()->addTypeBarrier(cx, pc, target, Type::UnknownType());
 76128:     else
 77353:         target->addType(cx, Type::UnknownType());
 76128: }
 76128: 
 75636: /*
 75636:  * Handle a property access on a specific object. All property accesses go through
 75636:  * here, whether via x.f, x[f], or global name accesses.
 75636:  */
 75636: static inline void
 76103: PropertyAccess(JSContext *cx, JSScript *script, jsbytecode *pc, TypeObject *object,
 75636:                bool assign, TypeSet *target, jsid id)
 75636: {
 75876:     /* Reads from objects with unknown properties are unknown, writes to such objects are ignored. */
 75989:     if (object->unknownProperties()) {
 75876:         if (!assign)
 76128:             MarkPropertyAccessUnknown(cx, script, pc, target);
 75876:         return;
 75876:     }
 75876: 
 75636:     /* Capture the effects of a standard property access. */
 75641:     TypeSet *types = object->getProperty(cx, id, assign);
 75720:     if (!types)
 75720:         return;
 77361:     if (assign) {
 77353:         target->addSubset(cx, types);
 77361:     } else {
 77361:         if (!types->hasPropagatedProperty())
 77361:             object->getFromPrototypes(cx, id, types);
 77460:         if (UsePropertyTypeBarrier(pc)) {
 76087:             types->addSubsetBarrier(cx, script, pc, target);
 77461:             if (object->singleton && !JSID_IS_VOID(id)) {
 77460:                 /*
 77461:                  * Add a singleton type barrier on the object if it has an
 77461:                  * 'own' property which is currently undefined. We'll be able
 77461:                  * to remove the barrier after the property becomes defined,
 77461:                  * even if no undefined value is ever observed at pc.
 77460:                  */
 78194:                 const Shape *shape = GetSingletonShape(cx, object->singleton, id);
 83221:                 if (shape && object->singleton->nativeGetSlot(shape->slot()).isUndefined())
 77460:                     script->analysis()->addSingletonTypeBarrier(cx, pc, target, object->singleton, id);
 77460:             }
 77460:         } else {
 77353:             types->addSubset(cx, target);
 77353:         }
 77361:     }
 77460: }
 77353: 
 77353: /* Whether the JSObject/TypeObject referent of an access on type cannot be determined. */
 77353: static inline bool
 77353: UnknownPropertyAccess(JSScript *script, Type type)
 77353: {
 77353:     return type.isUnknown()
 77353:         || type.isAnyObject()
 77353:         || (!type.isObject() && !script->hasGlobal());
 75636: }
 75636: 
 75615: void
 77353: TypeConstraintProp::newType(JSContext *cx, TypeSet *source, Type type)
 75615: {
 77353:     if (UnknownPropertyAccess(script, type)) {
 75633:         /*
 75633:          * Access on an unknown object. Reads produce an unknown result, writes
 77353:          * need to be monitored.
 75633:          */
 75633:         if (assign)
 75708:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
 75633:         else
 76128:             MarkPropertyAccessUnknown(cx, script, pc, target);
 76128:         return;
 76128:     }
 76128: 
 77353:     if (type.isPrimitive(JSVAL_TYPE_MAGIC)) {
 76136:         /* Ignore cases which will be accounted for by the followEscapingArguments analysis. */
 76128:         if (assign || (id != JSID_VOID && id != id_length(cx)))
 76128:             return;
 76128: 
 76128:         if (id == JSID_VOID)
 76128:             MarkPropertyAccessUnknown(cx, script, pc, target);
 76128:         else
 77353:             target->addType(cx, Type::Int32Type());
 75615:         return;
 75615:     }
 75615: 
 75708:     TypeObject *object = GetPropertyObject(cx, script, type);
 76136:     if (object)
 76136:         PropertyAccess(cx, script, pc, object, assign, target, id);
 76136: }
 76136: 
 76136: void
 77353: TypeConstraintCallProp::newType(JSContext *cx, TypeSet *source, Type type)
 76136: {
 76136:     /*
 78457:      * For CALLPROP, we need to update not just the pushed types but also the
 78457:      * 'this' types of possible callees. If we can't figure out that set of
 78457:      * callees, monitor the call to make sure discovered callees get their
 78457:      * 'this' types updated.
 76136:      */
 76136: 
 77353:     if (UnknownPropertyAccess(script, type)) {
 76136:         cx->compartment->types.monitorBytecode(cx, script, callpc - script->code);
 76136:         return;
 76136:     }
 76136: 
 76136:     TypeObject *object = GetPropertyObject(cx, script, type);
 76103:     if (object) {
 76136:         if (object->unknownProperties()) {
 76136:             cx->compartment->types.monitorBytecode(cx, script, callpc - script->code);
 76136:         } else {
 76103:             TypeSet *types = object->getProperty(cx, id, false);
 76103:             if (!types)
 76103:                 return;
 77361:             if (!types->hasPropagatedProperty())
 77361:                 object->getFromPrototypes(cx, id, types);
 76136:             /* Bypass addPropagateThis, we already have the callpc. */
 79410:             types->add(cx, cx->typeLifoAlloc().new_<TypeConstraintPropagateThis>(
 79410:                             script, callpc, type, (TypeSet *) NULL));
 76103:         }
 76103:     }
 75615: }
 75615: 
 75615: void
 77399: TypeConstraintSetElement::newType(JSContext *cx, TypeSet *source, Type type)
 77399: {
 77399:     if (type.isUnknown() ||
 77399:         type.isPrimitive(JSVAL_TYPE_INT32) ||
 77399:         type.isPrimitive(JSVAL_TYPE_DOUBLE)) {
 77399:         objectTypes->addSetProperty(cx, script, pc, valueTypes, JSID_VOID);
 77399:     }
 77399: }
 77399: 
 77399: void
 77353: TypeConstraintCall::newType(JSContext *cx, TypeSet *source, Type type)
 75615: {
 75708:     JSScript *script = callsite->script;
 76103:     jsbytecode *pc = callsite->pc;
 75708: 
 77353:     if (type.isUnknown() || type.isAnyObject()) {
 75615:         /* Monitor calls on unknown functions. */
 75708:         cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
 75615:         return;
 75615:     }
 75615: 
 77884:     JSFunction *callee = NULL;
 77353: 
 77353:     if (type.isSingleObject()) {
 77353:         JSObject *obj = type.singleObject();
 77353: 
 77353:         if (!obj->isFunction()) {
 77353:             /* Calls on non-functions are dynamically monitored. */
 75822:             return;
 77353:         }
 77353: 
 83234:         if (obj->toFunction()->isNative()) {
 75822:             /*
 76175:              * The return value and all side effects within native calls should
 76175:              * be dynamically monitored, except when the compiler is generating
 76175:              * specialized inline code or stub calls for a specific natives and
 76175:              * knows about the behavior of that native.
 75822:              */
 76175:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code, true);
 76175: 
 76108:             /*
 77353:              * Add type constraints capturing the possible behavior of
 77353:              * specialized natives which operate on properties. :XXX: use
 77353:              * better factoring for both this and the compiler code itself
 77353:              * which specializes particular natives.
 76108:              */
 76175: 
 83234:             Native native = obj->toFunction()->native();
 76175: 
 76175:             if (native == js::array_push) {
 77413:                 for (size_t i = 0; i < callsite->argumentCount; i++) {
 76175:                     callsite->thisTypes->addSetProperty(cx, script, pc,
 77413:                                                         callsite->argumentTypes[i], JSID_VOID);
 76175:                 }
 76175:             }
 76175: 
 80556:             if (native == js::array_pop || native == js::array_shift)
 76175:                 callsite->thisTypes->addGetProperty(cx, script, pc, callsite->returnTypes, JSID_VOID);
 76175: 
 77413:             if (native == js_Array) {
 77413:                 TypeObject *res = TypeScript::InitObject(cx, script, pc, JSProto_Array);
 77413:                 if (!res)
 77413:                     return;
 77413: 
 77413:                 callsite->returnTypes->addType(cx, Type::ObjectType(res));
 77413: 
 77413:                 if (callsite->argumentCount >= 2) {
 77413:                     for (unsigned i = 0; i < callsite->argumentCount; i++) {
 77413:                         PropertyAccess(cx, script, pc, res, true,
 77413:                                        callsite->argumentTypes[i], JSID_VOID);
 77413:                     }
 77413:                 }
 77413:             }
 77413: 
 76108:             return;
 76108:         }
 75615: 
 83234:         callee = obj->toFunction();
 77353:     } else if (type.isTypeObject()) {
 77884:         callee = type.typeObject()->interpretedFunction;
 77353:         if (!callee)
 77353:             return;
 77353:     } else {
 77353:         /* Calls on non-objects are dynamically monitored. */
 77353:         return;
 77353:     }
 77353: 
 83256:     if (!callee->script()->ensureHasTypes(cx))
 76092:         return;
 76092: 
 77884:     unsigned nargs = callee->nargs;
 75615: 
 75615:     /* Add bindings for the arguments of the call. */
 75708:     for (unsigned i = 0; i < callsite->argumentCount && i < nargs; i++) {
 75615:         TypeSet *argTypes = callsite->argumentTypes[i];
 77884:         TypeSet *types = TypeScript::ArgTypes(callee->script(), i);
 76087:         argTypes->addSubsetBarrier(cx, script, pc, types);
 75615:     }
 75615: 
 75615:     /* Add void type for any formals in the callee not supplied at the call site. */
 75708:     for (unsigned i = callsite->argumentCount; i < nargs; i++) {
 77884:         TypeSet *types = TypeScript::ArgTypes(callee->script(), i);
 77353:         types->addType(cx, Type::UndefinedType());
 75615:     }
 75615: 
 77884:     TypeSet *thisTypes = TypeScript::ThisTypes(callee->script());
 77884:     TypeSet *returnTypes = TypeScript::ReturnTypes(callee->script());
 77884: 
 75615:     if (callsite->isNew) {
 75615:         /*
 77361:          * If the script does not return a value then the pushed value is the
 77361:          * new object (typical case). Note that we don't model construction of
 77361:          * the new value, which is done dynamically; we don't keep track of the
 77361:          * possible 'new' types for a given prototype type object.
 75615:          */
 77884:         thisTypes->addSubset(cx, callsite->returnTypes);
 77884:         returnTypes->addFilterPrimitives(cx, callsite->returnTypes,
 77884:                                          TypeSet::FILTER_ALL_PRIMITIVES);
 75615:     } else {
 76103:         /*
 76103:          * Add a binding for the return value of the call. We don't add a
 76103:          * binding for the receiver object, as this is done with PropagateThis
 76103:          * constraints added by the original JSOP_CALL* op. The type sets we
 76103:          * manipulate here have lost any correlations between particular types
 76103:          * in the 'this' and 'callee' sets, which we want to maintain for
 76103:          * polymorphic JSOP_CALLPROP invocations.
 76103:          */
 77884:         returnTypes->addSubset(cx, callsite->returnTypes);
 75615:     }
 75615: }
 75615: 
 75615: void
 77353: TypeConstraintPropagateThis::newType(JSContext *cx, TypeSet *source, Type type)
 77353: {
 77353:     if (type.isUnknown() || type.isAnyObject()) {
 76103:         /*
 76136:          * The callee is unknown, make sure the call is monitored so we pick up
 76136:          * possible this/callee correlations. This only comes into play for
 78457:          * CALLPROP, for other calls we are past the type barrier and a
 78457:          * TypeConstraintCall will also monitor the call.
 76103:          */
 76136:         cx->compartment->types.monitorBytecode(cx, script, callpc - script->code);
 76103:         return;
 76136:     }
 76136: 
 77353:     /* Ignore calls to natives, these will be handled by TypeConstraintCall. */
 77884:     JSFunction *callee = NULL;
 77353: 
 77353:     if (type.isSingleObject()) {
 77353:         JSObject *object = type.singleObject();
 83234:         if (!object->isFunction() || !object->toFunction()->isInterpreted())
 77353:             return;
 83234:         callee = object->toFunction();
 77353:     } else if (type.isTypeObject()) {
 77353:         TypeObject *object = type.typeObject();
 77884:         if (!object->interpretedFunction)
 77353:             return;
 77884:         callee = object->interpretedFunction;
 77353:     } else {
 76136:         /* Ignore calls to primitives, these will go through a stub. */
 76136:         return;
 77353:     }
 76103: 
 83256:     if (!callee->script()->ensureHasTypes(cx))
 76103:         return;
 76103: 
 78457:     TypeSet *thisTypes = TypeScript::ThisTypes(callee->script());
 78457:     if (this->types)
 78457:         this->types->addSubset(cx, thisTypes);
 78457:     else
 78457:         thisTypes->addType(cx, this->type);
 76103: }
 76103: 
 76103: void
 77353: TypeConstraintArith::newType(JSContext *cx, TypeSet *source, Type type)
 75615: {
 75820:     /*
 75820:      * We only model a subset of the arithmetic behavior that is actually
 75820:      * possible. The following need to be watched for at runtime:
 75820:      *
 75820:      * 1. Operations producing a double where no operand was a double.
 75820:      * 2. Operations producing a string where no operand was a string (addition only).
 75820:      * 3. Operations producing a value other than int/double/string.
 75820:      */
 75615:     if (other) {
 75615:         /*
 75615:          * Addition operation, consider these cases:
 75633:          *   {int,bool} x {int,bool} -> int
 75820:          *   double x {int,bool,double} -> double
 75615:          *   string x any -> string
 75615:          */
 77353:         if (type.isUnknown() || other->unknown()) {
 77353:             target->addType(cx, Type::UnknownType());
 77353:         } else if (type.isPrimitive(JSVAL_TYPE_DOUBLE)) {
 75919:             if (other->hasAnyFlag(TYPE_FLAG_UNDEFINED | TYPE_FLAG_NULL |
 77353:                                   TYPE_FLAG_INT32 | TYPE_FLAG_DOUBLE | TYPE_FLAG_BOOLEAN |
 93651:                                   TYPE_FLAG_ANYOBJECT)) {
 77353:                 target->addType(cx, Type::DoubleType());
 93651:             } else if (other->getObjectCount() != 0) {
 93651:                 TypeDynamicResult(cx, script, pc, Type::DoubleType());
 77353:             }
 77353:         } else if (type.isPrimitive(JSVAL_TYPE_STRING)) {
 77353:             target->addType(cx, Type::StringType());
 93651:         } else if (other->hasAnyFlag(TYPE_FLAG_DOUBLE)) {
 93651:             target->addType(cx, Type::DoubleType());
 93651:         } else if (other->hasAnyFlag(TYPE_FLAG_UNDEFINED | TYPE_FLAG_NULL |
 77353:                                      TYPE_FLAG_INT32 | TYPE_FLAG_BOOLEAN |
 93651:                                      TYPE_FLAG_ANYOBJECT)) {
 77353:             target->addType(cx, Type::Int32Type());
 93651:         } else if (other->getObjectCount() != 0) {
 93651:             TypeDynamicResult(cx, script, pc, Type::Int32Type());
 75615:         }
 75615:     } else {
 77353:         if (type.isUnknown())
 77353:             target->addType(cx, Type::UnknownType());
 77353:         else if (type.isPrimitive(JSVAL_TYPE_DOUBLE))
 77353:             target->addType(cx, Type::DoubleType());
 93651:         else if (!type.isAnyObject() && type.isObject())
 93651:             TypeDynamicResult(cx, script, pc, Type::Int32Type());
 77353:         else
 77353:             target->addType(cx, Type::Int32Type());
 75615:     }
 75615: }
 75615: 
 75615: void
 77353: TypeConstraintTransformThis::newType(JSContext *cx, TypeSet *source, Type type)
 77353: {
 77353:     if (type.isUnknown() || type.isAnyObject() || type.isObject() || script->strictModeCode) {
 75615:         target->addType(cx, type);
 75615:         return;
 75615:     }
 75615: 
 76029:     /*
 76029:      * Note: if |this| is null or undefined, the pushed value is the outer window. We
 76029:      * can't use script->getGlobalType() here because it refers to the inner window.
 76029:      */
 77353:     if (!script->hasGlobal() ||
 77353:         type.isPrimitive(JSVAL_TYPE_NULL) ||
 77353:         type.isPrimitive(JSVAL_TYPE_UNDEFINED)) {
 77353:         target->addType(cx, Type::UnknownType());
 75688:         return;
 75688:     }
 75688: 
 75615:     TypeObject *object = NULL;
 77353:     switch (type.primitive()) {
 77353:       case JSVAL_TYPE_INT32:
 77353:       case JSVAL_TYPE_DOUBLE:
 77391:         object = TypeScript::StandardType(cx, script, JSProto_Number);
 75615:         break;
 77353:       case JSVAL_TYPE_BOOLEAN:
 77391:         object = TypeScript::StandardType(cx, script, JSProto_Boolean);
 75615:         break;
 77353:       case JSVAL_TYPE_STRING:
 77391:         object = TypeScript::StandardType(cx, script, JSProto_String);
 75615:         break;
 75615:       default:
 76130:         return;
 75615:     }
 75615: 
 75720:     if (!object) {
 75720:         cx->compartment->types.setPendingNukeTypes(cx);
 75720:         return;
 75720:     }
 75720: 
 77353:     target->addType(cx, Type::ObjectType(object));
 75615: }
 75615: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // Freeze constraints
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75775: /* Constraint which triggers recompilation of a script if any type is added to a type set. */
 75794: class TypeConstraintFreeze : public TypeConstraint
 75775: {
 75775: public:
 87654:     RecompileInfo info;
 77353: 
 75794:     /* Whether a new type has already been added, triggering recompilation. */
 75775:     bool typeAdded;
 75775: 
 87654:     TypeConstraintFreeze(RecompileInfo info)
 87654:         : TypeConstraint("freeze"), info(info), typeAdded(false)
 75775:     {}
 75775: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type)
 75775:     {
 75775:         if (typeAdded)
 75775:             return;
 75775: 
 75775:         typeAdded = true;
 87654:         cx->compartment->types.addPendingRecompile(cx, info);
 75775:     }
 75775: };
 75775: 
 75794: void
 75893: TypeSet::addFreeze(JSContext *cx)
 75870: {
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreeze>(
 87654:                 cx->compartment->types.compiledInfo), false);
 75870: }
 75870: 
 75615: /*
 75623:  * Constraint which triggers recompilation of a script if a possible new JSValueType
 75623:  * tag is realized for a type set.
 75615:  */
 75623: class TypeConstraintFreezeTypeTag : public TypeConstraint
 75615: {
 75615: public:
 87654:     RecompileInfo info;
 77353: 
 75623:     /*
 75623:      * Whether the type tag has been marked unknown due to a type change which
 75623:      * occurred after this constraint was generated (and which triggered recompilation).
 75623:      */
 75623:     bool typeUnknown;
 75623: 
 87654:     TypeConstraintFreezeTypeTag(RecompileInfo info)
 87654:         : TypeConstraint("freezeTypeTag"), info(info), typeUnknown(false)
 75615:     {}
 75615: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type)
 75615:     {
 75623:         if (typeUnknown)
 75623:             return;
 75623: 
 77353:         if (!type.isUnknown() && !type.isAnyObject() && type.isObject()) {
 75623:             /* Ignore new objects when the type set already has other objects. */
 75919:             if (source->getObjectCount() >= 2)
 75615:                 return;
 75615:         }
 75615: 
 75623:         typeUnknown = true;
 87654:         cx->compartment->types.addPendingRecompile(cx, info);
 75615:     }
 75615: };
 75615: 
 75625: static inline JSValueType
 75625: GetValueTypeFromTypeFlags(TypeFlags flags)
 75625: {
 75625:     switch (flags) {
 75625:       case TYPE_FLAG_UNDEFINED:
 75625:         return JSVAL_TYPE_UNDEFINED;
 75625:       case TYPE_FLAG_NULL:
 75625:         return JSVAL_TYPE_NULL;
 75625:       case TYPE_FLAG_BOOLEAN:
 75625:         return JSVAL_TYPE_BOOLEAN;
 75625:       case TYPE_FLAG_INT32:
 75625:         return JSVAL_TYPE_INT32;
 75630:       case (TYPE_FLAG_INT32 | TYPE_FLAG_DOUBLE):
 75630:         return JSVAL_TYPE_DOUBLE;
 75625:       case TYPE_FLAG_STRING:
 75625:         return JSVAL_TYPE_STRING;
 76128:       case TYPE_FLAG_LAZYARGS:
 76128:         return JSVAL_TYPE_MAGIC;
 80769:       case TYPE_FLAG_ANYOBJECT:
 80769:         return JSVAL_TYPE_OBJECT;
 75625:       default:
 75625:         return JSVAL_TYPE_UNKNOWN;
 75625:     }
 75625: }
 75625: 
 75625: JSValueType
 75893: TypeSet::getKnownTypeTag(JSContext *cx)
 75615: {
 75944:     TypeFlags flags = baseFlags();
 75720:     JSValueType type;
 75720: 
 77361:     if (baseObjectCount())
 75720:         type = flags ? JSVAL_TYPE_UNKNOWN : JSVAL_TYPE_OBJECT;
 75720:     else
 75720:         type = GetValueTypeFromTypeFlags(flags);
 75636: 
 76001:     /*
 76001:      * If the type set is totally empty then it will be treated as unknown,
 76001:      * but we still need to record the dependency as adding a new type can give
 76001:      * it a definite type tag. This is not needed if there are enough types
 76001:      * that the exact tag is unknown, as it will stay unknown as more types are
 76001:      * added to the set.
 76001:      */
 77361:     bool empty = flags == 0 && baseObjectCount() == 0;
 76001:     JS_ASSERT_IF(empty, type == JSVAL_TYPE_UNKNOWN);
 76001: 
 87654:     if (cx->compartment->types.compiledInfo.script && (empty || type != JSVAL_TYPE_UNKNOWN)) {
 79410:         add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeTypeTag>(
 87654:                   cx->compartment->types.compiledInfo), false);
 75893:     }
 75625: 
 75625:     return type;
 75625: }
 75625: 
 76044: /* Constraint which triggers recompilation if an object acquires particular flags. */
 76044: class TypeConstraintFreezeObjectFlags : public TypeConstraint
 75625: {
 75625: public:
 87654:     RecompileInfo info;
 77353: 
 76044:     /* Flags we are watching for on this object. */
 76044:     TypeObjectFlags flags;
 76044: 
 76044:     /* Whether the object has already been marked as having one of the flags. */
 76044:     bool *pmarked;
 76044:     bool localMarked;
 76044: 
 87654:     TypeConstraintFreezeObjectFlags(RecompileInfo info, TypeObjectFlags flags, bool *pmarked)
 87654:         : TypeConstraint("freezeObjectFlags"), info(info), flags(flags),
 76044:           pmarked(pmarked), localMarked(false)
 75833:     {}
 75833: 
 87654:     TypeConstraintFreezeObjectFlags(RecompileInfo info, TypeObjectFlags flags)
 87654:         : TypeConstraint("freezeObjectFlags"), info(info), flags(flags),
 76044:           pmarked(&localMarked), localMarked(false)
 75919:     {}
 75919: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type) {}
 75833: 
 76097:     void newObjectState(JSContext *cx, TypeObject *object, bool force)
 75625:     {
 76044:         if (object->hasAnyFlags(flags) && !*pmarked) {
 76044:             *pmarked = true;
 87654:             cx->compartment->types.addPendingRecompile(cx, info);
 76097:         } else if (force) {
 87654:             cx->compartment->types.addPendingRecompile(cx, info);
 75625:         }
 75833:     }
 75625: };
 75625: 
 75625: /*
 76044:  * Constraint which triggers recompilation if any object in a type set acquire
 76044:  * particular flags.
 75625:  */
 76044: class TypeConstraintFreezeObjectFlagsSet : public TypeConstraint
 75625: {
 75625: public:
 87654:     RecompileInfo info;
 77353: 
 76044:     TypeObjectFlags flags;
 76044:     bool marked;
 76044: 
 87654:     TypeConstraintFreezeObjectFlagsSet(RecompileInfo info, TypeObjectFlags flags)
 87654:         : TypeConstraint("freezeObjectKindSet"), info(info), flags(flags), marked(false)
 76044:     {}
 75625: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type)
 75625:     {
 76044:         if (marked) {
 75625:             /* Despecialized the kind we were interested in due to recompilation. */
 75625:             return;
 75625:         }
 75625: 
 77353:         if (type.isUnknown() || type.isAnyObject()) {
 76044:             /* Fallthrough and recompile. */
 77353:         } else if (type.isObject()) {
 77353:             TypeObject *object = type.isSingleObject()
 77353:                 ? type.singleObject()->getType(cx)
 77353:                 : type.typeObject();
 76044:             if (!object->hasAnyFlags(flags)) {
 75625:                 /*
 77361:                  * Add a constraint on the the object to pick up changes in the
 77361:                  * object's properties.
 75625:                  */
 77361:                 TypeSet *types = object->getProperty(cx, JSID_EMPTY, false);
 77361:                 if (!types)
 75720:                     return;
 79410:                 types->add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeObjectFlags>(
 87654:                                   info, flags, &marked), false);
 75625:                 return;
 75625:             }
 75833:         } else {
 75833:             return;
 75833:         }
 75636: 
 76044:         marked = true;
 87654:         cx->compartment->types.addPendingRecompile(cx, info);
 75625:     }
 75625: };
 75625: 
 76044: bool
 76044: TypeSet::hasObjectFlags(JSContext *cx, TypeObjectFlags flags)
 75625: {
 77353:     if (unknownObject())
 76044:         return true;
 76019: 
 76053:     /*
 76053:      * Treat type sets containing no objects as having all object flags,
 76053:      * to spare callers from having to check this.
 76053:      */
 77361:     if (baseObjectCount() == 0)
 76053:         return true;
 76053: 
 75919:     unsigned count = getObjectCount();
 75919:     for (unsigned i = 0; i < count; i++) {
 77353:         TypeObject *object = getTypeObject(i);
 77353:         if (!object) {
 77353:             JSObject *obj = getSingleObject(i);
 77353:             if (obj)
 77353:                 object = obj->getType(cx);
 77353:         }
 76044:         if (object && object->hasAnyFlags(flags))
 76044:             return true;
 76044:     }
 76044: 
 75625:     /*
 75625:      * Watch for new objects of different kind, and re-traverse existing types
 75625:      * in this set to add any needed FreezeArray constraints.
 75625:      */
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeObjectFlagsSet>(
 87654:                  cx->compartment->types.compiledInfo, flags));
 76044: 
 76044:     return false;
 76044: }
 76044: 
 76044: bool
 76044: TypeSet::HasObjectFlags(JSContext *cx, TypeObject *object, TypeObjectFlags flags)
 75919: {
 76044:     if (object->hasAnyFlags(flags))
 76044:         return true;
 76044: 
 77361:     TypeSet *types = object->getProperty(cx, JSID_EMPTY, false);
 77361:     if (!types)
 76044:         return true;
 79410:     types->add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeObjectFlags>(
 87654:                       cx->compartment->types.compiledInfo, flags), false);
 76044:     return false;
 75919: }
 75919: 
 75864: static inline void
 76097: ObjectStateChange(JSContext *cx, TypeObject *object, bool markingUnknown, bool force)
 75864: {
 76097:     if (object->unknownProperties())
 76097:         return;
 76097: 
 77361:     /* All constraints listening to state changes are on the empty id. */
 77361:     TypeSet *types = object->maybeGetProperty(cx, JSID_EMPTY);
 77361: 
 77361:     /* Mark as unknown after getting the types, to avoid assertion. */
 77361:     if (markingUnknown)
 77361:         object->flags |= OBJECT_FLAG_DYNAMIC_MASK | OBJECT_FLAG_UNKNOWN_PROPERTIES;
 77361: 
 77361:     if (types) {
 77361:         TypeConstraint *constraint = types->constraintList;
 75864:         while (constraint) {
 76097:             constraint->newObjectState(cx, object, force);
 75864:             constraint = constraint->next;
 75864:         }
 75864:     }
 77361: }
 75864: 
 75944: void
 77414: TypeSet::WatchObjectStateChange(JSContext *cx, TypeObject *obj)
 75944: {
 77414:     JS_ASSERT(!obj->unknownProperties());
 77414:     TypeSet *types = obj->getProperty(cx, JSID_EMPTY, false);
 75944:     if (!types)
 75944:         return;
 75944: 
 76097:     /*
 77414:      * Use a constraint which triggers recompilation when markStateChange is
 77414:      * called, which will set 'force' to true.
 76097:      */
 79410:     types->add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeObjectFlags>(
 87654:                      cx->compartment->types.compiledInfo,
 76097:                      0));
 75944: }
 75944: 
 75944: class TypeConstraintFreezeOwnProperty : public TypeConstraint
 75944: {
 75944: public:
 87654:     RecompileInfo info;
 77353: 
 75944:     bool updated;
 75944:     bool configurable;
 75944: 
 87654:     TypeConstraintFreezeOwnProperty(RecompileInfo info, bool configurable)
 77353:         : TypeConstraint("freezeOwnProperty"),
 87654:           info(info), updated(false), configurable(configurable)
 75944:     {}
 75944: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type) {}
 75944: 
 75944:     void newPropertyState(JSContext *cx, TypeSet *source)
 75944:     {
 75944:         if (updated)
 75944:             return;
 77361:         if (source->isOwnProperty(configurable)) {
 75944:             updated = true;
 87654:             cx->compartment->types.addPendingRecompile(cx, info);
 75944:         }
 75944:     }
 75944: };
 75944: 
 77361: static void
 95355: CheckNewScriptProperties(JSContext *cx, HandleTypeObject type, JSFunction *fun);
 77361: 
 75944: bool
 77361: TypeSet::isOwnProperty(JSContext *cx, TypeObject *object, bool configurable)
 75944: {
 77361:     /*
 77361:      * Everywhere compiled code depends on definite properties associated with
 77361:      * a type object's newScript, we need to make sure there are constraints
 77361:      * in place which will mark those properties as configured should the
 77361:      * definite properties be invalidated.
 77361:      */
 77361:     if (object->flags & OBJECT_FLAG_NEW_SCRIPT_REGENERATE) {
 77378:         if (object->newScript) {
 99421:             CheckNewScriptProperties(cx, RootedTypeObject(cx, object),
 95355:                                      object->newScript->fun);
 77378:         } else {
 77361:             JS_ASSERT(object->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED);
 77361:             object->flags &= ~OBJECT_FLAG_NEW_SCRIPT_REGENERATE;
 77361:         }
 77361:     }
 77361: 
 77361:     if (isOwnProperty(configurable))
 75944:         return true;
 75944: 
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeOwnProperty>(
 87654:                                                       cx->compartment->types.compiledInfo,
 75944:                                                       configurable), false);
 75944:     return false;
 75944: }
 75944: 
 75625: bool
 75893: TypeSet::knownNonEmpty(JSContext *cx)
 75625: {
 77361:     if (baseFlags() != 0 || baseObjectCount() != 0)
 75625:         return true;
 75677: 
 80557:     addFreeze(cx);
 75625: 
 75625:     return false;
 75615: }
 75615: 
 80557: bool
 80557: TypeSet::knownSubset(JSContext *cx, TypeSet *other)
 80557: {
 80557:     if ((baseFlags() & other->baseFlags()) != baseFlags())
 80557:         return false;
 80557: 
 80557:     if (unknownObject()) {
 80557:         JS_ASSERT(other->unknownObject());
 80557:     } else {
 80557:         for (unsigned i = 0; i < getObjectCount(); i++) {
 80557:             TypeObjectKey *obj = getObject(i);
 80557:             if (!obj)
 80557:                 continue;
 80557:             if (!other->hasType(Type::ObjectType(obj)))
 80557:                 return false;
 80557:         }
 80557:     }
 80557: 
 80557:     addFreeze(cx);
 80557: 
 80557:     return true;
 80557: }
 80557: 
 77347: int
 77347: TypeSet::getTypedArrayType(JSContext *cx)
 77347: {
 77347:     int arrayType = TypedArray::TYPE_MAX;
 77347:     unsigned count = getObjectCount();
 77347: 
 77347:     for (unsigned i = 0; i < count; i++) {
 77353:         JSObject *proto = NULL;
 77353:         if (JSObject *object = getSingleObject(i)) {
 77353:             proto = object->getProto();
 77353:         } else if (TypeObject *object = getTypeObject(i)) {
 77353:             JS_ASSERT(!object->hasAnyFlags(OBJECT_FLAG_NON_TYPED_ARRAY));
 77353:             proto = object->proto;
 77353:         }
 77353:         if (!proto)
 77347:             continue;
 77347: 
 96828:         int objArrayType = proto->getClass() - TypedArray::protoClasses;
 77347:         JS_ASSERT(objArrayType >= 0 && objArrayType < TypedArray::TYPE_MAX);
 77347: 
 77347:         /*
 77347:          * Set arrayType to the type of the first array. Return if there is an array
 77347:          * of another type.
 77347:          */
 77347:         if (arrayType == TypedArray::TYPE_MAX)
 77347:             arrayType = objArrayType;
 77347:         else if (arrayType != objArrayType)
 77347:             return TypedArray::TYPE_MAX;
 77347:     }
 77347: 
 77347:     /*
 77347:      * Assume the caller checked that OBJECT_FLAG_NON_TYPED_ARRAY is not set.
 77347:      * This means the set contains at least one object because sets with no
 77347:      * objects have all object flags.
 77347:      */
 77347:     JS_ASSERT(arrayType != TypedArray::TYPE_MAX);
 77347: 
 77347:     /* Recompile when another typed array is added to this set. */
 77347:     addFreeze(cx);
 77347: 
 77347:     return arrayType;
 77347: }
 77347: 
 75845: JSObject *
 77353: TypeSet::getSingleton(JSContext *cx, bool freeze)
 75845: {
 77361:     if (baseFlags() != 0 || baseObjectCount() != 1)
 75845:         return NULL;
 75845: 
 77353:     JSObject *obj = getSingleObject(0);
 77353:     if (!obj)
 75845:         return NULL;
 75845: 
 77353:     if (freeze) {
 79410:         add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreeze>(
 87654:                                                cx->compartment->types.compiledInfo), false);
 77353:     }
 77353: 
 77353:     return obj;
 75845: }
 75845: 
 77884: static inline bool
 77884: TypeHasGlobal(Type type, JSObject *global)
 77884: {
 77884:     if (type.isUnknown() || type.isAnyObject())
 77884:         return false;
 77884: 
 77884:     if (type.isSingleObject())
 86483:         return &type.singleObject()->global() == global;
 77884: 
 77884:     if (type.isTypeObject())
 77884:         return type.typeObject()->getGlobal() == global;
 77884: 
 77884:     JS_ASSERT(type.isPrimitive());
 77884:     return true;
 77884: }
 77884: 
 77884: class TypeConstraintFreezeGlobal : public TypeConstraint
 77884: {
 77884: public:
 87654:     RecompileInfo info;
 77884:     JSObject *global;
 77884: 
 87654:     TypeConstraintFreezeGlobal(RecompileInfo info, JSObject *global)
 87654:         : TypeConstraint("freezeGlobal"), info(info), global(global)
 77884:     {
 77884:         JS_ASSERT(global);
 77884:     }
 77884: 
 77884:     void newType(JSContext *cx, TypeSet *source, Type type)
 77884:     {
 77884:         if (!global || TypeHasGlobal(type, global))
 77884:             return;
 77884: 
 77884:         global = NULL;
 87654:         cx->compartment->types.addPendingRecompile(cx, info);
 77884:     }
 77884: };
 77884: 
 77884: bool
 77884: TypeSet::hasGlobalObject(JSContext *cx, JSObject *global)
 77884: {
 77884:     if (unknownObject())
 77884:         return false;
 77884: 
 77884:     unsigned count = getObjectCount();
 77884:     for (unsigned i = 0; i < count; i++) {
 77884:         TypeObjectKey *object = getObject(i);
 77884:         if (object && !TypeHasGlobal(Type::ObjectType(object), global))
 77884:             return false;
 77884:     }
 77884: 
 79410:     add(cx, cx->typeLifoAlloc().new_<TypeConstraintFreezeGlobal>(
 87654:               cx->compartment->types.compiledInfo, global), false);
 77884: 
 77884:     return true;
 77884: }
 77884: 
 82129: bool
 82129: TypeSet::needsBarrier(JSContext *cx)
 82129: {
 82129:     bool result = unknownObject()
 82129:                || getObjectCount() > 0
 82129:                || hasAnyFlag(TYPE_FLAG_STRING);
 82129:     if (!result)
 82129:         addFreeze(cx);
 82129:     return result;
 82129: }
 82129: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // TypeCompartment
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75720: void
 75720: TypeCompartment::init(JSContext *cx)
 75720: {
 75720:     PodZero(this);
 75720: 
 87590:     if (cx && cx->getRunOptions() & JSOPTION_TYPE_INFERENCE) {
 87590: #ifdef JS_METHODJIT
 87590:         JSC::MacroAssembler masm;
 87590:         if (masm.supportsFloatingPoint())
 87590: #endif
 75720:             inferenceEnabled = true;
 75720:     }
 87590: }
 75720: 
 75720: TypeObject *
 76094: TypeCompartment::newTypeObject(JSContext *cx, JSScript *script,
 99364:                                JSProtoKey key, JSObject *proto_, bool unknown)
 99364: {
 99421:     RootedObject proto(cx, proto_);
 86437: 
 83313:     TypeObject *object = gc::NewGCThing<TypeObject>(cx, gc::FINALIZE_TYPE_OBJECT, sizeof(TypeObject));
 75720:     if (!object)
 75720:         return NULL;
 77461:     new(object) TypeObject(proto, key == JSProto_Function, unknown);
 75720: 
 75839:     if (!cx->typeInferenceEnabled())
 77361:         object->flags |= OBJECT_FLAG_UNKNOWN_MASK;
 76179:     else
 76179:         object->setFlagsFromKey(cx, key);
 75919: 
 75720:     return object;
 75720: }
 75720: 
 75720: TypeObject *
 77361: TypeCompartment::newAllocationSiteTypeObject(JSContext *cx, const AllocationSiteKey &key)
 75720: {
 77361:     AutoEnterTypeInference enter(cx);
 77361: 
 77361:     if (!allocationSiteTable) {
 77361:         allocationSiteTable = cx->new_<AllocationSiteTable>();
 77361:         if (!allocationSiteTable || !allocationSiteTable->init()) {
 77361:             cx->compartment->types.setPendingNukeTypes(cx);
 77361:             return NULL;
 77361:         }
 77361:     }
 77361: 
 77361:     AllocationSiteTable::AddPtr p = allocationSiteTable->lookupForAdd(key);
 77361:     JS_ASSERT(!p);
 77361: 
 75720:     JSObject *proto;
 77361:     if (!js_GetClassPrototype(cx, key.script->global(), key.kind, &proto, NULL))
 75720:         return NULL;
 75720: 
 77461:     TypeObject *res = newTypeObject(cx, key.script, key.kind, proto);
 77361:     if (!res) {
 77361:         cx->compartment->types.setPendingNukeTypes(cx);
 75720:         return NULL;
 77361:     }
 77361: 
 77361:     jsbytecode *pc = key.script->code + key.offset;
 77361: 
 77446:     if (JSOp(*pc) == JSOP_NEWOBJECT) {
 75948:         /*
 75948:          * This object is always constructed the same way and will not be
 75948:          * observed by other code before all properties have been added. Mark
 75948:          * all the properties as definite properties of the object.
 75948:          */
 89253:         JSObject *baseobj = key.script->getObject(GET_UINT32_INDEX(pc));
 75948: 
 76059:         if (!res->addDefiniteProperties(cx, baseobj))
 75948:             return NULL;
 75948:     }
 75948: 
 77361:     if (!allocationSiteTable->add(p, key, res)) {
 77361:         cx->compartment->types.setPendingNukeTypes(cx);
 77361:         return NULL;
 77361:     }
 77361: 
 75720:     return res;
 75720: }
 75720: 
 75708: static inline jsid
 75708: GetAtomId(JSContext *cx, JSScript *script, const jsbytecode *pc, unsigned offset)
 75708: {
 97828:     PropertyName *name = script->getName(GET_UINT32_INDEX(pc + offset));
 97828:     return MakeTypeId(cx, NameToId(name));
 75708: }
 75708: 
 75788: bool
 75987: types::UseNewType(JSContext *cx, JSScript *script, jsbytecode *pc)
 75788: {
 75788:     JS_ASSERT(cx->typeInferenceEnabled());
 75788: 
 75788:     /*
 75788:      * Make a heuristic guess at a use of JSOP_NEW that the constructed object
 75788:      * should have a fresh type object. We do this when the NEW is immediately
 75788:      * followed by a simple assignment to an object's .prototype field.
 75788:      * This is designed to catch common patterns for subclassing in JS:
 75788:      *
 75788:      * function Super() { ... }
 75788:      * function Sub1() { ... }
 75788:      * function Sub2() { ... }
 75788:      *
 75788:      * Sub1.prototype = new Super();
 75788:      * Sub2.prototype = new Super();
 75788:      *
 75788:      * Using distinct type objects for the particular prototypes of Sub1 and
 75788:      * Sub2 lets us continue to distinguish the two subclasses and any extra
 75788:      * properties added to those prototype objects.
 75788:      */
 75788:     if (JSOp(*pc) != JSOP_NEW)
 75788:         return false;
 75788:     pc += JSOP_NEW_LENGTH;
 75788:     if (JSOp(*pc) == JSOP_SETPROP) {
 75788:         jsid id = GetAtomId(cx, script, pc, 0);
 75788:         if (id == id_prototype(cx))
 75788:             return true;
 75788:     }
 75788: 
 75788:     return false;
 75788: }
 75788: 
 80429: bool
 93664: types::UseNewTypeForInitializer(JSContext *cx, JSScript *script, jsbytecode *pc)
 93664: {
 93664:     /*
 93664:      * Objects created outside loops in global and eval scripts should have
 93664:      * singleton types. For now this is only done for plain objects, not arrays.
 93664:      */
 93664: 
 93664:     if (!cx->typeInferenceEnabled() || script->function())
 93664:         return false;
 93664: 
 93664:     JSOp op = JSOp(*pc);
 93705:     if (op == JSOP_NEWOBJECT || (op == JSOP_NEWINIT && GET_UINT8(pc) == JSProto_Object)) {
 93664:         AutoEnterTypeInference enter(cx);
 93664: 
 93664:         if (!script->ensureRanAnalysis(cx, NULL))
 93664:             return false;
 93664: 
 93664:         return !script->analysis()->getCode(pc).inLoop;
 93664:     }
 93664: 
 93664:     return false;
 93664: }
 93664: 
 93664: bool
 86292: types::ArrayPrototypeHasIndexedProperty(JSContext *cx, JSScript *script)
 86292: {
 86292:     if (!cx->typeInferenceEnabled() || !script->hasGlobal())
 86292:         return true;
 86292: 
 89843:     JSObject *proto = script->global()->getOrCreateArrayPrototype(cx);
 89843:     if (!proto)
 86292:         return true;
 86292: 
 89843:     do {
 86292:         TypeObject *type = proto->getType(cx);
 86292:         if (type->unknownProperties())
 86292:             return true;
 86292:         TypeSet *indexTypes = type->getProperty(cx, JSID_VOID, false);
 86292:         if (!indexTypes || indexTypes->isOwnProperty(cx, type, true) || indexTypes->knownNonEmpty(cx))
 86292:             return true;
 86292:         proto = proto->getProto();
 89843:     } while (proto);
 86292: 
 86292:     return false;
 86292: }
 86292: 
 86292: bool
 75718: TypeCompartment::growPendingArray(JSContext *cx)
 75615: {
 75720:     unsigned newCapacity = js::Max(unsigned(100), pendingCapacity * 2);
 77439:     PendingWork *newArray = (PendingWork *) OffTheBooks::calloc_(newCapacity * sizeof(PendingWork));
 75720:     if (!newArray) {
 75720:         cx->compartment->types.setPendingNukeTypes(cx);
 80429:         return false;
 75720:     }
 75720: 
 87623:     PodCopy(newArray, pendingArray, pendingCount);
 75901:     cx->free_(pendingArray);
 75720: 
 75720:     pendingArray = newArray;
 75720:     pendingCapacity = newCapacity;
 80429: 
 80429:     return true;
 75720: }
 75720: 
 76020: void
 94740: TypeCompartment::processPendingRecompiles(FreeOp *fop)
 75636: {
 75720:     /* Steal the list of scripts to recompile, else we will try to recursively recompile them. */
 87654:     Vector<RecompileInfo> *pending = pendingRecompiles;
 75720:     pendingRecompiles = NULL;
 75720: 
 75864:     JS_ASSERT(!pending->empty());
 75864: 
 75864: #ifdef JS_METHODJIT
 75864: 
 94740:     mjit::ExpandInlineFrames(compartment());
 75864: 
 75720:     for (unsigned i = 0; i < pending->length(); i++) {
 87654:         const RecompileInfo &info = (*pending)[i];
 98147:         mjit::JITScript *jit = info.script->getJIT(info.constructing, info.barriers);
 98147:         if (jit && jit->chunkDescriptor(info.chunkIndex).chunk) {
 98147:             mjit::Recompiler::clearStackReferences(fop, info.script);
 98147:             jit->destroyChunk(fop, info.chunkIndex);
 98147:         }
 76020:     }
 76020: 
 76020: #endif /* JS_METHODJIT */
 76020: 
 94740:     fop->delete_(pending);
 75720: }
 75720: 
 75720: void
 75720: TypeCompartment::setPendingNukeTypes(JSContext *cx)
 75720: {
 75720:     if (!pendingNukeTypes) {
 77439:         if (cx->compartment)
 75720:             js_ReportOutOfMemory(cx);
 75720:         pendingNukeTypes = true;
 75720:     }
 75720: }
 75720: 
 76020: void
 94740: TypeCompartment::setPendingNukeTypesNoReport()
 94740: {
 94740:     JS_ASSERT(compartment()->activeInference);
 94740:     if (!pendingNukeTypes)
 94740:         pendingNukeTypes = true;
 94740: }
 94740: 
 94740: void
 94740: TypeCompartment::nukeTypes(FreeOp *fop)
 94740: {
 75636:     /*
 75720:      * This is the usual response if we encounter an OOM while adding a type
 76092:      * or resolving type constraints. Reset the compartment to not use type
 76092:      * inference, and recompile all scripts.
 75720:      *
 75720:      * Because of the nature of constraint-based analysis (add constraints, and
 75720:      * iterate them until reaching a fixpoint), we can't undo an add of a type set,
 75720:      * and merely aborting the operation which triggered the add will not be
 75720:      * sufficient for correct behavior as we will be leaving the types in an
 75720:      * inconsistent state.
 75636:      */
 75720:     JS_ASSERT(pendingNukeTypes);
 75720:     if (pendingRecompiles) {
 94740:         fop->free_(pendingRecompiles);
 75636:         pendingRecompiles = NULL;
 75636:     }
 75636: 
 76092:     inferenceEnabled = false;
 76092: 
 76092:     /* Update the cached inferenceEnabled bit in all contexts. */
 94740:     for (ContextIter acx(fop->runtime()); !acx.done(); acx.next())
 91250:         acx->setCompartment(acx->compartment);
 76092: 
 76092: #ifdef JS_METHODJIT
 76092: 
 94740:     JSCompartment *compartment = this->compartment();
 77530:     mjit::ExpandInlineFrames(compartment);
 87654:     mjit::ClearAllFrames(compartment);
 76092: 
 76092:     /* Throw away all JIT code in the compartment, but leave everything else alone. */
 77659: 
 94740:     for (gc::CellIter i(compartment, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 77659:         JSScript *script = i.get<JSScript>();
 94740:         mjit::ReleaseScriptCode(fop, script);
 76092:     }
 76092: #endif /* JS_METHODJIT */
 76092: 
 75720: }
 75720: 
 75636: void
 87654: TypeCompartment::addPendingRecompile(JSContext *cx, const RecompileInfo &info)
 75636: {
 76193: #ifdef JS_METHODJIT
 98147:     mjit::JITScript *jit = info.script->getJIT(info.constructing, info.barriers);
 87654:     if (!jit || !jit->chunkDescriptor(info.chunkIndex).chunk) {
 75636:         /* Scripts which haven't been compiled yet don't need to be recompiled. */
 75636:         return;
 75636:     }
 75636: 
 75730:     if (!pendingRecompiles) {
 87654:         pendingRecompiles = cx->new_< Vector<RecompileInfo> >(cx);
 75730:         if (!pendingRecompiles) {
 75730:             cx->compartment->types.setPendingNukeTypes(cx);
 75730:             return;
 75730:         }
 75730:     }
 75636: 
 75636:     for (unsigned i = 0; i < pendingRecompiles->length(); i++) {
 87654:         if (info == (*pendingRecompiles)[i])
 75636:             return;
 75636:     }
 75636: 
 87654:     if (!pendingRecompiles->append(info)) {
 75720:         cx->compartment->types.setPendingNukeTypes(cx);
 75720:         return;
 75720:     }
 76193: #endif
 75720: }
 75720: 
 76136: void
 87654: TypeCompartment::addPendingRecompile(JSContext *cx, JSScript *script, jsbytecode *pc)
 87654: {
 87654: #ifdef JS_METHODJIT
 87654:     RecompileInfo info;
 87654:     info.script = script;
 87654: 
 98147:     for (int constructing = 0; constructing <= 1; constructing++) {
 98147:         for (int barriers = 0; barriers <= 1; barriers++) {
 98147:             if (mjit::JITScript *jit = script->getJIT((bool) constructing, (bool) barriers)) {
 98147:                 info.constructing = constructing;
 98147:                 info.barriers = barriers;
 98147:                 info.chunkIndex = jit->chunkIndex(pc);
 87654:                 addPendingRecompile(cx, info);
 87654:             }
 98147:         }
 87654:     }
 87654: #endif
 87654: }
 87654: 
 87654: void
 84755: TypeCompartment::monitorBytecode(JSContext *cx, JSScript *script, uint32_t offset,
 76175:                                  bool returnOnly)
 76136: {
 77391:     ScriptAnalysis *analysis = script->analysis();
 76175:     JS_ASSERT(analysis->ranInference());
 76136: 
 76136:     jsbytecode *pc = script->code + offset;
 76136: 
 76175:     JS_ASSERT_IF(returnOnly, js_CodeSpec[*pc].format & JOF_INVOKE);
 76175: 
 76175:     Bytecode &code = analysis->getCode(pc);
 76175: 
 76175:     if (returnOnly ? code.monitoredTypesReturn : code.monitoredTypes)
 76175:         return;
 76175: 
 76176:     InferSpew(ISpewOps, "addMonitorNeeded:%s #%u:%05u",
 76176:               returnOnly ? " returnOnly" : "", script->id(), offset);
 76175: 
 76175:     /* Dynamically monitor this call to keep track of its result types. */
 76175:     if (js_CodeSpec[*pc].format & JOF_INVOKE)
 76175:         code.monitoredTypesReturn = true;
 76175: 
 76175:     if (!returnOnly)
 76175:         code.monitoredTypes = true;
 75708: 
 87654:     cx->compartment->types.addPendingRecompile(cx, script, pc);
 76097: 
 76097:     /* Trigger recompilation of any inline callers. */
 83256:     if (script->function() && !script->function()->hasLazyType())
 77391:         ObjectStateChange(cx, script->function()->type(), false, true);
 77353: }
 77353: 
 76097: void
 77353: TypeCompartment::markSetsUnknown(JSContext *cx, TypeObject *target)
 77353: {
 77353:     JS_ASSERT(this == &cx->compartment->types);
 77361:     JS_ASSERT(!(target->flags & OBJECT_FLAG_SETS_MARKED_UNKNOWN));
 77353:     JS_ASSERT(!target->singleton);
 77353:     JS_ASSERT(target->unknownProperties());
 77361:     target->flags |= OBJECT_FLAG_SETS_MARKED_UNKNOWN;
 77353: 
 77353:     AutoEnterTypeInference enter(cx);
 77353: 
 77353:     /*
 77353:      * Mark both persistent and transient type sets which contain obj as having
 77353:      * a generic object type. It is not sufficient to mark just the persistent
 77353:      * sets, as analysis of individual opcodes can pull type objects from
 77353:      * static information (like initializer objects at various offsets).
 77659:      *
 77659:      * We make a list of properties to update and fix them afterwards, as adding
 77659:      * types can't be done while iterating over cells as it can potentially make
 77659:      * new type objects as well or trigger GC.
 77353:      */
 77659:     Vector<TypeSet *> pending(cx);
 91287:     for (gc::CellIter i(cx->compartment, gc::FINALIZE_TYPE_OBJECT); !i.done(); i.next()) {
 77659:         TypeObject *object = i.get<TypeObject>();
 77659: 
 77659:         unsigned count = object->getPropertyCount();
 77659:         for (unsigned i = 0; i < count; i++) {
 77659:             Property *prop = object->getProperty(i);
 77659:             if (prop && prop->types.hasType(Type::ObjectType(target))) {
 77659:                 if (!pending.append(&prop->types))
 77659:                     cx->compartment->types.setPendingNukeTypes(cx);
 77659:             }
 77659:         }
 77659:     }
 77659: 
 77659:     for (unsigned i = 0; i < pending.length(); i++)
 77659:         pending[i]->addType(cx, Type::AnyObjectType());
 77659: 
 91287:     for (gc::CellIter i(cx->compartment, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 77659:         JSScript *script = i.get<JSScript>();
 77391:         if (script->types) {
 77391:             unsigned count = TypeScript::NumTypeSets(script);
 77391:             TypeSet *typeArray = script->types->typeArray();
 77353:             for (unsigned i = 0; i < count; i++) {
 77391:                 if (typeArray[i].hasType(Type::ObjectType(target)))
 77391:                     typeArray[i].addType(cx, Type::AnyObjectType());
 77391:             }
 77391:         }
 77391:         if (script->hasAnalysis() && script->analysis()->ranInference()) {
 77353:             for (unsigned i = 0; i < script->length; i++) {
 77391:                 if (!script->analysis()->maybeCode(i))
 77353:                     continue;
 77353:                 jsbytecode *pc = script->code + i;
 77357:                 if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77357:                     continue;
 77353:                 unsigned defCount = GetDefCount(script, i);
 77353:                 if (ExtendedDef(pc))
 77353:                     defCount++;
 77353:                 for (unsigned j = 0; j < defCount; j++) {
 77391:                     TypeSet *types = script->analysis()->pushedTypes(pc, j);
 77353:                     if (types->hasType(Type::ObjectType(target)))
 77353:                         types->addType(cx, Type::AnyObjectType());
 77353:                 }
 77353:             }
 77353:         }
 77353:     }
 77353: }
 77353: 
 77353: void
 77353: ScriptAnalysis::addTypeBarrier(JSContext *cx, const jsbytecode *pc, TypeSet *target, Type type)
 76097: {
 76097:     Bytecode &code = getCode(pc);
 76097: 
 77353:     if (!type.isUnknown() && !type.isAnyObject() &&
 77353:         type.isObject() && target->getObjectCount() >= BARRIER_OBJECT_LIMIT) {
 76097:         /* Ignore this barrier, just add the type to the target. */
 76097:         target->addType(cx, type);
 76097:         return;
 76097:     }
 76097: 
 76097:     if (!code.typeBarriers) {
 76097:         /*
 76097:          * Adding type barriers at a bytecode which did not have them before
 76097:          * will trigger recompilation. If there were already type barriers,
 76097:          * however, do not trigger recompilation (the script will be recompiled
 76097:          * if any of the barriers is ever violated).
 76097:          */
 87654:         cx->compartment->types.addPendingRecompile(cx, script, const_cast<jsbytecode*>(pc));
 76097: 
 76097:         /* Trigger recompilation of any inline callers. */
 83256:         if (script->function() && !script->function()->hasLazyType())
 77391:             ObjectStateChange(cx, script->function()->type(), false, true);
 76097:     }
 76097: 
 76176:     /* Ignore duplicate barriers. */
 76176:     TypeBarrier *barrier = code.typeBarriers;
 76176:     while (barrier) {
 77467:         if (barrier->target == target && barrier->type == type && !barrier->singleton)
 76176:             return;
 76176:         barrier = barrier->next;
 76176:     }
 76176: 
 76182:     InferSpew(ISpewOps, "typeBarrier: #%u:%05u: %sT%p%s %s",
 76182:               script->id(), pc - script->code,
 76182:               InferSpewColor(target), target, InferSpewColorReset(),
 76182:               TypeString(type));
 76097: 
 79410:     barrier = cx->typeLifoAlloc().new_<TypeBarrier>(target, type, (JSObject *) NULL, JSID_VOID);
 77460: 
 91138:     if (!barrier) {
 91138:         cx->compartment->types.setPendingNukeTypes(cx);
 91138:         return;
 91138:     }
 91138: 
 77460:     barrier->next = code.typeBarriers;
 77460:     code.typeBarriers = barrier;
 77460: }
 77460: 
 77460: void
 77460: ScriptAnalysis::addSingletonTypeBarrier(JSContext *cx, const jsbytecode *pc, TypeSet *target, JSObject *singleton, jsid singletonId)
 77460: {
 77460:     JS_ASSERT(singletonId == MakeTypeId(cx, singletonId) && !JSID_IS_VOID(singletonId));
 77460: 
 77460:     Bytecode &code = getCode(pc);
 77460: 
 77460:     if (!code.typeBarriers) {
 77460:         /* Trigger recompilation as for normal type barriers. */
 87654:         cx->compartment->types.addPendingRecompile(cx, script, const_cast<jsbytecode*>(pc));
 83256:         if (script->function() && !script->function()->hasLazyType())
 77460:             ObjectStateChange(cx, script->function()->type(), false, true);
 77460:     }
 77460: 
 77460:     InferSpew(ISpewOps, "singletonTypeBarrier: #%u:%05u: %sT%p%s %p %s",
 77460:               script->id(), pc - script->code,
 77460:               InferSpewColor(target), target, InferSpewColorReset(),
 77460:               (void *) singleton, TypeIdString(singletonId));
 77460: 
 79410:     TypeBarrier *barrier = cx->typeLifoAlloc().new_<TypeBarrier>(target, Type::UndefinedType(),
 77460:                               singleton, singletonId);
 76097: 
 91138:     if (!barrier) {
 91138:         cx->compartment->types.setPendingNukeTypes(cx);
 91138:         return;
 91138:     }
 91138: 
 76097:     barrier->next = code.typeBarriers;
 76097:     code.typeBarriers = barrier;
 75633: }
 75633: 
 77893: void
 77893: TypeCompartment::print(JSContext *cx, bool force)
 77893: {
 77893:     JSCompartment *compartment = this->compartment();
 80167:     AutoEnterAnalysis enter(compartment);
 77893: 
 77893:     if (!force && !InferSpewActive(ISpewResult))
 77893:         return;
 77893: 
 91287:     for (gc::CellIter i(compartment, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 77893:         JSScript *script = i.get<JSScript>();
 77659:         if (script->hasAnalysis() && script->analysis()->ranInference())
 77659:             script->analysis()->printTypes(cx);
 77659:     }
 77659: 
 77362: #ifdef DEBUG
 91287:     for (gc::CellIter i(compartment, gc::FINALIZE_TYPE_OBJECT); !i.done(); i.next()) {
 77893:         TypeObject *object = i.get<TypeObject>();
 77361:         object->print(cx);
 77361:     }
 77362: #endif
 77361: 
 75638:     printf("Counts: ");
 75615:     for (unsigned count = 0; count < TYPE_COUNT_LIMIT; count++) {
 75615:         if (count)
 75638:             printf("/");
 75638:         printf("%u", typeCounts[count]);
 75615:     }
 75638:     printf(" (%u over)\n", typeCountOver);
 75638: 
 75640:     printf("Recompilations: %u\n", recompilations);
 75615: }
 75615: 
 75615: /////////////////////////////////////////////////////////////////////
 75770: // TypeCompartment tables
 75770: /////////////////////////////////////////////////////////////////////
 75770: 
 75770: /*
 75770:  * The arrayTypeTable and objectTypeTable are per-compartment tables for making
 75770:  * common type objects to model the contents of large script singletons and
 75770:  * JSON objects. These are vanilla Arrays and native Objects, so we distinguish
 75770:  * the types of different ones by looking at the types of their properties.
 75770:  *
 75770:  * All singleton/JSON arrays which have the same prototype, are homogenous and
 75926:  * of the same element type will share a type object. All singleton/JSON
 75926:  * objects which have the same shape and property types will also share a type
 75926:  * object. We don't try to collate arrays or objects that have type mismatches.
 75770:  */
 75770: 
 75770: static inline bool
 77353: NumberTypes(Type a, Type b)
 77353: {
 77353:     return (a.isPrimitive(JSVAL_TYPE_INT32) || a.isPrimitive(JSVAL_TYPE_DOUBLE))
 77353:         && (b.isPrimitive(JSVAL_TYPE_INT32) || b.isPrimitive(JSVAL_TYPE_DOUBLE));
 75770: }
 75770: 
 77448: /*
 77448:  * As for GetValueType, but requires object types to be non-singletons with
 77448:  * their default prototype. These are the only values that should appear in
 77448:  * arrays and objects whose type can be fixed.
 77448:  */
 77448: static inline Type
 77448: GetValueTypeForTable(JSContext *cx, const Value &v)
 77448: {
 77448:     Type type = GetValueType(cx, v);
 77448:     JS_ASSERT(!type.isSingleObject());
 77448:     return type;
 77448: }
 77448: 
 75987: struct types::ArrayTableKey
 75770: {
 77353:     Type type;
 75770:     JSObject *proto;
 75770: 
 77353:     ArrayTableKey()
 77353:         : type(Type::UndefinedType()), proto(NULL)
 77353:     {}
 77353: 
 75770:     typedef ArrayTableKey Lookup;
 75770: 
 84755:     static inline uint32_t hash(const ArrayTableKey &v) {
 91527:         return (uint32_t) (v.type.raw() ^ ((uint32_t)(size_t)v.proto >> 2));
 75770:     }
 75770: 
 75770:     static inline bool match(const ArrayTableKey &v1, const ArrayTableKey &v2) {
 75770:         return v1.type == v2.type && v1.proto == v2.proto;
 75770:     }
 75770: };
 75770: 
 76020: void
 75770: TypeCompartment::fixArrayType(JSContext *cx, JSObject *obj)
 75770: {
 76020:     AutoEnterTypeInference enter(cx);
 76020: 
 75770:     if (!arrayTypeTable) {
 75901:         arrayTypeTable = cx->new_<ArrayTypeTable>();
 75770:         if (!arrayTypeTable || !arrayTypeTable->init()) {
 75770:             arrayTypeTable = NULL;
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 75770:         }
 75770:     }
 75770: 
 75770:     /*
 75770:      * If the array is of homogenous type, pick a type object which will be
 75770:      * shared with all other singleton/JSON arrays of the same type.
 75770:      * If the array is heterogenous, keep the existing type object, which has
 75770:      * unknown properties.
 75770:      */
 83231:     JS_ASSERT(obj->isDenseArray());
 75770: 
 75770:     unsigned len = obj->getDenseArrayInitializedLength();
 75770:     if (len == 0)
 76020:         return;
 75770: 
 77448:     Type type = GetValueTypeForTable(cx, obj->getDenseArrayElement(0));
 75770: 
 75770:     for (unsigned i = 1; i < len; i++) {
 77448:         Type ntype = GetValueTypeForTable(cx, obj->getDenseArrayElement(i));
 75770:         if (ntype != type) {
 75770:             if (NumberTypes(type, ntype))
 77353:                 type = Type::DoubleType();
 75770:             else
 76020:                 return;
 75770:         }
 75770:     }
 75770: 
 75770:     ArrayTableKey key;
 75770:     key.type = type;
 75770:     key.proto = obj->getProto();
 75770:     ArrayTypeTable::AddPtr p = arrayTypeTable->lookupForAdd(key);
 75770: 
 75770:     if (p) {
 75770:         obj->setType(p->value);
 75770:     } else {
 77461:         /* Make a new type to use for future arrays with the same elements. */
 77461:         TypeObject *objType = newTypeObject(cx, NULL, JSProto_Array, obj->getProto());
 75770:         if (!objType) {
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 75770:         }
 75770:         obj->setType(objType);
 75770: 
 77353:         if (!objType->unknownProperties())
 77353:             objType->addPropertyType(cx, JSID_VOID, type);
 75770: 
 75770:         if (!arrayTypeTable->relookupOrAdd(p, key, objType)) {
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 76020:         }
 76020:     }
 75770: }
 75770: 
 75770: /*
 75770:  * N.B. We could also use the initial shape of the object (before its type is
 75770:  * fixed) as the key in the object table, but since all references in the table
 75770:  * are weak the hash entries would usually be collected on GC even if objects
 75770:  * with the new type/shape are still live.
 75770:  */
 75987: struct types::ObjectTableKey
 75770: {
 75770:     jsid *ids;
 84755:     uint32_t nslots;
 84755:     uint32_t nfixed;
 75770:     JSObject *proto;
 75770: 
 75770:     typedef JSObject * Lookup;
 75770: 
 84755:     static inline uint32_t hash(JSObject *obj) {
 91527:         return (uint32_t) (JSID_BITS(obj->lastProperty()->propid().get()) ^
 91527:                          obj->slotSpan() ^ obj->numFixedSlots() ^
 91527:                          ((uint32_t)(size_t)obj->getProto() >> 2));
 75770:     }
 75770: 
 75770:     static inline bool match(const ObjectTableKey &v, JSObject *obj) {
 75948:         if (obj->slotSpan() != v.nslots ||
 75948:             obj->numFixedSlots() != v.nfixed ||
 75948:             obj->getProto() != v.proto) {
 75770:             return false;
 75948:         }
 75770:         const Shape *shape = obj->lastProperty();
 83221:         while (!shape->isEmptyShape()) {
 83221:             if (shape->propid() != v.ids[shape->slot()])
 75770:                 return false;
 75770:             shape = shape->previous();
 75770:         }
 75770:         return true;
 75770:     }
 75770: };
 75770: 
 75987: struct types::ObjectTableEntry
 75770: {
 86321:     ReadBarriered<TypeObject> object;
 77353:     Type *types;
 75770: };
 75770: 
 76020: void
 75770: TypeCompartment::fixObjectType(JSContext *cx, JSObject *obj)
 75770: {
 76020:     AutoEnterTypeInference enter(cx);
 76020: 
 75770:     if (!objectTypeTable) {
 75901:         objectTypeTable = cx->new_<ObjectTypeTable>();
 75770:         if (!objectTypeTable || !objectTypeTable->init()) {
 75770:             objectTypeTable = NULL;
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 75770:         }
 75770:     }
 75770: 
 75770:     /*
 75770:      * Use the same type object for all singleton/JSON arrays with the same
 75770:      * base shape, i.e. the same fields written in the same order. If there
 75770:      * is a type mismatch with previous objects of the same shape, use the
 75770:      * generic unknown type.
 75770:      */
 75770:     JS_ASSERT(obj->isObject());
 75770: 
 75770:     if (obj->slotSpan() == 0 || obj->inDictionaryMode())
 76020:         return;
 75770: 
 75770:     ObjectTypeTable::AddPtr p = objectTypeTable->lookupForAdd(obj);
 75770:     const Shape *baseShape = obj->lastProperty();
 75770: 
 75770:     if (p) {
 75770:         /* The lookup ensures the shape matches, now check that the types match. */
 77353:         Type *types = p->value.types;
 75770:         for (unsigned i = 0; i < obj->slotSpan(); i++) {
 77448:             Type ntype = GetValueTypeForTable(cx, obj->getSlot(i));
 75770:             if (ntype != types[i]) {
 75770:                 if (NumberTypes(ntype, types[i])) {
 77353:                     if (types[i].isPrimitive(JSVAL_TYPE_INT32)) {
 77353:                         types[i] = Type::DoubleType();
 75770:                         const Shape *shape = baseShape;
 83221:                         while (!shape->isEmptyShape()) {
 83221:                             if (shape->slot() == i) {
 77353:                                 Type type = Type::DoubleType();
 77375:                                 if (!p->value.object->unknownProperties()) {
 83221:                                     jsid id = MakeTypeId(cx, shape->propid());
 77375:                                     p->value.object->addPropertyType(cx, id, type);
 77375:                                 }
 75770:                                 break;
 75770:                             }
 75770:                             shape = shape->previous();
 75770:                         }
 75770:                     }
 75770:                 } else {
 76020:                     return;
 75770:                 }
 75770:             }
 75770:         }
 75770: 
 77392:         obj->setType(p->value.object);
 75770:     } else {
 77392:         /* Make a new type to use for the object and similar future ones. */
 77461:         TypeObject *objType = newTypeObject(cx, NULL, JSProto_Object, obj->getProto());
 77392:         if (!objType || !objType->addDefiniteProperties(cx, obj)) {
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 75770:         }
 75770: 
 75901:         jsid *ids = (jsid *) cx->calloc_(obj->slotSpan() * sizeof(jsid));
 76020:         if (!ids) {
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 76020:         }
 75770: 
 77353:         Type *types = (Type *) cx->calloc_(obj->slotSpan() * sizeof(Type));
 76020:         if (!types) {
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 76020:         }
 75770: 
 75770:         const Shape *shape = baseShape;
 83221:         while (!shape->isEmptyShape()) {
 83221:             ids[shape->slot()] = shape->propid();
 83221:             types[shape->slot()] = GetValueTypeForTable(cx, obj->getSlot(shape->slot()));
 77375:             if (!objType->unknownProperties()) {
 83221:                 jsid id = MakeTypeId(cx, shape->propid());
 83221:                 objType->addPropertyType(cx, id, types[shape->slot()]);
 77375:             }
 75770:             shape = shape->previous();
 75770:         }
 75770: 
 75770:         ObjectTableKey key;
 75770:         key.ids = ids;
 75770:         key.nslots = obj->slotSpan();
 75948:         key.nfixed = obj->numFixedSlots();
 75770:         key.proto = obj->getProto();
 75770:         JS_ASSERT(ObjectTableKey::match(key, obj));
 75770: 
 75770:         ObjectTableEntry entry;
 75770:         entry.object = objType;
 75770:         entry.types = types;
 75770: 
 75770:         p = objectTypeTable->lookupForAdd(obj);
 75770:         if (!objectTypeTable->add(p, key, entry)) {
 76020:             cx->compartment->types.setPendingNukeTypes(cx);
 76020:             return;
 75770:         }
 75770: 
 77392:         obj->setType(objType);
 75770:     }
 75770: }
 75770: 
 75770: /////////////////////////////////////////////////////////////////////
 75641: // TypeObject
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75641: void
 77361: TypeObject::getFromPrototypes(JSContext *cx, jsid id, TypeSet *types, bool force)
 75641: {
 77361:     if (!force && types->hasPropagatedProperty())
 77361:         return;
 77361: 
 77361:     types->setPropagatedProperty();
 77361: 
 77361:     if (!proto)
 77361:         return;
 77361: 
 77361:     if (proto->getType(cx)->unknownProperties()) {
 77361:         types->addType(cx, Type::UnknownType());
 77361:         return;
 77361:     }
 77361: 
 95085:     TypeSet *protoTypes = proto->getType(cx)->getProperty(cx, id, false);
 77361:     if (!protoTypes)
 77361:         return;
 77361: 
 77361:     protoTypes->addSubset(cx, types);
 77361: 
 95085:     proto->getType(cx)->getFromPrototypes(cx, id, protoTypes);
 77361: }
 77361: 
 77361: static inline void
 77460: UpdatePropertyType(JSContext *cx, TypeSet *types, JSObject *obj, const Shape *shape, bool force)
 75705: {
 84118:     types->setOwnProperty(cx, false);
 84118:     if (!shape->writable())
 84118:         types->setOwnProperty(cx, true);
 84118: 
 77361:     if (shape->hasGetterValue() || shape->hasSetterValue()) {
 84118:         types->setOwnProperty(cx, true);
 77361:         types->addType(cx, Type::UnknownType());
 94227:     } else if (shape->hasDefaultGetter() && shape->hasSlot()) {
 83221:         const Value &value = obj->nativeGetSlot(shape->slot());
 77460: 
 77460:         /*
 77460:          * Don't add initial undefined types for singleton properties that are
 77460:          * not collated into the JSID_VOID property (see propertySet comment).
 77460:          */
 84118:         if (force || !value.isUndefined()) {
 77460:             Type type = GetValueType(cx, value);
 77361:             types->addType(cx, type);
 75705:         }
 75705:     }
 84118: }
 75705: 
 75720: bool
 75720: TypeObject::addProperty(JSContext *cx, jsid id, Property **pprop)
 75720: {
 75720:     JS_ASSERT(!*pprop);
 79410:     Property *base = cx->typeLifoAlloc().new_<Property>(id);
 75720:     if (!base) {
 75720:         cx->compartment->types.setPendingNukeTypes(cx);
 75720:         return false;
 75720:     }
 75718: 
 77361:     if (singleton) {
 77361:         /*
 77361:          * Fill the property in with any type the object already has in an
 77361:          * own property. We are only interested in plain native properties
 77361:          * which don't go through a barrier when read by the VM or jitcode.
 77361:          * We don't need to handle arrays or other JIT'ed non-natives as
 77361:          * these are not (yet) singletons.
 77361:          */
 77361: 
 77361:         if (JSID_IS_VOID(id)) {
 77361:             /* Go through all shapes on the object to get integer-valued properties. */
 77361:             const Shape *shape = singleton->lastProperty();
 83221:             while (!shape->isEmptyShape()) {
 83221:                 if (JSID_IS_VOID(MakeTypeId(cx, shape->propid())))
 77460:                     UpdatePropertyType(cx, &base->types, singleton, shape, true);
 77361:                 shape = shape->previous();
 77361:             }
 83221:         } else if (!JSID_IS_EMPTY(id)) {
 78194:             const Shape *shape = singleton->nativeLookup(cx, id);
 77361:             if (shape)
 77460:                 UpdatePropertyType(cx, &base->types, singleton, shape, false);
 77361:         }
 79911: 
 79911:         if (singleton->watched()) {
 79911:             /*
 79911:              * Mark the property as configured, to inhibit optimizations on it
 79911:              * and avoid bypassing the watchpoint handler.
 79911:              */
 79911:             base->types.setOwnProperty(cx, true);
 79911:         }
 77361:     }
 77361: 
 75720:     *pprop = base;
 75720: 
 76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s property %s %s",
 76182:               InferSpewColor(&base->types), &base->types, InferSpewColorReset(),
 77461:               TypeObjectString(this), TypeIdString(id));
 75641: 
 75720:     return true;
 75720: }
 75720: 
 75948: bool
 76059: TypeObject::addDefiniteProperties(JSContext *cx, JSObject *obj)
 75948: {
 75948:     if (unknownProperties())
 75948:         return true;
 75948: 
 77361:     /* Mark all properties of obj as definite properties of this type. */
 75948:     AutoEnterTypeInference enter(cx);
 75948: 
 75948:     const Shape *shape = obj->lastProperty();
 83221:     while (!shape->isEmptyShape()) {
 83221:         jsid id = MakeTypeId(cx, shape->propid());
 83221:         if (!JSID_IS_VOID(id) && obj->isFixedSlot(shape->slot()) &&
 83221:             shape->slot() <= (TYPE_FLAG_DEFINITE_MASK >> TYPE_FLAG_DEFINITE_SHIFT)) {
 75948:             TypeSet *types = getProperty(cx, id, true);
 75948:             if (!types)
 75948:                 return false;
 83221:             types->setDefinite(shape->slot());
 75948:         }
 75948:         shape = shape->previous();
 75948:     }
 75948: 
 75987:     return true;
 75948: }
 75948: 
 77361: bool
 77361: TypeObject::matchDefiniteProperties(JSObject *obj)
 77361: {
 77361:     unsigned count = getPropertyCount();
 77361:     for (unsigned i = 0; i < count; i++) {
 77361:         Property *prop = getProperty(i);
 77361:         if (!prop)
 77361:             continue;
 77361:         if (prop->types.isDefiniteProperty()) {
 77361:             unsigned slot = prop->types.definiteSlot();
 77361: 
 77361:             bool found = false;
 77361:             const Shape *shape = obj->lastProperty();
 83221:             while (!shape->isEmptyShape()) {
 83221:                 if (shape->slot() == slot && shape->propid() == prop->id) {
 77361:                     found = true;
 77361:                     break;
 77361:                 }
 77361:                 shape = shape->previous();
 77361:             }
 77361:             if (!found)
 77361:                 return false;
 77361:         }
 77361:     }
 77361: 
 77361:     return true;
 77361: }
 77361: 
 76148: inline void
 77353: InlineAddTypeProperty(JSContext *cx, TypeObject *obj, jsid id, Type type)
 76148: {
 77361:     JS_ASSERT(id == MakeTypeId(cx, id));
 76148: 
 76148:     AutoEnterTypeInference enter(cx);
 76148: 
 76148:     TypeSet *types = obj->getProperty(cx, id, true);
 76148:     if (!types || types->hasType(type))
 76148:         return;
 76148: 
 76148:     InferSpew(ISpewOps, "externalType: property %s %s: %s",
 77461:               TypeObjectString(obj), TypeIdString(id), TypeString(type));
 76148:     types->addType(cx, type);
 76148: }
 76148: 
 76148: void
 77353: TypeObject::addPropertyType(JSContext *cx, jsid id, Type type)
 76148: {
 76148:     InlineAddTypeProperty(cx, this, id, type);
 76148: }
 76148: 
 76148: void
 76148: TypeObject::addPropertyType(JSContext *cx, jsid id, const Value &value)
 76148: {
 76148:     InlineAddTypeProperty(cx, this, id, GetValueType(cx, value));
 76148: }
 76148: 
 76148: void
 77353: TypeObject::addPropertyType(JSContext *cx, const char *name, Type type)
 76148: {
 76148:     jsid id = JSID_VOID;
 76148:     if (name) {
 76148:         JSAtom *atom = js_Atomize(cx, name, strlen(name));
 76148:         if (!atom) {
 76148:             AutoEnterTypeInference enter(cx);
 76148:             cx->compartment->types.setPendingNukeTypes(cx);
 76148:             return;
 76148:         }
 97828:         id = AtomToId(atom);
 76148:     }
 76148:     InlineAddTypeProperty(cx, this, id, type);
 76148: }
 76148: 
 76148: void
 76148: TypeObject::addPropertyType(JSContext *cx, const char *name, const Value &value)
 76148: {
 76148:     addPropertyType(cx, name, GetValueType(cx, value));
 76148: }
 76148: 
 76148: void
 76148: TypeObject::markPropertyConfigured(JSContext *cx, jsid id)
 76148: {
 76148:     AutoEnterTypeInference enter(cx);
 76148: 
 76148:     id = MakeTypeId(cx, id);
 76148: 
 76148:     TypeSet *types = getProperty(cx, id, true);
 76148:     if (types)
 76148:         types->setOwnProperty(cx, true);
 76148: }
 76148: 
 76148: void
 77414: TypeObject::markStateChange(JSContext *cx)
 76148: {
 77444:     if (unknownProperties())
 77444:         return;
 77444: 
 76148:     AutoEnterTypeInference enter(cx);
 77361:     TypeSet *types = maybeGetProperty(cx, JSID_EMPTY);
 76148:     if (types) {
 76148:         TypeConstraint *constraint = types->constraintList;
 76148:         while (constraint) {
 76148:             constraint->newObjectState(cx, this, true);
 76148:             constraint = constraint->next;
 76148:         }
 76148:     }
 76148: }
 76148: 
 75720: void
 75919: TypeObject::setFlags(JSContext *cx, TypeObjectFlags flags)
 75720: {
 77353:     if ((this->flags & flags) == flags)
 77353:         return;
 77353: 
 76148:     AutoEnterTypeInference enter(cx);
 76148: 
 77398:     if (singleton) {
 77398:         /* Make sure flags are consistent with persistent object state. */
 77884:         JS_ASSERT_IF(flags & OBJECT_FLAG_UNINLINEABLE,
 77884:                      interpretedFunction->script()->uninlineable);
 77884:         JS_ASSERT_IF(flags & OBJECT_FLAG_REENTRANT_FUNCTION,
 77884:                      interpretedFunction->script()->reentrantOuterFunction);
 77884:         JS_ASSERT_IF(flags & OBJECT_FLAG_ITERATED,
 83248:                      singleton->lastProperty()->hasObjectFlag(BaseShape::ITERATED_SINGLETON));
 77398:     }
 76128: 
 75919:     this->flags |= flags;
 75919: 
 80023:     InferSpew(ISpewOps, "%s: setFlags 0x%x", TypeObjectString(this), flags);
 75864: 
 76097:     ObjectStateChange(cx, this, false, false);
 75864: }
 75864: 
 75864: void
 75641: TypeObject::markUnknown(JSContext *cx)
 75640: {
 76148:     AutoEnterTypeInference enter(cx);
 76148: 
 75987:     JS_ASSERT(cx->compartment->activeInference);
 75919:     JS_ASSERT(!unknownProperties());
 75760: 
 77414:     if (!(flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED))
 77414:         clearNewScript(cx);
 77414: 
 77461:     InferSpew(ISpewOps, "UnknownProperties: %s", TypeObjectString(this));
 75833: 
 76097:     ObjectStateChange(cx, this, true, true);
 75641: 
 75640:     /*
 75641:      * Existing constraints may have already been added to this object, which we need
 75640:      * to do the right thing for. We can't ensure that we will mark all unknown
 75640:      * objects before they have been accessed, as the __proto__ of a known object
 75640:      * could be dynamically set to an unknown object, and we can decide to ignore
 75640:      * properties of an object during analysis (i.e. hashmaps). Adding unknown for
 75640:      * any properties accessed already accounts for possible values read from them.
 75640:      */
 75640: 
 75919:     unsigned count = getPropertyCount();
 75919:     for (unsigned i = 0; i < count; i++) {
 75919:         Property *prop = getProperty(i);
 75944:         if (prop) {
 77353:             prop->types.addType(cx, Type::UnknownType());
 75944:             prop->types.setOwnProperty(cx, true);
 75944:         }
 75641:     }
 75641: }
 75641: 
 75615: void
 75948: TypeObject::clearNewScript(JSContext *cx)
 75948: {
 77361:     JS_ASSERT(!(flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED));
 77361:     flags |= OBJECT_FLAG_NEW_SCRIPT_CLEARED;
 76103: 
 76103:     /*
 76103:      * It is possible for the object to not have a new script yet but to have
 76103:      * one added in the future. When analyzing properties of new scripts we mix
 76103:      * in adding constraints to trigger clearNewScript with changes to the
 76103:      * type sets themselves (from breakTypeBarriers). It is possible that we
 76103:      * could trigger one of these constraints before AnalyzeNewScriptProperties
 76103:      * has finished, in which case we want to make sure that call fails.
 76103:      */
 76103:     if (!newScript)
 76103:         return;
 75948: 
 75948:     AutoEnterTypeInference enter(cx);
 75948: 
 75948:     /*
 75948:      * Any definite properties we added due to analysis of the new script when
 75948:      * the type object was created are now invalid: objects with the same type
 75948:      * can be created by using 'new' on a different script or through some
 75948:      * other mechanism (e.g. Object.create). Rather than clear out the definite
 75948:      * bits on the object's properties, just mark such properties as having
 75948:      * been deleted/reconfigured, which will have the same effect on JITs
 75948:      * wanting to use the definite bits to optimize property accesses.
 75948:      */
 75948:     for (unsigned i = 0; i < getPropertyCount(); i++) {
 75948:         Property *prop = getProperty(i);
 75948:         if (!prop)
 75948:             continue;
 75948:         if (prop->types.isDefiniteProperty())
 75948:             prop->types.setOwnProperty(cx, true);
 75948:     }
 76059: 
 76059:     /*
 76059:      * If we cleared the new script while in the middle of initializing an
 76059:      * object, it will still have the new script's shape and reflect the no
 76059:      * longer correct state of the object once its initialization is completed.
 76059:      * We can't really detect the possibility of this statically, but the new
 76059:      * script keeps track of where each property is initialized so we can walk
 76059:      * the stack and fix up any such objects.
 76059:      */
 97160:     Vector<uint32_t, 32> pcOffsets(cx);
 97161:     for (ScriptFrameIter iter(cx); !iter.done(); ++iter) {
 97160:         pcOffsets.append(uint32_t(iter.pc() - iter.script()->code));
 97160:         if (iter.isConstructing() &&
 97160:             iter.callee() == newScript->fun &&
 97160:             iter.thisv().isObject() &&
 97160:             !iter.thisv().toObject().hasLazyType() &&
 97160:             iter.thisv().toObject().type() == this)
 97160:         {
 97160:             JSObject *obj = &iter.thisv().toObject();
 76059: 
 76109:             /* Whether all identified 'new' properties have been initialized. */
 76109:             bool finished = false;
 76109: 
 76109:             /* If not finished, number of properties that have been added. */
 84755:             uint32_t numProperties = 0;
 76059: 
 76059:             /*
 76059:              * If non-zero, we are scanning initializers in a call which has
 76059:              * already finished.
 76059:              */
 76059:             size_t depth = 0;
 97160:             size_t callDepth = pcOffsets.length() - 1;
 97160:             uint32_t offset = pcOffsets[callDepth];
 76059: 
 76059:             for (TypeNewScript::Initializer *init = newScript->initializerList;; init++) {
 76059:                 if (init->kind == TypeNewScript::Initializer::SETPROP) {
 76059:                     if (!depth && init->offset > offset) {
 76059:                         /* Advanced past all properties which have been initialized. */
 76059:                         break;
 76059:                     }
 76059:                     numProperties++;
 76059:                 } else if (init->kind == TypeNewScript::Initializer::FRAME_PUSH) {
 76059:                     if (depth) {
 76059:                         depth++;
 76059:                     } else if (init->offset > offset) {
 76059:                         /* Advanced past all properties which have been initialized. */
 76059:                         break;
 76059:                     } else if (init->offset == offset) {
 97160:                         if (!callDepth)
 76059:                             break;
 97160:                         offset = pcOffsets[--callDepth];
 76059:                     } else {
 76059:                         /* This call has already finished. */
 76059:                         depth = 1;
 76059:                     }
 76059:                 } else if (init->kind == TypeNewScript::Initializer::FRAME_POP) {
 76059:                     if (depth) {
 76059:                         depth--;
 76059:                     } else {
 76059:                         /* This call has not finished yet. */
 76059:                         break;
 76059:                     }
 76059:                 } else {
 76087:                     JS_ASSERT(init->kind == TypeNewScript::Initializer::DONE);
 76109:                     finished = true;
 76059:                     break;
 76059:                 }
 76059:             }
 76059: 
 76109:             if (!finished)
 76153:                 obj->rollbackProperties(cx, numProperties);
 76059:         }
 76059:     }
 76059: 
 82129:     /* We NULL out newScript *before* freeing it so the write barrier works. */
 82129:     TypeNewScript *savedNewScript = newScript;
 76059:     newScript = NULL;
 82129:     cx->free_(savedNewScript);
 77414: 
 77414:     markStateChange(cx);
 75948: }
 75948: 
 75948: void
 75638: TypeObject::print(JSContext *cx)
 75615: {
 77461:     printf("%s : %s",
 77461:            TypeObjectString(this),
 77461:            proto ? TypeString(Type::ObjectType(proto)) : "(null)");
 75679: 
 75919:     if (unknownProperties()) {
 75679:         printf(" unknown");
 75919:     } else {
 76044:         if (!hasAnyFlags(OBJECT_FLAG_NON_PACKED_ARRAY))
 75826:             printf(" packed");
 76044:         if (!hasAnyFlags(OBJECT_FLAG_NON_DENSE_ARRAY))
 75826:             printf(" dense");
 76179:         if (!hasAnyFlags(OBJECT_FLAG_NON_TYPED_ARRAY))
 76179:             printf(" typed");
 76044:         if (hasAnyFlags(OBJECT_FLAG_UNINLINEABLE))
 75919:             printf(" uninlineable");
 76044:         if (hasAnyFlags(OBJECT_FLAG_SPECIAL_EQUALITY))
 75919:             printf(" specialEquality");
 76044:         if (hasAnyFlags(OBJECT_FLAG_ITERATED))
 76044:             printf(" iterated");
 75919:     }
 75641: 
 77361:     unsigned count = getPropertyCount();
 77361: 
 77361:     if (count == 0) {
 75641:         printf(" {}\n");
 75641:         return;
 75641:     }
 75641: 
 75641:     printf(" {");
 75641: 
 75919:     for (unsigned i = 0; i < count; i++) {
 75919:         Property *prop = getProperty(i);
 75641:         if (prop) {
 75641:             printf("\n    %s:", TypeIdString(prop->id));
 75944:             prop->types.print(cx);
 75641:         }
 75641:     }
 75641: 
 75641:     printf("\n}\n");
 75615: }
 75615: 
 75615: /////////////////////////////////////////////////////////////////////
 75987: // Type Analysis
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75615: /*
 75615:  * If the bytecode immediately following code/pc is a test of the value
 75708:  * pushed by code, that value should be marked as possibly void.
 75615:  */
 75708: static inline bool
 75708: CheckNextTest(jsbytecode *pc)
 75615: {
 76059:     jsbytecode *next = pc + GetBytecodeLength(pc);
 75615:     switch ((JSOp)*next) {
 75615:       case JSOP_IFEQ:
 75615:       case JSOP_IFNE:
 75615:       case JSOP_NOT:
 75703:       case JSOP_OR:
 75703:       case JSOP_AND:
 75615:       case JSOP_TYPEOF:
 75615:       case JSOP_TYPEOFEXPR:
 75708:         return true;
 75615:       default:
 76095:         /* TRAP ok here */
 75708:         return false;
 75615:     }
 75615: }
 75615: 
 75987: static inline TypeObject *
 75987: GetInitializerType(JSContext *cx, JSScript *script, jsbytecode *pc)
 75987: {
 76158:     if (!script->hasGlobal())
 75987:         return NULL;
 75987: 
 93664:     if (UseNewTypeForInitializer(cx, script, pc))
 93664:         return NULL;
 93664: 
 75987:     JSOp op = JSOp(*pc);
 75987:     JS_ASSERT(op == JSOP_NEWARRAY || op == JSOP_NEWOBJECT || op == JSOP_NEWINIT);
 75987: 
 87974:     bool isArray = (op == JSOP_NEWARRAY || (op == JSOP_NEWINIT && GET_UINT8(pc) == JSProto_Array));
 77391:     return TypeScript::InitObject(cx, script, pc, isArray ? JSProto_Array : JSProto_Object);
 75987: }
 75987: 
 77884: /*
 77884:  * Detach nesting state for script from its parent, removing it entirely if it
 77884:  * has no children of its own. This happens when walking type information while
 77884:  * initially resolving NAME accesses, thus will not invalidate any compiler
 77884:  * dependencies.
 77884:  */
 77884: static void
 77884: DetachNestingParent(JSScript *script)
 77884: {
 77884:     TypeScriptNesting *nesting = script->nesting();
 77884: 
 77884:     if (!nesting || !nesting->parent)
 77884:         return;
 77884: 
 77884:     /* Remove from parent's list of children. */
 77884:     JSScript **pscript = &nesting->parent->nesting()->children;
 77884:     while ((*pscript)->nesting() != nesting)
 77884:         pscript = &(*pscript)->nesting()->next;
 77884:     *pscript = nesting->next;
 77884: 
 77884:     nesting->parent = NULL;
 77884: 
 77884:     /* If this nesting can have no children of its own, destroy it. */
 77884:     if (!script->isOuterFunction)
 77884:         script->clearNesting();
 77884: }
 77884: 
 77884: ScriptAnalysis::NameAccess
 77884: ScriptAnalysis::resolveNameAccess(JSContext *cx, jsid id, bool addDependency)
 77884: {
 77884:     JS_ASSERT(cx->typeInferenceEnabled());
 77884: 
 77884:     NameAccess access;
 77884:     PodZero(&access);
 77884: 
 77884:     if (!JSID_IS_ATOM(id))
 77884:         return access;
 77884:     JSAtom *atom = JSID_TO_ATOM(id);
 77884: 
 77898:     JSScript *script = this->script;
 83256:     while (script->function() && script->nesting()) {
 77884:         if (!script->ensureRanInference(cx))
 77884:             return access;
 77884: 
 77884:         /*
 77884:          * Don't resolve names in scripts which use 'let' or 'with'. New names
 77884:          * bound here can mask variables of the script itself.
 77884:          *
 77884:          * Also, don't resolve names in scripts which are generators. Frame
 77884:          * balancing works differently for generators and we do not maintain
 77884:          * active frame counts for such scripts.
 77884:          */
 95100:         if (script->analysis()->addsScopeObjects() || script->isGenerator)
 77884:             return access;
 77884: 
 77884:         /* Check if the script definitely binds the identifier. */
 91237:         unsigned index;
 77884:         BindingKind kind = script->bindings.lookup(cx, atom, &index);
 77884:         if (kind == ARGUMENT || kind == VARIABLE) {
 77884:             TypeObject *obj = script->function()->getType(cx);
 77884: 
 77884:             if (addDependency) {
 77884:                 /*
 77884:                  * Record the dependency which compiled code has on the outer
 77884:                  * function being non-reentrant.
 77884:                  */
 77884:                 if (TypeSet::HasObjectFlags(cx, obj, OBJECT_FLAG_REENTRANT_FUNCTION))
 77884:                     return access;
 77884:             }
 77884: 
 90737:             if (!script->isOuterFunction)
 90737:                 return access;
 90737: 
 77884:             access.script = script;
 77884:             access.nesting = script->nesting();
 77884:             access.slot = (kind == ARGUMENT) ? ArgSlot(index) : LocalSlot(script, index);
 77884:             access.arg = (kind == ARGUMENT);
 77884:             access.index = index;
 77884:             return access;
 77884:         } else if (kind != NONE) {
 77884:             return access;
 77884:         }
 77884: 
 78455:         /*
 78455:          * The script's bindings do not contain a name for the function itself,
 78455:          * don't resolve name accesses on lambdas in DeclEnv objects on the
 78455:          * scope chain.
 78455:          */
 78455:         if (atom == CallObjectLambdaName(script->function()))
 78455:             return access;
 78455: 
 77884:         if (!script->nesting()->parent)
 77884:             return access;
 77884:         script = script->nesting()->parent;
 77884:     }
 77884: 
 77884:     return access;
 77884: }
 77884: 
 75708: /* Analyze type information for a single bytecode. */
 75987: bool
 76059: ScriptAnalysis::analyzeTypesBytecode(JSContext *cx, unsigned offset,
 75987:                                      TypeInferenceState &state)
 75615: {
 75615:     jsbytecode *pc = script->code + offset;
 75615:     JSOp op = (JSOp)*pc;
 75615: 
 75987:     Bytecode &code = getCode(offset);
 75987:     JS_ASSERT(!code.pushedTypes);
 75987: 
 75708:     InferSpew(ISpewOps, "analyze: #%u:%05u", script->id(), offset);
 75708: 
 76059:     unsigned defCount = GetDefCount(script, offset);
 76059:     if (ExtendedDef(pc))
 75987:         defCount++;
 75987: 
 79410:     TypeSet *pushed = cx->typeLifoAlloc().newArrayUninitialized<TypeSet>(defCount);
 75720:     if (!pushed)
 75720:         return false;
 75708:     PodZero(pushed, defCount);
 75987:     code.pushedTypes = pushed;
 75987: 
 75987:     /*
 75987:      * Add phi nodes introduced at this point to the list of all phi nodes in
 75987:      * the script. Types for these are not generated until after the script has
 75987:      * been processed, as types can flow backwards into phi nodes and the
 75987:      * source sets may not exist if we try to process these eagerly.
 75987:      */
 75987:     if (code.newValues) {
 75987:         SlotValue *newv = code.newValues;
 75987:         while (newv->slot) {
 75987:             if (newv->value.kind() != SSAValue::PHI || newv->value.phiOffset() != offset) {
 75987:                 newv++;
 75987:                 continue;
 75987:             }
 75987: 
 75987:             /*
 75987:              * The phi nodes at join points should all be unique, and every phi
 75987:              * node created should be in the phiValues list on some bytecode.
 75987:              */
 75987:             if (!state.phiNodes.append(newv->value.phiNode()))
 75987:                 return false;
 75987:             TypeSet &types = newv->value.phiNode()->types;
 76182:             InferSpew(ISpewOps, "typeSet: %sT%p%s phi #%u:%05u:%u",
 76182:                       InferSpewColor(&types), &types, InferSpewColorReset(),
 75987:                       script->id(), offset, newv->slot);
 75987:             newv++;
 75987:         }
 75987:     }
 75708: 
 77360:     /*
 77360:      * Treat decomposed ops as no-ops, we will analyze the decomposed version
 77360:      * instead. (We do, however, need to look at introduced phi nodes).
 77360:      */
 77360:     if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77360:         return true;
 77360: 
 75789:     for (unsigned i = 0; i < defCount; i++) {
 76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s pushed%u #%u:%05u",
 76182:                   InferSpewColor(&pushed[i]), &pushed[i], InferSpewColorReset(),
 76182:                   i, script->id(), offset);
 75789:     }
 75720: 
 75615:     /* Add type constraints for the various opcodes. */
 75615:     switch (op) {
 75615: 
 75615:         /* Nop bytecodes. */
 75636:       case JSOP_POP:
 75615:       case JSOP_NOP:
 83115:       case JSOP_LOOPHEAD:
 87961:       case JSOP_LOOPENTRY:
 75615:       case JSOP_GOTO:
 75615:       case JSOP_IFEQ:
 75615:       case JSOP_IFNE:
 75615:       case JSOP_LINENO:
 75615:       case JSOP_DEFCONST:
 75615:       case JSOP_LEAVEWITH:
 75615:       case JSOP_LEAVEBLOCK:
 75615:       case JSOP_RETRVAL:
 75615:       case JSOP_ENDITER:
 75615:       case JSOP_THROWING:
 75615:       case JSOP_GOSUB:
 75615:       case JSOP_RETSUB:
 75615:       case JSOP_CONDSWITCH:
 75615:       case JSOP_DEFAULT:
 75615:       case JSOP_POPN:
 75615:       case JSOP_STARTXML:
 75615:       case JSOP_STARTXMLEXPR:
 75615:       case JSOP_DEFXMLNS:
 75615:       case JSOP_POPV:
 75636:       case JSOP_DEBUGGER:
 75699:       case JSOP_SETCALL:
 75987:       case JSOP_TABLESWITCH:
 75987:       case JSOP_LOOKUPSWITCH:
 75987:       case JSOP_TRY:
 82079:       case JSOP_LABEL:
 75615:         break;
 75615: 
 75615:         /* Bytecodes pushing values of known type. */
 75615:       case JSOP_VOID:
 84493:       case JSOP_UNDEFINED:
 77353:         pushed[0].addType(cx, Type::UndefinedType());
 75615:         break;
 75615:       case JSOP_ZERO:
 75615:       case JSOP_ONE:
 75615:       case JSOP_INT8:
 75615:       case JSOP_INT32:
 75615:       case JSOP_UINT16:
 75615:       case JSOP_UINT24:
 75615:       case JSOP_BITAND:
 75615:       case JSOP_BITOR:
 75615:       case JSOP_BITXOR:
 75615:       case JSOP_BITNOT:
 75615:       case JSOP_RSH:
 75615:       case JSOP_LSH:
 75630:       case JSOP_URSH:
 99552:       case JSOP_ACTUALSFILLED:
 77353:         pushed[0].addType(cx, Type::Int32Type());
 75615:         break;
 75615:       case JSOP_FALSE:
 75615:       case JSOP_TRUE:
 75615:       case JSOP_EQ:
 75615:       case JSOP_NE:
 75615:       case JSOP_LT:
 75615:       case JSOP_LE:
 75615:       case JSOP_GT:
 75615:       case JSOP_GE:
 75615:       case JSOP_NOT:
 75615:       case JSOP_STRICTEQ:
 75615:       case JSOP_STRICTNE:
 75615:       case JSOP_IN:
 75615:       case JSOP_INSTANCEOF:
 75615:       case JSOP_DELDESC:
 77353:         pushed[0].addType(cx, Type::BooleanType());
 75615:         break;
 75615:       case JSOP_DOUBLE:
 77353:         pushed[0].addType(cx, Type::DoubleType());
 75615:         break;
 75615:       case JSOP_STRING:
 75615:       case JSOP_TYPEOF:
 75615:       case JSOP_TYPEOFEXPR:
 75615:       case JSOP_QNAMEPART:
 75615:       case JSOP_XMLTAGEXPR:
 75615:       case JSOP_TOATTRVAL:
 75615:       case JSOP_ADDATTRNAME:
 75615:       case JSOP_ADDATTRVAL:
 75615:       case JSOP_XMLELTEXPR:
 77353:         pushed[0].addType(cx, Type::StringType());
 75615:         break;
 75615:       case JSOP_NULL:
 77353:         pushed[0].addType(cx, Type::NullType());
 75615:         break;
 75720: 
 75615:       case JSOP_REGEXP:
 76158:         if (script->hasGlobal()) {
 77391:             TypeObject *object = TypeScript::StandardType(cx, script, JSProto_RegExp);
 75720:             if (!object)
 75720:                 return false;
 77353:             pushed[0].addType(cx, Type::ObjectType(object));
 75720:         } else {
 77353:             pushed[0].addType(cx, Type::UnknownType());
 75720:         }
 75615:         break;
 75615: 
 75716:       case JSOP_OBJECT: {
 89253:         JSObject *obj = script->getObject(GET_UINT32_INDEX(pc));
 77353:         pushed[0].addType(cx, Type::ObjectType(obj));
 75716:         break;
 75716:       }
 75716: 
 75615:       case JSOP_STOP:
 75615:         /* If a stop is reachable then the return type may be void. */
 83256:           if (script->function())
 77391:             TypeScript::ReturnTypes(script)->addType(cx, Type::UndefinedType());
 75615:         break;
 75615: 
 75615:       case JSOP_OR:
 75615:       case JSOP_AND:
 75615:         /* OR/AND push whichever operand determined the result. */
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615: 
 75640:       case JSOP_DUP:
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[1]);
 75615:         break;
 75615: 
 75615:       case JSOP_DUP2:
 77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[0]);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[1]);
 77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[2]);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[3]);
 75615:         break;
 75615: 
 77340:       case JSOP_SWAP:
 77340:       case JSOP_PICK: {
 87974:         unsigned pickedDepth = (op == JSOP_SWAP ? 1 : GET_UINT8(pc));
 77340:         /* The last popped value is the last pushed. */
 77353:         poppedTypes(pc, pickedDepth)->addSubset(cx, &pushed[pickedDepth]);
 77340:         for (unsigned i = 0; i < pickedDepth; i++)
 77353:             poppedTypes(pc, i)->addSubset(cx, &pushed[pickedDepth - 1 - i]);
 77340:         break;
 77340:       }
 77340: 
 75615:       case JSOP_GETGNAME:
 75718:       case JSOP_CALLGNAME: {
 78646:         jsid id = GetAtomId(cx, script, pc, 0);
 75636: 
 77884:         TypeSet *seen = bytecodeTypes(pc);
 77353:         seen->addSubset(cx, &pushed[0]);
 76087: 
 75888:         /*
 75888:          * Normally we rely on lazy standard class initialization to fill in
 75888:          * the types of global properties the script can access. In a few cases
 75888:          * the method JIT will bypass this, and we need to add the types direclty.
 75888:          */
 97828:         if (id == NameToId(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]))
 77353:             seen->addType(cx, Type::UndefinedType());
 97828:         if (id == NameToId(cx->runtime->atomState.NaNAtom))
 77353:             seen->addType(cx, Type::DoubleType());
 97828:         if (id == NameToId(cx->runtime->atomState.InfinityAtom))
 77353:             seen->addType(cx, Type::DoubleType());
 76061: 
 75636:         /* Handle as a property access. */
 77361:         PropertyAccess(cx, script, pc, script->global()->getType(cx), false, seen, id);
 75718: 
 86855:         if (op == JSOP_CALLGNAME)
 77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UnknownType());
 75716: 
 75708:         if (CheckNextTest(pc))
 77353:             pushed[0].addType(cx, Type::UndefinedType());
 75615:         break;
 75615:       }
 75615: 
 75987:       case JSOP_NAME:
 76061:       case JSOP_CALLNAME: {
 77884:         TypeSet *seen = bytecodeTypes(pc);
 77884:         seen->addSubset(cx, &pushed[0]);
 77884: 
 76061:         /*
 77885:          * Try to resolve this name by walking the function's scope nesting.
 77885:          * If we succeed but the accessed script has had its TypeScript purged
 77885:          * in the past, we still must use a type barrier: the name access can
 77885:          * be on a call object which predated the purge, and whose types might
 77885:          * not be reflected in the reconstructed information.
 76061:          */
 77884:         jsid id = GetAtomId(cx, script, pc, 0);
 77884:         NameAccess access = resolveNameAccess(cx, id);
 77885:         if (access.script && !access.script->typesPurged) {
 77884:             TypeSet *types = TypeScript::SlotTypes(access.script, access.slot);
 77884:             types->addSubsetBarrier(cx, script, pc, seen);
 77884:         } else {
 77353:             addTypeBarrier(cx, pc, seen, Type::UnknownType());
 77884:         }
 77884: 
 86855:         if (op == JSOP_CALLNAME)
 77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UnknownType());
 75987:         break;
 76061:       }
 75987: 
 75987:       case JSOP_BINDGNAME:
 75987:       case JSOP_BINDNAME:
 75987:         break;
 75987: 
 75987:       case JSOP_SETGNAME: {
 75987:         jsid id = GetAtomId(cx, script, pc, 0);
 77361:         PropertyAccess(cx, script, pc, script->global()->getType(cx),
 75987:                        true, poppedTypes(pc, 0), id);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75987:         break;
 75987:       }
 75987: 
 77884:       case JSOP_SETNAME: {
 77884:         jsid id = GetAtomId(cx, script, pc, 0);
 77884:         NameAccess access = resolveNameAccess(cx, id);
 77884:         if (access.script) {
 77884:             TypeSet *types = TypeScript::SlotTypes(access.script, access.slot);
 77884:             poppedTypes(pc, 0)->addSubset(cx, types);
 77884:         } else {
 77884:             cx->compartment->types.monitorBytecode(cx, script, offset);
 77884:         }
 77884:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 77884:         break;
 77884:       }
 77884: 
 75987:       case JSOP_SETCONST:
 75987:         cx->compartment->types.monitorBytecode(cx, script, offset);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75987:         break;
 75987: 
 93245:       case JSOP_GETXPROP: {
 77439:         TypeSet *seen = bytecodeTypes(pc);
 77353:         addTypeBarrier(cx, pc, seen, Type::UnknownType());
 77353:         seen->addSubset(cx, &pushed[0]);
 75615:         break;
 75615:       }
 75615: 
 95101:       case JSOP_GETALIASEDVAR:
 95101:       case JSOP_CALLALIASEDVAR:
 75615:       case JSOP_GETARG:
 75987:       case JSOP_CALLARG:
 75987:       case JSOP_GETLOCAL:
 75987:       case JSOP_CALLLOCAL: {
 84755:         uint32_t slot = GetBytecodeSlot(script, pc);
 75987:         if (trackSlot(slot)) {
 75987:             /*
 75987:              * Normally these opcodes don't pop anything, but they are given
 75987:              * an extended use holding the variable's SSA value before the
 75987:              * access. Use the types from here.
 75987:              */
 77353:             poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75987:         } else if (slot < TotalSlots(script)) {
 77391:             TypeSet *types = TypeScript::SlotTypes(script, slot);
 77353:             types->addSubset(cx, &pushed[0]);
 75987:         } else {
 75987:             /* Local 'let' variable. Punt on types for these, for now. */
 77353:             pushed[0].addType(cx, Type::UnknownType());
 75987:         }
 95101:         if (op == JSOP_CALLARG || op == JSOP_CALLLOCAL || op == JSOP_CALLALIASEDVAR)
 77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UndefinedType());
 75987:         break;
 75987:       }
 75987: 
 95101:       case JSOP_SETALIASEDVAR:
 75615:       case JSOP_SETARG:
 94278:       case JSOP_SETLOCAL: {
 84755:         uint32_t slot = GetBytecodeSlot(script, pc);
 75987:         if (!trackSlot(slot) && slot < TotalSlots(script)) {
 77391:             TypeSet *types = TypeScript::SlotTypes(script, slot);
 77353:             poppedTypes(pc, 0)->addSubset(cx, types);
 75987:         }
 75987: 
 75987:         /*
 75987:          * For assignments to non-escaping locals/args, we don't need to update
 75987:          * the possible types of the var, as for each read of the var SSA gives
 75987:          * us the writes that could have produced that read.
 75987:          */
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615:       }
 75615: 
 75615:       case JSOP_INCARG:
 75615:       case JSOP_DECARG:
 75615:       case JSOP_ARGINC:
 75987:       case JSOP_ARGDEC:
 75615:       case JSOP_INCLOCAL:
 75615:       case JSOP_DECLOCAL:
 75615:       case JSOP_LOCALINC:
 75615:       case JSOP_LOCALDEC: {
 84755:         uint32_t slot = GetBytecodeSlot(script, pc);
 75987:         if (trackSlot(slot)) {
 93651:             poppedTypes(pc, 0)->addArith(cx, script, pc, &pushed[0]);
 75987:         } else if (slot < TotalSlots(script)) {
 77391:             TypeSet *types = TypeScript::SlotTypes(script, slot);
 93651:             types->addArith(cx, script, pc, types);
 77353:             types->addSubset(cx, &pushed[0]);
 75708:         } else {
 77353:             pushed[0].addType(cx, Type::UnknownType());
 75708:         }
 75615:         break;
 75615:       }
 75615: 
 93250:       case JSOP_ARGUMENTS:
 76128:         /* Compute a precise type only when we know the arguments won't escape. */
 93250:         if (script->needsArgsObj())
 77353:             pushed[0].addType(cx, Type::UnknownType());
 93250:         else
 95100:             pushed[0].addType(cx, Type::MagicArgType());
 76128:         break;
 75708: 
 99225:       case JSOP_REST: {
 99225:         TypeSet *types = script->analysis()->bytecodeTypes(pc);
 99225:         types->addSubset(cx, &pushed[0]);
 99225:         if (script->hasGlobal()) {
 99225:             TypeObject *rest = TypeScript::InitObject(cx, script, pc, JSProto_Array);
 99225:             if (!rest)
 99225:                 return false;
 99225:             types->addType(cx, Type::ObjectType(rest));
 99225:         } else {
 99225:             types->addType(cx, Type::UnknownType());
 99225:         }
 99225:         break;
 99225:       }
 99225: 
 99225: 
 94227:       case JSOP_SETPROP: {
 75708:         jsid id = GetAtomId(cx, script, pc, 0);
 75987:         poppedTypes(pc, 1)->addSetProperty(cx, script, pc, poppedTypes(pc, 0), id);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615:       }
 75615: 
 75987:       case JSOP_LENGTH:
 75615:       case JSOP_GETPROP:
 76061:       case JSOP_CALLPROP: {
 76061:         jsid id = GetAtomId(cx, script, pc, 0);
 77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
 76103: 
 76061:         poppedTypes(pc, 0)->addGetProperty(cx, script, pc, seen, id);
 76136:         if (op == JSOP_CALLPROP)
 76136:             poppedTypes(pc, 0)->addCallProperty(cx, script, pc, id);
 76103: 
 77353:         seen->addSubset(cx, &pushed[0]);
 76061:         if (CheckNextTest(pc))
 77353:             pushed[0].addType(cx, Type::UndefinedType());
 76061:         break;
 76061:       }
 76061: 
 76061:       /*
 76061:        * We only consider ELEM accesses on integers below. Any element access
 76061:        * which is accessing a non-integer property must be monitored.
 76061:        */
 76061: 
 76061:       case JSOP_GETELEM:
 76061:       case JSOP_CALLELEM: {
 77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
 76103: 
 76061:         poppedTypes(pc, 1)->addGetProperty(cx, script, pc, seen, JSID_VOID);
 76103: 
 77353:         seen->addSubset(cx, &pushed[0]);
 86855:         if (op == JSOP_CALLELEM)
 86855:             pushed[0].addPropagateThis(cx, script, pc, Type::UndefinedType(), poppedTypes(pc, 1));
 75987:         if (CheckNextTest(pc))
 77353:             pushed[0].addType(cx, Type::UndefinedType());
 75615:         break;
 75615:       }
 75615: 
 75615:       case JSOP_SETELEM:
 77399:         poppedTypes(pc, 1)->addSetElement(cx, script, pc, poppedTypes(pc, 2), poppedTypes(pc, 0));
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615: 
 77357:       case JSOP_TOID:
 77357:         /*
 77357:          * This is only used for element inc/dec ops; any id produced which
 77357:          * is not an integer must be monitored.
 77357:          */
 77357:         pushed[0].addType(cx, Type::Int32Type());
 77357:         break;
 77357: 
 75615:       case JSOP_THIS:
 77391:         TypeScript::ThisTypes(script)->addTransformThis(cx, script, &pushed[0]);
 75615:         break;
 75615: 
 75615:       case JSOP_RETURN:
 75615:       case JSOP_SETRVAL:
 83256:           if (script->function())
 77391:             poppedTypes(pc, 0)->addSubset(cx, TypeScript::ReturnTypes(script));
 75615:         break;
 75615: 
 75615:       case JSOP_ADD:
 93651:         poppedTypes(pc, 0)->addArith(cx, script, pc, &pushed[0], poppedTypes(pc, 1));
 93651:         poppedTypes(pc, 1)->addArith(cx, script, pc, &pushed[0], poppedTypes(pc, 0));
 75615:         break;
 75615: 
 75615:       case JSOP_SUB:
 75615:       case JSOP_MUL:
 75615:       case JSOP_MOD:
 75630:       case JSOP_DIV:
 93651:         poppedTypes(pc, 0)->addArith(cx, script, pc, &pushed[0]);
 93651:         poppedTypes(pc, 1)->addArith(cx, script, pc, &pushed[0]);
 75615:         break;
 75615: 
 75615:       case JSOP_NEG:
 75615:       case JSOP_POS:
 93651:         poppedTypes(pc, 0)->addArith(cx, script, pc, &pushed[0]);
 75615:         break;
 75615: 
 75615:       case JSOP_LAMBDA:
 94152:       case JSOP_DEFFUN: {
 94152:         JSObject *obj = script->getObject(GET_UINT32_INDEX(pc));
 75615: 
 75615:         TypeSet *res = NULL;
 94152:         if (op == JSOP_LAMBDA)
 75708:             res = &pushed[0];
 75615: 
 75688:         if (res) {
 76158:             if (script->hasGlobal())
 77353:                 res->addType(cx, Type::ObjectType(obj));
 75615:             else
 77353:                 res->addType(cx, Type::UnknownType());
 75688:         } else {
 75708:             cx->compartment->types.monitorBytecode(cx, script, offset);
 75688:         }
 75615:         break;
 75615:       }
 75615: 
 75718:       case JSOP_DEFVAR:
 75718:         break;
 75718: 
 75615:       case JSOP_CALL:
 75615:       case JSOP_EVAL:
 75631:       case JSOP_FUNCALL:
 75631:       case JSOP_FUNAPPLY:
 75615:       case JSOP_NEW: {
 77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
 77353:         seen->addSubset(cx, &pushed[0]);
 76175: 
 75615:         /* Construct the base call information about this site. */
 76059:         unsigned argCount = GetUseCount(script, offset) - 2;
 79410:         TypeCallsite *callsite = cx->typeLifoAlloc().new_<TypeCallsite>(
 75720:                                                         cx, script, pc, op == JSOP_NEW, argCount);
 75720:         if (!callsite || (argCount && !callsite->argumentTypes)) {
 75720:             cx->compartment->types.setPendingNukeTypes(cx);
 75720:             break;
 75720:         }
 75987:         callsite->thisTypes = poppedTypes(pc, argCount);
 76175:         callsite->returnTypes = seen;
 75708: 
 75708:         for (unsigned i = 0; i < argCount; i++)
 75987:             callsite->argumentTypes[i] = poppedTypes(pc, argCount - 1 - i);
 75987: 
 76118:         /*
 76118:          * Mark FUNCALL and FUNAPPLY sites as monitored. The method JIT may
 76118:          * lower these into normal calls, and we need to make sure the
 76118:          * callee's argument types are checked on entry.
 76118:          */
 76118:         if (op == JSOP_FUNCALL || op == JSOP_FUNAPPLY)
 76118:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
 76118: 
 75987:         poppedTypes(pc, argCount + 1)->addCall(cx, callsite);
 75615:         break;
 75615:       }
 75615: 
 75639:       case JSOP_NEWINIT:
 75639:       case JSOP_NEWARRAY:
 75987:       case JSOP_NEWOBJECT: {
 93664:         TypeSet *types = script->analysis()->bytecodeTypes(pc);
 93664:         types->addSubset(cx, &pushed[0]);
 93664: 
 93664:         if (UseNewTypeForInitializer(cx, script, pc)) {
 93664:             /* Defer types pushed by this bytecode until runtime. */
 93664:             break;
 93664:         }
 93664: 
 75987:         TypeObject *initializer = GetInitializerType(cx, script, pc);
 76158:         if (script->hasGlobal()) {
 75720:             if (!initializer)
 75720:                 return false;
 86704:             types->addType(cx, Type::ObjectType(initializer));
 75688:         } else {
 75987:             JS_ASSERT(!initializer);
 86704:             types->addType(cx, Type::UnknownType());
 86704:         }
 75615:         break;
 75987:       }
 75615: 
 75627:       case JSOP_ENDINIT:
 75627:         break;
 75627: 
 75987:       case JSOP_INITELEM: {
 75987:         const SSAValue &objv = poppedValue(pc, 2);
 75987:         jsbytecode *initpc = script->code + objv.pushedOffset();
 75987:         TypeObject *initializer = GetInitializerType(cx, script, initpc);
 75987: 
 75762:         if (initializer) {
 77353:             pushed[0].addType(cx, Type::ObjectType(initializer));
 75919:             if (!initializer->unknownProperties()) {
 75759:                 /*
 75759:                  * Assume the initialized element is an integer. INITELEM can be used
 75759:                  * for doubles which don't map to the JSID_VOID property, which must
 75759:                  * be caught with dynamic monitoring.
 75759:                  */
 75759:                 TypeSet *types = initializer->getProperty(cx, JSID_VOID, true);
 75720:                 if (!types)
 75720:                     return false;
 77353:                 if (state.hasGetSet) {
 77353:                     types->addType(cx, Type::UnknownType());
 77353:                 } else if (state.hasHole) {
 77353:                     if (!initializer->unknownProperties())
 77353:                         initializer->setFlags(cx, OBJECT_FLAG_NON_PACKED_ARRAY);
 75688:                 } else {
 77353:                     poppedTypes(pc, 0)->addSubset(cx, types);
 77353:                 }
 77353:             }
 77353:         } else {
 77353:             pushed[0].addType(cx, Type::UnknownType());
 75688:         }
 75627:         state.hasGetSet = false;
 75639:         state.hasHole = false;
 75615:         break;
 75987:       }
 75615: 
 75627:       case JSOP_GETTER:
 75627:       case JSOP_SETTER:
 75627:         state.hasGetSet = true;
 75627:         break;
 75627: 
 75639:       case JSOP_HOLE:
 75639:         state.hasHole = true;
 75639:         break;
 75639: 
 94227:       case JSOP_INITPROP: {
 75987:         const SSAValue &objv = poppedValue(pc, 1);
 75987:         jsbytecode *initpc = script->code + objv.pushedOffset();
 75987:         TypeObject *initializer = GetInitializerType(cx, script, initpc);
 75987: 
 75762:         if (initializer) {
 77353:             pushed[0].addType(cx, Type::ObjectType(initializer));
 75919:             if (!initializer->unknownProperties()) {
 75708:                 jsid id = GetAtomId(cx, script, pc, 0);
 75708:                 TypeSet *types = initializer->getProperty(cx, id, true);
 75720:                 if (!types)
 75720:                     return false;
 75760:                 if (id == id___proto__(cx) || id == id_prototype(cx))
 75708:                     cx->compartment->types.monitorBytecode(cx, script, offset);
 75760:                 else if (state.hasGetSet)
 77353:                     types->addType(cx, Type::UnknownType());
 75760:                 else
 77353:                     poppedTypes(pc, 0)->addSubset(cx, types);
 75762:             }
 75688:         } else {
 77353:             pushed[0].addType(cx, Type::UnknownType());
 75688:         }
 75627:         state.hasGetSet = false;
 75639:         JS_ASSERT(!state.hasHole);
 75615:         break;
 75987:       }
 75615: 
 75615:       case JSOP_ENTERWITH:
 75708:       case JSOP_ENTERBLOCK:
 86078:       case JSOP_ENTERLET0:
 75615:         /*
 75708:          * Scope lookups can occur on the values being pushed here. We don't track
 75708:          * the value or its properties, and just monitor all name opcodes in the
 75718:          * script.
 75615:          */
 75615:         break;
 75615: 
 86078:       case JSOP_ENTERLET1:
 86078:         /*
 86078:          * JSOP_ENTERLET1 enters a let block with an unrelated value on top of
 86078:          * the stack (such as the condition to a switch) whose constraints must
 86078:          * be propagated. The other values are ignored for the same reason as
 86078:          * JSOP_ENTERLET0.
 86078:          */
 86078:         poppedTypes(pc, 0)->addSubset(cx, &pushed[defCount - 1]);
 86078:         break;
 86078: 
 77363:       case JSOP_ITER: {
 75627:         /*
 77363:          * Use a per-script type set to unify the possible target types of all
 77363:          * 'for in' or 'for each' loops in the script. We need to mark the
 77363:          * value pushed by the ITERNEXT appropriately, but don't track the SSA
 77363:          * information to connect that ITERNEXT with the appropriate ITER.
 77363:          * This loses some precision when a script mixes 'for in' and
 77363:          * 'for each' loops together, oh well.
 75627:          */
 77363:         if (!state.forTypes) {
 77363:           state.forTypes = TypeSet::make(cx, "forTypes");
 77363:           if (!state.forTypes)
 77363:               return false;
 77363:         }
 77363: 
 87974:         if (GET_UINT8(pc) & JSITER_FOREACH)
 77363:             state.forTypes->addType(cx, Type::UnknownType());
 77399:         else
 77399:             state.forTypes->addType(cx, Type::StringType());
 77363:         break;
 77363:       }
 77363: 
 77363:       case JSOP_ITERNEXT:
 77399:         state.forTypes->addSubset(cx, &pushed[0]);
 75615:         break;
 75615: 
 75615:       case JSOP_MOREITER:
 77353:         pushed[1].addType(cx, Type::BooleanType());
 75615:         break;
 75615: 
 75615:       case JSOP_ENUMELEM:
 75753:       case JSOP_ENUMCONSTELEM:
 75987:       case JSOP_ARRAYPUSH:
 75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
 75615:         break;
 75615: 
 75615:       case JSOP_THROW:
 75615:         /* There will be a monitor on the bytecode catching the exception. */
 75615:         break;
 75615: 
 75615:       case JSOP_FINALLY:
 75615:         /* Pushes information about whether an exception was thrown. */
 75615:         break;
 75615: 
 86855:       case JSOP_IMPLICITTHIS:
 75615:       case JSOP_EXCEPTION:
 77353:         pushed[0].addType(cx, Type::UnknownType());
 75615:         break;
 75615: 
 75615:       case JSOP_DELPROP:
 75615:       case JSOP_DELELEM:
 75615:       case JSOP_DELNAME:
 77353:         pushed[0].addType(cx, Type::BooleanType());
 75615:         break;
 75615: 
 75615:       case JSOP_LEAVEBLOCKEXPR:
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615: 
 86078:       case JSOP_LEAVEFORLETIN:
 86078:         break;
 86078: 
 75615:       case JSOP_CASE:
 77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615: 
 75615:       case JSOP_GENERATOR:
 83256:           if (script->function()) {
 76158:             if (script->hasGlobal()) {
 78098:                 JSObject *proto = script->global()->getOrCreateGeneratorPrototype(cx);
 78098:                 if (!proto)
 78098:                     return false;
 78098:                 TypeObject *object = proto->getNewType(cx);
 75720:                 if (!object)
 75720:                     return false;
 77391:                 TypeScript::ReturnTypes(script)->addType(cx, Type::ObjectType(object));
 75688:             } else {
 77391:                 TypeScript::ReturnTypes(script)->addType(cx, Type::UnknownType());
 75688:             }
 75615:         }
 75615:         break;
 75615: 
 75615:       case JSOP_YIELD:
 77353:         pushed[0].addType(cx, Type::UnknownType());
 75615:         break;
 75615: 
 87261:       case JSOP_CALLXMLNAME:
 87261:         pushed[1].addType(cx, Type::UnknownType());
 87261:         /* FALLTHROUGH */
 87261: 
 86855:       case JSOP_XMLNAME:
 77353:         pushed[0].addType(cx, Type::UnknownType());
 75633:         break;
 75633: 
 75615:       case JSOP_SETXMLNAME:
 75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
 77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
 75615:         break;
 75615: 
 75615:       case JSOP_BINDXMLNAME:
 75615:         break;
 75615: 
 75615:       case JSOP_TOXML:
 75615:       case JSOP_TOXMLLIST:
 75615:       case JSOP_XMLPI:
 75615:       case JSOP_XMLCDATA:
 75615:       case JSOP_XMLCOMMENT:
 75615:       case JSOP_DESCENDANTS:
 75615:       case JSOP_TOATTRNAME:
 75615:       case JSOP_QNAMECONST:
 75615:       case JSOP_QNAME:
 75615:       case JSOP_ANYNAME:
 75615:       case JSOP_GETFUNNS:
 75615:       case JSOP_FILTER:
 75615:         /* Note: the second value pushed by filter is a hole, and not modelled. */
 75615:       case JSOP_ENDFILTER:
 95095:         pushed[0].addType(cx, Type::UnknownType());
 75615:         break;
 75615: 
 75708:       case JSOP_CALLEE:
 76158:         if (script->hasGlobal())
 77391:             pushed[0].addType(cx, Type::ObjectType(script->function()));
 75708:         else
 77353:             pushed[0].addType(cx, Type::UnknownType());
 75708:         break;
 75708: 
 75615:       default:
 76150:         /* Display fine-grained debug information first */
 76150:         fprintf(stderr, "Unknown bytecode %02x at #%u:%05u\n", op, script->id(), offset);
 76150:         TypeFailure(cx, "Unknown bytecode %02x", op);
 75615:     }
 75720: 
 75720:     return true;
 75708: }
 75615: 
 75701: void
 76059: ScriptAnalysis::analyzeTypes(JSContext *cx)
 75701: {
 76093:     JS_ASSERT(!ranInference());
 76093: 
 76093:     if (OOM()) {
 76093:         cx->compartment->types.setPendingNukeTypes(cx);
 76093:         return;
 76093:     }
 75987: 
 76058:     /*
 76058:      * Refuse to analyze the types in a script which is compileAndGo but is
 76058:      * running against a global with a cleared scope. Per GlobalObject::clear,
 76058:      * we won't be running anymore compileAndGo code against the global
 76058:      * (moreover, after clearing our analysis results will be wrong for the
 76058:      * script and trying to reanalyze here can cause reentrance problems if we
 76058:      * try to reinitialize standard classes that were cleared).
 76058:      */
 76158:     if (script->hasClearedGlobal())
 76058:         return;
 76058: 
 75987:     if (!ranSSA()) {
 75987:         analyzeSSA(cx);
 75987:         if (failed())
 75987:             return;
 75987:     }
 75987: 
 75987:     /*
 75987:      * Set this early to avoid reentrance. Any failures are OOMs, and will nuke
 75987:      * all types in the compartment.
 75987:      */
 75987:     ranInference_ = true;
 75708: 
 75987:     /* Make sure the initial type set of all local vars includes void. */
 75987:     for (unsigned i = 0; i < script->nfixed; i++)
 77391:         TypeScript::LocalTypes(script, i)->addType(cx, Type::UndefinedType());
 75987: 
 83256:     TypeScriptNesting *nesting = script->function() ? script->nesting() : NULL;
 77887:     if (nesting && nesting->parent) {
 77884:         /*
 77887:          * Check whether NAME accesses can be resolved in parent scopes, and
 77887:          * detach from the parent if so. Even if outdated activations of this
 77887:          * function are live when the parent is called again, we do not need to
 77887:          * consider this reentrance as no state in the parent will be used.
 77884:          */
 77887:         if (!nesting->parent->ensureRanInference(cx))
 77887:             return;
 77887: 
 77898:         bool detached = false;
 77898: 
 77887:         /* Don't track for leaf scripts which have no free variables. */
 77898:         if (!usesScopeChain() && !script->isOuterFunction) {
 77884:             DetachNestingParent(script);
 77898:             detached = true;
 77898:         }
 77884: 
 77887:         /*
 77887:          * If the names bound by the script are extensible (DEFFUN, EVAL, ...),
 77887:          * don't resolve NAME accesses into the parent.
 77887:          */
 77898:         if (!detached && extendsScope()) {
 77887:             DetachNestingParent(script);
 77898:             detached = true;
 77898:         }
 77887: 
 84950: 
 84950:         if (!detached) {
 77887:             /*
 77887:              * Don't track for parents which add call objects or are generators,
 77887:              * don't resolve NAME accesses into the parent.
 77887:              */
 95100:             if (nesting->parent->analysis()->addsScopeObjects() || nesting->parent->isGenerator)
 77887:                 DetachNestingParent(script);
 84950:         }
 77887:     }
 77887: 
 75987:     TypeInferenceState state(cx);
 75768: 
 75701:     unsigned offset = 0;
 75701:     while (offset < script->length) {
 76059:         Bytecode *code = maybeCode(offset);
 75701: 
 75701:         jsbytecode *pc = script->code + offset;
 75701: 
 77360:         if (code && !analyzeTypesBytecode(cx, offset, state)) {
 75720:             cx->compartment->types.setPendingNukeTypes(cx);
 75720:             return;
 75720:         }
 75708: 
 76059:         offset += GetBytecodeLength(pc);
 75708:     }
 75708: 
 75987:     for (unsigned i = 0; i < state.phiNodes.length(); i++) {
 75987:         SSAPhiNode *node = state.phiNodes[i];
 75987:         for (unsigned j = 0; j < node->length; j++) {
 75987:             const SSAValue &v = node->options[j];
 77353:             getValueTypes(v)->addSubset(cx, &node->types);
 75987:         }
 75987:     }
 75987: 
 75718:     /*
 77361:      * Replay any dynamic type results which have been generated for the script
 77361:      * either because we ran the interpreter some before analyzing or because
 77361:      * we are reanalyzing after a GC.
 75718:      */
 77391:     TypeResult *result = script->types->dynamicList;
 75718:     while (result) {
 84755:         if (result->offset != UINT32_MAX) {
 77361:             pushedTypes(result->offset)->addType(cx, result->type);
 77399:         } else {
 77399:             /* Custom for-in loop iteration has happened in this script. */
 77399:             state.forTypes->addType(cx, Type::UnknownType());
 77399:         }
 75718:         result = result->next;
 75718:     }
 75708: }
 75708: 
 79677: bool
 79677: ScriptAnalysis::integerOperation(JSContext *cx, jsbytecode *pc)
 79677: {
 84755:     JS_ASSERT(uint32_t(pc - script->code) < script->length);
 79677: 
 79677:     switch (JSOp(*pc)) {
 79677: 
 79677:       case JSOP_INCARG:
 79677:       case JSOP_DECARG:
 79677:       case JSOP_ARGINC:
 79677:       case JSOP_ARGDEC:
 79677:       case JSOP_INCLOCAL:
 79677:       case JSOP_DECLOCAL:
 79677:       case JSOP_LOCALINC:
 79677:       case JSOP_LOCALDEC: {
 79677:         if (pushedTypes(pc, 0)->getKnownTypeTag(cx) != JSVAL_TYPE_INT32)
 79677:             return false;
 84755:         uint32_t slot = GetBytecodeSlot(script, pc);
 79677:         if (trackSlot(slot)) {
 79677:             if (poppedTypes(pc, 0)->getKnownTypeTag(cx) != JSVAL_TYPE_INT32)
 79677:                 return false;
 79677:         }
 79677:         return true;
 79677:       }
 79677: 
 79677:       case JSOP_ADD:
 79677:       case JSOP_SUB:
 79677:       case JSOP_MUL:
 79677:       case JSOP_DIV:
 79677:         if (pushedTypes(pc, 0)->getKnownTypeTag(cx) != JSVAL_TYPE_INT32)
 79677:             return false;
 79677:         if (poppedTypes(pc, 0)->getKnownTypeTag(cx) != JSVAL_TYPE_INT32)
 79677:             return false;
 79677:         if (poppedTypes(pc, 1)->getKnownTypeTag(cx) != JSVAL_TYPE_INT32)
 79677:             return false;
 79677:         return true;
 79677: 
 79677:       default:
 79677:         return true;
 79677:     }
 79677: }
 79677: 
 76059: /*
 76059:  * Persistent constraint clearing out newScript and definite properties from
 76059:  * an object should a property on another object get a setter.
 76059:  */
 76059: class TypeConstraintClearDefiniteSetter : public TypeConstraint
 76059: {
 76059: public:
 76059:     TypeObject *object;
 76059: 
 76059:     TypeConstraintClearDefiniteSetter(TypeObject *object)
 77361:         : TypeConstraint("clearDefiniteSetter"), object(object)
 76059:     {}
 76059: 
 84118:     void newPropertyState(JSContext *cx, TypeSet *source)
 84118:     {
 76059:         if (!object->newScript)
 76059:             return;
 76059:         /*
 76059:          * Clear out the newScript shape and definite property information from
 84118:          * an object if the source type set could be a setter or could be
 84118:          * non-writable, both of which are indicated by the source type set
 84118:          * being marked as configured.
 76059:          */
 84118:         if (!(object->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED) && source->isOwnProperty(true))
 76059:             object->clearNewScript(cx);
 76059:     }
 84118: 
 84118:     void newType(JSContext *cx, TypeSet *source, Type type) {}
 76059: };
 76059: 
 76059: /*
 76059:  * Constraint which clears definite properties on an object should a type set
 76059:  * contain any types other than a single object.
 76059:  */
 76059: class TypeConstraintClearDefiniteSingle : public TypeConstraint
 76059: {
 76059: public:
 76059:     TypeObject *object;
 76059: 
 77353:     TypeConstraintClearDefiniteSingle(TypeObject *object)
 77361:         : TypeConstraint("clearDefiniteSingle"), object(object)
 76059:     {}
 76059: 
 77353:     void newType(JSContext *cx, TypeSet *source, Type type) {
 77361:         if (object->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED)
 77353:             return;
 77353: 
 77353:         if (source->baseFlags() || source->getObjectCount() > 1)
 76059:             object->clearNewScript(cx);
 76059:     }
 76059: };
 76059: 
 76059: static bool
 77884: AnalyzeNewScriptProperties(JSContext *cx, TypeObject *type, JSFunction *fun, JSObject **pbaseobj,
 76059:                            Vector<TypeNewScript::Initializer> *initializerList)
 75948: {
 75948:     /*
 75948:      * When invoking 'new' on the specified script, try to find some properties
 75948:      * which will definitely be added to the created object before it has a
 76059:      * chance to escape and be accessed elsewhere.
 76059:      *
 76059:      * Returns true if the entire script was analyzed (pbaseobj has been
 76059:      * preserved), false if we had to bail out part way through (pbaseobj may
 76059:      * have been cleared).
 75948:      */
 75948: 
 76089:     if (initializerList->length() > 50) {
 76089:         /*
 76089:          * Bail out on really long initializer lists (far longer than maximum
 76089:          * number of properties we can track), we may be recursing.
 76089:          */
 76089:         return false;
 76089:     }
 76089: 
 77884:     JSScript *script = fun->script();
 77884:     JS_ASSERT(!script->isInnerFunction);
 77886: 
 77884:     if (!script->ensureRanAnalysis(cx, fun) || !script->ensureRanInference(cx)) {
 76059:         *pbaseobj = NULL;
 76059:         cx->compartment->types.setPendingNukeTypes(cx);
 76059:         return false;
 76059:     }
 77886: 
 77886:     if (script->hasClearedGlobal())
 77886:         return false;
 77886: 
 77391:     ScriptAnalysis *analysis = script->analysis();
 76059: 
 76059:     /*
 76059:      * Offset of the last bytecode which popped 'this' and which we have
 76059:      * processed. For simplicity, we scan for places where 'this' is pushed
 76059:      * and immediately analyze the place where that pushed value is popped.
 76059:      * This runs the risk of doing things out of order, if the script looks
 76059:      * something like 'this.f  = (this.g = ...)', so we watch and bail out if
 76059:      * a 'this' is pushed before the previous 'this' value was popped.
 76059:      */
 84755:     uint32_t lastThisPopped = 0;
 76059: 
 76059:     unsigned nextOffset = 0;
 76059:     while (nextOffset < script->length) {
 76059:         unsigned offset = nextOffset;
 75948:         jsbytecode *pc = script->code + offset;
 76095: 
 75948:         JSOp op = JSOp(*pc);
 75948: 
 76059:         nextOffset += GetBytecodeLength(pc);
 76059: 
 76060:         Bytecode *code = analysis->maybeCode(pc);
 76060:         if (!code)
 76060:             continue;
 76060: 
 76060:         /*
 76060:          * End analysis after the first return statement from the script,
 76060:          * returning success if the return is unconditional.
 76060:          */
 76060:         if (op == JSOP_RETURN || op == JSOP_STOP || op == JSOP_RETRVAL) {
 76060:             if (offset < lastThisPopped) {
 76060:                 *pbaseobj = NULL;
 76060:                 return false;
 76060:             }
 76060:             return code->unconditional;
 76060:         }
 76060: 
 76059:         /* 'this' can escape through a call to eval. */
 76060:         if (op == JSOP_EVAL) {
 76060:             if (offset < lastThisPopped)
 76060:                 *pbaseobj = NULL;
 76059:             return false;
 76060:         }
 76059: 
 75948:         /*
 76059:          * We are only interested in places where 'this' is popped. The new
 76059:          * 'this' value cannot escape and be accessed except through such uses.
 75948:          */
 76059:         if (op != JSOP_THIS)
 76059:             continue;
 76059: 
 89530:         /* Maintain ordering property on how 'this' is used, as described above. */
 89530:         if (offset < lastThisPopped) {
 89530:             *pbaseobj = NULL;
 89530:             return false;
 89530:         }
 89530: 
 76059:         SSAValue thisv = SSAValue::PushedValue(offset, 0);
 76059:         SSAUseChain *uses = analysis->useChain(thisv);
 76059: 
 76059:         JS_ASSERT(uses);
 76059:         if (uses->next || !uses->popped) {
 76059:             /* 'this' value popped in more than one place. */
 76059:             return false;
 76059:         }
 76059: 
 76059:         lastThisPopped = uses->offset;
 76059: 
 76060:         /* Only handle 'this' values popped in unconditional code. */
 76060:         Bytecode *poppedCode = analysis->maybeCode(uses->offset);
 76060:         if (!poppedCode || !poppedCode->unconditional)
 76060:             return false;
 76060: 
 76059:         pc = script->code + uses->offset;
 76059:         op = JSOp(*pc);
 76059: 
 99421:         RootedObject obj(cx, *pbaseobj);
 76059: 
 76059:         if (op == JSOP_SETPROP && uses->u.which == 1) {
 76141:             /*
 76141:              * Don't use GetAtomId here, we need to watch for SETPROP on
 76141:              * integer properties and bail out. We can't mark the aggregate
 76141:              * JSID_VOID type property as being in a definite slot.
 76141:              */
 99421:             RootedId id(cx, NameToId(script->getName(GET_UINT32_INDEX(pc))));
 76059:             if (MakeTypeId(cx, id) != id)
 76059:                 return false;
 98960:             if (id_prototype(cx) == id || id___proto__(cx) == id || id_constructor(cx) == id)
 76059:                 return false;
 76059: 
 84118:             /*
 84118:              * Ensure that if the properties named here could have a setter or
 84118:              * a permanent property in any transitive prototype, the definite
 84118:              * properties get cleared from the shape.
 84118:              */
 84118:             JSObject *parent = type->proto;
 84118:             while (parent) {
 84118:                 TypeObject *parentObject = parent->getType(cx);
 84118:                 if (parentObject->unknownProperties())
 84118:                     return false;
 84118:                 TypeSet *parentTypes = parentObject->getProperty(cx, id, false);
 84118:                 if (!parentTypes || parentTypes->isOwnProperty(true))
 84118:                     return false;
 84118:                 parentTypes->add(cx, cx->typeLifoAlloc().new_<TypeConstraintClearDefiniteSetter>(type));
 84118:                 parent = parent->getProto();
 84118:             }
 84118: 
 76059:             unsigned slotSpan = obj->slotSpan();
 76072:             if (!DefineNativeProperty(cx, obj, id, UndefinedValue(), NULL, NULL,
 76087:                                       JSPROP_ENUMERATE, 0, 0, DNP_SKIP_TYPE)) {
 76059:                 cx->compartment->types.setPendingNukeTypes(cx);
 76059:                 *pbaseobj = NULL;
 76059:                 return false;
 76059:             }
 76059: 
 76059:             if (obj->inDictionaryMode()) {
 76059:                 *pbaseobj = NULL;
 76059:                 return false;
 76059:             }
 76059: 
 76059:             if (obj->slotSpan() == slotSpan) {
 75948:                 /* Set a duplicate property. */
 76059:                 return false;
 76059:             }
 76059: 
 76059:             TypeNewScript::Initializer setprop(TypeNewScript::Initializer::SETPROP, uses->offset);
 76059:             if (!initializerList->append(setprop)) {
 76059:                 cx->compartment->types.setPendingNukeTypes(cx);
 76059:                 *pbaseobj = NULL;
 76059:                 return false;
 76059:             }
 76059: 
 76059:             if (obj->slotSpan() >= (TYPE_FLAG_DEFINITE_MASK >> TYPE_FLAG_DEFINITE_SHIFT)) {
 75948:                 /* Maximum number of definite properties added. */
 76059:                 return false;
 76059:             }
 76059:         } else if (op == JSOP_FUNCALL && uses->u.which == GET_ARGC(pc) - 1) {
 76059:             /*
 76059:              * Passed as the first parameter to Function.call. Follow control
 76059:              * into the callee, and add any definite properties it assigns to
 76059:              * the object as well. :TODO: This is narrow pattern matching on
 76059:              * the inheritance patterns seen in the v8-deltablue benchmark, and
 76059:              * needs robustness against other ways initialization can cross
 76059:              * script boundaries.
 76059:              *
 76059:              * Add constraints ensuring we are calling Function.call on a
 76059:              * particular script, removing definite properties from the result
 76059:              */
 76059: 
 76059:             /* Callee/this must have been pushed by a CALLPROP. */
 76059:             SSAValue calleev = analysis->poppedValue(pc, GET_ARGC(pc) + 1);
 76095:             if (calleev.kind() != SSAValue::PUSHED)
 76059:                 return false;
 76095:             jsbytecode *calleepc = script->code + calleev.pushedOffset();
 86855:             if (JSOp(*calleepc) != JSOP_CALLPROP)
 76095:                 return false;
 76095: 
 76103:             /*
 76103:              * This code may not have run yet, break any type barriers involved
 76103:              * in performing the call (for the greater good!).
 76103:              */
 76103:             analysis->breakTypeBarriersSSA(cx, analysis->poppedValue(calleepc, 0));
 76103:             analysis->breakTypeBarriers(cx, calleepc - script->code, true);
 76103: 
 86855:             TypeSet *funcallTypes = analysis->poppedTypes(pc, GET_ARGC(pc) + 1);
 86855:             TypeSet *scriptTypes = analysis->poppedTypes(pc, GET_ARGC(pc));
 76059: 
 76059:             /* Need to definitely be calling Function.call on a specific script. */
 77353:             JSObject *funcallObj = funcallTypes->getSingleton(cx, false);
 77353:             JSObject *scriptObj = scriptTypes->getSingleton(cx, false);
 77353:             if (!funcallObj || !scriptObj || !scriptObj->isFunction() ||
 83234:                 !scriptObj->toFunction()->isInterpreted()) {
 76059:                 return false;
 76059:             }
 77353: 
 83234:             JSFunction *function = scriptObj->toFunction();
 77884:             JS_ASSERT(!function->script()->isInnerFunction);
 76059: 
 76059:             /*
 76103:              * Generate constraints to clear definite properties from the type
 76059:              * should the Function.call or callee itself change in the future.
 76059:              */
 86855:             funcallTypes->add(cx,
 79410:                 cx->typeLifoAlloc().new_<TypeConstraintClearDefiniteSingle>(type));
 86855:             scriptTypes->add(cx,
 79410:                 cx->typeLifoAlloc().new_<TypeConstraintClearDefiniteSingle>(type));
 76059: 
 76059:             TypeNewScript::Initializer pushframe(TypeNewScript::Initializer::FRAME_PUSH, uses->offset);
 76059:             if (!initializerList->append(pushframe)) {
 76059:                 cx->compartment->types.setPendingNukeTypes(cx);
 76059:                 *pbaseobj = NULL;
 76059:                 return false;
 76059:             }
 76059: 
 77884:             if (!AnalyzeNewScriptProperties(cx, type, function,
 76059:                                             pbaseobj, initializerList)) {
 76059:                 return false;
 76059:             }
 76059: 
 76059:             TypeNewScript::Initializer popframe(TypeNewScript::Initializer::FRAME_POP, 0);
 76059:             if (!initializerList->append(popframe)) {
 76059:                 cx->compartment->types.setPendingNukeTypes(cx);
 76059:                 *pbaseobj = NULL;
 76059:                 return false;
 76059:             }
 76059: 
 76059:             /*
 76059:              * The callee never lets the 'this' value escape, continue looking
 76059:              * for definite properties in the remainder of this script.
 76059:              */
 76059:         } else {
 76059:             /* Unhandled use of 'this'. */
 76059:             return false;
 76059:         }
 76059:     }
 76059: 
 76076:     /* Will have hit a STOP or similar, unless the script always throws. */
 76059:     return true;
 75948: }
 75948: 
 77361: /*
 77361:  * Either make the newScript information for type when it is constructed
 77361:  * by the specified script, or regenerate the constraints for an existing
 77361:  * newScript on the type after they were cleared by a GC.
 77361:  */
 77361: static void
 95355: CheckNewScriptProperties(JSContext *cx, HandleTypeObject type, JSFunction *fun)
 77884: {
 77884:     if (type->unknownProperties() || fun->script()->isInnerFunction)
 76151:         return;
 76151: 
 76151:     /* Strawman object to add properties to and watch for duplicates. */
 99421:     RootedObject baseobj(cx);
 95355:     baseobj = NewBuiltinClassInstance(cx, &ObjectClass, gc::FINALIZE_OBJECT16);
 77361:     if (!baseobj) {
 77361:         if (type->newScript)
 77361:             type->clearNewScript(cx);
 76151:         return;
 77361:     }
 76151: 
 76151:     Vector<TypeNewScript::Initializer> initializerList(cx);
 95355:     AnalyzeNewScriptProperties(cx, type, fun, baseobj.address(), &initializerList);
 77361:     if (!baseobj || baseobj->slotSpan() == 0 || !!(type->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED)) {
 77361:         if (type->newScript)
 77361:             type->clearNewScript(cx);
 76151:         return;
 77361:     }
 77361: 
 77361:     /*
 77361:      * If the type already has a new script, we are just regenerating the type
 77361:      * constraints and don't need to make another TypeNewScript. Make sure that
 77361:      * the properties added to baseobj match the type's definite properties.
 77361:      */
 77361:     if (type->newScript) {
 77361:         if (!type->matchDefiniteProperties(baseobj))
 77361:             type->clearNewScript(cx);
 77361:         return;
 77361:     }
 76151: 
 77775:     gc::AllocKind kind = gc::GetGCObjectKind(baseobj->slotSpan());
 76151: 
 76151:     /* We should not have overflowed the maximum number of fixed slots for an object. */
 76151:     JS_ASSERT(gc::GetGCKindSlots(kind) >= baseobj->slotSpan());
 76151: 
 76151:     TypeNewScript::Initializer done(TypeNewScript::Initializer::DONE, 0);
 76151: 
 76151:     /*
 77392:      * The base object may have been created with a different finalize kind
 77392:      * than we will use for subsequent new objects. Generate an object with the
 77392:      * appropriate final shape.
 76151:      */
 76151:     baseobj = NewReshapedObject(cx, type, baseobj->getParent(), kind,
 76151:                                 baseobj->lastProperty());
 76151:     if (!baseobj ||
 76151:         !type->addDefiniteProperties(cx, baseobj) ||
 76151:         !initializerList.append(done)) {
 76151:         cx->compartment->types.setPendingNukeTypes(cx);
 76151:         return;
 76151:     }
 76151: 
 76151:     size_t numBytes = sizeof(TypeNewScript)
 76151:                     + (initializerList.length() * sizeof(TypeNewScript::Initializer));
 76151:     type->newScript = (TypeNewScript *) cx->calloc_(numBytes);
 76151:     if (!type->newScript) {
 76151:         cx->compartment->types.setPendingNukeTypes(cx);
 76151:         return;
 76151:     }
 76151: 
 77884:     type->newScript->fun = fun;
 77775:     type->newScript->allocKind = kind;
 76151:     type->newScript->shape = baseobj->lastProperty();
 76151: 
 76151:     type->newScript->initializerList = (TypeNewScript::Initializer *)
 82129:         ((char *) type->newScript.get() + sizeof(TypeNewScript));
 76151:     PodCopy(type->newScript->initializerList, initializerList.begin(), initializerList.length());
 76151: }
 76151: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // Printing
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75615: void
 76059: ScriptAnalysis::printTypes(JSContext *cx)
 75615: {
 80167:     AutoEnterAnalysis enter(script->compartment());
 77659:     TypeCompartment *compartment = &script->compartment()->types;
 75615: 
 75615:     /*
 75615:      * Check if there are warnings for used values with unknown types, and build
 75615:      * statistics about the size of type sets found for stack values.
 75615:      */
 75615:     for (unsigned offset = 0; offset < script->length; offset++) {
 75987:         if (!maybeCode(offset))
 75615:             continue;
 75615: 
 76095:         jsbytecode *pc = script->code + offset;
 76095: 
 77357:         if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77357:             continue;
 77357: 
 76059:         unsigned defCount = GetDefCount(script, offset);
 75708:         if (!defCount)
 75615:             continue;
 75615: 
 75708:         for (unsigned i = 0; i < defCount; i++) {
 75987:             TypeSet *types = pushedTypes(offset, i);
 75615: 
 76019:             if (types->unknown()) {
 76019:                 compartment->typeCountOver++;
 76019:                 continue;
 76019:             }
 76019: 
 77353:             unsigned typeCount = 0;
 77353: 
 77353:             if (types->hasAnyFlag(TYPE_FLAG_ANYOBJECT) || types->getObjectCount() != 0)
 77353:                 typeCount++;
 77353:             for (TypeFlags flag = 1; flag < TYPE_FLAG_ANYOBJECT; flag <<= 1) {
 77353:                 if (types->hasAnyFlag(flag))
 75615:                     typeCount++;
 75615:             }
 75615: 
 75615:             /*
 75615:              * Adjust the type counts for floats: values marked as floats
 75615:              * are also marked as ints by the inference, but for counting
 75615:              * we don't consider these to be separate types.
 75615:              */
 75919:             if (types->hasAnyFlag(TYPE_FLAG_DOUBLE)) {
 75919:                 JS_ASSERT(types->hasAnyFlag(TYPE_FLAG_INT32));
 75615:                 typeCount--;
 75615:             }
 75615: 
 76019:             if (typeCount > TypeCompartment::TYPE_COUNT_LIMIT) {
 75615:                 compartment->typeCountOver++;
 75615:             } else if (typeCount == 0) {
 75615:                 /* Ignore values without types, this may be unreached code. */
 75615:             } else {
 75615:                 compartment->typeCounts[typeCount-1]++;
 75615:             }
 75615:         }
 75615:     }
 75615: 
 75640: #ifdef DEBUG
 75640: 
 83256:     if (script->function())
 75638:         printf("Function");
 77446:     else if (script->isCachedEval)
 75718:         printf("Eval");
 75615:     else
 75718:         printf("Main");
 75789:     printf(" #%u %s (line %d):\n", script->id(), script->filename, script->lineno);
 75718: 
 75718:     printf("locals:");
 75718:     printf("\n    return:");
 77391:     TypeScript::ReturnTypes(script)->print(cx);
 75718:     printf("\n    this:");
 77391:     TypeScript::ThisTypes(script)->print(cx);
 77391: 
 83256:     for (unsigned i = 0; script->function() && i < script->function()->nargs; i++) {
 75708:         printf("\n    arg%u:", i);
 77391:         TypeScript::ArgTypes(script, i)->print(cx);
 75641:     }
 75708:     for (unsigned i = 0; i < script->nfixed; i++) {
 75987:         if (!trackSlot(LocalSlot(script, i))) {
 75708:             printf("\n    local%u:", i);
 77391:             TypeScript::LocalTypes(script, i)->print(cx);
 75718:         }
 75987:     }
 75641:     printf("\n");
 75615: 
 75615:     for (unsigned offset = 0; offset < script->length; offset++) {
 75987:         if (!maybeCode(offset))
 75615:             continue;
 75615: 
 76095:         jsbytecode *pc = script->code + offset;
 76095: 
 76095:         PrintBytecode(cx, script, pc);
 76095: 
 77357:         if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77357:             continue;
 77357: 
 76095:         if (js_CodeSpec[*pc].format & JOF_TYPESET) {
 77391:             TypeSet *types = script->analysis()->bytecodeTypes(pc);
 77391:             printf("  typeset %d:", (int) (types - script->types->typeArray()));
 76061:             types->print(cx);
 76061:             printf("\n");
 76061:         }
 76061: 
 76059:         unsigned defCount = GetDefCount(script, offset);
 75708:         for (unsigned i = 0; i < defCount; i++) {
 75708:             printf("  type %d:", i);
 75987:             pushedTypes(offset, i)->print(cx);
 75638:             printf("\n");
 75615:         }
 75615: 
 76061:         if (getCode(offset).monitoredTypes)
 75638:             printf("  monitored\n");
 76061: 
 76087:         TypeBarrier *barrier = getCode(offset).typeBarriers;
 76087:         if (barrier != NULL) {
 76087:             printf("  barrier:");
 76087:             while (barrier) {
 76087:                 printf(" %s", TypeString(barrier->type));
 76087:                 barrier = barrier->next;
 76087:             }
 76087:             printf("\n");
 76087:         }
 75615:     }
 75615: 
 75638:     printf("\n");
 75615: 
 75640: #endif /* DEBUG */
 75640: 
 75615: }
 75615: 
 75720: /////////////////////////////////////////////////////////////////////
 76148: // Interface functions
 76148: /////////////////////////////////////////////////////////////////////
 76148: 
 76158: namespace js {
 76158: namespace types {
 76148: 
 76148: void
 76175: MarkIteratorUnknownSlow(JSContext *cx)
 76148: {
 76175:     /* Check whether we are actually at an ITER opcode. */
 76148: 
 76157:     jsbytecode *pc;
 76157:     JSScript *script = cx->stack.currentScript(&pc);
 76168:     if (!script || !pc)
 76148:         return;
 76148: 
 77399:     if (JSOp(*pc) != JSOP_ITER)
 77399:         return;
 77399: 
 77399:     AutoEnterTypeInference enter(cx);
 77399: 
 76148:     /*
 77399:      * This script is iterating over an actual Iterator or Generator object, or
 77399:      * an object with a custom __iterator__ hook. In such cases 'for in' loops
 77399:      * can produce values other than strings, and the types of the ITER opcodes
 77399:      * in the script need to be updated. During analysis this is done with the
 77399:      * forTypes in the analysis state, but we don't keep a pointer to this type
 77399:      * set and need to scan the script to fix affected opcodes.
 76148:      */
 77399: 
 77399:     TypeResult *result = script->types->dynamicList;
 77399:     while (result) {
 84755:         if (result->offset == UINT32_MAX) {
 77399:             /* Already know about custom iterators used in this script. */
 77399:             JS_ASSERT(result->type.isUnknown());
 76148:             return;
 77399:         }
 77404:         result = result->next;
 77399:     }
 77399: 
 77399:     InferSpew(ISpewOps, "externalType: customIterator #%u", script->id());
 77399: 
 84755:     result = cx->new_<TypeResult>(UINT32_MAX, Type::UnknownType());
 77399:     if (!result) {
 77399:         cx->compartment->types.setPendingNukeTypes(cx);
 77399:         return;
 77399:     }
 77399:     result->next = script->types->dynamicList;
 77399:     script->types->dynamicList = result;
 77399: 
 77399:     if (!script->hasAnalysis() || !script->analysis()->ranInference())
 77399:         return;
 77399: 
 77399:     ScriptAnalysis *analysis = script->analysis();
 77399: 
 77399:     for (unsigned i = 0; i < script->length; i++) {
 77399:         jsbytecode *pc = script->code + i;
 77399:         if (!analysis->maybeCode(pc))
 77399:             continue;
 84195:         if (JSOp(*pc) == JSOP_ITERNEXT)
 77399:             analysis->pushedTypes(pc, 0)->addType(cx, Type::UnknownType());
 77399:     }
 77399: 
 77399:     /* Trigger recompilation of any inline callers. */
 83256:     if (script->function() && !script->function()->hasLazyType())
 77399:         ObjectStateChange(cx, script->function()->type(), false, true);
 76148: }
 76148: 
 76148: void
 76148: TypeMonitorCallSlow(JSContext *cx, JSObject *callee,
 80962:                     const CallArgs &args, bool constructing)
 76148: {
 83234:     unsigned nargs = callee->toFunction()->nargs;
 83234:     JSScript *script = callee->toFunction()->script();
 76148: 
 77391:     if (!constructing)
 77391:         TypeScript::SetThis(cx, script, args.thisv());
 76148: 
 76148:     /*
 76148:      * Add constraints going up to the minimum of the actual and formal count.
 76148:      * If there are more actuals than formals the later values can only be
 76148:      * accessed through the arguments object, which is monitored.
 76148:      */
 76148:     unsigned arg = 0;
 79387:     for (; arg < args.length() && arg < nargs; arg++)
 77391:         TypeScript::SetArgument(cx, script, arg, args[arg]);
 76148: 
 76148:     /* Watch for fewer actuals than formals to the call. */
 80962:     for (; arg < nargs; arg++)
 80962:         TypeScript::SetArgument(cx, script, arg, UndefinedValue());
 76148: }
 76148: 
 77353: static inline bool
 89658: IsAboutToBeFinalized(TypeObjectKey *key)
 77353: {
 77361:     /* Mask out the low bit indicating whether this is a type or JS object. */
 99246:     gc::Cell *tmp = reinterpret_cast<gc::Cell *>(uintptr_t(key) & ~1);
 99246:     bool isMarked = IsCellMarked(&tmp);
 99246:     JS_ASSERT(tmp == reinterpret_cast<gc::Cell *>(uintptr_t(key) & ~1));
 99246:     return !isMarked;
 77361: }
 76148: 
 76148: void
 77353: TypeDynamicResult(JSContext *cx, JSScript *script, jsbytecode *pc, Type type)
 76148: {
 76148:     JS_ASSERT(cx->typeInferenceEnabled());
 76148:     AutoEnterTypeInference enter(cx);
 76148: 
 76148:     /* Directly update associated type sets for applicable bytecodes. */
 76175:     if (js_CodeSpec[*pc].format & JOF_TYPESET) {
 83256:         if (!script->ensureRanAnalysis(cx, NULL)) {
 77391:             cx->compartment->types.setPendingNukeTypes(cx);
 77391:             return;
 77391:         }
 77391:         TypeSet *types = script->analysis()->bytecodeTypes(pc);
 76148:         if (!types->hasType(type)) {
 76148:             InferSpew(ISpewOps, "externalType: monitorResult #%u:%05u: %s",
 76148:                       script->id(), pc - script->code, TypeString(type));
 76148:             types->addType(cx, type);
 76148:         }
 76148:         return;
 76148:     }
 76148: 
 76148:     /*
 76148:      * For inc/dec ops, we need to go back and reanalyze the affected opcode
 76148:      * taking the overflow into account. We won't see an explicit adjustment
 76148:      * of the type of the thing being inc/dec'ed, nor will adding TYPE_DOUBLE to
 77357:      * the pushed value affect that type.
 76148:      */
 76148:     JSOp op = JSOp(*pc);
 76148:     const JSCodeSpec *cs = &js_CodeSpec[op];
 76148:     if (cs->format & (JOF_INC | JOF_DEC)) {
 76148:         switch (op) {
 76148:           case JSOP_INCLOCAL:
 76148:           case JSOP_DECLOCAL:
 76148:           case JSOP_LOCALINC:
 76148:           case JSOP_LOCALDEC:
 76148:           case JSOP_INCARG:
 76148:           case JSOP_DECARG:
 76148:           case JSOP_ARGINC:
 76148:           case JSOP_ARGDEC: {
 76148:             /*
 76148:              * Just mark the slot's type as holding the new type. This captures
 76148:              * the effect if the slot is not being tracked, and if the slot
 76148:              * doesn't escape we will update the pushed types below to capture
 76148:              * the slot's value after this write.
 76148:              */
 84755:             uint32_t slot = GetBytecodeSlot(script, pc);
 76148:             if (slot < TotalSlots(script)) {
 77391:                 TypeSet *types = TypeScript::SlotTypes(script, slot);
 76148:                 types->addType(cx, type);
 76148:             }
 76148:             break;
 76148:           }
 76148: 
 76148:           default:;
 76148:         }
 76148:     }
 76148: 
 77391:     if (script->hasAnalysis() && script->analysis()->ranInference()) {
 76148:         /*
 76148:          * If the pushed set already has this type, we don't need to ensure
 76148:          * there is a TypeIntermediate. Either there already is one, or the
 76148:          * type could be determined from the script's other input type sets.
 76148:          */
 77391:         TypeSet *pushed = script->analysis()->pushedTypes(pc, 0);
 76148:         if (pushed->hasType(type))
 76148:             return;
 76148:     } else {
 76148:         /* Scan all intermediate types on the script to check for a dupe. */
 77391:         TypeResult *result, **pstart = &script->types->dynamicList, **presult = pstart;
 76148:         while (*presult) {
 76148:             result = *presult;
 77361:             if (result->offset == unsigned(pc - script->code) && result->type == type) {
 76158:                 if (presult != pstart) {
 76148:                     /* Move to the head of the list, maintain LRU order. */
 76148:                     *presult = result->next;
 76158:                     result->next = *pstart;
 76158:                     *pstart = result;
 76148:                 }
 76148:                 return;
 76148:             }
 76148:             presult = &result->next;
 76148:         }
 76148:     }
 76148: 
 76148:     InferSpew(ISpewOps, "externalType: monitorResult #%u:%05u: %s",
 76148:               script->id(), pc - script->code, TypeString(type));
 76148: 
 77361:     TypeResult *result = cx->new_<TypeResult>(pc - script->code, type);
 76148:     if (!result) {
 76148:         cx->compartment->types.setPendingNukeTypes(cx);
 76148:         return;
 76148:     }
 77391:     result->next = script->types->dynamicList;
 77391:     script->types->dynamicList = result;
 77391: 
 77391:     if (script->hasAnalysis() && script->analysis()->ranInference()) {
 77391:         TypeSet *pushed = script->analysis()->pushedTypes(pc, 0);
 76148:         pushed->addType(cx, type);
 76148:     }
 76148: 
 76148:     /* Trigger recompilation of any inline callers. */
 83256:     if (script->function() && !script->function()->hasLazyType())
 77391:         ObjectStateChange(cx, script->function()->type(), false, true);
 76148: }
 76148: 
 76148: void
 80962: TypeMonitorResult(JSContext *cx, JSScript *script, jsbytecode *pc, const js::Value &rval)
 80962: {
 77357:     /* Allow the non-TYPESET scenario to simplify stubs used in compound opcodes. */
 76148:     if (!(js_CodeSpec[*pc].format & JOF_TYPESET))
 76148:         return;
 76148: 
 77391:     AutoEnterTypeInference enter(cx);
 77391: 
 83256:     if (!script->ensureRanAnalysis(cx, NULL)) {
 77391:         cx->compartment->types.setPendingNukeTypes(cx);
 77391:         return;
 77391:     }
 77391: 
 77353:     Type type = GetValueType(cx, rval);
 77391:     TypeSet *types = script->analysis()->bytecodeTypes(pc);
 76148:     if (types->hasType(type))
 76148:         return;
 76148: 
 76148:     InferSpew(ISpewOps, "bytecodeType: #%u:%05u: %s",
 76148:               script->id(), pc - script->code, TypeString(type));
 76148:     types->addType(cx, type);
 76148: }
 76148: 
 77884: bool
 99364: TypeScript::SetScope(JSContext *cx, JSScript *script_, JSObject *scope_)
 99364: {
 99421:     Rooted<JSScript*> script(cx, script_);
 99421:     RootedObject scope(cx, scope_);
 99364: 
 77884:     JS_ASSERT(script->types && !script->types->hasScope());
 77884: 
 83256:     JSFunction *fun = script->function();
 86437:     bool nullClosure = fun && fun->isNullClosure();
 83256: 
 77884:     JS_ASSERT_IF(!fun, !script->isOuterFunction && !script->isInnerFunction);
 77884:     JS_ASSERT_IF(!scope, fun && !script->isInnerFunction);
 77884: 
 77884:     /*
 77884:      * The scope object must be the initial one for the script, before any call
 77884:      * object has been created in the heavyweight case.
 77884:      */
 78065:     JS_ASSERT_IF(scope && scope->isCall() && !scope->asCall().isForEval(),
 78065:                  scope->asCall().getCalleeFunction() != fun);
 77884: 
 77884:     if (!script->compileAndGo) {
 77884:         script->types->global = NULL;
 77884:         return true;
 77884:     }
 77884: 
 86483:     JS_ASSERT_IF(fun && scope, fun->global() == scope->global());
 86483:     script->types->global = fun ? &fun->global() : &scope->global();
 77884: 
 83245:     /*
 83245:      * Update the parent in the script's bindings. The bindings are created
 83245:      * with a NULL parent, and fixing the parent now avoids the need to reshape
 83245:      * every time a call object is created from the bindings.
 83245:      */
 83245:     if (!script->bindings.setParent(cx, script->types->global))
 83245:         return false;
 83245: 
 77884:     if (!cx->typeInferenceEnabled())
 77884:         return true;
 77884: 
 86437:     if (!script->isInnerFunction || nullClosure) {
 77884:         /*
 77884:          * Outermost functions need nesting information if there are inner
 77884:          * functions directly nested in them.
 77884:          */
 77884:         if (script->isOuterFunction) {
 77884:             script->types->nesting = cx->new_<TypeScriptNesting>();
 77884:             if (!script->types->nesting)
 77884:                 return false;
 77884:         }
 77884:         return true;
 77884:     }
 77884: 
 77884:     /*
 77884:      * Walk the scope chain to the next call object, which will be the function
 77884:      * the script is nested inside.
 77884:      */
 77884:     while (!scope->isCall())
 86483:         scope = &scope->asScope().enclosingScope();
 77884: 
 78065:     CallObject &call = scope->asCall();
 78065: 
 77884:     /* The isInnerFunction test ensures there is no intervening strict eval call object. */
 78065:     JS_ASSERT(!call.isForEval());
 77884: 
 77884:     /* Don't track non-heavyweight parents, NAME ops won't reach into them. */
 78065:     JSFunction *parentFun = call.getCalleeFunction();
 77884:     if (!parentFun || !parentFun->isHeavyweight())
 77884:         return true;
 77884:     JSScript *parent = parentFun->script();
 77884:     JS_ASSERT(parent->isOuterFunction);
 77884: 
 77884:     /*
 77884:      * We only need the nesting in the child if it has NAME accesses going
 77884:      * into the parent. We won't know for sure whether this is the case until
 77884:      * analyzing the script's types, which we don't want to do yet. The nesting
 77884:      * info we make here may get pruned if/when we eventually do such analysis.
 77884:      */
 77884: 
 77884:     /*
 77884:      * Scopes are set when scripts first execute, and the parent script must
 77884:      * have executed first. It is still possible for the parent script to not
 77884:      * have a scope, however, as we occasionally purge all TypeScripts from the
 77884:      * compartment and there may be inner function objects parented to an
 77884:      * activation of the outer function sticking around. In such cases, treat
 77884:      * the parent's call object as the most recent one, so that it is not
 77884:      * marked as reentrant.
 77884:      */
 83256:     if (!parent->ensureHasTypes(cx))
 77884:         return false;
 77884:     if (!parent->types->hasScope()) {
 86483:         if (!SetScope(cx, parent, &call.enclosingScope()))
 77884:             return false;
 86483:         parent->nesting()->activeCall = &call;
 82129:         parent->nesting()->argArray = Valueify(call.argArray());
 82129:         parent->nesting()->varArray = Valueify(call.varArray());
 77884:     }
 77884: 
 77884:     JS_ASSERT(!script->types->nesting);
 77884: 
 77884:     /* Construct and link nesting information for the two functions. */
 77884: 
 77884:     script->types->nesting = cx->new_<TypeScriptNesting>();
 77884:     if (!script->types->nesting)
 77884:         return false;
 77884: 
 77884:     script->nesting()->parent = parent;
 77884:     script->nesting()->next = parent->nesting()->children;
 77884:     parent->nesting()->children = script;
 77884: 
 77884:     return true;
 77884: }
 77884: 
 77884: TypeScriptNesting::~TypeScriptNesting()
 77884: {
 77884:     /*
 77884:      * Unlink from any parent/child. Nesting info on a script does not keep
 77884:      * either the parent or children live during GC.
 77884:      */
 77884: 
 77884:     if (parent) {
 77884:         JSScript **pscript = &parent->nesting()->children;
 77884:         while ((*pscript)->nesting() != this)
 77884:             pscript = &(*pscript)->nesting()->next;
 77884:         *pscript = next;
 77884:     }
 77884: 
 77884:     while (children) {
 77884:         TypeScriptNesting *child = children->nesting();
 77884:         children = child->next;
 77884:         child->parent = NULL;
 77884:         child->next = NULL;
 77884:     }
 77884: }
 77884: 
 77884: bool
 77884: ClearActiveNesting(JSScript *start)
 77884: {
 77884:     /*
 77884:      * Clear active call information for script and any outer functions
 77884:      * inner to it. Return false if an inner function has frames on the stack.
 77884:      */
 77884: 
 77884:     /* Traverse children, then parent, avoiding recursion. */
 77884:     JSScript *script = start;
 77884:     bool traverseChildren = true;
 77884:     while (true) {
 77884:         TypeScriptNesting *nesting = script->nesting();
 77884:         if (nesting->children && traverseChildren) {
 77884:             script = nesting->children;
 77884:             continue;
 77884:         }
 77884:         if (nesting->activeFrames)
 77884:             return false;
 77884:         if (script->isOuterFunction) {
 77884:             nesting->activeCall = NULL;
 77884:             nesting->argArray = NULL;
 77884:             nesting->varArray = NULL;
 77884:         }
 77884:         if (script == start)
 77884:             break;
 77884:         if (nesting->next) {
 77884:             script = nesting->next;
 77884:             traverseChildren = true;
 77884:         } else {
 77884:             script = nesting->parent;
 77884:             traverseChildren = false;
 77884:         }
 77884:     }
 77884: 
 77884:     return true;
 77884: }
 77884: 
 77884: /*
 77884:  * For the specified scope and script with an outer function, check if the
 77884:  * scope represents a reentrant activation on an inner function of the parent
 77884:  * or any of its transitive parents.
 77884:  */
 77884: static void
 77884: CheckNestingParent(JSContext *cx, JSObject *scope, JSScript *script)
 77884: {
 77884:   restart:
 77884:     JSScript *parent = script->nesting()->parent;
 77884:     JS_ASSERT(parent);
 77884: 
 78065:     while (!scope->isCall() || scope->asCall().getCalleeFunction()->script() != parent)
 86483:         scope = &scope->asScope().enclosingScope();
 77884: 
 77884:     if (scope != parent->nesting()->activeCall) {
 77884:         parent->reentrantOuterFunction = true;
 77884:         MarkTypeObjectFlags(cx, parent->function(), OBJECT_FLAG_REENTRANT_FUNCTION);
 77884: 
 77884:         /*
 77884:          * Continue checking parents to see if this is reentrant for them too.
 77884:          * We don't need to check this in for non-reentrant calls on the outer
 77884:          * function: when we entered any outer function to the immediate parent
 77884:          * we cleared the active call for its transitive children, so a
 77884:          * non-reentrant call on a child is also a non-reentrant call on the
 77884:          * parent.
 77884:          */
 77884:         if (parent->nesting()->parent) {
 86483:             scope = &scope->asScope().enclosingScope();
 77884:             script = parent;
 77884:             goto restart;
 77884:         }
 77884:     }
 77884: }
 77884: 
 77884: void
 77884: NestingPrologue(JSContext *cx, StackFrame *fp)
 77884: {
 77884:     JSScript *script = fp->fun()->script();
 77884:     TypeScriptNesting *nesting = script->nesting();
 77884: 
 77884:     if (nesting->parent)
 96793:         CheckNestingParent(cx, fp->scopeChain(), script);
 77884: 
 77884:     if (script->isOuterFunction) {
 77884:         /*
 77884:          * Check the stack has no frames for this activation, any of its inner
 77884:          * functions or any of their transitive inner functions.
 77884:          */
 77884:         if (!ClearActiveNesting(script)) {
 77884:             script->reentrantOuterFunction = true;
 77884:             MarkTypeObjectFlags(cx, fp->fun(), OBJECT_FLAG_REENTRANT_FUNCTION);
 77884:         }
 77884: 
 77884:         nesting->activeCall = &fp->callObj();
100006:         nesting->argArray = fp->formalArgs();
100006:         nesting->varArray = fp->slots();
 77884:     }
 77884: 
 77884:     /* Maintain stack frame count for the function. */
 77884:     nesting->activeFrames++;
 77884: }
 77884: 
 77884: void
 77884: NestingEpilogue(StackFrame *fp)
 77884: {
 77884:     JSScript *script = fp->fun()->script();
 77884:     TypeScriptNesting *nesting = script->nesting();
 77884: 
 77884:     JS_ASSERT(nesting->activeFrames != 0);
 77884:     nesting->activeFrames--;
 77884: }
 77884: 
 76148: } } /* namespace js::types */
 76148: 
 76148: /////////////////////////////////////////////////////////////////////
 76158: // TypeScript
 75720: /////////////////////////////////////////////////////////////////////
 75720: 
 75708: /*
 75708:  * Returns true if we don't expect to compute the correct types for some value
 75708:  * pushed by the specified bytecode.
 75708:  */
 75708: static inline bool
 76020: IgnorePushed(const jsbytecode *pc, unsigned index)
 75708: {
 76020:     switch (JSOp(*pc)) {
 75708:       /* We keep track of the scopes pushed by BINDNAME separately. */
 75708:       case JSOP_BINDNAME:
 75708:       case JSOP_BINDGNAME:
 75708:       case JSOP_BINDXMLNAME:
 75708:         return true;
 75708: 
 75708:       /* Stack not consistent in TRY_BRANCH_AFTER_COND. */
 75708:       case JSOP_IN:
 75708:       case JSOP_EQ:
 75708:       case JSOP_NE:
 75708:       case JSOP_LT:
 75708:       case JSOP_LE:
 75708:       case JSOP_GT:
 75708:       case JSOP_GE:
 75708:         return (index == 0);
 75708: 
 75708:       /* Value not determining result is not pushed by OR/AND. */
 75708:       case JSOP_OR:
 75708:       case JSOP_AND:
 75708:         return (index == 0);
 75708: 
 75708:       /* Holes tracked separately. */
 75708:       case JSOP_HOLE:
 75708:         return (index == 0);
 75708:       case JSOP_FILTER:
 75708:         return (index == 1);
 75708: 
 75708:       /* Storage for 'with' and 'let' blocks not monitored. */
 75708:       case JSOP_ENTERWITH:
 75708:       case JSOP_ENTERBLOCK:
 86078:       case JSOP_ENTERLET0:
 86078:       case JSOP_ENTERLET1:
 75708:         return true;
 75708: 
 75708:       /* We don't keep track of the iteration state for 'for in' or 'for each in' loops. */
 75708:       case JSOP_ITER:
 77363:       case JSOP_ITERNEXT:
 75708:       case JSOP_MOREITER:
 75708:       case JSOP_ENDITER:
 75708:         return true;
 75708: 
 77357:       /* Ops which can manipulate values pushed by opcodes we don't model. */
 75708:       case JSOP_DUP:
 75708:       case JSOP_DUP2:
 77357:       case JSOP_SWAP:
 77357:       case JSOP_PICK:
 75708:         return true;
 75708: 
 75708:       /* We don't keep track of state indicating whether there is a pending exception. */
 75708:       case JSOP_FINALLY:
 75708:         return true;
 75708: 
 76020:       /*
 76020:        * We don't treat GETLOCAL immediately followed by a pop as a use-before-def,
 76020:        * and while the type will have been inferred correctly the method JIT
 76020:        * may not have written the local's initial undefined value to the stack,
 76020:        * leaving a stale value.
 76020:        */
 76020:       case JSOP_GETLOCAL:
 76020:         return JSOp(pc[JSOP_GETLOCAL_LENGTH]) == JSOP_POP;
 76020: 
 75708:       default:
 75708:         return false;
 75708:     }
 75708: }
 75708: 
 75718: bool
 83256: JSScript::makeTypes(JSContext *cx)
 75718: {
 77391:     JS_ASSERT(!types);
 77391: 
 77391:     if (!cx->typeInferenceEnabled()) {
 77391:         types = (TypeScript *) cx->calloc_(sizeof(TypeScript));
 95084:         if (!types) {
 95084:             js_ReportOutOfMemory(cx);
 77884:             return false;
 95084:         }
 83256:         new(types) TypeScript();
 77884:         return true;
 77391:     }
 75718: 
 76020:     AutoEnterTypeInference enter(cx);
 76020: 
 83256:     unsigned count = TypeScript::NumTypeSets(this);
 77884: 
 77391:     types = (TypeScript *) cx->calloc_(sizeof(TypeScript) + (sizeof(TypeSet) * count));
 77391:     if (!types) {
 76158:         cx->compartment->types.setPendingNukeTypes(cx);
 75718:         return false;
 76020:     }
 75718: 
 83256:     new(types) TypeScript();
 77884: 
 75718: #ifdef DEBUG
 77391:     TypeSet *typeArray = types->typeArray();
 77391:     for (unsigned i = 0; i < nTypeSets; i++)
 76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s bytecode%u #%u",
 76182:                   InferSpewColor(&typeArray[i]), &typeArray[i], InferSpewColorReset(),
 77391:                   i, id());
 77391:     TypeSet *returnTypes = TypeScript::ReturnTypes(this);
 76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s return #%u",
 77391:               InferSpewColor(returnTypes), returnTypes, InferSpewColorReset(),
 77391:               id());
 77391:     TypeSet *thisTypes = TypeScript::ThisTypes(this);
 76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s this #%u",
 77391:               InferSpewColor(thisTypes), thisTypes, InferSpewColorReset(),
 77391:               id());
 83256:     unsigned nargs = function() ? function()->nargs : 0;
 77391:     for (unsigned i = 0; i < nargs; i++) {
 77391:         TypeSet *types = TypeScript::ArgTypes(this, i);
 76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s arg%u #%u",
 77391:                   InferSpewColor(types), types, InferSpewColorReset(),
 77391:                   i, id());
 77391:     }
 77391:     for (unsigned i = 0; i < nfixed; i++) {
 77391:         TypeSet *types = TypeScript::LocalTypes(this, i);
 76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s local%u #%u",
 77391:                   InferSpewColor(types), types, InferSpewColorReset(),
 77391:                   i, id());
 77391:     }
 75718: #endif
 75718: 
 75718:     return true;
 75718: }
 75718: 
 75742: bool
 77391: JSScript::makeAnalysis(JSContext *cx)
 77391: {
 77391:     JS_ASSERT(types && !types->analysis);
 77391: 
 77391:     AutoEnterAnalysis enter(cx);
 77391: 
 79410:     types->analysis = cx->typeLifoAlloc().new_<ScriptAnalysis>(this);
 77391: 
 77391:     if (!types->analysis)
 77391:         return false;
 77391: 
 99421:     Rooted<JSScript*> self(cx, this);
 95355: 
 77391:     types->analysis->analyzeBytecode(cx);
 77391: 
 95355:     if (self->types->analysis->OOM()) {
 95355:         self->types->analysis = NULL;
 77391:         return false;
 77391:     }
 77391: 
 77391:     return true;
 77391: }
 77391: 
 77391: bool
 77353: JSScript::typeSetFunction(JSContext *cx, JSFunction *fun, bool singleton)
 75742: {
 83256:     function_ = fun;
 75843: 
 75843:     if (!cx->typeInferenceEnabled())
 75843:         return true;
 75742: 
 77353:     if (singleton) {
 77353:         if (!fun->setSingletonType(cx))
 77353:             return false;
 77353:     } else {
 77461:         TypeObject *type = cx->compartment->types.newTypeObject(cx, this,
 76179:                                                                 JSProto_Function, fun->getProto());
 75742:         if (!type)
 75742:             return false;
 77353: 
 77353:         fun->setType(type);
 77884:         type->interpretedFunction = fun;
 77353:     }
 77353: 
 75742:     return true;
 75742: }
 75742: 
 75739: #ifdef DEBUG
 75739: 
 77391: /* static */ void
 77391: TypeScript::CheckBytecode(JSContext *cx, JSScript *script, jsbytecode *pc, const js::Value *sp)
 75708: {
 75987:     AutoEnterTypeInference enter(cx);
 76158: 
 77357:     if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77357:         return;
 77357: 
 77391:     if (!script->hasAnalysis() || !script->analysis()->ranInference())
 75708:         return;
 77391:     ScriptAnalysis *analysis = script->analysis();
 77391: 
 77391:     int defCount = GetDefCount(script, pc - script->code);
 75708: 
 75708:     for (int i = 0; i < defCount; i++) {
 75708:         const js::Value &val = sp[-defCount + i];
 76158:         TypeSet *types = analysis->pushedTypes(pc, i);
 76020:         if (IgnorePushed(pc, i))
 75708:             continue;
 75708: 
 77353:         Type type = GetValueType(cx, val);
 77353: 
 77353:         if (!types->hasType(type)) {
 76150:             /* Display fine-grained debug information first */
 76150:             fprintf(stderr, "Missing type at #%u:%05u pushed %u: %s\n",
 77391:                     script->id(), unsigned(pc - script->code), i, TypeString(type));
 76150:             TypeFailure(cx, "Missing type pushed %u: %s", i, TypeString(type));
 75987:         }
 75708:     }
 75708: }
 75720: 
 75739: #endif
 75739: 
 75720: /////////////////////////////////////////////////////////////////////
 75720: // JSObject
 75720: /////////////////////////////////////////////////////////////////////
 75720: 
 77353: bool
 77353: JSObject::shouldSplicePrototype(JSContext *cx)
 77353: {
 77353:     /*
 77353:      * During bootstrapping, if inference is enabled we need to make sure not
 77353:      * to splice a new prototype in for Function.prototype or the global
 77353:      * object if their __proto__ had previously been set to null, as this
 77353:      * will change the prototype for all other objects with the same type.
 77353:      * If inference is disabled we cannot determine from the object whether it
 77353:      * has had its __proto__ set after creation.
 77353:      */
 77353:     if (getProto() != NULL)
 77353:         return false;
 77353:     return !cx->typeInferenceEnabled() || hasSingletonType();
 77353: }
 77353: 
 77353: bool
 77353: JSObject::splicePrototype(JSContext *cx, JSObject *proto)
 77353: {
 77353:     /*
 77353:      * For singleton types representing only a single JSObject, the proto
 77353:      * can be rearranged as needed without destroying type information for
 77353:      * the old or new types. Note that type constraints propagating properties
 77353:      * from the old prototype are not removed.
 77353:      */
 77353:     JS_ASSERT_IF(cx->typeInferenceEnabled(), hasSingletonType());
 77353: 
 89336:     /* Inner objects may not appear on prototype chains. */
 89336:     JS_ASSERT_IF(proto, !proto->getClass()->ext.outerObject);
 89336: 
 77353:     /*
 77353:      * Force type instantiation when splicing lazy types. This may fail,
 77353:      * in which case inference will be disabled for the compartment.
 77353:      */
 77408:     TypeObject *type = getType(cx);
 77408:     TypeObject *protoType = NULL;
 77361:     if (proto) {
 77408:         protoType = proto->getType(cx);
 77361:         if (!proto->getNewType(cx))
 77361:             return false;
 77361:     }
 77353: 
 77353:     if (!cx->typeInferenceEnabled()) {
 83230:         TypeObject *type = proto ? proto->getNewType(cx) : cx->compartment->getEmptyType(cx);
 77353:         if (!type)
 77353:             return false;
 77353:         type_ = type;
 77353:         return true;
 77353:     }
 77353: 
 77408:     type->proto = proto;
 77353: 
 77353:     AutoEnterTypeInference enter(cx);
 77353: 
 77408:     if (protoType && protoType->unknownProperties() && !type->unknownProperties()) {
 77408:         type->markUnknown(cx);
 77353:         return true;
 77353:     }
 77353: 
 77408:     if (!type->unknownProperties()) {
 77353:         /* Update properties on this type with any shared with the prototype. */
 77408:         unsigned count = type->getPropertyCount();
 77353:         for (unsigned i = 0; i < count; i++) {
 77408:             Property *prop = type->getProperty(i);
 77361:             if (prop && prop->types.hasPropagatedProperty())
 77408:                 type->getFromPrototypes(cx, prop->id, &prop->types, true);
 77361:         }
 77353:     }
 77353: 
 77353:     return true;
 77353: }
 77353: 
 75720: void
 77353: JSObject::makeLazyType(JSContext *cx)
 77353: {
 95087:     JS_ASSERT(hasLazyType());
 77353: 
 77461:     TypeObject *type = cx->compartment->types.newTypeObject(cx, NULL,
 77353:                                                             JSProto_Object, getProto());
 77353:     if (!type) {
 95087:         if (cx->typeInferenceEnabled())
 77353:             cx->compartment->types.setPendingNukeTypes(cx);
 77353:         return;
 77353:     }
 77353: 
 95087:     if (!cx->typeInferenceEnabled()) {
 95087:         /* This can only happen if types were previously nuked. */
 95087:         type_ = type;
 95087:         return;
 95087:     }
 95087: 
 95087:     AutoEnterTypeInference enter(cx);
 95087: 
 77353:     /* Fill in the type according to the state of this object. */
 77353: 
 77353:     type->singleton = this;
 77353: 
 83234:     if (isFunction() && toFunction()->isInterpreted()) {
 83234:         type->interpretedFunction = toFunction();
 77884:         JSScript *script = type->interpretedFunction->script();
 77884:         if (script->uninlineable)
 77361:             type->flags |= OBJECT_FLAG_UNINLINEABLE;
 77884:         if (script->reentrantOuterFunction)
 77884:             type->flags |= OBJECT_FLAG_REENTRANT_FUNCTION;
 77361:     }
 77353: 
 83248:     if (lastProperty()->hasObjectFlag(BaseShape::ITERATED_SINGLETON))
 77386:         type->flags |= OBJECT_FLAG_ITERATED;
 77386: 
 77353: #if JS_HAS_XML_SUPPORT
 77353:     /*
 77353:      * XML objects do not have equality hooks but are treated special by EQ/NE
 77353:      * ops. Just mark the type as totally unknown.
 77353:      */
 77353:     if (isXML() && !type->unknownProperties())
 77353:         type->markUnknown(cx);
 77353: #endif
 77353: 
 83222:     if (getClass()->ext.equality)
 77363:         type->flags |= OBJECT_FLAG_SPECIAL_EQUALITY;
 77363: 
 77353:     if (type->unknownProperties()) {
 77353:         type_ = type;
 77353:         return;
 77353:     }
 77353: 
 77353:     /* Not yet generating singleton arrays. */
 77353:     type->flags |= OBJECT_FLAG_NON_DENSE_ARRAY
 77353:                 |  OBJECT_FLAG_NON_PACKED_ARRAY
 77353:                 |  OBJECT_FLAG_NON_TYPED_ARRAY;
 77353: 
 77353:     type_ = type;
 79681: }
 79681: 
 83230: /* static */ inline HashNumber
 83297: TypeObjectEntry::hash(JSObject *proto)
 83230: {
 83230:     return PointerHasher<JSObject *, 3>::hash(proto);
 83230: }
 83230: 
 83230: /* static */ inline bool
 83297: TypeObjectEntry::match(TypeObject *key, JSObject *lookup)
 83230: {
 83230:     return key->proto == lookup;
 83230: }
 83230: 
 83230: #ifdef DEBUG
 83230: bool
 83230: JSObject::hasNewType(TypeObject *type)
 83230: {
 83297:     TypeObjectSet &table = compartment()->newTypeObjects;
 83230: 
 83230:     if (!table.initialized())
 83230:         return false;
 83230: 
 83297:     TypeObjectSet::Ptr p = table.lookup(this);
 83230:     return p && *p == type;
 83230: }
 83230: #endif /* DEBUG */
 83230: 
 83286: bool
 83286: JSObject::setNewTypeUnknown(JSContext *cx)
 83286: {
 83286:     if (!setFlag(cx, js::BaseShape::NEW_TYPE_UNKNOWN))
 83286:         return false;
 83286: 
 83286:     /*
 83286:      * If the object already has a new type, mark that type as unknown. It will
 83286:      * not have the SETS_MARKED_UNKNOWN bit set, so may require a type set
 83286:      * crawl if prototypes of the object change dynamically in the future.
 83286:      */
 83302:     TypeObjectSet &table = cx->compartment->newTypeObjects;
 83286:     if (table.initialized()) {
 83312:         if (TypeObjectSet::Ptr p = table.lookup(this))
 83286:             MarkTypeObjectUnknownProperties(cx, *p);
 83286:     }
 83286: 
 83286:     return true;
 83286: }
 83286: 
 83230: TypeObject *
 83286: JSObject::getNewType(JSContext *cx, JSFunction *fun)
 83230: {
 83297:     TypeObjectSet &table = cx->compartment->newTypeObjects;
 83230: 
 83230:     if (!table.initialized() && !table.init())
 83230:         return NULL;
 83230: 
 83297:     TypeObjectSet::AddPtr p = table.lookupForAdd(this);
 83230:     if (p) {
 83230:         TypeObject *type = *p;
 83230: 
 83230:         /*
 83230:          * If set, the type's newScript indicates the script used to create
 83230:          * all objects in existence which have this type. If there are objects
 83230:          * in existence which are not created by calling 'new' on newScript,
 83230:          * we must clear the new script information from the type and will not
 83230:          * be able to assume any definite properties for instances of the type.
 83230:          * This case is rare, but can happen if, for example, two scripted
 83230:          * functions have the same value for their 'prototype' property, or if
 83230:          * Object.create is called with a prototype object that is also the
 83230:          * 'prototype' property of some scripted function.
 83230:          */
 83230:         if (type->newScript && type->newScript->fun != fun)
 83230:             type->clearNewScript(cx);
 83230: 
 83230:         return type;
 83230:     }
 81205: 
 99421:     RootedObject self(cx, this);
 86437: 
 86437:     if (!setDelegate(cx))
 86437:         return NULL;
 86437: 
 86437:     bool markUnknown = self->lastProperty()->hasObjectFlag(BaseShape::NEW_TYPE_UNKNOWN);
 75720: 
 99421:     RootedTypeObject type(cx);
 95355:     type = cx->compartment->types.newTypeObject(cx, NULL, JSProto_Object, self, markUnknown);
 75720:     if (!type)
 83230:         return NULL;
 83230: 
 95355:     if (!table.relookupOrAdd(p, self, type.raw()))
 83230:         return NULL;
 77392: 
 77392:     if (!cx->typeInferenceEnabled())
 83230:         return type;
 75948: 
 75987:     AutoEnterTypeInference enter(cx);
 75720: 
 77353:     /*
 77353:      * Set the special equality flag for types whose prototype also has the
 77353:      * flag set. This is a hack, :XXX: need a real correspondence between
 77353:      * types and the possible js::Class of objects with that type.
 77353:      */
 86437:     if (self->hasSpecialEquality())
 77353:         type->flags |= OBJECT_FLAG_SPECIAL_EQUALITY;
 75948: 
 77884:     if (fun)
 77884:         CheckNewScriptProperties(cx, type, fun);
 75720: 
 77353: #if JS_HAS_XML_SUPPORT
 77353:     /* Special case for XML object equality, see makeLazyType(). */
 86437:     if (self->isXML() && !type->unknownProperties())
 77361:         type->flags |= OBJECT_FLAG_UNKNOWN_MASK;
 77353: #endif
 77353: 
 86437:     if (self->getClass()->ext.equality)
 77363:         type->flags |= OBJECT_FLAG_SPECIAL_EQUALITY;
 77363: 
 77353:     /*
 77353:      * The new type is not present in any type sets, so mark the object as
 77353:      * unknown in all type sets it appears in. This allows the prototype of
 77353:      * such objects to mutate freely without triggering an expensive walk of
 77353:      * the compartment's type sets. (While scripts normally don't mutate
 77353:      * __proto__, the browser will for proxies and such, and we need to
 77353:      * accommodate this behavior).
 77353:      */
 77353:     if (type->unknownProperties())
 77361:         type->flags |= OBJECT_FLAG_SETS_MARKED_UNKNOWN;
 83230: 
 83230:     return type;
 79681: }
 79681: 
 83249: TypeObject *
 83249: JSCompartment::getLazyType(JSContext *cx, JSObject *proto)
 83249: {
 97353:     MaybeCheckStackRoots(cx);
 86437: 
 83297:     TypeObjectSet &table = cx->compartment->lazyTypeObjects;
 83249: 
 83249:     if (!table.initialized() && !table.init())
 83249:         return NULL;
 83249: 
 83297:     TypeObjectSet::AddPtr p = table.lookupForAdd(proto);
 83249:     if (p) {
 83249:         TypeObject *type = *p;
 83249:         JS_ASSERT(type->lazy());
 83302: 
 83249:         return type;
 83249:     }
 83249: 
 83249:     TypeObject *type = cx->compartment->types.newTypeObject(cx, NULL,
 83249:                                                             JSProto_Object, proto, false);
 83249:     if (!type)
 83249:         return NULL;
 83249: 
 83249:     if (!table.relookupOrAdd(p, proto, type))
 83249:         return NULL;
 83249: 
 83249:     type->singleton = (JSObject *) TypeObject::LAZY_SINGLETON;
 83249: 
 83249:     return type;
 75720: }
 75720: 
 75720: /////////////////////////////////////////////////////////////////////
 75720: // Tracing
 75720: /////////////////////////////////////////////////////////////////////
 75720: 
 77361: void
 94740: TypeSet::sweep(JSCompartment *compartment)
 77353: {
 77439:     /*
 77439:      * Purge references to type objects that are no longer live. Type sets hold
 77439:      * only weak references. For type sets containing more than one object,
 77439:      * live entries in the object hash need to be copied to the compartment's
 77439:      * new arena.
 77439:      */
 77439:     unsigned objectCount = baseObjectCount();
 77353:     if (objectCount >= 2) {
 77439:         unsigned oldCapacity = HashSetCapacity(objectCount);
 77353:         TypeObjectKey **oldArray = objectSet;
 77439: 
 77439:         clearObjects();
 77353:         objectCount = 0;
 77439:         for (unsigned i = 0; i < oldCapacity; i++) {
 77353:             TypeObjectKey *object = oldArray[i];
 89658:             if (object && !IsAboutToBeFinalized(object)) {
 77353:                 TypeObjectKey **pentry =
 77353:                     HashSetInsert<TypeObjectKey *,TypeObjectKey,TypeObjectKey>
 77439:                         (compartment, objectSet, objectCount, object);
 77361:                 if (pentry)
 75720:                     *pentry = object;
 77361:                 else
 94740:                     compartment->types.setPendingNukeTypesNoReport();
 77361:             }
 77361:         }
 77361:         setBaseObjectCount(objectCount);
 77353:     } else if (objectCount == 1) {
 77353:         TypeObjectKey *object = (TypeObjectKey *) objectSet;
 89658:         if (IsAboutToBeFinalized(object)) {
 77353:             objectSet = NULL;
 77368:             setBaseObjectCount(0);
 77353:         }
 77353:     }
 77353: 
 77372:     /*
 77372:      * All constraints are wiped out on each GC, including those propagating
 77372:      * into this type set from prototype properties.
 77372:      */
 77353:     constraintList = NULL;
 77372:     flags &= ~TYPE_FLAG_PROPAGATED_PROPERTY;
 77361: }
 77361: 
 77361: inline void
 77361: TypeObject::clearProperties()
 77361: {
 77361:     setBasePropertyCount(0);
 77361:     propertySet = NULL;
 77361: }
 77361: 
 75720: /*
 77361:  * Before sweeping the arenas themselves, scan all type objects in a
 77361:  * compartment to fixup weak references: property type sets referencing dead
 77361:  * JS and type objects, and singleton JS objects whose type is not referenced
 77361:  * elsewhere. This also releases memory associated with dead type objects,
 77361:  * so that type objects do not need later finalization.
 75720:  */
 77439: inline void
 94740: TypeObject::sweep(FreeOp *fop)
 75760: {
 75736:     /*
 77361:      * We may be regenerating existing type sets containing this object,
 77361:      * so reset contributions on each GC to avoid tripping the limit.
 75736:      */
 77439:     contribution = 0;
 77439: 
 77439:     if (singleton) {
 77439:         JS_ASSERT(!newScript);
 77361: 
 77361:         /*
 77439:          * All properties can be discarded. We will regenerate them as needed
 77439:          * as code gets reanalyzed.
 77361:          */
 77439:         clearProperties();
 77439: 
 82079:         return;
 82079:     }
 82079: 
 77439:     if (!isMarked()) {
 77439:         if (newScript)
 94740:             fop->free_(newScript);
 77361:         return;
 77361:     }
 75736: 
 77439:     JSCompartment *compartment = this->compartment();
 77439: 
 77439:     /*
 77439:      * Properties were allocated from the old arena, and need to be copied over
 77439:      * to the new one. Don't hang onto properties without the OWN_PROPERTY
 77439:      * flag; these were never directly assigned, and get any possible values
 77439:      * from the object's prototype.
 77439:      */
 77439:     unsigned propertyCount = basePropertyCount();
 77439:     if (propertyCount >= 2) {
 77439:         unsigned oldCapacity = HashSetCapacity(propertyCount);
 77439:         Property **oldArray = propertySet;
 77439: 
 77439:         clearProperties();
 77439:         propertyCount = 0;
 77439:         for (unsigned i = 0; i < oldCapacity; i++) {
 77439:             Property *prop = oldArray[i];
 77439:             if (prop && prop->types.isOwnProperty(false)) {
 79410:                 Property *newProp = compartment->typeLifoAlloc.new_<Property>(*prop);
 77439:                 if (newProp) {
 77439:                     Property **pentry =
 77439:                         HashSetInsert<jsid,Property,Property>
 77439:                             (compartment, propertySet, propertyCount, prop->id);
 77439:                     if (pentry) {
 77439:                         *pentry = newProp;
 94740:                         newProp->types.sweep(compartment);
 77439:                     } else {
 94740:                         compartment->types.setPendingNukeTypesNoReport();
 77439:                     }
 77439:                 } else {
 94740:                     compartment->types.setPendingNukeTypesNoReport();
 77439:                 }
 77439:             }
 77439:         }
 77439:         setBasePropertyCount(propertyCount);
 77439:     } else if (propertyCount == 1) {
 77439:         Property *prop = (Property *) propertySet;
 77439:         if (prop->types.isOwnProperty(false)) {
 79410:             Property *newProp = compartment->typeLifoAlloc.new_<Property>(*prop);
 77439:             if (newProp) {
 77439:                 propertySet = (Property **) newProp;
 94740:                 newProp->types.sweep(compartment);
 77439:             } else {
 94740:                 compartment->types.setPendingNukeTypesNoReport();
 77439:             }
 77439:         } else {
 77439:             propertySet = NULL;
 77439:             setBasePropertyCount(0);
 77439:         }
 77439:     }
 77439: 
 77439:     if (basePropertyCount() <= SET_ARRAY_SIZE) {
 77439:         for (unsigned i = 0; i < basePropertyCount(); i++)
 77439:             JS_ASSERT(propertySet[i]);
 77361:     }
 77361: 
 77361:     /*
 77361:      * The GC will clear out the constraints ensuring the correctness of the
 77361:      * newScript information, these constraints will need to be regenerated
 77361:      * the next time we compile code which depends on this info.
 77361:      */
 77439:     if (newScript)
 77439:         flags |= OBJECT_FLAG_NEW_SCRIPT_REGENERATE;
 77361: }
 77361: 
 77464: struct SweepTypeObjectOp
 77464: {
 94740:     FreeOp *fop;
 94740:     SweepTypeObjectOp(FreeOp *fop) : fop(fop) {}
 77464:     void operator()(gc::Cell *cell) {
 77464:         TypeObject *object = static_cast<TypeObject *>(cell);
 94740:         object->sweep(fop);
 77464:     }
 77464: };
 77464: 
 77361: void
 94740: SweepTypeObjects(FreeOp *fop, JSCompartment *compartment)
 94740: {
 94740:     SweepTypeObjectOp op(fop);
 77464:     gc::ForEachArenaAndCell(compartment, gc::FINALIZE_TYPE_OBJECT, gc::EmptyArenaOp, op);
 76092: }
 76092: 
 77353: void
 94740: TypeCompartment::sweep(FreeOp *fop)
 77353: {
 77361:     JSCompartment *compartment = this->compartment();
 77361: 
 94740:     SweepTypeObjects(fop, compartment);
 77353: 
 77353:     /*
 77353:      * Iterate through the array/object type tables and remove all entries
 77353:      * referencing collected data. These tables only hold weak references.
 77353:      */
 77353: 
 77353:     if (arrayTypeTable) {
 77353:         for (ArrayTypeTable::Enum e(*arrayTypeTable); !e.empty(); e.popFront()) {
 77353:             const ArrayTableKey &key = e.front().key;
 77353:             TypeObject *obj = e.front().value;
 77353:             JS_ASSERT(obj->proto == key.proto);
 77353:             JS_ASSERT(!key.type.isSingleObject());
 77353: 
 77353:             bool remove = false;
 77361:             if (key.type.isTypeObject() && !key.type.typeObject()->isMarked())
 77353:                 remove = true;
 77361:             if (!obj->isMarked())
 77353:                 remove = true;
 77353: 
 77353:             if (remove)
 77353:                 e.removeFront();
 77353:         }
 77353:     }
 77353: 
 77353:     if (objectTypeTable) {
 77353:         for (ObjectTypeTable::Enum e(*objectTypeTable); !e.empty(); e.popFront()) {
 77353:             const ObjectTableKey &key = e.front().key;
 99246:             ObjectTableEntry &entry = e.front().value;
 77353:             JS_ASSERT(entry.object->proto == key.proto);
 77353: 
 77353:             bool remove = false;
 99246:             if (!IsTypeObjectMarked(entry.object.unsafeGet()))
 77353:                 remove = true;
 77353:             for (unsigned i = 0; !remove && i < key.nslots; i++) {
 77353:                 if (JSID_IS_STRING(key.ids[i])) {
 77353:                     JSString *str = JSID_TO_STRING(key.ids[i]);
 99246:                     if (!IsStringMarked(&str))
 77353:                         remove = true;
 99246:                     JS_ASSERT(AtomToId((JSAtom *)str) == key.ids[i]);
 77353:                 }
 77353:                 JS_ASSERT(!entry.types[i].isSingleObject());
 77361:                 if (entry.types[i].isTypeObject() && !entry.types[i].typeObject()->isMarked())
 77353:                     remove = true;
 77353:             }
 77353: 
 77353:             if (remove) {
 77353:                 Foreground::free_(key.ids);
 77353:                 Foreground::free_(entry.types);
 77353:                 e.removeFront();
 77353:             }
 77353:         }
 77353:     }
 77361: 
 77361:     if (allocationSiteTable) {
 77361:         for (AllocationSiteTable::Enum e(*allocationSiteTable); !e.empty(); e.popFront()) {
 99246:             AllocationSiteKey key = e.front().key;
 99246:             bool keyMarked = IsScriptMarked(&key.script);
 99246:             bool valMarked = IsTypeObjectMarked(e.front().value.unsafeGet());
 99246:             if (!keyMarked || !valMarked)
 77361:                 e.removeFront();
 99246:             else
 99246:                 e.rekeyFront(key);
 77361:         }
 77361:     }
 77439: 
 77439:     /*
 77439:      * The pending array is reset on GC, it can grow large (75+ KB) and is easy
 77439:      * to reallocate if the compartment becomes active again.
 77439:      */
 77439:     if (pendingArray)
 94740:         fop->free_(pendingArray);
 77439: 
 77439:     pendingArray = NULL;
 77439:     pendingCapacity = 0;
 75760: }
 75760: 
 83230: void
 94738: JSCompartment::sweepNewTypeObjectTable(TypeObjectSet &table)
 83249: {
 83249:     if (table.initialized()) {
 83297:         for (TypeObjectSet::Enum e(table); !e.empty(); e.popFront()) {
 83230:             TypeObject *type = e.front();
 83230:             if (!type->isMarked())
 83230:                 e.removeFront();
 83230:         }
 83230:     }
 83230: }
 83230: 
 75771: TypeCompartment::~TypeCompartment()
 75771: {
 75771:     if (pendingArray)
 75901:         Foreground::free_(pendingArray);
 75771: 
 75771:     if (arrayTypeTable)
 75901:         Foreground::delete_(arrayTypeTable);
 75771: 
 75771:     if (objectTypeTable)
 75901:         Foreground::delete_(objectTypeTable);
 77361: 
 77361:     if (allocationSiteTable)
 77361:         Foreground::delete_(allocationSiteTable);
 75771: }
 75771: 
 77391: /* static */ void
 94740: TypeScript::Sweep(FreeOp *fop, JSScript *script)
 75720: {
 77659:     JSCompartment *compartment = script->compartment();
 77353:     JS_ASSERT(compartment->types.inferenceEnabled);
 77353: 
 77391:     unsigned num = NumTypeSets(script);
 77391:     TypeSet *typeArray = script->types->typeArray();
 77391: 
 77391:     /* Remove constraints and references to dead objects from the persistent type sets. */
 77361:     for (unsigned i = 0; i < num; i++)
 94740:         typeArray[i].sweep(compartment);
 77391: 
 77391:     TypeResult **presult = &script->types->dynamicList;
 75836:     while (*presult) {
 77361:         TypeResult *result = *presult;
 77361:         Type type = result->type;
 77361: 
 77361:         if (!type.isUnknown() && !type.isAnyObject() && type.isObject() &&
 99246:             IsAboutToBeFinalized(type.objectKey()))
 99246:         {
 75836:             *presult = result->next;
 94740:             fop->delete_(result);
 77361:         } else {
 77361:             presult = &result->next;
 76059:         }
 75836:     }
 76092: 
 77353:     /*
 77884:      * If the script has nesting state with a most recent activation, we do not
 77884:      * need either to mark the call object or clear it if not live. Even with
 77884:      * a dead pointer in the nesting, we can't get a spurious match while
 77884:      * testing for reentrancy: if previous activations are still live, they
 77884:      * cannot alias the most recent one, and future activations will overwrite
 77884:      * activeCall on creation.
 77884:      */
 75720: }
 75720: 
 75720: void
 77353: TypeScript::destroy()
 76158: {
 77361:     while (dynamicList) {
 77361:         TypeResult *next = dynamicList->next;
 77361:         Foreground::delete_(dynamicList);
 77361:         dynamicList = next;
 76158:     }
 77439: 
 77884:     if (nesting)
 77884:         Foreground::delete_(nesting);
 77884: 
 77439:     Foreground::free_(this);
 77439: }
 77439: 
 77439: inline size_t
 88579: TypeSet::computedSizeOfExcludingThis()
 76203: {
 81205:     /*
 81205:      * This memory is allocated within the temp pool (but accounted for
 82849:      * elsewhere) so we can't use a JSMallocSizeOfFun to measure it.  We must
 88579:      * compute its size analytically.
 81205:      */
 84755:     uint32_t count = baseObjectCount();
 77361:     if (count >= 2)
 77361:         return HashSetCapacity(count) * sizeof(TypeObject *);
 77361:     return 0;
 76203: }
 76203: 
 77439: inline size_t
 88579: TypeObject::computedSizeOfExcludingThis()
 77439: {
 81205:     /*
 81205:      * This memory is allocated within the temp pool (but accounted for
 82849:      * elsewhere) so we can't use a JSMallocSizeOfFun to measure it.  We must
 88579:      * compute its size analytically.
 81205:      */
 77439:     size_t bytes = 0;
 77439: 
 84755:     uint32_t count = basePropertyCount();
 77439:     if (count >= 2)
 77439:         bytes += HashSetCapacity(count) * sizeof(TypeObject *);
 77439: 
 77439:     count = getPropertyCount();
 77439:     for (unsigned i = 0; i < count; i++) {
 77439:         Property *prop = getProperty(i);
 77439:         if (prop)
 88579:             bytes += sizeof(Property) + prop->types.computedSizeOfExcludingThis();
 77439:     }
 77439: 
 77439:     return bytes;
 77439: }
 77439: 
 76203: static void
 88579: SizeOfScriptTypeInferenceData(JSScript *script, TypeInferenceSizes *sizes,
 88579:                               JSMallocSizeOfFun mallocSizeOf)
 81205: {
 81205:     TypeScript *typeScript = script->types;
 81205:     if (!typeScript)
 77361:         return;
 77361: 
 81205:     /* If TI is disabled, a single TypeScript is still present. */
 77659:     if (!script->compartment()->types.inferenceEnabled) {
 88579:         sizes->scripts += mallocSizeOf(typeScript);
 77395:         return;
 77395:     }
 77395: 
 88579:     sizes->scripts += mallocSizeOf(typeScript->nesting);
 81205: 
 77391:     unsigned count = TypeScript::NumTypeSets(script);
 88579:     sizes->scripts += mallocSizeOf(typeScript);
 81205: 
 81205:     TypeResult *result = typeScript->dynamicList;
 77361:     while (result) {
 88579:         sizes->scripts += mallocSizeOf(result);
 77361:         result = result->next;
 77361:     }
 77439: 
 81205:     /*
 81205:      * This counts memory that is in the temp pool but gets attributed
 86104:      * elsewhere.  See JS::SizeOfCompartmentTypeInferenceData for more details.
 81205:      */
 81205:     TypeSet *typeArray = typeScript->typeArray();
 77439:     for (unsigned i = 0; i < count; i++) {
 88579:         size_t bytes = typeArray[i].computedSizeOfExcludingThis();
 88579:         sizes->scripts += bytes;
 88579:         sizes->temporary -= bytes;
 77439:     }
 77361: }
 77361: 
 88146: void
 91287: JSCompartment::sizeOfTypeInferenceData(TypeInferenceSizes *sizes, JSMallocSizeOfFun mallocSizeOf)
 77361: {
 77439:     /*
 77439:      * Note: not all data in the pool is temporary, and some will survive GCs
 81205:      * by being copied to the replacement pool. This memory will be counted
 81205:      * elsewhere and deducted from the amount of temporary data.
 77439:      */
 88579:     sizes->temporary += typeLifoAlloc.sizeOfExcludingThis(mallocSizeOf);
 77439: 
 77439:     /* Pending arrays are cleared on GC along with the analysis pool. */
 88579:     sizes->temporary += mallocSizeOf(types.pendingArray);
 81205: 
 81205:     /* TypeCompartment::pendingRecompiles is non-NULL only while inference code is running. */
 88579:     JS_ASSERT(!types.pendingRecompiles);
 88579: 
 91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next())
 88579:         SizeOfScriptTypeInferenceData(i.get<JSScript>(), sizes, mallocSizeOf);
 88579: 
 88579:     if (types.allocationSiteTable)
 88579:         sizes->tables += types.allocationSiteTable->sizeOfIncludingThis(mallocSizeOf);
 88579: 
 88579:     if (types.arrayTypeTable)
 88579:         sizes->tables += types.arrayTypeTable->sizeOfIncludingThis(mallocSizeOf);
 88579: 
 88579:     if (types.objectTypeTable) {
 88579:         sizes->tables += types.objectTypeTable->sizeOfIncludingThis(mallocSizeOf);
 88579: 
 88579:         for (ObjectTypeTable::Enum e(*types.objectTypeTable);
 77439:              !e.empty();
 81205:              e.popFront())
 81205:         {
 77439:             const ObjectTableKey &key = e.front().key;
 81205:             const ObjectTableEntry &value = e.front().value;
 81205: 
 81205:             /* key.ids and values.types have the same length. */
 88579:             sizes->tables += mallocSizeOf(key.ids) + mallocSizeOf(value.types);
 77439:         }
 77439:     }
 77404: }
 77404: 
 88146: void
 88579: TypeObject::sizeOfExcludingThis(TypeInferenceSizes *sizes, JSMallocSizeOfFun mallocSizeOf)
 88579: {
 88579:     if (singleton) {
 77361:         /*
 77439:          * Properties and associated type sets for singletons are cleared on
 77439:          * every GC. The type object is normally destroyed too, but we don't
 77439:          * charge this to 'temporary' as this is not for GC heap values.
 77361:          */
 88579:         JS_ASSERT(!newScript);
 77361:         return;
 77361:     }
 77361: 
 88579:     sizes->objects += mallocSizeOf(newScript);
 81205: 
 81205:     /*
 81205:      * This counts memory that is in the temp pool but gets attributed
 88579:      * elsewhere.  See JSCompartment::sizeOfTypeInferenceData for more details.
 81205:      */
 88579:     size_t bytes = computedSizeOfExcludingThis();
 88579:     sizes->objects += bytes;
 88579:     sizes->temporary -= bytes;
 88579: }
