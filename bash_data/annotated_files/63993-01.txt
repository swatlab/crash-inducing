38688: /* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
38688: /* ***** BEGIN LICENSE BLOCK *****
38688:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38688:  *
38688:  * The contents of this file are subject to the Mozilla Public License Version
38688:  * 1.1 (the "License"); you may not use this file except in compliance with
38688:  * the License. You may obtain a copy of the License at
38688:  * http://www.mozilla.org/MPL/
38688:  *
38688:  * Software distributed under the License is distributed on an "AS IS" basis,
38688:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38688:  * for the specific language governing rights and limitations under the
38688:  * License.
38688:  *
38688:  * The Original Code is mozilla.org code.
38688:  *
38688:  * The Initial Developer of the Original Code is
38688:  * the Mozilla Foundation <http://www.mozilla.org/>
38688:  * Portions created by the Initial Developer are Copyright (C) 2010
38688:  * the Initial Developer. All Rights Reserved.
38688:  *
38688:  * Contributor(s):
38688:  *   Karl Tomlinson <karlt+@karlt.net>
38688:  *
38688:  * Alternatively, the contents of this file may be used under the terms of
38688:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38688:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38688:  * in which case the provisions of the GPL or the LGPL are applicable instead
38688:  * of those above. If you wish to allow use of your version of this file only
38688:  * under the terms of either the GPL or the LGPL, and not to allow others to
38688:  * use your version of this file under the terms of the MPL, indicate your
38688:  * decision by deleting the provisions above and replace them with the notice
38688:  * and other provisions required by the GPL or the LGPL. If you do not delete
38688:  * the provisions above, a recipient may use your version of this file under
38688:  * the terms of any one of the MPL, the GPL or the LGPL.
38688:  *
38688:  * ***** END LICENSE BLOCK ***** */
38688: 
38688: #include "nsX11ErrorHandler.h"
38688: 
38688: #ifdef MOZ_IPC
42302: #include "mozilla/plugins/PluginProcessChild.h"
42302: using mozilla::plugins::PluginProcessChild;
38688: #endif
38688: 
38688: #include "prenv.h"
38688: #include "nsXULAppAPI.h"
38688: #include "nsExceptionHandler.h"
38688: #include "nsDebug.h"
38688: 
43912: #include "mozilla/X11Util.h"
39506: #include <X11/Xlib.h>
38688: 
38688: #define BUFSIZE 2048 // What Xlib uses with XGetErrorDatabaseText
38688: 
38688: extern "C" {
38688: static int
38688: X11Error(Display *display, XErrorEvent *event) {
38688:   nsCAutoString notes;
38688:   char buffer[BUFSIZE];
38688: 
38688:   // Get an indication of how long ago the request that caused the error was
63993:   // made.
38688:   unsigned long age = NextRequest(display) - event->serial;
38688: 
38688:   // Get a string to represent the request that caused the error.
38688:   nsCAutoString message;
38688:   if (event->request_code < 128) {
38688:     // Core protocol request
38688:     message.AppendInt(event->request_code);
38688:   } else {
38688:     // Extension request
63993: 
63993:     // man XSetErrorHandler says "the error handler should not call any
63993:     // functions (directly or indirectly) on the display that will generate
63993:     // protocol requests or that will look for input events" so we use another
63993:     // temporary Display to request extension information.  This assumes on
63993:     // the DISPLAY environment variable has been set and matches what was used
63993:     // to open |display|.
63993:     Display *tmpDisplay = XOpenDisplay(NULL);
63993:     if (tmpDisplay) {
38688:       int nExts;
63993:       char** extNames = XListExtensions(tmpDisplay, &nExts);
38688:       if (extNames) {
38688:         for (int i = 0; i < nExts; ++i) {
38688:           int major_opcode, first_event, first_error;
63993:           if (XQueryExtension(tmpDisplay, extNames[i],
38688:                               &major_opcode, &first_event, &first_error)
38688:               && major_opcode == event->request_code) {
38688:             message.Append(extNames[i]);
38688:             message.Append('.');
38688:             message.AppendInt(event->minor_code);
38688:             break;
38688:           }
38688:         }
38688: 
38688:         XFreeExtensionList(extNames);
38688:       }
63993:       XCloseDisplay(tmpDisplay);
63993:     }
38688:   }
38688: 
38688:   if (message.IsEmpty()) {
38688:     buffer[0] = '\0';
38688:   } else {
38688:     XGetErrorDatabaseText(display, "XRequest", message.get(), "",
38688:                           buffer, sizeof(buffer));
38688:   }
38688: 
38688:   if (buffer[0]) {
38688:     notes.Append(buffer);
38688:   } else {
38688:     notes.Append("Request ");
38688:     notes.AppendInt(event->request_code);
38688:     notes.Append('.');
38688:     notes.AppendInt(event->minor_code);
38688:   }
38688: 
38688:   notes.Append(": ");
38688: 
38688:   // Get a string to describe the error.
38688:   XGetErrorText(display, event->error_code, buffer, sizeof(buffer));
38688:   notes.Append(buffer);
38688: 
38688:   // For requests where Xlib gets the reply synchronously, |age| will be 1
38688:   // and the stack will include the function making the request.  For
38688:   // asynchronous requests, the current stack will often be unrelated to the
38688:   // point of making the request, even if |age| is 1, but sometimes this may
38688:   // help us count back to the point of the request.  With XSynchronize on,
38688:   // the stack will include the function making the request, even though
38688:   // |age| will be 2 for asynchronous requests because XSynchronize is
38688:   // implemented by an empty request from an XSync, which has not yet been
38688:   // processed.
38688:   if (age > 1) {
38688:     // XSynchronize returns the previous "after function".  If a second
38688:     // XSynchronize call returns the same function after an enable call then
38688:     // synchronization must have already been enabled.
38688:     if (XSynchronize(display, True) == XSynchronize(display, False)) {
38688:       notes.Append("; sync");
38688:     } else {
38688:       notes.Append("; ");
38689:       notes.AppendInt(PRUint32(age));
38688:       notes.Append(" requests ago");
38688:     }
38688:   }
38688: 
38688: #ifdef MOZ_CRASHREPORTER
38688:   switch (XRE_GetProcessType()) {
38688:   case GeckoProcessType_Default:
38688:     CrashReporter::AppendAppNotesToCrashReport(notes);
38688:     break;
38688: #ifdef MOZ_IPC
38688:   case GeckoProcessType_Plugin:
38688:     if (CrashReporter::GetEnabled()) {
38688:       // This is assuming that X operations are performed on the plugin
38688:       // thread.  If plugins are using X on another thread, then we'll need to
38688:       // handle that differently.
42302:       PluginProcessChild::AppendNotesToCrashReport(notes);
38688:     }
38688:     break;
38688: #endif
38688:   default: 
38688:     ; // crash report notes not supported.
38688:   }
38688: #endif
38688: 
38688: #ifdef DEBUG
38688:   // The resource id is unlikely to be useful in a crash report without
38688:   // context of other ids, but add it to the debug console output.
38688:   notes.Append("; id=0x");
38689:   notes.AppendInt(PRUint32(event->resourceid), 16);
39045: #ifdef MOZ_X11
38688:   // Actually, for requests where Xlib gets the reply synchronously,
38688:   // MOZ_X_SYNC=1 will not be necessary, but we don't have a table to tell us
38688:   // which requests get a synchronous reply.
38688:   if (!PR_GetEnv("MOZ_X_SYNC")) {
38688:     notes.Append("\nRe-running with MOZ_X_SYNC=1 in the environment may give a more helpful backtrace.");
38688:   }
38688: #endif
38688: #endif
38688: 
39841: #ifdef MOZ_WIDGET_QT
39841:   // We should not abort here if MOZ_X_SYNC is not set
39841:   // until http://bugreports.qt.nokia.com/browse/QTBUG-4042
39841:   // not fixed, just print error value
39841:   if (!PR_GetEnv("MOZ_X_SYNC")) {
39841:     fprintf(stderr, "XError: %s\n", notes.get());
39841:     return 0; // temporary workaround for bug 161472
39841:   }
39841: #endif
39841: 
38688:   NS_RUNTIMEABORT(notes.get());
38688:   return 0; // not reached
38688: }
38688: }
38688: 
38688: void
38688: InstallX11ErrorHandler()
38688: {
38688:   XSetErrorHandler(X11Error);
38688: 
43912:   Display *display = mozilla::DefaultXDisplay();
39045:   NS_ASSERTION(display, "No X display");
38688:   if (PR_GetEnv("MOZ_X_SYNC")) {
39045:     XSynchronize(display, True);
38688:   }
38688: }
