49073: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.org>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #include "ImageLayerD3D9.h"
42611: #include "gfxImageSurface.h"
42611: #include "yuv_convert.h"
51527: #include "nsIServiceManager.h" 
51527: #include "nsIConsoleService.h" 
51527: #include "nsPrintfCString.h" 
51527: #include "Nv3DVUtils.h"
42611: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
42611: using mozilla::MutexAutoLock;
42611: 
42611: ImageContainerD3D9::ImageContainerD3D9(LayerManagerD3D9 *aManager)
42611:   : ImageContainer(aManager)
42611:   , mActiveImageLock("mozilla.layers.ImageContainerD3D9.mActiveImageLock")
42611: {
42611: }
42611: 
42611: already_AddRefed<Image>
42611: ImageContainerD3D9::CreateImage(const Image::Format *aFormats,
42611:                                PRUint32 aNumFormats)
42611: {
42611:   if (!aNumFormats) {
42611:     return nsnull;
42611:   }
42611:   nsRefPtr<Image> img;
42611:   if (aFormats[0] == Image::PLANAR_YCBCR) {
42611:     img = new PlanarYCbCrImageD3D9(static_cast<LayerManagerD3D9*>(mManager));
42611:   } else if (aFormats[0] == Image::CAIRO_SURFACE) {
42611:     img = new CairoImageD3D9(static_cast<LayerManagerD3D9*>(mManager));
42611:   }
42611:   return img.forget();
42611: }
42611: 
42611: void
42611: ImageContainerD3D9::SetCurrentImage(Image *aImage)
42611: {
42611:   MutexAutoLock lock(mActiveImageLock);
42611: 
42611:   mActiveImage = aImage;
42611: }
42611: 
42611: already_AddRefed<Image>
42611: ImageContainerD3D9::GetCurrentImage()
42611: {
42611:   MutexAutoLock lock(mActiveImageLock);
42611: 
42611:   nsRefPtr<Image> retval = mActiveImage;
42611:   return retval.forget();
42611: }
42611: 
42611: already_AddRefed<gfxASurface>
42611: ImageContainerD3D9::GetCurrentAsSurface(gfxIntSize *aSize)
42611: {
42611:   MutexAutoLock lock(mActiveImageLock);
42611:   if (!mActiveImage) {
42611:     return nsnull;
42611:   }
42611: 
42611:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
42611:     PlanarYCbCrImageD3D9 *yuvImage =
42611:       static_cast<PlanarYCbCrImageD3D9*>(mActiveImage.get());
42611:     if (yuvImage->HasData()) {
42611:       *aSize = yuvImage->mSize;
42611:     }
42611:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
42611:     CairoImageD3D9 *cairoImage =
42611:       static_cast<CairoImageD3D9*>(mActiveImage.get());
57896:     *aSize = cairoImage->GetSize();
42611:   }
42611: 
42611:   return static_cast<ImageD3D9*>(mActiveImage->GetImplData())->GetAsSurface();
42611: }
42611: 
42611: gfxIntSize
42611: ImageContainerD3D9::GetCurrentSize()
42611: {
42611:   MutexAutoLock lock(mActiveImageLock);
42611:   if (!mActiveImage) {
42611:     return gfxIntSize(0,0);
42611:   }
42611:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
42611:     PlanarYCbCrImageD3D9 *yuvImage =
42611:       static_cast<PlanarYCbCrImageD3D9*>(mActiveImage.get());
42611:     if (!yuvImage->HasData()) {
42611:       return gfxIntSize(0,0);
42611:     }
42611:     return yuvImage->mSize;
42611: 
42611:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
42611:     CairoImageD3D9 *cairoImage =
42611:       static_cast<CairoImageD3D9*>(mActiveImage.get());
57896:     return cairoImage->GetSize();
42611:   }
42611: 
42611:   return gfxIntSize(0,0);
42611: }
42611: 
49073: PRBool
49073: ImageContainerD3D9::SetLayerManager(LayerManager *aManager)
49073: {
49073:   // we can't do anything here for now
49073:   return PR_FALSE;
49073: }
49073: 
42611: Layer*
42611: ImageLayerD3D9::GetLayer()
42611: {
42611:   return this;
42611: }
42611: 
42611: void
57097: ImageLayerD3D9::RenderLayer()
42611: {
42611:   if (!GetContainer()) {
42611:     return;
42611:   }
42611: 
42611:   nsRefPtr<Image> image = GetContainer()->GetCurrentImage();
42611: 
42611:   if (image->GetFormat() == Image::PLANAR_YCBCR) {
42611:     PlanarYCbCrImageD3D9 *yuvImage =
42611:       static_cast<PlanarYCbCrImageD3D9*>(image.get());
42611: 
42611:     if (!yuvImage->HasData()) {
42611:       return;
42611:     }
42611:     yuvImage->AllocateTextures();
42611: 
54880:     device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(0,
54880:                                                           0,
54880:                                                           yuvImage->mSize.width,
54880:                                                           yuvImage->mSize.height),
54880:                                        1);
42611: 
57097:     SetShaderTransformAndOpacity();
42611: 
49316:     mD3DManager->SetShaderMode(DeviceManagerD3D9::YCBCRLAYER);
42611: 
51527:     /* 
51527:      * Send 3d control data and metadata 
51527:      */ 
51527:     if (mD3DManager->Is3DEnabled() && mD3DManager->GetNv3DVUtils()) { 
51527:       mD3DManager->GetNv3DVUtils()->SendNv3DVControl(STEREO_MODE_RIGHT_LEFT, true, FIREFOX_3DV_APP_HANDLE); 
51527: 
51527:       nsRefPtr<IDirect3DSurface9> renderTarget; 
51527:       device()->GetRenderTarget(0, getter_AddRefs(renderTarget)); 
51527:       mD3DManager->GetNv3DVUtils()->SendNv3DVMetaData((unsigned int)yuvImage->mSize.width, 
51527:         (unsigned int)yuvImage->mSize.height, (HANDLE)(yuvImage->mYTexture), (HANDLE)(renderTarget)); 
51527:     } 
51527: 
42611:     device()->SetTexture(0, yuvImage->mYTexture);
42611:     device()->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
42611:     device()->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
42611:     device()->SetTexture(1, yuvImage->mCbTexture);
42611:     device()->SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
42611:     device()->SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
42611:     device()->SetTexture(2, yuvImage->mCrTexture);
42611:     device()->SetSamplerState(2, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
42611:     device()->SetSamplerState(2, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
42611: 
42611:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
42611: 
42611:   } else if (image->GetFormat() == Image::CAIRO_SURFACE) {
42611:     CairoImageD3D9 *cairoImage =
42611:       static_cast<CairoImageD3D9*>(image.get());
42611: 
42611: 
54880:     device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(0,
54880:                                                           0,
57896:                                                           cairoImage->GetSize().width,
57896:                                                           cairoImage->GetSize().height),
54880:                                        1);
42611: 
57097:     SetShaderTransformAndOpacity();
42611: 
51963:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
42611: 
57896:     device()->SetTexture(0, cairoImage->GetOrCreateTexture());
42611:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
42611:   }
42611: }
42611: 
42611: PlanarYCbCrImageD3D9::PlanarYCbCrImageD3D9(mozilla::layers::LayerManagerD3D9* aManager)
42611:   : PlanarYCbCrImage(static_cast<ImageD3D9*>(this))
42611:   , mManager(aManager)
42611:   , mHasData(PR_FALSE)
42611: {
42611: }
42611: 
42611: void
42611: PlanarYCbCrImageD3D9::SetData(const PlanarYCbCrImage::Data &aData)
42611: {
49317:   // XXX - For D3D9Ex we really should just copy to systemmem surfaces here.
42611:   // For now, we copy the data
42611:   int width_shift = 0;
42611:   int height_shift = 0;
42611:   if (aData.mYSize.width == aData.mCbCrSize.width &&
42611:       aData.mYSize.height == aData.mCbCrSize.height) {
42611:      // YV24 format
42611:      width_shift = 0;
42611:      height_shift = 0;
51961:      mType = gfx::YV24;
42611:   } else if (aData.mYSize.width / 2 == aData.mCbCrSize.width &&
42611:              aData.mYSize.height == aData.mCbCrSize.height) {
42611:     // YV16 format
42611:     width_shift = 1;
42611:     height_shift = 0;
51961:     mType = gfx::YV16;
42611:   } else if (aData.mYSize.width / 2 == aData.mCbCrSize.width &&
42611:              aData.mYSize.height / 2 == aData.mCbCrSize.height ) {
42611:       // YV12 format
42611:     width_shift = 1;
42611:     height_shift = 1;
51961:     mType = gfx::YV12;
42611:   } else {
42611:     NS_ERROR("YCbCr format not supported");
42611:   }
42611: 
42611:   mData = aData;
42611:   mData.mCbCrStride = mData.mCbCrSize.width = aData.mPicSize.width >> width_shift;
51961:   // Round up the values for width and height to make sure we sample enough data
51961:   // for the last pixel - See bug 590735
51961:   if (width_shift && (aData.mPicSize.width & 1)) {
51961:     mData.mCbCrStride++;
51961:     mData.mCbCrSize.width++;
51961:   }
42611:   mData.mCbCrSize.height = aData.mPicSize.height >> height_shift;
51961:   if (height_shift && (aData.mPicSize.height & 1)) {
51961:       mData.mCbCrSize.height++;
51961:   }
42611:   mData.mYSize = aData.mPicSize;
42611:   mData.mYStride = mData.mYSize.width;
42611: 
42611:   mBuffer = new PRUint8[mData.mCbCrStride * mData.mCbCrSize.height * 2 +
42611:                         mData.mYStride * mData.mYSize.height];
42611:   mData.mYChannel = mBuffer;
42611:   mData.mCbChannel = mData.mYChannel + mData.mYStride * mData.mYSize.height;
42611:   mData.mCrChannel = mData.mCbChannel + mData.mCbCrStride * mData.mCbCrSize.height;
42611: 
42611:   int cbcr_x = aData.mPicX >> width_shift;
42611:   int cbcr_y = aData.mPicY >> height_shift;
42611: 
42611:   for (int i = 0; i < mData.mYSize.height; i++) {
42611:     memcpy(mData.mYChannel + i * mData.mYStride,
42611:            aData.mYChannel + ((aData.mPicY + i) * aData.mYStride) + aData.mPicX,
42611:            mData.mYStride);
42611:   }
42611:   for (int i = 0; i < mData.mCbCrSize.height; i++) {
42611:     memcpy(mData.mCbChannel + i * mData.mCbCrStride,
42611:            aData.mCbChannel + ((cbcr_y + i) * aData.mCbCrStride) + cbcr_x,
42611:            mData.mCbCrStride);
42611:   }
42611:   for (int i = 0; i < mData.mCbCrSize.height; i++) {
42611:     memcpy(mData.mCrChannel + i * mData.mCbCrStride,
42611:            aData.mCrChannel + ((cbcr_y + i) * aData.mCbCrStride) + cbcr_x,
42611:            mData.mCbCrStride);
42611:   }
42611: 
42611:   // Fix picture rect to be correct
42611:   mData.mPicX = mData.mPicY = 0;
42611:   mSize = aData.mPicSize;
42611: 
42611:   mHasData = PR_TRUE;
42611: }
42611: 
42611: void
42611: PlanarYCbCrImageD3D9::AllocateTextures()
42611: {
42611: 
42611: 
49317:   D3DLOCKED_RECT lockrectY;
49317:   D3DLOCKED_RECT lockrectCb;
49317:   D3DLOCKED_RECT lockrectCr;
42611:   PRUint8* src;
42611:   PRUint8* dest;
49317: 
49317:   nsRefPtr<IDirect3DSurface9> tmpSurfaceY;
49317:   nsRefPtr<IDirect3DSurface9> tmpSurfaceCb;
49317:   nsRefPtr<IDirect3DSurface9> tmpSurfaceCr;
49317: 
49317:   if (mManager->deviceManager()->IsD3D9Ex()) {
49705:     nsRefPtr<IDirect3DTexture9> tmpYTexture;
49705:     nsRefPtr<IDirect3DTexture9> tmpCbTexture;
49705:     nsRefPtr<IDirect3DTexture9> tmpCrTexture;
49317:     // D3D9Ex does not support the managed pool, could use dynamic textures
49317:     // here. But since an Image is immutable static textures are probably a
49317:     // better idea.
49317:     mManager->device()->CreateTexture(mData.mYSize.width, mData.mYSize.height,
49317:                             1, 0, D3DFMT_L8, D3DPOOL_DEFAULT,
49317:                             getter_AddRefs(mYTexture), NULL);
49317:     mManager->device()->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                             1, 0, D3DFMT_L8, D3DPOOL_DEFAULT,
49317:                             getter_AddRefs(mCbTexture), NULL);
49317:     mManager->device()->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                             1, 0, D3DFMT_L8, D3DPOOL_DEFAULT,
49317:                             getter_AddRefs(mCrTexture), NULL);
49705:     mManager->device()->CreateTexture(mData.mYSize.width, mData.mYSize.height,
49705:                             1, 0, D3DFMT_L8, D3DPOOL_SYSTEMMEM,
49705:                             getter_AddRefs(tmpYTexture), NULL);
49705:     mManager->device()->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49705:                             1, 0, D3DFMT_L8, D3DPOOL_SYSTEMMEM,
49705:                             getter_AddRefs(tmpCbTexture), NULL);
49705:     mManager->device()->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49705:                             1, 0, D3DFMT_L8, D3DPOOL_SYSTEMMEM,
49705:                             getter_AddRefs(tmpCrTexture), NULL);
49705:     tmpYTexture->GetSurfaceLevel(0, getter_AddRefs(tmpSurfaceY));
49705:     tmpCbTexture->GetSurfaceLevel(0, getter_AddRefs(tmpSurfaceCb));
49705:     tmpCrTexture->GetSurfaceLevel(0, getter_AddRefs(tmpSurfaceCr));
49317:     tmpSurfaceY->LockRect(&lockrectY, NULL, 0);
49317:     tmpSurfaceCb->LockRect(&lockrectCb, NULL, 0);
49317:     tmpSurfaceCr->LockRect(&lockrectCr, NULL, 0);
49317:   } else {
42611:     mManager->device()->CreateTexture(mData.mYSize.width, mData.mYSize.height,
42611:                             1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
42611:                             getter_AddRefs(mYTexture), NULL);
49317:     mManager->device()->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                             1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
49317:                             getter_AddRefs(mCbTexture), NULL);
49317:     mManager->device()->CreateTexture(mData.mCbCrSize.width, mData.mCbCrSize.height,
49317:                             1, 0, D3DFMT_L8, D3DPOOL_MANAGED,
49317:                             getter_AddRefs(mCrTexture), NULL);
42611: 
42611:     /* lock the entire texture */
49317:     mYTexture->LockRect(0, &lockrectY, NULL, 0);
49317:     mCbTexture->LockRect(0, &lockrectCb, NULL, 0);
49317:     mCrTexture->LockRect(0, &lockrectCr, NULL, 0);
49317:   }
42611: 
42611:   src  = mData.mYChannel;
42611:   //FIX cast
49317:   dest = (PRUint8*)lockrectY.pBits;
42611: 
42611:   // copy over data
42611:   for (int h=0; h<mData.mYSize.height; h++) {
42611:     memcpy(dest, src, mData.mYSize.width);
49317:     dest += lockrectY.Pitch;
42611:     src += mData.mYStride;
42611:   }
42611: 
42611:   src  = mData.mCbChannel;
42611:   //FIX cast
49317:   dest = (PRUint8*)lockrectCb.pBits;
42611: 
42611:   // copy over data
42611:   for (int h=0; h<mData.mCbCrSize.height; h++) {
42611:     memcpy(dest, src, mData.mCbCrSize.width);
49317:     dest += lockrectCb.Pitch;
42611:     src += mData.mCbCrStride;
42611:   }
42611: 
42611:   src  = mData.mCrChannel;
42611:   //FIX cast
49317:   dest = (PRUint8*)lockrectCr.pBits;
42611: 
42611:   // copy over data
42611:   for (int h=0; h<mData.mCbCrSize.height; h++) {
42611:     memcpy(dest, src, mData.mCbCrSize.width);
49317:     dest += lockrectCr.Pitch;
42611:     src += mData.mCbCrStride;
42611:   }
42611: 
49317:   if (mManager->deviceManager()->IsD3D9Ex()) {
49317:     tmpSurfaceY->UnlockRect();
49317:     tmpSurfaceCb->UnlockRect();
49317:     tmpSurfaceCr->UnlockRect();
49317:     nsRefPtr<IDirect3DSurface9> dstSurface;
49317:     mYTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
49317:     mManager->device()->UpdateSurface(tmpSurfaceY, NULL, dstSurface, NULL);
49317:     mCbTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
49317:     mManager->device()->UpdateSurface(tmpSurfaceCb, NULL, dstSurface, NULL);
49317:     mCrTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
49317:     mManager->device()->UpdateSurface(tmpSurfaceCr, NULL, dstSurface, NULL);
49317:   } else {
49317:     mYTexture->UnlockRect(0);
49317:     mCbTexture->UnlockRect(0);
42611:     mCrTexture->UnlockRect(0);
49317:   }
42611: }
42611: 
42611: void
42611: PlanarYCbCrImageD3D9::FreeTextures()
42611: {
42611: }
42611: 
42611: already_AddRefed<gfxASurface>
42611: PlanarYCbCrImageD3D9::GetAsSurface()
42611: {
42611:   nsRefPtr<gfxImageSurface> imageSurface =
42611:     new gfxImageSurface(mSize, gfxASurface::ImageFormatRGB24);
42611: 
42611:   // Convert from YCbCr to RGB now
42611:   gfx::ConvertYCbCrToRGB32(mData.mYChannel,
42611:                            mData.mCbChannel,
42611:                            mData.mCrChannel,
42611:                            imageSurface->Data(),
42611:                            0,
42611:                            0,
42611:                            mSize.width,
42611:                            mSize.height,
42611:                            mData.mYStride,
42611:                            mData.mCbCrStride,
42611:                            imageSurface->Stride(),
51961:                            mType);
42611: 
42611:   return imageSurface.forget().get();
42611: }
42611: 
42611: CairoImageD3D9::~CairoImageD3D9()
42611: {
42611: }
42611: 
42611: void
42611: CairoImageD3D9::SetData(const CairoImage::Data &aData)
42611: {
42611:   mSize = aData.mSize;
57896:   mCachedSurface = aData.mSurface;
57896:   mTexture = NULL;
57896: 
57896:   // Try to upload the surface immediately, so that we don't block the
57896:   // rendering pipeline at paint time.
57896:   (void) GetOrCreateTexture();
57896: }
57896: 
57896: IDirect3DTexture9*
57896: CairoImageD3D9::GetOrCreateTexture()
57896: {
57896:   if (mTexture)
57896:     return mTexture;
42611: 
42611:   nsRefPtr<gfxImageSurface> imageSurface =
57896:     new gfxImageSurface(mSize, gfxASurface::ImageFormatARGB32);
42611: 
42611:   nsRefPtr<gfxContext> context = new gfxContext(imageSurface);
42611: 
57896:   context->SetSource(mCachedSurface);
42611:   context->Paint();
42611: 
49317:   if (mManager->deviceManager()->IsD3D9Ex()) {
49317:     // D3D9Ex doesn't support managed textures. We could use dynamic textures
49317:     // here but since Images are immutable that probably isn't such a great
49317:     // idea.
57896:     if (FAILED(mManager->device()->
57896:                CreateTexture(mSize.width, mSize.height,
49317:                              1, 0, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
57896:                              getter_AddRefs(mTexture), NULL)))
57896:       return NULL;
57896: 
49317:     nsRefPtr<IDirect3DSurface9> surface;
57896:     if (FAILED(mManager->device()->
57896:                CreateOffscreenPlainSurface(mSize.width,
57896:                                            mSize.height,
49317:                                            D3DFMT_A8R8G8B8,
49317:                                            D3DPOOL_SYSTEMMEM,
49317:                                            getter_AddRefs(surface),
57896:                                            NULL))) {
57896:       mTexture = NULL;
57896:       return NULL;
57896:     }
57896: 
49317:     D3DLOCKED_RECT lockedRect;
49317:     surface->LockRect(&lockedRect, NULL, 0);
57896:     for (int y = 0; y < mSize.height; y++) {
49317:       memcpy((char*)lockedRect.pBits + lockedRect.Pitch * y,
49317:              imageSurface->Data() + imageSurface->Stride() * y,
57896:              mSize.width * 4);
49317:     }
49317:     surface->UnlockRect();
49317:     nsRefPtr<IDirect3DSurface9> dstSurface;
49317:     mTexture->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
49317:     mManager->device()->UpdateSurface(surface, NULL, dstSurface, NULL);
49317:   } else {
57896:     if (FAILED(mManager->device()->
57896:                CreateTexture(mSize.width, mSize.height,
42611:                              1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
57896:                              getter_AddRefs(mTexture), NULL)))
57896:       return NULL;
57896: 
42611:     D3DLOCKED_RECT lockrect;
42611:     /* lock the entire texture */
42611:     mTexture->LockRect(0, &lockrect, NULL, 0);
42611: 
42611:     // copy over data. If we don't need to do any swaping we can
42611:     // use memcpy
57896:     for (int y = 0; y < mSize.height; y++) {
49317:       memcpy((char*)lockrect.pBits + lockrect.Pitch * y,
49317:              imageSurface->Data() + imageSurface->Stride() * y,
57896:              mSize.width * 4);
42611:     }
42611: 
42611:     mTexture->UnlockRect(0);
42611:   }
57896: 
57896:   NS_ASSERTION(mTexture, "Should have succeeded by now.");
57896:   // Release our no-longer-needed mCachedSurface
57896:   mCachedSurface = NULL;
57896:   return mTexture;
49317: }
42611: 
42611: already_AddRefed<gfxASurface>
42611: CairoImageD3D9::GetAsSurface()
42611: {
42611:   return nsnull;
42611: }
42611: 
42611: } /* layers */
42611: } /* mozilla */
