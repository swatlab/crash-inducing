37766: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
34349:  *
34349:  * ***** BEGIN LICENSE BLOCK *****
34349:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
34349:  *
34349:  * The contents of this file are subject to the Mozilla Public License Version
34349:  * 1.1 (the "License"); you may not use this file except in compliance with
34349:  * the License. You may obtain a copy of the License at
34349:  * http://www.mozilla.org/MPL/
34349:  *
34349:  * Software distributed under the License is distributed on an "AS IS" basis,
34349:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
34349:  * for the specific language governing rights and limitations under the
34349:  * License.
34349:  *
34349:  * The Original Code is Mozilla Communicator client code, released
34349:  * March 31, 1998.
34349:  *
34349:  * The Initial Developer of the Original Code is
34349:  * Netscape Communications Corporation.
34349:  * Portions created by the Initial Developer are Copyright (C) 1998
34349:  * the Initial Developer. All Rights Reserved.
34349:  *
34349:  * Contributor(s):
34349:  *
34349:  * Alternatively, the contents of this file may be used under the terms of
34349:  * either of the GNU General Public License Version 2 or later (the "GPL"),
34349:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
34349:  * in which case the provisions of the GPL or the LGPL are applicable instead
34349:  * of those above. If you wish to allow use of your version of this file only
34349:  * under the terms of either the GPL or the LGPL, and not to allow others to
34349:  * use your version of this file under the terms of the MPL, indicate your
34349:  * decision by deleting the provisions above and replace them with the notice
34349:  * and other provisions required by the GPL or the LGPL. If you do not delete
34349:  * the provisions above, a recipient may use your version of this file under
34349:  * the terms of any one of the MPL, the GPL or the LGPL.
34349:  *
34349:  * ***** END LICENSE BLOCK ***** */
34349: 
34349: #ifndef jsscopeinlines_h___
34349: #define jsscopeinlines_h___
34349: 
52503: #include <new>
52503: #include "jsbool.h"
34349: #include "jscntxt.h"
35453: #include "jsdbgapi.h"
34349: #include "jsfun.h"
34349: #include "jsobj.h"
34349: #include "jsscope.h"
34349: 
47485: #include "jscntxtinlines.h"
47485: 
52503: inline void
52503: js::Shape::freeTable(JSContext *cx)
37766: {
52503:     if (table) {
52503:         cx->destroy(table);
52503:         table = NULL;
52503:     }
37766: }
37766: 
52503: inline js::EmptyShape *
55746: JSObject::getEmptyShape(JSContext *cx, js::Class *aclasp,
55746:                         /* gc::FinalizeKind */ unsigned kind)
37766: {
55746:     JS_ASSERT(kind >= js::gc::FINALIZE_OBJECT0 && kind <= js::gc::FINALIZE_OBJECT_LAST);
55746:     int i = kind - js::gc::FINALIZE_OBJECT0;
55746: 
55746:     if (!emptyShapes) {
55746:         emptyShapes = (js::EmptyShape**)
55746:             cx->calloc(sizeof(js::EmptyShape*) * js::gc::JS_FINALIZE_OBJECT_LIMIT);
55746:         if (!emptyShapes)
55746:             return NULL;
55746: 
55746:         /*
55746:          * Always fill in emptyShapes[0], so canProvideEmptyShape works.
55746:          * Other empty shapes are filled in lazily.
55746:          */
55746:         emptyShapes[0] = js::EmptyShape::create(cx, aclasp);
55746:         if (!emptyShapes[0]) {
55746:             cx->free(emptyShapes);
55746:             emptyShapes = NULL;
55746:             return NULL;
55746:         }
55746:     }
55746: 
55746:     JS_ASSERT(aclasp == emptyShapes[0]->getClass());
55746: 
55746:     if (!emptyShapes[i]) {
55746:         emptyShapes[i] = js::EmptyShape::create(cx, aclasp);
55746:         if (!emptyShapes[i])
55746:             return NULL;
55746:     }
55746: 
55746:     return emptyShapes[i];
37766: }
37766: 
37766: inline bool
52503: JSObject::canProvideEmptyShape(js::Class *aclasp)
37766: {
55746:     return !emptyShapes || emptyShapes[0]->getClass() == aclasp;
37766: }
37766: 
34349: inline void
52503: JSObject::updateShape(JSContext *cx)
35453: {
52503:     JS_ASSERT(isNative());
52503:     js::LeaveTraceIfGlobalObject(cx, this);
52503:     if (hasOwnShape())
52503:         setOwnShape(js_GenerateShape(cx, false));
52503:     else
52503:         objShape = lastProp->shape;
35453: }
35453: 
35453: inline void
52503: JSObject::updateFlags(const js::Shape *shape, bool isDefinitelyAtom)
34349: {
34349:     jsuint index;
52503:     if (!isDefinitelyAtom && js_IdIsIndex(shape->id, &index))
52503:         setIndexed();
34349: 
52503:     if (shape->isMethod())
34349:         setMethodBarrier();
34349: }
34349: 
37034: inline void
52503: JSObject::extend(JSContext *cx, const js::Shape *shape, bool isDefinitelyAtom)
37034: {
52503:     setLastProperty(shape);
52503:     updateFlags(shape, isDefinitelyAtom);
37034:     updateShape(cx);
34349: }
34349: 
34349: inline void
52503: JSObject::trace(JSTracer *trc)
34349: {
52503:     if (!isNative())
52503:         return;
52503: 
34349:     JSContext *cx = trc->context;
52503:     js::Shape *shape = lastProp;
40327: 
52503:     if (IS_GC_MARKING_TRACER(trc) && cx->runtime->gcRegenShapes) {
34349:         /*
52503:          * Either this object has its own shape, which must be regenerated, or
34349:          * it must have the same shape as lastProp.
34349:          */
52503:         if (!shape->hasRegenFlag()) {
52503:             shape->shape = js_RegenerateShapeForGC(cx);
52503:             shape->setRegenFlag();
40327:         }
40327: 
52503:         uint32 newShape = shape->shape;
52503:         if (hasOwnShape()) {
52503:             newShape = js_RegenerateShapeForGC(cx);
52503:             JS_ASSERT(newShape != shape->shape);
52503:         }
52503:         objShape = newShape;
52503:     }
34349: 
52503:     /* Trace our property tree or dictionary ancestor line. */
34349:     do {
52503:         shape->trace(trc);
52503:     } while ((shape = shape->parent) != NULL);
34349: }
52503: 
52503: namespace js {
52503: 
52503: inline
53650: Shape::Shape(jsid id, js::PropertyOp getter, js::PropertyOp setter, uint32 slot, uintN attrs,
53652:              uintN flags, intN shortid, uint32 shape, uint32 slotSpan)
59712:   : JSObjectMap(JSObjectMap::SHAPE_START_MARKER, shape, slotSpan),
59238:     table(NULL), id(id), rawGetter(getter), rawSetter(setter), slot(slot), attrs(uint8(attrs)),
59712:     flags(uint8(flags)), shortid(int16(shortid)), parent(NULL),
59712:     marker1(JSObjectMap::SHAPE_MARKER_1), marker2(JSObjectMap::SHAPE_MARKER_2),
59712:     endMarker(JSObjectMap::SHAPE_END_MARKER)
52503: {
53652:     JS_ASSERT_IF(slotSpan != SHAPE_INVALID_SLOT, slotSpan < JSObject::NSLOTS_LIMIT);
52503:     JS_ASSERT_IF(getter && (attrs & JSPROP_GETTER), getterObj->isCallable());
52503:     JS_ASSERT_IF(setter && (attrs & JSPROP_SETTER), setterObj->isCallable());
52503:     kids.setNull();
34349: }
34349: 
42733: inline
52503: Shape::Shape(JSContext *cx, Class *aclasp)
59712:   : JSObjectMap(JSObjectMap::SHAPE_START_MARKER, js_GenerateShape(cx, false), JSSLOT_FREE(aclasp)), table(NULL),
53650:     id(JSID_EMPTY), clasp(aclasp), rawSetter(NULL), slot(SHAPE_INVALID_SLOT), attrs(0),
59712:     flags(SHARED_EMPTY), shortid(0), parent(NULL),
59712:     marker1(JSObjectMap::SHAPE_MARKER_1), marker2(JSObjectMap::SHAPE_MARKER_2),
59712:     endMarker(JSObjectMap::SHAPE_END_MARKER)
42733: {
52503:     kids.setNull();
42733: }
42733: 
38562: inline JSDHashNumber
52503: Shape::hash() const
38562: {
38562:     JSDHashNumber hash = 0;
38562: 
38562:     /* Accumulate from least to most random so the low bits are most random. */
39894:     JS_ASSERT_IF(isMethod(), !rawSetter || rawSetter == js_watch_set);
39894:     if (rawGetter)
39894:         hash = JS_ROTATE_LEFT32(hash, 4) ^ jsuword(rawGetter);
39894:     if (rawSetter)
39894:         hash = JS_ROTATE_LEFT32(hash, 4) ^ jsuword(rawSetter);
38562:     hash = JS_ROTATE_LEFT32(hash, 4) ^ (flags & PUBLIC_FLAGS);
38562:     hash = JS_ROTATE_LEFT32(hash, 4) ^ attrs;
38562:     hash = JS_ROTATE_LEFT32(hash, 4) ^ shortid;
38562:     hash = JS_ROTATE_LEFT32(hash, 4) ^ slot;
48470:     hash = JS_ROTATE_LEFT32(hash, 4) ^ JSID_BITS(id);
38562:     return hash;
38562: }
38562: 
38562: inline bool
52503: Shape::matches(const js::Shape *other) const
38562: {
48470:     JS_ASSERT(!JSID_IS_VOID(id));
52503:     JS_ASSERT(!JSID_IS_VOID(other->id));
52503:     return id == other->id &&
52503:            matchesParamsAfterId(other->rawGetter, other->rawSetter, other->slot, other->attrs,
52503:                                 other->flags, other->shortid);
38562: }
38562: 
38562: inline bool
52503: Shape::matchesParamsAfterId(js::PropertyOp agetter, js::PropertyOp asetter, uint32 aslot,
38562:                             uintN aattrs, uintN aflags, intN ashortid) const
38562: {
48470:     JS_ASSERT(!JSID_IS_VOID(id));
39894:     return rawGetter == agetter &&
39894:            rawSetter == asetter &&
38562:            slot == aslot &&
38562:            attrs == aattrs &&
38562:            ((flags ^ aflags) & PUBLIC_FLAGS) == 0 &&
38562:            shortid == ashortid;
38562: }
38562: 
47447: inline bool
57739: Shape::get(JSContext* cx, JSObject *receiver, JSObject* obj, JSObject *pobj, js::Value* vp) const
47447: {
48470:     JS_ASSERT(!JSID_IS_VOID(this->id));
47447:     JS_ASSERT(!hasDefaultGetter());
47447: 
47447:     if (hasGetterValue()) {
47447:         JS_ASSERT(!isMethod());
48470:         js::Value fval = getterValue();
57739:         return js::ExternalGetOrSet(cx, receiver, id, fval, JSACC_READ, 0, 0, vp);
47447:     }
47447: 
47447:     if (isMethod()) {
48470:         vp->setObject(methodObject());
52503:         return pobj->methodReadBarrier(cx, *this, vp);
47447:     }
47447: 
47447:     /*
47447:      * |with (it) color;| ends up here, as do XML filter-expressions.
47447:      * Avoid exposing the With object to native getters.
47447:      */
47447:     if (obj->getClass() == &js_WithClass)
47447:         obj = js_UnwrapWithObject(cx, obj);
52503:     return js::CallJSPropertyOp(cx, getterOp(), obj, SHAPE_USERID(this), vp);
47447: }
47447: 
47447: inline bool
52503: Shape::set(JSContext* cx, JSObject* obj, js::Value* vp) const
47447: {
47447:     JS_ASSERT_IF(hasDefaultSetter(), hasGetterValue());
47447: 
47447:     if (attrs & JSPROP_SETTER) {
48470:         js::Value fval = setterValue();
53557:         return js::ExternalGetOrSet(cx, obj, id, fval, JSACC_WRITE, 1, vp, vp);
47447:     }
47447: 
47447:     if (attrs & JSPROP_GETTER)
48470:         return js_ReportGetterOnlyAssignment(cx);
47447: 
52503:     /* See the comment in js::Shape::get as to why we check for With. */
47447:     if (obj->getClass() == &js_WithClass)
47447:         obj = js_UnwrapWithObject(cx, obj);
52503:     return js::CallJSPropertyOpSetter(cx, setterOp(), obj, SHAPE_USERID(this), vp);
47447: }
47447: 
52503: inline
52503: EmptyShape::EmptyShape(JSContext *cx, js::Class *aclasp)
52503:   : js::Shape(cx, aclasp)
52503: {
52503: #ifdef DEBUG
52503:     if (cx->runtime->meterEmptyShapes())
52503:         cx->runtime->emptyShapes.put(this);
52503: #endif
52503: }
52503: 
52503: } /* namespace js */
52503: 
34349: #endif /* jsscopeinlines_h___ */
