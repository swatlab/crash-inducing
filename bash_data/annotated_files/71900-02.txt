42412: /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
42412: /* ***** BEGIN LICENSE BLOCK *****
42412:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42412:  *
42412:  * The contents of this file are subject to the Mozilla Public License Version
42412:  * 1.1 (the "License"); you may not use this file except in compliance with
42412:  * the License. You may obtain a copy of the License at
42412:  * http://www.mozilla.org/MPL/
42412:  *
42412:  * Software distributed under the License is distributed on an "AS IS" basis,
42412:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42412:  * for the specific language governing rights and limitations under the
42412:  * License.
42412:  *
42412:  * The Original Code is mozilla.org code.
42412:  *
42412:  * The Initial Developer of the Original Code is
42412:  * Mozilla Corporation
42412:  * Portions created by the Initial Developer are Copyright (C) 2010
42412:  * the Initial Developer. All Rights Reserved.
42412:  *
42412:  * Contributor(s):
42412:  *
42412:  * Alternatively, the contents of this file may be used under the terms of
42412:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42412:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42412:  * in which case the provisions of the GPL or the LGPL are applicable instead
42412:  * of those above. If you wish to allow use of your version of this file only
42412:  * under the terms of either the GPL or the LGPL, and not to allow others to
42412:  * use your version of this file under the terms of the MPL, indicate your
42412:  * decision by deleting the provisions above and replace them with the notice
42412:  * and other provisions required by the GPL or the LGPL. If you do not delete
42412:  * the provisions above, a recipient may use your version of this file under
42412:  * the terms of any one of the MPL, the GPL or the LGPL.
42412:  *
42412:  * ***** END LICENSE BLOCK ***** */
42412: 
51811: #include "ContentChild.h"
51811: #include "ContentParent.h"
42783: #include "jscntxt.h"
42412: #include "nsFrameMessageManager.h"
42412: #include "nsContentUtils.h"
42412: #include "nsIXPConnect.h"
42412: #include "jsapi.h"
42412: #include "jsarray.h"
42412: #include "jsinterp.h"
42412: #include "nsJSUtils.h"
49304: #include "nsNetUtil.h"
49304: #include "nsScriptLoader.h"
49304: #include "nsIJSContextStack.h"
51811: #include "nsIXULRuntime.h"
69796: #include "nsIScriptError.h"
69796: #include "nsIConsoleService.h"
70078: #include "nsIProtocolHandler.h"
51811: 
51811: static PRBool
51811: IsChromeProcess()
51811: {
51811:   nsCOMPtr<nsIXULRuntime> rt = do_GetService("@mozilla.org/xre/runtime;1");
51828:   if (!rt)
51828:     return PR_TRUE;
51828: 
51811:   PRUint32 type;
51811:   rt->GetProcessType(&type);
51811:   return type == nsIXULRuntime::PROCESS_TYPE_DEFAULT;
51811: }
42412: 
42412: NS_IMPL_CYCLE_COLLECTION_CLASS(nsFrameMessageManager)
42412: 
42412: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFrameMessageManager)
42412:   PRUint32 count = tmp->mListeners.Length();
42412:   for (PRUint32 i = 0; i < count; i++) {
42412:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mListeners[i] mListener");
42412:     cb.NoteXPCOMChild(tmp->mListeners[i].mListener.get());
42412:   }
42412:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mChildManagers)
42412: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
42412: 
42412: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFrameMessageManager)
42412:   tmp->mListeners.Clear();
42412:   for (PRInt32 i = tmp->mChildManagers.Count(); i > 0; --i) {
42412:     static_cast<nsFrameMessageManager*>(tmp->mChildManagers[i - 1])->
42412:       Disconnect(PR_FALSE);
42412:   }
42412:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mChildManagers)
42412: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
42412: 
42412: 
42412: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsFrameMessageManager)
42412:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentFrameMessageManager)
43461:   NS_INTERFACE_MAP_ENTRY_AGGREGATED(nsIFrameMessageManager,
43461:                                     (mChrome ?
43461:                                        static_cast<nsIFrameMessageManager*>(
43461:                                          static_cast<nsIChromeFrameMessageManager*>(this)) :
43461:                                        static_cast<nsIFrameMessageManager*>(
43461:                                          static_cast<nsIContentFrameMessageManager*>(this))))
51811:   /* nsIContentFrameMessageManager is accessible only in TabChildGlobal. */
51811:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIContentFrameMessageManager,
51811:                                      !mChrome && !mIsProcessManager)
51811:   /* Message managers in child process support nsISyncMessageSender. */
51811:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsISyncMessageSender, !mChrome)
51811:   /* Process message manager doesn't support nsIChromeFrameMessageManager. */
51811:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIChromeFrameMessageManager,
51811:                                      mChrome && !mIsProcessManager)
42412: NS_INTERFACE_MAP_END
42412: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsFrameMessageManager)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsFrameMessageManager)
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::AddMessageListener(const nsAString& aMessage,
42412:                                           nsIFrameMessageListener* aListener)
42412: {
42412:   nsCOMPtr<nsIAtom> message = do_GetAtom(aMessage);
42412:   PRUint32 len = mListeners.Length();
42412:   for (PRUint32 i = 0; i < len; ++i) {
42412:     if (mListeners[i].mMessage == message &&
42412:       mListeners[i].mListener == aListener) {
42412:       return NS_OK;
42412:     }
42412:   }
42412:   nsMessageListenerInfo* entry = mListeners.AppendElement();
42412:   NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
42412:   entry->mMessage = message;
42412:   entry->mListener = aListener;
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::RemoveMessageListener(const nsAString& aMessage,
42412:                                              nsIFrameMessageListener* aListener)
42412: {
42412:   nsCOMPtr<nsIAtom> message = do_GetAtom(aMessage);
42412:   PRUint32 len = mListeners.Length();
42412:   for (PRUint32 i = 0; i < len; ++i) {
42412:     if (mListeners[i].mMessage == message &&
42412:       mListeners[i].mListener == aListener) {
42412:       mListeners.RemoveElementAt(i);
42412:       return NS_OK;
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::LoadFrameScript(const nsAString& aURL,
42412:                                        PRBool aAllowDelayedLoad)
42412: {
43461:   if (aAllowDelayedLoad) {
43461:     if (IsGlobal() || IsWindowLevel()) {
43461:       // Cache for future windows or frames
43461:       mPendingScripts.AppendElement(aURL);
43461:     } else if (!mCallbackData) {
43461:       // We're frame message manager, which isn't connected yet.
42412:       mPendingScripts.AppendElement(aURL);
42412:       return NS_OK;
42412:     }
43461:   }
42412: 
42412:   if (mCallbackData) {
42412: #ifdef DEBUG_smaug
42412:     printf("Will load %s \n", NS_ConvertUTF16toUTF8(aURL).get());
42412: #endif
42412:     NS_ENSURE_TRUE(mLoadScriptCallback(mCallbackData, aURL), NS_ERROR_FAILURE);
42412:   }
42412: 
43461:   for (PRInt32 i = 0; i < mChildManagers.Count(); ++i) {
43461:     nsRefPtr<nsFrameMessageManager> mm =
43461:       static_cast<nsFrameMessageManager*>(mChildManagers[i]);
42412:     if (mm) {
43461:       // Use PR_FALSE here, so that child managers don't cache the script, which
43461:       // is already cached in the parent.
43461:       mm->LoadFrameScript(aURL, PR_FALSE);
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: static JSBool
42412: JSONCreator(const jschar* aBuf, uint32 aLen, void* aData)
42412: {
42412:   nsAString* result = static_cast<nsAString*>(aData);
42412:   result->Append((PRUnichar*)aBuf, (PRUint32)aLen);
42412:   return JS_TRUE;
42412: }
42412: 
42412: nsresult
42412: nsFrameMessageManager::GetParamsForMessage(nsAString& aMessageName,
42412:                                            nsAString& aJSON)
42412: {
42412:   aMessageName.Truncate();
42412:   aJSON.Truncate();
42412:   nsAXPCNativeCallContext* ncc = nsnull;
42412:   nsresult rv = nsContentUtils::XPConnect()->GetCurrentNativeCallContext(&ncc);
42412:   NS_ENSURE_SUCCESS(rv, rv);
42412:   NS_ENSURE_STATE(ncc);
42412: 
42412:   JSContext* ctx = nsnull;
42412:   rv = ncc->GetJSContext(&ctx);
42412:   NS_ENSURE_SUCCESS(rv, rv);
42412: 
42412:   PRUint32 argc;
42412:   jsval* argv = nsnull;
42412:   ncc->GetArgc(&argc);
42412:   ncc->GetArgvPtr(&argv);
42412: 
42412:   JSAutoRequest ar(ctx);
42412:   JSString* str;
42412:   if (argc && (str = JS_ValueToString(ctx, argv[0])) && str) {
59889:     nsDependentJSString depStr;
59889:     if (!depStr.init(ctx, str)) {
59889:       return NS_ERROR_OUT_OF_MEMORY;
59889:     }
59889:     aMessageName.Assign(depStr);
42412:   }
42412: 
42412:   if (argc >= 2) {
42412:     jsval v = argv[1];
42412:     if (JS_TryJSON(ctx, &v)) {
42412:       JS_Stringify(ctx, &v, nsnull, JSVAL_NULL, JSONCreator, &aJSON);
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::SendSyncMessage()
42412: {
43461:   NS_ASSERTION(!IsGlobal(), "Should not call SendSyncMessage in chrome");
43461:   NS_ASSERTION(!IsWindowLevel(), "Should not call SendSyncMessage in chrome");
43461:   NS_ASSERTION(!mParentManager, "Should not have parent manager in content!");
42412:   if (mSyncCallback) {
42412:     NS_ENSURE_TRUE(mCallbackData, NS_ERROR_NOT_INITIALIZED);
42412:     nsString messageName;
42412:     nsString json;
42412:     nsresult rv = GetParamsForMessage(messageName, json);
42412:     NS_ENSURE_SUCCESS(rv, rv);
57141:     InfallibleTArray<nsString> retval;
42412:     if (mSyncCallback(mCallbackData, messageName, json, &retval)) {
42412:       nsAXPCNativeCallContext* ncc = nsnull;
42412:       rv = nsContentUtils::XPConnect()->GetCurrentNativeCallContext(&ncc);
42412:       NS_ENSURE_SUCCESS(rv, rv);
42412:       NS_ENSURE_STATE(ncc);
42412: 
42412:       JSContext* ctx = nsnull;
42412:       rv = ncc->GetJSContext(&ctx);
42412:       NS_ENSURE_SUCCESS(rv, rv);
42412:       JSAutoRequest ar(ctx);
42412: 
42412:       PRUint32 len = retval.Length();
48553:       JSObject* dataArray = JS_NewArrayObject(ctx, len, NULL);
42412:       NS_ENSURE_TRUE(dataArray, NS_ERROR_OUT_OF_MEMORY);
42412: 
42412:       for (PRUint32 i = 0; i < len; ++i) {
47688:         if (!retval[i].Length())
47688:           continue;
47688: 
42412:         jsval ret = JSVAL_VOID;
67923:         if (!JS_ParseJSON(ctx, (jschar*)retval[i].get(),
67923:                           (uint32)retval[i].Length(), &ret)) {
67923:           return NS_ERROR_UNEXPECTED;
67923:         }
48550:         NS_ENSURE_TRUE(JS_SetElement(ctx, dataArray, i, &ret), NS_ERROR_OUT_OF_MEMORY);
42412:       }
42412: 
42412:       jsval* retvalPtr;
42412:       ncc->GetRetValPtr(&retvalPtr);
42412:       *retvalPtr = OBJECT_TO_JSVAL(dataArray);
42412:       ncc->SetReturnValueWasSet(PR_TRUE);
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: nsresult
42412: nsFrameMessageManager::SendAsyncMessageInternal(const nsAString& aMessage,
42412:                                                 const nsAString& aJSON)
42412: {
42412:   if (mAsyncCallback) {
42412:     NS_ENSURE_TRUE(mCallbackData, NS_ERROR_NOT_INITIALIZED);
42412:     mAsyncCallback(mCallbackData, aMessage, aJSON);
42412:   }
42412:   PRInt32 len = mChildManagers.Count();
42412:   for (PRInt32 i = 0; i < len; ++i) {
42412:     static_cast<nsFrameMessageManager*>(mChildManagers[i])->
42412:       SendAsyncMessageInternal(aMessage, aJSON);
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::SendAsyncMessage()
42412: {
42412:   nsString messageName;
42412:   nsString json;
42412:   nsresult rv = GetParamsForMessage(messageName, json);
42412:   NS_ENSURE_SUCCESS(rv, rv);
42412:   return SendAsyncMessageInternal(messageName, json);
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::Dump(const nsAString& aStr)
42412: {
42412:   fputs(NS_ConvertUTF16toUTF8(aStr).get(), stdout);
42412:   fflush(stdout);
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
58164: nsFrameMessageManager::PrivateNoteIntentionalCrash()
58164: {
58164:   return NS_ERROR_NOT_IMPLEMENTED;
58164: }
58164: 
58164: NS_IMETHODIMP
42412: nsFrameMessageManager::GetContent(nsIDOMWindow** aContent)
42412: {
42412:   *aContent = nsnull;
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::GetDocShell(nsIDocShell** aDocShell)
42412: {
42412:   *aDocShell = nsnull;
42412:   return NS_OK;
42412: }
42412: 
42412: nsresult
42412: nsFrameMessageManager::ReceiveMessage(nsISupports* aTarget,
42412:                                       const nsAString& aMessage,
42412:                                       PRBool aSync, const nsAString& aJSON,
42412:                                       JSObject* aObjectsArray,
57141:                                       InfallibleTArray<nsString>* aJSONRetVal,
43461:                                       JSContext* aContext)
42412: {
43461:   JSContext* ctx = mContext ? mContext : aContext;
51811:   if (!ctx) {
51811:     nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&ctx);
51811:   }
42412:   if (mListeners.Length()) {
42412:     nsCOMPtr<nsIAtom> name = do_GetAtom(aMessage);
42412:     nsRefPtr<nsFrameMessageManager> kungfuDeathGrip(this);
42412: 
42412:     for (PRUint32 i = 0; i < mListeners.Length(); ++i) {
42412:       if (mListeners[i].mMessage == name) {
42412:         nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS =
42412:           do_QueryInterface(mListeners[i].mListener);
42412:         if (!wrappedJS) {
42412:           continue;
42412:         }
42412:         JSObject* object = nsnull;
42412:         wrappedJS->GetJSObject(&object);
42412:         if (!object) {
42412:           continue;
42412:         }
42412:         nsCxPusher pusher;
43461:         NS_ENSURE_STATE(pusher.Push(ctx, PR_FALSE));
42412: 
43461:         JSAutoRequest ar(ctx);
42412: 
71060:         JSAutoEnterCompartment ac;
71060:         if (!ac.enter(ctx, object))
71060:           return NS_ERROR_FAILURE;
71060: 
42412:         // The parameter for the listener function.
43461:         JSObject* param = JS_NewObject(ctx, NULL, NULL, NULL);
42412:         NS_ENSURE_TRUE(param, NS_ERROR_OUT_OF_MEMORY);
42412: 
42412:         jsval targetv;
43461:         nsContentUtils::WrapNative(ctx,
71060:                                    JS_GetGlobalForObject(ctx, object),
42412:                                    aTarget, &targetv);
42412: 
42412:         // To keep compatibility with e10s message manager,
42412:         // define empty objects array.
42412:         if (!aObjectsArray) {
42412:           // Because we want JS messages to have always the same properties,
42412:           // create array even if len == 0.
48553:           aObjectsArray = JS_NewArrayObject(ctx, 0, NULL);
42412:           if (!aObjectsArray) {
62917:             return NS_ERROR_OUT_OF_MEMORY;
42412:           }
42412:         }
42412: 
42412:         jsval json = JSVAL_NULL;
58977:         if (!aJSON.IsEmpty()) {
67923:           if (!JS_ParseJSON(ctx, (jschar*)nsString(aJSON).get(),
67923:                             (uint32)aJSON.Length(), &json)) {
42412:             json = JSVAL_NULL;
42412:           }
42412:         }
42412:         JSString* jsMessage =
43461:           JS_NewUCStringCopyN(ctx,
42412:                               reinterpret_cast<const jschar *>(nsString(aMessage).get()),
42412:                               aMessage.Length());
42412:         NS_ENSURE_TRUE(jsMessage, NS_ERROR_OUT_OF_MEMORY);
43461:         JS_DefineProperty(ctx, param, "target", targetv, NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "name",
42412:                           STRING_TO_JSVAL(jsMessage), NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "sync",
42412:                           BOOLEAN_TO_JSVAL(aSync), NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "json", json, NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "objects", OBJECT_TO_JSVAL(aObjectsArray),
42412:                           NULL, NULL, JSPROP_ENUMERATE);
42412: 
42412:         jsval thisValue = JSVAL_VOID;
42412: 
42412:         jsval funval = JSVAL_VOID;
43461:         if (JS_ObjectIsFunction(ctx, object)) {
42412:           // If the listener is a JS function:
42412:           funval = OBJECT_TO_JSVAL(object);
43461: 
43461:           // A small hack to get 'this' value right on content side where
43461:           // messageManager is wrapped in TabChildGlobal.
43461:           nsCOMPtr<nsISupports> defaultThisValue;
43461:           if (mChrome) {
43461:             defaultThisValue =
42412:               do_QueryInterface(static_cast<nsIContentFrameMessageManager*>(this));
43461:           } else {
43461:             defaultThisValue = aTarget;
43461:           }
43461:           nsContentUtils::WrapNative(ctx,
71060:                                      JS_GetGlobalForObject(ctx, object),
42412:                                      defaultThisValue, &thisValue);
42412:         } else {
42412:           // If the listener is a JS object which has receiveMessage function:
43461:           NS_ENSURE_STATE(JS_GetProperty(ctx, object, "receiveMessage",
42412:                                          &funval) &&
42412:                           JSVAL_IS_OBJECT(funval) &&
42412:                           !JSVAL_IS_NULL(funval));
42412:           JSObject* funobject = JSVAL_TO_OBJECT(funval);
43461:           NS_ENSURE_STATE(JS_ObjectIsFunction(ctx, funobject));
42412:           thisValue = OBJECT_TO_JSVAL(object);
42412:         }
42412: 
42412:         jsval rval = JSVAL_VOID;
42412: 
43461:         js::AutoValueRooter argv(ctx);
48470:         argv.set(OBJECT_TO_JSVAL(param));
42412: 
55678:         {
55678:           JSAutoEnterCompartment tac;
55678: 
42412:           JSObject* thisObject = JSVAL_TO_OBJECT(thisValue);
55678: 
55678:           if (!tac.enter(ctx, thisObject) ||
71059:               !JS_WrapValue(ctx, argv.jsval_addr()))
55678:             return NS_ERROR_UNEXPECTED;
55678: 
43461:           JS_CallFunctionValue(ctx, thisObject,
48470:                                funval, 1, argv.jsval_addr(), &rval);
42412:           if (aJSONRetVal) {
42412:             nsString json;
43461:             if (JS_TryJSON(ctx, &rval) &&
43461:                 JS_Stringify(ctx, &rval, nsnull, JSVAL_NULL,
42412:                              JSONCreator, &json)) {
42412:               aJSONRetVal->AppendElement(json);
42412:             }
42412:           }
42412:         }
42412:       }
42412:     }
55678:   }
71900:   nsRefPtr<nsFrameMessageManager> kungfuDeathGrip = mParentManager;
42412:   return mParentManager ? mParentManager->ReceiveMessage(aTarget, aMessage,
42412:                                                          aSync, aJSON, aObjectsArray,
43461:                                                          aJSONRetVal, mContext) : NS_OK;
42412: }
42412: 
42412: void
42412: nsFrameMessageManager::AddChildManager(nsFrameMessageManager* aManager,
42412:                                        PRBool aLoadScripts)
42412: {
42412:   mChildManagers.AppendObject(aManager);
42412:   if (aLoadScripts) {
43461:     nsRefPtr<nsFrameMessageManager> kungfuDeathGrip = this;
43461:     nsRefPtr<nsFrameMessageManager> kungfuDeathGrip2 = aManager;
43461:     // We have parent manager if we're a window message manager.
43461:     // In that case we want to load the pending scripts from global
43461:     // message manager.
43461:     if (mParentManager) {
43461:       nsRefPtr<nsFrameMessageManager> globalMM = mParentManager;
43461:       for (PRUint32 i = 0; i < globalMM->mPendingScripts.Length(); ++i) {
43461:         aManager->LoadFrameScript(globalMM->mPendingScripts[i], PR_FALSE);
43461:       }
43461:     }
42412:     for (PRUint32 i = 0; i < mPendingScripts.Length(); ++i) {
42412:       aManager->LoadFrameScript(mPendingScripts[i], PR_FALSE);
42412:     }
42412:   }
42412: }
42412: 
42412: void
42412: nsFrameMessageManager::SetCallbackData(void* aData, PRBool aLoadScripts)
42412: {
42412:   if (aData && mCallbackData != aData) {
42412:     mCallbackData = aData;
42412:     // First load global scripts by adding this to parent manager.
42412:     if (mParentManager) {
42412:       mParentManager->AddChildManager(this, aLoadScripts);
42412:     }
42412:     if (aLoadScripts) {
42412:       for (PRUint32 i = 0; i < mPendingScripts.Length(); ++i) {
42412:         LoadFrameScript(mPendingScripts[i], PR_FALSE);
42412:       }
42412:     }
42412:   }
42412: }
42412: 
42412: void
42412: nsFrameMessageManager::Disconnect(PRBool aRemoveFromParent)
42412: {
42412:   if (mParentManager && aRemoveFromParent) {
42412:     mParentManager->RemoveChildManager(this);
42412:   }
42412:   mParentManager = nsnull;
42412:   mCallbackData = nsnull;
43461:   mContext = nsnull;
42412: }
43461: 
43461: nsresult
43461: NS_NewGlobalMessageManager(nsIChromeFrameMessageManager** aResult)
43461: {
51811:   NS_ENSURE_TRUE(IsChromeProcess(), NS_ERROR_NOT_AVAILABLE);
43461:   nsFrameMessageManager* mm = new nsFrameMessageManager(PR_TRUE,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         PR_TRUE);
43461:   NS_ENSURE_TRUE(mm, NS_ERROR_OUT_OF_MEMORY);
43461:   return CallQueryInterface(mm, aResult);
43461: }
49304: 
69796: void
69796: ContentScriptErrorReporter(JSContext* aCx,
69796:                            const char* aMessage,
69796:                            JSErrorReport* aReport)
69796: {
69796:   nsresult rv;
69796:   nsCOMPtr<nsIScriptError> scriptError =
69796:       do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
69796:   if (NS_FAILED(rv)) {
69796:     return;
69796:   }
69796:   nsAutoString message, filename, line;
69796:   PRUint32 lineNumber, columnNumber, flags, errorNumber;
69796: 
69796:   if (aReport) {
69796:     if (aReport->ucmessage) {
69796:       message.Assign(reinterpret_cast<const PRUnichar*>(aReport->ucmessage));
69796:     }
69796:     filename.AssignWithConversion(aReport->filename);
69796:     line.Assign(reinterpret_cast<const PRUnichar*>(aReport->uclinebuf));
69796:     lineNumber = aReport->lineno;
69796:     columnNumber = aReport->uctokenptr - aReport->uclinebuf;
69796:     flags = aReport->flags;
69796:     errorNumber = aReport->errorNumber;
69796:   } else {
69796:     lineNumber = columnNumber = errorNumber = 0;
69796:     flags = nsIScriptError::errorFlag | nsIScriptError::exceptionFlag;
69796:   }
69796: 
69796:   if (message.IsEmpty()) {
69796:     message.AssignWithConversion(aMessage);
69796:   }
69796: 
69796:   rv = scriptError->Init(message.get(), filename.get(), line.get(),
69796:                          lineNumber, columnNumber, flags,
69796:                          "Message manager content script");
69796:   if (NS_FAILED(rv)) {
69796:     return;
69796:   }
69796: 
69796:   nsCOMPtr<nsIConsoleService> consoleService =
69796:       do_GetService(NS_CONSOLESERVICE_CONTRACTID);
69796:   if (consoleService) {
69796:     (void) consoleService->LogMessage(scriptError);
69796:   }
69796: }
69796: 
49304: nsDataHashtable<nsStringHashKey, nsFrameScriptExecutorJSObjectHolder*>*
49304:   nsFrameScriptExecutor::sCachedScripts = nsnull;
50684: nsRefPtr<nsScriptCacheCleaner> nsFrameScriptExecutor::sScriptCacheCleaner;
49304: 
49304: void
49304: nsFrameScriptExecutor::DidCreateCx()
49304: {
49304:   NS_ASSERTION(mCx, "Should have mCx!");
49304:   if (!sCachedScripts) {
49304:     sCachedScripts =
49304:       new nsDataHashtable<nsStringHashKey, nsFrameScriptExecutorJSObjectHolder*>;
49304:     sCachedScripts->Init();
50684: 
50684:     sScriptCacheCleaner = new nsScriptCacheCleaner();
49304:   }
49304: }
49304: 
49304: void
49304: nsFrameScriptExecutor::DestroyCx()
49304: {
71900:   if (mCxStackRefCnt) {
71900:     mDelayedCxDestroy = PR_TRUE;
71900:     return;
71900:   }
71900:   mDelayedCxDestroy = PR_FALSE;
71900:   if (mCx) {
49304:     nsIXPConnect* xpc = nsContentUtils::XPConnect();
49304:     if (xpc) {
49304:       xpc->ReleaseJSContext(mCx, PR_TRUE);
49304:     } else {
49304:       JS_DestroyContext(mCx);
49304:     }
71900:   }
49304:   mCx = nsnull;
51259:   mGlobal = nsnull;
49304: }
49304: 
49304: static PLDHashOperator
49304: CachedScriptUnrooter(const nsAString& aKey,
49304:                        nsFrameScriptExecutorJSObjectHolder*& aData,
49304:                        void* aUserArg)
49304: {
49304:   JSContext* cx = static_cast<JSContext*>(aUserArg);
49304:   JS_RemoveObjectRoot(cx, &(aData->mObject));
61117:   delete aData;
49304:   return PL_DHASH_REMOVE;
49304: }
49304: 
49304: // static
49304: void
49304: nsFrameScriptExecutor::Shutdown()
49304: {
49304:   if (sCachedScripts) {
49304:     JSContext* cx = nsnull;
49304:     nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&cx);
49304:     if (cx) {
49304: #ifdef DEBUG_smaug
49304:       printf("Will clear cached frame manager scripts!\n");
49304: #endif
49304:       JSAutoRequest ar(cx);
49304:       NS_ASSERTION(sCachedScripts != nsnull, "Need cached scripts");
49304:       sCachedScripts->Enumerate(CachedScriptUnrooter, cx);
49304:     } else {
49304:       NS_WARNING("No context available. Leaking cached scripts!\n");
49304:     }
49304: 
49304:     delete sCachedScripts;
49304:     sCachedScripts = nsnull;
50684: 
50684:     sScriptCacheCleaner = nsnull;
49304:   }
49304: }
49304: 
49304: void
49304: nsFrameScriptExecutor::LoadFrameScriptInternal(const nsAString& aURL)
49304: {
63116:   if (!mGlobal || !mCx || !sCachedScripts) {
49304:     return;
49304:   }
49304: 
49304:   nsFrameScriptExecutorJSObjectHolder* holder = sCachedScripts->Get(aURL);
49304:   if (holder) {
49304:     nsContentUtils::ThreadJSContextStack()->Push(mCx);
49304:     {
49304:       // Need to scope JSAutoRequest to happen after Push but before Pop,
49304:       // at least for now. See bug 584673.
49304:       JSAutoRequest ar(mCx);
49304:       JSObject* global = nsnull;
49304:       mGlobal->GetJSObject(&global);
49304:       if (global) {
69796:         (void) JS_ExecuteScript(mCx, global, holder->mObject, nsnull);
49304:       }
49304:     }
49304:     JSContext* unused;
49304:     nsContentUtils::ThreadJSContextStack()->Pop(&unused);
49304:     return;
49304:   }
49304: 
49304:   nsCString url = NS_ConvertUTF16toUTF8(aURL);
49304:   nsCOMPtr<nsIURI> uri;
49304:   nsresult rv = NS_NewURI(getter_AddRefs(uri), url);
49304:   if (NS_FAILED(rv)) {
49304:     return;
49304:   }
70078:   
70078:   PRBool hasFlags;
70078:   rv = NS_URIChainHasFlags(uri,
70078:                            nsIProtocolHandler::URI_IS_LOCAL_RESOURCE,
70078:                            &hasFlags);
70078:   if (NS_FAILED(rv) || !hasFlags) {
70078:     NS_WARNING("Will not load a frame script!");
70078:     return;
70078:   }
70078:   
49304:   nsCOMPtr<nsIChannel> channel;
49304:   NS_NewChannel(getter_AddRefs(channel), uri);
49304:   if (!channel) {
49304:     return;
49304:   }
49304: 
49304:   nsCOMPtr<nsIInputStream> input;
49304:   channel->Open(getter_AddRefs(input));
49304:   nsString dataString;
49304:   PRUint32 avail = 0;
67591:   if (input && NS_SUCCEEDED(input->Available(&avail)) && avail) {
67591:     nsCString buffer;
67591:     if (NS_FAILED(NS_ReadInputStreamToString(input, buffer, avail))) {
67591:       return;
49304:     }
67591:     nsScriptLoader::ConvertToUTF16(channel, (PRUint8*)buffer.get(), avail,
49304:                                    EmptyString(), nsnull, dataString);
49304:   }
49304: 
49304:   if (!dataString.IsEmpty()) {
49304:     nsContentUtils::ThreadJSContextStack()->Push(mCx);
49304:     {
49304:       // Need to scope JSAutoRequest to happen after Push but before Pop,
49304:       // at least for now. See bug 584673.
49304:       JSAutoRequest ar(mCx);
49304:       JSObject* global = nsnull;
49304:       mGlobal->GetJSObject(&global);
49304:       if (global) {
49304:         JSPrincipals* jsprin = nsnull;
49304:         mPrincipal->GetJSPrincipals(mCx, &jsprin);
63927: 
63927:         uint32 oldopts = JS_GetOptions(mCx);
63927:         JS_SetOptions(mCx, oldopts | JSOPTION_NO_SCRIPT_RVAL);
63927: 
64190:         JSObject* scriptObj =
49304:           JS_CompileUCScriptForPrincipals(mCx, nsnull, jsprin,
49304:                                          (jschar*)dataString.get(),
49304:                                           dataString.Length(),
49304:                                           url.get(), 1);
49304: 
63927:         JS_SetOptions(mCx, oldopts);
63927: 
64190:         if (scriptObj) {
49304:           nsCAutoString scheme;
49304:           uri->GetScheme(scheme);
49304:           // We don't cache data: scripts!
49304:           if (!scheme.EqualsLiteral("data")) {
49304:             nsFrameScriptExecutorJSObjectHolder* holder =
49304:               new nsFrameScriptExecutorJSObjectHolder(scriptObj);
49304:             // Root the object also for caching.
49304:             JS_AddNamedObjectRoot(mCx, &(holder->mObject),
49304:                                   "Cached message manager script");
49304:             sCachedScripts->Put(aURL, holder);
49304:           }
69796:           (void) JS_ExecuteScript(mCx, global, scriptObj, nsnull);
49304:         }
49304:         //XXX Argh, JSPrincipals are manually refcounted!
49304:         JSPRINCIPALS_DROP(mCx, jsprin);
49304:       }
49304:     } 
49304:     JSContext* unused;
49304:     nsContentUtils::ThreadJSContextStack()->Pop(&unused);
49304:   }
49304: }
50684: 
61808: // static
61808: void
61808: nsFrameScriptExecutor::Traverse(nsFrameScriptExecutor *tmp,
61808:                                 nsCycleCollectionTraversalCallback &cb)
61808: {
61808:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGlobal)
61808:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mCx");
61808:   nsContentUtils::XPConnect()->NoteJSContext(tmp->mCx, cb);
61808: }
61808: 
51344: NS_IMPL_ISUPPORTS1(nsScriptCacheCleaner, nsIObserver)
50684: 
51811: nsFrameMessageManager* nsFrameMessageManager::sChildProcessManager = nsnull;
51811: nsFrameMessageManager* nsFrameMessageManager::sParentProcessManager = nsnull;
51811: 
51811: bool SendAsyncMessageToChildProcess(void* aCallbackData,
51811:                                     const nsAString& aMessage,
51811:                                     const nsAString& aJSON)
51811: {
51811:   mozilla::dom::ContentParent* cp =
51811:     mozilla::dom::ContentParent::GetSingleton(PR_FALSE);
51811:   NS_WARN_IF_FALSE(cp, "No child process!");
51811:   if (cp) {
51811:     return cp->SendAsyncMessage(nsString(aMessage), nsString(aJSON));
51811:   }
51811:   return true;
51811: }
51811: 
51811: bool SendSyncMessageToParentProcess(void* aCallbackData,
51811:                                     const nsAString& aMessage,
51811:                                     const nsAString& aJSON,
57141:                                     InfallibleTArray<nsString>* aJSONRetVal)
51811: {
51811:   mozilla::dom::ContentChild* cc =
51811:     mozilla::dom::ContentChild::GetSingleton();
51811:   if (cc) {
51811:     return
51811:       cc->SendSyncMessage(nsString(aMessage), nsString(aJSON), aJSONRetVal);
51811:   }
51811:   return true;
51811: }
51811: 
51811: bool SendAsyncMessageToParentProcess(void* aCallbackData,
51811:                                      const nsAString& aMessage,
51811:                                      const nsAString& aJSON)
51811: {
51811:   mozilla::dom::ContentChild* cc =
51811:     mozilla::dom::ContentChild::GetSingleton();
51811:   if (cc) {
51811:     return cc->SendAsyncMessage(nsString(aMessage), nsString(aJSON));
51811:   }
51811:   return true;
51811: }
51811: 
51811: nsresult
51811: NS_NewParentProcessMessageManager(nsIFrameMessageManager** aResult)
51811: {
51811:   NS_ASSERTION(!nsFrameMessageManager::sParentProcessManager,
51811:                "Re-creating sParentProcessManager");
51811:   NS_ENSURE_TRUE(IsChromeProcess(), NS_ERROR_NOT_AVAILABLE);
51811:   nsFrameMessageManager* mm = new nsFrameMessageManager(PR_TRUE,
51811:                                                         nsnull,
51811:                                                         SendAsyncMessageToChildProcess,
51811:                                                         nsnull,
51811:                                                         &nsFrameMessageManager::sParentProcessManager,
51811:                                                         nsnull,
51811:                                                         nsnull,
51811:                                                         PR_FALSE,
51811:                                                         PR_TRUE);
51811:   NS_ENSURE_TRUE(mm, NS_ERROR_OUT_OF_MEMORY);
51811:   nsFrameMessageManager::sParentProcessManager = mm;
51811:   return CallQueryInterface(mm, aResult);
51811: }
51811: 
51811: 
51811: nsresult
51811: NS_NewChildProcessMessageManager(nsISyncMessageSender** aResult)
51811: {
51811:   NS_ASSERTION(!nsFrameMessageManager::sChildProcessManager,
51811:                "Re-creating sChildProcessManager");
51811:   NS_ENSURE_TRUE(!IsChromeProcess(), NS_ERROR_NOT_AVAILABLE);
51811:   nsFrameMessageManager* mm = new nsFrameMessageManager(PR_FALSE,
51811:                                                         SendSyncMessageToParentProcess,
51811:                                                         SendAsyncMessageToParentProcess,
51811:                                                         nsnull,
51811:                                                         &nsFrameMessageManager::sChildProcessManager,
51811:                                                         nsnull,
51811:                                                         nsnull,
51811:                                                         PR_FALSE,
51811:                                                         PR_TRUE);
51811:   NS_ENSURE_TRUE(mm, NS_ERROR_OUT_OF_MEMORY);
51811:   nsFrameMessageManager::sChildProcessManager = mm;
51811:   return CallQueryInterface(mm, aResult);
51811: }
