     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 97643: #include "RootAccessible.h"
 97643: 
 80467: #include "mozilla/Util.h"
 80467: 
 70359: #define CreateEvent CreateEventA
 70359: #include "nsIDOMDocument.h"
 70359: 
 95352: #include "Accessible-inl.h"
100057: #include "DocAccessible-inl.h"
     1: #include "nsAccessibilityService.h"
 41384: #include "nsAccUtils.h"
 41384: #include "nsCoreUtils.h"
106498: #include "nsEventShell.h"
 75194: #include "Relation.h"
 87094: #include "Role.h"
 75194: #include "States.h"
101616: #ifdef MOZ_XUL
101616: #include "XULTreeAccessible.h"
101616: #endif
 31732: 
 43504: #include "mozilla/dom/Element.h"
101260: 
 75194: #include "nsIAccessibleRelation.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
     1: #include "nsIDocShellTreeOwner.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMEventListener.h"
     1: #include "nsIDOMEventTarget.h"
     1: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsIDOMHTMLImageElement.h"
     1: #include "nsIDOMHTMLInputElement.h"
     1: #include "nsIDOMHTMLSelectElement.h"
  8868: #include "nsIDOMDataContainerEvent.h"
     1: #include "nsIDOMNSEvent.h"
     1: #include "nsIDOMXULMultSelectCntrlEl.h"
     1: #include "nsIDOMXULPopupElement.h"
     1: #include "nsIDocument.h"
 72328: #include "nsEventListenerManager.h"
     1: #include "nsIFrame.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIWebBrowserChrome.h"
     1: #include "nsReadableUtils.h"
 29018: #include "nsFocusManager.h"
     1: 
     1: #ifdef MOZ_XUL
     1: #include "nsIXULDocument.h"
     1: #include "nsIXULWindow.h"
     1: #endif
     1: 
 80467: using namespace mozilla;
 74618: using namespace mozilla::a11y;
 41634: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsISupports
 35523: 
 99568: NS_IMPL_ISUPPORTS_INHERITED1(RootAccessible, DocAccessible, nsIAccessibleDocument)
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 97643: // Constructor/destructor
 35523: 
 97643: RootAccessible::
 97643:   RootAccessible(nsIDocument* aDocument, nsIContent* aRootContent,
 89801:                  nsIPresShell* aPresShell) :
 99568:   DocAccessibleWrap(aDocument, aRootContent, aPresShell)
     1: {
 63248:   mFlags |= eRootAccessible;
     1: }
     1: 
 97643: RootAccessible::~RootAccessible()
     1: {
     1: }
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 99648: // Accessible
 35523: 
 97369: ENameValueFlag
 97643: RootAccessible::Name(nsString& aName)
     1: {
 18347:   aName.Truncate();
 18347: 
     1:   if (mRoleMapEntry) {
 99648:     Accessible::Name(aName);
 97369:     if (!aName.IsEmpty())
 97369:       return eNameOK;
     1:   }
     1: 
 70983:   nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(mDocument);
 97657:   NS_ENSURE_TRUE(document, eNameOK);
 97369:   document->GetTitle(aName);
 97369:   return eNameOK;
     1: }
     1: 
 87094: role
 97643: RootAccessible::NativeRole()
     1: {
 87094:   // If it's a <dialog> or <wizard>, use roles::DIALOG instead
 99102:   dom::Element* rootElm = mDocument->GetRootElement();
 99102:   if (rootElm && (rootElm->Tag() == nsGkAtoms::dialog ||
 99102:                   rootElm->Tag() == nsGkAtoms::wizard))
 99102:     return roles::DIALOG;
     1: 
 99568:   return DocAccessibleWrap::NativeRole();
     1: }
     1: 
 97643: // RootAccessible protected member
     1: #ifdef MOZ_XUL
 97643: PRUint32
 97643: RootAccessible::GetChromeFlags()
     1: {
     1:   // Return the flag set for the top level window as defined 
     1:   // by nsIWebBrowserChrome::CHROME_WINDOW_[FLAGNAME]
     1:   // Not simple: nsIXULWindow is not just a QI from nsIDOMWindow
  5679:   nsCOMPtr<nsIDocShellTreeItem> treeItem =
 43504:     nsCoreUtils::GetDocShellTreeItemFor(mDocument);
     1:   NS_ENSURE_TRUE(treeItem, 0);
     1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
     1:   treeItem->GetTreeOwner(getter_AddRefs(treeOwner));
     1:   NS_ENSURE_TRUE(treeOwner, 0);
     1:   nsCOMPtr<nsIXULWindow> xulWin(do_GetInterface(treeOwner));
     1:   if (!xulWin) {
     1:     return 0;
     1:   }
     1:   PRUint32 chromeFlags;
     1:   xulWin->GetChromeFlags(&chromeFlags);
     1:   return chromeFlags;
     1: }
     1: #endif
     1: 
 67790: PRUint64
 97643: RootAccessible::NativeState()
     1: {
 99568:   PRUint64 state = DocAccessibleWrap::NativeState();
 99145:   if (state & states::DEFUNCT)
 99145:     return state;
     1: 
     1: #ifdef MOZ_XUL
     1:   PRUint32 chromeFlags = GetChromeFlags();
 69026:   if (chromeFlags & nsIWebBrowserChrome::CHROME_WINDOW_RESIZE)
 99145:     state |= states::SIZEABLE;
     1:     // If it has a titlebar it's movable
     1:     // XXX unless it's minimized or maximized, but not sure
     1:     //     how to detect that
 69026:   if (chromeFlags & nsIWebBrowserChrome::CHROME_TITLEBAR)
 99145:     state |= states::MOVEABLE;
 69026:   if (chromeFlags & nsIWebBrowserChrome::CHROME_MODAL)
 99145:     state |= states::MODAL;
     1: #endif
     1: 
 89948:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 99145:   if (fm && fm->GetActiveWindow() == mDocument->GetWindow())
 99145:     state |= states::ACTIVE;
 29018: 
 99145:   return state;
     1: }
     1: 
     1: const char* const docEvents[] = {
 58455: #ifdef DEBUG_DRAGDROPSTART
  8862:   // Capture mouse over events and fire fake DRAGDROPSTART event to simplify
  8862:   // debugging a11y objects with event viewers
  8862:   "mouseover",
  8862: #endif
     1:   // capture Form change events 
     1:   "select",
     1:   // capture ValueChange events (fired whenever value changes, immediately after, whether focus moves or not)
     1:   "ValueChange",
     1:   // capture AlertActive events (fired whenever alert pops up)
     1:   "AlertActive",
  8868:   "TreeRowCountChanged",
 11389:   "TreeInvalidated",
     1:   // add ourself as a OpenStateChange listener (custom event fired in tree.xml)
     1:   "OpenStateChange",
     1:   // add ourself as a CheckboxStateChange listener (custom event fired in nsHTMLInputElement.cpp)
     1:   "CheckboxStateChange",
     1:   // add ourself as a RadioStateChange Listener ( custom event fired in in nsHTMLInputElement.cpp  & radio.xml)
     1:   "RadioStateChange",
     1:   "popupshown",
     1:   "popuphiding",
     1:   "DOMMenuInactive",
     1:   "DOMMenuItemActive",
 79384:   "DOMMenuItemInactive",
     1:   "DOMMenuBarActive",
 43310:   "DOMMenuBarInactive"
     1: };
     1: 
 97643: nsresult
 97643: RootAccessible::AddEventListeners()
     1: {
 72323:   // nsIDOMEventTarget interface allows to register event listeners to
     1:   // receive untrusted events (synthetic events generated by untrusted code).
     1:   // For example, XBL bindings implementations for elements that are hosted in
     1:   // non chrome document fire untrusted events.
 72323:   nsCOMPtr<nsIDOMEventTarget> nstarget(do_QueryInterface(mDocument));
     1: 
     1:   if (nstarget) {
     1:     for (const char* const* e = docEvents,
 80467:                    * const* e_end = ArrayEnd(docEvents);
     1:          e < e_end; ++e) {
     1:       nsresult rv = nstarget->AddEventListener(NS_ConvertASCIItoUTF16(*e),
 80486:                                                this, true, true, 2);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:   }
     1: 
     1:   if (!mCaretAccessible) {
  2395:     mCaretAccessible = new nsCaretAccessible(this);
     1:   }
     1: 
 99568:   return DocAccessible::AddEventListeners();
     1: }
     1: 
 97643: nsresult
 97643: RootAccessible::RemoveEventListeners()
     1: {
     1:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mDocument));
     1:   if (target) { 
     1:     for (const char* const* e = docEvents,
 80467:                    * const* e_end = ArrayEnd(docEvents);
     1:          e < e_end; ++e) {
 80486:       nsresult rv = target->RemoveEventListener(NS_ConvertASCIItoUTF16(*e), this, true);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:   }
     1: 
  8373:   // Do this before removing clearing caret accessible, so that it can use
  8373:   // shutdown the caret accessible's selection listener
 99568:   DocAccessible::RemoveEventListeners();
  8373: 
  2395:   if (mCaretAccessible) {
  2395:     mCaretAccessible->Shutdown();
     1:     mCaretAccessible = nsnull;
     1:   }
     1: 
  8373:   return NS_OK;
     1: }
     1: 
 63261: ////////////////////////////////////////////////////////////////////////////////
 63261: // public
 63261: 
  2401: nsCaretAccessible*
 97643: RootAccessible::GetCaretAccessible()
     1: {
  2401:   return mCaretAccessible;
     1: }
     1: 
 59126: void
 99568: RootAccessible::DocumentActivated(DocAccessible* aDocument)
 63261: {
 63261: }
 63261: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsIDOMEventListener
     1: 
 46469: NS_IMETHODIMP
 97643: RootAccessible::HandleEvent(nsIDOMEvent* aDOMEvent)
     1: {
 60746:   nsCOMPtr<nsIDOMNSEvent> DOMNSEvent(do_QueryInterface(aDOMEvent));
 60746:   nsCOMPtr<nsIDOMEventTarget> DOMEventTarget;
 60746:   DOMNSEvent->GetOriginalTarget(getter_AddRefs(DOMEventTarget));
 60746:   nsCOMPtr<nsINode> origTargetNode(do_QueryInterface(DOMEventTarget));
 60746:   if (!origTargetNode)
 60746:     return NS_OK;
     1: 
 99568:   DocAccessible* document =
 80526:     GetAccService()->GetDocAccessible(origTargetNode->OwnerDoc());
 60746: 
 60746:   if (document) {
100118: #ifdef DEBUG
100118:     if (logging::IsEnabled(logging::eDOMEvents)) {
     1:       nsAutoString eventType;
 60746:       aDOMEvent->GetType(eventType);
 60746: 
100118:       logging::MsgBegin("DOMEvents", "event '%s' handled",
 60746:                         NS_ConvertUTF16toUTF8(eventType).get());
100118:       logging::Node("target", origTargetNode);
100118:       logging::MsgEnd();
 60746:     }
 60746: #endif
 60746: 
 60746:     // Root accessible exists longer than any of its descendant documents so
 60746:     // that we are guaranteed notification is processed before root accessible
 60746:     // is destroyed.
 97643:     document->HandleNotification<RootAccessible, nsIDOMEvent>
 97643:       (this, &RootAccessible::ProcessDOMEvent, aDOMEvent);
 60746:   }
 60746: 
 60746:   return NS_OK;
 60746: }
 60746: 
 97643: // RootAccessible protected
 60746: void
 97643: RootAccessible::ProcessDOMEvent(nsIDOMEvent* aDOMEvent)
 60746: {
 60746:   nsCOMPtr<nsIDOMNSEvent> DOMNSEvent(do_QueryInterface(aDOMEvent));
 60746:   nsCOMPtr<nsIDOMEventTarget> DOMEventTarget;
 60746:   DOMNSEvent->GetOriginalTarget(getter_AddRefs(DOMEventTarget));
 60746:   nsCOMPtr<nsINode> origTargetNode(do_QueryInterface(DOMEventTarget));
 60746: 
 60746:   nsAutoString eventType;
 60746:   aDOMEvent->GetType(eventType);
     1: 
 60746:   if (eventType.EqualsLiteral("popuphiding")) {
 79384:     HandlePopupHidingEvent(origTargetNode);
 60746:     return;
 60746:   }
 22209: 
 99568:   DocAccessible* targetDocument = GetAccService()->
 89799:     GetDocAccessible(origTargetNode->OwnerDoc());
 89799:   NS_ASSERTION(targetDocument, "No document while accessible is in document?!");
 89799: 
 99648:   Accessible* accessible = 
 89799:     targetDocument->GetAccessibleOrContainer(origTargetNode);
 42313:   if (!accessible)
 60746:     return;
     1: 
 46469:   nsINode* targetNode = accessible->GetNode();
 62558: 
 10594: #ifdef MOZ_XUL
101616:   XULTreeAccessible* treeAcc = accessible->AsXULTree();
 83107:   if (treeAcc) {
 60746:     if (eventType.EqualsLiteral("TreeRowCountChanged")) {
 60746:       HandleTreeRowCountChangedEvent(aDOMEvent, treeAcc);
 60746:       return;
 60746:     }
  8868: 
 60746:     if (eventType.EqualsLiteral("TreeInvalidated")) {
 60746:       HandleTreeInvalidatedEvent(aDOMEvent, treeAcc);
 60746:       return;
 60746:     }
 15375:   }
 10594: #endif
  8868: 
   589:   if (eventType.EqualsLiteral("RadioStateChange")) {
 67790:     PRUint64 state = accessible->State();
  1510: 
  1510:     // radiogroup in prefWindow is exposed as a list,
  1510:     // and panebutton is exposed as XULListitem in A11y.
101616:     // XULListitemAccessible::GetStateInternal uses STATE_SELECTED in this case,
 67790:     // so we need to check states::SELECTED also.
 79445:     bool isEnabled = (state & (states::CHECKED | states::SELECTED)) != 0;
   589: 
 51377:     nsRefPtr<AccEvent> accEvent =
 67790:       new AccStateChangeEvent(accessible, states::CHECKED, isEnabled);
 37282:     nsEventShell::FireEvent(accEvent);
   589: 
 79384:     if (isEnabled) {
 79384:       FocusMgr()->ActiveItemChanged(accessible);
 79384:       A11YDEBUG_FOCUS_ACTIVEITEMCHANGE_CAUSE("RadioStateChange", accessible)
 79384:     }
   589: 
 60746:     return;
   589:   }
   589: 
   589:   if (eventType.EqualsLiteral("CheckboxStateChange")) {
 67790:     PRUint64 state = accessible->State();
   589: 
 79445:     bool isEnabled = !!(state & states::CHECKED);
   589: 
 51377:     nsRefPtr<AccEvent> accEvent =
 67790:       new AccStateChangeEvent(accessible, states::CHECKED, isEnabled);
   589: 
 37282:     nsEventShell::FireEvent(accEvent);
 60746:     return;
   589:   }
   589: 
 99648:   Accessible* treeItemAcc = nsnull;
     1: #ifdef MOZ_XUL
 82750:   // If it's a tree element, need the currently selected item.
 82750:   if (treeAcc) {
 82750:     treeItemAcc = accessible->CurrentItem();
 82750:     if (treeItemAcc)
 82750:       accessible = treeItemAcc;
     1:   }
     1: 
 82750:   if (treeItemAcc && eventType.EqualsLiteral("OpenStateChange")) {
 67790:     PRUint64 state = accessible->State();
 79445:     bool isEnabled = (state & states::EXPANDED) != 0;
     1: 
 51377:     nsRefPtr<AccEvent> accEvent =
 67790:       new AccStateChangeEvent(accessible, states::EXPANDED, isEnabled);
 37282:     nsEventShell::FireEvent(accEvent);
 60746:     return;
     1:   }
   589: 
 82750:   if (treeItemAcc && eventType.EqualsLiteral("select")) {
 81286:     // XXX: We shouldn't be based on DOM select event which doesn't provide us
 81286:     // any context info. We should integrate into nsTreeSelection instead.
     1:     // If multiselect tree, we should fire selectionadd or selection removed
 79384:     if (FocusMgr()->HasDOMFocus(targetNode)) {
     1:       nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSel =
 46469:         do_QueryInterface(targetNode);
     1:       nsAutoString selType;
     1:       multiSel->GetSelType(selType);
     1:       if (selType.IsEmpty() || !selType.EqualsLiteral("single")) {
   431:         // XXX: We need to fire EVENT_SELECTION_ADD and EVENT_SELECTION_REMOVE
   431:         // for each tree item. Perhaps each tree item will need to cache its
   431:         // selection state and fire an event after a DOM "select" event when
101616:         // that state changes. XULTreeAccessible::UpdateTreeSelection();
 37281:         nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SELECTION_WITHIN,
  3152:                                 accessible);
 60746:         return;
     1:       }
   431: 
 82750:       nsRefPtr<AccSelChangeEvent> selChangeEvent =
 82750:         new AccSelChangeEvent(treeAcc, treeItemAcc,
 82750:                               AccSelChangeEvent::eSelectionAdd);
 82750:       nsEventShell::FireEvent(selChangeEvent);
 60746:       return;
     1:     }
     1:   }
     1:   else
     1: #endif
 79384:   if (eventType.EqualsLiteral("AlertActive")) {
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_ALERT, accessible);
     1:   }
  1937:   else if (eventType.EqualsLiteral("popupshown")) {
 22209:     HandlePopupShownEvent(accessible);
  1671:   }
     1:   else if (eventType.EqualsLiteral("DOMMenuInactive")) {
 87094:     if (accessible->Role() == roles::MENUPOPUP) {
 37281:       nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_END,
  3152:                               accessible);
     1:     }
     1:   }
   431:   else if (eventType.EqualsLiteral("DOMMenuItemActive")) {
 79384:     FocusMgr()->ActiveItemChanged(accessible);
 79384:     A11YDEBUG_FOCUS_ACTIVEITEMCHANGE_CAUSE("DOMMenuItemActive", accessible)
 10594:   }
 79384:   else if (eventType.EqualsLiteral("DOMMenuItemInactive")) {
 79384:     // Process DOMMenuItemInactive event for autocomplete only because this is
 79384:     // unique widget that may acquire focus from autocomplete popup while popup
 79384:     // stays open and has no active item. In case of XUL tree autocomplete
 79384:     // popup this event is fired for tree accessible.
 99648:     Accessible* widget =
 79384:       accessible->IsWidget() ? accessible : accessible->ContainerWidget();
 79384:     if (widget && widget->IsAutoCompletePopup()) {
 79384:       FocusMgr()->ActiveItemChanged(nsnull);
 79384:       A11YDEBUG_FOCUS_ACTIVEITEMCHANGE_CAUSE("DOMMenuItemInactive", accessible)
     1:     }
 12366:   }
 56292:   else if (eventType.EqualsLiteral("DOMMenuBarActive")) {  // Always from user input
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENU_START,
 56292:                             accessible, eFromUserInput);
 79384: 
 79384:     // Notify of active item change when menubar gets active and if it has
 79384:     // current item. This is a case of mouseover (set current menuitem) and
 79384:     // mouse click (activate the menubar). If menubar doesn't have current item
 79384:     // (can be a case of menubar activation from keyboard) then ignore this
 79384:     // notification because later we'll receive DOMMenuItemActive event after
 79384:     // current menuitem is set.
 99648:     Accessible* activeItem = accessible->CurrentItem();
 79384:     if (activeItem) {
 79384:       FocusMgr()->ActiveItemChanged(activeItem);
 79384:       A11YDEBUG_FOCUS_ACTIVEITEMCHANGE_CAUSE("DOMMenuBarActive", accessible)
 79384:     }
     1:   }
 56292:   else if (eventType.EqualsLiteral("DOMMenuBarInactive")) {  // Always from user input
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENU_END,
 56292:                             accessible, eFromUserInput);
 79384: 
 79384:     FocusMgr()->ActiveItemChanged(nsnull);
 79384:     A11YDEBUG_FOCUS_ACTIVEITEMCHANGE_CAUSE("DOMMenuBarInactive", accessible)
     1:   }
     1:   else if (eventType.EqualsLiteral("ValueChange")) {
 59161:     targetDocument->
 32196:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE,
 51377:                                  targetNode, AccEvent::eRemoveDupes);
     1:   }
 58455: #ifdef DEBUG_DRAGDROPSTART
  8862:   else if (eventType.EqualsLiteral("mouseover")) {
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_DRAGDROP_START,
 20521:                             accessible);
  8862:   }
  8862: #endif
     1: }
     1: 
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // nsAccessNode
 35523: 
 43538: void
 97643: RootAccessible::Shutdown()
     1: {
  6794:   // Called manually or by nsAccessNode::LastRelease()
 89799:   if (!PresShell())
 43538:     return;  // Already shutdown
  6794: 
 99568:   DocAccessibleWrap::Shutdown();
     1: }
     1: 
 35523: // nsIAccessible method
 75194: Relation
 97643: RootAccessible::RelationByType(PRUint32 aType)
     1: {
 75194:   if (!mDocument || aType != nsIAccessibleRelation::RELATION_EMBEDS)
 99568:     return DocAccessibleWrap::RelationByType(aType);
     1: 
 88639:   nsIDOMWindow* rootWindow = mDocument->GetWindow();
 88639:   if (rootWindow) {
 88639:     nsCOMPtr<nsIDOMWindow> contentWindow;
 88639:     rootWindow->GetContent(getter_AddRefs(contentWindow));
 88639:     if (contentWindow) {
 88639:       nsCOMPtr<nsIDOMDocument> contentDOMDocument;
 88639:       contentWindow->GetDocument(getter_AddRefs(contentDOMDocument));
 88639:       nsCOMPtr<nsIDocument> contentDocumentNode =
 88639:         do_QueryInterface(contentDOMDocument);
 88639:       if (contentDocumentNode) {
 99568:         DocAccessible* contentDocument =
 88639:           GetAccService()->GetDocAccessible(contentDocumentNode);
 88639:         if (contentDocument)
 88639:           return Relation(contentDocument);
 88639:       }
 88639:     }
 88639:   }
 88639: 
 87912:   return Relation();
     1: }
     1: 
 35523: ////////////////////////////////////////////////////////////////////////////////
 35523: // Protected members
 35523: 
 60746: void
 99648: RootAccessible::HandlePopupShownEvent(Accessible* aAccessible)
 22209: {
 87094:   roles::Role role = aAccessible->Role();
 22209: 
 87094:   if (role == roles::MENUPOPUP) {
 22209:     // Don't fire menupopup events for combobox and autocomplete lists.
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_START,
 22209:                             aAccessible);
 60746:     return;
 22209:   }
 22209: 
 87094:   if (role == roles::TOOLTIP) {
 22209:     // There is a single <xul:tooltip> node which Mozilla moves around.
 22209:     // The accessible for it stays the same no matter where it moves. 
 22209:     // AT's expect to get an EVENT_SHOW for the tooltip. 
 22209:     // In event callback the tooltip's accessible will be ready.
 37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SHOW, aAccessible);
 60746:     return;
 22209:   }
 22209: 
 87094:   if (role == roles::COMBOBOX_LIST) {
 22209:     // Fire expanded state change event for comboboxes and autocompeletes.
 99648:     Accessible* combobox = aAccessible->Parent();
 60746:     if (!combobox)
 60746:       return;
 52089: 
 87094:     roles::Role comboboxRole = combobox->Role();
 87094:     if (comboboxRole == roles::COMBOBOX || 
 87094: 	comboboxRole == roles::AUTOCOMPLETE) {
 51377:       nsRefPtr<AccEvent> event =
 80486:         new AccStateChangeEvent(combobox, states::EXPANDED, true);
 60746:       if (event)
 37282:         nsEventShell::FireEvent(event);
 60746:     }
 22209:   }
 22209: }
 22209: 
 60746: void
 97643: RootAccessible::HandlePopupHidingEvent(nsINode* aPopupNode)
 22209: {
 79384:   // Get popup accessible. There are cases when popup element isn't accessible
 79384:   // but an underlying widget is and behaves like popup, an example is
 79384:   // autocomplete popups.
 99568:   DocAccessible* document = nsAccUtils::GetDocAccessibleFor(aPopupNode);
 79384:   if (!document)
 79384:     return;
 37539: 
 99648:   Accessible* popup = document->GetAccessible(aPopupNode);
 79384:   if (!popup) {
 99648:     Accessible* popupContainer = document->GetContainerAccessible(aPopupNode);
 79384:     if (!popupContainer)
 79384:       return;
 79384: 
 99463:     PRUint32 childCount = popupContainer->ChildCount();
 99463:     for (PRUint32 idx = 0; idx < childCount; idx++) {
 99648:       Accessible* child = popupContainer->GetChildAt(idx);
 79384:       if (child->IsAutoCompletePopup()) {
 79384:         popup = child;
 79384:         break;
 79384:       }
 22209:     }
 22209: 
 79384:     // No popup no events. Focus is managed by DOM. This is a case for
 79384:     // menupopups of menus on Linux since there are no accessible for popups.
 79384:     if (!popup)
 79384:       return;
 79384:   }
 79384: 
 79384:   // In case of autocompletes and comboboxes fire state change event for
 79384:   // expanded state. Note, HTML form autocomplete isn't a subject of state
 79384:   // change event because they aren't autocompletes strictly speaking.
 79384:   // When popup closes (except nested popups and menus) then fire focus event to
 79384:   // where it was. The focus event is expected even if popup didn't take a focus.
 79384: 
 79384:   static const PRUint32 kNotifyOfFocus = 1;
 79384:   static const PRUint32 kNotifyOfState = 2;
 79384:   PRUint32 notifyOf = 0;
 79384: 
 79384:   // HTML select is target of popuphidding event. Otherwise get container
 79384:   // widget. No container widget means this is either tooltip or menupopup.
 79384:   // No events in the former case.
 99648:   Accessible* widget = nsnull;
 79384:   if (popup->IsCombobox()) {
 79384:     widget = popup;
 79384:   } else {
 79384:     widget = popup->ContainerWidget();
 79384:     if (!widget) {
 79384:       if (!popup->IsMenuPopup())
 60746:         return;
 22209: 
 79384:       widget = popup;
 79384:     }
 79384:   }
 52089: 
 79384:   if (popup->IsAutoCompletePopup()) {
 79384:     // No focus event for autocomplete because it's managed by
 79384:     // DOMMenuItemInactive events.
 79384:     if (widget->IsAutoComplete())
 79384:       notifyOf = kNotifyOfState;
 79384: 
 79384:   } else if (widget->IsCombobox()) {
 79384:     // Fire focus for active combobox, otherwise the focus is managed by DOM
 79384:     // focus notifications. Always fire state change event.
 79384:     if (widget->IsActiveWidget())
 79384:       notifyOf = kNotifyOfFocus;
 79384:     notifyOf |= kNotifyOfState;
 79384: 
 79384:   } else if (widget->IsMenuButton()) {
 79384:     // Can be a part of autocomplete.
 99648:     Accessible* compositeWidget = widget->ContainerWidget();
 79384:     if (compositeWidget && compositeWidget->IsAutoComplete()) {
 79384:       widget = compositeWidget;
 79384:       notifyOf = kNotifyOfState;
 79384:     }
 79384: 
 79384:     // Autocomplete (like searchbar) can be inactive when popup hiddens
 79384:     notifyOf |= kNotifyOfFocus;
 79384: 
 79384:   } else if (widget == popup) {
 79384:     // Top level context menus and alerts.
 79384:     // Ignore submenus and menubar. When submenu is closed then sumbenu
 79384:     // container menuitem takes a focus via DOMMenuItemActive notification.
 79384:     // For menubars processing we listen DOMMenubarActive/Inactive
 79384:     // notifications.
 79384:     notifyOf = kNotifyOfFocus;
 79384:   }
 79384: 
 79384:   // Restore focus to where it was.
 79384:   if (notifyOf & kNotifyOfFocus) {
 79384:     FocusMgr()->ActiveItemChanged(nsnull);
 79384:     A11YDEBUG_FOCUS_ACTIVEITEMCHANGE_CAUSE("popuphiding", popup)
 79384:   }
 79384: 
 79384:   // Fire expanded state change event.
 79384:   if (notifyOf & kNotifyOfState) {
 51377:     nsRefPtr<AccEvent> event =
 80486:       new AccStateChangeEvent(widget, states::EXPANDED, false);
 79384:     document->FireDelayedAccessibleEvent(event);
 22209:   }
 22209: }
 22209: 
 18844: #ifdef MOZ_XUL
 60746: void
 97643: RootAccessible::HandleTreeRowCountChangedEvent(nsIDOMEvent* aEvent,
101616:                                                XULTreeAccessible* aAccessible)
 11389: {
 11389:   nsCOMPtr<nsIDOMDataContainerEvent> dataEvent(do_QueryInterface(aEvent));
 11389:   if (!dataEvent)
 60746:     return;
 11389: 
 11389:   nsCOMPtr<nsIVariant> indexVariant;
 11389:   dataEvent->GetData(NS_LITERAL_STRING("index"),
 11389:                      getter_AddRefs(indexVariant));
 11389:   if (!indexVariant)
 60746:     return;
 11389: 
 11389:   nsCOMPtr<nsIVariant> countVariant;
 11389:   dataEvent->GetData(NS_LITERAL_STRING("count"),
 11389:                      getter_AddRefs(countVariant));
 11389:   if (!countVariant)
 60746:     return;
 11389: 
 11389:   PRInt32 index, count;
 11389:   indexVariant->GetAsInt32(&index);
 11389:   countVariant->GetAsInt32(&count);
 11389: 
 29825:   aAccessible->InvalidateCache(index, count);
 11389: }
 11389: 
 60746: void
 97643: RootAccessible::HandleTreeInvalidatedEvent(nsIDOMEvent* aEvent,
101616:                                            XULTreeAccessible* aAccessible)
 11389: {
 11389:   nsCOMPtr<nsIDOMDataContainerEvent> dataEvent(do_QueryInterface(aEvent));
 11389:   if (!dataEvent)
 60746:     return;
 11389: 
 11389:   PRInt32 startRow = 0, endRow = -1, startCol = 0, endCol = -1;
 11389: 
 11389:   nsCOMPtr<nsIVariant> startRowVariant;
 11389:   dataEvent->GetData(NS_LITERAL_STRING("startrow"),
 11389:                      getter_AddRefs(startRowVariant));
 11389:   if (startRowVariant)
 11389:     startRowVariant->GetAsInt32(&startRow);
 11389: 
 11389:   nsCOMPtr<nsIVariant> endRowVariant;
 11389:   dataEvent->GetData(NS_LITERAL_STRING("endrow"),
 11389:                      getter_AddRefs(endRowVariant));
 11389:   if (endRowVariant)
 11389:     endRowVariant->GetAsInt32(&endRow);
 11389: 
 11389:   nsCOMPtr<nsIVariant> startColVariant;
 11389:   dataEvent->GetData(NS_LITERAL_STRING("startcolumn"),
 11389:                      getter_AddRefs(startColVariant));
 11389:   if (startColVariant)
 11389:     startColVariant->GetAsInt32(&startCol);
 11389: 
 11389:   nsCOMPtr<nsIVariant> endColVariant;
 11389:   dataEvent->GetData(NS_LITERAL_STRING("endcolumn"),
 11389:                      getter_AddRefs(endColVariant));
 11389:   if (endColVariant)
 11389:     endColVariant->GetAsInt32(&endCol);
 11389: 
 29825:   aAccessible->TreeViewInvalidated(startRow, endRow, startCol, endCol);
 11389: }
 18844: #endif
