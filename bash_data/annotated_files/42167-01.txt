    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sw=2 sts=2 et cindent: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla code.
    1:  *
    1:  * The Initial Developer of the Original Code is Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Darin Fisher <darin@meer.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsThreadUtils_h__
    1: #define nsThreadUtils_h__
    1: 
    1: #include "prthread.h"
    1: #include "prinrval.h"
    1: #include "nsIThreadManager.h"
    1: #include "nsIThread.h"
    1: #include "nsIRunnable.h"
    1: #include "nsStringGlue.h"
    1: #include "nsCOMPtr.h"
42167: #include "nsAutoPtr.h"
    1: 
    1: // This is needed on some systems to prevent collisions between the symbols
    1: // appearing in xpcom_core and xpcomglue.  It may be unnecessary in the future
    1: // with better toolchain support.
    1: #ifdef MOZILLA_INTERNAL_API
    1: # define NS_NewThread NS_NewThread_P
    1: # define NS_GetCurrentThread NS_GetCurrentThread_P
    1: # define NS_GetMainThread NS_GetMainThread_P
    1: # define NS_IsMainThread NS_IsMainThread_P
    1: # define NS_DispatchToCurrentThread NS_DispatchToCurrentThread_P
    1: # define NS_DispatchToMainThread NS_DispatchToMainThread_P
    1: # define NS_ProcessPendingEvents NS_ProcessPendingEvents_P
    1: # define NS_HasPendingEvents NS_HasPendingEvents_P
    1: # define NS_ProcessNextEvent NS_ProcessNextEvent_P
    1: #endif
    1: 
    1: //-----------------------------------------------------------------------------
    1: // These methods are alternatives to the methods on nsIThreadManager, provided
    1: // for convenience.
    1: 
    1: /**
    1:  * Create a new thread, and optionally provide an initial event for the thread.
    1:  *
    1:  * @param result
    1:  *   The resulting nsIThread object.
    1:  * @param initialEvent
    1:  *   The initial event to run on this thread.  This parameter may be null.
    1:  *
    1:  * @returns NS_ERROR_INVALID_ARG
    1:  *   Indicates that the given name is not unique.
    1:  */
    1: extern NS_COM_GLUE NS_METHOD
    1: NS_NewThread(nsIThread **result, nsIRunnable *initialEvent = nsnull);
    1: 
    1: /**
    1:  * Get a reference to the current thread.
    1:  *
    1:  * @param result
    1:  *   The resulting nsIThread object.
    1:  */
    1: extern NS_COM_GLUE NS_METHOD
    1: NS_GetCurrentThread(nsIThread **result);
    1: 
    1: /**
    1:  * Get a reference to the main thread.
    1:  *
    1:  * @param result
    1:  *   The resulting nsIThread object.
    1:  */
    1: extern NS_COM_GLUE NS_METHOD
    1: NS_GetMainThread(nsIThread **result);
    1: 
34731: #if defined(MOZILLA_INTERNAL_API) && defined(XP_WIN)
34731: 
34731: NS_COM bool NS_IsMainThread();
34731: 
34731: #elif defined(MOZILLA_INTERNAL_API) && defined(NS_TLS)
34250: // This is defined in nsThreadManager.cpp and initialized to `true` for the
34250: // main thread by nsThreadManager::Init.
34250: extern NS_TLS bool gTLSIsMainThread;
34250: 
34250: #ifdef MOZ_ENABLE_LIBXUL
34250: inline bool NS_IsMainThread()
34250: {
34250:   return gTLSIsMainThread;
34250: }
34250: #else
34250: NS_COM bool NS_IsMainThread();
34250: #endif
34250: #else
    1: /**
    1:  * Test to see if the current thread is the main thread.
    1:  *
    1:  * @returns PR_TRUE if the current thread is the main thread, and PR_FALSE
    1:  * otherwise.
    1:  */
34250: extern NS_COM_GLUE bool NS_IsMainThread();
34250: #endif
    1: 
    1: /**
    1:  * Dispatch the given event to the current thread.
    1:  *
    1:  * @param event
    1:  *   The event to dispatch.
    1:  *
    1:  * @returns NS_ERROR_INVALID_ARG
    1:  *   If event is null.
    1:  */
    1: extern NS_COM_GLUE NS_METHOD
    1: NS_DispatchToCurrentThread(nsIRunnable *event);
    1: 
    1: /**
    1:  * Dispatch the given event to the main thread.
    1:  *
    1:  * @param event
    1:  *   The event to dispatch.
    1:  * @param dispatchFlags
    1:  *   The flags to pass to the main thread's dispatch method.
    1:  *
    1:  * @returns NS_ERROR_INVALID_ARG
    1:  *   If event is null.
    1:  */
    1: extern NS_COM_GLUE NS_METHOD
    1: NS_DispatchToMainThread(nsIRunnable *event,
    1:                         PRUint32 dispatchFlags = NS_DISPATCH_NORMAL);
    1: 
  261: #ifndef XPCOM_GLUE_AVOID_NSPR
    1: /**
    1:  * Process all pending events for the given thread before returning.  This
    1:  * method simply calls ProcessNextEvent on the thread while HasPendingEvents
    1:  * continues to return true and the time spent in NS_ProcessPendingEvents
    1:  * does not exceed the given timeout value.
    1:  *
    1:  * @param thread
    1:  *   The thread object for which to process pending events.  If null, then
    1:  *   events will be processed for the current thread.
    1:  * @param timeout
    1:  *   The maximum number of milliseconds to spend processing pending events.
    1:  *   Events are not pre-empted to honor this timeout.  Rather, the timeout
    1:  *   value is simply used to determine whether or not to process another event.
    1:  *   Pass PR_INTERVAL_NO_TIMEOUT to specify no timeout.
    1:  */
    1: extern NS_COM_GLUE NS_METHOD
    1: NS_ProcessPendingEvents(nsIThread *thread,
    1:                         PRIntervalTime timeout = PR_INTERVAL_NO_TIMEOUT);
  261: #endif
    1: 
    1: /**
    1:  * Shortcut for nsIThread::HasPendingEvents.
    1:  *
    1:  * It is an error to call this function when the given thread is not the
    1:  * current thread.  This function will return PR_FALSE if called from some
    1:  * other thread.
    1:  *
    1:  * @param thread
    1:  *   The current thread or null.
    1:  *
    1:  * @returns
    1:  *   A boolean value that if "true" indicates that there are pending events
    1:  *   in the current thread's event queue.
    1:  */
    1: extern NS_COM_GLUE PRBool
    1: NS_HasPendingEvents(nsIThread *thread = nsnull);
    1: 
    1: /**
    1:  * Shortcut for nsIThread::ProcessNextEvent.
    1:  *   
    1:  * It is an error to call this function when the given thread is not the
    1:  * current thread.  This function will simply return PR_FALSE if called
    1:  * from some other thread.
    1:  *
    1:  * @param thread
    1:  *   The current thread or null.
    1:  * @param mayWait
    1:  *   A boolean parameter that if "true" indicates that the method may block
    1:  *   the calling thread to wait for a pending event.
    1:  *
    1:  * @returns
    1:  *   A boolean value that if "true" indicates that an event from the current
    1:  *   thread's event queue was processed.
    1:  */
    1: extern NS_COM_GLUE PRBool
    1: NS_ProcessNextEvent(nsIThread *thread = nsnull, PRBool mayWait = PR_TRUE);
    1: 
    1: //-----------------------------------------------------------------------------
    1: // Helpers that work with nsCOMPtr:
    1: 
    1: inline already_AddRefed<nsIThread>
    1: do_GetCurrentThread() {
    1:   nsIThread *thread = nsnull;
    1:   NS_GetCurrentThread(&thread);
    1:   return already_AddRefed<nsIThread>(thread);
    1: }
    1: 
    1: inline already_AddRefed<nsIThread>
    1: do_GetMainThread() {
    1:   nsIThread *thread = nsnull;
    1:   NS_GetMainThread(&thread);
    1:   return already_AddRefed<nsIThread>(thread);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: #ifdef MOZILLA_INTERNAL_API
    1: // Fast access to the current thread.  Do not release the returned pointer!  If
    1: // you want to use this pointer from some other thread, then you will need to
    1: // AddRef it.  Otherwise, you should only consider this pointer valid from code
    1: // running on the current thread.
    1: extern NS_COM_GLUE nsIThread *NS_GetCurrentThread();
    1: #endif
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: #ifndef XPCOM_GLUE_AVOID_NSPR
    1: 
    1: #undef  IMETHOD_VISIBILITY
  261: #define IMETHOD_VISIBILITY NS_COM_GLUE
    1: 
    1: // This class is designed to be subclassed.
    1: class NS_COM_GLUE nsRunnable : public nsIRunnable
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIRUNNABLE
    1: 
    1:   nsRunnable() {
    1:   }
    1: 
    1: protected:
    1:   virtual ~nsRunnable() {
    1:   }
    1: };
    1: 
    1: #undef  IMETHOD_VISIBILITY
    1: #define IMETHOD_VISIBILITY NS_VISIBILITY_HIDDEN
    1: 
    1: // An event that can be used to call a method on a class.  The class type must
16977: // support reference counting. This event supports Revoke for use
16977: // with nsRevocableEventPtr.
41359: template <class ClassType,
41359:           typename ReturnType = void,
41359:           bool Owning = true>
    1: class nsRunnableMethod : public nsRunnable
    1: {
    1: public:
41360:   virtual void Revoke() = 0;
16977: 
25116:   // These ReturnTypeEnforcer classes set up a blacklist for return types that
25116:   // we know are not safe. The default ReturnTypeEnforcer compiles just fine but
25116:   // already_AddRefed will not.
25116:   template <typename OtherReturnType>
25116:   class ReturnTypeEnforcer
25116:   {
25116:   public:
25116:     typedef int ReturnTypeIsSafe;
25116:   };
25116: 
25116:   template <class T>
25116:   class ReturnTypeEnforcer<already_AddRefed<T> >
25116:   {
25116:     // No ReturnTypeIsSafe makes this illegal!
25116:   };
25116: 
25116:   // Make sure this return type is safe.
25116:   typedef typename ReturnTypeEnforcer<ReturnType>::ReturnTypeIsSafe check;
41360: };
25116: 
41360: template <class ClassType, bool Owning>
41360: struct nsRunnableMethodReceiver {
41360:   ClassType *mObj;
41360:   nsRunnableMethodReceiver(ClassType *obj) : mObj(obj) { NS_IF_ADDREF(mObj); }
41360:  ~nsRunnableMethodReceiver() { Revoke(); }
41360:   void Revoke() { NS_IF_RELEASE(mObj); }
41360: };
41360: 
41360: template <class ClassType>
41360: struct nsRunnableMethodReceiver<ClassType, false> {
41360:   ClassType *mObj;
41360:   nsRunnableMethodReceiver(ClassType *obj) : mObj(obj) {}
41360:   void Revoke() { mObj = nsnull; }
41360: };
41360: 
41360: template <typename Method, bool Owning> struct nsRunnableMethodTraits;
41360: 
41360: template <class C, typename R, bool Owning>
41360: struct nsRunnableMethodTraits<R (C::*)(), Owning> {
41360:   typedef C class_type;
41360:   typedef R return_type;
41360:   typedef nsRunnableMethod<C, R, Owning> base_type;
41360: };
41360: 
41360: #ifdef HAVE_STDCALL
41360: template <class C, typename R, bool Owning>
41360: struct nsRunnableMethodTraits<R (__stdcall C::*)(), Owning> {
41360:   typedef C class_type;
41360:   typedef R return_type;
41360:   typedef nsRunnableMethod<C, R, Owning> base_type;
41360: };
41360: #endif
41360: 
41360: template <typename Method, bool Owning>
41360: class nsRunnableMethodImpl
41360:   : public nsRunnableMethodTraits<Method, Owning>::base_type
41360: {
41360:   typedef typename nsRunnableMethodTraits<Method, Owning>::class_type ClassType;
41360:   nsRunnableMethodReceiver<ClassType, Owning> mReceiver;
41360:   Method mMethod;
41360: 
41360: public:
41360:   nsRunnableMethodImpl(ClassType *obj,
41360:                        Method method)
41360:     : mReceiver(obj)
41360:     , mMethod(method)
41360:   {}
41360: 
41360:   NS_IMETHOD Run() {
41360:     if (NS_LIKELY(mReceiver.mObj))
41360:       ((*mReceiver.mObj).*mMethod)();
41360:     return NS_OK;
    1:   }
    1: 
41360:   void Revoke() {
41360:     mReceiver.Revoke();
41360:   }
    1: };
    1: 
41360: // Use this template function like so:
    1: //
    1: //   nsCOMPtr<nsIRunnable> event =
41360: //     NS_NewRunnableMethod(myObject, &MyClass::HandleEvent);
    1: //   NS_DispatchToCurrentThread(event);
    1: //
41360: // Statically enforced constraints:
41360: //  - myObject must be of (or implicitly convertible to) type MyClass
    1: //  - MyClass must defined AddRef and Release methods
    1: //
41360: template<typename PtrType, typename Method>
41360: typename nsRunnableMethodTraits<Method, true>::base_type*
41360: NS_NewRunnableMethod(PtrType ptr, Method method)
41360: {
41360:   return new nsRunnableMethodImpl<Method, true>(ptr, method);
41360: }
25116: 
41360: template<typename PtrType, typename Method>
41360: typename nsRunnableMethodTraits<Method, false>::base_type*
41360: NS_NewNonOwningRunnableMethod(PtrType ptr, Method method)
25116: {
41360:   return new nsRunnableMethodImpl<Method, false>(ptr, method);
25116: }
    1: 
    1: #endif  // XPCOM_GLUE_AVOID_NSPR
    1: 
    1: // This class is designed to be used when you have an event class E that has a
    1: // pointer back to resource class R.  If R goes away while E is still pending,
    1: // then it is important to "revoke" E so that it does not try use R after R has
    1: // been destroyed.  nsRevocableEventPtr makes it easy for R to manage such
    1: // situations:
    1: //
    1: //   class R;
    1: //
    1: //   class E : public nsRunnable {
    1: //   public:
    1: //     void Revoke() {
    1: //       mResource = nsnull;
    1: //     }
    1: //   private:
    1: //     R *mResource;
    1: //   };
    1: //
    1: //   class R {
    1: //   public:
    1: //     void EventHandled() {
    1: //       mEvent.Forget();
    1: //     }
    1: //   private:
    1: //     nsRevocableEventPtr<E> mEvent;
    1: //   };
    1: //
    1: //   void R::PostEvent() {
    1: //     // Make sure any pending event is revoked.
    1: //     mEvent->Revoke();
    1: //
    1: //     nsCOMPtr<nsIRunnable> event = new E();
    1: //     if (NS_SUCCEEDED(NS_DispatchToCurrentThread(event))) {
    1: //       // Keep pointer to event so we can revoke it.
    1: //       mEvent = event;
    1: //     }
    1: //   }
    1: //
    1: //   NS_IMETHODIMP E::Run() {
    1: //     if (!mResource)
    1: //       return NS_OK;
    1: //     ...
    1: //     mResource->EventHandled();
    1: //     return NS_OK;
    1: //   }
    1: //
    1: template <class T>
    1: class nsRevocableEventPtr {
    1: public:
    1:   nsRevocableEventPtr()
    1:     : mEvent(nsnull) {
    1:   }
    1: 
    1:   ~nsRevocableEventPtr() {
    1:     Revoke();
    1:   }
    1: 
    1:   const nsRevocableEventPtr& operator=(T *event) {
42167:     if (mEvent != event) {
    1:       Revoke();
    1:       mEvent = event;
42167:     }
    1:     return *this;
    1:   }
    1: 
    1:   void Revoke() {
    1:     if (mEvent) {
    1:       mEvent->Revoke();
    1:       mEvent = nsnull;
    1:     }
    1:   }
    1: 
    1:   void Forget() {
    1:     mEvent = nsnull;
    1:   }
    1: 
    1:   PRBool IsPending() {
    1:     return mEvent != nsnull;
    1:   }
    1:   
16977:   T *get() { return mEvent; }
16977: 
    1: private:
    1:   // Not implemented
    1:   nsRevocableEventPtr(const nsRevocableEventPtr&);
    1:   nsRevocableEventPtr& operator=(const nsRevocableEventPtr&);
    1: 
42167:   nsRefPtr<T> mEvent;
    1: };
    1: 
    1: #endif  // nsThreadUtils_h__
