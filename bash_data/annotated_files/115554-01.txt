     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: 
     1: #include "nsWebShellWindow.h"
     1: 
     1: #include "nsLayoutCID.h"
     1: #include "nsContentCID.h"
     1: #include "nsIWeakReference.h"
 80401: #include "nsIContentViewer.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIURL.h"
     1: #include "nsIIOService.h"
     1: #include "nsIURL.h"
     1: #include "nsNetCID.h"
     1: #include "nsIStringBundle.h"
     1: #include "nsReadableUtils.h"
     1: 
     1: #include "nsEscape.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDOMEventTarget.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIWindowWatcher.h"
     1: 
     1: #include "nsIDOMXULElement.h"
     1: 
     1: #include "nsGUIEvent.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsIWidget.h"
108457: #include "nsIWidgetListener.h"
     1: 
     1: #include "nsIDOMCharacterData.h"
     1: #include "nsIDOMNodeList.h"
     1: 
     1: #include "nsITimer.h"
  8408: #include "nsXULPopupManager.h"
     1: 
     1: #include "prmem.h"
     1: 
     1: #include "nsIDOMXULDocument.h"
     1: 
 29018: #include "nsFocusManager.h"
     1: 
     1: #include "nsIWebProgress.h"
     1: #include "nsIWebProgressListener.h"
     1: 
     1: #include "nsIDocument.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDocumentLoaderFactory.h"
     1: #include "nsIObserverService.h"
     1: #include "prprf.h"
     1: 
 55224: #include "nsIScreenManager.h"
 55224: #include "nsIScreen.h"
 55224: 
     1: #include "nsIContent.h" // for menus
114236: #include "nsIScriptSecurityManager.h"
     1: 
     1: // For calculating size
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
     1: 
     1: #include "nsIBaseWindow.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
     1: 
     1: #include "nsIMarkupDocumentViewer.h"
106228: #include "mozilla/Attributes.h"
     1: 
 15578: #ifdef XP_MACOSX
 15578: #include "nsINativeMenuService.h"
     1: #define USE_NATIVE_MENUS
     1: #endif
     1: 
 64576: using namespace mozilla;
 64576: 
     1: /* Define Class IDs */
     1: static NS_DEFINE_CID(kWindowCID,           NS_WINDOW_CID);
     1: 
     1: #define SIZE_PERSISTENCE_TIMEOUT 500 // msec
     1: 
108991: nsWebShellWindow::nsWebShellWindow(uint32_t aChromeFlags)
 31556:   : nsXULWindow(aChromeFlags)
 64576:   , mSPTimerLock("nsWebShellWindow.mSPTimerLock")
     1: {
     1: }
     1: 
     1: 
     1: nsWebShellWindow::~nsWebShellWindow()
     1: {
 64576:   MutexAutoLock lock(mSPTimerLock);
     1:   if (mSPTimer)
     1:     mSPTimer->Cancel();
     1: }
     1: 
     1: NS_IMPL_ADDREF_INHERITED(nsWebShellWindow, nsXULWindow)
     1: NS_IMPL_RELEASE_INHERITED(nsWebShellWindow, nsXULWindow)
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsWebShellWindow)
     1:   NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
     1: NS_INTERFACE_MAP_END_INHERITING(nsXULWindow)
     1: 
     1: nsresult nsWebShellWindow::Initialize(nsIXULWindow* aParent,
 33261:                                       nsIXULWindow* aOpener,
 80433:                                       nsIURI* aUrl,
108991:                                       int32_t aInitialWidth,
108991:                                       int32_t aInitialHeight,
 79445:                                       bool aIsHiddenWindow,
     1:                                       nsWidgetInitData& widgetInitData)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIWidget> parentWidget;
     1: 
     1:   mIsHiddenWindow = aIsHiddenWindow;
     1: 
108991:   int32_t initialX = 0, initialY = 0;
 33261:   nsCOMPtr<nsIBaseWindow> base(do_QueryInterface(aOpener));
 33261:   if (base) {
 33261:     rv = base->GetPositionAndSize(&mOpenerScreenRect.x,
 33261:                                   &mOpenerScreenRect.y,
 33261:                                   &mOpenerScreenRect.width,
 33261:                                   &mOpenerScreenRect.height);
 33261:     if (NS_FAILED(rv)) {
 68639:       mOpenerScreenRect.SetEmpty();
 55224:     } else {
 55224:       initialX = mOpenerScreenRect.x;
 55224:       initialY = mOpenerScreenRect.y;
 55224:       ConstrainToOpenerScreen(&initialX, &initialY);
 33261:     }
 33261:   }
 33261: 
     1:   // XXX: need to get the default window size from prefs...
     1:   // Doesn't come from prefs... will come from CSS/XUL/RDF
 55224:   nsIntRect r(initialX, initialY, aInitialWidth, aInitialHeight);
     1:   
     1:   // Create top level window
     1:   mWindow = do_CreateInstance(kWindowCID, &rv);
     1:   if (NS_OK != rv) {
     1:     return rv;
     1:   }
     1: 
     1:   /* This next bit is troublesome. We carry two different versions of a pointer
     1:      to our parent window. One is the parent window's widget, which is passed
     1:      to our own widget. The other is a weak reference we keep here to our
     1:      parent WebShellWindow. The former is useful to the widget, and we can't
     1:      trust its treatment of the parent reference because they're platform-
     1:      specific. The latter is useful to this class.
     1:        A better implementation would be one in which the parent keeps strong
     1:      references to its children and closes them before it allows itself
     1:      to be closed. This would mimic the behaviour of OSes that support
     1:      top-level child windows in OSes that do not. Later.
     1:   */
     1:   nsCOMPtr<nsIBaseWindow> parentAsWin(do_QueryInterface(aParent));
     1:   if (parentAsWin) {
     1:     parentAsWin->GetMainWidget(getter_AddRefs(parentWidget));
     1:     mParentWindow = do_GetWeakReference(aParent);
     1:   }
     1: 
108457:   mWindow->SetWidgetListener(this);
     1:   mWindow->Create((nsIWidget *)parentWidget,          // Parent nsIWidget
106838:                   nullptr,                            // Native parent widget
     1:                   r,                                  // Widget dimensions
106838:                   nullptr,                            // Device context
     1:                   &widgetInitData);                   // Widget initialization data
     1:   mWindow->GetClientBounds(r);
 52184:   // Match the default background color of content. Important on windows
 52184:   // since we no longer use content child widgets.
 52184:   mWindow->SetBackgroundColor(NS_RGB(255,255,255));
     1: 
     1:   // Create web shell
 28078:   mDocShell = do_CreateInstance("@mozilla.org/docshell;1");
     1:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
     1: 
     1:   // Make sure to set the item type on the docshell _before_ calling
     1:   // Create() so it knows what type it is.
     1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
     1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
     1:   NS_ENSURE_SUCCESS(EnsureChromeTreeOwner(), NS_ERROR_FAILURE);
     1: 
     1:   docShellAsItem->SetTreeOwner(mChromeTreeOwner);
     1:   docShellAsItem->SetItemType(nsIDocShellTreeItem::typeChrome);
     1: 
     1:   r.x = r.y = 0;
     1:   nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
106838:   NS_ENSURE_SUCCESS(docShellAsWin->InitWindow(nullptr, mWindow, 
     1:    r.x, r.y, r.width, r.height), NS_ERROR_FAILURE);
     1:   NS_ENSURE_SUCCESS(docShellAsWin->Create(), NS_ERROR_FAILURE);
     1: 
     1:   // Attach a WebProgress listener.during initialization...
     1:   nsCOMPtr<nsIWebProgress> webProgress(do_GetInterface(mDocShell, &rv));
     1:   if (webProgress) {
     1:     webProgress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_NETWORK);
     1:   }
     1: 
114236:   // Eagerly create an about:blank content viewer with the right principal here,
114236:   // rather than letting it happening in the upcoming call to
114236:   // SetInitialPrincipalToSubject. This avoids creating the about:blank document
114236:   // and then blowing it away with a second one, which can cause problems for the
114236:   // top-level chrome window case. See bug 789773.
114236:   nsCOMPtr<nsIScriptSecurityManager> ssm =
114236:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
115554:   if (ssm) { // Sometimes this happens really early  See bug 793370.
114236:     nsCOMPtr<nsIPrincipal> principal;
114236:     ssm->GetSubjectPrincipal(getter_AddRefs(principal));
114236:     if (!principal) {
114236:       ssm->GetSystemPrincipal(getter_AddRefs(principal));
114236:     }
114236:     rv = mDocShell->CreateAboutBlankContentViewer(principal);
114236:     NS_ENSURE_SUCCESS(rv, rv);
114236:     nsCOMPtr<nsIDocument> doc = do_GetInterface(mDocShell);
114236:     NS_ENSURE_TRUE(!!doc, NS_ERROR_FAILURE);
114236:     doc->SetIsInitialDocument(true);
115554:   }
114236: 
106838:   if (nullptr != aUrl)  {
 31556:     nsCString tmpStr;
     1: 
     1:     rv = aUrl->GetSpec(tmpStr);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     NS_ConvertUTF8toUTF16 urlString(tmpStr);
     1:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
     1:     NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
     1:     rv = webNav->LoadURI(urlString.get(),
     1:                          nsIWebNavigation::LOAD_FLAGS_NONE,
106838:                          nullptr,
106838:                          nullptr,
106838:                          nullptr);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:                      
     1:   return rv;
     1: }
     1: 
108458: nsIPresShell*
108458: nsWebShellWindow::GetPresShell()
108458: {
108458:   if (!mDocShell)
108458:     return nullptr;
108458: 
108458:   nsCOMPtr<nsIPresShell> presShell;
108458:   mDocShell->GetPresShell(getter_AddRefs(presShell));
108458:   return presShell.get();
108458: }
108458: 
108457: bool
108991: nsWebShellWindow::WindowMoved(nsIWidget* aWidget, int32_t x, int32_t y)
     1: {
 82030:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 48252:   if (pm) {
108457:     nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mDocShell);
 48252:     pm->AdjustPopupsOnWindowChange(window);
 48252:   }
  8408: 
108457:   // Persist position, but not immediately, in case this OS is firing
     1:   // repeated move events as the user drags the window
108457:   SetPersistenceTimer(PAD_POSITION);
108457:   return false;
     1: }
108457: 
108457: bool
108991: nsWebShellWindow::WindowResized(nsIWidget* aWidget, int32_t aWidth, int32_t aHeight)
108457: {
 82030:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 48252:   if (pm) {
108457:     nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mDocShell);
 48252:     pm->AdjustPopupsOnWindowChange(window);
 48252:   }
  8408: 
108457:   nsCOMPtr<nsIBaseWindow> shellAsWin(do_QueryInterface(mDocShell));
108484:   if (shellAsWin) {
108457:     shellAsWin->SetPositionAndSize(0, 0, aWidth, aHeight, false);
108484:   }
108457:   // Persist size, but not immediately, in case this OS is firing
     1:   // repeated size events as the user drags the sizing handle
108457:   if (!IsLocked())
108457:     SetPersistenceTimer(PAD_POSITION | PAD_SIZE | PAD_MISC);
108457:   return true;
     1: }
     1: 
108457: bool
108457: nsWebShellWindow::RequestWindowClose(nsIWidget* aWidget)
108457: {
108457:   // Maintain a reference to this as it is about to get destroyed.
108457:   nsCOMPtr<nsIXULWindow> xulWindow(this);
     1: 
108457:   nsCOMPtr<nsPIDOMWindow> window(do_GetInterface(mDocShell));
108457:   nsCOMPtr<nsIDOMEventTarget> eventTarget = do_QueryInterface(window);
108457: 
108457:   nsCOMPtr<nsIPresShell> presShell;
108457:   mDocShell->GetPresShell(getter_AddRefs(presShell));
108457: 
108457:   if (eventTarget) {
108457:     nsRefPtr<nsPresContext> presContext = presShell->GetPresContext();
108457: 
108457:     nsEventStatus status = nsEventStatus_eIgnore;
108457:     nsMouseEvent event(true, NS_XUL_CLOSE, nullptr, nsMouseEvent::eReal);
108457:     if (NS_SUCCEEDED(eventTarget->DispatchDOMEvent(&event, nullptr, presContext, &status)) &&
108457:         status == nsEventStatus_eConsumeNoDefault)
108457:       return false;
108457:   }
108457: 
108457:   Destroy();
108457:   return false;
108457: }
108457: 
108457: void
108457: nsWebShellWindow::SizeModeChanged(nsSizeMode sizeMode)
108457: {
108457:   // An alwaysRaised (or higher) window will hide any newly opened normal
108457:   // browser windows, so here we just drop a raised window to the normal
108457:   // zlevel if it's maximized. We make no provision for automatically
108457:   // re-raising it when restored.
108457:   if (sizeMode == nsSizeMode_Maximized || sizeMode == nsSizeMode_Fullscreen) {
108991:     uint32_t zLevel;
108457:     GetZLevel(&zLevel);
108457:     if (zLevel > nsIXULWindow::normalZ)
108457:       SetZLevel(nsIXULWindow::normalZ);
108457:   }
108457:   mWindow->SetSizeMode(sizeMode);
108457: 
108457:   // Persist mode, but not immediately, because in many (all?)
     1:   // cases this will merge with the similar call in NS_SIZE and
     1:   // write the attribute values only once.
108457:   SetPersistenceTimer(PAD_MISC);
108457:   nsCOMPtr<nsPIDOMWindow> ourWindow = do_GetInterface(mDocShell);
 73680:   if (ourWindow) {
 73680:     // Let the application know if it's in fullscreen mode so it
 73680:     // can update its UI.
108457:     if (sizeMode == nsSizeMode_Fullscreen) {
 80486:       ourWindow->SetFullScreen(true);
 51548:     }
108457:     else if (sizeMode != nsSizeMode_Minimized) {
 89522:       ourWindow->SetFullScreen(false);
 89522:     }
 51548: 
 73680:     // And always fire a user-defined sizemodechange event on the window
 73680:     ourWindow->DispatchCustomEvent("sizemodechange");
 73680:   }
 73680: 
     1:   // Note the current implementation of SetSizeMode just stores
     1:   // the new state; it doesn't actually resize. So here we store
     1:   // the state and pass the event on to the OS. The day is coming
     1:   // when we'll handle the event here, and the return result will
     1:   // then need to be different.
     1: }
     1: 
108457: void
108457: nsWebShellWindow::OSToolbarButtonPressed()
108457: {
108457:   // Keep a reference as setting the chrome flags can fire events.
108457:   nsCOMPtr<nsIXULWindow> xulWindow(this);
     1: 
108457:   // rjc: don't use "nsIWebBrowserChrome::CHROME_EXTRA"
108457:   //      due to components with multiple sidebar components
108457:   //      (such as Mail/News, Addressbook, etc)... and frankly,
108457:   //      Mac IE, OmniWeb, and other Mac OS X apps all work this way
108991:   uint32_t    chromeMask = (nsIWebBrowserChrome::CHROME_TOOLBAR |
108457:                             nsIWebBrowserChrome::CHROME_LOCATIONBAR |
108457:                             nsIWebBrowserChrome::CHROME_PERSONAL_TOOLBAR);
108457: 
108457:   nsCOMPtr<nsIWebBrowserChrome> wbc(do_GetInterface(xulWindow));
108457:   if (!wbc)
108457:     return;
108457: 
108991:   uint32_t    chromeFlags, newChromeFlags = 0;
108457:   wbc->GetChromeFlags(&chromeFlags);
108457:   newChromeFlags = chromeFlags & chromeMask;
108457:   if (!newChromeFlags)    chromeFlags |= chromeMask;
108457:   else                    chromeFlags &= (~newChromeFlags);
108457:   wbc->SetChromeFlags(chromeFlags);
     1: }
     1: 
108457: bool
108457: nsWebShellWindow::ZLevelChanged(bool aImmediate, nsWindowZ *aPlacement,
108457:                                 nsIWidget* aRequestBelow, nsIWidget** aActualBelow)
108457: {
108457:   if (aActualBelow)
108457:     *aActualBelow = nullptr;
108457: 
108457:   return ConstrainToZLevel(aImmediate, aPlacement, aRequestBelow, aActualBelow);
108457: }
108457: 
108457: void
108457: nsWebShellWindow::WindowActivated()
108457: {
108457:   nsCOMPtr<nsIXULWindow> xulWindow(this);
108457: 
 29018:   // focusing the window could cause it to close, so keep a reference to it
108457:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
 29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
 29018:   if (fm && window)
 29018:     fm->WindowRaised(window);
 29018: 
108457:   if (mChromeLoaded) {
108457:     PersistentAttributesDirty(PAD_POSITION | PAD_SIZE | PAD_MISC);
108457:     SavePersistentAttributes();
108457:    }
 29018: }
     1: 
108457: void
108457: nsWebShellWindow::WindowDeactivated()
108457: {
108457:   nsCOMPtr<nsIXULWindow> xulWindow(this);
     1: 
108457:   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(mDocShell);
 29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
 29018:   if (fm && window)
 29018:     fm->WindowLowered(window);
     1: }
     1: 
     1: #ifdef USE_NATIVE_MENUS
  5946: static void LoadNativeMenus(nsIDOMDocument *aDOMDoc, nsIWidget *aParentWindow)
     1: {
     1:   // Find the menubar tag (if there is more than one, we ignore all but
     1:   // the first).
     1:   nsCOMPtr<nsIDOMNodeList> menubarElements;
     1:   aDOMDoc->GetElementsByTagNameNS(NS_LITERAL_STRING("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"),
     1:                                   NS_LITERAL_STRING("menubar"),
     1:                                   getter_AddRefs(menubarElements));
     1: 
     1:   nsCOMPtr<nsIDOMNode> menubarNode;
     1:   if (menubarElements)
     1:     menubarElements->Item(0, getter_AddRefs(menubarNode));
     1:   if (!menubarNode)
     1:     return;
     1: 
 15578:   nsCOMPtr<nsINativeMenuService> nms = do_GetService("@mozilla.org/widget/nativemenuservice;1");
 15578:   nsCOMPtr<nsIContent> menubarContent(do_QueryInterface(menubarNode));
 15578:   if (nms && menubarContent)
 15578:     nms->CreateNativeMenuBar(aParentWindow, menubarContent);
     1: }
     1: #endif
     1: 
106133: namespace mozilla {
106133: 
106228: class WebShellWindowTimerCallback MOZ_FINAL : public nsITimerCallback
106133: {
106133: public:
106133:   WebShellWindowTimerCallback(nsWebShellWindow* aWindow)
106133:     : mWindow(aWindow)
106133:   {}
106133: 
106133:   NS_DECL_ISUPPORTS
106133: 
106133:   NS_IMETHOD Notify(nsITimer* aTimer)
106133:   {
106133:     // Although this object participates in a refcount cycle (this -> mWindow
106133:     // -> mSPTimer -> this), mSPTimer is a one-shot timer and releases this
106133:     // after it fires.  So we don't need to release mWindow here.
106133: 
106133:     mWindow->FirePersistenceTimer();
106133:     return NS_OK;
106133:   }
106133: 
106133: private:
106133:   nsRefPtr<nsWebShellWindow> mWindow;
106133: };
106133: 
106133: NS_IMPL_THREADSAFE_ADDREF(WebShellWindowTimerCallback)
106133: NS_IMPL_THREADSAFE_RELEASE(WebShellWindowTimerCallback)
106133: NS_IMPL_THREADSAFE_QUERY_INTERFACE1(WebShellWindowTimerCallback,
106133:                                     nsITimerCallback)
106133: 
106133: } // namespace mozilla
106133: 
     1: void
108991: nsWebShellWindow::SetPersistenceTimer(uint32_t aDirtyFlags)
     1: {
 64576:   MutexAutoLock lock(mSPTimerLock);
 24552:   if (!mSPTimer) {
106133:     mSPTimer = do_CreateInstance("@mozilla.org/timer;1");
106133:     if (!mSPTimer) {
106133:       NS_WARNING("Couldn't create @mozilla.org/timer;1 instance?");
106133:       return;
 24552:     }
 24552:   }
106133: 
106133:   nsRefPtr<WebShellWindowTimerCallback> callback =
106133:     new WebShellWindowTimerCallback(this);
106133:   mSPTimer->InitWithCallback(callback, SIZE_PERSISTENCE_TIMEOUT,
106133:                              nsITimer::TYPE_ONE_SHOT);
106133: 
     1:   PersistentAttributesDirty(aDirtyFlags);
     1: }
     1: 
     1: void
106133: nsWebShellWindow::FirePersistenceTimer()
     1: {
106133:   MutexAutoLock lock(mSPTimerLock);
106133:   SavePersistentAttributes();
     1: }
     1: 
     1: 
     1: //----------------------------------------
     1: // nsIWebProgessListener implementation
     1: //----------------------------------------
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnProgressChange(nsIWebProgress *aProgress,
     1:                                    nsIRequest *aRequest,
108991:                                    int32_t aCurSelfProgress,
108991:                                    int32_t aMaxSelfProgress,
108991:                                    int32_t aCurTotalProgress,
108991:                                    int32_t aMaxTotalProgress)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnStateChange(nsIWebProgress *aProgress,
     1:                                 nsIRequest *aRequest,
108991:                                 uint32_t aStateFlags,
     1:                                 nsresult aStatus)
     1: {
     1:   // If the notification is not about a document finishing, then just
     1:   // ignore it...
     1:   if (!(aStateFlags & nsIWebProgressListener::STATE_STOP) || 
     1:       !(aStateFlags & nsIWebProgressListener::STATE_IS_NETWORK)) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (mChromeLoaded)
     1:     return NS_OK;
     1: 
     1:   // If this document notification is for a frame then ignore it...
     1:   nsCOMPtr<nsIDOMWindow> eventWin;
     1:   aProgress->GetDOMWindow(getter_AddRefs(eventWin));
     1:   nsCOMPtr<nsPIDOMWindow> eventPWin(do_QueryInterface(eventWin));
     1:   if (eventPWin) {
     1:     nsPIDOMWindow *rootPWin = eventPWin->GetPrivateRoot();
     1:     if (eventPWin != rootPWin)
     1:       return NS_OK;
     1:   }
     1: 
 80486:   mChromeLoaded = true;
 80486:   mLockedUntilChromeLoad = false;
     1: 
     1: #ifdef USE_NATIVE_MENUS
     1:   ///////////////////////////////
     1:   // Find the Menubar DOM  and Load the menus, hooking them up to the loaded commands
     1:   ///////////////////////////////
 80434:   nsCOMPtr<nsIContentViewer> cv;
 80434:   mDocShell->GetContentViewer(getter_AddRefs(cv));
 80434:   if (cv) {
 80434:     nsCOMPtr<nsIDOMDocument> menubarDOMDoc(do_QueryInterface(cv->GetDocument()));
     1:     if (menubarDOMDoc)
  5946:       LoadNativeMenus(menubarDOMDoc, mWindow);
 80434:   }
     1: #endif // USE_NATIVE_MENUS
     1: 
     1:   OnChromeLoaded();
     1:   LoadContentAreas();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnLocationChange(nsIWebProgress *aProgress,
     1:                                    nsIRequest *aRequest,
 82127:                                    nsIURI *aURI,
108991:                                    uint32_t aFlags)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsWebShellWindow::OnStatusChange(nsIWebProgress* aWebProgress,
     1:                                  nsIRequest* aRequest,
     1:                                  nsresult aStatus,
     1:                                  const PRUnichar* aMessage)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsWebShellWindow::OnSecurityChange(nsIWebProgress *aWebProgress,
     1:                                    nsIRequest *aRequest,
108991:                                    uint32_t state)
     1: {
     1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //----------------------------------------
     1: 
     1: // if the main document URL specified URLs for any content areas, start them loading
     1: void nsWebShellWindow::LoadContentAreas() {
     1: 
     1:   nsAutoString searchSpec;
     1: 
     1:   // fetch the chrome document URL
     1:   nsCOMPtr<nsIContentViewer> contentViewer;
     1:   // yes, it's possible for the docshell to be null even this early
     1:   // see bug 57514.
     1:   if (mDocShell)
     1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
     1:   if (contentViewer) {
 37433:     nsIDocument* doc = contentViewer->GetDocument();
 37433:     if (doc) {
     1:       nsIURI* mainURL = doc->GetDocumentURI();
     1: 
     1:       nsCOMPtr<nsIURL> url = do_QueryInterface(mainURL);
     1:       if (url) {
110974:         nsAutoCString search;
     1:         url->GetQuery(search);
     1: 
     1:         AppendUTF8toUTF16(search, searchSpec);
     1:       }
     1:     }
     1:   }
     1: 
     1:   // content URLs are specified in the search part of the URL
     1:   // as <contentareaID>=<escapedURL>[;(repeat)]
     1:   if (!searchSpec.IsEmpty()) {
108991:     int32_t     begPos,
     1:                 eqPos,
     1:                 endPos;
     1:     nsString    contentAreaID,
     1:                 contentURL;
     1:     char        *urlChar;
     1:     nsresult rv;
108991:     for (endPos = 0; endPos < (int32_t)searchSpec.Length(); ) {
     1:       // extract contentAreaID and URL substrings
     1:       begPos = endPos;
     1:       eqPos = searchSpec.FindChar('=', begPos);
     1:       if (eqPos < 0)
     1:         break;
     1: 
     1:       endPos = searchSpec.FindChar(';', eqPos);
     1:       if (endPos < 0)
     1:         endPos = searchSpec.Length();
     1:       searchSpec.Mid(contentAreaID, begPos, eqPos-begPos);
     1:       searchSpec.Mid(contentURL, eqPos+1, endPos-eqPos-1);
     1:       endPos++;
     1: 
     1:       // see if we have a docshell with a matching contentAreaID
     1:       nsCOMPtr<nsIDocShellTreeItem> content;
     1:       rv = GetContentShellById(contentAreaID.get(), getter_AddRefs(content));
     1:       if (NS_SUCCEEDED(rv) && content) {
     1:         nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(content));
     1:         if (webNav) {
     1:           urlChar = ToNewCString(contentURL);
     1:           if (urlChar) {
     1:             nsUnescape(urlChar);
     1:             contentURL.AssignWithConversion(urlChar);
     1:             webNav->LoadURI(contentURL.get(),
     1:                           nsIWebNavigation::LOAD_FLAGS_NONE,
106838:                           nullptr,
106838:                           nullptr,
106838:                           nullptr);
     1:             nsMemory::Free(urlChar);
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: /**
     1:  * ExecuteCloseHandler - Run the close handler, if any.
 80486:  * @return true iff we found a close handler to run.
     1:  */
 79445: bool nsWebShellWindow::ExecuteCloseHandler()
     1: {
     1:   /* If the event handler closes this window -- a likely scenario --
     1:      things get deleted out of order without this death grip.
     1:      (The problem may be the death grip in nsWindow::windowProc,
     1:      which forces this window's widget to remain alive longer
     1:      than it otherwise would.) */
     1:   nsCOMPtr<nsIXULWindow> kungFuDeathGrip(this);
     1: 
     1:   nsCOMPtr<nsPIDOMWindow> window(do_GetInterface(mDocShell));
 72326:   nsCOMPtr<nsIDOMEventTarget> eventTarget = do_QueryInterface(window);
     1: 
     1:   if (eventTarget) {
     1:     nsCOMPtr<nsIContentViewer> contentViewer;
     1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
 80401:     if (contentViewer) {
 39823:       nsRefPtr<nsPresContext> presContext;
 80401:       contentViewer->GetPresContext(getter_AddRefs(presContext));
     1: 
     1:       nsEventStatus status = nsEventStatus_eIgnore;
106838:       nsMouseEvent event(true, NS_XUL_CLOSE, nullptr,
     1:                          nsMouseEvent::eReal);
     1: 
     1:       nsresult rv =
106838:         eventTarget->DispatchDOMEvent(&event, nullptr, presContext, &status);
     1:       if (NS_SUCCEEDED(rv) && status == nsEventStatus_eConsumeNoDefault)
 80486:         return true;
 80486:       // else fall through and return false
     1:     }
     1:   }
     1: 
 80486:   return false;
     1: } // ExecuteCloseHandler
     1: 
108991: void nsWebShellWindow::ConstrainToOpenerScreen(int32_t* aX, int32_t* aY)
 55224: {
 55224:   if (mOpenerScreenRect.IsEmpty()) {
 55224:     *aX = *aY = 0;
 55224:     return;
 55224:   }
 55224: 
108991:   int32_t left, top, width, height;
 55224:   // Constrain initial positions to the same screen as opener
 55224:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService("@mozilla.org/gfx/screenmanager;1");
 55224:   if (screenmgr) {
 55224:     nsCOMPtr<nsIScreen> screen;
 55224:     screenmgr->ScreenForRect(mOpenerScreenRect.x, mOpenerScreenRect.y,
 55224:                              mOpenerScreenRect.width, mOpenerScreenRect.height,
 55224:                              getter_AddRefs(screen));
 55224:     if (screen) {
 55224:       screen->GetAvailRect(&left, &top, &width, &height);
 71876:       if (*aX < left || *aX > left + width) {
 55224:         *aX = left;
 55224:       }
 55224:       if (*aY < top || *aY > top + height) {
 55224:         *aY = top;
 55224:       }
 55224:     }
 55224:   }
 55224: }
 55224: 
     1: // nsIBaseWindow
     1: NS_IMETHODIMP nsWebShellWindow::Destroy()
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIWebProgress> webProgress(do_GetInterface(mDocShell, &rv));
     1:   if (webProgress) {
     1:     webProgress->RemoveProgressListener(this);
     1:   }
     1: 
     1:   nsCOMPtr<nsIXULWindow> kungFuDeathGrip(this);
 64576:   {
 64576:     MutexAutoLock lock(mSPTimerLock);
     1:     if (mSPTimer) {
     1:       mSPTimer->Cancel();
     1:       SavePersistentAttributes();
106838:       mSPTimer = nullptr;
     1:     }
     1:   }
     1:   return nsXULWindow::Destroy();
     1: }
