     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsNSSComponent.h"
     1: #include "nsCrypto.h"
     1: #include "nsKeygenHandler.h"
     1: #include "nsKeygenThread.h"
     1: #include "nsNSSCertificate.h"
     1: #include "nsNSSCertificateDB.h"
     1: #include "nsPKCS12Blob.h"
     1: #include "nsPK11TokenDB.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIMemory.h"
119832: #include "nsAutoPtr.h"
     1: #include "nsAlgorithm.h"
     1: #include "nsCRT.h"
     1: #include "prprf.h"
     1: #include "nsDOMCID.h"
     1: #include "nsIDOMWindow.h"
     1: #include "nsIDOMClassInfo.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDocument.h"
     1: #include "nsIScriptObjectPrincipal.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsDOMJSUtils.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIRunnable.h"
     1: #include "nsIWindowWatcher.h"
     1: #include "nsIPrompt.h"
     1: #include "nsIFilePicker.h"
     1: #include "nsJSPrincipals.h"
     1: #include "nsIPrincipal.h"
  8203: #include "nsIScriptSecurityManager.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsIGenKeypairInfoDlg.h"
     1: #include "nsIDOMCryptoDialogs.h"
     1: #include "nsIFormSigningDialog.h"
     1: #include "nsIJSContextStack.h"
     1: #include "jsapi.h"
     1: #include "jsdbgapi.h"
     1: #include <ctype.h>
     1: #include "nsReadableUtils.h"
     1: #include "pk11func.h"
     1: #include "keyhi.h"
     1: #include "cryptohi.h"
     1: #include "seccomon.h"
     1: #include "secerr.h"
     1: #include "sechash.h"
119832: extern "C" {
     1: #include "crmf.h"
     1: #include "pk11pqg.h"
119832: }
     1: #include "cmmf.h"
     1: #include "nssb64.h"
     1: #include "base64.h"
     1: #include "cert.h"
     1: #include "certdb.h"
     1: #include "secmod.h"
     1: #include "nsISaveAsCharset.h"
108464: #include "nsNativeCharsetUtils.h"
     1: 
     1: #include "ssl.h" // For SSL_ClearSessionCache
     1: 
     1: #include "nsNSSCleaner.h"
     1: NSSCleanupAutoPtrClass(SECKEYPrivateKey, SECKEY_DestroyPrivateKey)
     1: NSSCleanupAutoPtrClass(PK11SlotInfo, PK11_FreeSlot)
     1: NSSCleanupAutoPtrClass(CERTCertNicknames, CERT_FreeNicknames)
     1: NSSCleanupAutoPtrClass(PK11SymKey, PK11_FreeSymKey)
 80486: NSSCleanupAutoPtrClass_WithParam(PK11Context, PK11_DestroyContext, TrueParam, true)
 80486: NSSCleanupAutoPtrClass_WithParam(SECItem, SECITEM_FreeItem, TrueParam, true)
     1: 
119832: #include "nsNSSShutDown.h"
119832: #include "nsNSSCertHelper.h"
119832: 
     1: /*
     1:  * These are the most common error strings that are returned
     1:  * by the JavaScript methods in case of error.
     1:  */
     1: 
     1: #define JS_ERROR       "error:"
     1: #define JS_ERROR_INTERNAL  JS_ERROR"internalError"
     1: 
     1: #undef REPORT_INCORRECT_NUM_ARGS
     1: 
     1: #define JS_OK_ADD_MOD                      3
     1: #define JS_OK_DEL_EXTERNAL_MOD             2
     1: #define JS_OK_DEL_INTERNAL_MOD             1
     1: 
     1: #define JS_ERR_INTERNAL                   -1
     1: #define JS_ERR_USER_CANCEL_ACTION         -2
     1: #define JS_ERR_INCORRECT_NUM_OF_ARGUMENTS -3
     1: #define JS_ERR_DEL_MOD                    -4
     1: #define JS_ERR_ADD_MOD                    -5
     1: #define JS_ERR_BAD_MODULE_NAME            -6
     1: #define JS_ERR_BAD_DLL_NAME               -7
     1: #define JS_ERR_BAD_MECHANISM_FLAGS        -8
     1: #define JS_ERR_BAD_CIPHER_ENABLE_FLAGS    -9
     1: #define JS_ERR_ADD_DUPLICATE_MOD          -10
     1: 
     1: /*
     1:  * This structure is used to store information for one key generation.
     1:  * The nsCrypto::GenerateCRMFRequest method parses the inputs and then
     1:  * stores one of these structures for every key generation that happens.
     1:  * The information stored in this structure is then used to set some
     1:  * values in the CRMF request.
     1:  */
     1: typedef enum {
     1:   rsaEnc, rsaDualUse, rsaSign, rsaNonrepudiation, rsaSignNonrepudiation,
     1:   ecEnc, ecDualUse, ecSign, ecNonrepudiation, ecSignNonrepudiation,
     1:   dhEx, dsaSignNonrepudiation, dsaSign, dsaNonrepudiation, invalidKeyGen
     1: } nsKeyGenType;
     1: 
 79445: bool isECKeyGenType(nsKeyGenType kgt)
     1: {
     1:   switch (kgt)
     1:   {
     1:     case ecEnc:
     1:     case ecDualUse:
     1:     case ecSign:
     1:     case ecNonrepudiation:
     1:     case ecSignNonrepudiation:
 80486:       return true;
     1:     
     1:     default:
     1:       break;
     1:   }
     1: 
 80486:   return false;
     1: }
     1: 
     1: typedef struct nsKeyPairInfoStr {
     1:   SECKEYPublicKey  *pubKey;     /* The putlic key associated with gen'd 
     1:                                    priv key. */
     1:   SECKEYPrivateKey *privKey;    /* The private key we generated */ 
     1:   nsKeyGenType      keyGenType; /* What type of key gen are we doing.*/
     1: 
     1:   CERTCertificate *ecPopCert;
     1:                    /* null: use signing for pop
     1:                       other than null: a cert that defines EC keygen params
     1:                                        and will be used for dhMac PoP. */
     1: 
     1:   SECKEYPublicKey  *ecPopPubKey;
     1:                    /* extracted public key from ecPopCert */
     1: } nsKeyPairInfo;
     1: 
     1: 
     1: //This class is just used to pass arguments
     1: //to the nsCryptoRunnable event.
     1: class nsCryptoRunArgs : public nsISupports {
     1: public:
     1:   nsCryptoRunArgs();
     1:   virtual ~nsCryptoRunArgs();
     1:   nsCOMPtr<nsISupports> m_kungFuDeathGrip;
     1:   JSContext *m_cx;
     1:   JSObject  *m_scope;
     1:   nsCOMPtr<nsIPrincipal> m_principals;
     1:   nsXPIDLCString m_jsCallback;
     1:   NS_DECL_ISUPPORTS
     1: };
     1: 
     1: //This class is used to run the callback code
     1: //passed to crypto.generateCRMFRequest
     1: //We have to do that for backwards compatibility
     1: //reasons w/ PSM 1.x and Communciator 4.x
     1: class nsCryptoRunnable : public nsIRunnable {
     1: public:
     1:   nsCryptoRunnable(nsCryptoRunArgs *args);
     1:   virtual ~nsCryptoRunnable();
     1: 
     1:   NS_IMETHOD Run ();
     1:   NS_DECL_ISUPPORTS
     1: private:
     1:   nsCryptoRunArgs *m_args;
     1: };
     1: 
     1: 
     1: //We're going to inherit the memory passed
     1: //into us.
     1: //This class backs up an array of certificates
     1: //as an event.
     1: class nsP12Runnable : public nsIRunnable {
     1: public:
108991:   nsP12Runnable(nsIX509Cert **certArr, int32_t numCerts, nsIPK11Token *token);
     1:   virtual ~nsP12Runnable();
     1: 
     1:   NS_IMETHOD Run();
     1:   NS_DECL_ISUPPORTS
     1: private:
     1:   nsCOMPtr<nsIPK11Token> mToken;
     1:   nsIX509Cert **mCertArr;
108991:   int32_t       mNumCerts;
     1: };
     1: 
     1: // QueryInterface implementation for nsCrypto
     1: NS_INTERFACE_MAP_BEGIN(nsCrypto)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCrypto)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Crypto)
     1: NS_INTERFACE_MAP_END
     1: 
     1: NS_IMPL_ADDREF(nsCrypto)
     1: NS_IMPL_RELEASE(nsCrypto)
     1: 
     1: // QueryInterface implementation for nsCRMFObject
     1: NS_INTERFACE_MAP_BEGIN(nsCRMFObject)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCRMFObject)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CRMFObject)
     1: NS_INTERFACE_MAP_END
     1: 
     1: NS_IMPL_ADDREF(nsCRMFObject)
     1: NS_IMPL_RELEASE(nsCRMFObject)
     1: 
     1: // QueryInterface implementation for nsPkcs11
     1: NS_INTERFACE_MAP_BEGIN(nsPkcs11)
 28823:   NS_INTERFACE_MAP_ENTRY(nsIPKCS11)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
     1: NS_INTERFACE_MAP_END
     1: 
     1: NS_IMPL_ADDREF(nsPkcs11)
     1: NS_IMPL_RELEASE(nsPkcs11)
     1: 
     1: // ISupports implementation for nsCryptoRunnable
     1: NS_IMPL_ISUPPORTS1(nsCryptoRunnable, nsIRunnable)
     1: 
     1: // ISupports implementation for nsP12Runnable
     1: NS_IMPL_ISUPPORTS1(nsP12Runnable, nsIRunnable)
     1: 
     1: // ISupports implementation for nsCryptoRunArgs
     1: NS_IMPL_ISUPPORTS0(nsCryptoRunArgs)
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: nsCrypto::nsCrypto() :
 80486:   mEnableSmartCardEvents(false)
     1: {
     1: }
     1: 
     1: nsCrypto::~nsCrypto()
     1: {
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsCrypto::SetEnableSmartCardEvents(bool aEnable)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
     1:   // this has the side effect of starting the nssComponent (and initializing
     1:   // NSS) even if it isn't already going. Starting the nssComponent is a 
     1:   // prerequisite for getting smartCard events.
     1:   if (aEnable) {
     1:     nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   }
     1: 
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   mEnableSmartCardEvents = aEnable;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsCrypto::GetEnableSmartCardEvents(bool *aEnable)
     1: {
     1:   *aEnable = mEnableSmartCardEvents;
     1:   return NS_OK;
     1: }
     1: 
     1: //A quick function to let us know if the key we're trying to generate
     1: //can be escrowed.
 79445: static bool
     1: ns_can_escrow(nsKeyGenType keyGenType)
     1: {
     1:   /* For now, we only escrow rsa-encryption and ec-encryption keys. */
 79445:   return (bool)(keyGenType == rsaEnc || keyGenType == ecEnc);
     1: }
     1: 
     1: //Retrieve crypto.version so that callers know what
     1: //version of PSM this is.
     1: NS_IMETHODIMP
     1: nsCrypto::GetVersion(nsAString& aVersion)
     1: {
     1:   aVersion.Assign(NS_LITERAL_STRING(PSM_VERSION_STRING).get());
     1:   return NS_OK;
     1: }
     1: 
     1: /*
     1:  * Given an nsKeyGenType, return the PKCS11 mechanism that will
     1:  * perform the correct key generation.
     1:  */
108991: static uint32_t
     1: cryptojs_convert_to_mechanism(nsKeyGenType keyGenType)
     1: {
108991:   uint32_t retMech;
     1: 
     1:   switch (keyGenType) {
     1:   case rsaEnc:
     1:   case rsaDualUse:
     1:   case rsaSign:
     1:   case rsaNonrepudiation:
     1:   case rsaSignNonrepudiation:
     1:     retMech = CKM_RSA_PKCS_KEY_PAIR_GEN;
     1:     break;
     1:   case ecEnc:
     1:   case ecDualUse:
     1:   case ecSign:
     1:   case ecNonrepudiation:
     1:   case ecSignNonrepudiation:
     1:     retMech = CKM_EC_KEY_PAIR_GEN;
     1:     break;
     1:   case dhEx:
     1:     retMech = CKM_DH_PKCS_KEY_PAIR_GEN;
     1:     break;
     1:   case dsaSign:
     1:   case dsaSignNonrepudiation:
     1:   case dsaNonrepudiation:
     1:     retMech = CKM_DSA_KEY_PAIR_GEN;
     1:     break;
     1:   default:
     1:     retMech = CKM_INVALID_MECHANISM;
     1:   }
     1:   return retMech;
     1: }
     1: 
     1: /*
     1:  * This function converts a string read through JavaScript parameters
     1:  * and translates it to the internal enumeration representing the
     1:  * key gen type.
     1:  */
     1: static nsKeyGenType
     1: cryptojs_interpret_key_gen_type(char *keyAlg)
     1: {
     1:   char *end;
119832:   if (keyAlg == nullptr) {
     1:     return invalidKeyGen;
     1:   }
     1:   /* First let's remove all leading and trailing white space */
     1:   while (isspace(keyAlg[0])) keyAlg++;
     1:   end = strchr(keyAlg, '\0');
119832:   if (end == nullptr) {
     1:     return invalidKeyGen;
     1:   }
     1:   end--;
     1:   while (isspace(*end)) end--;
     1:   end[1] = '\0';
     1:   if (strcmp(keyAlg, "rsa-ex") == 0) {
     1:     return rsaEnc;
     1:   } else if (strcmp(keyAlg, "rsa-dual-use") == 0) {
     1:     return rsaDualUse;
     1:   } else if (strcmp(keyAlg, "rsa-sign") == 0) {
     1:     return rsaSign;
     1:   } else if (strcmp(keyAlg, "rsa-sign-nonrepudiation") == 0) {
     1:     return rsaSignNonrepudiation;
     1:   } else if (strcmp(keyAlg, "rsa-nonrepudiation") == 0) {
     1:     return rsaNonrepudiation;
     1:   } else if (strcmp(keyAlg, "ec-ex") == 0) {
     1:     return ecEnc;
     1:   } else if (strcmp(keyAlg, "ec-dual-use") == 0) {
     1:     return ecDualUse;
     1:   } else if (strcmp(keyAlg, "ec-sign") == 0) {
     1:     return ecSign;
     1:   } else if (strcmp(keyAlg, "ec-sign-nonrepudiation") == 0) {
     1:     return ecSignNonrepudiation;
     1:   } else if (strcmp(keyAlg, "ec-nonrepudiation") == 0) {
     1:     return ecNonrepudiation;
     1:   } else if (strcmp(keyAlg, "dsa-sign-nonrepudiation") == 0) {
     1:     return dsaSignNonrepudiation;
     1:   } else if (strcmp(keyAlg, "dsa-sign") ==0 ){
     1:     return dsaSign;
     1:   } else if (strcmp(keyAlg, "dsa-nonrepudiation") == 0) {
     1:     return dsaNonrepudiation;
     1:   } else if (strcmp(keyAlg, "dh-ex") == 0) {
     1:     return dhEx;
     1:   }
     1:   return invalidKeyGen;
     1: }
     1: 
     1: /* 
     1:  * input: null terminated char* pointing to (the remainder of) an
     1:  * EC key param string.
     1:  *
     1:  * bool return value, false means "no more name=value pair found",
     1:  *                    true means "found, see out params"
     1:  * 
     1:  * out param name: char * pointing to name (not zero terminated)
     1:  * out param name_len: length of found name
     1:  * out param value: char * pointing to value (not zero terminated)
     1:  * out param value_len: length of found value
     1:  * out param next_pair: to be used for a follow up call to this function
     1:  */
     1: 
 79445: bool getNextNameValueFromECKeygenParamString(char *input,
     1:                                                char *&name,
     1:                                                int &name_len,
     1:                                                char *&value,
     1:                                                int &value_len,
     1:                                                char *&next_call)
     1: {
     1:   if (!input || !*input)
 80486:     return false;
     1: 
     1:   // we allow leading ; and leading space in front of each name value pair
     1: 
     1:   while (*input && *input == ';')
     1:     ++input;
     1: 
     1:   while (*input && *input == ' ')
     1:     ++input;
     1: 
     1:   name = input;
     1: 
     1:   while (*input && *input != '=')
     1:     ++input;
     1: 
     1:   if (*input != '=')
 80486:     return false;
     1: 
     1:   name_len = input - name;
     1:   ++input;
     1: 
     1:   value = input;
     1: 
     1:   while (*input && *input != ';')
     1:     ++input;
     1: 
     1:   value_len = input - value;
     1:   next_call = input;
     1: 
 80486:   return true;
     1: }
     1: 
     1: //Take the string passed into us via crypto.generateCRMFRequest
     1: //as the keygen type parameter and convert it to parameters 
     1: //we can actually pass to the PKCS#11 layer.
     1: static void*
108991: nsConvertToActualKeyGenParams(uint32_t keyGenMech, char *params,
108991:                               uint32_t paramLen, int32_t keySize,
     1:                               nsKeyPairInfo *keyPairInfo)
     1: {
106838:   void *returnParams = nullptr;
     1: 
     1: 
     1:   switch (keyGenMech) {
     1:   case CKM_RSA_PKCS_KEY_PAIR_GEN:
     1:   {
     1:     // For RSA, we don't support passing in key generation arguments from
     1:     // the JS code just yet.
     1:     if (params)
106838:       return nullptr;
     1: 
     1:     PK11RSAGenParams *rsaParams;
  3233:     rsaParams = static_cast<PK11RSAGenParams*>
  3233:                            (nsMemory::Alloc(sizeof(PK11RSAGenParams)));
     1:                               
119832:     if (rsaParams == nullptr) {
106838:       return nullptr;
     1:     }
     1:     /* I'm just taking the same parameters used in 
     1:      * certdlgs.c:GenKey
     1:      */
     1:     if (keySize > 0) {
     1:       rsaParams->keySizeInBits = keySize;
     1:     } else {
     1:       rsaParams->keySizeInBits = 1024;
     1:     }
     1:     rsaParams->pe = DEFAULT_RSA_KEYGEN_PE;
     1:     returnParams = rsaParams;
     1:     break;
     1:   }
     1:   case CKM_EC_KEY_PAIR_GEN:
     1:   {
     1:     /*
     1:      * keygen params for generating EC keys must be composed of name=value pairs,
     1:      * multiple pairs allowed, separated using semicolon ;
     1:      *
     1:      * Either param "curve" or param "popcert" must be specified.
     1:      * curve=name-of-curve
     1:      * popcert=base64-encoded-cert
     1:      *
     1:      * When both params are specified, popcert will be used.
     1:      * If no popcert param is given, or if popcert can not be decoded,
     1:      * we will fall back to the curve param.
     1:      *
     1:      * Additional name=value pairs may be defined in the future.
     1:      *
     1:      * If param popcert is present and valid, the given certificate will be used
     1:      * to determine the key generation params. In addition the certificate
     1:      * will be used to produce a dhMac based Proof of Posession,
     1:      * using the cert's public key, subject and issuer names,
     1:      * as specified in RFC 2511 section 4.3 paragraph 2 and Appendix A.
     1:      *
     1:      * If neither param popcert nor param curve could be used,
     1:      * tse a curve based on the keysize param.
     1:      * NOTE: Here keysize is used only as an indication of
     1:      * High/Medium/Low strength; elliptic curve
     1:      * cryptography uses smaller keys than RSA to provide
     1:      * equivalent security.
     1:      */
     1: 
106838:     char *curve = nullptr;
     1: 
     1:     {
     1:       // extract components of name=value list
     1: 
     1:       char *next_input = params;
106838:       char *name = nullptr;
106838:       char *value = nullptr;
     1:       int name_len = 0;
     1:       int value_len = 0;
     1:   
     1:       while (getNextNameValueFromECKeygenParamString(
     1:               next_input, name, name_len, value, value_len,
     1:               next_input))
     1:       {
     1:         if (PL_strncmp(name, "curve", NS_MIN(name_len, 5)) == 0)
     1:         {
     1:           curve = PL_strndup(value, value_len);
     1:         }
     1:         else if (PL_strncmp(name, "popcert", NS_MIN(name_len, 7)) == 0)
     1:         {
     1:           char *certstr = PL_strndup(value, value_len);
     1:           if (certstr) {
     1:             keyPairInfo->ecPopCert = CERT_ConvertAndDecodeCertificate(certstr);
     1:             PL_strfree(certstr);
     1: 
     1:             if (keyPairInfo->ecPopCert)
     1:             {
     1:               keyPairInfo->ecPopPubKey = CERT_ExtractPublicKey(keyPairInfo->ecPopCert);
     1:             }
     1:           }
     1:         }
     1:       }
     1:     }
     1: 
     1:     // first try to use the params of the provided CA cert
     1:     if (keyPairInfo->ecPopPubKey)
     1:     {
     1:       returnParams = SECITEM_DupItem(&keyPairInfo->ecPopPubKey->u.ec.DEREncodedParams);
     1:     }
     1: 
     1:     // if we did not yet find good params, do we have a curve name?
     1:     if (!returnParams && curve)
     1:     {
     1:       returnParams = decode_ec_params(curve);
     1:     }
     1: 
     1:     // if we did not yet find good params, do something based on keysize
     1:     if (!returnParams)
     1:     {
     1:       switch (keySize) {
     1:       case 512:
     1:       case 1024:
     1:           returnParams = decode_ec_params("secp256r1");
     1:           break;
     1:       case 2048:
     1:       default:
     1:           returnParams = decode_ec_params("secp384r1");
     1:           break;
     1:       }
     1:     }
     1: 
     1:     if (curve)
     1:       PL_strfree(curve);
     1: 
     1:     break;
     1:   }
     1:   case CKM_DSA_KEY_PAIR_GEN:
     1:   {
     1:     // For DSA, we don't support passing in key generation arguments from
     1:     // the JS code just yet.
     1:     if (params)
106838:       return nullptr;
106838: 
106838:     PQGParams *pqgParams = nullptr;
106838:     PQGVerify *vfy = nullptr;
     1:     SECStatus  rv;
     1:     int        index;
     1:        
     1:     index = PQG_PBITS_TO_INDEX(keySize);
     1:     if (index == -1) {
106838:       returnParams = nullptr;
     1:       break;
     1:     }
     1:     rv = PK11_PQG_ParamGen(0, &pqgParams, &vfy);
     1:     if (vfy) {
     1:       PK11_PQG_DestroyVerify(vfy);
     1:     }
     1:     if (rv != SECSuccess) {
     1:       if (pqgParams) {
     1:         PK11_PQG_DestroyParams(pqgParams);
     1:       }
106838:       return nullptr;
     1:     }
     1:     returnParams = pqgParams;
     1:     break;
     1:   }
     1:   default:
106838:     returnParams = nullptr;
     1:   }
     1:   return returnParams;
     1: }
     1: 
     1: //We need to choose which PKCS11 slot we're going to generate
     1: //the key on.  Calls the default implementation provided by
     1: //nsKeygenHandler.cpp
     1: static PK11SlotInfo*
     1: nsGetSlotForKeyGen(nsKeyGenType keyGenType, nsIInterfaceRequestor *ctx)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
108991:   uint32_t mechanism = cryptojs_convert_to_mechanism(keyGenType);
106838:   PK11SlotInfo *slot = nullptr;
     1:   nsresult rv = GetSlotWithMechanism(mechanism,ctx, &slot);
     1:   if (NS_FAILED(rv)) {
     1:     if (slot)
     1:       PK11_FreeSlot(slot);
106838:     slot = nullptr;
     1:   }
     1:   return slot;
     1: }
     1: 
     1: //Free the parameters that were passed into PK11_GenerateKeyPair
     1: //depending on the mechanism type used.
     1: static void
     1: nsFreeKeyGenParams(CK_MECHANISM_TYPE keyGenMechanism, void *params)
     1: {
     1:   switch (keyGenMechanism) {
     1:   case CKM_RSA_PKCS_KEY_PAIR_GEN:
     1:     nsMemory::Free(params);
     1:     break;
     1:   case CKM_EC_KEY_PAIR_GEN:
 80486:     SECITEM_FreeItem(reinterpret_cast<SECItem*>(params), true);
     1:     break;
     1:   case CKM_DSA_KEY_PAIR_GEN:
  3233:     PK11_PQG_DestroyParams(static_cast<PQGParams*>(params));
     1:     break;
     1:   }
     1: }
     1: 
     1: //Function that is used to generate a single key pair.
     1: //Once all the arguments have been parsed and processed, this
     1: //function gets called and takes care of actually generating
     1: //the key pair passing the appopriate parameters to the NSS
     1: //functions.
     1: static nsresult
     1: cryptojs_generateOneKeyPair(JSContext *cx, nsKeyPairInfo *keyPairInfo, 
108991:                             int32_t keySize, char *params, 
     1:                             nsIInterfaceRequestor *uiCxt,
 79445:                             PK11SlotInfo *slot, bool willEscrow)
     1:                             
     1: {
 93708:   const PK11AttrFlags sensitiveFlags = (PK11_ATTR_SENSITIVE | PK11_ATTR_PRIVATE);
 93708:   const PK11AttrFlags temporarySessionFlags = PK11_ATTR_SESSION;
 93708:   const PK11AttrFlags permanentTokenFlags = PK11_ATTR_TOKEN;
 93708:   const PK11AttrFlags extractableFlags = PK11_ATTR_EXTRACTABLE;
 93708:   
     1:   nsIGeneratingKeypairInfoDialogs * dialogs;
     1:   nsKeygenThread *KeygenRunnable = 0;
     1:   nsCOMPtr<nsIKeygenThread> runnable;
     1: 
108991:   uint32_t mechanism = cryptojs_convert_to_mechanism(keyPairInfo->keyGenType);
     1:   void *keyGenParams = nsConvertToActualKeyGenParams(mechanism, params, 
     1:                                                      (params) ? strlen(params):0, 
     1:                                                      keySize, keyPairInfo);
     1: 
 93708:   if (!keyGenParams || !slot) {
 57892:     return NS_ERROR_INVALID_ARG;
 57892:   }
 57892: 
     1:   // Make sure the token has password already set on it before trying
     1:   // to generate the key.
     1: 
     1:   nsresult rv = setPassword(slot, uiCxt);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 80486:   if (PK11_Authenticate(slot, true, uiCxt) != SECSuccess)
     1:     return NS_ERROR_FAILURE;
     1:  
     1:   // Smart cards will not let you extract a private key once 
     1:   // it is on the smart card.  If we've been told to escrow
 93708:   // a private key that will be stored on a smart card,
 93708:   // then we'll use the following strategy to ensure we can escrow it.
 93708:   // We'll attempt to generate the key on our internal token,
 93708:   // because this is expected to avoid some problems.
 93708:   // If it works, we'll escrow, move the key to the smartcard, done.
 93708:   // If it didn't work (or the internal key doesn't support the desired
 93708:   // mechanism), then we'll attempt to generate the key on
 93708:   // the destination token, with the EXTRACTABLE flag set.
 93708:   // If it works, we'll extract, escrow, done.
 93708:   // If it failed, then we're unable to escrow and return failure.
     1:   // NOTE: We call PK11_GetInternalSlot instead of PK11_GetInternalKeySlot
     1:   //       so that the key has zero chance of being store in the
     1:   //       user's key3.db file.  Which the slot returned by
     1:   //       PK11_GetInternalKeySlot has access to and PK11_GetInternalSlot
     1:   //       does not.
106838:   PK11SlotInfo *intSlot = nullptr;
     1:   PK11SlotInfoCleaner siCleaner(intSlot);
     1:   
     1:   if (willEscrow && !PK11_IsInternal(slot)) {
     1:     intSlot = PK11_GetInternalSlot();
     1:     NS_ASSERTION(intSlot,"Couldn't get the internal slot");
 93708:     
 93708:     if (!PK11_DoesMechanism(intSlot, mechanism)) {
 93708:       // Set to null, and the subsequent code will not attempt to use it.
 93708:       PK11_FreeSlot(intSlot);
106838:       intSlot = nullptr;
 93708:     }
     1:   }
     1: 
     1:   rv = getNSSDialogs((void**)&dialogs,
     1:                      NS_GET_IID(nsIGeneratingKeypairInfoDialogs),
     1:                      NS_GENERATINGKEYPAIRINFODIALOGS_CONTRACTID);
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     KeygenRunnable = new nsKeygenThread();
     1:     if (KeygenRunnable) {
     1:       NS_ADDREF(KeygenRunnable);
     1:     }
     1:   }
     1:   
 93708:   // "firstAttemptSlot" and "secondAttemptSlot" are alternative names
 93708:   // for better code readability, we don't increase the reference counts.
 93708:   
119832:   PK11SlotInfo *firstAttemptSlot = NULL;
 93708:   PK11AttrFlags firstAttemptFlags = 0;
 93708: 
 93708:   PK11SlotInfo *secondAttemptSlot = slot;
 93708:   PK11AttrFlags secondAttemptFlags = sensitiveFlags | permanentTokenFlags;
 93708:   
 93708:   if (willEscrow) {
 93708:     secondAttemptFlags |= extractableFlags;
 93708:   }
 93708:   
 93708:   if (!intSlot || PK11_IsInternal(slot)) {
 93708:     // if we cannot use the internal slot, then there is only one attempt
 93708:     // if the destination slot is the internal slot, then there is only one attempt
 93708:     firstAttemptSlot = secondAttemptSlot;
 93708:     firstAttemptFlags = secondAttemptFlags;
119832:     secondAttemptSlot = NULL;
 93708:     secondAttemptFlags = 0;
 93708:   }
 93708:   else {
 93708:     firstAttemptSlot = intSlot;
 93708:     firstAttemptFlags = sensitiveFlags | temporarySessionFlags;
 93708:     
 93708:     // We always need the extractable flag on the first attempt,
 93708:     // because we want to move the key to another slot - ### is this correct?
 93708:     firstAttemptFlags |= extractableFlags;
 93708:   }
 93708: 
 93708:   bool mustMoveKey = false;
 93708:   
     1:   if (NS_FAILED(rv) || !KeygenRunnable) {
 93708:     /* execute key generation on this thread */
     1:     rv = NS_OK;
 93708:     
 93708:     keyPairInfo->privKey = 
 93708:       PK11_GenerateKeyPairWithFlags(firstAttemptSlot, mechanism,
 93708:                                     keyGenParams, &keyPairInfo->pubKey,
 93708:                                     firstAttemptFlags, uiCxt);
 93708:     
 93708:     if (keyPairInfo->privKey) {
 93708:       // success on first attempt
 93708:       if (secondAttemptSlot) {
 93708:         mustMoveKey = true;
 93708:       }
 93708:     }
 93708:     else {
 93708:       keyPairInfo->privKey = 
 93708:         PK11_GenerateKeyPairWithFlags(secondAttemptSlot, mechanism,
 93708:                                       keyGenParams, &keyPairInfo->pubKey,
 93708:                                       secondAttemptFlags, uiCxt);
 93708:     }
 93708:     
     1:   } else {
 93708:     /* execute key generation on separate thread */
 93708:     KeygenRunnable->SetParams( firstAttemptSlot, firstAttemptFlags,
 93708:                                secondAttemptSlot, secondAttemptFlags,
 93708:                                mechanism, keyGenParams, uiCxt );
     1: 
     1:     runnable = do_QueryInterface(KeygenRunnable);
     1: 
     1:     if (runnable) {
     1:       {
     1:         nsPSMUITracker tracker;
     1:         if (tracker.isUIForbidden()) {
     1:           rv = NS_ERROR_NOT_AVAILABLE;
     1:         }
     1:         else {
     1:           rv = dialogs->DisplayGeneratingKeypairInfo(uiCxt, runnable);
     1:           // We call join on the thread, 
     1:           // so we can be sure that no simultaneous access to the passed parameters will happen.
     1:           KeygenRunnable->Join();
     1:         }
     1:       }
     1: 
     1:       NS_RELEASE(dialogs);
     1:       if (NS_SUCCEEDED(rv)) {
119832:         PK11SlotInfo *used_slot = NULL;
 93708:         rv = KeygenRunnable->ConsumeResult(&used_slot, 
 93708:                                            &keyPairInfo->privKey, &keyPairInfo->pubKey);
 93708: 
 93708:         if (NS_SUCCEEDED(rv)) {
119832:           if ((used_slot == firstAttemptSlot) && (secondAttemptSlot != NULL)) {
 93708:             mustMoveKey = true;
     1:           }
 93708:         
 93708:           PK11_FreeSlot(used_slot);
     1:         }
     1:       }
 93708:     }
 93708:   }
 93708: 
119832:   firstAttemptSlot = NULL;
119832:   secondAttemptSlot = NULL;
     1:   
     1:   nsFreeKeyGenParams(mechanism, keyGenParams);
     1: 
     1:   if (KeygenRunnable) {
     1:     NS_RELEASE(KeygenRunnable);
     1:   }
     1: 
     1:   if (!keyPairInfo->privKey || !keyPairInfo->pubKey) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:  
     1:   //If we generated the key pair on the internal slot because the
     1:   // keys were going to be escrowed, move the keys over right now.
 93708:   if (mustMoveKey) {
 93708:     SECKEYPrivateKey *newPrivKey = PK11_LoadPrivKey(slot, 
     1:                                                     keyPairInfo->privKey,
     1:                                                     keyPairInfo->pubKey,
 80486:                                                     true, true);
     1:     SECKEYPrivateKeyCleaner pkCleaner(newPrivKey);
     1: 
     1:     if (!newPrivKey)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     // The private key is stored on the selected slot now, and the copy we
     1:     // ultimately use for escrowing when the time comes lives 
     1:     // in the internal slot.  We will delete it from that slot
     1:     // after the requests are made.  This call only gives up
     1:     // our reference to the key object and does not actually 
     1:     // physically remove it from the card itself.
     1:     // The actual delete calls are being made in the destructors
     1:     // of the cleaner helper instances.
     1:   }  
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /*
     1:  * FUNCTION: cryptojs_ReadArgsAndGenerateKey
     1:  * -------------------------------------
     1:  * INPUTS:
     1:  *  cx
     1:  *    The JSContext associated with the execution of the corresponging
     1:  *    crypto.generateCRMFRequest call
     1:  *  argv
     1:  *    A pointer to an array of JavaScript parameters passed to the
     1:  *    method crypto.generateCRMFRequest.  The array should have the
     1:  *    3 arguments keySize, "keyParams", and "keyGenAlg" mentioned in
     1:  *    the definition of crypto.generateCRMFRequest at the following
     1:  *    document http://docs.iplanet.com/docs/manuals/psm/11/cmcjavascriptapi.html 
     1:  *  keyGenType
     1:  *    A structure used to store the information about the newly created
     1:  *    key pair.
     1:  *  uiCxt
     1:  *    An interface requestor that would be used to get an nsIPrompt
     1:  *    if we need to ask the user for a password.
     1:  *  slotToUse
106838:  *    The PKCS11 slot to use for generating the key pair. If nullptr, then
     1:  *    this function should select a slot that can do the key generation 
     1:  *    from the keytype associted with the keyPairInfo, and pass it back to
     1:  *    the caller so that subsequence key generations can use the same slot. 
     1:  *  willEscrow
 80486:  *    If true, then that means we will try to escrow the generated
 80486:  *    private key when building the CRMF request.  If false, then
     1:  *    we will not try to escrow the private key.
     1:  *
     1:  * NOTES:
     1:  * This function takes care of reading a set of 3 parameters that define
     1:  * one key generation.  The argv pointer should be one that originates
     1:  * from the argv parameter passed in to the method nsCrypto::GenerateCRMFRequest.
     1:  * The function interprets the argument in the first index as an integer and
     1:  * passes that as the key size for the key generation-this parameter is
     1:  * mandatory.  The second parameter is read in as a string.  This value can
     1:  * be null in JavaScript world and everything will still work.  The third
     1:  * parameter is a mandatory string that indicates what kind of key to generate.
     1:  * There should always be 1-to-1 correspondence between the strings compared
     1:  * in the function cryptojs_interpret_key_gen_type and the strings listed in
     1:  * document at http://docs.iplanet.com/docs/manuals/psm/11/cmcjavascriptapi.html 
     1:  * under the definition of the method generateCRMFRequest, for the parameter
     1:  * "keyGenAlgN".  After reading the parameters, the function then 
     1:  * generates the key pairs passing the parameters parsed from the JavaScript i
     1:  * routine.  
     1:  *
     1:  * RETURN:
     1:  * NS_OK if creating the Key was successful.  Any other return value
     1:  * indicates an error.
     1:  */
     1: 
     1: static nsresult
     1: cryptojs_ReadArgsAndGenerateKey(JSContext *cx,
     1:                                 jsval *argv,
     1:                                 nsKeyPairInfo *keyGenType,
     1:                                 nsIInterfaceRequestor *uiCxt,
 79445:                                 PK11SlotInfo **slot, bool willEscrow)
     1: {
     1:   JSString  *jsString;
 57812:   JSAutoByteString params, keyGenAlg;
     1:   int    keySize;
     1:   nsresult  rv;
     1: 
     1:   if (!JSVAL_IS_INT(argv[0])) {
     1:     JS_ReportError(cx, "%s%s\n", JS_ERROR,
     1:                    "passed in non-integer for key size");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   keySize = JSVAL_TO_INT(argv[0]);
 57812:   if (!JSVAL_IS_NULL(argv[1])) {
     1:     jsString = JS_ValueToString(cx,argv[1]);
 12545:     NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:     argv[1] = STRING_TO_JSVAL(jsString);
 57812:     params.encode(cx, jsString);
 57812:     NS_ENSURE_TRUE(!!params, NS_ERROR_OUT_OF_MEMORY);
     1:   }
     1: 
     1:   if (JSVAL_IS_NULL(argv[2])) {
     1:     JS_ReportError(cx,"%s%s\n", JS_ERROR,
     1:              "key generation type not specified");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   jsString = JS_ValueToString(cx, argv[2]);
 12545:   NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:   argv[2] = STRING_TO_JSVAL(jsString);
 57812:   keyGenAlg.encode(cx, jsString);
 57812:   NS_ENSURE_TRUE(!!keyGenAlg, NS_ERROR_OUT_OF_MEMORY);
 57812:   keyGenType->keyGenType = cryptojs_interpret_key_gen_type(keyGenAlg.ptr());
     1:   if (keyGenType->keyGenType == invalidKeyGen) {
     1:     JS_ReportError(cx, "%s%s%s", JS_ERROR,
     1:                    "invalid key generation argument:",
 57812:                    keyGenAlg.ptr());
     1:     goto loser;
     1:   }
119832:   if (*slot == nullptr) {
     1:     *slot = nsGetSlotForKeyGen(keyGenType->keyGenType, uiCxt);
119832:     if (*slot == nullptr)
     1:       goto loser;
     1:   }
     1: 
 57812:   rv = cryptojs_generateOneKeyPair(cx,keyGenType,keySize,params.ptr(),uiCxt,
 57812:                                    *slot,willEscrow);
     1: 
     1:   if (rv != NS_OK) {
     1:     JS_ReportError(cx,"%s%s%s", JS_ERROR,
     1:                    "could not generate the key for algorithm ",
 57812:                    keyGenAlg.ptr());
     1:     goto loser;
     1:   }
     1:   return NS_OK;
     1: loser:
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: //Utility funciton to free up the memory used by nsKeyPairInfo
     1: //arrays.
     1: static void
     1: nsFreeKeyPairInfo(nsKeyPairInfo *keyids, int numIDs)
     1: {
     1:   NS_ASSERTION(keyids, "NULL pointer passed to nsFreeKeyPairInfo");
     1:   if (!keyids)
     1:     return;
     1:   int i;
     1:   for (i=0; i<numIDs; i++) {
     1:     if (keyids[i].pubKey)
     1:       SECKEY_DestroyPublicKey(keyids[i].pubKey);
     1:     if (keyids[i].privKey)
     1:       SECKEY_DestroyPrivateKey(keyids[i].privKey);
     1:     if (keyids[i].ecPopCert)
     1:       CERT_DestroyCertificate(keyids[i].ecPopCert);
     1:     if (keyids[i].ecPopPubKey)
     1:       SECKEY_DestroyPublicKey(keyids[i].ecPopPubKey);
     1:   }
     1:   delete []keyids;
     1: }
     1: 
     1: //Utility funciton used to free the genertaed cert request messages
     1: static void
108991: nsFreeCertReqMessages(CRMFCertReqMsg **certReqMsgs, int32_t numMessages)
     1: {
108991:   int32_t i;
     1:   for (i=0; i<numMessages && certReqMsgs[i]; i++) {
     1:     CRMF_DestroyCertReqMsg(certReqMsgs[i]);
     1:   }
     1:   delete []certReqMsgs;
     1: }
     1: 
     1: //If the form called for escrowing the private key we just generated,
     1: //this function adds all the correct elements to the request.
     1: //That consists of adding CRMFEncryptedKey to the reques as part
     1: //of the CRMFPKIArchiveOptions Control.
     1: static nsresult
     1: nsSetEscrowAuthority(CRMFCertRequest *certReq, nsKeyPairInfo *keyInfo,
     1:                      nsNSSCertificate *wrappingCert)
     1: {
     1:   if (!wrappingCert ||
     1:       CRMF_CertRequestIsControlPresent(certReq, crmfPKIArchiveOptionsControl)){
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   CERTCertificate *cert = wrappingCert->GetCert();
     1:   if (!cert)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   CRMFEncryptedKey *encrKey = 
     1:       CRMF_CreateEncryptedKeyWithEncryptedValue(keyInfo->privKey, cert);
     1:   CERT_DestroyCertificate(cert);
     1:   if (!encrKey)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   CRMFPKIArchiveOptions *archOpt = 
     1:       CRMF_CreatePKIArchiveOptions(crmfEncryptedPrivateKey, encrKey);
     1:   if (!archOpt) {
     1:     CRMF_DestroyEncryptedKey(encrKey);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   SECStatus srv = CRMF_CertRequestSetPKIArchiveOptions(certReq, archOpt);
     1:   CRMF_DestroyEncryptedKey(encrKey);
     1:   CRMF_DestroyPKIArchiveOptions(archOpt);
     1:   if (srv != SECSuccess)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //Set the Distinguished Name (Subject Name) for the cert
     1: //being requested.
     1: static nsresult
     1: nsSetDNForRequest(CRMFCertRequest *certReq, char *reqDN)
     1: {
     1:   if (!reqDN || CRMF_CertRequestIsFieldPresent(certReq, crmfSubject)) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   CERTName *subjectName = CERT_AsciiToName(reqDN);
     1:   if (!subjectName) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   SECStatus srv = CRMF_CertRequestSetTemplateField(certReq, crmfSubject,
  3233:                                                    static_cast<void*>
  3233:                                                               (subjectName));
     1:   CERT_DestroyName(subjectName);
     1:   return (srv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: //Set Registration Token Control on the request.
     1: static nsresult
     1: nsSetRegToken(CRMFCertRequest *certReq, char *regToken)
     1: {
     1:   // this should never happen, but might as well add this.
     1:   NS_ASSERTION(certReq, "A bogus certReq passed to nsSetRegToken");
     1:   if (regToken){
     1:     if (CRMF_CertRequestIsControlPresent(certReq, crmfRegTokenControl))
     1:       return NS_ERROR_FAILURE;
     1:   
     1:     SECItem src;
     1:     src.data = (unsigned char*)regToken;
     1:     src.len  = strlen(regToken);
106838:     SECItem *derEncoded = SEC_ASN1EncodeItem(nullptr, nullptr, &src, 
     1:                                         SEC_ASN1_GET(SEC_UTF8StringTemplate));
     1: 
     1:     if (!derEncoded)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     SECStatus srv = CRMF_CertRequestSetRegTokenControl(certReq, derEncoded);
 80486:     SECITEM_FreeItem(derEncoded,true);
     1:     if (srv != SECSuccess)
     1:       return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: //Set the Authenticator control on the cert reuest.  It's just
     1: //a string that gets passed along.
     1: static nsresult
     1: nsSetAuthenticator(CRMFCertRequest *certReq, char *authenticator)
     1: {
     1:   //This should never happen, but might as well check.
     1:   NS_ASSERTION(certReq, "Bogus certReq passed to nsSetAuthenticator");
     1:   if (authenticator) {
     1:     if (CRMF_CertRequestIsControlPresent(certReq, crmfAuthenticatorControl))
     1:       return NS_ERROR_FAILURE;
     1:     
     1:     SECItem src;
     1:     src.data = (unsigned char*)authenticator;
     1:     src.len  = strlen(authenticator);
106838:     SECItem *derEncoded = SEC_ASN1EncodeItem(nullptr, nullptr, &src,
     1:                                      SEC_ASN1_GET(SEC_UTF8StringTemplate));
     1:     if (!derEncoded)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     SECStatus srv = CRMF_CertRequestSetAuthenticatorControl(certReq, 
     1:                                                             derEncoded);
 80486:     SECITEM_FreeItem(derEncoded, true);
     1:     if (srv != SECSuccess)
     1:       return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // ASN1 DER encoding rules say that when encoding a BIT string,
     1: // the length in the header for the bit string is the number 
     1: // of "useful" bits in the BIT STRING.  So the function finds
     1: // it and sets accordingly for the returned item.
     1: static void
     1: nsPrepareBitStringForEncoding (SECItem *bitsmap, SECItem *value)
     1: {
     1:   unsigned char onebyte;
     1:   unsigned int i, len = 0;
     1: 
     1:   /* to prevent warning on some platform at compile time */
     1:   onebyte = '\0';
     1:   /* Get the position of the right-most turn-on bit */
     1:   for (i = 0; i < (value->len ) * 8; ++i) {
     1:     if (i % 8 == 0)
     1:       onebyte = value->data[i/8];
     1:     if (onebyte & 0x80)
     1:       len = i;
     1:     onebyte <<= 1;
     1:   }
     1: 
     1:   bitsmap->data = value->data;
     1:   /* Add one here since we work with base 1 */
     1:   bitsmap->len = len + 1;
     1: }
     1: 
     1: //This next section defines all the functions that sets the 
     1: //keyUsageExtension for all the different types of key gens
     1: //we handle.  The keyUsageExtension is just a bit flag extension
     1: //that we set in wrapper functions that call straight into
     1: //nsSetKeyUsageExtension.  There is one wrapper funciton for each
     1: //keyGenType.  The correct function will eventually be called 
     1: //by going through a switch statement based on the nsKeyGenType
     1: //in the nsKeyPairInfo struct.
     1: static nsresult
     1: nsSetKeyUsageExtension(CRMFCertRequest *crmfReq,
     1:                        unsigned char   keyUsage)
     1: {
106838:   SECItem                 *encodedExt= nullptr;
106838:   SECItem                  keyUsageValue = { (SECItemType) 0, nullptr, 0 };
106838:   SECItem                  bitsmap = { (SECItemType) 0, nullptr, 0 };
     1:   SECStatus                srv;
106838:   CRMFCertExtension       *ext = nullptr;
     1:   CRMFCertExtCreationInfo  extAddParams;
106838:   SEC_ASN1Template         bitStrTemplate = {SEC_ASN1_BIT_STRING, 0, nullptr,
     1:                                              sizeof(SECItem)};
     1: 
     1:   keyUsageValue.data = &keyUsage;
     1:   keyUsageValue.len  = 1;
     1:   nsPrepareBitStringForEncoding(&bitsmap, &keyUsageValue);
     1: 
106838:   encodedExt = SEC_ASN1EncodeItem(nullptr, nullptr, &bitsmap,&bitStrTemplate);
119832:   if (encodedExt == nullptr) {
     1:     goto loser;
     1:   }
 80486:   ext = CRMF_CreateCertExtension(SEC_OID_X509_KEY_USAGE, true, encodedExt);
119832:   if (ext == nullptr) {
     1:       goto loser;
     1:   }
     1:   extAddParams.numExtensions = 1;
     1:   extAddParams.extensions = &ext;
     1:   srv = CRMF_CertRequestSetTemplateField(crmfReq, crmfExtension,
     1:                                          &extAddParams);
     1:   if (srv != SECSuccess) {
     1:       goto loser;
     1:   }
     1:   CRMF_DestroyCertExtension(ext);
 80486:   SECITEM_FreeItem(encodedExt, true);
     1:   return NS_OK;
     1:  loser:
     1:   if (ext) {
     1:     CRMF_DestroyCertExtension(ext);
     1:   }
     1:   if (encodedExt) {
 80486:       SECITEM_FreeItem(encodedExt, true);
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: static nsresult
     1: nsSetRSADualUse(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage =   KU_DIGITAL_SIGNATURE
     1:                            | KU_NON_REPUDIATION
     1:                            | KU_KEY_ENCIPHERMENT;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetRSAKeyEx(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_KEY_ENCIPHERMENT;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetRSASign(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_DIGITAL_SIGNATURE;
     1: 
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetRSANonRepudiation(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_NON_REPUDIATION;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetRSASignNonRepudiation(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_DIGITAL_SIGNATURE |
     1:                            KU_NON_REPUDIATION;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetECDualUse(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage =   KU_DIGITAL_SIGNATURE
     1:                            | KU_NON_REPUDIATION
     1:                            | KU_KEY_AGREEMENT;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetECKeyEx(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_KEY_AGREEMENT;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetECSign(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_DIGITAL_SIGNATURE;
     1: 
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetECNonRepudiation(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_NON_REPUDIATION;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetECSignNonRepudiation(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_DIGITAL_SIGNATURE |
     1:                            KU_NON_REPUDIATION;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetDH(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_KEY_AGREEMENT;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetDSASign(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_DIGITAL_SIGNATURE;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetDSANonRepudiation(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_NON_REPUDIATION;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetDSASignNonRepudiation(CRMFCertRequest *crmfReq)
     1: {
     1:   unsigned char keyUsage = KU_DIGITAL_SIGNATURE |
     1:                            KU_NON_REPUDIATION;
     1: 
     1:   return nsSetKeyUsageExtension(crmfReq, keyUsage);
     1: }
     1: 
     1: static nsresult
     1: nsSetKeyUsageExtension(CRMFCertRequest *crmfReq, nsKeyGenType keyGenType)
     1: {
     1:   nsresult rv;
     1: 
     1:   switch (keyGenType) {
     1:   case rsaDualUse:
     1:     rv = nsSetRSADualUse(crmfReq);
     1:     break;
     1:   case rsaEnc:
     1:     rv = nsSetRSAKeyEx(crmfReq);
     1:     break;
     1:   case rsaSign:
     1:     rv = nsSetRSASign(crmfReq);
     1:     break;
     1:   case rsaNonrepudiation:
     1:     rv = nsSetRSANonRepudiation(crmfReq);
     1:     break;
     1:   case rsaSignNonrepudiation:
     1:     rv = nsSetRSASignNonRepudiation(crmfReq);
     1:     break;
     1:   case ecDualUse:
     1:     rv = nsSetECDualUse(crmfReq);
     1:     break;
     1:   case ecEnc:
     1:     rv = nsSetECKeyEx(crmfReq);
     1:     break;
     1:   case ecSign:
     1:     rv = nsSetECSign(crmfReq);
     1:     break;
     1:   case ecNonrepudiation:
     1:     rv = nsSetECNonRepudiation(crmfReq);
     1:     break;
     1:   case ecSignNonrepudiation:
     1:     rv = nsSetECSignNonRepudiation(crmfReq);
     1:     break;
     1:   case dhEx:
     1:     rv = nsSetDH(crmfReq);
     1:     break;
     1:   case dsaSign:
     1:     rv = nsSetDSASign(crmfReq);
     1:     break;
     1:   case dsaNonrepudiation:
     1:     rv = nsSetDSANonRepudiation(crmfReq);
     1:     break;
     1:   case dsaSignNonrepudiation:
     1:     rv = nsSetDSASignNonRepudiation(crmfReq);
     1:     break;
     1:   default:
     1:     rv = NS_ERROR_FAILURE;
     1:     break;
     1:   }
     1:   return rv;
     1: }
     1: 
     1: //Create a single CRMFCertRequest with all of the necessary parts 
     1: //already installed.  The request returned by this function will
     1: //have all the parts necessary and can just be added to a 
     1: //Certificate Request Message.
     1: static CRMFCertRequest*
     1: nsCreateSingleCertReq(nsKeyPairInfo *keyInfo, char *reqDN, char *regToken, 
     1:                       char *authenticator, nsNSSCertificate *wrappingCert)
     1: {
108991:   uint32_t reqID;
     1:   nsresult rv;
     1: 
     1:   //The draft says the ID of the request should be a random
     1:   //number.  We don't have a way of tracking this number
     1:   //to compare when the reply actually comes back,though.
     1:   PK11_GenerateRandom((unsigned char*)&reqID, sizeof(reqID));
     1:   CRMFCertRequest *certReq = CRMF_CreateCertRequest(reqID);
     1:   if (!certReq)
106838:     return nullptr;
     1: 
     1:   long version = SEC_CERTIFICATE_VERSION_3;
     1:   SECStatus srv;
106838:   CERTSubjectPublicKeyInfo *spki = nullptr;
     1:   srv = CRMF_CertRequestSetTemplateField(certReq, crmfVersion, &version);
     1:   if (srv != SECSuccess)
     1:     goto loser;
     1:   
     1:   spki = SECKEY_CreateSubjectPublicKeyInfo(keyInfo->pubKey);
     1:   if (!spki)
     1:     goto loser;
     1: 
     1:   srv = CRMF_CertRequestSetTemplateField(certReq, crmfPublicKey, spki);
     1:   SECKEY_DestroySubjectPublicKeyInfo(spki);
     1:   if (srv != SECSuccess)
     1:     goto loser;
     1: 
     1:   if (wrappingCert && ns_can_escrow(keyInfo->keyGenType)) {
     1:     rv = nsSetEscrowAuthority(certReq, keyInfo, wrappingCert);
     1:     if (NS_FAILED(rv))
     1:       goto loser;
     1:   }
     1:   rv = nsSetDNForRequest(certReq, reqDN);
     1:   if (NS_FAILED(rv))
     1:     goto loser;
     1: 
     1:   rv = nsSetRegToken(certReq, regToken);
     1:   if (NS_FAILED(rv))
     1:     goto loser;
     1: 
     1:   rv = nsSetAuthenticator(certReq, authenticator);
     1:   if (NS_FAILED(rv))
     1:     goto loser;
     1: 
     1:  rv = nsSetKeyUsageExtension(certReq, keyInfo->keyGenType); 
     1:   if (NS_FAILED(rv))
     1:     goto loser;
     1: 
     1:   return certReq;
     1: loser:
     1:   if (certReq) {
     1:     CRMF_DestroyCertRequest(certReq);
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: /*
     1:  * This function will set the Proof Of Possession (POP) for a request
     1:  * associated with a key pair intended to do Key Encipherment.  Currently
     1:  * this means encryption only keys.
     1:  */
     1: static nsresult
 79445: nsSetKeyEnciphermentPOP(CRMFCertReqMsg *certReqMsg, bool isEscrowed)
     1: {
     1:   SECItem       bitString;
     1:   unsigned char der[2];
     1:   SECStatus     srv;
     1: 
     1:   if (isEscrowed) {
     1:     /* For proof of possession on escrowed keys, we use the
     1:      * this Message option of POPOPrivKey and include a zero
     1:      * length bit string in the POP field.  This is OK because the encrypted
     1:      * private key already exists as part of the PKIArchiveOptions
     1:      * Control and that for all intents and purposes proves that
     1:      * we do own the private key.
     1:      */
     1:     der[0] = 0x03; /*We've got a bit string          */
     1:     der[1] = 0x00; /*We've got a 0 length bit string */
     1:     bitString.data = der;
     1:     bitString.len  = 2;
     1:     srv = CRMF_CertReqMsgSetKeyEnciphermentPOP(certReqMsg, crmfThisMessage,
     1:                                               crmfNoSubseqMess, &bitString);
     1:   } else {
     1:     /* If the encryption key is not being escrowed, then we set the 
     1:      * Proof Of Possession to be a Challenge Response mechanism.
     1:      */
     1:     srv = CRMF_CertReqMsgSetKeyEnciphermentPOP(certReqMsg,
     1:                                               crmfSubsequentMessage,
106838:                                               crmfChallengeResp, nullptr);
     1:   }
     1:   return (srv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
115027: static void
     1: nsCRMFEncoderItemCount(void *arg, const char *buf, unsigned long len);
     1: 
115027: static void
     1: nsCRMFEncoderItemStore(void *arg, const char *buf, unsigned long len);
     1: 
     1: static nsresult
     1: nsSet_EC_DHMAC_ProofOfPossession(CRMFCertReqMsg *certReqMsg, 
     1:                                  nsKeyPairInfo  *keyInfo,
     1:                                  CRMFCertRequest *certReq)
     1: {
     1:   // RFC 2511 Appendix A section 2 a) defines,
     1:   // the "text" input for HMAC shall be the DER encoded version of
     1:   // of the single cert request.
     1:   // We'll produce that encoding and destroy it afterwards,
     1:   // because when sending the complete package to the CA,
     1:   // we'll use a different encoding, one that includes POP and
     1:   // allows multiple requests to be sent in one step.
     1: 
     1:   unsigned long der_request_len = 0;
119832:   SECItem *der_request = NULL;
     1:   SECItemCleanerTrueParam der_request_cleaner(der_request);
     1: 
     1:   if (SECSuccess != CRMF_EncodeCertRequest(certReq, 
     1:                                            nsCRMFEncoderItemCount, 
     1:                                            &der_request_len))
     1:     return NS_ERROR_FAILURE;
     1: 
106838:   der_request = SECITEM_AllocItem(nullptr, nullptr, der_request_len);
     1:   if (!der_request)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // set len in returned SECItem back to zero, because it will
     1:   // be used as the destination offset inside the 
     1:   // nsCRMFEncoderItemStore callback.
     1: 
     1:   der_request->len = 0;
     1: 
     1:   if (SECSuccess != CRMF_EncodeCertRequest(certReq, 
     1:                                            nsCRMFEncoderItemStore, 
     1:                                            der_request))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // RFC 2511 Appendix A section 2 c):
     1:   // "A key K is derived from the shared secret Kec and the subject and
     1:   //  issuer names in the CA's certificate as follows:
     1:   //  K = SHA1(DER-encoded-subjectName | Kec | DER-encoded-issuerName)"
     1: 
119832:   PK11SymKey *shared_secret = NULL;
     1:   PK11SymKeyCleaner shared_secret_cleaner(shared_secret);
     1: 
119832:   PK11SymKey *subject_and_secret = NULL;
     1:   PK11SymKeyCleaner subject_and_secret_cleaner(subject_and_secret);
     1: 
119832:   PK11SymKey *subject_and_secret_and_issuer = NULL;
     1:   PK11SymKeyCleaner subject_and_secret_and_issuer_cleaner(subject_and_secret_and_issuer);
     1: 
119832:   PK11SymKey *sha1_of_subject_and_secret_and_issuer = NULL;
     1:   PK11SymKeyCleaner sha1_of_subject_and_secret_and_issuer_cleaner(sha1_of_subject_and_secret_and_issuer);
     1: 
     1:   shared_secret = 
     1:     PK11_PubDeriveWithKDF(keyInfo->privKey, // SECKEYPrivateKey *privKey
     1:                           keyInfo->ecPopPubKey,  // SECKEYPublicKey *pubKey
 79445:                           false, // bool isSender
119832:                           NULL, // SECItem *randomA
119832:                           NULL, // SECItem *randomB
     1:                           CKM_ECDH1_DERIVE, // CK_MECHANISM_TYPE derive
     1:                           CKM_CONCATENATE_DATA_AND_BASE, // CK_MECHANISM_TYPE target
     1:                           CKA_DERIVE, // CK_ATTRIBUTE_TYPE operation
     1:                           0, // int keySize
     1:                           CKD_NULL, // CK_ULONG kdf
119832:                           NULL, // SECItem *sharedData
119832:                           NULL); // void *wincx
     1: 
     1:   if (!shared_secret)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   CK_KEY_DERIVATION_STRING_DATA concat_data_base;
     1:   concat_data_base.pData = keyInfo->ecPopCert->derSubject.data;
     1:   concat_data_base.ulLen = keyInfo->ecPopCert->derSubject.len;
     1:   SECItem concat_data_base_item;
     1:   concat_data_base_item.data = (unsigned char*)&concat_data_base;
     1:   concat_data_base_item.len = sizeof(CK_KEY_DERIVATION_STRING_DATA);
     1: 
     1:   subject_and_secret =
     1:     PK11_Derive(shared_secret, // PK11SymKey *baseKey
     1:                 CKM_CONCATENATE_DATA_AND_BASE, // CK_MECHANISM_TYPE mechanism
     1:                 &concat_data_base_item, // SECItem *param
     1:                 CKM_CONCATENATE_BASE_AND_DATA, // CK_MECHANISM_TYPE target
     1:                 CKA_DERIVE, // CK_ATTRIBUTE_TYPE operation
     1:                 0); // int keySize
     1: 
     1:   if (!subject_and_secret)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   CK_KEY_DERIVATION_STRING_DATA concat_base_data;
     1:   concat_base_data.pData = keyInfo->ecPopCert->derSubject.data;
     1:   concat_base_data.ulLen = keyInfo->ecPopCert->derSubject.len;
     1:   SECItem concat_base_data_item;
     1:   concat_base_data_item.data = (unsigned char*)&concat_base_data;
     1:   concat_base_data_item.len = sizeof(CK_KEY_DERIVATION_STRING_DATA);
     1: 
     1:   subject_and_secret_and_issuer =
     1:     PK11_Derive(subject_and_secret, // PK11SymKey *baseKey
     1:                 CKM_CONCATENATE_BASE_AND_DATA, // CK_MECHANISM_TYPE mechanism
     1:                 &concat_base_data_item, // SECItem *param
     1:                 CKM_SHA1_KEY_DERIVATION, // CK_MECHANISM_TYPE target
     1:                 CKA_DERIVE, // CK_ATTRIBUTE_TYPE operation
     1:                 0); // int keySize
     1: 
     1:   if (!subject_and_secret_and_issuer)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   sha1_of_subject_and_secret_and_issuer =
     1:     PK11_Derive(subject_and_secret_and_issuer, // PK11SymKey *baseKey
     1:                 CKM_SHA1_KEY_DERIVATION, // CK_MECHANISM_TYPE mechanism
119832:                 NULL, // SECItem *param
     1:                 CKM_SHA_1_HMAC, // CK_MECHANISM_TYPE target
     1:                 CKA_SIGN, // CK_ATTRIBUTE_TYPE operation
     1:                 0); // int keySize
     1: 
     1:   if (!sha1_of_subject_and_secret_and_issuer)
     1:     return NS_ERROR_FAILURE;
     1: 
119832:   PK11Context *context = NULL;
     1:   PK11ContextCleanerTrueParam context_cleaner(context);
     1: 
     1:   SECItem ignore;
     1:   ignore.data = 0;
     1:   ignore.len = 0;
     1: 
     1:   context = 
     1:     PK11_CreateContextBySymKey(CKM_SHA_1_HMAC, // CK_MECHANISM_TYPE type
     1:                                CKA_SIGN, // CK_ATTRIBUTE_TYPE operation
     1:                                sha1_of_subject_and_secret_and_issuer, // PK11SymKey *symKey
     1:                                &ignore); // SECItem *param
     1: 
     1:   if (!context)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SECSuccess != PK11_DigestBegin(context))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SECSuccess != 
     1:       PK11_DigestOp(context, der_request->data, der_request->len))
     1:     return NS_ERROR_FAILURE;
     1: 
119832:   SECItem *result_hmac_sha1_item = NULL;
     1:   SECItemCleanerTrueParam result_hmac_sha1_item_cleaner(result_hmac_sha1_item);
     1: 
106838:   result_hmac_sha1_item = SECITEM_AllocItem(nullptr, nullptr, SHA1_LENGTH);
     1:   if (!result_hmac_sha1_item)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SECSuccess !=
     1:       PK11_DigestFinal(context, 
     1:                        result_hmac_sha1_item->data, 
     1:                        &result_hmac_sha1_item->len, 
     1:                        SHA1_LENGTH))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SECSuccess !=
     1:       CRMF_CertReqMsgSetKeyAgreementPOP(certReqMsg, crmfDHMAC,
     1:                                         crmfNoSubseqMess, result_hmac_sha1_item))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: nsSetProofOfPossession(CRMFCertReqMsg *certReqMsg, 
     1:                        nsKeyPairInfo  *keyInfo,
     1:                        CRMFCertRequest *certReq)
     1: {
     1:   // Depending on the type of cert request we'll try
     1:   // POP mechanisms in different order,
     1:   // and add the result to the cert request message.
     1:   //
     1:   // For any signing or dual use cert,
     1:   //   try signing first,
     1:   //   fall back to DHMAC if we can
     1:   //     (EC cert requests that provide keygen param "popcert"),
     1:   //   otherwise fail.
     1:   //
     1:   // For encryption only certs that get escrowed, this is sufficient.
     1:   //
     1:   // For encryption only certs, that are not being escrowed, 
     1:   //   try DHMAC if we can 
     1:   //     (EC cert requests that provide keygen param "popcert"),
     1:   //   otherwise we'll indicate challenge response should be used.
     1:   
 79445:   bool isEncryptionOnlyCertRequest = false;
 79445:   bool escrowEncryptionOnlyCert = false;
     1:   
     1:   switch (keyInfo->keyGenType)
     1:   {
     1:     case rsaEnc:
     1:     case ecEnc:
 80486:       isEncryptionOnlyCertRequest = true;
     1:       break;
     1:     
     1:     case rsaSign:
     1:     case rsaDualUse:
     1:     case rsaNonrepudiation:
     1:     case rsaSignNonrepudiation:
     1:     case ecSign:
     1:     case ecDualUse:
     1:     case ecNonrepudiation:
     1:     case ecSignNonrepudiation:
     1:     case dsaSign:
     1:     case dsaNonrepudiation:
     1:     case dsaSignNonrepudiation:
     1:       break;
     1:     
     1:     case dhEx:
     1:     /* This case may be supported in the future, but for now, we just fall 
     1:       * though to the default case and return an error for diffie-hellman keys.
     1:     */
     1:     default:
     1:       return NS_ERROR_FAILURE;
     1:   };
     1:     
     1:   if (isEncryptionOnlyCertRequest)
     1:   {
     1:     escrowEncryptionOnlyCert = 
     1:       CRMF_CertRequestIsControlPresent(certReq,crmfPKIArchiveOptionsControl);
     1:   }
     1:     
 79445:   bool gotDHMACParameters = false;
     1:   
     1:   if (isECKeyGenType(keyInfo->keyGenType) && 
     1:       keyInfo->ecPopCert && 
     1:       keyInfo->ecPopPubKey)
     1:   {
 80486:     gotDHMACParameters = true;
     1:   }
     1:   
     1:   if (isEncryptionOnlyCertRequest)
     1:   {
     1:     if (escrowEncryptionOnlyCert)
 80486:       return nsSetKeyEnciphermentPOP(certReqMsg, true); // escrowed
     1:     
     1:     if (gotDHMACParameters)
     1:       return nsSet_EC_DHMAC_ProofOfPossession(certReqMsg, keyInfo, certReq);
     1:     
 80486:     return nsSetKeyEnciphermentPOP(certReqMsg, false); // not escrowed
     1:   }
     1:   
     1:   // !isEncryptionOnlyCertRequest
     1:   
     1:   SECStatus srv = CRMF_CertReqMsgSetSignaturePOP(certReqMsg,
     1:                                                  keyInfo->privKey,
106838:                                                  keyInfo->pubKey, nullptr,
106838:                                                  nullptr, nullptr);
     1: 
     1:   if (srv == SECSuccess)
     1:     return NS_OK;
     1:   
     1:   if (!gotDHMACParameters)
     1:     return NS_ERROR_FAILURE;
     1:   
     1:   return nsSet_EC_DHMAC_ProofOfPossession(certReqMsg, keyInfo, certReq);
     1: }
     1: 
115027: static void
     1: nsCRMFEncoderItemCount(void *arg, const char *buf, unsigned long len)
     1: {
     1:   unsigned long *count = (unsigned long *)arg;
     1:   *count += len;
     1: }
     1: 
115027: static void
     1: nsCRMFEncoderItemStore(void *arg, const char *buf, unsigned long len)
     1: {
     1:   SECItem *dest = (SECItem *)arg;
     1:   memcpy(dest->data + dest->len, buf, len);
     1:   dest->len += len;
     1: }
     1: 
     1: static SECItem*
     1: nsEncodeCertReqMessages(CRMFCertReqMsg **certReqMsgs)
     1: {
     1:   unsigned long len = 0;
     1:   if (CRMF_EncodeCertReqMessages(certReqMsgs, nsCRMFEncoderItemCount, &len)
     1:       != SECSuccess) {
106838:     return nullptr;
     1:   }
     1:   SECItem *dest = (SECItem *)PORT_Alloc(sizeof(SECItem));
119832:   if (dest == nullptr) {
106838:     return nullptr;
     1:   }
     1:   dest->type = siBuffer;
     1:   dest->data = (unsigned char *)PORT_Alloc(len);
119832:   if (dest->data == nullptr) {
     1:     PORT_Free(dest);
106838:     return nullptr;
     1:   }
     1:   dest->len = 0;
     1: 
     1:   if (CRMF_EncodeCertReqMessages(certReqMsgs, nsCRMFEncoderItemStore, dest)
     1:       != SECSuccess) {
 80486:     SECITEM_FreeItem(dest, true);
106838:     return nullptr;
     1:   }
     1:   return dest;
     1: }
     1: 
     1: //Create a Base64 encoded CRMFCertReqMsg that can be sent to a CA
     1: //requesting one or more certificates to be issued.  This function
     1: //creates a single cert request per key pair and then appends it to
     1: //a message that is ultimately sent off to a CA.
     1: static char*
108991: nsCreateReqFromKeyPairs(nsKeyPairInfo *keyids, int32_t numRequests,
     1:                         char *reqDN, char *regToken, char *authenticator,
     1:                         nsNSSCertificate *wrappingCert) 
     1: {
     1:   // We'use the goto notation for clean-up purposes in this function
     1:   // that calls the C API of NSS.
108991:   int32_t i;
     1:   // The ASN1 encoder in NSS wants the last entry in the array to be
119832:   // NULL so that it knows when the last element is.
     1:   CRMFCertReqMsg **certReqMsgs = new CRMFCertReqMsg*[numRequests+1];
     1:   CRMFCertRequest *certReq;
     1:   if (!certReqMsgs)
106838:     return nullptr;
     1:   memset(certReqMsgs, 0, sizeof(CRMFCertReqMsg*)*(1+numRequests));
     1:   SECStatus srv;
     1:   nsresult rv;
     1:   SECItem *encodedReq;
     1:   char *retString;
     1:   for (i=0; i<numRequests; i++) {
     1:     certReq = nsCreateSingleCertReq(&keyids[i], reqDN, regToken, authenticator,
     1:                                     wrappingCert);
     1:     if (!certReq)
     1:       goto loser;
     1: 
     1:     certReqMsgs[i] = CRMF_CreateCertReqMsg();
     1:     if (!certReqMsgs[i])
     1:       goto loser;
     1:     srv = CRMF_CertReqMsgSetCertRequest(certReqMsgs[i], certReq);
     1:     if (srv != SECSuccess)
     1:       goto loser;
     1: 
     1:     rv = nsSetProofOfPossession(certReqMsgs[i], &keyids[i], certReq);
     1:     if (NS_FAILED(rv))
     1:       goto loser;
     1:     CRMF_DestroyCertRequest(certReq);
     1:   }
     1:   encodedReq = nsEncodeCertReqMessages(certReqMsgs);
     1:   nsFreeCertReqMessages(certReqMsgs, numRequests);
     1: 
106838:   retString = NSSBase64_EncodeItem (nullptr, nullptr, 0, encodedReq);
 80486:   SECITEM_FreeItem(encodedReq, true);
     1:   return retString;
     1: loser:
     1:   nsFreeCertReqMessages(certReqMsgs,numRequests);
106838:   return nullptr;;
     1: }
     1: 
     1: static nsISupports *
     1: GetISupportsFromContext(JSContext *cx)
     1: {
     1:     if (JS_GetOptions(cx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)
  3233:         return static_cast<nsISupports *>(JS_GetContextPrivate(cx));
     1: 
106838:     return nullptr;
     1: }
     1: 
     1: //The top level method which is a member of nsIDOMCrypto
     1: //for generate a base64 encoded CRMF request.
     1: NS_IMETHODIMP
     1: nsCrypto::GenerateCRMFRequest(nsIDOMCRMFObject** aReturn)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
106838:   *aReturn = nullptr;
     1:   nsresult nrv;
     1:   nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &nrv));
     1:   NS_ENSURE_SUCCESS(nrv, nrv);
     1: 
106838:   nsAXPCNativeCallContext *ncc = nullptr;
 10286: 
 10286:   nrv = xpc->GetCurrentNativeCallContext(&ncc);
     1:   NS_ENSURE_SUCCESS(nrv, nrv);
     1: 
     1:   if (!ncc)
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
108991:   uint32_t argc;
     1: 
     1:   ncc->GetArgc(&argc);
     1: 
106838:   jsval *argv = nullptr;
     1: 
 12545:   nrv = ncc->GetArgvPtr(&argv);
 12545:   NS_ENSURE_SUCCESS(nrv, nrv);
     1: 
     1:   JSContext *cx;
     1: 
 12545:   nrv = ncc->GetJSContext(&cx);
 12545:   NS_ENSURE_SUCCESS(nrv, nrv);
     1: 
106838:   JSObject* script_obj = nullptr;
     1:   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1: 
  6404:   JSAutoRequest ar(cx);
     1: 
     1:   /*
     1:    * Get all of the parameters.
     1:    */
     1:   if (argc < 5 || ((argc-5) % 3) != 0) {
     1:     JS_ReportError(cx, "%s", "%s%s\n", JS_ERROR,
     1:                   "incorrect number of parameters");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   
     1:   if (JSVAL_IS_NULL(argv[0])) {
     1:     JS_ReportError(cx, "%s%s\n", JS_ERROR, "no DN specified");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   
     1:   JSString *jsString = JS_ValueToString(cx,argv[0]);
 12545:   NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:   argv[0] = STRING_TO_JSVAL(jsString);
 57812:   JSAutoByteString reqDN(cx,jsString);
 57812:   NS_ENSURE_TRUE(!!reqDN, NS_ERROR_OUT_OF_MEMORY);
 57812: 
 57812:   JSAutoByteString regToken;
 57812:   if (!JSVAL_IS_NULL(argv[1])) {
     1:     jsString = JS_ValueToString(cx, argv[1]);
 12545:     NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:     argv[1] = STRING_TO_JSVAL(jsString);
 57812:     regToken.encode(cx, jsString);
 57812:     NS_ENSURE_TRUE(!!regToken, NS_ERROR_OUT_OF_MEMORY);
     1:   }
 57812:   JSAutoByteString authenticator;
 57812:   if (!JSVAL_IS_NULL(argv[2])) {
     1:     jsString      = JS_ValueToString(cx, argv[2]);
 12545:     NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:     argv[2] = STRING_TO_JSVAL(jsString);
 57812:     authenticator.encode(cx, jsString);
 57812:     NS_ENSURE_TRUE(!!authenticator, NS_ERROR_OUT_OF_MEMORY);
     1:   }
 57812:   JSAutoByteString eaCert;
 57812:   if (!JSVAL_IS_NULL(argv[3])) {
     1:     jsString     = JS_ValueToString(cx, argv[3]);
 12545:     NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:     argv[3] = STRING_TO_JSVAL(jsString);
 57812:     eaCert.encode(cx, jsString);
 57812:     NS_ENSURE_TRUE(!!eaCert, NS_ERROR_OUT_OF_MEMORY);
     1:   }
     1:   if (JSVAL_IS_NULL(argv[4])) {
     1:     JS_ReportError(cx, "%s%s\n", JS_ERROR, "no completion "
     1:                    "function specified");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   jsString = JS_ValueToString(cx, argv[4]);
 12545:   NS_ENSURE_TRUE(jsString, NS_ERROR_OUT_OF_MEMORY);
 12545:   argv[4] = STRING_TO_JSVAL(jsString);
 57812:   JSAutoByteString jsCallback(cx, jsString);
 57812:   NS_ENSURE_TRUE(!!jsCallback, NS_ERROR_OUT_OF_MEMORY);
 12545: 
     1:   nrv = xpc->WrapNative(cx, ::JS_GetGlobalObject(cx),
  3233:                         static_cast<nsIDOMCrypto *>(this),
     1:                         NS_GET_IID(nsIDOMCrypto), getter_AddRefs(holder));
     1:   NS_ENSURE_SUCCESS(nrv, nrv);
     1: 
     1:   nrv = holder->GetJSObject(&script_obj);
     1:   NS_ENSURE_SUCCESS(nrv, nrv);
     1: 
     1:   //Put up some UI warning that someone is trying to 
     1:   //escrow the private key.
     1:   //Don't addref this copy.  That way ths reference goes away
     1:   //at the same the nsIX09Cert ref goes away.
106838:   nsNSSCertificate *escrowCert = nullptr;
     1:   nsCOMPtr<nsIX509Cert> nssCert;
 79445:   bool willEscrow = false;
 57812:   if (!!eaCert) {
106838:     SECItem certDer = {siBuffer, nullptr, 0};
 57812:     SECStatus srv = ATOB_ConvertAsciiToItem(&certDer, eaCert.ptr());
     1:     if (srv != SECSuccess) {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     CERTCertificate *cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(),
106838:                                                     &certDer, nullptr, false,
 80486:                                                     true);
     1:     if (!cert)
     1:       return NS_ERROR_FAILURE;
     1: 
 56495:     escrowCert = nsNSSCertificate::Create(cert);
     1:     CERT_DestroyCertificate(cert);
     1:     nssCert = escrowCert;
     1:     if (!nssCert)
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     nsCOMPtr<nsIDOMCryptoDialogs> dialogs;
     1:     nsresult rv = getNSSDialogs(getter_AddRefs(dialogs),
     1:                                 NS_GET_IID(nsIDOMCryptoDialogs),
     1:                                 NS_DOMCRYPTODIALOGS_CONTRACTID);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
 79445:     bool okay=false;
     1:     {
     1:       nsPSMUITracker tracker;
     1:       if (tracker.isUIForbidden()) {
 80486:         okay = false;
     1:       }
     1:       else {
     1:         dialogs->ConfirmKeyEscrow(nssCert, &okay);
     1:       }
     1:     }
     1:     if (!okay)
     1:       return NS_OK;
 80486:     willEscrow = true;
     1:   }
     1:   nsCOMPtr<nsIInterfaceRequestor> uiCxt = new PipUIContext;
108991:   int32_t numRequests = (argc - 5)/3;
     1:   nsKeyPairInfo *keyids = new nsKeyPairInfo[numRequests];
119832:   if (keyids == nullptr) {
119832:     JS_ReportError(cx, "%s\n", JS_ERROR_INTERNAL);
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832:   }
     1:   memset(keyids, 0, sizeof(nsKeyPairInfo)*numRequests);
     1:   int keyInfoIndex;
108991:   uint32_t i;
106838:   PK11SlotInfo *slot = nullptr;
     1:   // Go through all of the arguments and generate the appropriate key pairs.
     1:   for (i=5,keyInfoIndex=0; i<argc; i+=3,keyInfoIndex++) {
     1:     nrv = cryptojs_ReadArgsAndGenerateKey(cx, &argv[i], &keyids[keyInfoIndex],
     1:                                          uiCxt, &slot, willEscrow);
     1:                                        
     1:     if (NS_FAILED(nrv)) {
     1:       if (slot)
     1:         PK11_FreeSlot(slot);
     1:       nsFreeKeyPairInfo(keyids,numRequests);
     1:       return nrv;
     1:     }
     1:   }
     1:   // By this time we'd better have a slot for the key gen.
     1:   NS_ASSERTION(slot, "There was no slot selected for key generation");
     1:   if (slot) 
     1:     PK11_FreeSlot(slot);
     1: 
     1:   char *encodedRequest = nsCreateReqFromKeyPairs(keyids,numRequests,
 57812:                                                  reqDN.ptr(),regToken.ptr(),
 57812:                                                  authenticator.ptr(),
 57812:                                                  escrowCert);
     1: #ifdef DEBUG_javi
     1:   printf ("Created the folloing CRMF request:\n%s\n", encodedRequest);
     1: #endif
     1:   if (!encodedRequest) {
     1:     nsFreeKeyPairInfo(keyids, numRequests);
     1:     return NS_ERROR_FAILURE;
     1:   }                                                    
     1:   nsCRMFObject *newObject = new nsCRMFObject();
119832:   if (newObject == nullptr) {
119832:     JS_ReportError(cx, "%s%s\n", JS_ERROR, "could not create crmf JS object");
119832: 
119832:     nsFreeKeyPairInfo(keyids,numRequests);
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832:   }
     1:   newObject->SetCRMFRequest(encodedRequest);
     1:   *aReturn = newObject;
     1:   //Give a reference to the returnee.
     1:   NS_ADDREF(*aReturn);
     1:   nsFreeKeyPairInfo(keyids, numRequests);
     1: 
     1:   // 
     1:   // Post an event on the UI queue so that the JS gets called after
     1:   // we return control to the JS layer.  Why do we have to this?
     1:   // Because when this API was implemented for PSM 1.x w/ Communicator,
     1:   // the only way to make this method work was to have a callback
     1:   // in the JS layer that got called after key generation had happened.
     1:   // So for backwards compatibility, we return control and then just post
     1:   // an event to call the JS the script provides as the code to execute
     1:   // when the request has been generated.
     1:   //
     1: 
     1: 
  8203:   nsCOMPtr<nsIScriptSecurityManager> secMan =
  8203:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
  8203:   NS_ENSURE_TRUE(secMan, NS_ERROR_UNEXPECTED);
  8203:   
     1:   nsCOMPtr<nsIPrincipal> principals;
 72150:   nsresult rv = secMan->GetSubjectPrincipal(getter_AddRefs(principals));
 72150:   NS_ENSURE_SUCCESS(rv, rv);
  8203:   NS_ENSURE_TRUE(principals, NS_ERROR_UNEXPECTED);
  8203:   
     1:   nsCryptoRunArgs *args = new nsCryptoRunArgs();
119832:   if (!args)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   args->m_cx         = cx;
     1:   args->m_kungFuDeathGrip = GetISupportsFromContext(cx);
 89826:   args->m_scope      = JS_GetParent(script_obj);
 57721: 
 57812:   args->m_jsCallback.Adopt(!!jsCallback ? nsCRT::strdup(jsCallback.ptr()) : 0);
     1:   args->m_principals = principals;
     1:   
     1:   nsCryptoRunnable *cryptoRunnable = new nsCryptoRunnable(args);
119832:   if (!cryptoRunnable)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
 72150:   rv = NS_DispatchToMainThread(cryptoRunnable);
     1:   if (NS_FAILED(rv))
     1:     delete cryptoRunnable;
     1: 
     1:   return rv;
     1: }
     1: 
     1: 
     1: // Reminder that we inherit the memory passed into us here.
     1: // An implementation to let us back up certs as an event.
108991: nsP12Runnable::nsP12Runnable(nsIX509Cert **certArr, int32_t numCerts,
     1:                              nsIPK11Token *token)
     1: {
     1:   mCertArr  = certArr;
     1:   mNumCerts = numCerts;
     1:   mToken = token;
     1: }
     1: 
     1: nsP12Runnable::~nsP12Runnable()
     1: {
108991:   int32_t i;
     1:   for (i=0; i<mNumCerts; i++) {
     1:       NS_IF_RELEASE(mCertArr[i]);
     1:   }
     1:   delete []mCertArr;
     1: }
     1: 
     1: 
     1: //Implementation that backs cert(s) into a PKCS12 file
     1: NS_IMETHODIMP
     1: nsP12Runnable::Run()
     1: {
 81303:   NS_ASSERTION(NS_IsMainThread(), "nsP12Runnable dispatched to the wrong thread");
 81303: 
     1:   nsNSSShutDownPreventionLock locker;
     1:   NS_ASSERTION(mCertArr, "certArr is NULL while trying to back up");
     1: 
     1:   nsString final;
     1:   nsString temp;
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   //Build up the message that let's the user know we're trying to 
     1:   //make PKCS12 backups of the new certs.
     1:   nssComponent->GetPIPNSSBundleString("ForcedBackup1", final);
     1:   final.Append(NS_LITERAL_STRING("\n\n").get());
     1:   nssComponent->GetPIPNSSBundleString("ForcedBackup2", temp);
     1:   final.Append(temp.get());
     1:   final.Append(NS_LITERAL_STRING("\n\n").get());
     1: 
     1:   nssComponent->GetPIPNSSBundleString("ForcedBackup3", temp);
     1: 
     1:   final.Append(temp.get());
 81303:   nsNSSComponent::ShowAlertWithConstructedString(final);
     1: 
     1:   nsCOMPtr<nsIFilePicker> filePicker = 
     1:                         do_CreateInstance("@mozilla.org/filepicker;1", &rv);
     1:   if (!filePicker) {
 31561:     NS_ERROR("Could not create a file picker when backing up certs.");
     1:     return rv;
     1:   }
     1: 
     1:   nsCOMPtr<nsIWindowWatcher> wwatch =
     1:     (do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMWindow> window;
     1:   wwatch->GetActiveWindow(getter_AddRefs(window));
     1: 
     1:   nsString filePickMessage;
     1:   nssComponent->GetPIPNSSBundleString("chooseP12BackupFileDialog",
     1:                                       filePickMessage);
     1:   rv = filePicker->Init(window, filePickMessage, nsIFilePicker::modeSave);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   filePicker->AppendFilter(NS_LITERAL_STRING("PKCS12"),
     1:                            NS_LITERAL_STRING("*.p12"));
     1:   filePicker->AppendFilters(nsIFilePicker::filterAll);
     1: 
108991:   int16_t dialogReturn;
     1:   filePicker->Show(&dialogReturn);
     1:   if (dialogReturn == nsIFilePicker::returnCancel)
     1:     return NS_OK;  //User canceled.  It'd be nice if they couldn't, 
     1:                    //but oh well.
     1: 
101111:   nsCOMPtr<nsIFile> localFile;
     1:   rv = filePicker->GetFile(getter_AddRefs(localFile));
     1:   if (NS_FAILED(rv))
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nsPKCS12Blob p12Cxt;
     1:   
     1:   p12Cxt.SetToken(mToken);
     1:   p12Cxt.ExportToFile(localFile, mCertArr, mNumCerts);
     1:   return NS_OK;
     1: }
     1: 
     1: nsCryptoRunArgs::nsCryptoRunArgs() 
     1: {
     1: }
     1: nsCryptoRunArgs::~nsCryptoRunArgs() {}
     1: 
     1: 
     1: nsCryptoRunnable::nsCryptoRunnable(nsCryptoRunArgs *args)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
106838:   NS_ASSERTION(args,"Passed nullptr to nsCryptoRunnable constructor.");
     1:   m_args = args;
     1:   NS_IF_ADDREF(m_args);
 47403:   JS_AddNamedObjectRoot(args->m_cx, &args->m_scope,"nsCryptoRunnable::mScope");
     1: }
     1: 
     1: nsCryptoRunnable::~nsCryptoRunnable()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
 12545: 
 12545:   {
 12545:     JSAutoRequest ar(m_args->m_cx);
 47403:     JS_RemoveObjectRoot(m_args->m_cx, &m_args->m_scope);
 12545:   }
 12545: 
     1:   NS_IF_RELEASE(m_args);
     1: }
     1: 
     1: //Implementation that runs the callback passed to 
     1: //crypto.generateCRMFRequest as an event.
     1: NS_IMETHODIMP
     1: nsCryptoRunnable::Run()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   JSContext *cx = m_args->m_cx;
     1: 
 64080:   JSAutoRequest ar(cx);
109257:   JSAutoCompartment ac(cx, m_args->m_scope);
 64080: 
     1:   // make sure the right context is on the stack. must not return w/out popping
     1:   nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
     1:   if (!stack || NS_FAILED(stack->Push(cx))) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 91900:   JSBool ok =
 91900:     JS_EvaluateScriptForPrincipals(cx, m_args->m_scope,
 91900:                                    nsJSPrincipals::get(m_args->m_principals),
     1:                                    m_args->m_jsCallback, 
     1:                                    strlen(m_args->m_jsCallback),
106838:                                    nullptr, 0, nullptr);
106838:   stack->Pop(nullptr);
 91900:   return ok ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: //Quick helper function to check if a newly issued cert
     1: //already exists in the user's database.
 79445: static bool
     1: nsCertAlreadyExists(SECItem *derCert)
     1: {
     1:   CERTCertDBHandle *handle = CERT_GetDefaultCertDB();
     1:   CERTCertificate *cert;
 79445:   bool retVal = false;
     1: 
     1:   cert = CERT_FindCertByDERCert(handle, derCert);
     1:   if (cert) {
     1:     if (cert->isperm && !cert->nickname && !cert->emailAddr) {
     1:       //If the cert doesn't have a nickname or email addr, it is
     1:       //bogus cruft, so delete it.
     1:       SEC_DeletePermCertificate(cert);
     1:     } else if (cert->isperm) {
 80486:       retVal = true;
     1:     }
     1:     CERT_DestroyCertificate(cert);
     1:   }
     1:   return retVal;
     1: }
     1: 
108991: static int32_t
     1: nsCertListCount(CERTCertList *certList)
     1: {
108991:   int32_t numCerts = 0;
     1:   CERTCertListNode *node;
     1: 
     1:   node = CERT_LIST_HEAD(certList);
     1:   while (!CERT_LIST_END(node, certList)) {
     1:     numCerts++;
     1:     node = CERT_LIST_NEXT(node);
     1:   }
     1:   return numCerts;
     1: }
     1: 
     1: 
     1: //Import user certificates that arrive as a CMMF base64 encoded
     1: //string.
     1: NS_IMETHODIMP
     1: nsCrypto::ImportUserCertificates(const nsAString& aNickname, 
     1:                                  const nsAString& aCmmfResponse, 
 79445:                                  bool aDoForcedBackup, 
     1:                                  nsAString& aReturn)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
106838:   char *nickname=nullptr, *cmmfResponse=nullptr;
106838:   CMMFCertRepContent *certRepContent = nullptr;
     1:   int numResponses = 0;
106838:   nsIX509Cert **certArr = nullptr;
     1:   int i;
     1:   CMMFCertResponse *currResponse;
     1:   CMMFPKIStatus reqStatus;
     1:   CERTCertificate *currCert;
     1:   PK11SlotInfo *slot;
110974:   nsAutoCString localNick;
     1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
     1:   nsresult rv = NS_OK;
106838:   CERTCertList *caPubs = nullptr;
     1:   nsCOMPtr<nsIPK11Token> token;
     1: 
     1:   nickname = ToNewCString(aNickname);
     1:   cmmfResponse = ToNewCString(aCmmfResponse);
     1:   if (nsCRT::strcmp("null", nickname) == 0) {
     1:     nsMemory::Free(nickname);
106838:     nickname = nullptr;
     1:   }
     1: 
106838:   SECItem cmmfDer = {siBuffer, nullptr, 0};
     1:   SECStatus srv = ATOB_ConvertAsciiToItem(&cmmfDer, cmmfResponse);
     1: 
     1:   if (srv != SECSuccess) {
     1:     rv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: 
     1:   certRepContent = CMMF_CreateCertRepContentFromDER(CERT_GetDefaultCertDB(),
     1:                                                     (const char*)cmmfDer.data,
     1:                                                     cmmfDer.len);
     1:   if (!certRepContent) {
     1:     rv = NS_ERROR_FAILURE;
     1:     goto loser;
     1:   }
     1: 
     1:   numResponses = CMMF_CertRepContentGetNumResponses(certRepContent);
     1: 
     1:   if (aDoForcedBackup) {
     1:     //We've been asked to force the user to back up these
     1:     //certificates.  Let's keep an array of them around which
     1:     //we pass along to the nsP12Runnable to use.
     1:     certArr = new nsIX509Cert*[numResponses];
     1:     // If this is NULL, chances are we're gonna fail really soon,
     1:     // but let's try to keep going just in case.
     1:     if (!certArr)
 80486:       aDoForcedBackup = false;
     1: 
     1:     memset(certArr, 0, sizeof(nsIX509Cert*)*numResponses);
     1:   }
     1:   for (i=0; i<numResponses; i++) {
     1:     currResponse = CMMF_CertRepContentGetResponseAtIndex(certRepContent,i);
     1:     if (!currResponse) {
     1:       rv = NS_ERROR_FAILURE;
     1:       goto loser;
     1:     }
     1:     reqStatus = CMMF_CertResponseGetPKIStatusInfoStatus(currResponse);
     1:     if (!(reqStatus == cmmfGranted || reqStatus == cmmfGrantedWithMods)) {
     1:       // The CA didn't give us the cert we requested.
     1:       rv = NS_ERROR_FAILURE;
     1:       goto loser;
     1:     }
     1:     currCert = CMMF_CertResponseGetCertificate(currResponse, 
     1:                                                CERT_GetDefaultCertDB());
     1:     if (!currCert) {
     1:       rv = NS_ERROR_FAILURE;
     1:       goto loser;
     1:     }
     1: 
     1:     if (nsCertAlreadyExists(&currCert->derCert)) {
     1:       if (aDoForcedBackup) {
 56495:         certArr[i] = nsNSSCertificate::Create(currCert);
 56495:         if (!certArr[i])
 56495:           goto loser;
     1:         NS_ADDREF(certArr[i]);
     1:       }
     1:       CERT_DestroyCertificate(currCert);
     1:       CMMF_DestroyCertResponse(currResponse);
     1:       continue;
     1:     }
     1:     // Let's figure out which nickname to give the cert.  If 
     1:     // a certificate with the same subject name already exists,
     1:     // then just use that one, otherwise, get the default nickname.
     1:     if (currCert->nickname) {
     1:       localNick = currCert->nickname;
     1:     }
119832:     else if (nickname == nullptr || nickname[0] == '\0') {
 15320:       nsNSSCertificateDB::get_default_nickname(currCert, ctx, localNick);
     1:     } else {
     1:       //This is the case where we're getting a brand new
     1:       //cert that doesn't have the same subjectName as a cert
     1:       //that already exists in our db and the CA page has 
     1:       //designated a nickname to use for the newly issued cert.
     1:       localNick = nickname;
     1:     }
 15320:     {
 15320:       char *cast_const_away = const_cast<char*>(localNick.get());
 15320:       slot = PK11_ImportCertForKey(currCert, cast_const_away, ctx);
     1:     }
119832:     if (slot == nullptr) {
     1:       rv = NS_ERROR_FAILURE;
     1:       goto loser;
     1:     }
     1:     if (aDoForcedBackup) {
 56495:       certArr[i] = nsNSSCertificate::Create(currCert);
 56495:       if (!certArr[i])
 56495:         goto loser;
     1:       NS_ADDREF(certArr[i]);
     1:     }
     1:     CERT_DestroyCertificate(currCert);
     1: 
     1:     if (!token)
     1:       token = new nsPK11Token(slot);
     1: 
     1:     PK11_FreeSlot(slot);
     1:     CMMF_DestroyCertResponse(currResponse);
     1:   }
     1:   //Let the loser: label take care of freeing up our reference to
     1:   //nickname (This way we don't free it twice and avoid crashing.
     1:   //That would be a good thing.
     1: 
     1:   //Import the root chain into the cert db.
     1:   caPubs = CMMF_CertRepContentGetCAPubs(certRepContent);
     1:   if (caPubs) {
108991:     int32_t numCAs = nsCertListCount(caPubs);
     1:     
     1:     NS_ASSERTION(numCAs > 0, "Invalid number of CA's");
     1:     if (numCAs > 0) {
     1:       CERTCertListNode *node;
     1:       SECItem *derCerts;
     1: 
  3233:       derCerts = static_cast<SECItem*>
  3233:                             (nsMemory::Alloc(sizeof(SECItem)*numCAs));
     1:       if (!derCerts) {
     1:         rv = NS_ERROR_OUT_OF_MEMORY;
     1:         goto loser;
     1:       }
     1:       for (node = CERT_LIST_HEAD(caPubs), i=0; 
     1:            !CERT_LIST_END(node, caPubs);
     1:            node = CERT_LIST_NEXT(node), i++) {
     1:         derCerts[i] = node->cert->derCert;
     1:       }
     1:       nsNSSCertificateDB::ImportValidCACerts(numCAs, derCerts, ctx);
     1:       nsMemory::Free(derCerts);
     1:     }
     1:     
     1:     CERT_DestroyCertList(caPubs);
     1:   }
     1: 
     1:   if (aDoForcedBackup) {
     1:     // I can't pop up a file picker from the depths of JavaScript,
     1:     // so I'll just post an event on the UI queue to do the backups
     1:     // later.
     1:     nsCOMPtr<nsIRunnable> p12Runnable = new nsP12Runnable(certArr, numResponses,
     1:                                                           token);
     1:     if (!p12Runnable) {
     1:       rv = NS_ERROR_FAILURE;
     1:       goto loser;
     1:     }
     1: 
     1:     // null out the certArr pointer which has now been inherited by
     1:     // the nsP12Runnable instance so that we don't free up the
     1:     // memory on the way out.
106838:     certArr = nullptr;
     1: 
     1:     rv = NS_DispatchToMainThread(p12Runnable);
     1:     if (NS_FAILED(rv))
     1:       goto loser;
     1:   }
     1: 
     1:  loser:
     1:   if (certArr) {
     1:     for (i=0; i<numResponses; i++) {
     1:       NS_IF_RELEASE(certArr[i]);
     1:     }
     1:     delete []certArr;
     1:   }
 26177:   aReturn.Assign(EmptyString());
     1:   if (nickname) {
     1:     NS_Free(nickname);
     1:   }
     1:   if (cmmfResponse) {
     1:     NS_Free(cmmfResponse);
     1:   }
     1:   if (certRepContent) {
     1:     CMMF_DestroyCertRepContent(certRepContent);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCrypto::PopChallengeResponse(const nsAString& aChallenge, 
     1:                                nsAString& aReturn)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsCrypto::Random(int32_t aNumBytes, nsAString& aReturn)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: static void
     1: GetDocumentFromContext(JSContext *cx, nsIDocument **aDocument)
     1: {
     1:   // Get the script context.
     1:   nsIScriptContext* scriptContext = GetScriptContextFromJSContext(cx);
     1:   if (!scriptContext) {
     1:     return;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMWindow> domWindow = 
     1:     do_QueryInterface(scriptContext->GetGlobalObject());
     1:   if (!domWindow) {
     1:     return;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMDocument> domDocument;
     1:   domWindow->GetDocument(getter_AddRefs(domDocument));
     1:   if (!domDocument) {
     1:     return;
     1:   }
     1: 
     1:   CallQueryInterface(domDocument, aDocument);
     1: 
     1:   return;
     1: }
     1: 
     1: void signTextOutputCallback(void *arg, const char *buf, unsigned long len)
     1: {
     1:   ((nsCString*)arg)->Append(buf, len);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCrypto::SignText(const nsAString& aStringToSign, const nsAString& aCaOption,
     1:                    nsAString& aResult)
     1: {
     1:   // XXX This code should return error codes, but we're keeping this
     1:   //     backwards compatible with NS4.x and so we can't throw exceptions.
     1:   NS_NAMED_LITERAL_STRING(internalError, "error:internalError");
     1: 
     1:   aResult.Truncate();
     1: 
106838:   nsAXPCNativeCallContext* ncc = nullptr;
     1:   nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
     1:   if (xpc) {
 10286:     xpc->GetCurrentNativeCallContext(&ncc);
     1:   }
     1: 
     1:   if (!ncc) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
108991:   uint32_t argc;
     1:   ncc->GetArgc(&argc);
     1: 
     1:   JSContext *cx;
     1:   ncc->GetJSContext(&cx);
     1:   if (!cx) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (!aCaOption.EqualsLiteral("auto") &&
     1:       !aCaOption.EqualsLiteral("ask")) {
     1:     JS_ReportError(cx, "%s%s\n", JS_ERROR, "caOption argument must be ask or auto");
     1: 
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   // It was decided to always behave as if "ask" were specified.
     1:   // XXX Should we warn in the JS Console for auto?
     1: 
     1:   nsCOMPtr<nsIInterfaceRequestor> uiContext = new PipUIContext;
     1:   if (!uiContext) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 79445:   bool bestOnly = true;
 79445:   bool validOnly = true;
     1:   CERTCertList* certList =
     1:     CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), certUsageEmailSigner,
     1:                               bestOnly, validOnly, uiContext);
     1: 
108991:   uint32_t numCAs = argc - 2;
     1:   if (numCAs > 0) {
106838:     jsval *argv = nullptr;
 57812:     ncc->GetArgvPtr(&argv);
 57812: 
 57812:     nsAutoArrayPtr<JSAutoByteString> caNameBytes(new JSAutoByteString[numCAs]);
 57812:     if (!caNameBytes) {
 57786:       aResult.Append(internalError);
 57786:       return NS_OK;
 57786:     }
 57786: 
  6404:     JSAutoRequest ar(cx);
  6404: 
108991:     uint32_t i;
     1:     for (i = 2; i < argc; ++i) {
     1:       JSString *caName = JS_ValueToString(cx, argv[i]);
 12545:       NS_ENSURE_TRUE(caName, NS_ERROR_OUT_OF_MEMORY);
 12545:       argv[i] = STRING_TO_JSVAL(caName);
 57812:       caNameBytes[i - 2].encode(cx, caName);
 57812:       NS_ENSURE_TRUE(!!caNameBytes[i - 2], NS_ERROR_OUT_OF_MEMORY);
 57812:     }
 57812: 
 57812:     nsAutoArrayPtr<char*> caNames(new char*[numCAs]);
 57812:     if (!caNames) {
     1:       aResult.Append(internalError);
     1:       return NS_OK;
     1:     }
 57812: 
 57812:     for (i = 0; i < numCAs; ++i)
 57812:       caNames[i] = caNameBytes[i].ptr();
     1: 
     1:     if (certList &&
     1:         CERT_FilterCertListByCANames(certList, numCAs, caNames,
     1:                                      certUsageEmailSigner) != SECSuccess) {
     1:       aResult.Append(internalError);
     1: 
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   if (!certList || CERT_LIST_EMPTY(certList)) {
     1:     aResult.AppendLiteral("error:noMatchingCert");
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIFormSigningDialog> fsd =
     1:     do_CreateInstance(NS_FORMSIGNINGDIALOG_CONTRACTID);
     1:   if (!fsd) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDocument> document;
     1:   GetDocumentFromContext(cx, getter_AddRefs(document));
     1:   if (!document) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Get the hostname from the URL of the document.
     1:   nsIURI* uri = document->GetDocumentURI();
     1:   if (!uri) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 81303:   nsresult rv;
 81303: 
     1:   nsCString host;
     1:   rv = uri->GetHost(host);
     1:   if (NS_FAILED(rv)) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
108991:   int32_t numberOfCerts = 0;
     1:   CERTCertListNode* node;
     1:   for (node = CERT_LIST_HEAD(certList); !CERT_LIST_END(node, certList);
     1:        node = CERT_LIST_NEXT(node)) {
     1:     ++numberOfCerts;
     1:   }
     1: 
     1:   CERTCertNicknames* nicknames = getNSSCertNicknamesFromCertList(certList);
     1: 
     1:   if (!nicknames) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   CERTCertNicknamesCleaner cnc(nicknames);
     1: 
     1:   NS_ASSERTION(nicknames->numnicknames == numberOfCerts,
     1:                "nicknames->numnicknames != numberOfCerts");
     1: 
     1:   nsAutoArrayPtr<PRUnichar*> certNicknameList(new PRUnichar*[nicknames->numnicknames * 2]);
     1:   if (!certNicknameList) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   PRUnichar** certDetailsList = certNicknameList.get() + nicknames->numnicknames;
     1: 
108991:   int32_t certsToUse;
     1:   for (node = CERT_LIST_HEAD(certList), certsToUse = 0;
     1:        !CERT_LIST_END(node, certList) && certsToUse < nicknames->numnicknames;
     1:        node = CERT_LIST_NEXT(node)) {
119832:     nsRefPtr<nsNSSCertificate> tempCert = nsNSSCertificate::Create(node->cert);
     1:     if (tempCert) {
     1:       nsAutoString nickWithSerial, details;
     1:       rv = tempCert->FormatUIStrings(NS_ConvertUTF8toUTF16(nicknames->nicknames[certsToUse]),
     1:                                      nickWithSerial, details);
     1:       if (NS_SUCCEEDED(rv)) {
     1:         certNicknameList[certsToUse] = ToNewUnicode(nickWithSerial);
     1:         if (certNicknameList[certsToUse]) {
     1:           certDetailsList[certsToUse] = ToNewUnicode(details);
     1:           if (!certDetailsList[certsToUse]) {
     1:             nsMemory::Free(certNicknameList[certsToUse]);
     1:             continue;
     1:           }
     1:           ++certsToUse;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (certsToUse == 0) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   NS_ConvertUTF8toUTF16 utf16Host(host);
     1: 
106838:   CERTCertificate *signingCert = nullptr;
 79445:   bool tryAgain, canceled;
     1:   nsAutoString password;
     1:   do {
     1:     // Throw up the form signing confirmation dialog and get back the index
     1:     // of the selected cert.
108991:     int32_t selectedIndex = -1;
 81303:     rv = fsd->ConfirmSignText(uiContext, utf16Host, aStringToSign,
  3233:                               const_cast<const PRUnichar**>(certNicknameList.get()),
  3233:                               const_cast<const PRUnichar**>(certDetailsList),
     1:                               certsToUse, &selectedIndex, password,
     1:                               &canceled);
     1:     if (NS_FAILED(rv) || canceled) {
     1:       break; // out of tryAgain loop
     1:     }
     1: 
108991:     int32_t j = 0;
     1:     for (node = CERT_LIST_HEAD(certList); !CERT_LIST_END(node, certList);
     1:          node = CERT_LIST_NEXT(node)) {
     1:       if (j == selectedIndex) {
     1:         signingCert = CERT_DupCertificate(node->cert);
     1:         break; // out of cert list iteration loop
     1:       }
     1:       ++j;
     1:     }
     1: 
     1:     if (!signingCert) {
     1:       rv = NS_ERROR_FAILURE;
     1:       break; // out of tryAgain loop
     1:     }
     1: 
     1:     NS_ConvertUTF16toUTF8 pwUtf8(password);
     1: 
     1:     tryAgain =
     1:       PK11_CheckUserPassword(signingCert->slot,
  3233:                              const_cast<char *>(pwUtf8.get())) != SECSuccess;
     1:     // XXX we should show an error dialog before retrying
     1:   } while (tryAgain);
     1: 
108991:   int32_t k;
     1:   for (k = 0; k < certsToUse; ++k) {
     1:     nsMemory::Free(certNicknameList[k]);
     1:     nsMemory::Free(certDetailsList[k]);
     1:   }
     1: 
     1:   if (NS_FAILED(rv)) { // something went wrong inside the tryAgain loop
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (canceled) {
     1:     aResult.AppendLiteral("error:userCancel");
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   SECKEYPrivateKey* privKey = PK11_FindKeyByAnyCert(signingCert, uiContext);
     1:   if (!privKey) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
110974:   nsAutoCString charset(document->GetDocumentCharacterSet());
     1: 
     1:   // XXX Doing what nsFormSubmission::GetEncoder does (see
     1:   //     http://bugzilla.mozilla.org/show_bug.cgi?id=81203).
     1:   if (charset.EqualsLiteral("ISO-8859-1")) {
     1:     charset.AssignLiteral("windows-1252");
     1:   }
     1: 
     1:   nsCOMPtr<nsISaveAsCharset> encoder =
     1:     do_CreateInstance(NS_SAVEASCHARSET_CONTRACTID);
     1:   if (encoder) {
     1:     rv = encoder->Init(charset.get(),
     1:                        (nsISaveAsCharset::attr_EntityAfterCharsetConv + 
     1:                        nsISaveAsCharset::attr_FallbackDecimalNCR),
     1:                        0);
     1:   }
     1: 
     1:   nsXPIDLCString buffer;
     1:   if (aStringToSign.Length() > 0) {
     1:     if (encoder && NS_SUCCEEDED(rv)) {
     1:       rv = encoder->Convert(PromiseFlatString(aStringToSign).get(),
     1:                             getter_Copies(buffer));
     1:       if (NS_FAILED(rv)) {
     1:         aResult.Append(internalError);
     1: 
     1:         return NS_OK;
     1:       }
     1:     }
     1:     else {
     1:       AppendUTF16toUTF8(aStringToSign, buffer);
     1:     }
     1:   }
     1: 
     1:   HASHContext *hc = HASH_Create(HASH_AlgSHA1);
     1:   if (!hc) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   unsigned char hash[SHA1_LENGTH];
     1: 
     1:   SECItem digest;
     1:   digest.data = hash;
     1: 
     1:   HASH_Begin(hc);
  3233:   HASH_Update(hc, reinterpret_cast<const unsigned char*>(buffer.get()),
     1:               buffer.Length());
     1:   HASH_End(hc, digest.data, &digest.len, SHA1_LENGTH);
     1:   HASH_Destroy(hc);
     1: 
     1:   nsCString p7;
     1:   SECStatus srv = SECFailure;
     1: 
     1:   SEC_PKCS7ContentInfo *ci = SEC_PKCS7CreateSignedData(signingCert,
     1:                                                        certUsageEmailSigner,
106838:                                                        nullptr, SEC_OID_SHA1,
106838:                                                        &digest, nullptr, uiContext);
     1:   if (ci) {
106838:     srv = SEC_PKCS7IncludeCertChain(ci, nullptr);
     1:     if (srv == SECSuccess) {
     1:       srv = SEC_PKCS7AddSigningTime(ci);
     1:       if (srv == SECSuccess) {
106838:         srv = SEC_PKCS7Encode(ci, signTextOutputCallback, &p7, nullptr, nullptr,
     1:                               uiContext);
     1:       }
     1:     }
     1: 
     1:     SEC_PKCS7DestroyContentInfo(ci);
     1:   }
     1: 
     1:   if (srv != SECSuccess) {
     1:     aResult.Append(internalError);
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   SECItem binary_item;
  3233:   binary_item.data = reinterpret_cast<unsigned char*>
  3233:                                      (const_cast<char*>(p7.get()));
     1:   binary_item.len = p7.Length();
     1: 
106838:   char *result = NSSBase64_EncodeItem(nullptr, nullptr, 0, &binary_item);
     1:   if (result) {
     1:     AppendASCIItoUTF16(result, aResult);
     1:   }
     1:   else {
     1:     aResult.Append(internalError);
     1:   }
     1: 
     1:   PORT_Free(result);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //Logout out of all installed PKCS11 tokens.
     1: NS_IMETHODIMP
     1: nsCrypto::Logout()
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     PK11_LogoutAll();
     1:     SSL_ClearSessionCache();
     1:   }
     1: 
     1:   return nssComponent->LogoutAuthenticatedPK11();
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCrypto::DisableRightClick()
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: nsCRMFObject::nsCRMFObject()
     1: {
     1: }
     1: 
     1: nsCRMFObject::~nsCRMFObject()
     1: {
     1: }
     1: 
     1: nsresult
     1: nsCRMFObject::init()
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCRMFObject::GetRequest(nsAString& aRequest)
     1: {
     1:   aRequest.Assign(mBase64Request);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCRMFObject::SetCRMFRequest(char *inRequest)
     1: {
     1:   mBase64Request.AssignWithConversion(inRequest);  
     1:   return NS_OK;
     1: }
     1: 
     1: nsPkcs11::nsPkcs11()
     1: {
     1: }
     1: 
     1: nsPkcs11::~nsPkcs11()
     1: {
     1: }
     1: 
     1: //Quick function to confirm with the user.
 79445: bool
     1: confirm_user(const PRUnichar *message)
     1: {
108991:   int32_t buttonPressed = 1; // If the user exits by clicking the close box, assume No (button 1)
     1: 
     1:   nsCOMPtr<nsIPrompt> prompter;
 81303:   (void) nsNSSComponent::GetNewPrompter(getter_AddRefs(prompter));
     1: 
     1:   if (prompter) {
     1:     nsPSMUITracker tracker;
     1:     if (!tracker.isUIForbidden()) {
 71407:       // The actual value is irrelevant but we shouldn't be handing out
 71407:       // malformed JSBools to XPConnect.
 79445:       bool checkState = false;
     1:       prompter->ConfirmEx(0, message,
     1:                           (nsIPrompt::BUTTON_DELAY_ENABLE) +
     1:                           (nsIPrompt::BUTTON_POS_1_DEFAULT) +
     1:                           (nsIPrompt::BUTTON_TITLE_OK * nsIPrompt::BUTTON_POS_0) +
     1:                           (nsIPrompt::BUTTON_TITLE_CANCEL * nsIPrompt::BUTTON_POS_1),
106838:                           nullptr, nullptr, nullptr, nullptr, &checkState, &buttonPressed);
     1:     }
     1:   }
     1: 
     1:   return (buttonPressed == 0);
     1: }
     1: 
     1: //Delete a PKCS11 module from the user's profile.
     1: NS_IMETHODIMP
 28823: nsPkcs11::DeleteModule(const nsAString& aModuleName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv;
     1:   nsString errorMessage;
     1: 
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
 28823:   if (NS_FAILED(rv))
 28823:     return rv;
 28823: 
     1:   if (aModuleName.IsEmpty()) {
 28823:     return NS_ERROR_ILLEGAL_VALUE;
     1:   }
     1:   
108464:   NS_ConvertUTF16toUTF8 modName(aModuleName);
108991:   int32_t modType;
108464:   SECStatus srv = SECMOD_DeleteModule(modName.get(), &modType);
     1:   if (srv == SECSuccess) {
108464:     SECMODModule *module = SECMOD_FindModule(modName.get());
     1:     if (module) {
     1:       nssComponent->ShutdownSmartCardThread(module);
     1:       SECMOD_DestroyModule(module);
     1:     }
 28823:     rv = NS_OK;
     1:   } else {
 28823:     rv = NS_ERROR_FAILURE;
     1:   }
 28823:   return rv;
     1: }
     1: 
     1: //Add a new PKCS11 module to the user's profile.
     1: NS_IMETHODIMP
 28823: nsPkcs11::AddModule(const nsAString& aModuleName, 
     1:                     const nsAString& aLibraryFullPath, 
108991:                     int32_t aCryptoMechanismFlags, 
108991:                     int32_t aCipherFlags)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1: 
108464:   NS_ConvertUTF16toUTF8 moduleName(aModuleName);
108464:   nsCString fullPath;
108464:   // NSS doesn't support Unicode path.  Use native charset
108464:   NS_CopyUnicodeToNative(aLibraryFullPath, fullPath);
108991:   uint32_t mechFlags = SECMOD_PubMechFlagstoInternal(aCryptoMechanismFlags);
108991:   uint32_t cipherFlags = SECMOD_PubCipherFlagstoInternal(aCipherFlags);
108464:   SECStatus srv = SECMOD_AddNewModule(moduleName.get(), fullPath.get(), 
     1:                                       mechFlags, cipherFlags);
     1:   if (srv == SECSuccess) {
108464:     SECMODModule *module = SECMOD_FindModule(moduleName.get());
     1:     if (module) {
     1:       nssComponent->LaunchSmartCardThread(module);
     1:       SECMOD_DestroyModule(module);
     1:     }
     1:   }
     1: 
     1:   // The error message we report to the user depends directly on 
     1:   // what the return value for SEDMOD_AddNewModule is
     1:   switch (srv) {
     1:   case SECSuccess:
 28823:     return NS_OK;
     1:   case SECFailure:
 28823:     return NS_ERROR_FAILURE;
     1:   case -2:
 28823:     return NS_ERROR_ILLEGAL_VALUE;
 28823:   }
 31561:   NS_ERROR("Bogus return value, this should never happen");
     1:   return NS_ERROR_FAILURE;
     1: }
 28823: 
