    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Places code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /**
    1:  * The definitions of objects that make up a history query result set. This file
    1:  * should only be included by nsNavHistory.h, include that if you want these
    1:  * classes.
    1:  */
    1: 
    1: #ifndef nsNavHistoryResult_h_
    1: #define nsNavHistoryResult_h_
    1: 
    1: #include "nsTArray.h"
    1: #include "nsInterfaceHashtable.h"
    1: #include "nsDataHashtable.h"
 7025: #include "nsCycleCollectionParticipant.h"
    1: 
    1: class nsNavHistory;
    1: class nsIDateTimeFormat;
    1: class nsIWritablePropertyBag;
    1: class nsNavHistoryQuery;
    1: class nsNavHistoryQueryOptions;
    1: 
    1: class nsNavHistoryContainerResultNode;
    1: class nsNavHistoryFolderResultNode;
    1: class nsNavHistoryQueryResultNode;
    1: class nsNavHistoryVisitResultNode;
    1: 
    1: /**
    1:  * hashkey wrapper using PRInt64 KeyType
    1:  *
    1:  * @see nsTHashtable::EntryType for specification
    1:  *
    1:  * This just truncates the 64-bit int to a 32-bit one for using a hash number.
    1:  * It is used for bookmark folder IDs, which should be way less than 2^32.
    1:  */
    1: class nsTrimInt64HashKey : public PLDHashEntryHdr
    1: {
    1: public:
    1:   typedef const PRInt64& KeyType;
    1:   typedef const PRInt64* KeyTypePointer;
    1: 
    1:   nsTrimInt64HashKey(KeyTypePointer aKey) : mValue(*aKey) { }
    1:   nsTrimInt64HashKey(const nsTrimInt64HashKey& toCopy) : mValue(toCopy.mValue) { }
    1:   ~nsTrimInt64HashKey() { }
    1: 
    1:   KeyType GetKey() const { return mValue; }
    1:   PRBool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }
    1: 
    1:   static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
    1:   static PLDHashNumber HashKey(KeyTypePointer aKey)
 3233:     { return static_cast<PRUint32>((*aKey) & PR_UINT32_MAX); }
    1:   enum { ALLOW_MEMMOVE = PR_TRUE };
    1: 
    1: private:
    1:   const PRInt64 mValue;
    1: };
    1: 
    1: 
    1: // Declare methods for implementing nsINavBookmarkObserver
    1: // and nsINavHistoryObserver (some methods, such as BeginUpdateBatch overlap)
    1: #define NS_DECL_BOOKMARK_HISTORY_OBSERVER                               \
    1:   NS_DECL_NSINAVBOOKMARKOBSERVER                                        \
    1:   NS_IMETHOD OnVisit(nsIURI* aURI, PRInt64 aVisitId, PRTime aTime,      \
    1:                      PRInt64 aSessionId, PRInt64 aReferringId,          \
12328:                      PRUint32 aTransitionType, PRUint32* aAdded);      \
 4037:   NS_IMETHOD OnTitleChanged(nsIURI* aURI, const nsAString& aPageTitle); \
    1:   NS_IMETHOD OnDeleteURI(nsIURI *aURI);                                 \
    1:   NS_IMETHOD OnClearHistory();                                          \
    1:   NS_IMETHOD OnPageChanged(nsIURI *aURI, PRUint32 aWhat,                \
    1:                            const nsAString &aValue);                    \
    1:   NS_IMETHOD OnPageExpired(nsIURI* aURI, PRTime aVisitTime,             \
    1:                            PRBool aWholeEntry);
    1: 
    1: 
    1: // nsNavHistoryResult
    1: //
    1: //    nsNavHistory creates this object and fills in mChildren (by getting
    1: //    it through GetTopLevel()). Then FilledAllResults() is called to finish
    1: //    object initialization.
    1: //
    1: //    This object implements nsITreeView so you can just set it to a tree
    1: //    view and it will work. This object also observes the necessary history
    1: //    and bookmark events to keep itself up-to-date.
    1: 
    1: #define NS_NAVHISTORYRESULT_IID \
    1:   { 0x455d1d40, 0x1b9b, 0x40e6, { 0xa6, 0x41, 0x8b, 0xb7, 0xe8, 0x82, 0x23, 0x87 } }
    1: 
    1: class nsNavHistoryResult : public nsSupportsWeakReference,
    1:                            public nsINavHistoryResult,
    1:                            public nsINavBookmarkObserver,
    1:                            public nsINavHistoryObserver
    1: {
    1: public:
    1:   static nsresult NewHistoryResult(nsINavHistoryQuery** aQueries,
    1:                                    PRUint32 aQueryCount,
    1:                                    nsNavHistoryQueryOptions* aOptions,
    1:                                    nsNavHistoryContainerResultNode* aRoot,
    1:                                    nsNavHistoryResult** result);
    1: 
    1:   // the tree viewer can go faster if it can bypass XPCOM
    1:   friend class nsNavHistoryResultTreeViewer;
    1: 
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_NAVHISTORYRESULT_IID)
    1: 
    1:   nsresult PropertyBagFor(nsISupports* aObject,
    1:                           nsIWritablePropertyBag** aBag);
    1: 
 7025:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1:   NS_DECL_NSINAVHISTORYRESULT
    1:   NS_DECL_BOOKMARK_HISTORY_OBSERVER
 7025:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsNavHistoryResult, nsINavHistoryResult)
    1: 
 2579:   void AddHistoryObserver(nsNavHistoryQueryResultNode* aNode);
 2579:   void AddBookmarkFolderObserver(nsNavHistoryFolderResultNode* aNode, PRInt64 aFolder);
 2579:   void AddAllBookmarksObserver(nsNavHistoryQueryResultNode* aNode);
 2579:   void RemoveHistoryObserver(nsNavHistoryQueryResultNode* aNode);
 2579:   void RemoveBookmarkFolderObserver(nsNavHistoryFolderResultNode* aNode, PRInt64 aFolder);
 2579:   void RemoveAllBookmarksObserver(nsNavHistoryQueryResultNode* aNode);
    1: 
    1:   // returns the view. NOT-ADDREFED. May be NULL if there is no view
    1:   nsINavHistoryResultViewer* GetView() const
    1:     { return mView; }
    1: 
    1: public:
    1:   // two-stage init, use NewHistoryResult to construct
    1:   nsNavHistoryResult(nsNavHistoryContainerResultNode* mRoot);
    1:   ~nsNavHistoryResult();
    1:   nsresult Init(nsINavHistoryQuery** aQueries,
    1:                 PRUint32 aQueryCount,
    1:                 nsNavHistoryQueryOptions *aOptions);
    1: 
    1:   nsRefPtr<nsNavHistoryContainerResultNode> mRootNode;
    1: 
    1:   nsCOMArray<nsINavHistoryQuery> mQueries;
    1:   nsCOMPtr<nsNavHistoryQueryOptions> mOptions;
    1: 
    1:   // One of nsNavHistoryQueryOptions.SORY_BY_* This is initialized to mOptions.sortingMode,
    1:   // but may be overridden if the user clicks on one of the columns.
  809:   PRUint16 mSortingMode;
    1: 
  713:   // The sorting annotation to be used for in SORT_BY_ANNOTATION_* modes
  713:   nsCString mSortingAnnotation;
  713: 
    1:   nsCOMPtr<nsINavHistoryResultViewer> mView;
    1: 
    1:   // property bags for all result nodes, see PropertyBagFor
    1:   nsInterfaceHashtable<nsISupportsHashKey, nsIWritablePropertyBag> mPropertyBags;
    1: 
    1:   // node observers
    1:   PRBool mIsHistoryObserver;
 2579:   PRBool mIsBookmarkFolderObserver;
 2579:   PRBool mIsAllBookmarksObserver;
 2579: 
 2579:   nsTArray<nsNavHistoryQueryResultNode*> mHistoryObservers;
 2579:   nsTArray<nsNavHistoryQueryResultNode*> mAllBookmarksObservers;
    1:   typedef nsTArray<nsNavHistoryFolderResultNode*> FolderObserverList;
 2579:   nsDataHashtable<nsTrimInt64HashKey, FolderObserverList* > mBookmarkFolderObservers;
 2579:   FolderObserverList* BookmarkFolderObserversForId(PRInt64 aFolderId, PRBool aCreate);
    1: 
    1:   void RecursiveExpandCollapse(nsNavHistoryContainerResultNode* aContainer,
    1:                                PRBool aExpand);
    1: 
    1:   void InvalidateTree();
 4623:   
 4623:   PRBool mBatchInProgress;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsNavHistoryResult, NS_NAVHISTORYRESULT_IID)
    1: 
    1: // nsNavHistoryResultNode
    1: //
    1: //    This is the base class for every node in a result set. The result itself
    1: //    is a node (nsNavHistoryResult inherits from this), as well as every
    1: //    leaf and branch on the tree.
    1: 
    1: #define NS_NAVHISTORYRESULTNODE_IID \
    1:   {0x54b61d38, 0x57c1, 0x11da, {0x95, 0xb8, 0x00, 0x13, 0x21, 0xc9, 0xf6, 0x9e}}
    1: 
    1: // These are all the simple getters, they can be used for the result node
    1: // implementation and all subclasses. More complex are GetIcon, GetParent
    1: // (which depends on the definition of container result node), and GetUri
    1: // (which is overridded for lazy construction for some containers).
10046: #define NS_IMPLEMENT_SIMPLE_RESULTNODE_NO_GETITEMMID \
    1:   NS_IMETHOD GetTitle(nsACString& aTitle) \
    1:     { aTitle = mTitle; return NS_OK; } \
    1:   NS_IMETHOD GetAccessCount(PRUint32* aAccessCount) \
    1:     { *aAccessCount = mAccessCount; return NS_OK; } \
    1:   NS_IMETHOD GetTime(PRTime* aTime) \
    1:     { *aTime = mTime; return NS_OK; } \
  169:   NS_IMETHOD GetIndentLevel(PRInt32* aIndentLevel) \
    1:     { *aIndentLevel = mIndentLevel; return NS_OK; } \
    1:   NS_IMETHOD GetViewIndex(PRInt32* aViewIndex) \
    1:     { *aViewIndex = mViewIndex; return NS_OK; } \
    1:   NS_IMETHOD SetViewIndex(PRInt32 aViewIndex) \
    1:     { mViewIndex = aViewIndex; return NS_OK; } \
    1:   NS_IMETHOD GetBookmarkIndex(PRInt32* aIndex) \
    1:     { *aIndex = mBookmarkIndex; return NS_OK; } \
 1604:   NS_IMETHOD GetDateAdded(PRTime* aDateAdded) \
 1604:     { *aDateAdded = mDateAdded; return NS_OK; } \
 1604:   NS_IMETHOD GetLastModified(PRTime* aLastModified) \
 1604:     { *aLastModified = mLastModified; return NS_OK; }
 1604: 
10046: #define NS_IMPLEMENT_SIMPLE_RESULTNODE \
10046:   NS_IMPLEMENT_SIMPLE_RESULTNODE_NO_GETITEMMID \
10046:   NS_IMETHOD GetItemId(PRInt64* aId) \
10046:     { *aId = mItemId; return NS_OK; }
10046: 
    1: // This is used by the base classes instead of
    1: // NS_FORWARD_NSINAVHISTORYRESULTNODE(nsNavHistoryResultNode) because they
    1: // need to redefine GetType and GetUri rather than forwarding them. This
    1: // implements all the simple getters instead of forwarding because they are so
    1: // short and we can save a virtual function call.
    1: //
    1: // (GetUri is redefined only by QueryResultNode and FolderResultNode because
    1: // the queries might not necessarily be parsed. The rest just return the node's
    1: // buffer.)
10046: #define NS_FORWARD_COMMON_RESULTNODE_TO_BASE_NO_GETITEMMID \
10046:   NS_IMPLEMENT_SIMPLE_RESULTNODE_NO_GETITEMMID \
    1:   NS_IMETHOD GetIcon(nsIURI** aIcon) \
    1:     { return nsNavHistoryResultNode::GetIcon(aIcon); } \
    1:   NS_IMETHOD GetParent(nsINavHistoryContainerResultNode** aParent) \
    1:     { return nsNavHistoryResultNode::GetParent(aParent); } \
 7159:   NS_IMETHOD GetParentResult(nsINavHistoryResult** aResult) \
 7159:     { return nsNavHistoryResultNode::GetParentResult(aResult); } \
    1:   NS_IMETHOD GetPropertyBag(nsIWritablePropertyBag** aBag) \
 9553:     { return nsNavHistoryResultNode::GetPropertyBag(aBag); } \
 9553:   NS_IMETHOD GetTags(nsAString& aTags) \
 9553:     { return nsNavHistoryResultNode::GetTags(aTags); } \
    1: 
10046: #define NS_FORWARD_COMMON_RESULTNODE_TO_BASE \
10046:   NS_FORWARD_COMMON_RESULTNODE_TO_BASE_NO_GETITEMMID \
10046:   NS_IMETHOD GetItemId(PRInt64* aId) \
10046:     { *aId = mItemId; return NS_OK; }
10046: 
    1: class nsNavHistoryResultNode : public nsINavHistoryResultNode
    1: {
    1: public:
    1:   nsNavHistoryResultNode(const nsACString& aURI, const nsACString& aTitle,
    1:                          PRUint32 aAccessCount, PRTime aTime,
    1:                          const nsACString& aIconURI);
    1:   virtual ~nsNavHistoryResultNode() {}
    1: 
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_NAVHISTORYRESULTNODE_IID)
    1: 
 7025:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 7025:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNavHistoryResultNode)
 7025: 
    1:   NS_IMPLEMENT_SIMPLE_RESULTNODE
    1:   NS_IMETHOD GetIcon(nsIURI** aIcon);
    1:   NS_IMETHOD GetParent(nsINavHistoryContainerResultNode** aParent);
 7159:   NS_IMETHOD GetParentResult(nsINavHistoryResult** aResult);
    1:   NS_IMETHOD GetPropertyBag(nsIWritablePropertyBag** aBag);
    1:   NS_IMETHOD GetType(PRUint32* type)
    1:     { *type = nsNavHistoryResultNode::RESULT_TYPE_URI; return NS_OK; }
    1:   NS_IMETHOD GetUri(nsACString& aURI)
    1:     { aURI = mURI; return NS_OK; }
 9553:   NS_IMETHOD GetTags(nsAString& aTags);
    1: 
    1:   virtual void OnRemoving();
    1: 
 2551:   // Called from result's onItemChanged, see also bookmark observer declaration in
 2551:   // nsNavHistoryFolderResultNode
 2551:   NS_IMETHOD OnItemChanged(PRInt64 aItemId,
 2551:                            const nsACString &aProperty,
 2551:                            PRBool aIsAnnotationProperty,
 2551:                            const nsACString &aValue);
 2551: 
    1: public:
    1: 
    1:   nsNavHistoryResult* GetResult();
    1:   nsNavHistoryQueryOptions* GetGeneratingOptions();
    1: 
    1:   // These functions test the type. We don't use a virtual function since that
    1:   // would take a vtable slot for every one of (potentially very many) nodes.
    1:   // Note that GetType() already has a vtable slot because its on the iface.
    1:   PRBool IsTypeContainer(PRUint32 type) {
12328:     return (type == nsINavHistoryResultNode::RESULT_TYPE_DYNAMIC_CONTAINER ||
    1:             type == nsINavHistoryResultNode::RESULT_TYPE_QUERY ||
    1:             type == nsINavHistoryResultNode::RESULT_TYPE_FOLDER ||
12328:             type == nsINavHistoryResultNode::RESULT_TYPE_FOLDER_SHORTCUT);
    1:   }
    1:   PRBool IsContainer() {
    1:     PRUint32 type;
    1:     GetType(&type);
    1:     return IsTypeContainer(type);
    1:   }
 4179:   PRBool IsDynamicContainer() {
 4179:     PRUint32 type;
 4179:     GetType(&type);
 4179:     return (type == nsINavHistoryResultNode::RESULT_TYPE_DYNAMIC_CONTAINER);
 4179:   }
    1:   static PRBool IsTypeURI(PRUint32 type) {
    1:     return (type == nsINavHistoryResultNode::RESULT_TYPE_URI ||
    1:             type == nsINavHistoryResultNode::RESULT_TYPE_VISIT ||
    1:             type == nsINavHistoryResultNode::RESULT_TYPE_FULL_VISIT);
    1:   }
    1:   PRBool IsURI() {
    1:     PRUint32 type;
    1:     GetType(&type);
    1:     return IsTypeURI(type);
    1:   }
    1:   static PRBool IsTypeVisit(PRUint32 type) {
    1:     return (type == nsINavHistoryResultNode::RESULT_TYPE_VISIT ||
    1:             type == nsINavHistoryResultNode::RESULT_TYPE_FULL_VISIT);
    1:   }
    1:   PRBool IsVisit() {
    1:     PRUint32 type;
    1:     GetType(&type);
    1:     return IsTypeVisit(type);
    1:   }
    1:   static PRBool IsTypeFolder(PRUint32 type) {
10675:     return (type == nsINavHistoryResultNode::RESULT_TYPE_FOLDER ||
10675:             type == nsINavHistoryResultNode::RESULT_TYPE_FOLDER_SHORTCUT);
    1:   }
    1:   PRBool IsFolder() {
    1:     PRUint32 type;
    1:     GetType(&type);
    1:     return IsTypeFolder(type);
    1:   }
    1:   static PRBool IsTypeQuery(PRUint32 type) {
    1:     return (type == nsINavHistoryResultNode::RESULT_TYPE_QUERY);
    1:   }
    1:   PRBool IsQuery() {
    1:     PRUint32 type;
    1:     GetType(&type);
    1:     return IsTypeQuery(type);
    1:   }
    1:   PRBool IsSeparator() {
    1:     PRUint32 type;
    1:     GetType(&type);
    1:     return (type == nsINavHistoryResultNode::RESULT_TYPE_SEPARATOR);
    1:   }
    1:   nsNavHistoryContainerResultNode* GetAsContainer() {
    1:     NS_ASSERTION(IsContainer(), "Not a container");
 3233:     return reinterpret_cast<nsNavHistoryContainerResultNode*>(this);
    1:   }
    1:   nsNavHistoryVisitResultNode* GetAsVisit() {
    1:     NS_ASSERTION(IsVisit(), "Not a visit");
 3233:     return reinterpret_cast<nsNavHistoryVisitResultNode*>(this);
    1:   }
    1:   nsNavHistoryFolderResultNode* GetAsFolder() {
    1:     NS_ASSERTION(IsFolder(), "Not a folder");
 3233:     return reinterpret_cast<nsNavHistoryFolderResultNode*>(this);
    1:   }
    1:   nsNavHistoryQueryResultNode* GetAsQuery() {
    1:     NS_ASSERTION(IsQuery(), "Not a query");
 3233:     return reinterpret_cast<nsNavHistoryQueryResultNode*>(this);
    1:   }
    1: 
    1:   nsNavHistoryContainerResultNode* mParent;
    1:   nsCString mURI; // not necessarily valid for containers, call GetUri
    1:   nsCString mTitle;
 9553:   nsString mTags;
    1:   PRUint32 mAccessCount;
    1:   PRInt64 mTime;
    1:   nsCString mFaviconURI;
    1:   PRInt32 mBookmarkIndex;
 1337:   PRInt64 mItemId;
 1604:   PRTime mDateAdded;
 1604:   PRTime mLastModified;
    1: 
    1:   // The indent level of this node. The root node will have a value of -1.  The
    1:   // root's children will have a value of 0, and so on.
    1:   PRInt32 mIndentLevel;
    1: 
    1:   // Value used by the view for whatever it wants. For the built-in tree view,
    1:   // this is the index into the result's mVisibleElements list of this element.
    1:   // This is -1 if it is invalid. For items, >= 0 can be used to determine if
    1:   // the node is visible in the list or not. For folders, call IsVisible, since
    1:   // they can be the root node which is not itself visible, but its children
    1:   // are.
    1:   PRInt32 mViewIndex;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsNavHistoryResultNode, NS_NAVHISTORYRESULTNODE_IID)
    1: 
    1: // nsNavHistoryVisitResultNode
    1: 
    1: #define NS_IMPLEMENT_VISITRESULT \
    1:   NS_IMETHOD GetUri(nsACString& aURI) { aURI = mURI; return NS_OK; } \
    1:   NS_IMETHOD GetSessionId(PRInt64* aSessionId) \
    1:     { *aSessionId = mSessionId; return NS_OK; }
    1: 
    1: class nsNavHistoryVisitResultNode : public nsNavHistoryResultNode,
    1:                                     public nsINavHistoryVisitResultNode
    1: {
    1: public:
    1:   nsNavHistoryVisitResultNode(const nsACString& aURI, const nsACString& aTitle,
    1:                               PRUint32 aAccessCount, PRTime aTime,
    1:                               const nsACString& aIconURI, PRInt64 aSession);
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
    1:   NS_FORWARD_COMMON_RESULTNODE_TO_BASE
    1:   NS_IMETHOD GetType(PRUint32* type)
    1:     { *type = nsNavHistoryResultNode::RESULT_TYPE_VISIT; return NS_OK; }
    1:   NS_IMPLEMENT_VISITRESULT
    1: 
    1: public:
    1: 
    1:   PRInt64 mSessionId;
    1: };
    1: 
    1: 
    1: // nsNavHistoryFullVisitResultNode
    1: 
    1: #define NS_IMPLEMENT_FULLVISITRESULT \
    1:   NS_IMPLEMENT_VISITRESULT \
    1:   NS_IMETHOD GetVisitId(PRInt64 *aVisitId) \
    1:     { *aVisitId = mVisitId; return NS_OK; } \
    1:   NS_IMETHOD GetReferringVisitId(PRInt64 *aReferringVisitId) \
    1:     { *aReferringVisitId = mReferringVisitId; return NS_OK; } \
    1:   NS_IMETHOD GetTransitionType(PRInt32 *aTransitionType) \
    1:     { *aTransitionType = mTransitionType; return NS_OK; }
    1: 
    1: class nsNavHistoryFullVisitResultNode : public nsNavHistoryVisitResultNode,
    1:                                         public nsINavHistoryFullVisitResultNode
    1: {
    1: public:
    1:   nsNavHistoryFullVisitResultNode(
    1:     const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount,
    1:     PRTime aTime, const nsACString& aIconURI, PRInt64 aSession,
    1:     PRInt64 aVisitId, PRInt64 aReferringVisitId, PRInt32 aTransitionType);
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
    1:   NS_FORWARD_COMMON_RESULTNODE_TO_BASE
    1:   NS_IMETHOD GetType(PRUint32* type)
    1:     { *type = nsNavHistoryResultNode::RESULT_TYPE_FULL_VISIT; return NS_OK; }
    1:   NS_IMPLEMENT_FULLVISITRESULT
    1: 
    1: public:
    1:   PRInt64 mVisitId;
    1:   PRInt64 mReferringVisitId;
    1:   PRInt32 mTransitionType;
    1: };
    1: 
    1: 
    1: // nsNavHistoryContainerResultNode
    1: //
    1: //    This is the base class for all nodes that can have children. It is
    1: //    overridden for nodes that are dynamically populated such as queries and
    1: //    folders. It is used directly for simple containers such as host groups
    1: //    in history views.
    1: 
    1: // derived classes each provide their own implementation of has children and
    1: // forward the rest to us using this macro
    1: #define NS_FORWARD_CONTAINERNODE_EXCEPT_HASCHILDREN_AND_READONLY \
    1:   NS_IMETHOD GetContainerOpen(PRBool *aContainerOpen) \
    1:     { return nsNavHistoryContainerResultNode::GetContainerOpen(aContainerOpen); } \
    1:   NS_IMETHOD SetContainerOpen(PRBool aContainerOpen) \
    1:     { return nsNavHistoryContainerResultNode::SetContainerOpen(aContainerOpen); } \
    1:   NS_IMETHOD GetChildCount(PRUint32 *aChildCount) \
    1:     { return nsNavHistoryContainerResultNode::GetChildCount(aChildCount); } \
    1:   NS_IMETHOD GetChild(PRUint32 index, nsINavHistoryResultNode **_retval) \
    1:     { return nsNavHistoryContainerResultNode::GetChild(index, _retval); } \
 4179:   NS_IMETHOD GetDynamicContainerType(nsACString& aDynamicContainerType) \
 4179:     { return nsNavHistoryContainerResultNode::GetDynamicContainerType(aDynamicContainerType); } \
    1:   NS_IMETHOD AppendURINode(const nsACString& aURI, const nsACString& aTitle, PRUint32 aAccessCount, PRTime aTime, const nsACString& aIconURI, nsINavHistoryResultNode **_retval) \
    1:     { return nsNavHistoryContainerResultNode::AppendURINode(aURI, aTitle, aAccessCount, aTime, aIconURI, _retval); } \
 4179:   NS_IMETHOD AppendFolderNode(PRInt64 aFolderId, nsINavHistoryContainerResultNode **_retval) \
 4179:     { return nsNavHistoryContainerResultNode::AppendFolderNode(aFolderId, _retval); }
 4179: /* Untested container API functions
    1:   NS_IMETHOD AppendVisitNode(const nsACString& aURI, const nsACString & aTitle, PRUint32 aAccessCount, PRTime aTime, const nsACString & aIconURI, PRInt64 aSession, nsINavHistoryVisitResultNode **_retval) \
    1:     { return nsNavHistoryContainerResultNode::AppendVisitNode(aURI, aTitle, aAccessCount, aTime, aIconURI, aSession, _retval); } \
    1:   NS_IMETHOD AppendFullVisitNode(const nsACString& aURI, const nsACString & aTitle, PRUint32 aAccessCount, PRTime aTime, const nsACString & aIconURI, PRInt64 aSession, PRInt64 aVisitId, PRInt64 aReferringVisitId, PRInt32 aTransitionType, nsINavHistoryFullVisitResultNode **_retval) \
    1:     { return nsNavHistoryContainerResultNode::AppendFullVisitNode(aURI, aTitle, aAccessCount, aTime, aIconURI, aSession, aVisitId, aReferringVisitId, aTransitionType, _retval); } \
    1:   NS_IMETHOD AppendContainerNode(const nsACString & aTitle, const nsACString & aIconURI, PRUint32 aContainerType, const nsACString & aRemoteContainerType, nsINavHistoryContainerResultNode **_retval) \
    1:     { return nsNavHistoryContainerResultNode::AppendContainerNode(aTitle, aIconURI, aContainerType, aRemoteContainerType, _retval); } \
    1:   NS_IMETHOD AppendQueryNode(const nsACString& aQueryURI, const nsACString & aTitle, const nsACString & aIconURI, nsINavHistoryQueryResultNode **_retval) \
    1:     { return nsNavHistoryContainerResultNode::AppendQueryNode(aQueryURI, aTitle, aIconURI, _retval); } \
    1:   NS_IMETHOD ClearContents() \
    1:     { return nsNavHistoryContainerResultNode::ClearContents(); }
    1: */
    1: 
    1: #define NS_NAVHISTORYCONTAINERRESULTNODE_IID \
    1:   { 0x6e3bf8d3, 0x22aa, 0x4065, { 0x86, 0xbc, 0x37, 0x46, 0xb5, 0xb3, 0x2c, 0xe8 } }
    1: 
    1: class nsNavHistoryContainerResultNode : public nsNavHistoryResultNode,
    1:                                         public nsINavHistoryContainerResultNode
    1: {
    1: public:
    1:   nsNavHistoryContainerResultNode(
    1:     const nsACString& aURI, const nsACString& aTitle,
    1:     const nsACString& aIconURI, PRUint32 aContainerType,
 4179:     PRBool aReadOnly, const nsACString& aDynamicContainerType,
 4179:     nsNavHistoryQueryOptions* aOptions);
12328:   nsNavHistoryContainerResultNode(
12328:     const nsACString& aURI, const nsACString& aTitle,
12328:     PRTime aTime,
12328:     const nsACString& aIconURI, PRUint32 aContainerType,
12328:     PRBool aReadOnly, const nsACString& aDynamicContainerType,
12328:     nsNavHistoryQueryOptions* aOptions);
    1: 
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_NAVHISTORYCONTAINERRESULTNODE_IID)
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
 7025:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsNavHistoryContainerResultNode, nsNavHistoryResultNode)
    1:   NS_FORWARD_COMMON_RESULTNODE_TO_BASE
    1:   NS_IMETHOD GetType(PRUint32* type)
    1:     { *type = mContainerType; return NS_OK; }
    1:   NS_IMETHOD GetUri(nsACString& aURI)
    1:     { aURI = mURI; return NS_OK; }
    1:   NS_DECL_NSINAVHISTORYCONTAINERRESULTNODE
    1: 
    1: public:
    1: 
    1:   virtual void OnRemoving();
    1: 
    1:   PRBool AreChildrenVisible();
    1: 
    1:   // overridded by descendents to populate
    1:   virtual nsresult OpenContainer();
    1:   nsresult CloseContainer(PRBool aUpdateView = PR_TRUE);
    1: 
    1:   // this points to the result that owns this container. All containers have
    1:   // their result pointer set so we can quickly get to the result without having
    1:   // to walk the tree. Yet, this also saves us from storing a million pointers
    1:   // for every leaf node to the result.
 7025:   nsRefPtr<nsNavHistoryResult> mResult;
    1: 
12328:   // for example, RESULT_TYPE_QUERY. Query and Folder results override GetType
    1:   // so this is not used, but is still kept in sync.
    1:   PRUint32 mContainerType;
    1: 
    1:   // when there are children, this stores the open state in the tree
    1:   // this is set to the default in the constructor
    1:   PRBool mExpanded;
    1: 
    1:   // Filled in by the result type generator in nsNavHistory
    1:   nsCOMArray<nsNavHistoryResultNode> mChildren;
    1: 
    1:   PRBool mChildrenReadOnly;
    1: 
 4179:   nsCOMPtr<nsNavHistoryQueryOptions> mOptions;
 4179: 
 4179:   // ID of a dynamic container interface that we can use GetService to get.
 4179:   nsCString mDynamicContainerType;
    1: 
    1:   void FillStats();
    1:   void ReverseUpdateStats(PRInt32 aAccessCountChange);
    1: 
    1:   // sorting
    1:   typedef nsCOMArray<nsNavHistoryResultNode>::nsCOMArrayComparatorFunc SortComparator;
  809:   virtual PRUint16 GetSortType();
  713:   virtual void GetSortingAnnotation(nsACString& aSortingAnnotation);
  713: 
  809:   static SortComparator GetSortingComparator(PRUint16 aSortType);
  713:   virtual void RecursiveSort(const char* aData,
    1:                              SortComparator aComparator);
  713:   PRUint32 FindInsertionPoint(nsNavHistoryResultNode* aNode, SortComparator aComparator,
12328:                               const char* aData, PRBool* aItemExists);
  713:   PRBool DoesChildNeedResorting(PRUint32 aIndex, SortComparator aComparator,
  713:                                 const char* aData);
  713: 
  713:   static PRInt32 SortComparison_StringLess(const nsAString& a, const nsAString& b);
    1: 
    1:   PR_STATIC_CALLBACK(int) SortComparison_Bookmark(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_TitleLess(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_TitleGreater(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_DateLess(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_DateGreater(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_URILess(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_URIGreater(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_VisitCountLess(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1:   PR_STATIC_CALLBACK(int) SortComparison_VisitCountGreater(
    1:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 1429:   PR_STATIC_CALLBACK(int) SortComparison_KeywordLess(
 1429:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 1429:   PR_STATIC_CALLBACK(int) SortComparison_KeywordGreater(
 1429:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
  713:   PR_STATIC_CALLBACK(int) SortComparison_AnnotationLess(
  713:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
  713:   PR_STATIC_CALLBACK(int) SortComparison_AnnotationGreater(
  713:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 1604:   PR_STATIC_CALLBACK(int) SortComparison_DateAddedLess(
 1604:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 1604:   PR_STATIC_CALLBACK(int) SortComparison_DateAddedGreater(
 1604:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 1604:   PR_STATIC_CALLBACK(int) SortComparison_LastModifiedLess(
 1604:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 1604:   PR_STATIC_CALLBACK(int) SortComparison_LastModifiedGreater(
 1604:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 9553:   PR_STATIC_CALLBACK(int) SortComparison_TagsLess(
 9553:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
 9553:   PR_STATIC_CALLBACK(int) SortComparison_TagsGreater(
 9553:       nsNavHistoryResultNode* a, nsNavHistoryResultNode* b, void* closure);
    1: 
    1:   // finding children: THESE DO NOT ADDREF
    1:   nsNavHistoryResultNode* FindChildURI(nsIURI* aURI, PRUint32* aNodeIndex)
    1:   {
    1:     nsCAutoString spec;
    1:     if (NS_FAILED(aURI->GetSpec(spec)))
    1:       return PR_FALSE;
    1:     return FindChildURI(spec, aNodeIndex);
    1:   }
    1:   nsNavHistoryResultNode* FindChildURI(const nsACString& aSpec,
    1:                                        PRUint32* aNodeIndex);
    1:   nsNavHistoryFolderResultNode* FindChildFolder(PRInt64 aFolderId,
    1:                                                 PRUint32* aNodeIndex);
    1:   nsNavHistoryContainerResultNode* FindChildContainerByName(const nsACString& aTitle,
    1:                                                             PRUint32* aNodeIndex);
    1:   // returns the index of the given node, -1 if not found
    1:   PRInt32 FindChild(nsNavHistoryResultNode* aNode)
    1:     { return mChildren.IndexOf(aNode); }
    1: 
    1:   nsresult InsertChildAt(nsNavHistoryResultNode* aNode, PRInt32 aIndex,
    1:                          PRBool aIsTemporary = PR_FALSE);
    1:   nsresult InsertSortedChild(nsNavHistoryResultNode* aNode,
12328:                              PRBool aIsTemporary = PR_FALSE,
12328:                              PRBool aIgnoreDuplicates = PR_FALSE);
 9714:   PRBool EnsureItemPosition(PRUint32 aIndex);
    1:   void MergeResults(nsCOMArray<nsNavHistoryResultNode>* aNodes);
    1:   nsresult ReplaceChildURIAt(PRUint32 aIndex, nsNavHistoryResultNode* aNode);
    1:   nsresult RemoveChildAt(PRInt32 aIndex, PRBool aIsTemporary = PR_FALSE);
    1: 
    1:   void RecursiveFindURIs(PRBool aOnlyOne,
    1:                          nsNavHistoryContainerResultNode* aContainer,
    1:                          const nsCString& aSpec,
    1:                          nsCOMArray<nsNavHistoryResultNode>* aMatches);
    1:   void UpdateURIs(PRBool aRecursive, PRBool aOnlyOne, PRBool aUpdateSort,
    1:                   const nsCString& aSpec,
    1:                   void (*aCallback)(nsNavHistoryResultNode*,void*),
    1:                   void* aClosure);
    1:   nsresult ChangeTitles(nsIURI* aURI, const nsACString& aNewTitle,
    1:                         PRBool aRecursive, PRBool aOnlyOne);
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsNavHistoryContainerResultNode,
    1:                               NS_NAVHISTORYCONTAINERRESULTNODE_IID)
    1: 
    1: // nsNavHistoryQueryResultNode
    1: //
    1: //    Overridden container type for complex queries over history and/or
    1: //    bookmarks. This keeps itself in sync by listening to history and
    1: //    bookmark notifications.
    1: 
    1: class nsNavHistoryQueryResultNode : public nsNavHistoryContainerResultNode,
    1:                                     public nsINavHistoryQueryResultNode
    1: {
    1: public:
    1:   nsNavHistoryQueryResultNode(const nsACString& aQueryURI,
    1:                               const nsACString& aTitle,
    1:                               const nsACString& aIconURI);
    1:   nsNavHistoryQueryResultNode(const nsACString& aTitle,
    1:                               const nsACString& aIconURI,
    1:                               const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:                               nsNavHistoryQueryOptions* aOptions);
12328:   nsNavHistoryQueryResultNode(const nsACString& aTitle,
12328:                               const nsACString& aIconURI,
12328:                               PRTime aTime,
12328:                               const nsCOMArray<nsNavHistoryQuery>& aQueries,
12328:                               nsNavHistoryQueryOptions* aOptions);
    1: 
 1740:   NS_DECL_ISUPPORTS_INHERITED
    1:   NS_FORWARD_COMMON_RESULTNODE_TO_BASE
    1:   NS_IMETHOD GetType(PRUint32* type)
    1:     { *type = nsNavHistoryResultNode::RESULT_TYPE_QUERY; return NS_OK; }
    1:   NS_IMETHOD GetUri(nsACString& aURI); // does special lazy creation
    1:   NS_FORWARD_CONTAINERNODE_EXCEPT_HASCHILDREN_AND_READONLY
    1:   NS_IMETHOD GetHasChildren(PRBool* aHasChildren);
    1:   NS_IMETHOD GetChildrenReadOnly(PRBool *aChildrenReadOnly)
    1:     { return nsNavHistoryContainerResultNode::GetChildrenReadOnly(aChildrenReadOnly); }
 1740:   NS_DECL_NSINAVHISTORYQUERYRESULTNODE
    1: 
    1:   PRBool CanExpand();
14224:   PRBool IsContainersQuery();
    1: 
    1:   virtual nsresult OpenContainer();
    1: 
    1:   NS_DECL_BOOKMARK_HISTORY_OBSERVER
    1:   virtual void OnRemoving();
    1: 
    1: public:
    1:   // this constructs lazily mURI from mQueries and mOptions, call
    1:   // VerifyQueriesSerialized either this or mQueries/mOptions should be valid
    1:   nsresult VerifyQueriesSerialized();
    1: 
    1:   // these may be constructed lazily from mURI, call VerifyQueriesParsed
    1:   // either this or mURI should be valid
    1:   nsCOMArray<nsNavHistoryQuery> mQueries;
    1:   PRUint32 mLiveUpdate; // one of QUERYUPDATE_* in nsNavHistory.h
    1:   PRBool mHasSearchTerms;
    1:   nsresult VerifyQueriesParsed();
    1: 
15159:   // safe options getter, ensures queries are parsed
15159:   nsNavHistoryQueryOptions* Options();
15159: 
    1:   // this indicates whether the query contents are valid, they don't go away
    1:   // after the container is closed until a notification comes in
    1:   PRBool mContentsValid;
    1: 
    1:   PRBool mBatchInProgress;
    1: 
    1:   nsresult FillChildren();
    1:   void ClearChildren(PRBool unregister);
    1:   nsresult Refresh();
    1: 
  809:   virtual PRUint16 GetSortType();
  713:   virtual void GetSortingAnnotation(nsACString& aSortingAnnotation);
    1: };
    1: 
    1: 
    1: // nsNavHistoryFolderResultNode
    1: //
    1: //    Overridden container type for bookmark folders. It will keep the contents
    1: //    of the folder in sync with the bookmark service.
    1: 
    1: class nsNavHistoryFolderResultNode : public nsNavHistoryContainerResultNode,
 1431:                                      public nsINavHistoryQueryResultNode
    1: {
    1: public:
    1:   nsNavHistoryFolderResultNode(const nsACString& aTitle,
    1:                                nsNavHistoryQueryOptions* options,
    1:                                PRInt64 aFolderId,
 4179:                                const nsACString& aDynamicContainerType);
    1: 
13683:   virtual ~nsNavHistoryFolderResultNode();
13683: 
    1:   NS_DECL_ISUPPORTS_INHERITED
10046:   NS_FORWARD_COMMON_RESULTNODE_TO_BASE_NO_GETITEMMID
10675:   NS_IMETHOD GetType(PRUint32* type) {
10675:     if (mQueryItemId != -1) {
10675:       *type = nsNavHistoryResultNode::RESULT_TYPE_FOLDER_SHORTCUT;
10675:     } else {
10675:       *type = nsNavHistoryResultNode::RESULT_TYPE_FOLDER;
10675:     }
10675:     return NS_OK;
10675:   }
    1:   NS_IMETHOD GetUri(nsACString& aURI);
    1:   NS_FORWARD_CONTAINERNODE_EXCEPT_HASCHILDREN_AND_READONLY
    1:   NS_IMETHOD GetHasChildren(PRBool* aHasChildren);
    1:   NS_IMETHOD GetChildrenReadOnly(PRBool *aChildrenReadOnly);
10046:   NS_IMETHOD GetItemId(PRInt64 *aItemId);
    1:   NS_DECL_NSINAVHISTORYQUERYRESULTNODE
    1: 
    1:   virtual nsresult OpenContainer();
    1: 
    1:   // This object implements a bookmark observer interface without deriving from
    1:   // the bookmark observers. This is called from the result's actual observer
    1:   // and it knows all observers are FolderResultNodes
    1:   NS_DECL_NSINAVBOOKMARKOBSERVER
    1: 
    1:   virtual void OnRemoving();
    1: 
    1: public:
    1: 
    1:   // this indicates whether the folder contents are valid, they don't go away
    1:   // after the container is closed until a notification comes in
    1:   PRBool mContentsValid;
    1: 
10046:   // If the node is generated from a place:folder=X query, this is the query's
10046:   // itemId.
10046:   PRInt64 mQueryItemId;
10046: 
    1:   nsresult FillChildren();
    1:   void ClearChildren(PRBool aUnregister);
    1:   nsresult Refresh();
    1: 
    1:   PRBool StartIncrementalUpdate();
    1:   void ReindexRange(PRInt32 aStartIndex, PRInt32 aEndIndex, PRInt32 aDelta);
    1: 
 1347:   nsNavHistoryResultNode* FindChildById(PRInt64 aItemId,
    1:                                         PRUint32* aNodeIndex);
13683: 
13683: private:
13683: 
13683:   PRBool mIsRegisteredFolderObserver;
    1: };
    1: 
    1: // nsNavHistorySeparatorResultNode
    1: //
    1: // Separator result nodes do not hold any data.
    1: class nsNavHistorySeparatorResultNode : public nsNavHistoryResultNode
    1: {
    1: public:
    1:   nsNavHistorySeparatorResultNode();
    1: 
    1:   NS_IMETHOD GetType(PRUint32* type)
    1:     { *type = nsNavHistoryResultNode::RESULT_TYPE_SEPARATOR; return NS_OK; }
    1: };
    1: 
    1: #endif // nsNavHistoryResult_h_
