 81005: 
 81005: /*
 81005:  * Copyright 2006 The Android Open Source Project
 81005:  *
 81005:  * Use of this source code is governed by a BSD-style license that can be
 81005:  * found in the LICENSE file.
 81005:  */
 81005: 
 81005: 
 81005: #ifndef SkDraw_DEFINED
 81005: #define SkDraw_DEFINED
 81005: 
 81005: #include "SkBitmap.h"
 81005: #include "SkCanvas.h"
 81005: #include "SkMask.h"
 81005: #include "SkMatrix.h"
 81005: #include "SkPaint.h"
 81005: #include "SkRect.h"
 81005: #include "SkAutoKern.h"
 81005: 
 81005: class SkBounder;
 81005: class SkClipStack;
 81005: class SkDevice;
 81005: class SkPath;
 81005: class SkRegion;
 81005: class SkRasterClip;
 81005: struct SkDrawProcs;
 81005: 
 81005: class SkDraw {
 81005: public:
 81005:     SkDraw();
 81005:     SkDraw(const SkDraw& src);
 81005: 
 81005:     void    drawPaint(const SkPaint&) const;
 81005:     void    drawPoints(SkCanvas::PointMode, size_t count, const SkPoint[],
 81005:                        const SkPaint&, bool forceUseDevice = false) const;
 81005:     void    drawRect(const SkRect&, const SkPaint&) const;
 81005:     /**
 81005:      *  To save on mallocs, we allow a flag that tells us that srcPath is
 81005:      *  mutable, so that we don't have to make copies of it as we transform it.
 81005:      *
 81005:      *  If prePathMatrix is not null, it should logically be applied before any
 81005:      *  stroking or other effects. If there are no effects on the paint that
 81005:      *  affect the geometry/rasterization, then the pre matrix can just be
 81005:      *  pre-concated with the current matrix.
 81005:      */
 81005:     void    drawPath(const SkPath& srcPath, const SkPaint&,
 81005:                      const SkMatrix* prePathMatrix, bool pathIsMutable) const;
 81005:     void    drawBitmap(const SkBitmap&, const SkMatrix&, const SkPaint&) const;
 81005:     void    drawSprite(const SkBitmap&, int x, int y, const SkPaint&) const;
 81005:     void    drawText(const char text[], size_t byteLength, SkScalar x,
 81005:                      SkScalar y, const SkPaint& paint) const;
 81005:     void    drawPosText(const char text[], size_t byteLength,
 81005:                         const SkScalar pos[], SkScalar constY,
 81005:                         int scalarsPerPosition, const SkPaint& paint) const;
 81005:     void    drawTextOnPath(const char text[], size_t byteLength,
 81005:                         const SkPath&, const SkMatrix*, const SkPaint&) const;
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005:     void    drawPosTextOnPath(const char text[], size_t byteLength,
 81005:                               const SkPoint pos[], const SkPaint& paint,
 81005:                               const SkPath& path, const SkMatrix* matrix) const;
 81005: #endif
 81005:     void    drawVertices(SkCanvas::VertexMode mode, int count,
 81005:                          const SkPoint vertices[], const SkPoint textures[],
 81005:                          const SkColor colors[], SkXfermode* xmode,
 81005:                          const uint16_t indices[], int ptCount,
 81005:                          const SkPaint& paint) const;
 81005: 
 81005:     void drawPath(const SkPath& src, const SkPaint& paint) const {
 81005:         this->drawPath(src, paint, NULL, false);
 81005:     }
 81005: 
 81005:     /** Helper function that creates a mask from a path and an optional maskfilter.
 81005:         Note however, that the resulting mask will not have been actually filtered,
 81005:         that must be done afterwards (by calling filterMask). The maskfilter is provided
 81005:         solely to assist in computing the mask's bounds (if the mode requests that).
 81005:     */
 81005:     static bool DrawToMask(const SkPath& devPath, const SkIRect* clipBounds,
 81005:                            SkMaskFilter* filter, const SkMatrix* filterMatrix,
 99650:                            SkMask* mask, SkMask::CreateMode mode,
 99650:                            SkPaint::Style style);
 81005: 
 81005:     enum RectType {
 81005:         kHair_RectType,
 81005:         kFill_RectType,
 81005:         kStroke_RectType,
 81005:         kPath_RectType
 81005:     };
 81005: 
 81005:     /**
 81005:      *  Based on the paint's style, strokeWidth, and the matrix, classify how
 81005:      *  to draw the rect. If no special-case is available, returns
 81005:      *  kPath_RectType.
 81005:      *
 81005:      *  Iff RectType == kStroke_RectType, then strokeSize is set to the device
 81005:      *  width and height of the stroke.
 81005:      */
 81005:     static RectType ComputeRectType(const SkPaint&, const SkMatrix&,
 81005:                                     SkPoint* strokeSize);
 81005: 
 81005: private:
 81005:     void    drawText_asPaths(const char text[], size_t byteLength,
 81005:                              SkScalar x, SkScalar y, const SkPaint&) const;
 81005:     void    drawDevMask(const SkMask& mask, const SkPaint&) const;
 81005:     void    drawBitmapAsMask(const SkBitmap&, const SkPaint&) const;
 81005: 
 81005: public:
 81005:     const SkBitmap* fBitmap;        // required
 81005:     const SkMatrix* fMatrix;        // required
 81005:     const SkRegion* fClip;          // DEPRECATED
 81005:     const SkRasterClip* fRC;        // required
 81005: 
 81005:     const SkClipStack* fClipStack;  // optional
 81005:     SkDevice*       fDevice;        // optional
 81005:     SkBounder*      fBounder;       // optional
 81005:     SkDrawProcs*    fProcs;         // optional
 81005: 
 81005:     const SkMatrix* fMVMatrix;      // optional
 81005:     const SkMatrix* fExtMatrix;     // optional
 81005: 
 81005: #ifdef SK_DEBUG
 81005:     void validate() const;
 81005: #else
 81005:     void validate() const {}
 81005: #endif
 81005: };
 81005: 
 81005: class SkGlyphCache;
 81005: 
 81005: class SkTextToPathIter {
 81005: public:
 99650:     SkTextToPathIter(const char text[], size_t length, const SkPaint& paint,
101753:                      bool applyStrokeAndPathEffects);
 81005:     ~SkTextToPathIter();
 81005: 
 81005:     const SkPaint&  getPaint() const { return fPaint; }
 81005:     SkScalar        getPathScale() const { return fScale; }
 81005: 
 81005:     const SkPath*   next(SkScalar* xpos);   //!< returns nil when there are no more paths
 81005: 
 81005: private:
 81005:     SkGlyphCache*   fCache;
 81005:     SkPaint         fPaint;
 81005:     SkScalar        fScale;
 81005:     SkFixed         fPrevAdvance;
 81005:     const char*     fText;
 81005:     const char*     fStop;
 81005:     SkMeasureCacheProc fGlyphCacheProc;
 81005: 
 81005:     const SkPath*   fPath;      // returned in next
 81005:     SkScalar        fXPos;      // accumulated xpos, returned in next
 81005:     SkAutoKern      fAutoKern;
 87682:     int             fXYIndex;   // cache for horizontal -vs- vertical text
 81005: };
 81005: 
 81005: #endif
 81005: 
 81005: 
