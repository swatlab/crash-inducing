75615: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
75615: /* vim: set ts=40 sw=4 et tw=99: */
75615: /* ***** BEGIN LICENSE BLOCK *****
75615:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
75615:  *
75615:  * The contents of this file are subject to the Mozilla Public License Version
75615:  * 1.1 (the "License"); you may not use this file except in compliance with
75615:  * the License. You may obtain a copy of the License at
75615:  * http://www.mozilla.org/MPL/
75615:  *
75615:  * Software distributed under the License is distributed on an "AS IS" basis,
75615:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
75615:  * for the specific language governing rights and limitations under the
75615:  * License.
75615:  *
75615:  * The Original Code is the Mozilla SpiderMonkey bytecode type inference
75615:  *
75615:  * The Initial Developer of the Original Code is
75615:  *   Mozilla Foundation
75615:  * Portions created by the Initial Developer are Copyright (C) 2010
75615:  * the Initial Developer. All Rights Reserved.
75615:  *
75615:  * Contributor(s):
75615:  *   Brian Hackett <bhackett@mozilla.com>
75615:  *
75615:  * Alternatively, the contents of this file may be used under the terms of
75615:  * either of the GNU General Public License Version 2 or later (the "GPL"),
75615:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
75615:  * in which case the provisions of the GPL or the LGPL are applicable instead
75615:  * of those above. If you wish to allow use of your version of this file only
75615:  * under the terms of either the GPL or the LGPL, and not to allow others to
75615:  * use your version of this file under the terms of the MPL, indicate your
75615:  * decision by deleting the provisions above and replace them with the notice
75615:  * and other provisions required by the GPL or the LGPL. If you do not delete
75615:  * the provisions above, a recipient may use your version of this file under
75615:  * the terms of any one of the MPL, the GPL or the LGPL.
75615:  *
75615:  * ***** END LICENSE BLOCK ***** */
75615: 
75615: #include "jsapi.h"
75615: #include "jsautooplen.h"
75615: #include "jsbit.h"
75615: #include "jsbool.h"
75615: #include "jsdate.h"
75615: #include "jsexn.h"
77404: #include "jsfriendapi.h"
75637: #include "jsgc.h"
75985: #include "jsgcmark.h"
75615: #include "jsinfer.h"
75615: #include "jsmath.h"
75615: #include "jsnum.h"
75615: #include "jsobj.h"
75615: #include "jsscript.h"
75615: #include "jscntxt.h"
75615: #include "jsscan.h"
75615: #include "jsscope.h"
75615: #include "jsstr.h"
75615: #include "jstl.h"
75615: #include "jsiter.h"
75615: 
75636: #include "methodjit/MethodJIT.h"
75636: #include "methodjit/Retcon.h"
75636: 
75640: #include "jsatominlines.h"
75948: #include "jsgcinlines.h"
75615: #include "jsinferinlines.h"
75615: #include "jsobjinlines.h"
75615: #include "jsscriptinlines.h"
76059: #include "vm/Stack-inl.h"
75615: 
75615: #ifdef JS_HAS_XML_SUPPORT
75615: #include "jsxml.h"
75615: #endif
75615: 
77389: #ifdef __SUNPRO_CC
77389: #include <alloca.h>
77389: #endif
77389: 
75987: using namespace js;
75987: using namespace js::types;
76059: using namespace js::analyze;
75987: 
75615: static inline jsid
75615: id_prototype(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_arguments(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_length(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
75615: }
75615: 
75615: static inline jsid
75615: id___proto__(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_constructor(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.constructorAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_caller(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.callerAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_toString(JSContext *cx)
75615: {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.toStringAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_toSource(JSContext *cx)
75615: {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.toSourceAtom);
75615: }
75615: 
77353: #ifdef DEBUG
75720: const char *
75987: types::TypeIdStringImpl(jsid id)
75720: {
75720:     if (JSID_IS_VOID(id))
75720:         return "(index)";
75720:     if (JSID_IS_EMPTY(id))
75720:         return "(new)";
75720:     static char bufs[4][100];
75720:     static unsigned which = 0;
75720:     which = (which + 1) & 3;
75720:     PutEscapedString(bufs[which], 100, JSID_TO_FLAT_STRING(id), 0);
75720:     return bufs[which];
75720: }
77353: #endif
75720: 
75615: /////////////////////////////////////////////////////////////////////
75638: // Logging
75638: /////////////////////////////////////////////////////////////////////
75638: 
75638: static bool InferSpewActive(SpewChannel channel)
75638: {
75638:     static bool active[SPEW_COUNT];
75638:     static bool checked = false;
75638:     if (!checked) {
75638:         checked = true;
75638:         PodArrayZero(active);
75638:         const char *env = getenv("INFERFLAGS");
75638:         if (!env)
75638:             return false;
75638:         if (strstr(env, "ops"))
75638:             active[ISpewOps] = true;
75638:         if (strstr(env, "result"))
75638:             active[ISpewResult] = true;
75638:         if (strstr(env, "full")) {
75638:             for (unsigned i = 0; i < SPEW_COUNT; i++)
75638:                 active[i] = true;
75638:         }
75638:     }
75638:     return active[channel];
75638: }
75638: 
76186: #ifdef DEBUG
76186: 
76182: static bool InferSpewColorable()
76182: {
76182:     /* Only spew colors on xterm-color to not screw up emacs. */
76182:     const char *env = getenv("TERM");
76182:     if (!env)
76182:         return false;
76182:     return strcmp(env, "xterm-color") == 0;
76182: }
76182: 
75640: const char *
76184: types::InferSpewColorReset()
76184: {
76184:     if (!InferSpewColorable())
76184:         return "";
76184:     return "\x1b[0m";
76184: }
76184: 
76184: const char *
76182: types::InferSpewColor(TypeConstraint *constraint)
76182: {
76184:     /* Type constraints are printed out using foreground colors. */
76182:     static const char *colors[] = { "\x1b[31m", "\x1b[32m", "\x1b[33m",
76182:                                     "\x1b[34m", "\x1b[35m", "\x1b[36m",
76182:                                     "\x1b[37m" };
76182:     if (!InferSpewColorable())
76182:         return "";
76182:     return colors[DefaultHasher<TypeConstraint *>::hash(constraint) % 7];
76182: }
76182: 
76182: const char *
76182: types::InferSpewColor(TypeSet *types)
76182: {
76182:     /* Type sets are printed out using bold colors. */
76182:     static const char *colors[] = { "\x1b[1;31m", "\x1b[1;32m", "\x1b[1;33m",
76182:                                     "\x1b[1;34m", "\x1b[1;35m", "\x1b[1;36m",
76182:                                     "\x1b[1;37m" };
76182:     if (!InferSpewColorable())
76182:         return "";
76182:     return colors[DefaultHasher<TypeSet *>::hash(types) % 7];
76182: }
76182: 
76182: const char *
77353: types::TypeString(Type type)
77353: {
77353:     if (type.isPrimitive()) {
77353:         switch (type.primitive()) {
77353:           case JSVAL_TYPE_UNDEFINED:
75640:             return "void";
77353:           case JSVAL_TYPE_NULL:
75640:             return "null";
77353:           case JSVAL_TYPE_BOOLEAN:
75640:             return "bool";
77353:           case JSVAL_TYPE_INT32:
75640:             return "int";
77353:           case JSVAL_TYPE_DOUBLE:
75640:             return "float";
77353:           case JSVAL_TYPE_STRING:
75640:             return "string";
77353:           case JSVAL_TYPE_MAGIC:
76128:             return "lazyargs";
77353:           default:
77353:             JS_NOT_REACHED("Bad type");
77353:             return "";
77353:         }
77353:     }
77353:     if (type.isUnknown())
75640:         return "unknown";
77353:     if (type.isAnyObject())
77353:         return " object";
77461: 
77353:     static char bufs[4][40];
77353:     static unsigned which = 0;
77353:     which = (which + 1) & 3;
77461: 
77461:     if (type.isSingleObject())
77353:         JS_snprintf(bufs[which], 40, "<0x%p>", (void *) type.singleObject());
77461:     else
77461:         JS_snprintf(bufs[which], 40, "[0x%p]", (void *) type.typeObject());
77461: 
77353:     return bufs[which];
77353: }
77461: 
77461: const char *
77461: types::TypeObjectString(TypeObject *type)
77461: {
77461:     return TypeString(Type::ObjectType(type));
75640: }
75640: 
75987: void
75987: types::InferSpew(SpewChannel channel, const char *fmt, ...)
75638: {
75638:     if (!InferSpewActive(channel))
75638:         return;
75638: 
75638:     va_list ap;
75638:     va_start(ap, fmt);
75638:     fprintf(stdout, "[infer] ");
75638:     vfprintf(stdout, fmt, ap);
75638:     fprintf(stdout, "\n");
75638:     va_end(ap);
75638: }
75638: 
75737: bool
75987: types::TypeHasProperty(JSContext *cx, TypeObject *obj, jsid id, const Value &value)
75737: {
75737:     /*
75737:      * Check the correctness of the type information in the object's property
77353:      * against an actual value.
75737:      */
75919:     if (cx->typeInferenceEnabled() && !obj->unknownProperties() && !value.isUndefined()) {
75737:         id = MakeTypeId(cx, id);
75737: 
75737:         /* Watch for properties which inference does not monitor. */
75737:         if (id == id___proto__(cx) || id == id_constructor(cx) || id == id_caller(cx))
75737:             return true;
75737: 
75737:         /*
75737:          * If we called in here while resolving a type constraint, we may be in the
75737:          * middle of resolving a standard class and the type sets will not be updated
75737:          * until the outer TypeSet::add finishes.
75737:          */
75737:         if (cx->compartment->types.pendingCount)
75737:             return true;
75737: 
77353:         Type type = GetValueType(cx, value);
75737: 
75737:         AutoEnterTypeInference enter(cx);
75737: 
77353:         /*
77361:          * We don't track types for properties inherited from prototypes which
77361:          * haven't yet been accessed during analysis of the inheriting object.
77361:          * Don't do the property instantiation now.
77353:          */
77361:         TypeSet *types = obj->maybeGetProperty(cx, id);
77361:         if (!types)
77353:             return true;
77353: 
77361:         /*
77361:          * If the types inherited from prototypes are not being propagated into
77361:          * this set (because we haven't analyzed code which accesses the
77361:          * property), skip.
77361:          */
77361:         if (!types->hasPropagatedProperty())
77361:             return true;
77361: 
77361:         if (!types->hasType(type)) {
75737:             TypeFailure(cx, "Missing type in object %s %s: %s",
77461:                         TypeObjectString(obj), TypeIdString(id), TypeString(type));
75737:         }
75737:     }
75737:     return true;
75737: }
75737: 
75640: #endif
75640: 
75987: void
75987: types::TypeFailure(JSContext *cx, const char *fmt, ...)
75638: {
76150:     char msgbuf[1024]; /* Larger error messages will be truncated */
76150:     char errbuf[1024];
76150: 
75638:     va_list ap;
75638:     va_start(ap, fmt);
76150:     JS_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);
75638:     va_end(ap);
75638: 
76150:     JS_snprintf(msgbuf, sizeof(msgbuf), "[infer failure] %s", errbuf);
76150: 
77440:     /* Dump type state, even if INFERFLAGS is unset. */
77440:     cx->compartment->types.print(cx, true);
75640: 
76150:     /* Always active, even in release builds */
76150:     JS_Assert(msgbuf, __FILE__, __LINE__);
76150:     
76150:     *((int*)NULL) = 0;  /* Should never be reached */
75640: }
75638: 
75638: /////////////////////////////////////////////////////////////////////
75615: // TypeSet
75615: /////////////////////////////////////////////////////////////////////
75615: 
76175: TypeSet *
76175: TypeSet::make(JSContext *cx, const char *name)
76175: {
76175:     JS_ASSERT(cx->compartment->activeInference);
76175: 
76175:     TypeSet *res = ArenaNew<TypeSet>(cx->compartment->pool);
76175:     if (!res) {
76175:         cx->compartment->types.setPendingNukeTypes(cx);
76175:         return NULL;
76175:     }
76175: 
76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s intermediate %s",
76182:               InferSpewColor(res), res, InferSpewColorReset(),
76182:               name);
76175: 
76175:     return res;
76175: }
76175: 
75615: inline void
75615: TypeSet::add(JSContext *cx, TypeConstraint *constraint, bool callExisting)
75615: {
76093:     if (!constraint) {
76093:         /* OOM failure while constructing the constraint. */
76093:         cx->compartment->types.setPendingNukeTypes(cx);
76093:         return;
76093:     }
76093: 
77353:     JS_ASSERT(cx->compartment->activeInference);
75720: 
76182:     InferSpew(ISpewOps, "addConstraint: %sT%p%s %sC%p%s %s",
76182:               InferSpewColor(this), this, InferSpewColorReset(),
76182:               InferSpewColor(constraint), constraint, InferSpewColorReset(),
76182:               constraint->kind());
75615: 
75615:     JS_ASSERT(constraint->next == NULL);
75615:     constraint->next = constraintList;
75615:     constraintList = constraint;
75615: 
75615:     if (!callExisting)
75615:         return;
75615: 
77361:     if (flags & TYPE_FLAG_UNKNOWN) {
77353:         cx->compartment->types.addPending(cx, constraint, this, Type::UnknownType());
75615:         cx->compartment->types.resolvePending(cx);
75615:         return;
75615:     }
75615: 
77353:     for (TypeFlags flag = 1; flag < TYPE_FLAG_ANYOBJECT; flag <<= 1) {
77361:         if (flags & flag) {
77353:             Type type = Type::PrimitiveType(TypeFlagPrimitive(flag));
75615:             cx->compartment->types.addPending(cx, constraint, this, type);
75615:         }
77353:     }
77353: 
77361:     if (flags & TYPE_FLAG_ANYOBJECT) {
77353:         cx->compartment->types.addPending(cx, constraint, this, Type::AnyObjectType());
77353:         cx->compartment->types.resolvePending(cx);
77353:         return;
77353:     }
75615: 
75919:     unsigned count = getObjectCount();
75919:     for (unsigned i = 0; i < count; i++) {
77353:         TypeObjectKey *object = getObject(i);
75615:         if (object)
77353:             cx->compartment->types.addPending(cx, constraint, this, Type::ObjectType(object));
75615:     }
75615: 
75615:     cx->compartment->types.resolvePending(cx);
75615: }
75615: 
75615: void
75638: TypeSet::print(JSContext *cx)
75615: {
77361:     if (flags & TYPE_FLAG_OWN_PROPERTY)
75944:         printf(" [own]");
77361:     if (flags & TYPE_FLAG_CONFIGURED_PROPERTY)
75944:         printf(" [configured]");
75944: 
75948:     if (isDefiniteProperty())
75948:         printf(" [definite:%d]", definiteSlot());
75948: 
77361:     if (baseFlags() == 0 && !baseObjectCount()) {
75638:         printf(" missing");
75615:         return;
75615:     }
75615: 
77361:     if (flags & TYPE_FLAG_UNKNOWN)
75638:         printf(" unknown");
77361:     if (flags & TYPE_FLAG_ANYOBJECT)
77353:         printf(" object");
75615: 
77361:     if (flags & TYPE_FLAG_UNDEFINED)
75638:         printf(" void");
77361:     if (flags & TYPE_FLAG_NULL)
75638:         printf(" null");
77361:     if (flags & TYPE_FLAG_BOOLEAN)
75638:         printf(" bool");
77361:     if (flags & TYPE_FLAG_INT32)
75638:         printf(" int");
77361:     if (flags & TYPE_FLAG_DOUBLE)
75638:         printf(" float");
77361:     if (flags & TYPE_FLAG_STRING)
75638:         printf(" string");
77361:     if (flags & TYPE_FLAG_LAZYARGS)
76128:         printf(" lazyargs");
75615: 
77361:     uint32 objectCount = baseObjectCount();
75720:     if (objectCount) {
75638:         printf(" object[%u]", objectCount);
75615: 
75919:         unsigned count = getObjectCount();
75919:         for (unsigned i = 0; i < count; i++) {
77353:             TypeObjectKey *object = getObject(i);
75615:             if (object)
77353:                 printf(" %s", TypeString(Type::ObjectType(object)));
75615:         }
75615:     }
75615: }
75615: 
76059: /////////////////////////////////////////////////////////////////////
76059: // TypeSet constraints
76059: /////////////////////////////////////////////////////////////////////
75718: 
75615: /* Standard subset constraint, propagate all types from one set to another. */
75615: class TypeConstraintSubset : public TypeConstraint
75615: {
75615: public:
75615:     TypeSet *target;
75615: 
77353:     TypeConstraintSubset(TypeSet *target)
77353:         : TypeConstraint("subset"), target(target)
75615:     {
75615:         JS_ASSERT(target);
75615:     }
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type)
76059:     {
76059:         /* Basic subset constraint, move all types to the target. */
76059:         target->addType(cx, type);
76059:     }
75615: };
75615: 
75615: void
77353: TypeSet::addSubset(JSContext *cx, TypeSet *target)
77353: {
77353:     add(cx, ArenaNew<TypeConstraintSubset>(cx->compartment->pool, target));
75718: }
75718: 
75615: /* Constraints for reads/writes on object properties. */
75615: class TypeConstraintProp : public TypeConstraint
75615: {
75615: public:
77353:     JSScript *script;
76103:     jsbytecode *pc;
75615: 
75615:     /*
75615:      * If assign is true, the target is used to update a property of the object.
75615:      * If assign is false, the target is assigned the value of the property.
75615:      */
75615:     bool assign;
75615:     TypeSet *target;
75615: 
75615:     /* Property being accessed. */
75615:     jsid id;
75615: 
76103:     TypeConstraintProp(JSScript *script, jsbytecode *pc,
75708:                        TypeSet *target, jsid id, bool assign)
77353:         : TypeConstraint("prop"), script(script), pc(pc),
75708:           assign(assign), target(target), id(id)
75615:     {
77357:         JS_ASSERT(script && pc && target);
75615:     }
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type);
75615: };
75615: 
75615: void
76103: TypeSet::addGetProperty(JSContext *cx, JSScript *script, jsbytecode *pc,
75708:                         TypeSet *target, jsid id)
75615: {
75987:     add(cx, ArenaNew<TypeConstraintProp>(cx->compartment->pool, script, pc, target, id, false));
75615: }
75615: 
75615: void
76103: TypeSet::addSetProperty(JSContext *cx, JSScript *script, jsbytecode *pc,
75708:                         TypeSet *target, jsid id)
75615: {
75987:     add(cx, ArenaNew<TypeConstraintProp>(cx->compartment->pool, script, pc, target, id, true));
75615: }
75615: 
76136: /*
76136:  * Constraints for updating the 'this' types of callees on CALLPROP/CALLELEM.
76136:  * These are derived from the types on the properties themselves, rather than
76136:  * those pushed in the 'this' slot at the call site, which allows us to retain
76136:  * correlations between the type of the 'this' object and the associated
76136:  * callee scripts at polymorphic call sites.
76136:  */
76136: class TypeConstraintCallProp : public TypeConstraint
76136: {
76136: public:
77353:     JSScript *script;
76136:     jsbytecode *callpc;
76136: 
76136:     /* Property being accessed. */
76136:     jsid id;
76136: 
76136:     TypeConstraintCallProp(JSScript *script, jsbytecode *callpc, jsid id)
77353:         : TypeConstraint("callprop"), script(script), callpc(callpc), id(id)
76136:     {
76136:         JS_ASSERT(script && callpc);
76136:     }
76136: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type);
76136: };
76136: 
76136: void
76136: TypeSet::addCallProperty(JSContext *cx, JSScript *script, jsbytecode *pc, jsid id)
76136: {
76136:     /*
76136:      * For calls which will go through JSOP_NEW, don't add any constraints to
76136:      * modify the 'this' types of callees. The initial 'this' value will be
76136:      * outright ignored.
76136:      */
77391:     jsbytecode *callpc = script->analysis()->getCallPC(pc);
76136:     UntrapOpcode untrap(cx, script, callpc);
76136:     if (JSOp(*callpc) == JSOP_NEW)
76136:         return;
76136: 
76136:     add(cx, ArenaNew<TypeConstraintCallProp>(cx->compartment->pool, script, callpc, id));
76136: }
76136: 
75615: /*
77399:  * Constraints for generating 'set' property constraints on a SETELEM only if
77399:  * the element type may be a number. For SETELEM we only account for integer
77399:  * indexes, and if the element cannot be an integer (e.g. it must be a string)
77399:  * then we lose precision by treating it like one.
77399:  */
77399: class TypeConstraintSetElement : public TypeConstraint
77399: {
77399: public:
77399:     JSScript *script;
77399:     jsbytecode *pc;
77399: 
77399:     TypeSet *objectTypes;
77399:     TypeSet *valueTypes;
77399: 
77399:     TypeConstraintSetElement(JSScript *script, jsbytecode *pc,
77399:                              TypeSet *objectTypes, TypeSet *valueTypes)
77399:         : TypeConstraint("setelement"), script(script), pc(pc),
77399:           objectTypes(objectTypes), valueTypes(valueTypes)
77399:     {
77399:         JS_ASSERT(script && pc);
77399:     }
77399: 
77399:     void newType(JSContext *cx, TypeSet *source, Type type);
77399: };
77399: 
77399: void
77399: TypeSet::addSetElement(JSContext *cx, JSScript *script, jsbytecode *pc,
77399:                        TypeSet *objectTypes, TypeSet *valueTypes)
77399: {
77399:     add(cx, ArenaNew<TypeConstraintSetElement>(cx->compartment->pool, script, pc,
77399:                                                objectTypes, valueTypes));
77399: }
77399: 
77399: /*
75615:  * Constraints for watching call edges as they are discovered and invoking native
75615:  * function handlers, adding constraints for arguments, receiver objects and the
75615:  * return value, and updating script foundOffsets.
75615:  */
75615: class TypeConstraintCall : public TypeConstraint
75615: {
75615: public:
75615:     /* Call site being tracked. */
75615:     TypeCallsite *callsite;
75615: 
75615:     TypeConstraintCall(TypeCallsite *callsite)
77353:         : TypeConstraint("call"), callsite(callsite)
75615:     {}
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type);
75615: };
75615: 
75615: void
75615: TypeSet::addCall(JSContext *cx, TypeCallsite *site)
75615: {
75987:     add(cx, ArenaNew<TypeConstraintCall>(cx->compartment->pool, site));
75615: }
75615: 
75615: /* Constraints for arithmetic operations. */
75615: class TypeConstraintArith : public TypeConstraint
75615: {
75615: public:
75615:     /* Type set receiving the result of the arithmetic. */
75615:     TypeSet *target;
75615: 
75615:     /* For addition operations, the other operand. */
75615:     TypeSet *other;
75615: 
77353:     TypeConstraintArith(TypeSet *target, TypeSet *other)
77353:         : TypeConstraint("arith"), target(target), other(other)
75615:     {
75615:         JS_ASSERT(target);
75615:     }
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type);
75615: };
75615: 
75615: void
77353: TypeSet::addArith(JSContext *cx, TypeSet *target, TypeSet *other)
77353: {
77353:     add(cx, ArenaNew<TypeConstraintArith>(cx->compartment->pool, target, other));
75615: }
75615: 
75615: /* Subset constraint which transforms primitive values into appropriate objects. */
75615: class TypeConstraintTransformThis : public TypeConstraint
75615: {
75615: public:
77353:     JSScript *script;
75615:     TypeSet *target;
75615: 
75708:     TypeConstraintTransformThis(JSScript *script, TypeSet *target)
77353:         : TypeConstraint("transformthis"), script(script), target(target)
75615:     {}
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type);
75615: };
75615: 
75615: void
75708: TypeSet::addTransformThis(JSContext *cx, JSScript *script, TypeSet *target)
75615: {
75987:     add(cx, ArenaNew<TypeConstraintTransformThis>(cx->compartment->pool, script, target));
75615: }
75615: 
76103: /*
76103:  * Constraint which adds a particular type to the 'this' types of all
76103:  * discovered scripted functions.
76103:  */
76103: class TypeConstraintPropagateThis : public TypeConstraint
76103: {
76103: public:
77353:     JSScript *script;
76136:     jsbytecode *callpc;
77353:     Type type;
77353: 
77353:     TypeConstraintPropagateThis(JSScript *script, jsbytecode *callpc, Type type)
77353:         : TypeConstraint("propagatethis"), script(script), callpc(callpc), type(type)
76103:     {}
76103: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type);
76103: };
76103: 
76103: void
77353: TypeSet::addPropagateThis(JSContext *cx, JSScript *script, jsbytecode *pc, Type type)
76103: {
76136:     /* Don't add constraints when the call will be 'new' (see addCallProperty). */
77391:     jsbytecode *callpc = script->analysis()->getCallPC(pc);
76103:     UntrapOpcode untrap(cx, script, callpc);
76103:     if (JSOp(*callpc) == JSOP_NEW)
76103:         return;
76136: 
76136:     add(cx, ArenaNew<TypeConstraintPropagateThis>(cx->compartment->pool, script, callpc, type));
76103: }
76103: 
75615: /* Subset constraint which filters out primitive types. */
75615: class TypeConstraintFilterPrimitive : public TypeConstraint
75615: {
75615: public:
75615:     TypeSet *target;
75615: 
75615:     /* Primitive types other than null and undefined are passed through. */
75615:     bool onlyNullVoid;
75615: 
77353:     TypeConstraintFilterPrimitive(TypeSet *target, bool onlyNullVoid)
77353:         : TypeConstraint("filter"), target(target), onlyNullVoid(onlyNullVoid)
75615:     {}
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type)
76059:     {
76059:         if (onlyNullVoid) {
77353:             if (type.isPrimitive(JSVAL_TYPE_NULL) || type.isPrimitive(JSVAL_TYPE_UNDEFINED))
76059:                 return;
77353:         } else if (type.isPrimitive()) {
76059:             return;
76059:         }
76059: 
76059:         target->addType(cx, type);
76059:     }
75615: };
75615: 
75615: void
77353: TypeSet::addFilterPrimitives(JSContext *cx, TypeSet *target, bool onlyNullVoid)
75615: {
75987:     add(cx, ArenaNew<TypeConstraintFilterPrimitive>(cx->compartment->pool,
77353:                                                     target, onlyNullVoid));
75615: }
75615: 
77461: /* If id is a normal slotful 'own' property of an object, get its shape. */
77461: static inline const Shape *
77461: GetSingletonShape(JSObject *obj, jsid id)
77461: {
77461:     const Shape *shape = obj->nativeLookup(id);
77461:     if (shape && shape->hasDefaultGetterOrIsMethod() && shape->slot != SHAPE_INVALID_SLOT)
77461:         return shape;
77461:     return NULL;
77461: }
77461: 
76087: void
76103: ScriptAnalysis::pruneTypeBarriers(uint32 offset)
76087: {
76087:     TypeBarrier **pbarrier = &getCode(offset).typeBarriers;
76087:     while (*pbarrier) {
76087:         TypeBarrier *barrier = *pbarrier;
76087:         if (barrier->target->hasType(barrier->type)) {
76087:             /* Barrier is now obsolete, it can be removed. */
76087:             *pbarrier = barrier->next;
77460:             continue;
77460:         }
77460:         if (barrier->singleton) {
77460:             JS_ASSERT(barrier->type.isPrimitive(JSVAL_TYPE_UNDEFINED));
77461:             const Shape *shape = GetSingletonShape(barrier->singleton, barrier->singletonId);
77461:             if (shape && !barrier->singleton->nativeGetSlot(shape->slot).isUndefined()) {
77460:                 /*
77460:                  * When we analyzed the script the singleton had an 'own'
77460:                  * property which was undefined (probably a 'var' variable
77460:                  * added to a global object), but now it is defined. The only
77460:                  * way it can become undefined again is if an explicit assign
77460:                  * or deletion on the property occurs, which will update the
77460:                  * type set for the property directly and trigger construction
77460:                  * of a normal type barrier.
77460:                  */
77460:                 *pbarrier = barrier->next;
77460:                 continue;
77460:             }
77460:         }
76103:         pbarrier = &barrier->next;
76103:     }
76103: }
76103: 
76103: /*
76103:  * Cheesy limit on the number of objects we will tolerate in an observed type
76103:  * set before refusing to add new type barriers for objects.
76103:  * :FIXME: this heuristic sucks, and doesn't handle calls.
76103:  */
76103: static const uint32 BARRIER_OBJECT_LIMIT = 10;
76103: 
76103: void ScriptAnalysis::breakTypeBarriers(JSContext *cx, uint32 offset, bool all)
76103: {
77461:     pruneTypeBarriers(offset);
77461: 
76103:     TypeBarrier **pbarrier = &getCode(offset).typeBarriers;
76103:     while (*pbarrier) {
76103:         TypeBarrier *barrier = *pbarrier;
77463:         if (barrier->target->hasType(barrier->type) ) {
77463:             /*
77463:              * Barrier is now obsolete, it can be removed. This is not
77463:              * redundant with the pruneTypeBarriers() call above, as breaking
77463:              * previous type barriers may have modified the target type set.
77463:              */
77463:             *pbarrier = barrier->next;
77463:         } else if (all) {
76087:             /* Force removal of the barrier. */
76103:             barrier->target->addType(cx, barrier->type);
76087:             *pbarrier = barrier->next;
77353:         } else if (!barrier->type.isUnknown() &&
77353:                    !barrier->type.isAnyObject() &&
77353:                    barrier->type.isObject() &&
77353:                    barrier->target->getObjectCount() >= BARRIER_OBJECT_LIMIT) {
77353:             /* Maximum number of objects in the set exceeded. */
77353:             barrier->target->addType(cx, barrier->type);
77353:             *pbarrier = barrier->next;
76087:         } else {
76087:             pbarrier = &barrier->next;
76087:         }
76087:     }
76087: }
76087: 
76103: void ScriptAnalysis::breakTypeBarriersSSA(JSContext *cx, const SSAValue &v)
76103: {
76103:     if (v.kind() != SSAValue::PUSHED)
76103:         return;
76103: 
76103:     uint32 offset = v.pushedOffset();
76103:     if (JSOp(script->code[offset]) == JSOP_GETPROP)
76103:         breakTypeBarriersSSA(cx, poppedValue(offset, 0));
76103: 
76103:     breakTypeBarriers(cx, offset, true);
76103: }
76103: 
76087: /*
76087:  * Subset constraint for property reads and argument passing which can add type
76087:  * barriers on the read instead of passing types along.
76087:  */
76087: class TypeConstraintSubsetBarrier : public TypeConstraint
75615: {
75615: public:
77353:     JSScript *script;
76103:     jsbytecode *pc;
75615:     TypeSet *target;
75615: 
76103:     TypeConstraintSubsetBarrier(JSScript *script, jsbytecode *pc, TypeSet *target)
77353:         : TypeConstraint("subsetBarrier"), script(script), pc(pc), target(target)
77439:     {}
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type)
76059:     {
76087:         if (!target->hasType(type)) {
77391:             script->analysis()->addTypeBarrier(cx, pc, target, type);
76087:             return;
76087:         }
76087: 
76059:         target->addType(cx, type);
76059:     }
75615: };
75615: 
75615: void
76103: TypeSet::addSubsetBarrier(JSContext *cx, JSScript *script, jsbytecode *pc, TypeSet *target)
75615: {
76087:     add(cx, ArenaNew<TypeConstraintSubsetBarrier>(cx->compartment->pool, script, pc, target));
75615: }
75615: 
75627: /*
76128:  * Constraint which marks a pushed ARGUMENTS value as unknown if the script has
76128:  * an arguments object created in the future.
76128:  */
76128: class TypeConstraintLazyArguments : public TypeConstraint
76128: {
76128: public:
76128:     TypeSet *target;
76128: 
77353:     TypeConstraintLazyArguments(TypeSet *target)
77353:         : TypeConstraint("lazyArgs"), target(target)
76128:     {}
76128: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type) {}
76128: 
76128:     void newObjectState(JSContext *cx, TypeObject *object, bool force)
76128:     {
76128:         if (object->hasAnyFlags(OBJECT_FLAG_CREATED_ARGUMENTS))
77353:             target->addType(cx, Type::UnknownType());
76128:     }
76128: };
76128: 
76128: void
77353: TypeSet::addLazyArguments(JSContext *cx, TypeSet *target)
77353: {
77353:     add(cx, ArenaNew<TypeConstraintLazyArguments>(cx->compartment->pool, target));
76128: }
76128: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeConstraint
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: /* Get the object to use for a property access on type. */
75615: static inline TypeObject *
77353: GetPropertyObject(JSContext *cx, JSScript *script, Type type)
77353: {
77353:     if (type.isTypeObject())
77353:         return type.typeObject();
77353: 
77353:     /* Force instantiation of lazy types for singleton objects. */
77353:     if (type.isSingleObject())
77353:         return type.singleObject()->getType(cx);
75615: 
75615:     /*
75615:      * Handle properties attached to primitive types, treating this access as a
75615:      * read on the primitive's new object.
75615:      */
75720:     TypeObject *object = NULL;
77353:     switch (type.primitive()) {
77353: 
77353:       case JSVAL_TYPE_INT32:
77353:       case JSVAL_TYPE_DOUBLE:
77391:         object = TypeScript::StandardType(cx, script, JSProto_Number);
75720:         break;
75615: 
77353:       case JSVAL_TYPE_BOOLEAN:
77391:         object = TypeScript::StandardType(cx, script, JSProto_Boolean);
75720:         break;
75615: 
77353:       case JSVAL_TYPE_STRING:
77391:         object = TypeScript::StandardType(cx, script, JSProto_String);
75720:         break;
75615: 
75615:       default:
76130:         /* undefined, null and lazy arguments do not have properties. */
75615:         return NULL;
75615:     }
75720: 
75720:     if (!object)
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:     return object;
75615: }
75615: 
76175: static inline bool
76175: UsePropertyTypeBarrier(jsbytecode *pc)
76175: {
76175:     /*
76175:      * At call opcodes, type barriers can only be added for the call bindings,
76175:      * which TypeConstraintCall will add barrier constraints for directly.
76175:      */
76175:     uint32 format = js_CodeSpec[*pc].format;
76175:     return (format & JOF_TYPESET) && !(format & JOF_INVOKE);
76175: }
76175: 
76128: static inline void
76128: MarkPropertyAccessUnknown(JSContext *cx, JSScript *script, jsbytecode *pc, TypeSet *target)
76128: {
76175:     if (UsePropertyTypeBarrier(pc))
77391:         script->analysis()->addTypeBarrier(cx, pc, target, Type::UnknownType());
76128:     else
77353:         target->addType(cx, Type::UnknownType());
76128: }
76128: 
75636: /*
75636:  * Handle a property access on a specific object. All property accesses go through
75636:  * here, whether via x.f, x[f], or global name accesses.
75636:  */
75636: static inline void
76103: PropertyAccess(JSContext *cx, JSScript *script, jsbytecode *pc, TypeObject *object,
75636:                bool assign, TypeSet *target, jsid id)
75636: {
75876:     /* Reads from objects with unknown properties are unknown, writes to such objects are ignored. */
75989:     if (object->unknownProperties()) {
75876:         if (!assign)
76128:             MarkPropertyAccessUnknown(cx, script, pc, target);
75876:         return;
75876:     }
75876: 
75636:     /* Capture the effects of a standard property access. */
75641:     TypeSet *types = object->getProperty(cx, id, assign);
75720:     if (!types)
75720:         return;
77361:     if (assign) {
77353:         target->addSubset(cx, types);
77361:     } else {
77361:         if (!types->hasPropagatedProperty())
77361:             object->getFromPrototypes(cx, id, types);
77460:         if (UsePropertyTypeBarrier(pc)) {
76087:             types->addSubsetBarrier(cx, script, pc, target);
77461:             if (object->singleton && !JSID_IS_VOID(id)) {
77460:                 /*
77461:                  * Add a singleton type barrier on the object if it has an
77461:                  * 'own' property which is currently undefined. We'll be able
77461:                  * to remove the barrier after the property becomes defined,
77461:                  * even if no undefined value is ever observed at pc.
77460:                  */
77461:                 const Shape *shape = GetSingletonShape(object->singleton, id);
77461:                 if (shape && object->singleton->nativeGetSlot(shape->slot).isUndefined())
77460:                     script->analysis()->addSingletonTypeBarrier(cx, pc, target, object->singleton, id);
77460:             }
77460:         } else {
77353:             types->addSubset(cx, target);
77353:         }
77361:     }
77460: }
77353: 
77353: /* Whether the JSObject/TypeObject referent of an access on type cannot be determined. */
77353: static inline bool
77353: UnknownPropertyAccess(JSScript *script, Type type)
77353: {
77353:     return type.isUnknown()
77353:         || type.isAnyObject()
77353:         || (!type.isObject() && !script->hasGlobal());
75636: }
75636: 
75615: void
77353: TypeConstraintProp::newType(JSContext *cx, TypeSet *source, Type type)
75615: {
76128:     UntrapOpcode untrap(cx, script, pc);
76128: 
77353:     if (UnknownPropertyAccess(script, type)) {
75633:         /*
75633:          * Access on an unknown object. Reads produce an unknown result, writes
77353:          * need to be monitored.
75633:          */
75633:         if (assign)
75708:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75633:         else
76128:             MarkPropertyAccessUnknown(cx, script, pc, target);
76128:         return;
76128:     }
76128: 
77353:     if (type.isPrimitive(JSVAL_TYPE_MAGIC)) {
76136:         /* Ignore cases which will be accounted for by the followEscapingArguments analysis. */
76128:         if (assign || (id != JSID_VOID && id != id_length(cx)))
76128:             return;
76128: 
76128:         if (id == JSID_VOID)
76128:             MarkPropertyAccessUnknown(cx, script, pc, target);
76128:         else
77353:             target->addType(cx, Type::Int32Type());
75615:         return;
75615:     }
75615: 
75708:     TypeObject *object = GetPropertyObject(cx, script, type);
76136:     if (object)
76136:         PropertyAccess(cx, script, pc, object, assign, target, id);
76136: }
76136: 
76136: void
77353: TypeConstraintCallProp::newType(JSContext *cx, TypeSet *source, Type type)
76136: {
76136:     UntrapOpcode untrap(cx, script, callpc);
76136: 
76136:     /*
76136:      * For CALLPROP and CALLELEM, we need to update not just the pushed types
76136:      * but also the 'this' types of possible callees. If we can't figure out
76136:      * that set of callees, monitor the call to make sure discovered callees
76136:      * get their 'this' types updated.
76136:      */
76136: 
77353:     if (UnknownPropertyAccess(script, type)) {
76136:         cx->compartment->types.monitorBytecode(cx, script, callpc - script->code);
76136:         return;
76136:     }
76136: 
76136:     TypeObject *object = GetPropertyObject(cx, script, type);
76103:     if (object) {
76136:         if (object->unknownProperties()) {
76136:             cx->compartment->types.monitorBytecode(cx, script, callpc - script->code);
76136:         } else {
76103:             TypeSet *types = object->getProperty(cx, id, false);
76103:             if (!types)
76103:                 return;
77361:             if (!types->hasPropagatedProperty())
77361:                 object->getFromPrototypes(cx, id, types);
76136:             /* Bypass addPropagateThis, we already have the callpc. */
76136:             types->add(cx, ArenaNew<TypeConstraintPropagateThis>(cx->compartment->pool,
76136:                                                                  script, callpc, type));
76103:         }
76103:     }
75615: }
75615: 
75615: void
77399: TypeConstraintSetElement::newType(JSContext *cx, TypeSet *source, Type type)
77399: {
77399:     if (type.isUnknown() ||
77399:         type.isPrimitive(JSVAL_TYPE_INT32) ||
77399:         type.isPrimitive(JSVAL_TYPE_DOUBLE)) {
77399:         objectTypes->addSetProperty(cx, script, pc, valueTypes, JSID_VOID);
77399:     }
77399: }
77399: 
77399: void
77353: TypeConstraintCall::newType(JSContext *cx, TypeSet *source, Type type)
75615: {
75708:     JSScript *script = callsite->script;
76103:     jsbytecode *pc = callsite->pc;
75708: 
77353:     if (type.isUnknown() || type.isAnyObject()) {
75615:         /* Monitor calls on unknown functions. */
75708:         cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75615:         return;
75615:     }
75615: 
77353:     JSScript *callee = NULL;
77353: 
77353:     if (type.isSingleObject()) {
77353:         JSObject *obj = type.singleObject();
77353: 
77353:         if (!obj->isFunction()) {
77353:             /* Calls on non-functions are dynamically monitored. */
75822:             return;
77353:         }
77353: 
77353:         if (obj->getFunctionPrivate()->isNative()) {
75822:             /*
76175:              * The return value and all side effects within native calls should
76175:              * be dynamically monitored, except when the compiler is generating
76175:              * specialized inline code or stub calls for a specific natives and
76175:              * knows about the behavior of that native.
75822:              */
76175:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code, true);
76175: 
76108:             /*
77353:              * Add type constraints capturing the possible behavior of
77353:              * specialized natives which operate on properties. :XXX: use
77353:              * better factoring for both this and the compiler code itself
77353:              * which specializes particular natives.
76108:              */
76175: 
77353:             Native native = obj->getFunctionPrivate()->native();
76175: 
76175:             if (native == js::array_push) {
77413:                 for (size_t i = 0; i < callsite->argumentCount; i++) {
76175:                     callsite->thisTypes->addSetProperty(cx, script, pc,
77413:                                                         callsite->argumentTypes[i], JSID_VOID);
76175:                 }
76175:             }
76175: 
76175:             if (native == js::array_pop)
76175:                 callsite->thisTypes->addGetProperty(cx, script, pc, callsite->returnTypes, JSID_VOID);
76175: 
77413:             if (native == js_Array) {
77413:                 TypeObject *res = TypeScript::InitObject(cx, script, pc, JSProto_Array);
77413:                 if (!res)
77413:                     return;
77413: 
77413:                 callsite->returnTypes->addType(cx, Type::ObjectType(res));
77413: 
77413:                 if (callsite->argumentCount >= 2) {
77413:                     for (unsigned i = 0; i < callsite->argumentCount; i++) {
77413:                         PropertyAccess(cx, script, pc, res, true,
77413:                                        callsite->argumentTypes[i], JSID_VOID);
77413:                     }
77413:                 }
77413:             }
77413: 
76108:             return;
76108:         }
75615: 
77353:         callee = obj->getFunctionPrivate()->script();
77353:     } else if (type.isTypeObject()) {
77353:         callee = type.typeObject()->functionScript;
77353:         if (!callee)
77353:             return;
77353:     } else {
77353:         /* Calls on non-objects are dynamically monitored. */
77353:         return;
77353:     }
77353: 
77391:     unsigned nargs = callee->function()->nargs;
77391: 
77391:     if (!callee->ensureHasTypes(cx))
76092:         return;
76092: 
75708:     /* Analyze the function if we have not already done so. */
76158:     if (!callee->ensureRanInference(cx)) {
75987:         cx->compartment->types.setPendingNukeTypes(cx);
75987:         return;
75987:     }
75615: 
75615:     /* Add bindings for the arguments of the call. */
75708:     for (unsigned i = 0; i < callsite->argumentCount && i < nargs; i++) {
75615:         TypeSet *argTypes = callsite->argumentTypes[i];
77391:         TypeSet *types = TypeScript::ArgTypes(callee, i);
76087:         argTypes->addSubsetBarrier(cx, script, pc, types);
75615:     }
75615: 
75615:     /* Add void type for any formals in the callee not supplied at the call site. */
75708:     for (unsigned i = callsite->argumentCount; i < nargs; i++) {
77391:         TypeSet *types = TypeScript::ArgTypes(callee, i);
77353:         types->addType(cx, Type::UndefinedType());
75615:     }
75615: 
75615:     if (callsite->isNew) {
75615:         /*
77361:          * If the script does not return a value then the pushed value is the
77361:          * new object (typical case). Note that we don't model construction of
77361:          * the new value, which is done dynamically; we don't keep track of the
77361:          * possible 'new' types for a given prototype type object.
75615:          */
77391:         TypeScript::ThisTypes(callee)->addSubset(cx, callsite->returnTypes);
77391:         TypeScript::ReturnTypes(callee)->addFilterPrimitives(cx, callsite->returnTypes, false);
75615:     } else {
76103:         /*
76103:          * Add a binding for the return value of the call. We don't add a
76103:          * binding for the receiver object, as this is done with PropagateThis
76103:          * constraints added by the original JSOP_CALL* op. The type sets we
76103:          * manipulate here have lost any correlations between particular types
76103:          * in the 'this' and 'callee' sets, which we want to maintain for
76103:          * polymorphic JSOP_CALLPROP invocations.
76103:          */
77391:         TypeScript::ReturnTypes(callee)->addSubset(cx, callsite->returnTypes);
75615:     }
75615: }
75615: 
75615: void
77353: TypeConstraintPropagateThis::newType(JSContext *cx, TypeSet *source, Type type)
77353: {
77353:     if (type.isUnknown() || type.isAnyObject()) {
76103:         /*
76136:          * The callee is unknown, make sure the call is monitored so we pick up
76136:          * possible this/callee correlations. This only comes into play for
76136:          * CALLPROP and CALLELEM, for other calls we are past the type barrier
76136:          * already and a TypeConstraintCall will also monitor the call.
76103:          */
76136:         cx->compartment->types.monitorBytecode(cx, script, callpc - script->code);
76103:         return;
76136:     }
76136: 
77353:     /* Ignore calls to natives, these will be handled by TypeConstraintCall. */
77353:     JSScript *callee = NULL;
77353: 
77353:     if (type.isSingleObject()) {
77353:         JSObject *object = type.singleObject();
77353:         if (!object->isFunction() || !object->getFunctionPrivate()->isInterpreted())
77353:             return;
77353:         callee = object->getFunctionPrivate()->script();
77353:     } else if (type.isTypeObject()) {
77353:         TypeObject *object = type.typeObject();
77361:         if (!object->isFunction() || !object->functionScript)
77353:             return;
77353:         callee = object->functionScript;
77353:     } else {
76136:         /* Ignore calls to primitives, these will go through a stub. */
76136:         return;
77353:     }
76103: 
77391:     if (!callee->ensureHasTypes(cx))
76103:         return;
76103: 
77391:     TypeScript::ThisTypes(callee)->addType(cx, this->type);
76103: }
76103: 
76103: void
77353: TypeConstraintArith::newType(JSContext *cx, TypeSet *source, Type type)
75615: {
75820:     /*
75820:      * We only model a subset of the arithmetic behavior that is actually
75820:      * possible. The following need to be watched for at runtime:
75820:      *
75820:      * 1. Operations producing a double where no operand was a double.
75820:      * 2. Operations producing a string where no operand was a string (addition only).
75820:      * 3. Operations producing a value other than int/double/string.
75820:      */
75615:     if (other) {
75615:         /*
75615:          * Addition operation, consider these cases:
75633:          *   {int,bool} x {int,bool} -> int
75820:          *   double x {int,bool,double} -> double
75615:          *   string x any -> string
75615:          */
77353:         if (type.isUnknown() || other->unknown()) {
77353:             target->addType(cx, Type::UnknownType());
77353:         } else if (type.isPrimitive(JSVAL_TYPE_DOUBLE)) {
75919:             if (other->hasAnyFlag(TYPE_FLAG_UNDEFINED | TYPE_FLAG_NULL |
77353:                                   TYPE_FLAG_INT32 | TYPE_FLAG_DOUBLE | TYPE_FLAG_BOOLEAN |
77353:                                   TYPE_FLAG_ANYOBJECT) ||
75919:                 other->getObjectCount() != 0) {
77353:                 target->addType(cx, Type::DoubleType());
77353:             }
77353:         } else if (type.isPrimitive(JSVAL_TYPE_STRING)) {
77353:             target->addType(cx, Type::StringType());
77353:         } else {
75919:             if (other->hasAnyFlag(TYPE_FLAG_UNDEFINED | TYPE_FLAG_NULL |
77353:                                   TYPE_FLAG_INT32 | TYPE_FLAG_BOOLEAN |
77353:                                   TYPE_FLAG_ANYOBJECT) ||
75919:                 other->getObjectCount() != 0) {
77353:                 target->addType(cx, Type::Int32Type());
75820:             }
75919:             if (other->hasAnyFlag(TYPE_FLAG_DOUBLE))
77353:                 target->addType(cx, Type::DoubleType());
75615:         }
75615:     } else {
77353:         if (type.isUnknown())
77353:             target->addType(cx, Type::UnknownType());
77353:         else if (type.isPrimitive(JSVAL_TYPE_DOUBLE))
77353:             target->addType(cx, Type::DoubleType());
77353:         else
77353:             target->addType(cx, Type::Int32Type());
75615:     }
75615: }
75615: 
75615: void
77353: TypeConstraintTransformThis::newType(JSContext *cx, TypeSet *source, Type type)
77353: {
77353:     if (type.isUnknown() || type.isAnyObject() || type.isObject() || script->strictModeCode) {
75615:         target->addType(cx, type);
75615:         return;
75615:     }
75615: 
76029:     /*
76029:      * Note: if |this| is null or undefined, the pushed value is the outer window. We
76029:      * can't use script->getGlobalType() here because it refers to the inner window.
76029:      */
77353:     if (!script->hasGlobal() ||
77353:         type.isPrimitive(JSVAL_TYPE_NULL) ||
77353:         type.isPrimitive(JSVAL_TYPE_UNDEFINED)) {
77353:         target->addType(cx, Type::UnknownType());
75688:         return;
75688:     }
75688: 
75615:     TypeObject *object = NULL;
77353:     switch (type.primitive()) {
77353:       case JSVAL_TYPE_INT32:
77353:       case JSVAL_TYPE_DOUBLE:
77391:         object = TypeScript::StandardType(cx, script, JSProto_Number);
75615:         break;
77353:       case JSVAL_TYPE_BOOLEAN:
77391:         object = TypeScript::StandardType(cx, script, JSProto_Boolean);
75615:         break;
77353:       case JSVAL_TYPE_STRING:
77391:         object = TypeScript::StandardType(cx, script, JSProto_String);
75615:         break;
75615:       default:
76130:         return;
75615:     }
75615: 
75720:     if (!object) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75720: 
77353:     target->addType(cx, Type::ObjectType(object));
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // Freeze constraints
75615: /////////////////////////////////////////////////////////////////////
75615: 
75775: /* Constraint which triggers recompilation of a script if any type is added to a type set. */
75794: class TypeConstraintFreeze : public TypeConstraint
75775: {
75775: public:
77353:     JSScript *script;
77353: 
75794:     /* Whether a new type has already been added, triggering recompilation. */
75775:     bool typeAdded;
75775: 
75794:     TypeConstraintFreeze(JSScript *script)
77353:         : TypeConstraint("freeze"), script(script), typeAdded(false)
75775:     {}
75775: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type)
75775:     {
75775:         if (typeAdded)
75775:             return;
75775: 
75775:         typeAdded = true;
75775:         cx->compartment->types.addPendingRecompile(cx, script);
75775:     }
75775: };
75775: 
75794: void
75893: TypeSet::addFreeze(JSContext *cx)
75870: {
75987:     add(cx, ArenaNew<TypeConstraintFreeze>(cx->compartment->pool,
75893:                                            cx->compartment->types.compiledScript), false);
75870: }
75870: 
75615: /*
75623:  * Constraint which triggers recompilation of a script if a possible new JSValueType
75623:  * tag is realized for a type set.
75615:  */
75623: class TypeConstraintFreezeTypeTag : public TypeConstraint
75615: {
75615: public:
77353:     JSScript *script;
77353: 
75623:     /*
75623:      * Whether the type tag has been marked unknown due to a type change which
75623:      * occurred after this constraint was generated (and which triggered recompilation).
75623:      */
75623:     bool typeUnknown;
75623: 
75636:     TypeConstraintFreezeTypeTag(JSScript *script)
77353:         : TypeConstraint("freezeTypeTag"), script(script), typeUnknown(false)
75615:     {}
75615: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type)
75615:     {
75623:         if (typeUnknown)
75623:             return;
75623: 
77353:         if (!type.isUnknown() && !type.isAnyObject() && type.isObject()) {
75623:             /* Ignore new objects when the type set already has other objects. */
75919:             if (source->getObjectCount() >= 2)
75615:                 return;
75615:         }
75615: 
75623:         typeUnknown = true;
75636:         cx->compartment->types.addPendingRecompile(cx, script);
75615:     }
75615: };
75615: 
75625: static inline JSValueType
75625: GetValueTypeFromTypeFlags(TypeFlags flags)
75625: {
75625:     switch (flags) {
75625:       case TYPE_FLAG_UNDEFINED:
75625:         return JSVAL_TYPE_UNDEFINED;
75625:       case TYPE_FLAG_NULL:
75625:         return JSVAL_TYPE_NULL;
75625:       case TYPE_FLAG_BOOLEAN:
75625:         return JSVAL_TYPE_BOOLEAN;
75625:       case TYPE_FLAG_INT32:
75625:         return JSVAL_TYPE_INT32;
75630:       case (TYPE_FLAG_INT32 | TYPE_FLAG_DOUBLE):
75630:         return JSVAL_TYPE_DOUBLE;
75625:       case TYPE_FLAG_STRING:
75625:         return JSVAL_TYPE_STRING;
76128:       case TYPE_FLAG_LAZYARGS:
76128:         return JSVAL_TYPE_MAGIC;
75625:       default:
75625:         return JSVAL_TYPE_UNKNOWN;
75625:     }
75625: }
75625: 
75625: JSValueType
75893: TypeSet::getKnownTypeTag(JSContext *cx)
75615: {
75944:     TypeFlags flags = baseFlags();
75720:     JSValueType type;
75720: 
77361:     if (baseObjectCount())
75720:         type = flags ? JSVAL_TYPE_UNKNOWN : JSVAL_TYPE_OBJECT;
75720:     else
75720:         type = GetValueTypeFromTypeFlags(flags);
75636: 
76001:     /*
76001:      * If the type set is totally empty then it will be treated as unknown,
76001:      * but we still need to record the dependency as adding a new type can give
76001:      * it a definite type tag. This is not needed if there are enough types
76001:      * that the exact tag is unknown, as it will stay unknown as more types are
76001:      * added to the set.
76001:      */
77361:     bool empty = flags == 0 && baseObjectCount() == 0;
76001:     JS_ASSERT_IF(empty, type == JSVAL_TYPE_UNKNOWN);
76001: 
76001:     if (cx->compartment->types.compiledScript && (empty || type != JSVAL_TYPE_UNKNOWN)) {
75987:         add(cx, ArenaNew<TypeConstraintFreezeTypeTag>(cx->compartment->pool,
75893:                                                       cx->compartment->types.compiledScript), false);
75893:     }
75625: 
75625:     return type;
75625: }
75625: 
76044: /* Constraint which triggers recompilation if an object acquires particular flags. */
76044: class TypeConstraintFreezeObjectFlags : public TypeConstraint
75625: {
75625: public:
77353:     JSScript *script;
77353: 
76044:     /* Flags we are watching for on this object. */
76044:     TypeObjectFlags flags;
76044: 
76044:     /* Whether the object has already been marked as having one of the flags. */
76044:     bool *pmarked;
76044:     bool localMarked;
76044: 
76044:     TypeConstraintFreezeObjectFlags(JSScript *script, TypeObjectFlags flags, bool *pmarked)
77353:         : TypeConstraint("freezeObjectFlags"), script(script), flags(flags),
76044:           pmarked(pmarked), localMarked(false)
75833:     {}
75833: 
76044:     TypeConstraintFreezeObjectFlags(JSScript *script, TypeObjectFlags flags)
77353:         : TypeConstraint("freezeObjectFlags"), script(script), flags(flags),
76044:           pmarked(&localMarked), localMarked(false)
75919:     {}
75919: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type) {}
75833: 
76097:     void newObjectState(JSContext *cx, TypeObject *object, bool force)
75625:     {
76044:         if (object->hasAnyFlags(flags) && !*pmarked) {
76044:             *pmarked = true;
75636:             cx->compartment->types.addPendingRecompile(cx, script);
76097:         } else if (force) {
76097:             cx->compartment->types.addPendingRecompile(cx, script);
75625:         }
75833:     }
75625: };
75625: 
75625: /*
76044:  * Constraint which triggers recompilation if any object in a type set acquire
76044:  * particular flags.
75625:  */
76044: class TypeConstraintFreezeObjectFlagsSet : public TypeConstraint
75625: {
75625: public:
77353:     JSScript *script;
77353: 
76044:     TypeObjectFlags flags;
76044:     bool marked;
76044: 
76044:     TypeConstraintFreezeObjectFlagsSet(JSScript *script, TypeObjectFlags flags)
77353:         : TypeConstraint("freezeObjectKindSet"), script(script), flags(flags), marked(false)
76044:     {}
75625: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type)
75625:     {
76044:         if (marked) {
75625:             /* Despecialized the kind we were interested in due to recompilation. */
75625:             return;
75625:         }
75625: 
77353:         if (type.isUnknown() || type.isAnyObject()) {
76044:             /* Fallthrough and recompile. */
77353:         } else if (type.isObject()) {
77353:             TypeObject *object = type.isSingleObject()
77353:                 ? type.singleObject()->getType(cx)
77353:                 : type.typeObject();
76044:             if (!object->hasAnyFlags(flags)) {
75625:                 /*
77361:                  * Add a constraint on the the object to pick up changes in the
77361:                  * object's properties.
75625:                  */
77361:                 TypeSet *types = object->getProperty(cx, JSID_EMPTY, false);
77361:                 if (!types)
75720:                     return;
77361:                 types->add(cx,
76044:                     ArenaNew<TypeConstraintFreezeObjectFlags>(cx->compartment->pool,
76044:                                                               script, flags, &marked), false);
75625:                 return;
75625:             }
75833:         } else {
75833:             return;
75833:         }
75636: 
76044:         marked = true;
75636:         cx->compartment->types.addPendingRecompile(cx, script);
75625:     }
75625: };
75625: 
76044: bool
76044: TypeSet::hasObjectFlags(JSContext *cx, TypeObjectFlags flags)
75625: {
77353:     if (unknownObject())
76044:         return true;
76019: 
76053:     /*
76053:      * Treat type sets containing no objects as having all object flags,
76053:      * to spare callers from having to check this.
76053:      */
77361:     if (baseObjectCount() == 0)
76053:         return true;
76053: 
75919:     unsigned count = getObjectCount();
75919:     for (unsigned i = 0; i < count; i++) {
77353:         TypeObject *object = getTypeObject(i);
77353:         if (!object) {
77353:             JSObject *obj = getSingleObject(i);
77353:             if (obj)
77353:                 object = obj->getType(cx);
77353:         }
76044:         if (object && object->hasAnyFlags(flags))
76044:             return true;
76044:     }
76044: 
75625:     /*
75625:      * Watch for new objects of different kind, and re-traverse existing types
75625:      * in this set to add any needed FreezeArray constraints.
75625:      */
76044:     add(cx, ArenaNew<TypeConstraintFreezeObjectFlagsSet>(cx->compartment->pool,
76044:                                                          cx->compartment->types.compiledScript, flags));
76044: 
76044:     return false;
76044: }
76044: 
76044: bool
76044: TypeSet::HasObjectFlags(JSContext *cx, TypeObject *object, TypeObjectFlags flags)
75919: {
76044:     if (object->hasAnyFlags(flags))
76044:         return true;
76044: 
77361:     TypeSet *types = object->getProperty(cx, JSID_EMPTY, false);
77361:     if (!types)
76044:         return true;
77361:     types->add(cx,
76044:         ArenaNew<TypeConstraintFreezeObjectFlags>(cx->compartment->pool,
76044:                                                   cx->compartment->types.compiledScript, flags), false);
76044:     return false;
75919: }
75919: 
76128: void
77361: types::MarkArgumentsCreated(JSContext *cx, JSScript *script)
76128: {
77361:     JS_ASSERT(!script->createdArgs);
77361: 
77361:     script->createdArgs = true;
77361:     script->uninlineable = true;
77361: 
77391:     MarkTypeObjectFlags(cx, script->function(),
77361:                         OBJECT_FLAG_CREATED_ARGUMENTS | OBJECT_FLAG_UNINLINEABLE);
77361: 
77361:     if (!script->usedLazyArgs)
77361:         return;
77361: 
77361:     AutoEnterTypeInference enter(cx);
77361: 
76128: #ifdef JS_METHODJIT
77398:     mjit::ExpandInlineFrames(cx->compartment);
76128: #endif
76128: 
77391:     if (!script->ensureRanBytecode(cx))
76128:         return;
76128: 
77391:     ScriptAnalysis *analysis = script->analysis();
77391: 
76185:     for (FrameRegsIter iter(cx); !iter.done(); ++iter) {
76128:         StackFrame *fp = iter.fp();
76128:         if (fp->isScriptFrame() && fp->script() == script) {
76128:             /*
76128:              * Check locals and stack slots, assignment to individual arguments
76128:              * is treated as an escape on the arguments.
76128:              */
76160:             Value *sp = fp->base() + analysis->getCode(iter.pc()).stackDepth;
76128:             for (Value *vp = fp->slots(); vp < sp; vp++) {
76128:                 if (vp->isMagicCheck(JS_LAZY_ARGUMENTS)) {
76158:                     if (!js_GetArgsValue(cx, fp, vp))
76158:                         vp->setNull();
76128:                 }
76128:             }
76128:         }
76128:     }
76128: }
76128: 
75864: static inline void
76097: ObjectStateChange(JSContext *cx, TypeObject *object, bool markingUnknown, bool force)
75864: {
76097:     if (object->unknownProperties())
76097:         return;
76097: 
77361:     /* All constraints listening to state changes are on the empty id. */
77361:     TypeSet *types = object->maybeGetProperty(cx, JSID_EMPTY);
77361: 
77361:     /* Mark as unknown after getting the types, to avoid assertion. */
77361:     if (markingUnknown)
77361:         object->flags |= OBJECT_FLAG_DYNAMIC_MASK | OBJECT_FLAG_UNKNOWN_PROPERTIES;
77361: 
77361:     if (types) {
77361:         TypeConstraint *constraint = types->constraintList;
75864:         while (constraint) {
76097:             constraint->newObjectState(cx, object, force);
75864:             constraint = constraint->next;
75864:         }
75864:     }
77361: }
75864: 
75944: void
77414: TypeSet::WatchObjectStateChange(JSContext *cx, TypeObject *obj)
75944: {
77414:     JS_ASSERT(!obj->unknownProperties());
77414:     TypeSet *types = obj->getProperty(cx, JSID_EMPTY, false);
75944:     if (!types)
75944:         return;
75944: 
76097:     /*
77414:      * Use a constraint which triggers recompilation when markStateChange is
77414:      * called, which will set 'force' to true.
76097:      */
76097:     types->add(cx, ArenaNew<TypeConstraintFreezeObjectFlags>(cx->compartment->pool,
76097:                                                              cx->compartment->types.compiledScript,
76097:                                                              0));
75944: }
75944: 
75944: class TypeConstraintFreezeOwnProperty : public TypeConstraint
75944: {
75944: public:
77353:     JSScript *script;
77353: 
75944:     bool updated;
75944:     bool configurable;
75944: 
75944:     TypeConstraintFreezeOwnProperty(JSScript *script, bool configurable)
77353:         : TypeConstraint("freezeOwnProperty"),
77353:           script(script), updated(false), configurable(configurable)
75944:     {}
75944: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type) {}
75944: 
75944:     void newPropertyState(JSContext *cx, TypeSet *source)
75944:     {
75944:         if (updated)
75944:             return;
77361:         if (source->isOwnProperty(configurable)) {
75944:             updated = true;
75944:             cx->compartment->types.addPendingRecompile(cx, script);
75944:         }
75944:     }
75944: };
75944: 
77361: static void
77361: CheckNewScriptProperties(JSContext *cx, TypeObject *type, JSScript *script);
77361: 
75944: bool
77361: TypeSet::isOwnProperty(JSContext *cx, TypeObject *object, bool configurable)
75944: {
77361:     /*
77361:      * Everywhere compiled code depends on definite properties associated with
77361:      * a type object's newScript, we need to make sure there are constraints
77361:      * in place which will mark those properties as configured should the
77361:      * definite properties be invalidated.
77361:      */
77361:     if (object->flags & OBJECT_FLAG_NEW_SCRIPT_REGENERATE) {
77378:         if (object->newScript) {
77378:             CheckNewScriptProperties(cx, object, object->newScript->script);
77378:         } else {
77361:             JS_ASSERT(object->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED);
77361:             object->flags &= ~OBJECT_FLAG_NEW_SCRIPT_REGENERATE;
77361:         }
77361:     }
77361: 
77361:     if (isOwnProperty(configurable))
75944:         return true;
75944: 
75987:     add(cx, ArenaNew<TypeConstraintFreezeOwnProperty>(cx->compartment->pool,
75944:                                                       cx->compartment->types.compiledScript,
75944:                                                       configurable), false);
75944:     return false;
75944: }
75944: 
75625: bool
75893: TypeSet::knownNonEmpty(JSContext *cx)
75625: {
77361:     if (baseFlags() != 0 || baseObjectCount() != 0)
75625:         return true;
75677: 
75987:     add(cx, ArenaNew<TypeConstraintFreeze>(cx->compartment->pool,
75893:                                            cx->compartment->types.compiledScript), false);
75625: 
75625:     return false;
75615: }
75615: 
77347: int
77347: TypeSet::getTypedArrayType(JSContext *cx)
77347: {
77347:     int arrayType = TypedArray::TYPE_MAX;
77347:     unsigned count = getObjectCount();
77347: 
77347:     for (unsigned i = 0; i < count; i++) {
77353:         JSObject *proto = NULL;
77353:         if (JSObject *object = getSingleObject(i)) {
77353:             proto = object->getProto();
77353:         } else if (TypeObject *object = getTypeObject(i)) {
77353:             JS_ASSERT(!object->hasAnyFlags(OBJECT_FLAG_NON_TYPED_ARRAY));
77353:             proto = object->proto;
77353:         }
77353:         if (!proto)
77347:             continue;
77347: 
77353:         int objArrayType = proto->getClass() - TypedArray::slowClasses;
77347:         JS_ASSERT(objArrayType >= 0 && objArrayType < TypedArray::TYPE_MAX);
77347: 
77347:         /*
77347:          * Set arrayType to the type of the first array. Return if there is an array
77347:          * of another type.
77347:          */
77347:         if (arrayType == TypedArray::TYPE_MAX)
77347:             arrayType = objArrayType;
77347:         else if (arrayType != objArrayType)
77347:             return TypedArray::TYPE_MAX;
77347:     }
77347: 
77347:     /*
77347:      * Assume the caller checked that OBJECT_FLAG_NON_TYPED_ARRAY is not set.
77347:      * This means the set contains at least one object because sets with no
77347:      * objects have all object flags.
77347:      */
77347:     JS_ASSERT(arrayType != TypedArray::TYPE_MAX);
77347: 
77347:     /* Recompile when another typed array is added to this set. */
77347:     addFreeze(cx);
77347: 
77347:     return arrayType;
77347: }
77347: 
75845: JSObject *
77353: TypeSet::getSingleton(JSContext *cx, bool freeze)
75845: {
77361:     if (baseFlags() != 0 || baseObjectCount() != 1)
75845:         return NULL;
75845: 
77353:     JSObject *obj = getSingleObject(0);
77353:     if (!obj)
75845:         return NULL;
75845: 
77353:     if (freeze) {
75987:         add(cx, ArenaNew<TypeConstraintFreeze>(cx->compartment->pool,
75893:                                                cx->compartment->types.compiledScript), false);
77353:     }
77353: 
77353:     return obj;
75845: }
75845: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeCompartment
75615: /////////////////////////////////////////////////////////////////////
75615: 
77461: TypeObject types::emptyTypeObject(NULL, false, true);
77361: 
75720: void
75720: TypeCompartment::init(JSContext *cx)
75720: {
75720:     PodZero(this);
75720: 
76197: #ifndef JS_CPU_ARM
75720:     if (cx && cx->getRunOptions() & JSOPTION_TYPE_INFERENCE)
75720:         inferenceEnabled = true;
76197: #endif
75720: }
75720: 
75720: TypeObject *
76094: TypeCompartment::newTypeObject(JSContext *cx, JSScript *script,
77361:                                JSProtoKey key, JSObject *proto, bool unknown)
75720: {
77361:     TypeObject *object = NewGCThing<TypeObject>(cx, gc::FINALIZE_TYPE_OBJECT, sizeof(TypeObject));
75720:     if (!object)
75720:         return NULL;
77461:     new(object) TypeObject(proto, key == JSProto_Function, unknown);
75720: 
75839:     if (!cx->typeInferenceEnabled())
77361:         object->flags |= OBJECT_FLAG_UNKNOWN_MASK;
76179:     else
76179:         object->setFlagsFromKey(cx, key);
75919: 
75720:     return object;
75720: }
75720: 
75720: TypeObject *
77361: TypeCompartment::newAllocationSiteTypeObject(JSContext *cx, const AllocationSiteKey &key)
75720: {
77361:     AutoEnterTypeInference enter(cx);
77361: 
77361:     if (!allocationSiteTable) {
77361:         allocationSiteTable = cx->new_<AllocationSiteTable>();
77361:         if (!allocationSiteTable || !allocationSiteTable->init()) {
77361:             cx->compartment->types.setPendingNukeTypes(cx);
77361:             return NULL;
77361:         }
77361:     }
77361: 
77361:     AllocationSiteTable::AddPtr p = allocationSiteTable->lookupForAdd(key);
77361:     JS_ASSERT(!p);
77361: 
75720:     JSObject *proto;
77361:     if (!js_GetClassPrototype(cx, key.script->global(), key.kind, &proto, NULL))
75720:         return NULL;
75720: 
77461:     TypeObject *res = newTypeObject(cx, key.script, key.kind, proto);
77361:     if (!res) {
77361:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return NULL;
77361:     }
77361: 
77361:     jsbytecode *pc = key.script->code + key.offset;
77361:     UntrapOpcode untrap(cx, key.script, pc);
77361: 
77446:     if (JSOp(*pc) == JSOP_NEWOBJECT) {
75948:         /*
75948:          * This object is always constructed the same way and will not be
75948:          * observed by other code before all properties have been added. Mark
75948:          * all the properties as definite properties of the object.
75948:          */
77361:         JSObject *baseobj = key.script->getObject(GET_SLOTNO(pc));
75948: 
76059:         if (!res->addDefiniteProperties(cx, baseobj))
75948:             return NULL;
75948:     }
75948: 
77361:     if (!allocationSiteTable->add(p, key, res)) {
77361:         cx->compartment->types.setPendingNukeTypes(cx);
77361:         return NULL;
77361:     }
77361: 
75720:     return res;
75720: }
75720: 
75708: static inline jsid
75708: GetAtomId(JSContext *cx, JSScript *script, const jsbytecode *pc, unsigned offset)
75708: {
75708:     unsigned index = js_GetIndexFromBytecode(cx, script, (jsbytecode*) pc, offset);
75708:     return MakeTypeId(cx, ATOM_TO_JSID(script->getAtom(index)));
75708: }
75708: 
75708: static inline jsid
75708: GetGlobalId(JSContext *cx, JSScript *script, const jsbytecode *pc)
75708: {
75708:     unsigned index = GET_SLOTNO(pc);
75708:     return MakeTypeId(cx, ATOM_TO_JSID(script->getGlobalAtom(index)));
75708: }
75708: 
75708: static inline JSObject *
75708: GetScriptObject(JSContext *cx, JSScript *script, const jsbytecode *pc, unsigned offset)
75708: {
75708:     unsigned index = js_GetIndexFromBytecode(cx, script, (jsbytecode*) pc, offset);
75708:     return script->getObject(index);
75708: }
75708: 
75708: static inline const Value &
75708: GetScriptConst(JSContext *cx, JSScript *script, const jsbytecode *pc)
75708: {
75708:     unsigned index = js_GetIndexFromBytecode(cx, script, (jsbytecode*) pc, 0);
75708:     return script->getConst(index);
75708: }
75708: 
75788: bool
75987: types::UseNewType(JSContext *cx, JSScript *script, jsbytecode *pc)
75788: {
75788:     JS_ASSERT(cx->typeInferenceEnabled());
75788: 
76095:     UntrapOpcode untrap(cx, script, pc);
76095: 
75788:     /*
75788:      * Make a heuristic guess at a use of JSOP_NEW that the constructed object
75788:      * should have a fresh type object. We do this when the NEW is immediately
75788:      * followed by a simple assignment to an object's .prototype field.
75788:      * This is designed to catch common patterns for subclassing in JS:
75788:      *
75788:      * function Super() { ... }
75788:      * function Sub1() { ... }
75788:      * function Sub2() { ... }
75788:      *
75788:      * Sub1.prototype = new Super();
75788:      * Sub2.prototype = new Super();
75788:      *
75788:      * Using distinct type objects for the particular prototypes of Sub1 and
75788:      * Sub2 lets us continue to distinguish the two subclasses and any extra
75788:      * properties added to those prototype objects.
75788:      */
75788:     if (JSOp(*pc) != JSOP_NEW)
75788:         return false;
75788:     pc += JSOP_NEW_LENGTH;
75788:     if (JSOp(*pc) == JSOP_SETPROP) {
75788:         jsid id = GetAtomId(cx, script, pc, 0);
75788:         if (id == id_prototype(cx))
75788:             return true;
75788:     }
75788: 
75788:     return false;
75788: }
75788: 
75615: void
75718: TypeCompartment::growPendingArray(JSContext *cx)
75615: {
75720:     unsigned newCapacity = js::Max(unsigned(100), pendingCapacity * 2);
77439:     PendingWork *newArray = (PendingWork *) OffTheBooks::calloc_(newCapacity * sizeof(PendingWork));
75720:     if (!newArray) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75720: 
75720:     memcpy(newArray, pendingArray, pendingCount * sizeof(PendingWork));
75901:     cx->free_(pendingArray);
75720: 
75720:     pendingArray = newArray;
75720:     pendingCapacity = newCapacity;
75720: }
75720: 
76020: void
75636: TypeCompartment::processPendingRecompiles(JSContext *cx)
75636: {
75720:     /* Steal the list of scripts to recompile, else we will try to recursively recompile them. */
75720:     Vector<JSScript*> *pending = pendingRecompiles;
75720:     pendingRecompiles = NULL;
75720: 
75864:     JS_ASSERT(!pending->empty());
75864: 
75864: #ifdef JS_METHODJIT
75864: 
77398:     mjit::ExpandInlineFrames(cx->compartment);
75864: 
75720:     for (unsigned i = 0; i < pending->length(); i++) {
75720:         JSScript *script = (*pending)[i];
75720:         mjit::Recompiler recompiler(cx, script);
76020:         if (script->hasJITCode())
76020:             recompiler.recompile();
76020:     }
76020: 
76020: #endif /* JS_METHODJIT */
76020: 
75901:     cx->delete_(pending);
75720: }
75720: 
75720: void
75720: TypeCompartment::setPendingNukeTypes(JSContext *cx)
75720: {
77439:     JS_ASSERT(compartment()->activeInference);
75720:     if (!pendingNukeTypes) {
77439:         if (cx->compartment)
75720:             js_ReportOutOfMemory(cx);
75720:         pendingNukeTypes = true;
75720:     }
75720: }
75720: 
76020: void
75720: TypeCompartment::nukeTypes(JSContext *cx)
75720: {
77530:     JS_ASSERT(this == &cx->compartment->types);
76092: 
75636:     /*
75720:      * This is the usual response if we encounter an OOM while adding a type
76092:      * or resolving type constraints. Reset the compartment to not use type
76092:      * inference, and recompile all scripts.
75720:      *
75720:      * Because of the nature of constraint-based analysis (add constraints, and
75720:      * iterate them until reaching a fixpoint), we can't undo an add of a type set,
75720:      * and merely aborting the operation which triggered the add will not be
75720:      * sufficient for correct behavior as we will be leaving the types in an
75720:      * inconsistent state.
75636:      */
75720:     JS_ASSERT(pendingNukeTypes);
75720:     if (pendingRecompiles) {
75901:         cx->free_(pendingRecompiles);
75636:         pendingRecompiles = NULL;
75636:     }
75636: 
76092:     /*
76092:      * We may or may not be under the GC. In either case don't allocate, and
76092:      * acquire the GC lock so we can update inferenceEnabled for all contexts.
76092:      */
76092: 
76092: #ifdef JS_THREADSAFE
76092:     Maybe<AutoLockGC> maybeLock;
76092:     if (!cx->runtime->gcMarkAndSweep)
76093:         maybeLock.construct(cx->runtime);
76092: #endif
76092: 
76092:     inferenceEnabled = false;
76092: 
76092:     /* Update the cached inferenceEnabled bit in all contexts. */
76092:     for (JSCList *cl = cx->runtime->contextList.next;
76092:          cl != &cx->runtime->contextList;
76092:          cl = cl->next) {
77463:         JSContext *cx = JSContext::fromLinkField(cl);
76092:         cx->setCompartment(cx->compartment);
76092:     }
76092: 
76092: #ifdef JS_METHODJIT
76092: 
77530:     JSCompartment *compartment = cx->compartment;
77530:     mjit::ExpandInlineFrames(compartment);
76092: 
76092:     /* Throw away all JIT code in the compartment, but leave everything else alone. */
76092:     for (JSCList *cursor = compartment->scripts.next;
76092:          cursor != &compartment->scripts;
76092:          cursor = cursor->next) {
76092:         JSScript *script = reinterpret_cast<JSScript *>(cursor);
76092:         if (script->hasJITCode()) {
76092:             mjit::Recompiler recompiler(cx, script);
76092:             recompiler.recompile();
76092:         }
76092:     }
76092: 
76092: #endif /* JS_METHODJIT */
76092: 
75720: }
75720: 
75636: void
75636: TypeCompartment::addPendingRecompile(JSContext *cx, JSScript *script)
75636: {
76193: #ifdef JS_METHODJIT
75636:     if (!script->jitNormal && !script->jitCtor) {
75636:         /* Scripts which haven't been compiled yet don't need to be recompiled. */
75636:         return;
75636:     }
75636: 
75730:     if (!pendingRecompiles) {
75901:         pendingRecompiles = cx->new_< Vector<JSScript*> >(cx);
75730:         if (!pendingRecompiles) {
75730:             cx->compartment->types.setPendingNukeTypes(cx);
75730:             return;
75730:         }
75730:     }
75636: 
75636:     for (unsigned i = 0; i < pendingRecompiles->length(); i++) {
75636:         if (script == (*pendingRecompiles)[i])
75636:             return;
75636:     }
75636: 
75720:     if (!pendingRecompiles->append(script)) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
76193: #endif
75720: }
75720: 
76136: void
76175: TypeCompartment::monitorBytecode(JSContext *cx, JSScript *script, uint32 offset,
76175:                                  bool returnOnly)
76136: {
77391:     ScriptAnalysis *analysis = script->analysis();
76175:     JS_ASSERT(analysis->ranInference());
76136: 
76136:     jsbytecode *pc = script->code + offset;
76136:     UntrapOpcode untrap(cx, script, pc);
76136: 
76175:     JS_ASSERT_IF(returnOnly, js_CodeSpec[*pc].format & JOF_INVOKE);
76175: 
76175:     Bytecode &code = analysis->getCode(pc);
76175: 
76175:     if (returnOnly ? code.monitoredTypesReturn : code.monitoredTypes)
76175:         return;
76175: 
76176:     InferSpew(ISpewOps, "addMonitorNeeded:%s #%u:%05u",
76176:               returnOnly ? " returnOnly" : "", script->id(), offset);
76175: 
76175:     /* Dynamically monitor this call to keep track of its result types. */
76175:     if (js_CodeSpec[*pc].format & JOF_INVOKE)
76175:         code.monitoredTypesReturn = true;
76175: 
76175:     if (!returnOnly)
76175:         code.monitoredTypes = true;
75708: 
75636:     cx->compartment->types.addPendingRecompile(cx, script);
76097: 
76097:     /* Trigger recompilation of any inline callers. */
77391:     if (script->hasFunction && !script->function()->hasLazyType())
77391:         ObjectStateChange(cx, script->function()->type(), false, true);
77353: }
77353: 
77361: /*
77361:  * State for keeping track of which property type sets contain an object we are
77361:  * scrubbing from all properties in the compartment. We make a list of
77361:  * properties to update and fix them afterwards, as adding types can't be done
77361:  * with the GC locked (as is done in IterateCells), and can potentially make
77361:  * new type objects as well.
77361:  */
77361: struct MarkSetsUnknownState
77361: {
77361:     TypeObject *target;
77361:     Vector<TypeSet *> pending;
77361: 
77361:     MarkSetsUnknownState(JSContext *cx, TypeObject *target)
77361:         : target(target), pending(cx)
77361:     {}
77361: };
77361: 
77353: static void
77361: MarkObjectSetsUnknownCallback(JSContext *cx, void *data, void *thing,
77361:                               size_t traceKind, size_t thingSize)
77353: {
77361:     MarkSetsUnknownState *state = (MarkSetsUnknownState *) data;
77361:     TypeObject *object = (TypeObject *) thing;
77361: 
77361:     unsigned count = object->getPropertyCount();
77353:     for (unsigned i = 0; i < count; i++) {
77361:         Property *prop = object->getProperty(i);
77361:         if (prop && prop->types.hasType(Type::ObjectType(state->target))) {
77361:             if (!state->pending.append(&prop->types))
77361:                 cx->compartment->types.setPendingNukeTypes(cx);
77361:         }
77353:     }
76097: }
76097: 
76097: void
77353: TypeCompartment::markSetsUnknown(JSContext *cx, TypeObject *target)
77353: {
77353:     JS_ASSERT(this == &cx->compartment->types);
77361:     JS_ASSERT(!(target->flags & OBJECT_FLAG_SETS_MARKED_UNKNOWN));
77353:     JS_ASSERT(!target->singleton);
77353:     JS_ASSERT(target->unknownProperties());
77361:     target->flags |= OBJECT_FLAG_SETS_MARKED_UNKNOWN;
77353: 
77353:     AutoEnterTypeInference enter(cx);
77353: 
77353:     /*
77353:      * Mark both persistent and transient type sets which contain obj as having
77353:      * a generic object type. It is not sufficient to mark just the persistent
77353:      * sets, as analysis of individual opcodes can pull type objects from
77353:      * static information (like initializer objects at various offsets).
77353:      */
77353: 
77361:     MarkSetsUnknownState state(cx, target);
77361: 
77361:     IterateCells(cx, cx->compartment, gc::FINALIZE_TYPE_OBJECT,
77361:                  (void *) &state, MarkObjectSetsUnknownCallback);
77361: 
77361:     for (unsigned i = 0; i < state.pending.length(); i++)
77361:         state.pending[i]->addType(cx, Type::AnyObjectType());
77353: 
77353:     for (JSCList *cursor = cx->compartment->scripts.next;
77353:          cursor != &cx->compartment->scripts;
77353:          cursor = cursor->next) {
77353:         JSScript *script = reinterpret_cast<JSScript *>(cursor);
77391:         if (script->types) {
77391:             unsigned count = TypeScript::NumTypeSets(script);
77391:             TypeSet *typeArray = script->types->typeArray();
77353:             for (unsigned i = 0; i < count; i++) {
77391:                 if (typeArray[i].hasType(Type::ObjectType(target)))
77391:                     typeArray[i].addType(cx, Type::AnyObjectType());
77391:             }
77391:         }
77391:         if (script->hasAnalysis() && script->analysis()->ranInference()) {
77353:             for (unsigned i = 0; i < script->length; i++) {
77391:                 if (!script->analysis()->maybeCode(i))
77353:                     continue;
77353:                 jsbytecode *pc = script->code + i;
77353:                 UntrapOpcode untrap(cx, script, pc);
77357:                 if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
77357:                     continue;
77353:                 unsigned defCount = GetDefCount(script, i);
77353:                 if (ExtendedDef(pc))
77353:                     defCount++;
77353:                 for (unsigned j = 0; j < defCount; j++) {
77391:                     TypeSet *types = script->analysis()->pushedTypes(pc, j);
77353:                     if (types->hasType(Type::ObjectType(target)))
77353:                         types->addType(cx, Type::AnyObjectType());
77353:                 }
77353:             }
77353:         }
77353:     }
77353: }
77353: 
77353: void
77353: ScriptAnalysis::addTypeBarrier(JSContext *cx, const jsbytecode *pc, TypeSet *target, Type type)
76097: {
76097:     Bytecode &code = getCode(pc);
76097: 
77353:     if (!type.isUnknown() && !type.isAnyObject() &&
77353:         type.isObject() && target->getObjectCount() >= BARRIER_OBJECT_LIMIT) {
76097:         /* Ignore this barrier, just add the type to the target. */
76097:         target->addType(cx, type);
76097:         return;
76097:     }
76097: 
76097:     if (!code.typeBarriers) {
76097:         /*
76097:          * Adding type barriers at a bytecode which did not have them before
76097:          * will trigger recompilation. If there were already type barriers,
76097:          * however, do not trigger recompilation (the script will be recompiled
76097:          * if any of the barriers is ever violated).
76097:          */
76097:         cx->compartment->types.addPendingRecompile(cx, script);
76097: 
76097:         /* Trigger recompilation of any inline callers. */
77391:         if (script->hasFunction && !script->function()->hasLazyType())
77391:             ObjectStateChange(cx, script->function()->type(), false, true);
76097:     }
76097: 
76176:     /* Ignore duplicate barriers. */
76176:     TypeBarrier *barrier = code.typeBarriers;
76176:     while (barrier) {
77467:         if (barrier->target == target && barrier->type == type && !barrier->singleton)
76176:             return;
76176:         barrier = barrier->next;
76176:     }
76176: 
76182:     InferSpew(ISpewOps, "typeBarrier: #%u:%05u: %sT%p%s %s",
76182:               script->id(), pc - script->code,
76182:               InferSpewColor(target), target, InferSpewColorReset(),
76182:               TypeString(type));
76097: 
77460:     barrier = ArenaNew<TypeBarrier>(cx->compartment->pool, target, type,
77460:                                     (JSObject *) NULL, JSID_VOID);
77460: 
77460:     barrier->next = code.typeBarriers;
77460:     code.typeBarriers = barrier;
77460: }
77460: 
77460: void
77460: ScriptAnalysis::addSingletonTypeBarrier(JSContext *cx, const jsbytecode *pc, TypeSet *target, JSObject *singleton, jsid singletonId)
77460: {
77460:     JS_ASSERT(singletonId == MakeTypeId(cx, singletonId) && !JSID_IS_VOID(singletonId));
77460: 
77460:     Bytecode &code = getCode(pc);
77460: 
77460:     if (!code.typeBarriers) {
77460:         /* Trigger recompilation as for normal type barriers. */
77460:         cx->compartment->types.addPendingRecompile(cx, script);
77460:         if (script->hasFunction && !script->function()->hasLazyType())
77460:             ObjectStateChange(cx, script->function()->type(), false, true);
77460:     }
77460: 
77460:     InferSpew(ISpewOps, "singletonTypeBarrier: #%u:%05u: %sT%p%s %p %s",
77460:               script->id(), pc - script->code,
77460:               InferSpewColor(target), target, InferSpewColorReset(),
77460:               (void *) singleton, TypeIdString(singletonId));
77460: 
77460:     TypeBarrier *barrier =
77460:         ArenaNew<TypeBarrier>(cx->compartment->pool, target, Type::UndefinedType(),
77460:                               singleton, singletonId);
76097: 
76097:     barrier->next = code.typeBarriers;
76097:     code.typeBarriers = barrier;
75633: }
75633: 
77362: #ifdef DEBUG
77361: static void
77361: PrintObjectCallback(JSContext *cx, void *data, void *thing,
77361:                     size_t traceKind, size_t thingSize)
77361: {
77361:     TypeObject *object = (TypeObject *) thing;
77361:     object->print(cx);
77361: }
77362: #endif
77361: 
75633: void
77440: TypeCompartment::print(JSContext *cx, bool force)
75615: {
77361:     JSCompartment *compartment = this->compartment();
75615: 
77440:     if (JS_CLIST_IS_EMPTY(&compartment->scripts))
77440:         return;
77440: 
77440:     if (!force && !InferSpewActive(ISpewResult))
75638:         return;
75638: 
75615:     for (JSScript *script = (JSScript *)compartment->scripts.next;
75615:          &script->links != &compartment->scripts;
75615:          script = (JSScript *)script->links.next) {
77391:         if (script->hasAnalysis() && script->analysis()->ranInference())
77391:             script->analysis()->printTypes(cx);
75640:     }
75640: 
75640: #ifdef DEBUG
77362:     {
77362:         AutoUnlockGC unlock(cx->runtime);
77361:         IterateCells(cx, compartment, gc::FINALIZE_TYPE_OBJECT, NULL, PrintObjectCallback);
77362:     }
75640: #endif
75615: 
75638:     printf("Counts: ");
75615:     for (unsigned count = 0; count < TYPE_COUNT_LIMIT; count++) {
75615:         if (count)
75638:             printf("/");
75638:         printf("%u", typeCounts[count]);
75615:     }
75638:     printf(" (%u over)\n", typeCountOver);
75638: 
75640:     printf("Recompilations: %u\n", recompilations);
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75770: // TypeCompartment tables
75770: /////////////////////////////////////////////////////////////////////
75770: 
75770: /*
75770:  * The arrayTypeTable and objectTypeTable are per-compartment tables for making
75770:  * common type objects to model the contents of large script singletons and
75770:  * JSON objects. These are vanilla Arrays and native Objects, so we distinguish
75770:  * the types of different ones by looking at the types of their properties.
75770:  *
75770:  * All singleton/JSON arrays which have the same prototype, are homogenous and
75926:  * of the same element type will share a type object. All singleton/JSON
75926:  * objects which have the same shape and property types will also share a type
75926:  * object. We don't try to collate arrays or objects that have type mismatches.
75770:  */
75770: 
75770: static inline bool
77353: NumberTypes(Type a, Type b)
77353: {
77353:     return (a.isPrimitive(JSVAL_TYPE_INT32) || a.isPrimitive(JSVAL_TYPE_DOUBLE))
77353:         && (b.isPrimitive(JSVAL_TYPE_INT32) || b.isPrimitive(JSVAL_TYPE_DOUBLE));
75770: }
75770: 
77448: /*
77448:  * As for GetValueType, but requires object types to be non-singletons with
77448:  * their default prototype. These are the only values that should appear in
77448:  * arrays and objects whose type can be fixed.
77448:  */
77448: static inline Type
77448: GetValueTypeForTable(JSContext *cx, const Value &v)
77448: {
77448:     Type type = GetValueType(cx, v);
77448:     JS_ASSERT(!type.isSingleObject());
77448:     JS_ASSERT_IF(type.isTypeObject(), type.typeObject() != &emptyTypeObject);
77448:     return type;
77448: }
77448: 
75987: struct types::ArrayTableKey
75770: {
77353:     Type type;
75770:     JSObject *proto;
75770: 
77353:     ArrayTableKey()
77353:         : type(Type::UndefinedType()), proto(NULL)
77353:     {}
77353: 
75770:     typedef ArrayTableKey Lookup;
75770: 
75770:     static inline uint32 hash(const ArrayTableKey &v) {
77353:         return (uint32) (v.type.raw() ^ ((uint32)(size_t)v.proto >> 2));
75770:     }
75770: 
75770:     static inline bool match(const ArrayTableKey &v1, const ArrayTableKey &v2) {
75770:         return v1.type == v2.type && v1.proto == v2.proto;
75770:     }
75770: };
75770: 
76020: void
75770: TypeCompartment::fixArrayType(JSContext *cx, JSObject *obj)
75770: {
76020:     AutoEnterTypeInference enter(cx);
76020: 
75770:     if (!arrayTypeTable) {
75901:         arrayTypeTable = cx->new_<ArrayTypeTable>();
75770:         if (!arrayTypeTable || !arrayTypeTable->init()) {
75770:             arrayTypeTable = NULL;
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
75770:         }
75770:     }
75770: 
75770:     /*
75770:      * If the array is of homogenous type, pick a type object which will be
75770:      * shared with all other singleton/JSON arrays of the same type.
75770:      * If the array is heterogenous, keep the existing type object, which has
75770:      * unknown properties.
75770:      */
75770:     JS_ASSERT(obj->isPackedDenseArray());
75770: 
75770:     unsigned len = obj->getDenseArrayInitializedLength();
75770:     if (len == 0)
76020:         return;
75770: 
77448:     Type type = GetValueTypeForTable(cx, obj->getDenseArrayElement(0));
75770: 
75770:     for (unsigned i = 1; i < len; i++) {
77448:         Type ntype = GetValueTypeForTable(cx, obj->getDenseArrayElement(i));
75770:         if (ntype != type) {
75770:             if (NumberTypes(type, ntype))
77353:                 type = Type::DoubleType();
75770:             else
76020:                 return;
75770:         }
75770:     }
75770: 
75770:     ArrayTableKey key;
75770:     key.type = type;
75770:     key.proto = obj->getProto();
75770:     ArrayTypeTable::AddPtr p = arrayTypeTable->lookupForAdd(key);
75770: 
75770:     if (p) {
75770:         obj->setType(p->value);
75770:     } else {
77461:         /* Make a new type to use for future arrays with the same elements. */
77461:         TypeObject *objType = newTypeObject(cx, NULL, JSProto_Array, obj->getProto());
75770:         if (!objType) {
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
75770:         }
75770:         obj->setType(objType);
75770: 
77353:         if (!objType->unknownProperties())
77353:             objType->addPropertyType(cx, JSID_VOID, type);
75770: 
75770:         if (!arrayTypeTable->relookupOrAdd(p, key, objType)) {
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
76020:         }
76020:     }
75770: }
75770: 
75770: /*
75770:  * N.B. We could also use the initial shape of the object (before its type is
75770:  * fixed) as the key in the object table, but since all references in the table
75770:  * are weak the hash entries would usually be collected on GC even if objects
75770:  * with the new type/shape are still live.
75770:  */
75987: struct types::ObjectTableKey
75770: {
75770:     jsid *ids;
75770:     uint32 nslots;
75948:     uint32 nfixed;
75770:     JSObject *proto;
75770: 
75770:     typedef JSObject * Lookup;
75770: 
75770:     static inline uint32 hash(JSObject *obj) {
76022:         return (uint32) (JSID_BITS(obj->lastProperty()->propid) ^
75948:                          obj->slotSpan() ^ obj->numFixedSlots() ^
75771:                          ((uint32)(size_t)obj->getProto() >> 2));
75770:     }
75770: 
75770:     static inline bool match(const ObjectTableKey &v, JSObject *obj) {
75948:         if (obj->slotSpan() != v.nslots ||
75948:             obj->numFixedSlots() != v.nfixed ||
75948:             obj->getProto() != v.proto) {
75770:             return false;
75948:         }
75770:         const Shape *shape = obj->lastProperty();
76022:         while (!JSID_IS_EMPTY(shape->propid)) {
76022:             if (shape->propid != v.ids[shape->slot])
75770:                 return false;
75770:             shape = shape->previous();
75770:         }
75770:         return true;
75770:     }
75770: };
75770: 
75987: struct types::ObjectTableEntry
75770: {
75770:     TypeObject *object;
77353:     Type *types;
75770: };
75770: 
76020: void
75770: TypeCompartment::fixObjectType(JSContext *cx, JSObject *obj)
75770: {
76020:     AutoEnterTypeInference enter(cx);
76020: 
75770:     if (!objectTypeTable) {
75901:         objectTypeTable = cx->new_<ObjectTypeTable>();
75770:         if (!objectTypeTable || !objectTypeTable->init()) {
75770:             objectTypeTable = NULL;
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
75770:         }
75770:     }
75770: 
75770:     /*
75770:      * Use the same type object for all singleton/JSON arrays with the same
75770:      * base shape, i.e. the same fields written in the same order. If there
75770:      * is a type mismatch with previous objects of the same shape, use the
75770:      * generic unknown type.
75770:      */
75770:     JS_ASSERT(obj->isObject());
75770: 
75770:     if (obj->slotSpan() == 0 || obj->inDictionaryMode())
76020:         return;
75770: 
75770:     ObjectTypeTable::AddPtr p = objectTypeTable->lookupForAdd(obj);
75770:     const Shape *baseShape = obj->lastProperty();
75770: 
75770:     if (p) {
75770:         /* The lookup ensures the shape matches, now check that the types match. */
77353:         Type *types = p->value.types;
75770:         for (unsigned i = 0; i < obj->slotSpan(); i++) {
77448:             Type ntype = GetValueTypeForTable(cx, obj->getSlot(i));
75770:             if (ntype != types[i]) {
75770:                 if (NumberTypes(ntype, types[i])) {
77353:                     if (types[i].isPrimitive(JSVAL_TYPE_INT32)) {
77353:                         types[i] = Type::DoubleType();
75770:                         const Shape *shape = baseShape;
76022:                         while (!JSID_IS_EMPTY(shape->propid)) {
75770:                             if (shape->slot == i) {
77353:                                 Type type = Type::DoubleType();
77375:                                 if (!p->value.object->unknownProperties()) {
77375:                                     jsid id = MakeTypeId(cx, shape->propid);
77375:                                     p->value.object->addPropertyType(cx, id, type);
77375:                                 }
75770:                                 break;
75770:                             }
75770:                             shape = shape->previous();
75770:                         }
75770:                     }
75770:                 } else {
76020:                     return;
75770:                 }
75770:             }
75770:         }
75770: 
77392:         obj->setType(p->value.object);
75770:     } else {
77392:         /* Make a new type to use for the object and similar future ones. */
77461:         TypeObject *objType = newTypeObject(cx, NULL, JSProto_Object, obj->getProto());
77392:         if (!objType || !objType->addDefiniteProperties(cx, obj)) {
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
75770:         }
75770: 
75901:         jsid *ids = (jsid *) cx->calloc_(obj->slotSpan() * sizeof(jsid));
76020:         if (!ids) {
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
76020:         }
75770: 
77353:         Type *types = (Type *) cx->calloc_(obj->slotSpan() * sizeof(Type));
76020:         if (!types) {
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
76020:         }
75770: 
75770:         const Shape *shape = baseShape;
76022:         while (!JSID_IS_EMPTY(shape->propid)) {
76022:             ids[shape->slot] = shape->propid;
77448:             types[shape->slot] = GetValueTypeForTable(cx, obj->getSlot(shape->slot));
77375:             if (!objType->unknownProperties()) {
77375:                 jsid id = MakeTypeId(cx, shape->propid);
77375:                 objType->addPropertyType(cx, id, types[shape->slot]);
77375:             }
75770:             shape = shape->previous();
75770:         }
75770: 
75770:         ObjectTableKey key;
75770:         key.ids = ids;
75770:         key.nslots = obj->slotSpan();
75948:         key.nfixed = obj->numFixedSlots();
75770:         key.proto = obj->getProto();
75770:         JS_ASSERT(ObjectTableKey::match(key, obj));
75770: 
75770:         ObjectTableEntry entry;
75770:         entry.object = objType;
75770:         entry.types = types;
75770: 
75770:         p = objectTypeTable->lookupForAdd(obj);
75770:         if (!objectTypeTable->add(p, key, entry)) {
76020:             cx->compartment->types.setPendingNukeTypes(cx);
76020:             return;
75770:         }
75770: 
77392:         obj->setType(objType);
75770:     }
75770: }
75770: 
75770: /////////////////////////////////////////////////////////////////////
75641: // TypeObject
75615: /////////////////////////////////////////////////////////////////////
75615: 
75641: void
77361: TypeObject::getFromPrototypes(JSContext *cx, jsid id, TypeSet *types, bool force)
75641: {
77361:     if (!force && types->hasPropagatedProperty())
77361:         return;
77361: 
77361:     types->setPropagatedProperty();
77361: 
77361:     if (!proto)
77361:         return;
77361: 
77361:     if (proto->getType(cx)->unknownProperties()) {
77361:         types->addType(cx, Type::UnknownType());
77361:         return;
77361:     }
77361: 
77361:     TypeSet *protoTypes = proto->type()->getProperty(cx, id, false);
77361:     if (!protoTypes)
77361:         return;
77361: 
77361:     protoTypes->addSubset(cx, types);
77361: 
77361:     proto->type()->getFromPrototypes(cx, id, protoTypes);
77361: }
77361: 
77361: static inline void
77460: UpdatePropertyType(JSContext *cx, TypeSet *types, JSObject *obj, const Shape *shape, bool force)
75705: {
77361:     if (shape->hasGetterValue() || shape->hasSetterValue()) {
77361:         types->addType(cx, Type::UnknownType());
77461:     } else if (shape->hasDefaultGetterOrIsMethod() && shape->slot != SHAPE_INVALID_SLOT) {
77460:         const Value &value = obj->nativeGetSlot(shape->slot);
77460: 
77460:         /*
77460:          * Don't add initial undefined types for singleton properties that are
77460:          * not collated into the JSID_VOID property (see propertySet comment).
77460:          */
77460:         if (!force && value.isUndefined())
77460:             return;
77460: 
77460:         Type type = GetValueType(cx, value);
77361:         types->addType(cx, type);
75705:     }
75705: }
75705: 
75720: bool
75720: TypeObject::addProperty(JSContext *cx, jsid id, Property **pprop)
75720: {
75720:     JS_ASSERT(!*pprop);
77439:     Property *base = ArenaNew<Property>(cx->compartment->pool, id);
75720:     if (!base) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return false;
75720:     }
75718: 
77361:     if (singleton) {
77361:         /*
77361:          * Fill the property in with any type the object already has in an
77361:          * own property. We are only interested in plain native properties
77361:          * which don't go through a barrier when read by the VM or jitcode.
77361:          * We don't need to handle arrays or other JIT'ed non-natives as
77361:          * these are not (yet) singletons.
77361:          */
77361: 
77361:         if (JSID_IS_VOID(id)) {
77361:             /* Go through all shapes on the object to get integer-valued properties. */
77361:             const Shape *shape = singleton->lastProperty();
77361:             while (!JSID_IS_EMPTY(shape->propid)) {
77361:                 if (JSID_IS_VOID(MakeTypeId(cx, shape->propid)))
77460:                     UpdatePropertyType(cx, &base->types, singleton, shape, true);
77361:                 shape = shape->previous();
77361:             }
77361:         } else {
77361:             const Shape *shape = singleton->nativeLookup(id);
77361:             if (shape)
77460:                 UpdatePropertyType(cx, &base->types, singleton, shape, false);
77361:         }
77361:     }
77361: 
75720:     *pprop = base;
75720: 
76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s property %s %s",
76182:               InferSpewColor(&base->types), &base->types, InferSpewColorReset(),
77461:               TypeObjectString(this), TypeIdString(id));
75641: 
75720:     return true;
75720: }
75720: 
75948: bool
76059: TypeObject::addDefiniteProperties(JSContext *cx, JSObject *obj)
75948: {
75948:     if (unknownProperties())
75948:         return true;
75948: 
77361:     /* Mark all properties of obj as definite properties of this type. */
75948:     AutoEnterTypeInference enter(cx);
75948: 
75948:     const Shape *shape = obj->lastProperty();
76022:     while (!JSID_IS_EMPTY(shape->propid)) {
76022:         jsid id = MakeTypeId(cx, shape->propid);
75948:         if (!JSID_IS_VOID(id) && obj->isFixedSlot(shape->slot) &&
75948:             shape->slot <= (TYPE_FLAG_DEFINITE_MASK >> TYPE_FLAG_DEFINITE_SHIFT)) {
75948:             TypeSet *types = getProperty(cx, id, true);
75948:             if (!types)
75948:                 return false;
75948:             types->setDefinite(shape->slot);
75948:         }
75948:         shape = shape->previous();
75948:     }
75948: 
75987:     return true;
75948: }
75948: 
77361: bool
77361: TypeObject::matchDefiniteProperties(JSObject *obj)
77361: {
77361:     unsigned count = getPropertyCount();
77361:     for (unsigned i = 0; i < count; i++) {
77361:         Property *prop = getProperty(i);
77361:         if (!prop)
77361:             continue;
77361:         if (prop->types.isDefiniteProperty()) {
77361:             unsigned slot = prop->types.definiteSlot();
77361: 
77361:             bool found = false;
77361:             const Shape *shape = obj->lastProperty();
77361:             while (!JSID_IS_EMPTY(shape->propid)) {
77361:                 if (shape->slot == slot && shape->propid == prop->id) {
77361:                     found = true;
77361:                     break;
77361:                 }
77361:                 shape = shape->previous();
77361:             }
77361:             if (!found)
77361:                 return false;
77361:         }
77361:     }
77361: 
77361:     return true;
77361: }
77361: 
76148: inline void
77353: InlineAddTypeProperty(JSContext *cx, TypeObject *obj, jsid id, Type type)
76148: {
77361:     JS_ASSERT(id == MakeTypeId(cx, id));
76148: 
76148:     AutoEnterTypeInference enter(cx);
76148: 
76148:     TypeSet *types = obj->getProperty(cx, id, true);
76148:     if (!types || types->hasType(type))
76148:         return;
76148: 
76148:     InferSpew(ISpewOps, "externalType: property %s %s: %s",
77461:               TypeObjectString(obj), TypeIdString(id), TypeString(type));
76148:     types->addType(cx, type);
76148: }
76148: 
76148: void
77353: TypeObject::addPropertyType(JSContext *cx, jsid id, Type type)
76148: {
76148:     InlineAddTypeProperty(cx, this, id, type);
76148: }
76148: 
76148: void
76148: TypeObject::addPropertyType(JSContext *cx, jsid id, const Value &value)
76148: {
76148:     InlineAddTypeProperty(cx, this, id, GetValueType(cx, value));
76148: }
76148: 
76148: void
77353: TypeObject::addPropertyType(JSContext *cx, const char *name, Type type)
76148: {
76148:     jsid id = JSID_VOID;
76148:     if (name) {
76148:         JSAtom *atom = js_Atomize(cx, name, strlen(name));
76148:         if (!atom) {
76148:             AutoEnterTypeInference enter(cx);
76148:             cx->compartment->types.setPendingNukeTypes(cx);
76148:             return;
76148:         }
76148:         id = ATOM_TO_JSID(atom);
76148:     }
76148:     InlineAddTypeProperty(cx, this, id, type);
76148: }
76148: 
76148: void
76148: TypeObject::addPropertyType(JSContext *cx, const char *name, const Value &value)
76148: {
76148:     addPropertyType(cx, name, GetValueType(cx, value));
76148: }
76148: 
76148: void
76148: TypeObject::markPropertyConfigured(JSContext *cx, jsid id)
76148: {
76148:     AutoEnterTypeInference enter(cx);
76148: 
76148:     id = MakeTypeId(cx, id);
76148: 
76148:     TypeSet *types = getProperty(cx, id, true);
76148:     if (types)
76148:         types->setOwnProperty(cx, true);
76148: }
76148: 
76148: void
77414: TypeObject::markStateChange(JSContext *cx)
76148: {
77444:     if (unknownProperties())
77444:         return;
77444: 
76148:     AutoEnterTypeInference enter(cx);
77361:     TypeSet *types = maybeGetProperty(cx, JSID_EMPTY);
76148:     if (types) {
76148:         TypeConstraint *constraint = types->constraintList;
76148:         while (constraint) {
76148:             constraint->newObjectState(cx, this, true);
76148:             constraint = constraint->next;
76148:         }
76148:     }
76148: }
76148: 
75720: void
75919: TypeObject::setFlags(JSContext *cx, TypeObjectFlags flags)
75720: {
77353:     if ((this->flags & flags) == flags)
77353:         return;
77353: 
76148:     AutoEnterTypeInference enter(cx);
76148: 
77398:     if (singleton) {
77398:         /* Make sure flags are consistent with persistent object state. */
77361:         JS_ASSERT_IF(flags & OBJECT_FLAG_CREATED_ARGUMENTS,
77361:                      (flags & OBJECT_FLAG_UNINLINEABLE) && functionScript->createdArgs);
77398:         JS_ASSERT_IF(flags & OBJECT_FLAG_UNINLINEABLE, functionScript->uninlineable);
77398:         JS_ASSERT_IF(flags & OBJECT_FLAG_ITERATED, singleton->flags & JSObject::ITERATED);
77398:     }
76128: 
75919:     this->flags |= flags;
75919: 
77461:     InferSpew(ISpewOps, "%s: setFlags %u", TypeObjectString(this), flags);
75864: 
76097:     ObjectStateChange(cx, this, false, false);
75864: }
75864: 
75864: void
75641: TypeObject::markUnknown(JSContext *cx)
75640: {
76148:     AutoEnterTypeInference enter(cx);
76148: 
75987:     JS_ASSERT(cx->compartment->activeInference);
75919:     JS_ASSERT(!unknownProperties());
75760: 
77414:     if (!(flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED))
77414:         clearNewScript(cx);
77414: 
77461:     InferSpew(ISpewOps, "UnknownProperties: %s", TypeObjectString(this));
75833: 
76097:     ObjectStateChange(cx, this, true, true);
75641: 
75640:     /*
75641:      * Existing constraints may have already been added to this object, which we need
75640:      * to do the right thing for. We can't ensure that we will mark all unknown
75640:      * objects before they have been accessed, as the __proto__ of a known object
75640:      * could be dynamically set to an unknown object, and we can decide to ignore
75640:      * properties of an object during analysis (i.e. hashmaps). Adding unknown for
75640:      * any properties accessed already accounts for possible values read from them.
75640:      */
75640: 
75919:     unsigned count = getPropertyCount();
75919:     for (unsigned i = 0; i < count; i++) {
75919:         Property *prop = getProperty(i);
75944:         if (prop) {
77353:             prop->types.addType(cx, Type::UnknownType());
75944:             prop->types.setOwnProperty(cx, true);
75944:         }
75641:     }
75641: }
75641: 
75615: void
75948: TypeObject::clearNewScript(JSContext *cx)
75948: {
77361:     JS_ASSERT(!(flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED));
77361:     flags |= OBJECT_FLAG_NEW_SCRIPT_CLEARED;
76103: 
76103:     /*
76103:      * It is possible for the object to not have a new script yet but to have
76103:      * one added in the future. When analyzing properties of new scripts we mix
76103:      * in adding constraints to trigger clearNewScript with changes to the
76103:      * type sets themselves (from breakTypeBarriers). It is possible that we
76103:      * could trigger one of these constraints before AnalyzeNewScriptProperties
76103:      * has finished, in which case we want to make sure that call fails.
76103:      */
76103:     if (!newScript)
76103:         return;
75948: 
75948:     AutoEnterTypeInference enter(cx);
75948: 
75948:     /*
75948:      * Any definite properties we added due to analysis of the new script when
75948:      * the type object was created are now invalid: objects with the same type
75948:      * can be created by using 'new' on a different script or through some
75948:      * other mechanism (e.g. Object.create). Rather than clear out the definite
75948:      * bits on the object's properties, just mark such properties as having
75948:      * been deleted/reconfigured, which will have the same effect on JITs
75948:      * wanting to use the definite bits to optimize property accesses.
75948:      */
75948:     for (unsigned i = 0; i < getPropertyCount(); i++) {
75948:         Property *prop = getProperty(i);
75948:         if (!prop)
75948:             continue;
75948:         if (prop->types.isDefiniteProperty())
75948:             prop->types.setOwnProperty(cx, true);
75948:     }
76059: 
76059:     /*
76059:      * If we cleared the new script while in the middle of initializing an
76059:      * object, it will still have the new script's shape and reflect the no
76059:      * longer correct state of the object once its initialization is completed.
76059:      * We can't really detect the possibility of this statically, but the new
76059:      * script keeps track of where each property is initialized so we can walk
76059:      * the stack and fix up any such objects.
76059:      */
76185:     for (FrameRegsIter iter(cx); !iter.done(); ++iter) {
76059:         StackFrame *fp = iter.fp();
76059:         if (fp->isScriptFrame() && fp->isConstructing() &&
76059:             fp->script() == newScript->script && fp->thisValue().isObject() &&
77353:             !fp->thisValue().toObject().hasLazyType() &&
77353:             fp->thisValue().toObject().type() == this) {
76059:             JSObject *obj = &fp->thisValue().toObject();
76160:             jsbytecode *pc = iter.pc();
76059: 
76109:             /* Whether all identified 'new' properties have been initialized. */
76109:             bool finished = false;
76109: 
76109:             /* If not finished, number of properties that have been added. */
76059:             uint32 numProperties = 0;
76059: 
76059:             /*
76059:              * If non-zero, we are scanning initializers in a call which has
76059:              * already finished.
76059:              */
76059:             size_t depth = 0;
76059: 
76059:             for (TypeNewScript::Initializer *init = newScript->initializerList;; init++) {
76059:                 uint32 offset = uint32(pc - fp->script()->code);
76059:                 if (init->kind == TypeNewScript::Initializer::SETPROP) {
76059:                     if (!depth && init->offset > offset) {
76059:                         /* Advanced past all properties which have been initialized. */
76059:                         break;
76059:                     }
76059:                     numProperties++;
76059:                 } else if (init->kind == TypeNewScript::Initializer::FRAME_PUSH) {
76059:                     if (depth) {
76059:                         depth++;
76059:                     } else if (init->offset > offset) {
76059:                         /* Advanced past all properties which have been initialized. */
76059:                         break;
76059:                     } else if (init->offset == offset) {
76059:                         StackSegment &seg = cx->stack.space().containingSegment(fp);
76185:                         if (seg.maybefp() == fp)
76059:                             break;
76059:                         fp = seg.computeNextFrame(fp);
76168:                         pc = fp->pcQuadratic(cx->stack);
76059:                     } else {
76059:                         /* This call has already finished. */
76059:                         depth = 1;
76059:                     }
76059:                 } else if (init->kind == TypeNewScript::Initializer::FRAME_POP) {
76059:                     if (depth) {
76059:                         depth--;
76059:                     } else {
76059:                         /* This call has not finished yet. */
76059:                         break;
76059:                     }
76059:                 } else {
76087:                     JS_ASSERT(init->kind == TypeNewScript::Initializer::DONE);
76109:                     finished = true;
76059:                     break;
76059:                 }
76059:             }
76059: 
76109:             if (!finished)
76153:                 obj->rollbackProperties(cx, numProperties);
76059:         }
76059:     }
76059: 
76059:     cx->free_(newScript);
76059:     newScript = NULL;
77414: 
77414:     markStateChange(cx);
75948: }
75948: 
75948: void
75638: TypeObject::print(JSContext *cx)
75615: {
77461:     printf("%s : %s",
77461:            TypeObjectString(this),
77461:            proto ? TypeString(Type::ObjectType(proto)) : "(null)");
75679: 
75919:     if (unknownProperties()) {
75679:         printf(" unknown");
75919:     } else {
76044:         if (!hasAnyFlags(OBJECT_FLAG_NON_PACKED_ARRAY))
75826:             printf(" packed");
76044:         if (!hasAnyFlags(OBJECT_FLAG_NON_DENSE_ARRAY))
75826:             printf(" dense");
76179:         if (!hasAnyFlags(OBJECT_FLAG_NON_TYPED_ARRAY))
76179:             printf(" typed");
76044:         if (hasAnyFlags(OBJECT_FLAG_UNINLINEABLE))
75919:             printf(" uninlineable");
76044:         if (hasAnyFlags(OBJECT_FLAG_SPECIAL_EQUALITY))
75919:             printf(" specialEquality");
76044:         if (hasAnyFlags(OBJECT_FLAG_ITERATED))
76044:             printf(" iterated");
75919:     }
75641: 
77361:     unsigned count = getPropertyCount();
77361: 
77361:     if (count == 0) {
75641:         printf(" {}\n");
75641:         return;
75641:     }
75641: 
75641:     printf(" {");
75641: 
75919:     for (unsigned i = 0; i < count; i++) {
75919:         Property *prop = getProperty(i);
75641:         if (prop) {
75641:             printf("\n    %s:", TypeIdString(prop->id));
75944:             prop->types.print(cx);
75641:         }
75641:     }
75641: 
75641:     printf("\n}\n");
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75987: // Type Analysis
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: /*
75615:  * If the bytecode immediately following code/pc is a test of the value
75708:  * pushed by code, that value should be marked as possibly void.
75615:  */
75708: static inline bool
75708: CheckNextTest(jsbytecode *pc)
75615: {
76059:     jsbytecode *next = pc + GetBytecodeLength(pc);
75615:     switch ((JSOp)*next) {
75615:       case JSOP_IFEQ:
75615:       case JSOP_IFNE:
75615:       case JSOP_NOT:
75703:       case JSOP_OR:
75703:       case JSOP_ORX:
75703:       case JSOP_AND:
75703:       case JSOP_ANDX:
75615:       case JSOP_TYPEOF:
75615:       case JSOP_TYPEOFEXPR:
75708:         return true;
75615:       default:
76095:         /* TRAP ok here */
75708:         return false;
75615:     }
75615: }
75615: 
75987: static inline TypeObject *
75987: GetInitializerType(JSContext *cx, JSScript *script, jsbytecode *pc)
75987: {
76158:     if (!script->hasGlobal())
75987:         return NULL;
75987: 
76095:     UntrapOpcode untrap(cx, script, pc);
76095: 
75987:     JSOp op = JSOp(*pc);
75987:     JS_ASSERT(op == JSOP_NEWARRAY || op == JSOP_NEWOBJECT || op == JSOP_NEWINIT);
75987: 
75987:     bool isArray = (op == JSOP_NEWARRAY || (op == JSOP_NEWINIT && pc[1] == JSProto_Array));
77391:     return TypeScript::InitObject(cx, script, pc, isArray ? JSProto_Array : JSProto_Object);
75987: }
75987: 
75708: /* Analyze type information for a single bytecode. */
75987: bool
76059: ScriptAnalysis::analyzeTypesBytecode(JSContext *cx, unsigned offset,
75987:                                      TypeInferenceState &state)
75615: {
75615:     jsbytecode *pc = script->code + offset;
75615:     JSOp op = (JSOp)*pc;
75615: 
75987:     Bytecode &code = getCode(offset);
75987:     JS_ASSERT(!code.pushedTypes);
75987: 
75708:     InferSpew(ISpewOps, "analyze: #%u:%05u", script->id(), offset);
75708: 
76059:     unsigned defCount = GetDefCount(script, offset);
76059:     if (ExtendedDef(pc))
75987:         defCount++;
75987: 
75987:     TypeSet *pushed = ArenaArray<TypeSet>(cx->compartment->pool, defCount);
75720:     if (!pushed)
75720:         return false;
75708:     PodZero(pushed, defCount);
75987:     code.pushedTypes = pushed;
75987: 
75987:     /*
75987:      * Add phi nodes introduced at this point to the list of all phi nodes in
75987:      * the script. Types for these are not generated until after the script has
75987:      * been processed, as types can flow backwards into phi nodes and the
75987:      * source sets may not exist if we try to process these eagerly.
75987:      */
75987:     if (code.newValues) {
75987:         SlotValue *newv = code.newValues;
75987:         while (newv->slot) {
75987:             if (newv->value.kind() != SSAValue::PHI || newv->value.phiOffset() != offset) {
75987:                 newv++;
75987:                 continue;
75987:             }
75987: 
75987:             /*
75987:              * The phi nodes at join points should all be unique, and every phi
75987:              * node created should be in the phiValues list on some bytecode.
75987:              */
75987:             if (!state.phiNodes.append(newv->value.phiNode()))
75987:                 return false;
75987:             TypeSet &types = newv->value.phiNode()->types;
76182:             InferSpew(ISpewOps, "typeSet: %sT%p%s phi #%u:%05u:%u",
76182:                       InferSpewColor(&types), &types, InferSpewColorReset(),
75987:                       script->id(), offset, newv->slot);
75987:             newv++;
75987:         }
75987:     }
75708: 
77360:     /*
77360:      * Treat decomposed ops as no-ops, we will analyze the decomposed version
77360:      * instead. (We do, however, need to look at introduced phi nodes).
77360:      */
77360:     if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
77360:         return true;
77360: 
75789:     for (unsigned i = 0; i < defCount; i++) {
76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s pushed%u #%u:%05u",
76182:                   InferSpewColor(&pushed[i]), &pushed[i], InferSpewColorReset(),
76182:                   i, script->id(), offset);
75789:     }
75720: 
75615:     /* Add type constraints for the various opcodes. */
75615:     switch (op) {
75615: 
75615:         /* Nop bytecodes. */
75636:       case JSOP_POP:
75615:       case JSOP_NOP:
75615:       case JSOP_TRACE:
76031:       case JSOP_NOTRACE:
75615:       case JSOP_GOTO:
75615:       case JSOP_GOTOX:
75615:       case JSOP_IFEQ:
75615:       case JSOP_IFEQX:
75615:       case JSOP_IFNE:
75615:       case JSOP_IFNEX:
75615:       case JSOP_LINENO:
75615:       case JSOP_DEFCONST:
75615:       case JSOP_LEAVEWITH:
75615:       case JSOP_LEAVEBLOCK:
75615:       case JSOP_RETRVAL:
75615:       case JSOP_ENDITER:
75615:       case JSOP_THROWING:
75615:       case JSOP_GOSUB:
75615:       case JSOP_GOSUBX:
75615:       case JSOP_RETSUB:
75615:       case JSOP_CONDSWITCH:
75615:       case JSOP_DEFAULT:
75784:       case JSOP_DEFAULTX:
75615:       case JSOP_POPN:
75615:       case JSOP_UNBRANDTHIS:
75615:       case JSOP_STARTXML:
75615:       case JSOP_STARTXMLEXPR:
75615:       case JSOP_DEFXMLNS:
75615:       case JSOP_SHARPINIT:
75615:       case JSOP_INDEXBASE:
75615:       case JSOP_INDEXBASE1:
75615:       case JSOP_INDEXBASE2:
75615:       case JSOP_INDEXBASE3:
75615:       case JSOP_RESETBASE:
75615:       case JSOP_RESETBASE0:
75615:       case JSOP_BLOCKCHAIN:
75615:       case JSOP_NULLBLOCKCHAIN:
75615:       case JSOP_POPV:
75636:       case JSOP_DEBUGGER:
75699:       case JSOP_SETCALL:
75987:       case JSOP_TABLESWITCH:
75987:       case JSOP_TABLESWITCHX:
75987:       case JSOP_LOOKUPSWITCH:
75987:       case JSOP_LOOKUPSWITCHX:
75987:       case JSOP_TRY:
75615:         break;
75615: 
75615:         /* Bytecodes pushing values of known type. */
75615:       case JSOP_VOID:
75615:       case JSOP_PUSH:
77353:         pushed[0].addType(cx, Type::UndefinedType());
75615:         break;
75615:       case JSOP_ZERO:
75615:       case JSOP_ONE:
75615:       case JSOP_INT8:
75615:       case JSOP_INT32:
75615:       case JSOP_UINT16:
75615:       case JSOP_UINT24:
75615:       case JSOP_BITAND:
75615:       case JSOP_BITOR:
75615:       case JSOP_BITXOR:
75615:       case JSOP_BITNOT:
75615:       case JSOP_RSH:
75615:       case JSOP_LSH:
75630:       case JSOP_URSH:
77353:         pushed[0].addType(cx, Type::Int32Type());
75615:         break;
75615:       case JSOP_FALSE:
75615:       case JSOP_TRUE:
75615:       case JSOP_EQ:
75615:       case JSOP_NE:
75615:       case JSOP_LT:
75615:       case JSOP_LE:
75615:       case JSOP_GT:
75615:       case JSOP_GE:
75615:       case JSOP_NOT:
75615:       case JSOP_STRICTEQ:
75615:       case JSOP_STRICTNE:
75615:       case JSOP_IN:
75615:       case JSOP_INSTANCEOF:
75615:       case JSOP_DELDESC:
77353:         pushed[0].addType(cx, Type::BooleanType());
75615:         break;
75615:       case JSOP_DOUBLE:
77353:         pushed[0].addType(cx, Type::DoubleType());
75615:         break;
75615:       case JSOP_STRING:
75615:       case JSOP_TYPEOF:
75615:       case JSOP_TYPEOFEXPR:
75615:       case JSOP_QNAMEPART:
75615:       case JSOP_XMLTAGEXPR:
75615:       case JSOP_TOATTRVAL:
75615:       case JSOP_ADDATTRNAME:
75615:       case JSOP_ADDATTRVAL:
75615:       case JSOP_XMLELTEXPR:
77353:         pushed[0].addType(cx, Type::StringType());
75615:         break;
75615:       case JSOP_NULL:
77353:         pushed[0].addType(cx, Type::NullType());
75615:         break;
75720: 
75615:       case JSOP_REGEXP:
76158:         if (script->hasGlobal()) {
77391:             TypeObject *object = TypeScript::StandardType(cx, script, JSProto_RegExp);
75720:             if (!object)
75720:                 return false;
77353:             pushed[0].addType(cx, Type::ObjectType(object));
75720:         } else {
77353:             pushed[0].addType(cx, Type::UnknownType());
75720:         }
75615:         break;
75615: 
75716:       case JSOP_OBJECT: {
75716:         JSObject *obj = GetScriptObject(cx, script, pc, 0);
77353:         pushed[0].addType(cx, Type::ObjectType(obj));
75716:         break;
75716:       }
75716: 
75615:       case JSOP_STOP:
75615:         /* If a stop is reachable then the return type may be void. */
77391:         if (script->hasFunction)
77391:             TypeScript::ReturnTypes(script)->addType(cx, Type::UndefinedType());
75615:         break;
75615: 
75615:       case JSOP_OR:
75615:       case JSOP_ORX:
75615:       case JSOP_AND:
75615:       case JSOP_ANDX:
75615:         /* OR/AND push whichever operand determined the result. */
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75640:       case JSOP_DUP:
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[1]);
75615:         break;
75615: 
75615:       case JSOP_DUP2:
77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[0]);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[1]);
77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[2]);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[3]);
75615:         break;
75615: 
77340:       case JSOP_SWAP:
77340:       case JSOP_PICK: {
77340:         unsigned pickedDepth = (op == JSOP_SWAP ? 1 : pc[1]);
77340:         /* The last popped value is the last pushed. */
77353:         poppedTypes(pc, pickedDepth)->addSubset(cx, &pushed[pickedDepth]);
77340:         for (unsigned i = 0; i < pickedDepth; i++)
77353:             poppedTypes(pc, i)->addSubset(cx, &pushed[pickedDepth - 1 - i]);
77340:         break;
77340:       }
77340: 
75615:       case JSOP_GETGLOBAL:
75615:       case JSOP_CALLGLOBAL:
75615:       case JSOP_GETGNAME:
75718:       case JSOP_CALLGNAME: {
75615:         jsid id;
75718:         if (op == JSOP_GETGLOBAL || op == JSOP_CALLGLOBAL)
75708:             id = GetGlobalId(cx, script, pc);
75718:         else
75708:             id = GetAtomId(cx, script, pc, 0);
75636: 
77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
77353:         seen->addSubset(cx, &pushed[0]);
76087: 
75888:         /*
75888:          * Normally we rely on lazy standard class initialization to fill in
75888:          * the types of global properties the script can access. In a few cases
75888:          * the method JIT will bypass this, and we need to add the types direclty.
75888:          */
75888:         if (id == ATOM_TO_JSID(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]))
77353:             seen->addType(cx, Type::UndefinedType());
75888:         if (id == ATOM_TO_JSID(cx->runtime->atomState.NaNAtom))
77353:             seen->addType(cx, Type::DoubleType());
75888:         if (id == ATOM_TO_JSID(cx->runtime->atomState.InfinityAtom))
77353:             seen->addType(cx, Type::DoubleType());
76061: 
75636:         /* Handle as a property access. */
77361:         PropertyAccess(cx, script, pc, script->global()->getType(cx), false, seen, id);
75718: 
76103:         if (op == JSOP_CALLGLOBAL || op == JSOP_CALLGNAME) {
77353:             pushed[1].addType(cx, Type::UnknownType());
77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UnknownType());
76103:         }
75716: 
75708:         if (CheckNextTest(pc))
77353:             pushed[0].addType(cx, Type::UndefinedType());
75615:         break;
75615:       }
75615: 
75987:       case JSOP_NAME:
76061:       case JSOP_CALLNAME: {
76061:         /*
76061:          * The first value pushed by NAME/CALLNAME must always be added to the
76061:          * bytecode types, we don't model these opcodes with inference.
76061:          */
77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
77353:         addTypeBarrier(cx, pc, seen, Type::UnknownType());
77353:         seen->addSubset(cx, &pushed[0]);
76103:         if (op == JSOP_CALLNAME) {
77353:             pushed[1].addType(cx, Type::UnknownType());
77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UnknownType());
76103:         }
75987:         break;
76061:       }
75987: 
75987:       case JSOP_BINDGNAME:
75987:       case JSOP_BINDNAME:
75987:         break;
75987: 
75987:       case JSOP_SETGNAME: {
75987:         jsid id = GetAtomId(cx, script, pc, 0);
77361:         PropertyAccess(cx, script, pc, script->global()->getType(cx),
75987:                        true, poppedTypes(pc, 0), id);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75987:         break;
75987:       }
75987: 
75987:       case JSOP_SETNAME:
75987:       case JSOP_SETCONST:
75987:         cx->compartment->types.monitorBytecode(cx, script, offset);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75987:         break;
75987: 
77439:       case JSOP_GETXPROP:
77439:       case JSOP_GETFCSLOT:
77439:       case JSOP_CALLFCSLOT: {
77439:         TypeSet *seen = bytecodeTypes(pc);
77353:         addTypeBarrier(cx, pc, seen, Type::UnknownType());
77353:         seen->addSubset(cx, &pushed[0]);
76103:         if (op == JSOP_CALLFCSLOT) {
77353:             pushed[1].addType(cx, Type::UndefinedType());
77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UndefinedType());
76103:         }
75615:         break;
75615:       }
75615: 
75615:       case JSOP_GETARG:
75987:       case JSOP_CALLARG:
75987:       case JSOP_GETLOCAL:
75987:       case JSOP_CALLLOCAL: {
75987:         uint32 slot = GetBytecodeSlot(script, pc);
75987:         if (trackSlot(slot)) {
75987:             /*
75987:              * Normally these opcodes don't pop anything, but they are given
75987:              * an extended use holding the variable's SSA value before the
75987:              * access. Use the types from here.
75987:              */
77353:             poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75987:         } else if (slot < TotalSlots(script)) {
77391:             TypeSet *types = TypeScript::SlotTypes(script, slot);
77353:             types->addSubset(cx, &pushed[0]);
75987:         } else {
75987:             /* Local 'let' variable. Punt on types for these, for now. */
77353:             pushed[0].addType(cx, Type::UnknownType());
75987:         }
76103:         if (op == JSOP_CALLARG || op == JSOP_CALLLOCAL) {
77353:             pushed[1].addType(cx, Type::UndefinedType());
77353:             pushed[0].addPropagateThis(cx, script, pc, Type::UndefinedType());
76103:         }
75987:         break;
75987:       }
75987: 
75615:       case JSOP_SETARG:
75987:       case JSOP_SETLOCAL:
75987:       case JSOP_SETLOCALPOP: {
75987:         uint32 slot = GetBytecodeSlot(script, pc);
75987:         if (!trackSlot(slot) && slot < TotalSlots(script)) {
77391:             TypeSet *types = TypeScript::SlotTypes(script, slot);
77353:             poppedTypes(pc, 0)->addSubset(cx, types);
75987:         }
75987: 
75987:         /*
75987:          * For assignments to non-escaping locals/args, we don't need to update
75987:          * the possible types of the var, as for each read of the var SSA gives
75987:          * us the writes that could have produced that read.
75987:          */
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_INCARG:
75615:       case JSOP_DECARG:
75615:       case JSOP_ARGINC:
75987:       case JSOP_ARGDEC:
75615:       case JSOP_INCLOCAL:
75615:       case JSOP_DECLOCAL:
75615:       case JSOP_LOCALINC:
75615:       case JSOP_LOCALDEC: {
75987:         uint32 slot = GetBytecodeSlot(script, pc);
75987:         if (trackSlot(slot)) {
77353:             poppedTypes(pc, 0)->addArith(cx, &pushed[0]);
75987:         } else if (slot < TotalSlots(script)) {
77391:             TypeSet *types = TypeScript::SlotTypes(script, slot);
77353:             types->addArith(cx, types);
77353:             types->addSubset(cx, &pushed[0]);
75708:         } else {
77353:             pushed[0].addType(cx, Type::UnknownType());
75708:         }
75615:         break;
75615:       }
75615: 
76128:       case JSOP_ARGUMENTS: {
76128:         /* Compute a precise type only when we know the arguments won't escape. */
77391:         TypeObject *funType = script->function()->getType(cx);
76128:         if (funType->unknownProperties() || funType->hasAnyFlags(OBJECT_FLAG_CREATED_ARGUMENTS)) {
77353:             pushed[0].addType(cx, Type::UnknownType());
75987:             break;
76128:         }
77361:         TypeSet *types = funType->getProperty(cx, JSID_EMPTY, false);
77361:         if (!types)
75708:             break;
77361:         types->addLazyArguments(cx, &pushed[0]);
77353:         pushed[0].addType(cx, Type::LazyArgsType());
76128:         break;
76128:       }
75708: 
75708:       case JSOP_SETPROP:
75708:       case JSOP_SETMETHOD: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75987:         poppedTypes(pc, 1)->addSetProperty(cx, script, pc, poppedTypes(pc, 0), id);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615:       }
75615: 
75987:       case JSOP_LENGTH:
75615:       case JSOP_GETPROP:
76061:       case JSOP_CALLPROP: {
76061:         jsid id = GetAtomId(cx, script, pc, 0);
77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
76103: 
76061:         poppedTypes(pc, 0)->addGetProperty(cx, script, pc, seen, id);
76136:         if (op == JSOP_CALLPROP)
76136:             poppedTypes(pc, 0)->addCallProperty(cx, script, pc, id);
76103: 
77353:         seen->addSubset(cx, &pushed[0]);
76061:         if (op == JSOP_CALLPROP)
77353:             poppedTypes(pc, 0)->addFilterPrimitives(cx, &pushed[1], true);
76061:         if (CheckNextTest(pc))
77353:             pushed[0].addType(cx, Type::UndefinedType());
76061:         break;
76061:       }
76061: 
76061:       /*
76061:        * We only consider ELEM accesses on integers below. Any element access
76061:        * which is accessing a non-integer property must be monitored.
76061:        */
76061: 
76061:       case JSOP_GETELEM:
76061:       case JSOP_CALLELEM: {
77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
76103: 
76061:         poppedTypes(pc, 1)->addGetProperty(cx, script, pc, seen, JSID_VOID);
76136:         if (op == JSOP_CALLELEM)
76136:             poppedTypes(pc, 1)->addCallProperty(cx, script, pc, JSID_VOID);
76103: 
77353:         seen->addSubset(cx, &pushed[0]);
76061:         if (op == JSOP_CALLELEM)
77353:             poppedTypes(pc, 1)->addFilterPrimitives(cx, &pushed[1], true);
75987:         if (CheckNextTest(pc))
77353:             pushed[0].addType(cx, Type::UndefinedType());
75615:         break;
75615:       }
75615: 
75615:       case JSOP_SETELEM:
75919:       case JSOP_SETHOLE:
77399:         poppedTypes(pc, 1)->addSetElement(cx, script, pc, poppedTypes(pc, 2), poppedTypes(pc, 0));
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
77357:       case JSOP_TOID:
77357:         /*
77357:          * This is only used for element inc/dec ops; any id produced which
77357:          * is not an integer must be monitored.
77357:          */
77357:         pushed[0].addType(cx, Type::Int32Type());
77357:         break;
77357: 
75615:       case JSOP_THIS:
77391:         TypeScript::ThisTypes(script)->addTransformThis(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_RETURN:
75615:       case JSOP_SETRVAL:
77391:         if (script->hasFunction)
77391:             poppedTypes(pc, 0)->addSubset(cx, TypeScript::ReturnTypes(script));
75615:         break;
75615: 
75615:       case JSOP_ADD:
77353:         poppedTypes(pc, 0)->addArith(cx, &pushed[0], poppedTypes(pc, 1));
77353:         poppedTypes(pc, 1)->addArith(cx, &pushed[0], poppedTypes(pc, 0));
75615:         break;
75615: 
75615:       case JSOP_SUB:
75615:       case JSOP_MUL:
75615:       case JSOP_MOD:
75630:       case JSOP_DIV:
77353:         poppedTypes(pc, 0)->addArith(cx, &pushed[0]);
77353:         poppedTypes(pc, 1)->addArith(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_NEG:
75615:       case JSOP_POS:
77353:         poppedTypes(pc, 0)->addArith(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_LAMBDA:
75615:       case JSOP_LAMBDA_FC:
75615:       case JSOP_DEFFUN:
75615:       case JSOP_DEFFUN_FC:
75615:       case JSOP_DEFLOCALFUN:
75615:       case JSOP_DEFLOCALFUN_FC: {
75615:         unsigned off = (op == JSOP_DEFLOCALFUN || op == JSOP_DEFLOCALFUN_FC) ? SLOTNO_LEN : 0;
75640:         JSObject *obj = GetScriptObject(cx, script, pc, off);
75615: 
75615:         TypeSet *res = NULL;
75987:         if (op == JSOP_LAMBDA || op == JSOP_LAMBDA_FC) {
75708:             res = &pushed[0];
75987:         } else if (op == JSOP_DEFLOCALFUN || op == JSOP_DEFLOCALFUN_FC) {
75987:             uint32 slot = GetBytecodeSlot(script, pc);
75987:             if (trackSlot(slot)) {
75987:                 res = &pushed[0];
75987:             } else {
75987:                 /* Should not see 'let' vars here. */
75987:                 JS_ASSERT(slot < TotalSlots(script));
77391:                 res = TypeScript::SlotTypes(script, slot);
75987:             }
75987:         }
75615: 
75688:         if (res) {
76158:             if (script->hasGlobal())
77353:                 res->addType(cx, Type::ObjectType(obj));
75615:             else
77353:                 res->addType(cx, Type::UnknownType());
75688:         } else {
75708:             cx->compartment->types.monitorBytecode(cx, script, offset);
75688:         }
75615:         break;
75615:       }
75615: 
75718:       case JSOP_DEFVAR:
75718:         break;
75718: 
75615:       case JSOP_CALL:
75615:       case JSOP_EVAL:
75631:       case JSOP_FUNCALL:
75631:       case JSOP_FUNAPPLY:
75615:       case JSOP_NEW: {
77391:         TypeSet *seen = script->analysis()->bytecodeTypes(pc);
77353:         seen->addSubset(cx, &pushed[0]);
76175: 
75615:         /* Construct the base call information about this site. */
76059:         unsigned argCount = GetUseCount(script, offset) - 2;
75987:         TypeCallsite *callsite = ArenaNew<TypeCallsite>(cx->compartment->pool,
75720:                                                         cx, script, pc, op == JSOP_NEW, argCount);
75720:         if (!callsite || (argCount && !callsite->argumentTypes)) {
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             break;
75720:         }
75987:         callsite->thisTypes = poppedTypes(pc, argCount);
76175:         callsite->returnTypes = seen;
75708: 
75708:         for (unsigned i = 0; i < argCount; i++)
75987:             callsite->argumentTypes[i] = poppedTypes(pc, argCount - 1 - i);
75987: 
76118:         /*
76118:          * Mark FUNCALL and FUNAPPLY sites as monitored. The method JIT may
76118:          * lower these into normal calls, and we need to make sure the
76118:          * callee's argument types are checked on entry.
76118:          */
76118:         if (op == JSOP_FUNCALL || op == JSOP_FUNAPPLY)
76118:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
76118: 
75987:         poppedTypes(pc, argCount + 1)->addCall(cx, callsite);
75615:         break;
75615:       }
75615: 
75639:       case JSOP_NEWINIT:
75639:       case JSOP_NEWARRAY:
75987:       case JSOP_NEWOBJECT: {
75987:         TypeObject *initializer = GetInitializerType(cx, script, pc);
76158:         if (script->hasGlobal()) {
75720:             if (!initializer)
75720:                 return false;
77353:             pushed[0].addType(cx, Type::ObjectType(initializer));
75688:         } else {
75987:             JS_ASSERT(!initializer);
77353:             pushed[0].addType(cx, Type::UnknownType());
75688:         }
75615:         break;
75987:       }
75615: 
75627:       case JSOP_ENDINIT:
75627:         break;
75627: 
75987:       case JSOP_INITELEM: {
75987:         const SSAValue &objv = poppedValue(pc, 2);
75987:         jsbytecode *initpc = script->code + objv.pushedOffset();
75987:         TypeObject *initializer = GetInitializerType(cx, script, initpc);
75987: 
75762:         if (initializer) {
77353:             pushed[0].addType(cx, Type::ObjectType(initializer));
75919:             if (!initializer->unknownProperties()) {
75759:                 /*
75759:                  * Assume the initialized element is an integer. INITELEM can be used
75759:                  * for doubles which don't map to the JSID_VOID property, which must
75759:                  * be caught with dynamic monitoring.
75759:                  */
75759:                 TypeSet *types = initializer->getProperty(cx, JSID_VOID, true);
75720:                 if (!types)
75720:                     return false;
77353:                 if (state.hasGetSet) {
77353:                     types->addType(cx, Type::UnknownType());
77353:                 } else if (state.hasHole) {
77353:                     if (!initializer->unknownProperties())
77353:                         initializer->setFlags(cx, OBJECT_FLAG_NON_PACKED_ARRAY);
75688:                 } else {
77353:                     poppedTypes(pc, 0)->addSubset(cx, types);
77353:                 }
77353:             }
77353:         } else {
77353:             pushed[0].addType(cx, Type::UnknownType());
75688:         }
75627:         state.hasGetSet = false;
75639:         state.hasHole = false;
75615:         break;
75987:       }
75615: 
75627:       case JSOP_GETTER:
75627:       case JSOP_SETTER:
75627:         state.hasGetSet = true;
75627:         break;
75627: 
75639:       case JSOP_HOLE:
75639:         state.hasHole = true;
75639:         break;
75639: 
75615:       case JSOP_INITPROP:
75987:       case JSOP_INITMETHOD: {
75987:         const SSAValue &objv = poppedValue(pc, 1);
75987:         jsbytecode *initpc = script->code + objv.pushedOffset();
75987:         TypeObject *initializer = GetInitializerType(cx, script, initpc);
75987: 
75762:         if (initializer) {
77353:             pushed[0].addType(cx, Type::ObjectType(initializer));
75919:             if (!initializer->unknownProperties()) {
75708:                 jsid id = GetAtomId(cx, script, pc, 0);
75708:                 TypeSet *types = initializer->getProperty(cx, id, true);
75720:                 if (!types)
75720:                     return false;
75760:                 if (id == id___proto__(cx) || id == id_prototype(cx))
75708:                     cx->compartment->types.monitorBytecode(cx, script, offset);
75760:                 else if (state.hasGetSet)
77353:                     types->addType(cx, Type::UnknownType());
75760:                 else
77353:                     poppedTypes(pc, 0)->addSubset(cx, types);
75762:             }
75688:         } else {
77353:             pushed[0].addType(cx, Type::UnknownType());
75688:         }
75627:         state.hasGetSet = false;
75639:         JS_ASSERT(!state.hasHole);
75615:         break;
75987:       }
75615: 
75615:       case JSOP_ENTERWITH:
75708:       case JSOP_ENTERBLOCK:
75615:         /*
75708:          * Scope lookups can occur on the values being pushed here. We don't track
75708:          * the value or its properties, and just monitor all name opcodes in the
75718:          * script.
75615:          */
75615:         break;
75615: 
77363:       case JSOP_ITER: {
75627:         /*
77363:          * Use a per-script type set to unify the possible target types of all
77363:          * 'for in' or 'for each' loops in the script. We need to mark the
77363:          * value pushed by the ITERNEXT appropriately, but don't track the SSA
77363:          * information to connect that ITERNEXT with the appropriate ITER.
77363:          * This loses some precision when a script mixes 'for in' and
77363:          * 'for each' loops together, oh well.
75627:          */
77363:         if (!state.forTypes) {
77363:           state.forTypes = TypeSet::make(cx, "forTypes");
77363:           if (!state.forTypes)
77363:               return false;
77363:         }
77363: 
77363:         if (pc[1] & JSITER_FOREACH)
77363:             state.forTypes->addType(cx, Type::UnknownType());
77399:         else
77399:             state.forTypes->addType(cx, Type::StringType());
77363:         break;
77363:       }
77363: 
77363:       case JSOP_ITERNEXT:
77399:         state.forTypes->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_MOREITER:
77353:         pushed[1].addType(cx, Type::BooleanType());
75615:         break;
75615: 
75615:       case JSOP_ENUMELEM:
75753:       case JSOP_ENUMCONSTELEM:
75987:       case JSOP_ARRAYPUSH:
75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
75615:         break;
75615: 
75615:       case JSOP_THROW:
75615:         /* There will be a monitor on the bytecode catching the exception. */
75615:         break;
75615: 
75615:       case JSOP_FINALLY:
75615:         /* Pushes information about whether an exception was thrown. */
75615:         break;
75615: 
75615:       case JSOP_EXCEPTION:
77353:         pushed[0].addType(cx, Type::UnknownType());
75615:         break;
75615: 
75615:       case JSOP_DELPROP:
75615:       case JSOP_DELELEM:
75615:       case JSOP_DELNAME:
77353:         pushed[0].addType(cx, Type::BooleanType());
75615:         break;
75615: 
75615:       case JSOP_LEAVEBLOCKEXPR:
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_CASE:
75784:       case JSOP_CASEX:
77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_UNBRAND:
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_GENERATOR:
77391:         if (script->hasFunction) {
76158:             if (script->hasGlobal()) {
77391:                 TypeObject *object = TypeScript::StandardType(cx, script, JSProto_Generator);
75720:                 if (!object)
75720:                     return false;
77391:                 TypeScript::ReturnTypes(script)->addType(cx, Type::ObjectType(object));
75688:             } else {
77391:                 TypeScript::ReturnTypes(script)->addType(cx, Type::UnknownType());
75688:             }
75615:         }
75615:         break;
75615: 
75615:       case JSOP_YIELD:
77353:         pushed[0].addType(cx, Type::UnknownType());
75615:         break;
75615: 
75641:       case JSOP_CALLXMLNAME:
77353:         pushed[1].addType(cx, Type::UnknownType());
75633:         /* FALLTHROUGH */
75641:       case JSOP_XMLNAME:
77353:         pushed[0].addType(cx, Type::UnknownType());
75633:         break;
75633: 
75615:       case JSOP_SETXMLNAME:
75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_BINDXMLNAME:
75615:         break;
75615: 
75615:       case JSOP_TOXML:
75615:       case JSOP_TOXMLLIST:
75615:       case JSOP_XMLPI:
75615:       case JSOP_XMLCDATA:
75615:       case JSOP_XMLCOMMENT:
75615:       case JSOP_DESCENDANTS:
75615:       case JSOP_TOATTRNAME:
75615:       case JSOP_QNAMECONST:
75615:       case JSOP_QNAME:
75615:       case JSOP_ANYNAME:
75615:       case JSOP_GETFUNNS:
77353:         pushed[0].addType(cx, Type::UnknownType());
75615:         break;
75615: 
75615:       case JSOP_FILTER:
75615:         /* Note: the second value pushed by filter is a hole, and not modelled. */
77353:         poppedTypes(pc, 0)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_ENDFILTER:
77353:         poppedTypes(pc, 1)->addSubset(cx, &pushed[0]);
75615:         break;
75615: 
75708:       case JSOP_DEFSHARP:
75708:         break;
75708: 
75708:       case JSOP_USESHARP:
77353:         pushed[0].addType(cx, Type::UnknownType());
75708:         break;
75708: 
75708:       case JSOP_CALLEE:
76158:         if (script->hasGlobal())
77391:             pushed[0].addType(cx, Type::ObjectType(script->function()));
75708:         else
77353:             pushed[0].addType(cx, Type::UnknownType());
75708:         break;
75708: 
75615:       default:
76150:         /* Display fine-grained debug information first */
76150:         fprintf(stderr, "Unknown bytecode %02x at #%u:%05u\n", op, script->id(), offset);
76150:         TypeFailure(cx, "Unknown bytecode %02x", op);
75615:     }
75720: 
75720:     return true;
75708: }
75615: 
75701: void
76059: ScriptAnalysis::analyzeTypes(JSContext *cx)
75701: {
76093:     JS_ASSERT(!ranInference());
76093: 
76093:     if (OOM()) {
76093:         cx->compartment->types.setPendingNukeTypes(cx);
76093:         return;
76093:     }
75987: 
76058:     /*
76058:      * Refuse to analyze the types in a script which is compileAndGo but is
76058:      * running against a global with a cleared scope. Per GlobalObject::clear,
76058:      * we won't be running anymore compileAndGo code against the global
76058:      * (moreover, after clearing our analysis results will be wrong for the
76058:      * script and trying to reanalyze here can cause reentrance problems if we
76058:      * try to reinitialize standard classes that were cleared).
76058:      */
76158:     if (script->hasClearedGlobal())
76058:         return;
76058: 
75987:     if (!ranSSA()) {
75987:         analyzeSSA(cx);
75987:         if (failed())
75987:             return;
75987:     }
75987: 
75987:     /*
75987:      * Set this early to avoid reentrance. Any failures are OOMs, and will nuke
75987:      * all types in the compartment.
75987:      */
75987:     ranInference_ = true;
75708: 
75987:     /* Make sure the initial type set of all local vars includes void. */
75987:     for (unsigned i = 0; i < script->nfixed; i++)
77391:         TypeScript::LocalTypes(script, i)->addType(cx, Type::UndefinedType());
75987: 
75987:     TypeInferenceState state(cx);
75768: 
75701:     unsigned offset = 0;
75701:     while (offset < script->length) {
76059:         Bytecode *code = maybeCode(offset);
75701: 
75701:         jsbytecode *pc = script->code + offset;
76059:         UntrapOpcode untrap(cx, script, pc);
75701: 
77360:         if (code && !analyzeTypesBytecode(cx, offset, state)) {
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             return;
75720:         }
75708: 
76059:         offset += GetBytecodeLength(pc);
75708:     }
75708: 
75987:     for (unsigned i = 0; i < state.phiNodes.length(); i++) {
75987:         SSAPhiNode *node = state.phiNodes[i];
75987:         for (unsigned j = 0; j < node->length; j++) {
75987:             const SSAValue &v = node->options[j];
77353:             getValueTypes(v)->addSubset(cx, &node->types);
75987:         }
75987:     }
75987: 
75718:     /*
77361:      * Replay any dynamic type results which have been generated for the script
77361:      * either because we ran the interpreter some before analyzing or because
77361:      * we are reanalyzing after a GC.
75718:      */
77391:     TypeResult *result = script->types->dynamicList;
75718:     while (result) {
77399:         if (result->offset != uint32(-1)) {
77361:             pushedTypes(result->offset)->addType(cx, result->type);
77399:         } else {
77399:             /* Custom for-in loop iteration has happened in this script. */
77399:             state.forTypes->addType(cx, Type::UnknownType());
77399:         }
75718:         result = result->next;
75718:     }
76128: 
77374:     if (!script->usesArguments || script->createdArgs)
76128:         return;
76128: 
76128:     /*
76128:      * Do additional analysis to determine whether the arguments object in the
76128:      * script can escape.
76128:      */
76128: 
76128:     /*
76128:      * Note: don't check for strict mode code here, even though arguments
76128:      * accesses in such scripts will always be deoptimized. These scripts can
76128:      * have a JSOP_ARGUMENTS in their prologue which the usesArguments check
76128:      * above does not account for. We filter in the interpreter and JITs
76128:      * themselves.
76128:      */
77434:     if (script->function()->isHeavyweight() || cx->compartment->debugMode() || localsAliasStack()) {
77361:         MarkArgumentsCreated(cx, script);
76128:         return;
76128:     }
76128: 
76128:     offset = 0;
76128:     while (offset < script->length) {
76128:         Bytecode *code = maybeCode(offset);
76128:         jsbytecode *pc = script->code + offset;
76128: 
76128:         if (code && JSOp(*pc) == JSOP_ARGUMENTS) {
76128:             Vector<SSAValue> seen(cx);
76128:             if (!followEscapingArguments(cx, SSAValue::PushedValue(offset, 0), &seen)) {
77361:                 MarkArgumentsCreated(cx, script);
76128:                 return;
76128:             }
76128:         }
76128: 
76128:         offset += GetBytecodeLength(pc);
76128:     }
76128: 
76128:     /*
76128:      * The VM is now free to use the arguments in this script lazily. If we end
76128:      * up creating an arguments object for the script in the future or regard
76128:      * the arguments as escaping, we need to walk the stack and replace lazy
76128:      * arguments objects with actual arguments objects.
76128:      */
76128:     script->usedLazyArgs = true;
76128: }
76128: 
76128: bool
76128: ScriptAnalysis::followEscapingArguments(JSContext *cx, const SSAValue &v, Vector<SSAValue> *seen)
76128: {
76128:     /*
76128:      * trackUseChain is false for initial values of variables, which
76128:      * cannot hold the script's arguments object.
76128:      */
76128:     if (!trackUseChain(v))
76128:         return true;
76128: 
76128:     for (unsigned i = 0; i < seen->length(); i++) {
76128:         if (v.equals((*seen)[i]))
76128:             return true;
76128:     }
76128:     if (!seen->append(v)) {
76128:         cx->compartment->types.setPendingNukeTypes(cx);
76128:         return false;
76128:     }
76128: 
76128:     SSAUseChain *use = useChain(v);
76128:     while (use) {
76128:         if (!followEscapingArguments(cx, use, seen))
76128:             return false;
76128:         use = use->next;
76128:     }
76128: 
76128:     return true;
76128: }
76128: 
76128: bool
76128: ScriptAnalysis::followEscapingArguments(JSContext *cx, SSAUseChain *use, Vector<SSAValue> *seen)
76128: {
76131:     if (!use->popped)
76131:         return followEscapingArguments(cx, SSAValue::PhiValue(use->offset, use->u.phi), seen);
76128: 
76128:     jsbytecode *pc = script->code + use->offset;
76128:     uint32 which = use->u.which;
76128: 
76134:     JSOp op = JSOp(*pc);
76134:     JS_ASSERT(op != JSOP_TRAP);
76134: 
76134:     if (op == JSOP_POP || op == JSOP_POPN)
76134:         return true;
76134: 
76128:     /* Allow GETELEM and LENGTH on arguments objects that don't escape. */
76128: 
76128:     /*
76128:      * Note: if the element index is not an integer we will mark the arguments
76128:      * as escaping at the access site.
76128:      */
76134:     if (op == JSOP_GETELEM && which == 1)
76128:         return true;
76128: 
76134:     if (op == JSOP_LENGTH)
76128:         return true;
76128: 
76128:     /* Allow assignments to non-closed locals (but not arguments). */
76128: 
76134:     if (op == JSOP_SETLOCAL) {
76128:         uint32 slot = GetBytecodeSlot(script, pc);
76135:         if (!trackSlot(slot))
76128:             return false;
76134:         if (!followEscapingArguments(cx, SSAValue::PushedValue(use->offset, 0), seen))
76134:             return false;
76128:         return followEscapingArguments(cx, SSAValue::WrittenVar(slot, use->offset), seen);
76128:     }
76128: 
76134:     if (op == JSOP_GETLOCAL)
76128:         return followEscapingArguments(cx, SSAValue::PushedValue(use->offset, 0), seen);
76128: 
76128:     return false;
75708: }
75708: 
76059: /*
76059:  * Persistent constraint clearing out newScript and definite properties from
76059:  * an object should a property on another object get a setter.
76059:  */
76059: class TypeConstraintClearDefiniteSetter : public TypeConstraint
76059: {
76059: public:
76059:     TypeObject *object;
76059: 
76059:     TypeConstraintClearDefiniteSetter(TypeObject *object)
77361:         : TypeConstraint("clearDefiniteSetter"), object(object)
76059:     {}
76059: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type) {
76059:         if (!object->newScript)
76059:             return;
76059:         /*
76059:          * Clear out the newScript shape and definite property information from
76059:          * an object if the source type set could be a setter (its type set
76059:          * becomes unknown).
76059:          */
77361:         if (!(object->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED) && type.isUnknown())
76059:             object->clearNewScript(cx);
76059:     }
76059: };
76059: 
76059: /*
76059:  * Constraint which clears definite properties on an object should a type set
76059:  * contain any types other than a single object.
76059:  */
76059: class TypeConstraintClearDefiniteSingle : public TypeConstraint
76059: {
76059: public:
76059:     TypeObject *object;
76059: 
77353:     TypeConstraintClearDefiniteSingle(TypeObject *object)
77361:         : TypeConstraint("clearDefiniteSingle"), object(object)
76059:     {}
76059: 
77353:     void newType(JSContext *cx, TypeSet *source, Type type) {
77361:         if (object->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED)
77353:             return;
77353: 
77353:         if (source->baseFlags() || source->getObjectCount() > 1)
76059:             object->clearNewScript(cx);
76059:     }
76059: };
76059: 
76059: static bool
76059: AnalyzeNewScriptProperties(JSContext *cx, TypeObject *type, JSScript *script, JSObject **pbaseobj,
76059:                            Vector<TypeNewScript::Initializer> *initializerList)
75948: {
75948:     /*
75948:      * When invoking 'new' on the specified script, try to find some properties
75948:      * which will definitely be added to the created object before it has a
76059:      * chance to escape and be accessed elsewhere.
76059:      *
76059:      * Returns true if the entire script was analyzed (pbaseobj has been
76059:      * preserved), false if we had to bail out part way through (pbaseobj may
76059:      * have been cleared).
75948:      */
75948: 
76089:     if (initializerList->length() > 50) {
76089:         /*
76089:          * Bail out on really long initializer lists (far longer than maximum
76089:          * number of properties we can track), we may be recursing.
76089:          */
76089:         return false;
76089:     }
76089: 
77630:     if (script->hasClearedGlobal())
77630:         return false;
77630: 
76158:     if (!script->ensureRanInference(cx)) {
76059:         *pbaseobj = NULL;
76059:         cx->compartment->types.setPendingNukeTypes(cx);
76059:         return false;
76059:     }
77391:     ScriptAnalysis *analysis = script->analysis();
76059: 
76059:     /*
76059:      * Offset of the last bytecode which popped 'this' and which we have
76059:      * processed. For simplicity, we scan for places where 'this' is pushed
76059:      * and immediately analyze the place where that pushed value is popped.
76059:      * This runs the risk of doing things out of order, if the script looks
76059:      * something like 'this.f  = (this.g = ...)', so we watch and bail out if
76059:      * a 'this' is pushed before the previous 'this' value was popped.
76059:      */
76059:     uint32 lastThisPopped = 0;
76059: 
76059:     unsigned nextOffset = 0;
76059:     while (nextOffset < script->length) {
76059:         unsigned offset = nextOffset;
75948:         jsbytecode *pc = script->code + offset;
76095:         UntrapOpcode untrap(cx, script, pc);
76095: 
75948:         JSOp op = JSOp(*pc);
75948: 
76059:         nextOffset += GetBytecodeLength(pc);
76059: 
76060:         Bytecode *code = analysis->maybeCode(pc);
76060:         if (!code)
76060:             continue;
76060: 
76060:         /*
76060:          * End analysis after the first return statement from the script,
76060:          * returning success if the return is unconditional.
76060:          */
76060:         if (op == JSOP_RETURN || op == JSOP_STOP || op == JSOP_RETRVAL) {
76060:             if (offset < lastThisPopped) {
76060:                 *pbaseobj = NULL;
76060:                 return false;
76060:             }
76060:             return code->unconditional;
76060:         }
76060: 
76059:         /* 'this' can escape through a call to eval. */
76060:         if (op == JSOP_EVAL) {
76060:             if (offset < lastThisPopped)
76060:                 *pbaseobj = NULL;
76059:             return false;
76060:         }
76059: 
75948:         /*
76059:          * We are only interested in places where 'this' is popped. The new
76059:          * 'this' value cannot escape and be accessed except through such uses.
75948:          */
76059:         if (op != JSOP_THIS)
76059:             continue;
76059: 
76059:         SSAValue thisv = SSAValue::PushedValue(offset, 0);
76059:         SSAUseChain *uses = analysis->useChain(thisv);
76059: 
76059:         JS_ASSERT(uses);
76059:         if (uses->next || !uses->popped) {
76059:             /* 'this' value popped in more than one place. */
76059:             return false;
76059:         }
76059: 
76059:         /* Maintain ordering property on how 'this' is used, as described above. */
76059:         if (offset < lastThisPopped) {
76059:             *pbaseobj = NULL;
76059:             return false;
76059:         }
76059:         lastThisPopped = uses->offset;
76059: 
76060:         /* Only handle 'this' values popped in unconditional code. */
76060:         Bytecode *poppedCode = analysis->maybeCode(uses->offset);
76060:         if (!poppedCode || !poppedCode->unconditional)
76060:             return false;
76060: 
76059:         pc = script->code + uses->offset;
76095:         UntrapOpcode untrapUse(cx, script, pc);
76095: 
76059:         op = JSOp(*pc);
76059: 
76059:         JSObject *obj = *pbaseobj;
76059: 
76059:         if (op == JSOP_SETPROP && uses->u.which == 1) {
76141:             /*
76141:              * Don't use GetAtomId here, we need to watch for SETPROP on
76141:              * integer properties and bail out. We can't mark the aggregate
76141:              * JSID_VOID type property as being in a definite slot.
76141:              */
76141:             unsigned index = js_GetIndexFromBytecode(cx, script, pc, 0);
76141:             jsid id = ATOM_TO_JSID(script->getAtom(index));
76059:             if (MakeTypeId(cx, id) != id)
76059:                 return false;
75948:             if (id == id_prototype(cx) || id == id___proto__(cx) || id == id_constructor(cx))
76059:                 return false;
76059: 
76059:             unsigned slotSpan = obj->slotSpan();
76072:             if (!DefineNativeProperty(cx, obj, id, UndefinedValue(), NULL, NULL,
76087:                                       JSPROP_ENUMERATE, 0, 0, DNP_SKIP_TYPE)) {
76059:                 cx->compartment->types.setPendingNukeTypes(cx);
76059:                 *pbaseobj = NULL;
76059:                 return false;
76059:             }
76059: 
76059:             if (obj->inDictionaryMode()) {
76059:                 *pbaseobj = NULL;
76059:                 return false;
76059:             }
76059: 
76059:             if (obj->slotSpan() == slotSpan) {
75948:                 /* Set a duplicate property. */
76059:                 return false;
76059:             }
76059: 
76059:             TypeNewScript::Initializer setprop(TypeNewScript::Initializer::SETPROP, uses->offset);
76059:             if (!initializerList->append(setprop)) {
76059:                 cx->compartment->types.setPendingNukeTypes(cx);
76059:                 *pbaseobj = NULL;
76059:                 return false;
76059:             }
76059: 
76059:             if (obj->slotSpan() >= (TYPE_FLAG_DEFINITE_MASK >> TYPE_FLAG_DEFINITE_SHIFT)) {
75948:                 /* Maximum number of definite properties added. */
76059:                 return false;
76059:             }
76059: 
76059:             /*
76059:              * Ensure that if the properties named here could have a setter in
76059:              * the direct prototype (and thus its transitive prototypes), the
76059:              * definite properties get cleared from the shape.
76059:              */
77361:             TypeObject *parentObject = type->proto->getType(cx);
77361:             if (parentObject->unknownProperties())
77361:                 return false;
77361:             TypeSet *parentTypes = parentObject->getProperty(cx, id, false);
76059:             if (!parentTypes || parentTypes->unknown())
76059:                 return false;
77361:             parentObject->getFromPrototypes(cx, id, parentTypes);
77361:             parentTypes->add(cx,
77361:                 ArenaNew<TypeConstraintClearDefiniteSetter>(cx->compartment->pool, type));
76059:         } else if (op == JSOP_FUNCALL && uses->u.which == GET_ARGC(pc) - 1) {
76059:             /*
76059:              * Passed as the first parameter to Function.call. Follow control
76059:              * into the callee, and add any definite properties it assigns to
76059:              * the object as well. :TODO: This is narrow pattern matching on
76059:              * the inheritance patterns seen in the v8-deltablue benchmark, and
76059:              * needs robustness against other ways initialization can cross
76059:              * script boundaries.
76059:              *
76059:              * Add constraints ensuring we are calling Function.call on a
76059:              * particular script, removing definite properties from the result
76059:              */
76059: 
76059:             /* Callee/this must have been pushed by a CALLPROP. */
76059:             SSAValue calleev = analysis->poppedValue(pc, GET_ARGC(pc) + 1);
76095:             if (calleev.kind() != SSAValue::PUSHED)
76059:                 return false;
76095:             jsbytecode *calleepc = script->code + calleev.pushedOffset();
76095:             UntrapOpcode untrapCallee(cx, script, calleepc);
76095:             if (JSOp(*calleepc) != JSOP_CALLPROP || calleev.pushedIndex() != 0)
76095:                 return false;
76095: 
76103:             /*
76103:              * This code may not have run yet, break any type barriers involved
76103:              * in performing the call (for the greater good!).
76103:              */
76103:             analysis->breakTypeBarriersSSA(cx, analysis->poppedValue(calleepc, 0));
76103:             analysis->breakTypeBarriers(cx, calleepc - script->code, true);
76103: 
76095:             TypeSet *funcallTypes = analysis->pushedTypes(calleepc, 0);
76095:             TypeSet *scriptTypes = analysis->pushedTypes(calleepc, 1);
76059: 
76059:             /* Need to definitely be calling Function.call on a specific script. */
77353:             JSObject *funcallObj = funcallTypes->getSingleton(cx, false);
77353:             JSObject *scriptObj = scriptTypes->getSingleton(cx, false);
77353:             if (!funcallObj || !scriptObj || !scriptObj->isFunction() ||
77353:                 !scriptObj->getFunctionPrivate()->isInterpreted()) {
76059:                 return false;
76059:             }
77353: 
77353:             JSScript *functionScript = scriptObj->getFunctionPrivate()->script();
76059: 
76059:             /*
76103:              * Generate constraints to clear definite properties from the type
76059:              * should the Function.call or callee itself change in the future.
76059:              */
77361:             analysis->pushedTypes(calleev.pushedOffset(), 0)->add(cx,
77361:                 ArenaNew<TypeConstraintClearDefiniteSingle>(cx->compartment->pool, type));
77361:             analysis->pushedTypes(calleev.pushedOffset(), 1)->add(cx,
77361:                 ArenaNew<TypeConstraintClearDefiniteSingle>(cx->compartment->pool, type));
76059: 
76059:             TypeNewScript::Initializer pushframe(TypeNewScript::Initializer::FRAME_PUSH, uses->offset);
76059:             if (!initializerList->append(pushframe)) {
76059:                 cx->compartment->types.setPendingNukeTypes(cx);
76059:                 *pbaseobj = NULL;
76059:                 return false;
76059:             }
76059: 
77353:             if (!AnalyzeNewScriptProperties(cx, type, functionScript,
76059:                                             pbaseobj, initializerList)) {
76059:                 return false;
76059:             }
76059: 
76059:             TypeNewScript::Initializer popframe(TypeNewScript::Initializer::FRAME_POP, 0);
76059:             if (!initializerList->append(popframe)) {
76059:                 cx->compartment->types.setPendingNukeTypes(cx);
76059:                 *pbaseobj = NULL;
76059:                 return false;
76059:             }
76059: 
76059:             /*
76059:              * The callee never lets the 'this' value escape, continue looking
76059:              * for definite properties in the remainder of this script.
76059:              */
76059:         } else {
76059:             /* Unhandled use of 'this'. */
76059:             return false;
76059:         }
76059:     }
76059: 
76076:     /* Will have hit a STOP or similar, unless the script always throws. */
76059:     return true;
75948: }
75948: 
77361: /*
77361:  * Either make the newScript information for type when it is constructed
77361:  * by the specified script, or regenerate the constraints for an existing
77361:  * newScript on the type after they were cleared by a GC.
77361:  */
77361: static void
77361: CheckNewScriptProperties(JSContext *cx, TypeObject *type, JSScript *script)
76151: {
76151:     if (type->unknownProperties())
76151:         return;
76151: 
76151:     /* Strawman object to add properties to and watch for duplicates. */
76151:     JSObject *baseobj = NewBuiltinClassInstance(cx, &js_ObjectClass, gc::FINALIZE_OBJECT16);
77361:     if (!baseobj) {
77361:         if (type->newScript)
77361:             type->clearNewScript(cx);
76151:         return;
77361:     }
76151: 
76151:     Vector<TypeNewScript::Initializer> initializerList(cx);
76151:     AnalyzeNewScriptProperties(cx, type, script, &baseobj, &initializerList);
77361:     if (!baseobj || baseobj->slotSpan() == 0 || !!(type->flags & OBJECT_FLAG_NEW_SCRIPT_CLEARED)) {
77361:         if (type->newScript)
77361:             type->clearNewScript(cx);
76151:         return;
77361:     }
77361: 
77361:     /*
77361:      * If the type already has a new script, we are just regenerating the type
77361:      * constraints and don't need to make another TypeNewScript. Make sure that
77361:      * the properties added to baseobj match the type's definite properties.
77361:      */
77361:     if (type->newScript) {
77361:         if (!type->matchDefiniteProperties(baseobj))
77361:             type->clearNewScript(cx);
77361:         return;
77361:     }
76151: 
76151:     gc::FinalizeKind kind = gc::GetGCObjectKind(baseobj->slotSpan());
76151: 
76151:     /* We should not have overflowed the maximum number of fixed slots for an object. */
76151:     JS_ASSERT(gc::GetGCKindSlots(kind) >= baseobj->slotSpan());
76151: 
76151:     TypeNewScript::Initializer done(TypeNewScript::Initializer::DONE, 0);
76151: 
76151:     /*
77392:      * The base object may have been created with a different finalize kind
77392:      * than we will use for subsequent new objects. Generate an object with the
77392:      * appropriate final shape.
76151:      */
76151:     baseobj = NewReshapedObject(cx, type, baseobj->getParent(), kind,
76151:                                 baseobj->lastProperty());
76151:     if (!baseobj ||
76151:         !type->addDefiniteProperties(cx, baseobj) ||
76151:         !initializerList.append(done)) {
76151:         cx->compartment->types.setPendingNukeTypes(cx);
76151:         return;
76151:     }
76151: 
76151:     size_t numBytes = sizeof(TypeNewScript)
76151:                     + (initializerList.length() * sizeof(TypeNewScript::Initializer));
76151:     type->newScript = (TypeNewScript *) cx->calloc_(numBytes);
76151:     if (!type->newScript) {
76151:         cx->compartment->types.setPendingNukeTypes(cx);
76151:         return;
76151:     }
76151: 
76151:     type->newScript->script = script;
76151:     type->newScript->finalizeKind = unsigned(kind);
76151:     type->newScript->shape = baseobj->lastProperty();
76151: 
76151:     type->newScript->initializerList = (TypeNewScript::Initializer *)
76151:         ((char *) type->newScript + sizeof(TypeNewScript));
76151:     PodCopy(type->newScript->initializerList, initializerList.begin(), initializerList.length());
76151: }
76151: 
75615: /////////////////////////////////////////////////////////////////////
75615: // Printing
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: void
76059: ScriptAnalysis::printTypes(JSContext *cx)
75615: {
75987:     AutoEnterAnalysis enter(cx);
75615:     TypeCompartment *compartment = &script->compartment->types;
75615: 
75615:     /*
75615:      * Check if there are warnings for used values with unknown types, and build
75615:      * statistics about the size of type sets found for stack values.
75615:      */
75615:     for (unsigned offset = 0; offset < script->length; offset++) {
75987:         if (!maybeCode(offset))
75615:             continue;
75615: 
76095:         jsbytecode *pc = script->code + offset;
76095:         UntrapOpcode untrap(cx, script, pc);
76095: 
77357:         if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
77357:             continue;
77357: 
76059:         unsigned defCount = GetDefCount(script, offset);
75708:         if (!defCount)
75615:             continue;
75615: 
75708:         for (unsigned i = 0; i < defCount; i++) {
75987:             TypeSet *types = pushedTypes(offset, i);
75615: 
76019:             if (types->unknown()) {
76019:                 compartment->typeCountOver++;
76019:                 continue;
76019:             }
76019: 
77353:             unsigned typeCount = 0;
77353: 
77353:             if (types->hasAnyFlag(TYPE_FLAG_ANYOBJECT) || types->getObjectCount() != 0)
77353:                 typeCount++;
77353:             for (TypeFlags flag = 1; flag < TYPE_FLAG_ANYOBJECT; flag <<= 1) {
77353:                 if (types->hasAnyFlag(flag))
75615:                     typeCount++;
75615:             }
75615: 
75615:             /*
75615:              * Adjust the type counts for floats: values marked as floats
75615:              * are also marked as ints by the inference, but for counting
75615:              * we don't consider these to be separate types.
75615:              */
75919:             if (types->hasAnyFlag(TYPE_FLAG_DOUBLE)) {
75919:                 JS_ASSERT(types->hasAnyFlag(TYPE_FLAG_INT32));
75615:                 typeCount--;
75615:             }
75615: 
76019:             if (typeCount > TypeCompartment::TYPE_COUNT_LIMIT) {
75615:                 compartment->typeCountOver++;
75615:             } else if (typeCount == 0) {
75615:                 /* Ignore values without types, this may be unreached code. */
75615:             } else {
75615:                 compartment->typeCounts[typeCount-1]++;
75615:             }
75615:         }
75615:     }
75615: 
75640: #ifdef DEBUG
75640: 
77391:     if (script->hasFunction)
75638:         printf("Function");
77446:     else if (script->isCachedEval)
75718:         printf("Eval");
75615:     else
75718:         printf("Main");
75789:     printf(" #%u %s (line %d):\n", script->id(), script->filename, script->lineno);
75718: 
75718:     printf("locals:");
75718:     printf("\n    return:");
77391:     TypeScript::ReturnTypes(script)->print(cx);
75718:     printf("\n    this:");
77391:     TypeScript::ThisTypes(script)->print(cx);
77391: 
77391:     for (unsigned i = 0; script->hasFunction && i < script->function()->nargs; i++) {
75708:         printf("\n    arg%u:", i);
77391:         TypeScript::ArgTypes(script, i)->print(cx);
75641:     }
75708:     for (unsigned i = 0; i < script->nfixed; i++) {
75987:         if (!trackSlot(LocalSlot(script, i))) {
75708:             printf("\n    local%u:", i);
77391:             TypeScript::LocalTypes(script, i)->print(cx);
75718:         }
75987:     }
75641:     printf("\n");
75615: 
75615:     for (unsigned offset = 0; offset < script->length; offset++) {
75987:         if (!maybeCode(offset))
75615:             continue;
75615: 
76095:         jsbytecode *pc = script->code + offset;
76095:         UntrapOpcode untrap(cx, script, pc);
76095: 
76095:         PrintBytecode(cx, script, pc);
76095: 
77357:         if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
77357:             continue;
77357: 
76095:         if (js_CodeSpec[*pc].format & JOF_TYPESET) {
77391:             TypeSet *types = script->analysis()->bytecodeTypes(pc);
77391:             printf("  typeset %d:", (int) (types - script->types->typeArray()));
76061:             types->print(cx);
76061:             printf("\n");
76061:         }
76061: 
76059:         unsigned defCount = GetDefCount(script, offset);
75708:         for (unsigned i = 0; i < defCount; i++) {
75708:             printf("  type %d:", i);
75987:             pushedTypes(offset, i)->print(cx);
75638:             printf("\n");
75615:         }
75615: 
76061:         if (getCode(offset).monitoredTypes)
75638:             printf("  monitored\n");
76061: 
76087:         TypeBarrier *barrier = getCode(offset).typeBarriers;
76087:         if (barrier != NULL) {
76087:             printf("  barrier:");
76087:             while (barrier) {
76087:                 printf(" %s", TypeString(barrier->type));
76087:                 barrier = barrier->next;
76087:             }
76087:             printf("\n");
76087:         }
75615:     }
75615: 
75638:     printf("\n");
75615: 
75640: #endif /* DEBUG */
75640: 
75615: }
75615: 
75720: /////////////////////////////////////////////////////////////////////
76148: // Interface functions
76148: /////////////////////////////////////////////////////////////////////
76148: 
76158: namespace js {
76158: namespace types {
76148: 
76148: void
76175: MarkIteratorUnknownSlow(JSContext *cx)
76148: {
76175:     /* Check whether we are actually at an ITER opcode. */
76148: 
76157:     jsbytecode *pc;
76157:     JSScript *script = cx->stack.currentScript(&pc);
76168:     if (!script || !pc)
76148:         return;
76148: 
77399:     UntrapOpcode untrap(cx, script, pc);
77399: 
77399:     if (JSOp(*pc) != JSOP_ITER)
77399:         return;
77399: 
77399:     AutoEnterTypeInference enter(cx);
77399: 
76148:     /*
77399:      * This script is iterating over an actual Iterator or Generator object, or
77399:      * an object with a custom __iterator__ hook. In such cases 'for in' loops
77399:      * can produce values other than strings, and the types of the ITER opcodes
77399:      * in the script need to be updated. During analysis this is done with the
77399:      * forTypes in the analysis state, but we don't keep a pointer to this type
77399:      * set and need to scan the script to fix affected opcodes.
76148:      */
77399: 
77399:     TypeResult *result = script->types->dynamicList;
77399:     while (result) {
77399:         if (result->offset == uint32(-1)) {
77399:             /* Already know about custom iterators used in this script. */
77399:             JS_ASSERT(result->type.isUnknown());
76148:             return;
77399:         }
77404:         result = result->next;
77399:     }
77399: 
77399:     InferSpew(ISpewOps, "externalType: customIterator #%u", script->id());
77399: 
77399:     result = cx->new_<TypeResult>(uint32(-1), Type::UnknownType());
77399:     if (!result) {
77399:         cx->compartment->types.setPendingNukeTypes(cx);
77399:         return;
77399:     }
77399:     result->next = script->types->dynamicList;
77399:     script->types->dynamicList = result;
77399: 
77399:     if (!script->hasAnalysis() || !script->analysis()->ranInference())
77399:         return;
77399: 
77399:     ScriptAnalysis *analysis = script->analysis();
77399: 
77399:     for (unsigned i = 0; i < script->length; i++) {
77399:         jsbytecode *pc = script->code + i;
77399:         if (!analysis->maybeCode(pc))
77399:             continue;
77399:         if (js_GetOpcode(cx, script, pc) == JSOP_ITERNEXT)
77399:             analysis->pushedTypes(pc, 0)->addType(cx, Type::UnknownType());
77399:     }
77399: 
77399:     /* Trigger recompilation of any inline callers. */
77399:     if (script->hasFunction && !script->function()->hasLazyType())
77399:         ObjectStateChange(cx, script->function()->type(), false, true);
76148: }
76148: 
76148: void
76148: TypeMonitorCallSlow(JSContext *cx, JSObject *callee,
76148:                     const CallArgs &args, bool constructing)
76148: {
76148:     unsigned nargs = callee->getFunctionPrivate()->nargs;
76148:     JSScript *script = callee->getFunctionPrivate()->script();
76148: 
77391:     if (!constructing)
77391:         TypeScript::SetThis(cx, script, args.thisv());
76148: 
76148:     /*
76148:      * Add constraints going up to the minimum of the actual and formal count.
76148:      * If there are more actuals than formals the later values can only be
76148:      * accessed through the arguments object, which is monitored.
76148:      */
76148:     unsigned arg = 0;
76148:     for (; arg < args.argc() && arg < nargs; arg++)
77391:         TypeScript::SetArgument(cx, script, arg, args[arg]);
76148: 
76148:     /* Watch for fewer actuals than formals to the call. */
76148:     for (; arg < nargs; arg++)
77391:         TypeScript::SetArgument(cx, script, arg, UndefinedValue());
76148: }
76148: 
77353: static inline bool
77353: IsAboutToBeFinalized(JSContext *cx, TypeObjectKey *key)
77353: {
77361:     /* Mask out the low bit indicating whether this is a type or JS object. */
77361:     return !reinterpret_cast<const gc::Cell *>((jsuword) key & ~1)->isMarked();
77361: }
76148: 
76148: void
77353: TypeDynamicResult(JSContext *cx, JSScript *script, jsbytecode *pc, Type type)
76148: {
76148:     JS_ASSERT(cx->typeInferenceEnabled());
76148:     AutoEnterTypeInference enter(cx);
76148: 
76148:     UntrapOpcode untrap(cx, script, pc);
76148: 
76148:     /* Directly update associated type sets for applicable bytecodes. */
76175:     if (js_CodeSpec[*pc].format & JOF_TYPESET) {
77391:         if (!script->ensureRanBytecode(cx)) {
77391:             cx->compartment->types.setPendingNukeTypes(cx);
77391:             return;
77391:         }
77391:         TypeSet *types = script->analysis()->bytecodeTypes(pc);
76148:         if (!types->hasType(type)) {
76148:             InferSpew(ISpewOps, "externalType: monitorResult #%u:%05u: %s",
76148:                       script->id(), pc - script->code, TypeString(type));
76148:             types->addType(cx, type);
76148:         }
76148:         return;
76148:     }
76148: 
76148:     /*
76148:      * For inc/dec ops, we need to go back and reanalyze the affected opcode
76148:      * taking the overflow into account. We won't see an explicit adjustment
76148:      * of the type of the thing being inc/dec'ed, nor will adding TYPE_DOUBLE to
77357:      * the pushed value affect that type.
76148:      */
76148:     JSOp op = JSOp(*pc);
76148:     const JSCodeSpec *cs = &js_CodeSpec[op];
76148:     if (cs->format & (JOF_INC | JOF_DEC)) {
76148:         switch (op) {
76148:           case JSOP_INCLOCAL:
76148:           case JSOP_DECLOCAL:
76148:           case JSOP_LOCALINC:
76148:           case JSOP_LOCALDEC:
76148:           case JSOP_INCARG:
76148:           case JSOP_DECARG:
76148:           case JSOP_ARGINC:
76148:           case JSOP_ARGDEC: {
76148:             /*
76148:              * Just mark the slot's type as holding the new type. This captures
76148:              * the effect if the slot is not being tracked, and if the slot
76148:              * doesn't escape we will update the pushed types below to capture
76148:              * the slot's value after this write.
76148:              */
76148:             uint32 slot = GetBytecodeSlot(script, pc);
76148:             if (slot < TotalSlots(script)) {
77391:                 TypeSet *types = TypeScript::SlotTypes(script, slot);
76148:                 types->addType(cx, type);
76148:             }
76148:             break;
76148:           }
76148: 
76148:           default:;
76148:         }
76148:     }
76148: 
77391:     if (script->hasAnalysis() && script->analysis()->ranInference()) {
76148:         /*
76148:          * If the pushed set already has this type, we don't need to ensure
76148:          * there is a TypeIntermediate. Either there already is one, or the
76148:          * type could be determined from the script's other input type sets.
76148:          */
77391:         TypeSet *pushed = script->analysis()->pushedTypes(pc, 0);
76148:         if (pushed->hasType(type))
76148:             return;
76148:     } else {
76148:         /* Scan all intermediate types on the script to check for a dupe. */
77391:         TypeResult *result, **pstart = &script->types->dynamicList, **presult = pstart;
76148:         while (*presult) {
76148:             result = *presult;
77361:             if (result->offset == unsigned(pc - script->code) && result->type == type) {
76158:                 if (presult != pstart) {
76148:                     /* Move to the head of the list, maintain LRU order. */
76148:                     *presult = result->next;
76158:                     result->next = *pstart;
76158:                     *pstart = result;
76148:                 }
76148:                 return;
76148:             }
76148:             presult = &result->next;
76148:         }
76148:     }
76148: 
76148:     InferSpew(ISpewOps, "externalType: monitorResult #%u:%05u: %s",
76148:               script->id(), pc - script->code, TypeString(type));
76148: 
77361:     TypeResult *result = cx->new_<TypeResult>(pc - script->code, type);
76148:     if (!result) {
76148:         cx->compartment->types.setPendingNukeTypes(cx);
76148:         return;
76148:     }
77391:     result->next = script->types->dynamicList;
77391:     script->types->dynamicList = result;
77391: 
77391:     if (script->hasAnalysis() && script->analysis()->ranInference()) {
77391:         TypeSet *pushed = script->analysis()->pushedTypes(pc, 0);
76148:         pushed->addType(cx, type);
76148:     }
76148: 
76148:     /* Trigger recompilation of any inline callers. */
77391:     if (script->hasFunction && !script->function()->hasLazyType())
77391:         ObjectStateChange(cx, script->function()->type(), false, true);
76148: }
76148: 
76148: void
76148: TypeMonitorResult(JSContext *cx, JSScript *script, jsbytecode *pc, const js::Value &rval)
76148: {
76148:     UntrapOpcode untrap(cx, script, pc);
76148: 
77357:     /* Allow the non-TYPESET scenario to simplify stubs used in compound opcodes. */
76148:     if (!(js_CodeSpec[*pc].format & JOF_TYPESET))
76148:         return;
76148: 
77391:     AutoEnterTypeInference enter(cx);
77391: 
77391:     if (!script->ensureRanBytecode(cx)) {
77391:         cx->compartment->types.setPendingNukeTypes(cx);
77391:         return;
77391:     }
77391: 
77353:     Type type = GetValueType(cx, rval);
77391:     TypeSet *types = script->analysis()->bytecodeTypes(pc);
76148:     if (types->hasType(type))
76148:         return;
76148: 
76148:     InferSpew(ISpewOps, "bytecodeType: #%u:%05u: %s",
76148:               script->id(), pc - script->code, TypeString(type));
76148:     types->addType(cx, type);
76148: }
76148: 
76148: } } /* namespace js::types */
76148: 
76148: /////////////////////////////////////////////////////////////////////
76158: // TypeScript
75720: /////////////////////////////////////////////////////////////////////
75720: 
75708: /*
75708:  * Returns true if we don't expect to compute the correct types for some value
75708:  * pushed by the specified bytecode.
75708:  */
75708: static inline bool
76020: IgnorePushed(const jsbytecode *pc, unsigned index)
75708: {
76095:     JS_ASSERT(JSOp(*pc) != JSOP_TRAP);
76095: 
76020:     switch (JSOp(*pc)) {
75708:       /* We keep track of the scopes pushed by BINDNAME separately. */
75708:       case JSOP_BINDNAME:
75708:       case JSOP_BINDGNAME:
75708:       case JSOP_BINDXMLNAME:
75708:         return true;
75708: 
75708:       /* Stack not consistent in TRY_BRANCH_AFTER_COND. */
75708:       case JSOP_IN:
75708:       case JSOP_EQ:
75708:       case JSOP_NE:
75708:       case JSOP_LT:
75708:       case JSOP_LE:
75708:       case JSOP_GT:
75708:       case JSOP_GE:
75708:         return (index == 0);
75708: 
75708:       /* Value not determining result is not pushed by OR/AND. */
75708:       case JSOP_OR:
75708:       case JSOP_ORX:
75708:       case JSOP_AND:
75708:       case JSOP_ANDX:
75708:         return (index == 0);
75708: 
75708:       /* Holes tracked separately. */
75708:       case JSOP_HOLE:
75708:         return (index == 0);
75708:       case JSOP_FILTER:
75708:         return (index == 1);
75708: 
75708:       /* Storage for 'with' and 'let' blocks not monitored. */
75708:       case JSOP_ENTERWITH:
75708:       case JSOP_ENTERBLOCK:
75708:         return true;
75708: 
75708:       /* We don't keep track of the iteration state for 'for in' or 'for each in' loops. */
75708:       case JSOP_ITER:
77363:       case JSOP_ITERNEXT:
75708:       case JSOP_MOREITER:
75708:       case JSOP_ENDITER:
75708:         return true;
75708: 
77357:       /* Ops which can manipulate values pushed by opcodes we don't model. */
75708:       case JSOP_DUP:
75708:       case JSOP_DUP2:
77357:       case JSOP_SWAP:
77357:       case JSOP_PICK:
75708:         return true;
75708: 
75708:       /* We don't keep track of state indicating whether there is a pending exception. */
75708:       case JSOP_FINALLY:
75708:         return true;
75708: 
76020:       /*
76020:        * We don't treat GETLOCAL immediately followed by a pop as a use-before-def,
76020:        * and while the type will have been inferred correctly the method JIT
76020:        * may not have written the local's initial undefined value to the stack,
76020:        * leaving a stale value.
76020:        */
76020:       case JSOP_GETLOCAL:
76020:         return JSOp(pc[JSOP_GETLOCAL_LENGTH]) == JSOP_POP;
76020: 
75708:       default:
75708:         return false;
75708:     }
75708: }
75708: 
75718: bool
77391: JSScript::makeTypes(JSContext *cx)
75718: {
77391:     JS_ASSERT(!types);
77391: 
77391:     if (!cx->typeInferenceEnabled()) {
77391:         types = (TypeScript *) cx->calloc_(sizeof(TypeScript));
77391:         return types != NULL;
77391:     }
75718: 
76020:     AutoEnterTypeInference enter(cx);
76020: 
77391:     unsigned count = TypeScript::NumTypeSets(this);
77391:     types = (TypeScript *) cx->calloc_(sizeof(TypeScript) + (sizeof(TypeSet) * count));
77391:     if (!types) {
76158:         cx->compartment->types.setPendingNukeTypes(cx);
75718:         return false;
76020:     }
75718: 
75718: #ifdef DEBUG
77391:     TypeSet *typeArray = types->typeArray();
77391:     for (unsigned i = 0; i < nTypeSets; i++)
76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s bytecode%u #%u",
76182:                   InferSpewColor(&typeArray[i]), &typeArray[i], InferSpewColorReset(),
77391:                   i, id());
77391:     TypeSet *returnTypes = TypeScript::ReturnTypes(this);
76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s return #%u",
77391:               InferSpewColor(returnTypes), returnTypes, InferSpewColorReset(),
77391:               id());
77391:     TypeSet *thisTypes = TypeScript::ThisTypes(this);
76182:     InferSpew(ISpewOps, "typeSet: %sT%p%s this #%u",
77391:               InferSpewColor(thisTypes), thisTypes, InferSpewColorReset(),
77391:               id());
77391:     unsigned nargs = hasFunction ? function()->nargs : 0;
77391:     for (unsigned i = 0; i < nargs; i++) {
77391:         TypeSet *types = TypeScript::ArgTypes(this, i);
76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s arg%u #%u",
77391:                   InferSpewColor(types), types, InferSpewColorReset(),
77391:                   i, id());
77391:     }
77391:     for (unsigned i = 0; i < nfixed; i++) {
77391:         TypeSet *types = TypeScript::LocalTypes(this, i);
76182:         InferSpew(ISpewOps, "typeSet: %sT%p%s local%u #%u",
77391:                   InferSpewColor(types), types, InferSpewColorReset(),
77391:                   i, id());
77391:     }
75718: #endif
75718: 
75718:     return true;
75718: }
75718: 
75742: bool
77391: JSScript::makeAnalysis(JSContext *cx)
77391: {
77391:     JS_ASSERT(types && !types->analysis);
77391: 
77391:     AutoEnterAnalysis enter(cx);
77391: 
77391:     types->analysis = ArenaNew<ScriptAnalysis>(cx->compartment->pool, this);
77391: 
77391:     if (!types->analysis)
77391:         return false;
77391: 
77391:     types->analysis->analyzeBytecode(cx);
77391: 
77391:     if (types->analysis->OOM()) {
77391:         types->analysis = NULL;
77391:         return false;
77391:     }
77391: 
77391:     return true;
77391: }
77391: 
77391: bool
77353: JSScript::typeSetFunction(JSContext *cx, JSFunction *fun, bool singleton)
75742: {
77391:     hasFunction = true;
77391:     where.fun = fun;
75843: 
75843:     if (!cx->typeInferenceEnabled())
75843:         return true;
75742: 
77353:     if (singleton) {
77353:         if (!fun->setSingletonType(cx))
77353:             return false;
77353:     } else {
77461:         TypeObject *type = cx->compartment->types.newTypeObject(cx, this,
76179:                                                                 JSProto_Function, fun->getProto());
75742:         if (!type)
75742:             return false;
77353:         AutoTypeRooter root(cx, type);
77353: 
77353:         fun->setType(type);
76175:         type->functionScript = this;
77353:     }
77353: 
75742:     return true;
75742: }
75742: 
75739: #ifdef DEBUG
75739: 
77391: /* static */ void
77391: TypeScript::CheckBytecode(JSContext *cx, JSScript *script, jsbytecode *pc, const js::Value *sp)
75708: {
75987:     AutoEnterTypeInference enter(cx);
77391:     UntrapOpcode untrap(cx, script, pc);
76158: 
77357:     if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
77357:         return;
77357: 
77391:     if (!script->hasAnalysis() || !script->analysis()->ranInference())
75708:         return;
77391:     ScriptAnalysis *analysis = script->analysis();
77391: 
77391:     int defCount = GetDefCount(script, pc - script->code);
75708: 
75708:     for (int i = 0; i < defCount; i++) {
75708:         const js::Value &val = sp[-defCount + i];
76158:         TypeSet *types = analysis->pushedTypes(pc, i);
76020:         if (IgnorePushed(pc, i))
75708:             continue;
75708: 
77353:         Type type = GetValueType(cx, val);
77353: 
77353:         if (!types->hasType(type)) {
76150:             /* Display fine-grained debug information first */
76150:             fprintf(stderr, "Missing type at #%u:%05u pushed %u: %s\n", 
77391:                     script->id(), unsigned(pc - script->code), i, TypeString(type));
76150:             TypeFailure(cx, "Missing type pushed %u: %s", i, TypeString(type));
75987:         }
75708:     }
75708: }
75720: 
75739: #endif
75739: 
75720: /////////////////////////////////////////////////////////////////////
75720: // JSObject
75720: /////////////////////////////////////////////////////////////////////
75720: 
77353: bool
77353: JSObject::shouldSplicePrototype(JSContext *cx)
77353: {
77353:     /*
77353:      * During bootstrapping, if inference is enabled we need to make sure not
77353:      * to splice a new prototype in for Function.prototype or the global
77353:      * object if their __proto__ had previously been set to null, as this
77353:      * will change the prototype for all other objects with the same type.
77353:      * If inference is disabled we cannot determine from the object whether it
77353:      * has had its __proto__ set after creation.
77353:      */
77353:     if (getProto() != NULL)
77353:         return false;
77353:     return !cx->typeInferenceEnabled() || hasSingletonType();
77353: }
77353: 
77353: bool
77353: JSObject::splicePrototype(JSContext *cx, JSObject *proto)
77353: {
77353:     /*
77353:      * For singleton types representing only a single JSObject, the proto
77353:      * can be rearranged as needed without destroying type information for
77353:      * the old or new types. Note that type constraints propagating properties
77353:      * from the old prototype are not removed.
77353:      */
77353:     JS_ASSERT_IF(cx->typeInferenceEnabled(), hasSingletonType());
77353: 
77353:     /*
77353:      * Force type instantiation when splicing lazy types. This may fail,
77353:      * in which case inference will be disabled for the compartment.
77353:      */
77408:     TypeObject *type = getType(cx);
77408:     TypeObject *protoType = NULL;
77361:     if (proto) {
77408:         protoType = proto->getType(cx);
77361:         if (!proto->getNewType(cx))
77361:             return false;
77361:     }
77353: 
77353:     if (!cx->typeInferenceEnabled()) {
77361:         TypeObject *type = proto ? proto->getNewType(cx) : &emptyTypeObject;
77353:         if (!type)
77353:             return false;
77353:         type_ = type;
77353:         return true;
77353:     }
77353: 
77408:     type->proto = proto;
77353: 
77353:     AutoEnterTypeInference enter(cx);
77353: 
77408:     if (protoType && protoType->unknownProperties() && !type->unknownProperties()) {
77408:         type->markUnknown(cx);
77353:         return true;
77353:     }
77353: 
77408:     if (!type->unknownProperties()) {
77353:         /* Update properties on this type with any shared with the prototype. */
77408:         unsigned count = type->getPropertyCount();
77353:         for (unsigned i = 0; i < count; i++) {
77408:             Property *prop = type->getProperty(i);
77361:             if (prop && prop->types.hasPropagatedProperty())
77408:                 type->getFromPrototypes(cx, prop->id, &prop->types, true);
77361:         }
77353:     }
77353: 
77353:     return true;
77353: }
77353: 
75720: void
77353: JSObject::makeLazyType(JSContext *cx)
77353: {
77353:     JS_ASSERT(cx->typeInferenceEnabled() && hasLazyType());
77353:     AutoEnterTypeInference enter(cx);
77353: 
77461:     TypeObject *type = cx->compartment->types.newTypeObject(cx, NULL,
77353:                                                             JSProto_Object, getProto());
77353:     if (!type) {
77353:         cx->compartment->types.setPendingNukeTypes(cx);
77353:         return;
77353:     }
77353: 
77353:     /* Fill in the type according to the state of this object. */
77353: 
77353:     type->singleton = this;
77353: 
77361:     if (isFunction() && getFunctionPrivate() && getFunctionPrivate()->isInterpreted()) {
77353:         type->functionScript = getFunctionPrivate()->script();
77361:         if (type->functionScript->uninlineable)
77361:             type->flags |= OBJECT_FLAG_UNINLINEABLE;
77361:         if (type->functionScript->createdArgs)
77361:             type->flags |= OBJECT_FLAG_CREATED_ARGUMENTS;
77361:     }
77353: 
77386:     if (flags & ITERATED)
77386:         type->flags |= OBJECT_FLAG_ITERATED;
77386: 
77353: #if JS_HAS_XML_SUPPORT
77353:     /*
77353:      * XML objects do not have equality hooks but are treated special by EQ/NE
77353:      * ops. Just mark the type as totally unknown.
77353:      */
77353:     if (isXML() && !type->unknownProperties())
77353:         type->markUnknown(cx);
77353: #endif
77353: 
77363:     if (clasp->ext.equality)
77363:         type->flags |= OBJECT_FLAG_SPECIAL_EQUALITY;
77363: 
77353:     if (type->unknownProperties()) {
77353:         type_ = type;
77361:         flags &= ~LAZY_TYPE;
77353:         return;
77353:     }
77353: 
77353:     /* Not yet generating singleton arrays. */
77353:     type->flags |= OBJECT_FLAG_NON_DENSE_ARRAY
77353:                 |  OBJECT_FLAG_NON_PACKED_ARRAY
77353:                 |  OBJECT_FLAG_NON_TYPED_ARRAY;
77353: 
77353:     type_ = type;
77361:     flags &= ~LAZY_TYPE;
77353: }
77353: 
77353: void
77361: JSObject::makeNewType(JSContext *cx, JSScript *newScript, bool unknown)
75720: {
75720:     JS_ASSERT(!newType);
75720: 
77461:     TypeObject *type = cx->compartment->types.newTypeObject(cx, NULL,
77361:                                                             JSProto_Object, this, unknown);
75720:     if (!type)
75720:         return;
75720: 
75948:     newType = type;
75948:     setDelegate();
77392: 
77392:     if (!cx->typeInferenceEnabled())
75948:         return;
75948: 
75987:     AutoEnterTypeInference enter(cx);
75720: 
77353:     /*
77353:      * Set the special equality flag for types whose prototype also has the
77353:      * flag set. This is a hack, :XXX: need a real correspondence between
77353:      * types and the possible js::Class of objects with that type.
77353:      */
77353:     if (hasSpecialEquality())
77353:         type->flags |= OBJECT_FLAG_SPECIAL_EQUALITY;
75948: 
76151:     if (newScript)
76151:         CheckNewScriptProperties(cx, type, newScript);
75720: 
77353: #if JS_HAS_XML_SUPPORT
77353:     /* Special case for XML object equality, see makeLazyType(). */
77353:     if (isXML() && !type->unknownProperties())
77361:         type->flags |= OBJECT_FLAG_UNKNOWN_MASK;
77353: #endif
77353: 
77363:     if (clasp->ext.equality)
77363:         type->flags |= OBJECT_FLAG_SPECIAL_EQUALITY;
77363: 
77353:     /*
77353:      * The new type is not present in any type sets, so mark the object as
77353:      * unknown in all type sets it appears in. This allows the prototype of
77353:      * such objects to mutate freely without triggering an expensive walk of
77353:      * the compartment's type sets. (While scripts normally don't mutate
77353:      * __proto__, the browser will for proxies and such, and we need to
77353:      * accommodate this behavior).
77353:      */
77353:     if (type->unknownProperties())
77361:         type->flags |= OBJECT_FLAG_SETS_MARKED_UNKNOWN;
75720: }
75720: 
75720: /////////////////////////////////////////////////////////////////////
75720: // Tracing
75720: /////////////////////////////////////////////////////////////////////
75720: 
77361: void
77361: TypeSet::sweep(JSContext *cx, JSCompartment *compartment)
77353: {
77439:     /*
77439:      * Purge references to type objects that are no longer live. Type sets hold
77439:      * only weak references. For type sets containing more than one object,
77439:      * live entries in the object hash need to be copied to the compartment's
77439:      * new arena.
77439:      */
77439:     unsigned objectCount = baseObjectCount();
77353:     if (objectCount >= 2) {
77439:         unsigned oldCapacity = HashSetCapacity(objectCount);
77353:         TypeObjectKey **oldArray = objectSet;
77439: 
77439:         clearObjects();
77353:         objectCount = 0;
77439:         for (unsigned i = 0; i < oldCapacity; i++) {
77353:             TypeObjectKey *object = oldArray[i];
77439:             if (object && !IsAboutToBeFinalized(cx, object)) {
77353:                 TypeObjectKey **pentry =
77353:                     HashSetInsert<TypeObjectKey *,TypeObjectKey,TypeObjectKey>
77439:                         (compartment, objectSet, objectCount, object);
77361:                 if (pentry)
75720:                     *pentry = object;
77361:                 else
77361:                     compartment->types.setPendingNukeTypes(cx);
77361:             }
77361:         }
77361:         setBaseObjectCount(objectCount);
77353:     } else if (objectCount == 1) {
77353:         TypeObjectKey *object = (TypeObjectKey *) objectSet;
77353:         if (IsAboutToBeFinalized(cx, object)) {
77353:             objectSet = NULL;
77368:             setBaseObjectCount(0);
77353:         }
77353:     }
77353: 
77372:     /*
77372:      * All constraints are wiped out on each GC, including those propagating
77372:      * into this type set from prototype properties.
77372:      */
77353:     constraintList = NULL;
77372:     flags &= ~TYPE_FLAG_PROPAGATED_PROPERTY;
77361: }
77361: 
77361: inline void
77361: JSObject::revertLazyType()
77361: {
77361:     JS_ASSERT(hasSingletonType() && !hasLazyType());
77361:     JS_ASSERT_IF(type_->proto, type_->proto->newType);
77361:     flags |= LAZY_TYPE;
77361:     type_ = (type_->proto) ? type_->proto->newType : &emptyTypeObject;
77361: }
77361: 
77361: inline void
77361: TypeObject::clearProperties()
77361: {
77361:     setBasePropertyCount(0);
77361:     propertySet = NULL;
77361: }
77361: 
75720: /*
77361:  * Before sweeping the arenas themselves, scan all type objects in a
77361:  * compartment to fixup weak references: property type sets referencing dead
77361:  * JS and type objects, and singleton JS objects whose type is not referenced
77361:  * elsewhere. This also releases memory associated with dead type objects,
77361:  * so that type objects do not need later finalization.
75720:  */
77439: inline void
77439: TypeObject::sweep(JSContext *cx)
75760: {
75736:     /*
77361:      * We may be regenerating existing type sets containing this object,
77361:      * so reset contributions on each GC to avoid tripping the limit.
75736:      */
77439:     contribution = 0;
77439: 
77439:     if (singleton) {
77439:         JS_ASSERT(!emptyShapes);
77439:         JS_ASSERT(!newScript);
77361: 
77361:         /*
77439:          * All properties can be discarded. We will regenerate them as needed
77439:          * as code gets reanalyzed.
77361:          */
77439:         clearProperties();
77439: 
77439:         if (!isMarked()) {
77361:             /*
77361:              * Singleton objects do not hold strong references on their types.
77361:              * When removing the type, however, we need to fixup the singleton
77361:              * so that it has a lazy type again. The generic 'new' type for the
77361:              * proto must be live, since the type's prototype and its 'new'
77361:              * type are both strong references.
77361:              */
77439:             JS_ASSERT_IF(singleton->isMarked() && proto,
77439:                          proto->isMarked() && proto->newType->isMarked());
77439:             singleton->revertLazyType();
77361:         }
77361: 
77361:         return;
77361:     }
77361: 
77439:     if (!isMarked()) {
77439:         if (emptyShapes)
77439:             Foreground::free_(emptyShapes);
77439:         if (newScript)
77439:             Foreground::free_(newScript);
77361:         return;
77361:     }
75736: 
77439:     JSCompartment *compartment = this->compartment();
77439: 
77439:     /*
77439:      * Properties were allocated from the old arena, and need to be copied over
77439:      * to the new one. Don't hang onto properties without the OWN_PROPERTY
77439:      * flag; these were never directly assigned, and get any possible values
77439:      * from the object's prototype.
77439:      */
77439:     unsigned propertyCount = basePropertyCount();
77439:     if (propertyCount >= 2) {
77439:         unsigned oldCapacity = HashSetCapacity(propertyCount);
77439:         Property **oldArray = propertySet;
77439: 
77439:         clearProperties();
77439:         propertyCount = 0;
77439:         for (unsigned i = 0; i < oldCapacity; i++) {
77439:             Property *prop = oldArray[i];
77439:             if (prop && prop->types.isOwnProperty(false)) {
77439:                 Property *newProp = ArenaNew<Property>(compartment->pool, *prop);
77439:                 if (newProp) {
77439:                     Property **pentry =
77439:                         HashSetInsert<jsid,Property,Property>
77439:                             (compartment, propertySet, propertyCount, prop->id);
77439:                     if (pentry) {
77439:                         *pentry = newProp;
77439:                         newProp->types.sweep(cx, compartment);
77439:                     } else {
77439:                         compartment->types.setPendingNukeTypes(cx);
77439:                     }
77439:                 } else {
77439:                     compartment->types.setPendingNukeTypes(cx);
77439:                 }
77439:             }
77439:         }
77439:         setBasePropertyCount(propertyCount);
77439:     } else if (propertyCount == 1) {
77439:         Property *prop = (Property *) propertySet;
77439:         if (prop->types.isOwnProperty(false)) {
77439:             Property *newProp = ArenaNew<Property>(compartment->pool, *prop);
77439:             if (newProp) {
77439:                 propertySet = (Property **) newProp;
77439:                 newProp->types.sweep(cx, compartment);
77439:             } else {
77439:                 compartment->types.setPendingNukeTypes(cx);
77439:             }
77439:         } else {
77439:             propertySet = NULL;
77439:             setBasePropertyCount(0);
77439:         }
77439:     }
77439: 
77439:     if (basePropertyCount() <= SET_ARRAY_SIZE) {
77439:         for (unsigned i = 0; i < basePropertyCount(); i++)
77439:             JS_ASSERT(propertySet[i]);
77361:     }
77361: 
77361:     /*
77361:      * The GC will clear out the constraints ensuring the correctness of the
77361:      * newScript information, these constraints will need to be regenerated
77361:      * the next time we compile code which depends on this info.
77361:      */
77439:     if (newScript)
77439:         flags |= OBJECT_FLAG_NEW_SCRIPT_REGENERATE;
77361: }
77361: 
77464: struct SweepTypeObjectOp
77464: {
77464:     JSContext *cx;
77464:     SweepTypeObjectOp(JSContext *cx) : cx(cx) {}
77464:     void operator()(gc::Cell *cell) {
77464:         TypeObject *object = static_cast<TypeObject *>(cell);
77464:         object->sweep(cx);
77464:     }
77464: };
77464: 
77361: void
77361: SweepTypeObjects(JSContext *cx, JSCompartment *compartment)
77361: {
77361:     JS_ASSERT(!emptyTypeObject.emptyShapes);
77361:     JS_ASSERT(!emptyTypeObject.newScript);
77361: 
77464:     SweepTypeObjectOp op(cx);
77464:     gc::ForEachArenaAndCell(compartment, gc::FINALIZE_TYPE_OBJECT, gc::EmptyArenaOp, op);
76092: }
76092: 
77353: void
77353: TypeCompartment::sweep(JSContext *cx)
77353: {
77361:     JSCompartment *compartment = this->compartment();
77361: 
77361:     SweepTypeObjects(cx, compartment);
77353: 
77353:     /*
77353:      * Iterate through the array/object type tables and remove all entries
77353:      * referencing collected data. These tables only hold weak references.
77353:      */
77353: 
77353:     if (arrayTypeTable) {
77353:         for (ArrayTypeTable::Enum e(*arrayTypeTable); !e.empty(); e.popFront()) {
77353:             const ArrayTableKey &key = e.front().key;
77353:             TypeObject *obj = e.front().value;
77353:             JS_ASSERT(obj->proto == key.proto);
77353:             JS_ASSERT(!key.type.isSingleObject());
77353: 
77353:             bool remove = false;
77361:             if (key.type.isTypeObject() && !key.type.typeObject()->isMarked())
77353:                 remove = true;
77361:             if (!obj->isMarked())
77353:                 remove = true;
77353: 
77353:             if (remove)
77353:                 e.removeFront();
77353:         }
77353:     }
77353: 
77353:     if (objectTypeTable) {
77353:         for (ObjectTypeTable::Enum e(*objectTypeTable); !e.empty(); e.popFront()) {
77353:             const ObjectTableKey &key = e.front().key;
77353:             const ObjectTableEntry &entry = e.front().value;
77353:             JS_ASSERT(entry.object->proto == key.proto);
77353: 
77353:             bool remove = false;
77392:             if (!entry.object->isMarked())
77353:                 remove = true;
77353:             for (unsigned i = 0; !remove && i < key.nslots; i++) {
77353:                 if (JSID_IS_STRING(key.ids[i])) {
77353:                     JSString *str = JSID_TO_STRING(key.ids[i]);
77353:                     if (!str->isStaticAtom() && !str->isMarked())
77353:                         remove = true;
77353:                 }
77353:                 JS_ASSERT(!entry.types[i].isSingleObject());
77361:                 if (entry.types[i].isTypeObject() && !entry.types[i].typeObject()->isMarked())
77353:                     remove = true;
77353:             }
77353: 
77353:             if (remove) {
77353:                 Foreground::free_(key.ids);
77353:                 Foreground::free_(entry.types);
77353:                 e.removeFront();
77353:             }
77353:         }
77353:     }
77361: 
77361:     if (allocationSiteTable) {
77361:         for (AllocationSiteTable::Enum e(*allocationSiteTable); !e.empty(); e.popFront()) {
77361:             const AllocationSiteKey &key = e.front().key;
77361:             TypeObject *object = e.front().value;
77361: 
77446:             if (key.script->isAboutToBeFinalized(cx) || !object->isMarked())
77361:                 e.removeFront();
77361:         }
77361:     }
77439: 
77439:     /*
77439:      * The pending array is reset on GC, it can grow large (75+ KB) and is easy
77439:      * to reallocate if the compartment becomes active again.
77439:      */
77439:     if (pendingArray)
77439:         cx->free_(pendingArray);
77439: 
77439:     pendingArray = NULL;
77439:     pendingCapacity = 0;
75760: }
75760: 
75771: TypeCompartment::~TypeCompartment()
75771: {
75771:     if (pendingArray)
75901:         Foreground::free_(pendingArray);
75771: 
75771:     if (arrayTypeTable)
75901:         Foreground::delete_(arrayTypeTable);
75771: 
75771:     if (objectTypeTable)
75901:         Foreground::delete_(objectTypeTable);
77361: 
77361:     if (allocationSiteTable)
77361:         Foreground::delete_(allocationSiteTable);
75771: }
75771: 
77391: /* static */ void
77391: TypeScript::Sweep(JSContext *cx, JSScript *script)
75720: {
77391:     JSCompartment *compartment = script->compartment;
77353:     JS_ASSERT(compartment->types.inferenceEnabled);
77353: 
77391:     unsigned num = NumTypeSets(script);
77391:     TypeSet *typeArray = script->types->typeArray();
77391: 
77391:     if (script->isAboutToBeFinalized(cx)) {
76158:         /* Release all memory associated with the persistent type sets. */
75720:         for (unsigned i = 0; i < num; i++)
77361:             typeArray[i].clearObjects();
75736:     } else {
77391:         /* Remove constraints and references to dead objects from the persistent type sets. */
77361:         for (unsigned i = 0; i < num; i++)
77361:             typeArray[i].sweep(cx, compartment);
77361:     }
77391: 
77391:     TypeResult **presult = &script->types->dynamicList;
75836:     while (*presult) {
77361:         TypeResult *result = *presult;
77361:         Type type = result->type;
77361: 
77361:         if (!type.isUnknown() && !type.isAnyObject() && type.isObject() &&
77361:             IsAboutToBeFinalized(cx, type.objectKey())) {
75836:             *presult = result->next;
76059:             cx->delete_(result);
77361:         } else {
77361:             presult = &result->next;
76059:         }
75836:     }
76092: 
77353:     /*
77353:      * Method JIT code depends on the type inference data which is about to
77353:      * be purged, so purge the jitcode as well.
77353:      */
77353: #ifdef JS_METHODJIT
77434:     mjit::ReleaseScriptCode(cx, script);
77353: #endif
75720: }
75720: 
75720: void
77353: TypeScript::destroy()
76158: {
77361:     while (dynamicList) {
77361:         TypeResult *next = dynamicList->next;
77361:         Foreground::delete_(dynamicList);
77361:         dynamicList = next;
76158:     }
77439: 
77439:     Foreground::free_(this);
77439: }
77439: 
77439: inline size_t
76203: TypeSet::dynamicSize()
76203: {
77439:     /* Get the amount of memory allocated from the analysis pool for this set. */
77361:     uint32 count = baseObjectCount();
77361:     if (count >= 2)
77361:         return HashSetCapacity(count) * sizeof(TypeObject *);
77361:     return 0;
76203: }
76203: 
77439: inline size_t
77439: TypeObject::dynamicSize()
77439: {
77439:     size_t bytes = 0;
77439: 
77439:     uint32 count = basePropertyCount();
77439:     if (count >= 2)
77439:         bytes += HashSetCapacity(count) * sizeof(TypeObject *);
77439: 
77439:     count = getPropertyCount();
77439:     for (unsigned i = 0; i < count; i++) {
77439:         Property *prop = getProperty(i);
77439:         if (prop)
77439:             bytes += sizeof(Property) + prop->types.dynamicSize();
77439:     }
77439: 
77439:     return bytes;
77439: }
77439: 
76203: static void
77404: GetScriptMemoryStats(JSScript *script, TypeInferenceMemoryStats *stats)
76203: {
77391:     if (!script->types)
77361:         return;
77361: 
77395:     if (!script->compartment->types.inferenceEnabled) {
77439:         stats->scripts += sizeof(TypeScript);
77395:         return;
77395:     }
77395: 
77391:     unsigned count = TypeScript::NumTypeSets(script);
77439:     stats->scripts += sizeof(TypeScript) + count * sizeof(TypeSet);
77391: 
77391:     TypeResult *result = script->types->dynamicList;
77361:     while (result) {
77439:         stats->scripts += sizeof(TypeResult);
77361:         result = result->next;
77361:     }
77439: 
77439:     TypeSet *typeArray = script->types->typeArray();
77439:     for (unsigned i = 0; i < count; i++) {
77439:         size_t bytes = typeArray[i].dynamicSize();
77439:         stats->scripts += bytes;
77439:         stats->temporary -= bytes;
77439:     }
77361: }
77361: 
77404: JS_FRIEND_API(void)
77404: JS_GetTypeInferenceMemoryStats(JSContext *cx, JSCompartment *compartment,
77404:                                TypeInferenceMemoryStats *stats)
77361: {
77439:     /*
77439:      * Note: not all data in the pool is temporary, and some will survive GCs
77439:      * by being copied to the replacement pool. This memory will be counted too
77439:      * and deducted from the amount of temporary data.
77439:      */
77439:     stats->temporary += ArenaAllocatedSize(compartment->pool);
77439: 
77439:     /* Pending arrays are cleared on GC along with the analysis pool. */
77439:     stats->temporary += sizeof(TypeCompartment::PendingWork) * compartment->types.pendingCapacity;
77439: 
77404:     for (JSCList *cursor = compartment->scripts.next;
77404:          cursor != &compartment->scripts;
77404:          cursor = cursor->next) {
77361:         JSScript *script = reinterpret_cast<JSScript *>(cursor);
77361:         GetScriptMemoryStats(script, stats);
77361:     }
77361: 
77439:     if (compartment->types.allocationSiteTable)
77439:         stats->tables += compartment->types.allocationSiteTable->allocatedSize();
77439: 
77439:     if (compartment->types.arrayTypeTable)
77439:         stats->tables += compartment->types.arrayTypeTable->allocatedSize();
77439: 
77439:     if (compartment->types.objectTypeTable) {
77439:         stats->tables += compartment->types.objectTypeTable->allocatedSize();
77439: 
77439:         for (ObjectTypeTable::Enum e(*compartment->types.objectTypeTable);
77439:              !e.empty();
77439:              e.popFront()) {
77439:             const ObjectTableKey &key = e.front().key;
77439:             stats->tables += key.nslots * (sizeof(jsid) + sizeof(Type));
77439:         }
77439:     }
77404: }
77404: 
77404: JS_FRIEND_API(void)
77404: JS_GetTypeInferenceObjectStats(void *object_, TypeInferenceMemoryStats *stats)
77361: {
77406:     TypeObject *object = (TypeObject *) object_;
77439:     stats->objects += sizeof(TypeObject);
76203: 
77361:     if (object->singleton) {
77361:         /*
77439:          * Properties and associated type sets for singletons are cleared on
77439:          * every GC. The type object is normally destroyed too, but we don't
77439:          * charge this to 'temporary' as this is not for GC heap values.
77361:          */
77439:         JS_ASSERT(!object->newScript && !object->emptyShapes);
77361:         return;
77361:     }
77361: 
77439:     if (object->newScript) {
77439:         size_t length = 0;
77439:         for (TypeNewScript::Initializer *init = object->newScript->initializerList;; init++) {
77439:             length++;
77439:             if (init->kind == TypeNewScript::Initializer::DONE)
77439:                 break;
77439:         }
77439:         stats->objects += sizeof(TypeNewScript) + (length * sizeof(TypeNewScript::Initializer));
77439:     }
77439: 
77439:     if (object->emptyShapes)
77439:         stats->emptyShapes += sizeof(EmptyShape*) * gc::FINALIZE_FUNCTION_AND_OBJECT_LAST;
77439: 
77439:     size_t bytes = object->dynamicSize();
77439:     stats->objects += bytes;
77439:     stats->temporary -= bytes;
77439: }
