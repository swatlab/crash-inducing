38504: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
10217:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsobj_h___
    1: #define jsobj_h___
    1: /*
    1:  * JS object definitions.
    1:  *
    1:  * A JS object consists of a possibly-shared object descriptor containing
    1:  * ordered property names, called the map; and a dense vector of property
    1:  * values, called slots.  The map/slot pointer pair is GC'ed, while the map
    1:  * is reference counted and the slot vector is malloc'ed.
    1:  */
40901: #include "jsapi.h"
    1: #include "jshash.h" /* Added by JSIFY */
36991: #include "jspubtd.h"
    1: #include "jsprvtd.h"
36991: 
40388: namespace js { class AutoDescriptorArray; }
40388: 
36991: /*
36991:  * A representation of ECMA-262 ed. 5's internal property descriptor data
36991:  * structure.
36991:  */
36991: struct PropertyDescriptor {
40388:   friend class js::AutoDescriptorArray;
36999: 
36999:   private:
36991:     PropertyDescriptor();
36991: 
36999:   public:
36991:     /* 8.10.5 ToPropertyDescriptor(Obj) */
36991:     bool initialize(JSContext* cx, jsid id, jsval v);
36991: 
36991:     /* 8.10.1 IsAccessorDescriptor(desc) */
36991:     bool isAccessorDescriptor() const {
36991:         return hasGet || hasSet;
36991:     }
36991: 
36991:     /* 8.10.2 IsDataDescriptor(desc) */
36991:     bool isDataDescriptor() const {
36991:         return hasValue || hasWritable;
36991:     }
36991: 
36991:     /* 8.10.3 IsGenericDescriptor(desc) */
36991:     bool isGenericDescriptor() const {
36991:         return !isAccessorDescriptor() && !isDataDescriptor();
36991:     }
36991: 
36991:     bool configurable() const {
36991:         return (attrs & JSPROP_PERMANENT) == 0;
36991:     }
36991: 
36991:     bool enumerable() const {
36991:         return (attrs & JSPROP_ENUMERATE) != 0;
36991:     }
36991: 
36991:     bool writable() const {
36991:         return (attrs & JSPROP_READONLY) == 0;
36991:     }
36991: 
36991:     JSObject* getterObject() const {
41860:         return (get != JSVAL_VOID) ? JSVAL_TO_OBJECT(get) : NULL;
36991:     }
36991:     JSObject* setterObject() const {
41860:         return (set != JSVAL_VOID) ? JSVAL_TO_OBJECT(set) : NULL;
36991:     }
36991: 
36991:     jsval getterValue() const {
36991:         return get;
36991:     }
36991:     jsval setterValue() const {
36991:         return set;
36991:     }
36991: 
36991:     JSPropertyOp getter() const {
41860:         return js::CastAsPropertyOp(getterObject());
36991:     }
36991:     JSPropertyOp setter() const {
41860:         return js::CastAsPropertyOp(setterObject());
36991:     }
36991: 
36991:     static void traceDescriptorArray(JSTracer* trc, JSObject* obj);
36991:     static void finalizeDescriptorArray(JSContext* cx, JSObject* obj);
36991: 
36991:     jsid id;
36991:     jsval value, get, set;
36991: 
36991:     /* Property descriptor boolean fields. */
36992:     uint8 attrs;
36991: 
36991:     /* Bits indicating which values are set. */
36991:     bool hasGet : 1;
36991:     bool hasSet : 1;
36991:     bool hasValue : 1;
36991:     bool hasWritable : 1;
36991:     bool hasEnumerable : 1;
36991:     bool hasConfigurable : 1;
36991: };
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
26817: /* For detailed comments on these function pointer types, see jsprvtd.h. */
26817: struct JSObjectOps {
28353:     /*
28353:      * Custom shared object map for non-native objects. For native objects
28353:      * this should be null indicating, that JSObject.map is an instance of
28353:      * JSScope.
28353:      */
28353:     const JSObjectMap   *objectMap;
28353: 
26817:     /* Mandatory non-null function pointer members. */
26817:     JSLookupPropOp      lookupProperty;
26817:     JSDefinePropOp      defineProperty;
26817:     JSPropertyIdOp      getProperty;
26817:     JSPropertyIdOp      setProperty;
26817:     JSAttributesOp      getAttributes;
26817:     JSAttributesOp      setAttributes;
26817:     JSPropertyIdOp      deleteProperty;
26817:     JSConvertOp         defaultValue;
26817:     JSNewEnumerateOp    enumerate;
26817:     JSCheckAccessIdOp   checkAccess;
38633:     JSTypeOfOp          typeOf;
38633:     JSTraceOp           trace;
26817: 
26817:     /* Optionally non-null members start here. */
26817:     JSObjectOp          thisObject;
26817:     JSPropertyRefOp     dropProperty;
26817:     JSNative            call;
26817:     JSNative            construct;
26817:     JSHasInstanceOp     hasInstance;
26817:     JSFinalizeOp        clear;
38504: 
38504:     bool inline isNative() const;
26817: };
26817: 
38504: extern JS_FRIEND_DATA(JSObjectOps) js_ObjectOps;
38504: extern JS_FRIEND_DATA(JSObjectOps) js_WithObjectOps;
38504: 
38504: /*
38504:  * Test whether the ops is native. FIXME bug 492938: consider how it would
38504:  * affect the performance to do just the !objectMap check.
38504:  */
38504: inline bool
38504: JSObjectOps::isNative() const
38504: {
38504:     return JS_LIKELY(this == &js_ObjectOps) || !objectMap;
38504: }
38504: 
    1: struct JSObjectMap {
32777:     const JSObjectOps * const   ops;    /* high level object operation vtable */
32777:     uint32                      shape;  /* shape identifier */
32777: 
32777:     explicit JSObjectMap(const JSObjectOps *ops, uint32 shape) : ops(ops), shape(shape) {}
32777: 
32777:     enum { SHAPELESS = 0xffffffff };
39928: 
39928: private:
39928:     /* No copy or assignment semantics. */
39928:     JSObjectMap(JSObjectMap &);
39928:     void operator=(JSObjectMap &);
    1: };
    1: 
31452: const uint32 JS_INITIAL_NSLOTS = 5;
31452: 
31452: const uint32 JSSLOT_PROTO   = 0;
31452: const uint32 JSSLOT_PARENT  = 1;
32684: 
32684: /*
32684:  * The first available slot to store generic value. For JSCLASS_HAS_PRIVATE
32684:  * classes the slot stores a pointer to private data reinterpreted as jsval.
32684:  * Such pointer is stored as is without an overhead of PRIVATE_TO_JSVAL
32684:  * tagging and should be accessed using the (get|set)Private methods of
32684:  * JSObject.
32684:  */
31452: const uint32 JSSLOT_PRIVATE = 2;
31452: 
31566: const uintptr_t JSSLOT_CLASS_MASK_BITS = 3;
    1: 
    1: /*
27012:  * JSObject struct, with members sized to fit in 32 bytes on 32-bit targets,
27012:  * 64 bytes on 64-bit systems. The JSFunction struct is an extension of this
27012:  * struct allocated from a larger GC size-class.
27012:  *
27012:  * The classword member stores the JSClass pointer for this object, with the
27012:  * least two bits encoding whether this object is a "delegate" or a "system"
32603:  * object. We do *not* synchronize updates of classword -- API clients must
32603:  * take care.
27012:  *
27012:  * An object is a delegate if it is on another object's prototype (linked by
27012:  * JSSLOT_PROTO) or scope (JSSLOT_PARENT) chain, and therefore the delegate
27012:  * might be asked implicitly to get or set a property on behalf of another
27012:  * object. Delegates may be accessed directly too, as may any object, but only
27012:  * those objects linked after the head of any prototype or scope chain are
27012:  * flagged as delegates. This definition helps to optimize shape-based property
27012:  * cache invalidation (see Purge{Scope,Proto}Chain in jsobj.cpp).
27012:  *
27012:  * The meaning of the system object bit is defined by the API client. It is
27012:  * set in JS_NewSystemObject and is queried by JS_IsSystemObject (jsdbgapi.h),
27012:  * but it has no intrinsic meaning to SpiderMonkey. Further, JSFILENAME_SYSTEM
27012:  * and JS_FlagScriptFilenamePrefix (also exported via jsdbgapi.h) are intended
27012:  * to be complementary to this bit, but it is up to the API client to implement
27012:  * any such association.
27012:  *
27012:  * Both these classword tag bits are initially zero; they may be set or queried
32603:  * using the (is|set)(Delegate|System) inline methods.
27012:  *
27012:  * The dslots member is null or a pointer into a dynamically allocated vector
27012:  * of jsvals for reserved and dynamic slots. If dslots is not null, dslots[-1]
27012:  * records the number of available slots.
26970:  */
26970: struct JSObject {
40796:     /*
40796:      * TraceRecorder must be a friend because it generates code that
40796:      * manipulates JSObjects, which requires peeking under any encapsulation.
40796:      */
40796:     friend class js::TraceRecorder;
40796: 
35117:     JSObjectMap *map;                       /* property map, see jsscope.h */
35117:     jsuword     classword;                  /* JSClass ptr | bits, see above */
27012:     jsval       fslots[JS_INITIAL_NSLOTS];  /* small number of fixed slots */
    1:     jsval       *dslots;                    /* dynamically allocated slots */
31452: 
38504:     bool isNative() const { return map->ops->isNative(); }
38504: 
31452:     JSClass *getClass() const {
31452:         return (JSClass *) (classword & ~JSSLOT_CLASS_MASK_BITS);
31452:     }
31452: 
37694:     bool hasClass(const JSClass *clasp) const {
37694:         return clasp == getClass();
37694:     }
37694: 
40847:     inline JSScope *scope() const;
40847:     inline uint32 shape() const;
40847: 
32603:     bool isDelegate() const {
32603:         return (classword & jsuword(1)) != jsuword(0);
31452:     }
31452: 
32603:     void setDelegate() {
32603:         classword |= jsuword(1);
32603:     }
32603: 
32603:     static void setDelegateNullSafe(JSObject *obj) {
32603:         if (obj)
32603:             obj->setDelegate();
32603:     }
32603: 
32603:     bool isSystem() const {
32603:         return (classword & jsuword(2)) != jsuword(0);
32603:     }
32603: 
32603:     void setSystem() {
32603:         classword |= jsuword(2);
32603:     }
32603: 
40410:     uint32 numSlots(void) {
40410:         return dslots ? (uint32)dslots[-1] : (uint32)JS_INITIAL_NSLOTS;
40410:     }
40410: 
40410:     jsval& getSlotRef(uintN slot) {
40410:         return (slot < JS_INITIAL_NSLOTS)
40410:                ? fslots[slot]
40410:                : (JS_ASSERT(slot < (uint32)dslots[-1]),
40410:                   dslots[slot - JS_INITIAL_NSLOTS]);
40410:     }
40410: 
40410:     jsval getSlot(uintN slot) const {
40410:         return (slot < JS_INITIAL_NSLOTS)
40410:                ? fslots[slot]
40410:                : (JS_ASSERT(slot < (uint32)dslots[-1]),
40410:                   dslots[slot - JS_INITIAL_NSLOTS]);
40410:     }
40410: 
40410:     void setSlot(uintN slot, jsval value) {
40410:         if (slot < JS_INITIAL_NSLOTS) {
40410:             fslots[slot] = value;
40410:         } else {
40410:             JS_ASSERT(slot < (uint32)dslots[-1]);
40410:             dslots[slot - JS_INITIAL_NSLOTS] = value;
40410:         }
40410:     }
40410: 
40847:     inline jsval lockedGetSlot(uintN slot) const;
40847:     inline void lockedSetSlot(uintN slot, jsval value);
40847: 
40410:     /*
40430:      * These ones are for multi-threaded ("MT") objects.  Use getSlot(),
40410:      * getSlotRef(), setSlot() to directly manipulate slots in obj when only
40410:      * one thread can access obj, or when accessing read-only slots within
40410:      * JS_INITIAL_NSLOTS.
40410:      */
40430:     inline jsval getSlotMT(JSContext *cx, uintN slot);
40430:     inline void setSlotMT(JSContext *cx, uintN slot, jsval value);
40410: 
32603:     JSObject *getProto() const {
32603:         return JSVAL_TO_OBJECT(fslots[JSSLOT_PROTO]);
32603:     }
32603: 
32603:     void clearProto() {
32603:         fslots[JSSLOT_PROTO] = JSVAL_NULL;
32603:     }
32603: 
32603:     void setProto(JSObject *newProto) {
32603:         setDelegateNullSafe(newProto);
32603:         fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(newProto);
32603:     }
32603: 
32603:     JSObject *getParent() const {
32603:         return JSVAL_TO_OBJECT(fslots[JSSLOT_PARENT]);
32603:     }
32603: 
32603:     void clearParent() {
32603:         fslots[JSSLOT_PARENT] = JSVAL_NULL;
32603:     }
32603: 
32603:     void setParent(JSObject *newParent) {
32603:         setDelegateNullSafe(newParent);
32603:         fslots[JSSLOT_PARENT] = OBJECT_TO_JSVAL(newParent);
32603:     }
32603: 
32603:     void traceProtoAndParent(JSTracer *trc) const {
32603:         JSObject *proto = getProto();
32603:         if (proto)
32603:             JS_CALL_OBJECT_TRACER(trc, proto, "__proto__");
32603: 
32603:         JSObject *parent = getParent();
32603:         if (parent)
32603:             JS_CALL_OBJECT_TRACER(trc, parent, "__parent__");
32603:     }
32603: 
40424:     JSObject *getGlobal();
40424: 
31452:     void *getPrivate() const {
31452:         JS_ASSERT(getClass()->flags & JSCLASS_HAS_PRIVATE);
31452:         jsval v = fslots[JSSLOT_PRIVATE];
32684:         JS_ASSERT((v & jsval(1)) == jsval(0));
32684:         return reinterpret_cast<void *>(v);
31452:     }
31452: 
31452:     void setPrivate(void *data) {
31452:         JS_ASSERT(getClass()->flags & JSCLASS_HAS_PRIVATE);
32684:         jsval v = reinterpret_cast<jsval>(data);
32684:         JS_ASSERT((v & jsval(1)) == jsval(0));
32684:         fslots[JSSLOT_PRIVATE] = v;
31452:     }
31501: 
32684:     static jsval defaultPrivate(JSClass *clasp) {
32684:         return (clasp->flags & JSCLASS_HAS_PRIVATE)
32684:                ? JSVAL_NULL
32684:                : JSVAL_VOID;
32684:     }
32684: 
40796:     /*
40901:      * Primitive-specific getters and setters.
40901:      */
40901: 
40901:   private:
40901:     static const uint32 JSSLOT_PRIMITIVE_THIS = JSSLOT_PRIVATE;
40901: 
40901:   public:
40901:     inline jsval getPrimitiveThis() const;
40901:     inline void setPrimitiveThis(jsval pthis);
40901: 
40901:     /*
40796:      * Array-specific getters and setters (for both dense and slow arrays).
40796:      */
40796: 
40796:   private:
41838:     // Used by dense and slow arrays.
40796:     static const uint32 JSSLOT_ARRAY_LENGTH = JSSLOT_PRIVATE;
41838: 
41838:     // Used only by dense arrays.
41838:     static const uint32 JSSLOT_DENSE_ARRAY_COUNT     = JSSLOT_PRIVATE + 1;
41850:     static const uint32 JSSLOT_DENSE_ARRAY_MINLENCAP = JSSLOT_PRIVATE + 2;
40796: 
40797:     // This assertion must remain true;  see comment in js_MakeArraySlow().
40797:     // (Nb: This method is never called, it just contains a static assertion.
40797:     // The static assertion isn't inline because that doesn't work on Mac.)
40797:     inline void staticAssertArrayLengthIsInPrivateSlot();
40796: 
41850:     inline bool isDenseArrayMinLenCapOk() const;
41850: 
41850:     inline uint32 uncheckedGetArrayLength() const;
41850:     inline uint32 uncheckedGetDenseArrayCapacity() const;
41850: 
40796:   public:
40796:     inline uint32 getArrayLength() const;
41850:     inline void setDenseArrayLength(uint32 length);
41850:     inline void setSlowArrayLength(uint32 length);
40864: 
41838:     inline uint32 getDenseArrayCount() const;
41838:     inline void setDenseArrayCount(uint32 count);
41838:     inline void incDenseArrayCountBy(uint32 posDelta);
41838:     inline void decDenseArrayCountBy(uint32 negDelta);
40864: 
41782:     inline uint32 getDenseArrayCapacity() const;
41782:     inline void setDenseArrayCapacity(uint32 capacity); // XXX: bug 558263 will remove this
41782: 
41782:     inline jsval getDenseArrayElement(uint32 i) const;
41782:     inline void setDenseArrayElement(uint32 i, jsval v);
41782: 
41782:     inline jsval *getDenseArrayElements() const;   // returns pointer to the Array's elements array
41782:     bool resizeDenseArrayElements(JSContext *cx, uint32 oldcap, uint32 newcap,
41782:                                bool initializeAllSlots = true);
41782:     bool ensureDenseArrayElements(JSContext *cx, uint32 newcap,
41782:                                bool initializeAllSlots = true);
41782:     inline void freeDenseArrayElements(JSContext *cx);
40796: 
41850:     inline void voidDenseOnlyArraySlots();  // used when converting a dense array to a slow array
41850: 
40796:     /*
40864:      * Arguments-specific getters and setters.
40864:      */
40864: 
40864:     /*
40864:      * Reserved slot structure for Arguments objects:
40864:      *
40864:      * JSSLOT_PRIVATE       - the corresponding frame until the frame exits.
40864:      * JSSLOT_ARGS_LENGTH   - the number of actual arguments and a flag
40864:      *                        indicating whether arguments.length was
40864:      *                        overwritten.
40864:      * JSSLOT_ARGS_CALLEE   - the arguments.callee value or JSVAL_HOLE if that
40864:      *                        was overwritten.
40864:      *
40864:      * Argument index i is stored in dslots[i].  But future-proof your code by
40864:      * using {Get,Set}ArgsSlot instead of naked dslots references.
40864:      */
40864:   private:
40864:     static const uint32 JSSLOT_ARGS_LENGTH = JSSLOT_PRIVATE + 1;
40864:     static const uint32 JSSLOT_ARGS_CALLEE = JSSLOT_PRIVATE + 2;
40864: 
40864:   public:
40864:     /* Number of extra fixed slots besides JSSLOT_PRIVATE. */
40864:     static const uint32 ARGS_FIXED_RESERVED_SLOTS = 2;
40864: 
40864:     inline uint32 getArgsLength() const;
40864:     inline void setArgsLength(uint32 argc);
40864:     inline void setArgsLengthOverridden();
40864:     inline bool isArgsLengthOverridden();
40864: 
40864:     inline jsval getArgsCallee() const;
40864:     inline void setArgsCallee(jsval callee);
40864: 
40864:     /*
40901:      * Date-specific getters and setters.
40901:      */
40901: 
40901:   private:
40901:     // The second slot caches the local time;  it's initialized to NaN.
40901:     static const uint32 JSSLOT_DATE_UTC_TIME   = JSSLOT_PRIVATE;
40901:     static const uint32 JSSLOT_DATE_LOCAL_TIME = JSSLOT_PRIVATE + 1;
40901: 
40901:   public:
40901:     static const uint32 DATE_FIXED_RESERVED_SLOTS = 2;
40901: 
40901:     inline jsval getDateLocalTime() const;
40901:     inline jsval *addressOfDateLocalTime();
40901:     inline void setDateLocalTime(jsval pthis);
40901: 
40901:     inline jsval getDateUTCTime() const;
40901:     inline jsval *addressOfDateUTCTime();
40901:     inline void setDateUTCTime(jsval pthis);
40901: 
40901:     /*
40901:      * RegExp-specific getters and setters.
40901:      */
40901: 
40901:   private:
40901:     static const uint32 JSSLOT_REGEXP_LAST_INDEX = JSSLOT_PRIVATE + 1;
40901: 
40901:   public:
40901:     static const uint32 REGEXP_FIXED_RESERVED_SLOTS = 1;
40901: 
40901:     inline jsval getRegExpLastIndex() const;
40901:     inline jsval *addressOfRegExpLastIndex();
40901:     inline void zeroRegExpLastIndex();
40901: 
40901:     /*
40796:      * Back to generic stuff.
40796:      */
40796: 
38638:     bool isCallable();
38630: 
32684:     /* The map field is not initialized here and should be set separately. */
32684:     void init(JSClass *clasp, JSObject *proto, JSObject *parent,
35057:               jsval privateSlotValue) {
32684:         JS_ASSERT(((jsuword) clasp & 3) == 0);
32684:         JS_STATIC_ASSERT(JSSLOT_PRIVATE + 3 == JS_INITIAL_NSLOTS);
32684:         JS_ASSERT_IF(clasp->flags & JSCLASS_HAS_PRIVATE,
32684:                      (privateSlotValue & jsval(1)) == jsval(0));
32684: 
32684:         classword = jsuword(clasp);
32684:         JS_ASSERT(!isDelegate());
32684:         JS_ASSERT(!isSystem());
32684: 
32684:         setProto(proto);
32684:         setParent(parent);
32684:         fslots[JSSLOT_PRIVATE] = privateSlotValue;
32684:         fslots[JSSLOT_PRIVATE + 1] = JSVAL_VOID;
32684:         fslots[JSSLOT_PRIVATE + 2] = JSVAL_VOID;
35057:         dslots = NULL;
32560:     }
32560: 
35117:     /*
35117:      * Like init, but also initializes map. The catch: proto must be the result
35117:      * of a call to js_InitClass(...clasp, ...).
35117:      */
35117:     inline void initSharingEmptyScope(JSClass *clasp, JSObject *proto, JSObject *parent,
35117:                                       jsval privateSlotValue);
35117: 
39928:     inline bool hasSlotsArray() const { return !!dslots; }
36997: 
36997:     /* This method can only be called when hasSlotsArray() returns true. */
36997:     inline void freeSlotsArray(JSContext *cx);
36997: 
32603:     JSBool lookupProperty(JSContext *cx, jsid id,
31501:                           JSObject **objp, JSProperty **propp) {
31501:         return map->ops->lookupProperty(cx, this, id, objp, propp);
31501:     }
31501: 
32603:     JSBool defineProperty(JSContext *cx, jsid id, jsval value,
33165:                           JSPropertyOp getter = JS_PropertyStub,
33165:                           JSPropertyOp setter = JS_PropertyStub,
33165:                           uintN attrs = JSPROP_ENUMERATE) {
32573:         return map->ops->defineProperty(cx, this, id, value, getter, setter, attrs);
31501:     }
31501: 
32603:     JSBool getProperty(JSContext *cx, jsid id, jsval *vp) {
31501:         return map->ops->getProperty(cx, this, id, vp);
31501:     }
31501: 
32603:     JSBool setProperty(JSContext *cx, jsid id, jsval *vp) {
31501:         return map->ops->setProperty(cx, this, id, vp);
31501:     }
31501: 
32603:     JSBool getAttributes(JSContext *cx, jsid id, JSProperty *prop,
31501:                          uintN *attrsp) {
31501:         return map->ops->getAttributes(cx, this, id, prop, attrsp);
31501:     }
31501: 
32603:     JSBool setAttributes(JSContext *cx, jsid id, JSProperty *prop,
31501:                          uintN *attrsp) {
31501:         return map->ops->setAttributes(cx, this, id, prop, attrsp);
31501:     }
31501: 
32603:     JSBool deleteProperty(JSContext *cx, jsid id, jsval *rval) {
31501:         return map->ops->deleteProperty(cx, this, id, rval);
31501:     }
31501: 
32603:     JSBool defaultValue(JSContext *cx, JSType hint, jsval *vp) {
31501:         return map->ops->defaultValue(cx, this, hint, vp);
31501:     }
31501: 
32603:     JSBool enumerate(JSContext *cx, JSIterateOp op, jsval *statep,
31501:                      jsid *idp) {
31501:         return map->ops->enumerate(cx, this, op, statep, idp);
31501:     }
31501: 
32603:     JSBool checkAccess(JSContext *cx, jsid id, JSAccessMode mode, jsval *vp,
31501:                        uintN *attrsp) {
31501:         return map->ops->checkAccess(cx, this, id, mode, vp, attrsp);
31501:     }
31501: 
38633:     JSType typeOf(JSContext *cx) {
38633:         return map->ops->typeOf(cx, this);
38633:     }
38633: 
31501:     /* These four are time-optimized to avoid stub calls. */
32603:     JSObject *thisObject(JSContext *cx) {
31501:         return map->ops->thisObject ? map->ops->thisObject(cx, this) : this;
31501:     }
31501: 
32603:     void dropProperty(JSContext *cx, JSProperty *prop) {
31501:         if (map->ops->dropProperty)
31501:             map->ops->dropProperty(cx, this, prop);
31501:     }
37003: 
40405:     inline bool isArguments() const;
37003:     inline bool isArray() const;
37003:     inline bool isDenseArray() const;
40796:     inline bool isSlowArray() const;
40901:     inline bool isNumber() const;
40901:     inline bool isBoolean() const;
40901:     inline bool isString() const;
40901:     inline bool isPrimitive() const;
40901:     inline bool isDate() const;
37003:     inline bool isFunction() const;
37003:     inline bool isRegExp() const;
37003:     inline bool isXML() const;
37685: 
37685:     inline bool unbrand(JSContext *cx);
32603: };
31501: 
    1: #define JSSLOT_START(clasp) (((clasp)->flags & JSCLASS_HAS_PRIVATE)           \
    1:                              ? JSSLOT_PRIVATE + 1                             \
32684:                              : JSSLOT_PRIVATE)
    1: 
    1: #define JSSLOT_FREE(clasp)  (JSSLOT_START(clasp)                              \
    1:                              + JSCLASS_RESERVED_SLOTS(clasp))
    1: 
    1: /*
32650:  * Maximum capacity of the obj->dslots vector, net of the hidden slot at
32650:  * obj->dslots[-1] that is used to store the length of the vector biased by
32650:  * JS_INITIAL_NSLOTS (and again net of the slot at index -1).
27891:  */
32650: #define MAX_DSLOTS_LENGTH   (JS_MAX(~uint32(0), ~size_t(0)) / sizeof(jsval) - 1)
32650: #define MAX_DSLOTS_LENGTH32 (~uint32(0) / sizeof(jsval) - 1)
27891: 
    1: #define OBJ_CHECK_SLOT(obj,slot)                                              \
40847:     (JS_ASSERT((obj)->isNative()), JS_ASSERT(slot < (obj)->scope()->freeslot))
    1: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * The GC runs only when all threads except the one on which the GC is active
40410:  * are suspended at GC-safe points, so calling obj->getSlot() from the GC's
    1:  * thread is safe when rt->gcRunning is set. See jsgc.c for details.
    1:  */
    1: #define THREAD_IS_RUNNING_GC(rt, thread)                                      \
    1:     ((rt)->gcRunning && (rt)->gcThread == (thread))
    1: 
    1: #define CX_THREAD_IS_RUNNING_GC(cx)                                           \
    1:     THREAD_IS_RUNNING_GC((cx)->runtime, (cx)->thread)
    1: 
40410: #endif /* JS_THREADSAFE */
    1: 
31501: #ifdef __cplusplus
32603: inline void
31501: OBJ_TO_INNER_OBJECT(JSContext *cx, JSObject *&obj)
31501: {
40826:     JSClass *clasp = obj->getClass();
31501:     if (clasp->flags & JSCLASS_IS_EXTENDED) {
31501:         JSExtendedClass *xclasp = (JSExtendedClass *) clasp;
31501:         if (xclasp->innerObject)
31501:             obj = xclasp->innerObject(cx, obj);
31501:     }
31501: }
31501: 
31501: /*
31501:  * The following function has been copied to jsd/jsd_val.c. If making changes to
31501:  * OBJ_TO_OUTER_OBJECT, please update jsd/jsd_val.c as well.
31501:  */
32603: inline void
31501: OBJ_TO_OUTER_OBJECT(JSContext *cx, JSObject *&obj)
31501: {
40826:     JSClass *clasp = obj->getClass();
31501:     if (clasp->flags & JSCLASS_IS_EXTENDED) {
31501:         JSExtendedClass *xclasp = (JSExtendedClass *) clasp;
31501:         if (xclasp->outerObject)
31501:             obj = xclasp->outerObject(cx, obj);
31501:     }
31501: }
31501: #endif
31501: 
    1: extern JSClass  js_ObjectClass;
    1: extern JSClass  js_WithClass;
    1: extern JSClass  js_BlockClass;
    1: 
    1: /*
    1:  * Block scope object macros.  The slots reserved by js_BlockClass are:
    1:  *
    1:  *   JSSLOT_PRIVATE       JSStackFrame *    active frame pointer or null
    1:  *   JSSLOT_BLOCK_DEPTH   int               depth of block slots in frame
    1:  *
    1:  * After JSSLOT_BLOCK_DEPTH come one or more slots for the block locals.
    1:  *
    1:  * A With object is like a Block object, in that both have one reserved slot
    1:  * telling the stack depth of the relevant slots (the slot whose value is the
    1:  * object named in the with statement, the slots containing the block's local
    1:  * variables); and both have a private slot referring to the JSStackFrame in
    1:  * whose activation they were created (or null if the with or block object
    1:  * outlives the frame).
    1:  */
    1: #define JSSLOT_BLOCK_DEPTH      (JSSLOT_PRIVATE + 1)
    1: 
30645: static inline bool
30645: OBJ_IS_CLONED_BLOCK(JSObject *obj)
30645: {
32717:     return obj->getProto() != NULL;
30645: }
30645: 
32717: extern JSBool
33166: js_DefineBlockVariable(JSContext *cx, JSObject *obj, jsid id, intN index);
32717: 
    1: #define OBJ_BLOCK_COUNT(cx,obj)                                               \
40847:     ((OBJ_IS_CLONED_BLOCK(obj) ? obj->getProto() : obj)->scope()->entryCount)
    1: #define OBJ_BLOCK_DEPTH(cx,obj)                                               \
40410:     JSVAL_TO_INT(obj->getSlot(JSSLOT_BLOCK_DEPTH))
    1: #define OBJ_SET_BLOCK_DEPTH(cx,obj,depth)                                     \
40410:     obj->setSlot(JSSLOT_BLOCK_DEPTH, INT_TO_JSVAL(depth))
    1: 
    1: /*
    1:  * To make sure this slot is well-defined, always call js_NewWithObject to
    1:  * create a With object, don't call js_NewObject directly.  When creating a
    1:  * With object that does not correspond to a stack slot, pass -1 for depth.
    1:  *
    1:  * When popping the stack across this object's "with" statement, client code
31452:  * must call withobj->setPrivate(NULL).
    1:  */
22652: extern JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth);
    1: 
    1: /*
    1:  * Create a new block scope object not linked to any proto or parent object.
    1:  * Blocks are created by the compiler to reify let blocks and comprehensions.
    1:  * Only when dynamic scope is captured do they need to be cloned and spliced
    1:  * into an active scope chain.
    1:  */
    1: extern JSObject *
    1: js_NewBlockObject(JSContext *cx);
    1: 
    1: extern JSObject *
30645: js_CloneBlockObject(JSContext *cx, JSObject *proto, JSStackFrame *fp);
    1: 
22652: extern JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind);
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp);
28093: 
    1: struct JSSharpObjectMap {
    1:     jsrefcount  depth;
    1:     jsatomid    sharpgen;
    1:     JSHashTable *table;
    1: };
    1: 
    1: #define SHARP_BIT       ((jsatomid) 1)
    1: #define BUSY_BIT        ((jsatomid) 2)
    1: #define SHARP_ID_SHIFT  2
40292: #define IS_SHARP(he)    (uintptr_t((he)->value) & SHARP_BIT)
40292: #define MAKE_SHARP(he)  ((he)->value = (void *) (uintptr_t((he)->value)|SHARP_BIT))
40292: #define IS_BUSY(he)     (uintptr_t((he)->value) & BUSY_BIT)
40292: #define MAKE_BUSY(he)   ((he)->value = (void *) (uintptr_t((he)->value)|BUSY_BIT))
40292: #define CLEAR_BUSY(he)  ((he)->value = (void *) (uintptr_t((he)->value)&~BUSY_BIT))
    1: 
    1: extern JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp);
    1: 
    1: extern void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap);
    1: 
    1: /*
    1:  * Mark objects stored in map if GC happens between js_EnterSharpObject
    1:  * and js_LeaveSharpObject. GC calls this when map->depth > 0.
    1:  */
    1: extern void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map);
    1: 
    1: extern JSBool
16519: js_HasOwnPropertyHelper(JSContext *cx, JSLookupPropOp lookup, uintN argc,
16519:                         jsval *vp);
    1: 
18062: extern JSBool
18062: js_HasOwnProperty(JSContext *cx, JSLookupPropOp lookup, JSObject *obj, jsid id,
36991:                   JSObject **objp, JSProperty **propp);
18062: 
18062: extern JSBool
18062: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
18062: 
    1: extern JSObject *
14322: js_InitEval(JSContext *cx, JSObject *obj);
14322: 
14322: extern JSObject *
    1: js_InitObjectClass(JSContext *cx, JSObject *obj);
    1: 
25897: extern JSObject *
25897: js_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
25897:              JSClass *clasp, JSNative constructor, uintN nargs,
25897:              JSPropertySpec *ps, JSFunctionSpec *fs,
28086:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs);
25897: 
25702: /*
25702:  * Select Object.prototype method names shared between jsapi.cpp and jsobj.cpp.
25702:  */
    1: extern const char js_watch_str[];
    1: extern const char js_unwatch_str[];
    1: extern const char js_hasOwnProperty_str[];
    1: extern const char js_isPrototypeOf_str[];
    1: extern const char js_propertyIsEnumerable_str[];
40855: 
40855: #ifdef OLD_GETTER_SETTER_METHODS
    1: extern const char js_defineGetter_str[];
    1: extern const char js_defineSetter_str[];
    1: extern const char js_lookupGetter_str[];
    1: extern const char js_lookupSetter_str[];
40855: #endif
    1: 
11700: /*
32684:  * Allocate a new native object with the given value of the proto and private
32684:  * slots. The parent slot is set to the value of proto's parent slot.
25897:  *
35117:  * clasp must be a native class. proto must be the result of a call to
35117:  * js_InitClass(...clasp, ...).
35117:  *
25897:  * Note that this is the correct global object for native class instances, but
25897:  * not for user-defined functions called as constructors.  Functions used as
25897:  * constructors must create instances parented by the parent of the function
25897:  * object, not by the parent of its .prototype object value.
25897:  */
25897: extern JSObject*
35117: js_NewObjectWithClassProto(JSContext *cx, JSClass *clasp, JSObject *proto,
32684:                            jsval privateSlotValue);
25897: 
25897: /*
    1:  * Fast access to immutable standard objects (constructors and prototypes).
    1:  */
    1: extern JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp);
    1: 
    1: extern JSBool
    1: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj);
    1: 
38604: /*
38604:  * If protoKey is not JSProto_Null, then clasp is ignored. If protoKey is
38604:  * JSProto_Null, clasp must non-null.
38604:  */
    1: extern JSBool
38604: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey key, jsval *vp,
38604:                    JSClass *clasp = NULL);
    1: 
    1: extern JSObject *
    1: js_ConstructObject(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                    JSObject *parent, uintN argc, jsval *argv);
    1: 
    1: extern JSBool
    1: js_AllocSlot(JSContext *cx, JSObject *obj, uint32 *slotp);
    1: 
    1: extern void
    1: js_FreeSlot(JSContext *cx, JSObject *obj, uint32 slot);
    1: 
30454: extern bool
40858: js_AllocSlots(JSContext *cx, JSObject *obj, size_t nslots);
40858: 
40858: extern bool
30454: js_GrowSlots(JSContext *cx, JSObject *obj, size_t nslots);
30454: 
30454: extern void
30454: js_ShrinkSlots(JSContext *cx, JSObject *obj, size_t nslots);
30454: 
30732: /*
30732:  * Ensure that the object has at least JSCLASS_RESERVED_SLOTS(clasp)+nreserved
30732:  * slots. The function can be called only for native objects just created with
30732:  * js_NewObject or its forms. In particular, the object should not be shared
30732:  * between threads and its dslots array must be null. nreserved must match the
30732:  * value that JSClass.reserveSlots (if any) would return after the object is
30732:  * fully initialized.
30732:  */
30732: bool
30732: js_EnsureReservedSlots(JSContext *cx, JSObject *obj, size_t nreserved);
30732: 
11524: extern jsid
30270: js_CheckForStringIndex(jsid id);
11524: 
    1: /*
25936:  * js_PurgeScopeChain does nothing if obj is not itself a prototype or parent
25936:  * scope, else it reshapes the scope and prototype chains it links. It calls
25936:  * js_PurgeScopeChainHelper, which asserts that obj is flagged as a delegate
25936:  * (i.e., obj has ever been on a prototype or parent chain).
25936:  */
25936: extern void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id);
25936: 
30597: #ifdef __cplusplus /* Aargh, libgjs, bug 492720. */
25936: static JS_INLINE void
25936: js_PurgeScopeChain(JSContext *cx, JSObject *obj, jsid id)
25936: {
32603:     if (obj->isDelegate())
25936:         js_PurgeScopeChainHelper(cx, obj, id);
25936: }
30597: #endif
25936: 
25936: /*
    1:  * Find or create a property named by id in obj's scope, with the given getter
    1:  * and setter, slot, attributes, and other members.
    1:  */
    1: extern JSScopeProperty *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
    1:                      JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid);
    1: 
    1: /*
    1:  * Change sprop to have the given attrs, getter, and setter in scope, morphing
    1:  * it into a potentially new JSScopeProperty.  Return a pointer to the changed
    1:  * or identical property.
    1:  */
    1: extern JSScopeProperty *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
    1:                              JSScopeProperty *sprop, uintN attrs, uintN mask,
    1:                              JSPropertyOp getter, JSPropertyOp setter);
    1: 
32573: extern JSBool
32573: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
32573:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs);
32573: 
40356: extern JSBool
40356: js_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, jsval descriptor, JSBool *bp);
40356: 
32573: /*
32573:  * Flags for the defineHow parameter of js_DefineNativeProperty.
32573:  */
32573: const uintN JSDNP_CACHE_RESULT = 1; /* an interpreter call from JSOP_INITPROP */
32573: const uintN JSDNP_DONT_PURGE   = 2; /* suppress js_PurgeScopeChain */
32658: const uintN JSDNP_SET_METHOD   = 4; /* js_{DefineNativeProperty,SetPropertyHelper}
38562:                                        must pass the JSScopeProperty::METHOD
38562:                                        flag on to js_AddScopeProperty */
41774: const uintN JSDNP_UNQUALIFIED  = 8; /* Unqualified property set.  Only used in
41774:                                        the defineHow argument of
41774:                                        js_SetPropertyHelper. */
32573: 
    1: /*
    1:  * On error, return false.  On success, if propp is non-null, return true with
    1:  * obj locked and with a held property in *propp; if propp is null, return true
    1:  * but release obj's lock first.  Therefore all callers who pass non-null propp
31501:  * result parameters must later call obj->dropProperty(cx, *propp) both to drop
31501:  * the held property, and to release the lock on obj.
    1:  */
    1: extern JSBool
    1: js_DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
    1:                         JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
24852:                         uintN flags, intN shortid, JSProperty **propp,
28397:                         uintN defineHow = 0);
    1: 
    1: /*
32573:  * Unlike js_DefineNativeProperty, propp must be non-null. On success, and if
32573:  * id was found, return true with *objp non-null and locked, and with a held
32573:  * property stored in *propp. If successful but id was not found, return true
32573:  * with both *objp and *propp null. Therefore all callers who receive a
32573:  * non-null *propp must later call (*objp)->dropProperty(cx, *propp).
    1:  */
    1: extern JS_FRIEND_API(JSBool)
    1: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                   JSProperty **propp);
    1: 
    1: /*
10217:  * Specialized subroutine that allows caller to preset JSRESOLVE_* flags and
10217:  * returns the index along the prototype chain in which *propp was found, or
10217:  * the last index if not found, or -1 on error.
    1:  */
10217: extern int
    1: js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                            JSObject **objp, JSProperty **propp);
    1: 
31467: 
31467: /*
31467:  * We cache name lookup results only for the global object or for native
31467:  * non-global objects without prototype or with prototype that never mutates,
31467:  * see bug 462734 and bug 487039.
31467:  */
31467: static inline bool
31467: js_IsCacheableNonGlobalScope(JSObject *obj)
31467: {
31467:     extern JS_FRIEND_DATA(JSClass) js_CallClass;
31467:     extern JS_FRIEND_DATA(JSClass) js_DeclEnvClass;
39930:     JS_ASSERT(obj->getParent());
31467: 
40410:     JSClass *clasp = obj->getClass();
31467:     bool cacheable = (clasp == &js_CallClass ||
31467:                       clasp == &js_BlockClass ||
31467:                       clasp == &js_DeclEnvClass);
31467: 
31467:     JS_ASSERT_IF(cacheable, obj->map->ops->lookupProperty == js_LookupProperty);
31467:     return cacheable;
31467: }
31467: 
27575: /*
27575:  * If cacheResult is false, return JS_NO_PROP_CACHE_FILL on success.
27575:  */
40362: extern js::PropertyCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp);
11377: 
10217: /*
10217:  * Return the index along the scope chain in which id was found, or the last
10217:  * index if not found, or -1 on error.
10217:  */
11377: extern JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp);
    1: 
22652: extern JS_REQUIRES_STACK JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id);
    1: 
    1: extern JSObject *
    1: js_FindVariableScope(JSContext *cx, JSFunction **funp);
    1: 
    1: /*
32658:  * JSGET_CACHE_RESULT is the analogue of JSDNP_CACHE_RESULT for js_GetMethod.
32658:  *
32658:  * JSGET_METHOD_BARRIER (the default, hence 0 but provided for documentation)
32658:  * enables a read barrier that preserves standard function object semantics (by
32658:  * default we assume our caller won't leak a joined callee to script, where it
32658:  * would create hazardous mutable object sharing as well as observable identity
32658:  * according to == and ===.
32658:  *
32658:  * JSGET_NO_METHOD_BARRIER avoids the performance overhead of the method read
32658:  * barrier, which is not needed when invoking a lambda that otherwise does not
32658:  * leak its callee reference (via arguments.callee or its name).
32658:  */
32658: const uintN JSGET_CACHE_RESULT      = 1; // from a caching interpreter opcode
32658: const uintN JSGET_METHOD_BARRIER    = 0; // get can leak joined function object
32658: const uintN JSGET_NO_METHOD_BARRIER = 2; // call to joined function can't leak
32658: 
32658: /*
27490:  * NB: js_NativeGet and js_NativeSet are called with the scope containing sprop
27490:  * (pobj's scope for Get, obj's for Set) locked, and on successful return, that
27490:  * scope is again locked.  But on failure, both functions return false with the
27490:  * scope containing sprop unlocked.
    1:  */
    1: extern JSBool
    1: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj,
32658:              JSScopeProperty *sprop, uintN getHow, jsval *vp);
    1: 
    1: extern JSBool
32658: js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, bool added,
32658:              jsval *vp);
    1: 
    1: extern JSBool
32658: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN getHow,
27575:                      jsval *vp);
11377: 
11377: extern JSBool
    1: js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
    1: extern JSBool
40356: js_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
40356: 
40356: extern JSBool
32658: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, jsval *vp);
26187: 
27372: /*
41774:  * Check whether it is OK to assign an undeclared property with name
41774:  * propname of the global object in the current script on cx.  Reports
41774:  * an error if one needs to be reported (in particular in all cases
41774:  * when it returns false).
27372:  */
35308: extern JS_FRIEND_API(bool)
41774: js_CheckUndeclaredVarAssignment(JSContext *cx, jsval propname);
27372: 
27932: extern JSBool
32658: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
27575:                      jsval *vp);
11377: 
11377: extern JSBool
    1: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
    1: 
    1: extern JSBool
    1: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp);
    1: 
    1: extern JSBool
    1: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp);
    1: 
    1: extern JSBool
    1: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval);
    1: 
    1: extern JSBool
    1: js_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp);
    1: 
    1: extern JSBool
    1: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:              jsval *statep, jsid *idp);
    1: 
    1: extern void
33128: js_MarkEnumeratorState(JSTracer *trc, JSObject *obj, jsval state);
33128: 
33128: extern void
33128: js_PurgeCachedNativeEnumerators(JSContext *cx, JSThreadData *data);
    1: 
    1: extern JSBool
    1: js_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp);
    1: 
38633: extern JSType
38633: js_TypeOf(JSContext *cx, JSObject *obj);
38633: 
    1: extern JSBool
    1: js_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
    1: 
    1: extern JSBool
    1: js_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:              jsval *rval);
    1: 
    1: extern JSBool
    1: js_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
    1: 
    1: extern JSBool
28003: js_SetProtoOrParent(JSContext *cx, JSObject *obj, uint32 slot, JSObject *pobj,
28003:                     JSBool checkForCycles);
    1: 
    1: extern JSBool
    1: js_IsDelegate(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
    1: 
38604: /*
38604:  * If protoKey is not JSProto_Null, then clasp is ignored. If protoKey is
38604:  * JSProto_Null, clasp must non-null.
38604:  */
39541: extern JS_FRIEND_API(JSBool)
38604: js_GetClassPrototype(JSContext *cx, JSObject *scope, JSProtoKey protoKey,
38604:                      JSObject **protop, JSClass *clasp = NULL);
    1: 
    1: extern JSBool
    1: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto,
    1:                      uintN attrs);
    1: 
 2383: /*
 2383:  * Wrap boolean, number or string as Boolean, Number or String object.
 2383:  * *vp must not be an object, null or undefined.
 2383:  */
 2383: extern JSBool
 2383: js_PrimitiveToObject(JSContext *cx, jsval *vp);
 2383: 
    1: extern JSBool
    1: js_ValueToObject(JSContext *cx, jsval v, JSObject **objp);
    1: 
    1: extern JSObject *
    1: js_ValueToNonNullObject(JSContext *cx, jsval v);
    1: 
    1: extern JSBool
    1: js_TryValueOf(JSContext *cx, JSObject *obj, JSType type, jsval *rval);
    1: 
    1: extern JSBool
    1: js_TryMethod(JSContext *cx, JSObject *obj, JSAtom *atom,
    1:              uintN argc, jsval *argv, jsval *rval);
    1: 
    1: extern JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp);
    1: 
  583: extern void
  583: js_TraceObject(JSTracer *trc, JSObject *obj);
    1: 
    1: extern void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize);
11835: 
11835: extern void
    1: js_Clear(JSContext *cx, JSObject *obj);
    1: 
38611: #ifdef JS_THREADSAFE
38611: #define NATIVE_DROP_PROPERTY js_DropProperty
38611: 
38611: extern void
38611: js_DropProperty(JSContext *cx, JSObject *obj, JSProperty *prop);
38611: #else
38611: #define NATIVE_DROP_PROPERTY NULL
38611: #endif
38611: 
32603: extern bool
32603: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval *vp);
    1: 
32603: bool
32603: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval v);
    1: 
15588: /*
18308:  * Precondition: obj must be locked.
15588:  */
15588: extern JSBool
15588: js_ReallocSlots(JSContext *cx, JSObject *obj, uint32 nslots,
15588:                 JSBool exactAllocation);
15588: 
    1: extern JSObject *
    1: js_CheckScopeChainValidity(JSContext *cx, JSObject *scopeobj, const char *caller);
    1: 
    1: extern JSBool
    1: js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
    1:                          JSPrincipals *principals, JSAtom *caller);
 8179: 
39061: /* For CSP -- checks if eval() and friends are allowed to run. */
39061: extern JSBool
39061: js_CheckContentSecurityPolicy(JSContext *cx);
39061: 
12674: /* Infallible -- returns its argument if there is no wrapped object. */
12674: extern JSObject *
12674: js_GetWrappedObject(JSContext *cx, JSObject *obj);
12674: 
12690: /* NB: Infallible. */
12690: extern const char *
12690: js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
12690:                    JSPrincipals *principals, uintN *linenop);
18062: 
38630: static inline bool
38638: js_IsCallable(jsval v) {
38638:     return !JSVAL_IS_PRIMITIVE(v) && JSVAL_TO_OBJECT(v)->isCallable();
38630: }
25718: 
36491: extern JSBool
27641: js_ReportGetterOnlyAssignment(JSContext *cx);
27641: 
27641: extern JS_FRIEND_API(JSBool)
27641: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
27641: 
19714: #ifdef DEBUG
19714: JS_FRIEND_API(void) js_DumpChars(const jschar *s, size_t n);
19714: JS_FRIEND_API(void) js_DumpString(JSString *str);
19714: JS_FRIEND_API(void) js_DumpAtom(JSAtom *atom);
19714: JS_FRIEND_API(void) js_DumpValue(jsval val);
19714: JS_FRIEND_API(void) js_DumpId(jsid id);
19714: JS_FRIEND_API(void) js_DumpObject(JSObject *obj);
28665: JS_FRIEND_API(void) js_DumpStackFrame(JSStackFrame *fp);
19714: #endif
19714: 
30034: extern uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags);
30034: 
30860: /* Object constructor native. Exposed only so the JIT can know its address. */
30860: JSBool
30860: js_Object(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
30860: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsobj_h___ */
