41434: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
41434:  * ***** BEGIN LICENSE BLOCK *****
41434:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41434:  *
41434:  * The contents of this file are subject to the Mozilla Public License Version
41434:  * 1.1 (the "License"); you may not use this file except in compliance with
41434:  * the License. You may obtain a copy of the License at
41434:  * http://www.mozilla.org/MPL/
41434:  *
41434:  * Software distributed under the License is distributed on an "AS IS" basis,
41434:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41434:  * for the specific language governing rights and limitations under the
41434:  * License.
41434:  *
41434:  * The Initial Developer of the Original Code is Mozilla Foundation.
41434:  * Portions created by the Initial Developer are Copyright (C) 2010
41434:  * the Initial Developer. All Rights Reserved.
41434:  *
41434:  * Contributor(s):
41434:  *   Bas Schouten <bschouten@mozilla.com>
41434:  *   Matt Woodrow <mwoodrow@mozilla.com>
41434:  *
41434:  * Alternatively, the contents of this file may be used under the terms of
41434:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41434:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41434:  * in which case the provisions of the GPL or the LGPL are applicable instead
41434:  * of those above. If you wish to allow use of your version of this file only
41434:  * under the terms of either the GPL or the LGPL, and not to allow others to
41434:  * use your version of this file under the terms of the MPL, indicate your
41434:  * decision by deleting the provisions above and replace them with the notice
41434:  * and other provisions required by the GPL or the LGPL. If you do not delete
41434:  * the provisions above, a recipient may use your version of this file under
41434:  * the terms of any one of the MPL, the GPL or the LGPL.
41434:  *
41434:  * ***** END LICENSE BLOCK ***** */
41434: 
41434: #include "GLContextProvider.h"
41434: #include "nsDebug.h"
41434: #include "nsIWidget.h"
41434: #include "OpenGL/OpenGL.h"
41434: #include <OpenGL/gl.h>
41434: #include <AppKit/NSOpenGL.h>
44173: #include "gfxASurface.h"
46980: #include "gfxImageSurface.h"
57348: #include "gfxQuartzSurface.h"
46980: #include "gfxPlatform.h"
62107: #include "gfxFailure.h"
57545: #include "prenv.h"
80611: #include "mozilla/Preferences.h"
87692: #include "sampler.h"
41434: 
41434: namespace mozilla {
41434: namespace gl {
41434: 
79445: static bool gUseDoubleBufferedWindows = true;
57545: 
41434: class CGLLibrary
41434: {
41434: public:
47908:     CGLLibrary()
80486:       : mInitialized(false),
47908:         mOGLLibrary(nsnull),
47908:         mPixelFormat(nsnull)
47908:     { }
41434: 
79445:     bool EnsureInitialized()
41434:     {
41434:         if (mInitialized) {
80486:             return true;
41434:         }
41434:         if (!mOGLLibrary) {
41434:             mOGLLibrary = PR_LoadLibrary("/System/Library/Frameworks/OpenGL.framework/OpenGL");
41434:             if (!mOGLLibrary) {
41434:                 NS_WARNING("Couldn't load OpenGL Framework.");
80486:                 return false;
41434:             }
41434:         }
41434: 
57545:         const char* db = PR_GetEnv("MOZ_CGL_DB");
57545:         gUseDoubleBufferedWindows = (!db || *db != '0');
57545: 
80486:         mInitialized = true;
80486:         return true;
41434:     }
41434: 
47908:     NSOpenGLPixelFormat *PixelFormat()
47908:     {
47908:         if (mPixelFormat == nsnull) {
47908:             NSOpenGLPixelFormatAttribute attribs[] = {
47908:                 NSOpenGLPFAAccelerated,
78889:                 NSOpenGLPFAAllowOfflineRenderers,
57545:                 NSOpenGLPFADoubleBuffer,
98271:                 0
47908:             };
47908: 
57545:             if (!gUseDoubleBufferedWindows) {
98271:               attribs[2] = 0;
57545:             }
57545: 
47908:             mPixelFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes:attribs];
47908:         }
47908: 
47908:         return mPixelFormat;
47908:     }
41434: private:
79445:     bool mInitialized;
41434:     PRLibrary *mOGLLibrary;
47908:     NSOpenGLPixelFormat *mPixelFormat;
41434: }; 
41434: 
41434: CGLLibrary sCGLLibrary;
41434: 
41434: class GLContextCGL : public GLContext
41434: {
47908:     friend class GLContextProviderCGL;
47908: 
41434: public:
47908:     GLContextCGL(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  NSOpenGLContext *aContext,
79445:                  bool aIsOffscreen = false)
47908:         : GLContext(aFormat, aIsOffscreen, aShareContext),
47908:           mContext(aContext),
47908:           mPBuffer(nsnull),
47908:           mTempTextureName(0)
42402:     { }
42402: 
47908:     GLContextCGL(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  NSOpenGLContext *aContext,
47908:                  NSOpenGLPixelBuffer *aPixelBuffer)
80486:         : GLContext(aFormat, true, aShareContext),
47908:           mContext(aContext),
47908:           mPBuffer(aPixelBuffer),
47908:           mTempTextureName(0)
42402:     { }
41434: 
41434:     ~GLContextCGL()
41434:     {
54505:         MarkDestroyed();
47908: 
42402:         if (mContext)
41434:             [mContext release];
42402: 
47908:         if (mPBuffer)
47908:             [mPBuffer release];
47908:     }
42402: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeCGL;
41434:     }
41434: 
79445:     bool Init()
41434:     {
41434:         MakeCurrent();
92137:         if (!InitWithPrefix("gl", true))
92137:             return false;
92137: 
92137:         InitFramebuffers();
92137:         return true;
41434:     }
41434: 
42402:     void *GetNativeData(NativeDataType aType)
41434:     { 
42402:         switch (aType) {
42402:         case NativeGLContext:
41434:             return mContext;
42402: 
42402:         default:
42402:             return nsnull;
42402:         }
41434:     }
41434: 
98361:     bool MakeCurrentImpl(bool aForce = false)
41434:     {
98361:         if (!aForce && [NSOpenGLContext currentContext] == mContext) {
98361:             return true;
98361:         }
98361: 
42402:         if (mContext) {
41434:             [mContext makeCurrentContext];
42402:         }
80486:         return true;
41434:     }
41434: 
79445:     bool SetupLookupFunction()
41434:     {
80486:         return false;
41434:     }
41434: 
79445:     bool IsDoubleBuffered() 
57545:     { 
57545:       return gUseDoubleBufferedWindows; 
57545:     }
57545: 
82479:     bool SupportsRobustness()
82479:     {
82479:         return false;
82479:     }
82479: 
79445:     bool SwapBuffers()
57545:     {
87692:       SAMPLE_LABEL("GLContext", "SwapBuffers");
57545:       [mContext flushBuffer];
80486:       return true;
57545:     }
57545: 
79445:     bool BindTex2DOffscreen(GLContext *aOffscreen);
47908:     void UnbindTex2DOffscreen(GLContext *aOffscreen);
79445:     bool ResizeOffscreen(const gfxIntSize& aNewSize);
47908: 
46980:     virtual already_AddRefed<TextureImage>
46980:     CreateBasicTextureImage(GLuint aTexture,
46980:                             const nsIntSize& aSize,
57421:                             GLenum aWrapMode,
46980:                             TextureImage::ContentType aContentType,
98144:                             GLContext* aContext,
98144:                             TextureImage::Flags aFlags = TextureImage::NoFlags);
46980: 
41434:     NSOpenGLContext *mContext;
47908:     NSOpenGLPixelBuffer *mPBuffer;
47908:     GLuint mTempTextureName;
41434: };
41434: 
79445: bool
47908: GLContextCGL::BindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     if (aOffscreen->GetContextType() != ContextTypeCGL) {
47908:         NS_WARNING("non-CGL context");
80486:         return false;
47908:     }
47908: 
47908:     if (!aOffscreen->IsOffscreen()) {
47908:         NS_WARNING("non-offscreen context");
80486:         return false;
47908:     }
47908: 
47908:     GLContextCGL *offs = static_cast<GLContextCGL*>(aOffscreen);
47908: 
47908:     if (offs->mPBuffer) {
47908:         fGenTextures(1, &mTempTextureName);
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, mTempTextureName);
47908: 
47908:         [mContext
47908:          setTextureImageToPixelBuffer:offs->mPBuffer
47908:          colorBuffer:LOCAL_GL_FRONT];
47908:     } else if (offs->mOffscreenTexture) {
47908:         if (offs->GetSharedContext() != GLContextProviderCGL::GetGlobalContext())
47908:         {
47908:             NS_WARNING("offscreen FBO context can only be bound with context sharing!");
80486:             return false;
47908:         }
47908: 
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, offs->mOffscreenTexture);
47908:     } else {
47908:         NS_WARNING("don't know how to bind this!");
80486:         return false;
47908:     }
47908: 
80486:     return true;
47908: }
47908: 
47908: void
47908: GLContextCGL::UnbindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     NS_ASSERTION(aOffscreen->GetContextType() == ContextTypeCGL, "wrong type");
47908: 
47908:     GLContextCGL *offs = static_cast<GLContextCGL*>(aOffscreen);
47908:     if (offs->mPBuffer) {
47908:         NS_ASSERTION(mTempTextureName, "We didn't have an offscreen texture name?");
47908:         fDeleteTextures(1, &mTempTextureName);
47908:         mTempTextureName = 0;
47908:     }
47908: }
47908: 
79445: bool
47908: GLContextCGL::ResizeOffscreen(const gfxIntSize& aNewSize)
47908: {
80612:     if (!IsOffscreenSizeAllowed(aNewSize))
80612:         return false;
80612: 
47908:     if (mPBuffer) {
47908:         NSOpenGLPixelBuffer *pb = [[NSOpenGLPixelBuffer alloc]
47908:                                    initWithTextureTarget:LOCAL_GL_TEXTURE_2D
47908:                                    textureInternalFormat:(mCreationFormat.alpha ? LOCAL_GL_RGBA : LOCAL_GL_RGB)
47908:                                    textureMaxMipMapLevel:0
47908:                                    pixelsWide:aNewSize.width
47908:                                    pixelsHigh:aNewSize.height];
47908:         if (!pb) {
80486:             return false;
47908:         }
47908: 
96935:         if (!ResizeOffscreenFBOs(aNewSize, false)) {
84114:             [pb release];
80618:             return false;
80618:         }
80618: 
47908:         [mPBuffer release];
47908:         mPBuffer = pb;
47908: 
47908:         mOffscreenSize = aNewSize;
47908:         mOffscreenActualSize = aNewSize;
47908: 
47908:         [mContext setPixelBuffer:pb cubeMapFace:0 mipMapLevel:0
47908:          currentVirtualScreen:[mContext currentVirtualScreen]];
47908: 
47908:         MakeCurrent();
47908:         ClearSafely();
47908: 
80486:         return true;
47908:     }
47908: 
96935:     return ResizeOffscreenFBOs(aNewSize, true);
47908: }
47908: 
46980: class TextureImageCGL : public BasicTextureImage
46980: {
46980:     friend already_AddRefed<TextureImage>
46980:     GLContextCGL::CreateBasicTextureImage(GLuint,
46980:                                           const nsIntSize&,
57421:                                           GLenum,
46980:                                           TextureImage::ContentType,
98144:                                           GLContext*,
98144:                                           TextureImage::Flags);
59442: public:
59442:     ~TextureImageCGL()
59442:     {
59442:         if (mPixelBuffer) {
59797:             mGLContext->MakeCurrent();
59442:             mGLContext->fDeleteBuffers(1, &mPixelBuffer);
59442:         }
59442:     }
46980: 
46980: protected:
59442:     already_AddRefed<gfxASurface>
59442:     GetSurfaceForUpdate(const gfxIntSize& aSize, ImageFormat aFmt)
57351:     {
97082:         gfxIntSize size(aSize.width + 1, aSize.height + 1);
59797:         mGLContext->MakeCurrent();
60713:         if (!mGLContext->
60713:             IsExtensionSupported(GLContext::ARB_pixel_buffer_object)) 
60713:         {
59442:             return gfxPlatform::GetPlatform()->
97082:                 CreateOffscreenSurface(size,
60713:                                        gfxASurface::ContentFromFormat(aFmt));
57351:         }
57351: 
59442:         if (!mPixelBuffer) {
59442:             mGLContext->fGenBuffers(1, &mPixelBuffer);
59442:         }
59442:         mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, mPixelBuffer);
97082:         PRInt32 length = size.width * 4 * size.height;
59442: 
97082:         if (length > mPixelBufferSize) {
97082:             mGLContext->fBufferData(LOCAL_GL_PIXEL_UNPACK_BUFFER, length,
59442:                                     NULL, LOCAL_GL_STREAM_DRAW);
97082:             mPixelBufferSize = length;
59442:         }
59442:         unsigned char* data = 
60713:             (unsigned char*)mGLContext->
60713:                 fMapBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 
60713:                            LOCAL_GL_WRITE_ONLY);
59442: 
60740:         mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 0);
60740: 
59442:         if (!data) {
62107:             nsCAutoString failure;
62107:             failure += "Pixel buffer binding failed: ";
97082:             failure.AppendPrintf("%dx%d\n", size.width, size.height);
62107:             gfx::LogFailure(failure);
62107: 
60713:             mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 0);
60713:             return gfxPlatform::GetPlatform()->
97082:                 CreateOffscreenSurface(size,
60713:                                        gfxASurface::ContentFromFormat(aFmt));
59439:         }
59439: 
59442:         nsRefPtr<gfxQuartzSurface> surf = 
97082:             new gfxQuartzSurface(data, size, size.width * 4, aFmt);
57351: 
60713:         mBoundPixelBuffer = true;
59442:         return surf.forget();
57351:     }
57351:   
59442:     bool FinishedSurfaceUpdate()
57434:     {
60713:         if (mBoundPixelBuffer) {
59797:             mGLContext->MakeCurrent();
60740:             mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, mPixelBuffer);
59442:             mGLContext->fUnmapBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER);
59442:             return true;
57434:         }
59442:         return false;
57351:     }
57351: 
59442:     void FinishedSurfaceUpload()
57351:     {
60713:         if (mBoundPixelBuffer) {
59797:             mGLContext->MakeCurrent();
59442:             mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 0);
60713:             mBoundPixelBuffer = false;
57351:         }
46980:     }
46980: 
46980: private:
46980:     TextureImageCGL(GLuint aTexture,
46980:                     const nsIntSize& aSize,
57421:                     GLenum aWrapMode,
46980:                     ContentType aContentType,
98144:                     GLContext* aContext,
98144:                     TextureImage::Flags aFlags = TextureImage::NoFlags)
98144:         : BasicTextureImage(aTexture, aSize, aWrapMode, aContentType, aContext, aFlags)
59442:         , mPixelBuffer(0)
59442:         , mPixelBufferSize(0)
60713:         , mBoundPixelBuffer(false)
46980:     {}
46980:     
59442:     GLuint mPixelBuffer;
59442:     PRInt32 mPixelBufferSize;
60713:     bool mBoundPixelBuffer;
46980: };
46980: 
46980: already_AddRefed<TextureImage>
46980: GLContextCGL::CreateBasicTextureImage(GLuint aTexture,
46980:                                       const nsIntSize& aSize,
57421:                                       GLenum aWrapMode,
46980:                                       TextureImage::ContentType aContentType,
98144:                                       GLContext* aContext,
98144:                                       TextureImage::Flags aFlags)
46980: {
57421:     nsRefPtr<TextureImageCGL> teximage
98144:         (new TextureImageCGL(aTexture, aSize, aWrapMode, aContentType, aContext, aFlags));
46980:     return teximage.forget();
46980: }
46980: 
47908: static GLContextCGL *
47908: GetGlobalContextCGL()
47908: {
47908:     return static_cast<GLContextCGL*>(GLContextProviderCGL::GetGlobalContext());
47908: }
47908: 
41434: already_AddRefed<GLContext>
47907: GLContextProviderCGL::CreateForWindow(nsIWidget *aWidget)
41434: {
41434:     if (!sCGLLibrary.EnsureInitialized()) {
41434:         return nsnull;
41434:     }
41434: 
47908:     GLContextCGL *shareContext = GetGlobalContextCGL();
47908: 
41434:     NSOpenGLContext *context = [[NSOpenGLContext alloc] 
47908:                                 initWithFormat:sCGLLibrary.PixelFormat()
47908:                                 shareContext:(shareContext ? shareContext->mContext : NULL)];
47908:     if (!context) {
41434:         return nsnull;
41434:     }
41434: 
47908:     NSView *childView = (NSView *)aWidget->GetNativeData(NS_NATIVE_WIDGET);
47908:     [context setView:childView];
47908: 
54467:     // make the context transparent
54777:     nsRefPtr<GLContextCGL> glContext = new GLContextCGL(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                         shareContext,
47908:                                                         context);
41434:     if (!glContext->Init()) {
41434:         return nsnull;
41434:     }
41434: 
47908:     return glContext.forget();
41434: }
41434: 
47908: static already_AddRefed<GLContextCGL>
47908: CreateOffscreenPBufferContext(const gfxIntSize& aSize,
47908:                               const ContextFormat& aFormat,
79445:                               bool aShare = false)
41434: {
42402:     if (!sCGLLibrary.EnsureInitialized()) {
41434:         return nsnull;
41434:     }
41434: 
47908:     GLContextCGL *shareContext = aShare ? GetGlobalContextCGL() : nsnull;
47908:     if (aShare && !shareContext) {
42402:         return nsnull;
42402:     }
42402: 
47908:     nsTArray<NSOpenGLPixelFormatAttribute> attribs;
47908: 
47908: #define A_(_x)  attribs.AppendElement(NSOpenGLPixelFormatAttribute(_x))
47908:     A_(NSOpenGLPFAAccelerated);
47908:     A_(NSOpenGLPFAPixelBuffer);
47908:     A_(NSOpenGLPFAMinimumPolicy);
47908: 
47908:     A_(NSOpenGLPFAColorSize);
47908:     A_(aFormat.colorBits());
47908: 
47908:     A_(NSOpenGLPFAAlphaSize);
47908:     A_(aFormat.alpha);
47908: 
47908:     A_(NSOpenGLPFADepthSize);
47908:     A_(aFormat.depth);
47908: 
47908:     A_(NSOpenGLPFAStencilSize);
47908:     A_(aFormat.stencil);
47908: 
47908:     A_(0);
47908: #undef A_
47908: 
47908:     NSOpenGLPixelFormat *pbFormat = [[NSOpenGLPixelFormat alloc]
47908:                                      initWithAttributes:attribs.Elements()];
47908:     if (!pbFormat) {
42402:         return nsnull;
42402:     }
42402: 
81134:     // If we ask for any of these to be on/off and we get the opposite, we stop
81134:     // creating a pbuffer and instead create an FBO.
81134:     GLint alphaBits, depthBits, stencilBits;
81134:     [pbFormat getValues: &alphaBits forAttribute: NSOpenGLPFAAlphaSize forVirtualScreen: 0];
81134:     [pbFormat getValues: &depthBits forAttribute: NSOpenGLPFADepthSize forVirtualScreen: 0];
81134:     [pbFormat getValues: &stencilBits forAttribute: NSOpenGLPFAStencilSize forVirtualScreen: 0];
81134:     if ((alphaBits && !aFormat.alpha) || (!alphaBits && aFormat.alpha) ||
81134:         (depthBits && !aFormat.alpha) || (!depthBits && aFormat.depth) ||
81134:         (stencilBits && !aFormat.stencil) || (!stencilBits && aFormat.stencil)) 
81134:     {
81134:         [pbFormat release];
81134:         return nsnull;
81134:     }
81134: 
47908:     NSOpenGLPixelBuffer *pb = [[NSOpenGLPixelBuffer alloc]
47908:                                initWithTextureTarget:LOCAL_GL_TEXTURE_2D
47908:                                textureInternalFormat:(aFormat.alpha ? LOCAL_GL_RGBA : LOCAL_GL_RGB)
47908:                                textureMaxMipMapLevel:0
47908:                                pixelsWide:aSize.width
47908:                                pixelsHigh:aSize.height];
47908:     if (!pb) {
47908:         [pbFormat release];
42402:         return nsnull;
42402:     }
42402: 
47908:     NSOpenGLContext *context = [[NSOpenGLContext alloc]
47908:                                 initWithFormat:pbFormat
47908:                                 shareContext:shareContext ? shareContext->mContext : NULL];
47908:     if (!context) {
47908:         [pbFormat release];
47908:         [pb release];
42402:         return nsnull;
42402:     }
42402: 
47908:     [context
47908:      setPixelBuffer:pb
47908:      cubeMapFace:0
47908:      mipMapLevel:0
47908:      currentVirtualScreen:[context currentVirtualScreen]];
47908: 
47908:     {
47908:         GLint l;
47908:         [pbFormat getValues:&l forAttribute:NSOpenGLPFADepthSize forVirtualScreen:[context currentVirtualScreen]];
47908:     }
47908: 
47908:     [pbFormat release];
47908: 
47908:     nsRefPtr<GLContextCGL> glContext = new GLContextCGL(aFormat, shareContext, context, pb);
92137: 
47908:     return glContext.forget();
47908: }
47908: 
47908: static already_AddRefed<GLContextCGL>
80618: CreateOffscreenFBOContext(const ContextFormat& aFormat,
79445:                           bool aShare = true)
47908: {
47908:     if (!sCGLLibrary.EnsureInitialized()) {
42402:         return nsnull;
42402:     }
42402: 
47908:     GLContextCGL *shareContext = aShare ? GetGlobalContextCGL() : nsnull;
47908:     if (aShare && !shareContext) {
47908:         // if there is no share context, then we can't use FBOs.
42402:         return nsnull;
42402:     }
42402: 
47908:     NSOpenGLContext *context = [[NSOpenGLContext alloc]
47908:                                 initWithFormat:sCGLLibrary.PixelFormat()
47908:                                 shareContext:shareContext ? shareContext->mContext : NULL];
47908:     if (!context) {
47908:         return nsnull;
47908:     }
47908: 
80486:     nsRefPtr<GLContextCGL> glContext = new GLContextCGL(aFormat, shareContext, context, true);
92137: 
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderCGL::CreateOffscreen(const gfxIntSize& aSize,
93720:                                       const ContextFormat& aFormat,
93720:                                       const ContextFlags flags)
47908: {
80618:     ContextFormat actualFormat(aFormat);
80618: 
47908:     nsRefPtr<GLContextCGL> glContext;
47908:     
80611:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), nsnull);
82710:     const bool preferFBOs = Preferences::GetBool("cgl.prefer-fbo", true);
80611:     if (!preferFBOs)
80611:     {
80618:         glContext = CreateOffscreenPBufferContext(aSize, actualFormat);
47908:         if (glContext &&
80618:             glContext->Init() &&
96935:             glContext->ResizeOffscreenFBOs(aSize, false))
47908:         {
47908:             glContext->mOffscreenSize = aSize;
47908:             glContext->mOffscreenActualSize = aSize;
47908: 
47908:             return glContext.forget();
47908:         }
80611:     }
47908: 
47908:     // try a FBO as second choice
80618:     glContext = CreateOffscreenFBOContext(actualFormat);
47908:     if (glContext &&
47908:         glContext->Init() &&
96935:         glContext->ResizeOffscreenFBOs(aSize, true))
47908:     {
47908:         return glContext.forget();
47908:     }
47908: 
47908:     // everything failed
47908:     return nsnull;
42402: }
42402: 
44173: already_AddRefed<GLContext>
47907: GLContextProviderCGL::CreateForNativePixmapSurface(gfxASurface *aSurface)
44173: {
44173:     return nsnull;
44173: }
44173: 
47908: static nsRefPtr<GLContext> gGlobalContext;
47908: 
47908: GLContext *
47908: GLContextProviderCGL::GetGlobalContext()
47908: {
47908:     if (!sCGLLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     if (!gGlobalContext) {
47908:         // There are bugs in some older drivers with pbuffers less
47908:         // than 16x16 in size; also 16x16 is POT so that we can do
47908:         // a FBO with it on older video cards.  A FBO context for
47908:         // sharing is preferred since it has no associated target.
80618:         gGlobalContext = CreateOffscreenFBOContext(ContextFormat(ContextFormat::BasicRGB24),
80486:                                                    false);
52381:         if (!gGlobalContext || !static_cast<GLContextCGL*>(gGlobalContext.get())->Init()) {
48176:             NS_WARNING("Couldn't init gGlobalContext.");
48176:             gGlobalContext = nsnull;
48176:             return nsnull; 
48176:         }
49071: 
80486:         gGlobalContext->SetIsGlobalSharedContext(true);
47908:     }
47908: 
47908:     return gGlobalContext;
47908: }
47908: 
47967: void
47967: GLContextProviderCGL::Shutdown()
47967: {
51964:   gGlobalContext = nsnull;
47967: }
47967: 
41434: } /* namespace gl */
41434: } /* namespace mozilla */
