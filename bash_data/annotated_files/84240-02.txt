    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Uri Bernstein <uriber@gmail.com>
    1:  *   Haamed Gheibi <gheibi@metanetworking.com>
24437:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef IBMBIDI
    1: 
    1: #include "nsBidiPresUtils.h"
    1: #include "nsTextFragment.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPresContext.h"
68481: #include "nsRenderingContext.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsFrameManager.h"
    1: #include "nsBidiUtils.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsInlineFrame.h"
 5421: #include "nsPlaceholderFrame.h"
32841: #include "nsContainerFrame.h"
39530: #include "nsFirstLetterFrame.h"
59830: #include "gfxUnicodeProperties.h"
71482: #include "nsTextFrame.h"
63806: 
67826: #undef NOISY_BIDI
67826: #undef REALLY_NOISY_BIDI
67826: 
39965: using namespace mozilla;
39965: 
    1: static const PRUnichar kSpace            = 0x0020;
    1: static const PRUnichar kLineSeparator    = 0x2028;
    1: static const PRUnichar kObjectSubstitute = 0xFFFC;
    1: static const PRUnichar kLRE              = 0x202A;
    1: static const PRUnichar kRLE              = 0x202B;
    1: static const PRUnichar kLRO              = 0x202D;
    1: static const PRUnichar kRLO              = 0x202E;
    1: static const PRUnichar kPDF              = 0x202C;
    1: 
71474: #define NS_BIDI_CONTROL_FRAME ((nsIFrame*)0xfffb1d1)
68407: 
73724: struct BidiParagraphData {
73724:   nsString            mBuffer;
73724:   nsAutoTArray<PRUnichar, 16> mEmbeddingStack;
73724:   nsTArray<nsIFrame*> mLogicalFrames;
73724:   nsTArray<nsLineBox*> mLinePerFrame;
73724:   nsDataHashtable<nsISupportsHashKey, PRInt32> mContentToFrameIndex;
79445:   bool                mIsVisual;
84240:   bool                mReset;
73724:   nsBidiLevel         mParaLevel;
73724:   nsIContent*         mPrevContent;
73724:   nsAutoPtr<nsBidi>   mBidiEngine;
73724:   nsIFrame*           mPrevFrame;
80541:   nsAutoPtr<BidiParagraphData> mSubParagraph;
73724: 
73724:   void Init(nsBlockFrame *aBlockFrame)
    1:   {
73724:     mContentToFrameIndex.Init();
    1:     mBidiEngine = new nsBidi();
73724:     mPrevContent = nsnull;
80543: 
80543:     bool styleDirectionIsRTL =
80543:       (NS_STYLE_DIRECTION_RTL == aBlockFrame->GetStyleVisibility()->mDirection);
80543:     if (aBlockFrame->GetStyleTextReset()->mUnicodeBidi &
80543:         NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
80543:       // unicode-bidi: plaintext: the Bidi algorithm will determine the
80543:       // directionality of the paragraph according to the first strong
80543:       // directional character.
80543:       mParaLevel = styleDirectionIsRTL ? NSBIDI_DEFAULT_RTL : NSBIDI_DEFAULT_LTR;
80543:     } else {
80543:       mParaLevel = styleDirectionIsRTL ? NSBIDI_RTL : NSBIDI_LTR;
80543:     }
73724: 
73724:     mIsVisual = aBlockFrame->PresContext()->IsVisualMode();
73724:     if (mIsVisual) {
73724:       /**
73724:        * Drill up in content to detect whether this is an element that needs to
73724:        * be rendered with logical order even on visual pages.
73724:        *
73724:        * We always use logical order on form controls, firstly so that text
73724:        * entry will be in logical order, but also because visual pages were
73724:        * written with the assumption that even if the browser had no support
73724:        * for right-to-left text rendering, it would use native widgets with
73724:        * bidi support to display form controls.
73724:        *
73724:        * We also use logical order in XUL elements, since we expect that if a
73724:        * XUL element appears in a visual page, it will be generated by an XBL
73724:        * binding and contain localized text which will be in logical order.
73724:        */
73724:       for (nsIContent* content = aBlockFrame->GetContent() ; content; 
73724:            content = content->GetParent()) {
73724:         if (content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL) ||
73724:             content->IsXUL()) {
80486:           mIsVisual = false;
73724:           break;
73724:         }
73724:       }
    1:     }
    1:   }
    1: 
80541:   BidiParagraphData* GetSubParagraph()
80541:   {
80541:     if (!mSubParagraph) {
80541:       mSubParagraph = new BidiParagraphData();
80541:       mSubParagraph->Init(this);
80541:     }
80541: 
80541:     return mSubParagraph;
80541:   }
80541: 
80541:   // Initialise a sub-paragraph from its containing paragraph
80541:   void Init(BidiParagraphData *aBpd)
80541:   {
80541:     mContentToFrameIndex.Init();
80541:     mBidiEngine = new nsBidi();
80541:     mPrevContent = nsnull;
80541:     mIsVisual = aBpd->mIsVisual;
80541:     mParaLevel = aBpd->mParaLevel;
80543: 
80543:     // If the containing paragraph has a level of NSBIDI_DEFAULT_LTR/RTL, set
80543:     // the sub-paragraph to the corresponding non-default level (We can't use
80543:     // GetParaLevel, because the containing paragraph hasn't yet been through
80543:     // bidi resolution
80543:     if (IS_DEFAULT_LEVEL(mParaLevel)) {
80543:       mParaLevel = (mParaLevel == NSBIDI_DEFAULT_RTL) ? NSBIDI_RTL : NSBIDI_LTR;
80543:     }                    
84240:     mReset = false;
80541:   }
80541: 
80541:   void Reset(nsIFrame* aFrame, BidiParagraphData *aBpd)
80541:   {
84240:     mReset = true;
80541:     mLogicalFrames.Clear();
80541:     mLinePerFrame.Clear();
80541:     mContentToFrameIndex.Clear();
80541:     mBuffer.SetLength(0);
80541:     mPrevFrame = aBpd->mPrevFrame;
80541:     // We need to copy in embeddings (but not overrides!) from the containing
80541:     // paragraph so that the line(s) including this sub-paragraph will be
80541:     // correctly reordered.
80541:     for (PRUint32 i = 0; i < aBpd->mEmbeddingStack.Length(); ++i) {
80541:       switch(aBpd->mEmbeddingStack[i]) {
80541:         case kRLE:
80541:         case kRLO:
80541:           mParaLevel = NextOddLevel(mParaLevel);
80541:           break;
80541: 
80541:         case kLRE:
80541:         case kLRO:
80541:           mParaLevel = NextEvenLevel(mParaLevel);
80541:           break;
80541: 
80541:         default:
80541:           break;
80541:       }
80541:     }
80541: 
80541:     nsIFrame* container = aFrame->GetParent();
80541:     bool isRTL = (NS_STYLE_DIRECTION_RTL ==
80541:                   container->GetStyleVisibility()->mDirection);
80541:     if ((isRTL & 1) != (mParaLevel & 1)) {
80541:       mParaLevel = isRTL ? NextOddLevel(mParaLevel) : NextEvenLevel(mParaLevel);
80541:     }
80541: 
80541:     if (container->GetStyleTextReset()->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_OVERRIDE) {
80541:       PushBidiControl(isRTL ? kRLO : kLRO);
80541:     } else {
80541:       PushBidiControl(isRTL ? kRLE : kLRE);
80541:     }
80541:   }
80541: 
73724:   nsresult SetPara()
    1:   {
73724:     return mBidiEngine->SetPara(mBuffer.get(), BufferLength(),
73724:                                 mParaLevel, nsnull);
    1:   }
    1: 
80543:   /**
80543:    * mParaLevel can be NSBIDI_DEFAULT_LTR or NSBIDI_DEFAULT_RTL.
80543:    * GetParaLevel() returns the actual (resolved) paragraph level which is
80543:    * always either NSBIDI_LTR or NSBIDI_RTL
80543:    */
80543:   nsBidiLevel GetParaLevel()
80543:   {
80543:     nsBidiLevel paraLevel = mParaLevel;
80543:     if (IS_DEFAULT_LEVEL(paraLevel)) {
80543:       mBidiEngine->GetParaLevel(&paraLevel);
80543:     }
80543:     return paraLevel;
80543:   }
80543: 
73724:   nsresult CountRuns(PRInt32 *runCount){ return mBidiEngine->CountRuns(runCount); }
73724: 
73724:   nsresult GetLogicalRun(PRInt32 aLogicalStart, 
73724:                          PRInt32* aLogicalLimit,
73724:                          nsBidiLevel* aLevel)
    1:   {
73724:     nsresult rv = mBidiEngine->GetLogicalRun(aLogicalStart,
73724:                                              aLogicalLimit, aLevel);
73724:     if (mIsVisual || NS_FAILED(rv))
80543:       *aLevel = GetParaLevel();
73724:     return rv;
    1:   }
    1: 
73724:   void ResetData()
73724:   {
73724:     mLogicalFrames.Clear();
73724:     mLinePerFrame.Clear();
73724:     mContentToFrameIndex.Clear();
73724:     mBuffer.SetLength(0);
73724:     mPrevContent = nsnull;
73724:     for (PRUint32 i = 0; i < mEmbeddingStack.Length(); ++i) {
73724:       mBuffer.Append(mEmbeddingStack[i]);
73724:       mLogicalFrames.AppendElement(NS_BIDI_CONTROL_FRAME);
73724:       mLinePerFrame.AppendElement((nsLineBox*)nsnull);
73724:     }
73724:   }
73724: 
73724:   void AppendFrame(nsIFrame* aFrame,
73724:                    nsBlockInFlowLineIterator* aLineIter,
73724:                    nsIContent* aContent = nsnull)
73724:   {
73724:     if (aContent) {
73724:       mContentToFrameIndex.Put(aContent, FrameCount());
73724:     }
73724:     mLogicalFrames.AppendElement(aFrame);
73724: 
73724:     AdvanceLineIteratorToFrame(aFrame, aLineIter, mPrevFrame);
73724:     mLinePerFrame.AppendElement(aLineIter->GetLine().get());
73724:   }
73724: 
73724:   void AdvanceAndAppendFrame(nsIFrame** aFrame,
73724:                              nsBlockInFlowLineIterator* aLineIter,
73724:                              nsIFrame** aNextSibling)
73724:   {
73724:     nsIFrame* frame = *aFrame;
73724:     nsIFrame* nextSibling = *aNextSibling;
73724: 
73724:     frame = frame->GetNextContinuation();
73724:     if (frame) {
73724:       AppendFrame(frame, aLineIter, nsnull);
73724: 
73724:       /*
73724:        * If we have already overshot the saved next-sibling while
73724:        * scanning the frame's continuations, advance it.
73724:        */
73724:       if (frame == nextSibling) {
73724:         nextSibling = frame->GetNextSibling();
73724:       }
73724:     }
73724: 
73724:     *aFrame = frame;
73724:     *aNextSibling = nextSibling;
73724:   }
73724: 
73724:   PRInt32 GetLastFrameForContent(nsIContent *aContent)
73724:   {
73724:     PRInt32 index = 0;
73724:     mContentToFrameIndex.Get(aContent, &index);
73724:     return index;
73724:   }
73724: 
73724:   PRInt32 FrameCount(){ return mLogicalFrames.Length(); }
73724: 
73724:   PRInt32 BufferLength(){ return mBuffer.Length(); }
73724: 
73724:   nsIFrame* FrameAt(PRInt32 aIndex){ return mLogicalFrames[aIndex]; }
73724: 
73724:   nsLineBox* GetLineForFrameAt(PRInt32 aIndex){ return mLinePerFrame[aIndex]; }
73724: 
73724:   void AppendUnichar(PRUnichar aCh){ mBuffer.Append(aCh); }
73724: 
73724:   void AppendString(const nsDependentSubstring& aString){ mBuffer.Append(aString); }
73724: 
80542:   void AppendControlChar(PRUnichar aCh)
73724:   {
80542:     mLogicalFrames.AppendElement(NS_BIDI_CONTROL_FRAME);
73724:     mLinePerFrame.AppendElement((nsLineBox*)nsnull);
73724:     AppendUnichar(aCh);
73724:   }
73724: 
73724:   void PushBidiControl(PRUnichar aCh)
73724:   {
80542:     AppendControlChar(aCh);
73724:     mEmbeddingStack.AppendElement(aCh);
73724:   }
73724: 
73724:   void PopBidiControl()
73724:   {
80542:     AppendControlChar(kPDF);
73724:     NS_ASSERTION(mEmbeddingStack.Length(), "embedding/override underflow");
73724:     mEmbeddingStack.TruncateLength(mEmbeddingStack.Length() - 1);
73724:   }
73724: 
73724:   void ClearBidiControls()
73724:   {
73724:     for (PRUint32 i = 0; i < mEmbeddingStack.Length(); ++i) {
80542:       AppendControlChar(kPDF);
73724:     }
73724:   }
73724: 
80541:   nsBidiLevel NextOddLevel(nsBidiLevel aLevel)
80541:   {
80541:     return (aLevel + 1) | 1;
80541:   }
80541: 
80541:   nsBidiLevel NextEvenLevel(nsBidiLevel aLevel)
80541:   {
80541:     return (aLevel + 2) & ~1;
80541:   }
80541: 
79445:   static bool
73724:   IsFrameInCurrentLine(nsBlockInFlowLineIterator* aLineIter,
73724:                        nsIFrame* aPrevFrame, nsIFrame* aFrame)
73724:   {
73724:     nsIFrame* endFrame = aLineIter->IsLastLineInList() ? nsnull :
73724:       aLineIter->GetLine().next()->mFirstChild;
73724:     nsIFrame* startFrame = aPrevFrame ? aPrevFrame : aLineIter->GetLine()->mFirstChild;
73724:     for (nsIFrame* frame = startFrame; frame && frame != endFrame;
73724:          frame = frame->GetNextSibling()) {
73724:       if (frame == aFrame)
80486:         return true;
73724:     }
80486:     return false;
73724:   }
73724: 
73724:   static void
73724:   AdvanceLineIteratorToFrame(nsIFrame* aFrame,
73724:                              nsBlockInFlowLineIterator* aLineIter,
73724:                              nsIFrame*& aPrevFrame)
73724:   {
73724:     // Advance aLine to the line containing aFrame
73724:     nsIFrame* child = aFrame;
73724:     nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
73724:     nsIFrame* parent = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, child);
73724:     while (parent && !nsLayoutUtils::GetAsBlock(parent)) {
73724:       child = parent;
73724:       parent = nsLayoutUtils::GetParentOrPlaceholderFor(frameManager, child);
73724:     }
73724:     NS_ASSERTION (parent, "aFrame is not a descendent of aBlockFrame");
73724:     while (!IsFrameInCurrentLine(aLineIter, aPrevFrame, child)) {
73724: #ifdef DEBUG
79445:       bool hasNext =
73724: #endif
73724:         aLineIter->Next();
73724:       NS_ASSERTION(hasNext, "Can't find frame in lines!");
73724:       aPrevFrame = nsnull;
73724:     }
73724:     aPrevFrame = child;
73724:   }
73724: 
73724: };
73724: 
73724: struct BidiLineData {
73724:   nsTArray<nsIFrame*> mLogicalFrames;
73724:   nsTArray<nsIFrame*> mVisualFrames;
73724:   nsTArray<PRInt32> mIndexMap;
73724:   nsAutoTArray<PRUint8, 18> mLevels;
79445:   bool mIsReordered;
73724: 
73724:   BidiLineData(nsIFrame* aFirstFrameOnLine, PRInt32   aNumFramesOnLine)
73724:   {
73724:     /**
73724:      * Initialize the logically-ordered array of frames using the top-level
73724:      * frames of a single line
73724:      */
73724:     mLogicalFrames.Clear();
73724: 
79445:     bool isReordered = false;
79445:     bool hasRTLFrames = false;
73724: 
73724:     for (nsIFrame* frame = aFirstFrameOnLine;
73724:          frame && aNumFramesOnLine--;
73724:          frame = frame->GetNextSibling()) {
73724:       AppendFrame(frame);
73724:       PRUint8 level = nsBidiPresUtils::GetFrameEmbeddingLevel(frame);
73724:       mLevels.AppendElement(level);
73724:       mIndexMap.AppendElement(0);
73724:       if (level & 1) {
80486:         hasRTLFrames = true;
73724:       }
73724:     }
73724: 
73724:     // Reorder the line
73724:     nsBidi::ReorderVisual(mLevels.Elements(), FrameCount(),
73724:                           mIndexMap.Elements());
73724: 
73724:     for (PRInt32 i = 0; i < FrameCount(); i++) {
73724:       mVisualFrames.AppendElement(LogicalFrameAt(mIndexMap[i]));
73724:       if (i != mIndexMap[i]) {
80486:         isReordered = true;
73724:       }
73724:     }
73724: 
73724:     // If there's an RTL frame, assume the line is reordered
73724:     mIsReordered = isReordered || hasRTLFrames;
73724:   }
73724: 
73724:   void AppendFrame(nsIFrame* aFrame)
73724:   {
73724:     mLogicalFrames.AppendElement(aFrame); 
73724:   }
73724: 
73724:   PRInt32 FrameCount(){ return mLogicalFrames.Length(); }
73724: 
73724:   nsIFrame* LogicalFrameAt(PRInt32 aIndex){ return mLogicalFrames[aIndex]; }
73724: 
73724:   nsIFrame* VisualFrameAt(PRInt32 aIndex){ return mVisualFrames[aIndex]; }
73724: };
73724: 
    1: /* Some helper methods for Resolve() */
    1: 
    1: // Should this frame be split between text runs?
79445: bool
    1: IsBidiSplittable(nsIFrame* aFrame) {
    1:   nsIAtom* frameType = aFrame->GetType();
    1:   // Bidi inline containers should be split, unless they're line frames.
    1:   return aFrame->IsFrameOfType(nsIFrame::eBidiInlineContainer)
    1:     && frameType != nsGkAtoms::lineFrame;
    1: }
    1: 
    1: static nsresult
 5423: SplitInlineAncestors(nsIFrame*     aFrame)
    1: {
 5423:   nsPresContext *presContext = aFrame->PresContext();
 5423:   nsIPresShell *presShell = presContext->PresShell();
    1:   nsIFrame* frame = aFrame;
    1:   nsIFrame* parent = aFrame->GetParent();
    1:   nsIFrame* newParent;
    1: 
    1:   while (IsBidiSplittable(parent)) {
    1:     nsIFrame* grandparent = parent->GetParent();
    1:     NS_ASSERTION(grandparent, "Couldn't get parent's parent in nsBidiPresUtils::SplitInlineAncestors");
    1:     
    1:     nsresult rv = presShell->FrameConstructor()->
80486:       CreateContinuingFrame(presContext, parent, grandparent, &newParent, false);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:     
32841:     // Split the child list after |frame|.
32841:     nsContainerFrame* container = do_QueryFrame(parent);
32841:     nsFrameList tail = container->StealFramesAfter(frame);
30941: 
30941:     // Reparent views as necessary
68656:     rv = nsContainerFrame::ReparentFrameViewList(presContext, tail, parent, newParent);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:     
32841:     // The parent's continuation adopts the siblings after the split.
77154:     rv = newParent->InsertFrames(nsIFrame::kNoReflowPrincipalList, nsnull, tail);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
77154:     // The list name kNoReflowPrincipalList would indicate we don't want reflow
32841:     nsFrameList temp(newParent, newParent);
77154:     rv = grandparent->InsertFrames(nsIFrame::kNoReflowPrincipalList, parent, temp);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:     
    1:     frame = parent;
    1:     parent = grandparent;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
71482: static void
71482: MakeContinuationFluid(nsIFrame* aFrame, nsIFrame* aNext)
71482: {
71482:   NS_ASSERTION (!aFrame->GetNextInFlow() || aFrame->GetNextInFlow() == aNext, 
71482:                 "next-in-flow is not next continuation!");
71482:   aFrame->SetNextInFlow(aNext);
71482: 
71482:   NS_ASSERTION (!aNext->GetPrevInFlow() || aNext->GetPrevInFlow() == aFrame,
71482:                 "prev-in-flow is not prev continuation!");
71482:   aNext->SetPrevInFlow(aFrame);
71482: }
71482: 
71482: // If aFrame is the last child of its parent, convert bidi continuations to
71482: // fluid continuations for all of its inline ancestors.
13428: static void
13426: JoinInlineAncestors(nsIFrame* aFrame)
13426: {
71482:   if (aFrame->GetNextSibling()) {
71482:     return;
71482:   }
71482:   nsIFrame* frame = aFrame->GetParent();
13426:   while (frame && IsBidiSplittable(frame)) {
13426:     nsIFrame* next = frame->GetNextContinuation();
13426:     if (next) {
71482:       MakeContinuationFluid(frame, next);
13426:     }
13639:     // Join the parent only as long as we're its last child.
13639:     if (frame->GetNextSibling())
13639:       break;
13426:     frame = frame->GetParent();
13426:   }
13426: }
13426: 
    1: static nsresult
71482: CreateContinuation(nsIFrame*  aFrame,
71482:                    nsIFrame** aNewFrame,
79445:                    bool       aIsFluid)
    1: {
    1:   NS_PRECONDITION(aNewFrame, "null OUT ptr");
    1:   NS_PRECONDITION(aFrame, "null ptr");
    1: 
    1:   *aNewFrame = nsnull;
    1: 
 5423:   nsPresContext *presContext = aFrame->PresContext();
 5423:   nsIPresShell *presShell = presContext->PresShell();
71482:   NS_ASSERTION(presShell, "PresShell must be set on PresContext before calling nsBidiPresUtils::CreateContinuation");
    1: 
    1:   nsIFrame* parent = aFrame->GetParent();
71482:   NS_ASSERTION(parent, "Couldn't get frame parent in nsBidiPresUtils::CreateContinuation");
    1: 
39530:   nsresult rv = NS_OK;
    1:   
34443:   // Have to special case floating first letter frames because the continuation
34443:   // doesn't go in the first letter frame. The continuation goes with the rest
34443:   // of the text that the first letter frame was made out of.
34443:   if (parent->GetType() == nsGkAtoms::letterFrame &&
34443:       parent->GetStyleDisplay()->IsFloating()) {
39530:     nsFirstLetterFrame* letterFrame = do_QueryFrame(parent);
39530:     rv = letterFrame->CreateContinuationForFloatingParent(presContext, aFrame,
71482:                                                           aNewFrame, aIsFluid);
39530:     return rv;
34443:   }
34443: 
39530:   rv = presShell->FrameConstructor()->
71482:     CreateContinuingFrame(presContext, aFrame, parent, aNewFrame, aIsFluid);
39530:   if (NS_FAILED(rv)) {
34443:     return rv;
34443:   }
34443: 
77154:   // The list name kNoReflowPrincipalList would indicate we don't want reflow
30941:   // XXXbz this needs higher-level framelist love
32846:   nsFrameList temp(*aNewFrame, *aNewFrame);
77154:   rv = parent->InsertFrames(nsIFrame::kNoReflowPrincipalList, aFrame, temp);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
71482:   if (!aIsFluid) {  
    1:     // Split inline ancestor frames
 5423:     rv = SplitInlineAncestors(aFrame);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
71482:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Overview of the implementation of Resolve():
    1:  *
    1:  *  Walk through the descendants of aBlockFrame and build:
24551:  *   * mLogicalFrames: an nsTArray of nsIFrame* pointers in logical order
71482:  *   * mBuffer: an nsString containing a representation of
    1:  *     the content of the frames.
    1:  *     In the case of text frames, this is the actual text context of the
    1:  *     frames, but some other elements are represented in a symbolic form which
    1:  *     will make the Unicode Bidi Algorithm give the correct results.
    1:  *     Bidi embeddings and overrides set by CSS or <bdo> elements are
    1:  *     represented by the corresponding Unicode control characters.
    1:  *     <br> elements are represented by U+2028 LINE SEPARATOR
    1:  *     Other inline elements are represented by U+FFFC OBJECT REPLACEMENT
    1:  *     CHARACTER
    1:  *
    1:  *  Then pass mBuffer to the Bidi engine for resolving of embedding levels
    1:  *  by nsBidi::SetPara() and division into directional runs by
    1:  *  nsBidi::CountRuns().
    1:  *
    1:  *  Finally, walk these runs in logical order using nsBidi::GetLogicalRun() and
24551:  *  correlate them with the frames indexed in mLogicalFrames, setting the
42116:  *  baseLevel and embeddingLevel properties according to the results returned
42116:  *  by the Bidi engine.
    1:  *
    1:  *  The rendering layer requires each text frame to contain text in only one
42116:  *  direction, so we may need to call EnsureBidiContinuation() to split frames.
42116:  *  We may also need to call RemoveBidiContinuation() to convert frames created
42116:  *  by EnsureBidiContinuation() in previous reflows into fluid continuations.
    1:  */
    1: nsresult
41312: nsBidiPresUtils::Resolve(nsBlockFrame* aBlockFrame)
    1: {
73724:   BidiParagraphData bpd;
73724:   bpd.Init(aBlockFrame);
71475: 
63930:   // handle bidi-override being set on the block itself before calling
71479:   // TraverseFrames.
63930:   const nsStyleTextReset* text = aBlockFrame->GetStyleTextReset();
71473:   PRUnichar ch = 0;
80540:   if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_OVERRIDE) {
73724:     const nsStyleVisibility* vis = aBlockFrame->GetStyleVisibility();
63930:     if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
71473:       ch = kRLO;
63930:     }
63930:     else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
71473:       ch = kLRO;
63809:     }
71473:     if (ch != 0) {
73724:       bpd.PushBidiControl(ch);
63930:     }
63930:   }
63930:   for (nsBlockFrame* block = aBlockFrame; block;
63930:        block = static_cast<nsBlockFrame*>(block->GetNextContinuation())) {
63930:     block->RemoveStateBits(NS_BLOCK_NEEDS_BIDI_RESOLUTION);
80486:     nsBlockInFlowLineIterator lineIter(block, block->begin_lines(), false);
73724:     bpd.mPrevFrame = nsnull;
81310:     bpd.GetSubParagraph()->mPrevFrame = nsnull;
77154:     TraverseFrames(aBlockFrame, &lineIter, block->GetFirstPrincipalChild(), &bpd);
63930:   }
63930: 
71473:   if (ch != 0) {
73724:     bpd.PopBidiControl();
69015:   }
63930: 
73724:   return ResolveParagraph(aBlockFrame, &bpd);
71475: }
69015: 
73724: nsresult
73724: nsBidiPresUtils::ResolveParagraph(nsBlockFrame* aBlockFrame,
73724:                                   BidiParagraphData* aBpd)
71475: {
71475:   nsPresContext *presContext = aBlockFrame->PresContext();
69015: 
73724:   if (aBpd->BufferLength() < 1) {
73724:     return NS_OK;
69015:   }
73724:   aBpd->mBuffer.ReplaceChar("\t\r\n", kSpace);
71479: 
69015:   PRInt32 runCount;
69015: 
73724:   nsresult rv = aBpd->SetPara();
73724:   NS_ENSURE_SUCCESS(rv, rv);
63930: 
80543:   PRUint8 embeddingLevel = aBpd->GetParaLevel();
80543: 
73724:   rv = aBpd->CountRuns(&runCount);
73724:   NS_ENSURE_SUCCESS(rv, rv);
73724: 
63930:   PRInt32     runLength      = 0;   // the length of the current run of text
63930:   PRInt32     lineOffset     = 0;   // the start of the current run
63930:   PRInt32     logicalLimit   = 0;   // the end of the current run + 1
63930:   PRInt32     numRun         = -1;
63930:   PRInt32     fragmentLength = 0;   // the length of the current text frame
63930:   PRInt32     frameIndex     = -1;  // index to the frames in mLogicalFrames
73724:   PRInt32     frameCount     = aBpd->FrameCount();
63930:   PRInt32     contentOffset  = 0;   // offset of current frame in its content node
79445:   bool        isTextFrame    = false;
63930:   nsIFrame*   frame = nsnull;
63930:   nsIContent* content = nsnull;
73724:   PRInt32     contentTextLength = 0;
63930: 
63930:   FramePropertyTable *propTable = presContext->PropertyTable();
71476:   nsLineBox* currentLine = nsnull;
68407:   
67826: #ifdef DEBUG
67826: #ifdef NOISY_BIDI
80541:   printf("Before Resolve(), aBlockFrame=0x%p, mBuffer='%s', frameCount=%d, runCount=%d\n",
80541:          (void*)aBlockFrame, NS_ConvertUTF16toUTF8(aBpd->mBuffer).get(), frameCount, runCount);
67826: #ifdef REALLY_NOISY_BIDI
67826:   printf(" block frame tree=:\n");
67826:   aBlockFrame->List(stdout, 0);
67826: #endif
67826: #endif
67826: #endif
67826: 
    1:   for (; ;) {
    1:     if (fragmentLength <= 0) {
29930:       // Get the next frame from mLogicalFrames
    1:       if (++frameIndex >= frameCount) {
    1:         break;
    1:       }
73724:       frame = aBpd->FrameAt(frameIndex);
71474:       if (frame == NS_BIDI_CONTROL_FRAME ||
71474:           nsGkAtoms::textFrame != frame->GetType()) {
71474:         /*
71474:          * Any non-text frame corresponds to a single character in the text buffer
71474:          * (a bidi control character, LINE SEPARATOR, or OBJECT SUBSTITUTE)
71474:          */
80486:         isTextFrame = false;
71474:         fragmentLength = 1;
71474:       }
71474:       else {
73724:         currentLine = aBpd->GetLineForFrameAt(frameIndex);
    1:         content = frame->GetContent();
    1:         if (!content) {
73724:           rv = NS_OK;
    1:           break;
    1:         }
27501:         contentTextLength = content->TextLength();
27501:         if (contentTextLength == 0) {
27501:           frame->AdjustOffsetsForBidi(0, 0);
27869:           // Set the base level and embedding level of the current run even
27869:           // on an empty frame. Otherwise frame reordering will not be correct.
39965:           propTable->Set(frame, nsIFrame::EmbeddingLevelProperty(),
39965:                          NS_INT32_TO_PTR(embeddingLevel));
39965:           propTable->Set(frame, nsIFrame::BaseLevelProperty(),
80543:                          NS_INT32_TO_PTR(aBpd->GetParaLevel()));
27501:           continue;
    1:         }
27501:         PRInt32 start, end;
27501:         frame->GetOffsets(start, end);
49259:         NS_ASSERTION(!(contentTextLength < end - start),
49259:                      "Frame offsets don't fit in content");
49259:         fragmentLength = NS_MIN(contentTextLength, end - start);
27501:         contentOffset = start;
80486:         isTextFrame = true;
29930:       }
    1:     } // if (fragmentLength <= 0)
29930: 
    1:     if (runLength <= 0) {
29930:       // Get the next run of text from the Bidi engine
    1:       if (++numRun >= runCount) {
    1:         break;
    1:       }
    1:       lineOffset = logicalLimit;
73724:       if (NS_FAILED(aBpd->GetLogicalRun(
    1:               lineOffset, &logicalLimit, &embeddingLevel) ) ) {
    1:         break;
    1:       }
    1:       runLength = logicalLimit - lineOffset;
    1:     } // if (runLength <= 0)
    1: 
71474:     if (frame == NS_BIDI_CONTROL_FRAME) {
    1:       frame = nsnull;
    1:       ++lineOffset;
    1:     }
    1:     else {
39965:       propTable->Set(frame, nsIFrame::EmbeddingLevelProperty(),
39965:                      NS_INT32_TO_PTR(embeddingLevel));
39965:       propTable->Set(frame, nsIFrame::BaseLevelProperty(),
80543:                      NS_INT32_TO_PTR(aBpd->GetParaLevel()));
    1:       if (isTextFrame) {
    1:         if ( (runLength > 0) && (runLength < fragmentLength) ) {
29930:           /*
29930:            * The text in this frame continues beyond the end of this directional run.
29930:            * Create a non-fluid continuation frame for the next directional run.
29930:            */
71476:           currentLine->MarkDirty();
29930:           nsIFrame* nextBidi;
36825:           PRInt32 runEnd = contentOffset + runLength;
73724:           rv = EnsureBidiContinuation(frame, &nextBidi, frameIndex,
13495:                                       contentOffset,
36825:                                       runEnd);
73724:           if (NS_FAILED(rv)) {
13495:             break;
13495:           }
36825:           nextBidi->AdjustOffsetsForBidi(runEnd,
36825:                                          contentOffset + fragmentLength);
    1:           frame = nextBidi;
36825:           contentOffset = runEnd;
    1:         } // if (runLength < fragmentLength)
    1:         else {
27501:           if (contentOffset + fragmentLength == contentTextLength) {
29930:             /* 
29930:              * We have finished all the text in this content node. Convert any
29930:              * further non-fluid continuations to fluid continuations and advance
29930:              * frameIndex to the last frame in the content node
29930:              */
73724:             PRInt32 newIndex = aBpd->GetLastFrameForContent(content);
    1:             if (newIndex > frameIndex) {
73724:               RemoveBidiContinuation(aBpd, frame,
73724:                                      frameIndex, newIndex, lineOffset);
28985:               frameIndex = newIndex;
28985:             }
29930:           } else if (fragmentLength > 0 && runLength > fragmentLength) {
29930:             /*
29930:              * There is more text that belongs to this directional run in the next
29930:              * text frame: make sure it is a fluid continuation of the current frame.
29930:              * Do not advance frameIndex, because the next frame may contain
29930:              * multi-directional text and need to be split
29930:              */
29930:             PRInt32 newIndex = frameIndex;
29930:             do {
71482:             } while (++newIndex < frameCount &&
73724:                      aBpd->FrameAt(newIndex) == NS_BIDI_CONTROL_FRAME);
71482:             if (newIndex < frameCount) {
73724:               RemoveBidiContinuation(aBpd, frame,
73724:                                      frameIndex, newIndex, lineOffset);
71482:             }
71482:           } else if (runLength == fragmentLength &&
71482:                      numRun + 1 < runCount) {
33658:             /*
71482:              * If the directional run ends at the end of the frame, and this is
71482:              * not the end of our paragraph, make sure that the next frame is a
71482:              * non-fluid continuation
33658:              */
33658:             nsIFrame* next = frame->GetNextInFlow();
33658:             if (next) {
33658:               frame->SetNextContinuation(next);
33658:               next->SetPrevContinuation(frame);
33658:             }
28985:           }
28985:           frame->AdjustOffsetsForBidi(contentOffset, contentOffset + fragmentLength);
71476:           currentLine->MarkDirty();
    1:         }
    1:       } // isTextFrame
    1:       else {
    1:         ++lineOffset;
    1:       }
71474:     } // not bidi control frame
29930:     PRInt32 temp = runLength;
    1:     runLength -= fragmentLength;
    1:     fragmentLength -= temp;
    1: 
13426:     if (frame && fragmentLength <= 0) {
71479:       // If the frame is at the end of a run, and this is not the end of our
71479:       // paragrah, split all ancestor inlines that need splitting.
43881:       // To determine whether we're at the end of the run, we check that we've
43881:       // finished processing the current run, and that the current frame
43881:       // doesn't have a fluid continuation (it could have a fluid continuation
43881:       // of zero length, so testing runLength alone is not sufficient).
73661:       if (runLength <= 0 && !frame->GetNextInFlow()) {
73661:         if (numRun + 1 < runCount) {
    1:           nsIFrame* child = frame;
    1:           nsIFrame* parent = frame->GetParent();
73661:           // As long as we're on the last sibling, the parent doesn't have to
73661:           // be split.
43566:           // However, if the parent has a fluid continuation, we do have to make
73661:           // it non-fluid. This can happen e.g. when we have a first-letter
73661:           // frame and the end of the first-letter coincides with the end of a
43566:           // directional run.
    1:           while (parent &&
    1:                  IsBidiSplittable(parent) &&
    1:                  !child->GetNextSibling()) {
43566:             nsIFrame* next = parent->GetNextInFlow();
43566:             if (next) {
43566:               parent->SetNextContinuation(next);
43566:               next->SetPrevContinuation(parent);
43566:             }
    1:             child = parent;
    1:             parent = child->GetParent();
    1:           }
    1:           if (parent && IsBidiSplittable(parent))
 5423:             SplitInlineAncestors(child);
    1:         }
73661:       }
71482:       else {
71482:         // We're not at an end of a run. If |frame| is the last child of its
71482:         // parent, and its ancestors happen to have bidi continuations, convert
71482:         // them into fluid continuations.
71482:         JoinInlineAncestors(frame);
13426:       }
13426:     }
    1:   } // for
67826: 
67826: #ifdef DEBUG
67826: #ifdef REALLY_NOISY_BIDI
67826:   printf("---\nAfter Resolve(), frameTree =:\n");
67826:   aBlockFrame->List(stdout, 0);
67826:   printf("===\n");
67826: #endif
67826: #endif
73724: 
73724:   return rv;
    1: }
    1: 
24551: // Should this frame be treated as a leaf (e.g. when building mLogicalFrames)?
79445: bool IsBidiLeaf(nsIFrame* aFrame) {
77154:   nsIFrame* kid = aFrame->GetFirstPrincipalChild();
    1:   return !kid
 5421:     || !aFrame->IsFrameOfType(nsIFrame::eBidiInlineContainer);
    1: }
    1: 
 5423: void
71479: nsBidiPresUtils::TraverseFrames(nsBlockFrame*              aBlockFrame,
71479:                                 nsBlockInFlowLineIterator* aLineIter,
73724:                                 nsIFrame*                  aCurrentFrame,
81552:                                 BidiParagraphData*         aBpd)
    1: {
 9542:   if (!aCurrentFrame)
 9542:     return;
 9542: 
71479:   nsIFrame* childFrame = aCurrentFrame;
71479:   do {
71479:     /*
71479:      * It's important to get the next sibling and next continuation *before*
71479:      * handling the frame: If we encounter a forced paragraph break and call
71479:      * ResolveParagraph within this loop, doing GetNextSibling and
71479:      * GetNextContinuation after that could return a bidi continuation that had
71479:      * just been split from the original childFrame and we would process it
71479:      * twice.
71479:      */
71479:     nsIFrame* nextSibling = childFrame->GetNextSibling();
79445:     bool isLastFrame = !childFrame->GetNextContinuation();
80541:     bool isFirstFrame = !childFrame->GetPrevContinuation();
 5421: 
52083:     // If the real frame for a placeholder is a first letter frame, we need to
52083:     // drill down into it and include its contents in Bidi resolution.
52083:     // If not, we just use the placeholder.
 5596:     nsIFrame* frame = childFrame;
 5596:     if (nsGkAtoms::placeholderFrame == childFrame->GetType()) {
 5596:       nsIFrame* realFrame =
 5596:         nsPlaceholderFrame::GetRealFrameForPlaceholder(childFrame);
52083:       if (realFrame->GetType() == nsGkAtoms::letterFrame) {
 5596:         frame = realFrame;
 5596:       }
 5596:     }
    1: 
 1152:     PRUnichar ch = 0;
 5423:     if (frame->IsFrameOfType(nsIFrame::eBidiInlineContainer)) {
    1:       const nsStyleVisibility* vis = frame->GetStyleVisibility();
    1:       const nsStyleTextReset* text = frame->GetStyleTextReset();
80540:       if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_OVERRIDE) {
80540:         if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
80540:           ch = kRLO;
80540:         }
80540:         else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
80540:           ch = kLRO;
80540:         }
80540:       } else if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_EMBED) {
    1:         if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
 1152:           ch = kRLE;
    1:         }
    1:         else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
 1152:           ch = kLRE;
    1:         }
    1:       }
    1: 
71474:       // Add a dummy frame pointer representing a bidi control code before the
71474:       // first frame of an element specifying embedding or override
80541:       if (ch != 0 && isFirstFrame) {
73724:         aBpd->PushBidiControl(ch);
69015:       }
63930:     }
    1: 
    1:     if (IsBidiLeaf(frame)) {
    1:       /* Bidi leaf frame: add the frame to the mLogicalFrames array,
    1:        * and add its index to the mContentToFrameIndex hashtable. This
    1:        * will be used in RemoveBidiContinuation() to identify the last
    1:        * frame in the array with a given content.
    1:        */
    1:       nsIContent* content = frame->GetContent();
73724:       aBpd->AppendFrame(frame, aLineIter, content);
71476: 
71473:       // Append the content of the frame to the paragraph buffer
71473:       nsIAtom* frameType = frame->GetType();
71473:       if (nsGkAtoms::textFrame == frameType) {
73724:         if (content != aBpd->mPrevContent) {
73724:           aBpd->mPrevContent = content;
71482:           if (!frame->GetStyleContext()->GetStyleText()->NewlineIsSignificant()) {
73724:             content->AppendTextTo(aBpd->mBuffer);
71482:           } else {
71482:             /*
71482:              * For preformatted text we have to do bidi resolution on each line
71482:              * separately. 
71482:              */
71482:             nsAutoString text;
71482:             content->AppendTextTo(text);
71482:             nsIFrame* next;
71482:             do {
71482:               next = nsnull;
71482: 
71482:               PRInt32 start, end;
71482:               frame->GetOffsets(start, end);
71787:               PRInt32 endLine = text.FindChar('\n', start);
71482:               if (endLine == -1) {
71482:                 /*
71786:                  * If there is no newline in the text content, just save the
71786:                  * text from this frame and its continuations, and do bidi
71786:                  * resolution later
71482:                  */
73724:                 aBpd->AppendString(Substring(text, start));
71786:                 while (frame && nextSibling) {
73724:                   aBpd->AdvanceAndAppendFrame(&frame, aLineIter, &nextSibling);
71786:                 }
71482:                 break;
71482:               }
71482: 
71482:               /*
71482:                * If there is a newline in the frame, break the frame after the
72535:                * newline, do bidi resolution and repeat until the last sibling
71482:                */
71482:               ++endLine;
71482: 
71482:               /*
71482:                * If the frame ends before the new line, save the text and move
71482:                * into the next continuation
71482:                */
73724:               aBpd->AppendString(Substring(text, start,
72953:                                            NS_MIN(end, endLine) - start));
71784:               while (end < endLine && nextSibling) { 
73724:                 aBpd->AdvanceAndAppendFrame(&frame, aLineIter, &nextSibling);
71482:                 NS_ASSERTION(frame, "Premature end of continuation chain");
71482:                 frame->GetOffsets(start, end);
73724:                 aBpd->AppendString(Substring(text, start,
72953:                                              NS_MIN(end, endLine) - start));
71482:               }
71482: 
73663:               if (end < endLine) {
73724:                 aBpd->mPrevContent = nsnull;
73663:                 break;
73663:               }
73663: 
79445:               bool createdContinuation = false;
73663:               if (PRUint32(endLine) < text.Length()) {
71482:                 /*
71482:                  * Timing is everything here: if the frame already has a bidi
71482:                  * continuation, we need to make the continuation fluid *before*
71482:                  * resetting the length of the current frame. Otherwise
71482:                  * nsTextFrame::SetLength won't set the continuation frame's
71482:                  * text offsets correctly.
71482:                  *
71482:                  * On the other hand, if the frame doesn't have a continuation,
71482:                  * we need to create one *after* resetting the length, or
71482:                  * CreateContinuingFrame will complain that there is no more
71482:                  * content for the continuation.               
71482:                  */
71482:                 next = frame->GetNextInFlow();
71482:                 if (!next) {
71482:                   // If the frame already has a bidi continuation, make it fluid
71482:                   next = frame->GetNextContinuation();
71482:                   if (next) {
71482:                     MakeContinuationFluid(frame, next);
71482:                     JoinInlineAncestors(frame);
71482:                   }
71482:                 }
71482: 
71482:                 nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
71482:                 textFrame->SetLength(endLine - start, nsnull);
71482: 
71482:                 if (!next) {
71482:                   // If the frame has no next in flow, create one.
80486:                   CreateContinuation(frame, &next, true);
80486:                   createdContinuation = true;
71482:                 }
71482:               }
73724:               ResolveParagraphWithinBlock(aBlockFrame, aBpd);
71482: 
71482:               if (!nextSibling && !createdContinuation) {
71482:                 break;
71482:               } else if (next) {
71482:                 frame = next;
73724:                 aBpd->AppendFrame(frame, aLineIter);
71482:               }
71482: 
71482:               /*
71482:                * If we have already overshot the saved next-sibling while
71482:                * scanning the frame's continuations, advance it.
71482:                */
71482:               if (frame && frame == nextSibling) {
71482:                 nextSibling = frame->GetNextSibling();
71482:               }
71482: 
71482:             } while (next);
71482:           }
71473:         }
71473:       } else if (nsGkAtoms::brFrame == frameType) {
71473:         // break frame -- append line separator
73724:         aBpd->AppendUnichar(kLineSeparator);
73724:         ResolveParagraphWithinBlock(aBlockFrame, aBpd);
71473:       } else { 
71473:         // other frame type -- see the Unicode Bidi Algorithm:
71473:         // "...inline objects (such as graphics) are treated as if they are ...
71473:         // U+FFFC"
73724:         aBpd->AppendUnichar(kObjectSubstitute);
71479:         if (!frame->GetStyleContext()->GetStyleDisplay()->IsInlineOutside()) {
71479:           // if it is not inline, end the paragraph
73724:           ResolveParagraphWithinBlock(aBlockFrame, aBpd);
71479:         }
71473:       }
    1:     }
    1:     else {
71479:       // For a non-leaf frame, recurse into TraverseFrames
77154:       nsIFrame* kid = frame->GetFirstPrincipalChild();
80541:       if (kid) {
80541:         const nsStyleTextReset* text = frame->GetStyleTextReset();
80541:         if (text->mUnicodeBidi & NS_STYLE_UNICODE_BIDI_ISOLATE) {
80541:           // css "unicode-bidi: isolate" and html5 bdi: 
80541:           //  resolve the element as a separate paragraph
81552:           BidiParagraphData* subParagraph = aBpd->GetSubParagraph();
82733: 
82733:           /*
82733:            * As at the beginning of the loop, it's important to check for
82733:            * next-continuations before handling the frame. If we do
82733:            * TraverseFrames and *then* do GetNextContinuation on the original
82733:            * first frame, it could return a bidi continuation that had only
82733:            * just been created, and we would skip doing bidi resolution on the
82733:            * last part of the sub-paragraph.
82733:            */
82733:           bool isLastContinuation = !frame->GetNextContinuation();
84240:           if (!frame->GetPrevContinuation() || !subParagraph->mReset) {
81552:             subParagraph->Reset(kid, aBpd);
81552:           }
81552:           TraverseFrames(aBlockFrame, aLineIter, kid, subParagraph);
82733:           if (isLastContinuation) {
81552:             ResolveParagraph(aBlockFrame, subParagraph);
81552:           }
81552: 
81552:           // Treat the element as a neutral character within its containing
81552:           //  paragraph.
81552:           aBpd->AppendControlChar(kObjectSubstitute);
80541:         } else {
73724:           TraverseFrames(aBlockFrame, aLineIter, kid, aBpd);
    1:         }
80541:       }
80541:     }
    1: 
    1:     // If the element is attributed by dir, indicate direction pop (add PDF frame)
80541:     if (isLastFrame) {
80541:       if (ch) {
71474:         // Add a dummy frame pointer representing a bidi control code after the
71474:         // last frame of an element specifying embedding or override
73724:         aBpd->PopBidiControl();
    1:       }
80541:     }
71479:     childFrame = nextSibling;
71479:   } while (childFrame);
71479: }
71479: 
71479: void
73724: nsBidiPresUtils::ResolveParagraphWithinBlock(nsBlockFrame* aBlockFrame,
73724:                                              BidiParagraphData* aBpd)
71479: {
73724:   aBpd->ClearBidiControls();
73724:   ResolveParagraph(aBlockFrame, aBpd);
73724:   aBpd->ResetData();
67832: }
67832: 
67832: void
 5423: nsBidiPresUtils::ReorderFrames(nsIFrame*            aFirstFrameOnLine,
    1:                                PRInt32              aNumFramesOnLine)
    1: {
    1:   // If this line consists of a line frame, reorder the line frame's children.
    1:   if (aFirstFrameOnLine->GetType() == nsGkAtoms::lineFrame) {
77154:     aFirstFrameOnLine = aFirstFrameOnLine->GetFirstPrincipalChild();
    1:     if (!aFirstFrameOnLine)
    1:       return;
    1:     // All children of the line frame are on the first line. Setting aNumFramesOnLine
    1:     // to -1 makes InitLogicalArrayFromLine look at all of them.
    1:     aNumFramesOnLine = -1;
    1:   }
69015: 
73724:   BidiLineData bld(aFirstFrameOnLine, aNumFramesOnLine);
73724:   RepositionInlineFrames(&bld, aFirstFrameOnLine);
    1: }
    1: 
    1: nsBidiLevel
    1: nsBidiPresUtils::GetFrameEmbeddingLevel(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* firstLeaf = aFrame;
    1:   while (!IsBidiLeaf(firstLeaf)) {
77154:     nsIFrame* firstChild = firstLeaf->GetFirstPrincipalChild();
52083:     nsIFrame* realFrame = nsPlaceholderFrame::GetRealFrameFor(firstChild);
52083:     firstLeaf = (realFrame->GetType() == nsGkAtoms::letterFrame) ?
52083:                  realFrame : firstChild;
    1:   }
    1:   return NS_GET_EMBEDDING_LEVEL(firstLeaf);
    1: }
    1: 
    1: nsBidiLevel
    1: nsBidiPresUtils::GetFrameBaseLevel(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* firstLeaf = aFrame;
    1:   while (!IsBidiLeaf(firstLeaf)) {
77154:     firstLeaf = firstLeaf->GetFirstPrincipalChild();
    1:   }
    1:   return NS_GET_BASE_LEVEL(firstLeaf);
    1: }
    1: 
    1: void
    1: nsBidiPresUtils::IsLeftOrRightMost(nsIFrame*              aFrame,
    1:                                    nsContinuationStates*  aContinuationStates,
79445:                                    bool&                aIsLeftMost /* out */,
79445:                                    bool&                aIsRightMost /* out */)
    1: {
    1:   const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
79445:   bool isLTR = (NS_STYLE_DIRECTION_LTR == vis->mDirection);
    1: 
    1:   /*
    1:    * Since we lay out frames from left to right (in both LTR and RTL), visiting a
    1:    * frame with 'mFirstVisualFrame == nsnull', means it's the first appearance of
    1:    * one of its continuation chain frames on the line.
    1:    * To determine if it's the last visual frame of its continuation chain on the line
    1:    * or not, we count the number of frames of the chain on the line, and then reduce
    1:    * it when we lay out a frame of the chain. If this value becomes 1 it means
    1:    * that it's the last visual frame of its continuation chain on this line.
    1:    */
    1: 
    1:   nsFrameContinuationState* frameState = aContinuationStates->GetEntry(aFrame);
    1:   nsFrameContinuationState* firstFrameState;
    1: 
    1:   if (!frameState->mFirstVisualFrame) {
    1:     // aFrame is the first visual frame of its continuation chain
    1:     nsFrameContinuationState* contState;
    1:     nsIFrame* frame;
    1: 
    1:     frameState->mFrameCount = 1;
    1:     frameState->mFirstVisualFrame = aFrame;
    1: 
    1:     /**
    1:      * Traverse continuation chain of aFrame in both backward and forward
    1:      * directions while the frames are on this line. Count the frames and
    1:      * set their mFirstVisualFrame to aFrame.
    1:      */
    1:     // Traverse continuation chain backward
    1:     for (frame = aFrame->GetPrevContinuation();
    1:          frame && (contState = aContinuationStates->GetEntry(frame));
    1:          frame = frame->GetPrevContinuation()) {
    1:       frameState->mFrameCount++;
    1:       contState->mFirstVisualFrame = aFrame;
    1:     }
    1:     frameState->mHasContOnPrevLines = (frame != nsnull);
    1: 
    1:     // Traverse continuation chain forward
    1:     for (frame = aFrame->GetNextContinuation();
    1:          frame && (contState = aContinuationStates->GetEntry(frame));
    1:          frame = frame->GetNextContinuation()) {
    1:       frameState->mFrameCount++;
    1:       contState->mFirstVisualFrame = aFrame;
    1:     }
    1:     frameState->mHasContOnNextLines = (frame != nsnull);
    1: 
    1:     aIsLeftMost = isLTR ? !frameState->mHasContOnPrevLines
    1:                         : !frameState->mHasContOnNextLines;
    1:     firstFrameState = frameState;
    1:   } else {
    1:     // aFrame is not the first visual frame of its continuation chain
80486:     aIsLeftMost = false;
    1:     firstFrameState = aContinuationStates->GetEntry(frameState->mFirstVisualFrame);
    1:   }
    1: 
    1:   aIsRightMost = (firstFrameState->mFrameCount == 1) &&
    1:                  (isLTR ? !firstFrameState->mHasContOnNextLines
    1:                         : !firstFrameState->mHasContOnPrevLines);
    1: 
28217:   if ((aIsLeftMost || aIsRightMost) &&
28217:       (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
34460:     // For ib splits, don't treat anything except the last part as
34460:     // endmost or anything except the first part as startmost.
34460:     // As an optimization, only get the first continuation once.
34460:     nsIFrame* firstContinuation = aFrame->GetFirstContinuation();
34460:     if (nsLayoutUtils::FrameIsNonLastInIBSplit(firstContinuation)) {
28217:       // We are not endmost
28217:       if (isLTR) {
80486:         aIsRightMost = false;
28217:       } else {
80486:         aIsLeftMost = false;
28217:       }
34460:     }
34460:     if (nsLayoutUtils::FrameIsNonFirstInIBSplit(firstContinuation)) {
28217:       // We are not startmost
28217:       if (isLTR) {
80486:         aIsLeftMost = false;
28217:       } else {
80486:         aIsRightMost = false;
28217:       }
28217:     }
28217:   }
28217: 
    1:   // Reduce number of remaining frames of the continuation chain on the line.
    1:   firstFrameState->mFrameCount--;
    1: }
    1: 
    1: void
    1: nsBidiPresUtils::RepositionFrame(nsIFrame*              aFrame,
79445:                                  bool                   aIsOddLevel,
    1:                                  nscoord&               aLeft,
73724:                                  nsContinuationStates*  aContinuationStates)
    1: {
    1:   if (!aFrame)
    1:     return;
    1: 
79445:   bool isLeftMost, isRightMost;
    1:   IsLeftOrRightMost(aFrame,
    1:                     aContinuationStates,
    1:                     isLeftMost /* out */,
    1:                     isRightMost /* out */);
    1: 
23554:   nsInlineFrame* testFrame = do_QueryFrame(aFrame);
    1:   if (testFrame) {
    1:     aFrame->AddStateBits(NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET);
    1: 
    1:     if (isLeftMost)
    1:       aFrame->AddStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_LEFT_MOST);
    1:     else
    1:       aFrame->RemoveStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_LEFT_MOST);
    1: 
    1:     if (isRightMost)
    1:       aFrame->AddStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_RIGHT_MOST);
    1:     else
    1:       aFrame->RemoveStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_RIGHT_MOST);
    1:   }
10772:   // This method is called from nsBlockFrame::PlaceLine via the call to
10772:   // bidiUtils->ReorderFrames, so this is guaranteed to be after the inlines
10772:   // have been reflowed, which is required for GetUsedMargin/Border/Padding
10772:   nsMargin margin = aFrame->GetUsedMargin();
    1:   if (isLeftMost)
    1:     aLeft += margin.left;
    1: 
    1:   nscoord start = aLeft;
    1: 
    1:   if (!IsBidiLeaf(aFrame))
    1:   {
    1:     nscoord x = 0;
10772:     nsMargin borderPadding = aFrame->GetUsedBorderAndPadding();
    1:     if (isLeftMost) {
    1:       x += borderPadding.left;
    1:     }
    1: 
    1:     // If aIsOddLevel is true, so we need to traverse the child list
    1:     // in reverse order, to make it O(n) we store the list locally and
    1:     // iterate the list reversely
24551:     nsTArray<nsIFrame*> childList;
77154:     nsIFrame *frame = aFrame->GetFirstPrincipalChild();
    1:     if (frame && aIsOddLevel) {
24551:       childList.AppendElement((nsIFrame*)nsnull);
    1:       while (frame) {
    1:         childList.AppendElement(frame);
    1:         frame = frame->GetNextSibling();
    1:       }
24551:       frame = childList[childList.Length() - 1];
    1:     }
    1: 
    1:     // Reposition the child frames
    1:     PRInt32 index = 0;
    1:     while (frame) {
    1:       RepositionFrame(frame,
    1:                       aIsOddLevel,
    1:                       x,
    1:                       aContinuationStates);
    1:       index++;
    1:       frame = aIsOddLevel ?
24551:                 childList[childList.Length() - index - 1] :
    1:                 frame->GetNextSibling();
    1:     }
    1: 
    1:     if (isRightMost) {
    1:       x += borderPadding.right;
    1:     }
    1:     aLeft += x;
    1:   } else {
    1:     aLeft += aFrame->GetSize().width;
    1:   }
    1:   nsRect rect = aFrame->GetRect();
    1:   aFrame->SetRect(nsRect(start, rect.y, aLeft - start, rect.height));
    1: 
    1:   if (isRightMost)
    1:     aLeft += margin.right;
    1: }
    1: 
    1: void
    1: nsBidiPresUtils::InitContinuationStates(nsIFrame*              aFrame,
73724:                                         nsContinuationStates*  aContinuationStates)
    1: {
    1:   nsFrameContinuationState* state = aContinuationStates->PutEntry(aFrame);
    1:   state->mFirstVisualFrame = nsnull;
    1:   state->mFrameCount = 0;
    1: 
    1:   if (!IsBidiLeaf(aFrame)) {
    1:     // Continue for child frames
    1:     nsIFrame* frame;
77154:     for (frame = aFrame->GetFirstPrincipalChild();
    1:          frame;
    1:          frame = frame->GetNextSibling()) {
    1:       InitContinuationStates(frame,
    1:                              aContinuationStates);
    1:     }
    1:   }
    1: }
    1: 
    1: void
73724: nsBidiPresUtils::RepositionInlineFrames(BidiLineData *aBld,
73724:                                         nsIFrame* aFirstChild)
    1: {
    1:   const nsStyleVisibility* vis = aFirstChild->GetStyleVisibility();
79445:   bool isLTR = (NS_STYLE_DIRECTION_LTR == vis->mDirection);
    1:   nscoord leftSpace = 0;
    1: 
10772:   // This method is called from nsBlockFrame::PlaceLine via the call to
10772:   // bidiUtils->ReorderFrames, so this is guaranteed to be after the inlines
10772:   // have been reflowed, which is required for GetUsedMargin/Border/Padding
10772:   nsMargin margin = aFirstChild->GetUsedMargin();
28217:   if (!aFirstChild->GetPrevContinuation() &&
34460:       !nsLayoutUtils::FrameIsNonFirstInIBSplit(aFirstChild))
    1:     leftSpace = isLTR ? margin.left : margin.right;
    1: 
    1:   nscoord left = aFirstChild->GetPosition().x - leftSpace;
    1:   nsIFrame* frame;
73724:   PRInt32 count = aBld->mVisualFrames.Length();
    1:   PRInt32 index;
    1:   nsContinuationStates continuationStates;
    1: 
    1:   continuationStates.Init();
    1: 
    1:   // Initialize continuation states to (nsnull, 0) for
    1:   // each frame on the line.
    1:   for (index = 0; index < count; index++) {
73724:     InitContinuationStates(aBld->VisualFrameAt(index), &continuationStates);
    1:   }
    1: 
    1:   // Reposition frames in visual order
    1:   for (index = 0; index < count; index++) {
73724:     frame = aBld->VisualFrameAt(index);
    1:     RepositionFrame(frame,
73724:                     (aBld->mLevels[aBld->mIndexMap[index]] & 1),
    1:                     left,
    1:                     &continuationStates);
    1:   } // for
    1: }
    1: 
79445: bool
    1: nsBidiPresUtils::CheckLineOrder(nsIFrame*  aFirstFrameOnLine,
    1:                                 PRInt32    aNumFramesOnLine,
    1:                                 nsIFrame** aFirstVisual,
    1:                                 nsIFrame** aLastVisual)
    1: {
73724:   BidiLineData bld(aFirstFrameOnLine, aNumFramesOnLine);
73724:   PRInt32 count = bld.FrameCount();
    1:   
    1:   if (aFirstVisual) {
73724:     *aFirstVisual = bld.VisualFrameAt(0);
    1:   }
    1:   if (aLastVisual) {
73724:     *aLastVisual = bld.VisualFrameAt(count-1);
    1:   }
    1:   
73724:   return bld.mIsReordered;
    1: }
    1: 
    1: nsIFrame*
    1: nsBidiPresUtils::GetFrameToRightOf(const nsIFrame*  aFrame,
    1:                                    nsIFrame*        aFirstFrameOnLine,
    1:                                    PRInt32          aNumFramesOnLine)
    1: {
73724:   BidiLineData bld(aFirstFrameOnLine, aNumFramesOnLine);
    1: 
73724:   PRInt32 count = bld.mVisualFrames.Length();
    1: 
74345:   if (aFrame == nsnull && count)
73724:     return bld.VisualFrameAt(0);
    1:   
    1:   for (PRInt32 i = 0; i < count - 1; i++) {
73724:     if (bld.VisualFrameAt(i) == aFrame) {
73724:       return bld.VisualFrameAt(i+1);
    1:     }
    1:   }
    1:   
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: nsBidiPresUtils::GetFrameToLeftOf(const nsIFrame*  aFrame,
    1:                                   nsIFrame*        aFirstFrameOnLine,
    1:                                   PRInt32          aNumFramesOnLine)
    1: {
73724:   BidiLineData bld(aFirstFrameOnLine, aNumFramesOnLine);
    1: 
73724:   PRInt32 count = bld.mVisualFrames.Length();
    1:   
74345:   if (aFrame == nsnull && count)
73724:     return bld.VisualFrameAt(count-1);
    1:   
    1:   for (PRInt32 i = 1; i < count; i++) {
73724:     if (bld.VisualFrameAt(i) == aFrame) {
73724:       return bld.VisualFrameAt(i-1);
    1:     }
    1:   }
    1:   
    1:   return nsnull;
    1: }
    1: 
73724: inline nsresult
 5423: nsBidiPresUtils::EnsureBidiContinuation(nsIFrame*       aFrame,
    1:                                         nsIFrame**      aNewFrame,
10997:                                         PRInt32&        aFrameIndex,
10997:                                         PRInt32         aStart,
27501:                                         PRInt32         aEnd)
    1: {
    1:   NS_PRECONDITION(aNewFrame, "null OUT ptr");
    1:   NS_PRECONDITION(aFrame, "aFrame is null");
    1: 
10997:   aFrame->AdjustOffsetsForBidi(aStart, aEnd);
80486:   return CreateContinuation(aFrame, aNewFrame, false);
    1: }
    1: 
    1: void
73724: nsBidiPresUtils::RemoveBidiContinuation(BidiParagraphData *aBpd,
73724:                                         nsIFrame*       aFrame,
    1:                                         PRInt32         aFirstIndex,
    1:                                         PRInt32         aLastIndex,
73724:                                         PRInt32&        aOffset)
    1: {
39965:   FrameProperties props = aFrame->Properties();
39965:   nsBidiLevel embeddingLevel =
42116:     (nsBidiLevel)NS_PTR_TO_INT32(props.Get(nsIFrame::EmbeddingLevelProperty()));
39965:   nsBidiLevel baseLevel =
42116:     (nsBidiLevel)NS_PTR_TO_INT32(props.Get(nsIFrame::BaseLevelProperty()));
    1: 
    1:   for (PRInt32 index = aFirstIndex + 1; index <= aLastIndex; index++) {
73724:     nsIFrame* frame = aBpd->FrameAt(index);
71474:     if (frame == NS_BIDI_CONTROL_FRAME) {
    1:       ++aOffset;
    1:     }
    1:     else {
    1:       // Make the frame and its continuation ancestors fluid,
    1:       // so they can be reused or deleted by normal reflow code
39965:       FrameProperties frameProps = frame->Properties();
39965:       frameProps.Set(nsIFrame::EmbeddingLevelProperty(),
39965:                      NS_INT32_TO_PTR(embeddingLevel));
39965:       frameProps.Set(nsIFrame::BaseLevelProperty(),
39965:                      NS_INT32_TO_PTR(baseLevel));
    1:       frame->AddStateBits(NS_FRAME_IS_BIDI);
    1:       while (frame) {
    1:         nsIFrame* prev = frame->GetPrevContinuation();
    1:         if (prev) {
71482:           MakeContinuationFluid(prev, frame);
    1:           frame = frame->GetParent();
    1:         } else {
    1:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsBidiPresUtils::FormatUnicodeText(nsPresContext*  aPresContext,
    1:                                    PRUnichar*       aText,
    1:                                    PRInt32&         aTextLength,
    1:                                    nsCharType       aCharType,
79445:                                    bool             aIsOddLevel)
    1: {
    1:   NS_ASSERTION(aIsOddLevel == 0 || aIsOddLevel == 1, "aIsOddLevel should be 0 or 1");
    1:   nsresult rv = NS_OK;
    1:   // ahmed 
    1:   //adjusted for correct numeral shaping  
    1:   PRUint32 bidiOptions = aPresContext->GetBidi();
    1:   switch (GET_BIDI_OPTION_NUMERAL(bidiOptions)) {
    1: 
    1:     case IBMBIDI_NUMERAL_HINDI:
    1:       HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_HINDI);
    1:       break;
    1: 
    1:     case IBMBIDI_NUMERAL_ARABIC:
    1:       HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
    1:       break;
    1: 
24437:     case IBMBIDI_NUMERAL_PERSIAN:
24437:       HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_PERSIAN);
24437:       break;
24437: 
    1:     case IBMBIDI_NUMERAL_REGULAR:
    1: 
    1:       switch (aCharType) {
    1: 
    1:         case eCharType_EuropeanNumber:
    1:           HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
    1:           break;
    1: 
    1:         case eCharType_ArabicNumber:
    1:           HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_HINDI);
    1:           break;
    1: 
    1:         default:
    1:           break;
    1:       }
    1:       break;
    1: 
    1:     case IBMBIDI_NUMERAL_HINDICONTEXT:
    1:       if ( ( (GET_BIDI_OPTION_DIRECTION(bidiOptions)==IBMBIDI_TEXTDIRECTION_RTL) && (IS_ARABIC_DIGIT (aText[0])) ) || (eCharType_ArabicNumber == aCharType) )
    1:         HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_HINDI);
    1:       else if (eCharType_EuropeanNumber == aCharType)
    1:         HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
    1:       break;
    1: 
24437:     case IBMBIDI_NUMERAL_PERSIANCONTEXT:
24437:       if ( ( (GET_BIDI_OPTION_DIRECTION(bidiOptions)==IBMBIDI_TEXTDIRECTION_RTL) && (IS_ARABIC_DIGIT (aText[0])) ) || (eCharType_ArabicNumber == aCharType) )
24437:         HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_PERSIAN);
24437:       else if (eCharType_EuropeanNumber == aCharType)
24437:         HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
24437:       break;
24437: 
    1:     case IBMBIDI_NUMERAL_NOMINAL:
    1:     default:
    1:       break;
    1:   }
    1: 
    1:   StripBidiControlCharacters(aText, aTextLength);
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsBidiPresUtils::StripBidiControlCharacters(PRUnichar* aText,
73724:                                             PRInt32&   aTextLength)
    1: {
    1:   if ( (nsnull == aText) || (aTextLength < 1) ) {
    1:     return;
    1:   }
    1: 
    1:   PRInt32 stripLen = 0;
    1: 
    1:   for (PRInt32 i = 0; i < aTextLength; i++) {
    1:     // XXX: This silently ignores surrogate characters.
    1:     //      As of Unicode 4.0, all Bidi control characters are within the BMP.
 2997:     if (IsBidiControl((PRUint32)aText[i])) {
    1:       ++stripLen;
    1:     }
    1:     else {
    1:       aText[i - stripLen] = aText[i];
    1:     }
    1:   }
    1:   aTextLength -= stripLen;
    1: }
    1:  
    1: #if 0 // XXX: for the future use ???
    1: void
    1: RemoveDiacritics(PRUnichar* aText,
    1:                  PRInt32&   aTextLength)
    1: {
    1:   if (aText && (aTextLength > 0) ) {
    1:     PRInt32 offset = 0;
    1: 
    1:     for (PRInt32 i = 0; i < aTextLength && aText[i]; i++) {
    1:       if (IS_BIDI_DIACRITIC(aText[i]) ) {
    1:         ++offset;
    1:         continue;
    1:       }
    1:       aText[i - offset] = aText[i];
    1:     }
    1:     aTextLength = i - offset;
    1:     aText[aTextLength] = 0;
    1:   }
    1: }
    1: #endif
    1: 
    1: void
73724: nsBidiPresUtils::CalculateCharType(nsBidi* aBidiEngine,
73724:                                    const PRUnichar* aText,
73724:                                    PRInt32& aOffset,
    1:                                    PRInt32  aCharTypeLimit,
    1:                                    PRInt32& aRunLimit,
    1:                                    PRInt32& aRunLength,
    1:                                    PRInt32& aRunCount,
    1:                                    PRUint8& aCharType,
73724:                                    PRUint8& aPrevCharType)
    1: 
    1: {
79445:   bool       strongTypeFound = false;
    1:   PRInt32    offset;
    1:   nsCharType charType;
    1: 
    1:   aCharType = eCharType_OtherNeutral;
    1: 
    1:   for (offset = aOffset; offset < aCharTypeLimit; offset++) {
    1:     // Make sure we give RTL chartype to all characters that would be classified
    1:     // as Right-To-Left by a bidi platform.
    1:     // (May differ from the UnicodeData, eg we set RTL chartype to some NSMs.)
73724:     if (IS_HEBREW_CHAR(aText[offset]) ) {
    1:       charType = eCharType_RightToLeft;
    1:     }
73724:     else if (IS_ARABIC_ALPHABETIC(aText[offset]) ) {
    1:       charType = eCharType_RightToLeftArabic;
    1:     }
    1:     else {
73724:       aBidiEngine->GetCharTypeAt(offset, &charType);
    1:     }
    1: 
    1:     if (!CHARTYPE_IS_WEAK(charType) ) {
    1: 
    1:       if (strongTypeFound
    1:           && (charType != aPrevCharType)
    1:           && (CHARTYPE_IS_RTL(charType) || CHARTYPE_IS_RTL(aPrevCharType) ) ) {
    1:         // Stop at this point to ensure uni-directionality of the text
    1:         // (from platform's point of view).
    1:         // Also, don't mix Arabic and Hebrew content (since platform may
    1:         // provide BIDI support to one of them only).
    1:         aRunLength = offset - aOffset;
    1:         aRunLimit = offset;
    1:         ++aRunCount;
    1:         break;
    1:       }
    1: 
    1:       if ( (eCharType_RightToLeftArabic == aPrevCharType
    1:             || eCharType_ArabicNumber == aPrevCharType)
    1:           && eCharType_EuropeanNumber == charType) {
    1:         charType = eCharType_ArabicNumber;
    1:       }
    1: 
    1:       // Set PrevCharType to the last strong type in this frame
    1:       // (for correct numeric shaping)
    1:       aPrevCharType = charType;
    1: 
80486:       strongTypeFound = true;
    1:       aCharType = charType;
    1:     }
    1:   }
    1:   aOffset = offset;
    1: }
    1: 
    1: nsresult nsBidiPresUtils::ProcessText(const PRUnichar*       aText,
    1:                                       PRInt32                aLength,
    1:                                       nsBidiDirection        aBaseDirection,
    1:                                       nsPresContext*         aPresContext,
16043:                                       BidiProcessor&         aprocessor,
    1:                                       Mode                   aMode,
    1:                                       nsBidiPositionResolve* aPosResolve,
    1:                                       PRInt32                aPosResolveCount,
73724:                                       nscoord*               aWidth,
73724:                                       nsBidi*                aBidiEngine)
    1: {
    1:   NS_ASSERTION((aPosResolve == nsnull) != (aPosResolveCount > 0), "Incorrect aPosResolve / aPosResolveCount arguments");
    1: 
    1:   PRInt32 runCount;
    1: 
73724:   nsAutoString textBuffer(aText, aLength);
    1: 
73724:   nsresult rv = aBidiEngine->SetPara(aText, aLength, aBaseDirection, nsnull);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
73724:   rv = aBidiEngine->CountRuns(&runCount);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
16043:   nscoord xOffset = 0;
73724:   nscoord width, xEndRun = 0;
    1:   nscoord totalWidth = 0;
    1:   PRInt32 i, start, limit, length;
    1:   PRUint32 visualStart = 0;
    1:   PRUint8 charType;
    1:   PRUint8 prevType = eCharType_LeftToRight;
    1:   nsBidiLevel level;
    1:       
    1:   for(int nPosResolve=0; nPosResolve < aPosResolveCount; ++nPosResolve)
    1:   {
    1:     aPosResolve[nPosResolve].visualIndex = kNotFound;
    1:     aPosResolve[nPosResolve].visualLeftTwips = kNotFound;
26442:     aPosResolve[nPosResolve].visualWidth = kNotFound;
    1:   }
    1: 
    1:   for (i = 0; i < runCount; i++) {
73724:     rv = aBidiEngine->GetVisualRun(i, &start, &length, &aBaseDirection);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
73724:     rv = aBidiEngine->GetLogicalRun(start, &limit, &level);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     PRInt32 subRunLength = limit - start;
    1:     PRInt32 lineOffset = start;
32531:     PRInt32 typeLimit = NS_MIN(limit, aLength);
    1:     PRInt32 subRunCount = 1;
    1:     PRInt32 subRunLimit = typeLimit;
    1: 
    1:     /*
    1:      * If |level| is even, i.e. the direction of the run is left-to-right, we
    1:      * render the subruns from left to right and increment the x-coordinate
16043:      * |xOffset| by the width of each subrun after rendering.
    1:      *
    1:      * If |level| is odd, i.e. the direction of the run is right-to-left, we
16043:      * render the subruns from right to left. We begin by incrementing |xOffset| by
    1:      * the width of the whole run, and then decrement it by the width of each
    1:      * subrun before rendering. After rendering all the subruns, we restore the
    1:      * x-coordinate of the end of the run for the start of the next run.
    1:      */
    1: 
    1:     if (level & 1) {
16043:       aprocessor.SetText(aText + start, subRunLength, nsBidiDirection(level & 1));
16043:       width = aprocessor.GetWidth();
16043:       xOffset += width;
16043:       xEndRun = xOffset;
    1:     }
    1: 
    1:     while (subRunCount > 0) {
    1:       // CalculateCharType can increment subRunCount if the run
    1:       // contains mixed character types
73724:       CalculateCharType(aBidiEngine, aText, lineOffset, typeLimit, subRunLimit, subRunLength, subRunCount, charType, prevType);
    1:       
    1:       nsAutoString runVisualText;
    1:       runVisualText.Assign(aText + start, subRunLength);
24551:       if (PRInt32(runVisualText.Length()) < subRunLength)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       FormatUnicodeText(aPresContext, runVisualText.BeginWriting(), subRunLength,
16557:                         (nsCharType)charType, level & 1);
    1: 
16043:       aprocessor.SetText(runVisualText.get(), subRunLength, nsBidiDirection(level & 1));
16043:       width = aprocessor.GetWidth();
    1:       totalWidth += width;
    1:       if (level & 1) {
16043:         xOffset -= width;
    1:       }
    1:       if (aMode == MODE_DRAW) {
16043:         aprocessor.DrawText(xOffset, width);
    1:       }
    1: 
    1:       /*
    1:        * The caller may request to calculate the visual position of one
    1:        * or more characters.
    1:        */
    1:       for(int nPosResolve=0; nPosResolve<aPosResolveCount; ++nPosResolve)
    1:       {
    1:         nsBidiPositionResolve* posResolve = &aPosResolve[nPosResolve];
    1:         /*
    1:          * Did we already resolve this position's visual metric? If so, skip.
    1:          */
    1:         if (posResolve->visualLeftTwips != kNotFound)
    1:            continue;
    1:            
    1:         /*
    1:          * First find out if the logical position is within this run.
    1:          */
    1:         if (start <= posResolve->logicalIndex &&
    1:             start + subRunLength > posResolve->logicalIndex) {
    1:           /*
    1:            * If this run is only one character long, we have an easy case:
    1:            * the visual position is the x-coord of the start of the run
16043:            * less the x-coord of the start of the whole text.
    1:            */
    1:           if (subRunLength == 1) {
    1:             posResolve->visualIndex = visualStart;
16043:             posResolve->visualLeftTwips = xOffset;
26442:             posResolve->visualWidth = width;
    1:           }
    1:           /*
    1:            * Otherwise, we need to measure the width of the run's part
    1:            * which is to the visual left of the index.
    1:            * In other words, the run is broken in two, around the logical index,
    1:            * and we measure the part which is visually left.
    1:            * If the run is right-to-left, this part will span from after the index
    1:            * up to the end of the run; if it is left-to-right, this part will span
    1:            * from the start of the run up to (and inclduing) the character before the index.
    1:            */
    1:           else {
26442:             /*
26442:              * Here is a description of how the width of the current character
26442:              * (posResolve->visualWidth) is calculated:
26442:              *
26442:              * LTR (current char: "P"):
26442:              *    S A M P L E          (logical index: 3, visual index: 3)
26442:              *    ^ (visualLeftPart)
26442:              *    ^ (visualRightSide)
26442:              *    visualLeftLength == 3
26442:              *    ^^^^^^ (subWidth)
26442:              *    ^^^^^^^^ (aprocessor.GetWidth() -- with visualRightSide)
26442:              *          ^^ (posResolve->visualWidth)
26442:              *
26442:              * RTL (current char: "M"):
26442:              *    E L P M A S          (logical index: 2, visual index: 3)
26442:              *        ^ (visualLeftPart)
26442:              *          ^ (visualRightSide)
26442:              *    visualLeftLength == 3
26442:              *    ^^^^^^ (subWidth)
26442:              *    ^^^^^^^^ (aprocessor.GetWidth() -- with visualRightSide)
26442:              *          ^^ (posResolve->visualWidth)
26442:              */
    1:             nscoord subWidth;
    1:             // The position in the text where this run's "left part" begins.
26442:             const PRUnichar* visualLeftPart, *visualRightSide;
    1:             if (level & 1) {
    1:               // One day, son, this could all be replaced with mBidiEngine.GetVisualIndex ...
    1:               posResolve->visualIndex = visualStart + (subRunLength - (posResolve->logicalIndex + 1 - start));
    1:               // Skipping to the "left part".
    1:               visualLeftPart = aText + posResolve->logicalIndex + 1;
26442:               // Skipping to the right side of the current character
26442:               visualRightSide = visualLeftPart - 1;
    1:             }
    1:             else {
    1:               posResolve->visualIndex = visualStart + (posResolve->logicalIndex - start);
    1:               // Skipping to the "left part".
    1:               visualLeftPart = aText + start;
26442:               // In LTR mode this is the same as visualLeftPart
26442:               visualRightSide = visualLeftPart;
    1:             }
    1:             // The delta between the start of the run and the left part's end.
    1:             PRInt32 visualLeftLength = posResolve->visualIndex - visualStart;
16043:             aprocessor.SetText(visualLeftPart, visualLeftLength, nsBidiDirection(level & 1));
16043:             subWidth = aprocessor.GetWidth();
26442:             aprocessor.SetText(visualRightSide, visualLeftLength + 1, nsBidiDirection(level & 1));
16043:             posResolve->visualLeftTwips = xOffset + subWidth;
26442:             posResolve->visualWidth = aprocessor.GetWidth() - subWidth;
    1:           }
    1:         }
    1:       }
    1: 
    1:       if (!(level & 1)) {
16043:         xOffset += width;
    1:       }
    1: 
    1:       --subRunCount;
    1:       start = lineOffset;
    1:       subRunLimit = typeLimit;
    1:       subRunLength = typeLimit - lineOffset;
    1:     } // while
    1:     if (level & 1) {
16043:       xOffset = xEndRun;
    1:     }
    1:     
    1:     visualStart += length;
    1:   } // for
    1: 
    1:   if (aWidth) {
    1:     *aWidth = totalWidth;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
16043: class NS_STACK_CLASS nsIRenderingContextBidiProcessor : public nsBidiPresUtils::BidiProcessor {
16043: public:
68481:   nsIRenderingContextBidiProcessor(nsRenderingContext* aCtx,
68481:                                    nsRenderingContext* aTextRunConstructionContext,
16043:                                    const nsPoint&       aPt)
60677:     : mCtx(aCtx), mTextRunConstructionContext(aTextRunConstructionContext), mPt(aPt) { }
16043: 
16043:   ~nsIRenderingContextBidiProcessor()
16043:   {
80486:     mCtx->SetTextRunRTL(false);
16043:   }
16043: 
16043:   virtual void SetText(const PRUnichar* aText,
16043:                        PRInt32          aLength,
16043:                        nsBidiDirection  aDirection)
16043:   {
60677:     mTextRunConstructionContext->SetTextRunRTL(aDirection==NSBIDI_RTL);
16043:     mText = aText;
16043:     mLength = aLength;
16043:   }
16043: 
16043:   virtual nscoord GetWidth()
16043:   {
68484:     return mTextRunConstructionContext->GetWidth(mText, mLength);
16043:   }
16043: 
16043:   virtual void DrawText(nscoord aXOffset,
16043:                         nscoord)
16043:   {
68486:     mCtx->FontMetrics()->DrawString(mText, mLength, mPt.x + aXOffset, mPt.y,
60677:                                     mCtx, mTextRunConstructionContext);
16043:   }
16043: 
16043: private:
68481:   nsRenderingContext* mCtx;
68481:   nsRenderingContext* mTextRunConstructionContext;
16043:   nsPoint mPt;
16043:   const PRUnichar* mText;
16043:   PRInt32 mLength;
16043:   nsBidiDirection mDirection;
16043: };
16043: 
16043: nsresult nsBidiPresUtils::ProcessTextForRenderingContext(const PRUnichar*       aText,
16043:                                                          PRInt32                aLength,
16043:                                                          nsBidiDirection        aBaseDirection,
16043:                                                          nsPresContext*         aPresContext,
68481:                                                          nsRenderingContext&   aRenderingContext,
68481:                                                          nsRenderingContext&   aTextRunConstructionContext,
16043:                                                          Mode                   aMode,
16043:                                                          nscoord                aX,
16043:                                                          nscoord                aY,
16043:                                                          nsBidiPositionResolve* aPosResolve,
16043:                                                          PRInt32                aPosResolveCount,
16043:                                                          nscoord*               aWidth)
16043: {
60677:   nsIRenderingContextBidiProcessor processor(&aRenderingContext, &aTextRunConstructionContext, nsPoint(aX, aY));
73724:   nsBidi bidiEngine;
16043:   return ProcessText(aText, aLength, aBaseDirection, aPresContext, processor,
73724:                      aMode, aPosResolve, aPosResolveCount, aWidth, &bidiEngine);
16043: }
42982: 
59830: /* static */
59830: void nsBidiPresUtils::WriteReverse(const PRUnichar* aSrc,
59830:                                    PRUint32 aSrcLength,
59830:                                    PRUnichar* aDest)
59830: {
59830:   const PRUnichar* src = aSrc + aSrcLength;
59830:   PRUnichar* dest = aDest;
59830:   PRUint32 UTF32Char;
59830: 
59830:   while (--src >= aSrc) {
59830:     if (NS_IS_LOW_SURROGATE(*src)) {
59830:       if (src > aSrc && NS_IS_HIGH_SURROGATE(*(src - 1))) {
59830:         UTF32Char = SURROGATE_TO_UCS4(*(src - 1), *src);
59830:         --src;
59830:       } else {
59830:         UTF32Char = UCS2_REPLACEMENT_CHAR;
59830:       }
59830:     } else if (NS_IS_HIGH_SURROGATE(*src)) {
59830:       // paired high surrogates are handled above, so this is a lone high surrogate
59830:       UTF32Char = UCS2_REPLACEMENT_CHAR;
59830:     } else {
59830:       UTF32Char = *src;
59830:     }
59830: 
59830:     UTF32Char = gfxUnicodeProperties::GetMirroredChar(UTF32Char);
59830: 
59830:     if (IS_IN_BMP(UTF32Char)) {
59830:       *(dest++) = UTF32Char;
59830:     } else {
59830:       *(dest++) = H_SURROGATE(UTF32Char);
59830:       *(dest++) = L_SURROGATE(UTF32Char);
59830:     }
59830:   }
59830: 
59830:   NS_ASSERTION(dest - aDest == aSrcLength, "Whole string not copied");
59830: }
59830: 
59830: /* static */
79445: bool nsBidiPresUtils::WriteLogicalToVisual(const PRUnichar* aSrc,
59830:                                              PRUint32 aSrcLength,
59830:                                              PRUnichar* aDest,
59830:                                              nsBidiLevel aBaseDirection,
59830:                                              nsBidi* aBidiEngine)
59830: {
59830:   const PRUnichar* src = aSrc;
59830:   nsresult rv = aBidiEngine->SetPara(src, aSrcLength, aBaseDirection, nsnull);
59830:   if (NS_FAILED(rv)) {
80486:     return false;
59830:   }
59830: 
59830:   nsBidiDirection dir;
59830:   rv = aBidiEngine->GetDirection(&dir);
59830:   // NSBIDI_LTR returned from GetDirection means the whole text is LTR
59830:   if (NS_FAILED(rv) || dir == NSBIDI_LTR) {
80486:     return false;
59830:   }
59830: 
59830:   PRInt32 runCount;
59830:   rv = aBidiEngine->CountRuns(&runCount);
59830:   if (NS_FAILED(rv)) {
80486:     return false;
59830:   }
59830: 
59830:   PRInt32 runIndex, start, length;
59830:   PRUnichar* dest = aDest;
59830: 
59830:   for (runIndex = 0; runIndex < runCount; ++runIndex) {
59830:     rv = aBidiEngine->GetVisualRun(runIndex, &start, &length, &dir);
59830:     if (NS_FAILED(rv)) {
80486:       return false;
59830:     }
59830: 
59830:     src = aSrc + start;
59830: 
59830:     if (dir == NSBIDI_RTL) {
59830:       WriteReverse(src, length, dest);
59830:       dest += length;
59830:     } else {
59830:       do {
59830:         NS_ASSERTION(src >= aSrc && src < aSrc + aSrcLength,
59830:                      "logical index out of range");
59830:         NS_ASSERTION(dest < aDest + aSrcLength, "visual index out of range");
59830:         *(dest++) = *(src++);
59830:       } while (--length);
59830:     }
59830:   }
59830: 
59830:   NS_ASSERTION(dest - aDest == aSrcLength, "whole string not copied");
80486:   return true;
59830: }
59830: 
59830: void nsBidiPresUtils::CopyLogicalToVisual(const nsAString& aSource,
59830:                                           nsAString& aDest,
59830:                                           nsBidiLevel aBaseDirection,
79445:                                           bool aOverride)
59830: {
59830:   aDest.SetLength(0);
59830:   PRUint32 srcLength = aSource.Length();
59830:   if (srcLength == 0)
59830:     return;
59830:   if (!EnsureStringLength(aDest, srcLength)) {
59830:     return;
59830:   }
59830:   nsAString::const_iterator fromBegin, fromEnd;
59830:   nsAString::iterator toBegin;
59830:   aSource.BeginReading(fromBegin);
59830:   aSource.EndReading(fromEnd);
59830:   aDest.BeginWriting(toBegin);
59830: 
59830:   if (aOverride) {
59830:     if (aBaseDirection == NSBIDI_RTL) {
59830:       // no need to use the converter -- just copy the string in reverse order
59830:       WriteReverse(fromBegin.get(), srcLength, toBegin.get());
59830:     } else {
59830:       // if aOverride && aBaseDirection == NSBIDI_LTR, fall through to the
59830:       // simple copy
59830:       aDest.SetLength(0);
59830:     }
59830:   } else {
73724:     nsBidi bidiEngine;
59830:     if (!WriteLogicalToVisual(fromBegin.get(), srcLength, toBegin.get(),
73724:                              aBaseDirection, &bidiEngine)) {
59830:       aDest.SetLength(0);
59830:     }
59830:   }
59830: 
59830:   if (aDest.IsEmpty()) {
59830:     // Either there was an error or the source is unidirectional
59830:     //  left-to-right. In either case, just copy source to dest.
59830:     CopyUnicodeTo(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd),
59830:                   aDest);
59830:   }
59830: }
    1: #endif // IBMBIDI
