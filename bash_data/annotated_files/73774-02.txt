    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsTextControlFrame_h___
    1: #define nsTextControlFrame_h___
    1: 
    1: #include "nsStackFrame.h"
23176: #include "nsBlockFrame.h"
    1: #include "nsIFormControlFrame.h"
    1: #include "nsIAnonymousContentCreator.h"
    1: #include "nsITextControlFrame.h"
    1: #include "nsDisplayList.h"
37056: #include "nsIScrollableFrame.h"
37971: #include "nsStubMutationObserver.h"
43129: #include "nsITextControlElement.h"
62233: #include "nsIStatefulFrame.h"
    1: 
    1: class nsIEditor;
    1: class nsISelectionController;
    1: class nsIDOMCharacterData;
    1: #ifdef ACCESSIBILITY
    1: class nsIAccessible;
    1: #endif
40693: class EditorInitializerEntryTracker;
43129: class nsTextEditorState;
    1: 
    1: class nsTextControlFrame : public nsStackFrame,
    1:                            public nsIAnonymousContentCreator,
62233:                            public nsITextControlFrame,
62233:                            public nsIStatefulFrame
    1: {
    1: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
32423: 
62233:   NS_DECLARE_FRAME_PROPERTY(ContentScrollPos, DestroyPoint)
62233: 
    1:   nsTextControlFrame(nsIPresShell* aShell, nsStyleContext* aContext);
    1:   virtual ~nsTextControlFrame();
    1: 
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
    1: 
37056:   virtual nsIScrollableFrame* GetScrollTargetFrame() {
37056:     if (!IsScrollable())
37056:       return nsnull;
37056:     return do_QueryFrame(GetFirstChild(nsnull));
37056:   }
37056: 
68481:   virtual nscoord GetMinWidth(nsRenderingContext* aRenderingContext);
68481:   virtual nsSize ComputeAutoSize(nsRenderingContext *aRenderingContext,
 4887:                                  nsSize aCBSize, nscoord aAvailableWidth,
 4887:                                  nsSize aMargin, nsSize aBorder,
 4887:                                  nsSize aPadding, PRBool aShrinkWrap);
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
    1:   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual PRBool IsCollapsed(nsBoxLayoutState& aBoxLayoutState);
    1: 
    1:   DECL_DO_GLOBAL_REFLOW_COUNT_DSP(nsTextControlFrame, nsStackFrame)
    1: 
    1:   virtual PRBool IsLeaf() const;
    1:   
    1: #ifdef ACCESSIBILITY
46338:   virtual already_AddRefed<nsAccessible> CreateAccessible();
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const
    1:   {
    1:     aResult.AssignLiteral("nsTextControlFrame");
    1:     return NS_OK;
    1:   }
    1: #endif
    1: 
    1:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
    1:   {
    1:     // nsStackFrame is already both of these, but that's somewhat bogus,
    1:     // and we really mean it.
    1:     return nsStackFrame::IsFrameOfType(aFlags &
    1:       ~(nsIFrame::eReplaced | nsIFrame::eReplacedContainsBlock));
    1:   }
    1: 
    1:   // nsIAnonymousContentCreator
69438:   virtual nsresult CreateAnonymousContent(nsTArray<ContentInfo>& aElements);
55877:   virtual void AppendAnonymousContentTo(nsBaseContentList& aElements,
55877:                                         PRUint32 aFilter);
    1: 
    1:   // Utility methods to set current widget state
    1: 
    1:   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
30790:                                  nsFrameList&    aChildList);
    1: 
    1: //==== BEGIN NSIFORMCONTROLFRAME
    1:   virtual void SetFocus(PRBool aOn , PRBool aRepaint); 
    1:   virtual nsresult SetFormProperty(nsIAtom* aName, const nsAString& aValue);
    1:   virtual nsresult GetFormProperty(nsIAtom* aName, nsAString& aValue) const; 
    1: 
    1: 
    1: //==== END NSIFORMCONTROLFRAME
    1: 
24402: //==== NSITEXTCONTROLFRAME
    1: 
    1:   NS_IMETHOD    GetEditor(nsIEditor **aEditor);
    1:   NS_IMETHOD    GetTextLength(PRInt32* aTextLength);
    1:   NS_IMETHOD    CheckFireOnChange();
    1:   NS_IMETHOD    SetSelectionStart(PRInt32 aSelectionStart);
    1:   NS_IMETHOD    SetSelectionEnd(PRInt32 aSelectionEnd);
    1:   NS_IMETHOD    SetSelectionRange(PRInt32 aSelectionStart, PRInt32 aSelectionEnd);
    1:   NS_IMETHOD    GetSelectionRange(PRInt32* aSelectionStart, PRInt32* aSelectionEnd);
43129:   NS_IMETHOD    GetOwnedSelectionController(nsISelectionController** aSelCon);
43129:   virtual nsFrameSelection* GetOwnedFrameSelection();
    1: 
20884:   nsresult GetPhonetic(nsAString& aPhonetic);
    1: 
40683:   /**
40683:    * Ensure mEditor is initialized with the proper flags and the default value.
40683:    * @throws NS_ERROR_NOT_INITIALIZED if mEditor has not been created
40683:    * @throws various and sundry other things
40683:    */
40683:   virtual nsresult EnsureEditorInitialized();
40683: 
24402: //==== END NSITEXTCONTROLFRAME
62233: 
62233: //==== NSISTATEFULFRAME
62233: 
62233:   NS_IMETHOD SaveState(SpecialStateID aStateID, nsPresState** aState);
62233:   NS_IMETHOD RestoreState(nsPresState* aState);
62233: 
62233: //=== END NSISTATEFULFRAME
62233: 
    1: //==== OVERLOAD of nsIFrame
    1:   virtual nsIAtom* GetType() const;
    1: 
    1:   /** handler for attribute changes to mContent */
    1:   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
    1:                               nsIAtom*        aAttribute,
    1:                               PRInt32         aModType);
    1: 
37971:   nsresult GetText(nsString& aText);
    1: 
23554:   NS_DECL_QUERYFRAME
    1: 
70230:   // Temp reference to scriptrunner
70230:   // We could make these auto-Revoking via the "delete" entry for safety
70230:   NS_DECLARE_FRAME_PROPERTY(TextControlInitializer, nsnull)
70230: 
70230: 
    1: public: //for methods who access nsTextControlFrame directly
59460:   void FireOnInput(PRBool aTrusted);
    1:   void SetValueChanged(PRBool aValueChanged);
    1:   /** Called when the frame is focused, to remember the value for onChange. */
    1:   nsresult InitFocusedValue();
    1: 
    1:   void SetFireChangeEventState(PRBool aNewState)
    1:   {
    1:     mFireChangeEventState = aNewState;
  731:   }
    1: 
    1:   PRBool GetFireChangeEventState() const
    1:   {
    1:     return mFireChangeEventState;
    1:   }    
    1: 
 6348:   // called by the focus listener
 6348:   nsresult MaybeBeginSecureKeyboardInput();
 6348:   void MaybeEndSecureKeyboardInput();
 6348: 
43129:   class ValueSetter {
43129:   public:
43129:     ValueSetter(nsTextControlFrame* aFrame,
43129:                 PRBool aHasFocusValue)
43129:       : mFrame(aFrame)
43129:       // This method isn't used for user-generated changes, except for calls
43129:       // from nsFileControlFrame which sets mFireChangeEventState==true and
43129:       // restores it afterwards (ie. we want 'change' events for those changes).
43129:       // Focused value must be updated to prevent incorrect 'change' events,
43129:       // but only if user hasn't changed the value.
68468:       , mFocusValueInit(!mFrame->mFireChangeEventState && aHasFocusValue)
68468:       , mOuterTransaction(false)
68468:       , mInited(false)
68468:     {
68468:       NS_ASSERTION(aFrame, "Should pass a valid frame");
43129:     }
43129:     void Cancel() {
43129:       mInited = PR_FALSE;
43129:     }
43129:     void Init() {
43129:       // Since this code does not handle user-generated changes to the text,
43129:       // make sure we don't fire oninput when the editor notifies us.
43129:       // (mNotifyOnInput must be reset before we return).
43129: 
43129:       // To protect against a reentrant call to SetValue, we check whether
43129:       // another SetValue is already happening for this frame.  If it is,
43129:       // we must wait until we unwind to re-enable oninput events.
43129:       mOuterTransaction = mFrame->mNotifyOnInput;
43129:       if (mOuterTransaction)
43129:         mFrame->mNotifyOnInput = PR_FALSE;
43129: 
43129:       mInited = PR_TRUE;
43129:     }
43129:     ~ValueSetter() {
43129:       if (!mInited)
43129:         return;
43129: 
43129:       if (mOuterTransaction)
43129:         mFrame->mNotifyOnInput = PR_TRUE;
43129: 
43129:       if (mFocusValueInit) {
43129:         // Reset mFocusedValue so the onchange event doesn't fire incorrectly.
43129:         mFrame->InitFocusedValue();
43129:       }
43129:     }
43129: 
43129:   private:
43129:     nsTextControlFrame* mFrame;
43129:     PRPackedBool mFocusValueInit;
43129:     PRPackedBool mOuterTransaction;
43129:     PRPackedBool mInited;
43129:   };
43129:   friend class ValueSetter;
43129: 
43129: #define DEFINE_TEXTCTRL_FORWARDER(type, name)                                  \
43129:   type name() {                                                                \
43129:     nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent()); \
43129:     NS_ASSERTION(txtCtrl, "Content not a text control element");               \
43129:     return txtCtrl->name();                                                    \
43129:   }
43129: #define DEFINE_TEXTCTRL_CONST_FORWARDER(type, name)                            \
43129:   type name() const {                                                          \
43129:     nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent()); \
43129:     NS_ASSERTION(txtCtrl, "Content not a text control element");               \
43129:     return txtCtrl->name();                                                    \
43129:   }
43129: 
43129:   DEFINE_TEXTCTRL_CONST_FORWARDER(PRBool, IsSingleLineTextControl)
43129:   DEFINE_TEXTCTRL_CONST_FORWARDER(PRBool, IsTextArea)
43129:   DEFINE_TEXTCTRL_CONST_FORWARDER(PRBool, IsPlainTextControl)
43129:   DEFINE_TEXTCTRL_CONST_FORWARDER(PRBool, IsPasswordTextControl)
43129:   DEFINE_TEXTCTRL_FORWARDER(PRInt32, GetCols)
43129:   DEFINE_TEXTCTRL_FORWARDER(PRInt32, GetWrapCols)
43129:   DEFINE_TEXTCTRL_FORWARDER(PRInt32, GetRows)
43129: 
43129: #undef DEFINE_TEXTCTRL_CONST_FORWARDER
43129: #undef DEFINE_TEXTCTRL_FORWARDER
43129: 
    1: protected:
24402:   class EditorInitializer;
24402:   friend class EditorInitializer;
43129:   friend class nsTextEditorState; // needs access to UpdateValueDisplay
24402: 
24402:   class EditorInitializer : public nsRunnable {
24402:   public:
24402:     EditorInitializer(nsTextControlFrame* aFrame) :
24402:       mFrame(aFrame) {}
24402: 
24402:     NS_IMETHOD Run() {
70230:       if (mFrame) {
73774:         // need to block script to avoid bug 669767
73774:         nsAutoScriptBlocker scriptBlocker;
73774: 
27606:         nsCOMPtr<nsIPresShell> shell =
70230:           mFrame->PresContext()->GetPresShell();
27606:         PRBool observes = shell->ObservesNativeAnonMutationsForPrint();
27606:         shell->ObserveNativeAnonMutationsForPrint(PR_TRUE);
73774:         // This can cause the frame to be destroyed (and call Revoke()
43129:         mFrame->EnsureEditorInitialized();
27606:         shell->ObserveNativeAnonMutationsForPrint(observes);
73774: 
73774:         NS_ASSERTION(mFrame,"Frame destroyed even though we had a scriptblocker");
70230:         mFrame->FinishedInitializer();
24402:       }
24402:       return NS_OK;
24402:     }
24402: 
70230:     // avoids use of nsWeakFrame
70230:     void Revoke() {
70230:       mFrame = nsnull;
70230:     }
70230: 
24402:   private:
24402:     nsTextControlFrame* mFrame;
24402:   };
24402: 
42170:   class ScrollOnFocusEvent;
42170:   friend class ScrollOnFocusEvent;
42170: 
42170:   class ScrollOnFocusEvent : public nsRunnable {
42170:   public:
42170:     ScrollOnFocusEvent(nsTextControlFrame* aFrame) :
42170:       mFrame(aFrame) {}
42170: 
42170:     NS_DECL_NSIRUNNABLE
42170: 
42170:     void Revoke() {
42170:       mFrame = nsnull;
42170:     }
42170: 
42170:   private:
42170:     nsTextControlFrame* mFrame;
42170:   };
42170: 
24402:   nsresult DOMPointToOffset(nsIDOMNode* aNode, PRInt32 aNodeOffset, PRInt32 *aResult);
24402:   nsresult OffsetToDOMPoint(PRInt32 aOffset, nsIDOMNode** aResult, PRInt32* aPosition);
24402: 
    1:   /**
    1:    * Find out whether this control is scrollable (i.e. if it is not a single
    1:    * line text control)
    1:    * @return whether this control is scrollable
    1:    */
    1:   PRBool IsScrollable() const;
40692: 
40692:   /**
40692:    * Update the textnode under our anonymous div to show the new
40692:    * value. This should only be called when we have no editor yet.
40692:    * @throws NS_ERROR_UNEXPECTED if the div has no text content
40692:    */
40692:   nsresult UpdateValueDisplay(PRBool aNotify,
40692:                               PRBool aBeforeEditorInit = PR_FALSE,
40692:                               const nsAString *aValue = nsnull);
40692: 
40509:   /**
    1:    * Get the maxlength attribute
    1:    * @param aMaxLength the value of the max length attr
    1:    * @returns PR_FALSE if attr not defined
    1:    */
    1:   PRBool GetMaxLength(PRInt32* aMaxLength);
40692: 
    1:   /**
    1:    * Find out whether an attribute exists on the content or not.
    1:    * @param aAtt the attribute to determine the existence of
    1:    * @returns PR_FALSE if it does not exist
    1:    */
    1:   PRBool AttributeExists(nsIAtom *aAtt) const
    1:   { return mContent && mContent->HasAttr(kNameSpaceID_None, aAtt); }
    1: 
    1:   /**
    1:    * We call this when we are being destroyed or removed from the PFM.
    1:    * @param aPresContext the current pres context
    1:    */
    1:   void PreDestroy();
    1: 
    1:   // Compute our intrinsic size.  This does not include any borders, paddings,
    1:   // etc.  Just the size of our actual area for the text (and the scrollbars,
    1:   // for <textarea>).
68481:   nsresult CalcIntrinsicSize(nsRenderingContext* aRenderingContext,
    1:                              nsSize&              aIntrinsicSize);
    1: 
62234:   nsresult ScrollSelectionIntoView();
62234: 
    1: private:
    1:   //helper methods
    1:   nsresult SetSelectionInternal(nsIDOMNode *aStartNode, PRInt32 aStartOffset,
    1:                                 nsIDOMNode *aEndNode, PRInt32 aEndOffset);
37971:   nsresult SelectAllOrCollapseToEndOfText(PRBool aSelect);
    1:   nsresult SetSelectionEndPoints(PRInt32 aSelStart, PRInt32 aSelEnd);
    1: 
43129:   // accessors for the notify on input flag
43129:   PRBool GetNotifyOnInput() const { return mNotifyOnInput; }
43129:   void SetNotifyOnInput(PRBool val) { mNotifyOnInput = val; }
38754: 
43129:   /**
43129:    * Return the root DOM element, and implicitly initialize the editor if needed.
43129:    */
43129:   nsresult GetRootNodeAndInitializeEditor(nsIDOMElement **aRootElement);
40697: 
70230:   void FinishedInitializer() {
70230:     Properties().Delete(TextControlInitializer());
70230:   }
70230: 
    1: private:
    1:   // these packed bools could instead use the high order bits on mState, saving 4 bytes 
    1:   PRPackedBool mUseEditor;
    1:   PRPackedBool mIsProcessing;
    1:   PRPackedBool mNotifyOnInput;//default this to off to stop any notifications until setup is complete
    1:   // Calls to SetValue will be treated as user values (i.e. trigger onChange
    1:   // eventually) when mFireChangeEventState==true, this is used by nsFileControlFrame.
    1:   PRPackedBool mFireChangeEventState;
56086:   // Keep track if we have asked a placeholder node creation.
56086:   PRPackedBool mUsePlaceholder;
    1: 
40693: #ifdef DEBUG
40693:   PRPackedBool mInEditorInitialization;
40693:   friend class EditorInitializerEntryTracker;
40693: #endif
40693: 
    1:   nsString mFocusedValue;
42170:   nsRevocableEventPtr<ScrollOnFocusEvent> mScrollEvent;
    1: };
    1: 
    1: #endif
    1: 
    1: 
