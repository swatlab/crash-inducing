33581: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsfun_h___
    1: #define jsfun_h___
    1: /*
    1:  * JS function definitions.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
13824: #include "jsobj.h"
48676: #include "jsatom.h"
59968: #include "jsscript.h"
48676: #include "jsstr.h"
55527: #include "jsopcode.h"
    1: 
27012: /*
28832:  * The high two bits of JSFunction.flags encode whether the function is native
28832:  * or interpreted, and if interpreted, what kind of optimized closure form (if
27012:  * any) it might be.
27012:  *
27012:  *   00   not interpreted
27012:  *   01   interpreted, neither flat nor null closure
27012:  *   10   interpreted, flat closure
27012:  *   11   interpreted, null closure
27012:  *
27012:  * FUN_FLAT_CLOSURE implies FUN_INTERPRETED and u.i.script->upvarsOffset != 0.
27012:  * FUN_NULL_CLOSURE implies FUN_INTERPRETED and u.i.script->upvarsOffset == 0.
27012:  *
27012:  * FUN_INTERPRETED but not FUN_FLAT_CLOSURE and u.i.script->upvarsOffset != 0
27012:  * is an Algol-like function expression or nested function, i.e., a function
27012:  * that never escapes upward or downward (heapward), and is only ever called.
27012:  *
27012:  * Finally, FUN_INTERPRETED and u.i.script->upvarsOffset == 0 could be either
27012:  * a non-closure (a global function definition, or any function that uses no
27012:  * outer names), or a closure of an escaping function that uses outer names
27012:  * whose values can't be snapshot (because the outer names could be reassigned
27012:  * after the closure is formed, or because assignments could not be analyzed
27012:  * due to with or eval).
27012:  *
27012:  * Such a hard-case function must use JSOP_NAME, etc., and reify outer function
27012:  * activations' call objects, etc. if it's not a global function.
27012:  *
27012:  * NB: JSFUN_EXPR_CLOSURE reuses JSFUN_STUB_GSOPS, which is an API request flag
27012:  * bit only, never stored in fun->flags.
27012:  *
27012:  * If we need more bits in the future, all flags for FUN_INTERPRETED functions
27012:  * can move to u.i.script->flags. For now we use function flag bits to minimize
27012:  * pointer-chasing.
27012:  */
48676: #define JSFUN_JOINABLE      0x0001  /* function is null closure that does not
48676:                                        appear to call itself via its own name
48676:                                        or arguments.callee */
48676: 
55498: #define JSFUN_PROTOTYPE     0x0800  /* function is Function.prototype for some
55498:                                        global object */
55498: 
27012: #define JSFUN_EXPR_CLOSURE  0x1000  /* expression closure: function(x) x*x */
32669: #define JSFUN_TRCINFO       0x2000  /* when set, u.n.trcinfo is non-null,
32669:                                        JSFunctionSpec::call points to a
32669:                                        JSNativeTraceInfo. */
27012: #define JSFUN_INTERPRETED   0x4000  /* use u.i if kind >= this value else u.n */
61713: #define JSFUN_FLAT_CLOSURE  0x8000  /* flag (aka "display") closure */
27012: #define JSFUN_NULL_CLOSURE  0xc000  /* null closure entrains no scope chain */
27012: #define JSFUN_KINDMASK      0xc000  /* encode interp vs. native and closure
27012:                                        optimization level -- see above */
 4127: 
33581: #define FUN_OBJECT(fun)      (static_cast<JSObject *>(fun))
27012: #define FUN_KIND(fun)        ((fun)->flags & JSFUN_KINDMASK)
27012: #define FUN_SET_KIND(fun,k)  ((fun)->flags = ((fun)->flags & ~JSFUN_KINDMASK) | (k))
27012: #define FUN_INTERPRETED(fun) (FUN_KIND(fun) >= JSFUN_INTERPRETED)
27012: #define FUN_FLAT_CLOSURE(fun)(FUN_KIND(fun) == JSFUN_FLAT_CLOSURE)
27012: #define FUN_NULL_CLOSURE(fun)(FUN_KIND(fun) == JSFUN_NULL_CLOSURE)
13702: #define FUN_SCRIPT(fun)      (FUN_INTERPRETED(fun) ? (fun)->u.i.script : NULL)
20408: #define FUN_CLASP(fun)       (JS_ASSERT(!FUN_INTERPRETED(fun)),               \
25887:                               fun->u.n.clasp)
20408: #define FUN_TRCINFO(fun)     (JS_ASSERT(!FUN_INTERPRETED(fun)),               \
32669:                               JS_ASSERT((fun)->flags & JSFUN_TRCINFO),        \
25887:                               fun->u.n.trcinfo)
20408: 
55746: struct JSFunction : public JSObject_Slots2
38549: {
55746:     /* Functions always have two fixed slots (FUN_CLASS_RESERVED_SLOTS). */
55746: 
28832:     uint16          nargs;        /* maximum number of specified arguments,
28832:                                      reflected as f.length/f.arity */
28832:     uint16          flags;        /* flags, see JSFUN_* below and in jsapi.h */
52872:     union U {
28832:         struct {
48470:             js::Native  native;   /* native method pointer or null */
48470:             js::Class   *clasp;   /* class of objects constructed
28832:                                      by this function */
32669:             JSNativeTraceInfo *trcinfo;
28832:         } n;
52872:         struct Scripted {
57713:             JSScript    *script;  /* interpreted bytecode descriptor or null */
28952:             uint16       skipmin; /* net skip amount up (toward zero) from
28952:                                      script->staticLevel to nearest upvar,
28952:                                      including upvars in nested functions */
28952:             JSPackedBool wrapper; /* true if this function is a wrapper that
28952:                                      rewrites bytecode optimized for a function
28952:                                      judged non-escaping by the compiler, which
28952:                                      then escaped via the debugger or a rogue
28952:                                      indirect eval; if true, then this function
28952:                                      object's proto is the wrapped object */
52503:             js::Shape   *names;   /* argument and variable names */
28832:         } i;
57713:         void            *nativeOrScript;
28832:     } u;
28832:     JSAtom          *atom;        /* name for diagnostics and decompiling */
28832: 
33604:     bool optimizedClosure()  const { return FUN_KIND(this) > JSFUN_INTERPRETED; }
33604:     bool needsWrapper()      const { return FUN_NULL_CLOSURE(this) && u.i.skipmin != 0; }
42714:     bool isInterpreted()     const { return FUN_INTERPRETED(this); }
53557:     bool isNative()          const { return !FUN_INTERPRETED(this); }
53557:     bool isConstructor()     const { return flags & JSFUN_CONSTRUCTOR; }
42714:     bool isHeavyweight()     const { return JSFUN_HEAVYWEIGHT_TEST(flags); }
57829:     bool isFlatClosure()     const { return FUN_KIND(this) == JSFUN_FLAT_CLOSURE; }
28832: 
55498:     bool isFunctionPrototype() const { return flags & JSFUN_PROTOTYPE; }
55498: 
59942:     /* Returns the strictness of this function, which must be interpreted. */
51095:     inline bool inStrictMode() const;
51095: 
59968:     void setArgCount(uint16 nargs) {
59968:         JS_ASSERT(this->nargs == 0);
59968:         this->nargs = nargs;
37694:     }
37694: 
43221:     /* uint16 representation bounds number of call object dynamic slots. */
43223:     enum { MAX_ARGS_AND_VARS = 2 * ((1U << 16) - 1) };
43221: 
52503: #define JS_LOCAL_NAME_TO_ATOM(nameWord)  ((JSAtom *) ((nameWord) & ~(jsuword) 1))
52503: #define JS_LOCAL_NAME_IS_CONST(nameWord) ((((nameWord) & (jsuword) 1)) != 0)
38549: 
38549:     bool mightEscape() const {
59968:         return isInterpreted() && (isFlatClosure() || !script()->bindings.hasUpvars());
38549:     }
48676: 
48676:     bool joinable() const {
48676:         return flags & JSFUN_JOINABLE;
48676:     }
48676: 
53840:     JSObject &compiledFunObj() {
53840:         return *this;
53840:     }
53840: 
48676:   private:
48676:     /*
48676:      * js_FunctionClass reserves two slots, which are free in JSObject::fslots
48676:      * without requiring dslots allocation. Null closures that can be joined to
48676:      * a compiler-created function object use the first one to hold a mutable
48676:      * methodAtom() state variable, needed for correct foo.caller handling.
48676:      */
48676:     enum {
48676:         METHOD_ATOM_SLOT  = JSSLOT_FUN_METHOD_ATOM
48676:     };
48676: 
48676:   public:
48676:     void setJoinable() {
48676:         JS_ASSERT(FUN_INTERPRETED(this));
55746:         getSlotRef(METHOD_ATOM_SLOT).setNull();
48676:         flags |= JSFUN_JOINABLE;
48676:     }
48676: 
48676:     /*
48676:      * Method name imputed from property uniquely assigned to or initialized,
48676:      * where the function does not need to be cloned to carry a scope chain or
48676:      * flattened upvars.
48676:      */
48676:     JSAtom *methodAtom() const {
55746:         return (joinable() && getSlot(METHOD_ATOM_SLOT).isString())
55746:                ? STRING_TO_ATOM(getSlot(METHOD_ATOM_SLOT).toString())
48676:                : NULL;
48676:     }
48676: 
48676:     void setMethodAtom(JSAtom *atom) {
48676:         JS_ASSERT(joinable());
55746:         getSlotRef(METHOD_ATOM_SLOT).setString(ATOM_TO_STRING(atom));
48676:     }
52503: 
53557:     js::Native maybeNative() const {
53557:         return isInterpreted() ? NULL : u.n.native;
53557:     }
53557: 
53840:     JSScript *script() const {
53840:         JS_ASSERT(isInterpreted());
53840:         return u.i.script;
53840:     }
53840: 
57713:     static uintN offsetOfNativeOrScript() {
57713:         JS_STATIC_ASSERT(offsetof(U, n.native) == offsetof(U, i.script));
57713:         JS_STATIC_ASSERT(offsetof(U, n.native) == offsetof(U, nativeOrScript));
57713:         return offsetof(JSFunction, u.nativeOrScript);
57713:     }
57713: 
55746:     /* Number of extra fixed function object slots. */
52503:     static const uint32 CLASS_RESERVED_SLOTS = JSObject::FUN_CLASS_RESERVED_SLOTS;
28832: };
28832: 
20408: /*
32669:  * Trace-annotated native. This expands to a JSFunctionSpec initializer (like
48470:  * JS_FN in jsapi.h). fastcall is a FastNative; trcinfo is a
32669:  * JSNativeTraceInfo*.
20408:  */
20408: #ifdef JS_TRACER
20408: /* MSVC demands the intermediate (void *) cast here. */
20408: # define JS_TN(name,fastcall,nargs,flags,trcinfo)                             \
53557:     JS_FN(name, JS_DATA_TO_FUNC_PTR(Native, trcinfo), nargs,                  \
53557:           (flags) | JSFUN_STUB_GSOPS | JSFUN_TRCINFO)
20408: #else
20408: # define JS_TN(name,fastcall,nargs,flags,trcinfo)                             \
20408:     JS_FN(name, fastcall, nargs, flags)
20408: #endif
    1: 
40405: /*
51095:  * NB: the Arguments classes are uninitialized internal classes that masquerade
51095:  * (according to Object.prototype.toString.call(arguments)) as "Arguments",
51095:  * while having Object.getPrototypeOf(arguments) === Object.prototype.
40405:  *
40405:  * WARNING (to alert embedders reading this private .h file): arguments objects
40405:  * are *not* thread-safe and should not be used concurrently -- they should be
40405:  * used by only one thread at a time, preferably by only one thread over their
40405:  * lifetime (a JS worker that migrates from one OS thread to another but shares
40405:  * nothing is ok).
40405:  *
40405:  * Yes, this is an incompatible change, which prefigures the impending move to
40405:  * single-threaded objects and GC heaps.
40405:  */
48470: extern js::Class js_ArgumentsClass;
52503: 
51095: namespace js {
52503: 
51095: extern Class StrictArgumentsClass;
52503: 
52503: struct ArgumentsData {
52503:     js::Value   callee;
52503:     js::Value   slots[1];
52503: };
52503: 
51095: }
51095: 
51095: inline bool
51095: JSObject::isNormalArguments() const
51095: {
51095:     return getClass() == &js_ArgumentsClass;
51095: }
51095: 
51095: inline bool
51095: JSObject::isStrictArguments() const
51095: {
51095:     return getClass() == &js::StrictArgumentsClass;
51095: }
40405: 
40405: inline bool
40405: JSObject::isArguments() const
40405: {
51095:     return isNormalArguments() || isStrictArguments();
40405: }
40405: 
52503: #define JS_ARGUMENTS_OBJECT_ON_TRACE ((void *)0xa126)
49124: 
48470: extern JS_PUBLIC_DATA(js::Class) js_CallClass;
48470: extern JS_PUBLIC_DATA(js::Class) js_FunctionClass;
48470: extern js::Class js_DeclEnvClass;
52503: 
52503: inline bool
52503: JSObject::isCall() const
52503: {
52503:     return getClass() == &js_CallClass;
52503: }
    1: 
37003: inline bool
37003: JSObject::isFunction() const
37003: {
37003:     return getClass() == &js_FunctionClass;
37003: }
37003: 
53557: inline JSFunction *
53557: JSObject::getFunctionPrivate() const
53557: {
53557:     JS_ASSERT(isFunction());
53557:     return reinterpret_cast<JSFunction *>(getPrivate());
53557: }
53557: 
53557: namespace js {
53557: 
    1: /*
60146:  * Construct a call object for the given bindings.  If this is a call object
60146:  * for a function invocation, callee should be the function being called.
60146:  * Otherwise it must be a call object for eval of strict mode code, and callee
60146:  * must be null.
60146:  */
60146: extern JSObject *
62855: NewCallObject(JSContext *cx, js::Bindings *bindings, JSObject &scopeChain, JSObject *callee,
62855:               Origins origin);
60146: 
60146: /*
    1:  * NB: jsapi.h and jsobj.h must be included before any call to this macro.
    1:  */
    1: #define VALUE_IS_FUNCTION(cx, v)                                              \
40430:     (!JSVAL_IS_PRIMITIVE(v) && JSVAL_TO_OBJECT(v)->isFunction())
    1: 
48470: static JS_ALWAYS_INLINE bool
48470: IsFunctionObject(const js::Value &v)
48470: {
48470:     return v.isObject() && v.toObject().isFunction();
48470: }
48470: 
48470: static JS_ALWAYS_INLINE bool
48470: IsFunctionObject(const js::Value &v, JSObject **funobj)
48470: {
48470:     return v.isObject() && (*funobj = &v.toObject())->isFunction();
48470: }
48470: 
53557: static JS_ALWAYS_INLINE bool
53557: IsFunctionObject(const js::Value &v, JSFunction **fun)
53557: {
53557:     JSObject *funobj;
53557:     bool b = IsFunctionObject(v, &funobj);
53557:     if (b)
53557:         *fun = funobj->getFunctionPrivate();
53557:     return b;
53557: }
53557: 
59878: extern JS_ALWAYS_INLINE bool
59878: SameTraceType(const Value &lhs, const Value &rhs)
59878: {
59878:     return SameType(lhs, rhs) &&
59878:            (lhs.isPrimitive() ||
59878:             lhs.toObject().isFunction() == rhs.toObject().isFunction());
59878: }
59878: 
13691: /*
13691:  * Macro to access the private slot of the function object after the slot is
13691:  * initialized.
13691:  */
13691: #define GET_FUNCTION_PRIVATE(cx, funobj)                                      \
40430:     (JS_ASSERT((funobj)->isFunction()),                                       \
32684:      (JSFunction *) (funobj)->getPrivate())
13691: 
33604: /*
33604:  * Return true if this is a compiler-created internal function accessed by
33604:  * its own object. Such a function object must not be accessible to script
33604:  * or embedding code.
33604:  */
33604: inline bool
40405: IsInternalFunctionObject(JSObject *funobj)
33604: {
40430:     JS_ASSERT(funobj->isFunction());
33604:     JSFunction *fun = (JSFunction *) funobj->getPrivate();
33604:     return funobj == fun && (fun->flags & JSFUN_LAMBDA) && !funobj->getParent();
33604: }
33604:     
53557: /* Valueified JS_IsConstructing. */
53557: static JS_ALWAYS_INLINE bool
53557: IsConstructing(const Value *vp)
53557: {
53557: #ifdef DEBUG
53557:     JSObject *callee = &JS_CALLEE(cx, vp).toObject();
53557:     if (callee->isFunction()) {
53557:         JSFunction *fun = callee->getFunctionPrivate();
53557:         JS_ASSERT((fun->flags & JSFUN_CONSTRUCTOR) != 0);
53557:     } else {
53557:         JS_ASSERT(callee->getClass()->construct != NULL);
53557:     }
53557: #endif
53557:     return vp[1].isMagic();
53557: }
53557: 
53557: static JS_ALWAYS_INLINE bool
53557: IsConstructing_PossiblyWithGivenThisObject(const Value *vp, JSObject **ctorThis)
53557: {
53557: #ifdef DEBUG
53557:     JSObject *callee = &JS_CALLEE(cx, vp).toObject();
53557:     if (callee->isFunction()) {
53557:         JSFunction *fun = callee->getFunctionPrivate();
53557:         JS_ASSERT((fun->flags & JSFUN_CONSTRUCTOR) != 0);
53557:     } else {
53557:         JS_ASSERT(callee->getClass()->construct != NULL);
53557:     }
53557: #endif
53557:     bool isCtor = vp[1].isMagic();
53557:     if (isCtor)
53557:         *ctorThis = vp[1].getMagicObjectOrNullPayload();
53557:     return isCtor;
53557: }
53557: 
57812: inline const char *
57812: GetFunctionNameBytes(JSContext *cx, JSFunction *fun, JSAutoByteString *bytes)
57812: {
57812:     if (fun->atom)
57812:         return bytes->encode(cx, ATOM_TO_STRING(fun->atom));
57812:     return js_anonymous_str;
57812: }
57812: 
61449: extern JS_FRIEND_API(bool)
61448: IsBuiltinFunctionConstructor(JSFunction *fun);
61448: 
62590: /*
62590:  * Preconditions: funobj->isInterpreted() && !funobj->isFunctionPrototype() &&
62590:  * !funobj->isBoundFunction(). This is sufficient to establish that funobj has
62590:  * a non-configurable non-method .prototype data property, thought it might not
62590:  * have been resolved yet, and its value could be anything.
62590:  *
62590:  * Return the shape of the .prototype property of funobj, resolving it if
62590:  * needed. On error, return NULL.
62590:  *
62590:  * This is not safe to call on trace because it defines properties, which can
62590:  * trigger lookups that could reenter.
62590:  */
62590: const Shape *
62590: LookupInterpretedFunctionPrototype(JSContext *cx, JSObject *funobj);
62590: 
53557: } /* namespace js */
53557: 
51090: extern JSString *
51090: fun_toStringHelper(JSContext *cx, JSObject *obj, uintN indent);
51090: 
53557: extern JSFunction *
53557: js_NewFunction(JSContext *cx, JSObject *funobj, js::Native native, uintN nargs,
53557:                uintN flags, JSObject *parent, JSAtom *atom);
40405: 
    1: extern JSObject *
    1: js_InitFunctionClass(JSContext *cx, JSObject *obj);
    1: 
    1: extern JSObject *
    1: js_InitArgumentsClass(JSContext *cx, JSObject *obj);
    1: 
13702: extern void
13702: js_TraceFunction(JSTracer *trc, JSFunction *fun);
 8146: 
 4275: extern void
13702: js_FinalizeFunction(JSContext *cx, JSFunction *fun);
 4275: 
37694: extern JSObject * JS_FASTCALL
38604: js_CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent,
38604:                        JSObject *proto);
38604: 
38604: inline JSObject *
38604: CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent)
38604: {
38604:     JS_ASSERT(parent);
38604:     JSObject *proto;
38604:     if (!js_GetClassPrototype(cx, parent, JSProto_Function, &proto))
38604:         return NULL;
38604:     return js_CloneFunctionObject(cx, fun, parent, proto);
38604: }
    1: 
52503: extern JSObject * JS_FASTCALL
52503: js_AllocFlatClosure(JSContext *cx, JSFunction *fun, JSObject *scopeChain);
52503: 
60254: extern JSObject *
55527: js_NewFlatClosure(JSContext *cx, JSFunction *fun, JSOp op, size_t oplen);
13702: 
28952: extern JS_REQUIRES_STACK JSObject *
28952: js_NewDebuggableFlatClosure(JSContext *cx, JSFunction *fun);
28952: 
13702: extern JSFunction *
57721: js_DefineFunction(JSContext *cx, JSObject *obj, jsid id, js::Native native,
    1:                   uintN nargs, uintN flags);
    1: 
    1: /*
    1:  * Flags for js_ValueToFunction and js_ReportIsNotFunction.  We depend on the
    1:  * fact that JSINVOKE_CONSTRUCT (aka JSFRAME_CONSTRUCTING) is 1, and test that
    1:  * with #if/#error in jsfun.c.
    1:  */
    1: #define JSV2F_CONSTRUCT         JSINVOKE_CONSTRUCT
    1: #define JSV2F_SEARCH_STACK      0x10000
    1: 
    1: extern JSFunction *
48470: js_ValueToFunction(JSContext *cx, const js::Value *vp, uintN flags);
    1: 
    1: extern JSObject *
48470: js_ValueToFunctionObject(JSContext *cx, js::Value *vp, uintN flags);
    1: 
    1: extern JSObject *
48470: js_ValueToCallableObject(JSContext *cx, js::Value *vp, uintN flags);
    1: 
    1: extern void
48470: js_ReportIsNotFunction(JSContext *cx, const js::Value *vp, uintN flags);
    1: 
    1: extern JSObject *
62855: js_GetCallObject(JSContext *cx, JSStackFrame *fp, Origins origin);
    1: 
37694: extern JSObject * JS_FASTCALL
37694: js_CreateCallObjectOnTrace(JSContext *cx, JSFunction *fun, JSObject *callee, JSObject *scopeChain);
37694: 
31823: extern void
    1: js_PutCallObject(JSContext *cx, JSStackFrame *fp);
    1: 
37694: extern JSBool JS_FASTCALL
48470: js_PutCallObjectOnTrace(JSContext *cx, JSObject *scopeChain, uint32 nargs,
48470:                         js::Value *argv, uint32 nvars, js::Value *slots);
37694: 
58293: namespace js {
    1: 
29888: extern JSBool
58293: GetCallArg(JSContext *cx, JSObject *obj, jsid id, js::Value *vp);
58293: 
58293: extern JSBool
58293: GetCallVar(JSContext *cx, JSObject *obj, jsid id, js::Value *vp);
58293: 
58293: /*
58293:  * Slower version of js_GetCallVar used when call_resolve detects an attempt to
58293:  * leak an optimized closure via indirect or debugger eval.
58293:  */
58293: extern JSBool
58293: GetCallVarChecked(JSContext *cx, JSObject *obj, jsid id, js::Value *vp);
30848: 
30848: extern JSBool
60254: GetCallUpvar(JSContext *cx, JSObject *obj, jsid id, js::Value *vp);
59968: 
59968: extern JSBool
62395: SetCallArg(JSContext *cx, JSObject *obj, jsid id, JSBool strict, js::Value *vp);
30848: 
30848: extern JSBool
62395: SetCallVar(JSContext *cx, JSObject *obj, jsid id, JSBool strict, js::Value *vp);
    1: 
59968: extern JSBool
62395: SetCallUpvar(JSContext *cx, JSObject *obj, jsid id, JSBool strict, js::Value *vp);
59968: 
58293: } // namespace js
29009: 
    1: extern JSBool
48470: js_GetArgsValue(JSContext *cx, JSStackFrame *fp, js::Value *vp);
    1: 
    1: extern JSBool
48470: js_GetArgsProperty(JSContext *cx, JSStackFrame *fp, jsid id, js::Value *vp);
    1: 
51097: /*
51097:  * Get the arguments object for the given frame.  If the frame is strict mode
51097:  * code, its current arguments will be copied into the arguments object.
51097:  *
51097:  * NB: Callers *must* get the arguments object before any parameters are
51097:  *     mutated when the frame is strict mode code!  The emitter ensures this
51097:  *     occurs for strict mode functions containing syntax which might mutate a
51097:  *     named parameter by synthesizing an arguments access at the start of the
51097:  *     function.
51097:  */
    1: extern JSObject *
    1: js_GetArgsObject(JSContext *cx, JSStackFrame *fp);
    1: 
31823: extern void
    1: js_PutArgsObject(JSContext *cx, JSStackFrame *fp);
    1: 
37694: inline bool
37694: js_IsNamedLambda(JSFunction *fun) { return (fun->flags & JSFUN_LAMBDA) && fun->atom; }
37694: 
33113: /*
40405:  * Maximum supported value of arguments.length. It bounds the maximum number of
40405:  * arguments that can be supplied via the second (so-called |argArray|) param
40405:  * to Function.prototype.apply. This value also bounds the number of elements
40405:  * parsed in an array initialiser.
42714:  *
42714:  * The thread's stack is the limiting factor for this number. It is currently
42714:  * 2MB, which fits a little less than 2^19 arguments (once the stack frame,
42714:  * callstack, etc. are included). Pick a max args length that is a little less.
40405:  */
42714: const uint32 JS_ARGS_LENGTH_MAX = JS_BIT(19) - 1024;
33113: 
33113: /*
51095:  * JSSLOT_ARGS_LENGTH stores ((argc << 1) | overwritten_flag) as an Int32
51095:  * Value.  Thus (JS_ARGS_LENGTH_MAX << 1) | 1 must be less than JSVAL_INT_MAX.
33113:  */
33113: JS_STATIC_ASSERT(JS_ARGS_LENGTH_MAX <= JS_BIT(30));
48470: JS_STATIC_ASSERT(((JS_ARGS_LENGTH_MAX << 1) | 1) <= JSVAL_INT_MAX);
33113: 
    1: extern JSBool
28093: js_XDRFunctionObject(JSXDRState *xdr, JSObject **objp);
    1: 
29887: extern JSBool
48470: js_fun_apply(JSContext *cx, uintN argc, js::Value *vp);
21462: 
29887: extern JSBool
48470: js_fun_call(JSContext *cx, uintN argc, js::Value *vp);
21462: 
    1: #endif /* jsfun_h___ */
