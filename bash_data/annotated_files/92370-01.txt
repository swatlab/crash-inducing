    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef _nsAccessible_H_
    1: #define _nsAccessible_H_
    1: 
87094: #include "mozilla/a11y/Role.h"
87094: #include "mozilla/a11y/States.h"
    1: #include "nsAccessNodeWrap.h"
 1628: 
    1: #include "nsIAccessible.h"
    1: #include "nsIAccessibleHyperLink.h"
    1: #include "nsIAccessibleSelectable.h"
    1: #include "nsIAccessibleValue.h"
 1628: #include "nsIAccessibleRole.h"
 1628: #include "nsIAccessibleStates.h"
 1628: 
58433: #include "nsARIAMap.h"
41384: #include "nsStringGlue.h"
23904: #include "nsTArray.h"
43888: #include "nsRefPtrHashtable.h"
41384: 
61638: class AccEvent;
47172: class AccGroupInfo;
50622: class EmbeddedObjCollector;
74014: class KeyBinding;
61638: class nsAccessible;
61467: class nsHyperTextAccessible;
86933: class nsHTMLImageAccessible;
64006: class nsHTMLLIAccessible;
41384: struct nsRoleMapEntry;
75194: class Relation;
61638: class nsTextAccessible;
    1: 
    1: struct nsRect;
    1: class nsIContent;
    1: class nsIFrame;
    1: class nsIAtom;
    1: class nsIView;
    1: 
41384: typedef nsRefPtrHashtable<nsVoidPtrHashKey, nsAccessible>
41384:   nsAccessibleHashtable;
41384: 
22844: // see nsAccessible::GetAttrValue
 4274: #define NS_OK_NO_ARIA_VALUE \
 4274: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x21)
 4274: 
22844: // see nsAccessible::GetNameInternal
22844: #define NS_OK_EMPTY_NAME \
22844: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x23)
22844: 
25591: // see nsAccessible::GetNameInternal
25591: #define NS_OK_NAME_FROM_TOOLTIP \
25591: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x25)
25591: 
    1: 
41384: #define NS_ACCESSIBLE_IMPL_IID                          \
37299: {  /* 133c8bf4-4913-4355-bd50-426bd1d6e1ad */           \
37299:   0x133c8bf4,                                           \
37299:   0x4913,                                               \
37299:   0x4355,                                               \
37299:   { 0xbd, 0x50, 0x42, 0x6b, 0xd1, 0xd6, 0xe1, 0xad }    \
20246: }
20246: 
    1: class nsAccessible : public nsAccessNodeWrap, 
    1:                      public nsIAccessible, 
    1:                      public nsIAccessibleHyperLink,
    1:                      public nsIAccessibleSelectable,
    1:                      public nsIAccessibleValue
    1: {
    1: public:
89799:   nsAccessible(nsIContent* aContent, nsDocAccessible* aDoc);
    1:   virtual ~nsAccessible();
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
16428:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsAccessible, nsAccessNode)
16428: 
    1:   NS_DECL_NSIACCESSIBLE
    1:   NS_DECL_NSIACCESSIBLEHYPERLINK
    1:   NS_DECL_NSIACCESSIBLESELECTABLE
    1:   NS_DECL_NSIACCESSIBLEVALUE
41384:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ACCESSIBLE_IMPL_IID)
    1: 
21169:   //////////////////////////////////////////////////////////////////////////////
21169:   // nsAccessNode
21169: 
43538:   virtual void Shutdown();
    1: 
20246:   //////////////////////////////////////////////////////////////////////////////
20246:   // Public methods
20246: 
20246:   /**
69342:    * get the description of this accessible
69342:    */
69342:   virtual void Description(nsString& aDescription);
69342: 
69342:   /**
89598:    * Return DOM node associated with this accessible.
89598:    */
89598:   inline already_AddRefed<nsIDOMNode> DOMNode() const
89598:   {
89598:     nsIDOMNode *DOMNode = nsnull;
89598:     if (GetNode())
89598:       CallQueryInterface(GetNode(), &DOMNode);
89598:     return DOMNode;
89598:   }
89598: 
89598:   /**
20246:    * Returns the accessible name specified by ARIA.
20246:    */
20246:   nsresult GetARIAName(nsAString& aName);
20246: 
20246:   /**
29320:    * Maps ARIA state attributes to state of accessible. Note the given state
29320:    * argument should hold states for accessible before you pass it into this
29320:    * method.
29320:    *
29320:    * @param  [in/out] where to fill the states into.
29320:    */
67790:   virtual void ApplyARIAState(PRUint64* aState);
29320: 
29320:   /**
20246:    * Returns the accessible name provided by native markup. It doesn't take
22844:    * into account ARIA markup used to specify the name.
22844:    *
22844:    * @param  aName             [out] the accessible name
22844:    *
22844:    * @return NS_OK_EMPTY_NAME  points empty name was specified by native markup
22844:    *                           explicitly (see nsIAccessible::name attribute for
22844:    *                           details)
20246:    */
20246:   virtual nsresult GetNameInternal(nsAString& aName);
20246: 
  262:   /**
87094:    * Return enumerated accessible role (see constants in Role.h).
52053:    */
87094:   inline mozilla::a11y::role Role()
58433:   {
58433:     if (!mRoleMapEntry || mRoleMapEntry->roleRule != kUseMapRole)
58433:       return NativeRole();
58433: 
58433:     return ARIARoleInternal();
58433:   }
58433: 
58433:   /**
87821:    * Return true if ARIA role is specified on the element.
87821:    */
87821:   inline bool HasARIARole() const
87821:   {
87821:     return mRoleMapEntry;
87821:   }
87821: 
87821:   /**
58433:    * Return accessible role specified by ARIA (see constants in
87094:    * roles).
58433:    */
87094:   inline mozilla::a11y::role ARIARole()
58433:   {
58433:     if (!mRoleMapEntry || mRoleMapEntry->roleRule != kUseMapRole)
87094:       return mozilla::a11y::roles::NOTHING;
58433: 
58433:     return ARIARoleInternal();
58433:   }
52053: 
52053:   /**
25822:    * Returns enumerated accessible role from native markup (see constants in
87094:    * Role.h). Doesn't take into account ARIA roles.
25822:    */
87094:   virtual mozilla::a11y::role NativeRole();
25822: 
25822:   /**
67790:    * Return all states of accessible (including ARIA states).
  262:    */
67790:   virtual PRUint64 State();
67790: 
67790:   /**
67790:    * Return the states of accessible, not taking into account ARIA states.
67790:    * Use State() to get complete set of states.
67790:    */
67790:   virtual PRUint64 NativeState();
  262: 
  262:   /**
91761:    * Return bit set of invisible and offscreen states.
91761:    */
91761:   PRUint64 VisibilityState();
91761: 
91761:   /**
  401:    * Returns attributes for accessible without explicitly setted ARIA
  401:    * attributes.
  401:    */
  401:   virtual nsresult GetAttributesInternal(nsIPersistentProperties *aAttributes);
  401: 
28197:   /**
72477:    * Used by ChildAtPoint() method to get direct or deepest child at point.
64131:    */
64131:   enum EWhichChildAtPoint {
64131:     eDirectChild,
64131:     eDeepestChild
64131:   };
64131: 
64131:   /**
28197:    * Return direct or deepest child at the given point.
28197:    *
28197:    * @param  aX           [in] x coordinate relative screen
28197:    * @param  aY           [in] y coordinate relative screen
64131:    * @param  aWhichChild  [in] flag points if deepest or direct child
64131:    *                        should be returned
28197:    */
72477:   virtual nsAccessible* ChildAtPoint(PRInt32 aX, PRInt32 aY,
64131:                                      EWhichChildAtPoint aWhichChild);
28197: 
36879:   /**
74619:    * Return the focused child if any.
74619:    */
74619:   virtual nsAccessible* FocusedChild();
74619: 
74619:   /**
36879:    * Return calculated group level based on accessible hierarchy.
36879:    */
36879:   virtual PRInt32 GetLevelInternal();
36879: 
36879:   /**
36879:    * Calculate position in group and group size ('posinset' and 'setsize') based
36879:    * on accessible hierarchy.
36879:    *
36879:    * @param  aPosInSet  [out] accessible position in the group
36879:    * @param  aSetSize   [out] the group size
36879:    */
36879:   virtual void GetPositionAndSizeInternal(PRInt32 *aPosInSet,
36879:                                           PRInt32 *aSetSize);
36879: 
75194:   /**
75194:    * Get the relation of the given type.
75194:    */
75194:   virtual Relation RelationByType(PRUint32 aType);
75194: 
20246:   //////////////////////////////////////////////////////////////////////////////
35523:   // Initializing methods
29320: 
29320:   /**
29320:    * Set the ARIA role map entry for a new accessible.
29320:    * For a newly created accessible, specify which role map entry should be used.
29320:    *
29320:    * @param aRoleMapEntry The ARIA nsRoleMapEntry* for the accessible, or 
29320:    *                      nsnull if none.
29320:    */
29320:   virtual void SetRoleMapEntry(nsRoleMapEntry *aRoleMapEntry);
29320: 
29320:   /**
61359:    * Update the children cache.
61359:    */
61359:   inline bool UpdateChildren()
61359:   {
61359:     InvalidateChildren();
61359:     return EnsureChildren();
61359:   }
61359: 
61359:   /**
40575:    * Cache children if necessary. Return true if the accessible is defunct.
40575:    */
61463:   bool EnsureChildren();
40575: 
40575:   /**
35523:    * Set the child count to -1 (unknown) and null out cached child pointers.
35523:    * Should be called when accessible tree is changed because document has
47105:    * transformed. Note, if accessible cares about its parent relation chain
47105:    * itself should override this method to do nothing.
29320:    */
29320:   virtual void InvalidateChildren();
29320: 
43310:   /**
47105:    * Append/insert/remove a child. Return true if operation was successful.
43310:    */
79445:   virtual bool AppendChild(nsAccessible* aChild);
79445:   virtual bool InsertChildAt(PRUint32 aIndex, nsAccessible* aChild);
79445:   virtual bool RemoveChild(nsAccessible* aChild);
43310: 
35523:   //////////////////////////////////////////////////////////////////////////////
35523:   // Accessible tree traverse methods
35523: 
35523:   /**
35523:    * Return parent accessible.
35523:    */
74545:   nsAccessible* Parent() const { return mParent; }
35523: 
35523:   /**
35523:    * Return child accessible at the given index.
35523:    */
36989:   virtual nsAccessible* GetChildAt(PRUint32 aIndex);
35523: 
35523:   /**
35523:    * Return child accessible count.
35523:    */
35523:   virtual PRInt32 GetChildCount();
35523: 
35523:   /**
35523:    * Return index of the given child accessible.
35523:    */
47105:   virtual PRInt32 GetIndexOf(nsAccessible* aChild);
35523: 
35523:   /**
35523:    * Return index in parent accessible.
35523:    */
72476:   virtual PRInt32 IndexInParent() const;
35523: 
29320:   /**
42530:    * Return true if accessible has children;
42530:    */
79445:   bool HasChildren() { return !!GetChildAt(0); }
42530: 
42530:   /**
74545:    * Return first/last/next/previous sibling of the accessible.
71380:    */
71380:   inline nsAccessible* NextSibling() const
71380:     {  return GetSiblingAtOffset(1); }
71380:   inline nsAccessible* PrevSibling() const
71380:     { return GetSiblingAtOffset(-1); }
74545:   inline nsAccessible* FirstChild()
74545:     { return GetChildCount() != 0 ? GetChildAt(0) : nsnull; }
74545:   inline nsAccessible* LastChild()
74545:   {
74545:     PRUint32 childCount = GetChildCount();
74545:     return childCount != 0 ? GetChildAt(childCount - 1) : nsnull;
74545:   }
74545: 
71380: 
71380:   /**
50622:    * Return embedded accessible children count.
50622:    */
50622:   PRInt32 GetEmbeddedChildCount();
50622: 
50622:   /**
50622:    * Return embedded accessible child at the given index.
50622:    */
50622:   nsAccessible* GetEmbeddedChildAt(PRUint32 aIndex);
50622: 
50622:   /**
50622:    * Return index of the given embedded accessible child.
50622:    */
50622:   PRInt32 GetIndexOfEmbeddedChild(nsAccessible* aChild);
50622: 
71381:   /**
71381:    * Return number of content children/content child at index. The content
71381:    * child is created from markup in contrast to it's never constructed by its
71381:    * parent accessible (like treeitem accessibles for XUL trees).
71381:    */
71381:   PRUint32 ContentChildCount() const { return mChildren.Length(); }
71381:   nsAccessible* ContentChildAt(PRUint32 aIndex) const
71381:     { return mChildren.ElementAt(aIndex); }
71381: 
71381:   /**
71381:    * Return true if children were initialized.
71381:    */
61466:   inline bool AreChildrenCached() const
61466:     { return !IsChildrenFlag(eChildrenUninitialized); }
71381: 
71381:   /**
71381:    * Return true if the accessible is attached to tree.
71381:    */
61463:   bool IsBoundToParent() const { return !!mParent; }
29320: 
29320:   //////////////////////////////////////////////////////////////////////////////
35523:   // Miscellaneous methods
29320: 
29320:   /**
37299:    * Handle accessible event, i.e. process it, notifies observers and fires
37299:    * platform specific event.
29320:    */
51377:   virtual nsresult HandleAccEvent(AccEvent* aAccEvent);
29320: 
29320:   /**
89679:    * Return true if this accessible allows accessible children from anonymous subtree.
29320:    */
89679:   virtual bool CanHaveAnonChildren();
29320: 
29320:   /**
29320:    * Returns text of accessible if accessible has text role otherwise empty
29320:    * string.
29320:    *
61682:    * @param aText         [in] returned text of the accessible
61682:    * @param aStartOffset  [in, optional] start offset inside of the accessible,
61682:    *                        if missed entire text is appended
61682:    * @param aLength       [in, optional] required length of text, if missed
61682:    *                        then text form start offset till the end is appended
29320:    */
61682:   virtual void AppendTextTo(nsAString& aText, PRUint32 aStartOffset = 0,
61682:                             PRUint32 aLength = PR_UINT32_MAX);
29320: 
38000:   /**
39144:    * Assert if child not in parent's cache if the cache was initialized at this
39144:    * point.
38000:    */
61461:   void TestChildCache(nsAccessible* aCachedChild) const;
38000: 
51810:   //////////////////////////////////////////////////////////////////////////////
79384:   // Downcasting and types
61467: 
82721:   inline bool IsAbbreviation() const
82721:   {
82721:     return mContent->IsHTML() &&
82721:       (mContent->Tag() == nsGkAtoms::abbr || mContent->Tag() == nsGkAtoms::acronym);
82721:   }
82721: 
62919:   inline bool IsApplication() const { return mFlags & eApplicationAccessible; }
62919: 
79384:   bool IsAutoComplete() const { return mFlags & eAutoCompleteAccessible; }
79384: 
79384:   inline bool IsAutoCompletePopup() const { return mFlags & eAutoCompletePopupAccessible; }
79384: 
79384:   inline bool IsCombobox() const { return mFlags & eComboboxAccessible; }
79384: 
70092:   inline bool IsDoc() const { return mFlags & eDocAccessible; }
70092:   nsDocAccessible* AsDoc();
70092: 
61467:   inline bool IsHyperText() const { return mFlags & eHyperTextAccessible; }
61467:   nsHyperTextAccessible* AsHyperText();
61467: 
83000:   inline bool IsHTMLFileInput() const { return mFlags & eHTMLFileInputAccessible; }
83000: 
64006:   inline bool IsHTMLListItem() const { return mFlags & eHTMLListItemAccessible; }
64006:   nsHTMLLIAccessible* AsHTMLListItem();
64006:   
86933:   inline bool IsImageAccessible() const { return mFlags & eImageAccessible; }
86933:   nsHTMLImageAccessible* AsImage();
86933: 
79384:   inline bool IsListControl() const { return mFlags & eListControlAccessible; }
79384: 
79384:   inline bool IsMenuButton() const { return mFlags & eMenuButtonAccessible; }
79384: 
79384:   inline bool IsMenuPopup() const { return mFlags & eMenuPopupAccessible; }
79384: 
63248:   inline bool IsRoot() const { return mFlags & eRootAccessible; }
63248:   nsRootAccessible* AsRoot();
63248: 
61638:   inline bool IsTextLeaf() const { return mFlags & eTextLeafAccessible; }
61638:   nsTextAccessible* AsTextLeaf();
61638: 
61467:   //////////////////////////////////////////////////////////////////////////////
74014:   // ActionAccessible
74014: 
74014:   /**
74781:    * Return the number of actions that can be performed on this accessible.
74781:    */
74781:   virtual PRUint8 ActionCount();
74781: 
74781:   /**
74014:    * Return access key, such as Alt+D.
74014:    */
74014:   virtual KeyBinding AccessKey() const;
74014: 
74014:   /**
74014:    * Return global keyboard shortcut for default action, such as Ctrl+O for
74014:    * Open file menuitem.
74014:    */
74014:   virtual KeyBinding KeyboardShortcut() const;
74014: 
74014:   //////////////////////////////////////////////////////////////////////////////
51810:   // HyperLinkAccessible
51810: 
51810:   /**
51810:    * Return true if the accessible is hyper link accessible.
51810:    */
72484:   virtual bool IsLink();
51810: 
51810:   /**
51810:    * Return the start offset of the link within the parent accessible.
51810:    */
51810:   virtual PRUint32 StartOffset();
51810: 
51810:   /**
51810:    * Return the end offset of the link within the parent accessible.
51810:    */
51810:   virtual PRUint32 EndOffset();
51810: 
51810:   /**
51810:    * Return true if the link is valid (e. g. points to a valid URL).
51810:    */
72481:   inline bool IsLinkValid()
72481:   {
72484:     NS_PRECONDITION(IsLink(), "IsLinkValid is called on not hyper link!");
72481: 
72481:     // XXX In order to implement this we would need to follow every link
72481:     // Perhaps we can get information about invalid links from the cache
72481:     // In the mean time authors can use role="link" aria-invalid="true"
72481:     // to force it for links they internally know to be invalid
74618:     return (0 == (State() & mozilla::a11y::states::INVALID));
72481:   }
51810: 
51810:   /**
51810:    * Return true if the link currently has the focus.
51810:    */
79384:   bool IsLinkSelected();
51810: 
51810:   /**
51810:    * Return the number of anchors within the link.
51810:    */
51810:   virtual PRUint32 AnchorCount();
51810: 
51810:   /**
51810:    * Returns an anchor accessible at the given index.
51810:    */
72483:   virtual nsAccessible* AnchorAt(PRUint32 aAnchorIndex);
51810: 
51810:   /**
51810:    * Returns an anchor URI at the given index.
51810:    */
72483:   virtual already_AddRefed<nsIURI> AnchorURIAt(PRUint32 aAnchorIndex);
51810: 
51865:   //////////////////////////////////////////////////////////////////////////////
51865:   // SelectAccessible
51865: 
51865:   /**
51865:    * Return true if the accessible is a select control containing selectable
51865:    * items.
51865:    */
51865:   virtual bool IsSelect();
51865: 
51865:   /**
51865:    * Return an array of selected items.
51865:    */
51865:   virtual already_AddRefed<nsIArray> SelectedItems();
51865: 
51865:   /**
51865:    * Return the number of selected items.
51865:    */
51865:   virtual PRUint32 SelectedItemCount();
51865: 
51865:   /**
51865:    * Return selected item at the given index.
51865:    */
51865:   virtual nsAccessible* GetSelectedItem(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Determine if item at the given index is selected.
51865:    */
51865:   virtual bool IsItemSelected(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Add item at the given index the selection. Return true if success.
51865:    */
51865:   virtual bool AddItemToSelection(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Remove item at the given index from the selection. Return if success.
51865:    */
51865:   virtual bool RemoveItemFromSelection(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Select all items. Return true if success.
51865:    */
51865:   virtual bool SelectAll();
51865: 
51865:   /**
51865:    * Unselect all items. Return true if success.
51865:    */
51865:   virtual bool UnselectAll();
51865: 
79384:   //////////////////////////////////////////////////////////////////////////////
79384:   // Widgets
79384: 
79384:   /**
79384:    * Return true if accessible is a widget, i.e. control or accessible that
79384:    * manages its items. Note, being a widget the accessible may be a part of
79384:    * composite widget.
79384:    */
79384:   virtual bool IsWidget() const;
79384: 
79384:   /**
79384:    * Return true if the widget is active, i.e. has a focus within it.
79384:    */
79384:   virtual bool IsActiveWidget() const;
79384: 
79384:   /**
79384:    * Return true if the widget has items and items are operable by user and
79384:    * can be activated.
79384:    */
79384:   virtual bool AreItemsOperable() const;
79384: 
79384:   /**
79384:    * Return the current item of the widget, i.e. an item that has or will have
79384:    * keyboard focus when widget gets active.
79384:    */
79384:   virtual nsAccessible* CurrentItem();
79384: 
79384:   /**
84259:    * Set the current item of the widget.
84259:    */
84259:   virtual void SetCurrentItem(nsAccessible* aItem);
84259: 
84259:   /**
79384:    * Return container widget this accessible belongs to.
79384:    */
79384:   virtual nsAccessible* ContainerWidget() const;
79384: 
88363:   /**
88363:    * Return the localized string for the given key.
88363:    */
88363:   static void TranslateString(const nsAString& aKey, nsAString& aStringOut);
88363: 
35523: protected:
35523: 
35136:   //////////////////////////////////////////////////////////////////////////////
35523:   // Initializing, cache and tree traverse methods
35136: 
35523:   /**
35523:    * Cache accessible children.
35523:    */
35523:   virtual void CacheChildren();
35136: 
35523:   /**
47105:    * Set accessible parent and index in parent.
47105:    */
57414:   virtual void BindToParent(nsAccessible* aParent, PRUint32 aIndexInParent);
92370:   virtual void UnbindFromParent();
47105: 
47105:   /**
35523:    * Return sibling accessible at the given offset.
35523:    */
39191:   virtual nsAccessible* GetSiblingAtOffset(PRInt32 aOffset,
71380:                                            nsresult *aError = nsnull) const;
35523: 
61466:   /**
61466:    * Flags used to describe the state and type of children.
61466:    */
61466:   enum ChildrenFlags {
61466:     eChildrenUninitialized = 0, // children aren't initialized
61466:     eMixedChildren = 1 << 0, // text leaf children are presented
61466:     eEmbeddedChildren = 1 << 1 // all children are embedded objects
61466:   };
61466: 
61466:   /**
61466:    * Return true if the children flag is set.
61466:    */
61466:   inline bool IsChildrenFlag(ChildrenFlags aFlag) const
71131:     { return static_cast<ChildrenFlags> (mFlags & kChildrenFlagsMask) == aFlag; }
61466: 
61466:   /**
61466:    * Set children flag.
61466:    */
61466:   inline void SetChildrenFlag(ChildrenFlags aFlag)
61466:     { mFlags = (mFlags & ~kChildrenFlagsMask) | aFlag; }
61466: 
61467:   /**
61467:    * Flags describing the accessible itself.
61467:    * @note keep these flags in sync with ChildrenFlags
61467:    */
61467:   enum AccessibleTypes {
62919:     eApplicationAccessible = 1 << 2,
79384:     eAutoCompleteAccessible = 1 << 3,
79384:     eAutoCompletePopupAccessible = 1 << 4,
79384:     eComboboxAccessible = 1 << 5,
79384:     eDocAccessible = 1 << 6,
79384:     eHyperTextAccessible = 1 << 7,
83000:     eHTMLFileInputAccessible = 1 << 8,
83000:     eHTMLListItemAccessible = 1 << 9,
86933:     eImageAccessible = 1 << 10,
86933:     eListControlAccessible = 1 << 11,
86933:     eMenuButtonAccessible = 1 << 12,
86933:     eMenuPopupAccessible = 1 << 13,
86933:     eRootAccessible = 1 << 14,
86933:     eTextLeafAccessible = 1 << 15
61467:   };
61467: 
35523:   //////////////////////////////////////////////////////////////////////////////
35523:   // Miscellaneous helpers
35523: 
58433:   /**
58433:    * Return ARIA role (helper method).
58433:    */
87094:   mozilla::a11y::role ARIARoleInternal();
58433: 
    1:   virtual nsIFrame* GetBoundsFrame();
    1:   virtual void GetBoundsRect(nsRect& aRect, nsIFrame** aRelativeFrame);
86931: 
22204:   //////////////////////////////////////////////////////////////////////////////
35523:   // Name helpers
22204: 
22204:   /**
22204:    * Compute the name of HTML node.
22204:    */
22204:   nsresult GetHTMLName(nsAString& aName);
22204: 
22204:   /**
22204:    * Compute the name for XUL node.
22204:    */
22204:   nsresult GetXULName(nsAString& aName);
22204: 
    1:   // helper method to verify frames
    1:   static nsresult GetFullKeyName(const nsAString& aModifierName, const nsAString& aKeyName, nsAString& aStringOut);
15971: 
    1:   /**
34455:    * Return an accessible for the given DOM node, or if that node isn't
34455:    * accessible, return the accessible for the next DOM node which has one
34455:    * (based on forward depth first search).
34455:    *
34455:    * @param  aStartNode  [in] the DOM node to start from
    1:    * @return              the resulting accessible
    1:    */
43504:   nsAccessible *GetFirstAvailableAccessible(nsINode *aStartNode) const;
    1: 
31673:   //////////////////////////////////////////////////////////////////////////////
31673:   // Action helpers
31673: 
31673:   /**
31673:    * Prepares click action that will be invoked in timeout.
31673:    *
31673:    * @note  DoCommand() prepares an action in timeout because when action
31673:    *  command opens a modal dialog/window, it won't return until the
31673:    *  dialog/window is closed. If executing action command directly in
31673:    *  nsIAccessible::DoAction() method, it will block AT tools (e.g. GOK) that
31673:    *  invoke action of mozilla accessibles direclty (see bug 277888 for details).
31673:    *
31673:    * @param  aContent      [in, optional] element to click
31673:    * @param  aActionIndex  [in, optional] index of accessible action
31673:    */
37481:   void DoCommand(nsIContent *aContent = nsnull, PRUint32 aActionIndex = 0);
31673: 
31673:   /**
31673:    * Dispatch click event.
31673:    */
31673:   virtual void DispatchClickEvent(nsIContent *aContent, PRUint32 aActionIndex);
31673: 
37480:   NS_DECL_RUNNABLEMETHOD_ARG2(nsAccessible, DispatchClickEvent,
37480:                               nsCOMPtr<nsIContent>, PRUint32)
37480: 
31673:   //////////////////////////////////////////////////////////////////////////////
31673:   // Helpers
    1: 
 4274:   /**
 8937:    *  Get the container node for an atomic region, defined by aria-atomic="true"
 6066:    *  @return the container node
 6066:    */
75194:   nsIContent* GetAtomicRegion() const;
 6066: 
 6066:   /**
 6279:    * Get numeric value of the given ARIA attribute.
 4274:    *
 6279:    * @param aAriaProperty - the ARIA property we're using
 4274:    * @param aValue - value of the attribute
 4274:    *
 4274:    * @return - NS_OK_NO_ARIA_VALUE if there is no setted ARIA attribute
 4274:    */
 8937:   nsresult GetAttrValue(nsIAtom *aAriaProperty, double *aValue);
 4274: 
15375:   /**
20140:    * Return the action rule based on ARIA enum constants EActionRule
74781:    * (see nsARIAMap.h). Used by ActionCount() and GetActionName().
20140:    *
20140:    * @param aStates  [in] states of the accessible
20140:    */
67790:   PRUint32 GetActionRule(PRUint64 aStates);
20140: 
20140:   /**
47172:    * Return group info.
47172:    */
47172:   AccGroupInfo* GetGroupInfo();
47172: 
47172:   /**
15375:    * Fires platform accessible event. It's notification method only. It does
37299:    * change nothing on Gecko side. Don't use it until you're sure what you do
37299:    * (see example in XUL tree accessible), use nsEventShell::FireEvent()
37299:    * instead. MUST be overridden in wrap classes.
15375:    *
15375:    * @param aEvent  the accessible event to fire.
15375:    */
51377:   virtual nsresult FirePlatformEvent(AccEvent* aEvent) = 0;
15375: 
    1:   // Data Members
36989:   nsRefPtr<nsAccessible> mParent;
36989:   nsTArray<nsRefPtr<nsAccessible> > mChildren;
47105:   PRInt32 mIndexInParent;
16428: 
61466:   static const PRUint32 kChildrenFlagsMask =
61466:     eChildrenUninitialized | eMixedChildren | eEmbeddedChildren;
61466: 
61466:   PRUint32 mFlags;
50622: 
50622:   nsAutoPtr<EmbeddedObjCollector> mEmbeddedObjCollector;
50622:   PRInt32 mIndexOfEmbeddedChild;
50622:   friend class EmbeddedObjCollector;
50622: 
47172:   nsAutoPtr<AccGroupInfo> mGroupInfo;
47172:   friend class AccGroupInfo;
47172: 
    1:   nsRoleMapEntry *mRoleMapEntry; // Non-null indicates author-supplied role; possibly state & value as well
    1: };
    1: 
20246: NS_DEFINE_STATIC_IID_ACCESSOR(nsAccessible,
41384:                               NS_ACCESSIBLE_IMPL_IID)
    1: 
74014: 
74014: /**
74014:  * Represent key binding associated with accessible (such as access key and
74014:  * global keyboard shortcuts).
74014:  */
74014: class KeyBinding
74014: {
74014: public:
74014:   /**
74014:    * Modifier mask values.
74014:    */
74014:   static const PRUint32 kShift = 1;
74014:   static const PRUint32 kControl = 2;
74014:   static const PRUint32 kAlt = 4;
74014:   static const PRUint32 kMeta = 8;
74014: 
74014:   KeyBinding() : mKey(0), mModifierMask(0) {}
74014:   KeyBinding(PRUint32 aKey, PRUint32 aModifierMask) :
74014:     mKey(aKey), mModifierMask(aModifierMask) {};
74014: 
74014:   inline bool IsEmpty() const { return !mKey; }
74014:   inline PRUint32 Key() const { return mKey; }
74014:   inline PRUint32 ModifierMask() const { return mModifierMask; }
74014: 
74014:   enum Format {
74014:     ePlatformFormat,
74014:     eAtkFormat
74014:   };
74014: 
74014:   /**
74014:    * Return formatted string for this key binding depending on the given format.
74014:    */
74014:   inline void ToString(nsAString& aValue,
74014:                        Format aFormat = ePlatformFormat) const
74014:   {
74014:     aValue.Truncate();
74014:     AppendToString(aValue, aFormat);
74014:   }
74014:   inline void AppendToString(nsAString& aValue,
74014:                              Format aFormat = ePlatformFormat) const
74014:   {
74014:     if (mKey) {
74014:       if (aFormat == ePlatformFormat)
74014:         ToPlatformFormat(aValue);
74014:       else
74014:         ToAtkFormat(aValue);
74014:     }
74014:   }
74014: 
74014: private:
74014:   void ToPlatformFormat(nsAString& aValue) const;
74014:   void ToAtkFormat(nsAString& aValue) const;
74014: 
74014:   PRUint32 mKey;
74014:   PRUint32 mModifierMask;
74014: };
74014: 
    1: #endif
