 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "inDOMUtils.h"
     1: #include "inLayoutUtils.h"
     1: 
     1: #include "nsIServiceManager.h"
     1: #include "nsString.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDocument.h"
 31312: #include "nsIPresShell.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMCharacterData.h"
     1: #include "nsRuleNode.h"
     1: #include "nsIStyleRule.h"
 63693: #include "mozilla/css/StyleRule.h"
     1: #include "nsICSSStyleRuleDOMWrapper.h"
 73870: #include "nsIDOMWindow.h"
 31312: #include "nsXBLBinding.h"
 31312: #include "nsXBLPrototypeBinding.h"
 31312: #include "nsIMutableArray.h"
 31312: #include "nsBindingManager.h"
 31312: #include "nsComputedDOMStyle.h"
 68780: #include "nsEventStateManager.h"
 69428: #include "nsIAtom.h"
 86939: #include "nsRange.h"
 74131: #include "mozilla/dom/Element.h"
100218: #include "nsCSSStyleSheet.h"
 74131: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////////
     1: 
     1: inDOMUtils::inDOMUtils()
     1: {
     1: }
     1: 
     1: inDOMUtils::~inDOMUtils()
     1: {
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(inDOMUtils, inIDOMUtils)
     1: 
     1: ///////////////////////////////////////////////////////////////////////////////
     1: // inIDOMUtils
     1: 
     1: NS_IMETHODIMP
     1: inDOMUtils::IsIgnorableWhitespace(nsIDOMCharacterData *aDataNode,
 79445:                                   bool *aReturn)
     1: {
     1:   NS_PRECONDITION(aReturn, "Must have an out parameter");
     1: 
 22837:   NS_ENSURE_ARG_POINTER(aDataNode);
 22837: 
 80486:   *aReturn = false;
     1: 
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aDataNode);
     1:   NS_ASSERTION(content, "Does not implement nsIContent!");
     1: 
     1:   if (!content->TextIsOnlyWhitespace()) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Okay.  We have only white space.  Let's check the white-space
     1:   // property now and make sure that this isn't preformatted text...
     1: 
 73870:   nsCOMPtr<nsIDOMWindow> win = inLayoutUtils::GetWindowFor(aDataNode);
     1:   if (!win) {
     1:     // Hmm.  Things are screwy if we have no window...
     1:     NS_ERROR("No window!");
     1:     return NS_OK;
     1:   }
     1: 
 36656:   nsIFrame* frame = content->GetPrimaryFrame();
     1:   if (frame) {
     1:     const nsStyleText* text = frame->GetStyleText();
 11894:     *aReturn = !text->WhiteSpaceIsSignificant();
     1:   }
     1:   else {
     1:     // empty inter-tag text node without frame, e.g., in between <table>\n<tr>
 80486:     *aReturn = true;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: inDOMUtils::GetParentForNode(nsIDOMNode* aNode,
 79445:                              bool aShowingAnonymousContent,
     1:                              nsIDOMNode** aParent)
     1: {
 22837:   NS_ENSURE_ARG_POINTER(aNode);
 22837: 
     1:   // First do the special cases -- document nodes and anonymous content
     1:   nsCOMPtr<nsIDOMDocument> doc(do_QueryInterface(aNode));
     1:   nsCOMPtr<nsIDOMNode> parent;
     1: 
     1:   if (doc) {
     1:     parent = inLayoutUtils::GetContainerFor(doc);
     1:   } else if (aShowingAnonymousContent) {
     1:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
     1:     if (content) {
     1:       nsIContent* bparent = nsnull;
     1:       nsRefPtr<nsBindingManager> bindingManager = inLayoutUtils::GetBindingManagerFor(aNode);
     1:       if (bindingManager) {
     1:         bparent = bindingManager->GetInsertionParent(content);
     1:       }
     1: 
     1:       parent = do_QueryInterface(bparent);
     1:     }
     1:   }
     1: 
     1:   if (!parent) {
     1:     // Ok, just get the normal DOM parent node
     1:     aNode->GetParentNode(getter_AddRefs(parent));
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aParent = parent);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 71074: inDOMUtils::GetChildrenForNode(nsIDOMNode* aNode,
 79445:                                bool aShowingAnonymousContent,
 71074:                                nsIDOMNodeList** aChildren)
 71074: {
 71074:   NS_ENSURE_ARG_POINTER(aNode);
 71074:   NS_PRECONDITION(aChildren, "Must have an out parameter");
 71074: 
 71074:   nsCOMPtr<nsIDOMNodeList> kids;
 71074: 
 71074:   if (aShowingAnonymousContent) {
 71074:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 71074:     if (content) {
 71074:       nsRefPtr<nsBindingManager> bindingManager =
 71074:         inLayoutUtils::GetBindingManagerFor(aNode);
 71074:       if (bindingManager) {
 71074:         bindingManager->GetAnonymousNodesFor(content, getter_AddRefs(kids));
 71074:         if (!kids) {
 71074:           bindingManager->GetContentListFor(content, getter_AddRefs(kids));
 71074:         }
 71074:       }
 71074:     }
 71074:   }
 71074: 
 71074:   if (!kids) {
 71074:     aNode->GetChildNodes(getter_AddRefs(kids));
 71074:   }
 71074: 
 71074:   kids.forget(aChildren);
 71074:   return NS_OK;
 71074: }
 71074: 
 71074: NS_IMETHODIMP
     1: inDOMUtils::GetCSSStyleRules(nsIDOMElement *aElement,
 69428:                              const nsAString& aPseudo,
     1:                              nsISupportsArray **_retval)
     1: {
 22837:   NS_ENSURE_ARG_POINTER(aElement);
     1: 
     1:   *_retval = nsnull;
     1: 
 69428:   nsCOMPtr<nsIAtom> pseudoElt;
 69428:   if (!aPseudo.IsEmpty()) {
 69428:     pseudoElt = do_GetAtom(aPseudo);
 69428:   }
 69428: 
     1:   nsRuleNode* ruleNode = nsnull;
     1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
100311:   NS_ENSURE_STATE(content);
 35230:   nsRefPtr<nsStyleContext> styleContext;
 69428:   GetRuleNodeForContent(content, pseudoElt, getter_AddRefs(styleContext), &ruleNode);
     1:   if (!ruleNode) {
     1:     // This can fail for content nodes that are not in the document or
     1:     // if the document they're in doesn't have a presshell.  Bail out.
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsISupportsArray> rules;
     1:   NS_NewISupportsArray(getter_AddRefs(rules));
     1:   if (!rules) return NS_ERROR_OUT_OF_MEMORY;
     1: 
 63693:   nsRefPtr<mozilla::css::StyleRule> cssRule;
 31313:   for ( ; !ruleNode->IsRoot(); ruleNode = ruleNode->GetParent()) {
 63693:     cssRule = do_QueryObject(ruleNode->GetRule());
     1:     if (cssRule) {
 69443:       nsCOMPtr<nsIDOMCSSRule> domRule = cssRule->GetDOMRule();
     1:       if (domRule)
     1:         rules->InsertElementAt(domRule, 0);
     1:     }
     1:   }
     1: 
     1:   *_retval = rules;
     1:   NS_ADDREF(*_retval);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: inDOMUtils::GetRuleLine(nsIDOMCSSStyleRule *aRule, PRUint32 *_retval)
     1: {
     1:   *_retval = 0;
 22837: 
 22837:   NS_ENSURE_ARG_POINTER(aRule);
 22837: 
     1:   nsCOMPtr<nsICSSStyleRuleDOMWrapper> rule = do_QueryInterface(aRule);
 63693:   nsRefPtr<mozilla::css::StyleRule> cssrule;
 22837:   nsresult rv = rule->GetCSSStyleRule(getter_AddRefs(cssrule));
 22837:   NS_ENSURE_SUCCESS(rv, rv);
 22837:   NS_ENSURE_TRUE(cssrule != nsnull, NS_ERROR_FAILURE);
     1:   *_retval = cssrule->GetLineNumber();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 81474: inDOMUtils::IsInheritedProperty(const nsAString &aPropertyName, bool *_retval)
 81474: {
 81474:   nsCSSProperty prop = nsCSSProps::LookupProperty(aPropertyName);
 81474:   if (prop == eCSSProperty_UNKNOWN) {
 81474:     *_retval = false;
 81474:     return NS_OK;
 81474:   }
 81474: 
 81474:   if (nsCSSProps::IsShorthand(prop)) {
 81474:     prop = nsCSSProps::SubpropertyEntryFor(prop)[0];
 81474:   }
 81474: 
 81474:   nsStyleStructID sid = nsCSSProps::kSIDTable[prop];
 81474:   *_retval = !nsCachedStyleData::IsReset(sid);
 81474:   return NS_OK;
 81474: }
 81474: 
 81474: NS_IMETHODIMP
     1: inDOMUtils::GetBindingURLs(nsIDOMElement *aElement, nsIArray **_retval)
     1: {
 22837:   NS_ENSURE_ARG_POINTER(aElement);
 31312: 
 31312:   *_retval = nsnull;
 31312: 
 31312:   nsCOMPtr<nsIMutableArray> urls = do_CreateInstance(NS_ARRAY_CONTRACTID);
 31312:   if (!urls)
 31312:     return NS_ERROR_FAILURE;
 31312: 
 31312:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
 31312:   NS_ASSERTION(content, "elements must implement nsIContent");
 31312: 
 80526:   nsIDocument *ownerDoc = content->OwnerDoc();
 31312:   nsXBLBinding *binding = ownerDoc->BindingManager()->GetBinding(content);
 31312: 
 31312:   while (binding) {
 80486:     urls->AppendElement(binding->PrototypeBinding()->BindingURI(), false);
 31312:     binding = binding->GetBaseBinding();
 31312:   }
 31312: 
 31312:   NS_ADDREF(*_retval = urls);
 31312:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 56168: inDOMUtils::SetContentState(nsIDOMElement *aElement, nsEventStates::InternalType aState)
     1: {
 22837:   NS_ENSURE_ARG_POINTER(aElement);
     1: 
 68780:   nsRefPtr<nsEventStateManager> esm = inLayoutUtils::GetEventStateManagerFor(aElement);
     1:   if (esm) {
     1:     nsCOMPtr<nsIContent> content;
     1:     content = do_QueryInterface(aElement);
     1: 
 56168:     return esm->SetContentState(content, nsEventStates(aState));
     1:   }
     1: 
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
 56168: inDOMUtils::GetContentState(nsIDOMElement *aElement, nsEventStates::InternalType* aState)
     1: {
     1:   *aState = 0;
 71115:   nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
 71115:   NS_ENSURE_ARG_POINTER(content);
     1: 
 56168:   // NOTE: if this method is removed,
 56168:   // please remove GetInternalValue from nsEventStates
 71115:   *aState = content->AsElement()->State().GetInternalValue();
 42950:   return NS_OK;
     1: }
     1: 
 31312: /* static */ nsresult
 35230: inDOMUtils::GetRuleNodeForContent(nsIContent* aContent,
 69428:                                   nsIAtom* aPseudo,
 35230:                                   nsStyleContext** aStyleContext,
 35230:                                   nsRuleNode** aRuleNode)
 31312: {
 31312:   *aRuleNode = nsnull;
 35230:   *aStyleContext = nsnull;
 31312: 
 41643:   if (!aContent->IsElement()) {
 41643:     return NS_ERROR_UNEXPECTED;
 41643:   }
 41643: 
 31312:   nsIDocument* doc = aContent->GetDocument();
 31312:   NS_ENSURE_TRUE(doc, NS_ERROR_UNEXPECTED);
 31312: 
 46225:   nsIPresShell *presShell = doc->GetShell();
 31312:   NS_ENSURE_TRUE(presShell, NS_ERROR_UNEXPECTED);
 31312: 
 36787:   nsPresContext *presContext = presShell->GetPresContext();
 36787:   NS_ENSURE_TRUE(presContext, NS_ERROR_UNEXPECTED);
 36787: 
 79445:   bool safe = presContext->EnsureSafeToHandOutCSSRules();
 36787:   NS_ENSURE_TRUE(safe, NS_ERROR_OUT_OF_MEMORY);
 36787: 
 31312:   nsRefPtr<nsStyleContext> sContext =
 69428:     nsComputedDOMStyle::GetStyleContextForElement(aContent->AsElement(), aPseudo, presShell);
 69428:   if (sContext) {
 31312:     *aRuleNode = sContext->GetRuleNode();
 35230:     sContext.forget(aStyleContext);
 69428:   }
 31312:   return NS_OK;
 31312: }
 71908: 
 71908: NS_IMETHODIMP
 71908: inDOMUtils::GetUsedFontFaces(nsIDOMRange* aRange,
 71908:                              nsIDOMFontFaceList** aFontFaceList)
 71908: {
 86939:   return static_cast<nsRange*>(aRange)->GetUsedFontFaces(aFontFaceList);
 71908: }
 89714: 
 89714: static nsEventStates
 89714: GetStatesForPseudoClass(const nsAString& aStatePseudo)
 89714: {
 89714:   // An array of the states that are relevant for various pseudoclasses.
 89714:   // XXXbz this duplicates code in nsCSSRuleProcessor
 89714:   static const nsEventStates sPseudoClassStates[] = {
 89714: #define CSS_PSEUDO_CLASS(_name, _value) \
 89714:     nsEventStates(),
 89714: #define CSS_STATE_PSEUDO_CLASS(_name, _value, _states) \
 89714:     _states,
 89714: #include "nsCSSPseudoClassList.h"
 89714: #undef CSS_STATE_PSEUDO_CLASS
 89714: #undef CSS_PSEUDO_CLASS
 89714: 
 89714:     // Add more entries for our fake values to make sure we can't
 89714:     // index out of bounds into this array no matter what.
 89714:     nsEventStates(),
 89714:     nsEventStates()
 89714:   };
 94621:   MOZ_STATIC_ASSERT(NS_ARRAY_LENGTH(sPseudoClassStates) ==
 94621:                     nsCSSPseudoClasses::ePseudoClass_NotPseudoClass + 1,
 94621:                     "Length of PseudoClassStates array is incorrect");
 89714: 
 89714:   nsCOMPtr<nsIAtom> atom = do_GetAtom(aStatePseudo);
 89714: 
 89714:   // Ignore :moz-any-link so we don't give the element simultaneous
 89714:   // visited and unvisited style state
 89714:   if (nsCSSPseudoClasses::GetPseudoType(atom) ==
 89714:       nsCSSPseudoClasses::ePseudoClass_mozAnyLink) {
 89714:     return nsEventStates();
 89714:   }
 89714:   // Our array above is long enough that indexing into it with
 89714:   // NotPseudoClass is ok.
 89714:   return sPseudoClassStates[nsCSSPseudoClasses::GetPseudoType(atom)];
 89714: }
 89714: 
 89714: NS_IMETHODIMP
 89714: inDOMUtils::AddPseudoClassLock(nsIDOMElement *aElement,
 89714:                                const nsAString &aPseudoClass)
 89714: {
 89714:   nsEventStates state = GetStatesForPseudoClass(aPseudoClass);
 89714:   if (state.IsEmpty()) {
 89714:     return NS_OK;
 89714:   }
 89714: 
 89714:   nsCOMPtr<mozilla::dom::Element> element = do_QueryInterface(aElement);
 98128:   NS_ENSURE_ARG_POINTER(element);
 98128: 
 89714:   element->LockStyleStates(state);
 89714: 
 89714:   return NS_OK;
 89714: }
 89714: 
 89714: NS_IMETHODIMP
 89714: inDOMUtils::RemovePseudoClassLock(nsIDOMElement *aElement,
 89714:                                   const nsAString &aPseudoClass)
 89714: {
 89714:   nsEventStates state = GetStatesForPseudoClass(aPseudoClass);
 89714:   if (state.IsEmpty()) {
 89714:     return NS_OK;
 89714:   }
 89714: 
 89714:   nsCOMPtr<mozilla::dom::Element> element = do_QueryInterface(aElement);
 98128:   NS_ENSURE_ARG_POINTER(element);
 98128: 
 89714:   element->UnlockStyleStates(state);
 89714: 
 89714:   return NS_OK;
 89714: }
 89714: 
 89714: NS_IMETHODIMP
 89714: inDOMUtils::HasPseudoClassLock(nsIDOMElement *aElement,
 89714:                                const nsAString &aPseudoClass,
 89714:                                bool *_retval)
 89714: {
 89714:   nsEventStates state = GetStatesForPseudoClass(aPseudoClass);
 89714:   if (state.IsEmpty()) {
 89714:     *_retval = false;
 89714:     return NS_OK;
 89714:   }
 89714: 
 89714:   nsCOMPtr<mozilla::dom::Element> element = do_QueryInterface(aElement);
 98128:   NS_ENSURE_ARG_POINTER(element);
 98128: 
 89714:   nsEventStates locks = element->LockedStyleStates();
 89714: 
 89714:   *_retval = locks.HasAllStates(state);
 89714:   return NS_OK;
 89714: }
 89714: 
 89714: NS_IMETHODIMP
 89714: inDOMUtils::ClearPseudoClassLocks(nsIDOMElement *aElement)
 89714: {
 98128:   nsCOMPtr<mozilla::dom::Element> element = do_QueryInterface(aElement);
 98128:   NS_ENSURE_ARG_POINTER(element);
 89714: 
 89714:   element->ClearStyleStateLocks();
 89714: 
 89714:   return NS_OK;
 89714: }
100218: 
100218: NS_IMETHODIMP
100218: inDOMUtils::ParseStyleSheet(nsIDOMCSSStyleSheet *aSheet,
100218:                             const nsAString& aInput)
100218: {
100218:   nsRefPtr<nsCSSStyleSheet> sheet = do_QueryObject(aSheet);
100218:   NS_ENSURE_ARG_POINTER(sheet);
100218: 
100218:   return sheet->ParseSheet(aInput);
100218: }
