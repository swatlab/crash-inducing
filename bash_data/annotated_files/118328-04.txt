114869: // Copyright (c) 2010, Google Inc.
 36832: // All rights reserved.
 36832: //
 36832: // Redistribution and use in source and binary forms, with or without
 36832: // modification, are permitted provided that the following conditions are
 36832: // met:
 36832: //
 36832: //     * Redistributions of source code must retain the above copyright
 36832: // notice, this list of conditions and the following disclaimer.
 36832: //     * Redistributions in binary form must reproduce the above
 36832: // copyright notice, this list of conditions and the following disclaimer
 36832: // in the documentation and/or other materials provided with the
 36832: // distribution.
 36832: //     * Neither the name of Google Inc. nor the names of its
 36832: // contributors may be used to endorse or promote products derived from
 36832: // this software without specific prior written permission.
 36832: //
 36832: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 36832: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 36832: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 36832: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 36832: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 36832: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 36832: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 36832: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 36832: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 36832: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 36832: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 36832: 
 36832: // This code writes out minidump files:
 36832: //   http://msdn.microsoft.com/en-us/library/ms680378(VS.85,loband).aspx
 36832: //
 36832: // Minidumps are a Microsoft format which Breakpad uses for recording crash
 36832: // dumps. This code has to run in a compromised environment (the address space
 36832: // may have received SIGSEGV), thus the following rules apply:
 36832: //   * You may not enter the dynamic linker. This means that we cannot call
 36832: //     any symbols in a shared library (inc libc). Because of this we replace
 36832: //     libc functions in linux_libc_support.h.
 36832: //   * You may not call syscalls via the libc wrappers. This rule is a subset
 36832: //     of the first rule but it bears repeating. We have direct wrappers
 36832: //     around the system calls in linux_syscall_support.h.
 36832: //   * You may not malloc. There's an alternative allocator in memory.h and
 36832: //     a canonical instance in the LinuxDumper object. We use the placement
 36832: //     new form to allocate objects and we don't delete them.
 36832: 
114869: #include "client/linux/handler/minidump_descriptor.h"
 36832: #include "client/linux/minidump_writer/minidump_writer.h"
 36832: #include "client/minidump_file_writer-inl.h"
 36832: 
114869: #include <ctype.h>
 36832: #include <errno.h>
 36832: #include <fcntl.h>
114869: #include <link.h>
114869: #include <stdio.h>
114534: #if defined(__ANDROID__)
114869: #include <sys/system_properties.h>
114534: #endif
 36832: #include <sys/ucontext.h>
 36832: #include <sys/user.h>
 36832: #include <sys/utsname.h>
114869: #include <unistd.h>
114869: 
114869: #include <algorithm>
 36832: 
 36832: #include "client/linux/handler/exception_handler.h"
 36832: #include "client/linux/minidump_writer/line_reader.h"
 39657: #include "client/linux/minidump_writer/linux_dumper.h"
114869: #include "client/linux/minidump_writer/linux_ptrace_dumper.h"
114869: #include "client/minidump_file_writer.h"
 36832: #include "common/linux/linux_libc_support.h"
114869: #include "google_breakpad/common/minidump_format.h"
114869: #include "third_party/lss/linux_syscall_support.h"
 36832: 
114869: namespace {
114869: 
114869: using google_breakpad::AppMemoryList;
114869: using google_breakpad::ExceptionHandler;
114869: using google_breakpad::LineReader;
114869: using google_breakpad::LinuxDumper;
114869: using google_breakpad::LinuxPtraceDumper;
114869: using google_breakpad::MappingEntry;
114869: using google_breakpad::MappingInfo;
114869: using google_breakpad::MappingList;
114869: using google_breakpad::MinidumpFileWriter;
114869: using google_breakpad::PageAllocator;
 39789: using google_breakpad::ThreadInfo;
114869: using google_breakpad::TypedMDRVA;
114869: using google_breakpad::UntypedMDRVA;
114869: using google_breakpad::wasteful_vector;
 39789: 
 36832: // Minidump defines register structures which are different from the raw
 36832: // structures which we get from the kernel. These are platform specific
 36832: // functions to juggle the ucontext and user structures into minidump format.
 36832: #if defined(__i386)
 36832: typedef MDRawContextX86 RawContextCPU;
 36832: 
 36832: // Write a uint16_t to memory
 36832: //   out: memory location to write to
 36832: //   v: value to write.
114869: void U16(void* out, uint16_t v) {
114869:   my_memcpy(out, &v, sizeof(v));
 36832: }
 36832: 
 36832: // Write a uint32_t to memory
 36832: //   out: memory location to write to
 36832: //   v: value to write.
114869: void U32(void* out, uint32_t v) {
114869:   my_memcpy(out, &v, sizeof(v));
 36832: }
 36832: 
 36832: // Juggle an x86 user_(fp|fpx|)regs_struct into minidump format
 36832: //   out: the minidump structure
 36832: //   info: the collection of register structures.
114869: void CPUFillFromThreadInfo(MDRawContextX86 *out,
114869:                            const google_breakpad::ThreadInfo &info) {
 36832:   out->context_flags = MD_CONTEXT_X86_ALL;
 36832: 
 36832:   out->dr0 = info.dregs[0];
 36832:   out->dr1 = info.dregs[1];
 36832:   out->dr2 = info.dregs[2];
 36832:   out->dr3 = info.dregs[3];
 36832:   // 4 and 5 deliberatly omitted because they aren't included in the minidump
 36832:   // format.
 36832:   out->dr6 = info.dregs[6];
 36832:   out->dr7 = info.dregs[7];
 36832: 
 36832:   out->gs = info.regs.xgs;
 36832:   out->fs = info.regs.xfs;
 36832:   out->es = info.regs.xes;
 36832:   out->ds = info.regs.xds;
 36832: 
 36832:   out->edi = info.regs.edi;
 36832:   out->esi = info.regs.esi;
 36832:   out->ebx = info.regs.ebx;
 36832:   out->edx = info.regs.edx;
 36832:   out->ecx = info.regs.ecx;
 36832:   out->eax = info.regs.eax;
 36832: 
 36832:   out->ebp = info.regs.ebp;
 36832:   out->eip = info.regs.eip;
 36832:   out->cs = info.regs.xcs;
 36832:   out->eflags = info.regs.eflags;
 36832:   out->esp = info.regs.esp;
 36832:   out->ss = info.regs.xss;
 36832: 
 36832:   out->float_save.control_word = info.fpregs.cwd;
 36832:   out->float_save.status_word = info.fpregs.swd;
 36832:   out->float_save.tag_word = info.fpregs.twd;
 36832:   out->float_save.error_offset = info.fpregs.fip;
 36832:   out->float_save.error_selector = info.fpregs.fcs;
 36832:   out->float_save.data_offset = info.fpregs.foo;
 36832:   out->float_save.data_selector = info.fpregs.fos;
 36832: 
 36832:   // 8 registers * 10 bytes per register.
114869:   my_memcpy(out->float_save.register_area, info.fpregs.st_space, 10 * 8);
 36832: 
 36832:   // This matches the Intel fpsave format.
 36832:   U16(out->extended_registers + 0, info.fpregs.cwd);
 36832:   U16(out->extended_registers + 2, info.fpregs.swd);
 36832:   U16(out->extended_registers + 4, info.fpregs.twd);
 36832:   U16(out->extended_registers + 6, info.fpxregs.fop);
 36832:   U32(out->extended_registers + 8, info.fpxregs.fip);
 36832:   U16(out->extended_registers + 12, info.fpxregs.fcs);
 36832:   U32(out->extended_registers + 16, info.fpregs.foo);
 36832:   U16(out->extended_registers + 20, info.fpregs.fos);
 36832:   U32(out->extended_registers + 24, info.fpxregs.mxcsr);
 36832: 
114869:   my_memcpy(out->extended_registers + 32, &info.fpxregs.st_space, 128);
114869:   my_memcpy(out->extended_registers + 160, &info.fpxregs.xmm_space, 128);
 36832: }
 36832: 
 36832: // Juggle an x86 ucontext into minidump format
 36832: //   out: the minidump structure
 36832: //   info: the collection of register structures.
114869: void CPUFillFromUContext(MDRawContextX86 *out, const ucontext *uc,
 36832:                          const struct _libc_fpstate* fp) {
 36832:   const greg_t* regs = uc->uc_mcontext.gregs;
 36832: 
 36832:   out->context_flags = MD_CONTEXT_X86_FULL |
 36832:                        MD_CONTEXT_X86_FLOATING_POINT;
 36832: 
 36832:   out->gs = regs[REG_GS];
 36832:   out->fs = regs[REG_FS];
 36832:   out->es = regs[REG_ES];
 36832:   out->ds = regs[REG_DS];
 36832: 
 36832:   out->edi = regs[REG_EDI];
 36832:   out->esi = regs[REG_ESI];
 36832:   out->ebx = regs[REG_EBX];
 36832:   out->edx = regs[REG_EDX];
 36832:   out->ecx = regs[REG_ECX];
 36832:   out->eax = regs[REG_EAX];
 36832: 
 36832:   out->ebp = regs[REG_EBP];
 36832:   out->eip = regs[REG_EIP];
 36832:   out->cs = regs[REG_CS];
 36832:   out->eflags = regs[REG_EFL];
 36832:   out->esp = regs[REG_UESP];
 36832:   out->ss = regs[REG_SS];
 36832: 
 36832:   out->float_save.control_word = fp->cw;
 36832:   out->float_save.status_word = fp->sw;
 36832:   out->float_save.tag_word = fp->tag;
 36832:   out->float_save.error_offset = fp->ipoff;
 36832:   out->float_save.error_selector = fp->cssel;
 36832:   out->float_save.data_offset = fp->dataoff;
 36832:   out->float_save.data_selector = fp->datasel;
 36832: 
 36832:   // 8 registers * 10 bytes per register.
114869:   my_memcpy(out->float_save.register_area, fp->_st, 10 * 8);
 39789: }
 39789: 
 36832: #elif defined(__x86_64)
 36832: typedef MDRawContextAMD64 RawContextCPU;
 36832: 
114869: void CPUFillFromThreadInfo(MDRawContextAMD64 *out,
114869:                            const google_breakpad::ThreadInfo &info) {
 36832:   out->context_flags = MD_CONTEXT_AMD64_FULL |
 36832:                        MD_CONTEXT_AMD64_SEGMENTS;
 36832: 
 36832:   out->cs = info.regs.cs;
 36832: 
 36832:   out->ds = info.regs.ds;
 36832:   out->es = info.regs.es;
 36832:   out->fs = info.regs.fs;
 36832:   out->gs = info.regs.gs;
 36832: 
 36832:   out->ss = info.regs.ss;
 36832:   out->eflags = info.regs.eflags;
 36832: 
 36832:   out->dr0 = info.dregs[0];
 36832:   out->dr1 = info.dregs[1];
 36832:   out->dr2 = info.dregs[2];
 36832:   out->dr3 = info.dregs[3];
 36832:   // 4 and 5 deliberatly omitted because they aren't included in the minidump
 36832:   // format.
 36832:   out->dr6 = info.dregs[6];
 36832:   out->dr7 = info.dregs[7];
 36832: 
 36832:   out->rax = info.regs.rax;
 36832:   out->rcx = info.regs.rcx;
 36832:   out->rdx = info.regs.rdx;
 36832:   out->rbx = info.regs.rbx;
 36832: 
 36832:   out->rsp = info.regs.rsp;
 36832: 
 36832:   out->rbp = info.regs.rbp;
 36832:   out->rsi = info.regs.rsi;
 36832:   out->rdi = info.regs.rdi;
 36832:   out->r8 = info.regs.r8;
 36832:   out->r9 = info.regs.r9;
 36832:   out->r10 = info.regs.r10;
 36832:   out->r11 = info.regs.r11;
 36832:   out->r12 = info.regs.r12;
 36832:   out->r13 = info.regs.r13;
 36832:   out->r14 = info.regs.r14;
 36832:   out->r15 = info.regs.r15;
 36832: 
 36832:   out->rip = info.regs.rip;
 36832: 
 36832:   out->flt_save.control_word = info.fpregs.cwd;
 36832:   out->flt_save.status_word = info.fpregs.swd;
 36832:   out->flt_save.tag_word = info.fpregs.ftw;
 36832:   out->flt_save.error_opcode = info.fpregs.fop;
 36832:   out->flt_save.error_offset = info.fpregs.rip;
 36832:   out->flt_save.error_selector = 0;  // We don't have this.
 36832:   out->flt_save.data_offset = info.fpregs.rdp;
 36832:   out->flt_save.data_selector = 0;   // We don't have this.
 36832:   out->flt_save.mx_csr = info.fpregs.mxcsr;
 36832:   out->flt_save.mx_csr_mask = info.fpregs.mxcr_mask;
114869:   my_memcpy(&out->flt_save.float_registers, &info.fpregs.st_space, 8 * 16);
114869:   my_memcpy(&out->flt_save.xmm_registers, &info.fpregs.xmm_space, 16 * 16);
 36832: }
 36832: 
114869: void CPUFillFromUContext(MDRawContextAMD64 *out, const ucontext *uc,
 36832:                          const struct _libc_fpstate* fpregs) {
 36832:   const greg_t* regs = uc->uc_mcontext.gregs;
 36832: 
 36832:   out->context_flags = MD_CONTEXT_AMD64_FULL;
 36832: 
 36832:   out->cs = regs[REG_CSGSFS] & 0xffff;
 36832: 
 36832:   out->fs = (regs[REG_CSGSFS] >> 32) & 0xffff;
 36832:   out->gs = (regs[REG_CSGSFS] >> 16) & 0xffff;
 36832: 
 36832:   out->eflags = regs[REG_EFL];
 36832: 
 36832:   out->rax = regs[REG_RAX];
 36832:   out->rcx = regs[REG_RCX];
 36832:   out->rdx = regs[REG_RDX];
 36832:   out->rbx = regs[REG_RBX];
 36832: 
 36832:   out->rsp = regs[REG_RSP];
 36832:   out->rbp = regs[REG_RBP];
 36832:   out->rsi = regs[REG_RSI];
 36832:   out->rdi = regs[REG_RDI];
 36832:   out->r8 = regs[REG_R8];
 36832:   out->r9 = regs[REG_R9];
 36832:   out->r10 = regs[REG_R10];
 36832:   out->r11 = regs[REG_R11];
 36832:   out->r12 = regs[REG_R12];
 36832:   out->r13 = regs[REG_R13];
 36832:   out->r14 = regs[REG_R14];
 36832:   out->r15 = regs[REG_R15];
 36832: 
 36832:   out->rip = regs[REG_RIP];
 36832: 
 36832:   out->flt_save.control_word = fpregs->cwd;
 36832:   out->flt_save.status_word = fpregs->swd;
 36832:   out->flt_save.tag_word = fpregs->ftw;
 36832:   out->flt_save.error_opcode = fpregs->fop;
 36832:   out->flt_save.error_offset = fpregs->rip;
 36832:   out->flt_save.data_offset = fpregs->rdp;
 36832:   out->flt_save.error_selector = 0;  // We don't have this.
 36832:   out->flt_save.data_selector = 0;  // We don't have this.
 36832:   out->flt_save.mx_csr = fpregs->mxcsr;
 36832:   out->flt_save.mx_csr_mask = fpregs->mxcr_mask;
114869:   my_memcpy(&out->flt_save.float_registers, &fpregs->_st, 8 * 16);
114869:   my_memcpy(&out->flt_save.xmm_registers, &fpregs->_xmm, 16 * 16);
 39789: }
 39789: 
 39657: #elif defined(__ARMEL__)
 39657: typedef MDRawContextARM RawContextCPU;
 39657: 
114869: void CPUFillFromThreadInfo(MDRawContextARM* out,
114869:                            const google_breakpad::ThreadInfo& info) {
 39657:   out->context_flags = MD_CONTEXT_ARM_FULL;
 39657: 
 39657:   for (int i = 0; i < MD_CONTEXT_ARM_GPR_COUNT; ++i)
 39657:     out->iregs[i] = info.regs.uregs[i];
 39657:   // No CPSR register in ThreadInfo(it's not accessible via ptrace)
 39657:   out->cpsr = 0;
 56278: #if !defined(__ANDROID__)
 39657:   out->float_save.fpscr = info.fpregs.fpsr |
 39657:     (static_cast<u_int64_t>(info.fpregs.fpcr) << 32);
 39657:   // TODO: sort this out, actually collect floating point registers
114869:   my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
114869:   my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
 56278: #endif
 39657: }
 39657: 
114869: void CPUFillFromUContext(MDRawContextARM* out, const ucontext* uc,
 39657:                          const struct _libc_fpstate* fpregs) {
 39657:   out->context_flags = MD_CONTEXT_ARM_FULL;
 39657: 
 39657:   out->iregs[0] = uc->uc_mcontext.arm_r0;
 39657:   out->iregs[1] = uc->uc_mcontext.arm_r1;
 39657:   out->iregs[2] = uc->uc_mcontext.arm_r2;
 39657:   out->iregs[3] = uc->uc_mcontext.arm_r3;
 39657:   out->iregs[4] = uc->uc_mcontext.arm_r4;
 39657:   out->iregs[5] = uc->uc_mcontext.arm_r5;
 39657:   out->iregs[6] = uc->uc_mcontext.arm_r6;
 39657:   out->iregs[7] = uc->uc_mcontext.arm_r7;
 39657:   out->iregs[8] = uc->uc_mcontext.arm_r8;
 39657:   out->iregs[9] = uc->uc_mcontext.arm_r9;
 39657:   out->iregs[10] = uc->uc_mcontext.arm_r10;
 39657: 
 39657:   out->iregs[11] = uc->uc_mcontext.arm_fp;
 39657:   out->iregs[12] = uc->uc_mcontext.arm_ip;
 39657:   out->iregs[13] = uc->uc_mcontext.arm_sp;
 39657:   out->iregs[14] = uc->uc_mcontext.arm_lr;
 39657:   out->iregs[15] = uc->uc_mcontext.arm_pc;
 39657: 
 39657:   out->cpsr = uc->uc_mcontext.arm_cpsr;
 39657: 
 39657:   // TODO: fix this after fixing ExceptionHandler
 39657:   out->float_save.fpscr = 0;
114869:   my_memset(&out->float_save.regs, 0, sizeof(out->float_save.regs));
114869:   my_memset(&out->float_save.extra, 0, sizeof(out->float_save.extra));
 39789: }
 39789: 
 36832: #else
 36832: #error "This code has not been ported to your platform yet."
 36832: #endif
 36832: 
 36832: class MinidumpWriter {
 36832:  public:
114869:   MinidumpWriter(const char* minidump_path,
114869:                  int minidump_fd,
 56283:                  const ExceptionHandler::CrashContext* context,
 73558:                  const MappingList& mappings,
114869:                  const AppMemoryList& appmem,
114869:                  LinuxDumper* dumper)
114869:       : fd_(minidump_fd),
114869:         path_(minidump_path),
114869:         ucontext_(context ? &context->context : NULL),
 39657: #if !defined(__ARM_EABI__)
114869:         float_state_(context ? &context->float_state : NULL),
 39657: #else
 39657:         // TODO: fix this after fixing ExceptionHandler
 39657:         float_state_(NULL),
 39657: #endif
114869:         dumper_(dumper),
114869:         memory_blocks_(dumper_->allocator()),
114869:         mapping_list_(mappings),
114869:         app_memory_list_(appmem) {
114869:     // Assert there should be either a valid fd or a valid path, not both.
114869:     assert(fd_ != -1 || minidump_path);
114869:     assert(fd_ == -1 || !minidump_path);
 39789:   }
 39789: 
 36832:   bool Init() {
114869:     if (!dumper_->Init())
114869:       return false;
114869: 
114869:     if (fd_ != -1)
114869:       minidump_writer_.SetFile(fd_);
114869:     else if (!minidump_writer_.Open(path_))
114869:       return false;
114869: 
114869:     return dumper_->ThreadsSuspend();
 36832:   }
 36832: 
 36832:   ~MinidumpWriter() {
114869:     // Don't close the file descriptor when it's been provided explicitly.
114869:     // Callers might still need to use it.
114869:     if (fd_ == -1)
 36832:       minidump_writer_.Close();
114869:     dumper_->ThreadsResume();
 36832:   }
 36832: 
 36832:   bool Dump() {
 36832:     // A minidump file contains a number of tagged streams. This is the number
 36832:     // of stream which we write.
106369:     unsigned kNumWriters = 13;
 36832: 
 36832:     TypedMDRVA<MDRawHeader> header(&minidump_writer_);
 36832:     TypedMDRVA<MDRawDirectory> dir(&minidump_writer_);
 36832:     if (!header.Allocate())
 36832:       return false;
 36832:     if (!dir.AllocateArray(kNumWriters))
 36832:       return false;
114869:     my_memset(header.get(), 0, sizeof(MDRawHeader));
 36832: 
 36832:     header.get()->signature = MD_HEADER_SIGNATURE;
 36832:     header.get()->version = MD_HEADER_VERSION;
 36832:     header.get()->time_date_stamp = time(NULL);
 36832:     header.get()->stream_count = kNumWriters;
 36832:     header.get()->stream_directory_rva = dir.position();
 36832: 
 36832:     unsigned dir_index = 0;
 36832:     MDRawDirectory dirent;
 36832: 
 36832:     if (!WriteThreadListStream(&dirent))
 36832:       return false;
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     if (!WriteMappings(&dirent))
 36832:       return false;
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 73558:     if (!WriteAppMemory())
 73558:       return false;
 73558: 
 54618:     if (!WriteMemoryListStream(&dirent))
 54618:       return false;
 54618:     dir.CopyIndex(dir_index++, &dirent);
 54618: 
 36832:     if (!WriteExceptionStream(&dirent))
 36832:       return false;
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     if (!WriteSystemInfoStream(&dirent))
 36832:       return false;
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     dirent.stream_type = MD_LINUX_CPU_INFO;
 36832:     if (!WriteFile(&dirent.location, "/proc/cpuinfo"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     dirent.stream_type = MD_LINUX_PROC_STATUS;
114869:     if (!WriteProcFile(&dirent.location, GetCrashThread(), "status"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     dirent.stream_type = MD_LINUX_LSB_RELEASE;
 36832:     if (!WriteFile(&dirent.location, "/etc/lsb-release"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     dirent.stream_type = MD_LINUX_CMD_LINE;
114869:     if (!WriteProcFile(&dirent.location, GetCrashThread(), "cmdline"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     dirent.stream_type = MD_LINUX_ENVIRON;
114869:     if (!WriteProcFile(&dirent.location, GetCrashThread(), "environ"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 36832:     dirent.stream_type = MD_LINUX_AUXV;
114869:     if (!WriteProcFile(&dirent.location, GetCrashThread(), "auxv"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 50677:     dirent.stream_type = MD_LINUX_MAPS;
114869:     if (!WriteProcFile(&dirent.location, GetCrashThread(), "maps"))
 36832:       NullifyDirectoryEntry(&dirent);
 36832:     dir.CopyIndex(dir_index++, &dirent);
 36832: 
 50677:     dirent.stream_type = MD_LINUX_DSO_DEBUG;
106369:     if (!WriteDSODebugStream(&dirent))
 50677:       NullifyDirectoryEntry(&dirent);
 50677:     dir.CopyIndex(dir_index++, &dirent);
 50677: 
 36832:     // If you add more directory entries, don't forget to update kNumWriters,
 36832:     // above.
 36832: 
114869:     dumper_->ThreadsResume();
 36832:     return true;
 36832:   }
 36832: 
 50677:   // Check if the top of the stack is part of a system call that has been
 50677:   // redirected by the seccomp sandbox. If so, try to pop the stack frames
 50677:   // all the way back to the point where the interception happened.
 50677:   void PopSeccompStackFrame(RawContextCPU* cpu, const MDRawThread& thread,
 50677:                             uint8_t* stack_copy) {
 50677: #if defined(__x86_64)
 50677:     u_int64_t bp = cpu->rbp;
 50677:     u_int64_t top = thread.stack.start_of_memory_range;
 50677:     for (int i = 4; i--; ) {
 50677:       if (bp < top ||
 50677:           bp + sizeof(bp) > thread.stack.start_of_memory_range +
 50677:           thread.stack.memory.data_size ||
 50677:           bp & 1) {
 50677:         break;
 50677:       }
 50677:       uint64_t old_top = top;
 50677:       top = bp;
 50677:       u_int8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
114869:       my_memcpy(&bp, bp_addr, sizeof(bp));
 50677:       if (bp == 0xDEADBEEFDEADBEEFull) {
 50677:         struct {
 50677:           uint64_t r15;
 50677:           uint64_t r14;
 50677:           uint64_t r13;
 50677:           uint64_t r12;
 50677:           uint64_t r11;
 50677:           uint64_t r10;
 50677:           uint64_t r9;
 50677:           uint64_t r8;
 50677:           uint64_t rdi;
 50677:           uint64_t rsi;
 50677:           uint64_t rdx;
 50677:           uint64_t rcx;
 50677:           uint64_t rbx;
 50677:           uint64_t deadbeef;
 50677:           uint64_t rbp;
 50677:           uint64_t fakeret;
 50677:           uint64_t ret;
 50677:           /* char redzone[128]; */
 50677:         } seccomp_stackframe;
 50677:         if (top - offsetof(typeof(seccomp_stackframe), deadbeef) < old_top ||
 50677:             top - offsetof(typeof(seccomp_stackframe), deadbeef) +
 50677:             sizeof(seccomp_stackframe) >
 50677:             thread.stack.start_of_memory_range+thread.stack.memory.data_size) {
 50677:           break;
 50677:         }
114869:         my_memcpy(&seccomp_stackframe,
 50677:                   bp_addr - offsetof(typeof(seccomp_stackframe), deadbeef),
 50677:                   sizeof(seccomp_stackframe));
 50677:         cpu->rbx = seccomp_stackframe.rbx;
 50677:         cpu->rcx = seccomp_stackframe.rcx;
 50677:         cpu->rdx = seccomp_stackframe.rdx;
 50677:         cpu->rsi = seccomp_stackframe.rsi;
 50677:         cpu->rdi = seccomp_stackframe.rdi;
 50677:         cpu->rbp = seccomp_stackframe.rbp;
 50677:         cpu->rsp = top + 4*sizeof(uint64_t) + 128;
 50677:         cpu->r8  = seccomp_stackframe.r8;
 50677:         cpu->r9  = seccomp_stackframe.r9;
 50677:         cpu->r10 = seccomp_stackframe.r10;
 50677:         cpu->r11 = seccomp_stackframe.r11;
 50677:         cpu->r12 = seccomp_stackframe.r12;
 50677:         cpu->r13 = seccomp_stackframe.r13;
 50677:         cpu->r14 = seccomp_stackframe.r14;
 50677:         cpu->r15 = seccomp_stackframe.r15;
 50677:         cpu->rip = seccomp_stackframe.fakeret;
 50677:         return;
 50677:       }
 50677:     }
 50677: #elif defined(__i386)
 50677:     u_int32_t bp = cpu->ebp;
 50677:     u_int32_t top = thread.stack.start_of_memory_range;
 50677:     for (int i = 4; i--; ) {
 50677:       if (bp < top ||
 50677:           bp + sizeof(bp) > thread.stack.start_of_memory_range +
 50677:           thread.stack.memory.data_size ||
 50677:           bp & 1) {
 50677:         break;
 50677:       }
 50677:       uint32_t old_top = top;
 50677:       top = bp;
 50677:       u_int8_t* bp_addr = stack_copy + bp - thread.stack.start_of_memory_range;
114869:       my_memcpy(&bp, bp_addr, sizeof(bp));
 50677:       if (bp == 0xDEADBEEFu) {
 50677:         struct {
 50677:           uint32_t edi;
 50677:           uint32_t esi;
 50677:           uint32_t edx;
 50677:           uint32_t ecx;
 50677:           uint32_t ebx;
 50677:           uint32_t deadbeef;
 50677:           uint32_t ebp;
 50677:           uint32_t fakeret;
 50677:           uint32_t ret;
 50677:         } seccomp_stackframe;
 50677:         if (top - offsetof(typeof(seccomp_stackframe), deadbeef) < old_top ||
 50677:             top - offsetof(typeof(seccomp_stackframe), deadbeef) +
 50677:             sizeof(seccomp_stackframe) >
 50677:             thread.stack.start_of_memory_range+thread.stack.memory.data_size) {
 50677:           break;
 50677:         }
114869:         my_memcpy(&seccomp_stackframe,
 50677:                   bp_addr - offsetof(typeof(seccomp_stackframe), deadbeef),
 50677:                   sizeof(seccomp_stackframe));
 50677:         cpu->ebx = seccomp_stackframe.ebx;
 50677:         cpu->ecx = seccomp_stackframe.ecx;
 50677:         cpu->edx = seccomp_stackframe.edx;
 50677:         cpu->esi = seccomp_stackframe.esi;
 50677:         cpu->edi = seccomp_stackframe.edi;
 50677:         cpu->ebp = seccomp_stackframe.ebp;
 50677:         cpu->esp = top + 4*sizeof(void*);
 50677:         cpu->eip = seccomp_stackframe.fakeret;
 50677:         return;
 50677:       }
 50677:     }
 50677: #endif
 50677:   }
 50677: 
 36832:   // Write information about the threads.
 36832:   bool WriteThreadListStream(MDRawDirectory* dirent) {
114869:     const unsigned num_threads = dumper_->threads().size();
 36832: 
 36832:     TypedMDRVA<uint32_t> list(&minidump_writer_);
 36832:     if (!list.AllocateObjectAndArray(num_threads, sizeof(MDRawThread)))
 36832:       return false;
 36832: 
 36832:     dirent->stream_type = MD_THREAD_LIST_STREAM;
 36832:     dirent->location = list.location();
 36832: 
 36832:     *list.get() = num_threads;
 36832: 
 36832:     for (unsigned i = 0; i < num_threads; ++i) {
 36832:       MDRawThread thread;
 36832:       my_memset(&thread, 0, sizeof(thread));
114869:       thread.thread_id = dumper_->threads()[i];
 36832:       // We have a different source of information for the crashing thread. If
 36832:       // we used the actual state of the thread we would find it running in the
 36832:       // signal handler with the alternative stack, which would be deeply
 36832:       // unhelpful.
114869:       if (static_cast<pid_t>(thread.thread_id) == GetCrashThread() &&
114869:           ucontext_ &&
114869:           !dumper_->IsPostMortem()) {
 36832:         const void* stack;
 36832:         size_t stack_len;
114869:         if (!dumper_->GetStackInfo(&stack, &stack_len, GetStackPointer()))
 36832:           return false;
 36832:         UntypedMDRVA memory(&minidump_writer_);
 36832:         if (!memory.Allocate(stack_len))
 36832:           return false;
114869:         uint8_t* stack_copy = reinterpret_cast<uint8_t*>(Alloc(stack_len));
114869:         dumper_->CopyFromProcess(stack_copy, thread.thread_id, stack,
114869:                                  stack_len);
 36832:         memory.Copy(stack_copy, stack_len);
 36832:         thread.stack.start_of_memory_range = (uintptr_t) (stack);
 36832:         thread.stack.memory = memory.location();
 54618:         memory_blocks_.push_back(thread.stack);
 54618: 
 54618:         // Copy 256 bytes around crashing instruction pointer to minidump.
 54618:         const size_t kIPMemorySize = 256;
 54618:         u_int64_t ip = GetInstructionPointer();
 54618:         // Bound it to the upper and lower bounds of the memory map
 54618:         // it's contained within. If it's not in mapped memory,
 54618:         // don't bother trying to write it.
 54618:         bool ip_is_mapped = false;
 54618:         MDMemoryDescriptor ip_memory_d;
114869:         for (unsigned j = 0; j < dumper_->mappings().size(); ++j) {
114869:           const MappingInfo& mapping = *dumper_->mappings()[j];
 54618:           if (ip >= mapping.start_addr &&
 54618:               ip < mapping.start_addr + mapping.size) {
 54618:             ip_is_mapped = true;
 54618:             // Try to get 128 bytes before and after the IP, but
 54618:             // settle for whatever's available.
 54618:             ip_memory_d.start_of_memory_range =
 54618:               std::max(mapping.start_addr,
 54618:                        uintptr_t(ip - (kIPMemorySize / 2)));
 54618:             uintptr_t end_of_range =
 54618:               std::min(uintptr_t(ip + (kIPMemorySize / 2)),
 54618:                        uintptr_t(mapping.start_addr + mapping.size));
 54618:             ip_memory_d.memory.data_size =
 54618:               end_of_range - ip_memory_d.start_of_memory_range;
 54618:             break;
 54618:           }
 54618:         }
 54618: 
 54618:         if (ip_is_mapped) {
 54618:           UntypedMDRVA ip_memory(&minidump_writer_);
 54618:           if (!ip_memory.Allocate(ip_memory_d.memory.data_size))
 54618:             return false;
 54618:           uint8_t* memory_copy =
114869:               reinterpret_cast<uint8_t*>(Alloc(ip_memory_d.memory.data_size));
114869:           dumper_->CopyFromProcess(
 54618:               memory_copy,
 54618:               thread.thread_id,
 54618:               reinterpret_cast<void*>(ip_memory_d.start_of_memory_range),
 54618:               ip_memory_d.memory.data_size);
 54618:           ip_memory.Copy(memory_copy, ip_memory_d.memory.data_size);
 54618:           ip_memory_d.memory = ip_memory.location();
 54618:           memory_blocks_.push_back(ip_memory_d);
 54618:         }
 54618: 
 36832:         TypedMDRVA<RawContextCPU> cpu(&minidump_writer_);
 36832:         if (!cpu.Allocate())
 36832:           return false;
 36832:         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
 36832:         CPUFillFromUContext(cpu.get(), ucontext_, float_state_);
 50677:         PopSeccompStackFrame(cpu.get(), thread, stack_copy);
 36832:         thread.thread_context = cpu.location();
 36832:         crashing_thread_context_ = cpu.location();
 36832:       } else {
 36832:         ThreadInfo info;
114869:         if (!dumper_->GetThreadInfoByIndex(i, &info))
 36832:           return false;
 36832:         UntypedMDRVA memory(&minidump_writer_);
 36832:         if (!memory.Allocate(info.stack_len))
 36832:           return false;
114869:         uint8_t* stack_copy = reinterpret_cast<uint8_t*>(Alloc(info.stack_len));
114869:         dumper_->CopyFromProcess(stack_copy, thread.thread_id, info.stack,
 36832:                                  info.stack_len);
 36832:         memory.Copy(stack_copy, info.stack_len);
 36832:         thread.stack.start_of_memory_range = (uintptr_t)(info.stack);
 36832:         thread.stack.memory = memory.location();
 54618:         memory_blocks_.push_back(thread.stack);
 54618: 
 36832:         TypedMDRVA<RawContextCPU> cpu(&minidump_writer_);
 36832:         if (!cpu.Allocate())
 36832:           return false;
 36832:         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
 36832:         CPUFillFromThreadInfo(cpu.get(), info);
 50677:         PopSeccompStackFrame(cpu.get(), thread, stack_copy);
 36832:         thread.thread_context = cpu.location();
114869:         if (dumper_->threads()[i] == GetCrashThread()) {
 40023:           crashing_thread_context_ = cpu.location();
114869:           if (!dumper_->IsPostMortem()) {
114869:             // This is the crashing thread of a live process, but
114869:             // no context was provided, so set the crash address
114869:             // while the instruction pointer is already here.
114869:             dumper_->set_crash_address(GetInstructionPointer(info));
114869:           }
 40023:         }
 36832:       }
 36832: 
 36832:       list.CopyIndexAfterObject(i, &thread, sizeof(thread));
 36832:     }
 36832: 
 36832:     return true;
 36832:   }
 36832: 
114869:   // Write application-provided memory regions.
 73558:   bool WriteAppMemory() {
114869:     for (AppMemoryList::const_iterator iter = app_memory_list_.begin();
114869:          iter != app_memory_list_.end();
 73558:          ++iter) {
 73558:       uint8_t* data_copy =
114869:         reinterpret_cast<uint8_t*>(dumper_->allocator()->Alloc(iter->length));
114869:       dumper_->CopyFromProcess(data_copy, GetCrashThread(), iter->ptr,
 73558:                                iter->length);
 73558: 
 73558:       UntypedMDRVA memory(&minidump_writer_);
114869:       if (!memory.Allocate(iter->length)) {
 73558:         return false;
114869:       }
 73558:       memory.Copy(data_copy, iter->length);
 73558:       MDMemoryDescriptor desc;
114869:       desc.start_of_memory_range = reinterpret_cast<uintptr_t>(iter->ptr);
 73558:       desc.memory = memory.location();
 73558:       memory_blocks_.push_back(desc);
 73558:     }
 73558: 
 73558:     return true;
 73558:   }
 73558: 
 36832:   static bool ShouldIncludeMapping(const MappingInfo& mapping) {
114869:     if (mapping.name[0] == 0 ||  // only want modules with filenames.
114869:         mapping.offset ||  // only want to include one mapping per shared lib.
 36832:         mapping.size < 4096) {  // too small to get a signature for.
 36832:       return false;
 36832:     }
 36832: 
 36832:     return true;
 36832:   }
 36832: 
 56283:   // If there is caller-provided information about this mapping
114869:   // in the mapping_list_ list, return true. Otherwise, return false.
 56283:   bool HaveMappingInfo(const MappingInfo& mapping) {
114869:     for (MappingList::const_iterator iter = mapping_list_.begin();
114869:          iter != mapping_list_.end();
 56283:          ++iter) {
 57320:       // Ignore any mappings that are wholly contained within
 57320:       // mappings in the mapping_info_ list.
 57320:       if (mapping.start_addr >= iter->first.start_addr &&
 57320:           (mapping.start_addr + mapping.size) <=
 57320:           (iter->first.start_addr + iter->first.size)) {
 56283:         return true;
 56283:       }
 56283:     }
 56283:     return false;
 56283:   }
 56283: 
 36832:   // Write information about the mappings in effect. Because we are using the
 36832:   // minidump format, the information about the mappings is pretty limited.
 36832:   // Because of this, we also include the full, unparsed, /proc/$x/maps file in
 36832:   // another stream in the file.
 36832:   bool WriteMappings(MDRawDirectory* dirent) {
114869:     const unsigned num_mappings = dumper_->mappings().size();
114869:     unsigned num_output_mappings = mapping_list_.size();
 36832: 
114869:     for (unsigned i = 0; i < dumper_->mappings().size(); ++i) {
114869:       const MappingInfo& mapping = *dumper_->mappings()[i];
 57320:       if (ShouldIncludeMapping(mapping) && !HaveMappingInfo(mapping))
 36832:         num_output_mappings++;
 36832:     }
 36832: 
 36832:     TypedMDRVA<uint32_t> list(&minidump_writer_);
 36832:     if (!list.AllocateObjectAndArray(num_output_mappings, MD_MODULE_SIZE))
 36832:       return false;
 36832: 
 36832:     dirent->stream_type = MD_MODULE_LIST_STREAM;
 36832:     dirent->location = list.location();
 36832:     *list.get() = num_output_mappings;
 36832: 
 56283:     // First write all the mappings from the dumper
 56283:     unsigned int j = 0;
 56283:     for (unsigned i = 0; i < num_mappings; ++i) {
114869:       const MappingInfo& mapping = *dumper_->mappings()[i];
 56283:       if (!ShouldIncludeMapping(mapping) || HaveMappingInfo(mapping))
 36832:         continue;
 36832: 
 36832:       MDRawModule mod;
114869:       if (!FillRawModule(mapping, true, i, mod, NULL))
 56283:         return false;
 56283:       list.CopyIndexAfterObject(j++, &mod, MD_MODULE_SIZE);
 56283:     }
 56283:     // Next write all the mappings provided by the caller
114869:     for (MappingList::const_iterator iter = mapping_list_.begin();
114869:          iter != mapping_list_.end();
 56283:          ++iter) {
 56283:       MDRawModule mod;
114869:       if (!FillRawModule(iter->first, false, 0, mod, iter->second))
 56283:         return false;
 56283:       list.CopyIndexAfterObject(j++, &mod, MD_MODULE_SIZE);
 56283:     }
 56283: 
 56283:     return true;
 56283:   }
 56283: 
114869:   // Fill the MDRawModule |mod| with information about the provided
114869:   // |mapping|. If |identifier| is non-NULL, use it instead of calculating
 56283:   // a file ID from the mapping.
 56283:   bool FillRawModule(const MappingInfo& mapping,
114869:                      bool member,
114869:                      unsigned int mapping_id,
 56283:                      MDRawModule& mod,
 56283:                      const u_int8_t* identifier) {
 36832:     my_memset(&mod, 0, MD_MODULE_SIZE);
 56283: 
 36832:     mod.base_of_image = mapping.start_addr;
 36832:     mod.size_of_image = mapping.size;
 36832:     const size_t filepath_len = my_strlen(mapping.name);
 36832: 
 36832:     // Figure out file name from path
 36832:     const char* filename_ptr = mapping.name + filepath_len - 1;
 36832:     while (filename_ptr >= mapping.name) {
 36832:       if (*filename_ptr == '/')
 36832:         break;
 36832:       filename_ptr--;
 36832:     }
 36832:     filename_ptr++;
 56283: 
114869:     const size_t filename_len = mapping.name + filepath_len - filename_ptr;
 56283: 
 36832:     uint8_t cv_buf[MDCVInfoPDB70_minsize + NAME_MAX];
 36832:     uint8_t* cv_ptr = cv_buf;
 36832:     UntypedMDRVA cv(&minidump_writer_);
 36832:     if (!cv.Allocate(MDCVInfoPDB70_minsize + filename_len + 1))
 36832:       return false;
 36832: 
 36832:     const uint32_t cv_signature = MD_CVINFOPDB70_SIGNATURE;
114869:     my_memcpy(cv_ptr, &cv_signature, sizeof(cv_signature));
 36832:     cv_ptr += sizeof(cv_signature);
 36832:     uint8_t* signature = cv_ptr;
 36832:     cv_ptr += sizeof(MDGUID);
 56283:     if (identifier) {
 56283:       // GUID was provided by caller.
114869:       my_memcpy(signature, identifier, sizeof(MDGUID));
 56283:     } else {
114869:       dumper_->ElfFileIdentifierForMapping(mapping, member,
114869:                                            mapping_id, signature);
 56283:     }
 36832:     my_memset(cv_ptr, 0, sizeof(uint32_t));  // Set age to 0 on Linux.
 36832:     cv_ptr += sizeof(uint32_t);
 36832: 
 36832:     // Write pdb_file_name
114869:     my_memcpy(cv_ptr, filename_ptr, filename_len + 1);
 36832:     cv.Copy(cv_buf, MDCVInfoPDB70_minsize + filename_len + 1);
 36832: 
 36832:     mod.cv_record = cv.location();
 36832: 
 36832:     MDLocationDescriptor ld;
 36832:     if (!minidump_writer_.WriteString(mapping.name, filepath_len, &ld))
 36832:       return false;
 36832:     mod.module_name_rva = ld.rva;
 36832:     return true;
 36832:   }
 36832: 
 54618:   bool WriteMemoryListStream(MDRawDirectory* dirent) {
 54618:     TypedMDRVA<uint32_t> list(&minidump_writer_);
 54618:     if (!list.AllocateObjectAndArray(memory_blocks_.size(),
 54618:                                      sizeof(MDMemoryDescriptor)))
 54618:       return false;
 54618: 
 54618:     dirent->stream_type = MD_MEMORY_LIST_STREAM;
 54618:     dirent->location = list.location();
 54618: 
 54618:     *list.get() = memory_blocks_.size();
 54618: 
 54618:     for (size_t i = 0; i < memory_blocks_.size(); ++i) {
 54618:       list.CopyIndexAfterObject(i, &memory_blocks_[i],
 54618:                                 sizeof(MDMemoryDescriptor));
 54618:     }
 54618:     return true;
 54618:   }
 54618: 
 36832:   bool WriteExceptionStream(MDRawDirectory* dirent) {
 36832:     TypedMDRVA<MDRawExceptionStream> exc(&minidump_writer_);
 36832:     if (!exc.Allocate())
 36832:       return false;
 36832:     my_memset(exc.get(), 0, sizeof(MDRawExceptionStream));
 36832: 
 36832:     dirent->stream_type = MD_EXCEPTION_STREAM;
 36832:     dirent->location = exc.location();
 36832: 
114869:     exc.get()->thread_id = GetCrashThread();
114869:     exc.get()->exception_record.exception_code = dumper_->crash_signal();
114869:     exc.get()->exception_record.exception_address = dumper_->crash_address();
 36832:     exc.get()->thread_context = crashing_thread_context_;
 36832: 
 36832:     return true;
 36832:   }
 36832: 
 36832:   bool WriteSystemInfoStream(MDRawDirectory* dirent) {
 36832:     TypedMDRVA<MDRawSystemInfo> si(&minidump_writer_);
 36832:     if (!si.Allocate())
 36832:       return false;
 36832:     my_memset(si.get(), 0, sizeof(MDRawSystemInfo));
 36832: 
 36832:     dirent->stream_type = MD_SYSTEM_INFO_STREAM;
 36832:     dirent->location = si.location();
 36832: 
 36832:     WriteCPUInformation(si.get());
 36832:     WriteOSInformation(si.get());
 36832: 
 36832:     return true;
 36832:   }
 36832: 
106369:   bool WriteDSODebugStream(MDRawDirectory* dirent) {
 56278: #if defined(__ANDROID__)
 56278:     return false;
 56278: #else
114869:     ElfW(Phdr)* phdr = reinterpret_cast<ElfW(Phdr) *>(dumper_->auxv()[AT_PHDR]);
106369:     char* base;
114869:     int phnum = dumper_->auxv()[AT_PHNUM];
106369:     if (!phnum || !phdr)
106369:       return false;
106369: 
106369:     // Assume the program base is at the beginning of the same page as the PHDR
106369:     base = reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(phdr) & ~0xfff);
106369: 
106369:     // Search for the program PT_DYNAMIC segment
106369:     ElfW(Addr) dyn_addr = 0;
106369:     for (; phnum >= 0; phnum--, phdr++) {
106369:       ElfW(Phdr) ph;
114869:       dumper_->CopyFromProcess(&ph, GetCrashThread(), phdr, sizeof(ph));
106369:       // Adjust base address with the virtual address of the PT_LOAD segment
106369:       // corresponding to offset 0
114869:       if (ph.p_type == PT_LOAD && ph.p_offset == 0) {
106369:         base -= ph.p_vaddr;
114869:       }
114869:       if (ph.p_type == PT_DYNAMIC) {
106369:         dyn_addr = ph.p_vaddr;
106369:       }
114869:     }
106369:     if (!dyn_addr)
106369:       return false;
106369: 
106369:     ElfW(Dyn) *dynamic = reinterpret_cast<ElfW(Dyn) *>(dyn_addr + base);
106369: 
106369:     // The dynamic linker makes information available that helps gdb find all
106369:     // DSOs loaded into the program. If this information is indeed available,
106369:     // dump it to a MD_LINUX_DSO_DEBUG stream.
106369:     struct r_debug* r_debug = NULL;
106369:     uint32_t dynamic_length = 0;
106369: 
106369:     for (int i = 0;;) {
106369:       ElfW(Dyn) dyn;
106369:       dynamic_length += sizeof(dyn);
118328:       dumper_->CopyFromProcess(&dyn, GetCrashThread(), dynamic+i++,
118328:                                sizeof(dyn));
106369:       if (dyn.d_tag == DT_DEBUG) {
106369:         r_debug = reinterpret_cast<struct r_debug*>(dyn.d_un.d_ptr);
106369:         continue;
106369:       } else if (dyn.d_tag == DT_NULL) {
106369:         break;
106369:       }
106369:     }
106369: 
106369:     // The "r_map" field of that r_debug struct contains a linked list of all
106369:     // loaded DSOs.
 50677:     // Our list of DSOs potentially is different from the ones in the crashing
 50677:     // process. So, we have to be careful to never dereference pointers
 50677:     // directly. Instead, we use CopyFromProcess() everywhere.
 50677:     // See <link.h> for a more detailed discussion of the how the dynamic
 50677:     // loader communicates with debuggers.
 50677: 
 50677:     // Count the number of loaded DSOs
 50677:     int dso_count = 0;
 50677:     struct r_debug debug_entry;
114869:     dumper_->CopyFromProcess(&debug_entry, GetCrashThread(), r_debug,
 50677:                              sizeof(debug_entry));
 50677:     for (struct link_map* ptr = debug_entry.r_map; ptr; ) {
 50677:       struct link_map map;
114869:       dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map));
 50677:       ptr = map.l_next;
 50677:       dso_count++;
 50677:     }
 50677: 
 50677:     MDRVA linkmap_rva = minidump_writer_.kInvalidMDRVA;
 50677:     if (dso_count > 0) {
 50677:       // If we have at least one DSO, create an array of MDRawLinkMap
 50677:       // entries in the minidump file.
 50677:       TypedMDRVA<MDRawLinkMap> linkmap(&minidump_writer_);
 50677:       if (!linkmap.AllocateArray(dso_count))
 50677:         return false;
 50677:       linkmap_rva = linkmap.location().rva;
 50677:       int idx = 0;
 50677: 
 50677:       // Iterate over DSOs and write their information to mini dump
 50677:       for (struct link_map* ptr = debug_entry.r_map; ptr; ) {
 50677:         struct link_map map;
114869:         dumper_->CopyFromProcess(&map, GetCrashThread(), ptr, sizeof(map));
 50677:         ptr = map.l_next;
 50677:         char filename[257] = { 0 };
 50677:         if (map.l_name) {
114869:           dumper_->CopyFromProcess(filename, GetCrashThread(), map.l_name,
 50677:                                    sizeof(filename) - 1);
 50677:         }
 50677:         MDLocationDescriptor location;
 50677:         if (!minidump_writer_.WriteString(filename, 0, &location))
 50677:           return false;
 50677:         MDRawLinkMap entry;
 50677:         entry.name = location.rva;
 50677:         entry.addr = (void*)map.l_addr;
 50677:         entry.ld = (void*)map.l_ld;
 50677:         linkmap.CopyIndex(idx++, &entry);
 50677:       }
 50677:     }
 50677: 
 50677:     // Write MD_LINUX_DSO_DEBUG record
 50677:     TypedMDRVA<MDRawDebug> debug(&minidump_writer_);
 50677:     if (!debug.AllocateObjectAndArray(1, dynamic_length))
 50677:       return false;
 50677:     my_memset(debug.get(), 0, sizeof(MDRawDebug));
 50677:     dirent->stream_type = MD_LINUX_DSO_DEBUG;
 50677:     dirent->location = debug.location();
 50677: 
 50677:     debug.get()->version = debug_entry.r_version;
 50677:     debug.get()->map = linkmap_rva;
 50677:     debug.get()->dso_count = dso_count;
 50677:     debug.get()->brk = (void*)debug_entry.r_brk;
 50677:     debug.get()->ldbase = (void*)debug_entry.r_ldbase;
106369:     debug.get()->dynamic = dynamic;
 50677: 
 50677:     char* dso_debug_data = new char[dynamic_length];
114869:     dumper_->CopyFromProcess(dso_debug_data, GetCrashThread(), dynamic,
 50677:                              dynamic_length);
 50677:     debug.CopyIndexAfterObject(0, dso_debug_data, dynamic_length);
 50677:     delete[] dso_debug_data;
 50677: 
 50677:     return true;
114869: #endif
 50677:   }
 50677: 
 36832:  private:
114869:   void* Alloc(unsigned bytes) {
114869:     return dumper_->allocator()->Alloc(bytes);
114869:   }
114869: 
114869:   pid_t GetCrashThread() const {
114869:     return dumper_->crash_thread();
114869:   }
114869: 
 54618: #if defined(__i386)
114869:   uintptr_t GetStackPointer() {
114869:     return ucontext_->uc_mcontext.gregs[REG_ESP];
114869:   }
114869: 
 54618:   uintptr_t GetInstructionPointer() {
 54618:     return ucontext_->uc_mcontext.gregs[REG_EIP];
 54618:   }
114869: 
114869:   uintptr_t GetInstructionPointer(const ThreadInfo& info) {
114869:     return info.regs.eip;
114869:   }
 54618: #elif defined(__x86_64)
114869:   uintptr_t GetStackPointer() {
114869:     return ucontext_->uc_mcontext.gregs[REG_RSP];
114869:   }
114869: 
 54618:   uintptr_t GetInstructionPointer() {
 54618:     return ucontext_->uc_mcontext.gregs[REG_RIP];
 54618:   }
114869: 
114869:   uintptr_t GetInstructionPointer(const ThreadInfo& info) {
114869:     return info.regs.rip;
114869:   }
 54618: #elif defined(__ARM_EABI__)
114869:   uintptr_t GetStackPointer() {
114869:     return ucontext_->uc_mcontext.arm_sp;
114869:   }
114869: 
 54618:   uintptr_t GetInstructionPointer() {
114869:     return ucontext_->uc_mcontext.arm_pc;
114869:   }
114869: 
114869:   uintptr_t GetInstructionPointer(const ThreadInfo& info) {
114869:     return info.regs.uregs[15];
 54618:   }
 54618: #else
 54618: #error "This code has not been ported to your platform yet."
 54618: #endif
 54618: 
 36832:   void NullifyDirectoryEntry(MDRawDirectory* dirent) {
 36832:     dirent->stream_type = 0;
 36832:     dirent->location.data_size = 0;
 36832:     dirent->location.rva = 0;
 36832:   }
 36832: 
 36832:   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
 36832:     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
 36832:     static const char vendor_id_name[] = "vendor_id";
 36832:     static const size_t vendor_id_name_length = sizeof(vendor_id_name) - 1;
 36832: 
 36832:     struct CpuInfoEntry {
 36832:       const char* info_name;
 36832:       int value;
 36832:       bool found;
 36832:     } cpu_info_table[] = {
 36832:       { "processor", -1, false },
 36832:       { "model", 0, false },
 36832:       { "stepping",  0, false },
 36832:       { "cpu family", 0, false },
 36832:     };
 36832: 
 36832:     // processor_architecture should always be set, do this first
 36832:     sys_info->processor_architecture =
 36832: #if defined(__i386)
 36832:         MD_CPU_ARCHITECTURE_X86;
 36832: #elif defined(__x86_64)
 36832:         MD_CPU_ARCHITECTURE_AMD64;
 39657: #elif defined(__arm__)
 39657:         MD_CPU_ARCHITECTURE_ARM;
 36832: #else
 36832: #error "Unknown CPU arch"
 36832: #endif
 36832: 
 36832:     const int fd = sys_open("/proc/cpuinfo", O_RDONLY, 0);
 36832:     if (fd < 0)
 36832:       return false;
 36832: 
 36832:     {
 36832:       PageAllocator allocator;
 36832:       LineReader* const line_reader = new(allocator) LineReader(fd);
 36832:       const char* line;
 36832:       unsigned line_len;
 36832:       while (line_reader->GetNextLine(&line, &line_len)) {
 36832:         for (size_t i = 0;
 36832:              i < sizeof(cpu_info_table) / sizeof(cpu_info_table[0]);
 36832:              i++) {
 36832:           CpuInfoEntry* entry = &cpu_info_table[i];
 50677:           if (entry->found && i)
 36832:             continue;
114869:           if (!my_strncmp(line, entry->info_name, strlen(entry->info_name))) {
114869:             const char* value = my_strchr(line, ':');
 36832:             if (!value)
 36832:               continue;
 36832: 
 36832:             // the above strncmp only matches the prefix, it might be the wrong
 36832:             // line. i.e. we matched "model name" instead of "model".
 36832:             // check and make sure there is only spaces between the prefix and
 36832:             // the colon.
114869:             const char* space_ptr = line + my_strlen(entry->info_name);
 36832:             for (; space_ptr < value; space_ptr++) {
114869:               if (!my_isspace(*space_ptr)) {
 36832:                 break;
 36832:               }
 36832:             }
 36832:             if (space_ptr != value)
 36832:               continue;
 36832: 
118328:             // skip past the colon and all the spaces that follow
118328:             do {
118328:               value++;
118328:             } while (my_isspace(*value));
118328: 
114869:             uintptr_t val;
118328:             if (my_read_decimal_ptr(&val, value) == value)
118328:               continue;
114869:             entry->value = static_cast<int>(val);
 36832:             entry->found = true;
 36832:           }
 36832:         }
 36832: 
 36832:         // special case for vendor_id
114869:         if (!my_strncmp(line, vendor_id_name, vendor_id_name_length)) {
114869:           const char* value = my_strchr(line, ':');
 36832:           if (!value)
 36832:             goto popline;
 36832: 
118328:           // skip past the colon and all the spaces that follow
 36832:           do {
 36832:             value++;
114869:           } while (my_isspace(*value));
 36832: 
 36832:           if (*value) {
114869:             size_t length = my_strlen(value);
 36832:             if (length == 0)
 36832:               goto popline;
 36832:             // we don't want the trailing newline
 36832:             if (value[length - 1] == '\n')
 36832:               length--;
 36832:             // ensure we have space for the value
 36832:             if (length < sizeof(vendor_id))
114869:               my_strlcpy(vendor_id, value, length);
 36832:           }
 36832:         }
 36832: 
 36832:  popline:
 36832:         line_reader->PopLine(line_len);
 36832:       }
 36832:       sys_close(fd);
 36832:     }
 36832: 
 36832:     // make sure we got everything we wanted
 36832:     for (size_t i = 0;
 36832:          i < sizeof(cpu_info_table) / sizeof(cpu_info_table[0]);
 36832:          i++) {
 36832:       if (!cpu_info_table[i].found) {
 36832:         return false;
 36832:       }
 36832:     }
 36832:     // /proc/cpuinfo contains cpu id, change it into number by adding one.
 36832:     cpu_info_table[0].value++;
 36832: 
 36832:     sys_info->number_of_processors = cpu_info_table[0].value;
 36832:     sys_info->processor_level      = cpu_info_table[3].value;
 36832:     sys_info->processor_revision   = cpu_info_table[1].value << 8 |
 36832:                                      cpu_info_table[2].value;
 36832: 
 36832:     if (vendor_id[0] != '\0') {
114869:       my_memcpy(sys_info->cpu.x86_cpu_info.vendor_id, vendor_id,
 36832:                 sizeof(sys_info->cpu.x86_cpu_info.vendor_id));
 36832:     }
 36832:     return true;
 36832:   }
 36832: 
 36832:   bool WriteFile(MDLocationDescriptor* result, const char* filename) {
 36832:     const int fd = sys_open(filename, O_RDONLY, 0);
 36832:     if (fd < 0)
 36832:       return false;
 36832: 
 36832:     // We can't stat the files because several of the files that we want to
 36832:     // read are kernel seqfiles, which always have a length of zero. So we have
 36832:     // to read as much as we can into a buffer.
 50677:     static const unsigned kBufSize = 1024 - 2*sizeof(void*);
 50677:     struct Buffers {
114869:       Buffers* next;
 50677:       size_t len;
 50677:       uint8_t data[kBufSize];
114869:     } *buffers = reinterpret_cast<Buffers*>(Alloc(sizeof(Buffers)));
 50677:     buffers->next = NULL;
 50677:     buffers->len = 0;
 36832: 
 50677:     size_t total = 0;
114869:     for (Buffers* bufptr = buffers;;) {
 36832:       ssize_t r;
 36832:       do {
 50677:         r = sys_read(fd, &bufptr->data[bufptr->len], kBufSize - bufptr->len);
 36832:       } while (r == -1 && errno == EINTR);
 36832: 
 36832:       if (r < 1)
 36832:         break;
 50677: 
 50677:       total += r;
 50677:       bufptr->len += r;
 50677:       if (bufptr->len == kBufSize) {
114869:         bufptr->next = reinterpret_cast<Buffers*>(Alloc(sizeof(Buffers)));
 50677:         bufptr = bufptr->next;
 50677:         bufptr->next = NULL;
 50677:         bufptr->len = 0;
 50677:       }
 36832:     }
 36832:     sys_close(fd);
 36832: 
 50677:     if (!total)
 36832:       return false;
 36832: 
 36832:     UntypedMDRVA memory(&minidump_writer_);
 50677:     if (!memory.Allocate(total))
 36832:       return false;
 50677:     for (MDRVA pos = memory.position(); buffers; buffers = buffers->next) {
105693:       // Check for special case of a zero-length buffer.  This should only
105693:       // occur if a file's size happens to be a multiple of the buffer's
105693:       // size, in which case the final sys_read() will have resulted in
105693:       // zero bytes being read after the final buffer was just allocated.
105693:       if (buffers->len == 0) {
105693:         // This can only occur with final buffer.
105693:         assert(buffers->next == NULL);
105693:         continue;
105693:       }
 50677:       memory.Copy(pos, &buffers->data, buffers->len);
 50677:       pos += buffers->len;
 50677:     }
 36832:     *result = memory.location();
 36832:     return true;
 36832:   }
 36832: 
 36832:   bool WriteOSInformation(MDRawSystemInfo* sys_info) {
114869: #if defined(__ANDROID__)
114869:     sys_info->platform_id = MD_OS_ANDROID;
114869: #else
 36832:     sys_info->platform_id = MD_OS_LINUX;
114869: #endif
 36832: 
 36832:     struct utsname uts;
 36832:     if (uname(&uts))
 36832:       return false;
 36832: 
 36832:     static const size_t buf_len = 512;
 36832:     char buf[buf_len] = {0};
 36832:     size_t space_left = buf_len - 1;
 36832:     const char* info_table[] = {
 36832:       uts.sysname,
 36832:       uts.release,
 36832:       uts.version,
 36832:       uts.machine,
 36832:       NULL
 36832:     };
 36832:     bool first_item = true;
 36832:     for (const char** cur_info = info_table; *cur_info; cur_info++) {
114869:       static const char separator[] = " ";
114869:       size_t separator_len = sizeof(separator) - 1;
114869:       size_t info_len = my_strlen(*cur_info);
 36832:       if (info_len == 0)
 36832:         continue;
 36832: 
 36832:       if (space_left < info_len + (first_item ? 0 : separator_len))
 36832:         break;
 36832: 
 36832:       if (!first_item) {
114869:         my_strlcat(buf, separator, sizeof(buf));
 36832:         space_left -= separator_len;
 36832:       }
 36832: 
 36832:       first_item = false;
114869:       my_strlcat(buf, *cur_info, sizeof(buf));
 36832:       space_left -= info_len;
 36832:     }
 36832: 
114869: #ifdef __ANDROID__
114869:     // On Android, try to get the build fingerprint and append it.
114869:     // Fail gracefully because there is no guarantee that the system
114869:     // property will always be available or accessible.
114869:     char fingerprint[PROP_VALUE_MAX];
114869:     int fingerprint_len = __system_property_get("ro.build.fingerprint",
114869:                                                 fingerprint);
114869:     // System property values shall always be zero-terminated.
114869:     // Be paranoid and don't trust the system.
114869:     if (fingerprint_len > 0 && fingerprint_len < PROP_VALUE_MAX) {
114869:       const char* separator = " ";
114869:       if (!first_item)
114869:         my_strlcat(buf, separator, sizeof(buf));
114869:       my_strlcat(buf, fingerprint, sizeof(buf));
114869:     }
114869: #endif
114869: 
 36832:     MDLocationDescriptor location;
 36832:     if (!minidump_writer_.WriteString(buf, 0, &location))
 36832:       return false;
 36832:     sys_info->csd_version_rva = location.rva;
 36832: 
 36832:     return true;
 36832:   }
 36832: 
 36832:   bool WriteProcFile(MDLocationDescriptor* result, pid_t pid,
 36832:                      const char* filename) {
114869:     char buf[NAME_MAX];
114869:     if (!dumper_->BuildProcPath(buf, pid, filename))
114869:       return false;
 36832:     return WriteFile(result, buf);
 36832:   }
 36832: 
114869:   // Only one of the 2 member variables below should be set to a valid value.
114869:   const int fd_;  // File descriptor where the minidum should be written.
114869:   const char* path_;  // Path to the file where the minidum should be written.
114869: 
 36832:   const struct ucontext* const ucontext_;  // also from the signal handler
 36832:   const struct _libc_fpstate* const float_state_;  // ditto
114869:   LinuxDumper* dumper_;
 36832:   MinidumpFileWriter minidump_writer_;
 36832:   MDLocationDescriptor crashing_thread_context_;
 54618:   // Blocks of memory written to the dump. These are all currently
 54618:   // written while writing the thread list stream, but saved here
 54618:   // so a memory list stream can be written afterwards.
 54618:   wasteful_vector<MDMemoryDescriptor> memory_blocks_;
 56283:   // Additional information about some mappings provided by the caller.
114869:   const MappingList& mapping_list_;
114869:   // Additional memory regions to be included in the dump,
114869:   // provided by the caller.
114869:   const AppMemoryList& app_memory_list_;
 36832: };
 36832: 
 56283: 
114869: bool WriteMinidumpImpl(const char* minidump_path,
114869:                        int minidump_fd,
114869:                        pid_t crashing_process,
 56283:                        const void* blob, size_t blob_size,
 73558:                        const MappingList& mappings,
 73558:                        const AppMemoryList& appmem) {
 36832:   if (blob_size != sizeof(ExceptionHandler::CrashContext))
 36832:     return false;
 36832:   const ExceptionHandler::CrashContext* context =
 36832:       reinterpret_cast<const ExceptionHandler::CrashContext*>(blob);
114869:   LinuxPtraceDumper dumper(crashing_process);
114869:   dumper.set_crash_address(
114869:       reinterpret_cast<uintptr_t>(context->siginfo.si_addr));
114869:   dumper.set_crash_signal(context->siginfo.si_signo);
114869:   dumper.set_crash_thread(context->tid);
114869:   MinidumpWriter writer(minidump_path, minidump_fd, context, mappings,
114869:                         appmem, &dumper);
 36832:   if (!writer.Init())
 36832:     return false;
 36832:   return writer.Dump();
 36832: }
 36832: 
114869: }  // namespace
114869: 
114869: namespace google_breakpad {
114869: 
114869: bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
114869:                    const void* blob, size_t blob_size) {
114869:   return WriteMinidumpImpl(minidump_path, -1, crashing_process, blob, blob_size,
114869:                            MappingList(), AppMemoryList());
114869: }
114869: 
114869: bool WriteMinidump(int minidump_fd, pid_t crashing_process,
114869:                    const void* blob, size_t blob_size) {
114869:   return WriteMinidumpImpl(NULL, minidump_fd, crashing_process, blob, blob_size,
114869:                            MappingList(), AppMemoryList());
114869: }
114869: 
114869: bool WriteMinidump(const char* minidump_path, pid_t process,
 40023:                    pid_t process_blamed_thread) {
114869:   LinuxPtraceDumper dumper(process);
114869:   // MinidumpWriter will set crash address
114869:   dumper.set_crash_signal(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED);
114869:   dumper.set_crash_thread(process_blamed_thread);
114869:   MinidumpWriter writer(minidump_path, -1, NULL, MappingList(),
114869:                         AppMemoryList(), &dumper);
114869:   if (!writer.Init())
114869:     return false;
114869:   return writer.Dump();
114869: }
114869: 
114869: bool WriteMinidump(const char* minidump_path, pid_t crashing_process,
114869:                    const void* blob, size_t blob_size,
114869:                    const MappingList& mappings,
114869:                    const AppMemoryList& appmem) {
114869:   return WriteMinidumpImpl(minidump_path, -1, crashing_process, blob, blob_size,
114869:                            mappings, appmem);
114869: }
114869: 
114869: bool WriteMinidump(int minidump_fd, pid_t crashing_process,
114869:                    const void* blob, size_t blob_size,
114869:                    const MappingList& mappings,
114869:                    const AppMemoryList& appmem) {
114869:   return WriteMinidumpImpl(NULL, minidump_fd, crashing_process, blob, blob_size,
114869:                            mappings, appmem);
114869: }
114869: 
114869: bool WriteMinidump(const char* filename,
114869:                    const MappingList& mappings,
114869:                    const AppMemoryList& appmem,
114869:                    LinuxDumper* dumper) {
114869:   MinidumpWriter writer(filename, -1, NULL, mappings, appmem, dumper);
 39789:   if (!writer.Init())
 39789:     return false;
 39789:   return writer.Dump();
 39789: }
 39789: 
 36832: }  // namespace google_breakpad
