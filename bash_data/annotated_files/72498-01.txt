69884: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
69884: /* ***** BEGIN LICENSE BLOCK *****
69884:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69884:  *
69884:  * The contents of this file are subject to the Mozilla Public License Version
69884:  * 1.1 (the "License"); you may not use this file except in compliance with
69884:  * the License. You may obtain a copy of the License at
69884:  * http://www.mozilla.org/MPL/
69884:  *
69884:  * Software distributed under the License is distributed on an "AS IS" basis,
69884:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69884:  * for the specific language governing rights and limitations under the
69884:  * License.
69884:  *
69884:  * The Original Code is Mozilla.
69884:  *
69884:  * The Initial Developer of the Original Code is
69884:  * Mozilla Foundation.
69884:  * Portions created by the Initial Developer are Copyright (C) 2010 2011
69884:  * the Initial Developer. All Rights Reserved.
69884:  *
69884:  * Contributor(s):
69884:  *   Patrick McManus <mcmanus@ducksong.com>
69884:  *
69884:  * Alternatively, the contents of this file may be used under the terms of
69884:  * either of the GNU General Public License Version 2 or later (the "GPL"),
69884:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69884:  * in which case the provisions of the GPL or the LGPL are applicable instead
69884:  * of those above. If you wish to allow use of your version of this file only
69884:  * under the terms of either the GPL or the LGPL, and not to allow others to
69884:  * use your version of this file under the terms of the MPL, indicate your
69884:  * decision by deleting the provisions above and replace them with the notice
69884:  * and other provisions required by the GPL or the LGPL. If you do not delete
69884:  * the provisions above, a recipient may use your version of this file under
69884:  * the terms of any one of the MPL, the GPL or the LGPL.
69884:  *
69884:  * ***** END LICENSE BLOCK ***** */
69884: 
69884: #include "nsPreloadedStream.h"
69884: #include "nsIRunnable.h"
69884: 
69884: #include "nsThreadUtils.h"
69884: #include "nsAlgorithm.h"
69884: #include "prmem.h"
69884:    
69884: namespace mozilla {
69884: namespace net {
69884: 
69884: NS_IMPL_THREADSAFE_ISUPPORTS2(nsPreloadedStream,
69884:                               nsIInputStream,
69884:                               nsIAsyncInputStream)
69884: 
69884: nsPreloadedStream::nsPreloadedStream(nsIAsyncInputStream *aStream,
69884:                                      const char *data, PRUint32 datalen)
69884:     : mStream(aStream),
69884:       mOffset(0),
69884:       mLen(datalen)
69884: {
69884:     mBuf = (char *) moz_xmalloc(datalen);
69884:     memcpy(mBuf, data, datalen);
69884: }
69884: 
69884: nsPreloadedStream::~nsPreloadedStream()
69884: {
69884:     moz_free(mBuf);
69884: }
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::Close()
69884: {
69884:     mLen = 0;
69884:     return mStream->Close();
69884: }
69884: 
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::Available(PRUint32 *_retval NS_OUTPARAM)
69884: {
69884:     PRUint32 avail = 0;
69884:     
69884:     nsresult rv = mStream->Available(&avail);
69884:     if (NS_FAILED(rv))
69884:         return rv;
69884:     *_retval = avail + mLen;
69884:     return NS_OK;
69884: }
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::Read(char *aBuf, PRUint32 aCount,
69884:                         PRUint32 *_retval NS_OUTPARAM)
69884: {
69884:     if (!mLen)
69884:         return mStream->Read(aBuf, aCount, _retval);
69884:     
69884:     PRUint32 toRead = NS_MIN(mLen, aCount);
69884:     memcpy(aBuf, mBuf + mOffset, toRead);
69884:     mOffset += toRead;
69884:     mLen -= toRead;
69884:     *_retval = toRead;
69884:     return NS_OK;
69884: }
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::ReadSegments(nsWriteSegmentFun aWriter,
69884:                                 void *aClosure, PRUint32 aCount,
69884:                                 PRUint32 *result)
69884: {
69884:     if (!mLen)
69884:         return mStream->ReadSegments(aWriter, aClosure, aCount, result);
69884: 
69884:     *result = 0;
69884:     while (mLen > 0 && aCount > 0) {
69884:         PRUint32 toRead = NS_MIN(mLen, aCount);
69884:         PRUint32 didRead = 0;
69884:         nsresult rv;
69884: 
69884:         rv = aWriter(this, aClosure, mBuf + mOffset, *result, toRead, &didRead);
69884: 
69884:         if (NS_FAILED(rv))
69884:             return NS_OK;
69884: 
69884:         *result += didRead;
69884:         mOffset += didRead;
69884:         mLen -= didRead;
69884:         aCount -= didRead;
69884:     }
69884: 
69884:     return NS_OK;
69884: }
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::IsNonBlocking(PRBool *_retval NS_OUTPARAM)
69884: {
69884:     return mStream->IsNonBlocking(_retval);
69884: }
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::CloseWithStatus(nsresult aStatus)
69884: {
69884:     mLen = 0;
69884:     return mStream->CloseWithStatus(aStatus);
69884: }
69884: 
69884: class RunOnThread : public nsRunnable
69884: {
69884: public:
69884:     RunOnThread(nsIAsyncInputStream *aStream,
69884:                 nsIInputStreamCallback *aCallback)
69884:       : mStream(aStream),
69884:         mCallback(aCallback) {}
69884:     
69884:     virtual ~RunOnThread() {}
69884:     
69884:     NS_IMETHOD Run()
69884:     {
69884:         mCallback->OnInputStreamReady(mStream);
69884:         return NS_OK;
69884:     }
69884: 
69884: private:
69884:     nsCOMPtr<nsIAsyncInputStream>    mStream;
69884:     nsCOMPtr<nsIInputStreamCallback> mCallback;
69884: };
69884: 
69884: NS_IMETHODIMP
69884: nsPreloadedStream::AsyncWait(nsIInputStreamCallback *aCallback,
69884:                              PRUint32 aFlags,
69884:                              PRUint32 aRequestedCount,
69884:                              nsIEventTarget *aEventTarget)
69884: {
69884:     if (!mLen)
69884:         return mStream->AsyncWait(aCallback, aFlags, aRequestedCount,
69884:                                   aEventTarget);
69884: 
72498:     if (!aCallback)
72498:         return NS_OK;
72498: 
69884:     if (!aEventTarget)
69884:         return aCallback->OnInputStreamReady(this);
69884: 
69884:     nsCOMPtr<nsIRunnable> event =
69884:         new RunOnThread(this, aCallback);
69884:     return aEventTarget->Dispatch(event, nsIEventTarget::DISPATCH_NORMAL);
69884: }
69884: 
69884: } // namespace net
69884: } // namespace mozilla
