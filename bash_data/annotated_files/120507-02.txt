     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: // vim:set ts=2 sts=2 sw=2 et cin:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* rendering objects for replaced elements implemented by a plugin */
     1: 
 50668: #include "mozilla/plugins/PluginMessageUtils.h"
 50668: 
     1: #include "nscore.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsIView.h"
     1: #include "nsIViewManager.h"
 75045: #include "nsIDOMEventListener.h"
 20592: #include "nsIDOMDragEvent.h"
 69092: #include "nsPluginHost.h"
     1: #include "nsString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsGkAtoms.h"
     4: #include "nsIAppShell.h"
     1: #include "nsIDocument.h"
 94340: #include "nsINodeInfo.h"
     1: #include "nsIURL.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIPluginInstanceOwner.h"
 67677: #include "nsNPAPIPluginInstance.h"
 29840: #include "nsIPluginTagInfo.h"
     1: #include "plstr.h"
     1: #include "nsILinkHandler.h"
     1: #include "nsIScrollPositionListener.h"
     1: #include "nsITimer.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeOwner.h"
     1: #include "nsDocShellCID.h"
     1: #include "nsIWebBrowserChrome.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIDOMHTMLObjectElement.h"
     1: #include "nsIDOMHTMLEmbedElement.h"
     1: #include "nsIDOMHTMLAppletElement.h"
     1: #include "nsIDOMWindow.h"
  1418: #include "nsIDOMEventTarget.h"
     1: #include "nsIDocumentEncoder.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsIDOMRange.h"
     1: #include "nsIPluginWidget.h"
     1: #include "nsGUIEvent.h"
 68481: #include "nsRenderingContext.h"
     1: #include "npapi.h"
     1: #include "nsTransform2D.h"
     1: #include "nsIImageLoadingContent.h"
     1: #include "nsIObjectLoadingContent.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsContentUtils.h"
     1: #include "nsDisplayList.h"
     1: #include "nsAttrName.h"
     1: #include "nsDataHashtable.h"
 13098: #include "nsDOMClassInfo.h"
 29018: #include "nsFocusManager.h"
 30519: #include "nsLayoutUtils.h"
 30522: #include "nsFrameManager.h"
 30522: #include "nsComponentManagerUtils.h"
 35180: #include "nsIObserverService.h"
 37067: #include "nsIScrollableFrame.h"
 70842: #include "mozilla/Preferences.h"
 87692: #include "sampler.h"
     1: 
     1: // headers for plugin scriptability
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIXPCScriptable.h"
     1: #include "nsIClassInfo.h"
 35171: #include "nsIDOMClientRect.h"
     1: 
     1: #include "nsObjectFrame.h"
     1: #include "nsIObjectFrame.h"
     1: #include "nsPluginNativeWindow.h"
     1: #include "nsIPluginDocument.h"
 62646: #include "FrameLayerBuilder.h"
     1: 
  4577: #include "nsThreadUtils.h"
  4577: 
     1: #include "gfxContext.h"
 54223: #include "gfxPlatform.h"
108747: #include "ImageLayers.h"
     1: 
 11703: #ifdef XP_WIN
 11703: #include "gfxWindowsNativeDrawing.h"
 21080: #include "gfxWindowsSurface.h"
 11703: #endif
 11703: 
 34217: #include "gfxImageSurface.h"
 54223: #include "gfxUtils.h"
 54223: #include "Layers.h"
 62699: #include "ReadbackLayer.h"
 34217: 
     1: // accessibility support
     1: #ifdef ACCESSIBILITY
 61464: #include "nsAccessibilityService.h"
     1: #endif
     1: 
     1: #ifdef MOZ_LOGGING
     1: #define FORCE_PR_LOG 1 /* Allow logging in the release build */
     1: #endif /* MOZ_LOGGING */
     1: #include "prlog.h"
     1: 
     1: #include <errno.h>
     1: 
     1: #include "nsContentCID.h"
 13537: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
     1: 
 11944: #ifdef XP_MACOSX
 11944: #include "gfxQuartzNativeDrawing.h"
 32019: #include "nsPluginUtilsOSX.h"
106985: #include "mozilla/gfx/QuartzSupport.h"
 11944: #endif
 11944: 
  3059: #ifdef MOZ_WIDGET_GTK2
 23281: #include <gdk/gdk.h>
  3059: #include <gdk/gdkx.h>
 25500: #include <gtk/gtk.h>
 47118: #include "gfxXlibNativeRenderer.h"
  3059: #endif
     1: 
 41059: #ifdef MOZ_X11
 43912: #include "mozilla/X11Util.h"
 43912: using mozilla::DefaultXDisplay;
 16959: #endif
 16959: 
     1: #ifdef XP_WIN
     1: #include <wtypes.h>
     1: #include <winuser.h>
     1: #endif
     1: 
 32955: #ifdef XP_OS2
 32955: #define INCL_PM
 32955: #define INCL_GPI
 32955: #include <os2.h>
 68865: #include "gfxOS2Surface.h"
 32955: #endif
 32955: 
106178: #ifdef MOZ_WIDGET_ANDROID
106178: #include "AndroidBridge.h"
106178: #include "GLContext.h"
106178: #endif
106178: 
     1: #ifdef CreateEvent // Thank you MS.
     1: #undef CreateEvent
     1: #endif
     1: 
     1: #ifdef PR_LOGGING 
120415: static PRLogModuleInfo *
120415: GetObjectFrameLog()
120415: {
120415:   static PRLogModuleInfo *sLog;
120415:   if (!sLog)
120415:     sLog = PR_NewLogModule("nsObjectFrame");
120415:   return sLog;
120415: }
     1: #endif /* PR_LOGGING */
     1: 
118918: #if defined(XP_MACOSX) && !defined(__LP64__)
 71609: 
 71609: // The header files QuickdrawAPI.h and QDOffscreen.h are missing on OS X 10.7
 71609: // and up (though the QuickDraw APIs defined in them are still present) -- so
 71609: // we need to supply the relevant parts of their contents here.  It's likely
 71609: // that Apple will eventually remove the APIs themselves (probably in OS X
 71609: // 10.8), so we need to make them weak imports, and test for their presence
 71609: // before using them.
 71609: extern "C" {
 71609:   #if !defined(__QUICKDRAWAPI__)
 71609:   extern void SetRect(
 71609:     Rect * r,
 71609:     short  left,
 71609:     short  top,
 71609:     short  right,
 71609:     short  bottom)
 71609:     __attribute__((weak_import));
 71609:   #endif /* __QUICKDRAWAPI__ */
 71609: 
 71609:   #if !defined(__QDOFFSCREEN__)
 71609:   extern QDErr NewGWorldFromPtr(
 71609:     GWorldPtr *   offscreenGWorld,
 71609:     UInt32        PixelFormat,
 71609:     const Rect *  boundsRect,
 71609:     CTabHandle    cTable,                /* can be NULL */
 71609:     GDHandle      aGDevice,              /* can be NULL */
 71609:     GWorldFlags   flags,
 71609:     Ptr           newBuffer,
 71609:     SInt32        rowBytes)
 71609:     __attribute__((weak_import));
 71609:   extern void DisposeGWorld(GWorldPtr offscreenGWorld)
 71609:     __attribute__((weak_import));
 71609:   #endif /* __QDOFFSCREEN__ */
 71609: }
 71609: 
118918: #endif /* #if defined(XP_MACOSX) && !defined(__LP64__) */
     1: 
 62699: using namespace mozilla;
 62699: using namespace mozilla::plugins;
 54223: using namespace mozilla::layers;
 54223: 
 62699: class PluginBackgroundSink : public ReadbackSink {
 62699: public:
108991:   PluginBackgroundSink(nsObjectFrame* aFrame, uint64_t aStartSequenceNumber)
 62699:     : mLastSequenceNumber(aStartSequenceNumber), mFrame(aFrame) {}
 62699:   ~PluginBackgroundSink()
 62699:   {
 62699:     if (mFrame) {
106838:       mFrame->mBackgroundSink = nullptr;
 62699:     }
 62699:   }
 62699: 
108991:   virtual void SetUnknown(uint64_t aSequenceNumber)
 62699:   {
 62699:     if (!AcceptUpdate(aSequenceNumber))
 62699:       return;
 62699:     mFrame->mInstanceOwner->SetBackgroundUnknown();
 62699:   }
 62699: 
 62699:   virtual already_AddRefed<gfxContext>
108991:       BeginUpdate(const nsIntRect& aRect, uint64_t aSequenceNumber)
 62699:   {
 62699:     if (!AcceptUpdate(aSequenceNumber))
106838:       return nullptr;
 62699:     return mFrame->mInstanceOwner->BeginUpdateBackground(aRect);
 62699:   }
 62699: 
 62699:   virtual void EndUpdate(gfxContext* aContext, const nsIntRect& aRect)
 62699:   {
 62699:     return mFrame->mInstanceOwner->EndUpdateBackground(aContext, aRect);
 62699:   }
 62699: 
106838:   void Destroy() { mFrame = nullptr; }
 62699: 
 62699: protected:
108991:   bool AcceptUpdate(uint64_t aSequenceNumber) {
 62699:     if (aSequenceNumber > mLastSequenceNumber && mFrame &&
 62699:         mFrame->mInstanceOwner) {
 62699:       mLastSequenceNumber = aSequenceNumber;
 79618:       return true;
 62699:     }
 79618:     return false;
 62699:   }
 62699: 
108991:   uint64_t mLastSequenceNumber;
 62699:   nsObjectFrame* mFrame;
 62699: };
 62699: 
 12417: nsObjectFrame::nsObjectFrame(nsStyleContext* aContext)
 12417:   : nsObjectFrameSuper(aContext)
 79618:   , mReflowCallbackPosted(false)
 12417: {
120415:   PR_LOG(GetObjectFrameLog(), PR_LOG_DEBUG,
 12417:          ("Created new nsObjectFrame %p\n", this));
 12417: }
 12417: 
     1: nsObjectFrame::~nsObjectFrame()
     1: {
120415:   PR_LOG(GetObjectFrameLog(), PR_LOG_DEBUG,
 12417:          ("nsObjectFrame %p deleted\n", this));
     1: }
     1: 
 23554: NS_QUERYFRAME_HEAD(nsObjectFrame)
118929:   NS_QUERYFRAME_ENTRY(nsObjectFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsIObjectFrame)
 23554: NS_QUERYFRAME_TAIL_INHERITING(nsObjectFrameSuper)
     1: 
     1: #ifdef ACCESSIBILITY
118929: a11y::AccType
118929: nsObjectFrame::AccessibleType()
     1: {
118929:   return a11y::eHTMLObjectFrameAccessible;
     1: }
     1: 
     1: #ifdef XP_WIN
     1: NS_IMETHODIMP nsObjectFrame::GetPluginPort(HWND *aPort)
     1: {
 37446:   *aPort = (HWND) mInstanceOwner->GetPluginPortFromWidget();
     1:   return NS_OK;
     1: }
     1: #endif
     1: #endif
     1: 
     1: NS_IMETHODIMP 
     1: nsObjectFrame::Init(nsIContent*      aContent,
     1:                     nsIFrame*        aParent,
     1:                     nsIFrame*        aPrevInFlow)
     1: {
120415:   PR_LOG(GetObjectFrameLog(), PR_LOG_DEBUG,
 12417:          ("Initializing nsObjectFrame %p for content %p\n", this, aContent));
 12417: 
 35180:   nsresult rv = nsObjectFrameSuper::Init(aContent, aParent, aPrevInFlow);
 35180: 
 35180:   return rv;
     1: }
     1: 
     1: void
 36647: nsObjectFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
 89512:   if (mReflowCallbackPosted) {
 89512:     PresContext()->PresShell()->CancelReflowCallback(this);
 89512:   }
 89512: 
 89114:   // Tell content owner of the instance to disconnect its frame.
 89114:   nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(mContent));
 89114:   NS_ASSERTION(objContent, "Why not an object loading content?");
 89114:   objContent->DisconnectFrame();
 30522: 
 62699:   if (mBackgroundSink) {
 62699:     mBackgroundSink->Destroy();
 62699:   }
 62699: 
 91723:   if (mInstanceOwner) {
106838:     mInstanceOwner->SetFrame(nullptr);
 91723:   }
106838:   SetInstanceOwner(nullptr);
 89114: 
 36647:   nsObjectFrameSuper::DestroyFrom(aDestructRoot);
     1: }
     1: 
 20441: /* virtual */ void
 20836: nsObjectFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
  7015: {
  7015:   if (HasView()) {
  7015:     nsIView* view = GetView();
  7015:     nsIViewManager* vm = view->GetViewManager();
  7015:     if (vm) {
  7015:       nsViewVisibility visibility = 
  7015:         IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow;
  7015:       vm->SetViewVisibility(view, visibility);
  7015:     }
  7015:   }
  7015: 
 20836:   nsObjectFrameSuper::DidSetStyleContext(aOldStyleContext);
  7015: }
  7015: 
     1: nsIAtom*
     1: nsObjectFrame::GetType() const
     1: {
     1:   return nsGkAtoms::objectFrame; 
     1: }
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsObjectFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("ObjectFrame"), aResult);
     1: }
     1: #endif
     1: 
     1: nsresult
 89114: nsObjectFrame::PrepForDrawing(nsIWidget *aWidget)
     1: {
 89114:   mWidget = aWidget;
 89114: 
     1:   nsIView* view = GetView();
     1:   NS_ASSERTION(view, "Object frames must have views");  
     1:   if (!view) {
 89114:     return NS_ERROR_FAILURE;
 62617:   }
 62617: 
     1:   nsIViewManager* viewMan = view->GetViewManager();
     1:   // mark the view as hidden since we don't know the (x,y) until Paint
     1:   // XXX is the above comment correct?
     1:   viewMan->SetViewVisibility(view, nsViewVisibility_kHide);
     1: 
     1:   //this is ugly. it was ripped off from didreflow(). MMP
     1:   // Position and size view relative to its parent, not relative to our
     1:   // parent frame (our parent frame may not have a view).
     1:   
     1:   nsIView* parentWithView;
     1:   nsPoint origin;
     1:   nsRect r(0, 0, mRect.width, mRect.height);
     1: 
     1:   GetOffsetFromView(origin, &parentWithView);
     1:   viewMan->ResizeView(view, r);
     1:   viewMan->MoveViewTo(view, origin.x, origin.y);
     1: 
118837:   nsPresContext* presContext = PresContext();
118837:   nsRootPresContext* rpc = presContext->GetRootPresContext();
 37615:   if (!rpc) {
 37615:     return NS_ERROR_FAILURE;
 37615:   }
 37615: 
 89114:   if (mWidget) {
118837:     // Disallow windowed plugins in popups
103762:     nsIFrame* rootFrame = rpc->PresShell()->FrameManager()->GetRootFrame();
103762:     nsIWidget* parentWidget = rootFrame->GetNearestWidget();
103762:     if (!parentWidget || nsLayoutUtils::GetDisplayRootFrame(this) != rootFrame) {
 59654:       return NS_ERROR_FAILURE;
 89114:     }
 59654: 
 68635:     mInnerView = viewMan->CreateView(GetContentRectRelativeToSelf(), view);
 33369:     if (!mInnerView) {
 33369:       NS_ERROR("Could not create inner view");
 33369:       return NS_ERROR_OUT_OF_MEMORY;
 33369:     }
106838:     viewMan->InsertChild(view, mInnerView, nullptr, true);
 33369: 
 89114:     mWidget->SetParent(parentWidget);
 89114:     mWidget->Show(true);
 89114:     mWidget->Enable(true);
 77476: 
118837:     // Set the plugin window to have an empty clip region until we know
118837:     // what our true position, size and clip region are. These
118837:     // will be reset when nsRootPresContext computes our true
118837:     // geometry. The plugin window does need to have a good size here, so
118837:     // set the size explicitly to a reasonable guess.
118837:     nsAutoTArray<nsIWidget::Configuration,1> configurations;
118837:     nsIWidget::Configuration* configuration = configurations.AppendElement();
118837:     nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
118837:     configuration->mChild = mWidget;
118837:     configuration->mBounds.width = NSAppUnitsToIntPixels(mRect.width, appUnitsPerDevPixel);
118837:     configuration->mBounds.height = NSAppUnitsToIntPixels(mRect.height, appUnitsPerDevPixel);
118837:     parentWidget->ConfigureChildren(configurations);
 89114: 
 89114:     nsRefPtr<nsDeviceContext> dx;
 89114:     viewMan->GetDeviceContext(*getter_AddRefs(dx));
108460:     mInnerView->AttachWidgetEventHandler(mWidget);
 77476: 
 42961: #ifdef XP_MACOSX
 42961:     // On Mac, we need to invalidate ourselves since even windowed
 42961:     // plugins are painted through Thebes and we need to ensure
 42961:     // the Thebes layer containing the plugin is updated.
 89114:     if (parentWidget == GetNearestWidget()) {
115305:       InvalidateFrame();
 89114:     }
 42961: #endif
 77476: 
108609:     RegisterPluginForGeometryUpdates();
 37615: 
     1:     // Here we set the background color for this widget because some plugins will use 
     1:     // the child window background color when painting. If it's not set, it may default to gray
     1:     // Sometimes, a frame doesn't have a background color or is transparent. In this
     1:     // case, walk up the frame tree until we do find a frame with a background color
     1:     for (nsIFrame* frame = this; frame; frame = frame->GetParent()) {
 40178:       nscolor bgcolor =
 40178:         frame->GetVisitedDependentColor(eCSSProperty_background_color);
 40178:       if (NS_GET_A(bgcolor) > 0) {  // make sure we got an actual color
 40178:         mWidget->SetBackgroundColor(bgcolor);
     1:         break;
     1:       }
     1:     }
 57224:   } else {
 89114:     // Changing to windowless mode changes the NPWindow geometry.
 89114:     FixupWindow(GetContentRectRelativeToSelf().Size());
 89114: 
 57224: #ifndef XP_MACOSX
108609:     RegisterPluginForGeometryUpdates();
 57224: #endif
     1:   }
     1: 
  7015:   if (!IsHidden()) {
     1:     viewMan->SetViewVisibility(view, nsViewVisibility_kShow);
  7015:   }
     1: 
 89114: #ifdef ACCESSIBILITY
 89114:   nsAccessibilityService* accService = nsIPresShell::AccService();
 89114:   if (accService) {
 89114:     accService->RecreateAccessible(PresContext()->PresShell(), mContent);
 89114:   }
 89114: #endif
 89114: 
 89114:   return NS_OK;
     1: }
     1: 
     1: #define EMBED_DEF_WIDTH 240
     1: #define EMBED_DEF_HEIGHT 200
     1: 
     1: /* virtual */ nscoord
 68481: nsObjectFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   nscoord result = 0;
     1: 
 79618:   if (!IsHidden(false)) {
     1:     nsIAtom *atom = mContent->Tag();
     1:     if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
     1:       result = nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH);
     1:     }
     1:   }
     1: 
     1:   DISPLAY_MIN_WIDTH(this, result);
     1:   return result;
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsObjectFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   return nsObjectFrame::GetMinWidth(aRenderingContext);
     1: }
     1: 
     1: void
     1: nsObjectFrame::GetDesiredSize(nsPresContext* aPresContext,
     1:                               const nsHTMLReflowState& aReflowState,
     1:                               nsHTMLReflowMetrics& aMetrics)
     1: {
     1:   // By default, we have no area
     1:   aMetrics.width = 0;
     1:   aMetrics.height = 0;
     1: 
 79618:   if (IsHidden(false)) {
     1:     return;
     1:   }
     1:   
     1:   aMetrics.width = aReflowState.ComputedWidth();
  4166:   aMetrics.height = aReflowState.ComputedHeight();
     1: 
     1:   // for EMBED and APPLET, default to 240x200 for compatibility
     1:   nsIAtom *atom = mContent->Tag();
     1:   if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
     1:     if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
 81029:       aMetrics.width = clamped(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH),
 81029:                                aReflowState.mComputedMinWidth,
     1:                                aReflowState.mComputedMaxWidth);
     1:     }
     1:     if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
 81029:       aMetrics.height = clamped(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_HEIGHT),
 81029:                                 aReflowState.mComputedMinHeight,
     1:                                 aReflowState.mComputedMaxHeight);
     1:     }
     1: 
   944: #if defined (MOZ_WIDGET_GTK2)
     1:     // We need to make sure that the size of the object frame does not
     1:     // exceed the maximum size of X coordinates.  See bug #225357 for
     1:     // more information.  In theory Gtk2 can handle large coordinates,
     1:     // but underlying plugins can't.
115367:     aMetrics.height = NS_MIN(aPresContext->DevPixelsToAppUnits(INT16_MAX), aMetrics.height);
115367:     aMetrics.width = NS_MIN(aPresContext->DevPixelsToAppUnits(INT16_MAX), aMetrics.width);
     1: #endif
     1:   }
     1: 
     1:   // At this point, the width has an unconstrained value only if we have
     1:   // nothing to go on (no width set, no information from the plugin, nothing).
     1:   // Make up a number.
     1:   if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
     1:     aMetrics.width =
     1:       (aReflowState.mComputedMinWidth != NS_UNCONSTRAINEDSIZE) ?
     1:         aReflowState.mComputedMinWidth : 0;
     1:   }
     1: 
     1:   // At this point, the height has an unconstrained value only in two cases:
     1:   // a) We are in standards mode with percent heights and parent is auto-height
     1:   // b) We have no height information at all.
     1:   // In either case, we have to make up a number.
     1:   if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
     1:     aMetrics.height =
     1:       (aReflowState.mComputedMinHeight != NS_UNCONSTRAINEDSIZE) ?
     1:         aReflowState.mComputedMinHeight : 0;
     1:   }
     1: 
     1:   // XXXbz don't add in the border and padding, because we screw up our
     1:   // plugin's size and positioning if we do...  Eventually we _do_ want to
     1:   // paint borders, though!  At that point, we will need to adjust the desired
     1:   // size either here or in Reflow....  Further, we will need to fix Paint() to
     1:   // call the superclass in all cases.
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsObjectFrame::Reflow(nsPresContext*           aPresContext,
     1:                       nsHTMLReflowMetrics&     aMetrics,
     1:                       const nsHTMLReflowState& aReflowState,
     1:                       nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsObjectFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
     1: 
     1:   // Get our desired size
     1:   GetDesiredSize(aPresContext, aReflowState, aMetrics);
 55039:   aMetrics.SetOverflowAreasToDesiredBounds();
 24440:   FinishAndStoreOverflow(&aMetrics);
     1: 
     1:   // delay plugin instantiation until all children have
     1:   // arrived. Otherwise there may be PARAMs or other stuff that the
     1:   // plugin needs to see that haven't arrived yet.
     1:   if (!GetContent()->IsDoneAddingChildren()) {
     1:     aStatus = NS_FRAME_COMPLETE;
     1:     return NS_OK;
     1:   }
     1: 
     1:   // if we are printing or print previewing, bail for now
     1:   if (aPresContext->Medium() == nsGkAtoms::print) {
     1:     aStatus = NS_FRAME_COMPLETE;
     1:     return NS_OK;
     1:   }
     1: 
 33369:   nsRect r(0, 0, aMetrics.width, aMetrics.height);
 33369:   r.Deflate(aReflowState.mComputedBorderPadding);
 33369: 
 33369:   if (mInnerView) {
 33369:     nsIViewManager* vm = mInnerView->GetViewManager();
 33369:     vm->MoveViewTo(mInnerView, r.x, r.y);
 79618:     vm->ResizeView(mInnerView, nsRect(nsPoint(0, 0), r.Size()), true);
 33369:   }
 33369: 
 33369:   FixupWindow(r.Size());
 52186:   if (!mReflowCallbackPosted) {
 79618:     mReflowCallbackPosted = true;
 52186:     aPresContext->PresShell()->PostReflowCallback(this);
 52186:   }
     1: 
     1:   aStatus = NS_FRAME_COMPLETE;
     1: 
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
     1:   return NS_OK;
     1: }
     1: 
 52186: ///////////// nsIReflowCallback ///////////////
 52186: 
 79445: bool
 52186: nsObjectFrame::ReflowFinished()
 52186: {
 79618:   mReflowCallbackPosted = false;
 52186:   CallSetWindow();
 79618:   return true;
 52186: }
 52186: 
 52186: void
 52186: nsObjectFrame::ReflowCallbackCanceled()
 52186: {
 79618:   mReflowCallbackPosted = false;
 52186: }
 52186: 
     1: void
     1: nsObjectFrame::FixupWindow(const nsSize& aSize)
     1: {
   238:   nsPresContext* presContext = PresContext();
     1: 
     1:   if (!mInstanceOwner)
     1:     return;
     1: 
 32799:   NPWindow *window;
     1:   mInstanceOwner->GetWindow(window);
     1: 
     1:   NS_ENSURE_TRUE(window, /**/);
     1: 
  4329: #ifdef XP_MACOSX
 80981:   nsWeakFrame weakFrame(this);
 71095:   mInstanceOwner->FixUpPluginWindow(nsPluginInstanceOwner::ePluginPaintDisable);
 80981:   if (!weakFrame.IsAlive()) {
 80981:     return;
 80981:   }
  4329: #endif
  4329: 
 79445:   bool windowless = (window->type == NPWindowTypeDrawable);
  4329: 
 23738:   nsIntPoint origin = GetWindowOriginInPixels(windowless);
  4329: 
115799:   // window must be in "display pixels"
115799:   double scaleFactor = 1.0;
115799:   if (NS_FAILED(mInstanceOwner->GetContentsScaleFactor(&scaleFactor))) {
115799:     scaleFactor = 1.0;
115799:   }
115799:   int intScaleFactor = ceil(scaleFactor);
115799:   window->x = origin.x / intScaleFactor;
115799:   window->y = origin.y / intScaleFactor;
115799:   window->width = presContext->AppUnitsToDevPixels(aSize.width) / intScaleFactor;
115799:   window->height = presContext->AppUnitsToDevPixels(aSize.height) / intScaleFactor;
     1: 
     1:   // on the Mac we need to set the clipRect to { 0, 0, 0, 0 } for now. This will keep
     1:   // us from drawing on screen until the widget is properly positioned, which will not
     1:   // happen until we have finished the reflow process.
 57224: #ifdef XP_MACOSX
     1:   window->clipRect.top = 0;
     1:   window->clipRect.left = 0;
     1:   window->clipRect.bottom = 0;
     1:   window->clipRect.right = 0;
     1: #else
 79618:   mInstanceOwner->UpdateWindowPositionAndClipRect(false);
 56619: #endif
 57224: 
 37372:   NotifyPluginReflowObservers();
     1: }
     1: 
 58796: nsresult
 79445: nsObjectFrame::CallSetWindow(bool aCheckIsHidden)
     1: {
106838:   NPWindow *win = nullptr;
     1:  
 58796:   nsresult rv = NS_ERROR_FAILURE;
 70007:   nsRefPtr<nsNPAPIPluginInstance> pi;
     1:   if (!mInstanceOwner ||
 70007:       NS_FAILED(rv = mInstanceOwner->GetInstance(getter_AddRefs(pi))) ||
     1:       !pi ||
     1:       NS_FAILED(rv = mInstanceOwner->GetWindow(win)) || 
     1:       !win)
 58796:     return rv;
     1: 
     1:   nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
     1: #ifdef XP_MACOSX
 80981:   nsWeakFrame weakFrame(this);
 71095:   mInstanceOwner->FixUpPluginWindow(nsPluginInstanceOwner::ePluginPaintDisable);
 80981:   if (!weakFrame.IsAlive()) {
 80981:     return NS_ERROR_NOT_AVAILABLE;
 80981:   }
     1: #endif
     1: 
 59526:   if (aCheckIsHidden && IsHidden())
 58796:     return NS_ERROR_FAILURE;
     1: 
     1:   // refresh the plugin port as well
 37446:   window->window = mInstanceOwner->GetPluginPortFromWidget();
     1: 
 52187:   // Adjust plugin dimensions according to pixel snap results
 52187:   // and reduce amount of SetWindow calls
 52187:   nsPresContext* presContext = PresContext();
 52187:   nsRootPresContext* rootPC = presContext->GetRootPresContext();
 52187:   if (!rootPC)
 58796:     return NS_ERROR_FAILURE;
108991:   int32_t appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
 52187:   nsIFrame* rootFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
 68635:   nsRect bounds = GetContentRectRelativeToSelf() + GetOffsetToCrossDoc(rootFrame);
 52187:   nsIntRect intBounds = bounds.ToNearestPixels(appUnitsPerDevPixel);
115799: 
115799:   // window must be in "display pixels"
115799:   double scaleFactor = 1.0;
115799:   if (NS_FAILED(mInstanceOwner->GetContentsScaleFactor(&scaleFactor))) {
115799:     scaleFactor = 1.0;
115799:   }
115799:   size_t intScaleFactor = ceil(scaleFactor);
115799:   window->x = intBounds.x / intScaleFactor;
115799:   window->y = intBounds.y / intScaleFactor;
115799:   window->width = intBounds.width / intScaleFactor;
115799:   window->height = intBounds.height / intScaleFactor;
 52187: 
 81166:   // Calling SetWindow might destroy this frame. We need to use the instance
 81166:   // owner to clean up so hold a ref.
 81166:   nsRefPtr<nsPluginInstanceOwner> instanceOwnerRef(mInstanceOwner);
 81166: 
 81166:   // This will call pi->SetWindow and take care of window subclassing
 81166:   // if needed, see bug 132759. Calling SetWindow can destroy this frame
 81166:   // so check for that before doing anything else with this frame's memory.
 62474:   if (mInstanceOwner->UseAsyncRendering()) {
 58796:     rv = pi->AsyncSetWindow(window);
 54223:   }
 54223:   else {
 58796:     rv = window->CallSetWindow(pi);
 54223:   }
     1: 
 81166:   instanceOwnerRef->ReleasePluginPort(window->window);
 81166: 
 58796:   return rv;
  4825: }
  4825: 
 89114: void
108609: nsObjectFrame::RegisterPluginForGeometryUpdates()
108609: {
108609:   nsRootPresContext* rpc = PresContext()->GetRootPresContext();
108609:   NS_ASSERTION(rpc, "We should have a root pres context!");
108609:   if (mRootPresContextRegisteredWith == rpc || !rpc) {
108609:     // Already registered with current root pres context,
108609:     // or null root pres context...
108609:     return;
108609:   }
108609:   if (mRootPresContextRegisteredWith && mRootPresContextRegisteredWith != rpc) {
108609:     // Registered to some other root pres context. Unregister, and
108609:     // re-register with our current one...
108609:     UnregisterPluginForGeometryUpdates();
108609:   }
108609:   mRootPresContextRegisteredWith = rpc;
108609:   mRootPresContextRegisteredWith->RegisterPluginForGeometryUpdates(mContent);
108609: }
108609: 
108609: void
108609: nsObjectFrame::UnregisterPluginForGeometryUpdates()
108609: {
108609:   if (!mRootPresContextRegisteredWith) {
108609:     // Not registered...
108609:     return;
108609:   }
108609:   mRootPresContextRegisteredWith->UnregisterPluginForGeometryUpdates(mContent);
108609:   mRootPresContextRegisteredWith = nullptr;
108609: }
108609: 
108609: void
 89114: nsObjectFrame::SetInstanceOwner(nsPluginInstanceOwner* aOwner)
 89114: {
 89114:   mInstanceOwner = aOwner;
108608:   if (mInstanceOwner) {
108608:     return;
108608:   }
108609:   UnregisterPluginForGeometryUpdates();
108608:   if (mWidget && mInnerView) {
 89114:     mInnerView->DetachWidgetEventHandler(mWidget);
 89114:     // Make sure the plugin is hidden in case an update of plugin geometry
 89114:     // hasn't happened since this plugin became hidden.
 89114:     nsIWidget* parent = mWidget->GetParent();
 89114:     if (parent) {
 89114:       nsTArray<nsIWidget::Configuration> configurations;
118837:       nsIWidget::Configuration* configuration = configurations.AppendElement();
118837:       configuration->mChild = mWidget;
 89114:       parent->ConfigureChildren(configurations);
 89114: 
 89114:       mWidget->Show(false);
 89114:       mWidget->Enable(false);
106838:       mWidget->SetParent(nullptr);
 89114:     }
103762:   }
 89114: }
 89114: 
 79445: bool
108991: nsObjectFrame::IsFocusable(int32_t *aTabIndex, bool aWithMouse)
  4825: {
  4825:   if (aTabIndex)
  4825:     *aTabIndex = -1;
  4825:   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
  4825: }
  4825: 
 79445: bool
 79445: nsObjectFrame::IsHidden(bool aCheckVisibilityStyle) const
  4825: {
  4825:   if (aCheckVisibilityStyle) {
  4825:     if (!GetStyleVisibility()->IsVisibleOrCollapsed())
 79618:       return true;    
  4825:   }
  4825: 
  4825:   // only <embed> tags support the HIDDEN attribute
  4825:   if (mContent->Tag() == nsGkAtoms::embed) {
  4825:     // Yes, these are really the kooky ways that you could tell 4.x
  4825:     // not to hide the <embed> once you'd put the 'hidden' attribute
  4825:     // on the tag...
  4825: 
  4825:     // HIDDEN w/ no attributes gets translated as we are hidden for
  4825:     // compatibility w/ 4.x and IE so we don't create a non-painting
  4825:     // widget in layout. See bug 188959.
  4825:     nsAutoString hidden;
  4825:     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::hidden, hidden) &&
  4825:        (hidden.IsEmpty() ||
 19264:         (!hidden.LowerCaseEqualsLiteral("false") &&
  4825:          !hidden.LowerCaseEqualsLiteral("no") &&
 19264:          !hidden.LowerCaseEqualsLiteral("off")))) {
 79618:       return true;
  4825:     }
  4825:   }
  4825: 
 79618:   return false;
  4825: }
  4825: 
 79445: nsIntPoint nsObjectFrame::GetWindowOriginInPixels(bool aWindowless)
  4825: {
  4825:   nsIView * parentWithView;
  4825:   nsPoint origin(0,0);
  4825: 
  4825:   GetOffsetFromView(origin, &parentWithView);
  4825: 
  4825:   // if it's windowless, let's make sure we have our origin set right
  4825:   // it may need to be corrected, like after scrolling
  4825:   if (aWindowless && parentWithView) {
 30878:     nsPoint offsetToWidget;
 30878:     parentWithView->GetNearestWidget(&offsetToWidget);
 30878:     origin += offsetToWidget;
  4825:   }
 68635:   origin += GetContentRectRelativeToSelf().TopLeft();
  4825: 
 23738:   return nsIntPoint(PresContext()->AppUnitsToDevPixels(origin.x),
 23738:                     PresContext()->AppUnitsToDevPixels(origin.y));
  4825: }
  4825: 
  4825: NS_IMETHODIMP
  4825: nsObjectFrame::DidReflow(nsPresContext*            aPresContext,
  4825:                          const nsHTMLReflowState*  aReflowState,
  4825:                          nsDidReflowStatus         aStatus)
  4825: {
  4825:   // Do this check before calling the superclass, as that clears
  4825:   // NS_FRAME_FIRST_REFLOW
  4825:   if (aStatus == NS_FRAME_REFLOW_FINISHED &&
  4825:       (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
  4825:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(mContent));
  4825:     NS_ASSERTION(objContent, "Why not an object loading content?");
  4825:     objContent->HasNewFrame(this);
  4825:   }
  4825: 
  4825:   nsresult rv = nsObjectFrameSuper::DidReflow(aPresContext, aReflowState, aStatus);
  4825: 
  4825:   // The view is created hidden; once we have reflowed it and it has been
  4825:   // positioned then we show it.
  4825:   if (aStatus != NS_FRAME_REFLOW_FINISHED) 
  4825:     return rv;
  4825: 
  4825:   if (HasView()) {
  4825:     nsIView* view = GetView();
  4825:     nsIViewManager* vm = view->GetViewManager();
  4825:     if (vm)
  4825:       vm->SetViewVisibility(view, IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow);
  4825:   }
  4825: 
     1:   return rv;
     1: }
     1: 
 15688: /* static */ void
 68481: nsObjectFrame::PaintPrintPlugin(nsIFrame* aFrame, nsRenderingContext* aCtx,
     1:                                 const nsRect& aDirtyRect, nsPoint aPt)
     1: {
 68635:   nsPoint pt = aPt + aFrame->GetContentRectRelativeToSelf().TopLeft();
 68481:   nsRenderingContext::AutoPushTranslation translate(aCtx, pt);
 15688:   // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
  3233:   static_cast<nsObjectFrame*>(aFrame)->PrintPlugin(*aCtx, aDirtyRect);
     1: }
     1: 
 62699: class nsDisplayPluginReadback : public nsDisplayItem {
 62699: public:
 62699:   nsDisplayPluginReadback(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
 62699:     : nsDisplayItem(aBuilder, aFrame)
 62699:   {
 62699:     MOZ_COUNT_CTOR(nsDisplayPluginReadback);
 62699:   }
 62699: #ifdef NS_BUILD_REFCNT_LOGGING
 62699:   virtual ~nsDisplayPluginReadback() {
 62699:     MOZ_COUNT_DTOR(nsDisplayPluginReadback);
 62699:   }
 62699: #endif
 62699: 
 95051:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap);
 79445:   virtual bool ComputeVisibility(nsDisplayListBuilder* aBuilder,
 62699:                                    nsRegion* aVisibleRegion,
 69802:                                    const nsRect& aAllowVisibleRegionExpansion);
 62699: 
 62699:   NS_DISPLAY_DECL_NAME("PluginReadback", TYPE_PLUGIN_READBACK)
 62699: 
 62699:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
 72230:                                              LayerManager* aManager,
 72230:                                              const ContainerParameters& aContainerParameters)
 62699:   {
114087:     return static_cast<nsObjectFrame*>(mFrame)->BuildLayer(aBuilder, aManager, this, aContainerParameters);
 62699:   }
 62699: 
 62699:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
 97534:                                    LayerManager* aManager,
 97534:                                    const ContainerParameters& aParameters)
 62699:   {
 62699:     return LAYER_ACTIVE;
 62699:   }
 62699: };
 62699: 
 62699: static nsRect
 62982: GetDisplayItemBounds(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem, nsIFrame* aFrame)
 62982: {
 62982:   // XXX For slightly more accurate region computations we should pixel-snap this
 68635:   return aFrame->GetContentRectRelativeToSelf() + aItem->ToReferenceFrame();
 30522: }
 30522: 
 62699: nsRect
 95051: nsDisplayPluginReadback::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
 62699: {
 95051:   *aSnap = false;
 62982:   return GetDisplayItemBounds(aBuilder, this, mFrame);
 62699: }
 62699: 
 79445: bool
 62699: nsDisplayPluginReadback::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 62699:                                            nsRegion* aVisibleRegion,
 69802:                                            const nsRect& aAllowVisibleRegionExpansion)
 62699: {
 62700:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                         aAllowVisibleRegionExpansion))
 79618:     return false;
 62700: 
 62700:   nsRect expand;
 95051:   bool snap;
 95051:   expand.IntersectRect(aAllowVisibleRegionExpansion, GetBounds(aBuilder, &snap));
 62699:   // *Add* our bounds to the visible region so that stuff underneath us is
 62699:   // likely to be made visible, so we can use it for a background! This is
 62699:   // a bit crazy since we normally only subtract from the visible region.
 62700:   aVisibleRegion->Or(*aVisibleRegion, expand);
 79618:   return true;
 62699: }
 62699: 
106178: #ifdef MOZ_WIDGET_ANDROID
106178: 
106178: class nsDisplayPluginVideo : public nsDisplayItem {
106178: public:
106178:   nsDisplayPluginVideo(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame, nsNPAPIPluginInstance::VideoInfo* aVideoInfo)
106178:     : nsDisplayItem(aBuilder, aFrame), mVideoInfo(aVideoInfo)
106178:   {
106178:     MOZ_COUNT_CTOR(nsDisplayPluginVideo);
106178:   }
106178: #ifdef NS_BUILD_REFCNT_LOGGING
106178:   virtual ~nsDisplayPluginVideo() {
106178:     MOZ_COUNT_DTOR(nsDisplayPluginVideo);
106178:   }
106178: #endif
106178: 
106178:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap);
106178:   virtual bool ComputeVisibility(nsDisplayListBuilder* aBuilder,
106178:                                    nsRegion* aVisibleRegion,
106178:                                    const nsRect& aAllowVisibleRegionExpansion);
106178: 
106178:   NS_DISPLAY_DECL_NAME("PluginVideo", TYPE_PLUGIN_VIDEO)
106178: 
106178:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
106178:                                              LayerManager* aManager,
106178:                                              const ContainerParameters& aContainerParameters)
106178:   {
114087:     return static_cast<nsObjectFrame*>(mFrame)->BuildLayer(aBuilder, aManager, this, aContainerParameters);
106178:   }
106178: 
106178:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
106178:                                    LayerManager* aManager,
106178:                                    const ContainerParameters& aParameters)
106178:   {
106178:     return LAYER_ACTIVE;
106178:   }
106178: 
106178:   nsNPAPIPluginInstance::VideoInfo* VideoInfo() { return mVideoInfo; }
106178: 
106178: private:
106178:   nsNPAPIPluginInstance::VideoInfo* mVideoInfo;
106178: };
106178: 
106178: nsRect
106178: nsDisplayPluginVideo::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
106178: {
106178:   *aSnap = false;
106178:   return GetDisplayItemBounds(aBuilder, this, mFrame);
106178: }
106178: 
106178: bool
106178: nsDisplayPluginVideo::ComputeVisibility(nsDisplayListBuilder* aBuilder,
106178:                                            nsRegion* aVisibleRegion,
106178:                                            const nsRect& aAllowVisibleRegionExpansion)
106178: {
106178:   return nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
106178:                                           aAllowVisibleRegionExpansion);
106178: }
106178: 
106178: #endif
106178: 
 62699: nsRect
 95051: nsDisplayPlugin::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap)
 62699: {
 95051:   *aSnap = false;
 62982:   return GetDisplayItemBounds(aBuilder, this, mFrame);
 62699: }
 62699: 
 30522: void
 30522: nsDisplayPlugin::Paint(nsDisplayListBuilder* aBuilder,
 68481:                        nsRenderingContext* aCtx)
 30522: {
 30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
 95051:   bool snap;
 95051:   f->PaintPlugin(aBuilder, *aCtx, mVisibleRect, GetBounds(aBuilder, &snap));
 30522: }
 30522: 
 79445: bool
 33368: nsDisplayPlugin::ComputeVisibility(nsDisplayListBuilder* aBuilder,
 61411:                                    nsRegion* aVisibleRegion,
 69802:                                    const nsRect& aAllowVisibleRegionExpansion)
 50393: {
118837:   if (aBuilder->IsForPluginGeometry()) {
118837:     nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
118837:     if (!aBuilder->IsInTransform() || f->IsPaintedByGecko()) {
118837:       // Since transforms induce reference frames, we don't need to worry
118837:       // about this method fluffing out due to non-rectilinear transforms.
118837:       nsRect rAncestor = nsLayoutUtils::TransformFrameRectToAncestor(f,
118837:           f->GetContentRectRelativeToSelf(), ReferenceFrame());
118837:       nscoord appUnitsPerDevPixel =
118837:         ReferenceFrame()->PresContext()->AppUnitsPerDevPixel();
118837:       f->mNextConfigurationBounds = rAncestor.ToNearestPixels(appUnitsPerDevPixel);
118837: 
 95051:       bool snap;
118837:       nsRegion visibleRegion;
118837:       visibleRegion.And(*aVisibleRegion, GetBounds(aBuilder, &snap));
118837:       // Make visibleRegion relative to f
118837:       visibleRegion.MoveBy(-ToReferenceFrame());
118837: 
118837:       f->mNextConfigurationClipRegion.Clear();
118837:       nsRegionRectIterator iter(visibleRegion);
118837:       for (const nsRect* r = iter.Next(); r; r = iter.Next()) {
118837:         nsRect rAncestor =
118837:           nsLayoutUtils::TransformFrameRectToAncestor(f, *r, ReferenceFrame());
118837:         nsIntRect rPixels = rAncestor.ToNearestPixels(appUnitsPerDevPixel)
118837:             - f->mNextConfigurationBounds.TopLeft();
118837:         if (!rPixels.IsEmpty()) {
118837:           f->mNextConfigurationClipRegion.AppendElement(rPixels);
118837:         }
118837:       }
118837:     }
118837: 
118837:     if (f->mInnerView) {
118837:       // This should produce basically the same rectangle (but not relative
118837:       // to the root frame). We only call this here for the side-effect of
118837:       // setting mViewToWidgetOffset on the view.
118837:       f->mInnerView->CalcWidgetBounds(eWindowType_plugin);
118837:     }
118837:   }
118837: 
 61411:   return nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
 69802:                                           aAllowVisibleRegionExpansion);
 30522: }
 30522: 
 59779: nsRegion
 59779: nsDisplayPlugin::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
 97420:                                  bool* aSnap)
 56101: {
 95051:   *aSnap = false;
 59779:   nsRegion result;
 30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
 57094:   if (!aBuilder->IsForPluginGeometry()) {
 57094:     nsIWidget* widget = f->GetWidget();
 57094:     if (widget) {
118837:       // Be conservative and treat plugins with widgets as not opaque,
118837:       // because that's simple and we might need the content under the widget
118837:       // if the widget is unexpectedly clipped away. (As can happen when
118837:       // chrome content over a plugin forces us to clip out the plugin for
118837:       // security reasons.)
118837:       // We shouldn't be repainting the content under plugins much anyway
118837:       // since there generally shouldn't be anything to invalidate or paint
118837:       // in ThebesLayers there.
 59779:   	  return result;
 59779:     }
 59779:   }
118837: 
 95051:   if (f->IsOpaque()) {
 95051:     nsRect bounds = GetBounds(aBuilder, aSnap);
 95051:     if (aBuilder->IsForPluginGeometry() ||
 95051:         (f->GetPaintedRect(this) + ToReferenceFrame()).Contains(bounds)) {
 62982:       // We can treat this as opaque
 95051:       result = bounds;
 95051:     }
 59779:   }
118837: 
 59779:   return result;
 30522: }
 30522: 
 35171: nsresult
 37372: nsObjectFrame::PluginEventNotifier::Run() {
 41540:   nsCOMPtr<nsIObserverService> obsSvc =
 41540:     mozilla::services::GetObserverService();
106838:   obsSvc->NotifyObservers(nullptr, "plugin-changed-event", mEventType.get());
 37372:   return NS_OK;
 37372: }
 37372: 
 30524: void
 37372: nsObjectFrame::NotifyPluginReflowObservers()
 37372: {
 37372:   nsContentUtils::AddScriptRunner(new PluginEventNotifier(NS_LITERAL_STRING("reflow")));
 35180: }
 35180: 
 35180: void
 30524: nsObjectFrame::DidSetWidgetGeometry()
 30524: {
 30524: #if defined(XP_MACOSX)
 30524:   if (mInstanceOwner) {
 71095:     mInstanceOwner->FixUpPluginWindow(nsPluginInstanceOwner::ePluginPaintEnable);
 30524:   }
118837: #else
118837:   if (!mWidget && mInstanceOwner) {
118837:     // UpdateWindowVisibility will notify the plugin of position changes
118837:     // by updating the NPWindow and calling NPP_SetWindow/AsyncSetWindow.
118837:     mInstanceOwner->UpdateWindowVisibility(!mNextConfigurationBounds.IsEmpty());
118837:   }
 30524: #endif
 30524: }
 30524: 
 79445: bool
 30522: nsObjectFrame::IsOpaque() const
 30522: {
105834: #if defined(XP_MACOSX)
 62699:   // ???
 79618:   return false;
106178: #elif defined(MOZ_WIDGET_ANDROID)
106178:   // We don't know, so just assume transparent
106178:   return false;
 62699: #else
 62699:   return !IsTransparentMode();
 62699: #endif
 62699: }
 62699: 
 79445: bool
 62699: nsObjectFrame::IsTransparentMode() const
 62699: {
 62699: #if defined(XP_MACOSX)
 62699:   // ???
 79618:   return false;
 30522: #else
 36333:   if (!mInstanceOwner)
 79618:     return false;
 36333: 
106838:   NPWindow *window = nullptr;
 30522:   mInstanceOwner->GetWindow(window);
 89353:   if (!window) {
 89353:     return false;
 89353:   }
 89353: 
 36333:   if (window->type != NPWindowTypeDrawable)
 79618:     return false;
 36333: 
 34441:   nsresult rv;
 70007:   nsRefPtr<nsNPAPIPluginInstance> pi;
 70007:   rv = mInstanceOwner->GetInstance(getter_AddRefs(pi));
 36333:   if (NS_FAILED(rv) || !pi)
 79618:     return false;
 36333: 
 79445:   bool transparent = false;
 34441:   pi->IsTransparent(&transparent);
 62699:   return transparent;
 30522: #endif
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsObjectFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                 const nsRect&           aDirtyRect,
     1:                                 const nsDisplayListSet& aLists)
     1: {
     1:   // XXX why are we painting collapsed object frames?
     1:   if (!IsVisibleOrCollapsedForPainting(aBuilder))
     1:     return NS_OK;
     1: 
     1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
   238:   nsPresContext::nsPresContextType type = PresContext()->Type();
     1: 
     1:   // If we are painting in Print Preview do nothing....
     1:   if (type == nsPresContext::eContext_PrintPreview)
     1:     return NS_OK;
     1: 
     1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsObjectFrame");
     1: 
 30541: #ifndef XP_MACOSX
 30541:   if (mWidget && aBuilder->IsInTransform()) {
 30541:     // Windowed plugins should not be rendered inside a transform.
 30541:     return NS_OK;
 30541:   }
 30541: #endif
 30541: 
 52294:   nsDisplayList replacedContent;
 52294: 
 62474:   if (aBuilder->IsForPainting() && mInstanceOwner && mInstanceOwner->UseAsyncRendering()) {
106838:     NPWindow* window = nullptr;
 59491:     mInstanceOwner->GetWindow(window);
 79445:     bool isVisible = window && window->width > 0 && window->height > 0;
 60439:     if (isVisible && aBuilder->ShouldSyncDecodeImages()) {
 59491:   #ifndef XP_MACOSX
 79618:       mInstanceOwner->UpdateWindowVisibility(true);
 59491:   #endif
 59491:     }
 59491: 
 59491:     mInstanceOwner->NotifyPaintWaiter(aBuilder);
 59491:   }
 59491: 
     1:   // determine if we are printing
 52294:   if (type == nsPresContext::eContext_Print) {
 52294:     rv = replacedContent.AppendNewToTop(new (aBuilder)
 51260:         nsDisplayGeneric(aBuilder, this, PaintPrintPlugin, "PrintPlugin",
 47732:                          nsDisplayItem::TYPE_PRINT_PLUGIN));
 52294:   } else {
106178:     // We don't need this on Android, and it just confuses things
106178: #if !MOZ_WIDGET_ANDROID
 62699:     if (aBuilder->IsPaintingToWindow() &&
106838:         GetLayerState(aBuilder, nullptr) == LAYER_ACTIVE &&
 62699:         IsTransparentMode()) {
 62699:       rv = replacedContent.AppendNewToTop(new (aBuilder)
 62699:           nsDisplayPluginReadback(aBuilder, this));
 62699:       NS_ENSURE_SUCCESS(rv, rv);
 62699:     }
106178: #endif
106178: 
106178: #if MOZ_WIDGET_ANDROID
106178:     if (aBuilder->IsPaintingToWindow() &&
106838:         GetLayerState(aBuilder, nullptr) == LAYER_ACTIVE) {
106178: 
106178:       nsTArray<nsNPAPIPluginInstance::VideoInfo*> videos;
106178:       mInstanceOwner->GetVideos(videos);
106178: 
118883:       for (uint32_t i = 0; i < videos.Length(); i++) {
106178:         rv = replacedContent.AppendNewToTop(new (aBuilder)
106178:           nsDisplayPluginVideo(aBuilder, this, videos[i]));
106178:         NS_ENSURE_SUCCESS(rv, rv);
106178:       }
106178:     }
106178: #endif
 62699: 
 52294:     rv = replacedContent.AppendNewToTop(new (aBuilder)
 51260:         nsDisplayPlugin(aBuilder, this));
     1:   }
 52294:   NS_ENSURE_SUCCESS(rv, rv);
 52294: 
 52294:   WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
 52294: 
 52294:   return NS_OK;
 52294: }
     1: 
 68482: #ifdef XP_OS2
 68482: static void *
 68865: GetPSFromRC(nsRenderingContext& aRenderingContext)
 68482: {
 68482:   nsRefPtr<gfxASurface>
 68482:     surf = aRenderingContext.ThebesContext()->CurrentSurface();
 68482:   if (!surf || surf->CairoStatus())
106838:     return nullptr;
 68482:   return (void *)(static_cast<gfxOS2Surface*>
 68482:                   (static_cast<gfxASurface*>(surf.get()))->GetPS());
 68482: }
 68482: #endif
 68482: 
     1: void
 68481: nsObjectFrame::PrintPlugin(nsRenderingContext& aRenderingContext,
     1:                            const nsRect& aDirtyRect)
     1: {
 35581:   nsCOMPtr<nsIObjectLoadingContent> obj(do_QueryInterface(mContent));
 35581:   if (!obj)
     1:     return;
     1: 
106838:   nsIFrame* frame = nullptr;
 35581:   obj->GetPrintFrame(&frame);
     1:   if (!frame)
     1:     return;
     1: 
   238:   nsPresContext* presContext = PresContext();
     1:   // make sure this is REALLY an nsIObjectFrame
     1:   // we may need to go through the children to get it
 23554:   nsIObjectFrame* objectFrame = do_QueryFrame(frame);
     1:   if (!objectFrame)
     1:     objectFrame = GetNextObjectFrame(presContext,frame);
     1:   if (!objectFrame)
     1:     return;
     1: 
     1:   // finally we can get our plugin instance
 70007:   nsRefPtr<nsNPAPIPluginInstance> pi;
 70007:   if (NS_FAILED(objectFrame->GetPluginInstance(getter_AddRefs(pi))) || !pi)
     1:     return;
     1: 
     1:   // now we need to setup the correct location for printing
 32799:   NPWindow window;
106838:   window.window = nullptr;
     1: 
     1:   // prepare embedded mode printing struct
 32799:   NPPrint npprint;
 32799:   npprint.mode = NP_EMBED;
     1: 
     1:   // we need to find out if we are windowless or not
 79445:   bool windowless = false;
 32799:   pi->IsWindowless(&windowless);
 32799:   window.type = windowless ? NPWindowTypeDrawable : NPWindowTypeWindow;
     1: 
     1:   window.clipRect.bottom = 0; window.clipRect.top = 0;
     1:   window.clipRect.left = 0; window.clipRect.right = 0;
     1: 
 30472: // platform specific printing code
118918: #if defined(XP_MACOSX) && !defined(__LP64__)
118889: #pragma clang diagnostic ignored "-Wdeprecated-declarations"
 71609:   // Don't use this code if any of the QuickDraw APIs it currently requires
 71609:   // are missing (as they probably will be on OS X 10.8 and up).
118889:   if (!&::SetRect || !&::NewGWorldFromPtr || !&::DisposeGWorld) {
 71609:     NS_WARNING("Cannot print plugin -- required QuickDraw APIs are missing!");
 71609:     return;
 71609:   }
 71609: 
 68635:   nsSize contentSize = GetContentRectRelativeToSelf().Size();
 30472:   window.x = 0;
 30472:   window.y = 0;
 33371:   window.width = presContext->AppUnitsToDevPixels(contentSize.width);
 33371:   window.height = presContext->AppUnitsToDevPixels(contentSize.height);
 30472: 
 30472:   gfxContext *ctx = aRenderingContext.ThebesContext();
 30472:   if (!ctx)
 30472:     return;
 30472:   gfxContextAutoSaveRestore save(ctx);
 30472: 
 30472:   ctx->NewPath();
 30472: 
 30472:   gfxRect rect(window.x, window.y, window.width, window.height);
 30472: 
 30472:   ctx->Rectangle(rect);
 30472:   ctx->Clip();
 30472: 
 30472:   gfxQuartzNativeDrawing nativeDraw(ctx, rect);
 30472:   CGContextRef cgContext = nativeDraw.BeginNativeDrawing();
 30472:   if (!cgContext) {
 30472:     nativeDraw.EndNativeDrawing();
 30472:     return;
 30472:   }
 30472: 
 30472:   window.clipRect.right = window.width;
 30472:   window.clipRect.bottom = window.height;
 32799:   window.type = NPWindowTypeDrawable;
 30472: 
 68640:   ::Rect gwBounds;
 30472:   ::SetRect(&gwBounds, 0, 0, window.width, window.height);
 30472: 
 30472:   nsTArray<char> buffer(window.width * window.height * 4);
 30472:   CGColorSpaceRef cspace = ::CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
 30472:   if (!cspace) {
 30472:     nativeDraw.EndNativeDrawing();
 30472:     return;
 30472:   }
 30472:   CGContextRef cgBuffer =
 30472:     ::CGBitmapContextCreate(buffer.Elements(), 
 30472:                             window.width, window.height, 8, window.width * 4,
 30472:                             cspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedFirst);
 30472:   ::CGColorSpaceRelease(cspace);
 30472:   if (!cgBuffer) {
 30472:     nativeDraw.EndNativeDrawing();
 30472:     return;
 30472:   }
 30472:   GWorldPtr gWorld;
 30472:   if (::NewGWorldFromPtr(&gWorld, k32ARGBPixelFormat, &gwBounds, NULL, NULL, 0,
 30472:                          buffer.Elements(), window.width * 4) != noErr) {
 30472:     ::CGContextRelease(cgBuffer);
 30472:     nativeDraw.EndNativeDrawing();
 30472:     return;
 30472:   }
 30472: 
 30472:   window.clipRect.right = window.width;
 30472:   window.clipRect.bottom = window.height;
 32799:   window.type = NPWindowTypeDrawable;
 30472:   // Setting nsPluginPrint/NPPrint.print.embedPrint.window.window to
 30472:   // &GWorldPtr and nsPluginPrint/NPPrint.print.embedPrint.platformPrint to
 30472:   // GWorldPtr isn't any kind of standard (it's not documented anywhere).
 30472:   // But that's what WebKit does.  And it's what the Flash plugin (apparently
 30472:   // the only NPAPI plugin on OS X to support printing) seems to expect.  So
 30472:   // we do the same.  The Flash plugin uses the CoreGraphics drawing mode.
 30472:   // But a GWorldPtr should be usable in either CoreGraphics or QuickDraw
 30472:   // drawing mode.  See bug 191046.
 32799:   window.window = &gWorld;
 30472:   npprint.print.embedPrint.platformPrint = gWorld;
 30472:   npprint.print.embedPrint.window = window;
 72149:   pi->Print(&npprint);
 30472: 
 30472:   ::CGContextTranslateCTM(cgContext, 0.0f, float(window.height));
 30472:   ::CGContextScaleCTM(cgContext, 1.0f, -1.0f);
 30472:   CGImageRef image = ::CGBitmapContextCreateImage(cgBuffer);
 30472:   if (!image) {
 30472:     ::CGContextRestoreGState(cgContext);
 30472:     ::CGContextRelease(cgBuffer);
 30472:     ::DisposeGWorld(gWorld);
 30472:     nativeDraw.EndNativeDrawing();
 30472:     return;
 30472:   }
 30472:   ::CGContextDrawImage(cgContext,
 30472:                        ::CGRectMake(0, 0, window.width, window.height),
 30472:                        image);
 30472:   ::CGImageRelease(image);
 30472:   ::CGContextRelease(cgBuffer);
 30472: 
 30472:   ::DisposeGWorld(gWorld);
 30472: 
 30472:   nativeDraw.EndNativeDrawing();
118889: #pragma clang diagnostic warning "-Wdeprecated-declarations"
 30472: #elif defined(XP_UNIX)
 12653: 
 12653:   /* XXX this just flat-out doesn't work in a thebes world --
 12653:    * RenderEPS is a no-op.  So don't bother to do any work here.
 12653:    */
 85981:   (void)window;
 85981:   (void)npprint;
     1: 
 12859: #elif defined(XP_OS2)
 68482:   void *hps = GetPSFromRC(aRenderingContext);
 12859:   if (!hps)
 12859:     return;
 12859: 
 12859:   npprint.print.embedPrint.platformPrint = hps;
 12859:   npprint.print.embedPrint.window = window;
 12859:   // send off print info to plugin
 19448:   pi->Print(&npprint);
 11703: #elif defined(XP_WIN)
 11703: 
 11703:   /* On Windows, we use the win32 printing surface to print.  This, in
 11703:    * turn, uses the Cairo paginated surface, which in turn uses the
 11703:    * meta surface to record all operations and then play them back.
 11703:    * This doesn't work too well for plugins, because if plugins render
 11703:    * directly into the DC, the meta surface won't have any knowledge
 11703:    * of them, and so at the end when it actually does the replay step,
 11703:    * it'll fill the background with white and draw over whatever was
 11703:    * rendered before.
 11703:    *
 11703:    * So, to avoid this, we use PushGroup, which creates a new windows
 11703:    * surface, the plugin renders to that, and then we use normal
 11703:    * cairo methods to composite that in such that it's recorded using the
 11703:    * meta surface.
 11703:    */
 11703: 
 12653:   /* we'll already be translated into the right spot by gfxWindowsNativeDrawing */
 68635:   nsSize contentSize = GetContentRectRelativeToSelf().Size();
 12653:   window.x = 0;
 12653:   window.y = 0;
 33371:   window.width = presContext->AppUnitsToDevPixels(contentSize.width);
 33371:   window.height = presContext->AppUnitsToDevPixels(contentSize.height);
 12653: 
 11703:   gfxContext *ctx = aRenderingContext.ThebesContext();
 11703: 
 11703:   ctx->Save();
 11703: 
 12653:   /* Make sure plugins don't do any damage outside of where they're supposed to */
 11703:   ctx->NewPath();
 21080:   gfxRect r(window.x, window.y, window.width, window.height);
 21080:   ctx->Rectangle(r);
 11703:   ctx->Clip();
 12653: 
 21080:   gfxWindowsNativeDrawing nativeDraw(ctx, r);
 11703:   do {
 11703:     HDC dc = nativeDraw.BeginNativeDrawing();
 11703:     if (!dc)
 11703:       return;
 11703: 
 21080:     // XXX don't we need to call nativeDraw.TransformToNativeRect here?
 11703:     npprint.print.embedPrint.platformPrint = dc;
 11703:     npprint.print.embedPrint.window = window;
 11703:     // send off print info to plugin
 19448:     pi->Print(&npprint);
 11703: 
 11703:     nativeDraw.EndNativeDrawing();
 11703:   } while (nativeDraw.ShouldRenderAgain());
 11703:   nativeDraw.PaintToContext();
 11703: 
 11703:   ctx->Restore();
     1: #endif
     1: 
     1:   // XXX Nav 4.x always sent a SetWindow call after print. Should we do the same?
 33371:   // XXX Calling DidReflow here makes no sense!!!
     1:   nsDidReflowStatus status = NS_FRAME_REFLOW_FINISHED; // should we use a special status?
     1:   frame->DidReflow(presContext,
106838:                    nullptr, status);  // DidReflow will take care of it
     1: }
     1: 
 62982: nsRect
 62982: nsObjectFrame::GetPaintedRect(nsDisplayPlugin* aItem)
 62982: {
 62982:   if (!mInstanceOwner)
 62982:     return nsRect();
 68635:   nsRect r = GetContentRectRelativeToSelf();
 62982:   if (!mInstanceOwner->UseAsyncRendering())
 62982:     return r;
 62982: 
 62982:   nsIntSize size = mInstanceOwner->GetCurrentImageSize();
 62982:   nsPresContext* pc = PresContext();
 62982:   r.IntersectRect(r, nsRect(0, 0, pc->DevPixelsToAppUnits(size.width),
 62982:                                   pc->DevPixelsToAppUnits(size.height)));
 62982:   return r;
 62982: }
 62982: 
 62724: void
 89708: nsObjectFrame::UpdateImageLayer(const gfxRect& aRect)
 62724: {
 63222:   if (!mInstanceOwner) {
 63222:     return;
 63222:   }
 63222: 
 62724: #ifdef XP_MACOSX
 71284:   if (!mInstanceOwner->UseAsyncRendering()) {
106838:     mInstanceOwner->DoCocoaEventDrawRect(aRect, nullptr);
 89708:     // This makes sure the image on the container is up to date.
 89708:     // XXX - Eventually we probably just want to make sure DoCocoaEventDrawRect
 89708:     // updates the image container, to make this truly use 'push' semantics
 89708:     // too.
 89708:     mInstanceOwner->GetImageContainer();
 71284:   }
 62724: #endif
 62724: }
 62724: 
 62982: LayerState
 62224: nsObjectFrame::GetLayerState(nsDisplayListBuilder* aBuilder,
 62224:                              LayerManager* aManager)
 62224: {
 62474:   if (!mInstanceOwner)
 62982:     return LAYER_NONE;
 62474: 
 62474: #ifdef XP_MACOSX
 73761:   if (!mInstanceOwner->UseAsyncRendering() &&
 72866:       mInstanceOwner->IsRemoteDrawingCoreAnimation() &&
 72866:       mInstanceOwner->GetEventModel() == NPEventModelCocoa) {
 72866:     return LAYER_ACTIVE;
 72866:   }
 72866: #endif
 72866: 
106178: #ifdef MOZ_WIDGET_ANDROID
106178:   // We always want a layer on Honeycomb and later
106178:   if (AndroidBridge::Bridge()->GetAPIVersion() >= 11)
106178:     return LAYER_ACTIVE;
106178: #endif
106178: 
 72866:   if (!mInstanceOwner->UseAsyncRendering()) {
 72865:     return LAYER_NONE;
 62474:   }
 62982: 
 62982:   return LAYER_ACTIVE;
 54223: }
 54223: 
 54223: already_AddRefed<Layer>
 54223: nsObjectFrame::BuildLayer(nsDisplayListBuilder* aBuilder,
 54223:                           LayerManager* aManager,
114087:                           nsDisplayItem* aItem,
114087:                           const ContainerParameters& aContainerParameters)
 54223: {
 54223:   if (!mInstanceOwner)
106838:     return nullptr;
 54223: 
106838:   NPWindow* window = nullptr;
 54223:   mInstanceOwner->GetWindow(window);
 54223:   if (!window)
106838:     return nullptr;
 54223: 
 54223:   if (window->width <= 0 || window->height <= 0)
106838:     return nullptr;
 54223: 
 62699:   // Create image
 89708:   nsRefPtr<ImageContainer> container = mInstanceOwner->GetImageContainer();
 62984: 
 89708:   if (!container) {
 89708:     // This can occur if our instance is gone.
106838:     return nullptr;
 62699:   }
 62984: 
115799:   // window is in "display pixels", but size needs to be in device pixels
115799:   double scaleFactor = 1.0;
115799:   if (NS_FAILED(mInstanceOwner->GetContentsScaleFactor(&scaleFactor))) {
115799:     scaleFactor = 1.0;
115799:   }
115799:   int intScaleFactor = ceil(scaleFactor);
115799:   gfxIntSize size(window->width * intScaleFactor, window->height * intScaleFactor);
 62699: 
 68635:   nsRect area = GetContentRectRelativeToSelf() + aItem->ToReferenceFrame();
 54223:   gfxRect r = nsLayoutUtils::RectToGfxRect(area, PresContext()->AppUnitsPerDevPixel());
 54223:   // to provide crisper and faster drawing.
 54223:   r.Round();
 54223:   nsRefPtr<Layer> layer =
115307:     (aManager->GetLayerBuilder()->GetLeafLayerFor(aBuilder, aItem));
 54223: 
 62699:   if (aItem->GetType() == nsDisplayItem::TYPE_PLUGIN) {
 54223:     if (!layer) {
 58634:       mInstanceOwner->NotifyPaintWaiter(aBuilder);
 54223:       // Initialize ImageLayer
 54223:       layer = aManager->CreateImageLayer();
 54223:       if (!layer)
106838:         return nullptr;
 62699:     }
 62224: 
 62699:     NS_ASSERTION(layer->GetType() == Layer::TYPE_IMAGE, "Bad layer type");
 54223: 
 54223:     ImageLayer* imglayer = static_cast<ImageLayer*>(layer.get());
 89708:     UpdateImageLayer(r);
 62724: 
 92163:     imglayer->SetScaleToSize(size, ImageLayer::SCALE_STRETCH);
 54223:     imglayer->SetContainer(container);
 78441:     gfxPattern::GraphicsFilter filter =
 78441:       nsLayoutUtils::GetGraphicsFilterForFrame(this);
 78441: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
 78441:     if (!aManager->IsCompositingCheap()) {
 78441:       // Pixman just horrible with bilinear filter scaling
 78441:       filter = gfxPattern::FILTER_NEAREST;
 78441:     }
 78441: #endif
 78441:     imglayer->SetFilter(filter);
 54223: 
 54223:     layer->SetContentFlags(IsOpaque() ? Layer::CONTENT_OPAQUE : 0);
106178: #ifdef MOZ_WIDGET_ANDROID
106178:   } else if (aItem->GetType() == nsDisplayItem::TYPE_PLUGIN_VIDEO) {
106178:     nsDisplayPluginVideo* videoItem = reinterpret_cast<nsDisplayPluginVideo*>(aItem);
106178:     nsNPAPIPluginInstance::VideoInfo* videoInfo = videoItem->VideoInfo();
106178: 
106178:     nsRefPtr<ImageContainer> container = mInstanceOwner->GetImageContainerForVideo(videoInfo);
106178:     if (!container)
106838:       return nullptr;
106178: 
106178:     if (!layer) {
106178:       // Initialize ImageLayer
106178:       layer = aManager->CreateImageLayer();
106178:       if (!layer)
106838:         return nullptr;
106178:     }
106178: 
106178:     ImageLayer* imglayer = static_cast<ImageLayer*>(layer.get());
106178:     imglayer->SetContainer(container);
106178: 
106178:     layer->SetContentFlags(IsOpaque() ? Layer::CONTENT_OPAQUE : 0);
106178: 
106178:     // Set the offset and size according to the video dimensions
106178:     r.MoveBy(videoInfo->mDimensions.TopLeft());
106178:     size.width = videoInfo->mDimensions.width;
106178:     size.height = videoInfo->mDimensions.height;
106178: #endif
 62699:   } else {
 62699:     NS_ASSERTION(aItem->GetType() == nsDisplayItem::TYPE_PLUGIN_READBACK,
 62699:                  "Unknown item type");
 62699:     NS_ABORT_IF_FALSE(!IsOpaque(), "Opaque plugins don't use backgrounds");
 62699: 
 62699:     if (!layer) {
 62699:       layer = aManager->CreateReadbackLayer();
 62699:       if (!layer)
106838:         return nullptr;
 62699:     }
 62699:     NS_ASSERTION(layer->GetType() == Layer::TYPE_READBACK, "Bad layer type");
 62699: 
 62699:     ReadbackLayer* readback = static_cast<ReadbackLayer*>(layer.get());
 62699:     if (readback->GetSize() != nsIntSize(size.width, size.height)) {
 62699:       // This will destroy any old background sink and notify us that the
 62699:       // background is now unknown
106838:       readback->SetSink(nullptr);
 62699:       readback->SetSize(nsIntSize(size.width, size.height));
 62699: 
 63204:       if (mBackgroundSink) {
 63204:         // Maybe we still have a background sink associated with another
 63204:         // readback layer that wasn't recycled for some reason? Unhook it
 63204:         // now so that if this frame goes away, it doesn't have a dangling
 63204:         // reference to us.
 63204:         mBackgroundSink->Destroy();
 63204:       }
 62699:       mBackgroundSink =
 62699:         new PluginBackgroundSink(this,
 62699:                                  readback->AllocateSequenceNumber());
 62699:       readback->SetSink(mBackgroundSink);
 62699:       // The layer has taken ownership of our sink. When either the sink dies
 62699:       // or the frame dies, the connection from the surviving object is nulled out.
 62699:     }
 62699:   }
 54223: 
 54223:   // Set a transform on the layer to draw the plugin in the right place
 54223:   gfxMatrix transform;
114087:   transform.Translate(r.TopLeft() + aContainerParameters.mOffset);
 54223: 
106915:   layer->SetBaseTransform(gfx3DMatrix::From2D(transform));
 62985:   layer->SetVisibleRegion(nsIntRect(0, 0, size.width, size.height));
 62699:   return layer.forget();
 54223: }
 54223: 
     1: void
 56434: nsObjectFrame::PaintPlugin(nsDisplayListBuilder* aBuilder,
 68481:                            nsRenderingContext& aRenderingContext,
 33369:                            const nsRect& aDirtyRect, const nsRect& aPluginRect)
     1: {
 82142: #if defined(MOZ_WIDGET_ANDROID)
 78424:   if (mInstanceOwner) {
 78424:     gfxRect frameGfxRect =
 78424:       PresContext()->AppUnitsToGfxUnits(aPluginRect);
 78424:     gfxRect dirtyGfxRect =
 78424:       PresContext()->AppUnitsToGfxUnits(aDirtyRect);
 93094: 
 78424:     gfxContext* ctx = aRenderingContext.ThebesContext();
 78424: 
 93094:     mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
 78424:     return;
 78424:   }
 78424: #endif
 78424: 
     1:   // Screen painting code
     1: #if defined(XP_MACOSX)
     1:   // delegate all painting to the plugin instance.
 11944:   if (mInstanceOwner) {
 39757:     if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreGraphics ||
 43370:         mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation ||
 43370:         mInstanceOwner->GetDrawingModel() == 
 43370:                                   NPDrawingModelInvalidatingCoreAnimation) {
108991:       int32_t appUnitsPerDevPixel = PresContext()->AppUnitsPerDevPixel();
 29811:       // Clip to the content area where the plugin should be drawn. If
 29811:       // we don't do this, the plugin can draw outside its bounds.
 33369:       nsIntRect contentPixels = aPluginRect.ToNearestPixels(appUnitsPerDevPixel);
 29811:       nsIntRect dirtyPixels = aDirtyRect.ToOutsidePixels(appUnitsPerDevPixel);
 29811:       nsIntRect clipPixels;
 29811:       clipPixels.IntersectRect(contentPixels, dirtyPixels);
 43369: 
 43369:       // Don't invoke the drawing code if the clip is empty.
 43369:       if (clipPixels.IsEmpty())
 43369:         return;
 43369: 
 29811:       gfxRect nativeClipRect(clipPixels.x, clipPixels.y,
 29811:                              clipPixels.width, clipPixels.height);
 11944:       gfxContext* ctx = aRenderingContext.ThebesContext();
 29811: 
 29811:       gfxContextAutoSaveRestore save(ctx);
 29811:       ctx->NewPath();
 29811:       ctx->Rectangle(nativeClipRect);
 29811:       ctx->Clip();
 29811:       gfxPoint offset(contentPixels.x, contentPixels.y);
 29811:       ctx->Translate(offset);
 29811: 
 29811:       gfxQuartzNativeDrawing nativeDrawing(ctx, nativeClipRect - offset);
 11944: 
 11944:       CGContextRef cgContext = nativeDrawing.BeginNativeDrawing();
 11944:       if (!cgContext) {
 11944:         NS_WARNING("null CGContextRef during PaintPlugin");
 11944:         return;
 11944:       }
 11944: 
 70007:       nsRefPtr<nsNPAPIPluginInstance> inst;
 70007:       GetPluginInstance(getter_AddRefs(inst));
 12241:       if (!inst) {
 12241:         NS_WARNING("null plugin instance during PaintPlugin");
 21108:         nativeDrawing.EndNativeDrawing();
 12241:         return;
 12241:       }
 32799:       NPWindow* window;
 12241:       mInstanceOwner->GetWindow(window);
 12241:       if (!window) {
 12241:         NS_WARNING("null plugin window during PaintPlugin");
 21108:         nativeDrawing.EndNativeDrawing();
 12241:         return;
 12241:       }
 32799:       NP_CGContext* cgPluginPortCopy =
 32799:                 static_cast<NP_CGContext*>(mInstanceOwner->GetPluginPortCopy());
 32799:       if (!cgPluginPortCopy) {
 21108:         NS_WARNING("null plugin port copy during PaintPlugin");
 21108:         nativeDrawing.EndNativeDrawing();
 21108:         return;
 21108:       }
 21108: 
 21108:       mInstanceOwner->BeginCGPaint();
 43370:       if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation ||
 43370:           mInstanceOwner->GetDrawingModel() == 
 43370:                                    NPDrawingModelInvalidatingCoreAnimation) {
 39757:         // CoreAnimation is updated, render the layer and perform a readback.
 39757:         mInstanceOwner->RenderCoreAnimation(cgContext, window->width, window->height);
 39757:       } else {
 34717:         mInstanceOwner->Paint(nativeClipRect - offset, cgContext);
 39757:       }
 21108:       mInstanceOwner->EndCGPaint();
 11944: 
 11944:       nativeDrawing.EndNativeDrawing();
 11944:     } else {
 29811:       // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
 68481:       nsRenderingContext::AutoPushTranslation
 68479:         translate(&aRenderingContext, aPluginRect.TopLeft());
 29811: 
 32019:       // this rect is used only in the CoreGraphics drawing model
 32019:       gfxRect tmpRect(0, 0, 0, 0);
 34717:       mInstanceOwner->Paint(tmpRect, NULL);
 11944:     }
 11944:   }
 47118: #elif defined(MOZ_X11)
 21080:   if (mInstanceOwner) {
 32799:     NPWindow *window;
  3059:     mInstanceOwner->GetWindow(window);
 32799:     if (window->type == NPWindowTypeDrawable) {
 15688:       gfxRect frameGfxRect =
 33369:         PresContext()->AppUnitsToGfxUnits(aPluginRect);
 15688:       gfxRect dirtyGfxRect =
 15688:         PresContext()->AppUnitsToGfxUnits(aDirtyRect);
 15688:       gfxContext* ctx = aRenderingContext.ThebesContext();
 15688: 
 15688:       mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
 15688:     }
  3059:   }
 21080: #elif defined(XP_WIN)
 70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
 70007:   GetPluginInstance(getter_AddRefs(inst));
     1:   if (inst) {
 21080:     gfxRect frameGfxRect =
 33369:       PresContext()->AppUnitsToGfxUnits(aPluginRect);
 21080:     gfxRect dirtyGfxRect =
 21080:       PresContext()->AppUnitsToGfxUnits(aDirtyRect);
 21080:     gfxContext *ctx = aRenderingContext.ThebesContext();
 21080:     gfxMatrix currentMatrix = ctx->CurrentMatrix();
 21080: 
 79618:     if (ctx->UserToDevicePixelSnapped(frameGfxRect, false)) {
 21080:       dirtyGfxRect = ctx->UserToDevice(dirtyGfxRect);
 21080:       ctx->IdentityMatrix();
 21080:     }
 21080:     dirtyGfxRect.RoundOut();
 21080: 
     1:     // Look if it's windowless
 32799:     NPWindow *window;
     1:     mInstanceOwner->GetWindow(window);
     1: 
 32799:     if (window->type == NPWindowTypeDrawable) {
     1:       // the offset of the DC
 19835:       nsPoint origin;
     1: 
 21080:       gfxWindowsNativeDrawing nativeDraw(ctx, frameGfxRect);
 36270:       if (nativeDraw.IsDoublePass()) {
 36270:         // OOP plugin specific: let the shim know before we paint if we are doing a
 36270:         // double pass render. If this plugin isn't oop, the register window message
 36270:         // will be ignored.
 36270:         NPEvent pluginEvent;
 62699:         pluginEvent.event = DoublePassRenderingEvent();
 36270:         pluginEvent.wParam = 0;
 36270:         pluginEvent.lParam = 0;
 50668:         if (pluginEvent.event)
106838:           inst->HandleEvent(&pluginEvent, nullptr);
 36270:       }
 21080:       do {
 21080:         HDC hdc = nativeDraw.BeginNativeDrawing();
 21080:         if (!hdc)
     1:           return;
 21080: 
 21080:         RECT dest;
 21080:         nativeDraw.TransformToNativeRect(frameGfxRect, dest);
 21080:         RECT dirty;
 21080:         nativeDraw.TransformToNativeRect(dirtyGfxRect, dirty);
 21080: 
 32799:         window->window = hdc;
 21080:         window->x = dest.left;
 21080:         window->y = dest.top;
 57225:         window->clipRect.left = 0;
 57225:         window->clipRect.top = 0;
 57225:         // if we're painting, we're visible.
 57225:         window->clipRect.right = window->width;
 57225:         window->clipRect.bottom = window->height;
 21080: 
 36271:         // Windowless plugins on windows need a special event to update their location,
 36271:         // see bug 135737.
 36271:         //
     1:         // bug 271442: note, the rectangle we send is now purely the bounds of the plugin
 36271:         // relative to the window it is contained in, which is useful for the plugin to
 36271:         // correctly translate mouse coordinates.
     1:         //
     1:         // this does not mesh with the comments for bug 135737 which imply that the rectangle
 36271:         // must be clipped in some way to prevent the plugin attempting to paint over areas
 36271:         // it shouldn't.
     1:         //
 36271:         // since the two uses of the rectangle are mutually exclusive in some cases, and
 36271:         // since I don't see any incorrect painting (at least with Flash and ViewPoint -
 36271:         // the originator of bug 135737), it seems that windowless plugins are not relying
 36271:         // on information here for clipping their drawing, and we can safely use this message
 36271:         // to tell the plugin exactly where it is in all cases.
     1: 
 79618:         nsIntPoint origin = GetWindowOriginInPixels(true);
 23738:         nsIntRect winlessRect = nsIntRect(origin, nsIntSize(window->width, window->height));
 57232: 
 68638:         if (!mWindowlessRect.IsEqualEdges(winlessRect)) {
     1:           mWindowlessRect = winlessRect;
     1: 
     1:           WINDOWPOS winpos;
     1:           memset(&winpos, 0, sizeof(winpos));
     1:           winpos.x = mWindowlessRect.x;
     1:           winpos.y = mWindowlessRect.y;
     1:           winpos.cx = mWindowlessRect.width;
     1:           winpos.cy = mWindowlessRect.height;
     1: 
     1:           // finally, update the plugin by sending it a WM_WINDOWPOSCHANGED event
 32799:           NPEvent pluginEvent;
     1:           pluginEvent.event = WM_WINDOWPOSCHANGED;
     1:           pluginEvent.wParam = 0;
 43548:           pluginEvent.lParam = (LPARAM)&winpos;
106838:           inst->HandleEvent(&pluginEvent, nullptr);
 57234:         }
     1: 
     1:         inst->SetWindow(window);
 57234: 
 21080:         mInstanceOwner->Paint(dirty, hdc);
 21080:         nativeDraw.EndNativeDrawing();
 36270:       } while (nativeDraw.ShouldRenderAgain());
 21080:       nativeDraw.PaintToContext();
 21080:     }
 21080: 
 21080:     ctx->SetMatrix(currentMatrix);
 21080:   }
 21080: #elif defined(XP_OS2)
 70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
 70007:   GetPluginInstance(getter_AddRefs(inst));
 21080:   if (inst) {
 21080:     // Look if it's windowless
 32799:     NPWindow *window;
 21080:     mInstanceOwner->GetWindow(window);
 21080: 
 32799:     if (window->type == NPWindowTypeDrawable) {
 21080:       // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
 68481:       nsRenderingContext::AutoPushTranslation
 68479:         translate(&aRenderingContext, aPluginRect.TopLeft());
 21080: 
 21080:       // check if we need to call SetWindow with updated parameters
 79445:       bool doupdatewindow = false;
 21080:       // the offset of the DC
 23738:       nsIntPoint origin;
 21080: 
 21080:       /*
 21080:        * Layout now has an optimized way of painting. Now we always get
 21080:        * a new drawing surface, sized to be just what's needed. Windowless
 21080:        * plugins need a transform applied to their origin so they paint
 21080:        * in the right place. Since |SetWindow| is no longer being used
 21080:        * to tell the plugin where it is, we dispatch a NPWindow through
 21080:        * |HandleEvent| to tell the plugin when its window moved
 21080:        */
 21080:       gfxContext *ctx = aRenderingContext.ThebesContext();
 21080: 
 21080:       gfxMatrix ctxMatrix = ctx->CurrentMatrix();
 21080:       if (ctxMatrix.HasNonTranslation()) {
 21080:         // soo; in the future, we should be able to render
 21080:         // the object content to an offscreen DC, and then
 21080:         // composite it in with the right transforms.
 21080: 
 21080:         // But, we don't bother doing that, because we don't
 21080:         // have the event handling story figured out yet.
 21080:         // Instead, let's just bail.
 21080: 
 21080:         return;
 21080:       }
 21080: 
 21080:       origin.x = NSToIntRound(float(ctxMatrix.GetTranslation().x));
 21080:       origin.y = NSToIntRound(float(ctxMatrix.GetTranslation().y));
 21080: 
 21080:       /* Need to force the clip to be set */
 21080:       ctx->UpdateSurfaceClip();
 21080: 
 21080:       /* Set the device offsets as appropriate, for whatever our current group offsets might be */
 21080:       gfxFloat xoff, yoff;
 21080:       nsRefPtr<gfxASurface> surf = ctx->CurrentSurface(&xoff, &yoff);
 21080: 
 21080:       if (surf->CairoStatus() != 0) {
 21080:         NS_WARNING("Plugin is being asked to render to a surface that's in error!");
 21080:         return;
 21080:       }
 21080: 
 21080:       // check if we need to update the PS
 68482:       HPS hps = (HPS)GetPSFromRC(aRenderingContext);
 21080:       if (reinterpret_cast<HPS>(window->window) != hps) {
 32955:         window->window = reinterpret_cast<void*>(hps);
 79618:         doupdatewindow = true;
 21080:       }
 21080:       LONG lPSid = GpiSavePS(hps);
 21080:       RECTL rclViewport;
 21080:       if (GpiQueryDevice(hps) != NULLHANDLE) { // ensure that we have an associated HDC
 21080:         if (GpiQueryPageViewport(hps, &rclViewport)) {
 21080:           rclViewport.xLeft += (LONG)xoff;
 21080:           rclViewport.xRight += (LONG)xoff;
 21080:           rclViewport.yBottom += (LONG)yoff;
 21080:           rclViewport.yTop += (LONG)yoff;
 21080:           GpiSetPageViewport(hps, &rclViewport);
 21080:         }
 21080:       }
 21080: 
 21080:       if ((window->x != origin.x) || (window->y != origin.y)) {
 21080:         window->x = origin.x;
 21080:         window->y = origin.y;
 79618:         doupdatewindow = true;
 21080:       }
 21080: 
 21080:       // if our location or visible area has changed, we need to tell the plugin
 21080:       if (doupdatewindow) {
 21080:         inst->SetWindow(window);        
 21080:       }
 21080: 
 12859:       mInstanceOwner->Paint(aDirtyRect, hps);
 12859:       if (lPSid >= 1) {
 12859:         GpiRestorePS(hps, lPSid);
 12859:       }
     1:       surf->MarkDirty();
     1:     }
     1:   }
     1: #endif
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsObjectFrame::HandleEvent(nsPresContext* aPresContext,
     1:                            nsGUIEvent*     anEvent,
     1:                            nsEventStatus*  anEventStatus)
     1: {
 32019:   NS_ENSURE_ARG_POINTER(anEvent);
     1:   NS_ENSURE_ARG_POINTER(anEventStatus);
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (!mInstanceOwner)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
 13537:   mInstanceOwner->ConsiderNewEventloopNestingLevel();
 13537: 
     1:   if (anEvent->message == NS_PLUGIN_ACTIVATE) {
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(GetContent());
 29018:     if (fm && elem)
 29018:       return fm->SetFocus(elem, 0);
     1:   }
 57526:   else if (anEvent->message == NS_PLUGIN_FOCUS) {
 63883:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 57526:     if (fm)
 57526:       return fm->FocusPlugin(GetContent());
 57526:   }
     1: 
119106: #ifdef XP_MACOSX
119106:   if (anEvent->message == NS_PLUGIN_RESOLUTION_CHANGED) {
119106:     double scaleFactor = 1.0;
119106:     mInstanceOwner->GetContentsScaleFactor(&scaleFactor);
119106:     mInstanceOwner->ContentsScaleFactorChanged(scaleFactor);
119106:     return NS_OK;
119106:   }
119106: #endif
119106: 
 41061:   if (mInstanceOwner->SendNativeEvents() &&
 69670:       NS_IS_PLUGIN_EVENT(anEvent)) {
 22788:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
 22788:     return rv;
 22788:   }
 22788: 
     1: #ifdef XP_WIN
     1:   rv = nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
     1:   return rv;
     1: #endif
     1: 
 32019: #ifdef XP_MACOSX
 34678:   // we want to process some native mouse events in the cocoa event model
108065:   if ((anEvent->message == NS_MOUSE_ENTER ||
108065:        anEvent->message == NS_WHEEL_WHEEL) &&
 34678:       mInstanceOwner->GetEventModel() == NPEventModelCocoa) {
 32019:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
 32019:     return rv;
 32019:   }
 32019: #endif
 32019: 
 34742:   return nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
 34742: }
 34742: 
 37413: #ifdef XP_MACOSX
 37413: // Needed to make the routing of mouse events while dragging conform to
 37413: // standard OS X practice, and to the Cocoa NPAPI spec.  See bug 525078.
 37413: NS_IMETHODIMP
 37413: nsObjectFrame::HandlePress(nsPresContext* aPresContext,
 37413:                            nsGUIEvent*    anEvent,
 37413:                            nsEventStatus* anEventStatus)
 37413: {
 37413:   nsIPresShell::SetCapturingContent(GetContent(), CAPTURE_IGNOREALLOWED);
 37413:   return nsObjectFrameSuper::HandlePress(aPresContext, anEvent, anEventStatus);
 37413: }
 37413: #endif
 37413: 
 15569: nsresult
 70007: nsObjectFrame::GetPluginInstance(nsNPAPIPluginInstance** aPluginInstance)
 70007: {
106838:   *aPluginInstance = nullptr;
     1: 
 89114:   if (!mInstanceOwner) {
  8609:     return NS_OK;
  8609:   }
  8609: 
 89114:   return mInstanceOwner->GetInstance(aPluginInstance);
     1: }
     1: 
 67677: NS_IMETHODIMP
 67677: nsObjectFrame::GetCursor(const nsPoint& aPoint, nsIFrame::Cursor& aCursor)
 67677: {
 67677:   if (!mInstanceOwner) {
 67677:     return NS_ERROR_FAILURE;
 67677:   }
 67677: 
 70007:   nsRefPtr<nsNPAPIPluginInstance> inst;
 70007:   mInstanceOwner->GetInstance(getter_AddRefs(inst));
 67677:   if (!inst) {
 67677:     return NS_ERROR_FAILURE;
 67677:   }
 67677: 
 79445:   bool useDOMCursor = static_cast<nsNPAPIPluginInstance*>(inst.get())->UsesDOMForCursor();
 67677:   if (!useDOMCursor) {
 67677:     return NS_ERROR_FAILURE;
 67677:   }
 67677: 
 67677:   return nsObjectFrameSuper::GetCursor(aPoint, aCursor);
 67677: }
 67677: 
     1: void
 79445: nsObjectFrame::SetIsDocumentActive(bool aIsActive)
 76815: {
 76815: #ifndef XP_MACOSX
 76815:   if (mInstanceOwner) {
 76815:     mInstanceOwner->UpdateDocumentActiveState(aIsActive);
 76815:   }
 76815: #endif
 76815: }
 76815: 
     1: // static
     1: nsIObjectFrame *
     1: nsObjectFrame::GetNextObjectFrame(nsPresContext* aPresContext, nsIFrame* aRoot)
     1: {
 77154:   nsIFrame* child = aRoot->GetFirstPrincipalChild();
     1: 
     1:   while (child) {
 23554:     nsIObjectFrame* outFrame = do_QueryFrame(child);
     1:     if (outFrame) {
 70007:       nsRefPtr<nsNPAPIPluginInstance> pi;
 70007:       outFrame->GetPluginInstance(getter_AddRefs(pi));  // make sure we have a REAL plugin
     1:       if (pi)
     1:         return outFrame;
     1:     }
     1: 
     1:     outFrame = GetNextObjectFrame(aPresContext, child);
     1:     if (outFrame)
     1:       return outFrame;
     1:     child = child->GetNextSibling();
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
 54309: /*static*/ void
 54309: nsObjectFrame::BeginSwapDocShells(nsIContent* aContent, void*)
 54309: {
 54309:   NS_PRECONDITION(aContent, "");
 54309: 
 54309:   // This function is called from a document content enumerator so we need
 54309:   // to filter out the nsObjectFrames and ignore the rest.
 54309:   nsIObjectFrame* obj = do_QueryFrame(aContent->GetPrimaryFrame());
 54309:   if (!obj)
 54309:     return;
 54309: 
 54309:   nsObjectFrame* objectFrame = static_cast<nsObjectFrame*>(obj);
 54309:   NS_ASSERTION(!objectFrame->mWidget || objectFrame->mWidget->GetParent(),
 54309:                "Plugin windows must not be toplevel");
108609:   objectFrame->UnregisterPluginForGeometryUpdates();
 54309: }
 54309: 
 54309: /*static*/ void
 54309: nsObjectFrame::EndSwapDocShells(nsIContent* aContent, void*)
 54309: {
 54309:   NS_PRECONDITION(aContent, "");
 54309: 
 54309:   // This function is called from a document content enumerator so we need
 54309:   // to filter out the nsObjectFrames and ignore the rest.
 54309:   nsIObjectFrame* obj = do_QueryFrame(aContent->GetPrimaryFrame());
 54309:   if (!obj)
 54309:     return;
 54309: 
 54309:   nsObjectFrame* objectFrame = static_cast<nsObjectFrame*>(obj);
 54309:   nsRootPresContext* rootPC = objectFrame->PresContext()->GetRootPresContext();
 54309:   NS_ASSERTION(rootPC, "unable to register the plugin frame");
103762:   nsIWidget* widget = objectFrame->mWidget;
 54309:   if (widget) {
 54309:     // Reparent the widget.
 54309:     nsIWidget* parent =
 54309:       rootPC->PresShell()->GetRootFrame()->GetNearestWidget();
 54309:     widget->SetParent(parent);
 54309:     objectFrame->CallSetWindow();
 54309: 
 54309:     // Register for geometry updates and make a request.
108609:     objectFrame->RegisterPluginForGeometryUpdates();
 54309:   }
 54309: }
 54309: 
     1: nsIFrame*
     1: NS_NewObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsObjectFrame(aContext);
     1: }
     1: 
 93925: bool
118837: nsObjectFrame::IsPaintedByGecko() const
 93925: {
 93925: #ifdef XP_MACOSX
 93925:   return true;
 93925: #else
 93925:   return !mWidget;
 93925: #endif
 93925: }
 93925: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsObjectFrame)
