   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * Base class for all element classes; this provides an implementation
   1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
   1:  * utility methods for subclasses, and so forth.
   1:  */
   1: 
   1: #include "nsGenericElement.h"
   1: 
   1: #include "nsDOMAttribute.h"
   1: #include "nsDOMAttributeMap.h"
   1: #include "nsIAtom.h"
   1: #include "nsINodeInfo.h"
   1: #include "nsIDocument.h"
   1: #include "nsIDOMNodeList.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsIDOMText.h"
   1: #include "nsIContentIterator.h"
   1: #include "nsIEventListenerManager.h"
   1: #include "nsIFocusController.h"
   1: #include "nsILinkHandler.h"
   1: #include "nsIScriptGlobalObject.h"
   1: #include "nsIURL.h"
   1: #include "nsNetUtil.h"
   1: #include "nsIFrame.h"
   1: #include "nsIPresShell.h"
   1: #include "nsPresContext.h"
   1: #include "nsStyleConsts.h"
   1: #include "nsString.h"
   1: #include "nsUnicharUtils.h"
   1: #include "nsIEventStateManager.h"
   1: #include "nsIDOMEvent.h"
   1: #include "nsIPrivateDOMEvent.h"
   1: #include "nsDOMCID.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsIDOMCSSStyleDeclaration.h"
   1: #include "nsDOMCSSDeclaration.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsContentList.h"
   1: #include "nsDOMError.h"
   1: #include "nsDOMString.h"
   1: #include "nsIScriptSecurityManager.h"
   1: #include "nsIDOMMutationEvent.h"
   1: #include "nsMutationEvent.h"
   1: #include "nsNodeUtils.h"
   1: #include "nsDocument.h"
1498: #include "nsXULElement.h"
   1: 
   1: #include "nsBindingManager.h"
   1: #include "nsXBLBinding.h"
   1: #include "nsIDOMCSSStyleDeclaration.h"
   1: #include "nsIDOMViewCSS.h"
   1: #include "nsIXBLService.h"
   1: #include "nsPIDOMWindow.h"
   1: #include "nsIBoxObject.h"
   1: #include "nsPIBoxObject.h"
   1: #include "nsIDOMNSDocument.h"
   1: #include "nsIDOMNSElement.h"
2014: #include "nsTextRectangle.h"
2014: #ifdef MOZ_SVG
2014: #include "nsSVGUtils.h"
2014: #endif
2014: #include "nsLayoutUtils.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsContentUtils.h"
   1: #include "nsIJSContextStack.h"
   1: 
   1: #include "nsIServiceManager.h"
   1: #include "nsIDOMEventListener.h"
   1: 
   1: #include "nsIWebNavigation.h"
   1: #include "nsIBaseWindow.h"
   1: 
   1: #include "jsapi.h"
   1: 
   1: #include "nsNodeInfoManager.h"
   1: #include "nsICategoryManager.h"
   1: #include "nsIDOMNSFeatureFactory.h"
   1: #include "nsIDOMDocumentType.h"
   1: #include "nsIDOMUserDataHandler.h"
   1: #include "nsEventDispatcher.h"
   1: #include "nsContentCreatorFunctions.h"
   1: #include "nsIFocusController.h"
   1: #include "nsIControllers.h"
1685: #include "nsXBLInsertionPoint.h"
1839: #include "nsIXULDocument.h"
   1: 
   1: #include "nsCycleCollectionParticipant.h"
1353: #include "nsCCUncollectableMarker.h"
   1: 
   1: #ifdef MOZ_SVG
   1: PRBool NS_SVG_TestFeature(const nsAString &fstr);
   1: #endif /* MOZ_SVG */
   1: 
   1: #ifdef DEBUG_waterson
   1: 
   1: /**
   1:  * List a content tree to stdout. Meant to be called from gdb.
   1:  */
   1: void
   1: DebugListContentTree(nsIContent* aElement)
   1: {
   1:   aElement->List(stdout, 0);
   1:   printf("\n");
   1: }
   1: 
   1: #endif
   1: 
   1: PRInt32 nsIContent::sTabFocusModel = eTabFocus_any;
   1: PRBool nsIContent::sTabFocusModelAppliesToXUL = PR_FALSE;
   1: nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: nsINode::nsSlots::~nsSlots()
   1: {
   1:   if (mChildNodes) {
   1:     mChildNodes->DropReference();
   1:     NS_RELEASE(mChildNodes);
   1:   }
   1: 
   1:   if (mWeakReference) {
   1:     mWeakReference->NoticeNodeDestruction();
   1:   }
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: nsINode::~nsINode()
   1: {
   1:   NS_ASSERTION(!HasSlots(), "nsNodeUtils::LastRelease was not called?");
   1: }
   1: 
   1: void*
   1: nsINode::GetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
   1:                      nsresult *aStatus) const
   1: {
   1:   nsIDocument *doc = GetOwnerDoc();
   1:   if (!doc)
   1:     return nsnull;
   1: 
   1:   return doc->PropertyTable()->GetProperty(this, aCategory, aPropertyName,
   1:                                            aStatus);
   1: }
   1: 
   1: nsresult
   1: nsINode::SetProperty(PRUint16 aCategory, nsIAtom *aPropertyName, void *aValue,
   1:                      NSPropertyDtorFunc aDtor, PRBool aTransfer,
   1:                      void **aOldValue)
   1: {
   1:   nsIDocument *doc = GetOwnerDoc();
   1:   if (!doc)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsresult rv = doc->PropertyTable()->SetProperty(this, aCategory,
   1:                                                   aPropertyName, aValue, aDtor,
   1:                                                   nsnull, aTransfer, aOldValue);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     SetFlags(NODE_HAS_PROPERTIES);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsINode::DeleteProperty(PRUint16 aCategory, nsIAtom *aPropertyName)
   1: {
   1:   nsIDocument *doc = GetOwnerDoc();
   1:   if (!doc)
   1:     return nsnull;
   1: 
   1:   return doc->PropertyTable()->DeleteProperty(this, aCategory, aPropertyName);
   1: }
   1: 
   1: void*
   1: nsINode::UnsetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
   1:                        nsresult *aStatus)
   1: {
   1:   nsIDocument *doc = GetOwnerDoc();
   1:   if (!doc)
   1:     return nsnull;
   1: 
   1:   return doc->PropertyTable()->UnsetProperty(this, aCategory, aPropertyName,
   1:                                              aStatus);
   1: }
   1: 
1418: nsresult
   1: nsGenericElement::GetListenerManager(PRBool aCreateIfNotFound,
   1:                                      nsIEventListenerManager** aResult)
   1: {
   1:   return nsContentUtils::GetListenerManager(this, aCreateIfNotFound, aResult);
   1: }
   1: 
1418: nsresult
1418: nsGenericElement::AddEventListenerByIID(nsIDOMEventListener *aListener,
1418:                                        const nsIID& aIID)
1418: {
1418:   nsCOMPtr<nsIEventListenerManager> elm;
1418:   nsresult rv = GetListenerManager(PR_TRUE, getter_AddRefs(elm));
1418:   if (elm) {
1418:     return elm->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
1418:   }
1418:   return rv;
1418: }
1418: 
1418: nsresult
1418: nsGenericElement::RemoveEventListenerByIID(nsIDOMEventListener *aListener,
1418:                                            const nsIID& aIID)
1418: {
1418:   nsCOMPtr<nsIEventListenerManager> elm;
1418:   GetListenerManager(PR_FALSE, getter_AddRefs(elm));
1418:   if (elm) {
1418:     return elm->RemoveEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
1418:   }
1418:   return NS_OK;
1418: }
1418: 
1418: nsresult
1418: nsGenericElement::GetSystemEventGroup(nsIDOMEventGroup** aGroup)
1418: {
1418:   nsCOMPtr<nsIEventListenerManager> elm;
1418:   nsresult rv = GetListenerManager(PR_TRUE, getter_AddRefs(elm));
1418:   if (elm) {
1418:     return elm->GetSystemEventGroupLM(aGroup);
1418:   }
1418:   return rv;
1418: }
1418: 
   1: nsINode::nsSlots*
   1: nsINode::CreateSlots()
   1: {
   1:   return new nsSlots(mFlagsOrSlots);
   1: }
   1: 
   1: void
   1: nsINode::AddMutationObserver(nsIMutationObserver* aMutationObserver)
   1: {
   1:   nsSlots* slots = GetSlots();
   1:   if (slots) {
   1:     slots->mMutationObservers.AppendObserver(aMutationObserver);
   1:   }
   1: }
   1: 
   1: void
   1: nsINode::RemoveMutationObserver(nsIMutationObserver* aMutationObserver)
   1: {
   1:   nsSlots* slots = GetExistingSlots();
   1:   if (slots) {
   1:     slots->mMutationObservers.RemoveObserver(aMutationObserver);
   1:   }
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: void
   1: nsIContent::SetNativeAnonymous(PRBool aAnonymous)
   1: {
   1:   if (aAnonymous) {
   1:     SetFlags(NODE_IS_ANONYMOUS);
   1:     SetFlags(NODE_IS_ANONYMOUS_FOR_EVENTS);
   1:   } else {
   1:     UnsetFlags(NODE_IS_ANONYMOUS);
   1:     UnsetFlags(NODE_IS_ANONYMOUS_FOR_EVENTS);
   1:   }
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: nsChildContentList::~nsChildContentList()
   1: {
   1:   MOZ_COUNT_DTOR(nsChildContentList);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsChildContentList::GetLength(PRUint32* aLength)
   1: {
   1:   *aLength = mNode ? mNode->GetChildCount() : 0;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsChildContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
   1: {
   1:   if (mNode) {
   1:     nsIContent *content = mNode->GetChildAt(aIndex);
   1:     if (content) {
   1:       return CallQueryInterface(content, aReturn);
   1:     }
   1:   }
   1: 
   1:   *aReturn = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_1(nsNode3Tearoff, mContent)
   1: 
 791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNode3Tearoff)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3Node)
   1: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
   1: 
   1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNode3Tearoff)
   1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNode3Tearoff)
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::GetBaseURI(nsAString& aURI)
   1: {
   1:   nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
   1:   nsCAutoString spec;
   1: 
   1:   if (baseURI) {
   1:     baseURI->GetSpec(spec);
   1:   }
   1: 
   1:   CopyUTF8toUTF16(spec, aURI);
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::GetTextContent(nsAString &aTextContent)
   1: {
   1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
   1:   NS_ASSERTION(node, "We have an nsIContent which doesn't support nsIDOMNode");
   1: 
   1:   PRUint16 nodeType;
   1:   node->GetNodeType(&nodeType);
   1:   if (nodeType == nsIDOMNode::DOCUMENT_TYPE_NODE ||
   1:       nodeType == nsIDOMNode::NOTATION_NODE) {
   1:     SetDOMStringToNull(aTextContent);
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   if (nodeType == nsIDOMNode::TEXT_NODE ||
   1:       nodeType == nsIDOMNode::CDATA_SECTION_NODE ||
   1:       nodeType == nsIDOMNode::COMMENT_NODE ||
   1:       nodeType == nsIDOMNode::PROCESSING_INSTRUCTION_NODE) {
   1:     return node->GetNodeValue(aTextContent);
   1:   }
   1: 
   1:   nsContentUtils::GetNodeTextContent(mContent, PR_TRUE, aTextContent);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::SetTextContent(const nsAString &aTextContent)
   1: {
  62:   // Batch possible DOMSubtreeModified events.
  62:   mozAutoSubtreeModified subtree(mContent->GetOwnerDoc(), nsnull);
  62: 
   1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
   1:   NS_ASSERTION(node, "We have an nsIContent which doesn't support nsIDOMNode");
   1: 
   1:   PRUint16 nodeType;
   1:   node->GetNodeType(&nodeType);
   1:   if (nodeType == nsIDOMNode::DOCUMENT_TYPE_NODE ||
   1:       nodeType == nsIDOMNode::NOTATION_NODE) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   if (nodeType == nsIDOMNode::TEXT_NODE ||
   1:       nodeType == nsIDOMNode::CDATA_SECTION_NODE ||
   1:       nodeType == nsIDOMNode::COMMENT_NODE ||
   1:       nodeType == nsIDOMNode::PROCESSING_INSTRUCTION_NODE) {
   1:     return node->SetNodeValue(aTextContent);
   1:   }
   1: 
   1:   return nsContentUtils::SetNodeTextContent(mContent, aTextContent, PR_FALSE);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::CompareDocumentPosition(nsIDOMNode* aOther,
   1:                                         PRUint16* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aOther);
   1: 
   1:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
   1:   NS_ENSURE_TRUE(other, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
   1: 
   1:   *aReturn = nsContentUtils::ComparePosition(other, mContent);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::IsSameNode(nsIDOMNode* aOther,
   1:                            PRBool* aReturn)
   1: {
   1:   nsCOMPtr<nsIContent> other(do_QueryInterface(aOther));
   1:   *aReturn = mContent == other;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsNode3Tearoff::AreNodesEqual(nsIContent* aContent1,
   1:                               nsIContent* aContent2)
   1: {
   1:   // We use nsIContent instead of nsINode for the attributes of elements.
   1: 
   1:   NS_PRECONDITION(aContent1 && aContent2, "Who called AreNodesEqual?");
   1: 
   1:   nsAutoString string1, string2;
   1: 
   1:   // Prefix, namespace URI, local name, node name check.
   1:   if (!aContent1->NodeInfo()->Equals(aContent2->NodeInfo())) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   if (aContent1->Tag() == nsGkAtoms::documentTypeNodeName) {
   1:     nsCOMPtr<nsIDOMDocumentType> docType1 = do_QueryInterface(aContent1);
   1:     nsCOMPtr<nsIDOMDocumentType> docType2 = do_QueryInterface(aContent2);
   1: 
   1:     NS_ASSERTION(docType1 && docType2, "Why don't we have a document type node?");
   1: 
   1:     // Public ID
   1:     docType1->GetPublicId(string1);
   1:     docType2->GetPublicId(string2);
   1: 
   1:     if (!string1.Equals(string2)) {
   1:       return PR_FALSE;
   1:     }
   1: 
   1:     // System ID
   1:     docType1->GetSystemId(string1);
   1:     docType2->GetSystemId(string2);
   1: 
   1:     if (!string1.Equals(string2)) {
   1:       return PR_FALSE;
   1:     }
   1: 
   1:     // Internal subset
   1:     docType1->GetInternalSubset(string1);
   1:     docType2->GetInternalSubset(string2);
   1: 
   1:     if (!string1.Equals(string2)) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   if (aContent1->IsNodeOfType(nsINode::eELEMENT)) {
   1:     // aContent1 is an element.  Do the check on attributes.
   1:     PRUint32 attrCount = aContent1->GetAttrCount();
   1:     if (attrCount != aContent2->GetAttrCount()) {
   1:       return PR_FALSE;
   1:     }
   1: 
   1:     // Iterate over attributes.
   1:     for (PRUint32 i = 0; i < attrCount; ++i) {
   1:       const nsAttrName* attrName1 = aContent1->GetAttrNameAt(i);
   1: #ifdef DEBUG
   1:       PRBool hasAttr =
   1: #endif
   1:       aContent1->GetAttr(attrName1->NamespaceID(),
   1:                          attrName1->LocalName(),
   1:                          string1);
   1:       NS_ASSERTION(hasAttr, "Why don't we have an attr?");
   1: 
   1:       if (!aContent2->AttrValueIs(attrName1->NamespaceID(),
   1:                                   attrName1->LocalName(),
   1:                                   string1,
   1:                                   eCaseMatters)) {
   1:         return PR_FALSE;
   1:       }
   1:     }
   1:   } else {
   1:     // aContent1 is not an element.  Node value check.
   1:     nsCOMPtr<nsIDOMNode> domNode1 = do_QueryInterface(aContent1);
   1:     nsCOMPtr<nsIDOMNode> domNode2 = do_QueryInterface(aContent2);
   1:     NS_ASSERTION(domNode1 && domNode2, "How'd we get nsIContent without nsIDOMNode?");
   1:     domNode1->GetNodeValue(string1);
   1:     domNode2->GetNodeValue(string2);
   1:     if (!string1.Equals(string2)) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   // Child nodes count.
   1:   PRUint32 childCount = aContent1->GetChildCount();
   1:   if (childCount != aContent2->GetChildCount()) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   // Iterate over child nodes.
   1:   for (PRUint32 i = 0; i < childCount; ++i) {
   1:     nsIContent* child1 = aContent1->GetChildAt(i);
   1:     nsIContent* child2 = aContent2->GetChildAt(i);
   1:     if (!AreNodesEqual(child1, child2)) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::IsEqualNode(nsIDOMNode* aOther, PRBool* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aOther);
   1: 
   1:   *aReturn = PR_FALSE;
   1: 
   1:   // Since we implement nsIContent, aOther must as well.
   1:   nsCOMPtr<nsIContent> aOtherContent = do_QueryInterface(aOther);
   1:   // Documents and attributes don't implement nsIContent.
   1:   if (!aOtherContent) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   *aReturn = nsNode3Tearoff::AreNodesEqual(mContent, aOtherContent);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::GetFeature(const nsAString& aFeature,
   1:                            const nsAString& aVersion,
   1:                            nsISupports** aReturn)
   1: {
   1:   return nsGenericElement::InternalGetFeature(this, aFeature, aVersion, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::SetUserData(const nsAString& aKey,
   1:                             nsIVariant* aData,
   1:                             nsIDOMUserDataHandler* aHandler,
   1:                             nsIVariant** aResult)
   1: {
1391:   return nsNodeUtils::SetUserData(mContent, aKey, aData, aHandler, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::GetUserData(const nsAString& aKey,
   1:                             nsIVariant** aResult)
   1: {
1391:   return nsNodeUtils::GetUserData(mContent, aKey, aResult);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::LookupPrefix(const nsAString& aNamespaceURI,
   1:                              nsAString& aPrefix)
   1: {
   1:   SetDOMStringToNull(aPrefix);
   1: 
   1:   // XXX Waiting for DOM spec to list error codes.
   1: 
   1:   // Trace up the content parent chain looking for the namespace
   1:   // declaration that defines the aNamespaceURI namespace. Once found,
   1:   // return the prefix (i.e. the attribute localName).
   1:   for (nsIContent* content = mContent; content;
   1:        content = content->GetParent()) {
   1:     PRUint32 attrCount = content->GetAttrCount();
   1: 
   1:     for (PRUint32 i = 0; i < attrCount; ++i) {
   1:       const nsAttrName* name = content->GetAttrNameAt(i);
   1: 
   1:       if (name->NamespaceEquals(kNameSpaceID_XMLNS) &&
   1:           content->AttrValueIs(kNameSpaceID_XMLNS, name->LocalName(),
   1:                                aNamespaceURI, eCaseMatters)) {
   1:         // If the localName is "xmlns", the prefix we output should be
   1:         // null.
   1:         if (name->LocalName() != nsGkAtoms::xmlns) {
   1:           name->LocalName()->ToString(aPrefix);
   1:         }
   1: 
   1:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::LookupNamespaceURI(const nsAString& aNamespacePrefix,
   1:                                    nsAString& aNamespaceURI)
   1: {
   1:   if (NS_FAILED(nsContentUtils::LookupNamespaceURI(mContent,
   1:                                                    aNamespacePrefix,
   1:                                                    aNamespaceURI))) {
   1:     SetDOMStringToNull(aNamespaceURI);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNode3Tearoff::IsDefaultNamespace(const nsAString& aNamespaceURI,
   1:                                    PRBool* aReturn)
   1: {
   1:   nsAutoString defaultNamespace;
   1:   LookupNamespaceURI(EmptyString(), defaultNamespace);
   1:   *aReturn = aNamespaceURI.Equals(defaultNamespace);
   1:   return NS_OK;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: 
   1: NS_INTERFACE_MAP_BEGIN(nsNSElementTearoff)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSElement)
   1: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
   1: 
   1: NS_IMPL_ADDREF(nsNSElementTearoff)
   1: NS_IMPL_RELEASE(nsNSElementTearoff)
   1: 
   1: NS_IMETHODIMP
   1: nsNSElementTearoff::GetElementsByClassName(const nsAString& aClasses,
   1:                                            nsIDOMNodeList** aReturn)
   1: {
   1:   return nsDocument::GetElementsByClassNameHelper(mContent, aClasses, aReturn);
   1: }
   1: 
2014: static nsPoint
2014: GetOffsetFromInitialContainingBlock(nsIFrame* aFrame)
2014: {
2014:   nsPresContext* presContext = aFrame->PresContext();
2014:   nsIPresShell* shell = presContext->PresShell();
2014:   nsIFrame* rootScrollFrame = shell->GetRootScrollFrame();
2014:   nsPoint pt(0,0);
2014:   nsIFrame* child = aFrame;
2014:   for (nsIFrame* p = aFrame->GetParent(); p && p != rootScrollFrame;
2014:        p = p->GetParent()) {
2014:     pt += p->GetPositionOfChildIgnoringScrolling(child);
2014:     // coordinates of elements inside a foreignobject are relative to the top-left
2014:     // of the nearest foreignobject
2014:     if (p->IsFrameOfType(nsIFrame::eSVGForeignObject))
2014:       return pt;
2014:     child = p;
2014:   }
2014:   return pt;
2014: }
2014: 
2014: static double
2014: RoundFloat(double aValue)
2014: {
2014:   return floor(aValue + 0.5);
2014: }
2014: 
2014: static void
2014: SetTextRectangle(const nsRect& aLayoutRect, nsPresContext* aPresContext,
2014:                  nsTextRectangle* aRect)
2014: {
2014:   double scale = 4096.0;
2014:   // Round to the nearest 1/scale units. We choose scale so it can be represented
2014:   // exactly by machine floating point.
2014:   double scaleInv = 1/scale;
2014:   double t2pScaled = scale/aPresContext->AppUnitsPerCSSPixel();
2014:   aRect->SetRect(RoundFloat(aLayoutRect.x*t2pScaled)*scaleInv,
2014:                  RoundFloat(aLayoutRect.y*t2pScaled)*scaleInv,
2014:                  RoundFloat(aLayoutRect.width*t2pScaled)*scaleInv,
2014:                  RoundFloat(aLayoutRect.height*t2pScaled)*scaleInv);
2014: }
2014: 
2014: static PRBool
2014: TryGetSVGBoundingRect(nsIFrame* aFrame, nsRect* aRect)
2014: {
2014: #ifdef MOZ_SVG
2014:   nsRect r;
2014:   nsIFrame* outer = nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(aFrame, &r);
2014:   if (!outer)
2014:     return PR_FALSE;
2014: 
2014:   // r is in pixels relative to 'outer', get it into twips
2014:   // relative to ICB origin
2014:   r.ScaleRoundOut(1.0/aFrame->PresContext()->AppUnitsPerCSSPixel());
2014:   *aRect = r + GetOffsetFromInitialContainingBlock(outer);
2014:   return PR_TRUE;
2014: #else
2014:   return PR_FALSE;
2014: #endif
2014: }
2014: 
2014: NS_IMETHODIMP
2014: nsNSElementTearoff::GetBoundingClientRect(nsIDOMTextRectangle** aResult)
2014: {
2014:   // Weak ref, since we addref it below
2014:   nsTextRectangle* rect = new nsTextRectangle();
2014:   if (!rect)
2014:     return NS_ERROR_OUT_OF_MEMORY;
2014: 
2014:   NS_ADDREF(*aResult = rect);
2014:   
2014:   nsIFrame* frame = mContent->GetPrimaryFrame(Flush_Layout);  
2014:   if (!frame) {
2014:     // display:none, perhaps? Return the empty rect
2014:     return NS_OK;
2014:   }
2014:   
2014:   nsRect r;
2014:   if (TryGetSVGBoundingRect(frame, &r)) {
2014:     // Currently SVG frames don't have continuations but I don't want things to
2014:     // break if that changes.
2014:     nsIFrame* next;
2014:     while ((next = frame->GetNextContinuation()) != nsnull) {
2014:       frame = next;
2014:       nsRect nextRect;
2014: #ifdef DEBUG
2014:       PRBool isSVG =
2014: #endif
2014:         TryGetSVGBoundingRect(frame, &nextRect);
2014:       NS_ASSERTION(isSVG, "SVG frames must have SVG continuations");
2014:       r.UnionRect(r, nextRect);
2014:     }
2014:   } else {
2014:     r = nsLayoutUtils::GetAllInFlowBoundingRect(frame) +
2014:         GetOffsetFromInitialContainingBlock(frame);
2014:   }
2014:   SetTextRectangle(r, frame->PresContext(), rect);
2014:   return NS_OK;
2014: }
2014: 
2014: NS_IMETHODIMP
2014: nsNSElementTearoff::GetClientRects(nsIDOMTextRectangleList** aResult)
2014: {
2014:   // Weak ref, since we addref it below
2014:   nsTextRectangleList* rectList = new nsTextRectangleList();
2014:   if (!rectList)
2014:     return NS_ERROR_OUT_OF_MEMORY;
2014:   
2014:   NS_ADDREF(*aResult = rectList);
2014:   
2014:   nsIFrame* frame = mContent->GetPrimaryFrame(Flush_Layout);
2014:   if (!frame) {
2014:     // display:none, perhaps? Return an empty list
2014:     return NS_OK;
2014:   }
2014:   
2014:   nsPresContext* presContext = frame->PresContext();
2014:   for (nsIFrame* f = frame; f; f = f->GetNextContinuation()) {
2014:     nsRefPtr<nsTextRectangle> rect = new nsTextRectangle();
2014:     if (!rect)
2014:       return NS_ERROR_OUT_OF_MEMORY;
2014:     
2014:     nsRect r;
2014:     if (!TryGetSVGBoundingRect(f, &r)) {
2014:       r = nsRect(GetOffsetFromInitialContainingBlock(f), f->GetSize());
2014:     }
2014:     SetTextRectangle(r, presContext, rect);
2014:     rectList->Append(rect);
2014:   }
2014:   return NS_OK;
2014: }
2014: 
   1: //----------------------------------------------------------------------
   1: 
   1: 
   1: NS_IMPL_ISUPPORTS1(nsNodeWeakReference,
   1:                    nsIWeakReference)
   1: 
   1: nsNodeWeakReference::~nsNodeWeakReference()
   1: {
   1:   if (mNode) {
   1:     NS_ASSERTION(mNode->GetSlots() &&
   1:                  mNode->GetSlots()->mWeakReference == this,
   1:                  "Weak reference has wrong value");
   1:     mNode->GetSlots()->mWeakReference = nsnull;
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsNodeWeakReference::QueryReferent(const nsIID& aIID, void** aInstancePtr)
   1: {
   1:   return mNode ? mNode->QueryInterface(aIID, aInstancePtr) :
   1:                  NS_ERROR_NULL_POINTER;
   1: }
   1: 
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSupportsWeakRefTearoff, mNode)
   1: 
 791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSupportsWeakRefTearoff)
   1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
   1: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
   1: 
   1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSupportsWeakRefTearoff)
   1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSupportsWeakRefTearoff)
   1: 
   1: NS_IMETHODIMP
   1: nsNodeSupportsWeakRefTearoff::GetWeakReference(nsIWeakReference** aInstancePtr)
   1: {
   1:   nsINode::nsSlots* slots = mNode->GetSlots();
   1:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   if (!slots->mWeakReference) {
   1:     slots->mWeakReference = new nsNodeWeakReference(mNode);
   1:     NS_ENSURE_TRUE(slots->mWeakReference, NS_ERROR_OUT_OF_MEMORY);
   1:   }
   1: 
   1:   NS_ADDREF(*aInstancePtr = slots->mWeakReference);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: nsDOMEventRTTearoff *
   1: nsDOMEventRTTearoff::mCachedEventTearoff[NS_EVENT_TEAROFF_CACHE_SIZE];
   1: 
   1: PRUint32 nsDOMEventRTTearoff::mCachedEventTearoffCount = 0;
   1: 
   1: 
   1: nsDOMEventRTTearoff::nsDOMEventRTTearoff(nsIContent *aContent)
   1:   : mContent(aContent)
   1: {
   1: }
   1: 
   1: nsDOMEventRTTearoff::~nsDOMEventRTTearoff()
   1: {
   1: }
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_1(nsDOMEventRTTearoff, mContent)
   1: 
 791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMEventRTTearoff)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3EventTarget)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEventTarget)
   1: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
   1: 
   1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsDOMEventRTTearoff,
   1:                                           nsIDOMEventTarget)
   1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsDOMEventRTTearoff,
   1:                                                         nsIDOMEventTarget,
   1:                                                         LastRelease())
   1: 
   1: nsDOMEventRTTearoff *
   1: nsDOMEventRTTearoff::Create(nsIContent *aContent)
   1: {
   1:   if (mCachedEventTearoffCount) {
   1:     // We have cached unused instances of this class, return a cached
   1:     // instance in stead of always creating a new one.
   1:     nsDOMEventRTTearoff *tearoff =
   1:       mCachedEventTearoff[--mCachedEventTearoffCount];
   1: 
   1:     // Set the back pointer to the content object
   1:     tearoff->mContent = aContent;
   1: 
   1:     return tearoff;
   1:   }
   1: 
   1:   // The cache is empty, this means we haveto create a new instance.
   1:   return new nsDOMEventRTTearoff(aContent);
   1: }
   1: 
   1: // static
   1: void
   1: nsDOMEventRTTearoff::Shutdown()
   1: {
   1:   // Clear our cache.
   1:   while (mCachedEventTearoffCount) {
   1:     delete mCachedEventTearoff[--mCachedEventTearoffCount];
   1:   }
   1: }
   1: 
   1: void
   1: nsDOMEventRTTearoff::LastRelease()
   1: {
   1:   if (mCachedEventTearoffCount < NS_EVENT_TEAROFF_CACHE_SIZE) {
   1:     // There's still space in the cache for one more instance, put
   1:     // this instance in the cache in stead of deleting it.
   1:     mCachedEventTearoff[mCachedEventTearoffCount++] = this;
   1: 
   1:     // Don't set mContent to null directly since setting mContent to null
   1:     // could result in code that grabs a tearoff from the cache and we don't
   1:     // want to get reused while still being torn down.
   1:     // See bug 330526.
   1:     nsCOMPtr<nsIContent> kungFuDeathGrip;
   1:     kungFuDeathGrip.swap(mContent);
   1: 
   1:     // The refcount balancing and destructor re-entrancy protection
   1:     // code in Release() sets mRefCnt to 1 so we have to set it to 0
   1:     // here to prevent leaks
   1:     mRefCnt = 0;
   1: 
   1:     return;
   1:   }
   1: 
   1:   delete this;
   1: }
   1: 
   1: nsresult
   1: nsDOMEventRTTearoff::GetDOM3EventTarget(nsIDOM3EventTarget **aTarget)
   1: {
   1:   nsCOMPtr<nsIEventListenerManager> listener_manager;
   1:   nsresult rv =
   1:     mContent->GetListenerManager(PR_TRUE, getter_AddRefs(listener_manager));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return CallQueryInterface(listener_manager, aTarget);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::GetScriptTypeID(PRUint32 *aLang)
   1: {
   1:     *aLang = mContent->GetScriptTypeID();
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::SetScriptTypeID(PRUint32 aLang)
   1: {
   1:     return mContent->SetScriptTypeID(aLang);
   1: }
   1: 
   1: 
   1: // nsIDOMEventTarget
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::AddEventListener(const nsAString& aType,
   1:                                       nsIDOMEventListener *aListener,
   1:                                       PRBool useCapture)
   1: {
   1:   return
   1:     AddEventListener(aType, aListener, useCapture,
   1:                      !nsContentUtils::IsChromeDoc(mContent->GetOwnerDoc()));
   1: }
   1: 
   1: NS_IMETHODIMP
1418: nsDOMEventRTTearoff::RemoveEventListener(const nsAString& aType,
1418:                                          nsIDOMEventListener* aListener,
1418:                                          PRBool aUseCapture)
   1: {
1418:   return RemoveGroupedEventListener(aType, aListener, aUseCapture, nsnull);
1418: }
1418: 
1418: NS_IMETHODIMP
1418: nsDOMEventRTTearoff::DispatchEvent(nsIDOMEvent *aEvt, PRBool* _retval)
1418: {
1418:   nsCOMPtr<nsIEventListenerManager> listener_manager;
1418:   nsresult rv =
1418:     mContent->GetListenerManager(PR_TRUE, getter_AddRefs(listener_manager));
1373:   NS_ENSURE_SUCCESS(rv, rv);
1418:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(listener_manager);
1418:   NS_ENSURE_STATE(target);
1418:   return target->DispatchEvent(aEvt, _retval);
   1: }
   1: 
   1: // nsIDOM3EventTarget
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::AddGroupedEventListener(const nsAString& aType,
   1:                                              nsIDOMEventListener *aListener,
   1:                                              PRBool aUseCapture,
   1:                                              nsIDOMEventGroup *aEvtGrp)
   1: {
   1:   nsCOMPtr<nsIDOM3EventTarget> event_target;
   1:   nsresult rv = GetDOM3EventTarget(getter_AddRefs(event_target));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return event_target->AddGroupedEventListener(aType, aListener, aUseCapture,
   1:                                                aEvtGrp);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::RemoveGroupedEventListener(const nsAString& aType,
   1:                                                 nsIDOMEventListener *aListener,
   1:                                                 PRBool aUseCapture,
   1:                                                 nsIDOMEventGroup *aEvtGrp)
   1: {
   1:   nsCOMPtr<nsIDOM3EventTarget> event_target;
   1:   nsresult rv = GetDOM3EventTarget(getter_AddRefs(event_target));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return event_target->RemoveGroupedEventListener(aType, aListener,
   1:                                                   aUseCapture, aEvtGrp);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::CanTrigger(const nsAString & type, PRBool *_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::IsRegisteredHere(const nsAString & type, PRBool *_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: // nsIDOMNSEventTarget
   1: NS_IMETHODIMP
   1: nsDOMEventRTTearoff::AddEventListener(const nsAString& aType,
   1:                                       nsIDOMEventListener *aListener,
   1:                                       PRBool aUseCapture,
   1:                                       PRBool aWantsUntrusted)
   1: {
   1:   nsCOMPtr<nsIEventListenerManager> listener_manager;
   1:   nsresult rv =
   1:     mContent->GetListenerManager(PR_TRUE, getter_AddRefs(listener_manager));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
   1: 
   1:   if (aWantsUntrusted) {
   1:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
   1:   }
   1: 
   1:   return listener_manager->AddEventListenerByType(aListener, aType, flags,
   1:                                                   nsnull);
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: PRUint32 nsMutationGuard::sMutationCount = 0;
   1: 
   1: nsGenericElement::nsDOMSlots::nsDOMSlots(PtrBits aFlags)
   1:   : nsINode::nsSlots(aFlags),
   1:     mBindingParent(nsnull)
   1: {
   1: }
   1: 
   1: nsGenericElement::nsDOMSlots::~nsDOMSlots()
   1: {
   1:   if (mStyle) {
   1:     mStyle->DropReference();
   1:   }
   1: 
   1:   if (mAttributeMap) {
   1:     mAttributeMap->DropReference();
   1:   }
   1: }
   1: 
   1: nsGenericElement::nsGenericElement(nsINodeInfo *aNodeInfo)
   1:   : nsIContent(aNodeInfo)
   1: {
   1:   // Set the default scriptID to JS - but skip SetScriptTypeID as it
   1:   // does extra work we know isn't necessary here...
   1:   SetFlags(nsIProgrammingLanguage::JAVASCRIPT << NODE_SCRIPT_TYPE_OFFSET);
   1: }
   1: 
   1: nsGenericElement::~nsGenericElement()
   1: {
   1:   NS_PRECONDITION(!IsInDoc(),
   1:                   "Please remove this from the document properly");
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetNodeName(nsAString& aNodeName)
   1: {
   1:   mNodeInfo->GetQualifiedName(aNodeName);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetLocalName(nsAString& aLocalName)
   1: {
   1:   mNodeInfo->GetLocalName(aLocalName);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetNodeValue(nsAString& aNodeValue)
   1: {
   1:   SetDOMStringToNull(aNodeValue);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::SetNodeValue(const nsAString& aNodeValue)
   1: {
   1:   // The DOM spec says that when nodeValue is defined to be null "setting it
   1:   // has no effect", so we don't throw an exception.
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetNodeType(PRUint16* aNodeType)
   1: {
   1:   *aNodeType = (PRUint16)nsIDOMNode::ELEMENT_NODE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetParentNode(nsIDOMNode** aParentNode)
   1: {
   1:   *aParentNode = nsnull;
   1:   nsINode *parent = GetNodeParent();
   1: 
   1:   return parent ? CallQueryInterface(parent, aParentNode) : NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetPreviousSibling(nsIDOMNode** aPrevSibling)
   1: {
   1:   *aPrevSibling = nsnull;
   1: 
   1:   nsINode *parent = GetNodeParent();
   1:   if (!parent) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRInt32 pos = parent->IndexOf(this);
   1:   nsIContent *sibling = parent->GetChildAt(pos - 1);
   1: 
   1:   return sibling ? CallQueryInterface(sibling, aPrevSibling) : NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetNextSibling(nsIDOMNode** aNextSibling)
   1: {
   1:   *aNextSibling = nsnull;
   1: 
   1:   nsINode *parent = GetNodeParent();
   1:   if (!parent) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   PRInt32 pos = parent->IndexOf(this);
   1:   nsIContent *sibling = parent->GetChildAt(pos + 1);
   1: 
   1:   return sibling ? CallQueryInterface(sibling, aNextSibling) : NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
   1: {
   1:   nsIDocument *doc = GetOwnerDoc();
   1:   if (doc) {
   1:     return CallQueryInterface(doc, aOwnerDocument);
   1:   }
   1: 
   1:   *aOwnerDocument = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetNamespaceURI(nsAString& aNamespaceURI)
   1: {
   1:   return mNodeInfo->GetNamespaceURI(aNamespaceURI);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetPrefix(nsAString& aPrefix)
   1: {
   1:   mNodeInfo->GetPrefix(aPrefix);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::SetPrefix(const nsAString& aPrefix)
   1: {
   1:   // XXX: Validate the prefix string!
   1: 
   1:   nsCOMPtr<nsIAtom> prefix;
   1: 
   1:   if (!aPrefix.IsEmpty()) {
   1:     prefix = do_GetAtom(aPrefix);
   1:     NS_ENSURE_TRUE(prefix, NS_ERROR_OUT_OF_MEMORY);
   1:   }
   1: 
   1:   if (!nsContentUtils::IsValidNodeName(mNodeInfo->NameAtom(), prefix,
   1:                                        mNodeInfo->NamespaceID())) {
   1:     return NS_ERROR_DOM_NAMESPACE_ERR;
   1:   }
   1: 
   1:   nsCOMPtr<nsINodeInfo> newNodeInfo;
   1:   nsresult rv = nsContentUtils::PrefixChanged(mNodeInfo, prefix,
   1:                                               getter_AddRefs(newNodeInfo));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   mNodeInfo = newNodeInfo;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::InternalIsSupported(nsISupports* aObject,
   1:                                       const nsAString& aFeature,
   1:                                       const nsAString& aVersion,
   1:                                       PRBool* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   *aReturn = PR_FALSE;
   1: 
   1:   // Convert the incoming UTF16 strings to raw char*'s to save us some
   1:   // code when doing all those string compares.
   1:   NS_ConvertUTF16toUTF8 feature(aFeature);
   1:   NS_ConvertUTF16toUTF8 version(aVersion);
   1: 
   1:   const char *f = feature.get();
   1:   const char *v = version.get();
   1: 
   1:   if (PL_strcasecmp(f, "XML") == 0 ||
   1:       PL_strcasecmp(f, "HTML") == 0) {
   1:     if (aVersion.IsEmpty() ||
   1:         PL_strcmp(v, "1.0") == 0 ||
   1:         PL_strcmp(v, "2.0") == 0) {
   1:       *aReturn = PR_TRUE;
   1:     }
   1:   } else if (PL_strcasecmp(f, "Views") == 0 ||
   1:              PL_strcasecmp(f, "StyleSheets") == 0 ||
   1:              PL_strcasecmp(f, "Core") == 0 ||
   1:              PL_strcasecmp(f, "CSS") == 0 ||
   1:              PL_strcasecmp(f, "CSS2") == 0 ||
   1:              PL_strcasecmp(f, "Events") == 0 ||
   1:              PL_strcasecmp(f, "UIEvents") == 0 ||
   1:              PL_strcasecmp(f, "MouseEvents") == 0 ||
   1:              // Non-standard!
   1:              PL_strcasecmp(f, "MouseScrollEvents") == 0 ||
   1:              PL_strcasecmp(f, "HTMLEvents") == 0 ||
   1:              PL_strcasecmp(f, "Range") == 0 ||
   1:              PL_strcasecmp(f, "XHTML") == 0) {
   1:     if (aVersion.IsEmpty() ||
   1:         PL_strcmp(v, "2.0") == 0) {
   1:       *aReturn = PR_TRUE;
   1:     }
   1:   } else if (PL_strcasecmp(f, "XPath") == 0) {
   1:     if (aVersion.IsEmpty() ||
   1:         PL_strcmp(v, "3.0") == 0) {
   1:       *aReturn = PR_TRUE;
   1:     }
   1:   }
   1: #ifdef MOZ_SVG
   1:   else if (PL_strcasecmp(f, "SVGEvents") == 0 ||
   1:            PL_strcasecmp(f, "SVGZoomEvents") == 0 ||
   1:            NS_SVG_TestFeature(aFeature)) {
   1:     if (aVersion.IsEmpty() ||
   1:         PL_strcmp(v, "1.0") == 0 ||
   1:         PL_strcmp(v, "1.1") == 0) {
   1:       *aReturn = PR_TRUE;
   1:     }
   1:   }
   1: #endif /* MOZ_SVG */
   1:   else {
   1:     nsCOMPtr<nsIDOMNSFeatureFactory> factory =
   1:       GetDOMFeatureFactory(aFeature, aVersion);
   1: 
   1:     if (factory) {
   1:       factory->HasFeature(aObject, aFeature, aVersion, aReturn);
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::InternalGetFeature(nsISupports* aObject,
   1:                                     const nsAString& aFeature,
   1:                                     const nsAString& aVersion,
   1:                                     nsISupports** aReturn)
   1: {
   1:   *aReturn = nsnull;
   1:   nsCOMPtr<nsIDOMNSFeatureFactory> factory =
   1:     GetDOMFeatureFactory(aFeature, aVersion);
   1: 
   1:   if (factory) {
   1:     factory->GetFeature(aObject, aFeature, aVersion, aReturn);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: already_AddRefed<nsIDOMNSFeatureFactory>
   1: nsGenericElement::GetDOMFeatureFactory(const nsAString& aFeature,
   1:                                        const nsAString& aVersion)
   1: {
   1:   nsIDOMNSFeatureFactory *factory = nsnull;
   1:   nsCOMPtr<nsICategoryManager> categoryManager =
   1:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
   1:   if (categoryManager) {
   1:     nsCAutoString featureCategory(NS_DOMNS_FEATURE_PREFIX);
   1:     AppendUTF16toUTF8(aFeature, featureCategory);
   1:     nsXPIDLCString contractID;
   1:     nsresult rv = categoryManager->GetCategoryEntry(featureCategory.get(),
   1:                                                     NS_ConvertUTF16toUTF8(aVersion).get(),
   1:                                                     getter_Copies(contractID));
   1:     if (NS_SUCCEEDED(rv)) {
   1:       CallGetService(contractID.get(), &factory);  // addrefs
   1:     }
   1:   }
   1:   return factory;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::IsSupported(const nsAString& aFeature,
   1:                               const nsAString& aVersion,
   1:                               PRBool* aReturn)
   1: {
   1:   return InternalIsSupported(this, aFeature, aVersion, aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::HasAttributes(PRBool* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1: 
   1:   *aReturn = GetAttrCount() > 0;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aAttributes);
   1:   nsDOMSlots *slots = GetDOMSlots();
   1: 
   1:   if (!slots) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   if (!slots->mAttributeMap) {
   1:     slots->mAttributeMap = new nsDOMAttributeMap(this);
   1:     if (!slots->mAttributeMap) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     if (!slots->mAttributeMap->Init()) {
   1:       slots->mAttributeMap = nsnull;
   1:       return NS_ERROR_FAILURE;
   1:     }
   1:   }
   1: 
   1:   NS_ADDREF(*aAttributes = slots->mAttributeMap);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetChildNodes(nsIDOMNodeList** aChildNodes)
   1: {
   1:   nsSlots *slots = GetSlots();
   1: 
   1:   if (!slots) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   if (!slots->mChildNodes) {
   1:     slots->mChildNodes = new nsChildContentList(this);
   1:     if (!slots->mChildNodes) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     NS_ADDREF(slots->mChildNodes);
   1:   }
   1: 
   1:   NS_ADDREF(*aChildNodes = slots->mChildNodes);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::HasChildNodes(PRBool* aReturn)
   1: {
   1:   *aReturn = mAttrsAndChildren.ChildCount() > 0;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetFirstChild(nsIDOMNode** aNode)
   1: {
   1:   nsIContent *child = mAttrsAndChildren.GetSafeChildAt(0);
   1:   if (child) {
   1:     return CallQueryInterface(child, aNode);
   1:   }
   1: 
   1:   *aNode = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetLastChild(nsIDOMNode** aNode)
   1: {
   1:   PRUint32 count = mAttrsAndChildren.ChildCount();
   1:   
   1:   if (count > 0) {
   1:     return CallQueryInterface(mAttrsAndChildren.ChildAt(count - 1), aNode);
   1:   }
   1: 
   1:   *aNode = nsnull;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::GetTagName(nsAString& aTagName)
   1: {
   1:   mNodeInfo->GetQualifiedName(aTagName);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetAttribute(const nsAString& aName,
   1:                                nsAString& aReturn)
   1: {
   1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
   1: 
   1:   if (!name) {
   1:     if (mNodeInfo->NamespaceID() == kNameSpaceID_XUL) {
   1:       // XXX should be SetDOMStringToNull(aReturn);
   1:       // See bug 232598
   1:       aReturn.Truncate();
   1:     }
   1:     else {
   1:       SetDOMStringToNull(aReturn);
   1:     }
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   GetAttr(name->NamespaceID(), name->LocalName(), aReturn);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetAttribute(const nsAString& aName,
   1:                                const nsAString& aValue)
   1: {
   1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
   1: 
   1:   if (!name) {
   1:     nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aName);
   1:     NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:     return SetAttr(kNameSpaceID_None, nameAtom, aValue, PR_TRUE);
   1:   }
   1: 
   1:   return SetAttr(name->NamespaceID(), name->LocalName(), name->GetPrefix(),
   1:                  aValue, PR_TRUE);
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::RemoveAttribute(const nsAString& aName)
   1: {
   1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
   1: 
   1:   if (!name) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Hold a strong reference here so that the atom or nodeinfo doesn't go
   1:   // away during UnsetAttr. If it did UnsetAttr would be left with a
   1:   // dangling pointer as argument without knowing it.
   1:   nsAttrName tmp(*name);
   1: 
   1:   return UnsetAttr(name->NamespaceID(), name->LocalName(), PR_TRUE);
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetAttributeNode(const nsAString& aName,
   1:                                    nsIDOMAttr** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
   1:   nsresult rv = GetAttributes(getter_AddRefs(map));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> node;
   1:   rv = map->GetNamedItem(aName, getter_AddRefs(node));
   1: 
   1:   if (NS_SUCCEEDED(rv) && node) {
   1:     rv = CallQueryInterface(node, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetAttributeNode(nsIDOMAttr* aAttribute,
   1:                                    nsIDOMAttr** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   NS_ENSURE_ARG_POINTER(aAttribute);
   1: 
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
   1:   nsresult rv = GetAttributes(getter_AddRefs(map));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> returnNode;
   1:   rv = map->SetNamedItem(aAttribute, getter_AddRefs(returnNode));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (returnNode) {
   1:     rv = CallQueryInterface(returnNode, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::RemoveAttributeNode(nsIDOMAttr* aAttribute,
   1:                                       nsIDOMAttr** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   NS_ENSURE_ARG_POINTER(aAttribute);
   1: 
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
   1:   nsresult rv = GetAttributes(getter_AddRefs(map));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsAutoString name;
   1: 
   1:   rv = aAttribute->GetName(name);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     nsCOMPtr<nsIDOMNode> node;
   1:     rv = map->RemoveNamedItem(name, getter_AddRefs(node));
   1: 
   1:     if (NS_SUCCEEDED(rv) && node) {
   1:       rv = CallQueryInterface(node, aReturn);
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetElementsByTagName(const nsAString& aTagname,
   1:                                        nsIDOMNodeList** aReturn)
   1: {
   1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aTagname);
   1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   nsContentList *list = NS_GetContentList(this, nameAtom,
   1:                                           kNameSpaceID_Unknown).get();
   1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   // transfer ref to aReturn
   1:   *aReturn = list;
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetAttributeNS(const nsAString& aNamespaceURI,
   1:                                  const nsAString& aLocalName,
   1:                                  nsAString& aReturn)
   1: {
   1:   PRInt32 nsid =
   1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
   1: 
   1:   if (nsid == kNameSpaceID_Unknown) {
   1:     // Unknown namespace means no attr...
   1: 
   1:     aReturn.Truncate();
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
   1:   GetAttr(nsid, name, aReturn);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetAttributeNS(const nsAString& aNamespaceURI,
   1:                                  const nsAString& aQualifiedName,
   1:                                  const nsAString& aValue)
   1: {
   1:   nsCOMPtr<nsINodeInfo> ni;
   1:   nsresult rv =
   1:     nsContentUtils::GetNodeInfoFromQName(aNamespaceURI, aQualifiedName,
   1:                                          mNodeInfo->NodeInfoManager(),
   1:                                          getter_AddRefs(ni));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return SetAttr(ni->NamespaceID(), ni->NameAtom(), ni->GetPrefixAtom(),
   1:                  aValue, PR_TRUE);
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::RemoveAttributeNS(const nsAString& aNamespaceURI,
   1:                                     const nsAString& aLocalName)
   1: {
   1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
   1:   PRInt32 nsid =
   1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
   1: 
   1:   if (nsid == kNameSpaceID_Unknown) {
   1:     // Unknown namespace means no attr...
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsAutoString tmp;
   1:   UnsetAttr(nsid, name, PR_TRUE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetAttributeNodeNS(const nsAString& aNamespaceURI,
   1:                                      const nsAString& aLocalName,
   1:                                      nsIDOMAttr** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1: 
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
   1:   nsresult rv = GetAttributes(getter_AddRefs(map));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> node;
   1:   rv = map->GetNamedItemNS(aNamespaceURI, aLocalName, getter_AddRefs(node));
   1: 
   1:   if (NS_SUCCEEDED(rv) && node) {
   1:     rv = CallQueryInterface(node, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetAttributeNodeNS(nsIDOMAttr* aNewAttr,
   1:                                      nsIDOMAttr** aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1:   NS_ENSURE_ARG_POINTER(aNewAttr);
   1: 
   1:   *aReturn = nsnull;
   1: 
   1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
   1:   nsresult rv = GetAttributes(getter_AddRefs(map));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIDOMNode> returnNode;
   1:   rv = map->SetNamedItemNS(aNewAttr, getter_AddRefs(returnNode));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (returnNode) {
   1:     rv = CallQueryInterface(returnNode, aReturn);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
   1:                                          const nsAString& aLocalName,
   1:                                          nsIDOMNodeList** aReturn)
   1: {
   1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
   1: 
   1:   if (!aNamespaceURI.EqualsLiteral("*")) {
   1:     nsresult rv =
   1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
   1:                                                             nameSpaceId);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aLocalName);
   1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   nsContentList *list = NS_GetContentList(this, nameAtom, nameSpaceId).get();
   1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   // transfer ref to aReturn
   1:   *aReturn = list;
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::HasAttribute(const nsAString& aName, PRBool* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1: 
   1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
   1:   *aReturn = (name != nsnull);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::HasAttributeNS(const nsAString& aNamespaceURI,
   1:                                  const nsAString& aLocalName,
   1:                                  PRBool* aReturn)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aReturn);
   1: 
   1:   PRInt32 nsid =
   1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
   1: 
   1:   if (nsid == kNameSpaceID_Unknown) {
   1:     // Unknown namespace means no attr...
   1: 
   1:     *aReturn = PR_FALSE;
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
   1:   *aReturn = HasAttr(nsid, name);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::JoinTextNodes(nsIContent* aFirst,
   1:                                 nsIContent* aSecond)
   1: {
   1:   nsresult rv = NS_OK;
   1:   nsCOMPtr<nsIDOMText> firstText(do_QueryInterface(aFirst, &rv));
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
   1:     nsCOMPtr<nsIDOMText> secondText(do_QueryInterface(aSecond, &rv));
   1: 
   1:     if (NS_SUCCEEDED(rv)) {
   1:       nsAutoString str;
   1: 
   1:       rv = secondText->GetData(str);
   1:       if (NS_SUCCEEDED(rv)) {
   1:         rv = firstText->AppendData(str);
   1:       }
   1:     }
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::Normalize()
   1: {
  62:   // Batch possible DOMSubtreeModified events.
  62:   mozAutoSubtreeModified subtree(GetOwnerDoc(), nsnull);
  62: 
   1:   nsresult result = NS_OK;
   1:   PRUint32 index, count = GetChildCount();
   1: 
   1:   for (index = 0; (index < count) && (NS_OK == result); index++) {
   1:     nsIContent *child = GetChildAt(index);
   1: 
   1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(child);
   1:     if (node) {
   1:       PRUint16 nodeType;
   1:       node->GetNodeType(&nodeType);
   1: 
   1:       switch (nodeType) {
   1:         case nsIDOMNode::TEXT_NODE:
   1: 
   1:           // ensure that if the text node is empty, it is removed
   1:           if (0 == child->TextLength()) {
   1:             result = RemoveChildAt(index, PR_TRUE);
   1:             if (NS_FAILED(result)) {
   1:               return result;
   1:             }
   1: 
   1:             count--;
   1:             index--;
   1:             break;
   1:           }
   1:  
   1:           if (index+1 < count) {
   1:             // Get the sibling. If it's also a text node, then
   1:             // remove it from the tree and join the two text
   1:             // nodes.
   1:             nsIContent *sibling = GetChildAt(index + 1);
   1: 
   1:             nsCOMPtr<nsIDOMNode> siblingNode = do_QueryInterface(sibling);
   1: 
   1:             if (siblingNode) {
   1:               PRUint16 siblingNodeType;
   1:               siblingNode->GetNodeType(&siblingNodeType);
   1: 
   1:               if (siblingNodeType == nsIDOMNode::TEXT_NODE) {
   1:                 result = RemoveChildAt(index+1, PR_TRUE);
   1:                 if (NS_FAILED(result)) {
   1:                   return result;
   1:                 }
   1: 
   1:                 result = JoinTextNodes(child, sibling);
   1:                 if (NS_FAILED(result)) {
   1:                   return result;
   1:                 }
   1:                 count--;
   1:                 index--;
   1:               }
   1:             }
   1:           }
   1:           break;
   1: 
   1:         case nsIDOMNode::ELEMENT_NODE:
   1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(child);
   1: 
   1:           if (element) {
   1:             result = element->Normalize();
   1:           }
   1:           break;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return result;
   1: }
   1: 
1685: static nsXBLBinding*
1685: GetFirstBindingWithContent(nsBindingManager* aBmgr, nsIContent* aBoundElem)
1685: {
1685:   nsXBLBinding* binding = aBmgr->GetBinding(aBoundElem);
1685:   while (binding) {
1685:     if (binding->GetAnonymousContent()) {
1685:       return binding;
1685:     }
1685:     binding = binding->GetBaseBinding();
1685:   }
1685:   
1685:   return nsnull;
1685: }
1685: 
1728: static nsresult
1728: BindNodesInInsertPoints(nsXBLBinding* aBinding, nsIContent* aInsertParent,
1728:                         nsIDocument* aDocument)
1728: {
1728:   NS_PRECONDITION(aBinding && aInsertParent, "Missing arguments");
1728: 
1728:   nsresult rv;
1728:   // These should be refcounted or otherwise protectable.
1728:   nsInsertionPointList* inserts =
1728:     aBinding->GetExistingInsertionPointsFor(aInsertParent);
1728:   if (inserts) {
1728:     PRBool allowScripts = aBinding->AllowScripts();
1839:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(aDocument);
1728:     PRUint32 i;
1728:     for (i = 0; i < inserts->Length(); ++i) {
1728:       nsCOMPtr<nsIContent> insertRoot =
1728:         inserts->ElementAt(i)->GetDefaultContent();
1728:       if (insertRoot) {
1728:         PRUint32 j;
1728:         for (j = 0; j < insertRoot->GetChildCount(); ++j) {
1728:           nsCOMPtr<nsIContent> child = insertRoot->GetChildAt(j);
1728:           rv = child->BindToTree(aDocument, aInsertParent,
1728:                                  aBinding->GetBoundElement(), allowScripts);
1728:           NS_ENSURE_SUCCESS(rv, rv);
1839: 
1839:           if (xulDoc) {
1839:             xulDoc->AddSubtreeToDocument(child);
1839:           }
1728:         }
1728:       }
1728:     }
1728:   }
1728: 
1728:   return NS_OK;
1728: }
1728: 
   1: nsresult
   1: nsGenericElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
   1:                              nsIContent* aBindingParent,
   1:                              PRBool aCompileEventHandlers)
   1: {
   1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
   1:   NS_PRECONDITION(HasSameOwnerDoc(NODE_FROM(aParent, aDocument)),
   1:                   "Must have the same owner document");
1498:   NS_PRECONDITION(!aParent || aDocument == aParent->GetCurrentDoc(),
   1:                   "aDocument must be current doc of aParent");
   1:   NS_PRECONDITION(!GetCurrentDoc(), "Already have a document.  Unbind first!");
   1:   // Note that as we recurse into the kids, they'll have a non-null parent.  So
   1:   // only assert if our parent is _changing_ while we have a parent.
   1:   NS_PRECONDITION(!GetParent() || aParent == GetParent(),
   1:                   "Already have a parent.  Unbind first!");
   1:   NS_PRECONDITION(!GetBindingParent() ||
   1:                   aBindingParent == GetBindingParent() ||
   1:                   (!aBindingParent && aParent &&
   1:                    aParent->GetBindingParent() == GetBindingParent()),
   1:                   "Already have a binding parent.  Unbind first!");
1685:   NS_PRECONDITION(!aParent || !aDocument ||
1685:                   !aParent->HasFlag(NODE_FORCE_XBL_BINDINGS),
1685:                   "Parent in document but flagged as forcing XBL");
1498:   // XXXbz XUL's SetNativeAnonymous is all weird, so can't assert
1498:   // anything here
1498:   NS_PRECONDITION(IsNodeOfType(eXUL) ||
1498:                   aBindingParent != this || IsNativeAnonymous(),
1111:                   "Only native anonymous content should have itself as its "
1111:                   "own binding parent");
   1:   
   1:   if (!aBindingParent && aParent) {
   1:     aBindingParent = aParent->GetBindingParent();
   1:   }
   1: 
   1:   // First set the binding parent
1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
1498:   if (xulElem) {
1498:     xulElem->SetXULBindingParent(aBindingParent);
1498:   }
1498:   else {
   1:     if (aBindingParent) {
   1:       nsDOMSlots *slots = GetDOMSlots();
   1: 
   1:       if (!slots) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       }
   1: 
   1:       slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
   1:     }
1498:   }
1498: 
1685:   PRBool hadForceXBL = HasFlag(NODE_FORCE_XBL_BINDINGS);
1685: 
1498:   // Now set the parent and set the "Force attach xbl" flag if needed.
   1:   if (aParent) {
   1:     mParentPtrBits = NS_REINTERPRET_CAST(PtrBits, aParent) | PARENT_BIT_PARENT_IS_CONTENT;
1498: 
1498:     if (aParent->HasFlag(NODE_FORCE_XBL_BINDINGS)) {
1498:       SetFlags(NODE_FORCE_XBL_BINDINGS);
1498:     }
   1:   }
   1:   else {
   1:     mParentPtrBits = NS_REINTERPRET_CAST(PtrBits, aDocument);
   1:   }
   1: 
   1:   // XXXbz sXBL/XBL2 issue!
   1: 
   1:   // Finally, set the document
   1:   if (aDocument) {
   1:     // Notify XBL- & nsIAnonymousContentCreator-generated
   1:     // anonymous content that the document is changing.
   1:     // XXXbz ordering issues here?  Probably not, since ChangeDocumentFor is
   1:     // just pretty broken anyway....  Need to get it working.
   1:     // XXXbz XBL doesn't handle this (asserts), and we don't really want
   1:     // to be doing this during parsing anyway... sort this out.    
   1:     //    aDocument->BindingManager()->ChangeDocumentFor(this, nsnull,
   1:     //                                                   aDocument);
   1: 
   1:     // Being added to a document.
   1:     mParentPtrBits |= PARENT_BIT_INDOCUMENT;
1498: 
1498:     // Unset this flag since we now really are in a document.
1498:     UnsetFlags(NODE_FORCE_XBL_BINDINGS);
   1:   }
   1: 
1685:   // If NODE_FORCE_XBL_BINDINGS was set we might have anonymous children
1685:   // that also need to be told that they are moving.
1685:   nsresult rv;
1685:   if (hadForceXBL) {
1685:     nsIDocument* ownerDoc = GetOwnerDoc();
1685:     if (ownerDoc) {
1685:       nsBindingManager* bmgr = ownerDoc->BindingManager();
1685: 
1685:       // First check if we have a binding...
1685:       nsXBLBinding* contBinding =
1685:         GetFirstBindingWithContent(bmgr, this);
1685:       if (contBinding) {
1685:         nsCOMPtr<nsIContent> anonRoot = contBinding->GetAnonymousContent();
1685:         PRBool allowScripts = contBinding->AllowScripts();
1685:         PRUint32 i;
1685:         for (i = 0; i < anonRoot->GetChildCount(); ++i) {
1685:           nsCOMPtr<nsIContent> child = anonRoot->GetChildAt(i);
1685:           rv = child->BindToTree(aDocument, this, this, allowScripts);
1685:           NS_ENSURE_SUCCESS(rv, rv);
1685:         }
1728: 
1728:         // ...then check if we have content in insertion points that are
1728:         // direct children of the <content>
1728:         rv = BindNodesInInsertPoints(contBinding, this, aDocument);
1728:         NS_ENSURE_SUCCESS(rv, rv);
1728:       }
1728: 
1728:       // ...and finally check if we're in a binding where we have content in
1728:       // insertion points.
1685:       if (aBindingParent) {
1685:         nsXBLBinding* binding = bmgr->GetBinding(aBindingParent);
1685:         if (binding) {
1728:           rv = BindNodesInInsertPoints(binding, this, aDocument);
1685:           NS_ENSURE_SUCCESS(rv, rv);
1685:         }
1685:       }
1685:     }
1685:   }
1685: 
   1:   // Now recurse into our kids
   1:   PRUint32 i;
1498:   // Don't call GetChildCount() here since that'll make XUL generate
1498:   // template children, which we're not in a consistent enough state for.
1498:   // Additionally, there's not really a need to generate the children here.
1498:   for (i = 0; i < mAttrsAndChildren.ChildCount(); ++i) {
   1:     // The child can remove itself from the parent in BindToTree.
   1:     nsCOMPtr<nsIContent> child = mAttrsAndChildren.ChildAt(i);
   1:     rv = child->BindToTree(aDocument, this, aBindingParent,
   1:                            aCompileEventHandlers);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   nsNodeUtils::ParentChainChanged(this);
   1: 
   1:   // XXXbz script execution during binding can trigger some of these
   1:   // postcondition asserts....  But we do want that, since things will
   1:   // generally be quite broken when that happens.
   1:   NS_POSTCONDITION(aDocument == GetCurrentDoc(), "Bound to wrong document");
   1:   NS_POSTCONDITION(aParent == GetParent(), "Bound to wrong parent");
   1:   NS_POSTCONDITION(aBindingParent == GetBindingParent(),
   1:                    "Bound to wrong binding parent");
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsGenericElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
   1: {
   1:   NS_PRECONDITION(aDeep || (!GetCurrentDoc() && !GetBindingParent()),
   1:                   "Shallow unbind won't clear document and binding parent on "
   1:                   "kids!");
   1:   // Make sure to unbind this node before doing the kids
   1:   nsIDocument *document = GetCurrentDoc();
   1:   if (document) {
   1:     // Notify XBL- & nsIAnonymousContentCreator-generated
   1:     // anonymous content that the document is changing.
   1:     document->BindingManager()->ChangeDocumentFor(this, document, nsnull);
   1: 
   1:     if (HasAttr(kNameSpaceID_XLink, nsGkAtoms::href)) {
   1:       document->ForgetLink(this);
   1:     }
   1: 
   1:     document->ClearBoxObjectFor(this);
   1:   }
   1: 
   1:   // Unset things in the reverse order from how we set them in BindToTree
   1:   mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~PARENT_BIT_INDOCUMENT;
   1: 
1498:   // Unset this since that's what the old code effectively did.
1498:   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
1498:   
1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
1498:   if (xulElem) {
1498:     xulElem->SetXULBindingParent(nsnull);
1498:   }
1498:   else {
   1:     nsDOMSlots *slots = GetExistingDOMSlots();
   1:     if (slots) {
   1:       slots->mBindingParent = nsnull;
   1:     }
1498:   }
   1: 
   1:   if (aDeep) {
1498:     // Do the kids. Don't call GetChildCount() here since that'll force
1498:     // XUL to generate template children, which there is no need for since
1498:     // all we're going to do is unbind them anyway.
1498:     PRUint32 i, n = mAttrsAndChildren.ChildCount();
   1: 
   1:     for (i = 0; i < n; ++i) {
   1:       // Note that we pass PR_FALSE for aNullParent here, since we don't want
   1:       // the kids to forget us.  We _do_ want them to forget their binding
   1:       // parent, though, since this only walks non-anonymous kids.
   1:       mAttrsAndChildren.ChildAt(i)->UnbindFromTree(PR_TRUE, PR_FALSE);
   1:     }
   1:   }
   1: 
   1:   nsNodeUtils::ParentChainChanged(this);
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
   1: {
   1:   return nsGenericElement::doPreHandleEvent(this, aVisitor);
   1: }
   1: 
1401: static nsIContent*
1401: FindFirstNonAnonContent(nsIContent* aContent)
1401: {
1401:   while (aContent && aContent->IsAnonymousForEvents()) {
1401:     aContent = aContent->GetParent();
1401:   }
1401:   return aContent;
1401: }
1401: 
1401: static PRBool
1401: IsInAnonContent(nsIContent* aContent)
1401: {
1401:   while (aContent && !aContent->IsAnonymousForEvents()) {
1401:     aContent = aContent->GetParent();
1401:   }
1401:   return !!aContent;
1401: }
1401: 
   1: nsresult
   1: nsGenericElement::doPreHandleEvent(nsIContent* aContent,
   1:                                    nsEventChainPreVisitor& aVisitor)
   1: {
   1:   //FIXME! Document how this event retargeting works, Bug 329124.
   1:   aVisitor.mCanHandle = PR_TRUE;
1401: 
1401:   // Don't propagate mouseover and mouseout events when mouse is moving
1401:   // inside native anonymous content.
1401:   PRBool isAnonForEvents = aContent->IsAnonymousForEvents();
1401:   if (aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH ||
1401:       aVisitor.mEvent->message == NS_MOUSE_EXIT_SYNTH) {
1401:      nsCOMPtr<nsIContent> relatedTarget =
1401:        do_QueryInterface(NS_STATIC_CAST(nsMouseEvent*,
1401:                                         aVisitor.mEvent)->relatedTarget);
1401:     if (relatedTarget &&
1401:         relatedTarget->GetOwnerDoc() == aContent->GetOwnerDoc()) {
1401: 
1401:       // If current target is anonymous for events or we know that related
1401:       // target is descendant of an element which is anonymous for events,
1401:       // we may want to stop event propagation.
1401:       // If aContent is the original target, aVisitor.mRelatedTargetIsInAnon
1401:       // must be updated.
1401:       if (isAnonForEvents || aVisitor.mRelatedTargetIsInAnon ||
1401:           (aVisitor.mEvent->originalTarget == aContent &&
1401:            (aVisitor.mRelatedTargetIsInAnon = IsInAnonContent(relatedTarget)))) {
1401:         nsIContent* nonAnon = FindFirstNonAnonContent(aContent);
1593:         if (nonAnon) {
1401:           nsIContent* nonAnonRelated = FindFirstNonAnonContent(relatedTarget);
1593:           if (nonAnonRelated) {
1401:             if (nonAnon == nonAnonRelated ||
1401:                 nsContentUtils::ContentIsDescendantOf(nonAnonRelated, nonAnon)) {
1401:               aVisitor.mParentTarget = nsnull;
1401:               // Event should not propagate to non-anon content.
1401:               aVisitor.mCanHandle = isAnonForEvents;
1401:               return NS_OK;
1401:             }
1401:           }
1401:         }
1401:       }
1593:     }
1593:   }
1401: 
   1:   nsCOMPtr<nsIContent> parent = aContent->GetParent();
1401:   if (isAnonForEvents) {
   1:     // Don't propagate mutation events which are dispatched somewhere inside
   1:     // native anonymous content.
   1:     if (aVisitor.mEvent->eventStructType == NS_MUTATION_EVENT) {
   1:       aVisitor.mParentTarget = nsnull;
   1:       return NS_OK;
   1:     }
   1: 
   1:     aVisitor.mEventTargetAtParent = parent;
   1:   } else if (parent) {
   1:     nsCOMPtr<nsIContent> content(do_QueryInterface(aVisitor.mEvent->target));
   1:     if (content && content->GetBindingParent() == parent) {
   1:       aVisitor.mEventTargetAtParent = parent;
   1:     }
   1:   }
   1: 
   1:   // check for an anonymous parent
   1:   // XXX XBL2/sXBL issue
   1:   nsIDocument* ownerDoc = aContent->GetOwnerDoc();
   1:   if (ownerDoc) {
   1:     nsIContent* insertionParent = ownerDoc->BindingManager()->
   1:       GetInsertionParent(aContent);
   1:     NS_ASSERTION(!(aVisitor.mEventTargetAtParent && insertionParent &&
   1:                    aVisitor.mEventTargetAtParent != insertionParent),
   1:                  "Retargeting and having insertion parent!");
   1:     if (insertionParent) {
   1:       parent = insertionParent;
   1:     }
   1:   }
   1: 
   1:   if (parent) {
   1:     aVisitor.mParentTarget = parent;
   1:   } else {
   1:     aVisitor.mParentTarget = aContent->GetCurrentDoc();
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::PostHandleEvent(nsEventChainPostVisitor& /*aVisitor*/)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::DispatchDOMEvent(nsEvent* aEvent,
   1:                                    nsIDOMEvent* aDOMEvent,
   1:                                    nsPresContext* aPresContext,
   1:                                    nsEventStatus* aEventStatus)
   1: {
   1:   return nsEventDispatcher::DispatchDOMEvent(NS_STATIC_CAST(nsIContent*, this),
   1:                                              aEvent, aDOMEvent,
   1:                                              aPresContext, aEventStatus);
   1: }
   1: 
   1: nsIAtom*
   1: nsGenericElement::GetID() const
   1: {
   1:   nsIAtom* IDName = GetIDAttributeName();
   1:   if (IDName) {
   1:     const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(IDName);
   1:     if (attrVal){
   1:       if (attrVal->Type() == nsAttrValue::eAtom) {
   1:         return attrVal->GetAtomValue();
   1:       }
   1:       if(attrVal->IsEmptyString()){
   1:         return nsnull;
   1:       }
   1:       // Check if the ID has been stored as a string.
   1:       // This would occur if the ID attribute name changed after 
   1:       // the ID was parsed. 
   1:       if (attrVal->Type() == nsAttrValue::eString) {
   1:         nsAutoString idVal(attrVal->GetStringValue());
   1: 
   1:         // Create an atom from the value and set it into the attribute list. 
   1:         NS_CONST_CAST(nsAttrValue*, attrVal)->ParseAtom(idVal);
   1:         return attrVal->GetAtomValue();
   1:       }
   1:     }
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: const nsAttrValue*
   1: nsGenericElement::GetClasses() const
   1: {
   1:   return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsICSSStyleRule*
   1: nsGenericElement::GetInlineStyleRule()
   1: {
   1:   return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule,
   1:                                      PRBool aNotify)
   1: {
   1:   NS_NOTYETIMPLEMENTED("nsGenericElement::SetInlineStyleRule");
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP_(PRBool)
   1: nsGenericElement::IsAttributeMapped(const nsIAtom* aAttribute) const
   1: {
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsChangeHint
   1: nsGenericElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
   1:                                          PRInt32 aModType) const
   1: {
   1:   return nsChangeHint(0);
   1: }
   1: 
   1: nsIAtom *
   1: nsGenericElement::GetIDAttributeName() const
   1: {
   1:   return mNodeInfo->GetIDAttributeAtom();
   1: }
   1: 
   1: nsIAtom *
   1: nsGenericElement::GetClassAttributeName() const
   1: {
   1:   return nsnull;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::FindAttributeDependence(const nsIAtom* aAttribute,
   1:                                           const MappedAttributeEntry* const aMaps[],
   1:                                           PRUint32 aMapCount)
   1: {
   1:   for (PRUint32 mapindex = 0; mapindex < aMapCount; ++mapindex) {
   1:     for (const MappedAttributeEntry* map = aMaps[mapindex];
   1:          map->attribute; ++map) {
   1:       if (aAttribute == *map->attribute) {
   1:         return PR_TRUE;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: already_AddRefed<nsINodeInfo>
   1: nsGenericElement::GetExistingAttrNameFromQName(const nsAString& aStr) const
   1: {
   1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aStr);
   1:   if (!name) {
   1:     return nsnull;
   1:   }
   1: 
   1:   nsINodeInfo* nodeInfo;
   1:   if (name->IsAtom()) {
   1:     mNodeInfo->NodeInfoManager()->GetNodeInfo(name->Atom(), nsnull,
   1:                                               kNameSpaceID_None, &nodeInfo);
   1:   }
   1:   else {
   1:     NS_ADDREF(nodeInfo = name->NodeInfo());
   1:   }
   1: 
   1:   return nodeInfo;
   1: }
   1: 
   1: already_AddRefed<nsIURI>
   1: nsGenericElement::GetBaseURI() const
   1: {
   1:   nsIDocument* doc = GetOwnerDoc();
   1:   if (!doc) {
   1:     // We won't be able to do security checks, etc.  So don't go any
   1:     // further.  That said, this really shouldn't happen...
   1:     NS_ERROR("Element without owner document");
   1:     return nsnull;
   1:   }
   1: 
   1:   // Our base URL depends on whether we have an xml:base attribute, as
   1:   // well as on whether any of our ancestors do.
   1:   nsCOMPtr<nsIURI> parentBase;
   1: 
   1:   nsIContent *parent = GetParent();
   1:   if (parent) {
   1:     parentBase = parent->GetBaseURI();
   1:   } else {
   1:     // No parent, so just use the document (we must be the root or not in the
   1:     // tree).
   1:     parentBase = doc->GetBaseURI();
   1:   }
   1:   
   1:   // Now check for an xml:base attr 
   1:   nsAutoString value;
   1:   GetAttr(kNameSpaceID_XML, nsGkAtoms::base, value);
   1:   if (value.IsEmpty()) {
   1:     // No xml:base, so we just use the parent's base URL
   1:     nsIURI *base = nsnull;
   1:     parentBase.swap(base);
   1: 
   1:     return base;
   1:   }
   1: 
   1:   nsCOMPtr<nsIURI> ourBase;
   1:   nsresult rv = NS_NewURI(getter_AddRefs(ourBase), value,
   1:                           doc->GetDocumentCharacterSet().get(), parentBase);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     // do a security check, almost the same as nsDocument::SetBaseURL()
   1:     rv = nsContentUtils::GetSecurityManager()->
   1:       CheckLoadURIWithPrincipal(NodePrincipal(), ourBase,
   1:                                 nsIScriptSecurityManager::STANDARD);
   1:   }
   1: 
   1:   nsIURI *base;
   1:   if (NS_FAILED(rv)) {
   1:     base = parentBase;
   1:   } else {
   1:     base = ourBase;
   1:   }
   1: 
   1:   NS_IF_ADDREF(base);
   1: 
   1:   return base;    
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::IsLink(nsIURI** aURI) const
   1: {
   1:   *aURI = nsnull;
   1:   return PR_FALSE;
   1: }
   1: 
   1: void
   1: nsGenericElement::SetFocus(nsPresContext* aPresContext)
   1: {
   1:   // Traditionally focusable elements can take focus as long as they don't set
   1:   // the disabled attribute
   1: 
   1:   nsCOMPtr<nsIPresShell> presShell = aPresContext->PresShell();
   1:   if (!presShell) {
   1:     return;
   1:   }
   1:   nsIFrame* frame = presShell->GetPrimaryFrameFor(this);
   1:   if (frame && frame->IsFocusable() &&
   1:       aPresContext->EventStateManager()->SetContentState(this,
   1:                                                          NS_EVENT_STATE_FOCUS)) {
   1:     presShell->ScrollContentIntoView(this, NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
   1:                                      NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE);
   1:   }
   1: }
   1: 
   1: // static
   1: PRBool
   1: nsGenericElement::ShouldFocus(nsIContent *aContent)
   1: {
   1:   // Default to false, since if the document is not attached to a window,
   1:   // we should not focus any of its content.
   1:   PRBool visible = PR_FALSE;
   1: 
   1:   // Figure out if we're focusing an element in an inactive (hidden)
   1:   // tab (whose docshell is not visible), if so, drop this focus
   1:   // request on the floor
   1: 
   1:   nsIDocument *document = aContent->GetDocument();
   1: 
   1:   if (document) {
   1:     nsIScriptGlobalObject *sgo = document->GetScriptGlobalObject();
   1: 
   1:     if (sgo) {
   1:       nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(sgo));
   1:       nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(webNav));
   1: 
   1:       if (baseWin) {
   1:         baseWin->GetVisibility(&visible);
   1:       }
   1:     }
   1:   }
   1: 
   1:   return visible;
   1: }
   1: 
   1: // static
   1: PRBool
   1: nsGenericElement::ShouldBlur(nsIContent *aContent)
   1: {
   1:   // Determine if the current element is focused, if it is not focused
   1:   // then we should not try to blur
   1:   PRBool isFocused = PR_FALSE;
   1: 
   1:   nsIDocument *document = aContent->GetDocument();
   1: 
   1:   if (document) {
   1:     nsPIDOMWindow *win = document->GetWindow();
   1: 
   1:     if (win) {
   1:       nsCOMPtr<nsIFocusController> focusController =
   1:            win->GetRootFocusController();
   1: 
   1:       if (focusController) {
   1:         nsCOMPtr<nsIDOMElement> focusedElement;
   1:         focusController->GetFocusedElement(getter_AddRefs(focusedElement));    
   1:         nsCOMPtr<nsIDOMElement> domElement = do_QueryInterface(aContent);
   1:         //when the element is the same as the focused element, blur it
   1:         if (domElement == focusedElement)
   1:           isFocused = PR_TRUE;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return isFocused;
   1: }
   1: 
   1: nsIContent*
   1: nsGenericElement::GetBindingParent() const
   1: {
   1:   nsDOMSlots *slots = GetExistingDOMSlots();
   1: 
   1:   if (slots) {
   1:     return slots->mBindingParent;
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::IsNodeOfType(PRUint32 aFlags) const
   1: {
   1:   return !(aFlags & ~(eCONTENT | eELEMENT));
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // virtual
   1: void
   1: nsGenericElement::SetMayHaveFrame(PRBool aMayHaveFrame)
   1: {
   1:   if (aMayHaveFrame) {
   1:     SetFlags(NODE_MAY_HAVE_FRAME);
   1:   } else {
   1:     UnsetFlags(NODE_MAY_HAVE_FRAME);
   1:   }
   1: }
   1: 
   1: // virtual
   1: PRBool
   1: nsGenericElement::MayHaveFrame() const
   1: {
   1:   return HasFlag(NODE_MAY_HAVE_FRAME);
   1: }
   1: 
   1: PRUint32
   1: nsGenericElement::GetScriptTypeID() const
   1: {
   1:     PtrBits flags = GetFlags();
   1: 
   1:     /* 4 bits reserved for script-type ID. */
   1:     return (flags >> NODE_SCRIPT_TYPE_OFFSET) & 0x000F;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetScriptTypeID(PRUint32 aLang)
   1: {
   1:     if ((aLang & 0x000F) != aLang) {
   1:         NS_ERROR("script ID too large!");
   1:         return NS_ERROR_FAILURE;
   1:     }
   1:     /* SetFlags will just mask in the specific flags set, leaving existing
   1:        ones alone.  So we must clear all the bits first */
   1:     UnsetFlags(0x000FU << NODE_SCRIPT_TYPE_OFFSET);
   1:     SetFlags(aLang << NODE_SCRIPT_TYPE_OFFSET);
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::InsertChildAt(nsIContent* aKid,
   1:                                 PRUint32 aIndex,
   1:                                 PRBool aNotify)
   1: {
   1:   NS_PRECONDITION(aKid, "null ptr");
   1: 
   1:   return doInsertChildAt(aKid, aIndex, aNotify, this, GetCurrentDoc(),
   1:                          mAttrsAndChildren);
   1: }
   1: 
   1: 
   1: /* static */
   1: nsresult
   1: nsGenericElement::doInsertChildAt(nsIContent* aKid, PRUint32 aIndex,
   1:                                   PRBool aNotify, nsIContent* aParent,
   1:                                   nsIDocument* aDocument,
   1:                                   nsAttrAndChildArray& aChildArray)
   1: {
   1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
   1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
   1:                   "Incorrect aDocument");
   1: 
   1:   nsresult rv;
   1:   nsINode* container = NODE_FROM(aParent, aDocument);
   1:   if (!container->HasSameOwnerDoc(aKid)) {
   1:     if (aKid->GetOwnerDoc()) {
   1:       return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
   1:     }
   1: 
   1:     nsCOMPtr<nsIDOMNode> kid = do_QueryInterface(aKid, &rv);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     PRUint16 nodeType = 0;
   1:     rv = kid->GetNodeType(&nodeType);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // DocumentType nodes are the only nodes that can have a null ownerDocument
   1:     // according to the DOM spec, and we need to allow inserting them.
   1:     if (nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE) {
   1:       return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
   1:     }
   1:   }
   1: 
   1:   PRUint32 childCount = aChildArray.ChildCount();
   1:   NS_ENSURE_TRUE(aIndex <= childCount, NS_ERROR_ILLEGAL_VALUE);
   1: 
   1:   nsMutationGuard::DidMutate();
   1: 
   1:   PRBool isAppend = (aIndex == childCount);
   1: 
   1:   mozAutoDocUpdate updateBatch(aDocument, UPDATE_CONTENT_MODEL, aNotify);
   1: 
   1:   rv = aChildArray.InsertChildAt(aKid, aIndex);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   rv = aKid->BindToTree(aDocument, aParent, nsnull, PR_TRUE);
   1:   if (NS_FAILED(rv)) {
   1:     aChildArray.RemoveChildAt(aIndex);
   1:     aKid->UnbindFromTree();
   1:     return rv;
   1:   }
   1: 
   1:   // The kid may have removed its parent from the document, so recheck that
   1:   // that's still in the document before proceeding.  Also, the kid may have
   1:   // just removed itself, in which case we don't really want to fire
   1:   // ContentAppended or a mutation event.
   1:   // XXXbz What if the kid just moved us in the document?  Scripts suck.  We
   1:   // really need to stop running them while we're in the middle of modifying
   1:   // the DOM....
   1: 
   1:   if (aNotify && aKid->GetNodeParent() == container) {
   1:     // Note that we always want to call ContentInserted when things are added
   1:     // as kids to documents
   1:     if (aParent && isAppend) {
   1:       nsNodeUtils::ContentAppended(aParent, aIndex);
   1:     } else {
   1:       nsNodeUtils::ContentInserted(container, aKid, aIndex);
   1:     }
   1: 
   1:     if (nsContentUtils::HasMutationListeners(aKid,
   1:           NS_EVENT_BITS_MUTATION_NODEINSERTED)) {
   1:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEINSERTED);
   1:       mutation.mRelatedNode = do_QueryInterface(container);
  62:       mozAutoSubtreeModified subtree(container->GetOwnerDoc(), container);
   1:       nsEventDispatcher::Dispatch(aKid, nsnull, &mutation);
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)
   1: {
   1:   nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
   1:   NS_ASSERTION(oldKid == GetChildAt(aIndex), "Unexpected child in RemoveChildAt");
   1: 
   1:   if (oldKid) {
   1:     return doRemoveChildAt(aIndex, aNotify, oldKid, this, GetCurrentDoc(),
   1:                            mAttrsAndChildren);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsGenericElement::doRemoveChildAt(PRUint32 aIndex, PRBool aNotify,
   1:                                   nsIContent* aKid, nsIContent* aParent,
   1:                                   nsIDocument* aDocument,
   1:                                   nsAttrAndChildArray& aChildArray)
   1: {
   1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
   1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
   1:                   "Incorrect aDocument");
   1: 
   1:   nsMutationGuard::DidMutate();
   1: 
   1:   nsINode* container = NODE_FROM(aParent, aDocument);
   1:   
   1:   NS_PRECONDITION(aKid && aKid->GetParent() == aParent &&
   1:                   aKid == container->GetChildAt(aIndex) &&
   1:                   container->IndexOf(aKid) == (PRInt32)aIndex, "Bogus aKid");
   1: 
   1:   mozAutoDocUpdate updateBatch(aDocument, UPDATE_CONTENT_MODEL, aNotify);
   1: 
   1:   nsMutationGuard guard;
   1: 
  62:   mozAutoSubtreeModified subtree(nsnull, nsnull);
   1:   if (aNotify &&
   1:       nsContentUtils::HasMutationListeners(aKid,
   1:         NS_EVENT_BITS_MUTATION_NODEREMOVED)) {
   1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEREMOVED);
   1:     mutation.mRelatedNode = do_QueryInterface(container);
  62:     subtree.UpdateTarget(container->GetOwnerDoc(), container);
   1:     nsEventDispatcher::Dispatch(aKid, nsnull, &mutation);
   1:   }
   1: 
   1:   // Someone may have removed the kid or any of its siblings while that event
   1:   // was processing.
   1:   if (guard.Mutated(0)) {
   1:     aIndex = container->IndexOf(aKid);
   1:     if (NS_STATIC_CAST(PRInt32, aIndex) < 0) {
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   aChildArray.RemoveChildAt(aIndex);
   1: 
   1:   if (aNotify) {
   1:     nsNodeUtils::ContentRemoved(container, aKid, aIndex);
   1:   }
   1: 
   1:   aKid->UnbindFromTree();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsGenericElement::DispatchEvent(nsPresContext* aPresContext,
   1:                                 nsEvent* aEvent,
   1:                                 nsIContent* aTarget,
   1:                                 PRBool aFullDispatch,
   1:                                 nsEventStatus* aStatus)
   1: {
   1:   NS_PRECONDITION(aTarget, "Must have target");
   1:   NS_PRECONDITION(aEvent, "Must have source event");
   1:   NS_PRECONDITION(aStatus, "Null out param?");
   1: 
   1:   if (!aPresContext) {
   1:     return NS_OK;
   1:   }
   1: 
  95:   nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
   1:   if (!shell) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   if (aFullDispatch) {
   1:     return shell->HandleEventWithTarget(aEvent, nsnull, aTarget, aStatus);
   1:   }
   1: 
   1:   return shell->HandleDOMEventWithTarget(aTarget, aEvent, aStatus);
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsGenericElement::DispatchClickEvent(nsPresContext* aPresContext,
   1:                                      nsInputEvent* aSourceEvent,
   1:                                      nsIContent* aTarget,
   1:                                      PRBool aFullDispatch,
   1:                                      nsEventStatus* aStatus)
   1: {
   1:   NS_PRECONDITION(aTarget, "Must have target");
   1:   NS_PRECONDITION(aSourceEvent, "Must have source event");
   1:   NS_PRECONDITION(aStatus, "Null out param?");
   1: 
   1:   nsMouseEvent event(NS_IS_TRUSTED_EVENT(aSourceEvent), NS_MOUSE_CLICK,
   1:                      aSourceEvent->widget, nsMouseEvent::eReal);
   1:   event.refPoint = aSourceEvent->refPoint;
   1:   PRUint32 clickCount = 1;
   1:   if (aSourceEvent->eventStructType == NS_MOUSE_EVENT) {
   1:     clickCount = NS_STATIC_CAST(nsMouseEvent*, aSourceEvent)->clickCount;
   1:   }
   1:   event.clickCount = clickCount;
   1:   event.isShift = aSourceEvent->isShift;
   1:   event.isControl = aSourceEvent->isControl;
   1:   event.isAlt = aSourceEvent->isAlt;
   1:   event.isMeta = aSourceEvent->isMeta;
   1: 
   1:   return DispatchEvent(aPresContext, &event, aTarget, aFullDispatch, aStatus);
   1: }
   1: 
   1: nsIFrame*
   1: nsGenericElement::GetPrimaryFrame()
   1: {
   1:   nsIDocument* doc = GetCurrentDoc();
   1:   if (!doc) {
   1:     return nsnull;
   1:   }
   1: 
   1:   return GetPrimaryFrameFor(this, doc);
   1: }
   1: 
   1: nsIFrame*
   1: nsGenericElement::GetPrimaryFrame(mozFlushType aType)
   1: {
   1:   nsIDocument* doc = GetCurrentDoc();
   1:   if (!doc) {
   1:     return nsnull;
   1:   }
   1: 
   1:   // Cause a flush, so we get up-to-date frame
   1:   // information
   1:   doc->FlushPendingNotifications(aType);
   1: 
   1:   return GetPrimaryFrameFor(this, doc);
   1: }
   1: 
   1: /* static */
   1: nsIFrame*
   1: nsGenericElement::GetPrimaryFrameFor(nsIContent* aContent,
   1:                                      nsIDocument* aDocument)
   1: {
   1:   // Get presentation shell 0
 981:   nsIPresShell *presShell = aDocument->GetPrimaryShell();
   1:   if (!presShell) {
   1:     return nsnull;
   1:   }
   1: 
   1:   return presShell->GetPrimaryFrameFor(aContent);
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // Generic DOMNode implementations
   1: 
   1: /*
   1:  * This helper function checks if aChild is the same as aNode or if
   1:  * aChild is one of aNode's ancestors. -- jst@citec.fi
   1:  */
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::InsertBefore(nsIDOMNode *aNewChild, nsIDOMNode *aRefChild,
   1:                                nsIDOMNode **aReturn)
   1: {
   1:   return doReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, this, GetCurrentDoc(),
   1:                                  aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
   1:                                nsIDOMNode** aReturn)
   1: {
   1:   return doReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, this, GetCurrentDoc(),
   1:                                  aReturn);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsGenericElement::RemoveChild(nsIDOMNode *aOldChild, nsIDOMNode **aReturn)
   1: {
   1:   return doRemoveChild(aOldChild, this, GetCurrentDoc(),
   1:                        aReturn);
   1: }
   1: 
   1: // When replacing, aRefContent is the content being replaced; when
   1: // inserting it's the content before which we're inserting.  In the
   1: // latter case it may be null.
   1: static
   1: PRBool IsAllowedAsChild(nsIContent* aNewChild, PRUint16 aNewNodeType,
   1:                         nsIContent* aParent, nsIDocument* aDocument,
   1:                         PRBool aIsReplace, nsIContent* aRefContent)
   1: {
   1:   NS_PRECONDITION(aNewChild, "Must have new child");
   1:   NS_PRECONDITION(!aIsReplace || aRefContent,
   1:                   "Must have ref content for replace");
   1: #ifdef DEBUG
   1:   PRUint16 debugNodeType = 0;
   1:   nsCOMPtr<nsIDOMNode> debugNode(do_QueryInterface(aNewChild));
   1:   nsresult debugRv = debugNode->GetNodeType(&debugNodeType);
   1: 
   1:   NS_PRECONDITION(NS_SUCCEEDED(debugRv) && debugNodeType == aNewNodeType,
   1:                   "Bogus node type passed");
   1: #endif
   1: 
   1:   if (aParent && nsContentUtils::ContentIsDescendantOf(aParent, aNewChild)) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   // The allowed child nodes differ for documents and elements
   1:   switch (aNewNodeType) {
   1:   case nsIDOMNode::COMMENT_NODE :
   1:   case nsIDOMNode::PROCESSING_INSTRUCTION_NODE :
   1:     // OK in both cases
   1:     return PR_TRUE;
   1:   case nsIDOMNode::TEXT_NODE :
   1:   case nsIDOMNode::CDATA_SECTION_NODE :
   1:   case nsIDOMNode::ENTITY_REFERENCE_NODE :
   1:     // Only allowed under elements
   1:     return aParent != nsnull;
   1:   case nsIDOMNode::ELEMENT_NODE :
   1:     {
   1:       if (aParent) {
   1:         // Always ok to have elements under other elements
   1:         return PR_TRUE;
   1:       }
   1: 
   1:       nsIContent* rootContent = aDocument->GetRootContent();
   1:       if (rootContent) {
   1:         // Already have a documentElement, so this is only OK if we're
   1:         // replacing it.
   1:         return aIsReplace && rootContent == aRefContent;
   1:       }
   1: 
   1:       // We don't have a documentElement yet.  Our one remaining constraint is
   1:       // that the documentElement must come after the doctype.
   1:       if (!aRefContent) {
   1:         // Appending is just fine.
   1:         return PR_TRUE;
   1:       }
   1: 
   1:       // Now grovel for a doctype
   1:       nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aDocument);
   1:       NS_ASSERTION(doc, "Shouldn't happen");
   1:       nsCOMPtr<nsIDOMDocumentType> docType;
   1:       doc->GetDoctype(getter_AddRefs(docType));
   1:       nsCOMPtr<nsIContent> docTypeContent = do_QueryInterface(docType);
   1:       
   1:       if (!docTypeContent) {
   1:         // It's all good.
   1:         return PR_TRUE;
   1:       }
   1: 
   1:       PRInt32 doctypeIndex = aDocument->IndexOf(docTypeContent);
   1:       PRInt32 insertIndex = aDocument->IndexOf(aRefContent);
   1: 
   1:       // Now we're OK in the following two cases only:
   1:       // 1) We're replacing something that's not before the doctype
   1:       // 2) We're inserting before something that comes after the doctype 
   1:       return aIsReplace ? (insertIndex >= doctypeIndex) :
   1:         insertIndex > doctypeIndex;
   1:     }
   1:   case nsIDOMNode::DOCUMENT_TYPE_NODE :
   1:     {
   1:       if (aParent) {
   1:         // no doctypes allowed under elements
   1:         return PR_FALSE;
   1:       }
   1: 
   1:       nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aDocument);
   1:       NS_ASSERTION(doc, "Shouldn't happen");
   1:       nsCOMPtr<nsIDOMDocumentType> docType;
   1:       doc->GetDoctype(getter_AddRefs(docType));
   1:       nsCOMPtr<nsIContent> docTypeContent = do_QueryInterface(docType);
   1:       if (docTypeContent) {
   1:         // Already have a doctype, so this is only OK if we're replacing it
   1:         return aIsReplace && docTypeContent == aRefContent;
   1:       }
   1: 
   1:       // We don't have a doctype yet.  Our one remaining constraint is
   1:       // that the doctype must come before the documentElement.
   1:       nsIContent* rootContent = aDocument->GetRootContent();
   1:       if (!rootContent) {
   1:         // It's all good
   1:         return PR_TRUE;
   1:       }
   1: 
   1:       if (!aRefContent) {
   1:         // Trying to append a doctype, but have a documentElement
   1:         return PR_FALSE;
   1:       }
   1: 
   1:       PRInt32 rootIndex = aDocument->IndexOf(rootContent);
   1:       PRInt32 insertIndex = aDocument->IndexOf(aRefContent);
   1: 
   1:       // Now we're OK if and only if insertIndex <= rootIndex.  Indeed, either
   1:       // we end up replacing aRefContent or we end up before it.  Either one is
   1:       // ok as long as aRefContent is not after rootContent.
   1:       return insertIndex <= rootIndex;
   1:     }
   1:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE :
   1:     {
   1:       // Note that for now we only allow nodes inside document fragments if
   1:       // they're allowed inside elements.  If we ever change this to allow
   1:       // doctype nodes in document fragments, we'll need to update this code
   1:       if (aParent) {
   1:         // All good here
   1:         return PR_TRUE;
   1:       }
   1: 
   1:       PRBool sawElement = PR_FALSE;
   1:       PRUint32 count = aNewChild->GetChildCount();
   1:       for (PRUint32 index = 0; index < count; ++index) {
   1:         nsIContent* childContent = aNewChild->GetChildAt(index);
   1:         NS_ASSERTION(childContent, "Something went wrong");
   1:         if (childContent->IsNodeOfType(nsINode::eELEMENT)) {
   1:           if (sawElement) {
   1:             // Can't put two elements into a document
   1:             return PR_FALSE;
   1:           }
   1:           sawElement = PR_TRUE;
   1:         }
   1:         // If we can put this content at the the right place, we might be ok;
   1:         // if not, we bail out.
   1:         nsCOMPtr<nsIDOMNode> childNode(do_QueryInterface(childContent));
   1:         PRUint16 type;
   1:         childNode->GetNodeType(&type);
   1:         if (!IsAllowedAsChild(childContent, type, aParent, aDocument,
   1:                               aIsReplace, aRefContent)) {
   1:           return PR_FALSE;
   1:         }
   1:       }
   1: 
   1:       // Everything in the fragment checked out ok, so we can stick it in here
   1:       return PR_TRUE;
   1:     }
   1:   default:
   1:     /*
   1:      * aNewChild is of invalid type.
   1:      */
   1:     break;
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsGenericElement::doReplaceOrInsertBefore(PRBool aReplace,
   1:                                           nsIDOMNode* aNewChild,
   1:                                           nsIDOMNode* aRefChild,
   1:                                           nsIContent* aParent,
   1:                                           nsIDocument* aDocument,
   1:                                           nsIDOMNode** aReturn)
   1: {
   1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
   1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
   1:                   "Incorrect aDocument");
   1: 
   1:   *aReturn = nsnull;
   1: 
   1:   if (!aNewChild || (aReplace && !aRefChild)) {
   1:     return NS_ERROR_NULL_POINTER;
   1:   }
   1: 
   1:   // Keep a strong reference to the node that we'll return to ensure it
   1:   // doesn't go away.
   1:   nsCOMPtr<nsIDOMNode> returnVal = aReplace ? aRefChild : aNewChild;
   1: 
   1:   nsCOMPtr<nsIContent> refContent;
   1:   nsresult res = NS_OK;
   1:   PRInt32 insPos;
   1: 
   1:   nsINode* container = NODE_FROM(aParent, aDocument);
   1: 
   1:   // Figure out which index to insert at
   1:   if (aRefChild) {
   1:     refContent = do_QueryInterface(aRefChild);
   1:     insPos = container->IndexOf(refContent);
   1:     if (insPos < 0) {
   1:       return NS_ERROR_DOM_NOT_FOUND_ERR;
   1:     }
   1: 
   1:     if (aRefChild == aNewChild) {
   1:       NS_ADDREF(*aReturn = aNewChild);
   1: 
   1:       return NS_OK;
   1:     }
   1:   } else {
   1:     insPos = container->GetChildCount();
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent> newContent = do_QueryInterface(aNewChild);
   1:   if (!newContent) {
   1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:   }
   1: 
   1:   PRUint16 nodeType = 0;
   1:   res = aNewChild->GetNodeType(&nodeType);
   1:   NS_ENSURE_SUCCESS(res, res);
   1: 
   1:   // Make sure that the inserted node is allowed as a child of its new parent.
   1:   if (!IsAllowedAsChild(newContent, nodeType, aParent, aDocument, aReplace,
   1:                         refContent)) {
   1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:   }
   1: 
   1:   if (!container->HasSameOwnerDoc(newContent)) {
   1:     // DocumentType nodes are the only nodes that can have a null ownerDocument
   1:     // according to the DOM spec, and we need to allow inserting them.
   1:     if (nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE ||
   1:         newContent->GetOwnerDoc()) {
   1:       return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
   1:     }
   1: 
   1:     if (!nsContentUtils::CanCallerAccess(aNewChild)) {
   1:       return NS_ERROR_DOM_SECURITY_ERR;
   1:     }
   1:   }
   1: 
   1:   // We want an update batch when we expect several mutations to be performed,
   1:   // which is when we're replacing a node, or when we're inserting a fragment.
   1:   mozAutoDocUpdate updateBatch(aDocument, UPDATE_CONTENT_MODEL,
   1:     aReplace || nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE);
   1: 
   1:   // If we're replacing
   1:   if (aReplace) {
   1:     // Getting (and addrefing) the following child here is sort of wasteful
   1:     // in the common case, but really, it's not that expensive. Get over it.
   1:     refContent = container->GetChildAt(insPos + 1);
   1: 
   1:     nsMutationGuard guard;
   1: 
   1:     res = container->RemoveChildAt(insPos, PR_TRUE);
   1:     NS_ENSURE_SUCCESS(res, res);
   1: 
   1:     if (guard.Mutated(1)) {
   1:       insPos = refContent ? container->IndexOf(refContent) :
   1:                             container->GetChildCount();
   1:       if (insPos < 0) {
   1:         return NS_ERROR_DOM_NOT_FOUND_ERR;
   1:       }
   1: 
   1:       // Passing PR_FALSE for aIsReplace since we now have removed the node
   1:       // to be replaced.
   1:       if (!IsAllowedAsChild(newContent, nodeType, aParent, aDocument,
   1:                             PR_FALSE, refContent)) {
   1:         return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:       }
   1:     }
   1:   }
   1: 
   1:   /*
   1:    * Check if we're inserting a document fragment. If we are, we need
   1:    * to remove the children of the document fragment and add them
   1:    * individually (i.e. we don't add the actual document fragment).
   1:    */
   1:   if (nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
   1:     PRUint32 count = newContent->GetChildCount();
   1: 
   1:     // Copy the children into a separate array to avoid having to deal with
   1:     // mutations to the fragment while we're inserting.
   1:     nsCOMArray<nsIContent> fragChildren;
   1:     if (!fragChildren.SetCapacity(count)) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     PRUint32 i;
   1:     for (i = 0; i < count; i++) {
   1:       nsIContent* child = newContent->GetChildAt(i);
   1:       NS_ASSERTION(child->GetCurrentDoc() == nsnull,
   1:                    "How did we get a child with a current doc?");
   1:       fragChildren.AppendObject(child);
   1:     }
   1: 
   1:     // Remove the children from the fragment and flag for possible mutations.
   1:     PRBool mutated = PR_FALSE;
   1:     for (i = count; i > 0;) {
   1:       // We don't need to update i if someone mutates the DOM. The only thing
   1:       // that'd happen is that the resulting child list might be unexpected,
   1:       // but we should never crash since RemoveChildAt is out-of-bounds safe.
   1:       nsMutationGuard guard;
   1:       newContent->RemoveChildAt(--i, PR_TRUE);
   1:       mutated = mutated || guard.Mutated(1);
   1:     }
   1: 
   1:     // Iterate through the fragment's children, and insert them in the new
   1:     // parent
   1:     for (i = 0; i < count; ++i) {
   1:       // Get the n:th child from the array.
   1:       nsIContent* childContent = fragChildren[i];
   1: 
   1:       // If we've had any unexpeted mutations so far we need to recheck that
   1:       // the child can still be inserted.
   1:       if (mutated) {
   1:         // We really only need to update insPos if we *just* got an unexpected
   1:         // mutation as opposed to 3 insertions ago. But this is an edgecase so
   1:         // no need to over optimize.
   1:         insPos = refContent ? container->IndexOf(refContent) :
   1:                               container->GetChildCount();
   1:         if (insPos < 0) {
   1:           // Someone seriously messed up the childlist. We have no idea
   1:           // where to insert the remaining children, so just bail.
   1:           return NS_ERROR_DOM_NOT_FOUND_ERR;
   1:         }
   1: 
   1:         nsCOMPtr<nsIDOMNode> tmpNode = do_QueryInterface(childContent);
   1:         PRUint16 tmpType = 0;
   1:         tmpNode->GetNodeType(&tmpType);
   1: 
   1:         if (childContent->GetNodeParent() ||
   1:             !IsAllowedAsChild(childContent, tmpType, aParent, aDocument, PR_FALSE,
   1:                               refContent)) {
   1:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:         }
   1:       }
   1: 
   1:       nsMutationGuard guard;
   1: 
   1:       // XXXbz how come no reparenting here?  That seems odd...
   1:       // Insert the child.
   1:       res = container->InsertChildAt(childContent, insPos, PR_TRUE);
   1:       NS_ENSURE_SUCCESS(res, res);
   1: 
   1:       // Check to see if any evil mutation events mucked around with the
   1:       // child list.
   1:       mutated = mutated || guard.Mutated(1);
   1:       
   1:       ++insPos;
   1:     }
   1:   }
   1:   else {
   1:     // Not inserting a fragment but rather a single node.
   1: 
   1:     // Remove the element from the old parent if one exists
   1:     nsINode* oldParent = newContent->GetNodeParent();
   1: 
   1:     if (oldParent) {
   1:       PRInt32 removeIndex = oldParent->IndexOf(newContent);
   1: 
   1:       if (removeIndex < 0) {
   1:         // newContent is anonymous.  We can't deal with this, so just bail
   1:         return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
   1:       }
   1:       
   1:       NS_ASSERTION(!(oldParent == container && removeIndex == insPos),
   1:                    "invalid removeIndex");
   1: 
   1:       nsMutationGuard guard;
   1: 
   1:       res = oldParent->RemoveChildAt(removeIndex, PR_TRUE);
   1:       NS_ENSURE_SUCCESS(res, res);
   1: 
   1:       // Adjust insert index if the node we ripped out was a sibling
   1:       // of the node we're inserting before
   1:       if (oldParent == container && removeIndex < insPos) {
   1:         --insPos;
   1:       }
   1: 
   1:       if (guard.Mutated(1)) {
   1:         insPos = refContent ? container->IndexOf(refContent) :
   1:                               container->GetChildCount();
   1:         if (insPos < 0) {
   1:           // Someone seriously messed up the childlist. We have no idea
   1:           // where to insert the new child, so just bail.
   1:           return NS_ERROR_DOM_NOT_FOUND_ERR;
   1:         }
   1: 
   1:         if (newContent->GetNodeParent() ||
   1:             !IsAllowedAsChild(newContent, nodeType, aParent, aDocument,
   1:                               PR_FALSE, refContent)) {
   1:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
   1:         }
   1:       }
   1:     }
   1: 
1498:     if (!newContent->IsNodeOfType(eXUL)) {
   1:       nsContentUtils::ReparentContentWrapper(newContent, aParent,
   1:                                              container->GetOwnerDoc(),
   1:                                              container->GetOwnerDoc());
   1:     }
   1: 
   1:     res = container->InsertChildAt(newContent, insPos, PR_TRUE);
   1:     NS_ENSURE_SUCCESS(res, res);
   1:   }
   1: 
   1:   returnVal.swap(*aReturn);
   1: 
   1:   return res;
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsGenericElement::doRemoveChild(nsIDOMNode* aOldChild, nsIContent* aParent,
   1:                                 nsIDocument* aDocument, nsIDOMNode** aReturn)
   1: {
   1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
   1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
   1:                   "Incorrect aDocument");
   1: 
   1:   *aReturn = nsnull;
   1:   NS_ENSURE_TRUE(aOldChild, NS_ERROR_NULL_POINTER);
   1: 
   1:   nsINode* container = NODE_FROM(aParent, aDocument);
   1: 
   1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aOldChild);
   1:   // fix children to be a passed argument
   1:   PRInt32 index = container->IndexOf(content);
   1:   if (index == -1) {
   1:     // aOldChild isn't one of our children.
   1:     return NS_ERROR_DOM_NOT_FOUND_ERR;
   1:   }
   1: 
   1:   nsresult rv = container->RemoveChildAt(index, PR_TRUE);
   1: 
   1:   *aReturn = aOldChild;
   1:   NS_ADDREF(aOldChild);
   1: 
   1:   return rv;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: // nsISupports implementation
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericElement)
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericElement)
   1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
   1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
   1: 
   1:   // Unlink child content (and unbind our subtree).
   1:   {
   1:     PRUint32 i;
   1:     PRUint32 kids = tmp->mAttrsAndChildren.ChildCount();
   1:     for (i = kids; i > 0; i--) {
   1:       tmp->mAttrsAndChildren.ChildAt(i-1)->UnbindFromTree();
   1:       tmp->mAttrsAndChildren.RemoveChildAt(i-1);    
   1:     }
   1:   }  
   1: 
   1:   // Unlink any DOM slots of interest.
   1:   {
   1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
   1:     if (slots)
   1:       slots->mAttributeMap = nsnull;
   1:   }
   1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
   1: 
   1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericElement)
1353:   nsIDocument* currentDoc = tmp->GetCurrentDoc();
1498:   if (currentDoc && nsCCUncollectableMarker::InGeneration(
1353:                       currentDoc->GetMarkedCCGeneration())) {
1353:     return NS_OK;
1353:   }
1353: 
   1:   nsIDocument* ownerDoc = tmp->GetOwnerDoc();
   1:   if (ownerDoc) {
   1:     ownerDoc->BindingManager()->Traverse(tmp, cb);
   1:   }
   1: 
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER
1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
   1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_PRESERVED_WRAPPER
   1: 
   1:   if (tmp->HasProperties() && tmp->IsNodeOfType(nsINode::eXUL)) {
   1:     nsISupports* property =
   1:       NS_STATIC_CAST(nsISupports*,
   1:                      tmp->GetProperty(nsGkAtoms::contextmenulistener));
   1:     cb.NoteXPCOMChild(property);
   1:     property = NS_STATIC_CAST(nsISupports*,
   1:                               tmp->GetProperty(nsGkAtoms::popuplistener));
   1:     cb.NoteXPCOMChild(property);
   1:   }
   1: 
   1:   // Traverse child content.
   1:   {
   1:     PRUint32 i;
   1:     PRUint32 kids = tmp->mAttrsAndChildren.ChildCount();
   1:     for (i = 0; i < kids; i++)
   1:       cb.NoteXPCOMChild(tmp->mAttrsAndChildren.GetSafeChildAt(i));
   1:   }
   1: 
   1:   // Traverse any DOM slots of interest.
   1:   {
   1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
   1:     if (slots) {
   1:       cb.NoteXPCOMChild(slots->mAttributeMap.get());
   1:       if (tmp->IsNodeOfType(nsINode::eXUL))
   1:         cb.NoteXPCOMChild(slots->mControllers);
   1:     }
   1:   }
   1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
   1: 
   1: 
 791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGenericElement)
   1:   NS_INTERFACE_MAP_ENTRY(nsIContent)
   1:   NS_INTERFACE_MAP_ENTRY(nsINode)
   1:   NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
   1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Node, new nsNode3Tearoff(this))
   1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSElement, new nsNSElementTearoff(this))
   1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMEventTarget,
   1:                                  nsDOMEventRTTearoff::Create(this))
   1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3EventTarget,
   1:                                  nsDOMEventRTTearoff::Create(this))
   1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSEventTarget,
   1:                                  nsDOMEventRTTearoff::Create(this))
   1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
   1:                                  new nsNodeSupportsWeakRefTearoff(this))
   1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)
   1: NS_INTERFACE_MAP_END
   1: 
   1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGenericElement, nsIContent)
   1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsGenericElement, 
   1: 							nsIContent,
1391: 							nsNodeUtils::LastRelease(this))
   1: 
   1: nsresult
   1: nsGenericElement::PostQueryInterface(REFNSIID aIID, void** aInstancePtr)
   1: {
   1:   nsIDocument *document = GetOwnerDoc();
   1:   if (document) {
   1:     return document->BindingManager()->GetBindingImplementation(this, aIID,
   1:                                                                 aInstancePtr);
   1:   }
   1: 
   1:   return NS_NOINTERFACE;
   1: }
   1: 
   1: //----------------------------------------------------------------------
   1: nsresult
   1: nsGenericElement::LeaveLink(nsPresContext* aPresContext)
   1: {
   1:   nsILinkHandler *handler = aPresContext->GetLinkHandler();
   1:   if (!handler) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   return handler->OnLeaveLink();
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::TriggerLink(nsPresContext* aPresContext,
   1:                               nsIURI* aLinkURI,
   1:                               const nsAFlatString& aTargetSpec,
   1:                               PRBool aClick,
   1:                               PRBool aIsUserTriggered)
   1: {
   1:   NS_PRECONDITION(aLinkURI, "No link URI");
   1:   nsresult rv = NS_OK;
   1: 
   1:   nsILinkHandler *handler = aPresContext->GetLinkHandler();
   1:   if (!handler) return NS_OK;
   1: 
   1:   if (aClick) {
   1:     nsresult proceed = NS_OK;
   1:     // Check that this page is allowed to load this URI.
   1:     nsCOMPtr<nsIScriptSecurityManager> securityManager = 
   1:              do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
   1:     if (NS_SUCCEEDED(rv)) {
   1:       PRUint32 flag =
   1:         aIsUserTriggered ?
   1:         (PRUint32) nsIScriptSecurityManager::STANDARD :
   1:         (PRUint32) nsIScriptSecurityManager::LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT;
   1:       proceed =
   1:         securityManager->CheckLoadURIWithPrincipal(NodePrincipal(), aLinkURI,
   1:                                                    flag);
   1:     }
   1: 
   1:     // Only pass off the click event if the script security manager
   1:     // says it's ok.
   1:     if (NS_SUCCEEDED(proceed))
   1:       handler->OnLinkClick(this, aLinkURI, aTargetSpec.get());
   1:   } else {
   1:     handler->OnOverLink(this, aLinkURI, aTargetSpec.get());
   1:   }
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::AddScriptEventListener(nsIAtom* aEventName,
   1:                                          const nsAString& aValue,
   1:                                          PRBool aDefer)
   1: {
   1:   NS_PRECONDITION(aEventName, "Must have event name!");
   1:   nsCOMPtr<nsISupports> target;
   1:   PRBool defer = PR_TRUE;
   1:   nsCOMPtr<nsIEventListenerManager> manager;
   1: 
   1:   nsresult rv = GetEventListenerManagerForAttr(getter_AddRefs(manager),
   1:                                                getter_AddRefs(target),
   1:                                                &defer);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (manager) {
   1:     nsIDocument *ownerDoc = GetOwnerDoc();
   1: 
   1:     defer = defer && aDefer; // only defer if everyone agrees...
   1: 
   1:     PRUint32 lang = GetScriptTypeID();
   1:     rv =
   1:       manager->AddScriptEventListener(target, aEventName, aValue, lang, defer,
   1:                                       !nsContentUtils::IsChromeDoc(ownerDoc));
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: 
   1: //----------------------------------------------------------------------
   1: 
   1: const nsAttrName*
   1: nsGenericElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
   1: {
   1:   return mAttrsAndChildren.GetExistingAttrNameFromQName(
   1:     NS_ConvertUTF16toUTF8(aStr));
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::CopyInnerTo(nsGenericElement* aDst) const
   1: {
   1:   PRUint32 i, count = mAttrsAndChildren.AttrCount();
   1:   for (i = 0; i < count; ++i) {
   1:     const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);
   1:     const nsAttrValue* value = mAttrsAndChildren.AttrAt(i);
   1:     nsAutoString valStr;
   1:     value->ToString(valStr);
   1:     nsresult rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
   1:                                 name->GetPrefix(), valStr, PR_FALSE);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
   1:                           nsIAtom* aPrefix, const nsAString& aValue,
   1:                           PRBool aNotify)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aName);
   1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
   1:                "Don't call SetAttr with unknown namespace");
   1: 
   1:   nsIDocument* doc = GetCurrentDoc();
   1:   if (kNameSpaceID_XLink == aNamespaceID && nsGkAtoms::href == aName) {
   1:     // XLink URI(s) might be changing. Drop the link from the map. If it
   1:     // is still style relevant it will be re-added by
   1:     // nsStyleUtil::IsLink. Make sure to keep the style system
   1:     // consistent so this remains true! In particular if the style system
   1:     // were to get smarter and not restyling an XLink element if the href
   1:     // doesn't change in a "significant" way, we'd need to do the same
   1:     // significance check here.
   1:     if (doc) {
   1:       doc->ForgetLink(this);
   1:     }
   1:   }
   1: 
   1:   nsAutoString oldValue;
   1:   PRBool modification = PR_FALSE;
   1:   PRBool hasListeners = aNotify &&
   1:     nsContentUtils::HasMutationListeners(this,
   1:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED);
   1:   
   1:   // If we have no listeners and aNotify is false, we are almost certainly
   1:   // coming from the content sink and will almost certainly have no previous
   1:   // value.  Even if we do, setting the value is cheap when we have no
   1:   // listeners and don't plan to notify.  The check for aNotify here is an
   1:   // optimization, the check for haveListeners is a correctness issue.
   1:   if (hasListeners || aNotify) {
   1:     nsAttrInfo info(GetAttrInfo(aNamespaceID, aName));
   1:     if (info.mValue) {
   1:       // Check whether the old value is the same as the new one.  Note that we
   1:       // only need to actually _get_ the old value if we have listeners.
   1:       PRBool valueMatches;
   1:       if (hasListeners) {
   1:         // Need to store the old value
   1:         info.mValue->ToString(oldValue);
   1:         valueMatches = aValue.Equals(oldValue);
   1:       } else if (aNotify) {
   1:         valueMatches = info.mValue->Equals(aValue, eCaseMatters);
   1:       }
   1:       if (valueMatches && aPrefix == info.mName->GetPrefix()) {
   1:         return NS_OK;
   1:       }
   1:       modification = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   nsresult rv = BeforeSetAttr(aNamespaceID, aName, &aValue, aNotify);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   nsAttrValue attrValue;
   1:   if (!ParseAttribute(aNamespaceID, aName, aValue, attrValue)) {
   1:     attrValue.SetTo(aValue);
   1:   }
   1: 
   1:   rv = SetAttrAndNotify(aNamespaceID, aName, aPrefix, oldValue,
   1:                         attrValue, modification, hasListeners, aNotify);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return AfterSetAttr(aNamespaceID, aName, &aValue, aNotify);
   1: }
   1:   
   1: nsresult
   1: nsGenericElement::SetAttrAndNotify(PRInt32 aNamespaceID,
   1:                                    nsIAtom* aName,
   1:                                    nsIAtom* aPrefix,
   1:                                    const nsAString& aOldValue,
   1:                                    nsAttrValue& aParsedValue,
   1:                                    PRBool aModification,
   1:                                    PRBool aFireMutation,
   1:                                    PRBool aNotify)
   1: {
   1:   nsresult rv;
   1:   PRUint8 modType = aModification ?
   1:     NS_STATIC_CAST(PRUint8, nsIDOMMutationEvent::MODIFICATION) :
   1:     NS_STATIC_CAST(PRUint8, nsIDOMMutationEvent::ADDITION);
   1: 
   1:   nsIDocument* document = GetCurrentDoc();
   1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
   1:   if (aNotify && document) {
   1:     document->AttributeWillChange(this, aNamespaceID, aName);
   1:   }
   1: 
   1:   if (aNamespaceID == kNameSpaceID_None) {
   1:     // XXXbz Perhaps we should push up the attribute mapping function
   1:     // stuff to nsGenericElement?
   1:     if (!IsAttributeMapped(aName) ||
   1:         !SetMappedAttribute(document, aName, aParsedValue, &rv)) {
   1:       rv = mAttrsAndChildren.SetAndTakeAttr(aName, aParsedValue);
   1:     }
   1:   }
   1:   else {
   1:     nsCOMPtr<nsINodeInfo> ni;
   1:     rv = mNodeInfo->NodeInfoManager()->GetNodeInfo(aName, aPrefix,
   1:                                                    aNamespaceID,
   1:                                                    getter_AddRefs(ni));
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     rv = mAttrsAndChildren.SetAndTakeAttr(ni, aParsedValue);
   1:   }
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (document) {
2528:     nsRefPtr<nsXBLBinding> binding =
2528:       document->BindingManager()->GetBinding(this);
   1:     if (binding) {
   1:       binding->AttributeChanged(aName, aNamespaceID, PR_FALSE, aNotify);
   1:     }
   1:   }
   1: 
   1:   if (aFireMutation) {
   1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
   1: 
   1:     nsAutoString attrName;
   1:     aName->ToString(attrName);
   1:     nsCOMPtr<nsIDOMAttr> attrNode;
   1:     nsAutoString ns;
   1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNamespaceID, ns);
   1:     GetAttributeNodeNS(ns, attrName, getter_AddRefs(attrNode));
   1:     mutation.mRelatedNode = attrNode;
   1: 
   1:     mutation.mAttrName = aName;
   1:     nsAutoString newValue;
   1:     GetAttr(aNamespaceID, aName, newValue);
   1:     if (!newValue.IsEmpty()) {
   1:       mutation.mNewAttrValue = do_GetAtom(newValue);
   1:     }
   1:     if (!aOldValue.IsEmpty()) {
   1:       mutation.mPrevAttrValue = do_GetAtom(aOldValue);
   1:     }
   1:     mutation.mAttrChange = modType;
  62:     mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
   1:     nsEventDispatcher::Dispatch(this, nsnull, &mutation);
   1:   }
   1: 
   1:   if (aNotify) {
   1:     nsNodeUtils::AttributeChanged(this, aNamespaceID, aName, modType);
   1:   }
   1:   
   1:   if (aNamespaceID == kNameSpaceID_XMLEvents && 
   1:       aName == nsGkAtoms::event && mNodeInfo->GetDocument()) {
   1:     mNodeInfo->GetDocument()->AddXMLEventsContent(this);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::ParseAttribute(PRInt32 aNamespaceID,
   1:                                  nsIAtom* aAttribute,
   1:                                  const nsAString& aValue,
   1:                                  nsAttrValue& aResult)
   1: {
   1:   if (aNamespaceID == kNameSpaceID_None &&
   1:       aAttribute == GetIDAttributeName() && !aValue.IsEmpty()) {
   1:     // Store id as an atom.  id="" means that the element has no id,
   1:     // not that it has an emptystring as the id.
   1:     aResult.ParseAtom(aValue);
   1:     return PR_TRUE;
   1:   }
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::SetMappedAttribute(nsIDocument* aDocument,
   1:                                      nsIAtom* aName,
   1:                                      nsAttrValue& aValue,
   1:                                      nsresult* aRetval)
   1: {
   1:   *aRetval = NS_OK;
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
   1:                                                  nsISupports** aTarget,
   1:                                                  PRBool* aDefer)
   1: {
   1:   nsresult rv = GetListenerManager(PR_TRUE, aManager);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     NS_ADDREF(*aTarget = NS_STATIC_CAST(nsIContent*, this));
   1:   }
   1:   *aDefer = PR_TRUE;
   1:   return rv;
   1: }
   1: 
   1: nsGenericElement::nsAttrInfo
   1: nsGenericElement::GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const
   1: {
   1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
   1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
   1:                "must have a real namespace ID!");
   1: 
   1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNamespaceID);
   1:   if (index >= 0) {
   1:     return nsAttrInfo(mAttrsAndChildren.AttrNameAt(index),
   1:                       mAttrsAndChildren.AttrAt(index));
   1:   }
   1: 
   1:   return nsAttrInfo(nsnull, nsnull);
   1: }
   1:   
   1: 
   1: PRBool
   1: nsGenericElement::GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
   1:                           nsAString& aResult) const
   1: {
   1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
   1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
   1:                "must have a real namespace ID!");
   1: 
   1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   1:   if (!val) {
   1:     // Since we are returning a success code we'd better do
   1:     // something about the out parameters (someone may have
   1:     // given us a non-empty string).
   1:     aResult.Truncate();
   1:     
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   val->ToString(aResult);
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const
   1: {
   1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
   1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
   1:                "must have a real namespace ID!");
   1: 
   1:   return mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID) >= 0;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
   1:                               nsIAtom* aName,
   1:                               const nsAString& aValue,
   1:                               nsCaseTreatment aCaseSensitive) const
   1: {
   1:   NS_ASSERTION(aName, "Must have attr name");
   1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
   1: 
   1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   1:   return val && val->Equals(aValue, aCaseSensitive);
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
   1:                               nsIAtom* aName,
   1:                               nsIAtom* aValue,
   1:                               nsCaseTreatment aCaseSensitive) const
   1: {
   1:   NS_ASSERTION(aName, "Must have attr name");
   1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
   1:   NS_ASSERTION(aValue, "Null value atom");
   1: 
   1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   1:   return val && val->Equals(aValue, aCaseSensitive);
   1: }
   1: 
   1: PRInt32
   1: nsGenericElement::FindAttrValueIn(PRInt32 aNameSpaceID,
   1:                                   nsIAtom* aName,
   1:                                   AttrValuesArray* aValues,
   1:                                   nsCaseTreatment aCaseSensitive) const
   1: {
   1:   NS_ASSERTION(aName, "Must have attr name");
   1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
   1:   NS_ASSERTION(aValues, "Null value array");
   1:   
   1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
   1:   if (val) {
   1:     for (PRInt32 i = 0; aValues[i]; ++i) {
   1:       if (val->Equals(*aValues[i], aCaseSensitive)) {
   1:         return i;
   1:       }
   1:     }
   1:     return ATTR_VALUE_NO_MATCH;
   1:   }
   1:   return ATTR_MISSING;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
   1:                             PRBool aNotify)
   1: {
   1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
   1: 
   1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID);
   1:   if (index < 0) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsIDocument *document = GetCurrentDoc();    
   1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
   1:   if (document) {
   1:     if (kNameSpaceID_XLink == aNameSpaceID && nsGkAtoms::href == aName) {
   1:       // XLink URI might be changing.
   1:       document->ForgetLink(this);
   1:     }
   1: 
   1:     if (aNotify) {
   1:       document->AttributeWillChange(this, aNameSpaceID, aName);
   1:     }
   1:   }
   1: 
   1:   PRBool hasMutationListeners = aNotify &&
   1:     nsContentUtils::HasMutationListeners(this,
   1:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED);
   1: 
   1:   // Grab the attr node if needed before we remove it from the attr map
   1:   nsCOMPtr<nsIDOMAttr> attrNode;
   1:   if (hasMutationListeners) {
   1:     nsAutoString attrName;
   1:     aName->ToString(attrName);
   1:     nsAutoString ns;
   1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
   1:     GetAttributeNodeNS(ns, attrName, getter_AddRefs(attrNode));
   1:   }
   1: 
   1:   // Clear binding to nsIDOMNamedNodeMap
   1:   nsDOMSlots *slots = GetExistingDOMSlots();
   1:   if (slots && slots->mAttributeMap) {
   1:     slots->mAttributeMap->DropAttribute(aNameSpaceID, aName);
   1:   }
   1: 
   1:   nsAttrValue oldValue;
   1:   nsresult rv = mAttrsAndChildren.RemoveAttrAt(index, oldValue);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (document) {
   1:     nsXBLBinding *binding = document->BindingManager()->GetBinding(this);
   1:     if (binding)
   1:       binding->AttributeChanged(aName, aNameSpaceID, PR_TRUE, aNotify);
   1:   }
   1: 
   1:   if (aNotify) {
   1:     nsNodeUtils::AttributeChanged(this, aNameSpaceID, aName,
   1:                                   nsIDOMMutationEvent::REMOVAL);
   1:   }
   1: 
   1:   if (hasMutationListeners) {
   1:     nsCOMPtr<nsIDOMEventTarget> node =
   1:       do_QueryInterface(NS_STATIC_CAST(nsIContent *, this));
   1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
   1: 
   1:     mutation.mRelatedNode = attrNode;
   1:     mutation.mAttrName = aName;
   1: 
   1:     nsAutoString value;
   1:     oldValue.ToString(value);
   1:     if (!value.IsEmpty())
   1:       mutation.mPrevAttrValue = do_GetAtom(value);
   1:     mutation.mAttrChange = nsIDOMMutationEvent::REMOVAL;
   1: 
  62:     mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
   1:     nsEventDispatcher::Dispatch(this, nsnull, &mutation);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: const nsAttrName*
   1: nsGenericElement::GetAttrNameAt(PRUint32 aIndex) const
   1: {
   1:   return mAttrsAndChildren.GetSafeAttrNameAt(aIndex);
   1: }
   1: 
   1: PRUint32
   1: nsGenericElement::GetAttrCount() const
   1: {
   1:   return mAttrsAndChildren.AttrCount();
   1: }
   1: 
   1: const nsTextFragment*
   1: nsGenericElement::GetText()
   1: {
   1:   return nsnull;
   1: }
   1: 
   1: PRUint32
   1: nsGenericElement::TextLength()
   1: {
   1:   // We can remove this assertion if it turns out to be useful to be able
   1:   // to depend on this returning 0
   1:   NS_NOTREACHED("called nsGenericElement::TextLength");
   1: 
   1:   return 0;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::SetText(const PRUnichar* aBuffer, PRUint32 aLength,
   1:                           PRBool aNotify)
   1: {
   1:   NS_ERROR("called nsGenericElement::SetText");
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: nsresult
   1: nsGenericElement::AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
   1:                              PRBool aNotify)
   1: {
   1:   NS_ERROR("called nsGenericElement::AppendText");
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: PRBool
   1: nsGenericElement::TextIsOnlyWhitespace()
   1: {
   1:   return PR_FALSE;
   1: }
   1: 
   1: void
   1: nsGenericElement::AppendTextTo(nsAString& aResult)
   1: {
   1:   // We can remove this assertion if it turns out to be useful to be able
   1:   // to depend on this appending nothing.
   1:   NS_NOTREACHED("called nsGenericElement::TextLength");
   1: }
   1: 
   1: #ifdef DEBUG
   1: void
   1: nsGenericElement::ListAttributes(FILE* out) const
   1: {
   1:   PRUint32 index, count = mAttrsAndChildren.AttrCount();
   1:   for (index = 0; index < count; index++) {
   1:     nsAutoString buffer;
   1: 
   1:     // name
   1:     mAttrsAndChildren.AttrNameAt(index)->GetQualifiedName(buffer);
   1: 
   1:     // value
   1:     buffer.AppendLiteral("=\"");
   1:     nsAutoString value;
   1:     mAttrsAndChildren.AttrAt(index)->ToString(value);
   1:     for (int i = value.Length(); i >= 0; --i) {
   1:       if (value[i] == PRUnichar('"'))
   1:         value.Insert(PRUnichar('\\'), PRUint32(i));
   1:     }
   1:     buffer.Append(value);
   1:     buffer.AppendLiteral("\"");
   1: 
   1:     fputs(" ", out);
   1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
   1:   }
   1: }
   1: 
   1: void
   1: nsGenericElement::List(FILE* out, PRInt32 aIndent,
   1:                        const nsCString& aPrefix) const
   1: {
   1:   PRInt32 indent;
   1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1: 
   1:   fputs(aPrefix.get(), out);
   1: 
   1:   nsAutoString buf;
   1:   mNodeInfo->GetQualifiedName(buf);
   1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
   1: 
   1:   fprintf(out, "@%p", (void *)this);
   1: 
   1:   ListAttributes(out);
   1: 
   1:   fprintf(out, " intrinsicstate=[%08x]", IntrinsicState());
   1:   fprintf(out, " refcount=%d<", mRefCnt.get());
   1: 
   1:   PRUint32 i, length = GetChildCount();
   1:   if (length > 0) {
   1:     fputs("\n", out);
   1: 
   1:     for (i = 0; i < length; ++i) {
   1:       nsIContent *kid = GetChildAt(i);
   1:       kid->List(out, aIndent + 1);
   1:     }
   1: 
   1:     for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1:   }
   1: 
   1:   fputs(">\n", out);
   1:   
   1:   nsGenericElement* nonConstThis = NS_CONST_CAST(nsGenericElement*, this);
   1: 
   1:   // XXX sXBL/XBL2 issue! Owner or current document?
   1:   nsIDocument *document = GetOwnerDoc();
   1:   if (document) {
   1:     // Note: not listing nsIAnonymousContentCreator-created content...
   1: 
   1:     nsBindingManager* bindingManager = document->BindingManager();
   1:     nsCOMPtr<nsIDOMNodeList> anonymousChildren;
   1:     bindingManager->GetAnonymousNodesFor(nonConstThis,
   1:                                          getter_AddRefs(anonymousChildren));
   1: 
   1:     if (anonymousChildren) {
   1:       anonymousChildren->GetLength(&length);
   1:       if (length > 0) {
   1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1:         fputs("anonymous-children<\n", out);
   1: 
   1:         for (i = 0; i < length; ++i) {
   1:           nsCOMPtr<nsIDOMNode> node;
   1:           anonymousChildren->Item(i, getter_AddRefs(node));
   1:           nsCOMPtr<nsIContent> child = do_QueryInterface(node);
   1:           child->List(out, aIndent + 1);
   1:         }
   1: 
   1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1:         fputs(">\n", out);
   1:       }
   1:     }
   1: 
   1:     if (bindingManager->HasContentListFor(nonConstThis)) {
   1:       nsCOMPtr<nsIDOMNodeList> contentList;
   1:       bindingManager->GetContentListFor(nonConstThis,
   1:                                         getter_AddRefs(contentList));
   1: 
   1:       NS_ASSERTION(contentList != nsnull, "oops, binding manager lied");
   1: 
   1:       contentList->GetLength(&length);
   1:       if (length > 0) {
   1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1:         fputs("content-list<\n", out);
   1: 
   1:         for (i = 0; i < length; ++i) {
   1:           nsCOMPtr<nsIDOMNode> node;
   1:           contentList->Item(i, getter_AddRefs(node));
   1:           nsCOMPtr<nsIContent> child = do_QueryInterface(node);
   1:           child->List(out, aIndent + 1);
   1:         }
   1: 
   1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1:         fputs(">\n", out);
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsGenericElement::DumpContent(FILE* out, PRInt32 aIndent,
   1:                               PRBool aDumpAll) const
   1: {
   1:   PRInt32 indent;
   1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1: 
   1:   nsAutoString buf;
   1:   mNodeInfo->GetQualifiedName(buf);
   1:   fputs("<", out);
   1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
   1: 
   1:   if(aDumpAll) ListAttributes(out);
   1: 
   1:   fputs(">", out);
   1: 
   1:   if(aIndent) fputs("\n", out);
   1: 
   1:   PRInt32 index, kids = GetChildCount();
   1:   for (index = 0; index < kids; index++) {
   1:     nsIContent *kid = GetChildAt(index);
   1:     PRInt32 indent = aIndent ? aIndent + 1 : 0;
   1:     kid->DumpContent(out, indent, aDumpAll);
   1:   }
   1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
   1:   fputs("</", out);
   1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
   1:   fputs(">", out);
   1: 
   1:   if(aIndent) fputs("\n", out);
   1: }
   1: #endif
   1: 
   1: PRUint32
   1: nsGenericElement::GetChildCount() const
   1: {
   1:   return mAttrsAndChildren.ChildCount();
   1: }
   1: 
   1: nsIContent *
   1: nsGenericElement::GetChildAt(PRUint32 aIndex) const
   1: {
   1:   return mAttrsAndChildren.GetSafeChildAt(aIndex);
   1: }
   1: 
   1: PRInt32
   1: nsGenericElement::IndexOf(nsINode* aPossibleChild) const
   1: {
   1:   return mAttrsAndChildren.IndexOfChild(aPossibleChild);
   1: }
   1: 
   1: nsINode::nsSlots*
   1: nsGenericElement::CreateSlots()
   1: {
   1:   return new nsDOMSlots(mFlagsOrSlots);
   1: }
   1: 
 723: PRBool
 723: nsGenericElement::CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
 723:                                                        nsIURI** aURI) const
 723: {
 723:   if (aVisitor.mEventStatus == nsEventStatus_eConsumeNoDefault ||
 723:       !NS_IS_TRUSTED_EVENT(aVisitor.mEvent) ||
 723:       !aVisitor.mPresContext) {
 723:     return PR_FALSE;
 723:   }
 723: 
 723:   // Make sure we actually are a link
 723:   return IsLink(aURI);
 723: }
 723: 
 723: nsresult
 723: nsGenericElement::PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor)
 723: {
 723:   // Optimisation: return early if this event doesn't interest us.
 723:   // IMPORTANT: this switch and the switch below it must be kept in sync!
 723:   switch (aVisitor.mEvent->message) {
 723:   case NS_MOUSE_ENTER_SYNTH:
 723:   case NS_FOCUS_CONTENT:
 723:   case NS_MOUSE_EXIT_SYNTH:
 723:   case NS_BLUR_CONTENT:
 723:     break;
 723:   default:
 723:     return NS_OK;
 723:   }
 723: 
 723:   // Make sure we meet the preconditions before continuing
 723:   nsCOMPtr<nsIURI> absURI;
 723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
 723:     return NS_OK;
 723:   }
 723: 
 723:   nsresult rv = NS_OK;
 723: 
 723:   // We do the status bar updates in PreHandleEvent so that the status bar gets
 723:   // updated even if the event is consumed before we have a chance to set it.
 723:   switch (aVisitor.mEvent->message) {
 723:   // Set the status bar the same for focus and mouseover
 723:   case NS_MOUSE_ENTER_SYNTH:
 723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 723:     // FALL THROUGH
 723:   case NS_FOCUS_CONTENT:
 723:     {
 723:       nsAutoString target;
 723:       GetLinkTarget(target);
 723:       rv = TriggerLink(aVisitor.mPresContext, absURI, target, PR_FALSE, PR_TRUE);
 723:     }
 723:     break;
 723: 
 723:   case NS_MOUSE_EXIT_SYNTH:
 723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 723:     // FALL THROUGH
 723:   case NS_BLUR_CONTENT:
 723:     rv = LeaveLink(aVisitor.mPresContext);
 723:     break;
 723: 
 723:   default:
 723:     // switch not in sync with the optimization switch earlier in this function
 723:     NS_NOTREACHED("switch statements not in sync");
 723:     return NS_ERROR_UNEXPECTED;
 723:   }
 723: 
 723:   return rv;
 723: }
 723: 
   1: nsresult
   1: nsGenericElement::PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor)
   1: {
   1:   // Optimisation: return early if this event doesn't interest us.
   1:   // IMPORTANT: this switch and the switch below it must be kept in sync!
   1:   switch (aVisitor.mEvent->message) {
   1:   case NS_MOUSE_BUTTON_DOWN:
   1:   case NS_MOUSE_CLICK:
   1:   case NS_UI_ACTIVATE:
   1:   case NS_KEY_PRESS:
   1:     break;
   1:   default:
   1:     return NS_OK;
   1:   }
   1: 
 723:   // Make sure we meet the preconditions before continuing
   1:   nsCOMPtr<nsIURI> absURI;
 723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsresult rv = NS_OK;
   1: 
   1:   switch (aVisitor.mEvent->message) {
   1:   case NS_MOUSE_BUTTON_DOWN:
   1:     {
   1:       if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
   1:           NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
   1:           nsMouseEvent::eLeftButton) {
   1:         // don't make the link grab the focus if there is no link handler
   1:         nsILinkHandler *handler = aVisitor.mPresContext->GetLinkHandler();
   1:         nsIDocument *document = GetCurrentDoc();
   1:         if (handler && document && ShouldFocus(this)) {
   1:           // If the window is not active, do not allow the focus to bring the
   1:           // window to the front. We update the focus controller, but do nothing
   1:           // else.
   1:           nsPIDOMWindow *win = document->GetWindow();
   1:           if (win) {
   1:             nsIFocusController *focusController =
   1:               win->GetRootFocusController();
   1:             if (focusController) {
   1:               PRBool isActive = PR_FALSE;
   1:               focusController->GetActive(&isActive);
   1:               if (!isActive) {
   1:                 nsCOMPtr<nsIDOMElement> domElement = do_QueryInterface(this);
   1:                 if(domElement)
   1:                   focusController->SetFocusedElement(domElement);
   1:                 break;
   1:               }
   1:             }
   1:           }
   1:   
   1:           aVisitor.mPresContext->EventStateManager()->
   1:             SetContentState(this, NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_FOCUS);
   1:         }
   1:       }
   1:     }
   1:     break;
   1: 
   1:   case NS_MOUSE_CLICK:
   1:     if (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
   1:       nsInputEvent* inputEvent = NS_STATIC_CAST(nsInputEvent*, aVisitor.mEvent);
   1:       if (inputEvent->isControl || inputEvent->isMeta ||
   1:           inputEvent->isAlt ||inputEvent->isShift) {
   1:         break;
   1:       }
   1: 
   1:       // The default action is simply to dispatch DOMActivate
  95:       nsCOMPtr<nsIPresShell> shell = aVisitor.mPresContext->GetPresShell();
   1:       if (shell) {
   1:         // single-click
   1:         nsEventStatus status = nsEventStatus_eIgnore;
   1:         nsUIEvent actEvent(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
   1:                            NS_UI_ACTIVATE, 1);
   1: 
   1:         rv = shell->HandleDOMEventWithTarget(this, &actEvent, &status);
   1:       }
   1:     }
   1:     break;
   1: 
   1:   case NS_UI_ACTIVATE:
   1:     {
   1:       nsAutoString target;
   1:       GetLinkTarget(target);
   1:       rv = TriggerLink(aVisitor.mPresContext, absURI, target, PR_TRUE, PR_TRUE);
   1:     }
   1:     break;
   1: 
   1:   case NS_KEY_PRESS:
   1:     {
   1:       if (aVisitor.mEvent->eventStructType == NS_KEY_EVENT) {
   1:         nsKeyEvent* keyEvent = NS_STATIC_CAST(nsKeyEvent*, aVisitor.mEvent);
   1:         if (keyEvent->keyCode == NS_VK_RETURN) {
   1:           nsEventStatus status = nsEventStatus_eIgnore;
   1:           rv = DispatchClickEvent(aVisitor.mPresContext, keyEvent, this,
   1:                                   PR_FALSE, &status);
   1:           if (NS_SUCCEEDED(rv)) {
   1:             aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
   1:           }
   1:         }
   1:       }
   1:     }
   1:     break;
   1: 
   1:   default:
   1:     // switch not in sync with the optimization switch earlier in this function
   1:     NS_NOTREACHED("switch statements not in sync");
   1:     return NS_ERROR_UNEXPECTED;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsGenericElement::GetLinkTarget(nsAString& aTarget)
   1: {
   1:   aTarget.Truncate();
   1: }
   1: 
