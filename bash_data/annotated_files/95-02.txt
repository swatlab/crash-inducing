 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is Mozilla Communicator client code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: #include "nsIDOMHTMLButtonElement.h"
 1: #include "nsIDOMNSHTMLButtonElement.h"
 1: #include "nsIDOMHTMLFormElement.h"
 1: #include "nsIDOMEventReceiver.h"
 1: #include "nsGenericHTMLElement.h"
 1: #include "nsGkAtoms.h"
 1: #include "nsIPresShell.h"
 1: #include "nsStyleConsts.h"
 1: #include "nsPresContext.h"
 1: #include "nsIFormControl.h"
 1: #include "nsIForm.h"
 1: #include "nsIFormSubmission.h"
 1: #include "nsIURL.h"
 1: 
 1: #include "nsIFrame.h"
 1: #include "nsIFormControlFrame.h"
 1: #include "nsIEventStateManager.h"
 1: #include "nsIDOMEvent.h"
 1: #include "nsIDOMNSEvent.h"
 1: #include "nsIDocument.h"
 1: #include "nsGUIEvent.h"
 1: #include "nsUnicharUtils.h"
 1: #include "nsLayoutUtils.h"
 1: #include "nsEventDispatcher.h"
 1: #include "nsPresState.h"
 1: #include "nsLayoutErrors.h"
 1: 
 1: #define NS_IN_SUBMIT_CLICK (1 << 0)
 1: 
 1: class nsHTMLButtonElement : public nsGenericHTMLFormElement,
 1:                             public nsIDOMHTMLButtonElement,
 1:                             public nsIDOMNSHTMLButtonElement
 1: {
 1: public:
 1:   nsHTMLButtonElement(nsINodeInfo *aNodeInfo);
 1:   virtual ~nsHTMLButtonElement();
 1: 
 1:   // nsISupports
 1:   NS_DECL_ISUPPORTS_INHERITED
 1: 
 1:   // nsIDOMNode
 1:   NS_FORWARD_NSIDOMNODE(nsGenericHTMLFormElement::)
 1: 
 1:   // nsIDOMElement
 1:   NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLFormElement::)
 1: 
 1:   // nsIDOMHTMLElement
 1:   NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLFormElement::)
 1: 
 1:   // nsIDOMHTMLButtonElement
 1:   NS_DECL_NSIDOMHTMLBUTTONELEMENT
 1: 
 1:   // nsIDOMNSHTMLButtonElement
 1:   // Can't just use the macro, since it shares GetType with
 1:   // nsIDOMHTMLButtonElement
 1:   NS_IMETHOD Blur();
 1:   NS_IMETHOD Focus();
 1:   NS_IMETHOD Click();
 1:   NS_IMETHOD SetType(const nsAString& aType);
 1: 
 1:   // overriden nsIFormControl methods
 1:   NS_IMETHOD_(PRInt32) GetType() const { return mType; }
 1:   NS_IMETHOD Reset();
 1:   NS_IMETHOD SubmitNamesValues(nsIFormSubmission* aFormSubmission,
 1:                                nsIContent* aSubmitElement);
 1:   NS_IMETHOD SaveState();
 1:   PRBool RestoreState(nsPresState* aState);
 1: 
 1:   /**
 1:    * Called when an attribute is about to be changed
 1:    */
 1:   virtual nsresult BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                                  const nsAString* aValue, PRBool aNotify);
 1:   
 1:   // nsIContent overrides...
 1:   virtual void SetFocus(nsPresContext* aPresContext);
 1:   virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull);
 1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
 1:                                 nsIAtom* aAttribute,
 1:                                 const nsAString& aValue,
 1:                                 nsAttrValue& aResult);
 1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
 1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
 1: 
 1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 1:   virtual void DoneCreatingElement();
 1: 
 1: protected:
 1:   PRInt8 mType;
 1:   PRPackedBool mHandlingClick;
 1:   PRPackedBool mDisabledChanged;
 1: 
 1: private:
 1:   // The analogue of defaultValue in the DOM for input and textarea
 1:   nsresult SetDefaultValue(const nsAString& aDefaultValue);
 1:   nsresult GetDefaultValue(nsAString& aDefaultValue);
 1: };
 1: 
 1: 
 1: // Construction, destruction
 1: 
 1: 
 1: NS_IMPL_NS_NEW_HTML_ELEMENT(Button)
 1: 
 1: 
 1: nsHTMLButtonElement::nsHTMLButtonElement(nsINodeInfo *aNodeInfo)
 1:   : nsGenericHTMLFormElement(aNodeInfo),
 1:     mType(NS_FORM_BUTTON_SUBMIT),  // default
 1:     mHandlingClick(PR_FALSE),
 1:     mDisabledChanged(PR_FALSE)
 1: {
 1: }
 1: 
 1: nsHTMLButtonElement::~nsHTMLButtonElement()
 1: {
 1: }
 1: 
 1: // nsISupports
 1: 
 1: NS_IMPL_ADDREF_INHERITED(nsHTMLButtonElement, nsGenericElement)
 1: NS_IMPL_RELEASE_INHERITED(nsHTMLButtonElement, nsGenericElement)
 1: 
 1: 
 1: // QueryInterface implementation for nsHTMLButtonElement
 1: NS_HTML_CONTENT_INTERFACE_MAP_BEGIN(nsHTMLButtonElement,
 1:                                     nsGenericHTMLFormElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMHTMLButtonElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSHTMLButtonElement)
 1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLButtonElement)
 1: NS_HTML_CONTENT_INTERFACE_MAP_END
 1: 
 1: // nsIDOMHTMLButtonElement
 1: 
 1: 
 1: NS_IMPL_ELEMENT_CLONE(nsHTMLButtonElement)
 1: 
 1: 
 1: // nsIDOMHTMLButtonElement
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::GetForm(nsIDOMHTMLFormElement** aForm)
 1: {
 1:   return nsGenericHTMLFormElement::GetForm(aForm);
 1: }
 1: 
 1: NS_IMPL_STRING_ATTR(nsHTMLButtonElement, AccessKey, accesskey)
 1: NS_IMPL_BOOL_ATTR(nsHTMLButtonElement, Disabled, disabled)
 1: NS_IMPL_STRING_ATTR(nsHTMLButtonElement, Name, name)
 1: NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsHTMLButtonElement, TabIndex, tabindex, 0)
 1: NS_IMPL_STRING_ATTR(nsHTMLButtonElement, Value, value)
 1: NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLButtonElement, Type, type, "submit")
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::Blur()
 1: {
 1:   if (ShouldBlur(this)) {
 1:     SetElementFocus(PR_FALSE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::Focus()
 1: {
 1:   if (ShouldFocus(this)) {
 1:     SetElementFocus(PR_TRUE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::Click()
 1: {
 1:   if (mHandlingClick)
 1:     return NS_OK;
 1: 
 1:   mHandlingClick = PR_TRUE;
 1:   // Hold on to the document in case one of the events makes it die or
 1:   // something...
 1:   nsCOMPtr<nsIDocument> doc = GetCurrentDoc();
 1: 
 1:   if (doc) {
 1:     nsIPresShell *shell = doc->GetShellAt(0);
 1:     if (shell) {
 1:       nsCOMPtr<nsPresContext> context = shell->GetPresContext();
 1:       if (context) {
 1:         // Click() is never called from native code, but it may be
 1:         // called from chrome JS. Mark this event trusted if Click()
 1:         // is called from chrome code.
 1:         nsMouseEvent event(nsContentUtils::IsCallerChrome(),
 1:                            NS_MOUSE_CLICK, nsnull,
 1:                            nsMouseEvent::eReal);
 1:         nsEventStatus status = nsEventStatus_eIgnore;
 1:         nsEventDispatcher::Dispatch(NS_STATIC_CAST(nsIContent*, this), context,
 1:                                     &event, nsnull, &status);
 1:       }
 1:     }
 1:   }
 1: 
 1:   mHandlingClick = PR_FALSE;
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: PRBool
 1: nsHTMLButtonElement::IsFocusable(PRInt32 *aTabIndex)
 1: {
 1:   if (!nsGenericHTMLElement::IsFocusable(aTabIndex)) {
 1:     return PR_FALSE;
 1:   }
 1:   if (aTabIndex && (sTabFocusModel & eTabFocus_formElementsMask) == 0) {
 1:     *aTabIndex = -1;
 1:   }
 1:   return PR_TRUE;
 1: }
 1: 
 1: void
 1: nsHTMLButtonElement::SetFocus(nsPresContext* aPresContext)
 1: {
 1:   if (!aPresContext)
 1:     return;
 1: 
 1:   // first see if we are disabled or not. If disabled then do nothing.
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
 1:     return;
 1:   }
 1: 
 1:   SetFocusAndScrollIntoView(aPresContext);
 1: }
 1: 
 1: static const nsAttrValue::EnumTable kButtonTypeTable[] = {
 1:   { "button", NS_FORM_BUTTON_BUTTON },
 1:   { "reset", NS_FORM_BUTTON_RESET },
 1:   { "submit", NS_FORM_BUTTON_SUBMIT },
 1:   { 0 }
 1: };
 1: 
 1: PRBool
 1: nsHTMLButtonElement::ParseAttribute(PRInt32 aNamespaceID,
 1:                                     nsIAtom* aAttribute,
 1:                                     const nsAString& aValue,
 1:                                     nsAttrValue& aResult)
 1: {
 1:   if (aAttribute == nsGkAtoms::type && kNameSpaceID_None == aNamespaceID) {
 1:     // XXX ARG!! This is major evilness. ParseAttribute
 1:     // shouldn't set members. Override SetAttr instead
 1:     PRBool res = aResult.ParseEnumValue(aValue, kButtonTypeTable);
 1:     if (res) {
 1:       mType = aResult.GetEnumValue();
 1:     }
 1:     return res;
 1:   }
 1: 
 1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
 1:                                               aResult);
 1: }
 1: 
 1: nsresult
 1: nsHTMLButtonElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 1: {
 1:   // Do not process any DOM events if the element is disabled
 1:   aVisitor.mCanHandle = PR_FALSE;
 1:   PRBool bDisabled;
 1:   nsresult rv = GetDisabled(&bDisabled);
 1:   if (NS_FAILED(rv) || bDisabled) {
 1:     return rv;
 1:   }
 1: 
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_FALSE);
 1: 
 1:   if (formControlFrame) {
 1:     nsIFrame* formFrame = nsnull;
 1:     CallQueryInterface(formControlFrame, &formFrame);
 1: 
 1:     if (formFrame) {
 1:       const nsStyleUserInterface* uiStyle = formFrame->GetStyleUserInterface();
 1: 
 1:       if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
 1:           uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
 1:         return NS_OK;
 1:     }
 1:   }
 1: 
 1:   //FIXME Should this use NS_UI_ACTIVATE, not NS_MOUSE_CLICK?
 1:   //      https://bugzilla.mozilla.org/show_bug.cgi?id=309348#c16
 1:   PRBool bInSubmitClick = mType == NS_FORM_BUTTON_SUBMIT &&
 1:                           NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent) &&
 1:                           mForm;
 1: 
 1:   if (bInSubmitClick) {
 1:     aVisitor.mItemFlags |= NS_IN_SUBMIT_CLICK;
 1:     // tell the form that we are about to enter a click handler.
 1:     // that means that if there are scripted submissions, the
 1:     // latest one will be deferred until after the exit point of the handler.
 1:     mForm->OnSubmitClickBegin();
 1:   }
 1: 
 1:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
 1: }
 1: 
 1: nsresult
 1: nsHTMLButtonElement::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
 1: {
 1:   nsresult rv = NS_OK;
 1:   if (!aVisitor.mPresContext) {
 1:     return rv;
 1:   }
 1:   // mForm is null if the event handler removed us from the document (bug 194582).
 1:   if ((aVisitor.mItemFlags & NS_IN_SUBMIT_CLICK) && mForm) {
 1:     // tell the form that we are about to exit a click handler
 1:     // so the form knows not to defer subsequent submissions
 1:     // the pending ones that were created during the handler
 1:     // will be flushed or forgoten.
 1:     mForm->OnSubmitClickEnd();
 1:   }
 1: 
 1:   if (nsEventStatus_eIgnore == aVisitor.mEventStatus) {
 1:     switch (aVisitor.mEvent->message) {
 1:       case NS_KEY_PRESS:
 1:       case NS_KEY_UP:
 1:         {
 1:           // For backwards compat, trigger buttons with space or enter
 1:           // (bug 25300)
 1:           nsKeyEvent * keyEvent = (nsKeyEvent *)aVisitor.mEvent;
 1:           if ((keyEvent->keyCode == NS_VK_RETURN &&
 1:                NS_KEY_PRESS == aVisitor.mEvent->message) ||
 1:               keyEvent->keyCode == NS_VK_SPACE &&
 1:               NS_KEY_UP == aVisitor.mEvent->message) {
 1:             nsEventStatus status = nsEventStatus_eIgnore;
 1: 
 1:             nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
 1:                                NS_MOUSE_CLICK, nsnull,
 1:                                nsMouseEvent::eReal);
 1:             nsEventDispatcher::Dispatch(NS_STATIC_CAST(nsIContent*, this),
 1:                                         aVisitor.mPresContext, &event, nsnull,
 1:                                         &status);
 1:           }
 1:         }
 1:         break;// NS_KEY_PRESS
 1: 
 1:       case NS_MOUSE_CLICK:
 1:         {
 1:           if (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
95:             nsCOMPtr<nsIPresShell> presShell =
95:               aVisitor.mPresContext->GetPresShell();
 1:             if (presShell) {
 1:               // single-click
 1:               nsUIEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
 1:                               NS_UI_ACTIVATE, 1);
 1:               nsEventStatus status = nsEventStatus_eIgnore;
 1:   
 1:               presShell->HandleDOMEventWithTarget(this, &event, &status);
 1:               aVisitor.mEventStatus = status;
 1:             }
 1:           }
 1:         }
 1:         break;
 1: 
 1:       case NS_UI_ACTIVATE:
 1:         {
 1:           if (mForm && (mType == NS_FORM_BUTTON_SUBMIT ||
 1:                         mType == NS_FORM_BUTTON_RESET)) {
 1:             nsFormEvent event(PR_TRUE,
 1:                               (mType == NS_FORM_BUTTON_RESET)
 1:                               ? NS_FORM_RESET : NS_FORM_SUBMIT);
 1:             event.originator      = this;
 1:             nsEventStatus status  = nsEventStatus_eIgnore;
 1: 
95:             nsCOMPtr<nsIPresShell> presShell =
95:               aVisitor.mPresContext->GetPresShell();
 1:             // If |nsIPresShell::Destroy| has been called due to
 1:             // handling the event, the pres context will return
 1:             // a null pres shell.  See bug 125624.
 1:             //
 1:             // Using presShell to dispatch the event. It makes sure that
 1:             // event is not handled if the window is being destroyed.
 1:             if (presShell) {
 1:               nsCOMPtr<nsIContent> form(do_QueryInterface(mForm));
 1:               presShell->HandleDOMEventWithTarget(form, &event, &status);
 1:             }
 1:           }
 1:         }
 1:         break;// NS_MOUSE_CLICK
 1: 
 1:       case NS_MOUSE_BUTTON_DOWN:
 1:         {
 1:           if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT) {
 1:             if (NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                   nsMouseEvent::eLeftButton) {
 1:               aVisitor.mPresContext->EventStateManager()->
 1:                 SetContentState(this, NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_FOCUS);
 1:               aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 1:             } else if (NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                          nsMouseEvent::eMiddleButton ||
 1:                        NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                          nsMouseEvent::eRightButton) {
 1:               // cancel all of these events for buttons
 1:               //XXXsmaug What to do with these events? Why these should be cancelled?
 1:               aVisitor.mDOMEvent->StopPropagation();
 1:             }
 1:           }
 1:         }
 1:         break;
 1: 
 1:       // cancel all of these events for buttons
 1:       //XXXsmaug What to do with these events? Why these should be cancelled?
 1:       case NS_MOUSE_BUTTON_UP:
 1:       case NS_MOUSE_DOUBLECLICK:
 1:         {
 1:           if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 1:               aVisitor.mDOMEvent &&
 1:               (NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                  nsMouseEvent::eMiddleButton ||
 1:                NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                  nsMouseEvent::eRightButton)) {
 1:             aVisitor.mDOMEvent->StopPropagation();
 1:           }
 1:         }
 1:         break;
 1: 
 1:       case NS_MOUSE_ENTER_SYNTH:
 1:         {
 1:           aVisitor.mPresContext->EventStateManager()->
 1:             SetContentState(this, NS_EVENT_STATE_HOVER);
 1:           aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 1:         }
 1:         break;
 1: 
 1:         // XXX this doesn't seem to do anything yet
 1:       case NS_MOUSE_EXIT_SYNTH:
 1:         {
 1:           aVisitor.mPresContext->EventStateManager()->
 1:             SetContentState(nsnull, NS_EVENT_STATE_HOVER);
 1:           aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 1:         }
 1:         break;
 1: 
 1:       default:
 1:         break;
 1:     }
 1:   } else {
 1:     switch (aVisitor.mEvent->message) {
 1:       // Make sure any pending submissions from a call to
 1:       // form.submit() in a left click handler or an activate
 1:       // handler gets flushed, even if the event handler prevented
 1:       // the default action.
 1:       case NS_MOUSE_CLICK:
 1:         if (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
 1:           if (mForm && mType == NS_FORM_BUTTON_SUBMIT) {
 1:             // Tell the form to flush a possible pending submission.
 1:             // the reason is that the script returned false (the event was
 1:             // not ignored) so if there is a stored submission, it needs to
 1:             // be submitted immediatelly.
 1:             mForm->FlushPendingSubmission();
 1:           }
 1:         }
 1:         break;
 1:       case NS_UI_ACTIVATE:
 1:         if (mForm && mType == NS_FORM_BUTTON_SUBMIT) {
 1:           // Tell the form to flush a possible pending submission.
 1:           // the reason is that the script returned false (the event was
 1:           // not ignored) so if there is a stored submission, it needs to
 1:           // be submitted immediatelly.
 1:           mForm->FlushPendingSubmission();
 1:         }
 1:         break;// NS_UI_ACTIVATE
 1:     } //switch
 1:   } //if
 1: 
 1:   return rv;
 1: }
 1: 
 1: nsresult
 1: nsHTMLButtonElement::GetDefaultValue(nsAString& aDefaultValue)
 1: {
 1:   GetAttr(kNameSpaceID_None, nsGkAtoms::value, aDefaultValue);
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsHTMLButtonElement::SetDefaultValue(const nsAString& aDefaultValue)
 1: {
 1:   return SetAttr(kNameSpaceID_None, nsGkAtoms::value, aDefaultValue, PR_TRUE);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::Reset()
 1: {
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::SubmitNamesValues(nsIFormSubmission* aFormSubmission,
 1:                                        nsIContent* aSubmitElement)
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   //
 1:   // We only submit if we were the button pressed
 1:   //
 1:   if (aSubmitElement != this) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   //
 1:   // Disabled elements don't submit
 1:   //
 1:   PRBool disabled;
 1:   rv = GetDisabled(&disabled);
 1:   if (NS_FAILED(rv) || disabled) {
 1:     return rv;
 1:   }
 1: 
 1:   //
 1:   // Get the name (if no name, no submit)
 1:   //
 1:   nsAutoString name;
 1:   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::name, name)) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   //
 1:   // Get the value
 1:   //
 1:   nsAutoString value;
 1:   rv = GetValue(value);
 1:   if (NS_FAILED(rv)) {
 1:     return rv;
 1:   }
 1: 
 1:   //
 1:   // Submit
 1:   //
 1:   rv = aFormSubmission->AddNameValuePair(this, name, value);
 1: 
 1:   return rv;
 1: }
 1: 
 1: void
 1: nsHTMLButtonElement::DoneCreatingElement()
 1: {
 1:   // Restore state as needed.
 1:   RestoreFormControlState(this, this);
 1: }
 1: 
 1: nsresult
 1: nsHTMLButtonElement::BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                                    const nsAString* aValue, PRBool aNotify)
 1: {
 1:   if (aNotify && aName == nsGkAtoms::disabled &&
 1:       aNameSpaceID == kNameSpaceID_None) {
 1:     mDisabledChanged = PR_TRUE;
 1:   }
 1: 
 1:   return nsGenericHTMLFormElement::BeforeSetAttr(aNameSpaceID, aName,
 1:                                                  aValue, aNotify);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLButtonElement::SaveState()
 1: {
 1:   if (!mDisabledChanged) {
 1:     return NS_OK;
 1:   }
 1:   
 1:   nsPresState *state = nsnull;
 1:   nsresult rv = GetPrimaryPresState(this, &state);
 1:   if (state) {
 1:     PRBool disabled;
 1:     GetDisabled(&disabled);
 1:     if (disabled) {
 1:       rv |= state->SetStateProperty(NS_LITERAL_STRING("disabled"),
 1:                                     NS_LITERAL_STRING("t"));
 1:     } else {
 1:       rv |= state->SetStateProperty(NS_LITERAL_STRING("disabled"),
 1:                                     NS_LITERAL_STRING("f"));
 1:     }
 1:     NS_ASSERTION(NS_SUCCEEDED(rv), "disabled save failed!");
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: PRBool
 1: nsHTMLButtonElement::RestoreState(nsPresState* aState)
 1: {
 1:   nsAutoString disabled;
 1:   nsresult rv =
 1:     aState->GetStateProperty(NS_LITERAL_STRING("disabled"), disabled);
 1:   NS_ASSERTION(NS_SUCCEEDED(rv), "disabled restore failed!");
 1:   if (rv == NS_STATE_PROPERTY_EXISTS) {
 1:     SetDisabled(disabled.EqualsLiteral("t"));
 1:   }
 1: 
 1:   return PR_FALSE;
 1: }
