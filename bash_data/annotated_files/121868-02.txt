     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 48320: #ifndef imgRequestProxy_h__
 48320: #define imgRequestProxy_h__
 48320: 
     1: #include "imgIRequest.h"
118750: #include "imgINotificationObserver.h"
 18557: #include "nsISecurityInfoProvider.h"
     1: 
     1: #include "nsIRequestObserver.h"
     1: #include "nsIChannel.h"
     1: #include "nsILoadGroup.h"
     1: #include "nsISupportsPriority.h"
 71556: #include "nsITimedChannel.h"
     1: #include "nsCOMPtr.h"
  6229: #include "nsAutoPtr.h"
 22953: #include "nsThreadUtils.h"
     1: 
     1: #include "imgRequest.h"
     1: 
     1: #define NS_IMGREQUESTPROXY_CID \
     1: { /* 20557898-1dd2-11b2-8f65-9c462ee2bc95 */         \
     1:      0x20557898,                                     \
     1:      0x1dd2,                                         \
     1:      0x11b2,                                         \
     1:     {0x8f, 0x65, 0x9c, 0x46, 0x2e, 0xe2, 0xbc, 0x95} \
     1: }
     1: 
 48321: class imgRequestNotifyRunnable;
 48321: class imgStatusNotifyRunnable;
121868: class ProxyBehaviour;
 48321: 
 50546: namespace mozilla {
 87852: namespace image {
 50546: class Image;
 87852: } // namespace image
 50546: } // namespace mozilla
 50546: 
 71556: class imgRequestProxy : public imgIRequest, 
 71556:                         public nsISupportsPriority, 
 71556:                         public nsISecurityInfoProvider,
 71556:                         public nsITimedChannel
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_IMGIREQUEST
     1:   NS_DECL_NSIREQUEST
     1:   NS_DECL_NSISUPPORTSPRIORITY
 18557:   NS_DECL_NSISECURITYINFOPROVIDER
 71556:   // nsITimedChannel declared below
     1: 
     1:   imgRequestProxy();
     1:   virtual ~imgRequestProxy();
     1: 
 48319:   // Callers to Init or ChangeOwner are required to call NotifyListener after
 48319:   // (although not immediately after) doing so.
118746:   nsresult Init(imgStatusTracker* aStatusTracker,
118746:                 nsILoadGroup *aLoadGroup,
118750:                 nsIURI* aURI, imgINotificationObserver *aObserver);
 48319: 
     1:   nsresult ChangeOwner(imgRequest *aNewOwner); // this will change mOwner.  Do not call this if the previous
     1:                                                // owner has already sent notifications out!
     1: 
     1:   void AddToLoadGroup();
 79445:   void RemoveFromLoadGroup(bool releaseLoadGroup);
     1: 
 79445:   inline bool HasObserver() const {
106838:     return mListener != nullptr;
 48320:   }
 48320: 
 48321:   // Asynchronously notify this proxy's listener of the current state of the
 48321:   // image, and, if we have an imgRequest mOwner, any status changes that
 48321:   // happen between the time this function is called and the time the
 48321:   // notification is scheduled.
 48320:   void NotifyListener();
 48319: 
 48321:   // Synchronously notify this proxy's listener of the current state of the
 48321:   // image. Only use this function if you are currently servicing an
 48321:   // asynchronously-called function.
 48321:   void SyncNotifyListener();
 48321: 
 48936:   // Whether we want notifications from imgStatusTracker to be deferred until
 48936:   // an event it has scheduled has been fired.
 79445:   bool NotificationsDeferred() const
 48936:   {
 48936:     return mDeferNotifications;
 48936:   }
 79445:   void SetNotificationsDeferred(bool aDeferNotifications)
 48936:   {
 48936:     mDeferNotifications = aDeferNotifications;
 48936:   }
 48936: 
118747:   // XXXbholley - This eventually gets folded into the new notification API.
118747:   void SetHasImage();
 51297: 
 52149:   // Removes all animation consumers that were created with
 52149:   // IncrementAnimationConsumers. This is necessary since we need
 52149:   // to do it before the proxy itself is destroyed. See
 52149:   // imgRequest::RemoveProxy
 52149:   void ClearAnimationConsumers();
 52149: 
     1: protected:
 48320:   friend class imgStatusTracker;
 48321:   friend class imgStatusNotifyRunnable;
 48321:   friend class imgRequestNotifyRunnable;
 48319: 
 22953:   class imgCancelRunnable;
 22953:   friend class imgCancelRunnable;
 22953: 
 22953:   class imgCancelRunnable : public nsRunnable
 22953:   {
 22953:     public:
 22953:       imgCancelRunnable(imgRequestProxy* owner, nsresult status)
 22953:         : mOwner(owner), mStatus(status)
 22953:       {}
 22953: 
 22953:       NS_IMETHOD Run() {
 22953:         mOwner->DoCancel(mStatus);
 22953:         return NS_OK;
 22953:       }
 22953: 
 22953:     private:
 22953:       nsRefPtr<imgRequestProxy> mOwner;
 22953:       nsresult mStatus;
 22953:   };
 22953: 
 48321:   // The following notification functions are protected to ensure that (friend
 48321:   // class) imgStatusTracker is the only class allowed to send us
 48321:   // notifications.
 48321: 
     1:   /* non-virtual imgIDecoderObserver methods */
118757:   void OnStartContainer  ();
118758:   void OnFrameUpdate     (const nsIntRect * aRect);
118757:   void OnStopFrame       ();
118752:   void OnStopDecode      ();
 32424:   void OnDiscard         ();
 82096:   void OnImageIsAnimated ();
     1: 
 48317:   /* non-virtual sort-of-nsIRequestObserver methods */
 48317:   void OnStartRequest();
 79445:   void OnStopRequest(bool aLastPart);
     1: 
108324:   /* non-virtual imgIOnloadBlocker methods */
108324:   void BlockOnload();
108324:   void UnblockOnload();
108324: 
 22953:   /* Finish up canceling ourselves */
 22953:   void DoCancel(nsresult status);
 22953: 
 13293:   /* Do the proper refcount management to null out mListener */
 13293:   void NullOutListener();
 13293: 
 39122:   void DoRemoveFromLoadGroup() {
 80486:     RemoveFromLoadGroup(true);
 39122:   }
 48319: 
 51297:   // Return the imgStatusTracker associated with mOwner and/or mImage. It may
 51297:   // live either on mOwner or mImage, depending on whether
 51297:   //   (a) we have an mOwner at all
 51297:   //   (b) whether mOwner has instantiated its image yet
121868:   imgStatusTracker& GetStatusTracker() const;
 51297: 
 71556:   nsITimedChannel* TimedChannel()
 71556:   {
121868:     if (!GetOwner())
106838:       return nullptr;
121868:     return GetOwner()->mTimedChannel;
 71556:   }
 71556: 
121868:   mozilla::image::Image* GetImage() const;
121868:   imgRequest* GetOwner() const;
118747: 
118751:   nsresult PerformClone(imgINotificationObserver* aObserver,
118751:                         imgRequestProxy* (aAllocFn)(imgRequestProxy*),
118751:                         imgIRequest** aClone);
118751: 
 71556: public:
 71556:   NS_FORWARD_SAFE_NSITIMEDCHANNEL(TimedChannel())
 71556: 
121868: protected:
121868:   nsAutoPtr<ProxyBehaviour> mBehaviour;
121868: 
     1: private:
     1:   friend class imgCacheValidator;
121868:   friend imgRequestProxy* NewStaticProxy(imgRequestProxy* aThis);
     1: 
 48319:   // The URI of our request.
 48319:   nsCOMPtr<nsIURI> mURI;
 48319: 
 13293:   // mListener is only promised to be a weak ref (see imgILoader.idl),
 13293:   // but we actually keep a strong ref to it until we've seen our
 13293:   // first OnStopRequest.
118750:   imgINotificationObserver* mListener;
     1:   nsCOMPtr<nsILoadGroup> mLoadGroup;
     1: 
     1:   nsLoadFlags mLoadFlags;
108991:   uint32_t    mLockCount;
108991:   uint32_t    mAnimationConsumers;
 79445:   bool mCanceled;
 79445:   bool mIsInLoadGroup;
 79445:   bool mListenerIsStrongRef;
 79445:   bool mDecodeRequested;
 48321: 
 48321:   // Whether we want to defer our notifications by the non-virtual Observer
 48321:   // interfaces as image loads proceed.
 79445:   bool mDeferNotifications;
 49700: 
 49700:   // We only want to send OnStartContainer once for each proxy, but we might
 98961:   // get multiple OnStartContainer calls.
 79445:   bool mSentStartContainer;
118662: };
118662: 
118742: // Used for static image proxies for which no requests are available, so
118742: // certain behaviours must be overridden to compensate.
118742: class imgRequestProxyStatic : public imgRequestProxy
118742: {
118742: 
118742: public:
118747:   imgRequestProxyStatic(mozilla::image::Image* aImage,
121868:                         nsIPrincipal* aPrincipal);
118742: 
118751:   NS_IMETHOD GetImagePrincipal(nsIPrincipal** aPrincipal) MOZ_OVERRIDE;
118742: 
118751:   NS_IMETHOD Clone(imgINotificationObserver* aObserver,
118751:                    imgIRequest** aClone) MOZ_OVERRIDE;
118751: 
118742: protected:
118751:   friend imgRequestProxy* NewStaticProxy(imgRequestProxy*);
118751: 
118742:   // Our principal. We have to cache it, rather than accessing the underlying
118742:   // request on-demand, because static proxies don't have an underlying request.
118742:   nsCOMPtr<nsIPrincipal> mPrincipal;
118742: };
118742: 
 48320: #endif // imgRequestProxy_h__
