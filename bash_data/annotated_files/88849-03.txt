75157: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54814:  * ***** BEGIN LICENSE BLOCK *****
54814:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54814:  *
54814:  * The contents of this file are subject to the Mozilla Public License Version
54814:  * 1.1 (the "License"); you may not use this file except in compliance with
54814:  * the License. You may obtain a copy of the License at
54814:  * http://www.mozilla.org/MPL/
54814:  *
54814:  * Software distributed under the License is distributed on an "AS IS" basis,
54814:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54814:  * for the specific language governing rights and limitations under the
54814:  * License.
54814:  *
54814:  * The Original Code is Mozilla Corporation code.
54814:  *
54814:  * The Initial Developer of the Original Code is Mozilla Foundation.
54814:  * Portions created by the Initial Developer are Copyright (C) 2009
54814:  * the Initial Developer. All Rights Reserved.
54814:  *
54814:  * Contributor(s):
54814:  *   Bas Schouten <bschouten@mozilla.com>
54814:  *
54814:  * Alternatively, the contents of this file may be used under the terms of
54814:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54814:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54814:  * in which case the provisions of the GPL or the LGPL are applicable instead
54814:  * of those above. If you wish to allow use of your version of this file only
54814:  * under the terms of either the GPL or the LGPL, and not to allow others to
54814:  * use your version of this file under the terms of the MPL, indicate your
54814:  * decision by deleting the provisions above and replace them with the notice
54814:  * and other provisions required by the GPL or the LGPL. If you do not delete
54814:  * the provisions above, a recipient may use your version of this file under
54814:  * the terms of any one of the MPL, the GPL or the LGPL.
54814:  *
54814:  * ***** END LICENSE BLOCK ***** */
54814: 
54814: #ifndef GFX_LAYERMANAGERD3D10_H
54814: #define GFX_LAYERMANAGERD3D10_H
54814: 
75157: #include "mozilla/layers/PLayers.h"
75153: #include "mozilla/layers/ShadowLayers.h"
54814: #include "Layers.h"
54814: 
54814: #include <windows.h>
54814: #include <d3d10_1.h>
54814: 
54814: #include "gfxContext.h"
54814: #include "nsIWidget.h"
54814: 
62702: #include "ReadbackManagerD3D10.h"
62702: 
54814: namespace mozilla {
54814: namespace layers {
54814: 
75157: class DummyRoot;
60419: class Nv3DVUtils;
60419: 
54814: /**
54814:  * This structure is used to pass rectangles to our shader constant. We can use
54814:  * this for passing rectangular areas to SetVertexShaderConstant. In the format
54814:  * of a 4 component float(x,y,width,height). Our vertex shader can then use
54814:  * this to construct rectangular positions from the 0,0-1,1 quad that we source
54814:  * it with.
54814:  */
54814: struct ShaderConstantRectD3D10
54814: {
54814:   float mX, mY, mWidth, mHeight;
54814:   ShaderConstantRectD3D10(float aX, float aY, float aWidth, float aHeight)
54814:     : mX(aX), mY(aY), mWidth(aWidth), mHeight(aHeight)
54814:   { }
54814: 
54814:   // For easy passing to SetVertexShaderConstantF.
54814:   operator float* () { return &mX; }
54814: };
54814: 
54814: extern cairo_user_data_key_t gKeyD3D10Texture;
54814: 
54814: /*
75155:  * This is the LayerManager used for Direct3D 10. For now this will
75155:  * render on the main thread.
75155:  *
75155:  * For the time being, LayerManagerD3D10 both forwards layers
75155:  * transactions and receives forwarded transactions.  In the Azure
75155:  * future, it will only be a ShadowLayerManager.
54814:  */
75155: class THEBES_API LayerManagerD3D10 : public ShadowLayerManager,
75155:                                      public ShadowLayerForwarder {
54814: public:
75155:   typedef LayerManager::LayersBackend LayersBackend;
75155: 
54814:   LayerManagerD3D10(nsIWidget *aWidget);
54814:   virtual ~LayerManagerD3D10();
54814: 
54814:   /*
54814:    * Initializes the layer manager, this is when the layer manager will
54814:    * actually access the device and attempt to create the swap chain used
54814:    * to draw to the window. If this method fails the device cannot be used.
54814:    * This function is not threadsafe.
54814:    *
54814:    * \return True is initialization was succesful, false when it was not.
54814:    */
88849:   bool Initialize(bool force = false);
54814: 
54814:   /*
54814:    * LayerManager implementation.
54814:    */
56116:   virtual void Destroy();
56116: 
75155:   virtual ShadowLayerForwarder* AsShadowForwarder()
75155:   { return this; }
75155: 
75155:   virtual ShadowLayerManager* AsShadowManager()
75155:   { return this; }
75155: 
54814:   virtual void SetRoot(Layer *aLayer);
54814: 
60859:   virtual void BeginTransaction();
54814: 
60859:   virtual void BeginTransactionWithTarget(gfxContext* aTarget);
60859: 
60859:   virtual bool EndEmptyTransaction();
54814: 
54814:   struct CallbackInfo {
54814:     DrawThebesLayerCallback Callback;
54814:     void *CallbackData;
54814:   };
54814: 
60859:   virtual void EndTransaction(DrawThebesLayerCallback aCallback,
78887:                               void* aCallbackData,
78887:                               EndTransactionFlags aFlags = END_DEFAULT);
54814: 
54814:   const CallbackInfo &GetCallbackInfo() { return mCurrentCallbackInfo; }
54814: 
73612:   // D3D10 guarantees textures can be at least this size
73612:   enum {
73612:     MAX_TEXTURE_SIZE = 8192
73612:   };
73612:   virtual bool CanUseCanvasLayerForSize(const gfxIntSize &aSize)
73612:   {
73612:     return aSize <= gfxIntSize(MAX_TEXTURE_SIZE, MAX_TEXTURE_SIZE);
73612:   }
73612: 
54814:   virtual already_AddRefed<ThebesLayer> CreateThebesLayer();
75155:   virtual already_AddRefed<ShadowThebesLayer> CreateShadowThebesLayer();
54814: 
54814:   virtual already_AddRefed<ContainerLayer> CreateContainerLayer();
75155:   virtual already_AddRefed<ShadowContainerLayer> CreateShadowContainerLayer();
54814: 
54814:   virtual already_AddRefed<ImageLayer> CreateImageLayer();
75155:   virtual already_AddRefed<ShadowImageLayer> CreateShadowImageLayer()
75155:   { return nsnull; }
54814: 
54814:   virtual already_AddRefed<ColorLayer> CreateColorLayer();
75155:   virtual already_AddRefed<ShadowColorLayer> CreateShadowColorLayer()
75155:   { return nsnull; }
54814: 
54814:   virtual already_AddRefed<CanvasLayer> CreateCanvasLayer();
75155:   virtual already_AddRefed<ShadowCanvasLayer> CreateShadowCanvasLayer()
75155:   { return nsnull; }
54814: 
62702:   virtual already_AddRefed<ReadbackLayer> CreateReadbackLayer();
62702: 
54814:   virtual already_AddRefed<ImageContainer> CreateImageContainer();
54814: 
54814:   virtual already_AddRefed<gfxASurface>
54814:     CreateOptimalSurface(const gfxIntSize &aSize,
54814:                          gfxASurface::gfxImageFormat imageFormat);
54814: 
72426:   virtual TemporaryRef<mozilla::gfx::DrawTarget>
72426:     CreateDrawTarget(const mozilla::gfx::IntSize &aSize,
72426:                      mozilla::gfx::SurfaceFormat aFormat);
72426: 
54814:   virtual LayersBackend GetBackendType() { return LAYERS_D3D10; }
54814:   virtual void GetBackendName(nsAString& name) { name.AssignLiteral("Direct3D 10"); }
54814: 
54814: #ifdef MOZ_LAYERS_HAVE_LOG
60904:   virtual const char* Name() const { return "D3D10"; }
54814: #endif // MOZ_LAYERS_HAVE_LOG
54814: 
54814:   // Public helpers
54814: 
54814:   ID3D10Device1 *device() const { return mDevice; }
54814: 
54814:   ID3D10Effect *effect() const { return mEffect; }
54814: 
62702:   ReadbackManagerD3D10 *readbackManager();
62702: 
54814:   void SetViewport(const nsIntSize &aViewport);
54814:   const nsIntSize &GetViewport() { return mViewport; }
54814: 
60419:   /**
60419:    * Return pointer to the Nv3DVUtils instance
60419:    */
60419:   Nv3DVUtils *GetNv3DVUtils()  { return mNv3DVUtils; }
60419: 
73783:   static void ReportFailure(const nsACString &aMsg, HRESULT aCode);
60333: 
54814: private:
54814:   void SetupPipeline();
54814:   void UpdateRenderTarget();
54814:   void VerifyBufferSize();
62702:   void EnsureReadbackManager();
54814: 
54814:   void Render();
54814: 
54814:   nsRefPtr<ID3D10Device1> mDevice;
54814: 
54814:   nsRefPtr<ID3D10Effect> mEffect;
54814:   nsRefPtr<ID3D10InputLayout> mInputLayout;
54814:   nsRefPtr<ID3D10Buffer> mVertexBuffer;
62702:   nsRefPtr<ReadbackManagerD3D10> mReadbackManager;
54814: 
54814:   nsRefPtr<ID3D10RenderTargetView> mRTView;
54814: 
54814:   nsRefPtr<IDXGISwapChain> mSwapChain;
54814: 
54814:   nsIWidget *mWidget;
54814: 
54814:   CallbackInfo mCurrentCallbackInfo;
54814: 
54814:   nsIntSize mViewport;
54814: 
60419:   /* Nv3DVUtils instance */ 
60419:   nsAutoPtr<Nv3DVUtils> mNv3DVUtils; 
60419: 
54814:   /*
54814:    * Context target, NULL when drawing directly to our swap chain.
54814:    */
54814:   nsRefPtr<gfxContext> mTarget;
54814: 
54814:   /*
75156:    * We use a double-buffered "window surface" to display our content
75156:    * in the compositor process, if we're remote.  The textures act
75156:    * like the backing store for an OS window --- we render the layer
75156:    * tree into the back texture and send it to the compositor, then
75156:    * swap back/front textures.  This means, obviously, that we've lost
75156:    * all layer tree information after rendering.
75156:    *
75156:    * The remote front buffer is the texture currently being displayed
75156:    * by chrome.  We keep a reference to it to simplify resource
75156:    * management; if we didn't, then there can be periods during IPC
75156:    * transport when neither process holds a "real" ref.  That's
75156:    * solvable but not worth the complexity.
75156:    */
75156:   nsRefPtr<ID3D10Texture2D> mBackBuffer;
75156:   nsRefPtr<ID3D10Texture2D> mRemoteFrontBuffer;
75158:   /*
75158:    * If we're remote content, this is the root of the shadowable tree
75158:    * we send to the compositor.
75158:    */
75158:   nsRefPtr<DummyRoot> mRootForShadowTree;
75156: 
75156:   /*
54814:    * Copies the content of our backbuffer to the set transaction target.
54814:    */
54814:   void PaintToTarget();
54814: };
54814: 
54814: /*
54814:  * General information and tree management for OGL layers.
54814:  */
54814: class LayerD3D10
54814: {
54814: public:
54814:   LayerD3D10(LayerManagerD3D10 *aManager);
54814: 
54814:   virtual LayerD3D10 *GetFirstChildD3D10() { return nsnull; }
54814: 
54814:   void SetFirstChild(LayerD3D10 *aParent);
54814: 
54814:   virtual Layer* GetLayer() = 0;
54814: 
54814:   /**
54814:    * This will render a child layer to whatever render target is currently
57097:    * active.
54814:    */
57097:   virtual void RenderLayer() = 0;
54814:   virtual void Validate() {}
54814: 
54814:   ID3D10Device1 *device() const { return mD3DManager->device(); }
54814:   ID3D10Effect *effect() const { return mD3DManager->effect(); }
54814: 
54814:   /* Called by the layer manager when it's destroyed */
54814:   virtual void LayerManagerDestroyed() {}
57097: 
60419:   /**
60419:    * Return pointer to the Nv3DVUtils instance. Calls equivalent method in LayerManager.
60419:    */
60419:   Nv3DVUtils *GetNv3DVUtils()  { return mD3DManager->GetNv3DVUtils(); }
60419: 
60419: 
57097:   void SetEffectTransformAndOpacity()
57097:   {
57097:     Layer* layer = GetLayer();
57097:     const gfx3DMatrix& transform = layer->GetEffectiveTransform();
57097:     void* raw = &const_cast<gfx3DMatrix&>(transform)._11;
57097:     effect()->GetVariableByName("mLayerTransform")->SetRawValue(raw, 0, 64);
57097:     effect()->GetVariableByName("fLayerOpacity")->AsScalar()->SetFloat(layer->GetEffectiveOpacity());
57097:   }
57097: 
54814: protected:
54814:   LayerManagerD3D10 *mD3DManager;
54814: };
54814: 
75157: /**
75157:  * WindowLayer is a simple, special kinds of shadowable layer into
75157:  * which layer trees are rendered.  It represents something like an OS
75157:  * window.  It exists only to allow sharing textures with the
75157:  * compositor while reusing existing shadow-layer machinery.
75157:  *
75157:  * WindowLayer being implemented as a thebes layer isn't an important
75157:  * detail; other layer types could have been used.
75157:  */
75157: class WindowLayer : public ThebesLayer, public ShadowableLayer {
75157: public:
75157:   WindowLayer(LayerManagerD3D10* aManager);
75157:   virtual ~WindowLayer();
75157: 
75157:   void InvalidateRegion(const nsIntRegion&) {}
75157:   Layer* AsLayer() { return this; }
75157: 
75157:   void SetShadow(PLayerChild* aChild) { mShadow = aChild; }
75157: };
75157: 
75157: /**
75157:  * DummyRoot is the root of the shadowable layer tree created by
75157:  * remote content.  It exists only to contain WindowLayers.  It always
75157:  * has exactly one child WindowLayer.
75157:  */
75157: class DummyRoot : public ContainerLayer, public ShadowableLayer {
75157: public:
75157:   DummyRoot(LayerManagerD3D10* aManager);
75157:   virtual ~DummyRoot();
75157: 
75157:   void ComputeEffectiveTransforms(const gfx3DMatrix&) {}
75157:   void InsertAfter(Layer*, Layer*);
75157:   void RemoveChild(Layer*);
75157:   Layer* AsLayer() { return this; }
75157: 
75157:   void SetShadow(PLayerChild* aChild) { mShadow = aChild; }
75157: };
75157: 
54814: } /* layers */
54814: } /* mozilla */
54814: 
54814: #endif /* GFX_LAYERMANAGERD3D9_H */
