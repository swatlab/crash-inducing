21320: /* -*- Mode: c++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*- */
21320: /* ***** BEGIN LICENSE BLOCK *****
21320:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
21320:  *
21320:  * The contents of this file are subject to the Mozilla Public License Version
21320:  * 1.1 (the "License"); you may not use this file except in compliance with
21320:  * the License. You may obtain a copy of the License at
21320:  * http://www.mozilla.org/MPL/
21320:  *
21320:  * Software distributed under the License is distributed on an "AS IS" basis,
21320:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
21320:  * for the specific language governing rights and limitations under the
21320:  * License.
21320:  *
21320:  * The Original Code is Web Workers.
21320:  *
21320:  * The Initial Developer of the Original Code is
21320:  *   Mozilla Corporation.
21320:  * Portions created by the Initial Developer are Copyright (C) 2008
21320:  * the Initial Developer. All Rights Reserved.
21320:  *
21320:  * Contributor(s):
21320:  *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
21320:  *
21320:  * Alternatively, the contents of this file may be used under the terms of
21320:  * either the GNU General Public License Version 2 or later (the "GPL"), or
21320:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
21320:  * in which case the provisions of the GPL or the LGPL are applicable instead
21320:  * of those above. If you wish to allow use of your version of this file only
21320:  * under the terms of either the GPL or the LGPL, and not to allow others to
21320:  * use your version of this file under the terms of the MPL, indicate your
21320:  * decision by deleting the provisions above and replace them with the notice
21320:  * and other provisions required by the GPL or the LGPL. If you do not delete
21320:  * the provisions above, a recipient may use your version of this file under
21320:  * the terms of any one of the MPL, the GPL or the LGPL.
21320:  *
21320:  * ***** END LICENSE BLOCK ***** */
21320: 
21320: #include "nsDOMWorker.h"
21320: 
21320: #include "nsIDOMEvent.h"
21320: #include "nsIEventTarget.h"
21320: #include "nsIJSRuntimeService.h"
21320: #include "nsIXPConnect.h"
21320: 
21320: #ifdef MOZ_SHARK
21320: #include "jsdbgapi.h"
21320: #endif
21320: #include "nsAutoLock.h"
22477: #include "nsAXPCNativeCallContext.h"
21320: #include "nsContentUtils.h"
21320: #include "nsDOMClassInfoID.h"
21320: #include "nsGlobalWindow.h"
22477: #include "nsJSON.h"
21320: #include "nsJSUtils.h"
22039: #include "nsProxyRelease.h"
21320: #include "nsThreadUtils.h"
21320: 
21320: #include "nsDOMThreadService.h"
21320: #include "nsDOMWorkerEvents.h"
31409: #include "nsDOMWorkerLocation.h"
22036: #include "nsDOMWorkerNavigator.h"
21320: #include "nsDOMWorkerPool.h"
21320: #include "nsDOMWorkerScriptLoader.h"
21320: #include "nsDOMWorkerTimeout.h"
21320: #include "nsDOMWorkerXHR.h"
21320: 
21320: class nsDOMWorkerFunctions
21320: {
21320: public:
21320:   // Same as window.dump().
21320:   static JSBool Dump(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                      jsval* aArgv, jsval* aRval);
21320: 
21320:   // Same as window.setTimeout().
21320:   static JSBool SetTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                            jsval* aArgv, jsval* aRval) {
21320:     return MakeTimeout(aCx, aObj, aArgc, aArgv, aRval, PR_FALSE);
21320:   }
21320: 
21320:   // Same as window.setInterval().
21320:   static JSBool SetInterval(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                             jsval* aArgv, jsval* aRval) {
21320:     return MakeTimeout(aCx, aObj, aArgc, aArgv, aRval, PR_TRUE);
21320:   }
21320: 
21320:   // Used for both clearTimeout() and clearInterval().
21320:   static JSBool KillTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                             jsval* aArgv, jsval* aRval);
21320: 
21320:   static JSBool LoadScripts(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                             jsval* aArgv, jsval* aRval);
21320: 
21320:   static JSBool NewXMLHttpRequest(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                                   jsval* aArgv, jsval* aRval);
21320: 
21320:   static JSBool NewWorker(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                           jsval* aArgv, jsval* aRval);
21320: 
21320: private:
21320:   // Internal helper for SetTimeout and SetInterval.
21320:   static JSBool MakeTimeout(JSContext* aCx, JSObject* aObj, uintN aArgc,
21320:                             jsval* aArgv, jsval* aRval, PRBool aIsInterval);
21320: };
21320: 
21320: JSBool
21320: nsDOMWorkerFunctions::Dump(JSContext* aCx,
21320:                            JSObject* /* aObj */,
21320:                            uintN aArgc,
21320:                            jsval* aArgv,
21320:                            jsval* /* aRval */)
21320: {
21320:   if (!nsGlobalWindow::DOMWindowDumpEnabled()) {
21320:     return JS_TRUE;
21320:   }
21320: 
21320:   JSString* str;
21320:   if (aArgc && (str = JS_ValueToString(aCx, aArgv[0])) && str) {
21320:     nsDependentJSString string(str);
21320:     fputs(NS_ConvertUTF16toUTF8(nsDependentJSString(str)).get(), stderr);
21320:     fflush(stderr);
21320:   }
21320:   return JS_TRUE;
21320: }
21320: 
21320: JSBool
21320: nsDOMWorkerFunctions::MakeTimeout(JSContext* aCx,
21320:                                   JSObject* /* aObj */,
21320:                                   uintN aArgc,
21320:                                   jsval* aArgv,
21320:                                   jsval* aRval,
21320:                                   PRBool aIsInterval)
21320: {
21320:   nsDOMWorker* worker = static_cast<nsDOMWorker*>(JS_GetContextPrivate(aCx));
21320:   NS_ASSERTION(worker, "This should be set by the DOM thread service!");
21320: 
21320:   if (worker->IsCanceled()) {
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   PRUint32 id = worker->NextTimeoutId();
21320: 
26209:   if (worker->IsClosing()) {
26209:     // Timeouts won't run in the close handler, fake success and bail.
26209:     *aRval = INT_TO_JSVAL(id);
26209:     return JS_TRUE;
26209:   }
26209: 
21320:   nsRefPtr<nsDOMWorkerTimeout> timeout = new nsDOMWorkerTimeout(worker, id);
21320:   if (!timeout) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsresult rv = timeout->Init(aCx, aArgc, aArgv, aIsInterval);
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportError(aCx, "Failed to initialize timeout!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   rv = worker->AddFeature(timeout, aCx);
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   rv = timeout->Start();
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportError(aCx, "Failed to start timeout!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   *aRval = INT_TO_JSVAL(id);
21320:   return JS_TRUE;
21320: }
21320: 
21320: JSBool
21320: nsDOMWorkerFunctions::KillTimeout(JSContext* aCx,
21320:                                   JSObject* /* aObj */,
21320:                                   uintN aArgc,
21320:                                   jsval* aArgv,
21320:                                   jsval* /* aRval */)
21320: {
21320:   nsDOMWorker* worker = static_cast<nsDOMWorker*>(JS_GetContextPrivate(aCx));
21320:   NS_ASSERTION(worker, "This should be set by the DOM thread service!");
21320: 
21320:   if (worker->IsCanceled()) {
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   if (!aArgc) {
21320:     JS_ReportError(aCx, "Function requires at least 1 parameter");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   uint32 id;
21320:   if (!JS_ValueToECMAUint32(aCx, aArgv[0], &id)) {
21320:     JS_ReportError(aCx, "First argument must be a timeout id");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   worker->CancelTimeoutWithId(PRUint32(id));
21320:   return JS_TRUE;
21320: }
21320: 
21320: JSBool
21320: nsDOMWorkerFunctions::LoadScripts(JSContext* aCx,
21320:                                   JSObject* /* aObj */,
21320:                                   uintN aArgc,
21320:                                   jsval* aArgv,
21320:                                   jsval* /* aRval */)
21320: {
21320:   nsDOMWorker* worker = static_cast<nsDOMWorker*>(JS_GetContextPrivate(aCx));
21320:   NS_ASSERTION(worker, "This should be set by the DOM thread service!");
21320: 
21320:   if (worker->IsCanceled()) {
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   if (!aArgc) {
23616:     // No argument is ok according to spec.
23616:     return JS_TRUE;
21320:   }
21320: 
21320:   nsAutoTArray<nsString, 10> urls;
21320: 
21320:   if (!urls.SetCapacity((PRUint32)aArgc)) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   for (uintN index = 0; index < aArgc; index++) {
21320:     jsval val = aArgv[index];
21320: 
21320:     if (!JSVAL_IS_STRING(val)) {
21320:       JS_ReportError(aCx, "Argument %d must be a string", index);
21320:       return JS_FALSE;
21320:     }
21320: 
21320:     JSString* str = JS_ValueToString(aCx, val);
21320:     if (!str) {
21320:       JS_ReportError(aCx, "Couldn't convert argument %d to a string", index);
21320:       return JS_FALSE;
21320:     }
21320: 
21320:     nsString* newURL = urls.AppendElement();
21320:     NS_ASSERTION(newURL, "Shouldn't fail if SetCapacity succeeded above!");
21320: 
21320:     newURL->Assign(nsDependentJSString(str));
21320:   }
21320: 
21320:   nsRefPtr<nsDOMWorkerScriptLoader> loader =
21320:     new nsDOMWorkerScriptLoader(worker);
21320:   if (!loader) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsresult rv = worker->AddFeature(loader, aCx);
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
22039:   rv = loader->LoadScripts(aCx, urls, PR_FALSE);
21320:   if (NS_FAILED(rv)) {
21320:     if (!JS_IsExceptionPending(aCx)) {
21320:       JS_ReportError(aCx, "Failed to load scripts");
21320:     }
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   return JS_TRUE;
21320: }
21320: 
21320: JSBool
21320: nsDOMWorkerFunctions::NewXMLHttpRequest(JSContext* aCx,
21320:                                         JSObject* aObj,
21320:                                         uintN aArgc,
21320:                                         jsval* /* aArgv */,
21320:                                         jsval* aRval)
21320: {
21320:   nsDOMWorker* worker = static_cast<nsDOMWorker*>(JS_GetContextPrivate(aCx));
21320:   NS_ASSERTION(worker, "This should be set by the DOM thread service!");
21320: 
21320:   if (worker->IsCanceled()) {
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   if (aArgc) {
21320:     JS_ReportError(aCx, "XMLHttpRequest constructor takes no arguments!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsRefPtr<nsDOMWorkerXHR> xhr = new nsDOMWorkerXHR(worker);
21320:   if (!xhr) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsresult rv = xhr->Init();
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportError(aCx, "Failed to construct XMLHttpRequest!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   rv = worker->AddFeature(xhr, aCx);
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsCOMPtr<nsIXPConnectJSObjectHolder> xhrWrapped;
31981:   jsval v;
31981:   rv = nsContentUtils::WrapNative(aCx, aObj,
31981:                                   static_cast<nsIXMLHttpRequest*>(xhr), &v,
31981:                                   getter_AddRefs(xhrWrapped));
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportError(aCx, "Failed to wrap XMLHttpRequest!");
21320:     return JS_FALSE;
21320:   }
21320: 
31981:   *aRval = v;
21320:   return JS_TRUE;
21320: }
21320: 
21320: JSBool
21320: nsDOMWorkerFunctions::NewWorker(JSContext* aCx,
21320:                                 JSObject* aObj,
21320:                                 uintN aArgc,
21320:                                 jsval* aArgv,
21320:                                 jsval* aRval)
21320: {
21320:   nsDOMWorker* worker = static_cast<nsDOMWorker*>(JS_GetContextPrivate(aCx));
21320:   NS_ASSERTION(worker, "This should be set by the DOM thread service!");
21320: 
21320:   if (worker->IsCanceled()) {
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   if (!aArgc) {
21320:     JS_ReportError(aCx, "Worker constructor must have an argument!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   // This pointer is protected by our pool, but it is *not* threadsafe and must
21320:   // not be used in any way other than to pass it along to the Initialize call.
26209:   nsIScriptGlobalObject* owner = worker->Pool()->ScriptGlobalObject();
21320:   if (!owner) {
21320:     JS_ReportError(aCx, "Couldn't get owner from pool!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsCOMPtr<nsIXPConnectWrappedNative> wrappedWorker =
21320:     worker->GetWrappedNative();
21320:   if (!wrappedWorker) {
21320:     JS_ReportError(aCx, "Couldn't get wrapped native of worker!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsRefPtr<nsDOMWorker> newWorker = new nsDOMWorker(worker, wrappedWorker);
21320:   if (!newWorker) {
21320:     JS_ReportOutOfMemory(aCx);
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsresult rv = newWorker->InitializeInternal(owner, aCx, aObj, aArgc, aArgv);
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportError(aCx, "Couldn't initialize new worker!");
21320:     return JS_FALSE;
21320:   }
21320: 
21320:   nsCOMPtr<nsIXPConnectJSObjectHolder> workerWrapped;
31981:   jsval v;
31981:   rv = nsContentUtils::WrapNative(aCx, aObj, static_cast<nsIWorker*>(newWorker),
31981:                                   &v, getter_AddRefs(workerWrapped));
21320:   if (NS_FAILED(rv)) {
21320:     JS_ReportError(aCx, "Failed to wrap new worker!");
21320:     return JS_FALSE;
21320:   }
21320: 
31981:   *aRval = v;
21320:   return JS_TRUE;
21320: }
21320: 
21320: JSFunctionSpec gDOMWorkerFunctions[] = {
21320:   { "dump",                  nsDOMWorkerFunctions::Dump,              1, 0, 0 },
21320:   { "setTimeout",            nsDOMWorkerFunctions::SetTimeout,        1, 0, 0 },
21320:   { "clearTimeout",          nsDOMWorkerFunctions::KillTimeout,       1, 0, 0 },
21320:   { "setInterval",           nsDOMWorkerFunctions::SetInterval,       1, 0, 0 },
21320:   { "clearInterval",         nsDOMWorkerFunctions::KillTimeout,       1, 0, 0 },
21320:   { "importScripts",         nsDOMWorkerFunctions::LoadScripts,       1, 0, 0 },
21320:   { "XMLHttpRequest",        nsDOMWorkerFunctions::NewXMLHttpRequest, 0, 0, 0 },
21320:   { "Worker",                nsDOMWorkerFunctions::NewWorker,         1, 0, 0 },
21320: #ifdef MOZ_SHARK
21320:   { "startShark",            js_StartShark,                           0, 0, 0 },
21320:   { "stopShark",             js_StopShark,                            0, 0, 0 },
21320:   { "connectShark",          js_ConnectShark,                         0, 0, 0 },
21320:   { "disconnectShark",       js_DisconnectShark,                      0, 0, 0 },
21320: #endif
21320:   { nsnull,                  nsnull,                                  0, 0, 0 }
21320: };
21320: 
23261: nsDOMWorkerScope::nsDOMWorkerScope(nsDOMWorker* aWorker)
23261: : mWorker(aWorker),
26209:   mWrappedNative(nsnull),
23261:   mHasOnerror(PR_FALSE)
21320: {
21320:   NS_ASSERTION(aWorker, "Null pointer!");
21320: }
21320: 
26209: NS_IMPL_ISUPPORTS_INHERITED3(nsDOMWorkerScope, nsDOMWorkerMessageHandler,
26209:                                                nsIWorkerScope,
21320:                                                nsIWorkerGlobalScope,
26209:                                                nsIXPCScriptable)
21320: 
37185: NS_IMPL_CI_INTERFACE_GETTER5(nsDOMWorkerScope, nsIWorkerScope,
21320:                                                nsIWorkerGlobalScope,
37185:                                                nsIDOMNSEventTarget,
21320:                                                nsIDOMEventTarget,
21320:                                                nsIXPCScriptable)
21320: 
21320: NS_IMPL_THREADSAFE_DOM_CI_GETINTERFACES(nsDOMWorkerScope)
21320: NS_IMPL_THREADSAFE_DOM_CI_ALL_THE_REST(nsDOMWorkerScope)
21320: 
21320: // Need to return a scriptable helper so that XPConnect can get our
21320: // nsIXPCScriptable flags properly (to not enumerate QI, for instance).
21320: NS_IMETHODIMP
21320: nsDOMWorkerScope::GetHelperForLanguage(PRUint32 aLanguage,
21320:                                        nsISupports** _retval)
21320: {
21320:   if (aLanguage == nsIProgrammingLanguage::JAVASCRIPT) {
21320:     NS_ADDREF(*_retval = NS_ISUPPORTS_CAST(nsIWorkerScope*, this));
21320:   }
21320:   else {
21320:     *_retval = nsnull;
21320:   }
21320:   return NS_OK;
21320: }
21320: 
21320: // Use the xpc_map_end.h macros to generate the nsIXPCScriptable methods we want
21320: // for the scope.
21320: 
21320: #define XPC_MAP_CLASSNAME nsDOMWorkerScope
21320: #define XPC_MAP_QUOTED_CLASSNAME "DedicatedWorkerGlobalScope"
26209: #define XPC_MAP_WANT_POSTCREATE
26209: #define XPC_MAP_WANT_TRACE
26209: #define XPC_MAP_WANT_FINALIZE
21320: 
21320: #define XPC_MAP_FLAGS                                      \
21320:   nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY           | \
21320:   nsIXPCScriptable::USE_JSSTUB_FOR_DELPROPERTY           | \
21320:   nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY           | \
21320:   nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE            | \
21320:   nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY            | \
24019:   nsIXPCScriptable::DONT_REFLECT_INTERFACE_NAMES         | \
24019:   nsIXPCScriptable::WANT_ADDPROPERTY
24019: 
24019: #define XPC_MAP_WANT_ADDPROPERTY
21320: 
21320: #include "xpc_map_end.h"
21320: 
21320: NS_IMETHODIMP
26209: nsDOMWorkerScope::PostCreate(nsIXPConnectWrappedNative*  aWrapper,
26209:                              JSContext* /* aCx */,
26209:                              JSObject* /* aObj */)
26209: {
26209:   NS_ASSERTION(!mWrappedNative, "Already got a wrapper?!");
26209:   mWrappedNative = aWrapper;
26209:   return NS_OK;
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorkerScope::Trace(nsIXPConnectWrappedNative* /* aWrapper */,
26209:                         JSTracer* aTracer,
26209:                         JSObject* /*aObj */)
26209: {
26209:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
26209:   nsDOMWorkerMessageHandler::Trace(aTracer);
26209:   return NS_OK;
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorkerScope::Finalize(nsIXPConnectWrappedNative* /* aWrapper */,
26209:                            JSContext* /* aCx */,
26209:                            JSObject* /* aObj */)
26209: {
26209:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
26209:   ClearAllListeners();
26209:   mWrappedNative = nsnull;
26209:   return NS_OK;
26209: }
26209: 
26209: already_AddRefed<nsIXPConnectWrappedNative>
26209: nsDOMWorkerScope::GetWrappedNative()
26209: {
26209:   nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative = mWrappedNative;
26209:   NS_ASSERTION(wrappedNative, "Null wrapped native!");
26209:   return wrappedNative.forget();
26209: }
26209: 
26209: NS_IMETHODIMP
24019: nsDOMWorkerScope::AddProperty(nsIXPConnectWrappedNative* aWrapper,
24019:                               JSContext* aCx,
24019:                               JSObject* aObj,
24019:                               jsval aId,
24019:                               jsval* aVp,
24019:                               PRBool* _retval)
24019: {
24019:   // We're not going to be setting any exceptions manually so set _retval to
24019:   // true in the beginning.
24019:   *_retval = PR_TRUE;
24019: 
24019:   // Bail out now if any of our prerequisites are not met. We only care about
24019:   // someone making an 'onmessage' or 'onerror' function so aId must be a
24019:   // string and aVp must be a function.
24019:   JSObject* funObj;
24019:   if (!(JSVAL_IS_STRING(aId) &&
24019:         JSVAL_IS_OBJECT(*aVp) &&
24019:         (funObj = JSVAL_TO_OBJECT(*aVp)) &&
24019:         JS_ObjectIsFunction(aCx, funObj))) {
24019:     return NS_OK;
24019:   }
24019: 
24019:   const char* name = JS_GetStringBytes(JSVAL_TO_STRING(aId));
24019: 
24019:   // Figure out which listener we're setting.
24019:   SetListenerFunc func;
24019:   if (!strcmp(name, "onmessage")) {
24019:     func = &nsDOMWorkerScope::SetOnmessage;
24019:   }
24019:   else if (!strcmp(name, "onerror")) {
24019:     func = &nsDOMWorkerScope::SetOnerror;
24019:   }
24019:   else {
24019:     // Some other function, we don't need to do anything special after all.
24019:     return NS_OK;
24019:   }
24019: 
24019:   // Wrap the function as an nsIDOMEventListener.
24019:   nsCOMPtr<nsIDOMEventListener> listener;
24019:   nsresult rv =
24019:     nsContentUtils::XPConnect()->WrapJS(aCx, funObj,
24019:                                         NS_GET_IID(nsIDOMEventListener),
24019:                                         getter_AddRefs(listener));
24019:   NS_ENSURE_SUCCESS(rv, rv);
24019: 
24019:   // And pass the listener to the appropriate setter.
24019:   rv = (this->*func)(listener);
24019:   NS_ENSURE_SUCCESS(rv, rv);
24019: 
24019:   return NS_OK;
24019: }
24019: 
24019: NS_IMETHODIMP
21320: nsDOMWorkerScope::GetSelf(nsIWorkerGlobalScope** aSelf)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320:   NS_ENSURE_ARG_POINTER(aSelf);
21320: 
21320:   if (mWorker->IsCanceled()) {
21320:     return NS_ERROR_ABORT;
21320:   }
21320: 
21320:   NS_ADDREF(*aSelf = this);
21320:   return NS_OK;
21320: }
21320: 
21320: NS_IMETHODIMP
22036: nsDOMWorkerScope::GetNavigator(nsIWorkerNavigator** _retval)
22036: {
22036:   if (!mNavigator) {
22036:     mNavigator = new nsDOMWorkerNavigator();
22036:     NS_ENSURE_TRUE(mNavigator, NS_ERROR_OUT_OF_MEMORY);
22036:   }
22036: 
22036:   NS_ADDREF(*_retval = mNavigator);
22036:   return NS_OK;
22036: }
22036: 
22036: NS_IMETHODIMP
31409: nsDOMWorkerScope::GetLocation(nsIWorkerLocation** _retval)
31409: {
31409:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
31409: 
31409:   nsCOMPtr<nsIWorkerLocation> location = mWorker->GetLocation();
31409:   NS_ASSERTION(location, "This should never be null!");
31409: 
31409:   location.forget(_retval);
31409:   return NS_OK;
31409: }
31409: 
31409: NS_IMETHODIMP
23261: nsDOMWorkerScope::GetOnerror(nsIDOMEventListener** aOnerror)
23261: {
23261:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
23261:   NS_ENSURE_ARG_POINTER(aOnerror);
23261: 
23261:   if (mWorker->IsCanceled()) {
23261:     return NS_ERROR_ABORT;
23261:   }
23261: 
23261:   if (!mHasOnerror) {
23261:     // Spec says we have to return 'undefined' until something is set here.
23261:     nsIXPConnect* xpc = nsContentUtils::XPConnect();
23261:     NS_ENSURE_TRUE(xpc, NS_ERROR_UNEXPECTED);
23261: 
23261:     nsAXPCNativeCallContext* cc;
23261:     nsresult rv = xpc->GetCurrentNativeCallContext(&cc);
23261:     NS_ENSURE_SUCCESS(rv, rv);
23261:     NS_ENSURE_TRUE(cc, NS_ERROR_UNEXPECTED);
23261: 
23261:     jsval* retval;
23261:     rv = cc->GetRetValPtr(&retval);
23261:     NS_ENSURE_SUCCESS(rv, rv);
23261: 
23261:     *retval = JSVAL_VOID;
23261:     return cc->SetReturnValueWasSet(PR_TRUE);
23261:   }
23261: 
23261:   nsCOMPtr<nsIDOMEventListener> listener =
26209:     GetOnXListener(NS_LITERAL_STRING("error"));
23261:   listener.forget(aOnerror);
23261: 
23261:   return NS_OK;
23261: }
23261: 
23261: NS_IMETHODIMP
23261: nsDOMWorkerScope::SetOnerror(nsIDOMEventListener* aOnerror)
23261: {
23261:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
23261: 
23261:   if (mWorker->IsCanceled()) {
23261:     return NS_ERROR_ABORT;
23261:   }
23261: 
23261:   mHasOnerror = PR_TRUE;
23261: 
26209:   return SetOnXListener(NS_LITERAL_STRING("error"), aOnerror);
23261: }
23261: 
23261: NS_IMETHODIMP
22477: nsDOMWorkerScope::PostMessage(/* JSObject aMessage */)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   if (mWorker->IsCanceled()) {
21320:     return NS_ERROR_ABORT;
21320:   }
21320: 
38047:   return mWorker->PostMessageInternal(PR_FALSE);
21320: }
21320: 
21320: NS_IMETHODIMP
26209: nsDOMWorkerScope::Close()
26209: {
26209:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
26209: 
26209:   return mWorker->Close();
26209: }
26209: 
26209: NS_IMETHODIMP
21320: nsDOMWorkerScope::GetOnmessage(nsIDOMEventListener** aOnmessage)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320:   NS_ENSURE_ARG_POINTER(aOnmessage);
21320: 
21320:   if (mWorker->IsCanceled()) {
21320:     return NS_ERROR_ABORT;
21320:   }
21320: 
21320:   nsCOMPtr<nsIDOMEventListener> listener =
26209:     GetOnXListener(NS_LITERAL_STRING("message"));
21320:   listener.forget(aOnmessage);
21320: 
21320:   return NS_OK;
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorkerScope::SetOnmessage(nsIDOMEventListener* aOnmessage)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   if (mWorker->IsCanceled()) {
21320:     return NS_ERROR_ABORT;
21320:   }
21320: 
26209:   return SetOnXListener(NS_LITERAL_STRING("message"), aOnmessage);
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorkerScope::GetOnclose(nsIDOMEventListener** aOnclose)
26209: {
26209:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
26209:   NS_ENSURE_ARG_POINTER(aOnclose);
26209: 
26209:   if (mWorker->IsCanceled()) {
26209:     return NS_ERROR_ABORT;
26209:   }
26209: 
26209:   nsCOMPtr<nsIDOMEventListener> listener =
26209:     GetOnXListener(NS_LITERAL_STRING("close"));
26209:   listener.forget(aOnclose);
26209: 
26209:   return NS_OK;
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorkerScope::SetOnclose(nsIDOMEventListener* aOnclose)
26209: {
26209:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
26209: 
26209:   if (mWorker->IsCanceled()) {
26209:     return NS_ERROR_ABORT;
26209:   }
26209: 
26209:   nsresult rv = SetOnXListener(NS_LITERAL_STRING("close"), aOnclose);
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
26209:   return NS_OK;
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorkerScope::AddEventListener(const nsAString& aType,
21320:                                    nsIDOMEventListener* aListener,
21320:                                    PRBool aUseCapture)
21320: {
37185:   return AddEventListener(aType, aListener, aUseCapture, PR_FALSE, 0);
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorkerScope::RemoveEventListener(const nsAString& aType,
21320:                                       nsIDOMEventListener* aListener,
21320:                                       PRBool aUseCapture)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   if (mWorker->IsCanceled()) {
21320:     return NS_ERROR_ABORT;
21320:   }
21320: 
26209:   return nsDOMWorkerMessageHandler::RemoveEventListener(aType, aListener,
21320:                                                         aUseCapture);
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorkerScope::DispatchEvent(nsIDOMEvent* aEvent,
21320:                                 PRBool* _retval)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   if (mWorker->IsCanceled()) {
21320:     return NS_ERROR_ABORT;
21320:   }
21320: 
26209:   return nsDOMWorkerMessageHandler::DispatchEvent(aEvent, _retval);
21320: }
21320: 
37185: NS_IMETHODIMP
37185: nsDOMWorkerScope::AddEventListener(const nsAString& aType,
37185:                                    nsIDOMEventListener* aListener,
37185:                                    PRBool aUseCapture,
37185:                                    PRBool aWantsUntrusted,
37185:                                    PRUint8 optional_argc)
37185: {
37185:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
37185: 
37185:   if (mWorker->IsCanceled()) {
37185:     return NS_ERROR_ABORT;
37185:   }
37185: 
37185:   return nsDOMWorkerMessageHandler::AddEventListener(aType, aListener,
37185:                                                      aUseCapture,
37185:                                                      aWantsUntrusted,
37185:                                                      optional_argc);
37185: }
37185: 
21320: class nsWorkerHoldingRunnable : public nsIRunnable
21320: {
21320: public:
21320:   NS_DECL_ISUPPORTS
21320: 
21320:   nsWorkerHoldingRunnable(nsDOMWorker* aWorker)
21320:   : mWorker(aWorker), mWorkerWN(aWorker->GetWrappedNative()) { }
21320: 
21320:   NS_IMETHOD Run() {
21320:     return NS_OK;
21320:   }
21320: 
26209:   void ReplaceWrappedNative(nsIXPConnectWrappedNative* aWrappedNative) {
26209:     mWorkerWN = aWrappedNative;
26209:   }
26209: 
21320: protected:
21320:   virtual ~nsWorkerHoldingRunnable() { }
21320: 
21320:   nsRefPtr<nsDOMWorker> mWorker;
21320: 
21320: private:
21320:   nsCOMPtr<nsIXPConnectWrappedNative> mWorkerWN;
21320: };
21320: 
21320: NS_IMPL_THREADSAFE_ISUPPORTS1(nsWorkerHoldingRunnable, nsIRunnable)
21320: 
21320: class nsDOMFireEventRunnable : public nsWorkerHoldingRunnable
21320: {
21320: public:
21320:   NS_DECL_ISUPPORTS_INHERITED
21320: 
21320:   nsDOMFireEventRunnable(nsDOMWorker* aWorker,
21320:                          nsDOMWorkerEvent* aEvent,
21320:                          PRBool aToInner)
21320:   : nsWorkerHoldingRunnable(aWorker), mEvent(aEvent), mToInner(aToInner)
21320:   {
21320:     NS_ASSERTION(aWorker && aEvent, "Null pointer!");
21320:   }
21320: 
21320:   NS_IMETHOD Run() {
21320: #ifdef DEBUG
21320:     if (NS_IsMainThread()) {
21320:       NS_ASSERTION(!mToInner, "Should only run outer events on main thread!");
21320:       NS_ASSERTION(!mWorker->mParent, "Worker shouldn't have a parent!");
21320:     }
21320:     else {
21320:       JSContext* cx = nsDOMThreadService::GetCurrentContext();
21320:       nsDOMWorker* currentWorker = (nsDOMWorker*)JS_GetContextPrivate(cx);
21320:       NS_ASSERTION(currentWorker, "Must have a worker here!");
21320: 
21320:       nsDOMWorker* targetWorker = mToInner ? mWorker.get() : mWorker->mParent;
21320:       NS_ASSERTION(currentWorker == targetWorker, "Wrong worker!");
21320:     }
21320: #endif
21320:     if (mWorker->IsCanceled()) {
21320:       return NS_ERROR_ABORT;
21320:     }
21320: 
39293:     // If the worker is suspended and we're running on the main thread then we
39293:     // can't actually dispatch the event yet. Instead we queue it for whenever
39293:     // we resume.
39293:     if (mWorker->IsSuspended() && NS_IsMainThread()) {
39293:       if (!mWorker->QueueSuspendedRunnable(this)) {
39293:         NS_ERROR("Out of memory?!");
39293:         return NS_ERROR_ABORT;
39293:       }
39293:       return NS_OK;
39293:     }
39293: 
21320:     nsCOMPtr<nsIDOMEventTarget> target = mToInner ?
26209:       static_cast<nsDOMWorkerMessageHandler*>(mWorker->GetInnerScope()) :
26209:       static_cast<nsDOMWorkerMessageHandler*>(mWorker);
21320: 
21320:     NS_ASSERTION(target, "Null target!");
21320:     NS_ENSURE_TRUE(target, NS_ERROR_FAILURE);
21320: 
21320:     mEvent->SetTarget(target);
21320:     return target->DispatchEvent(mEvent, nsnull);
21320:   }
21320: 
21320: protected:
21320:   nsRefPtr<nsDOMWorkerEvent> mEvent;
21320:   PRBool mToInner;
21320: };
21320: 
21320: NS_IMPL_ISUPPORTS_INHERITED0(nsDOMFireEventRunnable, nsWorkerHoldingRunnable)
21320: 
21320: // Standard NS_IMPL_THREADSAFE_ADDREF without the logging stuff (since this
21320: // class is made to be inherited anyway).
21320: NS_IMETHODIMP_(nsrefcnt)
21320: nsDOMWorkerFeature::AddRef()
21320: {
21320:   NS_ASSERTION(mRefCnt >= 0, "Illegal refcnt!");
21320:   return PR_AtomicIncrement((PRInt32*)&mRefCnt);
21320: }
21320: 
21320: // Custom NS_IMPL_THREADSAFE_RELEASE. Checks the mFreeToDie flag before calling
21320: // delete. If the flag is false then the feature still lives in the worker's
21320: // list and must be removed. We rely on the fact that the RemoveFeature method
21320: // calls AddRef and Release after setting the mFreeToDie flag so we won't leak.
21320: NS_IMETHODIMP_(nsrefcnt)
21320: nsDOMWorkerFeature::Release()
21320: {
21320:   NS_ASSERTION(mRefCnt, "Double release!");
21320:   nsrefcnt count = PR_AtomicDecrement((PRInt32*)&mRefCnt);
21320:   if (count == 0) {
21320:     if (mFreeToDie) {
21320:       mRefCnt = 1;
21320:       delete this;
21320:     }
21320:     else {
21320:       mWorker->RemoveFeature(this, nsnull);
21320:     }
21320:   }
21320:   return count;
21320: }
21320: 
21320: NS_IMPL_QUERY_INTERFACE0(nsDOMWorkerFeature)
21320: 
21320: class nsDOMWorkerClassInfo : public nsIClassInfo
21320: {
21320: public:
21320:   NS_DECL_NSICLASSINFO
21320: 
21320:   NS_IMETHOD_(nsrefcnt) AddRef() {
21320:     return 2;
21320:   }
21320: 
21320:   NS_IMETHOD_(nsrefcnt) Release() {
21320:     return 1;
21320:   }
21320: 
21320:   NS_IMETHOD QueryInterface(REFNSIID aIID, void** aInstancePtr);
21320: };
21320: 
21320: NS_IMPL_QUERY_INTERFACE1(nsDOMWorkerClassInfo, nsIClassInfo)
21320: 
21320: // Keep this list in sync with the list in nsDOMClassInfo.cpp!
37185: NS_IMPL_CI_INTERFACE_GETTER4(nsDOMWorkerClassInfo, nsIWorker,
21320:                                                    nsIAbstractWorker,
37185:                                                    nsIDOMNSEventTarget,
21320:                                                    nsIDOMEventTarget)
21320: 
21320: NS_IMPL_THREADSAFE_DOM_CI(nsDOMWorkerClassInfo)
21320: 
21320: static nsDOMWorkerClassInfo sDOMWorkerClassInfo;
21320: 
21320: nsDOMWorker::nsDOMWorker(nsDOMWorker* aParent,
21320:                          nsIXPConnectWrappedNative* aParentWN)
21320: : mParent(aParent),
21320:   mParentWN(aParentWN),
21320:   mLock(nsnull),
21320:   mInnerScope(nsnull),
21320:   mGlobal(NULL),
21320:   mNextTimeoutId(0),
21320:   mFeatureSuspendDepth(0),
21320:   mWrappedNative(nsnull),
24018:   mErrorHandlerRecursionCount(0),
26209:   mStatus(eRunning),
26209:   mExpirationTime(0),
21320:   mSuspended(PR_FALSE),
26209:   mCompileAttempted(PR_FALSE)
21320: {
21320: #ifdef DEBUG
21320:   PRBool mainThread = NS_IsMainThread();
21320:   NS_ASSERTION(aParent ? !mainThread : mainThread, "Wrong thread!");
21320: #endif
21320: }
21320: 
21320: nsDOMWorker::~nsDOMWorker()
21320: {
21320:   if (mPool) {
21320:     mPool->NoteDyingWorker(this);
21320:   }
21320: 
21320:   if (mLock) {
21320:     nsAutoLock::DestroyLock(mLock);
21320:   }
21320: 
21320:   NS_ASSERTION(!mFeatures.Length(), "Live features!");
39293:   NS_ASSERTION(!mQueuedRunnables.Length(), "Events that never ran!");
22039: 
22039:   nsCOMPtr<nsIThread> mainThread;
22039:   NS_GetMainThread(getter_AddRefs(mainThread));
22039: 
22039:   nsIPrincipal* principal;
22039:   mPrincipal.forget(&principal);
22039:   if (principal) {
22039:     NS_ProxyRelease(mainThread, principal, PR_FALSE);
22039:   }
22039: 
22039:   nsIURI* uri;
22039:   mURI.forget(&uri);
22039:   if (uri) {
22039:     NS_ProxyRelease(mainThread, uri, PR_FALSE);
22039:   }
21320: }
21320: 
21320: /* static */ nsresult
21320: nsDOMWorker::NewWorker(nsISupports** aNewObject)
21320: {
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   nsCOMPtr<nsISupports> newWorker =
21320:     NS_ISUPPORTS_CAST(nsIWorker*, new nsDOMWorker(nsnull, nsnull));
21320:   NS_ENSURE_TRUE(newWorker, NS_ERROR_OUT_OF_MEMORY);
21320: 
21320:   newWorker.forget(aNewObject);
21320:   return NS_OK;
21320: }
21320: 
26209: NS_IMPL_ADDREF_INHERITED(nsDOMWorker, nsDOMWorkerMessageHandler)
26209: NS_IMPL_RELEASE_INHERITED(nsDOMWorker, nsDOMWorkerMessageHandler)
21320: 
21320: NS_INTERFACE_MAP_BEGIN(nsDOMWorker)
21320:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWorker)
21320:   NS_INTERFACE_MAP_ENTRY(nsIWorker)
21320:   NS_INTERFACE_MAP_ENTRY(nsIAbstractWorker)
37185:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMNSEventTarget,
37185:                                    nsDOMWorkerMessageHandler)
26209:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventTarget, nsDOMWorkerMessageHandler)
21320:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
21320:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
26209:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
21320:   if (aIID.Equals(NS_GET_IID(nsIClassInfo))) {
21320:     foundInterface = static_cast<nsIClassInfo*>(&sDOMWorkerClassInfo);
21320:   } else
21320: NS_INTERFACE_MAP_END
21320: 
21320: // Use the xpc_map_end.h macros to generate the nsIXPCScriptable methods we want
21320: // for the worker.
21320: 
21320: #define XPC_MAP_CLASSNAME nsDOMWorker
21320: #define XPC_MAP_QUOTED_CLASSNAME "Worker"
21320: #define XPC_MAP_WANT_POSTCREATE
21320: #define XPC_MAP_WANT_TRACE
21320: #define XPC_MAP_WANT_FINALIZE
21320: 
21320: #define XPC_MAP_FLAGS                                      \
22036:   nsIXPCScriptable::USE_JSSTUB_FOR_ADDPROPERTY           | \
22036:   nsIXPCScriptable::USE_JSSTUB_FOR_DELPROPERTY           | \
22036:   nsIXPCScriptable::USE_JSSTUB_FOR_SETPROPERTY           | \
21320:   nsIXPCScriptable::DONT_ENUM_QUERY_INTERFACE            | \
21320:   nsIXPCScriptable::CLASSINFO_INTERFACES_ONLY            | \
21320:   nsIXPCScriptable::DONT_REFLECT_INTERFACE_NAMES
21320: 
21320: #include "xpc_map_end.h"
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorker::PostCreate(nsIXPConnectWrappedNative* aWrapper,
21320:                         JSContext* /* aCx */,
21320:                         JSObject* /* aObj */)
21320: {
26209:   nsAutoLock lock(mLock);
21320:   mWrappedNative = aWrapper;
21320:   return NS_OK;
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorker::Trace(nsIXPConnectWrappedNative* /* aWrapper */,
21320:                    JSTracer* aTracer,
21320:                    JSObject* /*aObj */)
21320: {
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
21320: 
26209:   PRBool canceled = PR_FALSE;
26209:   {
26209:     nsAutoLock lock(mLock);
26209:     canceled = mStatus == eKilled;
21320:   }
21320: 
26209:   if (!canceled) {
26209:     nsDOMWorkerMessageHandler::Trace(aTracer);
21320:   }
21320: 
21320:   return NS_OK;
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorker::Finalize(nsIXPConnectWrappedNative* /* aWrapper */,
21320:                       JSContext* aCx,
21320:                       JSObject* /* aObj */)
21320: {
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   // Don't leave dangling JSObject pointers in our handlers!
26209:   ClearAllListeners();
21320: 
21320:   // Clear our wrapped native now that it has died.
26209:   {
26209:     nsAutoLock lock(mLock);
21320:     mWrappedNative = nsnull;
26209:   }
21320: 
26209:   // Do this *after* we null out mWrappedNative so that we don't hand out a
26209:   // freed pointer.
39837:   if (TerminateInternal(PR_TRUE) == NS_ERROR_ILLEGAL_DURING_SHUTDOWN) {
39837:     // We're shutting down, jump right to Kill.
39837:     Kill();
39837:   }
21320: 
21320:   return NS_OK;
21320: }
21320: 
21320: NS_IMETHODIMP
21320: nsDOMWorker::Initialize(nsISupports* aOwner,
21320:                         JSContext* aCx,
21320:                         JSObject* aObj,
21320:                         PRUint32 aArgc,
21320:                         jsval* aArgv)
21320: {
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
21320:   NS_ENSURE_ARG_POINTER(aOwner);
21320: 
21320:   nsCOMPtr<nsIScriptGlobalObject> globalObj(do_QueryInterface(aOwner));
21320:   NS_ENSURE_TRUE(globalObj, NS_NOINTERFACE);
21320: 
21320:   return InitializeInternal(globalObj, aCx, aObj, aArgc, aArgv);
21320: }
21320: 
21320: nsresult
21320: nsDOMWorker::InitializeInternal(nsIScriptGlobalObject* aOwner,
21320:                                 JSContext* aCx,
21320:                                 JSObject* aObj,
21320:                                 PRUint32 aArgc,
21320:                                 jsval* aArgv)
21320: {
22042:   NS_ENSURE_TRUE(aArgc, NS_ERROR_XPC_NOT_ENOUGH_ARGS);
21320:   NS_ENSURE_ARG_POINTER(aArgv);
21320: 
21320:   JSString* str = JS_ValueToString(aCx, aArgv[0]);
22042:   NS_ENSURE_TRUE(str, NS_ERROR_XPC_BAD_CONVERT_JS);
21320: 
21320:   mScriptURL.Assign(nsDependentJSString(str));
21320:   NS_ENSURE_FALSE(mScriptURL.IsEmpty(), NS_ERROR_INVALID_ARG);
21320: 
21320:   mLock = nsAutoLock::NewLock("nsDOMWorker::mLock");
21320:   NS_ENSURE_TRUE(mLock, NS_ERROR_OUT_OF_MEMORY);
21320: 
21320:   NS_ASSERTION(!mGlobal, "Already got a global?!");
21320: 
21320:   nsCOMPtr<nsIXPConnectJSObjectHolder> thisWrapped;
31981:   jsval v;
31981:   nsresult rv = nsContentUtils::WrapNative(aCx, aObj,
31981:                                            static_cast<nsIWorker*>(this), &v,
21320:                                            getter_AddRefs(thisWrapped));
21320:   NS_ENSURE_SUCCESS(rv, rv);
21320: 
21320:   NS_ASSERTION(mWrappedNative, "Post-create hook should have set this!");
21320: 
26209:   mKillTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
26209:   nsCOMPtr<nsIThread> mainThread;
26209:   rv = NS_GetMainThread(getter_AddRefs(mainThread));
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
26209:   rv = mKillTimer->SetTarget(mainThread);
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
21320:   // This is pretty cool - all we have to do to get our script executed is to
21320:   // pass a no-op runnable to the thread service and it will make sure we have
21320:   // a context and global object.
21320:   nsCOMPtr<nsIRunnable> runnable(new nsWorkerHoldingRunnable(this));
21320:   NS_ENSURE_TRUE(runnable, NS_ERROR_OUT_OF_MEMORY);
21320: 
21320:   nsRefPtr<nsDOMThreadService> threadService =
21320:     nsDOMThreadService::GetOrInitService();
21320:   NS_ENSURE_STATE(threadService);
21320: 
21320:   rv = threadService->RegisterWorker(this, aOwner);
21320:   NS_ENSURE_SUCCESS(rv, rv);
21320: 
21320:   NS_ASSERTION(mPool, "RegisterWorker should have set our pool!");
21320: 
21320:   rv = threadService->Dispatch(this, runnable);
21320:   NS_ENSURE_SUCCESS(rv, rv);
21320: 
21320:   return NS_OK;
21320: }
21320: 
21320: void
21320: nsDOMWorker::Cancel()
21320: {
26209:   // Called by the pool when the window that created us is being torn down. Must
26209:   // always be on the main thread.
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
21320: 
26209:   // We set the eCanceled status to indicate this. It behaves just like the
26209:   // eTerminated status (canceled while close runnable is unscheduled, not
26209:   // canceled while close runnable is running) except that it always reports
26209:   // that it is canceled when running on the main thread. This status trumps all
26209:   // others (except eKilled). Have to do this because the window that created
26209:   // us has gone away and had its scope cleared so XPConnect will assert all
26209:   // over the place if we try to run anything.
26209: 
26209:   PRBool enforceTimeout = PR_FALSE;
26209:   {
26209:     nsAutoLock lock(mLock);
26209: 
26209:     NS_ASSERTION(mStatus != eCanceled, "Canceled more than once?!");
26209: 
26209:     if (mStatus == eKilled) {
26209:       return;
26209:     }
26209: 
26209:     DOMWorkerStatus oldStatus = mStatus;
26209:     mStatus = eCanceled;
26209:     if (oldStatus != eRunning) {
26209:       enforceTimeout = PR_TRUE;
26209:     }
26209:   }
26209: 
26209:   PRUint32 timeoutMS = nsDOMThreadService::GetWorkerCloseHandlerTimeoutMS();
26209:   NS_ASSERTION(timeoutMS, "This must not be 0!");
26209: 
26209: #ifdef DEBUG
26209:   nsresult rv;
26209: #endif
26209:   if (enforceTimeout) {
26209:     // Tell the thread service to enforce a timeout on the close handler that
26209:     // is already scheduled.
26209:     nsDOMThreadService::get()->
26209:       SetWorkerTimeout(this, PR_MillisecondsToInterval(timeoutMS));
26209: 
26209: #ifdef DEBUG
26209:     rv =
26209: #endif
26209:     mKillTimer->InitWithCallback(this, timeoutMS, nsITimer::TYPE_ONE_SHOT);
26209:     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Failed to init kill timer!");
26209: 
26209:     return;
26209:   }
26209: 
26209: #ifdef DEBUG
26209:   rv =
26209: #endif
26209:   FireCloseRunnable(PR_MillisecondsToInterval(timeoutMS), PR_TRUE, PR_FALSE);
26209:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Failed to fire close runnable!");
26209: }
26209: 
26209: void
26209: nsDOMWorker::Kill()
26209: {
26209:   // Cancel all features and set our status to eKilled. This should only be
26209:   // called on the main thread by the thread service or our kill timer to
26209:   // indicate that the worker's close handler has run (or timed out).
26209:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
26209:   NS_ASSERTION(IsClosing(), "Close handler should have run by now!");
26209: 
26209:   // If the close handler finished before our kill timer then we don't need it
26209:   // any longer.
26209:   if (mKillTimer) {
26209:     mKillTimer->Cancel();
26209:     mKillTimer = nsnull;
26209:   }
26209: 
26209:   PRUint32 count, index;
26209:   nsAutoTArray<nsRefPtr<nsDOMWorkerFeature>, 20> features;
26209:   {
26209:     nsAutoLock lock(mLock);
26209: 
26209:     if (mStatus == eKilled) {
26209:       NS_ASSERTION(mFeatures.Length() == 0, "Features added after killed!");
26209:       return;
26209:     }
26209:     mStatus = eKilled;
26209: 
26209:     count = mFeatures.Length();
26209:     for (index = 0; index < count; index++) {
26209:       nsDOMWorkerFeature*& feature = mFeatures[index];
26209: 
26209: #ifdef DEBUG
26209:       nsRefPtr<nsDOMWorkerFeature>* newFeature =
26209: #endif
26209:       features.AppendElement(feature);
26209:       NS_ASSERTION(newFeature, "Out of memory!");
26209: 
26209:       feature->FreeToDie(PR_TRUE);
26209:     }
26209: 
26209:     mFeatures.Clear();
26209:   }
26209: 
26209:   count = features.Length();
26209:   for (index = 0; index < count; index++) {
26209:     features[index]->Cancel();
26209:   }
26209: 
39293:   // Make sure we kill any queued runnables that we never had a chance to run.
39293:   mQueuedRunnables.Clear();
39293: 
26209:   // We no longer need to keep our inner scope.
26209:   mInnerScope = nsnull;
26209:   mScopeWN = nsnull;
26209:   mGlobal = NULL;
26209: 
26209:   // And we can let our parent die now too.
26209:   mParent = nsnull;
26209:   mParentWN = nsnull;
21320: }
21320: 
21320: void
21320: nsDOMWorker::Suspend()
21320: {
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
26209: 
26209:   PRBool shouldSuspendFeatures;
26209:   {
26209:     nsAutoLock lock(mLock);
26172:     NS_ASSERTION(!mSuspended, "Suspended more than once!");
26209:     shouldSuspendFeatures = !mSuspended;
26172:     mSuspended = PR_TRUE;
26209:   }
26166: 
26209:   if (shouldSuspendFeatures) {
21320:     SuspendFeatures();
21320:   }
26209: }
21320: 
21320: void
21320: nsDOMWorker::Resume()
21320: {
21320:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
26209: 
26209:   PRBool shouldResumeFeatures;
26209:   {
26209:     nsAutoLock lock(mLock);
26209: #ifdef DEBUG
26209:     // Should only have a mismatch if GC or Cancel happened while suspended.
26209:     if (!mSuspended) {
26209:       NS_ASSERTION(mStatus == eCanceled ||
26209:                    (mStatus == eTerminated && !mWrappedNative),
26209:                    "Not suspended!");
26209:     }
26209: #endif
26209:     shouldResumeFeatures = mSuspended;
26172:     mSuspended = PR_FALSE;
26209:   }
26166: 
26209:   if (shouldResumeFeatures) {
21320:     ResumeFeatures();
21320:   }
39293: 
39293:   // Repost any events that were queued for the main thread while suspended.
39293:   PRUint32 count = mQueuedRunnables.Length();
39293:   for (PRUint32 index = 0; index < count; index++) {
39293:     NS_DispatchToCurrentThread(mQueuedRunnables[index]);
39293:   }
39293:   mQueuedRunnables.Clear();
26209: }
26209: 
26209: PRBool
26209: nsDOMWorker::IsCanceled()
26209: {
26209:   nsAutoLock lock(mLock);
39471:   return IsCanceledNoLock();
39471: }
39471: 
39471: PRBool
39471: nsDOMWorker::IsCanceledNoLock()
39471: {
39471:   // If we haven't started the close process then we're not canceled.
39471:   if (mStatus == eRunning) {
39471:     return PR_FALSE;
39471:   }
26209: 
26209:   // There are several conditions under which we want JS code to abort and all
26209:   // other functions to bail:
26209:   // 1. If we've already run our close handler then we are canceled forevermore.
26209:   // 2. If we've been terminated then we want to pretend to be canceled until
26209:   //    our close handler is scheduled and running.
26209:   // 3. If we've been canceled then we pretend to be canceled until the close
26209:   //    handler has been scheduled.
26209:   // 4. If the close handler has run for longer than the allotted time then we
26209:   //    should be canceled as well.
26209:   // 5. If we're on the main thread then we'll pretend to be canceled if the
26209:   //    user has navigated away from the page.
26209:   return mStatus == eKilled ||
26209:          (mStatus == eTerminated && !mExpirationTime) ||
26209:          (mStatus == eCanceled && !mExpirationTime) ||
26209:          (mExpirationTime && mExpirationTime != PR_INTERVAL_NO_TIMEOUT &&
26209:           mExpirationTime <= PR_IntervalNow()) ||
26209:          (mStatus == eCanceled && NS_IsMainThread());
26209: }
26209: 
26209: PRBool
26209: nsDOMWorker::IsClosing()
26209: {
26209:   nsAutoLock lock(mLock);
26209:   return mStatus != eRunning;
26209: }
26209: 
26209: PRBool
26209: nsDOMWorker::IsSuspended()
26209: {
26209:   nsAutoLock lock(mLock);
26209:   return mSuspended;
26209: }
21320: 
21320: nsresult
38047: nsDOMWorker::PostMessageInternal(PRBool aToInner)
21320: {
38047:   nsIXPConnect* xpc = nsContentUtils::XPConnect();
38047:   NS_ENSURE_TRUE(xpc, NS_ERROR_UNEXPECTED);
38047: 
38047:   nsAXPCNativeCallContext* cc;
38047:   nsresult rv = xpc->GetCurrentNativeCallContext(&cc);
38047:   NS_ENSURE_SUCCESS(rv, rv);
38047:   NS_ENSURE_TRUE(cc, NS_ERROR_UNEXPECTED);
38047: 
38047:   PRUint32 argc;
38047:   rv = cc->GetArgc(&argc);
38047:   NS_ENSURE_SUCCESS(rv, rv);
38047: 
38047:   if (!argc) {
38047:     return NS_ERROR_XPC_NOT_ENOUGH_ARGS;
38047:   }
38047: 
38047:   jsval* argv;
38047:   rv = cc->GetArgvPtr(&argv);
38047:   NS_ENSURE_SUCCESS(rv, rv);
38047: 
38047:   JSContext* cx;
38047:   rv = cc->GetJSContext(&cx);
38047:   NS_ENSURE_SUCCESS(rv, rv);
38047: 
38047:   JSAutoRequest ar(cx);
38047: 
38047:   nsAutoJSValHolder val;
38047:   if (!val.Hold(cx)) {
38047:     return NS_ERROR_FAILURE;
38047:   }
38047: 
39542:   rv = nsContentUtils::CreateStructuredClone(cx, argv[0], val.ToJSValPtr());
39542:   if (NS_FAILED(rv)) {
39542:     return rv;
39542:   }
38047: 
21320:   nsRefPtr<nsDOMWorkerMessageEvent> message = new nsDOMWorkerMessageEvent();
21320:   NS_ENSURE_TRUE(message, NS_ERROR_OUT_OF_MEMORY);
21320: 
38047:   rv = message->InitMessageEvent(NS_LITERAL_STRING("message"), PR_FALSE,
38047:                                  PR_FALSE, EmptyString(), EmptyString(),
38047:                                  nsnull);
21320:   NS_ENSURE_SUCCESS(rv, rv);
21320: 
39542:   rv = message->SetJSVal(cx, val);
38047:   NS_ENSURE_SUCCESS(rv, rv);
22477: 
21320:   nsRefPtr<nsDOMFireEventRunnable> runnable =
21320:     new nsDOMFireEventRunnable(this, message, aToInner);
21320:   NS_ENSURE_TRUE(runnable, NS_ERROR_OUT_OF_MEMORY);
21320: 
21320:   // If aToInner is true then we want to target the runnable at this worker's
21320:   // thread. Otherwise we need to target the parent's thread.
21320:   nsDOMWorker* target = aToInner ? this : mParent;
21320: 
21320:   // If this is a top-level worker then target the main thread. Otherwise use
21320:   // the thread service to find the target's thread.
21320:   if (!target) {
21320:     nsCOMPtr<nsIThread> mainThread;
21320:     rv = NS_GetMainThread(getter_AddRefs(mainThread));
21320:     NS_ENSURE_SUCCESS(rv, rv);
21320: 
21320:     rv = mainThread->Dispatch(runnable, NS_DISPATCH_NORMAL);
21320:     NS_ENSURE_SUCCESS(rv, rv);
21320:   }
21320:   else {
21320:     rv = nsDOMThreadService::get()->Dispatch(target, runnable);
21320:     NS_ENSURE_SUCCESS(rv, rv);
21320:   }
21320: 
21320:   return NS_OK;
21320: }
21320: 
21320: PRBool
21320: nsDOMWorker::SetGlobalForContext(JSContext* aCx)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   if (!CompileGlobalObject(aCx)) {
21320:     return PR_FALSE;
21320:   }
21320: 
35586:   JSAutoRequest ar(aCx);
35586: 
21320:   JS_SetGlobalObject(aCx, mGlobal);
21320:   return PR_TRUE;
21320: }
21320: 
21320: PRBool
21320: nsDOMWorker::CompileGlobalObject(JSContext* aCx)
21320: {
21320:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
21320: 
21320:   if (mGlobal) {
21320:     return PR_TRUE;
21320:   }
21320: 
21320:   if (mCompileAttempted) {
21320:     // Don't try to recompile a bad script.
21320:     return PR_FALSE;
21320:   }
21320:   mCompileAttempted = PR_TRUE;
21320: 
21320:   NS_ASSERTION(!mScriptURL.IsEmpty(), "Must have a url here!");
21320: 
21320:   JSAutoRequest ar(aCx);
21320: 
21320:   NS_ASSERTION(!JS_GetGlobalObject(aCx), "Global object should be unset!");
21320: 
21320:   nsRefPtr<nsDOMWorkerScope> scope = new nsDOMWorkerScope(this);
21758:   NS_ENSURE_TRUE(scope, PR_FALSE);
21320: 
21320:   nsISupports* scopeSupports = NS_ISUPPORTS_CAST(nsIWorkerScope*, scope);
21320: 
21320:   nsIXPConnect* xpc = nsContentUtils::XPConnect();
21320: 
22479:   const PRUint32 flags = nsIXPConnect::INIT_JS_STANDARD_CLASSES |
22479:                          nsIXPConnect::OMIT_COMPONENTS_OBJECT;
22479: 
21320:   nsCOMPtr<nsIXPConnectJSObjectHolder> globalWrapper;
21320:   nsresult rv =
21320:     xpc->InitClassesWithNewWrappedGlobal(aCx, scopeSupports,
22479:                                          NS_GET_IID(nsISupports), flags,
21320:                                          getter_AddRefs(globalWrapper));
21320:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
21320: 
21320:   JSObject* global;
21320:   rv = globalWrapper->GetJSObject(&global);
21320:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
21320: 
21320:   NS_ASSERTION(JS_GetGlobalObject(aCx) == global, "Global object mismatch!");
21320: 
22479: #ifdef DEBUG
22479:   {
22479:     jsval components;
22479:     if (JS_GetProperty(aCx, global, "Components", &components)) {
22479:       NS_ASSERTION(components == JSVAL_VOID,
22479:                    "Components property still defined!");
22479:     }
22479:   }
22479: #endif
21320: 
21320:   // Set up worker thread functions
22479:   PRBool success = JS_DefineFunctions(aCx, global, gDOMWorkerFunctions);
21320:   NS_ENSURE_TRUE(success, PR_FALSE);
21320: 
26209:   // From here on out we have to remember to null mGlobal, mInnerScope, and
26209:   // mScopeWN if something fails! We really don't need to hang on to mGlobal
26209:   // as long as we have mScopeWN, but it saves us a virtual call every time the
26209:   // worker is scheduled. Meh.
21320:   mGlobal = global;
21320:   mInnerScope = scope;
26209:   mScopeWN = scope->GetWrappedNative();
26209:   NS_ASSERTION(mScopeWN, "Should have a wrapped native here!");
21320: 
21320:   nsRefPtr<nsDOMWorkerScriptLoader> loader =
21320:     new nsDOMWorkerScriptLoader(this);
21320:   NS_ASSERTION(loader, "Out of memory!");
21320:   if (!loader) {
21320:     mGlobal = NULL;
21320:     mInnerScope = nsnull;
26209:     mScopeWN = nsnull;
21320:     return PR_FALSE;
21320:   }
21320: 
21320:   rv = AddFeature(loader, aCx);
21320:   if (NS_FAILED(rv)) {
21320:     mGlobal = NULL;
21320:     mInnerScope = nsnull;
26209:     mScopeWN = nsnull;
21320:     return PR_FALSE;
21320:   }
21320: 
22039:   rv = loader->LoadScript(aCx, mScriptURL, PR_TRUE);
21320: 
21320:   JS_ReportPendingException(aCx);
21320: 
21320:   if (NS_FAILED(rv)) {
21320:     mGlobal = NULL;
21320:     mInnerScope = nsnull;
26209:     mScopeWN = nsnull;
21320:     return PR_FALSE;
21320:   }
21320: 
22039:   NS_ASSERTION(mPrincipal && mURI, "Script loader didn't set our principal!");
22039: 
21320:   return PR_TRUE;
21320: }
21320: 
21320: void
21320: nsDOMWorker::SetPool(nsDOMWorkerPool* aPool)
21320: {
21320:   NS_ASSERTION(!mPool, "Shouldn't ever set pool more than once!");
21320:   mPool = aPool;
21320: }
21320: 
21320: already_AddRefed<nsIXPConnectWrappedNative>
21320: nsDOMWorker::GetWrappedNative()
21320: {
26209:   nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
26209:   {
26209:     nsAutoLock lock(mLock);
26209:     wrappedNative = mWrappedNative;
26209:   }
21320:   return wrappedNative.forget();
21320: }
21320: 
21320: nsresult
21320: nsDOMWorker::AddFeature(nsDOMWorkerFeature* aFeature,
21320:                         JSContext* aCx)
21320: {
21320:   NS_ASSERTION(aFeature, "Null pointer!");
21320: 
21320:   PRBool shouldSuspend;
21320:   {
21320:     // aCx may be null.
21320:     JSAutoSuspendRequest asr(aCx);
21320: 
21320:     nsAutoLock lock(mLock);
21320: 
26209:     if (mStatus == eKilled) {
26209:       // No features may be added after we've been canceled. Sorry.
26209:       return NS_ERROR_FAILURE;
26209:     }
26209: 
21320:     nsDOMWorkerFeature** newFeature = mFeatures.AppendElement(aFeature);
21320:     NS_ENSURE_TRUE(newFeature, NS_ERROR_OUT_OF_MEMORY);
21320: 
21320:     aFeature->FreeToDie(PR_FALSE);
21320:     shouldSuspend = mFeatureSuspendDepth > 0;
21320:   }
21320: 
21320:   if (shouldSuspend) {
21320:     aFeature->Suspend();
21320:   }
21320: 
21320:   return NS_OK;
21320: }
21320: 
21320: void
21320: nsDOMWorker::RemoveFeature(nsDOMWorkerFeature* aFeature,
21320:                            JSContext* aCx)
21320: {
21320:   NS_ASSERTION(aFeature, "Null pointer!");
21320: 
21320:   // This *must* be a nsRefPtr so that we call Release after setting FreeToDie.
21320:   nsRefPtr<nsDOMWorkerFeature> feature(aFeature);
21320:   {
21320:     // aCx may be null.
21320:     JSAutoSuspendRequest asr(aCx);
21320: 
21320:     nsAutoLock lock(mLock);
21320: 
21320: #ifdef DEBUG
21320:     PRBool removed =
21320: #endif
21320:     mFeatures.RemoveElement(aFeature);
21320:     NS_ASSERTION(removed, "Feature not in the list!");
21320: 
21320:     aFeature->FreeToDie(PR_TRUE);
21320:   }
21320: }
21320: 
21320: void
21320: nsDOMWorker::CancelTimeoutWithId(PRUint32 aId)
21320: {
21320:   nsRefPtr<nsDOMWorkerFeature> foundFeature;
21320:   {
21320:     nsAutoLock lock(mLock);
21320:     PRUint32 count = mFeatures.Length();
21320:     for (PRUint32 index = 0; index < count; index++) {
21320:       nsDOMWorkerFeature*& feature = mFeatures[index];
21320:       if (feature->HasId() && feature->GetId() == aId) {
21320:         foundFeature = feature;
21320:         feature->FreeToDie(PR_TRUE);
21320:         mFeatures.RemoveElementAt(index);
21320:         break;
21320:       }
21320:     }
21320:   }
21320: 
21320:   if (foundFeature) {
21320:     foundFeature->Cancel();
21320:   }
21320: }
21320: 
21320: void
21320: nsDOMWorker::SuspendFeatures()
21320: {
21320:   nsAutoTArray<nsRefPtr<nsDOMWorkerFeature>, 20> features;
21320:   {
21320:     nsAutoLock lock(mLock);
21320: 
21320:     // We don't really have to worry about overflow here because the only way
21320:     // to do this is through recursive script loading, which uses the stack. We
21320:     // would exceed our stack limit long before this counter.
21320:     NS_ASSERTION(mFeatureSuspendDepth < PR_UINT32_MAX, "Shouldn't happen!");
21320:     if (++mFeatureSuspendDepth != 1) {
21320:       // Allow nested suspending of timeouts.
21320:       return;
21320:     }
21320: 
21320: #ifdef DEBUG
21320:     nsRefPtr<nsDOMWorkerFeature>* newFeatures =
21320: #endif
21320:     features.AppendElements(mFeatures);
21320:     NS_WARN_IF_FALSE(newFeatures, "Out of memory!");
21320:   }
21320: 
21320:   PRUint32 count = features.Length();
21320:   for (PRUint32 i = 0; i < count; i++) {
21320:     features[i]->Suspend();
21320:   }
21320: }
21320: 
21320: void
21320: nsDOMWorker::ResumeFeatures()
21320: {
21320:   nsAutoTArray<nsRefPtr<nsDOMWorkerFeature>, 20> features;
21320:   {
21320:     nsAutoLock lock(mLock);
21320: 
21320:     NS_ASSERTION(mFeatureSuspendDepth > 0, "Shouldn't happen!");
21320:     if (--mFeatureSuspendDepth != 0) {
21320:       return;
21320:     }
21320: 
21320:     features.AppendElements(mFeatures);
21320:   }
21320: 
21320:   PRUint32 count = features.Length();
21320:   for (PRUint32 i = 0; i < count; i++) {
21320:     features[i]->Resume();
21320:   }
21320: }
21320: 
26209: nsresult
31409: nsDOMWorker::SetURI(nsIURI* aURI)
31409: {
31409:   NS_ASSERTION(aURI, "Don't hand me a null pointer!");
31409:   NS_ASSERTION(!mURI && !mLocation, "Called more than once?!");
31409:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
31409: 
31409:   mURI = aURI;
31409: 
31409:   nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
31409:   NS_ENSURE_TRUE(url, NS_ERROR_NO_INTERFACE);
31409: 
31409:   mLocation = nsDOMWorkerLocation::NewLocation(url);
31409:   NS_ENSURE_TRUE(mLocation, NS_ERROR_FAILURE);
31409: 
31409:   return NS_OK;
31409: }
31409: 
31409: nsresult
26209: nsDOMWorker::FireCloseRunnable(PRIntervalTime aTimeoutInterval,
26209:                                PRBool aClearQueue,
26209:                                PRBool aFromFinalize)
21320: {
26209:   // Resume the worker (but not its features) if we're currently suspended. This
26209:   // should only ever happen if we are being called from Cancel (page falling
26209:   // out of bfcache or quitting) or Finalize, in which case all we really want
26209:   // to do is unblock the waiting thread.
26209:   PRBool wakeUp;
21320:   {
21320:     nsAutoLock lock(mLock);
26209:     NS_ASSERTION(mExpirationTime == 0,
26209:                  "Close runnable should not be scheduled already!");
21320: 
26209:     if ((wakeUp = mSuspended)) {
26209:       NS_ASSERTION(mStatus == eCanceled ||
26209:                    (mStatus == eTerminated && aFromFinalize),
26209:                    "How can this happen otherwise?!");
26209:       mSuspended = PR_FALSE;
26209:     }
21320:   }
21320: 
26209:   if (wakeUp) {
26209:     nsAutoMonitor mon(mPool->Monitor());
26209:     mon.NotifyAll();
21320:   }
21320: 
26209:   nsRefPtr<nsDOMWorkerEvent> event = new nsDOMWorkerEvent();
26209:   NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
26209: 
26209:   nsresult rv =
26209:     event->InitEvent(NS_LITERAL_STRING("close"), PR_FALSE, PR_FALSE);
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
26209:   nsRefPtr<nsDOMFireEventRunnable> runnable =
26209:     new nsDOMFireEventRunnable(this, event, PR_TRUE);
26209:   NS_ENSURE_TRUE(runnable, NS_ERROR_OUT_OF_MEMORY);
26209: 
26209:   // Our worker has been collected and we want to keep the inner scope alive,
26209:   // so pass that along in the runnable.
26209:   if (aFromFinalize) {
26209:     NS_ASSERTION(mScopeWN, "This shouldn't be null!");
26209:     runnable->ReplaceWrappedNative(mScopeWN);
21320:   }
26209: 
39837:   return nsDOMThreadService::get()->Dispatch(this, runnable, aTimeoutInterval,
26209:                                              aClearQueue);
26209: }
26209: 
26209: nsresult
26209: nsDOMWorker::Close()
26209: {
26209:   {
26209:     nsAutoLock lock(mLock);
26209:     NS_ASSERTION(mStatus != eKilled, "This should be impossible!");
26209:     if (mStatus != eRunning) {
26209:       return NS_OK;
26209:     }
26209:     mStatus = eClosed;
26209:   }
26209: 
26209:   nsresult rv = FireCloseRunnable(PR_INTERVAL_NO_TIMEOUT, PR_FALSE, PR_FALSE);
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
26209:   return NS_OK;
26209: }
26209: 
26209: nsresult
26209: nsDOMWorker::TerminateInternal(PRBool aFromFinalize)
26209: {
26209:   {
26209:     nsAutoLock lock(mLock);
26209: #ifdef DEBUG
26209:     if (!aFromFinalize) {
26209:       NS_ASSERTION(mStatus != eCanceled, "Shouldn't be able to get here!");
26209:     }
26209: #endif
26209: 
26209:     if (mStatus == eRunning) {
26209:       // This is the beginning of the close process, fire an event and prevent
26209:       // any other close events from being generated.
26209:       mStatus = eTerminated;
26209:     }
26209:     else {
26209:       if (mStatus == eClosed) {
26209:         // The worker was previously closed which means that an expiration time
26209:         // might not be set. Setting the status to eTerminated will force the
26209:         // worker to jump to its close handler.
26209:         mStatus = eTerminated;
26209:       }
26209:       // No need to fire another close handler, it has already been done.
26209:       return NS_OK;
26209:     }
26209:   }
26209: 
26209:   nsresult rv = FireCloseRunnable(PR_INTERVAL_NO_TIMEOUT, PR_TRUE,
26209:                                   aFromFinalize);
39837:   if (rv == NS_ERROR_ILLEGAL_DURING_SHUTDOWN) {
39837:     return rv;
39837:   }
39837: 
39837:   // Warn about other kinds of failures.
26209:   NS_ENSURE_SUCCESS(rv, rv);
26209: 
26209:   return NS_OK;
21320: }
21320: 
21320: already_AddRefed<nsDOMWorker>
21320: nsDOMWorker::GetParent()
21320: {
21320:   nsRefPtr<nsDOMWorker> parent(mParent);
21320:   return parent.forget();
21320: }
21320: 
26209: void
26209: nsDOMWorker::SetExpirationTime(PRIntervalTime aExpirationTime)
26209: {
26209:   {
26209:     nsAutoLock lock(mLock);
26209: 
26209:     NS_ASSERTION(mStatus != eRunning && mStatus != eKilled, "Bad status!");
26209:     NS_ASSERTION(!mExpirationTime || mExpirationTime == PR_INTERVAL_NO_TIMEOUT,
26209:                  "Overwriting a timeout that was previously set!");
26209: 
26209:     mExpirationTime = aExpirationTime;
26209:   }
26209: }
26209: 
26209: #ifdef DEBUG
26209: PRIntervalTime
26209: nsDOMWorker::GetExpirationTime()
26209: {
26209:   nsAutoLock lock(mLock);
26209:   return mExpirationTime;
26209: }
26209: #endif
26209: 
39293: PRBool
39293: nsDOMWorker::QueueSuspendedRunnable(nsIRunnable* aRunnable)
39293: {
39293:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
39293:   return mQueuedRunnables.AppendElement(aRunnable) ? PR_TRUE : PR_FALSE;
39293: }
39293: 
26209: NS_IMETHODIMP
26209: nsDOMWorker::AddEventListener(const nsAString& aType,
26209:                               nsIDOMEventListener* aListener,
26209:                               PRBool aUseCapture)
26209: {
37185:   return AddEventListener(aType, aListener, aUseCapture, PR_FALSE, 0);
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorker::RemoveEventListener(const nsAString& aType,
26209:                                  nsIDOMEventListener* aListener,
26209:                                  PRBool aUseCapture)
26209: {
26209:   if (IsCanceled()) {
26209:     return NS_OK;
26209:   }
26209: 
26209:   return nsDOMWorkerMessageHandler::RemoveEventListener(aType, aListener,
26209:                                                         aUseCapture);
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorker::DispatchEvent(nsIDOMEvent* aEvent,
26209:                            PRBool* _retval)
26209: {
39471:   {
39471:     nsAutoLock lock(mLock);
39471:     if (IsCanceledNoLock()) {
26209:       return NS_OK;
26209:     }
39471:     if (mStatus == eTerminated) {
39471:       nsCOMPtr<nsIWorkerMessageEvent> messageEvent(do_QueryInterface(aEvent));
39471:       if (messageEvent) {
39471:         // This is a message event targeted to a terminated worker. Ignore it.
39471:         return NS_OK;
39471:       }
39471:     }
39471:   }
26209: 
26209:   return nsDOMWorkerMessageHandler::DispatchEvent(aEvent, _retval);
26209: }
26209: 
37185: NS_IMETHODIMP
37185: nsDOMWorker::AddEventListener(const nsAString& aType,
37185:                               nsIDOMEventListener* aListener,
37185:                               PRBool aUseCapture,
37185:                               PRBool aWantsUntrusted,
37185:                               PRUint8 optional_argc)
37185: {
37185:   NS_ASSERTION(mWrappedNative, "Called after Finalize!");
37185:   if (IsCanceled()) {
37185:     return NS_OK;
37185:   }
37185: 
37185:   return nsDOMWorkerMessageHandler::AddEventListener(aType, aListener,
37185:                                                      aUseCapture,
37185:                                                      aWantsUntrusted,
37185:                                                      optional_argc);
37185: }
37185: 
21320: /**
21320:  * See nsIWorker
21320:  */
21320: NS_IMETHODIMP
22477: nsDOMWorker::PostMessage(/* JSObject aMessage */)
21320: {
26209:   {
26209:     nsAutoLock lock(mLock);
26209:     // There's no reason to dispatch this message after the close handler has
26209:     // been triggered since it will never be allowed to run.
26209:     if (mStatus != eRunning) {
22038:       return NS_OK;
22038:     }
26209:   }
22038: 
38047:   return PostMessageInternal(PR_TRUE);
21320: }
21320: 
21320: /**
21320:  * See nsIWorker
21320:  */
21320: NS_IMETHODIMP
21320: nsDOMWorker::GetOnerror(nsIDOMEventListener** aOnerror)
21320: {
21320:   NS_ENSURE_ARG_POINTER(aOnerror);
21320: 
26209:   if (IsCanceled()) {
26209:     *aOnerror = nsnull;
26209:     return NS_OK;
26209:   }
26209: 
21320:   nsCOMPtr<nsIDOMEventListener> listener =
26209:     GetOnXListener(NS_LITERAL_STRING("error"));
21320: 
21320:   listener.forget(aOnerror);
21320:   return NS_OK;
21320: }
21320: 
21320: /**
21320:  * See nsIWorker
21320:  */
21320: NS_IMETHODIMP
21320: nsDOMWorker::SetOnerror(nsIDOMEventListener* aOnerror)
21320: {
26209:   NS_ASSERTION(mWrappedNative, "Called after Finalize!");
26209:   if (IsCanceled()) {
26209:     return NS_OK;
26209:   }
26209: 
26209:   return SetOnXListener(NS_LITERAL_STRING("error"), aOnerror);
21320: }
21320: 
21320: /**
21320:  * See nsIWorker
21320:  */
21320: NS_IMETHODIMP
21320: nsDOMWorker::GetOnmessage(nsIDOMEventListener** aOnmessage)
21320: {
21320:   NS_ENSURE_ARG_POINTER(aOnmessage);
21320: 
26209:   if (IsCanceled()) {
26209:     *aOnmessage = nsnull;
26209:     return NS_OK;
26209:   }
26209: 
21320:   nsCOMPtr<nsIDOMEventListener> listener =
26209:     GetOnXListener(NS_LITERAL_STRING("message"));
21320: 
21320:   listener.forget(aOnmessage);
21320:   return NS_OK;
21320: }
21320: 
21320: /**
21320:  * See nsIWorker
21320:  */
21320: NS_IMETHODIMP
21320: nsDOMWorker::SetOnmessage(nsIDOMEventListener* aOnmessage)
21320: {
26209:   NS_ASSERTION(mWrappedNative, "Called after Finalize!");
26209:   if (IsCanceled()) {
26209:     return NS_OK;
26209:   }
26209: 
26209:   return SetOnXListener(NS_LITERAL_STRING("message"), aOnmessage);
21320: }
22038: 
22038: NS_IMETHODIMP
22038: nsDOMWorker::Terminate()
22038: {
26209:   return TerminateInternal(PR_FALSE);
26209: }
26209: 
26209: NS_IMETHODIMP
26209: nsDOMWorker::Notify(nsITimer* aTimer)
26209: {
26209:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
26209:   Kill();
26172:   return NS_OK;
26166: }
