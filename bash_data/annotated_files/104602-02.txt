 98983: # This Source Code Form is subject to the terms of the Mozilla Public
 98983: # License, v. 2.0. If a copy of the MPL was not distributed with this
 98983: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 35742: 
 35990: import os, re, sys
 35742: from copy import deepcopy
 35742: 
 35990: import ipdl.ast
 35990: from ipdl.cxx.ast import *
 71247: from ipdl.type import ActorType, ProcessGraph, TypeVisitor
 35990: 
 35990: # FIXME/cjones: the chromium Message logging code doesn't work on
 35990: # gcc/POSIX, because it wprintf()s across the chromium/mozilla
 35990: # boundary. one side builds with -fshort-wchar, the other doesn't.
 35990: # this code will remain off until the chromium base lib is replaced
 35990: EMIT_LOGGING_CODE = ('win32' == sys.platform)
 35990: 
 35990: ##-----------------------------------------------------------------------------
 35990: ## "Public" interface to lowering
 35990: ##
 35990: class LowerToCxx:
 35990:     def lower(self, tu):
 36137:         '''returns |[ header: File ], [ cpp : File ]| representing the
 36137: lowered form of |tu|'''
 35990:         # annotate the AST with IPDL/C++ IR-type stuff used later
 35990:         tu.accept(_DecorateWithCxxStuff())
 35990: 
101616:         name = tu.name
101616:         pheader, pcpp = File(name +'.h'), File(name +'.cpp')
101616: 
101616:         _GenerateProtocolCode().lower(tu, pheader, pcpp)
101616:         headers = [ pheader ]
101616:         cpps = [ pcpp ]
101616: 
101616:         if tu.protocol:
101615:             pname = tu.protocol.name
101615: 
 36137:             parentheader, parentcpp = File(pname +'Parent.h'), File(pname +'Parent.cpp')
 36137:             _GenerateProtocolParentCode().lower(
 36137:                 tu, pname+'Parent', parentheader, parentcpp)
 36137: 
 36137:             childheader, childcpp = File(pname +'Child.h'), File(pname +'Child.cpp')
 36137:             _GenerateProtocolChildCode().lower(
 36137:                 tu, pname+'Child', childheader, childcpp)
 36137: 
101616:             headers += [ parentheader, childheader ]
101616:             cpps += [ parentcpp, childcpp ]
101616: 
101616:         return headers, cpps
 35990: 
 35990: 
 35990: ##-----------------------------------------------------------------------------
 35990: ## Helper code
 35990: ##
 36136: 
 36136: _NULL_ACTOR_ID = ExprLiteral.ZERO
 36136: _FREED_ACTOR_ID = ExprLiteral.ONE
 36136: 
 71234: _DISCLAIMER = Whitespace('''//
 71234: // Automatically generated by ipdlc.
 71234: // Edit at your own risk
 71234: //
 71234: 
 71234: ''')
 71234: 
 71234: 
 35990: class _struct: pass
 35990: 
101616: def _namespacedHeaderName(name, namespaces):
101616:     pfx = '/'.join([ ns.name for ns in namespaces ])
101616:     if pfx:
101616:         return pfx +'/'+ name
101616:     else:
101616:         return name
101616: 
101616: def _ipdlhHeaderName(tu):
101616:     assert tu.filetype == 'header'
101616:     return _namespacedHeaderName(tu.name, tu.namespaces)
101616: 
 36137: def _protocolHeaderName(p, side=''):
 36137:     if side: side = side.title()
 36137:     base = p.name + side
101616:     return _namespacedHeaderName(base, p.namespaces)
 35990: 
 35990: def _includeGuardMacroName(headerfile):
 35990:     return re.sub(r'[./]', '_', headerfile.name)
 35990: 
 35990: def _includeGuardStart(headerfile):
 35990:     guard = _includeGuardMacroName(headerfile)
 35990:     return [ CppDirective('ifndef', guard),
 35990:              CppDirective('define', guard)  ]
 35990: 
 35990: def _includeGuardEnd(headerfile):
 35990:     guard = _includeGuardMacroName(headerfile)
 35990:     return [ CppDirective('endif', '// ifndef '+ guard) ]
 35742: 
 38094: def _messageStartName(ptype):
 38094:     return ptype.name() +'MsgStart'
 38094: 
 38094: def _protocolId(ptype):
 38094:     return ExprVar(_messageStartName(ptype))
 38094: 
 38094: def _protocolIdType():
 38094:     return Type('int32')
 38094: 
 35896: def _actorName(pname, side):
 35896:     """|pname| is the protocol name. |side| is 'Parent' or 'Child'."""
 35990:     tag = side
 35990:     if not tag[0].isupper():  tag = side.title()
 35990:     return pname + tag
 35990: 
 35990: def _actorIdType():
 35990:     return Type('int32')
 35990: 
 63894: def _actorId(actor=None):
 63894:     if actor is not None:
 35990:         return ExprSelect(actor, '->', 'mId')
 63894:     return ExprVar('mId')
 35990: 
 35990: def _actorHId(actorhandle):
 35990:     return ExprSelect(actorhandle, '.', 'mId')
 35990: 
 35990: def _actorChannel(actor):
 35990:     return ExprSelect(actor, '->', 'mChannel')
 35990: 
 35990: def _actorManager(actor):
 35990:     return ExprSelect(actor, '->', 'mManager')
 35990: 
 47709: def _actorState(actor):
 47709:     return ExprSelect(actor, '->', 'mState')
 47709: 
 71247: def _backstagePass():
 71247:     return ExprCall(ExprVar('mozilla::ipc::PrivateIPDLInterface'))
 71247: 
 47709: def _nullState(proto=None):
 47709:     pfx = ''
 47709:     if proto is not None:  pfx = proto.name() +'::'
 47709:     return ExprVar(pfx +'__Null')
 47709: 
 47709: def _errorState(proto=None):
 47709:     pfx = ''
 47709:     if proto is not None:  pfx = proto.name() +'::'
 47709:     return ExprVar(pfx +'__Error')
 47709: 
 47709: def _deadState(proto=None):
 47709:     pfx = ''
 47709:     if proto is not None:  pfx = proto.name() +'::'
 47709:     return ExprVar(pfx +'__Dead')
 47709: 
104602: def _dyingState(proto=None):
104602:     pfx = ''
104602:     if proto is not None:  pfx = proto.name() +'::'
104602:     return ExprVar(pfx +'__Dying')
104602: 
 47709: def _startState(proto=None, fq=False):
 47709:     pfx = ''
 47709:     if proto:
 47709:         if fq:  pfx = proto.fullname() +'::'
 47709:         else:   pfx = proto.name() +'::'
 47709:     return ExprVar(pfx +'__Start')
 47709: 
 47710: def _deleteId():
 47710:     return ExprVar('Msg___delete____ID')
 47710: 
104602: def _deleteReplyId():
104602:     return ExprVar('Reply___delete____ID')
104602: 
 35990: def _lookupListener(idexpr):
 35990:     return ExprCall(ExprVar('Lookup'), args=[ idexpr ])
 35896: 
 42562: def _shmemType(ptr=0, const=1, ref=0):
 41362:     return Type('Shmem', ptr=ptr, ref=ref)
 36134: 
 36134: def _rawShmemType(ptr=0):
 36134:     return Type('Shmem::SharedMemory', ptr=ptr)
 36134: 
 39732: def _shmemIdType(ptr=0):
 39732:     return Type('Shmem::id_t', ptr=ptr)
 39312: 
 40908: def _shmemTypeType():
 40908:     return Type('Shmem::SharedMemory::SharedMemoryType')
 36134: 
 36134: def _shmemBackstagePass():
 36134:     return ExprCall(ExprVar(
 36134:         'Shmem::IHadBetterBeIPDLCodeCallingThis_OtherwiseIAmADoodyhead'))
 36134: 
 36134: def _shmemCtor(rawmem, idexpr):
 36134:     return ExprCall(ExprVar('Shmem'),
 36134:                     args=[ _shmemBackstagePass(), rawmem, idexpr ])
 36134: 
 36134: def _shmemId(shmemexpr):
 36134:     return ExprCall(ExprSelect(shmemexpr, '.', 'Id'),
 36134:                     args=[ _shmemBackstagePass() ])
 36134: 
 42562: def _shmemSegment(shmemexpr):
 42562:     return ExprCall(ExprSelect(shmemexpr, '.', 'Segment'),
 42562:                     args=[ _shmemBackstagePass() ])
 42562: 
 56896: def _shmemAlloc(size, type, unsafe):
 36134:     # starts out UNprotected
 36134:     return ExprCall(ExprVar('Shmem::Alloc'),
 56896:                     args=[ _shmemBackstagePass(), size, type, unsafe ])
 40908: 
 41362: def _shmemDealloc(rawmemvar):
 41362:     return ExprCall(ExprVar('Shmem::Dealloc'),
 41362:                     args=[ _shmemBackstagePass(), rawmemvar ])
 41362: 
 40908: def _shmemShareTo(shmemvar, processvar, route):
 40908:     return ExprCall(ExprSelect(shmemvar, '.', 'ShareTo'),
 40908:                     args=[ _shmemBackstagePass(),
 40908:                            processvar, route ])
 40908: 
 40908: def _shmemOpenExisting(descriptor, outid):
 36134:     # starts out protected
 36134:     return ExprCall(ExprVar('Shmem::OpenExisting'),
 36134:                     args=[ _shmemBackstagePass(),
 36134:                            # true => protect
 40908:                            descriptor, outid, ExprLiteral.TRUE ])
 39312: 
 41362: def _shmemUnshareFrom(shmemvar, processvar, route):
 41362:     return ExprCall(ExprSelect(shmemvar, '.', 'UnshareFrom'),
 41362:                     args=[ _shmemBackstagePass(),
 41362:                            processvar, route ])
 36134: 
 36134: def _shmemForget(shmemexpr):
 36134:     return ExprCall(ExprSelect(shmemexpr, '.', 'forget'),
 36134:                     args=[ _shmemBackstagePass() ])
 36134: 
 36134: def _shmemRevokeRights(shmemexpr):
 36134:     return ExprCall(ExprSelect(shmemexpr, '.', 'RevokeRights'),
 36134:                     args=[ _shmemBackstagePass() ])
 36134: 
 36134: def _lookupShmem(idexpr):
 39732:     return ExprCall(ExprVar('LookupSharedMemory'), args=[ idexpr ])
 39312: 
 42566: 
 42566: def _makeForwardDeclForQClass(clsname, quals):
 35990:     fd = ForwardDecl(clsname, cls=1)
 42566:     if 0 == len(quals):
 35848:         return fd
 35848: 
 42566:     outerns = Namespace(quals[0])
 35848:     innerns = outerns
 42566:     for ns in quals[1:]:
 35990:         tmpns = Namespace(ns)
 35848:         innerns.addstmt(tmpns)
 35848:         innerns = tmpns
 35848: 
 35848:     innerns.addstmt(fd)
 35848:     return outerns
 35742: 
 42566: def _makeForwardDeclForActor(ptype, side):
 42566:     return _makeForwardDeclForQClass(_actorName(ptype.qname.baseid, side),
 42566:                                      ptype.qname.quals)
 42566: 
 42566: def _makeForwardDecl(type):
 42566:     return _makeForwardDeclForQClass(type.name(), type.qname.quals)
 42566: 
 42566: 
 35990: def _putInNamespaces(cxxthing, namespaces):
 35990:     """|namespaces| is in order [ outer, ..., inner ]"""
 35990:     if 0 == len(namespaces):  return cxxthing
 35990: 
 35990:     outerns = Namespace(namespaces[0].name)
 35990:     innerns = outerns
 35990:     for ns in namespaces[1:]:
 35990:         newns = Namespace(ns.name)
 35990:         innerns.addstmt(newns)
 35990:         innerns = newns
 35990:     innerns.addstmt(cxxthing)
 35990:     return outerns
 35990: 
 35990: def _sendPrefix(msgtype):
 35990:     """Prefix of the name of the C++ method that sends |msgtype|."""
 35990:     if msgtype.isRpc():
 35990:         return 'Call'
 35990:     return 'Send'
 35990: 
 35990: def _recvPrefix(msgtype):
 35990:     """Prefix of the name of the C++ method that handles |msgtype|."""
 35990:     if msgtype.isRpc():
 35990:         return 'Answer'
 35990:     return 'Recv'
 35990: 
 35990: def _flatTypeName(ipdltype):
 35990:     """Return a 'flattened' IPDL type name that can be used as an
 35990: identifier.
 35990: E.g., |Foo[]| --> |ArrayOfFoo|."""
 35990:     # NB: this logic depends heavily on what IPDL types are allowed to
 35990:     # be constructed; e.g., Foo[][] is disallowed.  needs to be kept in
 35990:     # sync with grammar.
 35990:     if ipdltype.isIPDL() and ipdltype.isArray():
 35990:         return 'ArrayOf'+ ipdltype.basetype.name()
 35990:     return ipdltype.name()
 35990: 
 35990: 
 35990: def _hasVisibleActor(ipdltype):
 35990:     """Return true iff a C++ decl of |ipdltype| would have an Actor* type.
 57141: For example: |Actor[]| would turn into |Array<ActorParent*>|, so this
 35990: function would return true for |Actor[]|."""
 35990:     return (ipdltype.isIPDL()
 35990:             and (ipdltype.isActor()
 35990:                  or (ipdltype.isArray()
 35990:                      and _hasVisibleActor(ipdltype.basetype))))
 35990: 
 35990: def _abortIfFalse(cond, msg):
 35990:     return StmtExpr(ExprCall(
 35990:         ExprVar('NS_ABORT_IF_FALSE'),
 35990:         [ cond, ExprLiteral.String(msg) ]))
 35990: 
 35990: def _runtimeAbort(msg):
 35990:     return StmtExpr(ExprCall(ExprVar('NS_RUNTIMEABORT'),
 35990:                                      [ ExprLiteral.String(msg) ]))
 35990: 
 36134: def _autoptr(T):
 36134:     return Type('nsAutoPtr', T=T)
 36134: 
 40908: def _autoptrGet(expr):
 40908:     return ExprCall(ExprSelect(expr, '.', 'get'))
 40908: 
 36134: def _autoptrForget(expr):
 36134:     return ExprCall(ExprSelect(expr, '.', 'forget'))
 36134: 
 36139: def _cxxArrayType(basetype, const=0, ref=0):
 57141:     return Type('InfallibleTArray', T=basetype, const=const, ref=ref)
 35990: 
 35990: def _callCxxArrayLength(arr):
 35990:     return ExprCall(ExprSelect(arr, '.', 'Length'))
 35990: 
 42563: def _callCxxArraySetLength(arr, lenexpr, sel='.'):
 42563:     return ExprCall(ExprSelect(arr, sel, 'SetLength'),
 35990:                     args=[ lenexpr ])
 35990: 
 36139: def _callCxxArrayInsertSorted(arr, elt):
 36139:     return ExprCall(ExprSelect(arr, '.', 'InsertElementSorted'),
 36139:                     args=[ elt ])
 36139: 
 36139: def _callCxxArrayRemoveSorted(arr, elt):
 36139:     return ExprCall(ExprSelect(arr, '.', 'RemoveElementSorted'),
 36139:                     args=[ elt ])
 36139: 
 36140: def _callCxxArrayClear(arr):
 36140:     return ExprCall(ExprSelect(arr, '.', 'Clear'))
 36140: 
 38094: def _cxxArrayHasElementSorted(arr, elt):
 38094:     return ExprBinary(
 57140:         ExprSelect(arr, '.', 'NoIndex'), '!=',
 38094:         ExprCall(ExprSelect(arr, '.', 'BinaryIndexOf'), args=[ elt ]))
 38094: 
 35990: def _otherSide(side):
 35990:     if side == 'child':  return 'parent'
 35990:     if side == 'parent':  return 'child'
 35990:     assert 0
 35742: 
 71253: def _sideToTransportMode(side):
 71253:     if side == 'parent':  mode = 'SERVER'
 71253:     elif side == 'child': mode = 'CLIENT'
 71253:     return ExprVar('mozilla::ipc::Transport::MODE_'+ mode)
 71253: 
 36027: def _ifLogging(stmts):
 36028:     iflogging = StmtIf(ExprCall(ExprVar('mozilla::ipc::LoggingEnabled')))
 36027:     iflogging.addifstmts(stmts)
 36027:     return iflogging
 36027: 
 36135: # XXX we need to remove these and install proper error handling
 36135: def _printErrorMessage(msg):
 36136:     if isinstance(msg, str):
 36136:         msg = ExprLiteral.String(msg)
 36135:     return StmtExpr(
 36136:         ExprCall(ExprVar('NS_ERROR'), args=[ msg ]))
 36136: 
 47711: def _printWarningMessage(msg):
 47711:     if isinstance(msg, str):
 47711:         msg = ExprLiteral.String(msg)
 47711:     return StmtExpr(
 47711:         ExprCall(ExprVar('NS_WARNING'), args=[ msg ]))
 47711: 
 36136: def _fatalError(msg):
 36136:     return StmtExpr(
 36136:         ExprCall(ExprVar('FatalError'), args=[ ExprLiteral.String(msg) ]))
 36136: 
 36136: def _killProcess(pid):
 36136:     return ExprCall(
 36136:         ExprVar('base::KillProcess'),
 36136:         args=[ pid,
 36136:                # XXX this is meaningless on POSIX
 36136:                ExprVar('base::PROCESS_END_KILLED_BY_USER'),
 36136:                ExprLiteral.FALSE ])
 36136: 
 47711: def _badTransition():
 47711:     # FIXME: make this a FatalError()
 47711:     return [ _printWarningMessage('bad state transition!') ]
 47711: 
 36136: # Results that IPDL-generated code returns back to *Channel code.
 36136: # Users never see these
 36136: class _Result:
 36137:     @staticmethod
 36137:     def Type():
 36137:         return Type('Result')
 36136: 
 36136:     Processed = ExprVar('MsgProcessed')
 36136:     NotKnown = ExprVar('MsgNotKnown')
 36136:     NotAllowed = ExprVar('MsgNotAllowed')
 36136:     PayloadError = ExprVar('MsgPayloadError')
 42559:     ProcessingError = ExprVar('MsgProcessingError')
 36136:     RouteError = ExprVar('MsgRouteError')
 36136:     ValuError = ExprVar('MsgValueError') # [sic]
 36136: 
 36136: # these |errfn*| are functions that generate code to be executed on an
 36136: # error, such as "bad actor ID".  each is given a Python string
 36136: # containing a description of the error
 36136: 
 36136: # used in user-facing Send*() methods
 36136: def errfnSend(msg, errcode=ExprLiteral.FALSE):
 36136:     return [
 36136:         _fatalError(msg),
 36136:         StmtReturn(errcode)
 36136:     ]
 36136: 
 36136: def errfnSendCtor(msg):  return errfnSend(msg, errcode=ExprLiteral.NULL)
 36136: 
 36138: # TODO should this error handling be strengthened for dtors?
 36138: def errfnSendDtor(msg):
 36138:     return [
 36138:         _printErrorMessage(msg),
 42569:         StmtReturn.FALSE
 36138:     ]
 36138: 
 36136: # used in |OnMessage*()| handlers that hand in-messages off to Recv*()
 36136: # interface methods
 36136: def errfnRecv(msg, errcode=_Result.ValuError):
 36136:     return [
 36136:         _fatalError(msg),
 36136:         StmtReturn(errcode)
 36136:     ]
 36135: 
 42563: # used in Read() methods
 42563: def errfnRead(msg):
 42569:     return [ StmtReturn.FALSE ]
 42563: 
 36140: def _destroyMethod():
 36140:     return ExprVar('ActorDestroy')
 36140: 
 36140: class _DestroyReason:
 36140:     @staticmethod
 36140:     def Type():  return Type('ActorDestroyReason')
 36140: 
 36140:     Deletion = ExprVar('Deletion')
 36140:     AncestorDeletion = ExprVar('AncestorDeletion')
 36140:     NormalShutdown = ExprVar('NormalShutdown')
 36140:     AbnormalShutdown = ExprVar('AbnormalShutdown')
 63894:     FailedConstructor = ExprVar('FailedConstructor')
 36140: 
 35742: ##-----------------------------------------------------------------------------
 35990: ## Intermediate representation (IR) nodes used during lowering
 35990: 
 35990: class _ConvertToCxxType(TypeVisitor):
101732:     def __init__(self, side, fq):
101732:         self.side = side
101732:         self.fq = fq
101732: 
101732:     def typename(self, thing):
101732:         if self.fq:
101732:             return thing.fullname()
101732:         return thing.name()
 35990: 
 35990:     def visitBuiltinCxxType(self, t):
101732:         return Type(self.typename(t))
 35990: 
 35990:     def visitImportedCxxType(self, t):
101732:         return Type(self.typename(t))
 35990: 
 35990:     def visitActorType(self, a):
101732:         return Type(_actorName(self.typename(a.protocol), self.side), ptr=1)
 35990: 
 42564:     def visitStructType(self, s):
101732:         return Type(self.typename(s))
 42564: 
 35990:     def visitUnionType(self, u):
101732:         return Type(self.typename(u))
 35990: 
 35990:     def visitArrayType(self, a):
 35990:         basecxxtype = a.basetype.accept(self)
 35990:         return _cxxArrayType(basecxxtype)
 35990: 
 36134:     def visitShmemType(self, s):
101732:         return Type(self.typename(s))
 36134: 
 35990:     def visitProtocolType(self, p): assert 0
 35990:     def visitMessageType(self, m): assert 0
 35990:     def visitVoidType(self, v): assert 0
 35990:     def visitStateType(self, st): assert 0
 35990: 
101732: def _cxxBareType(ipdltype, side, fq=0):
101732:     return ipdltype.accept(_ConvertToCxxType(side, fq))
 38094: 
 42563: def _cxxRefType(ipdltype, side):
 42563:     t = _cxxBareType(ipdltype, side)
 42563:     t.ref = 1
 42563:     return t
 42563: 
 42563: def _cxxConstRefType(ipdltype, side):
 42563:     t = _cxxBareType(ipdltype, side)
 42563:     if ipdltype.isIPDL() and ipdltype.isActor():
 42563:         return t
 42563:     if ipdltype.isIPDL() and ipdltype.isShmem():
 42563:         t.ref = 1
 42563:         return t
 42563:     t.const = 1
 42563:     t.ref = 1
 42563:     return t
 42563: 
 42563: def _cxxPtrToType(ipdltype, side):
 42563:     t = _cxxBareType(ipdltype, side)
 42563:     if ipdltype.isIPDL() and ipdltype.isActor():
 42563:         t.ptr = 0
 42563:         t.ptrptr = 1
 42563:         return t
 42563:     t.ptr = 1
 42563:     return t
 42563: 
 42563: def _cxxConstPtrToType(ipdltype, side):
 42563:     t = _cxxBareType(ipdltype, side)
 42563:     if ipdltype.isIPDL() and ipdltype.isActor():
 42563:         t.ptr = 0
 49287:         t.ptrconstptr = 1
 42563:         return t
 42563:     t.const = 1
 42563:     t.ptrconst = 1
 42563:     return t
 42563: 
 36138: def _allocMethod(ptype):
 36138:     return ExprVar('Alloc'+ ptype.name())
 36138: 
 36138: def _deallocMethod(ptype):
 36138:     return ExprVar('Dealloc'+ ptype.name())
 35990: 
 35990: ##
 35990: ## A _HybridDecl straddles IPDL and C++ decls.  It knows which C++
 35990: ## types correspond to which IPDL types, and it also knows how
 35990: ## serialize and deserialize "special" IPDL C++ types.
 35990: ##
 35990: class _HybridDecl:
 35990:     """A hybrid decl stores both an IPDL type and all the C++ type
 35990: info needed by later passes, along with a basic name for the decl."""
 35990:     def __init__(self, ipdltype, name):
 35990:         self.ipdltype = ipdltype
 35990:         self.name = name
 35990:         self.idnum = 0
 35990: 
 35990:     def var(self):
 35990:         return ExprVar(self.name)
 35990: 
 35990:     def bareType(self, side):
 35990:         """Return this decl's unqualified C++ type."""
 42563:         return _cxxBareType(self.ipdltype, side)
 35990: 
 35990:     def refType(self, side):
 35990:         """Return this decl's C++ type as a 'reference' type, which is not
 35990: necessarily a C++ reference."""
 42563:         return _cxxRefType(self.ipdltype, side)
 35990: 
 35990:     def constRefType(self, side):
 35990:         """Return this decl's C++ type as a const, 'reference' type."""
 42563:         return _cxxConstRefType(self.ipdltype, side)
 35990: 
 35990:     def ptrToType(self, side):
 42563:         return _cxxPtrToType(self.ipdltype, side)
 35990: 
 35990:     def constPtrToType(self, side):
 42563:         return _cxxConstPtrToType(self.ipdltype, side)
 35990: 
 35990:     def inType(self, side):
 35990:         """Return this decl's C++ Type with inparam semantics."""
 35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
 35990:             return self.bareType(side)
 35990:         return self.constRefType(side)
 35990: 
 35990:     def outType(self, side):
 35990:         """Return this decl's C++ Type with outparam semantics."""
 35990:         t = self.bareType(side)
 35990:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
 35990:             t.ptr = 0;  t.ptrptr = 1
 35990:             return t
 35990:         t.ptr = 1
 35990:         return t
 35990: 
 35990: ##--------------------------------------------------
 35990: 
 42564: class HasFQName:
 35990:     def fqClassName(self):
 35990:         return self.decl.type.fullname()
 35990: 
 42566: class _CompoundTypeComponent(_HybridDecl):
 42566:     def __init__(self, ipdltype, name, side, ct):
 42566:         _HybridDecl.__init__(self, ipdltype, name)
 35990:         self.side = side
 42566:         self.special = _hasVisibleActor(ipdltype)
 42566:         self.recursive = ct.decl.type.mutuallyRecursiveWith(ipdltype)
 42566: 
 42566:     def internalType(self):
 42566:         if self.recursive:
 42566:             return self.ptrToType()
 35990:         else:
 42566:             return self.bareType()
 35990: 
 35990:     # @override the following methods to pass |self.side| instead of
 35990:     # forcing the caller to remember which side we're declared to
 35990:     # represent.
 35990:     def bareType(self, side=None):
 35990:         return _HybridDecl.bareType(self, self.side)
 35990:     def refType(self, side=None):
 35990:         return _HybridDecl.refType(self, self.side)
 35990:     def constRefType(self, side=None):
 35990:         return _HybridDecl.constRefType(self, self.side)
 35990:     def ptrToType(self, side=None):
 35990:         return _HybridDecl.ptrToType(self, self.side)
 35990:     def constPtrToType(self, side=None):
 35990:         return _HybridDecl.constPtrToType(self, self.side)
 35990:     def inType(self, side=None):
 35990:         return _HybridDecl.inType(self, self.side)
 35990: 
 42564: 
 42566: class StructDecl(ipdl.ast.StructDecl, HasFQName):
 42566:     @staticmethod
 42566:     def upgrade(structDecl):
 42566:         assert isinstance(structDecl, ipdl.ast.StructDecl)
 42566:         structDecl.__class__ = StructDecl
 42566:         return structDecl
 42566: 
 42566: class _StructField(_CompoundTypeComponent):
 42566:     def __init__(self, ipdltype, name, sd, side=None):
 42566:         fname = name
 42566:         special = _hasVisibleActor(ipdltype)
 42566:         if special:
 42566:             fname += side.title()
 42566: 
 42566:         _CompoundTypeComponent.__init__(self, ipdltype, fname, side, sd)
 42566: 
 42566:     def getMethod(self, thisexpr=None, sel='.'):
 42566:         meth = self.var()
 42566:         if thisexpr is not None:
 42566:             return ExprSelect(thisexpr, sel, meth.name)
 42566:         return meth
 42566: 
 42566:     def initExpr(self, thisexpr):
 42566:         expr = ExprCall(self.getMethod(thisexpr=thisexpr))
 42566:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
 42566:             expr = ExprCast(expr, self.bareType(), const=1)
 42566:         return expr
 42566: 
 42566:     def refExpr(self, thisexpr=None):
 42566:         ref = self.memberVar()
 42566:         if thisexpr is not None:
 42566:             ref = ExprSelect(thisexpr, '.', ref.name)
 42566:         if self.recursive:
 42566:             ref = ExprDeref(ref)
 42566:         return ref
 42566: 
 44201:     def constRefExpr(self, thisexpr=None):
 44201:         # sigh, gross hack
 44201:         refexpr = self.refExpr(thisexpr)
 44201:         if 'Shmem' == self.ipdltype.name():
 44201:             refexpr = ExprCast(refexpr, Type('Shmem', ref=1), const=1)
 44201:         return refexpr
 44201: 
 42566:     def argVar(self):
 42566:         return ExprVar('_'+ self.name)
 42566: 
 42566:     def memberVar(self):
 42566:         return ExprVar(self.name + '_')
 42566: 
 42566:     def initStmts(self):
 42566:         if self.recursive:
 42566:             return [ StmtExpr(ExprAssn(self.memberVar(),
 42566:                                        ExprNew(self.bareType()))) ]
104362:         elif self.ipdltype.isIPDL() and self.ipdltype.isActor():
104362:             return [ StmtExpr(ExprAssn(self.memberVar(),
104362:                                        ExprLiteral.NULL)) ]
 42566:         else:
 42566:             return []
 42566: 
 42566:     def destructStmts(self):
 42566:         if self.recursive:
 42566:             return [ StmtExpr(ExprDelete(self.memberVar())) ]
 42566:         else:
 42566:             return []
 42566: 
 42566: 
 42564: class UnionDecl(ipdl.ast.UnionDecl, HasFQName):
 42564:     def callType(self, var=None):
 42564:         func = ExprVar('type')
 42564:         if var is not None:
 42564:             func = ExprSelect(var, '.', func.name)
 42564:         return ExprCall(func)
 42564: 
 42564:     @staticmethod
 42564:     def upgrade(unionDecl):
 42564:         assert isinstance(unionDecl, ipdl.ast.UnionDecl)
 42564:         unionDecl.__class__ = UnionDecl
 42564:         return unionDecl
 42564: 
 42564: 
 42566: class _UnionMember(_CompoundTypeComponent):
 42564:     """Not in the AFL sense, but rather a member (e.g. |int;|) of an
 42564: IPDL union type."""
 42564:     def __init__(self, ipdltype, ud, side=None, other=None):
 42564:         flatname = _flatTypeName(ipdltype)
 42564:         special = _hasVisibleActor(ipdltype)
 42564:         if special:
 42564:             flatname += side.title()
 42564: 
 42566:         _CompoundTypeComponent.__init__(self, ipdltype, 'V'+ flatname, side, ud)
 42564:         self.flattypename = flatname
 42564:         if special:
 42564:             if other is not None:
 42564:                 self.other = other
 42564:             else:
 42564:                 self.other = _UnionMember(ipdltype, ud, _otherSide(side), self)
 42564: 
 42564:     def enum(self):
 42564:         return 'T' + self.flattypename
 42564: 
 42564:     def pqEnum(self):
 42564:         return self.ud.name +'::'+ self.enum()
 42564: 
 42564:     def enumvar(self):
 42564:         return ExprVar(self.enum())
 42564: 
 42564:     def unionType(self):
 42564:         """Type used for storage in generated C union decl."""
 42566:         if self.recursive:
 42566:             return self.ptrToType()
 42566:         else:
 42566:             return TypeArray(Type('char'), ExprSizeof(self.internalType()))
 42564: 
 42564:     def unionValue(self):
 42564:         # NB: knows that Union's storage C union is named |mValue|
 42564:         return ExprSelect(ExprVar('mValue'), '.', self.name)
 42564: 
 42564:     def typedef(self):
 42564:         return self.flattypename +'__tdef'
 42564: 
 42564:     def callGetConstPtr(self):
 42564:         """Return an expression of type self.constptrToSelfType()"""
 42564:         return ExprCall(ExprVar(self.getConstPtrName()))
 42564: 
 42564:     def callGetPtr(self):
 42564:         """Return an expression of type self.ptrToSelfType()"""
 42564:         return ExprCall(ExprVar(self.getPtrName()))
 42564: 
 42564:     def callOperatorEq(self, rhs):
 42564:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
 42564:             rhs = ExprCast(rhs, self.bareType(), const=1)
 42564:         return ExprAssn(ExprDeref(self.callGetPtr()), rhs)
 42564: 
 42566:     def callCtor(self, expr=None):
 42564:         assert not isinstance(expr, list)
 42564:         
 42564:         if expr is None:
 42564:             args = None
 42564:         elif self.ipdltype.isIPDL() and self.ipdltype.isActor():
 42564:             args = [ ExprCast(expr, self.bareType(), const=1) ]
 42564:         else:
 42564:             args = [ expr ]
 42564: 
 42566:         if self.recursive:
 42566:             return ExprAssn(self.callGetPtr(),
 42566:                             ExprNew(self.bareType(self.side),
 42566:                                     args=args))
 42566:         else:
 42564:             return ExprNew(self.bareType(self.side),
 42564:                            args=args,
 42564:                            newargs=[ self.callGetPtr() ])
 42564: 
 42566:     def callDtor(self):
 42566:         if self.recursive:
 42566:             return ExprDelete(self.callGetPtr())
 42566:         else:
 42564:             return ExprCall(
 42564:                 ExprSelect(self.callGetPtr(), '->', '~'+ self.typedef()))
 42564: 
 42564:     def getTypeName(self): return 'get_'+ self.flattypename
 42564:     def getConstTypeName(self): return 'get_'+ self.flattypename
 42564: 
 42564:     def getOtherTypeName(self): return 'get_'+ self.otherflattypename
 42564: 
 42564:     def getPtrName(self): return 'ptr_'+ self.flattypename
 42564:     def getConstPtrName(self): return 'constptr_'+ self.flattypename
 42564: 
 42564:     def ptrToSelfExpr(self):
 42564:         """|*ptrToSelfExpr()| has type |self.bareType()|"""
 42566:         v = self.unionValue()
 42566:         if self.recursive:
 42566:             return v
 42566:         else:
 42566:             return ExprCast(ExprAddrOf(v), self.ptrToType(), reinterpret=1)
 42564: 
 42564:     def constptrToSelfExpr(self):
 42564:         """|*constptrToSelfExpr()| has type |self.constType()|"""
 42566:         v = self.unionValue()
 42566:         if self.recursive:
 42566:             return v
 42566:         return ExprCast(ExprAddrOf(v), self.constPtrToType(), reinterpret=1)
 42566: 
 42566:     def ptrToInternalType(self):
 42566:         t = self.ptrToType()
 42566:         if self.recursive:
 42566:             t.ref = 1
 42566:         return t
 42564: 
 42564:     def defaultValue(self):
 42564:         if self.ipdltype.isIPDL() and self.ipdltype.isActor():
 42564:             return ExprCast(ExprLiteral.NULL, self.bareType(), static=1)
 42564:         # XXX sneaky here, maybe need ExprCtor()?
 42564:         return ExprCall(self.bareType())
 35990: 
 52195:     def getConstValue(self):
 52195:         v = ExprDeref(self.callGetConstPtr())
 52195:         # sigh
 52195:         if 'Shmem' == self.ipdltype.name():
 52195:             v = ExprCast(v, Type('Shmem', ref=1), const=1)
 52195:         return v
 52195: 
 35990: ##--------------------------------------------------
 35990: 
 35990: class MessageDecl(ipdl.ast.MessageDecl):
 35990:     def baseName(self):
 35990:         return self.name
 35990:     
 35990:     def recvMethod(self):
 35990:         name = _recvPrefix(self.decl.type) + self.baseName()
 35990:         if self.decl.type.isCtor():
 35990:             name += 'Constructor'
 35990:         return ExprVar(name)
 35990: 
 35990:     def sendMethod(self):
 35990:         name = _sendPrefix(self.decl.type) + self.baseName()
 35990:         if self.decl.type.isCtor():
 35990:             name += 'Constructor'
 35990:         return ExprVar(name)
 35990: 
 35990:     def hasReply(self):
 35990:         return (self.decl.type.hasReply()
 35990:                 or self.decl.type.isCtor()
 35990:                 or self.decl.type.isDtor())
 35990: 
 35990:     def msgClass(self):
 35990:         return 'Msg_%s'% (self.decl.progname)
 35990: 
 39613:     def prettyMsgName(self, pfx=''):
 39613:         return pfx + self.msgClass()
 39613: 
 35990:     def pqMsgClass(self):
 35990:         return '%s::%s'% (self.namespace, self.msgClass())
 35990: 
 36027:     def msgCast(self, msgexpr):
 39613:         return ExprCast(msgexpr, self.msgCxxType(const=1, ptr=1), static=1)
 39613: 
 39613:     def msgCxxType(self, const=0, ref=0, ptr=0):
 39613:         return Type(self.pqMsgClass(), const=const, ref=ref, ptr=ptr)
 36027: 
 35990:     def msgId(self):  return self.msgClass()+ '__ID'
 35990:     def pqMsgId(self):
 35990:         return '%s::%s'% (self.namespace, self.msgId())
 35990: 
 35990:     def replyClass(self):
 35990:         return 'Reply_%s'% (self.decl.progname)
 35990: 
 35990:     def pqReplyClass(self):
 35990:         return '%s::%s'% (self.namespace, self.replyClass())
 35990: 
 36027:     def replyCast(self, replyexpr):
 36027:         return ExprCast(replyexpr, Type(self.pqReplyClass(), const=1, ptr=1),
 36138:                         static=1)
 36027: 
 35990:     def replyId(self):  return self.replyClass()+ '__ID'
 35990:     def pqReplyId(self):
 35990:         return '%s::%s'% (self.namespace, self.replyId())
 35990: 
 39613:     def prettyReplyName(self, pfx=''):
 39613:         return pfx + self.replyClass()
 39613: 
 35990:     def actorDecl(self):
 35990:         return self.params[0]
 35990: 
 35990:     def makeCxxParams(self, paramsems='in', returnsems='out',
 42563:                       side=None, implicit=1):
 35990:         """Return a list of C++ decls per the spec'd configuration.
 42563: |params| and |returns| is the C++ semantics of those: 'in', 'out', or None."""
 42563: 
 42563:         def makeDecl(d, sems):
 42563:             if sems is 'in':
 35990:                 return Decl(d.inType(side), d.name)
 35990:             elif sems is 'out':
 35990:                 return Decl(d.outType(side), d.name)
 35990:             else: assert 0
 35990: 
 35990:         cxxparams = [ ]
 35990:         if paramsems is not None:
 42563:             cxxparams.extend([ makeDecl(d, paramsems) for d in self.params ])
 35990: 
 35990:         if returnsems is not None:
 42563:             cxxparams.extend([ makeDecl(r, returnsems) for r in self.returns ])
 35990: 
 35990:         if not implicit and self.decl.type.hasImplicitActorParam():
 35990:             cxxparams = cxxparams[1:]
 35990: 
 35990:         return cxxparams
 35990: 
 35990:     def makeCxxArgs(self, params=1, retsems='out', retcallsems='out',
 35990:                     implicit=1):
 35990:         assert not implicit or params     # implicit => params
 35990:         assert not retcallsems or retsems # retcallsems => returnsems
 35990:         cxxargs = [ ]
 35990: 
 35990:         if params:
 35990:             cxxargs.extend([ p.var() for p in self.params ])
 35990: 
 35990:         for ret in self.returns:
 35990:             if retsems is 'in':
 35990:                 if retcallsems is 'in':
 35990:                     cxxargs.append(ret.var())
 35990:                 elif retcallsems is 'out':
 35990:                     cxxargs.append(ExprAddrOf(ret.var()))
 35990:                 else: assert 0
 35990:             elif retsems is 'out':
 35990:                 if retcallsems is 'in':
 35990:                     cxxargs.append(ExprDeref(ret.var()))
 35990:                 elif retcallsems is 'out':
 35990:                     cxxargs.append(ret.var())
 35990:                 else: assert 0
 35990: 
 35990:         if not implicit:
 35990:             assert self.decl.type.hasImplicitActorParam()
 35990:             cxxargs = cxxargs[1:]
 35990: 
 35990:         return cxxargs
 35990: 
 35990: 
 35990:     @staticmethod
 35990:     def upgrade(messageDecl):
 35990:         assert isinstance(messageDecl, ipdl.ast.MessageDecl)
 35990:         if messageDecl.decl.type.hasImplicitActorParam():
 35990:             messageDecl.params.insert(
 35990:                 0,
 35990:                 _HybridDecl(
 35990:                     ipdl.type.ActorType(
 35990:                         messageDecl.decl.type.constructedType()),
 35990:                     'actor'))
 35990:         messageDecl.__class__ = MessageDecl
 35990:         return messageDecl
 35990: 
 35990: ##--------------------------------------------------
 35990: def _semsToChannelParts(sems):
 35990:     if ipdl.ast.ASYNC == sems:   channel = 'AsyncChannel'
 35990:     elif ipdl.ast.SYNC == sems:  channel = 'SyncChannel'
 35990:     elif ipdl.ast.RPC == sems:   channel = 'RPCChannel'
 35990:     return [ 'mozilla', 'ipc', channel ]
 35990: 
 35990: def _semsToListener(sems):
 35990:     return { ipdl.ast.ASYNC: 'AsyncListener',
 35990:              ipdl.ast.SYNC: 'SyncListener',
 35990:              ipdl.ast.RPC: 'RPCListener' }[sems]
 35990: 
 41364: def _usesShmem(p):
 41364:     for md in p.messageDecls:
 36134:         for param in md.inParams:
 36134:             if ipdl.type.hasshmem(param.type):
 36134:                 return True
 36134:         for ret in md.outParams:
 36134:             if ipdl.type.hasshmem(ret.type):
 36134:                 return True
 36134:     return False
 36134: 
 41364: def _subtreeUsesShmem(p):
 41364:     if _usesShmem(p):
 41364:         return True
 41368: 
 41368:     ptype = p.decl.type
 41368:     for mgd in ptype.manages:
 41368:         if ptype is not mgd:
101616:             if _subtreeUsesShmem(mgd._ast):
 41364:                 return True
 41364:     return False
 41364: 
 41364: 
 41364: class Protocol(ipdl.ast.Protocol):
 41364:     def cxxTypedefs(self):
 41364:         return self.decl.cxxtypedefs
 41364: 
 41364:     def sendSems(self):
 41364:         return self.decl.type.toplevel().sendSemantics
 41364: 
 41364:     def channelName(self):
 41364:         return '::'.join(_semsToChannelParts(self.sendSems()))
 41364: 
 41364:     def channelSel(self):
 41364:         if self.decl.type.isToplevel():  return '.'
 41364:         return '->'
 41364: 
 41364:     def channelType(self):
 41364:         return Type('Channel', ptr=not self.decl.type.isToplevel())
 41364: 
 41364:     def channelHeaderFile(self):
 41364:         return '/'.join(_semsToChannelParts(self.sendSems())) +'.h'
 41364: 
 41364:     def listenerName(self):
 41364:         return _semsToListener(self.sendSems())
 41364: 
 41364:     def fqListenerName(self):
 41364:         return self.channelName() +'::'+ _semsToListener(self.sendSems())
 41364: 
 41364:     def managerInterfaceType(self, ptr=0):
 41364:         return Type('mozilla::ipc::IProtocolManager',
 41364:                     ptr=ptr,
 41364:                     T=Type(self.fqListenerName()))
 41364: 
 41364:     def _ipdlmgrtype(self):
 41364:         assert 1 == len(self.decl.type.managers)
 41364:         for mgr in self.decl.type.managers:  return mgr
 41364: 
 41364:     def managerActorType(self, side, ptr=0):
 41364:         return Type(_actorName(self._ipdlmgrtype().name(), side),
 41364:                     ptr=ptr)
 41364: 
 41364:     def managerMethod(self, actorThis=None):
 41364:         _ = self._ipdlmgrtype()
 41364:         if actorThis is not None:
 41364:             return ExprSelect(actorThis, '->', 'Manager')
 41364:         return ExprVar('Manager');
 41364: 
 41364:     def stateMethod(self):
 41364:         return ExprVar('state');
 41364: 
 41364:     def registerMethod(self):
 41364:         return ExprVar('Register')
 41364: 
 41364:     def registerIDMethod(self):
 41364:         return ExprVar('RegisterID')
 41364: 
 41364:     def lookupIDMethod(self):
 41364:         return ExprVar('Lookup')
 41364: 
 41364:     def unregisterMethod(self, actorThis=None):
 41364:         if actorThis is not None:
 41364:             return ExprSelect(actorThis, '->', 'Unregister')
 41364:         return ExprVar('Unregister')
 41364: 
 41364:     def removeManageeMethod(self):
 41364:         return ExprVar('RemoveManagee')
 41364: 
 41364:     def createSharedMemory(self):
 41364:         return ExprVar('CreateSharedMemory')
 41364: 
 42562:     def adoptSharedMemory(self):
 42562:         return ExprVar('AdoptSharedMemory')
 42562:  
 41364:     def lookupSharedMemory(self):
 41364:         return ExprVar('LookupSharedMemory')
 41364: 
 42562:     def isTrackingSharedMemory(self):
 42562:         return ExprVar('IsTrackingSharedMemory')
 42562: 
 41364:     def destroySharedMemory(self):
 41364:         return ExprVar('DestroySharedMemory')
 41364: 
 41364:     def otherProcessMethod(self):
 41364:         return ExprVar('OtherProcess')
 41364: 
 71247:     def callOtherProcess(self, actorThis=None):
 71247:         fn = self.otherProcessMethod()
 71247:         if actorThis is not None:
 71247:             fn = ExprSelect(actorThis, '->', fn.name)
 71247:         return ExprCall(fn)
 71247: 
 71239:     def getChannelMethod(self):
 71239:         return ExprVar('GetIPCChannel')
 71239: 
 71247:     def callGetChannel(self, actorThis=None):
 71247:         fn = self.getChannelMethod()
 71247:         if actorThis is not None:
 71247:             fn = ExprSelect(actorThis, '->', fn.name)
 71247:         return ExprCall(fn)
 71247: 
 54001:     def processingErrorVar(self):
 54001:         assert self.decl.type.isToplevel()
 54001:         return ExprVar('ProcessingError')
 54001: 
 41364:     def shouldContinueFromTimeoutVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('ShouldContinueFromReplyTimeout')
 41364: 
 41364:     def enteredCxxStackVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('EnteredCxxStack')
 41364: 
 41364:     def exitedCxxStackVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('ExitedCxxStack')
 41364: 
 41650:     def enteredCallVar(self):
 41650:         assert self.decl.type.isToplevel()
 41650:         return ExprVar('EnteredCall')
 41650: 
 41650:     def exitedCallVar(self):
 41650:         assert self.decl.type.isToplevel()
 41650:         return ExprVar('ExitedCall')
 41650: 
 41364:     def onCxxStackVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('IsOnCxxStack')
 41364: 
 41364:     def nextActorIdExpr(self, side):
 41364:         assert self.decl.type.isToplevel()
 41364:         if side is 'parent':   op = '++'
 41364:         elif side is 'child':  op = '--'
 41364:         else: assert 0
 41364:         return ExprPrefixUnop(self.lastActorIdVar(), op)
 41364: 
 41364:     def actorIdInit(self, side):
 41364:         assert self.decl.type.isToplevel()
 41364: 
 41364:         # parents go up from FREED, children go down from NULL
 41364:         if side is 'parent':  return _FREED_ACTOR_ID
 41364:         elif side is 'child': return _NULL_ACTOR_ID
 41364:         else: assert 0
 41364: 
 41364:     # an actor's C++ private variables
 41364:     def lastActorIdVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('mLastRouteId')
 41364: 
 41364:     def actorMapVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('mActorMap')
 41364: 
 41364:     def channelVar(self, actorThis=None):
 41364:         if actorThis is not None:
 41364:             return ExprSelect(actorThis, '->', 'mChannel')
 41364:         return ExprVar('mChannel')
 41364: 
 41364:     def channelForSubactor(self):
 41364:         if self.decl.type.isToplevel():
 41364:             return ExprAddrOf(self.channelVar())
 41364:         return self.channelVar()
 41364: 
 41364:     def routingId(self, actorThis=None):
 41364:         if self.decl.type.isToplevel():
 41364:             return ExprVar('MSG_ROUTING_CONTROL')
 41364:         if actorThis is not None:
 41364:             return ExprSelect(actorThis, '->', self.idVar().name)
 41364:         return self.idVar()
 41364: 
 41364:     def idVar(self):
 41364:         assert not self.decl.type.isToplevel()
 41364:         return ExprVar('mId')
 41364: 
 47709:     def stateVar(self):
 47709:         return ExprVar('mState')
 47709: 
 47709:     def fqStateType(self):
 47709:         return Type(self.decl.type.name() +'::State')
 47709: 
 47709:     def startState(self):
 47709:         return _startState(self.decl.type)
 47709: 
 47709:     def nullState(self):
 47709:         return _nullState(self.decl.type)
 47709: 
 47709:     def deadState(self):
 47709:         return _deadState(self.decl.type)
 47709: 
 41364:     def managerVar(self, thisexpr=None):
 41364:         assert thisexpr is not None or not self.decl.type.isToplevel()
 41364:         mvar = ExprVar('mManager')
 41364:         if thisexpr is not None:
 41364:             mvar = ExprSelect(thisexpr, '->', mvar.name)
 41364:         return mvar
 41364: 
 41364:     def otherProcessVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('mOtherProcess')
 41364: 
 41364:     def managedCxxType(self, actortype, side):
 41364:         assert self.decl.type.isManagerOf(actortype)
 41364:         return Type(_actorName(actortype.name(), side), ptr=1)
 41364: 
 41364:     def managedMethod(self, actortype, side):
 41364:         assert self.decl.type.isManagerOf(actortype)
 41364:         return ExprVar('Managed'+  _actorName(actortype.name(), side))
 41364: 
 41364:     def managedVar(self, actortype, side):
 41364:         assert self.decl.type.isManagerOf(actortype)
 41364:         return ExprVar('mManaged'+ _actorName(actortype.name(), side))
 41364: 
 41364:     def managedVarType(self, actortype, side, const=0, ref=0):
 41364:         assert self.decl.type.isManagerOf(actortype)
 41364:         return _cxxArrayType(self.managedCxxType(actortype, side),
 41364:                              const=const, ref=ref)
 41364: 
 41364:     def managerArrayExpr(self, thisvar, side):
 41364:         """The member var my manager keeps of actors of my type."""
 41364:         assert self.decl.type.isManaged()
 41364:         return ExprSelect(
 41364:             ExprCall(self.managerMethod(thisvar)),
 41364:             '->', 'mManaged'+ _actorName(self.decl.type.name(), side))
 41364: 
 41364:     # shmem stuff
 41364:     def shmemMapType(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return Type('IDMap', T=_rawShmemType())
 41364: 
 41364:     def shmemIteratorType(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         # XXX breaks abstractions
 41364:         return Type('IDMap<SharedMemory>::const_iterator')
 41364: 
 41364:     def shmemMapVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('mShmemMap')
 41364: 
 41364:     def lastShmemIdVar(self):
 41364:         assert self.decl.type.isToplevel()
 41364:         return ExprVar('mLastShmemId')
 41364: 
 41364:     def shmemIdInit(self, side):
 41364:         assert self.decl.type.isToplevel()
 41364:         # use the same scheme for shmem IDs as actor IDs
 41364:         if side is 'parent':  return _FREED_ACTOR_ID
 41364:         elif side is 'child': return _NULL_ACTOR_ID
 41364:         else: assert 0
 41364: 
 41364:     def nextShmemIdExpr(self, side):
 41364:         assert self.decl.type.isToplevel()
 41364:         if side is 'parent':   op = '++'
 41364:         elif side is 'child':  op = '--'
 41364:         return ExprPrefixUnop(self.lastShmemIdVar(), op)
 41364: 
 41364:     def removeShmemId(self, idexpr):
 41364:         return ExprCall(ExprSelect(self.shmemMapVar(), '.', 'Remove'),
 41364:                         args=[ idexpr ])
 41364: 
 41364:     # XXX this is sucky, fix
 41364:     def usesShmem(self):
 41364:         return _usesShmem(self)
 41364: 
 41364:     def subtreeUsesShmem(self):
 41364:         return _subtreeUsesShmem(self)
 41364: 
 35990:     @staticmethod
 35990:     def upgrade(protocol):
 35990:         assert isinstance(protocol, ipdl.ast.Protocol)
 35990:         protocol.__class__ = Protocol
 35990:         return protocol
 35990: 
101616: 
101616: class TranslationUnit(ipdl.ast.TranslationUnit):
101616:     @staticmethod
101616:     def upgrade(tu):
101616:         assert isinstance(tu, ipdl.ast.TranslationUnit)
101616:         tu.__class__ = TranslationUnit
101616:         return tu
101616: 
 35990: ##-----------------------------------------------------------------------------
 35990: 
 35990: class _DecorateWithCxxStuff(ipdl.ast.Visitor):
 35990:     """Phase 1 of lowering: decorate the IPDL AST with information
 35990: relevant to C++ code generation.
 35990: 
 35990: This pass results in an AST that is a poor man's "IR"; in reality, a
 35990: "hybrid" AST mainly consisting of IPDL nodes with new C++ info along
 35990: with some new IPDL/C++ nodes that are tuned for C++ codegen."""
 35990: 
 35742:     def __init__(self):
101616:         self.visitedTus = set()
 35990:         # the set of typedefs that allow generated classes to
 35990:         # reference known C++ types by their "short name" rather than
 35990:         # fully-qualified name. e.g. |Foo| rather than |a::b::Foo|.
101616:         self.typedefs = [ ]
101616:         self.typedefSet = set([ Typedef(Type('mozilla::ipc::ActorHandle'),
101616:                                         'ActorHandle') ])
 35990:         self.protocolName = None
 35990: 
101616:     def visitTranslationUnit(self, tu):
101616:         if not isinstance(tu, TranslationUnit) and tu not in self.visitedTus:
101616:             self.visitedTus.add(tu)
101616:             ipdl.ast.Visitor.visitTranslationUnit(self, tu)
101616:             TranslationUnit.upgrade(tu)
101616:             self.typedefs[:] = sorted(list(self.typedefSet))
101616: 
101616:     def visitInclude(self, inc):
101616:         if inc.tu.filetype == 'header':
101616:             inc.tu.accept(self)
101616: 
 35990:     def visitProtocol(self, pro):
 35990:         self.protocolName = pro.name
 35990:         pro.decl.cxxtypedefs = self.typedefs
 35990:         Protocol.upgrade(pro)
 35990:         return ipdl.ast.Visitor.visitProtocol(self, pro)
 35990: 
 35990: 
 35990:     def visitUsingStmt(self, using):
 35990:         if using.decl.fullname is not None:
101616:             self.typedefSet.add(Typedef(Type(using.decl.fullname),
 35990:                                         using.decl.shortname))
 35990: 
 42564:     def visitStructDecl(self, sd):
 42564:         sd.decl.special = 0
 42564:         newfields = [ ]
 42564:         for f in sd.fields:
 42564:             ftype = f.decl.type
 42564:             if _hasVisibleActor(ftype):
 42564:                 sd.decl.special = 1
 42564:                 # if ftype has a visible actor, we need both
 42564:                 # |ActorParent| and |ActorChild| fields
 42564:                 newfields.append(_StructField(ftype, f.name, sd, side='parent'))
 42564:                 newfields.append(_StructField(ftype, f.name, sd, side='child'))
 42564:             else:
 42564:                 newfields.append(_StructField(ftype, f.name, sd))
 42564:         sd.fields = newfields
 42564:         StructDecl.upgrade(sd)
 42564: 
 42564:         if sd.decl.fullname is not None:
101616:             self.typedefSet.add(Typedef(Type(sd.fqClassName()), sd.name))
 42564: 
 42564: 
 35990:     def visitUnionDecl(self, ud):
 35990:         ud.decl.special = 0
 35990:         newcomponents = [ ]
 35990:         for ctype in ud.decl.type.components:
 35990:             if _hasVisibleActor(ctype):
 35990:                 ud.decl.special = 1
 35990:                 # if ctype has a visible actor, we need both
 35990:                 # |ActorParent| and |ActorChild| union members
 35990:                 newcomponents.append(_UnionMember(ctype, ud, side='parent'))
 35990:                 newcomponents.append(_UnionMember(ctype, ud, side='child'))
 35990:             else:
 35990:                 newcomponents.append(_UnionMember(ctype, ud))
 35990:         ud.components = newcomponents
 35990:         UnionDecl.upgrade(ud)
 35990: 
 35990:         if ud.decl.fullname is not None:
101616:             self.typedefSet.add(Typedef(Type(ud.fqClassName()), ud.name))
 35990: 
 35990: 
 35990:     def visitDecl(self, decl):
 35990:         return _HybridDecl(decl.type, decl.progname)
 35990: 
 35990:     def visitMessageDecl(self, md):
 35990:         md.namespace = self.protocolName
 35990:         md.params = [ param.accept(self) for param in md.inParams ]
 35990:         md.returns = [ ret.accept(self) for ret in md.outParams ]
 35990:         MessageDecl.upgrade(md)
 35990: 
 35990:     def visitTransitionStmt(self, ts):
 47709:         name = ts.state.decl.progname
 47709:         ts.state.decl.cxxname = name
 47709:         ts.state.decl.cxxenum = ExprVar(self.protocolName +'::'+ name)
 35990: 
 35990: ##-----------------------------------------------------------------------------
 35990: 
 71234: class _GenerateProtocolCode(ipdl.ast.Visitor):
 71234:     '''Creates code common to both the parent and child actors.'''
 35990:     def __init__(self):
 35990:         self.protocol = None     # protocol we're generating a class for
 71234:         self.hdrfile = None      # what will become Protocol.h
 71234:         self.cppfile = None      # what will become Protocol.cpp
 71247:         self.cppIncludeHeaders = []
 42566:         self.structUnionDefns = []
 71234:         self.funcDefns = []
 71234: 
 71234:     def lower(self, tu, cxxHeaderFile, cxxFile):
 35990:         self.protocol = tu.protocol
 71234:         self.hdrfile = cxxHeaderFile
 71234:         self.cppfile = cxxFile
 35742:         tu.accept(self)
 35742: 
 35742:     def visitTranslationUnit(self, tu):
 71234:         hf = self.hdrfile
 71234: 
 71234:         hf.addthing(_DISCLAIMER)
 71234:         hf.addthings(_includeGuardStart(hf))
 71234:         hf.addthing(Whitespace.NL)
 35990: 
 35990:         ipdl.ast.Visitor.visitTranslationUnit(self, tu)
101616:         if tu.filetype == 'header':
101616:             self.cppIncludeHeaders.append(_ipdlhHeaderName(tu))
 35990: 
 71234:         hf.addthing(Whitespace.NL)
 71234:         hf.addthings(_includeGuardEnd(hf))
 71234: 
 71234:         cf = self.cppfile
 71247:         cf.addthings((
 71247:             [ _DISCLAIMER, Whitespace.NL ]
 71247:             + [ CppDirective('include','"'+h+'.h"')
 71247:                 for h in self.cppIncludeHeaders ]
 71247:             + [ Whitespace.NL ]
 71247:         ))
 71234: 
101616:         if self.protocol:       
 71234:             # construct the namespace into which we'll stick all our defns
 71234:             ns = Namespace(self.protocol.name)
 71234:             cf.addthing(_putInNamespaces(ns, self.protocol.namespaces))
 71234:             ns.addstmts(([ Whitespace.NL]
 71234:                          + self.funcDefns
 71234:                          +[ Whitespace.NL ]))
101616: 
 71234:         cf.addthings(self.structUnionDefns)
 35742: 
 35742: 
 35742:     def visitCxxInclude(self, inc):
 71234:         self.hdrfile.addthing(CppDirective('include', '"'+ inc.file +'"'))
 35742: 
101616:     def visitInclude(self, inc):
101616:         if inc.tu.filetype == 'header':
101616:             self.hdrfile.addthing(CppDirective(
101616:                     'include', '"'+ _ipdlhHeaderName(inc.tu) +'.h"'))
101616: 
 42566:     def processStructOrUnionClass(self, su, which, forwarddecls, cls):
 71234:         clsdecl, methoddefns = _splitClassDeclDefn(cls)
 71234:         
 71234:         self.hdrfile.addthings(
 42566:             [  Whitespace.NL ]
 42566:             + forwarddecls
 42566:             + [ Whitespace("""
 42566: //-----------------------------------------------------------------------------
 42566: // Declaration of the IPDL type |%s %s|
 42566: //
 42566: """% (which, su.name)),
 42566:                 _putInNamespaces(clsdecl, su.namespaces),
 42566:             ])
 42566: 
 42566:         self.structUnionDefns.extend([
 42566:             Whitespace("""
 42566: //-----------------------------------------------------------------------------
 42566: // Method definitions for the IPDL type |%s %s|
 42566: //
 42566: """% (which, su.name)),
 42566:             _putInNamespaces(methoddefns, su.namespaces),
 42566:         ])
 42566: 
 42564:     def visitStructDecl(self, sd):
 42566:         return self.processStructOrUnionClass(sd, 'struct',
 42566:                                               *_generateCxxStruct(sd))
 42564: 
 35900:     def visitUnionDecl(self, ud):
 42566:         return self.processStructOrUnionClass(ud, 'union',
 42566:                                               *_generateCxxUnion(ud))
 35990: 
 35990:     def visitProtocol(self, p):
 71247:         self.cppIncludeHeaders.append(_protocolHeaderName(self.protocol, ''))
 71247:         bridges = ProcessGraph.bridgesOf(p.decl.type)
 71247:         for bridge in bridges:
 71247:             ppt, pside = bridge.parent.ptype, _otherSide(bridge.parent.side)
 71247:             cpt, cside = bridge.child.ptype, _otherSide(bridge.child.side)
 71247:             self.hdrfile.addthings([
 71247:                 Whitespace.NL,
 71247:                 _makeForwardDeclForActor(ppt, pside),
 71247:                 _makeForwardDeclForActor(cpt, cside)
 71247:             ])
101616:             self.cppIncludeHeaders.append(_protocolHeaderName(ppt._ast, pside))
101616:             self.cppIncludeHeaders.append(_protocolHeaderName(cpt._ast, cside))
 71247: 
 71253:         opens = ProcessGraph.opensOf(p.decl.type)
 71253:         for o in opens:
 71253:             optype, oside = o.opener.ptype, o.opener.side
 71253:             self.hdrfile.addthings([
 71253:                 Whitespace.NL,
 71253:                 _makeForwardDeclForActor(optype, oside)
 71253:             ])
101616:             self.cppIncludeHeaders.append(_protocolHeaderName(optype._ast, oside))
 71253: 
 71234:         self.hdrfile.addthing(Whitespace("""
 35990: //-----------------------------------------------------------------------------
 35990: // Code common to %sChild and %sParent
 35990: //
 35990: """% (p.name, p.name)))
 35990: 
 35990:         # construct the namespace into which we'll stick all our decls
 35990:         ns = Namespace(self.protocol.name)
 71234:         self.hdrfile.addthing(_putInNamespaces(ns, p.namespaces))
 35990:         ns.addstmt(Whitespace.NL)
 35990: 
 71247:         # user-facing methods for connecting two process with a new channel
 71247:         for bridge in bridges:
 71247:             bdecl, bdefn = _splitFuncDeclDefn(self.genBridgeFunc(bridge))
 71247:             ns.addstmts([ bdecl, Whitespace.NL ])
 71247:             self.funcDefns.append(bdefn)
 71247: 
 71253:         # user-facing methods for opening a new channel across two
 71253:         # existing endpoints
 71253:         for o in opens:
 71253:             odecl, odefn = _splitFuncDeclDefn(self.genOpenFunc(o))
 71253:             ns.addstmts([ odecl, Whitespace.NL ])
 71253:             self.funcDefns.append(odefn)
 71253: 
 35990:         # state information
 35990:         stateenum = TypeEnum('State')
 47709:         # NB: __Dead is the first state on purpose, so that it has
 47709:         # value '0'
 47709:         stateenum.addId(_deadState().name)
 47709:         stateenum.addId(_nullState().name)
 47709:         stateenum.addId(_errorState().name)
104602:         stateenum.addId(_dyingState().name)
 35990:         for ts in p.transitionStmts:
 47709:             stateenum.addId(ts.state.decl.cxxname)
 35990:         if len(p.transitionStmts):
 47709:             startstate = p.transitionStmts[0].state.decl.cxxname
 35990:         else:
 47709:             startstate = _nullState().name
 47709:         stateenum.addId(_startState().name, startstate)
 35990: 
 35990:         ns.addstmts([ StmtDecl(Decl(stateenum,'')), Whitespace.NL ])
 35990: 
 35990:         # spit out message type enum and classes
 35990:         msgenum = TypeEnum('MessageType')
 56382:         msgstart = _messageStartName(self.protocol.decl.type) +' << 16'
 35990:         msgenum.addId(self.protocol.name + 'Start', msgstart)
 35990:         msgenum.addId(self.protocol.name +'PreStart', '('+ msgstart +') - 1')
 35990: 
 35990:         for md in p.messageDecls:
 35990:             msgenum.addId(md.msgId())
 35990:             if md.hasReply():
 35990:                 msgenum.addId(md.replyId())
 35990: 
 35990:         msgenum.addId(self.protocol.name +'End')
 35990:         ns.addstmts([ StmtDecl(Decl(msgenum, '')), Whitespace.NL ])
 35990: 
 71234:         tfDecl, tfDefn = _splitFuncDeclDefn(self.genTransitionFunc())
 71234:         ns.addstmts([ tfDecl, Whitespace.NL ])
 71234:         self.funcDefns.append(tfDefn)
 47710: 
 35990:         typedefs = self.protocol.decl.cxxtypedefs
 35990:         for md in p.messageDecls:
 35990:             ns.addstmts([
 35990:                 _generateMessageClass(md.msgClass(), md.msgId(),
 42563:                                       typedefs, md.prettyMsgName(p.name+'::')),
 35990:                 Whitespace.NL ])
 35990:             if md.hasReply():
 35990:                 ns.addstmts([
 35990:                     _generateMessageClass(
 42563:                         md.replyClass(), md.replyId(),
 39613:                         typedefs, md.prettyReplyName(p.name+'::')),
 35990:                     Whitespace.NL ])
 35990: 
 35990:         ns.addstmts([ Whitespace.NL, Whitespace.NL ])
 35990: 
 47710: 
 71247:     def genBridgeFunc(self, bridge):
 71247:         p = self.protocol
 71247:         parentHandleType = _cxxBareType(ActorType(bridge.parent.ptype),
101732:                                         _otherSide(bridge.parent.side),
101732:                                         fq=1)
 71247:         parentvar = ExprVar('parentHandle')
 71247: 
 71247:         childHandleType = _cxxBareType(ActorType(bridge.child.ptype),
101732:                                        _otherSide(bridge.child.side),
101732:                                        fq=1)
 71247:         childvar = ExprVar('childHandle')
 71247: 
 71247:         bridgefunc = MethodDefn(MethodDecl(
 71247:             'Bridge',
 71247:             params=[ Decl(parentHandleType, parentvar.name),
 71247:                      Decl(childHandleType, childvar.name) ],
 71247:             ret=Type.BOOL))
 71247:         bridgefunc.addstmt(StmtReturn(ExprCall(
 71247:             ExprVar('mozilla::ipc::Bridge'),
 71247:             args=[ _backstagePass(),
 71247:                    p.callGetChannel(parentvar), p.callOtherProcess(parentvar),
 71247:                    p.callGetChannel(childvar), p.callOtherProcess(childvar),
 71247:                    _protocolId(p.decl.type)
 71247:                    ])))
 71247:         return bridgefunc
 71247: 
 71247: 
 71253:     def genOpenFunc(self, o):
 71253:         p = self.protocol
 71253:         localside = o.opener.side
101732:         openertype = _cxxBareType(ActorType(o.opener.ptype), o.opener.side,
101732:                                   fq=1)
 71253:         openervar = ExprVar('opener')
 71253:         openfunc = MethodDefn(MethodDecl(
 71253:             'Open',
 71253:             params=[ Decl(openertype, openervar.name) ],
 71253:             ret=Type.BOOL))
 71253:         openfunc.addstmt(StmtReturn(ExprCall(
 71253:             ExprVar('mozilla::ipc::Open'),
 71253:             args=[ _backstagePass(),
 71253:                    p.callGetChannel(openervar), p.callOtherProcess(openervar),
 71253:                    _sideToTransportMode(localside),
 71253:                    _protocolId(p.decl.type)
 71253:                    ])))
 71253:         return openfunc
 71253: 
 71253: 
 47710:     def genTransitionFunc(self):
 47710:         ptype = self.protocol.decl.type
 47710:         usesend, sendvar = set(), ExprVar('__Send')
 47710:         userecv, recvvar = set(), ExprVar('__Recv')
 47710:         
 47710:         def sameTrigger(trigger, actionexpr):
 47710:             if trigger is ipdl.ast.SEND or trigger is ipdl.ast.CALL:
 47710:                 usesend.add('yes')
 47710:                 return ExprBinary(sendvar, '==', actionexpr)
 47710:             else:
 47710:                 userecv.add('yes')
 47710:                 return ExprBinary(recvvar, '==',
 47710:                                   actionexpr)
 47710: 
 47710:         def stateEnum(s):
 47710:             if s is ipdl.ast.State.DEAD:
 47710:                 return _deadState()
 47710:             else:
 47710:                 return ExprVar(s.decl.cxxname)
 47710: 
 47710:         # bool Transition(State from, Trigger trigger, State* next)
 47710:         fromvar = ExprVar('from')
 47710:         triggervar = ExprVar('trigger')
 47710:         nextvar = ExprVar('next')
 47710:         msgexpr = ExprSelect(triggervar, '.', 'mMsg')
 47710:         actionexpr = ExprSelect(triggervar, '.', 'mAction')
 47710: 
 71234:         transitionfunc = FunctionDefn(FunctionDecl(
 47710:             'Transition',
 47710:             params=[ Decl(Type('State'), fromvar.name),
 47710:                      Decl(Type('mozilla::ipc::Trigger'), triggervar.name),
 47710:                      Decl(Type('State', ptr=1), nextvar.name) ],
 71234:             ret=Type.BOOL))
 47710: 
 47710:         fromswitch = StmtSwitch(fromvar)
 47710: 
 47710:         for ts in self.protocol.transitionStmts:
 47710:             msgswitch = StmtSwitch(msgexpr)
 47710: 
 47710:             msgToTransitions = { }
 47710: 
 47710:             for t in ts.transitions:
 47710:                 msgid = t.msg._md.msgId()
 47710: 
 47710:                 ifsametrigger = StmtIf(sameTrigger(t.trigger, actionexpr))
 47710:                 # FIXME multi-out states
 47710:                 for nextstate in t.toStates: break
 47710:                 ifsametrigger.addifstmts([
 47710:                     StmtExpr(ExprAssn(ExprDeref(nextvar),
 47710:                                       stateEnum(nextstate))),
 47710:                     StmtReturn(ExprLiteral.TRUE)
 47710:                 ])
 47710: 
 47710:                 transitions = msgToTransitions.get(msgid, [ ])
 47710:                 transitions.append(ifsametrigger)
 47710:                 msgToTransitions[msgid] = transitions
 47710: 
 47710:             for msgid, transitions in msgToTransitions.iteritems():
 47710:                 block = Block()
 47710:                 block.addstmts(transitions +[ StmtBreak() ])
 47710:                 msgswitch.addcase(CaseLabel(msgid), block)
 47710: 
 47710:             msgblock = Block()
 47710:             msgblock.addstmts([
 47710:                 msgswitch,
 47710:                 StmtBreak()
 47710:             ])
 47710:             fromswitch.addcase(CaseLabel(ts.state.decl.cxxname), msgblock)
 47710: 
 47710:         # special cases for Null and Error
 47710:         nullerrorblock = Block()
 47710:         if ptype.hasDelete:
 47710:             ifdelete = StmtIf(ExprBinary(_deleteId(), '==', msgexpr))
104602:             if ptype.hasReentrantDelete:
104602:                 nextState = _dyingState()
104602:             else:
104602:                 nextState = _deadState()
 47710:             ifdelete.addifstmts([
104602:                 StmtExpr(ExprAssn(ExprDeref(nextvar), nextState)),
 47710:                 StmtReturn(ExprLiteral.TRUE) ])
 47710:             nullerrorblock.addstmt(ifdelete)
 47710:         nullerrorblock.addstmt(
 47710:             StmtReturn(ExprBinary(_nullState(), '==', fromvar)))
 47710:         fromswitch.addfallthrough(CaseLabel(_nullState().name))
 47710:         fromswitch.addcase(CaseLabel(_errorState().name), nullerrorblock)
 47710: 
 47710:         # special case for Dead
 47710:         deadblock = Block()
 47710:         deadblock.addstmts([
 47710:             _runtimeAbort('__delete__()d actor'),
 47710:             StmtReturn(ExprLiteral.FALSE) ])
 47710:         fromswitch.addcase(CaseLabel(_deadState().name), deadblock)
 47710: 
104602:         # special case for Dying
104602:         dyingblock = Block()
104602:         if ptype.hasReentrantDelete:
104602:             ifdelete = StmtIf(ExprBinary(_deleteReplyId(), '==', msgexpr))
104602:             ifdelete.addifstmt(
104602:                 StmtExpr(ExprAssn(ExprDeref(nextvar), _deadState())))
104602:             dyingblock.addstmt(ifdelete)
104602:             dyingblock.addstmt(
104602:                 StmtReturn(ExprLiteral.TRUE))
104602:         else:
104602:             dyingblock.addstmts([
104602:                 _runtimeAbort('__delete__()d (and unexpectedly dying) actor'),
104602:                 StmtReturn(ExprLiteral.FALSE) ])
104602:         fromswitch.addcase(CaseLabel(_dyingState().name), dyingblock)
104602: 
 47710:         unreachedblock = Block()
 47710:         unreachedblock.addstmts([
 47710:             _runtimeAbort('corrupted actor state'),
 47710:             StmtReturn(ExprLiteral.FALSE) ])
 47710:         fromswitch.addcase(DefaultLabel(), unreachedblock)
 47710: 
 47710:         if usesend:
 47710:             transitionfunc.addstmt(
 47710:                 StmtDecl(Decl(Type('int32', const=1), sendvar.name),
 47710:                          init=ExprVar('mozilla::ipc::Trigger::Send')))
 47710:         if userecv:
 47710:             transitionfunc.addstmt(
 47710:                 StmtDecl(Decl(Type('int32', const=1), recvvar.name),
 47710:                          init=ExprVar('mozilla::ipc::Trigger::Recv')))
 47710:         if usesend or userecv:
 47710:             transitionfunc.addstmt(Whitespace.NL)
 47710: 
 47710:         transitionfunc.addstmts([
 47710:             fromswitch,
 47710:             # all --> Error transitions break to here
 47710:             StmtExpr(ExprAssn(ExprDeref(nextvar), _errorState())),
 47710:             StmtReturn(ExprLiteral.FALSE)
 47710:         ])
 47710:         return transitionfunc
 47710: 
 35990: ##--------------------------------------------------
 35990: 
 42563: def _generateMessageClass(clsname, msgid, typedefs, prettyName):
 35990:     cls = Class(name=clsname, inherits=[ Inherit(Type('IPC::Message')) ])
 35990:     cls.addstmt(Label.PRIVATE)
 35990:     cls.addstmts(typedefs)
 35990:     cls.addstmt(Whitespace.NL)
 35990: 
 35990:     cls.addstmt(Label.PUBLIC)
 35990: 
 35990:     idenum = TypeEnum()
 35990:     idenum.addId('ID', msgid)
 35990:     cls.addstmt(StmtDecl(Decl(idenum, '')))
 35990: 
 42563:     # make the message constructor
 35990:     ctor = ConstructorDefn(
 42563:         ConstructorDecl(clsname),
 35990:         memberinits=[ ExprMemberInit(ExprVar('IPC::Message'),
 35990:                                      [ ExprVar('MSG_ROUTING_NONE'),
 35990:                                        ExprVar('ID'),
 39613:                                        ExprVar('PRIORITY_NORMAL'),
 39613:                                        ExprLiteral.String(prettyName) ]) ])
 35990:     cls.addstmts([ ctor, Whitespace.NL ])
 35990: 
 35990:     # generate a logging function
 35990:     # 'pfx' will be something like "[FooParent] sent"
 35990:     pfxvar = ExprVar('__pfx')
 35990:     outfvar = ExprVar('__outf')
 35990:     logger = MethodDefn(MethodDecl(
 35990:         'Log',
 35990:         params=([ Decl(Type('std::string', const=1, ref=1), pfxvar.name),
 35990:                   Decl(Type('FILE', ptr=True), outfvar.name) ]),
 35990:         const=1))
 35990:     # TODO/cjones: allow selecting what information is printed to 
 35990:     # the log
 35990:     msgvar = ExprVar('__logmsg')
 35990:     logger.addstmt(StmtDecl(Decl(Type('std::string'), msgvar.name)))
 35990: 
 35990:     def appendToMsg(thing):
 35990:         return StmtExpr(ExprCall(ExprSelect(msgvar, '.', 'append'),
 35990:                                  args=[ thing ]))
 35990:     logger.addstmts([
 35990:         StmtExpr(ExprCall(
 35990:             ExprVar('StringAppendF'),
 35990:             args=[ ExprAddrOf(msgvar),
 35990:                    ExprLiteral.String('[time:%" PRId64 "]'),
 35990:                    ExprCall(ExprVar('PR_Now')) ])),
 35990:         appendToMsg(pfxvar),
 35990:         appendToMsg(ExprLiteral.String(clsname +'(')),
 35990:         Whitespace.NL
 35990:     ])
 35990: 
 35990:     # TODO turn this back on when string stuff is sorted
 35990: 
 42563:     logger.addstmt(appendToMsg(ExprLiteral.String('[TODO])\\n')))
 35990: 
 35990:     # and actually print the log message
 35990:     logger.addstmt(StmtExpr(ExprCall(
 35990:         ExprVar('fputs'),
 35990:         args=[ ExprCall(ExprSelect(msgvar, '.', 'c_str')), outfvar ])))
 35990: 
 35990:     cls.addstmt(logger)
 35990: 
 35990:     return cls
 35990: 
 35990: ##--------------------------------------------------
 35990: 
 42564: class _ComputeTypeDeps(TypeVisitor):
 42564:     '''Pass that gathers the C++ types that a particular IPDL type
 42564: (recursively) depends on.  There are two kinds of dependencies: (i)
 42564: types that need forward declaration; (ii) types that need a |using|
 42564: stmt.  Some types generate both kinds.'''
 42564: 
 42566:     def __init__(self, fortype):
 42566:         ipdl.type.TypeVisitor.__init__(self)
 42564:         self.usingTypedefs = [ ]
 42564:         self.forwardDeclStmts = [ ]
 42566:         self.fortype = fortype
 42564: 
 42564:     def maybeTypedef(self, fqname, name):
 42564:         if fqname != name:
 42564:             self.usingTypedefs.append(Typedef(Type(fqname), name))
 42564:         
 42564:     def visitBuiltinCxxType(self, t):
 42566:         if t in self.visited: return
 42566:         self.visited.add(t)
 42564:         self.maybeTypedef(t.fullname(), t.name())
 42564: 
 42564:     def visitImportedCxxType(self, t):
 42566:         if t in self.visited: return
 42566:         self.visited.add(t)
 42564:         self.maybeTypedef(t.fullname(), t.name())
 42564: 
 42564:     def visitActorType(self, t):
 42566:         if t in self.visited: return
 42566:         self.visited.add(t)
 42564: 
 42564:         fqname, name = t.fullname(), t.name()
 42564: 
 42564:         self.maybeTypedef(_actorName(fqname, 'Parent'),
 42564:                           _actorName(name, 'Parent'))
 42564:         self.maybeTypedef(_actorName(fqname, 'Child'),
 42564:                           _actorName(name, 'Child'))
 42564: 
 42564:         self.forwardDeclStmts.extend([
 42566:             _makeForwardDeclForActor(t.protocol, 'parent'), Whitespace.NL,
 42566:             _makeForwardDeclForActor(t.protocol, 'child'), Whitespace.NL
 42564:         ])
 42564: 
 42564:     def visitStructOrUnionType(self, su, defaultVisit):
 42566:         if su in self.visited or su == self.fortype: return
 42566:         self.visited.add(su)
 42564:         self.maybeTypedef(su.fullname(), su.name())
 42564: 
 42566:         if su.mutuallyRecursiveWith(self.fortype):
 42566:             self.forwardDeclStmts.append(_makeForwardDecl(su))
 42566: 
 42564:         return defaultVisit(self, su)
 42564: 
 42564:     def visitStructType(self, t):
 42564:         return self.visitStructOrUnionType(t, TypeVisitor.visitStructType)
 42564: 
 42564:     def visitUnionType(self, t):
 42564:         return self.visitStructOrUnionType(t, TypeVisitor.visitUnionType)
 42564: 
 42564:     def visitArrayType(self, t):
 42564:         return TypeVisitor.visitArrayType(self, t)
 42564: 
 44201:     def visitShmemType(self, s):
 44201:         if s in self.visited: return
 44201:         self.visited.add(s)
101616:         self.maybeTypedef('mozilla::ipc::Shmem', 'Shmem')
 44201: 
 42564:     def visitVoidType(self, v): assert 0
 42564:     def visitMessageType(self, v): assert 0
 42564:     def visitProtocolType(self, v): assert 0
 42564:     def visitStateType(self, v): assert 0
 42564: 
 42564: 
 42564: def _generateCxxStruct(sd):
 42564:     ''' '''
 42564:     # compute all the typedefs and forward decls we need to make
 42566:     gettypedeps = _ComputeTypeDeps(sd.decl.type)
 42564:     for f in sd.fields:
 42564:         f.ipdltype.accept(gettypedeps)
 42564: 
 42564:     usingTypedefs = gettypedeps.usingTypedefs
 42564:     forwarddeclstmts = gettypedeps.forwardDeclStmts
 42564: 
 57217:     struct = Class(sd.name, final=1)
 42566:     struct.addstmts([ Label.PRIVATE ]
 42564:                     + usingTypedefs
 42566:                     + [ Whitespace.NL, Label.PUBLIC ])
 42566: 
 42566:     constreftype = Type(sd.name, const=1, ref=1)
 42566:     initvar = ExprVar('Init')
 42566:     callinit = ExprCall(initvar)
 42566:     assignvar = ExprVar('Assign')
 42566: 
 42566:     def fieldsAsParamList():
 42566:         return [ Decl(f.inType(), f.argVar().name) for f in sd.fields ]
 42566: 
 42566:     def assignFromOther(oexpr):
 42566:         return ExprCall(assignvar,
 42566:                         args=[ f.initExpr(oexpr) for f in sd.fields ])
 42566: 
 99833:     # If this is an empty struct (no fields), then the default ctor
 99833:     # and "create-with-fields" ctors are equivalent.  So don't bother
 99833:     # with the default ctor.
 99833:     if len(sd.fields):
 42566:         # Struct()
 42566:         defctor = ConstructorDefn(ConstructorDecl(sd.name))
 42566:         defctor.addstmt(StmtExpr(callinit))
 42566:         struct.addstmts([ defctor, Whitespace.NL ])
 42566: 
 42566:     # Struct(const field1& _f1, ...)
 42566:     valctor = ConstructorDefn(ConstructorDecl(sd.name,
 42566:                                               params=fieldsAsParamList(),
 42566:                                               force_inline=1))
 42566:     valctor.addstmts([
 42566:         StmtExpr(callinit),
 42566:         StmtExpr(ExprCall(assignvar,
 42566:                           args=[ f.argVar() for f in sd.fields ]))
 42566:     ])
 42566:     struct.addstmts([ valctor, Whitespace.NL ])
 42566: 
 42566:     # Struct(const Struct& _o)
 42566:     ovar = ExprVar('_o')
 42566:     copyctor = ConstructorDefn(ConstructorDecl(
 42564:         sd.name,
 42566:         params=[ Decl(constreftype, ovar.name) ],
 42566:         force_inline=1))
 42566:     copyctor.addstmts([
 42566:         StmtExpr(callinit),
 42566:         StmtExpr(assignFromOther(ovar))
 42566:     ])
 42566:     struct.addstmts([ copyctor, Whitespace.NL ])
 42566: 
 42566:     # ~Struct()
 42566:     dtor = DestructorDefn(DestructorDecl(sd.name))
 42566:     for f in sd.fields:
 42566:         dtor.addstmts(f.destructStmts())
 42566:     struct.addstmts([ dtor, Whitespace.NL ])
 42566: 
 42566:     # Struct& operator=(const Struct& _o)
 42566:     opeq = MethodDefn(MethodDecl(
 42566:         'operator=',
 42566:         params=[ Decl(constreftype, ovar.name) ],
 42566:         force_inline=1))
 42566:     opeq.addstmt(StmtExpr(assignFromOther(ovar)))
 42566:     struct.addstmts([ opeq, Whitespace.NL ])
 42566: 
 42569:     # bool operator==(const Struct& _o)
 42569:     opeqeq = MethodDefn(MethodDecl(
 42569:         'operator==',
 42569:         params=[ Decl(constreftype, ovar.name) ],
 42569:         ret=Type.BOOL,
 42569:         const=1))
 42569:     for f in sd.fields:
 42569:         ifneq = StmtIf(ExprNot(
 42569:             ExprBinary(ExprCall(f.getMethod()), '==',
 42569:                        ExprCall(f.getMethod(ovar)))))
 42569:         ifneq.addifstmt(StmtReturn.FALSE)
 42569:         opeqeq.addstmt(ifneq)
 42569:     opeqeq.addstmt(StmtReturn.TRUE)
 42569:     struct.addstmts([ opeqeq, Whitespace.NL ])
 42569: 
 42566:     # field1& f1()
 42566:     # const field1& f1() const
 42566:     for f in sd.fields:
 42566:         get = MethodDefn(MethodDecl(f.getMethod().name,
 42566:                                     params=[ ],
 42566:                                     ret=f.refType(),
 42566:                                     force_inline=1))
 42566:         get.addstmt(StmtReturn(f.refExpr()))
 42566: 
 44201:         getconstdecl = deepcopy(get.decl)
 44201:         getconstdecl.ret = f.constRefType()
 44201:         getconstdecl.const = 1
 44201:         getconst = MethodDefn(getconstdecl)
 44201:         getconst.addstmt(StmtReturn(f.constRefExpr()))
 42566: 
 42566:         struct.addstmts([ get, getconst, Whitespace.NL ])
 42566: 
 42566:     # private:
 42566:     struct.addstmt(Label.PRIVATE)
 42566: 
 42566:     # Init()
 42566:     init = MethodDefn(MethodDecl(initvar.name))
 42566:     for f in sd.fields:
 42566:         init.addstmts(f.initStmts())
 42566:     struct.addstmts([ init, Whitespace.NL ])
 42566: 
 42566:     # Assign(const field1& _f1, ...)
 42566:     assign = MethodDefn(MethodDecl(assignvar.name,
 42566:                                    params=fieldsAsParamList()))
 42566:     assign.addstmts([ StmtExpr(ExprAssn(f.refExpr(), f.argVar()))
 42566:                       for f in sd.fields ])
 42566:     struct.addstmts([ assign, Whitespace.NL ])
 42566: 
 42566:     # members
 42566:     struct.addstmts([ StmtDecl(Decl(f.internalType(), f.memberVar().name))
 42566:                       for f in sd.fields ])
 42566: 
 42566:     return forwarddeclstmts, struct
 42564: 
 42564: ##--------------------------------------------------
 42564: 
 42566: def _generateCxxUnion(ud):
 35990:     # This Union class basically consists of a type (enum) and a
 35990:     # union for storage.  The union can contain POD and non-POD
 35990:     # types.  Each type needs a copy ctor, assignment operator,
 35990:     # and dtor.
 35900:     #
 35900:     # Rather than templating this class and only providing
 35900:     # specializations for the types we support, which is slightly
 35990:     # "unsafe" in that C++ code can add additional specializations
 35990:     # without the IPDL compiler's knowledge, we instead explicitly
 35990:     # implement non-templated methods for each supported type.
 35900:     #
 35990:     # The one complication that arises is that C++, for arcane
 35900:     # reasons, does not allow the placement destructor of a
 35900:     # builtin type, like int, to be directly invoked.  So we need
 35900:     # to hack around this by internally typedef'ing all
 35900:     # constituent types.  Sigh.
 35900:     #
 35900:     # So, for each type, this "Union" class needs:
 35900:     # (private)
 35900:     #  - entry in the type enum
 35900:     #  - entry in the storage union
 35900:     #  - [type]ptr() method to get a type* from the underlying union
 35900:     #  - same as above to get a const type*
 35900:     #  - typedef to hack around placement delete limitations
 35900:     # (public)
 35900:     #  - placement delete case for dtor
 35900:     #  - copy ctor
 35900:     #  - case in generic copy ctor
 35900:     #  - operator= impl
 35900:     #  - case in generic operator=
 35900:     #  - operator [type&]
 35900:     #  - operator [const type&] const
 35900:     #  - [type&] get_[type]()
 35900:     #  - [const type&] get_[type]() const
 35900:     #
 35990:     cls = Class(ud.name, final=1)
 35990:     # const Union&, i.e., Union type with inparam semantics
 35990:     inClsType = Type(ud.name, const=1, ref=1)
 35990:     refClsType = Type(ud.name, ref=1)
 35990:     typetype = Type('Type')
 35990:     valuetype = Type('Value')
 35990:     mtypevar = ExprVar('mType')
 35990:     mvaluevar = ExprVar('mValue')
 35990:     maybedtorvar = ExprVar('MaybeDestroy')
 35990:     assertsanityvar = ExprVar('AssertSanity')
 35990:     tnonevar = ExprVar('T__None')
 35990:     tlastvar = ExprVar('T__Last')
 35990: 
 35990:     def callAssertSanity(uvar=None, expectTypeVar=None):
 35990:         func = assertsanityvar
 35990:         args = [ ]
 35990:         if uvar is not None:
 35990:             func = ExprSelect(uvar, '.', assertsanityvar.name)
 35990:         if expectTypeVar is not None:
 35990:             args.append(expectTypeVar)
 35990:         return ExprCall(func, args=args)
 35990: 
 35990:     def callMaybeDestroy(newTypeVar):
 35990:         return ExprCall(maybedtorvar, args=[ newTypeVar ])
 35990: 
 35990:     def maybeReconstruct(memb, newTypeVar):
 35990:         ifdied = StmtIf(callMaybeDestroy(newTypeVar))
 42566:         ifdied.addifstmt(StmtExpr(memb.callCtor()))
 35990:         return ifdied
 35990: 
 35990:     # compute all the typedefs and forward decls we need to make
 42566:     gettypedeps = _ComputeTypeDeps(ud.decl.type)
 35990:     for c in ud.components:
 35990:         c.ipdltype.accept(gettypedeps)
 35990: 
 42564:     usingTypedefs = gettypedeps.usingTypedefs
 42564:     forwarddeclstmts = gettypedeps.forwardDeclStmts
 35990: 
 35990:     # the |Type| enum, used to switch on the discunion's real type
 35990:     cls.addstmt(Label.PUBLIC)
 35990:     typeenum = TypeEnum(typetype.name)
 35990:     typeenum.addId(tnonevar.name, 0)
 35990:     firstid = ud.components[0].enum()
 35990:     typeenum.addId(firstid, 1)
 35990:     for c in ud.components[1:]:
 35990:         typeenum.addId(c.enum())
 35990:     typeenum.addId(tlastvar.name, ud.components[-1].enum())
 35990:     cls.addstmts([ StmtDecl(Decl(typeenum,'')),
 35990:                    Whitespace.NL ])
 35990: 
 35990:     cls.addstmt(Label.PRIVATE)
 35990:     cls.addstmts(
 35990:         usingTypedefs
 35990:         # hacky typedef's that allow placement dtors of builtins
 42566:         + [ Typedef(c.internalType(), c.typedef()) for c in ud.components ])
 35990:     cls.addstmt(Whitespace.NL)
 35990: 
 35990:     # the C++ union the discunion use for storage
 35990:     valueunion = TypeUnion(valuetype.name)
 35990:     for c in ud.components:
 35990:         valueunion.addComponent(c.unionType(), c.name)
 35990:     cls.addstmts([ StmtDecl(Decl(valueunion,'')),
 35990:                        Whitespace.NL ])
 35990: 
 35990:     # for each constituent type T, add private accessors that
 35990:     # return a pointer to the Value union storage casted to |T*|
 35990:     # and |const T*|
 35990:     for c in ud.components:
 35990:         getptr = MethodDefn(MethodDecl(
 42566:             c.getPtrName(), params=[ ], ret=c.ptrToInternalType(),
 42566:             force_inline=1))
 35990:         getptr.addstmt(StmtReturn(c.ptrToSelfExpr()))
 35990: 
 35990:         getptrconst = MethodDefn(MethodDecl(
 42566:             c.getConstPtrName(), params=[ ], ret=c.constPtrToType(),
 42566:             const=1, force_inline=1))
 35990:         getptrconst.addstmt(StmtReturn(c.constptrToSelfExpr()))
 35990: 
 35990:         cls.addstmts([ getptr, getptrconst ])
 35990:     cls.addstmt(Whitespace.NL)
 35990: 
 35990:     # add a helper method that invokes the placement dtor on the
 35990:     # current underlying value, only if |aNewType| is different
 35990:     # than the current type, and returns true if the underlying
 35990:     # value needs to be re-constructed
 35990:     newtypevar = ExprVar('aNewType')
 35990:     maybedtor = MethodDefn(MethodDecl(
 35990:         maybedtorvar.name,
 35990:         params=[ Decl(typetype, newtypevar.name) ],
 35990:         ret=Type.BOOL))
 35990:     # wasn't /actually/ dtor'd, but it needs to be re-constructed
 35990:     ifnone = StmtIf(ExprBinary(mtypevar, '==', tnonevar))
 42569:     ifnone.addifstmt(StmtReturn.TRUE)
 35990:     # same type, nothing to see here
 35990:     ifnochange = StmtIf(ExprBinary(mtypevar, '==', newtypevar))
 42569:     ifnochange.addifstmt(StmtReturn.FALSE)
 35990:     # need to destroy.  switch on underlying type
 35990:     dtorswitch = StmtSwitch(mtypevar)
 35990:     for c in ud.components:
 35990:         dtorswitch.addcase(
 35990:             CaseLabel(c.enum()),
 42566:             StmtBlock([ StmtExpr(c.callDtor()),
 35990:                         StmtBreak() ]))
 35990:     dtorswitch.addcase(
 35990:         DefaultLabel(),
 35990:         StmtBlock([ _runtimeAbort("not reached"), StmtBreak() ]))
 35990:     maybedtor.addstmts([
 35990:         ifnone,
 35990:         ifnochange,
 35990:         dtorswitch,
 42569:         StmtReturn.TRUE
 35990:     ])
 35990:     cls.addstmts([ maybedtor, Whitespace.NL ])
 35990: 
 35990:     # add helper methods that ensure the discunion has a
 35990:     # valid type
 35990:     sanity = MethodDefn(MethodDecl(
 42566:         assertsanityvar.name, ret=Type.VOID, const=1, force_inline=1))
 35990:     sanity.addstmts([
 43020:         _abortIfFalse(ExprBinary(tnonevar, '<=', mtypevar),
 35990:                       'invalid type tag'),
 35990:         _abortIfFalse(ExprBinary(mtypevar, '<=', tlastvar),
 35990:                       'invalid type tag') ])
 35990:     cls.addstmt(sanity)
 35990: 
 35990:     atypevar = ExprVar('aType')
 35990:     sanity2 = MethodDefn(
 35990:         MethodDecl(assertsanityvar.name,
 35990:                        params=[ Decl(typetype, atypevar.name) ],
 36134:                        ret=Type.VOID,
 42566:                        const=1, force_inline=1))
 35990:     sanity2.addstmts([
 35990:         StmtExpr(ExprCall(assertsanityvar)),
 35990:         _abortIfFalse(ExprBinary(mtypevar, '==', atypevar),
 35990:                       'unexpected type tag') ])
 35990:     cls.addstmts([ sanity2, Whitespace.NL ])
 35990: 
 35990:     ## ---- begin public methods -----
 35990: 
 35990:     # Union() default ctor
 35990:     cls.addstmts([
 35990:         Label.PUBLIC,
 35990:         ConstructorDefn(
 42566:             ConstructorDecl(ud.name, force_inline=1),
 35990:             memberinits=[ ExprMemberInit(mtypevar, [ tnonevar ]) ]),
 35990:         Whitespace.NL
 35990:     ])
 35990: 
 35990:     # Union(const T&) copy ctors
 35990:     othervar = ExprVar('aOther')
 35990:     for c in ud.components:
 35990:         copyctor = ConstructorDefn(ConstructorDecl(
 35990:             ud.name, params=[ Decl(c.inType(), othervar.name) ]))
 35990:         copyctor.addstmts([
 42566:             StmtExpr(c.callCtor(othervar)),
 35990:             StmtExpr(ExprAssn(mtypevar, c.enumvar())) ])
 35990:         cls.addstmts([ copyctor, Whitespace.NL ])
 35990: 
 35990:     # Union(const Union&) copy ctor
 35990:     copyctor = ConstructorDefn(ConstructorDecl(
 36045:         ud.name, params=[ Decl(inClsType, othervar.name) ]))
 35990:     othertype = ud.callType(othervar)
 35990:     copyswitch = StmtSwitch(othertype)
 35990:     for c in ud.components:
 35990:         copyswitch.addcase(
 35990:             CaseLabel(c.enum()),
 35990:             StmtBlock([
 42566:                 StmtExpr(c.callCtor(
 35990:                     ExprCall(ExprSelect(othervar,
 35990:                                         '.', c.getConstTypeName())))),
 35990:                 StmtBreak()
 35990:             ]))
 43020:     copyswitch.addcase(CaseLabel(tnonevar.name),
 43020:                        StmtBlock([ StmtBreak() ]))
 35990:     copyswitch.addcase(
 35990:         DefaultLabel(),
 35990:         StmtBlock([ _runtimeAbort('unreached'), StmtReturn() ]))
 35990:     copyctor.addstmts([
 35990:         StmtExpr(callAssertSanity(uvar=othervar)),
 35990:         copyswitch,
 35990:         StmtExpr(ExprAssn(mtypevar, othertype))
 35990:     ])
 35990:     cls.addstmts([ copyctor, Whitespace.NL ])
 35990: 
 35990:     # ~Union()
 35990:     dtor = DestructorDefn(DestructorDecl(ud.name))
 35990:     dtor.addstmt(StmtExpr(callMaybeDestroy(tnonevar)))
 35990:     cls.addstmts([ dtor, Whitespace.NL ])
 35990: 
 35990:     # type()
 42566:     typemeth = MethodDefn(MethodDecl('type', ret=typetype,
 42566:                                      const=1, force_inline=1))
 35990:     typemeth.addstmt(StmtReturn(mtypevar))
 35990:     cls.addstmts([ typemeth, Whitespace.NL ])
 35990: 
 35990:     # Union& operator=(const T&) methods
 35990:     rhsvar = ExprVar('aRhs')
 35990:     for c in ud.components:
 35990:         opeq = MethodDefn(MethodDecl(
 35900:             'operator=',
 35990:             params=[ Decl(c.inType(), rhsvar.name) ],
 35990:             ret=refClsType))
 35990:         opeq.addstmts([
 35990:             # might need to placement-delete old value first
 35990:             maybeReconstruct(c, c.enumvar()),
 35990:             StmtExpr(c.callOperatorEq(rhsvar)),
 35990:             StmtExpr(ExprAssn(mtypevar, c.enumvar())),
 35990:             StmtReturn(ExprDeref(ExprVar.THIS))
 35990:         ])
 35990:         cls.addstmts([ opeq, Whitespace.NL ])
 35990: 
 35990:     # Union& operator=(const Union&)
 35990:     opeq = MethodDefn(MethodDecl(
 35990:         'operator=',
 35990:         params=[ Decl(inClsType, rhsvar.name) ],
 35990:         ret=refClsType))
 35990:     rhstypevar = ExprVar('t')
 35990:     opeqswitch = StmtSwitch(rhstypevar)
 35990:     for c in ud.components:
 35990:         case = StmtBlock()
 35990:         case.addstmts([
 35990:             maybeReconstruct(c, rhstypevar),
 35990:             StmtExpr(c.callOperatorEq(
 35990:                 ExprCall(ExprSelect(rhsvar, '.', c.getConstTypeName())))),
 35990:             StmtBreak()
 35990:         ])
 35990:         opeqswitch.addcase(CaseLabel(c.enum()), case)
 43020:     opeqswitch.addcase(CaseLabel(tnonevar.name),
 43020:                        StmtBlock([ StmtExpr(callMaybeDestroy(rhstypevar)),
 43020:                                    StmtBreak() ]))
 35990:     opeqswitch.addcase(
 35990:         DefaultLabel(),
 35990:         StmtBlock([ _runtimeAbort('unreached'), StmtBreak() ]))
 35990:     opeq.addstmts([
 35990:         StmtExpr(callAssertSanity(uvar=rhsvar)),
 35990:         StmtDecl(Decl(typetype, rhstypevar.name), init=ud.callType(rhsvar)),
 35990:         opeqswitch,
 35990:         StmtExpr(ExprAssn(mtypevar, rhstypevar)),
 35990:         StmtReturn(ExprDeref(ExprVar.THIS))
 35990:     ])
 35990:     cls.addstmts([ opeq, Whitespace.NL ])
 35990: 
 42569:     # bool operator==(const T&)
 42569:     for c in ud.components:
 42569:         opeqeq = MethodDefn(MethodDecl(
 42569:             'operator==',
 42569:             params=[ Decl(c.inType(), rhsvar.name) ],
 42569:             ret=Type.BOOL,
 42569:             const=1))
 42569:         opeqeq.addstmt(StmtReturn(ExprBinary(
 42569:             ExprCall(ExprVar(c.getTypeName())), '==', rhsvar)))
 42569:         cls.addstmts([ opeqeq, Whitespace.NL ])
 42569: 
 42569:     # bool operator==(const Union&)
 42569:     opeqeq = MethodDefn(MethodDecl(
 42569:         'operator==',
 42569:         params=[ Decl(inClsType, rhsvar.name) ],
 42569:         ret=Type.BOOL,
 42569:         const=1))
 42569:     iftypesmismatch = StmtIf(ExprBinary(ud.callType(), '!=',
 42569:                                         ud.callType(rhsvar)))
 42569:     iftypesmismatch.addifstmt(StmtReturn.FALSE)
 42569:     opeqeq.addstmts([ iftypesmismatch, Whitespace.NL ])
 42569: 
 42569:     opeqeqswitch = StmtSwitch(ud.callType())
 42569:     for c in ud.components:
 42569:         case = StmtBlock()
 42569:         case.addstmt(StmtReturn(ExprBinary(
 42569:             ExprCall(ExprVar(c.getTypeName())), '==',
 42569:             ExprCall(ExprSelect(rhsvar, '.', c.getTypeName())))))
 42569:         opeqeqswitch.addcase(CaseLabel(c.enum()), case)
 42569:     opeqeqswitch.addcase(
 42569:         DefaultLabel(),
 42569:         StmtBlock([ _runtimeAbort('unreached'),
 42569:                     StmtReturn.FALSE ]))
 42569:     opeqeq.addstmt(opeqeqswitch)
 42569: 
 42569:     cls.addstmts([ opeqeq, Whitespace.NL ])
 42569: 
 35990:     # accessors for each type: operator T&, operator const T&,
 35990:     # T& get(), const T& get()
 35990:     for c in ud.components:
 35990:         getValueVar = ExprVar(c.getTypeName())
 35990:         getConstValueVar = ExprVar(c.getConstTypeName())
 35990: 
 42566:         getvalue = MethodDefn(MethodDecl(getValueVar.name,
 42566:                                          ret=c.refType(),
 42566:                                          force_inline=1))
 35990:         getvalue.addstmts([
 35990:             StmtExpr(callAssertSanity(expectTypeVar=c.enumvar())),
 35990:             StmtReturn(ExprDeref(c.callGetPtr()))
 35990:         ])
 35990: 
 35990:         getconstvalue = MethodDefn(MethodDecl(
 42566:             getConstValueVar.name, ret=c.constRefType(),
 42566:             const=1, force_inline=1))
 35990:         getconstvalue.addstmts([
 35990:             StmtExpr(callAssertSanity(expectTypeVar=c.enumvar())),
 52195:             StmtReturn(c.getConstValue())
 35990:         ])
 35990: 
 42566:         optype = MethodDefn(MethodDecl('', typeop=c.refType(), force_inline=1))
 35990:         optype.addstmt(StmtReturn(ExprCall(getValueVar)))
 35990:         opconsttype = MethodDefn(MethodDecl(
 42566:             '', const=1, typeop=c.constRefType(), force_inline=1))
 35990:         opconsttype.addstmt(StmtReturn(ExprCall(getConstValueVar)))
 35990: 
 35990:         cls.addstmts([ getvalue, getconstvalue,
 35990:                        optype, opconsttype,
 35990:                        Whitespace.NL ])
 35990: 
 35990:     # private vars
 35990:     cls.addstmts([
 35990:         Label.PRIVATE,
 35990:         StmtDecl(Decl(valuetype, mvaluevar.name)),
 35990:         StmtDecl(Decl(typetype, mtypevar.name))
 35990:     ])
 35990: 
 42566:     return forwarddeclstmts, cls
 35990: 
 35990: ##-----------------------------------------------------------------------------
 35990: 
 35998: class _FindFriends(ipdl.ast.Visitor):
 35998:     def __init__(self):
 35998:         self.mytype = None              # ProtocolType
 35998:         self.vtype = None               # ProtocolType
 35998:         self.friends = set()            # set<ProtocolType>
 35998: 
 35998:     def findFriends(self, ptype):
 35998:         self.mytype = ptype
 36136:         self.walkDownTheProtocolTree(ptype.toplevel())
 35998:         return self.friends
 35998: 
 35998:     # TODO could make this into a _iterProtocolTreeHelper ...
 35998:     def walkDownTheProtocolTree(self, ptype):
 36067:         if ptype != self.mytype:
 36067:             # don't want to |friend| ourself!
 36067:             self.visit(ptype)
 35998:         for mtype in ptype.manages:
 41368:             if mtype is not ptype:
 35998:                 self.walkDownTheProtocolTree(mtype)
 35998: 
 35998:     def visit(self, ptype):
 36067:         # |vtype| is the type currently being visited
 35998:         savedptype = self.vtype
 35998:         self.vtype = ptype
101616:         ptype._ast.accept(self)
 35998:         self.vtype = savedptype
 35998: 
 35998:     def visitMessageDecl(self, md):
 35998:         for it in self.iterActorParams(md):
 35998:             if it.protocol == self.mytype:
 35998:                 self.friends.add(self.vtype)
 35998: 
 35998:     def iterActorParams(self, md):
 35998:         for param in md.inParams:
 35998:             for actor in ipdl.type.iteractortypes(param.type):
 35998:                 yield actor
 35998:         for ret in md.outParams:
 35998:             for actor in ipdl.type.iteractortypes(ret.type):
 35998:                 yield actor
 35998: 
 35998: 
 36137: class _GenerateProtocolActorCode(ipdl.ast.Visitor):
 35990:     def __init__(self, myside):
 35990:         self.side = myside              # "parent" or "child"
 35990:         self.prettyside = myside.title()
 35990:         self.clsname = None
 35990:         self.protocol = None
 36137:         self.hdrfile = None
 36137:         self.cppfile = None
 35990:         self.ns = None
 35990:         self.cls = None
 35990:         self.includedActorTypedefs = [ ]
 41431:         self.includedActorUsings = [ ]
 36137:         self.protocolCxxIncludes = [ ]
 36137: 
 36137:     def lower(self, tu, clsname, cxxHeaderFile, cxxFile):
 35990:         self.clsname = clsname
 36137:         self.hdrfile = cxxHeaderFile
 36137:         self.cppfile = cxxFile
 35990:         tu.accept(self)
 35990: 
 36137:     def standardTypedefs(self):
 36137:         return [
 36137:             Typedef(Type('IPC::Message'), 'Message'),
 36137:             Typedef(Type(self.protocol.channelName()), 'Channel'),
 36137:             Typedef(Type(self.protocol.fqListenerName()), 'ChannelListener'),
 40908:             Typedef(Type('base::ProcessHandle'), 'ProcessHandle'),
 71239:             Typedef(Type('mozilla::ipc::AsyncChannel'), 'AsyncChannel'),
 47711:             Typedef(Type('mozilla::ipc::SharedMemory'), 'SharedMemory'),
 47711:             Typedef(Type('mozilla::ipc::Trigger'), 'Trigger')
 36137:         ]
 36137: 
 36137: 
 35990:     def visitTranslationUnit(self, tu):
 36137:         self.protocol = tu.protocol
 36137: 
 36137:         hf = self.hdrfile
 36137:         cf = self.cppfile
 36137: 
 36137:         # make the C++ header
 36137:         hf.addthings(
 71234:             [ _DISCLAIMER ]
 36137:             + _includeGuardStart(hf)
 36137:             +[
 35990:                 Whitespace.NL,
 35990:                 CppDirective(
 35990:                     'include',
 36137:                     '"'+ _protocolHeaderName(tu.protocol) +'.h"')
 36137:             ])
 35990: 
101616:         for inc in tu.includes:
101616:             inc.accept(self)
 35990: 
 36137:         # this generates the actor's full impl in self.cls
 35990:         tu.protocol.accept(self)
 35990: 
 42566:         clsdecl, clsdefn = _splitClassDeclDefn(self.cls)
 36137: 
 36137:         # XXX damn C++ ... return types in the method defn aren't in
 36137:         # class scope
 36137:         for stmt in clsdefn.stmts:
 36137:             if isinstance(stmt, MethodDefn):
 36137:                 if stmt.decl.ret and stmt.decl.ret.name == 'Result':
 36137:                     stmt.decl.ret.name = clsdecl.name +'::'+ stmt.decl.ret.name
 36137: 
 36137:         def makeNamespace(p, file):
 36137:             if 0 == len(p.namespaces):
 36137:                 return file
 36137:             ns = Namespace(p.namespaces[-1].name)
 36137:             outerns = _putInNamespaces(ns, p.namespaces[:-1])
 36137:             file.addthing(outerns)
 36137:             return ns
 36137: 
 36137:         hdrns = makeNamespace(self.protocol, self.hdrfile)
 36137:         hdrns.addstmts([
 36137:             Whitespace.NL,
 36137:             Whitespace.NL,
 36137:             clsdecl,
 36137:             Whitespace.NL,
 36137:             Whitespace.NL
 36137:         ])
 36137: 
 36137:         self.hdrfile.addthings(
 36137:             ([
 36137:                 Whitespace.NL,
 36137:                 CppDirective('if', '0') ])
 36137:             + _GenerateSkeletonImpl(
 36137:                 _actorName(self.protocol.name, self.side)[1:],
 36137:                 self.protocol.namespaces).fromclass(self.cls)
 36137:             +([
 36137:                 CppDirective('endif', '// if 0'),
 36137:                 Whitespace.NL ])
 36137:             + _includeGuardEnd(hf))
 36137: 
 36137:         # make the .cpp file
 37383:         cf.addthings([
 71234:             _DISCLAIMER,
 36137:             Whitespace.NL,
 36137:             CppDirective(
 36137:                 'include',
 37383:                 '"'+ _protocolHeaderName(self.protocol, self.side) +'.h"')
 37383:         ])
 37383:              
 37383:         if self.protocol.decl.type.isToplevel():
 37383:             cf.addthings([
 37383:                 CppDirective('ifdef', 'MOZ_CRASHREPORTER'),
 37383:                 CppDirective('  include', '"nsXULAppAPI.h"'),
 37383:                 CppDirective('endif')
 37383:             ])
 37383: 
 37383:         cf.addthings((
 37383:             [ Whitespace.NL ]
 36137:             + self.protocolCxxIncludes
 36137:             + [ Whitespace.NL ]
 36137:             + self.standardTypedefs()
 36137:             + tu.protocol.decl.cxxtypedefs
 41431:             + self.includedActorUsings
 36137:             + [ Whitespace.NL ]))
 36137: 
 36137:         cppns = makeNamespace(self.protocol, cf)
 36137:         cppns.addstmts([
 36137:             Whitespace.NL,
 36137:             Whitespace.NL,
 36137:             clsdefn,
 36137:             Whitespace.NL,
 36137:             Whitespace.NL
 36137:         ])
 35990: 
 35990: 
101616:     def visitInclude(self, inc):
101616:         ip = inc.tu.protocol
101616:         if not ip:
101616:             return
 35990: 
 36137:         self.hdrfile.addthings([
 42566:             _makeForwardDeclForActor(ip.decl.type, self.side),
 36137:             Whitespace.NL
 36137:         ])
 36137:         self.protocolCxxIncludes.append(
 35990:             CppDirective(
 35990:                 'include',
 36137:                 '"%s.h"'% (_protocolHeaderName(ip, self.side))))
 35990: 
 35990:         if ip.decl.fullname is not None:
 35990:             self.includedActorTypedefs.append(Typedef(
 35990:                 Type(_actorName(ip.decl.fullname, self.prettyside)),
 35990:                 _actorName(ip.decl.shortname, self.prettyside)))
 41431:             self.includedActorUsings.append(Using(
 41431:                 Type(_actorName(ip.decl.fullname, self.prettyside))))
 35742: 
 35742: 
 35742:     def visitProtocol(self, p):
 36137:         self.hdrfile.addthings([
 35990:             CppDirective('ifdef', 'DEBUG'),
 35990:             CppDirective('include', '"prenv.h"'),
 35990:             CppDirective('endif', '// DEBUG')
 35990:         ])
 35990: 
 35990:         self.protocol = p
 38105:         ptype = p.decl.type
 38105:         toplevel = p.decl.type.toplevel()
 35990: 
 35990:         # FIXME: all actors impl Iface for now
 38105:         if ptype.isManager() or 1:
 36137:             self.hdrfile.addthing(CppDirective('include', '"base/id_map.h"'))
 36137: 
 36137:         self.hdrfile.addthings([
 35990:             CppDirective('include', '"'+ p.channelHeaderFile() +'"'),
 35990:             Whitespace.NL ])
 35742: 
 36140:         self.cls = Class(
 36140:             self.clsname,
 36140:             inherits=[ Inherit(Type(p.fqListenerName()), viz='protected'),
 36140:                        Inherit(p.managerInterfaceType(), viz='protected') ],
 36140:             abstract=True)
 35990: 
 71247:         bridgeActorsCreated = ProcessGraph.bridgeEndpointsOf(ptype, self.side)
 71253:         opensActorsCreated = ProcessGraph.opensEndpointsOf(ptype, self.side)
 71253:         channelOpenedActors = bridgeActorsCreated + opensActorsCreated
 71247: 
 38105:         friends = _FindFriends().findFriends(ptype)
 38105:         if ptype.isManaged():
 38105:             friends.update(ptype.managers)
 35998: 
 36138:         # |friend| managed actors so that they can call our Dealloc*()
 38105:         friends.update(ptype.manages)
 36138: 
 41368:         # don't friend ourself if we're a self-managed protocol
 41368:         friends.discard(ptype)
 41368: 
 35998:         for friend in friends:
 36137:             self.hdrfile.addthings([
 35990:                 Whitespace.NL,
 42566:                 _makeForwardDeclForActor(friend, self.prettyside),
 35990:                 Whitespace.NL
 35990:             ])
 35990:             self.cls.addstmts([
 35998:                 FriendClassDecl(_actorName(friend.fullname(),
 35990:                                            self.prettyside)),
 35990:                 Whitespace.NL ])
 35990: 
 71253:         for actor in channelOpenedActors:
 71247:             self.hdrfile.addthings([
 71247:                 Whitespace.NL,
 71247:                 _makeForwardDeclForActor(actor.ptype, actor.side),
 71247:                 Whitespace.NL
 71247:             ])
 71247: 
 35990:         self.cls.addstmt(Label.PROTECTED)
 35990:         for typedef in p.cxxTypedefs():
 35990:             self.cls.addstmt(typedef)
 35990:         for typedef in self.includedActorTypedefs:
 35990:             self.cls.addstmt(typedef)
 71247:         # XXX these don't really fit in the other lists; just include
 71247:         # them here for now
 71247:         self.cls.addstmts([
 71247:             Typedef(Type('base::ProcessId'), 'ProcessId'),
 71247:             Typedef(Type('mozilla::ipc::ProtocolId'), 'ProtocolId'),
 71247:             Typedef(Type('mozilla::ipc::Transport'), 'Transport'),
 71247:             Typedef(Type('mozilla::ipc::TransportDescriptor'), 'TransportDescriptor')
 71247:         ])
 71247: 
 35990:         self.cls.addstmt(Whitespace.NL)
 35990: 
 47709:         self.cls.addstmts([ Typedef(p.fqStateType(), 'State'), Whitespace.NL ])
 47709: 
 35990:         # interface methods that the concrete subclass has to impl
 35990:         for md in p.messageDecls:
 35990:             isctor, isdtor = md.decl.type.isCtor(), md.decl.type.isDtor()
 35990: 
 35990:             if self.receivesMessage(md):
 35990:                 # generate Recv/Answer* interface
 36138:                 implicit = (not isdtor)
 35990:                 recvDecl = MethodDecl(
 35990:                     md.recvMethod().name,
 35990:                     params=md.makeCxxParams(paramsems='in', returnsems='out',
 36138:                                             side=self.side, implicit=implicit),
 35990:                     ret=Type.BOOL, virtual=1)
 35990: 
 35990:                 if isctor or isdtor:
 35990:                     defaultRecv = MethodDefn(recvDecl)
 42569:                     defaultRecv.addstmt(StmtReturn.TRUE)
 35990:                     self.cls.addstmt(defaultRecv)
 35763:                 else:
 35990:                     recvDecl.pure = 1
 35990:                     self.cls.addstmt(StmtDecl(recvDecl))
 35990: 
 36138:         for md in p.messageDecls:
 36138:             managed = md.decl.type.constructedType()
 41368:             if not ptype.isManagerOf(managed) or md.decl.type.isDtor():
 36138:                 continue
 36138: 
 36138:             # add the Alloc/Dealloc interface for managed actors
 36138:             actortype = md.actorDecl().bareType(self.side)
 36138:             
 36138:             self.cls.addstmt(StmtDecl(MethodDecl(
 36138:                 _allocMethod(managed).name,
 36138:                 params=md.makeCxxParams(side=self.side, implicit=0),
 36138:                 ret=actortype,
 36138:                 virtual=1, pure=1)))
 36138: 
 36138:             self.cls.addstmt(StmtDecl(MethodDecl(
 36138:                 _deallocMethod(managed).name,
 36138:                 params=[ Decl(actortype, 'actor') ],
 36138:                 ret=Type.BOOL,
 36138:                 virtual=1, pure=1)))
 36138: 
 71253:         for actor in channelOpenedActors:
 71253:             # add the Alloc interface for actors created when a
 71253:             # new channel is opened
 71247:             actortype = _cxxBareType(actor.asType(), actor.side)
 71247:             self.cls.addstmt(StmtDecl(MethodDecl(
 71247:                 _allocMethod(actor.ptype).name,
 71247:                 params=[ Decl(Type('Transport', ptr=1), 'transport'),
 71247:                          Decl(Type('ProcessId'), 'otherProcess') ],
 71247:                 ret=actortype,
 71247:                 virtual=1, pure=1)))
 71247: 
 38100:         # optional ActorDestroy() method; default is no-op
 36140:         self.cls.addstmts([
 36140:             Whitespace.NL,
 36140:             MethodDefn(MethodDecl(
 36140:                 _destroyMethod().name,
 36140:                 params=[ Decl(_DestroyReason.Type(), 'why') ],
 38100:                 virtual=1)),
 38100:             Whitespace.NL
 36140:         ])
 36138: 
 38107:         if ptype.isToplevel():
 54001:             # void ProcessingError(code); default to no-op
 54001:             processingerror = MethodDefn(
 54001:                 MethodDecl(p.processingErrorVar().name,
 54001:                            params=[ Param(_Result.Type(), 'code') ],
 54001:                            virtual=1))
 54001: 
 38107:             # bool ShouldContinueFromReplyTimeout(); default to |true|
 38107:             shouldcontinue = MethodDefn(
 38107:                 MethodDecl(p.shouldContinueFromTimeoutVar().name,
 38107:                            ret=Type.BOOL, virtual=1))
 42569:             shouldcontinue.addstmt(StmtReturn.TRUE)
 39312: 
 41650:             # void Entered*()/Exited*(); default to no-op
 38682:             entered = MethodDefn(
 38682:                 MethodDecl(p.enteredCxxStackVar().name, virtual=1))
 38682:             exited = MethodDefn(
 38682:                 MethodDecl(p.exitedCxxStackVar().name, virtual=1))
 41650:             enteredcall = MethodDefn(
 41650:                 MethodDecl(p.enteredCallVar().name, virtual=1))
 41650:             exitedcall = MethodDefn(
 41650:                 MethodDecl(p.exitedCallVar().name, virtual=1))
 41650: 
 54001:             self.cls.addstmts([ processingerror,
 54001:                                 shouldcontinue,
 41650:                                 entered, exited,
 41650:                                 enteredcall, exitedcall,
 38682:                                 Whitespace.NL ])
 38107: 
 36137:         self.cls.addstmts((
 39264:             [ Label.PUBLIC ]
 36137:             + self.standardTypedefs()
 36137:             + [ Whitespace.NL ]
 36137:         ))
 35990: 
 35990:         self.cls.addstmt(Label.PUBLIC)
 35990:         # Actor()
 35990:         ctor = ConstructorDefn(ConstructorDecl(self.clsname))
 38105:         if ptype.isToplevel():
 35744:             ctor.memberinits = [
 35990:                 ExprMemberInit(p.channelVar(), [
 35990:                     ExprCall(ExprVar('ALLOW_THIS_IN_INITIALIZER_LIST'),
 35990:                              [ ExprVar.THIS ]) ]),
 36136:                 ExprMemberInit(p.lastActorIdVar(),
 47709:                                [ p.actorIdInit(self.side) ]),
 47709:                 ExprMemberInit(p.lastShmemIdVar(),
 47709:                                [ p.shmemIdInit(self.side) ]),
 47709:                 ExprMemberInit(p.stateVar(),
 47709:                                [ p.startState() ])
 35929:             ]
 35929:         else:
 35929:             ctor.memberinits = [
 47709:                 ExprMemberInit(p.idVar(), [ ExprLiteral.ZERO ]),
 47709:                 ExprMemberInit(p.stateVar(),
 47709:                                [ p.deadState() ])
 47709:             ]
 36166: 
 35990:         ctor.addstmt(StmtExpr(ExprCall(ExprVar('MOZ_COUNT_CTOR'),
 35990:                                        [ ExprVar(self.clsname) ])))
 35990:         self.cls.addstmts([ ctor, Whitespace.NL ])
 35990: 
 35990:         # ~Actor()
 35990:         dtor = DestructorDefn(
 35990:             DestructorDecl(self.clsname, virtual=True))
 35990:         dtor.addstmt(StmtExpr(ExprCall(ExprVar('MOZ_COUNT_DTOR'),
 35990:                                                [ ExprVar(self.clsname) ])))
 36039: 
 35990:         self.cls.addstmts([ dtor, Whitespace.NL ])
 35742: 
 38105:         if ptype.isToplevel():
 83465:             # Open(Transport*, ProcessHandle, MessageLoop*, Side)
 35990:             aTransportVar = ExprVar('aTransport')
 35990:             aThreadVar = ExprVar('aThread')
 36016:             processvar = ExprVar('aOtherProcess')
 71247:             sidevar = ExprVar('aSide')
 35990:             openmeth = MethodDefn(
 35990:                 MethodDecl(
 35742:                     'Open',
 35990:                     params=[ Decl(Type('Channel::Transport', ptr=True),
 35990:                                       aTransportVar.name),
 36016:                              Decl(Type('ProcessHandle'), processvar.name),
 36137:                              Param(Type('MessageLoop', ptr=True),
 36137:                                    aThreadVar.name,
 71247:                                    default=ExprLiteral.NULL),
 71247:                              Param(Type('AsyncChannel::Side'),
 71247:                                    sidevar.name,
 71247:                                    default=ExprVar('Channel::Unknown')) ],
 35990:                     ret=Type.BOOL))
 35990: 
 36016:             openmeth.addstmts([
 36016:                 StmtExpr(ExprAssn(p.otherProcessVar(), processvar)),
 36016:                 StmtReturn(ExprCall(ExprSelect(p.channelVar(), '.', 'Open'),
 71247:                                     [ aTransportVar, aThreadVar, sidevar ]))
 36016:             ])
 36016:             self.cls.addstmts([
 36016:                 openmeth,
 36016:                 Whitespace.NL ])
 35990: 
 83465:             # Open(AsyncChannel *, MessageLoop *, Side)
 83465:             aChannel = ExprVar('aChannel')
 83465:             aMessageLoop = ExprVar('aMessageLoop')
 83465:             sidevar = ExprVar('aSide')
 83465:             openmeth = MethodDefn(
 83465:                 MethodDecl(
 83465:                     'Open',
 83465:                     params=[ Decl(Type('AsyncChannel', ptr=True),
 83465:                                       aChannel.name),
 83465:                              Param(Type('MessageLoop', ptr=True),
 83465:                                    aMessageLoop.name),
 83465:                              Param(Type('AsyncChannel::Side'),
 83465:                                    sidevar.name,
 83465:                                    default=ExprVar('Channel::Unknown')) ],
 83465:                     ret=Type.BOOL))
 83465: 
 83465:             openmeth.addstmts([
 83465:                 StmtExpr(ExprAssn(p.otherProcessVar(), ExprLiteral.ZERO)),
 83465:                 StmtReturn(ExprCall(ExprSelect(p.channelVar(), '.', 'Open'),
 83465:                                     [ aChannel, aMessageLoop, sidevar ]))
 83465:             ])
 83465:             self.cls.addstmts([
 83465:                 openmeth,
 83465:                 Whitespace.NL ])
 83465: 
 35990:             # Close()
 35990:             closemeth = MethodDefn(MethodDecl('Close'))
 35990:             closemeth.addstmt(StmtExpr(
 35990:                 ExprCall(ExprSelect(p.channelVar(), '.', 'Close'))))
 35990:             self.cls.addstmts([ closemeth, Whitespace.NL ])
 35990: 
 38107:             if ptype.talksSync() or ptype.talksRpc():
 38107:                 # SetReplyTimeoutMs()
 38107:                 timeoutvar = ExprVar('aTimeoutMs')
 38107:                 settimeout = MethodDefn(MethodDecl(
 38107:                     'SetReplyTimeoutMs',
 38107:                     params=[ Decl(Type.INT32, timeoutvar.name) ]))
 38107:                 settimeout.addstmt(StmtExpr(
 38107:                     ExprCall(
 38107:                         ExprSelect(p.channelVar(), '.', 'SetReplyTimeoutMs'),
 38107:                         args=[ timeoutvar ])))
 38107:                 self.cls.addstmts([ settimeout, Whitespace.NL ])
 38107: 
 38105:         if not ptype.isToplevel():
 38096:             if 1 == len(p.managers):
 36138:                 ## manager()
 36138:                 managertype = p.managerActorType(self.side, ptr=1)
 36138:                 managermeth = MethodDefn(MethodDecl(
 36138:                     p.managerMethod().name, ret=managertype))
 38096:                 managermeth.addstmt(StmtReturn(
 38096:                     ExprCast(p.managerVar(), managertype, static=1)))
 36138: 
 36138:                 self.cls.addstmts([ managermeth, Whitespace.NL ])
 36138: 
 41367:         ## Managed[T](Array& inout) const
 41367:         ## const Array<T>& Managed() const
 38105:         for managed in ptype.manages:
 36139:             arrvar = ExprVar('aArr')
 36139:             meth = MethodDefn(MethodDecl(
 36139:                 p.managedMethod(managed, self.side).name,
 36140:                 params=[ Decl(p.managedVarType(managed, self.side, ref=1),
 36139:                               arrvar.name) ],
 36139:                 const=1))
 36139:             meth.addstmt(StmtExpr(ExprAssn(
 36139:                 arrvar, p.managedVar(managed, self.side))))
 41367: 
 41367:             refmeth = MethodDefn(MethodDecl(
 41367:                 p.managedMethod(managed, self.side).name,
 41367:                 params=[ ],
 41367:                 ret=p.managedVarType(managed, self.side, const=1, ref=1),
 41367:                 const=1))
 41367:             refmeth.addstmt(StmtReturn(p.managedVar(managed, self.side)))
 41367:             
 41367:             self.cls.addstmts([ meth, refmeth, Whitespace.NL ])
 36139: 
 47709:         statemethod = MethodDefn(MethodDecl(
 47709:             p.stateMethod().name,
 47709:             ret=p.fqStateType()))
 47709:         statemethod.addstmt(StmtReturn(p.stateVar()))
 47709:         self.cls.addstmts([ statemethod, Whitespace.NL ])
 47709: 
 35990:         ## OnMessageReceived()/OnCallReceived()
 35990: 
 35990:         # save these away for use in message handler case stmts
 42563:         msgvar = ExprVar('__msg')
 35990:         self.msgvar = msgvar
 42563:         replyvar = ExprVar('__reply')
 35990:         self.replyvar = replyvar
 42563:         itervar = ExprVar('__iter')
 42563:         self.itervar = itervar
 42563:         var = ExprVar('__v')
 42563:         self.var = var
 42563:         # for ctor recv cases, we can't read the actor ID into a PFoo*
 42563:         # because it doesn't exist on this side yet.  Use a "special"
 42563:         # actor handle instead
 42563:         handlevar = ExprVar('__handle')
 42563:         self.handlevar = handlevar
 35990: 
 35990:         msgtype = ExprCall(ExprSelect(msgvar, '.', 'type'), [ ])
 35990:         self.asyncSwitch = StmtSwitch(msgtype)
 38105:         if toplevel.talksSync():
 35990:             self.syncSwitch = StmtSwitch(msgtype)
 38105:             if toplevel.talksRpc():
 35990:                 self.rpcSwitch = StmtSwitch(msgtype)
 35990: 
 35990:         # implement Send*() methods and add dispatcher cases to
 35990:         # message switch()es
 35742:         for md in p.messageDecls:
 35742:             self.visitMessageDecl(md)
 35742: 
 71253:         # Handlers for the creation of actors when a new channel is
 71253:         # opened
 71253:         if len(channelOpenedActors):
 71253:             self.makeChannelOpenedHandlers(channelOpenedActors)
 71247: 
 35742:         # add default cases
 35990:         default = StmtBlock()
 35990:         default.addstmt(StmtReturn(_Result.NotKnown))
 35990:         self.asyncSwitch.addcase(DefaultLabel(), default)
 38105:         if toplevel.talksSync():
 35990:             self.syncSwitch.addcase(DefaultLabel(), default)
 38105:             if toplevel.talksRpc():
 35990:                 self.rpcSwitch.addcase(DefaultLabel(), default)
 35990: 
 87236:         # FIXME/bug 535053: only manager protocols and non-manager
 87236:         # protocols with union types need Lookup().  we'll give it to
 87236:         # all for the time being (simpler)
 87236:         if 1 or ptype.isManager():
 87236:             self.cls.addstmts(self.implementManagerIface())
 35990: 
 35990:         def makeHandlerMethod(name, switch, hasReply, dispatches=0):
 35990:             params = [ Decl(Type('Message', const=1, ref=1), msgvar.name) ]
 35990:             if hasReply:
 35990:                 params.append(Decl(Type('Message', ref=1, ptr=1),
 35990:                                    replyvar.name))
 35990:             
 35990:             method = MethodDefn(MethodDecl(name, virtual=True,
 36137:                                            params=params, ret=_Result.Type()))
 35990:             if dispatches:
 35990:                 routevar = ExprVar('__route')
 35990:                 routedecl = StmtDecl(
 35990:                     Decl(_actorIdType(), routevar.name),
 35990:                     init=ExprCall(ExprSelect(msgvar, '.', 'routing_id')))
 35990: 
 35990:                 routeif = StmtIf(ExprBinary(
 35990:                     ExprVar('MSG_ROUTING_CONTROL'), '!=', routevar))
 35990:                 routedvar = ExprVar('__routed')
 35990:                 routeif.ifb.addstmt(
 35990:                     StmtDecl(Decl(Type('ChannelListener', ptr=1),
 35990:                                   routedvar.name),
 35990:                              _lookupListener(routevar)))
 35990:                 failif = StmtIf(ExprPrefixUnop(routedvar, '!'))
 35990:                 failif.ifb.addstmt(StmtReturn(_Result.RouteError))
 35990:                 routeif.ifb.addstmt(failif)
 35990: 
 35990:                 routeif.ifb.addstmt(StmtReturn(ExprCall(
 35990:                     ExprSelect(routedvar, '->', name),
 35990:                     args=[ ExprVar(p.name) for p in params ])))
 35990: 
 35990:                 method.addstmts([ routedecl, routeif, Whitespace.NL ])
 35990: 
104602:             # in the event of an RPC delete message, we want to loudly complain about
104602:             # messages that are received that are not a reply to the original message
104602:             if ptype.hasReentrantDelete:
104602:                 msgVar = ExprVar(params[0].name)
104602:                 ifdying = StmtIf(ExprBinary(
104602:                     ExprBinary(ExprVar('mState'), '==', _dyingState(ptype)),
104602:                     '&&',
104602:                     ExprBinary(
104602:                         ExprBinary(ExprCall(ExprSelect(msgVar, '.', 'is_reply')), '!=', ExprLiteral.TRUE),
104602:                         '||',
104602:                         ExprBinary(ExprCall(ExprSelect(msgVar, '.', 'is_rpc')), '!=', ExprLiteral.TRUE))))
104602:                 ifdying.addifstmts([_fatalError('incoming message racing with actor deletion'),
104602:                                     StmtReturn(_Result.Processed)])
104602:                 method.addstmt(ifdying)
104602: 
 35990:             # bug 509581: don't generate the switch stmt if there
 35990:             # is only the default case; MSVC doesn't like that
 35990:             if switch.nr_cases > 1:
 35990:                 method.addstmt(switch)
 35990:             else:
 35990:                 method.addstmt(StmtReturn(_Result.NotKnown))
 35990: 
 35990:             return method
 35990: 
 38105:         dispatches = (ptype.isToplevel() and ptype.isManager())
 35990:         self.cls.addstmts([
 35990:             makeHandlerMethod('OnMessageReceived', self.asyncSwitch,
 35990:                               hasReply=0, dispatches=dispatches),
 35990:             Whitespace.NL
 35990:         ])
 38105:         if toplevel.talksSync():
 35990:             self.cls.addstmts([
 35990:                 makeHandlerMethod('OnMessageReceived', self.syncSwitch,
 35990:                                   hasReply=1, dispatches=dispatches),
 35990:                 Whitespace.NL
 35990:             ])
 38105:             if toplevel.talksRpc():
 35990:                 self.cls.addstmts([
 35990:                     makeHandlerMethod('OnCallReceived', self.rpcSwitch,
 35990:                                       hasReply=1, dispatches=dispatches),
 35990:                     Whitespace.NL
 35990:                 ])
 35990: 
 36140:         destroysubtreevar = ExprVar('DestroySubtree')
 36140:         deallocsubtreevar = ExprVar('DeallocSubtree')
 41363:         deallocshmemvar = ExprVar('DeallocShmems')
 36140: 
 54001:         # OnProcesingError(code)
 54001:         codevar = ExprVar('code')
 54001:         onprocessingerror = MethodDefn(
 54001:             MethodDecl('OnProcessingError',
 54001:                        params=[ Param(_Result.Type(), codevar.name) ]))
 54001:         if ptype.isToplevel():
 54001:             onprocessingerror.addstmt(StmtReturn(
 54001:                 ExprCall(p.processingErrorVar(), args=[ codevar ])))
 54001:         else:
 54001:             onprocessingerror.addstmt(
 54001:                 _runtimeAbort("`OnProcessingError' called on non-toplevel actor"))
 54001:         self.cls.addstmts([ onprocessingerror, Whitespace.NL ])
 54001: 
 38107:         # OnReplyTimeout()
 38107:         if toplevel.talksSync() or toplevel.talksRpc():
 38107:             ontimeout = MethodDefn(
 38107:                 MethodDecl('OnReplyTimeout', ret=Type.BOOL))
 38107: 
 38107:             if ptype.isToplevel():
 38107:                 ontimeout.addstmt(StmtReturn(
 38107:                     ExprCall(p.shouldContinueFromTimeoutVar())))
 38107:             else:
 38107:                 ontimeout.addstmts([
 38107:                     _runtimeAbort("`OnReplyTimeout' called on non-toplevel actor"),
 42569:                     StmtReturn.FALSE
 38107:                 ])
 38107: 
 38107:             self.cls.addstmts([ ontimeout, Whitespace.NL ])
 38107: 
 39312:         # C++-stack-related methods
 38682:         if ptype.isToplevel() and toplevel.talksRpc():
 39312:             # OnEnteredCxxStack()
 38682:             onentered = MethodDefn(MethodDecl('OnEnteredCxxStack'))
 38682:             onentered.addstmt(StmtReturn(ExprCall(p.enteredCxxStackVar())))
 38682: 
 39312:             # OnExitedCxxStack()
 38682:             onexited = MethodDefn(MethodDecl('OnExitedCxxStack'))
 38682:             onexited.addstmt(StmtReturn(ExprCall(p.exitedCxxStackVar())))
 38682: 
 41650:             # OnEnteredCxxStack()
 41650:             onenteredcall = MethodDefn(MethodDecl('OnEnteredCall'))
 41650:             onenteredcall.addstmt(StmtReturn(ExprCall(p.enteredCallVar())))
 41650: 
 41650:             # OnExitedCxxStack()
 41650:             onexitedcall = MethodDefn(MethodDecl('OnExitedCall'))
 41650:             onexitedcall.addstmt(StmtReturn(ExprCall(p.exitedCallVar())))
 41650: 
 39312:             # bool IsOnCxxStack()
 39312:             onstack = MethodDefn(
 39312:                 MethodDecl(p.onCxxStackVar().name, ret=Type.BOOL, const=1))
 39312:             onstack.addstmt(StmtReturn(ExprCall(
 39312:                 ExprSelect(p.channelVar(), '.', p.onCxxStackVar().name))))
 39312: 
 42538:             # void ProcessIncomingRacingRPCCall
 42538:             processincoming = MethodDefn(
 42538:                 MethodDecl('FlushPendingRPCQueue', ret=Type.VOID))
 42538:             processincoming.addstmt(StmtExpr(ExprCall(ExprSelect(_actorChannel(ExprVar.THIS), '.', 'FlushPendingRPCQueue'))))
 42538: 
 41650:             self.cls.addstmts([ onentered, onexited,
 41650:                                 onenteredcall, onexitedcall,
 42538:                                 onstack, processincoming, Whitespace.NL ])
 38682: 
 36140:         # OnChannelClose()
 36140:         onclose = MethodDefn(MethodDecl('OnChannelClose'))
 38105:         if ptype.isToplevel():
 37310:             onclose.addstmts([
 37310:                 StmtExpr(ExprCall(destroysubtreevar,
 37310:                                   args=[ _DestroyReason.NormalShutdown ])),
 41363:                 StmtExpr(ExprCall(deallocsubtreevar)),
 41363:                 StmtExpr(ExprCall(deallocshmemvar))
 37310:             ])
 38105:         else:
 38105:             onclose.addstmt(
 38105:                 _runtimeAbort("`OnClose' called on non-toplevel actor"))
 36140:         self.cls.addstmts([ onclose, Whitespace.NL ])
 36140: 
 38105:         # OnChannelError()
 36140:         onerror = MethodDefn(MethodDecl('OnChannelError'))
 38105:         if ptype.isToplevel():
 37310:             onerror.addstmts([
 37310:                 StmtExpr(ExprCall(destroysubtreevar,
 37310:                                   args=[ _DestroyReason.AbnormalShutdown ])),
 41363:                 StmtExpr(ExprCall(deallocsubtreevar)),
 41363:                 StmtExpr(ExprCall(deallocshmemvar))
 37310:             ])
 38105:         else:
 38105:             onerror.addstmt(
 38105:                 _runtimeAbort("`OnError' called on non-toplevel actor"))
 36140:         self.cls.addstmts([ onerror, Whitespace.NL ])
 36140: 
 57663:         # OnChannelConnected()
 58190:         onconnected = MethodDefn(MethodDecl('OnChannelConnected',
 58190:                                             params=[ Decl(Type.INT32, 'pid') ]))
 57663:         if not ptype.isToplevel():
 57663:             onconnected.addstmt(
 57663:                 _runtimeAbort("'OnConnected' called on non-toplevel actor"))
 57663: 
 57663:         self.cls.addstmts([ onconnected, Whitespace.NL ])
 35990: 
 39732:         # User-facing shmem methods
 46953:         self.cls.addstmts(self.makeShmemIface())
 46953: 
 70027:         if (ptype.isToplevel() and ptype.talksRpc()):
 41473: 
 41473:             processnative = MethodDefn(
 41473:                 MethodDecl('ProcessNativeEventsInRPCCall', ret=Type.VOID))
 41473: 
 41473:             processnative.addstmts([
 41473:                     CppDirective('ifdef', 'OS_WIN'),
 41473:                     StmtExpr(ExprCall(
 41473:                             ExprSelect(p.channelVar(), '.',
 41473:                                        'ProcessNativeEventsInRPCCall'))),
 41473:                     CppDirective('else'),
 41473:                     _runtimeAbort('This method is Windows-only'),
 41473:                     CppDirective('endif'),
 41473:                     ])
 41473: 
 41473:             self.cls.addstmts([ processnative, Whitespace.NL ])
 41473: 
 38105:         if ptype.isToplevel() and self.side is 'parent':
 57663:             ## void SetOtherProcess(ProcessHandle pid)
 57663:             otherprocessvar = ExprVar('aOtherProcess')
 57663:             setotherprocess = MethodDefn(MethodDecl(
 57663:                     'SetOtherProcess',
 57663:                     params=[ Decl(Type('ProcessHandle'), otherprocessvar.name)]))
 57663:             setotherprocess.addstmt(StmtExpr(ExprAssn(p.otherProcessVar(), otherprocessvar)))
 57663:             self.cls.addstmts([
 57663:                     setotherprocess,
 57663:                     Whitespace.NL])
 57663: 
 37383:             ## bool GetMinidump(nsIFile** dump)
 37383:             self.cls.addstmt(Label.PROTECTED)
 37383: 
 37383:             otherpidvar = ExprVar('OtherSidePID')
 37383:             otherpid = MethodDefn(MethodDecl(
 37383:                 otherpidvar.name, params=[ ],
 37383:                 ret=Type('base::ProcessId'),
 37383:                 const=1))
 37383:             otherpid.addstmts([
 37383:                 StmtReturn(ExprCall(
 37383:                     ExprVar('base::GetProcId'),
 37383:                     args=[ p.otherProcessVar() ])),
 37383:             ])
 37383: 
 37383:             dumpvar = ExprVar('aDump')
104355:             seqvar = ExprVar('aSequence')
 37383:             getdump = MethodDefn(MethodDecl(
 39624:                 'TakeMinidump',
104355:                 params=[ Decl(Type('nsIFile', ptrptr=1), dumpvar.name),
104355:                          Decl(Type.UINT32PTR, seqvar.name)],
 37383:                 ret=Type.BOOL,
 37383:                 const=1))
 37383:             getdump.addstmts([
 37383:                 CppDirective('ifdef', 'MOZ_CRASHREPORTER'),
 37383:                 StmtReturn(ExprCall(
 39624:                     ExprVar('XRE_TakeMinidumpForChild'),
104355:                     args=[ ExprCall(otherpidvar), dumpvar, seqvar ])),
 37383:                 CppDirective('else'),
 42569:                 StmtReturn.FALSE,
 37383:                 CppDirective('endif')
 37383:             ])
 37383:             self.cls.addstmts([ otherpid, Whitespace.NL,
 37383:                                 getdump, Whitespace.NL ])
 37383: 
 38105:         if (ptype.isToplevel() and self.side is 'parent'
 38105:             and ptype.talksRpc()):
 38100:             # offer BlockChild() and UnblockChild().
 38100:             # See ipc/glue/RPCChannel.h
 38100:             blockchild = MethodDefn(MethodDecl(
 38100:                 'BlockChild', ret=Type.BOOL))
 38100:             blockchild.addstmt(StmtReturn(ExprCall(
 38100:                 ExprSelect(p.channelVar(), '.', 'BlockChild'))))
 38100: 
 38100:             unblockchild = MethodDefn(MethodDecl(
 38100:                 'UnblockChild', ret=Type.BOOL))
 38100:             unblockchild.addstmt(StmtReturn(ExprCall(
 38100:                 ExprSelect(p.channelVar(), '.', 'UnblockChild'))))
 38100: 
 38100:             self.cls.addstmts([ blockchild, unblockchild, Whitespace.NL ])
 38100: 
 36136:         ## private methods
 36136:         self.cls.addstmt(Label.PRIVATE)
 36136: 
 36136:         ## FatalError()       
 36136:         msgvar = ExprVar('msg')
 36136:         fatalerror = MethodDefn(MethodDecl(
 36136:             'FatalError',
 36136:             params=[ Decl(Type('char', const=1, ptrconst=1), msgvar.name) ],
 52482:             const=1, virtual=1))
 36136:         fatalerror.addstmts([
 52482:             Whitespace('// Virtual method to prevent inlining.\n', indent=1),
 52482:             Whitespace('// This give us better error reporting.\n', indent=1),
 52482:             Whitespace('// See bug 589371\n\n', indent=1),
 36136:             _printErrorMessage('IPDL error:'),
 36136:             _printErrorMessage(msgvar),
 36136:             Whitespace.NL
 36136:         ])
 36136:         actorname = _actorName(p.name, self.side)
 36136:         if self.side is 'parent':
 36136:             # if the error happens on the parent side, the parent
 36136:             # kills off the child
 36136:             fatalerror.addstmts([
 36136:                 _printErrorMessage(
 36136:                     '['+ actorname +'] killing child side as a result'),
 36136:                 Whitespace.NL
 36136:             ])
 36136: 
 71247:             ifkill = StmtIf(ExprNot(_killProcess(p.callOtherProcess())))
 36136:             ifkill.addifstmt(
 36136:                 _printErrorMessage("  may have failed to kill child!"))
 36136:             fatalerror.addstmt(ifkill)
 36136:         else:
 36136:             # and if it happens on the child side, the child commits
 36136:             # seppuko
 36136:             fatalerror.addstmt(
 36136:                 _runtimeAbort('['+ actorname +'] abort()ing as a result'))
 36136:         self.cls.addstmts([ fatalerror, Whitespace.NL ])
 36136: 
 36140:         ## DestroySubtree(bool normal)
 36140:         whyvar = ExprVar('why')
 36140:         subtreewhyvar = ExprVar('subtreewhy')
 36140:         kidsvar = ExprVar('kids')
 36140:         ivar = ExprVar('i')
 36140:         ithkid = ExprIndex(kidsvar, ivar)
 36140: 
 36140:         destroysubtree = MethodDefn(MethodDecl(
 36140:             destroysubtreevar.name,
 36140:             params=[ Decl(_DestroyReason.Type(), whyvar.name) ]))
 36140: 
 63894:         if ptype.isManaged():
 63894:             destroysubtree.addstmt(
 63894:                 Whitespace('// Unregister from our manager.\n', indent=1))
 63894:             destroysubtree.addstmts(self.unregisterActor())
 63894:             destroysubtree.addstmt(Whitespace.NL)
 63894: 
 38105:         if ptype.isManager():
 36140:             # only declare this for managers to avoid unused var warnings
 36140:             destroysubtree.addstmts([
 36140:                 StmtDecl(
 36140:                     Decl(_DestroyReason.Type(), subtreewhyvar.name),
 36140:                     init=ExprConditional(
 63894:                         ExprBinary(
 63894:                             ExprBinary(whyvar, '==',
 63894:                                        _DestroyReason.Deletion),
 63894:                             '||',
 63894:                             ExprBinary(whyvar, '==',
 63894:                                        _DestroyReason.FailedConstructor)),
 36140:                         _DestroyReason.AncestorDeletion, whyvar)),
 36140:                 Whitespace.NL
 36140:             ])
 36140: 
 38105:         for managed in ptype.manages:
 36140:             foreachdestroy = StmtFor(
 36140:                 init=Param(Type.UINT32, ivar.name, ExprLiteral.ZERO),
 36140:                 cond=ExprBinary(ivar, '<', _callCxxArrayLength(kidsvar)),
 36140:                 update=ExprPrefixUnop(ivar, '++'))
 36140:             foreachdestroy.addstmt(StmtExpr(ExprCall(
 36140:                 ExprSelect(ithkid, '->', destroysubtreevar.name),
 36140:                 args=[ subtreewhyvar ])))
 36140: 
 36140:             block = StmtBlock()
 36140:             block.addstmts([
 36140:                 Whitespace(
 36140:                     '// Recursively shutting down %s kids\n'% (managed.name()),
 36140:                     indent=1),
 36140:                 StmtDecl(
 36140:                     Decl(p.managedVarType(managed, self.side), kidsvar.name),
 36140:                     init=p.managedVar(managed, self.side)),
 36140:                 foreachdestroy,
 36140:             ])
 36140:             destroysubtree.addstmt(block)
 63894: 
 63894:         if len(ptype.manages):
 63894:             destroysubtree.addstmt(Whitespace.NL)
 63894:         destroysubtree.addstmts([ Whitespace('// Finally, destroy "us".\n',
 63894:                                              indent=1),
 63894:                                   StmtExpr(ExprCall(_destroyMethod(),
 63894:                                                     args=[ whyvar ]))
 63894:                                 ])
 36140: 
 36140:         self.cls.addstmts([ destroysubtree, Whitespace.NL ])
 36140: 
 36140:         ## DeallocSubtree()
 36140:         deallocsubtree = MethodDefn(MethodDecl(deallocsubtreevar.name))
 38105:         for managed in ptype.manages:
 36140:             foreachrecurse = StmtFor(
 36140:                 init=Param(Type.UINT32, ivar.name, ExprLiteral.ZERO),
 36140:                 cond=ExprBinary(ivar, '<', _callCxxArrayLength(kidsvar)),
 36140:                 update=ExprPrefixUnop(ivar, '++'))
 36140:             foreachrecurse.addstmt(StmtExpr(ExprCall(
 36140:                 ExprSelect(ithkid, '->', deallocsubtreevar.name))))
 36140: 
 36140:             foreachdealloc = StmtFor(
 36140:                 init=Param(Type.UINT32, ivar.name, ExprLiteral.ZERO),
 36140:                 cond=ExprBinary(ivar, '<', _callCxxArrayLength(kidsvar)),
 36140:                 update=ExprPrefixUnop(ivar, '++'))
 36140:             foreachdealloc.addstmts([
 36140:                 StmtExpr(ExprCall(_deallocMethod(managed),
 36140:                                   args=[ ithkid ]))
 36140:             ])
 36140: 
 36140:             block = StmtBlock()
 36140:             block.addstmts([
 36140:                 Whitespace(
 36140:                     '// Recursively deleting %s kids\n'% (managed.name()),
 36140:                     indent=1),
 36140:                 StmtDecl(
 36140:                     Decl(p.managedVarType(managed, self.side, ref=1),
 36140:                          kidsvar.name),
 36140:                     init=p.managedVar(managed, self.side)),
 36140:                 foreachrecurse,
 36140:                 Whitespace.NL,
 36140:                 # no need to copy |kids| here; we're the ones deleting
 36140:                 # stragglers, no outside C++ is being invoked (except
 36140:                 # Dealloc(subactor))
 36140:                 foreachdealloc,
 36140:                 StmtExpr(_callCxxArrayClear(p.managedVar(managed, self.side))),
 36140: 
 36140:             ])
 36140:             deallocsubtree.addstmt(block)
 36140:         # don't delete outselves: either the manager will do it, or
 36140:         # we're toplevel
 36140:         self.cls.addstmts([ deallocsubtree, Whitespace.NL ])
 36140: 
 41363:         if ptype.isToplevel():
 41363:             ## DeallocShmem():
 41363:             #    for (cit = map.begin(); cit != map.end(); ++cit)
 41363:             #      Dealloc(cit->second)
 41363:             #    map.Clear()
 41363:             deallocshmem = MethodDefn(MethodDecl(deallocshmemvar.name))
 41363: 
 41363:             citvar = ExprVar('cit')
 41363:             begin = ExprCall(ExprSelect(p.shmemMapVar(), '.', 'begin'))
 41363:             end = ExprCall(ExprSelect(p.shmemMapVar(), '.', 'end'))
 41363:             shmem = ExprSelect(citvar, '->', 'second')
 41363:             foreachdealloc = StmtFor(
 41363:                 Param(p.shmemIteratorType(), citvar.name, begin),
 41363:                 ExprBinary(citvar, '!=', end),
 41363:                 ExprPrefixUnop(citvar, '++'))
 41363:             foreachdealloc.addstmt(StmtExpr(_shmemDealloc(shmem)))
 41363: 
 41363:             deallocshmem.addstmts([
 41363:                 foreachdealloc,
 41363:                 StmtExpr(ExprCall(ExprSelect(p.shmemMapVar(), '.', 'Clear')))
 41363:             ])
 41363:             self.cls.addstmts([ deallocshmem, Whitespace.NL ])
 41363: 
 42563:         self.implementPickling()
 42563: 
 36136:         ## private members
 36136:         self.cls.addstmt(StmtDecl(Decl(p.channelType(), 'mChannel')))
 38105:         if ptype.isToplevel():
 35990:             self.cls.addstmts([
 35990:                 StmtDecl(Decl(Type('IDMap', T=Type('ChannelListener')),
 35990:                               p.actorMapVar().name)),
 36016:                 StmtDecl(Decl(_actorIdType(), p.lastActorIdVar().name)),
 36016:                 StmtDecl(Decl(Type('ProcessHandle'),
 36016:                               p.otherProcessVar().name))
 35990:             ])
 38105:         elif ptype.isManaged():
 35990:             self.cls.addstmts([
 38096:                 StmtDecl(Decl(p.managerInterfaceType(ptr=1),
 95599:                               p.managerVar().name)),
 95599:                 StmtDecl(Decl(_actorIdType(), p.idVar().name))
 35990:             ])
 39732:         if p.decl.type.isToplevel():
 36134:             self.cls.addstmts([
 41363:                 StmtDecl(Decl(p.shmemMapType(), p.shmemMapVar().name)),
 36134:                 StmtDecl(Decl(_shmemIdType(), p.lastShmemIdVar().name))
 36134:             ])
 35990: 
 47709:         self.cls.addstmt(StmtDecl(Decl(Type('State'), p.stateVar().name)))
 47709: 
 38105:         for managed in ptype.manages:
 36139:             self.cls.addstmts([
 36139:                 Whitespace('// Sorted by pointer value\n', indent=1),
 36139:                 StmtDecl(Decl(
 36140:                     p.managedVarType(managed, self.side),
 36139:                     p.managedVar(managed, self.side).name)) ])
 36139: 
 35990:     def implementManagerIface(self):
 35990:         p = self.protocol
 35990:         routedvar = ExprVar('aRouted')
 35990:         idvar = ExprVar('aId')
 41362:         shmemvar = ExprVar('aShmem')
 42562:         rawvar = ExprVar('segment')
 39732:         sizevar = ExprVar('aSize')
 40908:         typevar = ExprVar('type')
 56896:         unsafevar = ExprVar('unsafe')
 35990:         listenertype = Type('ChannelListener', ptr=1)
 35990: 
 35990:         register = MethodDefn(MethodDecl(
 35990:             p.registerMethod().name,
 35990:             params=[ Decl(listenertype, routedvar.name) ],
 35990:             ret=_actorIdType(), virtual=1))
 35990:         registerid = MethodDefn(MethodDecl(
 35990:             p.registerIDMethod().name,
 35990:             params=[ Decl(listenertype, routedvar.name),
 35990:                      Decl(_actorIdType(), idvar.name) ],
 35990:             ret=_actorIdType(),
 35744:             virtual=1))
 35990:         lookup = MethodDefn(MethodDecl(
 35990:             p.lookupIDMethod().name,
 35990:             params=[ Decl(_actorIdType(), idvar.name) ],
 35990:             ret=listenertype, virtual=1))
 35990:         unregister = MethodDefn(MethodDecl(
 35990:             p.unregisterMethod().name,
 35990:             params=[ Decl(_actorIdType(), idvar.name) ],
 35812:             virtual=1))
 39732: 
 39732:         createshmem = MethodDefn(MethodDecl(
 39732:             p.createSharedMemory().name,
 39732:             ret=_rawShmemType(ptr=1),
 39732:             params=[ Decl(Type.SIZE, sizevar.name),
 40908:                      Decl(_shmemTypeType(), typevar.name),
 56896:                      Decl(Type.BOOL, unsafevar.name),
 39732:                      Decl(_shmemIdType(ptr=1), idvar.name) ],
 39732:             virtual=1))
 42562:         adoptshmem = MethodDefn(MethodDecl(
 42562:             p.adoptSharedMemory().name,
 42562:             ret=Type.BOOL,
 42562:             params=[ Decl(_rawShmemType(ptr=1), rawvar.name),
 42562:                      Decl(_shmemIdType(ptr=1), idvar.name) ],
 42562:             virtual=1))
 39732:         lookupshmem = MethodDefn(MethodDecl(
 39732:             p.lookupSharedMemory().name,
 39732:             ret=_rawShmemType(ptr=1),
 39732:             params=[ Decl(_shmemIdType(), idvar.name) ],
 39732:             virtual=1))
 41362:         destroyshmem = MethodDefn(MethodDecl(
 41362:             p.destroySharedMemory().name,
 41362:             ret=Type.BOOL,
 41362:             params=[ Decl(_shmemType(ref=1), shmemvar.name) ],
 41362:             virtual=1))
 42562:         istracking = MethodDefn(MethodDecl(
 42562:             p.isTrackingSharedMemory().name,
 42562:             ret=Type.BOOL,
 42562:             params=[ Decl(_rawShmemType(ptr=1), rawvar.name) ],
 42562:             virtual=1))
 39732: 
 36016:         otherprocess = MethodDefn(MethodDecl(
 36016:             p.otherProcessMethod().name,
 36016:             ret=Type('ProcessHandle'),
 36136:             const=1,
 36016:             virtual=1))
 71239:         getchannel = MethodDefn(MethodDecl(
 71239:             p.getChannelMethod().name,
 71239:             ret=Type('AsyncChannel', ptr=1),
 71239:             virtual=1))
 35990: 
 35744:         if p.decl.type.isToplevel():
 35990:             tmpvar = ExprVar('tmp')
 40908:             
 35990:             register.addstmts([
 35990:                 StmtDecl(Decl(_actorIdType(), tmpvar.name),
 35990:                          p.nextActorIdExpr(self.side)),
 35990:                 StmtExpr(ExprCall(
 35990:                     ExprSelect(p.actorMapVar(), '.', 'AddWithID'),
 35990:                     [ routedvar, tmpvar ])),
 35990:                 StmtReturn(tmpvar)
 35990:             ])
 35990:             registerid.addstmts([
 35990:                 StmtExpr(
 35990:                     ExprCall(ExprSelect(p.actorMapVar(), '.', 'AddWithID'),
 35990:                              [ routedvar, idvar ])),
 35990:                 StmtReturn(idvar)
 35990:             ])
 35990:             lookup.addstmt(StmtReturn(
 35990:                 ExprCall(ExprSelect(p.actorMapVar(), '.', 'Lookup'),
 35990:                          [ idvar ])))
 35990:             unregister.addstmt(StmtReturn(
 35990:                 ExprCall(ExprSelect(p.actorMapVar(), '.', 'Remove'),
 35990:                          [ idvar ])))
 39732: 
 56896:             # SharedMemory* CreateSharedMemory(size, type, bool, id_t*):
 56896:             #   nsAutoPtr<SharedMemory> seg(Shmem::Alloc(size, type, unsafe));
 39732:             #   if (!shmem)
 82295:             #     return null;
 40908:             #   Shmem s(seg, [nextshmemid]);
 40908:             #   Message descriptor;
 41362:             #   if (!s->ShareTo(subprocess, mId, descriptor) ||
 41362:             #       !Send(descriptor))
 42562:             #     return null;
 40908:             #   mShmemMap.Add(seg, id);
 39732:             #   return shmem.forget();
 39732:             createshmem.addstmt(StmtDecl(
 39732:                 Decl(_autoptr(_rawShmemType()), rawvar.name),
 56896:                 initargs=[ _shmemAlloc(sizevar, typevar, unsafevar) ]))
 39732:             failif = StmtIf(ExprNot(rawvar))
 42562:             failif.addifstmt(StmtReturn(ExprLiteral.NULL))
 39732:             createshmem.addstmt(failif)
 39732: 
 40908:             descriptorvar = ExprVar('descriptor')
 40908:             createshmem.addstmts([
 40908:                 StmtDecl(
 40908:                     Decl(_shmemType(), shmemvar.name),
 40908:                     initargs=[ _shmemBackstagePass(),
 40908:                                _autoptrGet(rawvar),
 40908:                                p.nextShmemIdExpr(self.side) ]),
 40908:                 StmtDecl(Decl(Type('Message', ptr=1), descriptorvar.name),
 40908:                          init=_shmemShareTo(shmemvar,
 71247:                                             p.callOtherProcess(),
 40908:                                             p.routingId()))
 40908:             ])
 40908:             failif = StmtIf(ExprNot(descriptorvar))
 82295:             failif.addifstmt(StmtReturn(ExprLiteral.NULL))
 39732:             createshmem.addstmt(failif)
 39732: 
 40908:             failif = StmtIf(ExprNot(ExprCall(
 40908:                 ExprSelect(p.channelVar(), p.channelSel(), 'Send'),
 40908:                 args=[ descriptorvar ])))
 40908:             createshmem.addstmt(failif)
 40908: 
 39732:             createshmem.addstmts([
 40908:                 StmtExpr(ExprAssn(ExprDeref(idvar), _shmemId(shmemvar))),
 40908:                 StmtExpr(ExprCall(
 39732:                     ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
 40908:                     args=[ rawvar, ExprDeref(idvar) ])),
 39732:                 StmtReturn(_autoptrForget(rawvar))
 39732:             ])
 39732: 
 42562:             # SharedMemory* AdoptSharedMemory(SharedMemory*, id_t*):
 42562:             #   Shmem s(seg, [nextshmemid]);
 42562:             #   Message descriptor;
 42562:             #   if (!s->ShareTo(subprocess, mId, descriptor) ||
 42562:             #       !Send(descriptor))
 42562:             #     return false;
 42562:             #   mShmemMap.Add(seg, id);
 42562:             #   seg->AddRef();
 42562:             #   return true;
 42562: 
 42562:             # XXX this is close to the same code as above, could be
 42562:             # refactored
 42562:             descriptorvar = ExprVar('descriptor')
 42562:             adoptshmem.addstmts([
 42562:                 StmtDecl(
 42562:                     Decl(_shmemType(), shmemvar.name),
 42562:                     initargs=[ _shmemBackstagePass(),
 42562:                                rawvar,
 42562:                                p.nextShmemIdExpr(self.side) ]),
 42562:                 StmtDecl(Decl(Type('Message', ptr=1), descriptorvar.name),
 42562:                          init=_shmemShareTo(shmemvar,
 71247:                                             p.callOtherProcess(),
 42562:                                             p.routingId()))
 42562:             ])
 42562:             failif = StmtIf(ExprNot(descriptorvar))
 42569:             failif.addifstmt(StmtReturn.FALSE)
 42562:             adoptshmem.addstmt(failif)
 42562: 
 42562:             failif = StmtIf(ExprNot(ExprCall(
 42562:                 ExprSelect(p.channelVar(), p.channelSel(), 'Send'),
 42562:                 args=[ descriptorvar ])))
 42562:             adoptshmem.addstmt(failif)
 42562: 
 42562:             adoptshmem.addstmts([
 42562:                 StmtExpr(ExprAssn(ExprDeref(idvar), _shmemId(shmemvar))),
 42562:                 StmtExpr(ExprCall(
 42562:                     ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
 42562:                     args=[ rawvar, ExprDeref(idvar) ])),
 42562:                 StmtExpr(ExprCall(ExprSelect(rawvar, '->', 'AddRef'))),
 42569:                 StmtReturn.TRUE
 42562:             ])
 42562: 
 40908:             # SharedMemory* Lookup(id)
 39732:             lookupshmem.addstmt(StmtReturn(ExprCall(
 39732:                 ExprSelect(p.shmemMapVar(), '.', 'Lookup'),
 39732:                 args=[ idvar ])))
 39732: 
 42562:             # bool IsTrackingSharedMemory(mem)
 42562:             istracking.addstmt(StmtReturn(ExprCall(
 42562:                 ExprSelect(p.shmemMapVar(), '.', 'HasData'),
 42562:                 args=[ rawvar ])))
 42562: 
 41362:             # bool DestroySharedMemory(shmem):
 41362:             #   id = shmem.Id()
 41362:             #   SharedMemory* rawmem = Lookup(id)
 41362:             #   if (!rawmem)
 41362:             #     return false;
 41362:             #   Message descriptor = UnShare(subprocess, mId, descriptor)
 41362:             #   mShmemMap.Remove(id)
 41362:             #   Shmem::Dealloc(rawmem)
 41362:             #   return descriptor && Send(descriptor)
 41362:             destroyshmem.addstmts([
 41362:                 StmtDecl(Decl(_shmemIdType(), idvar.name),
 41362:                          init=_shmemId(shmemvar)),
 41362:                 StmtDecl(Decl(_rawShmemType(ptr=1), rawvar.name),
 41362:                          init=_lookupShmem(idvar))
 41362:             ])
 41362: 
 41362:             failif = StmtIf(ExprNot(rawvar))
 42569:             failif.addifstmt(StmtReturn.FALSE)
 41362:             destroyshmem.addstmts([
 41362:                 failif,
 41362:                 StmtDecl(Decl(Type('Message', ptr=1), descriptorvar.name),
 41362:                          init=_shmemUnshareFrom(
 41362:                              shmemvar,
 71247:                              p.callOtherProcess(),
 41362:                              p.routingId())),
 41362:                 Whitespace.NL,
 41362:                 StmtExpr(p.removeShmemId(idvar)),
 41362:                 StmtExpr(_shmemDealloc(rawvar)),
 41362:                 Whitespace.NL,
 41362:                 StmtReturn(ExprBinary(
 41362:                     descriptorvar, '&&',
 41362:                     ExprCall(
 41362:                         ExprSelect(p.channelVar(), p.channelSel(), 'Send'),
 41362:                         args=[ descriptorvar ])))
 41362:             ])
 41362: 
 41362: 
 39732:             # "private" message that passes shmem mappings from one process
 39732:             # to the other
 41364:             if p.subtreeUsesShmem():
 39732:                 self.asyncSwitch.addcase(
 39732:                     CaseLabel('SHMEM_CREATED_MESSAGE_TYPE'),
 39732:                     self.genShmemCreatedHandler())
 41362:                 self.asyncSwitch.addcase(
 41362:                     CaseLabel('SHMEM_DESTROYED_MESSAGE_TYPE'),
 41362:                     self.genShmemDestroyedHandler())
 41362:             else:
 41362:                 abort = StmtBlock()
 41362:                 abort.addstmts([
 41362:                     _runtimeAbort('this protocol tree does not use shmem'),
 41362:                     StmtReturn(_Result.NotKnown)
 41362:                 ])
 41362:                 self.asyncSwitch.addcase(
 41362:                     CaseLabel('SHMEM_CREATED_MESSAGE_TYPE'), abort)
 41362:                 self.asyncSwitch.addcase(
 41362:                     CaseLabel('SHMEM_DESTROYED_MESSAGE_TYPE'), abort)
 39732:             
 36016:             otherprocess.addstmt(StmtReturn(p.otherProcessVar()))
 71239:             getchannel.addstmt(StmtReturn(ExprAddrOf(p.channelVar())))
 38094:         else:
 35990:             # delegate registration to manager
 35990:             register.addstmt(StmtReturn(ExprCall(
 35990:                 ExprSelect(p.managerVar(), '->', p.registerMethod().name),
 35990:                 [ routedvar ])))
 35990:             registerid.addstmt(StmtReturn(ExprCall(
 35990:                 ExprSelect(p.managerVar(), '->', p.registerIDMethod().name),
 35990:                 [ routedvar, idvar ])))
 35990:             lookup.addstmt(StmtReturn(ExprCall(
 35990:                 ExprSelect(p.managerVar(), '->', p.lookupIDMethod().name),
 35990:                 [ idvar ])))
 35990:             unregister.addstmt(StmtReturn(ExprCall(
 35990:                 ExprSelect(p.managerVar(), '->', p.unregisterMethod().name),
 35990:                 [ idvar ])))
 39732:             createshmem.addstmt(StmtReturn(ExprCall(
 39732:                 ExprSelect(p.managerVar(), '->', p.createSharedMemory().name),
 56896:                 [ sizevar, typevar, unsafevar, idvar ])))
 42562:             adoptshmem.addstmt(StmtReturn(ExprCall(
 42562:                 ExprSelect(p.managerVar(), '->', p.adoptSharedMemory().name),
 42562:                 [ rawvar, idvar ])))
 39732:             lookupshmem.addstmt(StmtReturn(ExprCall(
 39732:                 ExprSelect(p.managerVar(), '->', p.lookupSharedMemory().name),
 39732:                 [ idvar ])))
 42562:             istracking.addstmt(StmtReturn(ExprCall(
 42562:                 ExprSelect(p.managerVar(), '->',
 42562:                            p.isTrackingSharedMemory().name),
 42562:                 [ rawvar ])))
 41362:             destroyshmem.addstmt(StmtReturn(ExprCall(
 41362:                 ExprSelect(p.managerVar(), '->', p.destroySharedMemory().name),
 41362:                 [ shmemvar ])))
 71247:             otherprocess.addstmt(StmtReturn(
 71247:                 p.callOtherProcess(p.managerVar())))
 71239:             getchannel.addstmt(StmtReturn(p.channelVar()))
 36016: 
 38094:         # all protocols share the "same" RemoveManagee() implementation
 38094:         pvar = ExprVar('aProtocolId')
 38094:         listenervar = ExprVar('aListener')
 38094:         removemanagee = MethodDefn(MethodDecl(
 38094:             p.removeManageeMethod().name,
 38094:             params=[ Decl(_protocolIdType(), pvar.name),
 38094:                      Decl(listenertype, listenervar.name) ],
 38094:             virtual=1))
 38094: 
 64455:         if not len(p.managesStmts):
 64455:             removemanagee.addstmts([ _runtimeAbort('unreached'), StmtReturn() ])
 64455:         else:
 38094:             switchontype = StmtSwitch(pvar)
 38094:             for managee in p.managesStmts:
 38094:                 case = StmtBlock()
 38094:                 actorvar = ExprVar('actor')
 38094:                 manageeipdltype = managee.decl.type
 42563:                 manageecxxtype = _cxxBareType(ipdl.type.ActorType(manageeipdltype),
 38094:                                               self.side)
 38094:                 manageearray = p.managedVar(manageeipdltype, self.side)
 38094: 
 38094:                 case.addstmts([
 38094:                     StmtDecl(Decl(manageecxxtype, actorvar.name),
 38094:                              ExprCast(listenervar, manageecxxtype, static=1)),
 38094:                     _abortIfFalse(
 38094:                         _cxxArrayHasElementSorted(manageearray, actorvar),
 38094:                         "actor not managed by this!"),
 38094:                     Whitespace.NL,
 38094:                     StmtExpr(_callCxxArrayRemoveSorted(manageearray, actorvar)),
 38095:                     StmtExpr(ExprCall(_deallocMethod(manageeipdltype),
 38095:                                       args=[ actorvar ])),
 38094:                     StmtReturn()
 38094:                 ])
 38094:                 switchontype.addcase(CaseLabel(_protocolId(manageeipdltype).name),
 38094:                                      case)
 38094:             default = StmtBlock()
 38094:             default.addstmts([ _runtimeAbort('unreached'), StmtReturn() ])
 38094:             switchontype.addcase(DefaultLabel(), default)
 38094:             removemanagee.addstmt(switchontype)
 38094: 
 36016:         return [ register,
 36016:                  registerid,
 36016:                  lookup,
 36016:                  unregister,
 38094:                  removemanagee,
 39732:                  createshmem,
 42562:                  adoptshmem,
 39732:                  lookupshmem,
 42562:                  istracking,
 41362:                  destroyshmem,
 36016:                  otherprocess,
 71239:                  getchannel,
 36016:                  Whitespace.NL ]
 36016: 
 36134:     def makeShmemIface(self):
 36134:         p = self.protocol
 36134:         idvar = ExprVar('aId')
 39312:         sizevar = ExprVar('aSize')
 40908:         typevar = ExprVar('aType')
 39312:         memvar = ExprVar('aMem')
 42562:         outmemvar = ExprVar('aOutMem')
 39732:         rawvar = ExprVar('rawmem')
 46953: 
 56896:         def allocShmemMethod(name, unsafe):
 56896:             # bool Alloc*Shmem(size_t size, Type type, Shmem* outmem):
 39732:             #   id_t id;
 39732:             #   nsAutoPtr<SharedMemory> mem(CreateSharedMemory(&id));
 39732:             #   if (!mem)
 46953:             #     return false;
 42562:             #   *outmem = Shmem(mem, id)
 46953:             #   return true;
 56896:             method = MethodDefn(MethodDecl(
 56896:                 name,
 36134:                 params=[ Decl(Type.SIZE, sizevar.name),
 40908:                          Decl(_shmemTypeType(), typevar.name),
 36134:                          Decl(_shmemType(ptr=1), memvar.name) ],
 36134:                 ret=Type.BOOL))
 36134: 
 39732:             ifallocfails = StmtIf(ExprNot(rawvar))
 42569:             ifallocfails.addifstmt(StmtReturn.FALSE)
 36134: 
 56896:             if unsafe:
 56896:                 unsafe = ExprLiteral.TRUE
 56896:             else:
 56896:                 unsafe = ExprLiteral.FALSE
 56896:             method.addstmts([
 39732:                 StmtDecl(Decl(_shmemIdType(), idvar.name)),
 39732:                 StmtDecl(Decl(_autoptr(_rawShmemType()), rawvar.name),
 39732:                          initargs=[ ExprCall(p.createSharedMemory(),
 39732:                                          args=[ sizevar,
 40908:                                                 typevar,
 56896:                                                 unsafe,
 39732:                                                 ExprAddrOf(idvar) ]) ]),
 39732:                 ifallocfails,
 39732:                 Whitespace.NL,
 36134:                 StmtExpr(ExprAssn(
 36134:                     ExprDeref(memvar), _shmemCtor(_autoptrForget(rawvar), idvar))),
 42569:                 StmtReturn.TRUE
 36134:             ])
 56896:             return method
 56896: 
 56896:         # bool AllocShmem(size_t size, Type type, Shmem* outmem):
 56896:         allocShmem = allocShmemMethod('AllocShmem', False)
 56896: 
 56896:         # bool AllocUnsafeShmem(size_t size, Type type, Shmem* outmem):
 56896:         allocUnsafeShmem = allocShmemMethod('AllocUnsafeShmem', True)
 36134: 
 42562:         # bool AdoptShmem(const Shmem& mem, Shmem* outmem):
 42562:         #   SharedMemory* raw = mem.mSegment;
 42562:         #   if (!raw || IsTrackingSharedMemory(raw))
 42562:         #     RUNTIMEABORT()
 42562:         #   id_t id
 42562:         #   if (!AdoptSharedMemory(raw, &id))
 42562:         #     return false
 42562:         #   *outmem = Shmem(raw, id);
 42562:         #   return true;
 42562:         adoptShmem = MethodDefn(MethodDecl(
 42562:             'AdoptShmem',
 42562:             params=[ Decl(_shmemType(const=1, ref=1), memvar.name),
 42562:                      Decl(_shmemType(ptr=1), outmemvar.name) ],
 42562:             ret=Type.BOOL))
 42562: 
 42562:         adoptShmem.addstmt(StmtDecl(Decl(_rawShmemType(ptr=1), rawvar.name),
 42562:                                     init=_shmemSegment(memvar)))
 42562:         ifbad = StmtIf(ExprBinary(
 42562:             ExprNot(rawvar), '||',
 42562:             ExprCall(ExprVar('IsTrackingSharedMemory'), args=[ rawvar ])))
 42562:         ifbad.addifstmt(_runtimeAbort('bad Shmem'))
 42562:         adoptShmem.addstmt(ifbad)
 42562: 
 42562:         ifadoptfails = StmtIf(ExprNot(ExprCall(
 42562:             p.adoptSharedMemory(), args=[ rawvar, ExprAddrOf(idvar) ])))
 42569:         ifadoptfails.addifstmt(StmtReturn.FALSE)
 42562: 
 42562:         adoptShmem.addstmts([
 42562:             Whitespace.NL,
 42562:             StmtDecl(Decl(_shmemIdType(), idvar.name)),
 42562:             ifadoptfails,
 42562:             Whitespace.NL,
 42562:             StmtExpr(ExprAssn(ExprDeref(outmemvar),
 42562:                               _shmemCtor(rawvar, idvar))),
 42569:             StmtReturn.TRUE
 46953:         ])
 46953: 
 41362:         # bool DeallocShmem(Shmem& mem):
 41362:         #   bool ok = DestroySharedMemory(mem);
 41362:         #   mem.forget();
 41362:         #   return ok;
 41362:         deallocShmem = MethodDefn(MethodDecl(
 41362:             'DeallocShmem',
 41362:             params=[ Decl(_shmemType(ref=1), memvar.name) ],
 41362:             ret=Type.BOOL))
 41362:         okvar = ExprVar('ok')
 41362: 
 41362:         deallocShmem.addstmts([
 41362:             StmtDecl(Decl(Type.BOOL, okvar.name),
 41362:                      init=ExprCall(p.destroySharedMemory(),
 41362:                                    args=[ memvar ])),
 41362:             StmtExpr(_shmemForget(memvar)),
 41362:             StmtReturn(okvar)
 46953:         ])
 46953: 
 39732:         return [ Whitespace('// Methods for managing shmem\n', indent=1),
 36134:                  allocShmem,
 46953:                  Whitespace.NL,
 56896:                  allocUnsafeShmem,
 56896:                  Whitespace.NL,
 42562:                  adoptShmem,
 42562:                  Whitespace.NL,
 41362:                  deallocShmem,
 39732:                  Whitespace.NL ]
 36134: 
 36134:     def genShmemCreatedHandler(self):
 39732:         p = self.protocol
 39732:         assert p.decl.type.isToplevel()
 39732:         
 36134:         case = StmtBlock()                                          
 36134: 
 40908:         rawvar = ExprVar('rawmem')
 36134:         idvar = ExprVar('id')
 40908:         case.addstmts([
 40908:             StmtDecl(Decl(_shmemIdType(), idvar.name)),
 40908:             StmtDecl(Decl(_autoptr(_rawShmemType()), rawvar.name),
 40908:                      initargs=[ _shmemOpenExisting(self.msgvar,
 40908:                                                    ExprAddrOf(idvar)) ])
 40908:         ])
 40908:         failif = StmtIf(ExprNot(rawvar))
 39312:         failif.addifstmt(StmtReturn(_Result.PayloadError))
 39312: 
 39312:         case.addstmts([
 39312:             failif,
 39732:             StmtExpr(ExprCall(
 39732:                 ExprSelect(p.shmemMapVar(), '.', 'AddWithID'),
 39312:                 args=[ _autoptrForget(rawvar), idvar ])),
 39312:             Whitespace.NL,
 39312:             StmtReturn(_Result.Processed)
 39312:         ])
 39312: 
 39312:         return case
 39312: 
 41362:     def genShmemDestroyedHandler(self):
 41362:         p = self.protocol
 41362:         assert p.decl.type.isToplevel()
 41362:         
 41362:         case = StmtBlock()                                          
 41362: 
 36134:         rawvar = ExprVar('rawmem')
 41362:         idvar = ExprVar('id')
 41362:         itervar = ExprVar('iter')
 41362:         case.addstmts([
 41362:             StmtDecl(Decl(_shmemIdType(), idvar.name)),
 41362:             StmtDecl(Decl(Type.VOIDPTR, itervar.name), init=ExprLiteral.NULL)
 41362:         ])
 41362: 
 41362:         failif = StmtIf(ExprNot(
 41362:             ExprCall(ExprVar('IPC::ReadParam'),
 41362:                      args=[ ExprAddrOf(self.msgvar), ExprAddrOf(itervar),
 41362:                             ExprAddrOf(idvar) ])))
 36134:         failif.addifstmt(StmtReturn(_Result.PayloadError))
 36134: 
 36134:         case.addstmts([
 41362:             failif,
 41362:             StmtExpr(ExprCall(ExprSelect(self.msgvar, '.', 'EndRead'),
 41362:                               args=[ itervar ])),
 36134:             Whitespace.NL,
 41362:             StmtDecl(Decl(_rawShmemType(ptr=1), rawvar.name),
 41362:                      init=ExprCall(p.lookupSharedMemory(), args=[ idvar ]))
 36134:         ])
 36134: 
 36134:         failif = StmtIf(ExprNot(rawvar))
 36134:         failif.addifstmt(StmtReturn(_Result.ValuError))
 36134: 
 36134:         case.addstmts([
 36134:             failif,
 41362:             StmtExpr(p.removeShmemId(idvar)),
 41362:             StmtExpr(_shmemDealloc(rawvar)),
 36134:             StmtReturn(_Result.Processed)
 36134:         ])
 36134: 
 36134:         return case
 36134: 
 35990: 
 71253:     def makeChannelOpenedHandlers(self, actors):
 71247:         handlers = StmtBlock()
 71247: 
 71247:         # unpack the transport descriptor et al.
 71247:         msgvar = self.msgvar
 71247:         tdvar = ExprVar('td')
 71247:         pidvar = ExprVar('pid')
 71247:         pvar = ExprVar('p')
 71247:         iffail = StmtIf(ExprNot(ExprCall(
 71247:             ExprVar('mozilla::ipc::UnpackChannelOpened'),
 71247:             args=[ _backstagePass(),
 71247:                    msgvar,
 71247:                    ExprAddrOf(tdvar), ExprAddrOf(pidvar), ExprAddrOf(pvar) ])))
 71247:         iffail.addifstmt(StmtReturn(_Result.PayloadError))
 71247:         handlers.addstmts([
 71247:             StmtDecl(Decl(Type('TransportDescriptor'), tdvar.name)),
 71247:             StmtDecl(Decl(Type('ProcessId'), pidvar.name)),
 71247:             StmtDecl(Decl(Type('ProtocolId'), pvar.name)),
 71247:             iffail,
 71247:             Whitespace.NL
 71247:         ])
 71247: 
 71247:         def makeHandlerCase(actor):
 71247:             case = StmtBlock()
 71253:             modevar = _sideToTransportMode(actor.side)
 71247:             tvar = ExprVar('t')
 71247:             iffailopen = StmtIf(ExprNot(ExprAssn(
 71247:                 tvar,
 71247:                 ExprCall(ExprVar('mozilla::ipc::OpenDescriptor'),
 71247:                          args=[ tdvar, modevar ]))))
 71247:             iffailopen.addifstmt(StmtReturn(_Result.ValuError))
 71247: 
 71247:             iffailalloc = StmtIf(ExprNot(ExprCall(
 71247:                 _allocMethod(actor.ptype),
 71247:                 args=[ tvar, pidvar ])))
 71247:             iffailalloc.addifstmt(StmtReturn(_Result.ProcessingError))
 71247: 
 71247:             case.addstmts([
 71247:                 StmtDecl(Decl(Type('Transport', ptr=1), tvar.name)),
 71247:                 iffailopen,
 71247:                 iffailalloc,
 71247:                 StmtBreak()
 71247:             ])
 71247:             return CaseLabel(_protocolId(actor.ptype).name), case
 71247: 
 71247:         pswitch = StmtSwitch(pvar)
 71253:         for actor in actors:
 71247:             label, case = makeHandlerCase(actor)
 71247:             pswitch.addcase(label, case)
 71247: 
 71247:         die = Block()
 71247:         die.addstmts([ _runtimeAbort('Invalid protocol'),
 71247:                        StmtReturn(_Result.ValuError) ])
 71247:         pswitch.addcase(DefaultLabel(), die)
 71247: 
 71247:         handlers.addstmts([
 71247:             pswitch,
 71247:             StmtReturn(_Result.Processed)
 71247:         ])
 71247:         self.asyncSwitch.addcase(CaseLabel('CHANNEL_OPENED_MESSAGE_TYPE'),
 71247:                                  handlers)
 71247: 
 35990:     ##-------------------------------------------------------------------------
 35990:     ## The next few functions are the crux of the IPDL code generator.
 35990:     ## They generate code for all the nasty work of message
 35990:     ## serialization/deserialization and dispatching handlers for
 35990:     ## received messages.
 35990:     ##
 42563:     def implementPickling(self):
 42563:         # pickling of "normal", non-IPDL types
 42563:         self.implementGenericPickling()
 42563: 
 42563:         # pickling for IPDL types
 42563:         specialtypes = set()
 42563:         class findSpecialTypes(TypeVisitor):
 42563:             def visitActorType(self, a):  specialtypes.add(a)
 42563:             def visitShmemType(self, s):  specialtypes.add(s)
 42564:             def visitStructType(self, s):
 42564:                 specialtypes.add(s)
 42564:                 return TypeVisitor.visitStructType(self, s)
 42563:             def visitUnionType(self, u):
 42563:                 specialtypes.add(u)
 42563:                 return TypeVisitor.visitUnionType(self, u)
 42563:             def visitArrayType(self, a):
 42563:                 if a.basetype.isIPDL():
 42563:                     specialtypes.add(a)
 42563:                     return a.basetype.accept(self)
 42563: 
 42563:         for md in self.protocol.messageDecls:
 42563:             for param in md.params:
 42563:                 mtype = md.decl.type
 42563:                 # special case for top-level __delete__(), which isn't
 42563:                 # understood yet
 42563:                 if mtype.isDtor() and mtype.constructedType().isToplevel():
 42563:                     continue
 42563:                 param.ipdltype.accept(findSpecialTypes())
 42563:             for ret in md.returns:
 42563:                 ret.ipdltype.accept(findSpecialTypes())
 42563: 
 42563:         for t in specialtypes:
 42563:             if t.isActor():    self.implementActorPickling(t)
 42563:             elif t.isArray():  self.implementSpecialArrayPickling(t)
 42563:             elif t.isShmem():  self.implementShmemPickling(t)
 42564:             elif t.isStruct(): self.implementStructPickling(t)
 42563:             elif t.isUnion():  self.implementUnionPickling(t)
 42563:             else:
 42563:                 assert 0 and 'unknown special type'
 42563: 
 42563:     def implementGenericPickling(self):
 42563:         var = self.var
 42563:         msgvar = self.msgvar
 42563:         itervar = self.itervar
 42563: 
 42563:         write = MethodDefn(self.writeMethodDecl(
 42563:             Type('T', const=1, ref=1), var, template=Type('T')))
 42563:         write.addstmt(StmtExpr(ExprCall(ExprVar('IPC::WriteParam'),
 42563:                                         args=[ msgvar, var ])))
 42563: 
 42563:         read = MethodDefn(self.readMethodDecl(
 42563:             Type('T', ptr=1), var, template=Type('T')))
 42563:         read.addstmt(StmtReturn(ExprCall(ExprVar('IPC::ReadParam'),
 42563:                                          args=[ msgvar, itervar, var ])))
 42563: 
 42563:         self.cls.addstmts([ write, Whitespace.NL, read, Whitespace.NL ])
 42563: 
 42563: 
 42563:     def implementActorPickling(self, actortype):
 42563:         # Note that we pickle based on *protocol* type and *not* actor
 42563:         # type.  The actor type includes a |nullable| qualifier, but
 42563:         # this method is not specialized based on nullability.  The
 42563:         # |actortype| nullability is ignored in this method.
 42563:         var = self.var
 42563:         idvar = ExprVar('id')
 42563:         intype = _cxxConstRefType(actortype, self.side)
 42563:         cxxtype = _cxxBareType(actortype, self.side)
 42563:         outtype = _cxxPtrToType(actortype, self.side)
 42563: 
 42563:         ## Write([const] PFoo* var)
 42563:         write = MethodDefn(self.writeMethodDecl(intype, var))
 42563:         nullablevar = ExprVar('__nullable')
 42563:         write.decl.params.append(Decl(Type.BOOL, nullablevar.name))
 42563:         # id_t id;
 42563:         # if (!var)
 42563:         #   if(!nullable)
 42563:         #     abort()
 42563:         #   id = NULL_ID
 42563:         write.addstmt(StmtDecl(Decl(_actorIdType(), idvar.name)))
 42563: 
 42563:         ifnull = StmtIf(ExprNot(var))
 42563:         ifnotnullable = StmtIf(ExprNot(nullablevar))
 42563:         ifnotnullable.addifstmt(
 42563:             _runtimeAbort("NULL actor value passed to non-nullable param"))
 42563:         ifnull.addifstmt(ifnotnullable)
 42563:         ifnull.addifstmt(StmtExpr(ExprAssn(idvar, _NULL_ACTOR_ID)))
 42563:         # else
 42563:         #   id = var->mId
 42563:         #   if (id == FREED_ID)
 42563:         #     abort()
 42563:         # Write(msg, id)
 42563:         ifnull.addelsestmt(StmtExpr(ExprAssn(idvar, _actorId(var))))
 42563:         iffreed = StmtIf(ExprBinary(_FREED_ACTOR_ID, '==', idvar))
 42563:         # this is always a hard-abort, because it means that some C++
 42563:         # code has a live pointer to a freed actor, so we're playing
 42563:         # Russian roulette with invalid memory
 42563:         iffreed.addifstmt(_runtimeAbort("actor has been |delete|d"))
 42563:         ifnull.addelsestmt(iffreed)
 42563: 
 42563:         write.addstmts([
 42563:             ifnull,
 42563:             Whitespace.NL,
 42563:             StmtExpr(self.write(None, idvar, self.msgvar))
 42563:         ])
 42563: 
 42563:         ## Read(PFoo** var)
 42563:         read = MethodDefn(self.readMethodDecl(outtype, var))
 42563:         read.decl.params.append(Decl(Type.BOOL, nullablevar.name))
 42563: 
 42563:         # if (!Read(id, msg))
 42563:         #   return false
 42563:         # if (FREED_ID == id
 42563:         #     || NULL_ID == id && !nullable)
 42563:         #   return false
 42563:         read.addstmts([
 42563:             StmtDecl(Decl(_actorIdType(), idvar.name)),
 42563:             self.checkedRead(None, ExprAddrOf(idvar),
 42563:                              self.msgvar, self.itervar, errfnRead),
 42563:         ])
 42563: 
 42563:         ifbadid = StmtIf(ExprBinary(
 42563:             ExprBinary(_FREED_ACTOR_ID, '==', idvar),
 42563:             '||',
 42563:             ExprBinary(ExprBinary(_NULL_ACTOR_ID, '==', idvar),
 42563:                        '&&',
 42563:                        ExprNot(nullablevar))))
 42569:         ifbadid.addifstmt(StmtReturn.FALSE)
 42563:         read.addstmts([ ifbadid, Whitespace.NL ])
 42563:         
 42563:         # if (NULL_ID == id)
 42563:         #   *var = null
 42563:         # else
 42563:         #   *var = Lookup(id)
 42563:         #   if (!*var)
 42563:         #     return false
 42563:         outactor = ExprDeref(var)
 42563:         ifnull = StmtIf(ExprBinary(_NULL_ACTOR_ID, '==', idvar))
 42563:         ifnull.addifstmt(StmtExpr(ExprAssn(outactor, ExprLiteral.NULL)))
 42563: 
 42563:         ifnull.addelsestmt(StmtExpr(ExprAssn(
 42563:             outactor,
 42563:             ExprCast(_lookupListener(idvar), cxxtype, static=1))))
 42563: 
 42563:         ifnotfound = StmtIf(ExprNot(outactor))
 42569:         ifnotfound.addifstmt(StmtReturn.FALSE)
 42563:         ifnull.addelsestmt(ifnotfound)
 42563: 
 42563:         read.addstmts([
 42563:             ifnull,
 42569:             StmtReturn.TRUE
 42563:         ])
 42563: 
 42563:         self.cls.addstmts([ write, Whitespace.NL, read, Whitespace.NL ])
 42563: 
 42563: 
 42563:     def implementSpecialArrayPickling(self, arraytype):
 42563:         var = self.var
 42563:         msgvar = self.msgvar
 42563:         itervar = self.itervar
 42563:         lenvar = ExprVar('length')
 42563:         ivar = ExprVar('i')
 42563:         eltipdltype = arraytype.basetype
 42563:         intype = _cxxConstRefType(arraytype, self.side)
 42563:         outtype = _cxxPtrToType(arraytype, self.side)
 42563: 
 42563:         write = MethodDefn(self.writeMethodDecl(intype, var))
 42563:         forwrite = StmtFor(init=ExprAssn(Decl(Type.UINT32, ivar.name),
 42563:                                          ExprLiteral.ZERO),
 42563:                            cond=ExprBinary(ivar, '<', lenvar),
 42563:                            update=ExprPrefixUnop(ivar, '++'))
 42563:         forwrite.addstmt(StmtExpr(
 42563:             self.write(eltipdltype, ExprIndex(var, ivar), msgvar)))
 42563:         write.addstmts([
 42563:             StmtDecl(Decl(Type.UINT32, lenvar.name),
 42563:                      init=_callCxxArrayLength(var)),
 42563:             StmtExpr(self.write(None, lenvar, msgvar)),
 42563:             Whitespace.NL,
 42563:             forwrite
 42563:         ])
 42563: 
 42563:         read = MethodDefn(self.readMethodDecl(outtype, var))
 42563:         avar = ExprVar('a')
 42563:         forread = StmtFor(init=ExprAssn(Decl(Type.UINT32, ivar.name),
 42563:                                         ExprLiteral.ZERO),
 42563:                           cond=ExprBinary(ivar, '<', lenvar),
 42563:                           update=ExprPrefixUnop(ivar, '++'))
 42563:         forread.addstmt(
 42563:             self.checkedRead(eltipdltype, ExprAddrOf(ExprIndex(avar, ivar)),
 42563:                              msgvar, itervar, errfnRead))
 42563:         read.addstmts([
 42563:             StmtDecl(Decl(_cxxRefType(arraytype, self.side), avar.name),
 42563:                      init=ExprDeref(var)),
 42563:             StmtDecl(Decl(Type.UINT32, lenvar.name)),
 42563:             self.checkedRead(None, ExprAddrOf(lenvar),
 42563:                              msgvar, itervar, errfnRead),
 42563:             Whitespace.NL,
 42563:             StmtExpr(_callCxxArraySetLength(var, lenvar, '->')),
 42563:             forread,
 42569:             StmtReturn.TRUE
 42563:         ])
 42563: 
 42563:         self.cls.addstmts([ write, Whitespace.NL, read, Whitespace.NL ])
 42563: 
 42563: 
 42563:     def implementShmemPickling(self, shmemtype):
 42563:         msgvar = self.msgvar
 42563:         itervar = self.itervar
 42563:         var = self.var
 42563:         tmpvar = ExprVar('tmp')
 42563:         idvar = ExprVar('shmemid')
 42563:         rawvar = ExprVar('rawmem')
 42563:         baretype = _cxxBareType(shmemtype, self.side)
 42563:         intype = _cxxConstRefType(shmemtype, self.side)
 42563:         outtype = _cxxPtrToType(shmemtype, self.side)
 42563: 
 42563:         write = MethodDefn(self.writeMethodDecl(intype, var))
 42563:         write.addstmts([
 42563:             StmtExpr(ExprCall(ExprVar('IPC::WriteParam'),
 42563:                               args=[ msgvar, var ])),
 42563:             StmtExpr(_shmemRevokeRights(var)),
 42563:             StmtExpr(_shmemForget(var))
 42563:         ])
 42563: 
 42563:         read = MethodDefn(self.readMethodDecl(outtype, var))
 42563:         ifread = StmtIf(ExprNot(ExprCall(ExprVar('IPC::ReadParam'),
 42563:                                          args=[ msgvar, itervar,
 42563:                                                 ExprAddrOf(tmpvar) ])))
 42569:         ifread.addifstmt(StmtReturn.FALSE)
 42563: 
 42563:         iffound = StmtIf(rawvar)
 42563:         iffound.addifstmt(StmtExpr(ExprAssn(
 42563:             ExprDeref(var), _shmemCtor(rawvar, idvar))))
 42569:         iffound.addifstmt(StmtReturn.TRUE)
 42563: 
 42563:         read.addstmts([
 42563:             StmtDecl(Decl(_shmemType(), tmpvar.name)),
 42563:             ifread,
 42563:             Whitespace.NL,
 42563:             StmtDecl(Decl(_shmemIdType(), idvar.name),
 42563:                      init=_shmemId(tmpvar)),
 42563:             StmtDecl(Decl(_rawShmemType(ptr=1), rawvar.name),
 42563:                      init=_lookupShmem(idvar)),
 42563:             iffound,
 42569:             StmtReturn.FALSE
 42563:         ])
 42563: 
 42563:         self.cls.addstmts([ write, Whitespace.NL, read, Whitespace.NL ])
 42563: 
 42563: 
 42564:     def implementStructPickling(self, structtype):
 42564:         msgvar = self.msgvar
 42564:         itervar = self.itervar
 42564:         var = self.var
 42564:         intype = _cxxConstRefType(structtype, self.side)
 42564:         outtype = _cxxPtrToType(structtype, self.side)
101616:         sd = structtype._ast
 42564: 
 42564:         write = MethodDefn(self.writeMethodDecl(intype, var))
 42564:         read = MethodDefn(self.readMethodDecl(outtype, var))        
 42564: 
 42564:         def get(sel, f):
 42566:             return ExprCall(f.getMethod(thisexpr=var, sel=sel))
 42564: 
 42564:         for f in sd.fields:
 42564:             writefield = StmtExpr(self.write(f.ipdltype, get('.', f), msgvar))
 42564:             readfield = self.checkedRead(f.ipdltype,
 42564:                                          ExprAddrOf(get('->', f)),
 42564:                                          msgvar, itervar,
 42564:                                          errfn=errfnRead)
 42564:             if f.special and f.side != self.side:
 42564:                 writefield = Whitespace(
 42564:                     "// skipping actor field that's meaningless on this side\n", indent=1)
 42564:                 readfield = Whitespace(
 42564:                     "// skipping actor field that's meaningless on this side\n", indent=1)
 42564:             write.addstmt(writefield)
 42564:             read.addstmt(readfield)
 42564: 
 42569:         read.addstmt(StmtReturn.TRUE)
 42564: 
 42564:         self.cls.addstmts([ write, Whitespace.NL, read, Whitespace.NL ])
 42564: 
 42564: 
 42563:     def implementUnionPickling(self, uniontype):
 42563:         msgvar = self.msgvar
 42563:         itervar = self.itervar
 42563:         var = self.var
 42563:         intype = _cxxConstRefType(uniontype, self.side)
 42563:         outtype = _cxxPtrToType(uniontype, self.side)
101616:         ud = uniontype._ast
 42563: 
 42563:         typename = '__type'
 42563:         uniontdef = Typedef(_cxxBareType(uniontype, typename), typename)
 42563: 
 42563:         typevar = ExprVar('type')
 42563:         writeswitch = StmtSwitch(ud.callType(var))
 42563:         readswitch = StmtSwitch(typevar)
 42563: 
 42563:         for c in ud.components:
 42563:             ct = c.ipdltype
 42563:             isactor = (ct.isIPDL() and ct.isActor())
 42563:             caselabel = CaseLabel(typename +'::'+ c.enum())
 42563: 
 42563:             writecase = StmtBlock()
 42563:             if c.special and c.side != self.side:
 42563:                 writecase.addstmt(_runtimeAbort('wrong side!'))
 42563:             else:
 42563:                 wexpr = ExprCall(ExprSelect(var, '.', c.getTypeName()))
 42563:                 writecase.addstmt(StmtExpr(self.write(ct, wexpr, msgvar)))
 42563: 
 42563:             writecase.addstmt(StmtReturn())
 42563:             writeswitch.addcase(caselabel, writecase)
 42563: 
 42563:             readcase = StmtBlock()
 42563:             if c.special and c.side == self.side:
 42563:                 # the type comes across flipped from what the actor
 42563:                 # will be on this side; i.e. child->parent messages
 42563:                 # have type PFooChild when received on the parent side
 42563:                 # XXX: better error message
 42569:                 readcase.addstmt(StmtReturn.FALSE)
 42563:             else:
 42563:                 if c.special:
 42563:                     c = c.other       # see above
 52195:                 tmpvar = ExprVar('tmp')
 52195:                 ct = c.bareType()
 42563:                 readcase.addstmts([
 52195:                     StmtDecl(Decl(ct, tmpvar.name), init=c.defaultValue()),
 52195:                     StmtExpr(ExprAssn(ExprDeref(var), tmpvar)),
 42563:                     StmtReturn(self.read(
 42563:                         c.ipdltype,
 42563:                         ExprAddrOf(ExprCall(ExprSelect(var, '->',
 42563:                                                        c.getTypeName()))),
 42563:                         msgvar, itervar))
 42563:                 ])
 42563: 
 42563:             readswitch.addcase(caselabel, readcase)
 42563: 
 42563:         unknowntype = 'unknown union type'
 42563:         writeswitch.addcase(DefaultLabel(),
 42563:                             StmtBlock([ _runtimeAbort(unknowntype),
 42563:                                         StmtReturn() ]))
 42563:         readswitch.addcase(DefaultLabel(), StmtBlock(errfnRead(unknowntype)))
 42563: 
 42563:         write = MethodDefn(self.writeMethodDecl(intype, var))
 42563:         write.addstmts([
 42563:             uniontdef,
 42563:             StmtExpr(self.write(
 42563:                 None, ExprCall(Type.INT, args=[ ud.callType(var) ]), msgvar)),
 42563:             Whitespace.NL,
 42563:             writeswitch
 42563:         ])
 42563: 
 42563:         read = MethodDefn(self.readMethodDecl(outtype, var))
 42563:         read.addstmts([
 42563:             uniontdef,
 42563:             StmtDecl(Decl(Type.INT, typevar.name)),
 42563:             self.checkedRead(
 42563:                 None, ExprAddrOf(typevar), msgvar, itervar, errfnRead),
 42563:             Whitespace.NL,
 42563:             readswitch,
 42563:         ])
 42563: 
 42563:         self.cls.addstmts([ write, Whitespace.NL, read, Whitespace.NL ])
 42563: 
 42563: 
 42563:     def writeMethodDecl(self, intype, var, template=None):
 42563:         return MethodDecl(
 42563:             'Write',
 42563:             params=[ Decl(intype, var.name),
 42563:                      Decl(Type('Message', ptr=1), self.msgvar.name) ],
 42563:             T=template)
 42563: 
 42563:     def readMethodDecl(self, outtype, var, template=None):
 42563:         return MethodDecl(
 42563:             'Read',
 42563:             params=[ Decl(outtype, var.name),
 42563:                      Decl(Type('Message', ptr=1, const=1),
 42563:                           self.msgvar.name),
 42563:                      Decl(Type('void', ptrptr=1), self.itervar.name)],
 42563:             warn_unused=not template,
 42563:             T=template,
 42563:             ret=Type.BOOL)
 42563: 
 42563:     def maybeAddNullabilityArg(self, ipdltype, call):
 42563:         if ipdltype and ipdltype.isIPDL() and ipdltype.isActor():
 42563:             if ipdltype.nullable:
 42563:                 call.args.append(ExprLiteral.TRUE)
 42563:             else:
 42563:                 call.args.append(ExprLiteral.FALSE)
 42563:         return call
 42563: 
 42563:     def write(self, ipdltype, expr, to, this=None):
 42563:         write = ExprVar('Write')
 42563:         if this:  write = ExprSelect(this, '->', write.name)
 42563:         return self.maybeAddNullabilityArg(ipdltype,
 42563:                                            ExprCall(write, args=[ expr, to ]))
 42563: 
 42563:     def read(self, ipdltype, expr, from_, iterexpr, this=None):
 42563:         read = ExprVar('Read')
 42563:         if this:  read = ExprSelect(this, '->', read.name)
 42563:         return self.maybeAddNullabilityArg(
 42563:             ipdltype, ExprCall(read, args=[ expr, from_, iterexpr ]))
 42563: 
 42563: 
 35742:     def visitMessageDecl(self, md):
 35990:         isctor = md.decl.type.isCtor()
 35990:         isdtor = md.decl.type.isDtor()
 35990:         sems = md.decl.type.sendSemantics
 35990:         sendmethod = None
 35990:         helpermethod = None
 35990:         recvlbl, recvcase = None, None
 35990: 
 35990:         def addRecvCase(lbl, case):
 35990:             if sems is ipdl.ast.ASYNC:
 35990:                 self.asyncSwitch.addcase(lbl, case)
 35990:             elif sems is ipdl.ast.SYNC:
 35990:                 self.syncSwitch.addcase(lbl, case)
 35990:             elif sems is ipdl.ast.RPC:
 35990:                 self.rpcSwitch.addcase(lbl, case)
 35990:             else: assert 0
 35742: 
 35742:         if self.sendsMessage(md):
 35990:             isasync = (sems is ipdl.ast.ASYNC)
 35990: 
 35990:             if isctor:
 35990:                 self.cls.addstmts([ self.genHelperCtor(md), Whitespace.NL ])
 35990: 
 35990:             if isctor and isasync:
 35990:                 sendmethod, (recvlbl, recvcase) = self.genAsyncCtor(md)
 35990:             elif isctor:
 35990:                 sendmethod = self.genBlockingCtorMethod(md)
 35990:             elif isdtor and isasync:
 35990:                 sendmethod, (recvlbl, recvcase) = self.genAsyncDtor(md)
 35990:             elif isdtor:
 35990:                 sendmethod = self.genBlockingDtorMethod(md)
 35990:             elif isasync:
 35990:                 sendmethod = self.genAsyncSendMethod(md)
 35744:             else:
 35990:                 sendmethod = self.genBlockingSendMethod(md)
 36138: 
 36138:         # XXX figure out what to do here
 36138:         if isdtor and md.decl.type.constructedType().isToplevel():
 36138:             sendmethod = None
 36138:                 
 35990:         if sendmethod is not None:
 35990:             self.cls.addstmts([ sendmethod, Whitespace.NL ])
 35990:         if recvcase is not None:
 35990:             addRecvCase(recvlbl, recvcase)
 35990:             recvlbl, recvcase = None, None
 35990: 
 35990:         if self.receivesMessage(md):
 35990:             if isctor:
 35990:                 recvlbl, recvcase = self.genCtorRecvCase(md)
 35990:             elif isdtor:
 35990:                 recvlbl, recvcase = self.genDtorRecvCase(md)
 35990:             else:
 35990:                 recvlbl, recvcase = self.genRecvCase(md)
 36138: 
 36138:             # XXX figure out what to do here
 36138:             if isdtor and md.decl.type.constructedType().isToplevel():
 36138:                 return
 36138: 
 35990:             addRecvCase(recvlbl, recvcase)
 35990: 
 35990: 
 35990:     def genAsyncCtor(self, md):
 35990:         actor = md.actorDecl()
 35990:         method = MethodDefn(self.makeSendMethodDecl(md))
 35990:         method.addstmts(self.ctorPrologue(md) + [ Whitespace.NL ])
 35990: 
 36136:         msgvar, stmts = self.makeMessage(md, errfnSendCtor)
 36027:         sendok, sendstmts = self.sendAsync(md, msgvar)
 35990:         method.addstmts(
 35990:             stmts
 36027:             + sendstmts
 36027:             + self.failCtorIf(md, ExprNot(sendok))
 35990:             + [ StmtReturn(actor.var()) ])
 35990: 
 35990:         lbl = CaseLabel(md.pqReplyId())
 35990:         case = StmtBlock()
 35990:         case.addstmt(StmtReturn(_Result.Processed))
 35990:         # TODO not really sure what to do with async ctor "replies" yet.
 35990:         # destroy actor if there was an error?  tricky ...
 35990: 
 35990:         return method, (lbl, case)
 35990: 
 35990: 
 35990:     def genBlockingCtorMethod(self, md):
 35990:         actor = md.actorDecl()
 35990:         method = MethodDefn(self.makeSendMethodDecl(md))
 35990:         method.addstmts(self.ctorPrologue(md) + [ Whitespace.NL ])
 35990: 
 36136:         msgvar, stmts = self.makeMessage(md, errfnSendCtor)
 35990: 
 35990:         replyvar = self.replyvar
 36027:         sendok, sendstmts = self.sendBlocking(md, msgvar, replyvar)
 35990:         method.addstmts(
 35990:             stmts
 35990:             + [ Whitespace.NL,
 35990:                 StmtDecl(Decl(Type('Message'), replyvar.name)) ]
 36027:             + sendstmts
 36027:             + self.failCtorIf(md, ExprNot(sendok)))
 36027: 
 42563:         def errfnCleanupCtor(msg):
 42563:             return self.failCtorIf(md, ExprLiteral.TRUE)
 42563:         stmts = self.deserializeReply(
 42563:             md, ExprAddrOf(replyvar), self.side, errfnCleanupCtor)
 42563:         method.addstmts(stmts + [ StmtReturn(actor.var()) ])
 35990: 
 35990:         return method
 35990: 
 35990: 
 36136:     def ctorPrologue(self, md, errfn=ExprLiteral.NULL, idexpr=None):
 47709:         actordecl = md.actorDecl()
 47709:         actorvar = actordecl.var()
 47709:         actorproto = actordecl.ipdltype.protocol
 35990: 
 35990:         if idexpr is None:
 35990:             idexpr = ExprCall(self.protocol.registerMethod(),
 35990:                               args=[ actorvar ])
 35990:         else:
 35990:             idexpr = ExprCall(self.protocol.registerIDMethod(),
 35990:                               args=[ actorvar, idexpr ])
 35990: 
 35990:         return [
 36136:             self.failIfNullActor(actorvar, errfn),
 35990:             StmtExpr(ExprAssn(_actorId(actorvar), idexpr)),
 35990:             StmtExpr(ExprAssn(_actorManager(actorvar), ExprVar.THIS)),
 35990:             StmtExpr(ExprAssn(_actorChannel(actorvar),
 35990:                               self.protocol.channelForSubactor())),
 36139:             StmtExpr(_callCxxArrayInsertSorted(
 36139:                 self.protocol.managedVar(md.decl.type.constructedType(),
 36139:                                          self.side),
 47709:                 actorvar)),
 47709:             StmtExpr(ExprAssn(_actorState(actorvar),
 47709:                               _startState(actorproto, fq=1)))
 35990:         ]
 35990: 
 35990:     def failCtorIf(self, md, cond):
 35990:         actorvar = md.actorDecl().var()
 63894:         type = md.decl.type.constructedType()
 35990:         failif = StmtIf(cond)
 63894:         failif.addifstmts(self.destroyActor(md, actorvar,
 63894:                                             why=_DestroyReason.FailedConstructor)
 63894:                           + [ StmtReturn(ExprLiteral.NULL) ])
 35990:         return [ failif ]
 35990: 
 35990:     def genHelperCtor(self, md):
 35990:         helperdecl = self.makeSendMethodDecl(md)
 35990:         helperdecl.params = helperdecl.params[1:]
 35990:         helper = MethodDefn(helperdecl)
 35990: 
 35990:         callctor = self.callAllocActor(md, retsems='out')
 35990:         helper.addstmt(StmtReturn(ExprCall(
 35990:             ExprVar(helperdecl.name), args=[ callctor ] + callctor.args)))
 35990:         return helper
 35990: 
 35990: 
 35990:     def genAsyncDtor(self, md):
 35990:         actor = md.actorDecl()
 36138:         actorvar = actor.var()
 36138:         method = MethodDefn(self.makeDtorMethodDecl(md))
 35990: 
 35990:         method.addstmts(self.dtorPrologue(actor.var()))
 36138:         method.addstmts(self.dtorPrologue(actorvar))
 36138: 
 36138:         msgvar, stmts = self.makeMessage(md, errfnSendDtor, actorvar)
 36138:         sendok, sendstmts = self.sendAsync(md, msgvar, actorvar)
 35990:         method.addstmts(
 35990:             stmts
 36027:             + sendstmts
 36027:             + [ Whitespace.NL ]
 36138:             + self.dtorEpilogue(md, actor.var())
 36027:             + [ StmtReturn(sendok) ])
 35990: 
 35990:         lbl = CaseLabel(md.pqReplyId())
 35990:         case = StmtBlock()
 35990:         case.addstmt(StmtReturn(_Result.Processed))
 35990:         # TODO if the dtor is "inherently racy", keep the actor alive
 35990:         # until the other side acks
 35990: 
 35990:         return method, (lbl, case)
 35990: 
 35990: 
 35990:     def genBlockingDtorMethod(self, md):
 35990:         actor = md.actorDecl()
 36138:         actorvar = actor.var()
 36138:         method = MethodDefn(self.makeDtorMethodDecl(md))
 36138: 
 36138:         method.addstmts(self.dtorPrologue(actorvar))
 36138: 
 36138:         msgvar, stmts = self.makeMessage(md, errfnSendDtor, actorvar)
 35990: 
 35990:         replyvar = self.replyvar
 36138:         sendok, sendstmts = self.sendBlocking(md, msgvar, replyvar, actorvar)
 35990:         method.addstmts(
 35990:             stmts
 35990:             + [ Whitespace.NL,
 36027:                 StmtDecl(Decl(Type('Message'), replyvar.name)) ]
 36027:             + sendstmts)
 36027: 
 42563:         destmts = self.deserializeReply(
 36136:             md, ExprAddrOf(replyvar), self.side, errfnSend)
 42563:         ifsendok = StmtIf(ExprLiteral.FALSE)
 35990:         ifsendok.addifstmts(destmts)
 35990:         ifsendok.addifstmts([ Whitespace.NL,
 42563:                               StmtExpr(ExprAssn(sendok, ExprLiteral.FALSE, '&=')) ])
 35990: 
104602:         method.addstmt(ifsendok)
104602: 
104602:         if self.protocol.decl.type.hasReentrantDelete:
104602:             method.addstmts(self.transition(md, 'in', actor.var(), reply=True))
104602: 
 35990:         method.addstmts(
104602:             self.dtorEpilogue(md, actor.var())
 36027:             + [ Whitespace.NL, StmtReturn(sendok) ])
 35990: 
 35990:         return method
 35990: 
 63894:     def destroyActor(self, md, actorexpr, why=_DestroyReason.Deletion):
 63894:         if md.decl.type.isCtor():
 63894:             destroyedType = md.decl.type.constructedType()
 63894:         else:
 63894:             destroyedType = self.protocol.decl.type
 63894:         return ([ StmtExpr(self.callActorDestroy(actorexpr, why)),
 37310:                   StmtExpr(self.callDeallocSubtree(md, actorexpr)),
 38095:                   StmtExpr(self.callRemoveActor(
 38095:                       actorexpr,
 63894:                       manager=self.protocol.managerVar(actorexpr),
 63894:                       ipdltype=destroyedType))
 36139:                 ])
 35990: 
 63894:     def dtorPrologue(self, actorexpr):
 63894:         return [ self.failIfNullActor(actorexpr), Whitespace.NL ]
 63894: 
 63894:     def dtorEpilogue(self, md, actorexpr):
 63894:         return self.destroyActor(md, actorexpr)
 63894: 
 35990:     def genAsyncSendMethod(self, md):
 35990:         method = MethodDefn(self.makeSendMethodDecl(md))
 36136:         msgvar, stmts = self.makeMessage(md, errfnSend)
 36027:         sendok, sendstmts = self.sendAsync(md, msgvar)
 36027:         method.addstmts(stmts
 36027:                         +[ Whitespace.NL ]
 36027:                         + sendstmts
 36027:                         +[ StmtReturn(sendok) ])
 35990:         return method
 35990: 
 35990: 
 36138:     def genBlockingSendMethod(self, md, fromActor=None):
 35990:         method = MethodDefn(self.makeSendMethodDecl(md))
 35990: 
 36138:         msgvar, serstmts = self.makeMessage(md, errfnSend, fromActor)
 35990:         replyvar = self.replyvar
 35990: 
 36027:         sendok, sendstmts = self.sendBlocking(md, msgvar, replyvar)
 36027:         failif = StmtIf(ExprNot(sendok))
 42569:         failif.addifstmt(StmtReturn.FALSE)
 39312: 
 42563:         desstmts = self.deserializeReply(
 36136:             md, ExprAddrOf(replyvar), self.side, errfnSend)
 35990: 
 35990:         method.addstmts(
 35990:             serstmts
 35990:             + [ Whitespace.NL,
 36027:                 StmtDecl(Decl(Type('Message'), replyvar.name)) ]
 36027:             + sendstmts
 36027:             + [ failif ]
 35990:             + desstmts
 36027:             + [ Whitespace.NL,
 42569:                 StmtReturn.TRUE ])
 35990: 
 35990:         return method
 35990: 
 35990: 
 35990:     def genCtorRecvCase(self, md):
 35990:         lbl = CaseLabel(md.pqMsgId())
 35990:         case = StmtBlock()
 35990:         actorvar = md.actorDecl().var()
 42563:         actorhandle = self.handlevar
 42563: 
 42563:         stmts = self.deserializeMessage(md, self.side, errfnRecv)
 35990: 
 37314:         idvar, saveIdStmts = self.saveActorId(md)
 35990:         case.addstmts(
 35990:             stmts
 47711:             + self.transition(md, 'in')
 35990:             + [ StmtDecl(Decl(r.bareType(self.side), r.var().name))
 35990:                 for r in md.returns ]
 35990:             # alloc the actor, register it under the foreign ID
 35990:             + [ StmtExpr(ExprAssn(
 35990:                 actorvar,
 35990:                 self.callAllocActor(md, retsems='in'))) ]
 36136:             + self.ctorPrologue(md, errfn=_Result.ValuError,
 35990:                                 idexpr=_actorHId(actorhandle))
 35990:             + [ Whitespace.NL ]
 37314:             + saveIdStmts
 35990:             + self.invokeRecvHandler(md)
 37314:             + self.makeReply(md, errfnRecv, idvar)
 35990:             + [ Whitespace.NL,
 35990:                 StmtReturn(_Result.Processed) ])
 35990: 
 35990:         return lbl, case
 35990: 
 35990: 
 35990:     def genDtorRecvCase(self, md):
 35990:         lbl = CaseLabel(md.pqMsgId())
 35990:         case = StmtBlock()
 35990: 
 42563:         stmts = self.deserializeMessage(md, self.side, errfnRecv)
 35990: 
 37314:         idvar, saveIdStmts = self.saveActorId(md)
 35990:         case.addstmts(
 35990:             stmts
 47711:             + self.transition(md, 'in')
 35990:             + [ StmtDecl(Decl(r.bareType(self.side), r.var().name))
 35990:                 for r in md.returns ]
 36138:             + self.invokeRecvHandler(md, implicit=0)
 35990:             + [ Whitespace.NL ]
 37314:             + saveIdStmts
 36138:             + self.dtorEpilogue(md, md.actorDecl().var())
 37242:             + [ Whitespace.NL ]
 37242:             + self.makeReply(md, errfnRecv, routingId=idvar)
 35990:             + [ Whitespace.NL,
 35990:                 StmtReturn(_Result.Processed) ])
 35990:         
 35990:         return lbl, case
 35990: 
 35990: 
 35990:     def genRecvCase(self, md):
 35990:         lbl = CaseLabel(md.pqMsgId())
 35990:         case = StmtBlock()
 35990: 
 42563:         stmts = self.deserializeMessage(md, self.side, errfn=errfnRecv)
 35990: 
 37314:         idvar, saveIdStmts = self.saveActorId(md)
 35990:         case.addstmts(
 35990:             stmts
 47711:             + self.transition(md, 'in')
 35990:             + [ StmtDecl(Decl(r.bareType(self.side), r.var().name))
 35990:                 for r in md.returns ]
 37314:             + saveIdStmts
 35990:             + self.invokeRecvHandler(md)
 35990:             + [ Whitespace.NL ]
 37314:             + self.makeReply(md, errfnRecv, routingId=idvar)
 35990:             + [ StmtReturn(_Result.Processed) ])
 35990: 
 35990:         return lbl, case
 35990: 
 35990: 
 35990:     # helper methods
 35990: 
 35990:     def failIfNullActor(self, actorExpr, retOnNull=ExprLiteral.FALSE):
 35990:         failif = StmtIf(ExprNot(actorExpr))
 35990:         failif.addifstmt(StmtReturn(retOnNull))
 35990:         return failif
 35990: 
 63894:     def unregisterActor(self, actorexpr=None):
 36138:         return [ StmtExpr(ExprCall(self.protocol.unregisterMethod(actorexpr),
 36136:                                    args=[ _actorId(actorexpr) ])),
 36136:                  StmtExpr(ExprAssn(_actorId(actorexpr), _FREED_ACTOR_ID)) ]
 36136: 
 36138:     def makeMessage(self, md, errfn, fromActor=None):
 35990:         msgvar = self.msgvar
 37242:         routingId = self.protocol.routingId(fromActor)
 42563:         this = None
 42563:         if md.decl.type.isDtor():  this = md.actorDecl().var()
 42563: 
 42563:         stmts = ([ StmtDecl(Decl(Type(md.pqMsgClass(), ptr=1), msgvar.name),
 42563:                             init=ExprNew(Type(md.pqMsgClass()))) ]
 42563:                  + [ Whitespace.NL ]
 42563:                  + [ StmtExpr(self.write(p.ipdltype, p.var(), msgvar, this))
 42563:                      for p in md.params ]
 42563:                  + [ Whitespace.NL ]
 42563:                  + self.setMessageFlags(md, msgvar, reply=0,
 42563:                                         routingId=routingId))
 35990:         return msgvar, stmts
 35990: 
 35990: 
 37314:     def makeReply(self, md, errfn, routingId):
 35990:         # TODO special cases for async ctor/dtor replies
 37314:         if not md.decl.type.hasReply():
 35990:             return [ ]
 35990: 
 35990:         replyvar = self.replyvar
 42563:         return (
 42563:             [ StmtExpr(ExprAssn(
 42563:                 replyvar, ExprNew(Type(md.pqReplyClass()), args=[ ]))),
 42563:               Whitespace.NL ]
 42563:             + [ StmtExpr(self.write(r.ipdltype, r.var(), replyvar))
 42563:                 for r in md.returns ]
 37242:             + self.setMessageFlags(md, replyvar, reply=1, routingId=routingId)
 36027:             + [ self.logMessage(md, md.replyCast(replyvar), 'Sending reply ') ])
 35990: 
 35990: 
 37242:     def setMessageFlags(self, md, var, reply, routingId=None):
 37242:         if routingId is None:
 37242:             routingId = self.protocol.routingId()
 37242:         
 35990:         stmts = [ StmtExpr(ExprCall(
 35990:             ExprSelect(var, '->', 'set_routing_id'),
 37242:             args=[ routingId ])) ]
 35990: 
 35990:         if md.decl.type.isSync():
 35990:             stmts.append(StmtExpr(ExprCall(
 35990:                 ExprSelect(var, '->', 'set_sync'))))
 35990:         elif md.decl.type.isRpc():
 35990:             stmts.append(StmtExpr(ExprCall(
 35990:                 ExprSelect(var, '->', 'set_rpc'))))
 35990: 
 35990:         if reply:
 35990:             stmts.append(StmtExpr(ExprCall(
 35990:                 ExprSelect(var, '->', 'set_reply'))))
 35990: 
 35990:         return stmts + [ Whitespace.NL ]
 35990: 
 35990: 
 36136:     def deserializeMessage(self, md, side, errfn):
 36027:         msgvar = self.msgvar
 42563:         itervar = self.itervar
 42563:         msgexpr = ExprAddrOf(msgvar)
 35990:         isctor = md.decl.type.isCtor()
 42563:         stmts = ([
 39613:             # this is kind of naughty, but the only two other options
 42563:             # are forwarding the message name (yuck) or making the
 39613:             # IPDL|*Channel abstraction leak more
 39613:             StmtExpr(ExprCall(
 39613:                 ExprSelect(
 39613:                     ExprCast(msgvar, Type('Message', ref=1), const=1),
 39613:                     '.', 'set_name'),
 39613:                 args=[ ExprLiteral.String(md.prettyMsgName(self.protocol.name
 39613:                                                            +'::')) ])),
 42563:             self.logMessage(md, md.msgCast(msgexpr), 'Received '),
 36027:             Whitespace.NL
 42563:         ])
 42563: 
 42563:         if 0 == len(md.params):
 42563:             return stmts
 42563: 
 42563:         start, decls, reads = 0, [], []
 35990:         if isctor:
 35990:             # return the raw actor handle so that its ID can be used
 35990:             # to construct the "real" actor
 42563:             handlevar = self.handlevar
 42563:             decls = [ StmtDecl(Decl(Type('ActorHandle'), handlevar.name)) ]
 42563:             reads = [ self.checkedRead(None, ExprAddrOf(handlevar), msgexpr,
 42563:                                        ExprAddrOf(self.itervar),
 42563:                                        errfn) ]
 42563:             start = 1
 42563: 
 42563:         stmts.extend((
 42563:             [ StmtDecl(Decl(Type.VOIDPTR, self.itervar.name),
 42563:                      init=ExprLiteral.NULL) ]
 42563:             + decls + [ StmtDecl(Decl(p.bareType(side), p.var().name))
 42563:                       for p in md.params ]
 42563:             + [ Whitespace.NL ]
 42563:             + reads + [ self.checkedRead(p.ipdltype, ExprAddrOf(p.var()),
 42563:                                          msgexpr, ExprAddrOf(itervar),
 42563:                                          errfn)
 42563:                         for p in md.params[start:] ]
 42563:             + [ self.endRead(msgvar, itervar) ]))
 42563: 
 42563:         return stmts
 35990: 
 35990: 
 36136:     def deserializeReply(self, md, replyexpr, side, errfn):
 36027:         stmts = [ Whitespace.NL,
 36027:                    self.logMessage(md, md.replyCast(replyexpr),
 42563:                                    'Received reply ') ]
 42563:         if 0 == len(md.returns):
 42563:             return stmts
 42563: 
 42563:         itervar = self.itervar
 42563:         stmts.extend(
 42563:             [ Whitespace.NL,
 42563:               StmtDecl(Decl(Type.VOIDPTR, itervar.name),
 42563:                        init=ExprLiteral.NULL) ]
 42563:             + [ self.checkedRead(r.ipdltype, r.var(),
 42563:                                  ExprAddrOf(self.replyvar),
 42563:                                  ExprAddrOf(self.itervar),
 42563:                                  errfn)
 42563:                 for r in md.returns ]
 42563:             + [ self.endRead(self.replyvar, itervar) ])
 42563: 
 42563:         return stmts
 35990: 
 35990: 
 36138:     def sendAsync(self, md, msgexpr, actor=None):
 36027:         sendok = ExprVar('__sendok')
 36027:         return (
 36027:             sendok,
 47711:             ([ Whitespace.NL,
 47711:                self.logMessage(md, msgexpr, 'Sending ') ]
 47711:             + self.transition(md, 'out', actor)
 47711:             + [ Whitespace.NL,
 36027:                 StmtDecl(Decl(Type.BOOL, sendok.name),
 36027:                          init=ExprCall(
 36138:                              ExprSelect(self.protocol.channelVar(actor),
 35990:                                         self.protocol.channelSel(), 'Send'),
 36027:                              args=[ msgexpr ]))
 36027:             ])
 47711:         )
 35990: 
 36138:     def sendBlocking(self, md, msgexpr, replyexpr, actor=None):
 36027:         sendok = ExprVar('__sendok')
 36027:         return (
 36027:             sendok,
 47711:             ([ Whitespace.NL,
 47711:                self.logMessage(md, msgexpr, 'Sending ') ]
 47711:             + self.transition(md, 'out', actor)
 47711:             + [ Whitespace.NL,
 36138:                 StmtDecl(
 36138:                     Decl(Type.BOOL, sendok.name),
 36138:                     init=ExprCall(ExprSelect(self.protocol.channelVar(actor),
 35990:                                              self.protocol.channelSel(),
 35990:                                              _sendPrefix(md.decl.type)),
 36138:                                   args=[ msgexpr, ExprAddrOf(replyexpr) ]))
 36027:             ])
 47711:         )
 36027: 
 35990:     def callAllocActor(self, md, retsems):
 35990:         return ExprCall(
 36138:             _allocMethod(md.decl.type.constructedType()),
 35990:             args=md.makeCxxArgs(params=1, retsems=retsems, retcallsems='out',
 35990:                                 implicit=0))
 35990: 
 36140:     def callActorDestroy(self, actorexpr, why=_DestroyReason.Deletion):
 36140:         return ExprCall(ExprSelect(actorexpr, '->', 'DestroySubtree'),
 36140:                         args=[ why ])
 36140: 
 38095:     def callRemoveActor(self, actorexpr, manager=None, ipdltype=None):
 38095:         if ipdltype is None: ipdltype = self.protocol.decl.type
 38095: 
 38095:         if not ipdltype.isManaged():
 36140:             return Whitespace('// unmanaged protocol')
 36140: 
 38095:         removefunc = self.protocol.removeManageeMethod()
 38095:         if manager is not None:
 38095:             removefunc = ExprSelect(manager, '->', removefunc.name)
 38095: 
 38095:         return ExprCall(removefunc,
 38095:                         args=[ _protocolId(ipdltype),
 38094:                                actorexpr ])
 36139: 
 37310:     def callDeallocSubtree(self, md, actorexpr):
 37310:         return ExprCall(ExprSelect(actorexpr, '->', 'DeallocSubtree'))
 37310: 
 36138:     def invokeRecvHandler(self, md, implicit=1):
 35990:         failif = StmtIf(ExprNot(
 35990:             ExprCall(md.recvMethod(),
 35990:                      args=md.makeCxxArgs(params=1,
 36138:                                          retsems='in', retcallsems='out',
 36138:                                          implicit=implicit))))
 42559:         failif.addifstmt(StmtReturn(_Result.ProcessingError))
 35990:         return [ failif ]
 35990: 
 36138:     def makeDtorMethodDecl(self, md):
 36138:         decl = self.makeSendMethodDecl(md)
 36138:         decl.static = 1
 36138:         return decl
 36138: 
 35990:     def makeSendMethodDecl(self, md):
 35990:         implicit = md.decl.type.hasImplicitActorParam()
 35990:         decl = MethodDecl(
 35990:             md.sendMethod().name,
 35990:             params=md.makeCxxParams(paramsems='in', returnsems='out',
 35990:                                     side=self.side, implicit=implicit),
 41380:             warn_unused=(self.side == 'parent'),
 35990:             ret=Type.BOOL)
 35744:         if md.decl.type.isCtor():
 35990:             decl.ret = md.actorDecl().bareType(self.side)
 35990:         return decl
 35990: 
 36027:     def logMessage(self, md, msgptr, pfx):
 36068:         actorname = _actorName(self.protocol.name, self.side)
 36027:         return _ifLogging([
 36027:             StmtExpr(ExprCall(
 36027:                 ExprSelect(msgptr, '->', 'Log'),
 36068:                 args=[ ExprLiteral.String('['+ actorname +'] '+ pfx),
 36027:                        ExprVar('stderr') ])) ])
 36027: 
 37314:     def saveActorId(self, md):
 37314:         idvar = ExprVar('__id')
 37314:         if md.decl.type.hasReply():
 37314:             # only save the ID if we're actually going to use it, to
 37314:             # avoid unused-variable warnings
 37314:             saveIdStmts = [ StmtDecl(Decl(_actorIdType(), idvar.name),
 37314:                                      self.protocol.routingId()) ]
 37314:         else:
 37314:             saveIdStmts = [ ]
 37314:         return idvar, saveIdStmts
 37314: 
104602:     def transition(self, md, direction, actor=None, reply=False):
 47711:         if actor is not None:  stateexpr = _actorState(actor)
 47711:         else:                  stateexpr = self.protocol.stateVar()
 47711:         
 47711:         if (self.side is 'parent' and direction is 'out'
 47711:             or self.side is 'child' and direction is 'in'):
 47711:             action = ExprVar('Trigger::Send')
 47711:         elif (self.side is 'parent' and direction is 'in'
 47711:             or self.side is 'child' and direction is 'out'):
 47711:             action = ExprVar('Trigger::Recv')
 47711:         else: assert 0 and 'unknown combo %s/%s'% (self.side, direction)
 47711: 
104602:         msgid = md.pqMsgId() if not reply else md.pqReplyId()
 47711:         ifbad = StmtIf(ExprNot(
 47711:             ExprCall(
 47711:                 ExprVar(self.protocol.name +'::Transition'),
 47711:                 args=[ stateexpr,
 47711:                        ExprCall(ExprVar('Trigger'),
104602:                                 args=[ action, ExprVar(msgid) ]),
 47711:                        ExprAddrOf(stateexpr) ])))
 47711:         ifbad.addifstmts(_badTransition())
 47711:         return [ ifbad ]
 47711: 
 42563:     def checkedRead(self, ipdltype, expr, msgexpr, iterexpr, errfn):
 42563:         ifbad = StmtIf(ExprNot(self.read(ipdltype, expr, msgexpr, iterexpr)))
 42563:         ifbad.addifstmts(errfn('error deserializing (better message TODO)'))
 42563:         return ifbad
 42563: 
 42563:     def endRead(self, msgexpr, iterexpr):
 42563:         return StmtExpr(ExprCall(ExprSelect(msgexpr, '.', 'EndRead'),
 42563:                                  args=[ iterexpr ]))
 35990: 
 36137: class _GenerateProtocolParentCode(_GenerateProtocolActorCode):
 35742:     def __init__(self):
 36137:         _GenerateProtocolActorCode.__init__(self, 'parent')
 35742: 
 35742:     def sendsMessage(self, md):
 35742:         return not md.decl.type.isIn()
 35742: 
 35742:     def receivesMessage(self, md):
 35742:         return md.decl.type.isInout() or md.decl.type.isIn()
 35742: 
 36137: class _GenerateProtocolChildCode(_GenerateProtocolActorCode):
 35742:     def __init__(self):
 36137:         _GenerateProtocolActorCode.__init__(self, 'child')
 35742: 
 35742:     def sendsMessage(self, md):
 35742:         return not md.decl.type.isOut()
 35742: 
 35742:     def receivesMessage(self, md):
 35742:         return md.decl.type.isInout() or md.decl.type.isOut()
 35768: 
 35768: 
 35990: ##-----------------------------------------------------------------------------
 36137: ## Utility passes
 35990: ##
 35990: 
 71234: def _splitClassDeclDefn(cls):
 42566:     """Destructively split |cls| methods into declarations and
 42566: definitions (if |not methodDecl.force_inline|).  Return classDecl,
 42566: methodDefns."""
 36137:     defns = Block()
 36137: 
 36137:     for i, stmt in enumerate(cls.stmts):
 42566:         if isinstance(stmt, MethodDefn) and not stmt.decl.force_inline:
 71234:             decl, defn = _splitMethodDefn(stmt, cls.name)
 36137:             cls.stmts[i] = StmtDecl(decl)
 36137:             defns.addstmts([ defn, Whitespace.NL ])
 36137: 
 36137:     return cls, defns
 36137: 
 71234: def _splitMethodDefn(md, clsname):
 36137:     saveddecl = deepcopy(md.decl)
 36137:     md.decl.name = (clsname +'::'+ md.decl.name)
 36137:     md.decl.virtual = 0
 36137:     md.decl.static = 0
 41380:     md.decl.warn_unused = 0
 36137:     for param in md.decl.params:
 36137:         if isinstance(param, Param):
 36137:             param.default = None
 36137:     return saveddecl, md
 36137: 
 36137: 
 71234: def _splitFuncDeclDefn(fun):
 71234:     assert not fun.decl.inline
 71234:     return StmtDecl(fun.decl), fun
 71234: 
 71234: 
 42566: # XXX this is tantalizingly similar to _splitClassDeclDefn, but just
 36137: # different enough that I don't see the need to define
 36137: # _GenerateSkeleton in terms of that
 35990: class _GenerateSkeletonImpl(Visitor):
 36137:     def __init__(self, name, namespaces):
 35768:         self.name = name
 35768:         self.cls = None
 36137:         self.namespaces = namespaces
 36137:         self.methodimpls = Block()
 35768: 
 35768:     def fromclass(self, cls):
 35768:         cls.accept(self)
 36137: 
 36137:         nsclass = _putInNamespaces(self.cls, self.namespaces)
 36137:         nsmethodimpls = _putInNamespaces(self.methodimpls, self.namespaces)
 36137: 
 36137:         return [
 36137:             Whitespace('''
 35768: //-----------------------------------------------------------------------------
 35768: // Skeleton implementation of abstract actor class
 35768: 
 36137: '''),
 36137:             Whitespace('// Header file contents\n'),
 36137:             nsclass,
 36137:             Whitespace.NL,
 36137:             Whitespace('\n// C++ file contents\n'),
 36137:             nsmethodimpls
 36137:         ]
 36137: 
 35768: 
 35768:     def visitClass(self, cls):
 35990:         self.cls = Class(self.name, inherits=[ Inherit(Type(cls.name)) ])
 35990:         Visitor.visitClass(self, cls)
 35768: 
 35768:     def visitMethodDecl(self, md):
 35768:         if not md.pure:
 35768:             return
 35768:         decl = deepcopy(md)
 35768:         decl.pure = 0
 35990:         impl = MethodDefn(MethodDecl(self.implname(md.name),
 35768:                                              params=md.params,
 35768:                                              ret=md.ret))
 35840:         if md.ret.ptr:
 35990:             impl.addstmt(StmtReturn(ExprLiteral.ZERO))
 35840:         else:
 35990:             impl.addstmt(StmtReturn(ExprVar('false')))
 35990: 
 35990:         self.cls.addstmts([ StmtDecl(decl), Whitespace.NL ])
 35768:         self.addmethodimpl(impl)
 35768: 
 35768:     def visitConstructorDecl(self, cd):
 35990:         self.cls.addstmt(StmtDecl(ConstructorDecl(self.name)))
 35990:         ctor = ConstructorDefn(ConstructorDecl(self.implname(self.name)))
 35990:         ctor.addstmt(StmtExpr(ExprCall(ExprVar( 'MOZ_COUNT_CTOR'),
 35990:                                                [ ExprVar(self.name) ])))
 35879:         self.addmethodimpl(ctor)
 35768:         
 35768:     def visitDestructorDecl(self, dd):
 35768:         self.cls.addstmt(
 35990:             StmtDecl(DestructorDecl(self.name, virtual=1)))
 35768:         # FIXME/cjones: hack!
 35990:         dtor = DestructorDefn(ConstructorDecl(self.implname('~' +self.name)))
 35990:         dtor.addstmt(StmtExpr(ExprCall(ExprVar( 'MOZ_COUNT_DTOR'),
 35990:                                                [ ExprVar(self.name) ])))
 35879:         self.addmethodimpl(dtor)
 35768: 
 35768:     def addmethodimpl(self, impl):
 36137:         self.methodimpls.addstmts([ impl, Whitespace.NL ])
 35768: 
 35768:     def implname(self, method):
 35768:         return self.name +'::'+ method
