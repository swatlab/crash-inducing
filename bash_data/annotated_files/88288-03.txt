43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43113:  *
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsDiskCacheBinding.cpp, released
43113:  * May 10, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Patrick C. Beard <beard@netscape.com>
43113:  *   Gordon Sheridan  <gordon@netscape.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include <limits.h>
43113: 
43113: #include "nscore.h"
43113: #include "nsDiskCacheBinding.h"
88288: #include "nsCacheService.h"
43113: 
43113: 
43113: 
43113: /******************************************************************************
43113:  *  static hash table callback functions
43113:  *
43113:  *****************************************************************************/
43113: struct HashTableEntry : PLDHashEntryHdr {
43113:     nsDiskCacheBinding *  mBinding;
43113: };
43113: 
43113: 
43113: static PLDHashNumber
43113: HashKey( PLDHashTable *table, const void *key)
43113: {
43113:     return (PLDHashNumber) NS_PTR_TO_INT32(key);
43113: }
43113: 
43113: 
79445: static bool
43113: MatchEntry(PLDHashTable *              /* table */,
43113:             const PLDHashEntryHdr *       header,
43113:             const void *                  key)
43113: {
43113:     HashTableEntry * hashEntry = (HashTableEntry *) header;
43113:     return (hashEntry->mBinding->mRecord.HashNumber() == (PLDHashNumber) NS_PTR_TO_INT32(key));
43113: }
43113: 
43113: static void
43113: MoveEntry(PLDHashTable *           /* table */,
43113:           const PLDHashEntryHdr *     src,
43113:           PLDHashEntryHdr       *     dst)
43113: {
43113:     ((HashTableEntry *)dst)->mBinding = ((HashTableEntry *)src)->mBinding;
43113: }
43113: 
43113: 
43113: static void
43113: ClearEntry(PLDHashTable *      /* table */,
43113:            PLDHashEntryHdr *      header)
43113: {
43113:     ((HashTableEntry *)header)->mBinding = nsnull;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  Utility Functions
43113:  *****************************************************************************/
43113: nsDiskCacheBinding *
43113: GetCacheEntryBinding(nsCacheEntry * entry)
43113: {
43113:     return (nsDiskCacheBinding *) entry->Data();
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheBinding
43113:  *****************************************************************************/
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS0(nsDiskCacheBinding)
43113: 
43113: nsDiskCacheBinding::nsDiskCacheBinding(nsCacheEntry* entry, nsDiskCacheRecord * record)
43113:     :   mCacheEntry(entry)
43113:     ,   mStreamIO(nsnull)
68582:     ,   mDeactivateEvent(nsnull)
43113: {
43113:     NS_ASSERTION(record->ValidRecord(), "bad record");
43113:     PR_INIT_CLIST(this);
43113:     mRecord     = *record;
43113:     mDoomed     = entry->IsDoomed();
43113:     mGeneration = record->Generation();    // 0 == uninitialized, or data & meta using block files
43113: }
43113: 
43113: nsDiskCacheBinding::~nsDiskCacheBinding()
43113: {
43113:     NS_ASSERTION(PR_CLIST_IS_EMPTY(this), "binding deleted while still on list");
43113:     if (!PR_CLIST_IS_EMPTY(this))
43113:         PR_REMOVE_LINK(this);       // XXX why are we still on a list?
43113:     
43113:     // sever streamIO/binding link
43113:     if (mStreamIO) {
88288:         if (NS_FAILED(mStreamIO->ClearBinding()))
88288:             nsCacheService::DoomEntry(mCacheEntry);
43113:         NS_RELEASE(mStreamIO);
43113:     }
43113: }
43113: 
43113: nsresult
43113: nsDiskCacheBinding::EnsureStreamIO()
43113: {
43113:     if (!mStreamIO) {
43113:         mStreamIO = new nsDiskCacheStreamIO(this);
43113:         if (!mStreamIO)  return NS_ERROR_OUT_OF_MEMORY;
43113:         NS_ADDREF(mStreamIO);
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheBindery
43113:  *
43113:  *  Keeps track of bound disk cache entries to detect for collisions.
43113:  *
43113:  *****************************************************************************/
43113: 
43113: PLDHashTableOps nsDiskCacheBindery::ops =
43113: {
43113:     PL_DHashAllocTable,
43113:     PL_DHashFreeTable,
43113:     HashKey,
43113:     MatchEntry,
43113:     MoveEntry,
43113:     ClearEntry,
43113:     PL_DHashFinalizeStub
43113: };
43113: 
43113: 
43113: nsDiskCacheBindery::nsDiskCacheBindery()
80486:     : initialized(false)
43113: {
43113: }
43113: 
43113: 
43113: nsDiskCacheBindery::~nsDiskCacheBindery()
43113: {
43113:     Reset();
43113: }
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheBindery::Init()
43113: {
43113:     nsresult rv = NS_OK;
43113:     initialized = PL_DHashTableInit(&table, &ops, nsnull, sizeof(HashTableEntry), 0);
43113: 
43113:     if (!initialized) rv = NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     return rv;
43113: }
43113: 
43113: void
43113: nsDiskCacheBindery::Reset()
43113: {
43113:     if (initialized) {
43113:         PL_DHashTableFinish(&table);
80486:         initialized = false;
43113:     }
43113: }
43113: 
43113: 
43113: nsDiskCacheBinding *
43113: nsDiskCacheBindery::CreateBinding(nsCacheEntry *       entry,
43113:                                   nsDiskCacheRecord *  record)
43113: {
43113:     NS_ASSERTION(initialized, "nsDiskCacheBindery not initialized");
43113:     nsCOMPtr<nsISupports> data = entry->Data();
43113:     if (data) {
43113:         NS_ERROR("cache entry already has bind data");
43113:         return nsnull;
43113:     }
43113:     
43113:     nsDiskCacheBinding * binding = new nsDiskCacheBinding(entry, record);
43113:     if (!binding)  return nsnull;
43113:         
43113:     // give ownership of the binding to the entry
43113:     entry->SetData(binding);
43113:     
43113:     // add binding to collision detection system
43113:     nsresult rv = AddBinding(binding);
43113:     if (NS_FAILED(rv)) {
43113:         entry->SetData(nsnull);
43113:         return nsnull;
43113:     }
43113: 
43113:     return binding;
43113: }
43113: 
43113: 
43113: /**
43113:  *  FindActiveEntry :  to find active colliding entry so we can doom it
43113:  */
43113: nsDiskCacheBinding *
43113: nsDiskCacheBindery::FindActiveBinding(PRUint32  hashNumber)
43113: {
43113:     NS_ASSERTION(initialized, "nsDiskCacheBindery not initialized");
43113:     // find hash entry for key
43113:     HashTableEntry * hashEntry;
43113:     hashEntry = (HashTableEntry *) PL_DHashTableOperate(&table, (void*) hashNumber, PL_DHASH_LOOKUP);
43113:     if (PL_DHASH_ENTRY_IS_FREE(hashEntry)) return nsnull;
43113:     
43113:     // walk list looking for active entry
43113:     NS_ASSERTION(hashEntry->mBinding, "hash entry left with no binding");
43113:     nsDiskCacheBinding * binding = hashEntry->mBinding;    
43113:     while (binding->mCacheEntry->IsDoomed()) {
43113:         binding = (nsDiskCacheBinding *)PR_NEXT_LINK(binding);
43113:         if (binding == hashEntry->mBinding)  return nsnull;
43113:     }
43113:     return binding;
43113: }
43113: 
43113: 
43113: /**
43113:  *  AddBinding
43113:  *
43113:  *  Called from FindEntry() if we read an entry off of disk
43113:  *      - it may already have a generation number
43113:  *      - a generation number conflict is an error
43113:  *
43113:  *  Called from BindEntry()
43113:  *      - a generation number needs to be assigned
43113:  */
43113: nsresult
43113: nsDiskCacheBindery::AddBinding(nsDiskCacheBinding * binding)
43113: {
43113:     NS_ENSURE_ARG_POINTER(binding);
43113:     NS_ASSERTION(initialized, "nsDiskCacheBindery not initialized");
43113: 
43113:     // find hash entry for key
43113:     HashTableEntry * hashEntry;
43113:     hashEntry = (HashTableEntry *) PL_DHashTableOperate(&table,
43113:                                                         (void*) binding->mRecord.HashNumber(),
43113:                                                         PL_DHASH_ADD);
43113:     if (!hashEntry) return NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     if (hashEntry->mBinding == nsnull) {
43113:         hashEntry->mBinding = binding;
43113:         if (binding->mGeneration == 0)
43113:             binding->mGeneration = 1;   // if generation uninitialized, set it to 1
43113:             
43113:         return NS_OK;
43113:     }
43113:     
43113:     
43113:     // insert binding in generation order
43113:     nsDiskCacheBinding * p  = hashEntry->mBinding;
79445:     bool     calcGeneration = (binding->mGeneration == 0);  // do we need to calculate generation?
43113:     if (calcGeneration)  binding->mGeneration = 1;          // initialize to 1 if uninitialized
43113:     while (1) {
43113:     
43113:         if (binding->mGeneration < p->mGeneration) {
43113:             // here we are
43113:             PR_INSERT_BEFORE(binding, p);
43113:             if (hashEntry->mBinding == p)
43113:                 hashEntry->mBinding = binding;
43113:             break;
43113:         }
43113:         
43113:         if (binding->mGeneration == p->mGeneration) {
43113:             if (calcGeneration)  ++binding->mGeneration;    // try the next generation
43113:             else {
43113:                 NS_ERROR("### disk cache: generations collide!");
43113:                 return NS_ERROR_UNEXPECTED;
43113:             }
43113:         }
43113: 
43113:         p = (nsDiskCacheBinding *)PR_NEXT_LINK(p);
43113:         if (p == hashEntry->mBinding) {
43113:             // end of line: insert here or die
43113:             p = (nsDiskCacheBinding *)PR_PREV_LINK(p);  // back up and check generation
43113:             if (p->mGeneration == 255) {
43113:                 NS_WARNING("### disk cache: generation capacity at full");
43113:                 return NS_ERROR_UNEXPECTED;
43113:             }
43113:             PR_INSERT_BEFORE(binding, hashEntry->mBinding);
43113:             break;
43113:         }
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /**
43113:  *  RemoveBinding :  remove binding from collision detection on deactivation
43113:  */
43113: void
43113: nsDiskCacheBindery::RemoveBinding(nsDiskCacheBinding * binding)
43113: {
43113:     NS_ASSERTION(initialized, "nsDiskCacheBindery not initialized");
43113:     if (!initialized)   return;
43113:     
43113:     HashTableEntry * hashEntry;
43113:     void *           key = (void *)binding->mRecord.HashNumber();
43113: 
43113:     hashEntry = (HashTableEntry*) PL_DHashTableOperate(&table,
43113:                                                        (void*) key,
43113:                                                        PL_DHASH_LOOKUP);
43113:     if (!PL_DHASH_ENTRY_IS_BUSY(hashEntry)) {
43113:         NS_WARNING("### disk cache: binding not in hashtable!");
43113:         return;
43113:     }
43113:     
43113:     if (binding == hashEntry->mBinding) {
43113:         if (PR_CLIST_IS_EMPTY(binding)) {
43113:             // remove this hash entry
43113:             (void) PL_DHashTableOperate(&table,
43113:                                         (void*) binding->mRecord.HashNumber(),
43113:                                         PL_DHASH_REMOVE);
43113:             return;
43113:             
43113:         } else {
43113:             // promote next binding to head, and unlink this binding
43113:             hashEntry->mBinding = (nsDiskCacheBinding *)PR_NEXT_LINK(binding);
43113:         }
43113:     }
43113:     PR_REMOVE_AND_INIT_LINK(binding);
43113: }
43113: 
43113: 
43113: /**
43113:  *  ActiveBinding : PLDHashTable enumerate function to verify active bindings
43113:  */
43113: 
43113: PLDHashOperator
43113: ActiveBinding(PLDHashTable *    table,
43113:               PLDHashEntryHdr * hdr,
43113:               PRUint32          number,
43113:               void *            arg)
43113: {
43113:     nsDiskCacheBinding * binding = ((HashTableEntry *)hdr)->mBinding;
43113:     NS_ASSERTION(binding, "### disk cache binding = nsnull!");
43113:     
43113:     nsDiskCacheBinding * head = binding;
43113:     do {   
43113:         if (binding->IsActive()) {
79445:            *((bool *)arg) = true;
43113:             return PL_DHASH_STOP;
43113:         }
43113: 
43113:         binding = (nsDiskCacheBinding *)PR_NEXT_LINK(binding);
43113:     } while (binding != head);
43113: 
43113:     return PL_DHASH_NEXT;
43113: }
43113: 
43113: 
43113: /**
80486:  *  ActiveBindings : return true if any bindings have open descriptors
43113:  */
79445: bool
43113: nsDiskCacheBindery::ActiveBindings()
43113: {
43113:     NS_ASSERTION(initialized, "nsDiskCacheBindery not initialized");
80486:     if (!initialized) return false;
43113: 
79445:     bool    activeBinding = false;
43113:     PL_DHashTableEnumerate(&table, ActiveBinding, &activeBinding);
43113: 
43113:     return activeBinding;
43113: }
