   1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is thebes gfx
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * mozilla.org.
   1:  * Portions created by the Initial Developer are Copyright (C) 2005
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Vladimir Vukicevic <vladimir@pobox.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsThebesImage.h"
   1: #include "nsThebesRenderingContext.h"
   1: 
   1: #include "gfxContext.h"
   1: #include "gfxPattern.h"
   1: 
   1: #include "gfxPlatform.h"
   1: 
   1: #include "prenv.h"
   1: 
   1: static PRBool gDisableOptimize = PR_FALSE;
   1: 
   1: NS_IMPL_ISUPPORTS1(nsThebesImage, nsIImage)
   1: 
   1: nsThebesImage::nsThebesImage()
   1:     : mFormat(gfxImageSurface::ImageFormatRGB24),
   1:       mWidth(0),
   1:       mHeight(0),
   1:       mDecoded(0,0,0,0),
   1:       mImageComplete(PR_FALSE),
   1:       mSinglePixel(PR_FALSE),
   1:       mAlphaDepth(0)
   1: {
   1:     static PRBool hasCheckedOptimize = PR_FALSE;
   1:     if (!hasCheckedOptimize) {
   1:         if (PR_GetEnv("MOZ_DISABLE_IMAGE_OPTIMIZE")) {
   1:             gDisableOptimize = PR_TRUE;
   1:         }
   1:         hasCheckedOptimize = PR_TRUE;
   1:     }
   1: }
   1: 
   1: nsresult
   1: nsThebesImage::Init(PRInt32 aWidth, PRInt32 aHeight, PRInt32 aDepth, nsMaskRequirements aMaskRequirements)
   1: {
   1:     mWidth = aWidth;
   1:     mHeight = aHeight;
   1: 
   1:     // Reject over-wide or over-tall images.
   1:     if (!AllowedImageSize(aWidth, aHeight))
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     gfxImageSurface::gfxImageFormat format;
   1:     switch(aMaskRequirements)
   1:     {
   1:         case nsMaskRequirements_kNeeds1Bit:
   1:             format = gfxImageSurface::ImageFormatARGB32;
   1:             mAlphaDepth = 1;
   1:             break;
   1:         case nsMaskRequirements_kNeeds8Bit:
   1:             format = gfxImageSurface::ImageFormatARGB32;
   1:             mAlphaDepth = 8;
   1:             break;
   1:         default:
   1:             format = gfxImageSurface::ImageFormatRGB24;
   1:             mAlphaDepth = 0;
   1:             break;
   1:     }
   1: 
   1:     mFormat = format;
   1: 
   1: #ifdef XP_WIN
 271:     if (!ShouldUseImageSurfaces()) {
   1:         mWinSurface = new gfxWindowsSurface(gfxIntSize(mWidth, mHeight), format);
1349:         if (mWinSurface && mWinSurface->Status() == 0) {
1349:             // no error
   1:             mImageSurface = mWinSurface->GetImageSurface();
 271:         }
1349:     }
   1: 
   1:     if (!mImageSurface) {
   1:         mWinSurface = nsnull;
   1:         mImageSurface = new gfxImageSurface(gfxIntSize(mWidth, mHeight), format);
   1:     }
   1: #else
   1:     mImageSurface = new gfxImageSurface(gfxIntSize(mWidth, mHeight), format);
   1: #endif
1349: 
1349:     if (!mImageSurface || mImageSurface->Status()) {
1349:         mImageSurface = nsnull;
1349:         // guess
1349:         return NS_ERROR_OUT_OF_MEMORY;
1349:     }
1349: 
   1:     mStride = mImageSurface->Stride();
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsThebesImage::~nsThebesImage()
   1: {
   1: }
   1: 
   1: PRInt32
   1: nsThebesImage::GetBytesPix()
   1: {
   1:     return 4;
   1: }
   1: 
   1: PRBool
   1: nsThebesImage::GetIsRowOrderTopToBottom()
   1: {
   1:     return PR_TRUE;
   1: }
   1: 
   1: PRInt32
   1: nsThebesImage::GetWidth()
   1: {
   1:     return mWidth;
   1: }
   1: 
   1: PRInt32
   1: nsThebesImage::GetHeight()
   1: {
   1:     return mHeight;
   1: }
   1: 
   1: PRUint8 *
   1: nsThebesImage::GetBits()
   1: {
   1:     if (mImageSurface)
   1:         return mImageSurface->Data();
   1:     return nsnull;
   1: }
   1: 
   1: PRInt32
   1: nsThebesImage::GetLineStride()
   1: {
   1:     return mStride;
   1: }
   1: 
   1: PRBool
   1: nsThebesImage::GetHasAlphaMask()
   1: {
   1:     return mAlphaDepth > 0;
   1: }
   1: 
   1: PRUint8 *
   1: nsThebesImage::GetAlphaBits()
   1: {
   1:     return nsnull;
   1: }
   1: 
   1: PRInt32
   1: nsThebesImage::GetAlphaLineStride()
   1: {
   1:     return (mAlphaDepth > 0) ? mStride : 0;
   1: }
   1: 
   1: void
   1: nsThebesImage::ImageUpdated(nsIDeviceContext *aContext, PRUint8 aFlags, nsRect *aUpdateRect)
   1: {
   1:     mDecoded.UnionRect(mDecoded, *aUpdateRect);
   1: }
   1: 
   1: PRBool
   1: nsThebesImage::GetIsImageComplete()
   1: {
   1:     if (!mImageComplete)
   1:         mImageComplete = (mDecoded == nsRect(0, 0, mWidth, mHeight));
   1:     return mImageComplete;
   1: }
   1: 
   1: nsresult
   1: nsThebesImage::Optimize(nsIDeviceContext* aContext)
   1: {
   1:     if (gDisableOptimize)
   1:         return NS_OK;
   1: 
   1:     if (mOptSurface || mSinglePixel)
   1:         return NS_OK;
   1: 
   1:     if (mWidth == 1 && mHeight == 1) {
   1:         // yeah, let's optimize this.
   1:         if (mFormat == gfxImageSurface::ImageFormatARGB32 ||
   1:             mFormat == gfxImageSurface::ImageFormatRGB24)
   1:         {
   1:             PRUint32 pixel = *((PRUint32 *) mImageSurface->Data());
   1: 
   1:             mSinglePixelColor = gfxRGBA
   1:                 (pixel,
   1:                  (mFormat == gfxImageSurface::ImageFormatRGB24 ?
   1:                   gfxRGBA::PACKED_XRGB :
   1:                   gfxRGBA::PACKED_ARGB_PREMULTIPLIED));
   1: 
   1:             mSinglePixel = PR_TRUE;
   1: 
   1:             return NS_OK;
   1:         }
   1: 
   1:         // if it's not RGB24/ARGB32, don't optimize, but we should
   1:         // never hit this.
   1:     }
   1: 
 271:     // if we're being forced to use image surfaces due to
 271:     // resource constraints, don't try to optimize beyond single-pixel.
 271:     if (ShouldUseImageSurfaces())
 271:         return NS_OK;
 271: 
   1: #ifdef XP_WIN
   1:     // we need to special-case windows here, because windows has
   1:     // a distinction between DIB and DDB and we want to use DDBs as much
   1:     // as we can.
   1:     if (mWinSurface) {
   1:         // Don't do DDBs for large images; see bug 359147
   1:         // We use 1024 as a reasonable sized maximum; the real fix
   1:         // will be to make sure we don't ever make a DDB that's bigger
   1:         // than the primary screen size (rule of thumb).
   1:         if (mWidth <= 1024 && mHeight <= 1024) {
   1:             nsRefPtr<gfxWindowsSurface> wsurf = mWinSurface->OptimizeToDDB(nsnull, gfxIntSize(mWidth, mHeight), mFormat);
   1:             if (wsurf) {
   1:                 mOptSurface = wsurf;
   1:             }
   1:         }
   1: 
   1:         if (!mOptSurface) {
   1:             // just use the DIB
   1:             mOptSurface = mWinSurface;
   1:         }
   1:     } else {
   1:         mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface);
   1:     }
   1: 
   1:     mWinSurface = nsnull;
   1: #else
   1:     mOptSurface = gfxPlatform::GetPlatform()->OptimizeImage(mImageSurface);
   1: #endif
   1: 
   1:     mImageSurface = nsnull;
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsColorMap *
   1: nsThebesImage::GetColorMap()
   1: {
   1:     return NULL;
   1: }
   1: 
   1: PRInt8
   1: nsThebesImage::GetAlphaDepth()
   1: {
   1:     return mAlphaDepth;
   1: }
   1: 
   1: void *
   1: nsThebesImage::GetBitInfo()
   1: {
   1:     return NULL;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsThebesImage::LockImagePixels(PRBool aMaskPixels)
   1: {
   1:     if (aMaskPixels)
   1:         return NS_ERROR_NOT_IMPLEMENTED;
   1:     if ((mOptSurface || mSinglePixel) && !mImageSurface) {
   1:         // Recover the pixels
   1:         mImageSurface = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
   1:                                             gfxImageSurface::ImageFormatARGB32);
1349:         if (!mImageSurface || mImageSurface->Status())
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         nsRefPtr<gfxContext> context = new gfxContext(mImageSurface);
   1:         if (!context) {
   1:             mImageSurface = nsnull;
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1:         context->SetOperator(gfxContext::OPERATOR_SOURCE);
   1:         if (mSinglePixel)
   1:             context->SetColor(mSinglePixelColor);
   1:         else
   1:             context->SetSource(mOptSurface);
   1:         context->Paint();
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsThebesImage::UnlockImagePixels(PRBool aMaskPixels)
   1: {
   1:     if (aMaskPixels)
   1:         return NS_ERROR_NOT_IMPLEMENTED;
   1:     if (mImageSurface && mOptSurface) {
   1:         // Don't need the pixel data anymore
   1:         mImageSurface = nsnull;
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: /* NB: These are pixels, not twips. */
   1: NS_IMETHODIMP
   1: nsThebesImage::Draw(nsIRenderingContext &aContext,
   1:                     const gfxRect &aSourceRect,
   1:                     const gfxRect &aDestRect)
   1: {
   1:     if (NS_UNLIKELY(aDestRect.IsEmpty())) {
   1:         NS_ERROR("nsThebesImage::Draw zero dest size - please fix caller.");
   1:         return NS_OK;
   1:     }
   1: 
   1:     nsThebesRenderingContext *thebesRC = NS_STATIC_CAST(nsThebesRenderingContext*, &aContext);
   1:     gfxContext *ctx = thebesRC->Thebes();
   1: 
   1: #if 0
   1:     fprintf (stderr, "nsThebesImage::Draw src [%d %d %d %d] dest [%d %d %d %d] tx [%f %f] dec [%d %d %d %d]\n",
   1:              aSourceRect.pos.x, aSourceRect.pos.y, aSWidth, aSHeight, aDX, aDY, aDWidth, aDHeight,
   1:              ctx->CurrentMatrix().GetTranslation().x, ctx->CurrentMatrix().GetTranslation().y,
   1:              mDecoded.x, mDecoded.y, mDecoded.width, mDecoded.height);
   1: #endif
   1: 
   1:     gfxMatrix savedCTM(ctx->CurrentMatrix());
   1:     PRBool doSnap = !(savedCTM.HasNonTranslation());
   1: 
   1:     if (mSinglePixel) {
   1:         // if a == 0, it's a noop
   1:         if (mSinglePixelColor.a == 0.0)
   1:             return NS_OK;
   1: 
   1:         // otherwise
   1:         ctx->SetColor(mSinglePixelColor);
   1:         ctx->NewPath();
   1:         ctx->Rectangle(aDestRect, PR_TRUE);
   1:         ctx->Fill();
   1:         return NS_OK;
   1:     }
   1: 
   1:     // See comment inside ThebesDrawTile
   1:     if (doSnap) {
   1:         gfxMatrix roundedCTM(savedCTM);
   1:         roundedCTM.x0 = ::floor(roundedCTM.x0 + 0.5);
   1:         roundedCTM.y0 = ::floor(roundedCTM.y0 + 0.5);
   1:         ctx->SetMatrix(roundedCTM);
   1:     }
   1: 
   1:     gfxFloat xscale = aDestRect.size.width / aSourceRect.size.width;
   1:     gfxFloat yscale = aDestRect.size.height / aSourceRect.size.height;
   1: 
   1:     gfxRect srcRect(aSourceRect);
   1:     gfxRect destRect(aDestRect);
   1: 
   1:     if (!GetIsImageComplete()) {
   1:       srcRect = srcRect.Intersect(gfxRect(mDecoded.x, mDecoded.y,
   1:                                           mDecoded.width, mDecoded.height));
   1: 
   1:       // This happens when mDecoded.width or height is zero. bug 368427.
   1:       if (NS_UNLIKELY(srcRect.size.width == 0 || srcRect.size.height == 0))
   1:           return NS_OK;
   1: 
   1:       destRect.pos.x += (srcRect.pos.x - aSourceRect.pos.x)*xscale;
   1:       destRect.pos.y += (srcRect.pos.y - aSourceRect.pos.y)*yscale;
   1: 
   1:       // use '+ 1 - *scale' to get rid of rounding errors
   1:       destRect.size.width  = (srcRect.size.width)*xscale + 1 - xscale;
   1:       destRect.size.height = (srcRect.size.height)*yscale + 1 - yscale;
   1:     }
   1: 
   1:     // Reject over-wide or over-tall images.
   1:     if (!AllowedImageSize(destRect.size.width, destRect.size.height))
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     gfxMatrix mat;
   1:     mat.Translate(srcRect.pos);
   1:     mat.Scale(1.0/xscale, 1.0/yscale);
   1: 
   1:     /* Translate the start point of the image (srcRect.pos)
   1:      * to coincide with the destination rectangle origin
   1:      */
   1:     mat.Translate(-destRect.pos);
   1: 
   1:     nsRefPtr<gfxPattern> pat = new gfxPattern(ThebesSurface());
   1:     pat->SetMatrix(mat);
   1: 
   1:     ctx->NewPath();
   1:     ctx->SetPattern(pat);
   1:     ctx->Rectangle(destRect, doSnap);
   1:     ctx->Fill();
   1: 
   1:     if (doSnap)
   1:         ctx->SetMatrix(savedCTM);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsThebesImage::ThebesDrawTile(gfxContext *thebesContext,
   1:                               nsIDeviceContext* dx,
   1:                               const gfxPoint& offset,
   1:                               const gfxRect& targetRect,
   1:                               const PRInt32 xPadding,
   1:                               const PRInt32 yPadding)
   1: {
   1:     NS_ASSERTION(xPadding >= 0 && yPadding >= 0, "negative padding");
   1: 
   1:     if (targetRect.size.width <= 0.0 || targetRect.size.height <= 0.0)
   1:         return NS_OK;
   1: 
   1:     // don't do anything if we have a transparent pixel source
   1:     if (mSinglePixel && mSinglePixelColor.a == 0.0)
   1:         return NS_OK;
   1: 
   1:     // so we can hold on to this for a bit longer; might not be needed
   1:     nsRefPtr<gfxPattern> pat;
   1: 
   1:     gfxMatrix savedCTM(thebesContext->CurrentMatrix());
   1:     PRBool doSnap = !(savedCTM.HasNonTranslation());
   1:     PRBool hasPadding = ((xPadding != 0) || (yPadding != 0));
   1: 
   1:     // If we need to snap, we need to round the CTM as well;
   1:     // otherwise, we may have non-integer pixels in the translation,
   1:     // which will affect the rendering of images (since the current CTM
   1:     // is what's used at the time of a SetPattern call).
   1:     if (doSnap) {
   1:         gfxMatrix roundedCTM(savedCTM);
   1:         roundedCTM.x0 = ::floor(roundedCTM.x0 + 0.5);
   1:         roundedCTM.y0 = ::floor(roundedCTM.y0 + 0.5);
   1:         thebesContext->SetMatrix(roundedCTM);
   1:     }
   1: 
   1:     nsRefPtr<gfxASurface> tmpSurfaceGrip;
   1: 
   1:     if (mSinglePixel && !hasPadding) {
   1:         thebesContext->SetColor(mSinglePixelColor);
   1:     } else {
   1:         nsRefPtr<gfxASurface> surface;
   1:         PRInt32 width, height;
   1: 
   1:         if (hasPadding) {
   1:             /* Ugh we have padding; create a temporary surface that's the size of the surface + pad area,
   1:              * and render the image into it first.  Then we'll tile that surface. */
   1:             width = mWidth + xPadding;
   1:             height = mHeight + yPadding;
   1: 
   1:             // Reject over-wide or over-tall images.
   1:             if (!AllowedImageSize(width, height))
   1:                 return NS_ERROR_FAILURE;
   1: 
   1:             surface = new gfxImageSurface(gfxIntSize(width, height),
   1:                                           gfxASurface::ImageFormatARGB32);
1349:             if (!surface || surface->Status()) {
1349:                 thebesContext->SetMatrix(savedCTM);
1349:                 return NS_ERROR_OUT_OF_MEMORY;
1349:             }
1349: 
   1:             tmpSurfaceGrip = surface;
   1: 
   1:             nsRefPtr<gfxContext> tmpContext = new gfxContext(surface);
   1:             if (mSinglePixel) {
   1:                 tmpContext->SetColor(mSinglePixelColor);
   1:             } else {
   1:                 tmpContext->SetSource(ThebesSurface());
   1:             }
   1:             tmpContext->SetOperator(gfxContext::OPERATOR_SOURCE);
   1:             tmpContext->Rectangle(gfxRect(0, 0, mWidth, mHeight));
   1:             tmpContext->Fill();
   1:         } else {
   1:             width = mWidth;
   1:             height = mHeight;
   1:             surface = ThebesSurface();
   1:         }
   1: 
   1:         gfxMatrix patMat;
   1:         gfxPoint p0;
   1: 
   1:         if (offset.x > width || offset.y > height) {
   1:             p0.x = - floor(fmod(offset.x, gfxFloat(width)) + 0.5);
   1:             p0.y = - floor(fmod(offset.y, gfxFloat(height)) + 0.5);
   1:         } else {
   1:             p0.x = - floor(offset.x + 0.5);
   1:             p0.y = - floor(offset.y + 0.5);
   1:         }
   1:         // Scale factor to account for CSS pixels; note that the offset (and 
   1:         // therefore p0) is in device pixels, while the width and height are in
   1:         // CSS pixels.
   1:         gfxFloat scale = gfxFloat(nsIDeviceContext::AppUnitsPerCSSPixel()) / 
   1:                          gfxFloat(dx->AppUnitsPerDevPixel());
   1:         patMat.Scale(1.0 / scale, 1.0 / scale);
   1:         patMat.Translate(p0);
   1: 
   1:         pat = new gfxPattern(surface);
   1:         pat->SetExtend(gfxPattern::EXTEND_REPEAT);
   1:         pat->SetMatrix(patMat);
   1: 
   1:         thebesContext->SetPattern(pat);
   1:     }
   1: 
   1:     thebesContext->NewPath();
   1:     thebesContext->Rectangle(targetRect, doSnap);
   1:     thebesContext->Fill();
   1: 
   1:     thebesContext->SetColor(gfxRGBA(0,0,0,0));
   1:     if (doSnap)
   1:         thebesContext->SetMatrix(savedCTM);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: /* This function is going away; it's been replaced by ThebesDrawTile above. */
   1: NS_IMETHODIMP
   1: nsThebesImage::DrawTile(nsIRenderingContext &aContext,
   1:                         nsIDrawingSurface *aSurface,
   1:                         PRInt32 aSXOffset, PRInt32 aSYOffset,
   1:                         PRInt32 aPadX, PRInt32 aPadY,
   1:                         const nsRect &aTileRect)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: /* This is only used by the GIF decoder, via gfxImageFrame::DrawTo */
   1: NS_IMETHODIMP
   1: nsThebesImage::DrawToImage(nsIImage* aDstImage, PRInt32 aDX, PRInt32 aDY, PRInt32 aDWidth, PRInt32 aDHeight)
   1: {
   1:     nsThebesImage *dstThebesImage = NS_STATIC_CAST(nsThebesImage*, aDstImage);
   1: 
   1:     nsRefPtr<gfxContext> dst = new gfxContext(dstThebesImage->ThebesSurface());
   1: 
   1:     dst->NewPath();
   1:     // We don't use PixelSnappedRectangleAndSetPattern because if
   1:     // these coords aren't already pixel aligned, we've lost
   1:     // before we've even begun.
   1:     dst->Translate(gfxPoint(aDX, aDY));
   1:     dst->Rectangle(gfxRect(0, 0, aDWidth, aDHeight), PR_TRUE);
   1:     dst->Scale(double(aDWidth)/mWidth, double(aDHeight)/mHeight);
   1: 
   1:     dst->SetSource(ThebesSurface());
   1:     dst->Paint();
   1: 
   1:     return NS_OK;
   1: }
 271: 
 271: PRBool
 271: nsThebesImage::ShouldUseImageSurfaces()
 271: {
 271: #ifdef XP_WIN
 271:     static const DWORD kGDIObjectsHighWaterMark = 7000;
 271: 
 271:     // at 7000 GDI objects, stop allocating normal images to make sure
 271:     // we never hit the 10k hard limit.
 271:     // GetCurrentProcess() just returns (HANDLE)-1, it's inlined afaik
 271:     DWORD count = GetGuiResources(GetCurrentProcess(), GR_GDIOBJECTS);
 271:     if (count == 0 ||
 271:         count > kGDIObjectsHighWaterMark)
 271:     {
 271:         // either something's broken (count == 0),
 271:         // or we hit our high water mark; disable
 271:         // image allocations for a bit.
 271:         return PR_TRUE;
 271:     }
 271: #endif
 271: 
 271:     return PR_FALSE;
 271: }
