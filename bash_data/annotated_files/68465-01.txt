    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Author: Eric Vaughan (evaughan@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
41384: #include "nsHTMLFormControlAccessible.h"
41384: 
67790: #include "States.h"
    1: #include "nsAccessibilityAtoms.h"
41384: #include "nsAccUtils.h"
41384: #include "nsRelUtils.h"
41384: #include "nsTextEquivUtils.h"
41384: 
  392: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLInputElement.h"
 1247: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIDOMNSEditableElement.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIDOMHTMLTextAreaElement.h"
 4625: #include "nsIEditor.h"
    1: #include "nsIFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsISelectionController.h"
 3945: #include "jsapi.h"
 3945: #include "nsIJSContextStack.h"
 3945: #include "nsIServiceManager.h"
    1: #include "nsITextControlFrame.h"
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsHTMLCheckboxAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsHTMLCheckboxAccessible::
43504:   nsHTMLCheckboxAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsFormControlAccessible(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsHTMLCheckboxAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_CHECKBUTTON;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLCheckboxAccessible::GetNumActions(PRUint8 *_retval)
    1: {
    1:   *_retval = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLCheckboxAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {    // 0 is the magic value for default action
25871:     // cycle, check or uncheck
67790:     PRUint64 state = NativeState();
    1: 
67790:     if (state & states::CHECKED)
    1:       aName.AssignLiteral("uncheck"); 
67790:     else if (state & states::MIXED)
25871:       aName.AssignLiteral("cycle"); 
    1:     else
    1:       aName.AssignLiteral("check"); 
    1: 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
37481: NS_IMETHODIMP
37481: nsHTMLCheckboxAccessible::DoAction(PRUint8 aIndex)
    1: {
37481:   if (aIndex != 0)
    1:     return NS_ERROR_INVALID_ARG;
37481: 
37481:   DoCommand();
37481:   return NS_OK;
    1: }
    1: 
67790: PRUint64
67790: nsHTMLCheckboxAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsFormControlAccessible::NativeState();
  262: 
67790:   state |= states::CHECKABLE;
67790:   PRBool checkState = PR_FALSE;   // Radio buttons and check boxes can be checked or mixed
    1: 
43504:   nsCOMPtr<nsIDOMHTMLInputElement> htmlCheckboxElement =
43504:     do_QueryInterface(mContent);
48892:            
24914:   if (htmlCheckboxElement) {
67790:     htmlCheckboxElement->GetIndeterminate(&checkState);
    1: 
67790:     if (checkState) {
67790:       state |= states::MIXED;
48892:     } else {   // indeterminate can't be checked at the same time.
67790:       htmlCheckboxElement->GetChecked(&checkState);
48892:     
67790:       if (checkState)
67790:         state |= states::CHECKED;
24914:     }
48892:   }
67790:   return state;
    1: }
    1: 
36879: ////////////////////////////////////////////////////////////////////////////////
36879: // nsHTMLRadioButtonAccessible
36879: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsHTMLRadioButtonAccessible::
43504:   nsHTMLRadioButtonAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsRadioButtonAccessible(aContent, aShell)
    1: {
    1: }
    1: 
67790: PRUint64
67790: nsHTMLRadioButtonAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsAccessibleWrap::NativeState();
  262: 
67790:   state |= states::CHECKABLE;
 1157:   
    1:   PRBool checked = PR_FALSE;   // Radio buttons and check boxes can be checked
    1: 
43504:   nsCOMPtr<nsIDOMHTMLInputElement> htmlRadioElement =
43504:     do_QueryInterface(mContent);
    1:   if (htmlRadioElement)
    1:     htmlRadioElement->GetChecked(&checked);
    1: 
    1:   if (checked)
67790:     state |= states::CHECKED;
    1: 
67790:   return state;
    1: }
    1: 
36879: void
36879: nsHTMLRadioButtonAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet,
36879:                                                         PRInt32 *aSetSize)
  144: {
  144:   nsAutoString nsURI;
43504:   mContent->NodeInfo()->GetNamespaceURI(nsURI);
  144:   nsAutoString tagName;
43504:   mContent->NodeInfo()->GetName(tagName);
  283: 
  283:   nsAutoString type;
43504:   mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::type, type);
  283:   nsAutoString name;
43504:   mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::name, name);
  283: 
  392:   nsCOMPtr<nsIDOMNodeList> inputs;
  392: 
43504:   nsCOMPtr<nsIDOMHTMLInputElement> radio(do_QueryInterface(mContent));
  144:   nsCOMPtr<nsIDOMHTMLFormElement> form;
  144:   radio->GetForm(getter_AddRefs(form));
  392:   if (form) {
  392:     form->GetElementsByTagNameNS(nsURI, tagName, getter_AddRefs(inputs));
  392:   } else {
43504:     nsIDocument* doc = mContent->GetOwnerDoc();
43504:     nsCOMPtr<nsIDOMDocument> document(do_QueryInterface(doc));
  392:     if (document)
  392:       document->GetElementsByTagNameNS(nsURI, tagName, getter_AddRefs(inputs));
  392:   }
  144: 
36879:   NS_ENSURE_TRUE(inputs, );
  144: 
  283:   PRUint32 inputsCount = 0;
  283:   inputs->GetLength(&inputsCount);
  144: 
36879:   // Compute posinset and setsize.
  144:   PRInt32 indexOf = 0;
  283:   PRInt32 count = 0;
  283: 
  283:   for (PRUint32 index = 0; index < inputsCount; index++) {
  283:     nsCOMPtr<nsIDOMNode> itemNode;
  283:     inputs->Item(index, getter_AddRefs(itemNode));
  283: 
  283:     nsCOMPtr<nsIContent> item(do_QueryInterface(itemNode));
  283:     if (item &&
  283:         item->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
  283:                           type, eCaseMatters) &&
  283:         item->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::name,
  283:                           name, eCaseMatters)) {
  283: 
  283:       count++;
  283: 
43504:       if (item == mContent)
  283:         indexOf = count;
  144:     }
  144:   }
  144: 
36879:   *aPosInSet = indexOf;
36879:   *aSetSize = count;
  144: }
  144: 
36879: ////////////////////////////////////////////////////////////////////////////////
36879: // nsHTMLButtonAccessible
36879: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsHTMLButtonAccessible::
43504:   nsHTMLButtonAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLButtonAccessible::GetNumActions(PRUint8 *_retval)
    1: {
    1:   *_retval = 1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLButtonAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     aName.AssignLiteral("press"); 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
37481: NS_IMETHODIMP
37481: nsHTMLButtonAccessible::DoAction(PRUint8 aIndex)
    1: {
37481:   if (aIndex != eAction_Click)
    1:     return NS_ERROR_INVALID_ARG;
37481: 
37481:   DoCommand();
37481:   return NS_OK;
    1: }
    1: 
67790: PRUint64
67790: nsHTMLButtonAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsHyperTextAccessibleWrap::NativeState();
11542: 
43504:   if (mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
43504:                             nsAccessibilityAtoms::submit, eIgnoreCase))
67790:     state |= states::DEFAULT;
    1: 
67790:   return state;
    1: }
    1: 
52027: PRUint32
52027: nsHTMLButtonAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_PUSHBUTTON;
    1: }
    1: 
20246: nsresult
20246: nsHTMLButtonAccessible::GetNameInternal(nsAString& aName)
    1: {
29559:   nsAccessible::GetNameInternal(aName);
20452:   if (!aName.IsEmpty())
20452:     return NS_OK;
20452: 
20452:   // No name from HTML or ARIA
    1:   nsAutoString name;
43504:   if (!mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::value,
    1:                          name) &&
43504:       !mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::alt,
    1:                          name)) {
    1:     // Use the button's (default) label if nothing else works
    1:     nsIFrame* frame = GetFrame();
    1:     if (frame) {
23554:       nsIFormControlFrame* fcFrame = do_QueryFrame(frame);
    1:       if (fcFrame)
    1:         fcFrame->GetFormProperty(nsAccessibilityAtoms::defaultLabel, name);
    1:     }
    1:   }
20452: 
    1:   if (name.IsEmpty() &&
43504:       !mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::src,
    1:                          name)) {
43504:     mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::data, name);
    1:   }
    1: 
    1:   name.CompressWhitespace();
    1:   aName = name;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsHTML4ButtonAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsHTML4ButtonAccessible::
43504:   nsHTML4ButtonAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsHTML4ButtonAccessible::GetNumActions(PRUint8 *_retval)
    1: {
    1:   *_retval = 1;
    1:   return NS_OK;;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTML4ButtonAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     aName.AssignLiteral("press"); 
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
37481: NS_IMETHODIMP
37481: nsHTML4ButtonAccessible::DoAction(PRUint8 aIndex)
    1: {
37481:   if (aIndex != 0)
    1:     return NS_ERROR_INVALID_ARG;
37481: 
37481:   DoCommand();
37481:   return NS_OK;
    1: }
    1: 
52027: PRUint32
52027: nsHTML4ButtonAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_PUSHBUTTON;
    1: }
    1: 
67790: PRUint64
67790: nsHTML4ButtonAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsHyperTextAccessibleWrap::NativeState();
11542: 
67790:   state |= states::FOCUSABLE;
    1: 
43504:   if (mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
43504:                             nsAccessibilityAtoms::submit, eIgnoreCase))
67790:     state |= states::DEFAULT;
    1: 
67790:   return state;
    1: }
    1: 
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsHTMLTextFieldAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
43504: 
43504: nsHTMLTextFieldAccessible::
43504:   nsHTMLTextFieldAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
 7766: NS_IMPL_ISUPPORTS_INHERITED3(nsHTMLTextFieldAccessible, nsAccessible, nsHyperTextAccessible, nsIAccessibleText, nsIAccessibleEditableText)
 7766: 
52027: PRUint32
52027: nsHTMLTextFieldAccessible::NativeRole()
    1: {
43504:   if (mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
    1:                             nsAccessibilityAtoms::password, eIgnoreCase)) {
52027:     return nsIAccessibleRole::ROLE_PASSWORD_TEXT;
    1:   }
52027:   return nsIAccessibleRole::ROLE_ENTRY;
    1: }
    1: 
20452: nsresult
20452: nsHTMLTextFieldAccessible::GetNameInternal(nsAString& aName)
 2425: {
20452:   nsresult rv = nsAccessible::GetNameInternal(aName);
20246:   NS_ENSURE_SUCCESS(rv, rv);
20246: 
20246:   if (!aName.IsEmpty())
20246:     return NS_OK;
20246: 
57106:   if (mContent->GetBindingParent())
57106:   {
20452:     // XXX: bug 459640
 2425:     // There's a binding parent.
 2425:     // This means we're part of another control, so use parent accessible for name.
 2425:     // This ensures that a textbox inside of a XUL widget gets
 2425:     // an accessible name.
43504:     nsAccessible* parent = GetParent();
57106:     parent->GetName(aName);
57106:   }
57106: 
57106:   if (!aName.IsEmpty())
57106:     return NS_OK;
57106: 
57106:   // text inputs and textareas might have useful placeholder text
57106:   mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::placeholder, aName);
57106: 
57106:   return NS_OK;
 2425: }
 2425: 
    1: NS_IMETHODIMP nsHTMLTextFieldAccessible::GetValue(nsAString& _retval)
    1: {
68465:   if (IsDefunct())
68465:     return NS_ERROR_FAILURE;
68465: 
67790:   if (NativeState() & states::PROTECTED)    // Don't return password text!
    1:     return NS_ERROR_FAILURE;
    1: 
43504:   nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea(do_QueryInterface(mContent));
    1:   if (textArea) {
    1:     return textArea->GetValue(_retval);
    1:   }
    1:   
43504:   nsCOMPtr<nsIDOMHTMLInputElement> inputElement(do_QueryInterface(mContent));
    1:   if (inputElement) {
    1:     return inputElement->GetValue(_retval);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
67790: PRUint64
67790: nsHTMLTextFieldAccessible::NativeState()
    1: {
67790:   PRUint64 state = nsHyperTextAccessibleWrap::NativeState();
    1: 
    1:   // can be focusable, focused, protected. readonly, unavailable, selected
43504:   if (mContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
    1:                             nsAccessibilityAtoms::password, eIgnoreCase)) {
67790:     state |= states::PROTECTED;
    1:   }
    1:   else {
52089:     nsAccessible* parent = GetParent();
52089:     if (parent && parent->Role() == nsIAccessibleRole::ROLE_AUTOCOMPLETE)
67790:       state |= states::HASPOPUP;
    1:   }
    1: 
43504:   if (mContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::readonly)) {
67790:     state |= states::READONLY;
    1:   }
    1: 
43504:   nsCOMPtr<nsIDOMHTMLInputElement> htmlInput(do_QueryInterface(mContent));
    1:   // Is it an <input> or a <textarea> ?
 2089:   if (htmlInput) {
67790:     state |= states::SINGLE_LINE;
 2089:   }
 2089:   else {
67790:     state |= states::MULTI_LINE;
 2089:   }
    1: 
67790:   if (!(state & states::EDITABLE))
67790:     return state;
15638: 
43504:   nsCOMPtr<nsIContent> bindingContent = mContent->GetBindingParent();
  374:   if (bindingContent &&
  374:       bindingContent->NodeInfo()->Equals(nsAccessibilityAtoms::textbox,
67789:                                          kNameSpaceID_XUL)) {
67789:      if (bindingContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::type,
  374:                                      nsAccessibilityAtoms::autocomplete,
  374:                                      eIgnoreCase)) {
  374:        // If parent is XUL textbox and value of @type attribute is "autocomplete",
  374:        // then this accessible supports autocompletion.
67790:        state |= states::SUPPORTS_AUTOCOMPLETION;
67789:      }
67790:   } else if (gIsFormFillEnabled && htmlInput && !(state & states::PROTECTED)) {
  374:     // Check to see if autocompletion is allowed on this input. We don't expose
  374:     // it for password fields even though the entire password can be remembered
  374:     // for a page if the user asks it to be. However, the kind of autocomplete
  374:     // we're talking here is based on what the user types, where a popup of
  374:     // possible choices comes up.
    1:     nsAutoString autocomplete;
43504:     mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::autocomplete,
  374:                       autocomplete);
  374: 
    1:     if (!autocomplete.LowerCaseEqualsLiteral("off")) {
    1:       nsCOMPtr<nsIDOMHTMLFormElement> form;
    1:       htmlInput->GetForm(getter_AddRefs(form));
  374:       nsCOMPtr<nsIContent> formContent(do_QueryInterface(form));
  374:       if (formContent) {
  374:         formContent->GetAttr(kNameSpaceID_None,
  374:                              nsAccessibilityAtoms::autocomplete, autocomplete);
  374:       }
  374: 
  374:       if (!formContent || !autocomplete.LowerCaseEqualsLiteral("off"))
67790:         state |= states::SUPPORTS_AUTOCOMPLETION;
  332:     }
  372:   }
    1: 
67790:   return state;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLTextFieldAccessible::GetNumActions(PRUint8 *_retval)
    1: {
    1:   *_retval = 1;
    1:   return NS_OK;;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLTextFieldAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
    1:   if (aIndex == eAction_Click) {
    1:     aName.AssignLiteral("activate");
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLTextFieldAccessible::DoAction(PRUint8 index)
    1: {
    1:   if (index == 0) {
67818:     nsCOMPtr<nsIDOMHTMLElement> element(do_QueryInterface(mContent));
 1247:     if ( element ) {
 1247:       return element->Focus();
    1:     }
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
 4625: NS_IMETHODIMP nsHTMLTextFieldAccessible::GetAssociatedEditor(nsIEditor **aEditor)
    1: {
 4625:   *aEditor = nsnull;
43504:   nsCOMPtr<nsIDOMNSEditableElement> editableElt(do_QueryInterface(mContent));
 4625:   NS_ENSURE_TRUE(editableElt, NS_ERROR_FAILURE);
    1: 
 3945:   // nsGenericHTMLElement::GetEditor has a security check.
 3945:   // Make sure we're not restricted by the permissions of
 3945:   // whatever script is currently running.
 3945:   nsCOMPtr<nsIJSContextStack> stack =
 3945:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 3945:   PRBool pushed = stack && NS_SUCCEEDED(stack->Push(nsnull));
 3945: 
    1:   nsCOMPtr<nsIEditor> editor;
 4625:   nsresult rv = editableElt->GetEditor(aEditor);
 3945: 
 3945:   if (pushed) {
 3945:     JSContext* cx;
 3945:     stack->Pop(&cx);
 3945:     NS_ASSERTION(!cx, "context should be null");
 3945:   }
 4625: 
 4625:   return rv;
    1: }
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsHTMLGroupboxAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsHTMLGroupboxAccessible::
43504:   nsHTMLGroupboxAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
    1: {
    1: }
    1: 
52027: PRUint32
52027: nsHTMLGroupboxAccessible::NativeRole()
    1: {
52027:   return nsIAccessibleRole::ROLE_GROUPING;
    1: }
    1: 
 2985: nsIContent* nsHTMLGroupboxAccessible::GetLegend()
    1: {
 2985:   nsresult count = 0;
43504:   nsIContent *legendContent = nsnull;
43504:   while ((legendContent = mContent->GetChildAt(count++)) != nsnull) {
43504:     if (legendContent->NodeInfo()->Equals(nsAccessibilityAtoms::legend,
43504:                                           mContent->GetNameSpaceID())) {
 2985:       // Either XHTML namespace or no namespace
43504:       return legendContent;
 2985:     }
 2985:   }
 2985: 
 2985:   return nsnull;
    1: }
    1: 
20246: nsresult
20246: nsHTMLGroupboxAccessible::GetNameInternal(nsAString& aName)
    1: {
20246:   nsresult rv = nsAccessible::GetNameInternal(aName);
20246:   NS_ENSURE_SUCCESS(rv, rv);
18347: 
20246:   if (!aName.IsEmpty())
    1:     return NS_OK;
    1: 
 2985:   nsIContent *legendContent = GetLegend();
    1:   if (legendContent) {
25175:     return nsTextEquivUtils::
25175:       AppendTextEquivFromContent(this, legendContent, &aName);
    1:   }
 2985: 
    1:   return NS_OK;
    1: }
    1: 
 2985: NS_IMETHODIMP
24822: nsHTMLGroupboxAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                             nsIAccessibleRelation **aRelation)
    1: {
24822:   nsresult rv = nsHyperTextAccessibleWrap::GetRelationByType(aRelationType,
24822:                                                              aRelation);
24822:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 2985:   if (aRelationType == nsIAccessibleRelation::RELATION_LABELLED_BY) {
 2985:     // No override for label, so use <legend> for this <fieldset>
24822:     return nsRelUtils::
24822:       AddTargetFromContent(aRelationType, aRelation, GetLegend());
    1:   }
 2985: 
 2985:   return NS_OK;
    1: }
 2985: 
43504: 
25822: ////////////////////////////////////////////////////////////////////////////////
25822: // nsHTMLLegendAccessible
43504: ////////////////////////////////////////////////////////////////////////////////
25822: 
43504: nsHTMLLegendAccessible::
43504:   nsHTMLLegendAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
 2985: {
    1: }
 2985: 
 2985: NS_IMETHODIMP
24822: nsHTMLLegendAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                           nsIAccessibleRelation **aRelation)
 2985: {
24822:   nsresult rv = nsHyperTextAccessibleWrap::
24822:     GetRelationByType(aRelationType, aRelation);
24822:   NS_ENSURE_SUCCESS(rv, rv);
 2985: 
 2985:   if (aRelationType == nsIAccessibleRelation::RELATION_LABEL_FOR) {
 2985:     // Look for groupbox parent
36989:     nsAccessible* groupbox = GetParent();
36989: 
52089:     if (groupbox && groupbox->Role() == nsIAccessibleRole::ROLE_GROUPING) {
24822:       // XXX: if group box exposes more than one relation of the given type
24822:       // then we fail.
24822:       nsCOMPtr<nsIAccessible> testLabelAccessible =
36989:         nsRelUtils::GetRelatedAccessible(groupbox,
24822:                                          nsIAccessibleRelation::RELATION_LABELLED_BY);
24822: 
 2985:       if (testLabelAccessible == this) {
24822:         // We're the first child of the parent groupbox, see
24822:         // nsHTMLGroupboxAccessible::GetRelationByType().
24822:         return nsRelUtils::
36989:           AddTarget(aRelationType, aRelation, groupbox);
 2985:       }
 2985:     }
 2985:   }
 2985: 
 2985:   return NS_OK;
 2985: }
25822: 
52027: PRUint32
52027: nsHTMLLegendAccessible::NativeRole()
25822: {
52027:   return nsIAccessibleRole::ROLE_LABEL;
25822: }
