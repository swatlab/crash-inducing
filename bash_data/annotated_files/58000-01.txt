    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla toolkit.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Benjamin Smedberg <benjamin@smedbergs.us>
    1:  *
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsICommandLineRunner.h"
    1: 
    1: #include "nsICategoryManager.h"
    1: #include "nsICommandLineHandler.h"
 3321: #include "nsICommandLineValidator.h"
47978: #include "nsIConsoleService.h"
    1: #include "nsIClassInfoImpl.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIFile.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIStringEnumerator.h"
    1: 
    1: #include "nsCOMPtr.h"
46998: #include "mozilla/ModuleUtils.h"
    1: #include "nsISupportsImpl.h"
    1: #include "nsNativeCharsetUtils.h"
    1: #include "nsNetUtil.h"
    1: #include "nsUnicharUtils.h"
23904: #include "nsTArray.h"
47978: #include "nsTextFormatter.h"
    1: #include "nsXPCOMCID.h"
    1: #include "plstr.h"
    1: 
    1: #ifdef XP_MACOSX
26366: #include <CoreFoundation/CoreFoundation.h>
    1: #include "nsILocalFileMac.h"
    1: #elif defined(XP_WIN)
    1: #include <windows.h>
    1: #include <shlobj.h>
    1: #elif defined(XP_BEOS)
    1: #include <Path.h>
    1: #include <Directory.h>
    1: #elif defined(XP_UNIX)
    1: #include <unistd.h>
    1: #elif defined(XP_OS2)
    1: #include <os2.h>
    1: #endif
    1: 
    1: #ifdef DEBUG_bsmedberg
    1: #define DEBUG_COMMANDLINE
    1: #endif
    1: 
47016: #define NS_COMMANDLINE_CID \
47016:   { 0x23bcc750, 0xdc20, 0x460b, { 0xb2, 0xd4, 0x74, 0xd8, 0xf5, 0x8d, 0x36, 0x15 } }
47016: 
    1: class nsCommandLine : public nsICommandLineRunner
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSICOMMANDLINE
    1:   NS_DECL_NSICOMMANDLINERUNNER
    1: 
    1:   nsCommandLine();
    1: 
    1: protected:
    1:   ~nsCommandLine() { }
    1: 
 3321:   typedef nsresult (*EnumerateHandlersCallback)(nsICommandLineHandler* aHandler,
 3321: 					nsICommandLine* aThis,
 3321: 					void *aClosure);
 3321:   typedef nsresult (*EnumerateValidatorsCallback)(nsICommandLineValidator* aValidator,
    1: 					nsICommandLine* aThis,
    1: 					void *aClosure);
    1: 
    1:   void appendArg(const char* arg);
14484:   void resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL);
 3321:   nsresult EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure);
 3321:   nsresult EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure);
    1: 
23904:   nsTArray<nsString>      mArgs;
    1:   PRUint32                mState;
    1:   nsCOMPtr<nsIFile>       mWorkingDir;
    1:   nsCOMPtr<nsIDOMWindow>  mWindowContext;
    1:   PRBool                  mPreventDefault;
    1: };
    1: 
    1: nsCommandLine::nsCommandLine() :
    1:   mState(STATE_INITIAL_LAUNCH),
    1:   mPreventDefault(PR_FALSE)
    1: {
    1: 
    1: }
    1: 
    1: 
47016: NS_IMPL_CLASSINFO(nsCommandLine, NULL, 0, NS_COMMANDLINE_CID)
    1: NS_IMPL_ISUPPORTS2_CI(nsCommandLine,
    1:                       nsICommandLine,
    1:                       nsICommandLineRunner)
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetLength(PRInt32 *aResult)
    1: {
23904:   *aResult = PRInt32(mArgs.Length());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetArgument(PRInt32 aIndex, nsAString& aResult)
    1: {
    1:   NS_ENSURE_ARG_MIN(aIndex, 0);
41700:   NS_ENSURE_ARG_MAX(PRUint32(aIndex), mArgs.Length());
    1: 
23904:   aResult = mArgs[aIndex];
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::FindFlag(const nsAString& aFlag, PRBool aCaseSensitive, PRInt32 *aResult)
    1: {
    1:   NS_ENSURE_ARG(!aFlag.IsEmpty());
    1: 
    1:   nsDefaultStringComparator caseCmp;
    1:   nsCaseInsensitiveStringComparator caseICmp;
    1:   nsStringComparator& c = aCaseSensitive ?
 3233:     static_cast<nsStringComparator&>(caseCmp) :
 3233:     static_cast<nsStringComparator&>(caseICmp);
    1: 
23904:   for (PRUint32 f = 0; f < mArgs.Length(); f++) {
23904:     const nsString &arg = mArgs[f];
    1: 
    1:     if (arg.Length() >= 2 && arg.First() == PRUnichar('-')) {
    1:       if (aFlag.Equals(Substring(arg, 1), c)) {
    1:         *aResult = f;
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   *aResult = -1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::RemoveArguments(PRInt32 aStart, PRInt32 aEnd)
    1: {
    1:   NS_ENSURE_ARG_MIN(aStart, 0);
41700:   NS_ENSURE_ARG_MAX(PRUint32(aEnd) + 1, mArgs.Length());
    1: 
    1:   for (PRInt32 i = aEnd; i >= aStart; --i) {
23904:     mArgs.RemoveElementAt(i);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::HandleFlag(const nsAString& aFlag, PRBool aCaseSensitive,
    1:                           PRBool *aResult)
    1: {
    1:   nsresult rv;
    1: 
    1:   PRInt32 found;
    1:   rv = FindFlag(aFlag, aCaseSensitive, &found);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (found == -1) {
    1:     *aResult = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aResult = PR_TRUE;
    1:   RemoveArguments(found, found);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::HandleFlagWithParam(const nsAString& aFlag, PRBool aCaseSensitive,
    1:                                    nsAString& aResult)
    1: {
    1:   nsresult rv;
    1: 
    1:   PRInt32 found;
    1:   rv = FindFlag(aFlag, aCaseSensitive, &found);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (found == -1) {
    1:     aResult.SetIsVoid(PR_TRUE);
    1:     return NS_OK;
    1:   }
    1: 
23904:   if (found == PRInt32(mArgs.Length()) - 1) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   ++found;
    1: 
23904:   if (mArgs[found].First() == '-') {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
23904:   aResult = mArgs[found];
    1:   RemoveArguments(found - 1, found);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetState(PRUint32 *aResult)
    1: {
    1:   *aResult = mState;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetPreventDefault(PRBool *aResult)
    1: {
    1:   *aResult = mPreventDefault;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::SetPreventDefault(PRBool aValue)
    1: {
    1:   mPreventDefault = aValue;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetWorkingDirectory(nsIFile* *aResult)
    1: {
    1:   NS_ENSURE_TRUE(mWorkingDir, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   NS_ADDREF(*aResult = mWorkingDir);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetWindowContext(nsIDOMWindow* *aResult)
    1: {
    1:   NS_IF_ADDREF(*aResult = mWindowContext);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::SetWindowContext(nsIDOMWindow* aValue)
    1: {
    1:   mWindowContext = aValue;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::ResolveFile(const nsAString& aArgument, nsIFile* *aResult)
    1: {
    1:   NS_ENSURE_TRUE(mWorkingDir, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // This is some seriously screwed-up code. nsILocalFile.appendRelativeNativePath
    1:   // explicitly does not accept .. or . path parts, but that is exactly what we
    1:   // need here. So we hack around it.
    1: 
    1:   nsresult rv;
    1: 
    1: #if defined(XP_MACOSX)
    1:   nsCOMPtr<nsILocalFileMac> lfm (do_QueryInterface(mWorkingDir));
    1:   NS_ENSURE_TRUE(lfm, NS_ERROR_NO_INTERFACE);
    1: 
    1:   nsCOMPtr<nsILocalFileMac> newfile (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
    1:   NS_ENSURE_TRUE(newfile, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   CFURLRef baseurl;
    1:   rv = lfm->GetCFURL(&baseurl);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCAutoString path;
    1:   NS_CopyUnicodeToNative(aArgument, path);
    1: 
    1:   CFURLRef newurl =
    1:     CFURLCreateFromFileSystemRepresentationRelativeToBase(NULL, (const UInt8*) path.get(),
    1:                                                           path.Length(),
    1:                                                           true, baseurl);
    1: 
    1:   CFRelease(baseurl);
    1: 
    1:   rv = newfile->InitWithCFURL(newurl);
    1:   CFRelease(newurl);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   NS_ADDREF(*aResult = newfile);
    1:   return NS_OK;
    1: 
    1: #elif defined(XP_BEOS)
    1:   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
    1:   NS_ENSURE_TRUE(lf, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (aArgument.First() == '/') {
    1:     // absolute path
    1:     rv = lf->InitWithPath(aArgument);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     NS_ADDREF(*aResult = lf);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCAutoString carg;
    1:   NS_CopyUnicodeToNative(aArgument, carg);
    1: 
    1:   nsCAutoString wd;
    1:   rv = mWorkingDir->GetNativePath(wd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   BDirectory bwd(wd.get());
    1: 
    1:   BPath resolved(&bwd, carg.get(), true);
    1:   if (resolved.InitCheck() != B_OK)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   rv = lf->InitWithNativePath(nsDependentCString(resolved.Path()));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   NS_ADDREF(*aResult = lf);
    1:   return NS_OK;
    1: 
    1: #elif defined(XP_UNIX)
    1:   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
    1:   NS_ENSURE_TRUE(lf, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (aArgument.First() == '/') {
    1:     // absolute path
    1:     rv = lf->InitWithPath(aArgument);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     NS_ADDREF(*aResult = lf);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCAutoString nativeArg;
    1:   NS_CopyUnicodeToNative(aArgument, nativeArg);
    1: 
    1:   nsCAutoString newpath;
    1:   mWorkingDir->GetNativePath(newpath);
    1: 
    1:   newpath.Append('/');
    1:   newpath.Append(nativeArg);
    1: 
    1:   rv = lf->InitWithNativePath(newpath);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = lf->Normalize();
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   NS_ADDREF(*aResult = lf);
    1:   return NS_OK;
    1: 
    1: #elif defined(XP_WIN32)
    1:   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
    1:   NS_ENSURE_TRUE(lf, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   rv = lf->InitWithPath(aArgument);
    1:   if (NS_FAILED(rv)) {
    1:     // If it's a relative path, the Init is *going* to fail. We use string magic and
    1:     // win32 _fullpath. Note that paths of the form "\Relative\To\CurDrive" are
    1:     // going to fail, and I haven't figured out a way to work around this without
    1:     // the PathCombine() function, which is not available in plain win95/nt4
    1: 
 9738:     nsAutoString fullPath;
 9738:     mWorkingDir->GetPath(fullPath);
    1: 
    1:     fullPath.Append('\\');
 9738:     fullPath.Append(aArgument);
    1: 
 9738:     WCHAR pathBuf[MAX_PATH];
 9738:     if (!_wfullpath(pathBuf, fullPath.get(), MAX_PATH))
    1:       return NS_ERROR_FAILURE;
    1: 
 9738:     rv = lf->InitWithPath(nsDependentString(pathBuf));
    1:     if (NS_FAILED(rv)) return rv;
    1:   }
    1:   NS_ADDREF(*aResult = lf);
    1:   return NS_OK;
    1: 
    1: #elif defined(XP_OS2)
    1:   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
    1:   NS_ENSURE_TRUE(lf, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   rv = lf->InitWithPath(aArgument);
    1:   if (NS_FAILED(rv)) {
    1: 
    1:     nsCAutoString fullPath;
    1:     mWorkingDir->GetNativePath(fullPath);
    1: 
    1:     nsCAutoString carg;
    1:     NS_CopyUnicodeToNative(aArgument, carg);
    1: 
    1:     fullPath.Append('\\');
    1:     fullPath.Append(carg);
    1: 
    1:     char pathBuf[CCHMAXPATH];
    1:     if (DosQueryPathInfo(fullPath.get(), FIL_QUERYFULLNAME, pathBuf, sizeof(pathBuf)))
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     rv = lf->InitWithNativePath(nsDependentCString(pathBuf));
    1:     if (NS_FAILED(rv)) return rv;
    1:   }
    1:   NS_ADDREF(*aResult = lf);
    1:   return NS_OK;
    1: 
    1: #else
    1: #error Need platform-specific logic here.
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::ResolveURI(const nsAString& aArgument, nsIURI* *aResult)
    1: {
    1:   nsresult rv;
    1: 
    1:   // First, we try to init the argument as an absolute file path. If this doesn't
    1:   // work, it is an absolute or relative URI.
    1: 
    1:   nsCOMPtr<nsIIOService> io = do_GetIOService();
    1:   NS_ENSURE_TRUE(io, NS_ERROR_OUT_OF_MEMORY);
    1: 
14484:   nsCOMPtr<nsIURI> workingDirURI;
14484:   if (mWorkingDir) {
14484:     io->NewFileURI(mWorkingDir, getter_AddRefs(workingDirURI));
14484:   }
14484: 
    1:   nsCOMPtr<nsILocalFile> lf (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
    1:   rv = lf->InitWithPath(aArgument);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     lf->Normalize();
14484:     nsCAutoString url;
14484:     // Try to resolve the url for .url files.
14484:     resolveShortcutURL(lf, url);
14484:     if (!url.IsEmpty()) {
14484:       return io->NewURI(url,
14484:                         nsnull,
14484:                         workingDirURI,
14484:                         aResult);
    1:     }
    1: 
14484:     return io->NewFileURI(lf, aResult);
    1:   }
    1: 
    1:   return io->NewURI(NS_ConvertUTF16toUTF8(aArgument),
    1:                     nsnull,
    1:                     workingDirURI,
    1:                     aResult);
    1: }
    1: 
    1: void
    1: nsCommandLine::appendArg(const char* arg)
    1: {
    1: #ifdef DEBUG_COMMANDLINE
    1:   printf("Adding XP arg: %s\n", arg);
    1: #endif
    1: 
    1:   nsAutoString warg;
 9738: #ifdef XP_WIN
 9738:   CopyUTF8toUTF16(nsDependentCString(arg), warg);
 9738: #else
    1:   NS_CopyNativeToUnicode(nsDependentCString(arg), warg);
 9738: #endif
    1: 
23904:   mArgs.AppendElement(warg);
    1: }
    1: 
14484: void
14484: nsCommandLine::resolveShortcutURL(nsILocalFile* aFile, nsACString& outURL)
14484: {
14484:   nsCOMPtr<nsIFileProtocolHandler> fph;
14484:   nsresult rv = NS_GetFileProtocolHandler(getter_AddRefs(fph));
14484:   if (NS_FAILED(rv))
14484:     return;
14484: 
14484:   nsCOMPtr<nsIURI> uri;
14484:   rv = fph->ReadURLFile(aFile, getter_AddRefs(uri));
14484:   if (NS_FAILED(rv))
14484:     return;
14484: 
14484:   uri->GetSpec(outURL);
14484: }
14484: 
    1: NS_IMETHODIMP
    1: nsCommandLine::Init(PRInt32 argc, char** argv, nsIFile* aWorkingDir,
    1:                     PRUint32 aState)
    1: {
    1:   NS_ENSURE_ARG_MIN(aState, 0);
    1:   NS_ENSURE_ARG_MAX(aState, 2);
    1: 
    1:   PRInt32 i;
    1: 
    1:   mWorkingDir = aWorkingDir;
    1: 
    1:   // skip argv[0], we don't want it
    1:   for (i = 1; i < argc; ++i) {
    1:     const char* curarg = argv[i];
    1: 
    1: #ifdef DEBUG_COMMANDLINE
    1:     printf("Testing native arg %i: '%s'\n", i, curarg);
    1: #endif
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1:     if (*curarg == '/') {
    1:       char* dup = PL_strdup(curarg);
    1:       if (!dup) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       *dup = '-';
    1:       char* colon = PL_strchr(dup, ':');
    1:       if (colon) {
    1:         *colon = '\0';
    1:         appendArg(dup);
    1:         appendArg(colon+1);
    1:       } else {
    1:         appendArg(dup);
    1:       }
    1:       PL_strfree(dup);
    1:       continue;
    1:     }
    1: #endif
    1: #ifdef XP_UNIX
    1:     if (*curarg == '-' &&
    1:         *(curarg+1) == '-') {
    1:       ++curarg;
    1: 
    1:       char* dup = PL_strdup(curarg);
    1:       if (!dup) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       char* eq = PL_strchr(dup, '=');
    1:       if (eq) {
    1:         *eq = '\0';
    1:         appendArg(dup);
    1:         appendArg(eq + 1);
    1:       } else {
    1:         appendArg(dup);
    1:       }
    1:       PL_strfree(dup);
    1:       continue;
    1:     }
    1: #endif
    1: 
    1:     appendArg(curarg);
    1:   }
    1: 
    1:   mState = aState;
    1: 
    1:   return NS_OK;
    1: }
    1: 
47978: static void
58000: LogConsoleMessage(const PRUnichar* fmt, ...)
47978: {
47978:   va_list args;
47978:   va_start(args, fmt);
58000:   PRUnichar* msg = nsTextFormatter::vsmprintf(fmt, args);
47978:   va_end(args);
47978: 
47978:   nsCOMPtr<nsIConsoleService> cs = do_GetService("@mozilla.org/consoleservice;1");
47978:   if (cs)
47978:     cs->LogStringMessage(msg);
47978: 
47978:   NS_Free(msg);
47978: }
47978: 
    1: nsresult
 3321: nsCommandLine::EnumerateHandlers(EnumerateHandlersCallback aCallback, void *aClosure)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsICategoryManager> catman
    1:     (do_GetService(NS_CATEGORYMANAGER_CONTRACTID));
    1:   NS_ENSURE_TRUE(catman, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> entenum;
    1:   rv = catman->EnumerateCategory("command-line-handler",
    1:                                  getter_AddRefs(entenum));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIUTF8StringEnumerator> strenum (do_QueryInterface(entenum));
    1:   NS_ENSURE_TRUE(strenum, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsCAutoString entry;
    1:   PRBool hasMore;
    1:   while (NS_SUCCEEDED(strenum->HasMore(&hasMore)) && hasMore) {
    1:     strenum->GetNext(entry);
    1: 
54185:     nsCString contractID;
    1:     rv = catman->GetCategoryEntry("command-line-handler",
    1: 				  entry.get(),
    1: 				  getter_Copies(contractID));
54185:     if (NS_FAILED(rv))
    1:       continue;
    1: 
    1:     nsCOMPtr<nsICommandLineHandler> clh(do_GetService(contractID.get()));
47978:     if (!clh) {
58000:       LogConsoleMessage(NS_LITERAL_STRING("Contract ID '%s' was registered as a command line handler for entry '%s', but could not be created.").get(),
54185:                         contractID.get(), entry.get());
    1:       continue;
47978:     }
    1: 
    1:     rv = (aCallback)(clh, this, aClosure);
    1:     if (rv == NS_ERROR_ABORT)
    1:       break;
    1: 
    1:     rv = NS_OK;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 3321: nsresult
 3321: nsCommandLine::EnumerateValidators(EnumerateValidatorsCallback aCallback, void *aClosure)
 3321: {
 3321:   nsresult rv;
 3321: 
 3321:   nsCOMPtr<nsICategoryManager> catman
 3321:     (do_GetService(NS_CATEGORYMANAGER_CONTRACTID));
 3321:   NS_ENSURE_TRUE(catman, NS_ERROR_UNEXPECTED);
 3321: 
 3321:   nsCOMPtr<nsISimpleEnumerator> entenum;
 3321:   rv = catman->EnumerateCategory("command-line-validator",
 3321:                                  getter_AddRefs(entenum));
 3321:   NS_ENSURE_SUCCESS(rv, rv);
 3321: 
 3321:   nsCOMPtr<nsIUTF8StringEnumerator> strenum (do_QueryInterface(entenum));
 3321:   NS_ENSURE_TRUE(strenum, NS_ERROR_UNEXPECTED);
 3321: 
 3321:   nsCAutoString entry;
 3321:   PRBool hasMore;
 3321:   while (NS_SUCCEEDED(strenum->HasMore(&hasMore)) && hasMore) {
 3321:     strenum->GetNext(entry);
 3321: 
 3321:     nsXPIDLCString contractID;
 3321:     rv = catman->GetCategoryEntry("command-line-validator",
 3321: 				  entry.get(),
 3321: 				  getter_Copies(contractID));
 3321:     if (!contractID)
 3321:       continue;
 3321: 
 3321:     nsCOMPtr<nsICommandLineValidator> clv(do_GetService(contractID.get()));
 3321:     if (!clv)
 3321:       continue;
 3321: 
 3321:     rv = (aCallback)(clv, this, aClosure);
 3321:     if (rv == NS_ERROR_ABORT)
 3321:       break;
 3321: 
 3321:     rv = NS_OK;
 3321:   }
 3321: 
 3321:   return rv;
 3321: }
 3321: 
 3321: static nsresult
 3321: EnumValidate(nsICommandLineValidator* aValidator, nsICommandLine* aThis, void*)
 3321: {
 3321:   return aValidator->Validate(aThis);
 3321: }  
 3321: 
    1: static nsresult
    1: EnumRun(nsICommandLineHandler* aHandler, nsICommandLine* aThis, void*)
    1: {
    1:   return aHandler->Handle(aThis);
    1: }  
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::Run()
    1: {
    1:   nsresult rv;
    1: 
 3321:   rv = EnumerateValidators(EnumValidate, nsnull);
 3321:   if (rv == NS_ERROR_ABORT)
 3321:     return rv;
 3321: 
    1:   rv = EnumerateHandlers(EnumRun, nsnull);
    1:   if (rv == NS_ERROR_ABORT)
    1:     return rv;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: EnumHelp(nsICommandLineHandler* aHandler, nsICommandLine* aThis, void* aClosure)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsCString text;
    1:   rv = aHandler->GetHelpInfo(text);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     NS_ASSERTION(text.Length() == 0 || text.Last() == '\n',
    1:                  "Help text from command line handlers should end in a newline.");
    1: 
 3233:     nsACString* totalText = reinterpret_cast<nsACString*>(aClosure);
    1:     totalText->Append(text);
    1:   }
    1: 
    1:   return NS_OK;
    1: }  
    1: 
    1: NS_IMETHODIMP
    1: nsCommandLine::GetHelpText(nsACString& aResult)
    1: {
    1:   EnumerateHandlers(EnumHelp, &aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsCommandLine)
    1: 
46998: NS_DEFINE_NAMED_CID(NS_COMMANDLINE_CID);
46998: 
46998: static const mozilla::Module::CIDEntry kCommandLineCIDs[] = {
46998:   { &kNS_COMMANDLINE_CID, false, NULL, nsCommandLineConstructor },
46998:   { NULL }
    1: };
    1: 
46998: static const mozilla::Module::ContractIDEntry kCommandLineContracts[] = {
46998:   { "@mozilla.org/toolkit/command-line;1", &kNS_COMMANDLINE_CID },
46998:   { NULL }
46998: };
46998: 
46998: static const mozilla::Module kCommandLineModule = {
46998:   mozilla::Module::kVersion,
46998:   kCommandLineCIDs,
46998:   kCommandLineContracts
46998: };
46998: 
46998: NSMODULE_DEFN(CommandLineModule) = &kCommandLineModule;
