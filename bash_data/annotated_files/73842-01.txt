62797: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53422:  * vim: set ts=4 sw=4 et tw=78:
40383:  *
40383:  * ***** BEGIN LICENSE BLOCK *****
40383:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
40383:  *
40383:  * The contents of this file are subject to the Mozilla Public License Version
40383:  * 1.1 (the "License"); you may not use this file except in compliance with
40383:  * the License. You may obtain a copy of the License at
40383:  * http://www.mozilla.org/MPL/
40383:  *
40383:  * Software distributed under the License is distributed on an "AS IS" basis,
40383:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
40383:  * for the specific language governing rights and limitations under the
40383:  * License.
40383:  *
40383:  * The Original Code is SpiderMonkey code.
40383:  *
40383:  * The Initial Developer of the Original Code is
40383:  * Mozilla Corporation.
40383:  * Portions created by the Initial Developer are Copyright (C) 2010
40383:  * the Initial Developer. All Rights Reserved.
40383:  *
40383:  * Contributor(s):
40383:  *   Jeff Walden <jwalden+code@mit.edu> (original author)
40383:  *
40383:  * Alternatively, the contents of this file may be used under the terms of
40383:  * either of the GNU General Public License Version 2 or later (the "GPL"),
40383:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
40383:  * in which case the provisions of the GPL or the LGPL are applicable instead
40383:  * of those above. If you wish to allow use of your version of this file only
40383:  * under the terms of either the GPL or the LGPL, and not to allow others to
40383:  * use your version of this file under the terms of the MPL, indicate your
40383:  * decision by deleting the provisions above and replace them with the notice
40383:  * and other provisions required by the GPL or the LGPL. If you do not delete
40383:  * the provisions above, a recipient may use your version of this file under
40383:  * the terms of any one of the MPL, the GPL or the LGPL.
40383:  *
40383:  * ***** END LICENSE BLOCK ***** */
40383: 
40383: #ifndef jscntxtinlines_h___
40383: #define jscntxtinlines_h___
40383: 
40383: #include "jscntxt.h"
59733: #include "jscompartment.h"
47485: #include "jsstaticcheck.h"
40383: #include "jsxml.h"
53858: #include "jsregexp.h"
55606: #include "jsgc.h"
53858: 
72579: #include "frontend/ParseMaps.h"
72579: 
62876: namespace js {
62876: 
68955: static inline GlobalObject *
62876: GetGlobalForScopeChain(JSContext *cx)
62876: {
62876:     /*
62876:      * This is essentially GetScopeChain(cx)->getGlobal(), but without
62876:      * falling off trace.
62876:      *
62876:      * This use of cx->fp, possibly on trace, is deliberate:
62876:      * cx->fp->scopeChain->getGlobal() returns the same object whether we're on
62876:      * trace or not, since we do not trace calls across global objects.
62876:      */
62876:     VOUCH_DOES_NOT_REQUIRE_STACK();
62876: 
71696:     if (cx->hasfp())
62876:         return cx->fp()->scopeChain().getGlobal();
62876: 
62876:     JSObject *scope = cx->globalObject;
73842:     if (!NULLABLE_OBJ_TO_INNER_OBJECT(cx, scope))
62876:         return NULL;
68955:     return scope->asGlobal();
62876: }
62876: 
67915: inline GSNCache *
67915: GetGSNCache(JSContext *cx)
67915: {
67915:     return &JS_THREAD_DATA(cx)->gsnCache;
67915: }
67915: 
47478: class AutoNamespaceArray : protected AutoGCRooter {
47478:   public:
47478:     AutoNamespaceArray(JSContext *cx) : AutoGCRooter(cx, NAMESPACES) {
47478:         array.init();
40383:     }
40383: 
47478:     ~AutoNamespaceArray() {
47478:         array.finish(context);
47478:     }
47478: 
47478:     uint32 length() const { return array.length; }
47478: 
47478:   public:
40383:     friend void AutoGCRooter::trace(JSTracer *trc);
40383: 
40383:     JSXMLArray array;
40383: };
40383: 
57743: #ifdef DEBUG
47485: class CompartmentChecker
47485: {
47485:   private:
47485:     JSContext *context;
47485:     JSCompartment *compartment;
47485: 
47485:   public:
47485:     explicit CompartmentChecker(JSContext *cx) : context(cx), compartment(cx->compartment) {
71696:         check(cx->hasfp() ? JS_GetGlobalForScopeChain(cx) : cx->globalObject);
47485:         VOUCH_DOES_NOT_REQUIRE_STACK();
47485:     }
47485: 
47485:     /*
47485:      * Set a breakpoint here (break js::CompartmentChecker::fail) to debug
47485:      * compartment mismatches.
47485:      */
47485:     static void fail(JSCompartment *c1, JSCompartment *c2) {
47485:         printf("*** Compartment mismatch %p vs. %p\n", (void *) c1, (void *) c2);
57743:         JS_NOT_REACHED("compartment mismatched");
47485:     }
47485: 
60169:     /* Note: should only be used when neither c1 nor c2 may be the default compartment. */
60169:     static void check(JSCompartment *c1, JSCompartment *c2) {
60584:         JS_ASSERT(c1 != c1->rt->atomsCompartment);
60584:         JS_ASSERT(c2 != c2->rt->atomsCompartment);
60169:         if (c1 != c2)
60169:             fail(c1, c2);
60169:     }
60169: 
47485:     void check(JSCompartment *c) {
60584:         if (c && c != context->runtime->atomsCompartment) {
47485:             if (!compartment)
47485:                 compartment = c;
47485:             else if (c != compartment)
47485:                 fail(compartment, c);
47485:         }
47485:     }
47485: 
47485:     void check(JSPrincipals *) { /* nothing for now */ }
47485: 
47485:     void check(JSObject *obj) {
47485:         if (obj)
61430:             check(obj->compartment());
61430:     }
61430: 
61430:     void check(JSString *str) {
64343:         if (!str->isAtom())
64345:             check(str->compartment());
47485:     }
47485: 
48470:     void check(const js::Value &v) {
48470:         if (v.isObject())
48470:             check(&v.toObject());
61430:         else if (v.isString())
61430:             check(v.toString());
48470:     }
48470: 
47485:     void check(jsval v) {
48470:         check(Valueify(v));
47485:     }
47485: 
47485:     void check(const ValueArray &arr) {
47485:         for (size_t i = 0; i < arr.length; i++)
47485:             check(arr.array[i]);
47485:     }
47485: 
48470:     void check(const JSValueArray &arr) {
48470:         for (size_t i = 0; i < arr.length; i++)
48470:             check(arr.array[i]);
48470:     }
48470: 
71695:     void check(const CallArgs &args) {
71695:         for (Value *p = args.base(); p != args.end(); ++p)
71695:             check(*p);
71695:     }
71695: 
48470:     void check(jsid id) {
48470:         if (JSID_IS_OBJECT(id))
48470:             check(JSID_TO_OBJECT(id));
48470:     }
48470:     
47485:     void check(JSIdArray *ida) {
47485:         if (ida) {
48470:             for (jsint i = 0; i < ida->length; i++) {
48470:                 if (JSID_IS_OBJECT(ida->vector[i]))
48470:                     check(ida->vector[i]);
48470:             }
47485:         }
47485:     }
47485: 
47485:     void check(JSScript *script) {
59220:         if (script) {
55633:             check(script->compartment);
55633:             if (script->u.object)
47485:                 check(script->u.object);
47485:         }
55633:     }
47485: 
69223:     void check(StackFrame *fp) {
56704:         check(&fp->scopeChain());
56704:     }
47485: };
47485: 
57743: #endif
57743: 
47485: /*
47485:  * Don't perform these checks when called from a finalizer. The checking
47485:  * depends on other objects not having been swept yet.
47485:  */
47485: #define START_ASSERT_SAME_COMPARTMENT()                                       \
47485:     if (cx->runtime->gcRunning)                                               \
47485:         return;                                                               \
47485:     CompartmentChecker c(cx)
47485: 
47485: template <class T1> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2, class T3> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2, T3 t3)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
47485:     c.check(t3);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2, class T3, class T4> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2, T3 t3, T4 t4)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
47485:     c.check(t3);
47485:     c.check(t4);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2, class T3, class T4, class T5> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
47485:     c.check(t3);
47485:     c.check(t4);
47485:     c.check(t5);
57743: #endif
47485: }
47485: 
47485: #undef START_ASSERT_SAME_COMPARTMENT
47485: 
71695: STATIC_PRECONDITION_ASSUME(ubound(args.argv_) >= argc)
53557: JS_ALWAYS_INLINE bool
71695: CallJSNative(JSContext *cx, js::Native native, const CallArgs &args)
47485: {
53557: #ifdef DEBUG
60211:     JSBool alreadyThrowing = cx->isExceptionPending();
53557: #endif
71695:     assertSameCompartment(cx, args);
71695:     JSBool ok = native(cx, args.argc(), args.base());
53557:     if (ok) {
71695:         assertSameCompartment(cx, args.rval());
60211:         JS_ASSERT_IF(!alreadyThrowing, !cx->isExceptionPending());
53557:     }
47485:     return ok;
47485: }
47485: 
62402: extern JSBool CallOrConstructBoundFunction(JSContext *, uintN, js::Value *);
62402: 
71695: STATIC_PRECONDITION(ubound(args.argv_) >= argc)
53557: JS_ALWAYS_INLINE bool
71695: CallJSNativeConstructor(JSContext *cx, js::Native native, const CallArgs &args)
47485: {
53557: #ifdef DEBUG
71695:     JSObject &callee = args.callee();
53557: #endif
53557: 
71695:     JS_ASSERT(args.thisv().isMagic());
71695:     if (!CallJSNative(cx, native, args))
53557:         return false;
53557: 
53557:     /*
53617:      * Native constructors must return non-primitive values on success.
53617:      * Although it is legal, if a constructor returns the callee, there is a
53617:      * 99.9999% chance it is a bug. If any valid code actually wants the
54729:      * constructor to return the callee, the assertion can be removed or
54729:      * (another) conjunct can be added to the antecedent.
53617:      *
53617:      * Proxies are exceptions to both rules: they can return primitives and
53617:      * they allow content to return the callee.
54729:      *
62402:      * CallOrConstructBoundFunction is an exception as well because we
62402:      * might have used bind on a proxy function.
62402:      *
54729:      * (new Object(Object)) returns the callee.
53557:      */
53617:     extern JSBool proxy_Construct(JSContext *, uintN, Value *);
72094:     extern JSBool callable_Construct(JSContext *, uintN, Value *);
72094:     JS_ASSERT_IF(native != proxy_Construct &&
72094:                  native != callable_Construct &&
72094:                  native != js::CallOrConstructBoundFunction &&
71695:                  (!callee.isFunction() || callee.getFunctionPrivate()->u.n.clasp != &js_ObjectClass),
71695:                  !args.rval().isPrimitive() && callee != args.rval().toObject());
53617: 
53557:     return true;
47485: }
47485: 
53557: JS_ALWAYS_INLINE bool
67941: CallJSPropertyOp(JSContext *cx, js::PropertyOp op, JSObject *receiver, jsid id, js::Value *vp)
47485: {
67941:     assertSameCompartment(cx, receiver, id, *vp);
67941:     JSBool ok = op(cx, receiver, id, vp);
47485:     if (ok)
67941:         assertSameCompartment(cx, receiver, *vp);
47485:     return ok;
47485: }
47485: 
53557: JS_ALWAYS_INLINE bool
62395: CallJSPropertyOpSetter(JSContext *cx, js::StrictPropertyOp op, JSObject *obj, jsid id,
62395:                        JSBool strict, js::Value *vp)
47485: {
48470:     assertSameCompartment(cx, obj, id, *vp);
62395:     return op(cx, obj, id, strict, vp);
47485: }
47485: 
56817: inline bool
62395: CallSetter(JSContext *cx, JSObject *obj, jsid id, js::StrictPropertyOp op, uintN attrs,
62395:            uintN shortid, JSBool strict, js::Value *vp)
56817: {
56817:     if (attrs & JSPROP_SETTER)
56817:         return ExternalGetOrSet(cx, obj, id, CastAsObjectJsval(op), JSACC_WRITE, 1, vp, vp);
56817: 
56817:     if (attrs & JSPROP_GETTER)
56817:         return js_ReportGetterOnlyAssignment(cx);
56817: 
56817:     if (attrs & JSPROP_SHORTID)
56817:         id = INT_TO_JSID(shortid);
62395:     return CallJSPropertyOpSetter(cx, op, obj, id, strict, vp);
56817: }
56817: 
59733: #ifdef JS_TRACER
59733: /*
59733:  * Reconstruct the JS stack and clear cx->tracecx. We must be currently in a
59733:  * _FAIL builtin from trace on cx or another context on the same thread. The
59733:  * machine code for the trace remains on the C stack when js_DeepBail returns.
59733:  *
59733:  * Implemented in jstracer.cpp.
59733:  */
59733: JS_FORCES_STACK JS_FRIEND_API(void)
59733: DeepBail(JSContext *cx);
59733: #endif
59733: 
59733: static JS_INLINE void
59733: LeaveTraceIfGlobalObject(JSContext *cx, JSObject *obj)
59733: {
59733:     if (!obj->parent)
59733:         LeaveTrace(cx);
59733: }
59733: 
60160: static JS_INLINE void
60160: LeaveTraceIfArgumentsObject(JSContext *cx, JSObject *obj)
60160: {
60160:     if (obj->isArguments())
60160:         LeaveTrace(cx);
60160: }
60160: 
48470: }  /* namespace js */
40383: 
69223: #ifdef JS_METHODJIT
69223: inline js::mjit::JaegerCompartment *JSContext::jaegerCompartment()
69223: {
72551:     return compartment->jaegerCompartment();
69223: }
69223: #endif
69223: 
69223: inline bool
69223: JSContext::ensureGeneratorStackSpace()
69223: {
69223:     bool ok = genStack.reserve(genStack.length() + 1);
69223:     if (!ok)
69223:         js_ReportOutOfMemory(this);
69223:     return ok;
69223: }
69223: 
69223: inline js::RegExpStatics *
69223: JSContext::regExpStatics()
69223: {
69223:     return js::RegExpStatics::extractFrom(js::GetGlobalForScopeChain(this));
69223: }
69223: 
60211: inline void
60211: JSContext::setPendingException(js::Value v) {
60211:     this->throwing = true;
60211:     this->exception = v;
60211:     assertSameCompartment(this, v);
60211: }
60211: 
72579: inline bool
72579: JSContext::ensureParseMapPool()
72579: {
72579:     if (parseMapPool_)
72579:         return true;
72579:     parseMapPool_ = js::OffTheBooks::new_<js::ParseMapPool>(this);
72579:     return parseMapPool_;
72579: }
72579: 
40383: #endif /* jscntxtinlines_h___ */
