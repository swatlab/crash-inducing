 81281: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 81281: 
 81281: #include "DrawTargetSkia.h"
 81281: #include "SourceSurfaceSkia.h"
 87511: #include "ScaledFontBase.h"
 81281: #include "skia/SkDevice.h"
 81281: #include "skia/SkTypeface.h"
 81281: #include "skia/SkGradientShader.h"
 81281: #include "skia/SkBlurDrawLooper.h"
 81281: #include "skia/SkBlurMaskFilter.h"
 81281: #include "skia/SkColorFilter.h"
 81281: #include "skia/SkLayerRasterizer.h"
 81281: #include "skia/SkLayerDrawLooper.h"
 81281: #include "skia/SkDashPathEffect.h"
 81281: #include "Logging.h"
 81281: #include "HelpersSkia.h"
 81281: #include "Tools.h"
 81281: #include <algorithm>
 81281: 
 87686: #ifdef ANDROID
 87686: # define USE_SOFT_CLIPPING false
 87686: #else
 87686: # define USE_SOFT_CLIPPING true
 87686: #endif
 87686: 
 81281: namespace mozilla {
 81281: namespace gfx {
 81281: 
 81281: SkColor ColorToSkColor(const Color &color, Float aAlpha)
 81281: {
 87511:   //XXX: do a better job converting to int
 81281:   return SkColorSetARGB(color.a*aAlpha*255.0, color.r*255.0, color.g*255.0, color.b*255.0);
 81281: }
 81281: 
 81281: class GradientStopsSkia : public GradientStops
 81281: {
 81281: public:
 87680:   GradientStopsSkia(const std::vector<GradientStop>& aStops, uint32_t aNumStops, ExtendMode aExtendMode)
 81281:     : mCount(aNumStops)
 87680:     , mExtendMode(aExtendMode)
 81281:   {
 81281:     if (mCount == 0) {
 81281:       return;
 81281:     }
 81281: 
 81281:     // Skia gradients always require a stop at 0.0 and 1.0, insert these if
 81281:     // we don't have them.
 81281:     uint32_t shift = 0;
 81281:     if (aStops[0].offset != 0) {
 81281:       mCount++;
 81281:       shift = 1;
 81281:     }
 81281:     if (aStops[aNumStops-1].offset != 1) {
 81281:       mCount++;
 81281:     }
 81281:     mColors.resize(mCount);
 81281:     mPositions.resize(mCount);
 81281:     if (aStops[0].offset != 0) {
 81281:       mColors[0] = ColorToSkColor(aStops[0].color, 1.0);
 81281:       mPositions[0] = 0;
 81281:     }
 81281:     for (uint32_t i = 0; i < aNumStops; i++) {
 81281:       mColors[i + shift] = ColorToSkColor(aStops[i].color, 1.0);
 81281:       mPositions[i + shift] = SkFloatToScalar(aStops[i].offset);
 81281:     }
 81281:     if (aStops[aNumStops-1].offset != 1) {
 81281:       mColors[mCount-1] = ColorToSkColor(aStops[aNumStops-1].color, 1.0);
 81281:       mPositions[mCount-1] = SK_Scalar1;
 81281:     }
 81281:   }
 81281: 
 81281:   BackendType GetBackendType() const { return BACKEND_SKIA; }
 81281: 
 81281:   std::vector<SkColor> mColors;
 81281:   std::vector<SkScalar> mPositions;
 81281:   int mCount;
 87680:   ExtendMode mExtendMode;
 81281: };
 81281: 
 81281: SkXfermode::Mode
 81281: GfxOpToSkiaOp(CompositionOp op)
 81281: {
 81281:   switch (op)
 81281:   {
 81281:     case OP_OVER:
 81281:       return SkXfermode::kSrcOver_Mode;
 81281:     case OP_ADD:
 81281:       return SkXfermode::kPlus_Mode;
 81281:     case OP_ATOP:
 81281:       return SkXfermode::kSrcATop_Mode;
 81281:     case OP_OUT:
 81281:       return SkXfermode::kSrcOut_Mode;
 81281:     case OP_IN:
 81281:       return SkXfermode::kSrcIn_Mode;
 81281:     case OP_SOURCE:
 81281:       return SkXfermode::kSrc_Mode;
 81281:     case OP_DEST_IN:
 81281:       return SkXfermode::kDstIn_Mode;
 81281:     case OP_DEST_OUT:
 81281:       return SkXfermode::kDstOut_Mode;
 81281:     case OP_DEST_OVER:
 81281:       return SkXfermode::kDstOver_Mode;
 81281:     case OP_DEST_ATOP:
 81281:       return SkXfermode::kDstATop_Mode;
 81281:     case OP_XOR:
 81281:       return SkXfermode::kXor_Mode;
 81281:     case OP_COUNT:
 81281:       return SkXfermode::kSrcOver_Mode;
 81281:   }
 81281:   return SkXfermode::kSrcOver_Mode;
 81281: }
 81281: 
 81281: 
 81281: SkRect
 81281: RectToSkRect(const Rect& aRect)
 81281: {
 81281:   return SkRect::MakeXYWH(SkFloatToScalar(aRect.x), SkFloatToScalar(aRect.y), 
 81281:                           SkFloatToScalar(aRect.width), SkFloatToScalar(aRect.height));
 81281: }
 81281: 
 81281: SkRect
 81281: IntRectToSkRect(const IntRect& aRect)
 81281: {
 81281:   return SkRect::MakeXYWH(SkIntToScalar(aRect.x), SkIntToScalar(aRect.y), 
 81281:                           SkIntToScalar(aRect.width), SkIntToScalar(aRect.height));
 81281: }
 81281: 
 81281: SkIRect
 81281: RectToSkIRect(const Rect& aRect)
 81281: {
 81281:   return SkIRect::MakeXYWH(aRect.x, aRect.y, aRect.width, aRect.height);
 81281: }
 81281: 
 81281: SkIRect
 81281: IntRectToSkIRect(const IntRect& aRect)
 81281: {
 81281:   return SkIRect::MakeXYWH(aRect.x, aRect.y, aRect.width, aRect.height);
 81281: }
 81281: 
 81281: 
 81281: DrawTargetSkia::DrawTargetSkia()
 81281: {
 81281: }
 81281: 
 81281: DrawTargetSkia::~DrawTargetSkia()
 81281: {
 82424:   if (mSnapshots.size()) {
 82424:     for (std::vector<SourceSurfaceSkia*>::iterator iter = mSnapshots.begin();
 82424:          iter != mSnapshots.end(); iter++) {
 82424:       (*iter)->DrawTargetDestroyed();
 82424:     }
 82424:     // All snapshots will now have copied data.
 82424:     mSnapshots.clear();
 82424:   }
 81281: }
 81281: 
 81281: TemporaryRef<SourceSurface>
 81281: DrawTargetSkia::Snapshot()
 81281: {
 81281:   RefPtr<SourceSurfaceSkia> source = new SourceSurfaceSkia();
 81283:   if (!source->InitWithBitmap(mBitmap, mFormat, this)) {
 81281:     return NULL;
 81281:   }
 81283:   AppendSnapshot(source);
 81281:   return source;
 81281: }
 81281: 
 81281: SkShader::TileMode
 81281: ExtendModeToTileMode(ExtendMode aMode)
 81281: {
 81281:   switch (aMode)
 81281:   {
 81281:     case EXTEND_CLAMP:
 81281:       return SkShader::kClamp_TileMode;
 86250:     case EXTEND_REPEAT:
 81281:       return SkShader::kRepeat_TileMode;
 86250:     case EXTEND_REFLECT:
 81281:       return SkShader::kMirror_TileMode;
 81281:   }
 81281:   return SkShader::kClamp_TileMode;
 81281: }
 81281: 
 87680: void SetPaintPattern(SkPaint& aPaint, const Pattern& aPattern, Float aAlpha = 1.0)
 87680: {
 87680:   switch (aPattern.GetType()) {
 87680:     case PATTERN_COLOR: {
 87680:       Color color = static_cast<const ColorPattern&>(aPattern).mColor;
 87680:       aPaint.setColor(ColorToSkColor(color, aAlpha));
 87680:       break;
 87680:     }
 87680:     case PATTERN_LINEAR_GRADIENT: {
 87680:       const LinearGradientPattern& pat = static_cast<const LinearGradientPattern&>(aPattern);
 87680:       GradientStopsSkia *stops = static_cast<GradientStopsSkia*>(pat.mStops.get());
 87680:       SkShader::TileMode mode = ExtendModeToTileMode(stops->mExtendMode);
 87680: 
 87680:       if (stops->mCount >= 2) {
 87680:         SkPoint points[2];
 87680:         points[0] = SkPoint::Make(SkFloatToScalar(pat.mBegin.x), SkFloatToScalar(pat.mBegin.y));
 87680:         points[1] = SkPoint::Make(SkFloatToScalar(pat.mEnd.x), SkFloatToScalar(pat.mEnd.y));
 87680: 
 87680:         SkShader* shader = SkGradientShader::CreateLinear(points, 
 87680:                                                           &stops->mColors.front(), 
 87680:                                                           &stops->mPositions.front(), 
 87680:                                                           stops->mCount, 
 87680:                                                           mode);
 87680:         SkMatrix mat;
 87680:         GfxMatrixToSkiaMatrix(pat.mMatrix, mat);
 87680:         shader->setLocalMatrix(mat);
 87680:         SkSafeUnref(aPaint.setShader(shader));
 87680:       } else {
 87680:         aPaint.setColor(SkColorSetARGB(0, 0, 0, 0));
 87680:       }
 87680:       break;
 87680:     }
 87680:     case PATTERN_RADIAL_GRADIENT: {
 87680:       const RadialGradientPattern& pat = static_cast<const RadialGradientPattern&>(aPattern);
 87680:       GradientStopsSkia *stops = static_cast<GradientStopsSkia*>(pat.mStops.get());
 87680:       SkShader::TileMode mode = ExtendModeToTileMode(stops->mExtendMode);
 87680: 
 87680:       if (stops->mCount >= 2) {
 87680:         SkPoint points[2];
 87680:         points[0] = SkPoint::Make(SkFloatToScalar(pat.mCenter1.x), SkFloatToScalar(pat.mCenter1.y));
 87680:         points[1] = SkPoint::Make(SkFloatToScalar(pat.mCenter2.x), SkFloatToScalar(pat.mCenter2.y));
 87680: 
 87680:         SkShader* shader = SkGradientShader::CreateTwoPointRadial(points[0], 
 87680:                                                                   SkFloatToScalar(pat.mRadius1),
 87680:                                                                   points[1], 
 87680:                                                                   SkFloatToScalar(pat.mRadius2),
 87680:                                                                   &stops->mColors.front(), 
 87680:                                                                   &stops->mPositions.front(), 
 87680:                                                                   stops->mCount, 
 87680:                                                                   mode);
 87680:         SkMatrix mat;
 87680:         GfxMatrixToSkiaMatrix(pat.mMatrix, mat);
 87680:         shader->setLocalMatrix(mat);
 87680:         SkSafeUnref(aPaint.setShader(shader));
 87680:       } else {
 87680:         aPaint.setColor(SkColorSetARGB(0, 0, 0, 0));
 87680:       }
 87680:       break;
 87680:     }
 87680:     case PATTERN_SURFACE: {
 87680:       const SurfacePattern& pat = static_cast<const SurfacePattern&>(aPattern);
 87680:       const SkBitmap& bitmap = static_cast<SourceSurfaceSkia*>(pat.mSurface.get())->GetBitmap();
 87680: 
 87680:       SkShader::TileMode mode = ExtendModeToTileMode(pat.mExtendMode);
 87680:       SkShader* shader = SkShader::CreateBitmapShader(bitmap, mode, mode);
 87680:       SkMatrix mat;
 87680:       GfxMatrixToSkiaMatrix(pat.mMatrix, mat);
 87680:       shader->setLocalMatrix(mat);
 87680:       SkSafeUnref(aPaint.setShader(shader));
 87680:       if (pat.mFilter == FILTER_POINT) {
 87680:         aPaint.setFilterBitmap(false);
 87680:       }
 87680:       break;
 87680:     }
 87680:   }
 87680: }
 87680: 
 81281: struct AutoPaintSetup {
 81281:   AutoPaintSetup(SkCanvas *aCanvas, const DrawOptions& aOptions, const Pattern& aPattern)
 81281:     : mNeedsRestore(false), mAlpha(1.0)
 81281:   {
 81281:     Init(aCanvas, aOptions);
 87680:     SetPaintPattern(mPaint, aPattern, mAlpha);
 81281:   }
 81281: 
 81281:   AutoPaintSetup(SkCanvas *aCanvas, const DrawOptions& aOptions)
 81281:     : mNeedsRestore(false), mAlpha(1.0)
 81281:   {
 81281:     Init(aCanvas, aOptions);
 81281:   }
 81281: 
 81281:   ~AutoPaintSetup()
 81281:   {
 81281:     if (mNeedsRestore) {
 81281:       mCanvas->restore();
 81281:     }
 81281:   }
 81281: 
 81281:   void Init(SkCanvas *aCanvas, const DrawOptions& aOptions)
 81281:   {
 81281:     mPaint.setXfermodeMode(GfxOpToSkiaOp(aOptions.mCompositionOp));
 81281:     mCanvas = aCanvas;
 81281: 
 81281:     //TODO: Can we set greyscale somehow?
 81281:     if (aOptions.mAntialiasMode != AA_NONE) {
 81281:       mPaint.setAntiAlias(true);
 81281:     } else {
 81281:       mPaint.setAntiAlias(false);
 81281:     }
 81281: 
 94776:     MOZ_ASSERT(aOptions.mSnapping == SNAP_NONE, "Pixel snapping not supported yet!");
 81281:     
 81281:     // TODO: We could skip the temporary for operator_source and just
 81281:     // clear the clip rect. The other operators would be harder
 81281:     // but could be worth it to skip pushing a group.
 81281:     if (!IsOperatorBoundByMask(aOptions.mCompositionOp)) {
 81281:       mPaint.setXfermodeMode(SkXfermode::kSrcOver_Mode);
 81281:       SkPaint temp;
 81281:       temp.setXfermodeMode(GfxOpToSkiaOp(aOptions.mCompositionOp));
 81281:       temp.setAlpha(aOptions.mAlpha*255);
 81281:       //TODO: Get a rect here
 81281:       mCanvas->saveLayer(NULL, &temp);
 81281:       mNeedsRestore = true;
 81281:     } else {
 81281:       mPaint.setAlpha(aOptions.mAlpha*255.0);
 81281:       mAlpha = aOptions.mAlpha;
 81281:     }
 82420:     mPaint.setFilterBitmap(true);
 81281:   }
 81281: 
 81281:   // TODO: Maybe add an operator overload to access this easier?
 81281:   SkPaint mPaint;
 81281:   bool mNeedsRestore;
 81281:   SkCanvas* mCanvas;
 81281:   Float mAlpha;
 81281: };
 81281: 
 81281: void
 81281: DrawTargetSkia::Flush()
 81281: {
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::DrawSurface(SourceSurface *aSurface,
 81281:                             const Rect &aDest,
 81281:                             const Rect &aSource,
 81281:                             const DrawSurfaceOptions &aSurfOptions,
 81281:                             const DrawOptions &aOptions)
 81281: {
 81281:   if (aSurface->GetType() != SURFACE_SKIA) {
 81281:     return;
 81281:   }
 81281: 
 81281:   if (aSource.IsEmpty()) {
 81281:     return;
 81281:   }
 81281: 
 81283:   MarkChanged();
 81283: 
 81281:   SkRect destRect = RectToSkRect(aDest);
 81281:   SkRect sourceRect = RectToSkRect(aSource);
 81281: 
 81281:   SkMatrix matrix;
 81281:   matrix.setRectToRect(sourceRect, destRect, SkMatrix::kFill_ScaleToFit);
 81281:   
 81281:   const SkBitmap& bitmap = static_cast<SourceSurfaceSkia*>(aSurface)->GetBitmap();
 81281:  
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions);
 81281:   SkShader *shader = SkShader::CreateBitmapShader(bitmap, SkShader::kClamp_TileMode, SkShader::kClamp_TileMode);
 81281:   shader->setLocalMatrix(matrix);
 81281:   SkSafeUnref(paint.mPaint.setShader(shader));
 82420:   if (aSurfOptions.mFilter != FILTER_LINEAR) {
 82420:     paint.mPaint.setFilterBitmap(false);
 82420:   }
 81281:   mCanvas->drawRect(destRect, paint.mPaint);
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::DrawSurfaceWithShadow(SourceSurface *aSurface,
 81281:                                       const Point &aDest,
 81281:                                       const Color &aColor,
 81281:                                       const Point &aOffset,
 81281:                                       Float aSigma,
 81281:                                       CompositionOp aOperator)
 81281: {
 81283:   MarkChanged();
 81281:   mCanvas->save(SkCanvas::kMatrix_SaveFlag);
 81281:   mCanvas->resetMatrix();
 81281: 
 81281:   uint32_t blurFlags = SkBlurMaskFilter::kHighQuality_BlurFlag |
 81281:                        SkBlurMaskFilter::kIgnoreTransform_BlurFlag;
 81281:   const SkBitmap& bitmap = static_cast<SourceSurfaceSkia*>(aSurface)->GetBitmap();
 81281:   SkShader* shader = SkShader::CreateBitmapShader(bitmap, SkShader::kClamp_TileMode, SkShader::kClamp_TileMode);
 81281:   SkMatrix matrix;
 81281:   matrix.reset();
 81281:   matrix.setTranslateX(SkFloatToScalar(aDest.x));
 81281:   matrix.setTranslateY(SkFloatToScalar(aDest.y));
 81281:   shader->setLocalMatrix(matrix);
 81281:   SkLayerDrawLooper* dl = new SkLayerDrawLooper;
 81281:   SkLayerDrawLooper::LayerInfo info;
 81281:   info.fPaintBits |= SkLayerDrawLooper::kShader_Bit;
 81281:   SkPaint *layerPaint = dl->addLayer(info);
 81281:   layerPaint->setShader(shader);
 81281: 
 81281:   info.fPaintBits = 0;
 81281:   info.fPaintBits |= SkLayerDrawLooper::kMaskFilter_Bit;
 81281:   info.fPaintBits |= SkLayerDrawLooper::kColorFilter_Bit;
 81281:   info.fColorMode = SkXfermode::kDst_Mode;
 81281:   info.fOffset.set(SkFloatToScalar(aOffset.x), SkFloatToScalar(aOffset.y));
 81281:   info.fPostTranslate = true;
 81281: 
 81281:   SkMaskFilter* mf = SkBlurMaskFilter::Create(aSigma, SkBlurMaskFilter::kNormal_BlurStyle, blurFlags);
 81281:   SkColor color = ColorToSkColor(aColor, 1);
 81281:   SkColorFilter* cf = SkColorFilter::CreateModeFilter(color, SkXfermode::kSrcIn_Mode);
 81281: 
 81281: 
 81281:   layerPaint = dl->addLayer(info);
 81281:   SkSafeUnref(layerPaint->setMaskFilter(mf));
 81281:   SkSafeUnref(layerPaint->setColorFilter(cf));
 81281:   layerPaint->setColor(color);
 81281:   
 81281:   // TODO: This is using the rasterizer to calculate an alpha mask
 81281:   // on both the shadow and normal layers. We should fix this
 81281:   // properly so it only happens for the shadow layer
 81281:   SkLayerRasterizer *raster = new SkLayerRasterizer();
 81281:   SkPaint maskPaint;
 81281:   SkSafeUnref(maskPaint.setShader(shader));
 81281:   raster->addLayer(maskPaint, 0, 0);
 81281:   
 81281:   SkPaint paint;
 81281:   paint.setAntiAlias(true);
 81281:   SkSafeUnref(paint.setRasterizer(raster));
 81281:   paint.setXfermodeMode(GfxOpToSkiaOp(aOperator));
 81281:   SkSafeUnref(paint.setLooper(dl));
 81281: 
 81281:   SkRect rect = RectToSkRect(Rect(aDest.x, aDest.y, bitmap.width(), bitmap.height()));
 81281:   mCanvas->drawRect(rect, paint);
 81281:   mCanvas->restore();
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::FillRect(const Rect &aRect,
 81281:                          const Pattern &aPattern,
 81281:                          const DrawOptions &aOptions)
 81281: {
 81283:   MarkChanged();
 81281:   SkRect rect = RectToSkRect(aRect);
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions, aPattern);
 81281: 
 81281:   mCanvas->drawRect(rect, paint.mPaint);
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::Stroke(const Path *aPath,
 81281:                        const Pattern &aPattern,
 81281:                        const StrokeOptions &aStrokeOptions,
 81281:                        const DrawOptions &aOptions)
 81281: {
 81283:   MarkChanged();
 81281:   if (aPath->GetBackendType() != BACKEND_SKIA) {
 81281:     return;
 81281:   }
 81281: 
 81281:   const PathSkia *skiaPath = static_cast<const PathSkia*>(aPath);
 81281: 
 81281: 
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions, aPattern);
 82422:   if (!StrokeOptionsToPaint(paint.mPaint, aStrokeOptions)) {
 82422:     return;
 82422:   }
 81281: 
 81281:   mCanvas->drawPath(skiaPath->GetPath(), paint.mPaint);
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::StrokeRect(const Rect &aRect,
 81281:                            const Pattern &aPattern,
 81281:                            const StrokeOptions &aStrokeOptions,
 81281:                            const DrawOptions &aOptions)
 81281: {
 81283:   MarkChanged();
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions, aPattern);
 82422:   if (!StrokeOptionsToPaint(paint.mPaint, aStrokeOptions)) {
 82422:     return;
 82422:   }
 81281: 
 81281:   mCanvas->drawRect(RectToSkRect(aRect), paint.mPaint);
 81281: }
 81281: 
 81281: void 
 81281: DrawTargetSkia::StrokeLine(const Point &aStart,
 81281:                            const Point &aEnd,
 81281:                            const Pattern &aPattern,
 81281:                            const StrokeOptions &aStrokeOptions,
 81281:                            const DrawOptions &aOptions)
 81281: {
 81283:   MarkChanged();
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions, aPattern);
 82422:   if (!StrokeOptionsToPaint(paint.mPaint, aStrokeOptions)) {
 82422:     return;
 82422:   }
 81281: 
 81281:   mCanvas->drawLine(SkFloatToScalar(aStart.x), SkFloatToScalar(aStart.y), 
 81281:                     SkFloatToScalar(aEnd.x), SkFloatToScalar(aEnd.y), 
 81281:                     paint.mPaint);
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::Fill(const Path *aPath,
 81281:                     const Pattern &aPattern,
 81281:                     const DrawOptions &aOptions)
 81281: {
 81283:   MarkChanged();
 81281:   if (aPath->GetBackendType() != BACKEND_SKIA) {
 81281:     return;
 81281:   }
 81281: 
 81281:   const PathSkia *skiaPath = static_cast<const PathSkia*>(aPath);
 81281: 
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions, aPattern);
 81281: 
 81281:   mCanvas->drawPath(skiaPath->GetPath(), paint.mPaint);
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::FillGlyphs(ScaledFont *aFont,
 81281:                            const GlyphBuffer &aBuffer,
 81281:                            const Pattern &aPattern,
 93507:                            const DrawOptions &aOptions,
 93507:                            const GlyphRenderingOptions*)
 81281: {
101753:   if (aFont->GetType() != FONT_MAC && aFont->GetType() != FONT_SKIA) {
 81281:     return;
 81281:   }
 81281: 
 81283:   MarkChanged();
 81283: 
 87511:   ScaledFontBase* skiaFont = static_cast<ScaledFontBase*>(aFont);
 81281: 
 81281:   AutoPaintSetup paint(mCanvas.get(), aOptions, aPattern);
 87511:   paint.mPaint.setTypeface(skiaFont->GetSkTypeface());
 81281:   paint.mPaint.setTextSize(SkFloatToScalar(skiaFont->mSize));
 81281:   paint.mPaint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
 81281:   
 81281:   std::vector<uint16_t> indices;
 81281:   std::vector<SkPoint> offsets;
 81281:   indices.resize(aBuffer.mNumGlyphs);
 81281:   offsets.resize(aBuffer.mNumGlyphs);
 81281: 
 81281:   for (unsigned int i = 0; i < aBuffer.mNumGlyphs; i++) {
 81281:     indices[i] = aBuffer.mGlyphs[i].mIndex;
 81281:     offsets[i].fX = SkFloatToScalar(aBuffer.mGlyphs[i].mPosition.x);
 81281:     offsets[i].fY = SkFloatToScalar(aBuffer.mGlyphs[i].mPosition.y);
 81281:   }
 81281: 
 81281:   mCanvas->drawPosText(&indices.front(), aBuffer.mNumGlyphs*2, &offsets.front(), paint.mPaint);
 81281: }
 81281: 
 87680: void
 87680: DrawTargetSkia::Mask(const Pattern &aSource,
 87680:                      const Pattern &aMask,
 87680:                      const DrawOptions &aOptions)
 87680: {
 87680:   MarkChanged();
 87680:   AutoPaintSetup paint(mCanvas.get(), aOptions, aSource);
 87680: 
 87680:   SkPaint maskPaint;
 87680:   SetPaintPattern(maskPaint, aMask);
 87680:   
 87680:   SkLayerRasterizer *raster = new SkLayerRasterizer();
 87680:   raster->addLayer(maskPaint);
 87680:   SkSafeUnref(paint.mPaint.setRasterizer(raster));
 87680: 
 87680:   // Skia only uses the mask rasterizer when we are drawing a path/rect.
 87680:   // Take our destination bounds and convert them into user space to use
 87680:   // as the path to draw.
 87680:   SkPath path;
 87680:   path.addRect(SkRect::MakeWH(mSize.width, mSize.height));
 87680:  
 87680:   Matrix temp = mTransform;
 87680:   temp.Invert();
 87680:   SkMatrix mat;
 87680:   GfxMatrixToSkiaMatrix(temp, mat);
 87680:   path.transform(mat);
 87680: 
 87680:   mCanvas->drawPath(path, paint.mPaint);
 87680: }
 87680: 
 81281: TemporaryRef<SourceSurface>
 81281: DrawTargetSkia::CreateSourceSurfaceFromData(unsigned char *aData,
 81281:                                              const IntSize &aSize,
 81281:                                              int32_t aStride,
 81281:                                              SurfaceFormat aFormat) const
 81281: {
 81281:   RefPtr<SourceSurfaceSkia> newSurf = new SourceSurfaceSkia();
 81281: 
 81281:   if (!newSurf->InitFromData(aData, aSize, aStride, aFormat)) {
 81281:     gfxDebug() << *this << ": Failure to create source surface from data. Size: " << aSize;
 81281:     return NULL;
 81281:   }
 81281:     
 81281:   return newSurf;
 81281: }
 81281: 
 81281: TemporaryRef<DrawTarget>
 81281: DrawTargetSkia::CreateSimilarDrawTarget(const IntSize &aSize, SurfaceFormat aFormat) const
 81281: {
 81281:   RefPtr<DrawTargetSkia> target = new DrawTargetSkia();
 81281:   if (!target->Init(aSize, aFormat)) {
 81281:     return NULL;
 81281:   }
 81281:   return target;
 81281: }
 81281: 
 81281: TemporaryRef<SourceSurface>
 81281: DrawTargetSkia::OptimizeSourceSurface(SourceSurface *aSurface) const
 81281: {
 81281:   return NULL;
 81281: }
 81281: 
 81281: TemporaryRef<SourceSurface>
 81281: DrawTargetSkia::CreateSourceSurfaceFromNativeSurface(const NativeSurface &aSurface) const
 81281: {
 81281:   return NULL;
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::CopySurface(SourceSurface *aSurface,
 81281:                             const IntRect& aSourceRect,
 81281:                             const IntPoint &aDestination)
 81281: {
 81281:   //TODO: We could just use writePixels() here if the sourceRect is the entire source
 81281:   
 81281:     if (aSurface->GetType() != SURFACE_SKIA) {
 81281:     return;
 81281:   }
 81281: 
 81283:   MarkChanged();
 81283:   
 81281:   const SkBitmap& bitmap = static_cast<SourceSurfaceSkia*>(aSurface)->GetBitmap();
 81281: 
 81281:   mCanvas->save();
 81281:   mCanvas->resetMatrix();
 81281:   SkRect dest = IntRectToSkRect(IntRect(aDestination.x, aDestination.y, aSourceRect.width, aSourceRect.height)); 
 81281:   SkIRect source = IntRectToSkIRect(aSourceRect);
 81281:   mCanvas->clipRect(dest, SkRegion::kReplace_Op);
 81281:   SkPaint paint;
101080: 
101080:   if (mBitmap.config() == SkBitmap::kRGB_565_Config &&
101080:       mCanvas->getDevice()->config() == SkBitmap::kRGB_565_Config) {
101080:     // Set the xfermode to SOURCE_OVER to workaround
101080:     // http://code.google.com/p/skia/issues/detail?id=628
101080:     // RGB565 is opaque so they're equivalent anyway
101080:     paint.setXfermodeMode(SkXfermode::kSrcOver_Mode);
101080:   } else {
101080:     paint.setXfermodeMode(SkXfermode::kSrc_Mode);
101080:   }
101080: 
 81281:   mCanvas->drawBitmapRect(bitmap, &source, dest, &paint);
 81281:   mCanvas->restore();
 81281: }
 81281: 
 81281: bool
 81281: DrawTargetSkia::Init(const IntSize &aSize, SurfaceFormat aFormat)
 81281: {
 81281:   mBitmap.setConfig(GfxFormatToSkiaConfig(aFormat), aSize.width, aSize.height);
 81281:   if (!mBitmap.allocPixels()) {
 81281:     return false;
 81281:   }
 81281:   mBitmap.eraseARGB(0, 0, 0, 0);
 81281:   SkAutoTUnref<SkDevice> device(new SkDevice(mBitmap));
 81281:   SkAutoTUnref<SkCanvas> canvas(new SkCanvas(device.get()));
 81281:   mSize = aSize;
 81281: 
 81281:   mDevice = device.get();
 81281:   mCanvas = canvas.get();
 81281:   mFormat = aFormat;
 81281:   return true;
 81281: }
 81281: 
 81281: void
 87680: DrawTargetSkia::Init(unsigned char* aData, const IntSize &aSize, int32_t aStride, SurfaceFormat aFormat)
 87680: {
 87680:   mBitmap.setConfig(GfxFormatToSkiaConfig(aFormat), aSize.width, aSize.height, aStride);
 87680:   mBitmap.setPixels(aData);
 87680:   
 87680:   SkAutoTUnref<SkDevice> device(new SkDevice(mBitmap));
 87680:   SkAutoTUnref<SkCanvas> canvas(new SkCanvas(device.get()));
 87680:   mSize = aSize;
 87680: 
 87680:   mDevice = device.get();
 87680:   mCanvas = canvas.get();
 87680:   mFormat = aFormat;
 87680: }
 87680: 
 87680: void
 81281: DrawTargetSkia::SetTransform(const Matrix& aTransform)
 81281: {
 81281:   SkMatrix mat;
 81281:   GfxMatrixToSkiaMatrix(aTransform, mat);
 81281:   mCanvas->setMatrix(mat);
 81281:   mTransform = aTransform;
 81281: }
 81281: 
 81281: TemporaryRef<PathBuilder> 
 81281: DrawTargetSkia::CreatePathBuilder(FillRule aFillRule) const
 81281: {
 81281:   RefPtr<PathBuilderSkia> pb = new PathBuilderSkia(aFillRule);
 81281:   return pb;
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::ClearRect(const Rect &aRect)
 81281: {
 81283:   MarkChanged();
 81281:   SkPaint paint;
 81281:   mCanvas->save();
 87686:   mCanvas->clipRect(RectToSkRect(aRect), SkRegion::kIntersect_Op, USE_SOFT_CLIPPING);
 81281:   paint.setColor(SkColorSetARGB(0, 0, 0, 0));
 81281:   paint.setXfermodeMode(SkXfermode::kSrc_Mode);
 81281:   mCanvas->drawPaint(paint);
 81281:   mCanvas->restore();
 81281: }
 81281: 
 81281: void
 81281: DrawTargetSkia::PushClip(const Path *aPath)
 81281: {
 81281:   if (aPath->GetBackendType() != BACKEND_SKIA) {
 81281:     return;
 81281:   }
 81281: 
 81281:   const PathSkia *skiaPath = static_cast<const PathSkia*>(aPath);
 81281:   mCanvas->save(SkCanvas::kClip_SaveFlag);
 87686:   mCanvas->clipPath(skiaPath->GetPath(), SkRegion::kIntersect_Op, USE_SOFT_CLIPPING);
 81281: }
 81281: 
 81281: void
 87680: DrawTargetSkia::PushClipRect(const Rect& aRect)
 87680: {
 87680:   SkRect rect = RectToSkRect(aRect);
 87680: 
 87680:   mCanvas->save(SkCanvas::kClip_SaveFlag);
 87686:   mCanvas->clipRect(rect, SkRegion::kIntersect_Op, USE_SOFT_CLIPPING);
 87680: }
 87680: 
 87680: void
 81281: DrawTargetSkia::PopClip()
 81281: {
 81281:   mCanvas->restore();
 81281: }
 81281: 
 81281: TemporaryRef<GradientStops>
 86250: DrawTargetSkia::CreateGradientStops(GradientStop *aStops, uint32_t aNumStops, ExtendMode aExtendMode) const
 81281: {
 81281:   std::vector<GradientStop> stops;
 81281:   stops.resize(aNumStops);
 81281:   for (uint32_t i = 0; i < aNumStops; i++) {
 81281:     stops[i] = aStops[i];
 81281:   }
 81281:   std::stable_sort(stops.begin(), stops.end());
 81281:   
 87680:   return new GradientStopsSkia(stops, aNumStops, aExtendMode);
 81281: }
 81281: 
 81283: void
 81283: DrawTargetSkia::AppendSnapshot(SourceSurfaceSkia* aSnapshot)
 81283: {
 81283:   mSnapshots.push_back(aSnapshot);
 81281: }
 81283: 
 81283: void
 81283: DrawTargetSkia::RemoveSnapshot(SourceSurfaceSkia* aSnapshot)
 81283: {
 81283:   std::vector<SourceSurfaceSkia*>::iterator iter = std::find(mSnapshots.begin(), mSnapshots.end(), aSnapshot);
 81283:   if (iter != mSnapshots.end()) {
 81283:     mSnapshots.erase(iter);
 81281:   }
 81283: }
 81283: 
 81283: void
 81283: DrawTargetSkia::MarkChanged()
 81283: {
 81283:   if (mSnapshots.size()) {
 81283:     for (std::vector<SourceSurfaceSkia*>::iterator iter = mSnapshots.begin();
 81283:          iter != mSnapshots.end(); iter++) {
 81283:       (*iter)->DrawTargetWillChange();
 81283:     }
 81283:     // All snapshots will now have copied data.
 81283:     mSnapshots.clear();
 81283:   }
 81283: }
 81283: 
 81283: }
 81283: }
