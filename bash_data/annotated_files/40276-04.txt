29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18830:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS function support.
    1:  */
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
31823: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
21866: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: #include "jsexn.h"
18989: #include "jsstaticcheck.h"
32710: #include "jstracer.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: # include "jsiter.h"
    1: #endif
    1: 
11435: #if JS_HAS_XDR
11435: # include "jsxdrapi.h"
11435: #endif
11435: 
30283: #include "jsatominlines.h"
30283: 
37741: using namespace js;
37741: 
31823: static inline void
31823: SetOverriddenArgsLength(JSObject *obj)
31823: {
31823:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
31823: 
31823:     jsval v = obj->fslots[JSSLOT_ARGS_LENGTH];
31823:     v = INT_TO_JSVAL(JSVAL_TO_INT(v) | 1);
31823:     JS_ASSERT(JSVAL_IS_INT(v));
31823:     obj->fslots[JSSLOT_ARGS_LENGTH] = v;
31823: }
31823: 
31823: static inline void
31823: InitArgsLengthSlot(JSObject *obj, uint32 argc)
31823: {
31823:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
31823:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
31823:     JS_ASSERT(obj->fslots[JSSLOT_ARGS_LENGTH] == JSVAL_VOID);
31823:     obj->fslots[JSSLOT_ARGS_LENGTH] = INT_TO_JSVAL(argc << 1);
33113:     JS_ASSERT(!js_IsOverriddenArgsLength(obj));
31823: }
31823: 
31823: static inline uint32
31823: GetArgsLength(JSObject *obj)
31823: {
31823:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
31823: 
31823:     uint32 argc = uint32(JSVAL_TO_INT(obj->fslots[JSSLOT_ARGS_LENGTH])) >> 1;
31823:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
31823:     return argc;
31823: }
    1: 
32709: static inline void
37741: SetArgsPrivateNative(JSObject *argsobj, ArgsPrivateNative *apn)
32709: {
32709:     JS_ASSERT(STOBJ_GET_CLASS(argsobj) == &js_ArgumentsClass);
32709:     uintptr_t p = (uintptr_t) apn;
32709:     argsobj->setPrivate((void*) (p | 2));
32709: }
32709: 
    1: JSBool
    1: js_GetArgsValue(JSContext *cx, JSStackFrame *fp, jsval *vp)
    1: {
    1:     JSObject *argsobj;
    1: 
31823:     if (fp->flags & JSFRAME_OVERRIDE_ARGS) {
    1:         JS_ASSERT(fp->callobj);
31823:         jsid id = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
31823:         return fp->callobj->getProperty(cx, id, vp);
    1:     }
    1:     argsobj = js_GetArgsObject(cx, fp);
    1:     if (!argsobj)
    1:         return JS_FALSE;
    1:     *vp = OBJECT_TO_JSVAL(argsobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
 2383: js_GetArgsProperty(JSContext *cx, JSStackFrame *fp, jsid id, jsval *vp)
    1: {
31823:     if (fp->flags & JSFRAME_OVERRIDE_ARGS) {
31823:         JS_ASSERT(fp->callobj);
31823: 
31823:         jsid argumentsid = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
31823:         jsval v;
31823:         if (!fp->callobj->getProperty(cx, argumentsid, &v))
31823:             return false;
31823: 
    1:         JSObject *obj;
31823:         if (JSVAL_IS_PRIMITIVE(v)) {
31823:             obj = js_ValueToNonNullObject(cx, v);
    1:             if (!obj)
31823:                 return false;
    1:         } else {
31823:             obj = JSVAL_TO_OBJECT(v);
    1:         }
31501:         return obj->getProperty(cx, id, vp);
    1:     }
    1: 
    1:     *vp = JSVAL_VOID;
    1:     if (JSID_IS_INT(id)) {
31823:         uint32 arg = uint32(JSID_TO_INT(id));
31823:         JSObject *argsobj = JSVAL_TO_OBJECT(fp->argsobj);
31823:         if (arg < fp->argc) {
31823:             if (argsobj) {
31823:                 jsval v = OBJ_GET_SLOT(cx, argsobj, JSSLOT_ARGS_COPY_START+arg);
31823:                 if (v == JSVAL_HOLE)
31823:                     return argsobj->getProperty(cx, id, vp);
31823:             }
31823:             *vp = fp->argv[arg];
    1:         } else {
    1:             /*
    1:              * Per ECMA-262 Ed. 3, 10.1.8, last bulleted item, do not share
    1:              * storage between the formal parameter and arguments[k] for all
 4127:              * fp->argc <= k && k < fp->fun->nargs.  For example, in
    1:              *
    1:              *   function f(x) { x = 42; return arguments[0]; }
    1:              *   f();
    1:              *
    1:              * the call to f should return undefined, not 42.  If fp->argsobj
    1:              * is null at this point, as it would be in the example, return
    1:              * undefined in *vp.
    1:              */
31823:             if (argsobj)
31823:                 return argsobj->getProperty(cx, id, vp);
    1:         }
31823:     } else if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
31823:         JSObject *argsobj = JSVAL_TO_OBJECT(fp->argsobj);
33113:         if (argsobj && js_IsOverriddenArgsLength(argsobj))
31823:             return argsobj->getProperty(cx, id, vp);
31823:         *vp = INT_TO_JSVAL(jsint(fp->argc));
    1:     }
31823:     return true;
    1: }
31823: 
31823: static JSObject *
31823: NewArguments(JSContext *cx, JSObject *parent, uint32 argc, JSObject *callee)
31823: {
31823:     JSObject *argsobj = js_NewObject(cx, &js_ArgumentsClass, NULL, parent, 0);
31823:     if (!argsobj || !js_EnsureReservedSlots(cx, argsobj, argc))
31823:         return NULL;
31823: 
31823:     argsobj->fslots[JSSLOT_ARGS_CALLEE] = OBJECT_TO_JSVAL(callee);
31823:     InitArgsLengthSlot(argsobj, argc);
31823:     return argsobj;
31823: }
31823: 
31823: static void
31823: PutArguments(JSContext *cx, JSObject *argsobj, jsval *args)
31823: {
31823:     uint32 argc = GetArgsLength(argsobj);
31823:     JS_LOCK_OBJ(cx, argsobj);
31823:     for (uint32 i = 0; i != argc; ++i) {
31823:         jsval v = STOBJ_GET_SLOT(argsobj, JSSLOT_ARGS_COPY_START + i);
31823:         if (v != JSVAL_HOLE)
31823:             STOBJ_SET_SLOT(argsobj, JSSLOT_ARGS_COPY_START + i, args[i]);
31823:     }
31823:     JS_UNLOCK_OBJ(cx, argsobj);
    1: }
    1: 
    1: JSObject *
    1: js_GetArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     /*
    1:      * We must be in a function activation; the function must be lightweight
    1:      * or else fp must have a variable object.
    1:      */
37777:     JS_ASSERT(fp->fun);
37777:     JS_ASSERT_IF(fp->fun->flags & JSFUN_HEAVYWEIGHT,
40276:                  fp->varobj(cx->containingCallStack(fp)));
    1: 
    1:     /* Skip eval and debugger frames. */
    1:     while (fp->flags & JSFRAME_SPECIAL)
    1:         fp = fp->down;
    1: 
    1:     /* Create an arguments object for fp only if it lacks one. */
31447:     JSObject *argsobj = JSVAL_TO_OBJECT(fp->argsobj);
    1:     if (argsobj)
    1:         return argsobj;
    1: 
    1:     /*
    1:      * Give arguments an intrinsic scope chain link to fp's global object.
    1:      * Since the arguments object lacks a prototype because js_ArgumentsClass
    1:      * is not initialized, js_NewObject won't assign a default parent to it.
    1:      *
    1:      * Therefore if arguments is used as the head of an eval scope chain (via
    1:      * a direct or indirect call to eval(program, arguments)), any reference
    1:      * to a standard class object in the program will fail to resolve due to
    1:      * js_GetClassPrototype not being able to find a global object containing
    1:      * the standard prototype by starting from arguments and following parent.
    1:      */
39930:     JSObject *global = fp->scopeChain;
39930:     while (JSObject *parent = global->getParent())
    1:         global = parent;
31823: 
31939:     JS_ASSERT(fp->argv);
31940:     argsobj = NewArguments(cx, global, fp->argc, JSVAL_TO_OBJECT(fp->argv[-2]));
31447:     if (!argsobj)
31823:         return argsobj;
31447: 
31447:     /* Link the new object to fp so it can get actual argument values. */
31452:     argsobj->setPrivate(fp);
30248:     fp->argsobj = OBJECT_TO_JSVAL(argsobj);
    1:     return argsobj;
    1: }
    1: 
31823: void
    1: js_PutArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
31823:     JSObject *argsobj = JSVAL_TO_OBJECT(fp->argsobj);
31823:     JS_ASSERT(argsobj->getPrivate() == fp);
31823:     PutArguments(cx, argsobj, fp->argv);
31823:     argsobj->setPrivate(NULL);
31823:     fp->argsobj = JSVAL_NULL;
31823: }
    1: 
    1: /*
31823:  * Traced versions of js_GetArgsObject and js_PutArgsObject.
    1:  */
32709: 
32709: #ifdef JS_TRACER
31824: JSObject * JS_FASTCALL
31823: js_Arguments(JSContext *cx, JSObject *parent, uint32 argc, JSObject *callee,
37741:              double *argv, ArgsPrivateNative *apn)
31823: {
32709:     JSObject *argsobj = NewArguments(cx, parent, argc, callee);
33110:     if (!argsobj)
33110:         return NULL;
32709:     apn->argv = argv;
32709:     SetArgsPrivateNative(argsobj, apn);
32709:     return argsobj;
    1: }
32709: #endif
32709: 
32709: JS_DEFINE_CALLINFO_6(extern, OBJECT, js_Arguments, CONTEXT, OBJECT, UINT32, OBJECT,
39910:                      DOUBLEPTR, APNPTR, 0, nanojit::ACC_STORE_ANY)
31823: 
31823: /* FIXME change the return type to void. */
31823: JSBool JS_FASTCALL
31823: js_PutArguments(JSContext *cx, JSObject *argsobj, jsval *args)
31823: {
32709:     JS_ASSERT(js_GetArgsPrivateNative(argsobj));
31823:     PutArguments(cx, argsobj, args);
34328:     argsobj->setPrivate(NULL);
31823:     return true;
    1: }
    1: 
39910: JS_DEFINE_CALLINFO_3(extern, BOOL, js_PutArguments, CONTEXT, OBJECT, JSVALPTR, 0,
39910:                      nanojit::ACC_STORE_ANY)
31823: 
    1: static JSBool
31447: args_delProperty(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
    1: {
31823:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
    1: 
31447:     if (JSVAL_IS_INT(idval)) {
31447:         uintN arg = uintN(JSVAL_TO_INT(idval));
31823:         if (arg < GetArgsLength(obj))
31823:             OBJ_SET_SLOT(cx, obj, JSSLOT_ARGS_COPY_START + arg, JSVAL_HOLE);
31447:     } else if (idval == ATOM_KEY(cx->runtime->atomState.lengthAtom)) {
31823:         SetOverriddenArgsLength(obj);
31447:     } else if (idval == ATOM_KEY(cx->runtime->atomState.calleeAtom)) {
31823:         obj->fslots[JSSLOT_ARGS_CALLEE] = JSVAL_HOLE;
    1:     }
31447:     return true;
    1: }
    1: 
28952: static JS_REQUIRES_STACK JSObject *
28952: WrapEscapingClosure(JSContext *cx, JSStackFrame *fp, JSObject *funobj, JSFunction *fun)
28952: {
28952:     JS_ASSERT(GET_FUNCTION_PRIVATE(cx, funobj) == fun);
29009:     JS_ASSERT(fun->optimizedClosure());
28952:     JS_ASSERT(!fun->u.i.wrapper);
28952: 
28952:     /*
28952:      * We do not attempt to reify Call and Block objects on demand for outer
28952:      * scopes. This could be done (see the "v8" patch in bug 494235) but it is
28952:      * fragile in the face of ongoing compile-time optimization. Instead, the
28952:      * _DBG* opcodes used by wrappers created here must cope with unresolved
28952:      * upvars and throw them as reference errors. Caveat debuggers!
28952:      */
28952:     JSObject *scopeChain = js_GetScopeChain(cx, fp);
28952:     if (!scopeChain)
28952:         return NULL;
28952: 
28952:     JSObject *wfunobj = js_NewObjectWithGivenProto(cx, &js_FunctionClass,
30439:                                                    funobj, scopeChain);
28952:     if (!wfunobj)
28952:         return NULL;
40221:     AutoValueRooter tvr(cx, wfunobj);
28952: 
28952:     JSFunction *wfun = (JSFunction *) wfunobj;
32684:     wfunobj->setPrivate(wfun);
28952:     wfun->nargs = 0;
28952:     wfun->flags = fun->flags | JSFUN_HEAVYWEIGHT;
28952:     wfun->u.i.nvars = 0;
28952:     wfun->u.i.nupvars = 0;
28952:     wfun->u.i.skipmin = fun->u.i.skipmin;
28952:     wfun->u.i.wrapper = true;
28952:     wfun->u.i.script = NULL;
28952:     wfun->u.i.names.taggedAtom = NULL;
28952:     wfun->atom = fun->atom;
28952: 
28952:     if (fun->hasLocalNames()) {
28952:         void *mark = JS_ARENA_MARK(&cx->tempPool);
28952:         jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
28952:         if (!names)
28952:             return NULL;
28952: 
28952:         JSBool ok = true;
28952:         for (uintN i = 0, n = fun->countLocalNames(); i != n; i++) {
28952:             jsuword name = names[i];
28952:             JSAtom *atom = JS_LOCAL_NAME_TO_ATOM(name);
28952:             JSLocalKind localKind = (i < fun->nargs)
28952:                                     ? JSLOCAL_ARG
28952:                                     : (i < fun->countArgsAndVars())
28952:                                     ? (JS_LOCAL_NAME_IS_CONST(name)
28952:                                        ? JSLOCAL_CONST
28952:                                        : JSLOCAL_VAR)
28952:                                     : JSLOCAL_UPVAR;
28952: 
28952:             ok = js_AddLocal(cx, wfun, atom, localKind);
28952:             if (!ok)
28952:                 break;
28952:         }
28952: 
28952:         JS_ARENA_RELEASE(&cx->tempPool, mark);
28952:         if (!ok)
28952:             return NULL;
28952:         JS_ASSERT(wfun->nargs == fun->nargs);
28952:         JS_ASSERT(wfun->u.i.nvars == fun->u.i.nvars);
28952:         JS_ASSERT(wfun->u.i.nupvars == fun->u.i.nupvars);
28952:         js_FreezeLocalNames(cx, wfun);
28952:     }
28952: 
28952:     JSScript *script = fun->u.i.script;
32723:     jssrcnote *snbase = script->notes();
28952:     jssrcnote *sn = snbase;
28952:     while (!SN_IS_TERMINATOR(sn))
28952:         sn = SN_NEXT(sn);
28952:     uintN nsrcnotes = (sn - snbase) + 1;
28952: 
28952:     /* NB: GC must not occur before wscript is homed in wfun->u.i.script. */
28952:     JSScript *wscript = js_NewScript(cx, script->length, nsrcnotes,
28952:                                      script->atomMap.length,
28952:                                      (script->objectsOffset != 0)
32723:                                      ? script->objects()->length
28952:                                      : 0,
28952:                                      fun->u.i.nupvars,
28952:                                      (script->regexpsOffset != 0)
32723:                                      ? script->regexps()->length
28952:                                      : 0,
28952:                                      (script->trynotesOffset != 0)
32723:                                      ? script->trynotes()->length
28952:                                      : 0);
28952:     if (!wscript)
28952:         return NULL;
28952: 
28952:     memcpy(wscript->code, script->code, script->length);
28952:     wscript->main = wscript->code + (script->main - script->code);
28952: 
32723:     memcpy(wscript->notes(), snbase, nsrcnotes * sizeof(jssrcnote));
28952:     memcpy(wscript->atomMap.vector, script->atomMap.vector,
28952:            wscript->atomMap.length * sizeof(JSAtom *));
28952:     if (script->objectsOffset != 0) {
32723:         memcpy(wscript->objects()->vector, script->objects()->vector,
32723:                wscript->objects()->length * sizeof(JSObject *));
28952:     }
28952:     if (script->regexpsOffset != 0) {
32723:         memcpy(wscript->regexps()->vector, script->regexps()->vector,
32723:                wscript->regexps()->length * sizeof(JSObject *));
28952:     }
28952:     if (script->trynotesOffset != 0) {
32723:         memcpy(wscript->trynotes()->vector, script->trynotes()->vector,
32723:                wscript->trynotes()->length * sizeof(JSTryNote));
28952:     }
28952: 
28952:     if (wfun->u.i.nupvars != 0) {
32723:         JS_ASSERT(wfun->u.i.nupvars == wscript->upvars()->length);
32723:         memcpy(wscript->upvars()->vector, script->upvars()->vector,
28952:                wfun->u.i.nupvars * sizeof(uint32));
28952:     }
28952: 
28952:     jsbytecode *pc = wscript->code;
28952:     while (*pc != JSOP_STOP) {
28952:         /* XYZZYbe should copy JSOP_TRAP? */
28952:         JSOp op = js_GetOpcode(cx, wscript, pc);
28952:         const JSCodeSpec *cs = &js_CodeSpec[op];
28952:         ptrdiff_t oplen = cs->length;
28952:         if (oplen < 0)
28952:             oplen = js_GetVariableBytecodeLength(pc);
28952: 
28952:         /*
28952:          * Rewrite JSOP_{GET,CALL}DSLOT as JSOP_{GET,CALL}UPVAR_DBG for the
28952:          * case where fun is an escaping flat closure. This works because the
28952:          * UPVAR and DSLOT ops by design have the same format: an upvar index
28952:          * immediate operand.
28952:          */
28952:         switch (op) {
28952:           case JSOP_GETUPVAR:       *pc = JSOP_GETUPVAR_DBG; break;
28952:           case JSOP_CALLUPVAR:      *pc = JSOP_CALLUPVAR_DBG; break;
28952:           case JSOP_GETDSLOT:       *pc = JSOP_GETUPVAR_DBG; break;
28952:           case JSOP_CALLDSLOT:      *pc = JSOP_CALLUPVAR_DBG; break;
28952:           case JSOP_DEFFUN_FC:      *pc = JSOP_DEFFUN_DBGFC; break;
28952:           case JSOP_DEFLOCALFUN_FC: *pc = JSOP_DEFLOCALFUN_DBGFC; break;
28952:           case JSOP_LAMBDA_FC:      *pc = JSOP_LAMBDA_DBGFC; break;
28952:           default:;
28952:         }
28952:         pc += oplen;
28952:     }
28952: 
28952:     /*
29009:      * Fill in the rest of wscript. This means if you add members to JSScript
29009:      * you must update this code. FIXME: factor into JSScript::clone method.
28952:      */
33750:     wscript->noScriptRval = script->noScriptRval;
33750:     wscript->savedCallerFun = script->savedCallerFun;
33750:     wscript->hasSharps = script->hasSharps;
35113:     wscript->strictModeCode = script->strictModeCode;
28952:     wscript->version = script->version;
28952:     wscript->nfixed = script->nfixed;
28952:     wscript->filename = script->filename;
28952:     wscript->lineno = script->lineno;
28952:     wscript->nslots = script->nslots;
28952:     wscript->staticLevel = script->staticLevel;
28952:     wscript->principals = script->principals;
28952:     if (wscript->principals)
28952:         JSPRINCIPALS_HOLD(cx, wscript->principals);
28952: #ifdef CHECK_SCRIPT_OWNER
28952:     wscript->owner = script->owner;
28952: #endif
28952: 
28952:     /* Deoptimize wfun from FUN_{FLAT,NULL}_CLOSURE to FUN_INTERPRETED. */
28952:     FUN_SET_KIND(wfun, JSFUN_INTERPRETED);
28952:     wfun->u.i.script = wscript;
28952:     return wfunobj;
28952: }
28952: 
    1: static JSBool
31447: ArgGetter(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
    1: {
31823:     if (!JS_InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
31447:         return true;
31447: 
31447:     if (JSVAL_IS_INT(idval)) {
31447:         /*
31447:          * arg can exceed the number of arguments if a script changed the
31447:          * prototype to point to another Arguments object with a bigger argc.
31447:          */
31447:         uintN arg = uintN(JSVAL_TO_INT(idval));
31823:         if (arg < GetArgsLength(obj)) {
32709: #ifdef JS_TRACER
37741:             ArgsPrivateNative *argp = js_GetArgsPrivateNative(obj);
32709:             if (argp) {
37741:                 if (NativeToValue(cx, *vp, argp->typemap()[arg], &argp->argv[arg]))
32709:                     return true;
37741:                 LeaveTrace(cx);
32709:                 return false;
32709:             }
32709: #endif
32709: 
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
31823:             if (fp) {
31447:                 *vp = fp->argv[arg];
31823:             } else {
31823:                 jsval v = OBJ_GET_SLOT(cx, obj, JSSLOT_ARGS_COPY_START + arg);
31823:                 if (v != JSVAL_HOLE)
31823:                     *vp = v;
31823:             }
31823:         }
31447:     } else if (idval == ATOM_KEY(cx->runtime->atomState.lengthAtom)) {
33113:         if (!js_IsOverriddenArgsLength(obj))
31823:             *vp = INT_TO_JSVAL(GetArgsLength(obj));
31447:     } else {
31447:         JS_ASSERT(idval == ATOM_KEY(cx->runtime->atomState.calleeAtom));
31823:         jsval v = obj->fslots[JSSLOT_ARGS_CALLEE];
31823:         if (v != JSVAL_HOLE) {
29009:             /*
29009:              * If this function or one in it needs upvars that reach above it
29009:              * in the scope chain, it must not be a null closure (it could be a
29009:              * flat closure, or an unoptimized closure -- the latter itself not
29009:              * necessarily heavyweight). Rather than wrap here, we simply throw
29009:              * to reduce code size and tell debugger users the truth instead of
29009:              * passing off a fibbing wrapper.
29009:              */
31823:             if (GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(v))->needsWrapper()) {
28964:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28964:                                      JSMSG_OPTIMIZED_CLOSURE_LEAK);
31447:                 return false;
28964:             }
31823:             *vp = v;
28964:         }
    1:     }
31447:     return true;
    1: }
    1: 
    1: static JSBool
31447: ArgSetter(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
    1: {
35056: #ifdef JS_TRACER
35054:     // To be able to set a property here on trace, we would have to make
35054:     // sure any updates also get written back to the trace native stack.
35054:     // For simplicity, we just leave trace, since this is presumably not
35054:     // a common operation.
35054:     if (JS_ON_TRACE(cx)) {
37741:         DeepBail(cx);
35054:         return false;
35054:     }
35056: #endif
35054: 
31823:     if (!JS_InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
31447:         return true;
31447: 
31447:     if (JSVAL_IS_INT(idval)) {
31447:         uintN arg = uintN(JSVAL_TO_INT(idval));
31823:         if (arg < GetArgsLength(obj)) {
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
31823:             if (fp) {
31447:                 fp->argv[arg] = *vp;
31823:                 return true;
31823:             }
31447:         }
31447:     } else {
31447:         JS_ASSERT(idval == ATOM_KEY(cx->runtime->atomState.lengthAtom) ||
31447:                   idval == ATOM_KEY(cx->runtime->atomState.calleeAtom));
31447:     }
31823: 
31823:     /*
31823:      * For simplicity we use delete/set to replace the property with one
31823:      * backed by the default Object getter and setter. Note the we rely on
31823:      * args_delete to clear the corresponding reserved slot so the GC can
31823:      * collect its value.
31823:      */
31823:     jsid id;
31823:     if (!JS_ValueToId(cx, idval, &id))
31823:         return false;
31823: 
40221:     AutoValueRooter tvr(cx);
31823:     return js_DeleteProperty(cx, obj, id, tvr.addr()) &&
31823:            js_SetProperty(cx, obj, id, vp);
31447: }
31447: 
31447: static JSBool
31447: args_resolve(JSContext *cx, JSObject *obj, jsval idval, uintN flags,
31447:              JSObject **objp)
31447: {
31447:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
31823: 
31447:     *objp = NULL;
31823:     jsid id = 0;
31447:     if (JSVAL_IS_INT(idval)) {
31823:         uint32 arg = uint32(JSVAL_TO_INT(idval));
31823:         if (arg < GetArgsLength(obj) &&
31823:             OBJ_GET_SLOT(cx, obj, JSSLOT_ARGS_COPY_START + arg) != JSVAL_HOLE) {
31447:             id = INT_JSVAL_TO_JSID(idval);
31447:         }
31823:     } else if (idval == ATOM_KEY(cx->runtime->atomState.lengthAtom)) {
33113:         if (!js_IsOverriddenArgsLength(obj))
31823:             id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
31823: 
31823:     } else if (idval == ATOM_KEY(cx->runtime->atomState.calleeAtom)) {
31823:         if (obj->fslots[JSSLOT_ARGS_CALLEE] != JSVAL_HOLE)
31823:             id = ATOM_TO_JSID(cx->runtime->atomState.calleeAtom);
31447:     }
31823: 
31823:     if (id != 0) {
31823:         /*
31823:          * XXX ECMA specs DontEnum even for indexed properties, contrary to
31823:          * other array-like objects.
31823:          */
32573:         if (!js_DefineProperty(cx, obj, id, JSVAL_VOID, ArgGetter, ArgSetter, JSPROP_SHARED))
31823:             return JS_FALSE;
31447:         *objp = obj;
31823:     }
31447:     return true;
31447: }
31447: 
31447: static JSBool
31447: args_enumerate(JSContext *cx, JSObject *obj)
31447: {
31447:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
31447: 
    1:     /*
31823:      * Trigger reflection in args_resolve using a series of js_LookupProperty
31823:      * calls.
    1:      */
31823:     int argc = int(GetArgsLength(obj));
31447:     for (int i = -2; i != argc; i++) {
31447:         jsid id = (i == -2)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)
31447:                   : (i == -1)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.calleeAtom)
31447:                   : INT_JSVAL_TO_JSID(INT_TO_JSVAL(i));
31447: 
31447:         JSObject *pobj;
31447:         JSProperty *prop;
31447:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
31447:             return false;
31823: 
31823:         /* prop is null when the property was deleted. */
    1:         if (prop)
31501:             pobj->dropProperty(cx, prop);
    1:     }
31447:     return true;
    1: }
    1: 
    1: #if JS_HAS_GENERATORS
    1: /*
    1:  * If a generator-iterator's arguments or call object escapes, it needs to
    1:  * mark its generator object.
    1:  */
  583: static void
  583: args_or_call_trace(JSTracer *trc, JSObject *obj)
    1: {
31823:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass ||
31823:               STOBJ_GET_CLASS(obj) == &js_CallClass);
32709:     if (STOBJ_GET_CLASS(obj) == &js_ArgumentsClass && js_GetArgsPrivateNative(obj))
32709:         return;
31823: 
31823:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
  583:     if (fp && (fp->flags & JSFRAME_GENERATOR)) {
  583:         JS_CALL_OBJECT_TRACER(trc, FRAME_TO_GENERATOR(fp)->obj,
  583:                               "FRAME_TO_GENERATOR(fp)->obj");
  583:     }
    1: }
    1: #else
  583: # define args_or_call_trace NULL
    1: #endif
    1: 
31823: static uint32
31823: args_reserveSlots(JSContext *cx, JSObject *obj)
31823: {
31823:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_ArgumentsClass);
31823:     return GetArgsLength(obj);
31823: }
31823: 
    1: /*
    1:  * The Arguments class is not initialized via JS_InitClass, and must not be,
    1:  * because its name is "Object".  Per ECMA, that causes instances of it to
    1:  * delegate to the object named by Object.prototype.  It also ensures that
    1:  * arguments.toString() returns "[object Object]".
    1:  *
    1:  * The JSClass functions below collaborate to lazily reflect and synchronize
    1:  * actual argument values, argument count, and callee function object stored
    1:  * in a JSStackFrame with their corresponding property values in the frame's
    1:  * arguments object.
    1:  */
    1: JSClass js_ArgumentsClass = {
    1:     js_Object_str,
31823:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
31823:     JSCLASS_HAS_RESERVED_SLOTS(ARGS_CLASS_FIXED_RESERVED_SLOTS) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
    1:     JS_PropertyStub,    args_delProperty,
31447:     JS_PropertyStub,    JS_PropertyStub,
    1:     args_enumerate,     (JSResolveOp) args_resolve,
30654:     JS_ConvertStub,     NULL,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
31823:     JS_CLASS_TRACE(args_or_call_trace), args_reserveSlots
    1: };
    1: 
31823: const uint32 JSSLOT_CALLEE =                    JSSLOT_PRIVATE + 1;
31823: const uint32 JSSLOT_CALL_ARGUMENTS =            JSSLOT_PRIVATE + 2;
31823: const uint32 CALL_CLASS_FIXED_RESERVED_SLOTS =  2;
15588: 
28952: /*
28952:  * A Declarative Environment object stores its active JSStackFrame pointer in
28952:  * its private slot, just as Call and Arguments objects do.
28952:  */
27319: JSClass js_DeclEnvClass = {
27319:     js_Object_str,
28952:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
27319:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
27319:     JSCLASS_NO_OPTIONAL_MEMBERS
27319: };
27319: 
29888: static JSBool
28952: CheckForEscapingClosure(JSContext *cx, JSObject *obj, jsval *vp)
28952: {
28952:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_CallClass ||
28952:               STOBJ_GET_CLASS(obj) == &js_DeclEnvClass);
28952: 
28952:     jsval v = *vp;
28952: 
28952:     if (VALUE_IS_FUNCTION(cx, v)) {
28952:         JSObject *funobj = JSVAL_TO_OBJECT(v);
28952:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
28952: 
28952:         /*
28952:          * Any escaping null or flat closure that reaches above itself or
28952:          * contains nested functions that reach above it must be wrapped.
28952:          * We can wrap only when this Call or Declarative Environment obj
28952:          * still has an active stack frame associated with it.
28952:          */
29009:         if (fun->needsWrapper()) {
37741:             LeaveTrace(cx);
29888: 
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
28952:             if (fp) {
28952:                 JSObject *wrapper = WrapEscapingClosure(cx, fp, funobj, fun);
28952:                 if (!wrapper)
28952:                     return false;
28952:                 *vp = OBJECT_TO_JSVAL(wrapper);
28952:                 return true;
28952:             }
28952: 
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_OPTIMIZED_CLOSURE_LEAK);
28952:             return false;
28952:         }
28952:     }
28952:     return true;
28952: }
28952: 
29888: static JSBool
28952: CalleeGetter(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
28952: {
28952:     return CheckForEscapingClosure(cx, obj, vp);
28952: }
28952: 
37694: static JSObject *
37694: NewCallObject(JSContext *cx, JSFunction *fun, JSObject *scopeChain)
37694: {
37694:     JSObject *callobj = js_NewObjectWithGivenProto(cx, &js_CallClass, NULL, scopeChain);
37694:     if (!callobj ||
37694:         !js_EnsureReservedSlots(cx, callobj, fun->countArgsAndVars())) {
37694:         return NULL;
37694:     }
37694:     return callobj;
37694: }
37694: 
    1: JSObject *
25217: js_GetCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
25217:     JSObject *callobj;
    1: 
    1:     /* Create a call object for fp only if it lacks one. */
    1:     JS_ASSERT(fp->fun);
    1:     callobj = fp->callobj;
    1:     if (callobj)
    1:         return callobj;
    1: 
25217: #ifdef DEBUG
25217:     /* A call object should be a frame's outermost scope chain element.  */
25217:     JSClass *classp = OBJ_GET_CLASS(cx, fp->scopeChain);
25217:     if (classp == &js_WithClass || classp == &js_BlockClass || classp == &js_CallClass)
32684:         JS_ASSERT(fp->scopeChain->getPrivate() != fp);
25217: #endif
    1: 
25217:     /*
27319:      * Create the call object, using the frame's enclosing scope as its
27319:      * parent, and link the call to its stack frame. For a named function
27319:      * expression Call's parent points to an environment object holding
27319:      * function's name.
25217:      */
27319:     JSAtom *lambdaName = (fp->fun->flags & JSFUN_LAMBDA) ? fp->fun->atom : NULL;
27319:     if (lambdaName) {
27472:         JSObject *env = js_NewObjectWithGivenProto(cx, &js_DeclEnvClass, NULL,
30439:                                                    fp->scopeChain);
27472:         if (!env)
27660:             return NULL;
32684:         env->setPrivate(fp);
27472: 
28312:         /* Root env before js_DefineNativeProperty (-> JSClass.addProperty). */
27472:         fp->scopeChain = env;
31939:         JS_ASSERT(fp->argv);
28312:         if (!js_DefineNativeProperty(cx, fp->scopeChain, ATOM_TO_JSID(lambdaName),
34352:                                      fp->calleeValue(),
28952:                                      CalleeGetter, NULL,
28312:                                      JSPROP_PERMANENT | JSPROP_READONLY,
28312:                                      0, 0, NULL)) {
28312:             return NULL;
28312:         }
27319:     }
27539: 
37694:     callobj = NewCallObject(cx, fp->fun, fp->scopeChain);
37694:     if (!callobj)
    1:         return NULL;
15588: 
31452:     callobj->setPrivate(fp);
31939:     JS_ASSERT(fp->argv);
34352:     JS_ASSERT(fp->fun == GET_FUNCTION_PRIVATE(cx, fp->calleeObject()));
34352:     STOBJ_SET_SLOT(callobj, JSSLOT_CALLEE, fp->calleeValue());
    1:     fp->callobj = callobj;
    1: 
25217:     /*
25217:      * Push callobj on the top of the scope chain, and make it the
25217:      * variables object.
25217:      */
    1:     fp->scopeChain = callobj;
    1:     return callobj;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
37694: js_CreateCallObjectOnTrace(JSContext *cx, JSFunction *fun, JSObject *callee, JSObject *scopeChain)
37694: {
37694:     JS_ASSERT(!js_IsNamedLambda(fun));
37694:     JSObject *callobj = NewCallObject(cx, fun, scopeChain);
37694:     if (!callobj)
37694:         return NULL;
37694:     STOBJ_SET_SLOT(callobj, JSSLOT_CALLEE, OBJECT_TO_JSVAL(callee));
37694:     return callobj;
37694: }
37694: 
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CreateCallObjectOnTrace, CONTEXT, FUNCTION, OBJECT, OBJECT,
39910:                      0, nanojit::ACC_STORE_ANY)
37694: 
32589: JSFunction *
32589: js_GetCallObjectFunction(JSObject *obj)
15588: {
15588:     jsval v;
15588: 
15588:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_CallClass);
27012:     v = STOBJ_GET_SLOT(obj, JSSLOT_CALLEE);
15588:     if (JSVAL_IS_VOID(v)) {
15588:         /* Newborn or prototype object. */
15588:         return NULL;
15588:     }
15588:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
27012:     return GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(v));
15588: }
    1: 
37694: inline static void
37694: CopyValuesToCallObject(JSObject *callobj, int nargs, jsval *argv, int nvars, jsval *slots)
37694: {
37694:     memcpy(callobj->dslots, argv, nargs * sizeof(jsval));
37694:     memcpy(callobj->dslots + nargs, slots, nvars * sizeof(jsval));
37694: }
37694: 
31823: void
    1: js_PutCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
31447:     JSObject *callobj = fp->callobj;
31447:     JS_ASSERT(callobj);
31447: 
31823:     /* Get the arguments object to snapshot fp's actual argument values. */
31447:     if (fp->argsobj) {
31823:         if (!(fp->flags & JSFRAME_OVERRIDE_ARGS))
31447:             STOBJ_SET_SLOT(callobj, JSSLOT_CALL_ARGUMENTS, fp->argsobj);
31823:         js_PutArgsObject(cx, fp);
31447:     }
31447: 
31447:     JSFunction *fun = fp->fun;
32589:     JS_ASSERT(fun == js_GetCallObjectFunction(callobj));
31447:     uintN n = fun->countArgsAndVars();
    1: 
    1:     /*
15588:      * Since for a call object all fixed slots happen to be taken, we can copy
15588:      * arguments and variables straight into JSObject.dslots.
    1:      */
15588:     JS_STATIC_ASSERT(JS_INITIAL_NSLOTS - JSSLOT_PRIVATE ==
15588:                      1 + CALL_CLASS_FIXED_RESERVED_SLOTS);
15588:     if (n != 0) {
31823:         JS_ASSERT(STOBJ_NSLOTS(callobj) >= JS_INITIAL_NSLOTS + n);
30732:         n += JS_INITIAL_NSLOTS;
37694:         CopyValuesToCallObject(callobj, fun->nargs, fp->argv, fun->u.i.nvars, fp->slots);
15588:     }
30732: 
30732:     /* Clear private pointers to fp, which is about to go away (js_Invoke). */
37694:     if (js_IsNamedLambda(fun)) {
39930:         JSObject *env = callobj->getParent();
28952: 
28952:         JS_ASSERT(STOBJ_GET_CLASS(env) == &js_DeclEnvClass);
32684:         JS_ASSERT(env->getPrivate() == fp);
31452:         env->setPrivate(NULL);
28952:     }
28952: 
31452:     callobj->setPrivate(NULL);
    1:     fp->callobj = NULL;
    1: }
    1: 
37694: JSBool JS_FASTCALL
37694: js_PutCallObjectOnTrace(JSContext *cx, JSObject *scopeChain, uint32 nargs, jsval *argv,
37694:                         uint32 nvars, jsval *slots)
37694: {
37694:     JS_ASSERT(scopeChain->hasClass(&js_CallClass));
37694:     JS_ASSERT(!scopeChain->getPrivate());
37694: 
37694:     uintN n = nargs + nvars;
37694:     if (n != 0)
37694:         CopyValuesToCallObject(scopeChain, nargs, argv, nvars, slots);
37694: 
37694:     return true;
37694: }
37694: 
39910: JS_DEFINE_CALLINFO_6(extern, BOOL, js_PutCallObjectOnTrace, CONTEXT, OBJECT, UINT32, JSVALPTR,
39910:                      UINT32, JSVALPTR, 0, nanojit::ACC_STORE_ANY)
37694: 
    1: static JSBool
    1: call_enumerate(JSContext *cx, JSObject *obj)
    1: {
13702:     JSFunction *fun;
15588:     uintN n, i;
 8367:     void *mark;
11435:     jsuword *names;
11435:     JSBool ok;
11435:     JSAtom *name;
 8367:     JSObject *pobj;
    1:     JSProperty *prop;
    1: 
32589:     fun = js_GetCallObjectFunction(obj);
28832:     n = fun ? fun->countArgsAndVars() : 0;
 8367:     if (n == 0)
 8367:         return JS_TRUE;
 8367: 
 8367:     mark = JS_ARENA_MARK(&cx->tempPool);
11435: 
18989:     MUST_FLOW_THROUGH("out");
11435:     names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
11435:     if (!names) {
11435:         ok = JS_FALSE;
 8367:         goto out;
11435:     }
 8367: 
 8367:     for (i = 0; i != n; ++i) {
11435:         name = JS_LOCAL_NAME_TO_ATOM(names[i]);
 8367:         if (!name)
    1:             continue;
    1: 
 3624:         /*
 8367:          * Trigger reflection by looking up the name of the argument or
 8367:          * variable.
 3624:          */
11435:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(name), &pobj, &prop);
11435:         if (!ok)
 8367:             goto out;
    1: 
    1:         /*
28832:          * The call object will always have a property corresponding to the
28832:          * argument or variable name because call_resolve creates the property
28832:          * using JSPROP_PERMANENT.
    1:          */
28832:         JS_ASSERT(prop);
27341:         JS_ASSERT(pobj == obj);
31501:         pobj->dropProperty(cx, prop);
    1:     }
11435:     ok = JS_TRUE;
 8367: 
 8367:   out:
 8367:     JS_ARENA_RELEASE(&cx->tempPool, mark);
11435:     return ok;
    1: }
    1: 
39916: enum JSCallPropertyKind {
13706:     JSCPK_ARGUMENTS,
13706:     JSCPK_ARG,
39916:     JSCPK_VAR,
39916:     JSCPK_UPVAR
39916: };
13706: 
13706: static JSBool
13706: CallPropertyOp(JSContext *cx, JSObject *obj, jsid id, jsval *vp,
39916:                JSCallPropertyKind kind, JSBool setter = false)
13706: {
39916:     JS_ASSERT(obj->getClass() == &js_CallClass);
39919: 
39919:     uintN i = 0;
39919:     if (kind != JSCPK_ARGUMENTS) {
39916:         JS_ASSERT((int16) JSVAL_TO_INT(id) == JSVAL_TO_INT(id));
39919:         i = (uint16) JSVAL_TO_INT(id);
39919:     }
39916: 
13706:     jsval *array;
39916:     if (kind == JSCPK_UPVAR) {
39916:         JSObject *callee = JSVAL_TO_OBJECT(STOBJ_GET_SLOT(obj, JSSLOT_CALLEE));
39916: 
39916: #ifdef DEBUG
39916:         JSFunction *callee_fun = (JSFunction *) callee->getPrivate();
39916:         JS_ASSERT(FUN_FLAT_CLOSURE(callee_fun));
39916:         JS_ASSERT(i < callee_fun->u.i.nupvars);
39916: #endif
39916: 
39916:         array = callee->dslots;
39916:     } else {
39916:         JSFunction *fun = js_GetCallObjectFunction(obj);
39916:         JS_ASSERT_IF(kind == JSCPK_ARG, i < fun->nargs);
39916:         JS_ASSERT_IF(kind == JSCPK_VAR, i < fun->u.i.nvars);
39916: 
39916:         JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
13706: 
13706:         if (kind == JSCPK_ARGUMENTS) {
13706:             if (setter) {
15588:                 if (fp)
31823:                     fp->flags |= JSFRAME_OVERRIDE_ARGS;
15588:                 STOBJ_SET_SLOT(obj, JSSLOT_CALL_ARGUMENTS, *vp);
15588:             } else {
31823:                 if (fp && !(fp->flags & JSFRAME_OVERRIDE_ARGS)) {
13706:                     JSObject *argsobj;
13706: 
13706:                     argsobj = js_GetArgsObject(cx, fp);
13706:                     if (!argsobj)
39916:                         return false;
13706:                     *vp = OBJECT_TO_JSVAL(argsobj);
15588:                 } else {
15588:                     *vp = STOBJ_GET_SLOT(obj, JSSLOT_CALL_ARGUMENTS);
15588:                 }
13706:             }
39916:             return true;
13706:         }
13706: 
15588:         if (!fp) {
15588:             i += CALL_CLASS_FIXED_RESERVED_SLOTS;
15588:             if (kind == JSCPK_VAR)
15588:                 i += fun->nargs;
15588:             else
15588:                 JS_ASSERT(kind == JSCPK_ARG);
15588:             return setter
15588:                    ? JS_SetReservedSlot(cx, obj, i, *vp)
15588:                    : JS_GetReservedSlot(cx, obj, i, vp);
15588:         }
15588: 
13706:         if (kind == JSCPK_ARG) {
13706:             array = fp->argv;
13706:         } else {
13706:             JS_ASSERT(kind == JSCPK_VAR);
16072:             array = fp->slots;
13706:         }
39916:     }
39916: 
25514:     if (setter) {
25514:         GC_POKE(cx, array[i]);
13706:         array[i] = *vp;
25514:     } else {
13706:         *vp = array[i];
25514:     }
39916:     return true;
    1: }
    1: 
    1: static JSBool
13706: GetCallArguments(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS);
13706: }
13706: 
13706: static JSBool
13706: SetCallArguments(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS, true);
13706: }
13706: 
13706: JSBool
13706: js_GetCallArg(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG);
13706: }
13706: 
30848: JSBool
13706: SetCallArg(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG, true);
39916: }
39916: 
39916: JSBool
39916: GetFlatUpvar(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
39916: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_UPVAR);
39916: }
39916: 
39916: JSBool
39916: SetFlatUpvar(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
39916: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_UPVAR, true);
13706: }
13706: 
13706: JSBool
13706: js_GetCallVar(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR);
29009: }
29009: 
29009: JSBool
29009: js_GetCallVarChecked(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
29009: {
39916:     if (!CallPropertyOp(cx, obj, id, vp, JSCPK_VAR))
39916:         return false;
28952: 
28952:     return CheckForEscapingClosure(cx, obj, vp);
13706: }
13706: 
30848: JSBool
13706: SetCallVar(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR, true);
13706: }
13706: 
30848: JSBool JS_FASTCALL
30848: js_SetCallArg(JSContext *cx, JSObject *obj, jsid id, jsval v)
30848: {
39916:     return CallPropertyOp(cx, obj, id, &v, JSCPK_ARG, true);
30848: }
30848: 
30848: JSBool JS_FASTCALL
30848: js_SetCallVar(JSContext *cx, JSObject *obj, jsid id, jsval v)
30848: {
39916:     return CallPropertyOp(cx, obj, id, &v, JSCPK_VAR, true);
30848: }
30848: 
39910: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallArg, CONTEXT, OBJECT, JSID, JSVAL, 0,
39910:                      nanojit::ACC_STORE_ANY)
39910: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallVar, CONTEXT, OBJECT, JSID, JSVAL, 0,
39910:                      nanojit::ACC_STORE_ANY)
30848: 
 3624: static JSBool
10573: call_resolve(JSContext *cx, JSObject *obj, jsval idval, uintN flags,
    1:              JSObject **objp)
    1: {
27012:     jsval callee;
13706:     JSFunction *fun;
10573:     jsid id;
 8179:     JSLocalKind localKind;
    1:     JSPropertyOp getter, setter;
 8179:     uintN slot, attrs;
    1: 
27012:     JS_ASSERT(STOBJ_GET_CLASS(obj) == &js_CallClass);
39928:     JS_ASSERT(!obj->getProto());
28397: 
10573:     if (!JSVAL_IS_STRING(idval))
    1:         return JS_TRUE;
    1: 
27012:     callee = STOBJ_GET_SLOT(obj, JSSLOT_CALLEE);
27012:     if (JSVAL_IS_VOID(callee))
15588:         return JS_TRUE;
27012:     fun = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(callee));
15588: 
10573:     if (!js_ValueToStringId(cx, idval, &id))
    1:         return JS_FALSE;
    1: 
28397:     /*
28397:      * Check whether the id refers to a formal parameter, local variable or
28397:      * the arguments special name.
28397:      *
28397:      * We define all such names using JSDNP_DONT_PURGE to avoid an expensive
28397:      * shape invalidation in js_DefineNativeProperty. If such an id happens to
28397:      * shadow a global or upvar of the same name, any inner functions can
28397:      * never access the outer binding. Thus it cannot invalidate any property
28397:      * cache entries or derived trace guards for the outer binding. See also
28397:      * comments in js_PurgeScopeChainHelper from jsobj.cpp.
28397:      */
13427:     localKind = js_LookupLocal(cx, fun, JSID_TO_ATOM(id), &slot);
39916:     if (localKind != JSLOCAL_NONE) {
13706:         JS_ASSERT((uint16) slot == slot);
24849: 
24849:         /*
24849:          * We follow 10.2.3 of ECMA 262 v3 and make argument and variable
24849:          * properties of the Call objects enumerable.
24849:          */
24849:         attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_SHARED;
 8179:         if (localKind == JSLOCAL_ARG) {
13427:             JS_ASSERT(slot < fun->nargs);
13706:             getter = js_GetCallArg;
13706:             setter = SetCallArg;
 3624:         } else {
39916:             JSCallPropertyKind cpkind;
39916:             if (localKind == JSLOCAL_UPVAR) {
39916:                 if (!FUN_FLAT_CLOSURE(fun))
39916:                     return JS_TRUE;
39916:                 getter = GetFlatUpvar;
39916:                 setter = SetFlatUpvar;
39916:                 cpkind = JSCPK_UPVAR;
39916:             } else {
 8179:                 JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
13706:                 JS_ASSERT(slot < fun->u.i.nvars);
13706:                 getter = js_GetCallVar;
13706:                 setter = SetCallVar;
39916:                 cpkind = JSCPK_VAR;
15588:                 if (localKind == JSLOCAL_CONST)
15588:                     attrs |= JSPROP_READONLY;
39916:             }
29009: 
29009:             /*
29009:              * Use js_GetCallVarChecked if the local's value is a null closure.
29009:              * This way we penalize performance only slightly on first use of a
29009:              * null closure, not on every use.
29009:              */
29009:             jsval v;
39916:             if (!CallPropertyOp(cx, obj, INT_TO_JSID((int16)slot), &v, cpkind))
29009:                 return JS_FALSE;
29009:             if (VALUE_IS_FUNCTION(cx, v) &&
29009:                 GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(v))->needsWrapper()) {
29009:                 getter = js_GetCallVarChecked;
29009:             }
    1:         }
15588:         if (!js_DefineNativeProperty(cx, obj, id, JSVAL_VOID, getter, setter,
38562:                                      attrs, JSScopeProperty::HAS_SHORTID, (int16) slot,
28397:                                      NULL, JSDNP_DONT_PURGE)) {
 2464:             return JS_FALSE;
 2464:         }
 2464:         *objp = obj;
 2464:         return JS_TRUE;
 2464:     }
 3624: 
 3624:     /*
 3624:      * Resolve arguments so that we never store a particular Call object's
 3624:      * arguments object reference in a Call prototype's |arguments| slot.
 3624:      */
10573:     if (id == ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom)) {
10573:         if (!js_DefineNativeProperty(cx, obj, id, JSVAL_VOID,
13706:                                      GetCallArguments, SetCallArguments,
15588:                                      JSPROP_PERMANENT | JSPROP_SHARED,
28397:                                      0, 0, NULL, JSDNP_DONT_PURGE)) {
 3624:             return JS_FALSE;
 3624:         }
 3624:         *objp = obj;
 3624:         return JS_TRUE;
 2464:     }
27012: 
27012:     /* Control flow reaches here only if id was not resolved. */
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: call_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
    1:     if (type == JSTYPE_FUNCTION) {
31452:         JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
    1:         if (fp) {
    1:             JS_ASSERT(fp->fun);
31939:             JS_ASSERT(fp->argv);
34352:             *vp = fp->calleeValue();
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
15588: static uint32
15588: call_reserveSlots(JSContext *cx, JSObject *obj)
15588: {
15588:     JSFunction *fun;
15588: 
32589:     fun = js_GetCallObjectFunction(obj);
28832:     return fun->countArgsAndVars();
15588: }
15588: 
 9018: JS_FRIEND_DATA(JSClass) js_CallClass = {
27539:     "Call",
15588:     JSCLASS_HAS_PRIVATE |
15588:     JSCLASS_HAS_RESERVED_SLOTS(CALL_CLASS_FIXED_RESERVED_SLOTS) |
27539:     JSCLASS_NEW_RESOLVE | JSCLASS_IS_ANONYMOUS | JSCLASS_MARK_IS_TRACE,
    1:     JS_PropertyStub,    JS_PropertyStub,
13706:     JS_PropertyStub,    JS_PropertyStub,
    1:     call_enumerate,     (JSResolveOp)call_resolve,
30654:     call_convert,       NULL,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
    1:     NULL,               NULL,
15588:     JS_CLASS_TRACE(args_or_call_trace), call_reserveSlots
    1: };
    1: 
31823: /* Generic function tinyids. */
31823: enum {
31823:     FUN_ARGUMENTS   = -1,       /* predefined arguments local variable */
31823:     FUN_LENGTH      = -2,       /* number of actual args, arity if inactive */
31823:     FUN_ARITY       = -3,       /* number of formal parameters; desired argc */
31823:     FUN_NAME        = -4,       /* function name, "" if anonymous */
31823:     FUN_CALLER      = -5        /* Function.prototype.caller, backward compat */
31823: };
31823: 
    1: static JSBool
    1: fun_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsint slot;
    1:     JSFunction *fun;
    1:     JSStackFrame *fp;
18870:     JSSecurityCallbacks *callbacks;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     slot = JSVAL_TO_INT(id);
    1: 
    1:     /*
    1:      * Loop because getter and setter can be delegated from another class,
31823:      * but loop only for FUN_LENGTH because we must pretend that f.length
    1:      * is in each function instance f, per ECMA-262, instead of only in the
    1:      * Function.prototype object (we use JSPROP_PERMANENT with JSPROP_SHARED
    1:      * to make it appear so).
    1:      *
    1:      * This code couples tightly to the attributes for the function_props[]
18062:      * initializers above, and to js_SetProperty and js_HasOwnProperty.
    1:      *
    1:      * It's important to allow delegating objects, even though they inherit
    1:      * this getter (fun_getProperty), to override arguments, arity, caller,
31823:      * and name.  If we didn't return early for slot != FUN_LENGTH, we would
    1:      * clobber *vp with the native property value, instead of letting script
    1:      * override that value in delegating objects.
    1:      *
    1:      * Note how that clobbering is what simulates JSPROP_READONLY for all of
    1:      * the non-standard properties when the directly addressed object (obj)
    1:      * is a function object (i.e., when this loop does not iterate).
    1:      */
    1:     while (!(fun = (JSFunction *)
    1:                    JS_GetInstancePrivate(cx, obj, &js_FunctionClass, NULL))) {
31823:         if (slot != FUN_LENGTH)
    1:             return JS_TRUE;
39928:         obj = obj->getProto();
    1:         if (!obj)
    1:             return JS_TRUE;
    1:     }
    1: 
    1:     /* Find fun's top-most activation record. */
22652:     for (fp = js_GetTopStackFrame(cx);
22652:          fp && (fp->fun != fun || (fp->flags & JSFRAME_SPECIAL));
    1:          fp = fp->down) {
    1:         continue;
    1:     }
    1: 
    1:     switch (slot) {
31823:       case FUN_ARGUMENTS:
    1:         /* Warn if strict about f.arguments or equivalent unqualified uses. */
    1:         if (!JS_ReportErrorFlagsAndNumber(cx,
    1:                                           JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_DEPRECATED_USAGE,
    1:                                           js_arguments_str)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (fp) {
    1:             if (!js_GetArgsValue(cx, fp, vp))
    1:                 return JS_FALSE;
    1:         } else {
    1:             *vp = JSVAL_NULL;
    1:         }
    1:         break;
    1: 
31823:       case FUN_LENGTH:
    1:       case FUN_ARITY:
    1:             *vp = INT_TO_JSVAL((jsint)fun->nargs);
    1:         break;
    1: 
    1:       case FUN_NAME:
    1:         *vp = fun->atom
    1:               ? ATOM_KEY(fun->atom)
    1:               : STRING_TO_JSVAL(cx->runtime->emptyString);
    1:         break;
    1: 
    1:       case FUN_CALLER:
28952:         if (fp && fp->down && fp->down->fun) {
28965:             JSFunction *caller = fp->down->fun;
28965:             /*
28965:              * See equivalent condition in args_getProperty for ARGS_CALLEE,
28965:              * but here we do not want to throw, since this escape can happen
28965:              * via foo.caller alone, without any debugger or indirect eval. And
28965:              * it seems foo.caller is still used on the Web.
28965:              */
29009:             if (caller->needsWrapper()) {
28966:                 JSObject *wrapper = WrapEscapingClosure(cx, fp->down, FUN_OBJECT(caller), caller);
28965:                 if (!wrapper)
28964:                     return JS_FALSE;
28965:                 *vp = OBJECT_TO_JSVAL(wrapper);
28965:                 return JS_TRUE;
28964:             }
28964: 
31939:             JS_ASSERT(fp->down->argv);
34352:             *vp = fp->down->calleeValue();
28952:         } else {
    1:             *vp = JSVAL_NULL;
28952:         }
18870:         if (!JSVAL_IS_PRIMITIVE(*vp)) {
18870:             callbacks = JS_GetSecurityCallbacks(cx);
18870:             if (callbacks && callbacks->checkObjectAccess) {
    1:                 id = ATOM_KEY(cx->runtime->atomState.callerAtom);
18870:                 if (!callbacks->checkObjectAccess(cx, obj, id, JSACC_READ, vp))
    1:                     return JS_FALSE;
    1:             }
18870:         }
    1:         break;
    1: 
    1:       default:
    1:         /* XXX fun[0] and fun.arguments[0] are equivalent. */
    1:         if (fp && fp->fun && (uintN)slot < fp->fun->nargs)
    1:             *vp = fp->argv[slot];
    1:         break;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
18830: /*
18830:  * ECMA-262 specifies that length is a property of function object instances,
18830:  * but we can avoid that space cost by delegating to a prototype property that
18830:  * is JSPROP_PERMANENT and JSPROP_SHARED.  Each fun_getProperty call computes
18830:  * a fresh length value based on the arity of the individual function object's
18830:  * private data.
18830:  *
18830:  * The extensions below other than length, i.e., the ones not in ECMA-262,
18830:  * are neither JSPROP_READONLY nor JSPROP_SHARED, because for compatibility
18830:  * with ECMA we must allow a delegating object to override them. Therefore to
18830:  * avoid entraining garbage in Function.prototype slots, they must be resolved
18830:  * in non-prototype function objects, wherefore the lazy_function_props table
18830:  * and fun_resolve's use of it.
18830:  */
18830: #define LENGTH_PROP_ATTRS (JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED)
18830: 
18830: static JSPropertySpec function_props[] = {
31823:     {js_length_str,    FUN_LENGTH,    LENGTH_PROP_ATTRS, fun_getProperty, JS_PropertyStub},
18830:     {0,0,0,0,0}
18830: };
18830: 
18830: typedef struct LazyFunctionProp {
18830:     uint16      atomOffset;
18830:     int8        tinyid;
18830:     uint8       attrs;
18830: } LazyFunctionProp;
18830: 
18830: /* NB: no sentinel at the end -- use JS_ARRAY_LENGTH to bound loops. */
18830: static LazyFunctionProp lazy_function_props[] = {
31823:     {ATOM_OFFSET(arguments), FUN_ARGUMENTS, JSPROP_PERMANENT},
18830:     {ATOM_OFFSET(arity),     FUN_ARITY,      JSPROP_PERMANENT},
18830:     {ATOM_OFFSET(caller),    FUN_CALLER,     JSPROP_PERMANENT},
18830:     {ATOM_OFFSET(name),      FUN_NAME,       JSPROP_PERMANENT},
18830: };
18830: 
    1: static JSBool
    1: fun_resolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
    1:             JSObject **objp)
    1: {
    1:     JSFunction *fun;
 2803:     JSAtom *atom;
 2803:     uintN i;
 2102: 
    1:     if (!JSVAL_IS_STRING(id))
    1:         return JS_TRUE;
    1: 
13691:     fun = GET_FUNCTION_PRIVATE(cx, obj);
 2803: 
 2803:     /*
33604:      * No need to reflect fun.prototype in 'fun.prototype = ... '. Assert that
33604:      * fun is not a compiler-created function object, which must never leak to
33604:      * script or embedding code and then be mutated.
 2803:      */
33604:     if (flags & JSRESOLVE_ASSIGNING) {
33605:         JS_ASSERT(!js_IsInternalFunctionObject(obj));
    1:         return JS_TRUE;
33604:     }
    1: 
    1:     /*
    1:      * Ok, check whether id is 'prototype' and bootstrap the function object's
    1:      * prototype property.
    1:      */
 2803:     atom = cx->runtime->atomState.classPrototypeAtom;
 2803:     if (id == ATOM_KEY(atom)) {
33605:         JS_ASSERT(!js_IsInternalFunctionObject(obj));
    1: 
    1:         /*
    1:          * Beware of the wacky case of a user function named Object -- trying
    1:          * to find a prototype for that will recur back here _ad perniciem_.
    1:          */
13702:         if (fun->atom == CLASS_ATOM(cx, Object))
    1:             return JS_TRUE;
    1: 
    1:         /*
 9481:          * Make the prototype object to have the same parent as the function
 9481:          * object itself.
    1:          */
33604:         JSObject *proto =
39930:             js_NewObject(cx, &js_ObjectClass, NULL, obj->getParent());
    1:         if (!proto)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * ECMA (15.3.5.2) says that constructor.prototype is DontDelete for
    1:          * user-defined functions, but DontEnum | ReadOnly | DontDelete for
    1:          * native "system" constructors such as Object or Function.  So lazily
    1:          * set the former here in fun_resolve, but eagerly define the latter
    1:          * in JS_InitClass, with the right attributes.
    1:          */
32671:         if (!js_SetClassPrototype(cx, obj, proto, JSPROP_PERMANENT))
    1:             return JS_FALSE;
32671: 
    1:         *objp = obj;
 2803:         return JS_TRUE;
 2803:     }
 2803: 
 2803:     for (i = 0; i < JS_ARRAY_LENGTH(lazy_function_props); i++) {
 2803:         LazyFunctionProp *lfp = &lazy_function_props[i];
 2803: 
 2803:         atom = OFFSET_TO_ATOM(cx->runtime, lfp->atomOffset);
 2803:         if (id == ATOM_KEY(atom)) {
33605:             JS_ASSERT(!js_IsInternalFunctionObject(obj));
33604: 
 2803:             if (!js_DefineNativeProperty(cx, obj,
 2803:                                          ATOM_TO_JSID(atom), JSVAL_VOID,
18830:                                          fun_getProperty, JS_PropertyStub,
38562:                                          lfp->attrs, JSScopeProperty::HAS_SHORTID,
18830:                                          lfp->tinyid, NULL)) {
 2803:                 return JS_FALSE;
 2803:             }
 2803:             *objp = obj;
 2803:             return JS_TRUE;
 2803:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: fun_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
    1:     switch (type) {
    1:       case JSTYPE_FUNCTION:
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:         return JS_TRUE;
    1:       default:
    1:         return js_TryValueOf(cx, obj, type, vp);
    1:     }
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: /* XXX store parent and proto, if defined */
28093: JSBool
28093: js_XDRFunctionObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSFunction *fun;
28952:     uint32 firstword;           /* flag telling whether fun->atom is non-null,
28952:                                    plus for fun->u.i.skipmin, fun->u.i.wrapper,
28952:                                    and 14 bits reserved for future use */
27012:     uintN nargs, nvars, nupvars, n;
28952:     uint32 localsword;          /* word for argument and variable counts */
28952:     uint32 flagsword;           /* word for fun->u.i.nupvars and fun->flags */
    1: 
    1:     cx = xdr->cx;
    1:     if (xdr->mode == JSXDR_ENCODE) {
13702:         fun = GET_FUNCTION_PRIVATE(cx, *objp);
    1:         if (!FUN_INTERPRETED(fun)) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_NOT_SCRIPTED_FUNCTION,
    1:                                  JS_GetFunctionName(fun));
40221:             return false;
    1:         }
28952:         if (fun->u.i.wrapper) {
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_XDR_CLOSURE_WRAPPER,
28952:                                  JS_GetFunctionName(fun));
40221:             return false;
28952:         }
28952:         JS_ASSERT((fun->u.i.wrapper & ~1U) == 0);
28952:         firstword = (fun->u.i.skipmin << 2) | (fun->u.i.wrapper << 1) | !!fun->atom;
13691:         nargs = fun->nargs;
13702:         nvars = fun->u.i.nvars;
27012:         nupvars = fun->u.i.nupvars;
 8179:         localsword = (nargs << 16) | nvars;
27012:         flagsword = (nupvars << 16) | fun->flags;
    1:     } else {
13702:         fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, NULL, NULL);
    1:         if (!fun)
40221:             return false;
39930:         FUN_OBJECT(fun)->clearParent();
39928:         FUN_OBJECT(fun)->clearProto();
 8179: #ifdef __GNUC__
27012:         nvars = nargs = nupvars = 0;    /* quell GCC uninitialized warning */
 8179: #endif
    1:     }
    1: 
40221:     AutoValueRooter tvr(cx, FUN_OBJECT(fun));
    1: 
28952:     if (!JS_XDRUint32(xdr, &firstword))
40221:         return false;
28952:     if ((firstword & 1U) && !js_XDRStringAtom(xdr, &fun->atom))
40221:         return false;
 8179:     if (!JS_XDRUint32(xdr, &localsword) ||
    1:         !JS_XDRUint32(xdr, &flagsword)) {
40221:         return false;
    1:     }
    1: 
 8179:     if (xdr->mode == JSXDR_DECODE) {
 8179:         nargs = localsword >> 16;
27012:         nvars = uint16(localsword);
27012:         JS_ASSERT((flagsword & JSFUN_KINDMASK) >= JSFUN_INTERPRETED);
27012:         nupvars = flagsword >> 16;
27012:         fun->flags = uint16(flagsword);
28952:         fun->u.i.skipmin = uint16(firstword >> 2);
33166:         fun->u.i.wrapper = JSPackedBool((firstword >> 1) & 1);
 8179:     }
    1: 
    1:     /* do arguments and local vars */
27012:     n = nargs + nvars + nupvars;
13824:     if (n != 0) {
 8179:         void *mark;
 8179:         uintN i;
 8179:         uintN bitmapLength;
 8179:         uint32 *bitmap;
11435:         jsuword *names;
11435:         JSAtom *name;
 8337:         JSLocalKind localKind;
 8179: 
40221:         bool ok = true;
 8179:         mark = JS_ARENA_MARK(&xdr->cx->tempPool);
 8179: 
11435:         /*
11435:          * From this point the control must flow via the label release_mark.
11435:          *
11435:          * To xdr the names we prefix the names with a bitmap descriptor and
11435:          * then xdr the names as strings. For argument names (indexes below
11435:          * nargs) the corresponding bit in the bitmap is unset when the name
11435:          * is null. Such null names are not encoded or decoded. For variable
11435:          * names (indexes starting from nargs) bitmap's bit is set when the
11435:          * name is declared as const, not as ordinary var.
11435:          * */
27012:         MUST_FLOW_THROUGH("release_mark");
 8179:         bitmapLength = JS_HOWMANY(n, JS_BITS_PER_UINT32);
 8179:         JS_ARENA_ALLOCATE_CAST(bitmap, uint32 *, &xdr->cx->tempPool,
 8179:                                bitmapLength * sizeof *bitmap);
 8179:         if (!bitmap) {
 8296:             js_ReportOutOfScriptQuota(xdr->cx);
40221:             ok = false;
 8179:             goto release_mark;
 8179:         }
    1:         if (xdr->mode == JSXDR_ENCODE) {
13691:             names = js_GetLocalNameArray(xdr->cx, fun, &xdr->cx->tempPool);
11435:             if (!names) {
40221:                 ok = false;
11435:                 goto release_mark;
 8179:             }
40229:             PodZero(bitmap, bitmapLength);
11435:             for (i = 0; i != n; ++i) {
13691:                 if (i < fun->nargs
11435:                     ? JS_LOCAL_NAME_TO_ATOM(names[i]) != NULL
11435:                     : JS_LOCAL_NAME_IS_CONST(names[i])) {
11435:                     bitmap[i >> JS_BITS_PER_UINT32_LOG2] |=
11435:                         JS_BIT(i & (JS_BITS_PER_UINT32 - 1));
11435:                 }
11435:             }
11435:         }
11435: #ifdef __GNUC__
11435:         else {
11435:             names = NULL;   /* quell GCC uninitialized warning */
11435:         }
11435: #endif
 8179:         for (i = 0; i != bitmapLength; ++i) {
 8179:             ok = JS_XDRUint32(xdr, &bitmap[i]);
 8179:             if (!ok)
 8179:                 goto release_mark;
 8179:         }
 8179:         for (i = 0; i != n; ++i) {
 8179:             if (i < nargs &&
11435:                 !(bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 8179:                   JS_BIT(i & (JS_BITS_PER_UINT32 - 1)))) {
 8179:                 if (xdr->mode == JSXDR_DECODE) {
13691:                     ok = js_AddLocal(xdr->cx, fun, NULL, JSLOCAL_ARG);
 8179:                     if (!ok)
 8179:                         goto release_mark;
 8179:                 } else {
11435:                     JS_ASSERT(!JS_LOCAL_NAME_TO_ATOM(names[i]));
 8179:                 }
 8179:                 continue;
 8179:             }
 8179:             if (xdr->mode == JSXDR_ENCODE)
11435:                 name = JS_LOCAL_NAME_TO_ATOM(names[i]);
 8179:             ok = js_XDRStringAtom(xdr, &name);
 8179:             if (!ok)
 8179:                 goto release_mark;
 8179:             if (xdr->mode == JSXDR_DECODE) {
 8179:                 localKind = (i < nargs)
 8179:                             ? JSLOCAL_ARG
27012:                             : (i < nargs + nvars)
27012:                             ? (bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 8179:                                JS_BIT(i & (JS_BITS_PER_UINT32 - 1))
 8179:                                ? JSLOCAL_CONST
27012:                                : JSLOCAL_VAR)
27012:                             : JSLOCAL_UPVAR;
13691:                 ok = js_AddLocal(xdr->cx, fun, name, localKind);
 8179:                 if (!ok)
 8179:                     goto release_mark;
 8179:             }
 8179:         }
    1: 
 8179:       release_mark:
 8179:         JS_ARENA_RELEASE(&xdr->cx->tempPool, mark);
 8179:         if (!ok)
40221:             return false;
    1: 
 8367:         if (xdr->mode == JSXDR_DECODE)
13691:             js_FreezeLocalNames(cx, fun);
    1:     }
    1: 
34290:     if (!js_XDRScript(xdr, &fun->u.i.script, false, NULL))
40221:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
13824:         *objp = FUN_OBJECT(fun);
34290:         if (fun->u.i.script != JSScript::emptyScript()) {
11377: #ifdef CHECK_SCRIPT_OWNER
13702:             fun->u.i.script->owner = NULL;
11377: #endif
    1:             js_CallNewScriptHook(cx, fun->u.i.script, fun);
    1:         }
34290:     }
    1: 
40221:     return true;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
28093: #define js_XDRFunctionObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
    1: /*
    1:  * [[HasInstance]] internal method for Function objects: fetch the .prototype
    1:  * property of its 'this' parameter, and walks the prototype chain of v (only
    1:  * if v is an object) returning true if .prototype is found.
    1:  */
    1: static JSBool
    1: fun_hasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     jsval pval;
31823:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
31823:     if (!obj->getProperty(cx, id, &pval))
    1:         return JS_FALSE;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(pval)) {
    1:         /*
    1:          * Throw a runtime error if instanceof is called on a function that
    1:          * has a non-object as its .prototype value.
    1:          */
    1:         js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE,
    1:                             -1, OBJECT_TO_JSVAL(obj), NULL);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return js_IsDelegate(cx, JSVAL_TO_OBJECT(pval), v, bp);
    1: }
    1: 
  583: static void
13824: TraceLocalNames(JSTracer *trc, JSFunction *fun);
13824: 
13824: static void
13824: DestroyLocalNames(JSContext *cx, JSFunction *fun);
13824: 
13824: static void
  583: fun_trace(JSTracer *trc, JSObject *obj)
    1: {
13691:     /* A newborn function object may have a not yet initialized private slot. */
31452:     JSFunction *fun = (JSFunction *) obj->getPrivate();
13824:     if (!fun)
13824:         return;
13824: 
13824:     if (FUN_OBJECT(fun) != obj) {
13824:         /* obj is cloned function object, trace the original. */
13824:         JS_CALL_TRACER(trc, FUN_OBJECT(fun), JSTRACE_OBJECT, "private");
13824:         return;
13824:     }
  254:     if (fun->atom)
13824:         JS_CALL_STRING_TRACER(trc, ATOM_TO_STRING(fun->atom), "atom");
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
  583:             js_TraceScript(trc, fun->u.i.script);
13824:         TraceLocalNames(trc, fun);
13824:     }
13824: }
13824: 
13824: static void
13824: fun_finalize(JSContext *cx, JSObject *obj)
13824: {
13824:     /* Ignore newborn and cloned function objects. */
31823:     JSFunction *fun = (JSFunction *) obj->getPrivate();
13824:     if (!fun || FUN_OBJECT(fun) != obj)
13824:         return;
13824: 
13824:     /*
13824:      * Null-check of u.i.script is required since the parser sets interpreted
13824:      * very early.
13824:      */
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
13824:             js_DestroyScript(cx, fun->u.i.script);
13824:         DestroyLocalNames(cx, fun);
  254:     }
    1: }
    1: 
32729: int
32729: JSFunction::sharpSlotBase(JSContext *cx)
32729: {
32729: #if JS_HAS_SHARP_VARS
32729:     JSAtom *name = js_Atomize(cx, "#array", 6, 0);
32729:     if (name) {
32771:         uintN index = uintN(-1);
32757: #ifdef DEBUG
32757:         JSLocalKind kind =
32757: #endif
32757:             js_LookupLocal(cx, this, name, &index);
32757:         JS_ASSERT(kind == JSLOCAL_VAR);
32729:         return int(index);
32729:     }
32729: #endif
32729:     return -1;
32729: }
32729: 
30732: uint32
30737: JSFunction::countInterpretedReservedSlots() const
30732: {
30732:     JS_ASSERT(FUN_INTERPRETED(this));
30732: 
37029:     return (u.i.nupvars == 0) ? 0 : u.i.script->upvars()->length;
30732: }
30732: 
    1: static uint32
    1: fun_reserveSlots(JSContext *cx, JSObject *obj)
    1: {
 8179:     /*
31452:      * We use getPrivate and not GET_FUNCTION_PRIVATE because during
13691:      * js_InitFunctionClass invocation the function is called before the
13691:      * private slot of the function object is set.
 8179:      */
31452:     JSFunction *fun = (JSFunction *) obj->getPrivate();
30732:     return (fun && FUN_INTERPRETED(fun))
30737:            ? fun->countInterpretedReservedSlots()
30732:            : 0;
    1: }
    1: 
    1: /*
    1:  * Reserve two slots in all function objects for XPConnect.  Note that this
    1:  * does not bloat every instance, only those on which reserved slots are set,
    1:  * and those on which ad-hoc properties are defined.
    1:  */
    1: JS_FRIEND_DATA(JSClass) js_FunctionClass = {
    1:     js_Function_str,
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(2) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Function),
    1:     JS_PropertyStub,  JS_PropertyStub,
18830:     JS_PropertyStub,  JS_PropertyStub,
34318:     JS_EnumerateStub, (JSResolveOp)fun_resolve,
  254:     fun_convert,      fun_finalize,
    1:     NULL,             NULL,
    1:     NULL,             NULL,
28093:     js_XDRFunctionObject, fun_hasInstance,
  583:     JS_CLASS_TRACE(fun_trace), fun_reserveSlots
    1: };
    1: 
 4127: static JSBool
 4127: fun_toStringHelper(JSContext *cx, uint32 indent, uintN argc, jsval *vp)
    1: {
    1:     jsval fval;
 4127:     JSObject *obj;
    1:     JSFunction *fun;
    1:     JSString *str;
    1: 
11809:     fval = JS_THIS(cx, vp);
11809:     if (JSVAL_IS_NULL(fval))
11809:         return JS_FALSE;
11809: 
    1:     if (!VALUE_IS_FUNCTION(cx, fval)) {
    1:         /*
 4127:          * If we don't have a function to start off with, try converting the
 4127:          * object to a function. If that doesn't work, complain.
    1:          */
 4127:         if (!JSVAL_IS_PRIMITIVE(fval)) {
    1:             obj = JSVAL_TO_OBJECT(fval);
    1:             if (!OBJ_GET_CLASS(cx, obj)->convert(cx, obj, JSTYPE_FUNCTION,
    1:                                                  &fval)) {
    1:                 return JS_FALSE;
    1:             }
 4127:             vp[1] = fval;
    1:         }
    1:         if (!VALUE_IS_FUNCTION(cx, fval)) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_INCOMPATIBLE_PROTO,
    1:                                  js_Function_str, js_toString_str,
 4127:                                  JS_GetTypeName(cx, JS_TypeOfValue(cx, fval)));
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     obj = JSVAL_TO_OBJECT(fval);
12681:     if (argc != 0) {
12681:         indent = js_ValueToECMAUint32(cx, &vp[2]);
12694:         if (JSVAL_IS_NULL(vp[2]))
 4127:             return JS_FALSE;
    1:     }
    1: 
 4127:     JS_ASSERT(JS_ObjectIsFunction(cx, obj));
13691:     fun = GET_FUNCTION_PRIVATE(cx, obj);
    1:     if (!fun)
    1:         return JS_TRUE;
    1:     str = JS_DecompileFunction(cx, fun, (uintN)indent);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: fun_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return fun_toStringHelper(cx, 0, argc,  vp);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
 4127: fun_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return fun_toStringHelper(cx, JS_DONT_PRETTY_PRINT, argc, vp);
    1: }
    1: #endif
    1: 
29887: JSBool
21462: js_fun_call(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 6040:     jsval fval, *argv, *invokevp;
    1:     JSString *str;
    1:     void *mark;
    1:     JSBool ok;
    1: 
37741:     LeaveTrace(cx);
29887: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->defaultValue(cx, JSTYPE_FUNCTION, &vp[1]))
    1:         return JS_FALSE;
 4127:     fval = vp[1];
    1: 
38638:     if (!js_IsCallable(fval)) {
    1:         str = JS_ValueToString(cx, fval);
    1:         if (str) {
    1:             const char *bytes = js_GetStringBytes(cx, str);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
21473:                                      js_Function_str, js_call_str,
    1:                                      bytes);
    1:             }
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
 4127:     argv = vp + 2;
    1:     if (argc == 0) {
    1:         /* Call fun with its global object as the 'this' param if no args. */
    1:         obj = NULL;
    1:     } else {
    1:         /* Otherwise convert the first arg to 'this' and skip over it. */
    1:         if (!JSVAL_IS_PRIMITIVE(argv[0]))
    1:             obj = JSVAL_TO_OBJECT(argv[0]);
    1:         else if (!js_ValueToObject(cx, argv[0], &obj))
    1:             return JS_FALSE;
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
 6040:     invokevp = js_AllocStack(cx, 2 + argc, &mark);
 6040:     if (!invokevp)
    1:         return JS_FALSE;
    1: 
    1:     /* Push fval, obj, and the args. */
 6040:     invokevp[0] = fval;
 6040:     invokevp[1] = OBJECT_TO_JSVAL(obj);
 6040:     memcpy(invokevp + 2, argv, argc * sizeof *argv);
    1: 
14721:     ok = js_Invoke(cx, argc, invokevp, 0);
 6040:     *vp = *invokevp;
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: 
29887: JSBool
18712: js_fun_apply(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj, *aobj;
 6040:     jsval fval, *invokevp, *sp;
    1:     JSString *str;
    1:     jsuint length;
    1:     JSBool arraylike, ok;
    1:     void *mark;
    1:     uintN i;
    1: 
    1:     if (argc == 0) {
    1:         /* Will get globalObject as 'this' and no other arguments. */
21462:         return js_fun_call(cx, argc, vp);
    1:     }
    1: 
37741:     LeaveTrace(cx);
29887: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->defaultValue(cx, JSTYPE_FUNCTION, &vp[1]))
    1:         return JS_FALSE;
 4127:     fval = vp[1];
    1: 
38638:     if (!js_IsCallable(fval)) {
    1:         str = JS_ValueToString(cx, fval);
    1:         if (str) {
    1:             const char *bytes = js_GetStringBytes(cx, str);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
21473:                                      js_Function_str, js_apply_str,
    1:                                      bytes);
    1:             }
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Quell GCC overwarnings. */
    1:     aobj = NULL;
    1:     length = 0;
    1: 
    1:     if (argc >= 2) {
    1:         /* If the 2nd arg is null or void, call the function with 0 args. */
 4127:         if (JSVAL_IS_NULL(vp[3]) || JSVAL_IS_VOID(vp[3])) {
    1:             argc = 0;
    1:         } else {
    1:             /* The second arg must be an array (or arguments object). */
    1:             arraylike = JS_FALSE;
 4127:             if (!JSVAL_IS_PRIMITIVE(vp[3])) {
 4127:                 aobj = JSVAL_TO_OBJECT(vp[3]);
    1:                 if (!js_IsArrayLike(cx, aobj, &arraylike, &length))
    1:                     return JS_FALSE;
    1:             }
    1:             if (!arraylike) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
21473:                                      JSMSG_BAD_APPLY_ARGS, js_apply_str);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Convert the first arg to 'this' and skip over it. */
 4127:     if (!JSVAL_IS_PRIMITIVE(vp[2]))
 4127:         obj = JSVAL_TO_OBJECT(vp[2]);
 4127:     else if (!js_ValueToObject(cx, vp[2], &obj))
    1:         return JS_FALSE;
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
31823:     argc = (uintN)JS_MIN(length, JS_ARGS_LENGTH_MAX);
 6040:     invokevp = js_AllocStack(cx, 2 + argc, &mark);
 6040:     if (!invokevp)
    1:         return JS_FALSE;
    1: 
    1:     /* Push fval, obj, and aobj's elements as args. */
 6040:     sp = invokevp;
    1:     *sp++ = fval;
    1:     *sp++ = OBJECT_TO_JSVAL(obj);
    1:     for (i = 0; i < argc; i++) {
    1:         ok = JS_GetElement(cx, aobj, (jsint)i, sp);
    1:         if (!ok)
    1:             goto out;
    1:         sp++;
    1:     }
    1: 
14721:     ok = js_Invoke(cx, argc, invokevp, 0);
 6040:     *vp = *invokevp;
    1: out:
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: 
    1: #ifdef NARCISSUS
24499: static JS_REQUIRES_STACK JSBool
 4127: fun_applyConstructor(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSObject *aobj;
    1:     uintN length, i;
    1:     void *mark;
 6040:     jsval *invokevp, *sp;
    1:     JSBool ok;
    1: 
 4127:     if (JSVAL_IS_PRIMITIVE(vp[2]) ||
 4127:         (aobj = JSVAL_TO_OBJECT(vp[2]),
    1:          OBJ_GET_CLASS(cx, aobj) != &js_ArrayClass &&
    1:          OBJ_GET_CLASS(cx, aobj) != &js_ArgumentsClass)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_APPLY_ARGS, "__applyConstruct__");
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if (!js_GetLengthProperty(cx, aobj, &length))
    1:         return JS_FALSE;
    1: 
31823:     if (length > JS_ARGS_LENGTH_MAX)
31823:         length = JS_ARGS_LENGTH_MAX;
 6040:     invokevp = js_AllocStack(cx, 2 + length, &mark);
 6040:     if (!invokevp)
    1:         return JS_FALSE;
    1: 
 6040:     sp = invokevp;
 4127:     *sp++ = vp[1];
11809:     *sp++ = JSVAL_NULL; /* this is filled automagically */
    1:     for (i = 0; i < length; i++) {
    1:         ok = JS_GetElement(cx, aobj, (jsint)i, sp);
    1:         if (!ok)
    1:             goto out;
    1:         sp++;
    1:     }
    1: 
19577:     ok = js_InvokeConstructor(cx, length, JS_TRUE, invokevp);
 6040:     *vp = *invokevp;
    1: out:
    1:     js_FreeStack(cx, mark);
    1:     return ok;
    1: }
    1: #endif
    1: 
    1: static JSFunctionSpec function_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,   fun_toSource,   0,0),
    1: #endif
16519:     JS_FN(js_toString_str,   fun_toString,   0,0),
21473:     JS_FN(js_apply_str,      js_fun_apply,   2,0),
21473:     JS_FN(js_call_str,       js_fun_call,    1,0),
    1: #ifdef NARCISSUS
21471:     JS_FN("__applyConstructor__", fun_applyConstructor, 1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
    1: Function(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSFunction *fun;
    1:     JSObject *parent;
22652:     JSStackFrame *fp, *caller;
 8179:     uintN i, n, lineno;
    1:     JSAtom *atom;
    1:     const char *filename;
 8179:     JSBool ok;
    1:     JSString *str, *arg;
31925:     JSTokenStream ts(cx);
    1:     JSPrincipals *principals;
    1:     jschar *collected_args, *cp;
 6561:     void *mark;
    1:     size_t arg_length, args_length, old_args_length;
    1:     JSTokenType tt;
    1: 
22652:     if (!JS_IsConstructing(cx)) {
30439:         obj = js_NewObject(cx, &js_FunctionClass, NULL, NULL);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *rval = OBJECT_TO_JSVAL(obj);
13824:     } else {
13824:         /*
13824:          * The constructor is called before the private slot is initialized so
31452:          * we must use getPrivate, not GET_FUNCTION_PRIVATE here.
13824:          */
31452:         if (obj->getPrivate())
13482:             return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * NB: (new Function) is not lexically closed by its caller, it's just an
    1:      * anonymous function in the top-level scope that its constructor inhabits.
    1:      * Thus 'var x = 42; f = new Function("return x"); print(f())' prints 42,
    1:      * and so would a call to f from another top-level's script or function.
    1:      *
    1:      * In older versions, before call objects, a new Function was adopted by
    1:      * its running context's globalObject, which might be different from the
    1:      * top-level reachable from scopeChain (in HTML frames, e.g.).
    1:      */
39930:     parent = JSVAL_TO_OBJECT(argv[-2])->getParent();
    1: 
13702:     fun = js_NewFunction(cx, obj, NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
13702:                          parent, cx->runtime->atomState.anonymousAtom);
    1: 
    1:     if (!fun)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Function is static and not called directly by other functions in this
    1:      * file, therefore it is callable only as a native function by js_Invoke.
    1:      * Find the scripted caller, possibly skipping other native frames such as
    1:      * are built for Function.prototype.call or .apply activations that invoke
    1:      * Function indirectly from a script.
    1:      */
22652:     fp = js_GetTopStackFrame(cx);
    1:     JS_ASSERT(!fp->script && fp->fun && fp->fun->u.n.native == Function);
22652:     caller = js_GetScriptedCaller(cx, fp);
    1:     if (caller) {
    1:         principals = JS_EvalFramePrincipals(cx, fp, caller);
12690:         filename = js_ComputeFilename(cx, caller, principals, &lineno);
    1:     } else {
    1:         filename = NULL;
    1:         lineno = 0;
    1:         principals = NULL;
    1:     }
    1: 
    1:     /* Belt-and-braces: check that the caller has access to parent. */
    1:     if (!js_CheckPrincipalsAccess(cx, parent, principals,
    1:                                   CLASS_ATOM(cx, Function))) {
    1:         return JS_FALSE;
    1:     }
    1: 
39061:     /*
39061:      * CSP check: whether new Function() is allowed at all.
39061:      * Report errors via CSP is done in the script security manager.
39061:      * js_CheckContentSecurityPolicy is defined in jsobj.cpp
39061:      */
39061:     if (!js_CheckContentSecurityPolicy(cx)) {
39061:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, 
39061:                              JSMSG_CSP_BLOCKED_FUNCTION);
39061:         return JS_FALSE;
39061:     }
39061: 
    1:     n = argc ? argc - 1 : 0;
    1:     if (n > 0) {
 6561:         enum { OK, BAD, BAD_FORMAL } state;
 6561: 
    1:         /*
    1:          * Collect the function-argument arguments into one string, separated
    1:          * by commas, then make a tokenstream from that string, and scan it to
    1:          * get the arguments.  We need to throw the full scanner at the
    1:          * problem, because the argument string can legitimately contain
    1:          * comments and linefeeds.  XXX It might be better to concatenate
    1:          * everything up into a function definition and pass it to the
    1:          * compiler, but doing it this way is less of a delta from the old
    1:          * code.  See ECMA 15.3.2.1.
    1:          */
 6561:         state = BAD_FORMAL;
    1:         args_length = 0;
    1:         for (i = 0; i < n; i++) {
    1:             /* Collect the lengths for all the function-argument arguments. */
    1:             arg = js_ValueToString(cx, argv[i]);
    1:             if (!arg)
    1:                 return JS_FALSE;
    1:             argv[i] = STRING_TO_JSVAL(arg);
    1: 
    1:             /*
    1:              * Check for overflow.  The < test works because the maximum
    1:              * JSString length fits in 2 fewer bits than size_t has.
    1:              */
    1:             old_args_length = args_length;
29366:             args_length = old_args_length + arg->length();
    1:             if (args_length < old_args_length) {
12983:                 js_ReportAllocationOverflow(cx);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         /* Add 1 for each joining comma and check for overflow (two ways). */
    1:         old_args_length = args_length;
    1:         args_length = old_args_length + n - 1;
    1:         if (args_length < old_args_length ||
    1:             args_length >= ~(size_t)0 / sizeof(jschar)) {
12983:             js_ReportAllocationOverflow(cx);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Allocate a string to hold the concatenated arguments, including room
    1:          * for a terminating 0.  Mark cx->tempPool for later release, to free
    1:          * collected_args and its tokenstream in one swoop.
    1:          */
    1:         mark = JS_ARENA_MARK(&cx->tempPool);
    1:         JS_ARENA_ALLOCATE_CAST(cp, jschar *, &cx->tempPool,
    1:                                (args_length+1) * sizeof(jschar));
    1:         if (!cp) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return JS_FALSE;
    1:         }
    1:         collected_args = cp;
    1: 
    1:         /*
    1:          * Concatenate the arguments into the new string, separated by commas.
    1:          */
    1:         for (i = 0; i < n; i++) {
    1:             arg = JSVAL_TO_STRING(argv[i]);
29366:             arg_length = arg->length();
29366:             (void) js_strncpy(cp, arg->chars(), arg_length);
    1:             cp += arg_length;
    1: 
    1:             /* Add separating comma or terminating 0. */
    1:             *cp++ = (i + 1 < n) ? ',' : 0;
    1:         }
    1: 
 6561:         /* Initialize a tokenstream that reads from the given string. */
40270:         if (!ts.init(collected_args, args_length, NULL, filename, lineno)) {
    1:             JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* The argument string may be empty or contain no tokens. */
 8444:         tt = js_GetToken(cx, &ts);
    1:         if (tt != TOK_EOF) {
    1:             for (;;) {
    1:                 /*
    1:                  * Check that it's a name.  This also implicitly guards against
    1:                  * TOK_ERROR, which was already reported.
    1:                  */
    1:                 if (tt != TOK_NAME)
 6561:                     goto after_args;
    1: 
    1:                 /*
 8444:                  * Get the atom corresponding to the name from the token
 8444:                  * stream; we're assured at this point that it's a valid
 8444:                  * identifier.
    1:                  */
40270:                 atom = ts.currentToken().t_atom;
    1: 
 8179:                 /* Check for a duplicate parameter name. */
13691:                 if (js_LookupLocal(cx, fun, atom, NULL) != JSLOCAL_NONE) {
 8179:                     const char *name;
 8179: 
 8179:                     name = js_AtomToPrintableString(cx, atom);
    1:                     ok = name &&
 8444:                          js_ReportCompileErrorNumber(cx, &ts, NULL,
    1:                                                      JSREPORT_WARNING |
    1:                                                      JSREPORT_STRICT,
    1:                                                      JSMSG_DUPLICATE_FORMAL,
    1:                                                      name);
 3624:                     if (!ok)
 6561:                         goto after_args;
    1:                 }
13691:                 if (!js_AddLocal(cx, fun, atom, JSLOCAL_ARG))
 6561:                     goto after_args;
    1: 
    1:                 /*
    1:                  * Get the next token.  Stop on end of stream.  Otherwise
    1:                  * insist on a comma, get another name, and iterate.
    1:                  */
 8444:                 tt = js_GetToken(cx, &ts);
    1:                 if (tt == TOK_EOF)
    1:                     break;
    1:                 if (tt != TOK_COMMA)
 6561:                     goto after_args;
 8444:                 tt = js_GetToken(cx, &ts);
    1:             }
    1:         }
    1: 
 6561:         state = OK;
 6561:       after_args:
 8444:         if (state == BAD_FORMAL && !(ts.flags & TSF_ERROR)) {
 6561:             /*
 6561:              * Report "malformed formal parameter" iff no illegal char or
 6561:              * similar scanner error was already reported.
 6561:              */
 6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 6561:                                  JSMSG_BAD_FORMAL);
 6561:         }
40270:         ts.close();
    1:         JS_ARENA_RELEASE(&cx->tempPool, mark);
 6561:         if (state != OK)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (argc) {
    1:         str = js_ValueToString(cx, argv[argc-1]);
    1:         if (!str)
    1:             return JS_FALSE;
 4076:         argv[argc-1] = STRING_TO_JSVAL(str);
 4076:     } else {
 4076:         str = cx->runtime->emptyString;
    1:     }
    1: 
27012:     return JSCompiler::compileFunctionBody(cx, fun, principals,
29366:                                            str->chars(), str->length(),
 8444:                                            filename, lineno);
    1: }
    1: 
    1: JSObject *
    1: js_InitFunctionClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
    1:     JSFunction *fun;
    1: 
    1:     proto = JS_InitClass(cx, obj, NULL, &js_FunctionClass, Function, 1,
    1:                          function_props, function_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
13702:     fun = js_NewFunction(cx, proto, NULL, 0, JSFUN_INTERPRETED, obj, NULL);
    1:     if (!fun)
33178:         return NULL;
34290:     fun->u.i.script = JSScript::emptyScript();
    1:     return proto;
    1: }
    1: 
    1: JSFunction *
    1: js_NewFunction(JSContext *cx, JSObject *funobj, JSNative native, uintN nargs,
    1:                uintN flags, JSObject *parent, JSAtom *atom)
    1: {
    1:     JSFunction *fun;
    1: 
    1:     if (funobj) {
13824:         JS_ASSERT(HAS_FUNCTION_CLASS(funobj));
39930:         funobj->setParent(parent);
    1:     } else {
30439:         funobj = js_NewObject(cx, &js_FunctionClass, NULL, parent);
    1:         if (!funobj)
    1:             return NULL;
    1:     }
31452:     JS_ASSERT(!funobj->getPrivate());
13824:     fun = (JSFunction *) funobj;
    1: 
    1:     /* Initialize all function members. */
39928:     fun->nargs = uint16(nargs);
32669:     fun->flags = flags & (JSFUN_FLAGS_MASK | JSFUN_KINDMASK | JSFUN_TRCINFO);
27012:     if ((flags & JSFUN_KINDMASK) >= JSFUN_INTERPRETED) {
13702:         JS_ASSERT(!native);
13702:         JS_ASSERT(nargs == 0);
13702:         fun->u.i.nvars = 0;
18308:         fun->u.i.nupvars = 0;
28952:         fun->u.i.skipmin = 0;
28952:         fun->u.i.wrapper = false;
13702:         fun->u.i.script = NULL;
13482: #ifdef DEBUG
13702:         fun->u.i.names.taggedAtom = 0;
13482: #endif
13702:     } else {
    1:         fun->u.n.extra = 0;
16519:         fun->u.n.spare = 0;
25887:         fun->u.n.clasp = NULL;
32669:         if (flags & JSFUN_TRCINFO) {
20408: #ifdef JS_TRACER
32669:             JSNativeTraceInfo *trcinfo =
32669:                 JS_FUNC_TO_DATA_PTR(JSNativeTraceInfo *, native);
20408:             fun->u.n.native = (JSNative) trcinfo->native;
25887:             fun->u.n.trcinfo = trcinfo;
20408: #else
25887:             fun->u.n.trcinfo = NULL;
20408: #endif
20408:         } else {
20408:             fun->u.n.native = native;
25887:             fun->u.n.trcinfo = NULL;
20408:         }
28086:         JS_ASSERT(fun->u.n.native);
13702:     }
    1:     fun->atom = atom;
    1: 
13824:     /* Set private to self to indicate non-cloned fully initialized function. */
31452:     FUN_OBJECT(fun)->setPrivate(fun);
    1:     return fun;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
38604: js_CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent,
38604:                        JSObject *proto)
    1: {
38604:     JS_ASSERT(parent);
38604:     JS_ASSERT(proto);
38604: 
13482:     /*
27012:      * The cloned function object does not need the extra JSFunction members
27012:      * beyond JSObject as it points to fun via the private slot.
13482:      */
38604:     JSObject *clone = js_NewObjectWithGivenProto(cx, &js_FunctionClass, proto,
38604:                                                  parent, sizeof(JSObject));
13824:     if (!clone)
    1:         return NULL;
31452:     clone->setPrivate(fun);
13824:     return clone;
    1: }
    1: 
38604: #ifdef JS_TRACER
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CloneFunctionObject, CONTEXT, FUNCTION, OBJECT, OBJECT, 0,
39910:                      nanojit::ACC_STORE_ANY)
38604: #endif
37694: 
28923: /*
28923:  * Create a new flat closure, but don't initialize the imported upvar
28923:  * values. The tracer calls this function and then initializes the upvar
28923:  * slots on trace.
28923:  */
28923: JSObject * JS_FASTCALL
28923: js_AllocFlatClosure(JSContext *cx, JSFunction *fun, JSObject *scopeChain)
27012: {
27012:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28994:     JS_ASSERT((fun->u.i.script->upvarsOffset
32723:                ? fun->u.i.script->upvars()->length
28994:                : 0) == fun->u.i.nupvars);
27012: 
38604:     JSObject *closure = CloneFunctionObject(cx, fun, scopeChain);
31073:     if (!closure)
27012:         return closure;
31073: 
31073:     uint32 nslots = fun->countInterpretedReservedSlots();
31073:     if (!nslots)
31073:         return closure;
31073:     if (!js_EnsureReservedSlots(cx, closure, nslots))
27012:         return NULL;
27012: 
28923:     return closure;
28923: }
28923: 
28923: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_AllocFlatClosure,
39910:                      CONTEXT, FUNCTION, OBJECT, 0, nanojit::ACC_STORE_ANY)
28923: 
38563: JS_REQUIRES_STACK JSObject *
28923: js_NewFlatClosure(JSContext *cx, JSFunction *fun)
28923: {
38563:     /*
38563:      * Flat closures can be partial, they may need to search enclosing scope
38563:      * objects via JSOP_NAME, etc.
38563:      */
38563:     JSObject *scopeChain = js_GetScopeChain(cx, cx->fp);
38563:     if (!scopeChain)
38563:         return NULL;
38563: 
38563:     JSObject *closure = js_AllocFlatClosure(cx, fun, scopeChain);
28994:     if (!closure || fun->u.i.nupvars == 0)
28994:         return closure;
28923: 
32723:     JSUpvarArray *uva = fun->u.i.script->upvars();
27012:     JS_ASSERT(uva->length <= size_t(closure->dslots[-1]));
27012: 
27168:     uintN level = fun->u.i.script->staticLevel;
27168:     for (uint32 i = 0, n = uva->length; i < n; i++)
27168:         closure->dslots[i] = js_GetUpvar(cx, level, uva->vector[i]);
27012: 
27012:     return closure;
27012: }
27012: 
28952: JSObject *
28952: js_NewDebuggableFlatClosure(JSContext *cx, JSFunction *fun)
28952: {
28952:     JS_ASSERT(cx->fp->fun->flags & JSFUN_HEAVYWEIGHT);
29009:     JS_ASSERT(!cx->fp->fun->optimizedClosure());
39916:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28952: 
28952:     return WrapEscapingClosure(cx, cx->fp, FUN_OBJECT(fun), fun);
28952: }
28952: 
    1: JSFunction *
    1: js_DefineFunction(JSContext *cx, JSObject *obj, JSAtom *atom, JSNative native,
    1:                   uintN nargs, uintN attrs)
    1: {
27012:     JSPropertyOp gsop;
26970:     JSFunction *fun;
    1: 
27012:     if (attrs & JSFUN_STUB_GSOPS) {
27012:         /*
27012:          * JSFUN_STUB_GSOPS is a request flag only, not stored in fun->flags or
27012:          * the defined property's attributes. This allows us to encode another,
27012:          * internal flag using the same bit, JSFUN_EXPR_CLOSURE -- see jsfun.h
27012:          * for more on this.
27012:          */
27012:         attrs &= ~JSFUN_STUB_GSOPS;
27012:         gsop = JS_PropertyStub;
27012:     } else {
27012:         gsop = NULL;
27012:     }
    1:     fun = js_NewFunction(cx, NULL, native, nargs, attrs, obj, atom);
    1:     if (!fun)
    1:         return NULL;
32573:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), OBJECT_TO_JSVAL(FUN_OBJECT(fun)),
32573:                              gsop, gsop, attrs & ~JSFUN_FLAGS_MASK)) {
    1:         return NULL;
    1:     }
    1:     return fun;
    1: }
    1: 
    1: #if (JSV2F_CONSTRUCT & JSV2F_SEARCH_STACK)
    1: # error "JSINVOKE_CONSTRUCT and JSV2F_SEARCH_STACK are not disjoint!"
    1: #endif
    1: 
    1: JSFunction *
    1: js_ValueToFunction(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     jsval v;
    1:     JSObject *obj;
    1: 
    1:     v = *vp;
    1:     obj = NULL;
    1:     if (JSVAL_IS_OBJECT(v)) {
    1:         obj = JSVAL_TO_OBJECT(v);
    1:         if (obj && OBJ_GET_CLASS(cx, obj) != &js_FunctionClass) {
31501:             if (!obj->defaultValue(cx, JSTYPE_FUNCTION, &v))
    1:                 return NULL;
    1:             obj = VALUE_IS_FUNCTION(cx, v) ? JSVAL_TO_OBJECT(v) : NULL;
    1:         }
    1:     }
    1:     if (!obj) {
    1:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
13691:     return GET_FUNCTION_PRIVATE(cx, obj);
    1: }
    1: 
    1: JSObject *
    1: js_ValueToFunctionObject(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     JSFunction *fun;
    1:     JSStackFrame *caller;
    1:     JSPrincipals *principals;
    1: 
    1:     if (VALUE_IS_FUNCTION(cx, *vp))
    1:         return JSVAL_TO_OBJECT(*vp);
    1: 
    1:     fun = js_ValueToFunction(cx, vp, flags);
    1:     if (!fun)
    1:         return NULL;
13824:     *vp = OBJECT_TO_JSVAL(FUN_OBJECT(fun));
    1: 
22652:     caller = js_GetScriptedCaller(cx, NULL);
    1:     if (caller) {
11126:         principals = JS_StackFramePrincipals(cx, caller);
    1:     } else {
    1:         /* No scripted caller, don't allow access. */
    1:         principals = NULL;
    1:     }
    1: 
13824:     if (!js_CheckPrincipalsAccess(cx, FUN_OBJECT(fun), principals,
    1:                                   fun->atom
    1:                                   ? fun->atom
    1:                                   : cx->runtime->atomState.anonymousAtom)) {
    1:         return NULL;
    1:     }
13824:     return FUN_OBJECT(fun);
    1: }
    1: 
    1: JSObject *
    1: js_ValueToCallableObject(JSContext *cx, jsval *vp, uintN flags)
    1: {
26059:     JSObject *callable = JSVAL_IS_OBJECT(*vp) ? JSVAL_TO_OBJECT(*vp) : NULL;
    1: 
38638:     if (callable && callable->isCallable()) {
    1:         *vp = OBJECT_TO_JSVAL(callable);
26059:         return callable;
    1:     }
26059:     return js_ValueToFunctionObject(cx, vp, flags);
    1: }
    1: 
    1: void
    1: js_ReportIsNotFunction(JSContext *cx, jsval *vp, uintN flags)
    1: {
    1:     JSStackFrame *fp;
    1:     uintN error;
    1:     const char *name, *source;
    1: 
22652:     for (fp = js_GetTopStackFrame(cx); fp && !fp->regs; fp = fp->down)
    1:         continue;
14218:     name = source = NULL;
40221: 
40221:     AutoValueRooter tvr(cx);
    1:     if (flags & JSV2F_ITERATOR) {
    1:         error = JSMSG_BAD_ITERATOR;
    1:         name = js_iterator_str;
32694:         JSString *src = js_ValueToSource(cx, *vp);
32694:         if (!src)
40221:             return;
40221:         tvr.setString(src);
32694:         JSString *qsrc = js_QuoteString(cx, src, 0);
32694:         if (!qsrc)
40221:             return;
40221:         tvr.setString(qsrc);
32694:         source = js_GetStringBytes(cx, qsrc);
    1:         if (!source)
40221:             return;
    1:     } else if (flags & JSV2F_CONSTRUCT) {
    1:         error = JSMSG_NOT_CONSTRUCTOR;
    1:     } else {
    1:         error = JSMSG_NOT_FUNCTION;
    1:     }
    1: 
    1:     js_ReportValueError3(cx, error,
13168:                          (fp && fp->regs &&
16072:                           StackBase(fp) <= vp && vp < fp->regs->sp)
13168:                          ? vp - fp->regs->sp
    1:                          : (flags & JSV2F_SEARCH_STACK)
    1:                          ? JSDVG_SEARCH_STACK
    1:                          : JSDVG_IGNORE_STACK,
    1:                          *vp, NULL,
    1:                          name, source);
    1: }
 8179: 
 8367: /*
 8367:  * When a function has between 2 and MAX_ARRAY_LOCALS arguments and variables,
 8367:  * their name are stored as the JSLocalNames.array.
 8367:  */
 8367: #define MAX_ARRAY_LOCALS 8
 8367: 
 8367: JS_STATIC_ASSERT(2 <= MAX_ARRAY_LOCALS);
 8367: JS_STATIC_ASSERT(MAX_ARRAY_LOCALS < JS_BITMASK(16));
 8367: 
 8367: /*
 8367:  * We use the lowest bit of the string atom to distinguish const from var
 8367:  * name when there is only single name or when names are stored as an array.
 8367:  */
 8367: JS_STATIC_ASSERT((JSVAL_STRING & 1) == 0);
 8367: 
 8367: /*
 8367:  * When we use a hash table to store the local names, we use a singly linked
 8367:  * list to record the indexes of duplicated parameter names to preserve the
 8367:  * duplicates for the decompiler.
 8367:  */
 8367: typedef struct JSNameIndexPair JSNameIndexPair;
 8367: 
 8367: struct JSNameIndexPair {
 8367:     JSAtom          *name;
 8367:     uint16          index;
 8367:     JSNameIndexPair *link;
 8367: };
 8367: 
 8367: struct JSLocalNameMap {
 8367:     JSDHashTable    names;
 8367:     JSNameIndexPair *lastdup;
 8367: };
 8367: 
 8367: typedef struct JSLocalNameHashEntry {
 8367:     JSDHashEntryHdr hdr;
 8367:     JSAtom          *name;
 8367:     uint16          index;
 8367:     uint8           localKind;
 8367: } JSLocalNameHashEntry;
 8367: 
 8367: static void
 8367: FreeLocalNameHash(JSContext *cx, JSLocalNameMap *map)
 8367: {
 8367:     JSNameIndexPair *dup, *next;
 8367: 
 8367:     for (dup = map->lastdup; dup; dup = next) {
 8367:         next = dup->link;
30851:         cx->free(dup);
 8367:     }
 8367:     JS_DHashTableFinish(&map->names);
30851:     cx->free(map);
 8367: }
 8367: 
 8367: static JSBool
 8367: HashLocalName(JSContext *cx, JSLocalNameMap *map, JSAtom *name,
 8367:               JSLocalKind localKind, uintN index)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
 8367:     JSNameIndexPair *dup;
 8367: 
 8367:     JS_ASSERT(index <= JS_BITMASK(16));
 8367: #if JS_HAS_DESTRUCTURING
 8367:     if (!name) {
 8367:         /* A destructuring pattern does not need a hash entry. */
 8367:         JS_ASSERT(localKind == JSLOCAL_ARG);
 8367:         return JS_TRUE;
 8367:     }
 8367: #endif
 8367:     JS_ASSERT(ATOM_IS_STRING(name));
 8367:     entry = (JSLocalNameHashEntry *)
 8367:             JS_DHashTableOperate(&map->names, name, JS_DHASH_ADD);
 8367:     if (!entry) {
 8367:         JS_ReportOutOfMemory(cx);
 8367:         return JS_FALSE;
 8367:     }
 8367:     if (entry->name) {
 8367:         JS_ASSERT(entry->name == name);
35376:         JS_ASSERT(entry->localKind == JSLOCAL_ARG && localKind == JSLOCAL_ARG);
30851:         dup = (JSNameIndexPair *) cx->malloc(sizeof *dup);
 8367:         if (!dup)
 8367:             return JS_FALSE;
 8367:         dup->name = entry->name;
 8367:         dup->index = entry->index;
 8367:         dup->link = map->lastdup;
 8367:         map->lastdup = dup;
 8367:     }
 8367:     entry->name = name;
 8367:     entry->index = (uint16) index;
 8367:     entry->localKind = (uint8) localKind;
 8367:     return JS_TRUE;
 8367: }
 8367: 
 8179: JSBool
13702: js_AddLocal(JSContext *cx, JSFunction *fun, JSAtom *atom, JSLocalKind kind)
 8179: {
 8367:     jsuword taggedAtom;
 8179:     uint16 *indexp;
 8367:     uintN n, i;
 8367:     jsuword *array;
 8367:     JSLocalNameMap *map;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
13702:     JS_ASSERT(!fun->u.i.script);
 8367:     JS_ASSERT(((jsuword) atom & 1) == 0);
 8367:     taggedAtom = (jsuword) atom;
 8179:     if (kind == JSLOCAL_ARG) {
 8367:         indexp = &fun->nargs;
18308:     } else if (kind == JSLOCAL_UPVAR) {
18308:         indexp = &fun->u.i.nupvars;
 8367:     } else {
13702:         indexp = &fun->u.i.nvars;
 8367:         if (kind == JSLOCAL_CONST)
 8367:             taggedAtom |= 1;
 8367:         else
 8367:             JS_ASSERT(kind == JSLOCAL_VAR);
 8367:     }
28832:     n = fun->countLocalNames();
 8367:     if (n == 0) {
13702:         JS_ASSERT(fun->u.i.names.taggedAtom == 0);
13702:         fun->u.i.names.taggedAtom = taggedAtom;
 8367:     } else if (n < MAX_ARRAY_LOCALS) {
 8367:         if (n > 1) {
13702:             array = fun->u.i.names.array;
 8367:         } else {
30851:             array = (jsuword *) cx->malloc(MAX_ARRAY_LOCALS * sizeof *array);
 8367:             if (!array)
 8367:                 return JS_FALSE;
13702:             array[0] = fun->u.i.names.taggedAtom;
13702:             fun->u.i.names.array = array;
 8367:         }
 8367:         if (kind == JSLOCAL_ARG) {
 8367:             /*
 8367:              * A destructuring argument pattern adds variables, not arguments,
 8367:              * so for the following arguments nvars != 0.
 8367:              */
 8179: #if JS_HAS_DESTRUCTURING
13702:             if (fun->u.i.nvars != 0) {
 8367:                 memmove(array + fun->nargs + 1, array + fun->nargs,
13702:                         fun->u.i.nvars * sizeof *array);
 8179:             }
 8367: #else
13702:             JS_ASSERT(fun->u.i.nvars == 0);
 8179: #endif
 8367:             array[fun->nargs] = taggedAtom;
 8179:         } else {
 8367:             array[n] = taggedAtom;
 8367:         }
 8367:     } else if (n == MAX_ARRAY_LOCALS) {
13702:         array = fun->u.i.names.array;
30851:         map = (JSLocalNameMap *) cx->malloc(sizeof *map);
 8367:         if (!map)
 8367:             return JS_FALSE;
 8367:         if (!JS_DHashTableInit(&map->names, JS_DHashGetStubOps(),
 8367:                                NULL, sizeof(JSLocalNameHashEntry),
 8367:                                JS_DHASH_DEFAULT_CAPACITY(MAX_ARRAY_LOCALS
 8367:                                                          * 2))) {
 8367:             JS_ReportOutOfMemory(cx);
30851:             cx->free(map);
 8367:             return JS_FALSE;
 8179:         }
 8179: 
 8367:         map->lastdup = NULL;
 8367:         for (i = 0; i != MAX_ARRAY_LOCALS; ++i) {
 8367:             taggedAtom = array[i];
27012:             uintN j = i;
27012:             JSLocalKind k = JSLOCAL_ARG;
27012:             if (j >= fun->nargs) {
27012:                 j -= fun->nargs;
27012:                 if (j < fun->u.i.nvars) {
27012:                     k = (taggedAtom & 1) ? JSLOCAL_CONST : JSLOCAL_VAR;
27012:                 } else {
27012:                     j -= fun->u.i.nvars;
27012:                     k = JSLOCAL_UPVAR;
27012:                 }
27012:             }
27012:             if (!HashLocalName(cx, map, (JSAtom *) (taggedAtom & ~1), k, j)) {
 8367:                 FreeLocalNameHash(cx, map);
 8367:                 return JS_FALSE;
 8367:             }
 8367:         }
 8367:         if (!HashLocalName(cx, map, atom, kind, *indexp)) {
 8367:             FreeLocalNameHash(cx, map);
 8367:             return JS_FALSE;
 8367:         }
 8367: 
 8367:         /*
 8367:          * At this point the entry is added and we cannot fail. It is time
 8367:          * to replace fun->u.i.names with the built map.
 8367:          */
13702:         fun->u.i.names.map = map;
30851:         cx->free(array);
 8367:     } else {
 8179:         if (*indexp == JS_BITMASK(16)) {
 8179:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8179:                                  (kind == JSLOCAL_ARG)
 8179:                                  ? JSMSG_TOO_MANY_FUN_ARGS
16072:                                  : JSMSG_TOO_MANY_LOCALS);
 8179:             return JS_FALSE;
 8179:         }
13702:         if (!HashLocalName(cx, fun->u.i.names.map, atom, kind, *indexp))
 8179:             return JS_FALSE;
 8179:     }
 8179: 
 8367:     /* Update the argument or variable counter. */
 8179:     ++*indexp;
 8179:     return JS_TRUE;
 8179: }
 8179: 
 8179: JSLocalKind
13702: js_LookupLocal(JSContext *cx, JSFunction *fun, JSAtom *atom, uintN *indexp)
 8179: {
18308:     uintN n, i, upvar_base;
 8367:     jsuword *array;
 8367:     JSLocalNameHashEntry *entry;
 8179: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
28832:     n = fun->countLocalNames();
 8367:     if (n == 0)
 8367:         return JSLOCAL_NONE;
 8367:     if (n <= MAX_ARRAY_LOCALS) {
13702:         array = (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
 8179: 
 8367:         /* Search from the tail to pick up the last duplicated name. */
 8367:         i = n;
28832:         upvar_base = fun->countArgsAndVars();
 8367:         do {
 8367:             --i;
11435:             if (atom == JS_LOCAL_NAME_TO_ATOM(array[i])) {
 8367:                 if (i < fun->nargs) {
 8367:                     if (indexp)
 8367:                         *indexp = i;
 8367:                     return JSLOCAL_ARG;
 8179:                 }
18308:                 if (i >= upvar_base) {
18308:                     if (indexp)
18308:                         *indexp = i - upvar_base;
18308:                     return JSLOCAL_UPVAR;
18308:                 }
 8179:                 if (indexp)
 8367:                     *indexp = i - fun->nargs;
11435:                 return JS_LOCAL_NAME_IS_CONST(array[i])
11435:                        ? JSLOCAL_CONST
11435:                        : JSLOCAL_VAR;
 8179:             }
 8367:         } while (i != 0);
 8367:     } else {
 8367:         entry = (JSLocalNameHashEntry *)
13702:                 JS_DHashTableOperate(&fun->u.i.names.map->names, atom,
 8367:                                      JS_DHASH_LOOKUP);
 8367:         if (JS_DHASH_ENTRY_IS_BUSY(&entry->hdr)) {
 8367:             JS_ASSERT(entry->localKind != JSLOCAL_NONE);
 8367:             if (indexp)
 8367:                 *indexp = entry->index;
 8367:             return (JSLocalKind) entry->localKind;
 8179:         }
 8367:     }
 8367:     return JSLOCAL_NONE;
 8367: }
 8367: 
11435: typedef struct JSLocalNameEnumeratorArgs {
13702:     JSFunction      *fun;
11435:     jsuword         *names;
 8367: #ifdef DEBUG
 8367:     uintN           nCopiedArgs;
 8367:     uintN           nCopiedVars;
 8367: #endif
11435: } JSLocalNameEnumeratorArgs;
 8367: 
18907: static JSDHashOperator
 8367: get_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
 8367:                            uint32 number, void *arg)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
11435:     JSLocalNameEnumeratorArgs *args;
 8367:     uint i;
11435:     jsuword constFlag;
 8367: 
 8367:     entry = (JSLocalNameHashEntry *) hdr;
11435:     args = (JSLocalNameEnumeratorArgs *) arg;
 8367:     JS_ASSERT(entry->name);
 8367:     if (entry->localKind == JSLOCAL_ARG) {
 8367:         JS_ASSERT(entry->index < args->fun->nargs);
 8367:         JS_ASSERT(args->nCopiedArgs++ < args->fun->nargs);
 8367:         i = entry->index;
11435:         constFlag = 0;
 8367:     } else {
 8367:         JS_ASSERT(entry->localKind == JSLOCAL_VAR ||
27012:                   entry->localKind == JSLOCAL_CONST ||
27012:                   entry->localKind == JSLOCAL_UPVAR);
27012:         JS_ASSERT(entry->index < args->fun->u.i.nvars + args->fun->u.i.nupvars);
33166:         JS_ASSERT(args->nCopiedVars++ < unsigned(args->fun->u.i.nvars + args->fun->u.i.nupvars));
27012:         i = args->fun->nargs;
27012:         if (entry->localKind == JSLOCAL_UPVAR)
27012:            i += args->fun->u.i.nvars;
27012:         i += entry->index;
11435:         constFlag = (entry->localKind == JSLOCAL_CONST);
 8367:     }
11435:     args->names[i] = (jsuword) entry->name | constFlag;
 8367:     return JS_DHASH_NEXT;
 8179: }
 8179: 
34186: JS_FRIEND_API(jsuword *)
13702: js_GetLocalNameArray(JSContext *cx, JSFunction *fun, JSArenaPool *pool)
 8179: {
11435:     uintN n;
11435:     jsuword *names;
 8367:     JSLocalNameMap *map;
11435:     JSLocalNameEnumeratorArgs args;
 8367:     JSNameIndexPair *dup;
 8179: 
28832:     JS_ASSERT(fun->hasLocalNames());
28832:     n = fun->countLocalNames();
11435: 
11435:     if (n <= MAX_ARRAY_LOCALS)
13702:         return (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
11435: 
11435:     /*
11435:      * No need to check for overflow of the allocation size as we are making a
11435:      * copy of already allocated data. As such it must fit size_t.
11435:      */
11435:     JS_ARENA_ALLOCATE_CAST(names, jsuword *, pool, (size_t) n * sizeof *names);
 8179:     if (!names) {
 8296:         js_ReportOutOfScriptQuota(cx);
 8179:         return NULL;
 8179:     }
 8179: 
 8179: #if JS_HAS_DESTRUCTURING
 8179:     /* Some parameter names can be NULL due to destructuring patterns. */
40229:     PodZero(names, fun->nargs);
 8179: #endif
13702:     map = fun->u.i.names.map;
 8367:     args.fun = fun;
 8367:     args.names = names;
 8367: #ifdef DEBUG
 8367:     args.nCopiedArgs = 0;
 8367:     args.nCopiedVars = 0;
 8367: #endif
 8367:     JS_DHashTableEnumerate(&map->names, get_local_names_enumerator, &args);
 8367:     for (dup = map->lastdup; dup; dup = dup->link) {
 8367:         JS_ASSERT(dup->index < fun->nargs);
 8367:         JS_ASSERT(args.nCopiedArgs++ < fun->nargs);
11435:         names[dup->index] = (jsuword) dup->name;
 8179:     }
 8179: #if !JS_HAS_DESTRUCTURING
 8367:     JS_ASSERT(args.nCopiedArgs == fun->nargs);
 8179: #endif
27012:     JS_ASSERT(args.nCopiedVars == fun->u.i.nvars + fun->u.i.nupvars);
 8367: 
 8179:     return names;
 8179: }
 8179: 
18907: static JSDHashOperator
 8367: trace_local_names_enumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
 8367:                              uint32 number, void *arg)
 8367: {
 8367:     JSLocalNameHashEntry *entry;
 8367:     JSTracer *trc;
 8367: 
 8367:     entry = (JSLocalNameHashEntry *) hdr;
 8367:     JS_ASSERT(entry->name);
 8367:     trc = (JSTracer *) arg;
 8367:     JS_SET_TRACING_INDEX(trc,
 8367:                          entry->localKind == JSLOCAL_ARG ? "arg" : "var",
 8367:                          entry->index);
38595:     js_CallGCMarker(trc, ATOM_TO_STRING(entry->name), JSTRACE_STRING);
 8367:     return JS_DHASH_NEXT;
 8367: }
 8367: 
 8367: static void
13702: TraceLocalNames(JSTracer *trc, JSFunction *fun)
 8367: {
 8367:     uintN n, i;
 8367:     JSAtom *atom;
 8367:     jsuword *array;
 8367: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
28832:     n = fun->countLocalNames();
 8367:     if (n == 0)
 8367:         return;
 8367:     if (n <= MAX_ARRAY_LOCALS) {
13702:         array = (n == 1) ? &fun->u.i.names.taggedAtom : fun->u.i.names.array;
 8367:         i = n;
 8367:         do {
 8367:             --i;
 8367:             atom = (JSAtom *) (array[i] & ~1);
 8367:             if (atom) {
 8367:                 JS_SET_TRACING_INDEX(trc,
 8367:                                      i < fun->nargs ? "arg" : "var",
 8367:                                      i < fun->nargs ? i : i - fun->nargs);
38595:                 js_CallGCMarker(trc, ATOM_TO_STRING(atom), JSTRACE_STRING);
 8367:             }
 8367:         } while (i != 0);
 8367:     } else {
13702:         JS_DHashTableEnumerate(&fun->u.i.names.map->names,
 8367:                                trace_local_names_enumerator, trc);
 8367: 
 8367:         /*
 8367:          * No need to trace the list of duplicates in map->lastdup as the
 8367:          * names there are traced when enumerating the hash table.
 8367:          */
 8367:     }
 8367: }
 8367: 
 8367: void
13702: DestroyLocalNames(JSContext *cx, JSFunction *fun)
 8367: {
 8367:     uintN n;
 8367: 
28832:     n = fun->countLocalNames();
 8367:     if (n <= 1)
 8367:         return;
 8367:     if (n <= MAX_ARRAY_LOCALS)
30851:         cx->free(fun->u.i.names.array);
 8367:     else
13702:         FreeLocalNameHash(cx, fun->u.i.names.map);
 8367: }
 8367: 
 8367: void
13702: js_FreezeLocalNames(JSContext *cx, JSFunction *fun)
 8367: {
 8367:     uintN n;
 8367:     jsuword *array;
 8367: 
13702:     JS_ASSERT(FUN_INTERPRETED(fun));
13702:     JS_ASSERT(!fun->u.i.script);
18308:     n = fun->nargs + fun->u.i.nvars + fun->u.i.nupvars;
 8367:     if (2 <= n && n < MAX_ARRAY_LOCALS) {
 8367:         /* Shrink over-allocated array ignoring realloc failures. */
30851:         array = (jsuword *) cx->realloc(fun->u.i.names.array,
13702:                                         n * sizeof *array);
 8367:         if (array)
13702:             fun->u.i.names.array = array;
 8367:     }
26569: #ifdef DEBUG
26569:     if (n > MAX_ARRAY_LOCALS)
26569:         JS_DHashMarkTableImmutable(&fun->u.i.names.map->names);
26569: #endif
 8367: }
35323: 
35409: JSAtom *
35409: JSFunction::findDuplicateFormal() const
35323: {
35323:     if (nargs <= 1)
35323:         return NULL;
35323: 
35323:     /* Function with two to MAX_ARRAY_LOCALS parameters use an aray. */
35409:     unsigned n = nargs + u.i.nvars + u.i.nupvars;
35409:     if (n <= MAX_ARRAY_LOCALS) {
35409:         jsuword *array = u.i.names.array;
35409: 
35323:         /* Quadratic, but MAX_ARRAY_LOCALS is 8, so at most 28 comparisons. */
35323:         for (unsigned i = 0; i < nargs; i++) {
35323:             for (unsigned j = i + 1; j < nargs; j++) {
35323:                 if (array[i] == array[j])
35323:                     return JS_LOCAL_NAME_TO_ATOM(array[i]);
35323:             }
35323:         }
35323:         return NULL;
35323:     }
35323: 
35323:     /*
35323:      * Functions with more than MAX_ARRAY_LOCALS parameters use a hash
35323:      * table. Hashed local name maps have already made a list of any
35323:      * duplicate argument names for us.
35323:      */
35409:     JSNameIndexPair *dup = u.i.names.map->lastdup;
35323:     return dup ? dup->name : NULL;
35323: }
