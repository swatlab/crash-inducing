116432: /* This Source Code Form is subject to the terms of the Mozilla Public
116432:  * License, v. 2.0. If a copy of the MPL was not distributed with this
116432:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
116432: 
116432: "use strict";
116432: 
116432: const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
116432: 
116432: Cu.import("resource://gre/modules/Services.jsm");
116432: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
116432: 
116432: const PC_CONTRACT = "@mozilla.org/dom/peerconnection;1";
116432: const PC_ICE_CONTRACT = "@mozilla.org/dom/rtcicecandidate;1";
116432: const PC_SESSION_CONTRACT = "@mozilla.org/dom/rtcsessiondescription;1";
116432: 
116432: const PC_CID = Components.ID("{7cb2b368-b1ce-4560-acac-8e0dbda7d3d0}");
116432: const PC_ICE_CID = Components.ID("{8c5dbd70-2c8e-4ecb-a5ad-2fc919099f01}");
116432: const PC_SESSION_CID = Components.ID("{5f21ffd9-b73f-4ba0-a685-56b4667aaf1c}");
116432: 
116432: // Global list of PeerConnection objects, so they can be cleaned up when
116432: // a page is torn down. (Maps inner window ID to an array of PC objects).
116432: function GlobalPCList() {
116432:   this._list = {};
116432:   Services.obs.addObserver(this, "inner-window-destroyed", true);
116432: }
116432: GlobalPCList.prototype = {
116432:   QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver,
116432:                                          Ci.nsISupportsWeakReference]),
116432: 
116432:   addPC: function(pc) {
116432:     let winID = pc._winID;
116432:     if (this._list[winID]) {
116432:       this._list[winID].push(pc);
116432:     } else {
116432:       this._list[winID] = [pc];
116432:     }
116432:   },
116432: 
116432:   observe: function(subject, topic, data) {
116432:     if (topic != "inner-window-destroyed") {
116432:       return;
116432:     }
116432:     let winID = subject.QueryInterface(Ci.nsISupportsPRUint64).data;
116432:     if (this._list[winID]) {
116432:       this._list[winID].forEach(function(pc) {
116432:         pc._pc.close();
116432:         delete pc._observer;
116432:       });
116432:       delete this._list[winID];
116432:     }
116432:   }
116432: };
116432: let _globalPCList = new GlobalPCList();
116432: 
116432: function IceCandidate(candidate) {
116432:   this.candidate = candidate;
116432:   this.sdpMid = null;
116432:   this.sdpMLineIndex = null;
116432: }
116432: IceCandidate.prototype = {
116432:   classID: PC_ICE_CID,
116432: 
116432:   classInfo: XPCOMUtils.generateCI({classID: PC_ICE_CID,
116432:                                     contractID: PC_ICE_CONTRACT,
116432:                                     classDescription: "IceCandidate",
116432:                                     interfaces: [
116432:                                       Ci.nsIDOMRTCIceCandidate
116432:                                     ],
116432:                                     flags: Ci.nsIClassInfo.DOM_OBJECT}),
116432: 
116432:   QueryInterface: XPCOMUtils.generateQI([
116432:     Ci.nsIDOMRTCIceCandidate, Ci.nsIDOMGlobalObjectConstructor
116432:   ]),
116432: 
116432:   constructor: function(win, cand, mid, mline) {
116432:     if (this._win) {
116432:       throw new Error("Constructor already called");
116432:     }
116432:     this._win = win;
116432:     this.candidate = cand;
116432:     this.sdpMid = mid;
116432:     this.sdpMLineIndex = mline;
116432:   }
116432: };
116432: 
116432: function SessionDescription(type, sdp) {
116432:   this.type = type;
116432:   this.sdp = sdp;
116432: }
116432: SessionDescription.prototype = {
116432:   classID: PC_SESSION_CID,
116432: 
116432:   classInfo: XPCOMUtils.generateCI({classID: PC_SESSION_CID,
116432:                                     contractID: PC_SESSION_CONTRACT,
116432:                                     classDescription: "SessionDescription",
116432:                                     interfaces: [
116432:                                       Ci.nsIDOMRTCSessionDescription
116432:                                     ],
116432:                                     flags: Ci.nsIClassInfo.DOM_OBJECT}),
116432: 
116432:   QueryInterface: XPCOMUtils.generateQI([
116432:     Ci.nsIDOMRTCSessionDescription, Ci.nsIDOMGlobalObjectConstructor
116432:   ]),
116432: 
116432:   constructor: function(win, type, sdp) {
116432:     if (this._win) {
116432:       throw new Error("Constructor already called");
116432:     }
116432:     this._win = win;
116432:     this.type = type;
116432:     this.sdp = sdp;
116432:   },
116432: 
116432:   toString: function() {
116432:     return JSON.stringify({
116432:       type: this.type, sdp: this.sdp
116432:     });
116432:   }
116432: };
116432: 
116432: function PeerConnection() {
116432:   this._queue = [];
116432: 
116432:   this._pc = null;
116432:   this._observer = null;
119639:   this._closed = false;
116432: 
116432:   this._onCreateOfferSuccess = null;
116432:   this._onCreateOfferFailure = null;
116432:   this._onCreateAnswerSuccess = null;
116432:   this._onCreateAnswerFailure = null;
116432: 
116432:   /**
116432:    * Everytime we get a request from content, we put it in the queue. If
116432:    * there are no pending operations though, we will execute it immediately.
116432:    * In PeerConnectionObserver, whenever we are notified that an operation
116432:    * has finished, we will check the queue for the next operation and execute
116432:    * if neccesary. The _pending flag indicates whether an operation is currently
116432:    * in progress.
116432:    */
116432:   this._pending = false;
116432: 
116432:   // Public attributes.
116432:   this.onaddstream = null;
116432:   this.onremovestream = null;
116432:   this.onicecandidate = null;
116432:   this.onstatechange = null;
116432:   this.ongatheringchange = null;
116432:   this.onicechange = null;
118954:   this.remoteDescription = null;
116433: 
116433:   // Data channel.
116433:   this.ondatachannel = null;
116433:   this.onconnection = null;
116433:   this.onclosedconnection = null;
116432: }
116432: PeerConnection.prototype = {
116432:   classID: PC_CID,
116432: 
116432:   classInfo: XPCOMUtils.generateCI({classID: PC_CID,
116432:                                     contractID: PC_CONTRACT,
116432:                                     classDescription: "PeerConnection",
116432:                                     interfaces: [
116432:                                       Ci.nsIDOMRTCPeerConnection
116432:                                     ],
116432:                                     flags: Ci.nsIClassInfo.DOM_OBJECT}),
116432: 
116432:   QueryInterface: XPCOMUtils.generateQI([
116432:     Ci.nsIDOMRTCPeerConnection, Ci.nsIDOMGlobalObjectConstructor
116432:   ]),
116432: 
116432:   // Constructor is an explicit function, because of nsIDOMGlobalObjectConstructor.
116432:   constructor: function(win) {
116432:     if (!Services.prefs.getBoolPref("media.peerconnection.enabled")) {
116432:       throw new Error("PeerConnection not enabled (did you set the pref?)");
116432:     }
116432:     if (this._win) {
116432:       throw new Error("Constructor already called");
116432:     }
116432: 
116432:     this._pc = Cc["@mozilla.org/peerconnection;1"].
116432:              createInstance(Ci.IPeerConnection);
116432:     this._observer = new PeerConnectionObserver(this);
116432: 
116432:     // Nothing starts until ICE gathering completes.
116432:     this._queueOrRun({
116432:       func: this._pc.initialize,
116432:       args: [this._observer, win, Services.tm.currentThread],
116432:       wait: true
116432:     });
116432: 
116432:     this._win = win;
116432:     this._winID = this._win.QueryInterface(Ci.nsIInterfaceRequestor)
116432:                            .getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
116432: 
116432:     // Add a reference to the PeerConnection to global list.
116432:     _globalPCList.addPC(this);
116432:   },
116432: 
116432:   /**
116432:    * Add a function to the queue or run it immediately if the queue is empty.
116432:    * Argument is an object with the func, args and wait properties; wait should
116432:    * be set to true if the function has a success/error callback that will
116432:    * call _executeNext, false if it doesn't have a callback.
116432:    */
116432:   _queueOrRun: function(obj) {
119639:     if (this._closed) {
119639: 	return;
119639:     }
116432:     if (!this._pending) {
116432:       obj.func.apply(this, obj.args);
116432:       if (obj.wait) {
116432:         this._pending = true;
116432:       }
116432:     } else {
116432:       this._queue.push(obj);
116432:     }
116432:   },
116432: 
116432:   // Pick the next item from the queue and run it.
116432:   _executeNext: function() {
116432:     if (this._queue.length) {
116432:       let obj = this._queue.shift();
116432:       obj.func.apply(this, obj.args);
116432:       if (!obj.wait) {
116432:         this._executeNext();
116432:       }
116432:     } else {
116432:       this._pending = false;
116432:     }
116432:   },
116432: 
116432:   createOffer: function(onSuccess, onError, constraints) {
116432:     if (this._onCreateOfferSuccess) {
116432:       if (onError) {
116432:         onError.onCallback("createOffer already called");
116432:       }
116432:       return;
116432:     }
116432: 
116432:     this._onCreateOfferSuccess = onSuccess;
116432:     this._onCreateOfferFailure = onError;
116432: 
116432:     // TODO: Implement constraints/hints.
116432:     if (!constraints) {
116432:       constraints = "";
116432:     }
116432: 
116432:     this._queueOrRun({
116432:       func: this._pc.createOffer,
116432:       args: [constraints],
116432:       wait: true
116432:     });
116432:   },
116432: 
118954:   createAnswer: function(onSuccess, onError, constraints, provisional) {
116432:     if (this._onCreateAnswerSuccess) {
116432:       if (onError) {
118954:         try {
116432:           onError.onCallback("createAnswer already called");
118954:         } catch(e) {}
116432:       }
116432:       return;
116432:     }
116432: 
118954:     if (!this.remoteDescription) {
118954:       if (onError) {
118954:         try {
118954:           onError.onCallback("setRemoteDescription not called");
118954:         } catch(e) {}
118954:       }
118954:     }
118954: 
118954:     if (this.remoteDescription.type != "offer") {
118954:       if (onError) {
118954:         try {
118954:           onError.onCallback("No outstanding offer");
118954:         } catch(e) {}
118954:       }
118954:     }
118954: 
116432:     this._onCreateAnswerSuccess = onSuccess;
116432:     this._onCreateAnswerFailure = onError;
116432: 
116432:     if (!constraints) {
116432:       constraints = "";
116432:     }
116432:     if (!provisional) {
116432:       provisional = false;
116432:     }
116432: 
116432:     // TODO: Implement provisional answer & constraints.
116432:     this._queueOrRun({
116432:       func: this._pc.createAnswer,
118954:       args: ["", this.remoteDescription.sdp],
116432:       wait: true
116432:     });
116432:   },
116432: 
116432:   setLocalDescription: function(desc, onSuccess, onError) {
116432:     if (this._onSetLocalDescriptionSuccess) {
116432:       if (onError) {
118954:         try {
116432:           onError.onCallback("setLocalDescription already called");
118954:         } catch(e) {}
116432:       }
116432:       return;
116432:     }
116432: 
116432:     this._onSetLocalDescriptionSuccess = onSuccess;
116432:     this._onSetLocalDescriptionFailure = onError;
116432: 
116432:     let type;
116432:     switch (desc.type) {
116432:       case "offer":
116432:         type = Ci.IPeerConnection.kActionOffer;
116432:         break;
116432:       case "answer":
116432:         type = Ci.IPeerConnection.kActionAnswer;
116432:         break;
116432:       default:
116432:         if (onError) {
118954:           try {
116432:             onError.onCallback(
116432:               "Invalid type " + desc.type + " provided to setLocalDescription"
116432:             );
118954:           } catch(e) {}
116432:           return;
116432:         }
116432:         break;
116432:     }
116432: 
116432:     this._queueOrRun({
116432:       func: this._pc.setLocalDescription,
116432:       args: [type, desc.sdp],
116432:       wait: true
116432:     });
116432:   },
116432: 
116432:   setRemoteDescription: function(desc, onSuccess, onError) {
116432:     if (this._onSetRemoteDescriptionSuccess) {
116432:       if (onError) {
118954:         try {
116432:           onError.onCallback("setRemoteDescription already called");
118954:         } catch(e) {}
116432:       }
116432:       return;
116432:     }
116432: 
116432:     this._onSetRemoteDescriptionSuccess = onSuccess;
116432:     this._onSetRemoteDescriptionFailure = onError;
116432: 
116432:     let type;
116432:     switch (desc.type) {
116432:       case "offer":
116432:         type = Ci.IPeerConnection.kActionOffer;
116432:         break;
116432:       case "answer":
116432:         type = Ci.IPeerConnection.kActionAnswer;
116432:         break;
116432:       default:
116432:         if (onError) {
118954:           try {
116432:             onError.onCallback(
118954:               "Invalid type " + desc.type + " provided to setRemoteDescription"
116432:             );
118954:           } catch(e) {}
116432:           return;
116432:         }
116432:         break;
116432:     }
116432: 
118954:     this.remoteDescription = {
118954:       type: desc.type, sdp: desc.sdp,
118954:       __exposedProps__: { type: "rw", sdp: "rw" }
118954:     };
118954: 
116432:     this._queueOrRun({
116432:       func: this._pc.setRemoteDescription,
116432:       args: [type, desc.sdp],
116432:       wait: true
116432:     });
116432:   },
116432: 
116432:   updateIce: function(config, constraints, restart) {
116432:     return Cr.NS_ERROR_NOT_IMPLEMENTED;
116432:   },
116432: 
116432:   addIceCandidate: function(cand) {
116432:     if (!cand) {
116432:       throw "Invalid candidate passed to addIceCandidate!";
116432:     }
116432:     if (!cand.candidate || !cand.sdpMid || !cand.sdpMLineIndex) {
116432:       throw "Invalid candidate passed to addIceCandidate!";
116432:     }
116432: 
116432:     this._queueOrRun({
116432:       func: this._pc.addIceCandidate,
116432:       args: [cand.candidate, cand.sdpMid, cand.sdpMLineIndex],
116432:       wait: false
116432:     });
116432:   },
116432: 
116432:   addStream: function(stream, constraints) {
116432:     // TODO: Implement constraints.
116432:     this._queueOrRun({
116432:       func: this._pc.addStream,
116432:       args: [stream],
116432:       wait: false
116432:     });
116432:   },
116432: 
116432:   removeStream: function(stream) {
116432:     this._queueOrRun({
116432:       func: this._pc.removeStream,
116432:       args: [stream],
116432:       wait: false
116432:     });
116432:   },
116432: 
116432:   close: function() {
116432:     this._queueOrRun({
116432:       func: this._pc.close,
116432:       args: [],
116432:       wait: false
116432:     });
119639:     this._closed = true;
116433:   },
116433: 
118913:   get localStreams() {
118913:     return this._pc.localStreams;
118913:   },
118913:   get remoteStreams() {
118913:     return this._pc.remoteStreams;
118913:   },
118913: 
116433:   createDataChannel: function(label, dict) {
116433:     if (dict &&
116433:         dict.maxRetransmitTime != undefined &&
116433:         dict.maxRetransmitNum != undefined) {
116433:       throw new Error("Both maxRetransmitTime and maxRetransmitNum cannot be provided");
116433:     }
116433: 
116433:     // Must determine the type where we still know if entries are undefined.
116433:     let type;
116433:     if (dict.maxRetransmitTime != undefined) {
116433:       type = Ci.IPeerConnection.DATACHANNEL_PARTIAL_RELIABLE_TIMED;
116433:     } else if (dict.maxRetransmitNum != undefined) {
116433:       type = Ci.IPeerConnection.DATACHANNEL_PARTIAL_RELIABLE_REXMIT;
116433:     } else {
116433:       type = Ci.IPeerConnection.DATACHANNEL_RELIABLE;
116433:     }
116433: 
116433:     // Synchronous since it doesn't block.
116433:     let channel = this._pc.createDataChannel(
116433:       label, type, dict.outOfOrderAllowed, dict.maxRetransmitTime,
116433:       dict.maxRetransmitNum
116433:     );
116433:     return channel;
116433:   },
116433: 
116433:   connectDataConnection: function(localport, remoteport, numstreams) {
116433:     if (numstreams == undefined || numstreams <= 0) {
116433:       numstreams = 16;
116433:     }
116433:     this._queueOrRun({
116433:       func: this._pc.connectDataConnection,
116433:       args: [localport, remoteport, numstreams],
116433:       wait: false
116433:     });
116432:   }
116432: };
116432: 
116432: // This is a seperate object because we don't want to expose it to DOM.
116432: function PeerConnectionObserver(dompc) {
116432:   this._dompc = dompc;
116432: }
116432: PeerConnectionObserver.prototype = {
116432:   QueryInterface: XPCOMUtils.generateQI([Ci.IPeerConnectionObserver]),
116432: 
116432:   onCreateOfferSuccess: function(offer) {
116432:     if (this._dompc._onCreateOfferSuccess) {
116432:       try {
116432:         this._dompc._onCreateOfferSuccess.onCallback({
116432:           type: "offer", sdp: offer,
116432:           __exposedProps__: { type: "rw", sdp: "rw" }
116432:         });
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onCreateOfferError: function(code) {
116432:     if (this._dompc._onCreateOfferFailure) {
116432:       try {
116432:         this._dompc._onCreateOfferFailure.onCallback(code);
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onCreateAnswerSuccess: function(answer) {
116432:     if (this._dompc._onCreateAnswerSuccess) {
116432:       try {
116432:         this._dompc._onCreateAnswerSuccess.onCallback({
116432:           type: "answer", sdp: answer,
116432:           __exposedProps__: { type: "rw", sdp: "rw" }
116432:         });
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onCreateAnswerError: function(code) {
116432:     if (this._dompc._onCreateAnswerFailure) {
116432:       try {
116432:         this._dompc._onCreateAnswerFailure.onCallback(code);
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onSetLocalDescriptionSuccess: function(code) {
116432:     if (this._dompc._onSetLocalDescriptionSuccess) {
116432:       try {
116432:         this._dompc._onSetLocalDescriptionSuccess.onCallback(code);
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onSetRemoteDescriptionSuccess: function(code) {
116432:     if (this._dompc._onSetRemoteDescriptionSuccess) {
116432:       try {
116432:         this._dompc._onSetRemoteDescriptionSuccess.onCallback(code);
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onSetLocalDescriptionError: function(code) {
116432:     if (this._dompc._onSetLocalDescriptionFailure) {
116432:       try {
116432:         this._dompc._onSetLocalDescriptionFailure.onCallback(code);
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onSetRemoteDescriptionError: function(code) {
116432:     if (this._dompc._onSetRemoteDescriptionFailure) {
116432:       this._dompc._onSetRemoteDescriptionFailure.onCallback(code);
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onStateChange: function(state) {
116432:     if (state != Ci.IPeerConnectionObserver.kIceState) {
116432:       return;
116432:     }
116432: 
116432:     let self = this;
116432:     let iceCb = function() {};
116432:     let iceGatherCb = function() {};
116432:     if (this._dompc.onicechange) {
116432:       iceCb = function(args) {
116432:         try {
116432:           self._dompc.onicechange(args);
116432:         } catch(e) {}
116432:       };
116432:     }
116432:     if (this._dompc.ongatheringchange) {
116432:       iceGatherCb = function(args) {
116432:         try {
116432:           self._dompc.ongatheringchange(args);
116432:         } catch(e) {}
116432:       };
116432:     }
116432: 
116432:     switch (this._dompc._pc.iceState) {
116432:       case Ci.IPeerConnection.kIceGathering:
116432:         iceGatherCb("gathering");
116432:         break;
116432:       case Ci.IPeerConnection.kIceWaiting:
116432:         iceCb("starting");
116432:         this._dompc._executeNext();
116432:         break;
116432:       case Ci.IPeerConnection.kIceChecking:
116432:         iceCb("checking");
116432:         this._dompc._executeNext();
116432:         break;
116432:       case Ci.IPeerConnection.kIceConnected:
116432:         // ICE gathering complete.
116432:         iceCb("connected");
116432:         iceGatherCb("complete");
116432:         this._dompc._executeNext();
116432:         break;
116432:       case Ci.IPeerConnection.kIceFailed:
116432:         iceCb("failed");
116432:         break;
116432:       default:
116432:         // Unknown state!
116432:         break;
116432:     }
116432:   },
116432: 
116432:   onAddStream: function(stream, type) {
116432:     if (this._dompc.onaddstream) {
116432:       try {
116432:         this._dompc.onaddstream.onCallback({
116432:           stream: stream, type: type,
116432:           __exposedProps__: { stream: "r", type: "r" }
116432:         });
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   onRemoveStream: function(stream, type) {
116432:     if (this._dompc.onremovestream) {
116432:       try {
116432:         this._dompc.onremovestream.onCallback({
116432:           stream: stream, type: type,
116432:           __exposedProps__: { stream: "r", type: "r" }
116432:         });
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116432:   },
116432: 
116432:   foundIceCandidate: function(cand) {
116432:     if (this._dompc.onicecandidate) {
116432:       try {
116432:         this._dompc.onicecandidate.onCallback({
116432:           candidate: cand,
116432:           __exposedProps__: { candidate: "rw" }
116432:         });
116432:       } catch(e) {}
116432:     }
116432:     this._dompc._executeNext();
116433:   },
116433: 
116433:   notifyDataChannel: function(channel) {
116433:     if (this._dompc.ondatachannel) {
116433:       try {
116433:         this._dompc.ondatachannel.onCallback(channel);
116433:       } catch(e) {}
116433:     }
116433:     this._dompc._executeNext();
116433:   },
116433: 
116433:   notifyConnection: function() {
116433:     if (this._dompc.onconnection) {
116433:       try {
116433:         this._dompc.onconnection.onCallback();
116433:       } catch(e) {}
116433:     }
116433:     this._dompc._executeNext();
116433:   },
116433: 
116433:   notifyClosedConnection: function() {
116433:     if (this._dompc.onclosedconnection) {
116433:       try {
116433:         this._dompc.onclosedconnection.onCallback();
116433:       } catch(e) {}
116433:     }
116433:     this._dompc._executeNext();
116432:   }
116432: };
116432: 
116432: let NSGetFactory = XPCOMUtils.generateNSGetFactory(
116432:   [IceCandidate, SessionDescription, PeerConnection]
116432: );
