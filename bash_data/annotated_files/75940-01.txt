29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set sw=4 ts=8 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS array class.
11835:  *
25888:  * Array objects begin as "dense" arrays, optimized for index-only property
41782:  * access over a vector of slots with high load factor.  Array methods
41782:  * optimize for denseness by testing that the object's class is
11835:  * &js_ArrayClass, and can then directly manipulate the slots for efficiency.
11835:  *
11835:  * We track these pieces of metadata for arrays in dense mode:
41850:  *  - The array's length property as a uint32, accessible with
48537:  *    getArrayLength(), setArrayLength().
41850:  *  - The number of element slots (capacity), gettable with
41782:  *    getDenseArrayCapacity().
75625:  *  - The array's initialized length, accessible with getDenseArrayInitializedLength().
11835:  *
59234:  * In dense mode, holes in the array are represented by
75688:  * MagicValue(JS_ARRAY_HOLE) invalid values. Elements between the initialized
75688:  * length and the length property are left uninitialized, but are conceptually holes.
75688:  * Arrays with no holes below the initialized length are "packed" arrays.
11835:  *
28242:  * NB: the capacity and length of a dense array are entirely unrelated!  The
59234:  * length may be greater than, less than, or equal to the capacity. The first
59234:  * case may occur when the user writes "new Array(100), in which case the
59234:  * length is 100 while the capacity remains 0 (indices below length and above
75688:  * capacity must be treated as holes). See array_length_setter for another
75919:  * explanation of how the first case may occur. When type inference is enabled,
75919:  * the initialized length is always less than or equal to both the length and
75919:  * capacity. Otherwise, the initialized length always equals the capacity.
28242:  *
11835:  * Arrays are converted to use js_SlowArrayClass when any of these conditions
11835:  * are met:
75919:  *  - there are more than MIN_SPARSE_INDEX slots total and the load factor
75919:  *    (COUNT / capacity) is less than 0.25
58702:  *  - a property is set that is not indexed (and not "length")
25475:  *  - a property is defined that has non-default property attributes.
11835:  *
25475:  * Dense arrays do not track property creation order, so unlike other native
25475:  * objects and slow arrays, enumerating an array does not necessarily visit the
25475:  * properties in the order they were created.  We could instead maintain the
25475:  * scope to track property enumeration order, but still use the fast slot
25475:  * access.  That would have the same memory cost as just using a
25475:  * js_SlowArrayClass, but have the same performance characteristics as a dense
25475:  * array for slot accesses, at some cost in code complexity.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
11835: #include "jsbit.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
43281: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
11835: #include "jsscope.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
64215: #include "jstracer.h"
30023: #include "jsvector.h"
56565: #include "jswrapper.h"
75900: #include "methodjit/StubCalls.h"
75900: #include "methodjit/StubCalls-inl.h"
    1: 
30283: #include "jsatominlines.h"
55530: #include "jscntxtinlines.h"
55530: #include "jsinterpinlines.h"
40796: #include "jsobjinlines.h"
75657: #include "jsscopeinlines.h"
75615: #include "jscntxtinlines.h"
75615: #include "jsinferinlines.h"
64345: #include "jsstrinlines.h"
30283: 
37741: using namespace js;
54707: using namespace js::gc;
75615: using namespace js::types;
37741: 
    1: /* 2^32 - 1 as a number and a string */
    1: #define MAXINDEX 4294967295u
    1: #define MAXSTR   "4294967295"
    1: 
48537: static inline bool
48537: ENSURE_SLOW_ARRAY(JSContext *cx, JSObject *obj)
48537: {
48537:     return obj->getClass() == &js_SlowArrayClass ||
48537:            obj->makeDenseArraySlow(cx);
48537: }
11835: 
    1: /*
    1:  * Determine if the id represents an array index or an XML property index.
    1:  *
    1:  * An id is an array index according to ECMA by (15.4):
    1:  *
    1:  * "Array objects give special treatment to a certain class of property names.
    1:  * A property name P (in the form of a string value) is an array index if and
    1:  * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    1:  * to 2^32-1."
    1:  *
    1:  * In our implementation, it would be sufficient to check for JSVAL_IS_INT(id)
48470:  * except that by using signed 31-bit integers we miss the top half of the
    1:  * valid range. This function checks the string representation itself; note
    1:  * that calling a standard conversion routine might allow strings such as
    1:  * "08" or "4.0" as array indices, which they are not.
48470:  *
48470:  * 'id' is passed as a jsboxedword since the given id need not necessarily hold
48470:  * an atomized string.
    1:  */
59890: bool
59890: js_StringIsIndex(JSLinearString *str, jsuint *indexp)
    1: {
59890:     const jschar *cp = str->chars();
29366:     if (JS7_ISDEC(*cp) && str->length() < sizeof(MAXSTR)) {
    1:         jsuint index = JS7_UNDEC(*cp++);
    1:         jsuint oldIndex = 0;
    1:         jsuint c = 0;
    1:         if (index != 0) {
    1:             while (JS7_ISDEC(*cp)) {
    1:                 oldIndex = index;
    1:                 c = JS7_UNDEC(*cp);
    1:                 index = 10*index + c;
    1:                 cp++;
    1:             }
    1:         }
    1: 
    1:         /* Ensure that all characters were consumed and we didn't overflow. */
    1:         if (*cp == 0 &&
    1:              (oldIndex < (MAXINDEX / 10) ||
    1:               (oldIndex == (MAXINDEX / 10) && c < (MAXINDEX % 10))))
    1:         {
    1:             *indexp = index;
59890:             return true;
    1:         }
    1:     }
59890:     return false;
    1: }
    1: 
59234: static bool 
59234: ValueToLength(JSContext *cx, Value* vp, jsuint* plength)
    1: {
48470:     if (vp->isInt32()) {
48470:         int32_t i = vp->toInt32();
12694:         if (i < 0)
12694:             goto error;
59234: 
59234:         *plength = (jsuint)(i);
59234:         return true;
12694:     }
12694: 
40828:     jsdouble d;
40828:     if (!ValueToNumber(cx, *vp, &d))
12694:         goto error;
12694: 
12694:     if (JSDOUBLE_IS_NaN(d))
12694:         goto error;
59234: 
48470:     jsuint length;
12694:     length = (jsuint) d;
12694:     if (d != (jsdouble) length)
12694:         goto error;
59234: 
59234: 
59234:     *plength = length;
59234:     return true;
12694: 
12694: error:
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                          JSMSG_BAD_ARRAY_LENGTH);
59234:     return false;
    1: }
    1: 
    1: JSBool
    1: js_GetLengthProperty(JSContext *cx, JSObject *obj, jsuint *lengthp)
    1: {
39928:     if (obj->isArray()) {
40796:         *lengthp = obj->getArrayLength();
40405:         return true;
40405:     }
40405: 
40864:     if (obj->isArguments() && !obj->isArgsLengthOverridden()) {
51091:         *lengthp = obj->getArgsInitialLength();
40405:         return true;
11835:     }
11835: 
48470:     AutoValueRooter tvr(cx);
31501:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), tvr.addr()))
40405:         return false;
28839: 
48470:     if (tvr.value().isInt32()) {
48470:         *lengthp = jsuint(jsint(tvr.value().toInt32())); /* jsuint cast does ToUint32 */
40405:         return true;
28839:     }
28839: 
40828:     JS_STATIC_ASSERT(sizeof(jsuint) == sizeof(uint32_t));
40828:     return ValueToECMAUint32(cx, tvr.value(), (uint32_t *)lengthp);
    1: }
    1: 
19545: JSBool JS_FASTCALL
19545: js_IndexToId(JSContext *cx, jsuint index, jsid *idp)
12479: {
12479:     JSString *str;
12479: 
48470:     if (index <= JSID_INT_MAX) {
12479:         *idp = INT_TO_JSID(index);
12479:         return JS_TRUE;
12479:     }
12479:     str = js_NumberToString(cx, index);
12479:     if (!str)
12479:         return JS_FALSE;
48470:     return js_ValueToStringId(cx, StringValue(str), idp);
    1: }
    1: 
    1: static JSBool
    1: BigIndexToId(JSContext *cx, JSObject *obj, jsuint index, JSBool createAtom,
    1:              jsid *idp)
    1: {
    1:     jschar buf[10], *start;
48470:     Class *clasp;
    1:     JSAtom *atom;
    1:     JS_STATIC_ASSERT((jsuint)-1 == 4294967295U);
    1: 
48470:     JS_ASSERT(index > JSID_INT_MAX);
    1: 
    1:     start = JS_ARRAY_END(buf);
    1:     do {
    1:         --start;
    1:         *start = (jschar)('0' + index % 10);
    1:         index /= 10;
    1:     } while (index != 0);
    1: 
    1:     /*
    1:      * Skip the atomization if the class is known to store atoms corresponding
    1:      * to big indexes together with elements. In such case we know that the
    1:      * array does not have an element at the given index if its atom does not
11835:      * exist.  Fast arrays (clasp == &js_ArrayClass) don't use atoms for
11835:      * any indexes, though it would be rare to see them have a big index
11835:      * in any case.
    1:      */
    1:     if (!createAtom &&
40826:         ((clasp = obj->getClass()) == &js_SlowArrayClass ||
    1:          clasp == &js_ArgumentsClass ||
    1:          clasp == &js_ObjectClass)) {
    1:         atom = js_GetExistingStringAtom(cx, start, JS_ARRAY_END(buf) - start);
    1:         if (!atom) {
48470:             *idp = JSID_VOID;
    1:             return JS_TRUE;
    1:         }
    1:     } else {
    1:         atom = js_AtomizeChars(cx, start, JS_ARRAY_END(buf) - start, 0);
    1:         if (!atom)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     *idp = ATOM_TO_JSID(atom);
    1:     return JS_TRUE;
    1: }
    1: 
58702: bool
58702: JSObject::willBeSparseDenseArray(uintN requiredCapacity, uintN newElementsHint)
58702: {
58702:     JS_ASSERT(isDenseArray());
58702:     JS_ASSERT(requiredCapacity > MIN_SPARSE_INDEX);
58702: 
58702:     uintN cap = numSlots();
58702:     JS_ASSERT(requiredCapacity >= cap);
58702: 
58702:     if (requiredCapacity >= JSObject::NSLOTS_LIMIT)
58702:         return true;
58702:     
58702:     uintN minimalDenseCount = requiredCapacity / 4;
58702:     if (newElementsHint >= minimalDenseCount)
58702:         return false;
58702:     minimalDenseCount -= newElementsHint;
58702: 
58702:     if (minimalDenseCount > cap)
58702:         return true;
58702:     
75767:     uintN len = getDenseArrayInitializedLength();
58702:     Value *elems = getDenseArrayElements();
75767:     for (uintN i = 0; i < len; i++) {
58702:         if (!elems[i].isMagic(JS_ARRAY_HOLE) && !--minimalDenseCount)
58702:             return false;
58702:     }
58702:     return true;
58702: }
58702: 
26564: static bool
26564: ReallyBigIndexToId(JSContext* cx, jsdouble index, jsid* idp)
26564: {
48470:     return js_ValueToStringId(cx, DoubleValue(index), idp);
26564: }
26564: 
26564: static bool
26564: IndexToId(JSContext* cx, JSObject* obj, jsdouble index, JSBool* hole, jsid* idp,
26564:           JSBool createAtom = JS_FALSE)
26564: {
48470:     if (index <= JSID_INT_MAX) {
33166:         *idp = INT_TO_JSID(int(index));
26564:         return JS_TRUE;
26564:     }
26564: 
26564:     if (index <= jsuint(-1)) {
26564:         if (!BigIndexToId(cx, obj, jsuint(index), createAtom, idp))
26564:             return JS_FALSE;
48470:         if (hole && JSID_IS_VOID(*idp))
26564:             *hole = JS_TRUE;
26564:         return JS_TRUE;
26564:     }
26564: 
26564:     return ReallyBigIndexToId(cx, index, idp);
26564: }
26564: 
    1: /*
    1:  * If the property at the given index exists, get its value into location
    1:  * pointed by vp and set *hole to false. Otherwise set *hole to true and *vp
    1:  * to JSVAL_VOID. This function assumes that the location pointed by vp is
    1:  * properly rooted and can be used as GC-protected storage for temporaries.
    1:  */
    1: static JSBool
57714: GetElement(JSContext *cx, JSObject *obj, jsdouble index, JSBool *hole, Value *vp)
    1: {
26564:     JS_ASSERT(index >= 0);
75625:     if (obj->isDenseArray() && index < obj->getDenseArrayInitializedLength() &&
48470:         !(*vp = obj->getDenseArrayElement(uint32(index))).isMagic(JS_ARRAY_HOLE)) {
26564:         *hole = JS_FALSE;
26564:         return JS_TRUE;
26564:     }
55530:     if (obj->isArguments() &&
55530:         index < obj->getArgsInitialLength() &&
59984:         !(*vp = obj->getArgsElement(uint32(index))).isMagic(JS_ARGS_HOLE)) {
55530:         *hole = JS_FALSE;
55530:         JSStackFrame *fp = (JSStackFrame *)obj->getPrivate();
55530:         if (fp != JS_ARGUMENTS_OBJECT_ON_TRACE) {
55530:             if (fp)
55530:                 *vp = fp->canonicalActualArg(index);
55530:             return JS_TRUE;
55530:         }
55530:     }
26564: 
40390:     AutoIdRooter idr(cx);
26564: 
26564:     *hole = JS_FALSE;
26564:     if (!IndexToId(cx, obj, index, hole, idr.addr()))
26564:         return JS_FALSE;
26564:     if (*hole) {
48470:         vp->setUndefined();
26564:         return JS_TRUE;
26564:     }
26564: 
    1:     JSObject *obj2;
    1:     JSProperty *prop;
31501:     if (!obj->lookupProperty(cx, idr.id(), &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         *hole = JS_TRUE;
48470:         vp->setUndefined();
    1:     } else {
31501:         if (!obj->getProperty(cx, idr.id(), vp))
    1:             return JS_FALSE;
    1:         *hole = JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
57714: namespace js {
57714: 
57714: bool
57714: GetElements(JSContext *cx, JSObject *aobj, jsuint length, Value *vp)
57714: {
75767:     if (aobj->isDenseArray() && length <= aobj->getDenseArrayInitializedLength() &&
57744:         !js_PrototypeHasIndexedProperties(cx, aobj)) {
57744:         /* The prototype does not have indexed properties so hole = undefined */
57714:         Value *srcbeg = aobj->getDenseArrayElements();
57714:         Value *srcend = srcbeg + length;
57714:         for (Value *dst = vp, *src = srcbeg; src < srcend; ++dst, ++src)
57714:             *dst = src->isMagic(JS_ARRAY_HOLE) ? UndefinedValue() : *src;
57744:     } else if (aobj->isArguments() && !aobj->isArgsLengthOverridden() &&
57744:                !js_PrototypeHasIndexedProperties(cx, aobj)) {
57714:         /*
57714:          * Two cases, two loops: note how in the case of an active stack frame
57714:          * backing aobj, even though we copy from fp->argv, we still must check
57714:          * aobj->getArgsElement(i) for a hole, to handle a delete on the
57714:          * corresponding arguments element. See args_delProperty.
57714:          */
57714:         if (JSStackFrame *fp = (JSStackFrame *) aobj->getPrivate()) {
57714:             JS_ASSERT(fp->numActualArgs() <= JS_ARGS_LENGTH_MAX);
57718:             fp->forEachCanonicalActualArg(CopyNonHoleArgsTo(aobj, vp));
57714:         } else {
57714:             Value *srcbeg = aobj->getArgsElements();
57714:             Value *srcend = srcbeg + length;
57714:             for (Value *dst = vp, *src = srcbeg; src < srcend; ++dst, ++src)
57714:                 *dst = src->isMagic(JS_ARGS_HOLE) ? UndefinedValue() : *src;
57714:         }
57714:     } else {
57714:         for (uintN i = 0; i < length; i++) {
57714:             if (!aobj->getProperty(cx, INT_TO_JSID(jsint(i)), &vp[i]))
57714:                 return JS_FALSE;
57714:         }
57714:     }
57714: 
57714:     return true;
57714: }
57714: 
57714: }
57714: 
    1: /*
    1:  * Set the value of the property at the given index to v assuming v is rooted.
    1:  */
    1: static JSBool
48470: SetArrayElement(JSContext *cx, JSObject *obj, jsdouble index, const Value &v)
    1: {
26564:     JS_ASSERT(index >= 0);
    1: 
39928:     if (obj->isDenseArray()) {
26564:         /* Predicted/prefetched code should favor the remains-dense case. */
58702:         JSObject::EnsureDenseResult result = JSObject::ED_SPARSE;
58702:         do {
58702:             if (index > jsuint(-1))
58702:                 break;
26564:             jsuint idx = jsuint(index);
58702:             result = obj->ensureDenseArrayElements(cx, idx, 1);
58702:             if (result != JSObject::ED_OK)
58702:                 break;
40796:             if (idx >= obj->getArrayLength())
75720:                 obj->setDenseArrayLength(idx + 1);
41782:             obj->setDenseArrayElement(idx, v);
58702:             return true;
58702:         } while (false);
58702: 
58702:         if (result == JSObject::ED_FAILED)
58702:             return false;
58702:         JS_ASSERT(result == JSObject::ED_SPARSE);
43287:         if (!obj->makeDenseArraySlow(cx))
18712:             return JS_FALSE;
11835:     }
11835: 
40390:     AutoIdRooter idr(cx);
26564: 
26564:     if (!IndexToId(cx, obj, index, NULL, idr.addr(), JS_TRUE))
    1:         return JS_FALSE;
48470:     JS_ASSERT(!JSID_IS_VOID(idr.id()));
48470: 
48470:     Value tmp = v;
54169:     return obj->setProperty(cx, idr.id(), &tmp, true);
    1: }
    1: 
53614: #ifdef JS_TRACER
53614: JSBool JS_FASTCALL
53614: js_EnsureDenseArrayCapacity(JSContext *cx, JSObject *obj, jsint i)
53614: {
56180: #ifdef DEBUG
56180:     Class *origObjClasp = obj->clasp; 
56180: #endif
53614:     jsuint u = jsuint(i);
58702:     JSBool ret = (obj->ensureDenseArrayElements(cx, u, 1) == JSObject::ED_OK);
56180: 
56180:     /* Partially check the CallInfo's storeAccSet is correct. */
56180:     JS_ASSERT(obj->clasp == origObjClasp);
56180:     return ret;
53614: }
56180: /* This function and its callees do not touch any object's .clasp field. */
56180: JS_DEFINE_CALLINFO_3(extern, BOOL, js_EnsureDenseArrayCapacity, CONTEXT, OBJECT, INT32,
56750:                      0, nanojit::ACCSET_STORE_ANY & ~tjit::ACCSET_OBJ_CLASP)
53614: #endif
53614: 
62396: /*
62396:  * Delete the element |index| from |obj|. If |strict|, do a strict
62396:  * deletion: throw if the property is not configurable.
62396:  *
62396:  * - Return 1 if the deletion succeeds (that is, ES5's [[Delete]] would
62396:  *   return true)
62396:  *
62396:  * - Return 0 if the deletion fails because the property is not
62396:  *   configurable (that is, [[Delete]] would return false). Note that if
62396:  *   |strict| is true we will throw, not return zero.
62396:  *
62396:  * - Return -1 if an exception occurs (that is, [[Delete]] would throw).
62396:  */
62396: static int
62396: DeleteArrayElement(JSContext *cx, JSObject *obj, jsdouble index, bool strict)
    1: {
26564:     JS_ASSERT(index >= 0);
39928:     if (obj->isDenseArray()) {
26564:         if (index <= jsuint(-1)) {
26564:             jsuint idx = jsuint(index);
75625:             if (idx < obj->getDenseArrayInitializedLength()) {
75720:                 if (!obj->setDenseArrayNotPacked(cx))
75720:                     return -1;
48470:                 obj->setDenseArrayElement(idx, MagicValue(JS_ARRAY_HOLE));
62396:                 if (!js_SuppressDeletedIndexProperties(cx, obj, idx, idx+1))
62396:                     return -1;
26564:             }
26564:         }
62396:         return 1;
26564:     }
26564: 
40390:     AutoIdRooter idr(cx);
26564: 
26564:     if (!IndexToId(cx, obj, index, NULL, idr.addr()))
62396:         return -1;
48470:     if (JSID_IS_VOID(idr.id()))
62396:         return 1;
62396: 
62396:     Value v;
62396:     if (!obj->deleteProperty(cx, idr.id(), &v, strict))
62396:         return -1;
62396:     return v.isTrue() ? 1 : 0;
    1: }
    1: 
    1: /*
    1:  * When hole is true, delete the property at the given index. Otherwise set
    1:  * its value to v assuming v is rooted.
    1:  */
    1: static JSBool
26564: SetOrDeleteArrayElement(JSContext *cx, JSObject *obj, jsdouble index,
48470:                         JSBool hole, const Value &v)
    1: {
    1:     if (hole) {
48470:         JS_ASSERT(v.isUndefined());
62396:         return DeleteArrayElement(cx, obj, index, true) >= 0;
11835:     }
    1:     return SetArrayElement(cx, obj, index, v);
    1: }
    1: 
    1: JSBool
26564: js_SetLengthProperty(JSContext *cx, JSObject *obj, jsdouble length)
    1: {
48470:     Value v;
    1:     jsid id;
    1: 
48470:     v.setNumber(length);
    1:     id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
75704: 
75704:     /*
75704:      * Arrays are already known to have lengths (if the length overflows, it will
75704:      * be caught by setArrayLength).
75704:      */
75720:     if (!obj->isArray() && !cx->addTypePropertyId(obj->getType(), id, v))
75720:         return false;
75704: 
54169:     /* We don't support read-only array length yet. */
54169:     return obj->setProperty(cx, id, &v, false);
    1: }
    1: 
    1: JSBool
    1: js_HasLengthProperty(JSContext *cx, JSObject *obj, jsuint *lengthp)
    1: {
33178:     JSErrorReporter older = JS_SetErrorReporter(cx, NULL);
48470:     AutoValueRooter tvr(cx);
33178:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
33178:     JSBool ok = obj->getProperty(cx, id, tvr.addr());
    1:     JS_SetErrorReporter(cx, older);
33178:     if (!ok)
33178:         return false;
33178: 
59234:     if (!ValueToLength(cx, tvr.addr(), lengthp))
59234:         return false;
59234: 
59234:     return true;
    1: }
    1: 
    1: /*
 4182:  * Since SpiderMonkey supports cross-class prototype-based delegation, we have
 4182:  * to be careful about the length getter and setter being called on an object
 4182:  * not of Array class. For the getter, we search obj's prototype chain for the
 4182:  * array that caused this getter to be invoked. In the setter case to overcome
 4182:  * the JSPROP_SHARED attribute, we must define a shadowing length property.
    1:  */
    1: static JSBool
48470: array_length_getter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
 4182:     do {
48470:         if (obj->isArray()) {
48470:             vp->setNumber(obj->getArrayLength());
48470:             return JS_TRUE;
48470:         }
39928:     } while ((obj = obj->getProto()) != NULL);
 4127:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
62395: array_length_setter(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
    1: {
    1:     jsuint newlen, oldlen, gap, index;
48470:     Value junk;
    1: 
39928:     if (!obj->isArray()) {
 4182:         jsid lengthId = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
 4182: 
32573:         return obj->defineProperty(cx, lengthId, *vp, NULL, NULL, JSPROP_ENUMERATE);
 4182:     }
 4182: 
59234:     if (!ValueToLength(cx, vp, &newlen))
40221:         return false;
59234: 
40796:     oldlen = obj->getArrayLength();
11835: 
11835:     if (oldlen == newlen)
40221:         return true;
11835: 
48470:     vp->setNumber(newlen);
75720:     if (oldlen < newlen)
75720:         return obj->setArrayLength(cx, newlen);
64560: 
75919:     if (!cx->markTypeArrayShrank(obj->getType()))
75919:         return false;
11835: 
39928:     if (obj->isDenseArray()) {
48537:         /*
48537:          * Don't reallocate if we're not actually shrinking our slots. If we do
75625:          * shrink slots here, shrink the initialized length too.  This permits us
75625:          * us to disregard length when reading from arrays as long we are within
75625:          * the initialized capacity.
48537:          */
48551:         jsuint oldcap = obj->getDenseArrayCapacity();
55746:         if (oldcap > newlen)
55746:             obj->shrinkDenseArrayElements(cx, newlen);
75625:         jsuint oldinit = obj->getDenseArrayInitializedLength();
75900:         if (oldinit > newlen) {
75625:             obj->setDenseArrayInitializedLength(newlen);
75900:             if (!cx->typeInferenceEnabled())
75900:                 obj->backfillDenseArrayHoles();
75900:         }
11835:     } else if (oldlen - newlen < (1 << 24)) {
    1:         do {
    1:             --oldlen;
54169:             if (!JS_CHECK_OPERATION_LIMIT(cx)) {
75720:                 JS_ALWAYS_TRUE(obj->setArrayLength(cx, oldlen + 1));
40221:                 return false;
54169:             }
62396:             int deletion = DeleteArrayElement(cx, obj, oldlen, strict);
62396:             if (deletion <= 0) {
75720:                 JS_ALWAYS_TRUE(obj->setArrayLength(cx, oldlen + 1));
62396:                 return deletion >= 0;
54169:             }
    1:         } while (oldlen != newlen);
    1:     } else {
    1:         /*
    1:          * We are going to remove a lot of indexes in a presumably sparse
    1:          * array. So instead of looping through indexes between newlen and
    1:          * oldlen, we iterate through all properties and remove those that
11835:          * correspond to indexes in the half-open range [newlen, oldlen).  See
11835:          * bug 322135.
    1:          */
40221:         JSObject *iter = JS_NewPropertyIterator(cx, obj);
    1:         if (!iter)
40221:             return false;
    1: 
31501:         /* Protect iter against GC under JSObject::deleteProperty. */
48470:         AutoObjectRooter tvr(cx, iter);
40390: 
    1:         gap = oldlen - newlen;
    1:         for (;;) {
40390:             if (!JS_CHECK_OPERATION_LIMIT(cx) || !JS_NextProperty(cx, iter, &id))
40390:                 return false;
48470:             if (JSID_IS_VOID(id))
    1:                 break;
40390:             if (js_IdIsIndex(id, &index) && index - newlen < gap &&
54169:                 !obj->deleteProperty(cx, id, &junk, false)) {
40221:                 return false;
    1:             }
40390:         }
75720:     }
75720: 
75720:     return obj->setArrayLength(cx, newlen);
    1: }
    1: 
27483: /*
75625:  * We have only indexed properties up to initialized length, plus the
27483:  * length property. For all else, we delegate to the prototype.
27483:  */
27483: static inline bool
27483: IsDenseArrayId(JSContext *cx, JSObject *obj, jsid id)
27483: {
39928:     JS_ASSERT(obj->isDenseArray());
27483: 
27483:     uint32 i;
48470:     return JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
75625:            (js_IdIsIndex(id, &i) && i < obj->getDenseArrayInitializedLength() &&
48470:             !obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE));
27483: }
27483: 
    1: static JSBool
11835: array_lookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
11835:                      JSProperty **propp)
11835: {
39928:     if (!obj->isDenseArray())
11835:         return js_LookupProperty(cx, obj, id, objp, propp);
11835: 
27483:     if (IsDenseArrayId(cx, obj, id)) {
48470:         *propp = (JSProperty *) 1;  /* non-null to indicate found */
27483:         *objp = obj;
27483:         return JS_TRUE;
27483:     }
27483: 
39928:     JSObject *proto = obj->getProto();
11835:     if (!proto) {
11835:         *objp = NULL;
11835:         *propp = NULL;
11835:         return JS_TRUE;
    1:     }
31501:     return proto->lookupProperty(cx, id, objp, propp);
11835: }
11835: 
27483: JSBool
48470: js_GetDenseArrayElementValue(JSContext *cx, JSObject *obj, jsid id, Value *vp)
26820: {
48470:     JS_ASSERT(obj->isDenseArray());
27483: 
27483:     uint32 i;
27483:     if (!js_IdIsIndex(id, &i)) {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
48470:         vp->setNumber(obj->getArrayLength());
48470:         return JS_TRUE;
27483:     }
41782:     *vp = obj->getDenseArrayElement(i);
27483:     return JS_TRUE;
26820: }
26820: 
    1: static JSBool
56817: array_getProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
11835: {
11835:     uint32 i;
11835: 
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
48470:         vp->setNumber(obj->getArrayLength());
11835:         return JS_TRUE;
11835:     }
11835: 
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.protoAtom)) {
48470:         vp->setObjectOrNull(obj->getProto());
48470:         return JS_TRUE;
48470:     }
48470: 
39928:     if (!obj->isDenseArray())
11835:         return js_GetProperty(cx, obj, id, vp);
11835: 
75625:     if (!js_IdIsIndex(id, &i) || i >= obj->getDenseArrayInitializedLength() ||
48470:         obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
15601:         JSObject *obj2;
15601:         JSProperty *prop;
52503:         const Shape *shape;
15601: 
39928:         JSObject *proto = obj->getProto();
11835:         if (!proto) {
48470:             vp->setUndefined();
11835:             return JS_TRUE;
11835:         }
11835: 
48470:         vp->setUndefined();
19712:         if (js_LookupPropertyWithFlags(cx, proto, id, cx->resolveFlags,
19712:                                        &obj2, &prop) < 0)
15601:             return JS_FALSE;
15601: 
43290:         if (prop && obj2->isNative()) {
52503:             shape = (const Shape *) prop;
52503:             if (!js_NativeGet(cx, obj, obj2, shape, JSGET_METHOD_BARRIER, vp))
15601:                 return JS_FALSE;
15601:         }
15601:         return JS_TRUE;
11835:     }
11835: 
41782:     *vp = obj->getDenseArrayElement(i);
11835:     return JS_TRUE;
11835: }
11835: 
11835: static JSBool
48470: slowarray_addProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
    1:     jsuint index, length;
    1: 
    1:     if (!js_IdIsIndex(id, &index))
    1:         return JS_TRUE;
40796:     length = obj->getArrayLength();
75720:     if (index >= length && !obj->setArrayLength(cx, index + 1))
75720:         return false;
    1:     return JS_TRUE;
    1: }
    1: 
38633: static JSType
38633: array_typeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
    1: static JSBool
56760: array_setProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
    1: {
11835:     uint32 i;
11835: 
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom))
62395:         return array_length_setter(cx, obj, id, strict, vp);
11835: 
39928:     if (!obj->isDenseArray())
54169:         return js_SetProperty(cx, obj, id, vp, strict);
11835: 
58702:     do {
58702:         if (!js_IdIsIndex(id, &i))
58702:             break;
58702:         if (js_PrototypeHasIndexedProperties(cx, obj))
58702:             break;
58702: 
58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, i, 1);
58702:         if (result != JSObject::ED_OK) {
58702:             if (result == JSObject::ED_FAILED)
54169:                 return false;
58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
58702:             break;
11835:         }
11835: 
40796:         if (i >= obj->getArrayLength())
75720:             obj->setDenseArrayLength(i + 1);
41782:         obj->setDenseArrayElement(i, *vp);
54169:         return true;
58702:     } while (false);
58702: 
58702:     if (!obj->makeDenseArraySlow(cx))
58702:         return false;
58702:     return js_SetProperty(cx, obj, id, vp, strict);
11835: }
11835: 
25886: JSBool
25886: js_PrototypeHasIndexedProperties(JSContext *cx, JSObject *obj)
25883: {
25883:     /*
25888:      * Walk up the prototype chain and see if this indexed element already
25888:      * exists. If we hit the end of the prototype chain, it's safe to set the
25888:      * element on the original object.
25883:      */
32603:     while ((obj = obj->getProto()) != NULL) {
25883:         /*
25888:          * If the prototype is a non-native object (possibly a dense array), or
25888:          * a native object (possibly a slow array) that has indexed properties,
25888:          * return true.
25883:          */
40430:         if (!obj->isNative())
25888:             return JS_TRUE;
52503:         if (obj->isIndexed())
25883:             return JS_TRUE;
25883:     }
25883:     return JS_FALSE;
25883: }
25883: 
11835: static JSBool
48470: array_defineProperty(JSContext *cx, JSObject *obj, jsid id, const Value *value,
62395:                      PropertyOp getter, StrictPropertyOp setter, uintN attrs)
11835: {
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom))
11835:         return JS_TRUE;
11835: 
59891:     if (!obj->isDenseArray())
32573:         return js_DefineProperty(cx, obj, id, value, getter, setter, attrs);
59891: 
59891:     do {
59891:         uint32 i = 0;       // init to shut GCC up
59891:         bool isIndex = js_IdIsIndex(id, &i);
59891:         if (!isIndex || attrs != JSPROP_ENUMERATE)
59891:             break;
59891: 
59891:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, i, 1);
59891:         if (result != JSObject::ED_OK) {
59891:             if (result == JSObject::ED_FAILED)
59891:                 return false;
59891:             JS_ASSERT(result == JSObject::ED_SPARSE);
59891:             break;
11835:         }
11835: 
59891:         if (i >= obj->getArrayLength())
75720:             obj->setDenseArrayLength(i + 1);
59891:         obj->setDenseArrayElement(i, *value);
59891:         return true;
59891:     } while (false);
59891: 
59891:     if (!obj->makeDenseArraySlow(cx))
59891:         return false;
59891:     return js_DefineProperty(cx, obj, id, value, getter, setter, attrs);
11835: }
11835: 
11835: static JSBool
43290: array_getAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
11835: {
48470:     *attrsp = JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)
11835:         ? JSPROP_PERMANENT : JSPROP_ENUMERATE;
11835:     return JS_TRUE;
11835: }
11835: 
11835: static JSBool
43290: array_setAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
11835: {
11835:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
11835:                          JSMSG_CANT_SET_ARRAY_ATTRS);
11835:     return JS_FALSE;
11835: }
11835: 
11835: static JSBool
54169: array_deleteProperty(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
11835: {
11835:     uint32 i;
11835: 
39928:     if (!obj->isDenseArray())
54169:         return js_DeleteProperty(cx, obj, id, rval, strict);
11835: 
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
48470:         rval->setBoolean(false);
11835:         return JS_TRUE;
11835:     }
11835: 
75625:     if (js_IdIsIndex(id, &i) && i < obj->getDenseArrayInitializedLength()) {
75720:         if (!obj->setDenseArrayNotPacked(cx))
75720:             return false;
48470:         obj->setDenseArrayElement(i, MagicValue(JS_ARRAY_HOLE));
75625:     }
11835: 
43281:     if (!js_SuppressDeletedProperty(cx, obj, id))
43281:         return false;
43281: 
48470:     rval->setBoolean(true);
11835:     return JS_TRUE;
11835: }
11835: 
11835: static void
11835: array_trace(JSTracer *trc, JSObject *obj)
11835: {
37003:     JS_ASSERT(obj->isDenseArray());
11835: 
75657:     uint32 capacity = obj->getDenseArrayInitializedLength();
75935:     MarkValueRange(trc, capacity, obj->getDenseArrayElements(), "element");
11835: }
11835: 
56593: static JSBool
54563: array_fix(JSContext *cx, JSObject *obj, bool *success, AutoIdVector *props)
54563: {
54563:     JS_ASSERT(obj->isDenseArray());
54563: 
54563:     /*
54563:      * We must slowify dense arrays; otherwise, we'd need to detect assignments to holes,
54563:      * since that is effectively adding a new property to the array.
54563:      */
54563:     if (!obj->makeDenseArraySlow(cx) ||
54563:         !GetPropertyNames(cx, obj, JSITER_HIDDEN | JSITER_OWNONLY, props))
54563:         return false;
54563: 
54563:     *success = true;
54563:     return true;
54563: }
54563: 
48622: Class js_ArrayClass = {
48622:     "Array",
48622:     Class::NON_NATIVE |
55746:     JSCLASS_HAS_PRIVATE |
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Array),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     js_TryValueOf,
55746:     NULL,
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
64223:     array_trace,    /* trace       */
48622:     JS_NULL_CLASS_EXT,
48622:     {
43290:         array_lookupProperty,
43290:         array_defineProperty,
43290:         array_getProperty,
43290:         array_setProperty,
43290:         array_getAttributes,
43290:         array_setAttributes,
43290:         array_deleteProperty,
48622:         NULL,       /* enumerate      */
43290:         array_typeOf,
54563:         array_fix,
43290:         NULL,       /* thisObject     */
48622:         NULL,       /* clear          */
    1:     }
    1: };
    1: 
48470: Class js_SlowArrayClass = {
11835:     "Array",
50489:     JSCLASS_HAS_PRIVATE |
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Array),
48622:     slowarray_addProperty,
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
59216:     js_TryValueOf
    1: };
    1: 
62076: static bool
62076: AddLengthProperty(JSContext *cx, JSObject *obj)
62076: {
62076:     const jsid lengthId = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
62076:     JS_ASSERT(!obj->nativeLookup(lengthId));
62076: 
62076:     return obj->addProperty(cx, lengthId, array_length_getter, array_length_setter,
62076:                             SHAPE_INVALID_SLOT, JSPROP_PERMANENT | JSPROP_SHARED, 0, 0);
62076: }
62076: 
11835: /*
11835:  * Convert an array object from fast-and-dense to slow-and-flexible.
11835:  */
15602: JSBool
43287: JSObject::makeDenseArraySlow(JSContext *cx)
11835: {
43287:     JS_ASSERT(isDenseArray());
32652: 
75720:     if (!cx->markTypeArrayNotPacked(getType(), true))
75720:         return false;
75720:     JS_ALWAYS_TRUE(setDenseArrayNotPacked(cx));
75625: 
32652:     /*
52503:      * Save old map now, before calling InitScopeForObject. We'll have to undo
75940:      * on error. This is gross, but a better way is not obvious. Note: the
75940:      * exact contents of the array are not preserved on error.
52503:      */
52503:     JSObjectMap *oldMap = map;
52503: 
57821:     /* Create a native scope. */
57821:     js::gc::FinalizeKind kind = js::gc::FinalizeKind(arena()->header()->thingKind);
75679:     if (!InitScopeForObject(cx, this, &js_SlowArrayClass, getType(), kind))
52503:         return false;
11835: 
75935:     backfillDenseArrayHoles();
75935: 
75935:     uint32 arrayCapacity = getDenseArrayCapacity();
75940:     uint32 arrayInitialized = getDenseArrayInitializedLength();
75935: 
75935:     /*
75935:      * Adjust the slots to account for the different layout between dense
75935:      * arrays and other objects. The slots must be dynamic, and the fixed slots
75935:      * are now available for newly added properties.
75935:      */
75935:     if (denseArrayHasInlineSlots()) {
75935:         if (!allocSlots(cx, numSlots())) {
75935:             setMap(oldMap);
75935:             return false;
75935:         }
75935:         JS_ASSERT(!denseArrayHasInlineSlots());
75935:     }
75935:     capacity = numFixedSlots() + arrayCapacity;
75935:     clasp = &js_SlowArrayClass;
55746: 
75940:     /* The initialized length is used iff this is a dense array. */
75940:     initializedLength = 0;
75940:     JS_ASSERT(newType == NULL);
75940: 
48641:     /*
55746:      * Begin with the length property to share more of the property tree.
55746:      * The getter/setter here will directly access the object's private value.
48641:      */
62076:     if (!AddLengthProperty(cx, this)) {
52503:         setMap(oldMap);
75935:         capacity = arrayCapacity;
75940:         initializedLength = arrayInitialized;
75935:         clasp = &js_ArrayClass;
52503:         return false;
43287:     }
43287: 
57821:     /*
57821:      * Create new properties pointing to existing elements. Pack the array to
57821:      * remove holes, so that shapes use successive slots (as for other objects).
57821:      */
57821:     uint32 next = 0;
75935:     for (uint32 i = 0; i < arrayCapacity; i++) {
75935:         /* Dense array indexes can always fit in a jsid. */
11835:         jsid id;
75935:         JS_ALWAYS_TRUE(ValueToId(cx, Int32Value(i), &id));
75935: 
75935:         if (slots[i].isMagic(JS_ARRAY_HOLE))
11835:             continue;
57821: 
75935:         setSlot(next, slots[i]);
57821: 
57821:         if (!addDataProperty(cx, id, next, JSPROP_ENUMERATE)) {
52503:             setMap(oldMap);
75935:             capacity = arrayCapacity;
75940:             initializedLength = arrayInitialized;
75935:             clasp = &js_ArrayClass;
52503:             return false;
52503:         }
57821: 
57821:         next++;
11835:     }
11835: 
75935:     clearSlotRange(next, capacity - next);
75935: 
18712:     /*
52513:      * Finally, update class. If |this| is Array.prototype, then js_InitClass
52513:      * will create an emptyShape whose class is &js_SlowArrayClass, to ensure
52513:      * that delegating instances can share shapes in the tree rooted at the
52513:      * proto's empty shape.
52513:      */
52503:     return true;
11835: }
11835: 
30023: /* Transfer ownership of buffer to returned string. */
31477: static inline JSBool
60571: BufferToString(JSContext *cx, StringBuffer &sb, Value *rval)
30023: {
60571:     JSString *str = sb.finishString();
31477:     if (!str)
31477:         return false;
48470:     rval->setString(str);
31477:     return true;
30023: }
30023: 
30023: #if JS_HAS_TOSOURCE
30023: static JSBool
48470: array_toSource(JSContext *cx, uintN argc, Value *vp)
30023: {
31477:     JS_CHECK_RECURSION(cx, return false);
30023: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
31477:         return false;
61734:     if (!obj->isSlowArray() && !InstanceOf(cx, obj, &js_ArrayClass, vp + 2))
61734:         return false;
30023: 
30023:     /* Find joins or cycles in the reachable object graph. */
30023:     jschar *sharpchars;
30023:     JSHashEntry *he = js_EnterSharpObject(cx, obj, NULL, &sharpchars);
30023:     if (!he)
31477:         return false;
31477:     bool initiallySharp = IS_SHARP(he);
31477: 
31477:     /* After this point, all paths exit through the 'out' label. */
31477:     MUST_FLOW_THROUGH("out");
31477:     bool ok = false;
30021: 
30021:     /*
30023:      * This object will take responsibility for the jschar buffer until the
30023:      * buffer is transferred to the returned JSString.
30021:      */
60571:     StringBuffer sb(cx);
30023: 
30023:     /* Cycles/joins are indicated by sharp objects. */
30023: #if JS_HAS_SHARP_VARS
30023:     if (IS_SHARP(he)) {
30023:         JS_ASSERT(sharpchars != 0);
60571:         sb.replaceRawBuffer(sharpchars, js_strlen(sharpchars));
30023:         goto make_string;
30023:     } else if (sharpchars) {
30023:         MAKE_SHARP(he);
60571:         sb.replaceRawBuffer(sharpchars, js_strlen(sharpchars));
30023:     }
30023: #else
30023:     if (IS_SHARP(he)) {
60571:         if (!sb.append("[]"))
31477:             goto out;
64560:         cx->free_(sharpchars);
30023:         goto make_string;
30023:     }
30023: #endif
30023: 
60571:     if (!sb.append('['))
31477:         goto out;
30023: 
30023:     jsuint length;
31477:     if (!js_GetLengthProperty(cx, obj, &length))
31477:         goto out;
30023: 
30023:     for (jsuint index = 0; index < length; index++) {
30023:         /* Use vp to locally root each element value. */
30023:         JSBool hole;
31477:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:             !GetElement(cx, obj, index, &hole, vp)) {
31477:             goto out;
31477:         }
30023: 
30023:         /* Get element's character string. */
30023:         JSString *str;
30023:         if (hole) {
    1:             str = cx->runtime->emptyString;
    1:         } else {
30023:             str = js_ValueToSource(cx, *vp);
31477:             if (!str)
31477:                 goto out;
30023:         }
48470:         vp->setString(str);
59890: 
59890:         const jschar *chars = str->getChars(cx);
59890:         if (!chars)
59890:             goto out;
30023: 
30023:         /* Append element to buffer. */
60571:         if (!sb.append(chars, chars + str->length()))
31477:             goto out;
30023:         if (index + 1 != length) {
60571:             if (!sb.append(", "))
31477:                 goto out;
30023:         } else if (hole) {
60571:             if (!sb.append(','))
31477:                 goto out;
30023:         }
30023:     }
30023: 
30023:     /* Finalize the buffer. */
60571:     if (!sb.append(']'))
31477:         goto out;
30023: 
30023:   make_string:
60571:     if (!BufferToString(cx, sb, vp))
31477:         goto out;
31477: 
31477:     ok = true;
31477: 
31477:   out:
30023:     if (!initiallySharp)
30023:         js_LeaveSharpObject(cx, NULL);
30023:     return ok;
30023: }
30023: #endif
30023: 
30023: static JSBool
30023: array_toString_sub(JSContext *cx, JSObject *obj, JSBool locale,
48470:                    JSString *sepstr, Value *rval)
30023: {
31477:     JS_CHECK_RECURSION(cx, return false);
30023: 
59890:     /* Get characters to use for the separator. */
59890:     static const jschar comma = ',';
59890:     const jschar *sep;
59890:     size_t seplen;
59890:     if (sepstr) {
59890:         seplen = sepstr->length();
59890:         sep = sepstr->getChars(cx);
59890:         if (!sep)
59890:             return false;
59890:     } else {
59890:         sep = &comma;
59890:         seplen = 1;
59890:     }
59890: 
51451:     /*
51451:      * Use HashTable entry as the cycle indicator. On first visit, create the
51451:      * entry, and, when leaving, remove the entry.
51451:      */
61229:     BusyArraysMap::AddPtr hashp = cx->busyArrays.lookupForAdd(obj);
51451:     uint32 genBefore;
51451:     if (!hashp) {
51451:         /* Not in hash table, so not a cycle. */
59890:         if (!cx->busyArrays.add(hashp, obj))
51451:             return false;
51451:         genBefore = cx->busyArrays.generation();
51451:     } else {
51451:         /* Cycle, so return empty string. */
64345:         rval->setString(cx->runtime->atomState.emptyAtom);
31477:         return true;
30023:     }
30023: 
48470:     AutoObjectRooter tvr(cx, obj);
30023: 
51451:     /* After this point, all paths exit through the 'out' label. */
51451:     MUST_FLOW_THROUGH("out");
51451:     bool ok = false;
51451: 
30023:     /*
30023:      * This object will take responsibility for the jschar buffer until the
30023:      * buffer is transferred to the returned JSString.
30023:      */
60571:     StringBuffer sb(cx);
30023: 
30023:     jsuint length;
31477:     if (!js_GetLengthProperty(cx, obj, &length))
51451:         goto out;
51451: 
51451:     for (jsuint index = 0; index < length; index++) {
51451:         /* Use rval to locally root each element value. */
51451:         JSBool hole;
51451:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:             !GetElement(cx, obj, index, &hole, rval)) {
51451:             goto out;
51448:         }
51451: 
51451:         /* Get element's character string. */
67921:         if (!hole && !rval->isNullOrUndefined()) {
51451:             if (locale) {
51451:                 /* Work on obj.toLocalString() instead. */
67921:                 JSObject *robj = ToObject(cx, rval);
67921:                 if (!robj)
51451:                     goto out;
67921:                 jsid id = ATOM_TO_JSID(cx->runtime->atomState.toLocaleStringAtom);
67921:                 if (!robj->callMethod(cx, id, 0, NULL, rval))
51451:                     goto out;
51448:             }
51451: 
60571:             if (!ValueToStringBuffer(cx, *rval, sb))
51451:                 goto out;
    1:         }
30023: 
30023:         /* Append the separator. */
30023:         if (index + 1 != length) {
60571:             if (!sb.append(sep, seplen))
51451:                 goto out;
    1:         }
30023:     }
30023: 
30023:     /* Finalize the buffer. */
60571:     if (!BufferToString(cx, sb, rval))
51451:         goto out;
51451: 
51451:     ok = true;
51451: 
51451:   out:
51451:     if (genBefore == cx->busyArrays.generation())
51451:         cx->busyArrays.remove(hashp);
51451:     else
51451:         cx->busyArrays.remove(obj);
51451:     return ok;
    1: }
    1: 
48486: /* ES5 15.4.4.2. NB: The algorithm here differs from the one in ES3. */
    1: static JSBool
48470: array_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
48486:     if (!obj)
48486:         return false;
48486: 
48486:     Value &join = vp[0];
48486:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.joinAtom), &join))
48486:         return false;
48486: 
48486:     if (!js_IsCallable(join)) {
48486:         JSString *str = obj_toStringHelper(cx, obj);
48486:         if (!str)
48486:             return false;
48486:         vp->setString(str);
48486:         return true;
    1:     }
30023: 
48486:     LeaveTrace(cx);
48486:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, 0, &args))
48486:         return false;
48486: 
50468:     args.callee() = join;
50468:     args.thisv().setObject(*obj);
48486: 
48486:     /* Do the call. */
48486:     if (!Invoke(cx, args, 0))
48486:         return false;
50468:     *vp = args.rval();
48486:     return true;
    1: }
    1: 
    1: static JSBool
48470: array_toLocaleString(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
48486:     if (!obj)
48486:         return false;
 3287: 
    1:     /*
    1:      *  Passing comma here as the separator. Need a way to get a
    1:      *  locale-specific version.
    1:      */
30023:     return array_toString_sub(cx, obj, JS_TRUE, NULL, vp);
    1: }
    1: 
75732: static inline bool
75732: InitArrayTypes(JSContext *cx, TypeObject *type, const Value *vector, unsigned count)
75732: {
75919:     if (cx->typeInferenceEnabled() && !type->unknownProperties()) {
75732:         AutoEnterTypeInference enter(cx);
75732: 
75732:         TypeSet *types = type->getProperty(cx, JSID_VOID, true);
75732:         if (!types)
75732:             return JS_FALSE;
75732: 
75732:         for (unsigned i = 0; i < count; i++) {
75732:             if (vector[i].isMagic(JS_ARRAY_HOLE))
75732:                 continue;
75732:             jstype valtype = GetValueType(cx, vector[i]);
75732:             types->addType(cx, valtype);
75732:         }
75732: 
75732:         return cx->compartment->types.checkPendingRecompiles(cx);
75732:     }
75732:     return true;
75732: }
75732: 
    1: static JSBool
75732: InitArrayElements(JSContext *cx, JSObject *obj, jsuint start, jsuint count, Value *vector, bool updateTypes)
    1: {
26564:     JS_ASSERT(count < MAXINDEX);
28242: 
75625:     if (count == 0)
75625:         return JS_TRUE;
75625: 
75732:     if (updateTypes && !InitArrayTypes(cx, obj->getType(), vector, count))
75732:         return JS_FALSE;
75732: 
26564:     /*
26564:      * Optimize for dense arrays so long as adding the given set of elements
26564:      * wouldn't otherwise make the array slow.
26564:      */
58702:     do {
58702:         if (!obj->isDenseArray())
58702:             break;
58702:         if (js_PrototypeHasIndexedProperties(cx, obj))
58702:             break;
58702: 
58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, start, count);
58702:         if (result != JSObject::ED_OK) {
58702:             if (result == JSObject::ED_FAILED)
58702:                 return false;
58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
58702:             break;
58702:         }
26564:         jsuint newlen = start + count;
40796:         if (newlen > obj->getArrayLength())
75720:             obj->setDenseArrayLength(newlen);
26564: 
48470:         JS_ASSERT(count < uint32(-1) / sizeof(Value));
41782:         memcpy(obj->getDenseArrayElements() + start, vector, sizeof(jsval) * count);
48470:         JS_ASSERT_IF(count != 0, !obj->getDenseArrayElement(newlen - 1).isMagic(JS_ARRAY_HOLE));
58702:         return true;
58702:     } while (false);
11835: 
48470:     Value* end = vector + count;
26564:     while (vector != end && start < MAXINDEX) {
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
    1:             !SetArrayElement(cx, obj, start++, *vector++)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
26564: 
26564:     if (vector == end)
26564:         return JS_TRUE;
26564: 
26564:     /* Finish out any remaining elements past the max array index. */
39928:     if (obj->isDenseArray() && !ENSURE_SLOW_ARRAY(cx, obj))
26564:         return JS_FALSE;
26564: 
26564:     JS_ASSERT(start == MAXINDEX);
48470:     AutoValueRooter tvr(cx);
40390:     AutoIdRooter idr(cx);
48470:     Value idval = DoubleValue(MAXINDEX);
26564:     do {
48470:         *tvr.addr() = *vector++;
48470:         if (!js_ValueToStringId(cx, idval, idr.addr()) ||
54169:             !obj->setProperty(cx, idr.id(), tvr.addr(), true)) {
26564:             return JS_FALSE;
26564:         }
48470:         idval.getDoubleRef() += 1;
26564:     } while (vector != end);
26564: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48537: InitArrayObject(JSContext *cx, JSObject *obj, jsuint length, const Value *vector)
    1: {
39928:     JS_ASSERT(obj->isArray());
11835: 
41838:     JS_ASSERT(obj->isDenseArray());
75720:     if (!obj->setArrayLength(cx, length))
75720:         return false;
48551:     if (!vector || !length)
48604:         return true;
58702: 
75732:     if (!InitArrayTypes(cx, obj->getType(), vector, length))
75732:         return false;
75732: 
58702:     /* Avoid ensureDenseArrayElements to skip sparse array checks there. */
58702:     if (!obj->ensureSlots(cx, length))
48551:         return false;
75927: 
75927:     if (cx->typeInferenceEnabled())
75625:         obj->setDenseArrayInitializedLength(length);
75927:     else
75927:         obj->backfillDenseArrayHoles();
75927: 
75720:     bool hole = false;
75625:     for (jsuint i = 0; i < length; i++) {
75625:         obj->setDenseArrayElement(i, vector[i]);
75720:         hole |= vector[i].isMagic(JS_ARRAY_HOLE);
75720:     }
75720:     if (hole && !obj->setDenseArrayNotPacked(cx))
75720:         return false;
75927: 
48551:     return true;
    1: }
    1: 
    1: /*
    1:  * Perl-inspired join, reverse, and sort.
    1:  */
20408: static JSBool
48470: array_join(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
48470:     if (argc == 0 || vp[2].isUndefined()) {
    1:         str = NULL;
    1:     } else {
 4127:         str = js_ValueToString(cx, vp[2]);
    1:         if (!str)
    1:             return JS_FALSE;
48470:         vp[2].setString(str);
    1:     }
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     return array_toString_sub(cx, obj, JS_FALSE, str, vp);
    1: }
    1: 
    1: static JSBool
48470: array_reverse(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
33178:     jsuint len;
61734:     if (!js_GetLengthProperty(cx, obj, &len))
61734:         return false;
48470:     vp->setObject(*obj);
28242: 
58702:     do {
58702:         if (!obj->isDenseArray())
58702:             break;
58702:         if (js_PrototypeHasIndexedProperties(cx, obj))
58702:             break;
58702:         
28242:         /* An empty array or an array with no elements is already reversed. */
41782:         if (len == 0 || obj->getDenseArrayCapacity() == 0)
61734:             return true;
28242: 
28242:         /*
28242:          * It's actually surprisingly complicated to reverse an array due to the
28242:          * orthogonality of array length and array capacity while handling
28242:          * leading and trailing holes correctly.  Reversing seems less likely to
28242:          * be a common operation than other array mass-mutation methods, so for
28242:          * now just take a probably-small memory hit (in the absence of too many
28242:          * holes in the array at its start) and ensure that the capacity is
28242:          * sufficient to hold all the elements in the array if it were full.
28242:          */
58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, len, 0);
58702:         if (result != JSObject::ED_OK) {
58702:             if (result == JSObject::ED_FAILED)
58702:                 return false;
58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
58702:             break;
58702:         }
28242: 
75625:         /* Fill out the array's initialized length to its proper length. */
75625:         jsuint initlen = obj->getDenseArrayInitializedLength();
75625:         if (len > initlen) {
75927:             JS_ASSERT(cx->typeInferenceEnabled());
75720:             if (!obj->setDenseArrayNotPacked(cx))
75720:                 return false;
75625:             ClearValueRange(obj->getDenseArrayElements() + initlen, len - initlen, true);
75625:             obj->setDenseArrayInitializedLength(len);
75625:         }
75625: 
41782:         uint32 lo = 0, hi = len - 1;
28242:         for (; lo < hi; lo++, hi--) {
61434:             Value origlo = obj->getDenseArrayElement(lo);
61434:             Value orighi = obj->getDenseArrayElement(hi);
61434:             obj->setDenseArrayElement(lo, orighi);
61434:             if (orighi.isMagic(JS_ARRAY_HOLE) &&
61434:                 !js_SuppressDeletedProperty(cx, obj, INT_TO_JSID(lo))) {
61434:                 return false;
61434:             }
61434:             obj->setDenseArrayElement(hi, origlo);
61434:             if (origlo.isMagic(JS_ARRAY_HOLE) &&
61434:                 !js_SuppressDeletedProperty(cx, obj, INT_TO_JSID(hi))) {
61434:                 return false;
61434:             }
28242:         }
28242: 
28242:         /*
28242:          * Per ECMA-262, don't update the length of the array, even if the new
28242:          * array has trailing holes (and thus the original array began with
28242:          * holes).
28242:          */
61434:         return true;
58702:     } while (false);
    1: 
40390:     AutoValueRooter tvr(cx);
33178:     for (jsuint i = 0, half = len / 2; i < half; i++) {
33178:         JSBool hole, hole2;
33178:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:             !GetElement(cx, obj, i, &hole, tvr.addr()) ||
57714:             !GetElement(cx, obj, len - i - 1, &hole2, vp) ||
33178:             !SetOrDeleteArrayElement(cx, obj, len - i - 1, hole, tvr.value()) ||
33178:             !SetOrDeleteArrayElement(cx, obj, i, hole2, *vp)) {
33178:             return false;
33178:         }
33178:     }
48470:     vp->setObject(*obj);
33178:     return true;
    1: }
    1: 
    1: typedef struct MSortArgs {
    1:     size_t       elsize;
    1:     JSComparator cmp;
    1:     void         *arg;
48470:     JSBool       isValue;
    1: } MSortArgs;
    1: 
    1: /* Helper function for js_MergeSort. */
29887: static JSBool
    1: MergeArrays(MSortArgs *msa, void *src, void *dest, size_t run1, size_t run2)
    1: {
    1:     void *arg, *a, *b, *c;
    1:     size_t elsize, runtotal;
    1:     int cmp_result;
    1:     JSComparator cmp;
48470:     JSBool isValue;
    1: 
    1:     runtotal = run1 + run2;
    1: 
    1:     elsize = msa->elsize;
    1:     cmp = msa->cmp;
    1:     arg = msa->arg;
48470:     isValue = msa->isValue;
    1: 
    1: #define CALL_CMP(a, b) \
    1:     if (!cmp(arg, (a), (b), &cmp_result)) return JS_FALSE;
    1: 
    1:     /* Copy runs already in sorted order. */
    1:     b = (char *)src + run1 * elsize;
    1:     a = (char *)b - elsize;
    1:     CALL_CMP(a, b);
    1:     if (cmp_result <= 0) {
    1:         memcpy(dest, src, runtotal * elsize);
    1:         return JS_TRUE;
    1:     }
    1: 
    1: #define COPY_ONE(p,q,n) \
48470:     (isValue ? (void)(*(Value*)p = *(Value*)q) : (void)memcpy(p, q, n))
    1: 
    1:     a = src;
    1:     c = dest;
    1:     for (; runtotal != 0; runtotal--) {
    1:         JSBool from_a = run2 == 0;
    1:         if (!from_a && run1 != 0) {
    1:             CALL_CMP(a,b);
    1:             from_a = cmp_result <= 0;
    1:         }
    1: 
    1:         if (from_a) {
    1:             COPY_ONE(c, a, elsize);
    1:             run1--;
    1:             a = (char *)a + elsize;
    1:         } else {
    1:             COPY_ONE(c, b, elsize);
    1:             run2--;
    1:             b = (char *)b + elsize;
    1:         }
    1:         c = (char *)c + elsize;
    1:     }
    1: #undef COPY_ONE
    1: #undef CALL_CMP
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * This sort is stable, i.e. sequence of equal elements is preserved.
    1:  * See also bug #224128.
    1:  */
48470: bool
    1: js_MergeSort(void *src, size_t nel, size_t elsize,
48470:              JSComparator cmp, void *arg, void *tmp,
48470:              JSMergeSortElemType elemType)
    1: {
    1:     void *swap, *vec1, *vec2;
    1:     MSortArgs msa;
    1:     size_t i, j, lo, hi, run;
    1:     int cmp_result;
    1: 
48470:     JS_ASSERT_IF(JS_SORTING_VALUES, elsize == sizeof(Value));
48470:     bool isValue = elemType == JS_SORTING_VALUES;
48470: 
 9015:     /* Avoid memcpy overhead for word-sized and word-aligned elements. */
    1: #define COPY_ONE(p,q,n) \
48470:     (isValue ? (void)(*(Value*)p = *(Value*)q) : (void)memcpy(p, q, n))
    1: #define CALL_CMP(a, b) \
    1:     if (!cmp(arg, (a), (b), &cmp_result)) return JS_FALSE;
    1: #define INS_SORT_INT 4
    1: 
    1:     /*
    1:      * Apply insertion sort to small chunks to reduce the number of merge
    1:      * passes needed.
    1:      */
    1:     for (lo = 0; lo < nel; lo += INS_SORT_INT) {
    1:         hi = lo + INS_SORT_INT;
    1:         if (hi >= nel)
    1:             hi = nel;
    1:         for (i = lo + 1; i < hi; i++) {
    1:             vec1 = (char *)src + i * elsize;
    1:             vec2 = (char *)vec1 - elsize;
    1:             for (j = i; j > lo; j--) {
    1:                 CALL_CMP(vec2, vec1);
    1:                 /* "<=" instead of "<" insures the sort is stable */
    1:                 if (cmp_result <= 0) {
    1:                     break;
    1:                 }
    1: 
    1:                 /* Swap elements, using "tmp" as tmp storage */
    1:                 COPY_ONE(tmp, vec2, elsize);
    1:                 COPY_ONE(vec2, vec1, elsize);
    1:                 COPY_ONE(vec1, tmp, elsize);
    1:                 vec1 = vec2;
    1:                 vec2 = (char *)vec1 - elsize;
    1:             }
    1:         }
    1:     }
    1: #undef CALL_CMP
    1: #undef COPY_ONE
    1: 
    1:     msa.elsize = elsize;
    1:     msa.cmp = cmp;
    1:     msa.arg = arg;
48470:     msa.isValue = isValue;
    1: 
    1:     vec1 = src;
    1:     vec2 = tmp;
    1:     for (run = INS_SORT_INT; run < nel; run *= 2) {
    1:         for (lo = 0; lo < nel; lo += 2 * run) {
    1:             hi = lo + run;
    1:             if (hi >= nel) {
    1:                 memcpy((char *)vec2 + lo * elsize, (char *)vec1 + lo * elsize,
    1:                        (nel - lo) * elsize);
    1:                 break;
    1:             }
    1:             if (!MergeArrays(&msa, (char *)vec1 + lo * elsize,
    1:                              (char *)vec2 + lo * elsize, run,
    1:                              hi + run > nel ? nel - hi : run)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         swap = vec1;
    1:         vec1 = vec2;
    1:         vec2 = swap;
    1:     }
    1:     if (src != vec1)
    1:         memcpy(src, tmp, nel * elsize);
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
42714: struct CompareArgs
42714: {
    1:     JSContext          *context;
55565:     InvokeSessionGuard session;
55565: 
55565:     CompareArgs(JSContext *cx)
55565:       : context(cx)
42714:     {}
42714: };
    1: 
24499: static JS_REQUIRES_STACK JSBool
    1: sort_compare(void *arg, const void *a, const void *b, int *result)
    1: {
48470:     const Value *av = (const Value *)a, *bv = (const Value *)b;
    1:     CompareArgs *ca = (CompareArgs *) arg;
    1:     JSContext *cx = ca->context;
42714: 
42714:     /*
    1:      * array_sort deals with holes and undefs on its own and they should not
    1:      * come here.
    1:      */
48470:     JS_ASSERT(!av->isMagic() && !av->isUndefined());
48470:     JS_ASSERT(!av->isMagic() && !bv->isUndefined());
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return JS_FALSE;
    1: 
55565:     InvokeSessionGuard &session = ca->session;
55565:     session[0] = *av;
55565:     session[1] = *bv;
55565: 
55565:     if (!session.invoke(cx))
 8439:         return JS_FALSE;
12694: 
40828:     jsdouble cmp;
55565:     if (!ValueToNumber(cx, session.rval(), &cmp))
12694:         return JS_FALSE;
    1: 
    1:     /* Clamp cmp to -1, 0, 1. */
    1:     *result = 0;
 8439:     if (!JSDOUBLE_IS_NaN(cmp) && cmp != 0)
 8439:         *result = cmp > 0 ? 1 : -1;
 8439: 
    1:     /*
 8439:      * XXX else report some kind of error here?  ECMA talks about 'consistent
 8439:      * compare functions' that don't return NaN, but is silent about what the
 8439:      * result should be.  So we currently ignore it.
    1:      */
 8439: 
 8439:     return JS_TRUE;
    1: }
    1: 
29885: typedef JSBool (JS_REQUIRES_STACK *JSRedComparator)(void*, const void*,
29885:                                                     const void*, int *);
29885: 
29885: static inline JS_IGNORE_STACK JSComparator
29885: comparator_stack_cast(JSRedComparator func)
29885: {
29885:     return func;
29885: }
29885: 
    1: static int
    1: sort_compare_strings(void *arg, const void *a, const void *b, int *result)
    1: {
59890:     JSContext *cx = (JSContext *)arg;
59890:     JSString *astr = ((const Value *)a)->toString();
59890:     JSString *bstr = ((const Value *)b)->toString();
59890:     return JS_CHECK_OPERATION_LIMIT(cx) && CompareStrings(cx, astr, bstr, result);
    1: }
    1: 
48676: JSBool
48676: js::array_sort(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsuint len, newlen, i, undefs;
 9015:     size_t elemsize;
 9015:     JSString *str;
    1: 
48470:     Value *argv = JS_ARGV(cx, vp);
48470:     Value fval;
56555:     if (argc > 0 && !argv[0].isUndefined()) {
48470:         if (argv[0].isPrimitive()) {
40390:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_SORT_ARG);
40390:             return false;
    1:         }
 9015:         fval = argv[0];     /* non-default compare function */
    1:     } else {
48470:         fval.setNull();
    1:     }
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     if (!js_GetLengthProperty(cx, obj, &len))
40390:         return false;
    1:     if (len == 0) {
48470:         vp->setObject(*obj);
40390:         return true;
    1:     }
    1: 
    1:     /*
48470:      * We need a temporary array of 2 * len Value to hold the array elements
 9015:      * and the scratch space for merge sort. Check that its size does not
 9015:      * overflow size_t, which would allow for indexing beyond the end of the
 9015:      * malloc'd vector.
    1:      */
 9975: #if JS_BITS_PER_WORD == 32
48470:     if (size_t(len) > size_t(-1) / (2 * sizeof(Value))) {
12983:         js_ReportAllocationOverflow(cx);
40390:         return false;
    1:     }
 9975: #endif
    1: 
    1:     /*
    1:      * Initialize vec as a root. We will clear elements of vec one by
40390:      * one while increasing the rooted amount of vec when we know that the
40390:      * property at the corresponding index exists and its value must be rooted.
    1:      *
    1:      * In this way when sorting a huge mostly sparse array we will not
    1:      * access the tail of vec corresponding to properties that do not
    1:      * exist, allowing OS to avoiding committing RAM. See bug 330812.
    1:      */
40390:     {
64560:         Value *vec = (Value *) cx->malloc_(2 * size_t(len) * sizeof(Value));
40390:         if (!vec)
40390:             return false;
40390: 
48470:         DEFINE_LOCAL_CLASS_OF_STATIC_FUNCTION(AutoFreeVector) {
48470:             JSContext *const cx;
48470:             Value *&vec;
48470:            public:
48470:             AutoFreeVector(JSContext *cx, Value *&vec) : cx(cx), vec(vec) { }
40390:             ~AutoFreeVector() {
64560:                 cx->free_(vec);
40390:             }
64560:         } free_(cx, vec);
40390: 
40390:         AutoArrayRooter tvr(cx, 0, vec);
    1: 
    1:         /*
    1:          * By ECMA 262, 15.4.4.11, a property that does not exist (which we
    1:          * call a "hole") is always greater than an existing property with
    1:          * value undefined and that is always greater than any other property.
    1:          * Thus to sort holes and undefs we simply count them, sort the rest
    1:          * of elements, append undefs after them and then make holes after
    1:          * undefs.
    1:          */
    1:         undefs = 0;
    1:         newlen = 0;
40390:         bool allStrings = true;
    1:         for (i = 0; i < len; i++) {
40390:             if (!JS_CHECK_OPERATION_LIMIT(cx))
40390:                 return false;
    1: 
    1:             /* Clear vec[newlen] before including it in the rooted set. */
40390:             JSBool hole;
48470:             vec[newlen].setNull();
40390:             tvr.changeLength(newlen + 1);
57714:             if (!GetElement(cx, obj, i, &hole, &vec[newlen]))
40390:                 return false;
    1: 
    1:             if (hole)
    1:                 continue;
    1: 
48470:             if (vec[newlen].isUndefined()) {
    1:                 ++undefs;
    1:                 continue;
    1:             }
    1: 
48470:             allStrings = allStrings && vec[newlen].isString();
    1: 
    1:             ++newlen;
    1:         }
    1: 
58691:         if (newlen == 0) {
58691:             vp->setObject(*obj);
40390:             return true; /* The array has only holes and undefs. */
58691:         }
 9015: 
    1:         /*
 9015:          * The first newlen elements of vec are copied from the array object
 9015:          * (above). The remaining newlen positions are used as GC-rooted scratch
 9015:          * space for mergesort. We must clear the space before including it to
48470:          * the root set covered by tvr.count.
    1:          */
48470:         Value *mergesort_tmp = vec + newlen;
62363:         MakeRangeGCSafe(mergesort_tmp, newlen);
40390:         tvr.changeLength(newlen * 2);
    1: 
    1:         /* Here len == 2 * (newlen + undefs + number_of_holes). */
48470:         if (fval.isNull()) {
 9015:             /*
 9015:              * Sort using the default comparator converting all elements to
 9015:              * strings.
 9015:              */
40390:             if (allStrings) {
48470:                 elemsize = sizeof(Value);
 9015:             } else {
 9015:                 /*
 9015:                  * To avoid string conversion on each compare we do it only once
 9015:                  * prior to sorting. But we also need the space for the original
 9015:                  * values to recover the sorting result. To reuse
 9015:                  * sort_compare_strings we move the original values to the odd
 9015:                  * indexes in vec, put the string conversion results in the even
48470:                  * indexes and pass 2 * sizeof(Value) as an element size to the
 9015:                  * sorting function. In this way sort_compare_strings will only
 9015:                  * see the string values when it casts the compare arguments as
48470:                  * pointers to Value.
 9015:                  *
 9015:                  * This requires doubling the temporary storage including the
 9015:                  * scratch space for the merge sort. Since vec already contains
 9015:                  * the rooted scratch space for newlen elements at the tail, we
 9015:                  * can use it to rearrange and convert to strings first and try
 9015:                  * realloc only when we know that we successfully converted all
 9015:                  * the elements.
 9015:                  */
 9975: #if JS_BITS_PER_WORD == 32
48470:                 if (size_t(newlen) > size_t(-1) / (4 * sizeof(Value))) {
12983:                     js_ReportAllocationOverflow(cx);
40390:                     return false;
 9015:                 }
 9975: #endif
 9015: 
 9015:                 /*
 9015:                  * Rearrange and string-convert the elements of the vector from
 9015:                  * the tail here and, after sorting, move the results back
 9015:                  * starting from the start to prevent overwrite the existing
 9015:                  * elements.
 9015:                  */
 9015:                 i = newlen;
 9015:                 do {
 9015:                     --i;
40390:                     if (!JS_CHECK_OPERATION_LIMIT(cx))
40390:                         return false;
48470:                     const Value &v = vec[i];
 9015:                     str = js_ValueToString(cx, v);
40390:                     if (!str)
40390:                         return false;
48470:                     // Copying v must come first, because the following line overwrites v
48470:                     // when i == 0.
 9015:                     vec[2 * i + 1] = v;
48470:                     vec[2 * i].setString(str);
 9015:                 } while (i != 0);
 9015: 
40390:                 JS_ASSERT(tvr.array == vec);
64560:                 vec = (Value *) cx->realloc_(vec, 4 * size_t(newlen) * sizeof(Value));
 9015:                 if (!vec) {
48470:                     vec = tvr.array;  /* N.B. AutoFreeVector */
40390:                     return false;
40390:                 }
 9015:                 mergesort_tmp = vec + 2 * newlen;
62363:                 MakeRangeGCSafe(mergesort_tmp, 2 * newlen);
40390:                 tvr.changeArray(vec, newlen * 4);
48470:                 elemsize = 2 * sizeof(Value);
 9015:             }
40390:             if (!js_MergeSort(vec, size_t(newlen), elemsize,
48470:                               sort_compare_strings, cx, mergesort_tmp,
48470:                               JS_SORTING_GENERIC)) {
40390:                 return false;
40390:             }
40390:             if (!allStrings) {
 9015:                 /*
 9780:                  * We want to make the following loop fast and to unroot the
 9780:                  * cached results of toString invocations before the operation
 9780:                  * callback has a chance to run the GC. For this reason we do
 9780:                  * not call JS_CHECK_OPERATION_LIMIT in the loop.
 9015:                  */
 9069:                 i = 0;
 9069:                 do {
 9015:                     vec[i] = vec[2 * i + 1];
 9069:                 } while (++i != newlen);
 9015:             }
    1:         } else {
55565:             CompareArgs ca(cx);
56179:             if (!ca.session.start(cx, fval, UndefinedValue(), 2))
40390:                 return false;
42714: 
48470:             if (!js_MergeSort(vec, size_t(newlen), sizeof(Value),
29885:                               comparator_stack_cast(sort_compare),
48470:                               &ca, mergesort_tmp,
48470:                               JS_SORTING_VALUES)) {
40390:                 return false;
 9015:             }
42714:         }
    1: 
 9015:         /*
 9015:          * We no longer need to root the scratch space for the merge sort, so
40390:          * unroot it now to make the job of a potential GC under
40390:          * InitArrayElements easier.
 9015:          */
40390:         tvr.changeLength(newlen);
75732:         if (!InitArrayElements(cx, obj, 0, newlen, vec, false))
40390:             return false;
40390:     }
    1: 
    1:     /* Set undefs that sorted after the rest of elements. */
    1:     while (undefs != 0) {
    1:         --undefs;
48470:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
48470:             !SetArrayElement(cx, obj, newlen++, UndefinedValue())) {
40390:             return false;
    1:         }
48470:     }
    1: 
    1:     /* Re-create any holes that sorted to the end of the array. */
    1:     while (len > newlen) {
62396:         if (!JS_CHECK_OPERATION_LIMIT(cx) || DeleteArrayElement(cx, obj, --len, true) < 0)
54169:             return false;
    1:     }
48470:     vp->setObject(*obj);
40390:     return true;
    1: }
    1: 
    1: /*
    1:  * Perl-inspired push, pop, shift, unshift, and splice methods.
    1:  */
20408: static JSBool
48470: array_push_slowly(JSContext *cx, JSObject *obj, uintN argc, Value *argv, Value *rval)
    1: {
26564:     jsuint length;
    1: 
    1:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
75732:     if (!InitArrayElements(cx, obj, length, argc, argv, true))
    1:         return JS_FALSE;
    1: 
    1:     /* Per ECMA-262, return the new array length. */
26564:     jsdouble newlength = length + jsdouble(argc);
48470:     rval->setNumber(newlength);
75615: 
75704:     /* watch for length overflowing to a double. */
75720:     if (!rval->isInt32() && !cx->markTypeCallerOverflow())
75720:         return false;
75615: 
    1:     return js_SetLengthProperty(cx, obj, newlength);
    1: }
    1: 
20408: static JSBool
48470: array_push1_dense(JSContext* cx, JSObject* obj, const Value &v, Value *rval)
19571: {
40796:     uint32 length = obj->getArrayLength();
58702:     do {
58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, length, 1);
58702:         if (result != JSObject::ED_OK) {
58702:             if (result == JSObject::ED_FAILED)
58702:                 return false;
58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
58702:             break;
19571:         }
19571: 
75732:         if (cx->typeInferenceEnabled() && !cx->addTypePropertyId(obj->getType(), JSID_VOID, v))
75732:             return false;
75732: 
75720:         obj->setDenseArrayLength(length + 1);
41782:         obj->setDenseArrayElement(length, v);
48470:         rval->setNumber(obj->getArrayLength());
58702:         return true;
58702:     } while (false);
58702: 
58702:     if (!obj->makeDenseArraySlow(cx))
58702:         return false;
58702:     Value tmp = v;
58702:     return array_push_slowly(cx, obj, 1, &tmp, rval);
19571: }
19571: 
48470: JS_ALWAYS_INLINE JSBool
48470: ArrayCompPushImpl(JSContext *cx, JSObject *obj, const Value &v)
24861: {
62932:     uint32 length = obj->getArrayLength();
62932:     if (obj->isSlowArray()) {
62932:         /* This can happen in one evil case. See bug 630377. */
62932:         jsid id;
62932:         return js_IndexToId(cx, length, &id) &&
62932:                js_DefineProperty(cx, obj, id, &v, NULL, NULL, JSPROP_ENUMERATE);
62932:     }
62932: 
39928:     JS_ASSERT(obj->isDenseArray());
41782:     JS_ASSERT(length <= obj->getDenseArrayCapacity());
41782: 
41782:     if (length == obj->getDenseArrayCapacity()) {
31823:         if (length > JS_ARGS_LENGTH_MAX) {
24861:             JS_ReportErrorNumberUC(cx, js_GetErrorMessage, NULL,
24861:                                    JSMSG_ARRAY_INIT_TOO_BIG);
62932:             return false;
24861:         }
24861: 
58702:         /*
62932:          * An array comprehension cannot add holes to the array. So we can use
62932:          * ensureSlots instead of ensureDenseArrayElements.
58702:          */
58702:         if (!obj->ensureSlots(cx, length + 1))
58702:             return false;
75927:         if (!cx->typeInferenceEnabled())
75927:             obj->backfillDenseArrayHoles();
75927:     }
75927: 
75927:     if (cx->typeInferenceEnabled())
75927:         obj->setDenseArrayInitializedLength(length + 1);
75720:     obj->setDenseArrayLength(length + 1);
41782:     obj->setDenseArrayElement(length, v);
62932:     return true;
24861: }
48470: 
48470: JSBool
48470: js_ArrayCompPush(JSContext *cx, JSObject *obj, const Value &vp)
48470: {
48470:     return ArrayCompPushImpl(cx, obj, vp);
48470: }
48470: 
58283: #ifdef JS_TRACER
48470: JSBool JS_FASTCALL
48470: js_ArrayCompPush_tn(JSContext *cx, JSObject *obj, ValueArgType v)
48470: {
62033:     TraceMonitor *tm = JS_TRACE_MONITOR_ON_TRACE(cx);
62032: 
57710:     if (!ArrayCompPushImpl(cx, obj, ValueArgToConstRef(v))) {
62032:         SetBuiltinError(tm);
57710:         return JS_FALSE;
48470:     }
57710: 
62032:     return WasBuiltinSuccessful(tm);
57710: }
57710: JS_DEFINE_CALLINFO_3(extern, BOOL_FAIL, js_ArrayCompPush_tn, CONTEXT, OBJECT,
57710:                      VALUE, 0, nanojit::ACCSET_STORE_ANY)
58283: #endif
24861: 
20408: static JSBool
48470: array_push(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
 4127:     /* Insist on one argument and obj of the expected class. */
39928:     if (argc != 1 || !obj->isDenseArray())
20408:         return array_push_slowly(cx, obj, argc, vp + 2, vp);
20408: 
20408:     return array_push1_dense(cx, obj, vp[2], vp);
 4127: }
11835: 
20408: static JSBool
48470: array_pop_slowly(JSContext *cx, JSObject* obj, Value *vp)
 4127: {
    1:     jsuint index;
    1:     JSBool hole;
    1: 
19571:     if (!js_GetLengthProperty(cx, obj, &index))
11835:         return JS_FALSE;
19571:     if (index == 0) {
48470:         vp->setUndefined();
75824:         if (!cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:             return JS_FALSE;
19571:     } else {
19571:         index--;
19571: 
19571:         /* Get the to-be-deleted property's value into vp. */
57714:         if (!GetElement(cx, obj, index, &hole, vp))
19571:             return JS_FALSE;
75824:         if (hole && !cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:             return JS_FALSE;
62396:         if (!hole && DeleteArrayElement(cx, obj, index, true) < 0)
19571:             return JS_FALSE;
19571:     }
19571:     return js_SetLengthProperty(cx, obj, index);
19571: }
19571: 
20408: static JSBool
48470: array_pop_dense(JSContext *cx, JSObject* obj, Value *vp)
19571: {
19571:     jsuint index;
19571:     JSBool hole;
19571: 
40796:     index = obj->getArrayLength();
15603:     if (index == 0) {
48470:         vp->setUndefined();
75824:         if (!cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:             return JS_FALSE;
11835:         return JS_TRUE;
15603:     }
11835:     index--;
57714:     if (!GetElement(cx, obj, index, &hole, vp))
15603:         return JS_FALSE;
75824:     if (hole && !cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:         return JS_FALSE;
62396:     if (!hole && DeleteArrayElement(cx, obj, index, true) < 0)
15603:         return JS_FALSE;
75927: 
75720:     obj->setDenseArrayLength(index);
75927:     if (!cx->markTypeArrayShrank(obj->getType()))
75927:         return JS_FALSE;
75927: 
11835:     return JS_TRUE;
11835: }
11835: 
20408: static JSBool
48470: array_pop(JSContext *cx, uintN argc, Value *vp)
19571: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
19571:     if (!obj)
61734:         return false;
39928:     if (obj->isDenseArray())
20408:         return array_pop_dense(cx, obj, vp);
20408:     return array_pop_slowly(cx, obj, vp);
    1: }
    1: 
    1: static JSBool
48470: array_shift(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
61734: 
61734:     jsuint length;
61734:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
40868: 
    1:     if (length == 0) {
48470:         vp->setUndefined();
75824:         if (!cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:             return JS_FALSE;
    1:     } else {
    1:         length--;
    1: 
39928:         if (obj->isDenseArray() && !js_PrototypeHasIndexedProperties(cx, obj) &&
75927:             length < obj->getDenseArrayCapacity() &&
75927:             0 < obj->getDenseArrayInitializedLength()) {
41782:             *vp = obj->getDenseArrayElement(0);
75824:             if (vp->isMagic(JS_ARRAY_HOLE)) {
48470:                 vp->setUndefined();
75824:                 if (!cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:                     return JS_FALSE;
75824:             }
48470:             Value *elems = obj->getDenseArrayElements();
41782:             memmove(elems, elems + 1, length * sizeof(jsval));
75927:             if (cx->typeInferenceEnabled()) {
75927:                 obj->setDenseArrayInitializedLength(obj->getDenseArrayInitializedLength() - 1);
75927:                 if (!cx->markTypeArrayShrank(obj->getType()))
75927:                     return JS_FALSE;
75625:             } else {
48470:                 obj->setDenseArrayElement(length, MagicValue(JS_ARRAY_HOLE));
75625:             }
75720:             JS_ALWAYS_TRUE(obj->setArrayLength(cx, length));
75830:             if (!js_SuppressDeletedIndexProperties(cx, obj, length, length + 1))
61434:                 return JS_FALSE;
40868:             return JS_TRUE;
40868:         }
40868: 
 4127:         /* Get the to-be-deleted property's value into vp ASAP. */
61734:         JSBool hole;
57714:         if (!GetElement(cx, obj, 0, &hole, vp))
    1:             return JS_FALSE;
    1: 
75824:         if (hole && !cx->markTypeCallerUnexpected(TYPE_UNDEFINED))
75824:             return JS_FALSE;
75824: 
 6917:         /* Slide down the array above the first element. */
40390:         AutoValueRooter tvr(cx);
61734:         for (jsuint i = 0; i < length; i++) {
28242:             if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:                 !GetElement(cx, obj, i + 1, &hole, tvr.addr()) ||
28242:                 !SetOrDeleteArrayElement(cx, obj, i, hole, tvr.value())) {
    1:                 return JS_FALSE;
28242:             }
28242:         }
28242: 
28242:         /* Delete the only or last element when it exists. */
62396:         if (!hole && DeleteArrayElement(cx, obj, length, true) < 0)
    1:             return JS_FALSE;
    1:     }
    1:     return js_SetLengthProperty(cx, obj, length);
    1: }
    1: 
    1: static JSBool
48470: array_unshift(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     Value *argv;
28242:     JSBool hole;
26564:     jsdouble last, newlen;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     jsuint length;
61734:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
75627: 
26564:     newlen = length;
    1:     if (argc > 0) {
    1:         /* Slide up the array to make room for argc at the bottom. */
 4127:         argv = JS_ARGV(cx, vp);
    1:         if (length > 0) {
58702:             bool optimized = false;
58702:             do {
58702:                 if (!obj->isDenseArray())
58702:                     break;
58702:                 if (js_PrototypeHasIndexedProperties(cx, obj))
58702:                     break;
58702:                 JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, length, argc);
58702:                 if (result != JSObject::ED_OK) {
58702:                     if (result == JSObject::ED_FAILED)
58702:                         return false;
58702:                     JS_ASSERT(result == JSObject::ED_SPARSE);
58702:                     break;
58702:                 }
48470:                 Value *elems = obj->getDenseArrayElements();
41782:                 memmove(elems + argc, elems, length * sizeof(jsval));
75625:                 ClearValueRange(obj->getDenseArrayElements(), argc, false);
58702:                 optimized = true;
58702:             } while (false);
58702: 
58702:             if (!optimized) {
    1:                 last = length;
28242:                 jsdouble upperIndex = last + argc;
40390:                 AutoValueRooter tvr(cx);
    1:                 do {
28242:                     --last, --upperIndex;
28242:                     if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:                         !GetElement(cx, obj, last, &hole, tvr.addr()) ||
28242:                         !SetOrDeleteArrayElement(cx, obj, upperIndex, hole, tvr.value())) {
28242:                         return JS_FALSE;
28242:                     }
 6917:                 } while (last != 0);
28242:             }
    1:         }
    1: 
    1:         /* Copy from argv to the bottom of the array. */
75732:         if (!InitArrayElements(cx, obj, 0, argc, argv, true))
    1:             return JS_FALSE;
    1: 
26564:         newlen += argc;
58298:     }
26564:     if (!js_SetLengthProperty(cx, obj, newlen))
    1:         return JS_FALSE;
    1: 
    1:     /* Follow Perl by returning the new array length. */
48470:     vp->setNumber(newlen);
75704: 
75704:     /* watch for length overflowing to a double. */
75720:     if (!vp->isInt32() && !cx->markTypeCallerOverflow())
75720:         return false;
75704: 
48470:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: array_splice(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
    1:     jsuint length, begin, end, count, delta, last;
28242:     JSBool hole;
    1: 
75679:     /* Get the type of the result object. */
75679:     TypeObject *type;
75716:     if (obj->isArray()) {
75704:         /*
75704:          * :FIXME: This is getting a type whose prototype is that of the
75704:          * argument, even if it is the Array.prototype on a different
75704:          * global than the current frame.
75704:          */
75679:         type = obj->getType();
75679:     } else {
75615:         /*
75615:          * Make a new type object for the return value.  This is an unexpected
75615:          * result of the call so mark it at the callsite.
75615:          */
75704:         type = cx->getTypeNewObject(JSProto_Array);
75720:         if (!type || !cx->markTypeCallerUnexpected((jstype) type))
75720:             return false;
75720:     }
75720: 
61734:     /* Create a new array value to return. */
59234:     JSObject *obj2 = NewDenseEmptyArray(cx);
18402:     if (!obj2)
18402:         return JS_FALSE;
75679:     obj2->setType(type);
48470:     vp->setObject(*obj2);
18402: 
 6917:     /* Nothing to do if no args.  Otherwise get length. */
    1:     if (argc == 0)
    1:         return JS_TRUE;
48470:     Value *argv = JS_ARGV(cx, vp);
61734:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
55519:     jsuint origlength = length;
    1: 
    1:     /* Convert the first argument into a starting index. */
40828:     jsdouble d;
40828:     if (!ValueToNumber(cx, *argv, &d))
    1:         return JS_FALSE;
    1:     d = js_DoubleToInteger(d);
    1:     if (d < 0) {
    1:         d += length;
    1:         if (d < 0)
    1:             d = 0;
    1:     } else if (d > length) {
    1:         d = length;
    1:     }
    1:     begin = (jsuint)d; /* d has been clamped to uint32 */
    1:     argc--;
    1:     argv++;
    1: 
    1:     /* Convert the second argument from a count into a fencepost index. */
    1:     delta = length - begin;
    1:     if (argc == 0) {
    1:         count = delta;
    1:         end = length;
    1:     } else {
40828:         if (!ValueToNumber(cx, *argv, &d))
    1:             return JS_FALSE;
    1:         d = js_DoubleToInteger(d);
    1:         if (d < 0)
    1:             d = 0;
    1:         else if (d > delta)
    1:             d = delta;
    1:         count = (jsuint)d;
    1:         end = begin + count;
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
48470:     AutoValueRooter tvr(cx);
    1: 
    1:     /* If there are elements to remove, put them into the return value. */
    1:     if (count > 0) {
39928:         if (obj->isDenseArray() && !js_PrototypeHasIndexedProperties(cx, obj) &&
75767:             end <= obj->getDenseArrayInitializedLength()) {
48537:             if (!InitArrayObject(cx, obj2, count, obj->getDenseArrayElements() + begin))
28242:                 return JS_FALSE;
28242:         } else {
    1:             for (last = begin; last < end; last++) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:                     !GetElement(cx, obj, last, &hole, tvr.addr())) {
28242:                     return JS_FALSE;
28242:                 }
28242: 
75732:                 if (!cx->addTypePropertyId(obj2->getType(), JSID_VOID, tvr.value()))
75732:                     return JS_FALSE;
75732: 
28242:                 /* Copy tvr.value() to the new array unless it's a hole. */
28242:                 if (!hole && !SetArrayElement(cx, obj2, last - begin, tvr.value()))
28242:                     return JS_FALSE;
28242:             }
28242: 
28242:             if (!js_SetLengthProperty(cx, obj2, count))
28242:                 return JS_FALSE;
28242:         }
    1:     }
    1: 
    1:     /* Find the direction (up or down) to copy and make way for argv. */
    1:     if (argc > count) {
    1:         delta = (jsuint)argc - count;
    1:         last = length;
58702:         bool optimized = false;
58702:         do {
58702:             if (!obj->isDenseArray())
58702:                 break;
58702:             if (js_PrototypeHasIndexedProperties(cx, obj))
58702:                 break;
75670:             if (length > obj->getDenseArrayInitializedLength())
58702:                 break;
58702:             if (length != 0 && obj->getDenseArrayElement(length - 1).isMagic(JS_ARRAY_HOLE))
58702:                 break;
58702:             JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, length, delta);
58702:             if (result != JSObject::ED_OK) {
58702:                 if (result == JSObject::ED_FAILED)
58702:                     return false;
58702:                 JS_ASSERT(result == JSObject::ED_SPARSE);
58702:                 break;
58702:             }
48520:             Value *arraybeg = obj->getDenseArrayElements();
48520:             Value *srcbeg = arraybeg + last - 1;
48520:             Value *srcend = arraybeg + end - 1;
48520:             Value *dstbeg = srcbeg + delta;
48537:             for (Value *src = srcbeg, *dst = dstbeg; src > srcend; --src, --dst)
48537:                 *dst = *src;
48537: 
75720:             if (!obj->setArrayLength(cx, obj->getArrayLength() + delta))
75720:                 return false;
58702:             optimized = true;
58702:         } while (false);
58702: 
58702:         if (!optimized) {
28242:             /* (uint) end could be 0, so we can't use a vanilla >= test. */
28242:             while (last-- > end) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:                     !GetElement(cx, obj, last, &hole, tvr.addr()) ||
28242:                     !SetOrDeleteArrayElement(cx, obj, last + delta, hole, tvr.value())) {
28242:                     return JS_FALSE;
28242:                 }
28242:             }
    1:         }
    1:         length += delta;
    1:     } else if (argc < count) {
    1:         delta = count - (jsuint)argc;
39928:         if (obj->isDenseArray() && !js_PrototypeHasIndexedProperties(cx, obj) &&
75625:             length <= obj->getDenseArrayInitializedLength()) {
48520: 
48520:             Value *arraybeg = obj->getDenseArrayElements();
48520:             Value *srcbeg = arraybeg + end;
48520:             Value *srcend = arraybeg + length;
48520:             Value *dstbeg = srcbeg - delta;
48537:             for (Value *src = srcbeg, *dst = dstbeg; src < srcend; ++src, ++dst)
48537:                 *dst = *src;
28242:         } else {
28242:             for (last = end; last < length; last++) {
28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:                     !GetElement(cx, obj, last, &hole, tvr.addr()) ||
28242:                     !SetOrDeleteArrayElement(cx, obj, last - delta, hole, tvr.value())) {
28242:                     return JS_FALSE;
28242:                 }
28242:             }
    1:         }
    1:         length -= delta;
    1:     }
    1: 
55519:     if (length < origlength && !js_SuppressDeletedIndexProperties(cx, obj, length, origlength))
55519:         return JS_FALSE;
55519: 
28242:     /*
28242:      * Copy from argv into the hole to complete the splice, and update length in
28242:      * case we deleted elements from the end.
28242:      */
75732:     return InitArrayElements(cx, obj, begin, argc, argv, true) &&
28242:            js_SetLengthProperty(cx, obj, length);
    1: }
    1: 
    1: /*
    1:  * Python-esque sequence operations.
    1:  */
    1: static JSBool
48470: array_concat(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     /* Treat our |this| object as the first argument; see ECMA 15.4.4.4. */
48470:     Value *p = JS_ARGV(cx, vp) - 1;
    1: 
 4127:     /* Create a new Array object and root it using *vp. */
61734:     JSObject *aobj = ToObject(cx, &vp[1]);
61734:     if (!aobj)
61734:         return false;
61734: 
48470:     JSObject *nobj;
48470:     jsuint length;
39928:     if (aobj->isDenseArray()) {
40796:         length = aobj->getArrayLength();
75732:         Value *vector = aobj->getDenseArrayElements();
75671:         jsuint initlen = aobj->getDenseArrayInitializedLength();
75732:         nobj = NewDenseCopiedArray(cx, initlen, vector);
11835:         if (!nobj)
11835:             return JS_FALSE;
75823:         if (nobj->getProto() == aobj->getProto())
75823:             nobj->setType(aobj->getType());
75823:         else if (!cx->markTypeCallerUnexpected(TYPE_UNKNOWN))
75823:             return JS_FALSE;
75823:         nobj->setType(aobj->getType());
75720:         if (!nobj->setArrayLength(cx, length))
75720:             return JS_FALSE;
75732:         if (!aobj->isPackedDenseArray() && !nobj->setDenseArrayNotPacked(cx))
75732:             return JS_FALSE;
48470:         vp->setObject(*nobj);
11835:         if (argc == 0)
11835:             return JS_TRUE;
11835:         argc--;
48470:         p++;
11835:     } else {
59234:         nobj = NewDenseEmptyArray(cx);
    1:         if (!nobj)
    1:             return JS_FALSE;
75823:         if (!cx->markTypeCallerUnexpected(TYPE_UNKNOWN))
75823:             return JS_FALSE;
48470:         vp->setObject(*nobj);
11835:         length = 0;
11835:     }
    1: 
48470:     AutoValueRooter tvr(cx);
    1: 
    1:     /* Loop over [0, argc] to concat args into nobj, expanding all Arrays. */
48470:     for (uintN i = 0; i <= argc; i++) {
33178:         if (!JS_CHECK_OPERATION_LIMIT(cx))
33178:             return false;
48470:         const Value &v = p[i];
48470:         if (v.isObject()) {
48470:             aobj = &v.toObject();
56565:             if (aobj->isArray() ||
56565:                 (aobj->isWrapper() && JSWrapper::wrappedObject(aobj)->isArray())) {
33178:                 jsid id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
33178:                 if (!aobj->getProperty(cx, id, tvr.addr()))
33178:                     return false;
59234:                 jsuint alength;
59234:                 if (!ValueToLength(cx, tvr.addr(), &alength))
33178:                     return false;
48470:                 for (jsuint slot = 0; slot < alength; slot++) {
48470:                     JSBool hole;
33178:                     if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:                         !GetElement(cx, aobj, slot, &hole, tvr.addr())) {
33178:                         return false;
33178:                     }
    1: 
75823:                     if (!hole && !cx->addTypePropertyId(nobj->getType(), JSID_VOID, tvr.value()))
75732:                         return false;
75732: 
    1:                     /*
42587:                      * Per ECMA 262, 15.4.4.4, step 9, ignore nonexistent
    1:                      * properties.
    1:                      */
33178:                     if (!hole &&
33178:                         !SetArrayElement(cx, nobj, length+slot, tvr.value())) {
33178:                         return false;
    1:                     }
    1:                 }
    1:                 length += alength;
    1:                 continue;
    1:             }
    1:         }
    1: 
75823:         if (!cx->addTypePropertyId(nobj->getType(), JSID_VOID, v))
75720:             return false;
75673: 
33178:         if (!SetArrayElement(cx, nobj, length, v))
33178:             return false;
    1:         length++;
    1:     }
    1: 
33178:     return js_SetLengthProperty(cx, nobj, length);
    1: }
    1: 
    1: static JSBool
48470: array_slice(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     Value *argv;
48470:     JSObject *nobj;
    1:     jsuint length, begin, end, slot;
28242:     JSBool hole;
    1: 
 4127:     argv = JS_ARGV(cx, vp);
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1:     begin = 0;
    1:     end = length;
    1: 
    1:     if (argc > 0) {
40828:         jsdouble d;
40828:         if (!ValueToNumber(cx, argv[0], &d))
    1:             return JS_FALSE;
    1:         d = js_DoubleToInteger(d);
    1:         if (d < 0) {
    1:             d += length;
    1:             if (d < 0)
    1:                 d = 0;
    1:         } else if (d > length) {
    1:             d = length;
    1:         }
    1:         begin = (jsuint)d;
    1: 
56555:         if (argc > 1 && !argv[1].isUndefined()) {
40828:             if (!ValueToNumber(cx, argv[1], &d))
    1:                 return JS_FALSE;
    1:             d = js_DoubleToInteger(d);
    1:             if (d < 0) {
    1:                 d += length;
    1:                 if (d < 0)
    1:                     d = 0;
    1:             } else if (d > length) {
    1:                 d = length;
    1:             }
    1:             end = (jsuint)d;
    1:         }
    1:     }
    1: 
    1:     if (begin > end)
    1:         begin = end;
    1: 
75615:     /* Get the type object for the returned array. */
75679:     TypeObject *type;
75679:     if (obj->isArray()) {
75704:         /* :FIXME: Same issue as array_splice. */
75679:         type = obj->getType();
75679:     } else {
75615:         /*
75615:          * Make a new type object for the return value.  This is an unexpected
75615:          * result of the call so mark it at the callsite.
75615:          */
75704:         type = cx->getTypeNewObject(JSProto_Array);
75720:         if (!type || !cx->markTypeCallerUnexpected((jstype) type))
75720:             return false;
75720:     }
75720: 
75767:     if (obj->isDenseArray() && end <= obj->getDenseArrayInitializedLength() &&
28242:         !js_PrototypeHasIndexedProperties(cx, obj)) {
59234:         nobj = NewDenseCopiedArray(cx, end - begin, obj->getDenseArrayElements() + begin);
11835:         if (!nobj)
11835:             return JS_FALSE;
75679:         nobj->setType(type);
75720:         if (!obj->isPackedDenseArray() && !nobj->setDenseArrayNotPacked(cx))
75720:             return JS_FALSE;
48470:         vp->setObject(*nobj);
11835:         return JS_TRUE;
11835:     }
11835: 
11835:     /* Create a new Array object and root it using *vp. */
59234:     nobj = NewDenseAllocatedArray(cx, end - begin);
11835:     if (!nobj)
11835:         return JS_FALSE;
75679:     nobj->setType(type);
48470:     vp->setObject(*nobj);
11835: 
40390:     AutoValueRooter tvr(cx);
    1:     for (slot = begin; slot < end; slot++) {
28242:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:             !GetElement(cx, obj, slot, &hole, tvr.addr())) {
28242:             return JS_FALSE;
28242:         }
28242:         if (!hole && !SetArrayElement(cx, nobj, slot - begin, tvr.value()))
28242:             return JS_FALSE;
28242:     }
28242: 
59234:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_ARRAY_EXTRAS
    1: 
    1: static JSBool
48470: array_indexOfHelper(JSContext *cx, JSBool isLast, uintN argc, Value *vp)
    1: {
    1:     jsuint length, i, stop;
48470:     Value tosearch;
    1:     jsint direction;
    1:     JSBool hole;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1:     if (length == 0)
    1:         goto not_found;
    1: 
    1:     if (argc <= 1) {
    1:         i = isLast ? length - 1 : 0;
48470:         tosearch = (argc != 0) ? vp[2] : UndefinedValue();
    1:     } else {
    1:         jsdouble start;
    1: 
16519:         tosearch = vp[2];
40828:         if (!ValueToNumber(cx, vp[3], &start))
    1:             return JS_FALSE;
    1:         start = js_DoubleToInteger(start);
    1:         if (start < 0) {
    1:             start += length;
    1:             if (start < 0) {
    1:                 if (isLast)
    1:                     goto not_found;
    1:                 i = 0;
    1:             } else {
    1:                 i = (jsuint)start;
    1:             }
    1:         } else if (start >= length) {
    1:             if (!isLast)
    1:                 goto not_found;
    1:             i = length - 1;
    1:         } else {
    1:             i = (jsuint)start;
    1:         }
    1:     }
    1: 
    1:     if (isLast) {
    1:         stop = 0;
    1:         direction = -1;
    1:     } else {
    1:         stop = length - 1;
    1:         direction = 1;
    1:     }
    1: 
    1:     for (;;) {
25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
57714:             !GetElement(cx, obj, (jsuint)i, &hole, vp)) {
    1:             return JS_FALSE;
    1:         }
59890:         if (!hole) {
59890:             JSBool equal;
59890:             if (!StrictlyEqual(cx, *vp, tosearch, &equal))
59890:                 return JS_FALSE;
59890:             if (equal) {
48470:                 vp->setNumber(i);
75720:                 if (!vp->isInt32() && !cx->markTypeCallerOverflow())
75720:                     return false;
48470:                 return JS_TRUE;
48470:             }
59890:         }
    1:         if (i == stop)
    1:             goto not_found;
    1:         i += direction;
    1:     }
    1: 
    1:   not_found:
48470:     vp->setInt32(-1);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: array_indexOf(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_indexOfHelper(cx, JS_FALSE, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: array_lastIndexOf(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_indexOfHelper(cx, JS_TRUE, argc, vp);
    1: }
    1: 
    1: /* Order is important; extras that take a predicate funarg must follow MAP. */
    1: typedef enum ArrayExtraMode {
    1:     FOREACH,
    1:     REDUCE,
    1:     REDUCE_RIGHT,
    1:     MAP,
    1:     FILTER,
    1:     SOME,
    1:     EVERY
    1: } ArrayExtraMode;
    1: 
    1: #define REDUCE_MODE(mode) ((mode) == REDUCE || (mode) == REDUCE_RIGHT)
    1: 
29887: static JSBool
48470: array_extra(JSContext *cx, ArrayExtraMode mode, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
42714:     jsuint length;
61734:     if (!js_GetLengthProperty(cx, obj, &length))
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * First, get or compute our callee, so that we error out consistently
    1:      * when passed a non-callable object.
    1:      */
16519:     if (argc == 0) {
48470:         js_ReportMissingArg(cx, *vp, 0);
16519:         return JS_FALSE;
16519:     }
48470:     Value *argv = vp + 2;
42714:     JSObject *callable = js_ValueToCallableObject(cx, &argv[0], JSV2F_SEARCH_STACK);
    1:     if (!callable)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Set our initial return condition, used for zero-length array cases
    1:      * (and pre-size our map return to match our known length, for all cases).
    1:      */
42714:     jsuint newlen;
42714:     JSObject *newarr;
75615:     TypeObject *newtype = NULL;
    1: #ifdef __GNUC__ /* quell GCC overwarning */
    1:     newlen = 0;
    1:     newarr = NULL;
    1: #endif
42714:     jsint start = 0, end = length, step = 1;
 4127: 
    1:     switch (mode) {
    1:       case REDUCE_RIGHT:
    1:         start = length - 1, end = -1, step = -1;
    1:         /* FALL THROUGH */
    1:       case REDUCE:
    1:         if (length == 0 && argc == 1) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_EMPTY_ARRAY_REDUCE);
    1:             return JS_FALSE;
    1:         }
    1:         if (argc >= 2) {
 6040:             *vp = argv[1];
    1:         } else {
42714:             JSBool hole;
 2888:             do {
57714:                 if (!GetElement(cx, obj, start, &hole, vp))
    1:                     return JS_FALSE;
    1:                 start += step;
 2888:             } while (hole && start != end);
 2888: 
 2888:             if (hole && start == end) {
 2888:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 2888:                                      JSMSG_EMPTY_ARRAY_REDUCE);
 2888:                 return JS_FALSE;
 2888:             }
    1:         }
    1:         break;
    1:       case MAP:
    1:       case FILTER:
    1:         newlen = (mode == MAP) ? length : 0;
59234:         newarr = NewDenseAllocatedArray(cx, newlen);
    1:         if (!newarr)
    1:             return JS_FALSE;
75679:         newtype = cx->getTypeCallerInitObject(true);
75686:         if (!newtype)
75686:             return JS_FALSE;
75679:         newarr->setType(newtype);
48470:         vp->setObject(*newarr);
    1:         break;
    1:       case SOME:
48470:         vp->setBoolean(false);
    1:         break;
    1:       case EVERY:
48470:         vp->setBoolean(true);
    1:         break;
    1:       case FOREACH:
48470:         vp->setUndefined();
    1:         break;
    1:     }
    1: 
    1:     if (length == 0)
    1:         return JS_TRUE;
    1: 
55713:     Value thisv = (argc > 1 && !REDUCE_MODE(mode)) ? argv[1] : UndefinedValue();
    1: 
    1:     /*
 6040:      * For all but REDUCE, we call with 3 args (value, index, array). REDUCE
 6040:      * requires 4 args (accum, value, index, array).
    1:      */
    1:     argc = 3 + REDUCE_MODE(mode);
42714: 
55565:     InvokeSessionGuard session;
55565:     if (!session.start(cx, ObjectValue(*callable), thisv, argc))
    1:         return JS_FALSE;
    1: 
18989:     MUST_FLOW_THROUGH("out");
42714:     JSBool ok = JS_TRUE;
42714:     JSBool cond;
48470: 
55565:     Value objv = ObjectValue(*obj);
42714:     AutoValueRooter tvr(cx);
42714:     for (jsint i = start; i != end; i += step) {
42714:         JSBool hole;
25087:         ok = JS_CHECK_OPERATION_LIMIT(cx) &&
57714:              GetElement(cx, obj, i, &hole, tvr.addr());
    1:         if (!ok)
 6040:             goto out;
    1:         if (hole)
    1:             continue;
    1: 
    1:         /*
    1:          * Push callable and 'this', then args. We must do this for every
50468:          * iteration around the loop since Invoke clobbers its arguments.
    1:          */
55565:         uintN argi = 0;
    1:         if (REDUCE_MODE(mode))
55565:             session[argi++] = *vp;
55565:         session[argi++] = tvr.value();
55565:         session[argi++] = Int32Value(i);
55565:         session[argi]   = objv;
    1: 
    1:         /* Do the call. */
55565:         ok = session.invoke(cx);
    1:         if (!ok)
    1:             break;
    1: 
55565:         const Value &rval = session.rval();
55565: 
10449:         if (mode > MAP)
55565:             cond = js_ValueToBoolean(rval);
10449: #ifdef __GNUC__ /* quell GCC overwarning */
10449:         else
    1:             cond = JS_FALSE;
10449: #endif
    1: 
    1:         switch (mode) {
    1:           case FOREACH:
    1:             break;
    1:           case REDUCE:
    1:           case REDUCE_RIGHT:
55565:             *vp = rval;
    1:             break;
    1:           case MAP:
75720:             ok = cx->addTypePropertyId(newarr->getType(), JSID_VOID, rval);
75720:             if (!ok)
75720:                 goto out;
55565:             ok = SetArrayElement(cx, newarr, i, rval);
    1:             if (!ok)
    1:                 goto out;
    1:             break;
    1:           case FILTER:
    1:             if (!cond)
    1:                 break;
42714:             /* The element passed the filter, so push it onto our result. */
75720:             ok = cx->addTypePropertyId(newarr->getType(), JSID_VOID, tvr.value());
75720:             if (!ok)
75720:                 goto out;
42714:             ok = SetArrayElement(cx, newarr, newlen++, tvr.value());
    1:             if (!ok)
    1:                 goto out;
    1:             break;
    1:           case SOME:
    1:             if (cond) {
48470:                 vp->setBoolean(true);
    1:                 goto out;
    1:             }
    1:             break;
    1:           case EVERY:
    1:             if (!cond) {
48470:                 vp->setBoolean(false);
    1:                 goto out;
    1:             }
    1:             break;
    1:         }
    1:     }
    1: 
    1:   out:
    1:     if (ok && mode == FILTER)
    1:         ok = js_SetLengthProperty(cx, newarr, newlen);
    1:     return ok;
    1: }
    1: 
29887: static JSBool
48470: array_forEach(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, FOREACH, argc, vp);
    1: }
    1: 
29887: static JSBool
48470: array_map(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, MAP, argc, vp);
    1: }
    1: 
29887: static JSBool
48470: array_reduce(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, REDUCE, argc, vp);
    1: }
    1: 
29887: static JSBool
48470: array_reduceRight(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, REDUCE_RIGHT, argc, vp);
    1: }
    1: 
29887: static JSBool
48470: array_filter(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, FILTER, argc, vp);
    1: }
    1: 
29887: static JSBool
48470: array_some(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, SOME, argc, vp);
    1: }
    1: 
29887: static JSBool
48470: array_every(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return array_extra(cx, EVERY, argc, vp);
    1: }
    1: #endif
    1: 
75704: /*
75704:  * These handlers deal with objects of type other than arrays, except for updates
75704:  * of the 'length' property. Sets of length on non-arrays and overflowing length
75704:  * on arrays are both handled by write barriers within the natives.
75704:  */
75615: 
75720: static void
75720: array_TypeSort(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75615: 
75720:     if (!site->forceThisTypes(cx))
75720:         return;
75615: 
75690:     if (site->returnTypes) {
75690:         if (site->isNew)
75690:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75718:         site->thisTypes->addSubset(cx, site->script, site->returnTypes);
75690:     }
75720: }
75720: 
75720: static void
75720: array_TypeInsert(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75615: 
75615:     if (site->returnTypes) {
75679:         /* The return type is an integer (array length). */
75690:         if (site->isNew)
75690:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75615:         site->returnTypes->addType(cx, TYPE_INT32);
75615:     }
75615: 
75720:     if (!site->forceThisTypes(cx))
75720:         return;
75615: 
75708:     for (size_t ind = 0; ind < site->argumentCount; ind++) {
75708:         site->thisTypes->addSetProperty(cx, site->script, site->pc,
75708:                                         site->argumentTypes[ind], JSID_VOID);
75708:     }
75720: }
75720: 
75720: static void
75720: array_TypeRemove(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75615: 
75615:     if (!site->returnTypes)
75615:         return;
75615: 
75690:     if (site->isNew)
75690:         site->returnTypes->addType(cx, TYPE_UNKNOWN);
75690: 
75720:     if (!site->forceThisTypes(cx))
75720:         return;
75708:     site->thisTypes->addGetProperty(cx, site->script, site->pc, site->returnTypes, JSID_VOID);
75720: }
75720: 
75720: static void
75720: array_TypeSplice(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75615: 
75720:     if (!site->forceThisTypes(cx))
75720:         return;
75615: 
75615:     if (site->returnTypes) {
75679:         /* Treat the returned array the same as the 'this' array. */
75690:         if (site->isNew)
75690:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75718:         site->thisTypes->addSubset(cx, site->script, site->returnTypes);
75615:     }
75615: 
75679:     /* All arguments beyond the first two are new array elements. */
75708:     for (size_t ind = 2; ind < site->argumentCount; ind++) {
75708:         site->thisTypes->addSetProperty(cx, site->script, site->pc,
75708:                                         site->argumentTypes[ind], JSID_VOID);
75708:     }
75720: }
75720: 
75720: static void
75720: array_TypeConcat(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75615: 
75688:     if (!site->compileAndGo()) {
75688:         if (site->returnTypes)
75688:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75688:         return;
75688:     }
75688: 
75720:     if (!site->forceThisTypes(cx))
75720:         return;
75615: 
75690:     if (site->returnTypes) {
75690:         if (site->isNew)
75690:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75823:         site->thisTypes->addSubset(cx, site->script, site->returnTypes);
75708:     }
75615: }
75615: 
75824: static void
75824: array_TypeSlice(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75824: {
75824:     TypeCallsite *site = Valueify(jssite);
75824: 
75824:     if (!site->forceThisTypes(cx))
75824:         return;
75824: 
75824:     if (site->returnTypes) {
75824:         if (site->isNew)
75824:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75824:         site->thisTypes->addFilterPrimitives(cx, site->script, site->returnTypes, false);
75824:     }
75824: }
75824: 
75679: /* Handler for all higher order array builtins. */
75720: static void
75720: array_TypeExtra(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite,
75615:                 ArrayExtraMode mode)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75708: 
75708:     if (!site->returnTypes)
75615:         return;
75615: 
75690:     if (site->isNew)
75690:         site->returnTypes->addType(cx, TYPE_UNKNOWN);
75690: 
75615:     switch (mode) {
75615: 
75615:       case FOREACH:
75615:         site->returnTypes->addType(cx, TYPE_UNDEFINED);
75615:         break;
75615: 
75708:       case REDUCE:
75708:         site->returnTypes->addType(cx, TYPE_UNKNOWN);
75615:         break;
75615: 
75688:       case MAP:
75708:       case FILTER:
75688:         if (site->compileAndGo()) {
75708:             /* Makes a new array whose element type will be filled in as the code runs. */
75615:             TypeObject *object = site->getInitObject(cx, true);
75720:             if (!object)
75720:                 return;
75615:             site->returnTypes->addType(cx, (jstype) object);
75688:         } else {
75688:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75688:         }
75615:         break;
75688: 
75615:       case SOME:
75615:         site->returnTypes->addType(cx, TYPE_BOOLEAN);
75615:         break;
75615: 
75615:       default:
75615:         JS_NOT_REACHED("Unexpected ArrayExtraMode");
75615:     }
75720: }
75720: 
75720: static void
75720: array_TypeExtraForEach(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     array_TypeExtra(cx, jsfun, jssite, FOREACH);
75615: }
75615: 
75720: static void
75720: array_TypeExtraMap(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     array_TypeExtra(cx, jsfun, jssite, MAP);
75615: }
75615: 
75720: static void
75720: array_TypeExtraReduce(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     array_TypeExtra(cx, jsfun, jssite, REDUCE);
75615: }
75615: 
75720: static void
75720: array_TypeExtraFilter(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     array_TypeExtra(cx, jsfun, jssite, FILTER);
75615: }
75615: 
75720: static void
75720: array_TypeExtraSome(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     array_TypeExtra(cx, jsfun, jssite, SOME);
75615: }
75615: 
31833: static JSBool
53557: array_isArray(JSContext *cx, uintN argc, Value *vp)
31833: {
56565:     JSObject *obj;
53557:     vp->setBoolean(argc > 0 &&
53557:                    vp[2].isObject() &&
56565:                    ((obj = &vp[2].toObject())->isArray() ||
56565:                     (obj->isWrapper() && JSWrapper::wrappedObject(obj)->isArray())));
56565:     return true;
31833: }
31833: 
75615: #define GENERIC JSFUN_GENERIC_NATIVE
75615: 
    1: static JSFunctionSpec array_methods[] = {
    1: #if JS_HAS_TOSOURCE
75615:     JS_FN_TYPE(js_toSource_str,      array_toSource,     0,0, JS_TypeHandlerString),
    1: #endif
75615:     JS_FN_TYPE(js_toString_str,      array_toString,     0,0, JS_TypeHandlerString),
75615:     JS_FN_TYPE(js_toLocaleString_str,array_toLocaleString,0,0, JS_TypeHandlerString),
    1: 
    1:     /* Perl-ish methods. */
75615:     JS_FN_TYPE("join",               array_join,         1,GENERIC, JS_TypeHandlerString),
75615:     JS_FN_TYPE("reverse",            array_reverse,      0,GENERIC, JS_TypeHandlerThis),
75615:     JS_FN_TYPE("sort",               array_sort,         1,GENERIC, array_TypeSort),
75615:     JS_FN_TYPE("push",               array_push,         1,GENERIC, array_TypeInsert),
75615:     JS_FN_TYPE("pop",                array_pop,          0,GENERIC, array_TypeRemove),
75615:     JS_FN_TYPE("shift",              array_shift,        0,GENERIC, array_TypeRemove),
75615:     JS_FN_TYPE("unshift",            array_unshift,      1,GENERIC, array_TypeInsert),
75615:     JS_FN_TYPE("splice",             array_splice,       2,GENERIC, array_TypeSplice),
    1: 
11835:     /* Pythonic sequence methods. */
75615:     JS_FN_TYPE("concat",             array_concat,       1,GENERIC, array_TypeConcat),
75824:     JS_FN_TYPE("slice",              array_slice,        2,GENERIC, array_TypeSlice),
    1: 
    1: #if JS_HAS_ARRAY_EXTRAS
75615:     JS_FN_TYPE("indexOf",            array_indexOf,      1,GENERIC, JS_TypeHandlerInt),
75615:     JS_FN_TYPE("lastIndexOf",        array_lastIndexOf,  1,GENERIC, JS_TypeHandlerInt),
75615:     JS_FN_TYPE("forEach",            array_forEach,      1,GENERIC, array_TypeExtraForEach),
75615:     JS_FN_TYPE("map",                array_map,          1,GENERIC, array_TypeExtraMap),
75615:     JS_FN_TYPE("reduce",             array_reduce,       1,GENERIC, array_TypeExtraReduce),
75615:     JS_FN_TYPE("reduceRight",        array_reduceRight,  1,GENERIC, array_TypeExtraReduce),
75615:     JS_FN_TYPE("filter",             array_filter,       1,GENERIC, array_TypeExtraFilter),
75615:     JS_FN_TYPE("some",               array_some,         1,GENERIC, array_TypeExtraSome),
75615:     JS_FN_TYPE("every",              array_every,        1,GENERIC, array_TypeExtraSome),
    1: #endif
    1: 
 4127:     JS_FS_END
    1: };
    1: 
31833: static JSFunctionSpec array_static_methods[] = {
75615:     JS_FN_TYPE("isArray",            array_isArray,      1,0, JS_TypeHandlerBool),
31833:     JS_FS_END
31833: };
31833: 
18300: JSBool
50489: js_Array(JSContext *cx, uintN argc, Value *vp)
    1: {
59234:     JSObject *obj;
59234: 
75615:     TypeObject *type = cx->getTypeCallerInitObject(true);
75686:     if (!type)
75686:         return JS_FALSE;
75615: 
59234:     if (argc == 0) {
59234:         obj = NewDenseEmptyArray(cx);
59234:     } else if (argc > 1) {
75732:         if (!InitArrayTypes(cx, type, vp + 2, argc))
75732:             return false;
59234:         obj = NewDenseCopiedArray(cx, argc, vp + 2);
59234:     } else if (!vp[2].isNumber()) {
75720:         if (!cx->addTypeProperty(type, NULL, vp[2]))
75720:             return false;
59234:         obj = NewDenseCopiedArray(cx, 1, vp + 2);
59234:     } else {
    1:         jsuint length;
59234:         if (!ValueToLength(cx, vp + 2, &length))
    1:             return JS_FALSE;
59234:         obj = NewDenseUnallocatedArray(cx, length);
    1:     }
48641: 
55746:     if (!obj)
55746:         return JS_FALSE;
75688: 
75679:     obj->setType(type);
75688: 
75697:     /* If the length calculation overflowed, make sure that is marked for the new type. */
75720:     if (obj->getArrayLength() > INT32_MAX && !obj->setArrayLength(cx, obj->getArrayLength()))
75720:         return false;
75697: 
55746:     vp->setObject(*obj);
59234:     return JS_TRUE;
    1: }
    1: 
75720: /*
75720:  * Specialized handler for Array() that propagates arguments into indexes of
75720:  * the resulting array.
75720:  */
75720: static void
75720: array_TypeNew(JSContext *cx, JSTypeFunction *jsfun, JSTypeCallsite *jssite)
75615: {
75615:     TypeCallsite *site = Valueify(jssite);
75615: 
75688:     if (!site->compileAndGo()) {
75688:         if (site->returnTypes)
75688:             site->returnTypes->addType(cx, TYPE_UNKNOWN);
75688:         return;
75688:     }
75688: 
75615:     TypeObject *object = site->getInitObject(cx, true);
75720:     if (!object)
75720:         return;
75615:     if (site->returnTypes)
75615:         site->returnTypes->addType(cx, (jstype) object);
75615: 
75919:     if (object->unknownProperties())
75760:         return;
75760: 
75641:     TypeSet *indexTypes = object->getProperty(cx, JSID_VOID, true);
75720:     if (!indexTypes)
75720:         return;
75720: 
75720:     /*
75720:      * Ignore the case where the call is passed a single argument. This is
75720:      * expected to be the array length, but if it isn't we will catch it in the
75720:      * Array native itself.
75720:      */
75615:     if (site->argumentCount > 1) {
75615:         for (size_t ind = 0; ind < site->argumentCount; ind++)
75718:             site->argumentTypes[ind]->addSubset(cx, site->script, indexTypes);
75615:     }
75615: }
75615: 
    1: JSObject *
    1: js_InitArrayClass(JSContext *cx, JSObject *obj)
    1: {
75615:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_ArrayClass, js_Array, 1, array_TypeNew,
43287:                                    NULL, array_methods, NULL, array_static_methods);
48551:     if (!proto)
    1:         return NULL;
52513: 
75720:     if (!JS_AddTypeProperty(cx, proto, "length", INT_TO_JSVAL(0)))
75720:         return NULL;
75720:     JS_ALWAYS_TRUE(proto->setArrayLength(cx, 0));
75679: 
75679:     /* The default 'new' object for Array.prototype has unknown properties. */
75720:     TypeObject *newType = proto->getNewType(cx);
75720:     if (!newType || !cx->markTypeObjectUnknownProperties(newType))
75720:         return NULL;
75679: 
    1:     return proto;
    1: }
    1: 
59234: /*
59234:  * Array allocation functions.
59234:  */
59234: namespace js {
59234: 
59234: template<bool allocateCapacity>
59234: static JS_ALWAYS_INLINE JSObject *
59234: NewArray(JSContext *cx, jsuint length, JSObject *proto)
59234: {
59234:     JS_ASSERT_IF(proto, proto->isArray());
59234: 
59234:     gc::FinalizeKind kind = GuessObjectGCKind(length, true);
59234:     JSObject *obj = detail::NewObject<WithProto::Class, false>(cx, &js_ArrayClass, proto, NULL, kind);
60255:     if (!obj)
60255:         return NULL;
59234: 
75720:     if (!obj->setArrayLength(cx, length))
59234:         return NULL;
59234: 
75899:     if (allocateCapacity) {
75899:         if (!obj->ensureSlots(cx, length))
64345:             return NULL;
75900:     }
75900: 
75899:     if (!cx->typeInferenceEnabled())
75899:         obj->backfillDenseArrayHoles();
64345: 
59234:     return obj;
59234: }
59234: 
59234: JSObject * JS_FASTCALL
59234: NewDenseEmptyArray(JSContext *cx, JSObject *proto)
59234: {
59234:     return NewArray<false>(cx, 0, proto);
59234: }
59234: 
59234: JSObject * JS_FASTCALL
59234: NewDenseAllocatedArray(JSContext *cx, uint32 length, JSObject *proto)
59234: {
59234:     return NewArray<true>(cx, length, proto);
59234: }
59234: 
59234: JSObject * JS_FASTCALL
75688: NewDenseAllocatedEmptyArray(JSContext *cx, uint length, JSObject *proto)
75688: {
75900:     return NewArray<true>(cx, length, proto);
75688: }
75688: 
75688: JSObject * JS_FASTCALL
59234: NewDenseUnallocatedArray(JSContext *cx, uint32 length, JSObject *proto)
59234: {
59234:     return NewArray<false>(cx, length, proto);
59234: }
59234: 
75900: #ifdef JS_METHODJIT
75900: JSObject * JS_FASTCALL
75900: mjit::stubs::NewDenseUnallocatedArray(VMFrame &f, uint32 length)
75900: {
75900:     JSObject *proto = (JSObject *) f.scratch;
75900:     JSObject *obj = NewArray<false>(f.cx, length, proto);
75900:     if (!obj) {
75900:         js_ReportOutOfMemory(f.cx);
75900:         THROWV(NULL);
75900:     }
75900:     return obj;
75900: }
75900: #endif
75900: 
    1: JSObject *
59234: NewDenseCopiedArray(JSContext *cx, uintN length, Value *vp, JSObject *proto)
    1: {
59234:     JSObject* obj = NewArray<true>(cx, length, proto);
60255:     if (!obj)
60255:         return NULL;
60255: 
59234:     JS_ASSERT(obj->getDenseArrayCapacity() >= length);
59234: 
75900:     if (cx->typeInferenceEnabled()) {
75692:         if (vp) {
59234:             memcpy(obj->getDenseArrayElements(), vp, length * sizeof(Value));
75688:             obj->setDenseArrayInitializedLength(length);
75692:         } else {
75692:             obj->setDenseArrayInitializedLength(0);
75692:         }
75900:     } else if (vp) {
75900:         memcpy(obj->getDenseArrayElements(), vp, length * sizeof(Value));
75900:     }
59234: 
59234:     return obj;
59234: }
59234: 
59234: #ifdef JS_TRACER
59234: JS_DEFINE_CALLINFO_2(extern, OBJECT, NewDenseEmptyArray, CONTEXT, OBJECT, 0,
59234:                      nanojit::ACCSET_STORE_ANY)
59234: JS_DEFINE_CALLINFO_3(extern, OBJECT, NewDenseAllocatedArray, CONTEXT, UINT32, OBJECT, 0,
59234:                      nanojit::ACCSET_STORE_ANY)
75688: JS_DEFINE_CALLINFO_3(extern, OBJECT, NewDenseAllocatedEmptyArray, CONTEXT, UINT32, OBJECT, 0,
75688:                      nanojit::ACCSET_STORE_ANY)
59234: JS_DEFINE_CALLINFO_3(extern, OBJECT, NewDenseUnallocatedArray, CONTEXT, UINT32, OBJECT, 0,
59234:                      nanojit::ACCSET_STORE_ANY)
59234: #endif
59234: 
59234: 
59234: 
59234: JSObject *
59234: NewSlowEmptyArray(JSContext *cx)
59234: {
59234:     JSObject *obj = NewNonFunction<WithProto::Class>(cx, &js_SlowArrayClass, NULL, NULL);
62076:     if (!obj || !AddLengthProperty(cx, obj))
    1:         return NULL;
    1: 
75720:     JS_ALWAYS_TRUE(obj->setArrayLength(cx, 0));
11835:     return obj;
11835: }
11835: 
59234: }
59234: 
59234: 
54568: #ifdef DEBUG
11835: JSBool
54568: js_ArrayInfo(JSContext *cx, uintN argc, jsval *vp)
11835: {
11835:     uintN i;
11835:     JSObject *array;
11835: 
11835:     for (i = 0; i < argc; i++) {
54568:         Value arg = Valueify(JS_ARGV(cx, vp)[i]);
54568: 
54568:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, arg, NULL);
11835:         if (!bytes)
11835:             return JS_FALSE;
54568:         if (arg.isPrimitive() ||
54568:             !(array = arg.toObjectOrNull())->isArray()) {
11835:             fprintf(stderr, "%s: not array\n", bytes);
64560:             cx->free_(bytes);
11835:             continue;
11835:         }
54568:         fprintf(stderr, "%s: %s (len %u", bytes,
54568:                 array->isDenseArray() ? "dense" : "sparse",
40796:                 array->getArrayLength());
39928:         if (array->isDenseArray()) {
54568:             fprintf(stderr, ", capacity %u",
41782:                     array->getDenseArrayCapacity());
11835:         }
11835:         fputs(")\n", stderr);
64560:         cx->free_(bytes);
11835:     }
54568: 
54568:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
54568:     return true;
11835: }
11835: #endif
18268: 
18293: JS_FRIEND_API(JSBool)
29066: js_CoerceArrayToCanvasImageData(JSObject *obj, jsuint offset, jsuint count,
18268:                                 JSUint8 *dest)
18268: {
18268:     uint32 length;
18268: 
37003:     if (!obj || !obj->isDenseArray())
18268:         return JS_FALSE;
18268: 
40796:     length = obj->getArrayLength();
18268:     if (length < offset + count)
18268:         return JS_FALSE;
18268: 
18268:     JSUint8 *dp = dest;
18268:     for (uintN i = offset; i < offset+count; i++) {
48470:         const Value &v = obj->getDenseArrayElement(i);
48470:         if (v.isInt32()) {
48470:             jsint vi = v.toInt32();
29066:             if (jsuint(vi) > 255)
29066:                 vi = (vi < 0) ? 0 : 255;
29066:             *dp++ = JSUint8(vi);
48470:         } else if (v.isDouble()) {
48470:             jsdouble vd = v.toDouble();
29066:             if (!(vd >= 0)) /* Not < so that NaN coerces to 0 */
29066:                 *dp++ = 0;
29066:             else if (vd > 255)
29066:                 *dp++ = 255;
29066:             else {
29066:                 jsdouble toTruncate = vd + 0.5;
29066:                 JSUint8 val = JSUint8(toTruncate);
29066: 
29066:                 /*
29066:                  * now val is rounded to nearest, ties rounded up.  We want
29066:                  * rounded to nearest ties to even, so check whether we had a
29066:                  * tie.
29066:                  */
29066:                 if (val == toTruncate) {
29066:                   /*
29066:                    * It was a tie (since adding 0.5 gave us the exact integer
29066:                    * we want).  Since we rounded up, we either already have an
29066:                    * even number or we have an odd number but the number we
29066:                    * want is one less.  So just unconditionally masking out the
29066:                    * ones bit should do the trick to get us the value we
29066:                    * want.
29066:                    */
29066:                   *dp++ = (val & ~1);
29066:                 } else {
29066:                   *dp++ = val;
29066:                 }
29066:             }
29066:         } else {
18268:             return JS_FALSE;
29066:         }
18268:     }
18268: 
18268:     return JS_TRUE;
18268: }
34198: 
41512: JS_FRIEND_API(JSBool)
41512: js_IsDensePrimitiveArray(JSObject *obj)
41512: {
41512:     if (!obj || !obj->isDenseArray())
41512:         return JS_FALSE;
41512: 
48614:     jsuint capacity = obj->getDenseArrayCapacity();
48614:     for (jsuint i = 0; i < capacity; i++) {
55746:         if (obj->getDenseArrayElement(i).isObject())
41512:             return JS_FALSE;
41512:     }
41512: 
41512:     return JS_TRUE;
41512: }
41512: 
41512: JS_FRIEND_API(JSBool)
41512: js_CloneDensePrimitiveArray(JSContext *cx, JSObject *obj, JSObject **clone)
41512: {
41512:     JS_ASSERT(obj);
41512:     if (!obj->isDenseArray()) {
41512:         /*
41512:          * This wasn't a dense array. Return JS_TRUE but a NULL clone to signal
41512:          * that no exception was encountered.
41512:          */
41512:         *clone = NULL;
41512:         return JS_TRUE;
41512:     }
41512: 
41512:     jsuint length = obj->getArrayLength();
75671:     jsuint initlen = obj->getDenseArrayInitializedLength();
41512: 
64229:     AutoValueVector vector(cx);
75671:     if (!vector.reserve(initlen))
41512:         return JS_FALSE;
41512: 
75671:     for (jsuint i = 0; i < initlen; i++) {
55746:         const Value &val = obj->getDenseArrayElement(i);
48470: 
48470:         if (val.isString()) {
41512:             // Strings must be made immutable before being copied to a clone.
64345:             if (!val.toString()->ensureFixed(cx))
41512:                 return JS_FALSE;
48470:         } else if (val.isObject()) {
41512:             /*
41512:              * This wasn't an array of primitives. Return JS_TRUE but a null
41512:              * clone to signal that no exception was encountered.
41512:              */
41512:             *clone = NULL;
41512:             return JS_TRUE;
41512:         }
41512: 
64229:         vector.infallibleAppend(val);
41512:     }
41512: 
75688:     *clone = NewDenseCopiedArray(cx, initlen, vector.begin());
41512:     if (!*clone)
41512:         return JS_FALSE;
59234: 
75720:     if (!obj->isPackedDenseArray() && !(*clone)->setDenseArrayNotPacked(cx))
75720:         return JS_FALSE;
75688: 
75688:     /* The length will be set to the initlen, above, but length might be larger. */
75720:     return (*clone)->setArrayLength(cx, length);
75720: }
