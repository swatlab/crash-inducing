    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is thebes gfx code.
    1:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxPlatformMac.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxQuartzSurface.h"
11244: #include "gfxQuartzImageSurface.h"
    1: 
31590: #include "gfxMacPlatformFontList.h"
39206: #include "gfxMacFont.h"
39206: #include "gfxCoreTextShaper.h"
19962: #include "gfxUserFontSet.h"
26688: 
11086: #include "nsIPrefBranch.h"
11086: #include "nsIPrefService.h"
11086: #include "nsIPrefLocalizedString.h"
11086: #include "nsServiceManagerUtils.h"
11086: #include "nsCRT.h"
23904: #include "nsTArray.h"
26688: #include "nsUnicodeRange.h"
11086: 
27035: #include "qcms.h"
 3787: 
    1: gfxPlatformMac::gfxPlatformMac()
    1: {
14465:     mOSXVersion = 0;
14836:     mFontAntiAliasingThreshold = ReadAntiAliasingThreshold();
26688: }
26688: 
26688: gfxPlatformMac::~gfxPlatformMac()
26688: {
39206:     gfxCoreTextShaper::Shutdown();
    1: }
    1: 
31590: gfxPlatformFontList*
31590: gfxPlatformMac::CreatePlatformFontList()
31590: {
57104:     gfxPlatformFontList* list = new gfxMacPlatformFontList();
57104:     if (NS_SUCCEEDED(list->InitFontList())) {
57104:         return list;
57104:     }
57104:     gfxPlatformFontList::Shutdown();
57104:     return nsnull;
31590: }
31590: 
    1: already_AddRefed<gfxASurface>
    1: gfxPlatformMac::CreateOffscreenSurface(const gfxIntSize& size,
54253:                                        gfxASurface::gfxContentType contentType)
    1: {
    1:     gfxASurface *newSurface = nsnull;
    1: 
54253:     newSurface = new gfxQuartzSurface(size, gfxASurface::FormatFromContent(contentType));
    1: 
    1:     NS_IF_ADDREF(newSurface);
    1:     return newSurface;
    1: }
    1: 
11244: already_AddRefed<gfxASurface>
11244: gfxPlatformMac::OptimizeImage(gfxImageSurface *aSurface,
11244:                               gfxASurface::gfxImageFormat format)
11244: {
11244:     const gfxIntSize& surfaceSize = aSurface->GetSize();
11244:     nsRefPtr<gfxImageSurface> isurf = aSurface;
11244: 
11244:     if (format != aSurface->Format()) {
11244:         isurf = new gfxImageSurface (surfaceSize, format);
11244:         if (!isurf->CopyFrom (aSurface)) {
11244:             // don't even bother doing anything more
11244:             NS_ADDREF(aSurface);
11244:             return aSurface;
11244:         }
11244:     }
11244: 
11244:     nsRefPtr<gfxASurface> ret = new gfxQuartzImageSurface(isurf);
11244:     return ret.forget();
11244: }
11244: 
    1: nsresult
    1: gfxPlatformMac::ResolveFontName(const nsAString& aFontName,
    1:                                 FontResolverCallback aCallback,
    1:                                 void *aClosure, PRBool& aAborted)
    1: {
    1:     nsAutoString resolvedName;
31590:     if (!gfxPlatformFontList::PlatformFontList()->
    1:              ResolveFontName(aFontName, resolvedName)) {
    1:         aAborted = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1:     aAborted = !(*aCallback)(resolvedName, aClosure);
    1:     return NS_OK;
    1: }
    1: 
13003: nsresult
13003: gfxPlatformMac::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
13003: {
31590:     gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName, aFamilyName);
13003:     return NS_OK;
13003: }
13003: 
  270: gfxFontGroup *
  270: gfxPlatformMac::CreateFontGroup(const nsAString &aFamilies,
19962:                                 const gfxFontStyle *aStyle,
19962:                                 gfxUserFontSet *aUserFontSet)
  270: {
37211:     return new gfxFontGroup(aFamilies, aStyle, aUserFontSet);
19962: }
19962: 
31590: // these will move to gfxPlatform once all platforms support the fontlist
19962: gfxFontEntry* 
23273: gfxPlatformMac::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                 const nsAString& aFontName)
19962: {
31590:     return gfxPlatformFontList::PlatformFontList()->LookupLocalFont(aProxyEntry, 
24932:                                                                     aFontName);
19962: }
19962: 
19962: gfxFontEntry* 
22397: gfxPlatformMac::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
22397:                                  const PRUint8 *aFontData, PRUint32 aLength)
19962: {
36949:     // Ownership of aFontData is received here, and passed on to
36949:     // gfxPlatformFontList::MakePlatformFont(), which must ensure the data
36949:     // is released with NS_Free when no longer needed
36949:     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aProxyEntry,
32808:                                                                      aFontData,
32808:                                                                      aLength);
19962: }
19962: 
19962: PRBool
19962: gfxPlatformMac::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
19962: {
23576:     // check for strange format flags
23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
23576:                  "strange font format hint set");
23576: 
23576:     // accept supported formats
32809:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_WOFF     |
32809:                         gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE_AAT)) {
23576:         return PR_TRUE;
23576:     }
23576: 
23576:     // reject all other formats, known and unknown
23576:     if (aFormatFlags != 0) {
19962:         return PR_FALSE;
19962:     }
19962: 
23576:     // no format hint set, need to look at data
19962:     return PR_TRUE;
  270: }
  270: 
31590: // these will also move to gfxPlatform once all platforms support the fontlist
    1: nsresult
38493: gfxPlatformMac::GetFontList(nsIAtom *aLangGroup,
    1:                             const nsACString& aGenericFamily,
23904:                             nsTArray<nsString>& aListOfFonts)
    1: {
31590:     gfxPlatformFontList::PlatformFontList()->GetFontList(aLangGroup, aGenericFamily, aListOfFonts);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: gfxPlatformMac::UpdateFontList()
    1: {
31590:     gfxPlatformFontList::PlatformFontList()->UpdateFontList();
    1:     return NS_OK;
    1: }
 3787: 
14465: PRInt32 
14465: gfxPlatformMac::OSXVersion()
14465: {
14465:     if (!mOSXVersion) {
14465:         // minor version is not accurate, use gestaltSystemVersionMajor, gestaltSystemVersionMinor, gestaltSystemVersionBugFix for these
31590:         OSErr err = ::Gestalt(gestaltSystemVersion, reinterpret_cast<SInt32*>(&mOSXVersion));
14465:         if (err != noErr) {
14465:             //This should probably be changed when our minimum version changes
14465:             NS_ERROR("Couldn't determine OS X version, assuming 10.4");
14465:             mOSXVersion = MAC_OS_X_VERSION_10_4_HEX;
14465:         }
14465:     }
14465:     return mOSXVersion;
14465: }
14465: 
14836: PRUint32
14836: gfxPlatformMac::ReadAntiAliasingThreshold()
14836: {
14836:     PRUint32 threshold = 0;  // default == no threshold
14836:     
14836:     // first read prefs flag to determine whether to use the setting or not
14836:     PRBool useAntiAliasingThreshold = PR_FALSE;
14836:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
14836:     if (prefs) {
14836:         PRBool enabled;
14836:         nsresult rv =
14836:             prefs->GetBoolPref("gfx.use_text_smoothing_setting", &enabled);
14836:         if (NS_SUCCEEDED(rv)) {
14836:             useAntiAliasingThreshold = enabled;
14836:         }
14836:     }
14836:     
14836:     // if the pref setting is disabled, return 0 which effectively disables this feature
14836:     if (!useAntiAliasingThreshold)
14836:         return threshold;
14836:         
14836:     // value set via Appearance pref panel, "Turn off text smoothing for font sizes xxx and smaller"
14836:     CFNumberRef prefValue = (CFNumberRef)CFPreferencesCopyAppValue(CFSTR("AppleAntiAliasingThreshold"), kCFPreferencesCurrentApplication);
14836: 
14836:     if (prefValue) {
14836:         if (!CFNumberGetValue(prefValue, kCFNumberIntType, &threshold)) {
14836:             threshold = 0;
14836:         }
14836:         CFRelease(prefValue);
14836:     }
14836: 
14836:     return threshold;
14836: }
11086: 
27035: qcms_profile *
 3787: gfxPlatformMac::GetPlatformCMSOutputProfile()
 3787: {
33428:     qcms_profile *profile = nsnull;
33428:     CMProfileRef cmProfile;
33428:     CMProfileLocation *location;
33428:     UInt32 locationSize;
33428: 
33428:     /* There a number of different ways that we could try to get a color
33428:        profile to use.  On 10.5 all of these methods seem to give the same
33428:        results. On 10.6, the results are different and the following method,
33428:        using CGMainDisplayID() seems to best match what we are looking for.
33428:        Currently, both Google Chrome and Qt4 use a similar method.
33428: 
33428:        CMTypes.h describes CMDisplayIDType:
33428:        "Data type for ColorSync DisplayID reference
33428:         On 8 & 9 this is a AVIDType
33428: 	On X this is a CGSDisplayID"
33428: 
33428:        CGMainDisplayID gives us a CGDirectDisplayID which presumeably
33428:        corresponds directly to a CGSDisplayID */
33428:     CGDirectDisplayID displayID = CGMainDisplayID();
33428: 
33428:     CMError err = CMGetProfileByAVID(static_cast<CMDisplayIDType>(displayID), &cmProfile);
 3787:     if (err != noErr)
 3787:         return nsnull;
 3787: 
33428:     // get the size of location
33428:     err = NCMGetProfileLocation(cmProfile, NULL, &locationSize);
33428:     if (err != noErr)
33428:         return nsnull;
33428: 
33428:     // allocate enough room for location
33428:     location = static_cast<CMProfileLocation*>(malloc(locationSize));
33428:     if (!location)
33428:         goto fail_close;
33428: 
33428:     err = NCMGetProfileLocation(cmProfile, location, &locationSize);
33428:     if (err != noErr)
33428:         goto fail_location;
33428: 
33428:     switch (location->locType) {
27622: #ifndef __LP64__
 3787:     case cmFileBasedProfile: {
 3787:         FSRef fsRef;
33428:         if (!FSpMakeFSRef(&location->u.fileLoc.spec, &fsRef)) {
 3787:             char path[512];
31590:             if (!FSRefMakePath(&fsRef, reinterpret_cast<UInt8*>(path), sizeof(path))) {
27035:                 profile = qcms_profile_from_path(path);
 3787: #ifdef DEBUG_tor
 3787:                 if (profile)
 3787:                     fprintf(stderr,
 3787:                             "ICM profile read from %s fileLoc successfully\n", path);
 3787: #endif
 3787:             }
 3787:         }
 3787:         break;
 3787:     }
27622: #endif
 3787:     case cmPathBasedProfile:
33428:         profile = qcms_profile_from_path(location->u.pathLoc.path);
 3787: #ifdef DEBUG_tor
 3787:         if (profile)
 3787:             fprintf(stderr,
 3787:                     "ICM profile read from %s pathLoc successfully\n",
 3787:                     device.u.pathLoc.path);
 3787: #endif
 3787:         break;
 3787:     default:
 3787: #ifdef DEBUG_tor
 3787:         fprintf(stderr, "Unhandled ColorSync profile location\n");
 3787: #endif
 3787:         break;
 3787:     }
 3787: 
33428: fail_location:
33428:     free(location);
33428: fail_close:
33428:     CMCloseProfile(cmProfile);
 3787:     return profile;
 3787: }
