29300: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
29300:  * vim: sw=2 ts=2 sts=2 et
29300:  * ***** BEGIN LICENSE BLOCK *****
29300:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29300:  *
29300:  * The contents of this file are subject to the Mozilla Public License Version
29300:  * 1.1 (the "License"); you may not use this file except in compliance with
29300:  * the License. You may obtain a copy of the License at
29300:  * http://www.mozilla.org/MPL/
29300:  *
29300:  * Software distributed under the License is distributed on an "AS IS" basis,
29300:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29300:  * for the specific language governing rights and limitations under the
29300:  * License.
29300:  *
29300:  * The Original Code is mozilla.org code.
29300:  *
29300:  * The Initial Developer of the Original Code is
63115:  * the Mozilla Foundation.
29300:  * Portions created by the Initial Developer are Copyright (C) 2009
29300:  * the Initial Developer. All Rights Reserved.
29300:  *
29300:  * Contributor(s):
29300:  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
29300:  *
29300:  * Alternatively, the contents of this file may be used under the terms of
29300:  * either the GNU General Public License Version 2 or later (the "GPL"), or
29300:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29300:  * in which case the provisions of the GPL or the LGPL are applicable instead
29300:  * of those above. If you wish to allow use of your version of this file only
29300:  * under the terms of either the GPL or the LGPL, and not to allow others to
29300:  * use your version of this file under the terms of the MPL, indicate your
29300:  * decision by deleting the provisions above and replace them with the notice
29300:  * and other provisions required by the GPL or the LGPL. If you do not delete
29300:  * the provisions above, a recipient may use your version of this file under
29300:  * the terms of any one of the MPL, the GPL or the LGPL.
29300:  *
29300:  * ***** END LICENSE BLOCK ***** */
29300: 
43071: #ifndef mozStorageStatementData_h
43071: #define mozStorageStatementData_h
29300: 
30834: #include "sqlite3.h"
30834: 
29300: #include "nsAutoPtr.h"
29300: #include "nsTArray.h"
63115: #include "nsIEventTarget.h"
63115: #include "nsProxyRelease.h"
29300: 
29300: #include "mozStorageBindingParamsArray.h"
39769: #include "mozIStorageBaseStatement.h"
39769: #include "mozStorageConnection.h"
39769: #include "StorageBaseStatementInternal.h"
29300: 
29300: struct sqlite3_stmt;
29300: 
29300: namespace mozilla {
29300: namespace storage {
29300: 
29300: class StatementData
29300: {
29300: public:
29300:   StatementData(sqlite3_stmt *aStatement,
30834:                 already_AddRefed<BindingParamsArray> aParamsArray,
39769:                 StorageBaseStatementInternal *aStatementOwner)
29300:   : mStatement(aStatement)
29300:   , mParamsArray(aParamsArray)
30834:   , mStatementOwner(aStatementOwner)
29300:   {
63115:     NS_PRECONDITION(mStatementOwner, "Must have a statement owner!");
29300:   }
29300:   StatementData(const StatementData &aSource)
29300:   : mStatement(aSource.mStatement)
29300:   , mParamsArray(aSource.mParamsArray)
30834:   , mStatementOwner(aSource.mStatementOwner)
29300:   {
63115:     NS_PRECONDITION(mStatementOwner, "Must have a statement owner!");
29300:   }
29300:   StatementData()
29300:   {
29300:   }
29300: 
39769:   /**
39769:    * Return the sqlite statement, fetching it from the storage statement.  In
39769:    * the case of AsyncStatements this may actually create the statement 
39769:    */
39769:   inline int getSqliteStatement(sqlite3_stmt **_stmt)
29300:   {
39769:     if (!mStatement) {
39769:       int rc = mStatementOwner->getAsyncStatement(&mStatement);
39769:       NS_ENSURE_TRUE(rc == SQLITE_OK, rc);
29300:     }
39769:     *_stmt = mStatement;
39769:     return SQLITE_OK;
39769:   }
39769: 
29300:   operator BindingParamsArray *() const { return mParamsArray; }
29300: 
29300:   /**
39769:    * Provide the ability to coerce back to a sqlite3 * connection for purposes 
39769:    * of getting an error message out of it.
39769:    */
39769:   operator sqlite3 *() const
39769:   {
39769:     return mStatementOwner->getOwner()->GetNativeConnection();
39769:   }
39769: 
39769:   /**
30834:    * NULLs out our sqlite3_stmt (it is held by the owner) after reseting it and
39769:    * clear all bindings to it.  This is expected to occur on the async thread.
39769:    *
63115:    * @param aReleaseThread
63115:    *        The thread that we should release mParamsArray and mStatementOwner
63115:    *        on.  This may not be the thread we are called on.
29300:    */
63115:   inline void finalize(nsIEventTarget *aReleaseThread)
29300:   {
63115:     NS_PRECONDITION(aReleaseThread, "Must have a non-NULL release thread!");
63115:     NS_PRECONDITION(mStatementOwner, "Must have a statement owner!");
63115: #ifdef DEBUG
63115:     {
63115:       nsCOMPtr<nsIEventTarget> asyncThread =
63115:         mStatementOwner->getOwner()->getAsyncExecutionTarget();
63115:       // It's possible that we are shutting down the async thread, and this
63115:       // method would return NULL as a result.
63115:       if (asyncThread) {
63115:         PRBool onAsyncThread;
63115:         NS_ASSERTION(NS_SUCCEEDED(asyncThread->IsOnCurrentThread(&onAsyncThread)) && onAsyncThread,
63115:                      "This should only be running on the async thread!");
63115:       }
63115:     }
63115: #endif
39769:     // In the AsyncStatement case we may never have populated mStatement if the
39769:     // AsyncExecuteStatements got canceled or a failure occurred in constructing
39769:     // the statement.
39769:     if (mStatement) {
30834:       (void)::sqlite3_reset(mStatement);
30834:       (void)::sqlite3_clear_bindings(mStatement);
29300:       mStatement = NULL;
39769:     }
63115:     (void)NS_ProxyRelease(aReleaseThread, mStatementOwner, PR_TRUE);
63115:     if (mParamsArray) {
63115:       (void)NS_ProxyRelease(aReleaseThread, mParamsArray, PR_TRUE);
63115:     }
29300:   }
29300: 
29300:   /**
29300:    * Indicates if this statement has parameters to be bound before it is
29300:    * executed.
29300:    *
30834:    * @return true if the statement has parameters to bind against, false
29300:    *         otherwise.
29300:    */
42000:   inline bool hasParametersToBeBound() const { return !!mParamsArray; }
30834:   /**
30834:    * Indicates if this statement needs a transaction for execution.
30834:    *
30834:    * @return true if the statement needs a transaction, false otherwise.
30834:    */
30834:   inline bool needsTransaction() const
30834:   {
30834:     return mParamsArray != nsnull && mParamsArray->length() > 1;
30834:   }
29300: 
29300: private:
29300:   sqlite3_stmt *mStatement;
29300:   nsRefPtr<BindingParamsArray> mParamsArray;
30834: 
30834:   /**
30834:    * We hold onto a reference of the statement's owner so it doesn't get
30834:    * destroyed out from under us.
30834:    */
39769:   nsCOMPtr<StorageBaseStatementInternal> mStatementOwner;
29300: };
29300: 
29300: } // namespace storage
29300: } // namespace mozilla
29300: 
43071: #endif // mozStorageStatementData_h
