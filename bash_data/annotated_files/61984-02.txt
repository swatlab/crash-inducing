    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Places.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com> (original author)
33704:  *   Dietrich Ayala <dietrich@mozilla.com>
33704:  *   Marco Bonardo <mak77@bonardo.net>
40626:  *   Drew Willcoxon <adw@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsNavBookmarks_h_
    1: #define nsNavBookmarks_h_
    1: 
    1: #include "nsINavBookmarksService.h"
 1337: #include "nsIAnnotationService.h"
    1: #include "nsITransaction.h"
    1: #include "nsNavHistory.h"
    1: #include "nsToolkitCompsCID.h"
30050: #include "nsCategoryCache.h"
    1: 
39811: namespace mozilla {
39811: namespace places {
39811: 
39811:   enum BookmarkStatementId {
39811:     DB_FIND_REDIRECTED_BOOKMARK = 0
60944:   , DB_GET_BOOKMARKS_FOR_URI
39811:   };
39811: 
60944:   struct ItemVisitData {
60944:     PRInt64 itemId;
60944:     nsCOMPtr<nsIURI> uri;
60944:     PRInt64 visitId;
60944:     PRTime time;
60944:   };
60944: 
60944:   struct ItemChangeData {
60944:     PRInt64 itemId;
60944:     nsCOMPtr<nsIURI> uri;
60944:     nsCString property;
60944:     PRBool isAnnotation;
60944:     nsCString newValue;
60944:     PRTime lastModified;
60944:     PRUint16 itemType;
60944:   };
60944: 
61984:   typedef void (nsNavBookmarks::*ItemVisitMethod)(const ItemVisitData&);
61984:   typedef void (nsNavBookmarks::*ItemChangeMethod)(const ItemChangeData&);
60944: 
39811: } // namespace places
39811: } // namespace mozilla
39811: 
39811: 
    1: class nsIOutputStream;
    1: 
    1: class nsNavBookmarks : public nsINavBookmarksService,
 1337:                        public nsINavHistoryObserver,
 1337:                        public nsIAnnotationObserver
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSINAVBOOKMARKSSERVICE
    1:   NS_DECL_NSINAVHISTORYOBSERVER
 1337:   NS_DECL_NSIANNOTATIONOBSERVER
    1: 
    1:   nsNavBookmarks();
35298: 
35298:   /**
35298:    * Obtains the service's object.
35298:    */
35298:   static nsNavBookmarks* GetSingleton();
35298: 
35298:   /**
35298:    * Initializes the service's object.  This should only be called once.
35298:    */
    1:   nsresult Init();
    1: 
    1:   // called by nsNavHistory::Init
    1:   static nsresult InitTables(mozIStorageConnection* aDBConn);
    1: 
    1:   static nsNavBookmarks* GetBookmarksService() {
35298:     if (!gBookmarksService) {
35298:       nsCOMPtr<nsINavBookmarksService> serv =
35298:         do_GetService(NS_NAVBOOKMARKSSERVICE_CONTRACTID);
35298:       NS_ENSURE_TRUE(serv, nsnull);
35298:       NS_ASSERTION(gBookmarksService,
35298:                    "Should have static instance pointer now");
    1:     }
35298:     return gBookmarksService;
    1:   }
    1: 
37340:   nsresult ResultNodeForContainer(PRInt64 aID,
37340:                                   nsNavHistoryQueryOptions* aOptions,
    1:                                   nsNavHistoryResultNode** aNode);
    1: 
    1:   // Find all the children of a folder, using the given query and options.
    1:   // For each child, a ResultNode is created and added to |children|.
    1:   // The results are ordered by folder position.
    1:   nsresult QueryFolderChildren(PRInt64 aFolderId,
    1:                                nsNavHistoryQueryOptions* aOptions,
    1:                                nsCOMArray<nsNavHistoryResultNode>* children);
    1: 
40626:   /**
40626:    * Turns aRow into a node and appends it to aChildren if it is appropriate to
40626:    * do so.
40626:    *
40626:    * @param aRow
40626:    *        A Storage statement (in the case of synchronous execution) or row of
40626:    *        a result set (in the case of asynchronous execution).
40626:    * @param aOptions
40626:    *        The options of the parent folder node.
40626:    * @param aChildren
40626:    *        The children of the parent folder node.
40626:    * @param aCurrentIndex
40626:    *        The index of aRow within the results.  When called on the first row,
40626:    *        this should be set to -1.
40626:    */
40626:   nsresult ProcessFolderNodeRow(mozIStorageValueArray* aRow,
40626:                                 nsNavHistoryQueryOptions* aOptions,
40626:                                 nsCOMArray<nsNavHistoryResultNode>* aChildren,
40626:                                 PRInt32& aCurrentIndex);
40626: 
40626:   /**
40626:    * The async version of QueryFolderChildren.
40626:    *
40626:    * @param aNode
40626:    *        The folder node that will receive the children.
40626:    * @param _pendingStmt
40626:    *        The Storage pending statement that will be used to control async
40626:    *        execution.
40626:    */
40626:   nsresult QueryFolderChildrenAsync(nsNavHistoryFolderResultNode* aNode,
40626:                                     PRInt64 aFolderId,
40626:                                     mozIStoragePendingStatement** _pendingStmt);
40626: 
    1:   // If aFolder is -1, uses the autoincrement id for folder index. Returns
    1:   // the index of the new folder in aIndex, whether it was passed in or
 4179:   // generated by autoincrement.
 4179:   nsresult CreateContainerWithID(PRInt64 aId, PRInt64 aParent,
10046:                                  const nsACString& aName,
 4179:                                  const nsAString& aContractId,
 4179:                                  PRBool aIsBookmarkFolder,
 4179:                                  PRInt32* aIndex,
 4179:                                  PRInt64* aNewFolder);
    1: 
24324:   /**
24324:    * Determines if we have a real bookmark or not (not a livemark).
24324:    *
24324:    * @param aPlaceId
24324:    *        The place_id of the location to check against.
29518:    * @return true if it's a real bookmark, false otherwise.
24324:    */
24324:   PRBool IsRealBookmark(PRInt64 aPlaceId);
24324: 
 2780:   PRBool ItemExists(PRInt64 aItemId);
 2780: 
21642:   /**
21642:    * Finalize all internal statements.
21642:    */
21642:   nsresult FinalizeStatements();
21642: 
39811:   mozIStorageStatement* GetStatementById(
39811:     enum mozilla::places::BookmarkStatementId aStatementId
39811:   )
39811:   {
39811:     using namespace mozilla::places;
39811:     switch(aStatementId) {
39811:       case DB_FIND_REDIRECTED_BOOKMARK:
39811:         return GetStatement(mDBFindRedirectedBookmark);
60944:       case DB_GET_BOOKMARKS_FOR_URI:
60944:         return GetStatement(mDBFindURIBookmarks);
39811:     }
39811:     return nsnull;
39811:   }
39811: 
60944:   /**
60944:    * Notifies that a bookmark has been visited.
60944:    *
60944:    * @param aItemId
60944:    *        The visited item id.
60944:    * @param aData
60944:    *        Details about the new visit.
60944:    */
61984:   void NotifyItemVisited(const mozilla::places::ItemVisitData& aData);
60944: 
60944:   /**
60944:    * Notifies that a bookmark has changed.
60944:    *
60944:    * @param aItemId
60944:    *        The changed item id.
60944:    * @param aData
60944:    *        Details about the change.
60944:    */
61984:   void NotifyItemChanged(const mozilla::places::ItemChangeData& aData);
60944: 
    1: private:
35298:   static nsNavBookmarks* gBookmarksService;
    1: 
    1:   ~nsNavBookmarks();
    1: 
59312:   /**
59312:    * Locates the root items in the bookmarks folder hierarchy assigning folder
59312:    * ids to the root properties that are exposed through the service interface.
59312:    * 
59312:    * @param aForceCreate
59312:    *        Whether the method should try creating the roots.  It should be set
59312:    *        to true if the database has just been created or upgraded.
59312:    *
59312:    * @note The creation of roots skips already existing entries.
59312:    */
59312:   nsresult InitRoots(bool aForceCreate);
59312: 
59312:   /**
59312:    * Tries to create a root folder with the given name.
59312:    *
59312:    * @param name
59312:    *        Name associated to the root.
59312:    * @param _itemId
59312:    *        if set CreateRoot will skip creation, otherwise will return the
59312:    *        newly created folder id.
59312:    * @param aParentId
59312:    *        Id of the parent that should cotain this root.
59312:    * @param aBundle
59312:    *        Stringbundle used to get the visible title of the root.
59312:    * @param aTitleStringId
59312:    *        Id of the title string in the stringbundle.
59312:    */
59312:   nsresult CreateRoot(const nsCString& name,
59312:                       PRInt64* _itemId,
59312:                       PRInt64 aParentId,
59312:                       nsIStringBundle* aBundle,
59312:                       const PRUnichar* aTitleStringId);
    1: 
    1:   nsresult AdjustIndices(PRInt64 aFolder,
37340:                          PRInt32 aStartIndex,
37340:                          PRInt32 aEndIndex,
    1:                          PRInt32 aDelta);
31729: 
37340:   nsresult RemoveFolder(PRInt64 aFolderId);
33340: 
31729:   /**
31729:    * Calculates number of children for the given folder.
31729:    *
31729:    * @param aFolderId Folder to count children for.
31729:    *
31729:    * @return aFolderCount The number of children in this folder.
31729:    *
31729:    * @throws If folder does not exist.
31729:    */
31729:   nsresult FolderCount(PRInt64 aFolderId, PRInt32* aFolderCount);
31729: 
    1:   nsresult GetFolderType(PRInt64 aFolder, nsACString& aType);
    1: 
11268:   nsresult GetLastChildId(PRInt64 aFolder, PRInt64* aItemId);
11268: 
59362:   /**
59362:    * This is the basic Places read-write connection, obtained from history.
59362:    */
20874:   nsCOMPtr<mozIStorageConnection> mDBConn;
59362:   /**
59362:    * Cloned read-only connection.  Can be used to read from the database
59362:    * without being locked out by writers.
59362:    */
59362:   nsCOMPtr<mozIStorageConnection> mDBReadOnlyConn;
    1: 
 4004:   nsString mGUIDBase;
20874:   nsresult GetGUIDBase(nsAString& aGUIDBase);
20874: 
 4004:   PRInt32 mItemCount;
 4004: 
    1:   nsMaybeWeakPtrArray<nsINavBookmarkObserver> mObservers;
59312: 
    1:   PRInt64 mRoot;
59312:   PRInt64 mMenuRoot;
59312:   PRInt64 mTagsRoot;
 5930:   PRInt64 mUnfiledRoot;
59312:   PRInt64 mToolbarRoot;
    1: 
37340:   nsresult GetParentAndIndexOfFolder(PRInt64 aFolder,
37340:                                      PRInt64* aParent,
    1:                                      PRInt32* aIndex);
    1: 
    1:   nsresult IsBookmarkedInDatabase(PRInt64 aBookmarkID, PRBool* aIsBookmarked);
    1: 
37340:   nsresult SetItemDateInternal(mozIStorageStatement* aStatement,
37340:                                PRInt64 aItemId,
37340:                                PRTime aValue);
13203: 
21350:   // Structure to hold folder's children informations
22470:   struct folderChildrenInfo
21350:   {
21350:     PRInt64 itemId;
21350:     PRUint16 itemType;
21350:     PRInt64 placeId;
21350:     PRInt64 parentId;
21350:     PRInt64 grandParentId;
21350:     PRInt32 index;
21350:     nsCString url;
21350:     nsCString folderType;
21350:   };
21350: 
21350:   // Recursive method to build an array of folder's children
21350:   nsresult GetDescendantChildren(PRInt64 aFolderId,
21350:                                  PRInt64 aGrandParentId,
21350:                                  nsTArray<folderChildrenInfo>& aFolderChildrenArray);
21350: 
29518:   enum ItemType {
29518:     BOOKMARK = TYPE_BOOKMARK,
29518:     FOLDER = TYPE_FOLDER,
29518:     SEPARATOR = TYPE_SEPARATOR,
29518:     DYNAMIC_CONTAINER = TYPE_DYNAMIC_CONTAINER
29518:   };
29518: 
29518:   /**
29518:    * Helper to insert a bookmark in the database.
29518:    *
29518:    *  @param aItemId
29518:    *         The itemId to insert, pass -1 to generate a new one.
29518:    *  @param aPlaceId
29518:    *         The placeId to which this bookmark refers to, pass nsnull for
29518:    *         items that don't refer to an URI (eg. folders, separators, ...).
29518:    *  @param aItemType
29518:    *         The type of the new bookmark, see TYPE_* constants.
29518:    *  @param aParentId
29518:    *         The itemId of the parent folder.
29518:    *  @param aIndex
29518:    *         The position inside the parent folder.
29518:    *  @param aTitle
29518:    *         The title for the new bookmark.
29518:    *         Pass a void string to set a NULL title.
29518:    *  @param aDateAdded
29518:    *         The date for the insertion.
29518:    *  @param [optional] aLastModified
29518:    *         The last modified date for the insertion.
29518:    *         It defaults to aDateAdded.
29518:    *  @param [optional] aServiceContractId
29518:    *         The contract id for a dynamic container.
29518:    *         Pass EmptyCString() for other type of containers.
29518:    *
29518:    *  @return The new item id that has been inserted.
29518:    *
29518:    *  @note This will also update last modified date of the parent folder.
29518:    */
29518:   nsresult InsertBookmarkInDB(PRInt64 aItemId,
29518:                               PRInt64 aPlaceId,
29518:                               enum ItemType aItemType,
29518:                               PRInt64 aParentId,
29518:                               PRInt32 aIndex,
29518:                               const nsACString& aTitle,
29518:                               PRTime aDateAdded,
29518:                               PRTime aLastModified,
29518:                               const nsAString& aServiceContractId,
29518:                               PRInt64* _retval);
29518: 
34260:   /**
34260:    * TArray version of getBookmarksIdForURI for ease of use in C++ code.
34260:    * Pass in a reference to a TArray; it will get filled with the
34260:    * resulting list of bookmark IDs.
34260:    */
34260:   nsresult GetBookmarkIdsForURITArray(nsIURI* aURI,
34260:                                       nsTArray<PRInt64>& aResult);
34260: 
39203:   PRInt64 RecursiveFindRedirectedBookmark(PRInt64 aPlaceId);
37341: 
37341:   /**
37341:    *  You should always use this getter and never use directly the nsCOMPtr.
37341:    */
37341:   mozIStorageStatement* GetStatement(const nsCOMPtr<mozIStorageStatement>& aStmt);
37341: 
37341:   nsCOMPtr<mozIStorageStatement> mDBGetChildren;
 8193:   // kGetInfoIndex_* results + kGetChildrenIndex_* results
    1:   static const PRInt32 kGetChildrenIndex_Position;
  338:   static const PRInt32 kGetChildrenIndex_Type;
21350:   static const PRInt32 kGetChildrenIndex_PlaceID;
    1:   static const PRInt32 kGetChildrenIndex_FolderTitle;
21350:   static const PRInt32 kGetChildrenIndex_ServiceContractId;
    1: 
37341:   nsCOMPtr<mozIStorageStatement> mDBFindURIBookmarks;
    1:   static const PRInt32 kFindBookmarksIndex_ID;
  338:   static const PRInt32 kFindBookmarksIndex_Type;
21350:   static const PRInt32 kFindBookmarksIndex_PlaceID;
    1:   static const PRInt32 kFindBookmarksIndex_Parent;
    1:   static const PRInt32 kFindBookmarksIndex_Position;
    1:   static const PRInt32 kFindBookmarksIndex_Title;
    1: 
37341:   nsCOMPtr<mozIStorageStatement> mDBGetItemProperties;
 1297:   static const PRInt32 kGetItemPropertiesIndex_ID;
37341:   static const PRInt32 kGetItemPropertiesIndex_URI;
 1297:   static const PRInt32 kGetItemPropertiesIndex_Title;
 1297:   static const PRInt32 kGetItemPropertiesIndex_Position;
 1297:   static const PRInt32 kGetItemPropertiesIndex_PlaceID;
 1297:   static const PRInt32 kGetItemPropertiesIndex_Parent;
 1297:   static const PRInt32 kGetItemPropertiesIndex_Type;
 4179:   static const PRInt32 kGetItemPropertiesIndex_ServiceContractId;
 1604:   static const PRInt32 kGetItemPropertiesIndex_DateAdded;
 1604:   static const PRInt32 kGetItemPropertiesIndex_LastModified;
    1: 
 7778:   nsCOMPtr<mozIStorageStatement> mDBInsertBookmark;
29518:   static const PRInt32 kInsertBookmarkIndex_Id;
29518:   static const PRInt32 kInsertBookmarkIndex_PlaceId;
29518:   static const PRInt32 kInsertBookmarkIndex_Type;
29518:   static const PRInt32 kInsertBookmarkIndex_Parent;
29518:   static const PRInt32 kInsertBookmarkIndex_Position;
29518:   static const PRInt32 kInsertBookmarkIndex_Title;
29518:   static const PRInt32 kInsertBookmarkIndex_ServiceContractId;
29518:   static const PRInt32 kInsertBookmarkIndex_DateAdded;
29518:   static const PRInt32 kInsertBookmarkIndex_LastModified;
29518: 
37341:   nsCOMPtr<mozIStorageStatement> mDBFolderCount;
37341:   nsCOMPtr<mozIStorageStatement> mDBGetItemIndex;
37341:   nsCOMPtr<mozIStorageStatement> mDBGetChildAt;
37341:   nsCOMPtr<mozIStorageStatement> mDBGetItemIdForGUID;
 7778:   nsCOMPtr<mozIStorageStatement> mDBIsBookmarkedInDatabase;
39203:   nsCOMPtr<mozIStorageStatement> mDBIsURIBookmarkedInDatabase;
24324:   nsCOMPtr<mozIStorageStatement> mDBIsRealBookmark;
16751:   nsCOMPtr<mozIStorageStatement> mDBGetLastBookmarkID;
 7778:   nsCOMPtr<mozIStorageStatement> mDBSetItemDateAdded;
 7778:   nsCOMPtr<mozIStorageStatement> mDBSetItemLastModified;
 7778:   nsCOMPtr<mozIStorageStatement> mDBSetItemIndex;
    1:   nsCOMPtr<mozIStorageStatement> mDBGetKeywordForURI;
50437:   nsCOMPtr<mozIStorageStatement> mDBGetBookmarksToKeywords;
37340:   nsCOMPtr<mozIStorageStatement> mDBAdjustPosition;
37340:   nsCOMPtr<mozIStorageStatement> mDBRemoveItem;
37340:   nsCOMPtr<mozIStorageStatement> mDBGetLastChildId;
37340:   nsCOMPtr<mozIStorageStatement> mDBMoveItem;
37340:   nsCOMPtr<mozIStorageStatement> mDBSetItemTitle;
37340:   nsCOMPtr<mozIStorageStatement> mDBChangeBookmarkURI;
39203:   nsCOMPtr<mozIStorageStatement> mDBFindRedirectedBookmark;
37340: 
    1:   class RemoveFolderTransaction : public nsITransaction {
    1:   public:
19158:     RemoveFolderTransaction(PRInt64 aID) : mID(aID) {}
    1: 
    1:     NS_DECL_ISUPPORTS
    1: 
    1:     NS_IMETHOD DoTransaction() {
    1:       nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
35298:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
19158:       nsresult rv = bookmarks->GetParentAndIndexOfFolder(mID, &mParent, &mIndex);
19158:       NS_ENSURE_SUCCESS(rv, rv);
19158: 
19158:       rv = bookmarks->GetItemTitle(mID, mTitle);
19158:       NS_ENSURE_SUCCESS(rv, rv);
19158: 
19158:       nsCAutoString type;
19158:       rv = bookmarks->GetFolderType(mID, type);
19158:       NS_ENSURE_SUCCESS(rv, rv);
24715:       CopyUTF8toUTF16(type, mType);
19158: 
    1:       return bookmarks->RemoveFolder(mID);
    1:     }
    1: 
    1:     NS_IMETHOD UndoTransaction() {
    1:       nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
35298:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
    1:       PRInt64 newFolder;
 4179:       return bookmarks->CreateContainerWithID(mID, mParent, mTitle, mType, PR_TRUE,
 4179:                                               &mIndex, &newFolder); 
    1:     }
    1: 
    1:     NS_IMETHOD RedoTransaction() {
    1:       return DoTransaction();
    1:     }
    1: 
    1:     NS_IMETHOD GetIsTransient(PRBool* aResult) {
    1:       *aResult = PR_FALSE;
    1:       return NS_OK;
    1:     }
    1:     
    1:     NS_IMETHOD Merge(nsITransaction* aTransaction, PRBool* aResult) {
    1:       *aResult = PR_FALSE;
    1:       return NS_OK;
    1:     }
    1: 
    1:   private:
    1:     PRInt64 mID;
    1:     PRInt64 mParent;
10046:     nsCString mTitle;
 4179:     nsString mType;
    1:     PRInt32 mIndex;
    1:   };
30050: 
30050:   // Used to enable and disable the observer notifications.
30050:   bool mCanNotify;
30050:   nsCategoryCache<nsINavBookmarkObserver> mCacheObservers;
37340: 
37340:   bool mShuttingDown;
50437: 
59379:   // Tracks whether we are in batch mode.
59379:   // Note: this is only tracking bookmarks batches, not history ones.
59379:   bool mBatching;
59379: 
50437:   /**
50437:    * Always call EnsureKeywordsHash() and check it for errors before actually
50437:    * using the hash.  Internal keyword methods are already doing that.
50437:    */
50437:   nsresult EnsureKeywordsHash();
50437:   nsDataHashtable<nsTrimInt64HashKey, nsString> mBookmarkToKeywordHash;
50437: 
50437:   /**
50437:    * This function must be called every time a bookmark is removed.
50437:    *
50437:    * @param aURI
50437:    *        Uri to test.
50437:    */
50437:   nsresult UpdateKeywordsHashForRemovedBookmark(PRInt64 aItemId);
    1: };
    1: 
    1: #endif // nsNavBookmarks_h_
