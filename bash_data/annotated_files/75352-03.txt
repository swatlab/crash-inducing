58638: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
58638: /* ***** BEGIN LICENSE BLOCK *****
 9699:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 9699:  *
 9699:  * The contents of this file are subject to the Mozilla Public License Version
 9699:  * 1.1 (the "License"); you may not use this file except in compliance with
 9699:  * the License. You may obtain a copy of the License at
 9699:  * http://www.mozilla.org/MPL/
 9699:  *
 9699:  * Software distributed under the License is distributed on an "AS IS" basis,
 9699:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 9699:  * for the specific language governing rights and limitations under the
 9699:  * License.
 9699:  *
 9699:  * The Original Code is thebes gfx code.
 9699:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
31590:  * Portions created by the Initial Developer are Copyright (C) 2007-2009
 9699:  * the Initial Developer. All Rights Reserved.
 9699:  *
 9699:  * Contributor(s):
 9699:  *   Stuart Parmenter <stuart@mozilla.com>
 9699:  *   John Daggett <jdaggett@mozilla.com>
31590:  *   Jonathan Kew <jfkthame@gmail.com>
 9699:  *
 9699:  * Alternatively, the contents of this file may be used under the terms of
 9699:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 9699:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 9699:  * in which case the provisions of the GPL or the LGPL are applicable instead
 9699:  * of those above. If you wish to allow use of your version of this file only
 9699:  * under the terms of either the GPL or the LGPL, and not to allow others to
 9699:  * use your version of this file under the terms of the MPL, indicate your
 9699:  * decision by deleting the provisions above and replace them with the notice
 9699:  * and other provisions required by the GPL or the LGPL. If you do not delete
 9699:  * the provisions above, a recipient may use your version of this file under
 9699:  * the terms of any one of the MPL, the GPL or the LGPL.
 9699:  *
 9699:  * ***** END LICENSE BLOCK ***** */
 9699: 
 9699: #include "gfxFontUtils.h"
 9699: 
12239: #include "nsServiceManagerUtils.h"
12239: 
71640: #include "mozilla/Preferences.h"
71640: 
19962: #include "nsIStreamBufferAccess.h"
26027: #include "nsIUUIDGenerator.h"
22991: #include "nsMemory.h"
31590: #include "nsICharsetConverterManager.h"
 9699: 
26027: #include "plbase64.h"
26027: 
32808: #include "woff.h"
32808: 
26852: #ifdef XP_MACOSX
26852: #include <CoreFoundation/CoreFoundation.h>
26852: #endif
26027: 
 9699: #define NO_RANGE_FOUND 126 // bit 126 in the font unicode ranges is required to be 0
 9699: 
43526: #define UNICODE_BMP_LIMIT 0x10000
43526: 
43526: using namespace mozilla; // for the AutoSwap_* types
43526: 
 9699: /* Unicode subrange table
61084:  *   from: http://msdn.microsoft.com/en-us/library/dd374090
 9699:  *
61084:  * Edit the text to extend the initial digit, then use something like:
61084:  * perl -pi -e 's/^(\d+)\t([\dA-Fa-f]+)\s+-\s+([\dA-Fa-f]+)\s+\b([a-zA-Z0-9\(\)\- ]+)/    { \1, 0x\2, 0x\3, \"\4\" },/' < unicoderange.txt
 9699:  * to generate the below list.
 9699:  */
 9699: struct UnicodeRangeTableEntry
 9699: {
 9699:     PRUint8 bit;
 9699:     PRUint32 start;
 9699:     PRUint32 end;
 9699:     const char *info;
 9699: };
 9699: 
61084: static struct UnicodeRangeTableEntry gUnicodeRanges[] = {
 9699:     { 0, 0x0000, 0x007F, "Basic Latin" },
 9699:     { 1, 0x0080, 0x00FF, "Latin-1 Supplement" },
 9699:     { 2, 0x0100, 0x017F, "Latin Extended-A" },
 9699:     { 3, 0x0180, 0x024F, "Latin Extended-B" },
 9699:     { 4, 0x0250, 0x02AF, "IPA Extensions" },
 9699:     { 4, 0x1D00, 0x1D7F, "Phonetic Extensions" },
 9699:     { 4, 0x1D80, 0x1DBF, "Phonetic Extensions Supplement" },
 9699:     { 5, 0x02B0, 0x02FF, "Spacing Modifier Letters" },
 9699:     { 5, 0xA700, 0xA71F, "Modifier Tone Letters" },
61084:     { 6, 0x0300, 0x036F, "Combining Diacritical Marks" },
 9699:     { 6, 0x1DC0, 0x1DFF, "Combining Diacritical Marks Supplement" },
 9699:     { 7, 0x0370, 0x03FF, "Greek and Coptic" },
 9699:     { 8, 0x2C80, 0x2CFF, "Coptic" },
 9699:     { 9, 0x0400, 0x04FF, "Cyrillic" },
61084:     { 9, 0x0500, 0x052F, "Cyrillic Supplement" },
61084:     { 9, 0x2DE0, 0x2DFF, "Cyrillic Extended-A" },
61084:     { 9, 0xA640, 0xA69F, "Cyrillic Extended-B" },
 9699:     { 10, 0x0530, 0x058F, "Armenian" },
61084:     { 11, 0x0590, 0x05FF, "Hebrew" },
61084:     { 12, 0xA500, 0xA63F, "Vai" },
61084:     { 13, 0x0600, 0x06FF, "Arabic" },
 9699:     { 13, 0x0750, 0x077F, "Arabic Supplement" },
61084:     { 14, 0x07C0, 0x07FF, "NKo" },
 9699:     { 15, 0x0900, 0x097F, "Devanagari" },
 9699:     { 16, 0x0980, 0x09FF, "Bengali" },
 9699:     { 17, 0x0A00, 0x0A7F, "Gurmukhi" },
 9699:     { 18, 0x0A80, 0x0AFF, "Gujarati" },
 9699:     { 19, 0x0B00, 0x0B7F, "Oriya" },
 9699:     { 20, 0x0B80, 0x0BFF, "Tamil" },
 9699:     { 21, 0x0C00, 0x0C7F, "Telugu" },
 9699:     { 22, 0x0C80, 0x0CFF, "Kannada" },
 9699:     { 23, 0x0D00, 0x0D7F, "Malayalam" },
 9699:     { 24, 0x0E00, 0x0E7F, "Thai" },
 9699:     { 25, 0x0E80, 0x0EFF, "Lao" },
 9699:     { 26, 0x10A0, 0x10FF, "Georgian" },
 9699:     { 26, 0x2D00, 0x2D2F, "Georgian Supplement" },
 9699:     { 27, 0x1B00, 0x1B7F, "Balinese" },
 9699:     { 28, 0x1100, 0x11FF, "Hangul Jamo" },
 9699:     { 29, 0x1E00, 0x1EFF, "Latin Extended Additional" },
 9699:     { 29, 0x2C60, 0x2C7F, "Latin Extended-C" },
61084:     { 29, 0xA720, 0xA7FF, "Latin Extended-D" },
 9699:     { 30, 0x1F00, 0x1FFF, "Greek Extended" },
 9699:     { 31, 0x2000, 0x206F, "General Punctuation" },
 9699:     { 31, 0x2E00, 0x2E7F, "Supplemental Punctuation" },
61084:     { 32, 0x2070, 0x209F, "Superscripts And Subscripts" },
 9699:     { 33, 0x20A0, 0x20CF, "Currency Symbols" },
61084:     { 34, 0x20D0, 0x20FF, "Combining Diacritical Marks For Symbols" },
61084:     { 35, 0x2100, 0x214F, "Letterlike Symbols" },
 9699:     { 36, 0x2150, 0x218F, "Number Forms" },
 9699:     { 37, 0x2190, 0x21FF, "Arrows" },
 9699:     { 37, 0x27F0, 0x27FF, "Supplemental Arrows-A" },
 9699:     { 37, 0x2900, 0x297F, "Supplemental Arrows-B" },
 9699:     { 37, 0x2B00, 0x2BFF, "Miscellaneous Symbols and Arrows" },
 9699:     { 38, 0x2200, 0x22FF, "Mathematical Operators" },
 9699:     { 38, 0x27C0, 0x27EF, "Miscellaneous Mathematical Symbols-A" },
 9699:     { 38, 0x2980, 0x29FF, "Miscellaneous Mathematical Symbols-B" },
 9699:     { 38, 0x2A00, 0x2AFF, "Supplemental Mathematical Operators" },
 9699:     { 39, 0x2300, 0x23FF, "Miscellaneous Technical" },
 9699:     { 40, 0x2400, 0x243F, "Control Pictures" },
 9699:     { 41, 0x2440, 0x245F, "Optical Character Recognition" },
 9699:     { 42, 0x2460, 0x24FF, "Enclosed Alphanumerics" },
 9699:     { 43, 0x2500, 0x257F, "Box Drawing" },
 9699:     { 44, 0x2580, 0x259F, "Block Elements" },
 9699:     { 45, 0x25A0, 0x25FF, "Geometric Shapes" },
 9699:     { 46, 0x2600, 0x26FF, "Miscellaneous Symbols" },
 9699:     { 47, 0x2700, 0x27BF, "Dingbats" },
61084:     { 48, 0x3000, 0x303F, "CJK Symbols And Punctuation" },
 9699:     { 49, 0x3040, 0x309F, "Hiragana" },
 9699:     { 50, 0x30A0, 0x30FF, "Katakana" },
 9699:     { 50, 0x31F0, 0x31FF, "Katakana Phonetic Extensions" },
 9699:     { 51, 0x3100, 0x312F, "Bopomofo" },
61084:     { 50, 0x31A0, 0x31BF, "Bopomofo Extended" },
 9699:     { 52, 0x3130, 0x318F, "Hangul Compatibility Jamo" },
 9699:     { 53, 0xA840, 0xA87F, "Phags-pa" },
61084:     { 54, 0x3200, 0x32FF, "Enclosed CJK Letters And Months" },
 9699:     { 55, 0x3300, 0x33FF, "CJK Compatibility" },
61084:     { 56, 0xAC00, 0xD7AF, "Hangul Syllables" },
61084:     { 57, 0xD800, 0xDFFF, "Non-Plane 0" },
 9699:     { 58, 0x10900, 0x1091F, "Phoenician" },
 9699:     { 59, 0x2E80, 0x2EFF, "CJK Radicals Supplement" },
 9699:     { 59, 0x2F00, 0x2FDF, "Kangxi Radicals" },
 9699:     { 59, 0x2FF0, 0x2FFF, "Ideographic Description Characters" },
 9699:     { 59, 0x3190, 0x319F, "Kanbun" },
 9699:     { 59, 0x3400, 0x4DBF, "CJK Unified Ideographs Extension A" },
 9699:     { 59, 0x4E00, 0x9FFF, "CJK Unified Ideographs" },
 9699:     { 59, 0x20000, 0x2A6DF, "CJK Unified Ideographs Extension B" },
61084:     { 60, 0xE000, 0xF8FF, "Private Use Area" },
61084:     { 61, 0x31C0, 0x31EF, "CJK Strokes" },
 9699:     { 61, 0xF900, 0xFAFF, "CJK Compatibility Ideographs" },
 9699:     { 61, 0x2F800, 0x2FA1F, "CJK Compatibility Ideographs Supplement" },
61084:     { 62, 0xFB00, 0xFB4F, "Alphabetic Presentation Forms" },
 9699:     { 63, 0xFB50, 0xFDFF, "Arabic Presentation Forms-A" },
 9699:     { 64, 0xFE20, 0xFE2F, "Combining Half Marks" },
 9699:     { 65, 0xFE10, 0xFE1F, "Vertical Forms" },
 9699:     { 65, 0xFE30, 0xFE4F, "CJK Compatibility Forms" },
 9699:     { 66, 0xFE50, 0xFE6F, "Small Form Variants" },
61084:     { 67, 0xFE70, 0xFEFF, "Arabic Presentation Forms-B" },
61084:     { 68, 0xFF00, 0xFFEF, "Halfwidth And Fullwidth Forms" },
 9699:     { 69, 0xFFF0, 0xFFFF, "Specials" },
 9699:     { 70, 0x0F00, 0x0FFF, "Tibetan" },
 9699:     { 71, 0x0700, 0x074F, "Syriac" },
 9699:     { 72, 0x0780, 0x07BF, "Thaana" },
 9699:     { 73, 0x0D80, 0x0DFF, "Sinhala" },
 9699:     { 74, 0x1000, 0x109F, "Myanmar" },
 9699:     { 75, 0x1200, 0x137F, "Ethiopic" },
 9699:     { 75, 0x1380, 0x139F, "Ethiopic Supplement" },
 9699:     { 75, 0x2D80, 0x2DDF, "Ethiopic Extended" },
 9699:     { 76, 0x13A0, 0x13FF, "Cherokee" },
61084:     { 77, 0x1400, 0x167F, "Unified Canadian Aboriginal Syllabics" },
 9699:     { 78, 0x1680, 0x169F, "Ogham" },
 9699:     { 79, 0x16A0, 0x16FF, "Runic" },
 9699:     { 80, 0x1780, 0x17FF, "Khmer" },
 9699:     { 80, 0x19E0, 0x19FF, "Khmer Symbols" },
 9699:     { 81, 0x1800, 0x18AF, "Mongolian" },
61084:     { 82, 0x2800, 0x28FF, "Braille Patterns" },
61084:     { 83, 0xA000, 0xA48F, "Yi Syllables" },
 9699:     { 83, 0xA490, 0xA4CF, "Yi Radicals" },
 9699:     { 84, 0x1700, 0x171F, "Tagalog" },
 9699:     { 84, 0x1720, 0x173F, "Hanunoo" },
 9699:     { 84, 0x1740, 0x175F, "Buhid" },
 9699:     { 84, 0x1760, 0x177F, "Tagbanwa" },
 9699:     { 85, 0x10300, 0x1032F, "Old Italic" },
 9699:     { 86, 0x10330, 0x1034F, "Gothic" },
61084:     { 87, 0x10400, 0x1044F, "Deseret" },
 9699:     { 88, 0x1D000, 0x1D0FF, "Byzantine Musical Symbols" },
 9699:     { 88, 0x1D100, 0x1D1FF, "Musical Symbols" },
 9699:     { 88, 0x1D200, 0x1D24F, "Ancient Greek Musical Notation" },
 9699:     { 89, 0x1D400, 0x1D7FF, "Mathematical Alphanumeric Symbols" },
61084:     { 90, 0xFF000, 0xFFFFD, "Private Use (plane 15)" },
61084:     { 90, 0x100000, 0x10FFFD, "Private Use (plane 16)" },
 9699:     { 91, 0xFE00, 0xFE0F, "Variation Selectors" },
 9699:     { 91, 0xE0100, 0xE01EF, "Variation Selectors Supplement" },
 9699:     { 92, 0xE0000, 0xE007F, "Tags" },
 9699:     { 93, 0x1900, 0x194F, "Limbu" },
 9699:     { 94, 0x1950, 0x197F, "Tai Le" },
 9699:     { 95, 0x1980, 0x19DF, "New Tai Lue" },
 9699:     { 96, 0x1A00, 0x1A1F, "Buginese" },
 9699:     { 97, 0x2C00, 0x2C5F, "Glagolitic" },
61084:     { 98, 0x2D30, 0x2D7F, "Tifinagh" },
 9699:     { 99, 0x4DC0, 0x4DFF, "Yijing Hexagram Symbols" },
 9699:     { 100, 0xA800, 0xA82F, "Syloti Nagri" },
 9699:     { 101, 0x10000, 0x1007F, "Linear B Syllabary" },
 9699:     { 101, 0x10080, 0x100FF, "Linear B Ideograms" },
 9699:     { 101, 0x10100, 0x1013F, "Aegean Numbers" },
 9699:     { 102, 0x10140, 0x1018F, "Ancient Greek Numbers" },
 9699:     { 103, 0x10380, 0x1039F, "Ugaritic" },
 9699:     { 104, 0x103A0, 0x103DF, "Old Persian" },
 9699:     { 105, 0x10450, 0x1047F, "Shavian" },
 9699:     { 106, 0x10480, 0x104AF, "Osmanya" },
 9699:     { 107, 0x10800, 0x1083F, "Cypriot Syllabary" },
 9699:     { 108, 0x10A00, 0x10A5F, "Kharoshthi" },
 9699:     { 109, 0x1D300, 0x1D35F, "Tai Xuan Jing Symbols" },
 9699:     { 110, 0x12000, 0x123FF, "Cuneiform" },
 9699:     { 110, 0x12400, 0x1247F, "Cuneiform Numbers and Punctuation" },
61084:     { 111, 0x1D360, 0x1D37F, "Counting Rod Numerals" },
61084:     { 112, 0x1B80, 0x1BBF, "Sundanese" },
61084:     { 113, 0x1C00, 0x1C4F, "Lepcha" },
61084:     { 114, 0x1C50, 0x1C7F, "Ol Chiki" },
61084:     { 115, 0xA880, 0xA8DF, "Saurashtra" },
61084:     { 116, 0xA900, 0xA92F, "Kayah Li" },
61084:     { 117, 0xA930, 0xA95F, "Rejang" },
61084:     { 118, 0xAA00, 0xAA5F, "Cham" },
61084:     { 119, 0x10190, 0x101CF, "Ancient Symbols" },
61084:     { 120, 0x101D0, 0x101FF, "Phaistos Disc" },
61084:     { 121, 0x10280, 0x1029F, "Lycian" },
61084:     { 121, 0x102A0, 0x102DF, "Carian" },
61084:     { 121, 0x10920, 0x1093F, "Lydian" },
61084:     { 122, 0x1F000, 0x1F02F, "Mahjong Tiles" },
61084:     { 122, 0x1F030, 0x1F09F, "Domino Tiles" }
 9699: };
 9699: 
43526: #pragma pack(1)
43526: 
43526: typedef struct {
43526:     AutoSwap_PRUint16 format;
43526:     AutoSwap_PRUint16 reserved;
43526:     AutoSwap_PRUint32 length;
43526:     AutoSwap_PRUint32 language;
43526:     AutoSwap_PRUint32 numGroups;
43526: } Format12CmapHeader;
43526: 
43526: typedef struct {
43526:     AutoSwap_PRUint32 startCharCode;
43526:     AutoSwap_PRUint32 endCharCode;
43526:     AutoSwap_PRUint32 startGlyphId;
43526: } Format12Group;
43526: 
43526: #pragma pack()
43526: 
 9699: nsresult
43526: gfxFontUtils::ReadCMAPTableFormat12(const PRUint8 *aBuf, PRUint32 aLength,
43526:                                     gfxSparseBitSet& aCharacterMap) 
 9699: {
43526:     // Ensure table is large enough that we can safely read the header
43526:     NS_ENSURE_TRUE(aLength >= sizeof(Format12CmapHeader),
32826:                     NS_ERROR_GFX_CMAP_MALFORMED);
 9699: 
43526:     // Sanity-check header fields
43526:     const Format12CmapHeader *cmap12 =
43526:         reinterpret_cast<const Format12CmapHeader*>(aBuf);
43526:     NS_ENSURE_TRUE(PRUint16(cmap12->format) == 12, 
43526:                    NS_ERROR_GFX_CMAP_MALFORMED);
43526:     NS_ENSURE_TRUE(PRUint16(cmap12->reserved) == 0, 
32826:                    NS_ERROR_GFX_CMAP_MALFORMED);
 9699: 
43526:     PRUint32 tablelen = cmap12->length;
43526:     NS_ENSURE_TRUE(tablelen >= sizeof(Format12CmapHeader) &&
43526:                    tablelen <= aLength, NS_ERROR_GFX_CMAP_MALFORMED);
43526: 
43526:     NS_ENSURE_TRUE(cmap12->language == 0, NS_ERROR_GFX_CMAP_MALFORMED);
43526: 
43526:     // Check that the table is large enough for the group array
43526:     const PRUint32 numGroups = cmap12->numGroups;
43526:     NS_ENSURE_TRUE((tablelen - sizeof(Format12CmapHeader)) /
43526:                        sizeof(Format12Group) >= numGroups,
32826:                    NS_ERROR_GFX_CMAP_MALFORMED);
 9699: 
43526:     // The array of groups immediately follows the subtable header.
43526:     const Format12Group *group =
43526:         reinterpret_cast<const Format12Group*>(aBuf + sizeof(Format12CmapHeader));
43526: 
43526:     // Check that groups are in correct order and do not overlap,
43526:     // and record character coverage in aCharacterMap.
32826:     PRUint32 prevEndCharCode = 0;
43526:     for (PRUint32 i = 0; i < numGroups; i++, group++) {
43526:         const PRUint32 startCharCode = group->startCharCode;
43526:         const PRUint32 endCharCode = group->endCharCode;
32826:         NS_ENSURE_TRUE((prevEndCharCode < startCharCode || i == 0) &&
32826:                        startCharCode <= endCharCode &&
32826:                        endCharCode <= CMAP_MAX_CODEPOINT, 
32826:                        NS_ERROR_GFX_CMAP_MALFORMED);
 9699:         aCharacterMap.SetRange(startCharCode, endCharCode);
32826:         prevEndCharCode = endCharCode;
 9699:     }
 9699: 
75352:     aCharacterMap.mBlocks.Compact();
40782: 
 9699:     return NS_OK;
 9699: }
 9699: 
 9699: nsresult 
43526: gfxFontUtils::ReadCMAPTableFormat4(const PRUint8 *aBuf, PRUint32 aLength,
43526:                                    gfxSparseBitSet& aCharacterMap)
 9699: {
 9699:     enum {
 9699:         OffsetFormat = 0,
 9699:         OffsetLength = 2,
 9699:         OffsetLanguage = 4,
 9699:         OffsetSegCountX2 = 6
 9699:     };
 9699: 
32826:     NS_ENSURE_TRUE(ReadShortAt(aBuf, OffsetFormat) == 4, 
32826:                    NS_ERROR_GFX_CMAP_MALFORMED);
 9699:     PRUint16 tablelen = ReadShortAt(aBuf, OffsetLength);
32826:     NS_ENSURE_TRUE(tablelen <= aLength, NS_ERROR_GFX_CMAP_MALFORMED);
32826:     NS_ENSURE_TRUE(tablelen > 16, NS_ERROR_GFX_CMAP_MALFORMED);
 9699:     
36924:     // This field should normally (except for Mac platform subtables) be zero according to
36924:     // the OT spec, but some buggy fonts have lang = 1 (which would be English for MacOS).
36924:     // E.g. Arial Narrow Bold, v. 1.1 (Tiger), Arial Unicode MS (see bug 530614).
36924:     // So accept either zero or one here; the error should be harmless.
36924:     NS_ENSURE_TRUE((ReadShortAt(aBuf, OffsetLanguage) & 0xfffe) == 0, 
32826:                    NS_ERROR_GFX_CMAP_MALFORMED);
 9699: 
 9699:     PRUint16 segCountX2 = ReadShortAt(aBuf, OffsetSegCountX2);
32826:     NS_ENSURE_TRUE(tablelen >= 16 + (segCountX2 * 4), 
32826:                    NS_ERROR_GFX_CMAP_MALFORMED);
 9699: 
 9699:     const PRUint16 segCount = segCountX2 / 2;
 9699: 
31590:     const PRUint16 *endCounts = reinterpret_cast<const PRUint16*>(aBuf + 14);
 9699:     const PRUint16 *startCounts = endCounts + 1 /* skip one uint16 for reservedPad */ + segCount;
 9699:     const PRUint16 *idDeltas = startCounts + segCount;
 9699:     const PRUint16 *idRangeOffsets = idDeltas + segCount;
32826:     PRUint16 prevEndCount = 0;
 9699:     for (PRUint16 i = 0; i < segCount; i++) {
 9699:         const PRUint16 endCount = ReadShortAt16(endCounts, i);
 9699:         const PRUint16 startCount = ReadShortAt16(startCounts, i);
 9699:         const PRUint16 idRangeOffset = ReadShortAt16(idRangeOffsets, i);
32826: 
32826:         // sanity-check range
36535:         NS_ENSURE_TRUE((startCount > prevEndCount || i == 0 || startCount == 0xFFFF) &&
32826:                        startCount <= endCount,
32826:                        NS_ERROR_GFX_CMAP_MALFORMED);
32826:         prevEndCount = endCount;
32826: 
 9699:         if (idRangeOffset == 0) {
 9699:             aCharacterMap.SetRange(startCount, endCount);
 9699:         } else {
19254:             // const PRUint16 idDelta = ReadShortAt16(idDeltas, i); // Unused: self-documenting.
 9699:             for (PRUint32 c = startCount; c <= endCount; ++c) {
 9699:                 if (c == 0xFFFF)
 9699:                     break;
 9699: 
 9699:                 const PRUint16 *gdata = (idRangeOffset/2 
 9699:                                          + (c - startCount)
 9699:                                          + &idRangeOffsets[i]);
 9699: 
32826:                 NS_ENSURE_TRUE((PRUint8*)gdata > aBuf && 
32826:                                (PRUint8*)gdata < aBuf + aLength, 
32826:                                NS_ERROR_GFX_CMAP_MALFORMED);
 9699: 
 9699:                 // make sure we have a glyph
 9699:                 if (*gdata != 0) {
 9699:                     // The glyph index at this point is:
 9699:                     // glyph = (ReadShortAt16(idDeltas, i) + *gdata) % 65536;
 9699: 
 9699:                     aCharacterMap.set(c);
 9699:                 }
 9699:             }
 9699:         }
 9699:     }
 9699: 
75352:     aCharacterMap.mBlocks.Compact();
40782: 
 9699:     return NS_OK;
 9699: }
 9699: 
42989: nsresult
43526: gfxFontUtils::ReadCMAPTableFormat14(const PRUint8 *aBuf, PRUint32 aLength,
42989:                                     PRUint8*& aTable)
42989: {
42989:     enum {
42989:         OffsetFormat = 0,
42989:         OffsetTableLength = 2,
42989:         OffsetNumVarSelectorRecords = 6,
42989:         OffsetVarSelectorRecords = 10,
42989: 
42989:         SizeOfVarSelectorRecord = 11,
42989:         VSRecOffsetVarSelector = 0,
42989:         VSRecOffsetDefUVSOffset = 3,
42989:         VSRecOffsetNonDefUVSOffset = 7,
42989: 
42989:         SizeOfDefUVSTable = 4,
42989:         DefUVSOffsetStartUnicodeValue = 0,
42989:         DefUVSOffsetAdditionalCount = 3,
42989: 
42989:         SizeOfNonDefUVSTable = 5,
42989:         NonDefUVSOffsetUnicodeValue = 0,
42989:         NonDefUVSOffsetGlyphID = 3
42989:     };
42989:     NS_ENSURE_TRUE(aLength >= OffsetVarSelectorRecords,
42989:                    NS_ERROR_GFX_CMAP_MALFORMED);
42989: 
42989:     NS_ENSURE_TRUE(ReadShortAt(aBuf, OffsetFormat) == 14, 
42989:                    NS_ERROR_GFX_CMAP_MALFORMED);
42989: 
42989:     PRUint32 tablelen = ReadLongAt(aBuf, OffsetTableLength);
42989:     NS_ENSURE_TRUE(tablelen <= aLength, NS_ERROR_GFX_CMAP_MALFORMED);
42989:     NS_ENSURE_TRUE(tablelen >= OffsetVarSelectorRecords,
42989:                    NS_ERROR_GFX_CMAP_MALFORMED);
42989: 
42989:     const PRUint32 numVarSelectorRecords = ReadLongAt(aBuf, OffsetNumVarSelectorRecords);
42989:     NS_ENSURE_TRUE((tablelen - OffsetVarSelectorRecords) /
42989:                    SizeOfVarSelectorRecord >= numVarSelectorRecords,
42989:                    NS_ERROR_GFX_CMAP_MALFORMED);
42989: 
42989:     const PRUint8 *records = aBuf + OffsetVarSelectorRecords;
42989:     for (PRUint32 i = 0; i < numVarSelectorRecords; 
42989:          i++, records += SizeOfVarSelectorRecord) {
42989:         const PRUint32 varSelector = ReadUint24At(records, VSRecOffsetVarSelector);
42989:         const PRUint32 defUVSOffset = ReadLongAt(records, VSRecOffsetDefUVSOffset);
42989:         const PRUint32 nonDefUVSOffset = ReadLongAt(records, VSRecOffsetNonDefUVSOffset);
42989:         NS_ENSURE_TRUE(varSelector <= CMAP_MAX_CODEPOINT &&
42989:                        defUVSOffset <= tablelen - 4 &&
42989:                        nonDefUVSOffset <= tablelen - 4, 
42989:                        NS_ERROR_GFX_CMAP_MALFORMED);
42989: 
42989:         if (defUVSOffset) {
42989:             const PRUint32 numUnicodeValueRanges = ReadLongAt(aBuf, defUVSOffset);
42989:             NS_ENSURE_TRUE((tablelen - defUVSOffset) /
42989:                            SizeOfDefUVSTable >= numUnicodeValueRanges,
42989:                            NS_ERROR_GFX_CMAP_MALFORMED);
42989:             const PRUint8 *tables = aBuf + defUVSOffset + 4;
42989:             PRUint32 prevEndUnicode = 0;
42989:             for (PRUint32 j = 0; j < numUnicodeValueRanges; j++, tables += SizeOfDefUVSTable) {
42989:                 const PRUint32 startUnicode = ReadUint24At(tables, DefUVSOffsetStartUnicodeValue);
42989:                 const PRUint32 endUnicode = startUnicode + tables[DefUVSOffsetAdditionalCount];
42989:                 NS_ENSURE_TRUE((prevEndUnicode < startUnicode || j == 0) &&
42989:                                endUnicode <= CMAP_MAX_CODEPOINT, 
42989:                                NS_ERROR_GFX_CMAP_MALFORMED);
42989:                 prevEndUnicode = endUnicode;
42989:             }
42989:         }
42989: 
42989:         if (nonDefUVSOffset) {
42989:             const PRUint32 numUVSMappings = ReadLongAt(aBuf, nonDefUVSOffset);
42989:             NS_ENSURE_TRUE((tablelen - nonDefUVSOffset) /
42989:                            SizeOfNonDefUVSTable >= numUVSMappings,
42989:                            NS_ERROR_GFX_CMAP_MALFORMED);
42989:             const PRUint8 *tables = aBuf + nonDefUVSOffset + 4;
42989:             PRUint32 prevUnicode = 0;
42989:             for (PRUint32 j = 0; j < numUVSMappings; j++, tables += SizeOfNonDefUVSTable) {
42989:                 const PRUint32 unicodeValue = ReadUint24At(tables, NonDefUVSOffsetUnicodeValue);
42989:                 NS_ENSURE_TRUE((prevUnicode < unicodeValue || j == 0) &&
42989:                                unicodeValue <= CMAP_MAX_CODEPOINT, 
42989:                                NS_ERROR_GFX_CMAP_MALFORMED);
42989:                 prevUnicode = unicodeValue;
42989:             }
42989:         }
42989:     }
42989: 
42989:     aTable = new PRUint8[tablelen];
42989:     memcpy(aTable, aBuf, tablelen);
42989: 
42989:     return NS_OK;
42989: }
42989: 
 9699: // Windows requires fonts to have a format-4 cmap with a Microsoft ID (3).  On the Mac, fonts either have
 9699: // a format-4 cmap with Microsoft platform/encoding id or they have one with a platformID == Unicode (0)
42359: // For fonts with two format-4 tables, the first one (Unicode platform) is preferred on the Mac.
 9699: 
 9699: #if defined(XP_MACOSX)
42989:     #define acceptableFormat4(p,e,k) (((p) == PLATFORM_ID_MICROSOFT && (e) == EncodingIDMicrosoft && !(k)) || \
31590:                                       ((p) == PLATFORM_ID_UNICODE))
42989: 
42989:     #define acceptableUCS4Encoding(p, e, k) \
42989:         (((p) == PLATFORM_ID_MICROSOFT && (e) == EncodingIDUCS4ForMicrosoftPlatform) && (k) != 12 || \
42989:          ((p) == PLATFORM_ID_UNICODE   && \
42989:           ((e) == EncodingIDDefaultForUnicodePlatform || (e) >= EncodingIDUCS4ForUnicodePlatform)))
 9699: #else
42989:     #define acceptableFormat4(p,e,k) ((p) == PLATFORM_ID_MICROSOFT && (e) == EncodingIDMicrosoft)
42989: 
42989:     #define acceptableUCS4Encoding(p, e, k) \
42989:         ((p) == PLATFORM_ID_MICROSOFT && (e) == EncodingIDUCS4ForMicrosoftPlatform)
 9699: #endif
 9699: 
42989: #define acceptablePlatform(p) ((p) == PLATFORM_ID_UNICODE || (p) == PLATFORM_ID_MICROSOFT)
42989: #define isSymbol(p,e)         ((p) == PLATFORM_ID_MICROSOFT && (e) == EncodingIDSymbol)
42989: #define isUVSEncoding(p, e)   ((p) == PLATFORM_ID_UNICODE && (e) == EncodingIDUVSForUnicodePlatform)
13057: 
35526: PRUint32
43526: gfxFontUtils::FindPreferredSubtable(const PRUint8 *aBuf, PRUint32 aBufLength,
43526:                                     PRUint32 *aTableOffset,
43526:                                     PRUint32 *aUVSTableOffset,
42989:                                     PRBool *aSymbolEncoding)
 9699: {
 9699:     enum {
 9699:         OffsetVersion = 0,
 9699:         OffsetNumTables = 2,
 9699:         SizeOfHeader = 4,
 9699: 
 9699:         TableOffsetPlatformID = 0,
 9699:         TableOffsetEncodingID = 2,
 9699:         TableOffsetOffset = 4,
 9699:         SizeOfTable = 8,
 9699: 
 9699:         SubtableOffsetFormat = 0
 9699:     };
 9699:     enum {
 9699:         EncodingIDSymbol = 0,
 9699:         EncodingIDMicrosoft = 1,
35527:         EncodingIDDefaultForUnicodePlatform = 0,
13057:         EncodingIDUCS4ForUnicodePlatform = 3,
42989:         EncodingIDUVSForUnicodePlatform = 5,
13057:         EncodingIDUCS4ForMicrosoftPlatform = 10
 9699:     };
 9699: 
42989:     if (aUVSTableOffset) {
42989:         *aUVSTableOffset = nsnull;
42989:     }
42989: 
51967:     if (!aBuf || aBufLength < SizeOfHeader) {
51967:         // cmap table is missing, or too small to contain header fields!
51967:         return 0;
51967:     }
51967: 
19254:     // PRUint16 version = ReadShortAt(aBuf, OffsetVersion); // Unused: self-documenting.
 9699:     PRUint16 numTables = ReadShortAt(aBuf, OffsetNumTables);
58638:     if (aBufLength < PRUint32(SizeOfHeader + numTables * SizeOfTable)) {
51967:         return 0;
51967:     }
 9699: 
35526:     // save the format we want here
 9699:     PRUint32 keepFormat = 0;
 9699: 
43526:     const PRUint8 *table = aBuf + SizeOfHeader;
 9699:     for (PRUint16 i = 0; i < numTables; ++i, table += SizeOfTable) {
 9699:         const PRUint16 platformID = ReadShortAt(table, TableOffsetPlatformID);
 9699:         if (!acceptablePlatform(platformID))
 9699:             continue;
 9699: 
 9699:         const PRUint16 encodingID = ReadShortAt(table, TableOffsetEncodingID);
 9699:         const PRUint32 offset = ReadLongAt(table, TableOffsetOffset);
51967:         if (aBufLength - 2 < offset) {
51967:             // this subtable is not valid - beyond end of buffer
51967:             return 0;
51967:         }
10952: 
 9699:         const PRUint8 *subtable = aBuf + offset;
 9699:         const PRUint16 format = ReadShortAt(subtable, SubtableOffsetFormat);
 9699: 
 9699:         if (isSymbol(platformID, encodingID)) {
35526:             keepFormat = format;
35526:             *aTableOffset = offset;
35526:             *aSymbolEncoding = PR_TRUE;
35526:             break;
42359:         } else if (format == 4 && acceptableFormat4(platformID, encodingID, keepFormat)) {
35526:             keepFormat = format;
35526:             *aTableOffset = offset;
35526:             *aSymbolEncoding = PR_FALSE;
42989:         } else if (format == 12 && acceptableUCS4Encoding(platformID, encodingID, keepFormat)) {
35526:             keepFormat = format;
35526:             *aTableOffset = offset;
35526:             *aSymbolEncoding = PR_FALSE;
42989:             if (platformID > PLATFORM_ID_UNICODE || !aUVSTableOffset || *aUVSTableOffset) {
35526:                 break; // we don't want to try anything else when this format is available.
35526:             }
42989:         } else if (format == 14 && isUVSEncoding(platformID, encodingID) && aUVSTableOffset) {
42989:             *aUVSTableOffset = offset;
42989:             if (keepFormat == 12) {
42989:                 break;
42989:             }
42989:         }
35526:     }
35526: 
35526:     return keepFormat;
35526: }
35526: 
35526: nsresult
43526: gfxFontUtils::ReadCMAP(const PRUint8 *aBuf, PRUint32 aBufLength,
43526:                        gfxSparseBitSet& aCharacterMap,
42989:                        PRUint32& aUVSOffset,
35526:                        PRPackedBool& aUnicodeFont, PRPackedBool& aSymbolFont)
35526: {
35526:     PRUint32 offset;
35526:     PRBool   symbol;
43526:     PRUint32 format = FindPreferredSubtable(aBuf, aBufLength,
43526:                                             &offset, &aUVSOffset, &symbol);
35526: 
35526:     if (format == 4) {
35526:         if (symbol) {
 9699:             aUnicodeFont = PR_FALSE;
 9699:             aSymbolFont = PR_TRUE;
35526:         } else {
13578:             aUnicodeFont = PR_TRUE;
13578:             aSymbolFont = PR_FALSE;
35526:         }
43526:         return ReadCMAPTableFormat4(aBuf + offset, aBufLength - offset,
43526:                                     aCharacterMap);
35526:     }
35526: 
35526:     if (format == 12) {
13578:         aUnicodeFont = PR_TRUE;
13578:         aSymbolFont = PR_FALSE;
43526:         return ReadCMAPTableFormat12(aBuf + offset, aBufLength - offset,
43526:                                      aCharacterMap);
 9699:     }
 9699: 
35526:     return NS_ERROR_FAILURE;
35526: }
 9699: 
35526: #pragma pack(1)
35526: 
35526: typedef struct {
35526:     AutoSwap_PRUint16 format;
35526:     AutoSwap_PRUint16 length;
35526:     AutoSwap_PRUint16 language;
35526:     AutoSwap_PRUint16 segCountX2;
35526:     AutoSwap_PRUint16 searchRange;
35526:     AutoSwap_PRUint16 entrySelector;
35526:     AutoSwap_PRUint16 rangeShift;
35526: 
35526:     AutoSwap_PRUint16 arrays[1];
35526: } Format4Cmap;
41172: 
42989: typedef struct {
42989:     AutoSwap_PRUint16 format;
42989:     AutoSwap_PRUint32 length;
42989:     AutoSwap_PRUint32 numVarSelectorRecords;
42989: 
42989:     typedef struct {
42989:         AutoSwap_PRUint24 varSelector;
42989:         AutoSwap_PRUint32 defaultUVSOffset;
42989:         AutoSwap_PRUint32 nonDefaultUVSOffset;
42989:     } VarSelectorRecord;
42989: 
42989:     VarSelectorRecord varSelectorRecords[1];
42989: } Format14Cmap;
42989: 
42989: typedef struct {
42989:     AutoSwap_PRUint32 numUVSMappings;
42989: 
42989:     typedef struct {
42989:         AutoSwap_PRUint24 unicodeValue;
42989:         AutoSwap_PRUint16 glyphID;
42989:     } UVSMapping;
42989: 
42989:     UVSMapping uvsMappings[1];
42989: } NonDefUVSTable;
42989: 
41238: #pragma pack()
41238: 
35526: PRUint32
35526: gfxFontUtils::MapCharToGlyphFormat4(const PRUint8 *aBuf, PRUnichar aCh)
35526: {
35526:     const Format4Cmap *cmap4 = reinterpret_cast<const Format4Cmap*>(aBuf);
35526:     PRUint16 segCount;
35526:     const AutoSwap_PRUint16 *endCodes;
35526:     const AutoSwap_PRUint16 *startCodes;
35526:     const AutoSwap_PRUint16 *idDelta;
35526:     const AutoSwap_PRUint16 *idRangeOffset;
35526:     PRUint16 probe;
35526:     PRUint16 rangeShiftOver2;
35526:     PRUint16 index;
35526: 
35526:     segCount = (PRUint16)(cmap4->segCountX2) / 2;
35526: 
35526:     endCodes = &cmap4->arrays[0];
35526:     startCodes = &cmap4->arrays[segCount + 1]; // +1 for reserved word between arrays
35526:     idDelta = &startCodes[segCount];
35526:     idRangeOffset = &idDelta[segCount];
35526: 
35526:     probe = 1 << (PRUint16)(cmap4->entrySelector);
35526:     rangeShiftOver2 = (PRUint16)(cmap4->rangeShift) / 2;
35526: 
35526:     if ((PRUint16)(startCodes[rangeShiftOver2]) <= aCh) {
35526:         index = rangeShiftOver2;
35526:     } else {
35526:         index = 0;
35526:     }
35526: 
35526:     while (probe > 1) {
35526:         probe >>= 1;
35526:         if ((PRUint16)(startCodes[index + probe]) <= aCh) {
35526:             index += probe;
35526:         }
35526:     }
35526: 
35526:     if (aCh >= (PRUint16)(startCodes[index]) && aCh <= (PRUint16)(endCodes[index])) {
35526:         PRUint16 result;
35526:         if ((PRUint16)(idRangeOffset[index]) == 0) {
35526:             result = aCh;
35526:         } else {
35526:             PRUint16 offset = aCh - (PRUint16)(startCodes[index]);
35526:             const AutoSwap_PRUint16 *glyphIndexTable =
35526:                 (const AutoSwap_PRUint16*)((const char*)&idRangeOffset[index] +
35526:                                            (PRUint16)(idRangeOffset[index]));
35526:             result = glyphIndexTable[offset];
35526:         }
35526: 
35526:         // note that this is unsigned 16-bit arithmetic, and may wrap around
35526:         result += (PRUint16)(idDelta[index]);
35526:         return result;
35526:     }
35526: 
35526:     return 0;
35526: }
35526: 
43526: PRUint32
43526: gfxFontUtils::MapCharToGlyphFormat12(const PRUint8 *aBuf, PRUint32 aCh)
43526: {
43526:     const Format12CmapHeader *cmap12 =
43526:         reinterpret_cast<const Format12CmapHeader*>(aBuf);
43526: 
43526:     // We know that numGroups is within range for the subtable size
43526:     // because it was checked by ReadCMAPTableFormat12.
43526:     PRUint32 numGroups = cmap12->numGroups;
43526: 
43526:     // The array of groups immediately follows the subtable header.
43526:     const Format12Group *groups =
43526:         reinterpret_cast<const Format12Group*>(aBuf + sizeof(Format12CmapHeader));
43526: 
43526:     // For most efficient binary search, we want to work on a range that
43526:     // is a power of 2 so that we can always halve it by shifting.
43526:     // So we find the largest power of 2 that is <= numGroups.
43526:     // We will offset this range by rangeOffset so as to reach the end
43526:     // of the table, provided that doesn't put us beyond the target
43526:     // value from the outset.
43526:     PRUint32 powerOf2 = mozilla::FindHighestBit(numGroups);
43526:     PRUint32 rangeOffset = numGroups - powerOf2;
43526:     PRUint32 range = 0;
43526:     PRUint32 startCharCode;
43526: 
43526:     if (groups[rangeOffset].startCharCode <= aCh) {
43526:         range = rangeOffset;
43526:     }
43526: 
43526:     // Repeatedly halve the size of the range until we find the target group
43526:     while (powerOf2 > 1) {
43526:         powerOf2 >>= 1;
43526:         if (groups[range + powerOf2].startCharCode <= aCh) {
43526:             range += powerOf2;
43526:         }
43526:     }
43526: 
43526:     // Check if the character is actually present in the range and return
43526:     // the corresponding glyph ID
43526:     startCharCode = groups[range].startCharCode;
43526:     if (startCharCode <= aCh && groups[range].endCharCode >= aCh) {
43526:         return groups[range].startGlyphId + aCh - startCharCode;
43526:     }
43526: 
43526:     // Else it's not present, so return the .notdef glyph
43526:     return 0;
43526: }
43526: 
42989: PRUint16
42989: gfxFontUtils::MapUVSToGlyphFormat14(const PRUint8 *aBuf, PRUint32 aCh, PRUint32 aVS)
42989: {
42989:     const Format14Cmap *cmap14 = reinterpret_cast<const Format14Cmap*>(aBuf);
42989: 
42989:     // binary search in varSelectorRecords
42989:     PRUint32 min = 0;
42989:     PRUint32 max = cmap14->numVarSelectorRecords;
42989:     PRUint32 nonDefUVSOffset = 0;
42989:     while (min < max) {
42989:         PRUint32 index = (min + max) >> 1;
42989:         PRUint32 varSelector = cmap14->varSelectorRecords[index].varSelector;
42989:         if (aVS == varSelector) {
42989:             nonDefUVSOffset = cmap14->varSelectorRecords[index].nonDefaultUVSOffset;
42989:             break;
42989:         }
42989:         if (aVS < varSelector) {
42989:             max = index;
42989:         } else {
42989:             min = index + 1;
42989:         }
42989:     }
42989:     if (!nonDefUVSOffset) {
42989:         return 0;
42989:     }
42989: 
42989:     const NonDefUVSTable *table = reinterpret_cast<const NonDefUVSTable*>
42989:                                       (aBuf + nonDefUVSOffset);
42989: 
42989:     // binary search in uvsMappings
42989:     min = 0;
42989:     max = table->numUVSMappings;
42989:     while (min < max) {
42989:         PRUint32 index = (min + max) >> 1;
42989:         PRUint32 unicodeValue = table->uvsMappings[index].unicodeValue;
42989:         if (aCh == unicodeValue) {
42989:             return table->uvsMappings[index].glyphID;
42989:         }
42989:         if (aCh < unicodeValue) {
42989:             max = index;
42989:         } else {
42989:             min = index + 1;
42989:         }
42989:     }
42989: 
42989:     return 0;
42989: }
42989: 
35526: PRUint32
43526: gfxFontUtils::MapCharToGlyph(const PRUint8 *aBuf, PRUint32 aBufLength,
48281:                              PRUint32 aCh)
35526: {
35526:     PRUint32 offset;
35526:     PRBool   symbol;
43526:     PRUint32 format = FindPreferredSubtable(aBuf, aBufLength, &offset,
43526:                                             nsnull, &symbol);
35526: 
43526:     switch (format) {
43526:     case 4:
43526:         return aCh < UNICODE_BMP_LIMIT ?
48281:             MapCharToGlyphFormat4(aBuf + offset, PRUnichar(aCh)) : 0;
43526:     case 12:
43526:         return MapCharToGlyphFormat12(aBuf + offset, aCh);
43526:     default:
35526:         return 0;
 9699:     }
43526: }
 9699: 
 9699: PRUint8 gfxFontUtils::CharRangeBit(PRUint32 ch) {
 9699:     const PRUint32 n = sizeof(gUnicodeRanges) / sizeof(struct UnicodeRangeTableEntry);
 9699: 
 9699:     for (PRUint32 i = 0; i < n; ++i)
 9699:         if (ch >= gUnicodeRanges[i].start && ch <= gUnicodeRanges[i].end)
 9699:             return gUnicodeRanges[i].bit;
 9699: 
 9699:     return NO_RANGE_FOUND;
 9699: }
 9699: 
14457: void gfxFontUtils::GetPrefsFontList(const char *aPrefName, nsTArray<nsString>& aFontList)
12239: {
12239:     const PRUnichar kComma = PRUnichar(',');
12239:     
12239:     aFontList.Clear();
12239:     
12239:     // get the list of single-face font families
71640:     nsAdoptingString fontlistValue = Preferences::GetString(aPrefName);
71640:     if (!fontlistValue) {
12239:         return;
12239:     }
12239: 
12239:     // append each font name to the list
12239:     nsAutoString fontname;
12239:     const PRUnichar *p, *p_end;
71730:     fontlistValue.BeginReading(p);
71730:     fontlistValue.EndReading(p_end);
12239: 
12239:      while (p < p_end) {
12239:         const PRUnichar *nameStart = p;
12239:         while (++p != p_end && *p != kComma)
12239:         /* nothing */ ;
12239: 
12239:         // pull out a single name and clean out leading/trailing whitespace        
12239:         fontname = Substring(nameStart, p);
12239:         fontname.CompressWhitespace(PR_TRUE, PR_TRUE);
12239:         
12239:         // append it to the list
12239:         aFontList.AppendElement(fontname);
12239:         ++p;
12239:     }
12239: 
12239: }
12239: 
26027: // produce a unique font name that is (1) a valid Postscript name and (2) less
26027: // than 31 characters in length.  Using AddFontMemResourceEx on Windows fails 
26027: // for names longer than 30 characters in length.
26027: 
26027: #define MAX_B64_LEN 32
26027: 
26027: nsresult gfxFontUtils::MakeUniqueUserFontName(nsAString& aName)
26027: {
26027:     nsCOMPtr<nsIUUIDGenerator> uuidgen =
26027:       do_GetService("@mozilla.org/uuid-generator;1");
26027:     NS_ENSURE_TRUE(uuidgen, NS_ERROR_OUT_OF_MEMORY);
26027: 
26027:     nsID guid;
26027: 
26027:     NS_ASSERTION(sizeof(guid) * 2 <= MAX_B64_LEN, "size of nsID has changed!");
26027: 
26027:     nsresult rv = uuidgen->GenerateUUIDInPlace(&guid);
26027:     NS_ENSURE_SUCCESS(rv, rv);
26027: 
26027:     char guidB64[MAX_B64_LEN] = {0};
26027: 
31590:     if (!PL_Base64Encode(reinterpret_cast<char*>(&guid), sizeof(guid), guidB64))
26027:         return NS_ERROR_FAILURE;
26027: 
26027:     // all b64 characters except for '/' are allowed in Postscript names, so convert / ==> -
26027:     char *p;
26027:     for (p = guidB64; *p; p++) {
26027:         if (*p == '/')
26027:             *p = '-';
26027:     }
26027: 
26027:     aName.Assign(NS_LITERAL_STRING("uf"));
26027:     aName.AppendASCII(guidB64);
26027:     return NS_OK;
26027: }
26027: 
26027: 
19962: // TrueType/OpenType table handling code
19962: 
19962: // need byte aligned structs
19962: #pragma pack(1)
19962: 
21067: // name table stores set of name record structures, followed by
21067: // large block containing all the strings.  name record offset and length
21067: // indicates the offset and length within that block.
21067: // http://www.microsoft.com/typography/otspec/name.htm
21067: struct NameRecordData {
21067:     PRUint32  offset;
21067:     PRUint32  length;
21067: };
21067: 
41238: #pragma pack()
41238: 
21067: static PRBool
21067: IsValidSFNTVersion(PRUint32 version)
21067: {
21067:     // normally 0x00010000, CFF-style OT fonts == 'OTTO' and Apple TT fonts = 'true'
21067:     // 'typ1' is also possible for old Type 1 fonts in a SFNT container but not supported
31590:     return version == 0x10000 ||
31590:            version == TRUETYPE_TAG('O','T','T','O') ||
31590:            version == TRUETYPE_TAG('t','r','u','e');
21067: }
21067: 
21067: // copy and swap UTF-16 values, assume no surrogate pairs, can be in place
21067: static void
21067: CopySwapUTF16(const PRUint16 *aInBuf, PRUint16 *aOutBuf, PRUint32 aLen)
21067: {
21067:     const PRUint16 *end = aInBuf + aLen;
21067:     while (aInBuf < end) {
21067:         PRUint16 value = *aInBuf;
21067:         *aOutBuf = (value >> 8) | (value & 0xff) << 8;
21067:         aOutBuf++;
21067:         aInBuf++;
21067:     }
21067: }
21067: 
27304: static PRBool
27304: ValidateKernTable(const PRUint8 *aKernTable, PRUint32 aKernLength)
27304: {
27304:     // -- kern table can cause crashes if invalid, so do some basic sanity-checking
27304:     const KernTableVersion0 *kernTable0 = reinterpret_cast<const KernTableVersion0*>(aKernTable);
27304:     if (aKernLength < sizeof(KernTableVersion0)) {
27304:         return PR_FALSE;
27304:     }
27304:     if (PRUint16(kernTable0->version) == 0) {
27304:         if (aKernLength < sizeof(KernTableVersion0) +
27304:                             PRUint16(kernTable0->nTables) * sizeof(KernTableSubtableHeaderVersion0)) {
27304:             return PR_FALSE;
27304:         }
27304:         // at least the table is big enough to contain the subtable headers;
27304:         // we could go further and check the actual subtable sizes....
27304:         // for now, assume this is OK
27304:         return PR_TRUE;
27304:     }
27304: 
27304:     const KernTableVersion1 *kernTable1 = reinterpret_cast<const KernTableVersion1*>(aKernTable);
27304:     if (aKernLength < sizeof(KernTableVersion1)) {
27304:         return PR_FALSE;
27304:     }
27304:     if (kernTable1->version == 0x00010000) {
27304:         if (aKernLength < sizeof(KernTableVersion1) +
27304:                             kernTable1->nTables * sizeof(KernTableSubtableHeaderVersion1)) {
27304:             return PR_FALSE;
27304:         }
27304:         // at least the table is big enough to contain the subtable headers;
27304:         // we could go further and check the actual subtable sizes....
27304:         // for now, assume this is OK
27304:         return PR_TRUE;
27304:     }
27304: 
27304:     // neither the old Windows version nor the newer Apple one; refuse to use it
27304:     return PR_FALSE;
27304: }
27304: 
48071: static PRBool
48071: ValidateLocaTable(const PRUint8* aLocaTable, PRUint32 aLocaLen,
48071:                   PRUint32 aGlyfLen, PRInt16 aLocaFormat, PRUint16 aNumGlyphs)
48071: {
48071:     if (aLocaFormat == 0) {
48071:         if (aLocaLen < PRUint32(aNumGlyphs + 1) * sizeof(PRUint16)) {
48071:             return PR_FALSE;
48071:         }
48071:         const AutoSwap_PRUint16 *p =
48071:             reinterpret_cast<const AutoSwap_PRUint16*>(aLocaTable);
48071:         PRUint32 prev = 0;
48071:         for (PRUint32 i = 0; i <= aNumGlyphs; ++i) {
48071:             PRUint32 current = PRUint16(*p++) * 2;
48071:             if (current < prev || current > aGlyfLen) {
48071:                 return PR_FALSE;
48071:             }
48071:             prev = current;
48071:         }
48071:         return PR_TRUE;
48071:     }
48071:     if (aLocaFormat == 1) {
48071:         if (aLocaLen < (aNumGlyphs + 1) * sizeof(PRUint32)) {
48071:             return PR_FALSE;
48071:         }
48071:         const AutoSwap_PRUint32 *p =
48071:             reinterpret_cast<const AutoSwap_PRUint32*>(aLocaTable);
48071:         PRUint32 prev = 0;
48071:         for (PRUint32 i = 0; i <= aNumGlyphs; ++i) {
48071:             PRUint32 current = *p++;
48071:             if (current < prev || current > aGlyfLen) {
48071:                 return PR_FALSE;
48071:             }
48071:             prev = current;
48071:         }
48071:         return PR_TRUE;
48071:     }
48071:     return PR_FALSE;
48071: }
48071: 
32808: gfxUserFontType
32808: gfxFontUtils::DetermineFontDataType(const PRUint8 *aFontData, PRUint32 aFontDataLength)
32808: {
32808:     // test for OpenType font data
32808:     // problem: EOT-Lite with 0x10000 length will look like TrueType!
32808:     if (aFontDataLength >= sizeof(SFNTHeader)) {
32808:         const SFNTHeader *sfntHeader = reinterpret_cast<const SFNTHeader*>(aFontData);
32808:         PRUint32 sfntVersion = sfntHeader->sfntVersion;
32808:         if (IsValidSFNTVersion(sfntVersion)) {
32808:             return GFX_USERFONT_OPENTYPE;
32808:         }
32808:     }
32808:     
32808:     // test for WOFF
32808:     if (aFontDataLength >= sizeof(AutoSwap_PRUint32)) {
32808:         const AutoSwap_PRUint32 *version = 
32808:             reinterpret_cast<const AutoSwap_PRUint32*>(aFontData);
32808:         if (PRUint32(*version) == TRUETYPE_TAG('w','O','F','F')) {
32808:             return GFX_USERFONT_WOFF;
32808:         }
32808:     }
32808:     
32808:     // tests for other formats here
32808:     
32808:     return GFX_USERFONT_UNKNOWN;
32808: }
32808: 
21067: PRBool
22991: gfxFontUtils::ValidateSFNTHeaders(const PRUint8 *aFontData, 
32808:                                   PRUint32 aFontDataLength)
21067: {
32808:     NS_ASSERTION(aFontData, "null font data");
21067: 
21067:     PRUint64 dataLength(aFontDataLength);
21067:     
21067:     // read in the sfnt header
21067:     if (sizeof(SFNTHeader) > aFontDataLength) {
21067:         NS_WARNING("invalid font (insufficient data)");
21067:         return PR_FALSE;
21067:     }
21067:     
21067:     const SFNTHeader *sfntHeader = reinterpret_cast<const SFNTHeader*>(aFontData);
21067:     PRUint32 sfntVersion = sfntHeader->sfntVersion;
21067:     if (!IsValidSFNTVersion(sfntVersion)) {
21067:         NS_WARNING("invalid font (SFNT version)");
21067:         return PR_FALSE;
21067:     }
21067:     
21067:     // iterate through the table headers to find the head, name and OS/2 tables
21067:     PRBool foundHead = PR_FALSE, foundOS2 = PR_FALSE, foundName = PR_FALSE;
27304:     PRBool foundGlyphs = PR_FALSE, foundCFF = PR_FALSE, foundKern = PR_FALSE;
48071:     PRBool foundLoca = PR_FALSE, foundMaxp = PR_FALSE;
58638:     PRUint32 headOffset = 0, headLen, nameOffset = 0, nameLen, kernOffset = 0,
58638:         kernLen = 0, glyfLen = 0, locaOffset = 0, locaLen = 0,
58638:         maxpOffset = 0, maxpLen;
21067:     PRUint32 i, numTables;
21067: 
21067:     numTables = sfntHeader->numTables;
21067:     PRUint32 headerLen = sizeof(SFNTHeader) + sizeof(TableDirEntry) * numTables;
21067:     if (headerLen > aFontDataLength) {
21067:         NS_WARNING("invalid font (table directory)");
21067:         return PR_FALSE;
21067:     }
21067:     
21067:     // table directory entries begin immediately following SFNT header
22991:     const TableDirEntry *dirEntry = 
22991:         reinterpret_cast<const TableDirEntry*>(aFontData + sizeof(SFNTHeader));
21067:     PRUint32 checksum = 0;
21067:     
21067:     // checksum for font = (checksum of header) + (checksum of tables)
22991:     const AutoSwap_PRUint32 *headerData = 
22991:         reinterpret_cast<const AutoSwap_PRUint32*>(aFontData);
21067: 
21067:     // header length is in bytes, checksum calculated in longwords
21067:     for (i = 0; i < (headerLen >> 2); i++, headerData++) {
21067:         checksum += *headerData;
21067:     }
21067:     
21067:     for (i = 0; i < numTables; i++, dirEntry++) {
21067:     
21067:         // sanity check on offset, length values
21067:         if (PRUint64(dirEntry->offset) + PRUint64(dirEntry->length) > dataLength) {
21067:             NS_WARNING("invalid font (table directory entry)");
21067:             return PR_FALSE;
21067:         }
21067: 
21067:         checksum += dirEntry->checkSum;
21067:         
21067:         switch (dirEntry->tag) {
21067: 
26852:         case TRUETYPE_TAG('h','e','a','d'):
21067:             foundHead = PR_TRUE;
21067:             headOffset = dirEntry->offset;
21067:             headLen = dirEntry->length;
21067:             if (headLen < sizeof(HeadTable)) {
21067:                 NS_WARNING("invalid font (head table length)");
21067:                 return PR_FALSE;
21067:             }
21067:             break;
21067: 
27304:         case TRUETYPE_TAG('k','e','r','n'):
27304:             foundKern = PR_TRUE;
27304:             kernOffset = dirEntry->offset;
27304:             kernLen = dirEntry->length;
27304:             break;
27304: 
26852:         case TRUETYPE_TAG('n','a','m','e'):
21067:             foundName = PR_TRUE;
21067:             nameOffset = dirEntry->offset;
21067:             nameLen = dirEntry->length;
21067:             break;
21067: 
26852:         case TRUETYPE_TAG('O','S','/','2'):
21067:             foundOS2 = PR_TRUE;
21067:             break;
21067: 
26852:         case TRUETYPE_TAG('g','l','y','f'):  // TrueType-style quadratic glyph table
21067:             foundGlyphs = PR_TRUE;
48071:             glyfLen = dirEntry->length;
48071:             break;
48071: 
48071:         case TRUETYPE_TAG('l','o','c','a'):  // glyph location table
48071:             foundLoca = PR_TRUE;
48071:             locaOffset = dirEntry->offset;
48071:             locaLen = dirEntry->length;
48071:             break;
48071: 
48071:         case TRUETYPE_TAG('m','a','x','p'):  // max profile
48071:             foundMaxp = PR_TRUE;
48071:             maxpOffset = dirEntry->offset;
48071:             maxpLen = dirEntry->length;
48071:             if (maxpLen < sizeof(MaxpTableHeader)) {
48071:                 NS_WARNING("invalid font (maxp table length)");
48071:                 return PR_FALSE;
48071:             }
21067:             break;
21067: 
26852:         case TRUETYPE_TAG('C','F','F',' '):  // PS-style cubic glyph table
21067:             foundCFF = PR_TRUE;
21067:             break;
21067: 
21067:         default:
21067:             break;
21067:         }
21067: 
21067:     }
21067: 
21067:     // simple sanity checks
21067:     
48071:     // -- fonts need head, name, maxp tables
48071:     if (!foundHead || !foundName || !foundMaxp) {
48071:         NS_WARNING("invalid font (missing head/name/maxp table)");
21067:         return PR_FALSE;
21067:     }
21067:     
21067:     // -- on Windows need OS/2 table
21067: #ifdef XP_WIN
21067:     if (!foundOS2) {
21067:         NS_WARNING("invalid font (missing OS/2 table)");
21067:         return PR_FALSE;
21067:     }
21067: #endif
21067: 
21067:     // -- head table data
21067:     const HeadTable *headData = reinterpret_cast<const HeadTable*>(aFontData + headOffset);
21067: 
50727:     if (headData->tableVersionNumber != HeadTable::HEAD_VERSION) {
50727:         NS_WARNING("invalid font (head table version)");
50727:         return PR_FALSE;
50727:     }
50727: 
21067:     if (headData->magicNumber != HeadTable::HEAD_MAGIC_NUMBER) {
21067:         NS_WARNING("invalid font (head magic number)");
21067:         return PR_FALSE;
21067:     }
21067: 
21067:     if (headData->checkSumAdjustment != (HeadTable::HEAD_CHECKSUM_CALC_CONST - checksum)) {
21067:         NS_WARNING("invalid font (bad checksum)");
28626:         // Bug 483459 - warn about a bad checksum but allow the font to be 
28626:         // used, since a small percentage of fonts don't calculate this 
28626:         // correctly and font systems aren't fussy about this
28626:         // return PR_FALSE;
21067:     }
21067:     
21067:     // need glyf or CFF table based on sfnt version
26852:     if (sfntVersion == TRUETYPE_TAG('O','T','T','O')) {
21067:         if (!foundCFF) {
21067:             NS_WARNING("invalid font (missing CFF table)");
21067:             return PR_FALSE;
21067:         }
21067:     } else {
48071:         if (!foundGlyphs || !foundLoca) {
48071:             NS_WARNING("invalid font (missing glyf or loca table)");
48071:             return PR_FALSE;
48071:         }
48071: 
48071:         // sanity-check 'loca' offsets
48071:         const MaxpTableHeader *maxpData =
48071:             reinterpret_cast<const MaxpTableHeader*>(aFontData + maxpOffset);
48071:         if (!ValidateLocaTable(aFontData + locaOffset, locaLen, glyfLen,
48071:                                headData->indexToLocFormat,
48071:                                maxpData->numGlyphs)) {
48071:             NS_WARNING("invalid font (loca table offsets)");
21067:             return PR_FALSE;
21067:         }
21067:     }
21067:     
21067:     // -- name table data
21067:     const NameHeader *nameHeader = reinterpret_cast<const NameHeader*>(aFontData + nameOffset);
21067: 
21067:     PRUint32 nameCount = nameHeader->count;
21067: 
21067:     // -- sanity check the number of name records
21067:     if (PRUint64(nameCount) * sizeof(NameRecord) + PRUint64(nameOffset) > dataLength) {
21067:         NS_WARNING("invalid font (name records)");
21067:         return PR_FALSE;
21067:     }
21067:     
21067:     // -- iterate through name records
31590:     const NameRecord *nameRecord = reinterpret_cast<const NameRecord*>
31590:                                        (aFontData + nameOffset + sizeof(NameHeader));
21067:     PRUint64 nameStringsBase = PRUint64(nameOffset) + PRUint64(nameHeader->stringOffset);
21067: 
21067:     for (i = 0; i < nameCount; i++, nameRecord++) {
21067:         PRUint32 namelen = nameRecord->length;
21067:         PRUint32 nameoff = nameRecord->offset;  // offset from base of string storage
21067: 
21067:         if (nameStringsBase + PRUint64(nameoff) + PRUint64(namelen) > dataLength) {
21067:             NS_WARNING("invalid font (name table strings)");
21067:             return PR_FALSE;
21067:         }
21067:     }
21067: 
27304:     // -- sanity-check the kern table, if present (see bug 487549)
27304:     if (foundKern) {
27304:         if (!ValidateKernTable(aFontData + kernOffset, kernLen)) {
27304:             NS_WARNING("invalid font (kern table)");
27304:             return PR_FALSE;
27304:         }
27304:     }
27304: 
21067:     // everything seems consistent
21067:     return PR_TRUE;
21067: }
21067: 
22991: nsresult
22991: gfxFontUtils::RenameFont(const nsAString& aName, const PRUint8 *aFontData, 
60098:                          PRUint32 aFontDataLength, FallibleTArray<PRUint8> *aNewFont)
22991: {
22991:     NS_ASSERTION(aNewFont, "null font data array");
22991:     
22991:     PRUint64 dataLength(aFontDataLength);
22991: 
22991:     // new name table
31590:     static const PRUint32 neededNameIDs[] = {NAME_ID_FAMILY, 
31590:                                              NAME_ID_STYLE,
31590:                                              NAME_ID_UNIQUE,
31590:                                              NAME_ID_FULL,
31590:                                              NAME_ID_POSTSCRIPT};
22991: 
22991:     // calculate new name table size
22991:     PRUint16 nameCount = NS_ARRAY_LENGTH(neededNameIDs);
22991: 
22991:     // leave room for null-terminator
22991:     PRUint16 nameStrLength = (aName.Length() + 1) * sizeof(PRUnichar); 
22991: 
22991:     // round name table size up to 4-byte multiple
22991:     PRUint32 nameTableSize = (sizeof(NameHeader) +
22991:                               sizeof(NameRecord) * nameCount +
22991:                               nameStrLength +
22991:                               3) & ~3;
22991:                               
22991:     if (dataLength + nameTableSize > PR_UINT32_MAX)
22991:         return NS_ERROR_FAILURE;
22991:         
32829:     // bug 505386 - need to handle unpadded font length
32829:     PRUint32 paddedFontDataSize = (aFontDataLength + 3) & ~3;
32829:     PRUint32 adjFontDataSize = paddedFontDataSize + nameTableSize;
22991: 
22991:     // create new buffer: old font data plus new name table
22991:     if (!aNewFont->AppendElements(adjFontDataSize))
22991:         return NS_ERROR_OUT_OF_MEMORY;
22991: 
22991:     // copy the old font data
22991:     PRUint8 *newFontData = reinterpret_cast<PRUint8*>(aNewFont->Elements());
22991:     
32829:     // null the last four bytes in case the font length is not a multiple of 4
32829:     memset(newFontData + aFontDataLength, 0, paddedFontDataSize - aFontDataLength);
32829: 
32829:     // copy font data
22991:     memcpy(newFontData, aFontData, aFontDataLength);
22991:     
22991:     // null out the last 4 bytes for checksum calculations
22991:     memset(newFontData + adjFontDataSize - 4, 0, 4);
22991:     
22991:     NameHeader *nameHeader = reinterpret_cast<NameHeader*>(newFontData +
32829:                                                             paddedFontDataSize);
22991:     
22991:     // -- name header
22991:     nameHeader->format = 0;
22991:     nameHeader->count = nameCount;
22991:     nameHeader->stringOffset = sizeof(NameHeader) + nameCount * sizeof(NameRecord);
22991:     
22991:     // -- name records
22991:     PRUint32 i;
22991:     NameRecord *nameRecord = reinterpret_cast<NameRecord*>(nameHeader + 1);
22991:     
22991:     for (i = 0; i < nameCount; i++, nameRecord++) {
31590:         nameRecord->platformID = PLATFORM_ID_MICROSOFT;
31590:         nameRecord->encodingID = ENCODING_ID_MICROSOFT_UNICODEBMP;
31590:         nameRecord->languageID = LANG_ID_MICROSOFT_EN_US;
22991:         nameRecord->nameID = neededNameIDs[i];
22991:         nameRecord->offset = 0;
22991:         nameRecord->length = nameStrLength;
22991:     }
22991:     
22991:     // -- string data, located after the name records, stored in big-endian form
22991:     PRUnichar *strData = reinterpret_cast<PRUnichar*>(nameRecord);
22991: 
22991:     const PRUnichar *nameStr = aName.BeginReading();
22991:     const PRUnichar *nameStrEnd = aName.EndReading();
22991:     while (nameStr < nameStrEnd) {
22991:         PRUnichar ch = *nameStr++;
22991:         *strData++ = NS_SWAP16(ch);
22991:     }
22991:     *strData = 0; // add null termination
22991:     
22991:     // adjust name table header to point to the new name table
22991:     SFNTHeader *sfntHeader = reinterpret_cast<SFNTHeader*>(newFontData);
22991: 
22991:     // table directory entries begin immediately following SFNT header
22991:     TableDirEntry *dirEntry = 
22991:         reinterpret_cast<TableDirEntry*>(newFontData + sizeof(SFNTHeader));
22991: 
22991:     PRUint32 numTables = sfntHeader->numTables;
22991:     PRBool foundName = PR_FALSE;
22991:     
22991:     for (i = 0; i < numTables; i++, dirEntry++) {
26852:         if (dirEntry->tag == TRUETYPE_TAG('n','a','m','e')) {
22991:             foundName = PR_TRUE;
22991:             break;
22991:         }
22991:     }
22991:     
22991:     // function only called if font validates, so this should always be true
22991:     NS_ASSERTION(foundName, "attempt to rename font with no name table");
22991: 
22991:     // note: dirEntry now points to name record
22991:     
22991:     // recalculate name table checksum
22991:     PRUint32 checkSum = 0;
22991:     AutoSwap_PRUint32 *nameData = reinterpret_cast<AutoSwap_PRUint32*> (nameHeader);
22991:     AutoSwap_PRUint32 *nameDataEnd = nameData + (nameTableSize >> 2);
22991:     
22991:     while (nameData < nameDataEnd)
22991:         checkSum = checkSum + *nameData++;
22991:     
22991:     // adjust name table entry to point to new name table
32829:     dirEntry->offset = paddedFontDataSize;
22991:     dirEntry->length = nameTableSize;
22991:     dirEntry->checkSum = checkSum;
22991:     
22991:     // fix up checksums
22991:     PRUint32 checksum = 0;
22991:     
22991:     // checksum for font = (checksum of header) + (checksum of tables)
22991:     PRUint32 headerLen = sizeof(SFNTHeader) + sizeof(TableDirEntry) * numTables;
22991:     const AutoSwap_PRUint32 *headerData = 
22991:         reinterpret_cast<const AutoSwap_PRUint32*>(newFontData);
22991: 
22991:     // header length is in bytes, checksum calculated in longwords
22991:     for (i = 0; i < (headerLen >> 2); i++, headerData++) {
22991:         checksum += *headerData;
22991:     }
22991:     
22991:     PRUint32 headOffset = 0;
22991:     dirEntry = reinterpret_cast<TableDirEntry*>(newFontData + sizeof(SFNTHeader));
22991: 
22991:     for (i = 0; i < numTables; i++, dirEntry++) {
26852:         if (dirEntry->tag == TRUETYPE_TAG('h','e','a','d')) {
22991:             headOffset = dirEntry->offset;
22991:         }
22991:         checksum += dirEntry->checkSum;
22991:     }
22991:     
22991:     NS_ASSERTION(headOffset != 0, "no head table for font");
22991:     
22991:     HeadTable *headData = reinterpret_cast<HeadTable*>(newFontData + headOffset);
22991: 
22991:     headData->checkSumAdjustment = HeadTable::HEAD_CHECKSUM_CALC_CONST - checksum;
22991: 
22991:     return NS_OK;
22991: }
22991: 
71914: // This is only called after the basic validity of the downloaded sfnt
71914: // data has been checked, so it should never fail to find the name table
71914: // (though it might fail to read it, if memory isn't available);
71914: // other checks here are just for extra paranoia.
71914: nsresult
71914: gfxFontUtils::GetFullNameFromSFNT(const PRUint8* aFontData, PRUint32 aLength,
71914:                                   nsAString& aFullName)
71914: {
71914:     aFullName.AssignLiteral("(MISSING NAME)"); // should always get replaced
71914: 
71914:     NS_ENSURE_TRUE(aLength >= sizeof(SFNTHeader), NS_ERROR_UNEXPECTED);
71914:     const SFNTHeader *sfntHeader =
71914:         reinterpret_cast<const SFNTHeader*>(aFontData);
71914:     const TableDirEntry *dirEntry =
71914:         reinterpret_cast<const TableDirEntry*>(aFontData + sizeof(SFNTHeader));
71914:     PRUint32 numTables = sfntHeader->numTables;
71914:     NS_ENSURE_TRUE(aLength >=
71914:                    sizeof(SFNTHeader) + numTables * sizeof(TableDirEntry),
71914:                    NS_ERROR_UNEXPECTED);
71914:     PRBool foundName = PR_FALSE;
71914:     for (PRUint32 i = 0; i < numTables; i++, dirEntry++) {
71914:         if (dirEntry->tag == TRUETYPE_TAG('n','a','m','e')) {
71914:             foundName = PR_TRUE;
71914:             break;
71914:         }
71914:     }
71914:     
71914:     // should never fail, as we're only called after font validation succeeded
71914:     NS_ENSURE_TRUE(foundName, NS_ERROR_NOT_AVAILABLE);
71914: 
71914:     PRUint32 len = dirEntry->length;
71914:     NS_ENSURE_TRUE(aLength > len && aLength - len >= dirEntry->offset,
71914:                    NS_ERROR_UNEXPECTED);
71914:     FallibleTArray<PRUint8> nameTable;
71914:     if (!nameTable.SetLength(len)) {
71914:         return NS_ERROR_OUT_OF_MEMORY;
71914:     }
71914:     memcpy(nameTable.Elements(), aFontData + dirEntry->offset, len);
71914: 
71914:     return GetFullNameFromTable(nameTable, aFullName);
71914: }
71914: 
71914: nsresult
71914: gfxFontUtils::GetFullNameFromTable(FallibleTArray<PRUint8>& aNameTable,
71914:                                    nsAString& aFullName)
71914: {
71914:     nsAutoString name;
71914:     nsresult rv =
71914:         gfxFontUtils::ReadCanonicalName(aNameTable,
71914:                                         gfxFontUtils::NAME_ID_FULL,
71914:                                         name);
71914:     if (NS_SUCCEEDED(rv) && !name.IsEmpty()) {
71914:         aFullName = name;
71914:         return NS_OK;
71914:     }
71914:     rv = gfxFontUtils::ReadCanonicalName(aNameTable,
71914:                                          gfxFontUtils::NAME_ID_FAMILY,
71914:                                          name);
71914:     if (NS_SUCCEEDED(rv) && !name.IsEmpty()) {
71914:         nsAutoString styleName;
71914:         rv = gfxFontUtils::ReadCanonicalName(aNameTable,
71914:                                              gfxFontUtils::NAME_ID_STYLE,
71914:                                              styleName);
71914:         if (NS_SUCCEEDED(rv) && !styleName.IsEmpty()) {
71914:             name.AppendLiteral(" ");
71914:             name.Append(styleName);
71914:             aFullName = name;
71914:         }
71914:         return NS_OK;
71914:     }
71914: 
71914:     return NS_ERROR_NOT_AVAILABLE;
71914: }
71914: 
26852: enum {
26852: #if defined(XP_MACOSX)
31590:     CANONICAL_LANG_ID = gfxFontUtils::LANG_ID_MAC_ENGLISH,
31590:     PLATFORM_ID       = gfxFontUtils::PLATFORM_ID_MAC
26852: #else
31590:     CANONICAL_LANG_ID = gfxFontUtils::LANG_ID_MICROSOFT_EN_US,
31590:     PLATFORM_ID       = gfxFontUtils::PLATFORM_ID_MICROSOFT
26852: #endif
26852: };    
26852: 
26852: nsresult
60098: gfxFontUtils::ReadNames(FallibleTArray<PRUint8>& aNameTable, PRUint32 aNameID, 
26852:                         PRInt32 aPlatformID, nsTArray<nsString>& aNames)
26852: {
31590:     return ReadNames(aNameTable, aNameID, LANG_ALL, aPlatformID, aNames);
26852: }
26852: 
26852: nsresult
60098: gfxFontUtils::ReadCanonicalName(FallibleTArray<PRUint8>& aNameTable, PRUint32 aNameID, 
26852:                                 nsString& aName)
26852: {
26852:     nsresult rv;
26852:     
26852:     nsTArray<nsString> names;
26852:     
26852:     // first, look for the English name (this will succeed 99% of the time)
26852:     rv = ReadNames(aNameTable, aNameID, CANONICAL_LANG_ID, PLATFORM_ID, names);
26852:     NS_ENSURE_SUCCESS(rv, rv);
26852:         
26852:     // otherwise, grab names for all languages
26852:     if (names.Length() == 0) {
31590:         rv = ReadNames(aNameTable, aNameID, LANG_ALL, PLATFORM_ID, names);
26852:         NS_ENSURE_SUCCESS(rv, rv);
26852:     }
26852:     
26852: #if defined(XP_MACOSX)
26852:     // may be dealing with font that only has Microsoft name entries
26852:     if (names.Length() == 0) {
31590:         rv = ReadNames(aNameTable, aNameID, LANG_ID_MICROSOFT_EN_US, 
31590:                        PLATFORM_ID_MICROSOFT, names);
26852:         NS_ENSURE_SUCCESS(rv, rv);
26852:         
26852:         // getting really desperate now, take anything!
26852:         if (names.Length() == 0) {
31590:             rv = ReadNames(aNameTable, aNameID, LANG_ALL, 
31590:                            PLATFORM_ID_MICROSOFT, names);
26852:             NS_ENSURE_SUCCESS(rv, rv);
26852:         }
26852:     }
26852: #endif
26852: 
26852:     // return the first name (99.9% of the time names will
26852:     // contain a single English name)
26852:     if (names.Length()) {
26852:         aName.Assign(names[0]);
26852:         return NS_OK;
26852:     }
26852:         
26852:     return NS_ERROR_FAILURE;
26852: }
26852: 
31590: // Charsets to use for decoding Mac platform font names.
31590: // This table is sorted by {encoding, language}, with the wildcard "ANY" being
31590: // greater than any defined values for each field; we use a binary search on both
31590: // fields, and fall back to matching only encoding if necessary
31590: 
31590: // Some "redundant" entries for specific combinations are included such as
31590: // encoding=roman, lang=english, in order that common entries will be found
31590: // on the first search.
31590: 
31590: #define ANY 0xffff
31590: const gfxFontUtils::MacFontNameCharsetMapping gfxFontUtils::gMacFontNameCharsets[] =
26852: {
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_ENGLISH,      "x-mac-roman"     },
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_ICELANDIC,    "x-mac-icelandic" },
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_TURKISH,      "x-mac-turkish"   },
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_POLISH,       "x-mac-ce"        },
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_ROMANIAN,     "x-mac-romanian"  },
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_CZECH,        "x-mac-ce"        },
31590:     { ENCODING_ID_MAC_ROMAN,        LANG_ID_MAC_SLOVAK,       "x-mac-ce"        },
31590:     { ENCODING_ID_MAC_ROMAN,        ANY,                      "x-mac-roman"     },
31590:     { ENCODING_ID_MAC_JAPANESE,     LANG_ID_MAC_JAPANESE,     "Shift_JIS"       },
31590:     { ENCODING_ID_MAC_JAPANESE,     ANY,                      "Shift_JIS"       },
31590:     { ENCODING_ID_MAC_TRAD_CHINESE, LANG_ID_MAC_TRAD_CHINESE, "Big5"            },
31590:     { ENCODING_ID_MAC_TRAD_CHINESE, ANY,                      "Big5"            },
31590:     { ENCODING_ID_MAC_KOREAN,       LANG_ID_MAC_KOREAN,       "EUC-KR"          },
31590:     { ENCODING_ID_MAC_KOREAN,       ANY,                      "EUC-KR"          },
31590:     { ENCODING_ID_MAC_ARABIC,       LANG_ID_MAC_ARABIC,       "x-mac-arabic"    },
31590:     { ENCODING_ID_MAC_ARABIC,       LANG_ID_MAC_URDU,         "x-mac-farsi"     },
31590:     { ENCODING_ID_MAC_ARABIC,       LANG_ID_MAC_FARSI,        "x-mac-farsi"     },
31590:     { ENCODING_ID_MAC_ARABIC,       ANY,                      "x-mac-arabic"    },
31590:     { ENCODING_ID_MAC_HEBREW,       LANG_ID_MAC_HEBREW,       "x-mac-hebrew"    },
31590:     { ENCODING_ID_MAC_HEBREW,       ANY,                      "x-mac-hebrew"    },
31590:     { ENCODING_ID_MAC_GREEK,        ANY,                      "x-mac-greek"     },
31590:     { ENCODING_ID_MAC_CYRILLIC,     ANY,                      "x-mac-cyrillic"  },
31590:     { ENCODING_ID_MAC_DEVANAGARI,   ANY,                      "x-mac-devanagari"},
31590:     { ENCODING_ID_MAC_GURMUKHI,     ANY,                      "x-mac-gurmukhi"  },
31590:     { ENCODING_ID_MAC_GUJARATI,     ANY,                      "x-mac-gujarati"  },
31590:     { ENCODING_ID_MAC_SIMP_CHINESE, LANG_ID_MAC_SIMP_CHINESE, "GB2312"          },
31590:     { ENCODING_ID_MAC_SIMP_CHINESE, ANY,                      "GB2312"          }
31590: };
26852: 
31590: const char* gfxFontUtils::gISOFontNameCharsets[] = 
31590: {
31590:     /* 0 */ "us-ascii"   ,
31590:     /* 1 */ nsnull       , /* spec says "ISO 10646" but does not specify encoding form! */
31590:     /* 2 */ "ISO-8859-1"
31590: };
26852: 
31590: const char* gfxFontUtils::gMSFontNameCharsets[] =
31590: {
31590:     /* [0] ENCODING_ID_MICROSOFT_SYMBOL */      ""          ,
31590:     /* [1] ENCODING_ID_MICROSOFT_UNICODEBMP */  ""          ,
31590:     /* [2] ENCODING_ID_MICROSOFT_SHIFTJIS */    "Shift_JIS" ,
31590:     /* [3] ENCODING_ID_MICROSOFT_PRC */         nsnull      ,
31590:     /* [4] ENCODING_ID_MICROSOFT_BIG5 */        "Big5"      ,
31590:     /* [5] ENCODING_ID_MICROSOFT_WANSUNG */     nsnull      ,
31590:     /* [6] ENCODING_ID_MICROSOFT_JOHAB */       "x-johab"   ,
31590:     /* [7] reserved */                          nsnull      ,
31590:     /* [8] reserved */                          nsnull      ,
31590:     /* [9] reserved */                          nsnull      ,
31590:     /*[10] ENCODING_ID_MICROSOFT_UNICODEFULL */ ""
31590: };
26852: 
31590: #define ARRAY_SIZE(A) (sizeof(A) / sizeof(A[0]))
31590: 
31590: // Return the name of the charset we should use to decode a font name
31590: // given the name table attributes.
31590: // Special return values:
31590: //    ""       charset is UTF16BE, no need for a converter
31590: //    nsnull   unknown charset, do not attempt conversion
31590: const char*
31590: gfxFontUtils::GetCharsetForFontName(PRUint16 aPlatform, PRUint16 aScript, PRUint16 aLanguage)
26852: {
31590:     switch (aPlatform)
31590:     {
31590:     case PLATFORM_ID_UNICODE:
31590:         return "";
31590: 
31590:     case PLATFORM_ID_MAC:
31590:         {
31590:             PRUint32 lo = 0, hi = ARRAY_SIZE(gMacFontNameCharsets);
31590:             MacFontNameCharsetMapping searchValue = { aScript, aLanguage, nsnull };
31590:             for (PRUint32 i = 0; i < 2; ++i) {
31590:                 // binary search; if not found, set language to ANY and try again
31590:                 while (lo < hi) {
31590:                     PRUint32 mid = (lo + hi) / 2;
31590:                     const MacFontNameCharsetMapping& entry = gMacFontNameCharsets[mid];
31590:                     if (entry < searchValue) {
31590:                         lo = mid + 1;
31590:                         continue;
31590:                     }
31590:                     if (searchValue < entry) {
31590:                         hi = mid;
31590:                         continue;
31590:                     }
31590:                     // found a match
31590:                     return entry.mCharsetName;
26852:                 }
26852: 
31590:                 // no match, so reset high bound for search and re-try
31590:                 hi = ARRAY_SIZE(gMacFontNameCharsets);
31590:                 searchValue.mLanguage = ANY;
31590:             }
31590:         }
31590:         break;
26852: 
31590:     case PLATFORM_ID_ISO:
31590:         if (aScript < ARRAY_SIZE(gISOFontNameCharsets)) {
31590:             return gISOFontNameCharsets[aScript];
31590:         }
31590:         break;
26852: 
31590:     case PLATFORM_ID_MICROSOFT:
31590:         if (aScript < ARRAY_SIZE(gMSFontNameCharsets)) {
31590:             return gMSFontNameCharsets[aScript];
31590:         }
31590:         break;
31590:     }
31590: 
31590:     return nsnull;
31590: }
31590: 
31590: // convert a raw name from the name table to an nsString, if possible;
31590: // return value indicates whether conversion succeeded
31590: PRBool
31590: gfxFontUtils::DecodeFontName(const PRUint8 *aNameData, PRInt32 aByteLen, 
31590:                              PRUint32 aPlatformCode, PRUint32 aScriptCode,
31590:                              PRUint32 aLangCode, nsAString& aName)
31590: {
31590:     NS_ASSERTION(aByteLen > 0, "bad length for font name data");
31590: 
31590:     const char *csName = GetCharsetForFontName(aPlatformCode, aScriptCode, aLangCode);
31590: 
31590:     if (!csName) {
31590:         // nsnull -> unknown charset
31590: #ifdef DEBUG
31590:         char warnBuf[128];
31590:         if (aByteLen > 64)
31590:             aByteLen = 64;
31590:         sprintf(warnBuf, "skipping font name, unknown charset %d:%d:%d for <%.*s>",
31590:                 aPlatformCode, aScriptCode, aLangCode, aByteLen, aNameData);
31590:         NS_WARNING(warnBuf);
31590: #endif
31590:         return PR_FALSE;
31590:     }
31590: 
31590:     if (csName[0] == 0) {
31590:         // empty charset name: data is utf16be, no need to instantiate a converter
31590:         PRUint32 strLen = aByteLen / 2;
31590: #ifdef IS_LITTLE_ENDIAN
31590:         aName.SetLength(strLen);
31631:         CopySwapUTF16(reinterpret_cast<const PRUint16*>(aNameData),
31631:                       reinterpret_cast<PRUint16*>(aName.BeginWriting()), strLen);
26852: #else
31590:         aName.Assign(reinterpret_cast<const PRUnichar*>(aNameData), strLen);
31590: #endif    
31590:         return PR_TRUE;
31590:     }
26852: 
31590:     nsresult rv;
31590:     nsCOMPtr<nsICharsetConverterManager> ccm =
31590:         do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
31590:     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get charset converter manager");
31590:     if (NS_FAILED(rv)) {
31590:         return PR_FALSE;
31590:     }
26852: 
31590:     nsCOMPtr<nsIUnicodeDecoder> decoder;
57099:     rv = ccm->GetUnicodeDecoderRawInternal(csName, getter_AddRefs(decoder));
31590:     if (NS_FAILED(rv)) {
31590:         NS_WARNING("failed to get the decoder for a font name string");
31590:         return PR_FALSE;
31590:     }
26852: 
31590:     PRInt32 destLength;
31590:     rv = decoder->GetMaxLength(reinterpret_cast<const char*>(aNameData), aByteLen, &destLength);
31590:     if (NS_FAILED(rv)) {
31590:         NS_WARNING("decoder->GetMaxLength failed, invalid font name?");
31590:         return PR_FALSE;
31590:     }
26852: 
31590:     // make space for the converted string
31590:     aName.SetLength(destLength);
31590:     rv = decoder->Convert(reinterpret_cast<const char*>(aNameData), &aByteLen,
31590:                           aName.BeginWriting(), &destLength);
31590:     if (NS_FAILED(rv)) {
31590:         NS_WARNING("decoder->Convert failed, invalid font name?");
31590:         return PR_FALSE;
26852:     }
31590:     aName.Truncate(destLength); // set the actual length
26852: 
31590:     return PR_TRUE;
26852: }
26852: 
26852: nsresult
60098: gfxFontUtils::ReadNames(FallibleTArray<PRUint8>& aNameTable, PRUint32 aNameID, 
26852:                         PRInt32 aLangID, PRInt32 aPlatformID,
26852:                         nsTArray<nsString>& aNames)
26852: {
26852:     PRUint32 nameTableLen = aNameTable.Length();
26852:     NS_ASSERTION(nameTableLen != 0, "null name table");
26852: 
26852:     if (nameTableLen == 0)
26852:         return NS_ERROR_FAILURE;
26852: 
26852:     PRUint8 *nameTable = aNameTable.Elements();
26852: 
26852:     // -- name table data
26852:     const NameHeader *nameHeader = reinterpret_cast<const NameHeader*>(nameTable);
26852: 
26852:     PRUint32 nameCount = nameHeader->count;
26852: 
26852:     // -- sanity check the number of name records
26852:     if (PRUint64(nameCount) * sizeof(NameRecord) > nameTableLen) {
26852:         NS_WARNING("invalid font (name table data)");
26852:         return NS_ERROR_FAILURE;
26852:     }
26852:     
26852:     // -- iterate through name records
26852:     const NameRecord *nameRecord 
26852:         = reinterpret_cast<const NameRecord*>(nameTable + sizeof(NameHeader));
26852:     PRUint64 nameStringsBase = PRUint64(nameHeader->stringOffset);
26852: 
26852:     PRUint32 i;
26852:     for (i = 0; i < nameCount; i++, nameRecord++) {
26852:         PRUint32 platformID;
26852:         
26852:         // skip over unwanted nameID's
26852:         if (PRUint32(nameRecord->nameID) != aNameID)
26852:             continue;
26852: 
26852:         // skip over unwanted platform data
26852:         platformID = nameRecord->platformID;
26852:         if (aPlatformID != PLATFORM_ALL 
26852:             && PRUint32(nameRecord->platformID) != PLATFORM_ID)
26852:             continue;
26852:             
26852:         // skip over unwanted languages
31590:         if (aLangID != LANG_ALL 
26852:               && PRUint32(nameRecord->languageID) != PRUint32(aLangID))
26852:             continue;
26852:         
26852:         // add name to names array
26852:         
26852:         // -- calculate string location
26852:         PRUint32 namelen = nameRecord->length;
26852:         PRUint32 nameoff = nameRecord->offset;  // offset from base of string storage
26852: 
26852:         if (nameStringsBase + PRUint64(nameoff) + PRUint64(namelen) 
26852:                 > nameTableLen) {
26852:             NS_WARNING("invalid font (name table strings)");
26852:             return NS_ERROR_FAILURE;
26852:         }
26852:         
26852:         // -- decode if necessary and make nsString
26852:         nsAutoString name;
26852:         nsresult rv;
26852:         
31590:         rv = DecodeFontName(nameTable + nameStringsBase + nameoff, namelen, 
31590:                             platformID, PRUint32(nameRecord->encodingID),
31590:                             PRUint32(nameRecord->languageID), name);
26852:         
26852:         if (NS_FAILED(rv))
26852:             continue;
26852:             
26852:         PRUint32 k, numNames;
26852:         PRBool foundName = PR_FALSE;
26852:         
26852:         numNames = aNames.Length();
26852:         for (k = 0; k < numNames; k++) {
26852:             if (name.Equals(aNames[k])) {
26852:                 foundName = PR_TRUE;
26852:                 break;
26852:             }    
26852:         }
26852:         
26852:         if (!foundName)
26852:             aNames.AppendElement(name);                          
26852: 
26852:     }
26852: 
26852:     return NS_OK;
26852: }
26852: 
41238: #ifdef XP_WIN
41238: 
19962: // Embedded OpenType (EOT) handling
19962: // needed for dealing with downloadable fonts on Windows
19962: //
19962: // EOT version 0x00020001
19962: // based on http://www.w3.org/Submission/2008/SUBM-EOT-20080305/
19962: //
19962: // EOT header consists of a fixed-size portion containing general font
19962: // info, followed by a variable-sized portion containing name data,
19962: // followed by the actual TT/OT font data (non-byte values are always
19962: // stored in big-endian format)
19962: //
19962: // EOT header is stored in *little* endian order!!
19962: 
41238: #pragma pack(1)
41238: 
19962: struct EOTFixedHeader {
19962: 
19962:     PRUint32      eotSize;            // Total structure length in PRUint8s (including string and font data)
19962:     PRUint32      fontDataSize;       // Length of the OpenType font (FontData) in PRUint8s
19962:     PRUint32      version;            // Version number of this format - 0x00010000
19962:     PRUint32      flags;              // Processing Flags
19962:     PRUint8       panose[10];         // The PANOSE value for this font - See http://www.microsoft.com/typography/otspec/os2.htm#pan
19962:     PRUint8       charset;            // In Windows this is derived from TEXTMETRIC.tmCharSet. This value specifies the character set of the font. DEFAULT_CHARSET (0x01) indicates no preference. - See http://msdn2.microsoft.com/en-us/library/ms534202.aspx
19962:     PRUint8       italic;             // If the bit for ITALIC is set in OS/2.fsSelection, the value will be 0x01 - See http://www.microsoft.com/typography/otspec/os2.htm#fss
19962:     PRUint32      weight;             // The weight value for this font - See http://www.microsoft.com/typography/otspec/os2.htm#wtc
19962:     PRUint16      fsType;             // Type flags that provide information about embedding permissions - See http://www.microsoft.com/typography/otspec/os2.htm#fst
19962:     PRUint16      magicNumber;        // Magic number for EOT file - 0x504C. Used to check for data corruption.
19962:     PRUint32      unicodeRange1;      // OS/2.UnicodeRange1 (bits 0-31) - See http://www.microsoft.com/typography/otspec/os2.htm#ur
19962:     PRUint32      unicodeRange2;      // OS/2.UnicodeRange2 (bits 32-63) - See http://www.microsoft.com/typography/otspec/os2.htm#ur
19962:     PRUint32      unicodeRange3;      // OS/2.UnicodeRange3 (bits 64-95) - See http://www.microsoft.com/typography/otspec/os2.htm#ur
19962:     PRUint32      unicodeRange4;      // OS/2.UnicodeRange4 (bits 96-127) - See http://www.microsoft.com/typography/otspec/os2.htm#ur
19962:     PRUint32      codePageRange1;     // CodePageRange1 (bits 0-31) - See http://www.microsoft.com/typography/otspec/os2.htm#cpr
19962:     PRUint32      codePageRange2;     // CodePageRange2 (bits 32-63) - See http://www.microsoft.com/typography/otspec/os2.htm#cpr
19962:     PRUint32      checkSumAdjustment; // head.CheckSumAdjustment - See http://www.microsoft.com/typography/otspec/head.htm
19962:     PRUint32      reserved[4];        // Reserved - must be 0
19962:     PRUint16      padding1;           // Padding to maintain long alignment. Padding value must always be set to 0x0000.
19962: 
19962:     enum {
19962:         EOT_VERSION = 0x00020001,
19962:         EOT_MAGIC_NUMBER = 0x504c,
19962:         EOT_DEFAULT_CHARSET = 0x01,
19962:         EOT_EMBED_PRINT_PREVIEW = 0x0004,
19962:         EOT_FAMILY_NAME_INDEX = 0,    // order of names in variable portion of EOT header
19962:         EOT_STYLE_NAME_INDEX = 1,
19962:         EOT_VERSION_NAME_INDEX = 2,
19962:         EOT_FULL_NAME_INDEX = 3,
19962:         EOT_NUM_NAMES = 4
19962:     };
19962: 
19962: };
19962: 
41238: #pragma pack()
41238: 
21067: // EOT headers are only used on Windows
21067: 
19962: // EOT variable-sized header (version 0x00020001 - contains 4 name
19962: // fields, each with the structure):
19962: //
19962: //   // number of bytes in the name array
19962: //   PRUint16 size;
19962: //   // array of UTF-16 chars, total length = <size> bytes
19962: //   // note: english version of name record string
19962: //   PRUint8  name[size]; 
19962: //
19962: // This structure is used for the following names, each separated by two
19962: // bytes of padding (always 0 with no padding after the rootString):
19962: //
19962: //   familyName  - based on name ID = 1
19962: //   styleName   - based on name ID = 2
19962: //   versionName - based on name ID = 5
19962: //   fullName    - based on name ID = 4
19962: //   rootString  - used to restrict font usage to a specific domain
19962: //
19962: 
21067: #if DEBUG
19962: static void 
21067: DumpEOTHeader(PRUint8 *aHeader, PRUint32 aHeaderLen)
19962: {
19962:     PRUint32 offset = 0;
19962:     PRUint8 *ch = aHeader;
19962: 
19962:     printf("\n\nlen == %d\n\n", aHeaderLen);
19962:     while (offset < aHeaderLen) {
19962:         printf("%7.7x    ", offset);
19962:         int i;
19962:         for (i = 0; i < 16; i++) {
19962:             printf("%2.2x  ", *ch++);
19962:         }
19962:         printf("\n");
19962:         offset += 16;
19962:     }
19962: }
19962: #endif
19962: 
19962: nsresult
21067: gfxFontUtils::MakeEOTHeader(const PRUint8 *aFontData, PRUint32 aFontDataLength,
60098:                             FallibleTArray<PRUint8> *aHeader,
60098:                             FontDataOverlay *aOverlay)
19962: {
21067:     NS_ASSERTION(aFontData && aFontDataLength != 0, "null font data");
21067:     NS_ASSERTION(aHeader, "null header");
21067:     NS_ASSERTION(aHeader->Length() == 0, "non-empty header passed in");
30595:     NS_ASSERTION(aOverlay, "null font overlay struct passed in");
30595: 
30595:     aOverlay->overlaySrc = 0;
19962:     
19962:     if (!aHeader->AppendElements(sizeof(EOTFixedHeader)))
19962:         return NS_ERROR_OUT_OF_MEMORY;
19962: 
19962:     EOTFixedHeader *eotHeader = reinterpret_cast<EOTFixedHeader*>(aHeader->Elements());
19962:     memset(eotHeader, 0, sizeof(EOTFixedHeader));
19962: 
21067:     PRUint32 fontDataSize = aFontDataLength;
19962: 
19962:     // set up header fields
19962:     eotHeader->fontDataSize = fontDataSize;
19962:     eotHeader->version = EOTFixedHeader::EOT_VERSION;
19962:     eotHeader->flags = 0;  // don't specify any special processing
19962:     eotHeader->charset = EOTFixedHeader::EOT_DEFAULT_CHARSET;
19962:     eotHeader->fsType = EOTFixedHeader::EOT_EMBED_PRINT_PREVIEW;
19962:     eotHeader->magicNumber = EOTFixedHeader::EOT_MAGIC_NUMBER;
19962: 
19962:     // read in the sfnt header
21067:     if (sizeof(SFNTHeader) > aFontDataLength)
21067:         return NS_ERROR_FAILURE;
21067:     
21067:     const SFNTHeader *sfntHeader = reinterpret_cast<const SFNTHeader*>(aFontData);
21067:     if (!IsValidSFNTVersion(sfntHeader->sfntVersion))
19962:         return NS_ERROR_FAILURE;
19962: 
19962:     // iterate through the table headers to find the head, name and OS/2 tables
19962:     PRBool foundHead = PR_FALSE, foundOS2 = PR_FALSE, foundName = PR_FALSE, foundGlyphs = PR_FALSE;
19962:     PRUint32 headOffset, headLen, nameOffset, nameLen, os2Offset, os2Len;
19962:     PRUint32 i, numTables;
19962: 
21067:     numTables = sfntHeader->numTables;
21067:     if (sizeof(SFNTHeader) + sizeof(TableDirEntry) * numTables > aFontDataLength)
19962:         return NS_ERROR_FAILURE;
19962:     
21067:     PRUint64 dataLength(aFontDataLength);
21067:     
21067:     // table directory entries begin immediately following SFNT header
21067:     const TableDirEntry *dirEntry = reinterpret_cast<const TableDirEntry*>(aFontData + sizeof(SFNTHeader));
21067:     
21067:     for (i = 0; i < numTables; i++, dirEntry++) {
21067:     
21067:         // sanity check on offset, length values
21067:         if (PRUint64(dirEntry->offset) + PRUint64(dirEntry->length) > dataLength)
21067:             return NS_ERROR_FAILURE;
21067: 
21067:         switch (dirEntry->tag) {
19962: 
26852:         case TRUETYPE_TAG('h','e','a','d'):
19962:             foundHead = PR_TRUE;
21067:             headOffset = dirEntry->offset;
21067:             headLen = dirEntry->length;
19962:             if (headLen < sizeof(HeadTable))
19962:                 return NS_ERROR_FAILURE;
19962:             break;
19962: 
26852:         case TRUETYPE_TAG('n','a','m','e'):
19962:             foundName = PR_TRUE;
21067:             nameOffset = dirEntry->offset;
21067:             nameLen = dirEntry->length;
19962:             break;
19962: 
26852:         case TRUETYPE_TAG('O','S','/','2'):
19962:             foundOS2 = PR_TRUE;
21067:             os2Offset = dirEntry->offset;
21067:             os2Len = dirEntry->length;
19962:             break;
19962: 
26852:         case TRUETYPE_TAG('g','l','y','f'):  // TrueType-style quadratic glyph table
19962:             foundGlyphs = PR_TRUE;
19962:             break;
19962: 
26852:         case TRUETYPE_TAG('C','F','F',' '):  // PS-style cubic glyph table
19962:             foundGlyphs = PR_TRUE;
19962:             break;
19962: 
19962:         default:
19962:             break;
19962:         }
19962: 
19962:         if (foundHead && foundName && foundOS2 && foundGlyphs)
19962:             break;
19962:     }
19962: 
19962:     // require these three tables on Windows
19962:     if (!foundHead || !foundName || !foundOS2)
19962:         return NS_ERROR_FAILURE;
19962: 
21067:     // at this point, all table offset/length values are within bounds
21067:     
19962:     // read in the data from those tables
19962: 
19962:     // -- head table data
21067:     const HeadTable  *headData = reinterpret_cast<const HeadTable*>(aFontData + headOffset);
21067: 
50727:     if (headData->tableVersionNumber != HeadTable::HEAD_VERSION ||
50727:         headData->magicNumber != HeadTable::HEAD_MAGIC_NUMBER) {
19962:         return NS_ERROR_FAILURE;
50727:     }
19962: 
21067:     eotHeader->checkSumAdjustment = headData->checkSumAdjustment;
19962: 
19962:     // -- name table data
19962: 
19962:     // -- first, read name table header
21067:     const NameHeader *nameHeader = reinterpret_cast<const NameHeader*>(aFontData + nameOffset);
30595:     PRUint32 nameStringsBase = PRUint32(nameHeader->stringOffset);
19962: 
21067:     PRUint32 nameCount = nameHeader->count;
21067: 
21067:     // -- sanity check the number of name records
21067:     if (PRUint64(nameCount) * sizeof(NameRecord) + PRUint64(nameOffset) > dataLength)
19962:         return NS_ERROR_FAILURE;
19962:     
19962:     // -- iterate through name records, look for specific name ids with
19962:     //    matching platform/encoding/etc. and store offset/lengths
19962:     NameRecordData names[EOTFixedHeader::EOT_NUM_NAMES] = {0};
21067:     const NameRecord *nameRecord = reinterpret_cast<const NameRecord*>(aFontData + nameOffset + sizeof(NameHeader));
25463:     PRUint32 needNames = (1 << EOTFixedHeader::EOT_FAMILY_NAME_INDEX) | 
25463:                          (1 << EOTFixedHeader::EOT_STYLE_NAME_INDEX) | 
25463:                          (1 << EOTFixedHeader::EOT_FULL_NAME_INDEX) | 
25463:                          (1 << EOTFixedHeader::EOT_VERSION_NAME_INDEX);
19962: 
21067:     for (i = 0; i < nameCount; i++, nameRecord++) {
19962: 
19962:         // looking for Microsoft English US name strings, skip others
31590:         if (PRUint32(nameRecord->platformID) != PLATFORM_ID_MICROSOFT || 
31590:                 PRUint32(nameRecord->encodingID) != ENCODING_ID_MICROSOFT_UNICODEBMP || 
31590:                 PRUint32(nameRecord->languageID) != LANG_ID_MICROSOFT_EN_US)
19962:             continue;
19962: 
21067:         switch ((PRUint32)nameRecord->nameID) {
19962: 
31590:         case NAME_ID_FAMILY:
21067:             names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].offset = nameRecord->offset;
21067:             names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].length = nameRecord->length;
25463:             needNames &= ~(1 << EOTFixedHeader::EOT_FAMILY_NAME_INDEX);
19962:             break;
19962: 
31590:         case NAME_ID_STYLE:
21067:             names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].offset = nameRecord->offset;
21067:             names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].length = nameRecord->length;
25463:             needNames &= ~(1 << EOTFixedHeader::EOT_STYLE_NAME_INDEX);
19962:             break;
19962: 
31590:         case NAME_ID_FULL:
21067:             names[EOTFixedHeader::EOT_FULL_NAME_INDEX].offset = nameRecord->offset;
21067:             names[EOTFixedHeader::EOT_FULL_NAME_INDEX].length = nameRecord->length;
25463:             needNames &= ~(1 << EOTFixedHeader::EOT_FULL_NAME_INDEX);
19962:             break;
19962: 
31590:         case NAME_ID_VERSION:
21067:             names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].offset = nameRecord->offset;
21067:             names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].length = nameRecord->length;
25463:             needNames &= ~(1 << EOTFixedHeader::EOT_VERSION_NAME_INDEX);
19962:             break;
19962: 
19962:         default:
19962:             break;
19962:         }
19962: 
25463:         if (needNames == 0)
19962:             break;
19962:     }
19962: 
40911:     // the Version name is allowed to be null
40911:     if ((needNames & ~(1 << EOTFixedHeader::EOT_VERSION_NAME_INDEX)) != 0) {
19962:         return NS_ERROR_FAILURE;
19962:     }
19962: 
19962:     // -- expand buffer if needed to include variable-length portion
19962:     PRUint32 eotVariableLength = 0;
19962:     eotVariableLength = (names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].length & (~1)) +
19962:                         (names[EOTFixedHeader::EOT_STYLE_NAME_INDEX].length & (~1)) +
19962:                         (names[EOTFixedHeader::EOT_FULL_NAME_INDEX].length & (~1)) +
19962:                         (names[EOTFixedHeader::EOT_VERSION_NAME_INDEX].length & (~1)) +
19962:                         EOTFixedHeader::EOT_NUM_NAMES * (2 /* size */ 
19962:                                                          + 2 /* padding */) +
19962:                         2 /* null root string size */;
19962: 
19962:     if (!aHeader->AppendElements(eotVariableLength))
19962:         return NS_ERROR_OUT_OF_MEMORY;
19962: 
19962:     // append the string data to the end of the EOT header
19962:     PRUint8 *eotEnd = aHeader->Elements() + sizeof(EOTFixedHeader);
21067:     PRUint32 strOffset, strLen;
19962: 
19962:     for (i = 0; i < EOTFixedHeader::EOT_NUM_NAMES; i++) {
19962:         PRUint32 namelen = names[i].length;
19962:         PRUint32 nameoff = names[i].offset;  // offset from base of string storage
19962: 
21067:         // sanity check the name string location
36486:         if (PRUint64(nameOffset) + PRUint64(nameStringsBase) +
36486:             PRUint64(nameoff) + PRUint64(namelen) > dataLength) {
19962:             return NS_ERROR_FAILURE;
30595:         }
19962: 
36486:         strOffset = nameOffset + nameStringsBase + nameoff;
21067: 
19962:         // output 2-byte str size
19962:         strLen = namelen & (~1);  // UTF-16 string len must be even
19962:         *((PRUint16*) eotEnd) = PRUint16(strLen);
19962:         eotEnd += 2;
19962: 
19962:         // length is number of UTF-16 chars, not bytes
21067:         CopySwapUTF16(reinterpret_cast<const PRUint16*>(aFontData + strOffset),
19962:                       reinterpret_cast<PRUint16*>(eotEnd),
19962:                       (strLen >> 1));
19962:         eotEnd += strLen;
19962: 
19962:         // add 2-byte zero padding to the end of each string
19962:         *eotEnd++ = 0;
19962:         *eotEnd++ = 0;
19962: 
19962:        // Note: Microsoft's WEFT tool produces name strings which
19962:        // include an extra null at the end of each string, in addition
19962:        // to the 2-byte zero padding that separates the string fields. 
19962:        // Don't think this is important to imitate...
19962:     }
19962: 
19962:     // append null root string size
19962:     *eotEnd++ = 0;
19962:     *eotEnd++ = 0;
19962: 
19962:     NS_ASSERTION(eotEnd == aHeader->Elements() + aHeader->Length(), 
19962:                  "header length calculation incorrect");
19962:                  
30595:     // bug 496573 -- fonts with a fullname that does not begin with the 
30595:     // family name cause the EOT font loading API to hiccup
30595:     PRUint32 famOff = names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].offset;
30595:     PRUint32 famLen = names[EOTFixedHeader::EOT_FAMILY_NAME_INDEX].length;
30595:     PRUint32 fullOff = names[EOTFixedHeader::EOT_FULL_NAME_INDEX].offset;
30595:     PRUint32 fullLen = names[EOTFixedHeader::EOT_FULL_NAME_INDEX].length;
30595:     
30595:     const PRUint8 *nameStrings = aFontData + nameOffset + nameStringsBase;
30595: 
30595:     // assure that the start of the fullname matches the family name
30595:     if (famLen <= fullLen 
30595:         && memcmp(nameStrings + famOff, nameStrings + fullOff, famLen)) {
30595:         aOverlay->overlaySrc = nameOffset + nameStringsBase + famOff;
30595:         aOverlay->overlaySrcLen = famLen;
30595:         aOverlay->overlayDest = nameOffset + nameStringsBase + fullOff;
30595:     }
30595: 
19962:     // -- OS/2 table data
21067:     const OS2Table *os2Data = reinterpret_cast<const OS2Table*>(aFontData + os2Offset);
19962: 
21067:     memcpy(eotHeader->panose, os2Data->panose, sizeof(eotHeader->panose));
19962: 
21067:     eotHeader->italic = (PRUint16) os2Data->fsSelection & 0x01;
21067:     eotHeader->weight = os2Data->usWeightClass;
21067:     eotHeader->unicodeRange1 = os2Data->unicodeRange1;
21067:     eotHeader->unicodeRange2 = os2Data->unicodeRange2;
21067:     eotHeader->unicodeRange3 = os2Data->unicodeRange3;
21067:     eotHeader->unicodeRange4 = os2Data->unicodeRange4;
21067:     eotHeader->codePageRange1 = os2Data->codePageRange1;
21067:     eotHeader->codePageRange2 = os2Data->codePageRange2;
19962: 
19962:     eotHeader->eotSize = aHeader->Length() + fontDataSize;
19962: 
19962:     // DumpEOTHeader(aHeader->Elements(), aHeader->Length());
19962: 
19962:     return NS_OK;
19962: }
19962: 
32808: /* static */
32808: PRBool
63900: gfxFontUtils::IsCffFont(const PRUint8* aFontData, PRBool& hasVertical)
32808: {
32808:     // this is only called after aFontData has passed basic validation,
32808:     // so we know there is enough data present to allow us to read the version!
32808:     const SFNTHeader *sfntHeader = reinterpret_cast<const SFNTHeader*>(aFontData);
63900: 
63900:     PRUint32 i;
63900:     PRUint32 numTables = sfntHeader->numTables;
63900:     const TableDirEntry *dirEntry = 
63900:         reinterpret_cast<const TableDirEntry*>(aFontData + sizeof(SFNTHeader));
63900:     hasVertical = PR_FALSE;
63900:     for (i = 0; i < numTables; i++, dirEntry++) {
63900:         if (dirEntry->tag == TRUETYPE_TAG('v','h','e','a')) {
63900:             hasVertical = PR_TRUE;
63900:             break;
63900:         }
63900:     }
63900: 
32808:     return (sfntHeader->sfntVersion == TRUETYPE_TAG('O','T','T','O'));
32808: }
32808: 
30824: #endif
