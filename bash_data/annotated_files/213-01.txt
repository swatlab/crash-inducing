  1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
  1:  * vim: set sw=4 ts=8 et tw=78:
  1:  *
  1:  * ***** BEGIN LICENSE BLOCK *****
  1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  1:  *
  1:  * The contents of this file are subject to the Mozilla Public License Version
  1:  * 1.1 (the "License"); you may not use this file except in compliance with
  1:  * the License. You may obtain a copy of the License at
  1:  * http://www.mozilla.org/MPL/
  1:  *
  1:  * Software distributed under the License is distributed on an "AS IS" basis,
  1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  1:  * for the specific language governing rights and limitations under the
  1:  * License.
  1:  *
  1:  * The Original Code is Mozilla Communicator client code, released
  1:  * March 31, 1998.
  1:  *
  1:  * The Initial Developer of the Original Code is
  1:  * Netscape Communications Corporation.
  1:  * Portions created by the Initial Developer are Copyright (C) 1998
  1:  * the Initial Developer. All Rights Reserved.
  1:  *
  1:  * Contributor(s):
  1:  *
  1:  * Alternatively, the contents of this file may be used under the terms of
  1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
  1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  1:  * in which case the provisions of the GPL or the LGPL are applicable instead
  1:  * of those above. If you wish to allow use of your version of this file only
  1:  * under the terms of either the GPL or the LGPL, and not to allow others to
  1:  * use your version of this file under the terms of the MPL, indicate your
  1:  * decision by deleting the provisions above and replace them with the notice
  1:  * and other provisions required by the GPL or the LGPL. If you do not delete
  1:  * the provisions above, a recipient may use your version of this file under
  1:  * the terms of any one of the MPL, the GPL or the LGPL.
  1:  *
  1:  * ***** END LICENSE BLOCK ***** */
  1: 
  1: /*
  1:  * JS regular expressions, after Perl.
  1:  */
  1: #include "jsstddef.h"
  1: #include <stdlib.h>
  1: #include <string.h>
 22: #include <stdarg.h>
  1: #include "jstypes.h"
  1: #include "jsarena.h" /* Added by JSIFY */
  1: #include "jsutil.h" /* Added by JSIFY */
  1: #include "jsapi.h"
  1: #include "jsarray.h"
  1: #include "jsatom.h"
  1: #include "jscntxt.h"
  1: #include "jsconfig.h"
  1: #include "jsfun.h"
  1: #include "jsgc.h"
  1: #include "jsinterp.h"
  1: #include "jslock.h"
  1: #include "jsnum.h"
  1: #include "jsobj.h"
  1: #include "jsopcode.h"
  1: #include "jsregexp.h"
  1: #include "jsscan.h"
  1: #include "jsstr.h"
  1: 
  1: typedef enum REOp {
 22: #define REOP_DEF(opcode, name) opcode,
 22: #include "jsreops.tbl"
 22: #undef REOP_DEF
  1: } REOp;
  1: 
  1: #define REOP_IS_SIMPLE(op)  ((op) <= (unsigned)REOP_NCLASS)
  1: 
170: #ifdef REGEXP_DEBUG 
 22: const char *reop_names[] = {
 22: #define REOP_DEF(opcode, name) name,
 22: #include "jsreops.tbl"
 22: #undef REOP_DEF
 22:     NULL
 22: };
 22: #endif
 22: 
 22: #ifdef __GNUC__
 22: static int
 22: re_debug(const char *fmt, ...) __attribute__ ((format(printf, 1, 2)));
 22: #endif
 22: 
 22: #ifdef REGEXP_DEBUG
 22: static int
 22: re_debug(const char *fmt, ...)
 22: {
 22:     va_list ap;
 22:     int retval;
 22: 
 22:     va_start(ap, fmt);
 22:     retval = vprintf(fmt, ap);
 22:     va_end(ap);
 22:     return retval;
 22: }
 22: 
 22: static void
 22: re_debug_chars(const jschar *chrs, size_t length)
 22: {
 22:     int i = 0;
 22: 
 22:     printf(" \"");
 22:     while (*chrs && i++ < length) {
 22:         putchar((char)*chrs++);
 22:     }
 22:     printf("\"");
 22: }
 22: #else  /* !REGEXP_DEBUG */
 22: /* This should be optimized to a no-op by our tier-1 compilers. */
 22: static int
 22: re_debug(const char *fmt, ...)
 22: {
 22:     return 0;
 22: }
 22: 
 22: static void
 22: re_debug_chars(const jschar *chrs, size_t length)
 22: {
 22: }
 22: #endif /* !REGEXP_DEBUG */
 22: 
  1: struct RENode {
  1:     REOp            op;         /* r.e. op bytecode */
  1:     RENode          *next;      /* next in concatenation order */
  1:     void            *kid;       /* first operand */
  1:     union {
  1:         void        *kid2;      /* second operand */
  1:         jsint       num;        /* could be a number */
  1:         size_t      parenIndex; /* or a parenthesis index */
  1:         struct {                /* or a quantifier range */
  1:             uintN  min;
  1:             uintN  max;
  1:             JSPackedBool greedy;
  1:         } range;
  1:         struct {                /* or a character class */
  1:             size_t  startIndex;
  1:             size_t  kidlen;     /* length of string at kid, in jschars */
  1:             size_t  index;      /* index into class list */
  1:             uint16  bmsize;     /* bitmap size, based on max char code */
  1:             JSPackedBool sense;
  1:         } ucclass;
  1:         struct {                /* or a literal sequence */
  1:             jschar  chr;        /* of one character */
  1:             size_t  length;     /* or many (via the kid) */
  1:         } flat;
  1:         struct {
  1:             RENode  *kid2;      /* second operand from ALT */
  1:             jschar  ch1;        /* match char for ALTPREREQ */
  1:             jschar  ch2;        /* ditto, or class index for ALTPREREQ2 */
  1:         } altprereq;
  1:     } u;
  1: };
  1: 
  1: #define RE_IS_LETTER(c)     (((c >= 'A') && (c <= 'Z')) ||                    \
  1:                              ((c >= 'a') && (c <= 'z')) )
  1: #define RE_IS_LINE_TERM(c)  ((c == '\n') || (c == '\r') ||                    \
  1:                              (c == LINE_SEPARATOR) || (c == PARA_SEPARATOR))
  1: 
  1: #define CLASS_CACHE_SIZE    4
  1: 
  1: typedef struct CompilerState {
  1:     JSContext       *context;
  1:     JSTokenStream   *tokenStream; /* For reporting errors */
  1:     const jschar    *cpbegin;
  1:     const jschar    *cpend;
  1:     const jschar    *cp;
  1:     size_t          parenCount;
  1:     size_t          classCount;   /* number of [] encountered */
  1:     size_t          treeDepth;    /* maximum depth of parse tree */
  1:     size_t          progLength;   /* estimated bytecode length */
  1:     RENode          *result;
  1:     size_t          classBitmapsMem; /* memory to hold all class bitmaps */
  1:     struct {
  1:         const jschar *start;        /* small cache of class strings */
  1:         size_t length;              /* since they're often the same */
  1:         size_t index;
  1:     } classCache[CLASS_CACHE_SIZE];
  1:     uint16          flags;
  1: } CompilerState;
  1: 
  1: typedef struct EmitStateStackEntry {
  1:     jsbytecode      *altHead;       /* start of REOP_ALT* opcode */
  1:     jsbytecode      *nextAltFixup;  /* fixup pointer to next-alt offset */
  1:     jsbytecode      *nextTermFixup; /* fixup ptr. to REOP_JUMP offset */
  1:     jsbytecode      *endTermFixup;  /* fixup ptr. to REOPT_ALTPREREQ* offset */
  1:     RENode          *continueNode;  /* original REOP_ALT* node being stacked */
  1:     jsbytecode      continueOp;     /* REOP_JUMP or REOP_ENDALT continuation */
  1:     JSPackedBool    jumpToJumpFlag; /* true if we've patched jump-to-jump to
  1:                                        avoid 16-bit unsigned offset overflow */
  1: } EmitStateStackEntry;
  1: 
  1: /*
  1:  * Immediate operand sizes and getter/setters.  Unlike the ones in jsopcode.h,
  1:  * the getters and setters take the pc of the offset, not of the opcode before
  1:  * the offset.
  1:  */
  1: #define ARG_LEN             2
  1: #define GET_ARG(pc)         ((uint16)(((pc)[0] << 8) | (pc)[1]))
  1: #define SET_ARG(pc, arg)    ((pc)[0] = (jsbytecode) ((arg) >> 8),       \
  1:                              (pc)[1] = (jsbytecode) (arg))
  1: 
  1: #define OFFSET_LEN          ARG_LEN
  1: #define OFFSET_MAX          (JS_BIT(ARG_LEN * 8) - 1)
  1: #define GET_OFFSET(pc)      GET_ARG(pc)
  1: 
  1: /*
  1:  * Maximum supported tree depth is maximum size of EmitStateStackEntry stack.
  1:  * For sanity, we limit it to 2^24 bytes.
  1:  */
  1: #define TREE_DEPTH_MAX  (JS_BIT(24) / sizeof(EmitStateStackEntry))
  1: 
  1: /*
  1:  * The maximum memory that can be allocated for class bitmaps.
  1:  * For sanity, we limit it to 2^24 bytes.
  1:  */
  1: #define CLASS_BITMAPS_MEM_LIMIT JS_BIT(24)
  1: 
  1: /*
  1:  * Functions to get size and write/read bytecode that represent small indexes
  1:  * compactly.
  1:  * Each byte in the code represent 7-bit chunk of the index. 8th bit when set
  1:  * indicates that the following byte brings more bits to the index. Otherwise
  1:  * this is the last byte in the index bytecode representing highest index bits.
  1:  */
  1: static size_t
  1: GetCompactIndexWidth(size_t index)
  1: {
  1:     size_t width;
  1: 
  1:     for (width = 1; (index >>= 7) != 0; ++width) { }
  1:     return width;
  1: }
  1: 
  1: static jsbytecode *
  1: WriteCompactIndex(jsbytecode *pc, size_t index)
  1: {
  1:     size_t next;
  1: 
  1:     while ((next = index >> 7) != 0) {
  1:         *pc++ = (jsbytecode)(index | 0x80);
  1:         index = next;
  1:     }
  1:     *pc++ = (jsbytecode)index;
  1:     return pc;
  1: }
  1: 
  1: static jsbytecode *
  1: ReadCompactIndex(jsbytecode *pc, size_t *result)
  1: {
  1:     size_t nextByte;
  1: 
  1:     nextByte = *pc++;
  1:     if ((nextByte & 0x80) == 0) {
  1:         /*
  1:          * Short-circuit the most common case when compact index <= 127.
  1:          */
  1:         *result = nextByte;
  1:     } else {
  1:         size_t shift = 7;
  1:         *result = 0x7F & nextByte;
  1:         do {
  1:             nextByte = *pc++;
  1:             *result |= (nextByte & 0x7F) << shift;
  1:             shift += 7;
  1:         } while ((nextByte & 0x80) != 0);
  1:     }
  1:     return pc;
  1: }
  1: 
  1: typedef struct RECapture {
  1:     ptrdiff_t index;           /* start of contents, -1 for empty  */
  1:     size_t length;             /* length of capture */
  1: } RECapture;
  1: 
  1: typedef struct REMatchState {
  1:     const jschar *cp;
  1:     RECapture parens[1];      /* first of 're->parenCount' captures,
  1:                                  allocated at end of this struct */
  1: } REMatchState;
  1: 
  1: struct REBackTrackData;
  1: 
  1: typedef struct REProgState {
  1:     jsbytecode *continue_pc;        /* current continuation data */
  1:     jsbytecode continue_op;
  1:     ptrdiff_t index;                /* progress in text */
  1:     size_t parenSoFar;              /* highest indexed paren started */
  1:     union {
  1:         struct {
  1:             uintN min;             /* current quantifier limits */
  1:             uintN max;
  1:         } quantifier;
  1:         struct {
  1:             size_t top;             /* backtrack stack state */
  1:             size_t sz;
  1:         } assertion;
  1:     } u;
  1: } REProgState;
  1: 
  1: typedef struct REBackTrackData {
  1:     size_t sz;                      /* size of previous stack entry */
  1:     jsbytecode *backtrack_pc;       /* where to backtrack to */
  1:     jsbytecode backtrack_op;
  1:     const jschar *cp;               /* index in text of match at backtrack */
  1:     size_t parenIndex;              /* start index of saved paren contents */
  1:     size_t parenCount;              /* # of saved paren contents */
  1:     size_t saveStateStackTop;       /* number of parent states */
  1:     /* saved parent states follow */
  1:     /* saved paren contents follow */
  1: } REBackTrackData;
  1: 
  1: #define INITIAL_STATESTACK  100
  1: #define INITIAL_BACKTRACK   8000
  1: 
  1: typedef struct REGlobalData {
  1:     JSContext *cx;
  1:     JSRegExp *regexp;               /* the RE in execution */
  1:     JSBool ok;                      /* runtime error (out_of_memory only?) */
  1:     size_t start;                   /* offset to start at */
  1:     ptrdiff_t skipped;              /* chars skipped anchoring this r.e. */
  1:     const jschar    *cpbegin;       /* text base address */
  1:     const jschar    *cpend;         /* text limit address */
  1: 
  1:     REProgState *stateStack;        /* stack of state of current parents */
  1:     size_t stateStackTop;
  1:     size_t stateStackLimit;
  1: 
  1:     REBackTrackData *backTrackStack;/* stack of matched-so-far positions */
  1:     REBackTrackData *backTrackSP;
  1:     size_t backTrackStackSize;
  1:     size_t cursz;                   /* size of current stack entry */
  1:     size_t backTrackCount;          /* how many times we've backtracked */
  1:     size_t backTrackLimit;          /* upper limit on backtrack states */
  1: 
  1:     JSArenaPool     pool;           /* It's faster to use one malloc'd pool
  1:                                        than to malloc/free the three items
  1:                                        that are allocated from this pool */
  1: } REGlobalData;
  1: 
  1: /*
  1:  * 1. If IgnoreCase is false, return ch.
  1:  * 2. Let u be ch converted to upper case as if by calling
  1:  *    String.prototype.toUpperCase on the one-character string ch.
  1:  * 3. If u does not consist of a single character, return ch.
  1:  * 4. Let cu be u's character.
  1:  * 5. If ch's code point value is greater than or equal to decimal 128 and cu's
  1:  *    code point value is less than decimal 128, then return ch.
  1:  * 6. Return cu.
  1:  */
  1: static jschar
  1: upcase(jschar ch)
  1: {
  1:     jschar cu = JS_TOUPPER(ch);
  1:     if (ch >= 128 && cu < 128)
  1:         return ch;
  1:     return cu;
  1: }
  1: 
  1: static jschar
  1: downcase(jschar ch)
  1: {
  1:     jschar cl = JS_TOLOWER(ch);
  1:     if (cl >= 128 && ch < 128)
  1:         return ch;
  1:     return cl;
  1: }
  1: 
  1: /* Construct and initialize an RENode, returning NULL for out-of-memory */
  1: static RENode *
  1: NewRENode(CompilerState *state, REOp op)
  1: {
  1:     JSContext *cx;
  1:     RENode *ren;
  1: 
  1:     cx = state->context;
  1:     JS_ARENA_ALLOCATE_CAST(ren, RENode *, &cx->tempPool, sizeof *ren);
  1:     if (!ren) {
  1:         JS_ReportOutOfMemory(cx);
  1:         return NULL;
  1:     }
  1:     ren->op = op;
  1:     ren->next = NULL;
  1:     ren->kid = NULL;
  1:     return ren;
  1: }
  1: 
  1: /*
  1:  * Validates and converts hex ascii value.
  1:  */
  1: static JSBool
  1: isASCIIHexDigit(jschar c, uintN *digit)
  1: {
  1:     uintN cv = c;
  1: 
  1:     if (cv < '0')
  1:         return JS_FALSE;
  1:     if (cv <= '9') {
  1:         *digit = cv - '0';
  1:         return JS_TRUE;
  1:     }
  1:     cv |= 0x20;
  1:     if (cv >= 'a' && cv <= 'f') {
  1:         *digit = cv - 'a' + 10;
  1:         return JS_TRUE;
  1:     }
  1:     return JS_FALSE;
  1: }
  1: 
  1: 
  1: typedef struct {
  1:     REOp op;
  1:     const jschar *errPos;
  1:     size_t parenIndex;
  1: } REOpData;
  1: 
  1: 
  1: /*
  1:  * Process the op against the two top operands, reducing them to a single
  1:  * operand in the penultimate slot. Update progLength and treeDepth.
  1:  */
  1: static JSBool
  1: ProcessOp(CompilerState *state, REOpData *opData, RENode **operandStack,
  1:           intN operandSP)
  1: {
  1:     RENode *result;
  1: 
  1:     switch (opData->op) {
  1:       case REOP_ALT:
  1:         result = NewRENode(state, REOP_ALT);
  1:         if (!result)
  1:             return JS_FALSE;
  1:         result->kid = operandStack[operandSP - 2];
  1:         result->u.kid2 = operandStack[operandSP - 1];
  1:         operandStack[operandSP - 2] = result;
  1: 
  1:         if (state->treeDepth == TREE_DEPTH_MAX) {
  1:             js_ReportCompileErrorNumber(state->context, state->tokenStream,
  1:                                         JSREPORT_TS | JSREPORT_ERROR,
  1:                                         JSMSG_REGEXP_TOO_COMPLEX);
  1:             return JS_FALSE;
  1:         }
  1:         ++state->treeDepth;
  1: 
  1:         /*
  1:          * Look at both alternates to see if there's a FLAT or a CLASS at
  1:          * the start of each. If so, use a prerequisite match.
  1:          */
  1:         if (((RENode *) result->kid)->op == REOP_FLAT &&
  1:             ((RENode *) result->u.kid2)->op == REOP_FLAT &&
  1:             (state->flags & JSREG_FOLD) == 0) {
  1:             result->op = REOP_ALTPREREQ;
  1:             result->u.altprereq.ch1 = ((RENode *) result->kid)->u.flat.chr;
  1:             result->u.altprereq.ch2 = ((RENode *) result->u.kid2)->u.flat.chr;
  1:             /* ALTPREREQ, <end>, uch1, uch2, <next>, ...,
  1:                                             JUMP, <end> ... ENDALT */
  1:             state->progLength += 13;
  1:         }
  1:         else
  1:         if (((RENode *) result->kid)->op == REOP_CLASS &&
  1:             ((RENode *) result->kid)->u.ucclass.index < 256 &&
  1:             ((RENode *) result->u.kid2)->op == REOP_FLAT &&
  1:             (state->flags & JSREG_FOLD) == 0) {
  1:             result->op = REOP_ALTPREREQ2;
  1:             result->u.altprereq.ch1 = ((RENode *) result->u.kid2)->u.flat.chr;
  1:             result->u.altprereq.ch2 = ((RENode *) result->kid)->u.ucclass.index;
  1:             /* ALTPREREQ2, <end>, uch1, uch2, <next>, ...,
  1:                                             JUMP, <end> ... ENDALT */
  1:             state->progLength += 13;
  1:         }
  1:         else
  1:         if (((RENode *) result->kid)->op == REOP_FLAT &&
  1:             ((RENode *) result->u.kid2)->op == REOP_CLASS &&
  1:             ((RENode *) result->u.kid2)->u.ucclass.index < 256 &&
  1:             (state->flags & JSREG_FOLD) == 0) {
  1:             result->op = REOP_ALTPREREQ2;
  1:             result->u.altprereq.ch1 = ((RENode *) result->kid)->u.flat.chr;
  1:             result->u.altprereq.ch2 =
  1:                 ((RENode *) result->u.kid2)->u.ucclass.index;
  1:             /* ALTPREREQ2, <end>, uch1, uch2, <next>, ...,
  1:                                           JUMP, <end> ... ENDALT */
  1:             state->progLength += 13;
  1:         }
  1:         else {
  1:             /* ALT, <next>, ..., JUMP, <end> ... ENDALT */
  1:             state->progLength += 7;
  1:         }
  1:         break;
  1: 
  1:       case REOP_CONCAT:
  1:         result = operandStack[operandSP - 2];
  1:         while (result->next)
  1:             result = result->next;
  1:         result->next = operandStack[operandSP - 1];
  1:         break;
  1: 
  1:       case REOP_ASSERT:
  1:       case REOP_ASSERT_NOT:
  1:       case REOP_LPARENNON:
  1:       case REOP_LPAREN:
  1:         /* These should have been processed by a close paren. */
  1:         js_ReportCompileErrorNumberUC(state->context, state->tokenStream,
  1:                                       JSREPORT_TS | JSREPORT_ERROR,
  1:                                       JSMSG_MISSING_PAREN, opData->errPos);
  1:         return JS_FALSE;
  1: 
  1:       default:;
  1:     }
  1:     return JS_TRUE;
  1: }
  1: 
  1: /*
  1:  * Parser forward declarations.
  1:  */
  1: static JSBool ParseTerm(CompilerState *state);
  1: static JSBool ParseQuantifier(CompilerState *state);
  1: static intN ParseMinMaxQuantifier(CompilerState *state, JSBool ignoreValues);
  1: 
  1: /*
  1:  * Top-down regular expression grammar, based closely on Perl4.
  1:  *
  1:  *  regexp:     altern                  A regular expression is one or more
  1:  *              altern '|' regexp       alternatives separated by vertical bar.
  1:  */
  1: #define INITIAL_STACK_SIZE  128
  1: 
  1: static JSBool
  1: ParseRegExp(CompilerState *state)
  1: {
  1:     size_t parenIndex;
  1:     RENode *operand;
  1:     REOpData *operatorStack;
  1:     RENode **operandStack;
  1:     REOp op;
  1:     intN i;
  1:     JSBool result = JS_FALSE;
  1: 
  1:     intN operatorSP = 0, operatorStackSize = INITIAL_STACK_SIZE;
  1:     intN operandSP = 0, operandStackSize = INITIAL_STACK_SIZE;
  1: 
  1:     /* Watch out for empty regexp */
  1:     if (state->cp == state->cpend) {
  1:         state->result = NewRENode(state, REOP_EMPTY);
  1:         return (state->result != NULL);
  1:     }
  1: 
  1:     operatorStack = (REOpData *)
  1:         JS_malloc(state->context, sizeof(REOpData) * operatorStackSize);
  1:     if (!operatorStack)
  1:         return JS_FALSE;
  1: 
  1:     operandStack = (RENode **)
  1:         JS_malloc(state->context, sizeof(RENode *) * operandStackSize);
  1:     if (!operandStack)
  1:         goto out;
  1: 
  1:     for (;;) {
  1:         parenIndex = state->parenCount;
  1:         if (state->cp == state->cpend) {
  1:             /*
  1:              * If we are at the end of the regexp and we're short one or more
  1:              * operands, the regexp must have the form /x|/ or some such, with
  1:              * left parentheses making us short more than one operand.
  1:              */
  1:             if (operatorSP >= operandSP) {
  1:                 operand = NewRENode(state, REOP_EMPTY);
  1:                 if (!operand)
  1:                     goto out;
  1:                 goto pushOperand;
  1:             }
  1:         } else {
  1:             switch (*state->cp) {
  1:               case '(':
  1:                 ++state->cp;
  1:                 if (state->cp + 1 < state->cpend &&
  1:                     *state->cp == '?' &&
  1:                     (state->cp[1] == '=' ||
  1:                      state->cp[1] == '!' ||
  1:                      state->cp[1] == ':')) {
  1:                     switch (state->cp[1]) {
  1:                       case '=':
  1:                         op = REOP_ASSERT;
  1:                         /* ASSERT, <next>, ... ASSERTTEST */
  1:                         state->progLength += 4;
  1:                         break;
  1:                       case '!':
  1:                         op = REOP_ASSERT_NOT;
  1:                         /* ASSERTNOT, <next>, ... ASSERTNOTTEST */
  1:                         state->progLength += 4;
  1:                         break;
  1:                       default:
  1:                         op = REOP_LPARENNON;
  1:                         break;
  1:                     }
  1:                     state->cp += 2;
  1:                 } else {
  1:                     op = REOP_LPAREN;
  1:                     /* LPAREN, <index>, ... RPAREN, <index> */
  1:                     state->progLength
  1:                         += 2 * (1 + GetCompactIndexWidth(parenIndex));
  1:                     state->parenCount++;
  1:                     if (state->parenCount == 65535) {
  1:                         js_ReportCompileErrorNumber(state->context,
  1:                                                     state->tokenStream,
  1:                                                     JSREPORT_TS |
  1:                                                     JSREPORT_ERROR,
  1:                                                     JSMSG_TOO_MANY_PARENS);
  1:                         goto out;
  1:                     }
  1:                 }
  1:                 goto pushOperator;
  1: 
  1:               case ')':
  1:                 /*
  1:                  * If there's no stacked open parenthesis, throw syntax error.
  1:                  */
  1:                 for (i = operatorSP - 1; ; i--) {
  1:                     if (i < 0) {
  1:                         js_ReportCompileErrorNumber(state->context,
  1:                                                     state->tokenStream,
  1:                                                     JSREPORT_TS |
  1:                                                     JSREPORT_ERROR,
  1:                                                     JSMSG_UNMATCHED_RIGHT_PAREN);
  1:                         goto out;
  1:                     }
  1:                     if (operatorStack[i].op == REOP_ASSERT ||
  1:                         operatorStack[i].op == REOP_ASSERT_NOT ||
  1:                         operatorStack[i].op == REOP_LPARENNON ||
  1:                         operatorStack[i].op == REOP_LPAREN) {
  1:                         break;
  1:                     }
  1:                 }
  1:                 /* FALL THROUGH */
  1: 
  1:               case '|':
  1:                 /* Expected an operand before these, so make an empty one */
  1:                 operand = NewRENode(state, REOP_EMPTY);
  1:                 if (!operand)
  1:                     goto out;
  1:                 goto pushOperand;
  1: 
  1:               default:
  1:                 if (!ParseTerm(state))
  1:                     goto out;
  1:                 operand = state->result;
  1: pushOperand:
  1:                 if (operandSP == operandStackSize) {
  1:                     operandStackSize += operandStackSize;
  1:                     operandStack = (RENode **)
  1:                         JS_realloc(state->context, operandStack,
  1:                                    sizeof(RENode *) * operandStackSize);
  1:                     if (!operandStack)
  1:                         goto out;
  1:                 }
  1:                 operandStack[operandSP++] = operand;
  1:                 break;
  1:             }
  1:         }
  1: 
  1:         /* At the end; process remaining operators. */
  1: restartOperator:
  1:         if (state->cp == state->cpend) {
  1:             while (operatorSP) {
  1:                 --operatorSP;
  1:                 if (!ProcessOp(state, &operatorStack[operatorSP],
  1:                                operandStack, operandSP))
  1:                     goto out;
  1:                 --operandSP;
  1:             }
  1:             JS_ASSERT(operandSP == 1);
  1:             state->result = operandStack[0];
  1:             result = JS_TRUE;
  1:             goto out;
  1:         }
  1: 
  1:         switch (*state->cp) {
  1:           case '|':
  1:             /* Process any stacked 'concat' operators */
  1:             ++state->cp;
  1:             while (operatorSP &&
  1:                    operatorStack[operatorSP - 1].op == REOP_CONCAT) {
  1:                 --operatorSP;
  1:                 if (!ProcessOp(state, &operatorStack[operatorSP],
  1:                                operandStack, operandSP)) {
  1:                     goto out;
  1:                 }
  1:                 --operandSP;
  1:             }
  1:             op = REOP_ALT;
  1:             goto pushOperator;
  1: 
  1:           case ')':
  1:             /*
  1:              * If there's no stacked open parenthesis, throw syntax error.
  1:              */
  1:             for (i = operatorSP - 1; ; i--) {
  1:                 if (i < 0) {
  1:                     js_ReportCompileErrorNumber(state->context,
  1:                                                 state->tokenStream,
  1:                                                 JSREPORT_TS | JSREPORT_ERROR,
  1:                                                 JSMSG_UNMATCHED_RIGHT_PAREN);
  1:                     goto out;
  1:                 }
  1:                 if (operatorStack[i].op == REOP_ASSERT ||
  1:                     operatorStack[i].op == REOP_ASSERT_NOT ||
  1:                     operatorStack[i].op == REOP_LPARENNON ||
  1:                     operatorStack[i].op == REOP_LPAREN) {
  1:                     break;
  1:                 }
  1:             }
  1:             ++state->cp;
  1: 
  1:             /* Process everything on the stack until the open parenthesis. */
  1:             for (;;) {
  1:                 JS_ASSERT(operatorSP);
  1:                 --operatorSP;
  1:                 switch (operatorStack[operatorSP].op) {
  1:                   case REOP_ASSERT:
  1:                   case REOP_ASSERT_NOT:
  1:                   case REOP_LPAREN:
  1:                     operand = NewRENode(state, operatorStack[operatorSP].op);
  1:                     if (!operand)
  1:                         goto out;
  1:                     operand->u.parenIndex =
  1:                         operatorStack[operatorSP].parenIndex;
  1:                     JS_ASSERT(operandSP);
  1:                     operand->kid = operandStack[operandSP - 1];
  1:                     operandStack[operandSP - 1] = operand;
  1:                     if (state->treeDepth == TREE_DEPTH_MAX) {
  1:                         js_ReportCompileErrorNumber(state->context,
  1:                                                     state->tokenStream,
  1:                                                     JSREPORT_TS |
  1:                                                     JSREPORT_ERROR,
  1:                                                     JSMSG_REGEXP_TOO_COMPLEX);
  1:                         goto out;
  1:                     }
  1:                     ++state->treeDepth;
  1:                     /* FALL THROUGH */
  1: 
  1:                   case REOP_LPARENNON:
  1:                     state->result = operandStack[operandSP - 1];
  1:                     if (!ParseQuantifier(state))
  1:                         goto out;
  1:                     operandStack[operandSP - 1] = state->result;
  1:                     goto restartOperator;
  1:                   default:
  1:                     if (!ProcessOp(state, &operatorStack[operatorSP],
  1:                                    operandStack, operandSP))
  1:                         goto out;
  1:                     --operandSP;
  1:                     break;
  1:                 }
  1:             }
  1:             break;
  1: 
  1:           case '{':
  1:           {
  1:             const jschar *errp = state->cp;
  1: 
  1:             if (ParseMinMaxQuantifier(state, JS_TRUE) < 0) {
  1:                 /*
  1:                  * This didn't even scan correctly as a quantifier, so we should
  1:                  * treat it as flat.
  1:                  */
  1:                 op = REOP_CONCAT;
  1:                 goto pushOperator;
  1:             }
  1: 
  1:             state->cp = errp;
  1:             /* FALL THROUGH */
  1:           }
  1: 
  1:           case '+':
  1:           case '*':
  1:           case '?':
  1:             js_ReportCompileErrorNumberUC(state->context, state->tokenStream,
  1:                                           JSREPORT_TS | JSREPORT_ERROR,
  1:                                           JSMSG_BAD_QUANTIFIER, state->cp);
  1:             result = JS_FALSE;
  1:             goto out;
  1: 
  1:           default:
  1:             /* Anything else is the start of the next term. */
  1:             op = REOP_CONCAT;
  1: pushOperator:
  1:             if (operatorSP == operatorStackSize) {
  1:                 operatorStackSize += operatorStackSize;
  1:                 operatorStack = (REOpData *)
  1:                     JS_realloc(state->context, operatorStack,
  1:                                sizeof(REOpData) * operatorStackSize);
  1:                 if (!operatorStack)
  1:                     goto out;
  1:             }
  1:             operatorStack[operatorSP].op = op;
  1:             operatorStack[operatorSP].errPos = state->cp;
  1:             operatorStack[operatorSP++].parenIndex = parenIndex;
  1:             break;
  1:         }
  1:     }
  1: out:
  1:     if (operatorStack)
  1:         JS_free(state->context, operatorStack);
  1:     if (operandStack)
  1:         JS_free(state->context, operandStack);
  1:     return result;
  1: }
  1: 
  1: /*
  1:  * Hack two bits in CompilerState.flags, for use within FindParenCount to flag
  1:  * its being on the stack, and to propagate errors to its callers.
  1:  */
  1: #define JSREG_FIND_PAREN_COUNT  0x8000
  1: #define JSREG_FIND_PAREN_ERROR  0x4000
  1: 
  1: /*
  1:  * Magic return value from FindParenCount and GetDecimalValue, to indicate
  1:  * overflow beyond GetDecimalValue's max parameter, or a computed maximum if
  1:  * its findMax parameter is non-null.
  1:  */
  1: #define OVERFLOW_VALUE          ((uintN)-1)
  1: 
  1: static uintN
  1: FindParenCount(CompilerState *state)
  1: {
  1:     CompilerState temp;
  1:     int i;
  1: 
  1:     if (state->flags & JSREG_FIND_PAREN_COUNT)
  1:         return OVERFLOW_VALUE;
  1: 
  1:     /*
  1:      * Copy state into temp, flag it so we never report an invalid backref,
  1:      * and reset its members to parse the entire regexp.  This is obviously
  1:      * suboptimal, but GetDecimalValue calls us only if a backref appears to
  1:      * refer to a forward parenthetical, which is rare.
  1:      */
  1:     temp = *state;
  1:     temp.flags |= JSREG_FIND_PAREN_COUNT;
  1:     temp.cp = temp.cpbegin;
  1:     temp.parenCount = 0;
  1:     temp.classCount = 0;
  1:     temp.progLength = 0;
  1:     temp.treeDepth = 0;
  1:     temp.classBitmapsMem = 0;
  1:     for (i = 0; i < CLASS_CACHE_SIZE; i++)
  1:         temp.classCache[i].start = NULL;
  1: 
  1:     if (!ParseRegExp(&temp)) {
  1:         state->flags |= JSREG_FIND_PAREN_ERROR;
  1:         return OVERFLOW_VALUE;
  1:     }
  1:     return temp.parenCount;
  1: }
  1: 
  1: /*
  1:  * Extract and return a decimal value at state->cp.  The initial character c
  1:  * has already been read.  Return OVERFLOW_VALUE if the result exceeds max.
  1:  * Callers who pass a non-null findMax should test JSREG_FIND_PAREN_ERROR in
  1:  * state->flags to discover whether an error occurred under findMax.
  1:  */
  1: static uintN
  1: GetDecimalValue(jschar c, uintN max, uintN (*findMax)(CompilerState *state),
  1:                 CompilerState *state)
  1: {
  1:     uintN value = JS7_UNDEC(c);
  1:     JSBool overflow = (value > max && (!findMax || value > findMax(state)));
  1: 
  1:     /* The following restriction allows simpler overflow checks. */
  1:     JS_ASSERT(max <= ((uintN)-1 - 9) / 10);
  1:     while (state->cp < state->cpend) {
  1:         c = *state->cp;
  1:         if (!JS7_ISDEC(c))
  1:             break;
  1:         value = 10 * value + JS7_UNDEC(c);
  1:         if (!overflow && value > max && (!findMax || value > findMax(state)))
  1:             overflow = JS_TRUE;
  1:         ++state->cp;
  1:     }
  1:     return overflow ? OVERFLOW_VALUE : value;
  1: }
  1: 
  1: /*
  1:  * Calculate the total size of the bitmap required for a class expression.
  1:  */
  1: static JSBool
  1: CalculateBitmapSize(CompilerState *state, RENode *target, const jschar *src,
  1:                     const jschar *end)
  1: {
  1:     uintN max = 0;
  1:     JSBool inRange = JS_FALSE;
  1:     jschar c, rangeStart = 0;
  1:     uintN n, digit, nDigits, i;
  1: 
  1:     target->u.ucclass.bmsize = 0;
  1:     target->u.ucclass.sense = JS_TRUE;
  1: 
  1:     if (src == end)
  1:         return JS_TRUE;
  1: 
  1:     if (*src == '^') {
  1:         ++src;
  1:         target->u.ucclass.sense = JS_FALSE;
  1:     }
  1: 
  1:     while (src != end) {
  1:         uintN localMax = 0;
  1:         switch (*src) {
  1:           case '\\':
  1:             ++src;
  1:             c = *src++;
  1:             switch (c) {
  1:               case 'b':
  1:                 localMax = 0x8;
  1:                 break;
  1:               case 'f':
  1:                 localMax = 0xC;
  1:                 break;
  1:               case 'n':
  1:                 localMax = 0xA;
  1:                 break;
  1:               case 'r':
  1:                 localMax = 0xD;
  1:                 break;
  1:               case 't':
  1:                 localMax = 0x9;
  1:                 break;
  1:               case 'v':
  1:                 localMax = 0xB;
  1:                 break;
  1:               case 'c':
  1:                 if (src < end && RE_IS_LETTER(*src)) {
  1:                     localMax = (jschar) (*src++ & 0x1F);
  1:                 } else {
  1:                     --src;
  1:                     localMax = '\\';
  1:                 }
  1:                 break;
  1:               case 'x':
  1:                 nDigits = 2;
  1:                 goto lexHex;
  1:               case 'u':
  1:                 nDigits = 4;
  1: lexHex:
  1:                 n = 0;
  1:                 for (i = 0; (i < nDigits) && (src < end); i++) {
  1:                     c = *src++;
  1:                     if (!isASCIIHexDigit(c, &digit)) {
  1:                         /*
  1:                          * Back off to accepting the original
  1:                          *'\' as a literal.
  1:                          */
  1:                         src -= i + 1;
  1:                         n = '\\';
  1:                         break;
  1:                     }
  1:                     n = (n << 4) | digit;
  1:                 }
  1:                 localMax = n;
  1:                 break;
  1:               case 'd':
  1:                 if (inRange) {
  1:                     JS_ReportErrorNumber(state->context,
  1:                                          js_GetErrorMessage, NULL,
  1:                                          JSMSG_BAD_CLASS_RANGE);
  1:                     return JS_FALSE;
  1:                 }
  1:                 localMax = '9';
  1:                 break;
  1:               case 'D':
  1:               case 's':
  1:               case 'S':
  1:               case 'w':
  1:               case 'W':
  1:                 if (inRange) {
  1:                     JS_ReportErrorNumber(state->context,
  1:                                          js_GetErrorMessage, NULL,
  1:                                          JSMSG_BAD_CLASS_RANGE);
  1:                     return JS_FALSE;
  1:                 }
212:                 localMax = 65535;
212:                 break;
  1:               case '0':
  1:               case '1':
  1:               case '2':
  1:               case '3':
  1:               case '4':
  1:               case '5':
  1:               case '6':
  1:               case '7':
  1:                 /*
  1:                  *  This is a non-ECMA extension - decimal escapes (in this
  1:                  *  case, octal!) are supposed to be an error inside class
  1:                  *  ranges, but supported here for backwards compatibility.
  1:                  *
  1:                  */
  1:                 n = JS7_UNDEC(c);
  1:                 c = *src;
  1:                 if ('0' <= c && c <= '7') {
  1:                     src++;
  1:                     n = 8 * n + JS7_UNDEC(c);
  1:                     c = *src;
  1:                     if ('0' <= c && c <= '7') {
  1:                         src++;
  1:                         i = 8 * n + JS7_UNDEC(c);
  1:                         if (i <= 0377)
  1:                             n = i;
  1:                         else
  1:                             src--;
  1:                     }
  1:                 }
  1:                 localMax = n;
  1:                 break;
  1: 
  1:               default:
  1:                 localMax = c;
  1:                 break;
  1:             }
  1:             break;
  1:           default:
  1:             localMax = *src++;
  1:             break;
  1:         }
213:         if (state->flags & JSREG_FOLD) {
213:             c = JS_MAX(upcase((jschar) localMax), downcase((jschar) localMax));
213:             if (c > localMax)
213:                 localMax = c;
213:         }
  1:         if (inRange) {
  1:             if (rangeStart > localMax) {
  1:                 JS_ReportErrorNumber(state->context,
  1:                                      js_GetErrorMessage, NULL,
  1:                                      JSMSG_BAD_CLASS_RANGE);
  1:                 return JS_FALSE;
  1:             }
  1:             inRange = JS_FALSE;
  1:         } else {
  1:             if (src < end - 1) {
  1:                 if (*src == '-') {
  1:                     ++src;
  1:                     inRange = JS_TRUE;
  1:                     rangeStart = (jschar)localMax;
  1:                     continue;
  1:                 }
  1:             }
  1:         }
  1:         if (localMax > max)
  1:             max = localMax;
  1:     }
  1:     target->u.ucclass.bmsize = max;
  1:     return JS_TRUE;
  1: }
  1: 
  1: /*
  1:  *  item:       assertion               An item is either an assertion or
  1:  *              quantatom               a quantified atom.
  1:  *
  1:  *  assertion:  '^'                     Assertions match beginning of string
  1:  *                                      (or line if the class static property
  1:  *                                      RegExp.multiline is true).
  1:  *              '$'                     End of string (or line if the class
  1:  *                                      static property RegExp.multiline is
  1:  *                                      true).
  1:  *              '\b'                    Word boundary (between \w and \W).
  1:  *              '\B'                    Word non-boundary.
  1:  *
  1:  *  quantatom:  atom                    An unquantified atom.
  1:  *              quantatom '{' n ',' m '}'
  1:  *                                      Atom must occur between n and m times.
  1:  *              quantatom '{' n ',' '}' Atom must occur at least n times.
  1:  *              quantatom '{' n '}'     Atom must occur exactly n times.
  1:  *              quantatom '*'           Zero or more times (same as {0,}).
  1:  *              quantatom '+'           One or more times (same as {1,}).
  1:  *              quantatom '?'           Zero or one time (same as {0,1}).
  1:  *
  1:  *              any of which can be optionally followed by '?' for ungreedy
  1:  *
  1:  *  atom:       '(' regexp ')'          A parenthesized regexp (what matched
  1:  *                                      can be addressed using a backreference,
  1:  *                                      see '\' n below).
  1:  *              '.'                     Matches any char except '\n'.
  1:  *              '[' classlist ']'       A character class.
  1:  *              '[' '^' classlist ']'   A negated character class.
  1:  *              '\f'                    Form Feed.
  1:  *              '\n'                    Newline (Line Feed).
  1:  *              '\r'                    Carriage Return.
  1:  *              '\t'                    Horizontal Tab.
  1:  *              '\v'                    Vertical Tab.
  1:  *              '\d'                    A digit (same as [0-9]).
  1:  *              '\D'                    A non-digit.
  1:  *              '\w'                    A word character, [0-9a-z_A-Z].
  1:  *              '\W'                    A non-word character.
  1:  *              '\s'                    A whitespace character, [ \b\f\n\r\t\v].
  1:  *              '\S'                    A non-whitespace character.
  1:  *              '\' n                   A backreference to the nth (n decimal
  1:  *                                      and positive) parenthesized expression.
  1:  *              '\' octal               An octal escape sequence (octal must be
  1:  *                                      two or three digits long, unless it is
  1:  *                                      0 for the null character).
  1:  *              '\x' hex                A hex escape (hex must be two digits).
  1:  *              '\u' unicode            A unicode escape (must be four digits).
  1:  *              '\c' ctrl               A control character, ctrl is a letter.
  1:  *              '\' literalatomchar     Any character except one of the above
  1:  *                                      that follow '\' in an atom.
  1:  *              otheratomchar           Any character not first among the other
  1:  *                                      atom right-hand sides.
  1:  */
  1: static JSBool
  1: ParseTerm(CompilerState *state)
  1: {
  1:     jschar c = *state->cp++;
  1:     uintN nDigits;
  1:     uintN num, tmp, n, i;
  1:     const jschar *termStart;
  1: 
  1:     switch (c) {
  1:     /* assertions and atoms */
  1:       case '^':
  1:         state->result = NewRENode(state, REOP_BOL);
  1:         if (!state->result)
  1:             return JS_FALSE;
  1:         state->progLength++;
  1:         return JS_TRUE;
  1:       case '$':
  1:         state->result = NewRENode(state, REOP_EOL);
  1:         if (!state->result)
  1:             return JS_FALSE;
  1:         state->progLength++;
  1:         return JS_TRUE;
  1:       case '\\':
  1:         if (state->cp >= state->cpend) {
  1:             /* a trailing '\' is an error */
  1:             js_ReportCompileErrorNumber(state->context, state->tokenStream,
  1:                                         JSREPORT_TS | JSREPORT_ERROR,
  1:                                         JSMSG_TRAILING_SLASH);
  1:             return JS_FALSE;
  1:         }
  1:         c = *state->cp++;
  1:         switch (c) {
  1:         /* assertion escapes */
  1:           case 'b' :
  1:             state->result = NewRENode(state, REOP_WBDRY);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->progLength++;
  1:             return JS_TRUE;
  1:           case 'B':
  1:             state->result = NewRENode(state, REOP_WNONBDRY);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->progLength++;
  1:             return JS_TRUE;
  1:           /* Decimal escape */
  1:           case '0':
  1:             /* Give a strict warning. See also the note below. */
  1:             if (!js_ReportCompileErrorNumber(state->context,
  1:                                              state->tokenStream,
  1:                                              JSREPORT_TS |
  1:                                              JSREPORT_WARNING |
  1:                                              JSREPORT_STRICT,
  1:                                              JSMSG_INVALID_BACKREF)) {
  1:                 return JS_FALSE;
  1:             }
  1:      doOctal:
  1:             num = 0;
  1:             while (state->cp < state->cpend) {
  1:                 c = *state->cp;
  1:                 if (c < '0' || '7' < c)
  1:                     break;
  1:                 state->cp++;
  1:                 tmp = 8 * num + (uintN)JS7_UNDEC(c);
  1:                 if (tmp > 0377)
  1:                     break;
  1:                 num = tmp;
  1:             }
  1:             c = (jschar)num;
  1:     doFlat:
  1:             state->result = NewRENode(state, REOP_FLAT);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.flat.chr = c;
  1:             state->result->u.flat.length = 1;
  1:             state->progLength += 3;
  1:             break;
  1:           case '1':
  1:           case '2':
  1:           case '3':
  1:           case '4':
  1:           case '5':
  1:           case '6':
  1:           case '7':
  1:           case '8':
  1:           case '9':
  1:             termStart = state->cp - 1;
  1:             num = GetDecimalValue(c, state->parenCount, FindParenCount, state);
  1:             if (state->flags & JSREG_FIND_PAREN_ERROR)
  1:                 return JS_FALSE;
  1:             if (num == OVERFLOW_VALUE) {
  1:                 /* Give a strict mode warning. */
  1:                 if (!js_ReportCompileErrorNumber(state->context,
  1:                                                  state->tokenStream,
  1:                                                  JSREPORT_TS |
  1:                                                  JSREPORT_WARNING |
  1:                                                  JSREPORT_STRICT,
  1:                                                  (c >= '8')
  1:                                                  ? JSMSG_INVALID_BACKREF
  1:                                                  : JSMSG_BAD_BACKREF)) {
  1:                     return JS_FALSE;
  1:                 }
  1: 
  1:                 /*
  1:                  * Note: ECMA 262, 15.10.2.9 says that we should throw a syntax
  1:                  * error here. However, for compatibility with IE, we treat the
  1:                  * whole backref as flat if the first character in it is not a
  1:                  * valid octal character, and as an octal escape otherwise.
  1:                  */
  1:                 state->cp = termStart;
  1:                 if (c >= '8') {
  1:                     /* Treat this as flat. termStart - 1 is the \. */
  1:                     c = '\\';
  1:                     goto asFlat;
  1:                 }
  1: 
  1:                 /* Treat this as an octal escape. */
  1:                 goto doOctal;
  1:             }
  1:             JS_ASSERT(1 <= num && num <= 0x10000);
  1:             state->result = NewRENode(state, REOP_BACKREF);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.parenIndex = num - 1;
  1:             state->progLength
  1:                 += 1 + GetCompactIndexWidth(state->result->u.parenIndex);
  1:             break;
  1:           /* Control escape */
  1:           case 'f':
  1:             c = 0xC;
  1:             goto doFlat;
  1:           case 'n':
  1:             c = 0xA;
  1:             goto doFlat;
  1:           case 'r':
  1:             c = 0xD;
  1:             goto doFlat;
  1:           case 't':
  1:             c = 0x9;
  1:             goto doFlat;
  1:           case 'v':
  1:             c = 0xB;
  1:             goto doFlat;
  1:           /* Control letter */
  1:           case 'c':
  1:             if (state->cp < state->cpend && RE_IS_LETTER(*state->cp)) {
  1:                 c = (jschar) (*state->cp++ & 0x1F);
  1:             } else {
  1:                 /* back off to accepting the original '\' as a literal */
  1:                 --state->cp;
  1:                 c = '\\';
  1:             }
  1:             goto doFlat;
  1:           /* HexEscapeSequence */
  1:           case 'x':
  1:             nDigits = 2;
  1:             goto lexHex;
  1:           /* UnicodeEscapeSequence */
  1:           case 'u':
  1:             nDigits = 4;
  1: lexHex:
  1:             n = 0;
  1:             for (i = 0; i < nDigits && state->cp < state->cpend; i++) {
  1:                 uintN digit;
  1:                 c = *state->cp++;
  1:                 if (!isASCIIHexDigit(c, &digit)) {
  1:                     /*
  1:                      * Back off to accepting the original 'u' or 'x' as a
  1:                      * literal.
  1:                      */
  1:                     state->cp -= i + 2;
  1:                     n = *state->cp++;
  1:                     break;
  1:                 }
  1:                 n = (n << 4) | digit;
  1:             }
  1:             c = (jschar) n;
  1:             goto doFlat;
  1:           /* Character class escapes */
  1:           case 'd':
  1:             state->result = NewRENode(state, REOP_DIGIT);
  1: doSimple:
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->progLength++;
  1:             break;
  1:           case 'D':
  1:             state->result = NewRENode(state, REOP_NONDIGIT);
  1:             goto doSimple;
  1:           case 's':
  1:             state->result = NewRENode(state, REOP_SPACE);
  1:             goto doSimple;
  1:           case 'S':
  1:             state->result = NewRENode(state, REOP_NONSPACE);
  1:             goto doSimple;
  1:           case 'w':
  1:             state->result = NewRENode(state, REOP_ALNUM);
  1:             goto doSimple;
  1:           case 'W':
  1:             state->result = NewRENode(state, REOP_NONALNUM);
  1:             goto doSimple;
  1:           /* IdentityEscape */
  1:           default:
  1:             state->result = NewRENode(state, REOP_FLAT);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.flat.chr = c;
  1:             state->result->u.flat.length = 1;
  1:             state->result->kid = (void *) (state->cp - 1);
  1:             state->progLength += 3;
  1:             break;
  1:         }
  1:         break;
  1:       case '[':
  1:         state->result = NewRENode(state, REOP_CLASS);
  1:         if (!state->result)
  1:             return JS_FALSE;
  1:         termStart = state->cp;
  1:         state->result->u.ucclass.startIndex = termStart - state->cpbegin;
  1:         for (;;) {
  1:             if (state->cp == state->cpend) {
  1:                 js_ReportCompileErrorNumberUC(state->context, state->tokenStream,
  1:                                               JSREPORT_TS | JSREPORT_ERROR,
  1:                                               JSMSG_UNTERM_CLASS, termStart);
  1: 
  1:                 return JS_FALSE;
  1:             }
  1:             if (*state->cp == '\\') {
  1:                 state->cp++;
  1:                 if (state->cp != state->cpend)
  1:                     state->cp++;
  1:                 continue;
  1:             }
  1:             if (*state->cp == ']') {
  1:                 state->result->u.ucclass.kidlen = state->cp - termStart;
  1:                 break;
  1:             }
  1:             state->cp++;
  1:         }
  1:         for (i = 0; i < CLASS_CACHE_SIZE; i++) {
  1:             if (!state->classCache[i].start) {
  1:                 state->classCache[i].start = termStart;
  1:                 state->classCache[i].length = state->result->u.ucclass.kidlen;
  1:                 state->classCache[i].index = state->classCount;
  1:                 break;
  1:             }
  1:             if (state->classCache[i].length ==
  1:                 state->result->u.ucclass.kidlen) {
  1:                 for (n = 0; ; n++) {
  1:                     if (n == state->classCache[i].length) {
  1:                         state->result->u.ucclass.index
  1:                             = state->classCache[i].index;
  1:                         goto claim;
  1:                     }
  1:                     if (state->classCache[i].start[n] != termStart[n])
  1:                         break;
  1:                 }
  1:             }
  1:         }
  1:         state->result->u.ucclass.index = state->classCount++;
  1: 
  1:     claim:
  1:         /*
  1:          * Call CalculateBitmapSize now as we want any errors it finds
  1:          * to be reported during the parse phase, not at execution.
  1:          */
  1:         if (!CalculateBitmapSize(state, state->result, termStart, state->cp++))
  1:             return JS_FALSE;
  1:         /*
  1:          * Update classBitmapsMem with number of bytes to hold bmsize bits,
  1:          * which is (bitsCount + 7) / 8 or (highest_bit + 1 + 7) / 8
  1:          * or highest_bit / 8 + 1 where highest_bit is u.ucclass.bmsize.
  1:          */
  1:         n = (state->result->u.ucclass.bmsize >> 3) + 1;
  1:         if (n > CLASS_BITMAPS_MEM_LIMIT - state->classBitmapsMem) {
  1:             js_ReportCompileErrorNumber(state->context, state->tokenStream,
  1:                                         JSREPORT_TS | JSREPORT_ERROR,
  1:                                         JSMSG_REGEXP_TOO_COMPLEX);
  1:             return JS_FALSE;
  1:         }
  1:         state->classBitmapsMem += n;
  1:         /* CLASS, <index> */
  1:         state->progLength
  1:             += 1 + GetCompactIndexWidth(state->result->u.ucclass.index);
  1:         break;
  1: 
  1:       case '.':
  1:         state->result = NewRENode(state, REOP_DOT);
  1:         goto doSimple;
  1: 
  1:       case '{':
  1:       {
  1:         const jschar *errp = state->cp--;
  1:         intN err;
  1: 
  1:         err = ParseMinMaxQuantifier(state, JS_TRUE);
  1:         state->cp = errp;
  1: 
  1:         if (err < 0)
  1:             goto asFlat;
  1: 
  1:         /* FALL THROUGH */
  1:       }
  1:       case '*':
  1:       case '+':
  1:       case '?':
  1:         js_ReportCompileErrorNumberUC(state->context, state->tokenStream,
  1:                                       JSREPORT_TS | JSREPORT_ERROR,
  1:                                       JSMSG_BAD_QUANTIFIER, state->cp - 1);
  1:         return JS_FALSE;
  1:       default:
  1: asFlat:
  1:         state->result = NewRENode(state, REOP_FLAT);
  1:         if (!state->result)
  1:             return JS_FALSE;
  1:         state->result->u.flat.chr = c;
  1:         state->result->u.flat.length = 1;
  1:         state->result->kid = (void *) (state->cp - 1);
  1:         state->progLength += 3;
  1:         break;
  1:     }
  1:     return ParseQuantifier(state);
  1: }
  1: 
  1: static JSBool
  1: ParseQuantifier(CompilerState *state)
  1: {
  1:     RENode *term;
  1:     term = state->result;
  1:     if (state->cp < state->cpend) {
  1:         switch (*state->cp) {
  1:           case '+':
  1:             state->result = NewRENode(state, REOP_QUANT);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.range.min = 1;
  1:             state->result->u.range.max = (uintN)-1;
  1:             /* <PLUS>, <next> ... <ENDCHILD> */
  1:             state->progLength += 4;
  1:             goto quantifier;
  1:           case '*':
  1:             state->result = NewRENode(state, REOP_QUANT);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.range.min = 0;
  1:             state->result->u.range.max = (uintN)-1;
  1:             /* <STAR>, <next> ... <ENDCHILD> */
  1:             state->progLength += 4;
  1:             goto quantifier;
  1:           case '?':
  1:             state->result = NewRENode(state, REOP_QUANT);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.range.min = 0;
  1:             state->result->u.range.max = 1;
  1:             /* <OPT>, <next> ... <ENDCHILD> */
  1:             state->progLength += 4;
  1:             goto quantifier;
  1:           case '{':       /* balance '}' */
  1:           {
  1:             intN err;
  1:             const jschar *errp = state->cp;
  1: 
  1:             err = ParseMinMaxQuantifier(state, JS_FALSE);
  1:             if (err == 0)
  1:                 goto quantifier;
  1:             if (err == -1)
  1:                 return JS_TRUE;
  1: 
  1:             js_ReportCompileErrorNumberUC(state->context,
  1:                                           state->tokenStream,
  1:                                           JSREPORT_TS | JSREPORT_ERROR,
  1:                                           err, errp);
  1:             return JS_FALSE;
  1:           }
  1:           default:;
  1:         }
  1:     }
  1:     return JS_TRUE;
  1: 
  1: quantifier:
  1:     if (state->treeDepth == TREE_DEPTH_MAX) {
  1:         js_ReportCompileErrorNumber(state->context, state->tokenStream,
  1:                                     JSREPORT_TS | JSREPORT_ERROR,
  1:                                     JSMSG_REGEXP_TOO_COMPLEX);
  1:         return JS_FALSE;
  1:     }
  1: 
  1:     ++state->treeDepth;
  1:     ++state->cp;
  1:     state->result->kid = term;
  1:     if (state->cp < state->cpend && *state->cp == '?') {
  1:         ++state->cp;
  1:         state->result->u.range.greedy = JS_FALSE;
  1:     } else {
  1:         state->result->u.range.greedy = JS_TRUE;
  1:     }
  1:     return JS_TRUE;
  1: }
  1: 
  1: static intN
  1: ParseMinMaxQuantifier(CompilerState *state, JSBool ignoreValues)
  1: {
  1:     uintN min, max;
  1:     jschar c;
  1:     const jschar *errp = state->cp++;
  1: 
  1:     c = *state->cp;
  1:     if (JS7_ISDEC(c)) {
  1:         ++state->cp;
  1:         min = GetDecimalValue(c, 0xFFFF, NULL, state);
  1:         c = *state->cp;
  1: 
  1:         if (!ignoreValues && min == OVERFLOW_VALUE)
  1:             return JSMSG_MIN_TOO_BIG;
  1: 
  1:         if (c == ',') {
  1:             c = *++state->cp;
  1:             if (JS7_ISDEC(c)) {
  1:                 ++state->cp;
  1:                 max = GetDecimalValue(c, 0xFFFF, NULL, state);
  1:                 c = *state->cp;
  1:                 if (!ignoreValues && max == OVERFLOW_VALUE)
  1:                     return JSMSG_MAX_TOO_BIG;
  1:                 if (!ignoreValues && min > max)
  1:                     return JSMSG_OUT_OF_ORDER;
  1:             } else {
  1:                 max = (uintN)-1;
  1:             }
  1:         } else {
  1:             max = min;
  1:         }
  1:         if (c == '}') {
  1:             state->result = NewRENode(state, REOP_QUANT);
  1:             if (!state->result)
  1:                 return JS_FALSE;
  1:             state->result->u.range.min = min;
  1:             state->result->u.range.max = max;
  1:             /*
  1:              * QUANT, <min>, <max>, <next> ... <ENDCHILD>
  1:              * where <max> is written as compact(max+1) to make
  1:              * (uintN)-1 sentinel to occupy 1 byte, not width_of(max)+1.
  1:              */
  1:             state->progLength += (1 + GetCompactIndexWidth(min)
  1:                                   + GetCompactIndexWidth(max + 1)
  1:                                   +3);
  1:             return 0;
  1:         }
  1:     }
  1: 
  1:     state->cp = errp;
  1:     return -1;
  1: }
  1: 
  1: static JSBool
  1: SetForwardJumpOffset(jsbytecode *jump, jsbytecode *target)
  1: {
  1:     ptrdiff_t offset = target - jump;
  1: 
  1:     /* Check that target really points forward. */
  1:     JS_ASSERT(offset >= 2);
  1:     if ((size_t)offset > OFFSET_MAX)
  1:         return JS_FALSE;
  1: 
  1:     jump[0] = JUMP_OFFSET_HI(offset);
  1:     jump[1] = JUMP_OFFSET_LO(offset);
  1:     return JS_TRUE;
  1: }
  1: 
  1: /*
  1:  * Generate bytecode for the tree rooted at t using an explicit stack instead
  1:  * of recursion.
  1:  */
  1: static jsbytecode *
  1: EmitREBytecode(CompilerState *state, JSRegExp *re, size_t treeDepth,
  1:                jsbytecode *pc, RENode *t)
  1: {
  1:     EmitStateStackEntry *emitStateSP, *emitStateStack;
  1:     RECharSet *charSet;
  1:     REOp op;
  1: 
  1:     if (treeDepth == 0) {
  1:         emitStateStack = NULL;
  1:     } else {
  1:         emitStateStack =
  1:             (EmitStateStackEntry *)JS_malloc(state->context,
  1:                                              sizeof(EmitStateStackEntry) *
  1:                                              treeDepth);
  1:         if (!emitStateStack)
  1:             return NULL;
  1:     }
  1:     emitStateSP = emitStateStack;
  1:     op = t->op;
  1:     JS_ASSERT(op < REOP_LIMIT);
  1: 
  1:     for (;;) {
  1:         *pc++ = op;
  1:         switch (op) {
  1:           case REOP_EMPTY:
  1:             --pc;
  1:             break;
  1: 
  1:           case REOP_ALTPREREQ2:
  1:           case REOP_ALTPREREQ:
  1:             JS_ASSERT(emitStateSP);
  1:             emitStateSP->altHead = pc - 1;
  1:             emitStateSP->endTermFixup = pc;
  1:             pc += OFFSET_LEN;
  1:             SET_ARG(pc, t->u.altprereq.ch1);
  1:             pc += ARG_LEN;
  1:             SET_ARG(pc, t->u.altprereq.ch2);
  1:             pc += ARG_LEN;
  1: 
  1:             emitStateSP->nextAltFixup = pc;    /* offset to next alternate */
  1:             pc += OFFSET_LEN;
  1: 
  1:             emitStateSP->continueNode = t;
  1:             emitStateSP->continueOp = REOP_JUMP;
  1:             emitStateSP->jumpToJumpFlag = JS_FALSE;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = (RENode *) t->kid;
  1:             op = t->op;
  1:             JS_ASSERT(op < REOP_LIMIT);
  1:             continue;
  1: 
  1:           case REOP_JUMP:
  1:             emitStateSP->nextTermFixup = pc;    /* offset to following term */
  1:             pc += OFFSET_LEN;
  1:             if (!SetForwardJumpOffset(emitStateSP->nextAltFixup, pc))
  1:                 goto jump_too_big;
  1:             emitStateSP->continueOp = REOP_ENDALT;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = t->u.kid2;
  1:             op = t->op;
  1:             JS_ASSERT(op < REOP_LIMIT);
  1:             continue;
  1: 
  1:           case REOP_ENDALT:
  1:             /*
  1:              * If we already patched emitStateSP->nextTermFixup to jump to
  1:              * a nearer jump, to avoid 16-bit immediate offset overflow, we
  1:              * are done here.
  1:              */
  1:             if (emitStateSP->jumpToJumpFlag)
  1:                 break;
  1: 
  1:             /*
  1:              * Fix up the REOP_JUMP offset to go to the op after REOP_ENDALT.
  1:              * REOP_ENDALT is executed only on successful match of the last
  1:              * alternate in a group.
  1:              */
  1:             if (!SetForwardJumpOffset(emitStateSP->nextTermFixup, pc))
  1:                 goto jump_too_big;
  1:             if (t->op != REOP_ALT) {
  1:                 if (!SetForwardJumpOffset(emitStateSP->endTermFixup, pc))
  1:                     goto jump_too_big;
  1:             }
  1: 
  1:             /*
  1:              * If the program is bigger than the REOP_JUMP offset range, then
  1:              * we must check for alternates before this one that are part of
  1:              * the same group, and fix up their jump offsets to target jumps
  1:              * close enough to fit in a 16-bit unsigned offset immediate.
  1:              */
  1:             if ((size_t)(pc - re->program) > OFFSET_MAX &&
  1:                 emitStateSP > emitStateStack) {
  1:                 EmitStateStackEntry *esp, *esp2;
  1:                 jsbytecode *alt, *jump;
  1:                 ptrdiff_t span, header;
  1: 
  1:                 esp2 = emitStateSP;
  1:                 alt = esp2->altHead;
  1:                 for (esp = esp2 - 1; esp >= emitStateStack; --esp) {
  1:                     if (esp->continueOp == REOP_ENDALT &&
  1:                         !esp->jumpToJumpFlag &&
  1:                         esp->nextTermFixup + OFFSET_LEN == alt &&
  1:                         (size_t)(pc - ((esp->continueNode->op != REOP_ALT)
  1:                                        ? esp->endTermFixup
  1:                                        : esp->nextTermFixup)) > OFFSET_MAX) {
  1:                         alt = esp->altHead;
  1:                         jump = esp->nextTermFixup;
  1: 
  1:                         /*
  1:                          * The span must be 1 less than the distance from
  1:                          * jump offset to jump offset, so we actually jump
  1:                          * to a REOP_JUMP bytecode, not to its offset!
  1:                          */
  1:                         for (;;) {
  1:                             JS_ASSERT(jump < esp2->nextTermFixup);
  1:                             span = esp2->nextTermFixup - jump - 1;
  1:                             if ((size_t)span <= OFFSET_MAX)
  1:                                 break;
  1:                             do {
  1:                                 if (--esp2 == esp)
  1:                                     goto jump_too_big;
  1:                             } while (esp2->continueOp != REOP_ENDALT);
  1:                         }
  1: 
  1:                         jump[0] = JUMP_OFFSET_HI(span);
  1:                         jump[1] = JUMP_OFFSET_LO(span);
  1: 
  1:                         if (esp->continueNode->op != REOP_ALT) {
  1:                             /*
  1:                              * We must patch the offset at esp->endTermFixup
  1:                              * as well, for the REOP_ALTPREREQ{,2} opcodes.
  1:                              * If we're unlucky and endTermFixup is more than
  1:                              * OFFSET_MAX bytes from its target, we cheat by
  1:                              * jumping 6 bytes to the jump whose offset is at
  1:                              * esp->nextTermFixup, which has the same target.
  1:                              */
  1:                             jump = esp->endTermFixup;
  1:                             header = esp->nextTermFixup - jump;
  1:                             span += header;
  1:                             if ((size_t)span > OFFSET_MAX)
  1:                                 span = header;
  1: 
  1:                             jump[0] = JUMP_OFFSET_HI(span);
  1:                             jump[1] = JUMP_OFFSET_LO(span);
  1:                         }
  1: 
  1:                         esp->jumpToJumpFlag = JS_TRUE;
  1:                     }
  1:                 }
  1:             }
  1:             break;
  1: 
  1:           case REOP_ALT:
  1:             JS_ASSERT(emitStateSP);
  1:             emitStateSP->altHead = pc - 1;
  1:             emitStateSP->nextAltFixup = pc;     /* offset to next alternate */
  1:             pc += OFFSET_LEN;
  1:             emitStateSP->continueNode = t;
  1:             emitStateSP->continueOp = REOP_JUMP;
  1:             emitStateSP->jumpToJumpFlag = JS_FALSE;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = t->kid;
  1:             op = t->op;
  1:             JS_ASSERT(op < REOP_LIMIT);
  1:             continue;
  1: 
  1:           case REOP_FLAT:
  1:             /*
  1:              * Coalesce FLATs if possible and if it would not increase bytecode
  1:              * beyond preallocated limit. The latter happens only when bytecode
  1:              * size for coalesced string with offset p and length 2 exceeds 6
  1:              * bytes preallocated for 2 single char nodes, i.e. when
  1:              * 1 + GetCompactIndexWidth(p) + GetCompactIndexWidth(2) > 6 or
  1:              * GetCompactIndexWidth(p) > 4.
  1:              * Since when GetCompactIndexWidth(p) <= 4 coalescing of 3 or more
  1:              * nodes strictly decreases bytecode size, the check has to be
  1:              * done only for the first coalescing.
  1:              */
  1:             if (t->kid &&
  1:                 GetCompactIndexWidth((jschar *)t->kid - state->cpbegin) <= 4)
  1:             {
  1:                 while (t->next &&
  1:                        t->next->op == REOP_FLAT &&
  1:                        (jschar*)t->kid + t->u.flat.length ==
  1:                        (jschar*)t->next->kid) {
  1:                     t->u.flat.length += t->next->u.flat.length;
  1:                     t->next = t->next->next;
  1:                 }
  1:             }
  1:             if (t->kid && t->u.flat.length > 1) {
  1:                 pc[-1] = (state->flags & JSREG_FOLD) ? REOP_FLATi : REOP_FLAT;
  1:                 pc = WriteCompactIndex(pc, (jschar *)t->kid - state->cpbegin);
  1:                 pc = WriteCompactIndex(pc, t->u.flat.length);
  1:             } else if (t->u.flat.chr < 256) {
  1:                 pc[-1] = (state->flags & JSREG_FOLD) ? REOP_FLAT1i : REOP_FLAT1;
  1:                 *pc++ = (jsbytecode) t->u.flat.chr;
  1:             } else {
  1:                 pc[-1] = (state->flags & JSREG_FOLD)
  1:                          ? REOP_UCFLAT1i
  1:                          : REOP_UCFLAT1;
  1:                 SET_ARG(pc, t->u.flat.chr);
  1:                 pc += ARG_LEN;
  1:             }
  1:             break;
  1: 
  1:           case REOP_LPAREN:
  1:             JS_ASSERT(emitStateSP);
  1:             pc = WriteCompactIndex(pc, t->u.parenIndex);
  1:             emitStateSP->continueNode = t;
  1:             emitStateSP->continueOp = REOP_RPAREN;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = (RENode *) t->kid;
  1:             op = t->op;
  1:             continue;
  1: 
  1:           case REOP_RPAREN:
  1:             pc = WriteCompactIndex(pc, t->u.parenIndex);
  1:             break;
  1: 
  1:           case REOP_BACKREF:
  1:             pc = WriteCompactIndex(pc, t->u.parenIndex);
  1:             break;
  1: 
  1:           case REOP_ASSERT:
  1:             JS_ASSERT(emitStateSP);
  1:             emitStateSP->nextTermFixup = pc;
  1:             pc += OFFSET_LEN;
  1:             emitStateSP->continueNode = t;
  1:             emitStateSP->continueOp = REOP_ASSERTTEST;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = (RENode *) t->kid;
  1:             op = t->op;
  1:             continue;
  1: 
  1:           case REOP_ASSERTTEST:
  1:           case REOP_ASSERTNOTTEST:
  1:             if (!SetForwardJumpOffset(emitStateSP->nextTermFixup, pc))
  1:                 goto jump_too_big;
  1:             break;
  1: 
  1:           case REOP_ASSERT_NOT:
  1:             JS_ASSERT(emitStateSP);
  1:             emitStateSP->nextTermFixup = pc;
  1:             pc += OFFSET_LEN;
  1:             emitStateSP->continueNode = t;
  1:             emitStateSP->continueOp = REOP_ASSERTNOTTEST;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = (RENode *) t->kid;
  1:             op = t->op;
  1:             continue;
  1: 
  1:           case REOP_QUANT:
  1:             JS_ASSERT(emitStateSP);
  1:             if (t->u.range.min == 0 && t->u.range.max == (uintN)-1) {
  1:                 pc[-1] = (t->u.range.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
  1:             } else if (t->u.range.min == 0 && t->u.range.max == 1) {
  1:                 pc[-1] = (t->u.range.greedy) ? REOP_OPT : REOP_MINIMALOPT;
  1:             } else if (t->u.range.min == 1 && t->u.range.max == (uintN) -1) {
  1:                 pc[-1] = (t->u.range.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
  1:             } else {
  1:                 if (!t->u.range.greedy)
  1:                     pc[-1] = REOP_MINIMALQUANT;
  1:                 pc = WriteCompactIndex(pc, t->u.range.min);
  1:                 /*
  1:                  * Write max + 1 to avoid using size_t(max) + 1 bytes
  1:                  * for (uintN)-1 sentinel.
  1:                  */
  1:                 pc = WriteCompactIndex(pc, t->u.range.max + 1);
  1:             }
  1:             emitStateSP->nextTermFixup = pc;
  1:             pc += OFFSET_LEN;
  1:             emitStateSP->continueNode = t;
  1:             emitStateSP->continueOp = REOP_ENDCHILD;
  1:             ++emitStateSP;
  1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
  1:             t = (RENode *) t->kid;
  1:             op = t->op;
  1:             continue;
  1: 
  1:           case REOP_ENDCHILD:
  1:             if (!SetForwardJumpOffset(emitStateSP->nextTermFixup, pc))
  1:                 goto jump_too_big;
  1:             break;
  1: 
  1:           case REOP_CLASS:
  1:             if (!t->u.ucclass.sense)
  1:                 pc[-1] = REOP_NCLASS;
  1:             pc = WriteCompactIndex(pc, t->u.ucclass.index);
  1:             charSet = &re->classList[t->u.ucclass.index];
  1:             charSet->converted = JS_FALSE;
  1:             charSet->length = t->u.ucclass.bmsize;
  1:             charSet->u.src.startIndex = t->u.ucclass.startIndex;
  1:             charSet->u.src.length = t->u.ucclass.kidlen;
  1:             charSet->sense = t->u.ucclass.sense;
  1:             break;
  1: 
  1:           default:
  1:             break;
  1:         }
  1: 
  1:         t = t->next;
  1:         if (t) {
  1:             op = t->op;
  1:         } else {
  1:             if (emitStateSP == emitStateStack)
  1:                 break;
  1:             --emitStateSP;
  1:             t = emitStateSP->continueNode;
  1:             op = emitStateSP->continueOp;
  1:         }
  1:     }
  1: 
  1:   cleanup:
  1:     if (emitStateStack)
  1:         JS_free(state->context, emitStateStack);
  1:     return pc;
  1: 
  1:   jump_too_big:
  1:     js_ReportCompileErrorNumber(state->context, state->tokenStream,
  1:                                 JSREPORT_TS | JSREPORT_ERROR,
  1:                                 JSMSG_REGEXP_TOO_COMPLEX);
  1:     pc = NULL;
  1:     goto cleanup;
  1: }
  1: 
  1: 
  1: JSRegExp *
  1: js_NewRegExp(JSContext *cx, JSTokenStream *ts,
  1:              JSString *str, uintN flags, JSBool flat)
  1: {
  1:     JSRegExp *re;
  1:     void *mark;
  1:     CompilerState state;
  1:     size_t resize;
  1:     jsbytecode *endPC;
  1:     uintN i;
  1:     size_t len;
  1: 
  1:     re = NULL;
  1:     mark = JS_ARENA_MARK(&cx->tempPool);
  1:     len = JSSTRING_LENGTH(str);
  1: 
  1:     state.context = cx;
  1:     state.tokenStream = ts;
  1:     state.cp = js_UndependString(cx, str);
  1:     if (!state.cp)
  1:         goto out;
  1:     state.cpbegin = state.cp;
  1:     state.cpend = state.cp + len;
  1:     state.flags = flags;
  1:     state.parenCount = 0;
  1:     state.classCount = 0;
  1:     state.progLength = 0;
  1:     state.treeDepth = 0;
  1:     state.classBitmapsMem = 0;
  1:     for (i = 0; i < CLASS_CACHE_SIZE; i++)
  1:         state.classCache[i].start = NULL;
  1: 
  1:     if (len != 0 && flat) {
  1:         state.result = NewRENode(&state, REOP_FLAT);
  1:         state.result->u.flat.chr = *state.cpbegin;
  1:         state.result->u.flat.length = len;
  1:         state.result->kid = (void *) state.cpbegin;
  1:         /* Flat bytecode: REOP_FLAT compact(string_offset) compact(len). */
  1:         state.progLength += 1 + GetCompactIndexWidth(0)
  1:                           + GetCompactIndexWidth(len);
  1:     } else {
  1:         if (!ParseRegExp(&state))
  1:             goto out;
  1:     }
  1:     resize = offsetof(JSRegExp, program) + state.progLength + 1;
  1:     re = (JSRegExp *) JS_malloc(cx, resize);
  1:     if (!re)
  1:         goto out;
  1: 
  1:     re->nrefs = 1;
  1:     JS_ASSERT(state.classBitmapsMem <= CLASS_BITMAPS_MEM_LIMIT);
  1:     re->classCount = state.classCount;
  1:     if (re->classCount) {
  1:         re->classList = (RECharSet *)
  1:             JS_malloc(cx, re->classCount * sizeof(RECharSet));
  1:         if (!re->classList) {
  1:             js_DestroyRegExp(cx, re);
  1:             re = NULL;
  1:             goto out;
  1:         }
  1:         for (i = 0; i < re->classCount; i++)
  1:             re->classList[i].converted = JS_FALSE;
  1:     } else {
  1:         re->classList = NULL;
  1:     }
  1:     endPC = EmitREBytecode(&state, re, state.treeDepth, re->program, state.result);
  1:     if (!endPC) {
  1:         js_DestroyRegExp(cx, re);
  1:         re = NULL;
  1:         goto out;
  1:     }
  1:     *endPC++ = REOP_END;
  1:     /*
  1:      * Check whether size was overestimated and shrink using realloc.
  1:      * This is safe since no pointers to newly parsed regexp or its parts
  1:      * besides re exist here.
  1:      */
  1:     if ((size_t)(endPC - re->program) != state.progLength + 1) {
  1:         JSRegExp *tmp;
  1:         JS_ASSERT((size_t)(endPC - re->program) < state.progLength + 1);
  1:         resize = offsetof(JSRegExp, program) + (endPC - re->program);
  1:         tmp = (JSRegExp *) JS_realloc(cx, re, resize);
  1:         if (tmp)
  1:             re = tmp;
  1:     }
  1: 
  1:     re->flags = flags;
  1:     re->cloneIndex = 0;
  1:     re->parenCount = state.parenCount;
  1:     re->source = str;
  1: 
  1: out:
  1:     JS_ARENA_RELEASE(&cx->tempPool, mark);
  1:     return re;
  1: }
  1: 
  1: JSRegExp *
  1: js_NewRegExpOpt(JSContext *cx, JSTokenStream *ts,
  1:                 JSString *str, JSString *opt, JSBool flat)
  1: {
  1:     uintN flags;
  1:     jschar *s;
  1:     size_t i, n;
  1:     char charBuf[2];
  1: 
  1:     flags = 0;
  1:     if (opt) {
  1:         s = JSSTRING_CHARS(opt);
  1:         for (i = 0, n = JSSTRING_LENGTH(opt); i < n; i++) {
  1:             switch (s[i]) {
  1:               case 'g':
  1:                 flags |= JSREG_GLOB;
  1:                 break;
  1:               case 'i':
  1:                 flags |= JSREG_FOLD;
  1:                 break;
  1:               case 'm':
  1:                 flags |= JSREG_MULTILINE;
  1:                 break;
  1:               case 'y':
  1:                 flags |= JSREG_STICKY;
  1:                 break;
  1:               default:
  1:                 charBuf[0] = (char)s[i];
  1:                 charBuf[1] = '\0';
  1:                 js_ReportCompileErrorNumber(cx, ts,
  1:                                             JSREPORT_TS | JSREPORT_ERROR,
  1:                                             JSMSG_BAD_FLAG, charBuf);
  1:                 return NULL;
  1:             }
  1:         }
  1:     }
  1:     return js_NewRegExp(cx, ts, str, flags, flat);
  1: }
  1: 
  1: /*
  1:  * Save the current state of the match - the position in the input
  1:  * text as well as the position in the bytecode. The state of any
  1:  * parent expressions is also saved (preceding state).
  1:  * Contents of parenCount parentheses from parenIndex are also saved.
  1:  */
  1: static REBackTrackData *
  1: PushBackTrackState(REGlobalData *gData, REOp op,
  1:                    jsbytecode *target, REMatchState *x, const jschar *cp,
  1:                    size_t parenIndex, size_t parenCount)
  1: {
  1:     size_t i;
  1:     REBackTrackData *result =
  1:         (REBackTrackData *) ((char *)gData->backTrackSP + gData->cursz);
  1: 
  1:     size_t sz = sizeof(REBackTrackData) +
  1:                 gData->stateStackTop * sizeof(REProgState) +
  1:                 parenCount * sizeof(RECapture);
  1: 
  1:     ptrdiff_t btsize = gData->backTrackStackSize;
  1:     ptrdiff_t btincr = ((char *)result + sz) -
  1:                        ((char *)gData->backTrackStack + btsize);
  1: 
211:     re_debug("\tBT_Push: %lu,%lu",
211:              (unsigned long) parenIndex, (unsigned long) parenCount);
 22: 
  1:     JS_COUNT_OPERATION(gData->cx, JSOW_JUMP * (1 + parenCount));
  1:     if (btincr > 0) {
  1:         ptrdiff_t offset = (char *)result - (char *)gData->backTrackStack;
  1: 
  1:         JS_COUNT_OPERATION(gData->cx, JSOW_ALLOCATION);
  1:         btincr = JS_ROUNDUP(btincr, btsize);
  1:         JS_ARENA_GROW_CAST(gData->backTrackStack, REBackTrackData *,
  1:                            &gData->pool, btsize, btincr);
  1:         if (!gData->backTrackStack) {
  1:             JS_ReportOutOfMemory(gData->cx);
  1:             gData->ok = JS_FALSE;
  1:             return NULL;
  1:         }
  1:         gData->backTrackStackSize = btsize + btincr;
  1:         result = (REBackTrackData *) ((char *)gData->backTrackStack + offset);
  1:     }
  1:     gData->backTrackSP = result;
  1:     result->sz = gData->cursz;
  1:     gData->cursz = sz;
  1: 
  1:     result->backtrack_op = op;
  1:     result->backtrack_pc = target;
  1:     result->cp = cp;
  1:     result->parenCount = parenCount;
 22:     result->parenIndex = parenIndex;
  1: 
  1:     result->saveStateStackTop = gData->stateStackTop;
  1:     JS_ASSERT(gData->stateStackTop);
  1:     memcpy(result + 1, gData->stateStack,
  1:            sizeof(REProgState) * result->saveStateStackTop);
  1: 
  1:     if (parenCount != 0) {
  1:         memcpy((char *)(result + 1) +
  1:                sizeof(REProgState) * result->saveStateStackTop,
  1:                &x->parens[parenIndex],
  1:                sizeof(RECapture) * parenCount);
  1:         for (i = 0; i != parenCount; i++)
  1:             x->parens[parenIndex + i].index = -1;
  1:     }
  1: 
  1:     return result;
  1: }
  1: 
  1: 
  1: /*
  1:  *   Consecutive literal characters.
  1:  */
  1: #if 0
  1: static REMatchState *
  1: FlatNMatcher(REGlobalData *gData, REMatchState *x, jschar *matchChars,
  1:              size_t length)
  1: {
  1:     size_t i;
  1:     if (length > gData->cpend - x->cp)
  1:         return NULL;
  1:     for (i = 0; i != length; i++) {
  1:         if (matchChars[i] != x->cp[i])
  1:             return NULL;
  1:     }
  1:     x->cp += length;
  1:     return x;
  1: }
  1: #endif
  1: 
  1: static REMatchState *
  1: FlatNIMatcher(REGlobalData *gData, REMatchState *x, jschar *matchChars,
  1:               size_t length)
  1: {
  1:     size_t i;
  1:     JS_ASSERT(gData->cpend >= x->cp);
  1:     if (length > (size_t)(gData->cpend - x->cp))
  1:         return NULL;
  1:     for (i = 0; i != length; i++) {
  1:         if (upcase(matchChars[i]) != upcase(x->cp[i]))
  1:             return NULL;
  1:     }
  1:     x->cp += length;
  1:     return x;
  1: }
  1: 
  1: /*
  1:  * 1. Evaluate DecimalEscape to obtain an EscapeValue E.
  1:  * 2. If E is not a character then go to step 6.
  1:  * 3. Let ch be E's character.
  1:  * 4. Let A be a one-element RECharSet containing the character ch.
  1:  * 5. Call CharacterSetMatcher(A, false) and return its Matcher result.
  1:  * 6. E must be an integer. Let n be that integer.
  1:  * 7. If n=0 or n>NCapturingParens then throw a SyntaxError exception.
  1:  * 8. Return an internal Matcher closure that takes two arguments, a State x
  1:  *    and a Continuation c, and performs the following:
  1:  *     1. Let cap be x's captures internal array.
  1:  *     2. Let s be cap[n].
  1:  *     3. If s is undefined, then call c(x) and return its result.
  1:  *     4. Let e be x's endIndex.
  1:  *     5. Let len be s's length.
  1:  *     6. Let f be e+len.
  1:  *     7. If f>InputLength, return failure.
  1:  *     8. If there exists an integer i between 0 (inclusive) and len (exclusive)
  1:  *        such that Canonicalize(s[i]) is not the same character as
  1:  *        Canonicalize(Input [e+i]), then return failure.
  1:  *     9. Let y be the State (f, cap).
  1:  *     10. Call c(y) and return its result.
  1:  */
  1: static REMatchState *
  1: BackrefMatcher(REGlobalData *gData, REMatchState *x, size_t parenIndex)
  1: {
  1:     size_t len, i;
  1:     const jschar *parenContent;
  1:     RECapture *cap = &x->parens[parenIndex];
  1: 
  1:     if (cap->index == -1)
  1:         return x;
  1: 
  1:     len = cap->length;
  1:     if (x->cp + len > gData->cpend)
  1:         return NULL;
  1: 
  1:     parenContent = &gData->cpbegin[cap->index];
  1:     if (gData->regexp->flags & JSREG_FOLD) {
  1:         for (i = 0; i < len; i++) {
  1:             if (upcase(parenContent[i]) != upcase(x->cp[i]))
  1:                 return NULL;
  1:         }
  1:     } else {
  1:         for (i = 0; i < len; i++) {
  1:             if (parenContent[i] != x->cp[i])
  1:                 return NULL;
  1:         }
  1:     }
  1:     x->cp += len;
  1:     return x;
  1: }
  1: 
  1: 
  1: /* Add a single character to the RECharSet */
  1: static void
  1: AddCharacterToCharSet(RECharSet *cs, jschar c)
  1: {
  1:     uintN byteIndex = (uintN)(c >> 3);
  1:     JS_ASSERT(c <= cs->length);
  1:     cs->u.bits[byteIndex] |= 1 << (c & 0x7);
  1: }
  1: 
  1: 
  1: /* Add a character range, c1 to c2 (inclusive) to the RECharSet */
  1: static void
  1: AddCharacterRangeToCharSet(RECharSet *cs, jschar c1, jschar c2)
  1: {
  1:     uintN i;
  1: 
  1:     uintN byteIndex1 = (uintN)(c1 >> 3);
  1:     uintN byteIndex2 = (uintN)(c2 >> 3);
  1: 
  1:     JS_ASSERT((c2 <= cs->length) && (c1 <= c2));
  1: 
  1:     c1 &= 0x7;
  1:     c2 &= 0x7;
  1: 
  1:     if (byteIndex1 == byteIndex2) {
  1:         cs->u.bits[byteIndex1] |= ((uint8)0xFF >> (7 - (c2 - c1))) << c1;
  1:     } else {
  1:         cs->u.bits[byteIndex1] |= 0xFF << c1;
  1:         for (i = byteIndex1 + 1; i < byteIndex2; i++)
  1:             cs->u.bits[i] = 0xFF;
  1:         cs->u.bits[byteIndex2] |= (uint8)0xFF >> (7 - c2);
  1:     }
  1: }
  1: 
  1: /* Compile the source of the class into a RECharSet */
  1: static JSBool
  1: ProcessCharSet(REGlobalData *gData, RECharSet *charSet)
  1: {
  1:     const jschar *src, *end;
  1:     JSBool inRange = JS_FALSE;
  1:     jschar rangeStart = 0;
  1:     uintN byteLength, n;
  1:     jschar c, thisCh;
  1:     intN nDigits, i;
  1: 
  1:     JS_ASSERT(!charSet->converted);
  1:     /*
  1:      * Assert that startIndex and length points to chars inside [] inside
  1:      * source string.
  1:      */
  1:     JS_ASSERT(1 <= charSet->u.src.startIndex);
  1:     JS_ASSERT(charSet->u.src.startIndex
  1:               < JSSTRING_LENGTH(gData->regexp->source));
  1:     JS_ASSERT(charSet->u.src.length <= JSSTRING_LENGTH(gData->regexp->source)
  1:                                        - 1 - charSet->u.src.startIndex);
  1: 
  1:     charSet->converted = JS_TRUE;
  1:     src = JSSTRING_CHARS(gData->regexp->source) + charSet->u.src.startIndex;
  1:     end = src + charSet->u.src.length;
  1:     JS_ASSERT(src[-1] == '[');
  1:     JS_ASSERT(end[0] == ']');
  1: 
  1:     byteLength = (charSet->length >> 3) + 1;
  1:     charSet->u.bits = (uint8 *)JS_malloc(gData->cx, byteLength);
  1:     if (!charSet->u.bits) {
  1:         JS_ReportOutOfMemory(gData->cx);
  1:         gData->ok = JS_FALSE;
  1:         return JS_FALSE;
  1:     }
  1:     memset(charSet->u.bits, 0, byteLength);
  1: 
  1:     if (src == end)
  1:         return JS_TRUE;
  1: 
  1:     if (*src == '^') {
  1:         JS_ASSERT(charSet->sense == JS_FALSE);
  1:         ++src;
  1:     } else {
  1:         JS_ASSERT(charSet->sense == JS_TRUE);
  1:     }
  1: 
  1:     while (src != end) {
  1:         switch (*src) {
  1:           case '\\':
  1:             ++src;
  1:             c = *src++;
  1:             switch (c) {
  1:               case 'b':
  1:                 thisCh = 0x8;
  1:                 break;
  1:               case 'f':
  1:                 thisCh = 0xC;
  1:                 break;
  1:               case 'n':
  1:                 thisCh = 0xA;
  1:                 break;
  1:               case 'r':
  1:                 thisCh = 0xD;
  1:                 break;
  1:               case 't':
  1:                 thisCh = 0x9;
  1:                 break;
  1:               case 'v':
  1:                 thisCh = 0xB;
  1:                 break;
  1:               case 'c':
  1:                 if (src < end && JS_ISWORD(*src)) {
  1:                     thisCh = (jschar)(*src++ & 0x1F);
  1:                 } else {
  1:                     --src;
  1:                     thisCh = '\\';
  1:                 }
  1:                 break;
  1:               case 'x':
  1:                 nDigits = 2;
  1:                 goto lexHex;
  1:               case 'u':
  1:                 nDigits = 4;
  1:             lexHex:
  1:                 n = 0;
  1:                 for (i = 0; (i < nDigits) && (src < end); i++) {
  1:                     uintN digit;
  1:                     c = *src++;
  1:                     if (!isASCIIHexDigit(c, &digit)) {
  1:                         /*
  1:                          * Back off to accepting the original '\'
  1:                          * as a literal
  1:                          */
  1:                         src -= i + 1;
  1:                         n = '\\';
  1:                         break;
  1:                     }
  1:                     n = (n << 4) | digit;
  1:                 }
  1:                 thisCh = (jschar)n;
  1:                 break;
  1:               case '0':
  1:               case '1':
  1:               case '2':
  1:               case '3':
  1:               case '4':
  1:               case '5':
  1:               case '6':
  1:               case '7':
  1:                 /*
  1:                  *  This is a non-ECMA extension - decimal escapes (in this
  1:                  *  case, octal!) are supposed to be an error inside class
  1:                  *  ranges, but supported here for backwards compatibility.
  1:                  */
  1:                 n = JS7_UNDEC(c);
  1:                 c = *src;
  1:                 if ('0' <= c && c <= '7') {
  1:                     src++;
  1:                     n = 8 * n + JS7_UNDEC(c);
  1:                     c = *src;
  1:                     if ('0' <= c && c <= '7') {
  1:                         src++;
  1:                         i = 8 * n + JS7_UNDEC(c);
  1:                         if (i <= 0377)
  1:                             n = i;
  1:                         else
  1:                             src--;
  1:                     }
  1:                 }
  1:                 thisCh = (jschar)n;
  1:                 break;
  1: 
  1:               case 'd':
  1:                 AddCharacterRangeToCharSet(charSet, '0', '9');
  1:                 continue;   /* don't need range processing */
  1:               case 'D':
  1:                 AddCharacterRangeToCharSet(charSet, 0, '0' - 1);
  1:                 AddCharacterRangeToCharSet(charSet,
  1:                                            (jschar)('9' + 1),
  1:                                            (jschar)charSet->length);
  1:                 continue;
  1:               case 's':
  1:                 for (i = (intN)charSet->length; i >= 0; i--)
  1:                     if (JS_ISSPACE(i))
  1:                         AddCharacterToCharSet(charSet, (jschar)i);
  1:                 continue;
  1:               case 'S':
  1:                 for (i = (intN)charSet->length; i >= 0; i--)
  1:                     if (!JS_ISSPACE(i))
  1:                         AddCharacterToCharSet(charSet, (jschar)i);
  1:                 continue;
  1:               case 'w':
  1:                 for (i = (intN)charSet->length; i >= 0; i--)
  1:                     if (JS_ISWORD(i))
  1:                         AddCharacterToCharSet(charSet, (jschar)i);
  1:                 continue;
  1:               case 'W':
  1:                 for (i = (intN)charSet->length; i >= 0; i--)
  1:                     if (!JS_ISWORD(i))
  1:                         AddCharacterToCharSet(charSet, (jschar)i);
  1:                 continue;
  1:               default:
  1:                 thisCh = c;
  1:                 break;
  1: 
  1:             }
  1:             break;
  1: 
  1:           default:
  1:             thisCh = *src++;
  1:             break;
  1: 
  1:         }
  1:         if (inRange) {
  1:             if (gData->regexp->flags & JSREG_FOLD) {
  1:                 AddCharacterRangeToCharSet(charSet, upcase(rangeStart),
  1:                                                     upcase(thisCh));
  1:                 AddCharacterRangeToCharSet(charSet, downcase(rangeStart),
  1:                                                     downcase(thisCh));
  1:             } else {
  1:                 AddCharacterRangeToCharSet(charSet, rangeStart, thisCh);
  1:             }
  1:             inRange = JS_FALSE;
  1:         } else {
  1:             if (gData->regexp->flags & JSREG_FOLD) {
  1:                 AddCharacterToCharSet(charSet, upcase(thisCh));
  1:                 AddCharacterToCharSet(charSet, downcase(thisCh));
  1:             } else {
  1:                 AddCharacterToCharSet(charSet, thisCh);
  1:             }
  1:             if (src < end - 1) {
  1:                 if (*src == '-') {
  1:                     ++src;
  1:                     inRange = JS_TRUE;
  1:                     rangeStart = thisCh;
  1:                 }
  1:             }
  1:         }
  1:     }
  1:     return JS_TRUE;
  1: }
  1: 
  1: void
  1: js_DestroyRegExp(JSContext *cx, JSRegExp *re)
  1: {
  1:     if (JS_ATOMIC_DECREMENT(&re->nrefs) == 0) {
  1:         if (re->classList) {
  1:             uintN i;
  1:             for (i = 0; i < re->classCount; i++) {
  1:                 if (re->classList[i].converted)
  1:                     JS_free(cx, re->classList[i].u.bits);
  1:                 re->classList[i].u.bits = NULL;
  1:             }
  1:             JS_free(cx, re->classList);
  1:         }
  1:         JS_free(cx, re);
  1:     }
  1: }
  1: 
  1: static JSBool
  1: ReallocStateStack(REGlobalData *gData)
  1: {
  1:     size_t limit = gData->stateStackLimit;
  1:     size_t sz = sizeof(REProgState) * limit;
  1: 
  1:     JS_ARENA_GROW_CAST(gData->stateStack, REProgState *, &gData->pool, sz, sz);
  1:     if (!gData->stateStack) {
  1:         gData->ok = JS_FALSE;
  1:         return JS_FALSE;
  1:     }
  1:     gData->stateStackLimit = limit + limit;
  1:     return JS_TRUE;
  1: }
  1: 
  1: #define PUSH_STATE_STACK(data)                                                \
  1:     JS_BEGIN_MACRO                                                            \
  1:         ++(data)->stateStackTop;                                              \
  1:         if ((data)->stateStackTop == (data)->stateStackLimit &&               \
  1:             !ReallocStateStack((data))) {                                     \
  1:             return NULL;                                                      \
  1:         }                                                                     \
  1:     JS_END_MACRO
  1: 
  1: /*
  1:  * Apply the current op against the given input to see if it's going to match
  1:  * or fail. Return false if we don't get a match, true if we do. If updatecp is
  1:  * true, then update the current state's cp. Always update startpc to the next
  1:  * op.
  1:  */
  1: static REMatchState *
  1: SimpleMatch(REGlobalData *gData, REMatchState *x, REOp op,
  1:             jsbytecode **startpc, JSBool updatecp)
  1: {
  1:     REMatchState *result = NULL;
  1:     jschar matchCh;
  1:     size_t parenIndex;
  1:     size_t offset, length, index;
  1:     jsbytecode *pc = *startpc;  /* pc has already been incremented past op */
  1:     jschar *source;
  1:     const jschar *startcp = x->cp;
  1:     jschar ch;
  1:     RECharSet *charSet;
  1: 
 22: #ifdef REGEXP_DEBUG
 22:     const char *opname = reop_names[op];
 22:     re_debug("\n%06d: %*s%s", pc - gData->regexp->program,
 22:              gData->stateStackTop * 2, "", opname);
 22: #endif
  1:     switch (op) {
  1:       case REOP_EMPTY:
  1:         result = x;
  1:         break;
  1:       case REOP_BOL:
  1:         if (x->cp != gData->cpbegin) {
  1:             if (!gData->cx->regExpStatics.multiline &&
  1:                 !(gData->regexp->flags & JSREG_MULTILINE)) {
  1:                 break;
  1:             }
  1:             if (!RE_IS_LINE_TERM(x->cp[-1]))
  1:                 break;
  1:         }
  1:         result = x;
  1:         break;
  1:       case REOP_EOL:
  1:         if (x->cp != gData->cpend) {
  1:             if (!gData->cx->regExpStatics.multiline &&
  1:                 !(gData->regexp->flags & JSREG_MULTILINE)) {
  1:                 break;
  1:             }
  1:             if (!RE_IS_LINE_TERM(*x->cp))
  1:                 break;
  1:         }
  1:         result = x;
  1:         break;
  1:       case REOP_WBDRY:
  1:         if ((x->cp == gData->cpbegin || !JS_ISWORD(x->cp[-1])) ^
  1:             !(x->cp != gData->cpend && JS_ISWORD(*x->cp))) {
  1:             result = x;
  1:         }
  1:         break;
  1:       case REOP_WNONBDRY:
  1:         if ((x->cp == gData->cpbegin || !JS_ISWORD(x->cp[-1])) ^
  1:             (x->cp != gData->cpend && JS_ISWORD(*x->cp))) {
  1:             result = x;
  1:         }
  1:         break;
  1:       case REOP_DOT:
  1:         if (x->cp != gData->cpend && !RE_IS_LINE_TERM(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_DIGIT:
  1:         if (x->cp != gData->cpend && JS_ISDIGIT(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_NONDIGIT:
  1:         if (x->cp != gData->cpend && !JS_ISDIGIT(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_ALNUM:
  1:         if (x->cp != gData->cpend && JS_ISWORD(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_NONALNUM:
  1:         if (x->cp != gData->cpend && !JS_ISWORD(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_SPACE:
  1:         if (x->cp != gData->cpend && JS_ISSPACE(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_NONSPACE:
  1:         if (x->cp != gData->cpend && !JS_ISSPACE(*x->cp)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_BACKREF:
  1:         pc = ReadCompactIndex(pc, &parenIndex);
  1:         JS_ASSERT(parenIndex < gData->regexp->parenCount);
  1:         result = BackrefMatcher(gData, x, parenIndex);
  1:         break;
  1:       case REOP_FLAT:
  1:         pc = ReadCompactIndex(pc, &offset);
  1:         JS_ASSERT(offset < JSSTRING_LENGTH(gData->regexp->source));
  1:         pc = ReadCompactIndex(pc, &length);
  1:         JS_ASSERT(1 <= length);
  1:         JS_ASSERT(length <= JSSTRING_LENGTH(gData->regexp->source) - offset);
  1:         if (length <= (size_t)(gData->cpend - x->cp)) {
  1:             source = JSSTRING_CHARS(gData->regexp->source) + offset;
 22:             re_debug_chars(source, length);
  1:             for (index = 0; index != length; index++) {
  1:                 if (source[index] != x->cp[index])
  1:                     return NULL;
  1:             }
  1:             x->cp += length;
  1:             result = x;
  1:         }
  1:         break;
  1:       case REOP_FLAT1:
  1:         matchCh = *pc++;
 22:         re_debug(" '%c' == '%c'", (char)matchCh, (char)*x->cp);
  1:         if (x->cp != gData->cpend && *x->cp == matchCh) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_FLATi:
  1:         pc = ReadCompactIndex(pc, &offset);
  1:         JS_ASSERT(offset < JSSTRING_LENGTH(gData->regexp->source));
  1:         pc = ReadCompactIndex(pc, &length);
  1:         JS_ASSERT(1 <= length);
  1:         JS_ASSERT(length <= JSSTRING_LENGTH(gData->regexp->source) - offset);
  1:         source = JSSTRING_CHARS(gData->regexp->source);
  1:         result = FlatNIMatcher(gData, x, source + offset, length);
  1:         break;
  1:       case REOP_FLAT1i:
  1:         matchCh = *pc++;
  1:         if (x->cp != gData->cpend && upcase(*x->cp) == upcase(matchCh)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_UCFLAT1:
  1:         matchCh = GET_ARG(pc);
 22:         re_debug(" '%c' == '%c'", (char)matchCh, (char)*x->cp);
  1:         pc += ARG_LEN;
  1:         if (x->cp != gData->cpend && *x->cp == matchCh) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_UCFLAT1i:
  1:         matchCh = GET_ARG(pc);
  1:         pc += ARG_LEN;
  1:         if (x->cp != gData->cpend && upcase(*x->cp) == upcase(matchCh)) {
  1:             result = x;
  1:             result->cp++;
  1:         }
  1:         break;
  1:       case REOP_CLASS:
  1:         pc = ReadCompactIndex(pc, &index);
  1:         JS_ASSERT(index < gData->regexp->classCount);
  1:         if (x->cp != gData->cpend) {
  1:             charSet = &gData->regexp->classList[index];
  1:             JS_ASSERT(charSet->converted);
  1:             ch = *x->cp;
  1:             index = ch >> 3;
  1:             if (charSet->length != 0 &&
  1:                 ch <= charSet->length &&
  1:                 (charSet->u.bits[index] & (1 << (ch & 0x7)))) {
  1:                 result = x;
  1:                 result->cp++;
  1:             }
  1:         }
  1:         break;
  1:       case REOP_NCLASS:
  1:         pc = ReadCompactIndex(pc, &index);
  1:         JS_ASSERT(index < gData->regexp->classCount);
  1:         if (x->cp != gData->cpend) {
  1:             charSet = &gData->regexp->classList[index];
  1:             JS_ASSERT(charSet->converted);
  1:             ch = *x->cp;
  1:             index = ch >> 3;
  1:             if (charSet->length == 0 ||
  1:                 ch > charSet->length ||
  1:                 !(charSet->u.bits[index] & (1 << (ch & 0x7)))) {
  1:                 result = x;
  1:                 result->cp++;
  1:             }
  1:         }
  1:         break;
  1: 
  1:       default:
  1:         JS_ASSERT(JS_FALSE);
  1:     }
  1:     if (result) {
  1:         if (!updatecp)
  1:             x->cp = startcp;
  1:         *startpc = pc;
 22:         re_debug(" * ");
  1:         return result;
  1:     }
  1:     x->cp = startcp;
  1:     return NULL;
  1: }
  1: 
  1: static REMatchState *
  1: ExecuteREBytecode(REGlobalData *gData, REMatchState *x)
  1: {
  1:     REMatchState *result = NULL;
  1:     REBackTrackData *backTrackData;
  1:     jsbytecode *nextpc, *testpc;
  1:     REOp nextop;
  1:     RECapture *cap;
  1:     REProgState *curState;
  1:     const jschar *startcp;
  1:     size_t parenIndex, k;
  1:     size_t parenSoFar = 0;
  1: 
  1:     jschar matchCh1, matchCh2;
  1:     RECharSet *charSet;
  1: 
  1:     JSBool anchor;
  1:     jsbytecode *pc = gData->regexp->program;
  1:     REOp op = (REOp) *pc++;
  1: 
  1:     /*
  1:      * If the first node is a simple match, step the index into the string
  1:      * until that match is made, or fail if it can't be found at all.
  1:      */
  1:     if (REOP_IS_SIMPLE(op) && !(gData->regexp->flags & JSREG_STICKY)) {
  1:         anchor = JS_FALSE;
  1:         while (x->cp <= gData->cpend) {
  1:             nextpc = pc;    /* reset back to start each time */
  1:             result = SimpleMatch(gData, x, op, &nextpc, JS_TRUE);
  1:             if (result) {
  1:                 anchor = JS_TRUE;
  1:                 x = result;
  1:                 pc = nextpc;    /* accept skip to next opcode */
  1:                 op = (REOp) *pc++;
  1:                 JS_ASSERT(op < REOP_LIMIT);
  1:                 break;
  1:             }
  1:             gData->skipped++;
  1:             x->cp++;
  1:         }
  1:         if (!anchor)
 22:             goto bad;
  1:     }
  1: 
  1:     for (;;) {
 22: #ifdef REGEXP_DEBUG
 22:         const char *opname = reop_names[op];
 22:         re_debug("\n%06d: %*s%s", pc - gData->regexp->program,
 22:                  gData->stateStackTop * 2, "", opname);
 22: #endif
  1:         if (REOP_IS_SIMPLE(op)) {
  1:             result = SimpleMatch(gData, x, op, &pc, JS_TRUE);
  1:         } else {
  1:             curState = &gData->stateStack[gData->stateStackTop];
  1:             switch (op) {
  1:               case REOP_END:
 22:                 goto good;
  1:               case REOP_ALTPREREQ2:
  1:                 nextpc = pc + GET_OFFSET(pc);   /* start of next op */
  1:                 pc += ARG_LEN;
  1:                 matchCh2 = GET_ARG(pc);
  1:                 pc += ARG_LEN;
  1:                 k = GET_ARG(pc);
  1:                 pc += ARG_LEN;
  1: 
  1:                 if (x->cp != gData->cpend) {
  1:                     if (*x->cp == matchCh2)
  1:                         goto doAlt;
  1: 
  1:                     charSet = &gData->regexp->classList[k];
  1:                     if (!charSet->converted && !ProcessCharSet(gData, charSet))
 22:                         goto bad;
  1:                     matchCh1 = *x->cp;
  1:                     k = matchCh1 >> 3;
  1:                     if ((charSet->length == 0 ||
  1:                          matchCh1 > charSet->length ||
  1:                          !(charSet->u.bits[k] & (1 << (matchCh1 & 0x7)))) ^
  1:                         charSet->sense) {
  1:                         goto doAlt;
  1:                     }
  1:                 }
  1:                 result = NULL;
  1:                 break;
  1: 
  1:               case REOP_ALTPREREQ:
  1:                 nextpc = pc + GET_OFFSET(pc);   /* start of next op */
  1:                 pc += ARG_LEN;
  1:                 matchCh1 = GET_ARG(pc);
  1:                 pc += ARG_LEN;
  1:                 matchCh2 = GET_ARG(pc);
  1:                 pc += ARG_LEN;
  1:                 if (x->cp == gData->cpend ||
  1:                     (*x->cp != matchCh1 && *x->cp != matchCh2)) {
  1:                     result = NULL;
  1:                     break;
  1:                 }
  1:                 /* else false thru... */
  1: 
  1:               case REOP_ALT:
  1:               doAlt:
  1:                 nextpc = pc + GET_OFFSET(pc);   /* start of next alternate */
  1:                 pc += ARG_LEN;                  /* start of this alternate */
  1:                 curState->parenSoFar = parenSoFar;
  1:                 PUSH_STATE_STACK(gData);
  1:                 op = (REOp) *pc++;
  1:                 startcp = x->cp;
  1:                 if (REOP_IS_SIMPLE(op)) {
  1:                     if (!SimpleMatch(gData, x, op, &pc, JS_TRUE)) {
  1:                         op = (REOp) *nextpc++;
  1:                         pc = nextpc;
  1:                         continue;
  1:                     }
  1:                     result = x;
  1:                     op = (REOp) *pc++;
  1:                 }
  1:                 nextop = (REOp) *nextpc++;
  1:                 if (!PushBackTrackState(gData, nextop, nextpc, x, startcp, 0, 0))
 22:                     goto bad;
  1:                 continue;
  1: 
  1:               /*
  1:                * Occurs at (successful) end of REOP_ALT,
  1:                */
  1:               case REOP_JUMP:
  1:                 /*
  1:                  * If we have not gotten a result here, it is because of an
  1:                  * empty match.  Do the same thing REOP_EMPTY would do.
  1:                  */
  1:                 if (!result)
  1:                     result = x;
  1: 
  1:                 --gData->stateStackTop;
  1:                 pc += GET_OFFSET(pc);
  1:                 op = (REOp) *pc++;
  1:                 continue;
  1: 
  1:               /*
  1:                * Occurs at last (successful) end of REOP_ALT,
  1:                */
  1:               case REOP_ENDALT:
  1:                 /*
  1:                  * If we have not gotten a result here, it is because of an
  1:                  * empty match.  Do the same thing REOP_EMPTY would do.
  1:                  */
  1:                 if (!result)
  1:                     result = x;
  1: 
  1:                 --gData->stateStackTop;
  1:                 op = (REOp) *pc++;
  1:                 continue;
  1: 
  1:               case REOP_LPAREN:
  1:                 pc = ReadCompactIndex(pc, &parenIndex);
211:                 re_debug("[ %lu ]", (unsigned long) parenIndex);
  1:                 JS_ASSERT(parenIndex < gData->regexp->parenCount);
  1:                 if (parenIndex + 1 > parenSoFar)
  1:                     parenSoFar = parenIndex + 1;
  1:                 x->parens[parenIndex].index = x->cp - gData->cpbegin;
  1:                 x->parens[parenIndex].length = 0;
  1:                 op = (REOp) *pc++;
  1:                 continue;
  1: 
  1:               case REOP_RPAREN:
  1:                 pc = ReadCompactIndex(pc, &parenIndex);
  1:                 JS_ASSERT(parenIndex < gData->regexp->parenCount);
  1:                 cap = &x->parens[parenIndex];
  1:                 cap->length = x->cp - (gData->cpbegin + cap->index);
  1:                 op = (REOp) *pc++;
 38: 
 38:                 if (!result)
 38:                     result = x;
  1:                 continue;
  1: 
  1:               case REOP_ASSERT:
  1:                 nextpc = pc + GET_OFFSET(pc);  /* start of term after ASSERT */
  1:                 pc += ARG_LEN;                 /* start of ASSERT child */
  1:                 op = (REOp) *pc++;
  1:                 testpc = pc;
  1:                 if (REOP_IS_SIMPLE(op) &&
  1:                     !SimpleMatch(gData, x, op, &testpc, JS_FALSE)) {
  1:                     result = NULL;
  1:                     break;
  1:                 }
  1:                 curState->u.assertion.top =
  1:                     (char *)gData->backTrackSP - (char *)gData->backTrackStack;
  1:                 curState->u.assertion.sz = gData->cursz;
  1:                 curState->index = x->cp - gData->cpbegin;
  1:                 curState->parenSoFar = parenSoFar;
  1:                 PUSH_STATE_STACK(gData);
  1:                 if (!PushBackTrackState(gData, REOP_ASSERTTEST,
  1:                                         nextpc, x, x->cp, 0, 0)) {
 22:                     goto bad;
  1:                 }
  1:                 continue;
  1: 
  1:               case REOP_ASSERT_NOT:
  1:                 nextpc = pc + GET_OFFSET(pc);
  1:                 pc += ARG_LEN;
  1:                 op = (REOp) *pc++;
  1:                 testpc = pc;
  1:                 if (REOP_IS_SIMPLE(op) /* Note - fail to fail! */ &&
  1:                     SimpleMatch(gData, x, op, &testpc, JS_FALSE) &&
  1:                     *testpc == REOP_ASSERTNOTTEST) {
  1:                     result = NULL;
  1:                     break;
  1:                 }
  1:                 curState->u.assertion.top
  1:                     = (char *)gData->backTrackSP -
  1:                       (char *)gData->backTrackStack;
  1:                 curState->u.assertion.sz = gData->cursz;
  1:                 curState->index = x->cp - gData->cpbegin;
  1:                 curState->parenSoFar = parenSoFar;
  1:                 PUSH_STATE_STACK(gData);
  1:                 if (!PushBackTrackState(gData, REOP_ASSERTNOTTEST,
  1:                                         nextpc, x, x->cp, 0, 0)) {
 22:                     goto bad;
  1:                 }
  1:                 continue;
  1: 
  1:               case REOP_ASSERTTEST:
  1:                 --gData->stateStackTop;
  1:                 --curState;
  1:                 x->cp = gData->cpbegin + curState->index;
  1:                 gData->backTrackSP =
  1:                     (REBackTrackData *) ((char *)gData->backTrackStack +
  1:                                          curState->u.assertion.top);
  1:                 gData->cursz = curState->u.assertion.sz;
  1:                 if (result)
  1:                     result = x;
  1:                 break;
  1: 
  1:               case REOP_ASSERTNOTTEST:
  1:                 --gData->stateStackTop;
  1:                 --curState;
  1:                 x->cp = gData->cpbegin + curState->index;
  1:                 gData->backTrackSP =
  1:                     (REBackTrackData *) ((char *)gData->backTrackStack +
  1:                                          curState->u.assertion.top);
  1:                 gData->cursz = curState->u.assertion.sz;
  1:                 result = (!result) ? x : NULL;
  1:                 break;
  1:               case REOP_STAR:
  1:                 curState->u.quantifier.min = 0;
  1:                 curState->u.quantifier.max = (uintN)-1;
  1:                 goto quantcommon;
  1:               case REOP_PLUS:
  1:                 curState->u.quantifier.min = 1;
  1:                 curState->u.quantifier.max = (uintN)-1;
  1:                 goto quantcommon;
  1:               case REOP_OPT:
  1:                 curState->u.quantifier.min = 0;
  1:                 curState->u.quantifier.max = 1;
  1:                 goto quantcommon;
  1:               case REOP_QUANT:
  1:                 pc = ReadCompactIndex(pc, &k);
  1:                 curState->u.quantifier.min = k;
  1:                 pc = ReadCompactIndex(pc, &k);
  1:                 /* max is k - 1 to use one byte for (uintN)-1 sentinel. */
  1:                 curState->u.quantifier.max = k - 1;
  1:                 JS_ASSERT(curState->u.quantifier.min
  1:                           <= curState->u.quantifier.max);
  1:               quantcommon:
  1:                 if (curState->u.quantifier.max == 0) {
  1:                     pc = pc + GET_OFFSET(pc);
  1:                     op = (REOp) *pc++;
  1:                     result = x;
  1:                     continue;
  1:                 }
  1:                 /* Step over <next> */
  1:                 nextpc = pc + ARG_LEN;
  1:                 op = (REOp) *nextpc++;
  1:                 startcp = x->cp;
  1:                 if (REOP_IS_SIMPLE(op)) {
  1:                     if (!SimpleMatch(gData, x, op, &nextpc, JS_TRUE)) {
  1:                         if (curState->u.quantifier.min == 0)
  1:                             result = x;
  1:                         else
  1:                             result = NULL;
  1:                         pc = pc + GET_OFFSET(pc);
  1:                         break;
  1:                     }
  1:                     op = (REOp) *nextpc++;
  1:                     result = x;
  1:                 }
  1:                 curState->index = startcp - gData->cpbegin;
  1:                 curState->continue_op = REOP_REPEAT;
  1:                 curState->continue_pc = pc;
  1:                 curState->parenSoFar = parenSoFar;
  1:                 PUSH_STATE_STACK(gData);
  1:                 if (curState->u.quantifier.min == 0 &&
  1:                     !PushBackTrackState(gData, REOP_REPEAT, pc, x, startcp,
  1:                                         0, 0)) {
 22:                     goto bad;
  1:                 }
  1:                 pc = nextpc;
  1:                 continue;
  1: 
  1:               case REOP_ENDCHILD: /* marks the end of a quantifier child */
  1:                 pc = curState[-1].continue_pc;
  1:                 op = curState[-1].continue_op;
  1:                 continue;
  1: 
  1:               case REOP_REPEAT:
  1:                 --curState;
  1:                 do {
  1:                     --gData->stateStackTop;
  1:                     if (!result) {
  1:                         /* Failed, see if we have enough children. */
  1:                         if (curState->u.quantifier.min == 0)
  1:                             goto repeatDone;
  1:                         goto break_switch;
  1:                     }
  1:                     if (curState->u.quantifier.min == 0 &&
  1:                         x->cp == gData->cpbegin + curState->index) {
  1:                         /* matched an empty string, that'll get us nowhere */
  1:                         result = NULL;
  1:                         goto break_switch;
  1:                     }
  1:                     if (curState->u.quantifier.min != 0)
  1:                         curState->u.quantifier.min--;
  1:                     if (curState->u.quantifier.max != (uintN) -1)
  1:                         curState->u.quantifier.max--;
  1:                     if (curState->u.quantifier.max == 0)
  1:                         goto repeatDone;
  1:                     nextpc = pc + ARG_LEN;
  1:                     nextop = (REOp) *nextpc;
  1:                     startcp = x->cp;
  1:                     if (REOP_IS_SIMPLE(nextop)) {
  1:                         nextpc++;
  1:                         if (!SimpleMatch(gData, x, nextop, &nextpc, JS_TRUE)) {
  1:                             if (curState->u.quantifier.min == 0)
  1:                                 goto repeatDone;
  1:                             result = NULL;
  1:                             goto break_switch;
  1:                         }
  1:                         result = x;
  1:                     }
  1:                     curState->index = startcp - gData->cpbegin;
  1:                     PUSH_STATE_STACK(gData);
  1:                     if (curState->u.quantifier.min == 0 &&
  1:                         !PushBackTrackState(gData, REOP_REPEAT,
  1:                                             pc, x, startcp,
  1:                                             curState->parenSoFar,
  1:                                             parenSoFar -
  1:                                             curState->parenSoFar)) {
 22:                         goto bad;
  1:                     }
  1:                 } while (*nextpc == REOP_ENDCHILD);
  1:                 pc = nextpc;
  1:                 op = (REOp) *pc++;
  1:                 parenSoFar = curState->parenSoFar;
  1:                 continue;
  1: 
  1:               repeatDone:
  1:                 result = x;
  1:                 pc += GET_OFFSET(pc);
  1:                 goto break_switch;
  1: 
  1:               case REOP_MINIMALSTAR:
  1:                 curState->u.quantifier.min = 0;
  1:                 curState->u.quantifier.max = (uintN)-1;
  1:                 goto minimalquantcommon;
  1:               case REOP_MINIMALPLUS:
  1:                 curState->u.quantifier.min = 1;
  1:                 curState->u.quantifier.max = (uintN)-1;
  1:                 goto minimalquantcommon;
  1:               case REOP_MINIMALOPT:
  1:                 curState->u.quantifier.min = 0;
  1:                 curState->u.quantifier.max = 1;
  1:                 goto minimalquantcommon;
  1:               case REOP_MINIMALQUANT:
  1:                 pc = ReadCompactIndex(pc, &k);
  1:                 curState->u.quantifier.min = k;
  1:                 pc = ReadCompactIndex(pc, &k);
  1:                 /* See REOP_QUANT comments about k - 1. */
  1:                 curState->u.quantifier.max = k - 1;
  1:                 JS_ASSERT(curState->u.quantifier.min
  1:                           <= curState->u.quantifier.max);
  1:               minimalquantcommon:
  1:                 curState->index = x->cp - gData->cpbegin;
  1:                 curState->parenSoFar = parenSoFar;
  1:                 PUSH_STATE_STACK(gData);
  1:                 if (curState->u.quantifier.min != 0) {
  1:                     curState->continue_op = REOP_MINIMALREPEAT;
  1:                     curState->continue_pc = pc;
  1:                     /* step over <next> */
  1:                     pc += OFFSET_LEN;
  1:                     op = (REOp) *pc++;
  1:                 } else {
  1:                     if (!PushBackTrackState(gData, REOP_MINIMALREPEAT,
  1:                                             pc, x, x->cp, 0, 0)) {
 22:                         goto bad;
  1:                     }
  1:                     --gData->stateStackTop;
  1:                     pc = pc + GET_OFFSET(pc);
  1:                     op = (REOp) *pc++;
  1:                 }
  1:                 continue;
  1: 
  1:               case REOP_MINIMALREPEAT:
  1:                 --gData->stateStackTop;
  1:                 --curState;
  1: 
 22:                 re_debug("{%d,%d}", curState->u.quantifier.min,
 22:                          curState->u.quantifier.max);
 22: #define PREPARE_REPEAT()                                                      \
 22:     JS_BEGIN_MACRO                                                            \
 22:         curState->index = x->cp - gData->cpbegin;                             \
 22:         curState->continue_op = REOP_MINIMALREPEAT;                           \
 22:         curState->continue_pc = pc;                                           \
 22:         pc += ARG_LEN;                                                        \
 22:         for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
 22:             x->parens[k].index = -1;                                          \
 22:         PUSH_STATE_STACK(gData);                                              \
 22:         op = (REOp) *pc++;                                                    \
 22:         JS_ASSERT(op < REOP_LIMIT);                                           \
 22:     JS_END_MACRO
 22: 
  1:                 if (!result) {
 22:                     re_debug(" - ");
  1:                     /*
  1:                      * Non-greedy failure - try to consume another child.
  1:                      */
  1:                     if (curState->u.quantifier.max == (uintN) -1 ||
  1:                         curState->u.quantifier.max > 0) {
 22:                         PREPARE_REPEAT();
  1:                         continue;
  1:                     }
  1:                     /* Don't need to adjust pc since we're going to pop. */
  1:                     break;
  1:                 }
  1:                 if (curState->u.quantifier.min == 0 &&
  1:                     x->cp == gData->cpbegin + curState->index) {
  1:                     /* Matched an empty string, that'll get us nowhere. */
  1:                     result = NULL;
  1:                     break;
  1:                 }
  1:                 if (curState->u.quantifier.min != 0)
  1:                     curState->u.quantifier.min--;
  1:                 if (curState->u.quantifier.max != (uintN) -1)
  1:                     curState->u.quantifier.max--;
  1:                 if (curState->u.quantifier.min != 0) {
 22:                     PREPARE_REPEAT();
  1:                     continue;
  1:                 }
  1:                 curState->index = x->cp - gData->cpbegin;
  1:                 curState->parenSoFar = parenSoFar;
  1:                 PUSH_STATE_STACK(gData);
  1:                 if (!PushBackTrackState(gData, REOP_MINIMALREPEAT,
  1:                                         pc, x, x->cp,
  1:                                         curState->parenSoFar,
  1:                                         parenSoFar - curState->parenSoFar)) {
 22:                     goto bad;
  1:                 }
  1:                 --gData->stateStackTop;
  1:                 pc = pc + GET_OFFSET(pc);
  1:                 op = (REOp) *pc++;
  1:                 JS_ASSERT(op < REOP_LIMIT);
  1:                 continue;
  1:               default:
  1:                 JS_ASSERT(JS_FALSE);
  1:                 result = NULL;
  1:             }
  1:           break_switch:;
  1:         }
  1: 
  1:         /*
  1:          *  If the match failed and there's a backtrack option, take it.
  1:          *  Otherwise this is a complete and utter failure.
  1:          */
  1:         if (!result) {
  1:             if (gData->cursz == 0)
  1:                 return NULL;
  1:             if (!JS_CHECK_OPERATION_LIMIT(gData->cx, JSOW_JUMP)) {
  1:                 gData->ok = JS_FALSE;
  1:                 return NULL;
  1:             }
  1: 
  1:             /* Potentially detect explosive regex here. */
  1:             gData->backTrackCount++;
  1:             if (gData->backTrackLimit &&
  1:                 gData->backTrackCount >= gData->backTrackLimit) {
  1:                 JS_ReportErrorNumber(gData->cx, js_GetErrorMessage, NULL,
  1:                                      JSMSG_REGEXP_TOO_COMPLEX);
  1:                 gData->ok = JS_FALSE;
  1:                 return NULL;
  1:             }
  1: 
  1:             backTrackData = gData->backTrackSP;
  1:             gData->cursz = backTrackData->sz;
  1:             gData->backTrackSP =
  1:                 (REBackTrackData *) ((char *)backTrackData - backTrackData->sz);
  1:             x->cp = backTrackData->cp;
  1:             pc = backTrackData->backtrack_pc;
  1:             op = backTrackData->backtrack_op;
  1:             JS_ASSERT(op < REOP_LIMIT);
  1:             gData->stateStackTop = backTrackData->saveStateStackTop;
  1:             JS_ASSERT(gData->stateStackTop);
  1: 
  1:             memcpy(gData->stateStack, backTrackData + 1,
  1:                    sizeof(REProgState) * backTrackData->saveStateStackTop);
  1:             curState = &gData->stateStack[gData->stateStackTop - 1];
  1: 
  1:             if (backTrackData->parenCount) {
  1:                 memcpy(&x->parens[backTrackData->parenIndex],
  1:                        (char *)(backTrackData + 1) +
  1:                        sizeof(REProgState) * backTrackData->saveStateStackTop,
  1:                        sizeof(RECapture) * backTrackData->parenCount);
  1:                 parenSoFar = backTrackData->parenIndex + backTrackData->parenCount;
  1:             } else {
  1:                 for (k = curState->parenSoFar; k < parenSoFar; k++)
  1:                     x->parens[k].index = -1;
  1:                 parenSoFar = curState->parenSoFar;
  1:             }
 22: 
211:             re_debug("\tBT_Pop: %ld,%ld",
211:                      (unsigned long) backTrackData->parenIndex,
211:                      (unsigned long) backTrackData->parenCount);
  1:             continue;
  1:         }
  1:         x = result;
  1: 
  1:         /*
  1:          *  Continue with the expression.
  1:          */
  1:         op = (REOp)*pc++;
  1:         JS_ASSERT(op < REOP_LIMIT);
  1:     }
 22: 
 22: bad:            
 22:     re_debug("\n");
  1:     return NULL;
 22:               
 22: good:           
 22:     re_debug("\n");
 22:     return x;   
  1: }
  1: 
  1: static REMatchState *
  1: MatchRegExp(REGlobalData *gData, REMatchState *x)
  1: {
  1:     REMatchState *result;
  1:     const jschar *cp = x->cp;
  1:     const jschar *cp2;
  1:     uintN j;
  1: 
  1:     /*
  1:      * Have to include the position beyond the last character
  1:      * in order to detect end-of-input/line condition.
  1:      */
  1:     for (cp2 = cp; cp2 <= gData->cpend; cp2++) {
  1:         gData->skipped = cp2 - cp;
  1:         x->cp = cp2;
  1:         for (j = 0; j < gData->regexp->parenCount; j++)
  1:             x->parens[j].index = -1;
  1:         result = ExecuteREBytecode(gData, x);
  1:         if (!gData->ok || result || (gData->regexp->flags & JSREG_STICKY))
  1:             return result;
  1:         gData->backTrackSP = gData->backTrackStack;
  1:         gData->cursz = 0;
  1:         gData->stateStackTop = 0;
  1:         cp2 = cp + gData->skipped;
  1:     }
  1:     return NULL;
  1: }
  1: 
  1: #define MIN_BACKTRACK_LIMIT 400000
  1: 
  1: static REMatchState *
  1: InitMatch(JSContext *cx, REGlobalData *gData, JSRegExp *re, size_t length)
  1: {
  1:     REMatchState *result;
  1:     uintN i;
  1: 
  1:     gData->backTrackStackSize = INITIAL_BACKTRACK;
  1:     JS_ARENA_ALLOCATE_CAST(gData->backTrackStack, REBackTrackData *,
  1:                            &gData->pool,
  1:                            INITIAL_BACKTRACK);
  1:     if (!gData->backTrackStack)
  1:         goto bad;
  1: 
  1:     gData->backTrackSP = gData->backTrackStack;
  1:     gData->cursz = 0;
  1:     gData->backTrackCount = 0;
  1:     gData->backTrackLimit = 0;
  1:     if (JS_GetOptions(cx) & JSOPTION_RELIMIT) {
  1:         gData->backTrackLimit = length * length * length; /* O(n^3) */
  1:         if (gData->backTrackLimit < MIN_BACKTRACK_LIMIT)
  1:             gData->backTrackLimit = MIN_BACKTRACK_LIMIT;
  1:     }
  1: 
  1:     gData->stateStackLimit = INITIAL_STATESTACK;
  1:     JS_ARENA_ALLOCATE_CAST(gData->stateStack, REProgState *,
  1:                            &gData->pool,
  1:                            sizeof(REProgState) * INITIAL_STATESTACK);
  1:     if (!gData->stateStack)
  1:         goto bad;
  1: 
  1:     gData->stateStackTop = 0;
  1:     gData->cx = cx;
  1:     gData->regexp = re;
  1:     gData->ok = JS_TRUE;
  1: 
  1:     JS_ARENA_ALLOCATE_CAST(result, REMatchState *,
  1:                            &gData->pool,
  1:                            offsetof(REMatchState, parens)
  1:                            + re->parenCount * sizeof(RECapture));
  1:     if (!result)
  1:         goto bad;
  1: 
  1:     for (i = 0; i < re->classCount; i++) {
  1:         if (!re->classList[i].converted &&
  1:             !ProcessCharSet(gData, &re->classList[i])) {
  1:             return NULL;
  1:         }
  1:     }
  1: 
  1:     return result;
  1: 
  1: bad:
  1:     JS_ReportOutOfMemory(cx);
  1:     gData->ok = JS_FALSE;
  1:     return NULL;
  1: }
  1: 
  1: JSBool
  1: js_ExecuteRegExp(JSContext *cx, JSRegExp *re, JSString *str, size_t *indexp,
  1:                  JSBool test, jsval *rval)
  1: {
  1:     REGlobalData gData;
  1:     REMatchState *x, *result;
  1: 
  1:     const jschar *cp, *ep;
  1:     size_t i, length, start;
  1:     JSSubString *morepar;
  1:     JSBool ok;
  1:     JSRegExpStatics *res;
  1:     ptrdiff_t matchlen;
  1:     uintN num, morenum;
  1:     JSString *parstr, *matchstr;
  1:     JSObject *obj;
  1: 
  1:     RECapture *parsub = NULL;
  1: 
  1:     /*
  1:      * It's safe to load from cp because JSStrings have a zero at the end,
  1:      * and we never let cp get beyond cpend.
  1:      */
  1:     start = *indexp;
  1:     length = JSSTRING_LENGTH(str);
  1:     if (start > length)
  1:         start = length;
  1:     cp = JSSTRING_CHARS(str);
  1:     gData.cpbegin = cp;
  1:     gData.cpend = cp + length;
  1:     cp += start;
  1:     gData.start = start;
  1:     gData.skipped = 0;
  1: 
  1:     JS_InitArenaPool(&gData.pool, "RegExpPool", 8096, 4);
  1:     x = InitMatch(cx, &gData, re, length);
  1: 
  1:     if (!x) {
  1:         ok = JS_FALSE;
  1:         goto out;
  1:     }
  1:     x->cp = cp;
  1: 
  1:     /*
  1:      * Call the recursive matcher to do the real work.  Return null on mismatch
  1:      * whether testing or not.  On match, return an extended Array object.
  1:      */
  1:     result = MatchRegExp(&gData, x);
  1:     ok = gData.ok;
  1:     if (!ok)
  1:         goto out;
  1:     if (!result) {
  1:         *rval = JSVAL_NULL;
  1:         goto out;
  1:     }
  1:     cp = result->cp;
  1:     i = cp - gData.cpbegin;
  1:     *indexp = i;
  1:     matchlen = i - (start + gData.skipped);
  1:     ep = cp;
  1:     cp -= matchlen;
  1: 
  1:     if (test) {
  1:         /*
  1:          * Testing for a match and updating cx->regExpStatics: don't allocate
  1:          * an array object, do return true.
  1:          */
  1:         *rval = JSVAL_TRUE;
  1: 
  1:         /* Avoid warning.  (gcc doesn't detect that obj is needed iff !test); */
  1:         obj = NULL;
  1:     } else {
  1:         /*
  1:          * The array returned on match has element 0 bound to the matched
  1:          * string, elements 1 through state.parenCount bound to the paren
  1:          * matches, an index property telling the length of the left context,
  1:          * and an input property referring to the input string.
  1:          */
  1:         obj = js_NewArrayObject(cx, 0, NULL);
  1:         if (!obj) {
  1:             ok = JS_FALSE;
  1:             goto out;
  1:         }
  1:         *rval = OBJECT_TO_JSVAL(obj);
  1: 
  1: #define DEFVAL(val, id) {                                                     \
  1:     ok = js_DefineProperty(cx, obj, id, val,                                  \
  1:                            JS_PropertyStub, JS_PropertyStub,                  \
  1:                            JSPROP_ENUMERATE, NULL);                           \
  1:     if (!ok) {                                                                \
  1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;                             \
  1:         cx->weakRoots.newborn[GCX_STRING] = NULL;                             \
  1:         goto out;                                                             \
  1:     }                                                                         \
  1: }
  1: 
  1:         matchstr = js_NewStringCopyN(cx, cp, matchlen, 0);
  1:         if (!matchstr) {
  1:             cx->weakRoots.newborn[GCX_OBJECT] = NULL;
  1:             ok = JS_FALSE;
  1:             goto out;
  1:         }
  1:         DEFVAL(STRING_TO_JSVAL(matchstr), INT_TO_JSID(0));
  1:     }
  1: 
  1:     res = &cx->regExpStatics;
  1:     res->input = str;
  1:     res->parenCount = re->parenCount;
  1:     if (re->parenCount == 0) {
  1:         res->lastParen = js_EmptySubString;
  1:     } else {
  1:         for (num = 0; num < re->parenCount; num++) {
  1:             parsub = &result->parens[num];
  1:             if (num < 9) {
  1:                 if (parsub->index == -1) {
  1:                     res->parens[num].chars = NULL;
  1:                     res->parens[num].length = 0;
  1:                 } else {
  1:                     res->parens[num].chars = gData.cpbegin + parsub->index;
  1:                     res->parens[num].length = parsub->length;
  1:                 }
  1:             } else {
  1:                 morenum = num - 9;
  1:                 morepar = res->moreParens;
  1:                 if (!morepar) {
  1:                     res->moreLength = 10;
  1:                     morepar = (JSSubString*)
  1:                         JS_malloc(cx, 10 * sizeof(JSSubString));
  1:                 } else if (morenum >= res->moreLength) {
  1:                     res->moreLength += 10;
  1:                     morepar = (JSSubString*)
  1:                         JS_realloc(cx, morepar,
  1:                                    res->moreLength * sizeof(JSSubString));
  1:                 }
  1:                 if (!morepar) {
  1:                     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
  1:                     cx->weakRoots.newborn[GCX_STRING] = NULL;
  1:                     ok = JS_FALSE;
  1:                     goto out;
  1:                 }
  1:                 res->moreParens = morepar;
  1:                 if (parsub->index == -1) {
  1:                     morepar[morenum].chars = NULL;
  1:                     morepar[morenum].length = 0;
  1:                 } else {
  1:                     morepar[morenum].chars = gData.cpbegin + parsub->index;
  1:                     morepar[morenum].length = parsub->length;
  1:                 }
  1:             }
  1:             if (test)
  1:                 continue;
  1:             if (parsub->index == -1) {
  1:                 ok = js_DefineProperty(cx, obj, INT_TO_JSID(num + 1),
  1:                                        JSVAL_VOID, NULL, NULL,
  1:                                        JSPROP_ENUMERATE, NULL);
  1:             } else {
  1:                 parstr = js_NewStringCopyN(cx, gData.cpbegin + parsub->index,
  1:                                            parsub->length, 0);
  1:                 if (!parstr) {
  1:                     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
  1:                     cx->weakRoots.newborn[GCX_STRING] = NULL;
  1:                     ok = JS_FALSE;
  1:                     goto out;
  1:                 }
  1:                 ok = js_DefineProperty(cx, obj, INT_TO_JSID(num + 1),
  1:                                        STRING_TO_JSVAL(parstr), NULL, NULL,
  1:                                        JSPROP_ENUMERATE, NULL);
  1:             }
  1:             if (!ok) {
  1:                 cx->weakRoots.newborn[GCX_OBJECT] = NULL;
  1:                 cx->weakRoots.newborn[GCX_STRING] = NULL;
  1:                 goto out;
  1:             }
  1:         }
  1:         if (parsub->index == -1) {
  1:             res->lastParen = js_EmptySubString;
  1:         } else {
  1:             res->lastParen.chars = gData.cpbegin + parsub->index;
  1:             res->lastParen.length = parsub->length;
  1:         }
  1:     }
  1: 
  1:     if (!test) {
  1:         /*
  1:          * Define the index and input properties last for better for/in loop
  1:          * order (so they come after the elements).
  1:          */
  1:         DEFVAL(INT_TO_JSVAL(start + gData.skipped),
  1:                ATOM_TO_JSID(cx->runtime->atomState.indexAtom));
  1:         DEFVAL(STRING_TO_JSVAL(str),
  1:                ATOM_TO_JSID(cx->runtime->atomState.inputAtom));
  1:     }
  1: 
  1: #undef DEFVAL
  1: 
  1:     res->lastMatch.chars = cp;
  1:     res->lastMatch.length = matchlen;
  1: 
  1:     /*
  1:      * For JS1.3 and ECMAv2, emulate Perl5 exactly:
  1:      *
  1:      * js1.3        "hi", "hi there"            "hihitherehi therebye"
  1:      */
  1:     res->leftContext.chars = JSSTRING_CHARS(str);
  1:     res->leftContext.length = start + gData.skipped;
  1:     res->rightContext.chars = ep;
  1:     res->rightContext.length = gData.cpend - ep;
  1: 
  1: out:
  1:     JS_FinishArenaPool(&gData.pool);
  1:     return ok;
  1: }
  1: 
  1: /************************************************************************/
  1: 
  1: enum regexp_tinyid {
  1:     REGEXP_SOURCE       = -1,
  1:     REGEXP_GLOBAL       = -2,
  1:     REGEXP_IGNORE_CASE  = -3,
  1:     REGEXP_LAST_INDEX   = -4,
  1:     REGEXP_MULTILINE    = -5,
  1:     REGEXP_STICKY       = -6
  1: };
  1: 
  1: #define REGEXP_PROP_ATTRS (JSPROP_PERMANENT|JSPROP_SHARED)
  1: 
  1: static JSPropertySpec regexp_props[] = {
  1:     {"source",     REGEXP_SOURCE,      REGEXP_PROP_ATTRS | JSPROP_READONLY,0,0},
  1:     {"global",     REGEXP_GLOBAL,      REGEXP_PROP_ATTRS | JSPROP_READONLY,0,0},
  1:     {"ignoreCase", REGEXP_IGNORE_CASE, REGEXP_PROP_ATTRS | JSPROP_READONLY,0,0},
  1:     {"lastIndex",  REGEXP_LAST_INDEX,  REGEXP_PROP_ATTRS,0,0},
  1:     {"multiline",  REGEXP_MULTILINE,   REGEXP_PROP_ATTRS | JSPROP_READONLY,0,0},
  1:     {"sticky",     REGEXP_STICKY,      REGEXP_PROP_ATTRS | JSPROP_READONLY,0,0},
  1:     {0,0,0,0,0}
  1: };
  1: 
  1: static JSBool
  1: regexp_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
  1: {
  1:     jsint slot;
  1:     JSRegExp *re;
  1: 
  1:     if (!JSVAL_IS_INT(id))
  1:         return JS_TRUE;
  1:     slot = JSVAL_TO_INT(id);
  1:     if (slot == REGEXP_LAST_INDEX)
  1:         return JS_GetReservedSlot(cx, obj, 0, vp);
  1: 
  1:     JS_LOCK_OBJ(cx, obj);
  1:     re = (JSRegExp *) JS_GetInstancePrivate(cx, obj, &js_RegExpClass, NULL);
  1:     if (re) {
  1:         switch (slot) {
  1:           case REGEXP_SOURCE:
  1:             *vp = STRING_TO_JSVAL(re->source);
  1:             break;
  1:           case REGEXP_GLOBAL:
  1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_GLOB) != 0);
  1:             break;
  1:           case REGEXP_IGNORE_CASE:
  1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_FOLD) != 0);
  1:             break;
  1:           case REGEXP_MULTILINE:
  1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_MULTILINE) != 0);
  1:             break;
  1:           case REGEXP_STICKY:
  1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_STICKY) != 0);
  1:             break;
  1:         }
  1:     }
  1:     JS_UNLOCK_OBJ(cx, obj);
  1:     return JS_TRUE;
  1: }
  1: 
  1: static JSBool
  1: regexp_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
  1: {
  1:     JSBool ok;
  1:     jsint slot;
  1:     jsdouble lastIndex;
  1: 
  1:     ok = JS_TRUE;
  1:     if (!JSVAL_IS_INT(id))
  1:         return ok;
  1:     slot = JSVAL_TO_INT(id);
  1:     if (slot == REGEXP_LAST_INDEX) {
  1:         if (!js_ValueToNumber(cx, *vp, &lastIndex))
  1:             return JS_FALSE;
  1:         lastIndex = js_DoubleToInteger(lastIndex);
  1:         ok = js_NewNumberValue(cx, lastIndex, vp) &&
  1:              JS_SetReservedSlot(cx, obj, 0, *vp);
  1:     }
  1:     return ok;
  1: }
  1: 
  1: /*
  1:  * RegExp class static properties and their Perl counterparts:
  1:  *
  1:  *  RegExp.input                $_
  1:  *  RegExp.multiline            $*
  1:  *  RegExp.lastMatch            $&
  1:  *  RegExp.lastParen            $+
  1:  *  RegExp.leftContext          $`
  1:  *  RegExp.rightContext         $'
  1:  */
  1: enum regexp_static_tinyid {
  1:     REGEXP_STATIC_INPUT         = -1,
  1:     REGEXP_STATIC_MULTILINE     = -2,
  1:     REGEXP_STATIC_LAST_MATCH    = -3,
  1:     REGEXP_STATIC_LAST_PAREN    = -4,
  1:     REGEXP_STATIC_LEFT_CONTEXT  = -5,
  1:     REGEXP_STATIC_RIGHT_CONTEXT = -6
  1: };
  1: 
  1: JSBool
  1: js_InitRegExpStatics(JSContext *cx, JSRegExpStatics *res)
  1: {
  1:     JS_ClearRegExpStatics(cx);
  1:     return js_AddRoot(cx, &res->input, "res->input");
  1: }
  1: 
  1: void
  1: js_FreeRegExpStatics(JSContext *cx, JSRegExpStatics *res)
  1: {
  1:     if (res->moreParens) {
  1:         JS_free(cx, res->moreParens);
  1:         res->moreParens = NULL;
  1:     }
  1:     js_RemoveRoot(cx->runtime, &res->input);
  1: }
  1: 
  1: static JSBool
  1: regexp_static_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
  1: {
  1:     jsint slot;
  1:     JSRegExpStatics *res;
  1:     JSString *str;
  1:     JSSubString *sub;
  1: 
  1:     res = &cx->regExpStatics;
  1:     if (!JSVAL_IS_INT(id))
  1:         return JS_TRUE;
  1:     slot = JSVAL_TO_INT(id);
  1:     switch (slot) {
  1:       case REGEXP_STATIC_INPUT:
  1:         *vp = res->input ? STRING_TO_JSVAL(res->input)
  1:                          : JS_GetEmptyStringValue(cx);
  1:         return JS_TRUE;
  1:       case REGEXP_STATIC_MULTILINE:
  1:         *vp = BOOLEAN_TO_JSVAL(res->multiline);
  1:         return JS_TRUE;
  1:       case REGEXP_STATIC_LAST_MATCH:
  1:         sub = &res->lastMatch;
  1:         break;
  1:       case REGEXP_STATIC_LAST_PAREN:
  1:         sub = &res->lastParen;
  1:         break;
  1:       case REGEXP_STATIC_LEFT_CONTEXT:
  1:         sub = &res->leftContext;
  1:         break;
  1:       case REGEXP_STATIC_RIGHT_CONTEXT:
  1:         sub = &res->rightContext;
  1:         break;
  1:       default:
  1:         sub = REGEXP_PAREN_SUBSTRING(res, slot);
  1:         break;
  1:     }
  1:     str = js_NewStringCopyN(cx, sub->chars, sub->length, 0);
  1:     if (!str)
  1:         return JS_FALSE;
  1:     *vp = STRING_TO_JSVAL(str);
  1:     return JS_TRUE;
  1: }
  1: 
  1: static JSBool
  1: regexp_static_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
  1: {
  1:     JSRegExpStatics *res;
  1: 
  1:     if (!JSVAL_IS_INT(id))
  1:         return JS_TRUE;
  1:     res = &cx->regExpStatics;
  1:     /* XXX use if-else rather than switch to keep MSVC1.52 from crashing */
  1:     if (JSVAL_TO_INT(id) == REGEXP_STATIC_INPUT) {
  1:         if (!JSVAL_IS_STRING(*vp) &&
  1:             !JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp)) {
  1:             return JS_FALSE;
  1:         }
  1:         res->input = JSVAL_TO_STRING(*vp);
  1:     } else if (JSVAL_TO_INT(id) == REGEXP_STATIC_MULTILINE) {
  1:         if (!JSVAL_IS_BOOLEAN(*vp) &&
  1:             !JS_ConvertValue(cx, *vp, JSTYPE_BOOLEAN, vp)) {
  1:             return JS_FALSE;
  1:         }
  1:         res->multiline = JSVAL_TO_BOOLEAN(*vp);
  1:     }
  1:     return JS_TRUE;
  1: }
  1: 
  1: static JSPropertySpec regexp_static_props[] = {
  1:     {"input",
  1:      REGEXP_STATIC_INPUT,
  1:      JSPROP_ENUMERATE|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_setProperty},
  1:     {"multiline",
  1:      REGEXP_STATIC_MULTILINE,
  1:      JSPROP_ENUMERATE|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_setProperty},
  1:     {"lastMatch",
  1:      REGEXP_STATIC_LAST_MATCH,
  1:      JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"lastParen",
  1:      REGEXP_STATIC_LAST_PAREN,
  1:      JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"leftContext",
  1:      REGEXP_STATIC_LEFT_CONTEXT,
  1:      JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"rightContext",
  1:      REGEXP_STATIC_RIGHT_CONTEXT,
  1:      JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1: 
  1:     /* XXX should have block scope and local $1, etc. */
  1:     {"$1", 0, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$2", 1, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$3", 2, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$4", 3, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$5", 4, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$6", 5, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$7", 6, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$8", 7, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1:     {"$9", 8, JSPROP_ENUMERATE|JSPROP_READONLY|JSPROP_SHARED,
  1:      regexp_static_getProperty,    regexp_static_getProperty},
  1: 
  1:     {0,0,0,0,0}
  1: };
  1: 
  1: static void
  1: regexp_finalize(JSContext *cx, JSObject *obj)
  1: {
  1:     JSRegExp *re;
  1: 
  1:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
  1:     if (!re)
  1:         return;
  1:     js_DestroyRegExp(cx, re);
  1: }
  1: 
  1: /* Forward static prototype. */
  1: static JSBool
  1: regexp_exec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
  1:             jsval *rval);
  1: 
  1: static JSBool
  1: regexp_call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
  1: {
  1:     return regexp_exec(cx, JSVAL_TO_OBJECT(argv[-2]), argc, argv, rval);
  1: }
  1: 
  1: #if JS_HAS_XDR
  1: 
  1: #include "jsxdrapi.h"
  1: 
  1: static JSBool
  1: regexp_xdrObject(JSXDRState *xdr, JSObject **objp)
  1: {
  1:     JSRegExp *re;
  1:     JSString *source;
  1:     uint32 flagsword;
  1:     JSObject *obj;
  1: 
  1:     if (xdr->mode == JSXDR_ENCODE) {
  1:         re = (JSRegExp *) JS_GetPrivate(xdr->cx, *objp);
  1:         if (!re)
  1:             return JS_FALSE;
  1:         source = re->source;
  1:         flagsword = ((uint32)re->cloneIndex << 16) | re->flags;
  1:     }
  1:     if (!JS_XDRString(xdr, &source) ||
  1:         !JS_XDRUint32(xdr, &flagsword)) {
  1:         return JS_FALSE;
  1:     }
  1:     if (xdr->mode == JSXDR_DECODE) {
  1:         obj = js_NewObject(xdr->cx, &js_RegExpClass, NULL, NULL);
  1:         if (!obj)
  1:             return JS_FALSE;
  1:         re = js_NewRegExp(xdr->cx, NULL, source, (uint16)flagsword, JS_FALSE);
  1:         if (!re)
  1:             return JS_FALSE;
  1:         if (!JS_SetPrivate(xdr->cx, obj, re) ||
  1:             !js_SetLastIndex(xdr->cx, obj, 0)) {
  1:             js_DestroyRegExp(xdr->cx, re);
  1:             return JS_FALSE;
  1:         }
  1:         re->cloneIndex = (uint16)(flagsword >> 16);
  1:         *objp = obj;
  1:     }
  1:     return JS_TRUE;
  1: }
  1: 
  1: #else  /* !JS_HAS_XDR */
  1: 
  1: #define regexp_xdrObject NULL
  1: 
  1: #endif /* !JS_HAS_XDR */
  1: 
  1: static uint32
  1: regexp_mark(JSContext *cx, JSObject *obj, void *arg)
  1: {
  1:     JSRegExp *re = (JSRegExp *) JS_GetPrivate(cx, obj);
  1:     if (re)
  1:         GC_MARK(cx, re->source, "source");
  1:     return 0;
  1: }
  1: 
  1: JSClass js_RegExpClass = {
  1:     js_RegExp_str,
  1:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) |
  1:     JSCLASS_HAS_CACHED_PROTO(JSProto_RegExp),
  1:     JS_PropertyStub,    JS_PropertyStub,
  1:     regexp_getProperty, regexp_setProperty,
  1:     JS_EnumerateStub,   JS_ResolveStub,
  1:     JS_ConvertStub,     regexp_finalize,
  1:     NULL,               NULL,
  1:     regexp_call,        NULL,
  1:     regexp_xdrObject,   NULL,
  1:     regexp_mark,        0
  1: };
  1: 
  1: static const jschar empty_regexp_ucstr[] = {'(', '?', ':', ')', 0};
  1: 
  1: JSBool
  1: js_regexp_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
  1:                    jsval *rval)
  1: {
  1:     JSRegExp *re;
  1:     const jschar *source;
  1:     jschar *chars;
  1:     size_t length, nflags;
  1:     uintN flags;
  1:     JSString *str;
  1: 
  1:     if (!JS_InstanceOf(cx, obj, &js_RegExpClass, argv))
  1:         return JS_FALSE;
  1:     JS_LOCK_OBJ(cx, obj);
  1:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
  1:     if (!re) {
  1:         JS_UNLOCK_OBJ(cx, obj);
  1:         *rval = STRING_TO_JSVAL(cx->runtime->emptyString);
  1:         return JS_TRUE;
  1:     }
  1: 
  1:     source = JSSTRING_CHARS(re->source);
  1:     length = JSSTRING_LENGTH(re->source);
  1:     if (length == 0) {
  1:         source = empty_regexp_ucstr;
  1:         length = sizeof(empty_regexp_ucstr) / sizeof(jschar) - 1;
  1:     }
  1:     length += 2;
  1:     nflags = 0;
  1:     for (flags = re->flags; flags != 0; flags &= flags - 1)
  1:         nflags++;
  1:     chars = (jschar*) JS_malloc(cx, (length + nflags + 1) * sizeof(jschar));
  1:     if (!chars) {
  1:         JS_UNLOCK_OBJ(cx, obj);
  1:         return JS_FALSE;
  1:     }
  1: 
  1:     chars[0] = '/';
  1:     js_strncpy(&chars[1], source, length - 2);
  1:     chars[length-1] = '/';
  1:     if (nflags) {
  1:         if (re->flags & JSREG_GLOB)
  1:             chars[length++] = 'g';
  1:         if (re->flags & JSREG_FOLD)
  1:             chars[length++] = 'i';
  1:         if (re->flags & JSREG_MULTILINE)
  1:             chars[length++] = 'm';
  1:         if (re->flags & JSREG_STICKY)
  1:             chars[length++] = 'y';
  1:     }
  1:     JS_UNLOCK_OBJ(cx, obj);
  1:     chars[length] = 0;
  1: 
  1:     str = js_NewString(cx, chars, length, 0);
  1:     if (!str) {
  1:         JS_free(cx, chars);
  1:         return JS_FALSE;
  1:     }
  1:     *rval = STRING_TO_JSVAL(str);
  1:     return JS_TRUE;
  1: }
  1: 
  1: static JSBool
  1: regexp_compile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
  1:                jsval *rval)
  1: {
  1:     JSString *opt, *str;
  1:     JSRegExp *oldre, *re;
  1:     JSBool ok, ok2;
  1:     JSObject *obj2;
  1:     size_t length, nbytes;
  1:     const jschar *cp, *start, *end;
  1:     jschar *nstart, *ncp, *tmp;
  1: 
  1:     if (!JS_InstanceOf(cx, obj, &js_RegExpClass, argv))
  1:         return JS_FALSE;
  1:     opt = NULL;
  1:     if (argc == 0) {
  1:         str = cx->runtime->emptyString;
  1:     } else {
  1:         if (JSVAL_IS_OBJECT(argv[0])) {
  1:             /*
  1:              * If we get passed in a RegExp object we construct a new
  1:              * RegExp that is a duplicate of it by re-compiling the
  1:              * original source code. ECMA requires that it be an error
  1:              * here if the flags are specified. (We must use the flags
  1:              * from the original RegExp also).
  1:              */
  1:             obj2 = JSVAL_TO_OBJECT(argv[0]);
  1:             if (obj2 && OBJ_GET_CLASS(cx, obj2) == &js_RegExpClass) {
  1:                 if (argc >= 2 && !JSVAL_IS_VOID(argv[1])) { /* 'flags' passed */
  1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
  1:                                          JSMSG_NEWREGEXP_FLAGGED);
  1:                     return JS_FALSE;
  1:                 }
  1:                 JS_LOCK_OBJ(cx, obj2);
  1:                 re = (JSRegExp *) JS_GetPrivate(cx, obj2);
  1:                 if (!re) {
  1:                     JS_UNLOCK_OBJ(cx, obj2);
  1:                     return JS_FALSE;
  1:                 }
  1:                 re = js_NewRegExp(cx, NULL, re->source, re->flags, JS_FALSE);
  1:                 JS_UNLOCK_OBJ(cx, obj2);
  1:                 goto created;
  1:             }
  1:         }
  1:         str = js_ValueToString(cx, argv[0]);
  1:         if (!str)
  1:             return JS_FALSE;
  1:         argv[0] = STRING_TO_JSVAL(str);
  1:         if (argc > 1) {
  1:             if (JSVAL_IS_VOID(argv[1])) {
  1:                 opt = NULL;
  1:             } else {
  1:                 opt = js_ValueToString(cx, argv[1]);
  1:                 if (!opt)
  1:                     return JS_FALSE;
  1:                 argv[1] = STRING_TO_JSVAL(opt);
  1:             }
  1:         }
  1: 
  1:         /* Escape any naked slashes in the regexp source. */
  1:         length = JSSTRING_LENGTH(str);
  1:         start = JSSTRING_CHARS(str);
  1:         end = start + length;
  1:         nstart = ncp = NULL;
  1:         for (cp = start; cp < end; cp++) {
  1:             if (*cp == '/' && (cp == start || cp[-1] != '\\')) {
  1:                 nbytes = (++length + 1) * sizeof(jschar);
  1:                 if (!nstart) {
  1:                     nstart = (jschar *) JS_malloc(cx, nbytes);
  1:                     if (!nstart)
  1:                         return JS_FALSE;
  1:                     ncp = nstart + (cp - start);
  1:                     js_strncpy(nstart, start, cp - start);
  1:                 } else {
  1:                     tmp = (jschar *) JS_realloc(cx, nstart, nbytes);
  1:                     if (!tmp) {
  1:                         JS_free(cx, nstart);
  1:                         return JS_FALSE;
  1:                     }
  1:                     ncp = tmp + (ncp - nstart);
  1:                     nstart = tmp;
  1:                 }
  1:                 *ncp++ = '\\';
  1:             }
  1:             if (nstart)
  1:                 *ncp++ = *cp;
  1:         }
  1: 
  1:         if (nstart) {
  1:             /* Don't forget to store the backstop after the new string. */
  1:             JS_ASSERT((size_t)(ncp - nstart) == length);
  1:             *ncp = 0;
  1:             str = js_NewString(cx, nstart, length, 0);
  1:             if (!str) {
  1:                 JS_free(cx, nstart);
  1:                 return JS_FALSE;
  1:             }
  1:             argv[0] = STRING_TO_JSVAL(str);
  1:         }
  1:     }
  1: 
  1:     re = js_NewRegExpOpt(cx, NULL, str, opt, JS_FALSE);
  1: created:
  1:     if (!re)
  1:         return JS_FALSE;
  1:     JS_LOCK_OBJ(cx, obj);
  1:     oldre = (JSRegExp *) JS_GetPrivate(cx, obj);
  1:     ok = JS_SetPrivate(cx, obj, re);
  1:     ok2 = js_SetLastIndex(cx, obj, 0);
  1:     JS_UNLOCK_OBJ(cx, obj);
  1:     if (!ok) {
  1:         js_DestroyRegExp(cx, re);
  1:         return JS_FALSE;
  1:     }
  1:     if (oldre)
  1:         js_DestroyRegExp(cx, oldre);
  1:     *rval = OBJECT_TO_JSVAL(obj);
  1:     return ok2;
  1: }
  1: 
  1: static JSBool
  1: regexp_exec_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
  1:                 JSBool test, jsval *rval)
  1: {
  1:     JSBool ok, sticky;
  1:     JSRegExp *re;
  1:     jsdouble lastIndex;
  1:     JSString *str;
  1:     size_t i;
  1: 
  1:     ok = JS_InstanceOf(cx, obj, &js_RegExpClass, argv);
  1:     if (!ok)
  1:         return JS_FALSE;
  1:     JS_LOCK_OBJ(cx, obj);
  1:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
  1:     if (!re) {
  1:         JS_UNLOCK_OBJ(cx, obj);
  1:         return JS_TRUE;
  1:     }
  1: 
  1:     /* NB: we must reach out: after this paragraph, in order to drop re. */
  1:     HOLD_REGEXP(cx, re);
  1:     sticky = (re->flags & JSREG_STICKY) != 0;
  1:     if (re->flags & (JSREG_GLOB | JSREG_STICKY)) {
  1:         ok = js_GetLastIndex(cx, obj, &lastIndex);
  1:     } else {
  1:         lastIndex = 0;
  1:     }
  1:     JS_UNLOCK_OBJ(cx, obj);
  1:     if (!ok)
  1:         goto out;
  1: 
  1:     /* Now that obj is unlocked, it's safe to (potentially) grab the GC lock. */
  1:     if (argc == 0) {
  1:         str = cx->regExpStatics.input;
  1:         if (!str) {
  1:             const char *bytes = js_GetStringBytes(cx, re->source);
  1: 
  1:             if (bytes) {
  1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
  1:                                      JSMSG_NO_INPUT,
  1:                                      bytes,
  1:                                      (re->flags & JSREG_GLOB) ? "g" : "",
  1:                                      (re->flags & JSREG_FOLD) ? "i" : "",
  1:                                      (re->flags & JSREG_MULTILINE) ? "m" : "",
  1:                                      (re->flags & JSREG_STICKY) ? "y" : "");
  1:             }
  1:             ok = JS_FALSE;
  1:             goto out;
  1:         }
  1:     } else {
  1:         str = js_ValueToString(cx, argv[0]);
  1:         if (!str) {
  1:             ok = JS_FALSE;
  1:             goto out;
  1:         }
  1:         argv[0] = STRING_TO_JSVAL(str);
  1:     }
  1: 
  1:     if (lastIndex < 0 || JSSTRING_LENGTH(str) < lastIndex) {
  1:         ok = js_SetLastIndex(cx, obj, 0);
  1:         *rval = JSVAL_NULL;
  1:     } else {
  1:         i = (size_t) lastIndex;
  1:         ok = js_ExecuteRegExp(cx, re, str, &i, test, rval);
  1:         if (ok &&
  1:             ((re->flags & JSREG_GLOB) || (*rval != JSVAL_NULL && sticky))) {
  1:             ok = js_SetLastIndex(cx, obj, (*rval == JSVAL_NULL) ? 0 : i);
  1:         }
  1:     }
  1: 
  1: out:
  1:     DROP_REGEXP(cx, re);
  1:     return ok;
  1: }
  1: 
  1: static JSBool
  1: regexp_exec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
  1: {
  1:     return regexp_exec_sub(cx, obj, argc, argv, JS_FALSE, rval);
  1: }
  1: 
  1: static JSBool
  1: regexp_test(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
  1: {
  1:     if (!regexp_exec_sub(cx, obj, argc, argv, JS_TRUE, rval))
  1:         return JS_FALSE;
  1:     if (*rval != JSVAL_TRUE)
  1:         *rval = JSVAL_FALSE;
  1:     return JS_TRUE;
  1: }
  1: 
  1: static JSFunctionSpec regexp_methods[] = {
  1: #if JS_HAS_TOSOURCE
  1:     {js_toSource_str,   js_regexp_toString,     0,0,0},
  1: #endif
  1:     {js_toString_str,   js_regexp_toString,     0,0,0},
  1:     {"compile",         regexp_compile,         1,0,0},
  1:     {"exec",            regexp_exec,            0,0,0},
  1:     {"test",            regexp_test,            0,0,0},
  1:     {0,0,0,0,0}
  1: };
  1: 
  1: static JSBool
  1: RegExp(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
  1: {
  1:     if (!(cx->fp->flags & JSFRAME_CONSTRUCTING)) {
  1:         /*
  1:          * If first arg is regexp and no flags are given, just return the arg.
  1:          * (regexp_compile detects the regexp + flags case and throws a
  1:          * TypeError.)  See 10.15.3.1.
  1:          */
  1:         if ((argc < 2 || JSVAL_IS_VOID(argv[1])) &&
  1:             !JSVAL_IS_PRIMITIVE(argv[0]) &&
  1:             OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(argv[0])) == &js_RegExpClass) {
  1:             *rval = argv[0];
  1:             return JS_TRUE;
  1:         }
  1: 
  1:         /* Otherwise, replace obj with a new RegExp object. */
  1:         obj = js_NewObject(cx, &js_RegExpClass, NULL, NULL);
  1:         if (!obj)
  1:             return JS_FALSE;
  1: 
  1:         /*
  1:          * regexp_compile does not use rval to root its temporaries
  1:          * so we can use it to root obj.
  1:          */
  1:         *rval = OBJECT_TO_JSVAL(obj);
  1:     }
  1:     return regexp_compile(cx, obj, argc, argv, rval);
  1: }
  1: 
  1: JSObject *
  1: js_InitRegExpClass(JSContext *cx, JSObject *obj)
  1: {
  1:     JSObject *proto, *ctor;
  1:     jsval rval;
  1: 
  1:     proto = JS_InitClass(cx, obj, NULL, &js_RegExpClass, RegExp, 1,
  1:                          regexp_props, regexp_methods,
  1:                          regexp_static_props, NULL);
  1: 
  1:     if (!proto || !(ctor = JS_GetConstructor(cx, proto)))
  1:         return NULL;
  1:     if (!JS_AliasProperty(cx, ctor, "input",        "$_") ||
  1:         !JS_AliasProperty(cx, ctor, "multiline",    "$*") ||
  1:         !JS_AliasProperty(cx, ctor, "lastMatch",    "$&") ||
  1:         !JS_AliasProperty(cx, ctor, "lastParen",    "$+") ||
  1:         !JS_AliasProperty(cx, ctor, "leftContext",  "$`") ||
  1:         !JS_AliasProperty(cx, ctor, "rightContext", "$'")) {
  1:         goto bad;
  1:     }
  1: 
  1:     /* Give RegExp.prototype private data so it matches the empty string. */
  1:     if (!regexp_compile(cx, proto, 0, NULL, &rval))
  1:         goto bad;
  1:     return proto;
  1: 
  1: bad:
  1:     JS_DeleteProperty(cx, obj, js_RegExpClass.name);
  1:     return NULL;
  1: }
  1: 
  1: JSObject *
  1: js_NewRegExpObject(JSContext *cx, JSTokenStream *ts,
  1:                    jschar *chars, size_t length, uintN flags)
  1: {
  1:     JSString *str;
  1:     JSObject *obj;
  1:     JSRegExp *re;
  1:     JSTempValueRooter tvr;
  1: 
  1:     str = js_NewStringCopyN(cx, chars, length, 0);
  1:     if (!str)
  1:         return NULL;
  1:     re = js_NewRegExp(cx, ts,  str, flags, JS_FALSE);
  1:     if (!re)
  1:         return NULL;
  1:     JS_PUSH_TEMP_ROOT_STRING(cx, str, &tvr);
  1:     obj = js_NewObject(cx, &js_RegExpClass, NULL, NULL);
  1:     if (!obj || !JS_SetPrivate(cx, obj, re)) {
  1:         js_DestroyRegExp(cx, re);
  1:         obj = NULL;
  1:     }
  1:     if (obj && !js_SetLastIndex(cx, obj, 0))
  1:         obj = NULL;
  1:     JS_POP_TEMP_ROOT(cx, &tvr);
  1:     return obj;
  1: }
  1: 
  1: JSObject *
  1: js_CloneRegExpObject(JSContext *cx, JSObject *obj, JSObject *parent)
  1: {
  1:     JSObject *clone;
  1:     JSRegExp *re;
  1: 
  1:     JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_RegExpClass);
  1:     clone = js_NewObject(cx, &js_RegExpClass, NULL, parent);
  1:     if (!clone)
  1:         return NULL;
  1:     re = JS_GetPrivate(cx, obj);
  1:     if (!JS_SetPrivate(cx, clone, re) || !js_SetLastIndex(cx, clone, 0)) {
  1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
  1:         return NULL;
  1:     }
  1:     HOLD_REGEXP(cx, re);
  1:     return clone;
  1: }
  1: 
  1: JSBool
  1: js_GetLastIndex(JSContext *cx, JSObject *obj, jsdouble *lastIndex)
  1: {
  1:     jsval v;
  1: 
  1:     return JS_GetReservedSlot(cx, obj, 0, &v) &&
  1:            js_ValueToNumber(cx, v, lastIndex);
  1: }
  1: 
  1: JSBool
  1: js_SetLastIndex(JSContext *cx, JSObject *obj, jsdouble lastIndex)
  1: {
  1:     jsval v;
  1: 
  1:     return js_NewNumberValue(cx, lastIndex, &v) &&
  1:            JS_SetReservedSlot(cx, obj, 0, v);
  1: }
 22: 
