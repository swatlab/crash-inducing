29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jscntxt_h___
    1: #define jscntxt_h___
    1: /*
    1:  * JS execution context.
    1:  */
38604: #include <string.h>
38604: 
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jslong.h"
    1: #include "jsatom.h"
18863: #include "jsversion.h"
    1: #include "jsdhash.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
    1: #include "jsregexp.h"
    1: #include "jsutil.h"
30023: #include "jsarray.h"
30851: #include "jstask.h"
34299: #include "jsvector.h"
38568: #include "jshashtable.h"
    1: 
39928: #ifdef _MSC_VER
39928: #pragma warning(push)
39928: #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
39928: #pragma warning(push)
39928: #pragma warning(disable:4355) /* Silence warning about "this" used in base member initializer list */
39928: #endif
39928: 
    1: /*
    1:  * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
15530:  * given pc in a script. We use the script->code pointer to tag the cache,
15530:  * instead of the script address itself, so that source notes are always found
15530:  * by offset from the bytecode with which they were generated.
    1:  */
    1: typedef struct JSGSNCache {
15530:     jsbytecode      *code;
    1:     JSDHashTable    table;
    1: #ifdef JS_GSNMETER
    1:     uint32          hits;
    1:     uint32          misses;
    1:     uint32          fills;
26569:     uint32          purges;
    1: # define GSN_CACHE_METER(cache,cnt) (++(cache)->cnt)
    1: #else
    1: # define GSN_CACHE_METER(cache,cnt) /* nothing */
    1: #endif
    1: } JSGSNCache;
    1: 
26569: #define js_FinishGSNCache(cache) js_PurgeGSNCache(cache)
26569: 
26569: extern void
26569: js_PurgeGSNCache(JSGSNCache *cache);
    1: 
    1: /* These helper macros take a cx as parameter and operate on its GSN cache. */
26569: #define JS_PURGE_GSN_CACHE(cx)      js_PurgeGSNCache(&JS_GSN_CACHE(cx))
    1: #define JS_METER_GSN_CACHE(cx,cnt)  GSN_CACHE_METER(&JS_GSN_CACHE(cx), cnt)
    1: 
34572: /* Forward declarations of nanojit types. */
37741: namespace nanojit {
37741: 
31475: class Assembler;
31475: class CodeAlloc;
17937: class Fragment;
33166: template<typename K> struct DefaultHash;
32784: template<typename K, typename V, typename H> class HashMap;
32784: template<typename T> class Seq;
37741: 
37741: }  /* namespace nanojit */
37741: 
37741: namespace js {
34572: 
34572: /* Tracer constants. */
34572: static const size_t MONITOR_N_GLOBAL_STATES = 4;
34572: static const size_t FRAGMENT_TABLE_SIZE = 512;
34572: static const size_t MAX_NATIVE_STACK_SLOTS = 4096;
34572: static const size_t MAX_CALL_STACK_ENTRIES = 500;
34572: static const size_t MAX_GLOBAL_SLOTS = 4096;
34572: static const size_t GLOBAL_SLOTS_BUFFER_SIZE = MAX_GLOBAL_SLOTS + 1;
34572: 
34572: /* Forward declarations of tracer types. */
34572: class VMAllocator;
34572: class FrameInfoCache;
34572: struct REHashFn;
34572: struct REHashKey;
34572: struct FrameInfo;
34572: struct VMSideExit;
35044: struct TreeFragment;
34572: struct InterpState;
34572: template<typename T> class Queue;
34572: typedef Queue<uint16> SlotList;
39928: class TypeMap;
35044: struct REFragment;
35044: typedef nanojit::HashMap<REHashKey, REFragment*, REHashFn> REHashMap;
34572: 
32784: #if defined(JS_JIT_SPEW) || defined(DEBUG)
32784: struct FragPI;
32788: typedef nanojit::HashMap<uint32, FragPI, nanojit::DefaultHash<uint32> > FragStatsMap;
32784: #endif
17583: 
38568: /*
38568:  * Allocation policy that calls JSContext memory functions and reports errors
38568:  * to the context. Since the JSContext given on construction is stored for
38568:  * the lifetime of the container, this policy may only be used for containers
38568:  * whose lifetime is a shorter than the given JSContext.
38568:  */
38568: class ContextAllocPolicy
38568: {
38568:     JSContext *cx;
38568: 
38568:   public:
38568:     ContextAllocPolicy(JSContext *cx) : cx(cx) {}
38568:     JSContext *context() const { return cx; }
38568: 
38568:     /* Inline definitions below. */
38568:     void *malloc(size_t bytes);
38568:     void free(void *p);
38568:     void *realloc(void *p, size_t bytes);
38568:     void reportAllocOverflow() const;
38568: };
38568: 
34572: /* Holds the execution state during trace execution. */
34572: struct InterpState
34572: {
35083:     JSContext*     cx;                  // current VM context handle
35083:     double*        stackBase;           // native stack base
34572:     double*        sp;                  // native stack pointer, stack[0] is spbase[0]
35083:     double*        eos;                 // first unusable word after the native stack / begin of globals
35083:     FrameInfo**    callstackBase;       // call stack base
35083:     void*          sor;                 // start of rp stack
34572:     FrameInfo**    rp;                  // call stack pointer
34572:     void*          eor;                 // first unusable word after the call stack
34572:     VMSideExit*    lastTreeExitGuard;   // guard we exited on during a tree call
34572:     VMSideExit*    lastTreeCallGuard;   // guard we want to grow from if the tree
34572:                                         // call exit guard mismatched
34572:     void*          rpAtLastTreeCall;    // value of rp at innermost tree call guard
34572:     VMSideExit*    outermostTreeExitGuard; // the last side exit returned by js_CallTree
36361:     TreeFragment*  outermostTree;       // the outermost tree we initially invoked
34572:     uintN*         inlineCallCountp;    // inline call count counter
34572:     VMSideExit**   innermostNestedGuardp;
34572:     VMSideExit*    innermost;
34572:     uint64         startTime;
34572:     InterpState*   prev;
24307: 
34572:     // Used by _FAIL builtins; see jsbuiltins.h. The builtin sets the
34572:     // JSBUILTIN_BAILED bit if it bails off trace and the JSBUILTIN_ERROR bit
34572:     // if an error or exception occurred.
34572:     uint32         builtinStatus;
31918: 
34572:     // Used to communicate the location of the return value in case of a deep bail.
34572:     double*        deepBailSp;
34572: 
34572:     // Used when calling natives from trace to root the vp vector.
34572:     uintN          nativeVpLen;
34572:     jsval*         nativeVp;
35083: 
37741:     InterpState(JSContext *cx, TraceMonitor *tm, TreeFragment *ti,
35083:                 uintN &inlineCallCountp, VMSideExit** innermostNestedGuardp);
35083:     ~InterpState();
34572: };
34572: 
34572: /*
34572:  * Storage for the execution state and store during trace execution. Generated
34572:  * code depends on the fact that the globals begin |MAX_NATIVE_STACK_SLOTS|
34572:  * doubles after the stack begins. Thus, on trace, |InterpState::eos| holds a
34572:  * pointer to the first global.
34572:  */
34572: struct TraceNativeStorage
34572: {
34572:     double stack_global_buf[MAX_NATIVE_STACK_SLOTS + GLOBAL_SLOTS_BUFFER_SIZE];
34572:     FrameInfo *callstack_buf[MAX_CALL_STACK_ENTRIES];
34572: 
34572:     double *stack() { return stack_global_buf; }
34572:     double *global() { return stack_global_buf + MAX_NATIVE_STACK_SLOTS; }
34572:     FrameInfo **callstack() { return callstack_buf; }
34572: };
34572: 
34572: /* Holds data to track a single globa. */
24491: struct GlobalState {
26819:     JSObject*               globalObj;
24491:     uint32                  globalShape;
34299:     SlotList*               globalSlots;
24491: };
24491: 
17583: /*
37777:  * A callstack contains a set of stack frames linked by fp->down. A callstack
37777:  * is a member of a JSContext and all of a JSContext's callstacks are kept in a
37777:  * list starting at cx->currentCallStack. A callstack may be active or
37777:  * suspended. There are zero or one active callstacks for a context and any
37777:  * number of suspended contexts. If there is an active context, it is the first
37777:  * in the currentCallStack list, |cx->fp != NULL| and the callstack's newest
37777:  * (top) stack frame is |cx->fp|. For all other (suspended) callstacks, the
37777:  * newest frame is pointed to by suspendedFrame.
37777:  *
37777:  * While all frames in a callstack are down-linked, not all down-linked frames
37777:  * are in the same callstack (e.g., calling js_Execute with |down != cx->fp|
37777:  * will create a new frame in a new active callstack).
37777:  */
37777: class CallStack
37777: {
37777: #ifdef DEBUG
37777:     /* The context to which this callstack belongs. */
37777:     JSContext           *cx;
37777: #endif
37777: 
37777:     /* If this callstack is suspended, the top of the callstack. */
37777:     JSStackFrame        *suspendedFrame;
37777: 
37777:     /* This callstack was suspended by JS_SaveFrameChain. */
37777:     bool                saved;
37777: 
37777:     /* Links members of the JSContext::currentCallStack list. */
37777:     CallStack           *previous;
37777: 
37777:     /* The varobj on entry to initialFrame. */
37777:     JSObject            *initialVarObj;
37777: 
37777:     /* The first frame executed in this callstack. */
37777:     JSStackFrame        *initialFrame;
37777: 
37777:   public:
37777:     CallStack(JSContext *cx)
37777:       :
37777: #ifdef DEBUG
37777:         cx(cx),
37777: #endif
37777:         suspendedFrame(NULL), saved(false), previous(NULL),
37777:         initialVarObj(NULL), initialFrame(NULL)
37777:     {}
37777: 
37777: #ifdef DEBUG
37777:     bool contains(JSStackFrame *fp);
37777: #endif
37777: 
37777:     void suspend(JSStackFrame *fp) {
37777:         JS_ASSERT(fp && !isSuspended() && contains(fp));
37777:         suspendedFrame = fp;
37777:     }
37777: 
37777:     void resume() {
37777:         JS_ASSERT(suspendedFrame);
37777:         suspendedFrame = NULL;
37777:     }
37777: 
37777:     JSStackFrame *getSuspendedFrame() const {
37777:         JS_ASSERT(suspendedFrame);
37777:         return suspendedFrame;
37777:     }
37777: 
39928:     bool isSuspended() const { return !!suspendedFrame; }
37777: 
37777:     void setPrevious(CallStack *cs) { previous = cs; }
37777:     CallStack *getPrevious() const  { return previous; }
37777: 
37777:     void setInitialVarObj(JSObject *o) { initialVarObj = o; }
37777:     JSObject *getInitialVarObj() const { return initialVarObj; }
37777: 
37777:     void setInitialFrame(JSStackFrame *f) { initialFrame = f; }
37777:     JSStackFrame *getInitialFrame() const { return initialFrame; }
37777: 
37777:     /*
37777:      * Saving and restoring is a special case of suspending and resuming
37777:      * whereby the active callstack becomes suspended without pushing a new
37777:      * active callstack. This means that if a callstack c1 is pushed on top of a
37777:      * saved callstack c2, when c1 is popped, c2 must not be made active. In
37777:      * the normal case, where c2 is not saved, when c1 is popped, c2 is made
37777:      * active. This distinction is indicated by the |saved| flag.
37777:      */
37777: 
37777:     void save(JSStackFrame *fp) {
37777:         suspend(fp);
37777:         saved = true;
37777:     }
37777: 
37777:     void restore() {
37777:         saved = false;
37777:         resume();
37777:     }
37777: 
37777:     bool isSaved() const {
37777:         JS_ASSERT_IF(saved, isSuspended());
37777:         return saved;
37777:     }
37777: };
37777: 
38568: /* Holds the number of recording attemps for an address. */
38568: typedef HashMap<jsbytecode*,
38568:                 size_t,
38568:                 DefaultHasher<jsbytecode*>,
38568:                 SystemAllocPolicy> RecordAttemptMap;
38568: 
37777: /*
17583:  * Trace monitor. Every JSThread (if JS_THREADSAFE) or JSRuntime (if not
17583:  * JS_THREADSAFE) has an associated trace monitor that keeps track of loop
17583:  * frequencies for all JavaScript code loaded into that runtime.
17583:  */
37741: struct TraceMonitor {
18782:     /*
27882:      * The context currently executing JIT-compiled code on this thread, or
27882:      * NULL if none. Among other things, this can in certain cases prevent
27882:      * last-ditch GC and suppress calls to JS_ReportOutOfMemory.
24613:      *
27882:      * !tracecx && !recorder: not on trace
33172:      * !tracecx && recorder: recording
27882:      * tracecx && !recorder: executing a trace
27882:      * tracecx && recorder: executing inner loop, recording outer loop
18782:      */
27882:     JSContext               *tracecx;
24598: 
33545:     /*
34572:      * Cached storage to use when executing on trace. While we may enter nested
34572:      * traces, we always reuse the outer trace's storage, so never need more
34572:      * than of these.
34572:      */
37037:     TraceNativeStorage      *storage;
34572: 
34572:     /*
36377:      * There are 5 allocators here.  This might seem like overkill, but they
33545:      * have different lifecycles, and by keeping them separate we keep the
36377:      * amount of retained memory down significantly.  They are flushed (ie.
36377:      * all the allocated memory is freed) periodically.
33545:      *
36377:      * - dataAlloc has the lifecycle of the monitor.  It's flushed only when
36377:      *   the monitor is flushed.  It's used for fragments.
33545:      *
36377:      * - traceAlloc has the same flush lifecycle as the dataAlloc, but it is
36377:      *   also *marked* when a recording starts and rewinds to the mark point
36377:      *   if recording aborts.  So you can put things in it that are only
36377:      *   reachable on a successful record/compile cycle like GuardRecords and
36377:      *   SideExits.
33545:      *
36377:      * - tempAlloc is flushed after each recording, successful or not.  It's
36377:      *   used to store LIR code and for all other elements in the LIR
36377:      *   pipeline.
36377:      *
36377:      * - reTempAlloc is just like tempAlloc, but is used for regexp
36377:      *   compilation in RegExpNativeCompiler rather than normal compilation in
36377:      *   TraceRecorder.
36377:      *
36377:      * - codeAlloc has the same lifetime as dataAlloc, but its API is
36377:      *   different (CodeAlloc vs. VMAllocator).  It's used for native code.
36377:      *   It's also a good idea to keep code and data separate to avoid I-cache
36377:      *   vs. D-cache issues.
33545:      */
36377:     VMAllocator*            dataAlloc;
36377:     VMAllocator*            traceAlloc;
36377:     VMAllocator*            tempAlloc;
36377:     VMAllocator*            reTempAlloc;
36377:     nanojit::CodeAlloc*     codeAlloc;
34299:     nanojit::Assembler*     assembler;
34299:     FrameInfoCache*         frameCache;
31920: 
34299:     TraceRecorder*          recorder;
21491: 
37741:     GlobalState             globalStates[MONITOR_N_GLOBAL_STATES];
37741:     TreeFragment*           vmfragments[FRAGMENT_TABLE_SIZE];
38568:     RecordAttemptMap*       recordAttempts;
27379: 
27379:     /*
27884:      * Maximum size of the code cache before we start flushing. 1/16 of this
27884:      * size is used as threshold for the regular expression code cache.
27884:      */
27884:     uint32                  maxCodeCacheBytes;
27884: 
27884:     /*
28312:      * If nonzero, do not flush the JIT cache after a deep bail. That would
28312:      * free JITted code pages that we will later return to. Instead, set the
28312:      * needFlush flag so that it can be flushed later.
28312:      */
31526:     JSBool                  needFlush;
28312: 
28312:     /*
23448:      * reservedObjects is a linked list (via fslots[0]) of preallocated JSObjects.
23448:      * The JIT uses this to ensure that leaving a trace tree can't fail.
23448:      */
31526:     JSBool                  useReservedObjects;
23448:     JSObject                *reservedObjects;
23448: 
32767:     /*
32767:      * Fragment map for the regular expression compiler.
32767:      */
34299:     REHashMap*              reFragments;
21723: 
37694:     // Cached temporary typemap to avoid realloc'ing every time we create one.
37694:     // This must be used in only one place at a given time. It must be cleared
37694:     // before use.
37694:     TypeMap*                cachedTempTypeMap;
37694: 
32784: #ifdef DEBUG
32784:     /* Fields needed for fragment/guard profiling. */
34299:     nanojit::Seq<nanojit::Fragment*>* branches;
32788:     uint32                  lastFragID;
32784:     /*
32784:      * profAlloc has a lifetime which spans exactly from js_InitJIT to
32784:      * js_FinishJIT.
32784:      */
34299:     VMAllocator*            profAlloc;
34299:     FragStatsMap*           profTab;
32784: #endif
32784: 
31843:     /* Flush the JIT cache. */
31843:     void flush();
31843: 
31843:     /* Mark all objects baked into native code in the code cache. */
31843:     void mark(JSTracer *trc);
35083: 
35083:     bool outOfMemory() const;
26569: };
17583: 
37741: } /* namespace js */
24612: 
27577: /*
27577:  * N.B. JS_ON_TRACE(cx) is true if JIT code is on the stack in the current
27577:  * thread, regardless of whether cx is the context in which that trace is
27577:  * executing.  cx must be a context on the current thread.
27577:  */
18782: #ifdef JS_TRACER
27882: # define JS_ON_TRACE(cx)            (JS_TRACE_MONITOR(cx).tracecx != NULL)
18782: #else
18782: # define JS_ON_TRACE(cx)            JS_FALSE
18782: #endif
18782: 
36446: #ifdef DEBUG_brendan
24375: # define JS_EVAL_CACHE_METERING     1
27012: # define JS_FUNCTION_METERING       1
24375: #endif
24375: 
24375: /* Number of potentially reusable scriptsToGC to search for the eval cache. */
24375: #ifndef JS_EVAL_CACHE_SHIFT
24375: # define JS_EVAL_CACHE_SHIFT        6
24375: #endif
24375: #define JS_EVAL_CACHE_SIZE          JS_BIT(JS_EVAL_CACHE_SHIFT)
24375: 
24375: #ifdef JS_EVAL_CACHE_METERING
24375: # define EVAL_CACHE_METER_LIST(_)   _(probe), _(hit), _(step), _(noscope)
27012: # define identity(x)                x
24375: 
29923: struct JSEvalCacheMeter {
27012:     uint64 EVAL_CACHE_METER_LIST(identity);
29923: };
24375: 
27012: # undef identity
27012: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012: # define FUNCTION_KIND_METER_LIST(_)                                          \
27012:                         _(allfun), _(heavy), _(nofreeupvar), _(onlyfreevar),  \
27012:                         _(display), _(flat), _(setupvar), _(badfunarg)
27012: # define identity(x)    x
27012: 
35075: struct JSFunctionMeter {
27012:     int32 FUNCTION_KIND_METER_LIST(identity);
35075: };
27012: 
27012: # undef identity
24375: #endif
24375: 
35075: struct JSLocalRootChunk;
35075: 
35075: #define JSLRS_CHUNK_SHIFT       8
35075: #define JSLRS_CHUNK_SIZE        JS_BIT(JSLRS_CHUNK_SHIFT)
35075: #define JSLRS_CHUNK_MASK        JS_BITMASK(JSLRS_CHUNK_SHIFT)
35075: 
35075: struct JSLocalRootChunk {
35075:     jsval               roots[JSLRS_CHUNK_SIZE];
35075:     JSLocalRootChunk    *down;
35075: };
35075: 
35075: struct JSLocalRootStack {
35075:     uint32              scopeMark;
35075:     uint32              rootCount;
35075:     JSLocalRootChunk    *topChunk;
35075:     JSLocalRootChunk    firstChunk;
35075: 
35075:     /* See comments in js_NewFinalizableGCThing. */
35075:     JSGCFreeLists       gcFreeLists;
35075: };
35075: 
35075: const uint32 JSLRS_NULL_MARK = uint32(-1);
35075: 
26569: struct JSThreadData {
33952:     JSGCFreeLists       gcFreeLists;
33747: 
26569:     /*
35078:      * Flag indicating that we are waiving any soft limits on the GC heap
35078:      * because we want allocations to be infallible (except when we hit
35078:      * a hard quota).
35078:      */
35078:     bool                waiveGCQuota;
35078: 
35078:     /*
26569:      * The GSN cache is per thread since even multi-cx-per-thread embeddings
26569:      * do not interleave js_GetSrcNote calls.
26569:      */
26569:     JSGSNCache          gsnCache;
26569: 
26569:     /* Property cache for faster call/get/set invocation. */
26569:     JSPropertyCache     propertyCache;
26569: 
31898:     /* Random number generator state, used by jsmath.cpp. */
31898:     int64               rngSeed;
31898: 
35075:     /* Optional stack of heap-allocated scoped local GC roots. */
35075:     JSLocalRootStack    *localRootStack;
35075: 
26569: #ifdef JS_TRACER
26569:     /* Trace-tree JIT recorder/interpreter state. */
37741:     js::TraceMonitor    traceMonitor;
26569: #endif
26569: 
26569:     /* Lock-free hashed lists of scripts created by eval to garbage-collect. */
26569:     JSScript            *scriptsToGC[JS_EVAL_CACHE_SIZE];
26569: 
26569: #ifdef JS_EVAL_CACHE_METERING
26569:     JSEvalCacheMeter    evalCacheMeter;
26569: #endif
30453: 
32553:     /*
33128:      * Cache of reusable JSNativeEnumerators mapped by shape identifiers (as
33128:      * stored in scope->shape). This cache is nulled by the GC and protected
33128:      * by gcLock.
33128:      */
33128: #define NATIVE_ENUM_CACHE_LOG2  8
33128: #define NATIVE_ENUM_CACHE_MASK  JS_BITMASK(NATIVE_ENUM_CACHE_LOG2)
33128: #define NATIVE_ENUM_CACHE_SIZE  JS_BIT(NATIVE_ENUM_CACHE_LOG2)
33128: 
33128: #define NATIVE_ENUM_CACHE_HASH(shape)                                         \
33128:     ((((shape) >> NATIVE_ENUM_CACHE_LOG2) ^ (shape)) & NATIVE_ENUM_CACHE_MASK)
33128: 
33128:     jsuword             nativeEnumCache[NATIVE_ENUM_CACHE_SIZE];
33128: 
35075:     void init();
35075:     void finish();
35075:     void mark(JSTracer *trc);
35075:     void purge(JSContext *cx);
35075:     void purgeGCFreeLists();
26569: };
26569: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * Structure uniquely representing a thread.  It holds thread-private data
    1:  * that can be accessed without a global lock.
    1:  */
    1: struct JSThread {
28312:     /* Linked list of all contexts in use on this thread. */
    1:     JSCList             contextList;
    1: 
    1:     /* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */
    1:     jsword              id;
    1: 
27384:     /* Indicates that the thread is waiting in ClaimTitle from jslock.cpp. */
27384:     JSTitle             *titleToShare;
27384: 
34288:     /*
34288:      * Thread-local version of JSRuntime.gcMallocBytes to avoid taking
34288:      * locks on each JS_malloc.
34288:      */
34288:     ptrdiff_t           gcThreadMallocBytes;
34288: 
35075:     /*
37743:      * This thread is inside js_GC, either waiting until it can start GC, or
37743:      * waiting for GC to finish on another thread. This thread holds no locks;
37743:      * other threads may steal titles from it.
37743:      *
37743:      * Protected by rt->gcLock.
37743:      */
37743:     bool                gcWaiting;
37743: 
37743:     /*
35075:      * Deallocator task for this thread.
35075:      */
35075:     JSFreePointerListTask *deallocatorTask;
35075: 
28312:     /* Factored out of JSThread for !JS_THREADSAFE embedding in JSRuntime. */
26569:     JSThreadData        data;
    1: };
    1: 
34288: /*
34288:  * Only when JSThread::gcThreadMallocBytes exhausts the following limit we
34288:  * update JSRuntime::gcMallocBytes.
34288:  * .
34288:  */
34288: const size_t JS_GC_THREAD_MALLOC_LIMIT = 1 << 19;
34288: 
26569: #define JS_THREAD_DATA(cx)      (&(cx)->thread->data)
    1: 
26569: struct JSThreadsHashEntry {
26569:     JSDHashEntryHdr     base;
26569:     JSThread            *thread;
26569: };
26569: 
34365: extern JSThread *
34365: js_CurrentThread(JSRuntime *rt);
34365: 
26569: /*
26569:  * The function takes the GC lock and does not release in successful return.
26569:  * On error (out of memory) the function releases the lock but delegates
26569:  * the error reporting to the caller.
26569:  */
26569: extern JSBool
26569: js_InitContextThread(JSContext *cx);
26569: 
26569: /*
26569:  * On entrance the GC lock must be held and it will be held on exit.
26569:  */
26561: extern void
26569: js_ClearContextThread(JSContext *cx);
    1: 
    1: #endif /* JS_THREADSAFE */
    1: 
    1: typedef enum JSDestroyContextMode {
    1:     JSDCM_NO_GC,
    1:     JSDCM_MAYBE_GC,
    1:     JSDCM_FORCE_GC,
    1:     JSDCM_NEW_FAILED
    1: } JSDestroyContextMode;
    1: 
    1: typedef enum JSRuntimeState {
    1:     JSRTS_DOWN,
    1:     JSRTS_LAUNCHING,
    1:     JSRTS_UP,
    1:     JSRTS_LANDING
    1: } JSRuntimeState;
    1: 
24384: typedef enum JSBuiltinFunctionId {
24384:     JSBUILTIN_ObjectToIterator,
24384:     JSBUILTIN_CallIteratorNext,
24384:     JSBUILTIN_LIMIT
24384: } JSBuiltinFunctionId;
24384: 
    1: typedef struct JSPropertyTreeEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSScopeProperty     *child;
    1: } JSPropertyTreeEntry;
    1: 
11041: typedef struct JSSetSlotRequest JSSetSlotRequest;
11041: 
11041: struct JSSetSlotRequest {
11041:     JSObject            *obj;           /* object containing slot to set */
11041:     JSObject            *pobj;          /* new proto or parent reference */
11041:     uint16              slot;           /* which to set, proto or parent */
28003:     JSPackedBool        cycle;          /* true if a cycle was detected */
11041:     JSSetSlotRequest    *next;          /* next request in GC worklist */
11041: };
11041: 
38604: /* Caching Class.prototype lookups for the standard classes. */
38604: struct JSClassProtoCache {
40229:     void purge() { js::PodArrayZero(entries); }
38604: 
38604: #ifdef JS_PROTO_CACHE_METERING
38604:     struct Stats {
38604:         int32       probe, hit;
38604:     };
38604: # define PROTO_CACHE_METER(cx, x)                                             \
38605:     ((void) (JS_ATOMIC_INCREMENT(&(cx)->runtime->classProtoCacheStats.x)))
38604: #else
38604: # define PROTO_CACHE_METER(cx, x)  ((void) 0)
38604: #endif
38604: 
38604:   private:
38604:     struct GlobalAndProto {
38604:         JSObject    *global;
38604:         JSObject    *proto;
38604:     };
38604: 
38604:     GlobalAndProto  entries[JSProto_LIMIT - JSProto_Object];
38604: 
38604:     friend JSBool js_GetClassPrototype(JSContext *cx, JSObject *scope,
38604:                                        JSProtoKey protoKey, JSObject **protop,
38604:                                        JSClass *clasp);
38604: };
38604: 
    1: struct JSRuntime {
    1:     /* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */
    1:     JSRuntimeState      state;
    1: 
    1:     /* Context create/destroy callback. */
    1:     JSContextCallback   cxCallback;
    1: 
28312:     /*
28312:      * Shape regenerated whenever a prototype implicated by an "add property"
28312:      * property cache fill and induced trace guard has a readonly property or a
28312:      * setter defined on it. This number proxies for the shapes of all objects
28312:      * along the prototype chain of all objects in the runtime on which such an
28312:      * add-property result has been cached/traced.
28312:      *
28312:      * See bug 492355 for more details.
28312:      *
28312:      * This comes early in JSRuntime to minimize the immediate format used by
28312:      * trace-JITted code that reads it.
28312:      */
28312:     uint32              protoHazardShape;
28312: 
    1:     /* Garbage collector state, used by jsgc.c. */
32823:     JSGCChunkInfo       *gcChunkList;
33582:     JSGCArenaList       gcArenaList[FINALIZE_LIMIT];
12282:     JSGCDoubleArenaList gcDoubleArenaList;
    1:     JSDHashTable        gcRootsHash;
36680:     JSDHashTable        gcLocksHash;
    1:     jsrefcount          gcKeepAtoms;
32553:     size_t              gcBytes;
32553:     size_t              gcLastBytes;
32553:     size_t              gcMaxBytes;
32553:     size_t              gcMaxMallocBytes;
19196:     uint32              gcEmptyArenaPoolLifespan;
    1:     uint32              gcLevel;
    1:     uint32              gcNumber;
  583:     JSTracer            *gcMarkingTracer;
32553:     uint32              gcTriggerFactor;
32553:     size_t              gcTriggerBytes;
27546:     volatile JSBool     gcIsNeeded;
31885:     volatile JSBool     gcFlushCodeCaches;
    1: 
    1:     /*
    1:      * NB: do not pack another flag here by claiming gcPadding unless the new
    1:      * flag is written only by the GC thread.  Atomic updates to packed bytes
    1:      * are not guaranteed, so stores issued by one thread may be lost due to
    1:      * unsynchronized read-modify-write cycles on other threads.
    1:      */
    1:     JSPackedBool        gcPoke;
    1:     JSPackedBool        gcRunning;
30733:     JSPackedBool        gcRegenShapes;
30845: 
30845:     /*
30845:      * During gc, if rt->gcRegenShapes &&
30845:      *   (scope->flags & JSScope::SHAPE_REGEN) == rt->gcRegenShapesScopeFlag,
30845:      * then the scope's shape has already been regenerated during this GC.
30845:      * To avoid having to sweep JSScopes, the bit's meaning toggles with each
30845:      * shape-regenerating GC.
30845:      *
30845:      * FIXME Once scopes are GC'd (bug 505004), this will be obsolete.
30845:      */
30845:     uint8               gcRegenShapesScopeFlag;
30845: 
 1492: #ifdef JS_GC_ZEAL
 7944:     jsrefcount          gcZeal;
 1492: #endif
    1: 
    1:     JSGCCallback        gcCallback;
34288: 
34288:     /*
34288:      * Malloc counter to measure memory pressure for GC scheduling. It runs
34288:      * from gcMaxMallocBytes down to zero.
34288:      */
34288:     ptrdiff_t           gcMallocBytes;
34288: 
36410:     /* See comments before DelayMarkingChildren is jsgc.cpp. */
37684:     JSGCArena           *gcUnmarkedArenaStackTop;
    1: #ifdef DEBUG
36410:     size_t              gcMarkLaterCount;
    1: #endif
    1: 
    1:     /*
    1:      * Table for tracking iterators to ensure that we close iterator's state
    1:      * before finalizing the iterable object.
    1:      */
34299:     js::Vector<JSObject*, 0, js::SystemAllocPolicy> gcIteratorTable;
    1: 
  958:     /*
  958:      * The trace operation and its data argument to trace embedding-specific
  958:      * GC roots.
  958:      */
  958:     JSTraceDataOp       gcExtraRootsTraceOp;
  958:     void                *gcExtraRootsData;
  958: 
11041:     /*
11041:      * Used to serialize cycle checks when setting __proto__ or __parent__ by
11041:      * requesting the GC handle the required cycle detection. If the GC hasn't
11041:      * been poked, it won't scan for garbage. This member is protected by
11041:      * rt->gcLock.
11041:      */
11041:     JSSetSlotRequest    *setSlotRequests;
11041: 
    1:     /* Well-known numbers held for use by this runtime's contexts. */
34372:     jsval               NaNValue;
34372:     jsval               negativeInfinityValue;
34372:     jsval               positiveInfinityValue;
    1: 
40267: #ifdef JS_THREADSAFE
40267:     JSLock              *deflatedStringCacheLock;
40267: #endif
40267:     JSHashTable         *deflatedStringCache;
40267: #ifdef DEBUG
40267:     uint32              deflatedStringCacheBytes;
40267: #endif
    1: 
    1:     JSString            *emptyString;
    1: 
24384:     /*
24384:      * Builtin functions, lazily created and held for use by the trace recorder.
24384:      *
24384:      * This field would be #ifdef JS_TRACER, but XPConnect is compiled without
24384:      * -DJS_TRACER and includes this header.
24384:      */
24384:     JSObject            *builtinFunctions[JSBUILTIN_LIMIT];
24384: 
    1:     /* List of active contexts sharing this runtime; protected by gcLock. */
    1:     JSCList             contextList;
    1: 
 2433:     /* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */
 2433:     JSDebugHooks        globalDebugHooks;
    1: 
35331: #ifdef JS_TRACER
35331:     /* True if any debug hooks not supported by the JIT are enabled. */
35331:     bool debuggerInhibitsJIT() const {
35331:         return (globalDebugHooks.interruptHandler ||
35331:                 globalDebugHooks.callHook ||
35331:                 globalDebugHooks.objectHook);
35331:     }
35331: #endif
35331: 
    1:     /* More debugging state, see jsdbgapi.c. */
    1:     JSCList             trapList;
    1:     JSCList             watchPointList;
    1: 
20312:     /* Client opaque pointers */
    1:     void                *data;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     /* These combine to interlock the GC and new requests. */
    1:     PRLock              *gcLock;
    1:     PRCondVar           *gcDone;
    1:     PRCondVar           *requestDone;
    1:     uint32              requestCount;
    1:     JSThread            *gcThread;
    1: 
    1:     /* Lock and owning thread pointer for JS_LOCK_RUNTIME. */
    1:     PRLock              *rtLock;
    1: #ifdef DEBUG
    1:     jsword              rtLockOwner;
    1: #endif
    1: 
    1:     /* Used to synchronize down/up state change; protected by gcLock. */
    1:     PRCondVar           *stateChange;
    1: 
    1:     /*
11739:      * State for sharing single-threaded titles, once a second thread tries to
11739:      * lock a title.  The titleSharingDone condvar is protected by rt->gcLock
    1:      * to minimize number of locks taken in JS_EndRequest.
    1:      *
11739:      * The titleSharingTodo linked list is likewise "global" per runtime, not
    1:      * one-list-per-context, to conserve space over all contexts, optimizing
11739:      * for the likely case that titles become shared rarely, and among a very
    1:      * small set of threads (contexts).
    1:      */
11739:     PRCondVar           *titleSharingDone;
11739:     JSTitle             *titleSharingTodo;
    1: 
    1: /*
11739:  * Magic terminator for the rt->titleSharingTodo linked list, threaded through
11739:  * title->u.link.  This hack allows us to test whether a title is on the list
11739:  * by asking whether title->u.link is non-null.  We use a large, likely bogus
    1:  * pointer here to distinguish this value from any valid u.count (small int)
    1:  * value.
    1:  */
11739: #define NO_TITLE_SHARING_TODO   ((JSTitle *) 0xfeedbeef)
    1: 
    1:     /*
    1:      * Lock serializing trapList and watchPointList accesses, and count of all
    1:      * mutations to trapList and watchPointList made by debugger threads.  To
    1:      * keep the code simple, we define debuggerMutations for the thread-unsafe
    1:      * case too.
    1:      */
    1:     PRLock              *debuggerLock;
26569: 
26569:     JSDHashTable        threads;
    1: #endif /* JS_THREADSAFE */
    1:     uint32              debuggerMutations;
    1: 
    1:     /*
18870:      * Security callbacks set on the runtime are used by each context unless
18870:      * an override is set on the context.
    1:      */
18870:     JSSecurityCallbacks *securityCallbacks;
    1: 
    1:     /*
    1:      * Shared scope property tree, and arena-pool for allocating its nodes.
30258:      * The propertyRemovals counter is incremented for every JSScope::clear,
30258:      * and for each JSScope::remove method call that frees a slot in an object.
    1:      * See js_NativeGet and js_NativeSet in jsobj.c.
    1:      */
    1:     JSDHashTable        propertyTreeHash;
    1:     JSScopeProperty     *propertyFreeList;
    1:     JSArenaPool         propertyArenaPool;
    1:     int32               propertyRemovals;
    1: 
    1:     /* Script filename table. */
    1:     struct JSHashTable  *scriptFilenameTable;
    1:     JSCList             scriptFilenamePrefixes;
    1: #ifdef JS_THREADSAFE
    1:     PRLock              *scriptFilenameTableLock;
    1: #endif
    1: 
    1:     /* Number localization, used by jsnum.c */
    1:     const char          *thousandsSeparator;
    1:     const char          *decimalSeparator;
    1:     const char          *numGrouping;
    1: 
    1:     /*
    1:      * Weak references to lazily-created, well-known XML singletons.
    1:      *
    1:      * NB: Singleton objects must be carefully disconnected from the rest of
    1:      * the object graph usually associated with a JSContext's global object,
    1:      * including the set of standard class objects.  See jsxml.c for details.
    1:      */
    1:     JSObject            *anynameObject;
    1:     JSObject            *functionNamespaceObject;
    1: 
    1: #ifndef JS_THREADSAFE
26569:     JSThreadData        threadData;
    1: 
26569: #define JS_THREAD_DATA(cx)      (&(cx)->runtime->threadData)
    1: #endif
    1: 
11377:     /*
11377:      * Object shape (property cache structural type) identifier generator.
11377:      *
11377:      * Type 0 stands for the empty scope, and must not be regenerated due to
27546:      * uint32 wrap-around. Since js_GenerateShape (in jsinterp.cpp) uses
27546:      * atomic pre-increment, the initial value for the first typed non-empty
27546:      * scope will be 1.
11377:      *
11377:      * If this counter overflows into SHAPE_OVERFLOW_BIT (in jsinterp.h), the
27546:      * cache is disabled, to avoid aliasing two different types. It stays
27546:      * disabled until a triggered GC at some later moment compresses live
27546:      * types, minimizing rt->shapeGen in the process.
11377:      */
27546:     volatile uint32     shapeGen;
11377: 
 4342:     /* Literal table maintained by jsatom.c functions. */
 4342:     JSAtomState         atomState;
 4342: 
34288: #ifdef JS_THREADSAFE
34288:     JSBackgroundThread    *deallocatorThread;
34288: #endif
34288: 
37766:     JSEmptyScope          *emptyBlockScope;
37766: 
10954:     /*
10954:      * Various metering fields are defined at the end of JSRuntime. In this
10954:      * way there is no need to recompile all the code that refers to other
10954:      * fields of JSRuntime after enabling the corresponding metering macro.
10954:      */
17049: #ifdef JS_DUMP_ENUM_CACHE_STATS
17049:     int32               nativeEnumProbes;
17049:     int32               nativeEnumMisses;
17049: # define ENUM_CACHE_METER(name)     JS_ATOMIC_INCREMENT(&cx->runtime->name)
17049: #else
17049: # define ENUM_CACHE_METER(name)     ((void) 0)
17049: #endif
10954: 
17182: #ifdef JS_DUMP_LOOP_STATS
17182:     /* Loop statistics, to trigger trace recording and compiling. */
17182:     JSBasicStats        loopStats;
17182: #endif
17182: 
35453: #ifdef DEBUG
    1:     /* Function invocation metering. */
    1:     jsrefcount          inlineCalls;
    1:     jsrefcount          nativeCalls;
    1:     jsrefcount          nonInlineCalls;
    1:     jsrefcount          constructs;
    1: 
11739:     /* Title lock and scope property metering. */
    1:     jsrefcount          claimAttempts;
11739:     jsrefcount          claimedTitles;
    1:     jsrefcount          deadContexts;
    1:     jsrefcount          deadlocksAvoided;
    1:     jsrefcount          liveScopes;
11739:     jsrefcount          sharedTitles;
    1:     jsrefcount          totalScopes;
    1:     jsrefcount          liveScopeProps;
10217:     jsrefcount          liveScopePropsPreSweep;
    1:     jsrefcount          totalScopeProps;
    1:     jsrefcount          livePropTreeNodes;
    1:     jsrefcount          duplicatePropTreeNodes;
    1:     jsrefcount          totalPropTreeNodes;
    1:     jsrefcount          propTreeKidsChunks;
    1: 
    1:     /* String instrumentation. */
    1:     jsrefcount          liveStrings;
    1:     jsrefcount          totalStrings;
    1:     jsrefcount          liveDependentStrings;
    1:     jsrefcount          totalDependentStrings;
10217:     jsrefcount          badUndependStrings;
    1:     double              lengthSum;
    1:     double              lengthSquaredSum;
    1:     double              strdepLengthSum;
    1:     double              strdepLengthSquaredSum;
34290: 
34290:     /* Script instrumentation. */
34290:     jsrefcount          liveScripts;
34290:     jsrefcount          totalScripts;
34290:     jsrefcount          liveEmptyScripts;
34290:     jsrefcount          totalEmptyScripts;
35453: #endif /* DEBUG */
10217: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     /*
10217:      * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
10217:      * counts of objects traversed on a chain until the wanted id is found.
10217:      */
10217:     JSBasicStats        protoLookupDepthStats;
10217:     JSBasicStats        scopeSearchDepthStats;
10217: 
10217:     /*
10217:      * Stats on compile-time host environment and lexical scope chain lengths
10217:      * (maximum depths).
10217:      */
10217:     JSBasicStats        hostenvScopeDepthStats;
10217:     JSBasicStats        lexicalScopeDepthStats;
    1: #endif
10954: 
10954: #ifdef JS_GCMETER
10954:     JSGCStats           gcStats;
10954: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012:     JSFunctionMeter     functionMeter;
27012:     char                lastScriptFilename[1024];
27012: #endif
30438: 
38604: #ifdef JS_PROTO_CACHE_METERING
38604:     JSClassProtoCache::Stats classProtoCacheStats;
38604: #endif
38604: 
34299:     JSRuntime();
34299:     ~JSRuntime();
34299: 
34299:     bool init(uint32 maxbytes);
34299: 
32553:     void setGCTriggerFactor(uint32 factor);
32553:     void setGCLastBytes(size_t lastBytes);
32553: 
34288:     void* malloc(size_t bytes) { return ::js_malloc(bytes); }
34288: 
34288:     void* calloc(size_t bytes) { return ::js_calloc(bytes); }
34288: 
34288:     void* realloc(void* p, size_t bytes) { return ::js_realloc(p, bytes); }
34288: 
34288:     void free(void* p) { ::js_free(p); }
34288: 
34288:     bool isGCMallocLimitReached() const { return gcMallocBytes <= 0; }
34288: 
34288:     void resetGCMallocBytes() { gcMallocBytes = ptrdiff_t(gcMaxMallocBytes); }
34288: 
34288:     void setGCMaxMallocBytes(size_t value) {
34288:         /*
34288:          * For compatibility treat any value that exceeds PTRDIFF_T_MAX to
34288:          * mean that value.
34288:          */
34288:         gcMaxMallocBytes = (ptrdiff_t(value) >= 0) ? value : size_t(-1) >> 1;
34288:         resetGCMallocBytes();
30851:     }
    1: };
    1: 
24375: /* Common macros to access thread-local caches in JSThread or JSRuntime. */
26569: #define JS_GSN_CACHE(cx)        (JS_THREAD_DATA(cx)->gsnCache)
26569: #define JS_PROPERTY_CACHE(cx)   (JS_THREAD_DATA(cx)->propertyCache)
26569: #define JS_TRACE_MONITOR(cx)    (JS_THREAD_DATA(cx)->traceMonitor)
26569: #define JS_SCRIPTS_TO_GC(cx)    (JS_THREAD_DATA(cx)->scriptsToGC)
24375: 
24375: #ifdef JS_EVAL_CACHE_METERING
26569: # define EVAL_CACHE_METER(x)    (JS_THREAD_DATA(cx)->evalCacheMeter.x++)
24375: #else
24375: # define EVAL_CACHE_METER(x)    ((void) 0)
24375: #endif
24375: 
    1: #ifdef DEBUG
    1: # define JS_RUNTIME_METER(rt, which)    JS_ATOMIC_INCREMENT(&(rt)->which)
    1: # define JS_RUNTIME_UNMETER(rt, which)  JS_ATOMIC_DECREMENT(&(rt)->which)
    1: #else
    1: # define JS_RUNTIME_METER(rt, which)    /* nothing */
    1: # define JS_RUNTIME_UNMETER(rt, which)  /* nothing */
    1: #endif
    1: 
    1: #define JS_KEEP_ATOMS(rt)   JS_ATOMIC_INCREMENT(&(rt)->gcKeepAtoms);
    1: #define JS_UNKEEP_ATOMS(rt) JS_ATOMIC_DECREMENT(&(rt)->gcKeepAtoms);
    1: 
    1: #ifdef JS_ARGUMENT_FORMATTER_DEFINED
    1: /*
    1:  * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
    1:  * formatter functions.  Elements are sorted in non-increasing format string
    1:  * length order.
    1:  */
    1: struct JSArgumentFormatMap {
    1:     const char          *format;
    1:     size_t              length;
    1:     JSArgumentFormatter formatter;
    1:     JSArgumentFormatMap *next;
    1: };
    1: #endif
    1: 
    1: struct JSStackHeader {
    1:     uintN               nslots;
    1:     JSStackHeader       *down;
    1: };
    1: 
    1: #define JS_STACK_SEGMENT(sh)    ((jsval *)(sh) + 2)
    1: 
    1: /*
    1:  * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
    1:  * here because all consumers need to see these declarations (and not just the
    1:  * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
    1:  * declaration), along with cx->resolvingTable.
    1:  */
    1: typedef struct JSResolvingKey {
    1:     JSObject            *obj;
    1:     jsid                id;
    1: } JSResolvingKey;
    1: 
    1: typedef struct JSResolvingEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSResolvingKey      key;
    1:     uint32              flags;
    1: } JSResolvingEntry;
    1: 
    1: #define JSRESFLAG_LOOKUP        0x1     /* resolving id from lookup */
    1: #define JSRESFLAG_WATCH         0x2     /* resolving id from watch */
19712: #define JSRESOLVE_INFER         0xffff  /* infer bits from current bytecode */
19712: 
37717: extern const JSDebugHooks js_NullDebugHooks;  /* defined in jsdbgapi.cpp */
37717: 
37777: /*
37777:  * Wraps a stack frame which has been temporarily popped from its call stack
37777:  * and needs to be GC-reachable. See JSContext::{push,pop}GCReachableFrame.
37777:  */
38604: struct JSGCReachableFrame {
37777:     JSGCReachableFrame  *next;
37777:     JSStackFrame        *frame;
37777: };
37777: 
40221: namespace js {
40221: class AutoGCRooter;
40221: }
40221: 
38568: struct JSContext
38568: {
38568:     explicit JSContext(JSRuntime *rt) : runtime(rt), busyArrays(this) {}
38568: 
 9780:     /*
25087:      * If this flag is set, we were asked to call back the operation callback
25087:      * as soon as possible.
 9780:      */
25087:     volatile jsint      operationCallbackFlag;
    1: 
23092:     /* JSRuntime contextList linkage. */
23092:     JSCList             link;
23092: 
    1: #if JS_HAS_XML_SUPPORT
    1:     /*
    1:      * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
    1:      * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
    1:      * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
    1:      * property values associated with this context's global object.
    1:      */
    1:     uint8               xmlSettingFlags;
18782:     uint8               padding;
18041: #else
18782:     uint16              padding;
    1: #endif
    1: 
18041:     /*
18308:      * Classic Algol "display" static link optimization.
18308:      */
27109: #define JS_DISPLAY_SIZE 16U
18308: 
18308:     JSStackFrame        *display[JS_DISPLAY_SIZE];
18308: 
    1:     /* Runtime version control identifier. */
    1:     uint16              version;
    1: 
    1:     /* Per-context options. */
    1:     uint32              options;            /* see jsapi.h for JSOPTION_* */
    1: 
    1:     /* Locale specific callbacks for string conversion. */
    1:     JSLocaleCallbacks   *localeCallbacks;
    1: 
    1:     /*
    1:      * cx->resolvingTable is non-null and non-empty if we are initializing
    1:      * standard classes lazily, or if we are otherwise recursing indirectly
    1:      * from js_LookupProperty through a JSClass.resolve hook.  It is used to
    1:      * limit runaway recursion (see jsapi.c and jsobj.c).
    1:      */
    1:     JSDHashTable        *resolvingTable;
    1: 
    1:     /*
    1:      * True if generating an error, to prevent runaway recursion.
31815:      * NB: generatingError packs with insideGCMarkCallback and throwing below.
    1:      */
    1:     JSPackedBool        generatingError;
    1: 
    1:     /* Flag to indicate that we run inside gcCallback(cx, JSGC_MARK_END). */
    1:     JSPackedBool        insideGCMarkCallback;
    1: 
    1:     /* Exception state -- the exception member is a GC root by definition. */
    1:     JSPackedBool        throwing;           /* is there a pending exception? */
    1:     jsval               exception;          /* most-recently-thrown exception */
    1: 
 5344:     /* Limit pointer for checking native stack consumption during recursion. */
    1:     jsuword             stackLimit;
    1: 
 5344:     /* Quota on the size of arenas used to compile and execute scripts. */
 5344:     size_t              scriptStackQuota;
 5344: 
    1:     /* Data shared by threads in an address space. */
32777:     JSRuntime * const   runtime;
32777: 
    1:     /* Stack arena pool and frame pointer register. */
24499:     JS_REQUIRES_STACK
    1:     JSArenaPool         stackPool;
22652: 
22652:     JS_REQUIRES_STACK
    1:     JSStackFrame        *fp;
    1: 
    1:     /* Temporary arena pool used while compiling and decompiling. */
    1:     JSArenaPool         tempPool;
    1: 
    1:     /* Top-level object and pointer to top stack frame's scope chain. */
    1:     JSObject            *globalObject;
    1: 
    1:     /* Storage to root recently allocated GC things and script result. */
    1:     JSWeakRoots         weakRoots;
    1: 
    1:     /* Regular expression class statics (XXX not shared globally). */
    1:     JSRegExpStatics     regExpStatics;
    1: 
    1:     /* State for object and array toSource conversion. */
    1:     JSSharpObjectMap    sharpObjectMap;
38568:     js::HashSet<JSObject *> busyArrays;
    1: 
    1:     /* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */
    1:     JSArgumentFormatMap *argumentFormatMap;
    1: 
    1:     /* Last message string and trace file for debugging. */
    1:     char                *lastMessage;
    1: #ifdef DEBUG
    1:     void                *tracefp;
27233:     jsbytecode          *tracePrevPc;
    1: #endif
    1: 
 9780:     /* Per-context optional error reporter. */
    1:     JSErrorReporter     errorReporter;
    1: 
25087:     /* Branch callback. */
 9780:     JSOperationCallback operationCallback;
 9780: 
    1:     /* Interpreter activation count. */
    1:     uintN               interpLevel;
    1: 
20312:     /* Client opaque pointers. */
    1:     void                *data;
20312:     void                *data2;
    1: 
37777:     /* Linked list of frames temporarily popped from their chain. */
37777:     JSGCReachableFrame  *reachableFrames;
37777: 
37777:     void pushGCReachableFrame(JSGCReachableFrame &gcrf, JSStackFrame *f) {
37777:         gcrf.next = reachableFrames;
37777:         gcrf.frame = f;
37777:         reachableFrames = &gcrf;
37777:     }
37777: 
37777:     void popGCReachableFrame() {
37777:         reachableFrames = reachableFrames->next;
37777:     }
37777: 
37777:   private:
38510: #ifdef __GNUC__
38510: # pragma GCC visibility push(default)
38510: #endif
37777:     friend void js_TraceContext(JSTracer *, JSContext *);
38510: #ifdef __GNUC__
38510: # pragma GCC visibility pop
38510: #endif
37777: 
37777:     /* Linked list of callstacks. See CallStack. */
37777:     js::CallStack       *currentCallStack;
37777: 
37777:   public:
37777:     /* Assuming there is an active callstack, return it. */
37777:     js::CallStack *activeCallStack() const {
37777:         JS_ASSERT(currentCallStack && !currentCallStack->isSaved());
37777:         return currentCallStack;
37777:     }
37777: 
37777:     /* Add the given callstack to the list as the new active callstack. */
37777:     void pushCallStack(js::CallStack *newcs) {
37777:         if (fp)
37777:             currentCallStack->suspend(fp);
37777:         else
37777:             JS_ASSERT_IF(currentCallStack, currentCallStack->isSaved());
37777:         newcs->setPrevious(currentCallStack);
37777:         currentCallStack = newcs;
37777:         JS_ASSERT(!newcs->isSuspended() && !newcs->isSaved());
37777:     }
37777: 
37777:     /* Remove the active callstack and make the next callstack active. */
37777:     void popCallStack() {
37777:         JS_ASSERT(!currentCallStack->isSuspended() && !currentCallStack->isSaved());
37777:         currentCallStack = currentCallStack->getPrevious();
37777:         if (currentCallStack && !currentCallStack->isSaved()) {
37777:             JS_ASSERT(fp);
37777:             currentCallStack->resume();
37777:         }
37777:     }
37777: 
37777:     /* Mark the top callstack as suspended, without pushing a new one. */
37777:     void saveActiveCallStack() {
37777:         JS_ASSERT(fp && currentCallStack && !currentCallStack->isSuspended());
37777:         currentCallStack->save(fp);
37777:         fp = NULL;
37777:     }
37777: 
37777:     /* Undoes calls to suspendTopCallStack. */
37777:     void restoreCallStack() {
37777:         JS_ASSERT(!fp && currentCallStack && currentCallStack->isSuspended());
37777:         fp = currentCallStack->getSuspendedFrame();
37777:         currentCallStack->restore();
37777:     }
37777: 
40276:     /*
40276:      * Perform a linear search of all frames in all callstacks in the given context
40276:      * for the given frame, returning the callstack, if found, and null otherwise.
40276:      */
40276:     js::CallStack *containingCallStack(JSStackFrame *target);
40276: 
    1: #ifdef JS_THREADSAFE
    1:     JSThread            *thread;
    1:     jsrefcount          requestDepth;
 7286:     /* Same as requestDepth but ignoring JS_SuspendRequest/JS_ResumeRequest */
 7286:     jsrefcount          outstandingRequests;
11739:     JSTitle             *lockedSealedTitle; /* weak ref, for low-cost sealed
11739:                                                title locking */
    1:     JSCList             threadLinks;        /* JSThread contextList linkage */
    1: 
    1: #define CX_FROM_THREAD_LINKS(tl) \
    1:     ((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))
    1: #endif
    1: 
    1:     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
    1:     JSStackHeader       *stackHeaders;
    1: 
40221:     /* Stack of thread-stack-allocated GC roots. */
40221:     js::AutoGCRooter   *autoGCRooters;
 2433: 
 2433:     /* Debug hooks associated with the current context. */
35331:     const JSDebugHooks  *debugHooks;
18870: 
18870:     /* Security callbacks that override any defined on the runtime. */
18870:     JSSecurityCallbacks *securityCallbacks;
19196: 
19196:     /* Pinned regexp pool used for regular expressions. */
19196:     JSArenaPool         regexpPool;
19712: 
19712:     /* Stored here to avoid passing it around as a parameter. */
19712:     uintN               resolveFlags;
24598: 
24612: #ifdef JS_TRACER
24612:     /*
24612:      * State for the current tree execution.  bailExit is valid if the tree has
24612:      * called back into native code via a _FAIL builtin and has not yet bailed,
24612:      * else garbage (NULL in debug builds).
24612:      */
37741:     js::InterpState     *interpState;
37741:     js::VMSideExit      *bailExit;
35331: 
35331:     /*
35331:      * True if traces may be executed. Invariant: The value of jitEnabled is
35331:      * always equal to the expression in updateJITEnabled below.
35331:      *
35331:      * This flag and the fields accessed by updateJITEnabled are written only
35331:      * in runtime->gcLock, to avoid race conditions that would leave the wrong
35331:      * value in jitEnabled. (But the interpreter reads this without
35331:      * locking. That can race against another thread setting debug hooks, but
35331:      * we always read cx->debugHooks without locking anyway.)
35331:      */
35331:     bool                 jitEnabled;
24612: #endif
30453: 
38604:     JSClassProtoCache    classProtoCache;
38604: 
35331:     /* Caller must be holding runtime->gcLock. */
35331:     void updateJITEnabled() {
35331: #ifdef JS_TRACER
35331:         jitEnabled = ((options & JSOPTION_JIT) &&
37717:                       (debugHooks == &js_NullDebugHooks ||
37717:                        (debugHooks == &runtime->globalDebugHooks &&
37717:                         !runtime->debuggerInhibitsJIT())));
35331: #endif
35331:     }
35331: 
30851: #ifdef JS_THREADSAFE
32553:     inline void createDeallocatorTask() {
35075:         JS_ASSERT(!thread->deallocatorTask);
30851:         if (runtime->deallocatorThread && !runtime->deallocatorThread->busy())
35075:             thread->deallocatorTask = new JSFreePointerListTask();
30851:     }
30851: 
30851:     inline void submitDeallocatorTask() {
35075:         if (thread->deallocatorTask) {
35075:             runtime->deallocatorThread->schedule(thread->deallocatorTask);
35075:             thread->deallocatorTask = NULL;
30851:         }
30851:     }
30851: #endif
30851: 
34288:     ptrdiff_t &getMallocCounter() {
34288: #ifdef JS_THREADSAFE
34288:         return thread->gcThreadMallocBytes;
34288: #else
34288:         return runtime->gcMallocBytes;
34288: #endif
34288:     }
34288: 
34288:     /*
34288:      * Call this after allocating memory held by GC things, to update memory
34288:      * pressure counters or report the OOM error if necessary.
34288:      */
34288:     inline void updateMallocCounter(void *p, size_t nbytes) {
34288:         JS_ASSERT(ptrdiff_t(nbytes) >= 0);
34288:         ptrdiff_t &counter = getMallocCounter();
34288:         counter -= ptrdiff_t(nbytes);
34288:         if (!p || counter <= 0)
34288:             checkMallocGCPressure(p);
34288:     }
34288: 
34288:     /*
34288:      * Call this after successfully allocating memory held by GC things, to
34288:      * update memory pressure counters.
34288:      */
32553:     inline void updateMallocCounter(size_t nbytes) {
34288:         JS_ASSERT(ptrdiff_t(nbytes) >= 0);
34288:         ptrdiff_t &counter = getMallocCounter();
34288:         counter -= ptrdiff_t(nbytes);
34288:         if (counter <= 0) {
34288:             /*
34288:              * Use 1 as an arbitrary non-null pointer indicating successful
34288:              * allocation.
34288:              */
34288:             checkMallocGCPressure(reinterpret_cast<void *>(jsuword(1)));
34288:         }
32553:     }
32553: 
30851:     inline void* malloc(size_t bytes) {
30851:         JS_ASSERT(bytes != 0);
30851:         void *p = runtime->malloc(bytes);
34288:         updateMallocCounter(p, bytes);
30851:         return p;
30851:     }
30851: 
33128:     inline void* mallocNoReport(size_t bytes) {
33128:         JS_ASSERT(bytes != 0);
33128:         void *p = runtime->malloc(bytes);
33128:         if (!p)
33128:             return NULL;
33128:         updateMallocCounter(bytes);
33128:         return p;
33128:     }
33128: 
30851:     inline void* calloc(size_t bytes) {
30851:         JS_ASSERT(bytes != 0);
30851:         void *p = runtime->calloc(bytes);
34288:         updateMallocCounter(p, bytes);
30851:         return p;
30851:     }
30851: 
30851:     inline void* realloc(void* p, size_t bytes) {
32553:         void *orig = p;
30851:         p = runtime->realloc(p, bytes);
34288: 
34288:         /*
34288:          * For compatibility we do not account for realloc that increases
34288:          * previously allocated memory.
34288:          */
34288:         updateMallocCounter(p, orig ? 0 : bytes);
30851:         return p;
30851:     }
30851: 
30851: #ifdef JS_THREADSAFE
30851:     inline void free(void* p) {
30851:         if (!p)
30851:             return;
30851:         if (thread) {
35075:             JSFreePointerListTask* task = thread->deallocatorTask;
30851:             if (task) {
30851:                 task->add(p);
30851:                 return;
30851:             }
30851:         }
30851:         runtime->free(p);
30851:     }
30851: #else
30851:     inline void free(void* p) {
30851:         if (!p)
30851:             return;
30851:         runtime->free(p);
30851:     }
30851: #endif
32651: 
32651:     /*
32651:      * In the common case that we'd like to allocate the memory for an object
32651:      * with cx->malloc/free, we cannot use overloaded C++ operators (no
32651:      * placement delete).  Factor the common workaround into one place.
32651:      */
32651: #define CREATE_BODY(parms)                                                    \
32651:     void *memory = this->malloc(sizeof(T));                                   \
34288:     if (!memory)                                                              \
32651:         return NULL;                                                          \
32651:     return new(memory) T parms;
32651: 
32651:     template <class T>
32651:     JS_ALWAYS_INLINE T *create() {
32651:         CREATE_BODY(())
32651:     }
32651: 
32651:     template <class T, class P1>
32651:     JS_ALWAYS_INLINE T *create(const P1 &p1) {
32651:         CREATE_BODY((p1))
32651:     }
32651: 
32651:     template <class T, class P1, class P2>
32651:     JS_ALWAYS_INLINE T *create(const P1 &p1, const P2 &p2) {
32651:         CREATE_BODY((p1, p2))
32651:     }
32651: 
32651:     template <class T, class P1, class P2, class P3>
32651:     JS_ALWAYS_INLINE T *create(const P1 &p1, const P2 &p2, const P3 &p3) {
32651:         CREATE_BODY((p1, p2, p3))
32651:     }
32651: #undef CREATE_BODY
32651: 
32651:     template <class T>
32651:     JS_ALWAYS_INLINE void destroy(T *p) {
32651:         p->~T();
32651:         this->free(p);
32651:     }
34288: 
37739:     bool isConstructing();
37739: 
38604:     void purge();
38604: 
34288: private:
34288: 
34288:     /*
34288:      * The allocation code calls the function to indicate either OOM failure
34288:      * when p is null or that a memory pressure counter has reached some
34288:      * threshold when p is not null. The function takes the pointer and not
34288:      * a boolean flag to minimize the amount of code in its inlined callers.
34288:      */
34288:     void checkMallocGCPressure(void *p);
    1: };
    1: 
37777: JS_ALWAYS_INLINE JSObject *
37777: JSStackFrame::varobj(js::CallStack *cs)
37777: {
37777:     JS_ASSERT(cs->contains(this));
37777:     return fun ? callobj : cs->getInitialVarObj();
37777: }
37777: 
37777: JS_ALWAYS_INLINE JSObject *
37777: JSStackFrame::varobj(JSContext *cx)
37777: {
37777:     JS_ASSERT(cx->activeCallStack()->contains(this));
37777:     return fun ? callobj : cx->activeCallStack()->getInitialVarObj();
37777: }
37777: 
    1: #ifdef JS_THREADSAFE
    1: # define JS_THREAD_ID(cx)       ((cx)->thread ? (cx)->thread->id : 0)
    1: #endif
    1: 
    1: #ifdef __cplusplus
24293: 
24293: static inline JSAtom **
24293: FrameAtomBase(JSContext *cx, JSStackFrame *fp)
24293: {
24293:     return fp->imacpc
24293:            ? COMMON_ATOMS_START(&cx->runtime->atomState)
24293:            : fp->script->atomMap.vector;
24293: }
24293: 
40221: namespace js {
40221: 
40221: class AutoGCRooter {
40221:   public:
40221:     AutoGCRooter(JSContext *cx, ptrdiff_t tag)
40221:       : down(cx->autoGCRooters), tag(tag), context(cx)
40221:     {
40221:         JS_ASSERT(this != cx->autoGCRooters);
40221:         cx->autoGCRooters = this;
40221:     }
40221: 
40221:     ~AutoGCRooter() {
40221:         JS_ASSERT(this == context->autoGCRooters);
40221:         context->autoGCRooters = down;
40221:     }
40221: 
40221:     inline void trace(JSTracer *trc);
40221: 
40221:     friend void ::js_TraceContext(JSTracer *trc, JSContext *acx);
40221: 
40221:   protected:
40221:     AutoGCRooter * const down;
40221: 
40221:     /*
40221:      * Discriminates actual subclass of this being used.  If non-negative, the
40221:      * subclass roots an array of jsvals of the length stored in this field.
40221:      * If negative, meaning is indicated by the corresponding value in the enum
40221:      * below.  Any other negative value indicates some deeper problem such as
40221:      * memory corruption.
40221:      */
40221:     ptrdiff_t tag;
40221: 
40221:     JSContext * const context;
40221: 
40221:     enum {
40221:         JSVAL =        -1, /* js::AutoValueRooter */
40223:         SPROP =        -2, /* js::AutoScopePropertyRooter */
40223:         WEAKROOTS =    -3, /* js::AutoSaveWeakRoots */
40221:         COMPILER =     -4, /* JSCompiler */
40223:         SCRIPT =       -5, /* js::AutoScriptRooter */
40223:         ENUMERATOR =   -6, /* js::AutoEnumStateRooter */
40223:         IDARRAY =      -7, /* js::AutoIdArray */
40223:         DESCRIPTORS =  -8, /* js::AutoDescriptorArray */
40223:         NAMESPACES =   -9, /* js::AutoNamespaces */
40223:         XML =         -10, /* js::AutoXMLRooter */
40223:         OBJECT =      -11, /* js::AutoObjectRooter */
40223:         ID =          -12  /* js::AutoIdRooter */
40221:     };
40221: };
40221: 
40221: class AutoSaveWeakRoots : private AutoGCRooter
    1: {
    1:   public:
40221:     explicit AutoSaveWeakRoots(JSContext *cx
33538:                                JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, WEAKROOTS), savedRoots(cx->weakRoots)
40221:     {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
34312:     }
    1: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
20444: 
    1:   private:
40221:     JSWeakRoots savedRoots;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
    1: };
19712: 
40221: /* FIXME(bug 332648): Move this into a public header. */
40221: class AutoValueRooter : private AutoGCRooter
25094: {
25094:   public:
40221:     explicit AutoValueRooter(JSContext *cx, jsval v = JSVAL_NULL
33538:                              JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, JSVAL), val(v)
40221:     {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:     }
40221:     AutoValueRooter(JSContext *cx, JSString *str
40221:                     JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, JSVAL), val(STRING_TO_JSVAL(str))
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:     }
40221:     AutoValueRooter(JSContext *cx, JSObject *obj
40221:                     JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, JSVAL), val(OBJECT_TO_JSVAL(obj))
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
25094:     }
25094: 
40221:     void setObject(JSObject *obj) {
40221:         JS_ASSERT(tag == JSVAL);
40221:         val = OBJECT_TO_JSVAL(obj);
25094:     }
25094: 
40221:     void setString(JSString *str) {
40221:         JS_ASSERT(tag == JSVAL);
40221:         JS_ASSERT(str);
40221:         val = STRING_TO_JSVAL(str);
40221:     }
40221: 
40221:     void setDouble(jsdouble *dp) {
40221:         JS_ASSERT(tag == JSVAL);
40221:         JS_ASSERT(dp);
40221:         val = DOUBLE_TO_JSVAL(dp);
40221:     }
40221: 
40221:     jsval value() const {
40221:         JS_ASSERT(tag == JSVAL);
40221:         return val;
40221:     }
40221: 
40221:     jsval *addr() {
40221:         JS_ASSERT(tag == JSVAL);
40221:         return &val;
40221:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
25094: 
25094:   private:
40221:     jsval val;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
25094: };
25094: 
40221: class AutoObjectRooter : private AutoGCRooter {
33155:   public:
40221:     AutoObjectRooter(JSContext *cx, JSObject *obj = NULL
33538:                      JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, OBJECT), obj(obj)
40221:     {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
33155:     }
40221: 
40221:     void setObject(JSObject *obj) {
40221:         this->obj = obj;
33155:     }
40221: 
40221:     JSObject * object() const {
40221:         return obj;
40221:     }
40221: 
40221:     JSObject ** addr() {
40221:         return &obj;
40221:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   private:
40221:     JSObject *obj;
40221:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
40221: };
40221: 
40221: class AutoArrayRooter : private AutoGCRooter {
40221:   public:
40221:     AutoArrayRooter(JSContext *cx, size_t len, jsval *vec
40221:                     JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, len), array(vec)
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:         JS_ASSERT(tag >= 0);
40221:     }
40221: 
40221:     void changeLength(size_t newLength) {
40221:         tag = ptrdiff_t(newLength);
40221:         JS_ASSERT(tag >= 0);
40221:     }
40221: 
40221:     void changeArray(jsval *newArray, size_t newLength) {
40221:         changeLength(newLength);
40221:         array = newArray;
40221:     }
40221: 
40221:     jsval *array;
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   private:
40221:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
40221: };
40221: 
40221: class AutoScopePropertyRooter : private AutoGCRooter {
40221:   public:
40221:     AutoScopePropertyRooter(JSContext *cx, JSScopeProperty *sprop
40221:                             JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, SPROP), sprop(sprop)
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   private:
40221:     JSScopeProperty * const sprop;
40221:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
40221: };
40221: 
40221: class AutoScriptRooter : private AutoGCRooter {
40221:   public:
40221:     AutoScriptRooter(JSContext *cx, JSScript *script
40221:                      JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, SCRIPT), script(script)
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:     }
40221: 
40221:     void setScript(JSScript *script) {
40221:         this->script = script;
40221:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   private:
40221:     JSScript *script;
40221:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
40221: };
40221: 
40221: class AutoIdRooter : private AutoGCRooter
40221: {
40221:   public:
40221:     explicit AutoIdRooter(JSContext *cx, jsid id = INT_TO_JSID(0)
40221:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, ID), idval(id)
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:     }
40221: 
40221:     jsid id() {
40221:         return idval;
40221:     }
40221: 
40221:     jsid * addr() {
40221:         return &idval;
40221:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   private:
40221:     jsid idval;
40221:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
40221: };
40221: 
40221: class AutoIdArray : private AutoGCRooter {
40221:   public:
40221:     AutoIdArray(JSContext *cx, JSIdArray *ida
40221:                   JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, ida ? ida->length : 0), idArray(ida)
40221:     {
40221:         JS_GUARD_OBJECT_NOTIFIER_INIT;
40221:     }
40221:     ~AutoIdArray() {
40221:         if (idArray)
40221:             JS_DestroyIdArray(context, idArray);
33155:     }
33155:     bool operator!() {
33155:         return idArray == NULL;
33155:     }
33155:     jsid operator[](size_t i) const {
33155:         JS_ASSERT(idArray);
33155:         JS_ASSERT(i < size_t(idArray->length));
33155:         return idArray->vector[i];
33155:     }
33155:     size_t length() const {
33155:          return idArray->length;
33155:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   protected:
40221:     inline void trace(JSTracer *trc);
40221: 
33155:   private:
33155:     JSIdArray * const idArray;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
39928: 
39928:     /* No copy or assignment semantics. */
40221:     AutoIdArray(AutoIdArray &ida);
40221:     void operator=(AutoIdArray &ida);
33155: };
33155: 
33128: /* The auto-root for enumeration object and its state. */
40221: class AutoEnumStateRooter : private AutoGCRooter
33128: {
33128:   public:
40221:     AutoEnumStateRooter(JSContext *cx, JSObject *obj
33538:                         JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : AutoGCRooter(cx, ENUMERATOR), obj(obj), stateValue(JSVAL_NULL)
33128:     {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
33128:         JS_ASSERT(obj);
33128:     }
33128: 
40221:     ~AutoEnumStateRooter() {
40221:         if (!JSVAL_IS_NULL(stateValue)) {
40221: #ifdef DEBUG
40221:             JSBool ok =
40221: #endif
40221:             obj->enumerate(context, JSENUMERATE_DESTROY, &stateValue, 0);
40221:             JS_ASSERT(ok);
40221:         }
33128:     }
33128: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:     jsval state() const { return stateValue; }
40221:     jsval * addr() { return &stateValue; }
40221: 
40221:   protected:
40221:     void trace(JSTracer *trc) {
40221:         JS_CALL_OBJECT_TRACER(trc, obj, "js::AutoEnumStateRooter.obj");
40221:         js_MarkEnumeratorState(trc, obj, stateValue);
33128:     }
33128: 
40221:     JSObject * const obj;
40221: 
33128:   private:
40221:     jsval stateValue;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
33128: };
33128: 
40221: #ifdef JS_HAS_XML_SUPPORT
40221: class AutoXMLRooter : private AutoGCRooter {
40221:   public:
40221:     AutoXMLRooter(JSContext *cx, JSXML *xml)
40221:       : AutoGCRooter(cx, XML), xml(xml)
40221:     {
40221:         JS_ASSERT(xml);
40221:     }
40221: 
40221:     friend void AutoGCRooter::trace(JSTracer *trc);
40221: 
40221:   private:
40221:     JSXML * const xml;
40221: };
40221: #endif /* JS_HAS_XML_SUPPORT */
40221: 
40221: }
40221: 
19712: class JSAutoResolveFlags
19712: {
19712:   public:
33538:     JSAutoResolveFlags(JSContext *cx, uintN flags
33538:                        JS_GUARD_OBJECT_NOTIFIER_PARAM)
40221:       : mContext(cx), mSaved(cx->resolveFlags)
40221:     {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
19712:         cx->resolveFlags = flags;
19712:     }
19712: 
19712:     ~JSAutoResolveFlags() { mContext->resolveFlags = mSaved; }
19712: 
19712:   private:
19712:     JSContext *mContext;
19712:     uintN mSaved;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
19712: };
24293: 
24293: #endif /* __cpluscplus */
    1: 
    1: /*
    1:  * Slightly more readable macros for testing per-context option settings (also
    1:  * to hide bitset implementation detail).
    1:  *
    1:  * JSOPTION_XML must be handled specially in order to propagate from compile-
    1:  * to run-time (from cx->options to script->version/cx->version).  To do that,
    1:  * we copy JSOPTION_XML from cx->options into cx->version as JSVERSION_HAS_XML
    1:  * whenever options are set, and preserve this XML flag across version number
    1:  * changes done via the JS_SetVersion API.
    1:  *
    1:  * But when executing a script or scripted function, the interpreter changes
    1:  * cx->version, including the XML flag, to script->version.  Thus JSOPTION_XML
    1:  * is a compile-time option that causes a run-time version change during each
    1:  * activation of the compiled script.  That version change has the effect of
    1:  * changing JS_HAS_XML_OPTION, so that any compiling done via eval enables XML
    1:  * support.  If an XML-enabled script or function calls a non-XML function,
    1:  * the flag bit will be cleared during the callee's activation.
    1:  *
    1:  * Note that JS_SetVersion API calls never pass JSVERSION_HAS_XML or'd into
    1:  * that API's version parameter.
    1:  *
    1:  * Note also that script->version must contain this XML option flag in order
    1:  * for XDR'ed scripts to serialize and deserialize with that option preserved
    1:  * for detection at run-time.  We can't copy other compile-time options into
    1:  * script->version because that would break backward compatibility (certain
    1:  * other options, e.g. JSOPTION_VAROBJFIX, are analogous to JSOPTION_XML).
    1:  */
    1: #define JS_HAS_OPTION(cx,option)        (((cx)->options & (option)) != 0)
    1: #define JS_HAS_STRICT_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_STRICT)
    1: #define JS_HAS_WERROR_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_WERROR)
    1: #define JS_HAS_COMPILE_N_GO_OPTION(cx)  JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)
    1: #define JS_HAS_ATLINE_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_ATLINE)
    1: 
    1: #define JSVERSION_MASK                  0x0FFF  /* see JSVersion in jspubtd.h */
    1: #define JSVERSION_HAS_XML               0x1000  /* flag induced by XML option */
24375: #define JSVERSION_ANONFUNFIX            0x2000  /* see jsapi.h, the comments
24375:                                                    for JSOPTION_ANONFUNFIX */
    1: 
 3164: #define JSVERSION_NUMBER(cx)            ((JSVersion)((cx)->version &          \
 3164:                                                      JSVERSION_MASK))
    1: #define JS_HAS_XML_OPTION(cx)           ((cx)->version & JSVERSION_HAS_XML || \
    1:                                          JSVERSION_NUMBER(cx) >= JSVERSION_1_6)
    1: 
34365: extern JSThreadData *
34365: js_CurrentThreadData(JSRuntime *rt);
34365: 
    1: extern JSBool
26569: js_InitThreads(JSRuntime *rt);
    1: 
26569: extern void
26569: js_FinishThreads(JSRuntime *rt);
26569: 
26569: extern void
26569: js_PurgeThreads(JSContext *cx);
22627: 
31843: extern void
31843: js_TraceThreads(JSRuntime *rt, JSTracer *trc);
31843: 
22627: /*
24874:  * Ensures the JSOPTION_XML and JSOPTION_ANONFUNFIX bits of cx->options are
24874:  * reflected in cx->version, since each bit must travel with a script that has
24874:  * it set.
24874:  */
24874: extern void
24874: js_SyncOptionsToVersion(JSContext *cx);
24874: 
24874: /*
    1:  * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
    1:  * data that depends on version.
    1:  */
    1: extern void
    1: js_OnVersionChange(JSContext *cx);
    1: 
    1: /*
    1:  * Unlike the JS_SetVersion API, this function stores JSVERSION_HAS_XML and
    1:  * any future non-version-number flags induced by compiler options.
    1:  */
    1: extern void
    1: js_SetVersion(JSContext *cx, JSVersion version);
    1: 
    1: /*
    1:  * Create and destroy functions for JSContext, which is manually allocated
    1:  * and exclusively owned.
    1:  */
    1: extern JSContext *
    1: js_NewContext(JSRuntime *rt, size_t stackChunkSize);
    1: 
    1: extern void
    1: js_DestroyContext(JSContext *cx, JSDestroyContextMode mode);
    1: 
    1: /*
    1:  * Return true if cx points to a context in rt->contextList, else return false.
11739:  * NB: the caller (see jslock.c:ClaimTitle) must hold rt->gcLock.
    1:  */
    1: extern JSBool
    1: js_ValidContextPointer(JSRuntime *rt, JSContext *cx);
    1: 
23092: static JS_INLINE JSContext *
23092: js_ContextFromLinkField(JSCList *link)
23092: {
23092:     JS_ASSERT(link);
23092:     return (JSContext *) ((uint8 *) link - offsetof(JSContext, link));
23092: }
23092: 
    1: /*
    1:  * If unlocked, acquire and release rt->gcLock around *iterp update; otherwise
    1:  * the caller must be holding rt->gcLock.
    1:  */
23442: extern JSContext *
    1: js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp);
    1: 
    1: /*
25087:  * Iterate through contexts with active requests. The caller must be holding
25087:  * rt->gcLock in case of a thread-safe build, or otherwise guarantee that the
25087:  * context list is not alternated asynchroniously.
25087:  */
25087: extern JS_FRIEND_API(JSContext *)
25087: js_NextActiveContext(JSRuntime *, JSContext *);
25087: 
27384: #ifdef JS_THREADSAFE
27384: 
27384: /*
27384:  * Count the number of contexts entered requests on the current thread.
27384:  */
37743: extern uint32
27384: js_CountThreadRequests(JSContext *cx);
27384: 
27384: /*
27384:  * This is a helper for code at can potentially run outside JS request to
27384:  * ensure that the GC is not running when the function returns.
27384:  *
27384:  * This function must be called with the GC lock held.
27384:  */
27384: extern void
27384: js_WaitForGC(JSRuntime *rt);
27384: 
27384: #else /* !JS_THREADSAFE */
27384: 
27384: # define js_WaitForGC(rt)    ((void) 0)
27384: 
27384: #endif
27384: 
25087: /*
    1:  * JSClass.resolve and watchpoint recursion damping machinery.
    1:  */
    1: extern JSBool
    1: js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                   JSResolvingEntry **entryp);
    1: 
    1: extern void
    1: js_StopResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                  JSResolvingEntry *entry, uint32 generation);
    1: 
    1: /*
    1:  * Local root set management.
    1:  *
    1:  * NB: the jsval parameters below may be properly tagged jsvals, or GC-thing
    1:  * pointers cast to (jsval).  This relies on JSObject's tag being zero, but
    1:  * on the up side it lets us push int-jsval-encoded scopeMark values on the
    1:  * local root stack.
    1:  */
    1: extern JSBool
    1: js_EnterLocalRootScope(JSContext *cx);
    1: 
    1: #define js_LeaveLocalRootScope(cx) \
    1:     js_LeaveLocalRootScopeWithResult(cx, JSVAL_NULL)
    1: 
    1: extern void
    1: js_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval);
    1: 
    1: extern void
    1: js_ForgetLocalRoot(JSContext *cx, jsval v);
    1: 
    1: extern int
    1: js_PushLocalRoot(JSContext *cx, JSLocalRootStack *lrs, jsval v);
    1: 
    1: /*
    1:  * Report an exception, which is currently realized as a printf-style format
    1:  * string and its arguments.
    1:  */
    1: typedef enum JSErrNum {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     name = number,
    1: #include "js.msg"
    1: #undef MSG_DEF
    1:     JSErr_Limit
    1: } JSErrNum;
    1: 
18543: extern JS_FRIEND_API(const JSErrorFormatString *)
    1: js_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
    1: 
    1: #ifdef va_start
    1: extern JSBool
    1: js_ReportErrorVA(JSContext *cx, uintN flags, const char *format, va_list ap);
    1: 
    1: extern JSBool
    1: js_ReportErrorNumberVA(JSContext *cx, uintN flags, JSErrorCallback callback,
    1:                        void *userRef, const uintN errorNumber,
    1:                        JSBool charArgs, va_list ap);
    1: 
    1: extern JSBool
    1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
    1:                         void *userRef, const uintN errorNumber,
    1:                         char **message, JSErrorReport *reportp,
35302:                         bool charArgs, va_list ap);
    1: #endif
    1: 
    1: extern void
    1: js_ReportOutOfMemory(JSContext *cx);
    1: 
    1: /*
 8296:  * Report that cx->scriptStackQuota is exhausted.
 8296:  */
 8296: extern void
 8296: js_ReportOutOfScriptQuota(JSContext *cx);
 8296: 
 8296: extern void
 8296: js_ReportOverRecursed(JSContext *cx);
 8296: 
12983: extern void
12983: js_ReportAllocationOverflow(JSContext *cx);
12983: 
11139: #define JS_CHECK_RECURSION(cx, onerror)                                       \
11139:     JS_BEGIN_MACRO                                                            \
11139:         int stackDummy_;                                                      \
11139:                                                                               \
11139:         if (!JS_CHECK_STACK_SIZE(cx, stackDummy_)) {                          \
11139:             js_ReportOverRecursed(cx);                                        \
11139:             onerror;                                                          \
11139:         }                                                                     \
11139:     JS_END_MACRO
11139: 
 8296: /*
    1:  * Report an exception using a previously composed JSErrorReport.
    1:  * XXXbe remove from "friend" API
    1:  */
    1: extern JS_FRIEND_API(void)
    1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *report);
    1: 
    1: extern void
    1: js_ReportIsNotDefined(JSContext *cx, const char *name);
    1: 
    1: /*
 7897:  * Report an attempt to access the property of a null or undefined value (v).
 7897:  */
 7897: extern JSBool
 7897: js_ReportIsNullOrUndefined(JSContext *cx, intN spindex, jsval v,
 7897:                            JSString *fallback);
 7897: 
16519: extern void
16519: js_ReportMissingArg(JSContext *cx, jsval *vp, uintN arg);
16519: 
 7897: /*
    1:  * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
    1:  * the first argument for the error message. If the error message has less
    1:  * then 3 arguments, use null for arg1 or arg2.
    1:  */
    1: extern JSBool
    1: js_ReportValueErrorFlags(JSContext *cx, uintN flags, const uintN errorNumber,
    1:                          intN spindex, jsval v, JSString *fallback,
    1:                          const char *arg1, const char *arg2);
    1: 
    1: #define js_ReportValueError(cx,errorNumber,spindex,v,fallback)                \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, NULL, NULL))
    1: 
    1: #define js_ReportValueError2(cx,errorNumber,spindex,v,fallback,arg1)          \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, NULL))
    1: 
    1: #define js_ReportValueError3(cx,errorNumber,spindex,v,fallback,arg1,arg2)     \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, arg2))
    1: 
    1: extern JSErrorFormatString js_ErrorFormatString[JSErr_Limit];
    1: 
    1: /*
    1:  * See JS_SetThreadStackLimit in jsapi.c, where we check that the stack grows
    1:  * in the expected direction.  On Unix-y systems, JS_STACK_GROWTH_DIRECTION is
    1:  * computed on the build host by jscpucfg.c and written into jsautocfg.h.  The
    1:  * macro is hardcoded in jscpucfg.h on Windows and Mac systems (for historical
    1:  * reasons pre-dating autoconf usage).
    1:  */
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) < (cx)->stackLimit)
    1: #else
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) > (cx)->stackLimit)
    1: #endif
    1: 
 9780: /*
25087:  * If the operation callback flag was set, call the operation callback.
 9780:  * This macro can run the full GC. Return true if it is OK to continue and
 9780:  * false otherwise.
 9780:  */
25087: #define JS_CHECK_OPERATION_LIMIT(cx) \
25087:     (!(cx)->operationCallbackFlag || js_InvokeOperationCallback(cx))
 9780: 
 9780: /*
25087:  * Invoke the operation callback and return false if the current execution
25087:  * is to be terminated.
    1:  */
    1: extern JSBool
25087: js_InvokeOperationCallback(JSContext *cx);
23726: 
27546: #ifndef JS_THREADSAFE
27546: # define js_TriggerAllOperationCallbacks(rt, gcLocked) \
27546:     js_TriggerAllOperationCallbacks (rt)
27546: #endif
27546: 
27546: void
27546: js_TriggerAllOperationCallbacks(JSRuntime *rt, JSBool gcLocked);
27546: 
25214: extern JSStackFrame *
25214: js_GetScriptedCaller(JSContext *cx, JSStackFrame *fp);
25214: 
26550: extern jsbytecode*
26550: js_GetCurrentBytecodePC(JSContext* cx);
26550: 
31911: extern bool
31911: js_CurrentPCIsInImacro(JSContext *cx);
31911: 
37741: namespace js {
37741: 
25214: #ifdef JS_TRACER
25214: /*
27882:  * Reconstruct the JS stack and clear cx->tracecx. We must be currently in a
27882:  * _FAIL builtin from trace on cx or another context on the same thread. The
27882:  * machine code for the trace remains on the C stack when js_DeepBail returns.
25214:  *
25214:  * Implemented in jstracer.cpp.
25214:  */
25214: JS_FORCES_STACK JS_FRIEND_API(void)
37741: DeepBail(JSContext *cx);
25214: #endif
25214: 
25214: static JS_FORCES_STACK JS_INLINE void
37741: LeaveTrace(JSContext *cx)
25214: {
25214: #ifdef JS_TRACER
25214:     if (JS_ON_TRACE(cx))
37741:         DeepBail(cx);
25214: #endif
25214: }
25214: 
27894: static JS_INLINE void
37741: LeaveTraceIfGlobalObject(JSContext *cx, JSObject *obj)
27894: {
27894:     if (!obj->fslots[JSSLOT_PARENT])
37741:         LeaveTrace(cx);
27894: }
27894: 
25214: static JS_INLINE JSBool
37741: CanLeaveTrace(JSContext *cx)
25214: {
25214:     JS_ASSERT(JS_ON_TRACE(cx));
25214: #ifdef JS_TRACER
25214:     return cx->bailExit != NULL;
25214: #else
25214:     return JS_FALSE;
25214: #endif
25214: }
25214: 
37741: }       /* namespace js */
37741: 
22652: /*
22652:  * Get the current cx->fp, first lazily instantiating stack frames if needed.
22652:  * (Do not access cx->fp directly except in JS_REQUIRES_STACK code.)
22652:  *
22652:  * Defined in jstracer.cpp if JS_TRACER is defined.
22652:  */
25214: static JS_FORCES_STACK JS_INLINE JSStackFrame *
25214: js_GetTopStackFrame(JSContext *cx)
25214: {
37741:     js::LeaveTrace(cx);
25214:     return cx->fp;
25214: }
22652: 
33121: static JS_INLINE JSBool
33121: js_IsPropertyCacheDisabled(JSContext *cx)
33121: {
33121:     return cx->runtime->shapeGen >= SHAPE_OVERFLOW_BIT;
33121: }
33121: 
27546: static JS_INLINE uint32
27546: js_RegenerateShapeForGC(JSContext *cx)
27546: {
27546:     JS_ASSERT(cx->runtime->gcRunning);
30733:     JS_ASSERT(cx->runtime->gcRegenShapes);
27546: 
27546:     /*
27546:      * Under the GC, compared with js_GenerateShape, we don't need to use
27546:      * atomic increments but we still must make sure that after an overflow
27546:      * the shape stays such.
27546:      */
27546:     uint32 shape = cx->runtime->shapeGen;
27546:     shape = (shape + 1) | (shape & SHAPE_OVERFLOW_BIT);
27546:     cx->runtime->shapeGen = shape;
27546:     return shape;
27546: }
27546: 
34299: namespace js {
34299: 
38568: inline void *
38568: ContextAllocPolicy::malloc(size_t bytes)
34299: {
38568:     return cx->malloc(bytes);
38568: }
34299: 
38568: inline void
38568: ContextAllocPolicy::free(void *p)
38568: {
38568:     cx->free(p);
38568: }
34299: 
38568: inline void *
38568: ContextAllocPolicy::realloc(void *p, size_t bytes)
38568: {
38568:     return cx->realloc(p, bytes);
38568: }
38568: 
38568: inline void
38568: ContextAllocPolicy::reportAllocOverflow() const
38568: {
38568:     js_ReportAllocationOverflow(cx);
38568: }
34299: 
34299: }
34299: 
39928: #ifdef _MSC_VER
39928: #pragma warning(pop)
39928: #pragma warning(pop)
39928: #endif
39928: 
    1: #endif /* jscntxt_h___ */
