43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@netscape.com> (original author)
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include <stdlib.h>
43113: #include "nsHttp.h"
43113: #include "nsHttpPipeline.h"
43113: #include "nsHttpHandler.h"
43113: #include "nsIOService.h"
43113: #include "nsIRequest.h"
43113: #include "nsISocketTransport.h"
43113: #include "nsIStringStream.h"
43113: #include "nsIPipe.h"
43113: #include "nsCOMPtr.h"
43113: #include "nsComponentManagerUtils.h"
43113: 
43113: #ifdef DEBUG
43113: #include "prthread.h"
43113: // defined by the socket transport service while active
43113: extern PRThread *gSocketThread;
43113: #endif
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpPushBackWriter
43113: //-----------------------------------------------------------------------------
43113: 
43113: class nsHttpPushBackWriter : public nsAHttpSegmentWriter
43113: {
43113: public:
43113:     nsHttpPushBackWriter(const char *buf, PRUint32 bufLen)
43113:         : mBuf(buf)
43113:         , mBufLen(bufLen)
43113:         { }
43113:     virtual ~nsHttpPushBackWriter() {}
43113: 
43113:     nsresult OnWriteSegment(char *buf, PRUint32 count, PRUint32 *countWritten)
43113:     {
43113:         if (mBufLen == 0)
43113:             return NS_BASE_STREAM_CLOSED;
43113: 
43113:         if (count > mBufLen)
43113:             count = mBufLen;
43113: 
43113:         memcpy(buf, mBuf, count);
43113: 
43113:         mBuf += count;
43113:         mBufLen -= count;
43113:         *countWritten = count;
43113:         return NS_OK;
43113:     }
43113: 
43113: private:
43113:     const char *mBuf;
43113:     PRUint32    mBufLen;
43113: };
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpPipeline <public>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpPipeline::nsHttpPipeline()
43113:     : mConnection(nsnull)
43113:     , mStatus(NS_OK)
80486:     , mRequestIsPartial(false)
80486:     , mResponseIsPartial(false)
80486:     , mClosed(false)
43113:     , mPushBackBuf(nsnull)
43113:     , mPushBackLen(0)
43113:     , mPushBackMax(0)
83069:     , mReceivingFromProgress(0)
83069:     , mSendingToProgress(0)
83069:     , mSuppressSendEvents(true)
43113: {
43113: }
43113: 
43113: nsHttpPipeline::~nsHttpPipeline()
43113: {
43113:     // make sure we aren't still holding onto any transactions!
43113:     Close(NS_ERROR_ABORT);
43113: 
43113:     if (mPushBackBuf)
43113:         free(mPushBackBuf);
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::AddTransaction(nsAHttpTransaction *trans)
43113: {
43113:     LOG(("nsHttpPipeline::AddTransaction [this=%x trans=%x]\n", this, trans));
43113: 
43113:     NS_ADDREF(trans);
43113:     mRequestQ.AppendElement(trans);
43113: 
43113:     if (mConnection) {
43113:         trans->SetConnection(this);
43113: 
43113:         if (mRequestQ.Length() == 1)
84396:             mConnection->ResumeSend();
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpPipeline::nsISupports
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMPL_THREADSAFE_ADDREF(nsHttpPipeline)
43113: NS_IMPL_THREADSAFE_RELEASE(nsHttpPipeline)
43113: 
43113: // multiple inheritance fun :-)
43113: NS_INTERFACE_MAP_BEGIN(nsHttpPipeline)
43113:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsAHttpConnection)
43113: NS_INTERFACE_MAP_END
43113: 
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpPipeline::nsAHttpConnection
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpPipeline::OnHeadersAvailable(nsAHttpTransaction *trans,
43113:                                    nsHttpRequestHead *requestHead,
43113:                                    nsHttpResponseHead *responseHead,
79445:                                    bool *reset)
43113: {
43113:     LOG(("nsHttpPipeline::OnHeadersAvailable [this=%x]\n", this));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     NS_ASSERTION(mConnection, "no connection");
43113: 
43113:     // trans has now received its response headers; forward to the real connection
43113:     return mConnection->OnHeadersAvailable(trans, requestHead, responseHead, reset);
43113: }
43113: 
43113: nsresult
84396: nsHttpPipeline::ResumeSend()
43113: {
82262:     if (mConnection)
84396:         return mConnection->ResumeSend();
43113:     return NS_ERROR_UNEXPECTED;
43113: }
43113: 
43113: nsresult
84396: nsHttpPipeline::ResumeRecv()
43113: {
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     NS_ASSERTION(mConnection, "no connection");
84396:     return mConnection->ResumeRecv();
43113: }
43113: 
43113: void
43113: nsHttpPipeline::CloseTransaction(nsAHttpTransaction *trans, nsresult reason)
43113: {
43113:     LOG(("nsHttpPipeline::CloseTransaction [this=%x trans=%x reason=%x]\n",
43113:         this, trans, reason));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     NS_ASSERTION(NS_FAILED(reason), "expecting failure code");
43113: 
43113:     // the specified transaction is to be closed with the given "reason"
43113:     
43113:     PRInt32 index;
79445:     bool killPipeline = false;
43113: 
43113:     index = mRequestQ.IndexOf(trans);
43113:     if (index >= 0) {
43113:         if (index == 0 && mRequestIsPartial) {
43113:             // the transaction is in the request queue.  check to see if any of
43113:             // its data has been written out yet.
80486:             killPipeline = true;
43113:         }
43113:         mRequestQ.RemoveElementAt(index);
43113:     }
43113:     else {
43113:         index = mResponseQ.IndexOf(trans);
43113:         if (index >= 0)
43113:             mResponseQ.RemoveElementAt(index);
43113:         // while we could avoid killing the pipeline if this transaction is the
43113:         // last transaction in the pipeline, there doesn't seem to be that much
43113:         // value in doing so.  most likely if this transaction is going away,
43113:         // the others will be shortly as well.
80486:         killPipeline = true;
43113:     }
43113: 
43113:     trans->Close(reason);
43113:     NS_RELEASE(trans);
43113: 
43113:     if (killPipeline) {
43113:         if (mConnection)
43113:             mConnection->CloseTransaction(this, reason);
43113:         else
43113:             Close(reason);
43113:     }
43113: }
43113: 
43113: void
43113: nsHttpPipeline::GetConnectionInfo(nsHttpConnectionInfo **result)
43113: {
43113:     NS_ASSERTION(mConnection, "no connection");
43113:     mConnection->GetConnectionInfo(result);
43113: }
43113: 
70090: nsresult
70090: nsHttpPipeline::TakeTransport(nsISocketTransport  **aTransport,
70090:                               nsIAsyncInputStream **aInputStream,
70090:                               nsIAsyncOutputStream **aOutputStream)
70090: {
70090:     return mConnection->TakeTransport(aTransport, aInputStream, aOutputStream);
70090: }
70090: 
43113: void
43113: nsHttpPipeline::GetSecurityInfo(nsISupports **result)
43113: {
43113:     NS_ASSERTION(mConnection, "no connection");
43113:     mConnection->GetSecurityInfo(result);
43113: }
43113: 
79445: bool
43113: nsHttpPipeline::IsPersistent()
43113: {
80486:     return true; // pipelining requires this
43113: }
43113: 
79445: bool
43113: nsHttpPipeline::IsReused()
43113: {
80486:     return true; // pipelining requires this
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::PushBack(const char *data, PRUint32 length)
43113: {
43113:     LOG(("nsHttpPipeline::PushBack [this=%x len=%u]\n", this, length));
43113:     
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     NS_ASSERTION(mPushBackLen == 0, "push back buffer already has data!");
43113: 
70090:     // If we have no chance for a pipeline (e.g. due to an Upgrade)
70090:     // then push this data down to original connection
70090:     if (!mConnection->IsPersistent())
70090:         return mConnection->PushBack(data, length);
70090: 
43113:     // PushBack is called recursively from WriteSegments
43113: 
43113:     // XXX we have a design decision to make here.  either we buffer the data
43113:     // and process it when we return to WriteSegments, or we attempt to move
43113:     // onto the next transaction from here.  doing so adds complexity with the
43113:     // benefit of eliminating the extra buffer copy.  the buffer is at most
43113:     // 4096 bytes, so it is really unclear if there is any value in the added
43113:     // complexity.  besides simplicity, buffering this data has the advantage
43113:     // that we'll call close on the transaction sooner, which will wake up
43113:     // the HTTP channel sooner to continue with its work.
43113: 
43113:     if (!mPushBackBuf) {
43113:         mPushBackMax = length;
43113:         mPushBackBuf = (char *) malloc(mPushBackMax);
43113:         if (!mPushBackBuf)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113:     else if (length > mPushBackMax) {
43113:         // grow push back buffer as necessary.
43113:         NS_ASSERTION(length <= nsIOService::gDefaultSegmentSize, "too big");
43113:         mPushBackMax = length;
43113:         mPushBackBuf = (char *) realloc(mPushBackBuf, mPushBackMax);
43113:         if (!mPushBackBuf)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113:  
43113:     memcpy(mPushBackBuf, data, length);
43113:     mPushBackLen = length;
43113: 
43113:     return NS_OK;
43113: }
43113: 
79445: bool
61543: nsHttpPipeline::LastTransactionExpectedNoContent()
61543: {
61543:     NS_ABORT_IF_FALSE(mConnection, "no connection");
61543:     return mConnection->LastTransactionExpectedNoContent();
61543: }
61543: 
61543: void
79445: nsHttpPipeline::SetLastTransactionExpectedNoContent(bool val)
61543: {
61543:     NS_ABORT_IF_FALSE(mConnection, "no connection");
61543:      mConnection->SetLastTransactionExpectedNoContent(val);
61543: }
61543: 
67712: nsHttpConnection *
67712: nsHttpPipeline::TakeHttpConnection()
67712: {
67712:     if (mConnection)
67712:         return mConnection->TakeHttpConnection();
67712:     return nsnull;
67712: }
67712: 
83069: nsISocketTransport *
83069: nsHttpPipeline::Transport()
83069: {
83069:     if (!mConnection)
83069:         return nsnull;
83069:     return mConnection->Transport();
83069: }
83069: 
67712: void
67712: nsHttpPipeline::SetSSLConnectFailed()
67712: {
67712:     nsAHttpTransaction *trans = Request(0);
67712: 
67712:     if (trans)
67712:         trans->SetSSLConnectFailed();
67712: }
67712: 
67712: nsHttpRequestHead *
67712: nsHttpPipeline::RequestHead()
67712: {
67712:     nsAHttpTransaction *trans = Request(0);
67712: 
67712:     if (trans)
67712:         return trans->RequestHead();
67712:     return nsnull;
67712: }
67712: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpPipeline::nsAHttpConnection
43113: //-----------------------------------------------------------------------------
43113: 
43113: void
43113: nsHttpPipeline::SetConnection(nsAHttpConnection *conn)
43113: {
43113:     LOG(("nsHttpPipeline::SetConnection [this=%x conn=%x]\n", this, conn));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     NS_ASSERTION(!mConnection, "already have a connection");
43113: 
43113:     NS_IF_ADDREF(mConnection = conn);
43113: 
43113:     PRInt32 i, count = mRequestQ.Length();
43113:     for (i=0; i<count; ++i)
43113:         Request(i)->SetConnection(this);
43113: }
43113: 
43113: void
64613: nsHttpPipeline::GetSecurityCallbacks(nsIInterfaceRequestor **result,
64613:                                      nsIEventTarget        **target)
43113: {
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     // return security callbacks from first request
43113:     nsAHttpTransaction *trans = Request(0);
43113:     if (trans)
64613:         trans->GetSecurityCallbacks(result, target);
64613:     else {
43113:         *result = nsnull;
64613:         if (target)
64613:             *target = nsnull;
64613:     }
43113: }
43113: 
43113: void
67756: nsHttpPipeline::OnTransportStatus(nsITransport* transport,
67756:                                   nsresult status, PRUint64 progress)
43113: {
43113:     LOG(("nsHttpPipeline::OnStatus [this=%x status=%x progress=%llu]\n",
43113:         this, status, progress));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     nsAHttpTransaction *trans;
83069:     PRInt32 i, count;
83069: 
43113:     switch (status) {
83069: 
83069:     case NS_NET_STATUS_RESOLVING_HOST:
83069:     case NS_NET_STATUS_RESOLVED_HOST:
83069:     case NS_NET_STATUS_CONNECTING_TO:
83069:     case NS_NET_STATUS_CONNECTED_TO:
83069:         // These should only appear at most once per pipeline.
83069:         // Deliver to the first transaction.
83069: 
83069:         trans = Request(0);
83069:         if (!trans)
43113:             trans = Response(0);
43113:         if (trans)
67756:             trans->OnTransportStatus(transport, status, progress);
83069: 
43113:         break;
83069: 
83069:     case NS_NET_STATUS_SENDING_TO:
83069:         // This is generated by the socket transport when (part) of
83069:         // a transaction is written out
83069:         //
83069:         // In pipelining this is generated out of FillSendBuf(), but it cannot do
83069:         // so until the connection is confirmed by CONNECTED_TO.
83069:         // See patch for bug 196827.
83069:         //
83069: 
83069:         if (mSuppressSendEvents) {
83069:             mSuppressSendEvents = false;
83069:             
83069:             // catch up by sending the event to all the transactions that have
83069:             // moved from request to response and any that have been partially
83069:             // sent. Also send WAITING_FOR to those that were completely sent
83069:             count = mResponseQ.Length();
83069:             for (i = 0; i < count; ++i) {
83069:                 Response(i)->OnTransportStatus(transport,
83069:                                                NS_NET_STATUS_SENDING_TO,
83069:                                                progress);
83069:                 Response(i)->OnTransportStatus(transport, 
83069:                                                NS_NET_STATUS_WAITING_FOR,
83069:                                                progress);
83069:             }
83069:             if (mRequestIsPartial && Request(0))
83069:                 Request(0)->OnTransportStatus(transport,
83069:                                               NS_NET_STATUS_SENDING_TO,
83069:                                               progress);
83069:             mSendingToProgress = progress;
83069:         }
83069:         // otherwise ignore it
83069:         break;
83069:         
83069:     case NS_NET_STATUS_WAITING_FOR: 
83069:         // Created by nsHttpConnection when request pipeline has been totally
83069:         // sent. Ignore it here because it is simulated in FillSendBuf() when
83069:         // a request is moved from request to response.
83069:         
83069:         // ignore it
83069:         break;
83069: 
83069:     case NS_NET_STATUS_RECEIVING_FROM:
83069:         // Forward this only to the transaction currently recieving data. It is
83069:         // normally generated by the socket transport, but can also
83069:         // be repeated by the pushbackwriter if necessary.
83069:         mReceivingFromProgress = progress;
83069:         if (Response(0))
83069:             Response(0)->OnTransportStatus(transport, status, progress);
83069:         break;
83069: 
43113:     default:
83069:         // forward other notifications to all request transactions
83069:         count = mRequestQ.Length();
83069:         for (i = 0; i < count; ++i)
83069:             Request(i)->OnTransportStatus(transport, status, progress);
43113:         break;
43113:     }
43113: }
43113: 
79445: bool
43113: nsHttpPipeline::IsDone()
43113: {
82265:     bool done = true;
82263:     
82263:     PRUint32 i, count = mRequestQ.Length();
82263:     for (i = 0; done && (i < count); i++)
82263:         done = Request(i)->IsDone();
82263: 
82263:     count = mResponseQ.Length();
82263:     for (i = 0; done && (i < count); i++)
82263:         done = Response(i)->IsDone();
82263:     
82263:     return done;
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::Status()
43113: {
43113:     return mStatus;
43113: }
43113: 
43113: PRUint32
43113: nsHttpPipeline::Available()
43113: {
43113:     PRUint32 result = 0;
43113: 
43113:     PRInt32 i, count = mRequestQ.Length();
43113:     for (i=0; i<count; ++i)
43113:         result += Request(i)->Available();
43113:     return result;
43113: }
43113: 
43113: NS_METHOD
43113: nsHttpPipeline::ReadFromPipe(nsIInputStream *stream,
43113:                              void *closure,
43113:                              const char *buf,
43113:                              PRUint32 offset,
43113:                              PRUint32 count,
43113:                              PRUint32 *countRead)
43113: {
43113:     nsHttpPipeline *self = (nsHttpPipeline *) closure;
43113:     return self->mReader->OnReadSegment(buf, count, countRead);
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::ReadSegments(nsAHttpSegmentReader *reader,
43113:                              PRUint32 count,
43113:                              PRUint32 *countRead)
43113: {
43113:     LOG(("nsHttpPipeline::ReadSegments [this=%x count=%u]\n", this, count));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     if (mClosed) {
43113:         *countRead = 0;
43113:         return mStatus;
43113:     }
43113: 
43113:     nsresult rv;
43113:     PRUint32 avail = 0;
43113:     if (mSendBufIn) {
43113:         rv = mSendBufIn->Available(&avail);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     if (avail == 0) {
43113:         rv = FillSendBuf();
43113:         if (NS_FAILED(rv)) return rv;
43113: 
43113:         rv = mSendBufIn->Available(&avail);
43113:         if (NS_FAILED(rv)) return rv;
43113: 
43113:         // return EOF if send buffer is empty
43113:         if (avail == 0) {
43113:             *countRead = 0;
43113:             return NS_OK;
43113:         }
43113:     }
43113: 
43113:     // read no more than what was requested
43113:     if (avail > count)
43113:         avail = count;
43113: 
43113:     mReader = reader;
43113: 
43113:     rv = mSendBufIn->ReadSegments(ReadFromPipe, this, avail, countRead);
43113: 
43113:     mReader = nsnull;
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::WriteSegments(nsAHttpSegmentWriter *writer,
43113:                               PRUint32 count,
43113:                               PRUint32 *countWritten)
43113: {
43113:     LOG(("nsHttpPipeline::WriteSegments [this=%x count=%u]\n", this, count));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     if (mClosed)
43113:         return NS_SUCCEEDED(mStatus) ? NS_BASE_STREAM_CLOSED : mStatus;
43113: 
43113:     nsAHttpTransaction *trans; 
43113:     nsresult rv;
43113: 
43113:     trans = Response(0);
43113:     if (!trans) {
43113:         if (mRequestQ.Length() > 0)
43113:             rv = NS_BASE_STREAM_WOULD_BLOCK;
43113:         else
43113:             rv = NS_BASE_STREAM_CLOSED;
43113:     }
43113:     else {
43113:         // 
43113:         // ask the transaction to consume data from the connection.
43113:         // PushBack may be called recursively.
43113:         //
43113:         rv = trans->WriteSegments(writer, count, countWritten);
43113: 
43113:         if (rv == NS_BASE_STREAM_CLOSED || trans->IsDone()) {
43113:             trans->Close(NS_OK);
43113:             NS_RELEASE(trans);
43113:             mResponseQ.RemoveElementAt(0);
80486:             mResponseIsPartial = false;
43113: 
43113:             // ask the connection manager to add additional transactions
43113:             // to our pipeline.
43113:             gHttpHandler->ConnMgr()->AddTransactionToPipeline(this);
43113:         }
43113:         else
80486:             mResponseIsPartial = true;
43113:     }
43113: 
43113:     if (mPushBackLen) {
43113:         nsHttpPushBackWriter writer(mPushBackBuf, mPushBackLen);
43113:         PRUint32 len = mPushBackLen, n;
43113:         mPushBackLen = 0;
83069: 
83069:         // This progress notification has previously been sent from
83069:         // the socket transport code, but it was delivered to the
83069:         // previous transaction on the pipeline.
83069:         nsITransport *transport = Transport();
83069:         if (transport)
83069:             OnTransportStatus(transport,
83069:                               nsISocketTransport::STATUS_RECEIVING_FROM,
83069:                               mReceivingFromProgress);
83069: 
43113:         // the push back buffer is never larger than NS_HTTP_SEGMENT_SIZE,
43113:         // so we are guaranteed that the next response will eat the entire
43113:         // push back buffer (even though it might again call PushBack).
43113:         rv = WriteSegments(&writer, len, &n);
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: void
43113: nsHttpPipeline::Close(nsresult reason)
43113: {
43113:     LOG(("nsHttpPipeline::Close [this=%x reason=%x]\n", this, reason));
43113: 
43113:     if (mClosed) {
43113:         LOG(("  already closed\n"));
43113:         return;
43113:     }
43113: 
43113:     // the connection is going away!
43113:     mStatus = reason;
80486:     mClosed = true;
43113: 
43113:     PRUint32 i, count;
43113:     nsAHttpTransaction *trans;
43113: 
43113:     // any pending requests can ignore this error and be restarted
43113:     count = mRequestQ.Length();
43113:     for (i=0; i<count; ++i) {
43113:         trans = Request(i);
43113:         trans->Close(NS_ERROR_NET_RESET);
43113:         NS_RELEASE(trans);
43113:     }
43113:     mRequestQ.Clear();
43113: 
43113:     trans = Response(0);
43113:     if (trans) {
43113:         // if the current response is partially complete, then it cannot be
43113:         // restarted and will have to fail with the status of the connection.
43113:         if (mResponseIsPartial)
43113:             trans->Close(reason);
43113:         else
43113:             trans->Close(NS_ERROR_NET_RESET);
43113:         NS_RELEASE(trans);
43113:         
43113:         // any remaining pending responses can be restarted
43113:         count = mResponseQ.Length();
43113:         for (i=1; i<count; ++i) {
43113:             trans = Response(i);
43113:             trans->Close(NS_ERROR_NET_RESET);
43113:             NS_RELEASE(trans);
43113:         }
43113:         mResponseQ.Clear();
43113:     }
58921: 
58922:     // we must no longer reference the connection!  This needs to come
58922:     // after we've closed all our transactions, since they might want
58922:     // connection info as they close.
58921:     NS_IF_RELEASE(mConnection);
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::OnReadSegment(const char *segment,
43113:                               PRUint32 count,
43113:                               PRUint32 *countRead)
43113: {
43113:     return mSendBufOut->Write(segment, count, countRead);
43113: }
43113: 
43113: nsresult
43113: nsHttpPipeline::FillSendBuf()
43113: {
43113:     // reads from request queue, moving transactions to response queue
43113:     // when they have been completely read.
43113: 
43113:     nsresult rv;
43113:     
43113:     if (!mSendBufIn) {
43113:         // allocate a single-segment pipe
43113:         rv = NS_NewPipe(getter_AddRefs(mSendBufIn),
43113:                         getter_AddRefs(mSendBufOut),
43113:                         nsIOService::gDefaultSegmentSize,  /* segment size */
43113:                         nsIOService::gDefaultSegmentSize,  /* max size */
80486:                         true, true,
43113:                         nsIOService::gBufferCache);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     PRUint32 n, avail;
43113:     nsAHttpTransaction *trans;
83069:     nsITransport *transport = Transport();
83069: 
43113:     while ((trans = Request(0)) != nsnull) {
43113:         avail = trans->Available();
43113:         if (avail) {
43113:             rv = trans->ReadSegments(this, avail, &n);
43113:             if (NS_FAILED(rv)) return rv;
43113:             
43113:             if (n == 0) {
43113:                 LOG(("send pipe is full"));
43113:                 break;
43113:             }
83069: 
83069:             mSendingToProgress += n;
83069:             if (!mSuppressSendEvents && transport) {
83069:                 // Simulate a SENDING_TO event
83069:                 trans->OnTransportStatus(transport,
83069:                                          NS_NET_STATUS_SENDING_TO,
83069:                                          mSendingToProgress);
43113:             }
83069:         }
83069: 
43113:         avail = trans->Available();
43113:         if (avail == 0) {
43113:             // move transaction from request queue to response queue
43113:             mRequestQ.RemoveElementAt(0);
43113:             mResponseQ.AppendElement(trans);
80486:             mRequestIsPartial = false;
83069: 
83069:             if (!mSuppressSendEvents && transport) {
83069:                 // Simulate a WAITING_FOR event
83069:                 trans->OnTransportStatus(transport,
83069:                                          NS_NET_STATUS_WAITING_FOR,
83069:                                          mSendingToProgress);
83069:             }
43113:         }
43113:         else
80486:             mRequestIsPartial = true;
43113:     }
43113:     return NS_OK;
43113: }
