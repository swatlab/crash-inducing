29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS symbol tables.
    1:  */
32777: #include <new>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h"
    1: #include "jsbit.h"
    1: #include "jsclist.h"
    1: #include "jsdhash.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
    1: #include "jsdbgapi.h"
40405: #include "jsfun.h"      /* for JS_ARGS_LENGTH_MAX */
    1: #include "jslock.h"
    1: #include "jsnum.h"
40405: #include "jsobj.h"
    1: #include "jsscope.h"
    1: #include "jsstr.h"
32777: #include "jstracer.h"
    1: 
34349: #include "jsscopeinlines.h"
34349: 
37741: using namespace js;
37741: 
30258: uint32
30258: js_GenerateShape(JSContext *cx, bool gcLocked)
30258: {
30258:     JSRuntime *rt;
30258:     uint32 shape;
30258: 
30258:     rt = cx->runtime;
30258:     shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
30258:     JS_ASSERT(shape != 0);
30258:     if (shape >= SHAPE_OVERFLOW_BIT) {
30258:         /*
30258:          * FIXME bug 440834: The shape id space has overflowed. Currently we
30258:          * cope badly with this and schedule the GC on the every call. But
30258:          * first we make sure that increments from other threads would not
30258:          * have a chance to wrap around shapeGen to zero.
30258:          */
30258:         rt->shapeGen = SHAPE_OVERFLOW_BIT;
32735:         shape = SHAPE_OVERFLOW_BIT;
30258:         js_TriggerGC(cx, gcLocked);
30258:     }
30258:     return shape;
30258: }
30258: 
    1: JSScope *
    1: js_GetMutableScope(JSContext *cx, JSObject *obj)
    1: {
    1:     JSScope *scope, *newscope;
13705:     JSClass *clasp;
13705:     uint32 freeslot;
    1: 
40847:     scope = obj->scope();
    1:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, scope));
37766:     if (!scope->isSharedEmpty())
    1:         return scope;
28093: 
28093:     /*
28093:      * Compile-time block objects each have their own scope, created at
28093:      * birth, and runtime clone of a block objects are never mutated.
28093:      */
40410:     JS_ASSERT(obj->getClass() != &js_BlockClass);
32777:     newscope = JSScope::create(cx, scope->ops, obj->getClass(), obj, scope->shape);
    1:     if (!newscope)
    1:         return NULL;
37766: 
37766:     /* The newly allocated scope is single-threaded and, as such, is locked. */
37766:     JS_ASSERT(CX_OWNS_SCOPE_TITLE(cx, newscope));
37766:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, newscope));
32777:     obj->map = newscope;
28353: 
40410:     JS_ASSERT(newscope->freeslot == JSSLOT_FREE(obj->getClass()));
40410:     clasp = obj->getClass();
13705:     if (clasp->reserveSlots) {
36435:         /*
40847:          * FIXME: Here we change obj->scope()->freeslot without changing
40847:          * obj->shape(). If we strengthen the shape guarantees to cover
36435:          * freeslot, we can eliminate a check in JSOP_SETPROP and in
36435:          * js_AddProperty. See bug 535416.
36435:          */
13705:         freeslot = JSSLOT_FREE(clasp) + clasp->reserveSlots(cx, obj);
40410:         if (freeslot > obj->numSlots())
40410:             freeslot = obj->numSlots();
28353:         if (newscope->freeslot < freeslot)
28353:             newscope->freeslot = freeslot;
13705:     }
37766:     JS_DROP_ALL_EMPTY_SCOPE_LOCKS(cx, scope);
37766:     static_cast<JSEmptyScope *>(scope)->drop(cx);
    1:     return newscope;
    1: }
    1: 
    1: /*
    1:  * JSScope uses multiplicative hashing, _a la_ jsdhash.[ch], but specialized
    1:  * to minimize footprint.  But if a scope has fewer than SCOPE_HASH_THRESHOLD
    1:  * entries, we use linear search and avoid allocating scope->table.
    1:  */
    1: #define SCOPE_HASH_THRESHOLD    6
    1: #define MIN_SCOPE_SIZE_LOG2     4
    1: #define MIN_SCOPE_SIZE          JS_BIT(MIN_SCOPE_SIZE_LOG2)
    1: #define SCOPE_TABLE_NBYTES(n)   ((n) * sizeof(JSScopeProperty *))
    1: 
30258: void
32652: JSScope::initMinimal(JSContext *cx, uint32 newShape)
    1: {
32652:     shape = newShape;
30645:     emptyScope = NULL;
30258:     hashShift = JS_DHASH_BITS - MIN_SCOPE_SIZE_LOG2;
30258:     entryCount = removedCount = 0;
30258:     table = NULL;
30258:     lastProp = NULL;
    1: }
    1: 
35453: #ifdef DEBUG
35453: JS_FRIEND_DATA(JSScopeStats) js_scope_stats = {0};
35453: 
35453: # define METER(x)       JS_ATOMIC_INCREMENT(&js_scope_stats.x)
35453: #else
35453: # define METER(x)       /* nothing */
35453: #endif
35453: 
30258: bool
30258: JSScope::createTable(JSContext *cx, bool report)
    1: {
    1:     int sizeLog2;
    1:     JSScopeProperty *sprop, **spp;
    1: 
30258:     JS_ASSERT(!table);
30258:     JS_ASSERT(lastProp);
    1: 
30258:     if (entryCount > SCOPE_HASH_THRESHOLD) {
    1:         /*
12307:          * Either we're creating a table for a large scope that was populated
12307:          * via property cache hit logic under JSOP_INITPROP, JSOP_SETNAME, or
12307:          * JSOP_SETPROP; or else calloc failed at least once already. In any
12307:          * event, let's try to grow, overallocating to hold at least twice the
12307:          * current population.
    1:          */
30258:         sizeLog2 = JS_CeilingLog2(2 * entryCount);
30258:         hashShift = JS_DHASH_BITS - sizeLog2;
    1:     } else {
30258:         JS_ASSERT(hashShift == JS_DHASH_BITS - MIN_SCOPE_SIZE_LOG2);
    1:         sizeLog2 = MIN_SCOPE_SIZE_LOG2;
    1:     }
    1: 
30851:     table = (JSScopeProperty **) js_calloc(JS_BIT(sizeLog2) * sizeof(JSScopeProperty *));
30258:     if (!table) {
    1:         if (report)
    1:             JS_ReportOutOfMemory(cx);
35453:         METER(tableAllocFails);
30258:         return false;
    1:     }
32553:     cx->updateMallocCounter(JS_BIT(sizeLog2) * sizeof(JSScopeProperty *));
    1: 
30258:     hashShift = JS_DHASH_BITS - sizeLog2;
30258:     for (sprop = lastProp; sprop; sprop = sprop->parent) {
30258:         spp = search(sprop->id, true);
    1:         SPROP_STORE_PRESERVING_COLLISION(spp, sprop);
    1:     }
30258:     return true;
    1: }
    1: 
    1: JSScope *
32777: JSScope::create(JSContext *cx, const JSObjectOps *ops, JSClass *clasp,
32777:                 JSObject *obj, uint32 shape)
    1: {
38504:     JS_ASSERT(ops->isNative());
28353:     JS_ASSERT(obj);
    1: 
32777:     JSScope *scope = cx->create<JSScope>(ops, obj);
    1:     if (!scope)
    1:         return NULL;
    1: 
28353:     scope->freeslot = JSSLOT_FREE(clasp);
30845:     scope->flags = cx->runtime->gcRegenShapesScopeFlag;
32652:     scope->initMinimal(cx, shape);
    1: 
    1: #ifdef JS_THREADSAFE
11739:     js_InitTitle(cx, &scope->title);
    1: #endif
    1:     JS_RUNTIME_METER(cx->runtime, liveScopes);
    1:     JS_RUNTIME_METER(cx->runtime, totalScopes);
    1:     return scope;
    1: }
    1: 
37766: JSEmptyScope::JSEmptyScope(JSContext *cx, const JSObjectOps *ops,
37766:                            JSClass *clasp)
37766:     : JSScope(ops, NULL), clasp(clasp)
30645: {
30645:     /*
30645:      * This scope holds a reference to the new empty scope. Our only caller,
30645:      * getEmptyScope, also promises to incref on behalf of its caller.
30645:      */
37766:     nrefs = 2;
37766:     freeslot = JSSLOT_FREE(clasp);
37766:     flags = OWN_SHAPE | cx->runtime->gcRegenShapesScopeFlag;
37766:     initMinimal(cx, js_GenerateShape(cx, false));
30645: 
30645: #ifdef JS_THREADSAFE
37766:     js_InitTitle(cx, &title);
30645: #endif
30645:     JS_RUNTIME_METER(cx->runtime, liveScopes);
30645:     JS_RUNTIME_METER(cx->runtime, totalScopes);
30645: }
30645: 
35453: #ifdef DEBUG
10217: # include "jsprf.h"
10217: # define LIVE_SCOPE_METER(cx,expr) JS_LOCK_RUNTIME_VOID(cx->runtime,expr)
10217: #else
10217: # define LIVE_SCOPE_METER(cx,expr) /* nothing */
10217: #endif
10217: 
    1: void
37766: JSScope::destroy(JSContext *cx)
    1: {
    1: #ifdef JS_THREADSAFE
37766:     js_FinishTitle(cx, &title);
    1: #endif
37766:     if (table)
37766:         cx->free(table);
    1: 
37766:     /*
37766:      * The scopes containing empty scopes are only destroyed from the GC
37766:      * thread.
37766:      */
37766:     if (emptyScope)
37766:         emptyScope->dropFromGC(cx);
37766: 
37766:     LIVE_SCOPE_METER(cx, cx->runtime->liveScopeProps -= entryCount);
    1:     JS_RUNTIME_UNMETER(cx->runtime, liveScopes);
37766:     cx->free(this);
37766: }
37766: 
37766: /* static */
37766: bool
37766: JSScope::initRuntimeState(JSContext *cx)
37766: {
40405:     JSRuntime *rt = cx->runtime;
40405: 
40405:     rt->emptyArgumentsScope = cx->create<JSEmptyScope>(cx, &js_ObjectOps, &js_ArgumentsClass);
40405:     if (!rt->emptyArgumentsScope)
40405:         return false;
40405:     JS_ASSERT(rt->emptyArgumentsScope->nrefs == 2);
40405:     rt->emptyArgumentsScope->nrefs = 1;
40405: 
40405:     /*
40405:      * NewArguments allocates dslots to have enough room for the argc of the
40405:      * particular arguments object being created.
40405:      *
40405:      * Thus we fake freeslot in the shared empty scope for the many unmutated
40405:      * arguments objects so that, until and unless a scope property is defined
40405:      * on a particular arguments object, it can share the runtime-wide empty
40405:      * scope with other arguments objects, whatever their initial argc values.
40405:      *
40405:      * This allows assertions that the arg slot being got or set by a fast path
40405:      * is less than freeslot to succeed. As the shared emptyArgumentsScope is
40405:      * never mutated, it's safe to pretend to have all the slots possible.
40405:      *
40405:      * Note how the fast paths in jsops.cpp for JSOP_LENGTH and JSOP_GETELEM
40405:      * bypass resolution of scope properties for length and element indices on
40405:      * arguments objects. This helps ensure that any arguments object needing
40405:      * its own mutable scope (with unique shape) is a rare event.
40405:      */
40405:     rt->emptyArgumentsScope->freeslot = JS_INITIAL_NSLOTS + JS_ARGS_LENGTH_MAX;
40405: 
40405:     rt->emptyBlockScope = cx->create<JSEmptyScope>(cx, &js_ObjectOps, &js_BlockClass);
40405:     if (!rt->emptyBlockScope) {
40405:         rt->emptyArgumentsScope->drop(cx);
40405:         rt->emptyArgumentsScope = NULL;
40405:         return false;
40405:     }
40405:     JS_ASSERT(rt->emptyBlockScope->nrefs == 2);
40405:     rt->emptyBlockScope->nrefs = 1;
40405:     return true;
37766: }
37766: 
37766: /* static */
37766: void
37766: JSScope::finishRuntimeState(JSContext *cx)
37766: {
37766:     JSRuntime *rt = cx->runtime;
40405:     if (rt->emptyArgumentsScope) {
40405:         rt->emptyArgumentsScope->drop(cx);
40405:         rt->emptyArgumentsScope = NULL;
40405:     }
37766:     if (rt->emptyBlockScope) {
37766:         rt->emptyBlockScope->drop(cx);
37766:         rt->emptyBlockScope = NULL;
37766:     }
    1: }
    1: 
 3328: JS_STATIC_ASSERT(sizeof(JSHashNumber) == 4);
 3328: JS_STATIC_ASSERT(sizeof(jsid) == JS_BYTES_PER_WORD);
 3328: 
 3328: #if JS_BYTES_PER_WORD == 4
 3328: # define HASH_ID(id) ((JSHashNumber)(id))
 3328: #elif JS_BYTES_PER_WORD == 8
 3328: # define HASH_ID(id) ((JSHashNumber)(id) ^ (JSHashNumber)((id) >> 32))
 3328: #else
 3328: # error "Unsupported configuration"
 3328: #endif
 3328: 
    1: /*
    1:  * Double hashing needs the second hash code to be relatively prime to table
    1:  * size, so we simply make hash2 odd.  The inputs to multiplicative hash are
 3328:  * the golden ratio, expressed as a fixed-point 32 bit fraction, and the id
 3328:  * itself.
    1:  */
    1: #define SCOPE_HASH0(id)                 (HASH_ID(id) * JS_GOLDEN_RATIO)
    1: #define SCOPE_HASH1(hash0,shift)        ((hash0) >> (shift))
    1: #define SCOPE_HASH2(hash0,log2,shift)   ((((hash0) << (log2)) >> (shift)) | 1)
    1: 
30258: JSScopeProperty **
30281: JSScope::searchTable(jsid id, bool adding)
    1: {
    1:     JSHashNumber hash0, hash1, hash2;
30258:     int sizeLog2;
    1:     JSScopeProperty *stored, *sprop, **spp, **firstRemoved;
    1:     uint32 sizeMask;
    1: 
30281:     JS_ASSERT(table);
33133:     JS_ASSERT(!JSVAL_IS_NULL(id));
    1: 
12307:     /* Compute the primary hash address. */
 3230:     METER(hashes);
    1:     hash0 = SCOPE_HASH0(id);
    1:     hash1 = SCOPE_HASH1(hash0, hashShift);
30258:     spp = table + hash1;
    1: 
    1:     /* Miss: return space for a new entry. */
    1:     stored = *spp;
    1:     if (SPROP_IS_FREE(stored)) {
    1:         METER(misses);
    1:         return spp;
    1:     }
    1: 
    1:     /* Hit: return entry. */
    1:     sprop = SPROP_CLEAR_COLLISION(stored);
    1:     if (sprop && sprop->id == id) {
    1:         METER(hits);
    1:         return spp;
    1:     }
    1: 
    1:     /* Collision: double hash. */
    1:     sizeLog2 = JS_DHASH_BITS - hashShift;
    1:     hash2 = SCOPE_HASH2(hash0, sizeLog2, hashShift);
    1:     sizeMask = JS_BITMASK(sizeLog2);
    1: 
35465: #ifdef DEBUG
35465:     jsuword collision_flag = SPROP_COLLISION;
35465: #endif
35465: 
    1:     /* Save the first removed entry pointer so we can recycle it if adding. */
    1:     if (SPROP_IS_REMOVED(stored)) {
    1:         firstRemoved = spp;
    1:     } else {
    1:         firstRemoved = NULL;
    1:         if (adding && !SPROP_HAD_COLLISION(stored))
    1:             SPROP_FLAG_COLLISION(spp, sprop);
35465: #ifdef DEBUG
35465:         collision_flag &= jsuword(*spp) & SPROP_COLLISION;
35465: #endif
    1:     }
    1: 
    1:     for (;;) {
    1:         METER(steps);
    1:         hash1 -= hash2;
    1:         hash1 &= sizeMask;
30258:         spp = table + hash1;
    1: 
    1:         stored = *spp;
    1:         if (SPROP_IS_FREE(stored)) {
    1:             METER(stepMisses);
    1:             return (adding && firstRemoved) ? firstRemoved : spp;
    1:         }
    1: 
    1:         sprop = SPROP_CLEAR_COLLISION(stored);
    1:         if (sprop && sprop->id == id) {
    1:             METER(stepHits);
35465:             JS_ASSERT(collision_flag);
    1:             return spp;
    1:         }
    1: 
    1:         if (SPROP_IS_REMOVED(stored)) {
    1:             if (!firstRemoved)
    1:                 firstRemoved = spp;
    1:         } else {
    1:             if (adding && !SPROP_HAD_COLLISION(stored))
    1:                 SPROP_FLAG_COLLISION(spp, sprop);
35465: #ifdef DEBUG
35465:             collision_flag &= jsuword(*spp) & SPROP_COLLISION;
35465: #endif
    1:         }
    1:     }
    1: 
    1:     /* NOTREACHED */
    1:     return NULL;
    1: }
    1: 
30258: bool
30258: JSScope::changeTable(JSContext *cx, int change)
    1: {
    1:     int oldlog2, newlog2;
    1:     uint32 oldsize, newsize, nbytes;
30258:     JSScopeProperty **newtable, **oldtable, **spp, **oldspp, *sprop;
    1: 
30258:     if (!table)
30258:         return createTable(cx, true);
12307: 
30258:     /* Grow, shrink, or compress by changing this->table. */
30258:     oldlog2 = JS_DHASH_BITS - hashShift;
    1:     newlog2 = oldlog2 + change;
    1:     oldsize = JS_BIT(oldlog2);
    1:     newsize = JS_BIT(newlog2);
    1:     nbytes = SCOPE_TABLE_NBYTES(newsize);
30851:     newtable = (JSScopeProperty **) cx->calloc(nbytes);
35453:     if (!newtable) {
35453:         METER(tableAllocFails);
30258:         return false;
35453:     }
    1: 
30258:     /* Now that we have newtable allocated, update members. */
30258:     hashShift = JS_DHASH_BITS - newlog2;
30258:     removedCount = 0;
30258:     oldtable = table;
30258:     table = newtable;
    1: 
32553:     /* Treat the above calloc as a JS_malloc, to match CreateScopeTable. */
34288:     cx->updateMallocCounter(nbytes);
32553: 
    1:     /* Copy only live entries, leaving removed and free ones behind. */
    1:     for (oldspp = oldtable; oldsize != 0; oldspp++) {
    1:         sprop = SPROP_FETCH(oldspp);
    1:         if (sprop) {
30258:             spp = search(sprop->id, true);
    1:             JS_ASSERT(SPROP_IS_FREE(*spp));
    1:             *spp = sprop;
    1:         }
    1:         oldsize--;
    1:     }
    1: 
    1:     /* Finally, free the old table storage. */
30851:     cx->free(oldtable);
30258:     return true;
    1: }
    1: 
35453: /*
35453:  * Get or create a property-tree or dictionary child property of parent, which
35453:  * must be lastProp if inDictionaryMode(), else parent must be one of lastProp
35453:  * or lastProp->parent.
35453:  */
35453: JSScopeProperty *
35453: JSScope::getChildProperty(JSContext *cx, JSScopeProperty *parent,
35453:                           JSScopeProperty &child)
35453: {
35453:     JS_ASSERT(!JSVAL_IS_NULL(child.id));
38562:     JS_ASSERT(!child.inDictionary());
35453: 
35453:     /*
35453:      * Aliases share another property's slot, passed in the |slot| parameter.
35453:      * Shared properties have no slot. Unshared properties that do not alias
35453:      * another property's slot allocate a slot here, but may lose it due to a
35453:      * JS_ClearScope call.
35453:      */
38562:     if (!child.isAlias()) {
35453:         if (child.attrs & JSPROP_SHARED) {
35453:             child.slot = SPROP_INVALID_SLOT;
35453:         } else {
35453:             /*
35453:              * We may have set slot from a nearly-matching sprop, above.
35453:              * If so, we're overwriting that nearly-matching sprop, so we
35453:              * can reuse its slot -- we don't need to allocate a new one.
35453:              * Similarly, we use a specific slot if provided by the caller.
35453:              */
35453:             if (child.slot == SPROP_INVALID_SLOT &&
35453:                 !js_AllocSlot(cx, object, &child.slot)) {
35453:                 return NULL;
35453:             }
35453:         }
35453:     }
35453: 
35453:     if (inDictionaryMode()) {
35453:         JS_ASSERT(parent == lastProp);
35453:         if (newDictionaryProperty(cx, child, &lastProp)) {
35453:             updateShape(cx);
35453:             return lastProp;
35453:         }
35453:         return NULL;
35453:     }
35453: 
40327:     JSScopeProperty *sprop = JS_PROPERTY_TREE(cx).getChild(cx, parent, shape, child);
35453:     if (sprop) {
35453:         JS_ASSERT(sprop->parent == parent);
35453:         if (parent == lastProp) {
35453:             extend(cx, sprop);
35453:         } else {
35453:             JS_ASSERT(parent == lastProp->parent);
35453:             setLastProperty(sprop);
35453:             updateShape(cx);
35453:         }
35453:     }
35453:     return sprop;
35453: }
35453: 
    1: #ifdef DEBUG_notbrendan
    1: #define CHECK_ANCESTOR_LINE(scope, sparse)                                    \
    1:     JS_BEGIN_MACRO                                                            \
35453:         if ((scope)->table) CheckAncestorLine(scope);                         \
    1:     JS_END_MACRO
    1: 
    1: static void
35453: CheckAncestorLine(JSScope *scope)
    1: {
    1:     uint32 size;
    1:     JSScopeProperty **spp, **start, **end, *ancestorLine, *sprop, *aprop;
    1:     uint32 entryCount, ancestorCount;
    1: 
35453:     ancestorLine = scope->lastProperty();
    1:     if (ancestorLine)
35453:         JS_ASSERT(scope->hasProperty(ancestorLine));
    1: 
    1:     entryCount = 0;
    1:     size = SCOPE_CAPACITY(scope);
    1:     start = scope->table;
    1:     for (spp = start, end = start + size; spp < end; spp++) {
    1:         sprop = SPROP_FETCH(spp);
    1:         if (sprop) {
35453:             ++entryCount;
    1:             for (aprop = ancestorLine; aprop; aprop = aprop->parent) {
    1:                 if (aprop == sprop)
    1:                     break;
    1:             }
    1:             JS_ASSERT(aprop);
    1:         }
    1:     }
    1:     JS_ASSERT(entryCount == scope->entryCount);
    1: 
    1:     ancestorCount = 0;
35453:     for (sprop = ancestorLine; sprop; sprop = sprop->parent)
    1:         ancestorCount++;
    1:     JS_ASSERT(ancestorCount == scope->entryCount);
    1: }
    1: #else
    1: #define CHECK_ANCESTOR_LINE(scope, sparse) /* nothing */
    1: #endif
    1: 
30258: void
30258: JSScope::reportReadOnlyScope(JSContext *cx)
    1: {
    1:     JSString *str;
    1:     const char *bytes;
    1: 
30258:     str = js_ValueToString(cx, OBJECT_TO_JSVAL(object));
    1:     if (!str)
    1:         return;
    1:     bytes = js_GetStringBytes(cx, str);
    1:     if (!bytes)
    1:         return;
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_READ_ONLY, bytes);
    1: }
    1: 
30733: void
30733: JSScope::generateOwnShape(JSContext *cx)
30258: {
33560: #ifdef JS_TRACER
33560:     if (object) {
37741:          LeaveTraceIfGlobalObject(cx, object);
30733: 
33560:         /*
33560:          * The JIT must have arranged to re-guard after any unpredictable shape
33560:          * change, so if we are on trace here, we should already be prepared to
33560:          * bail off trace.
33560:          */
33560:         JS_ASSERT_IF(JS_ON_TRACE(cx), cx->bailExit);
33560: 
33560:         /*
33560:          * If we are recording, here is where we forget already-guarded shapes.
33560:          * Any subsequent property operation upon object on the trace currently
33560:          * being recorded will re-guard (and re-memoize).
33560:          */
37741:         TraceMonitor *tm = &JS_TRACE_MONITOR(cx);
33560:         if (TraceRecorder *tr = tm->recorder)
33560:             tr->forgetGuardedShapesForObject(object);
33560:     }
33560: #endif
33560: 
30733:     shape = js_GenerateShape(cx, false);
30733:     setOwnShape();
30258: }
30258: 
    1: JSScopeProperty *
35453: JSScope::newDictionaryProperty(JSContext *cx, const JSScopeProperty &child,
35453:                                JSScopeProperty **childp)
35453: {
40327:     JSScopeProperty *dprop = JS_PROPERTY_TREE(cx).newScopeProperty(cx);
40327:     if (!dprop)
35453:         return NULL;
35453: 
39894:     new (dprop) JSScopeProperty(child.id, child.rawGetter, child.rawSetter, child.slot,
39894:                                 child.attrs, child.flags | JSScopeProperty::IN_DICTIONARY,
39894:                                 child.shortid);
35453:     dprop->shape = js_GenerateShape(cx, false);
35453: 
35453:     dprop->childp = NULL;
35453:     insertDictionaryProperty(dprop, childp);
37034:     updateFlags(dprop);
35453:     return dprop;
35453: }
35453: 
35453: bool
35453: JSScope::toDictionaryMode(JSContext *cx, JSScopeProperty *&aprop)
35453: {
35453:     JS_ASSERT(!inDictionaryMode());
35453: 
35453:     JSScopeProperty **oldTable = table;
35453:     uint32 saveRemovedCount = removedCount;
35453:     if (oldTable) {
35453:         int sizeLog2 = JS_DHASH_BITS - hashShift;
35453:         JSScopeProperty **newTable = (JSScopeProperty **)
35453:             js_calloc(JS_BIT(sizeLog2) * sizeof(JSScopeProperty *));
35453: 
35453:         if (!newTable) {
35453:             JS_ReportOutOfMemory(cx);
35453:             METER(toDictFails);
35453:             return false;
35453:         }
35453:         table = newTable;
35453:         removedCount = 0;
35453:     }
35453: 
35453:     /*
35453:      * We are committed from here on. If we fail due to OOM in the loop below,
35453:      * we'll restore saveEntryCount, oldTable, oldLastProp.
35453:      */
35453:     JSScopeProperty *oldLastProp = lastProp;
35453:     lastProp = NULL;
35453: 
35453:     /*
35453:      * Clear entryCount because JSScope::insertDictionaryProperty called from
35453:      * JSScope::newDictionaryProperty bumps it.
35453:      */
35453:     uint32 saveEntryCount = entryCount;
35453:     entryCount = 0;
35453: 
35453:     for (JSScopeProperty *sprop = oldLastProp, **childp = &lastProp; sprop; sprop = sprop->parent) {
35453:         JSScopeProperty *dprop = newDictionaryProperty(cx, *sprop, childp);
35453:         if (!dprop) {
35453:             entryCount = saveEntryCount;
35453:             removedCount = saveRemovedCount;
35453:             if (table)
35453:                 js_free(table);
35453:             table = oldTable;
35453:             lastProp = oldLastProp;
35453:             METER(toDictFails);
35453:             return false;
35453:         }
35453: 
35453:         if (table) {
35453:             JSScopeProperty **spp = search(dprop->id, true);
35453:             JS_ASSERT(!SPROP_FETCH(spp));
35453:             SPROP_STORE_PRESERVING_COLLISION(spp, dprop);
35453:         }
35453: 
35453:         if (aprop == sprop)
35453:             aprop = dprop;
35453:         childp = &dprop->parent;
35453:     }
35453: 
35453:     if (oldTable)
35453:         js_free(oldTable);
35453:     setDictionaryMode();
35453:     clearOwnShape();
35453: 
35453:     if (lastProp) {
35453:         /*
35453:          * This scope may get OWN_SHAPE set again, but for now its shape must
35453:          * be the shape of its lastProp. If it is empty, its initial shape is
35453:          * still valid. See JSScope::updateShape's definition in jsscope.h.
35453:          */
35453:         shape = lastProp->shape;
35453:     }
35453:     return true;
35453: }
35453: 
35453: JSScopeProperty *
35453: JSScope::addProperty(JSContext *cx, jsid id,
30258:                      JSPropertyOp getter, JSPropertyOp setter,
30258:                      uint32 slot, uintN attrs,
30258:                      uintN flags, intN shortid)
    1: {
30258:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, this));
30258:     CHECK_ANCESTOR_LINE(this, true);
    1: 
34360:     JS_ASSERT(!JSVAL_IS_NULL(id));
34360:     JS_ASSERT_IF(!cx->runtime->gcRegenShapes,
34360:                  hasRegenFlag(cx->runtime->gcRegenShapesScopeFlag));
33133: 
    1:     /*
    1:      * You can't add properties to a sealed scope. But note well that you can
    1:      * change property attributes in a sealed scope, even though that replaces
    1:      * a JSScopeProperty * in the scope's hash table -- but no id is added, so
    1:      * the scope remains sealed.
    1:      */
30258:     if (sealed()) {
30258:         reportReadOnlyScope(cx);
    1:         return NULL;
    1:     }
    1: 
35453:     /* Search for id with adding = true in order to claim its entry. */
35453:     JSScopeProperty **spp = search(id, true);
35453:     JS_ASSERT(!SPROP_FETCH(spp));
35453:     return addPropertyHelper(cx, id, getter, setter, slot, attrs, flags, shortid, spp);
35453: }
35453: 
    1: /*
35453:  * Normalize stub getter and setter values for faster is-stub testing in the
35453:  * SPROP_CALL_[GS]ETTER macros.
    1:  */
35453: static inline bool
41855: NormalizeGetterAndSetter(JSContext *cx, JSScope *scope,
35453:                          jsid id, uintN attrs, uintN flags,
35453:                          JSPropertyOp &getter,
35453:                          JSPropertyOp &setter)
35453: {
41860:     if (setter == JS_PropertyStub) {
41860:         JS_ASSERT(!(attrs & JSPROP_SETTER));
32658:         setter = NULL;
41860:     }
38562:     if (flags & JSScopeProperty::METHOD) {
32658:         /* Here, getter is the method, a function object reference. */
32658:         JS_ASSERT(getter);
32658:         JS_ASSERT(!setter || setter == js_watch_set);
32658:         JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658:     } else {
41860:         if (getter == JS_PropertyStub) {
41860:             JS_ASSERT(!(attrs & JSPROP_GETTER));
32568:             getter = NULL;
32658:         }
41860:     }
    1: 
    1:     /*
35453:      * Check for a watchpoint on a deleted property; if one exists, change
35453:      * setter to js_watch_set or js_watch_set_wrapper.
35453:      * XXXbe this could get expensive with lots of watchpoints...
    1:      */
35453:     if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList) &&
35453:         js_FindWatchPoint(cx->runtime, scope, id)) {
35453:         setter = js_WrapWatchedSetter(cx, id, attrs, setter);
35453:         if (!setter) {
35453:             METER(wrapWatchFails);
35453:             return false;
35453:         }
35453:     }
35453:     return true;
35453: }
35453: 
35453: JSScopeProperty *
35453: JSScope::addPropertyHelper(JSContext *cx, jsid id,
35453:                            JSPropertyOp getter, JSPropertyOp setter,
35453:                            uint32 slot, uintN attrs,
35453:                            uintN flags, intN shortid,
35453:                            JSScopeProperty **spp)
35453: {
35453:     NormalizeGetterAndSetter(cx, this, id, attrs, flags, getter, setter);
35453: 
35390:     /* Check whether we need to grow, if the load factor is >= .75. */
35453:     uint32 size = SCOPE_CAPACITY(this);
35390:     if (entryCount + removedCount >= size - (size >> 2)) {
35453:         int change = removedCount < size >> 2;
35453:         if (!change)
35390:             METER(compresses);
35453:         else
35390:             METER(grows);
35453:         if (!changeTable(cx, change) && entryCount + removedCount == size - 1)
35390:             return NULL;
30258:         spp = search(id, true);
    1:         JS_ASSERT(!SPROP_FETCH(spp));
    1:     }
35453: 
35453:     /* Find or create a property tree node labeled by our arguments. */
35453:     JSScopeProperty *sprop;
35453:     {
39894:         JSScopeProperty child(id, getter, setter, slot, attrs, flags, shortid);
35453:         sprop = getChildProperty(cx, lastProp, child);
35453:     }
35453: 
35453:     if (sprop) {
35453:         /* Store the tree node pointer in the table entry for id. */
35453:         if (table)
35453:             SPROP_STORE_PRESERVING_COLLISION(spp, sprop);
35453:         CHECK_ANCESTOR_LINE(this, false);
35453: #ifdef DEBUG
35453:         LIVE_SCOPE_METER(cx, ++cx->runtime->liveScopeProps);
35453:         JS_RUNTIME_METER(cx->runtime, totalScopeProps);
35453: #endif
35453: 
35453:         /*
35453:          * If we reach the hashing threshold, try to allocate this->table.
35453:          * If we can't (a rare event, preceded by swapping to death on most
35453:          * modern OSes), stick with linear search rather than whining about
35453:          * this little set-back.  Therefore we must test !this->table and
35453:          * this->entryCount >= SCOPE_HASH_THRESHOLD, not merely whether the
35453:          * entry count just reached the threshold.
35453:          */
35453:         if (!table && entryCount >= SCOPE_HASH_THRESHOLD)
35453:             (void) createTable(cx, false);
35453: 
35453:         METER(adds);
35453:         return sprop;
35453:     }
35453: 
35453:     METER(addFails);
35453:     return NULL;
35453: }
35453: 
35453: JSScopeProperty *
35453: JSScope::putProperty(JSContext *cx, jsid id,
35453:                      JSPropertyOp getter, JSPropertyOp setter,
35453:                      uint32 slot, uintN attrs,
35453:                      uintN flags, intN shortid)
35453: {
35453:     JSScopeProperty **spp, *sprop, *overwriting;
35453: 
35453:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, this));
35453:     CHECK_ANCESTOR_LINE(this, true);
35453: 
35453:     JS_ASSERT(!JSVAL_IS_NULL(id));
35453: 
35453:     JS_ASSERT_IF(!cx->runtime->gcRegenShapes,
35453:                  hasRegenFlag(cx->runtime->gcRegenShapesScopeFlag));
35453: 
35453:     if (sealed()) {
35453:         reportReadOnlyScope(cx);
35453:         return NULL;
35453:     }
35453: 
35453:     /* Search for id in order to claim its entry if table has been allocated. */
35453:     spp = search(id, true);
35453:     sprop = SPROP_FETCH(spp);
35453:     if (!sprop)
35453:         return addPropertyHelper(cx, id, getter, setter, slot, attrs, flags, shortid, spp);
35453: 
30258:     /* Property exists: JSScope::search must have returned a valid *spp. */
    1:     JS_ASSERT(!SPROP_IS_REMOVED(*spp));
35453:     overwriting = sprop;
35453: 
35453:     NormalizeGetterAndSetter(cx, this, id, attrs, flags, getter, setter);
    1: 
    1:     /*
    1:      * If all property members match, this is a redundant add and we can
    1:      * return early.  If the caller wants to allocate a slot, but doesn't
    1:      * care which slot, copy sprop->slot into slot so we can match sprop,
    1:      * if all other members match.
    1:      */
    1:     if (!(attrs & JSPROP_SHARED) &&
    1:         slot == SPROP_INVALID_SLOT &&
30258:         SPROP_HAS_VALID_SLOT(sprop, this)) {
    1:         slot = sprop->slot;
    1:     }
38562:     if (sprop->matchesParamsAfterId(getter, setter, slot, attrs, flags, shortid)) {
35453:         METER(redundantPuts);
    1:         return sprop;
    1:     }
    1: 
    1:     /*
26755:      * If we are clearing sprop to force the existing property that it
26755:      * describes to be overwritten, then we have to unlink sprop from the
35453:      * ancestor line at this->lastProp.
    1:      *
35453:      * If sprop is not lastProp and this scope is not in dictionary mode,
35453:      * we must switch to dictionary mode so we can unlink the non-terminal
35453:      * sprop without breaking anyone sharing the property lineage via the
35453:      * runtime's property tree.
    1:      */
35453:     if (sprop == lastProp && !inDictionaryMode()) {
35453:         removeLastProperty();
35453:     } else {
35453:         if (!inDictionaryMode()) {
35453:             if (!toDictionaryMode(cx, sprop))
    1:                 return NULL;
35453:             spp = search(id, false);
    1:         }
35453:         removeDictionaryProperty(sprop);
    1:     }
    1: 
    1:     /*
    1:      * If we fail later on trying to find or create a new sprop, we will
35453:      * restore *spp from |overwriting|. Note that we don't bother to keep
35453:      * this->removedCount in sync, because we will fix up both *spp and
35453:      * this->entryCount shortly.
    1:      */
30258:     if (table)
    1:         SPROP_STORE_PRESERVING_COLLISION(spp, NULL);
30258:     CHECK_ANCESTOR_LINE(this, true);
    1: 
35453:     {
    1:         /* Find or create a property tree node labeled by our arguments. */
39894:         JSScopeProperty child(id, getter, setter, slot, attrs, flags, shortid);
35453:         sprop = getChildProperty(cx, lastProp, child);
35453:     }
    1: 
35453:     if (sprop) {
30258:         CHECK_ANCESTOR_LINE(this, false);
    1: 
35465:         if (table) {
35465:             /* Store the tree node pointer in the table entry for id. */
35465:             SPROP_STORE_PRESERVING_COLLISION(spp, sprop);
35465:         } else if (entryCount >= SCOPE_HASH_THRESHOLD) {
35453:             /* See comment in JSScope::addPropertyHelper about ignoring OOM here. */
30258:             (void) createTable(cx, false);
35465:         }
35453: 
35453:         METER(puts);
35453:         return sprop;
    1:     }
    1: 
30258:     if (table)
    1:         SPROP_STORE_PRESERVING_COLLISION(spp, overwriting);
35453:     ++entryCount;
30258:     CHECK_ANCESTOR_LINE(this, true);
35453:     METER(putFails);
    1:     return NULL;
    1: }
    1: 
    1: JSScopeProperty *
35453: JSScope::changeProperty(JSContext *cx, JSScopeProperty *sprop,
30258:                         uintN attrs, uintN mask,
    1:                         JSPropertyOp getter, JSPropertyOp setter)
    1: {
39894:     JSScopeProperty *newsprop;
    1: 
35453:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, this));
30258:     CHECK_ANCESTOR_LINE(this, true);
    1: 
33133:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
35453:     JS_ASSERT(hasProperty(sprop));
35453: 
35453:     attrs |= sprop->attrs & mask;
33133: 
    1:     /* Allow only shared (slot-less) => unshared (slot-full) transition. */
    1:     JS_ASSERT(!((attrs ^ sprop->attrs) & JSPROP_SHARED) ||
    1:               !(attrs & JSPROP_SHARED));
35453: 
38631:     /* Don't allow method properties to be changed to have a getter. */
39894:     JS_ASSERT_IF(getter != sprop->rawGetter, !sprop->isMethod());
35453: 
    1:     if (getter == JS_PropertyStub)
    1:         getter = NULL;
    1:     if (setter == JS_PropertyStub)
    1:         setter = NULL;
39894:     if (sprop->attrs == attrs && sprop->getter() == getter && sprop->setter() == setter)
    1:         return sprop;
    1: 
39894:     JSScopeProperty child(sprop->id, getter, setter, sprop->slot, attrs, sprop->flags,
39894:                           sprop->shortid);
35453:     if (inDictionaryMode()) {
35453:         removeDictionaryProperty(sprop);
35453:         newsprop = newDictionaryProperty(cx, child, &lastProp);
35453:         if (newsprop) {
35453:             if (table) {
35453:                 JSScopeProperty **spp = search(sprop->id, false);
35453:                 SPROP_STORE_PRESERVING_COLLISION(spp, newsprop);
35390:             }
35453:             updateShape(cx);
35453:         }
35453:     } else if (sprop == lastProp) {
35453:         newsprop = getChildProperty(cx, sprop->parent, child);
35334:         if (newsprop) {
35453:             if (table) {
35453:                 JSScopeProperty **spp = search(sprop->id, false);
35390:                 JS_ASSERT(SPROP_FETCH(spp) == sprop);
35334:                 SPROP_STORE_PRESERVING_COLLISION(spp, newsprop);
35453:             }
30258:             CHECK_ANCESTOR_LINE(this, true);
    1:         }
    1:     } else {
    1:         /*
35453:          * Let JSScope::putProperty handle this |overwriting| case, including
35453:          * the conservation of sprop->slot (if it's valid). We must not call
35465:          * JSScope::removeProperty because it will free a valid sprop->slot and
35453:          * JSScope::putProperty won't re-allocate it.
    1:          */
39894:         newsprop = putProperty(cx, child.id, child.rawGetter, child.rawSetter, child.slot,
27490:                                child.attrs, child.flags, child.shortid);
    1:     }
    1: 
35453: #ifdef DEBUG
35453:     if (newsprop)
35453:         METER(changes);
11377:     else
35453:         METER(changeFails);
    1: #endif
    1:     return newsprop;
    1: }
    1: 
30258: bool
35453: JSScope::removeProperty(JSContext *cx, jsid id)
    1: {
35465:     JSScopeProperty **spp, *sprop;
    1:     uint32 size;
    1: 
30258:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, this));
30258:     CHECK_ANCESTOR_LINE(this, true);
30258:     if (sealed()) {
30258:         reportReadOnlyScope(cx);
30258:         return false;
    1:     }
    1: 
30258:     spp = search(id, false);
35465:     sprop = SPROP_CLEAR_COLLISION(*spp);
    1:     if (!sprop) {
    1:         METER(uselessRemoves);
30258:         return true;
    1:     }
    1: 
35453:     /* If sprop is not the last property added, switch to dictionary mode. */
35453:     if (sprop != lastProp) {
35453:         if (!inDictionaryMode()) {
35453:             if (!toDictionaryMode(cx, sprop))
30258:                 return false;
30258:             spp = search(id, false);
35453:         }
35453:         JS_ASSERT(SPROP_FETCH(spp) == sprop);
    1:     }
    1: 
    1:     /* First, if sprop is unshared and not cleared, free its slot number. */
30258:     if (SPROP_HAS_VALID_SLOT(sprop, this)) {
30258:         js_FreeSlot(cx, object, sprop->slot);
    1:         JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
    1:     }
    1: 
    1:     /* Next, remove id by setting its entry to a removed or free sentinel. */
35465:     if (SPROP_HAD_COLLISION(*spp)) {
30258:         JS_ASSERT(table);
    1:         *spp = SPROP_REMOVED;
35453:         ++removedCount;
    1:     } else {
    1:         METER(removeFrees);
35465:         if (table) {
    1:             *spp = NULL;
35465: #ifdef DEBUG
36404:             /*
36404:              * Check the consistency of the table but limit the number of
36404:              * checks not to alter significantly the complexity of the delete
36404:              * in debug builds, see bug 534493.
36404:              */
36404:             JSScopeProperty *aprop = lastProp;
36404:             for (unsigned n = 50; aprop && n != 0; aprop = aprop->parent, --n)
35465:                 JS_ASSERT_IF(aprop != sprop, hasProperty(aprop));
35465: #endif
35465:         }
    1:     }
10217:     LIVE_SCOPE_METER(cx, --cx->runtime->liveScopeProps);
    1: 
35453:     if (inDictionaryMode()) {
35453:         /*
35453:          * Remove sprop from its scope-owned doubly linked list, setting this
35453:          * scope's OWN_SHAPE flag first if sprop is lastProp so updateShape(cx)
35453:          * after this if-else will generate a fresh shape for this scope.
35453:          */
35453:         if (sprop != lastProp)
35453:             setOwnShape();
35453:         removeDictionaryProperty(sprop);
35453:     } else {
35453:         JS_ASSERT(sprop == lastProp);
35453:         removeLastProperty();
    1:     }
35453:     updateShape(cx);
30258:     CHECK_ANCESTOR_LINE(this, true);
    1: 
30258:     /* Last, consider shrinking this->table if its load factor is <= .25. */
30258:     size = SCOPE_CAPACITY(this);
30258:     if (size > MIN_SCOPE_SIZE && entryCount <= size >> 2) {
    1:         METER(shrinks);
30258:         (void) changeTable(cx, -1);
    1:     }
    1: 
35453:     METER(removes);
30258:     return true;
    1: }
    1: 
    1: void
30258: JSScope::clear(JSContext *cx)
    1: {
30258:     CHECK_ANCESTOR_LINE(this, true);
30258:     LIVE_SCOPE_METER(cx, cx->runtime->liveScopeProps -= entryCount);
    1: 
30258:     if (table)
30851:         js_free(table);
35453:     clearDictionaryMode();
35453:     clearOwnShape();
37741:     LeaveTraceIfGlobalObject(cx, object);
32652: 
32652:     JSClass *clasp = object->getClass();
32652:     JSObject *proto = object->getProto();
35117:     JSEmptyScope *emptyScope;
35117:     uint32 newShape;
35117:     if (proto &&
40430:         proto->isNative() &&
40847:         (emptyScope = proto->scope()->emptyScope) &&
35117:         emptyScope->clasp == clasp) {
35117:         newShape = emptyScope->shape;
32652:     } else {
32652:         newShape = js_GenerateShape(cx, false);
32652:     }
32652:     initMinimal(cx, newShape);
32652: 
    1:     JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
    1: }
    1: 
    1: void
30258: JSScope::deletingShapeChange(JSContext *cx, JSScopeProperty *sprop)
30258: {
33133:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
30733:     generateOwnShape(cx);
30258: }
30258: 
32658: bool
41851: JSScope::methodShapeChange(JSContext *cx, JSScopeProperty *sprop)
32658: {
33133:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
32658:     if (sprop->isMethod()) {
32658: #ifdef DEBUG
40847:         jsval prev = object->lockedGetSlot(sprop->slot);
32658:         JS_ASSERT(sprop->methodValue() == prev);
32658:         JS_ASSERT(hasMethodBarrier());
32658:         JS_ASSERT(object->getClass() == &js_ObjectClass);
39894:         JS_ASSERT(!sprop->rawSetter || sprop->rawSetter == js_watch_set);
32658: #endif
32658: 
32658:         /*
32658:          * Pass null to make a stub getter, but pass along sprop->setter to
38562:          * preserve watchpoints. Clear JSScopeProperty::METHOD from flags as we
38562:          * are despecializing from a method memoized in the property tree to a
32658:          * plain old function-valued property.
32658:          */
39894:         sprop = putProperty(cx, sprop->id, NULL, sprop->rawSetter, sprop->slot,
38562:                             sprop->attrs,
38562:                             sprop->getFlags() & ~JSScopeProperty::METHOD,
32658:                             sprop->shortid);
32658:         if (!sprop)
32658:             return false;
32658:     }
32658: 
32658:     generateOwnShape(cx);
32658:     return true;
32658: }
32658: 
32658: bool
41851: JSScope::methodShapeChange(JSContext *cx, uint32 slot)
30258: {
32658:     if (!hasMethodBarrier()) {
30733:         generateOwnShape(cx);
32658:     } else {
32658:         for (JSScopeProperty *sprop = lastProp; sprop; sprop = sprop->parent) {
33133:             JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
35453:             if (sprop->slot == slot)
41851:                 return methodShapeChange(cx, sprop);
32658:         }
32658:     }
32658:     return true;
30258: }
30258: 
30258: void
30258: JSScope::protoShapeChange(JSContext *cx)
30258: {
30733:     generateOwnShape(cx);
30258: }
30258: 
30258: void
30258: JSScope::shadowingShapeChange(JSContext *cx, JSScopeProperty *sprop)
30258: {
33133:     JS_ASSERT(!JSVAL_IS_NULL(sprop->id));
30733:     generateOwnShape(cx);
30258: }
30258: 
40871: bool
40871: JSScope::globalObjectOwnShapeChange(JSContext *cx)
40871: {
40871:     generateOwnShape(cx);
40871:     return !js_IsPropertyCacheDisabled(cx);
40871: }
40871: 
30258: void
  583: js_TraceId(JSTracer *trc, jsid id)
    1: {
 4529:     jsval v;
  583: 
 4529:     v = ID_TO_VALUE(id);
 4529:     JS_CALL_VALUE_TRACER(trc, v, "id");
  583: }
    1: 
  583: #ifdef DEBUG
  583: static void
  583: PrintPropertyGetterOrSetter(JSTracer *trc, char *buf, size_t bufsize)
  583: {
  583:     JSScopeProperty *sprop;
 4529:     jsid id;
  583:     size_t n;
  583:     const char *name;
  583: 
  583:     JS_ASSERT(trc->debugPrinter == PrintPropertyGetterOrSetter);
  583:     sprop = (JSScopeProperty *)trc->debugPrintArg;
 4529:     id = sprop->id;
33133:     JS_ASSERT(!JSVAL_IS_NULL(id));
  583:     name = trc->debugPrintIndex ? js_setter_str : js_getter_str;
  583: 
 8367:     if (JSID_IS_ATOM(id)) {
  583:         n = js_PutEscapedString(buf, bufsize - 1,
 4529:                                 ATOM_TO_STRING(JSID_TO_ATOM(id)), 0);
 4529:         if (n < bufsize - 1)
 8367:             JS_snprintf(buf + n, bufsize - n, " %s", name);
  583:     } else if (JSID_IS_INT(sprop->id)) {
 4529:         JS_snprintf(buf, bufsize, "%d %s", JSID_TO_INT(id), name);
  583:     } else {
  583:         JS_snprintf(buf, bufsize, "<object> %s", name);
  583:     }
  583: }
32658: 
32658: static void
32658: PrintPropertyMethod(JSTracer *trc, char *buf, size_t bufsize)
32658: {
32658:     JSScopeProperty *sprop;
32658:     jsid id;
32658:     size_t n;
32658: 
32658:     JS_ASSERT(trc->debugPrinter == PrintPropertyMethod);
32658:     sprop = (JSScopeProperty *)trc->debugPrintArg;
32658:     id = sprop->id;
33133:     JS_ASSERT(!JSVAL_IS_NULL(id));
32658: 
32658:     JS_ASSERT(JSID_IS_ATOM(id));
32658:     n = js_PutEscapedString(buf, bufsize - 1, ATOM_TO_STRING(JSID_TO_ATOM(id)), 0);
32658:     if (n < bufsize - 1)
32658:         JS_snprintf(buf + n, bufsize - n, " method");
32658: }
  583: #endif
  583: 
    1: void
30258: JSScopeProperty::trace(JSTracer *trc)
    1: {
 5975:     if (IS_GC_MARKING_TRACER(trc))
38562:         mark();
30852:     js_TraceId(trc, id);
    1: 
30258:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
39894:         if ((attrs & JSPROP_GETTER) && rawGetter) {
30258:             JS_SET_TRACING_DETAILS(trc, PrintPropertyGetterOrSetter, this, 0);
38595:             js_CallGCMarker(trc, getterObject(), JSTRACE_OBJECT);
    1:         }
39894:         if ((attrs & JSPROP_SETTER) && rawSetter) {
30258:             JS_SET_TRACING_DETAILS(trc, PrintPropertyGetterOrSetter, this, 1);
38595:             js_CallGCMarker(trc, setterObject(), JSTRACE_OBJECT);
    1:         }
    1:     }
32658: 
32658:     if (isMethod()) {
32658:         JS_SET_TRACING_DETAILS(trc, PrintPropertyMethod, this, 0);
38595:         js_CallGCMarker(trc, methodObject(), JSTRACE_OBJECT);
32658:     }
    1: }
