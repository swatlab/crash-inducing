 69827: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 69827:  * vim: set ts=8 sw=4 et tw=78:
 69827:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 69827: 
 69827: #ifndef ArgumentsObject_h___
 69827: #define ArgumentsObject_h___
 69827: 
 69827: #include "jsfun.h"
 69827: 
 69827: namespace js {
 69827: 
 70319: /*
 70319:  * ArgumentsData stores the initial indexed arguments provided to the
 70319:  * corresponding and that function itself.  It is used to store arguments[i]
 70319:  * and arguments.callee -- up until the corresponding property is modified,
100006:  * when the relevant value is overwritten with MagicValue(JS_ARGS_HOLE) to
100006:  * memorialize the modification.
 70319:  */
 69827: struct ArgumentsData
 69827: {
 69827:     /*
100006:      * arguments.callee, or MagicValue(JS_ARGS_HOLE) if arguments.callee has
100006:      * been modified.
 69827:      */
 82129:     HeapValue   callee;
 69827: 
 69827:     /*
 93646:      * Pointer to an array of bits indicating, for every argument in 'slots',
 93646:      * whether the element has been deleted. See isElementDeleted comment.
 93646:      */
 93646:     size_t      *deletedBits;
 93646: 
 93646:     /*
100006:      * Values of the arguments for this object, or MagicValue(JS_ARGS_HOLE) if
100006:      * the indexed argument has been modified.
 69827:      */
100006:     HeapValue   slots[1];
 69827: };
 69827: 
 70319: /*
 70319:  * ArgumentsObject instances represent |arguments| objects created to store
 70319:  * function arguments when a function is called.  It's expensive to create such
100006:  * objects if they're never used, so they're only created lazily.  (See
100006:  * js::StackFrame::setArgsObj and friends.)
 70319:  *
 70319:  * Arguments objects are complicated because, for non-strict mode code, they
 70319:  * must alias any named arguments which were provided to the function.  Gnarly
 70319:  * example:
 70319:  *
 70319:  *   function f(a, b, c, d)
 70319:  *   {
 70319:  *     arguments[0] = "seta";
 70319:  *     assertEq(a, "seta");
 70319:  *     b = "setb";
 70319:  *     assertEq(arguments[1], "setb");
 70319:  *     c = "setc";
 70319:  *     assertEq(arguments[2], undefined);
 70319:  *     arguments[3] = "setd";
 70319:  *     assertEq(d, undefined);
 70319:  *   }
 70319:  *   f("arga", "argb");
 70319:  *
 70319:  * ES5's strict mode behaves more sanely, and named arguments don't alias
 70319:  * elements of an arguments object.
 70319:  *
 70319:  * ArgumentsObject instances use the following reserved slots:
 70319:  *
 70319:  *   INITIAL_LENGTH_SLOT
 70319:  *     Stores the initial value of arguments.length, plus a bit indicating
 70319:  *     whether arguments.length has been modified.  Use initialLength() and
 70319:  *     hasOverriddenLength() to access these values.  If arguments.length has
 70319:  *     been modified, then the current value of arguments.length is stored in
 70319:  *     another slot associated with a new property.
 70319:  *   DATA_SLOT
100006:  *     Stores an ArgumentsData* storing argument values and the callee, or
100006:  *     sentinels for any of these if the corresponding property is modified.
100006:  *     Use callee() to access the callee/sentinel, and use
100006:  *     element/addressOfElement/setElement to access the values stored in
100006:  *     the ArgumentsData.  If you're simply looking to get arguments[i],
100006:  *     however, use getElement or getElements to avoid spreading arguments
100006:  *     object implementation details around too much.
100006:  *   STACK_FRAME_SLOT
100006:  *     Stores the function's stack frame for non-strict arguments objects until
100006:  *     the function returns, when it is replaced with null.  When an arguments
100006:  *     object is created on-trace its private is JS_ARGUMENTS_OBJECT_ON_TRACE,
100006:  *     and when the trace exits its private is replaced with the stack frame or
100006:  *     null, as appropriate. This slot is used by strict arguments objects as
100006:  *     well, but the slot is always null. Conceptually it would be better to
100006:  *     remove this oddity, but preserving it allows us to work with arguments
100006:  *     objects of either kind more abstractly, so we keep it for now.
 70319:  */
 86483: class ArgumentsObject : public JSObject
 69827: {
 84755:     static const uint32_t INITIAL_LENGTH_SLOT = 0;
 84755:     static const uint32_t DATA_SLOT = 1;
100006:     static const uint32_t STACK_FRAME_SLOT = 2;
 69827: 
100006:     /* Lower-order bit stolen from the length slot. */
 84755:     static const uint32_t LENGTH_OVERRIDDEN_BIT = 0x1;
 84755:     static const uint32_t PACKED_BITS_COUNT = 1;
 69827: 
100006:     void initInitialLength(uint32_t length);
100006:     void initData(ArgumentsData *data);
100006:     static ArgumentsObject *create(JSContext *cx, uint32_t argc, HandleObject callee);
 69827: 
 69827:   public:
 93646:     static const uint32_t RESERVED_SLOTS = 3;
 93646:     static const gc::AllocKind FINALIZE_KIND = gc::FINALIZE_OBJECT4;
 93646: 
 93250:     /* Create an arguments object for a frame that is expecting them. */
100006:     static ArgumentsObject *create(JSContext *cx, StackFrame *fp);
 93250: 
 93250:     /*
 93250:      * Purposefully disconnect the returned arguments object from the frame
 93250:      * by always creating a new copy that does not alias formal parameters.
 93250:      * This allows function-local analysis to determine that formals are
 93250:      * not aliased and generally simplifies arguments objects.
 93250:      */
 93250:     static ArgumentsObject *createUnexpected(JSContext *cx, StackFrame *fp);
 69827: 
 69827:     /*
 69827:      * Return the initial length of the arguments.  This may differ from the
 69827:      * current value of arguments.length!
 69827:      */
 84755:     inline uint32_t initialLength() const;
 69827: 
 69827:     /* True iff arguments.length has been assigned or its attributes changed. */
 69827:     inline bool hasOverriddenLength() const;
 69827:     inline void markLengthOverridden();
 69827: 
 70319:     /*
100006:      * Attempt to speedily and efficiently access the i-th element of this
100006:      * arguments object.  Return true if the element was speedily returned.
100006:      * Return false if the element must be looked up more slowly using
100006:      * getProperty or some similar method.
100006:      *
100006:      * NB: Returning false does not indicate error!
100006:      */
100006:     inline bool getElement(uint32_t i, js::Value *vp);
100006: 
100006:     /*
100006:      * Attempt to speedily and efficiently get elements [start, start + count)
100006:      * of this arguments object into the locations starting at |vp|.  Return
100006:      * true if all elements were copied.  Return false if the elements must be
100006:      * gotten more slowly, perhaps using a getProperty or some similar method
100006:      * in a loop.
100006:      *
100006:      * NB: Returning false does not indicate error!
100006:      */
100006:     inline bool getElements(uint32_t start, uint32_t count, js::Value *vp);
100006: 
100006:     inline js::ArgumentsData *data() const;
100006: 
100006:     /*
 93646:      * Because the arguments object is a real object, its elements may be
 93646:      * deleted. This is implemented by setting a 'deleted' flag for the arg
 93646:      * which is read by argument object resolve and getter/setter hooks.
 93646:      *
 93646:      * NB: an element, once deleted, stays deleted. Thus:
 93646:      *
 93646:      *   function f(x) { delete arguments[0]; arguments[0] = 42; return x }
 93646:      *   assertEq(f(1), 1);
 93646:      *
 93646:      * This works because, once a property is deleted from an arguments object,
 93646:      * it gets regular properties with regular getters/setters that don't alias
 93646:      * ArgumentsData::slots.
 93646:      */
 93646:     inline bool isElementDeleted(uint32_t i) const;
 93646:     inline bool isAnyElementDeleted() const;
 93646:     inline void markElementDeleted(uint32_t i);
 93646: 
100006:     inline const js::Value &element(uint32_t i) const;
100006:     inline void setElement(uint32_t i, const js::Value &v);
 78065: 
100006:     /* The stack frame for this ArgumentsObject, if the frame is still active. */
100006:     inline js::StackFrame *maybeStackFrame() const;
100006:     inline void setStackFrame(js::StackFrame *frame);
 89497: 
 89497:     /*
 89497:      * Measures things hanging off this ArgumentsObject that are counted by the
 89497:      * |miscSize| argument in JSObject::sizeOfExcludingThis().
 89497:      */
 89497:     inline size_t sizeOfMisc(JSMallocSizeOfFun mallocSizeOf) const;
 69827: };
 69827: 
 69827: class NormalArgumentsObject : public ArgumentsObject
 69827: {
 69827:   public:
 69827:     /*
 69827:      * Stores arguments.callee, or MagicValue(JS_ARGS_HOLE) if the callee has
 69827:      * been cleared.
 69827:      */
 69827:     inline const js::Value &callee() const;
 69827: 
 69827:     /* Clear the location storing arguments.callee's initial value. */
 69827:     inline void clearCallee();
 93250: 
 93250:     /*
 93250:      * Return 'arguments[index]' for some unmodified NormalArgumentsObject of
 93250:      * 'fp' (the actual instance of 'arguments' doesn't matter so it does not
 93250:      * have to be passed or even created).
 93250:      */
 93250:     static bool optimizedGetElem(JSContext *cx, StackFrame *fp, const Value &elem, Value *vp);
 69827: };
 69827: 
 69827: class StrictArgumentsObject : public ArgumentsObject
 93250: {};
 69827: 
 69827: } // namespace js
 69827: 
 86483: js::NormalArgumentsObject &
 69827: JSObject::asNormalArguments()
 69827: {
 69827:     JS_ASSERT(isNormalArguments());
 89497:     return *static_cast<js::NormalArgumentsObject *>(this);
 69827: }
 69827: 
 86483: js::StrictArgumentsObject &
 69827: JSObject::asStrictArguments()
 69827: {
 69827:     JS_ASSERT(isStrictArguments());
 89497:     return *static_cast<js::StrictArgumentsObject *>(this);
 69827: }
 69827: 
 86483: js::ArgumentsObject &
 69827: JSObject::asArguments()
 69827: {
 69827:     JS_ASSERT(isArguments());
 89497:     return *static_cast<js::ArgumentsObject *>(this);
 89497: }
 89497: 
 89497: const js::ArgumentsObject &
 89497: JSObject::asArguments() const
 89497: {
 89497:     JS_ASSERT(isArguments());
 89497:     return *static_cast<const js::ArgumentsObject *>(this);
 69827: }
 69827: 
 69827: #endif /* ArgumentsObject_h___ */
