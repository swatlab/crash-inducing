    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sw=2 sts=2 ci et: */
    1: /*
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Ben Goodger <ben@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // Local includes
    1: #include "nsXULWindow.h"
    1: 
    1: // Helper classes
    1: #include "nsString.h"
    1: #include "nsWidgetsCID.h"
    1: #include "prprf.h"
    1: #include "nsCRT.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNetCID.h"
    1: 
    1: //Interfaces needed to be included
    1: #include "nsIAppShell.h"
    1: #include "nsIAppShellService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMBarProp.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMXULElement.h"
 4040: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMScreen.h"
    1: #include "nsIEmbeddingSiteWindow.h"
    1: #include "nsIEmbeddingSiteWindow2.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIIOService.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIWindowMediator.h"
    1: #include "nsIScreenManager.h"
    1: #include "nsIScreen.h"
    1: #include "nsIScrollable.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIURI.h"
    1: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMViewCSS.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsITimelineService.h"
    1: #include "nsAppShellCID.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsStyleConsts.h"
21733: #include "nsPresContext.h"
    1: 
    1: #include "nsWebShellWindow.h" // get rid of this one, too...
    1: 
    1: #define SIZEMODE_NORMAL    NS_LITERAL_STRING("normal")
    1: #define SIZEMODE_MAXIMIZED NS_LITERAL_STRING("maximized")
    1: #define SIZEMODE_MINIMIZED NS_LITERAL_STRING("minimized")
    1: 
    1: #define WINDOWTYPE_ATTRIBUTE NS_LITERAL_STRING("windowtype")
    1: 
    1: #define PERSIST_ATTRIBUTE  NS_LITERAL_STRING("persist")
    1: #define SCREENX_ATTRIBUTE  NS_LITERAL_STRING("screenX")
    1: #define SCREENY_ATTRIBUTE  NS_LITERAL_STRING("screenY")
    1: #define WIDTH_ATTRIBUTE    NS_LITERAL_STRING("width")
    1: #define HEIGHT_ATTRIBUTE   NS_LITERAL_STRING("height")
    1: #define MODE_ATTRIBUTE     NS_LITERAL_STRING("sizemode")
    1: #define ZLEVEL_ATTRIBUTE   NS_LITERAL_STRING("zlevel")
    1: 
24816: // Unit conversion helpers
24816: static PRInt32
24816: CSSToDevPixels(PRInt32 aPixels, PRInt32 aAppPerDev)
24816: {
24816:   return NSAppUnitsToIntPixels(nsPresContext::CSSPixelsToAppUnits(aPixels),
24816:                                aAppPerDev);
24816: }
24816: 
24816: static PRInt32
24816: DevToCSSPixels(PRInt32 aPixels, PRInt32 aAppPerDev)
24816: {
24816:   return nsPresContext::AppUnitsToIntCSSPixels(
24816:     NSIntPixelsToAppUnits(aPixels, aAppPerDev));
24816: }
24816: 
24816: 
    1: //*****************************************************************************
    1: //***    nsXULWindow: Object Management
    1: //*****************************************************************************
    1: 
    1: nsXULWindow::nsXULWindow()
    1:   : mChromeTreeOwner(nsnull), 
    1:     mContentTreeOwner(nsnull),
    1:     mPrimaryContentTreeOwner(nsnull),
    1:     mModalStatus(NS_OK),
    1:     mContinueModalLoop(PR_FALSE),
    1:     mDebuting(PR_FALSE),
    1:     mChromeLoaded(PR_FALSE), 
    1:     mShowAfterLoad(PR_FALSE),
    1:     mIntrinsicallySized(PR_FALSE),
    1:     mCenterAfterLoad(PR_FALSE),
    1:     mIsHiddenWindow(PR_FALSE),
    1:     mLockedUntilChromeLoad(PR_FALSE),
    1:     mContextFlags(0),
    1:     mBlurSuppressionLevel(0),
    1:     mPersistentAttributesDirty(0),
    1:     mPersistentAttributesMask(0),
26484:     mChromeFlags(nsIWebBrowserChrome::CHROME_ALL),
26484:     // best guess till we have a widget
26484:     mAppPerDev(nsPresContext::AppUnitsPerCSSPixel()) 
    1: {
    1: }
    1: 
    1: nsXULWindow::~nsXULWindow()
    1: {
    1:   Destroy();
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsXULWindow::nsISupports
    1: //*****************************************************************************
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsXULWindow)
    1: NS_IMPL_THREADSAFE_RELEASE(nsXULWindow)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsXULWindow)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXULWindow)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXULWindow)
    1:   NS_INTERFACE_MAP_ENTRY(nsIBaseWindow)
    1:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   if (aIID.Equals(NS_GET_IID(nsXULWindow)))
 3233:     foundInterface = reinterpret_cast<nsISupports*>(this);
    1:   else
    1: NS_INTERFACE_MAP_END
    1: 
    1: //*****************************************************************************
    1: // nsXULWindow::nsIIntefaceRequestor
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetInterface(const nsIID& aIID, void** aSink)
    1: {
    1:   nsresult rv;
    1: 
    1:   NS_ENSURE_ARG_POINTER(aSink);
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIPrompt))) {
    1:     rv = EnsurePrompter();
    1:     if (NS_FAILED(rv)) return rv;
    1:     return mPrompter->QueryInterface(aIID, aSink);
    1:   }   
    1:   if (aIID.Equals(NS_GET_IID(nsIAuthPrompt))) {
    1:     rv = EnsureAuthPrompter();
    1:     if (NS_FAILED(rv)) return rv;
    1:     return mAuthPrompter->QueryInterface(aIID, aSink);
    1:   }
14886:   if (aIID.Equals(NS_GET_IID(nsIDOMWindowInternal))) {
14886:     return GetWindowDOMWindow(reinterpret_cast<nsIDOMWindowInternal**>(aSink));
14886:   }   
    1:   if (aIID.Equals(NS_GET_IID(nsIWebBrowserChrome)) && 
    1:     NS_SUCCEEDED(EnsureContentTreeOwner()) &&
    1:     NS_SUCCEEDED(mContentTreeOwner->QueryInterface(aIID, aSink)))
    1:     return NS_OK;
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIEmbeddingSiteWindow)) && 
    1:     NS_SUCCEEDED(EnsureContentTreeOwner()) &&
    1:     NS_SUCCEEDED(mContentTreeOwner->QueryInterface(aIID, aSink)))
    1:     return NS_OK;
    1:   if (aIID.Equals(NS_GET_IID(nsIEmbeddingSiteWindow2)) && 
    1:     NS_SUCCEEDED(EnsureContentTreeOwner()) &&
    1:     NS_SUCCEEDED(mContentTreeOwner->QueryInterface(aIID, aSink)))
    1:     return NS_OK;
    1: 
    1:   return QueryInterface(aIID, aSink);
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsXULWindow::nsIXULWindow
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetDocShell(nsIDocShell** aDocShell)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocShell);
    1: 
    1:   *aDocShell = mDocShell;
    1:   NS_IF_ADDREF(*aDocShell);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetZLevel(PRUint32 *outLevel)
    1: {
 5691:   nsCOMPtr<nsIWindowMediator> mediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (mediator)
    1:     mediator->GetZLevel(this, outLevel);
    1:   else
    1:     *outLevel = normalZ;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetZLevel(PRUint32 aLevel)
    1: {
 5691:   nsCOMPtr<nsIWindowMediator> mediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (!mediator)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRUint32 zLevel;
    1:   mediator->GetZLevel(this, &zLevel);
    1:   if (zLevel == aLevel)
    1:     return NS_OK;
    1: 
    1:   /* refuse to raise a maximized window above the normal browser level,
    1:      for fear it could hide newly opened browser windows */
    1:   if (aLevel > nsIXULWindow::normalZ) {
    1:     PRInt32 sizeMode;
    1:     if (mWindow) {
    1:       mWindow->GetSizeMode(&sizeMode);
    1:       if (sizeMode == nsSizeMode_Maximized)
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   // disallow user script
    1:   nsCOMPtr<nsIScriptSecurityManager> secMan =
    1:            do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
    1:   if (!secMan)
    1:     return NS_ERROR_FAILURE;
    1:   PRBool inChrome;
    1:   if (NS_FAILED(secMan->SubjectPrincipalIsSystem(&inChrome)) || !inChrome)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // do it
    1:   mediator->SetZLevel(this, aLevel);
    1:   PersistentAttributesDirty(PAD_MISC);
    1:   SavePersistentAttributes();
    1: 
    1:   // finally, send a notification DOM event
    1:   nsCOMPtr<nsIContentViewer> cv;
    1:   mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:   nsCOMPtr<nsIDocumentViewer> dv(do_QueryInterface(cv));
    1:   if (dv) {
    1:     nsCOMPtr<nsIDocument> doc;
    1:     dv->GetDocument(getter_AddRefs(doc));
    1:     nsCOMPtr<nsIDOMDocumentEvent> docEvent(do_QueryInterface(doc));
    1:     if (docEvent) {
    1:       nsCOMPtr<nsIDOMEvent> event;
    1:       docEvent->CreateEvent(NS_LITERAL_STRING("Events"), getter_AddRefs(event));
    1:       if (event) {
    1:         event->InitEvent(NS_LITERAL_STRING("windowZLevel"), PR_TRUE, PR_FALSE);
    1: 
    1:         nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
    1:         privateEvent->SetTrusted(PR_TRUE);
    1: 
    1:         nsCOMPtr<nsIDOMEventTarget> targ(do_QueryInterface(doc));
    1:         if (targ) {
    1:           PRBool defaultActionEnabled;
    1:           targ->DispatchEvent(event, &defaultActionEnabled);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetContextFlags(PRUint32 *aContextFlags)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aContextFlags);
    1:   *aContextFlags = mContextFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetContextFlags(PRUint32 aContextFlags)
    1: {
    1:   mContextFlags = aContextFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetChromeFlags(PRUint32 *aChromeFlags)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aChromeFlags);
    1:   *aChromeFlags = mChromeFlags;
    1:   /* mChromeFlags is kept up to date, except for scrollbar visibility.
    1:      That can be changed directly by the content DOM window, which
    1:      doesn't know to update the chrome window. So that we must check
    1:      separately. */
    1: 
    1:   // however, it's pointless to ask if the window isn't set up yet
    1:   if (!mChromeLoaded)
    1:     return NS_OK;
    1: 
    1:   if (GetContentScrollbarVisibility())
    1:     *aChromeFlags |= nsIWebBrowserChrome::CHROME_SCROLLBARS;
    1:   else
    1:     *aChromeFlags &= ~nsIWebBrowserChrome::CHROME_SCROLLBARS;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetChromeFlags(PRUint32 aChromeFlags)
    1: {
    1:   mChromeFlags = aChromeFlags;
    1:   if (mChromeLoaded)
    1:     NS_ENSURE_SUCCESS(ApplyChromeFlags(), NS_ERROR_FAILURE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetIntrinsicallySized(PRBool aIntrinsicallySized)
    1: {
    1:   mIntrinsicallySized = aIntrinsicallySized;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetIntrinsicallySized(PRBool* aIntrinsicallySized)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIntrinsicallySized);
    1: 
    1:   *aIntrinsicallySized = mIntrinsicallySized;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetPrimaryContentShell(nsIDocShellTreeItem** 
    1:    aDocShellTreeItem)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocShellTreeItem);
    1:   NS_IF_ADDREF(*aDocShellTreeItem = mPrimaryContentShell);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetContentShellById(const PRUnichar* aID, 
    1:    nsIDocShellTreeItem** aDocShellTreeItem)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocShellTreeItem);
    1:   *aDocShellTreeItem = nsnull;
    1: 
25835:   PRUint32 count = mContentShells.Length();
25835:   for (PRUint32 i = 0; i < count; i++) {
25835:     nsContentShellInfo* shellInfo = mContentShells.ElementAt(i);
    1:     if (shellInfo->id.Equals(aID)) {
    1:       *aDocShellTreeItem = nsnull;
    1:       if (shellInfo->child)
    1:         CallQueryReferent(shellInfo->child.get(), aDocShellTreeItem);
    1:       return NS_OK;
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::AddChildWindow(nsIXULWindow *aChild)
    1: {
    1:   // we're not really keeping track of this right now
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::RemoveChildWindow(nsIXULWindow *aChild)
    1: {
    1:   // we're not really keeping track of this right now
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::ShowModal()
    1: {
    1:   // Store locally so it doesn't die on us
    1:   nsCOMPtr<nsIWidget> window = mWindow;
    1:   nsCOMPtr<nsIXULWindow> tempRef = this;  
    1: 
    1:   window->SetModal(PR_TRUE);
    1:   mContinueModalLoop = PR_TRUE;
    1:   EnableParent(PR_FALSE);
    1: 
    1:   nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
    1:   if (stack && NS_SUCCEEDED(stack->Push(nsnull))) {
    1:     nsIThread *thread = NS_GetCurrentThread();
    1:     while (mContinueModalLoop) {
    1:       if (!NS_ProcessNextEvent(thread))
    1:         break;
    1:     }
    1:     JSContext* cx;
    1:     stack->Pop(&cx);
    1:     NS_ASSERTION(cx == nsnull, "JSContextStack mismatch");
    1:   }
    1: 
    1:   mContinueModalLoop = PR_FALSE;
    1:   window->SetModal(PR_FALSE);
    1:   /*   Note there's no EnableParent(PR_TRUE) here to match the PR_FALSE one
    1:      above. That's done in ExitModalLoop. It's important that the parent
    1:      be re-enabled before this window is made invisible; to do otherwise
    1:      causes bizarre z-ordering problems. At this point, the window is
    1:      already invisible.
    1:        No known current implementation of Enable would have a problem with
    1:      re-enabling the parent twice, so we could do it again here without
    1:      breaking any current implementation. But that's unnecessary if the
    1:      modal loop is always exited using ExitModalLoop (the other way would be
    1:      to change the protected member variable directly.)
    1:   */
    1: 
    1:   return mModalStatus;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsXULWindow::nsIBaseWindow
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsXULWindow::InitWindow(nativeWindow aParentNativeWindow,
    1:    nsIWidget* parentWidget, PRInt32 x, PRInt32 y, PRInt32 cx, PRInt32 cy)   
    1: {
    1:   //XXX First Check In
    1:   NS_ASSERTION(PR_FALSE, "Not Yet Implemented");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::Create()
    1: {
    1:   //XXX First Check In
    1:   NS_ASSERTION(PR_FALSE, "Not Yet Implemented");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::Destroy()
    1: {
    1:   if (!mWindow)
    1:      return NS_OK;
    1: 
    1:   nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
    1:   NS_ASSERTION(appShell, "Couldn't get appShell... xpcom shutdown?");
    1:   if (appShell)
 3233:     appShell->UnregisterTopLevelWindow(static_cast<nsIXULWindow*>(this));
    1: 
    1:   nsCOMPtr<nsIXULWindow> parentWindow(do_QueryReferent(mParentWindow));
    1:   if (parentWindow)
    1:     parentWindow->RemoveChildWindow(this);
    1: 
    1:   // let's make sure the window doesn't get deleted out from under us
    1:   // while we are trying to close....this can happen if the docshell
    1:   // we close ends up being the last owning reference to this xulwindow
    1: 
    1:   // XXXTAB This shouldn't be an issue anymore because the ownership model
    1:   // only goes in one direction.  When webshell container is fully removed
    1:   // try removing this...
    1: 
    1:   nsCOMPtr<nsIXULWindow> placeHolder = this;
    1: 
    1:   // Remove modality (if any) and hide while destroying. More than
    1:   // a convenience, the hide prevents user interaction with the partially
    1:   // destroyed window. This is especially necessary when the eldest window
    1:   // in a stack of modal windows is destroyed first. It happens.
    1:   ExitModalLoop(NS_OK);
    1:   if (mWindow)
    1:     mWindow->Show(PR_FALSE);
    1: 
    1: #if defined(XP_WIN) || defined(XP_OS2)
16326:   // We need to explicitly set the focus on Windows, but 
16326:   // only if the parent is visible.
    1:   nsCOMPtr<nsIBaseWindow> parent(do_QueryReferent(mParentWindow));
    1:   if (parent) {
16326:     PRBool parentVisible = PR_TRUE;
16326:     nsCOMPtr<nsIWidget> parentWidget;
16326:     parent->GetMainWidget(getter_AddRefs(parentWidget));
16326:     if (parentWidget)
16326:       parentWidget->IsVisible(parentVisible);
16326:     if (parentVisible) {
    1:       nsCOMPtr<nsIBaseWindow> baseHiddenWindow;
    1:       if (appShell) {
    1:         nsCOMPtr<nsIXULWindow> hiddenWindow;
    1:         appShell->GetHiddenWindow(getter_AddRefs(hiddenWindow));
    1:         if (hiddenWindow)
    1:           baseHiddenWindow = do_GetInterface(hiddenWindow);
    1:       }
    1:       // somebody screwed up somewhere. hiddenwindow shouldn't be anybody's
    1:       // parent. still, when it happens, skip activating it.
    1:       if (baseHiddenWindow != parent) {
    1:         nsCOMPtr<nsIWidget> parentWidget;
    1:         parent->GetMainWidget(getter_AddRefs(parentWidget));
    1:         if (parentWidget)
    1:           parentWidget->PlaceBehind(eZPlacementTop, 0, PR_TRUE);
    1:       }
    1:     }
16326:   }
    1: #endif
    1:    
    1:   mDOMWindow = nsnull;
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIBaseWindow> shellAsWin(do_QueryInterface(mDocShell));
    1:     shellAsWin->Destroy();
    1:     mDocShell = nsnull; // this can cause reentrancy of this function
    1:   }
    1: 
    1:   // Remove our ref on the content shells
25835:   PRUint32 count = mContentShells.Length();
25835:   for (PRUint32 i = 0; i < count; i++) {
25835:     nsContentShellInfo* shellInfo = mContentShells.ElementAt(i);
    1:     delete shellInfo;
    1:   }
    1:   mContentShells.Clear();
    1:   mPrimaryContentShell = nsnull;
    1: 
    1:   if (mContentTreeOwner) {
    1:     mContentTreeOwner->XULWindow(nsnull);
    1:     NS_RELEASE(mContentTreeOwner);
    1:   }
    1:   if (mPrimaryContentTreeOwner) {
    1:     mPrimaryContentTreeOwner->XULWindow(nsnull);
    1:     NS_RELEASE(mPrimaryContentTreeOwner);
    1:   }
    1:   if (mChromeTreeOwner) {
    1:     mChromeTreeOwner->XULWindow(nsnull);
    1:     NS_RELEASE(mChromeTreeOwner);
    1:   }
    1:   if (mWindow) {
    1:     mWindow->SetClientData(0); // nsWebShellWindow hackery
    1:     mWindow = nsnull;
    1:   }
    1: 
    1:   if (!mIsHiddenWindow) {
    1:     /* Inform appstartup we've destroyed this window and it could
    1:        quit now if it wanted. This must happen at least after mDocShell
    1:        is destroyed, because onunload handlers fire then, and those being
    1:        script, anything could happen. A new window could open, even.
    1:        See bug 130719. */
    1:     nsCOMPtr<nsIObserverService> obssvc =
    1:         do_GetService("@mozilla.org/observer-service;1");
    1:     NS_ASSERTION(obssvc, "Couldn't get observer service?");
    1: 
    1:     if (obssvc)
    1:       obssvc->NotifyObservers(nsnull, "xul-window-destroyed", nsnull);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetPosition(PRInt32 aX, PRInt32 aY)
    1: {
    1:   /* any attempt to set the window's size or position overrides the window's
    1:      zoom state. this is important when these two states are competing while
    1:      the window is being opened. but it should probably just always be so. */
    1:   mWindow->SetSizeMode(nsSizeMode_Normal);
    1:     
    1:   NS_ENSURE_SUCCESS(mWindow->Move(aX, aY), NS_ERROR_FAILURE);
    1:   PersistentAttributesDirty(PAD_POSITION);
    1:   SavePersistentAttributes();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetPosition(PRInt32* aX, PRInt32* aY)
    1: {
    1:   return GetPositionAndSize(aX, aY, nsnull, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetSize(PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
    1: {
    1:   /* any attempt to set the window's size or position overrides the window's
    1:      zoom state. this is important when these two states are competing while
    1:      the window is being opened. but it should probably just always be so. */
    1:   mWindow->SetSizeMode(nsSizeMode_Normal);
    1: 
    1:   mIntrinsicallySized = PR_FALSE;
    1: 
24816:   NS_ENSURE_SUCCESS(mWindow->Resize(aCX, aCY, aRepaint), NS_ERROR_FAILURE);
    1:   PersistentAttributesDirty(PAD_SIZE);
    1:   SavePersistentAttributes();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetSize(PRInt32* aCX, PRInt32* aCY)
    1: {
    1:   return GetPositionAndSize(nsnull, nsnull, aCX, aCY);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetPositionAndSize(PRInt32 aX, PRInt32 aY, 
    1:    PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
    1: {
    1:   /* any attempt to set the window's size or position overrides the window's
    1:      zoom state. this is important when these two states are competing while
    1:      the window is being opened. but it should probably just always be so. */
    1:   mWindow->SetSizeMode(nsSizeMode_Normal);
    1: 
    1:   mIntrinsicallySized = PR_FALSE;
    1: 
    1:   NS_ENSURE_SUCCESS(mWindow->Resize(aX, aY, aCX, aCY, aRepaint), NS_ERROR_FAILURE);
    1:   PersistentAttributesDirty(PAD_POSITION | PAD_SIZE);
    1:   SavePersistentAttributes();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetPositionAndSize(PRInt32* x, PRInt32* y, PRInt32* cx,
    1:    PRInt32* cy)
    1: {
23738:   nsIntRect rect;
    1: 
    1:   if (!mWindow)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mWindow->GetScreenBounds(rect);
    1: 
    1:   if (x)
    1:     *x = rect.x;
    1:   if (y)
    1:     *y = rect.y;
    1:   if (cx)
    1:     *cx = rect.width;
    1:   if (cy)
    1:     *cy = rect.height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
23391: NS_IMETHODIMP nsXULWindow::Center(nsIXULWindow *aRelative, PRBool aScreen, PRBool aAlert)
23391: {
    1:   PRInt32  left, top, width, height,
    1:            ourWidth, ourHeight;
    1:   PRBool   screenCoordinates =  PR_FALSE,
    1:            windowCoordinates =  PR_FALSE;
    1:   nsresult result;
    1: 
    1:   if (!mChromeLoaded) {
    1:     // note we lose the parameters. at time of writing, this isn't a problem.
    1:     mCenterAfterLoad = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!aScreen && !aRelative)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService("@mozilla.org/gfx/screenmanager;1", &result);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   nsCOMPtr<nsIScreen> screen;
    1: 
    1:   if (aRelative) {
    1:     nsCOMPtr<nsIBaseWindow> base(do_QueryInterface(aRelative, &result));
    1:     if (base) {
    1:       // get window rect
    1:       result = base->GetPositionAndSize(&left, &top, &width, &height);
    1:       if (NS_SUCCEEDED(result)) {
    1:         // if centering on screen, convert that to the corresponding screen
    1:         if (aScreen)
    1:           screenmgr->ScreenForRect(left, top, width, height, getter_AddRefs(screen));
    1:         else
    1:           windowCoordinates = PR_TRUE;
    1:       } else {
    1:         // something's wrong with the reference window.
    1:         // fall back to the primary screen
    1:         aRelative = 0;
    1:         aScreen = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   if (!aRelative)
    1:     screenmgr->GetPrimaryScreen(getter_AddRefs(screen));
    1: 
    1:   if (aScreen && screen) {
    1:     screen->GetAvailRect(&left, &top, &width, &height);
    1:     screenCoordinates = PR_TRUE;
    1:   }
    1: 
    1:   if (screenCoordinates || windowCoordinates) {
    1:     GetSize(&ourWidth, &ourHeight);
    1:     left += (width - ourWidth) / 2;
    1:     top += (height - ourHeight) / (aAlert ? 3 : 2);
    1:     if (windowCoordinates)
    1:       mWindow->ConstrainPosition(PR_FALSE, &left, &top);
    1:     SetPosition(left, top);
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::Repaint(PRBool aForce)
    1: {
    1:   //XXX First Check In
    1:   NS_ASSERTION(PR_FALSE, "Not Yet Implemented");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetParentWidget(nsIWidget** aParentWidget)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParentWidget);
    1:   NS_ENSURE_STATE(mWindow);
    1: 
    1:   NS_IF_ADDREF(*aParentWidget = mWindow->GetParent());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetParentWidget(nsIWidget* aParentWidget)
    1: {
    1:   //XXX First Check In
    1:   NS_ASSERTION(PR_FALSE, "Not Yet Implemented");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetParentNativeWindow(nativeWindow* aParentNativeWindow)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParentNativeWindow);
    1: 
    1:   nsCOMPtr<nsIWidget> parentWidget;
    1:   NS_ENSURE_SUCCESS(GetParentWidget(getter_AddRefs(parentWidget)), NS_ERROR_FAILURE);
    1: 
    1:   *aParentNativeWindow = parentWidget->GetNativeData(NS_NATIVE_WIDGET);
    1:    
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetParentNativeWindow(nativeWindow aParentNativeWindow)
    1: {
    1:   //XXX First Check In
    1:   NS_ASSERTION(PR_FALSE, "Not Yet Implemented");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetVisibility(PRBool* aVisibility)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aVisibility);
    1: 
    1:   // Always claim to be visible for now. See bug
    1:   // https://bugzilla.mozilla.org/show_bug.cgi?id=306245.
    1: 
    1:   *aVisibility = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetVisibility(PRBool aVisibility)
    1: {
    1:   NS_TIMELINE_ENTER("nsXULWindow::SetVisibility.");
    1:   if (!mChromeLoaded) {
    1:     mShowAfterLoad = aVisibility;
    1:     NS_TIMELINE_LEAVE("nsXULWindow::SetVisibility");
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mDebuting) {
    1:     NS_TIMELINE_LEAVE("nsXULWindow::SetVisibility");
    1:     return NS_OK;
    1:   }
    1:   mDebuting = PR_TRUE;  // (Show / Focus is recursive)
    1: 
    1:   //XXXTAB Do we really need to show docshell and the window?  Isn't 
    1:   // the window good enough?
    1:   nsCOMPtr<nsIBaseWindow> shellAsWin(do_QueryInterface(mDocShell));
    1:   shellAsWin->SetVisibility(aVisibility);
    1:   mWindow->Show(aVisibility);
    1: 
 5691:   nsCOMPtr<nsIWindowMediator> windowMediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (windowMediator)
 3233:      windowMediator->UpdateWindowTimeStamp(static_cast<nsIXULWindow*>(this));
    1: 
    1:   // notify observers so that we can hide the splash screen if possible
    1:   nsCOMPtr<nsIObserverService> obssvc
    1:     (do_GetService("@mozilla.org/observer-service;1"));
    1:   NS_ASSERTION(obssvc, "Couldn't get observer service.");
    1:   if (obssvc) {
    1:     obssvc->NotifyObservers(nsnull, "xul-window-visible", nsnull); 
    1:   }
    1: 
    1:   mDebuting = PR_FALSE;
    1:   NS_TIMELINE_LEAVE("nsXULWindow::SetVisibility");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetEnabled(PRBool *aEnabled)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEnabled);
    1:   if (mWindow)
    1:     return mWindow->IsEnabled(aEnabled);
    1: 
    1:   *aEnabled = PR_TRUE; // better guess than most
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetEnabled(PRBool aEnable)
    1: {
    1:   if (mWindow) {
    1:     mWindow->Enable(aEnable);
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetBlurSuppression(PRBool *aBlurSuppression)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aBlurSuppression);
    1:   *aBlurSuppression = mBlurSuppressionLevel > 0;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetBlurSuppression(PRBool aBlurSuppression)
    1: {
    1:   if (aBlurSuppression)
    1:     ++mBlurSuppressionLevel;
    1:   else {
    1:     NS_ASSERTION(mBlurSuppressionLevel > 0, "blur over-allowed");
    1:     if (mBlurSuppressionLevel > 0)
    1:       --mBlurSuppressionLevel;
    1:   }
    1:   return NS_OK;
    1: 
    1:   /* XXX propagate this information to the widget? It has its own
    1:      independent concept of blur suppression. Each is used on
    1:      a different platform, so at time of writing it's not necessary
    1:      to keep them in sync. (And there's no interface for doing so.) */
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetMainWidget(nsIWidget** aMainWidget)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMainWidget);
    1:    
    1:   *aMainWidget = mWindow;
    1:   NS_IF_ADDREF(*aMainWidget);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetFocus()
    1: {
    1:   //XXX First Check In
    1:   NS_ASSERTION(PR_FALSE, "Not Yet Implemented");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetTitle(PRUnichar** aTitle)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aTitle);
    1: 
    1:   *aTitle = ToNewUnicode(mTitle);
    1:   if (!*aTitle)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetTitle(const PRUnichar* aTitle)
    1: {
    1:   NS_ENSURE_STATE(mWindow);
    1:   mTitle.Assign(aTitle);
    1:   mTitle.StripChars("\n\r");
    1:   NS_ENSURE_SUCCESS(mWindow->SetTitle(mTitle), NS_ERROR_FAILURE);
    1: 
    1:   // Tell the window mediator that a title has changed
 5691:   nsCOMPtr<nsIWindowMediator> windowMediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (!windowMediator)
    1:     return NS_OK;
    1: 
 3233:   windowMediator->UpdateWindowTitle(static_cast<nsIXULWindow*>(this), aTitle);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsXULWindow: Helpers
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsXULWindow::EnsureChromeTreeOwner()
    1: {
    1:   if (mChromeTreeOwner)
    1:     return NS_OK;
    1: 
    1:   mChromeTreeOwner = new nsChromeTreeOwner();
    1:   NS_ENSURE_TRUE(mChromeTreeOwner, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ADDREF(mChromeTreeOwner);
    1:   mChromeTreeOwner->XULWindow(this);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::EnsureContentTreeOwner()
    1: {
    1:   if (mContentTreeOwner)
    1:     return NS_OK;
    1: 
    1:   mContentTreeOwner = new nsContentTreeOwner(PR_FALSE);
    1:   NS_ENSURE_TRUE(mContentTreeOwner, NS_ERROR_FAILURE);
    1: 
    1:   NS_ADDREF(mContentTreeOwner);
    1:   mContentTreeOwner->XULWindow(this);
    1:    
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::EnsurePrimaryContentTreeOwner()
    1: {
    1:   if (mPrimaryContentTreeOwner)
    1:     return NS_OK;
    1: 
    1:   mPrimaryContentTreeOwner = new nsContentTreeOwner(PR_TRUE);
    1:   NS_ENSURE_TRUE(mPrimaryContentTreeOwner, NS_ERROR_FAILURE);
    1: 
    1:   NS_ADDREF(mPrimaryContentTreeOwner);
    1:   mPrimaryContentTreeOwner->XULWindow(this);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::EnsurePrompter()
    1: {
    1:   if (mPrompter)
    1:     return NS_OK;
    1:    
    1:   nsCOMPtr<nsIDOMWindowInternal> ourWindow;
    1:   nsresult rv = GetWindowDOMWindow(getter_AddRefs(ourWindow));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIWindowWatcher> wwatch = 
    1:         do_GetService(NS_WINDOWWATCHER_CONTRACTID);
    1:     if (wwatch)
    1:       wwatch->GetNewPrompter(ourWindow, getter_AddRefs(mPrompter));
    1:   }
    1:   return mPrompter ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::EnsureAuthPrompter()
    1: {
    1:   if (mAuthPrompter)
    1:     return NS_OK;
    1:       
    1:   nsCOMPtr<nsIDOMWindowInternal> ourWindow;
    1:   nsresult rv = GetWindowDOMWindow(getter_AddRefs(ourWindow));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:     if (wwatch)
    1:       wwatch->GetNewAuthPrompter(ourWindow, getter_AddRefs(mAuthPrompter));
    1:   }
    1:   return mAuthPrompter ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1:  
    1: void nsXULWindow::OnChromeLoaded()
    1: {
    1:   nsresult rv = EnsureContentTreeOwner();
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     mChromeLoaded = PR_TRUE;
    1:     ApplyChromeFlags();
    1: 
    1:     LoadChromeHidingFromXUL();
    1:     LoadWindowClassFromXUL();
    1:     LoadIconFromXUL();
    1:     LoadSizeFromXUL();
    1:     if (mIntrinsicallySized) {
    1:       // (if LoadSizeFromXUL set the size, mIntrinsicallySized will be false)
    1:       nsCOMPtr<nsIContentViewer> cv;
    1:       mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:       nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(cv));
    1:       if (markupViewer)
    1:         markupViewer->SizeToContent();
    1:     }
    1: 
    1:     PRBool positionSet = PR_TRUE;
    1:     nsCOMPtr<nsIXULWindow> parentWindow(do_QueryReferent(mParentWindow));
    1: #if defined(XP_UNIX) && !defined(XP_MACOSX)
    1:     // don't override WM placement on unix for independent, top-level windows
    1:     // (however, we think the benefits of intelligent dependent window placement
    1:     // trump that override.)
    1:     if (!parentWindow)
    1:       positionSet = PR_FALSE;
    1: #endif
    1:     if (positionSet)
    1:       positionSet = LoadPositionFromXUL();
    1:     LoadMiscPersistentAttributesFromXUL();
    1: 
    1:     //LoadContentAreas();
    1: 
    1:     if (mCenterAfterLoad && !positionSet)
    1:       Center(parentWindow, parentWindow ? PR_FALSE : PR_TRUE, PR_FALSE);
    1: 
    1:     if (mShowAfterLoad)
    1:       SetVisibility(PR_TRUE);
    1:   }
    1:   mPersistentAttributesMask |= PAD_POSITION | PAD_SIZE | PAD_MISC;
    1: }
    1: 
    1: nsresult nsXULWindow::LoadChromeHidingFromXUL()
    1: {
    1:   NS_ENSURE_STATE(mWindow);
    1: 
    1:   // Get <window> element.
    1:   nsCOMPtr<nsIDOMElement> windowElement;
    1:   GetWindowDOMElement(getter_AddRefs(windowElement));
    1:   NS_ENSURE_TRUE(windowElement, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString attr;
    1:   nsresult rv = windowElement->GetAttribute(NS_LITERAL_STRING("hidechrome"), attr);
    1: 
    1:   if (NS_SUCCEEDED(rv) && attr.LowerCaseEqualsLiteral("true")) {
    1:     mWindow->HideWindowChrome(PR_TRUE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsXULWindow::LoadPositionFromXUL()
    1: {
    1:   nsresult rv;
    1:   PRBool   gotPosition = PR_FALSE;
    1:   
    1:   // if we're the hidden window, don't try to validate our size/position. We're
    1:   // special.
    1:   if (mIsHiddenWindow)
    1:     return PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> windowElement;
    1:   GetWindowDOMElement(getter_AddRefs(windowElement));
    1:   NS_ASSERTION(windowElement, "no xul:window");
    1:   if (!windowElement)
    1:     return PR_FALSE;
    1: 
    1:   PRInt32 currX = 0;
    1:   PRInt32 currY = 0;
    1:   PRInt32 currWidth = 0;
    1:   PRInt32 currHeight = 0;
    1:   PRInt32 errorCode;
    1:   PRInt32 temp;
    1: 
    1:   GetPositionAndSize(&currX, &currY, &currWidth, &currHeight);
    1: 
    1:   // Obtain the position information from the <xul:window> element.
    1:   PRInt32 specX = currX;
    1:   PRInt32 specY = currY;
    1:   nsAutoString posString;
26484:   PRInt32 appPerDev = AppUnitsPerDevPixel();
    1: 
    1:   rv = windowElement->GetAttribute(NS_LITERAL_STRING("screenX"), posString);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     temp = posString.ToInteger(&errorCode);
    1:     if (NS_SUCCEEDED(errorCode)) {
24816:       specX = CSSToDevPixels(temp, appPerDev);
    1:       gotPosition = PR_TRUE;
    1:     }
    1:   }
    1:   rv = windowElement->GetAttribute(NS_LITERAL_STRING("screenY"), posString);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     temp = posString.ToInteger(&errorCode);
    1:     if (NS_SUCCEEDED(errorCode)) {
24816:       specY = CSSToDevPixels(temp, appPerDev);
    1:       gotPosition = PR_TRUE;
    1:     }
    1:   }
    1:     
    1:   if (gotPosition) {
    1:     // our position will be relative to our parent, if any
    1:     nsCOMPtr<nsIBaseWindow> parent(do_QueryReferent(mParentWindow));
    1:     if (parent) {
    1:       PRInt32 parentX, parentY;
    1:       if (NS_SUCCEEDED(parent->GetPosition(&parentX, &parentY))) {
    1:         specX += parentX;
    1:         specY += parentY;
    1:       }
 5900:     }
 5900:     else {
    1:       StaggerPosition(specX, specY, currWidth, currHeight);
    1:     }
 5900:   }
    1:   mWindow->ConstrainPosition(PR_FALSE, &specX, &specY);
    1:   if (specX != currX || specY != currY)
    1:     SetPosition(specX, specY);
    1: 
    1:   return gotPosition;
    1: }
    1: 
    1: PRBool nsXULWindow::LoadSizeFromXUL()
    1: {
    1:   nsresult rv;
    1:   PRBool   gotSize = PR_FALSE;
    1:   
    1:   // if we're the hidden window, don't try to validate our size/position. We're
    1:   // special.
    1:   if (mIsHiddenWindow)
    1:     return PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> windowElement;
    1:   GetWindowDOMElement(getter_AddRefs(windowElement));
    1:   NS_ASSERTION(windowElement, "no xul:window");
    1:   if (!windowElement)
    1:     return PR_FALSE;
    1: 
    1:   PRInt32 currWidth = 0;
    1:   PRInt32 currHeight = 0;
    1:   PRInt32 errorCode;
    1:   PRInt32 temp;
    1: 
    1:   GetSize(&currWidth, &currHeight);
    1: 
    1:   // Obtain the position and sizing information from the <xul:window> element.
    1:   PRInt32 specWidth = currWidth;
    1:   PRInt32 specHeight = currHeight;
    1:   nsAutoString sizeString;
26484:   PRInt32 appPerDev = AppUnitsPerDevPixel();
    1: 
    1:   rv = windowElement->GetAttribute(NS_LITERAL_STRING("width"), sizeString);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     temp = sizeString.ToInteger(&errorCode);
    1:     if (NS_SUCCEEDED(errorCode) && temp > 0) {
24816:       specWidth = CSSToDevPixels(PR_MAX(temp, 100), appPerDev);
    1:       gotSize = PR_TRUE;
    1:     }
    1:   }
    1:   rv = windowElement->GetAttribute(NS_LITERAL_STRING("height"), sizeString);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     temp = sizeString.ToInteger(&errorCode);
    1:     if (NS_SUCCEEDED(errorCode) && temp > 0) {
24816:       specHeight = CSSToDevPixels(PR_MAX(temp, 100), appPerDev);
    1:       gotSize = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   if (gotSize) {
    1:     // constrain to screen size
    1:     nsCOMPtr<nsIDOMWindowInternal> domWindow;
    1:     GetWindowDOMWindow(getter_AddRefs(domWindow));
    1:     if (domWindow) {
    1:       nsCOMPtr<nsIDOMScreen> screen;
    1:       domWindow->GetScreen(getter_AddRefs(screen));
    1:       if (screen) {
    1:         PRInt32 screenWidth;
    1:         PRInt32 screenHeight;
    1:         screen->GetAvailWidth(&screenWidth);
    1:         screen->GetAvailHeight(&screenHeight);
24816:         screenWidth = CSSToDevPixels(screenWidth, appPerDev);
24816:         screenHeight = CSSToDevPixels(screenHeight, appPerDev);
    1:         if (specWidth > screenWidth)
    1:           specWidth = screenWidth;
    1:         if (specHeight > screenHeight)
    1:           specHeight = screenHeight;
    1:       }
    1:     }
    1: 
    1:     mIntrinsicallySized = PR_FALSE;
    1:     if (specWidth != currWidth || specHeight != currHeight)
    1:       SetSize(specWidth, specHeight, PR_FALSE);
    1:   }
    1: 
    1:   return gotSize;
    1: }
    1: 
    1: /* Miscellaneous persistent attributes are attributes named in the
    1:    |persist| attribute, other than size and position. Those are special
    1:    because it's important to load those before one of the misc
    1:    attributes (sizemode) and they require extra processing. */
    1: PRBool nsXULWindow::LoadMiscPersistentAttributesFromXUL()
    1: {
    1:   nsresult rv;
    1:   PRBool   gotState = PR_FALSE;
    1:   
    1:   /* There are no misc attributes of interest to the hidden window.
    1:      It's especially important not to try to validate that window's
    1:      size or position, because some platforms (Mac OS X) need to
    1:      make it visible and offscreen. */
    1:   if (mIsHiddenWindow)
    1:     return PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> windowElement;
    1:   GetWindowDOMElement(getter_AddRefs(windowElement));
    1:   NS_ASSERTION(windowElement, "no xul:window");
    1:   if (!windowElement)
    1:     return PR_FALSE;
    1: 
    1:   nsAutoString stateString;
    1: 
    1:   // sizemode
    1:   rv = windowElement->GetAttribute(NS_LITERAL_STRING("sizemode"), stateString);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     PRInt32 sizeMode = nsSizeMode_Normal;
    1:     /* ignore request to minimize, to not confuse novices
    1:     if (stateString.Equals(SIZEMODE_MINIMIZED))
    1:       sizeMode = nsSizeMode_Minimized;
    1:     */
    1:     if (stateString.Equals(SIZEMODE_MAXIMIZED)) {
    1:       /* Honor request to maximize only if the window is sizable.
    1:          An unsizable, unmaximizable, yet maximized window confuses
    1:          Windows OS and is something of a travesty, anyway. */
    1:       if (mChromeFlags & nsIWebBrowserChrome::CHROME_WINDOW_RESIZE) {
    1:         mIntrinsicallySized = PR_FALSE;
    1:         sizeMode = nsSizeMode_Maximized;
    1:       }
    1:     }
    1:     // the widget had better be able to deal with not becoming visible yet
    1:     mWindow->SetSizeMode(sizeMode);
    1:     gotState = PR_TRUE;
    1:   }
    1: 
    1:   // zlevel
    1:   rv = windowElement->GetAttribute(NS_LITERAL_STRING("zlevel"), stateString);
    1:   if (NS_SUCCEEDED(rv) && stateString.Length() > 0) {
    1:     PRInt32  errorCode;
    1:     PRUint32 zLevel = stateString.ToInteger(&errorCode);
    1:     if (NS_SUCCEEDED(errorCode) && zLevel >= lowestZ && zLevel <= highestZ)
    1:       SetZLevel(zLevel);
    1:   }
    1: 
    1:   return gotState;
    1: }
    1: 
    1: /* Stagger windows of the same type so they don't appear on top of each other.
    1:    This code does have a scary double loop -- it'll keep passing through
    1:    the entire list of open windows until it finds a non-collision. Doesn't
    1:    seem to be a problem, but it deserves watching.
    1: */
    1: void nsXULWindow::StaggerPosition(PRInt32 &aRequestedX, PRInt32 &aRequestedY,
    1:                                   PRInt32 aSpecWidth, PRInt32 aSpecHeight)
    1: {
    1:   const PRInt32 kOffset = 22;
    1:   const PRInt32 kSlop = 4;
    1:   nsresult rv;
    1:   PRBool   keepTrying;
    1:   int      bouncedX = 0, // bounced off vertical edge of screen
    1:            bouncedY = 0; // bounced off horizontal edge
    1: 
    1:   // look for any other windows of this type
    1:   nsCOMPtr<nsIWindowMediator> wm(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (!wm)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDOMElement> windowElement;
    1:   GetWindowDOMElement(getter_AddRefs(windowElement));
    1:   nsCOMPtr<nsIXULWindow> ourXULWindow(this);
    1: 
    1:   nsAutoString windowType;
    1:   rv = windowElement->GetAttribute(WINDOWTYPE_ATTRIBUTE, windowType);
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
    1:   PRInt32 screenTop = 0,    // it's pointless to initialize these ...
    1:           screenRight = 0,  // ... but to prevent oversalubrious and ...
    1:           screenBottom = 0, // ... underbright compilers from ...
    1:           screenLeft = 0;   // ... issuing warnings.
    1:   PRBool  gotScreen = PR_FALSE;
    1: 
    1:   { // fetch screen coordinates
    1:     nsCOMPtr<nsIScreenManager> screenMgr(do_GetService(
    1:                                          "@mozilla.org/gfx/screenmanager;1"));
    1:     if (screenMgr) {
    1:       nsCOMPtr<nsIScreen> ourScreen;
    1:       screenMgr->ScreenForRect(aRequestedX, aRequestedY,
    1:                                aSpecWidth, aSpecHeight,
    1:                                getter_AddRefs(ourScreen));
    1:       if (ourScreen) {
    1:         PRInt32 screenWidth, screenHeight;
    1:         ourScreen->GetAvailRect(&screenLeft, &screenTop,
    1:                                 &screenWidth, &screenHeight);
    1:         screenBottom = screenTop + screenHeight;
    1:         screenRight = screenLeft + screenWidth;
    1:         gotScreen = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
 5900:   // One full pass through all windows of this type, repeat until no collisions.
    1:   do {
    1:     keepTrying = PR_FALSE;
    1:     nsCOMPtr<nsISimpleEnumerator> windowList;
    1:     wm->GetXULWindowEnumerator(windowType.get(), getter_AddRefs(windowList));
    1: 
    1:     if (!windowList)
    1:       break;
    1: 
 5900:     // One full pass through all windows of this type, offset and stop on collision.
    1:     do {
    1:       PRBool more;
    1:       windowList->HasMoreElements(&more);
    1:       if (!more)
    1:         break;
    1: 
    1:       nsCOMPtr<nsISupports> supportsWindow;
    1:       windowList->GetNext(getter_AddRefs(supportsWindow));
    1: 
    1:       nsCOMPtr<nsIXULWindow> listXULWindow(do_QueryInterface(supportsWindow));
 5900:       if (listXULWindow != ourXULWindow) {
 5900:         PRInt32 listX, listY;
    1:         nsCOMPtr<nsIBaseWindow> listBaseWindow(do_QueryInterface(supportsWindow));
    1:         listBaseWindow->GetPosition(&listX, &listY);
    1: 
    1:         if (PR_ABS(listX - aRequestedX) <= kSlop &&
    1:             PR_ABS(listY - aRequestedY) <= kSlop) {
    1:           // collision! offset and start over
    1:           if (bouncedX & 0x1)
    1:             aRequestedX -= kOffset;
    1:           else
    1:             aRequestedX += kOffset;
    1:           aRequestedY += kOffset;
    1: 
    1:           if (gotScreen) {
 5900:             // if we're moving to the right and we need to bounce...
 5900:             if (!(bouncedX & 0x1) && ((aRequestedX + aSpecWidth) > screenRight)) {
    1:               aRequestedX = screenRight - aSpecWidth;
    1:               ++bouncedX;
    1:             }
 5900: 
 5900:             // if we're moving to the left and we need to bounce...
    1:             if ((bouncedX & 0x1) && aRequestedX < screenLeft) {
    1:               aRequestedX = screenLeft;
    1:               ++bouncedX;
    1:             }
 5900: 
 5900:             // if we hit the bottom then bounce to the top
    1:             if (aRequestedY + aSpecHeight > screenBottom) {
    1:               aRequestedY = screenTop;
    1:               ++bouncedY;
    1:             }
    1:           }
    1: 
    1:           /* loop around again,
    1:              but it's time to give up once we've covered the screen.
    1:              there's a potential infinite loop with lots of windows. */
    1:           keepTrying = bouncedX < 2 || bouncedY == 0;
    1:           break;
    1:         }
    1:       }
    1:     } while(1);
    1:   } while (keepTrying);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::LoadWindowClassFromXUL()
    1: {
    1:   nsCOMPtr<nsIDOMElement> docShellElement;
    1:   GetWindowDOMElement(getter_AddRefs(docShellElement));
    1:   NS_ENSURE_TRUE(docShellElement, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString windowType;
    1: 
    1:   docShellElement->GetAttribute(NS_LITERAL_STRING("windowtype"),
    1:                                 windowType);
    1: 
    1:   if (!windowType.IsEmpty()) {
    1:     mWindow->SetWindowClass(windowType);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::LoadIconFromXUL()
    1: {
    1:   NS_ENSURE_STATE(mWindow);
    1: 
    1:   // Get <window> element.
    1:   nsCOMPtr<nsIDOMElement> windowElement;
    1:   GetWindowDOMElement(getter_AddRefs(windowElement));
    1:   NS_ENSURE_TRUE(windowElement, NS_ERROR_FAILURE);
    1: 
    1:   // XXX The following code is being #if 0'd out since it
    1:   // basically does nothing until bug 70974 is fixed.
    1:   // After bug 70974 is fixed, we will also need to implement
    1:   // computed style for that property before this will
    1:   // be of any use.  And even then, it will *still* 
    1:   // do nothing on platforms which don't implement 
    1:   // nsWindow::SetIcon(). See bug 76211 for that.
    1:   // Also see bug 57576 and its dependency tree.
    1: #if 0
    1:   // Get document in which this <window> is contained.
    1:   nsCOMPtr<nsIDOMDocument> document;
    1:   windowElement->GetOwnerDocument(getter_AddRefs(document));
    1:   NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
    1: 
    1:   // Get document view.
    1:   nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(document));
    1:   NS_ENSURE_TRUE(docView, NS_ERROR_FAILURE);
    1: 
    1:   // Get default/abstract view.
    1:   nsCOMPtr<nsIDOMAbstractView> abstractView;
    1:   docView->GetDefaultView(getter_AddRefs(abstractView));
    1:   NS_ENSURE_TRUE(abstractView, NS_ERROR_FAILURE);
    1: 
    1:   // Get "view CSS."
    1:   nsCOMPtr<nsIDOMViewCSS> viewCSS(do_QueryInterface(abstractView));
    1:   NS_ENSURE_TRUE(viewCSS, NS_ERROR_FAILURE);
    1: 
    1:   // Next, get CSS style declaration.
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
    1:   viewCSS->GetComputedStyle(windowElement, EmptyString(),
    1:                             getter_AddRefs(cssDecl));
    1:   NS_ENSURE_TRUE(cssDecl, NS_ERROR_FAILURE);
    1: 
    1:   // Whew.  Now get "list-style-image" property value.
    1:   nsAutoString windowIcon;
    1:   windowIcon.AssignLiteral("-moz-window-icon");
    1:   nsAutoString icon;
    1:   cssDecl->GetPropertyValue(windowIcon, icon);
    1: #endif
    1: 
    1:   nsAutoString id;
    1:   windowElement->GetAttribute(NS_LITERAL_STRING("id"), id);
    1: 
    1:   if (id.IsEmpty()) {
    1:     id.AssignLiteral("default");
    1:   }
    1: 
    1:   mWindow->SetIcon(id);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SavePersistentAttributes()
    1: {
    1:   // can happen when the persistence timer fires at an inopportune time
    1:   // during window shutdown
    1:   if (!mDocShell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> docShellElement;
    1:   GetWindowDOMElement(getter_AddRefs(docShellElement));
    1:   if (!docShellElement)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsAutoString   persistString;
    1:   docShellElement->GetAttribute(PERSIST_ATTRIBUTE, persistString);
    1:   if (persistString.IsEmpty()) { // quick check which sometimes helps
    1:     mPersistentAttributesDirty = 0;
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRInt32 x, y, cx, cy;
    1:   PRInt32 sizeMode;
    1: 
    1:   // get our size, position and mode to persist
    1:   NS_ENSURE_SUCCESS(GetPositionAndSize(&x, &y, &cx, &cy), NS_ERROR_FAILURE);
    1:   mWindow->GetSizeMode(&sizeMode);
    1: 
    1:   // make our position relative to our parent, if any
    1:   nsCOMPtr<nsIBaseWindow> parent(do_QueryReferent(mParentWindow));
    1:   if (parent) {
    1:     PRInt32 parentX, parentY;
    1:     if (NS_SUCCEEDED(parent->GetPosition(&parentX, &parentY))) {
    1:       x -= parentX;
    1:       y -= parentY;
    1:     }
    1:   }
    1: 
    1:   char                        sizeBuf[10];
    1:   nsAutoString                sizeString;
    1:   nsAutoString                windowElementId;
    1:   nsCOMPtr<nsIDOMXULDocument> ownerXULDoc;
26484:   PRInt32 appPerDev = AppUnitsPerDevPixel();
    1: 
    1:   { // fetch docShellElement's ID and XUL owner document
    1:     nsCOMPtr<nsIDOMDocument> ownerDoc;
    1:     docShellElement->GetOwnerDocument(getter_AddRefs(ownerDoc));
    1:     ownerXULDoc = do_QueryInterface(ownerDoc);
    1:     nsCOMPtr<nsIDOMXULElement> XULElement(do_QueryInterface(docShellElement));
    1:     if (XULElement)
    1:       XULElement->GetId(windowElementId);
    1:   }
    1: 
    1:   // (only for size elements which are persisted)
    1:   if ((mPersistentAttributesDirty & PAD_POSITION) &&
    1:       sizeMode == nsSizeMode_Normal) {
    1:     if (persistString.Find("screenX") >= 0) {
24816:       PR_snprintf(sizeBuf, sizeof(sizeBuf), "%ld",
24816:                   (long)DevToCSSPixels(x, appPerDev));
    1:       sizeString.AssignWithConversion(sizeBuf);
    1:       docShellElement->SetAttribute(SCREENX_ATTRIBUTE, sizeString);
    1:       if (ownerXULDoc) // force persistence in case the value didn't change
    1:         ownerXULDoc->Persist(windowElementId, SCREENX_ATTRIBUTE);
    1:     }
    1:     if (persistString.Find("screenY") >= 0) {
24816:       PR_snprintf(sizeBuf, sizeof(sizeBuf), "%ld",
24816:                   (long)DevToCSSPixels(y, appPerDev));
    1:       sizeString.AssignWithConversion(sizeBuf);
    1:       docShellElement->SetAttribute(SCREENY_ATTRIBUTE, sizeString);
    1:       if (ownerXULDoc)
    1:         ownerXULDoc->Persist(windowElementId, SCREENY_ATTRIBUTE);
    1:     }
    1:   }
    1: 
    1:   if ((mPersistentAttributesDirty & PAD_SIZE) &&
    1:       sizeMode == nsSizeMode_Normal) {
    1:     if (persistString.Find("width") >= 0) {
24816:       PR_snprintf(sizeBuf, sizeof(sizeBuf), "%ld",
24816:                   (long)DevToCSSPixels(cx, appPerDev));
    1:       sizeString.AssignWithConversion(sizeBuf);
    1:       docShellElement->SetAttribute(WIDTH_ATTRIBUTE, sizeString);
    1:       if (ownerXULDoc)
    1:         ownerXULDoc->Persist(windowElementId, WIDTH_ATTRIBUTE);
    1:     }
    1:     if (persistString.Find("height") >= 0) {
24816:       PR_snprintf(sizeBuf, sizeof(sizeBuf), "%ld",
24816:                   (long)DevToCSSPixels(cy, appPerDev));
    1:       sizeString.AssignWithConversion(sizeBuf);
    1:       docShellElement->SetAttribute(HEIGHT_ATTRIBUTE, sizeString);
    1:       if (ownerXULDoc)
    1:         ownerXULDoc->Persist(windowElementId, HEIGHT_ATTRIBUTE);
    1:     }
    1:   }
    1: 
    1:   if (mPersistentAttributesDirty & PAD_MISC) {
    1:     if (sizeMode != nsSizeMode_Minimized &&
    1:         persistString.Find("sizemode") >= 0) {
    1:       if (sizeMode == nsSizeMode_Maximized)
    1:         sizeString.Assign(SIZEMODE_MAXIMIZED);
    1:       else
    1:         sizeString.Assign(SIZEMODE_NORMAL);
    1:       docShellElement->SetAttribute(MODE_ATTRIBUTE, sizeString);
    1:       if (ownerXULDoc)
    1:         ownerXULDoc->Persist(windowElementId, MODE_ATTRIBUTE);
    1:     }
    1:     if (persistString.Find("zlevel") >= 0) {
    1:       PRUint32 zLevel;
 5691:       nsCOMPtr<nsIWindowMediator> mediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:       if (mediator) {
    1:         mediator->GetZLevel(this, &zLevel);
    1:         PR_snprintf(sizeBuf, sizeof(sizeBuf), "%lu", (unsigned long)zLevel);
    1:         sizeString.AssignWithConversion(sizeBuf);
    1:         docShellElement->SetAttribute(ZLEVEL_ATTRIBUTE, sizeString);
    1:         ownerXULDoc->Persist(windowElementId, ZLEVEL_ATTRIBUTE);
    1:       }
    1:     }
    1:   }
    1: 
    1:   mPersistentAttributesDirty = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetWindowDOMWindow(nsIDOMWindowInternal** aDOMWindow)
    1: {
    1:   NS_ENSURE_STATE(mDocShell);
    1: 
    1:   if (!mDOMWindow)
    1:     mDOMWindow = do_GetInterface(mDocShell);
    1:   NS_ENSURE_TRUE(mDOMWindow, NS_ERROR_FAILURE);
    1: 
    1:   *aDOMWindow = mDOMWindow;
    1:   NS_ADDREF(*aDOMWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetWindowDOMElement(nsIDOMElement** aDOMElement)
    1: {
    1:   NS_ENSURE_STATE(mDocShell);
    1:   NS_ENSURE_ARG_POINTER(aDOMElement);
    1: 
    1:   *aDOMElement = nsnull;
    1: 
    1:   nsCOMPtr<nsIContentViewer> cv;
    1: 
    1:   mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:   NS_ENSURE_TRUE(cv, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(cv));
    1:   NS_ENSURE_TRUE(docv, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocument> doc;
    1:   docv->GetDocument(getter_AddRefs(doc));
    1:   nsCOMPtr<nsIDOMDocument> domdoc(do_QueryInterface(doc));
    1:   NS_ENSURE_TRUE(domdoc, NS_ERROR_FAILURE);
    1: 
    1:   domdoc->GetDocumentElement(aDOMElement);
    1:   NS_ENSURE_TRUE(*aDOMElement, NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetDOMElementById(char* aID, nsIDOMElement** aDOMElement)
    1: {
    1:   NS_ENSURE_STATE(mDocShell);
    1:   NS_ENSURE_ARG_POINTER(aDOMElement);
    1: 
    1:   *aDOMElement = nsnull;
    1: 
    1:   nsCOMPtr<nsIContentViewer> cv;
    1: 
    1:   mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:   if (!cv)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(cv));
    1:   if (!docv)   
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDocument> doc;
    1:   docv->GetDocument(getter_AddRefs(doc));
    1:   nsCOMPtr<nsIDOMDocument> domdoc(do_QueryInterface(doc));
    1:   if (!domdoc) 
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ENSURE_SUCCESS(domdoc->GetElementById(NS_ConvertASCIItoUTF16(aID), aDOMElement), NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsXULWindow::ContentShellAdded(nsIDocShellTreeItem* aContentShell,
    1:    PRBool aPrimary, PRBool aTargetable, const nsAString& aID)
    1: {
    1:   nsContentShellInfo* shellInfo = nsnull;
    1: 
25835:   PRUint32 i, count = mContentShells.Length();
    1:   nsWeakPtr contentShellWeak = do_GetWeakReference(aContentShell);
    1:   for (i = 0; i < count; i++) {
25835:     nsContentShellInfo* info = mContentShells.ElementAt(i);
    1:     if (info->id.Equals(aID)) {
    1:       // We already exist. Do a replace.
    1:       info->child = contentShellWeak;
    1:       shellInfo = info;
    1:     }
    1:     else if (info->child == contentShellWeak)
    1:       info->child = nsnull;
    1:   }
    1: 
    1:   if (!shellInfo) {
    1:     shellInfo = new nsContentShellInfo(aID, contentShellWeak);
25835:     mContentShells.AppendElement(shellInfo);
    1:   }
    1:     
    1:   // Set the default content tree owner
    1:   if (aPrimary) {
    1:     NS_ENSURE_SUCCESS(EnsurePrimaryContentTreeOwner(), NS_ERROR_FAILURE);
    1:     aContentShell->SetTreeOwner(mPrimaryContentTreeOwner);
    1:     mPrimaryContentShell = aContentShell;
    1:   }
    1:   else {
    1:     NS_ENSURE_SUCCESS(EnsureContentTreeOwner(), NS_ERROR_FAILURE);
    1:     aContentShell->SetTreeOwner(mContentTreeOwner);
    1:     if (mPrimaryContentShell == aContentShell)
    1:       mPrimaryContentShell = nsnull;
    1:   }
    1: 
    1:   if (aTargetable) {
    1: #ifdef DEBUG
    1:     PRInt32 debugCount = mTargetableShells.Count();
    1:     PRInt32 debugCounter;
    1:     for (debugCounter = debugCount - 1; debugCounter >= 0; --debugCounter) {
    1:       nsCOMPtr<nsIDocShellTreeItem> curItem =
    1:         do_QueryReferent(mTargetableShells[debugCounter]);
    1:       NS_ASSERTION(!SameCOMIdentity(curItem, aContentShell),
    1:                    "Adding already existing item to mTargetableShells");
    1:     }
    1: #endif
    1:     
 9070:     // put the new shell at the start of the targetable shells list if either
 9070:     // it's the new primary shell or there is no existing primary shell (which
 9070:     // means that chances are this one just stopped being primary).  If we
 9070:     // really cared, we could keep track of the "last no longer primary shell"
 9070:     // explicitly, but it probably doesn't matter enough: the difference would
 9070:     // only be felt in a situation where all shells were non-primary, which
 9070:     // doesn't happen much.  In a situation where there is one and only one
 9070:     // primary shell, and in which shells get unmarked as primary before some
 9070:     // other shell gets marked as primary, this effectively stores the list of
 9070:     // targetable shells in "most recently primary first" order.
 9070:     PRBool inserted;
 9070:     if (aPrimary || !mPrimaryContentShell) {
 9070:       inserted = mTargetableShells.InsertObjectAt(contentShellWeak, 0);
 9070:     } else {
 9070:       inserted = mTargetableShells.AppendObject(contentShellWeak);
 9070:     }
 9070:     NS_ENSURE_TRUE(inserted, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsXULWindow::ContentShellRemoved(nsIDocShellTreeItem* aContentShell)
    1: {
    1:   if (mPrimaryContentShell == aContentShell) {
    1:     mPrimaryContentShell = nsnull;
    1:   }
    1: 
25835:   PRInt32 i, count = mContentShells.Length();
    1:   for (i = count - 1; i >= 0; --i) {
25835:     nsContentShellInfo* info = mContentShells.ElementAt(i);
    1:     nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryReferent(info->child);
    1:     if (!curItem || SameCOMIdentity(curItem, aContentShell)) {
    1:       mContentShells.RemoveElementAt(i);
    1:       delete info;
    1:     }
    1:   }
    1: 
    1:   count = mTargetableShells.Count();
    1:   for (i = count - 1; i >= 0; --i) {
    1:     nsCOMPtr<nsIDocShellTreeItem> curItem =
    1:       do_QueryReferent(mTargetableShells[i]);
    1:     if (!curItem || SameCOMIdentity(curItem, aContentShell)) {
    1:       mTargetableShells.RemoveObjectAt(i);
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SizeShellTo(nsIDocShellTreeItem* aShellItem,
    1:    PRInt32 aCX, PRInt32 aCY)
    1: {
    1:   // XXXTAB This is wrong, we should actually reflow based on the passed in
    1:   // shell.  For now we are hacking and doing delta sizing.  This is bad
    1:   // because it assumes all size we add will go to the shell which probably
    1:   // won't happen.
    1: 
    1:   nsCOMPtr<nsIBaseWindow> shellAsWin(do_QueryInterface(aShellItem));
    1:   NS_ENSURE_TRUE(shellAsWin, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 width = 0;
    1:   PRInt32 height = 0;
    1:   shellAsWin->GetSize(&width, &height);
    1: 
    1:   PRInt32 widthDelta = aCX - width;
    1:   PRInt32 heightDelta = aCY - height;
    1: 
    1:   if (widthDelta || heightDelta) {
    1:     PRInt32 winCX = 0;
    1:     PRInt32 winCY = 0;
    1: 
    1:     GetSize(&winCX, &winCY);
23309:     // There's no point in trying to make the window smaller than the
23309:     // desired docshell size --- that's not likely to work. This whole
23309:     // function assumes that the outer docshell is adding some constant
23309:     // "border" chrome to aShellItem.
23309:     winCX = PR_MAX(winCX + widthDelta, aCX);
23309:     winCY = PR_MAX(winCY + heightDelta, aCY);
23309:     SetSize(winCX, winCY, PR_TRUE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::ExitModalLoop(nsresult aStatus)
    1: {
    1:   if (mContinueModalLoop)
    1:     EnableParent(PR_TRUE);
    1:   mContinueModalLoop = PR_FALSE;
    1:   mModalStatus = aStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: // top-level function to create a new window
    1: NS_IMETHODIMP nsXULWindow::CreateNewWindow(PRInt32 aChromeFlags,
    1:                              nsIAppShell* aAppShell, nsIXULWindow **_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:   if (aChromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME)
    1:     return CreateNewChromeWindow(aChromeFlags, aAppShell, _retval);
    1:   return CreateNewContentWindow(aChromeFlags, aAppShell, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::CreateNewChromeWindow(PRInt32 aChromeFlags,
    1:    nsIAppShell* aAppShell, nsIXULWindow **_retval)
    1: {
    1:   NS_TIMELINE_ENTER("nsXULWindow::CreateNewChromeWindow");
    1:   nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
    1:   NS_ENSURE_TRUE(appShell, NS_ERROR_FAILURE);
    1: 
    1:   // Just do a normal create of a window and return.
    1:   //XXXTAB remove this when appshell talks in terms of nsIXULWindow
    1:   nsCOMPtr<nsIXULWindow> parent;
    1:   if (aChromeFlags & nsIWebBrowserChrome::CHROME_DEPENDENT)
    1:     parent = this;
    1: 
    1:   nsCOMPtr<nsIXULWindow> newWindow;
    1:   appShell->CreateTopLevelWindow(parent, nsnull, aChromeFlags,
    1:                                  nsIAppShellService::SIZE_TO_CONTENT,
    1:                                  nsIAppShellService::SIZE_TO_CONTENT,
    1:                                  aAppShell, getter_AddRefs(newWindow));
    1: 
    1:   NS_ENSURE_TRUE(newWindow, NS_ERROR_FAILURE);
    1: 
    1:   newWindow->SetChromeFlags(aChromeFlags);
    1: 
    1:   *_retval = newWindow;
    1:   NS_ADDREF(*_retval);
    1: 
    1:   NS_TIMELINE_LEAVE("nsXULWindow::CreateNewChromeWindow done");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::CreateNewContentWindow(PRInt32 aChromeFlags,
    1:    nsIAppShell* aAppShell, nsIXULWindow **_retval)
    1: {
    1:   NS_TIMELINE_ENTER("nsXULWindow::CreateNewContentWindow");
    1: 
    1:   nsCOMPtr<nsIAppShellService> appShell(do_GetService(NS_APPSHELLSERVICE_CONTRACTID));
    1:   NS_ENSURE_TRUE(appShell, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIXULWindow> parent;
    1:   if (aChromeFlags & nsIWebBrowserChrome::CHROME_DEPENDENT)
    1:     parent = this;
    1: 
    1:   // We need to create a new top level window and then enter a nested
    1:   // loop. Eventually the new window will be told that it has loaded,
    1:   // at which time we know it is safe to spin out of the nested loop
    1:   // and allow the opening code to proceed.
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   if (prefs) {
    1:     nsXPIDLCString urlStr;
    1:     nsresult prefres;
    1:     prefres = prefs->GetCharPref("browser.chromeURL", getter_Copies(urlStr));
    1:     if (NS_SUCCEEDED(prefres) && urlStr.IsEmpty())
    1:       prefres = NS_ERROR_FAILURE;
    1:     if (NS_FAILED(prefres))
    1:       urlStr.AssignLiteral("chrome://navigator/content/navigator.xul");
    1: 
    1:     nsCOMPtr<nsIIOService> service(do_GetService(NS_IOSERVICE_CONTRACTID));
    1:     if (service)
    1:       service->NewURI(urlStr, nsnull, nsnull, getter_AddRefs(uri));
    1:   }
    1:   NS_ENSURE_TRUE(uri, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIXULWindow> newWindow;
    1:   appShell->CreateTopLevelWindow(parent, uri,
    1:                                 aChromeFlags, 615, 480, aAppShell,
    1:                                 getter_AddRefs(newWindow));
    1: 
    1:   NS_ENSURE_TRUE(newWindow, NS_ERROR_FAILURE);
    1: 
    1:   newWindow->SetChromeFlags(aChromeFlags);
    1: 
    1:   // Specify that we want the window to remain locked until the chrome has loaded.
 3233:   nsXULWindow *xulWin = static_cast<nsXULWindow*>
 3233:                                    (static_cast<nsIXULWindow*>
 3233:                                                (newWindow));
    1: 
    1:   xulWin->LockUntilChromeLoad();
    1: 
    1:   // Push nsnull onto the JSContext stack before we dispatch a native event.
    1:   nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
    1:   if (stack && NS_SUCCEEDED(stack->Push(nsnull))) {
    1:     nsIThread *thread = NS_GetCurrentThread();
    1:     while (xulWin->IsLocked()) {
    1:       if (!NS_ProcessNextEvent(thread))
    1:         break;
    1:     }
    1:     JSContext *cx;
    1:     stack->Pop(&cx);
    1:     NS_ASSERTION(cx == nsnull, "JSContextStack mismatch");
    1:   }
    1: 
    1:   *_retval = newWindow;
    1:   NS_ADDREF(*_retval);
    1: 
    1:   NS_TIMELINE_LEAVE("nsXULWindow::CreateNewContentWindow");
    1:   return NS_OK;
    1: }
    1: 
    1: void nsXULWindow::EnableParent(PRBool aEnable)
    1: {
    1:   nsCOMPtr<nsIBaseWindow> parentWindow;
    1:   nsCOMPtr<nsIWidget>     parentWidget;
    1: 
    1:   parentWindow = do_QueryReferent(mParentWindow);
    1:   if (parentWindow)
    1:     parentWindow->GetMainWidget(getter_AddRefs(parentWidget));
    1:   if (parentWidget)
    1:     parentWidget->Enable(aEnable);
    1: }
    1: 
    1: // Constrain the window to its proper z-level
23391: PRBool nsXULWindow::ConstrainToZLevel(PRBool      aImmediate,
    1:                                       nsWindowZ  *aPlacement,
    1:                                       nsIWidget  *aReqBelow,
23391:                                       nsIWidget **aActualBelow)
23391: {
    1: #if 0
    1:   /* Do we have a parent window? This means our z-order is already constrained,
    1:      since we're a dependent window. Our window list isn't hierarchical,
    1:      so we can't properly calculate placement for such a window.
    1:      Should we just abort? */
    1:   nsCOMPtr<nsIBaseWindow> parentWindow = do_QueryReferent(mParentWindow);
    1:   if (parentWindow)
    1:     return PR_FALSE;
    1: #endif
    1: 
 5691:   nsCOMPtr<nsIWindowMediator> mediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (!mediator)
    1:     return PR_FALSE;
    1: 
    1:   PRBool         altered;
    1:   PRUint32       position,
    1:                  newPosition,
    1:                  zLevel;
    1:   nsIXULWindow  *us = this;
    1: 
    1:   altered = PR_FALSE;
    1:   mediator->GetZLevel(this, &zLevel);
    1: 
    1:   // translate from nsGUIEvent to nsIWindowMediator constants
    1:   position = nsIWindowMediator::zLevelTop;
    1:   if (*aPlacement == nsWindowZBottom || zLevel == nsIXULWindow::lowestZ)
    1:     position = nsIWindowMediator::zLevelBottom;
    1:   else if (*aPlacement == nsWindowZRelative)
    1:     position = nsIWindowMediator::zLevelBelow;
    1: 
    1:   if (NS_SUCCEEDED(mediator->CalculateZPosition(us, position, aReqBelow,
    1:                                &newPosition, aActualBelow, &altered))) {
    1:     /* If we were asked to move to the top but constrained to remain
    1:        below one of our other windows, first move all windows in that
    1:        window's layer and above to the top. This allows the user to
    1:        click a window which can't be topmost and still bring mozilla
    1:        to the foreground. */
    1:     if (altered &&
    1:         (position == nsIWindowMediator::zLevelTop ||
24816:          (position == nsIWindowMediator::zLevelBelow && aReqBelow == 0)))
    1:       PlaceWindowLayersBehind(zLevel + 1, nsIXULWindow::highestZ, 0);
    1: 
    1:     if (*aPlacement != nsWindowZBottom &&
    1:         position == nsIWindowMediator::zLevelBottom)
    1:       altered = PR_TRUE;
    1:     if (altered || aImmediate) {
    1:       if (newPosition == nsIWindowMediator::zLevelTop)
    1:         *aPlacement = nsWindowZTop;
    1:       else if (newPosition == nsIWindowMediator::zLevelBottom)
    1:         *aPlacement = nsWindowZBottom;
    1:       else
    1:         *aPlacement = nsWindowZRelative;
    1: 
    1:       if (aImmediate) {
 3233:         nsCOMPtr<nsIBaseWindow> ourBase = do_QueryInterface(static_cast<nsIXULWindow *>(this));
    1:         if (ourBase) {
    1:           nsCOMPtr<nsIWidget> ourWidget;
    1:           ourBase->GetMainWidget(getter_AddRefs(ourWidget));
    1:           ourWidget->PlaceBehind(*aPlacement == nsWindowZBottom ?
    1:                                    eZPlacementBottom : eZPlacementBelow,
    1:                                  *aActualBelow, PR_FALSE);
    1:         }
    1:       }
    1:     }
    1: 
23391:     /* CalculateZPosition can tell us to be below nothing, because it tries
    1:        not to change something it doesn't recognize. A request to verify
    1:        being below an unrecognized window, then, is treated as a request
    1:        to come to the top (below null) */
    1:     nsCOMPtr<nsIXULWindow> windowAbove;
    1:     if (newPosition == nsIWindowMediator::zLevelBelow && *aActualBelow) {
    1:       void *data;
    1:       (*aActualBelow)->GetClientData(data);
    1:       if (data) {
 3233:         windowAbove = reinterpret_cast<nsWebShellWindow*>(data);
    1:       }
    1:     }
    1: 
    1:     mediator->SetZPosition(us, newPosition, windowAbove);
    1:   }
    1: 
    1:   return altered;
    1: }
    1: 
    1: /* Re-z-position all windows in the layers from aLowLevel to aHighLevel,
    1:    inclusive, to be behind aBehind. aBehind of null means on top.
    1:    Note this method actually does nothing to our relative window positions.
    1:    (And therefore there's no need to inform WindowMediator we're moving
    1:    things, because we aren't.) This method is useful for, say, moving
    1:    a range of layers of our own windows relative to windows belonging to
    1:    external applications.
    1: */
    1: void nsXULWindow::PlaceWindowLayersBehind(PRUint32 aLowLevel,
    1:                                           PRUint32 aHighLevel,
23391:                                           nsIXULWindow *aBehind)
23391: {
    1:   // step through windows in z-order from top to bottommost window
    1: 
 5691:   nsCOMPtr<nsIWindowMediator> mediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1:   if (!mediator)
    1:     return;
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
    1:   mediator->GetZOrderXULWindowEnumerator(0, PR_TRUE,
    1:               getter_AddRefs(windowEnumerator));
    1:   if (!windowEnumerator)
    1:     return;
    1: 
    1:   // each window will be moved behind previousHighWidget, itself
    1:   // a moving target. initialize it.
    1:   nsCOMPtr<nsIWidget> previousHighWidget;
    1:   if (aBehind) {
    1:     nsCOMPtr<nsIBaseWindow> highBase(do_QueryInterface(aBehind));
    1:     if (highBase)
    1:       highBase->GetMainWidget(getter_AddRefs(previousHighWidget));
    1:   }
    1: 
    1:   // get next lower window
    1:   PRBool more;
    1:   while (windowEnumerator->HasMoreElements(&more), more) {
    1:     PRUint32 nextZ; // z-level of nextWindow
    1:     nsCOMPtr<nsISupports> nextWindow;
    1:     windowEnumerator->GetNext(getter_AddRefs(nextWindow));
    1:     nsCOMPtr<nsIXULWindow> nextXULWindow(do_QueryInterface(nextWindow));
    1:     nextXULWindow->GetZLevel(&nextZ);
    1:     if (nextZ < aLowLevel)
    1:       break; // we've processed all windows through aLowLevel
    1:     
    1:     // move it just below its next higher window
    1:     nsCOMPtr<nsIBaseWindow> nextBase(do_QueryInterface(nextXULWindow));
    1:     if (nextBase) {
    1:       nsCOMPtr<nsIWidget> nextWidget;
    1:       nextBase->GetMainWidget(getter_AddRefs(nextWidget));
    1:       if (nextZ <= aHighLevel)
    1:         nextWidget->PlaceBehind(eZPlacementBelow, previousHighWidget, PR_FALSE);
    1:       previousHighWidget = nextWidget;
    1:     }
    1:   }
    1: }
    1: 
    1: void nsXULWindow::SetContentScrollbarVisibility(PRBool aVisible)
    1: {
    1:   nsCOMPtr<nsIDOMWindow> contentWin(do_GetInterface(mPrimaryContentShell));
    1:   if (contentWin) {
    1:     nsCOMPtr<nsIDOMBarProp> scrollbars;
    1:     contentWin->GetScrollbars(getter_AddRefs(scrollbars));
    1:     if (scrollbars)
    1:       scrollbars->SetVisible(aVisible);
    1:   }
    1: }
    1: 
    1: PRBool nsXULWindow::GetContentScrollbarVisibility()
    1: {
 7837:   // This code already exists in dom/src/base/nsBarProp.cpp, but we
 7837:   // can't safely get to that from here as this function is called
 7837:   // while the DOM window is being set up, and we need the DOM window
 7837:   // to get to that code.
 7837:   nsCOMPtr<nsIScrollable> scroller(do_QueryInterface(mPrimaryContentShell));
    1: 
 7837:   if (scroller) {
 7837:     PRInt32 prefValue;
 7837:     scroller->GetDefaultScrollbarPreferences(
 7837:                   nsIScrollable::ScrollOrientation_Y, &prefValue);
 7837:     if (prefValue == nsIScrollable::Scrollbar_Never) // try the other way
 7837:       scroller->GetDefaultScrollbarPreferences(
 7837:                   nsIScrollable::ScrollOrientation_X, &prefValue);
 7837: 
 7837:     if (prefValue == nsIScrollable::Scrollbar_Never)
 7837:       return PR_FALSE;
    1:   }
 7837: 
 7837:   return PR_TRUE;
    1: }
    1: 
    1: // during spinup, attributes that haven't been loaded yet can't be dirty
    1: void nsXULWindow::PersistentAttributesDirty(PRUint32 aDirtyFlags)
    1: {
    1:   mPersistentAttributesDirty |= aDirtyFlags & mPersistentAttributesMask;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::ApplyChromeFlags()
    1: {
    1:   nsCOMPtr<nsIDOMElement> window;
    1:   GetWindowDOMElement(getter_AddRefs(window));
    1:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
    1: 
    1:   if (mChromeLoaded) {
    1:     // The two calls in this block don't need to happen early because they
    1:     // don't cause a global restyle on the document.  Not only that, but the
    1:     // scrollbar stuff needs a content area to toggle the scrollbars on anyway.
    1:     // So just don't do these until mChromeLoaded is true.
    1:     
    1:     // menubar has its own special treatment
    1:     mWindow->ShowMenuBar(mChromeFlags & nsIWebBrowserChrome::CHROME_MENUBAR ? 
    1:                          PR_TRUE : PR_FALSE);
    1: 
    1:     // Scrollbars have their own special treatment.
    1:     SetContentScrollbarVisibility(mChromeFlags &
    1:                                   nsIWebBrowserChrome::CHROME_SCROLLBARS ?
    1:                                     PR_TRUE : PR_FALSE);
    1:   }
    1: 
    1:   /* the other flags are handled together. we have style rules
    1:      in navigator.css that trigger visibility based on
    1:      the 'chromehidden' attribute of the <window> tag. */
    1:   nsAutoString newvalue;
    1: 
    1:   if (! (mChromeFlags & nsIWebBrowserChrome::CHROME_MENUBAR))
    1:     newvalue.AppendLiteral("menubar ");
    1: 
    1:   if (! (mChromeFlags & nsIWebBrowserChrome::CHROME_TOOLBAR))
    1:     newvalue.AppendLiteral("toolbar ");
    1: 
    1:   if (! (mChromeFlags & nsIWebBrowserChrome::CHROME_LOCATIONBAR))
    1:     newvalue.AppendLiteral("location ");
    1: 
    1:   if (! (mChromeFlags & nsIWebBrowserChrome::CHROME_PERSONAL_TOOLBAR))
    1:     newvalue.AppendLiteral("directories ");
    1: 
    1:   if (! (mChromeFlags & nsIWebBrowserChrome::CHROME_STATUSBAR))
    1:     newvalue.AppendLiteral("status ");
    1: 
    1:   if (! (mChromeFlags & nsIWebBrowserChrome::CHROME_EXTRA))
    1:     newvalue.AppendLiteral("extrachrome ");
    1: 
    1:   // Note that if we're not actually changing the value this will be a no-op,
    1:   // so no need to compare to the old value.
    1:   window->SetAttribute(NS_LITERAL_STRING("chromehidden"), newvalue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::GetXULBrowserWindow(nsIXULBrowserWindow * *aXULBrowserWindow)
    1: {
    1:   NS_IF_ADDREF(*aXULBrowserWindow = mXULBrowserWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXULWindow::SetXULBrowserWindow(nsIXULBrowserWindow * aXULBrowserWindow)
    1: {
    1:   mXULBrowserWindow = aXULBrowserWindow;
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsXULWindow: Accessors
    1: //*****************************************************************************
    1: 
26484: PRInt32 nsXULWindow::AppUnitsPerDevPixel()
26484: {
26484:   if (mWindow && mWindow->GetDeviceContext()) {
26484:     mAppPerDev = mWindow->GetDeviceContext()->AppUnitsPerDevPixel();
26484:   } else {
26484:     NS_ERROR("nsXULWindow::AppUnitsPerDevPixel called with no window "
26484:              "or no dev context");
26484:   }
26484:   return mAppPerDev;
26484: }
26484: 
    1: //*****************************************************************************
    1: //*** nsContentShellInfo: Object Management
    1: //*****************************************************************************   
    1: 
    1: nsContentShellInfo::nsContentShellInfo(const nsAString& aID,
    1:                                        nsIWeakReference* aContentShell)
    1:   : id(aID),
    1:     child(aContentShell)
    1: {
    1:   MOZ_COUNT_CTOR(nsContentShellInfo);
    1: }
    1: 
    1: nsContentShellInfo::~nsContentShellInfo()
    1: {
    1:   MOZ_COUNT_DTOR(nsContentShellInfo);
    1:    //XXX Set Tree Owner to null if the tree owner is nsXULWindow->mContentTreeOwner
    1: } 
