20627: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
20627: /* vim:set ts=2 sw=2 sts=2 et cindent: */
20627: /* ***** BEGIN LICENSE BLOCK *****
39436:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
20627:  *
20627:  * The contents of this file are subject to the Mozilla Public License Version
20627:  * 1.1 (the "License"); you may not use this file except in compliance with
20627:  * the License. You may obtain a copy of the License at
20627:  * http://www.mozilla.org/MPL/
20627:  *
20627:  * Software distributed under the License is distributed on an "AS IS" basis,
20627:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
20627:  * for the specific language governing rights and limitations under the
20627:  * License.
20627:  *
20627:  * The Original Code is Mozilla code.
20627:  *
20627:  * The Initial Developer of the Original Code is the Mozilla Corporation.
20627:  * Portions created by the Initial Developer are Copyright (C) 2007
20627:  * the Initial Developer. All Rights Reserved.
20627:  *
20627:  * Contributor(s):
20627:  *  Chris Double <chris.double@double.co.nz>
20627:  *
20627:  * Alternatively, the contents of this file may be used under the terms of
20627:  * either the GNU General Public License Version 2 or later (the "GPL"), or
20627:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
20627:  * in which case the provisions of the GPL or the LGPL are applicable instead
20627:  * of those above. If you wish to allow use of your version of this file only
20627:  * under the terms of either the GPL or the LGPL, and not to allow others to
20627:  * use your version of this file under the terms of the MPL, indicate your
20627:  * decision by deleting the provisions above and replace them with the notice
20627:  * and other provisions required by the GPL or the LGPL. If you do not delete
20627:  * the provisions above, a recipient may use your version of this file under
20627:  * the terms of any one of the MPL, the GPL or the LGPL.
20627:  *
20627:  * ***** END LICENSE BLOCK ***** */
33372: 
33372: #include "nsMediaDecoder.h"
48905: #include "nsMediaStream.h"
33372: 
20627: #include "prlog.h"
20627: #include "prmem.h"
20627: #include "nsIFrame.h"
20627: #include "nsIDocument.h"
20627: #include "nsThreadUtils.h"
20627: #include "nsIDOMHTMLMediaElement.h"
20627: #include "nsNetUtil.h"
20627: #include "nsHTMLMediaElement.h"
20627: #include "gfxContext.h"
20627: #include "nsPresContext.h"
24155: #include "nsDOMError.h"
47740: #include "nsDisplayList.h"
50430: #include "nsSVGEffects.h"
74548: #include "VideoUtils.h"
20627: 
64576: using namespace mozilla;
64576: 
23763: // Number of milliseconds between progress events as defined by spec
78286: static const PRUint32 PROGRESS_MS = 350;
23763: 
23763: // Number of milliseconds of no data before a stall event is fired as defined by spec
78286: static const PRUint32 STALL_MS = 3000;
23763: 
53827: // Number of estimated seconds worth of data we need to have buffered 
53827: // ahead of the current playback position before we allow the media decoder
53827: // to report that it can play through the entire media without the decode
53827: // catching up with the download. Having this margin make the
53827: // nsMediaDecoder::CanPlayThrough() calculation more stable in the case of
53827: // fluctuating bitrates.
78286: static const PRInt64 CAN_PLAY_THROUGH_MARGIN = 10;
53827: 
20627: nsMediaDecoder::nsMediaDecoder() :
78689:   mElement(nsnull),
20627:   mRGBWidth(-1),
20627:   mRGBHeight(-1),
64576:   mVideoUpdateLock("nsMediaDecoder.mVideoUpdateLock"),
51477:   mFrameBufferLength(0),
48905:   mPinnedForSeek(PR_FALSE),
26944:   mSizeChanged(PR_FALSE),
62745:   mImageContainerSizeChanged(PR_FALSE),
28622:   mShuttingDown(PR_FALSE)
20627: {
20627:   MOZ_COUNT_CTOR(nsMediaDecoder);
74548:   MediaMemoryReporter::AddMediaDecoder(this);
20627: }
20627: 
20627: nsMediaDecoder::~nsMediaDecoder()
20627: {
20627:   MOZ_COUNT_DTOR(nsMediaDecoder);
74548:   MediaMemoryReporter::RemoveMediaDecoder(this);
20627: }
20627: 
23851: PRBool nsMediaDecoder::Init(nsHTMLMediaElement* aElement)
20627: {
23851:   mElement = aElement;
64576:   return PR_TRUE;
20627: }
20627: 
20627: void nsMediaDecoder::Shutdown()
20627: {
20627:   StopProgress();
23851:   mElement = nsnull;
20627: }
20627: 
24155: nsHTMLMediaElement* nsMediaDecoder::GetMediaElement()
24155: {
24155:   return mElement;
24155: }
20627: 
51477: nsresult nsMediaDecoder::RequestFrameBufferLength(PRUint32 aLength)
51477: {
51477:   if (aLength < FRAMEBUFFER_LENGTH_MIN || aLength > FRAMEBUFFER_LENGTH_MAX) {
51477:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
51477:   }
51477: 
51477:   mFrameBufferLength = aLength;
51477:   return NS_OK;
51477: }
51477: 
20627: void nsMediaDecoder::Invalidate()
20627: {
20627:   if (!mElement)
20627:     return;
20627: 
20627:   nsIFrame* frame = mElement->GetPrimaryFrame();
62745:   PRBool invalidateFrame = PR_FALSE;
20627: 
20627:   {
64576:     MutexAutoLock lock(mVideoUpdateLock);
62745: 
62745:     // Get mImageContainerSizeChanged while holding the lock.
62745:     invalidateFrame = mImageContainerSizeChanged;
62745:     mImageContainerSizeChanged = PR_FALSE;
62745: 
20627:     if (mSizeChanged) {
72348:       mElement->UpdateMediaSize(nsIntSize(mRGBWidth, mRGBHeight));
72348:       mSizeChanged = PR_FALSE;
28572: 
23851:       if (frame) {
20627:         nsPresContext* presContext = frame->PresContext();
20627:         nsIPresShell *presShell = presContext->PresShell();
20627:         presShell->FrameNeedsReflow(frame,
20627:                                     nsIPresShell::eStyleChange,
20627:                                     NS_FRAME_IS_DIRTY);
20627:       }
20627:     }
23851:   }
23851: 
23851:   if (frame) {
47740:     nsRect contentRect = frame->GetContentRect() - frame->GetPosition();
62745:     if (invalidateFrame) {
62745:       frame->Invalidate(contentRect);
62745:     } else {
47740:       frame->InvalidateLayer(contentRect, nsDisplayItem::TYPE_VIDEO);
20627:     }
62745:   }
50430: 
50430:   nsSVGEffects::InvalidateDirectRenderingObservers(mElement);
23851: }
20627: 
20627: static void ProgressCallback(nsITimer* aTimer, void* aClosure)
20627: {
20627:   nsMediaDecoder* decoder = static_cast<nsMediaDecoder*>(aClosure);
23763:   decoder->Progress(PR_TRUE);
20627: }
20627: 
23763: void nsMediaDecoder::Progress(PRBool aTimer)
20627: {
23400:   if (!mElement)
20627:     return;
20627: 
27222:   TimeStamp now = TimeStamp::Now();
25852: 
25852:   if (!aTimer) {
25852:     mDataTime = now;
25852:   }
25852: 
25852:   // If PROGRESS_MS has passed since the last progress event fired and more
25852:   // data has arrived since then, fire another progress event.
27222:   if ((mProgressTime.IsNull() ||
27222:        now - mProgressTime >= TimeDuration::FromMilliseconds(PROGRESS_MS)) &&
27222:       !mDataTime.IsNull() &&
27222:       now - mDataTime <= TimeDuration::FromMilliseconds(PROGRESS_MS)) {
53767:     mElement->DispatchAsyncEvent(NS_LITERAL_STRING("progress"));
23763:     mProgressTime = now;
23763:   }
23763: 
27222:   if (!mDataTime.IsNull() &&
27222:       now - mDataTime >= TimeDuration::FromMilliseconds(STALL_MS)) {
28488:     mElement->DownloadStalled();
27222:     // Null it out
27222:     mDataTime = TimeStamp();
23763:   }
20627: }
20627: 
20627: nsresult nsMediaDecoder::StartProgress()
20627: {
23763:   if (mProgressTimer)
23763:     return NS_OK;
22408: 
20627:   mProgressTimer = do_CreateInstance("@mozilla.org/timer;1");
23763:   return mProgressTimer->InitWithFuncCallback(ProgressCallback,
20627:                                               this,
23763:                                               PROGRESS_MS,
23763:                                               nsITimer::TYPE_REPEATING_SLACK);
22910: }
20627: 
20627: nsresult nsMediaDecoder::StopProgress()
20627: {
23763:   if (!mProgressTimer)
23763:     return NS_OK;
23763: 
23763:   nsresult rv = mProgressTimer->Cancel();
20627:   mProgressTimer = nsnull;
23763: 
20627:   return rv;
20627: }
20627: 
53770: void nsMediaDecoder::FireTimeUpdate()
53770: {
53770:   if (!mElement)
53770:     return;
58179:   mElement->FireTimeUpdate(PR_TRUE);
53770: }
53770: 
39499: void nsMediaDecoder::SetVideoData(const gfxIntSize& aSize,
63612:                                   Image* aImage,
63612:                                   TimeStamp aTarget)
20627: {
64576:   MutexAutoLock lock(mVideoUpdateLock);
26338: 
72348:   if (mRGBWidth != aSize.width || mRGBHeight != aSize.height) {
39499:     mRGBWidth = aSize.width;
39499:     mRGBHeight = aSize.height;
20627:     mSizeChanged = PR_TRUE;
20627:   }
39499:   if (mImageContainer && aImage) {
62745:     gfxIntSize oldFrameSize = mImageContainer->GetCurrentSize();
63612: 
63612:     TimeStamp paintTime = mImageContainer->GetPaintTime();
63612:     if (!paintTime.IsNull() && !mPaintTarget.IsNull()) {
63612:       mPaintDelay = paintTime - mPaintTarget;
63612:     }
63612: 
39499:     mImageContainer->SetCurrentImage(aImage);
62745:     gfxIntSize newFrameSize = mImageContainer->GetCurrentSize();
62745:     if (oldFrameSize != newFrameSize) {
62745:       mImageContainerSizeChanged = PR_TRUE;
62745:     }
20627:   }
63612: 
63612:   mPaintTarget = aTarget;
63612: }
63612: 
63612: double nsMediaDecoder::GetFrameDelay()
63612: {
64576:   MutexAutoLock lock(mVideoUpdateLock);
63612:   return mPaintDelay.ToSeconds();
26337: }
48104: 
48905: void nsMediaDecoder::PinForSeek()
48905: {
48905:   nsMediaStream* stream = GetCurrentStream();
48905:   if (!stream || mPinnedForSeek) {
48905:     return;
48905:   }
48905:   mPinnedForSeek = PR_TRUE;
48905:   stream->Pin();
48905: }
48905: 
48905: void nsMediaDecoder::UnpinForSeek()
48905: {
48905:   nsMediaStream* stream = GetCurrentStream();
48905:   if (!stream || !mPinnedForSeek) {
48905:     return;
48905:   }
48905:   mPinnedForSeek = PR_FALSE;
48905:   stream->Unpin();
48905: }
48905: 
48104: PRBool nsMediaDecoder::CanPlayThrough()
48104: {
48104:   Statistics stats = GetStatistics();
48104:   if (!stats.mDownloadRateReliable || !stats.mPlaybackRateReliable) {
48104:     return PR_FALSE;
48104:   }
48104:   PRInt64 bytesToDownload = stats.mTotalBytes - stats.mDownloadPosition;
48104:   PRInt64 bytesToPlayback = stats.mTotalBytes - stats.mPlaybackPosition;
62886:   double timeToDownload = bytesToDownload / stats.mDownloadRate;
48104:   double timeToPlay = bytesToPlayback / stats.mPlaybackRate;
53827: 
53827:   if (timeToDownload > timeToPlay) {
53827:     // Estimated time to download is greater than the estimated time to play.
53827:     // We probably can't play through without having to stop to buffer.
53827:     return PR_FALSE;
48104:   }
53827: 
53827:   // Estimated time to download is less than the estimated time to play.
53827:   // We can probably play through without having to buffer, but ensure that
53827:   // we've got a reasonable amount of data buffered after the current
53827:   // playback position, so that if the bitrate of the media fluctuates, or if
53827:   // our download rate or decode rate estimation is otherwise inaccurate,
53827:   // we don't suddenly discover that we need to buffer. This is particularly
53827:   // required near the start of the media, when not much data is downloaded.
63624:   PRInt64 readAheadMargin =
63624:     static_cast<PRInt64>(stats.mPlaybackRate * CAN_PLAY_THROUGH_MARGIN);
53827:   return stats.mTotalBytes == stats.mDownloadPosition ||
53827:          stats.mDownloadPosition > stats.mPlaybackPosition + readAheadMargin;
53827: }
74548: 
74548: namespace mozilla {
74548: 
74548: MediaMemoryReporter* MediaMemoryReporter::sUniqueInstance;
74548: 
74548: NS_MEMORY_REPORTER_IMPLEMENT(MediaDecodedVideoMemory,
74548:                              "explicit/media/decoded-video",
74548:                              KIND_HEAP,
74548:                              UNITS_BYTES,
74548:                              MediaMemoryReporter::GetDecodedVideoMemory,
74548:                              "Memory used by decoded video frames.")
74548: 
74548: NS_MEMORY_REPORTER_IMPLEMENT(MediaDecodedAudioMemory,
74548:                              "explicit/media/decoded-audio",
74548:                              KIND_HEAP,
74548:                              UNITS_BYTES,
74548:                              MediaMemoryReporter::GetDecodedAudioMemory,
74548:                              "Memory used by decoded audio chunks.")
74548: 
74548: MediaMemoryReporter::MediaMemoryReporter()
74548:   : mMediaDecodedVideoMemory(new NS_MEMORY_REPORTER_NAME(MediaDecodedVideoMemory))
74548:   , mMediaDecodedAudioMemory(new NS_MEMORY_REPORTER_NAME(MediaDecodedAudioMemory))
74548: {
74548:   NS_RegisterMemoryReporter(mMediaDecodedVideoMemory);
74548:   NS_RegisterMemoryReporter(mMediaDecodedAudioMemory);
74548: }
74548: 
74548: MediaMemoryReporter::~MediaMemoryReporter()
74548: {
74548:   NS_UnregisterMemoryReporter(mMediaDecodedVideoMemory);
74548:   NS_UnregisterMemoryReporter(mMediaDecodedAudioMemory);
74548: }
74548: 
74548: } // namespace mozilla
