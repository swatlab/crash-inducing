19014: /* ***** BEGIN LICENSE BLOCK *****
19014:  * 
23574:  * Copyright (c) 2008, Mozilla Corporation
23574:  * All rights reserved.
19014:  * 
23574:  * Redistribution and use in source and binary forms, with or without
23574:  * modification, are permitted provided that the following conditions are met:
19014:  * 
23574:  * * Redistributions of source code must retain the above copyright notice, this
23574:  *   list of conditions and the following disclaimer.
23574:  * * Redistributions in binary form must reproduce the above copyright notice,
23574:  *   this list of conditions and the following disclaimer in the documentation
23574:  *   and/or other materials provided with the distribution.
23574:  * * Neither the name of the Mozilla Corporation nor the names of its
23574:  *   contributors may be used to endorse or promote products derived from this
23574:  *   software without specific prior written permission.
19014:  * 
23574:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
23574:  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
23574:  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
23574:  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
23574:  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
23574:  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
23574:  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
23574:  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
23574:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
23574:  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
19014:  * 
19014:  * Contributor(s):
19014:  *   Dave Townsend <dtownsend@oxymoronical.com>
23574:  *   Josh Aas <josh@mozilla.com>
19014:  * 
19014:  * ***** END LICENSE BLOCK ***** */
19014: 
23574: #include "nptest.h"
23574: #include "nptest_utils.h"
23574: #include "nptest_platform.h"
19014: 
57662: #include "mozilla/IntentionalCrash.h"
57662: 
23574: #include <stdlib.h>
23574: #include <string.h>
23653: #include <stdio.h>
32918: #include <iostream>
32918: #include <string>
32918: #include <sstream>
62174: #include <list>
19014: 
36169: #ifdef XP_WIN
36169: #include <process.h>
37101: #include <float.h>
37857: #include <windows.h>
36169: #define getpid _getpid
36169: #else
36169: #include <unistd.h>
37426: #include <pthread.h>
36169: #endif
36169: 
33639: using namespace std;
33639: 
19014: #define PLUGIN_NAME        "Test Plug-in"
60772: #define PLUGIN_DESCRIPTION "Plug-in for testing purposes.\xE2\x84\xA2 "          \
60772:     "(\xe0\xa4\xb9\xe0\xa4\xbf\xe0\xa4\xa8\xe0\xa5\x8d\xe0\xa4\xa6\xe0\xa5\x80 " \
60772:     "\xe4\xb8\xad\xe6\x96\x87 "                                                  \
60772:     "\xd8\xa7\xd9\x84\xd8\xb9\xd8\xb1\xd8\xa8\xd9\x8a\xd8\xa9)"
19014: #define PLUGIN_VERSION     "1.0.0.0"
19014: 
26942: #define ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))
41053: #define STATIC_ASSERT(condition)                                \
41053:     extern void np_static_assert(int arg[(condition) ? 1 : -1])
26942: 
42621: static char sPluginName[] = PLUGIN_NAME; 
42621: static char sPluginDescription[] = PLUGIN_DESCRIPTION;
42621: static char sPluginVersion[] = PLUGIN_VERSION;
42621: 
23574: //
36611: // Intentional crash
36611: //
36611: 
37560: int gCrashCount = 0;
37560: 
48301: static void Crash()
48301: {
48301:   int *pi = NULL;
48301:   *pi = 55; // Crash dereferencing null pointer
48301:   ++gCrashCount;
48301: }
48301: 
39273: static void
38122: IntentionalCrash()
38122: {
57662:   mozilla::NoteIntentionalCrash("plugin");
48301:   Crash();
36611: }
36611: 
36611: //
23574: // static data
23574: //
23574: 
23574: static NPNetscapeFuncs* sBrowserFuncs = NULL;
23574: static NPClass sNPClass;
23574: 
37426: void
37426: asyncCallback(void* cookie);
36110: 
23574: //
23574: // identifiers
23574: //
23574: 
26802: typedef bool (* ScriptableFunction)
26802:   (NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26802: 
34142: static bool npnEvaluateTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
33631: static bool npnInvokeTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
33771: static bool npnInvokeDefaultTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
27202: static bool setUndefinedValueTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26802: static bool identifierToStringTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
29937: static bool timerTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26802: static bool queryPrivateModeState(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26802: static bool lastReportedPrivateModeState(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26802: static bool hasWidget(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26942: static bool getEdge(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26942: static bool getClipRegionRectCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
26942: static bool getClipRegionRectEdge(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
28108: static bool startWatchingInstanceCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
28108: static bool getInstanceCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
28108: static bool stopWatchingInstanceCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
31130: static bool getLastMouseX(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
31130: static bool getLastMouseY(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
34501: static bool getPaintCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
36907: static bool getWidthAtLastPaint(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
47770: static bool setInvalidateDuringPaint(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
33296: static bool getError(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
33358: static bool doInternalConsistencyCheck(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
33861: static bool setColor(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
34018: static bool throwExceptionNextInvoke(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
34693: static bool convertPointX(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
34693: static bool convertPointY(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
36110: static bool streamTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
36163: static bool crashPlugin(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
36611: static bool crashOnDestroy(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
36929: static bool getObjectValue(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
36929: static bool checkObjectValue(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
37101: static bool enableFPExceptions(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
37325: static bool setCookie(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
37325: static bool getCookie(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
37391: static bool getAuthInfo(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
37426: static bool asyncCallbackTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
37857: static bool checkGCRace(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
38122: static bool hangPlugin(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
38686: static bool getClipboardText(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
39210: static bool callOnDestroy(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
39855: static bool reinitWidget(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
41053: static bool crashPluginInNestedLoop(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
57139: static bool destroySharedGfxStuff(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
40566: static bool propertyAndMethod(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
41061: static bool getTopLevelWindowActivationState(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
41061: static bool getTopLevelWindowActivationEventCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
41321: static bool getFocusState(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
41321: static bool getFocusEventCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
41061: static bool getEventModel(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
42020: static bool getReflector(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
57226: static bool isVisible(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
57514: static bool getWindowPosition(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
57515: static bool constructObject(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
62174: static bool setSitesWithData(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
62174: static bool setSitesWithDataCapabilities(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
23574: 
26942: static const NPUTF8* sPluginMethodIdentifierNames[] = {
34142:   "npnEvaluateTest",
33631:   "npnInvokeTest",
33771:   "npnInvokeDefaultTest",
27202:   "setUndefinedValueTest",
23574:   "identifierToStringTest",
29937:   "timerTest",
24475:   "queryPrivateModeState",
24475:   "lastReportedPrivateModeState",
26802:   "hasWidget",
26942:   "getEdge",
26942:   "getClipRegionRectCount",
26942:   "getClipRegionRectEdge",
28108:   "startWatchingInstanceCount",
28108:   "getInstanceCount",
28108:   "stopWatchingInstanceCount",
31130:   "getLastMouseX",
31130:   "getLastMouseY",
34501:   "getPaintCount",
36907:   "getWidthAtLastPaint",
47770:   "setInvalidateDuringPaint",
33296:   "getError",
33358:   "doInternalConsistencyCheck",
33861:   "setColor",
34018:   "throwExceptionNextInvoke",
34693:   "convertPointX",
34693:   "convertPointY",
36110:   "streamTest",
36155:   "crash",
36611:   "crashOnDestroy",
36929:   "getObjectValue",
36929:   "checkObjectValue",
37101:   "enableFPExceptions",
37325:   "setCookie",
37325:   "getCookie",
37391:   "getAuthInfo",
37426:   "asyncCallbackTest",
37857:   "checkGCRace",
38122:   "hang",
38686:   "getClipboardText",
39210:   "callOnDestroy",
39855:   "reinitWidget",
41053:   "crashInNestedLoop",
57139:   "destroySharedGfxStuff",
41061:   "propertyAndMethod",
41061:   "getTopLevelWindowActivationState",
41061:   "getTopLevelWindowActivationEventCount",
41321:   "getFocusState",
41321:   "getFocusEventCount",
42020:   "getEventModel",
57226:   "getReflector",
57514:   "isVisible",
57515:   "getWindowPosition",
62174:   "constructObject",
62174:   "setSitesWithData",
62174:   "setSitesWithDataCapabilities"
26802: };
26942: static NPIdentifier sPluginMethodIdentifiers[ARRAY_LENGTH(sPluginMethodIdentifierNames)];
41053: static const ScriptableFunction sPluginMethodFunctions[] = {
34142:   npnEvaluateTest,
33631:   npnInvokeTest,
33771:   npnInvokeDefaultTest,
27202:   setUndefinedValueTest,
26802:   identifierToStringTest,
29937:   timerTest,
26802:   queryPrivateModeState,
26802:   lastReportedPrivateModeState,
26802:   hasWidget,
26942:   getEdge,
26942:   getClipRegionRectCount,
26942:   getClipRegionRectEdge,
28108:   startWatchingInstanceCount,
28108:   getInstanceCount,
28108:   stopWatchingInstanceCount,
31130:   getLastMouseX,
31130:   getLastMouseY,
34501:   getPaintCount,
36907:   getWidthAtLastPaint,
47770:   setInvalidateDuringPaint,
33296:   getError,
33358:   doInternalConsistencyCheck,
33861:   setColor,
34018:   throwExceptionNextInvoke,
34693:   convertPointX,
34693:   convertPointY,
36110:   streamTest,
36163:   crashPlugin,
36611:   crashOnDestroy,
36929:   getObjectValue,
36929:   checkObjectValue,
37101:   enableFPExceptions,
37325:   setCookie,
37325:   getCookie,
37391:   getAuthInfo,
37426:   asyncCallbackTest,
37857:   checkGCRace,
38122:   hangPlugin,
38686:   getClipboardText,
39210:   callOnDestroy,
39855:   reinitWidget,
41053:   crashPluginInNestedLoop,
57139:   destroySharedGfxStuff,
41061:   propertyAndMethod,
41061:   getTopLevelWindowActivationState,
41061:   getTopLevelWindowActivationEventCount,
41321:   getFocusState,
41321:   getFocusEventCount,
42020:   getEventModel,
57226:   getReflector,
57514:   isVisible,
57515:   getWindowPosition,
62174:   constructObject,
62174:   setSitesWithData,
62174:   setSitesWithDataCapabilities
23574: };
41053: 
41053: STATIC_ASSERT(ARRAY_LENGTH(sPluginMethodIdentifierNames) ==
41053:               ARRAY_LENGTH(sPluginMethodFunctions));
41053: 
40566: static const NPUTF8* sPluginPropertyIdentifierNames[] = {
40566:   "propertyAndMethod"
40566: };
40566: static NPIdentifier sPluginPropertyIdentifiers[ARRAY_LENGTH(sPluginPropertyIdentifierNames)];
40566: static NPVariant sPluginPropertyValues[ARRAY_LENGTH(sPluginPropertyIdentifierNames)];
23574: 
36110: struct URLNotifyData
36110: {
36110:   const char* cookie;
60022:   NPObject* writeCallback;
60022:   NPObject* notifyCallback;
60481:   NPObject* redirectCallback;
60022:   bool allowRedirects;
36110:   uint32_t size;
36110:   char* data;
36110: };
36110: 
36110: static URLNotifyData kNotifyData = {
36110:   "static-cookie",
36110:   NULL,
60022:   NULL,
60022:   false,
36110:   0,
36110:   NULL
36110: };
32918: 
33686: static const char* SUCCESS_STRING = "pass";
33404: 
23574: static bool sIdentifiersInitialized = false;
23574: 
37426: static uint32_t timerEventCount = 0;
37426: 
37426: struct timerEvent {
37426:   int32_t timerIdReceive;
37426:   int32_t timerIdSchedule;
37426:   uint32_t timerInterval;
37426:   bool timerRepeat;
37426:   int32_t timerIdUnschedule;
37426: };
37426: static timerEvent timerEvents[] = {
37426:   {-1, 0, 200, false, -1},
37426:   {0, 0, 400, false, -1},
37426:   {0, 0, 200, true, -1},
37426:   {0, 1, 100, true, -1},
37426:   {1, -1, 0, false, -1},
37426:   {0, -1, 0, false, -1},
37426:   {1, -1, 0, false, -1},
37426:   {1, -1, 0, false, -1},
37426:   {0, -1, 0, false, 0},
37426:   {1, 2, 600, false, 1},
37426:   {2, -1, 0, false, 2},
37426: };
37426: static uint32_t totalTimerEvents = sizeof(timerEvents) / sizeof(timerEvent);
37426: 
28108: /**
28108:  * Incremented for every startWatchingInstanceCount.
28108:  */
28108: static int32_t sCurrentInstanceCountWatchGeneration = 0;
28108: /**
28108:  * Tracks the number of instances created or destroyed since the last
28108:  * startWatchingInstanceCount.
28108:  */
28108: static int32_t sInstanceCount = 0;
28108: /**
28108:  * True when we've had a startWatchingInstanceCount with no corresponding
28108:  * stopWatchingInstanceCount.
28108:  */
28108: static bool sWatchingInstanceCount = false;
28108: 
62174: /**
62174:  * A list representing sites for which the plugin has stored data. See
62174:  * NPP_ClearSiteData and NPP_GetSitesWithData.
62174:  */
62174: struct siteData {
62174:   string site;
62174:   uint64_t flags;
62174:   uint64_t age;
62174: };
62174: static list<siteData>* sSitesWithData;
62174: static bool sClearByAgeSupported;
62174: 
23574: static void initializeIdentifiers()
23574: {
23574:   if (!sIdentifiersInitialized) {
26942:     NPN_GetStringIdentifiers(sPluginMethodIdentifierNames,
26942:         ARRAY_LENGTH(sPluginMethodIdentifierNames), sPluginMethodIdentifiers);
40566:     NPN_GetStringIdentifiers(sPluginPropertyIdentifierNames,
40566:         ARRAY_LENGTH(sPluginPropertyIdentifierNames), sPluginPropertyIdentifiers);
40566: 
23574:     sIdentifiersInitialized = true;    
38646: 
38646:     // Check whether NULL is handled in NPN_GetStringIdentifiers
38646:     NPIdentifier IDList[2];
38646:     static char const *const kIDNames[2] = { NULL, "setCookie" };
38646:     NPN_GetStringIdentifiers(const_cast<const NPUTF8**>(kIDNames), 2, IDList);
23574:   }
23574: }
23574: 
23574: static void clearIdentifiers()
23574: {
26942:   memset(sPluginMethodIdentifiers, 0,
26942:       ARRAY_LENGTH(sPluginMethodIdentifiers) * sizeof(NPIdentifier));
40566:   memset(sPluginPropertyIdentifiers, 0,
40566:       ARRAY_LENGTH(sPluginPropertyIdentifiers) * sizeof(NPIdentifier));
40566: 
23574:   sIdentifiersInitialized = false;
23574: }
23574: 
32918: static void addRange(InstanceData* instanceData, const char* range)
32918: {
32918:   char rangestr[16];
32918:   strncpy(rangestr, range, sizeof(rangestr));
32918:   const char* str1 = strtok(rangestr, ",");
32918:   const char* str2 = str1 ? strtok(NULL, ",") : NULL;
32918:   if (str1 && str2) {
32918:     TestRange* byterange = new TestRange;
32918:     byterange->offset = atoi(str1);
32918:     byterange->length = atoi(str2);
32918:     byterange->waiting = true;
32918:     byterange->next = instanceData->testrange;
32918:     instanceData->testrange = byterange;
32918:   }
32918: }
32918: 
32918: static void sendBufferToFrame(NPP instance)
32918: {
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
33296:   string outbuf;
33296:   if (!instanceData->npnNewStream) outbuf = "data:text/html,";
32918:   const char* buf = reinterpret_cast<char *>(instanceData->streamBuf);
32918:   int32_t bufsize = instanceData->streamBufSize;
32918:   if (instanceData->streamMode == NP_ASFILE || 
32918:       instanceData->streamMode == NP_ASFILEONLY) {
32918:     buf = reinterpret_cast<char *>(instanceData->fileBuf);
32918:     bufsize = instanceData->fileBufSize;
32918:   }
32918:   if (instanceData->err.str().length() > 0) {
33296:     outbuf.append(instanceData->err.str());
32918:   }
33296:   else if (bufsize > 0) {
32918:     outbuf.append(buf);
32918:   }
32918:   else {
32918:     outbuf.append("Error: no data in buffer");
32918:   }
32918:   
33296:   if (instanceData->npnNewStream &&
33296:       instanceData->err.str().length() == 0) {
33686:     char typeHTML[] = "text/html";
33296:     NPStream* stream;
33296:     printf("calling NPN_NewStream...");
33686:     NPError err = NPN_NewStream(instance, typeHTML, 
33686:         instanceData->frame.c_str(), &stream);
33296:     printf("return value %d\n", err);
33296:     if (err != NPERR_NO_ERROR) {
33296:       instanceData->err << "NPN_NewStream returned " << err;
33296:       return;
33296:     }
33296:     
33296:     int32_t bytesToWrite = outbuf.length();
33296:     int32_t bytesWritten = 0;
33296:     while ((bytesToWrite - bytesWritten) > 0) {
33296:       int32_t numBytes = (bytesToWrite - bytesWritten) < 
33296:           instanceData->streamChunkSize ?
33296:           bytesToWrite - bytesWritten : instanceData->streamChunkSize;
33296:       int32_t written = NPN_Write(instance, stream,
33296:           numBytes, (void*)(outbuf.c_str() + bytesWritten));
33296:       if (written <= 0) {
33296:         instanceData->err << "NPN_Write returned " << written;
33296:         break;
33296:       }
33296:       bytesWritten += numBytes;
33296:       printf("%d bytes written, total %d\n", written, bytesWritten);
33296:     }
33296:     err = NPN_DestroyStream(instance, stream, NPRES_DONE);
33296:     if (err != NPERR_NO_ERROR) {
33296:       instanceData->err << "NPN_DestroyStream returned " << err;
33296:     }
33296:   }
33296:   else {
32918:     // Convert CRLF to LF, and escape most other non-alphanumeric chars.
33686:     for (size_t i = 0; i < outbuf.length(); i++) {
32918:       if (outbuf[i] == '\n') {
32918:         outbuf.replace(i, 1, "%0a");
32918:         i += 2;
32918:       }
32918:       else if (outbuf[i] == '\r') {
32918:         outbuf.replace(i, 1, "");
32918:         i -= 1;
32918:       }
32918:       else {
32918:         int ascii = outbuf[i];
32918:         if (!((ascii >= ',' && ascii <= ';') ||
32918:               (ascii >= 'A' && ascii <= 'Z') ||
32918:               (ascii >= 'a' && ascii <= 'z'))) {
32918:           char hex[8];
32918:           sprintf(hex, "%%%x", ascii);
32918:           outbuf.replace(i, 1, hex);
32918:           i += 2;
32918:         }
32918:       }
32918:     }
33296: 
32918:     NPError err = NPN_GetURL(instance, outbuf.c_str(), 
32918:                              instanceData->frame.c_str());
32918:     if (err != NPERR_NO_ERROR) {
32918:       instanceData->err << "NPN_GetURL returned " << err;
32918:     }
32918:   }
33296: }
32918: 
33404: TestFunction
33404: getFuncFromString(const char* funcname)
33404: {
33404:   FunctionTable funcTable[] = 
33404:     {
33686:       { FUNCTION_NPP_NEWSTREAM, "npp_newstream" },
33686:       { FUNCTION_NPP_WRITEREADY, "npp_writeready" },
33686:       { FUNCTION_NPP_WRITE, "npp_write" },
33686:       { FUNCTION_NPP_DESTROYSTREAM, "npp_destroystream" },
38760:       { FUNCTION_NPP_WRITE_RPC, "npp_write_rpc" },
33686:       { FUNCTION_NONE, NULL }
33404:     };
33404:   int32_t i = 0;
33404:   while(funcTable[i].funcName) {
33404:     if (!strcmp(funcname, funcTable[i].funcName)) return funcTable[i].funcId;
33404:     i++;
33404:   }
33404:   return FUNCTION_NONE;
33404: }
33404: 
40566: static void
40566: DuplicateNPVariant(NPVariant& aDest, const NPVariant& aSrc)
40566: {
40566:   if (NPVARIANT_IS_STRING(aSrc)) {
40566:     NPString src = NPVARIANT_TO_STRING(aSrc);
40566:     char* buf = new char[src.UTF8Length];
40566:     strncpy(buf, src.UTF8Characters, src.UTF8Length);
40566:     STRINGN_TO_NPVARIANT(buf, src.UTF8Length, aDest);
40566:   }
40566:   else if (NPVARIANT_IS_OBJECT(aSrc)) {
40566:     NPObject* obj =
40566:       NPN_RetainObject(NPVARIANT_TO_OBJECT(aSrc));
40566:     OBJECT_TO_NPVARIANT(obj, aDest);
40566:   }
40566:   else {
40566:     aDest = aSrc;
40566:   }
40566: }
40566: 
23574: //
23574: // function signatures
23574: //
23574: 
23574: NPObject* scriptableAllocate(NPP npp, NPClass* aClass);
23574: void scriptableDeallocate(NPObject* npobj);
23574: void scriptableInvalidate(NPObject* npobj);
23574: bool scriptableHasMethod(NPObject* npobj, NPIdentifier name);
23574: bool scriptableInvoke(NPObject* npobj, NPIdentifier name, const NPVariant* args, uint32_t argCount, NPVariant* result);
23574: bool scriptableInvokeDefault(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
23574: bool scriptableHasProperty(NPObject* npobj, NPIdentifier name);
23574: bool scriptableGetProperty(NPObject* npobj, NPIdentifier name, NPVariant* result);
23574: bool scriptableSetProperty(NPObject* npobj, NPIdentifier name, const NPVariant* value);
23574: bool scriptableRemoveProperty(NPObject* npobj, NPIdentifier name);
23574: bool scriptableEnumerate(NPObject* npobj, NPIdentifier** identifier, uint32_t* count);
23574: bool scriptableConstruct(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result);
23574: 
23574: //
23574: // npapi plugin functions
23574: //
23574: 
23574: #ifdef XP_UNIX
22933: NP_EXPORT(char*)
23574: NP_GetPluginVersion()
23574: {
42621:   return sPluginVersion;
22931: }
23574: #endif
22931: 
42621: static char sMimeDescription[] = "application/x-test:tst:Test mimetype";
42621: 
23574: #if defined(XP_UNIX)
23574: NP_EXPORT(char*) NP_GetMIMEDescription()
26614: #elif defined(XP_WIN) || defined(XP_OS2)
23574: char* NP_GetMIMEDescription()
23574: #endif
23574: {
42621:   return sMimeDescription;
19014: }
19014: 
23574: #ifdef XP_UNIX
19014: NP_EXPORT(NPError)
19014: NP_GetValue(void* future, NPPVariable aVariable, void* aValue) {
19014:   switch (aVariable) {
19014:     case NPPVpluginNameString:
42621:       *((char**)aValue) = sPluginName;
19014:       break;
19014:     case NPPVpluginDescriptionString:
42621:       *((char**)aValue) = sPluginDescription;
19014:       break;
19014:     default:
19014:       return NPERR_INVALID_PARAM;
19014:       break;
19014:   }
19014:   return NPERR_NO_ERROR;
19014: }
23574: #endif
22933: 
58535: static bool fillPluginFunctionTable(NPPluginFuncs* pFuncs)
23574: {
58535:   // Check the size of the provided structure based on the offset of the
58535:   // last member we need.
58535:   if (pFuncs->size < (offsetof(NPPluginFuncs, setvalue) + sizeof(void*)))
58535:     return false;
58535: 
23574:   pFuncs->newp = NPP_New;
23574:   pFuncs->destroy = NPP_Destroy;
23574:   pFuncs->setwindow = NPP_SetWindow;
23574:   pFuncs->newstream = NPP_NewStream;
23574:   pFuncs->destroystream = NPP_DestroyStream;
23574:   pFuncs->asfile = NPP_StreamAsFile;
23574:   pFuncs->writeready = NPP_WriteReady;
23574:   pFuncs->write = NPP_Write;
23574:   pFuncs->print = NPP_Print;
23574:   pFuncs->event = NPP_HandleEvent;
60481:   pFuncs->urlnotify = NPP_URLNotify;
23574:   pFuncs->getvalue = NPP_GetValue;
23574:   pFuncs->setvalue = NPP_SetValue;
60022:   pFuncs->urlredirectnotify = NPP_URLRedirectNotify;
62174:   pFuncs->clearsitedata = NPP_ClearSiteData;
62174:   pFuncs->getsiteswithdata = NPP_GetSitesWithData;
58535: 
58535:   return true;
23574: }
23574: 
23574: #if defined(XP_MACOSX)
23574: NP_EXPORT(NPError) NP_Initialize(NPNetscapeFuncs* bFuncs)
26614: #elif defined(XP_WIN) || defined(XP_OS2)
23574: NPError OSCALL NP_Initialize(NPNetscapeFuncs* bFuncs)
23574: #elif defined(XP_UNIX)
23574: NP_EXPORT(NPError) NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs)
22931: #endif
23574: {
23574:   sBrowserFuncs = bFuncs;
23574: 
23574:   initializeIdentifiers();
23574: 
42621:   for (unsigned int i = 0; i < ARRAY_LENGTH(sPluginPropertyValues); i++) {
40566:     VOID_TO_NPVARIANT(sPluginPropertyValues[i]);
40566:   }
40566: 
23574:   memset(&sNPClass, 0, sizeof(NPClass));
23574:   sNPClass.structVersion =  NP_CLASS_STRUCT_VERSION;
23574:   sNPClass.allocate =       (NPAllocateFunctionPtr)scriptableAllocate;
23574:   sNPClass.deallocate =     (NPDeallocateFunctionPtr)scriptableDeallocate;
23574:   sNPClass.invalidate =     (NPInvalidateFunctionPtr)scriptableInvalidate;
23574:   sNPClass.hasMethod =      (NPHasMethodFunctionPtr)scriptableHasMethod;
23574:   sNPClass.invoke =         (NPInvokeFunctionPtr)scriptableInvoke;
23574:   sNPClass.invokeDefault =  (NPInvokeDefaultFunctionPtr)scriptableInvokeDefault;
23574:   sNPClass.hasProperty =    (NPHasPropertyFunctionPtr)scriptableHasProperty;
23574:   sNPClass.getProperty =    (NPGetPropertyFunctionPtr)scriptableGetProperty;
23574:   sNPClass.setProperty =    (NPSetPropertyFunctionPtr)scriptableSetProperty;
23574:   sNPClass.removeProperty = (NPRemovePropertyFunctionPtr)scriptableRemoveProperty;
23574:   sNPClass.enumerate =      (NPEnumerationFunctionPtr)scriptableEnumerate;
23574:   sNPClass.construct =      (NPConstructFunctionPtr)scriptableConstruct;
23574: 
23574: #if defined(XP_UNIX) && !defined(XP_MACOSX)
58535:   if (!fillPluginFunctionTable(pFuncs)) {
58535:     return NPERR_INVALID_FUNCTABLE_ERROR;
58535:   }
23574: #endif
23574: 
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: #if defined(XP_MACOSX)
23574: NP_EXPORT(NPError) NP_GetEntryPoints(NPPluginFuncs* pFuncs)
26614: #elif defined(XP_WIN) || defined(XP_OS2)
23574: NPError OSCALL NP_GetEntryPoints(NPPluginFuncs* pFuncs)
23574: #endif
26614: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(XP_OS2)
23574: {
58535:   if (!fillPluginFunctionTable(pFuncs)) {
58535:     return NPERR_INVALID_FUNCTABLE_ERROR;
58535:   }
58535: 
23574:   return NPERR_NO_ERROR;
23574: }
23574: #endif
23574: 
23574: #if defined(XP_UNIX)
23574: NP_EXPORT(NPError) NP_Shutdown()
26614: #elif defined(XP_WIN) || defined(XP_OS2)
23574: NPError OSCALL NP_Shutdown()
23574: #endif
23574: {
23574:   clearIdentifiers();
23574: 
42621:   for (unsigned int i = 0; i < ARRAY_LENGTH(sPluginPropertyValues); i++) {
40566:     NPN_ReleaseVariantValue(&sPluginPropertyValues[i]);
40566:   }
40566: 
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: NPError
23574: NPP_New(NPMIMEType pluginType, NPP instance, uint16_t mode, int16_t argc, char* argn[], char* argv[], NPSavedData* saved)
23574: {
39978:   // Make sure our pdata field is NULL at this point. If it isn't, that
39978:   // probably means the browser gave us uninitialized memory.
39978:   if (instance->pdata) {
39978:     printf("NPP_New called with non-NULL NPP->pdata pointer!\n");
39978:     return NPERR_GENERIC_ERROR;
39978:   }
39978: 
26802:   // Make sure we can render this plugin
26802:   NPBool browserSupportsWindowless = false;
26802:   NPN_GetValue(instance, NPNVSupportsWindowless, &browserSupportsWindowless);
26802:   if (!browserSupportsWindowless && !pluginSupportsWindowMode()) {
26802:     printf("Windowless mode not supported by the browser, windowed mode not supported by the plugin!\n");
26802:     return NPERR_GENERIC_ERROR;
26802:   }
23574: 
23574:   // set up our our instance data
32918:   InstanceData* instanceData = new InstanceData;
23574:   if (!instanceData)
23574:     return NPERR_OUT_OF_MEMORY_ERROR;
23574:   instanceData->npp = instance;
32918:   instanceData->streamMode = NP_ASFILEONLY;
33071:   instanceData->testFunction = FUNCTION_NONE;
33404:   instanceData->functionToFail = FUNCTION_NONE;
33404:   instanceData->failureCode = 0;
39210:   instanceData->callOnDestroy = NULL;
32918:   instanceData->streamChunkSize = 1024;
32918:   instanceData->streamBuf = NULL;
32918:   instanceData->streamBufSize = 0;
33071:   instanceData->fileBuf = NULL;
33071:   instanceData->fileBufSize = 0;
34018:   instanceData->throwOnNextInvoke = false;
54262:   instanceData->runScriptOnPaint = false;
32918:   instanceData->testrange = NULL;
32918:   instanceData->hasWidget = false;
33296:   instanceData->npnNewStream = false;
47770:   instanceData->invalidateDuringPaint = false;
33404:   instanceData->writeCount = 0;
33404:   instanceData->writeReadyCount = 0;
32918:   memset(&instanceData->window, 0, sizeof(instanceData->window));
36611:   instanceData->crashOnDestroy = false;
41489:   instanceData->cleanupWidget = true; // only used by nptest_gtk
41061:   instanceData->topLevelWindowActivationState = ACTIVATION_STATE_UNKNOWN;
41061:   instanceData->topLevelWindowActivationEventCount = 0;
41321:   instanceData->focusState = ACTIVATION_STATE_UNKNOWN;
41321:   instanceData->focusEventCount = 0;
41061:   instanceData->eventModel = 0;
63014:   instanceData->closeStream = false;
23574:   instance->pdata = instanceData;
23574: 
23574:   TestNPObject* scriptableObject = (TestNPObject*)NPN_CreateObject(instance, &sNPClass);
23574:   if (!scriptableObject) {
23574:     printf("NPN_CreateObject failed to create an object, can't create a plugin instance\n");
26802:     free(instanceData);
23574:     return NPERR_GENERIC_ERROR;
23574:   }
23574:   scriptableObject->npp = instance;
26802:   scriptableObject->drawMode = DM_DEFAULT;
26802:   scriptableObject->drawColor = 0;
23574:   instanceData->scriptableObject = scriptableObject;
23574: 
28108:   instanceData->instanceCountWatchGeneration = sCurrentInstanceCountWatchGeneration;
28108: 
40721:   if (NP_FULL == mode) {
40721:     instanceData->streamMode = NP_SEEK;
40721:     instanceData->frame = "testframe";
40721:     addRange(instanceData, "100,100");
40721:   }
40721: 
26802:   bool requestWindow = false;
23823:   // handle extra params
23823:   for (int i = 0; i < argc; i++) {
23823:     if (strcmp(argn[i], "drawmode") == 0) {
23823:       if (strcmp(argv[i], "solid") == 0)
23823:         scriptableObject->drawMode = DM_SOLID_COLOR;    
23823:     }
23823:     else if (strcmp(argn[i], "color") == 0) {
33861:       scriptableObject->drawColor = parseHexColor(argv[i], strlen(argv[i]));
23823:     }
26802:     else if (strcmp(argn[i], "wmode") == 0) {
26802:       if (strcmp(argv[i], "window") == 0) {
26802:         requestWindow = true;
26802:       }
26802:     }
32918:     if (strcmp(argn[i], "streammode") == 0) {
32918:       if (strcmp(argv[i], "normal") == 0) {
32918:         instanceData->streamMode = NP_NORMAL;
32918:       }
32918:       else if ((strcmp(argv[i], "asfile") == 0) &&
32918:                 strlen(argv[i]) == strlen("asfile")) {
32918:         instanceData->streamMode = NP_ASFILE;
32918:       }
32918:       else if (strcmp(argv[i], "asfileonly") == 0) {
32918:         instanceData->streamMode = NP_ASFILEONLY;
32918:       }
32918:       else if (strcmp(argv[i], "seek") == 0) {
32918:         instanceData->streamMode = NP_SEEK;
32918:       }
32918:     }
32918:     if (strcmp(argn[i], "streamchunksize") == 0) {
32918:       instanceData->streamChunkSize = atoi(argv[i]);
32918:     }
33404:     if (strcmp(argn[i], "failurecode") == 0) {
33404:       instanceData->failureCode = atoi(argv[i]);
33404:     }
33404:     if (strcmp(argn[i], "functiontofail") == 0) {
33404:       instanceData->functionToFail = getFuncFromString(argv[i]);
33404:     }
32918:     if (strcmp(argn[i], "geturl") == 0) {
32918:       instanceData->testUrl = argv[i];
32918:       instanceData->testFunction = FUNCTION_NPP_GETURL;
32918:     }
32918:     if (strcmp(argn[i], "posturl") == 0) {
32918:       instanceData->testUrl = argv[i];
32918:       instanceData->testFunction = FUNCTION_NPP_POSTURL;
32918:     }
32918:     if (strcmp(argn[i], "geturlnotify") == 0) {
32918:       instanceData->testUrl = argv[i];
32918:       instanceData->testFunction = FUNCTION_NPP_GETURLNOTIFY;
32918:     }
32918:     if (strcmp(argn[i], "postmode") == 0) {
32918:       if (strcmp(argv[i], "frame") == 0) {
32918:         instanceData->postMode = POSTMODE_FRAME;
32918:       }
32918:       else if (strcmp(argv[i], "stream") == 0) {
32918:         instanceData->postMode = POSTMODE_STREAM;
32918:       }
32918:     }
32918:     if (strcmp(argn[i], "frame") == 0) {
32918:       instanceData->frame = argv[i];
32918:     }
32918:     if (strcmp(argn[i], "range") == 0) {
32918:       string range = argv[i];
33686:       size_t semicolon = range.find(';');
32918:       while (semicolon != string::npos) {
32918:         addRange(instanceData, range.substr(0, semicolon).c_str());
32918:         if (semicolon == range.length()) {
32918:           range = "";
32918:           break;
32918:         }
32918:         range = range.substr(semicolon + 1);
32918:         semicolon = range.find(';');
32918:       }
32918:       if (range.length()) addRange(instanceData, range.c_str());
32918:     }
33296:     if (strcmp(argn[i], "newstream") == 0 &&
33296:         strcmp(argv[i], "true") == 0) {
33296:       instanceData->npnNewStream = true;
33296:     }
36611:     if (strcmp(argn[i], "newcrash") == 0) {
37560:       IntentionalCrash();
36611:     }
54262:     if (strcmp(argn[i], "paintscript") == 0) {
54262:       instanceData->runScriptOnPaint = true;
54262:     }
41489:     // "cleanupwidget" is only used with nptest_gtk, defaulting to true.  It
41489:     // indicates whether the plugin should destroy its window in response to
41489:     // NPP_Destroy (or let the platform destroy the widget when the parent
41489:     // window gets destroyed).
41489:     if (strcmp(argn[i], "cleanupwidget") == 0 &&
41489:         strcmp(argv[i], "false") == 0) {
41489:       instanceData->cleanupWidget = false;
41489:     }
63014:     if (!strcmp(argn[i], "closestream")) {
63014:       instanceData->closeStream = true;
63014:     }
26802:   }
26802: 
26802:   if (!browserSupportsWindowless || !pluginSupportsWindowlessMode()) {
26802:     requestWindow = true;
26802:   } else if (!pluginSupportsWindowMode()) {
26802:     requestWindow = false;
26802:   }
26802:   if (requestWindow) {
26802:     instanceData->hasWidget = true;
26802:   } else {
26802:     // NPPVpluginWindowBool should default to true, so we may as well
26802:     // test that by not setting it in the window case
26802:     NPN_SetValue(instance, NPPVpluginWindowBool, (void*)false);
26802:   }
26802: 
26802:   if (scriptableObject->drawMode == DM_SOLID_COLOR &&
26802:       (scriptableObject->drawColor & 0xFF000000) != 0xFF000000) {
26802:     NPN_SetValue(instance, NPPVpluginTransparentBool, (void*)true);
23823:   }
23823: 
24475:   instanceData->lastReportedPrivateModeState = false;
31130:   instanceData->lastMouseX = instanceData->lastMouseY = -1;
36907:   instanceData->widthAtLastPaint = -1;
34501:   instanceData->paintCount = 0;
24475: 
23574:   // do platform-specific initialization
23574:   NPError err = pluginInstanceInit(instanceData);
26802:   if (err != NPERR_NO_ERROR) {
26802:     NPN_ReleaseObject(scriptableObject);
26802:     free(instanceData);
23574:     return err;
26802:   }
23574: 
32369:   NPVariant variantTrue;
32369:   BOOLEAN_TO_NPVARIANT(true, variantTrue);
32369: 
32369:   // Set a property on NPNVPluginElementNPObject
32369:   NPObject* o = NULL;
32369:   err = NPN_GetValue(instance, NPNVPluginElementNPObject, &o);
32369:   if (err == NPERR_NO_ERROR) {
32369:     NPN_SetProperty(instance, o,
32369:                     NPN_GetStringIdentifier("pluginFoundElement"), &variantTrue);
32369:     NPN_ReleaseObject(o);
32369:     o = NULL;
32369:   }
32369:   
32369:   // Set a property on NPNVWindowNPObject
32369:   err = NPN_GetValue(instance, NPNVWindowNPObject, &o);
32369:   if (err == NPERR_NO_ERROR) {
32369:     NPN_SetProperty(instance, o,
32369:                     NPN_GetStringIdentifier("pluginFoundWindow"), &variantTrue);
32369:     NPN_ReleaseObject(o);
32369:     o = NULL;
32369:   }
32369: 
28108:   ++sInstanceCount;
32918: 
32918:   if (instanceData->testFunction == FUNCTION_NPP_GETURL) {
32918:     NPError err = NPN_GetURL(instance, instanceData->testUrl.c_str(), NULL);
32918:     if (err != NPERR_NO_ERROR) {
32918:       instanceData->err << "NPN_GetURL returned " << err;
32918:     }
32918:   }
32918:   else if (instanceData->testFunction == FUNCTION_NPP_GETURLNOTIFY) {
32918:     NPError err = NPN_GetURLNotify(instance, instanceData->testUrl.c_str(), 
36110:                                    NULL, static_cast<void*>(&kNotifyData));
32918:     if (err != NPERR_NO_ERROR) {
32918:       instanceData->err << "NPN_GetURLNotify returned " << err;
32918:     }
32918:   }
32918: 
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: NPError
23574: NPP_Destroy(NPP instance, NPSavedData** save)
23574: {
33404:   printf("NPP_Destroy\n");
23574:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
32918: 
39273:   if (instanceData->crashOnDestroy)
37560:     IntentionalCrash();
36611: 
39210:   if (instanceData->callOnDestroy) {
39210:     NPVariant result;
39210:     NPN_InvokeDefault(instance, instanceData->callOnDestroy, NULL, 0, &result);
39210:     NPN_ReleaseVariantValue(&result);
39210:     NPN_ReleaseObject(instanceData->callOnDestroy);
39210:   }
39210: 
32918:   if (instanceData->streamBuf) {
32918:     free(instanceData->streamBuf);
32918:   }
33071:   if (instanceData->fileBuf) {
33071:     free(instanceData->fileBuf);
33071:   }
32918: 
32918:   TestRange* currentrange = instanceData->testrange;
32918:   TestRange* nextrange;
32918:   while (currentrange != NULL) {
32918:     nextrange = reinterpret_cast<TestRange*>(currentrange->next);
32918:     delete currentrange;
32918:     currentrange = nextrange;
32918:   }
32918: 
26802:   pluginInstanceShutdown(instanceData);
23574:   NPN_ReleaseObject(instanceData->scriptableObject);
28108: 
28108:   if (sCurrentInstanceCountWatchGeneration == instanceData->instanceCountWatchGeneration) {
28108:     --sInstanceCount;
28108:   }
32918:   delete instanceData;
28108: 
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: NPError
23574: NPP_SetWindow(NPP instance, NPWindow* window)
23574: {
23574:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
48695: 
48695:   if (instanceData->scriptableObject->drawMode == DM_DEFAULT &&
48695:       (instanceData->window.width != window->width ||
48695:        instanceData->window.height != window->height)) {
48695:     NPRect r;
48695:     r.left = r.top = 0;
48695:     r.right = window->width;
48695:     r.bottom = window->height;
48695:     NPN_InvalidateRect(instance, &r);
48695:   }
48695: 
26802:   void* oldWindow = instanceData->window.window;
26942:   pluginDoSetWindow(instanceData, window);
26802:   if (instanceData->hasWidget && oldWindow != instanceData->window.window) {
26802:     pluginWidgetInit(instanceData, oldWindow);
26802:   }
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: NPError
23574: NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream, NPBool seekable, uint16_t* stype)
23574: {
32918:   printf("NPP_NewStream\n");
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
33404:   
33404:   if (instanceData->functionToFail == FUNCTION_NPP_NEWSTREAM &&
33404:       instanceData->failureCode) {
33404:     instanceData->err << SUCCESS_STRING;
33404:     if (instanceData->frame.length() > 0) {
33404:       sendBufferToFrame(instance);
33404:     }
33404:     return instanceData->failureCode;
33404:   }
33404: 
36110:   if (stream->notifyData &&
36110:       static_cast<URLNotifyData*>(stream->notifyData) != &kNotifyData) {
36110:     // stream from streamTest
36110:     *stype = NP_NORMAL;
36110:   }
36110:   else {
32918:     *stype = instanceData->streamMode;
32918: 
32918:     if (instanceData->streamBufSize) {
32918:       free(instanceData->streamBuf);
32918:       instanceData->streamBufSize = 0;
32918:       if (instanceData->testFunction == FUNCTION_NPP_POSTURL &&
32918:           instanceData->postMode == POSTMODE_STREAM) {
32918:         instanceData->testFunction = FUNCTION_NPP_GETURL;
32918:       }
32918:     }
36110:   }
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: NPError
23574: NPP_DestroyStream(NPP instance, NPStream* stream, NPReason reason)
23574: {
32918:   printf("NPP_DestroyStream\n");
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
33404: 
33404:   if (instanceData->functionToFail == FUNCTION_NPP_NEWSTREAM) {
33404:     instanceData->err << "NPP_DestroyStream called";
33404:   }
33404: 
33404:   if (instanceData->functionToFail == FUNCTION_NPP_WRITE) {
33404:     if (instanceData->writeCount == 1)
33404:       instanceData->err << SUCCESS_STRING;
33404:     else
33404:       instanceData->err << "NPP_Write called after returning -1";
33404:   }
33404: 
33404:   if (instanceData->functionToFail == FUNCTION_NPP_DESTROYSTREAM &&
33404:       instanceData->failureCode) {
33404:     instanceData->err << SUCCESS_STRING;
33404:     if (instanceData->frame.length() > 0) {
33404:       sendBufferToFrame(instance);
33404:     }
33404:     return instanceData->failureCode;
33404:   }
33404: 
36110:   URLNotifyData* nd = static_cast<URLNotifyData*>(stream->notifyData);
36110:   if (nd && nd != &kNotifyData) {
36110:     return NPERR_NO_ERROR;
36110:   }
36110: 
33404:   if (instanceData->streamMode == NP_ASFILE &&
33404:       instanceData->functionToFail == FUNCTION_NONE) {
36101:     if (!instanceData->streamBuf) {
36101:       instanceData->err <<
36101:         "Error: no data written with NPP_Write";
36101:       return NPERR_GENERIC_ERROR;
36101:     }
36101: 
36101:     if (!instanceData->fileBuf) {
36101:       instanceData->err <<
36101:         "Error: no data written with NPP_StreamAsFile";
36101:       return NPERR_GENERIC_ERROR;
36101:     }
36101: 
32918:     if (strcmp(reinterpret_cast<char *>(instanceData->fileBuf), 
36101:                reinterpret_cast<char *>(instanceData->streamBuf))) {
32918:       instanceData->err <<
32918:         "Error: data passed to NPP_Write and NPP_StreamAsFile differed";
32918:     }
32918:   }
32918:   if (instanceData->frame.length() > 0 && 
32918:       instanceData->testFunction != FUNCTION_NPP_GETURLNOTIFY &&
32918:       instanceData->testFunction != FUNCTION_NPP_POSTURL) {
32918:     sendBufferToFrame(instance);
32918:   }
32918:   if (instanceData->testFunction == FUNCTION_NPP_POSTURL) {
32918:     NPError err = NPN_PostURL(instance, instanceData->testUrl.c_str(), 
32918:       instanceData->postMode == POSTMODE_FRAME ? instanceData->frame.c_str() : NULL, 
32918:       instanceData->streamBufSize,
32918:       reinterpret_cast<char *>(instanceData->streamBuf), false);
32918:     if (err != NPERR_NO_ERROR)
32918:       instanceData->err << "Error: NPN_PostURL returned error value " << err;
32918:   }
23574:   return NPERR_NO_ERROR;
23574: }
23574: 
23574: int32_t
23574: NPP_WriteReady(NPP instance, NPStream* stream)
23574: {
33404:   printf("NPP_WriteReady\n");
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
33404:   instanceData->writeReadyCount++;
33404:   if (instanceData->functionToFail == FUNCTION_NPP_NEWSTREAM) {
33404:     instanceData->err << "NPP_WriteReady called";
33404:   }
33404:   
33404:   // temporarily disabled per bug 519870
33404:   //if (instanceData->writeReadyCount == 1) {
33404:   //  return 0;
33404:   //}
33404: 
32918:   return instanceData->streamChunkSize;
23574: }
23574: 
23574: int32_t
23574: NPP_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len, void* buffer)
23574: {
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
33404:   instanceData->writeCount++;
33404: 
33404:   // temporarily disabled per bug 519870
33404:   //if (instanceData->writeReadyCount == 1) {
33404:   //  instanceData->err << "NPP_Write called even though NPP_WriteReady " <<
33404:   //      "returned 0";
33404:   //}
33404: 
38760:   if (instanceData->functionToFail == FUNCTION_NPP_WRITE_RPC) {
38760:     // Make an RPC call and pretend to consume the data
38760:     NPObject* windowObject = NULL;
38760:     NPN_GetValue(instance, NPNVWindowNPObject, &windowObject);
38760:     if (windowObject)
38760:       NPN_ReleaseObject(windowObject);
38760: 
38760:     return len;
38760:   }
38760:   
33404:   if (instanceData->functionToFail == FUNCTION_NPP_NEWSTREAM) {
33404:     instanceData->err << "NPP_Write called";
33404:   }
33404: 
33404:   if (instanceData->functionToFail == FUNCTION_NPP_WRITE) {
33404:     return -1;
33404:   }
32918: 
36110:   URLNotifyData* nd = static_cast<URLNotifyData*>(stream->notifyData);
60022: 
60022:   if (nd && nd->writeCallback) {
60022:     NPVariant args[1];
60022:     STRINGN_TO_NPVARIANT(stream->url, strlen(stream->url), args[0]);
60022: 
60022:     NPVariant result;
60022:     NPN_InvokeDefault(instance, nd->writeCallback, args, 1, &result);
60022:     NPN_ReleaseVariantValue(&result);
60022:   }
60022: 
36110:   if (nd && nd != &kNotifyData) {
36110:     uint32_t newsize = nd->size + len;
36110:     nd->data = (char*) realloc(nd->data, newsize);
36110:     memcpy(nd->data + nd->size, buffer, len);
36110:     nd->size = newsize;
36110:     return len;
36110:   }
36110: 
63014:   if (instanceData->closeStream) {
63014:     instanceData->closeStream = false;
63014:     if (instanceData->testrange != NULL) {
63014:       NPError err = NPN_RequestRead(stream, instanceData->testrange);
63014:     }
63014:     NPN_DestroyStream(instance, stream, NPRES_USER_BREAK);
63014:   }
63014:   else if (instanceData->streamMode == NP_SEEK &&
63014:       stream->end != 0 && 
63014:       stream->end == ((uint32_t)instanceData->streamBufSize + len)) {
32918:     // If the complete stream has been written, and we're doing a seek test,
32918:     // then call NPN_RequestRead.
32918:     // prevent recursion
32918:     instanceData->streamMode = NP_NORMAL;
32918: 
32918:     if (instanceData->testrange != NULL) {
32918:       NPError err = NPN_RequestRead(stream, instanceData->testrange);
32918:       if (err != NPERR_NO_ERROR) {
32918:         instanceData->err << "NPN_RequestRead returned error %d" << err;
32918:       }
32918:       printf("called NPN_RequestRead, return %d\n", err);
32918:     }
32918:   }
32918: 
32918:   char* streamBuf = reinterpret_cast<char *>(instanceData->streamBuf);
32918:   if (offset + len <= instanceData->streamBufSize) {
32918:     if (memcmp(buffer, streamBuf + offset, len)) {
32918:       instanceData->err << 
32918:           "Error: data written from NPN_RequestRead doesn't match";
32918:     }
32918:     else {
32918:       printf("data matches!\n");
32918:     }
32918:     TestRange* range = instanceData->testrange;
32918:     bool stillwaiting = false;
32918:     while(range != NULL) {
32918:       if (offset == range->offset &&
33686:         (uint32_t)len == range->length) {
32918:         range->waiting = false;
32918:       }
32918:       if (range->waiting) stillwaiting = true;
32918:       range = reinterpret_cast<TestRange*>(range->next);
32918:     }
32918:     if (!stillwaiting) {
32918:       NPError err = NPN_DestroyStream(instance, stream, NPRES_DONE);
32918:       if (err != NPERR_NO_ERROR) {
32918:         instanceData->err << "Error: NPN_DestroyStream returned " << err;
32918:       }
32918:     }
32918:   }
32918:   else {
32918:     if (instanceData->streamBufSize == 0) {
32918:       instanceData->streamBuf = malloc(len + 1);
32918:       streamBuf = reinterpret_cast<char *>(instanceData->streamBuf);
32918:     }
32918:     else {
32918:       instanceData->streamBuf = 
32918:         realloc(reinterpret_cast<char *>(instanceData->streamBuf), 
32918:         instanceData->streamBufSize + len + 1);
32918:       streamBuf = reinterpret_cast<char *>(instanceData->streamBuf);
32918:     }
32918:     memcpy(streamBuf + instanceData->streamBufSize, buffer, len);
32918:     instanceData->streamBufSize = instanceData->streamBufSize + len;
32918:     streamBuf[instanceData->streamBufSize] = '\0';
32918:   }
32918:   return len;
23574: }
23574: 
23574: void
23574: NPP_StreamAsFile(NPP instance, NPStream* stream, const char* fname)
23574: {
32918:   printf("NPP_StreamAsFile, file=%s\n", fname);
33071:   size_t size;
32918: 
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
32918: 
33404:   if (instanceData->functionToFail == FUNCTION_NPP_NEWSTREAM ||
33404:       instanceData->functionToFail == FUNCTION_NPP_WRITE) {
33404:     instanceData->err << "NPP_StreamAsFile called";
33404:   }
33404: 
32918:   if (!fname)
32918:     return;
32918: 
33071:   FILE *file = fopen(fname, "rb");
33071:   if (file) {
33071:     fseek(file, 0, SEEK_END);
33071:     size = ftell(file);
32918:     instanceData->fileBuf = malloc((int32_t)size + 1);
32918:     char* buf = reinterpret_cast<char *>(instanceData->fileBuf);
33071:     fseek(file, 0, SEEK_SET);
33071:     fread(instanceData->fileBuf, 1, size, file);
33071:     fclose(file);
32918:     buf[size] = '\0';
32918:     instanceData->fileBufSize = (int32_t)size;
32918:   }
33071:   else {
33071:     printf("Unable to open file\n");
33296:     instanceData->err << "Unable to open file " << fname;
33071:   }
23574: }
23574: 
23574: void
23574: NPP_Print(NPP instance, NPPrint* platformPrint)
23574: {
23574: }
23574: 
23574: int16_t
23574: NPP_HandleEvent(NPP instance, void* event)
23574: {
23574:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
23574:   return pluginHandleEvent(instanceData, event);
23574: }
23574: 
23574: void
60481: NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData)
23574: {
32918:   InstanceData* instanceData = (InstanceData*)(instance->pdata);
36110:   URLNotifyData* ndata = static_cast<URLNotifyData*>(notifyData);
36110: 
32918:   printf("NPP_URLNotify called\n");
36110:   if (&kNotifyData == ndata) {
36110:     if (instanceData->frame.length() > 0) {
36110:       sendBufferToFrame(instance);
36110:     }
36110:   }
36110:   else if (!strcmp(ndata->cookie, "dynamic-cookie")) {
60481:     if (ndata->notifyCallback) {
36110:       NPVariant args[2];
60481:       INT32_TO_NPVARIANT(reason, args[0]);
60481:       if (ndata->data) {
60481:         STRINGN_TO_NPVARIANT(ndata->data, ndata->size, args[1]);
60481:       }
60481:       else {
60481:         STRINGN_TO_NPVARIANT("", 0, args[1]);
60481:       }
60481: 
36110:       NPVariant result;
60022:       NPN_InvokeDefault(instance, ndata->notifyCallback, args, 2, &result);
36110:       NPN_ReleaseVariantValue(&result);
60481:     }
36110: 
36110:     // clean up the URLNotifyData
60022:     if (ndata->writeCallback) {
60022:       NPN_ReleaseObject(ndata->writeCallback);
60022:     }
60481:     if (ndata->notifyCallback) {
60022:       NPN_ReleaseObject(ndata->notifyCallback);
60481:     }
60481:     if (ndata->redirectCallback) {
60481:       NPN_ReleaseObject(ndata->redirectCallback);
60481:     }
36110:     free(ndata->data);
36110:     delete ndata;
36110:   }
36110:   else {
32918:     printf("ERROR! NPP_URLNotify called with wrong cookie\n");
32918:     instanceData->err << "Error: NPP_URLNotify called with wrong cookie";
32918:   }
23574: }
23574: 
23574: NPError
23574: NPP_GetValue(NPP instance, NPPVariable variable, void* value)
23574: {
26802:   InstanceData* instanceData = (InstanceData*)instance->pdata;
23574:   if (variable == NPPVpluginScriptableNPObject) {
26802:     NPObject* object = instanceData->scriptableObject;
23574:     NPN_RetainObject(object);
23574:     *((NPObject**)value) = object;
23574:     return NPERR_NO_ERROR;
23574:   }
26802:   if (variable == NPPVpluginNeedsXEmbed) {
26802:     // Only relevant for X plugins
26802:     *(NPBool*)value = instanceData->hasWidget;
26802:     return NPERR_NO_ERROR;
26802:   }
23574: 
23574:   return NPERR_GENERIC_ERROR;
23574: }
23574: 
23574: NPError
23574: NPP_SetValue(NPP instance, NPNVariable variable, void* value)
23574: {
24475:   if (variable == NPNVprivateModeBool) {
24475:     InstanceData* instanceData = (InstanceData*)(instance->pdata);
26942:     instanceData->lastReportedPrivateModeState = bool(*static_cast<NPBool*>(value));
24475:     return NPERR_NO_ERROR;
24475:   }
23574:   return NPERR_GENERIC_ERROR;
23574: }
23574: 
60022: void
60022: NPP_URLRedirectNotify(NPP instance, const char* url, int32_t status, void* notifyData)
60022: {
60022:   if (notifyData) {
60481:     URLNotifyData* nd = static_cast<URLNotifyData*>(notifyData);
60481:     if (nd->redirectCallback) {
60481:       NPVariant args[2];
60481:       STRINGN_TO_NPVARIANT(url, strlen(url), args[0]);
60481:       INT32_TO_NPVARIANT(status, args[1]);
60481: 
60481:       NPVariant result;
60481:       NPN_InvokeDefault(instance, nd->redirectCallback, args, 2, &result);
60481:       NPN_ReleaseVariantValue(&result);
60481:     }
60481:     NPN_URLRedirectResponse(instance, notifyData, nd->allowRedirects);
60022:     return;
60022:   }
60022:   NPN_URLRedirectResponse(instance, notifyData, true);
60022: }
60022: 
62174: NPError
62174: NPP_ClearSiteData(const char* site, uint64_t flags, uint64_t maxAge)
62174: {
62174:   if (!sSitesWithData)
62174:     return NPERR_NO_ERROR;
62174: 
62174:   // Error condition: no support for clear-by-age
62174:   if (!sClearByAgeSupported && maxAge != uint64_t(int64_t(-1)))
62174:     return NPERR_TIME_RANGE_NOT_SUPPORTED;
62174: 
62174:   // Iterate over list and remove matches
62174:   list<siteData>::iterator iter = sSitesWithData->begin();
62174:   list<siteData>::iterator end = sSitesWithData->end();
62174:   while (iter != end) {
62174:     const siteData& data = *iter;
62174:     list<siteData>::iterator next = iter;
62174:     ++next;
62174:     if ((!site || data.site.compare(site) == 0) &&
62174:         (flags == NP_CLEAR_ALL || data.flags & flags) &&
62174:         data.age <= maxAge) {
62174:       sSitesWithData->erase(iter);
62174:     }
62174:     iter = next;
62174:   }
62174: 
62174:   return NPERR_NO_ERROR;
62174: }
62174: 
62174: char**
62174: NPP_GetSitesWithData()
62174: {
62174:   int length = 0;
62174:   char** result;
62174: 
62174:   if (sSitesWithData)
62174:     length = sSitesWithData->size();
62174: 
62174:   // Allocate the maximum possible size the list could be.
62174:   result = static_cast<char**>(NPN_MemAlloc((length + 1) * sizeof(char*)));
62174:   result[length] = NULL;
62174: 
62174:   if (length == 0) {
62174:     // Represent the no site data case as an array of length 1 with a NULL
62174:     // entry.
62174:     return result;
62174:   }
62174: 
62174:   // Iterate the list of stored data, and build a list of strings.
62174:   list<string> sites;
62174:   {
62174:     list<siteData>::iterator iter = sSitesWithData->begin();
62174:     list<siteData>::iterator end = sSitesWithData->end();
62174:     for (; iter != end; ++iter) {
62174:       const siteData& data = *iter;
62174:       sites.push_back(data.site);
62174:     }
62174:   }
62174: 
62174:   // Remove duplicate strings.
62174:   sites.sort();
62174:   sites.unique();
62174: 
62174:   // Add strings to the result array, and null terminate.
62174:   {
62174:     int i = 0;
62174:     list<string>::iterator iter = sites.begin();
62174:     list<string>::iterator end = sites.end();
62174:     for (; iter != end; ++iter, ++i) {
62174:       const string& site = *iter;
62174:       result[i] = static_cast<char*>(NPN_MemAlloc(site.length() + 1));
62174:       memcpy(result[i], site.c_str(), site.length() + 1);
62174:     }
62174:   }
62174:   result[sites.size()] = NULL;
62174: 
62174:   return result;
62174: }
62174: 
23574: //
23574: // npapi browser functions
23574: //
23574: 
23574: bool
23574: NPN_SetProperty(NPP instance, NPObject* obj, NPIdentifier propertyName, const NPVariant* value)
23574: {
23574:   return sBrowserFuncs->setproperty(instance, obj, propertyName, value);
23574: }
23574: 
23574: NPIdentifier
23574: NPN_GetIntIdentifier(int32_t intid)
23574: {
23574:   return sBrowserFuncs->getintidentifier(intid);
23574: }
23574: 
23574: NPIdentifier
23574: NPN_GetStringIdentifier(const NPUTF8* name)
23574: {
23574:   return sBrowserFuncs->getstringidentifier(name);
23574: }
23574: 
23574: void
23574: NPN_GetStringIdentifiers(const NPUTF8 **names, int32_t nameCount, NPIdentifier *identifiers)
23574: {
23574:   return sBrowserFuncs->getstringidentifiers(names, nameCount, identifiers);
23574: }
23574: 
42020: bool
42020: NPN_IdentifierIsString(NPIdentifier identifier)
42020: {
42020:   return sBrowserFuncs->identifierisstring(identifier);
42020: }
42020: 
23574: NPUTF8*
23574: NPN_UTF8FromIdentifier(NPIdentifier identifier)
23574: {
23574:   return sBrowserFuncs->utf8fromidentifier(identifier);
23574: }
23574: 
23574: int32_t
23574: NPN_IntFromIdentifier(NPIdentifier identifier)
23574: {
23574:   return sBrowserFuncs->intfromidentifier(identifier);
23574: }
23574: 
23574: NPError
23574: NPN_GetValue(NPP instance, NPNVariable variable, void* value)
23574: {
23574:   return sBrowserFuncs->getvalue(instance, variable, value);
23574: }
23574: 
23574: NPError
23574: NPN_SetValue(NPP instance, NPPVariable variable, void* value)
23574: {
23574:   return sBrowserFuncs->setvalue(instance, variable, value);
23574: }
23574: 
33861: void
33861: NPN_InvalidateRect(NPP instance, NPRect* rect)
33861: {
33861:   sBrowserFuncs->invalidaterect(instance, rect);
33861: }
33861: 
23574: bool
23574: NPN_HasProperty(NPP instance, NPObject* obj, NPIdentifier propertyName)
23574: {
23574:   return sBrowserFuncs->hasproperty(instance, obj, propertyName);
23574: }
23574: 
23574: NPObject*
23574: NPN_CreateObject(NPP instance, NPClass* aClass)
23574: {
23574:   return sBrowserFuncs->createobject(instance, aClass);
23574: }
23574: 
29937: bool
29937: NPN_Invoke(NPP npp, NPObject* obj, NPIdentifier methodName, const NPVariant *args, uint32_t argCount, NPVariant *result)
29937: {
29937:   return sBrowserFuncs->invoke(npp, obj, methodName, args, argCount, result);
29937: }
29937: 
33771: bool
33771: NPN_InvokeDefault(NPP npp, NPObject* obj, const NPVariant *args, uint32_t argCount, NPVariant *result)
33771: {
33771:   return sBrowserFuncs->invokeDefault(npp, obj, args, argCount, result);
33771: }
33771: 
57514: bool
57514: NPN_Construct(NPP npp, NPObject* npobj, const NPVariant* args,
57514: 	      uint32_t argCount, NPVariant* result)
57514: {
57514:   return sBrowserFuncs->construct(npp, npobj, args, argCount, result);
57514: }
57514: 
23574: const char*
23574: NPN_UserAgent(NPP instance)
23574: {
23574:   return sBrowserFuncs->uagent(instance);
23574: }
23574: 
23574: NPObject*
23574: NPN_RetainObject(NPObject* obj)
23574: {
23574:   return sBrowserFuncs->retainobject(obj);
23574: }
23574: 
23574: void
23574: NPN_ReleaseObject(NPObject* obj)
23574: {
23574:   return sBrowserFuncs->releaseobject(obj);
23574: }
23574: 
23574: void*
23574: NPN_MemAlloc(uint32_t size)
23574: {
23574:   return sBrowserFuncs->memalloc(size);
23574: }
23574: 
42123: char*
42123: NPN_StrDup(const char* str)
42123: {
42123:   return strcpy((char*)sBrowserFuncs->memalloc(strlen(str) + 1), str);
42123: }
42123: 
23574: void
23574: NPN_MemFree(void* ptr)
23574: {
23574:   return sBrowserFuncs->memfree(ptr);
23574: }
23574: 
29937: uint32_t
29937: NPN_ScheduleTimer(NPP instance, uint32_t interval, NPBool repeat, void (*timerFunc)(NPP npp, uint32_t timerID))
29937: {
29937:   return sBrowserFuncs->scheduletimer(instance, interval, repeat, timerFunc);
29937: }
29937: 
29937: void
29937: NPN_UnscheduleTimer(NPP instance, uint32_t timerID)
29937: {
29937:   return sBrowserFuncs->unscheduletimer(instance, timerID);
29937: }
29937: 
29937: void
29937: NPN_ReleaseVariantValue(NPVariant *variant)
29937: {
29937:   return sBrowserFuncs->releasevariantvalue(variant);
29937: }
29937: 
32918: NPError
32918: NPN_GetURLNotify(NPP instance, const char* url, const char* target, void* notifyData)
32918: {
32918:   return sBrowserFuncs->geturlnotify(instance, url, target, notifyData);
32918: }
32918: 
32918: NPError
32918: NPN_GetURL(NPP instance, const char* url, const char* target)
32918: {
32918:   return sBrowserFuncs->geturl(instance, url, target);
32918: }
32918: 
32918: NPError
32918: NPN_RequestRead(NPStream* stream, NPByteRange* rangeList)
32918: {
32918:   return sBrowserFuncs->requestread(stream, rangeList);
32918: }
32918: 
32918: NPError
32918: NPN_PostURLNotify(NPP instance, const char* url, 
32918:                   const char* target, uint32_t len, 
32918:                   const char* buf, NPBool file, void* notifyData)
32918: {
32918:   return sBrowserFuncs->posturlnotify(instance, url, target, len, buf, file, notifyData);
32918: }
32918: 
32918: NPError 
32918: NPN_PostURL(NPP instance, const char *url,
32918:                     const char *target, uint32_t len,
32918:                     const char *buf, NPBool file)
32918: {
32918:   return sBrowserFuncs->posturl(instance, url, target, len, buf, file);
32918: }
32918: 
32918: NPError
32918: NPN_DestroyStream(NPP instance, NPStream* stream, NPError reason)
32918: {
32918:   return sBrowserFuncs->destroystream(instance, stream, reason);
32918: }
32918: 
33296: NPError
33296: NPN_NewStream(NPP instance, 
33296:               NPMIMEType  type, 
33296:               const char* target,
33296:               NPStream**  stream)
33296: {
33296:   return sBrowserFuncs->newstream(instance, type, target, stream);
33296: }
33296: 
33296: int32_t
33296: NPN_Write(NPP instance,
33296:           NPStream* stream,
33296:           int32_t len,
33296:           void* buf)
33296: {
33296:   return sBrowserFuncs->write(instance, stream, len, buf);
33296: }
33296: 
33631: bool
33631: NPN_Enumerate(NPP instance,
33631:               NPObject *npobj,
33631:               NPIdentifier **identifiers,
33631:               uint32_t *identifierCount)
33631: {
33631:   return sBrowserFuncs->enumerate(instance, npobj, identifiers, 
33631:       identifierCount);
33631: }
33631: 
33631: bool
33631: NPN_GetProperty(NPP instance,
33631:                 NPObject *npobj,
33631:                 NPIdentifier propertyName,
33631:                 NPVariant *result)
33631: {
33631:   return sBrowserFuncs->getproperty(instance, npobj, propertyName, result);
33631: }
33631: 
34142: bool
34142: NPN_Evaluate(NPP instance, NPObject *npobj, NPString *script, NPVariant *result)
34142: {
34142:   return sBrowserFuncs->evaluate(instance, npobj, script, result);
34142: }
34142: 
34018: void
34018: NPN_SetException(NPObject *npobj, const NPUTF8 *message)
34018: {
34018:   return sBrowserFuncs->setexception(npobj, message);
34018: }
34018: 
34693: NPBool
34693: NPN_ConvertPoint(NPP instance, double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace)
34693: {
34693:   return sBrowserFuncs->convertpoint(instance, sourceX, sourceY, sourceSpace, destX, destY, destSpace);
34693: }
34693: 
37325: NPError
37325: NPN_SetValueForURL(NPP instance, NPNURLVariable variable, const char *url, const char *value, uint32_t len)
37325: {
37325:   return sBrowserFuncs->setvalueforurl(instance, variable, url, value, len);
37325: }
37325: 
37325: NPError
37325: NPN_GetValueForURL(NPP instance, NPNURLVariable variable, const char *url, char **value, uint32_t *len)
37325: {
37325:   return sBrowserFuncs->getvalueforurl(instance, variable, url, value, len);
37325: }
37325: 
37391: NPError
37391: NPN_GetAuthenticationInfo(NPP instance,
37391:                           const char *protocol,
37391:                           const char *host, int32_t port,
37391:                           const char *scheme,
37391:                           const char *realm,
37391:                           char **username, uint32_t *ulen,
37391:                           char **password,
37391:                           uint32_t *plen)
37391: {
37391:   return sBrowserFuncs->getauthenticationinfo(instance, protocol, host, port, scheme, realm,
37391:       username, ulen, password, plen);
37391: }
37391: 
37426: void
37426: NPN_PluginThreadAsyncCall(NPP plugin, void (*func)(void*), void* userdata)
37426: {
37426:   return sBrowserFuncs->pluginthreadasynccall(plugin, func, userdata);
37426: }
37426: 
60022: void
60022: NPN_URLRedirectResponse(NPP instance, void* notifyData, NPBool allow)
60022: {
60022:   return sBrowserFuncs->urlredirectresponse(instance, notifyData, allow);
60022: }
60022: 
23574: //
23574: // npruntime object functions
23574: //
23574: 
23574: NPObject*
23574: scriptableAllocate(NPP npp, NPClass* aClass)
23574: {
23574:   TestNPObject* object = (TestNPObject*)NPN_MemAlloc(sizeof(TestNPObject));
23574:   if (!object)
23574:     return NULL;
23574:   memset(object, 0, sizeof(TestNPObject));
23574:   return object;
23574: }
23574: 
23574: void
23574: scriptableDeallocate(NPObject* npobj)
23574: {
23574:   NPN_MemFree(npobj);
23574: }
23574: 
23574: void
23574: scriptableInvalidate(NPObject* npobj)
23574: {
23574: }
23574: 
23574: bool
23574: scriptableHasMethod(NPObject* npobj, NPIdentifier name)
23574: {
26942:   for (int i = 0; i < int(ARRAY_LENGTH(sPluginMethodIdentifiers)); i++) {
23574:     if (name == sPluginMethodIdentifiers[i])
23574:       return true;
23574:   }
23574:   return false;
23574: }
23574: 
23574: bool
23574: scriptableInvoke(NPObject* npobj, NPIdentifier name, const NPVariant* args, uint32_t argCount, NPVariant* result)
23574: {
34018:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34018:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
34018:   if (id->throwOnNextInvoke) {
34018:     id->throwOnNextInvoke = false;
34018:     if (argCount == 0) {
34018:       NPN_SetException(npobj, NULL);
34018:     }
34018:     else {
34018:       for (uint32_t i = 0; i < argCount; i++) {
34018:         const NPString* argstr = &NPVARIANT_TO_STRING(args[i]);
34018:         NPN_SetException(npobj, argstr->UTF8Characters);
34018:       }
34018:     }
34018:     return false;
34018:   }
34018:   
26942:   for (int i = 0; i < int(ARRAY_LENGTH(sPluginMethodIdentifiers)); i++) {
26802:     if (name == sPluginMethodIdentifiers[i])
26802:       return sPluginMethodFunctions[i](npobj, args, argCount, result);
26802:   }
23574:   return false;
23574: }
23574: 
23574: bool
23574: scriptableInvokeDefault(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
23574: {
34018:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34018:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
34018:   if (id->throwOnNextInvoke) {
34018:     id->throwOnNextInvoke = false;
34018:     if (argCount == 0) {
34018:       NPN_SetException(npobj, NULL);
34018:     }
34018:     else {
34018:       for (uint32_t i = 0; i < argCount; i++) {
34018:         const NPString* argstr = &NPVARIANT_TO_STRING(args[i]);
34018:         NPN_SetException(npobj, argstr->UTF8Characters);
34018:       }
34018:     }
34018:     return false;
34018:   }
34018: 
33921:   ostringstream value;
33921:   value << PLUGIN_NAME;
33921:   for (uint32_t i = 0; i < argCount; i++) {
33921:     switch(args[i].type) {
33921:       case NPVariantType_Int32:
33921:         value << ";" << NPVARIANT_TO_INT32(args[i]);
33921:         break;
33921:       case NPVariantType_String: {
33921:         const NPString* argstr = &NPVARIANT_TO_STRING(args[i]);
33921:         value << ";" << argstr->UTF8Characters;
33921:         break;
33921:       }
33921:       case NPVariantType_Void:
33921:         value << ";undefined";
33921:         break;
33921:       case NPVariantType_Null:
33921:         value << ";null";
33921:         break;
33921:       default:
33921:         value << ";other";
33921:     }
33921:   }
42123:   STRINGZ_TO_NPVARIANT(NPN_StrDup(value.str().c_str()), *result);
33921:   return true;
23574: }
23574: 
23574: bool
23574: scriptableHasProperty(NPObject* npobj, NPIdentifier name)
23574: {
48301:   if (NPN_IdentifierIsString(name)) {
48301:     if (NPN_GetStringIdentifier(NPN_UTF8FromIdentifier(name)) != name)
48301:       Crash();
48301:   }
48301:   else {
48301:     if (NPN_GetIntIdentifier(NPN_IntFromIdentifier(name)) != name)
48301:       Crash();
48301:   }
40566:   for (int i = 0; i < int(ARRAY_LENGTH(sPluginPropertyIdentifiers)); i++) {
40566:     if (name == sPluginPropertyIdentifiers[i])
40566:       return true;
40566:   }
23574:   return false;
23574: }
23574: 
23574: bool
23574: scriptableGetProperty(NPObject* npobj, NPIdentifier name, NPVariant* result)
23574: {
40566:   for (int i = 0; i < int(ARRAY_LENGTH(sPluginPropertyIdentifiers)); i++) {
40566:     if (name == sPluginPropertyIdentifiers[i]) {
40566:       DuplicateNPVariant(*result, sPluginPropertyValues[i]);
40566:       return true;
40566:     }
40566:   }
23574:   return false;
23574: }
23574: 
23574: bool
23574: scriptableSetProperty(NPObject* npobj, NPIdentifier name, const NPVariant* value)
23574: {
40566:   for (int i = 0; i < int(ARRAY_LENGTH(sPluginPropertyIdentifiers)); i++) {
40566:     if (name == sPluginPropertyIdentifiers[i]) {
40566:       NPN_ReleaseVariantValue(&sPluginPropertyValues[i]);
40566:       DuplicateNPVariant(sPluginPropertyValues[i], *value);
40566:       return true;
40566:     }
40566:   }
23574:   return false;
23574: }
23574: 
23574: bool
23574: scriptableRemoveProperty(NPObject* npobj, NPIdentifier name)
23574: {
40566:   for (int i = 0; i < int(ARRAY_LENGTH(sPluginPropertyIdentifiers)); i++) {
40566:     if (name == sPluginPropertyIdentifiers[i]) {
40566:       NPN_ReleaseVariantValue(&sPluginPropertyValues[i]);
40566:       return true;
40566:     }
40566:   }
23574:   return false;
23574: }
23574: 
23574: bool
23574: scriptableEnumerate(NPObject* npobj, NPIdentifier** identifier, uint32_t* count)
23574: {
42018:   const int bufsize = sizeof(NPIdentifier) * ARRAY_LENGTH(sPluginMethodIdentifierNames);
42018:   NPIdentifier* ids = (NPIdentifier*) NPN_MemAlloc(bufsize);
42018:   if (!ids)
23574:     return false;
42018: 
42018:   memcpy(ids, sPluginMethodIdentifiers, bufsize);
42018:   *identifier = ids;
42018:   *count = ARRAY_LENGTH(sPluginMethodIdentifierNames);
42018:   return true;
23574: }
23574: 
23574: bool
23574: scriptableConstruct(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
23574: {
23574:   return false;
23574: }
23574: 
23574: //
23574: // test functions
23574: //
23574: 
26802: static bool
33631: compareVariants(NPP instance, const NPVariant* var1, const NPVariant* var2)
33631: {
33631:   bool success = true;
33631:   InstanceData* id = static_cast<InstanceData*>(instance->pdata);
33631:   if (var1->type != var2->type) {
33631:     id->err << "Variant types don't match; got " << var1->type <<
33631:         " expected " << var2->type;
33631:     return false;
33631:   }
33631:   
33631:   switch (var1->type) {
33631:     case NPVariantType_Int32: {
33631:         int32_t result = NPVARIANT_TO_INT32(*var1);
33631:         int32_t expected = NPVARIANT_TO_INT32(*var2);
33631:         if (result != expected) {
33631:           id->err << "Variant values don't match; got " << result <<
33631:               " expected " << expected;
33631:           success = false;
33631:         }
33631:         break;
33631:       }
33631:     case NPVariantType_Double: {
33631:         double result = NPVARIANT_TO_DOUBLE(*var1);
33631:         double expected = NPVARIANT_TO_DOUBLE(*var2);
33631:         if (result != expected) {
33631:           id->err << "Variant values don't match (double)";
33631:           success = false;
33631:         }
33631:         break;
33631:       }
33631:     case NPVariantType_Void: {
33631:         // void values are always equivalent
33631:         break;
33631:       }
33631:     case NPVariantType_Null: {
33631:         // null values are always equivalent
33631:         break;
33631:       }
33631:     case NPVariantType_Bool: {
33631:         bool result = NPVARIANT_TO_BOOLEAN(*var1);
33631:         bool expected = NPVARIANT_TO_BOOLEAN(*var2);
33631:         if (result != expected) {
33631:           id->err << "Variant values don't match (bool)";
33631:           success = false;
33631:         }
33631:         break;
33631:       }
33631:     case NPVariantType_String: {
33631:         const NPString* result = &NPVARIANT_TO_STRING(*var1);
33631:         const NPString* expected = &NPVARIANT_TO_STRING(*var2);
33631:         if (strcmp(result->UTF8Characters, expected->UTF8Characters) ||
33631:             strlen(result->UTF8Characters) != strlen(expected->UTF8Characters)) {
33631:           id->err << "Variant values don't match; got " << 
33631:               result->UTF8Characters << " expected " << 
33631:               expected->UTF8Characters;
33631:           success = false;
33631:         }
33631:         break;
33631:       }
33631:     case NPVariantType_Object: {
33631:         uint32_t i, identifierCount = 0;
33631:         NPIdentifier* identifiers;
33631:         NPObject* result = NPVARIANT_TO_OBJECT(*var1);
33631:         NPObject* expected = NPVARIANT_TO_OBJECT(*var2);
33631:         bool enumerate_result = NPN_Enumerate(instance, expected,
33631:             &identifiers, &identifierCount);
33631:         if (!enumerate_result) {
33631:           id->err << "NPN_Enumerate failed";
33631:           success = false;
33631:         }
33631:         for (i = 0; i < identifierCount; i++) {
33631:           NPVariant resultVariant, expectedVariant;
33631:           if (!NPN_GetProperty(instance, expected, identifiers[i],
33631:               &expectedVariant)) {
33631:             id->err << "NPN_GetProperty returned false";
33631:             success = false;
33631:           }
33631:           else {
33631:             if (!NPN_HasProperty(instance, result, identifiers[i])) {
33631:               id->err << "NPN_HasProperty returned false";
33631:               success = false;
33631:             }
33631:             else {
33631:               if (!NPN_GetProperty(instance, result, identifiers[i],
33631:               &resultVariant)) {
33631:                 id->err << "NPN_GetProperty 2 returned false";
33631:                 success = false;
33631:               }
33631:               else {
33631:                 success = compareVariants(instance, &resultVariant, 
33631:                     &expectedVariant);
33631:                 NPN_ReleaseVariantValue(&expectedVariant);
33631:               }
33631:             }
33631:             NPN_ReleaseVariantValue(&resultVariant);
33631:           }
33631:         }
33631:         break;
33631:       }
33631:     default:
33631:       id->err << "Unknown variant type";
33631:       success = false;
33631:   }
33631:   
33631:   return success;
33631: }
33631: 
33631: static bool
34018: throwExceptionNextInvoke(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
34018: {
34018:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34018:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
34018:   id->throwOnNextInvoke = true;
34018:   BOOLEAN_TO_NPVARIANT(true, *result);
34018:   return true;  
34018: }
34018: 
34018: static bool
33771: npnInvokeDefaultTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
33771: {
33771:   bool success = false;
33771:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
33771:  
33771:   NPObject* windowObject;
33771:   NPN_GetValue(npp, NPNVWindowNPObject, &windowObject);
33771:   if (!windowObject)
33771:     return false;
33771: 
33771:   NPIdentifier objectIdentifier = variantToIdentifier(args[0]);
33771:   if (!objectIdentifier)
33771:     return false;
33771: 
33771:   NPVariant objectVariant;
33771:   if (NPN_GetProperty(npp, windowObject, objectIdentifier,
33771:       &objectVariant)) {
33771:     if (NPVARIANT_IS_OBJECT(objectVariant)) {
33771:       NPObject* selfObject = NPVARIANT_TO_OBJECT(objectVariant);
33771:       if (selfObject != NULL) {
33771:         NPVariant resultVariant;
33966:         if (NPN_InvokeDefault(npp, selfObject, argCount > 1 ? &args[1] : NULL, 
33966:             argCount - 1, &resultVariant)) {
33771:           *result = resultVariant;
33771:           success = true;
33771:         }
33771:       }
33771:     }
33771:     NPN_ReleaseVariantValue(&objectVariant);
33771:   }
33771: 
33771:   NPN_ReleaseObject(windowObject);
33771:   return success;
33771: }
33771: 
33771: static bool
33631: npnInvokeTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
33631: {
33631:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
33631:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
33631:   id->err.str("");
33631:   if (argCount < 2)
33631:     return false;
33631: 
33631:   NPIdentifier function = variantToIdentifier(args[0]);
33631:   if (!function)
33631:     return false;
33631:   
33631:   NPObject* windowObject;
33631:   NPN_GetValue(npp, NPNVWindowNPObject, &windowObject);
33631:   if (!windowObject)
33631:     return false;
33631:   
33631:   NPVariant invokeResult;
33631:   bool invokeReturn = NPN_Invoke(npp, windowObject, function,
33631:       argCount > 2 ? &args[2] : NULL, argCount - 2, &invokeResult);
33631:       
33631:   bool compareResult = compareVariants(npp, &invokeResult, &args[1]);
33631:       
33631:   NPN_ReleaseObject(windowObject);
33631:   NPN_ReleaseVariantValue(&invokeResult);
33631:   BOOLEAN_TO_NPVARIANT(invokeReturn && compareResult, *result);
33631:   return true;
33631: }
33631: 
33631: static bool
34142: npnEvaluateTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
34142: {
34142:   bool success = false;
34142:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34142:   
34142:   if (argCount != 1)
34142:     return false;
34142:   
34142:   if (!NPVARIANT_IS_STRING(args[0]))
34142:     return false;
34142: 
34142:   NPObject* windowObject;
34142:   NPN_GetValue(npp, NPNVWindowNPObject, &windowObject);
34142:   if (!windowObject)
34142:     return false;
34142:   
34142:   success = NPN_Evaluate(npp, windowObject, (NPString*)&NPVARIANT_TO_STRING(args[0]), result);
34142:   
34142:   NPN_ReleaseObject(windowObject);
34142:   return success;
34142: }
34142: 
34142: static bool
27202: setUndefinedValueTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
27202: {
27202:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
27202:   NPError err = NPN_SetValue(npp, (NPPVariable)0x0, 0x0);
27202:   BOOLEAN_TO_NPVARIANT((err == NPERR_NO_ERROR), *result);
27202:   return true;
27202: }
27202: 
27202: static bool
24475: identifierToStringTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
23574: {
23574:   if (argCount != 1)
23574:     return false;
23574:   NPIdentifier identifier = variantToIdentifier(args[0]);
23574:   if (!identifier)
23574:     return false;
26942: 
23574:   NPUTF8* utf8String = NPN_UTF8FromIdentifier(identifier);
23574:   if (!utf8String)
23574:     return false;
23574:   STRINGZ_TO_NPVARIANT(utf8String, *result);
23574:   return true;
23574: }
24475: 
26802: static bool
24475: queryPrivateModeState(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
24475: {
26942:   if (argCount != 0)
26942:     return false;
26942: 
24475:   NPBool pms = false;
24475:   NPN_GetValue(static_cast<TestNPObject*>(npobj)->npp, NPNVprivateModeBool, &pms);
24475:   BOOLEAN_TO_NPVARIANT(pms, *result);
24475:   return true;
24475: }
24475: 
26802: static bool
24475: lastReportedPrivateModeState(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
24475: {
26942:   if (argCount != 0)
26942:     return false;
26942: 
24475:   InstanceData* id = static_cast<InstanceData*>(static_cast<TestNPObject*>(npobj)->npp->pdata);
26802:   BOOLEAN_TO_NPVARIANT(id->lastReportedPrivateModeState, *result);
24475:   return true;
24475: }
26802: 
26802: static bool
26802: hasWidget(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
26802: {
26942:   if (argCount != 0)
26942:     return false;
26942: 
26802:   InstanceData* id = static_cast<InstanceData*>(static_cast<TestNPObject*>(npobj)->npp->pdata);
26802:   BOOLEAN_TO_NPVARIANT(id->hasWidget, *result);
26802:   return true;
26802: }
26942: 
26942: static bool
26942: getEdge(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
26942: {
26942:   if (argCount != 1)
26942:     return false;
26942:   if (!NPVARIANT_IS_INT32(args[0]))
26942:     return false;
26942:   int32_t edge = NPVARIANT_TO_INT32(args[0]);
26942:   if (edge < EDGE_LEFT || edge > EDGE_BOTTOM)
26942:     return false;
26942: 
26942:   InstanceData* id = static_cast<InstanceData*>(static_cast<TestNPObject*>(npobj)->npp->pdata);
26942:   int32_t r = pluginGetEdge(id, RectEdge(edge));
26942:   if (r == NPTEST_INT32_ERROR)
26942:     return false;
26942:   INT32_TO_NPVARIANT(r, *result);
26942:   return true;
26942: }
26942: 
26942: static bool
26942: getClipRegionRectCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
26942: {
26942:   if (argCount != 0)
26942:     return false;
26942: 
26942:   InstanceData* id = static_cast<InstanceData*>(static_cast<TestNPObject*>(npobj)->npp->pdata);
26942:   int32_t r = pluginGetClipRegionRectCount(id);
26942:   if (r == NPTEST_INT32_ERROR)
26942:     return false;
26942:   INT32_TO_NPVARIANT(r, *result);
26942:   return true;
26942: }
26942: 
26942: static bool
26942: getClipRegionRectEdge(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
26942: {
26942:   if (argCount != 2)
26942:     return false;
26942:   if (!NPVARIANT_IS_INT32(args[0]))
26942:     return false;
26942:   int32_t rectIndex = NPVARIANT_TO_INT32(args[0]);
26942:   if (rectIndex < 0)
26942:     return false;
26942:   if (!NPVARIANT_IS_INT32(args[1]))
26942:     return false;
26942:   int32_t edge = NPVARIANT_TO_INT32(args[1]);
26942:   if (edge < EDGE_LEFT || edge > EDGE_BOTTOM)
26942:     return false;
26942: 
26942:   InstanceData* id = static_cast<InstanceData*>(static_cast<TestNPObject*>(npobj)->npp->pdata);
26942:   int32_t r = pluginGetClipRegionRectEdge(id, rectIndex, RectEdge(edge));
26942:   if (r == NPTEST_INT32_ERROR)
26942:     return false;
26942:   INT32_TO_NPVARIANT(r, *result);
26942:   return true;
26942: }
28108: 
28108: static bool
28108: startWatchingInstanceCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
28108: {
28108:   if (argCount != 0)
28108:     return false;
28108:   if (sWatchingInstanceCount)
28108:     return false;
28108: 
28108:   sWatchingInstanceCount = true;
28108:   sInstanceCount = 0;
28108:   ++sCurrentInstanceCountWatchGeneration;
28108:   return true;
28108: }
28108: 
28108: static bool
28108: getInstanceCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
28108: {
28108:   if (argCount != 0)
28108:     return false;
28108:   if (!sWatchingInstanceCount)
28108:     return false;
28108: 
28108:   INT32_TO_NPVARIANT(sInstanceCount, *result);
28108:   return true;
28108: }
28108: 
28108: static bool
28108: stopWatchingInstanceCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
28108: {
28108:   if (argCount != 0)
28108:     return false;
28108:   if (!sWatchingInstanceCount)
28108:     return false;
28108: 
28108:   sWatchingInstanceCount = false;
28108:   return true;
28108: }
29937: 
29937: static bool
31130: getLastMouseX(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
31130: {
31130:   if (argCount != 0)
31130:     return false;
31130: 
31130:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
31130:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
31130:   INT32_TO_NPVARIANT(id->lastMouseX, *result);
31130:   return true;
31130: }
31130: 
31130: static bool
31130: getLastMouseY(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
31130: {
31130:   if (argCount != 0)
31130:     return false;
31130: 
31130:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
31130:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
31130:   INT32_TO_NPVARIANT(id->lastMouseY, *result);
31130:   return true;
31130: }
33296: 
33296: static bool
34501: getPaintCount(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
34501: {
34501:   if (argCount != 0)
34501:     return false;
34501: 
34501:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34501:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
34501:   INT32_TO_NPVARIANT(id->paintCount, *result);
34501:   return true;
34501: }
34501: 
34501: static bool
36907: getWidthAtLastPaint(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
36907: {
36907:   if (argCount != 0)
36907:     return false;
36907: 
36907:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
36907:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
36907:   INT32_TO_NPVARIANT(id->widthAtLastPaint, *result);
36907:   return true;
36907: }
36907: 
36907: static bool
47770: setInvalidateDuringPaint(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
47770: {
47770:   if (argCount != 1)
47770:     return false;
47770: 
47770:   if (!NPVARIANT_IS_BOOLEAN(args[0]))
47770:     return false;
47770:   bool doInvalidate = NPVARIANT_TO_BOOLEAN(args[0]);
47770: 
47770:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
47770:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
47770:   id->invalidateDuringPaint = doInvalidate;
47770:   return true;
47770: }
47770: 
47770: static bool
33296: getError(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
33296: {
33358:   if (argCount != 0)
33358:     return false;
33358: 
33296:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
33296:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41716:   if (id->err.str().length() == 0)
42123:     STRINGZ_TO_NPVARIANT(NPN_StrDup(SUCCESS_STRING), *result);
41716:   else
42123:     STRINGZ_TO_NPVARIANT(NPN_StrDup(id->err.str().c_str()), *result);
33296:   return true;
33296: }
33358: 
33358: static bool
33358: doInternalConsistencyCheck(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
33358: {
33358:   if (argCount != 0)
33358:     return false;
33358: 
33358:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
33358:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
33358:   string error;
33358:   pluginDoInternalConsistencyCheck(id, error);
33358:   NPUTF8* utf8String = (NPUTF8*)NPN_MemAlloc(error.length() + 1);
33358:   if (!utf8String) {
33358:     return false;
33358:   }
33358:   memcpy(utf8String, error.c_str(), error.length() + 1);
33358:   STRINGZ_TO_NPVARIANT(utf8String, *result);
33358:   return true;
33358: }
33861: 
33861: static bool
34693: convertPointX(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
34693: {
34693:   if (argCount != 4)
34693:     return false;
34693: 
34693:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[0]))
34693:     return false;
34693:   int32_t sourceSpace = NPVARIANT_TO_INT32(args[0]);
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[1]))
34693:     return false;
34693:   double sourceX = static_cast<double>(NPVARIANT_TO_INT32(args[1]));
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[2]))
34693:     return false;
34693:   double sourceY = static_cast<double>(NPVARIANT_TO_INT32(args[2]));
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[3]))
34693:     return false;
34693:   int32_t destSpace = NPVARIANT_TO_INT32(args[3]);
34693: 
34693:   double resultX, resultY;
34693:   NPN_ConvertPoint(npp, sourceX, sourceY, (NPCoordinateSpace)sourceSpace, &resultX, &resultY, (NPCoordinateSpace)destSpace);
34693: 
34693:   DOUBLE_TO_NPVARIANT(resultX, *result);
34693:   return true;
34693: }
34693: 
34693: static bool
34693: convertPointY(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
34693: {
34693:   if (argCount != 4)
34693:     return false;
34693: 
34693:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[0]))
34693:     return false;
34693:   int32_t sourceSpace = NPVARIANT_TO_INT32(args[0]);
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[1]))
34693:     return false;
34693:   double sourceX = static_cast<double>(NPVARIANT_TO_INT32(args[1]));
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[2]))
34693:     return false;
34693:   double sourceY = static_cast<double>(NPVARIANT_TO_INT32(args[2]));
34693: 
34693:   if (!NPVARIANT_IS_INT32(args[3]))
34693:     return false;
34693:   int32_t destSpace = NPVARIANT_TO_INT32(args[3]);
34693: 
34693:   double resultX, resultY;
34693:   NPN_ConvertPoint(npp, sourceX, sourceY, (NPCoordinateSpace)sourceSpace, &resultX, &resultY, (NPCoordinateSpace)destSpace);
34693:   
34693:   DOUBLE_TO_NPVARIANT(resultY, *result);
34693:   return true;
34693: }
34693: 
34693: static bool
36110: streamTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
36110: {
60481:   // .streamTest(url, doPost, doNull, writeCallback, notifyCallback, redirectCallback, allowRedirects)
60481:   if (7 != argCount)
36110:     return false;
36110: 
36110:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
36110: 
36110:   if (!NPVARIANT_IS_STRING(args[0]))
36110:     return false;
36110:   NPString url = NPVARIANT_TO_STRING(args[0]);
36110: 
36110:   if (!NPVARIANT_IS_BOOLEAN(args[1]))
36110:     return false;
36110:   bool doPost = NPVARIANT_TO_BOOLEAN(args[1]);
36110: 
36110:   NPString postData = { NULL, 0 };
60481:   if (NPVARIANT_IS_STRING(args[2])) {
36110:     postData = NPVARIANT_TO_STRING(args[2]);
36110:   }
36110:   else {
60481:     if (!NPVARIANT_IS_NULL(args[2])) {
36110:       return false;
36110:     }
60481:   }
36110: 
60022:   NPObject* writeCallback = NULL;
60481:   if (NPVARIANT_IS_OBJECT(args[3])) {
60022:     writeCallback = NPVARIANT_TO_OBJECT(args[3]);
60022:   }
60022:   else {
60481:     if (!NPVARIANT_IS_NULL(args[3])) {
36110:       return false;
60022:     }
60481:   }
60481: 
60481:   NPObject* notifyCallback = NULL;
60481:   if (NPVARIANT_IS_OBJECT(args[4])) {
60481:     notifyCallback = NPVARIANT_TO_OBJECT(args[4]);
60481:   }
60481:   else {
60481:     if (!NPVARIANT_IS_NULL(args[4])) {
60022:       return false;
60481:     }
60481:   }
60481: 
60481:   NPObject* redirectCallback = NULL;
60481:   if (NPVARIANT_IS_OBJECT(args[5])) {
60481:     redirectCallback = NPVARIANT_TO_OBJECT(args[5]);
60481:   }
60481:   else {
60481:     if (!NPVARIANT_IS_NULL(args[5])) {
60022:       return false;
60481:     }
60481:   }
60481: 
60481:   if (!NPVARIANT_IS_BOOLEAN(args[6]))
60481:     return false;
60481:   bool allowRedirects = NPVARIANT_TO_BOOLEAN(args[6]);
36110: 
36110:   URLNotifyData* ndata = new URLNotifyData;
36110:   ndata->cookie = "dynamic-cookie";
60022:   ndata->writeCallback = writeCallback;
60022:   ndata->notifyCallback = notifyCallback;
60481:   ndata->redirectCallback = redirectCallback;
36110:   ndata->size = 0;
36110:   ndata->data = NULL;
60022:   ndata->allowRedirects = allowRedirects;
36110: 
36110:   /* null-terminate "url" */
36110:   char* urlstr = (char*) malloc(url.UTF8Length + 1);
36110:   strncpy(urlstr, url.UTF8Characters, url.UTF8Length);
36110:   urlstr[url.UTF8Length] = '\0';
36110: 
36110:   NPError err;
36110:   if (doPost) {
36110:     err = NPN_PostURLNotify(npp, urlstr, NULL,
36110:                             postData.UTF8Length, postData.UTF8Characters,
36110:                             false, ndata);
36110:   }
36110:   else {
36110:     err = NPN_GetURLNotify(npp, urlstr, NULL, ndata);
36110:   }
36110: 
36110:   free(urlstr);
36110: 
36110:   if (NPERR_NO_ERROR == err) {
60022:     if (ndata->writeCallback) {
60022:       NPN_RetainObject(ndata->writeCallback);
60022:     }
60481:     if (ndata->notifyCallback) {
60022:       NPN_RetainObject(ndata->notifyCallback);
60481:     }
60481:     if (ndata->redirectCallback) {
60481:       NPN_RetainObject(ndata->redirectCallback);
60481:     }
36110:     BOOLEAN_TO_NPVARIANT(true, *result);
36110:   }
36110:   else {
36110:     delete ndata;
36110:     BOOLEAN_TO_NPVARIANT(false, *result);
36110:   }
36110: 
36110:   return true;
36110: }
36110: 
36110: static bool
36163: crashPlugin(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
36155: {
37560:   IntentionalCrash();
36611:   VOID_TO_NPVARIANT(*result);
36611:   return true;
36169: }
36611: 
36611: static bool
36611: crashOnDestroy(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
36611: {
36611:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
36611:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
36611: 
36611:   id->crashOnDestroy = true;
36611:   VOID_TO_NPVARIANT(*result);
36155:   return true;
36155: }
36155: 
36155: static bool
33861: setColor(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
33861: {
33861:   if (argCount != 1)
33861:     return false;
33861:   if (!NPVARIANT_IS_STRING(args[0]))
33861:     return false;
33861:   const NPString* str = &NPVARIANT_TO_STRING(args[0]);
33861: 
33861:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
33861:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
33861: 
33861:   id->scriptableObject->drawColor =
33861:     parseHexColor(str->UTF8Characters, str->UTF8Length);
33861: 
33861:   NPRect r;
33861:   r.left = 0;
33861:   r.top = 0;
33861:   r.right = id->window.width;
33861:   r.bottom = id->window.height;
33861:   NPN_InvalidateRect(npp, &r);
33861: 
36064:   VOID_TO_NPVARIANT(*result);
33861:   return true;
33861: }
36907: 
36907: void notifyDidPaint(InstanceData* instanceData)
36907: {
36907:   ++instanceData->paintCount;
36907:   instanceData->widthAtLastPaint = instanceData->window.width;
47770: 
47770:   if (instanceData->invalidateDuringPaint) {
47770:     NPRect r;
47770:     r.left = 0;
47770:     r.top = 0;
47770:     r.right = instanceData->window.width;
47770:     r.bottom = instanceData->window.height;
47770:     NPN_InvalidateRect(instanceData->npp, &r);
47770:   }
54262: 
54262:   if (instanceData->runScriptOnPaint) {
54262:     NPObject* o = NULL;
54262:     NPN_GetValue(instanceData->npp, NPNVPluginElementNPObject, &o);
54262:     if (o) {
54262:       NPVariant param;
54262:       STRINGZ_TO_NPVARIANT("paintscript", param);
54262:       NPVariant result;
54262:       NPN_Invoke(instanceData->npp, o, NPN_GetStringIdentifier("getAttribute"),
54262:                  &param, 1, &result);
54262: 
54262:       if (NPVARIANT_IS_STRING(result)) {
54262:         NPObject* windowObject;
54262:         NPN_GetValue(instanceData->npp, NPNVWindowNPObject, &windowObject);
54262:         if (windowObject) {
54262:           NPVariant evalResult;
54262:           NPN_Evaluate(instanceData->npp, windowObject,
54262:                        (NPString*)&NPVARIANT_TO_STRING(result), &evalResult);
54262:           NPN_ReleaseVariantValue(&evalResult);
54262:           NPN_ReleaseObject(windowObject);
54262:         }
54262:       }
54262: 
54262:       NPN_ReleaseVariantValue(&result);
54262:       NPN_ReleaseObject(o);
54262:     }
54262:   }
36907: }
36929: 
36929: static const NPClass kTestSharedNPClass = {
36929:   NP_CLASS_STRUCT_VERSION,
36929:   // Everything else is NULL
36929: };
36929: 
36929: static bool getObjectValue(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
36929: {
36929:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
36929: 
36929:   NPObject* o = NPN_CreateObject(npp,
36929:                                  const_cast<NPClass*>(&kTestSharedNPClass));
36929:   if (!o)
36929:     return false;
36929: 
36929:   OBJECT_TO_NPVARIANT(o, *result);
36929:   return true;
36929: }
36929: 
36929: static bool checkObjectValue(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
36929: {
36929:   VOID_TO_NPVARIANT(*result);
36929: 
36929:   if (1 != argCount)
36929:     return false;
36929: 
36929:   if (!NPVARIANT_IS_OBJECT(args[0]))
36929:     return false;
36929: 
36929:   NPObject* o = NPVARIANT_TO_OBJECT(args[0]);
36929: 
36929:   BOOLEAN_TO_NPVARIANT(o->_class == &kTestSharedNPClass, *result);
36929:   return true;
36929: }
37101: 
37101: static bool enableFPExceptions(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
37101: {
37101:   VOID_TO_NPVARIANT(*result);
37101: 
37101: #if defined(XP_WIN) && defined(_M_IX86)
37101:   _control87(0, _MCW_EM);
37101:   return true;
37101: #else
37101:   return false;
37101: #endif
37101: }
37325: 
37325: // caller is responsible for freeing return buffer
37325: static char* URLForInstanceWindow(NPP instance) {
37325:   char *outString = NULL;
37325:   
37325:   NPObject* windowObject = NULL;
37325:   NPError err = NPN_GetValue(instance, NPNVWindowNPObject, &windowObject);
37325:   if (err != NPERR_NO_ERROR || !windowObject)
37325:     return NULL;
37325:   
37325:   NPIdentifier locationIdentifier = NPN_GetStringIdentifier("location");
37325:   NPVariant locationVariant;
37325:   if (NPN_GetProperty(instance, windowObject, locationIdentifier, &locationVariant)) {
37325:     NPObject *locationObject = locationVariant.value.objectValue;
37325:     if (locationObject) {
37325:       NPIdentifier hrefIdentifier = NPN_GetStringIdentifier("href");
37325:       NPVariant hrefVariant;
37325:       if (NPN_GetProperty(instance, locationObject, hrefIdentifier, &hrefVariant)) {
37325:         const NPString* hrefString = &NPVARIANT_TO_STRING(hrefVariant);
37325:         if (hrefString) {
37325:           outString = (char *)malloc(hrefString->UTF8Length + 1);
37325:           if (outString) {
37325:             strcpy(outString, hrefString->UTF8Characters);
37325:             outString[hrefString->UTF8Length] = '\0';
37325:           }
37325:         }
37325:         NPN_ReleaseVariantValue(&hrefVariant);
37325:       }      
37325:     }
37325:     NPN_ReleaseVariantValue(&locationVariant);
37325:   }
37325:   
37325:   NPN_ReleaseObject(windowObject);
37325:   
37325:   return outString;
37325: }
37325: 
37325: static bool
37325: setCookie(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
37325: {
37325:   if (argCount != 1)
37325:     return false;
37325:   if (!NPVARIANT_IS_STRING(args[0]))
37325:     return false;
37325:   const NPString* cookie = &NPVARIANT_TO_STRING(args[0]);
37325:   
37325:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37325:   
37325:   char* url = URLForInstanceWindow(npp);
37325:   if (!url)
37325:     return false;
37325:   NPError err = NPN_SetValueForURL(npp, NPNURLVCookie, url, cookie->UTF8Characters, cookie->UTF8Length);
37325:   free(url);
37325:   
37325:   return (err == NPERR_NO_ERROR);
37325: }
37325: 
37325: static bool
37325: getCookie(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
37325: {
37325:   if (argCount != 0)
37325:     return false;
37325:   
37325:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37325:   
37325:   char* url = URLForInstanceWindow(npp);
37325:   if (!url)
37325:     return false;
37325:   char* cookie = NULL;
37325:   unsigned int length = 0;
37325:   NPError err = NPN_GetValueForURL(npp, NPNURLVCookie, url, &cookie, &length);
37325:   free(url);
37325:   if (err != NPERR_NO_ERROR || !cookie)
37325:     return false;
37325:   
37325:   STRINGZ_TO_NPVARIANT(cookie, *result);
37325:   return true;
37325: }
37391: 
37391: static bool
37391: getAuthInfo(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
37391: {
37391:   if (argCount != 5)
37391:     return false;
37391: 
37391:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37391: 
37391:   if (!NPVARIANT_IS_STRING(args[0]) || !NPVARIANT_IS_STRING(args[1]) ||
37391:       !NPVARIANT_IS_INT32(args[2]) || !NPVARIANT_IS_STRING(args[3]) ||
37391:       !NPVARIANT_IS_STRING(args[4]))
37391:     return false;
37391: 
37391:   const NPString* protocol = &NPVARIANT_TO_STRING(args[0]);
37391:   const NPString* host = &NPVARIANT_TO_STRING(args[1]);
37391:   uint32_t port = NPVARIANT_TO_INT32(args[2]);
37391:   const NPString* scheme = &NPVARIANT_TO_STRING(args[3]);
37391:   const NPString* realm = &NPVARIANT_TO_STRING(args[4]);
37391: 
37391:   char* username = NULL;
37391:   char* password = NULL;
37391:   uint32_t ulen = 0, plen = 0;
37391:   
37391:   NPError err = NPN_GetAuthenticationInfo(npp, 
37391:       protocol->UTF8Characters, 
37391:       host->UTF8Characters, 
37391:       port, 
37391:       scheme->UTF8Characters, 
37391:       realm->UTF8Characters,
37391:       &username, 
37391:       &ulen, 
37391:       &password, 
37391:       &plen);
37391:   
37391:   if (err != NPERR_NO_ERROR) {
37391:     return false;
37391:   }
37391: 
37391:   char* outstring = (char*)NPN_MemAlloc(ulen + plen + 2);
37391:   memset(outstring, 0, ulen + plen + 2);
37391:   strncpy(outstring, username, ulen);
37391:   strcat(outstring, "|");
37391:   strncat(outstring, password, plen);
37391: 
37391:   STRINGZ_TO_NPVARIANT(outstring, *result);
37391: 
37391:   NPN_MemFree(username);
37391:   NPN_MemFree(password);
37391:   
37391:   return true;
37391: }
37426: 
37426: static void timerCallback(NPP npp, uint32_t timerID)
37426: {
37426:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
37426:   timerEventCount++;
37426:   timerEvent event = timerEvents[timerEventCount];
37426: 
37426:   NPObject* windowObject;
37426:   NPN_GetValue(npp, NPNVWindowNPObject, &windowObject);
37426:   if (!windowObject)
37426:     return;
37426: 
37426:   NPVariant rval;
37426:   if (timerID != id->timerID[event.timerIdReceive])
37426:     id->timerTestResult = false;
37426: 
37426:   if (timerEventCount == totalTimerEvents - 1) {
37426:     NPVariant arg;
37426:     BOOLEAN_TO_NPVARIANT(id->timerTestResult, arg);
37426:     NPN_Invoke(npp, windowObject, NPN_GetStringIdentifier(id->timerTestScriptCallback.c_str()), &arg, 1, &rval);
37426:     NPN_ReleaseVariantValue(&arg);
37426:   }
37426: 
37426:   NPN_ReleaseObject(windowObject);
37426:   
37426:   if (event.timerIdSchedule > -1) {
37426:     id->timerID[event.timerIdSchedule] = NPN_ScheduleTimer(npp, event.timerInterval, event.timerRepeat, timerCallback);
37426:   }
37426:   if (event.timerIdUnschedule > -1) {
37426:     NPN_UnscheduleTimer(npp, id->timerID[event.timerIdUnschedule]);
37426:   }
37426: }
37426: 
37426: static bool
37426: timerTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
37426: {
37426:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37426:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
37426:   timerEventCount = 0;
37426: 
37426:   if (argCount < 1 || !NPVARIANT_IS_STRING(args[0]))
37426:     return false;
37426:   const NPString* argstr = &NPVARIANT_TO_STRING(args[0]);
37426:   id->timerTestScriptCallback = argstr->UTF8Characters;
37426: 
37426:   id->timerTestResult = true;
37426:   timerEvent event = timerEvents[timerEventCount];
37426:     
37426:   id->timerID[event.timerIdSchedule] = NPN_ScheduleTimer(npp, event.timerInterval, event.timerRepeat, timerCallback);
37426:   
37426:   return id->timerID[event.timerIdSchedule] != 0;
37426: }
37426: 
37426: #ifdef XP_WIN
37426: void
37426: ThreadProc(void* cookie)
37426: #else
37426: void*
37426: ThreadProc(void* cookie)
37426: #endif
37426: {
37426:   NPObject* npobj = (NPObject*)cookie;
37426:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37426:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
37426:   id->asyncTestPhase = 1;
37426:   NPN_PluginThreadAsyncCall(npp, asyncCallback, (void*)npobj);
37426: #ifndef XP_WIN
37426:   return NULL;
37426: #endif
37426: }
37426: 
37426: void
37426: asyncCallback(void* cookie)
37426: {
37426:   NPObject* npobj = (NPObject*)cookie;
37426:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37426:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
37426: 
37426:   switch (id->asyncTestPhase) {
37426:     // async callback triggered from same thread
37426:     case 0:
37426: #ifdef XP_WIN
37426:       if (_beginthread(ThreadProc, 0, (void*)npobj) == -1)
37426:         id->asyncCallbackResult = false;
37426: #else
37426:       pthread_t tid;
37426:       if (pthread_create(&tid, 0, ThreadProc, (void*)npobj))
37426:         id->asyncCallbackResult = false;
37426: #endif
37426:       break;
37426:     
37426:     // async callback triggered from different thread
37426:     default:
37426:       NPObject* windowObject;
37426:       NPN_GetValue(npp, NPNVWindowNPObject, &windowObject);
37426:       if (!windowObject)
37426:         return;
37426:       NPVariant arg, rval;
37426:       BOOLEAN_TO_NPVARIANT(id->asyncCallbackResult, arg);
37426:       NPN_Invoke(npp, windowObject, NPN_GetStringIdentifier(id->asyncTestScriptCallback.c_str()), &arg, 1, &rval);
37426:       NPN_ReleaseVariantValue(&arg);
37490:       NPN_ReleaseObject(windowObject);
37426:       break;
37426:   }
37426: }
37426: 
37426: static bool
37426: asyncCallbackTest(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
37426: {
37426:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37426:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
37426: 
37426:   if (argCount < 1 || !NPVARIANT_IS_STRING(args[0]))
37426:     return false;
37426:   const NPString* argstr = &NPVARIANT_TO_STRING(args[0]);
37426:   id->asyncTestScriptCallback = argstr->UTF8Characters;
37426:   
37426:   id->asyncTestPhase = 0;
37426:   id->asyncCallbackResult = true;
37426:   NPN_PluginThreadAsyncCall(npp, asyncCallback, (void*)npobj);
37426:   
37426:   return true;
37426: }
37857: 
37857: static bool
37857: GCRaceInvoke(NPObject*, NPIdentifier, const NPVariant*, uint32_t, NPVariant*)
37857: {
37857:   return false;
37857: }
37857: 
37857: static bool
37857: GCRaceInvokeDefault(NPObject* o, const NPVariant* args, uint32_t argCount,
37857: 		    NPVariant* result)
37857: {
37857:   if (1 != argCount || !NPVARIANT_IS_INT32(args[0]) ||
37857:       35 != NPVARIANT_TO_INT32(args[0]))
37857:     return false;
37857: 
37857:   return true;
37857: }
37857: 
37857: static const NPClass kGCRaceClass = {
37857:   NP_CLASS_STRUCT_VERSION,
37857:   NULL,
37857:   NULL,
37857:   NULL,
37857:   NULL,
37857:   GCRaceInvoke,
37857:   GCRaceInvokeDefault,
37857:   NULL,
37857:   NULL,
37857:   NULL,
37857:   NULL,
37857:   NULL,
37857:   NULL
37857: };
37857: 
37857: struct GCRaceData
37857: {
37857:   GCRaceData(NPP npp, NPObject* callback, NPObject* localFunc)
37857:     : npp_(npp)
37857:     , callback_(callback)
37857:     , localFunc_(localFunc)
37857:   {
37857:     NPN_RetainObject(callback_);
37857:     NPN_RetainObject(localFunc_);
37857:   }
37857: 
37857:   ~GCRaceData()
37857:   {
37857:     NPN_ReleaseObject(callback_);
37857:     NPN_ReleaseObject(localFunc_);
37857:   }
37857: 
37857:   NPP npp_;
37857:   NPObject* callback_;
37857:   NPObject* localFunc_;
37857: };
37857: 
37857: static void
37857: FinishGCRace(void* closure)
37857: {
37857:   GCRaceData* rd = static_cast<GCRaceData*>(closure);
37857: 
37857: #ifdef XP_WIN
37857:   Sleep(5000);
37857: #else
37857:   sleep(5);
37857: #endif
37857: 
37857:   NPVariant arg;
37857:   OBJECT_TO_NPVARIANT(rd->localFunc_, arg);
37857: 
37857:   NPVariant result;
37857:   bool ok = NPN_InvokeDefault(rd->npp_, rd->callback_, &arg, 1, &result);
37857:   if (!ok)
37857:     return;
37857: 
37857:   NPN_ReleaseVariantValue(&result);
37857:   delete rd;
37857: }
37857: 
37857: bool
37857: checkGCRace(NPObject* npobj, const NPVariant* args, uint32_t argCount,
37857: 	    NPVariant* result)
37857: {
37857:   if (1 != argCount || !NPVARIANT_IS_OBJECT(args[0]))
37857:     return false;
37857: 
37857:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
37857:   
37857:   NPObject* localFunc =
37857:     NPN_CreateObject(npp, const_cast<NPClass*>(&kGCRaceClass));
37857: 
37857:   GCRaceData* rd =
37857:     new GCRaceData(npp, NPVARIANT_TO_OBJECT(args[0]), localFunc);
37857:   NPN_PluginThreadAsyncCall(npp, FinishGCRace, rd);
37857: 
37857:   OBJECT_TO_NPVARIANT(localFunc, *result);
37857:   return true;
37857: }
38122: 
38122: bool
38122: hangPlugin(NPObject* npobj, const NPVariant* args, uint32_t argCount,
38122:            NPVariant* result)
38122: {
57662:   mozilla::NoteIntentionalCrash("plugin");
38122: 
38122: #ifdef XP_WIN
38122:   Sleep(100000000);
38122: #else
38122:   pause();
38122: #endif
38122:   // NB: returning true here means that we weren't terminated, and
38122:   // thus the hang detection/handling didn't work correctly.  The
38122:   // test harness will succeed in calling this function, and the
38122:   // test will fail.
38122:   return true;
38122: }
38686: 
38686: #if defined(MOZ_WIDGET_GTK2)
38686: bool
38686: getClipboardText(NPObject* npobj, const NPVariant* args, uint32_t argCount,
38686:                  NPVariant* result)
38686: {
38686:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
38686:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
38686:   string sel = pluginGetClipboardText(id);
38686: 
38686:   uint32 len = sel.size();
38686:   char* selCopy = static_cast<char*>(NPN_MemAlloc(1 + len));
38686:   if (!selCopy)
38686:     return false;
38686: 
38686:   memcpy(selCopy, sel.c_str(), len);
38686:   selCopy[len] = '\0';
38686: 
38686:   STRINGN_TO_NPVARIANT(selCopy, len, *result);
38686:   // *result owns str now
38686: 
38686:   return true;
38686: }
38686: 
41053: bool
41053: crashPluginInNestedLoop(NPObject* npobj, const NPVariant* args,
41053:                         uint32_t argCount, NPVariant* result)
41053: {
41053:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
41053:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41053:   return pluginCrashInNestedLoop(id);
41053: }
41053: 
57139: bool
57139: destroySharedGfxStuff(NPObject* npobj, const NPVariant* args,
57139:                         uint32_t argCount, NPVariant* result)
57139: {
57139:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
57139:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
57139:   return pluginDestroySharedGfxStuff(id);
57139: }
57139: 
38686: #else
38686: bool
38686: getClipboardText(NPObject* npobj, const NPVariant* args, uint32_t argCount,
38686:                  NPVariant* result)
38686: {
41053:   // XXX Not implemented!
41053:   return false;
41053: }
41053: 
41053: bool
41053: crashPluginInNestedLoop(NPObject* npobj, const NPVariant* args,
41053:                         uint32_t argCount, NPVariant* result)
41053: {
41053:   // XXX Not implemented!
38686:   return false;
38686: }
57139: 
57139: bool
57139: destroySharedGfxStuff(NPObject* npobj, const NPVariant* args,
57139:                         uint32_t argCount, NPVariant* result)
57139: {
57139:   // XXX Not implemented!
57139:   return false;
57139: }
38686: #endif
39210: 
39210: bool
39210: callOnDestroy(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
39210: {
39210:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
39210:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
39210: 
39210:   if (id->callOnDestroy)
39210:     return false;
39210: 
39210:   if (1 != argCount || !NPVARIANT_IS_OBJECT(args[0]))
39210:     return false;
39210: 
39210:   id->callOnDestroy = NPVARIANT_TO_OBJECT(args[0]);
39210:   NPN_RetainObject(id->callOnDestroy);
39210: 
39210:   return true;
39210: }
39210: 
39855: // On Linux at least, a windowed plugin resize causes Flash Player to
39855: // reconnect to the browser window.  This method simulates that.
39855: bool
39855: reinitWidget(NPObject* npobj, const NPVariant* args, uint32_t argCount,
39855:              NPVariant* result)
39855: {
39855:   if (argCount != 0)
39855:     return false;
39210: 
39855:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
39855:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
39210: 
39855:   if (!id->hasWidget)
39855:     return false;
39855: 
39855:   pluginWidgetInit(id, id->window.window);
39855:   return true;
39855: }
40566: 
40566: bool
40566: propertyAndMethod(NPObject* npobj, const NPVariant* args, uint32_t argCount,
40566:                   NPVariant* result)
40566: {
40566:   INT32_TO_NPVARIANT(5, *result);
40566:   return true;
40566: }
41061: 
41061: // Returns top-level window activation state as indicated by Cocoa NPAPI's
41061: // NPCocoaEventWindowFocusChanged events - 'true' if active, 'false' if not.
41061: // Throws an exception if no events have been received and thus this state
41061: // is unknown.
41061: bool
41061: getTopLevelWindowActivationState(NPObject* npobj, const NPVariant* args, uint32_t argCount,
41061:                                  NPVariant* result)
41061: {
41061:   if (argCount != 0)
41061:     return false;
41061: 
41061:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
41061:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41061: 
41061:   // Throw an exception for unknown state.
41061:   if (id->topLevelWindowActivationState == ACTIVATION_STATE_UNKNOWN) {
41061:     return false;
41061:   }
41061: 
41061:   if (id->topLevelWindowActivationState == ACTIVATION_STATE_ACTIVATED) {
41061:     BOOLEAN_TO_NPVARIANT(true, *result);
41061:   } else if (id->topLevelWindowActivationState == ACTIVATION_STATE_DEACTIVATED) {
41061:     BOOLEAN_TO_NPVARIANT(false, *result);
41061:   }
41061: 
41061:   return true;
41061: }
41061: 
41061: bool
41061: getTopLevelWindowActivationEventCount(NPObject* npobj, const NPVariant* args, uint32_t argCount,
41061:                                       NPVariant* result)
41061: {
41061:   if (argCount != 0)
41061:     return false;
41061: 
41061:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
41061:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41061: 
41061:   INT32_TO_NPVARIANT(id->topLevelWindowActivationEventCount, *result);
41061: 
41061:   return true;
41061: }
41061: 
41321: // Returns top-level window activation state as indicated by Cocoa NPAPI's
41321: // NPCocoaEventWindowFocusChanged events - 'true' if active, 'false' if not.
41321: // Throws an exception if no events have been received and thus this state
41321: // is unknown.
41321: bool
41321: getFocusState(NPObject* npobj, const NPVariant* args, uint32_t argCount,
41321:               NPVariant* result)
41321: {
41321:   if (argCount != 0)
41321:     return false;
41321: 
41321:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
41321:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41321: 
41321:   // Throw an exception for unknown state.
41321:   if (id->focusState == ACTIVATION_STATE_UNKNOWN) {
41321:     return false;
41321:   }
41321: 
41321:   if (id->focusState == ACTIVATION_STATE_ACTIVATED) {
41321:     BOOLEAN_TO_NPVARIANT(true, *result);
41321:   } else if (id->focusState == ACTIVATION_STATE_DEACTIVATED) {
41321:     BOOLEAN_TO_NPVARIANT(false, *result);
41321:   }
41321: 
41321:   return true;
41321: }
41321: 
41321: bool
41321: getFocusEventCount(NPObject* npobj, const NPVariant* args, uint32_t argCount,
41321:                    NPVariant* result)
41321: {
41321:   if (argCount != 0)
41321:     return false;
41321: 
41321:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
41321:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41321: 
41321:   INT32_TO_NPVARIANT(id->focusEventCount, *result);
41321: 
41321:   return true;
41321: }
41321: 
41061: bool
41061: getEventModel(NPObject* npobj, const NPVariant* args, uint32_t argCount,
41061:               NPVariant* result)
41061: {
41061:   if (argCount != 0)
41061:     return false;
41061: 
41061:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
41061:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
41061: 
41061:   INT32_TO_NPVARIANT(id->eventModel, *result);
41061: 
41061:   return true;
41061: }
42020: 
42020: static bool
42020: ReflectorHasMethod(NPObject* npobj, NPIdentifier name)
42020: {
42020:   return false;
42020: }
42020: 
42020: static bool
42020: ReflectorHasProperty(NPObject* npobj, NPIdentifier name)
42020: {
42020:   return true;
42020: }
42020: 
42020: static bool
42020: ReflectorGetProperty(NPObject* npobj, NPIdentifier name, NPVariant* result)
42020: {
42020:   if (NPN_IdentifierIsString(name)) {
42020:     char* s = NPN_UTF8FromIdentifier(name);
42020:     STRINGZ_TO_NPVARIANT(s, *result);
42020:     return true;
42020:   }
42020: 
42020:   INT32_TO_NPVARIANT(NPN_IntFromIdentifier(name), *result);
42020:   return true;
42020: }
42020: 
42020: static const NPClass kReflectorNPClass = {
42020:   NP_CLASS_STRUCT_VERSION,
42020:   NULL,
42020:   NULL,
42020:   NULL,
42020:   ReflectorHasMethod,
42020:   NULL,
42020:   NULL,
42020:   ReflectorHasProperty,
42020:   ReflectorGetProperty,
42020:   NULL,
42020:   NULL,
42020:   NULL,
42020:   NULL
42020: };
42020: 
42020: bool
42020: getReflector(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
42020: {
42020:   if (0 != argCount)
42020:     return false;
42020: 
42020:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
42020: 
42020:   NPObject* reflector =
42020:     NPN_CreateObject(npp,
42020: 		     const_cast<NPClass*>(&kReflectorNPClass)); // retains
42020:   OBJECT_TO_NPVARIANT(reflector, *result);
42020:   return true;
42020: }
57226: 
57226: bool isVisible(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
57226: {
57226:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
57226:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
57226: 
57226:   BOOLEAN_TO_NPVARIANT(id->window.clipRect.top != 0 ||
57226: 		       id->window.clipRect.left != 0 ||
57226: 		       id->window.clipRect.bottom != 0 ||
57226: 		       id->window.clipRect.right != 0, *result);
57226:   return true;
57226: }
57514: 
57514: bool getWindowPosition(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
57514: {
57514:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
57514:   InstanceData* id = static_cast<InstanceData*>(npp->pdata);
57514: 
57514:   NPObject* window = NULL;
57514:   NPError err = NPN_GetValue(npp, NPNVWindowNPObject, &window);
57514:   if (NPERR_NO_ERROR != err || !window)
57514:     return false;
57514: 
57514:   NPIdentifier arrayID = NPN_GetStringIdentifier("Array");
57514:   NPVariant arrayFunctionV;
57514:   bool ok = NPN_GetProperty(npp, window, arrayID, &arrayFunctionV);
57514: 
57514:   NPN_ReleaseObject(window);
57514: 
57514:   if (!ok)
57514:     return false;
57514: 
57514:   if (!NPVARIANT_IS_OBJECT(arrayFunctionV)) {
57514:     NPN_ReleaseVariantValue(&arrayFunctionV);
57514:     return false;
57514:   }
57514:   NPObject* arrayFunction = NPVARIANT_TO_OBJECT(arrayFunctionV);
57514: 
57514:   NPVariant elements[4];
57514:   INT32_TO_NPVARIANT(id->window.x, elements[0]);
57514:   INT32_TO_NPVARIANT(id->window.y, elements[1]);
57514:   INT32_TO_NPVARIANT(id->window.width, elements[2]);
57514:   INT32_TO_NPVARIANT(id->window.height, elements[3]);
57514: 
57514:   ok = NPN_InvokeDefault(npp, arrayFunction, elements, 4, result);
57514: 
57514:   NPN_ReleaseObject(arrayFunction);
57514: 
57514:   return ok;
57514: }
57515: 
57515: bool constructObject(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
57515: {
57515:   if (argCount == 0 || !NPVARIANT_IS_OBJECT(args[0]))
57515:     return false;
57515: 
57515:   NPObject* ctor = NPVARIANT_TO_OBJECT(args[0]);
57515:   
57515:   NPP npp = static_cast<TestNPObject*>(npobj)->npp;
57515: 
57515:   return NPN_Construct(npp, ctor, args + 1, argCount - 1, result);
57515: }
62174: 
62174: bool setSitesWithData(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
62174: {
62174:   if (argCount != 1 || !NPVARIANT_IS_STRING(args[0]))
62174:     return false;
62174: 
62174:   // Clear existing data.
62174:   delete sSitesWithData;
62174: 
62174:   const NPString* str = &NPVARIANT_TO_STRING(args[0]);
62174:   if (str->UTF8Length == 0)
62174:     return true;
62174: 
62174:   // Parse the comma-delimited string into a vector.
62174:   sSitesWithData = new list<siteData>;
62174:   const char* iterator = str->UTF8Characters;
62174:   const char* end = iterator + str->UTF8Length;
62174:   while (1) {
62174:     const char* next = strchr(iterator, ',');
62174:     if (!next)
62174:       next = end;
62174: 
62174:     // Parse out the three tokens into a siteData struct.
62174:     const char* siteEnd = strchr(iterator, ':');
62174:     *((char*) siteEnd) = NULL;
62174:     const char* flagsEnd = strchr(siteEnd + 1, ':');
62174:     *((char*) flagsEnd) = NULL;
62174:     *((char*) next) = NULL;
62174:     
62174:     siteData data;
62174:     data.site = string(iterator);
62174:     data.flags = atoi(siteEnd + 1);
62174:     data.age = atoi(flagsEnd + 1);
62174:     
62174:     sSitesWithData->push_back(data);
62174: 
62174:     if (next == end)
62174:       break;
62174: 
62174:     iterator = next + 1;
62174:   }
62174: 
62174:   return true;
62174: }
62174: 
62174: bool setSitesWithDataCapabilities(NPObject* npobj, const NPVariant* args, uint32_t argCount, NPVariant* result)
62174: {
62174:   if (argCount != 1 || !NPVARIANT_IS_BOOLEAN(args[0]))
62174:     return false;
62174: 
62174:   sClearByAgeSupported = NPVARIANT_TO_BOOLEAN(args[0]);
62174:   return true;
62174: }
62174: 
