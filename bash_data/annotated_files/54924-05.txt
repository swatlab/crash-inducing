    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Henri Sivonen <hsivonen@iki.fi>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsExpatDriver.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsParserCIID.h"
    1: #include "CParserContext.h"
    1: #include "nsIExpatSink.h"
    1: #include "nsIExtendedExpatSink.h"
    1: #include "nsIContentSink.h"
    1: #include "nsParserMsgUtils.h"
    1: #include "nsIURL.h"
    1: #include "nsIUnicharInputStream.h"
    1: #include "nsISimpleUnicharStreamFactory.h"
    1: #include "nsNetUtil.h"
    1: #include "prprf.h"
    1: #include "prmem.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsCRT.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
12100: #include "nsIContentPolicy.h"
12100: #include "nsContentPolicyUtils.h"
12100: #include "nsContentErrors.h"
    1: #include "nsXPCOMCIDInternal.h"
    1: #include "nsUnicharInputStream.h"
    1: 
    1: #define kExpatSeparatorChar 0xFFFF
    1: 
    1: static const PRUnichar kUTF16[] = { 'U', 'T', 'F', '-', '1', '6', '\0' };
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo *gExpatDriverLog = PR_NewLogModule("expatdriver");
    1: #endif
    1: 
    1: /***************************** EXPAT CALL BACKS ******************************/
    1: // The callback handlers that get called from the expat parser.
    1: 
20261: static void
    1: Driver_HandleXMLDeclaration(void *aUserData,
    1:                             const XML_Char *aVersion,
    1:                             const XML_Char *aEncoding,
    1:                             int aStandalone)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     nsExpatDriver* driver = static_cast<nsExpatDriver*>(aUserData);
    1:     driver->HandleXMLDeclaration(aVersion, aEncoding, aStandalone);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleStartElement(void *aUserData,
    1:                           const XML_Char *aName,
    1:                           const XML_Char **aAtts)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->HandleStartElement(aName,
    1:                                                                   aAtts);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleEndElement(void *aUserData,
    1:                         const XML_Char *aName)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->HandleEndElement(aName);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleCharacterData(void *aUserData,
    1:                            const XML_Char *aData,
    1:                            int aLength)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     nsExpatDriver* driver = static_cast<nsExpatDriver*>(aUserData);
    1:     driver->HandleCharacterData(aData, PRUint32(aLength));
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleComment(void *aUserData,
    1:                      const XML_Char *aName)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if(aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->HandleComment(aName);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleProcessingInstruction(void *aUserData,
    1:                                    const XML_Char *aTarget,
    1:                                    const XML_Char *aData)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     nsExpatDriver* driver = static_cast<nsExpatDriver*>(aUserData);
    1:     driver->HandleProcessingInstruction(aTarget, aData);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleDefault(void *aUserData,
    1:                      const XML_Char *aData,
    1:                      int aLength)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     nsExpatDriver* driver = static_cast<nsExpatDriver*>(aUserData);
    1:     driver->HandleDefault(aData, PRUint32(aLength));
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleStartCdataSection(void *aUserData)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->HandleStartCdataSection();
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleEndCdataSection(void *aUserData)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->HandleEndCdataSection();
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleStartDoctypeDecl(void *aUserData,
    1:                               const XML_Char *aDoctypeName,
    1:                               const XML_Char *aSysid,
    1:                               const XML_Char *aPubid,
    1:                               int aHasInternalSubset)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->
19025:       HandleStartDoctypeDecl(aDoctypeName, aSysid, aPubid, !!aHasInternalSubset);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleEndDoctypeDecl(void *aUserData)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->HandleEndDoctypeDecl();
    1:   }
    1: }
    1: 
20261: static int
    1: Driver_HandleExternalEntityRef(void *aExternalEntityRefHandler,
    1:                                const XML_Char *aOpenEntityNames,
    1:                                const XML_Char *aBase,
    1:                                const XML_Char *aSystemId,
    1:                                const XML_Char *aPublicId)
    1: {
    1:   NS_ASSERTION(aExternalEntityRefHandler, "expat driver should exist");
    1:   if (!aExternalEntityRefHandler) {
    1:     return 1;
    1:   }
    1: 
 3233:   nsExpatDriver* driver = static_cast<nsExpatDriver*>
 3233:                                      (aExternalEntityRefHandler);
    1: 
    1:   return driver->HandleExternalEntityRef(aOpenEntityNames, aBase, aSystemId,
    1:                                          aPublicId);
    1: }
    1: 
20261: static void
    1: Driver_HandleStartNamespaceDecl(void *aUserData,
    1:                                 const XML_Char *aPrefix,
    1:                                 const XML_Char *aUri)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->
    1:       HandleStartNamespaceDecl(aPrefix, aUri);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleEndNamespaceDecl(void *aUserData,
    1:                               const XML_Char *aPrefix)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->
    1:       HandleEndNamespaceDecl(aPrefix);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleNotationDecl(void *aUserData,
    1:                           const XML_Char *aNotationName,
    1:                           const XML_Char *aBase,
    1:                           const XML_Char *aSysid,
    1:                           const XML_Char *aPubid)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->
    1:       HandleNotationDecl(aNotationName, aBase, aSysid, aPubid);
    1:   }
    1: }
    1: 
20261: static void
    1: Driver_HandleUnparsedEntityDecl(void *aUserData,
    1:                                 const XML_Char *aEntityName,
    1:                                 const XML_Char *aBase,
    1:                                 const XML_Char *aSysid,
    1:                                 const XML_Char *aPubid,
    1:                                 const XML_Char *aNotationName)
    1: {
    1:   NS_ASSERTION(aUserData, "expat driver should exist");
    1:   if (aUserData) {
 3233:     static_cast<nsExpatDriver*>(aUserData)->
    1:       HandleUnparsedEntityDecl(aEntityName, aBase, aSysid, aPubid,
    1:                                aNotationName);
    1:   }
    1: }
    1: 
    1: 
    1: /***************************** END CALL BACKS ********************************/
    1: 
    1: /***************************** CATALOG UTILS *********************************/
    1: 
    1: // Initially added for bug 113400 to switch from the remote "XHTML 1.0 plus
    1: // MathML 2.0" DTD to the the lightweight customized version that Mozilla uses.
    1: // Since Mozilla is not validating, no need to fetch a *huge* file at each
    1: // click.
    1: // XXX The cleanest solution here would be to fix Bug 98413: Implement XML
    1: // Catalogs.
    1: struct nsCatalogData {
    1:   const char* mPublicID;
    1:   const char* mLocalDTD;
    1:   const char* mAgentSheet;
    1: };
    1: 
    1: // The order of this table is guestimated to be in the optimum order
    1: static const nsCatalogData kCatalogTable[] = {
    1:   { "-//W3C//DTD XHTML 1.0 Transitional//EN",    "xhtml11.dtd", nsnull },
    1:   { "-//W3C//DTD XHTML 1.1//EN",                 "xhtml11.dtd", nsnull },
    1:   { "-//W3C//DTD XHTML 1.0 Strict//EN",          "xhtml11.dtd", nsnull },
    1:   { "-//W3C//DTD XHTML 1.0 Frameset//EN",        "xhtml11.dtd", nsnull },
    1:   { "-//W3C//DTD XHTML Basic 1.0//EN",           "xhtml11.dtd", nsnull },
33850:   { "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN", "mathml.dtd",  "resource://gre-resources/mathml.css" },
33777:   { "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN", "mathml.dtd", "resource://gre-resources/mathml.css" },
33777:   { "-//W3C//DTD MathML 2.0//EN",                "mathml.dtd",  "resource://gre-resources/mathml.css" },
    1:   { "-//WAPFORUM//DTD XHTML Mobile 1.0//EN",     "xhtml11.dtd", nsnull },
    1:   { nsnull, nsnull, nsnull }
    1: };
    1: 
    1: static const nsCatalogData*
    1: LookupCatalogData(const PRUnichar* aPublicID)
    1: {
    1:   nsDependentString publicID(aPublicID);
    1: 
    1:   // linear search for now since the number of entries is going to
    1:   // be negligible, and the fix for bug 98413 would get rid of this
    1:   // code anyway
    1:   const nsCatalogData* data = kCatalogTable;
    1:   while (data->mPublicID) {
    1:     if (publicID.EqualsASCII(data->mPublicID)) {
    1:       return data;
    1:     }
    1:     ++data;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
40160: // This function provides a resource URI to a local DTD 
40160: // in resource://gre/res/dtd/ which may or may not exist.
40160: // If aCatalogData is provided, it is used to remap the
40160: // DTD instead of taking the filename from the URI.
40160: static void
40160: GetLocalDTDURI(const nsCatalogData* aCatalogData, nsIURI* aDTD,
    1:               nsIURI** aResult)
    1: {
    1:   NS_ASSERTION(aDTD, "Null parameter.");
    1: 
    1:   nsCAutoString fileName;
    1:   if (aCatalogData) {
    1:     // remap the DTD to a known local DTD
    1:     fileName.Assign(aCatalogData->mLocalDTD);
    1:   }
    1: 
    1:   if (fileName.IsEmpty()) {
    1:     // Try to see if the user has installed the DTD file -- we extract the
    1:     // filename.ext of the DTD here. Hence, for any DTD for which we have
    1:     // no predefined mapping, users just have to copy the DTD file to our
    1:     // special DTD directory and it will be picked.
    1:     nsCOMPtr<nsIURL> dtdURL = do_QueryInterface(aDTD);
    1:     if (!dtdURL) {
40160:       return;
    1:     }
    1: 
    1:     dtdURL->GetFileName(fileName);
    1:     if (fileName.IsEmpty()) {
40160:       return;
    1:     }
    1:   }
    1: 
40160:   nsCAutoString respath("resource://gre/res/dtd/");
40160:   respath += fileName;
40160:   NS_NewURI(aResult, respath);
    1: }
    1: 
    1: /***************************** END CATALOG UTILS *****************************/
    1: 
11423: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsExpatDriver)
11423:   NS_INTERFACE_MAP_ENTRY(nsITokenizer)
11423:   NS_INTERFACE_MAP_ENTRY(nsIDTD)
11423:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDTD)
11423: NS_INTERFACE_MAP_END
11423: 
11423: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsExpatDriver)
11423: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsExpatDriver)
11423: 
11423: NS_IMPL_CYCLE_COLLECTION_2(nsExpatDriver, mSink, mExtendedSink)
    1: 
    1: nsExpatDriver::nsExpatDriver()
    1:   : mExpatParser(nsnull),
    1:     mInCData(PR_FALSE),
    1:     mInInternalSubset(PR_FALSE),
    1:     mInExternalDTD(PR_FALSE),
26256:     mMadeFinalCallToExpat(PR_FALSE),
    1:     mIsFinalChunk(PR_FALSE),
    1:     mInternalState(NS_OK),
    1:     mExpatBuffered(0),
    1:     mCatalogData(nsnull)
    1: {
    1: }
    1: 
    1: nsExpatDriver::~nsExpatDriver()
    1: {
    1:   if (mExpatParser) {
    1:     XML_ParserFree(mExpatParser);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleStartElement(const PRUnichar *aValue,
    1:                                   const PRUnichar **aAtts)
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   // Calculate the total number of elements in aAtts.
    1:   // XML_GetSpecifiedAttributeCount will only give us the number of specified
    1:   // attrs (twice that number, actually), so we have to check for default attrs
    1:   // ourselves.
    1:   PRUint32 attrArrayLength;
    1:   for (attrArrayLength = XML_GetSpecifiedAttributeCount(mExpatParser);
    1:        aAtts[attrArrayLength];
    1:        attrArrayLength += 2) {
    1:     // Just looping till we find out what the length is
    1:   }
    1: 
    1:   if (mSink) {
 8169:     nsresult rv = mSink->
    1:       HandleStartElement(aValue, aAtts, attrArrayLength,
    1:                          XML_GetIdAttributeIndex(mExpatParser),
    1:                          XML_GetCurrentLineNumber(mExpatParser));
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleEndElement(const PRUnichar *aValue)
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
 8169:   NS_ASSERTION(mInternalState != NS_ERROR_HTMLPARSER_BLOCK,
 8169:                "Shouldn't block from HandleStartElement.");
    1: 
 8169:   if (mSink && mInternalState != NS_ERROR_HTMLPARSER_STOPPARSING) {
 8169:     nsresult rv = mSink->HandleEndElement(aValue);
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleCharacterData(const PRUnichar *aValue,
    1:                                    const PRUint32 aLength)
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   if (mInCData) {
    1:     mCDataText.Append(aValue, aLength);
    1:   }
    1:   else if (mSink) {
 8169:     nsresult rv = mSink->HandleCharacterData(aValue, aLength);
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleComment(const PRUnichar *aValue)
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   if (mInExternalDTD) {
    1:     // Ignore comments from external DTDs
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mInInternalSubset) {
    1:     mInternalSubset.AppendLiteral("<!--");
    1:     mInternalSubset.Append(aValue);
    1:     mInternalSubset.AppendLiteral("-->");
    1:   }
    1:   else if (mSink) {
 8169:     nsresult rv = mSink->HandleComment(aValue);
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleProcessingInstruction(const PRUnichar *aTarget,
    1:                                            const PRUnichar *aData)
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   if (mInExternalDTD) {
    1:     // Ignore PIs in external DTDs for now.  Eventually we want to
    1:     // pass them to the sink in a way that doesn't put them in the DOM
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mInInternalSubset) {
    1:     mInternalSubset.AppendLiteral("<?");
    1:     mInternalSubset.Append(aTarget);
    1:     mInternalSubset.Append(' ');
    1:     mInternalSubset.Append(aData);
    1:     mInternalSubset.AppendLiteral("?>");
    1:   }
    1:   else if (mSink) {
 8169:     nsresult rv = mSink->HandleProcessingInstruction(aTarget, aData);
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleXMLDeclaration(const PRUnichar *aVersion,
    1:                                     const PRUnichar *aEncoding,
    1:                                     PRInt32 aStandalone)
    1: {
    1:   if (mSink) {
 8169:     nsresult rv = mSink->HandleXMLDeclaration(aVersion, aEncoding, aStandalone);
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleDefault(const PRUnichar *aValue,
    1:                              const PRUint32 aLength)
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   if (mInExternalDTD) {
    1:     // Ignore newlines in external DTDs
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mInInternalSubset) {
    1:     mInternalSubset.Append(aValue, aLength);
    1:   }
    1:   else if (mSink) {
    1:     PRUint32 i;
 8169:     nsresult rv = mInternalState;
 8169:     for (i = 0; i < aLength && NS_SUCCEEDED(rv); ++i) {
    1:       if (aValue[i] == '\n' || aValue[i] == '\r') {
 8169:         rv = mSink->HandleCharacterData(&aValue[i], 1);
    1:       }
    1:     }
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleStartCdataSection()
    1: {
    1:   mInCData = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleEndCdataSection()
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   mInCData = PR_FALSE;
    1:   if (mSink) {
 8169:     nsresult rv = mSink->HandleCDataSection(mCDataText.get(),
    1:                                             mCDataText.Length());
 8169:     MaybeStopParser(rv);
    1:   }
    1:   mCDataText.Truncate();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleStartNamespaceDecl(const PRUnichar* aPrefix,
    1:                                         const PRUnichar* aUri)
    1: {
    1:   if (mExtendedSink) {
 8169:     nsresult rv = mExtendedSink->HandleStartNamespaceDecl(aPrefix, aUri);
 8169:     MaybeStopParser(rv);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleEndNamespaceDecl(const PRUnichar* aPrefix)
    1: {
 8169:   if (mExtendedSink && mInternalState != NS_ERROR_HTMLPARSER_STOPPARSING) {
 8169:     nsresult rv = mExtendedSink->HandleEndNamespaceDecl(aPrefix);
 8169:     MaybeStopParser(rv);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleNotationDecl(const PRUnichar* aNotationName,
    1:                                   const PRUnichar* aBase,
    1:                                   const PRUnichar* aSysid,
    1:                                   const PRUnichar* aPubid)
    1: {
    1:   if (mExtendedSink) {
 8169:     nsresult rv = mExtendedSink->HandleNotationDecl(aNotationName, aSysid,
    1:                                                     aPubid);
 8169:     MaybeStopParser(rv);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleUnparsedEntityDecl(const PRUnichar* aEntityName,
    1:                                         const PRUnichar* aBase,
    1:                                         const PRUnichar* aSysid,
    1:                                         const PRUnichar* aPubid,
    1:                                         const PRUnichar* aNotationName)
    1: {
    1:   if (mExtendedSink) {
 8169:     nsresult rv = mExtendedSink->HandleUnparsedEntityDecl(aEntityName,
    1:                                                           aSysid,
    1:                                                           aPubid,
    1:                                                           aNotationName);
 8169:     MaybeStopParser(rv);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleStartDoctypeDecl(const PRUnichar* aDoctypeName,
    1:                                       const PRUnichar* aSysid,
    1:                                       const PRUnichar* aPubid,
    1:                                       PRBool aHasInternalSubset)
    1: {
    1:   mDoctypeName = aDoctypeName;
    1:   mSystemID = aSysid;
    1:   mPublicID = aPubid;
    1: 
    1:   if (mExtendedSink) {
 8169:     nsresult rv = mExtendedSink->HandleStartDTD(aDoctypeName, aSysid, aPubid);
 8169:     MaybeStopParser(rv);
    1:   }
    1: 
    1:   if (aHasInternalSubset) {
    1:     // Consuming a huge internal subset translates to numerous
    1:     // allocations. In an effort to avoid too many allocations
    1:     // setting mInternalSubset's capacity to be 1K ( just a guesstimate! ).
    1:     mInInternalSubset = PR_TRUE;
    1:     mInternalSubset.SetCapacity(1024);
15348:   } else {
15348:     // Distinguish missing internal subset from an empty one
15348:     mInternalSubset.SetIsVoid(PR_TRUE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleEndDoctypeDecl()
    1: {
    1:   NS_ASSERTION(mSink, "content sink not found!");
    1: 
    1:   mInInternalSubset = PR_FALSE;
    1: 
    1:   if (mSink) {
    1:     // let the sink know any additional knowledge that we have about the
    1:     // document (currently, from bug 124570, we only expect to pass additional
    1:     // agent sheets needed to layout the XML vocabulary of the document)
    1:     nsCOMPtr<nsIURI> data;
    1:     if (mCatalogData && mCatalogData->mAgentSheet) {
    1:       NS_NewURI(getter_AddRefs(data), mCatalogData->mAgentSheet);
    1:     }
    1: 
    1:     // Note: mInternalSubset already doesn't include the [] around it.
 8169:     nsresult rv = mSink->HandleDoctypeDecl(mInternalSubset, mDoctypeName,
    1:                                            mSystemID, mPublicID, data);
 8169:     MaybeStopParser(rv);
    1:   }
    1:   
    1:   mInternalSubset.SetCapacity(0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static NS_METHOD
    1: ExternalDTDStreamReaderFunc(nsIUnicharInputStream* aIn,
    1:                             void* aClosure,
    1:                             const PRUnichar* aFromSegment,
    1:                             PRUint32 aToOffset,
    1:                             PRUint32 aCount,
    1:                             PRUint32 *aWriteCount)
    1: {
    1:   // Pass the buffer to expat for parsing.
    1:   if (XML_Parse((XML_Parser)aClosure, (const char *)aFromSegment,
    1:                 aCount * sizeof(PRUnichar), 0) == XML_STATUS_OK) {
    1:     *aWriteCount = aCount;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aWriteCount = 0;
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: int
    1: nsExpatDriver::HandleExternalEntityRef(const PRUnichar *openEntityNames,
    1:                                        const PRUnichar *base,
    1:                                        const PRUnichar *systemId,
    1:                                        const PRUnichar *publicId)
    1: {
    1:   if (mInInternalSubset && !mInExternalDTD && openEntityNames) {
    1:     mInternalSubset.Append(PRUnichar('%'));
    1:     mInternalSubset.Append(nsDependentString(openEntityNames));
    1:     mInternalSubset.Append(PRUnichar(';'));
    1:   }
    1: 
    1:   // Load the external entity into a buffer.
    1:   nsCOMPtr<nsIInputStream> in;
    1:   nsAutoString absURL;
    1:   nsresult rv = OpenInputStreamFromExternalDTD(publicId, systemId, base,
    1:                                                getter_AddRefs(in), absURL);
    1:   NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:   nsCOMPtr<nsIUnicharInputStream> uniIn;
    1:   rv = nsSimpleUnicharStreamFactory::GetInstance()->
    1:     CreateInstanceFromUTF8Stream(in, getter_AddRefs(uniIn));
    1:   NS_ENSURE_SUCCESS(rv, 1);
    1: 
    1:   int result = 1;
    1:   if (uniIn) {
    1:     XML_Parser entParser = XML_ExternalEntityParserCreate(mExpatParser, 0,
    1:                                                           kUTF16);
    1:     if (entParser) {
    1:       XML_SetBase(entParser, absURL.get());
    1: 
    1:       mInExternalDTD = PR_TRUE;
    1: 
    1:       PRUint32 totalRead;
    1:       do {
    1:         rv = uniIn->ReadSegments(ExternalDTDStreamReaderFunc, entParser,
    1:                                  PRUint32(-1), &totalRead);
    1:       } while (NS_SUCCEEDED(rv) && totalRead > 0);
    1: 
    1:       result = XML_Parse(entParser, nsnull, 0, 1);
    1: 
    1:       mInExternalDTD = PR_FALSE;
    1: 
    1:       XML_ParserFree(entParser);
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::OpenInputStreamFromExternalDTD(const PRUnichar* aFPIStr,
    1:                                               const PRUnichar* aURLStr,
    1:                                               const PRUnichar* aBaseURL,
    1:                                               nsIInputStream** aStream,
    1:                                               nsAString& aAbsURL)
    1: {
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(baseURI),
    1:                           NS_ConvertUTF16toUTF8(aBaseURL));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = NS_NewURI(getter_AddRefs(uri), NS_ConvertUTF16toUTF8(aURLStr), nsnull,
    1:                  baseURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // check if it is alright to load this uri
    1:   PRBool isChrome = PR_FALSE;
    1:   uri->SchemeIs("chrome", &isChrome);
    1:   if (!isChrome) {
    1:     // since the url is not a chrome url, check to see if we can map the DTD
    1:     // to a known local DTD, or if a DTD file of the same name exists in the
    1:     // special DTD directory
    1:     if (aFPIStr) {
    1:       // see if the Formal Public Identifier (FPI) maps to a catalog entry
    1:       mCatalogData = LookupCatalogData(aFPIStr);
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> localURI;
40160:     GetLocalDTDURI(mCatalogData, uri, getter_AddRefs(localURI));
40160:     if (!localURI) {
    1:       return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1: 
    1:     localURI.swap(uri);
    1:   }
    1: 
12100:   nsCOMPtr<nsIDocument> doc;
29499:   NS_ASSERTION(mSink == nsCOMPtr<nsIExpatSink>(do_QueryInterface(mOriginalSink)),
29499:                "In nsExpatDriver::OpenInputStreamFromExternalDTD: "
29499:                "mOriginalSink not the same object as mSink?");
29499:   if (mOriginalSink)
29499:     doc = do_QueryInterface(mOriginalSink->GetTarget());
12100:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
12593:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_DTD,
12100:                                 uri,
12100:                                 (doc ? doc->NodePrincipal() : nsnull),
12100:                                 doc,
12100:                                 EmptyCString(), //mime guess
12100:                                 nsnull,         //extra
12100:                                 &shouldLoad);
12100:   if (NS_FAILED(rv)) return rv;
12100:   if (NS_CP_REJECTED(shouldLoad)) {
12100:     // Disallowed by content policy
12100:     return NS_ERROR_CONTENT_BLOCKED;
12100:   }
12100: 
    1:   rv = NS_OpenURI(aStream, uri);
    1: 
    1:   nsCAutoString absURL;
    1:   uri->GetSpec(absURL);
    1: 
    1:   CopyUTF8toUTF16(absURL, aAbsURL);
    1: 
    1:   return rv;
    1: }
    1: 
    1: static nsresult
    1: CreateErrorText(const PRUnichar* aDescription,
    1:                 const PRUnichar* aSourceURL,
    1:                 const PRUint32 aLineNumber,
    1:                 const PRUint32 aColNumber,
    1:                 nsString& aErrorString)
    1: {
    1:   aErrorString.Truncate();
    1: 
    1:   nsAutoString msg;
    1:   nsresult rv =
    1:     nsParserMsgUtils::GetLocalizedStringByName(XMLPARSER_PROPERTIES,
    1:                                                "XMLParsingError", msg);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // XML Parsing Error: %1$S\nLocation: %2$S\nLine Number %3$u, Column %4$u:
    1:   PRUnichar *message = nsTextFormatter::smprintf(msg.get(), aDescription,
    1:                                                  aSourceURL, aLineNumber,
    1:                                                  aColNumber);
    1:   if (!message) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   aErrorString.Assign(message);
    1:   nsTextFormatter::smprintf_free(message);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: AppendErrorPointer(const PRInt32 aColNumber,
    1:                    const PRUnichar *aSourceLine,
    1:                    nsString& aSourceString)
    1: {
    1:   aSourceString.Append(PRUnichar('\n'));
    1: 
    1:   // Last character will be '^'.
    1:   PRInt32 last = aColNumber - 1;
    1:   PRInt32 i;
    1:   PRUint32 minuses = 0;
    1:   for (i = 0; i < last; ++i) {
    1:     if (aSourceLine[i] == '\t') {
    1:       // Since this uses |white-space: pre;| a tab stop equals 8 spaces.
    1:       PRUint32 add = 8 - (minuses % 8);
    1:       aSourceString.AppendASCII("--------", add);
    1:       minuses += add;
    1:     }
    1:     else {
    1:       aSourceString.Append(PRUnichar('-'));
    1:       ++minuses;
    1:     }
    1:   }
    1:   aSourceString.Append(PRUnichar('^'));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsExpatDriver::HandleError()
    1: {
    1:   PRInt32 code = XML_GetErrorCode(mExpatParser);
    1:   NS_ASSERTION(code > XML_ERROR_NONE, "unexpected XML error code");
    1: 
    1:   // Map Expat error code to an error string
    1:   // XXX Deal with error returns.
    1:   nsAutoString description;
    1:   nsParserMsgUtils::GetLocalizedStringByID(XMLPARSER_PROPERTIES, code,
    1:                                            description);
    1: 
    1:   if (code == XML_ERROR_TAG_MISMATCH) {
    1:     /**
    1:      *  Expat can send the following:
    1:      *    localName
    1:      *    namespaceURI<separator>localName
    1:      *    namespaceURI<separator>localName<separator>prefix
    1:      *
    1:      *  and we use 0xFFFF for the <separator>.
    1:      *
    1:      */
    1:     const PRUnichar *mismatch = MOZ_XML_GetMismatchedTag(mExpatParser);
    1:     const PRUnichar *uriEnd = nsnull;
    1:     const PRUnichar *nameEnd = nsnull;
    1:     const PRUnichar *pos;
    1:     for (pos = mismatch; *pos; ++pos) {
    1:       if (*pos == kExpatSeparatorChar) {
    1:         if (uriEnd) {
    1:           nameEnd = pos;
    1:         }
    1:         else {
    1:           uriEnd = pos;
    1:         }
    1:       }
    1:     }
    1: 
    1:     nsAutoString tagName;
    1:     if (uriEnd && nameEnd) {
    1:       // We have a prefix.
    1:       tagName.Append(nameEnd + 1, pos - nameEnd - 1);
    1:       tagName.Append(PRUnichar(':'));
    1:     }
    1:     const PRUnichar *nameStart = uriEnd ? uriEnd + 1 : mismatch;
    1:     tagName.Append(nameStart, (nameEnd ? nameEnd : pos) - nameStart);
    1:     
    1:     nsAutoString msg;
    1:     nsParserMsgUtils::GetLocalizedStringByName(XMLPARSER_PROPERTIES,
    1:                                                "Expected", msg);
    1: 
    1:     // . Expected: </%S>.
    1:     PRUnichar *message = nsTextFormatter::smprintf(msg.get(), tagName.get());
    1:     if (!message) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     description.Append(message);
    1: 
    1:     nsTextFormatter::smprintf_free(message);
    1:   }
    1: 
    1:   // Adjust the column number so that it is one based rather than zero based.
    1:   PRUint32 colNumber = XML_GetCurrentColumnNumber(mExpatParser) + 1;
    1:   PRUint32 lineNumber = XML_GetCurrentLineNumber(mExpatParser);
    1: 
    1:   nsAutoString errorText;
    1:   CreateErrorText(description.get(), XML_GetBase(mExpatParser), lineNumber,
    1:                   colNumber, errorText);
    1: 
    1:   NS_ASSERTION(mSink, "no sink?");
    1: 
    1:   nsAutoString sourceText(mLastLine);
    1:   AppendErrorPointer(colNumber, mLastLine.get(), sourceText);
    1: 
    1:   // Try to create and initialize the script error.
    1:   nsCOMPtr<nsIScriptError> serr(do_CreateInstance(NS_SCRIPTERROR_CONTRACTID));
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   if (serr) {
    1:     rv = serr->Init(description.get(),
    1:                     mURISpec.get(),
    1:                     mLastLine.get(),
    1:                     lineNumber, colNumber,
    1:                     nsIScriptError::errorFlag, "malformed-xml");
    1:   }
    1: 
    1:   // If it didn't initialize, we can't do any logging.
    1:   PRBool shouldReportError = NS_SUCCEEDED(rv);
    1: 
    1:   if (mSink && shouldReportError) {
    1:     rv = mSink->ReportError(errorText.get(), 
    1:                             sourceText.get(), 
    1:                             serr, 
    1:                             &shouldReportError);
    1:     if (NS_FAILED(rv)) {
    1:       shouldReportError = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   if (shouldReportError) {
    1:     nsCOMPtr<nsIConsoleService> cs
    1:       (do_GetService(NS_CONSOLESERVICE_CONTRACTID));  
    1:     if (cs) {
    1:       cs->LogMessage(serr);
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_HTMLPARSER_STOPPARSING;
    1: }
    1: 
    1: void
    1: nsExpatDriver::ParseBuffer(const PRUnichar *aBuffer,
    1:                            PRUint32 aLength,
    1:                            PRBool aIsFinal,
    1:                            PRUint32 *aConsumed)
    1: {
    1:   NS_ASSERTION((aBuffer && aLength != 0) || (!aBuffer && aLength == 0), "?");
    1:   NS_ASSERTION(mInternalState != NS_OK || aIsFinal || aBuffer,
    1:                "Useless call, we won't call Expat");
    1:   NS_PRECONDITION(!BlockedOrInterrupted() || !aBuffer,
    1:                   "Non-null buffer when resuming");
    1:   NS_PRECONDITION(XML_GetCurrentByteIndex(mExpatParser) % sizeof(PRUnichar) == 0,
    1:                   "Consumed part of a PRUnichar?");
    1: 
    1:   if (mExpatParser && (mInternalState == NS_OK || BlockedOrInterrupted())) {
    1:     PRInt32 parserBytesBefore = XML_GetCurrentByteIndex(mExpatParser);
    1:     NS_ASSERTION(parserBytesBefore >= 0, "Unexpected value");
    1: 
    1:     XML_Status status;
    1:     if (BlockedOrInterrupted()) {
    1:       mInternalState = NS_OK; // Resume in case we're blocked.
    1:       status = XML_ResumeParser(mExpatParser);
    1:     }
    1:     else {
    1:       status = XML_Parse(mExpatParser,
 3233:                          reinterpret_cast<const char*>(aBuffer),
    1:                          aLength * sizeof(PRUnichar), aIsFinal);
    1:     }
    1: 
    1:     PRInt32 parserBytesConsumed = XML_GetCurrentByteIndex(mExpatParser);
    1: 
    1:     NS_ASSERTION(parserBytesConsumed >= 0, "Unexpected value");
    1:     NS_ASSERTION(parserBytesConsumed >= parserBytesBefore,
    1:                  "How'd this happen?");
    1:     NS_ASSERTION(parserBytesConsumed % sizeof(PRUnichar) == 0,
    1:                  "Consumed part of a PRUnichar?");
    1: 
    1:     // Consumed something.
    1:     *aConsumed = (parserBytesConsumed - parserBytesBefore) / sizeof(PRUnichar);
    1:     NS_ASSERTION(*aConsumed <= aLength + mExpatBuffered,
    1:                  "Too many bytes consumed?");
    1: 
 8169:     NS_ASSERTION(status != XML_STATUS_SUSPENDED || BlockedOrInterrupted(), 
    1:                  "Inconsistent expat suspension state.");
    1: 
    1:     if (status == XML_STATUS_ERROR) {
    1:       mInternalState = NS_ERROR_HTMLPARSER_STOPPARSING;
    1:     }
    1:   }
    1:   else {
    1:     *aConsumed = 0;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsExpatDriver::ConsumeToken(nsScanner& aScanner, PRBool& aFlushTokens)
    1: {
    1:   // We keep the scanner pointing to the position where Expat will start
    1:   // parsing.
    1:   nsScannerIterator currentExpatPosition;
    1:   aScanner.CurrentPosition(currentExpatPosition);
    1: 
    1:   // This is the start of the first buffer that we need to pass to Expat.
    1:   nsScannerIterator start = currentExpatPosition;
    1:   start.advance(mExpatBuffered);
    1: 
    1:   // This is the end of the last buffer (at this point, more data could come in
    1:   // later).
    1:   nsScannerIterator end;
    1:   aScanner.EndReading(end);
    1: 
    1:   PR_LOG(gExpatDriverLog, PR_LOG_DEBUG,
    1:          ("Remaining in expat's buffer: %i, remaining in scanner: %i.",
    1:           mExpatBuffered, Distance(start, end)));
    1: 
    1:   // We want to call Expat if we have more buffers, or if we know there won't
    1:   // be more buffers (and so we want to flush the remaining data), or if we're
    1:   // currently blocked and there's data in Expat's buffer.
26256:   while (start != end || (mIsFinalChunk && !mMadeFinalCallToExpat) ||
    1:          (BlockedOrInterrupted() && mExpatBuffered > 0)) {
    1:     PRBool noMoreBuffers = start == end && mIsFinalChunk;
    1:     PRBool blocked = BlockedOrInterrupted();
    1: 
    1:     const PRUnichar *buffer;
    1:     PRUint32 length;
    1:     if (blocked || noMoreBuffers) {
    1:       // If we're blocked we just resume Expat so we don't need a buffer, if
    1:       // there aren't any more buffers we pass a null buffer to Expat.
    1:       buffer = nsnull;
    1:       length = 0;
    1: 
26256: #if defined(PR_LOGGING) || defined (DEBUG)
    1:       if (blocked) {
    1:         PR_LOG(gExpatDriverLog, PR_LOG_DEBUG,
    1:                ("Resuming Expat, will parse data remaining in Expat's "
    1:                 "buffer.\nContent of Expat's buffer:\n-----\n%s\n-----\n",
    1:                 NS_ConvertUTF16toUTF8(currentExpatPosition.get(),
    1:                                       mExpatBuffered).get()));
    1:       }
    1:       else {
    1:         NS_ASSERTION(mExpatBuffered == Distance(currentExpatPosition, end),
    1:                      "Didn't pass all the data to Expat?");
    1:         PR_LOG(gExpatDriverLog, PR_LOG_DEBUG,
    1:                ("Last call to Expat, will parse data remaining in Expat's "
    1:                 "buffer.\nContent of Expat's buffer:\n-----\n%s\n-----\n",
    1:                 NS_ConvertUTF16toUTF8(currentExpatPosition.get(),
    1:                                       mExpatBuffered).get()));
    1:       }
26256: #endif
    1:     }
    1:     else {
    1:       buffer = start.get();
    1:       length = PRUint32(start.size_forward());
    1: 
    1:       PR_LOG(gExpatDriverLog, PR_LOG_DEBUG,
    1:              ("Calling Expat, will parse data remaining in Expat's buffer and "
    1:               "new data.\nContent of Expat's buffer:\n-----\n%s\n-----\nNew "
    1:               "data:\n-----\n%s\n-----\n",
    1:               NS_ConvertUTF16toUTF8(currentExpatPosition.get(),
    1:                                     mExpatBuffered).get(),
    1:               NS_ConvertUTF16toUTF8(start.get(), length).get()));
    1:     }
    1: 
    1:     PRUint32 consumed;
    1:     ParseBuffer(buffer, length, noMoreBuffers, &consumed);
    1:     if (consumed > 0) {
    1:       nsScannerIterator oldExpatPosition = currentExpatPosition;
    1:       currentExpatPosition.advance(consumed);
    1: 
    1:       // We consumed some data, we want to store the last line of data that
    1:       // was consumed in case we run into an error (to show the line in which
    1:       // the error occurred).
    1: 
    1:       // The length of the last line that Expat has parsed.
    1:       XML_Size lastLineLength = XML_GetCurrentColumnNumber(mExpatParser);
    1: 
    1:       if (lastLineLength <= consumed) {
    1:         // The length of the last line was less than what expat consumed, so
    1:         // there was at least one line break in the consumed data. Store the
    1:         // last line until the point where we stopped parsing.
    1:         nsScannerIterator startLastLine = currentExpatPosition;
    1:         startLastLine.advance(-((ptrdiff_t)lastLineLength));
    1:         CopyUnicodeTo(startLastLine, currentExpatPosition, mLastLine);
    1:       }
    1:       else {
    1:         // There was no line break in the consumed data, append the consumed
    1:         // data.
    1:         AppendUnicodeTo(oldExpatPosition, currentExpatPosition, mLastLine);
    1:       }
    1:     }
    1: 
    1:     mExpatBuffered += length - consumed;
    1: 
    1:     if (BlockedOrInterrupted()) {
    1:       PR_LOG(gExpatDriverLog, PR_LOG_DEBUG,
    1:              ("Blocked or interrupted parser (probably for loading linked "
    1:               "stylesheets or scripts)."));
    1: 
    1:       aScanner.SetPosition(currentExpatPosition, PR_TRUE);
    1:       aScanner.Mark();
    1: 
    1:       return mInternalState;
    1:     }
    1: 
26256:     if (noMoreBuffers && mExpatBuffered == 0) {
26256:       mMadeFinalCallToExpat = PR_TRUE;
26256:     }
26256: 
    1:     if (NS_FAILED(mInternalState)) {
    1:       if (XML_GetErrorCode(mExpatParser) != XML_ERROR_NONE) {
    1:         NS_ASSERTION(mInternalState == NS_ERROR_HTMLPARSER_STOPPARSING,
    1:                      "Unexpected error");
    1: 
    1:         // Look for the next newline after the last one we consumed
    1:         nsScannerIterator lastLine = currentExpatPosition;
    1:         while (lastLine != end) {
    1:           length = PRUint32(lastLine.size_forward());
    1:           PRUint32 endOffset = 0;
    1:           const PRUnichar *buffer = lastLine.get();
    1:           while (endOffset < length && buffer[endOffset] != '\n' &&
    1:                  buffer[endOffset] != '\r') {
    1:             ++endOffset;
    1:           }
    1:           mLastLine.Append(Substring(buffer, buffer + endOffset));
    1:           if (endOffset < length) {
    1:             // We found a newline.
    1:             break;
    1:           }
    1: 
    1:           lastLine.advance(length);
    1:         }
    1: 
    1:         HandleError();
    1:       }
    1: 
    1:       return mInternalState;
    1:     }
    1: 
    1:     // Either we have more buffers, or we were blocked (and we'll flush in the
    1:     // next iteration), or we should have emptied Expat's buffer.
    1:     NS_ASSERTION(!noMoreBuffers || blocked ||
    1:                  (mExpatBuffered == 0 && currentExpatPosition == end),
    1:                  "Unreachable data left in Expat's buffer");
    1: 
    1:     start.advance(length);
25526: 
25526:     // It's possible for start to have passed end if we received more data
25526:     // (e.g. if we spun the event loop in an inline script). Reload end now
25526:     // to compensate.
25526:     aScanner.EndReading(end);
    1:   }
    1: 
    1:   aScanner.SetPosition(currentExpatPosition, PR_TRUE);
    1:   aScanner.Mark();
    1: 
    1:   PR_LOG(gExpatDriverLog, PR_LOG_DEBUG,
    1:          ("Remaining in expat's buffer: %i, remaining in scanner: %i.",
    1:           mExpatBuffered, Distance(currentExpatPosition, end)));
    1: 
 2814:   return NS_SUCCEEDED(mInternalState) ? kEOF : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsExpatDriver::WillBuildModel(const CParserContext& aParserContext,
    1:                               nsITokenizer* aTokenizer,
    1:                               nsIContentSink* aSink)
    1: {
    1:   mSink = do_QueryInterface(aSink);
    1:   if (!mSink) {
    1:     NS_ERROR("nsExpatDriver didn't get an nsIExpatSink");
    1:     // Make sure future calls to us bail out as needed
    1:     mInternalState = NS_ERROR_UNEXPECTED;
    1:     return mInternalState;
    1:   }
    1: 
29499:   mOriginalSink = aSink;
29499: 
    1:   static const XML_Memory_Handling_Suite memsuite =
    1:     {
    1:       (void *(*)(size_t))PR_Malloc,
    1:       (void *(*)(void *, size_t))PR_Realloc,
    1:       PR_Free
    1:     };
    1: 
    1:   static const PRUnichar kExpatSeparator[] = { kExpatSeparatorChar, '\0' };
    1: 
    1:   mExpatParser = XML_ParserCreate_MM(kUTF16, &memsuite, kExpatSeparator);
    1:   NS_ENSURE_TRUE(mExpatParser, NS_ERROR_FAILURE);
    1: 
    1:   XML_SetReturnNSTriplet(mExpatParser, XML_TRUE);
    1: 
    1: #ifdef XML_DTD
    1:   XML_SetParamEntityParsing(mExpatParser, XML_PARAM_ENTITY_PARSING_ALWAYS);
    1: #endif
    1: 
    1:   mURISpec = aParserContext.mScanner->GetFilename();
    1: 
    1:   XML_SetBase(mExpatParser, mURISpec.get());
    1: 
    1:   // Set up the callbacks
    1:   XML_SetXmlDeclHandler(mExpatParser, Driver_HandleXMLDeclaration); 
    1:   XML_SetElementHandler(mExpatParser, Driver_HandleStartElement,
    1:                         Driver_HandleEndElement);
    1:   XML_SetCharacterDataHandler(mExpatParser, Driver_HandleCharacterData);
    1:   XML_SetProcessingInstructionHandler(mExpatParser,
    1:                                       Driver_HandleProcessingInstruction);
    1:   XML_SetDefaultHandlerExpand(mExpatParser, Driver_HandleDefault);
    1:   XML_SetExternalEntityRefHandler(mExpatParser,
    1:                                   (XML_ExternalEntityRefHandler)
    1:                                           Driver_HandleExternalEntityRef);
    1:   XML_SetExternalEntityRefHandlerArg(mExpatParser, this);
    1:   XML_SetCommentHandler(mExpatParser, Driver_HandleComment);
    1:   XML_SetCdataSectionHandler(mExpatParser, Driver_HandleStartCdataSection,
    1:                              Driver_HandleEndCdataSection);
    1: 
    1:   XML_SetParamEntityParsing(mExpatParser,
    1:                             XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE);
    1:   XML_SetDoctypeDeclHandler(mExpatParser, Driver_HandleStartDoctypeDecl,
    1:                             Driver_HandleEndDoctypeDecl);
    1: 
    1:   // If the sink is an nsIExtendedExpatSink,
    1:   // register some addtional handlers.
    1:   mExtendedSink = do_QueryInterface(mSink);
    1:   if (mExtendedSink) {
    1:     XML_SetNamespaceDeclHandler(mExpatParser,
    1:                                 Driver_HandleStartNamespaceDecl,
    1:                                 Driver_HandleEndNamespaceDecl);
    1:     XML_SetUnparsedEntityDeclHandler(mExpatParser,
    1:                                      Driver_HandleUnparsedEntityDecl);
    1:     XML_SetNotationDeclHandler(mExpatParser,
    1:                                Driver_HandleNotationDecl);
    1:   }
    1: 
    1:   // Set up the user data.
    1:   XML_SetUserData(mExpatParser, this);
    1: 
25035:   // XML must detect invalid character convertion
25035:   aParserContext.mScanner->OverrideReplacementCharacter(0xffff);
25035: 
29498:   return mInternalState;
    1: }
    1: 
    1: NS_IMETHODIMP
29500: nsExpatDriver::BuildModel(nsITokenizer* aTokenizer,
29500:                           PRBool,// aCanInterrupt,
29500:                           PRBool,// aCountLines,
29500:                           const nsCString*)// aCharsetPtr)
    1: {
    1:   return mInternalState;
    1: }
    1: 
    1: NS_IMETHODIMP
29500: nsExpatDriver::DidBuildModel(nsresult anErrorCode)
    1: {
29499:   mOriginalSink = nsnull;
26498:   mSink = nsnull;
    1:   mExtendedSink = nsnull;
29498:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsExpatDriver::WillTokenize(PRBool aIsFinalChunk,
    1:                             nsTokenAllocator* aTokenAllocator)
    1: {
    1:   mIsFinalChunk = aIsFinalChunk;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsExpatDriver::DidTokenize(PRBool aIsFinalChunk)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsExpatDriver::Terminate()
    1: {
    1:   // XXX - not sure what happens to the unparsed data.
    1:   if (mExpatParser) {
    1:     XML_StopParser(mExpatParser, XML_FALSE);
    1:   }
    1:   mInternalState = NS_ERROR_HTMLPARSER_STOPPARSING;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRInt32)
    1: nsExpatDriver::GetType()
    1: {
    1:   return NS_IPARSER_FLAG_XML;
    1: }
    1: 
29496: NS_IMETHODIMP_(nsDTDMode)
29496: nsExpatDriver::GetMode() const
29496: {
29496:   return eDTDMode_full_standards;
29496: }
29496: 
    1: /*************************** Unused methods **********************************/
    1: 
    1: NS_IMETHODIMP_(CToken*)
    1: nsExpatDriver::PushTokenFront(CToken* aToken)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(CToken*)
    1: nsExpatDriver::PushToken(CToken* aToken)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(CToken*)
    1: nsExpatDriver::PopToken(void)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(CToken*)
    1: nsExpatDriver::PeekToken(void)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(CToken*)
    1: nsExpatDriver::GetTokenAt(PRInt32 anIndex)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRInt32)
    1: nsExpatDriver::GetCount(void)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsTokenAllocator*)
    1: nsExpatDriver::GetTokenAllocator(void)
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: nsExpatDriver::PrependTokens(nsDeque& aDeque)
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsExpatDriver::CopyState(nsITokenizer* aTokenizer)
    1: {
    1:   return NS_OK;
    1: }
    1: 
29499: nsresult
29500: nsExpatDriver::HandleToken(CToken* aToken)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsExpatDriver::IsContainer(PRInt32 aTag) const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsExpatDriver::CanContain(PRInt32 aParent,PRInt32 aChild) const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
 8169: nsExpatDriver::MaybeStopParser(nsresult aState)
    1: {
 8169:   if (NS_FAILED(aState)) {
 8169:     // If we had a failure we want to override NS_ERROR_HTMLPARSER_INTERRUPTED
 8169:     // and we want to override NS_ERROR_HTMLPARSER_BLOCK but not with
 8169:     // NS_ERROR_HTMLPARSER_INTERRUPTED.
 8169:     if (NS_SUCCEEDED(mInternalState) ||
 8169:         mInternalState == NS_ERROR_HTMLPARSER_INTERRUPTED ||
 8169:         (mInternalState == NS_ERROR_HTMLPARSER_BLOCK &&
 8169:          aState != NS_ERROR_HTMLPARSER_INTERRUPTED)) {
54924:       mInternalState = (aState == NS_ERROR_HTMLPARSER_INTERRUPTED ||
54924:                         aState == NS_ERROR_HTMLPARSER_BLOCK) ?
54924:                        aState :
54924:                        NS_ERROR_HTMLPARSER_STOPPARSING;
    1:     }
 8169: 
 8169:     // If we get an error then we need to stop Expat (by calling XML_StopParser
 8169:     // with PR_FALSE as the last argument). If the parser should be blocked or
 8169:     // interrupted we need to pause Expat (by calling XML_StopParser with
 8169:     // PR_TRUE as the last argument).
 8169:     XML_StopParser(mExpatParser, BlockedOrInterrupted());
    1:   }
 8169:   else if (NS_SUCCEEDED(mInternalState)) {
 8169:     // Only clobber mInternalState with the success code if we didn't block or
 8169:     // interrupt before.
 8169:     mInternalState = aState;
 8169:   }
 8169: }
