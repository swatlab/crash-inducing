   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Morten Nilsen <morten@nilsen.com>
   1:  *   Christian Biesinger <cbiesinger@web.de>
   1:  *   Jan Varga <varga@ku.sk>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsRect.h"
   1: #include "nsHTMLDocument.h"
   1: #include "nsIImageDocument.h"
   1: #include "nsIImageLoadingContent.h"
   1: #include "nsGenericHTMLElement.h"
   1: #include "nsIDOMHTMLImageElement.h"
   1: #include "nsIDOMEvent.h"
   1: #include "nsIDOMKeyEvent.h"
   1: #include "nsIDOMMouseEvent.h"
   1: #include "nsIDOMEventListener.h"
   1: #include "nsGkAtoms.h"
   1: #include "imgIRequest.h"
   1: #include "imgILoader.h"
   1: #include "imgIContainer.h"
   1: #include "nsStubImageDecoderObserver.h"
   1: #include "nsIPresShell.h"
   1: #include "nsPresContext.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsIViewManager.h"
   1: #include "nsStyleContext.h"
   1: #include "nsAutoPtr.h"
   1: #include "nsMediaDocument.h"
   1: #include "nsStyleSet.h"
   1: #include "nsIChannel.h"
   1: #include "nsIContentPolicy.h"
   1: #include "nsContentPolicyUtils.h"
   1: #include "nsPIDOMWindow.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsIDOMNSHTMLElement.h"
   1: #include "nsContentErrors.h"
   1: #include "ImageErrors.h"
   1: 
   1: #define AUTOMATIC_IMAGE_RESIZING_PREF "browser.enable_automatic_image_resizing"
   1: 
   1: class nsImageDocument;
   1: 
   1: class ImageListener: public nsMediaDocumentStreamListener
   1: {
   1: public:
   1:   ImageListener(nsImageDocument* aDocument);
   1:   virtual ~ImageListener();
   1: 
   1:   NS_DECL_ISUPPORTS
   1: 
   1:   NS_DECL_NSIREQUESTOBSERVER
   1: };
   1: 
   1: class nsImageDocument : public nsMediaDocument,
   1:                         public nsIImageDocument,
   1:                         public nsStubImageDecoderObserver,
   1:                         public nsIDOMEventListener
   1: {
   1: public:
   1:   nsImageDocument();
   1:   virtual ~nsImageDocument();
   1: 
   1:   NS_DECL_ISUPPORTS
   1: 
   1:   virtual nsresult Init();
   1: 
   1:   virtual nsresult StartDocumentLoad(const char*         aCommand,
   1:                                      nsIChannel*         aChannel,
   1:                                      nsILoadGroup*       aLoadGroup,
   1:                                      nsISupports*        aContainer,
   1:                                      nsIStreamListener** aDocListener,
   1:                                      PRBool              aReset = PR_TRUE,
   1:                                      nsIContentSink*     aSink = nsnull);
   1: 
   1:   virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aScriptGlobalObject);
   1:   virtual void Destroy();
   1: 
   1:   NS_DECL_NSIIMAGEDOCUMENT
   1: 
   1:   // imgIDecoderObserver (override nsStubImageDecoderObserver)
   1:   NS_IMETHOD OnStartContainer(imgIRequest* aRequest, imgIContainer* aImage);
   1: 
   1:   // nsIDOMEventListener
   1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
   1: 
   1:   friend class ImageListener;
   1: protected:
   1:   nsresult CreateSyntheticDocument();
   1: 
   1:   nsresult CheckOverflowing(PRBool changeState);
   1: 
   1:   void UpdateTitleAndCharset();
   1: 
   1:   float GetRatio() {
   1:     return PR_MIN((float)mVisibleWidth / mImageWidth,
   1:                   (float)mVisibleHeight / mImageHeight);
   1:   }
   1: 
   1:   nsCOMPtr<nsIContent>          mImageContent;
   1: 
   1:   PRInt32                       mVisibleWidth;
   1:   PRInt32                       mVisibleHeight;
   1:   PRInt32                       mImageWidth;
   1:   PRInt32                       mImageHeight;
   1: 
   1:   PRPackedBool                  mResizeImageByDefault;
   1:   PRPackedBool                  mImageIsOverflowing;
   1:   // mImageIsResized is true if the image is currently resized
   1:   PRPackedBool                  mImageIsResized;
   1:   // mShouldResize is true if the image should be resized when it doesn't fit
   1:   // mImageIsResized cannot be true when this is false, but mImageIsResized
   1:   // can be false when this is true
   1:   PRPackedBool                  mShouldResize;
   1:   PRPackedBool                  mFirstResize;
   1: };
   1: 
   1: NS_IMPL_ADDREF_INHERITED(ImageListener, nsMediaDocumentStreamListener)
   1: NS_IMPL_RELEASE_INHERITED(ImageListener, nsMediaDocumentStreamListener)
   1: 
   1: NS_INTERFACE_MAP_BEGIN(ImageListener)
   1: NS_INTERFACE_MAP_END_INHERITING(nsMediaDocumentStreamListener)
   1: 
   1: ImageListener::ImageListener(nsImageDocument* aDocument)
   1:   : nsMediaDocumentStreamListener(aDocument)
   1: {
   1: }
   1: 
   1: 
   1: ImageListener::~ImageListener()
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP
   1: ImageListener::OnStartRequest(nsIRequest* request, nsISupports *ctxt)
   1: {
   1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
   1: 
   1:   nsImageDocument *imgDoc = (nsImageDocument*)mDocument.get();
   1:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
   1:   if (!channel) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsPIDOMWindow> domWindow =
   1:     do_QueryInterface(imgDoc->GetScriptGlobalObject());
   1:   NS_ENSURE_TRUE(domWindow, NS_ERROR_UNEXPECTED);
   1: 
   1:   // Do a ShouldProcess check to see whether to keep loading the image.
   1:   nsCOMPtr<nsIURI> channelURI;
   1:   channel->GetURI(getter_AddRefs(channelURI));
   1: 
   1:   nsCAutoString mimeType;
   1:   channel->GetContentType(mimeType);
   1:     
   1:   PRInt16 decision = nsIContentPolicy::ACCEPT;
   1:   nsresult rv = NS_CheckContentProcessPolicy(nsIContentPolicy::TYPE_IMAGE,
   1:                                              channelURI,
   1:                                              nsnull,
   1:                                              domWindow->GetFrameElementInternal(),
   1:                                              mimeType,
   1:                                              nsnull,
   1:                                              &decision,
   1:                                              nsContentUtils::GetContentPolicy());
   1:                                                
   1:   if (NS_FAILED(rv) || NS_CP_REJECTED(decision)) {
   1:     request->Cancel(NS_ERROR_CONTENT_BLOCKED);
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(imgDoc->mImageContent);
   1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
   1: 
   1:   imageLoader->AddObserver(imgDoc);
   1:   imageLoader->LoadImageWithChannel(channel, getter_AddRefs(mNextStream));
   1: 
   1:   return nsMediaDocumentStreamListener::OnStartRequest(request, ctxt);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: ImageListener::OnStopRequest(nsIRequest* request, nsISupports *ctxt,
   1:                              nsresult status)
   1: {
   1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
   1:   nsImageDocument *imgDoc = (nsImageDocument*)mDocument.get();
   1:   imgDoc->UpdateTitleAndCharset();
   1:   
   1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(imgDoc->mImageContent);
   1:   if (imageLoader) {
   1:     imageLoader->RemoveObserver(imgDoc);
   1:   }
   1: 
   1:   // |status| is NS_IMAGELIB_ERROR_LOAD_ABORTED if the image was found in
   1:   // the cache (bug 177747 comment 51).
   1:   if (status == NS_IMAGELIB_ERROR_LOAD_ABORTED) {
   1:     status = NS_OK;
   1:   }
   1: 
   1:   // mImageContent can be null if the document is already destroyed
   1:   if (NS_FAILED(status) && imgDoc->mStringBundle && imgDoc->mImageContent) {
   1:     nsCAutoString src;
   1:     imgDoc->mDocumentURI->GetSpec(src);
   1:     NS_ConvertUTF8toUTF16 srcString(src);
   1:     const PRUnichar* formatString[] = { srcString.get() };
   1:     nsXPIDLString errorMsg;
   1:     NS_NAMED_LITERAL_STRING(str, "InvalidImage");
   1:     imgDoc->mStringBundle->FormatStringFromName(str.get(), formatString, 1,
   1:                                                 getter_Copies(errorMsg));
   1:     
   1:     imgDoc->mImageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::alt, errorMsg, PR_FALSE);
   1:   }
   1: 
   1:   return nsMediaDocumentStreamListener::OnStopRequest(request, ctxt, status);
   1: }
   1: 
   1: 
   1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
   1:   // bother initializing members to 0.
   1: 
   1: nsImageDocument::nsImageDocument()
   1: {
   1: 
   1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
   1:   // bother initializing members to 0.
   1: 
   1: }
   1: 
   1: nsImageDocument::~nsImageDocument()
   1: {
   1: }
   1: 
   1: NS_IMPL_ADDREF_INHERITED(nsImageDocument, nsMediaDocument)
   1: NS_IMPL_RELEASE_INHERITED(nsImageDocument, nsMediaDocument)
   1: 
   1: NS_INTERFACE_MAP_BEGIN(nsImageDocument)
   1:   NS_INTERFACE_MAP_ENTRY(nsIImageDocument)
   1:   NS_INTERFACE_MAP_ENTRY(imgIDecoderObserver)
   1:   NS_INTERFACE_MAP_ENTRY(imgIContainerObserver)
   1:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventListener)
   1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ImageDocument)
   1: NS_INTERFACE_MAP_END_INHERITING(nsMediaDocument)
   1: 
   1: 
   1: nsresult
   1: nsImageDocument::Init()
   1: {
   1:   nsresult rv = nsMediaDocument::Init();
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   mResizeImageByDefault =
   1:     nsContentUtils::GetBoolPref(AUTOMATIC_IMAGE_RESIZING_PREF);
   1:   mShouldResize = mResizeImageByDefault;
   1:   mFirstResize = PR_TRUE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsImageDocument::StartDocumentLoad(const char*         aCommand,
   1:                                    nsIChannel*         aChannel,
   1:                                    nsILoadGroup*       aLoadGroup,
   1:                                    nsISupports*        aContainer,
   1:                                    nsIStreamListener** aDocListener,
   1:                                    PRBool              aReset,
   1:                                    nsIContentSink*     aSink)
   1: {
   1:   nsresult rv =
   1:     nsMediaDocument::StartDocumentLoad(aCommand, aChannel, aLoadGroup,
   1:                                        aContainer, aDocListener, aReset,
   1:                                        aSink);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   NS_ASSERTION(aDocListener, "null aDocListener");
   1:   *aDocListener = new ImageListener(this);
   1:   if (!*aDocListener)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   NS_ADDREF(*aDocListener);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsImageDocument::Destroy()
   1: {
   1:   if (mImageContent) {
   1:     // Remove our event listener from the image content.
   1:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mImageContent);
   1:     target->RemoveEventListener(NS_LITERAL_STRING("click"), this, PR_FALSE);
   1: 
   1:     // Break reference cycle with mImageContent, if we have one
   1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
   1:     if (imageLoader) {
   1:       imageLoader->RemoveObserver(this);
   1:     }
   1: 
   1:     mImageContent = nsnull;
   1:   }
   1: 
   1:   nsMediaDocument::Destroy();
   1: }
   1: 
   1: void
   1: nsImageDocument::SetScriptGlobalObject(nsIScriptGlobalObject* aScriptGlobalObject)
   1: {
   1:   // If the script global object is changing, we need to unhook our event
   1:   // listeners on the window.
   1:   nsCOMPtr<nsIDOMEventTarget> target;
   1:   if (mScriptGlobalObject &&
   1:       aScriptGlobalObject != mScriptGlobalObject) {
   1:     target = do_QueryInterface(mScriptGlobalObject);
   1:     target->RemoveEventListener(NS_LITERAL_STRING("resize"), this, PR_FALSE);
   1:     target->RemoveEventListener(NS_LITERAL_STRING("keypress"), this,
   1:                                 PR_FALSE);
   1:   }
   1: 
   1:   // Set the script global object on the superclass before doing
   1:   // anything that might require it....
   1:   nsHTMLDocument::SetScriptGlobalObject(aScriptGlobalObject);
   1: 
   1:   if (aScriptGlobalObject) {
   1:     if (!mRootContent) {
   1:       // Create synthetic document
   1:       nsresult rv = CreateSyntheticDocument();
   1:       NS_ASSERTION(NS_SUCCEEDED(rv), "failed to create synthetic document");
   1: 
   1:       target = do_QueryInterface(mImageContent);
   1:       target->AddEventListener(NS_LITERAL_STRING("click"), this, PR_FALSE);
   1:     }
   1: 
   1:     target = do_QueryInterface(aScriptGlobalObject);
   1:     target->AddEventListener(NS_LITERAL_STRING("resize"), this, PR_FALSE);
   1:     target->AddEventListener(NS_LITERAL_STRING("keypress"), this, PR_FALSE);
   1:   }
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::GetImageResizingEnabled(PRBool* aImageResizingEnabled)
   1: {
   1:   *aImageResizingEnabled = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::GetImageIsOverflowing(PRBool* aImageIsOverflowing)
   1: {
   1:   *aImageIsOverflowing = mImageIsOverflowing;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::GetImageIsResized(PRBool* aImageIsResized)
   1: {
   1:   *aImageIsResized = mImageIsResized;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::GetImageRequest(imgIRequest** aImageRequest)
   1: {
   1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
   1:   if (imageLoader) {
   1:     return imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
   1:                                    aImageRequest);
   1:   }
   1: 
   1:   *aImageRequest = nsnull;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::ShrinkToFit()
   1: {
4291:   // Keep image content alive while changing the attributes.
4291:   nsCOMPtr<nsIContent> imageContent = mImageContent;
   1:   nsCOMPtr<nsIDOMHTMLImageElement> image = do_QueryInterface(mImageContent);
   1:   image->SetWidth(PR_MAX(1, NSToCoordFloor(GetRatio() * mImageWidth)));
   1:   image->SetHeight(PR_MAX(1, NSToCoordFloor(GetRatio() * mImageHeight)));
   1:   
4291:   imageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
   1:                         NS_LITERAL_STRING("cursor: -moz-zoom-in"), PR_TRUE);
   1:   
   1:   mImageIsResized = PR_TRUE;
   1:   
   1:   UpdateTitleAndCharset();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::RestoreImageTo(PRInt32 aX, PRInt32 aY)
   1: {
   1:   float ratio = GetRatio();
   1: 
   1:   RestoreImage();
   1:   FlushPendingNotifications(Flush_Layout);
   1: 
 981:   nsIPresShell *shell = GetPrimaryShell();
   1:   if (!shell)
   1:     return NS_OK;
   1: 
   1:   nsPresContext* context = shell->GetPresContext();
   1:   if (!context)
   1:     return NS_OK;
   1: 
   1:   nsIViewManager* vm = context->GetViewManager();
   1:   if (!vm)
   1:     return NS_OK;
   1: 
   1:   nsIScrollableView* view;
   1:   vm->GetRootScrollableView(&view);
   1:   if (!view)
   1:     return NS_OK;
   1: 
   1:   nsSize scrolledSize;
   1:   if (NS_FAILED(view->GetContainerSize(&scrolledSize.width, &scrolledSize.height)))
   1:     return NS_OK;
   1: 
   1:   nsRect portRect = view->View()->GetBounds();
   1:   view->ScrollTo(nsPresContext::CSSPixelsToAppUnits(aX/ratio) - portRect.width/2,
   1:                  nsPresContext::CSSPixelsToAppUnits(aY/ratio) - portRect.height/2,
   1:                  NS_VMREFRESH_IMMEDIATE);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::RestoreImage()
   1: {
4291:   // Keep image content alive while changing the attributes.
4291:   nsCOMPtr<nsIContent> imageContent = mImageContent;
4291:   imageContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::width, PR_TRUE);
4291:   imageContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::height, PR_TRUE);
   1:   
   1:   if (mImageIsOverflowing) {
4291:     imageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
   1:                           NS_LITERAL_STRING("cursor: -moz-zoom-out"), PR_TRUE);
   1:   }
   1:   else {
4291:     imageContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::style, PR_TRUE);
   1:   }
   1:   
   1:   mImageIsResized = PR_FALSE;
   1:   
   1:   UpdateTitleAndCharset();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::ToggleImageSize()
   1: {
   1:   mShouldResize = PR_TRUE;
   1:   if (mImageIsResized) {
   1:     mShouldResize = PR_FALSE;
   1:     RestoreImage();
   1:   }
   1:   else if (mImageIsOverflowing) {
   1:     ShrinkToFit();
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::OnStartContainer(imgIRequest* aRequest, imgIContainer* aImage)
   1: {
   1:   aImage->GetWidth(&mImageWidth);
   1:   aImage->GetHeight(&mImageHeight);
   1:   CheckOverflowing(mResizeImageByDefault);
   1:   UpdateTitleAndCharset();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsImageDocument::HandleEvent(nsIDOMEvent* aEvent)
   1: {
   1:   nsAutoString eventType;
   1:   aEvent->GetType(eventType);
   1:   if (eventType.EqualsLiteral("resize")) {
   1:     CheckOverflowing(PR_FALSE);
   1:   }
   1:   else if (eventType.EqualsLiteral("click")) {
   1:     mShouldResize = PR_TRUE;
   1:     if (mImageIsResized) {
   1:       PRInt32 x = 0, y = 0;
   1:       nsCOMPtr<nsIDOMMouseEvent> event(do_QueryInterface(aEvent));
   1:       if (event) {
   1:         event->GetClientX(&x);
   1:         event->GetClientY(&y);
   1:         PRInt32 left = 0, top = 0;
   1:         nsCOMPtr<nsIDOMNSHTMLElement> nsElement(do_QueryInterface(mImageContent));
   1:         nsElement->GetOffsetLeft(&left);
   1:         nsElement->GetOffsetTop(&top);
   1:         x -= left;
   1:         y -= top;
   1:       }
   1:       mShouldResize = PR_FALSE;
   1:       RestoreImageTo(x, y);
   1:     }
   1:     else if (mImageIsOverflowing) {
   1:       ShrinkToFit();
   1:     }
   1:   }
   1:   else if (eventType.EqualsLiteral("keypress")) {
   1:     nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
   1:     PRUint32 charCode;
   1:     keyEvent->GetCharCode(&charCode);
   1:     // plus key
   1:     if (charCode == 0x2B) {
   1:       mShouldResize = PR_FALSE;
   1:       if (mImageIsResized) {
   1:         RestoreImage();
   1:       }
   1:     }
   1:     // minus key
   1:     else if (charCode == 0x2D) {
   1:       mShouldResize = PR_TRUE;
   1:       if (mImageIsOverflowing) {
   1:         ShrinkToFit();
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsImageDocument::CreateSyntheticDocument()
   1: {
   1:   // Synthesize an html document that refers to the image
   1:   nsresult rv = nsMediaDocument::CreateSyntheticDocument();
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIContent> body = do_QueryInterface(mBodyContent);
   1:   if (!body) {
   1:     NS_WARNING("no body on image document!");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsINodeInfo> nodeInfo;
   1:   rv = mNodeInfoManager->GetNodeInfo(nsGkAtoms::img, nsnull,
   1:                                      kNameSpaceID_None,
   1:                                      getter_AddRefs(nodeInfo));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   mImageContent = NS_NewHTMLImageElement(nodeInfo);
   1:   if (!mImageContent) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
   1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
   1: 
   1:   nsCAutoString src;
   1:   mDocumentURI->GetSpec(src);
   1: 
   1:   NS_ConvertUTF8toUTF16 srcString(src);
   1:   // Make sure not to start the image load from here...
   1:   imageLoader->SetLoadingEnabled(PR_FALSE);
   1:   mImageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::src, srcString, PR_FALSE);
   1:   mImageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::alt, srcString, PR_FALSE);
   1: 
   1:   body->AppendChildTo(mImageContent, PR_FALSE);
   1:   imageLoader->SetLoadingEnabled(PR_TRUE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsImageDocument::CheckOverflowing(PRBool changeState)
   1: {
4043:   /* Create a scope so that the style context gets destroyed before we might
4043:    * call ClearStyleDataAndReflow.  Also, holding onto pointers to the
4043:    * presentatation through style resolution is potentially dangerous.
4043:    */
4043:   {
 981:     nsIPresShell *shell = GetPrimaryShell();
   1:     if (!shell) {
   1:       return NS_OK;
   1:     }
   1: 
   1:     nsPresContext *context = shell->GetPresContext();
   1:     nsRect visibleArea = context->GetVisibleArea();
   1: 
   1:     nsCOMPtr<nsIContent> content = do_QueryInterface(mBodyContent);
   1:     if (!content) {
   1:       NS_WARNING("no body on image document!");
   1:       return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     nsRefPtr<nsStyleContext> styleContext =
   1:       context->StyleSet()->ResolveStyleFor(content, nsnull);
   1: 
   1:     nsMargin m;
   1:     if (styleContext->GetStyleMargin()->GetMargin(m))
   1:       visibleArea.Deflate(m);
   1:     m = styleContext->GetStyleBorder()->GetBorder();
   1:     visibleArea.Deflate(m);
   1:     if (styleContext->GetStylePadding()->GetPadding(m))
   1:       visibleArea.Deflate(m);
   1: 
   1:     mVisibleWidth = nsPresContext::AppUnitsToIntCSSPixels(visibleArea.width);
   1:     mVisibleHeight = nsPresContext::AppUnitsToIntCSSPixels(visibleArea.height);
4043:   }
   1: 
   1:   PRBool imageWasOverflowing = mImageIsOverflowing;
   1:   mImageIsOverflowing =
   1:     mImageWidth > mVisibleWidth || mImageHeight > mVisibleHeight;
   1:   PRBool windowBecameBigEnough = imageWasOverflowing && !mImageIsOverflowing;
   1: 
   1:   if (changeState || mShouldResize || mFirstResize ||
   1:       windowBecameBigEnough) {
   1:     if (mImageIsOverflowing && (changeState || mShouldResize)) {
   1:       ShrinkToFit();
   1:     }
   1:     else if (mImageIsResized || mFirstResize || windowBecameBigEnough) {
   1:       RestoreImage();
   1:     }
   1:   }
   1:   mFirstResize = PR_FALSE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void 
   1: nsImageDocument::UpdateTitleAndCharset()
   1: {
   1:   nsCAutoString typeStr;
   1:   nsCOMPtr<imgIRequest> imageRequest;
   1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
   1:   if (imageLoader) {
   1:     imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
   1:                             getter_AddRefs(imageRequest));
   1:   }
   1:     
   1:   if (imageRequest) {
   1:     nsXPIDLCString mimeType;
   1:     imageRequest->GetMimeType(getter_Copies(mimeType));
   1:     ToUpperCase(mimeType);
   1:     nsXPIDLCString::const_iterator start, end;
   1:     mimeType.BeginReading(start);
   1:     mimeType.EndReading(end);
   1:     nsXPIDLCString::const_iterator iter = end;
   1:     if (FindInReadable(NS_LITERAL_CSTRING("IMAGE/"), start, iter) && 
   1:         iter != end) {
   1:       // strip out "X-" if any
   1:       if (*iter == 'X') {
   1:         ++iter;
   1:         if (iter != end && *iter == '-') {
   1:           ++iter;
   1:           if (iter == end) {
   1:             // looks like "IMAGE/X-" is the type??  Bail out of here.
   1:             mimeType.BeginReading(iter);
   1:           }
   1:         } else {
   1:           --iter;
   1:         }
   1:       }
   1:       typeStr = Substring(iter, end);
   1:     } else {
   1:       typeStr = mimeType;
   1:     }
   1:   }
   1: 
   1:   nsXPIDLString status;
   1:   if (mImageIsResized) {
   1:     nsAutoString ratioStr;
   1:     ratioStr.AppendInt(NSToCoordFloor(GetRatio() * 100));
   1: 
   1:     const PRUnichar* formatString[1] = { ratioStr.get() };
   1:     mStringBundle->FormatStringFromName(NS_LITERAL_STRING("ScaledImage").get(),
   1:                                         formatString, 1,
   1:                                         getter_Copies(status));
   1:   }
   1: 
   1:   static const char* const formatNames[4] = 
   1:   {
   1:     "ImageTitleWithNeitherDimensionsNorFile",
   1:     "ImageTitleWithoutDimensions",
   1:     "ImageTitleWithDimensions",
   1:     "ImageTitleWithDimensionsAndFile",
   1:   };
   1: 
   1:   nsMediaDocument::UpdateTitleAndCharset(typeStr, formatNames,
   1:                                          mImageWidth, mImageHeight, status);
   1: }
   1: 
   1: 
   1: nsresult
   1: NS_NewImageDocument(nsIDocument** aResult)
   1: {
   1:   nsImageDocument* doc = new nsImageDocument();
   1:   if (!doc) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   NS_ADDREF(doc);
   1:   nsresult rv = doc->Init();
   1: 
   1:   if (NS_FAILED(rv)) {
   1:     NS_RELEASE(doc);
   1:   }
   1: 
   1:   *aResult = doc;
   1: 
   1:   return rv;
   1: }
