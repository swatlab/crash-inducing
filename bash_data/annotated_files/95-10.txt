 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is Mozilla Communicator client code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
 1:  *   Blake Ross (blakeross@telocity.com)
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: #include "nsCOMPtr.h"
 1: #include "nsButtonBoxFrame.h"
 1: #include "nsIContent.h"
 1: #include "nsIDocument.h"
 1: #include "nsIDOMDocument.h"
 1: #include "nsIDOMNodeList.h"
 1: #include "nsIDOMXULButtonElement.h"
 1: #include "nsGkAtoms.h"
 1: #include "nsINameSpaceManager.h"
 1: #include "nsPresContext.h"
 1: #include "nsIPresShell.h"
 1: #include "nsGUIEvent.h"
 1: #include "nsIEventStateManager.h"
 1: #include "nsIDOMElement.h"
 1: #include "nsDisplayList.h"
 1: 
 1: //
 1: // NS_NewXULButtonFrame
 1: //
 1: // Creates a new Button frame and returns it
 1: //
 1: nsIFrame*
 1: NS_NewButtonBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext)
 1: {
 1:   return new (aPresShell) nsButtonBoxFrame(aPresShell, aContext);
 1: } // NS_NewXULButtonFrame
 1: 
 1: NS_IMETHODIMP
 1: nsButtonBoxFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
 1:                                               const nsRect&           aDirtyRect,
 1:                                               const nsDisplayListSet& aLists)
 1: {
 1:   // override, since we don't want children to get events
 1:   if (aBuilder->IsForEventDelivery())
 1:     return NS_OK;
 1:   return nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsButtonBoxFrame::HandleEvent(nsPresContext* aPresContext, 
 1:                               nsGUIEvent* aEvent,
 1:                               nsEventStatus* aEventStatus)
 1: {
 1:   switch (aEvent->message) {
 1:     case NS_KEY_DOWN:
 1:       if (NS_KEY_EVENT == aEvent->eventStructType) {
 1:         nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
 1:         if (NS_VK_SPACE == keyEvent->keyCode) {
 1:           nsIEventStateManager *esm = aPresContext->EventStateManager();
 1:           // :hover:active state
 1:           esm->SetContentState(mContent,
 1:                                NS_EVENT_STATE_HOVER |  NS_EVENT_STATE_ACTIVE);
 1:         }
 1:       }
 1:       break;
 1: 
 1: // On mac, Return fires the defualt button, not the focused one.
 1: #ifndef XP_MACOSX
 1:     case NS_KEY_PRESS:
 1:       if (NS_KEY_EVENT == aEvent->eventStructType) {
 1:         nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
 1:         if (NS_VK_RETURN == keyEvent->keyCode) {
 1:           nsCOMPtr<nsIDOMXULButtonElement> buttonEl(do_QueryInterface(mContent));
 1:           if (buttonEl) {
 1:             MouseClicked(aPresContext, aEvent);
 1:             *aEventStatus = nsEventStatus_eConsumeNoDefault;
 1:           }
 1:         }
 1:       }
 1:       break;
 1: #endif
 1: 
 1:     case NS_KEY_UP:
 1:       if (NS_KEY_EVENT == aEvent->eventStructType) {
 1:         nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
 1:         if (NS_VK_SPACE == keyEvent->keyCode) {
 1:           // only activate on keyup if we're already in the :hover:active state
 1:           PRInt32 buttonState;
 1:           const PRInt32 activeHover = NS_EVENT_STATE_ACTIVE | NS_EVENT_STATE_HOVER;
 1:           nsIEventStateManager *esm = aPresContext->EventStateManager();
 1:           esm->GetContentState(mContent, buttonState);
 1:           if ((buttonState & activeHover) == activeHover) {
 1:             esm->SetContentState(nsnull, activeHover);    // return to normal state
 1:             MouseClicked(aPresContext, aEvent);
 1:           }
 1:         }
 1:       }
 1:       break;
 1: 
 1:     case NS_MOUSE_CLICK:
 1:       if (NS_IS_MOUSE_LEFT_CLICK(aEvent)) {
 1:         MouseClicked(aPresContext, aEvent);
 1:       }
 1:       break;
 1:   }
 1: 
 1:   return nsBoxFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 1: }
 1: 
 1: void 
 1: nsButtonBoxFrame::DoMouseClick(nsGUIEvent* aEvent, PRBool aTrustEvent) 
 1: {
 1:   // Don't execute if we're disabled.
 1:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
 1:                             nsGkAtoms::_true, eCaseMatters))
 1:     return;
 1: 
 1:   // Execute the oncommand event handler.
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsXULCommandEvent event(aEvent ? NS_IS_TRUSTED_EVENT(aEvent) : aTrustEvent,
 1:                           NS_XUL_COMMAND, nsnull);
 1:   if(aEvent) {
 1:     event.isShift = ((nsInputEvent*)(aEvent))->isShift;
 1:     event.isControl = ((nsInputEvent*)(aEvent))->isControl;
 1:     event.isAlt = ((nsInputEvent*)(aEvent))->isAlt;
 1:     event.isMeta = ((nsInputEvent*)(aEvent))->isMeta;
 1:   }
 1: 
 1:   // Have the content handle the event, propagating it according to normal DOM rules.
95:   nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:   if (shell) {
 1:     shell->HandleDOMEventWithTarget(mContent, &event, &status);
 1:   }
 1: }
