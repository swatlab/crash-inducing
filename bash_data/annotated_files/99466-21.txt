28495: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
28495: 
28495: #ifndef nsDOMStorageDB_h___
28495: #define nsDOMStorageDB_h___
28495: 
28495: #include "nscore.h"
28495: #include "nsTHashtable.h"
28495: 
28495: #include "nsDOMStoragePersistentDB.h"
28495: #include "nsDOMStorageMemoryDB.h"
28495: 
28495: extern void ReverseString(const nsCSubstring& source, nsCSubstring& result);
28495: 
28495: class nsDOMStorage;
28495: class nsSessionStorageEntry;
28495: 
28495: /**
28495:  * For the purposes of quota checking, we want to be able to efficiently
28495:  * reference data items that belong to a host or its subhosts.  We do this by
28495:  * using a reversed domain name as the key for an item.  For example, a
28495:  * storage for foo.bar.com would use a key of 'moc.rab.oof.".
28495:  *
28495:  * Additionally, globalStorage and localStorage items must be distinguished.
28495:  * globalStorage items are scoped to the host, and localStorage are items are
28495:  * scoped to the scheme/host/port.  To scope localStorage data, its port and
28495:  * scheme are appended to its key.  http://foo.bar.com is stored as
28495:  * moc.rab.foo.:http:80.
28495:  *
28495:  * So the following queries can be used, for http://foo.bar.com:
28495:  *
28495:  * All data owned by globalStorage["foo.bar.com"] -> SELECT * WHERE Domain =
28495:  * "moc.rab.foo.:"
28495:  *
28495:  * All data owned by localStorage -> SELECT * WHERE Domain =
28495:  * "moc.rab.foo.:http:80"
28495:  *
28495:  * All data owned by foo.bar.com, in any storage ->
28495:  * SELECT * WHERE Domain GLOB "moc.rab.foo.:*"
28495:  *
28495:  * All data owned by foo.bar.com or any subdomain, in any storage ->
28495:  * SELECT * WHERE Domain GLOB "moc.rab.foo.*".
28495:  *
28495:  * This key is called the "scope DB key" throughout the code.  So the scope DB
28495:  * key for localStorage at http://foo.bar.com is "moc.rab.foo.:http:80".
28495:  *
28495:  * When calculating quotas, we want to lump together everything in an ETLD+1.
28495:  * So we use a "quota key" during lookups to calculate the quota.  So the
28495:  * quota key for localStorage at http://foo.bar.com is "moc.rab.". */
28495: 
28495: class nsDOMStorageDBWrapper
28495: {
28495: public:
56436:   nsDOMStorageDBWrapper();
56436:   ~nsDOMStorageDBWrapper();
28495: 
83067:   /**
83067:    * Close the connections, finalizing all the cached statements.
83067:    */
83067:   void Close();
83067: 
28495:   nsresult
28495:   Init();
28495: 
28495:   /**
28495:    * Retrieve a list of all the keys associated with a particular domain.
28495:    */
28495:   nsresult
58092:   GetAllKeys(DOMStorageImpl* aStorage,
28495:              nsTHashtable<nsSessionStorageEntry>* aKeys);
28495: 
28495:   /**
28495:    * Retrieve a value and secure flag for a key from storage.
28495:    *
28495:    * @throws NS_ERROR_DOM_NOT_FOUND_ERR if key not found
28495:    */
28495:   nsresult
58092:   GetKeyValue(DOMStorageImpl* aStorage,
28495:               const nsAString& aKey,
28495:               nsAString& aValue,
79445:               bool* aSecure);
28495: 
28495:   /**
28495:    * Set the value and secure flag for a key in storage.
28495:    */
28495:   nsresult
58092:   SetKey(DOMStorageImpl* aStorage,
28495:          const nsAString& aKey,
28495:          const nsAString& aValue,
79445:          bool aSecure,
28495:          PRInt32 aQuota,
79445:          bool aExcludeOfflineFromUsage,
28495:          PRInt32* aNewUsage);
28495: 
28495:   /**
28495:    * Set the secure flag for a key in storage. Does nothing if the key was
28495:    * not found.
28495:    */
28495:   nsresult
58092:   SetSecure(DOMStorageImpl* aStorage,
28495:             const nsAString& aKey,
79445:             const bool aSecure);
28495: 
28495:   /**
28495:    * Removes a key from storage.
28495:    */
28495:   nsresult
58092:   RemoveKey(DOMStorageImpl* aStorage,
28495:             const nsAString& aKey,
79445:             bool aExcludeOfflineFromUsage,
28495:             PRInt32 aKeyUsage);
28495: 
28495:   /**
28495:     * Remove all keys belonging to this storage.
28495:     */
28495:   nsresult
58092:   ClearStorage(DOMStorageImpl* aStorage);
28495: 
28495:   /**
28495:    * Drop session-only storage for a specific host and all it's subdomains
28495:    */
28495:   nsresult
28495:   DropSessionOnlyStoragesForHost(const nsACString& aHostName);
28495: 
28495:   /**
28495:    * Drop everything we gathered to private browsing in-memory database
28495:    */
28495:   nsresult
28495:   DropPrivateBrowsingStorages();
28495: 
28495:   /**
28495:    * Removes all keys added by a given domain.
28495:    */
28495:   nsresult
79445:   RemoveOwner(const nsACString& aOwner, bool aIncludeSubDomains);
28495: 
28495:   /**
28495:    * Removes keys owned by domains that either match or don't match the
28495:    * list.
28495:    */
28495:   nsresult
28495:   RemoveOwners(const nsTArray<nsString>& aOwners,
79445:                bool aIncludeSubDomains, bool aMatch);
28495: 
28495:   /**
99466:    * Removes all keys from storage. Used when clearing storage.
99466:    */
99466:   nsresult
99466:   RemoveAll();
99466: 
99466:   /**
28495:     * Returns usage for a storage using its GetQuotaDomainDBKey() as a key.
28495:     */
28495:   nsresult
79445:   GetUsage(DOMStorageImpl* aStorage, bool aExcludeOfflineFromUsage, PRInt32 *aUsage);
28495: 
28495:   /**
28495:     * Returns usage of the domain and optionaly by any subdomain.
28495:     */
28495:   nsresult
99466:   GetUsage(const nsACString& aDomain, bool aIncludeSubDomains, PRInt32 *aUsage);
28495: 
28495:   /**
78721:    * Marks the storage as "cached" after the DOMStorageImpl object has loaded
78721:    * all items to its memory copy of the entries - IsScopeDirty returns false
78721:    * after call of this method for this storage.
78721:    *
78721:    * When a key is changed or deleted in the storage, the storage scope is
78721:    * marked as "dirty" again and makes the DOMStorageImpl object recache its
78721:    * keys on next access, because IsScopeDirty returns true again.
78721:    */
78721:   void
78721:   MarkScopeCached(DOMStorageImpl* aStorage);
78721: 
78721:   /**
78721:    * Test whether the storage for the scope (i.e. origin or host) has been
78721:    * changed since the last MarkScopeCached call.
78721:    */
78721:   bool
78721:   IsScopeDirty(DOMStorageImpl* aStorage);
78721: 
78721:   /**
28495:     * Turns "http://foo.bar.com:80" to "moc.rab.oof.:http:80",
28495:     * i.e. reverses the host, appends a dot, appends the schema
28495:     * and a port number.
28495:     */
28495:   static nsresult CreateOriginScopeDBKey(nsIURI* aUri, nsACString& aKey);
28495: 
28495:   /**
28495:     * Turns "http://foo.bar.com" to "moc.rab.oof.",
28495:     * i.e. reverses the host and appends a dot.
28495:     */
28495:   static nsresult CreateDomainScopeDBKey(nsIURI* aUri, nsACString& aKey);
28495:   static nsresult CreateDomainScopeDBKey(const nsACString& aAsciiDomain, nsACString& aKey);
28495: 
28495:   /**
28495:     * Turns "foo.bar.com" to "moc.rab.",
28495:     * i.e. extracts eTLD+1 from the host, reverses the result
28495:     * and appends a dot.
28495:     */
28495:   static nsresult CreateQuotaDomainDBKey(const nsACString& aAsciiDomain,
79445:                                          bool aIncludeSubDomains, bool aETLDplus1Only,
34057:                                          nsACString& aKey);
34057: 
34057:   static nsresult GetDomainFromScopeKey(const nsACString& aScope,
34057:                                          nsACString& aDomain);
28495: 
59411:   /**
59411:    * Ensures the temp table flush timer is running. This is called when we add
59411:    * data that will need to be flushed.
59411:    */
59411:   void EnsureTempTableFlushTimer();
59411: 
59411:   /**
60667:    * Called by the timer or on shutdown/profile change to flush all temporary
60667:    * tables that are too long in memory to disk.
60667:    * Set force to flush even a table doesn't meet the age limits.  Used during
60667:    * shutdown.
60667:    */
60667:   nsresult FlushAndDeleteTemporaryTables(bool force);
60667: 
60667:   /**
59411:    * Stops the temp table flush timer.
59411:    */
59411:   void StopTempTableFlushTimer();
59411: 
28495: protected:
52374:   nsDOMStoragePersistentDB mChromePersistentDB;
28495:   nsDOMStoragePersistentDB mPersistentDB;
28495:   nsDOMStorageMemoryDB mSessionOnlyDB;
28495:   nsDOMStorageMemoryDB mPrivateBrowsingDB;
56436: 
59411:   nsCOMPtr<nsITimer> mTempTableFlushTimer;
28495: };
28495: 
28495: #endif /* nsDOMStorageDB_h___ */
