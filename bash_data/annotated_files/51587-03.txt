    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.org code.
    1:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *         Jonas Sicking <jonas@sicking.cc> (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNodeUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsINode.h"
    1: #include "nsIContent.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIMutationObserver.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMUserDataHandler.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIAttribute.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsGenericElement.h"
    1: #include "pldhash.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsCOMArray.h"
    1: #include "nsPIDOMWindow.h"
32360: #include "nsDocument.h"
    1: #ifdef MOZ_XUL
    1: #include "nsXULElement.h"
    1: #endif
18850: #include "nsBindingManager.h"
33311: #include "nsGenericHTMLElement.h"
34389: #ifdef MOZ_MEDIA
34207: #include "nsHTMLMediaElement.h"
34389: #endif // MOZ_MEDIA
51587: #include "nsImageLoadingContent.h"
    1: 
41636: using namespace mozilla::dom;
41636: 
 8678: // This macro expects the ownerDocument of content_ to be in scope as
 8678: // |nsIDocument* doc|
    1: #define IMPL_MUTATION_NOTIFICATION(func_, content_, params_)      \
    1:   PR_BEGIN_MACRO                                                  \
    1:   nsINode* node = content_;                                       \
 8678:   NS_ASSERTION(node->GetOwnerDoc() == doc, "Bogus document");     \
 8678:   if (doc) {                                                      \
 8678:     static_cast<nsIMutationObserver*>(doc->BindingManager())->    \
 8678:       func_ params_;                                              \
 8678:   }                                                               \
    1:   do {                                                            \
    1:     nsINode::nsSlots* slots = node->GetExistingSlots();           \
    1:     if (slots && !slots->mMutationObservers.IsEmpty()) {          \
    1:       /* No need to explicitly notify the first observer first    \
    1:          since that'll happen anyway. */                          \
    1:       NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(                         \
    1:         slots->mMutationObservers, nsIMutationObserver,           \
    1:         func_, params_);                                          \
    1:     }                                                             \
    1:     node = node->GetNodeParent();                                 \
    1:   } while (node);                                                 \
    1:   PR_END_MACRO
    1: 
    1: void
 5681: nsNodeUtils::CharacterDataWillChange(nsIContent* aContent,
 5681:                                      CharacterDataChangeInfo* aInfo)
 5681: {
 5681:   nsIDocument* doc = aContent->GetOwnerDoc();
48010:   IMPL_MUTATION_NOTIFICATION(CharacterDataWillChange, aContent,
 5681:                              (doc, aContent, aInfo));
 5681: }
 5681: 
 5681: void
    1: nsNodeUtils::CharacterDataChanged(nsIContent* aContent,
    1:                                   CharacterDataChangeInfo* aInfo)
    1: {
    1:   nsIDocument* doc = aContent->GetOwnerDoc();
48011:   IMPL_MUTATION_NOTIFICATION(CharacterDataChanged, aContent,
    1:                              (doc, aContent, aInfo));
    1: }
    1: 
    1: void
51352: nsNodeUtils::AttributeWillChange(Element* aElement,
29833:                                  PRInt32 aNameSpaceID,
29833:                                  nsIAtom* aAttribute,
29833:                                  PRInt32 aModType)
29833: {
51352:   nsIDocument* doc = aElement->GetOwnerDoc();
51352:   IMPL_MUTATION_NOTIFICATION(AttributeWillChange, aElement,
51352:                              (doc, aElement, aNameSpaceID, aAttribute,
29833:                               aModType));
29833: }
29833: 
29833: void
51351: nsNodeUtils::AttributeChanged(Element* aElement,
    1:                               PRInt32 aNameSpaceID,
    1:                               nsIAtom* aAttribute,
35535:                               PRInt32 aModType)
    1: {
51350:   nsIDocument* doc = aElement->GetOwnerDoc();
51350:   IMPL_MUTATION_NOTIFICATION(AttributeChanged, aElement,
51350:                              (doc, aElement, aNameSpaceID, aAttribute,
35535:                               aModType));
    1: }
    1: 
    1: void
    1: nsNodeUtils::ContentAppended(nsIContent* aContainer,
42107:                              nsIContent* aFirstNewContent,
    1:                              PRInt32 aNewIndexInContainer)
    1: {
 8678:   nsIDocument* doc = aContainer->GetOwnerDoc();
    1: 
48014:   IMPL_MUTATION_NOTIFICATION(ContentAppended, aContainer,
42107:                              (doc, aContainer, aFirstNewContent,
42107:                               aNewIndexInContainer));
    1: }
    1: 
    1: void
    1: nsNodeUtils::ContentInserted(nsINode* aContainer,
    1:                              nsIContent* aChild,
    1:                              PRInt32 aIndexInContainer)
    1: {
    1:   NS_PRECONDITION(aContainer->IsNodeOfType(nsINode::eCONTENT) ||
    1:                   aContainer->IsNodeOfType(nsINode::eDOCUMENT),
    1:                   "container must be an nsIContent or an nsIDocument");
    1:   nsIContent* container;
 8678:   nsIDocument* doc = aContainer->GetOwnerDoc();
    1:   nsIDocument* document;
    1:   if (aContainer->IsNodeOfType(nsINode::eCONTENT)) {
 3233:     container = static_cast<nsIContent*>(aContainer);
 8678:     document = doc;
    1:   }
    1:   else {
    1:     container = nsnull;
 3233:     document = static_cast<nsIDocument*>(aContainer);
    1:   }
    1: 
48015:   IMPL_MUTATION_NOTIFICATION(ContentInserted, aContainer,
    1:                              (document, container, aChild, aIndexInContainer));
    1: }
    1: 
    1: void
    1: nsNodeUtils::ContentRemoved(nsINode* aContainer,
    1:                             nsIContent* aChild,
48038:                             PRInt32 aIndexInContainer,
48038:                             nsIContent* aPreviousSibling)
    1: {
    1:   NS_PRECONDITION(aContainer->IsNodeOfType(nsINode::eCONTENT) ||
    1:                   aContainer->IsNodeOfType(nsINode::eDOCUMENT),
    1:                   "container must be an nsIContent or an nsIDocument");
    1:   nsIContent* container;
 8678:   nsIDocument* doc = aContainer->GetOwnerDoc();
    1:   nsIDocument* document;
    1:   if (aContainer->IsNodeOfType(nsINode::eCONTENT)) {
 3233:     container = static_cast<nsIContent*>(aContainer);
 8678:     document = doc;
    1:   }
    1:   else {
    1:     container = nsnull;
 3233:     document = static_cast<nsIDocument*>(aContainer);
    1:   }
    1: 
48016:   IMPL_MUTATION_NOTIFICATION(ContentRemoved, aContainer,
48038:                              (document, container, aChild, aIndexInContainer,
48038:                               aPreviousSibling));
    1: }
    1: 
    1: void
    1: nsNodeUtils::ParentChainChanged(nsIContent *aContent)
    1: {
    1:   // No need to notify observers on the parents since their parent
    1:   // chain must have been changed too and so their observers were
    1:   // notified at that time.
    1: 
    1:   nsINode::nsSlots* slots = aContent->GetExistingSlots();
    1:   if (slots && !slots->mMutationObservers.IsEmpty()) {
48008:     NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(
    1:         slots->mMutationObservers,
    1:         nsIMutationObserver,
    1:         ParentChainChanged,
    1:         (aContent));
    1:   }
    1: }
    1: 
    1: void
 1391: nsNodeUtils::LastRelease(nsINode* aNode)
    1: {
    1:   nsINode::nsSlots* slots = aNode->GetExistingSlots();
    1:   if (slots) {
    1:     if (!slots->mMutationObservers.IsEmpty()) {
48009:       NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(slots->mMutationObservers,
    1:                                          nsIMutationObserver,
    1:                                          NodeWillBeDestroyed, (aNode));
    1:     }
    1: 
    1:     PtrBits flags = slots->mFlags | NODE_DOESNT_HAVE_SLOTS;
11169:     delete slots;
    1:     aNode->mFlagsOrSlots = flags;
    1:   }
    1: 
    1:   // Kill properties first since that may run external code, so we want to
    1:   // be in as complete state as possible at that time.
 1391:   if (aNode->IsNodeOfType(nsINode::eDOCUMENT)) {
 1391:     // Delete all properties before tearing down the document. Some of the
 1391:     // properties are bound to nsINode objects and the destructor functions of
 1391:     // the properties may want to use the owner document of the nsINode.
41182:     static_cast<nsIDocument*>(aNode)->DeleteAllProperties();
 1391:   }
33311:   else {
33311:     if (aNode->HasProperties()) {
    1:       // Strong reference to the document so that deleting properties can't
    1:       // delete the document.
    1:       nsCOMPtr<nsIDocument> document = aNode->GetOwnerDoc();
    1:       if (document) {
41182:         document->DeleteAllPropertiesFor(aNode);
 1391:       }
    1:     }
33311: 
33311:     // I wonder whether it's faster to do the HasFlag check first....
33311:     if (aNode->IsNodeOfType(nsINode::eHTML_FORM_CONTROL) &&
33311:         aNode->HasFlag(ADDED_TO_FORM)) {
33311:       // Tell the form (if any) this node is going away.  Don't
33311:       // notify, since we're being destroyed in any case.
33311:       static_cast<nsGenericHTMLFormElement*>(aNode)->ClearForm(PR_TRUE,
33311:                                                                PR_FALSE);
33311:     }
33311:   }
    1:   aNode->UnsetFlags(NODE_HAS_PROPERTIES);
    1: 
    1:   if (aNode->HasFlag(NODE_HAS_LISTENERMANAGER)) {
    1: #ifdef DEBUG
    1:     if (nsContentUtils::IsInitialized()) {
29474:       nsIEventListenerManager* manager =
29474:         nsContentUtils::GetListenerManager(aNode, PR_FALSE);
    1:       if (!manager) {
    1:         NS_ERROR("Huh, our bit says we have a listener manager list, "
    1:                  "but there's nothing in the hash!?!!");
    1:       }
    1:     }
    1: #endif
    1: 
    1:     nsContentUtils::RemoveListenerManager(aNode);
    1:     aNode->UnsetFlags(NODE_HAS_LISTENERMANAGER);
    1:   }
    1: 
41636:   if (aNode->IsElement()) {
11731:     nsIDocument* ownerDoc = aNode->GetOwnerDoc();
42846:     Element* elem = aNode->AsElement();
11731:     if (ownerDoc) {
42846:       ownerDoc->ClearBoxObjectFor(elem);
42846:     }
42846:     
42846:     NS_ASSERTION(aNode->HasFlag(NODE_FORCE_XBL_BINDINGS) ||
42846:                  !ownerDoc ||
42846:                  !ownerDoc->BindingManager() ||
42847:                  !ownerDoc->BindingManager()->GetBinding(elem),
42846:                  "Non-forced node has binding on destruction");
42846: 
42846:     // if NODE_FORCE_XBL_BINDINGS is set, the node might still have a binding
42846:     // attached
42846:     if (aNode->HasFlag(NODE_FORCE_XBL_BINDINGS) &&
42846:         ownerDoc && ownerDoc->BindingManager()) {
43087:       ownerDoc->BindingManager()->RemovedFromDocument(elem, ownerDoc);
11731:     }
11731:   }
11731: 
30001:   nsContentUtils::ReleaseWrapper(aNode, aNode);
30001: 
    1:   delete aNode;
    1: }
 1391: 
15594: struct NS_STACK_CLASS nsHandlerData
 1391: {
 1391:   PRUint16 mOperation;
15594:   nsCOMPtr<nsIDOMNode> mSource;
15594:   nsCOMPtr<nsIDOMNode> mDest;
41407:   nsCxPusher mPusher;
 1391: };
 1391: 
 1391: static void
 1391: CallHandler(void *aObject, nsIAtom *aKey, void *aHandler, void *aData)
 1391: {
 3233:   nsHandlerData *handlerData = static_cast<nsHandlerData*>(aData);
 1391:   nsCOMPtr<nsIDOMUserDataHandler> handler =
 3233:     static_cast<nsIDOMUserDataHandler*>(aHandler);
 3233:   nsINode *node = static_cast<nsINode*>(aObject);
 1391:   nsCOMPtr<nsIVariant> data =
 3233:     static_cast<nsIVariant*>(node->GetProperty(DOM_USER_DATA, aKey));
 1391:   NS_ASSERTION(data, "Handler without data?");
 1391: 
41407:   if (!handlerData->mPusher.RePush(node)) {
41407:     return;
41407:   }
 1391:   nsAutoString key;
 1391:   aKey->ToString(key);
 1391:   handler->Handle(handlerData->mOperation, key, data, handlerData->mSource,
 1391:                   handlerData->mDest);
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsNodeUtils::CallUserDataHandlers(nsCOMArray<nsINode> &aNodesWithProperties,
    1:                                   nsIDocument *aOwnerDocument,
    1:                                   PRUint16 aOperation, PRBool aCloned)
    1: {
    1:   NS_PRECONDITION(!aCloned || (aNodesWithProperties.Count() % 2 == 0),
    1:                   "Expected aNodesWithProperties to contain original and "
    1:                   "cloned nodes.");
    1: 
41182:   nsPropertyTable *table = aOwnerDocument->PropertyTable(DOM_USER_DATA_HANDLER);
    1: 
    1:   // Keep the document alive, just in case one of the handlers causes it to go
    1:   // away.
    1:   nsCOMPtr<nsIDocument> ownerDoc = aOwnerDocument;
    1: 
    1:   nsHandlerData handlerData;
    1:   handlerData.mOperation = aOperation;
    1: 
    1:   PRUint32 i, count = aNodesWithProperties.Count();
    1:   for (i = 0; i < count; ++i) {
    1:     nsINode *nodeWithProperties = aNodesWithProperties[i];
    1: 
    1:     nsresult rv;
    1:     handlerData.mSource = do_QueryInterface(nodeWithProperties, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (aCloned) {
    1:       handlerData.mDest = do_QueryInterface(aNodesWithProperties[++i], &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
41182:     table->Enumerate(nodeWithProperties, CallHandler, &handlerData);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 1391: static void
 1391: NoteUserData(void *aObject, nsIAtom *aKey, void *aXPCOMChild, void *aData)
 1391: {
 1391:   nsCycleCollectionTraversalCallback* cb =
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(aData);
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "[user data (or handler)]");
 3233:   cb->NoteXPCOMChild(static_cast<nsISupports*>(aXPCOMChild));
 1391: }
 1391: 
 1391: /* static */
 1391: void
 1391: nsNodeUtils::TraverseUserData(nsINode* aNode,
 1391:                               nsCycleCollectionTraversalCallback &aCb)
 1391: {
 1391:   nsIDocument* ownerDoc = aNode->GetOwnerDoc();
 1391:   if (!ownerDoc) {
 1391:     return;
 1391:   }
 1391: 
41182:   ownerDoc->PropertyTable(DOM_USER_DATA)->Enumerate(aNode, NoteUserData, &aCb);
41182:   ownerDoc->PropertyTable(DOM_USER_DATA_HANDLER)->Enumerate(aNode, NoteUserData, &aCb);
 1391: }
 1391: 
    1: /* static */
    1: nsresult
    1: nsNodeUtils::CloneNodeImpl(nsINode *aNode, PRBool aDeep, nsIDOMNode **aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> newNode;
    1:   nsCOMArray<nsINode> nodesWithProperties;
    1:   nsresult rv = Clone(aNode, aDeep, nsnull, nodesWithProperties,
    1:                       getter_AddRefs(newNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsIDocument *ownerDoc = aNode->GetOwnerDoc();
    1:   if (ownerDoc) {
    1:     rv = CallUserDataHandlers(nodesWithProperties, ownerDoc,
    1:                               nsIDOMUserDataHandler::NODE_CLONED, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   newNode.swap(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsNodeUtils::CloneAndAdopt(nsINode *aNode, PRBool aClone, PRBool aDeep,
    1:                            nsNodeInfoManager *aNewNodeInfoManager,
    1:                            JSContext *aCx, JSObject *aOldScope,
    1:                            JSObject *aNewScope,
    1:                            nsCOMArray<nsINode> &aNodesWithProperties,
33674:                            nsINode *aParent, nsINode **aResult)
    1: {
    1:   NS_PRECONDITION((!aClone && aNewNodeInfoManager) || !aCx,
    1:                   "If cloning or not getting a new nodeinfo we shouldn't "
    1:                   "rewrap");
    1:   NS_PRECONDITION(!aCx || (aOldScope && aNewScope), "Must have scopes");
33674:   NS_PRECONDITION(!aParent || aNode->IsNodeOfType(nsINode::eCONTENT),
33674:                   "Can't insert document or attribute nodes into a parent");
    1: 
    1:   *aResult = nsnull;
    1: 
    1:   // First deal with aNode and walk its attributes (and their children). Then,
    1:   // if aDeep is PR_TRUE, deal with aNode's children (and recurse into their
    1:   // attributes and children).
    1: 
    1:   nsresult rv;
    1:   nsNodeInfoManager *nodeInfoManager = aNewNodeInfoManager;
    1: 
    1:   // aNode.
    1:   nsINodeInfo *nodeInfo = aNode->mNodeInfo;
    1:   nsCOMPtr<nsINodeInfo> newNodeInfo;
    1:   if (nodeInfoManager) {
20377: 
20377:     // Don't allow importing/adopting nodes from non-privileged "scriptable"
20377:     // documents to "non-scriptable" documents.
20377:     nsIDocument* newDoc = nodeInfoManager->GetDocument();
22218:     NS_ENSURE_STATE(newDoc);
20377:     PRBool hasHadScriptHandlingObject = PR_FALSE;
20377:     if (!newDoc->GetScriptHandlingObject(hasHadScriptHandlingObject) &&
20377:         !hasHadScriptHandlingObject) {
22218:       nsIDocument* currentDoc = aNode->GetOwnerDoc();
22218:       NS_ENSURE_STATE(currentDoc &&
22218:                       (nsContentUtils::IsChromeDoc(currentDoc) ||
20377:                        (!currentDoc->GetScriptHandlingObject(hasHadScriptHandlingObject) &&
22218:                         !hasHadScriptHandlingObject)));
20377:     }
20377: 
19197:     newNodeInfo = nodeInfoManager->GetNodeInfo(nodeInfo->NameAtom(),
    1:                                                nodeInfo->GetPrefixAtom(),
19197:                                                nodeInfo->NamespaceID());
19747:     NS_ENSURE_TRUE(newNodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     nodeInfo = newNodeInfo;
    1:   }
    1: 
41636:   nsGenericElement *elem = aNode->IsElement() ?
 3233:                            static_cast<nsGenericElement*>(aNode) :
    1:                            nsnull;
    1: 
    1:   nsCOMPtr<nsINode> clone;
32360:   PRBool isDeepDocumentClone = PR_FALSE;
    1:   if (aClone) {
    1:     rv = aNode->Clone(nodeInfo, getter_AddRefs(clone));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (aParent) {
    1:       // If we're cloning we need to insert the cloned children into the cloned
    1:       // parent.
33674:       rv = aParent->AppendChildTo(static_cast<nsIContent*>(clone.get()),
33674:                                   PR_FALSE);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else if (aDeep && clone->IsNodeOfType(nsINode::eDOCUMENT)) {
32360:       isDeepDocumentClone = PR_TRUE;
    1:       // After cloning the document itself, we want to clone the children into
    1:       // the cloned document (somewhat like cloning and importing them into the
    1:       // cloned document).
    1:       nodeInfoManager = clone->mNodeInfo->NodeInfoManager();
    1:     }
    1:   }
    1:   else if (nodeInfoManager) {
    1:     nsIDocument* oldDoc = aNode->GetOwnerDoc();
28108:     PRBool wasRegistered = PR_FALSE;
41636:     if (oldDoc && aNode->IsElement()) {
41636:       Element* element = aNode->AsElement();
41636:       oldDoc->ClearBoxObjectFor(element);
41636:       wasRegistered = oldDoc->UnregisterFreezableElement(element);
11731:     }
    1: 
    1:     aNode->mNodeInfo.swap(newNodeInfo);
    1: 
    1:     nsIDocument* newDoc = aNode->GetOwnerDoc();
    1:     if (newDoc) {
34207:       // XXX what if oldDoc is null, we don't know if this should be
34207:       // registered or not! Can that really happen?
28108:       if (wasRegistered) {
41636:         newDoc->RegisterFreezableElement(aNode->AsElement());
28108:       }
28108: 
    1:       nsPIDOMWindow* window = newDoc->GetInnerWindow();
    1:       if (window) {
29474:         nsIEventListenerManager* elm = aNode->GetListenerManager(PR_FALSE);
    1:         if (elm) {
    1:           window->SetMutationListeners(elm->MutationListenerBits());
20515:           if (elm->MayHavePaintEventListener()) {
20515:             window->SetHasPaintEventListeners();
20515:           }
51477: #ifdef MOZ_MEDIA
51477:           if (elm->MayHaveAudioAvailableEventListener()) {
51477:             window->SetHasAudioAvailableEventListeners();
51477:           }
51477: #endif
    1:         }
    1:       }
    1:     }
    1: 
34207: #ifdef MOZ_MEDIA
34207:     if (wasRegistered && oldDoc != newDoc) {
34207:       nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aNode));
34207:       if (domMediaElem) {
34207:         nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aNode);
34207:         mediaElem->NotifyOwnerDocumentActivityChanged();
34207:       }
34207:     }
34207: #endif
34207: 
51587:     // nsImageLoadingContent needs to know when its document changes
51587:     if (oldDoc != newDoc) {
51587:       nsCOMPtr<nsIImageLoadingContent> imageContent(do_QueryInterface(aNode));
51587:       if (imageContent)
51587:         imageContent->NotifyOwnerDocumentChanged(oldDoc);
51587:     }
51587: 
    1:     if (elem) {
    1:       elem->RecompileScriptEventListeners();
    1:     }
    1: 
    1:     if (aCx) {
    1:       nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:       if (xpc) {
    1:         nsCOMPtr<nsIXPConnectJSObjectHolder> oldWrapper;
    1:         rv = xpc->ReparentWrappedNativeIfFound(aCx, aOldScope, aNewScope, aNode,
    1:                                                getter_AddRefs(oldWrapper));
    1:         if (NS_FAILED(rv)) {
    1:           aNode->mNodeInfo.swap(nodeInfo);
    1: 
    1:           return rv;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
41743:   // XXX If there are any attribute nodes on this element with UserDataHandlers
41743:   // we should technically adopt/clone/import such attribute nodes and notify
41743:   // those handlers. However we currently don't have code to do so without
41743:   // also notifying when it's not safe so we're not doing that at this time.
    1: 
    1:   // The DOM spec says to always adopt/clone/import the children of attribute
    1:   // nodes.
    1:   // XXX The following block is here because our implementation of attribute
    1:   //     nodes is broken when it comes to inserting children. Instead of cloning
    1:   //     their children we force creation of the only child by calling
    1:   //     GetChildAt(0). We can remove this when
    1:   //     https://bugzilla.mozilla.org/show_bug.cgi?id=56758 is fixed.
    1:   if (aClone && aNode->IsNodeOfType(nsINode::eATTRIBUTE)) {
    1:     nsCOMPtr<nsINode> attrChildNode = aNode->GetChildAt(0);
    1:     // We only need to do this if the child node has properties (because we
    1:     // might need to call a userdata handler).
    1:     if (attrChildNode && attrChildNode->HasProperties()) {
    1:       nsCOMPtr<nsINode> clonedAttrChildNode = clone->GetChildAt(0);
    1:       if (clonedAttrChildNode) {
    1:         PRBool ok = aNodesWithProperties.AppendObject(attrChildNode) &&
    1:                     aNodesWithProperties.AppendObject(clonedAttrChildNode);
    1:         NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
    1:       }
    1:     }
    1:   }
    1:   // XXX End of workaround for broken attribute nodes.
    1:   else if (aDeep || aNode->IsNodeOfType(nsINode::eATTRIBUTE)) {
    1:     // aNode's children.
    1:     PRUint32 i, length = aNode->GetChildCount();
    1:     for (i = 0; i < length; ++i) {
33674:       nsCOMPtr<nsINode> child;
    1:       rv = CloneAndAdopt(aNode->GetChildAt(i), aClone, PR_TRUE, nodeInfoManager,
    1:                          aCx, aOldScope, aNewScope, aNodesWithProperties,
    1:                          clone, getter_AddRefs(child));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   // XXX setting document on some nodes not in a document so XBL will bind
    1:   // and chrome won't break. Make XBL bind to document-less nodes!
    1:   // XXXbz Once this is fixed, fix up the asserts in all implementations of
    1:   // BindToTree to assert what they would like to assert, and fix the
    1:   // ChangeDocumentFor() call in nsXULElement::BindToTree as well.  Also,
    1:   // remove the UnbindFromTree call in ~nsXULElement, and add back in the
    1:   // precondition in nsXULElement::UnbindFromTree and remove the line in
    1:   // nsXULElement.h that makes nsNodeUtils a friend of nsXULElement.
    1:   // Note: Make sure to do this witchery _after_ we've done any deep
    1:   // cloning, so kids of the new node aren't confused about whether they're
    1:   // in a document.
    1: #ifdef MOZ_XUL
41636:   if (aClone && !aParent && aNode->IsElement() &&
41636:       aNode->AsElement()->IsXUL()) {
 3233:     nsXULElement *xulElem = static_cast<nsXULElement*>(elem);
    1:     if (!xulElem->mPrototype || xulElem->IsInDoc()) {
 1498:       clone->SetFlags(NODE_FORCE_XBL_BINDINGS);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   if (aNode->HasProperties()) {
    1:     PRBool ok = aNodesWithProperties.AppendObject(aNode);
    1:     if (aClone) {
    1:       ok = ok && aNodesWithProperties.AppendObject(clone);
    1:     }
    1: 
    1:     NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
33674:   clone.forget(aResult);
33674: 
33674:   return NS_OK;
    1: }
 1391: 
 1391: 
 1391: /* static */
 1391: void
 1391: nsNodeUtils::UnlinkUserData(nsINode *aNode)
 1391: {
 1391:   NS_ASSERTION(aNode->HasProperties(), "Call to UnlinkUserData not needed.");
 1391: 
 1391:   // Strong reference to the document so that deleting properties can't
 1391:   // delete the document.
 1391:   nsCOMPtr<nsIDocument> document = aNode->GetOwnerDoc();
 1391:   if (document) {
41182:     document->PropertyTable(DOM_USER_DATA)->DeleteAllPropertiesFor(aNode);
41182:     document->PropertyTable(DOM_USER_DATA_HANDLER)->DeleteAllPropertiesFor(aNode);
 1391:   }
 1391: }
