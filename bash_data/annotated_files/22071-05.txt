17092: #!/usr/bin/env/python
17092: # qsgen.py - Generate XPConnect quick stubs.
17092: #
17092: # ***** BEGIN LICENSE BLOCK *****
17092: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
17092: #
17092: # The contents of this file are subject to the Mozilla Public License Version
17092: # 1.1 (the "License"); you may not use this file except in compliance with
17092: # the License. You may obtain a copy of the License at
17092: # http://www.mozilla.org/MPL/
17092: #
17092: # Software distributed under the License is distributed on an "AS IS" basis,
17092: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
17092: # for the specific language governing rights and limitations under the
17092: # License.
17092: #
17092: # The Original Code is mozilla.org code.
17092: #
17092: # The Initial Developer of the Original Code is
17092: #   Mozilla Foundation.
17092: # Portions created by the Initial Developer are Copyright (C) 2008
17092: # the Initial Developer. All Rights Reserved.
17092: #
17092: # Contributor(s):
17092: #   Jason Orendorff <jorendorff@mozilla.com>
17092: #
17092: # Alternatively, the contents of this file may be used under the terms of
17092: # either of the GNU General Public License Version 2 or later (the "GPL"),
17092: # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
17092: # in which case the provisions of the GPL or the LGPL are applicable instead
17092: # of those above. If you wish to allow use of your version of this file only
17092: # under the terms of either the GPL or the LGPL, and not to allow others to
17092: # use your version of this file under the terms of the MPL, indicate your
17092: # decision by deleting the provisions above and replace them with the notice
17092: # and other provisions required by the GPL or the LGPL. If you do not delete
17092: # the provisions above, a recipient may use your version of this file under
17092: # the terms of any one of the MPL, the GPL or the LGPL.
17092: #
17092: # ***** END LICENSE BLOCK *****
17092: 
17092: # =About quick stubs=
17092: # qsgen.py generates "quick stubs", custom SpiderMonkey getters, setters, and
17092: # methods for specified XPCOM interface members.  These quick stubs serve at
17092: # runtime as replacements for the XPConnect functions XPC_WN_GetterSetter and
17092: # XPC_WN_CallMethod, which are the extremely generic (and slow) SpiderMonkey
17092: # getter/setter/methods otherwise used for all XPCOM member accesses from JS.
17092: #
17092: # There are two ways quick stubs win:
17092: #   1. Pure, transparent optimization by partial evaluation.
17092: #   2. Cutting corners.
17092: #
17092: # == Partial evaluation ==
17092: # Partial evaluation is when you execute part of a program early (before or at
17092: # compile time) so that you don't have to execute it at run time.  In this
17092: # case, everything that involves interpreting xptcall data (for example, the
17092: # big methodInfo loops in XPCWrappedNative::CallMethod and the switch statement
17092: # in XPCConert::JSData2Native) might as well happen at build time, since all
17092: # the type information for any given member is already known.  That's what this
17092: # script does.  It gets the information from IDL instead of XPT files.  Apart
17092: # from that, the code in this script is very similar to what you'll find in
17092: # XPConnect itself.  The advantage is that it runs once, at build time, not in
17092: # tight loops at run time.
17092: #
17092: # == Cutting corners ==
17092: # The XPConnect versions have to be slow because they do tons of work that's
17092: # only necessary in a few cases.  The quick stubs skip a lot of that work.  So
17092: # quick stubs necessarily differ from XPConnect in potentially observable ways.
17092: # For many specific interface members, the differences are not observable from
17092: # scripts or don't matter enough to worry about; but you do have to be careful
17092: # which members you decide to generate quick stubs for.
17092: #
17092: # The complete list of known differences, as of this writing, after an
17092: # assiduous search:
17092: #
19260: # - Quick stubs affect the handling of naming conflicts--that is, which C++
19260: #   method gets called when a script uses an XPCOM feature that is declared in
19260: #   more than one of the interfaces the object implements.  Without quick
19260: #   stubs, XPConnect just walks the interfaces in the order they're listed by
19260: #   nsClassInfo.  You get the first interface that implements a feature with
19260: #   that name.  With quick stubs, it's the same except that non-quick-stubbed
19260: #   features are shadowed.
17092: #
17092: # - Quick stub getters and setters are JSPropertyOps-- that is, they do not use
17092: #   JSPROP_GETTER or JSPROP_SETTER.  This means __lookupGetter__ does not work
17092: #   on them.  This change is visible to scripts.
17092: #
17092: # - Quick stub methods are JSFastNative, which means that when a quick stub
17092: #   method is called, no JS stack frame is created.  This doesn't affect
17092: #   Mozilla security checks because they look for scripted JSStackFrames, not
17092: #   native ones.
17092: #
17092: #   It does affect the 'stack' property of JavaScript exceptions, though: the
17092: #   stubbed member will not appear.  (Note that if the stubbed member itself
17092: #   fails, the member name will appear in the 'message' property.)
17092: #
17092: # - Many quick stubs don't create an XPCCallContext.  In those cases, no entry
17092: #   is added to the XPCCallContext stack.  So native implementations of
17092: #   quick-stubbed methods must avoid nsXPConnect::GetCurrentNativeCallContext.
17092: #
17092: #   (Even when a quick stub does have an XPCCallContext, it never pushes it all
17092: #   the way to READY_TO_CALL state, so a lot of its members are garbage.  But
17092: #   this doesn't endanger native implementations of non-quick-stubbed methods
17092: #   that use GetCurrentNativeCallContext and are called indirectly from
17092: #   quick-stubbed methods, because only the current top XPCCallContext is
17092: #   exposed--nsAXPCNativeCallContext does not expose
17092: #   XPCCallContext::GetPrevCallContext.)
17092: #
17092: # - There are a few differences in how the "this" JSObject is unwrapped.
17092: #   Ordinarily, XPConnect searches the prototype chain of the "this" JSObject
17092: #   for an XPCOM object of the desired "proto".  For details, see the parts of
17092: #   XPCWrappedNative::GetWrappedNativeOfJSObject that use "proto".  Some quick
17092: #   stubs (methods, not getters or setters, that have XPCCallContexts) do this,
17092: #   but most instead look for an XPCOM object that supports the desired
17092: #   *interface*.  This is more lenient.  The difference is observable in some
17092: #   cases where a getter/setter/method is taken from one object and applied to
17092: #   another object.
17092: #
17092: # - Quick stubs never suspend the JS request.  So they are only suitable for
17092: #   main-thread-only interfaces.
17092: #
17092: # - Quick stubs don't call XPCContext::SetLastResult.  This is visible on the
17092: #   Components object.
17092: #
17092: # - Quick stubs skip a security check that XPConnect does in
17092: #   XPCWrappedNative::CallMethod.  This means the security manager doesn't have
17092: #   an opportunity to veto accesses to members for which quick stubs exist.
17092: #
17092: # - There are many features of IDL that XPConnect supports but qsgen does not,
17092: #   including dependent types, arrays, and out parameters.
17092: 
17092: 
17092: import xpidl
17092: import header
17092: import os, re
17092: import sys
17092: import sets
17092: 
17092: # === Preliminaries
17092: 
17092: # --makedepend-output support.
17092: make_dependencies = []
17092: make_targets = []
17092: 
17092: def warn(msg):
17092:     sys.stderr.write(msg + '\n')
17092: 
17092: def unaliasType(t):
17092:     while t.kind == 'typedef':
17092:         t = t.realtype
17092:     assert t is not None
17092:     return t
17092: 
17092: def isVoidType(type):
17092:     """ Return True if the given xpidl type is void. """
17092:     return type.kind == 'builtin' and type.name == 'void'
17092: 
17092: def isInterfaceType(t):
17092:     t = unaliasType(t)
17092:     assert t.kind in ('builtin', 'native', 'interface', 'forward')
17092:     return t.kind in ('interface', 'forward')
17092: 
17092: def isSpecificInterfaceType(t, name):
17092:     """ True if `t` is an interface type with the given name, or a forward
17092:     declaration or typedef aliasing it.
17092: 
17092:     `name` must not be the name of a typedef but the actual name of the
17092:     interface.
17092:     """
17092:     t = unaliasType(t)
17092:     return t.kind in ('interface', 'forward') and t.name == name
17092: 
17092: def getBuiltinOrNativeTypeName(t):
17092:     t = unaliasType(t)
17092:     if t.kind == 'builtin':
17092:         return t.name
17092:     elif t.kind == 'native':
17092:         assert t.specialtype is not None
17092:         return '[%s]' % t.specialtype
17092:     else:
17092:         return None
17092: 
17092: 
17092: # === Reading the file
17092: 
17092: class UserError(Exception):
17092:     pass
17092: 
17092: def findIDL(includePath, irregularFilenames, interfaceName):
17092:     filename = irregularFilenames.get(interfaceName, interfaceName) + '.idl'
17092:     for d in includePath:
18544:         # Not os.path.join: we need a forward slash even on Windows because
18544:         # this filename ends up in makedepend output.
18544:         path = d + '/' + filename
17092:         if os.path.exists(path):
17092:             return path
17092:     raise UserError("No IDL file found for interface %s "
17092:                     "in include path %r"
17092:                     % (interfaceName, includePath))
17092: 
17092: def loadIDL(parser, includePath, filename):
17092:     make_dependencies.append(filename)
17092:     text = open(filename, 'r').read()
17092:     idl = parser.parse(text, filename=filename)
17092:     idl.resolve(includePath, parser)
17092:     return idl
17092: 
17092: def addStubMember(memberId, member):
17092:     # Check that the member is ok.
17092:     if member.kind not in ('method', 'attribute'):
17092:         raise UserError("Member %s is %r, not a method or attribute."
17092:                         % (memberId, member.kind))
17092:     if member.noscript:
17092:         raise UserError("%s %s is noscript."
17092:                         % (member.kind.capitalize(), memberId))
17092:     if member.notxpcom:
17092:         raise UserError(
17092:             "%s %s: notxpcom methods are not supported."
17092:             % (member.kind.capitalize(), memberId))
17092: 
17092:     if (member.kind == 'attribute'
17092:           and not member.readonly
17092:           and isSpecificInterfaceType(member.realtype, 'nsIVariant')):
17092:         raise UserError(
17092:             "Attribute %s: Non-readonly attributes of type nsIVariant "
17092:             "are not supported."
17092:             % memberId)
17092: 
17092:     # Check for unknown properties.
17092:     for attrname, value in vars(member).items():
17092:         if value is True and attrname not in ('readonly',):
17092:             raise UserError("%s %s: unrecognized property %r"
17092:                             % (member.kind.capitalize(), memberId,
17092:                                attrname))
17092:     if member.kind == 'method':
17092:         for param in member.params:
17092:             for attrname, value in vars(param).items():
17092:                 if value is True and attrname not in ('optional',):
17092:                     raise UserError("Method %s, parameter %s: "
17092:                                     "unrecognized property %r"
17092:                                     % (memberId, param.name, attrname))
17092: 
17092:     # Add this member to the list.
17092:     member.iface.stubMembers.append(member)
17092: 
17092: def parseMemberId(memberId):
17092:     """ Split the geven member id into its parts. """
17092:     pieces = memberId.split('.')
17092:     if len(pieces) < 2:
17092:         raise UserError("Member %r: Missing dot." % memberId)
17092:     if len(pieces) > 2:
17092:         raise UserError("Member %r: Dots out of control." % memberId)
17092:     return tuple(pieces)
17092: 
17092: class Configuration:
17092:     def __init__(self, filename, includePath):
17092:         self.includePath = includePath
17092:         config = {}
17092:         execfile(filename, config)
17092:         # required settings
17092:         for name in ('name', 'members'):
17092:             if name not in config:
17092:                 raise UserError(filename + ": `%s` was not defined." % name)
17092:             setattr(self, name, config[name])
17092:         # optional settings
17092:         self.irregularFilenames = config.get('irregularFilenames', {})
17092: 
17092: def readConfigFile(filename, includePath, cachedir):
17092:     # Read the config file.
17092:     conf = Configuration(filename, includePath)
17092: 
17092:     # Now read IDL files to connect the information in the config file to
17092:     # actual XPCOM interfaces, methods, and attributes.
17092:     interfaces = []
17092:     interfacesByName = {}
17092:     parser = xpidl.IDLParser(cachedir)
17092: 
17092:     def getInterface(interfaceName, errorLoc):
17092:         iface = interfacesByName.get(interfaceName)
17092:         if iface is None:
17092:             idlFile = findIDL(conf.includePath, conf.irregularFilenames,
17092:                               interfaceName)
17092:             idl = loadIDL(parser, conf.includePath, idlFile)
17092:             if not idl.hasName(interfaceName):
17092:                 raise UserError("The interface %s was not found "
17092:                                 "in the idl file %r."
17092:                                 % (interfaceName, idlFile))
17092:             iface = idl.getName(interfaceName, errorLoc)
17092:             iface.stubMembers = []
17092:             interfaces.append(iface)
17092:             interfacesByName[interfaceName] = iface
17092:         return iface
17092: 
17092:     for memberId in conf.members:
17092:         interfaceName, memberName = parseMemberId(memberId)
17092:         iface = getInterface(interfaceName, errorLoc='looking for %r' % memberId)
17092: 
17092:         if not iface.attributes.scriptable:
17092:             raise UserError("Interface %s is not scriptable. "
17092:                             "IDL file: %r." % (interfaceName, idlFile))
17092: 
17092:         if memberName == '*':
17092:             # Stub all scriptable members of this interface.
17092:             for member in iface.members:
17092:                 if member.kind in ('method', 'attribute') and not member.noscript:
17092:                     addStubMember(iface.name + '.' + member.name, member)
17092:         else:
17092:             # Look up a member by name.
17092:             if memberName not in iface.namemap:
17092:                 idlFile = iface.idl.parser.lexer.filename
17092:                 raise UserError("Interface %s has no member %r. "
17092:                                 "(See IDL file %r.)"
17092:                                 % (interfaceName, memberName, idlFile))
17092:             member = iface.namemap.get(memberName, None)
17092:             if member in iface.stubMembers:
17092:                 raise UserError("Member %s is specified more than once."
17092:                                 % memberId)
17092:             addStubMember(memberId, member)
17092: 
17092:     return conf, interfaces
17092: 
17092: 
17092: # === Generating the header file
17092: 
17092: def writeHeaderFile(filename, name):
17092:     print "Creating header file", filename
17092:     make_targets.append(filename)
17092: 
17092:     headerMacro = '__gen_%s__' % filename.replace('.', '_')
17092:     f = open(filename, 'w')
17092:     try:
17092:         f.write("/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n"
17092:                 "#ifndef " + headerMacro + "\n"
22071:                 "#define " + headerMacro + "\n"
17092:                 "JSBool " + name + "_DefineQuickStubs("
17092:                 "JSContext *cx, JSObject *proto, uintN flags, "
22071:                 "PRUint32 count, const nsID **iids);\n"
17092:                 "#endif\n")
17092:     finally:
17092:         f.close()
17092: 
17092: # === Generating the source file
17092: 
17092: def substitute(template, vals):
17092:     """ Simple replacement for string.Template, which isn't in Python 2.3. """
17092:     def replacement(match):
17092:         return vals[match.group(1)]
17092:     return re.sub(r'\${(\w+)}', replacement, template)
17092: 
17092: # From JSData2Native.
17092: argumentUnboxingTemplates = {
17092:     'short':
17092:         "    int32 ${name}_i32;\n"
21218:         "    if (!JS_ValueToECMAInt32(cx, ${argVal}, &${name}_i32))\n"
21218:         "        return JS_FALSE;\n"
17092:         "    int16 ${name} = (int16) ${name}_i32;\n",
17092: 
17092:     'unsigned short':
17092:         "    uint32 ${name}_u32;\n"
21218:         "    if (!JS_ValueToECMAUint32(cx, ${argVal}, &${name}_u32))\n"
21218:         "        return JS_FALSE;\n"
17092:         "    uint16 ${name} = (uint16) ${name}_u32;\n",
17092: 
17092:     'long':
17092:         "    int32 ${name};\n"
21218:         "    if (!JS_ValueToECMAInt32(cx, ${argVal}, &${name}))\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     'unsigned long':
17092:         "    uint32 ${name};\n"
21218:         "    if (!JS_ValueToECMAUint32(cx, ${argVal}, &${name}))\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     'float':
17092:         "    jsdouble ${name}_dbl;\n"
21218:         "    if (!JS_ValueToNumber(cx, ${argVal}, &${name}_dbl))\n"
21218:         "        return JS_FALSE;\n"
17092:         "    float ${name} = (float) ${name}_dbl;\n",
17092: 
17092:     'double':
17092:         "    jsdouble ${name};\n"
21218:         "    if (!JS_ValueToNumber(cx, ${argVal}, &${name}))\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     'boolean':
17092:         "    PRBool ${name};\n"
21218:         "    if (!JS_ValueToBoolean(cx, ${argVal}, &${name}))\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     '[astring]':
17092:         "    xpc_qsAString ${name}(cx, ${argPtr});\n"
21218:         "    if (!${name}.IsValid())\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     '[domstring]':
17092:         "    xpc_qsDOMString ${name}(cx, ${argPtr});\n"
21218:         "    if (!${name}.IsValid())\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     'string':
17092:         "    char *${name};\n"
21218:         "    if (!xpc_qsJsvalToCharStr(cx, ${argPtr}, &${name}))\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     'wstring':
17092:         "    PRUnichar *${name};\n"
21218:         "    if (!xpc_qsJsvalToWcharStr(cx, ${argPtr}, &${name}))\n"
21218:         "        return JS_FALSE;\n",
17092: 
17092:     '[cstring]':
17092:         "    xpc_qsACString ${name}(cx, ${argPtr});\n"
21218:         "    if (!${name}.IsValid())\n"
21218:         "        return JS_FALSE;\n"
17092:     }
17092: 
17092: # From JSData2Native.
17092: #
17092: # Omitted optional arguments are treated as though the caller had passed JS
17092: # `null`; this behavior is from XPCWrappedNative::CallMethod.
17092: #
17092: def writeArgumentUnboxing(f, i, name, type, haveCcx, optional):
17092:     # f - file to write to
17092:     # i - int or None - Indicates the source jsval.  If i is an int, the source
17092:     #     jsval is argv[i]; otherwise it is *vp.  But if Python i >= C++ argc,
17092:     #     which can only happen if optional is True, the argument is missing;
17092:     #     use JSVAL_NULL as the source jsval instead.
17092:     # name - str - name of the native C++ variable to create.
17092:     # type - xpidl.{Interface,Native,Builtin} - IDL type of argument
17092:     # optional - bool - True if the parameter is optional.
17092: 
17092:     isSetter = (i is None)
17092: 
17092:     if isSetter:
17092:         argPtr = "vp"
17092:         argVal = "*vp"
17092:     elif optional:
17092:         argPtr = '!  /* TODO - optional parameter of this type not supported */'
17092:         argVal = "(%d < argc ? argv[%d] : JSVAL_NULL)" % (i, i)
17092:     else:
17092:         argVal = "argv[%d]" % i
17092:         argPtr = "&" + argVal
17092: 
17092:     params = {
17092:         'name': name,
17092:         'argVal': argVal,
21218:         'argPtr': argPtr
17092:         }
17092: 
17092:     typeName = getBuiltinOrNativeTypeName(type)
17092:     if typeName is not None:
17092:         template = argumentUnboxingTemplates.get(typeName)
17092:         if template is not None:
17092:             if optional and ("${argPtr}" in template):
17092:                 warn("Optional parameters of type %s are not supported."
17092:                      % type.name)
17092:             f.write(substitute(template, params))
17092:             return
17092:         # else fall through; the type isn't supported yet.
17092:     elif isInterfaceType(type):
17092:         if type.name == 'nsIVariant':
17092:             # Totally custom.
17092:             assert haveCcx
17092:             template = (
17092:                 "    nsCOMPtr<nsIVariant> ${name}(already_AddRefed<nsIVariant>("
17092:                 "XPCVariant::newVariant(ccx, ${argVal})));\n"
21218:                 "    if (!${name})\n"
21218:                 "        return JS_FALSE;\n")
17092:             f.write(substitute(template, params))
17092:             return
17092:         elif type.name == 'nsIAtom':
17092:             # Should have special atomizing behavior.  Fall through.
17092:             pass
17092:         else:
17092:             f.write("    nsCOMPtr<%s> %s;\n" % (type.name, name))
17092:             f.write("    rv = xpc_qsUnwrapArg<%s>("
17092:                     "cx, %s, getter_AddRefs(%s));\n"
17092:                     % (type.name, argVal, name))
17092:             f.write("    if (NS_FAILED(rv)) {\n")
17092:             if isSetter:
17092:                 f.write("        xpc_qsThrowBadSetterValue("
21218:                         "cx, rv, JSVAL_TO_OBJECT(*tvr.addr()), id);\n")
17092:             elif haveCcx:
17092:                 f.write("        xpc_qsThrowBadArgWithCcx(ccx, rv, %d);\n" % i)
17092:             else:
21218:                 f.write("        xpc_qsThrowBadArg(cx, rv, vp, %d);\n" % i)
21218:             f.write("        return JS_FALSE;\n"
21218:                     "    }\n")
17092:             return
17092: 
17092:     warn("Unable to unbox argument of type %s" % type.name)
17092:     if i is None:
17092:         src = '*vp'
17092:     else:
17092:         src = 'argv[%d]' % i
17092:     f.write("    !; // TODO - Unbox argument %s = %s\n" % (name, src))
17092: 
17092: def writeResultDecl(f, type):
17092:     if isVoidType(type):
17092:         return  # nothing to declare
17092:     
17092:     t = unaliasType(type)
17092:     if t.kind == 'builtin':
17092:         if not t.nativename.endswith('*'):
17092:             if type.kind == 'typedef':
17092:                 typeName = type.name  # use it
17092:             else:
17092:                 typeName = t.nativename
17092:             f.write("    %s result;\n" % typeName)
17092:             return
17092:     elif t.kind == 'native':
17092:         name = getBuiltinOrNativeTypeName(t)
17092:         if name in ('[domstring]', '[astring]'):
17092:             f.write("    nsString result;\n")
17092:             return
17092:     elif t.kind in ('interface', 'forward'):
17092:         f.write("    nsCOMPtr<%s> result;\n" % type.name)
17092:         return
17092: 
17092:     warn("Unable to declare result of type %s" % type.name)
17092:     f.write("    !; // TODO - Declare out parameter `result`.\n")
17092: 
17092: def outParamForm(name, type):
17092:     type = unaliasType(type)
17092:     if type.kind == 'builtin':
17092:         return '&' + name
17092:     elif type.kind == 'native':
17092:         if type.modifier == 'ref':
17092:             return name
17092:         else:
17092:             return '&' + name
17092:     else:
17092:         return 'getter_AddRefs(%s)' % name
17092: 
17092: # From NativeData2JS.
17092: resultConvTemplates = {
17092:     'void':
17092:             "    ${jsvalRef} = JSVAL_VOID;\n"
17092:             "    return JS_TRUE;\n",
17092: 
17092:     'short':
17092:         "    ${jsvalRef} = INT_TO_JSVAL((int32) result);\n"
17092:         "    return JS_TRUE;\n",
17092: 
17092:     'long':
17092:         "    return xpc_qsInt32ToJsval(cx, result, ${jsvalPtr});\n",
17092: 
17092:     'long long':
17092:         "    return xpc_qsInt64ToJsval(cx, result, ${jsvalPtr};\n",
17092: 
17092:     'unsigned short':
17092:         "    ${jsvalRef} = INT_TO_JSVAL((int32) result);\n"
17092:         "    return JS_TRUE;\n",
17092: 
17092:     'unsigned long':
17092:         "    return xpc_qsUint32ToJsval(cx, result, ${jsvalPtr});\n",
17092: 
17092:     'unsigned long long':
17092:         "    return xpc_qsUint64ToJsval(cx, result, ${jsvalPtr});\n",
17092: 
17092:     'float':
17092:         "    return JS_NewNumberValue(cx, result, ${jsvalPtr});\n",
17092: 
17092:     'double':
17092:         "    return JS_NewNumberValue(cx, result, ${jsvalPtr});\n",
17092: 
17092:     'boolean':
17092:         "    ${jsvalRef} = (result ? JSVAL_TRUE : JSVAL_FALSE);\n"
17092:         "    return JS_TRUE;\n",
17092: 
17092:     '[astring]':
17092:         "    return xpc_qsStringToJsval(cx, result, ${jsvalPtr});\n",
17092: 
17092:     '[domstring]':
17092:         "    return xpc_qsStringToJsval(cx, result, ${jsvalPtr});\n"
17092:     }    
17092: 
17092: def isVariantType(t):
17092:     return isSpecificInterfaceType(t, 'nsIVariant')
17092: 
17092: def writeResultConv(f, type, paramNum, jsvalPtr, jsvalRef):
17092:     """ Emit code to convert the C++ variable `result` to a jsval.
17092: 
17092:     The emitted code contains a return statement; it returns JS_TRUE on
17092:     success, JS_FALSE on error.
17092:     """
17092:     # From NativeData2JS.
17092:     typeName = getBuiltinOrNativeTypeName(type)
17092:     if typeName is not None:
17092:         template = resultConvTemplates.get(typeName)
17092:         if template is not None:
17092:             values = {'jsvalRef': jsvalRef,
17092:                       'jsvalPtr': jsvalPtr}
17092:             f.write(substitute(template, values))
17092:             return
17092:         # else fall through; this type isn't supported yet
17092:     elif isInterfaceType(type):
17092:         if isVariantType(type):
17092:             f.write("    return xpc_qsVariantToJsval(ccx, result, %d, %s);\n"
17092:                     % (paramNum, jsvalPtr))
17092:             return
17092:         else:
17092:             f.write("    return xpc_qsXPCOMObjectToJsval(ccx, result, "
22071:                     "NS_GET_IID(%s), %s);\n" % (type.name, jsvalPtr))
17092:             return
17092: 
17092:     warn("Unable to convert result of type %s" % type.name)
17092:     f.write("    !; // TODO - Convert `result` to jsval, store in `%s`.\n"
17092:             % jsvalRef)
17092:     f.write("    return xpc_qsThrow(cx, NS_ERROR_UNEXPECTED); // FIXME\n")
17092: 
17092: def anyParamRequiresCcx(member):
17092:     for p in member.params:
17092:         if isVariantType(p.realtype):
17092:             return True
17092:     return False
17092: 
17092: def writeQuickStub(f, member, stubName, isSetter=False):
17092:     """ Write a single quick stub (a custom SpiderMonkey getter/setter/method)
17092:     for the specified XPCOM interface-member. 
17092:     """
17092:     isAttr = (member.kind == 'attribute')
17092:     isMethod = (member.kind == 'method')
17092:     assert isAttr or isMethod
17092:     isGetter = isAttr and not isSetter
17092: 
17092:     # Function prolog.
18908:     f.write("static JSBool\n")
17092:     if isAttr:
17092:         # JSPropertyOp signature.
17092:         f.write(stubName + "(JSContext *cx, JSObject *obj, jsval id, "
17092:                 "jsval *vp)\n")
17092:     else:
17092:         # JSFastNative.
17092:         f.write(stubName + "(JSContext *cx, uintN argc, jsval *vp)\n")
17092:     f.write("{\n")
17092:     f.write("    XPC_QS_ASSERT_CONTEXT_OK(cx);\n")
17092: 
17092:     # For methods, compute "this".
17092:     if isMethod:
17092:         f.write("    JSObject *obj = JS_THIS_OBJECT(cx, vp);\n"
17092:                 "    if (!obj)\n"
17092:                 "        return JS_FALSE;\n")
17092: 
17092:     # Create ccx if needed.
17092:     haveCcx = isMethod and (isInterfaceType(member.realtype)
17092:                             or anyParamRequiresCcx(member))
17092:     if haveCcx:
17092:             f.write("    XPCCallContext ccx(JS_CALLER, cx, obj, "
17092:                     "JSVAL_TO_OBJECT(JS_CALLEE(cx, vp)));\n")
17092:     else:
17092:         # In some cases we emit a ccx, but it does not count as
17092:         # "haveCcx" because it's not complete.
17092:         if isAttr and isInterfaceType(member.realtype):
17092:             f.write("    XPCCallContext ccx(JS_CALLER, cx, obj);\n")
17092: 
17092:     # Get the 'self' pointer.
17092:     thisType = member.iface.name
17092:     f.write("    %s *self;\n" % thisType)
21218:     f.write("    xpc_qsSelfRef selfref;\n")
17092:     # Don't use FromCcx for getters or setters; the way we construct the ccx in
17092:     # a getter/setter causes it to find the wrong wrapper in some cases.
17092:     if isMethod and haveCcx:
21218:         # Undocumented, but the interpreter puts 'this' at argv[-1],
21218:         # which is vp[1]; and it's ok to overwrite it.
21218:         f.write("    if (!xpc_qsUnwrapThisFromCcx(ccx, &self, &selfref.ptr, "
21218:                 "&vp[1]))\n")
21218:         f.write("        return JS_FALSE;\n")
17092:     else:
21218:         if isGetter:
21218:             pthisval = 'vp'
21218:         elif isSetter:
21218:             f.write("    xpc_qsTempRoot tvr(cx);\n")
21218:             pthisval = 'tvr.addr()'
21218:         else:
21218:             pthisval = '&vp[1]' # as above, ok to overwrite vp[1]
21218: 
21218:         f.write("    if (!xpc_qsUnwrapThis(cx, obj, &self, &selfref.ptr, "
21218:                 "%s))\n" % pthisval)
21218:         f.write("        return JS_FALSE;\n")
17092: 
17092:     if isMethod:
17092:         # If there are any required arguments, check argc.
17092:         requiredArgs = len(member.params)
17092:         while requiredArgs and member.params[requiredArgs-1].optional:
17092:             requiredArgs -= 1
17092:         if requiredArgs:
21218:             f.write("    if (argc < %d)\n" % requiredArgs)
21218:             f.write("        return xpc_qsThrow(cx, "
21218:                     "NS_ERROR_XPC_NOT_ENOUGH_ARGS);\n")
17092: 
17092:     def pfail(msg):
17092:         raise UserError(
17092:             member.iface.name + '.' + member.name + ": "
17092:             "parameter " + param.name + ": " + msg)
17092: 
17092:     # Convert in-parameters.
17092:     f.write("    nsresult rv;\n")
17092:     if isMethod:
17092:         if len(member.params) > 0:
17092:             f.write("    jsval *argv = JS_ARGV(cx, vp);\n")
17092:         for i, param in enumerate(member.params):
17092:             if param.iid_is is not None:
17092:                 pfail("iid_is parameters are not supported.")
17092:             if param.size_is is not None:
17092:                 pfail("size_is parameters are not supported.")
17092:             if param.retval:
17092:                 pfail("Unexpected retval parameter!")
17092:             if param.paramtype in ('out', 'inout'):
17092:                 pfail("Out parameters are not supported.")
17092:             if param.const or param.array or param.shared:
17092:                 pfail("I am a simple caveman.")
17092:             # Emit code to convert this argument from jsval.
17092:             writeArgumentUnboxing(
17092:                 f, i, 'arg%d' % i, param.realtype,
17092:                 haveCcx=haveCcx,
17092:                 optional=param.optional)
17092:     elif isSetter:
17092:         writeArgumentUnboxing(f, None, 'arg0', member.realtype,
17092:                               haveCcx=False, optional=False)
17092: 
17092:     # Prepare out-parameter.
17092:     if isMethod or isGetter:
17092:         writeResultDecl(f, member.realtype)
17092: 
17092:     # Call the method.
17092:     if isMethod:
17092:         comName = header.methodNativeName(member)
17092:         argv = ['arg' + str(i) for i, p in enumerate(member.params)]
17092:         if not isVoidType(member.realtype):
17092:             argv.append(outParamForm('result', member.realtype))
17092:         args = ', '.join(argv)
17092:     else:
17092:         comName = header.attributeNativeName(member, isGetter)
17092:         if isGetter:
17092:             args = outParamForm("result", member.realtype)
17092:         else:
17092:             args = "arg0"
17092:     f.write("    rv = self->%s(%s);\n" % (comName, args))
17092: 
17092:     # Check for errors.
17092:     f.write("    if (NS_FAILED(rv))\n")
17092:     if isMethod:
17092:         if haveCcx:
17092:             f.write("        return xpc_qsThrowMethodFailedWithCcx(ccx, rv);\n")
17092:         else:
17092:             f.write("        return xpc_qsThrowMethodFailed("
21218:                     "cx, rv, vp);\n")
17092:     else:
21218:         if isGetter:
21218:             thisval = '*vp'
21218:         else:
21218:             thisval = '*tvr.addr()'
21218:         f.write("        return xpc_qsThrowGetterSetterFailed(cx, rv, " +
21218:                 "JSVAL_TO_OBJECT(%s), id);\n" % thisval)
17092: 
17092:     # Convert the return value.
17092:     if isMethod:
17092:         writeResultConv(f, member.realtype, len(member.params) + 1, 'vp', '*vp')
17092:     elif isGetter:
17092:         writeResultConv(f, member.realtype, None, 'vp', '*vp')
17092:     else:
21218:         f.write("    return JS_TRUE;\n")
17092: 
17092:     # Epilog.
17092:     f.write("}\n\n")
17092: 
17092: def writeAttrStubs(f, attr):
17092:     getterName = (attr.iface.name + '_'
17092:                   + header.attributeNativeName(attr, True))
17092:     writeQuickStub(f, attr, getterName)
17092:     if attr.readonly:
17092:         setterName = 'xpc_qsReadOnlySetter'
17092:     else:
17092:         setterName = (attr.iface.name + '_'
17092:                       + header.attributeNativeName(attr, False))
17092:         writeQuickStub(f, attr, setterName, isSetter=True)
17092: 
17092:     ps = ('{"%s", %s, %s}'
17092:           % (attr.name, getterName, setterName))
17092:     return ps
17092: 
17092: def writeMethodStub(f, method):
17092:     """ Write a method stub to `f`. Return an xpc_qsFunctionSpec initializer. """
17092:     stubName = method.iface.name + '_' + header.methodNativeName(method)
17092:     writeQuickStub(f, method, stubName)
17092:     fs = '{"%s", %s, %d}' % (method.name, stubName, len(method.params))
17092:     return fs
17092: 
17092: def writeStubsForInterface(f, iface):
17092:     f.write("// === interface %s\n\n" % iface.name)
17092:     propspecs = []
17092:     funcspecs = []
17092:     for member in iface.stubMembers:
17092:         if member.kind == 'attribute':
17092:             ps = writeAttrStubs(f, member)
17092:             propspecs.append(ps)
17092:         elif member.kind == 'method':
17092:             fs = writeMethodStub(f, member)
17092:             funcspecs.append(fs)
17092:         else:
17092:             raise TypeError('expected attribute or method, not %r'
17092:                             % member.__class__.__name__)
17092: 
17092:     if propspecs:
17092:         f.write("static const xpc_qsPropertySpec %s_properties[] = {\n"
17092:                 % iface.name)
17092:         for ps in propspecs:
17092:             f.write("    %s,\n" % ps)
17092:         f.write("    {nsnull}};\n")
17092:     if funcspecs:
17092:         f.write("static const xpc_qsFunctionSpec %s_functions[] = {\n" % iface.name)
17092:         for fs in funcspecs:
17092:             f.write("    %s,\n" % fs)
17092:         f.write("    {nsnull}};\n")
17092:     f.write('\n\n')
17092: 
17092: def hashIID(iid):
17092:     # See nsIDKey::HashCode in nsHashtable.h.
17092:     return int(iid[:8], 16)
17092: 
17092: uuid_re = re.compile(r'^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$')
17092: 
17092: def writeDefiner(f, conf, interfaces):
17092:     f.write("// === Definer\n\n")
17092: 
17092:     # generate the static hash table
17092:     loadFactor = 0.6
17092:     size = int(len(interfaces) / loadFactor)
17092:     buckets = [[] for i in range(size)]
17092:     for iface in interfaces:
17092:         # This if-statement discards interfaces specified with
17092:         # "nsInterfaceName.*" that don't have any stub-able members.
17092:         if iface.stubMembers:
17092:             h = hashIID(iface.attributes.uuid)
17092:             buckets[h % size].append(iface)
17092: 
17092:     # Calculate where each interface's entry will show up in tableData.  Where
17092:     # there are hash collisions, the extra entries are added at the end of the
17092:     # table.
17092:     entryIndexes = {}
17092:     arraySize = size
17092:     for i, bucket in enumerate(buckets):
17092:         if bucket:
17092:             entryIndexes[bucket[0].attributes.uuid] = i
17092:             for iface in bucket[1:]:
17092:                 entryIndexes[iface.attributes.uuid] = arraySize
17092:                 arraySize += 1
17092: 
17092:     entries = ["    {{0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0}}, "
17092:                "nsnull, nsnull, XPC_QS_NULL_INDEX, XPC_QS_NULL_INDEX}"
17092:                for i in range(arraySize)]
17092:     for i, bucket in enumerate(buckets):
17092:         for j, iface in enumerate(bucket):
17092:             # iid field
17092:             uuid = iface.attributes.uuid.lower()
17092:             m = uuid_re.match(uuid)
17092:             assert m is not None
17092:             m0, m1, m2, m3, m4 = m.groups()
17092:             m3arr = ('{0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s, 0x%s}'
17092:                      % (m3[0:2], m3[2:4], m4[0:2], m4[2:4],
17092:                         m4[4:6], m4[6:8], m4[8:10], m4[10:12]))
17092:             iid = ('{0x%s, 0x%s, 0x%s, %s}' % (m0, m1, m2, m3arr))
17092: 
17092:             # properties field
17092:             properties = "nsnull"
17092:             for member in iface.stubMembers:
17092:                 if member.kind == 'attribute':
17092:                     properties = iface.name + "_properties"
17092:                     break
17092:             functions = "nsnull"
17092: 
17092:             # member field
17092:             for member in iface.stubMembers:
17092:                 if member.kind == 'method':
17092:                     functions = iface.name + "_functions"
17092:                     break
17092: 
17092:             # parentInterface field
17092:             baseName = iface.base
17092:             while baseName is not None:
17092:                 piface = iface.idl.getName(baseName, None)
17092:                 k = entryIndexes.get(piface.attributes.uuid)
17092:                 if k is not None:
17092:                     parentInterface = str(k)
17092:                     break
17092:                 baseName = piface.base
17092:             else:
17092:                 parentInterface = "XPC_QS_NULL_INDEX"
17092: 
17092:             # chain field
17092:             if j == len(bucket) - 1:
17092:                 chain = "XPC_QS_NULL_INDEX"
17092:             else:
17092:                 k = entryIndexes[bucket[j+1].attributes.uuid]
17092:                 chain = str(k)
17092: 
17092:             # add entry
17092:             entry = "    {%s, %s, %s, %s, %s}" % (
17092:                 iid, properties, functions, parentInterface, chain)
17092:             entries[entryIndexes[iface.attributes.uuid]] = entry
17092: 
17092:     f.write("static const xpc_qsHashEntry tableData[] = {\n")
17092:     f.write(",\n".join(entries))
17092:     f.write("\n    };\n\n")
17092: 
17092:     # the definer function (entry point to this quick stubs file)
17092:     f.write("JSBool %s_DefineQuickStubs(" % conf.name)
17092:     f.write("JSContext *cx, JSObject *proto, uintN flags, PRUint32 count, "
17092:             "const nsID **iids)\n"
17092:             "{\n")
17092:     f.write("    return xpc_qsDefineQuickStubs("
17092:             "cx, proto, flags, count, iids, %d, tableData);\n" % size)
17092:     f.write("}\n\n\n")
17092: 
17092: 
17092: stubTopTemplate = '''\
17092: /* THIS FILE IS AUTOGENERATED - DO NOT EDIT */
17092: #include "jsapi.h"
21218: #include "jscntxt.h"
17092: #include "prtypes.h"
17092: #include "nsID.h"
17092: #include "%s"
17092: #include "nscore.h"
17092: #include "nsCOMPtr.h"
17092: #include "nsDependentString.h"
17092: #include "xpcprivate.h"  // for XPCCallContext
17092: #include "xpcquickstubs.h"
17092: 
17092: '''
17092: 
17092: def writeStubFile(filename, headerFilename, conf, interfaces):
17092:     print "Creating stub file", filename
17092:     make_targets.append(filename)
17092: 
17092:     f = open(filename, 'w')
17092:     filesIncluded = sets.Set()
17092: 
17092:     def includeType(type):
17092:         type = unaliasType(type)
17092:         if type.kind in ('builtin', 'native'):
22071:             return
17092:         file = conf.irregularFilenames.get(type.name, type.name) + '.h'
17092:         if file not in filesIncluded:
17092:             f.write('#include "%s"\n' % file)
17092:             filesIncluded.add(file)
17092: 
17092:     def writeIncludesForMember(member):
17092:         assert member.kind in ('attribute', 'method')
22071:         includeType(member.realtype)
17092:         if member.kind == 'method':
17092:             for p in member.params:
17092:                 includeType(p.realtype)
17092: 
17092:     def writeIncludesForInterface(iface):
17092:         assert iface.kind == 'interface'
17092:         for member in iface.stubMembers:
22071:             writeIncludesForMember(member)
17092:         includeType(iface)
17092: 
17092:     try:
17092:         f.write(stubTopTemplate % os.path.basename(headerFilename))
17092:         N = 256
17092:         for iface in interfaces:
22071:             writeIncludesForInterface(iface)
17092:         f.write("\n\n")
17092:         for iface in interfaces:
17092:             writeStubsForInterface(f, iface)
17092:         writeDefiner(f, conf, interfaces)
17092:     finally:
17092:         f.close()
17092: 
17092: def makeQuote(filename):
17092:     return filename.replace(' ', '\\ ')  # enjoy!
17092: 
17092: def writeMakeDependOutput(filename):
17092:     print "Creating makedepend file", filename
17092:     f = open(filename, 'w')
17092:     try:
17092:         if len(make_targets) > 0:
20748:             f.write("%s:" % makeQuote(make_targets[0]))
17092:             for filename in make_dependencies:
20748:                 f.write(' \\\n\t\t%s' % makeQuote(filename))
20748:             f.write('\n\n')
17092:             for filename in make_targets[1:]:
17092:                 f.write('%s: %s\n' % (makeQuote(filename), makeQuote(make_targets[0])))
17092:     finally:
17092:         f.close()
17092: 
17092: def main():
17092:     from optparse import OptionParser
17092:     o = OptionParser(usage="usage: %prog [options] configfile")
17092:     o.add_option('-o', "--stub-output",
17092:                  type='string', dest='stub_output', default=None,
17092:                  help="Quick stub C++ source output file", metavar="FILE")
17092:     o.add_option('--header-output', type='string', default=None,
17092:                  help="Quick stub header output file", metavar="FILE")
17092:     o.add_option('--makedepend-output', type='string', default=None,
17092:                  help="gnumake dependencies output file", metavar="FILE")
17092:     o.add_option('--idlpath', type='string', default='.',
17092:                  help="colon-separated directories to search for idl files",
17092:                  metavar="PATH")
17092:     o.add_option('--cachedir', dest='cachedir', default='',
17092:                  help="Directory in which to cache lex/parse tables.")
17092:     o.add_option("--verbose-errors", action='store_true', default=False,
17092:                  help="When an error happens, display the Python traceback.")
17092:     (options, filenames) = o.parse_args()
17092: 
17092:     if len(filenames) != 1:
17092:         o.error("Exactly one config filename is needed.")
17092:     filename = filenames[0]
17092: 
17092:     if options.stub_output is None:
17092:         if filename.endswith('.qsconf') or filename.endswith('.py'):
17092:             options.stub_output = filename.rsplit('.', 1)[0] + '.cpp'
17092:         else:
17092:             options.stub_output = filename + '.cpp'
17092:     if options.header_output is None:
17092:         options.header_output = re.sub(r'(\.c|\.cpp)?$', '.h',
17092:                                        options.stub_output)
17092: 
17092:     if options.cachedir != '':
17092:         sys.path.append(options.cachedir)
17092:         if not os.path.isdir(options.cachedir):
17092:             os.mkdir(options.cachedir)
17092: 
17092:     try:
17092:         includePath = options.idlpath.split(':')
17092:         conf, interfaces = readConfigFile(filename,
17092:                                           includePath=includePath,
17092:                                           cachedir=options.cachedir)
17092:         writeHeaderFile(options.header_output, conf.name)
17092:         writeStubFile(options.stub_output, options.header_output,
17092:                       conf, interfaces)
17092:         if options.makedepend_output is not None:
17092:             writeMakeDependOutput(options.makedepend_output)
17092:     except Exception, exc:
17092:         if options.verbose_errors:
17092:             raise
17092:         elif isinstance(exc, (UserError, xpidl.IDLError)):
17092:             warn(str(exc))
17092:         elif isinstance(exc, OSError):
17092:             warn("%s: %s" % (exc.__class__.__name__, exc))
17092:         else:
17092:             raise
17092:         sys.exit(1)
17092: 
17092: if __name__ == '__main__':
17092:     main()
