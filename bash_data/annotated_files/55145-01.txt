51713: /* -*-  Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2; -*- */
51713: /* ***** BEGIN LICENSE BLOCK *****
51713:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51713:  *
51713:  * The contents of this file are subject to the Mozilla Public License Version
51713:  * 1.1 (the "License"); you may not use this file except in compliance with
51713:  * the License. You may obtain a copy of the License at
51713:  * http://www.mozilla.org/MPL/
51713:  *
51713:  * Software distributed under the License is distributed on an "AS IS" basis,
51713:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51713:  * for the specific language governing rights and limitations under the
51713:  * License.
51713:  *
51713:  * The Original Code is Startup Cache.
51713:  *
51713:  * The Initial Developer of the Original Code is
51713:  * The Mozilla Foundation <http://www.mozilla.org/>.
51713:  * Portions created by the Initial Developer are Copyright (C) 2009
51713:  * the Initial Developer. All Rights Reserved.
51713:  *
51713:  * Contributor(s):
51713:  *  Benedict Hsieh <bhsieh@mozilla.com>
51713:  *
51713:  * Alternatively, the contents of this file may be used under the terms of
51713:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51713:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51713:  * in which case the provisions of the GPL or the LGPL are applicable instead
51713:  * of those above. If you wish to allow use of your version of this file only
51713:  * under the terms of either the GPL or the LGPL, and not to allow others to
51713:  * use your version of this file under the terms of the MPL, indicate your
51713:  * decision by deleting the provisions above and replace them with the notice
51713:  * and other provisions required by the GPL or the LGPL. If you do not delete
51713:  * the provisions above, a recipient may use your version of this file under
51713:  * the terms of any one of the MPL, the GPL or the LGPL.
51713:  *
51713:  * ***** END LICENSE BLOCK ***** */
51713: 
51713: #include "prio.h"
51713: #include "prtypes.h"
51713: #include "pldhash.h"
51713: #include "mozilla/scache/StartupCache.h"
51713: 
51713: #include "nsAutoPtr.h"
51713: #include "nsClassHashtable.h"
51713: #include "nsComponentManagerUtils.h"
51713: #include "nsDirectoryServiceUtils.h"
51713: #include "nsIClassInfo.h"
51713: #include "nsIFile.h"
51713: #include "nsILocalFile.h"
51713: #include "nsIObserver.h"
51713: #include "nsIObserverService.h"
51713: #include "nsIOutputStream.h"
51713: #include "nsIStartupCache.h"
51713: #include "nsIStorageStream.h"
51713: #include "nsIStreamBufferAccess.h"
51713: #include "nsIStringStream.h"
51713: #include "nsISupports.h"
51713: #include "nsITimer.h"
51713: #include "nsIZipWriter.h"
51713: #include "nsIZipReader.h"
51713: #include "nsWeakReference.h"
51713: #include "nsZipArchive.h"
51713: 
51713: #ifdef IS_BIG_ENDIAN
51713: #define SC_ENDIAN "big"
51713: #else
51713: #define SC_ENDIAN "little"
51713: #endif
51713: 
51713: #if PR_BYTES_PER_WORD == 4
51713: #define SC_WORDSIZE "4"
51713: #else
51713: #define SC_WORDSIZE "8"
51713: #endif
51713: 
51713: namespace mozilla {
51713: namespace scache {
51713: 
51713: static const char sStartupCacheName[] = "startupCache." SC_WORDSIZE "." SC_ENDIAN;
51713: static NS_DEFINE_CID(kZipReaderCID, NS_ZIPREADER_CID);
51713: 
51713: StartupCache*
51713: StartupCache::GetSingleton() 
51713: {
51713:   if (!gStartupCache)
51713:     StartupCache::InitSingleton();
51713: 
51713:   return StartupCache::gStartupCache;
51713: }
51713: 
51713: void
51713: StartupCache::DeleteSingleton()
51713: {
51713:   delete StartupCache::gStartupCache;
51713: }
51713: 
51713: nsresult
51713: StartupCache::InitSingleton() 
51713: {
51713:   nsresult rv;
51713:   StartupCache::gStartupCache = new StartupCache();
51713: 
51713:   rv = StartupCache::gStartupCache->Init();
51713:   if (NS_FAILED(rv)) {
51713:     delete StartupCache::gStartupCache;
55145:     StartupCache::gStartupCache = nsnull;
51713:   }
51713:   return rv;
51713: }
51713: 
51713: StartupCache* StartupCache::gStartupCache;
51713: PRBool StartupCache::gShutdownInitiated;
51713: 
51713: StartupCache::StartupCache() 
51713:   : mArchive(NULL), mStartupWriteInitiated(PR_FALSE) { }
51713: 
51713: StartupCache::~StartupCache() 
51713: {
55145:   if (mTimer) {
55145:     mTimer->Cancel();
55145:   }
55145: 
51713:   // Generally, the in-memory table should be empty here,
51713:   // but in special cases (like Talos Ts tests) we
51713:   // could shut down before we write.
51713:   // This mechanism will change when IO is moved off-thread
51713:   // (bug 586859) or when Talos first-run is changed to allow
51713:   // our timer to work (bug 591471).
51713:   WriteToDisk();
51713:   gStartupCache = nsnull;
51713: }
51713: 
51713: nsresult
51713: StartupCache::Init() 
51713: {
51713:   nsresult rv;
51713:   mTable.Init();
51713: #ifdef DEBUG
51713:   mWriteObjectMap.Init();
51713: #endif
51713: 
51713:   mZipW = do_CreateInstance("@mozilla.org/zipwriter;1", &rv);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   nsCOMPtr<nsIFile> file;
51713:   rv = NS_GetSpecialDirectory("ProfLDS",
51713:                               getter_AddRefs(file));
51713:   if (NS_FAILED(rv)) {
51713:     // return silently, this will fail in mochitests's xpcshell process.
51713:     return rv;
51713:   }
51713: 
51713:   rv = file->AppendNative(NS_LITERAL_CSTRING("startupCache"));
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713: 
51713:   // Try to create the directory if it's not there yet
51713:   rv = file->Create(nsIFile::DIRECTORY_TYPE, 0777);
51713:   if (NS_FAILED(rv) && rv != NS_ERROR_FILE_ALREADY_EXISTS)
51713:     return rv;
51713: 
51713:   rv = file->AppendNative(NS_LITERAL_CSTRING(sStartupCacheName));
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   
51713:   mFile = do_QueryInterface(file);
51713:   NS_ENSURE_TRUE(mFile, NS_ERROR_UNEXPECTED);
51713: 
51713:   mObserverService = do_GetService("@mozilla.org/observer-service;1");
51713:   
51713:   if (!mObserverService) {
51713:     NS_WARNING("Could not get observerService.");
51713:     return NS_ERROR_UNEXPECTED;
51713:   }
51713:   
51713:   mListener = new StartupCacheListener();  
51713:   rv = mObserverService->AddObserver(mListener, NS_XPCOM_SHUTDOWN_OBSERVER_ID,
51713:                                      PR_FALSE);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   
51713:   rv = LoadArchive();
51713:   
51713:   // Sometimes we don't have a cache yet, that's ok.
51713:   // If it's corrupted, just remove it and start over.
51713:   if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND) {
51713:     NS_WARNING("Failed to load startupcache file correctly, removing!");
51713:     InvalidateCache();
51713:   }
51713: 
51713:   mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   // Wait for 10 seconds, then write out the cache.
51713:   rv = mTimer->InitWithFuncCallback(StartupCache::WriteTimeout, this, 10000,
51713:                                     nsITimer::TYPE_ONE_SHOT);
51713: 
51713:   return rv;
51713: }
51713: 
51713: nsresult
51713: StartupCache::LoadArchive() 
51713: {
51713:   PRBool exists;
51713:   mArchive = NULL;
51713:   nsresult rv = mFile->Exists(&exists);
51713:   if (NS_FAILED(rv) || !exists)
51713:     return NS_ERROR_FILE_NOT_FOUND;
51713:   
51713:   mArchive = new nsZipArchive();
51713:   return mArchive->OpenArchive(mFile);
51713: }
51713: 
51713: // NOTE: this will not find a new entry until it has been written to disk!
51713: // Consumer should take ownership of the resulting buffer.
51713: nsresult
51713: StartupCache::GetBuffer(const char* id, char** outbuf, PRUint32* length) 
51713: {
51713:   char* data = NULL;
51713:   PRUint32 len;
51713: 
51713:   if (!mStartupWriteInitiated) {
51713:     CacheEntry* entry; 
51713:     nsDependentCString idStr(id);
51713:     mTable.Get(idStr, &entry);
51713:     if (entry) {
51713:       data = entry->data;
51713:       len = entry->size;
51713:     }
51713:   }
51713: 
51713:   if (!data && mArchive) {
51713:     nsZipItem* zipItem = mArchive->GetItem(id);
51713:     if (zipItem) {
52249:       const PRUint8* itemData = mArchive->GetData(zipItem);
51713:       if (!itemData || !mArchive->CheckCRC(zipItem, itemData)) {
51713:         NS_WARNING("StartupCache file corrupted!");
51713:         InvalidateCache();
51713:         return NS_ERROR_FILE_CORRUPTED;
51713:       }
51713: 
51713:       len = zipItem->Size();
51713:       data = (char*) itemData;
51713:     }
51713:   }
51713: 
51713:   if (data) {
51713:     *outbuf = new char[len];
51713:     memcpy(*outbuf, data, len);
51713:     *length = len;
51713:     return NS_OK;
51713:   }
51713: 
51713:   return NS_ERROR_NOT_AVAILABLE;
51713: }
51713: 
51713: // Makes a copy of the buffer, client retains ownership of inbuf.
51713: nsresult
51713: StartupCache::PutBuffer(const char* id, const char* inbuf, PRUint32 len) 
51713: {
51713:   nsresult rv;
51713: 
51713:   if (StartupCache::gShutdownInitiated) {
51713:     return NS_ERROR_NOT_AVAILABLE;
51713:   }
51713: 
51713:   nsAutoArrayPtr<char> data(new char[len]);
51713:   memcpy(data, inbuf, len);
51713: 
51713:   nsDependentCString idStr(id);
51713:   if (!mStartupWriteInitiated) {
51713:     // Cache it for now, we'll write all together later.
51713:     CacheEntry* entry; 
51713: 
51713: #ifdef DEBUG
51713:     mTable.Get(idStr, &entry);
51713:     NS_ASSERTION(entry == nsnull, "Existing entry in StartupCache.");
51713: 
51713:     if (mArchive) {
51713:       nsZipItem* zipItem = mArchive->GetItem(id);
51713:       NS_ASSERTION(zipItem == nsnull, "Existing entry in disk StartupCache.");
51713:     }
51713: #endif
51713: 
51713:     entry = new CacheEntry(data.forget(), len);
51713:     mTable.Put(idStr, entry);
51713:     return NS_OK;
51713:   }
51713:   
51713:   rv = mZipW->Open(mFile, PR_RDWR | PR_CREATE_FILE);
51713:   NS_ENSURE_SUCCESS(rv, rv);  
51713: 
51713:   // XXX We need to think about whether to write this out every time,
51713:   // or somehow detect a good time to write.  We need to finish writing
51713:   // before shutdown though, and writing also requires a reload of the
51713:   // reader's archive, which probably can't handle having the underlying
51713:   // file change underneath it. Potentially could reload on the next
51713:   // read request, if this is a problem. See Bug 586859.
51713: #ifdef DEBUG
51713:   PRBool hasEntry;
51713:   rv = mZipW->HasEntry(idStr, &hasEntry);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   NS_ASSERTION(hasEntry == PR_FALSE, "Existing entry in disk StartupCache.");
51713: #endif
51713: 
51713:   nsCOMPtr<nsIStringInputStream> stream
51713:     = do_CreateInstance("@mozilla.org/io/string-input-stream;1",
51713:                         &rv);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713: 
51713:   rv = stream->AdoptData(data, len);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   data.forget();
51713:   
51713:   rv = mZipW->AddEntryStream(idStr, 0, 0, stream, false);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713: 
51713:   // Close the archive so Windows doesn't choke.
51713:   mArchive = NULL;
51713:   rv = mZipW->Close();
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713: 
51713:   // our reader's view of the archive is outdated now, reload it.
51713:   return LoadArchive();
51713: }
51713: 
51713: struct CacheWriteHolder
51713: {
51713:   nsCOMPtr<nsIZipWriter> writer;
51713:   nsCOMPtr<nsIStringInputStream> stream;
51713: };
51713: 
51713: PLDHashOperator
51713: CacheCloseHelper(const nsACString& key, nsAutoPtr<CacheEntry>& data, 
51713:                  void* closure) 
51713: {
51713:   nsresult rv;
51713:  
51713:   CacheWriteHolder* holder = (CacheWriteHolder*) closure;  
51713:   nsIStringInputStream* stream = holder->stream;
51713:   nsIZipWriter* writer = holder->writer;
51713: 
51713:   stream->ShareData(data->data, data->size);
51713: 
51713: #ifdef DEBUG
51713:   PRBool hasEntry;
51713:   rv = writer->HasEntry(key, &hasEntry);
51713:   NS_ASSERTION(NS_SUCCEEDED(rv) && hasEntry == PR_FALSE, 
51713:                "Existing entry in disk StartupCache.");
51713: #endif
51713:   rv = writer->AddEntryStream(key, 0, 0, stream, false);
51713:   
51713:   if (NS_FAILED(rv)) {
51713:     NS_WARNING("cache entry deleted but not written to disk.");
51713:   }
51713:   return PL_DHASH_REMOVE;
51713: }
51713: 
51713: void
51713: StartupCache::WriteToDisk() 
51713: {
51713:   nsresult rv;
51713:   mStartupWriteInitiated = PR_TRUE;
51713: 
51713:   if (mTable.Count() == 0)
51713:     return;
51713: 
51713:   rv = mZipW->Open(mFile, PR_RDWR | PR_CREATE_FILE);
51713:   if (NS_FAILED(rv)) {
51713:     NS_WARNING("could not open zipfile for write");
51713:     return;
51713:   } 
51713: 
51713:   nsCOMPtr<nsIStringInputStream> stream 
51713:     = do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
51713:   if (NS_FAILED(rv)) {
51713:     NS_WARNING("Couldn't create string input stream.");
51713:     return;
51713:   }
51713: 
51713:   CacheWriteHolder holder;
51713:   holder.stream = stream;
51713:   holder.writer = mZipW;
51713: 
51713:   mTable.Enumerate(CacheCloseHelper, &holder);
51713: 
51713:   // Close the archive so Windows doesn't choke.
51713:   mArchive = NULL;
51713:   mZipW->Close();
51713:       
51713:   // our reader's view of the archive is outdated now, reload it.
51713:   LoadArchive();
51713:   
51713:   return;
51713: }
51713: 
51713: void
51713: StartupCache::InvalidateCache() 
51713: {
51713:   mTable.Clear();
51713:   mArchive = NULL;
51713: 
51713:   // This is usually closed, but it's possible to get into
51713:   // an inconsistent state.
51713:   mZipW->Close();
51713:   mFile->Remove(false);
51713:   LoadArchive();
51713: }
51713: 
51713: void
51713: StartupCache::WriteTimeout(nsITimer *aTimer, void *aClosure)
51713: {
51713:   StartupCache* sc = (StartupCache*) aClosure;
51713:   sc->WriteToDisk();
51713: }
51713: 
51713: // We don't want to refcount StartupCache, so we'll just
51713: // hold a ref to this and pass it to observerService instead.
51713: NS_IMPL_THREADSAFE_ISUPPORTS1(StartupCacheListener, nsIObserver)
51713: 
51713: nsresult
51713: StartupCacheListener::Observe(nsISupports *subject, const char* topic, const PRUnichar* data)
51713: {
51713:   nsresult rv = NS_OK;
51713:   if (strcmp(topic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
51713:     StartupCache::gShutdownInitiated = PR_TRUE;
51713:   }
51713:   return rv;
51713: } 
51713: 
51713: nsresult
51713: StartupCache::GetDebugObjectOutputStream(nsIObjectOutputStream* aStream,
51713:                                          nsIObjectOutputStream** aOutStream) 
51713: {
51713:   NS_ENSURE_ARG_POINTER(aStream);
51713: #ifdef DEBUG
51713:   StartupCacheDebugOutputStream* stream
51713:     = new StartupCacheDebugOutputStream(aStream, &mWriteObjectMap);
51713:   NS_ADDREF(*aOutStream = stream);
51713: #else
51713:   NS_ADDREF(*aOutStream = aStream);
51713: #endif
51713:   
51713:   return NS_OK;
51713: }
51713: 
51713: // StartupCacheDebugOutputStream implementation
51713: #ifdef DEBUG
51713: NS_IMPL_ISUPPORTS3(StartupCacheDebugOutputStream, nsIObjectOutputStream, 
51713:                    nsIBinaryOutputStream, nsIOutputStream)
51713: 
51713: PRBool
51713: StartupCacheDebugOutputStream::CheckReferences(nsISupports* aObject)
51713: {
51713:   nsresult rv;
51713:   
51713:   nsCOMPtr<nsIClassInfo> classInfo = do_QueryInterface(aObject);
51713:   if (!classInfo) {
51713:     NS_ERROR("aObject must implement nsIClassInfo");
51713:     return PR_FALSE;
51713:   }
51713:   
51713:   PRUint32 flags;
51713:   rv = classInfo->GetFlags(&flags);
51713:   NS_ENSURE_SUCCESS(rv, rv);
51713:   if (flags & nsIClassInfo::SINGLETON)
51713:     return PR_TRUE;
51713:   
51713:   nsISupportsHashKey* key = mObjectMap->GetEntry(aObject);
51713:   if (key) {
51713:     NS_ERROR("non-singleton aObject is referenced multiple times in this" 
51713:                   "serialization, we don't support that.");
51713:     return PR_FALSE;
51713:   }
51713: 
51713:   mObjectMap->PutEntry(aObject);
51713:   return PR_TRUE;
51713: }
51713: 
51713: // nsIObjectOutputStream implementation
51713: nsresult
51713: StartupCacheDebugOutputStream::WriteObject(nsISupports* aObject, PRBool aIsStrongRef)
51713: {
51713:   nsresult rv;
51713:   
51713:   nsCOMPtr<nsISupports> rootObject(do_QueryInterface(aObject));
51713:   
51713:   NS_ASSERTION(rootObject.get() == aObject,
51713:                "bad call to WriteObject -- call WriteCompoundObject!");
51713:   PRBool check = CheckReferences(aObject);
51713:   NS_ENSURE_TRUE(check, NS_ERROR_FAILURE);
51713:   return mBinaryStream->WriteObject(aObject, aIsStrongRef);
51713: }
51713: 
51713: nsresult
51713: StartupCacheDebugOutputStream::WriteSingleRefObject(nsISupports* aObject)
51713: {
51713:   nsresult rv;
51713:   nsCOMPtr<nsISupports> rootObject(do_QueryInterface(aObject));
51713:   
51713:   NS_ASSERTION(rootObject.get() == aObject,
51713:                "bad call to WriteSingleRefObject -- call WriteCompoundObject!");
51713:   PRBool check = CheckReferences(aObject);
51713:   NS_ENSURE_TRUE(check, NS_ERROR_FAILURE);
51713:   return mBinaryStream->WriteSingleRefObject(aObject);
51713: }
51713: 
51713: nsresult
51713: StartupCacheDebugOutputStream::WriteCompoundObject(nsISupports* aObject,
51713:                                                 const nsIID& aIID,
51713:                                                 PRBool aIsStrongRef)
51713: {
51713:   nsresult rv;
51713:   nsCOMPtr<nsISupports> rootObject(do_QueryInterface(aObject));
51713:   
51713:   nsCOMPtr<nsISupports> roundtrip;
51713:   rootObject->QueryInterface(aIID, getter_AddRefs(roundtrip));
51713:   NS_ASSERTION(roundtrip.get() == aObject,
51713:                "bad aggregation or multiple inheritance detected by call to "
51713:                "WriteCompoundObject!");
51713: 
51713:   PRBool check = CheckReferences(aObject);
51713:   NS_ENSURE_TRUE(check, NS_ERROR_FAILURE);
51713:   return mBinaryStream->WriteCompoundObject(aObject, aIID, aIsStrongRef);
51713: }
51713: 
51713: nsresult
51713: StartupCacheDebugOutputStream::WriteID(nsID const& aID) 
51713: {
51713:   return mBinaryStream->WriteID(aID);
51713: }
51713: 
51713: char*
51713: StartupCacheDebugOutputStream::GetBuffer(PRUint32 aLength, PRUint32 aAlignMask)
51713: {
51713:   return mBinaryStream->GetBuffer(aLength, aAlignMask);
51713: }
51713: 
51713: void
51713: StartupCacheDebugOutputStream::PutBuffer(char* aBuffer, PRUint32 aLength)
51713: {
51713:   mBinaryStream->PutBuffer(aBuffer, aLength);
51713: }
51713: #endif //DEBUG
51713: 
51713: StartupCacheWrapper* StartupCacheWrapper::gStartupCacheWrapper = nsnull;
51713: 
51713: NS_IMPL_THREADSAFE_ISUPPORTS1(StartupCacheWrapper, nsIStartupCache)
51713: 
51713: StartupCacheWrapper* StartupCacheWrapper::GetSingleton() 
51713: {
51713:   if (!gStartupCacheWrapper)
51713:     gStartupCacheWrapper = new StartupCacheWrapper();
51713: 
51713:   NS_ADDREF(gStartupCacheWrapper);
51713:   return gStartupCacheWrapper;
51713: }
51713: 
51713: nsresult 
51713: StartupCacheWrapper::GetBuffer(const char* id, char** outbuf, PRUint32* length) 
51713: {
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   return sc->GetBuffer(id, outbuf, length);
51713: }
51713: 
51713: nsresult
51713: StartupCacheWrapper::PutBuffer(const char* id, char* inbuf, PRUint32 length) 
51713: {
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   return sc->PutBuffer(id, inbuf, length);
51713: }
51713: 
51713: nsresult
51713: StartupCacheWrapper::InvalidateCache() 
51713: {
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   sc->InvalidateCache();
51713:   return NS_OK;
51713: }
51713: 
51713: nsresult 
51713: StartupCacheWrapper::GetDebugObjectOutputStream(nsIObjectOutputStream* stream,
51713:                                                 nsIObjectOutputStream** outStream) 
51713: {
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   return sc->GetDebugObjectOutputStream(stream, outStream);
51713: }
51713: 
51713: nsresult
51713: StartupCacheWrapper::StartupWriteComplete(PRBool *complete)
51713: {  
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   *complete = sc->mStartupWriteInitiated && sc->mTable.Count() == 0;
51713:   return NS_OK;
51713: }
51713: 
51713: nsresult
51713: StartupCacheWrapper::ResetStartupWriteTimer()
51713: {
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   sc->mStartupWriteInitiated = PR_FALSE;
51713:   sc->mTimer->InitWithFuncCallback(StartupCache::WriteTimeout, sc, 10000,
51713:                                    nsITimer::TYPE_ONE_SHOT);
51713:   return NS_OK;
51713: }
51713: 
51713: nsresult
51713: StartupCacheWrapper::GetObserver(nsIObserver** obv) {
51713:   StartupCache* sc = StartupCache::GetSingleton();
51713:   if (!sc) {
51713:     return NS_ERROR_NOT_INITIALIZED;
51713:   }
51713:   NS_ADDREF(*obv = sc->mListener);
51713:   return NS_OK;
51713: }
51713: 
51713: } // namespace scache
51713: } // namespace mozilla
