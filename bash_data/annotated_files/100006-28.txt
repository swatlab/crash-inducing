 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JavaScript iterators.
     1:  */
 80468: #include "mozilla/Util.h"
 80468: 
     1: #include "jstypes.h"
     1: #include "jsutil.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsexn.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
 42733: #include "jsproxy.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: 
     1: #if JS_HAS_XML_SUPPORT
     1: #include "jsxml.h"
     1: #endif
     1: 
 84344: #include "ds/Sort.h"
 80506: #include "frontend/TokenStream.h"
 97569: #include "gc/Marking.h"
 75062: #include "vm/GlobalObject.h"
 75062: 
 77343: #include "jsinferinlines.h"
 40858: #include "jsobjinlines.h"
 40858: 
 90523: #include "vm/MethodGuard-inl.h"
 69223: #include "vm/Stack-inl.h"
 72107: #include "vm/String-inl.h"
 69223: 
 80468: using namespace mozilla;
 37741: using namespace js;
 54707: using namespace js::gc;
 37741: 
 94738: static void iterator_finalize(FreeOp *fop, JSObject *obj);
 42641: static void iterator_trace(JSTracer *trc, JSObject *obj);
 98960: static JSObject *iterator_iterator(JSContext *cx, HandleObject obj, JSBool keysonly);
     1: 
 77817: Class js::IteratorClass = {
 48622:     "Iterator",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS |
 68896:     JSCLASS_HAS_CACHED_PROTO(JSProto_Iterator),
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     iterator_finalize,
 48622:     NULL,                    /* checkAccess */
 48622:     NULL,                    /* call        */
 48622:     NULL,                    /* construct   */
 48622:     NULL,                    /* hasInstance */
 64218:     iterator_trace,
 48622:     {
 48622:         NULL,                /* equality       */
 48622:         NULL,                /* outerObject    */
 48622:         NULL,                /* innerObject    */
 48622:         iterator_iterator,
 56565:         NULL                 /* unused  */
 48622:     }
 42641: };
  3436: 
 89622: Class js::ElementIteratorClass = {
 89622:     "ElementIterator",
 89622:     JSCLASS_HAS_RESERVED_SLOTS(ElementIteratorObject::NumSlots),
 89622:     JS_PropertyStub,         /* addProperty */
 89622:     JS_PropertyStub,         /* delProperty */
 89622:     JS_PropertyStub,         /* getProperty */
 89622:     JS_StrictPropertyStub,   /* setProperty */
 89622:     JS_EnumerateStub,
 89622:     JS_ResolveStub,
 89622:     JS_ConvertStub,
 89622:     NULL,                    /* finalize    */
 89622:     NULL,                    /* checkAccess */
 89622:     NULL,                    /* call        */
 89622:     NULL,                    /* construct   */
 89622:     NULL,                    /* hasInstance */
 89622:     NULL,                    /* trace       */
 89622:     {
 89622:         NULL,                /* equality       */
 89622:         NULL,                /* outerObject    */
 89622:         NULL,                /* innerObject    */
 89622:         iterator_iterator,
 89622:         NULL                 /* unused  */
 89622:     }
 89622: };
 89622: 
 83316: static const gc::AllocKind ITERATOR_FINALIZE_KIND = gc::FINALIZE_OBJECT2;
 83316: 
 42641: void
 42641: NativeIterator::mark(JSTracer *trc)
 42641: {
 87655:     for (HeapPtr<JSFlatString> *str = begin(); str < end(); str++)
 90409:         MarkString(trc, str, "prop");
 48470:     if (obj)
 90409:         MarkObject(trc, &obj, "obj");
 42641: }
  3436: 
 40857: static void
 94738: iterator_finalize(FreeOp *fop, JSObject *obj)
 40857: {
 77817:     JS_ASSERT(obj->isIterator());
 42641: 
 42641:     NativeIterator *ni = obj->getNativeIterator();
 42641:     if (ni) {
 82129:         obj->setPrivate(NULL);
 94738:         fop->free_(ni);
 42641:     }
 40857: }
 40857: 
 40857: static void
 33128: iterator_trace(JSTracer *trc, JSObject *obj)
 33128: {
 42641:     NativeIterator *ni = obj->getNativeIterator();
 42641: 
 42641:     if (ni)
 42641:         ni->mark(trc);
 33128: }
 33128: 
 48470: struct IdHashPolicy {
 48470:     typedef jsid Lookup;
 48470:     static HashNumber hash(jsid id) {
 48470:         return JSID_BITS(id);
 48470:     }
 48470:     static bool match(jsid id1, jsid id2) {
 48470:         return id1 == id2;
 48470:     }
 48470: };
 48470: 
 72091: typedef HashSet<jsid, IdHashPolicy> IdSet;
 48470: 
 48470: static inline bool
 48470: NewKeyValuePair(JSContext *cx, jsid id, const Value &val, Value *rval)
 42641: {
 48470:     Value vec[2] = { IdToValue(id), val };
 80468:     AutoArrayRooter tvr(cx, ArrayLength(vec), vec);
     1: 
 59234:     JSObject *aobj = NewDenseCopiedArray(cx, 2, vec);
 42641:     if (!aobj)
 42641:         return false;
 48470:     rval->setObject(*aobj);
 42641:     return true;
 42641: }
 42641: 
 42641: static inline bool
 42691: Enumerate(JSContext *cx, JSObject *obj, JSObject *pobj, jsid id,
 91237:           bool enumerable, unsigned flags, IdSet& ht, AutoIdVector *props)
     1: {
 72089:     JS_ASSERT_IF(flags & JSITER_OWNONLY, obj == pobj);
 72089: 
 79933:     /*
 79933:      * We implement __proto__ using a property on |Object.prototype|, but
 79933:      * because __proto__ is highly deserving of removal, we don't want it to
 79933:      * show up in property enumeration, even if only for |Object.prototype|
 79933:      * (think introspection by Prototype-like frameworks that add methods to
 79933:      * the built-in prototypes).  So exclude __proto__ if the object where the
 79933:      * property was found has no [[Prototype]] and might be |Object.prototype|.
 79933:      */
 79933:     if (JS_UNLIKELY(!pobj->getProto() && JSID_IS_ATOM(id, cx->runtime->atomState.protoAtom)))
 79933:         return true;
 79933: 
 72560:     if (!(flags & JSITER_OWNONLY) || pobj->isProxy() || pobj->getOps()->enumerate) {
 72560:         /* If we've already seen this, we definitely won't add it. */
 48470:         IdSet::AddPtr p = ht.lookupForAdd(id);
 42641:         if (JS_UNLIKELY(!!p))
 42641:             return true;
 47569: 
 47569:         /*
 72089:          * It's not necessary to add properties to the hash table at the end of
 72560:          * the prototype chain, but custom enumeration behaviors might return
 72560:          * duplicated properties, so always add in such cases.
 47569:          */
 72560:         if ((pobj->getProto() || pobj->isProxy() || pobj->getOps()->enumerate) && !ht.add(p, id))
 42641:             return false;
 42641:     }
 47569: 
 48470:     if (enumerable || (flags & JSITER_HIDDEN))
 61055:         return props->append(id);
 48470: 
 42641:     return true;
 42641: }
 42641: 
 42641: static bool
 99364: EnumerateNativeProperties(JSContext *cx, JSObject *obj_, JSObject *pobj_, unsigned flags, IdSet &ht,
 61055:                           AutoIdVector *props)
 42641: {
 99421:     RootedObject obj(cx, obj_), pobj(cx, pobj_);
 86437: 
 54562:     size_t initialLength = props->length();
 42641: 
 42641:     /* Collect all unique properties from this object's scope. */
 86437:     Shape::Range r = pobj->lastProperty()->all();
 99364:     Shape::Range::AutoRooter root(cx, &r);
 86437:     for (; !r.empty(); r.popFront()) {
 52503:         const Shape &shape = r.front();
 52503: 
 83221:         if (!JSID_IS_DEFAULT_XML_NAMESPACE(shape.propid()) &&
 83221:             !Enumerate(cx, obj, pobj, shape.propid(), shape.enumerable(), flags, ht, props))
 47569:         {
 42641:             return false;
 42641:         }
 42641:     }
 42641: 
 64335:     ::Reverse(props->begin() + initialLength, props->end());
 42641:     return true;
 42641: }
 42641: 
 42641: static bool
 91237: EnumerateDenseArrayProperties(JSContext *cx, JSObject *obj, JSObject *pobj, unsigned flags,
 61055:                               IdSet &ht, AutoIdVector *props)
 42641: {
 97828:     if (!Enumerate(cx, obj, pobj, NameToId(cx->runtime->atomState.lengthAtom), false,
 47569:                    flags, ht, props)) {
 47569:         return false;
 47569:     }
 42641: 
 48537:     if (pobj->getArrayLength() > 0) {
 77343:         size_t initlen = pobj->getDenseArrayInitializedLength();
 74457:         const Value *vp = pobj->getDenseArrayElements();
 77343:         for (size_t i = 0; i < initlen; ++i, ++vp) {
 48470:             if (!vp->isMagic(JS_ARRAY_HOLE)) {
 42641:                 /* Dense arrays never get so large that i would not fit into an integer id. */
 72089:                 if (!Enumerate(cx, obj, pobj, INT_TO_JSID(i), true, flags, ht, props))
 42641:                     return false;
 42641:             }
 42641:         }
 42641:     }
 47569: 
 42641:     return true;
 42641: }
 42641: 
 84344: #ifdef JS_MORE_DETERMINISTIC
 84344: 
 84344: struct SortComparatorIds
 84344: {
 84344:     JSContext   *const cx;
 84344: 
 84344:     SortComparatorIds(JSContext *cx)
 84344:       : cx(cx) {}
 84344: 
 84344:     bool operator()(jsid a, jsid b, bool *lessOrEqualp)
 84344:     {
 84344:         /* Pick an arbitrary total order on jsids that is stable across executions. */
 84344:         JSString *astr = IdToString(cx, a);
 84344: 	if (!astr)
 84344: 	    return false;
 84344:         JSString *bstr = IdToString(cx, b);
 84344:         if (!bstr)
 84344:             return false;
 84344: 
 84755:         int32_t result;
 84344:         if (!CompareStrings(cx, astr, bstr, &result))
 84344:             return false;
 84344: 
 84344:         *lessOrEqualp = (result <= 0);
 84344:         return true;
 84344:     }
 84344: };
 84344: 
 84344: #endif /* JS_MORE_DETERMINISTIC */
 84344: 
 47459: static bool
 99364: Snapshot(JSContext *cx, JSObject *obj_, unsigned flags, AutoIdVector *props)
 42641: {
 48470:     IdSet ht(cx);
 47569:     if (!ht.init(32))
 48470:         return NULL;
 42641: 
 99421:     RootedObject obj(cx, obj_), pobj(cx);
 86437:     pobj = obj;
 86437: 
 47459:     do {
 48470:         Class *clasp = pobj->getClass();
 42691:         if (pobj->isNative() &&
 48622:             !pobj->getOps()->enumerate &&
 42641:             !(clasp->flags & JSCLASS_NEW_ENUMERATE)) {
 42691:             if (!clasp->enumerate(cx, pobj))
 47459:                 return false;
 61055:             if (!EnumerateNativeProperties(cx, obj, pobj, flags, ht, props))
 47459:                 return false;
 42691:         } else if (pobj->isDenseArray()) {
 61055:             if (!EnumerateDenseArrayProperties(cx, obj, pobj, flags, ht, props))
 47459:                 return false;
 42641:         } else {
 42733:             if (pobj->isProxy()) {
 48470:                 AutoIdVector proxyProps(cx);
 42733:                 if (flags & JSITER_OWNONLY) {
 61423:                     if (flags & JSITER_HIDDEN) {
 79386:                         if (!Proxy::getOwnPropertyNames(cx, pobj, proxyProps))
 61423:                             return false;
 61423:                     } else {
 79386:                         if (!Proxy::keys(cx, pobj, proxyProps))
 47459:                             return false;
 61423:                     }
 42733:                 } else {
 79386:                     if (!Proxy::enumerate(cx, pobj, proxyProps))
 47459:                         return false;
 42733:                 }
 47460:                 for (size_t n = 0, len = proxyProps.length(); n < len; n++) {
 72089:                     if (!Enumerate(cx, obj, pobj, proxyProps[n], true, flags, ht, props))
 47459:                         return false;
 42733:                 }
 42733:                 /* Proxy objects enumerate the prototype on their own, so we are done here. */
 42733:                 break;
 42733:             }
 48470:             Value state;
 47569:             JSIterateOp op = (flags & JSITER_HIDDEN) ? JSENUMERATE_INIT_ALL : JSENUMERATE_INIT;
 47569:             if (!pobj->enumerate(cx, op, &state, NULL))
 47459:                 return false;
 48470:             if (state.isMagic(JS_NATIVE_ENUMERATE)) {
 61055:                 if (!EnumerateNativeProperties(cx, obj, pobj, flags, ht, props))
 47459:                     return false;
 42641:             } else {
 42641:                 while (true) {
 42641:                     jsid id;
 42691:                     if (!pobj->enumerate(cx, JSENUMERATE_NEXT, &state, &id))
 47459:                         return false;
 48470:                     if (state.isNull())
 42641:                         break;
 72089:                     if (!Enumerate(cx, obj, pobj, id, true, flags, ht, props))
 47459:                         return false;
 42641:                 }
 42641:             }
 42641:         }
     1: 
 98644:         if (flags & JSITER_OWNONLY)
 42641:             break;
 98644: 
 98644: #if JS_HAS_XML_SUPPORT
 98644:         if (pobj->isXML())
 98644:             break;
 98644: #endif
 47459:     } while ((pobj = pobj->getProto()) != NULL);
     1: 
 84344: #ifdef JS_MORE_DETERMINISTIC
 84344: 
 84344:     /*
 84344:      * In some cases the enumeration order for an object depends on the
 84344:      * execution mode (interpreter vs. JIT), especially for native objects
 84344:      * with a class enumerate hook (where resolving a property changes the
 84344:      * resulting enumeration order). These aren't really bugs, but the
 84344:      * differences can change the generated output and confuse correctness
 84344:      * fuzzers, so we sort the ids if such a fuzzer is running.
 84344:      *
 84344:      * We don't do this in the general case because (a) doing so is slow,
 84344:      * and (b) it also breaks the web, which expects enumeration order to
 84344:      * follow the order in which properties are added, in certain cases.
 84344:      * Since ECMA does not specify an enumeration order for objects, both
 84344:      * behaviors are technically correct to do.
 84344:      */
 84344: 
 84344:     jsid *ids = props->begin();
 84344:     size_t n = props->length();
 84344: 
 84344:     Vector<jsid> tmp(cx);
 84344:     if (!tmp.resizeUninitialized(n))
 84344:         return false;
 84344: 
 84344:     if (!MergeSort(ids, n, tmp.begin(), SortComparatorIds(cx)))
 84344:         return false;
 84344: 
 84344: #endif /* JS_MORE_DETERMINISTIC */
 84344: 
 47459:     return true;
 42641: }
 42641: 
 42641: bool
 79734: js::VectorToIdArray(JSContext *cx, AutoIdVector &props, JSIdArray **idap)
 42641: {
 47459:     JS_STATIC_ASSERT(sizeof(JSIdArray) > sizeof(jsid));
 47459:     size_t len = props.length();
 47459:     size_t idsz = len * sizeof(jsid);
 47459:     size_t sz = (sizeof(JSIdArray) - sizeof(jsid)) + idsz;
 64560:     JSIdArray *ida = static_cast<JSIdArray *>(cx->malloc_(sz));
 47459:     if (!ida)
 47459:         return false;
 47459: 
 91450:     ida->length = static_cast<int>(len);
 82129:     jsid *v = props.begin();
 91450:     for (int i = 0; i < ida->length; i++)
 82129:         ida->vector[i].init(v[i]);
 42641:     *idap = ida;
 42641:     return true;
 42641: }
 42641: 
 55632: JS_FRIEND_API(bool)
 91237: js::GetPropertyNames(JSContext *cx, JSObject *obj, unsigned flags, AutoIdVector *props)
 42733: {
 61055:     return Snapshot(cx, obj, flags & (JSITER_OWNONLY | JSITER_HIDDEN), props);
 42733: }
 42733: 
 74914: size_t sCustomIteratorCount = 0;
 74914: 
 42641: static inline bool
 95355: GetCustomIterator(JSContext *cx, HandleObject obj, unsigned flags, Value *vp)
 42641: {
 82893:     JS_CHECK_RECURSION(cx, return false);
 82893: 
 89621:     /*
 89621:      * for-of iteration does not fall back on __iterator__ or property
 89621:      * enumeration. This is more conservative than the current proposed spec.
 89621:      */
 89621:     if (flags == JSITER_FOR_OF) {
 89621:         js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_NOT_ITERABLE,
 89621:                                  JSDVG_SEARCH_STACK, ObjectValue(*obj), NULL, NULL, NULL);
 89621:         return false;
 89621:     }
 89621: 
 42641:     /* Check whether we have a valid __iterator__ method. */
 97828:     PropertyName *name = cx->runtime->atomState.iteratorAtom;
 98960:     if (!GetMethod(cx, obj, name, 0, vp))
 42641:         return false;
 42641: 
 42641:     /* If there is no custom __iterator__ method, we are done here. */
 60775:     if (!vp->isObject()) {
 60775:         vp->setUndefined();
 42641:         return true;
 60775:     }
 42641: 
 74914:     if (!cx->runningWithTrustedPrincipals())
 74914:         ++sCustomIteratorCount;
 74914: 
 42641:     /* Otherwise call it and return that object. */
 48470:     Value arg = BooleanValue((flags & JSITER_FOREACH) == 0);
 76829:     if (!Invoke(cx, ObjectValue(*obj), *vp, 1, &arg, vp))
 42641:         return false;
 48470:     if (vp->isPrimitive()) {
 43211:         /*
 91364:          * We are always coming from js::ValueToIterator, and we are no longer on
 43211:          * trace, so the object we are iterating over is on top of the stack (-1).
 43211:          */
 57812:         JSAutoByteString bytes;
 97828:         if (!js_AtomToPrintableString(cx, name, &bytes))
 57812:             return false;
 43211:         js_ReportValueError2(cx, JSMSG_BAD_TRAP_RETURN_VALUE,
 57812:                              -1, ObjectValue(*obj), NULL, bytes.ptr());
 42641:         return false;
 42641:     }
 42641:     return true;
 42641: }
 42641: 
 42641: template <typename T>
 42641: static inline bool
 42641: Compare(T *a, T *b, size_t c)
 42641: {
 42641:     size_t n = (c + size_t(7)) / size_t(8);
 42641:     switch (c % 8) {
 42641:       case 0: do { if (*a++ != *b++) return false;
 42641:       case 7:      if (*a++ != *b++) return false;
 42641:       case 6:      if (*a++ != *b++) return false;
 42641:       case 5:      if (*a++ != *b++) return false;
 42641:       case 4:      if (*a++ != *b++) return false;
 42641:       case 3:      if (*a++ != *b++) return false;
 42641:       case 2:      if (*a++ != *b++) return false;
 42641:       case 1:      if (*a++ != *b++) return false;
 42641:               } while (--n > 0);
 42641:     }
 42641:     return true;
 42641: }
 42641: 
 47497: static inline JSObject *
 91237: NewIteratorObject(JSContext *cx, unsigned flags)
 43190: {
 47497:     if (flags & JSITER_ENUMERATE) {
 99421:         RootedTypeObject type(cx);
 86437:         type = cx->compartment->getEmptyType(cx);
 83230:         if (!type)
 83230:             return NULL;
 83230: 
 99421:         RootedShape emptyEnumeratorShape(cx);
 86437:         emptyEnumeratorShape = EmptyShape::getInitialShape(cx, &IteratorClass, NULL, NULL,
 83316:                                                            ITERATOR_FINALIZE_KIND);
 80622:         if (!emptyEnumeratorShape)
 80622:             return NULL;
 83230: 
 83316:         JSObject *obj = JSObject::create(cx, ITERATOR_FINALIZE_KIND,
 83316:                                          emptyEnumeratorShape, type, NULL);
 47497:         if (!obj)
 68902:             return NULL;
 64242: 
 83233:         JS_ASSERT(obj->numFixedSlots() == JSObject::ITER_CLASS_NFIXED_SLOTS);
 47497:         return obj;
 47497:     }
 47497: 
 77817:     return NewBuiltinClassInstance(cx, &IteratorClass);
 43190: }
 43190: 
 48470: NativeIterator *
 84755: NativeIterator::allocateIterator(JSContext *cx, uint32_t slength, const AutoIdVector &props)
 48470: {
 48470:     size_t plength = props.length();
 48470:     NativeIterator *ni = (NativeIterator *)
 87655:         cx->malloc_(sizeof(NativeIterator)
 87655:                     + plength * sizeof(JSString *)
 87655:                     + slength * sizeof(Shape *));
 48470:     if (!ni)
 48470:         return NULL;
 87872:     AutoValueVector strings(cx);
 87655:     ni->props_array = ni->props_cursor = (HeapPtr<JSFlatString> *) (ni + 1);
 82129:     ni->props_end = ni->props_array + plength;
 82129:     if (plength) {
 87655:         for (size_t i = 0; i < plength; i++) {
 87655:             JSFlatString *str = IdToString(cx, props[i]);
 87872:             if (!str || !strings.append(StringValue(str)))
 87655:                 return NULL;
 87655:             ni->props_array[i].init(str);
 87655:         }
 82129:     }
 48470:     return ni;
 48470: }
 48470: 
 48470: inline void
 91237: NativeIterator::init(JSObject *obj, unsigned flags, uint32_t slength, uint32_t key)
 48470: {
 82129:     this->obj.init(obj);
 48470:     this->flags = flags;
 83221:     this->shapes_array = (const Shape **) this->props_end;
 48470:     this->shapes_length = slength;
 48470:     this->shapes_key = key;
 48470: }
 48470: 
 43281: static inline void
 43281: RegisterEnumerator(JSContext *cx, JSObject *iterobj, NativeIterator *ni)
 43281: {
 43281:     /* Register non-escaping native enumerators (for-in) with the current context. */
 43281:     if (ni->flags & JSITER_ENUMERATE) {
 43281:         ni->next = cx->enumerators;
 43281:         cx->enumerators = iterobj;
 53519: 
 53519:         JS_ASSERT(!(ni->flags & JSITER_ACTIVE));
 62413:         ni->flags |= JSITER_ACTIVE;
 43281:     }
 43281: }
 43281: 
 48470: static inline bool
 95355: VectorToKeyIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &keys,
 84755:                     uint32_t slength, uint32_t key, Value *vp)
 43190: {
 48470:     JS_ASSERT(!(flags & JSITER_FOREACH));
 48470: 
 77361:     if (obj) {
 83248:         if (obj->hasSingletonType() && !obj->setIteratedSingleton(cx))
 83248:             return false;
 77353:         types::MarkTypeObjectFlags(cx, obj, types::OBJECT_FLAG_ITERATED);
 77361:     }
 77343: 
 99421:     RootedObject iterobj(cx, NewIteratorObject(cx, flags));
 43190:     if (!iterobj)
 43190:         return false;
 43190: 
 61055:     NativeIterator *ni = NativeIterator::allocateIterator(cx, slength, keys);
 43190:     if (!ni)
 53404:         return false;
 53404:     ni->init(obj, flags, slength, key);
 53404: 
 53404:     if (slength) {
 53404:         /*
 53404:          * Fill in the shape array from scratch.  We can't use the array that was
 53404:          * computed for the cache lookup earlier, as constructing iterobj could
 53404:          * have triggered a shape-regenerating GC.  Don't bother with regenerating
 53404:          * the shape key; if such a GC *does* occur, we can only get hits through
 53404:          * the one-slot lastNativeIterator cache.
 53404:          */
 53404:         JSObject *pobj = obj;
 53404:         size_t ind = 0;
 53404:         do {
 83221:             ni->shapes_array[ind++] = pobj->lastProperty();
 53404:             pobj = pobj->getProto();
 53404:         } while (pobj);
 53404:         JS_ASSERT(ind == slength);
 53404:     }
 47525: 
 43190:     iterobj->setNativeIterator(ni);
 48470:     vp->setObject(*iterobj);
 43281: 
 43281:     RegisterEnumerator(cx, iterobj, ni);
 43190:     return true;
 43190: }
 43190: 
 55632: namespace js {
 55632: 
 43190: bool
 95355: VectorToKeyIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp)
 48470: {
 53404:     return VectorToKeyIterator(cx, obj, flags, props, 0, 0, vp);
 48470: }
 48470: 
 53404: bool
 95355: VectorToValueIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &keys,
 53404:                       Value *vp)
 48470: {
 48470:     JS_ASSERT(flags & JSITER_FOREACH);
 48470: 
 77361:     if (obj) {
 83248:         if (obj->hasSingletonType() && !obj->setIteratedSingleton(cx))
 83248:             return false;
 77353:         types::MarkTypeObjectFlags(cx, obj, types::OBJECT_FLAG_ITERATED);
 77361:     }
 77343: 
 48470:     JSObject *iterobj = NewIteratorObject(cx, flags);
 48470:     if (!iterobj)
 48470:         return false;
 48470: 
 61055:     NativeIterator *ni = NativeIterator::allocateIterator(cx, 0, keys);
 48470:     if (!ni)
 53404:         return false;
 53404:     ni->init(obj, flags, 0, 0);
 48470: 
 48470:     iterobj->setNativeIterator(ni);
 48470:     vp->setObject(*iterobj);
 48470: 
 48470:     RegisterEnumerator(cx, iterobj, ni);
 48470:     return true;
 48470: }
 48470: 
 48470: bool
 95355: EnumeratedIdVectorToIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp)
 48470: {
 48470:     if (!(flags & JSITER_FOREACH))
 48470:         return VectorToKeyIterator(cx, obj, flags, props, vp);
 48470: 
 61055:     return VectorToValueIterator(cx, obj, flags, props, vp);
 48470: }
 48470: 
 59250: static inline void
 59250: UpdateNativeIterator(NativeIterator *ni, JSObject *obj)
 59250: {
 59250:     // Update the object for which the native iterator is associated, so
 59250:     // SuppressDeletedPropertyHelper will recognize the iterator as a match.
 59250:     ni->obj = obj;
 59250: }
 59250: 
 48470: bool
 95355: GetIterator(JSContext *cx, HandleObject obj, unsigned flags, Value *vp)
 42641: {
 83221:     Vector<const Shape *, 8> shapes(cx);
 84755:     uint32_t key = 0;
 42641: 
 42641:     bool keysOnly = (flags == JSITER_ENUMERATE);
 42641: 
 42641:     if (obj) {
 56574:         /* Enumerate Iterator.prototype directly. */
 80307:         if (JSIteratorOp op = obj->getClass()->ext.iteratorObject) {
 89621:             /*
 89621:              * Arrays and other classes representing iterable collections have
 89621:              * the JSCLASS_FOR_OF_ITERATION flag. This flag means that the
 89621:              * object responds to all other kinds of enumeration (for-in,
 89621:              * for-each, Object.keys, Object.getOwnPropertyNames, etc.) in the
 89621:              * default way, ignoring the hook. The hook is used only when
 89621:              * iterating in the style of a for-of loop.
 89621:              */
 89621:             if (!(obj->getClass()->flags & JSCLASS_FOR_OF_ITERATION) || flags == JSITER_FOR_OF) {
 89621:                 JSObject *iterobj = op(cx, obj, !(flags & (JSITER_FOREACH | JSITER_FOR_OF)));
 56574:                 if (!iterobj)
 56574:                     return false;
 56574:                 vp->setObject(*iterobj);
 77399:                 types::MarkIteratorUnknown(cx);
 56574:                 return true;
 56574:             }
 89621:         }
 56574: 
 42641:         if (keysOnly) {
     1:             /*
 53404:              * Check to see if this is the same as the most recent object which
 53404:              * was iterated over.  We don't explicitly check for shapeless
 53404:              * objects here, as they are not inserted into the cache and
 53404:              * will result in a miss.
 53404:              */
 97466:             JSObject *last = cx->runtime->nativeIterCache.last;
 53404:             JSObject *proto = obj->getProto();
 53404:             if (last) {
 53404:                 NativeIterator *lastni = last->getNativeIterator();
 62573:                 if (!(lastni->flags & (JSITER_ACTIVE|JSITER_UNREUSABLE)) &&
 53531:                     obj->isNative() &&
 83221:                     obj->lastProperty() == lastni->shapes_array[0] &&
 53531:                     proto && proto->isNative() &&
 83221:                     proto->lastProperty() == lastni->shapes_array[1] &&
 53404:                     !proto->getProto()) {
 53404:                     vp->setObject(*last);
 59250:                     UpdateNativeIterator(lastni, obj);
 53404:                     RegisterEnumerator(cx, last, lastni);
 53404:                     return true;
 53404:                 }
 53404:             }
 53404: 
 53404:             /*
 42641:              * The iterator object for JSITER_ENUMERATE never escapes, so we
 42641:              * don't care for the proper parent/proto to be set. This also
 53404:              * allows us to re-use a previous iterator object that is not
 53404:              * currently active.
     1:              */
 42641:             JSObject *pobj = obj;
 42641:             do {
 42641:                 if (!pobj->isNative() ||
 83332:                     pobj->hasUncacheableProto() ||
 48622:                     obj->getOps()->enumerate ||
 42641:                     pobj->getClass()->enumerate != JS_EnumerateStub) {
 42641:                     shapes.clear();
 42641:                     goto miss;
     1:                 }
 83221:                 const Shape *shape = pobj->lastProperty();
 86976:                 key = (key + (key << 16)) ^ (uintptr_t(shape) >> 3);
 83221:                 if (!shapes.append((Shape *) shape))
 42641:                     return false;
 42641:                 pobj = pobj->getProto();
 42641:             } while (pobj);
 42641: 
 97466:             JSObject *iterobj = cx->runtime->nativeIterCache.get(key);
 42641:             if (iterobj) {
 43190:                 NativeIterator *ni = iterobj->getNativeIterator();
 62573:                 if (!(ni->flags & (JSITER_ACTIVE|JSITER_UNREUSABLE)) &&
 53404:                     ni->shapes_key == key &&
 42641:                     ni->shapes_length == shapes.length() &&
 42641:                     Compare(ni->shapes_array, shapes.begin(), ni->shapes_length)) {
 48470:                     vp->setObject(*iterobj);
 43281: 
 59250:                     UpdateNativeIterator(ni, obj);
 43281:                     RegisterEnumerator(cx, iterobj, ni);
 53404:                     if (shapes.length() == 2)
 97466:                         cx->runtime->nativeIterCache.last = iterobj;
 42641:                     return true;
 42641:                 }
 42641:             }
 42641:         }
 42641: 
 42641:       miss:
 77399:         if (obj->isProxy()) {
 77399:             types::MarkIteratorUnknown(cx);
 79386:             return Proxy::iterate(cx, obj, flags, vp);
 77399:         }
 42641:         if (!GetCustomIterator(cx, obj, flags, vp))
 42641:             return false;
 77399:         if (!vp->isUndefined()) {
 77399:             types::MarkIteratorUnknown(cx);
 42641:             return true;
 42641:         }
 77399:     }
 42641: 
 48470:     /* NB: for (var p in null) succeeds by iterating over no properties. */
 48470: 
 61055:     AutoIdVector keys(cx);
 48470:     if (flags & JSITER_FOREACH) {
 61055:         if (JS_LIKELY(obj != NULL) && !Snapshot(cx, obj, flags, &keys))
 42641:             return false;
 53404:         JS_ASSERT(shapes.empty());
 61055:         if (!VectorToValueIterator(cx, obj, flags, keys, vp))
 53404:             return false;
 53404:     } else {
 61055:         if (JS_LIKELY(obj != NULL) && !Snapshot(cx, obj, flags, &keys))
 47459:             return false;
 53404:         if (!VectorToKeyIterator(cx, obj, flags, keys, shapes.length(), key, vp))
 53404:             return false;
 53404:     }
 53404: 
 53404:     JSObject *iterobj = &vp->toObject();
 53404: 
 53404:     /* Cache the iterator object if possible. */
 59954:     if (shapes.length())
 97466:         cx->runtime->nativeIterCache.set(key, iterobj);
 53404: 
 53404:     if (shapes.length() == 2)
 97466:         cx->runtime->nativeIterCache.last = iterobj;
 53404:     return true;
 42641: }
 42641: 
 55632: }
 55632: 
 42641: static JSObject *
 98960: iterator_iterator(JSContext *cx, HandleObject obj, JSBool keysonly)
 42641: {
 42641:     return obj;
     1: }
     1: 
     1: static JSBool
 91237: Iterator(JSContext *cx, unsigned argc, Value *vp)
     1: {
 99943:     CallArgs args = CallArgsFromVp(argc, vp);
 99943:     if (args.length() == 0) {
 99943:         js_ReportMissingArg(cx, args.calleev(), 0);
 99943:         return false;
 99943:     }
 99943: 
 99943:     bool keyonly = false;
 99943:     if (args.length() >= 2)
 99943:         keyonly = js_ValueToBoolean(args[1]);
 91237:     unsigned flags = JSITER_OWNONLY | (keyonly ? 0 : (JSITER_FOREACH | JSITER_KEYVALUE));
 99943: 
 99943:     if (!ValueToIterator(cx, flags, &args[0]))
 99943:         return false;
 99943:     args.rval() = args[0];
 99943:     return true;
     1: }
     1: 
  6464: JSBool
  6464: js_ThrowStopIteration(JSContext *cx)
     1: {
 48470:     Value v;
     1: 
     1:     JS_ASSERT(!JS_IsExceptionPending(cx));
 38604:     if (js_FindClassObject(cx, NULL, JSProto_StopIteration, &v))
 60211:         cx->setPendingException(v);
     1:     return JS_FALSE;
     1: }
     1: 
     1: static JSBool
 91237: iterator_next(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79387:     CallArgs args = CallArgsFromVp(argc, vp);
 79389: 
 79389:     bool ok;
 99421:     RootedObject obj(cx, NonGenericMethodGuard(cx, args, iterator_next, &IteratorClass, &ok));
 67943:     if (!obj)
 79389:         return ok;
     1: 
 79387:     if (!js_IteratorMore(cx, obj, &args.rval()))
 42641:         return false;
 79389: 
 79387:     if (!args.rval().toBoolean()) {
  6464:         js_ThrowStopIteration(cx);
 42641:         return false;
     1:     }
 79389: 
 79387:     return js_IteratorNext(cx, obj, &args.rval());
     1: }
     1: 
  4127: #define JSPROP_ROPERM   (JSPROP_READONLY | JSPROP_PERMANENT)
  4127: 
     1: static JSFunctionSpec iterator_methods[] = {
 16519:     JS_FN(js_next_str,      iterator_next,  0,JSPROP_ROPERM),
  4127:     JS_FS_END
     1: };
     1: 
 91160: #if JS_HAS_GENERATORS
 91160: static JSBool
 91160: CloseGenerator(JSContext *cx, JSObject *genobj);
 91160: #endif
 91160: 
     1: /*
     1:  * Call ToObject(v).__iterator__(keyonly) if ToObject(v).__iterator__ exists.
 11835:  * Otherwise construct the default iterator.
     1:  */
 91160: JSBool
 91947: js::ValueToIterator(JSContext *cx, unsigned flags, Value *vp)
     1: {
     1:     /* JSITER_KEYVALUE must always come with JSITER_FOREACH */
 42641:     JS_ASSERT_IF(flags & JSITER_KEYVALUE, flags & JSITER_FOREACH);
 42641: 
 42641:     /*
 42641:      * Make sure the more/next state machine doesn't get stuck. A value might be
 42641:      * left in iterValue when a trace is left due to an operation time-out after
 42641:      * JSOP_MOREITER but before the value is picked up by FOR*.
 42641:      */
 48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
     1: 
 99421:     RootedObject obj(cx);
 48470:     if (vp->isObject()) {
 40867:         /* Common case. */
 48470:         obj = &vp->toObject();
     1:     } else {
     1:         /*
     1:          * Enumerating over null and undefined gives an empty enumerator.
     1:          * This is contrary to ECMA-262 9.9 ToObject, invoked from step 3 of
     1:          * the first production in 12.6.4 and step 4 of the second production,
 40867:          * but it's "web JS" compatible. ES5 fixed for-in to match this de-facto
 40867:          * standard.
     1:          */
     1:         if ((flags & JSITER_ENUMERATE)) {
 95355:             if (!js_ValueToObjectOrNull(cx, *vp, obj.address()))
 40395:                 return false;
 56574:             /* fall through */
     1:         } else {
     1:             obj = js_ValueToNonNullObject(cx, *vp);
     1:             if (!obj)
 40395:                 return false;
     1:         }
     1:     }
     1: 
 42641:     return GetIterator(cx, obj, flags, vp);
  5899: }
     1: 
 91160: bool
 91947: js::CloseIterator(JSContext *cx, JSObject *obj)
  3025: {
 48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
  3025: 
 77817:     if (obj->isIterator()) {
 43281:         /* Remove enumerators from the active list, which is a stack. */
 43281:         NativeIterator *ni = obj->getNativeIterator();
 53404: 
 62413:         if (ni->flags & JSITER_ENUMERATE) {
 43281:             JS_ASSERT(cx->enumerators == obj);
 43281:             cx->enumerators = ni->next;
 43281: 
 53404:             JS_ASSERT(ni->flags & JSITER_ACTIVE);
 53404:             ni->flags &= ~JSITER_ACTIVE;
 53404: 
 53519:             /*
 53519:              * Reset the enumerator; it may still be in the cached iterators
 53519:              * for this thread, and can be reused.
 53519:              */
 42641:             ni->props_cursor = ni->props_array;
 42641:         }
  3025:     }
  3025: #if JS_HAS_GENERATORS
 77817:     else if (obj->isGenerator()) {
 42641:         return CloseGenerator(cx, obj);
  3025:     }
  3025: #endif
  3025:     return JS_TRUE;
  3025: }
  3025: 
 91160: bool
 91947: js::UnwindIteratorForException(JSContext *cx, JSObject *obj)
 91160: {
 99421:     RootedValue v(cx, cx->getPendingException());
 91160:     cx->clearPendingException();
 91160:     if (!CloseIterator(cx, obj))
 91160:         return false;
 91160:     cx->setPendingException(v);
 91160:     return true;
 91160: }
 91160: 
 91947: void
 91947: js::UnwindIteratorForUncatchableException(JSContext *cx, JSObject *obj)
 91947: {
 91947:     if (obj->isIterator()) {
 91947:         NativeIterator *ni = obj->getNativeIterator();
 91947:         if (ni->flags & JSITER_ENUMERATE) {
 91947:             JS_ASSERT(cx->enumerators == obj);
 91947:             cx->enumerators = ni->next;
 91947:         }
 91947:     }
 91947: }
 91160: 
 43281: /*
 55519:  * Suppress enumeration of deleted properties. This function must be called
 55519:  * when a property is deleted and there might be active enumerators.
 55519:  *
 55519:  * We maintain a list of active non-escaping for-in enumerators. To suppress
 55519:  * a property, we check whether each active enumerator contains the (obj, id)
 55519:  * pair and has not yet enumerated |id|. If so, and |id| is the next property,
 55519:  * we simply advance the cursor. Otherwise, we delete |id| from the list.
 43281:  *
 43281:  * We do not suppress enumeration of a property deleted along an object's
 43281:  * prototype chain. Only direct deletions on the object are handled.
 55519:  *
 55519:  * This function can suppress multiple properties at once. The |predicate|
 55519:  * argument is an object which can be called on an id and returns true or
 55519:  * false. It also must have a method |matchesAtMostOne| which allows us to
 55519:  * stop searching after the first deletion if true.
 43281:  */
 87655: template<typename StringPredicate>
 55519: static bool
 97353: SuppressDeletedPropertyHelper(JSContext *cx, HandleObject obj, StringPredicate predicate)
 43281: {
 43281:     JSObject *iterobj = cx->enumerators;
 43281:     while (iterobj) {
 47383:       again:
 43281:         NativeIterator *ni = iterobj->getNativeIterator();
 48470:         /* This only works for identified surpressed keys, not values. */
 48470:         if (ni->isKeyIter() && ni->obj == obj && ni->props_cursor < ni->props_end) {
 43281:             /* Check whether id is still to come. */
 87655:             HeapPtr<JSFlatString> *props_cursor = ni->current();
 87655:             HeapPtr<JSFlatString> *props_end = ni->end();
 87655:             for (HeapPtr<JSFlatString> *idp = props_cursor; idp < props_end; ++idp) {
 55519:                 if (predicate(*idp)) {
 43281:                     /*
 43281:                      * Check whether another property along the prototype chain
 43281:                      * became visible as a result of this deletion.
 43281:                      */
 43281:                     if (obj->getProto()) {
 86437:                         JSObject *proto = obj->getProto();
 86437:                         JSObject *obj2;
 43281:                         JSProperty *prop;
 99421:                         RootedId id(cx);
 98960:                         if (!ValueToId(cx, StringValue(*idp), id.address()))
 87655:                             return false;
 87655:                         if (!proto->lookupGeneric(cx, id, &obj2, &prop))
 43281:                             return false;
 43290:                         if (prop) {
 91237:                             unsigned attrs;
 86437:                             if (obj2->isNative())
 52503:                                 attrs = ((Shape *) prop)->attributes();
 87655:                             else if (!obj2->getGenericAttributes(cx, id, &attrs))
 43281:                                 return false;
 56567: 
 43281:                             if (attrs & JSPROP_ENUMERATE)
 43281:                                 continue;
 43281:                         }
 43281:                     }
 43281: 
 43281:                     /*
 47383:                      * If lookupProperty or getAttributes above removed a property from
 47383:                      * ni, start over.
 47383:                      */
 47383:                     if (props_end != ni->props_end || props_cursor != ni->props_cursor)
 47383:                         goto again;
 47383: 
 47383:                     /*
 55519:                      * No property along the prototype chain stepped in to take the
 43281:                      * property's place, so go ahead and delete id from the list.
 43281:                      * If it is the next property to be enumerated, just skip it.
 43281:                      */
 47383:                     if (idp == props_cursor) {
 61055:                         ni->incCursor();
 43281:                     } else {
 87655:                         for (HeapPtr<JSFlatString> *p = idp; p + 1 != props_end; p++)
 82129:                             *p = *(p + 1);
 61055:                         ni->props_end = ni->end() - 1;
 89967: 
 89967:                         /*
 95221:                          * This invokes the pre barrier on this element, since
 95221:                          * it's no longer going to be marked, and ensures that
 95221:                          * any existing remembered set entry will be dropped.
 89967:                          */
 95221:                         *ni->props_end = NULL;
 43281:                     }
 62573: 
 62573:                     /* Don't reuse modified native iterators. */
 62573:                     ni->flags |= JSITER_UNREUSABLE;
 62573: 
 55519:                     if (predicate.matchesAtMostOne())
 43281:                         break;
 43281:                 }
 43281:             }
 43281:         }
 43281:         iterobj = ni->next;
 43281:     }
 43281:     return true;
 43281: }
 43281: 
 87655: class SingleStringPredicate {
 97353:     Handle<JSFlatString*> str;
 55519: public:
 97353:     SingleStringPredicate(JSContext *cx, Handle<JSFlatString*> str) : str(str) {}
 55519: 
 87655:     bool operator()(JSFlatString *str) { return EqualStrings(str, this->str); }
 55519:     bool matchesAtMostOne() { return true; }
 55519: };
 55519: 
 55519: bool
 97353: js_SuppressDeletedProperty(JSContext *cx, HandleObject obj, jsid id)
 55519: {
 99421:     Rooted<JSFlatString*> str(cx, IdToString(cx, id));
 87655:     if (!str)
 87655:         return false;
 97353:     return SuppressDeletedPropertyHelper(cx, obj, SingleStringPredicate(cx, str));
 55519: }
 55519: 
 78344: bool
 97353: js_SuppressDeletedElement(JSContext *cx, HandleObject obj, uint32_t index)
 78344: {
 78344:     jsid id;
 78344:     if (!IndexToId(cx, index, &id))
 78344:         return false;
 87655:     return js_SuppressDeletedProperty(cx, obj, id);
 78344: }
 78344: 
 55519: class IndexRangePredicate {
 84755:     uint32_t begin, end;
 79934: 
 55519:   public:
 84755:     IndexRangePredicate(uint32_t begin, uint32_t end) : begin(begin), end(end) {}
 55519: 
 87655:     bool operator()(JSFlatString *str) {
 84755:         uint32_t index;
 87655:         return str->isIndex(&index) && begin <= index && index < end;
 79934:     }
 79934: 
 55519:     bool matchesAtMostOne() { return false; }
 55519: };
 55519: 
 55519: bool
 97353: js_SuppressDeletedElements(JSContext *cx, HandleObject obj, uint32_t begin, uint32_t end)
 55519: {
 55519:     return SuppressDeletedPropertyHelper(cx, obj, IndexRangePredicate(begin, end));
 55519: }
 55519: 
 89622: const uint32_t CLOSED_INDEX = UINT32_MAX;
 89622: 
 89622: JSObject *
 97353: ElementIteratorObject::create(JSContext *cx, HandleObject obj)
 89622: {
 89622:     JS_ASSERT(obj);
 89622:     JSObject *iterobj = NewObjectWithGivenProto(cx, &ElementIteratorClass, NULL, obj);
 89622:     if (iterobj) {
 89622:         iterobj->setReservedSlot(TargetSlot, ObjectValue(*obj));
 89622:         iterobj->setReservedSlot(IndexSlot, Int32Value(0));
 89622:     }
 89622:     return iterobj;
 89622: }
 89622: 
 89622: inline uint32_t
 89622: ElementIteratorObject::getIndex() const
 89622: {
 89622:     return uint32_t(getReservedSlot(IndexSlot).toInt32());
 89622: }
 89622: 
 89622: inline JSObject *
 89622: ElementIteratorObject::getTargetObject() const
 89622: {
 89622:     return &getReservedSlot(TargetSlot).toObject();
 89622: }
 89622: 
 89622: inline void
 89622: ElementIteratorObject::setIndex(uint32_t index)
 89622: {
 89622:     setReservedSlot(IndexSlot, Int32Value(int32_t(index)));
 89622: }
 89622: 
 89622: bool
 89622: ElementIteratorObject::iteratorNext(JSContext *cx, Value *vp)
 89622: {
 99421:     Rooted<ElementIteratorObject*> self(cx, this);
 97353: 
 89622:     uint32_t i, length;
 99421:     RootedObject obj(cx, getTargetObject());
 89622:     if (!js_GetLengthProperty(cx, obj, &length))
 89622:         goto error;
 89622: 
 97353:     i = self->getIndex();
 89622:     if (i >= length) {
 97353:         self->setIndex(CLOSED_INDEX);
 89622:         vp->setMagic(JS_NO_ITER_VALUE);
 89622:         return true;
 89622:     }
 89622: 
 89622:     JS_ASSERT(i + 1 > i);
 89622:     if (!obj->getElement(cx, obj, i, vp))
 89622:         goto error;
 89622: 
 89622:     /* On success, bump the index. */
 97353:     self->setIndex(i + 1);
 89622:     return true;
 89622: 
 89622:   error:
 97353:     self->setIndex(CLOSED_INDEX);
 89622:     return false;
 89622: }
 89622: 
 89622: inline js::ElementIteratorObject *
 89622: JSObject::asElementIterator()
 89622: {
 89622:     JS_ASSERT(isElementIterator());
 89622:     return static_cast<js::ElementIteratorObject *>(this);
 89622: }
 89622: 
 42641: JSBool
 95355: js_IteratorMore(JSContext *cx, HandleObject iterobj, Value *rval)
     1: {
 42641:     /* Fast path for native iterators */
 61055:     NativeIterator *ni = NULL;
 77817:     if (iterobj->isIterator()) {
 61055:         /* Key iterators are handled by fast-paths. */
 61055:         ni = iterobj->getNativeIterator();
 61055:         bool more = ni->props_cursor < ni->props_end;
 61055:         if (ni->isKeyIter() || !more) {
 61055:             rval->setBoolean(more);
 42641:             return true;
     1:         }
 61055:     }
     1: 
 42641:     /* We might still have a pending value. */
 48470:     if (!cx->iterValue.isMagic(JS_NO_ITER_VALUE)) {
 48470:         rval->setBoolean(true);
 42641:         return true;
     1:     }
     1: 
 72108:     /* We're reentering below and can call anything. */
 72108:     JS_CHECK_RECURSION(cx, return false);
 72108: 
 42641:     /* Fetch and cache the next value from the iterator. */
 89622:     if (ni) {
 89622:         JS_ASSERT(!ni->isKeyIter());
 99421:         RootedId id(cx);
 98960:         if (!ValueToId(cx, StringValue(*ni->current()), id.address()))
 89622:             return false;
 89622:         ni->incCursor();
 89622:         if (!ni->obj->getGeneric(cx, id, rval))
 89622:             return false;
 89622:         if ((ni->flags & JSITER_KEYVALUE) && !NewKeyValuePair(cx, id, *rval, rval))
 89622:             return false;
 89622:     } else if (iterobj->isElementIterator()) {
 89622:         /*
 89622:          * Like native iterators, element iterators do not have a .next
 89622:          * method, so this fast path is necessary for correctness.
 89622:          */
 89622:         if (!iterobj->asElementIterator()->iteratorNext(cx, rval))
 89622:             return false;
 89622:         if (rval->isMagic(JS_NO_ITER_VALUE)) {
 89622:             cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 89622:             rval->setBoolean(false);
 89622:             return true;
 89622:         }
 89623:     } else if (iterobj->isProxy()) {
 89623:         if (!Proxy::iteratorNext(cx, iterobj, rval))
 89623:             return false;
 89623:         if (rval->isMagic(JS_NO_ITER_VALUE)) {
 89623:             rval->setBoolean(false);
 89623:             return true;
 89623:         }
 89622:     } else {
 89622:         /* Call the iterator object's .next method. */
 98960:         if (!GetMethod(cx, iterobj, cx->runtime->atomState.nextAtom, 0, rval))
 42641:             return false;
 76829:         if (!Invoke(cx, ObjectValue(*iterobj), *rval, 0, NULL, rval)) {
     1:             /* Check for StopIteration. */
 77817:             if (!cx->isExceptionPending() || !IsStopIteration(cx->getPendingException()))
 42641:                 return false;
     1: 
 60211:             cx->clearPendingException();
 48470:             cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 48470:             rval->setBoolean(false);
 42641:             return true;
     1:         }
 61055:     }
     1: 
 42641:     /* Cache the value returned by iterobj.next() so js_IteratorNext() can find it. */
 48470:     JS_ASSERT(!rval->isMagic(JS_NO_ITER_VALUE));
 42641:     cx->iterValue = *rval;
 48470:     rval->setBoolean(true);
 42641:     return true;
 42641: }
 42641: 
 42641: JSBool
 48470: js_IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
 42641: {
 42641:     /* Fast path for native iterators */
 77817:     if (iterobj->isIterator()) {
 42641:         /*
 42641:          * Implement next directly as all the methods of the native iterator are
 42641:          * read-only and permanent.
 42641:          */
 42641:         NativeIterator *ni = iterobj->getNativeIterator();
 80307:         if (ni->isKeyIter()) {
 60785:             JS_ASSERT(ni->props_cursor < ni->props_end);
 87655:             *rval = StringValue(*ni->current());
 61055:             ni->incCursor();
 42641: 
 61055:             if (rval->isString())
 42641:                 return true;
 42641: 
 42641:             JSString *str;
 91450:             int i;
 78537:             if (rval->isInt32() && StaticStrings::hasInt(i = rval->toInt32())) {
 78537:                 str = cx->runtime->staticStrings.getInt(i);
 42641:             } else {
 84160:                 str = ToString(cx, *rval);
 42641:                 if (!str)
 42641:                     return false;
 42641:             }
 42641: 
 48470:             rval->setString(str);
 42641:             return true;
 42641:         }
 61055:     }
 42641: 
 48470:     JS_ASSERT(!cx->iterValue.isMagic(JS_NO_ITER_VALUE));
 42641:     *rval = cx->iterValue;
 48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 42641: 
 42641:     return true;
     1: }
     1: 
     1: static JSBool
 98960: stopiter_hasInstance(JSContext *cx, HandleObject obj, const Value *v, JSBool *bp)
     1: {
 77817:     *bp = IsStopIteration(*v);
     1:     return JS_TRUE;
     1: }
     1: 
 77817: Class js::StopIterationClass = {
     1:     js_StopIteration_str,
 56574:     JSCLASS_HAS_CACHED_PROTO(JSProto_StopIteration) |
 56576:     JSCLASS_FREEZE_PROTO,
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     NULL,                    /* finalize    */
 48622:     NULL,                    /* checkAccess */
 48622:     NULL,                    /* call        */
 98058:     stopiter_hasInstance,
 98058:     NULL                     /* construct   */
     1: };
     1: 
     1: #if JS_HAS_GENERATORS
     1: 
     1: static void
 94738: generator_finalize(FreeOp *fop, JSObject *obj)
     1: {
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 31452:     if (!gen)
 31452:         return;
     1: 
     1:     /*
 31452:      * gen is open when a script has not called its close method while
 31452:      * explicitly manipulating it.
     1:      */
 31452:     JS_ASSERT(gen->state == JSGEN_NEWBORN ||
 31452:               gen->state == JSGEN_CLOSED ||
     1:               gen->state == JSGEN_OPEN);
 94738:     fop->free_(gen);
     1: }
     1: 
   583: static void
 82129: MarkGenerator(JSTracer *trc, JSGenerator *gen)
 82129: {
100006:     StackFrame *fp = gen->floatingFrame();
100006: 
100006:     /*
100006:      * MarkGenerator should only be called when regs is based on the floating frame.
100006:      * See calls to RebaseRegsFromTo.
100006:      */
100006:     JS_ASSERT(size_t(gen->regs.sp - fp->slots()) <= fp->numSlots());
100006: 
100006:     /*
100006:      * Currently, generators are not mjitted. Still, (overflow) args can be
100006:      * pushed by the mjit and need to be conservatively marked. Technically, the
100006:      * formal args and generator slots are safe for exact marking, but since the
100006:      * plan is to eventually mjit generators, it makes sense to future-proof
100006:      * this code and save someone an hour later.
100006:      */
100006:     MarkValueRange(trc, (HeapValue *)fp->formalArgsEnd() - gen->floatingStack,
100006:                    gen->floatingStack, "Generator Floating Args");
100006:     fp->mark(trc);
100006:     MarkValueRange(trc, gen->regs.sp - fp->slots(),
100006:                    (HeapValue *)fp->slots(), "Generator Floating Stack");
 82129: }
 82129: 
 82129: static void
 82129: GeneratorWriteBarrierPre(JSContext *cx, JSGenerator *gen)
 82129: {
 82129:     JSCompartment *comp = cx->compartment;
 82129:     if (comp->needsBarrier())
 82129:         MarkGenerator(comp->barrierTracer(), gen);
 82129: }
 82129: 
 82129: static void
   583: generator_trace(JSTracer *trc, JSObject *obj)
     1: {
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
  4282:     if (!gen)
  4282:         return;
  4282: 
     1:     /*
 42714:      * Do not mark if the generator is running; the contents may be trash and
 42714:      * will be replaced when the generator stops.
     1:      */
 42714:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING)
 42714:         return;
  4282: 
100006:     JS_ASSERT(gen->liveFrame() == gen->floatingFrame());
 82129:     MarkGenerator(trc, gen);
     1: }
     1: 
 77817: Class js::GeneratorClass = {
 78098:     "Generator",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS,
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     generator_finalize,
 48622:     NULL,                    /* checkAccess */
 48622:     NULL,                    /* call        */
 48622:     NULL,                    /* construct   */
 48622:     NULL,                    /* hasInstance */
 64218:     generator_trace,
 48622:     {
 48622:         NULL,                /* equality       */
 48622:         NULL,                /* outerObject    */
 48622:         NULL,                /* innerObject    */
 48622:         iterator_iterator,
 56565:         NULL                 /* unused */
 48622:     }
     1: };
     1: 
     1: /*
     1:  * Called from the JSOP_GENERATOR case in the interpreter, with fp referring
     1:  * to the frame by which the generator function was activated.  Create a new
 69223:  * JSGenerator object, which contains its own StackFrame that we populate
     1:  * from *fp.  We know that upon return, the JSOP_GENERATOR opcode will return
     1:  * from the activation in fp, so we can steal away fp->callobj and fp->argsobj
     1:  * if they are non-null.
     1:  */
 86484: JSObject *
 37777: js_NewGenerator(JSContext *cx)
     1: {
 71695:     FrameRegs &stackRegs = cx->regs();
 71695:     StackFrame *stackfp = stackRegs.fp();
100006:     JS_ASSERT(stackfp->base() == cx->regs().sp);
100006:     JS_ASSERT(stackfp->actualArgs() <= stackfp->formalArgs());
 53840: 
 99421:     Rooted<GlobalObject*> global(cx, &stackfp->global());
 78098:     JSObject *proto = global->getOrCreateGeneratorPrototype(cx);
 78098:     if (!proto)
 78098:         return NULL;
 83275:     JSObject *obj = NewObjectWithGivenProto(cx, &GeneratorClass, proto, global);
 78098:     if (!obj)
 78098:         return NULL;
 78098: 
     1:     /* Load and compute stack slot counts. */
100006:     Value *stackvp = stackfp->actualArgs() - 2;
100006:     unsigned vplen = stackfp->formalArgsEnd() - stackvp;
     1: 
 42714:     /* Compute JSGenerator size. */
 91237:     unsigned nbytes = sizeof(JSGenerator) +
 48470:                    (-1 + /* one Value included in JSGenerator */
 42714:                     vplen +
 42714:                     VALUES_PER_STACK_FRAME +
100006:                     stackfp->numSlots()) * sizeof(HeapValue);
 90005: 
 90005:     JS_ASSERT(nbytes % sizeof(Value) == 0);
 90005:     JS_STATIC_ASSERT(sizeof(StackFrame) % sizeof(HeapValue) == 0);
 42714: 
 64560:     JSGenerator *gen = (JSGenerator *) cx->malloc_(nbytes);
     1:     if (!gen)
 31452:         return NULL;
 90005:     SetValueRangeToUndefined((Value *)gen, nbytes / sizeof(Value));
     1: 
 42714:     /* Cut up floatingStack space. */
100006:     HeapValue *genvp = gen->floatingStack;
 69223:     StackFrame *genfp = reinterpret_cast<StackFrame *>(genvp + vplen);
 42714: 
 42714:     /* Initialize JSGenerator. */
 82129:     gen->obj.init(obj);
 42714:     gen->state = JSGEN_NEWBORN;
 43281:     gen->enumerators = NULL;
100006:     gen->floating = genfp;
 42708: 
 71695:     /* Copy from the stack to the generator's floating frame. */
 71697:     gen->regs.rebaseFromTo(stackRegs, *genfp);
100006:     genfp->stealFrameAndSlots<HeapValue, Value, StackFrame::DoPostBarrier>(
 98921:                               cx, genfp, genvp, stackfp, stackvp, stackRegs.sp);
100006:     genfp->initFloatingGenerator();
100006:     stackfp->setYielding();  /* XXX: to be removed */
     1: 
 31452:     obj->setPrivate(gen);
     1:     return obj;
     1: }
     1: 
100006: JSGenerator *
100006: js_FloatingFrameToGenerator(StackFrame *fp)
100006: {
100006:     JS_ASSERT(fp->isGeneratorFrame() && fp->isFloatingGenerator());
100006:     char *floatingStackp = (char *)(fp->actualArgs() - 2);
100006:     char *p = floatingStackp - offsetof(JSGenerator, floatingStack);
100006:     return reinterpret_cast<JSGenerator *>(p);
100006: }
100006: 
     1: typedef enum JSGeneratorOp {
     1:     JSGENOP_NEXT,
     1:     JSGENOP_SEND,
     1:     JSGENOP_THROW,
     1:     JSGENOP_CLOSE
     1: } JSGeneratorOp;
     1: 
     1: /*
     1:  * Start newborn or restart yielding generator and perform the requested
     1:  * operation inside its frame.
     1:  */
 86484: static JSBool
     1: SendToGenerator(JSContext *cx, JSGeneratorOp op, JSObject *obj,
 48470:                 JSGenerator *gen, const Value &arg)
     1: {
  3554:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING) {
100006:         js_ReportValueError(cx, JSMSG_NESTING_GENERATOR,
100006:                             JSDVG_SEARCH_STACK, ObjectOrNullValue(obj),
100006:                             JS_GetFunctionId(gen->floatingFrame()->fun()));
  3554:         return JS_FALSE;
  3554:     }
  3554: 
100006:     /* Check for OOM errors here, where we can fail easily. */
100006:     if (!cx->ensureGeneratorStackSpace())
100006:         return JS_FALSE;
100006: 
 82129:     /*
 82129:      * Write barrier is needed since the generator stack can be updated,
 82129:      * and it's not barriered in any other way. We need to do it before
 82129:      * gen->state changes, which can cause us to trace the generator
 82129:      * differently.
 82129:      *
 82129:      * We could optimize this by setting a bit on the generator to signify
 82129:      * that it has been marked. If this bit has already been set, there is no
 82129:      * need to mark again. The bit would have to be reset before the next GC,
 82129:      * or else some kind of epoch scheme would have to be used.
 82129:      */
 82129:     GeneratorWriteBarrierPre(cx, gen);
 82129: 
     1:     JS_ASSERT(gen->state == JSGEN_NEWBORN || gen->state == JSGEN_OPEN);
     1:     switch (op) {
     1:       case JSGENOP_NEXT:
     1:       case JSGENOP_SEND:
     1:         if (gen->state == JSGEN_OPEN) {
     1:             /*
     1:              * Store the argument to send as the result of the yield
     1:              * expression.
     1:              */
 53840:             gen->regs.sp[-1] = arg;
     1:         }
     1:         gen->state = JSGEN_RUNNING;
     1:         break;
     1: 
     1:       case JSGENOP_THROW:
 60211:         cx->setPendingException(arg);
     1:         gen->state = JSGEN_RUNNING;
     1:         break;
     1: 
     1:       default:
     1:         JS_ASSERT(op == JSGENOP_CLOSE);
 60211:         cx->setPendingException(MagicValue(JS_GENERATOR_CLOSING));
     1:         gen->state = JSGEN_CLOSING;
     1:         break;
     1:     }
     1: 
100006:     StackFrame *genfp = gen->floatingFrame();
100006: 
 42714:     JSBool ok;
 42714:     {
 71695:         GeneratorFrameGuard gfg;
 71695:         if (!cx->stack.pushGeneratorFrame(cx, gen, &gfg)) {
 42714:             gen->state = JSGEN_CLOSED;
 42714:             return JS_FALSE;
 42714:         }
 42714: 
 71695:         StackFrame *fp = gfg.fp();
 71695:         gen->regs = cx->regs();
100006:         JS_ASSERT(gen->liveFrame() == fp);
 42714: 
 53840:         cx->enterGenerator(gen);   /* OOM check above. */
 43281:         JSObject *enumerators = cx->enumerators;
 43281:         cx->enumerators = gen->enumerators;
 43281: 
 71695:         ok = RunScript(cx, fp->script(), fp);
 42708: 
 43281:         gen->enumerators = cx->enumerators;
 43281:         cx->enumerators = enumerators;
 53840:         cx->leaveGenerator(gen);
 53840:     }
 42708: 
100006:     if (gen->floatingFrame()->isYielding()) {
     1:         /* Yield cannot fail, throw or be called on closing. */
     1:         JS_ASSERT(ok);
 60211:         JS_ASSERT(!cx->isExceptionPending());
     1:         JS_ASSERT(gen->state == JSGEN_RUNNING);
     1:         JS_ASSERT(op != JSGENOP_CLOSE);
100006:         genfp->clearYielding();
     1:         gen->state = JSGEN_OPEN;
     1:         return JS_TRUE;
     1:     }
     1: 
100006:     genfp->clearReturnValue();
     1:     gen->state = JSGEN_CLOSED;
     1:     if (ok) {
     1:         /* Returned, explicitly or by falling off the end. */
     1:         if (op == JSGENOP_CLOSE)
     1:             return JS_TRUE;
  6464:         return js_ThrowStopIteration(cx);
     1:     }
     1: 
     1:     /*
  9780:      * An error, silent termination by operation callback or an exception.
     1:      * Propagate the condition to the caller.
     1:      */
     1:     return JS_FALSE;
     1: }
     1: 
 86484: static JSBool
  3436: CloseGenerator(JSContext *cx, JSObject *obj)
     1: {
 77817:     JS_ASSERT(obj->isGenerator());
  3025: 
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
  3025:     if (!gen) {
  3025:         /* Generator prototype object. */
  3025:         return JS_TRUE;
  3025:     }
  3025: 
  3025:     if (gen->state == JSGEN_CLOSED)
  3025:         return JS_TRUE;
  3025: 
 48470:     return SendToGenerator(cx, JSGENOP_CLOSE, obj, gen, UndefinedValue());
     1: }
     1: 
     1: /*
     1:  * Common subroutine of generator_(next|send|throw|close) methods.
     1:  */
     1: static JSBool
 91237: generator_op(JSContext *cx, Native native, JSGeneratorOp op, Value *vp, unsigned argc)
     1: {
 79387:     CallArgs args = CallArgsFromVp(argc, vp);
 79389: 
 79389:     bool ok;
 79779:     JSObject *obj = NonGenericMethodGuard(cx, args, native, &GeneratorClass, &ok);
 67943:     if (!obj)
 79389:         return ok;
     1: 
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 31452:     if (!gen) {
     1:         /* This happens when obj is the generator prototype. See bug 352885. */
     1:         goto closed_generator;
     1:     }
     1: 
  3554:     if (gen->state == JSGEN_NEWBORN) {
     1:         switch (op) {
     1:           case JSGENOP_NEXT:
     1:           case JSGENOP_THROW:
     1:             break;
     1: 
     1:           case JSGENOP_SEND:
 91388:             if (args.hasDefined(0)) {
     1:                 js_ReportValueError(cx, JSMSG_BAD_GENERATOR_SEND,
 79387:                                     JSDVG_SEARCH_STACK, args[0], NULL);
 79387:                 return false;
     1:             }
     1:             break;
     1: 
     1:           default:
     1:             JS_ASSERT(op == JSGENOP_CLOSE);
     1:             gen->state = JSGEN_CLOSED;
 79387:             args.rval().setUndefined();
 79387:             return true;
     1:         }
  3554:     } else if (gen->state == JSGEN_CLOSED) {
     1:       closed_generator:
     1:         switch (op) {
     1:           case JSGENOP_NEXT:
     1:           case JSGENOP_SEND:
  6464:             return js_ThrowStopIteration(cx);
     1:           case JSGENOP_THROW:
 79387:             cx->setPendingException(args.length() >= 1 ? args[0] : UndefinedValue());
 79387:             return false;
     1:           default:
     1:             JS_ASSERT(op == JSGENOP_CLOSE);
 79387:             args.rval().setUndefined();
 79387:             return true;
     1:         }
     1:     }
     1: 
 79387:     bool undef = ((op == JSGENOP_SEND || op == JSGENOP_THROW) && args.length() != 0);
 79387:     if (!SendToGenerator(cx, op, obj, gen, undef ? args[0] : UndefinedValue()))
 79387:         return false;
 64224: 
100006:     args.rval() = gen->floatingFrame()->returnValue();
 79387:     return true;
     1: }
     1: 
     1: static JSBool
 91237: generator_send(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79779:     return generator_op(cx, generator_send, JSGENOP_SEND, vp, argc);
     1: }
     1: 
     1: static JSBool
 91237: generator_next(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79779:     return generator_op(cx, generator_next, JSGENOP_NEXT, vp, argc);
     1: }
     1: 
     1: static JSBool
 91237: generator_throw(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79779:     return generator_op(cx, generator_throw, JSGENOP_THROW, vp, argc);
     1: }
     1: 
     1: static JSBool
 91237: generator_close(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79779:     return generator_op(cx, generator_close, JSGENOP_CLOSE, vp, argc);
     1: }
     1: 
     1: static JSFunctionSpec generator_methods[] = {
 16519:     JS_FN(js_next_str,      generator_next,     0,JSPROP_ROPERM),
 16519:     JS_FN(js_send_str,      generator_send,     1,JSPROP_ROPERM),
 16519:     JS_FN(js_throw_str,     generator_throw,    1,JSPROP_ROPERM),
 16519:     JS_FN(js_close_str,     generator_close,    0,JSPROP_ROPERM),
  4127:     JS_FS_END
     1: };
     1: 
     1: #endif /* JS_HAS_GENERATORS */
     1: 
 75062: static bool
 97353: InitIteratorClass(JSContext *cx, Handle<GlobalObject*> global)
 75062: {
 99421:     RootedObject iteratorProto(cx, global->createBlankPrototype(cx, &IteratorClass));
 75062:     if (!iteratorProto)
 75062:         return false;
 75062: 
 80307:     AutoIdVector blank(cx);
 80307:     NativeIterator *ni = NativeIterator::allocateIterator(cx, 0, blank);
 80307:     if (!ni)
 80307:         return false;
 80307:     ni->init(NULL, 0 /* flags */, 0, 0);
 80307: 
 80307:     iteratorProto->setNativeIterator(ni);
 80307: 
 99421:     RootedFunction ctor(cx);
 97828:     ctor = global->createConstructor(cx, Iterator, CLASS_NAME(cx, Iterator), 2);
 75062:     if (!ctor)
 75062:         return false;
 75062: 
 75062:     if (!LinkConstructorAndPrototype(cx, ctor, iteratorProto))
 75062:         return false;
 75062: 
 75062:     if (!DefinePropertiesAndBrand(cx, iteratorProto, NULL, iterator_methods))
 75062:         return false;
 75062: 
 75062:     return DefineConstructorAndPrototype(cx, global, JSProto_Iterator, ctor, iteratorProto);
 75062: }
 75062: 
 97353: /* static */ bool
 97353: GlobalObject::initGeneratorClass(JSContext *cx, Handle<GlobalObject*> global)
 75062: {
 75062: #if JS_HAS_GENERATORS
 99421:     RootedObject proto(cx, global->createBlankPrototype(cx, &GeneratorClass));
 78098:     if (!proto || !DefinePropertiesAndBrand(cx, proto, NULL, generator_methods))
 75063:         return false;
 97353:     global->setReservedSlot(GENERATOR_PROTO, ObjectValue(*proto));
 78098: #endif
 75062:     return true;
 75062: }
 75062: 
 75062: static JSObject *
 97353: InitStopIterationClass(JSContext *cx, Handle<GlobalObject*> global)
 75062: {
 99421:     RootedObject proto(cx, global->createBlankPrototype(cx, &StopIterationClass));
 75064:     if (!proto || !proto->freeze(cx))
 75064:         return NULL;
 75064: 
 75064:     /* This should use a non-JSProtoKey'd slot, but this is easier for now. */
 75064:     if (!DefineConstructorAndPrototype(cx, global, JSProto_StopIteration, proto, proto))
 75064:         return NULL;
 75064: 
 77817:     MarkStandardClassInitializedNoProto(global, &StopIterationClass);
 75064: 
 75062:     return proto;
 75062: }
 75062: 
     1: JSObject *
     1: js_InitIteratorClasses(JSContext *cx, JSObject *obj)
     1: {
 75062:     JS_ASSERT(obj->isNative());
     1: 
 99421:     Rooted<GlobalObject*> global(cx, &obj->asGlobal());
 75062: 
 75062:     /*
 75062:      * Bail if Iterator has already been initialized.  We test for Iterator
 75062:      * rather than for StopIteration because if js_InitIteratorClasses recurs,
 75062:      * as happens when the StopIteration object is frozen, initializing the
 75062:      * Iterator class a second time will assert.
 75062:      */
 75062:     JSObject *iter;
 75062:     if (!js_GetClassObject(cx, global, JSProto_Iterator, &iter))
     1:         return NULL;
 75062:     if (iter)
 75062:         return iter;
     1: 
 97353:     if (!InitIteratorClass(cx, global) || !GlobalObject::initGeneratorClass(cx, global))
     1:         return NULL;
 75062:     return InitStopIterationClass(cx, global);
     1: }
