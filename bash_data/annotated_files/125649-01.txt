     1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef GFX_FONT_H
     1: #define GFX_FONT_H
     1: 
 72496: #include "nsAlgorithm.h"
     1: #include "gfxTypes.h"
     1: #include "nsString.h"
     1: #include "gfxPoint.h"
 16418: #include "gfxFontUtils.h"
     1: #include "nsTArray.h"
   323: #include "nsTHashtable.h"
   323: #include "nsHashKeys.h"
     1: #include "gfxSkipChars.h"
     1: #include "gfxRect.h"
   323: #include "nsExpirationTracker.h"
 24407: #include "gfxFontConstants.h"
 37211: #include "gfxPlatform.h"
 38493: #include "nsIAtom.h"
 40109: #include "nsISupportsImpl.h"
 89450: #include "gfxPattern.h"
 92143: #include "mozilla/HashFunctions.h"
 93997: #include "nsIMemoryReporter.h"
 96985: #include "gfxFontFeatures.h"
 99162: #include "mozilla/gfx/Types.h"
101898: #include "mozilla/Attributes.h"
     1: 
 84651: typedef struct _cairo_scaled_font cairo_scaled_font_t;
 84651: 
 10484: #ifdef DEBUG
 10484: #include <stdio.h>
 10484: #endif
 10484: 
     1: class gfxContext;
     1: class gfxTextRun;
   323: class gfxFont;
 31590: class gfxFontFamily;
     1: class gfxFontGroup;
 19962: class gfxUserFontSet;
 19962: class gfxUserFontData;
 86691: class gfxShapedWord;
111292: class gfxSVGGlyphs;
111295: class gfxTextObjectPaint;
     1: 
 38492: class nsILanguageAtomService;
 38492: 
107539: typedef struct hb_blob_t hb_blob_t;
 43526: 
  2210: #define FONT_MAX_SIZE                  2000.0
  2210: 
 47360: #define NO_FONT_LANGUAGE_OVERRIDE      0
 47360: 
 94199: struct FontListSizes;
 94199: 
     1: struct THEBES_API gfxFontStyle {
 12929:     gfxFontStyle();
108991:     gfxFontStyle(uint8_t aStyle, uint16_t aWeight, int16_t aStretch,
 38493:                  gfxFloat aSize, nsIAtom *aLanguage,
 79445:                  float aSizeAdjust, bool aSystemFont,
 79445:                  bool aPrinterFont,
 47360:                  const nsString& aLanguageOverride);
   323:     gfxFontStyle(const gfxFontStyle& aStyle);
     1: 
 93218:     // the language (may be an internal langGroup code rather than an actual
 93218:     // language code) specified in the document or element's lang property,
 93218:     // or inferred from the charset
 93218:     nsRefPtr<nsIAtom> language;
 93218: 
 93218:     // custom opentype feature settings
 93218:     nsTArray<gfxFontFeature> featureSettings;
 24408: 
     1:     // The logical size of the font, in pixels
     1:     gfxFloat size;
     1: 
     1:     // The aspect-value (ie., the ratio actualsize:actualxheight) that any
     1:     // actual physical font created from this font structure must have when
     1:     // rendering or measuring a string. A value of 0 means no adjustment
     1:     // needs to be done.
     1:     float sizeAdjust;
     1: 
 47360:     // Language system tag, to override document language;
 47360:     // an OpenType "language system" tag represented as a 32-bit integer
 47360:     // (see http://www.microsoft.com/typography/otspec/languagetags.htm).
 47360:     // Normally 0, so font rendering will use the document or element language
 47360:     // (see above) to control any language-specific rendering, but the author
 47360:     // can override this for cases where the options implemented in the font
 47360:     // do not directly match the actual language. (E.g. lang may be Macedonian,
 47360:     // but the font in use does not explicitly support this; the author can
 47360:     // use font-language-override to request the Serbian option in the font
 47360:     // in order to get correct glyph shapes.)
108991:     uint32_t languageOverride;
 47360: 
 93218:     // The weight of the font: 100, 200, ... 900.
108991:     uint16_t weight;
 93218: 
 93218:     // The stretch of the font (the sum of various NS_FONT_STRETCH_*
 93218:     // constants; see gfxFontConstants.h).
108991:     int8_t stretch;
 93218: 
 93218:     // Say that this font is a system font and therefore does not
 93218:     // require certain fixup that we do for fonts from untrusted
 93218:     // sources.
 93218:     bool systemFont : 1;
 93218: 
 93218:     // Say that this font is used for print or print preview.
 93218:     bool printerFont : 1;
 93218: 
 93218:     // The style of font (normal, italic, oblique)
108991:     uint8_t style : 2;
 47360: 
  2210:     // Return the final adjusted font size for the given aspect ratio.
  2210:     // Not meant to be called when sizeAdjust = 0.
  2210:     gfxFloat GetAdjustedSize(gfxFloat aspect) const {
  2210:         NS_ASSERTION(sizeAdjust != 0.0, "Not meant to be called when sizeAdjust = 0");
 72496:         gfxFloat adjustedSize = NS_MAX(NS_round(size*(sizeAdjust/aspect)), 1.0);
 72496:         return NS_MIN(adjustedSize, FONT_MAX_SIZE);
  2210:     }
  2210: 
   323:     PLDHashNumber Hash() const {
 63567:         return ((style + (systemFont << 7) +
108991:             (weight << 8)) + uint32_t(size*1000) + uint32_t(sizeAdjust*1000)) ^
 38493:             nsISupportsHashKey::HashKey(language);
   323:     }
   323: 
108991:     int8_t ComputeWeight() const;
     1: 
 79445:     bool Equals(const gfxFontStyle& other) const {
119673:         return
119673:             (*reinterpret_cast<const uint64_t*>(&size) ==
119673:              *reinterpret_cast<const uint64_t*>(&other.size)) &&
     1:             (style == other.style) &&
     1:             (systemFont == other.systemFont) &&
 22866:             (printerFont == other.printerFont) &&
     1:             (weight == other.weight) &&
 24408:             (stretch == other.stretch) &&
 38493:             (language == other.language) &&
119673:             (*reinterpret_cast<const uint32_t*>(&sizeAdjust) ==
119673:              *reinterpret_cast<const uint32_t*>(&other.sizeAdjust)) &&
 58968:             (featureSettings == other.featureSettings) &&
 47360:             (languageOverride == other.languageOverride);
     1:     }
 47360: 
 47360:     static void ParseFontFeatureSettings(const nsString& aFeatureString,
 47360:                                          nsTArray<gfxFontFeature>& aFeatures);
 47360: 
108991:     static uint32_t ParseFontLanguageOverride(const nsString& aLangTag);
     1: };
     1: 
 95682: class gfxCharacterMap : public gfxSparseBitSet {
 95682: public:
 95682:     nsrefcnt AddRef() {
108991:         NS_PRECONDITION(int32_t(mRefCnt) >= 0, "illegal refcnt");
 95682:         ++mRefCnt;
 95682:         NS_LOG_ADDREF(this, mRefCnt, "gfxCharacterMap", sizeof(*this));
 95682:         return mRefCnt;
 95682:     }
 95682: 
 95682:     nsrefcnt Release() {
 95682:         NS_PRECONDITION(0 != mRefCnt, "dup release");
 95682:         --mRefCnt;
 95682:         NS_LOG_RELEASE(this, mRefCnt, "gfxCharacterMap");
 95682:         if (mRefCnt == 0) {
 95682:             NotifyReleased();
 95682:             // |this| has been deleted.
 95682:             return 0;
 95682:         }
 95682:         return mRefCnt;
 95682:     }
 95682: 
 95682:     gfxCharacterMap() :
 95682:         mHash(0), mBuildOnTheFly(false), mShared(false)
 95682:     { }
 95682: 
 95682:     void CalcHash() { mHash = GetChecksum(); }
 95682: 
 95682:     size_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const {
 95682:         return gfxSparseBitSet::SizeOfExcludingThis(aMallocSizeOf);
 95682:     }
 95682: 
 95682:     // hash of the cmap bitvector
108991:     uint32_t mHash;
 95682: 
 95682:     // if cmap is built on the fly it's never shared
 95682:     bool mBuildOnTheFly;
 95682: 
 95682:     // cmap is shared globally
 95682:     bool mShared;
 95682: 
 95682: protected:
 95682:     void NotifyReleased();
 95682: 
 95682:     nsAutoRefCnt mRefCnt;
 95682: 
 95682: private:
 95682:     gfxCharacterMap(const gfxCharacterMap&);
 95682:     gfxCharacterMap& operator=(const gfxCharacterMap&);
 95682: };
 95682: 
 16418: class gfxFontEntry {
 16418: public:
 40109:     NS_INLINE_DECL_REFCOUNTING(gfxFontEntry)
 16418: 
106838:     gfxFontEntry(const nsAString& aName, gfxFontFamily *aFamily = nullptr,
 79445:                  bool aIsStandardFace = false) : 
 80486:         mName(aName), mItalic(false), mFixedPitch(false),
 80486:         mIsProxy(false), mIsValid(true), 
 80486:         mIsBadUnderlineFont(false), mIsUserFont(false),
 80486:         mIsLocalUserFont(false), mStandardFace(aIsStandardFace),
 80486:         mSymbolFont(false),
 80486:         mIgnoreGDEF(false),
 93388:         mIgnoreGSUB(false),
111292:         mSVGInitialized(false),
 24683:         mWeight(500), mStretch(NS_FONT_STRETCH_NORMAL),
 84392: #ifdef MOZ_GRAPHITE
 84392:         mCheckedForGraphiteTables(false),
 84392: #endif
 80486:         mHasCmapTable(false),
106838:         mUVSOffset(0), mUVSData(nullptr),
106838:         mUserFontData(nullptr),
111292:         mSVGGlyphs(nullptr),
 47360:         mLanguageOverride(NO_FONT_LANGUAGE_OVERRIDE),
 31590:         mFamily(aFamily)
 16418:     { }
 16418: 
 16418:     virtual ~gfxFontEntry();
 16418: 
 71914:     // unique name for the face, *not* the family; not necessarily the
 71914:     // "real" or user-friendly name, may be an internal identifier
 16418:     const nsString& Name() const { return mName; }
 16418: 
 71914:     // the "real" name of the face, if available from the font resource
 71914:     // (may be expensive); returns Name() if nothing better is available
 71914:     virtual nsString RealFaceName();
 71914: 
 63782:     gfxFontFamily* Family() const { return mFamily; }
 63782: 
108991:     uint16_t Weight() const { return mWeight; }
108991:     int16_t Stretch() const { return mStretch; }
 16418: 
 79445:     bool IsUserFont() const { return mIsUserFont; }
 79445:     bool IsLocalUserFont() const { return mIsLocalUserFont; }
 79445:     bool IsFixedPitch() const { return mFixedPitch; }
 79445:     bool IsItalic() const { return mItalic; }
 79445:     bool IsBold() const { return mWeight >= 600; } // bold == weights 600 and above
 79445:     bool IgnoreGDEF() const { return mIgnoreGDEF; }
 93388:     bool IgnoreGSUB() const { return mIgnoreGSUB; }
 16418: 
 79445:     virtual bool IsSymbolFont();
 70100: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     inline bool HasGraphiteTables() {
 84392:         if (!mCheckedForGraphiteTables) {
 84392:             CheckForGraphiteTables();
 84392:             mCheckedForGraphiteTables = true;
 84392:         }
 84392:         return mHasGraphiteTables;
 84392:     }
 84392: #endif
 84392: 
 79445:     inline bool HasCmapTable() {
 95682:         if (!mCharacterMap) {
 43527:             ReadCMAP();
 95682:             NS_ASSERTION(mCharacterMap, "failed to initialize character map");
 43527:         }
 43527:         return mHasCmapTable;
 43527:     }
 43527: 
108991:     inline bool HasCharacter(uint32_t ch) {
 95682:         if (mCharacterMap && mCharacterMap->test(ch)) {
 80486:             return true;
 95682:         }
 16418:         return TestCharacterMap(ch);
 16418:     }
 16418: 
 79445:     virtual bool SkipDuringSystemFallback() { return false; }
108991:     virtual bool TestCharacterMap(uint32_t aCh);
 42989:     nsresult InitializeUVSMap();
108991:     uint16_t GetUVSGlyph(uint32_t aCh, uint32_t aVS);
 31590:     virtual nsresult ReadCMAP();
 31590: 
111292:     bool TryGetSVGData();
111292:     bool HasSVGGlyph(uint32_t aGlyphId);
111300:     bool GetSVGGlyphExtents(gfxContext *aContext, uint32_t aGlyphId,
111300:                             gfxRect *aResult);
111295:     bool RenderSVGGlyph(gfxContext *aContext, uint32_t aGlyphId, int aDrawMode,
111295:                         gfxTextObjectPaint *aObjectPaint);
111292: 
 79445:     virtual bool MatchesGenericFamily(const nsACString& aGeneric) const {
 80486:         return true;
 36949:     }
 79445:     virtual bool SupportsLangGroup(nsIAtom *aLangGroup) const {
 80486:         return true;
 36949:     }
 36949: 
108991:     virtual nsresult GetFontTable(uint32_t aTableTag, FallibleTArray<uint8_t>& aBuffer) {
 47309:         return NS_ERROR_FAILURE; // all platform subclasses should reimplement this!
 47309:     }
 47309: 
 36967:     void SetFamily(gfxFontFamily* aFamily) {
 36967:         mFamily = aFamily;
 36967:     }
 36967: 
 71910:     virtual nsString FamilyName() const;
 16418: 
 43526:     already_AddRefed<gfxFont> FindOrMakeFont(const gfxFontStyle *aStyle,
 79445:                                              bool aNeedsBold);
 43526: 
 58944:     // Get an existing font table cache entry in aBlob if it has been
 80486:     // registered, or return false if not.  Callers must call
 80486:     // hb_blob_destroy on aBlob if true is returned.
 43526:     //
 43526:     // Note that some gfxFont implementations may not call this at all,
 43526:     // if it is more efficient to get the table from the OS at that level.
108991:     bool GetExistingFontTable(uint32_t aTag, hb_blob_t** aBlob);
 58944: 
 58944:     // Elements of aTable are transferred (not copied) to and returned in a
 58944:     // new hb_blob_t which is registered on the gfxFontEntry, but the initial
 58944:     // reference is owned by the caller.  Removing the last reference
 58944:     // unregisters the table from the font entry.
 58944:     //
 58944:     // Pass NULL for aBuffer to indicate that the table is not present and
 58944:     // NULL will be returned.  Also returns NULL on OOM.
108991:     hb_blob_t *ShareFontTableAndGetBlob(uint32_t aTag,
108991:                                         FallibleTArray<uint8_t>* aTable);
 37211: 
 94199:     // For memory reporting
 94199:     virtual void SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                      FontListSizes*    aSizes) const;
 94199:     virtual void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                      FontListSizes*    aSizes) const;
 94199: 
 16418:     nsString         mName;
 16418: 
 79445:     bool             mItalic      : 1;
 79445:     bool             mFixedPitch  : 1;
 79445:     bool             mIsProxy     : 1;
 79445:     bool             mIsValid     : 1;
 79445:     bool             mIsBadUnderlineFont : 1;
 79445:     bool             mIsUserFont  : 1;
 79445:     bool             mIsLocalUserFont  : 1;
 79445:     bool             mStandardFace : 1;
 79445:     bool             mSymbolFont  : 1;
 79445:     bool             mIgnoreGDEF  : 1;
 93388:     bool             mIgnoreGSUB  : 1;
111292:     bool             mSVGInitialized : 1;
 16418: 
108991:     uint16_t         mWeight;
108991:     int16_t          mStretch;
 16418: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     bool             mHasGraphiteTables;
 84392:     bool             mCheckedForGraphiteTables;
 84392: #endif
 79445:     bool             mHasCmapTable;
 95682:     nsRefPtr<gfxCharacterMap> mCharacterMap;
108991:     uint32_t         mUVSOffset;
108991:     nsAutoArrayPtr<uint8_t> mUVSData;
 19962:     gfxUserFontData* mUserFontData;
111292:     gfxSVGGlyphs    *mSVGGlyphs;
 31590: 
 58968:     nsTArray<gfxFontFeature> mFeatureSettings;
108991:     uint32_t         mLanguageOverride;
 47360: 
 31590: protected:
 31590:     friend class gfxPlatformFontList;
 31590:     friend class gfxMacPlatformFontList;
 57979:     friend class gfxUserFcFontEntry;
 31590:     friend class gfxFontFamily;
 37618:     friend class gfxSingleFaceMacFontFamily;
 31590: 
 31590:     gfxFontEntry() :
 80486:         mItalic(false), mFixedPitch(false),
 80486:         mIsProxy(false), mIsValid(true), 
 80486:         mIsBadUnderlineFont(false),
 80486:         mIsUserFont(false),
 80486:         mIsLocalUserFont(false),
 80486:         mStandardFace(false),
 80486:         mSymbolFont(false),
 80486:         mIgnoreGDEF(false),
 93388:         mIgnoreGSUB(false),
111292:         mSVGInitialized(false),
 31590:         mWeight(500), mStretch(NS_FONT_STRETCH_NORMAL),
 84392: #ifdef MOZ_GRAPHITE
 84392:         mCheckedForGraphiteTables(false),
 84392: #endif
 80486:         mHasCmapTable(false),
106838:         mUVSOffset(0), mUVSData(nullptr),
106838:         mUserFontData(nullptr),
111292:         mSVGGlyphs(nullptr),
 47360:         mLanguageOverride(NO_FONT_LANGUAGE_OVERRIDE),
106838:         mFamily(nullptr)
 31590:     { }
 31590: 
 79445:     virtual gfxFont *CreateFontInstance(const gfxFontStyle *aFontStyle, bool aNeedsBold) {
 37211:         NS_NOTREACHED("oops, somebody didn't override CreateFontInstance");
106838:         return nullptr;
 37211:     }
 37211: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     virtual void CheckForGraphiteTables();
 84392: #endif
 84392: 
 31590:     gfxFontFamily *mFamily;
 42989: 
 58248: private:
 58248: 
 58248:     /**
 58248:      * Font table hashtable, to support GetFontTable for harfbuzz.
 43526:      *
 43526:      * The harfbuzz shaper (and potentially other clients) needs access to raw
 43526:      * font table data. This needs to be cached so that it can be used
 43526:      * repeatedly (each time we construct a text run; in some cases, for
 43526:      * each character/glyph within the run) without re-fetching large tables
 43526:      * every time.
 43526:      * 
 43526:      * Because we may instantiate many gfxFonts for the same physical font
 43526:      * file (at different sizes), we should ensure that they can share a
 43526:      * single cached copy of the font tables. To do this, we implement table
 58248:      * access and sharing on the fontEntry rather than the font itself.
 43526:      *
 43526:      * The default implementation uses GetFontTable() to read font table
 58248:      * data into byte arrays, and wraps them in blobs which are registered in
 58248:      * a hashtable.  The hashtable can then return pre-existing blobs to
 58248:      * harfbuzz.
 43526:      *
 58248:      * Harfbuzz will "destroy" the blobs when it is finished with them.  When
 58248:      * the last blob reference is removed, the FontTableBlobData user data
 58248:      * will remove the blob from the hashtable if still registered.
 43526:      */
 58248: 
 58248:     class FontTableBlobData;
 58248: 
 58248:     /**
 58248:      * FontTableHashEntry manages the entries of hb_blob_ts for two
 58248:      * different situations:
 58248:      *
 58248:      * The common situation is to share font table across fonts with the same
 58248:      * font entry (but different sizes) for use by HarfBuzz.  The hashtable
 58248:      * does not own a strong reference to the blob, but keeps a weak pointer,
 58248:      * managed by FontTableBlobData.  Similarly FontTableBlobData keeps only a
 58248:      * weak pointer to the hashtable, managed by FontTableHashEntry.
 58248:      *
 58248:      * Some font tables are saved here before they would get stripped by OTS
 58248:      * sanitizing.  These are retained for harfbuzz, which does its own
 58248:      * sanitizing.  The hashtable owns a reference, so ownership is simple.
 58248:      */
 58248: 
 58248:     class FontTableHashEntry : public nsUint32HashKey
 58248:     {
 43526:     public:
 58248:         // Declarations for nsTHashtable
 43526: 
 58248:         typedef nsUint32HashKey KeyClass;
 58248:         typedef KeyClass::KeyType KeyType;
 58248:         typedef KeyClass::KeyTypePointer KeyTypePointer;
 58248: 
 58248:         FontTableHashEntry(KeyTypePointer aTag)
105442:             : KeyClass(aTag), mBlob() { }
 58248:         // Copying transfers blob association.
 58248:         FontTableHashEntry(FontTableHashEntry& toCopy)
 58248:             : KeyClass(toCopy), mBlob(toCopy.mBlob)
 58248:         {
106838:             toCopy.mBlob = nullptr;
 43526:         }
 43526: 
 58248:         ~FontTableHashEntry() { Clear(); }
 43526: 
 58248:         // FontTable/Blob API
 58248: 
 58248:         // Transfer (not copy) elements of aTable to a new hb_blob_t and
 58248:         // return ownership to the caller.  A weak reference to the blob is
 58248:         // recorded in the hashtable entry so that others may use the same
 58248:         // table.
 58248:         hb_blob_t *
108991:         ShareTableAndGetBlob(FallibleTArray<uint8_t>& aTable,
 58248:                              nsTHashtable<FontTableHashEntry> *aHashtable);
 58248: 
 58248:         // Transfer (not copy) elements of aTable to a new hb_blob_t that is
 58248:         // owned by the hashtable entry.
108991:         void SaveTable(FallibleTArray<uint8_t>& aTable);
 58248: 
 58248:         // Return a strong reference to the blob.
 58248:         // Callers must hb_blob_destroy the returned blob.
 58248:         hb_blob_t *GetBlob() const;
 58248: 
 58248:         void Clear();
 43526: 
 94199:         static size_t
 94199:         SizeOfEntryExcludingThis(FontTableHashEntry *aEntry,
 94199:                                  nsMallocSizeOfFun   aMallocSizeOf,
 94199:                                  void*               aUserArg);
 94199: 
 43526:     private:
 58248:         static void DeleteFontTableBlobData(void *aBlobData);
 43526:         // not implemented
 58248:         FontTableHashEntry& operator=(FontTableHashEntry& toCopy);
 43526: 
 58248:         FontTableBlobData *mSharedBlobData;
 58248:         hb_blob_t *mBlob;
 43526:     };
 43526: 
 58248:     nsTHashtable<FontTableHashEntry> mFontTableCache;
 43526: 
 42989:     gfxFontEntry(const gfxFontEntry&);
 42989:     gfxFontEntry& operator=(const gfxFontEntry&);
 16418: };
 16418: 
 16418: 
 91870: // used when iterating over all fonts looking for a match for a given character
 91870: struct GlobalFontMatch {
108991:     GlobalFontMatch(const uint32_t aCharacter,
108991:                     int32_t aRunScript,
 91870:                     const gfxFontStyle *aStyle) :
 91870:         mCh(aCharacter), mRunScript(aRunScript), mStyle(aStyle),
 91870:         mMatchRank(0), mCount(0), mCmapsTested(0)
 91870:         {
 91870: 
 31590:         }
 91870: 
108991:     const uint32_t         mCh;          // codepoint to be matched
108991:     int32_t                mRunScript;   // Unicode script for the codepoint
 91870:     const gfxFontStyle*    mStyle;       // style to match
108991:     int32_t                mMatchRank;   // metric indicating closest match
 91870:     nsRefPtr<gfxFontEntry> mBestMatch;   // current best match
108991:     uint32_t               mCount;       // number of fonts matched
108991:     uint32_t               mCmapsTested; // number of cmaps tested
 31590: };
 31590: 
 16418: class gfxFontFamily {
 16418: public:
 40109:     NS_INLINE_DECL_REFCOUNTING(gfxFontFamily)
 16418: 
 16418:     gfxFontFamily(const nsAString& aName) :
 35525:         mName(aName),
 80486:         mOtherFamilyNamesInitialized(false),
 80486:         mHasOtherFamilyNames(false),
 80486:         mFaceNamesInitialized(false),
 80486:         mHasStyles(false),
 80486:         mIsSimpleFamily(false),
 90084:         mIsBadUnderlineFamily(false),
 95682:         mFamilyCharacterMapInitialized(false)
 31590:         { }
 16418: 
 89332:     virtual ~gfxFontFamily() {
 89332:         // clear Family pointers in our faces; the font entries might stay
 89332:         // alive due to cached font objects, but they can no longer refer
 89332:         // to their families.
108991:         uint32_t i = mAvailableFonts.Length();
 89332:         while (i) {
 89332:              gfxFontEntry *fe = mAvailableFonts[--i];
 89332:              if (fe) {
106838:                  fe->SetFamily(nullptr);
 89332:              }
 89332:         }
 89332:     }
 16418: 
 16418:     const nsString& Name() { return mName; }
 16418: 
 31590:     virtual void LocalizedName(nsAString& aLocalizedName);
 79445:     virtual bool HasOtherFamilyNames();
 31590:     
 31590:     nsTArray<nsRefPtr<gfxFontEntry> >& GetFontList() { return mAvailableFonts; }
 31590:     
 31590:     void AddFontEntry(nsRefPtr<gfxFontEntry> aFontEntry) {
 68647:         // bug 589682 - set the IgnoreGDEF flag on entries for Italic faces
 68647:         // of Times New Roman, because of buggy table in those fonts
 68647:         if (aFontEntry->IsItalic() && !aFontEntry->IsUserFont() &&
 68647:             Name().EqualsLiteral("Times New Roman"))
 68647:         {
 80486:             aFontEntry->mIgnoreGDEF = true;
 68647:         }
 31590:         mAvailableFonts.AppendElement(aFontEntry);
 61357:         aFontEntry->SetFamily(this);
 31590:     }
 31590: 
 31590:     // note that the styles for this family have been added
 79445:     void SetHasStyles(bool aHasStyles) { mHasStyles = aHasStyles; }
 31590: 
 19962:     // choose a specific face to match a style using CSS font matching
 39307:     // rules (weight matching occurs here).  may return a face that doesn't
 39307:     // precisely match (e.g. normal face when no italic face exists).
 39307:     // aNeedsSyntheticBold is set to true when synthetic bolding is
 39307:     // needed, false otherwise
 19962:     gfxFontEntry *FindFontForStyle(const gfxFontStyle& aFontStyle, 
 79445:                                    bool& aNeedsSyntheticBold);
 16418: 
 91870:     // checks for a matching font within the family
 31590:     // used as part of the font fallback process
 91870:     void FindFontForChar(GlobalFontMatch *aMatchData);
 31590: 
 91871:     // checks all fonts for a matching font within the family
 91871:     void SearchAllFontsForChar(GlobalFontMatch *aMatchData);
 91871: 
 31590:     // read in other family names, if any, and use functor to add each into cache
 37618:     virtual void ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList);
 37618: 
 60116:     // set when other family names have been read in
 60116:     void SetOtherFamilyNamesInitialized() {
 80486:         mOtherFamilyNamesInitialized = true;
 60116:     }
 60116: 
 37618:     // read in other localized family names, fullnames and Postscript names
 37618:     // for all faces and append to lookup tables
 37618:     virtual void ReadFaceNames(gfxPlatformFontList *aPlatformFontList,
 79445:                                bool aNeedFullnamePostscriptNames);
 31590: 
 35525:     // find faces belonging to this family (platform implementations override this;
 35525:     // should be made pure virtual once all subclasses have been updated)
 31590:     virtual void FindStyleVariations() { }
 31590: 
 31590:     // search for a specific face using the Postscript name
 31590:     gfxFontEntry* FindFont(const nsAString& aPostscriptName);
 31590: 
 31590:     // read in cmaps for all the faces
 91871:     void ReadAllCMAPs() {
108991:         uint32_t i, numFonts = mAvailableFonts.Length();
 90084:         for (i = 0; i < numFonts; i++) {
 90084:             gfxFontEntry *fe = mAvailableFonts[i];
 95682:             // don't try to load cmaps for downloadable fonts not yet loaded
 95682:             if (!fe || fe->mIsProxy) {
 90084:                 continue;
 90084:             }
 90084:             fe->ReadCMAP();
 95682:             mFamilyCharacterMap.Union(*(fe->mCharacterMap));
 90084:         }
 95682:         mFamilyCharacterMap.Compact();
 95682:         mFamilyCharacterMapInitialized = true;
 90084:     }
 90084: 
108991:     bool TestCharacterMap(uint32_t aCh) {
 95682:         if (!mFamilyCharacterMapInitialized) {
 91871:             ReadAllCMAPs();
 90084:         }
 95682:         return mFamilyCharacterMap.test(aCh);
 90084:     }
 90084: 
 90084:     void ResetCharacterMap() {
 95682:         mFamilyCharacterMap.reset();
 95682:         mFamilyCharacterMapInitialized = false;
 31590:     }
 31590: 
 35525:     // mark this family as being in the "bad" underline offset blacklist
 35525:     void SetBadUnderlineFamily() {
 80486:         mIsBadUnderlineFamily = true;
 35525:         if (mHasStyles) {
 35525:             SetBadUnderlineFonts();
 35525:         }
 31590:     }
 31590: 
 79445:     bool IsBadUnderlineFamily() const { return mIsBadUnderlineFamily; }
 37599: 
 31590:     // sort available fonts to put preferred (standard) faces towards the end
 31590:     void SortAvailableFonts();
 31590: 
 31590:     // check whether the family fits into the simple 4-face model,
 31590:     // so we can use simplified style-matching;
 31590:     // if so set the mIsSimpleFamily flag (defaults to False before we've checked)
 31590:     void CheckForSimpleFamily();
 31590: 
 94199:     // For memory reporter
 94199:     virtual void SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                      FontListSizes*    aSizes) const;
 94199:     virtual void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                      FontListSizes*    aSizes) const;
 94199: 
 16418: protected:
 31590:     // fills in an array with weights of faces that match style,
 31590:     // returns whether any matching entries found
 79445:     virtual bool FindWeightsForStyle(gfxFontEntry* aFontsForWeights[],
108991:                                        bool anItalic, int16_t aStretch);
 31590: 
 79445:     bool ReadOtherFamilyNamesForFace(gfxPlatformFontList *aPlatformFontList,
108991:                                        FallibleTArray<uint8_t>& aNameTable,
 79445:                                        bool useFullName = false);
 16418: 
 35525:     // set whether this font family is in "bad" underline offset blacklist.
 35525:     void SetBadUnderlineFonts() {
108991:         uint32_t i, numFonts = mAvailableFonts.Length();
 35525:         for (i = 0; i < numFonts; i++) {
 35525:             if (mAvailableFonts[i]) {
 80486:                 mAvailableFonts[i]->mIsBadUnderlineFont = true;
 35525:             }
 35525:         }
 35525:     }
 35525: 
 16418:     nsString mName;
 31590:     nsTArray<nsRefPtr<gfxFontEntry> >  mAvailableFonts;
 95682:     gfxSparseBitSet mFamilyCharacterMap;
 95682:     bool mOtherFamilyNamesInitialized : 1;
 95682:     bool mHasOtherFamilyNames : 1;
 95682:     bool mFaceNamesInitialized : 1;
 95682:     bool mHasStyles : 1;
 95682:     bool mIsSimpleFamily : 1;
 95682:     bool mIsBadUnderlineFamily : 1;
 95682:     bool mFamilyCharacterMapInitialized : 1;
 31590: 
 31590:     enum {
 31590:         // for "simple" families, the faces are stored in mAvailableFonts
 31590:         // with fixed positions:
 31590:         kRegularFaceIndex    = 0,
 31590:         kBoldFaceIndex       = 1,
 31590:         kItalicFaceIndex     = 2,
 31590:         kBoldItalicFaceIndex = 3,
 31590:         // mask values for selecting face with bold and/or italic attributes
 31590:         kBoldMask   = 0x01,
 31590:         kItalicMask = 0x02
 31590:     };
 16418: };
 16418: 
 16418: struct gfxTextRange {
 71910:     enum {
 71910:         // flags for recording the kind of font-matching that was used
 71910:         kFontGroup      = 0x0001,
 71910:         kPrefsFallback  = 0x0002,
 71910:         kSystemFallback = 0x0004
 71910:     };
108991:     gfxTextRange(uint32_t aStart, uint32_t aEnd,
108991:                  gfxFont* aFont, uint8_t aMatchType)
 71910:         : start(aStart),
 71910:           end(aEnd),
 71910:           font(aFont),
 71910:           matchType(aMatchType)
 71910:     { }
108991:     uint32_t Length() const { return end - start; }
108991:     uint32_t start, end;
 71873:     nsRefPtr<gfxFont> font;
108991:     uint8_t matchType;
 16418: };
 16418: 
 16418: 
   323: /**
   323:  * Font cache design:
   323:  * 
 47360:  * The mFonts hashtable contains most fonts, indexed by (gfxFontEntry*, style).
   323:  * It does not add a reference to the fonts it contains.
   323:  * When a font's refcount decreases to zero, instead of deleting it we
   323:  * add it to our expiration tracker.
   323:  * The expiration tracker tracks fonts with zero refcount. After a certain
   323:  * period of time, such fonts expire and are deleted.
   323:  *
   323:  * We're using 3 generations with a ten-second generation interval, so
   323:  * zero-refcount fonts will be deleted 20-30 seconds after their refcount
   323:  * goes to zero, if timer events fire in a timely manner.
 86698:  *
 86698:  * The font cache also handles timed expiration of cached ShapedWords
 86698:  * for "persistent" fonts: it has a repeating timer, and notifies
 86698:  * each cached font to "age" its shaped words. The words will be released
 86698:  * by the fonts if they get aged three times without being re-used in the
 86698:  * meantime.
 86698:  *
 86698:  * Note that the ShapedWord timeout is much larger than the font timeout,
 86698:  * so that in the case of a short-lived font, we'll discard the gfxFont
 86698:  * completely, with all its words, and avoid the cost of aging the words
 86698:  * individually. That only happens with longer-lived fonts.
   323:  */
 93997: struct FontCacheSizes {
 93997:     FontCacheSizes()
 93997:         : mFontInstances(0), mShapedWords(0)
 93997:     { }
 93997: 
 93997:     size_t mFontInstances; // memory used by instances of gfxFont subclasses
 93997:     size_t mShapedWords; // memory used by the per-font shapedWord caches
 93997: };
 93997: 
 87511: class THEBES_API gfxFontCache MOZ_FINAL : public nsExpirationTracker<gfxFont,3> {
   323: public:
 86698:     enum {
 86698:         FONT_TIMEOUT_SECONDS = 10,
 86698:         SHAPED_WORD_TIMEOUT_SECONDS = 60
 86698:     };
 86698: 
 86698:     gfxFontCache();
 86698:     ~gfxFontCache();
     1: 
   323:     /*
   323:      * Get the global gfxFontCache.  You must call Init() before
   323:      * calling this method --- the result will not be null.
   323:      */
   323:     static gfxFontCache* GetCache() {
   323:         return gGlobalCache;
   323:     }
   323: 
   323:     static nsresult Init();
   323:     // It's OK to call this even if Init() has not been called.
   323:     static void Shutdown();
   323: 
   323:     // Look up a font in the cache. Returns an addrefed pointer, or null
   323:     // if there's nothing matching in the cache
 47360:     already_AddRefed<gfxFont> Lookup(const gfxFontEntry *aFontEntry,
 86698:                                      const gfxFontStyle *aStyle);
   323:     // We created a new font (presumably because Lookup returned null);
   323:     // put it in the cache. The font's refcount should be nonzero. It is
   323:     // allowable to add a new font even if there is one already in the
   323:     // cache with the same key; we'll forget about the old one.
   323:     void AddNew(gfxFont *aFont);
   323: 
   323:     // The font's refcount has gone to zero; give ownership of it to
   323:     // the cache. We delete it if it's not acquired again after a certain
   323:     // amount of time.
   323:     void NotifyReleased(gfxFont *aFont);
   323: 
   323:     // This gets called when the timeout has expired on a zero-refcount
   323:     // font; we just delete it.
   323:     virtual void NotifyExpired(gfxFont *aFont);
   323: 
 43347:     // Cleans out the hashtable and removes expired fonts waiting for cleanup.
 43347:     // Other gfxFont objects may be still in use but they will be pushed
 43347:     // into the expiration queues and removed.
 43347:     void Flush() {
 43347:         mFonts.Clear();
 43347:         AgeAllGenerations();
 43347:     }
 43347: 
 87228:     void FlushShapedWordCaches() {
106838:         mFonts.EnumerateEntries(ClearCachedWordsForFont, nullptr);
 87228:     }
 87228: 
 93997:     void SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                              FontCacheSizes*   aSizes) const;
 93997:     void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                              FontCacheSizes*   aSizes) const;
 93997: 
   323: protected:
101898:     class MemoryReporter MOZ_FINAL
 93997:         : public nsIMemoryMultiReporter
 93997:     {
 93997:     public:
 93997:         NS_DECL_ISUPPORTS
 93997:         NS_DECL_NSIMEMORYMULTIREPORTER
 93997:     };
 93997: 
   323:     void DestroyFont(gfxFont *aFont);
   323: 
   323:     static gfxFontCache *gGlobalCache;
   323: 
   323:     struct Key {
 47360:         const gfxFontEntry* mFontEntry;
   323:         const gfxFontStyle* mStyle;
 47360:         Key(const gfxFontEntry* aFontEntry, const gfxFontStyle* aStyle)
 47360:             : mFontEntry(aFontEntry), mStyle(aStyle) {}
   323:     };
   323: 
   323:     class HashEntry : public PLDHashEntryHdr {
   323:     public:
   323:         typedef const Key& KeyType;
   323:         typedef const Key* KeyTypePointer;
   323: 
   323:         // When constructing a new entry in the hashtable, we'll leave this
   323:         // blank. The caller of Put() will fill this in.
106838:         HashEntry(KeyTypePointer aStr) : mFont(nullptr) { }
   323:         HashEntry(const HashEntry& toCopy) : mFont(toCopy.mFont) { }
   323:         ~HashEntry() { }
   323: 
 79445:         bool KeyEquals(const KeyTypePointer aKey) const;
   323:         static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
   323:         static PLDHashNumber HashKey(const KeyTypePointer aKey) {
 92143:             return mozilla::HashGeneric(aKey->mStyle->Hash(), aKey->mFontEntry);
   323:         }
 80486:         enum { ALLOW_MEMMOVE = true };
   323: 
   323:         gfxFont* mFont;
   323:     };
   323: 
 93997:     static size_t SizeOfFontEntryExcludingThis(HashEntry*        aHashEntry,
 93997:                                                nsMallocSizeOfFun aMallocSizeOf,
 93997:                                                void*             aUserArg);
 93997: 
   323:     nsTHashtable<HashEntry> mFonts;
 86698: 
 87228:     static PLDHashOperator ClearCachedWordsForFont(HashEntry* aHashEntry, void*);
 86698:     static PLDHashOperator AgeCachedWordsForFont(HashEntry* aHashEntry, void*);
 86698:     static void WordCacheExpirationTimerCallback(nsITimer* aTimer, void* aCache);
 86698:     nsCOMPtr<nsITimer>      mWordCacheExpirationTimer;
   323: };
     1: 
 86691: class THEBES_API gfxTextRunFactory {
 86691:     NS_INLINE_DECL_REFCOUNTING(gfxTextRunFactory)
 86691: 
 86691: public:
 86691:     // Flags in the mask 0xFFFF0000 are reserved for textrun clients
 86691:     // Flags in the mask 0x0000F000 are reserved for per-platform fonts
 86691:     // Flags in the mask 0x00000FFF are set by the textrun creator.
 86691:     enum {
 86691:         CACHE_TEXT_FLAGS    = 0xF0000000,
 86691:         USER_TEXT_FLAGS     = 0x0FFF0000,
 86691:         PLATFORM_TEXT_FLAGS = 0x0000F000,
 86691:         TEXTRUN_TEXT_FLAGS  = 0x00000FFF,
 86691:         SETTABLE_FLAGS      = CACHE_TEXT_FLAGS | USER_TEXT_FLAGS,
 86691: 
 86691:         /**
 86691:          * When set, the text string pointer used to create the text run
 86691:          * is guaranteed to be available during the lifetime of the text run.
 86691:          */
 86691:         TEXT_IS_PERSISTENT           = 0x0001,
 86691:         /**
 86691:          * When set, the text is known to be all-ASCII (< 128).
 86691:          */
 86691:         TEXT_IS_ASCII                = 0x0002,
 86691:         /**
 86691:          * When set, the text is RTL.
 86691:          */
 86691:         TEXT_IS_RTL                  = 0x0004,
 86691:         /**
 86691:          * When set, spacing is enabled and the textrun needs to call GetSpacing
 86691:          * on the spacing provider.
 86691:          */
 86691:         TEXT_ENABLE_SPACING          = 0x0008,
 86691:         /**
 86691:          * When set, GetHyphenationBreaks may return true for some character
 86691:          * positions, otherwise it will always return false for all characters.
 86691:          */
 86691:         TEXT_ENABLE_HYPHEN_BREAKS    = 0x0010,
 86691:         /**
 86691:          * When set, the text has no characters above 255 and it is stored
 86691:          * in the textrun in 8-bit format.
 86691:          */
 86691:         TEXT_IS_8BIT                 = 0x0020,
 86691:         /**
 86691:          * When set, the RunMetrics::mBoundingBox field will be initialized
 86691:          * properly based on glyph extents, in particular, glyph extents that
 86691:          * overflow the standard font-box (the box defined by the ascent, descent
 86691:          * and advance width of the glyph). When not set, it may just be the
 86691:          * standard font-box even if glyphs overflow.
 86691:          */
 86691:         TEXT_NEED_BOUNDING_BOX       = 0x0040,
 86691:         /**
 86691:          * When set, optional ligatures are disabled. Ligatures that are
 86691:          * required for legible text should still be enabled.
 86691:          */
 86691:         TEXT_DISABLE_OPTIONAL_LIGATURES = 0x0080,
 86691:         /**
 86691:          * When set, the textrun should favour speed of construction over
 86691:          * quality. This may involve disabling ligatures and/or kerning or
 86691:          * other effects.
 86691:          */
 86691:         TEXT_OPTIMIZE_SPEED          = 0x0100,
 86691:         /**
 86691:          * For internal use by the memory reporter when accounting for
 86691:          * storage used by textruns.
 86691:          * Because the reporter may visit each textrun multiple times while
 86691:          * walking the frame trees and textrun cache, it needs to mark
 86691:          * textruns that have been seen so as to avoid multiple-accounting.
 86691:          */
 86691:         TEXT_RUN_SIZE_ACCOUNTED      = 0x0200,
 86691: 
 86691:         /**
 86691:          * nsTextFrameThebes sets these, but they're defined here rather than
 86691:          * in nsTextFrameUtils.h because ShapedWord creation/caching also needs
 86691:          * to check the _INCOMING flag
 86691:          */
 86691:         TEXT_TRAILING_ARABICCHAR = 0x20000000,
 86691:         /**
 86691:          * When set, the previous character for this textrun was an Arabic
 86691:          * character.  This is used for the context detection necessary for
 86691:          * bidi.numeral implementation.
 86691:          */
 86691:         TEXT_INCOMING_ARABICCHAR = 0x40000000,
 86691: 
 86691:         TEXT_UNUSED_FLAGS = 0x90000000
 86691:     };
 86691: 
 86691:     /**
 86691:      * This record contains all the parameters needed to initialize a textrun.
 86691:      */
 86691:     struct Parameters {
 86691:         // A reference context suggesting where the textrun will be rendered
 86691:         gfxContext   *mContext;
 86691:         // Pointer to arbitrary user data (which should outlive the textrun)
 86691:         void         *mUserData;
 86691:         // A description of which characters have been stripped from the original
 86691:         // DOM string to produce the characters in the textrun. May be null
 86691:         // if that information is not relevant.
 86691:         gfxSkipChars *mSkipChars;
 86691:         // A list of where linebreaks are currently placed in the textrun. May
 86691:         // be null if mInitialBreakCount is zero.
108991:         uint32_t     *mInitialBreaks;
108991:         uint32_t      mInitialBreakCount;
 86691:         // The ratio to use to convert device pixels to application layout units
108991:         uint32_t      mAppUnitsPerDevUnit;
 86691:     };
 86691: 
 86691:     virtual ~gfxTextRunFactory() {}
 86691: };
 86691: 
  6247: /**
  6247:  * This stores glyph bounds information for a particular gfxFont, at
  6247:  * a particular appunits-per-dev-pixel ratio (because the compressed glyph
  6247:  * width array is stored in appunits).
  6247:  * 
  6247:  * We store a hashtable from glyph IDs to float bounding rects. For the
  6247:  * common case where the glyph has no horizontal left bearing, and no
  6247:  * y overflow above the font ascent or below the font descent, and tight
  6247:  * bounding boxes are not required, we avoid storing the glyph ID in the hashtable
  6247:  * and instead consult an array of 16-bit glyph XMost values (in appunits).
  6247:  * This array always has an entry for the font's space glyph --- the width is
  6247:  * assumed to be zero.
  6247:  */
  6247: class THEBES_API gfxGlyphExtents {
  6247: public:
108991:     gfxGlyphExtents(uint32_t aAppUnitsPerDevUnit) :
  6247:         mAppUnitsPerDevUnit(aAppUnitsPerDevUnit) {
  6513:         MOZ_COUNT_CTOR(gfxGlyphExtents);
  6247:         mTightGlyphExtents.Init();
  6247:     }
  6513:     ~gfxGlyphExtents();
  6247: 
  6247:     enum { INVALID_WIDTH = 0xFFFF };
  6247: 
  6247:     // returns INVALID_WIDTH => not a contained glyph
  6247:     // Otherwise the glyph has no before-bearing or vertical bearings,
  6247:     // and the result is its width measured from the baseline origin, in
  6247:     // appunits.
108991:     uint16_t GetContainedGlyphWidthAppUnits(uint32_t aGlyphID) const {
  6513:         return mContainedGlyphWidths.Get(aGlyphID);
  6247:     }
  6247: 
108991:     bool IsGlyphKnown(uint32_t aGlyphID) const {
  6513:         return mContainedGlyphWidths.Get(aGlyphID) != INVALID_WIDTH ||
106838:             mTightGlyphExtents.GetEntry(aGlyphID) != nullptr;
  6247:     }
  6247: 
108991:     bool IsGlyphKnownWithTightExtents(uint32_t aGlyphID) const {
106838:         return mTightGlyphExtents.GetEntry(aGlyphID) != nullptr;
  6247:     }
  6247: 
  6247:     // Get glyph extents; a rectangle relative to the left baseline origin
  9576:     // Returns true on success. Can fail on OOM or when aContext is null
  9576:     // and extents were not (successfully) prefetched.
 79445:     bool GetTightGlyphExtentsAppUnits(gfxFont *aFont, gfxContext *aContext,
108991:             uint32_t aGlyphID, gfxRect *aExtents);
108991: 
108991:     void SetContainedGlyphWidthAppUnits(uint32_t aGlyphID, uint16_t aWidth) {
  6513:         mContainedGlyphWidths.Set(aGlyphID, aWidth);
  6513:     }
108991:     void SetTightGlyphExtents(uint32_t aGlyphID, const gfxRect& aExtentsAppUnits);
108991: 
108991:     uint32_t GetAppUnitsPerDevUnit() { return mAppUnitsPerDevUnit; }
  6247: 
 93997:     size_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 93997:     size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 93997: 
  6247: private:
  6247:     class HashEntry : public nsUint32HashKey {
  6247:     public:
  6247:         // When constructing a new entry in the hashtable, we'll leave this
  6247:         // blank. The caller of Put() will fill this in.
  6247:         HashEntry(KeyTypePointer aPtr) : nsUint32HashKey(aPtr) {}
  6247:         HashEntry(const HashEntry& toCopy) : nsUint32HashKey(toCopy) {
  6247:           x = toCopy.x; y = toCopy.y; width = toCopy.width; height = toCopy.height;
  6247:         }
  6247: 
  6247:         float x, y, width, height;
  6247:     };
  6247: 
  6513:     enum { BLOCK_SIZE_BITS = 7, BLOCK_SIZE = 1 << BLOCK_SIZE_BITS }; // 128-glyph blocks
  6513: 
  6513:     class GlyphWidths {
  6513:     public:
108991:         void Set(uint32_t aIndex, uint16_t aValue);
108991:         uint16_t Get(uint32_t aIndex) const {
108991:             uint32_t block = aIndex >> BLOCK_SIZE_BITS;
  6513:             if (block >= mBlocks.Length())
  6513:                 return INVALID_WIDTH;
115682:             uintptr_t bits = mBlocks[block];
  6513:             if (!bits)
  6513:                 return INVALID_WIDTH;
108991:             uint32_t indexInBlock = aIndex & (BLOCK_SIZE - 1);
  6513:             if (bits & 0x1) {
  6513:                 if (GetGlyphOffset(bits) != indexInBlock)
  6513:                     return INVALID_WIDTH;
  6513:                 return GetWidth(bits);
  6513:             }
108991:             uint16_t *widths = reinterpret_cast<uint16_t *>(bits);
  6513:             return widths[indexInBlock];
  6513:         }
  6513: 
108991:         uint32_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
  6513:         
  6513:         ~GlyphWidths();
  6513: 
  6513:     private:
115682:         static uint32_t GetGlyphOffset(uintptr_t aBits) {
  6513:             NS_ASSERTION(aBits & 0x1, "This is really a pointer...");
  6513:             return (aBits >> 1) & ((1 << BLOCK_SIZE_BITS) - 1);
  6513:         }
115682:         static uint32_t GetWidth(uintptr_t aBits) {
  6513:             NS_ASSERTION(aBits & 0x1, "This is really a pointer...");
  6513:             return aBits >> (1 + BLOCK_SIZE_BITS);
  6513:         }
115682:         static uintptr_t MakeSingle(uint32_t aGlyphOffset, uint16_t aWidth) {
  6513:             return (aWidth << (1 + BLOCK_SIZE_BITS)) + (aGlyphOffset << 1) + 1;
  6513:         }
  6513: 
115682:         nsTArray<uintptr_t> mBlocks;
  6513:     };
  6513: 
  6513:     GlyphWidths             mContainedGlyphWidths;
  6247:     nsTHashtable<HashEntry> mTightGlyphExtents;
108991:     uint32_t                mAppUnitsPerDevUnit;
  6247: };
  6247: 
 39206: /**
 39206:  * gfxFontShaper
 39206:  *
 39206:  * This class implements text shaping (character to glyph mapping and
 39206:  * glyph layout). There is a gfxFontShaper subclass for each text layout
 39206:  * technology (uniscribe, core text, harfbuzz,....) we support.
 39206:  *
 39206:  * The shaper is responsible for setting up glyph data in gfxTextRuns.
 39206:  *
 39206:  * A generic, platform-independent shaper relies only on the standard
 39206:  * gfxFont interface and can work with any concrete subclass of gfxFont.
 39206:  *
 39206:  * Platform-specific implementations designed to interface to platform
 39206:  * shaping APIs such as Uniscribe or CoreText may rely on features of a
 39206:  * specific font subclass to access native font references
 39206:  * (such as CTFont, HFONT, DWriteFont, etc).
 39206:  */
 39206: 
 39206: class gfxFontShaper {
 39206: public:
 39206:     gfxFontShaper(gfxFont *aFont)
 43527:         : mFont(aFont)
 43527:     {
 43527:         NS_ASSERTION(aFont, "shaper requires a valid font!");
 43527:     }
 39206: 
 39206:     virtual ~gfxFontShaper() { }
 39206: 
 86691:     virtual bool ShapeWord(gfxContext *aContext,
 86691:                            gfxShapedWord *aShapedWord,
 86691:                            const PRUnichar *aText) = 0;
 39206: 
 43527:     gfxFont *GetFont() const { return mFont; }
 43527: 
 96989:     // returns true if features exist in output, false otherwise
 96989:     static bool
 96989:     MergeFontFeatures(const nsTArray<gfxFontFeature>& aStyleRuleFeatures,
 96989:                       const nsTArray<gfxFontFeature>& aFontFeatures,
 96989:                       bool aDisableLigatures,
108991:                       nsDataHashtable<nsUint32HashKey,uint32_t>& aMergedFeatures);
 96989: 
 39206: protected:
 39206:     // the font this shaper is working with
 39206:     gfxFont * mFont;
 39206: };
 39206: 
     1: /* a SPECIFIC single font family */
     1: class THEBES_API gfxFont {
   323: public:
   323:     nsrefcnt AddRef(void) {
108991:         NS_PRECONDITION(int32_t(mRefCnt) >= 0, "illegal refcnt");
 10514:         if (mExpirationState.IsTracked()) {
 10514:             gfxFontCache::GetCache()->RemoveObject(this);
 10514:         }
   323:         ++mRefCnt;
   323:         NS_LOG_ADDREF(this, mRefCnt, "gfxFont", sizeof(*this));
   323:         return mRefCnt;
   323:     }
   323:     nsrefcnt Release(void) {
   323:         NS_PRECONDITION(0 != mRefCnt, "dup release");
   323:         --mRefCnt;
   323:         NS_LOG_RELEASE(this, mRefCnt, "gfxFont");
   323:         if (mRefCnt == 0) {
 19479:             NotifyReleased();
 19479:             // |this| may have been deleted.
 19409:             return 0;
   323:         }
   323:         return mRefCnt;
   323:     }
   323: 
108991:     int32_t GetRefCount() { return mRefCnt; }
   323: 
 39447:     // options to specify the kind of AA to be used when creating a font
 39447:     typedef enum {
 39447:         kAntialiasDefault,
 39447:         kAntialiasNone,
 39447:         kAntialiasGrayscale,
 39447:         kAntialiasSubpixel
 39447:     } AntialiasOption;
 39447: 
 88295:     // Options for how the text should be drawn
 88295:     typedef enum {
 88295:         // GLYPH_FILL and GLYPH_STROKE draw into the current context
 88295:         //  and may be used together with bitwise OR.
 88295:         GLYPH_FILL = 1,
 88295:         // Note: using GLYPH_STROKE will destroy the current path.
 88295:         GLYPH_STROKE = 2,
 88295:         // Appends glyphs to the current path. Can NOT be used with
 88295:         //  GLYPH_FILL or GLYPH_STROKE.
 88295:         GLYPH_PATH = 4
 88295:     } DrawMode;
 88295: 
   323: protected:
   323:     nsAutoRefCnt mRefCnt;
 84651:     cairo_scaled_font_t *mScaledFont;
     1: 
 19479:     void NotifyReleased() {
 19479:         gfxFontCache *cache = gfxFontCache::GetCache();
 19479:         if (cache) {
 19479:             // Don't delete just yet; return the object to the cache for
 19479:             // possibly recycling within some time limit
 19479:             cache->NotifyReleased(this);
 19479:         } else {
 19479:             // The cache may have already been shut down.
 19479:             delete this;
 19479:         }
 19479:     }
 19479: 
 39447:     gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle,
 84651:             AntialiasOption anAAOption = kAntialiasDefault,
106838:             cairo_scaled_font_t *aScaledFont = nullptr);
 19479: 
 19409: public:
  6247:     virtual ~gfxFont();
     1: 
 79445:     bool Valid() const {
 37211:         return mIsValid;
 37211:     }
 37211: 
 25417:     // options for the kind of bounding box to return from measurement
 25417:     typedef enum {
 25417:         LOOSE_INK_EXTENTS,
 25417:             // A box that encloses all the painted pixels, and may
 25417:             // include sidebearings and/or additional ascent/descent
 25417:             // within the glyph cell even if the ink is smaller.
 25417:         TIGHT_INK_EXTENTS,
 25417:             // A box that tightly encloses all the painted pixels
 25417:             // (although actually on Windows, at least, it may be
 25417:             // slightly larger than strictly necessary because
 25417:             // we can't get precise extents with ClearType).
 25417:         TIGHT_HINTED_OUTLINE_EXTENTS
 25417:             // A box that tightly encloses the glyph outline,
 25417:             // ignoring possible antialiasing pixels that extend
 25417:             // beyond this.
 25417:             // NOTE: The default implementation of gfxFont::Measure(),
 25417:             // which works with the glyph extents cache, does not
 25417:             // differentiate between this and TIGHT_INK_EXTENTS.
 25417:             // Whether the distinction is important depends on the
 25417:             // antialiasing behavior of the platform; currently the
 25417:             // distinction is only implemented in the gfxWindowsFont
 25417:             // subclass, because of ClearType's tendency to paint
 25417:             // outside the hinted outline.
 25417:             // Also NOTE: it is relatively expensive to request this,
 25417:             // as it does not use cached glyph extents in the font.
 25417:     } BoundingBoxType;
 25417: 
 16418:     const nsString& GetName() const { return mFontEntry->Name(); }
   323:     const gfxFontStyle *GetStyle() const { return &mStyle; }
     1: 
121665:     virtual cairo_scaled_font_t* GetCairoScaledFont() { return mScaledFont; }
 87057: 
 39447:     virtual gfxFont* CopyWithAntialiasOption(AntialiasOption anAAOption) {
 39447:         // platforms where this actually matters should override
106838:         return nullptr;
 39447:     }
 39447: 
 61083:     virtual gfxFloat GetAdjustedSize() {
 43527:         return mAdjustedSize > 0.0 ? mAdjustedSize : mStyle.size;
 43527:     }
 43527: 
 43527:     float FUnitsToDevUnitsFactor() const {
 43527:         // check this was set up during font initialization
 43527:         NS_ASSERTION(mFUnitsConvFactor > 0.0f, "mFUnitsConvFactor not valid");
 43527:         return mFUnitsConvFactor;
 43527:     }
 43527: 
 43527:     // check whether this is an sfnt we can potentially use with harfbuzz
 79445:     bool FontCanSupportHarfBuzz() {
 43527:         return mFontEntry->HasCmapTable();
 43527:     }
 43527: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     // check whether this is an sfnt we can potentially use with Graphite
 84392:     bool FontCanSupportGraphite() {
 84392:         return mFontEntry->HasGraphiteTables();
 84392:     }
 84392: #endif
 84392: 
 43526:     // Access to raw font table data (needed for Harfbuzz):
 43526:     // returns a pointer to data owned by the fontEntry or the OS,
 43526:     // which will remain valid until released.
 43526:     //
 58944:     // Default implementations forward to the font entry,
 58944:     // and maintain a shared table.
 58944:     //
 58944:     // Subclasses should override this if they can provide more efficient
 58944:     // access than getting tables with mFontEntry->GetFontTable() and sharing
 58944:     // them via the entry.
 58944:     //
 58944:     // Get pointer to a specific font table, or NULL if
 43526:     // the table doesn't exist in the font
108991:     virtual hb_blob_t *GetFontTable(uint32_t aTag);
 43526: 
 58948:     // Subclasses may choose to look up glyph ids for characters.
 58948:     // If they do not override this, gfxHarfBuzzShaper will fetch the cmap
 58948:     // table and use that.
 79445:     virtual bool ProvidesGetGlyph() const {
 80486:         return false;
 58948:     }
 58948:     // Map unicode character to glyph ID.
 80486:     // Only used if ProvidesGetGlyph() returns true.
108991:     virtual uint32_t GetGlyph(uint32_t unicode, uint32_t variation_selector) {
 58948:         return 0;
 58948:     }
 58948: 
 61073:     // subclasses may provide (possibly hinted) glyph widths (in font units);
 43527:     // if they do not override this, harfbuzz will use unhinted widths
 43527:     // derived from the font tables
 79445:     virtual bool ProvidesGlyphWidths() {
 80486:         return false;
 43527:     }
 43527: 
 58946:     // The return value is interpreted as a horizontal advance in 16.16 fixed
 58946:     // point format.
108991:     virtual int32_t GetGlyphWidth(gfxContext *aCtx, uint16_t aGID) {
 43527:         return -1;
 43527:     }
 43527: 
 93509:     // Return Azure GlyphRenderingOptions for drawing this font.
 93509:     virtual mozilla::TemporaryRef<mozilla::gfx::GlyphRenderingOptions>
106838:       GetGlyphRenderingOptions() { return nullptr; }
 93509: 
108991:     gfxFloat SynthesizeSpaceWidth(uint32_t aCh);
 69197: 
     1:     // Font metrics
     1:     struct Metrics {
     1:         gfxFloat xHeight;
     1:         gfxFloat superscriptOffset;
     1:         gfxFloat subscriptOffset;
     1:         gfxFloat strikeoutSize;
     1:         gfxFloat strikeoutOffset;
     1:         gfxFloat underlineSize;
     1:         gfxFloat underlineOffset;
     1: 
     1:         gfxFloat internalLeading;
     1:         gfxFloat externalLeading;
     1: 
     1:         gfxFloat emHeight;
     1:         gfxFloat emAscent;
     1:         gfxFloat emDescent;
     1:         gfxFloat maxHeight;
     1:         gfxFloat maxAscent;
     1:         gfxFloat maxDescent;
     1:         gfxFloat maxAdvance;
     1: 
     1:         gfxFloat aveCharWidth;
     1:         gfxFloat spaceWidth;
 15955:         gfxFloat zeroOrAveCharWidth;  // width of '0', or if there is
 15955:                                       // no '0' glyph in this font,
 15955:                                       // equal to .aveCharWidth
     1:     };
     1:     virtual const gfxFont::Metrics& GetMetrics() = 0;
     1: 
     1:     /**
     1:      * We let layout specify spacing on either side of any
     1:      * character. We need to specify both before and after
     1:      * spacing so that substring measurement can do the right things.
     1:      * These values are in appunits. They're always an integral number of
     1:      * appunits, but we specify them in floats in case very large spacing
     1:      * values are required.
     1:      */
     1:     struct Spacing {
     1:         gfxFloat mBefore;
     1:         gfxFloat mAfter;
     1:     };
     1:     /**
     1:      * Metrics for a particular string
     1:      */
 16581:     struct THEBES_API RunMetrics {
     1:         RunMetrics() {
     1:             mAdvanceWidth = mAscent = mDescent = 0.0;
     1:             mBoundingBox = gfxRect(0,0,0,0);
     1:         }
     1: 
 79445:         void CombineWith(const RunMetrics& aOther, bool aOtherIsOnLeft);
     1: 
     1:         // can be negative (partly due to negative spacing).
     1:         // Advance widths should be additive: the advance width of the
     1:         // (offset1, length1) plus the advance width of (offset1 + length1,
     1:         // length2) should be the advance width of (offset1, length1 + length2)
     1:         gfxFloat mAdvanceWidth;
     1:         
     1:         // For zero-width substrings, these must be zero!
     1:         gfxFloat mAscent;  // always non-negative
     1:         gfxFloat mDescent; // always non-negative
     1:         
     1:         // Bounding box that is guaranteed to include everything drawn.
 25417:         // If a tight boundingBox was requested when these metrics were
     1:         // generated, this will tightly wrap the glyphs, otherwise it is
     1:         // "loose" and may be larger than the true bounding box.
     1:         // Coordinates are relative to the baseline left origin, so typically
     1:         // mBoundingBox.y == -mAscent
     1:         gfxRect  mBoundingBox;
     1:     };
     1: 
     1:     /**
     1:      * Draw a series of glyphs to aContext. The direction of aTextRun must
     1:      * be honoured.
     1:      * @param aStart the first character to draw
     1:      * @param aEnd draw characters up to here
     1:      * @param aBaselineOrigin the baseline origin; the left end of the baseline
     1:      * for LTR textruns, the right end of the baseline for RTL textruns. On return,
     1:      * this should be updated to the other end of the baseline. In application
     1:      * units, really!
     1:      * @param aSpacing spacing to insert before and after characters (for RTL
     1:      * glyphs, before-spacing is inserted to the right of characters). There
     1:      * are aEnd - aStart elements in this array, unless it's null to indicate
     1:      * that there is no spacing.
 88295:      * @param aDrawMode specifies whether the fill or stroke of the glyph should be
 88295:      * drawn, or if it should be drawn into the current path
111295:      * @param aObjectPaint information about how to construct the fill and
111295:      * stroke pattern. Can be NULL if we are not stroking the text, which
111295:      * indicates that the current source from aContext should be used for filling
     1:      * 
     1:      * Callers guarantee:
     1:      * -- aStart and aEnd are aligned to cluster and ligature boundaries
     1:      * -- all glyphs use this font
     1:      * 
     1:      * The default implementation builds a cairo glyph array and
     1:      * calls cairo_show_glyphs or cairo_glyph_path.
     1:      */
108991:     virtual void Draw(gfxTextRun *aTextRun, uint32_t aStart, uint32_t aEnd,
 88295:                       gfxContext *aContext, DrawMode aDrawMode, gfxPoint *aBaselineOrigin,
111295:                       Spacing *aSpacing, gfxTextObjectPaint *aObjectPaint);
 89450: 
     1:     /**
     1:      * Measure a run of characters. See gfxTextRun::Metrics.
     1:      * @param aTight if false, then return the union of the glyph extents
     1:      * with the font-box for the characters (the rectangle with x=0,width=
     1:      * the advance width for the character run,y=-(font ascent), and height=
     1:      * font ascent + font descent). Otherwise, we must return as tight as possible
     1:      * an approximation to the area actually painted by glyphs.
  9576:      * @param aContextForTightBoundingBox when aTight is true, this must
  9576:      * be non-null.
     1:      * @param aSpacing spacing to insert before and after glyphs. The bounding box
     1:      * need not include the spacing itself, but the spacing affects the glyph
     1:      * positions. null if there is no spacing.
     1:      * 
     1:      * Callers guarantee:
     1:      * -- aStart and aEnd are aligned to cluster and ligature boundaries
     1:      * -- all glyphs use this font
     1:      * 
     1:      * The default implementation just uses font metrics and aTextRun's
     1:      * advances, and assumes no characters fall outside the font box. In
     1:      * general this is insufficient, because that assumption is not always true.
     1:      */
     1:     virtual RunMetrics Measure(gfxTextRun *aTextRun,
108991:                                uint32_t aStart, uint32_t aEnd,
 25417:                                BoundingBoxType aBoundingBoxType,
  6247:                                gfxContext *aContextForTightBoundingBox,
     1:                                Spacing *aSpacing);
     1:     /**
     1:      * Line breaks have been changed at the beginning and/or end of a substring
     1:      * of the text. Reshaping may be required; glyph updating is permitted.
     1:      * @return true if anything was changed, false otherwise
     1:      */
 79445:     bool NotifyLineBreaksChanged(gfxTextRun *aTextRun,
108991:                                    uint32_t aStart, uint32_t aLength)
 80486:     { return false; }
     1: 
   323:     // Expiration tracking
   323:     nsExpirationState *GetExpirationState() { return &mExpirationState; }
   323: 
  1295:     // Get the glyphID of a space
108991:     virtual uint32_t GetSpaceGlyph() = 0;
108991: 
108991:     gfxGlyphExtents *GetOrCreateGlyphExtents(uint32_t aAppUnitsPerDevUnit);
  6247: 
  6247:     // You need to call SetupCairoFont on the aCR just before calling this
108991:     virtual void SetupGlyphExtents(gfxContext *aContext, uint32_t aGlyphID,
 79445:                                    bool aNeedTight, gfxGlyphExtents *aExtents);
  6247: 
  6247:     // This is called by the default Draw() implementation above.
 79445:     virtual bool SetupCairoFont(gfxContext *aContext) = 0;
  6247: 
 99360:     virtual bool AllowSubpixelAA() { return true; }
 99360: 
 79445:     bool IsSyntheticBold() { return mApplySyntheticBold; }
 77795: 
 77795:     // Amount by which synthetic bold "fattens" the glyphs: 1/16 of the em-size
 77795:     gfxFloat GetSyntheticBoldOffset() {
 77795:         return GetAdjustedSize() * (1.0 / 16.0);
 77795:     }
 13339: 
 16418:     gfxFontEntry *GetFontEntry() { return mFontEntry.get(); }
108991:     bool HasCharacter(uint32_t ch) {
 16418:         if (!mIsValid)
 80486:             return false;
 16418:         return mFontEntry->HasCharacter(ch); 
 16418:     }
 16418: 
108991:     uint16_t GetUVSGlyph(uint32_t aCh, uint32_t aVS) {
 42989:         if (!mIsValid) {
 42989:             return 0;
 42989:         }
 42989:         return mFontEntry->GetUVSGlyph(aCh, aVS); 
 42989:     }
 42989: 
 60118:     // call the (virtual) InitTextRun method to do glyph generation/shaping,
 60118:     // limiting the length of text passed by processing the run in multiple
 60118:     // segments if necessary
 86691:     template<typename T>
 79445:     bool SplitAndInitTextRun(gfxContext *aContext,
 39206:                              gfxTextRun *aTextRun,
 86691:                              const T *aString,
108991:                              uint32_t aRunStart,
108991:                              uint32_t aRunLength,
108991:                              int32_t aRunScript);
 37211: 
 86691:     // Get a ShapedWord representing the given text (either 8- or 16-bit)
 86691:     // for use in setting up a gfxTextRun.
 86691:     template<typename T>
 86691:     gfxShapedWord* GetShapedWord(gfxContext *aContext,
 86691:                                  const T *aText,
108991:                                  uint32_t aLength,
108991:                                  uint32_t aHash,
108991:                                  int32_t aRunScript,
108991:                                  int32_t aAppUnitsPerDevUnit,
108991:                                  uint32_t aFlags);
 86691: 
 86691:     // Ensure the ShapedWord cache is initialized. This MUST be called before
 86691:     // any attempt to use GetShapedWord().
 86691:     void InitWordCache() {
 86691:         if (!mWordCache.IsInitialized()) {
 86691:             mWordCache.Init();
 86691:         }
 86691:     }
 86691: 
 86698:     // Called by the gfxFontCache timer to increment the age of all the words,
 86698:     // so that they'll expire after a sufficient period of non-use
 86698:     void AgeCachedWords() {
 86698:         if (mWordCache.IsInitialized()) {
 86698:             (void)mWordCache.EnumerateEntries(AgeCacheEntry, this);
 86698:         }
 86698:     }
 86698: 
 87228:     // Discard all cached word records; called on memory-pressure notification.
 87228:     void ClearCachedWords() {
 87228:         if (mWordCache.IsInitialized()) {
 87228:             mWordCache.Clear();
 87228:         }
 87228:     }
 87228: 
 93997:     virtual void SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                                      FontCacheSizes*   aSizes) const;
 93997:     virtual void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                                      FontCacheSizes*   aSizes) const;
 93997: 
 95169:     typedef enum {
 95169:         FONT_TYPE_DWRITE,
 95169:         FONT_TYPE_GDI,
 95169:         FONT_TYPE_FT2,
 95169:         FONT_TYPE_MAC,
106609:         FONT_TYPE_OS2,
106609:         FONT_TYPE_CAIRO
 95169:     } FontType;
 95169: 
 95169:     virtual FontType GetType() const = 0;
 95169: 
114778:     virtual mozilla::TemporaryRef<mozilla::gfx::ScaledFont> GetScaledFont(mozilla::gfx::DrawTarget *aTarget)
114778:     { return gfxPlatform::GetPlatform()->GetScaledFontForFont(aTarget, this); }
114778: 
     1: protected:
 86691:     // Call the appropriate shaper to generate glyphs for aText and store
 86691:     // them into aShapedWord.
 86691:     // The length of the text is aShapedWord->Length().
 86691:     virtual bool ShapeWord(gfxContext *aContext,
 86691:                            gfxShapedWord *aShapedWord,
 86691:                            const PRUnichar *aText,
 86691:                            bool aPreferPlatformShaping = false);
 86691: 
 16418:     nsRefPtr<gfxFontEntry> mFontEntry;
 16418: 
 86691:     struct CacheHashKey {
 86691:         union {
108991:             const uint8_t   *mSingle;
 86691:             const PRUnichar *mDouble;
 86691:         }                mText;
108991:         uint32_t         mLength;
108991:         uint32_t         mFlags;
108991:         int32_t          mScript;
108991:         int32_t          mAppUnitsPerDevUnit;
 86691:         PLDHashNumber    mHashKey;
 86691:         bool             mTextIs8Bit;
 86691: 
108991:         CacheHashKey(const uint8_t *aText, uint32_t aLength,
108991:                      uint32_t aStringHash,
108991:                      int32_t aScriptCode, int32_t aAppUnitsPerDevUnit,
108991:                      uint32_t aFlags)
 86691:             : mLength(aLength),
 86691:               mFlags(aFlags),
 86691:               mScript(aScriptCode),
 86691:               mAppUnitsPerDevUnit(aAppUnitsPerDevUnit),
 86691:               mHashKey(aStringHash + aScriptCode +
 86691:                   aAppUnitsPerDevUnit * 0x100 + aFlags * 0x10000),
 86691:               mTextIs8Bit(true)
 86691:         {
 86691:             NS_ASSERTION(aFlags & gfxTextRunFactory::TEXT_IS_8BIT,
 86691:                          "8-bit flag should have been set");
 86691:             mText.mSingle = aText;
 86691:         }
 86691: 
108991:         CacheHashKey(const PRUnichar *aText, uint32_t aLength,
108991:                      uint32_t aStringHash,
108991:                      int32_t aScriptCode, int32_t aAppUnitsPerDevUnit,
108991:                      uint32_t aFlags)
 86691:             : mLength(aLength),
 86691:               mFlags(aFlags),
 86691:               mScript(aScriptCode),
 86691:               mAppUnitsPerDevUnit(aAppUnitsPerDevUnit),
 86691:               mHashKey(aStringHash + aScriptCode +
 86691:                   aAppUnitsPerDevUnit * 0x100 + aFlags * 0x10000),
 86691:               mTextIs8Bit(false)
 86691:         {
 86691:             // We can NOT assert that TEXT_IS_8BIT is false in aFlags here,
 86691:             // because this might be an 8bit-only word from a 16-bit textrun,
 86691:             // in which case the text we're passed is still in 16-bit form,
 86691:             // and we'll have to use an 8-to-16bit comparison in KeyEquals.
 86691:             mText.mDouble = aText;
 86691:         }
 86691:     };
 86691: 
 86691:     class CacheHashEntry : public PLDHashEntryHdr {
 86691:     public:
 86691:         typedef const CacheHashKey &KeyType;
 86691:         typedef const CacheHashKey *KeyTypePointer;
 86691: 
 86691:         // When constructing a new entry in the hashtable, the caller of Put()
 86691:         // will fill us in.
 86691:         CacheHashEntry(KeyTypePointer aKey) { }
 86691:         CacheHashEntry(const CacheHashEntry& toCopy) { NS_ERROR("Should not be called"); }
 86691:         ~CacheHashEntry() { }
 86691: 
 86691:         bool KeyEquals(const KeyTypePointer aKey) const;
 86691: 
 86691:         static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
 86691: 
 86691:         static PLDHashNumber HashKey(const KeyTypePointer aKey) {
 86691:             return aKey->mHashKey;
 86691:         }
 86691: 
 86691:         enum { ALLOW_MEMMOVE = true };
 86691: 
 86691:         nsAutoPtr<gfxShapedWord> mShapedWord;
 86691:     };
 86691: 
 93997:     static size_t
 93997:     WordCacheEntrySizeOfExcludingThis(CacheHashEntry*   aHashEntry,
 93997:                                       nsMallocSizeOfFun aMallocSizeOf,
 93997:                                       void*             aUserArg);
 93997: 
 86691:     nsTHashtable<CacheHashEntry> mWordCache;
 86691: 
 86698:     static PLDHashOperator AgeCacheEntry(CacheHashEntry *aEntry, void *aUserData);
108991:     static const uint32_t  kShapedWordCacheMaxAge = 3;
 86698: 
 79445:     bool                       mIsValid;
 77795: 
 77795:     // use synthetic bolding for environments where this is not supported
 77795:     // by the platform
 79445:     bool                       mApplySyntheticBold;
 77795: 
   323:     nsExpirationState          mExpirationState;
   323:     gfxFontStyle               mStyle;
  6247:     nsAutoTArray<gfxGlyphExtents*,1> mGlyphExtentsArray;
 11765: 
 43527:     gfxFloat                   mAdjustedSize;
 43527: 
 43527:     float                      mFUnitsConvFactor; // conversion factor from font units to dev units
 43527: 
 39447:     // the AA setting requested for this font - may affect glyph bounds
 39447:     AntialiasOption            mAntialiasOption;
 39447: 
 42207:     // a copy of the font without antialiasing, if needed for separate
 42207:     // measurement by mathml code
 42207:     nsAutoPtr<gfxFont>         mNonAAFont;
 42207: 
 43527:     // we may switch between these shapers on the fly, based on the script
 43527:     // of the text run being shaped
 43527:     nsAutoPtr<gfxFontShaper>   mPlatformShaper;
 43527:     nsAutoPtr<gfxFontShaper>   mHarfBuzzShaper;
 84392: #ifdef MOZ_GRAPHITE
 84392:     nsAutoPtr<gfxFontShaper>   mGraphiteShaper;
 84392: #endif
114778:     mozilla::RefPtr<mozilla::gfx::ScaledFont> mAzureScaledFont;
 43527: 
 43527:     // Create a default platform text shaper for this font.
 43527:     // (TODO: This should become pure virtual once all font backends have
 43527:     // been updated.)
 43527:     virtual void CreatePlatformShaper() { }
 39206: 
 47309:     // Helper for subclasses that want to initialize standard metrics from the
 47309:     // tables of sfnt (TrueType/OpenType) fonts.
 47309:     // This will use mFUnitsConvFactor if it is already set, else compute it
 47309:     // from mAdjustedSize and the unitsPerEm in the font's 'head' table.
 47309:     // Returns TRUE and sets mIsValid=TRUE if successful;
 47309:     // Returns TRUE but leaves mIsValid=FALSE if the font seems to be broken.
 47309:     // Returns FALSE if the font does not appear to be an sfnt at all,
 47309:     // and should be handled (if possible) using other APIs.
 79445:     bool InitMetricsFromSfntTables(Metrics& aMetrics);
 47309: 
 47309:     // Helper to calculate various derived metrics from the results of
 47309:     // InitMetricsFromSfntTables or equivalent platform code
 47309:     void CalculateDerivedMetrics(Metrics& aMetrics);
 47309: 
 11765:     // some fonts have bad metrics, this method sanitize them.
 12989:     // if this font has bad underline offset, aIsBadUnderlineFont should be true.
 79445:     void SanitizeMetrics(gfxFont::Metrics *aMetrics, bool aIsBadUnderlineFont);
 86696: 
111292:     bool RenderSVGGlyph(gfxContext *aContext, gfxPoint aPoint, DrawMode aDrawMode,
111295:                         uint32_t aGlyphId, gfxTextObjectPaint *aObjectPaint);
111292: 
 86696:     // Bug 674909. When synthetic bolding text by drawing twice, need to
 86696:     // render using a pixel offset in device pixels, otherwise text
 86696:     // doesn't appear bolded, it appears as if a bad text shadow exists
 86696:     // when a non-identity transform exists.  Use an offset factor so that
 86696:     // the second draw occurs at a constant offset in device pixels.
 86696:     // This helper calculates the scale factor we need to apply to the
 86696:     // synthetic-bold offset.
 86696:     static double CalcXScale(gfxContext *aContext);
     1: };
     1: 
 47309: // proportion of ascent used for x-height, if unable to read value from font
 47309: #define DEFAULT_XHEIGHT_FACTOR 0.56f
 47309: 
 86691: /*
 86691:  * gfxShapedWord stores a list of zero or more glyphs for each character. For each
 86691:  * glyph we store the glyph ID, the advance, and possibly an xoffset and yoffset.
 86691:  * The idea is that a string is rendered by a loop that draws each glyph
 86691:  * at its designated offset from the current point, then advances the current
 86691:  * point by the glyph's advance in the direction of the textrun (LTR or RTL).
 86691:  * Each glyph advance is always rounded to the nearest appunit; this ensures
 86691:  * consistent results when dividing the text in a textrun into multiple text
 86691:  * frames (frame boundaries are always aligned to appunits). We optimize
 86691:  * for the case where a character has a single glyph and zero xoffset and yoffset,
 86691:  * and the glyph ID and advance are in a reasonable range so we can pack all
 86691:  * necessary data into 32 bits.
 86691:  *
 86691:  * This glyph data is copied into gfxTextRuns as needed from the cache of
 86691:  * ShapedWords associated with each gfxFont instance.
 86691:  *
 86691:  * gfxTextRun methods that measure or draw substrings will associate all the
 86691:  * glyphs in a cluster with the first character of the cluster; if that character
 86691:  * is in the substring, the glyphs will be measured or drawn, otherwise they
 86691:  * won't.
 86691:  */
 86691: class gfxShapedWord
 86691: {
     1: public:
108991:     static const uint32_t kMaxLength = 0x7fff;
 86691: 
 86691:     // Create a ShapedWord that can hold glyphs for aLength characters,
 86691:     // with mCharacterGlyphs sized appropriately.
 86691:     //
 86691:     // Returns null on allocation failure (does NOT use infallible alloc)
 86691:     // so caller must check for success.
 86691:     //
 86691:     // This does NOT perform shaping, so the returned word contains no
 86691:     // glyph data; the caller must call gfxFont::Shape() with appropriate
 86691:     // parameters to set up the glyphs.
108991:     static gfxShapedWord* Create(const uint8_t *aText, uint32_t aLength,
108991:                                  int32_t aRunScript,
108991:                                  int32_t aAppUnitsPerDevUnit,
108991:                                  uint32_t aFlags) {
 86691:         NS_ASSERTION(aLength <= kMaxLength, "excessive length for gfxShapedWord!");
 86691: 
 86691:         // Compute size needed including the mCharacterGlyphs array
 86691:         // and a copy of the original text
108991:         uint32_t size =
 86691:             offsetof(gfxShapedWord, mCharacterGlyphs) +
108991:             aLength * (sizeof(CompressedGlyph) + sizeof(uint8_t));
 86691:         void *storage = moz_malloc(size);
 86691:         if (!storage) {
106838:             return nullptr;
 86691:         }
 86691: 
 86691:         // Construct in the pre-allocated storage, using placement new
 86691:         return new (storage) gfxShapedWord(aText, aLength, aRunScript,
 86691:                                            aAppUnitsPerDevUnit, aFlags);
 86691:     }
 86691: 
108991:     static gfxShapedWord* Create(const PRUnichar *aText, uint32_t aLength,
108991:                                  int32_t aRunScript,
108991:                                  int32_t aAppUnitsPerDevUnit,
108991:                                  uint32_t aFlags) {
 86691:         NS_ASSERTION(aLength <= kMaxLength, "excessive length for gfxShapedWord!");
 86691: 
 86691:         // In the 16-bit version of Create, if the TEXT_IS_8BIT flag is set,
 86691:         // then we convert the text to an 8-bit version and call the 8-bit
 86691:         // Create function instead.
 86691:         if (aFlags & gfxTextRunFactory::TEXT_IS_8BIT) {
110974:             nsAutoCString narrowText;
 86691:             LossyAppendUTF16toASCII(nsDependentSubstring(aText, aLength),
 86691:                                     narrowText);
108991:             return Create((const uint8_t*)(narrowText.BeginReading()),
 86691:                           aLength, aRunScript, aAppUnitsPerDevUnit, aFlags);
 86691:         }
 86691: 
108991:         uint32_t size =
 86691:             offsetof(gfxShapedWord, mCharacterGlyphs) +
 86691:             aLength * (sizeof(CompressedGlyph) + sizeof(PRUnichar));
 86691:         void *storage = moz_malloc(size);
 86691:         if (!storage) {
106838:             return nullptr;
 86691:         }
 86691: 
 86691:         return new (storage) gfxShapedWord(aText, aLength, aRunScript,
 86691:                                            aAppUnitsPerDevUnit, aFlags);
 86691:     }
 86691: 
 86691:     // Override operator delete to properly free the object that was
 86691:     // allocated via moz_malloc.
 86691:     void operator delete(void* p) {
 86691:         moz_free(p);
 86691:     }
 86691: 
 86691:     /**
 86691:      * This class records the information associated with a character in the
 86691:      * input string. It's optimized for the case where there is one glyph
 86691:      * representing that character alone.
 86691:      * 
 86691:      * A character can have zero or more associated glyphs. Each glyph
 86691:      * has an advance width and an x and y offset.
 86691:      * A character may be the start of a cluster.
 86691:      * A character may be the start of a ligature group.
 86691:      * A character can be "missing", indicating that the system is unable
 86691:      * to render the character.
 86691:      * 
 86691:      * All characters in a ligature group conceptually share all the glyphs
 86691:      * associated with the characters in a group.
 86691:      */
 86691:     class CompressedGlyph {
 86691:     public:
 86691:         CompressedGlyph() { mValue = 0; }
 86691: 
     1:         enum {
 86691:             // Indicates that a cluster and ligature group starts at this
 86691:             // character; this character has a single glyph with a reasonable
 86691:             // advance and zero offsets. A "reasonable" advance
 86697:             // is one that fits in the available bits (currently 12) (specified
 86691:             // in appunits).
 86691:             FLAG_IS_SIMPLE_GLYPH  = 0x80000000U,
 86691: 
 86691:             // Indicates whether a linebreak is allowed before this character;
 86691:             // this is a two-bit field that holds a FLAG_BREAK_TYPE_xxx value
 86691:             // indicating the kind of linebreak (if any) allowed here.
 86691:             FLAGS_CAN_BREAK_BEFORE = 0x60000000U,
 86691: 
 86691:             FLAGS_CAN_BREAK_SHIFT = 29,
 86691:             FLAG_BREAK_TYPE_NONE   = 0,
 86691:             FLAG_BREAK_TYPE_NORMAL = 1,
 86691:             FLAG_BREAK_TYPE_HYPHEN = 2,
 86691: 
 86697:             FLAG_CHAR_IS_SPACE     = 0x10000000U,
 86697: 
 86691:             // The advance is stored in appunits
 86697:             ADVANCE_MASK  = 0x0FFF0000U,
 86691:             ADVANCE_SHIFT = 16,
 86691: 
 86691:             GLYPH_MASK = 0x0000FFFFU,
 86691: 
 86691:             // Non-simple glyphs may or may not have glyph data in the
 86691:             // corresponding mDetailedGlyphs entry. They have the following
 86691:             // flag bits:
 86691: 
 86691:             // When NOT set, indicates that this character corresponds to a
 86691:             // missing glyph and should be skipped (or possibly, render the character
 86691:             // Unicode value in some special way). If there are glyphs,
 86691:             // the mGlyphID is actually the UTF16 character code. The bit is
 86691:             // inverted so we can memset the array to zero to indicate all missing.
 86691:             FLAG_NOT_MISSING              = 0x01,
 86691:             FLAG_NOT_CLUSTER_START        = 0x02,
 86691:             FLAG_NOT_LIGATURE_GROUP_START = 0x04,
 86691: 
 86697:             FLAG_CHAR_IS_TAB              = 0x08,
 86697:             FLAG_CHAR_IS_NEWLINE          = 0x10,
 86697:             FLAG_CHAR_IS_LOW_SURROGATE    = 0x20,
 95501:             CHAR_IDENTITY_FLAGS_MASK      = 0x38,
 86697: 
 86691:             GLYPH_COUNT_MASK = 0x00FFFF00U,
 86691:             GLYPH_COUNT_SHIFT = 8
 86691:         };
 86691: 
 86691:         // "Simple glyphs" have a simple glyph ID, simple advance and their
 86691:         // x and y offsets are zero. Also the glyph extents do not overflow
 86691:         // the font-box defined by the font ascent, descent and glyph advance width.
 86691:         // These case is optimized to avoid storing DetailedGlyphs.
 86691: 
 86691:         // Returns true if the glyph ID aGlyph fits into the compressed representation
108991:         static bool IsSimpleGlyphID(uint32_t aGlyph) {
 86691:             return (aGlyph & GLYPH_MASK) == aGlyph;
 86691:         }
 86691:         // Returns true if the advance aAdvance fits into the compressed representation.
 86691:         // aAdvance is in appunits.
108991:         static bool IsSimpleAdvance(uint32_t aAdvance) {
 86691:             return (aAdvance & (ADVANCE_MASK >> ADVANCE_SHIFT)) == aAdvance;
 86691:         }
 86691: 
 86691:         bool IsSimpleGlyph() const { return (mValue & FLAG_IS_SIMPLE_GLYPH) != 0; }
108991:         uint32_t GetSimpleAdvance() const { return (mValue & ADVANCE_MASK) >> ADVANCE_SHIFT; }
108991:         uint32_t GetSimpleGlyph() const { return mValue & GLYPH_MASK; }
 86691: 
 86691:         bool IsMissing() const { return (mValue & (FLAG_NOT_MISSING|FLAG_IS_SIMPLE_GLYPH)) == 0; }
 86691:         bool IsClusterStart() const {
 86691:             return (mValue & FLAG_IS_SIMPLE_GLYPH) || !(mValue & FLAG_NOT_CLUSTER_START);
 86691:         }
 86691:         bool IsLigatureGroupStart() const {
 86691:             return (mValue & FLAG_IS_SIMPLE_GLYPH) || !(mValue & FLAG_NOT_LIGATURE_GROUP_START);
 86691:         }
 86691:         bool IsLigatureContinuation() const {
 86691:             return (mValue & FLAG_IS_SIMPLE_GLYPH) == 0 &&
 86691:                 (mValue & (FLAG_NOT_LIGATURE_GROUP_START | FLAG_NOT_MISSING)) ==
 86691:                     (FLAG_NOT_LIGATURE_GROUP_START | FLAG_NOT_MISSING);
 86691:         }
 86691: 
 86697:         // Return true if the original character was a normal (breakable,
 86697:         // trimmable) space (U+0020). Not true for other characters that
 86697:         // may happen to map to the space glyph (U+00A0).
 86697:         bool CharIsSpace() const {
 86697:             return (mValue & FLAG_CHAR_IS_SPACE) != 0;
 86697:         }
 86697: 
 86697:         bool CharIsTab() const {
 86697:             return !IsSimpleGlyph() && (mValue & FLAG_CHAR_IS_TAB) != 0;
 86697:         }
 86697:         bool CharIsNewline() const {
 86697:             return !IsSimpleGlyph() && (mValue & FLAG_CHAR_IS_NEWLINE) != 0;
 86697:         }
 86697:         bool CharIsLowSurrogate() const {
 86697:             return !IsSimpleGlyph() && (mValue & FLAG_CHAR_IS_LOW_SURROGATE) != 0;
 86697:         }
 86697: 
108991:         uint32_t CharIdentityFlags() const {
 95501:             return IsSimpleGlyph() ? 0 : (mValue & CHAR_IDENTITY_FLAGS_MASK);
 95501:         }
 95501: 
 86691:         void SetClusterStart(bool aIsClusterStart) {
 86691:             NS_ASSERTION(!IsSimpleGlyph(),
 86691:                          "can't call SetClusterStart on simple glyphs");
 86691:             if (aIsClusterStart) {
 86691:                 mValue &= ~FLAG_NOT_CLUSTER_START;
 86691:             } else {
 86691:                 mValue |= FLAG_NOT_CLUSTER_START;
 86691:             }
 86691:         }
 86691: 
108991:         uint8_t CanBreakBefore() const {
 86691:             return (mValue & FLAGS_CAN_BREAK_BEFORE) >> FLAGS_CAN_BREAK_SHIFT;
 86691:         }
 86691:         // Returns FLAGS_CAN_BREAK_BEFORE if the setting changed, 0 otherwise
108991:         uint32_t SetCanBreakBefore(uint8_t aCanBreakBefore) {
 86691:             NS_ASSERTION(aCanBreakBefore <= 2,
 86691:                          "Bogus break-before value!");
108991:             uint32_t breakMask = (uint32_t(aCanBreakBefore) << FLAGS_CAN_BREAK_SHIFT);
108991:             uint32_t toggle = breakMask ^ (mValue & FLAGS_CAN_BREAK_BEFORE);
 86691:             mValue ^= toggle;
 86691:             return toggle;
 86691:         }
 86691: 
108991:         CompressedGlyph& SetSimpleGlyph(uint32_t aAdvanceAppUnits, uint32_t aGlyph) {
 86691:             NS_ASSERTION(IsSimpleAdvance(aAdvanceAppUnits), "Advance overflow");
 86691:             NS_ASSERTION(IsSimpleGlyphID(aGlyph), "Glyph overflow");
 95501:             NS_ASSERTION(!CharIdentityFlags(), "Char identity flags lost");
 95501:             mValue = (mValue & (FLAGS_CAN_BREAK_BEFORE | FLAG_CHAR_IS_SPACE)) |
 86691:                 FLAG_IS_SIMPLE_GLYPH |
 86691:                 (aAdvanceAppUnits << ADVANCE_SHIFT) | aGlyph;
 86691:             return *this;
 86691:         }
 86691:         CompressedGlyph& SetComplex(bool aClusterStart, bool aLigatureStart,
108991:                 uint32_t aGlyphCount) {
 95501:             mValue = (mValue & (FLAGS_CAN_BREAK_BEFORE | FLAG_CHAR_IS_SPACE)) |
 86691:                 FLAG_NOT_MISSING |
 95501:                 CharIdentityFlags() |
 86691:                 (aClusterStart ? 0 : FLAG_NOT_CLUSTER_START) |
 86691:                 (aLigatureStart ? 0 : FLAG_NOT_LIGATURE_GROUP_START) |
 86691:                 (aGlyphCount << GLYPH_COUNT_SHIFT);
 86691:             return *this;
 86691:         }
     1:         /**
 86691:          * Missing glyphs are treated as ligature group starts; don't mess with
 86691:          * the cluster-start flag (see bugs 618870 and 619286).
     1:          */
108991:         CompressedGlyph& SetMissing(uint32_t aGlyphCount) {
 95501:             mValue = (mValue & (FLAGS_CAN_BREAK_BEFORE | FLAG_NOT_CLUSTER_START |
 95501:                                 FLAG_CHAR_IS_SPACE)) |
 95501:                 CharIdentityFlags() |
 86691:                 (aGlyphCount << GLYPH_COUNT_SHIFT);
 86691:             return *this;
 86691:         }
108991:         uint32_t GetGlyphCount() const {
 86691:             NS_ASSERTION(!IsSimpleGlyph(), "Expected non-simple-glyph");
 86691:             return (mValue & GLYPH_COUNT_MASK) >> GLYPH_COUNT_SHIFT;
 86691:         }
 86691: 
 86697:         void SetIsSpace() {
 86697:             mValue |= FLAG_CHAR_IS_SPACE;
 86697:         }
 86697:         void SetIsTab() {
 86697:             NS_ASSERTION(!IsSimpleGlyph(), "Expected non-simple-glyph");
 86697:             mValue |= FLAG_CHAR_IS_TAB;
 86697:         }
 86697:         void SetIsNewline() {
 86697:             NS_ASSERTION(!IsSimpleGlyph(), "Expected non-simple-glyph");
 86697:             mValue |= FLAG_CHAR_IS_NEWLINE;
 86697:         }
 86697:         void SetIsLowSurrogate() {
 86697:             NS_ASSERTION(!IsSimpleGlyph(), "Expected non-simple-glyph");
 86697:             mValue |= FLAG_CHAR_IS_LOW_SURROGATE;
 86697:         }
 86697: 
 86691:     private:
108991:         uint32_t mValue;
 86691:     };
 86691: 
     1:     /**
 86691:      * When the glyphs for a character don't fit into a CompressedGlyph record
 86691:      * in SimpleGlyph format, we use an array of DetailedGlyphs instead.
     1:      */
 86691:     struct DetailedGlyph {
 86691:         /** The glyphID, or the Unicode character
 86691:          * if this is a missing glyph */
108991:         uint32_t mGlyphID;
 86691:         /** The advance, x-offset and y-offset of the glyph, in appunits
 86691:          *  mAdvance is in the text direction (RTL or LTR)
 86691:          *  mXOffset is always from left to right
 86691:          *  mYOffset is always from top to bottom */   
108991:         int32_t  mAdvance;
 86691:         float    mXOffset, mYOffset;
     1:     };
     1: 
108991:     bool IsClusterStart(uint32_t aPos) {
 86691:         NS_ASSERTION(aPos < Length(), "aPos out of range");
 86691:         return mCharacterGlyphs[aPos].IsClusterStart();
 86691:     }
 86691: 
108991:     bool IsLigatureGroupStart(uint32_t aPos) {
 86691:         NS_ASSERTION(aPos < Length(), "aPos out of range");
 86691:         return mCharacterGlyphs[aPos].IsLigatureGroupStart();
 86691:     }
 86691: 
108991:     uint32_t Length() const {
 86691:         return mLength;
 86691:     }
 86691: 
108991:     const uint8_t* Text8Bit() const {
 86691:         NS_ASSERTION(TextIs8Bit(), "invalid use of Text8Bit()");
108991:         return reinterpret_cast<const uint8_t*>(&mCharacterGlyphs[Length()]);
 86691:     }
 86691: 
 86691:     const PRUnichar* TextUnicode() const {
 86691:         NS_ASSERTION(!TextIs8Bit(), "invalid use of TextUnicode()");
 86691:         return reinterpret_cast<const PRUnichar*>(&mCharacterGlyphs[Length()]);
 86691:     }
 86691: 
108991:     PRUnichar GetCharAt(uint32_t aOffset) const {
 86691:         NS_ASSERTION(aOffset < Length(), "aOffset out of range");
 86691:         return TextIs8Bit() ?
 86691:             PRUnichar(Text8Bit()[aOffset]) : TextUnicode()[aOffset];
 86691:     }
 86691: 
108991:     uint32_t Flags() const {
 86691:         return mFlags;
 86691:     }
 86691: 
 86691:     bool IsRightToLeft() const {
 86691:         return (Flags() & gfxTextRunFactory::TEXT_IS_RTL) != 0;
 86691:     }
 86691: 
 86693:     float GetDirection() const {
115612:         return IsRightToLeft() ? -1.0f : 1.0f;
 86693:     }
 86693: 
 86691:     bool DisableLigatures() const {
 86691:         return (Flags() & gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES) != 0;
 86691:     }
 86691: 
 86691:     bool TextIs8Bit() const {
 86691:         return (Flags() & gfxTextRunFactory::TEXT_IS_8BIT) != 0;
 86691:     }
 86691: 
108991:     int32_t Script() const {
 86691:         return mScript;
 86691:     }
 86691: 
108991:     int32_t AppUnitsPerDevUnit() const {
 86691:         return mAppUnitsPerDevUnit;
 86691:     }
 86691: 
 86698:     void ResetAge() {
 86698:         mAgeCounter = 0;
 86698:     }
108991:     uint32_t IncrementAge() {
 86698:         return ++mAgeCounter;
 86698:     }
 86698: 
108991:     void SetSimpleGlyph(uint32_t aCharIndex, CompressedGlyph aGlyph) {
 86691:         NS_ASSERTION(aGlyph.IsSimpleGlyph(), "Should be a simple glyph here");
 86699:         NS_ASSERTION(mCharacterGlyphs, "mCharacterGlyphs pointer is null!");
 86691:         mCharacterGlyphs[aCharIndex] = aGlyph;
 86691:     }
 86691: 
108991:     void SetGlyphs(uint32_t aCharIndex, CompressedGlyph aGlyph,
 86691:                    const DetailedGlyph *aGlyphs);
 86691: 
108991:     void SetMissingGlyph(uint32_t aIndex, uint32_t aChar, gfxFont *aFont);
108991: 
108991:     void SetIsSpace(uint32_t aIndex) {
 86697:         mCharacterGlyphs[aIndex].SetIsSpace();
 86697:     }
 86697: 
108991:     void SetIsLowSurrogate(uint32_t aIndex) {
106838:         SetGlyphs(aIndex, CompressedGlyph().SetComplex(false, false, 0), nullptr);
 86697:         mCharacterGlyphs[aIndex].SetIsLowSurrogate();
 86697:     }
 86697: 
108991:     bool FilterIfIgnorable(uint32_t aIndex);
 86691: 
 86691:     const CompressedGlyph *GetCharacterGlyphs() const {
 86691:         return &mCharacterGlyphs[0];
 86691:     }
 86691: 
 86691:     bool HasDetailedGlyphs() const {
106838:         return mDetailedGlyphs != nullptr;
 86691:     }
 86691: 
 86691:     // NOTE that this must not be called for a character offset that does
 86691:     // not have any DetailedGlyph records; callers must have verified that
 86691:     // mCharacterGlyphs[aCharIndex].GetGlyphCount() is greater than zero.
108991:     DetailedGlyph *GetDetailedGlyphs(uint32_t aCharIndex) const {
 86691:         NS_ASSERTION(HasDetailedGlyphs() &&
 86691:                      !mCharacterGlyphs[aCharIndex].IsSimpleGlyph() &&
 86691:                      mCharacterGlyphs[aCharIndex].GetGlyphCount() > 0,
 86691:                      "invalid use of GetDetailedGlyphs; check the caller!");
 86691:         return mDetailedGlyphs->Get(aCharIndex);
 86691:     }
 86691: 
 86691:     void AdjustAdvancesForSyntheticBold(float aSynBoldOffset);
 86691: 
 86691:     // this is a public static method in order to make it available
 86691:     // for gfxTextRun to use directly on its own CompressedGlyph array,
 86691:     // in addition to the use within ShapedWord
 86691:     static void
 86691:     SetupClusterBoundaries(CompressedGlyph *aGlyphs,
108991:                            const PRUnichar *aString, uint32_t aLength);
 86691: 
 86691: private:
 86691:     // so that gfxTextRun can share our DetailedGlyphStore class
 86691:     friend class gfxTextRun;
 86691: 
 86691:     // Construct storage for a ShapedWord, ready to receive glyph data
108991:     gfxShapedWord(const uint8_t *aText, uint32_t aLength,
108991:                   int32_t aRunScript, int32_t aAppUnitsPerDevUnit,
108991:                   uint32_t aFlags)
 86691:         : mLength(aLength)
 86691:         , mFlags(aFlags | gfxTextRunFactory::TEXT_IS_8BIT)
 86691:         , mAppUnitsPerDevUnit(aAppUnitsPerDevUnit)
 86691:         , mScript(aRunScript)
 86698:         , mAgeCounter(0)
 86691:     {
 86691:         memset(mCharacterGlyphs, 0, aLength * sizeof(CompressedGlyph));
108991:         uint8_t *text = reinterpret_cast<uint8_t*>(&mCharacterGlyphs[aLength]);
108991:         memcpy(text, aText, aLength * sizeof(uint8_t));
 86691:     }
 86691: 
108991:     gfxShapedWord(const PRUnichar *aText, uint32_t aLength,
108991:                   int32_t aRunScript, int32_t aAppUnitsPerDevUnit,
108991:                   uint32_t aFlags)
 86691:         : mLength(aLength)
 86691:         , mFlags(aFlags)
 86691:         , mAppUnitsPerDevUnit(aAppUnitsPerDevUnit)
 86691:         , mScript(aRunScript)
 86698:         , mAgeCounter(0)
 86691:     {
 86691:         memset(mCharacterGlyphs, 0, aLength * sizeof(CompressedGlyph));
 86691:         PRUnichar *text = reinterpret_cast<PRUnichar*>(&mCharacterGlyphs[aLength]);
 86691:         memcpy(text, aText, aLength * sizeof(PRUnichar));
 86691:         SetupClusterBoundaries(&mCharacterGlyphs[0], aText, aLength);
 86691:     }
 86691: 
 86691:     // Allocate aCount DetailedGlyphs for the given index
108991:     DetailedGlyph *AllocateDetailedGlyphs(uint32_t aCharIndex,
108991:                                           uint32_t aCount);
 86691: 
 86691:     // For characters whose glyph data does not fit the "simple" glyph criteria
 86691:     // in CompressedGlyph, we use a sorted array to store the association
 86691:     // between the source character offset and an index into an array 
 86691:     // DetailedGlyphs. The CompressedGlyph record includes a count of
 86691:     // the number of DetailedGlyph records that belong to the character,
 86691:     // starting at the given index.
 86691:     class DetailedGlyphStore {
 86691:     public:
 86691:         DetailedGlyphStore()
 86691:             : mLastUsed(0)
 86691:         { }
 86691: 
 86691:         // This is optimized for the most common calling patterns:
 86691:         // we rarely need random access to the records, access is most commonly
 86691:         // sequential through the textRun, so we record the last-used index
 86691:         // and check whether the caller wants the same record again, or the
 86691:         // next; if not, it's most likely we're starting over from the start
 86691:         // of the run, so we check the first entry before resorting to binary
 86691:         // search as a last resort.
 86691:         // NOTE that this must not be called for a character offset that does
 86691:         // not have any DetailedGlyph records; callers must have verified that
 86691:         // mCharacterGlyphs[aOffset].GetGlyphCount() is greater than zero
 86691:         // before calling this, otherwise the assertions here will fire (in a
 86691:         // debug build), and we'll probably crash.
108991:         DetailedGlyph* Get(uint32_t aOffset) {
 86691:             NS_ASSERTION(mOffsetToIndex.Length() > 0,
 86691:                          "no detailed glyph records!");
 86691:             DetailedGlyph* details = mDetails.Elements();
 86691:             // check common cases (fwd iteration, initial entry, etc) first
 86691:             if (mLastUsed < mOffsetToIndex.Length() - 1 &&
 86691:                 aOffset == mOffsetToIndex[mLastUsed + 1].mOffset) {
 86691:                 ++mLastUsed;
 86691:             } else if (aOffset == mOffsetToIndex[0].mOffset) {
 86691:                 mLastUsed = 0;
 86691:             } else if (aOffset == mOffsetToIndex[mLastUsed].mOffset) {
 86691:                 // do nothing
 86691:             } else if (mLastUsed > 0 &&
 86691:                        aOffset == mOffsetToIndex[mLastUsed - 1].mOffset) {
 86691:                 --mLastUsed;
 86691:             } else {
 86691:                 mLastUsed =
 86691:                     mOffsetToIndex.BinaryIndexOf(aOffset, CompareToOffset());
 86691:             }
 86691:             NS_ASSERTION(mLastUsed != nsTArray<DGRec>::NoIndex,
 86691:                          "detailed glyph record missing!");
 86691:             return details + mOffsetToIndex[mLastUsed].mIndex;
 86691:         }
 86691: 
108991:         DetailedGlyph* Allocate(uint32_t aOffset, uint32_t aCount) {
108991:             uint32_t detailIndex = mDetails.Length();
 86691:             DetailedGlyph *details = mDetails.AppendElements(aCount);
 86691:             if (!details) {
106838:                 return nullptr;
 86691:             }
 86691:             // We normally set up glyph records sequentially, so the common case
 86691:             // here is to append new records to the mOffsetToIndex array;
 86691:             // test for that before falling back to the InsertElementSorted
 86691:             // method.
 86691:             if (mOffsetToIndex.Length() == 0 ||
 86691:                 aOffset > mOffsetToIndex[mOffsetToIndex.Length() - 1].mOffset) {
 86691:                 if (!mOffsetToIndex.AppendElement(DGRec(aOffset, detailIndex))) {
106838:                     return nullptr;
 86691:                 }
 86691:             } else {
 86691:                 if (!mOffsetToIndex.InsertElementSorted(DGRec(aOffset, detailIndex),
 86691:                                                         CompareRecordOffsets())) {
106838:                     return nullptr;
 86691:                 }
 86691:             }
 86691:             return details;
 86691:         }
 86691: 
 86691:         size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) {
 88300:             return aMallocSizeOf(this) +
 86691:                 mDetails.SizeOfExcludingThis(aMallocSizeOf) +
 86691:                 mOffsetToIndex.SizeOfExcludingThis(aMallocSizeOf);
 86691:         }
 86691: 
 86691:     private:
 86691:         struct DGRec {
108991:             DGRec(const uint32_t& aOffset, const uint32_t& aIndex)
 86691:                 : mOffset(aOffset), mIndex(aIndex) { }
108991:             uint32_t mOffset; // source character offset in the textrun
108991:             uint32_t mIndex;  // index where this char's DetailedGlyphs begin
     1:         };
     1: 
 86691:         struct CompareToOffset {
108991:             bool Equals(const DGRec& a, const uint32_t& b) const {
 86691:                 return a.mOffset == b;
 86691:             }
108991:             bool LessThan(const DGRec& a, const uint32_t& b) const {
 86691:                 return a.mOffset < b;
 86691:             }
 86691:         };
 86691: 
 86691:         struct CompareRecordOffsets {
 86691:             bool Equals(const DGRec& a, const DGRec& b) const {
 86691:                 return a.mOffset == b.mOffset;
 86691:             }
 86691:             bool LessThan(const DGRec& a, const DGRec& b) const {
 86691:                 return a.mOffset < b.mOffset;
 86691:             }
 86691:         };
 86691: 
 86691:         // Concatenated array of all the DetailedGlyph records needed for the
 86691:         // textRun; individual character offsets are associated with indexes
 86691:         // into this array via the mOffsetToIndex table.
 86691:         nsTArray<DetailedGlyph>     mDetails;
 86691: 
 86691:         // For each character offset that needs DetailedGlyphs, we record the
 86691:         // index in mDetails where the list of glyphs begins. This array is
 86691:         // sorted by mOffset.
 86691:         nsTArray<DGRec>             mOffsetToIndex;
 86691: 
 86691:         // Records the most recently used index into mOffsetToIndex, so that
 86691:         // we can support sequential access more quickly than just doing
 86691:         // a binary search each time.
 86691:         nsTArray<DGRec>::index_type mLastUsed;
 86691:     };
 86691: 
 86691:     nsAutoPtr<DetailedGlyphStore>   mDetailedGlyphs;
 86691: 
 86691:     // Number of PRUnichar characters and CompressedGlyph glyph records;
 86691:     // note that gfx font code will never attempt to create a ShapedWord
 86691:     // with a huge number of characters, so we could limit this to 16 bits
 86691:     // to minimize memory usage for large numbers of cached words.
108991:     uint32_t                        mLength;
108991: 
108991:     uint32_t                        mFlags;
108991: 
108991:     int32_t                         mAppUnitsPerDevUnit;
108991:     int32_t                         mScript;
108991: 
108991:     uint32_t                        mAgeCounter;
 86698: 
 86691:     // The mCharacterGlyphs array is actually a variable-size member;
 86691:     // when the ShapedWord is created, its size will be increased as necessary
 86691:     // to allow the proper number of glyphs to be stored.
 86691:     // The original text, in either 8-bit or 16-bit form, will be stored
 86691:     // immediately following the CompressedGlyphs.
 86691:     CompressedGlyph                 mCharacterGlyphs[1];
     1: };
     1: 
     1: /**
     1:  * gfxTextRun is an abstraction for drawing and measuring substrings of a run
     1:  * of text. It stores runs of positioned glyph data, each run having a single
     1:  * gfxFont. The glyphs are associated with a string of source text, and the
     1:  * gfxTextRun APIs take parameters that are offsets into that source text.
     1:  * 
     1:  * gfxTextRuns are not refcounted. They should be deleted when no longer required.
     1:  * 
     1:  * gfxTextRuns are mostly immutable. The only things that can change are
     1:  * inter-cluster spacing and line break placement. Spacing is always obtained
     1:  * lazily by methods that need it, it is not cached. Line breaks are stored
     1:  * persistently (insofar as they affect the shaping of glyphs; gfxTextRun does
     1:  * not actually do anything to explicitly account for line breaks). Initially
     1:  * there are no line breaks. The textrun can record line breaks before or after
     1:  * any given cluster. (Line breaks specified inside clusters are ignored.)
     1:  * 
     1:  * It is important that zero-length substrings are handled correctly. This will
     1:  * be on the test!
     1:  */
     1: class THEBES_API gfxTextRun {
     1: public:
 86691:     // we use the same glyph storage as gfxShapedWord, to facilitate copying
 86691:     // glyph data from shaped words into text runs as needed
 86691:     typedef gfxShapedWord::CompressedGlyph    CompressedGlyph;
 86691:     typedef gfxShapedWord::DetailedGlyph      DetailedGlyph;
 86691:     typedef gfxShapedWord::DetailedGlyphStore DetailedGlyphStore;
 86691: 
 86699:     // Override operator delete to properly free the object that was
 86699:     // allocated via moz_malloc.
 86699:     void operator delete(void* p) {
 86699:         moz_free(p);
 86699:     }
 86699: 
  1295:     virtual ~gfxTextRun();
     1: 
     1:     typedef gfxFont::RunMetrics Metrics;
     1: 
     1:     // Public textrun API for general use
     1: 
108991:     bool IsClusterStart(uint32_t aPos) {
 84641:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
     1:         return mCharacterGlyphs[aPos].IsClusterStart();
     1:     }
108991:     bool IsLigatureGroupStart(uint32_t aPos) {
 84641:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
  7715:         return mCharacterGlyphs[aPos].IsLigatureGroupStart();
     1:     }
108991:     bool CanBreakLineBefore(uint32_t aPos) {
 84641:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
 69311:         return mCharacterGlyphs[aPos].CanBreakBefore() ==
 69311:             CompressedGlyph::FLAG_BREAK_TYPE_NORMAL;
 69311:     }
108991:     bool CanHyphenateBefore(uint32_t aPos) {
 84641:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
 69311:         return mCharacterGlyphs[aPos].CanBreakBefore() ==
 69311:             CompressedGlyph::FLAG_BREAK_TYPE_HYPHEN;
     1:     }
     1: 
108991:     bool CharIsSpace(uint32_t aPos) {
 94709:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
 86697:         return mCharacterGlyphs[aPos].CharIsSpace();
 86697:     }
108991:     bool CharIsTab(uint32_t aPos) {
 94709:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
 86697:         return mCharacterGlyphs[aPos].CharIsTab();
 86697:     }
108991:     bool CharIsNewline(uint32_t aPos) {
 94709:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
 86697:         return mCharacterGlyphs[aPos].CharIsNewline();
 86697:     }
108991:     bool CharIsLowSurrogate(uint32_t aPos) {
 94709:         NS_ASSERTION(aPos < mCharacterCount, "aPos out of range");
 86697:         return mCharacterGlyphs[aPos].CharIsLowSurrogate();
 86697:     }
 86697: 
108991:     uint32_t GetLength() { return mCharacterCount; }
108991: 
108991:     // All uint32_t aStart, uint32_t aLength ranges below are restricted to
     1:     // grapheme cluster boundaries! All offsets are in terms of the string
     1:     // passed into MakeTextRun.
     1:     
     1:     // All coordinates are in layout/app units
     1: 
     1:     /**
     1:      * Set the potential linebreaks for a substring of the textrun. These are
     1:      * the "allow break before" points. Initially, there are no potential
     1:      * linebreaks.
     1:      * 
     6:      * This can change glyphs and/or geometry! Some textruns' shapes
     6:      * depend on potential line breaks (e.g., title-case-converting textruns).
     6:      * This function is virtual so that those textruns can reshape themselves.
     6:      * 
     1:      * @return true if this changed the linebreaks, false if the new line
     1:      * breaks are the same as the old
     1:      */
108991:     virtual bool SetPotentialLineBreaks(uint32_t aStart, uint32_t aLength,
108991:                                           uint8_t *aBreakBefore,
  2834:                                           gfxContext *aRefContext);
     1: 
     1:     /**
     1:      * Layout provides PropertyProvider objects. These allow detection of
     1:      * potential line break points and computation of spacing. We pass the data
     1:      * this way to allow lazy data acquisition; for example BreakAndMeasureText
     1:      * will want to only ask for properties of text it's actually looking at.
     1:      * 
     1:      * NOTE that requested spacing may not actually be applied, if the textrun
     1:      * is unable to apply it in some context. Exception: spacing around a
     1:      * whitespace character MUST always be applied.
     1:      */
     6:     class PropertyProvider {
     1:     public:
     1:         // Detect hyphenation break opportunities in the given range; breaks
     1:         // not at cluster boundaries will be ignored.
108991:         virtual void GetHyphenationBreaks(uint32_t aStart, uint32_t aLength,
 79445:                                           bool *aBreakBefore) = 0;
     1: 
 69311:         // Returns the provider's hyphenation setting, so callers can decide
 69311:         // whether it is necessary to call GetHyphenationBreaks.
 69311:         // Result is an NS_STYLE_HYPHENS_* value.
108991:         virtual int8_t GetHyphensOption() = 0;
 69311: 
     1:         // Returns the extra width that will be consumed by a hyphen. This should
     1:         // be constant for a given textrun.
     1:         virtual gfxFloat GetHyphenWidth() = 0;
     1: 
     1:         typedef gfxFont::Spacing Spacing;
     1: 
     1:         /**
     1:          * Get the spacing around the indicated characters. Spacing must be zero
     1:          * inside clusters. In other words, if character i is not
     1:          * CLUSTER_START, then character i-1 must have zero after-spacing and
     1:          * character i must have zero before-spacing.
     1:          */
108991:         virtual void GetSpacing(uint32_t aStart, uint32_t aLength,
     1:                                 Spacing *aSpacing) = 0;
     1:     };
     1: 
 63634:     class ClusterIterator {
 63634:     public:
 63634:         ClusterIterator(gfxTextRun *aTextRun);
 63634: 
 63634:         void Reset();
 63634: 
 79445:         bool NextCluster();
 63634: 
108991:         uint32_t Position() const {
 63634:             return mCurrentChar;
 63634:         }
 63634: 
108991:         uint32_t ClusterLength() const;
 63634: 
 63634:         gfxFloat ClusterAdvance(PropertyProvider *aProvider) const;
 63634: 
 63634:     private:
 63634:         gfxTextRun *mTextRun;
108991:         uint32_t    mCurrentChar;
 63634:     };
 63634: 
     1:     /**
107804:      * Callback for Draw() to use when drawing text with mode
107804:      * gfxFont::GLYPH_PATH.
107804:      */
107804:     struct DrawCallbacks {
107804: 
107804:         /**
107804:          * Called when a path has been emitted to the gfxContext when
107804:          * painting a text run.  This can be called up to three times:
107804:          * once for any partial ligature at the beginning of the text run,
107804:          * once for the main run of glyphs, and once for any partial ligature
107804:          * at the end of the text run.
107804:          */
107804:         virtual void NotifyGlyphPathEmitted() = 0;
107804:     };
107804: 
107804:     /**
     1:      * Draws a substring. Uses only GetSpacing from aBreakProvider.
     1:      * The provided point is the baseline origin on the left of the string
     1:      * for LTR, on the right of the string for RTL.
     1:      * @param aAdvanceWidth if non-null, the advance width of the substring
     1:      * is returned here.
     1:      * 
     1:      * Drawing should respect advance widths in the sense that for LTR runs,
     1:      * Draw(ctx, pt, offset1, length1, dirty, &provider, &advance) followed by
     1:      * Draw(ctx, gfxPoint(pt.x + advance, pt.y), offset1 + length1, length2,
106838:      *      dirty, &provider, nullptr) should have the same effect as
106838:      * Draw(ctx, pt, offset1, length1+length2, dirty, &provider, nullptr).
     1:      * For RTL runs the rule is:
     1:      * Draw(ctx, pt, offset1 + length1, length2, dirty, &provider, &advance) followed by
     1:      * Draw(ctx, gfxPoint(pt.x + advance, pt.y), offset1, length1,
106838:      *      dirty, &provider, nullptr) should have the same effect as
106838:      * Draw(ctx, pt, offset1, length1+length2, dirty, &provider, nullptr).
     1:      * 
     1:      * Glyphs should be drawn in logical content order, which can be significant
     1:      * if they overlap (perhaps due to negative spacing).
     1:      */
     1:     void Draw(gfxContext *aContext, gfxPoint aPt,
 88295:               gfxFont::DrawMode aDrawMode,
108991:               uint32_t aStart, uint32_t aLength,
     1:               PropertyProvider *aProvider,
111295:               gfxFloat *aAdvanceWidth, gfxTextObjectPaint *aObjectPaint,
107804:               DrawCallbacks *aCallbacks = nullptr);
     1: 
     1:     /**
     1:      * Computes the ReflowMetrics for a substring.
     1:      * Uses GetSpacing from aBreakProvider.
 25417:      * @param aBoundingBoxType which kind of bounding box (loose/tight)
     1:      */
108991:     Metrics MeasureText(uint32_t aStart, uint32_t aLength,
 25417:                         gfxFont::BoundingBoxType aBoundingBoxType,
  6247:                         gfxContext *aRefContextForTightBoundingBox,
     1:                         PropertyProvider *aProvider);
     1: 
     1:     /**
     1:      * Computes just the advance width for a substring.
     1:      * Uses GetSpacing from aBreakProvider.
     1:      */
108991:     gfxFloat GetAdvanceWidth(uint32_t aStart, uint32_t aLength,
     1:                              PropertyProvider *aProvider);
     1: 
     1:     /**
     1:      * Clear all stored line breaks for the given range (both before and after),
     1:      * and then set the line-break state before aStart to aBreakBefore and
     1:      * after the last cluster to aBreakAfter.
     1:      * 
     1:      * We require that before and after line breaks be consistent. For clusters
     1:      * i and i+1, we require that if there is a break after cluster i, a break
     1:      * will be specified before cluster i+1. This may be temporarily violated
     1:      * (e.g. after reflowing line L and before reflowing line L+1); to handle
     1:      * these temporary violations, we say that there is a break betwen i and i+1
     1:      * if a break is specified after i OR a break is specified before i+1.
     1:      * 
     1:      * This can change textrun geometry! The existence of a linebreak can affect
     1:      * the advance width of the cluster before the break (when kerning) or the
     1:      * geometry of one cluster before the break or any number of clusters
     1:      * after the break. (The one-cluster-before-the-break limit is somewhat
     1:      * arbitrary; if some scripts require breaking it, then we need to
     1:      * alter nsTextFrame::TrimTrailingWhitespace, perhaps drastically becase
     1:      * it could affect the layout of frames before it...)
     1:      * 
     6:      * We return true if glyphs or geometry changed, false otherwise. This
     6:      * function is virtual so that gfxTextRun subclasses can reshape
     6:      * properly.
     6:      * 
     1:      * @param aAdvanceWidthDelta if non-null, returns the change in advance
     1:      * width of the given range.
     1:      */
108991:     virtual bool SetLineBreaks(uint32_t aStart, uint32_t aLength,
 79445:                                  bool aLineBreakBefore, bool aLineBreakAfter,
  2834:                                  gfxFloat *aAdvanceWidthDelta,
  2834:                                  gfxContext *aRefContext);
     1: 
     1:     /**
     1:      * Finds the longest substring that will fit into the given width.
     1:      * Uses GetHyphenationBreaks and GetSpacing from aBreakProvider.
     1:      * Guarantees the following:
     1:      * -- 0 <= result <= aMaxLength
     1:      * -- result is the maximal value of N such that either
     1:      *       N < aMaxLength && line break at N && GetAdvanceWidth(aStart, N) <= aWidth
     1:      *   OR  N < aMaxLength && hyphen break at N && GetAdvanceWidth(aStart, N) + GetHyphenWidth() <= aWidth
     1:      *   OR  N == aMaxLength && GetAdvanceWidth(aStart, N) <= aWidth
     1:      * where GetAdvanceWidth assumes the effect of
     1:      * SetLineBreaks(aStart, N, aLineBreakBefore, N < aMaxLength, aProvider)
     1:      * -- if no such N exists, then result is the smallest N such that
     1:      *       N < aMaxLength && line break at N
     1:      *   OR  N < aMaxLength && hyphen break at N
     1:      *   OR  N == aMaxLength
     1:      *
     1:      * The call has the effect of
     1:      * SetLineBreaks(aStart, result, aLineBreakBefore, result < aMaxLength, aProvider)
     1:      * and the returned metrics and the invariants above reflect this.
     1:      *
115367:      * @param aMaxLength this can be UINT32_MAX, in which case the length used
     1:      * is up to the end of the string
     1:      * @param aLineBreakBefore set to true if and only if there is an actual
     1:      * line break at the start of this string.
     1:      * @param aSuppressInitialBreak if true, then we assume there is no possible
     1:      * linebreak before aStart. If false, then we will check the internal
     1:      * line break opportunity state before deciding whether to return 0 as the
     1:      * character to break before.
  1731:      * @param aTrimWhitespace if non-null, then we allow a trailing run of
  1731:      * spaces to be trimmed; the width of the space(s) will not be included in
  1731:      * the measured string width for comparison with the limit aWidth, and
  1731:      * trimmed spaces will not be included in returned metrics. The width
  1731:      * of the trimmed spaces will be returned in aTrimWhitespace.
  1731:      * Trimmed spaces are still counted in the "characters fit" result.
     1:      * @param aMetrics if non-null, we fill this in for the returned substring.
     1:      * If a hyphenation break was used, the hyphen is NOT included in the returned metrics.
 25417:      * @param aBoundingBoxType whether to make the bounding box in aMetrics tight
  6247:      * @param aRefContextForTightBoundingBox a reference context to get the
 25417:      * tight bounding box, if requested
     1:      * @param aUsedHyphenation if non-null, records if we selected a hyphenation break
     1:      * @param aLastBreak if non-null and result is aMaxLength, we set this to
     1:      * the maximal N such that
     1:      *       N < aMaxLength && line break at N && GetAdvanceWidth(aStart, N) <= aWidth
     1:      *   OR  N < aMaxLength && hyphen break at N && GetAdvanceWidth(aStart, N) + GetHyphenWidth() <= aWidth
115367:      * or UINT32_MAX if no such N exists, where GetAdvanceWidth assumes
     1:      * the effect of
     1:      * SetLineBreaks(aStart, N, aLineBreakBefore, N < aMaxLength, aProvider)
     1:      *
 16166:      * @param aCanWordWrap true if we can break between any two grapheme
 16166:      * clusters. This is set by word-wrap: break-word
 16166:      *
 16166:      * @param aBreakPriority in/out the priority of the break opportunity
 16166:      * saved in the line. If we are prioritizing break opportunities, we will
 16166:      * not set a break with a lower priority. @see gfxBreakPriority.
 16166:      * 
     1:      * Note that negative advance widths are possible especially if negative
     1:      * spacing is provided.
     1:      */
108991:     uint32_t BreakAndMeasureText(uint32_t aStart, uint32_t aMaxLength,
 79445:                                  bool aLineBreakBefore, gfxFloat aWidth,
     1:                                  PropertyProvider *aProvider,
 79445:                                  bool aSuppressInitialBreak,
  1731:                                  gfxFloat *aTrimWhitespace,
 25417:                                  Metrics *aMetrics,
 25417:                                  gfxFont::BoundingBoxType aBoundingBoxType,
  6247:                                  gfxContext *aRefContextForTightBoundingBox,
 79445:                                  bool *aUsedHyphenation,
108991:                                  uint32_t *aLastBreak,
 79445:                                  bool aCanWordWrap,
 16166:                                  gfxBreakPriority *aBreakPriority);
     1: 
     1:     /**
     1:      * Update the reference context.
     1:      * XXX this is a hack. New text frame does not call this. Use only
     1:      * temporarily for old text frame.
     1:      */
     1:     void SetContext(gfxContext *aContext) {}
     1: 
     1:     // Utility getters
     1: 
 79445:     bool IsRightToLeft() const { return (mFlags & gfxTextRunFactory::TEXT_IS_RTL) != 0; }
     1:     gfxFloat GetDirection() const { return (mFlags & gfxTextRunFactory::TEXT_IS_RTL) ? -1.0 : 1.0; }
     1:     void *GetUserData() const { return mUserData; }
  1295:     void SetUserData(void *aUserData) { mUserData = aUserData; }
108991:     uint32_t GetFlags() const { return mFlags; }
108991:     void SetFlagBits(uint32_t aFlags) {
  3118:       NS_ASSERTION(!(aFlags & ~gfxTextRunFactory::SETTABLE_FLAGS),
  2317:                    "Only user flags should be mutable");
  2317:       mFlags |= aFlags;
  2317:     }
108991:     void ClearFlagBits(uint32_t aFlags) {
  3118:       NS_ASSERTION(!(aFlags & ~gfxTextRunFactory::SETTABLE_FLAGS),
  2317:                    "Only user flags should be mutable");
  2317:       mFlags &= ~aFlags;
  2317:     }
     1:     const gfxSkipChars& GetSkipChars() const { return mSkipChars; }
108991:     uint32_t GetAppUnitsPerDevUnit() const { return mAppUnitsPerDevUnit; }
  1295:     gfxFontGroup *GetFontGroup() const { return mFontGroup; }
 86697: 
     1: 
  8081:     // Call this, don't call "new gfxTextRun" directly. This does custom
  8081:     // allocation and initialization
  8081:     static gfxTextRun *Create(const gfxTextRunFactory::Parameters *aParams,
108991:                               uint32_t aLength, gfxFontGroup *aFontGroup,
108991:                               uint32_t aFlags);
  1295: 
     1:     // The text is divided into GlyphRuns as necessary
     1:     struct GlyphRun {
     1:         nsRefPtr<gfxFont> mFont;   // never null
108991:         uint32_t          mCharacterOffset; // into original UTF16 string
108991:         uint8_t           mMatchType;
     1:     };
     1: 
  7715:     class THEBES_API GlyphRunIterator {
     1:     public:
108991:         GlyphRunIterator(gfxTextRun *aTextRun, uint32_t aStart, uint32_t aLength)
     1:           : mTextRun(aTextRun), mStartOffset(aStart), mEndOffset(aStart + aLength) {
     1:             mNextIndex = mTextRun->FindFirstGlyphRunContaining(aStart);
     1:         }
 79445:         bool NextRun();
     1:         GlyphRun *GetGlyphRun() { return mGlyphRun; }
108991:         uint32_t GetStringStart() { return mStringStart; }
108991:         uint32_t GetStringEnd() { return mStringEnd; }
     1:     private:
     1:         gfxTextRun *mTextRun;
     1:         GlyphRun   *mGlyphRun;
108991:         uint32_t    mStringStart;
108991:         uint32_t    mStringEnd;
108991:         uint32_t    mNextIndex;
108991:         uint32_t    mStartOffset;
108991:         uint32_t    mEndOffset;
     1:     };
     1: 
  3609:     class GlyphRunOffsetComparator {
  3609:     public:
 79445:         bool Equals(const GlyphRun& a,
  3609:                       const GlyphRun& b) const
  3609:         {
  3609:             return a.mCharacterOffset == b.mCharacterOffset;
  3609:         }
  3609: 
 79445:         bool LessThan(const GlyphRun& a,
  3609:                         const GlyphRun& b) const
  3609:         {
  3609:             return a.mCharacterOffset < b.mCharacterOffset;
  3609:         }
  3609:     };
  3609: 
     1:     friend class GlyphRunIterator;
     1:     friend class FontSelector;
     1: 
     1:     // API for setting up the textrun glyphs. Should only be called by
     1:     // things that construct textruns.
     1:     /**
     1:      * We've found a run of text that should use a particular font. Call this
     1:      * only during initialization when font substitution has been computed.
   132:      * Call it before setting up the glyphs for the characters in this run;
   132:      * SetMissingGlyph requires that the correct glyphrun be installed.
  3609:      *
  3609:      * If aForceNewRun, a new glyph run will be added, even if the
  3609:      * previously added run uses the same font.  If glyph runs are
  3609:      * added out of strictly increasing aStartCharIndex order (via
  3609:      * force), then SortGlyphRuns must be called after all glyph runs
  3609:      * are added before any further operations are performed with this
  3609:      * TextRun.
     1:      */
108991:     nsresult AddGlyphRun(gfxFont *aFont, uint8_t aMatchType,
108991:                          uint32_t aStartCharIndex, bool aForceNewRun);
     6:     void ResetGlyphRuns() { mGlyphRuns.Clear(); }
  3609:     void SortGlyphRuns();
 26688:     void SanitizeGlyphRuns();
  3609: 
     1:     // Call the following glyph-setters during initialization or during reshaping
     1:     // only. It is OK to overwrite existing data for a character.
108991:     void SetSimpleGlyph(uint32_t aCharIndex, CompressedGlyph aGlyph) {
 86699:         NS_ASSERTION(aGlyph.IsSimpleGlyph(), "Should be a simple glyph here");
 86699:         mCharacterGlyphs[aCharIndex] = aGlyph;
 86699:     }
     1:     /**
  7715:      * Set the glyph data for a character. aGlyphs may be null if aGlyph is a
  7715:      * simple glyph or has no associated glyphs. If non-null the data is copied,
  7715:      * the caller retains ownership.
     1:      */
108991:     void SetGlyphs(uint32_t aCharIndex, CompressedGlyph aGlyph,
  7715:                    const DetailedGlyph *aGlyphs);
108991:     void SetMissingGlyph(uint32_t aCharIndex, uint32_t aUnicodeChar);
108991:     void SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext, uint32_t aCharIndex);
     1: 
 86691:     // Set the glyph data for the given character index to the font's
 86691:     // space glyph, IF this can be done as a "simple" glyph record
 86691:     // (not requiring a DetailedGlyph entry). This avoids the need to call
 86691:     // the font shaper and go through the shaped-word cache for most spaces.
 86691:     //
 86697:     // The parameter aSpaceChar is the original character code for which
 86697:     // this space glyph is being used; if this is U+0020, we need to record
 86697:     // that it could be trimmed at a run edge, whereas other kinds of space
 86697:     // (currently just U+00A0) would not be trimmable/breakable.
 86697:     //
 86691:     // Returns true if it was able to set simple glyph data for the space;
 86691:     // if it returns false, the caller needs to fall back to some other
 86691:     // means to create the necessary (detailed) glyph data.
 86691:     bool SetSpaceGlyphIfSimple(gfxFont *aFont, gfxContext *aContext,
108991:                                uint32_t aCharIndex, PRUnichar aSpaceChar);
 86697: 
 86697:     // Record the positions of specific characters that layout may need to
 86697:     // detect in the textrun, even though it doesn't have an explicit copy
 86697:     // of the original text. These are recorded using flag bits in the
 86697:     // CompressedGlyph record; if necessary, we convert "simple" glyph records
 86697:     // to "complex" ones as the Tab and Newline flags are not present in
 86697:     // simple CompressedGlyph records.
108991:     void SetIsTab(uint32_t aIndex) {
 86697:         CompressedGlyph *g = &mCharacterGlyphs[aIndex];
 86697:         if (g->IsSimpleGlyph()) {
 86697:             DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
 86697:             details->mGlyphID = g->GetSimpleGlyph();
 86697:             details->mAdvance = g->GetSimpleAdvance();
 86697:             details->mXOffset = details->mYOffset = 0;
 86697:             SetGlyphs(aIndex, CompressedGlyph().SetComplex(true, true, 1), details);
 86697:         }
 86697:         g->SetIsTab();
 86697:     }
108991:     void SetIsNewline(uint32_t aIndex) {
 86697:         CompressedGlyph *g = &mCharacterGlyphs[aIndex];
 86697:         if (g->IsSimpleGlyph()) {
 86697:             DetailedGlyph *details = AllocateDetailedGlyphs(aIndex, 1);
 86697:             details->mGlyphID = g->GetSimpleGlyph();
 86697:             details->mAdvance = g->GetSimpleAdvance();
 86697:             details->mXOffset = details->mYOffset = 0;
 86697:             SetGlyphs(aIndex, CompressedGlyph().SetComplex(true, true, 1), details);
 86697:         }
 86697:         g->SetIsNewline();
 86697:     }
108991:     void SetIsLowSurrogate(uint32_t aIndex) {
106838:         SetGlyphs(aIndex, CompressedGlyph().SetComplex(false, false, 0), nullptr);
 86697:         mCharacterGlyphs[aIndex].SetIsLowSurrogate();
 86697:     }
 43527: 
  9576:     /**
  9576:      * Prefetch all the glyph extents needed to ensure that Measure calls
 25417:      * on this textrun not requesting tight boundingBoxes will succeed. Note
  9576:      * that some glyph extents might not be fetched due to OOM or other
  9576:      * errors.
  9576:      */
  6247:     void FetchGlyphExtents(gfxContext *aRefContext);
  6247: 
     1:     // API for access to the raw glyph data, needed by gfxFont::Draw
     1:     // and gfxFont::GetBoundingBox
 86691:     CompressedGlyph *GetCharacterGlyphs() { return mCharacterGlyphs; }
 62426: 
 62426:     // NOTE that this must not be called for a character offset that does
 62426:     // not have any DetailedGlyph records; callers must have verified that
 62426:     // mCharacterGlyphs[aCharIndex].GetGlyphCount() is greater than zero.
108991:     DetailedGlyph *GetDetailedGlyphs(uint32_t aCharIndex) {
106838:         NS_ASSERTION(mDetailedGlyphs != nullptr &&
 62426:                      !mCharacterGlyphs[aCharIndex].IsSimpleGlyph() &&
 62426:                      mCharacterGlyphs[aCharIndex].GetGlyphCount() > 0,
 62426:                      "invalid use of GetDetailedGlyphs; check the caller!");
 62288:         return mDetailedGlyphs->Get(aCharIndex);
 62288:     }
 62426: 
106838:     bool HasDetailedGlyphs() { return mDetailedGlyphs != nullptr; }
108991:     uint32_t CountMissingGlyphs();
108991:     const GlyphRun *GetGlyphRuns(uint32_t *aNumGlyphRuns) {
     6:         *aNumGlyphRuns = mGlyphRuns.Length();
     6:         return mGlyphRuns.Elements();
     6:     }
  2317:     // Returns the index of the GlyphRun containing the given offset.
  2317:     // Returns mGlyphRuns.Length() when aOffset is mCharacterCount.
108991:     uint32_t FindFirstGlyphRunContaining(uint32_t aOffset);
 86691: 
 86691:     // Copy glyph data from a ShapedWord into this textrun.
108991:     void CopyGlyphDataFrom(const gfxShapedWord *aSource, uint32_t aStart);
 86691: 
  2317:     // Copy glyph data for a range of characters from aSource to this
 62288:     // textrun.
108991:     void CopyGlyphDataFrom(gfxTextRun *aSource, uint32_t aStart,
108991:                            uint32_t aLength, uint32_t aDest);
     1: 
  1295:     nsExpirationState *GetExpirationState() { return &mExpirationState; }
  1295: 
  4434:     struct LigatureData {
  4434:         // textrun offsets of the start and end of the containing ligature
108991:         uint32_t mLigatureStart;
108991:         uint32_t mLigatureEnd;
  4434:         // appunits advance to the start of the ligature part within the ligature;
  4434:         // never includes any spacing
  4434:         gfxFloat mPartAdvance;
  4434:         // appunits width of the ligature part; includes before-spacing
  4434:         // when the part is at the start of the ligature, and after-spacing
  4434:         // when the part is as the end of the ligature
  4434:         gfxFloat mPartWidth;
  4434:         
 79445:         bool mClipBeforePart;
 79445:         bool mClipAfterPart;
  4434:     };
  4434:     
 80375:     // return storage used by this run, for memory reporter;
 80375:     // nsTransformedTextRun needs to override this as it holds additional data
 82849:     virtual NS_MUST_OVERRIDE size_t
 82849:         SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf);
 82849:     virtual NS_MUST_OVERRIDE size_t
 82849:         SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf);
 80375: 
 82849:     // Get the size, if it hasn't already been gotten, marking as it goes.
 82849:     size_t MaybeSizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf)  {
 80375:         if (mFlags & gfxTextRunFactory::TEXT_RUN_SIZE_ACCOUNTED) {
 82849:             return 0;
 80375:         }
 80375:         mFlags |= gfxTextRunFactory::TEXT_RUN_SIZE_ACCOUNTED;
 82849:         return SizeOfIncludingThis(aMallocSizeOf);
 80375:     }
 82849:     void ResetSizeOfAccountingFlags() {
 80375:         mFlags &= ~gfxTextRunFactory::TEXT_RUN_SIZE_ACCOUNTED;
 80375:     }
 80375: 
  5320: #ifdef DEBUG
 10484:     void Dump(FILE* aOutput);
  5320: #endif
  5320: 
  8081: protected:
  8081:     /**
 86699:      * Create a textrun, and set its mCharacterGlyphs to point immediately
 86699:      * after the base object; this is ONLY used in conjunction with placement
 86699:      * new, after allocating a block large enough for the glyph records to
 86699:      * follow the base textrun object.
  8081:      */
 93219:     gfxTextRun(const gfxTextRunFactory::Parameters *aParams,
108991:                uint32_t aLength, gfxFontGroup *aFontGroup, uint32_t aFlags);
 38204: 
 38204:     /**
 38204:      * Helper for the Create() factory method to allocate the required
 86699:      * glyph storage for a textrun object with the basic size aSize,
 86699:      * plus room for aLength glyph records.
 38204:      */
108991:     static void* AllocateStorageForTextRun(size_t aSize, uint32_t aLength);
 86699: 
 86699:     // All our glyph data is in logical order, not visual.
 86699:     // Space for mCharacterGlyphs is allocated fused with the textrun object,
 86699:     // and then the constructor sets the pointer to the beginning of this
 86699:     // storage area. Thus, this pointer must NOT be freed!
 86699:     CompressedGlyph  *mCharacterGlyphs;
  8081: 
     1: private:
     1:     // **** general helpers **** 
     1: 
   132:     // Allocate aCount DetailedGlyphs for the given index
108991:     DetailedGlyph *AllocateDetailedGlyphs(uint32_t aCharIndex, uint32_t aCount);
     1: 
 62288:     // Get the total advance for a range of glyphs.
108991:     int32_t GetAdvanceForGlyphs(uint32_t aStart, uint32_t aEnd);
 62288: 
  4434:     // Spacing for characters outside the range aSpacingStart/aSpacingEnd
  4434:     // is assumed to be zero; such characters are not passed to aProvider.
  4434:     // This is useful to protect aProvider from being passed character indices
  4434:     // it is not currently able to handle.
108991:     bool GetAdjustedSpacingArray(uint32_t aStart, uint32_t aEnd,
  4434:                                    PropertyProvider *aProvider,
108991:                                    uint32_t aSpacingStart, uint32_t aSpacingEnd,
  4434:                                    nsTArray<PropertyProvider::Spacing> *aSpacing);
  4434: 
     1:     //  **** ligature helpers ****
     1:     // (Platforms do the actual ligaturization, but we need to do a bunch of stuff
     1:     // to handle requests that begin or end inside a ligature)
     1: 
     1:     // if aProvider is null then mBeforeSpacing and mAfterSpacing are set to zero
108991:     LigatureData ComputeLigatureData(uint32_t aPartStart, uint32_t aPartEnd,
     1:                                      PropertyProvider *aProvider);
108991:     gfxFloat ComputePartialLigatureWidth(uint32_t aPartStart, uint32_t aPartEnd,
  4434:                                          PropertyProvider *aProvider);
 60285:     void DrawPartialLigature(gfxFont *aFont, gfxContext *aCtx,
108991:                              uint32_t aStart, uint32_t aEnd, gfxPoint *aPt,
107804:                              PropertyProvider *aProvider,
107804:                              DrawCallbacks *aCallbacks);
  4434:     // Advance aStart to the start of the nearest ligature; back up aEnd
  4434:     // to the nearest ligature end; may result in *aStart == *aEnd
108991:     void ShrinkToLigatureBoundaries(uint32_t *aStart, uint32_t *aEnd);
     1:     // result in appunits
108991:     gfxFloat GetPartialLigatureWidth(uint32_t aStart, uint32_t aEnd, PropertyProvider *aProvider);
     1:     void AccumulatePartialLigatureMetrics(gfxFont *aFont,
108991:                                           uint32_t aStart, uint32_t aEnd,
 25417:                                           gfxFont::BoundingBoxType aBoundingBoxType,
  6247:                                           gfxContext *aRefContext,
     1:                                           PropertyProvider *aProvider,
     1:                                           Metrics *aMetrics);
     1: 
     1:     // **** measurement helper ****
108991:     void AccumulateMetricsForRun(gfxFont *aFont, uint32_t aStart, uint32_t aEnd,
 25417:                                  gfxFont::BoundingBoxType aBoundingBoxType,
  6247:                                  gfxContext *aRefContext,
     1:                                  PropertyProvider *aProvider,
108991:                                  uint32_t aSpacingStart, uint32_t aSpacingEnd,
     1:                                  Metrics *aMetrics);
     1: 
     1:     // **** drawing helper ****
 88295:     void DrawGlyphs(gfxFont *aFont, gfxContext *aContext,
 88295:                     gfxFont::DrawMode aDrawMode, gfxPoint *aPt,
111295:                     gfxTextObjectPaint *aObjectPaint, uint32_t aStart,
111295:                     uint32_t aEnd, PropertyProvider *aProvider,
108991:                     uint32_t aSpacingStart, uint32_t aSpacingEnd);
     1: 
 62288:     nsAutoPtr<DetailedGlyphStore>   mDetailedGlyphs;
 62288: 
     1:     // XXX this should be changed to a GlyphRun plus a maybe-null GlyphRun*,
     1:     // for smaller size especially in the super-common one-glyphrun case
     1:     nsAutoTArray<GlyphRun,1>        mGlyphRuns;
 86697: 
     1:     void             *mUserData;
  1295:     gfxFontGroup     *mFontGroup; // addrefed
     1:     gfxSkipChars      mSkipChars;
  1295:     nsExpirationState mExpirationState;
108991:     uint32_t          mAppUnitsPerDevUnit;
108991:     uint32_t          mFlags;
108991:     uint32_t          mCharacterCount;
 62296: 
 79445:     bool              mSkipDrawing; // true if the font group we used had a user font
 62296:                                     // download that's in progress, so we should hide text
 62296:                                     // until the download completes (or timeout fires)
     1: };
     1: 
     1: class THEBES_API gfxFontGroup : public gfxTextRunFactory {
 37211: public:
 38492:     static void Shutdown(); // platform must call this to release the languageAtomService
 38492: 
106838:     gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet = nullptr);
     1: 
 19962:     virtual ~gfxFontGroup();
     1: 
108991:     virtual gfxFont *GetFontAt(int32_t i) {
 21927:         // If it turns out to be hard for all clients that cache font
 21927:         // groups to call UpdateFontList at appropriate times, we could
 21927:         // instead consider just calling UpdateFontList from someplace
 21927:         // more central (such as here).
 21927:         NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
 21927:                      "Whoever was caching this font group should have "
 21927:                      "called UpdateFontList on it");
108991:         NS_ASSERTION(mFonts.Length() > uint32_t(i), 
 24104:                      "Requesting a font index that doesn't exist");
 21927: 
  3233:         return static_cast<gfxFont*>(mFonts[i]);
     1:     }
102480: 
108991:     uint32_t FontListLength() const {
     1:         return mFonts.Length();
     1:     }
     1: 
 79445:     bool Equals(const gfxFontGroup& other) const {
     1:         return mFamilies.Equals(other.mFamilies) &&
     1:             mStyle.Equals(other.mStyle);
     1:     }
     1: 
     1:     const gfxFontStyle *GetStyle() const { return &mStyle; }
     1: 
 37211:     virtual gfxFontGroup *Copy(const gfxFontStyle *aStyle);
     1: 
  1295:     /**
 86691:      * The listed characters should be treated as invisible and zero-width
 86691:      * when creating textruns.
  1746:      */
108991:     static bool IsInvalidChar(uint8_t ch);
 79445:     static bool IsInvalidChar(PRUnichar ch);
  1746: 
  1746:     /**
  1435:      * Make a textrun for a given string.
  1435:      * If aText is not persistent (aFlags & TEXT_IS_PERSISTENT), the
  1435:      * textrun will copy it.
  9576:      * This calls FetchGlyphExtents on the textrun.
  1295:      */
108991:     virtual gfxTextRun *MakeTextRun(const PRUnichar *aString, uint32_t aLength,
108991:                                     const Parameters *aParams, uint32_t aFlags);
  1295:     /**
  1435:      * Make a textrun for a given string.
  1435:      * If aText is not persistent (aFlags & TEXT_IS_PERSISTENT), the
  1435:      * textrun will copy it.
  9576:      * This calls FetchGlyphExtents on the textrun.
  1295:      */
108991:     virtual gfxTextRun *MakeTextRun(const uint8_t *aString, uint32_t aLength,
108991:                                     const Parameters *aParams, uint32_t aFlags);
     1: 
 86690:     /**
 86690:      * Textrun creation helper for clients that don't want to pass
 86690:      * a full Parameters record.
 86690:      */
 86690:     template<typename T>
108991:     gfxTextRun *MakeTextRun(const T *aString, uint32_t aLength,
 86690:                             gfxContext *aRefContext,
108991:                             uint32_t aAppUnitsPerDevUnit,
108991:                             uint32_t aFlags)
 86690:     {
 86690:         gfxTextRunFactory::Parameters params = {
106838:             aRefContext, nullptr, nullptr, nullptr, 0, aAppUnitsPerDevUnit
 86690:         };
 86690:         return MakeTextRun(aString, aLength, &params, aFlags);
 86690:     }
 86690: 
     1:     /* helper function for splitting font families on commas and
     1:      * calling a function for each family to fill the mFonts array
     1:      */
 79445:     typedef bool (*FontCreationCallback) (const nsAString& aName,
     1:                                             const nsACString& aGenericName,
 79445:                                             bool aUseFontSet,
     1:                                             void *closure);
 79445:     bool ForEachFont(const nsAString& aFamilies,
 38493:                        nsIAtom *aLanguage,
     1:                        FontCreationCallback fc,
     1:                        void *closure);
 79445:     bool ForEachFont(FontCreationCallback fc, void *closure);
     1: 
 37211:     /**
 37211:      * Check whether a given font (specified by its gfxFontEntry)
 37211:      * is already in the fontgroup's list of actual fonts
 37211:      */
 79445:     bool HasFont(const gfxFontEntry *aFontEntry);
 37211: 
     1:     const nsString& GetFamilies() { return mFamilies; }
     1: 
 12989:     // This returns the preferred underline for this font group.
 12989:     // Some CJK fonts have wrong underline offset in its metrics.
 12989:     // If this group has such "bad" font, each platform's gfxFontGroup initialized mUnderlineOffset.
 12989:     // The value should be lower value of first font's metrics and the bad font's metrics.
 12989:     // Otherwise, this returns from first font's metrics.
115367:     enum { UNDERLINE_OFFSET_NOT_SET = INT16_MAX };
 22991:     virtual gfxFloat GetUnderlineOffset() {
 14253:         if (mUnderlineOffset == UNDERLINE_OFFSET_NOT_SET)
 12989:             mUnderlineOffset = GetFontAt(0)->GetMetrics().underlineOffset;
 12989:         return mUnderlineOffset;
 12989:     }
 12989: 
 57263:     virtual already_AddRefed<gfxFont>
108991:         FindFontForChar(uint32_t ch, uint32_t prevCh, int32_t aRunScript,
 71910:                         gfxFont *aPrevMatchedFont,
108991:                         uint8_t *aMatchType);
 16418: 
106838:     // search through pref fonts for a character, return nullptr if no matching pref font
108991:     virtual already_AddRefed<gfxFont> WhichPrefFontSupportsChar(uint32_t aCh);
 16418: 
 91870:     virtual already_AddRefed<gfxFont>
108991:         WhichSystemFontSupportsChar(uint32_t aCh, int32_t aRunScript);
 16418: 
 86691:     template<typename T>
 57263:     void ComputeRanges(nsTArray<gfxTextRange>& mRanges,
108991:                        const T *aString, uint32_t aLength,
108991:                        int32_t aRunScript);
 16418: 
 19962:     gfxUserFontSet* GetUserFontSet();
 19962: 
 19962:     // With downloadable fonts, the composition of the font group can change as fonts are downloaded
 19962:     // for each change in state of the user font set, the generation value is bumped to avoid picking up
 19962:     // previously created text runs in the text run word cache.  For font groups based on stylesheets
 19962:     // with no @font-face rule, this always returns 0.
108991:     uint64_t GetGeneration();
 19962: 
 22397:     // If there is a user font set, check to see whether the font list or any
 22397:     // caches need updating.
 37211:     virtual void UpdateFontList();
 16418: 
 79445:     bool ShouldSkipDrawing() const {
 62296:         return mSkipDrawing;
 62296:     }
 62296: 
     1: protected:
     1:     nsString mFamilies;
     1:     gfxFontStyle mStyle;
     1:     nsTArray< nsRefPtr<gfxFont> > mFonts;
 12989:     gfxFloat mUnderlineOffset;
 12989: 
 19962:     gfxUserFontSet* mUserFontSet;
108991:     uint64_t mCurrGeneration;  // track the current user font set generation, rebuild font list if needed
 19962: 
 37211:     // cache the most recent pref font to avoid general pref font lookup
 37211:     nsRefPtr<gfxFontFamily> mLastPrefFamily;
 37211:     nsRefPtr<gfxFont>       mLastPrefFont;
 37211:     eFontPrefLang           mLastPrefLang;       // lang group for last pref font
 37211:     eFontPrefLang           mPageLang;
 79445:     bool                    mLastPrefFirstFont;  // is this the first font in the list of pref fonts for this lang group?
 62296: 
 79445:     bool                    mSkipDrawing; // hide text while waiting for a font
 62296:                                           // download to complete (or fallback
 62296:                                           // timer to fire)
 37211: 
 86690:     /**
 86690:      * Textrun creation short-cuts for special cases where we don't need to
 86690:      * call a font shaper to generate glyphs.
 86690:      */
108991:     gfxTextRun *MakeEmptyTextRun(const Parameters *aParams, uint32_t aFlags);
108991:     gfxTextRun *MakeSpaceTextRun(const Parameters *aParams, uint32_t aFlags);
108991:     gfxTextRun *MakeBlankTextRun(uint32_t aLength,
108991:                                  const Parameters *aParams, uint32_t aFlags);
 86690: 
 22397:     // Used for construction/destruction.  Not intended to change the font set
 22397:     // as invalidation of font lists and caches is not considered.
 22397:     void SetUserFontSet(gfxUserFontSet *aUserFontSet);
 22397: 
 38461:     // Initialize the list of fonts
 38461:     void BuildFontList();
 38461: 
 12989:     // Init this font group's font metrics. If there no bad fonts, you don't need to call this.
 12989:     // But if there are one or more bad fonts which have bad underline offset,
 12989:     // you should call this with the *first* bad font.
 12989:     void InitMetricsForBadFont(gfxFont* aBadFont);
     1: 
 60118:     // Set up the textrun glyphs for an entire text run:
 60118:     // find script runs, and then call InitScriptRun for each
 86691:     template<typename T>
 39206:     void InitTextRun(gfxContext *aContext,
 39206:                      gfxTextRun *aTextRun,
 86691:                      const T *aString,
108991:                      uint32_t aLength);
 37211: 
 60118:     // InitTextRun helper to handle a single script run, by finding font ranges
 60118:     // and calling each font's InitTextRun() as appropriate
 86691:     template<typename T>
 60118:     void InitScriptRun(gfxContext *aContext,
 43525:                        gfxTextRun *aTextRun,
 86691:                        const T *aString,
108991:                        uint32_t aScriptRunStart,
108991:                        uint32_t aScriptRunEnd,
108991:                        int32_t aRunScript);
 43525: 
 10774:     /* If aResolveGeneric is true, then CSS/Gecko generic family names are
 10774:      * replaced with preferred fonts.
 10774:      *
 10774:      * If aResolveFontName is true then fc() is called only for existing fonts
 10774:      * and with actual font names.  If false then fc() is called with each
 10774:      * family name in aFamilies (after resolving CSS/Gecko generic family names
 10774:      * if aResolveGeneric).
 73730:      * If aUseFontSet is true, the fontgroup's user font set is checked;
 73730:      * if false then it is skipped.
 10774:      */
 79445:     bool ForEachFontInternal(const nsAString& aFamilies,
 38493:                                nsIAtom *aLanguage,
 79445:                                bool aResolveGeneric,
 79445:                                bool aResolveFontName,
 79445:                                bool aUseFontSet,
     1:                                FontCreationCallback fc,
     1:                                void *closure);
     1: 
106282:     // Helper for font-matching:
106282:     // see if aCh is supported in any of the other faces from aFont's family;
106282:     // if so return the best style match, else return null.
106282:     already_AddRefed<gfxFont> TryOtherFamilyMembers(gfxFont* aFont,
108991:                                                     uint32_t aCh);
106282: 
 79445:     static bool FontResolverProc(const nsAString& aName, void *aClosure);
 16418: 
 79445:     static bool FindPlatformFont(const nsAString& aName,
 37211:                                    const nsACString& aGenericName,
 79445:                                    bool aUseFontSet,
 37211:                                    void *closure);
 37211: 
 38492:     static NS_HIDDEN_(nsILanguageAtomService*) gLangService;
     1: };
     1: #endif
