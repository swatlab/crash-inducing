103059: /* This Source Code Form is subject to the terms of the Mozilla Public
103059:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
103059:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
103059: 
103059: #ifndef nsCanvasRenderingContext2DAzure_h
103059: #define nsCanvasRenderingContext2DAzure_h
103059: 
103059: #include <vector>
103059: #include "nsIDOMCanvasRenderingContext2D.h"
103059: #include "nsICanvasRenderingContextInternal.h"
103059: #include "mozilla/RefPtr.h"
103059: #include "nsColor.h"
103059: #include "nsHTMLCanvasElement.h"
103059: #include "CanvasUtils.h"
103059: #include "nsHTMLImageElement.h"
103059: #include "nsHTMLVideoElement.h"
103059: #include "gfxFont.h"
103059: #include "mozilla/ErrorResult.h"
103059: #include "mozilla/dom/ImageData.h"
103059: #include "mozilla/dom/UnionTypes.h"
103059: 
103059: namespace mozilla {
103059: namespace dom {
103059: template<typename T> class Optional;
103059: }
103059: namespace gfx {
103059: struct Rect;
103059: class SourceSurface;
103059: }
103059: }
103059: 
103059: extern const mozilla::gfx::Float SIGMA_MAX;
103059: 
103059: /**
103059:  ** nsCanvasGradientAzure
103059:  **/
103059: #define NS_CANVASGRADIENTAZURE_PRIVATE_IID \
103059:     {0x28425a6a, 0x90e0, 0x4d42, {0x9c, 0x75, 0xff, 0x60, 0x09, 0xb3, 0x10, 0xa8}}
103059: class nsCanvasGradientAzure : public nsIDOMCanvasGradient
103059: {
103059: public:
103059:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASGRADIENTAZURE_PRIVATE_IID)
103059: 
103059:   enum Type
103059:   {
103059:     LINEAR = 0,
103059:     RADIAL
103059:   };
103059: 
103059:   Type GetType()
103059:   {
103059:     return mType;
103059:   }
103059: 
103059: 
103059:   mozilla::gfx::GradientStops *
103059:   GetGradientStopsForTarget(mozilla::gfx::DrawTarget *aRT)
103059:   {
103059:     if (mStops && mStops->GetBackendType() == aRT->GetType()) {
103059:       return mStops;
103059:     }
103059: 
103059:     mStops = aRT->CreateGradientStops(mRawStops.Elements(), mRawStops.Length());
103059: 
103059:     return mStops;
103059:   }
103059: 
103059:   NS_DECL_ISUPPORTS
103059: 
103059:   /* nsIDOMCanvasGradient */
103059:   NS_IMETHOD AddColorStop(float offset, const nsAString& colorstr);
103059: 
103059: protected:
103059:   nsCanvasGradientAzure(Type aType) : mType(aType)
103059:   {}
103059: 
103059:   nsTArray<mozilla::gfx::GradientStop> mRawStops;
103059:   mozilla::RefPtr<mozilla::gfx::GradientStops> mStops;
103059:   Type mType;
103059:   virtual ~nsCanvasGradientAzure() {}
103059: };
103059: 
103059: /**
103059:  ** nsCanvasPatternAzure
103059:  **/
103059: #define NS_CANVASPATTERNAZURE_PRIVATE_IID \
103059:     {0xc9bacc25, 0x28da, 0x421e, {0x9a, 0x4b, 0xbb, 0xd6, 0x93, 0x05, 0x12, 0xbc}}
103059: class nsCanvasPatternAzure MOZ_FINAL : public nsIDOMCanvasPattern
103059: {
103059: public:
103059:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASPATTERNAZURE_PRIVATE_IID)
103059: 
103059:   enum RepeatMode
103059:   {
103059:     REPEAT,
103059:     REPEATX,
103059:     REPEATY,
103059:     NOREPEAT
103059:   };
103059: 
103059:   nsCanvasPatternAzure(mozilla::gfx::SourceSurface* aSurface,
103059:                        RepeatMode aRepeat,
103059:                        nsIPrincipal* principalForSecurityCheck,
103059:                        bool forceWriteOnly,
103059:                        bool CORSUsed)
103059:     : mSurface(aSurface)
103059:     , mRepeat(aRepeat)
103059:     , mPrincipal(principalForSecurityCheck)
103059:     , mForceWriteOnly(forceWriteOnly)
103059:     , mCORSUsed(CORSUsed)
103059:   {
103059:   }
103059: 
103059:   NS_DECL_ISUPPORTS
103059: 
103059:   mozilla::RefPtr<mozilla::gfx::SourceSurface> mSurface;
103059:   const RepeatMode mRepeat;
103059:   nsCOMPtr<nsIPrincipal> mPrincipal;
103059:   const bool mForceWriteOnly;
103059:   const bool mCORSUsed;
103059: };
103059: 
103059: struct nsCanvasBidiProcessorAzure;
103059: class CanvasRenderingContext2DUserDataAzure;
103059: 
103059: /**
103059:  ** nsCanvasRenderingContext2DAzure
103059:  **/
103059: class nsCanvasRenderingContext2DAzure :
103059:   public nsIDOMCanvasRenderingContext2D,
103059:   public nsICanvasRenderingContextInternal,
103059:   public nsWrapperCache
103059: {
103059: typedef mozilla::dom::HTMLImageElementOrHTMLCanvasElementOrHTMLVideoElement
103059:   HTMLImageOrCanvasOrVideoElement;
103059: 
103059: public:
103059:   nsCanvasRenderingContext2DAzure();
103059:   virtual ~nsCanvasRenderingContext2DAzure();
103059: 
103330:   virtual JSObject* WrapObject(JSContext *cx, JSObject *scope,
103330:                                bool *triedToWrap);
103330: 
103059:   nsHTMLCanvasElement* GetCanvas() const
103059:   {
103059:     return mCanvasElement;
103059:   }
103059: 
103059:   void Save();
103059:   void Restore();
103059:   void Scale(double x, double y, mozilla::ErrorResult& error);
103059:   void Rotate(double angle, mozilla::ErrorResult& error);
103059:   void Translate(double x, double y, mozilla::ErrorResult& error);
103059:   void Transform(double m11, double m12, double m21, double m22, double dx,
103059:                  double dy, mozilla::ErrorResult& error);
103059:   void SetTransform(double m11, double m12, double m21, double m22, double dx,
103059:                     double dy, mozilla::ErrorResult& error);
103059: 
103059:   double GetGlobalAlpha()
103059:   {
103059:     return CurrentState().globalAlpha;
103059:   }
103059: 
103059:   void SetGlobalAlpha(double globalAlpha)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(globalAlpha) &&
103059:         globalAlpha >= 0.0 && globalAlpha <= 1.0) {
103059:       CurrentState().globalAlpha = globalAlpha;
103059:     }
103059:   }
103059: 
103059:   void GetGlobalCompositeOperation(nsAString& op, mozilla::ErrorResult& error);
103059:   void SetGlobalCompositeOperation(const nsAString& op,
103059:                                    mozilla::ErrorResult& error);
103059:   JS::Value GetStrokeStyle(JSContext* cx, mozilla::ErrorResult& error);
103059: 
103059:   void SetStrokeStyle(JSContext* cx, JS::Value& value)
103059:   {
103059:     SetStyleFromJSValue(cx, value, STYLE_STROKE);
103059:   }
103059: 
103059:   JS::Value GetFillStyle(JSContext* cx, mozilla::ErrorResult& error);
103059: 
103059:   void SetFillStyle(JSContext* cx, JS::Value& value)
103059:   {
103059:     SetStyleFromJSValue(cx, value, STYLE_FILL);
103059:   }
103059: 
103059:   already_AddRefed<nsIDOMCanvasGradient>
103059:     CreateLinearGradient(double x0, double y0, double x1, double y1,
103059:                          mozilla::ErrorResult& aError);
103059:   already_AddRefed<nsIDOMCanvasGradient>
103059:     CreateRadialGradient(double x0, double y0, double r0, double x1, double y1,
103059:                          double r1, mozilla::ErrorResult& aError);
103059:   already_AddRefed<nsIDOMCanvasPattern>
103059:     CreatePattern(const HTMLImageOrCanvasOrVideoElement& element,
103059:                   const nsAString& repeat, mozilla::ErrorResult& error);
103059: 
103059:   double GetShadowOffsetX()
103059:   {
103059:     return CurrentState().shadowOffset.x;
103059:   }
103059: 
103059:   void SetShadowOffsetX(double shadowOffsetX)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(shadowOffsetX)) {
103059:       CurrentState().shadowOffset.x = shadowOffsetX;
103059:     }
103059:   }
103059: 
103059:   double GetShadowOffsetY()
103059:   {
103059:     return CurrentState().shadowOffset.y;
103059:   }
103059: 
103059:   void SetShadowOffsetY(double shadowOffsetY)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(shadowOffsetY)) {
103059:       CurrentState().shadowOffset.y = shadowOffsetY;
103059:     }
103059:   }
103059: 
103059:   double GetShadowBlur()
103059:   {
103059:     return CurrentState().shadowBlur;
103059:   }
103059: 
103059:   void SetShadowBlur(double shadowBlur)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(shadowBlur) && shadowBlur >= 0.0) {
103059:       CurrentState().shadowBlur = shadowBlur;
103059:     }
103059:   }
103059: 
103059:   void GetShadowColor(nsAString& shadowColor)
103059:   {
103059:     StyleColorToString(CurrentState().shadowColor, shadowColor);
103059:   }
103059: 
103059:   void SetShadowColor(const nsAString& shadowColor);
103059:   void ClearRect(double x, double y, double w, double h);
103059:   void FillRect(double x, double y, double w, double h);
103059:   void StrokeRect(double x, double y, double w, double h);
103059:   void BeginPath();
103059:   void Fill();
103059:   void Stroke();
103059:   void Clip();
103059:   bool IsPointInPath(double x, double y);
103059:   void FillText(const nsAString& text, double x, double y,
103059:                 const mozilla::dom::Optional<double>& maxWidth,
103059:                 mozilla::ErrorResult& error);
103059:   void StrokeText(const nsAString& text, double x, double y,
103059:                   const mozilla::dom::Optional<double>& maxWidth,
103059:                   mozilla::ErrorResult& error);
103059:   already_AddRefed<nsIDOMTextMetrics>
103059:     MeasureText(const nsAString& rawText, mozilla::ErrorResult& error);
103059: 
103059:   void DrawImage(const HTMLImageOrCanvasOrVideoElement& image,
103059:                  double dx, double dy, mozilla::ErrorResult& error)
103059:   {
103059:     if (!mozilla::CanvasUtils::FloatValidate(dx, dy)) {
103059:       return;
103059:     }
103059:     DrawImage(image, 0.0, 0.0, 0.0, 0.0, dx, dy, 0.0, 0.0, 0, error);
103059:   }
103059: 
103059:   void DrawImage(const HTMLImageOrCanvasOrVideoElement& image,
103059:                  double dx, double dy, double dw, double dh,
103059:                  mozilla::ErrorResult& error)
103059:   {
103059:     if (!mozilla::CanvasUtils::FloatValidate(dx, dy, dw, dh)) {
103059:       return;
103059:     }
103059:     DrawImage(image, 0.0, 0.0, 0.0, 0.0, dx, dy, dw, dh, 2, error);
103059:   }
103059: 
103059:   void DrawImage(const HTMLImageOrCanvasOrVideoElement& image,
103059:                  double sx, double sy, double sw, double sh, double dx,
103059:                  double dy, double dw, double dh, mozilla::ErrorResult& error)
103059:   {
103059:     if (!mozilla::CanvasUtils::FloatValidate(sx, sy, sw, sh) ||
103059:         !mozilla::CanvasUtils::FloatValidate(dx, dy, dw, dh)) {
103059:       return;
103059:     }
103059:     DrawImage(image, sx, sy, sw, sh, dx, dy, dw, dh, 6, error);
103059:   }
103059: 
103059:   already_AddRefed<mozilla::dom::ImageData>
103059:     CreateImageData(JSContext* cx, double sw, double sh,
103059:                     mozilla::ErrorResult& error);
103059:   already_AddRefed<mozilla::dom::ImageData>
103059:     CreateImageData(JSContext* cx, mozilla::dom::ImageData* imagedata,
103059:                     mozilla::ErrorResult& error);
103059:   already_AddRefed<mozilla::dom::ImageData>
103059:     GetImageData(JSContext* cx, double sx, double sy, double sw, double sh,
103059:                  mozilla::ErrorResult& error);
103059:   void PutImageData(JSContext* cx, mozilla::dom::ImageData* imageData,
103059:                     double dx, double dy, mozilla::ErrorResult& error);
103059:   void PutImageData(JSContext* cx, mozilla::dom::ImageData* imageData,
103059:                     double dx, double dy, double dirtyX, double dirtyY,
103059:                     double dirtyWidth, double dirtyHeight,
103059:                     mozilla::ErrorResult& error);
103059: 
103059:   double GetLineWidth()
103059:   {
103059:     return CurrentState().lineWidth;
103059:   }
103059: 
103059:   void SetLineWidth(double width)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(width) && width > 0.0) {
103059:       CurrentState().lineWidth = width;
103059:     }
103059:   }
103059:   void GetLineCap(nsAString& linecap);
103059:   void SetLineCap(const nsAString& linecap);
103059:   void GetLineJoin(nsAString& linejoin, mozilla::ErrorResult& error);
103059:   void SetLineJoin(const nsAString& linejoin);
103059: 
103059:   double GetMiterLimit()
103059:   {
103059:     return CurrentState().miterLimit;
103059:   }
103059: 
103059:   void SetMiterLimit(double miter)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(miter) && miter > 0.0) {
103059:       CurrentState().miterLimit = miter;
103059:     }
103059:   }
103059: 
103059:   void GetFont(nsAString& font)
103059:   {
103059:     font = GetFont();
103059:   }
103059: 
103059:   void SetFont(const nsAString& font, mozilla::ErrorResult& error);
103059:   void GetTextAlign(nsAString& textAlign);
103059:   void SetTextAlign(const nsAString& textAlign);
103059:   void GetTextBaseline(nsAString& textBaseline);
103059:   void SetTextBaseline(const nsAString& textBaseline);
103059: 
103059:   void ClosePath()
103059:   {
103059:     EnsureWritablePath();
103059: 
103059:     if (mPathBuilder) {
103059:       mPathBuilder->Close();
103059:     } else {
103059:       mDSPathBuilder->Close();
103059:     }
103059:   }
103059: 
103059:   void MoveTo(double x, double y)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(x, y)) {
103059:       EnsureWritablePath();
103059: 
103059:       if (mPathBuilder) {
103059:         mPathBuilder->MoveTo(mozilla::gfx::Point(x, y));
103059:       } else {
103059:         mDSPathBuilder->MoveTo(mTarget->GetTransform() *
103059:                                  mozilla::gfx::Point(x, y));
103059:       }
103059:     }
103059:   }
103059: 
103059:   void LineTo(double x, double y)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(x, y)) {
103059:       EnsureWritablePath();
103059:     
103059:       LineTo(mozilla::gfx::Point(x, y));
103059:     }
103059:   }
103059: 
103059:   void QuadraticCurveTo(double cpx, double cpy, double x, double y)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(cpx, cpy, x, y)) {
103059:       EnsureWritablePath();
103059: 
103059:       if (mPathBuilder) {
103059:         mPathBuilder->QuadraticBezierTo(mozilla::gfx::Point(cpx, cpy),
103059:                                         mozilla::gfx::Point(x, y));
103059:       } else {
103059:         mozilla::gfx::Matrix transform = mTarget->GetTransform();
103059:         mDSPathBuilder->QuadraticBezierTo(transform *
103059:                                             mozilla::gfx::Point(cpx, cpy),
103059:                                           transform *
103059:                                             mozilla::gfx::Point(x, y));
103059:       }
103059:     }
103059:   }
103059: 
103059:   void BezierCurveTo(double cp1x, double cp1y, double cp2x, double cp2y, double x, double y)
103059:   {
103059:     if (mozilla::CanvasUtils::FloatValidate(cp1x, cp1y, cp2x, cp2y, x, y)) {
103059:       EnsureWritablePath();
103059: 
103059:       BezierTo(mozilla::gfx::Point(cp1x, cp1y),
103059:                mozilla::gfx::Point(cp2x, cp2y),
103059:                mozilla::gfx::Point(x, y));
103059:     }
103059:   }
103059: 
103059:   void ArcTo(double x1, double y1, double x2, double y2, double radius,
103059:              mozilla::ErrorResult& error);
103059:   void Rect(double x, double y, double w, double h);
103059:   void Arc(double x, double y, double radius, double startAngle,
103059:            double endAngle, bool anticlockwise, mozilla::ErrorResult& error);
103059: 
103059:   JSObject* GetMozCurrentTransform(JSContext* cx,
103059:                                    mozilla::ErrorResult& error) const;
103059:   void SetMozCurrentTransform(JSContext* cx, JSObject& currentTransform,
103059:                               mozilla::ErrorResult& error);
103059:   JSObject* GetMozCurrentTransformInverse(JSContext* cx,
103059:                                           mozilla::ErrorResult& error) const;
103059:   void SetMozCurrentTransformInverse(JSContext* cx, JSObject& currentTransform, 
103059:                                      mozilla::ErrorResult& error);
103059:   void GetFillRule(nsAString& fillRule);
103059:   void SetFillRule(const nsAString& fillRule);
103059:   JS::Value GetMozDash(JSContext* cx, mozilla::ErrorResult& error);
103059:   void SetMozDash(JSContext* cx, const JS::Value& mozDash,
103059:                   mozilla::ErrorResult& error);
103059: 
103059:   double GetMozDashOffset()
103059:   {
103059:     return CurrentState().dashOffset;
103059:   }
103059: 
103059:   void SetMozDashOffset(double mozDashOffset, mozilla::ErrorResult& error);
103059: 
103059:   void GetMozTextStyle(nsAString& mozTextStyle)
103059:   {
103059:     GetFont(mozTextStyle);
103059:   }
103059: 
103059:   void SetMozTextStyle(const nsAString& mozTextStyle,
103059:                        mozilla::ErrorResult& error)
103059:   {
103059:     SetFont(mozTextStyle, error);
103059:   }
103059: 
103059:   bool GetImageSmoothingEnabled()
103059:   {
103059:     return CurrentState().imageSmoothingEnabled;
103059:   }
103059: 
103059:   void SetImageSmoothingEnabled(bool imageSmoothingEnabled)
103059:   {
103059:     if (imageSmoothingEnabled != CurrentState().imageSmoothingEnabled) {
103059:       CurrentState().imageSmoothingEnabled = imageSmoothingEnabled;
103059:     }
103059:   }
103059: 
103059:   void DrawWindow(nsIDOMWindow* window, double x, double y, double w, double h,
103059:                   const nsAString& bgColor, uint32_t flags,
103059:                   mozilla::ErrorResult& error);
103059:   void AsyncDrawXULElement(nsIDOMXULElement* elem, double x, double y, double w,
103059:                            double h, const nsAString& bgColor, uint32_t flags,
103059:                            mozilla::ErrorResult& error);
103059: 
103059:   nsresult Redraw();
103059: 
103059:   // nsICanvasRenderingContextInternal
108991:   NS_IMETHOD SetDimensions(int32_t width, int32_t height);
108991:   NS_IMETHOD InitializeWithSurface(nsIDocShell *shell, gfxASurface *surface, int32_t width, int32_t height);
103059: 
103059:   NS_IMETHOD Render(gfxContext *ctx,
103059:                     gfxPattern::GraphicsFilter aFilter,
108991:                     uint32_t aFlags = RenderFlagPremultAlpha);
103059:   NS_IMETHOD GetInputStream(const char* aMimeType,
103059:                             const PRUnichar* aEncoderOptions,
103059:                             nsIInputStream **aStream);
103059:   NS_IMETHOD GetThebesSurface(gfxASurface **surface);
103059: 
103059:   mozilla::TemporaryRef<mozilla::gfx::SourceSurface> GetSurfaceSnapshot()
106838:   { return mTarget ? mTarget->Snapshot() : nullptr; }
103059: 
103059:   NS_IMETHOD SetIsOpaque(bool isOpaque);
103059:   NS_IMETHOD Reset();
103059:   already_AddRefed<CanvasLayer> GetCanvasLayer(nsDisplayListBuilder* aBuilder,
103059:                                                 CanvasLayer *aOldLayer,
103059:                                                 LayerManager *aManager);
106596:   virtual bool ShouldForceInactiveLayer(LayerManager *aManager);
103059:   void MarkContextClean();
103059:   NS_IMETHOD SetIsIPC(bool isIPC);
103059:   // this rect is in canvas device space
103059:   void Redraw(const mozilla::gfx::Rect &r);
103059:   NS_IMETHOD Redraw(const gfxRect &r) { Redraw(ToRect(r)); return NS_OK; }
103059: 
103059:   // this rect is in mTarget's current user space
103059:   void RedrawUser(const gfxRect &r);
103059: 
103059:   // nsISupports interface + CC
103059:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
103059: 
103059:   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsCanvasRenderingContext2DAzure,
103059:                                                                    nsIDOMCanvasRenderingContext2D)
103059: 
103059:   // nsIDOMCanvasRenderingContext2D interface
103059:   NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D
103059: 
103059:   enum Style {
103059:     STYLE_STROKE = 0,
103059:     STYLE_FILL,
103059:     STYLE_MAX
103059:   };
103059: 
103059:   nsINode* GetParentObject()
103059:   {
103059:     return mCanvasElement;
103059:   }
103059: 
103059:   void LineTo(const mozilla::gfx::Point& aPoint)
103059:   {
103059:     if (mPathBuilder) {
103059:       mPathBuilder->LineTo(aPoint);
103059:     } else {
103059:       mDSPathBuilder->LineTo(mTarget->GetTransform() * aPoint);
103059:     }
103059:   }
103059: 
103059:   void BezierTo(const mozilla::gfx::Point& aCP1,
103059:                 const mozilla::gfx::Point& aCP2,
103059:                 const mozilla::gfx::Point& aCP3)
103059:   {
103059:     if (mPathBuilder) {
103059:       mPathBuilder->BezierTo(aCP1, aCP2, aCP3);
103059:     } else {
103059:       mozilla::gfx::Matrix transform = mTarget->GetTransform();
103059:       mDSPathBuilder->BezierTo(transform * aCP1,
103059:                                 transform * aCP2,
103059:                                 transform * aCP3);
103059:     }
103059:   }
103059: 
103059:   friend class CanvasRenderingContext2DUserDataAzure;
103059: 
103059: protected:
103059:   nsresult GetImageDataArray(JSContext* aCx, int32_t aX, int32_t aY,
103059:                              uint32_t aWidth, uint32_t aHeight,
103059:                              JSObject** aRetval);
103059: 
106611:   /**
106611:    * Internal method to complete initialisation, expects mTarget to have been set
106611:    */
108991:   nsresult Initialize(int32_t width, int32_t height);
106611: 
103059:   nsresult InitializeWithTarget(mozilla::gfx::DrawTarget *surface,
108991:                                 int32_t width, int32_t height);
103059: 
103059:   /**
103059:     * The number of living nsCanvasRenderingContexts.  When this goes down to
103059:     * 0, we free the premultiply and unpremultiply tables, if they exist.
103059:     */
108991:   static uint32_t sNumLivingContexts;
103059: 
103059:   /**
103059:     * Lookup table used to speed up GetImageData().
103059:     */
108991:   static uint8_t (*sUnpremultiplyTable)[256];
103059: 
103059:   /**
103059:     * Lookup table used to speed up PutImageData().
103059:     */
108991:   static uint8_t (*sPremultiplyTable)[256];
103059: 
103059:   // Some helpers.  Doesn't modify a color on failure.
103059:   void SetStyleFromJSValue(JSContext* cx, JS::Value& value, Style whichStyle);
103059:   void SetStyleFromString(const nsAString& str, Style whichStyle);
103059: 
103059:   void SetStyleFromGradient(nsCanvasGradientAzure *gradient, Style whichStyle)
103059:   {
103059:     CurrentState().SetGradientStyle(whichStyle, gradient);
103059:   }
103059: 
103059:   void SetStyleFromPattern(nsCanvasPatternAzure *pattern, Style whichStyle)
103059:   {
103059:     CurrentState().SetPatternStyle(whichStyle, pattern);
103059:   }
103059: 
103059:   void SetStyleFromStringOrInterface(const nsAString& aStr, nsISupports *aInterface, Style aWhichStyle);
103059:   nsISupports* GetStyleAsStringOrInterface(nsAString& aStr, CanvasMultiGetterType& aType, Style aWhichStyle);
103059: 
103059:   // Returns whether a color was successfully parsed.
103059:   bool ParseColor(const nsAString& aString, nscolor* aColor);
103059: 
103059:   static void StyleColorToString(const nscolor& aColor, nsAString& aStr);
103059: 
103059:   /**
103059:     * Creates the unpremultiply lookup table, if it doesn't exist.
103059:     */
103059:   void EnsureUnpremultiplyTable();
103059: 
103059:   /**
103059:     * Creates the premultiply lookup table, if it doesn't exist.
103059:     */
103059:   void EnsurePremultiplyTable();
103059: 
103059:   /* This function ensures there is a writable pathbuilder available, this
103059:    * pathbuilder may be working in user space or in device space or
103059:    * device space.
106604:    * After calling this function mPathTransformWillUpdate will be false
103059:    */
103059:   void EnsureWritablePath();
103059: 
103059:   // Ensures a path in UserSpace is available.
106604:   // If aCommitTransform is true, then any transform on the context will be
106604:   // used for the path.
106604:   void EnsureUserSpacePath(bool aCommitTransform = true);
103059: 
103059:   void TransformWillUpdate();
103059: 
103059:   // Report the fillRule has changed.
103059:   void FillRuleChanged();
103059: 
103059:   /**
103059:     * Returns the surface format this canvas should be allocated using. Takes
103059:     * into account mOpaque, platform requirements, etc.
103059:     */
103059:   mozilla::gfx::SurfaceFormat GetSurfaceFormat() const;
103059: 
103059:   void DrawImage(const HTMLImageOrCanvasOrVideoElement &imgElt,
103059:                  double sx, double sy, double sw, double sh,
103059:                  double dx, double dy, double dw, double dh, 
108991:                  uint8_t optional_argc, mozilla::ErrorResult& error);
103059: 
103059:   nsString& GetFont()
103059:   {
103059:     /* will initilize the value if not set, else does nothing */
103059:     GetCurrentFontStyle();
103059: 
103059:     return CurrentState().font;
103059:   }
103059: 
103059:   static bool
103059:   ToHTMLImageOrCanvasOrVideoElement(nsIDOMElement* html,
103059:                                     HTMLImageOrCanvasOrVideoElement& element)
103059:   {
103059:     nsCOMPtr<nsIContent> content = do_QueryInterface(html);
103059:     if (content) {
103059:       if (content->IsHTML(nsGkAtoms::canvas)) {
103059:         element.SetAsHTMLCanvasElement() =
103059:           static_cast<nsHTMLCanvasElement*>(html);
103059:         return true;
103059:       }
103059:       if (content->IsHTML(nsGkAtoms::img)) {
103059:         element.SetAsHTMLImageElement() =
103059:           static_cast<nsHTMLImageElement*>(html);
103059:         return true;
103059:       }
103059:       if (content->IsHTML(nsGkAtoms::video)) {
103059:         element.SetAsHTMLVideoElement() =
103059:           static_cast<nsHTMLVideoElement*>(html);
103059:         return true;
103059:       }
103059:     }
103059: 
103059:     return false;
103059:   }
103059: 
103059:   // Member vars
108991:   int32_t mWidth, mHeight;
103059: 
111232:   // This is true when the canvas is valid, false otherwise, this occurs when
111232:   // for some reason initialization of the drawtarget fails. If the canvas
111232:   // is invalid certain behavior is expected.
111232:   bool mValid;
103059:   // This is true when the canvas is valid, but of zero size, this requires
103059:   // specific behavior on some operations.
103059:   bool mZero;
103059: 
103059:   bool mOpaque;
103059: 
103059:   // This is true when the next time our layer is retrieved we need to
103059:   // recreate it (i.e. our backing surface changed)
103059:   bool mResetLayer;
103059:   // This is needed for drawing in drawAsyncXULElement
103059:   bool mIPC;
103059: 
103059:   nsTArray<CanvasRenderingContext2DUserDataAzure*> mUserDatas;
103059: 
103059:   // If mCanvasElement is not provided, then a docshell is
103059:   nsCOMPtr<nsIDocShell> mDocShell;
103059: 
111232:   // our drawing surfaces, contexts, and layers
103059:   mozilla::RefPtr<mozilla::gfx::DrawTarget> mTarget;
103059: 
103059:   /**
103059:     * Flag to avoid duplicate calls to InvalidateFrame. Set to true whenever
103059:     * Redraw is called, reset to false when Render is called.
103059:     */
103059:   bool mIsEntireFrameInvalid;
103059:   /**
103059:     * When this is set, the first call to Redraw(gfxRect) should set
103059:     * mIsEntireFrameInvalid since we expect it will be followed by
103059:     * many more Redraw calls.
103059:     */
103059:   bool mPredictManyRedrawCalls;
103059: 
103059:   // This is stored after GetThebesSurface has been called once to avoid
103059:   // excessive ThebesSurface initialization overhead.
103059:   nsRefPtr<gfxASurface> mThebesSurface;
103059: 
103059:   /**
103059:     * We also have a device space pathbuilder. The reason for this is as
103059:     * follows, when a path is being built, but the transform changes, we
103059:     * can no longer keep a single path in userspace, considering there's
103059:     * several 'user spaces' now. We therefore transform the current path
103059:     * into device space, and add all operations to this path in device
103059:     * space.
103059:     *
103059:     * When then finally executing a render, the Azure drawing API expects
103059:     * the path to be in userspace. We could then set an identity transform
103059:     * on the DrawTarget and do all drawing in device space. This is
103059:     * undesirable because it requires transforming patterns, gradients,
103059:     * clips, etc. into device space and it would not work for stroking.
103059:     * What we do instead is convert the path back to user space when it is
103059:     * drawn, and draw it with the current transform. This makes all drawing
103059:     * occur correctly.
103059:     *
103059:     * There's never both a device space path builder and a user space path
103059:     * builder present at the same time. There is also never a path and a
103059:     * path builder present at the same time. When writing proceeds on an
103059:     * existing path the Path is cleared and a new builder is created.
103059:     *
103059:     * mPath is always in user-space.
103059:     */
103059:   mozilla::RefPtr<mozilla::gfx::Path> mPath;
103059:   mozilla::RefPtr<mozilla::gfx::PathBuilder> mDSPathBuilder;
103059:   mozilla::RefPtr<mozilla::gfx::PathBuilder> mPathBuilder;
103059:   bool mPathTransformWillUpdate;
103059:   mozilla::gfx::Matrix mPathToDS;
103059: 
103059:   /**
103059:     * Number of times we've invalidated before calling redraw
103059:     */
108991:   uint32_t mInvalidateCount;
108991:   static const uint32_t kCanvasMaxInvalidateCount = 100;
103059: 
103059:   /**
103059:     * Returns true if a shadow should be drawn along with a
103059:     * drawing operation.
103059:     */
103059:   bool NeedToDrawShadow()
103059:   {
103059:     const ContextState& state = CurrentState();
103059: 
103059:     // The spec says we should not draw shadows if the operator is OVER.
103059:     // If it's over and the alpha value is zero, nothing needs to be drawn.
103059:     return NS_GET_A(state.shadowColor) != 0 && 
103059:       (state.shadowBlur != 0 || state.shadowOffset.x != 0 || state.shadowOffset.y != 0);
103059:   }
103059: 
103059:   mozilla::gfx::CompositionOp UsedOperation()
103059:   {
103059:     if (NeedToDrawShadow()) {
103059:       // In this case the shadow rendering will use the operator.
103059:       return mozilla::gfx::OP_OVER;
103059:     }
103059: 
103059:     return CurrentState().op;
103059:   }
103059: 
103059:   /**
103059:     * Gets the pres shell from either the canvas element or the doc shell
103059:     */
103059:   nsIPresShell *GetPresShell() {
103059:     if (mCanvasElement) {
103059:       return mCanvasElement->OwnerDoc()->GetShell();
103059:     }
103059:     if (mDocShell) {
103059:       nsCOMPtr<nsIPresShell> shell;
103059:       mDocShell->GetPresShell(getter_AddRefs(shell));
103059:       return shell.get();
103059:     }
106838:     return nullptr;
103059:   }
103059: 
103059:   // text
103059:   enum TextAlign {
103059:     TEXT_ALIGN_START,
103059:     TEXT_ALIGN_END,
103059:     TEXT_ALIGN_LEFT,
103059:     TEXT_ALIGN_RIGHT,
103059:     TEXT_ALIGN_CENTER
103059:   };
103059: 
103059:   enum TextBaseline {
103059:     TEXT_BASELINE_TOP,
103059:     TEXT_BASELINE_HANGING,
103059:     TEXT_BASELINE_MIDDLE,
103059:     TEXT_BASELINE_ALPHABETIC,
103059:     TEXT_BASELINE_IDEOGRAPHIC,
103059:     TEXT_BASELINE_BOTTOM
103059:   };
103059: 
103059:   gfxFontGroup *GetCurrentFontStyle();
103059: 
103059:   enum TextDrawOperation {
103059:     TEXT_DRAW_OPERATION_FILL,
103059:     TEXT_DRAW_OPERATION_STROKE,
103059:     TEXT_DRAW_OPERATION_MEASURE
103059:   };
103059: 
103059:   /*
103059:     * Implementation of the fillText, strokeText, and measure functions with
103059:     * the operation abstracted to a flag.
103059:     */
103059:   nsresult DrawOrMeasureText(const nsAString& text,
103059:                               float x,
103059:                               float y,
103059:                               const mozilla::dom::Optional<double>& maxWidth,
103059:                               TextDrawOperation op,
103059:                               float* aWidth);
103059: 
103059:   // state stack handling
103059:   class ContextState {
103059:   public:
103059:       ContextState() : textAlign(TEXT_ALIGN_START),
103059:                        textBaseline(TEXT_BASELINE_ALPHABETIC),
103059:                        lineWidth(1.0f),
103059:                        miterLimit(10.0f),
103059:                        globalAlpha(1.0f),
103059:                        shadowBlur(0.0),
103059:                        dashOffset(0.0f),
103059:                        op(mozilla::gfx::OP_OVER),
103059:                        fillRule(mozilla::gfx::FILL_WINDING),
103059:                        lineCap(mozilla::gfx::CAP_BUTT),
103059:                        lineJoin(mozilla::gfx::JOIN_MITER_OR_BEVEL),
103059:                        imageSmoothingEnabled(true)
103059:       { }
103059: 
103059:       ContextState(const ContextState& other)
103059:           : fontGroup(other.fontGroup),
103059:             font(other.font),
103059:             textAlign(other.textAlign),
103059:             textBaseline(other.textBaseline),
103059:             shadowColor(other.shadowColor),
103059:             transform(other.transform),
103059:             shadowOffset(other.shadowOffset),
103059:             lineWidth(other.lineWidth),
103059:             miterLimit(other.miterLimit),
103059:             globalAlpha(other.globalAlpha),
103059:             shadowBlur(other.shadowBlur),
103059:             dash(other.dash),
103059:             dashOffset(other.dashOffset),
103059:             op(other.op),
103059:             fillRule(other.fillRule),
103059:             lineCap(other.lineCap),
103059:             lineJoin(other.lineJoin),
103059:             imageSmoothingEnabled(other.imageSmoothingEnabled)
103059:       {
103059:           for (int i = 0; i < STYLE_MAX; i++) {
103059:               colorStyles[i] = other.colorStyles[i];
103059:               gradientStyles[i] = other.gradientStyles[i];
103059:               patternStyles[i] = other.patternStyles[i];
103059:           }
103059:       }
103059: 
103059:       void SetColorStyle(Style whichStyle, nscolor color) {
103059:           colorStyles[whichStyle] = color;
106838:           gradientStyles[whichStyle] = nullptr;
106838:           patternStyles[whichStyle] = nullptr;
103059:       }
103059: 
103059:       void SetPatternStyle(Style whichStyle, nsCanvasPatternAzure* pat) {
106838:           gradientStyles[whichStyle] = nullptr;
103059:           patternStyles[whichStyle] = pat;
103059:       }
103059: 
103059:       void SetGradientStyle(Style whichStyle, nsCanvasGradientAzure* grad) {
103059:           gradientStyles[whichStyle] = grad;
106838:           patternStyles[whichStyle] = nullptr;
103059:       }
103059: 
103059:       /**
103059:         * returns true iff the given style is a solid color.
103059:         */
103059:       bool StyleIsColor(Style whichStyle) const
103059:       {
103059:           return !(patternStyles[whichStyle] || gradientStyles[whichStyle]);
103059:       }
103059: 
103059: 
103059:       std::vector<mozilla::RefPtr<mozilla::gfx::Path> > clipsPushed;
103059: 
103059:       nsRefPtr<gfxFontGroup> fontGroup;
103059:       nsRefPtr<nsCanvasGradientAzure> gradientStyles[STYLE_MAX];
103059:       nsRefPtr<nsCanvasPatternAzure> patternStyles[STYLE_MAX];
103059: 
103059:       nsString font;
103059:       TextAlign textAlign;
103059:       TextBaseline textBaseline;
103059: 
103059:       nscolor colorStyles[STYLE_MAX];
103059:       nscolor shadowColor;
103059: 
103059:       mozilla::gfx::Matrix transform;
103059:       mozilla::gfx::Point shadowOffset;
103059:       mozilla::gfx::Float lineWidth;
103059:       mozilla::gfx::Float miterLimit;
103059:       mozilla::gfx::Float globalAlpha;
103059:       mozilla::gfx::Float shadowBlur;
103059:       FallibleTArray<mozilla::gfx::Float> dash;
103059:       mozilla::gfx::Float dashOffset;
103059: 
103059:       mozilla::gfx::CompositionOp op;
103059:       mozilla::gfx::FillRule fillRule;
103059:       mozilla::gfx::CapStyle lineCap;
103059:       mozilla::gfx::JoinStyle lineJoin;
103059: 
103059:       bool imageSmoothingEnabled;
103059:   };
103059: 
103059:   nsAutoTArray<ContextState, 3> mStyleStack;
103059: 
103059:   inline ContextState& CurrentState() {
103059:     return mStyleStack[mStyleStack.Length() - 1];
103059:   }
103059: 
103252:   friend class CanvasGeneralPattern;
103059:   friend class AdjustedTarget;
103059: 
103059:   // other helpers
108991:   void GetAppUnitsValues(uint32_t *perDevPixel, uint32_t *perCSSPixel) {
103059:     // If we don't have a canvas element, we just return something generic.
108991:     uint32_t devPixel = 60;
108991:     uint32_t cssPixel = 60;
103059: 
103059:     nsIPresShell *ps = GetPresShell();
103059:     nsPresContext *pc;
103059: 
103059:     if (!ps) goto FINISH;
103059:     pc = ps->GetPresContext();
103059:     if (!pc) goto FINISH;
103059:     devPixel = pc->AppUnitsPerDevPixel();
103059:     cssPixel = pc->AppUnitsPerCSSPixel();
103059: 
103059:   FINISH:
103059:     if (perDevPixel)
103059:       *perDevPixel = devPixel;
103059:     if (perCSSPixel)
103059:       *perCSSPixel = cssPixel;
103059:   }
103059: 
103059:   friend struct nsCanvasBidiProcessorAzure;
103059: };
103059: 
103059: #endif /* nsCanvasRenderingContext2DAzure_h */
