 3129: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 3129: /* ***** BEGIN LICENSE BLOCK *****
 3129:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 3129:  *
 3129:  * The contents of this file are subject to the Mozilla Public License Version
 3129:  * 1.1 (the "License"); you may not use this file except in compliance with
 3129:  * the License. You may obtain a copy of the License at
 3129:  * http://www.mozilla.org/MPL/
 3129:  *
 3129:  * Software distributed under the License is distributed on an "AS IS" basis,
 3129:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 3129:  * for the specific language governing rights and limitations under the
 3129:  * License.
 3129:  *
 3129:  * The Original Code is mozilla.org code.
 3129:  *
 3129:  * The Initial Developer of the Original Code is Neil Deakin
 3129:  * Portions created by the Initial Developer are Copyright (C) 2006
 3129:  * the Initial Developer. All Rights Reserved.
 3129:  *
 3129:  * Contributor(s):
 3129:  *
 3129:  * Alternatively, the contents of this file may be used under the terms of
 3129:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 3129:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 3129:  * in which case the provisions of the GPL or the LGPL are applicable instead
 3129:  * of those above. If you wish to allow use of your version of this file only
 3129:  * under the terms of either the GPL or the LGPL, and not to allow others to
 3129:  * use your version of this file under the terms of the MPL, indicate your
 3129:  * decision by deleting the provisions above and replace them with the notice
 3129:  * and other provisions required by the GPL or the LGPL. If you do not delete
 3129:  * the provisions above, a recipient may use your version of this file under
 3129:  * the terms of any one of the MPL, the GPL or the LGPL.
 3129:  *
 3129:  * ***** END LICENSE BLOCK ***** */
 3129: 
 3129: #include "nsGkAtoms.h"
 3129: #include "nsXULPopupManager.h"
 3129: #include "nsMenuFrame.h"
 3129: #include "nsMenuPopupFrame.h"
 3129: #include "nsMenuBarFrame.h"
 3129: #include "nsIPopupBoxObject.h"
 3129: #include "nsMenuBarListener.h"
 3129: #include "nsContentUtils.h"
 3129: #include "nsIDOMDocument.h"
 3129: #include "nsIDOMNSEvent.h"
 3129: #include "nsIDOMNSUIEvent.h"
12021: #include "nsIDOMXULElement.h"
12021: #include "nsIXULTemplateBuilder.h"
 3560: #include "nsIPrivateDOMEvent.h"
 3129: #include "nsEventDispatcher.h"
 3804: #include "nsEventStateManager.h"
 3129: #include "nsCSSFrameConstructor.h"
 3129: #include "nsLayoutUtils.h"
 3129: #include "nsIViewManager.h"
 3129: #include "nsILookAndFeel.h"
 3129: #include "nsIComponentManager.h"
 3129: #include "nsITimer.h"
29018: #include "nsFocusManager.h"
 3129: #include "nsIDocShellTreeItem.h"
 3129: #include "nsIDocShell.h"
 3129: #include "nsPIDOMWindow.h"
 3129: #include "nsIInterfaceRequestorUtils.h"
 3129: #include "nsIBaseWindow.h"
11414: #include "nsIDocShellTreeItem.h"
11962: #include "nsIDOMMouseEvent.h"
15969: #include "nsCaret.h"
13787: #include "nsIDocument.h"
13787: #include "nsPIDOMWindow.h"
30532: #include "nsFrameManager.h"
 3129: 
23190: const nsNavigationDirection DirectionFromKeyCodeTable[2][6] = {
23190:   {
 3534:     eNavigationDirection_Last,   // NS_VK_END
 3534:     eNavigationDirection_First,  // NS_VK_HOME
 3534:     eNavigationDirection_Start,  // NS_VK_LEFT
 3534:     eNavigationDirection_Before, // NS_VK_UP
 3534:     eNavigationDirection_End,    // NS_VK_RIGHT
 3534:     eNavigationDirection_After   // NS_VK_DOWN
23190:   },
23190:   {
 3534:     eNavigationDirection_Last,   // NS_VK_END
 3534:     eNavigationDirection_First,  // NS_VK_HOME
 3534:     eNavigationDirection_End,    // NS_VK_LEFT
 3534:     eNavigationDirection_Before, // NS_VK_UP
 3534:     eNavigationDirection_Start,  // NS_VK_RIGHT
 3534:     eNavigationDirection_After   // NS_VK_DOWN
23190:   }
 3534: };
 3534: 
 3129: nsXULPopupManager* nsXULPopupManager::sInstance = nsnull;
 3129: 
 3129: nsIContent* nsMenuChainItem::Content()
 3129: {
 3129:   return mFrame->GetContent();
 3129: }
 3129: 
 3129: void nsMenuChainItem::SetParent(nsMenuChainItem* aParent)
 3129: {
 3129:   if (mParent) {
 3129:     NS_ASSERTION(mParent->mChild == this, "Unexpected - parent's child not set to this");
 3129:     mParent->mChild = nsnull;
 3129:   }
 3129:   mParent = aParent;
 3129:   if (mParent) {
 3129:     if (mParent->mChild)
 3129:       mParent->mChild->mParent = nsnull;
 3129:     mParent->mChild = this;
 3129:   }
 3129: }
 3129: 
 3129: void nsMenuChainItem::Detach(nsMenuChainItem** aRoot)
 3129: {
 3129:   // If the item has a child, set the child's parent to this item's parent,
 3129:   // effectively removing the item from the chain. If the item has no child,
 3129:   // just set the parent to null.
 3129:   if (mChild) {
 3129:     NS_ASSERTION(this != *aRoot, "Unexpected - popup with child at end of chain");
 3129:     mChild->SetParent(mParent);
 3129:   }
 3129:   else {
 3129:     // An item without a child should be the first item in the chain, so set
 3129:     // the first item pointer, pointed to by aRoot, to the parent.
 3129:     NS_ASSERTION(this == *aRoot, "Unexpected - popup with no child not at end of chain");
 3129:     *aRoot = mParent;
 3129:     SetParent(nsnull);
 3129:   }
 3129: }
 3129: 
36806: NS_IMPL_ISUPPORTS4(nsXULPopupManager,
13964:                    nsIDOMKeyListener,
13964:                    nsIDOMEventListener,
13964:                    nsIMenuRollup,
13964:                    nsITimerCallback)
 3129: 
 3129: nsXULPopupManager::nsXULPopupManager() :
 3129:   mRangeOffset(0),
30532:   mCachedMousePoint(0, 0),
 3129:   mActiveMenuBar(nsnull),
22371:   mPopups(nsnull),
22371:   mNoHidePanels(nsnull),
 3129:   mTimerMenu(nsnull)
 3129: {
 3129: }
 3129: 
 3129: nsXULPopupManager::~nsXULPopupManager() 
 3129: {
22371:   NS_ASSERTION(!mPopups && !mNoHidePanels, "XUL popups still open");
 3129: }
 3129: 
 3129: nsresult
 3129: nsXULPopupManager::Init()
 3129: {
 3129:   sInstance = new nsXULPopupManager();
 3129:   NS_ENSURE_TRUE(sInstance, NS_ERROR_OUT_OF_MEMORY);
 3129:   NS_ADDREF(sInstance);
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::Shutdown()
 3129: {
 3390:   NS_IF_RELEASE(sInstance);
 3129: }
 3129: 
 3129: nsXULPopupManager*
 3129: nsXULPopupManager::GetInstance()
 3129: {
 3129:   return sInstance;
 3129: }
 3129: 
 3129: NS_IMETHODIMP
29148: nsXULPopupManager::Rollup(PRUint32 aCount, nsIContent** aLastRolledUp)
 3129: {
 8591:   if (aLastRolledUp)
 8591:     *aLastRolledUp = nsnull;
 8591: 
 6051:   nsMenuChainItem* item = GetTopVisibleMenu();
 8591:   if (item) {
 8591:     if (aLastRolledUp) {
 8591:       // we need to get the popup that will be closed last, so that
 8591:       // widget can keep track of it so it doesn't reopen if a mouse
 8591:       // down event is going to processed.
 8591:       // Keep going up the menu chain to get the first level menu. This will
 8591:       // be the one that closes up last. It's possible that this menu doesn't
 8591:       // end up closing because the popuphiding event was cancelled, but in
 8591:       // that case we don't need to deal with the menu reopening as it will
 8591:       // already still be open.
 8591:       nsMenuChainItem* first = item;
 8591:       while (first->GetParent())
 8591:         first = first->GetParent();
 8591:       NS_ADDREF(*aLastRolledUp = first->Content());
 8591:     }
29148: 
29148:     // if a number of popups to close has been specified, determine the last
29148:     // popup to close
29148:     nsIContent* lastPopup = nsnull;
29148:     if (aCount != PR_UINT32_MAX) {
29148:       nsMenuChainItem* last = item;
29148:       while (--aCount && last->GetParent()) {
29148:         last = last->GetParent();
29148:       }
29148:       if (last) {
29148:         lastPopup = last->Content();
29148:       }
29148:     }
29148: 
29148:     HidePopup(item->Content(), PR_TRUE, PR_TRUE, PR_FALSE, lastPopup);
 8591:   }
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: ////////////////////////////////////////////////////////////////////////
 3129: NS_IMETHODIMP nsXULPopupManager::ShouldRollupOnMouseWheelEvent(PRBool *aShouldRollup) 
 3129: {
 3129:   // should rollup only for autocomplete widgets
 3129:   // XXXndeakin this should really be something the popup has more control over
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 4668:   *aShouldRollup = (item && !item->Frame()->IsMenu()); 
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: // a menu should not roll up if activated by a mouse activate message (eg. X-mouse)
 3129: NS_IMETHODIMP nsXULPopupManager::ShouldRollupOnMouseActivate(PRBool *aShouldRollup) 
 3129: {
 3129:   *aShouldRollup = PR_FALSE;
 3129:   return NS_OK;
 3129: }
 3129: 
29148: PRUint32
29148: nsXULPopupManager::GetSubmenuWidgetChain(nsTArray<nsIWidget*> *aWidgetChain)
 3129: {
 4407:   // this method is used by the widget code to determine the list of popups
 4407:   // that are open. If a mouse click occurs outside one of these popups, the
 4407:   // panels will roll up. If the click is inside a popup, they will not roll up
29148:   PRUint32 count = 0, sameTypeCount = 0;
29148: 
29148:   NS_ASSERTION(aWidgetChain, "null parameter");
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 3129:   while (item) {
 3129:     nsCOMPtr<nsIWidget> widget;
 3129:     item->Frame()->GetWidget(getter_AddRefs(widget));
 6048:     NS_ASSERTION(widget, "open popup has no widget");
29148:     aWidgetChain->AppendElement(widget.get());
 4407:     // In the case when a menulist inside a panel is open, clicking in the
 4407:     // panel should still roll up the menu, so if a different type is found,
 4407:     // stop scanning.
 4407:     nsMenuChainItem* parent = item->GetParent();
29148:     if (!sameTypeCount) {
29148:       count++;
 7728:       if (!parent || item->Frame()->PopupType() != parent->Frame()->PopupType() ||
29148:                      item->IsContextMenu() != parent->IsContextMenu()) {
29148:         sameTypeCount = count;
29148:       }
29148:     }
 4407:     item = parent;
 3129:   }
29148: 
29148:   return sameTypeCount;
 3129: }
 3129: 
10353: void
 8408: nsXULPopupManager::AdjustPopupsOnWindowChange()
 8408: {
22371:   // Panels with noautohide="true" are moved and kept aligned with the anchor
22371:   // when the parent window moves. Dismissable menus and panels are expected
22371:   // to roll up when a window is moved, so there is no need to check these.
22371:   nsMenuChainItem* item = mNoHidePanels;
 8408:   while (item) {
 8408:     // if the auto positioning has been disabled, don't move the popup
 8408:     if (item->Frame()->GetAutoPosition())
36614:       item->Frame()->SetPopupPosition(nsnull);
 8408:     item = item->GetParent();
 8408:   }
 8408: }
 8408: 
 3129: nsIFrame*
 3129: nsXULPopupManager::GetFrameOfTypeForContent(nsIContent* aContent,
 6743:                                             nsIAtom* aFrameType,
 6743:                                             PRBool aShouldFlush)
 3129: {
 3129:   nsIDocument *document = aContent->GetCurrentDoc();
 3129:   if (document) {
 6743:     nsCOMPtr<nsIPresShell> presShell = document->GetPrimaryShell();
 3129:     if (presShell) {
 6743:       if (aShouldFlush)
 6743:         presShell->FlushPendingNotifications(Flush_Frames);
 6743: 
36656:       nsIFrame* frame = aContent->GetPrimaryFrame();
 3129:       if (frame && frame->GetType() == aFrameType)
 3129:         return frame;
 3129:     }
 3129:   }
 3129: 
 3129:   return nsnull;
 3129: }
 3129: 
 3129: nsMenuFrame*
 3129: nsXULPopupManager::GetMenuFrameForContent(nsIContent* aContent)
 3129: {
 6743:   // as ShowMenu is called from frames, don't flush to be safe.
 3233:   return static_cast<nsMenuFrame *>
 6743:                     (GetFrameOfTypeForContent(aContent, nsGkAtoms::menuFrame, PR_FALSE));
 3129: }
 3129: 
 3129: nsMenuPopupFrame*
 3129: nsXULPopupManager::GetPopupFrameForContent(nsIContent* aContent)
 3129: {
 3233:   return static_cast<nsMenuPopupFrame *>
 6743:                     (GetFrameOfTypeForContent(aContent, nsGkAtoms::menuPopupFrame, PR_TRUE));
 3129: }
 3129: 
 4668: nsMenuChainItem*
 4668: nsXULPopupManager::GetTopVisibleMenu()
 4668: {
22371:   nsMenuChainItem* item = mPopups;
 4668:   while (item && item->Frame()->PopupState() == ePopupInvisible)
 4668:     item = item->GetParent();
 4668:   return item;
 4668: }
 4668: 
 3129: void
 3129: nsXULPopupManager::GetMouseLocation(nsIDOMNode** aNode, PRInt32* aOffset)
 3129: {
 3129:   *aNode = mRangeParent;
 3129:   NS_IF_ADDREF(*aNode);
 3129:   *aOffset = mRangeOffset;
 3129: }
 3129: 
 3129: void
 8127: nsXULPopupManager::SetTriggerEvent(nsIDOMEvent* aEvent, nsIContent* aPopup)
 3129: {
23738:   mCachedMousePoint = nsIntPoint(0, 0);
 3560: 
 3129:   nsCOMPtr<nsIDOMNSUIEvent> uiEvent = do_QueryInterface(aEvent);
 3129:   if (uiEvent) {
 3129:     uiEvent->GetRangeParent(getter_AddRefs(mRangeParent));
 3129:     uiEvent->GetRangeOffset(&mRangeOffset);
 3560: 
 3560:     // get the event coordinates relative to the root frame of the document
 3560:     // containing the popup.
 3560:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aEvent));
 3560:     if (privateEvent) {
 3560:       NS_ASSERTION(aPopup, "Expected a popup node");
 3560:       nsEvent* event;
20234:       event = privateEvent->GetInternalNSEvent();
20234:       if (event) {
 3560:         nsIDocument* doc = aPopup->GetCurrentDoc();
 3560:         if (doc) {
 3560:           nsIPresShell* presShell = doc->GetPrimaryShell();
11962:           if (presShell && presShell->GetPresContext()) {
30532:             nsPresContext* rootDocPresContext =
37502:               presShell->GetPresContext()->GetRootPresContext();
37502:             if (!rootDocPresContext)
37502:               return;
30532:             nsIFrame* rootDocumentRootFrame = rootDocPresContext->
30532:                 PresShell()->FrameManager()->GetRootFrame();
11962:             if ((event->eventStructType == NS_MOUSE_EVENT || 
11962:                  event->eventStructType == NS_MOUSE_SCROLL_EVENT) &&
11962:                  !(static_cast<nsGUIEvent *>(event))->widget) {
11962:               // no widget, so just use the client point if available
11962:               nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
30532:               nsIntPoint clientPt;
30532:               mouseEvent->GetClientX(&clientPt.x);
30532:               mouseEvent->GetClientY(&clientPt.y);
11962: 
30532:               // XXX this doesn't handle IFRAMEs in transforms
30532:               nsPoint thisDocToRootDocOffset =
30532:                 presShell->FrameManager()->GetRootFrame()->GetOffsetTo(rootDocumentRootFrame);
11962:               // convert to device pixels
30532:               mCachedMousePoint.x = rootDocPresContext->AppUnitsToDevPixels(
30532:                   nsPresContext::CSSPixelsToAppUnits(clientPt.x) + thisDocToRootDocOffset.x);
30532:               mCachedMousePoint.y = rootDocPresContext->AppUnitsToDevPixels(
30532:                   nsPresContext::CSSPixelsToAppUnits(clientPt.y) + thisDocToRootDocOffset.y);
11962:             }
30532:             else if (rootDocumentRootFrame) {
 3560:               nsPoint pnt =
30532:                 nsLayoutUtils::GetEventCoordinatesRelativeTo(event, rootDocumentRootFrame);
30532:               mCachedMousePoint = nsIntPoint(rootDocPresContext->AppUnitsToDevPixels(pnt.x),
30532:                                              rootDocPresContext->AppUnitsToDevPixels(pnt.y));
 3560:             }
 3560:           }
 3560:         }
 3560:       }
 3560:     }
 3129:   }
 3129:   else {
 3129:     mRangeParent = nsnull;
 3129:     mRangeOffset = 0;
 3129:   }
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::SetActiveMenuBar(nsMenuBarFrame* aMenuBar, PRBool aActivate)
 3129: {
 3129:   if (aActivate)
 3129:     mActiveMenuBar = aMenuBar;
 3129:   else if (mActiveMenuBar == aMenuBar)
 3129:     mActiveMenuBar = nsnull;
 3129: 
 3129:   UpdateKeyboardListeners();
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::ShowMenu(nsIContent *aMenu,
 3129:                             PRBool aSelectFirstItem,
 3129:                             PRBool aAsynchronous)
 3129: {
12021:   // generate any template content first. Otherwise, the menupopup may not
12021:   // have been created yet.
12021:   if (aMenu) {
12021:     nsIContent* element = aMenu;
12021:     do {
12021:       nsCOMPtr<nsIDOMXULElement> xulelem = do_QueryInterface(element);
12021:       if (xulelem) {
12021:         nsCOMPtr<nsIXULTemplateBuilder> builder;
12021:         xulelem->GetBuilder(getter_AddRefs(builder));
12021:         if (builder) {
12021:           builder->CreateContents(aMenu, PR_TRUE);
12021:           break;
12021:         }
12021:       }
12021:       element = element->GetParent();
12021:     } while (element);
12021:   }
12021: 
 3129:   nsMenuFrame* menuFrame = GetMenuFrameForContent(aMenu);
 3129:   if (!menuFrame || !menuFrame->IsMenu())
 3129:     return;
 3129: 
 3129:   nsMenuPopupFrame* popupFrame =  menuFrame->GetPopup();
 3129:   if (!popupFrame || !MayShowPopup(popupFrame))
 3129:     return;
 3129: 
 3129:   // inherit whether or not we're a context menu from the parent
 3129:   PRBool parentIsContextMenu = PR_FALSE;
 3129:   PRBool onMenuBar = PR_FALSE;
 3129:   PRBool onmenu = menuFrame->IsOnMenu();
 3129: 
22372:   nsMenuParent* parent = menuFrame->GetMenuParent();
 3129:   if (parent && onmenu) {
 3129:     parentIsContextMenu = parent->IsContextMenu();
 3129:     onMenuBar = parent->IsMenuBar();
 3129:   }
 3129: 
 3129:   nsAutoString position;
 3129:   if (onMenuBar || !onmenu)
 3129:     position.AssignLiteral("after_start");
 3129:   else
 3129:     position.AssignLiteral("end_before");
 3129:   popupFrame->InitializePopup(aMenu, position, 0, 0, PR_TRUE);
 3129: 
 3129:   if (aAsynchronous) {
 8127:     SetTriggerEvent(nsnull, nsnull);
 3129:     nsCOMPtr<nsIRunnable> event =
23975:       new nsXULPopupShowingEvent(popupFrame->GetContent(), aMenu, popupFrame->PopupType(),
 3129:                                  parentIsContextMenu, aSelectFirstItem);
 3129:     NS_DispatchToCurrentThread(event);
 3129:   }
 3129:   else {
 4234:     nsCOMPtr<nsIContent> popupContent = popupFrame->GetContent();
 4234:     FirePopupShowingEvent(popupContent, aMenu,
 4709:                           popupFrame->PresContext(), popupFrame->PopupType(),
 3129:                           parentIsContextMenu, aSelectFirstItem);
 3129:   }
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::ShowPopup(nsIContent* aPopup,
 3129:                              nsIContent* aAnchorContent,
 3129:                              const nsAString& aPosition,
 3129:                              PRInt32 aXPos, PRInt32 aYPos,
 3129:                              PRBool aIsContextMenu,
 3129:                              PRBool aAttributesOverride,
 8127:                              PRBool aSelectFirstItem,
 8127:                              nsIDOMEvent* aTriggerEvent)
 3129: {
 3129:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup);
 3129:   if (!popupFrame || !MayShowPopup(popupFrame))
 3129:     return;
 3129: 
 8127:   SetTriggerEvent(aTriggerEvent, aPopup);
 8127: 
 3129:   popupFrame->InitializePopup(aAnchorContent, aPosition, aXPos, aYPos,
 3129:                               aAttributesOverride);
 3129: 
 3129:   FirePopupShowingEvent(aPopup, nsnull, popupFrame->PresContext(),
 4709:                         popupFrame->PopupType(), aIsContextMenu, aSelectFirstItem);
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::ShowPopupAtScreen(nsIContent* aPopup,
 3129:                                      PRInt32 aXPos, PRInt32 aYPos,
 8127:                                      PRBool aIsContextMenu,
 8127:                                      nsIDOMEvent* aTriggerEvent)
 3129: {
 3129:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup);
 3129:   if (!popupFrame || !MayShowPopup(popupFrame))
 3129:     return;
 3129: 
 8127:   SetTriggerEvent(aTriggerEvent, aPopup);
 8127: 
14630:   popupFrame->InitializePopupAtScreen(aXPos, aYPos, aIsContextMenu);
 3129: 
 3129:   FirePopupShowingEvent(aPopup, nsnull, popupFrame->PresContext(),
 4709:                         popupFrame->PopupType(), aIsContextMenu, PR_FALSE);
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::ShowPopupWithAnchorAlign(nsIContent* aPopup,
 3129:                                             nsIContent* aAnchorContent,
 3129:                                             nsAString& aAnchor,
 3129:                                             nsAString& aAlign,
 3129:                                             PRInt32 aXPos, PRInt32 aYPos,
 3129:                                             PRBool aIsContextMenu)
 3129: {
 3129:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup);
 3129:   if (!popupFrame || !MayShowPopup(popupFrame))
 3129:     return;
 3129: 
 8127:   SetTriggerEvent(nsnull, nsnull);
 8127: 
 3129:   popupFrame->InitializePopupWithAnchorAlign(aAnchorContent, aAnchor,
 3129:                                              aAlign, aXPos, aYPos);
 3129: 
 3129:   FirePopupShowingEvent(aPopup, nsnull, popupFrame->PresContext(),
 4709:                         popupFrame->PopupType(), aIsContextMenu, PR_FALSE);
 3129: }
 3129: 
13787: static void
29018: CheckCaretDrawingState() {
13787: 
13787:   // There is 1 caret per document, we need to find the focused
13787:   // document and erase its caret.
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm) {
29018:     nsCOMPtr<nsIDOMWindow> window;
29018:     fm->GetFocusedWindow(getter_AddRefs(window));
29018:     if (!window)
13787:       return;
13787: 
29018:     nsCOMPtr<nsIDOMWindowInternal> windowInternal = do_QueryInterface(window);
13787: 
13787:     nsCOMPtr<nsIDOMDocument> domDoc;
13787:     nsCOMPtr<nsIDocument> focusedDoc;
13787:     windowInternal->GetDocument(getter_AddRefs(domDoc));
13787:     focusedDoc = do_QueryInterface(domDoc);
13787:     if (!focusedDoc)
13787:       return;
13787: 
13787:     nsIPresShell* presShell = focusedDoc->GetPrimaryShell();
13884:     if (!presShell)
13884:       return;
13787: 
15969:     nsRefPtr<nsCaret> caret;
19448:     presShell->GetCaret(getter_AddRefs(caret));
13884:     if (!caret)
13884:       return;
13787:     caret->CheckCaretDrawingState();
29018:   }
13787: }
13787: 
 3129: void
 3129: nsXULPopupManager::ShowPopupCallback(nsIContent* aPopup,
 3129:                                      nsMenuPopupFrame* aPopupFrame,
 3129:                                      PRBool aIsContextMenu,
 3129:                                      PRBool aSelectFirstItem)
 3129: {
 3129:   // clear these as they are no longer valid
 3129:   mRangeParent = nsnull;
 3129:   mRangeOffset = 0;
 3129: 
 4709:   nsPopupType popupType = aPopupFrame->PopupType();
 3129:   PRBool ismenu = (popupType == ePopupTypeMenu);
 3129: 
 3129:   nsMenuChainItem* item =
 4709:     new nsMenuChainItem(aPopupFrame, aIsContextMenu, popupType);
 3129:   if (!item)
 3129:     return;
 3129: 
 7871:   // install keyboard event listeners for navigating menus. For panels, the
 7871:   // escape key may be used to close the panel. However, the ignorekeys
 7871:   // attribute may be used to disable adding these event listeners for popups
 7871:   // that want to handle their own keyboard events.
 3129:   if (aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::ignorekeys,
 3129:                            nsGkAtoms::_true, eCaseMatters))
 3129:     item->SetIgnoreKeys(PR_TRUE);
 3129: 
 7871:   if (ismenu) {
 3129:     // if the menu is on a menubar, use the menubar's listener instead
 3129:     nsIFrame* parent = aPopupFrame->GetParent();
 3129:     if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
 3233:       nsMenuFrame* menuFrame = static_cast<nsMenuFrame *>(parent);
 3129:       item->SetOnMenuBar(menuFrame->IsOnMenuBar());
 3129:     }
 3129:   }
 3129: 
 3129:   // use a weak frame as the popup will set an open attribute if it is a menu
 3129:   nsWeakFrame weakFrame(aPopupFrame);
 3129:   PRBool hasChildren = aPopupFrame->ShowPopup(aIsContextMenu, aSelectFirstItem);
 3129:   ENSURE_TRUE(weakFrame.IsAlive());
 3129: 
 3129:   // popups normally hide when an outside click occurs. Panels may use
 3129:   // the noautohide attribute to disable this behaviour. It is expected
 3129:   // that the application will hide these popups manually. The tooltip
 3129:   // listener will handle closing the tooltip also.
 8408:   if (aPopupFrame->IsNoAutoHide() || popupType == ePopupTypeTooltip) {
22371:     item->SetParent(mNoHidePanels);
22371:     mNoHidePanels = item;
 3129:   }
 3129:   else {
 3129:     nsIContent* oldmenu = nsnull;
22371:     if (mPopups)
22371:       oldmenu = mPopups->Content();
22371:     item->SetParent(mPopups);
22371:     mPopups = item;
 3129:     SetCaptureState(oldmenu);
 3129:   }
 3129: 
 3129:   if (hasChildren) {
 3129:     if (aSelectFirstItem) {
 3129:       nsMenuFrame* next = GetNextMenuItem(aPopupFrame, nsnull, PR_TRUE);
 3129:       aPopupFrame->SetCurrentMenuItem(next);
 3129:     }
 3129: 
 3129:     if (ismenu)
 3129:       UpdateMenuItems(aPopup);
 3129:   }
13787: 
13787:   // Caret visibility may have been affected, ensure that
13787:   // the caret isn't now drawn when it shouldn't be.
29018:   CheckCaretDrawingState();
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::HidePopup(nsIContent* aPopup,
 3129:                              PRBool aHideChain,
 3129:                              PRBool aDeselectMenu,
29148:                              PRBool aAsynchronous,
29148:                              nsIContent* aLastPopup)
 3129: {
22371:   // if the popup is on the nohide panels list, remove it but don't close any
22371:   // other panels
 3129:   nsMenuPopupFrame* popupFrame = nsnull;
 3129:   PRBool foundPanel = PR_FALSE;
22371:   nsMenuChainItem* item = mNoHidePanels;
 3129:   while (item) {
 3129:     if (item->Content() == aPopup) {
 3129:       foundPanel = PR_TRUE;
 3129:       popupFrame = item->Frame();
 3129:       break;
 3129:     }
 3129:     item = item->GetParent();
 3129:   }
 3129: 
 3129:   // when removing a menu, all of the child popups must be closed
 3129:   nsMenuChainItem* foundMenu = nsnull;
22371:   item = mPopups;
 3129:   while (item) {
 3129:     if (item->Content() == aPopup) {
 3129:       foundMenu = item;
 3129:       break;
 3129:     }
 3129:     item = item->GetParent();
 3129:   }
 3129: 
 4709:   nsPopupType type = ePopupTypePanel;
 3129:   PRBool deselectMenu = PR_FALSE;
 3129:   nsCOMPtr<nsIContent> popupToHide, nextPopup, lastPopup;
 3129:   if (foundMenu) {
 5227:     // at this point, foundMenu will be set to the found item in the list. If
 5227:     // foundMenu is the topmost menu, the one to remove, then there are no other
 5227:     // popups to hide. If foundMenu is not the topmost menu, then there may be
 3129:     // open submenus below it. In this case, we need to make sure that those
 5227:     // submenus are closed up first. To do this, we scan up the menu list to
 5227:     // find the topmost popup with only menus between it and foundMenu and
 5227:     // close that menu first. In synchronous mode, the FirePopupHidingEvent
 5227:     // method will be called which in turn calls HidePopupCallback to close up
 5227:     // the next popup in the chain. These two methods will be called in
 5227:     // sequence recursively to close up all the necessary popups. In
 5227:     // asynchronous mode, a similar process occurs except that the
 8127:     // FirePopupHidingEvent method is called asynchronously. In either case,
 5227:     // nextPopup is set to the content node of the next popup to close, and
 5227:     // lastPopup is set to the last popup in the chain to close, which will be
 5227:     // aPopup, or null to close up all menus.
 5227: 
 5227:     nsMenuChainItem* topMenu = foundMenu;
 5227:     // Use IsMenu to ensure that foundMenu is a menu and scan down the child
 5227:     // list until a non-menu is found. If foundMenu isn't a menu at all, don't
 5227:     // scan and just close up this menu.
 5227:     if (foundMenu->IsMenu()) {
 5227:       item = topMenu->GetChild();
 5227:       while (item && item->IsMenu()) {
 5227:         topMenu = item;
 5227:         item = item->GetChild();
 5227:       }
 5227:     }
 5227:     
 3129:     deselectMenu = aDeselectMenu;
 5227:     popupToHide = topMenu->Content();
 5227:     popupFrame = topMenu->Frame();
 4709:     type = popupFrame->PopupType();
 3129: 
 5227:     nsMenuChainItem* parent = topMenu->GetParent();
 3129: 
 4234:     // close up another popup if there is one, and we are either hiding the
 4234:     // entire chain or the item to hide isn't the topmost popup.
 5227:     if (parent && (aHideChain || topMenu != foundMenu))
 4234:       nextPopup = parent->Content();
 3129: 
29148:     lastPopup = aLastPopup ? aLastPopup : (aHideChain ? nsnull : aPopup);
 3129:   }
 3129:   else if (foundPanel) {
 3129:     popupToHide = aPopup;
 3129:   }
 3129: 
 3129:   if (popupFrame) {
 4234:     nsPopupState state = popupFrame->PopupState();
 4234:     // if the popup is already being hidden, don't attempt to hide it again
 4234:     if (state == ePopupHiding)
 4234:       return;
 4234:     // change the popup state to hiding. Don't set the hiding state if the
 4234:     // popup is invisible, otherwise nsMenuPopupFrame::HidePopup will
 4234:     // run again. In the invisible state, we just want the events to fire.
 4234:     if (state != ePopupInvisible)
 4234:       popupFrame->SetPopupState(ePopupHiding);
 4234: 
 4234:     // for menus, popupToHide is always the frommost item in the list to hide.
 3129:     if (aAsynchronous) {
 3129:       nsCOMPtr<nsIRunnable> event =
 3129:         new nsXULPopupHidingEvent(popupToHide, nextPopup, lastPopup,
 4709:                                   type, deselectMenu);
 3129:         NS_DispatchToCurrentThread(event);
 3129:     }
 3129:     else {
 3129:       FirePopupHidingEvent(popupToHide, nextPopup, lastPopup,
 4709:                            popupFrame->PresContext(), type, deselectMenu);
 3129:     }
 3129:   }
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::HidePopupCallback(nsIContent* aPopup,
 3129:                                      nsMenuPopupFrame* aPopupFrame,
 3129:                                      nsIContent* aNextPopup,
 3129:                                      nsIContent* aLastPopup,
 4709:                                      nsPopupType aPopupType,
 3129:                                      PRBool aDeselectMenu)
 3129: {
 7231:   if (mCloseTimer && mTimerMenu == aPopupFrame) {
 3129:     mCloseTimer->Cancel();
 3129:     mCloseTimer = nsnull;
 3129:     mTimerMenu = nsnull;
 3129:   }
 3129: 
 4234:   // The popup to hide is aPopup. Search the list again to find the item that
 4234:   // corresponds to the popup to hide aPopup. This is done because it's
 4234:   // possible someone added another item (attempted to open another popup)
 4234:   // or removed a popup frame during the event processing so the item isn't at
 4234:   // the front anymore.
22371:   nsMenuChainItem* item = mNoHidePanels;
 4234:   while (item) {
 4234:     if (item->Content() == aPopup) {
22371:       item->Detach(&mNoHidePanels);
 4234:       break;
 4234:     }
 4234:     item = item->GetParent();
 4234:   }
 4234: 
 4234:   if (!item) {
22371:     item = mPopups;
 4234:     while (item) {
 4234:       if (item->Content() == aPopup) {
22371:         item->Detach(&mPopups);
 4234:         SetCaptureState(aPopup);
 4234:         break;
 4234:       }
 4234:       item = item->GetParent();
 4234:     }
 4234:   }
 4234: 
 4234:   delete item;
 4234: 
 3129:   nsWeakFrame weakFrame(aPopupFrame);
 4234:   aPopupFrame->HidePopup(aDeselectMenu, ePopupClosed);
 3129:   ENSURE_TRUE(weakFrame.IsAlive());
 3129: 
 3129:   // send the popuphidden event synchronously. This event has no default behaviour.
 3129:   nsEventStatus status = nsEventStatus_eIgnore;
 3560:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_HIDDEN, nsnull, nsMouseEvent::eReal);
 3129:   nsEventDispatcher::Dispatch(aPopup, aPopupFrame->PresContext(),
 3129:                               &event, nsnull, &status);
 3129: 
 3129:   // if there are more popups to close, look for the next one
 3129:   if (aNextPopup && aPopup != aLastPopup) {
 3129:     nsMenuChainItem* foundMenu = nsnull;
22371:     nsMenuChainItem* item = mPopups;
 3129:     while (item) {
 3129:       if (item->Content() == aNextPopup) {
 3129:         foundMenu = item;
 3129:         break;
 3129:       }
 3129:       item = item->GetParent();
 3129:     }
 3129: 
 3129:     // continue hiding the chain of popups until the last popup aLastPopup
 3129:     // is reached, or until a popup of a different type is reached. This
 3129:     // last check is needed so that a menulist inside a non-menu panel only
 3129:     // closes the menu and not the panel as well.
 4709:     if (foundMenu &&
 4709:         (aLastPopup || aPopupType == foundMenu->PopupType())) {
29148: 
 3129:       nsCOMPtr<nsIContent> popupToHide = item->Content();
 3300:       nsMenuChainItem* parent = item->GetParent();
 3129: 
 3129:       nsCOMPtr<nsIContent> nextPopup;
 3300:       if (parent && popupToHide != aLastPopup)
 3300:         nextPopup = parent->Content();
 3129: 
 4234:       nsMenuPopupFrame* popupFrame = item->Frame();
 4234:       nsPopupState state = popupFrame->PopupState();
 4234:       if (state == ePopupHiding)
 4234:         return;
 4234:       if (state != ePopupInvisible)
 4234:         popupFrame->SetPopupState(ePopupHiding);
 3129: 
 3129:       FirePopupHidingEvent(popupToHide, nextPopup, aLastPopup,
 4709:                            popupFrame->PresContext(),
 4709:                            foundMenu->PopupType(), aDeselectMenu);
 3129:     }
 3129:   }
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::HidePopupAfterDelay(nsMenuPopupFrame* aPopup)
 3129: {
 3129:   // Don't close up immediately.
 3129:   // Kick off a close timer.
 3129:   KillMenuTimer();
 3129: 
 3129:   PRInt32 menuDelay = 300;   // ms
 3129:   aPopup->PresContext()->LookAndFeel()->
 3129:     GetMetric(nsILookAndFeel::eMetric_SubmenuDelay, menuDelay);
 3129: 
 3129:   // Kick off the timer.
 3129:   mCloseTimer = do_CreateInstance("@mozilla.org/timer;1");
 3129:   mCloseTimer->InitWithCallback(this, menuDelay, nsITimer::TYPE_ONE_SHOT);
 3129: 
 3129:   // the popup will call PopupDestroyed if it is destroyed, which checks if it
 3129:   // is set to mTimerMenu, so it should be safe to keep a reference to it
 3129:   mTimerMenu = aPopup;
 3129: }
 3129: 
 3129: void
 8127: nsXULPopupManager::HidePopupsInList(const nsTArray<nsMenuPopupFrame *> &aFrames,
 8127:                                     PRBool aDeselectMenu)
 8127: {
 8127:   // Create a weak frame list. This is done in a separate array with the
 8127:   // right capacity predetermined, otherwise the array would get resized and
 8127:   // move the weak frame pointers around.
 8127:   nsTArray<nsWeakFrame> weakPopups(aFrames.Length());
 8127:   PRUint32 f;
 8127:   for (f = 0; f < aFrames.Length(); f++) {
 8127:     nsWeakFrame* wframe = weakPopups.AppendElement();
 8127:     if (wframe)
 8127:       *wframe = aFrames[f];
 8127:   }
 8127: 
 8127:   for (f = 0; f < weakPopups.Length(); f++) {
 8127:     // check to ensure that the frame is still alive before hiding it.
 8127:     if (weakPopups[f].IsAlive()) {
 8127:       nsMenuPopupFrame* frame =
 8127:         static_cast<nsMenuPopupFrame *>(weakPopups[f].GetFrame());
 8127:       frame->HidePopup(PR_TRUE, ePopupInvisible);
 8127:     }
 8127:   }
 8127: 
 8127:   SetCaptureState(nsnull);
 8127: }
 8127: 
11414: PRBool
11414: nsXULPopupManager::IsChildOfDocShell(nsIDocument* aDoc, nsIDocShellTreeItem* aExpected)
11414: {
11414:   nsCOMPtr<nsISupports> doc = aDoc->GetContainer();
11414:   nsCOMPtr<nsIDocShellTreeItem> docShellItem(do_QueryInterface(doc));
11414:   while(docShellItem) {
11414:     if (docShellItem == aExpected)
11414:       return PR_TRUE;
11414: 
11414:     nsCOMPtr<nsIDocShellTreeItem> parent;
11414:     docShellItem->GetParent(getter_AddRefs(parent));
11414:     docShellItem = parent;
11414:   }
11414: 
11414:   return PR_FALSE;
11414: }
11414: 
 8127: void
11414: nsXULPopupManager::HidePopupsInDocShell(nsIDocShellTreeItem* aDocShellToHide)
 3129: {
 8127:   nsTArray<nsMenuPopupFrame *> popupsToHide;
 8127: 
 8127:   // iterate to get the set of popup frames to hide
22371:   nsMenuChainItem* item = mPopups;
 3129:   while (item) {
 4234:     nsMenuChainItem* parent = item->GetParent();
 8127:     if (item->Frame()->PopupState() != ePopupInvisible &&
11414:         IsChildOfDocShell(item->Content()->GetOwnerDoc(), aDocShellToHide)) {
 8127:       nsMenuPopupFrame* frame = item->Frame();
22371:       item->Detach(&mPopups);
 4234:       delete item;
 8127:       popupsToHide.AppendElement(frame);
 4234:     }
 4234:     item = parent;
 3129:   }
 3129: 
 8127:   // now look for panels to hide
22371:   item = mNoHidePanels;
 3129:   while (item) {
 4234:     nsMenuChainItem* parent = item->GetParent();
 8127:     if (item->Frame()->PopupState() != ePopupInvisible &&
11414:         IsChildOfDocShell(item->Content()->GetOwnerDoc(), aDocShellToHide)) {
 8127:       nsMenuPopupFrame* frame = item->Frame();
22371:       item->Detach(&mNoHidePanels);
 4234:       delete item;
 8127:       popupsToHide.AppendElement(frame);
 4234:     }
 4234:     item = parent;
 3129:   }
 4668: 
 8127:   HidePopupsInList(popupsToHide, PR_TRUE);
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::ExecuteMenu(nsIContent* aMenu, nsEvent* aEvent)
 3129: {
 5462:   CloseMenuMode cmm = CloseMenuMode_Auto;
 5462: 
 5462:   static nsIContent::AttrValuesArray strings[] =
 5462:     {&nsGkAtoms::none, &nsGkAtoms::single, nsnull};
 5462: 
 5462:   switch (aMenu->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::closemenu,
 5462:                                  strings, eCaseMatters)) {
 5462:     case 0:
 5462:       cmm = CloseMenuMode_None;
 5462:       break;
 5462:     case 1:
 5462:       cmm = CloseMenuMode_Single;
 5462:       break;
 5462:     default:
 5462:       break;
 5462:   }
 5462: 
 3129:   // When a menuitem is selected to be executed, first hide all the open
 3129:   // popups, but don't remove them yet. This is needed when a menu command
 3129:   // opens a modal dialog. The views associated with the popups needed to be
 3129:   // hidden and the accesibility events fired before the command executes, but
 3129:   // the popuphiding/popuphidden events are fired afterwards.
 8127:   nsTArray<nsMenuPopupFrame *> popupsToHide;
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 5462:   if (cmm != CloseMenuMode_None) {
 3129:     while (item) {
 3129:       // if it isn't a <menupopup>, don't close it automatically
 3129:       if (!item->IsMenu())
 3129:         break;
 3129:       nsMenuChainItem* next = item->GetParent();
 8127:       popupsToHide.AppendElement(item->Frame());
 5462:       if (cmm == CloseMenuMode_Single) // only close one level of menu
 5462:         break;
 3129:       item = next;
 3129:     }
 8127: 
 8127:     // Now hide the popups. If the closemenu mode is auto, deselect the menu,
 8127:     // otherwise only one popup is closing, so keep the parent menu selected.
 8127:     HidePopupsInList(popupsToHide, cmm == CloseMenuMode_Auto);
 5462:   }
 3129: 
 3129:   // Create a trusted event if the triggering event was trusted, or if
 3129:   // we're called from chrome code (since at least one of our caller
 3129:   // passes in a null event).
 3129:   PRBool isTrusted = aEvent ? NS_IS_TRUSTED_EVENT(aEvent) :
 3129:                               nsContentUtils::IsCallerChrome();
 3129: 
 3129:   PRBool shift = PR_FALSE, control = PR_FALSE, alt = PR_FALSE, meta = PR_FALSE;
 3129:   if (aEvent && (aEvent->eventStructType == NS_MOUSE_EVENT ||
 3129:                  aEvent->eventStructType == NS_KEY_EVENT ||
 3129:                  aEvent->eventStructType == NS_ACCESSIBLE_EVENT)) {
 3233:     shift = static_cast<nsInputEvent *>(aEvent)->isShift;
 3233:     control = static_cast<nsInputEvent *>(aEvent)->isControl;
 3233:     alt = static_cast<nsInputEvent *>(aEvent)->isAlt;
 3233:     meta = static_cast<nsInputEvent *>(aEvent)->isMeta;
 3129:   }
 3129: 
 3804:   // Because the command event is firing asynchronously, a flag is needed to
 3804:   // indicate whether user input is being handled. This ensures that a popup
 3804:   // window won't get blocked.
 3804:   PRBool userinput = nsEventStateManager::IsHandlingUserInput();
 3804: 
 3129:   nsCOMPtr<nsIRunnable> event =
 5462:     new nsXULMenuCommandEvent(aMenu, isTrusted, shift, control,
 5462:                               alt, meta, userinput, cmm);
 3129:   NS_DispatchToCurrentThread(event);
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::FirePopupShowingEvent(nsIContent* aPopup,
 3129:                                          nsIContent* aMenu,
 3129:                                          nsPresContext* aPresContext,
 4709:                                          nsPopupType aPopupType,
 3129:                                          PRBool aIsContextMenu,
 3129:                                          PRBool aSelectFirstItem)
 3129: {
 3129:   nsCOMPtr<nsIPresShell> presShell = aPresContext->PresShell();
 3129: 
 3129:   // XXXndeakin (bug 383930)
 3129:   //   eventually, the popup events will be a different event type with
 3129:   //   additional fields for the anchor node and position and so forth. This
 3129:   //   is where those details would be retrieved. This removes the need for
 3129:   //   all the globals people keep adding to nsIDOMXULDocument.
 3129:   nsEventStatus status = nsEventStatus_eIgnore;
 3560:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_SHOWING, nsnull, nsMouseEvent::eReal);
32215: 
32215:   // coordinates are relative to the root widget
32215:   nsPresContext* rootPresContext =
37502:     presShell->GetPresContext()->GetRootPresContext();
37502:   if (rootPresContext) {
37502:     rootPresContext->PresShell()->GetViewManager()->
37502:       GetRootWidget(getter_AddRefs(event.widget));
37502:   }
37502:   else {
37502:     event.widget = nsnull;
37502:   }
32215: 
 3560:   event.refPoint = mCachedMousePoint;
 3129:   nsEventDispatcher::Dispatch(aPopup, aPresContext, &event, nsnull, &status);
23738:   mCachedMousePoint = nsIntPoint(0, 0);
 3129: 
 4709:   // if a panel, blur whatever has focus so that the panel can take the focus.
 4709:   // This is done after the popupshowing event in case that event is cancelled.
 4709:   // Using noautofocus="true" will disable this behaviour, which is needed for
 4709:   // the autocomplete widget as it manages focus itself.
 4709:   if (aPopupType == ePopupTypePanel &&
 4709:       !aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautofocus,
 4709:                            nsGkAtoms::_true, eCaseMatters)) {
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     if (fm) {
29018:       nsIDocument* doc = aPopup->GetCurrentDoc();
 4709: 
 4709:       // Only remove the focus if the currently focused item is ouside the
 4709:       // popup. It isn't a big deal if the current focus is in a child popup
 4709:       // inside the popup as that shouldn't be visible. This check ensures that
 4709:       // a node inside the popup that is focused during a popupshowing event
 4709:       // remains focused.
29018:       nsCOMPtr<nsIDOMElement> currentFocusElement;
29018:       fm->GetFocusedElement(getter_AddRefs(currentFocusElement));
29018:       nsCOMPtr<nsIContent> currentFocus = do_QueryInterface(currentFocusElement);
29018:       if (doc && currentFocus &&
32033:           !nsContentUtils::ContentIsCrossDocDescendantOf(currentFocus, aPopup)) {
29018:         fm->ClearFocus(doc->GetWindow());
29018:       }
 4709:     }
 4709:   }
 4709: 
 3129:   // it is common to append content to the menu during the popupshowing event.
 3129:   // Flush the notifications so that the frames are up to date before showing
 3129:   // the popup, otherwise the new frames will reflow after the popup appears,
 3129:   // causing the popup to flicker. Frame code always calls this asynchronously,
 3129:   // so this should be safe.
 3129:   nsIDocument *document = aPopup->GetCurrentDoc();
 3129:   if (document)
 3129:     document->FlushPendingNotifications(Flush_Layout);
 3129: 
 3129:   // get the frame again in case it went away
36656:   nsIFrame* frame = aPopup->GetPrimaryFrame();
 3129:   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
 3233:     nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame *>(frame);
 3129: 
 4234:     // if the event was cancelled, don't open the popup, and reset it's
 4234:     // state back to closed
 4234:     if (status == nsEventStatus_eConsumeNoDefault) {
 4234:       popupFrame->SetPopupState(ePopupClosed);
 4234:     }
 4234:     else {
 3129:       ShowPopupCallback(aPopup, popupFrame, aIsContextMenu, aSelectFirstItem);
 3129:     }
 3129:   }
 4234: }
 3129: 
 3129: void
 3129: nsXULPopupManager::FirePopupHidingEvent(nsIContent* aPopup,
 3129:                                         nsIContent* aNextPopup,
 3129:                                         nsIContent* aLastPopup,
 3129:                                         nsPresContext *aPresContext,
 4709:                                         nsPopupType aPopupType,
 3129:                                         PRBool aDeselectMenu)
 3129: {
 3129:   nsCOMPtr<nsIPresShell> presShell = aPresContext->PresShell();
 3129: 
 3129:   nsEventStatus status = nsEventStatus_eIgnore;
 3560:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_HIDING, nsnull, nsMouseEvent::eReal);
 3129:   nsEventDispatcher::Dispatch(aPopup, aPresContext, &event, nsnull, &status);
 3129: 
 4709:   // when a panel is closed, blur whatever has focus inside the popup
 4709:   if (aPopupType == ePopupTypePanel &&
 4709:       !aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautofocus,
 4709:                            nsGkAtoms::_true, eCaseMatters)) {
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     if (fm) {
29018:       nsIDocument* doc = aPopup->GetCurrentDoc();
 4709: 
 4709:       // Remove the focus from the focused node only if it is inside the popup.
29018:       nsCOMPtr<nsIDOMElement> currentFocusElement;
29018:       fm->GetFocusedElement(getter_AddRefs(currentFocusElement));
29018:       nsCOMPtr<nsIContent> currentFocus = do_QueryInterface(currentFocusElement);
29018:       if (doc && currentFocus &&
32033:           nsContentUtils::ContentIsCrossDocDescendantOf(currentFocus, aPopup)) {
29018:         fm->ClearFocus(doc->GetWindow());
29018:       }
 4709:     }
 4709:   }
 4709: 
 3129:   // get frame again in case it went away
36656:   nsIFrame* frame = aPopup->GetPrimaryFrame();
 3129:   if (frame && frame->GetType() == nsGkAtoms::menuPopupFrame) {
 3233:     nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame *>(frame);
 3129: 
 4234:     // if the event was cancelled, don't hide the popup, and reset it's
 4234:     // state back to open. Only popups in chrome shells can prevent a popup
 4234:     // from hiding.
 4234:     if (status == nsEventStatus_eConsumeNoDefault &&
 4234:         !popupFrame->IsInContentShell()) {
 4234:       popupFrame->SetPopupState(ePopupOpenAndVisible);
 4234:     }
 4234:     else {
 3129:       HidePopupCallback(aPopup, popupFrame, aNextPopup, aLastPopup,
 4709:                         aPopupType, aDeselectMenu);
 3129:     }
 3129:   }
 3129: }
 3129: 
 3129: PRBool
 3340: nsXULPopupManager::IsPopupOpen(nsIContent* aPopup)
 3340: {
 4234:   // a popup is open if it is in the open list. The assertions ensure that the
 4234:   // frame is in the correct state. If the popup is in the hiding or invisible
 4234:   // state, it will still be in the open popup list until it is closed.
22371:   nsMenuChainItem* item = mPopups;
 3340:   while (item) {
 4234:     if (item->Content() == aPopup) {
 4234:       NS_ASSERTION(item->Frame()->IsOpen() ||
 4234:                    item->Frame()->PopupState() == ePopupHiding ||
 4234:                    item->Frame()->PopupState() == ePopupInvisible,
 5462:                    "popup in open list not actually open");
 3340:       return PR_TRUE;
 4234:     }
 3340:     item = item->GetParent();
 3340:   }
 3340: 
22371:   item = mNoHidePanels;
 3340:   while (item) {
 4234:     if (item->Content() == aPopup) {
 4234:       NS_ASSERTION(item->Frame()->IsOpen() ||
 4234:                    item->Frame()->PopupState() == ePopupHiding ||
 4234:                    item->Frame()->PopupState() == ePopupInvisible,
 5462:                    "popup in open list not actually open");
 3340:       return PR_TRUE;
 4234:     }
 3340:     item = item->GetParent();
 3340:   }
 3340: 
 3340:   return PR_FALSE;
 3340: }
 3340: 
 3340: PRBool
22372: nsXULPopupManager::IsPopupOpenForMenuParent(nsMenuParent* aMenuParent)
 3129: {
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 3129:   while (item) {
 4234:     nsMenuPopupFrame* popup = item->Frame();
 4234:     if (popup && popup->IsOpen()) {
 4234:       nsIFrame* parent = popup->GetParent();
 3129:       if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
 3233:         nsMenuFrame* menuFrame = static_cast<nsMenuFrame *>(parent);
 3129:         if (menuFrame->GetMenuParent() == aMenuParent)
 3129:           return PR_TRUE;
 3129:       }
 4234:     }
 3129:     item = item->GetParent();
 3129:   }
 3129: 
 3129:   return PR_FALSE;
 3129: }
 3129: 
 4709: nsIFrame*
 4709: nsXULPopupManager::GetTopPopup(nsPopupType aType)
 4709: {
22371:   if (aType == ePopupTypePanel && mNoHidePanels)
22371:     return mNoHidePanels->Frame();
 4709: 
 4709:   nsMenuChainItem* item = GetTopVisibleMenu();
 4709:   while (item) {
 6051:     if (item->PopupType() == aType || aType == ePopupTypeAny)
 4709:       return item->Frame();
 4709:     item = item->GetParent();
 4709:   }
 4709: 
 4709:   return nsnull;
 4709: }
 4709: 
 3516: nsTArray<nsIFrame *>
25413: nsXULPopupManager::GetVisiblePopups()
 3516: {
 3516:   nsTArray<nsIFrame *> popups;
 3516: 
22371:   nsMenuChainItem* item = mPopups;
 3516:   while (item) {
25413:     if (item->Frame()->PopupState() == ePopupOpenAndVisible)
 3644:       popups.AppendElement(static_cast<nsIFrame*>(item->Frame()));
 3516:     item = item->GetParent();
 3516:   }
 3516: 
 3516:   return popups;
 3516: }
 3516: 
 3129: PRBool
 3129: nsXULPopupManager::MayShowPopup(nsMenuPopupFrame* aPopup)
 3129: {
 4234:   // if a popup's IsOpen method returns true, then the popup must always be in
 4234:   // the popup chain scanned in IsPopupOpen.
 4234:   NS_ASSERTION(!aPopup->IsOpen() || IsPopupOpen(aPopup->GetContent()),
 4234:                "popup frame state doesn't match XULPopupManager open state");
 4234: 
 4234:   nsPopupState state = aPopup->PopupState();
 4234: 
 4234:   // if the popup is not in the open popup chain, then it must have a state that
 4234:   // is either closed, in the process of being shown, or invisible.
 4234:   NS_ASSERTION(IsPopupOpen(aPopup->GetContent()) || state == ePopupClosed ||
 4234:                state == ePopupShowing || state == ePopupInvisible,
 4234:                "popup not in XULPopupManager open list is open");
 4234: 
 4234:   // don't show popups unless they are closed or invisible
 4234:   if (state != ePopupClosed && state != ePopupInvisible)
 3129:     return PR_FALSE;
 3129: 
35447:   // Don't show popups that we already have in our popup chain
35447:   if (IsPopupOpen(aPopup->GetContent())) {
35447:     NS_WARNING("Refusing to show duplicate popup");
35447:     return PR_FALSE;
35447:   }
35447: 
 8591:   // if the popup was just rolled up, don't reopen it
 8591:   nsCOMPtr<nsIWidget> widget;
 8591:   aPopup->GetWidget(getter_AddRefs(widget));
 8591:   if (widget && widget->GetLastRollup() == aPopup->GetContent())
 8591:       return PR_FALSE;
 8591: 
 3129:   nsCOMPtr<nsISupports> cont = aPopup->PresContext()->GetContainer();
 3129:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
19112:   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(dsti);
19112:   if (!baseWin)
 3129:     return PR_FALSE;
 3129: 
 3129:   PRInt32 type = -1;
 3129:   if (NS_FAILED(dsti->GetItemType(&type)))
 3129:     return PR_FALSE;
 3129: 
19112:   // chrome shells can always open popups, but other types of shells can only
19112:   // open popups when they are focused and visible
 3129:   if (type != nsIDocShellTreeItem::typeChrome) {
19112:     // only allow popups in active windows
29018:     nsCOMPtr<nsIDocShellTreeItem> root;
29018:     dsti->GetRootTreeItem(getter_AddRefs(root));
29018:     nsCOMPtr<nsIDOMWindow> rootWin = do_GetInterface(root);
29018: 
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     if (!fm || !rootWin)
 3129:       return PR_FALSE;
 3129: 
29018:     nsCOMPtr<nsIDOMWindow> activeWindow;
29018:     fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018:     if (activeWindow != rootWin)
 3129:       return PR_FALSE;
 3129: 
 3129:     // only allow popups in visible frames
 3129:     PRBool visible;
 3129:     baseWin->GetVisibility(&visible);
 3129:     if (!visible)
 3129:       return PR_FALSE;
 3129:   }
 3129: 
19112:   // platforms respond differently when an popup is opened in a minimized
19112:   // window, so this is always disabled.
19112:   nsCOMPtr<nsIWidget> mainWidget;
19112:   baseWin->GetMainWidget(getter_AddRefs(mainWidget));
19112:   if (mainWidget) {
19112:     PRInt32 sizeMode;
19112:     mainWidget->GetSizeMode(&sizeMode);
19112:     if (sizeMode == nsSizeMode_Minimized)
19112:       return PR_FALSE;
19112:   }
19112: 
 3129:   // cannot open a popup that is a submenu of a menupopup that isn't open.
 3129:   nsIFrame* parent = aPopup->GetParent();
 3129:   if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
 3233:     nsMenuFrame* menuFrame = static_cast<nsMenuFrame *>(parent);
22372:     nsMenuParent* parentPopup = menuFrame->GetMenuParent();
 3129:     if (parentPopup && !parentPopup->IsOpen())
 3129:       return PR_FALSE;
 3129:   }
 3129: 
 3129:   return PR_TRUE;
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::PopupDestroyed(nsMenuPopupFrame* aPopup)
 3129: {
 3129:   // when a popup frame is destroyed, just unhook it from the list of popups
 3129:   if (mTimerMenu == aPopup) {
 3129:     if (mCloseTimer) {
 3129:       mCloseTimer->Cancel();
 3129:       mCloseTimer = nsnull;
 3129:     }
 3129:     mTimerMenu = nsnull;
 3129:   }
 3129: 
22371:   nsMenuChainItem* item = mNoHidePanels;
 3129:   while (item) {
 3129:     if (item->Frame() == aPopup) {
22371:       item->Detach(&mNoHidePanels);
 3129:       delete item;
 3129:       break;
 3129:     }
 3129:     item = item->GetParent();
 3129:   }
 3129: 
 8127:   nsTArray<nsMenuPopupFrame *> popupsToHide;
 3129: 
22371:   item = mPopups;
 3129:   while (item) {
 8127:     nsMenuPopupFrame* frame = item->Frame();
 8127:     if (frame == aPopup) {
 8127:       if (frame->PopupState() != ePopupInvisible) {
 8127:         // Iterate through any child menus and hide them as well, since the
 8127:         // parent is going away. We won't remove them from the list yet, just
 8127:         // hide them, as they will be removed from the list when this function
 8127:         // gets called for that child frame.
 8127:         nsMenuChainItem* child = item->GetChild();
 8127:         while (child) {
 8127:           // if the popup is a child frame of the menu that was destroyed, add
 8127:           // it to the list of popups to hide. Don't bother with the events
 8127:           // since the frames are going away. If the child menu is not a child
 8127:           // frame, for example, a context menu, use HidePopup instead, but call
 8127:           // it asynchronously since we are in the middle of frame destruction.
 8127:           nsMenuPopupFrame* childframe = child->Frame();
 8127:           if (nsLayoutUtils::IsProperAncestorFrame(frame, childframe)) {
 8127:             popupsToHide.AppendElement(childframe);
 8127:           }
 8127:           else {
 8127:             // HidePopup will take care of hiding any of its children, so
 8127:             // break out afterwards
 8127:             HidePopup(child->Content(), PR_FALSE, PR_FALSE, PR_TRUE);
 3129:             break;
 3129:           }
 8127: 
 8127:           child = child->GetChild();
 8127:         }
 8127:       }
 8127: 
22371:       item->Detach(&mPopups);
 8127:       delete item;
 8127:       break;
 8127:     }
 8127: 
 3129:     item = item->GetParent();
 3129:   }
 3129: 
 8127:   HidePopupsInList(popupsToHide, PR_FALSE);
 3129: }
 3129: 
 3129: PRBool
 3129: nsXULPopupManager::HasContextMenu(nsMenuPopupFrame* aPopup)
 3129: {
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 3129:   while (item && item->Frame() != aPopup) {
 3129:     if (item->IsContextMenu())
 3129:       return PR_TRUE;
 3129:     item = item->GetParent();
 3129:   }
 3129: 
 3129:   return PR_FALSE;
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::SetCaptureState(nsIContent* aOldPopup)
 3129: {
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 4668:   if (item && aOldPopup == item->Content())
 3129:     return;
 3129: 
 3129:   if (mWidget) {
36806:     mWidget->CaptureRollupEvents(this, this, PR_FALSE, PR_FALSE);
 3129:     mWidget = nsnull;
 3129:   }
 3129: 
 4668:   if (item) {
 4668:     nsMenuPopupFrame* popup = item->Frame();
 3129:     nsCOMPtr<nsIWidget> widget;
 3129:     popup->GetWidget(getter_AddRefs(widget));
 3129:     if (widget) {
36806:       widget->CaptureRollupEvents(this, this, PR_TRUE,
36806:                                   popup->ConsumeOutsideClicks());
 3129:       mWidget = widget;
 3129:       popup->AttachedDismissalListener();
 3129:     }
 3129:   }
 3129: 
 3129:   UpdateKeyboardListeners();
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::UpdateKeyboardListeners()
 3129: {
 3129:   nsCOMPtr<nsIDOMEventTarget> newTarget;
 8637:   PRBool isForMenu = PR_FALSE;
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 4668:   if (item) {
 4668:     if (!item->IgnoreKeys())
 4668:       newTarget = do_QueryInterface(item->Content()->GetDocument());
 8637:     isForMenu = item->PopupType() == ePopupTypeMenu;
 3129:   }
 3129:   else if (mActiveMenuBar) {
 3129:     newTarget = do_QueryInterface(mActiveMenuBar->GetContent()->GetDocument());
 8637:     isForMenu = PR_TRUE;
 3129:   }
 3129: 
 3129:   if (mKeyListener != newTarget) {
 3129:     if (mKeyListener) {
 3129:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keypress"), this, PR_TRUE);
 3129:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keydown"), this, PR_TRUE);
 3129:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keyup"), this, PR_TRUE);
 3129:       mKeyListener = nsnull;
 3129:       nsContentUtils::NotifyInstalledMenuKeyboardListener(PR_FALSE);
 3129:     }
 3129: 
 3129:     if (newTarget) {
 3129:       newTarget->AddEventListener(NS_LITERAL_STRING("keypress"), this, PR_TRUE);
 3129:       newTarget->AddEventListener(NS_LITERAL_STRING("keydown"), this, PR_TRUE);
 3129:       newTarget->AddEventListener(NS_LITERAL_STRING("keyup"), this, PR_TRUE);
 8637:       nsContentUtils::NotifyInstalledMenuKeyboardListener(isForMenu);
 3129:       mKeyListener = newTarget;
 3129:     }
 3129:   }
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::UpdateMenuItems(nsIContent* aPopup)
 3129: {
 3129:   // Walk all of the menu's children, checking to see if any of them has a
 3129:   // command attribute. If so, then several attributes must potentially be updated.
 3129:  
 3129:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(aPopup->GetDocument()));
 3129:   PRUint32 count = aPopup->GetChildCount();
 3129:   for (PRUint32 i = 0; i < count; i++) {
 3129:     nsCOMPtr<nsIContent> grandChild = aPopup->GetChildAt(i);
 3129: 
 3129:     if (grandChild->NodeInfo()->Equals(nsGkAtoms::menuitem, kNameSpaceID_XUL)) {
 3129:       // See if we have a command attribute.
 3129:       nsAutoString command;
 3129:       grandChild->GetAttr(kNameSpaceID_None, nsGkAtoms::command, command);
 3129:       if (!command.IsEmpty()) {
 3129:         // We do! Look it up in our document
 3129:         nsCOMPtr<nsIDOMElement> commandElt;
 3129:         domDoc->GetElementById(command, getter_AddRefs(commandElt));
 3129:         nsCOMPtr<nsIContent> commandContent(do_QueryInterface(commandElt));
 3129:         if (commandContent) {
 3129:           nsAutoString commandValue;
 3129:           // The menu's disabled state needs to be updated to match the command.
 3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandValue))
 3129:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandValue, PR_TRUE);
 3129:           else
 3129:             grandChild->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, PR_TRUE);
 3129: 
 3129:           // The menu's label, accesskey and checked states need to be updated
 3129:           // to match the command. Note that unlike the disabled state if the
 3129:           // command has *no* value, we assume the menu is supplying its own.
 3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, commandValue))
 3129:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::label, commandValue, PR_TRUE);
 3129: 
 3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandValue))
 3129:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandValue, PR_TRUE);
 3129: 
 3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandValue))
 3129:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandValue, PR_TRUE);
 3129:         }
 3129:       }
 3129:     }
 3129:   }
 3129: }
 3129: 
 3129: // Notify
 3129: //
 3129: // The item selection timer has fired, we might have to readjust the 
 3129: // selected item. There are two cases here that we are trying to deal with:
 3129: //   (1) diagonal movement from a parent menu to a submenu passing briefly over
 3129: //       other items, and
 3129: //   (2) moving out from a submenu to a parent or grandparent menu.
 3129: // In both cases, |mTimerMenu| is the menu item that might have an open submenu and
22371: // the first item in |mPopups| is the item the mouse is currently over, which could be
22371: // none of them.
 3129: //
 3129: // case (1):
 3129: //  As the mouse moves from the parent item of a submenu (we'll call 'A') diagonally into the
 3129: //  submenu, it probably passes through one or more sibilings (B). As the mouse passes
 3129: //  through B, it becomes the current menu item and the timer is set and mTimerMenu is 
 3129: //  set to A. Before the timer fires, the mouse leaves the menu containing A and B and
22371: //  enters the submenus. Now when the timer fires, |mPopups| is null (!= |mTimerMenu|)
 3129: //  so we have to see if anything in A's children is selected (recall that even disabled
 3129: //  items are selected, the style just doesn't show it). If that is the case, we need to
 3129: //  set the selected item back to A.
 3129: //
 3129: // case (2);
 3129: //  Item A has an open submenu, and in it there is an item (B) which also has an open
 3129: //  submenu (so there are 3 menus displayed right now). The mouse then leaves B's child
 3129: //  submenu and selects an item that is a sibling of A, call it C. When the mouse enters C,
22371: //  the timer is set and |mTimerMenu| is A and |mPopups| is C. As the timer fires,
 3129: //  the mouse is still within C. The correct behavior is to set the current item to C
 3129: //  and close up the chain parented at A.
 3129: //
 3129: //  This brings up the question of is the logic of case (1) enough? The answer is no,
 3129: //  and is discussed in bugzilla bug 29400. Case (1) asks if A's submenu has a selected
 3129: //  child, and if it does, set the selected item to A. Because B has a submenu open, it
 3129: //  is selected and as a result, A is set to be the selected item even though the mouse
 3129: //  rests in C -- very wrong. 
 3129: //
 3129: //  The solution is to use the same idea, but instead of only checking one level, 
 3129: //  drill all the way down to the deepest open submenu and check if it has something 
 3129: //  selected. Since the mouse is in a grandparent, it won't, and we know that we can
 3129: //  safely close up A and all its children.
 3129: //
 3129: // The code below melds the two cases together.
 3129: //
 3129: nsresult
 3129: nsXULPopupManager::Notify(nsITimer* aTimer)
 3129: {
 3129:   if (aTimer == mCloseTimer)
 3129:     KillMenuTimer();
 3129: 
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: void
 3129: nsXULPopupManager::KillMenuTimer()
 3129: {
 3129:   if (mCloseTimer && mTimerMenu) {
 3129:     mCloseTimer->Cancel();
 3129:     mCloseTimer = nsnull;
 3129: 
 3129:     if (mTimerMenu->IsOpen())
 3129:       HidePopup(mTimerMenu->GetContent(), PR_FALSE, PR_FALSE, PR_TRUE);
 3129:   }
 3129: 
 3129:   mTimerMenu = nsnull;
 3129: }
 3129: 
 3332: void
22372: nsXULPopupManager::CancelMenuTimer(nsMenuParent* aMenuParent)
 3332: {
 3332:   if (mCloseTimer && mTimerMenu == aMenuParent) {
 3332:     mCloseTimer->Cancel();
 3332:     mCloseTimer = nsnull;
 3332:     mTimerMenu = nsnull;
 3332:   }
 3332: }
 3332: 
 3129: PRBool
 3779: nsXULPopupManager::HandleShortcutNavigation(nsIDOMKeyEvent* aKeyEvent,
 3779:                                             nsMenuPopupFrame* aFrame)
 3129: {
 4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 4668:   if (!aFrame && item)
 4668:     aFrame = item->Frame();
 3129: 
 3779:   if (aFrame) {
 3129:     PRBool action;
 3779:     nsMenuFrame* result = aFrame->FindMenuWithShortcut(aKeyEvent, action);
 3129:     if (result) {
 3779:       aFrame->ChangeMenuItem(result, PR_FALSE);
 3225:       if (action) {
 3225:         nsMenuFrame* menuToOpen = result->Enter();
 3225:         if (menuToOpen) {
 3225:           nsCOMPtr<nsIContent> content = menuToOpen->GetContent();
 3225:           ShowMenu(content, PR_TRUE, PR_FALSE);
 3225:         }
 3225:       }
 3129:       return PR_TRUE;
 3129:     }
 3129: 
 3129:     return PR_FALSE;
 3129:   }
 3129: 
 3129:   if (mActiveMenuBar) {
 3129:     nsMenuFrame* result = mActiveMenuBar->FindMenuWithShortcut(aKeyEvent);
 3129:     if (result) {
 3129:       mActiveMenuBar->SetActive(PR_TRUE);
 3129:       result->OpenMenu(PR_TRUE);
 3129:       return PR_TRUE;
 3129:     }
 3129:   }
 3129: 
 3129:   return PR_FALSE;
 3129: }
 3129: 
 3129: 
 3129: PRBool
 3129: nsXULPopupManager::HandleKeyboardNavigation(PRUint32 aKeyCode)
 3129: {
 3129:   // navigate up through the open menus, looking for the topmost one
 3129:   // in the same hierarchy
 3129:   nsMenuChainItem* item = nsnull;
 4668:   nsMenuChainItem* nextitem = GetTopVisibleMenu();
 3129: 
 3129:   while (nextitem) {
 3129:     item = nextitem;
 3129:     nextitem = item->GetParent();
 3129: 
 3129:     if (nextitem) {
 3129:       // stop if the parent isn't a menu
 3129:       if (!nextitem->IsMenu())
 3129:         break;
 3129: 
 3129:       // check to make sure that the parent is actually the parent menu. It won't
 3129:       // be if the parent is in a different frame hierarchy, for example, for a
 3129:       // context menu opened on another menu.
22372:       nsMenuParent* expectedParent = static_cast<nsMenuParent *>(nextitem->Frame());
 3129:       nsIFrame* parent = item->Frame()->GetParent();
 3129:       if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
 3233:         nsMenuFrame* menuFrame = static_cast<nsMenuFrame *>(parent);
 3129:         if (menuFrame->GetMenuParent() != expectedParent)
 3129:           break;
 3129:       }
 3129:       else {
 3129:         break;
 3129:       }
 3129:     }
 3129:   }
 3129: 
 3129:   nsIFrame* itemFrame;
 3129:   if (item)
 3129:     itemFrame = item->Frame();
 3129:   else if (mActiveMenuBar)
 3129:     itemFrame = mActiveMenuBar;
 3129:   else
 3129:     return PR_FALSE;
 3129: 
 3129:   nsNavigationDirection theDirection;
23190:   NS_ASSERTION(aKeyCode >= NS_VK_END && aKeyCode <= NS_VK_DOWN, "Illegal key code");
23190:   theDirection = NS_DIRECTION_FROM_KEY_CODE(itemFrame, aKeyCode);
 3129: 
 3129:   // if a popup is open, first check for navigation within the popup
 3129:   if (item && HandleKeyboardNavigationInPopup(item, theDirection))
 3129:     return PR_TRUE;
 3129: 
 3129:   // no popup handled the key, so check the active menubar, if any
 3129:   if (mActiveMenuBar) {
 3129:     nsMenuFrame* currentMenu = mActiveMenuBar->GetCurrentMenuItem();
 3129:   
 3129:     if (NS_DIRECTION_IS_INLINE(theDirection)) {
 3129:       nsMenuFrame* nextItem = (theDirection == eNavigationDirection_End) ?
 3129:                               GetNextMenuItem(mActiveMenuBar, currentMenu, PR_FALSE) : 
 3129:                               GetPreviousMenuItem(mActiveMenuBar, currentMenu, PR_FALSE);
 3129:       mActiveMenuBar->ChangeMenuItem(nextItem, PR_TRUE);
 3129:       return PR_TRUE;
 3129:     }
12967:     else if (NS_DIRECTION_IS_BLOCK(theDirection)) {
 3129:       // Open the menu and select its first item.
 9315:       if (currentMenu) {
 3129:         nsCOMPtr<nsIContent> content = currentMenu->GetContent();
 3129:         ShowMenu(content, PR_TRUE, PR_FALSE);
 9315:       }
 3129:       return PR_TRUE;
 3129:     }
 3129:   }
 3129: 
 3129:   return PR_FALSE;
 3129: }
 3129: 
 3129: PRBool
 3129: nsXULPopupManager::HandleKeyboardNavigationInPopup(nsMenuChainItem* item,
 3779:                                                    nsMenuPopupFrame* aFrame,
 3129:                                                    nsNavigationDirection aDir)
 3129: {
 3779:   NS_ASSERTION(aFrame, "aFrame is null");
 3779:   NS_ASSERTION(!item || item->Frame() == aFrame,
 3779:                "aFrame is expected to be equal to item->Frame()");
 3129: 
 3779:   nsMenuFrame* currentMenu = aFrame->GetCurrentMenuItem();
 3779: 
 3779:   aFrame->ClearIncrementalString();
 3129: 
 3129:   // This method only gets called if we're open.
 3129:   if (!currentMenu && NS_DIRECTION_IS_INLINE(aDir)) {
 3129:     // We've been opened, but we haven't had anything selected.
 3129:     // We can handle End, but our parent handles Start.
 3129:     if (aDir == eNavigationDirection_End) {
 3779:       nsMenuFrame* nextItem = GetNextMenuItem(aFrame, nsnull, PR_TRUE);
 3129:       if (nextItem) {
 3779:         aFrame->ChangeMenuItem(nextItem, PR_FALSE);
 3129:         return PR_TRUE;
 3129:       }
 3129:     }
 3129:     return PR_FALSE;
 3129:   }
 3129: 
 3129:   PRBool isContainer = PR_FALSE;
 3129:   PRBool isOpen = PR_FALSE;
 3129:   if (currentMenu) {
 3129:     isOpen = currentMenu->IsOpen();
 3129:     isContainer = currentMenu->IsMenu();
 3129:     if (isOpen) {
 3129:       // for an open popup, have the child process the event
 3779:       nsMenuChainItem* child = item ? item->GetChild() : nsnull;
 3129:       if (child && HandleKeyboardNavigationInPopup(child, aDir))
 3129:         return PR_TRUE;
 3129:     }
 3129:     else if (aDir == eNavigationDirection_End &&
 3129:              isContainer && !currentMenu->IsDisabled()) {
 3129:       // The menu is not yet open. Open it and select the first item.
 3129:       nsCOMPtr<nsIContent> content = currentMenu->GetContent();
 3129:       ShowMenu(content, PR_TRUE, PR_FALSE);
 3129:       return PR_TRUE;
 3129:     }
 3129:   }
 3129: 
 3129:   // For block progression, we can move in either direction
 3129:   if (NS_DIRECTION_IS_BLOCK(aDir) ||
 3129:       NS_DIRECTION_IS_BLOCK_TO_EDGE(aDir)) {
 3129:     nsMenuFrame* nextItem;
 3129: 
 3129:     if (aDir == eNavigationDirection_Before)
 3779:       nextItem = GetPreviousMenuItem(aFrame, currentMenu, PR_TRUE);
 3129:     else if (aDir == eNavigationDirection_After)
 3779:       nextItem = GetNextMenuItem(aFrame, currentMenu, PR_TRUE);
 3129:     else if (aDir == eNavigationDirection_First)
 3779:       nextItem = GetNextMenuItem(aFrame, nsnull, PR_TRUE);
 3129:     else
 3779:       nextItem = GetPreviousMenuItem(aFrame, nsnull, PR_TRUE);
 3129: 
 3129:     if (nextItem) {
 3779:       aFrame->ChangeMenuItem(nextItem, PR_FALSE);
 3129:       return PR_TRUE;
 3129:     }
 3129:   }
 3129:   else if (currentMenu && isContainer && isOpen) {
 3129:     if (aDir == eNavigationDirection_Start) {
 3129:       // close a submenu when Left is pressed
 3129:       nsMenuPopupFrame* popupFrame = currentMenu->GetPopup();
 3129:       if (popupFrame)
 3129:         HidePopup(popupFrame->GetContent(), PR_FALSE, PR_FALSE, PR_FALSE);
 3129:       return PR_TRUE;
 3129:     }
 3129:   }
 3129: 
 3129:   return PR_FALSE;
 3129: }
 3129: 
 3129: nsMenuFrame*
 3129: nsXULPopupManager::GetNextMenuItem(nsIFrame* aParent,
 3129:                                    nsMenuFrame* aStart,
 3129:                                    PRBool aIsPopup)
 3129: {
 3129:   nsIFrame* immediateParent = nsnull;
 3129:   nsPresContext* presContext = aParent->PresContext();
 3129:   presContext->PresShell()->
 3129:     FrameConstructor()->GetInsertionPoint(aParent, nsnull, &immediateParent);
 3129:   if (!immediateParent)
 3129:     immediateParent = aParent;
 3129: 
 3129:   nsIFrame* currFrame = nsnull;
 3129:   if (aStart)
 3129:     currFrame = aStart->GetNextSibling();
 3129:   else 
 3129:     currFrame = immediateParent->GetFirstChild(nsnull);
 3129:   
 3129:   while (currFrame) {
 3129:     // See if it's a menu item.
 3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
 3129:       return (currFrame->GetType() == nsGkAtoms::menuFrame) ?
 3233:              static_cast<nsMenuFrame *>(currFrame) : nsnull;
 3129:     }
 3129:     currFrame = currFrame->GetNextSibling();
 3129:   }
 3129: 
 3129:   currFrame = immediateParent->GetFirstChild(nsnull);
 3129: 
 3129:   // Still don't have anything. Try cycling from the beginning.
 3129:   while (currFrame && currFrame != aStart) {
 3129:     // See if it's a menu item.
 3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
 3129:       return (currFrame->GetType() == nsGkAtoms::menuFrame) ?
 3233:              static_cast<nsMenuFrame *>(currFrame) : nsnull;
 3129:     }
 3129: 
 3129:     currFrame = currFrame->GetNextSibling();
 3129:   }
 3129: 
 3129:   // No luck. Just return our start value.
 3129:   return aStart;
 3129: }
 3129: 
 3129: nsMenuFrame*
 3129: nsXULPopupManager::GetPreviousMenuItem(nsIFrame* aParent,
 3129:                                        nsMenuFrame* aStart,
 3129:                                        PRBool aIsPopup)
 3129: {
 3129:   nsIFrame* immediateParent = nsnull;
 3129:   nsPresContext* presContext = aParent->PresContext();
 3129:   presContext->PresShell()->
 3129:     FrameConstructor()->GetInsertionPoint(aParent, nsnull, &immediateParent);
 3129:   if (!immediateParent)
 3129:     immediateParent = aParent;
 3129: 
32846:   const nsFrameList& frames(immediateParent->GetChildList(nsnull));
 3129: 
 3129:   nsIFrame* currFrame = nsnull;
 3129:   if (aStart)
33388:     currFrame = aStart->GetPrevSibling();
 3129:   else
 3129:     currFrame = frames.LastChild();
 3129: 
 3129:   while (currFrame) {
 3129:     // See if it's a menu item.
 3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
 3129:       return (currFrame->GetType() == nsGkAtoms::menuFrame) ?
 3233:              static_cast<nsMenuFrame *>(currFrame) : nsnull;
 3129:     }
33388:     currFrame = currFrame->GetPrevSibling();
 3129:   }
 3129: 
 3129:   currFrame = frames.LastChild();
 3129: 
 3129:   // Still don't have anything. Try cycling from the end.
 3129:   while (currFrame && currFrame != aStart) {
 3129:     // See if it's a menu item.
 3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
 3129:       return (currFrame->GetType() == nsGkAtoms::menuFrame) ?
 3233:              static_cast<nsMenuFrame *>(currFrame) : nsnull;
 3129:     }
 3129: 
33388:     currFrame = currFrame->GetPrevSibling();
 3129:   }
 3129: 
 3129:   // No luck. Just return our start value.
 3129:   return aStart;
 3129: }
 3129: 
 3129: PRBool
 3129: nsXULPopupManager::IsValidMenuItem(nsPresContext* aPresContext,
 3129:                                    nsIContent* aContent,
 3129:                                    PRBool aOnPopup)
 3129: {
 3129:   PRInt32 ns = aContent->GetNameSpaceID();
 3129:   nsIAtom *tag = aContent->Tag();
 8127:   if (ns == kNameSpaceID_XUL) {
 8127:     if (tag != nsGkAtoms::menu && tag != nsGkAtoms::menuitem)
 3129:       return PR_FALSE;
 8127:   }
 8127:   else if (ns != kNameSpaceID_XHTML || !aOnPopup || tag != nsGkAtoms::option) {
 3129:     return PR_FALSE;
 8127:   }
 3129: 
 3129:   PRBool skipNavigatingDisabledMenuItem = PR_TRUE;
 3129:   if (aOnPopup) {
 3129:     aPresContext->LookAndFeel()->
 3129:       GetMetric(nsILookAndFeel::eMetric_SkipNavigatingDisabledMenuItem,
 3129:                 skipNavigatingDisabledMenuItem);
 3129:   }
 3129: 
 3129:   return !(skipNavigatingDisabledMenuItem &&
 3129:            aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
 3129:                                  nsGkAtoms::_true, eCaseMatters));
 3129: }
 3129: 
 3129: nsresult
 3129: nsXULPopupManager::KeyUp(nsIDOMEvent* aKeyEvent)
 3129: {
 8260:   // don't do anything if a menu isn't open or a menubar isn't active
 8260:   if (!mActiveMenuBar) {
 7871:     nsMenuChainItem* item = GetTopVisibleMenu();
 8260:     if (!item || item->PopupType() != ePopupTypeMenu)
 8260:       return NS_OK;
 8260:   }
 8260: 
 3129:   aKeyEvent->StopPropagation();
 3129:   aKeyEvent->PreventDefault();
 3129: 
 3129:   return NS_OK; // I am consuming event
 3129: }
 3129: 
 3129: nsresult
 3129: nsXULPopupManager::KeyDown(nsIDOMEvent* aKeyEvent)
 3129: {
 8260:   // don't do anything if a menu isn't open or a menubar isn't active
 8260:   if (!mActiveMenuBar) {
 7871:     nsMenuChainItem* item = GetTopVisibleMenu();
 7871:     if (!item || item->PopupType() != ePopupTypeMenu)
 5218:       return NS_OK;
 8260:   }
 5218: 
 3129:   PRInt32 menuAccessKey = -1;
 3129: 
 3129:   // If the key just pressed is the access key (usually Alt),
 3129:   // dismiss and unfocus the menu.
 3129: 
 3129:   nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
 3129:   if (menuAccessKey) {
 3129:     PRUint32 theChar;
 3129:     nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aKeyEvent);
 3129:     keyEvent->GetKeyCode(&theChar);
 3129: 
 3129:     if (theChar == (PRUint32)menuAccessKey) {
 3129:       PRBool ctrl = PR_FALSE;
 3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_CONTROL)
 3129:         keyEvent->GetCtrlKey(&ctrl);
 3129:       PRBool alt=PR_FALSE;
 3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_ALT)
 3129:         keyEvent->GetAltKey(&alt);
 3129:       PRBool shift=PR_FALSE;
 3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_SHIFT)
 3129:         keyEvent->GetShiftKey(&shift);
 3129:       PRBool meta=PR_FALSE;
 3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_META)
 3129:         keyEvent->GetMetaKey(&meta);
 3129:       if (!(ctrl || alt || shift || meta)) {
 3129:         // The access key just went down and no other
 3129:         // modifiers are already down.
22371:         if (mPopups)
29148:           Rollup(nsnull, nsnull);
 8260:         else if (mActiveMenuBar)
 8260:           mActiveMenuBar->MenuClosed();
 3129:       }
 3129:     }
 3129:   }
 3129: 
 3129:   // Since a menu was open, eat the event to keep other event
 3129:   // listeners from becoming confused.
 3129:   aKeyEvent->StopPropagation();
 3129:   aKeyEvent->PreventDefault();
 3129:   return NS_OK; // I am consuming event
 3129: }
 3129: 
 3129: nsresult
 3129: nsXULPopupManager::KeyPress(nsIDOMEvent* aKeyEvent)
 3129: {
 3129:   // Don't check prevent default flag -- menus always get first shot at key events.
 3129:   // When a menu is open, the prevent default flag on a keypress is always set, so
 3129:   // that no one else uses the key event.
 3129: 
 3129:   //handlers shouldn't be triggered by non-trusted events.
 3129:   nsCOMPtr<nsIDOMNSEvent> domNSEvent = do_QueryInterface(aKeyEvent);
 3129:   PRBool trustedEvent = PR_FALSE;
 3129: 
 3129:   if (domNSEvent) {
 3129:     domNSEvent->GetIsTrusted(&trustedEvent);
 3129:   }
 3129: 
 3129:   if (!trustedEvent)
 3129:     return NS_OK;
 3129: 
 3129:   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aKeyEvent);
 3129:   PRUint32 theChar;
 3129:   keyEvent->GetKeyCode(&theChar);
 3129: 
 7871:   // Escape should close panels, but the other keys should have no effect.
 7871:   nsMenuChainItem* item = GetTopVisibleMenu();
 7871:   if (item && item->PopupType() != ePopupTypeMenu) {
 7871:     if (theChar == NS_VK_ESCAPE) {
 7871:       HidePopup(item->Content(), PR_FALSE, PR_FALSE, PR_FALSE);
 7871:       aKeyEvent->StopPropagation();
 7871:       aKeyEvent->PreventDefault();
 7871:     }
 7871:     return NS_OK;
 7871:   }
 7871: 
 8260:   // if a menu is open or a menubar is active, it consumes the key event
22371:   PRBool consume = (mPopups || mActiveMenuBar);
 8260: 
 3129:   if (theChar == NS_VK_LEFT ||
 3129:       theChar == NS_VK_RIGHT ||
 3129:       theChar == NS_VK_UP ||
 3129:       theChar == NS_VK_DOWN ||
 3129:       theChar == NS_VK_HOME ||
 3129:       theChar == NS_VK_END) {
 3129:     HandleKeyboardNavigation(theChar);
 3129:   }
 3129:   else if (theChar == NS_VK_ESCAPE) {
 4669:     // Pressing Escape hides one level of menus only. If no menu is open,
 4669:     // check if a menubar is active and inform it that a menu closed. Even
 4669:     // though in this latter case, a menu didn't actually close, the effect
 4669:     // ends up being the same. Similar for the tab key below.
 4668:     if (item)
 4668:       HidePopup(item->Content(), PR_FALSE, PR_FALSE, PR_FALSE);
 4669:     else if (mActiveMenuBar)
 4669:       mActiveMenuBar->MenuClosed();
 3129:   }
 8260:   else if (theChar == NS_VK_TAB
 8260: #ifndef XP_MACOSX
 8260:            || theChar == NS_VK_F10
 8260: #endif
 8260:   ) {
 8260:     // close popups or deactivate menubar when Tab or F10 are pressed
 8260:     if (item)
29148:       Rollup(nsnull, nsnull);
 4669:     else if (mActiveMenuBar)
 4669:       mActiveMenuBar->MenuClosed();
 3129:   }
 3129:   else if (theChar == NS_VK_ENTER ||
 3129:            theChar == NS_VK_RETURN) {
 3129:     // If there is a popup open, check if the current item needs to be opened.
 3129:     // Otherwise, tell the active menubar, if any, to activate the menu. The
 3129:     // Enter method will return a menu if one needs to be opened as a result.
 3129:     nsMenuFrame* menuToOpen = nsnull;
 4668:     nsMenuChainItem* item = GetTopVisibleMenu();
 4668:     if (item)
 4668:       menuToOpen = item->Frame()->Enter();
 3129:     else if (mActiveMenuBar)
 3129:       menuToOpen = mActiveMenuBar->Enter();
 3129:     if (menuToOpen) {
 3129:       nsCOMPtr<nsIContent> content = menuToOpen->GetContent();
 3129:       ShowMenu(content, PR_TRUE, PR_FALSE);
 3129:     }
 3129:   }
 3129:   else {
 3779:     HandleShortcutNavigation(keyEvent, nsnull);
 3129:   }
 3129: 
 8260:   if (consume) {
 3129:     aKeyEvent->StopPropagation();
 3129:     aKeyEvent->PreventDefault();
 5218:   }
 5218: 
 3129:   return NS_OK; // I am consuming event
 3129: }
 3129: 
 3129: static nsPresContext*
 3129: GetPresContextFor(nsIContent* aContent)
 3129: {
 3129:   nsIDocument *document = aContent->GetCurrentDoc();
 3129:   if (document) {
 3129:     nsIPresShell* presShell = document->GetPrimaryShell();
 3129:     if (presShell)
 3129:       return presShell->GetPresContext();
 3129:   }
 3129: 
 3129:   return nsnull;
 3129: }
 3129: 
 3129: NS_IMETHODIMP
 3129: nsXULPopupShowingEvent::Run()
 3129: {
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   nsPresContext* context = GetPresContextFor(mPopup);
 3129:   if (pm && context) {
23975:     pm->FirePopupShowingEvent(mPopup, mMenu, context, mPopupType,
 3129:                               mIsContextMenu, mSelectFirstItem);
 3129:   }
 3129: 
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: NS_IMETHODIMP
 3129: nsXULPopupHidingEvent::Run()
 3129: {
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   nsPresContext* context = GetPresContextFor(mPopup);
 3129:   if (pm && context) {
 3129:     pm->FirePopupHidingEvent(mPopup, mNextPopup, mLastPopup,
 4709:                              context, mPopupType, mDeselectMenu);
 3129:   }
 3129: 
 3129:   return NS_OK;
 3129: }
 3129: 
 3129: NS_IMETHODIMP
 3129: nsXULMenuCommandEvent::Run()
 3129: {
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   if (!pm)
 3129:     return NS_OK;
 3129: 
 3129:   // The order of the nsIViewManager and nsIPresShell COM pointers is
 3129:   // important below.  We want the pres shell to get released before the
 3129:   // associated view manager on exit from this function.
 3129:   // See bug 54233.
 3129:   // XXXndeakin is this still needed?
 5227: 
 5227:   nsCOMPtr<nsIContent> popup;
 3129:   nsMenuFrame* menuFrame = pm->GetMenuFrameForContent(mMenu);
 3129:   if (menuFrame) {
 5227:     // Find the popup that the menu is inside. Below, this popup will
 5227:     // need to be hidden.
 5227:     nsIFrame* popupFrame = menuFrame->GetParent();
 5227:     while (popupFrame) {
 8591:       if (popupFrame->GetType() == nsGkAtoms::menuPopupFrame) {
 8591:         popup = popupFrame->GetContent();
 7205:         break;
 7205:       }
 5227:       popupFrame = popupFrame->GetParent();
 5227:     }
 5227: 
 3129:     nsPresContext* presContext = menuFrame->PresContext();
 3129:     nsCOMPtr<nsIPresShell> shell = presContext->PresShell();
26050:     nsCOMPtr<nsIViewManager> kungFuDeathGrip = shell->GetViewManager();
 3129: 
 3129:     // Deselect ourselves.
 5462:     if (mCloseMenuMode != CloseMenuMode_None)
 3129:       menuFrame->SelectMenu(PR_FALSE);
 3129: 
32435:     nsAutoHandlingUserInputStatePusher userInpStatePusher(mUserInput, PR_FALSE);
29844:     nsContentUtils::DispatchXULCommand(mMenu, mIsTrusted, nsnull, shell,
29844:                                        mControl, mAlt, mShift, mMeta);
 3129:   }
 3129: 
 5462:   if (popup && mCloseMenuMode != CloseMenuMode_None)
 6051:     pm->HidePopup(popup, mCloseMenuMode == CloseMenuMode_Auto, PR_TRUE, PR_FALSE);
 3129: 
 3129:   return NS_OK;
 3129: }
 8408: 
 8408: nsresult
 8408: NS_NewXULPopupManager(nsISupports** aResult)
 8408: {
 8408:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 8408:   NS_IF_ADDREF(pm);
 8408:   *aResult = static_cast<nsIMenuRollup *>(pm);
 8408:   return NS_OK;
 8408: }
