  144: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  144: /* ***** BEGIN LICENSE BLOCK *****
  144:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  144:  *
  144:  * The contents of this file are subject to the Mozilla Public License Version
  144:  * 1.1 (the "License"); you may not use this file except in compliance with
  144:  * the License. You may obtain a copy of the License at
  144:  * http://www.mozilla.org/MPL/
  144:  *
  144:  * Software distributed under the License is distributed on an "AS IS" basis,
  144:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  144:  * for the specific language governing rights and limitations under the
  144:  * License.
  144:  *
  144:  * The Original Code is mozilla.org code.
  144:  *
  144:  * The Initial Developer of the Original Code is
  144:  * Mozilla Foundation.
  144:  * Portions created by the Initial Developer are Copyright (C) 2007
  144:  * the Initial Developer. All Rights Reserved.
  144:  *
  144:  * Contributor(s):
  144:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
  144:  *
  144:  * Alternatively, the contents of this file may be used under the terms of
  144:  * either of the GNU General Public License Version 2 or later (the "GPL"),
  144:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  144:  * in which case the provisions of the GPL or the LGPL are applicable instead
  144:  * of those above. If you wish to allow use of your version of this file only
  144:  * under the terms of either the GPL or the LGPL, and not to allow others to
  144:  * use your version of this file under the terms of the MPL, indicate your
  144:  * decision by deleting the provisions above and replace them with the notice
  144:  * and other provisions required by the GPL or the LGPL. If you do not delete
  144:  * the provisions above, a recipient may use your version of this file under
  144:  * the terms of any one of the MPL, the GPL or the LGPL.
  144:  *
  144:  * ***** END LICENSE BLOCK ***** */
  144: 
20521: #include "nsCoreUtils.h"
 3152: 
 5245: #include "nsIAccessibleTypes.h"
 3152: 
20536: #include "nsAccessNode.h"
20536: 
 5679: #include "nsIDocument.h"
 5679: #include "nsIDOMAbstractView.h"
 7830: #include "nsIDOM3Node.h"
 5679: #include "nsIDOMDocument.h"
 5679: #include "nsIDOMDocumentView.h"
 6279: #include "nsIDOMDocumentXBL.h"
20138: #include "nsIDOMHTMLDocument.h"
20138: #include "nsIDOMHTMLElement.h"
 6279: #include "nsIDOMNodeList.h"
 5245: #include "nsIDOMRange.h"
20566: #include "nsIDOMViewCSS.h"
 5679: #include "nsIDOMWindowInternal.h"
28029: #include "nsIDOMXULElement.h"
20566: #include "nsIDocShell.h"
20566: #include "nsIContentViewer.h"
 1294: #include "nsIEventListenerManager.h"
 5414: #include "nsIPresShell.h"
 5414: #include "nsPresContext.h"
 6286: #include "nsIScrollableFrame.h"
 5414: #include "nsIEventStateManager.h"
 5245: #include "nsISelection2.h"
 5245: #include "nsISelectionController.h"
20566: #include "nsPIDOMWindow.h"
16427: #include "nsGUIEvent.h"
37062: #include "nsIView.h"
 5245: 
 5245: #include "nsContentCID.h"
 5245: #include "nsComponentManagerUtils.h"
 5679: #include "nsIInterfaceRequestorUtils.h"
 5245: 
 5245: static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
  144: 
41384: ////////////////////////////////////////////////////////////////////////////////
41384: // nsCoreUtils
41384: ////////////////////////////////////////////////////////////////////////////////
41384: 
 3146: PRBool
37859: nsCoreUtils::HasClickListener(nsIContent *aContent)
 1294: {
11916:   NS_ENSURE_TRUE(aContent, PR_FALSE);
29474:   nsIEventListenerManager* listenerManager =
29474:     aContent->GetListenerManager(PR_FALSE);
 1294: 
37859:   return listenerManager &&
37859:     (listenerManager->HasListenersFor(NS_LITERAL_STRING("click")) ||
37859:      listenerManager->HasListenersFor(NS_LITERAL_STRING("mousedown")) ||
37859:      listenerManager->HasListenersFor(NS_LITERAL_STRING("mouseup")));
 1294: }
 1294: 
31673: void
31673: nsCoreUtils::DispatchClickEvent(nsITreeBoxObject *aTreeBoxObj,
31673:                                 PRInt32 aRowIndex, nsITreeColumn *aColumn,
31673:                                 const nsCString& aPseudoElt)
31673: {
31673:   nsCOMPtr<nsIDOMElement> tcElm;
31673:   aTreeBoxObj->GetTreeBody(getter_AddRefs(tcElm));
31673:   if (!tcElm)
31673:     return;
31673: 
31673:   nsCOMPtr<nsIContent> tcContent(do_QueryInterface(tcElm));
31673:   nsIDocument *document = tcContent->GetCurrentDoc();
31673:   if (!document)
31673:     return;
31673: 
31673:   nsIPresShell *presShell = nsnull;
31673:   presShell = document->GetPrimaryShell();
31673:   if (!presShell)
31673:     return;
31673: 
31673:   // Ensure row is visible.
31673:   aTreeBoxObj->EnsureRowIsVisible(aRowIndex);
31673: 
31673:   // Calculate x and y coordinates.
31673:   PRInt32 x = 0, y = 0, width = 0, height = 0;
31673:   nsresult rv = aTreeBoxObj->GetCoordsForCellItem(aRowIndex, aColumn,
31673:                                                   aPseudoElt,
31673:                                                   &x, &y, &width, &height);
31673:   if (NS_FAILED(rv))
31673:     return;
31673: 
31673:   nsCOMPtr<nsIDOMXULElement> tcXULElm(do_QueryInterface(tcElm));
31673:   nsCOMPtr<nsIBoxObject> tcBoxObj;
31673:   tcXULElm->GetBoxObject(getter_AddRefs(tcBoxObj));
31673: 
31673:   PRInt32 tcX = 0;
31673:   tcBoxObj->GetX(&tcX);
31673: 
31673:   PRInt32 tcY = 0;
31673:   tcBoxObj->GetY(&tcY);
31673: 
31673:   // Dispatch mouse events.
36654:   nsIFrame* tcFrame = tcContent->GetPrimaryFrame();
31673:   nsIFrame* rootFrame = presShell->GetRootFrame();
31673: 
31673:   nsPoint offset;
31673:   nsIWidget *rootWidget =
31673:     rootFrame->GetViewExternal()->GetNearestWidget(&offset);
31673: 
31673:   nsPresContext* presContext = presShell->GetPresContext();
31673: 
31673:   PRInt32 cnvdX = presContext->CSSPixelsToDevPixels(tcX + x + 1) +
31673:     presContext->AppUnitsToDevPixels(offset.x);
31673:   PRInt32 cnvdY = presContext->CSSPixelsToDevPixels(tcY + y + 1) +
31673:     presContext->AppUnitsToDevPixels(offset.y);
31673: 
31673:   DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, cnvdX, cnvdY,
31673:                      tcContent, tcFrame, presShell, rootWidget);
31673: 
31673:   DispatchMouseEvent(NS_MOUSE_BUTTON_UP, cnvdX, cnvdY,
31673:                      tcContent, tcFrame, presShell, rootWidget);
31673: }
31673: 
16427: PRBool
20521: nsCoreUtils::DispatchMouseEvent(PRUint32 aEventType,
16427:                                 nsIPresShell *aPresShell,
16427:                                 nsIContent *aContent)
16427: {
36654:   nsIFrame *frame = aContent->GetPrimaryFrame();
16427:   if (!frame)
16427:     return PR_FALSE;
16427: 
16427:   nsIFrame* rootFrame = aPresShell->GetRootFrame();
16427:   if (!rootFrame)
16427:     return PR_FALSE;
16427: 
16427:   nsCOMPtr<nsIWidget> rootWidget = rootFrame->GetWindow();
16427:   if (!rootWidget)
16427:     return PR_FALSE;
16427: 
16427:   // Compute x and y coordinates.
16427:   nsPoint point = frame->GetOffsetToExternal(rootFrame);
16427:   nsSize size = frame->GetSize();
16427: 
16427:   nsPresContext* presContext = aPresShell->GetPresContext();
16427: 
16427:   PRInt32 x = presContext->AppUnitsToDevPixels(point.x + size.width / 2);
16427:   PRInt32 y = presContext->AppUnitsToDevPixels(point.y + size.height / 2);
16427: 
16427:   // Fire mouse event.
31673:   DispatchMouseEvent(aEventType, x, y, aContent, frame, aPresShell, rootWidget);
31673:   return PR_TRUE;
31673: }
31673: 
31673: void
31673: nsCoreUtils::DispatchMouseEvent(PRUint32 aEventType, PRInt32 aX, PRInt32 aY,
31673:                                 nsIContent *aContent, nsIFrame *aFrame,
31673:                                 nsIPresShell *aPresShell, nsIWidget *aRootWidget)
31673: {
31673:   nsMouseEvent event(PR_TRUE, aEventType, aRootWidget,
16427:                      nsMouseEvent::eReal, nsMouseEvent::eNormal);
16427: 
31673:   event.refPoint = nsIntPoint(aX, aY);
16427: 
16427:   event.clickCount = 1;
16427:   event.button = nsMouseEvent::eLeftButton;
16427:   event.time = PR_IntervalNow();
16427: 
16427:   nsEventStatus status = nsEventStatus_eIgnore;
31673:   aPresShell->HandleEventWithTarget(&event, aFrame, aContent, &status);
16427: }
16427: 
 5414: PRUint32
20521: nsCoreUtils::GetAccessKeyFor(nsIContent *aContent)
 5414: {
 5414:   if (!aContent)
 5414:     return 0;
 5414: 
 5414:   // Accesskeys are registered by @accesskey attribute only. At first check
 5414:   // whether it is presented on the given element to avoid the slow
 5414:   // nsIEventStateManager::GetRegisteredAccessKey() method.
 5414:   if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::accesskey))
 5414:     return 0;
 5414: 
 5414:   nsCOMPtr<nsIDocument> doc = aContent->GetOwnerDoc();
 5414:   if (!doc)
 5414:     return 0;
 5414: 
 5414:   nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
 5414:   if (!presShell)
 5414:     return 0;
 5414: 
 5414:   nsPresContext *presContext = presShell->GetPresContext();
 5414:   if (!presContext)
 5414:     return 0;
 5414: 
 5414:   nsIEventStateManager *esm = presContext->EventStateManager();
 5414:   if (!esm)
 5414:     return 0;
 5414: 
 5414:   PRUint32 key = 0;
 5414:   esm->GetRegisteredAccessKey(aContent, &key);
 5414:   return key;
 5414: }
 5414: 
16001: already_AddRefed<nsIDOMElement>
20521: nsCoreUtils::GetDOMElementFor(nsIDOMNode *aNode)
16001: {
16001:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
20138:   nsIDOMElement *element = nsnull;
19825: 
41645:   if (node->IsElement())
16001:     CallQueryInterface(node, &element);
20138: 
21084:   else if (node->IsNodeOfType(nsINode::eTEXT)) {
21084:     nsCOMPtr<nsINode> nodeParent = node->GetNodeParent();
21084:     NS_ASSERTION(nodeParent, "Text node has no parent!");
21084:     if (nodeParent)
21084:       CallQueryInterface(nodeParent, &element);
21084:   }
20138: 
16001:   else if (node->IsNodeOfType(nsINode::eDOCUMENT)) {
20138:     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(node));
20138:     if (htmlDoc) {
20138:       nsCOMPtr<nsIDOMHTMLElement> bodyElement;
20138:       htmlDoc->GetBody(getter_AddRefs(bodyElement));
20138:       if (bodyElement) {
20138:         CallQueryInterface(bodyElement, &element);
20138:         return element;
20138:       }
20138:     }
20138: 
16001:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(node));
16001:     domDoc->GetDocumentElement(&element);
16001:   }
16001: 
16001:   return element;
16001: }
16001: 
42796: nsINode *
42796: nsCoreUtils::GetDOMNodeFromDOMPoint(nsINode *aNode, PRUint32 aOffset)
22834: {
42796:   if (aNode && aNode->IsElement()) {
42796:     PRUint32 childCount = aNode->GetChildCount();
22834:     NS_ASSERTION(aOffset >= 0 && aOffset <= childCount,
22834:                  "Wrong offset of the DOM point!");
22834: 
22834:     // The offset can be after last child of container node that means DOM point
22834:     // is placed immediately after the last child. In this case use the DOM node
22834:     // from the given DOM point is used as result node.
42796:     if (aOffset != childCount)
42796:       return aNode->GetChildAt(aOffset);
22834:   }
22834: 
42796:   return aNode;
22834: }
22834: 
20566: nsIContent*
20566: nsCoreUtils::GetRoleContent(nsIDOMNode *aDOMNode)
20566: {
20566:   nsCOMPtr<nsIContent> content(do_QueryInterface(aDOMNode));
20566:   if (!content) {
20566:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(aDOMNode));
20566:     if (domDoc) {
20566:       nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(aDOMNode));
20566:       if (htmlDoc) {
20566:         nsCOMPtr<nsIDOMHTMLElement> bodyElement;
20566:         htmlDoc->GetBody(getter_AddRefs(bodyElement));
20566:         content = do_QueryInterface(bodyElement);
20566:       }
20566:       else {
20566:         nsCOMPtr<nsIDOMElement> docElement;
20566:         domDoc->GetDocumentElement(getter_AddRefs(docElement));
20566:         content = do_QueryInterface(docElement);
20566:       }
20566:     }
20566:   }
20566: 
20566:   return content;
20566: }
20566: 
 4637: PRBool
37539: nsCoreUtils::IsAncestorOf(nsINode *aPossibleAncestorNode,
43441:                           nsINode *aPossibleDescendantNode,
43441:                           nsINode *aRootNode)
 4637: {
13167:   NS_ENSURE_TRUE(aPossibleAncestorNode && aPossibleDescendantNode, PR_FALSE);
 4637: 
37539:   nsINode *parentNode = aPossibleDescendantNode;
43503:   while ((parentNode = parentNode->GetNodeParent()) &&
43503:          parentNode != aRootNode) {
37539:     if (parentNode == aPossibleAncestorNode)
 4637:       return PR_TRUE;
 4637:   }
37539: 
 4637:   return PR_FALSE;
 4637: }
 4637: 
 5245: nsresult
20521: nsCoreUtils::ScrollSubstringTo(nsIFrame *aFrame,
 5245:                                nsIDOMNode *aStartNode, PRInt32 aStartIndex,
 5245:                                nsIDOMNode *aEndNode, PRInt32 aEndIndex,
 5245:                                PRUint32 aScrollType)
 5245: {
 6286:   PRInt16 vPercent, hPercent;
 6286:   ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
 6286: 
 6286:   return ScrollSubstringTo(aFrame, aStartNode, aStartIndex, aEndNode, aEndIndex,
 6286:                            vPercent, hPercent);
 6286: }
 6286: 
 6286: nsresult
20521: nsCoreUtils::ScrollSubstringTo(nsIFrame *aFrame,
 6286:                                nsIDOMNode *aStartNode, PRInt32 aStartIndex,
 6286:                                nsIDOMNode *aEndNode, PRInt32 aEndIndex,
 6286:                                PRInt16 aVPercent, PRInt16 aHPercent)
 6286: {
 5245:   if (!aFrame || !aStartNode || !aEndNode)
 5245:     return NS_ERROR_FAILURE;
 5245: 
 5245:   nsPresContext *presContext = aFrame->PresContext();
 5245: 
 5245:   nsCOMPtr<nsIDOMRange> scrollToRange = do_CreateInstance(kRangeCID);
 5245:   NS_ENSURE_TRUE(scrollToRange, NS_ERROR_FAILURE);
 5245: 
 5245:   nsCOMPtr<nsISelectionController> selCon;
 5245:   aFrame->GetSelectionController(presContext, getter_AddRefs(selCon));
 5245:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
 5245: 
 5245:   scrollToRange->SetStart(aStartNode, aStartIndex);
 5245:   scrollToRange->SetEnd(aEndNode, aEndIndex);
 5245: 
 5245:   nsCOMPtr<nsISelection> selection1;
 5245:   selCon->GetSelection(nsISelectionController::SELECTION_ACCESSIBILITY,
 5245:                        getter_AddRefs(selection1));
 5245: 
 5245:   nsCOMPtr<nsISelection2> selection(do_QueryInterface(selection1));
 5245:   if (selection) {
 5245:     selection->RemoveAllRanges();
 5245:     selection->AddRange(scrollToRange);
 5245: 
 5245:     selection->ScrollIntoView(nsISelectionController::SELECTION_ANCHOR_REGION,
 6286:                               PR_TRUE, aVPercent, aHPercent);
 5245: 
 5245:     selection->CollapseToStart();
 5245:   }
 5245: 
 5245:   return NS_OK;
 5245: }
 5245: 
 5245: void
20521: nsCoreUtils::ScrollFrameToPoint(nsIFrame *aScrollableFrame,
 6286:                                 nsIFrame *aFrame,
 6286:                                 const nsIntPoint& aPoint)
 6286: {
23554:   nsIScrollableFrame *scrollableFrame = do_QueryFrame(aScrollableFrame);
 6286:   if (!scrollableFrame)
 6286:     return;
 6286: 
 6286:   nsPresContext *presContext = aFrame->PresContext();
 6286: 
 6286:   nsIntRect frameRect = aFrame->GetScreenRectExternal();
 6286:   PRInt32 devDeltaX = aPoint.x - frameRect.x;
 6286:   PRInt32 devDeltaY = aPoint.y - frameRect.y;
 6286: 
 6286:   nsPoint deltaPoint;
 6286:   deltaPoint.x = presContext->DevPixelsToAppUnits(devDeltaX);
 6286:   deltaPoint.y = presContext->DevPixelsToAppUnits(devDeltaY);
 6286: 
 6286:   nsPoint scrollPoint = scrollableFrame->GetScrollPosition();
 6286:   scrollPoint -= deltaPoint;
 6286: 
37055:   scrollableFrame->ScrollTo(scrollPoint, nsIScrollableFrame::INSTANT);
 6286: }
 6286: 
 6286: void
20521: nsCoreUtils::ConvertScrollTypeToPercents(PRUint32 aScrollType,
 5245:                                          PRInt16 *aVPercent,
 5245:                                          PRInt16 *aHPercent)
 5245: {
 5245:   switch (aScrollType)
 5245:   {
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_TOP;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_TOP_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_TOP;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_LEFT_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_RIGHT_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
 5245:       break;
 5245:     default:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:   }
 5245: }
 5245: 
 5679: nsIntPoint
20521: nsCoreUtils::GetScreenCoordsForWindow(nsIDOMNode *aNode)
 5679: {
 5679:   nsIntPoint coords(0, 0);
 5679:   nsCOMPtr<nsIDocShellTreeItem> treeItem(GetDocShellTreeItemFor(aNode));
 5679:   if (!treeItem)
 5679:     return coords;
 5679: 
 5679:   nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
 5679:   treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
 5679:   nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(rootTreeItem);
 5679:   nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(domDoc));
 5679:   if (!docView)
 5679:     return coords;
 5679: 
 5679:   nsCOMPtr<nsIDOMAbstractView> abstractView;
 5679:   docView->GetDefaultView(getter_AddRefs(abstractView));
 5679:   nsCOMPtr<nsIDOMWindowInternal> windowInter(do_QueryInterface(abstractView));
 5679:   if (!windowInter)
 5679:     return coords;
 5679: 
 5679:   windowInter->GetScreenX(&coords.x);
 5679:   windowInter->GetScreenY(&coords.y);
 5679:   return coords;
 5679: }
 5679: 
 5679: already_AddRefed<nsIDocShellTreeItem>
20521: nsCoreUtils::GetDocShellTreeItemFor(nsIDOMNode *aNode)
 5679: {
 5679:   if (!aNode)
 5679:     return nsnull;
 5679: 
 5679:   nsCOMPtr<nsIDOMDocument> domDoc;
 5679:   aNode->GetOwnerDocument(getter_AddRefs(domDoc));
 5679:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
 5679:   if (!doc)
 5679:     doc = do_QueryInterface(aNode);
 5679: 
 5679:   NS_ASSERTION(doc, "No document for node passed in");
 5679:   NS_ENSURE_TRUE(doc, nsnull);
 5679: 
 5679:   nsCOMPtr<nsISupports> container = doc->GetContainer();
 5679:   nsIDocShellTreeItem *docShellTreeItem = nsnull;
 5679:   if (container)
 5679:     CallQueryInterface(container, &docShellTreeItem);
 5679: 
 5679:   return docShellTreeItem;
 5679: }
 5679: 
43310: PRBool
43310: nsCoreUtils::IsDocumentBusy(nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
43310:   if (!docShell)
43310:     return PR_TRUE;
43310: 
43310:   PRUint32 busyFlags = 0;
43310:   docShell->GetBusyFlags(&busyFlags);
43310:   return (busyFlags != nsIDocShell::BUSY_FLAGS_NONE);
43310: }
43310: 
43310: PRBool
43310: nsCoreUtils::IsRootDocument(nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43310:     do_QueryInterface(container);
43310:   NS_ASSERTION(docShellTreeItem, "No document shell for document!");
43310: 
43310:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
43310:   docShellTreeItem->GetParent(getter_AddRefs(parentTreeItem));
43310: 
43310:   return !parentTreeItem;
43310: }
43310: 
43310: PRBool
43310: nsCoreUtils::IsContentDocument(nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43310:     do_QueryInterface(container);
43310:   NS_ASSERTION(docShellTreeItem, "No document shell tree item for document!");
43310: 
43310:   PRInt32 contentType;
43310:   docShellTreeItem->GetItemType(&contentType);
43310:   return (contentType == nsIDocShellTreeItem::typeContent);
43310: }
43310: 
43310: PRBool
43310: nsCoreUtils::IsErrorPage(nsIDocument *aDocument)
43310: {
43310:   nsIURI *uri = aDocument->GetDocumentURI();
43310:   PRBool isAboutScheme = PR_FALSE;
43310:   uri->SchemeIs("about", &isAboutScheme);
43310:   if (!isAboutScheme)
43310:     return PR_FALSE;
43310: 
43310:   nsCAutoString path;
43310:   uri->GetPath(path);
43310: 
43310:   nsCAutoString::const_iterator start, end;
43310:   path.BeginReading(start);
43310:   path.EndReading(end);
43310: 
43310:   NS_NAMED_LITERAL_CSTRING(neterror, "neterror");
43310:   return FindInReadable(neterror, start, end);
43310: }
43310: 
18496: nsIFrame*
20521: nsCoreUtils::GetFrameFor(nsIDOMElement *aElm)
18496: {
18496:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElm));
18496:   if (!content)
18496:     return nsnull;
18496:   
36654:   return content->GetPrimaryFrame();
18496: }
18496: 
 6065: PRBool
20566: nsCoreUtils::IsCorrectFrameType(nsIFrame *aFrame, nsIAtom *aAtom)
20566: {
20566:   NS_ASSERTION(aFrame != nsnull,
20566:                "aFrame is null in call to IsCorrectFrameType!");
20566:   NS_ASSERTION(aAtom != nsnull,
20566:                "aAtom is null in call to IsCorrectFrameType!");
20566:   
20566:   return aFrame->GetType() == aAtom;
20566: }
20566: 
20566: already_AddRefed<nsIDOMNode>
20566: nsCoreUtils::GetDOMNodeForContainer(nsIDocShellTreeItem *aContainer)
20566: {
20566:   nsCOMPtr<nsIDocShell> shell = do_QueryInterface(aContainer);
20566: 
20566:   nsCOMPtr<nsIContentViewer> cv;
20566:   shell->GetContentViewer(getter_AddRefs(cv));
20566: 
20566:   if (!cv)
20566:     return nsnull;
20566: 
37433:   nsIDocument* doc = cv->GetDocument();
20566:   if (!doc)
20566:     return nsnull;
20566: 
20566:   nsIDOMNode* node = nsnull;
37433:   CallQueryInterface(doc, &node);
20566:   return node;
20566: }
20566: 
20566: PRBool
20521: nsCoreUtils::GetID(nsIContent *aContent, nsAString& aID)
 6065: {
 6065:   nsIAtom *idAttribute = aContent->GetIDAttributeName();
 6065:   return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;
 6065: }
 6279: 
13757: PRBool
37109: nsCoreUtils::GetUIntAttr(nsIContent *aContent, nsIAtom *aAttr, PRInt32 *aUInt)
37109: {
37109:   nsAutoString value;
37109:   aContent->GetAttr(kNameSpaceID_None, aAttr, value);
37109:   if (!value.IsEmpty()) {
37109:     PRInt32 error = NS_OK;
37109:     PRInt32 integer = value.ToInteger(&error);
37109:     if (NS_SUCCEEDED(error) && integer > 0) {
37109:       *aUInt = integer;
37109:       return PR_TRUE;
37109:     }
37109:   }
37109: 
37109:   return PR_FALSE;
37109: }
37109: 
37109: PRBool
20521: nsCoreUtils::IsXLink(nsIContent *aContent)
13757: {
13775:   if (!aContent)
13775:     return PR_FALSE;
13775: 
13757:   return aContent->AttrValueIs(kNameSpaceID_XLink, nsAccessibilityAtoms::type,
13757:                                nsAccessibilityAtoms::simple, eCaseMatters) &&
13757:          aContent->HasAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href);
13757: }
13757: 
 6279: nsIContent*
20521: nsCoreUtils::FindNeighbourPointingToNode(nsIContent *aForNode, 
 8937:                                          nsIAtom *aRelationAttr,
 6279:                                          nsIAtom *aTagName,
 6279:                                          PRUint32 aAncestorLevelsToSearch)
 6279: {
10515:   return FindNeighbourPointingToNode(aForNode, &aRelationAttr, 1, aTagName, aAncestorLevelsToSearch);
10515: }
10515: 
10515: nsIContent*
20521: nsCoreUtils::FindNeighbourPointingToNode(nsIContent *aForNode, 
10515:                                          nsIAtom **aRelationAttrs,
10515:                                          PRUint32 aAttrNum,
10515:                                          nsIAtom *aTagName,
10515:                                          PRUint32 aAncestorLevelsToSearch)
10515: {
 6279:   nsAutoString controlID;
20521:   if (!nsCoreUtils::GetID(aForNode, controlID)) {
16143:     if (!aForNode->IsInAnonymousSubtree())
 6279:       return nsnull;
 6279: 
 6279:     aForNode->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::anonid, controlID);
 6279:     if (controlID.IsEmpty())
 6279:       return nsnull;
 6279:   }
 6279: 
 6279:   // Look for label in subtrees of nearby ancestors
16127:   nsCOMPtr<nsIContent> binding(aForNode->GetBindingParent());
 6279:   PRUint32 count = 0;
 6279:   nsIContent *labelContent = nsnull;
 6279:   nsIContent *prevSearched = nsnull;
 6279: 
 6279:   while (!labelContent && ++count <= aAncestorLevelsToSearch &&
 6279:          (aForNode = aForNode->GetParent()) != nsnull) {
 6279: 
 6279:     if (aForNode == binding) {
 6279:       // When we reach the binding parent, make sure to check
 6279:       // all of its anonymous child subtrees
 6279:       nsCOMPtr<nsIDocument> doc = aForNode->GetCurrentDoc();
 6279:       nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(doc));
 6279:       if (!xblDoc)
 6279:         return nsnull;
 6279: 
 6279:       nsCOMPtr<nsIDOMNodeList> nodes;
 6279:       nsCOMPtr<nsIDOMElement> forElm(do_QueryInterface(aForNode));
 6279:       xblDoc->GetAnonymousNodes(forElm, getter_AddRefs(nodes));
 6279:       if (!nodes)
 6279:         return nsnull;
 6279: 
 6279:       PRUint32 length;
 6279:       nsresult rv = nodes->GetLength(&length);
 6279:       if (NS_FAILED(rv))
 6279:         return nsnull;
 6279: 
 6279:       for (PRUint32 index = 0; index < length && !labelContent; index++) {
 6279:         nsCOMPtr<nsIDOMNode> node;
 6279:         rv = nodes->Item(index, getter_AddRefs(node));
 6279:         if (NS_FAILED(rv))
 6279:           return nsnull;
 6279: 
 6279:         nsCOMPtr<nsIContent> content = do_QueryInterface(node);
 6279:         if (!content)
 6279:           return nsnull;
 6279: 
 6279:         if (content != prevSearched) {
 8937:           labelContent = FindDescendantPointingToID(&controlID, content,
10515:                                                     aRelationAttrs, aAttrNum,
10515:                                                     nsnull, aTagName);
 6279:         }
 6279:       }
 6279:       break;
 6279:     }
 6279: 
 8937:     labelContent = FindDescendantPointingToID(&controlID, aForNode,
10515:                                               aRelationAttrs, aAttrNum,
10515:                                               prevSearched, aTagName);
 6279:     prevSearched = aForNode;
 6279:   }
 6279: 
 6279:   return labelContent;
 6279: }
 6279: 
 6279: // Pass in aAriaProperty = null and aRelationAttr == nsnull if any <label> will do
 6279: nsIContent*
20521: nsCoreUtils::FindDescendantPointingToID(const nsString *aId,
 6279:                                         nsIContent *aLookContent,
10515:                                         nsIAtom **aRelationAttrs,
10515:                                         PRUint32 aAttrNum,
 6279:                                         nsIContent *aExcludeContent,
 6279:                                         nsIAtom *aTagType)
 6279: {
 6279:   // Surround id with spaces for search
 6279:   nsCAutoString idWithSpaces(' ');
 6279:   LossyAppendUTF16toASCII(*aId, idWithSpaces);
 6279:   idWithSpaces += ' ';
 6279:   return FindDescendantPointingToIDImpl(idWithSpaces, aLookContent,
10515:                                         aRelationAttrs, aAttrNum,
10515:                                         aExcludeContent, aTagType);
10515: }
10515: 
10515: nsIContent*
20521: nsCoreUtils::FindDescendantPointingToID(const nsString *aId,
10515:                                         nsIContent *aLookContent,
10515:                                         nsIAtom *aRelationAttr,
10515:                                         nsIContent *aExcludeContent,
10515:                                         nsIAtom *aTagType)
10515: {
10515:   return FindDescendantPointingToID(aId, aLookContent, &aRelationAttr, 1, aExcludeContent, aTagType);
 6279: }
 6279: 
 6279: nsIContent*
20521: nsCoreUtils::FindDescendantPointingToIDImpl(nsCString& aIdWithSpaces,
 6279:                                             nsIContent *aLookContent,
10515:                                             nsIAtom **aRelationAttrs,
10515:                                             PRUint32 aAttrNum,
 6279:                                             nsIContent *aExcludeContent,
 6279:                                             nsIAtom *aTagType)
 6279: {
 8937:   NS_ENSURE_TRUE(aLookContent, nsnull);
10515:   NS_ENSURE_TRUE(aRelationAttrs && *aRelationAttrs, nsnull);
 8937: 
 8937:   if (!aTagType || aLookContent->Tag() == aTagType) {
 6279:     // Tag matches
10515:     // Check for ID in the attributes aRelationAttrs, which can be a list
10515:     for (PRUint32 i = 0; i < aAttrNum; i++) {
 6279:       nsAutoString idList;
10515:       if (aLookContent->GetAttr(kNameSpaceID_None, aRelationAttrs[i], idList)) {
 6279:         idList.Insert(' ', 0);  // Surround idlist with spaces for search
 6279:         idList.Append(' ');
 6279:         // idList is now a set of id's with spaces around each,
 6279:         // and id also has spaces around it.
 6279:         // If id is a substring of idList then we have a match
 6279:         if (idList.Find(aIdWithSpaces) != -1) {
 6279:           return aLookContent;
 6279:         }
 6279:       }
10515:     }
 6279:     if (aTagType) {
 6279:       // Don't bother to search descendants of an element with matching tag.
 6279:       // That would be like looking for a nested <label> or <description>
 6279:       return nsnull;
 6279:     }
 6279:   }
 6279: 
 6279:   // Recursively search descendants for match
 6279:   PRUint32 count  = 0;
 6279:   nsIContent *child;
 6279:   nsIContent *labelContent = nsnull;
 6279: 
 6279:   while ((child = aLookContent->GetChildAt(count++)) != nsnull) {
 6279:     if (child != aExcludeContent) {
 6279:       labelContent = FindDescendantPointingToIDImpl(aIdWithSpaces, child,
10515:                                                     aRelationAttrs, aAttrNum,
10515:                                                     aExcludeContent, aTagType);
 6279:       if (labelContent) {
 6279:         return labelContent;
 6279:       }
 6279:     }
 6279:   }
 6279:   return nsnull;
 6279: }
 6279: 
20566: nsIContent*
20566: nsCoreUtils::GetLabelContent(nsIContent *aForNode)
20566: {
33329:   if (aForNode->IsXUL())
20566:     return FindNeighbourPointingToNode(aForNode, nsAccessibilityAtoms::control,
20566:                                        nsAccessibilityAtoms::label);
20566: 
20566:   return GetHTMLLabelContent(aForNode);
20566: }
20566: 
20566: nsIContent*
20566: nsCoreUtils::GetHTMLLabelContent(nsIContent *aForNode)
20566: {
20566:   // Get either <label for="[id]"> element which explictly points to aForNode,
20566:   // or <label> ancestor which implicitly point to it.
20566:   nsIContent *walkUpContent = aForNode;
20566:   
20566:   // Go up tree get name of ancestor label if there is one. Don't go up farther
20566:   // than form element.
20566:   while ((walkUpContent = walkUpContent->GetParent()) != nsnull) {
20566:     nsIAtom *tag = walkUpContent->Tag();
20566:     if (tag == nsAccessibilityAtoms::label)
20566:       return walkUpContent;  // An ancestor <label> implicitly points to us
20566: 
20566:     if (tag == nsAccessibilityAtoms::form ||
20566:         tag == nsAccessibilityAtoms::body) {
20566:       // Reached top ancestor in form
20566:       // There can be a label targeted at this control using the 
20566:       // for="control_id" attribute. To save computing time, only 
20566:       // look for those inside of a form element
20566:       nsAutoString forId;
20566:       if (!GetID(aForNode, forId))
20566:         break;
20566: 
20566:       // Actually we'll be walking down the content this time, with a depth first search
20566:       return FindDescendantPointingToID(&forId, walkUpContent,
20566:                                         nsAccessibilityAtoms::_for);
20566:     }
20566:   }
20566: 
20566:   return nsnull;
20566: }
20566: 
16001: void
20521: nsCoreUtils::GetLanguageFor(nsIContent *aContent, nsIContent *aRootContent,
16001:                             nsAString& aLanguage)
16001: {
16001:   aLanguage.Truncate();
16001: 
16001:   nsIContent *walkUp = aContent;
16001:   while (walkUp && walkUp != aRootContent &&
16001:          !walkUp->GetAttr(kNameSpaceID_None,
16001:                           nsAccessibilityAtoms::lang, aLanguage))
16001:     walkUp = walkUp->GetParent();
16001: }
20566: 
20566: void
24822: nsCoreUtils::GetElementsByIDRefsAttr(nsIContent *aContent, nsIAtom *aAttr,
24822:                                      nsIArray **aRefElements)
24822: {
24822:   *aRefElements = nsnull;
24822: 
24822:   nsAutoString ids;
24822:   if (!aContent->GetAttr(kNameSpaceID_None, aAttr, ids))
24822:     return;
24822: 
24822:   ids.CompressWhitespace(PR_TRUE, PR_TRUE);
24822: 
24822:   nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(aContent->GetOwnerDoc());
24822:   NS_ASSERTION(document, "The given node is not in document!");
24822:   if (!document)
24822:     return;
24822: 
28281:   nsCOMPtr<nsIDOMDocumentXBL> xblDocument;
28281:   if (aContent->IsInAnonymousSubtree())
28281:     xblDocument = do_QueryInterface(document);
28281: 
24822:   nsCOMPtr<nsIMutableArray> refElms = do_CreateInstance(NS_ARRAY_CONTRACTID);
24822: 
24822:   while (!ids.IsEmpty()) {
24822:     nsAutoString id;
24822:     PRInt32 idLength = ids.FindChar(' ');
24822:     NS_ASSERTION(idLength != 0,
24822:                  "Should not be 0 because of CompressWhitespace() call above");
24822: 
24822:     if (idLength == kNotFound) {
24822:       id = ids;
24822:       ids.Truncate();
24822:     } else {
24822:       id = Substring(ids, 0, idLength);
24822:       ids.Cut(0, idLength + 1);
24822:     }
24822: 
28281:     // If content is anonymous subtree then use "anonid" attribute to get
28281:     // elements, otherwise search elements in DOM by ID attribute.
24822:     nsCOMPtr<nsIDOMElement> refElement;
28281:     if (xblDocument) {
28281:       nsCOMPtr<nsIDOMElement> elm =
28281:         do_QueryInterface(aContent->GetBindingParent());
28281:       xblDocument->GetAnonymousElementByAttribute(elm,
28281:                                                   NS_LITERAL_STRING("anonid"),
28281:                                                   id,
28281:                                                   getter_AddRefs(refElement));
28281:     } else {
24822:       document->GetElementById(id, getter_AddRefs(refElement));
28281:     }
28281: 
24822:     if (!refElement)
24822:       continue;
24822: 
24822:     refElms->AppendElement(refElement, PR_FALSE);
24822:   }
24822: 
24822:   NS_ADDREF(*aRefElements = refElms);
24822:   return;
24822: }
24822: 
24822: void
28316: nsCoreUtils::GetElementsHavingIDRefsAttr(nsIContent *aRootContent,
28316:                                          nsIContent *aContent,
28316:                                          nsIAtom *aIDRefsAttr,
28316:                                          nsIArray **aElements)
28316: {
28316:   *aElements = nsnull;
28316: 
28316:   nsAutoString id;
28316:   if (!GetID(aContent, id))
28316:     return;
28316: 
28316:   nsCAutoString idWithSpaces(' ');
28316:   LossyAppendUTF16toASCII(id, idWithSpaces);
28316:   idWithSpaces += ' ';
28316: 
28316:   nsCOMPtr<nsIMutableArray> elms = do_CreateInstance(NS_ARRAY_CONTRACTID);
28316:   if (!elms)
28316:     return;
28316: 
28316:   GetElementsHavingIDRefsAttrImpl(aRootContent, idWithSpaces, aIDRefsAttr,
28316:                                   elms);
28316:   NS_ADDREF(*aElements = elms);
28316: }
28316: 
28316: void
28316: nsCoreUtils::GetElementsHavingIDRefsAttrImpl(nsIContent *aRootContent,
28316:                                              nsCString& aIdWithSpaces,
28316:                                              nsIAtom *aIDRefsAttr,
28316:                                              nsIMutableArray *aElements)
28316: {
28316:   PRUint32 childCount = aRootContent->GetChildCount();
28316:   for (PRUint32 index = 0; index < childCount; index++) {
28316:     nsIContent* child = aRootContent->GetChildAt(index);
28316:     nsAutoString idList;
28316:     if (child->GetAttr(kNameSpaceID_None, aIDRefsAttr, idList)) {
28316:       idList.Insert(' ', 0);  // Surround idlist with spaces for search
28316:       idList.Append(' ');
28316:       // idList is now a set of id's with spaces around each, and id also has
28316:       // spaces around it. If id is a substring of idList then we have a match.
28316:       if (idList.Find(aIdWithSpaces) != -1) {
28316:         aElements->AppendElement(child, PR_FALSE);
28316:         continue; // Do not search inside children.
28316:       }
28316:     }
28316:     GetElementsHavingIDRefsAttrImpl(child, aIdWithSpaces,
28316:                                     aIDRefsAttr, aElements);
28316:   }
28316: }
28316: 
28316: void
20566: nsCoreUtils::GetComputedStyleDeclaration(const nsAString& aPseudoElt,
20566:                                          nsIDOMNode *aNode,
20566:                                          nsIDOMCSSStyleDeclaration **aCssDecl)
20566: {
20566:   *aCssDecl = nsnull;
20566: 
20566:   nsCOMPtr<nsIDOMElement> domElement = GetDOMElementFor(aNode);
20566:   if (!domElement)
20566:     return;
20566: 
20566:   // Returns number of items in style declaration
20566:   nsCOMPtr<nsIContent> content = do_QueryInterface(domElement);
20566:   nsCOMPtr<nsIDocument> doc = content->GetDocument();
20566:   if (!doc)
20566:     return;
20566: 
20566:   nsCOMPtr<nsIDOMViewCSS> viewCSS(do_QueryInterface(doc->GetWindow()));
20566:   if (!viewCSS)
20566:     return;
20566: 
20566:   viewCSS->GetComputedStyle(domElement, aPseudoElt, aCssDecl);
20566: }
28029: 
28029: already_AddRefed<nsIBoxObject>
28029: nsCoreUtils::GetTreeBodyBoxObject(nsITreeBoxObject *aTreeBoxObj)
28029: {
28029:   nsCOMPtr<nsIDOMElement> tcElm;
28029:   aTreeBoxObj->GetTreeBody(getter_AddRefs(tcElm));
28029:   nsCOMPtr<nsIDOMXULElement> tcXULElm(do_QueryInterface(tcElm));
28029:   if (!tcXULElm)
28029:     return nsnull;
28029: 
28029:   nsIBoxObject *boxObj = nsnull;
28029:   tcXULElm->GetBoxObject(&boxObj);
28029:   return boxObj;
28029: }
31673: 
31673: void
31673: nsCoreUtils::GetTreeBoxObject(nsIDOMNode *aDOMNode,
31673:                               nsITreeBoxObject **aBoxObject)
31673: {
31673:   nsAutoString name;
31673:   nsCOMPtr<nsIDOMNode> parentNode, currentNode;
31673:   
31673:   // Find DOMNode's parents recursively until reach the <tree> tag
31673:   currentNode = aDOMNode;
31673:   while (currentNode) {
31673:     currentNode->GetLocalName(name);
31673:     if (name.EqualsLiteral("tree")) {
31673:       // We will get the nsITreeBoxObject from the tree node
31673:       nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(currentNode));
31673:       if (xulElement) {
31673:         nsCOMPtr<nsIBoxObject> box;
31673:         xulElement->GetBoxObject(getter_AddRefs(box));
31673:         nsCOMPtr<nsITreeBoxObject> treeBox(do_QueryInterface(box));
31673:         if (treeBox) {
31673:           *aBoxObject = treeBox;
31673:           NS_ADDREF(*aBoxObject);
31673:           return;
31673:         }
31673:       }
31673:     }
31673:     currentNode->GetParentNode(getter_AddRefs(parentNode));
31673:     currentNode = parentNode;
31673:   }
31673:   
31673:   *aBoxObject = nsnull;
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetFirstSensibleColumn(nsITreeBoxObject *aTree)
31673: {
31673:   nsCOMPtr<nsITreeColumns> cols;
31673:   aTree->GetColumns(getter_AddRefs(cols));
31673:   if (!cols)
31673:     return nsnull;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   cols->GetFirstColumn(getter_AddRefs(column));
31673:   if (column && IsColumnHidden(column))
31673:     return GetNextSensibleColumn(column);
31673: 
31673:   return column.forget();
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetLastSensibleColumn(nsITreeBoxObject *aTree)
31673: {
31673:   nsCOMPtr<nsITreeColumns> cols;
31673:   aTree->GetColumns(getter_AddRefs(cols));
31673:   if (!cols)
31673:     return nsnull;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   cols->GetLastColumn(getter_AddRefs(column));
31673:   if (column && IsColumnHidden(column))
31673:     return GetPreviousSensibleColumn(column);
31673: 
31673:   return column.forget();
31673: }
31673: 
31673: PRUint32
35523: nsCoreUtils::GetSensibleColumnCount(nsITreeBoxObject *aTree)
31673: {
31673:   PRUint32 count = 0;
31673: 
31673:   nsCOMPtr<nsITreeColumns> cols;
31673:   aTree->GetColumns(getter_AddRefs(cols));
31673:   if (!cols)
31673:     return count;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   cols->GetFirstColumn(getter_AddRefs(column));
31673: 
31673:   while (column) {
31673:     if (!IsColumnHidden(column))
31673:       count++;
31673: 
31673:     nsCOMPtr<nsITreeColumn> nextColumn;
31673:     column->GetNext(getter_AddRefs(nextColumn));
31673:     column.swap(nextColumn);
31673:   }
31673: 
31673:   return count;
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetSensibleColumnAt(nsITreeBoxObject *aTree, PRUint32 aIndex)
31673: {
31673:   PRUint32 idx = aIndex;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column = GetFirstSensibleColumn(aTree);
31673:   while (column) {
31673:     if (idx == 0)
31673:       return column.forget();
31673: 
31673:     idx--;
31673:     column = GetNextSensibleColumn(column);
31673:   }
31673: 
31673:   return nsnull;
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetNextSensibleColumn(nsITreeColumn *aColumn)
31673: {
31673:   nsCOMPtr<nsITreeColumn> nextColumn;
31673:   aColumn->GetNext(getter_AddRefs(nextColumn));
31673: 
31673:   while (nextColumn && IsColumnHidden(nextColumn)) {
31673:     nsCOMPtr<nsITreeColumn> tempColumn;
31673:     nextColumn->GetNext(getter_AddRefs(tempColumn));
31673:     nextColumn.swap(tempColumn);
31673:   }
31673: 
31673:   return nextColumn.forget();
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetPreviousSensibleColumn(nsITreeColumn *aColumn)
31673: {
31673:   nsCOMPtr<nsITreeColumn> prevColumn;
31673:   aColumn->GetPrevious(getter_AddRefs(prevColumn));
31673: 
31673:   while (prevColumn && IsColumnHidden(prevColumn)) {
31673:     nsCOMPtr<nsITreeColumn> tempColumn;
31673:     prevColumn->GetPrevious(getter_AddRefs(tempColumn));
31673:     prevColumn.swap(tempColumn);
31673:   }
31673: 
31673:   return prevColumn.forget();
31673: }
31673: 
31673: PRBool
31673: nsCoreUtils::IsColumnHidden(nsITreeColumn *aColumn)
31673: {
31673:   nsCOMPtr<nsIDOMElement> element;
31673:   aColumn->GetElement(getter_AddRefs(element));
31673:   nsCOMPtr<nsIContent> content = do_QueryInterface(element);
31673:   return content->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::hidden,
31673:                               nsAccessibilityAtoms::_true, eCaseMatters);
31673: }
34719: 
34719: void
34719: nsCoreUtils::GeneratePopupTree(nsIDOMNode *aNode, PRBool aIsAnon)
34719: {
34719:   // Set menugenerated="true" on the menupopup node to generate the sub-menu
34719:   // items if they have not been generated.
34719: 
34719:   nsCOMPtr<nsIDOMNodeList> list;
34719:   if (aIsAnon) {
34719:     nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
34719:     nsIDocument* document = content->GetCurrentDoc();
34719:     if (document)
34719:       document->GetXBLChildNodesFor(content, getter_AddRefs(list));
34719: 
34719:   } else {
34719:     aNode->GetChildNodes(getter_AddRefs(list));
34719:   }
34719: 
34719:   PRUint32 length = 0;
34719:   if (!list || NS_FAILED(list->GetLength(&length)))
34719:     return;
34719: 
34719:   for (PRUint32 idx = 0; idx < length; idx++) {
34719:     nsCOMPtr<nsIDOMNode> childNode;
34719:     list->Item(idx, getter_AddRefs(childNode));
34719:     nsCOMPtr<nsIContent> child(do_QueryInterface(childNode));
34719: 
34719:     PRBool isPopup = child->NodeInfo()->Equals(nsAccessibilityAtoms::menupopup,
34719:                                                kNameSpaceID_XUL) ||
34719:                      child->NodeInfo()->Equals(nsAccessibilityAtoms::panel,
34719:                                                kNameSpaceID_XUL);
34719:     if (isPopup && !child->AttrValueIs(kNameSpaceID_None,
34719:                                        nsAccessibilityAtoms::menugenerated,
34719:                                        nsAccessibilityAtoms::_true,
34719:                                        eCaseMatters)) {
34719: 
34719:       child->SetAttr(kNameSpaceID_None, nsAccessibilityAtoms::menugenerated,
34719:                      NS_LITERAL_STRING("true"), PR_TRUE);
34719:       return;
34719:     }
34719:   }
34719: }
41384: 
41384: 
41384: ////////////////////////////////////////////////////////////////////////////////
41384: // nsAccessibleDOMStringList
41384: ////////////////////////////////////////////////////////////////////////////////
41384: 
41384: NS_IMPL_ISUPPORTS1(nsAccessibleDOMStringList, nsIDOMDOMStringList)
41384: 
41384: NS_IMETHODIMP
41384: nsAccessibleDOMStringList::Item(PRUint32 aIndex, nsAString& aResult)
41384: {
41384:   if (aIndex >= mNames.Length())
41384:     SetDOMStringToNull(aResult);
41384:   else
41384:     aResult = mNames.ElementAt(aIndex);
41384: 
41384:   return NS_OK;
41384: }
41384: 
41384: NS_IMETHODIMP
41384: nsAccessibleDOMStringList::GetLength(PRUint32 *aLength)
41384: {
41384:   *aLength = mNames.Length();
41384: 
41384:   return NS_OK;
41384: }
41384: 
41384: NS_IMETHODIMP
41384: nsAccessibleDOMStringList::Contains(const nsAString& aString, PRBool *aResult)
41384: {
41384:   *aResult = mNames.Contains(aString);
41384: 
41384:   return NS_OK;
41384: }
