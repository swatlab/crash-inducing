52558: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52558:  * vim: set ts=4 sw=4 et tw=99:
52558:  *
52558:  * ***** BEGIN LICENSE BLOCK *****
52558:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52558:  *
52558:  * The contents of this file are subject to the Mozilla Public License Version
52558:  * 1.1 (the "License"); you may not use this file except in compliance with
52558:  * the License. You may obtain a copy of the License at
52558:  * http://www.mozilla.org/MPL/
52558:  *
52558:  * Software distributed under the License is distributed on an "AS IS" basis,
52558:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52558:  * for the specific language governing rights and limitations under the
52558:  * License.
52558:  *
52558:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52558:  * May 28, 2008.
52558:  *
52558:  * The Initial Developer of the Original Code is
52558:  *   Brendan Eich <brendan@mozilla.org>
52558:  *
52558:  * Contributor(s):
52558:  *   David Anderson <danderson@mozilla.com>
52558:  *   David Mandelin <dmandelin@mozilla.com>
52558:  *
52558:  * Alternatively, the contents of this file may be used under the terms of
52558:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52558:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52558:  * in which case the provisions of the GPL or the LGPL are applicable instead
52558:  * of those above. If you wish to allow use of your version of this file only
52558:  * under the terms of either the GPL or the LGPL, and not to allow others to
52558:  * use your version of this file under the terms of the MPL, indicate your
52558:  * decision by deleting the provisions above and replace them with the notice
52558:  * and other provisions required by the GPL or the LGPL. If you do not delete
52558:  * the provisions above, a recipient may use your version of this file under
52558:  * the terms of any one of the MPL, the GPL or the LGPL.
52558:  *
52558:  * ***** END LICENSE BLOCK ***** */
53270: 
52558: #include "MethodJIT.h"
52651: #include "jsnum.h"
52686: #include "jsbool.h"
52737: #include "jsiter.h"
52558: #include "Compiler.h"
52611: #include "StubCalls.h"
52826: #include "MonoIC.h"
53270: #include "PolyIC.h"
53168: #include "Retcon.h"
52611: #include "assembler/jit/ExecutableAllocator.h"
52826: #include "assembler/assembler/LinkBuffer.h"
52618: #include "FrameState-inl.h"
52668: #include "jsscriptinlines.h"
52560: 
52560: #include "jsautooplen.h"
52558: 
52558: using namespace js;
52558: using namespace js::mjit;
53270: #if defined JS_POLYIC
53270: using namespace js::mjit::ic;
53270: #endif
52558: 
53168: #define ADD_CALLSITE(stub) addCallSite(__LINE__, (stub))
53168: 
52558: #if defined(JS_METHODJIT_SPEW)
52558: static const char *OpcodeNames[] = {
52558: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) #name,
52558: # include "jsopcode.tbl"
52558: # undef OPDEF
52558: };
52558: #endif
52558: 
52560: mjit::Compiler::Compiler(JSContext *cx, JSScript *script, JSFunction *fun, JSObject *scopeChain)
52606:   : cx(cx), script(script), scopeChain(scopeChain), globalObj(scopeChain->getGlobal()), fun(fun),
52617:     analysis(cx, script), jumpMap(NULL), frame(cx, script, masm),
53119:     branchPatches(ContextAllocPolicy(cx)),
53119: #if defined JS_MONOIC
53119:     mics(ContextAllocPolicy(cx)),
53119: #endif
53119: #if defined JS_POLYIC
53119:     pics(ContextAllocPolicy(cx)), 
53119: #endif
53183:     callSites(ContextAllocPolicy(cx)), 
53183:     doubleList(ContextAllocPolicy(cx)),
53520:     escapingList(ContextAllocPolicy(cx)),
53183:     stubcc(cx, *this, frame, script)
53136: #if defined JS_TRACER
53136:     ,addTraceHints(cx->jitEnabled)
53136: #endif
52558: {
52558: }
52558: 
52558: #define CHECK_STATUS(expr)              \
52558:     JS_BEGIN_MACRO                      \
52558:         CompileStatus status_ = (expr); \
52558:         if (status_ != Compile_Okay)    \
52558:             return status_;             \
52558:     JS_END_MACRO
52558: 
52558: CompileStatus
52558: mjit::Compiler::Compile()
52558: {
52558:     JS_ASSERT(!script->ncode);
52558: 
52558:     JaegerSpew(JSpew_Scripts, "compiling script (file \"%s\") (line \"%d\") (length \"%d\")\n",
52558:                script->filename, script->lineno, script->length);
52558: 
52558:     /* Perform bytecode analysis. */
52558:     if (!analysis.analyze()) {
52558:         if (analysis.OOM())
52558:             return Compile_Error;
52558:         JaegerSpew(JSpew_Abort, "couldn't analyze bytecode; probably switchX or OOM\n");
52558:         return Compile_Abort;
52558:     }
52558: 
52560:     uint32 nargs = fun ? fun->nargs : 0;
52617:     if (!frame.init(nargs) || !stubcc.init(nargs))
52560:         return Compile_Abort;
52560: 
52558:     jumpMap = (Label *)cx->malloc(sizeof(Label) * script->length);
52558:     if (!jumpMap)
52558:         return Compile_Error;
52558: #ifdef DEBUG
52558:     for (uint32 i = 0; i < script->length; i++)
52558:         jumpMap[i] = Label();
52558: #endif
52558: 
52654: #ifdef JS_METHODJIT_SPEW
52558:     Profiler prof;
52558:     prof.start();
52654: #endif
52558: 
52558:     CHECK_STATUS(generatePrologue());
52558:     CHECK_STATUS(generateMethod());
52558:     CHECK_STATUS(generateEpilogue());
52558:     CHECK_STATUS(finishThisUp());
52558: 
52558: #ifdef JS_METHODJIT_SPEW
52558:     prof.stop();
52558:     JaegerSpew(JSpew_Prof, "compilation took %d us\n", prof.time_us());
52558: #endif
52558: 
52558:     JaegerSpew(JSpew_Scripts, "successfully compiled (code \"%p\") (size \"%ld\")\n",
52617:                (void*)script->ncode, masm.size() + stubcc.size());
52558: 
52560:     return Compile_Okay;
52558: }
52558: 
52558: #undef CHECK_STATUS
52558: 
52558: mjit::Compiler::~Compiler()
52558: {
52558:     cx->free(jumpMap);
52558: }
52558: 
52558: CompileStatus
52611: mjit::TryCompile(JSContext *cx, JSScript *script, JSFunction *fun, JSObject *scopeChain)
52611: {
52611:     Compiler cc(cx, script, fun, scopeChain);
52611: 
52611:     JS_ASSERT(!script->ncode);
52668:     JS_ASSERT(!script->isEmpty());
52611: 
52611:     CompileStatus status = cc.Compile();
53333:     if (status != Compile_Okay)
52611:         script->ncode = JS_UNJITTABLE_METHOD;
52611: 
52611:     return status;
52611: }
52611: 
53515: void
53515: mjit::Compiler::saveReturnAddress()
53471: {
53471: #ifndef JS_CPU_ARM
53471:     masm.pop(Registers::ReturnReg);
53515:     restoreFrameRegs(masm);
53515:     masm.storePtr(Registers::ReturnReg, Address(JSFrameReg, offsetof(JSStackFrame, ncode)));
53471: #else
53515:     restoreFrameRegs(masm);
53515:     masm.storePtr(JSC::ARMRegisters::lr, Address(JSFrameReg, offsetof(JSStackFrame, ncode)));
53471: #endif
53471: }
53471: 
52611: CompileStatus
52558: mjit::Compiler::generatePrologue()
52558: {
52873:     invokeLabel = masm.label();
53471: 
53515:     saveReturnAddress();
52873: 
52873:     /*
52873:      * If there is no function, then this can only be called via JaegerShot(),
52873:      * which expects an existing frame to be initialized like the interpreter.
52873:      */
52872:     if (fun) {
52873:         Jump j = masm.jump();
52873:         invokeLabel = masm.label();
53515:         saveReturnAddress();
52873: 
52873:         /* Set locals to undefined. */
53488:         for (uint32 i = 0; i < script->nfixed; i++) {
52873:             Address local(JSFrameReg, sizeof(JSStackFrame) + i * sizeof(Value));
53081:             masm.storeValue(UndefinedValue(), local);
52872:         }
52872: 
52873:         /* Create the call object. */
52873:         if (fun->isHeavyweight()) {
53087:             prepareStubCall(Uses(0));
53087:             stubCall(stubs::GetCallObject);
52873:         }
52873: 
52873:         j.linkTo(masm.label(), &masm);
52873:     }
52872: 
52558:     return Compile_Okay;
52558: }
52558: 
52611: CompileStatus
52611: mjit::Compiler::generateEpilogue()
52611: {
52611:     return Compile_Okay;
52611: }
52611: 
52611: CompileStatus
52611: mjit::Compiler::finishThisUp()
52611: {
52611:     for (size_t i = 0; i < branchPatches.length(); i++) {
52611:         Label label = labelOf(branchPatches[i].pc);
52611:         branchPatches[i].jump.linkTo(label, &masm);
52611:     }
52611: 
53147: #ifdef JS_CPU_ARM
53147:     masm.forceFlushConstantPool();
53147:     stubcc.masm.forceFlushConstantPool();
53147: #endif
53147:     JaegerSpew(JSpew_Insns, "## Fast code (masm) size = %u, Slow code (stubcc) size = %u.\n", masm.size(), stubcc.size());
53147: 
53183:     size_t totalSize = masm.size() +
53183:                        stubcc.size() +
53183:                        doubleList.length() * sizeof(double);
53183: 
53183:     JSC::ExecutablePool *execPool = getExecPool(totalSize);
52611:     if (!execPool)
52611:         return Compile_Abort;
52611: 
53183:     uint8 *result = (uint8 *)execPool->alloc(totalSize);
53183:     JSC::ExecutableAllocator::makeWritable(result, totalSize);
53147:     masm.executableCopy(result);
53147:     stubcc.masm.executableCopy(result + masm.size());
52611: 
53498:     JSC::LinkBuffer fullCode(result, totalSize);
53498:     JSC::LinkBuffer stubCode(result + masm.size(), stubcc.size());
53498: 
53498:     size_t totalBytes = sizeof(JITScript) +
53520:                         sizeof(uint32) * escapingList.length() +
53498:                         sizeof(void *) * script->length +
53498: #if defined JS_MONOIC
53498:                         sizeof(ic::MICInfo) * mics.length() +
53498: #endif
53498: #if defined JS_POLYIC
53498:                         sizeof(ic::PICInfo) * pics.length() +
53498: #endif
53498:                         sizeof(CallSite) * callSites.length();
53498: 
53498:     uint8 *cursor = (uint8 *)cx->calloc(totalBytes);
53498:     if (!cursor) {
52661:         execPool->release();
52661:         return Compile_Error;
52661:     }
52661: 
53498:     script->jit = (JITScript *)cursor;
53498:     cursor += sizeof(JITScript);
53498: 
53498:     script->jit->execPool = execPool;
53498:     script->jit->inlineLength = masm.size();
53498:     script->jit->outOfLineLength = stubcc.size();
53498:     script->jit->nCallSites = callSites.length();
53498:     script->jit->invoke = result;
53498: 
53520:     script->jit->nescaping = escapingList.length();
53520:     if (escapingList.length()) {
53520:         script->jit->escaping = (uint32 *)cursor;
53520:         cursor += sizeof(uint32) * escapingList.length();
53520:         for (uint32 i = 0; i < escapingList.length(); i++)
53520:             script->jit->escaping[i] = escapingList[i];
53520:     } else {
53520:         script->jit->escaping = NULL;
53520:     }
53520: 
53498:     /* Build the pc -> ncode mapping. */
53498:     void **nmap = (void **)cursor;
52669:     script->nmap = nmap;
53498:     cursor += sizeof(void *) * script->length;
52669: 
52661:     for (size_t i = 0; i < script->length; i++) {
52661:         Label L = jumpMap[i];
52678:         if (analysis[i].safePoint) {
52661:             JS_ASSERT(L.isValid());
52661:             nmap[i] = (uint8 *)(result + masm.distanceOf(L));
52661:         }
52661:     }
52661: 
53119: #if defined JS_MONOIC
53498:     script->jit->nMICs = mics.length();
52826:     if (mics.length()) {
53405:         script->mics = (ic::MICInfo *)cursor;
53498:         cursor += sizeof(ic::MICInfo) * mics.length();
53405:     } else {
53405:         script->mics = NULL;
52826:     }
53498: 
52826:     for (size_t i = 0; i < mics.length(); i++) {
53133:         script->mics[i].kind = mics[i].kind;
52826:         script->mics[i].entry = fullCode.locationOf(mics[i].entry);
53301:         switch (mics[i].kind) {
53301:           case ic::MICInfo::GET:
53301:           case ic::MICInfo::SET:
52826:             script->mics[i].load = fullCode.locationOf(mics[i].load);
53408:             script->mics[i].shape = fullCode.locationOf(mics[i].shape);
52826:             script->mics[i].stubCall = stubCode.locationOf(mics[i].call);
52826:             script->mics[i].stubEntry = stubCode.locationOf(mics[i].stubEntry);
53133:             script->mics[i].u.name.typeConst = mics[i].u.name.typeConst;
53133:             script->mics[i].u.name.dataConst = mics[i].u.name.dataConst;
53269: #if defined JS_PUNBOX64
53269:             script->mics[i].patchValueOffset = mics[i].patchValueOffset;
53269: #endif
53301:             break;
53515:           case ic::MICInfo::CALL:
53515:             script->mics[i].frameDepth = mics[i].frameDepth;
53515:             script->mics[i].knownObject = fullCode.locationOf(mics[i].knownObject);
53515:             script->mics[i].callEnd = fullCode.locationOf(mics[i].callEnd);
53515:             script->mics[i].stubEntry = stubCode.locationOf(mics[i].stubEntry);
53515:             script->mics[i].dataReg = mics[i].dataReg;
53515:             script->mics[i].u.generated = false;
53515:             /* FALLTHROUGH */
53515:           case ic::MICInfo::EMPTYCALL:
53515:             script->mics[i].argc = mics[i].argc;
53515:             break;
53301:           case ic::MICInfo::TRACER: {
53133:             uint32 offs = uint32(mics[i].jumpTarget - script->code);
53133:             JS_ASSERT(jumpMap[offs].isValid());
53133:             script->mics[i].traceHint = fullCode.locationOf(mics[i].traceHint);
53133:             script->mics[i].load = fullCode.locationOf(jumpMap[offs]);
53277:             script->mics[i].u.hasSlowTraceHint = mics[i].slowTraceHint.isSet();
53277:             if (mics[i].slowTraceHint.isSet())
53277:                 script->mics[i].slowTraceHint = stubCode.locationOf(mics[i].slowTraceHint.get());
53301:             break;
53301:           }
53301:           default:
53301:             JS_NOT_REACHED("Bad MIC kind");
53133:         }
52826:     }
53119: #endif /* JS_MONOIC */
53119: 
53119: #if defined JS_POLYIC
53498:     script->jit->nPICs = pics.length();
52880:     if (pics.length()) {
52880:         script->pics = (ic::PICInfo *)cursor;
53498:         cursor += sizeof(ic::PICInfo) * pics.length();
53391:     } else {
53391:         script->pics = NULL;
52880:     }
52880: 
52880:     for (size_t i = 0; i < pics.length(); i++) {
53137:         pics[i].copySimpleMembersTo(script->pics[i]);
53270:         script->pics[i].fastPathStart = fullCode.locationOf(pics[i].fastPathStart);
52880:         script->pics[i].storeBack = fullCode.locationOf(pics[i].storeBack);
52880:         script->pics[i].slowPathStart = stubCode.locationOf(pics[i].slowPathStart);
53104:         script->pics[i].callReturn = uint16((uint8*)stubCode.locationOf(pics[i].callReturn).executableAddress() -
52880:                                            (uint8*)script->pics[i].slowPathStart.executableAddress());
52880:         script->pics[i].shapeGuard = masm.distanceOf(pics[i].shapeGuard) -
53270:                                      masm.distanceOf(pics[i].fastPathStart);
53426:         JS_ASSERT(script->pics[i].shapeGuard == masm.distanceOf(pics[i].shapeGuard) -
53426:                                      masm.distanceOf(pics[i].fastPathStart));
53054:         script->pics[i].shapeRegHasBaseShape = true;
52887: 
53315: # if defined JS_CPU_X64
53315:         memcpy(&script->pics[i].labels, &pics[i].labels, sizeof(PICLabels));
53315: # endif
53315: 
52887:         if (pics[i].kind == ic::PICInfo::SET) {
52887:             script->pics[i].u.vr = pics[i].vr;
53054:         } else if (pics[i].kind != ic::PICInfo::NAME) {
52884:             if (pics[i].hasTypeCheck) {
52884:                 int32 distance = stubcc.masm.distanceOf(pics[i].typeCheck) -
52884:                                  stubcc.masm.distanceOf(pics[i].slowPathStart);
53264:                 JS_ASSERT(distance <= 0);
53264:                 script->pics[i].u.get.typeCheckOffset = distance;
52887:             }
52884:         }
52880:         new (&script->pics[i].execPools) ic::PICInfo::ExecPoolVector(SystemAllocPolicy());
53498:         script->pics[i].reset();
52880:     }
53119: #endif /* JS_POLYIC */
52880: 
52613:     /* Link fast and slow paths together. */
52613:     stubcc.fixCrossJumps(result, masm.size(), masm.size() + stubcc.size());
52613: 
53183:     /* Patch all double references. */
53183:     size_t doubleOffset = masm.size() + stubcc.size();
53183:     double *doubleVec = (double *)(result + doubleOffset);
53183:     for (size_t i = 0; i < doubleList.length(); i++) {
53183:         DoublePatch &patch = doubleList[i];
53183:         doubleVec[i] = patch.d;
53183:         if (patch.ool)
53183:             stubCode.patch(patch.label, &doubleVec[i]);
53183:         else
53183:             fullCode.patch(patch.label, &doubleVec[i]);
53183:     }
53183: 
52613:     /* Patch all outgoing calls. */
52611:     masm.finalize(result);
52611:     stubcc.finalize(result + masm.size());
52611: 
52611:     JSC::ExecutableAllocator::makeExecutable(result, masm.size() + stubcc.size());
52611:     JSC::ExecutableAllocator::cacheFlush(result, masm.size() + stubcc.size());
52611: 
52873:     script->ncode = (uint8 *)(result + masm.distanceOf(invokeLabel));
52611: 
53168:     /* Build the table of call sites. */
53498:     if (callSites.length()) {
53498:         CallSite *callSiteList = (CallSite *)cursor;
53498:         cursor += sizeof(CallSite) * callSites.length();
53498: 
53168:         for (size_t i = 0; i < callSites.length(); i++) {
53168:             if (callSites[i].stub)
53498:                 callSiteList[i].codeOffset = masm.size() + stubcc.masm.distanceOf(callSites[i].location);
53168:             else
53498:                 callSiteList[i].codeOffset = masm.distanceOf(callSites[i].location);
53498:             callSiteList[i].pcOffset = callSites[i].pc - script->code;
53498:             callSiteList[i].id = callSites[i].id;
53168:         }
53498:         script->jit->callSites = callSiteList;
53498:     } else {
53498:         script->jit->callSites = NULL;
53498:     }
53498: 
53498:     JS_ASSERT(size_t(cursor - (uint8*)script->jit) == totalBytes);
53168: 
53515: #ifdef JS_METHODJIT
53515:     script->debugMode = cx->compartment->debugMode;
53515: #endif
53515: 
52611:     return Compile_Okay;
52611: }
52611: 
52776: #ifdef DEBUG
52776: #define SPEW_OPCODE()                                                         \
52776:     JS_BEGIN_MACRO                                                            \
52776:         if (IsJaegerSpewChannelActive(JSpew_JSOps)) {                         \
52776:             JaegerSpew(JSpew_JSOps, "    %2d ", frame.stackDepth());          \
52776:             js_Disassemble1(cx, script, PC, PC - script->code,                \
52776:                             JS_TRUE, stdout);                                 \
52776:         }                                                                     \
52776:     JS_END_MACRO;
52776: #else
52776: #define SPEW_OPCODE()
52776: #endif /* DEBUG */
52776: 
52560: #define BEGIN_CASE(name)        case name:
52560: #define END_CASE(name)                      \
52560:     JS_BEGIN_MACRO                          \
52560:         PC += name##_LENGTH;                \
52560:     JS_END_MACRO;                           \
52560:     break;
52560: 
52558: CompileStatus
52558: mjit::Compiler::generateMethod()
52558: {
53168:     mjit::AutoScriptRetrapper trapper(cx, script);
53515:     PC = script->code;
52558: 
52558:     for (;;) {
52558:         JSOp op = JSOp(*PC);
52558: 
52558:         OpcodeStatus &opinfo = analysis[PC];
53285:         frame.setInTryBlock(opinfo.inTryBlock);
53168:         if (opinfo.nincoming || opinfo.trap) {
52678:             frame.forgetEverything(opinfo.stackDepth);
52558:             opinfo.safePoint = true;
53133:         }
52599:         jumpMap[uint32(PC - script->code)] = masm.label();
52558: 
53168:         if (opinfo.trap) {
53168:             if (!trapper.untrap(PC))
53168:                 return Compile_Error;
53168:             op = JSOp(*PC);
53168:         }
53168: 
52558:         if (!opinfo.visited) {
52558:             if (op == JSOP_STOP)
52558:                 break;
52558:             if (js_CodeSpec[op].length != -1)
52558:                 PC += js_CodeSpec[op].length;
52558:             else
52558:                 PC += js_GetVariableBytecodeLength(PC);
52558:             continue;
52558:         }
52558: 
52776:         SPEW_OPCODE();
52599:         JS_ASSERT(frame.stackDepth() == opinfo.stackDepth);
52599: 
53168:         if (opinfo.trap) {
53168:             prepareStubCall(Uses(0));
53168:             masm.move(ImmPtr(PC), Registers::ArgReg1);
53168:             stubCall(stubs::Trap);
53168:         }
53326: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53326:         // In case of no fast call, when we change the return address,
53326:         // we need to make sure add esp by 8. For normal call, we need
53326:         // to make sure the esp is not changed.
53326:         else {
53326:             masm.subPtr(Imm32(8), Registers::StackPointer);
53326:             masm.callLabel = masm.label();
53326:             masm.addPtr(Imm32(8), Registers::StackPointer);
53326:         }
53477: #elif defined(_WIN64)
53477:         // In case of Win64 ABI, stub caller make 32-bytes spcae on stack
53477:         else {
53477:             masm.subPtr(Imm32(32), Registers::StackPointer);
53477:             masm.callLabel = masm.label();
53477:             masm.addPtr(Imm32(32), Registers::StackPointer);
53477:         }
53326: #endif
53168:         ADD_CALLSITE(false);
53168: 
52560:     /**********************
52560:      * BEGIN COMPILER OPS *
52560:      **********************/ 
52560: 
52558:         switch (op) {
52647:           BEGIN_CASE(JSOP_NOP)
52647:           END_CASE(JSOP_NOP)
52647: 
52769:           BEGIN_CASE(JSOP_PUSH)
53081:             frame.push(UndefinedValue());
52769:           END_CASE(JSOP_PUSH)
52769: 
52662:           BEGIN_CASE(JSOP_POPV)
52806:           BEGIN_CASE(JSOP_SETRVAL)
52662:           {
52662:             FrameEntry *fe = frame.peek(-1);
53440:             frame.storeTo(fe, Address(JSFrameReg, JSStackFrame::offsetReturnValue()), true);
52662:             frame.pop();
52662:           }
52662:           END_CASE(JSOP_POPV)
52662: 
52650:           BEGIN_CASE(JSOP_RETURN)
52650:           {
52650:             FrameEntry *fe = frame.peek(-1);
53440:             frame.storeTo(fe, Address(JSFrameReg, JSStackFrame::offsetReturnValue()), true);
52727:             frame.pop();
52650:             emitReturn();
52650:           }
52650:           END_CASE(JSOP_RETURN)
52650: 
52599:           BEGIN_CASE(JSOP_GOTO)
52599:           {
52617:             /* :XXX: this isn't really necessary if we follow the branch. */
52617:             frame.forgetEverything();
52599:             Jump j = masm.jump();
53133:             jumpAndTrace(j, PC + GET_JUMP_OFFSET(PC));
52599:           }
52599:           END_CASE(JSOP_GOTO)
52599: 
52686:           BEGIN_CASE(JSOP_IFEQ)
52686:           BEGIN_CASE(JSOP_IFNE)
53102:             jsop_ifneq(op, PC + GET_JUMP_OFFSET(PC));
52737:           END_CASE(JSOP_IFNE)
52737: 
52778:           BEGIN_CASE(JSOP_ARGUMENTS)
53087:             prepareStubCall(Uses(0));
53087:             stubCall(stubs::Arguments);
52778:             frame.pushSynced();
52778:           END_CASE(JSOP_ARGUMENTS)
52778: 
52737:           BEGIN_CASE(JSOP_FORLOCAL)
52737:             iterNext();
52973:             frame.storeLocal(GET_SLOTNO(PC), true);
52737:             frame.pop();
52737:           END_CASE(JSOP_FORLOCAL)
52686: 
52714:           BEGIN_CASE(JSOP_DUP)
52714:             frame.dup();
52714:           END_CASE(JSOP_DUP)
52714: 
52715:           BEGIN_CASE(JSOP_DUP2)
52715:             frame.dup2();
52715:           END_CASE(JSOP_DUP2)
52715: 
52721:           BEGIN_CASE(JSOP_BITOR)
52718:           BEGIN_CASE(JSOP_BITXOR)
52685:           BEGIN_CASE(JSOP_BITAND)
52685:             jsop_bitop(op);
52685:           END_CASE(JSOP_BITAND)
52685: 
52651:           BEGIN_CASE(JSOP_LT)
52651:           BEGIN_CASE(JSOP_LE)
52651:           BEGIN_CASE(JSOP_GT)
52651:           BEGIN_CASE(JSOP_GE)
52679:           BEGIN_CASE(JSOP_EQ)
52679:           BEGIN_CASE(JSOP_NE)
52651:           {
52652:             /* Detect fusions. */
52652:             jsbytecode *next = &PC[JSOP_GE_LENGTH];
52652:             JSOp fused = JSOp(*next);
52652:             if ((fused != JSOP_IFEQ && fused != JSOP_IFNE) || analysis[next].nincoming)
52651:                 fused = JSOP_NOP;
52652: 
52652:             /* Get jump target, if any. */
52652:             jsbytecode *target = NULL;
52652:             if (fused != JSOP_NOP)
52652:                 target = next + GET_JUMP_OFFSET(next);
52651: 
52652:             BoolStub stub = NULL;
52652:             switch (op) {
52652:               case JSOP_LT:
52652:                 stub = stubs::LessThan;
52652:                 break;
52652:               case JSOP_LE:
52652:                 stub = stubs::LessEqual;
52652:                 break;
52652:               case JSOP_GT:
52652:                 stub = stubs::GreaterThan;
52652:                 break;
52652:               case JSOP_GE:
52652:                 stub = stubs::GreaterEqual;
52652:                 break;
52679:               case JSOP_EQ:
52679:                 stub = stubs::Equal;
52679:                 break;
52679:               case JSOP_NE:
52679:                 stub = stubs::NotEqual;
52679:                 break;
52652:               default:
52652:                 JS_NOT_REACHED("WAT");
52652:                 break;
52652:             }
52653: 
52653:             FrameEntry *rhs = frame.peek(-1);
52653:             FrameEntry *lhs = frame.peek(-2);
52653: 
52653:             /* Check for easy cases that the parser does not constant fold. */
52653:             if (lhs->isConstant() && rhs->isConstant()) {
52653:                 /* Primitives can be trivially constant folded. */
52653:                 const Value &lv = lhs->getValue();
52653:                 const Value &rv = rhs->getValue();
52653: 
52653:                 if (lv.isPrimitive() && rv.isPrimitive()) {
52653:                     bool result = compareTwoValues(cx, op, lv, rv);
52653: 
52652:                     frame.pop();
52652:                     frame.pop();
52652: 
52652:                     if (!target) {
53081:                         frame.push(Value(BooleanValue(result)));
52652:                     } else {
52653:                         if (fused == JSOP_IFEQ)
52653:                             result = !result;
52653: 
52653:                         /* Branch is never taken, don't bother doing anything. */
52653:                         if (result) {
52652:                             frame.forgetEverything();
52653:                             Jump j = masm.jump();
53133:                             jumpAndTrace(j, target);
52652:                         }
52652:                     }
52652:                 } else {
52653:                     emitStubCmpOp(stub, target, fused);
52653:                 }
52653:             } else {
52651:                 /* Anything else should go through the fast path generator. */
52653:                 jsop_relational(op, stub, target, fused);
52651:             }
52651: 
52651:             /* Advance PC manually. */
52679:             JS_STATIC_ASSERT(JSOP_LT_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_LE_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_GT_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_EQ_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_NE_LENGTH == JSOP_GE_LENGTH);
52679: 
52651:             PC += JSOP_GE_LENGTH;
52776:             if (fused != JSOP_NOP) {
52776:                 SPEW_OPCODE();
52651:                 PC += JSOP_IFNE_LENGTH;
52776:             }
52651:             break;
52651:           }
52651:           END_CASE(JSOP_GE)
52651: 
52685:           BEGIN_CASE(JSOP_LSH)
53230:             jsop_bitop(op);
53230:           END_CASE(JSOP_LSH)
53230: 
52685:           BEGIN_CASE(JSOP_RSH)
53230:             jsop_rsh();
52685:           END_CASE(JSOP_RSH)
52560: 
52725:           BEGIN_CASE(JSOP_URSH)
53087:             prepareStubCall(Uses(2));
53087:             stubCall(stubs::Ursh);
52725:             frame.popn(2);
52725:             frame.pushSynced();
52725:           END_CASE(JSOP_URSH)
52725: 
52692:           BEGIN_CASE(JSOP_ADD)
52692:             jsop_binary(op, stubs::Add);
52692:           END_CASE(JSOP_ADD)
52692: 
52692:           BEGIN_CASE(JSOP_SUB)
52692:             jsop_binary(op, stubs::Sub);
52692:           END_CASE(JSOP_SUB)
52692: 
52692:           BEGIN_CASE(JSOP_MUL)
52692:             jsop_binary(op, stubs::Mul);
52692:           END_CASE(JSOP_MUL)
52692: 
52692:           BEGIN_CASE(JSOP_DIV)
52692:             jsop_binary(op, stubs::Div);
52692:           END_CASE(JSOP_DIV)
52692: 
52692:           BEGIN_CASE(JSOP_MOD)
53156:             jsop_mod();
52692:           END_CASE(JSOP_MOD)
52692: 
52734:           BEGIN_CASE(JSOP_NOT)
52734:             jsop_not();
52734:           END_CASE(JSOP_NOT)
52734: 
52724:           BEGIN_CASE(JSOP_BITNOT)
52724:           {
52724:             FrameEntry *top = frame.peek(-1);
52724:             if (top->isConstant() && top->getValue().isPrimitive()) {
52724:                 int32_t i;
52724:                 ValueToECMAInt32(cx, top->getValue(), &i);
52724:                 i = ~i;
52724:                 frame.pop();
53081:                 frame.push(Int32Value(i));
52724:             } else {
52724:                 jsop_bitnot();
52724:             }
52724:           }
52724:           END_CASE(JSOP_BITNOT)
52724: 
52713:           BEGIN_CASE(JSOP_NEG)
52713:           {
52713:             FrameEntry *top = frame.peek(-1);
52713:             if (top->isConstant() && top->getValue().isPrimitive()) {
52713:                 double d;
52713:                 ValueToNumber(cx, top->getValue(), &d);
52713:                 d = -d;
52713:                 frame.pop();
53327:                 frame.push(NumberValue(d));
52713:             } else {
52713:                 jsop_neg();
52713:             }
52713:           }
52713:           END_CASE(JSOP_NEG)
52713: 
53039:           BEGIN_CASE(JSOP_POS)
53039:             jsop_pos();
53039:           END_CASE(JSOP_POS)
53039: 
52738:           BEGIN_CASE(JSOP_TYPEOF)
52784:           BEGIN_CASE(JSOP_TYPEOFEXPR)
52738:             jsop_typeof();
52738:           END_CASE(JSOP_TYPEOF)
52738: 
52676:           BEGIN_CASE(JSOP_VOID)
52676:             frame.pop();
53081:             frame.push(UndefinedValue());
52676:           END_CASE(JSOP_VOID)
52676: 
52732:           BEGIN_CASE(JSOP_INCNAME)
52732:             jsop_nameinc(op, stubs::IncName, fullAtomIndex(PC));
53118:             break;
52732:           END_CASE(JSOP_INCNAME)
52732: 
52825:           BEGIN_CASE(JSOP_INCGNAME)
53118:             jsop_gnameinc(op, stubs::IncGlobalName, fullAtomIndex(PC));
53511:             break;
52825:           END_CASE(JSOP_INCGNAME)
52825: 
52746:           BEGIN_CASE(JSOP_INCPROP)
52746:             jsop_propinc(op, stubs::IncProp, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_INCPROP)
52746: 
52815:           BEGIN_CASE(JSOP_INCELEM)
52815:             jsop_eleminc(op, stubs::IncElem);
52815:           END_CASE(JSOP_INCELEM)
52815: 
52732:           BEGIN_CASE(JSOP_DECNAME)
52732:             jsop_nameinc(op, stubs::DecName, fullAtomIndex(PC));
53118:             break;
52732:           END_CASE(JSOP_DECNAME)
52732: 
52825:           BEGIN_CASE(JSOP_DECGNAME)
53118:             jsop_gnameinc(op, stubs::DecGlobalName, fullAtomIndex(PC));
53511:             break;
52825:           END_CASE(JSOP_DECGNAME)
52825: 
52746:           BEGIN_CASE(JSOP_DECPROP)
52746:             jsop_propinc(op, stubs::DecProp, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_DECPROP)
52746: 
52815:           BEGIN_CASE(JSOP_DECELEM)
52815:             jsop_eleminc(op, stubs::DecElem);
52815:           END_CASE(JSOP_DECELEM)
52815: 
53118:           BEGIN_CASE(JSOP_NAMEINC)
53118:             jsop_nameinc(op, stubs::NameInc, fullAtomIndex(PC));
53118:             break;
53118:           END_CASE(JSOP_NAMEINC)
53118: 
52825:           BEGIN_CASE(JSOP_GNAMEINC)
53118:             jsop_gnameinc(op, stubs::GlobalNameInc, fullAtomIndex(PC));
53511:             break;
52825:           END_CASE(JSOP_GNAMEINC)
52732: 
52746:           BEGIN_CASE(JSOP_PROPINC)
52746:             jsop_propinc(op, stubs::PropInc, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_PROPINC)
52746: 
52815:           BEGIN_CASE(JSOP_ELEMINC)
52815:             jsop_eleminc(op, stubs::ElemInc);
52815:           END_CASE(JSOP_ELEMINC)
52815: 
52732:           BEGIN_CASE(JSOP_NAMEDEC)
52732:             jsop_nameinc(op, stubs::NameDec, fullAtomIndex(PC));
53118:             break;
52732:           END_CASE(JSOP_NAMEDEC)
52732: 
52825:           BEGIN_CASE(JSOP_GNAMEDEC)
53118:             jsop_gnameinc(op, stubs::GlobalNameDec, fullAtomIndex(PC));
53511:             break;
52825:           END_CASE(JSOP_GNAMEDEC)
52825: 
52746:           BEGIN_CASE(JSOP_PROPDEC)
52746:             jsop_propinc(op, stubs::PropDec, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_PROPDEC)
52746: 
52815:           BEGIN_CASE(JSOP_ELEMDEC)
52815:             jsop_eleminc(op, stubs::ElemDec);
52815:           END_CASE(JSOP_ELEMDEC)
52815: 
52741:           BEGIN_CASE(JSOP_GETTHISPROP)
52741:             /* Push thisv onto stack. */
52741:             jsop_this();
52892:             jsop_getprop(script->getAtom(fullAtomIndex(PC)));
52741:           END_CASE(JSOP_GETTHISPROP);
52741: 
52741:           BEGIN_CASE(JSOP_GETARGPROP)
52741:             /* Push arg onto stack. */
52741:             jsop_getarg(GET_SLOTNO(PC));
52892:             jsop_getprop(script->getAtom(fullAtomIndex(&PC[ARGNO_LEN])));
52741:           END_CASE(JSOP_GETARGPROP)
52741: 
52741:           BEGIN_CASE(JSOP_GETLOCALPROP)
52741:             frame.pushLocal(GET_SLOTNO(PC));
52892:             jsop_getprop(script->getAtom(fullAtomIndex(&PC[SLOTNO_LEN])));
52741:           END_CASE(JSOP_GETLOCALPROP)
52741: 
52741:           BEGIN_CASE(JSOP_GETPROP)
52770:           BEGIN_CASE(JSOP_GETXPROP)
52892:             jsop_getprop(script->getAtom(fullAtomIndex(PC)));
52741:           END_CASE(JSOP_GETPROP)
52741: 
52762:           BEGIN_CASE(JSOP_LENGTH)
52884:             jsop_length();
52762:           END_CASE(JSOP_LENGTH)
52762: 
52693:           BEGIN_CASE(JSOP_GETELEM)
52843:             jsop_getelem();
52693:           END_CASE(JSOP_GETELEM)
52693: 
52693:           BEGIN_CASE(JSOP_SETELEM)
52838:             jsop_setelem();
52693:           END_CASE(JSOP_SETELEM);
52693: 
52644:           BEGIN_CASE(JSOP_CALLNAME)
53087:             prepareStubCall(Uses(0));
52644:             masm.move(Imm32(fullAtomIndex(PC)), Registers::ArgReg1);
53087:             stubCall(stubs::CallName);
52644:             frame.pushSynced();
52771:             frame.pushSynced();
52644:           END_CASE(JSOP_CALLNAME)
52644: 
52645:           BEGIN_CASE(JSOP_CALL)
52767:           BEGIN_CASE(JSOP_EVAL)
52767:           BEGIN_CASE(JSOP_APPLY)
52645:           {
52648:             JaegerSpew(JSpew_Insns, " --- SCRIPTED CALL --- \n");
52850:             inlineCallHelper(GET_ARGC(PC), false);
52648:             JaegerSpew(JSpew_Insns, " --- END SCRIPTED CALL --- \n");
52645:           }
52645:           END_CASE(JSOP_CALL)
52645: 
52615:           BEGIN_CASE(JSOP_NAME)
53054:             jsop_name(script->getAtom(fullAtomIndex(PC)));
52615:           END_CASE(JSOP_NAME)
52615: 
52605:           BEGIN_CASE(JSOP_DOUBLE)
52605:           {
52605:             uint32 index = fullAtomIndex(PC);
53081:             double d = script->getConst(index).toDouble();
53081:             frame.push(Value(DoubleValue(d)));
52605:           }
52605:           END_CASE(JSOP_DOUBLE)
52605: 
52653:           BEGIN_CASE(JSOP_STRING)
52653:           {
52653:             JSAtom *atom = script->getAtom(fullAtomIndex(PC));
52653:             JSString *str = ATOM_TO_STRING(atom);
53081:             frame.push(Value(StringValue(str)));
52653:           }
52653:           END_CASE(JSOP_STRING)
52653: 
52560:           BEGIN_CASE(JSOP_ZERO)
52617:             frame.push(Valueify(JSVAL_ZERO));
52560:           END_CASE(JSOP_ZERO)
52560: 
52560:           BEGIN_CASE(JSOP_ONE)
52617:             frame.push(Valueify(JSVAL_ONE));
52560:           END_CASE(JSOP_ONE)
52560: 
52675:           BEGIN_CASE(JSOP_NULL)
53081:             frame.push(NullValue());
52675:           END_CASE(JSOP_NULL)
52675: 
52704:           BEGIN_CASE(JSOP_THIS)
52741:             jsop_this();
52704:           END_CASE(JSOP_THIS)
52704: 
52666:           BEGIN_CASE(JSOP_FALSE)
53081:             frame.push(Value(BooleanValue(false)));
52666:           END_CASE(JSOP_FALSE)
52666: 
52665:           BEGIN_CASE(JSOP_TRUE)
53081:             frame.push(Value(BooleanValue(true)));
52665:           END_CASE(JSOP_TRUE)
52665: 
52733:           BEGIN_CASE(JSOP_OR)
52733:           BEGIN_CASE(JSOP_AND)
53086:             jsop_andor(op, PC + GET_JUMP_OFFSET(PC));
52733:           END_CASE(JSOP_AND)
52733: 
52794:           BEGIN_CASE(JSOP_TABLESWITCH)
52794:             frame.forgetEverything();
52794:             masm.move(ImmPtr(PC), Registers::ArgReg1);
53338: 
53338:             /* prepareStubCall() is not needed due to forgetEverything() */
53087:             stubCall(stubs::TableSwitch);
53338:             frame.pop();
53338: 
52794:             masm.jump(Registers::ReturnReg);
52794:             PC += js_GetVariableBytecodeLength(PC);
52794:             break;
52794:           END_CASE(JSOP_TABLESWITCH)
52794: 
52793:           BEGIN_CASE(JSOP_LOOKUPSWITCH)
52793:             frame.forgetEverything();
52793:             masm.move(ImmPtr(PC), Registers::ArgReg1);
53338: 
53338:             /* prepareStubCall() is not needed due to forgetEverything() */
53087:             stubCall(stubs::LookupSwitch);
53338:             frame.pop();
53338: 
52793:             masm.jump(Registers::ReturnReg);
52793:             PC += js_GetVariableBytecodeLength(PC);
52793:             break;
52793:           END_CASE(JSOP_LOOKUPSWITCH)
52793: 
52739:           BEGIN_CASE(JSOP_STRICTEQ)
52855:             jsop_stricteq(op);
52739:           END_CASE(JSOP_STRICTEQ)
52739: 
52739:           BEGIN_CASE(JSOP_STRICTNE)
52855:             jsop_stricteq(op);
52739:           END_CASE(JSOP_STRICTNE)
52739: 
52736:           BEGIN_CASE(JSOP_ITER)
53404: # if defined JS_CPU_X64
53368:             prepareStubCall(Uses(1));
53368:             masm.move(Imm32(PC[1]), Registers::ArgReg1);
53368:             stubCall(stubs::Iter);
53368:             frame.pop();
53368:             frame.pushSynced();
53404: #else
53404:             iter(PC[1]);
53404: #endif
52736:           END_CASE(JSOP_ITER)
52736: 
52737:           BEGIN_CASE(JSOP_MOREITER)
52737:             /* This MUST be fused with IFNE or IFNEX. */
52737:             iterMore();
52737:             break;
52737:           END_CASE(JSOP_MOREITER)
52737: 
52737:           BEGIN_CASE(JSOP_ENDITER)
53404: # if defined JS_CPU_X64
53368:             prepareStubCall(Uses(1));
53368:             stubCall(stubs::EndIter);
53368:             frame.pop();
53404: #else
53404:             iterEnd();
53404: #endif
52737:           END_CASE(JSOP_ENDITER)
52737: 
52575:           BEGIN_CASE(JSOP_POP)
52575:             frame.pop();
52575:           END_CASE(JSOP_POP)
52575: 
52697:           BEGIN_CASE(JSOP_NEW)
52697:           {
52697:             JaegerSpew(JSpew_Insns, " --- NEW OPERATOR --- \n");
52850:             inlineCallHelper(GET_ARGC(PC), true);
52697:             JaegerSpew(JSpew_Insns, " --- END NEW OPERATOR --- \n");
52697:           }
52697:           END_CASE(JSOP_NEW)
52697: 
52656:           BEGIN_CASE(JSOP_GETARG)
52678:           BEGIN_CASE(JSOP_CALLARG)
52656:           {
52741:             jsop_getarg(GET_SLOTNO(PC));
52678:             if (op == JSOP_CALLARG)
53081:                 frame.push(NullValue());
52656:           }
52656:           END_CASE(JSOP_GETARG)
52656: 
52825:           BEGIN_CASE(JSOP_BINDGNAME)
52826:             jsop_bindgname();
52825:           END_CASE(JSOP_BINDGNAME)
52825: 
52728:           BEGIN_CASE(JSOP_SETARG)
52728:           {
52728:             uint32 slot = GET_SLOTNO(PC);
52728:             FrameEntry *top = frame.peek(-1);
52728: 
52728:             bool popped = PC[JSOP_SETARG_LENGTH] == JSOP_POP;
52728: 
52728:             RegisterID reg = frame.allocReg();
52829:             masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, argv)), reg);
52728:             Address address = Address(reg, slot * sizeof(Value));
52728:             frame.storeTo(top, address, popped);
52728:             frame.freeReg(reg);
52728:           }
52728:           END_CASE(JSOP_SETARG)
52728: 
52670:           BEGIN_CASE(JSOP_GETLOCAL)
52670:           {
52670:             uint32 slot = GET_SLOTNO(PC);
52670:             frame.pushLocal(slot);
52670:           }
52670:           END_CASE(JSOP_GETLOCAL)
52670: 
52670:           BEGIN_CASE(JSOP_SETLOCAL)
52786:           BEGIN_CASE(JSOP_SETLOCALPOP)
52691:             frame.storeLocal(GET_SLOTNO(PC));
52786:             if (op == JSOP_SETLOCALPOP)
52786:                 frame.pop();
52670:           END_CASE(JSOP_SETLOCAL)
52670: 
52575:           BEGIN_CASE(JSOP_UINT16)
53081:             frame.push(Value(Int32Value((int32_t) GET_UINT16(PC))));
52575:           END_CASE(JSOP_UINT16)
52575: 
52719:           BEGIN_CASE(JSOP_NEWINIT)
52719:           {
52719:             jsint i = GET_INT8(PC);
52719:             JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
52719: 
53087:             prepareStubCall(Uses(0));
52719:             if (i == JSProto_Array) {
53087:                 stubCall(stubs::NewInitArray);
52719:             } else {
52719:                 JSOp next = JSOp(PC[JSOP_NEWINIT_LENGTH]);
52719:                 masm.move(Imm32(next == JSOP_ENDINIT ? 1 : 0), Registers::ArgReg1);
53087:                 stubCall(stubs::NewInitObject);
52719:             }
52719:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52719:           }
52719:           END_CASE(JSOP_NEWINIT)
52719: 
52719:           BEGIN_CASE(JSOP_ENDINIT)
52719:           END_CASE(JSOP_ENDINIT)
52719: 
52735:           BEGIN_CASE(JSOP_INITPROP)
52735:           {
52735:             JSAtom *atom = script->getAtom(fullAtomIndex(PC));
53087:             prepareStubCall(Uses(2));
52735:             masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:             stubCall(stubs::InitProp);
52735:             frame.pop();
52735:           }
52735:           END_CASE(JSOP_INITPROP)
52735: 
52723:           BEGIN_CASE(JSOP_INITELEM)
52723:           {
52723:             JSOp next = JSOp(PC[JSOP_INITELEM_LENGTH]);
53087:             prepareStubCall(Uses(3));
52723:             masm.move(Imm32(next == JSOP_ENDINIT ? 1 : 0), Registers::ArgReg1);
53087:             stubCall(stubs::InitElem);
52723:             frame.popn(2);
52723:           }
52723:           END_CASE(JSOP_INITELEM)
52723: 
52804:           BEGIN_CASE(JSOP_INCARG)
52804:           BEGIN_CASE(JSOP_DECARG)
52804:           BEGIN_CASE(JSOP_ARGINC)
52804:           BEGIN_CASE(JSOP_ARGDEC)
52804:           {
52804:             jsbytecode *next = &PC[JSOP_ARGINC_LENGTH];
52804:             bool popped = false;
52804:             if (JSOp(*next) == JSOP_POP && !analysis[next].nincoming)
52804:                 popped = true;
52804:             jsop_arginc(op, GET_SLOTNO(PC), popped);
52804:             PC += JSOP_ARGINC_LENGTH;
52804:             if (popped)
52804:                 PC += JSOP_POP_LENGTH;
52804:             break;
52804:           }
52804:           END_CASE(JSOP_ARGDEC)
52804: 
52773:           BEGIN_CASE(JSOP_FORNAME)
53087:             prepareStubCall(Uses(1));
52773:             masm.move(ImmPtr(script->getAtom(fullAtomIndex(PC))), Registers::ArgReg1);
53087:             stubCall(stubs::ForName);
52773:           END_CASE(JSOP_FORNAME)
52773: 
52808:           BEGIN_CASE(JSOP_INCLOCAL)
52808:           BEGIN_CASE(JSOP_DECLOCAL)
52808:           BEGIN_CASE(JSOP_LOCALINC)
52808:           BEGIN_CASE(JSOP_LOCALDEC)
52808:           {
52808:             jsbytecode *next = &PC[JSOP_LOCALINC_LENGTH];
52808:             bool popped = false;
52808:             if (JSOp(*next) == JSOP_POP && !analysis[next].nincoming)
52808:                 popped = true;
52808:             /* These manually advance the PC. */
52808:             jsop_localinc(op, GET_SLOTNO(PC), popped);
52808:             PC += JSOP_LOCALINC_LENGTH;
52808:             if (popped)
52808:                 PC += JSOP_POP_LENGTH;
52808:             break;
52808:           }
52808:           END_CASE(JSOP_LOCALDEC)
52808: 
52560:           BEGIN_CASE(JSOP_BINDNAME)
52560:             jsop_bindname(fullAtomIndex(PC));
52560:           END_CASE(JSOP_BINDNAME)
52560: 
52886:           BEGIN_CASE(JSOP_SETPROP)
52892:             jsop_setprop(script->getAtom(fullAtomIndex(PC)));
52886:           END_CASE(JSOP_SETPROP)
52886: 
52611:           BEGIN_CASE(JSOP_SETNAME)
52747:           BEGIN_CASE(JSOP_SETMETHOD)
52974:             jsop_setprop(script->getAtom(fullAtomIndex(PC)));
52611:           END_CASE(JSOP_SETNAME)
52611: 
52772:           BEGIN_CASE(JSOP_THROW)
53087:             prepareStubCall(Uses(1));
53087:             stubCall(stubs::Throw);
52772:             frame.pop();
52772:           END_CASE(JSOP_THROW)
52772: 
52780:           BEGIN_CASE(JSOP_INSTANCEOF)
52894:             jsop_instanceof();
52780:           END_CASE(JSOP_INSTANCEOF)
52780: 
52786:           BEGIN_CASE(JSOP_EXCEPTION)
52786:           {
52787:             JS_STATIC_ASSERT(sizeof(cx->throwing) == 4);
52786:             RegisterID reg = frame.allocReg();
52786:             masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), reg);
52786:             masm.store32(Imm32(JS_FALSE), Address(reg, offsetof(JSContext, throwing)));
52786: 
52786:             Address excn(reg, offsetof(JSContext, exception));
52786:             frame.freeReg(reg);
52786:             frame.push(excn);
52786:           }
52786:           END_CASE(JSOP_EXCEPTION)
52786: 
52768:           BEGIN_CASE(JSOP_LINENO)
52768:           END_CASE(JSOP_LINENO)
52768: 
52647:           BEGIN_CASE(JSOP_DEFFUN)
53087:             prepareStubCall(Uses(0));
52647:             masm.move(Imm32(fullAtomIndex(PC)), Registers::ArgReg1);
53087:             stubCall(stubs::DefFun);
52647:           END_CASE(JSOP_DEFFUN)
52647: 
53038:           BEGIN_CASE(JSOP_DEFLOCALFUN_FC)
53038:           {
53038:             uint32 slot = GET_SLOTNO(PC);
53038:             JSFunction *fun = script->getFunction(fullAtomIndex(&PC[SLOTNO_LEN]));
53087:             prepareStubCall(Uses(frame.frameDepth()));
53038:             masm.move(ImmPtr(fun), Registers::ArgReg1);
53087:             stubCall(stubs::DefLocalFun_FC);
53038:             frame.takeReg(Registers::ReturnReg);
53038:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
53309:             frame.storeLocal(slot, true);
53038:             frame.pop();
53038:           }
53340:           END_CASE(JSOP_DEFLOCALFUN_FC)
53038: 
52730:           BEGIN_CASE(JSOP_LAMBDA)
52730:           {
52730:             JSFunction *fun = script->getFunction(fullAtomIndex(PC));
53249: 
53249:             JSObjStubFun stub = stubs::Lambda;
53249:             uint32 uses = 0;
53249: 
53249:             JSOp next = JSOp(PC[JSOP_LAMBDA_LENGTH]);
53249:             if (next == JSOP_INITMETHOD) {
53249:                 stub = stubs::LambdaForInit;
53249:             } else if (next == JSOP_SETMETHOD) {
53249:                 stub = stubs::LambdaForSet;
53249:                 uses = 1;
53249:             } else if (fun->joinable()) {
53249:                 if (next == JSOP_CALL) {
53249:                     stub = stubs::LambdaJoinableForCall;
53249:                     uses = frame.frameDepth();
53249:                 } else if (next == JSOP_NULL) {
53249:                     stub = stubs::LambdaJoinableForNull;
53249:                 }
53249:             }
53249: 
53249:             prepareStubCall(Uses(uses));
52730:             masm.move(ImmPtr(fun), Registers::ArgReg1);
53128: 
53249:             stubCall(stub);
53249: 
52730:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52730:           }
52730:           END_CASE(JSOP_LAMBDA)
52730: 
52774:           BEGIN_CASE(JSOP_TRY)
52774:           END_CASE(JSOP_TRY)
52774: 
52716:           BEGIN_CASE(JSOP_GETDSLOT)
52716:           BEGIN_CASE(JSOP_CALLDSLOT)
52716:           {
52716:             // :FIXME: x64
52716:             RegisterID reg = frame.allocReg();
52829:             masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, argv)), reg);
53144:             masm.loadPayload(Address(reg, int32(sizeof(Value)) * -2), reg);
52716:             masm.loadPtr(Address(reg, offsetof(JSObject, dslots)), reg);
52716:             frame.freeReg(reg);
52716:             frame.push(Address(reg, GET_UINT16(PC) * sizeof(Value)));
52716:             if (op == JSOP_CALLDSLOT)
53081:                 frame.push(NullValue());
52716:           }
52716:           END_CASE(JSOP_CALLDSLOT)
52716: 
53037:           BEGIN_CASE(JSOP_ARGSUB)
53087:             prepareStubCall(Uses(0));
53037:             masm.move(Imm32(GET_ARGNO(PC)), Registers::ArgReg1);
53087:             stubCall(stubs::ArgSub);
53037:             frame.pushSynced();
53037:           END_CASE(JSOP_ARGSUB)
53037: 
52781:           BEGIN_CASE(JSOP_ARGCNT)
53087:             prepareStubCall(Uses(0));
53087:             stubCall(stubs::ArgCnt);
52781:             frame.pushSynced();
52781:           END_CASE(JSOP_ARGCNT)
52781: 
52727:           BEGIN_CASE(JSOP_DEFLOCALFUN)
52727:           {
52727:             uint32 slot = GET_SLOTNO(PC);
52727:             JSFunction *fun = script->getFunction(fullAtomIndex(&PC[SLOTNO_LEN]));
53087:             prepareStubCall(Uses(0));
52727:             masm.move(ImmPtr(fun), Registers::ArgReg1);
53087:             stubCall(stubs::DefLocalFun);
52727:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
53309:             frame.storeLocal(slot, true);
52727:             frame.pop();
52727:           }
52727:           END_CASE(JSOP_DEFLOCALFUN)
52727: 
52806:           BEGIN_CASE(JSOP_RETRVAL)
52806:             emitReturn();
52806:           END_CASE(JSOP_RETRVAL)
52806: 
52825:           BEGIN_CASE(JSOP_GETGNAME)
52825:           BEGIN_CASE(JSOP_CALLGNAME)
52826:             jsop_getgname(fullAtomIndex(PC));
52825:             if (op == JSOP_CALLGNAME)
53081:                 frame.push(NullValue());
52825:           END_CASE(JSOP_GETGNAME)
52825: 
52825:           BEGIN_CASE(JSOP_SETGNAME)
52831:             jsop_setgname(fullAtomIndex(PC));
52825:           END_CASE(JSOP_SETGNAME)
52825: 
52729:           BEGIN_CASE(JSOP_REGEXP)
52729:           {
52729:             JSObject *regex = script->getRegExp(fullAtomIndex(PC));
53087:             prepareStubCall(Uses(0));
52729:             masm.move(ImmPtr(regex), Registers::ArgReg1);
53087:             stubCall(stubs::RegExp);
52729:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52729:           }
52729:           END_CASE(JSOP_REGEXP)
52729: 
52761:           BEGIN_CASE(JSOP_CALLPROP)
52903:             if (!jsop_callprop(script->getAtom(fullAtomIndex(PC))))
52903:                 return Compile_Error;
52761:           END_CASE(JSOP_CALLPROP)
52761: 
52726:           BEGIN_CASE(JSOP_GETUPVAR)
52726:           BEGIN_CASE(JSOP_CALLUPVAR)
52726:           {
52726:             uint32 index = GET_UINT16(PC);
52726:             JSUpvarArray *uva = script->upvars();
52726:             JS_ASSERT(index < uva->length);
52726: 
53087:             prepareStubCall(Uses(0));
53081:             masm.move(Imm32(uva->vector[index].asInteger()), Registers::ArgReg1);
53087:             stubCall(stubs::GetUpvar);
52726:             frame.pushSynced();
52726:             if (op == JSOP_CALLUPVAR)
53081:                 frame.push(NullValue());
52726:           }
52726:           END_CASE(JSOP_CALLUPVAR)
52726: 
52575:           BEGIN_CASE(JSOP_UINT24)
53081:             frame.push(Value(Int32Value((int32_t) GET_UINT24(PC))));
52575:           END_CASE(JSOP_UINT24)
52575: 
52771:           BEGIN_CASE(JSOP_CALLELEM)
53087:             prepareStubCall(Uses(2));
53087:             stubCall(stubs::CallElem);
52771:             frame.popn(2);
52771:             frame.pushSynced();
52771:             frame.pushSynced();
52771:           END_CASE(JSOP_CALLELEM)
52771: 
52560:           BEGIN_CASE(JSOP_STOP)
52560:             /* Safe point! */
52560:             emitReturn();
52560:             goto done;
52560:           END_CASE(JSOP_STOP)
52560: 
52785:           BEGIN_CASE(JSOP_ENTERBLOCK)
52785:           {
52785:             // If this is an exception entry point, then jsl_InternalThrow has set
52785:             // VMFrame::fp to the correct fp for the entry point. We need to copy
52785:             // that value here to FpReg so that FpReg also has the correct sp.
52785:             // Otherwise, we would simply be using a stale FpReg value.
52785:             if (analysis[PC].exceptionEntry)
53133:                 restoreFrameRegs(masm);
52785: 
52785:             /* For now, don't bother doing anything for this opcode. */
52785:             JSObject *obj = script->getObject(fullAtomIndex(PC));
52785:             frame.forgetEverything();
52785:             masm.move(ImmPtr(obj), Registers::ArgReg1);
52785:             uint32 n = js_GetEnterBlockStackDefs(cx, script, PC);
53087:             stubCall(stubs::EnterBlock);
52785:             frame.enterBlock(n);
52785:           }
52785:           END_CASE(JSOP_ENTERBLOCK)
52785: 
52785:           BEGIN_CASE(JSOP_LEAVEBLOCK)
52785:           {
52785:             uint32 n = js_GetVariableStackUses(op, PC);
53087:             prepareStubCall(Uses(n));
53087:             stubCall(stubs::LeaveBlock);
52785:             frame.leaveBlock(n);
52785:           }
52785:           END_CASE(JSOP_LEAVEBLOCK)
52785: 
52742:           BEGIN_CASE(JSOP_CALLLOCAL)
52742:             frame.pushLocal(GET_SLOTNO(PC));
53081:             frame.push(NullValue());
52742:           END_CASE(JSOP_CALLLOCAL)
52742: 
52575:           BEGIN_CASE(JSOP_INT8)
53081:             frame.push(Value(Int32Value(GET_INT8(PC))));
52575:           END_CASE(JSOP_INT8)
52575: 
52575:           BEGIN_CASE(JSOP_INT32)
53081:             frame.push(Value(Int32Value(GET_INT32(PC))));
52575:           END_CASE(JSOP_INT32)
52575: 
52703:           BEGIN_CASE(JSOP_NEWARRAY)
52703:           {
52703:             uint32 len = GET_UINT16(PC);
53087:             prepareStubCall(Uses(len));
52703:             masm.move(Imm32(len), Registers::ArgReg1);
53087:             stubCall(stubs::NewArray);
52703:             frame.popn(len);
52703:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52703:           }
52703:           END_CASE(JSOP_NEWARRAY)
52703: 
52775:           BEGIN_CASE(JSOP_LAMBDA_FC)
52775:           {
52775:             JSFunction *fun = script->getFunction(fullAtomIndex(PC));
53087:             prepareStubCall(Uses(frame.frameDepth()));
52775:             masm.move(ImmPtr(fun), Registers::ArgReg1);
53087:             stubCall(stubs::FlatLambda);
52775:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52775:           }
52775:           END_CASE(JSOP_LAMBDA_FC)
52775: 
52617:           BEGIN_CASE(JSOP_TRACE)
52753:           {
53223:             if (analysis[PC].nincoming > 0)
53223:                 interruptCheckHelper();
52753:           }
52617:           END_CASE(JSOP_TRACE)
52617: 
53395:           BEGIN_CASE(JSOP_DEBUGGER)
53395:             prepareStubCall(Uses(0));
53396:             masm.move(ImmPtr(PC), Registers::ArgReg1);
53395:             stubCall(stubs::Debugger);
53395:           END_CASE(JSOP_DEBUGGER)
53395: 
52783:           BEGIN_CASE(JSOP_INITMETHOD)
52783:           {
52783:             JSAtom *atom = script->getAtom(fullAtomIndex(PC));
53087:             prepareStubCall(Uses(2));
52783:             masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:             stubCall(stubs::InitMethod);
52783:             frame.pop();
52783:           }
52783:           END_CASE(JSOP_INITMETHOD)
52783: 
52874:           BEGIN_CASE(JSOP_UNBRAND)
52874:             jsop_unbrand();
52874:           END_CASE(JSOP_UNBRAND)
52874: 
52874:           BEGIN_CASE(JSOP_UNBRANDTHIS)
52874:             jsop_this();
52874:             jsop_unbrand();
52875:             frame.pop();
52874:           END_CASE(JSOP_UNBRANDTHIS)
52874: 
52560:           BEGIN_CASE(JSOP_GETGLOBAL)
52779:           BEGIN_CASE(JSOP_CALLGLOBAL)
52560:             jsop_getglobal(GET_SLOTNO(PC));
52779:             if (op == JSOP_CALLGLOBAL)
53081:                 frame.push(NullValue());
52560:           END_CASE(JSOP_GETGLOBAL)
52560: 
52560:           BEGIN_CASE(JSOP_SETGLOBAL)
52560:             jsop_setglobal(GET_SLOTNO(PC));
52560:           END_CASE(JSOP_SETGLOBAL)
52560: 
52623:           BEGIN_CASE(JSOP_INCGLOBAL)
52623:           BEGIN_CASE(JSOP_DECGLOBAL)
52623:           BEGIN_CASE(JSOP_GLOBALINC)
52623:           BEGIN_CASE(JSOP_GLOBALDEC)
52623:             /* Advances PC automatically. */
52623:             jsop_globalinc(op, GET_SLOTNO(PC));
52623:             break;
52623:           END_CASE(JSOP_GLOBALINC)
52623: 
52878:           BEGIN_CASE(JSOP_DEFUPVAR)
53520:           {
53520:             uint32 slot = GET_SLOTNO(PC);
53520:             if (frame.addEscaping(slot) && slot < script->nfixed) {
53520:                 if (!escapingList.append(slot))
53520:                     return Compile_Error;
53520:             }
53520:           }
52878:           END_CASE(JSOP_DEFUPVAR)
52878: 
52558:           default:
52558:            /* Sorry, this opcode isn't implemented yet. */
52558: #ifdef JS_METHODJIT_SPEW
52825:             JaegerSpew(JSpew_Abort, "opcode %s not handled yet (%s line %d)\n", OpcodeNames[op],
52825:                        script->filename, js_PCToLineNumber(cx, script, PC));
52558: #endif
52558:             return Compile_Abort;
52558:         }
52560: 
52560:     /**********************
52560:      *  END COMPILER OPS  *
52560:      **********************/ 
52578: 
52618: #ifdef DEBUG
52578:         frame.assertValidRegisterState();
52618: #endif
52558:     }
52558: 
52560:   done:
52558:     return Compile_Okay;
52558: }
52558: 
52560: #undef END_CASE
52560: #undef BEGIN_CASE
52560: 
52653: JSC::MacroAssembler::Label
52599: mjit::Compiler::labelOf(jsbytecode *pc)
52599: {
52599:     uint32 offs = uint32(pc - script->code);
52599:     JS_ASSERT(jumpMap[offs].isValid());
52599:     return jumpMap[offs];
52599: }
52599: 
52606: JSC::ExecutablePool *
52606: mjit::Compiler::getExecPool(size_t size)
52606: {
52606:     ThreadData *jaegerData = &JS_METHODJIT_DATA(cx);
52606:     return jaegerData->execPool->poolForSize(size);
52606: }
52606: 
52560: uint32
52560: mjit::Compiler::fullAtomIndex(jsbytecode *pc)
52560: {
52560:     return GET_SLOTNO(pc);
52560: 
52560:     /* If we ever enable INDEXBASE garbage, use this below. */
52560: #if 0
52560:     return GET_SLOTNO(pc) + (atoms - script->atomMap.vector);
52560: #endif
52560: }
52560: 
52653: bool
52653: mjit::Compiler::knownJump(jsbytecode *pc)
52653: {
52653:     return pc < PC;
52653: }
52653: 
53168: void *
53168: mjit::Compiler::findCallSite(const CallSite &callSite)
53168: {
53498:     JS_ASSERT(callSite.pcOffset < script->length);
53168: 
53168:     for (uint32 i = 0; i < callSites.length(); i++) {
53498:         if (callSites[i].pc == script->code + callSite.pcOffset &&
53498:             callSites[i].id == callSite.id) {
53168:             if (callSites[i].stub) {
53498:                 return (uint8*)script->jit->invoke + masm.size() +
53168:                        stubcc.masm.distanceOf(callSites[i].location);
53168:             }
53498:             return (uint8*)script->jit->invoke +
53168:                 stubcc.masm.distanceOf(callSites[i].location);
53168:         }
53168:     }
53168: 
53168:     /* We have no idea where to patch up to. */
53168:     JS_NOT_REACHED("Call site vanished.");
53168:     return NULL;
53168: }
53168: 
52599: void
52599: mjit::Compiler::jumpInScript(Jump j, jsbytecode *pc)
52599: {
52599:     JS_ASSERT(pc >= script->code && uint32(pc - script->code) < script->length);
52599: 
52599:     /* :TODO: OOM failure possible here. */
52599: 
52599:     if (pc < PC)
52599:         j.linkTo(jumpMap[uint32(pc - script->code)], &masm);
52599:     else
52599:         branchPatches.append(BranchPatch(j, pc));
52599: }
52599: 
52560: void
52560: mjit::Compiler::jsop_setglobal(uint32 index)
52560: {
52560:     JS_ASSERT(globalObj);
52560:     uint32 slot = script->getGlobalSlot(index);
52560: 
52560:     FrameEntry *fe = frame.peek(-1);
52560:     bool popped = PC[JSOP_SETGLOBAL_LENGTH] == JSOP_POP;
52560: 
52560:     RegisterID reg = frame.allocReg();
52622:     Address address = masm.objSlotRef(globalObj, reg, slot);
52622:     frame.storeTo(fe, address, popped);
52560:     frame.freeReg(reg);
52560: }
52560: 
52560: void
52560: mjit::Compiler::jsop_getglobal(uint32 index)
52560: {
52560:     JS_ASSERT(globalObj);
52560:     uint32 slot = script->getGlobalSlot(index);
52560: 
52560:     RegisterID reg = frame.allocReg();
52622:     Address address = masm.objSlotRef(globalObj, reg, slot);
52560:     frame.freeReg(reg);
52622:     frame.push(address);
52560: }
52560: 
52560: void
52560: mjit::Compiler::emitReturn()
52560: {
52847:     /*
52847:      * if (!f.inlineCallCount)
52847:      *     return;
52847:      */
52847:     Jump noInlineCalls = masm.branchPtr(Assembler::Equal,
53422:                                         FrameAddress(offsetof(VMFrame, entryFp)),
53422:                                         JSFrameReg);
53088:     stubcc.linkExit(noInlineCalls, Uses(frame.frameDepth()));
53472:     stubcc.masm.restoreReturnAddress();
52847:     stubcc.masm.ret();
52847: 
52847:     JS_ASSERT_IF(!fun, JSOp(*PC) == JSOP_STOP);
52847: 
52847:     /*
52847:      * If there's a function object, deal with the fact that it can escape.
52847:      * Note that after we've placed the call object, all tracked state can
52847:      * be thrown away. This will happen anyway because the next live opcode
52847:      * (if any) must have an incoming edge.
52847:      *
52847:      * However, it's an optimization to throw it away early - the tracker
52847:      * won't be spilled on further exits or join points.
52847:      */
52847:     if (fun) {
52847:         if (fun->isHeavyweight()) {
52847:             /* There will always be a call object. */
53087:             prepareStubCall(Uses(0));
53087:             stubCall(stubs::PutCallObject);
52847:             frame.throwaway();
52847:         } else {
52847:             /* if (callobj) ... */
52847:             Jump callObj = masm.branchPtr(Assembler::NotEqual,
53420:                                           Address(JSFrameReg, JSStackFrame::offsetCallObj()),
52847:                                           ImmPtr(0));
53088:             stubcc.linkExit(callObj, Uses(frame.frameDepth()));
52847: 
52847:             frame.throwaway();
52847: 
52847:             stubcc.leave();
52847:             stubcc.call(stubs::PutCallObject);
52847:             Jump j = stubcc.masm.jump();
52847: 
52847:             /* if (arguments) ... */
53081:             Jump argsObj = masm.branchPtr(Assembler::NotEqual,
53420:                                           Address(JSFrameReg, JSStackFrame::offsetArgsObj()),
53081:                                           ImmIntPtr(0));
53088:             stubcc.linkExit(argsObj, Uses(0));
52847:             stubcc.call(stubs::PutArgsObject);
53088:             stubcc.rejoin(Changes(0));
52847:             stubcc.crossJump(j, masm.label());
52847:         }
52847:     }
52847: 
52847:     /*
52847:      * r = fp->down
52847:      * f.fp = r
52847:      */
52847:     masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, down)), Registers::ReturnReg);
53482:     masm.storePtr(Registers::ReturnReg, FrameAddress(offsetof(VMFrame, regs.fp)));
52847: 
52847:     JS_STATIC_ASSERT(Registers::ReturnReg != JSReturnReg_Data);
52847:     JS_STATIC_ASSERT(Registers::ReturnReg != JSReturnReg_Type);
52847: 
53440:     Address rval(JSFrameReg, JSStackFrame::offsetReturnValue());
53162:     masm.loadPayload(rval, JSReturnReg_Data);
53162:     masm.loadTypeTag(rval, JSReturnReg_Type);
53472:     masm.restoreReturnAddress();
52847:     masm.move(Registers::ReturnReg, JSFrameReg);
52847: #ifdef DEBUG
52847:     masm.storePtr(ImmPtr(JSStackFrame::sInvalidPC),
52847:                   Address(JSFrameReg, offsetof(JSStackFrame, savedPC)));
52847: #endif
52560:     masm.ret();
52560: }
52560: 
52611: void
53087: mjit::Compiler::prepareStubCall(Uses uses)
52611: {
52613:     JaegerSpew(JSpew_Insns, " ---- STUB CALL, SYNCING FRAME ---- \n");
53087:     frame.syncAndKill(Registers(Registers::TempRegs), uses);
52611:     JaegerSpew(JSpew_Insns, " ---- FRAME SYNCING DONE ---- \n");
52611: }
52611: 
52611: JSC::MacroAssembler::Call
53087: mjit::Compiler::stubCall(void *ptr)
52611: {
52611:     JaegerSpew(JSpew_Insns, " ---- CALLING STUB ---- \n");
52611:     Call cl = masm.stubCall(ptr, PC, frame.stackDepth() + script->nfixed);
52613:     JaegerSpew(JSpew_Insns, " ---- END STUB CALL ---- \n");
52611:     return cl;
52611: }
52611: 
52645: void
53223: mjit::Compiler::interruptCheckHelper()
53223: {
53223:     RegisterID cxreg = frame.allocReg();
53223:     masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), cxreg);
53223: #ifdef JS_THREADSAFE
53223:     masm.loadPtr(Address(cxreg, offsetof(JSContext, thread)), cxreg);
53223:     Address flag(cxreg, offsetof(JSThread, data.interruptFlags));
53223: #else
53223:     masm.loadPtr(Address(cxreg, offsetof(JSContext, runtime)), cxreg);
53223:     Address flag(cxreg, offsetof(JSRuntime, threadData.interruptFlags));
53223: #endif
53223:     Jump jump = masm.branchTest32(Assembler::NonZero, flag);
53223:     frame.freeReg(cxreg);
53223:     stubcc.linkExit(jump, Uses(0));
53223:     stubcc.leave();
53223:     stubcc.masm.move(ImmPtr(PC), Registers::ArgReg1);
53223:     stubcc.call(stubs::Interrupt);
53223:     ADD_CALLSITE(true);
53223:     stubcc.rejoin(Changes(0));
53223: }
53223: 
53223: void
53515: mjit::Compiler::inlineCallHelper(uint32 argc, bool callingNew)
52645: {
53515:     /* Check for interrupts on function call */
53515:     interruptCheckHelper();
53515: 
53515:     FrameEntry *fe = frame.peek(-int(argc + 2));
53515:     bool typeKnown = fe->isTypeKnown();
53515: 
53515:     if (typeKnown && fe->getKnownType() != JSVAL_TYPE_OBJECT) {
53515: #ifdef JS_MONOIC
53515:         /*
53515:          * Make an otherwise empty MIC to hold the argument count.
53515:          * This can't be a fast native so the rest of the MIC won't be used.
53515:          */
53515:         MICGenInfo mic(ic::MICInfo::EMPTYCALL);
53515:         mic.entry = masm.label();
53515:         mic.argc = argc;
53515:         mics.append(mic);
53515: #endif
53515: 
53515:         prepareStubCall(Uses(argc + 2));
53515:         VoidPtrStubUInt32 stub = callingNew ? stubs::SlowNew : stubs::SlowCall;
53515: #ifdef JS_MONOIC
53515:         masm.move(Imm32(mics.length() - 1), Registers::ArgReg1);
53515: #else
53515:         masm.move(Imm32(argc), Registers::ArgReg1);
53515: #endif
53515:         masm.stubCall(stub, PC, frame.stackDepth() + script->nfixed);
53515:         ADD_CALLSITE(false);
53515:         frame.popn(argc + 2);
53515:         frame.pushSynced();
53515:         return;
53515:     }
53515: 
53515: #ifdef JS_MONOIC
53515:     MICGenInfo mic(ic::MICInfo::CALL);
53515:     mic.entry = masm.label();
53515:     mic.argc = argc;
53515:     mic.frameDepth = frame.frameDepth() - argc - 2;
53515: #endif
53515: 
53515:     MaybeRegisterID typeReg;
53515:     RegisterID data = frame.tempRegForData(fe);
53515:     frame.pinReg(data);
53515: 
53515:     Address addr = frame.addressOf(fe);
53515: 
53515:     if (!typeKnown) {
53515:         if (!frame.shouldAvoidTypeRemat(fe)) {
53515:             typeReg = frame.tempRegForType(fe);
53515:             frame.pinReg(typeReg.reg());
53515:         }
53515:     }
53515: 
53515:     /*
53515:      * We rely on the fact that syncAndKill() is not allowed to touch the
53515:      * registers we've preserved.
53515:      */
53515:     frame.syncAndKill(Registers(Registers::AvailRegs), Uses(argc + 2));
53515:     frame.resetRegState();
53515: 
53515:     Label invoke = stubcc.masm.label();
53515: 
53515: #ifdef JS_MONOIC
53515:     mic.stubEntry = invoke;
53515:     mic.dataReg = data;
53515: #endif
53515: 
53515:     Jump j;
53515:     if (!typeKnown) {
53515:         if (!typeReg.isSet())
53515:             j = masm.testObject(Assembler::NotEqual, frame.addressOf(fe));
53515:         else
53515:             j = masm.testObject(Assembler::NotEqual, typeReg.reg());
53515:         stubcc.linkExit(j, Uses(argc + 2));
53515:     }
53515: 
53515: #ifdef JS_MONOIC
53515:     mic.knownObject = masm.label();
53515: #endif
53515: 
53515:     j = masm.testFunction(Assembler::NotEqual, data);
53515:     stubcc.linkExit(j, Uses(argc + 2));
53515:     stubcc.leave();
53515: #ifdef JS_MONOIC
53515:     stubcc.masm.move(Imm32(mics.length()), Registers::ArgReg1);
53515: #else
53515:     stubcc.masm.move(Imm32(argc), Registers::ArgReg1);
53515: #endif
53515:     stubcc.call(callingNew ? stubs::SlowNew : stubs::SlowCall);
53515:     ADD_CALLSITE(true);
53515: 
53515:     /* Get function private pointer. */
53515:     masm.loadFunctionPrivate(data, data);
53515: 
53515:     frame.takeReg(data);
53515:     RegisterID t0 = frame.allocReg();
53515:     RegisterID t1 = frame.allocReg();
53515: 
53515:     /* Test if the function is interpreted, and if not, take a slow path. */
53515:     {
53515:         masm.load16(Address(data, offsetof(JSFunction, flags)), t0);
53515:         masm.move(t0, t1);
53515:         masm.and32(Imm32(JSFUN_KINDMASK), t1);
53515:         Jump notInterp = masm.branch32(Assembler::Below, t1, Imm32(JSFUN_INTERPRETED));
53515:         stubcc.linkExitDirect(notInterp, invoke);
53515:     }
53515: 
53515:     /* Test if it's not got compiled code. */
53515:     Address scriptAddr(data, offsetof(JSFunction, u) + offsetof(JSFunction::U::Scripted, script));
53515:     masm.loadPtr(scriptAddr, data);
53515:     Jump notCompiled = masm.branchPtr(Assembler::BelowOrEqual,
53515:                                       Address(data, offsetof(JSScript, ncode)),
53515:                                       ImmIntPtr(1));
53515:     {
53515:         stubcc.linkExitDirect(notCompiled, invoke);
53515:     }
53515: 
53515:     frame.freeReg(t0);
53515:     frame.freeReg(t1);
53515:     frame.freeReg(data);
53515: 
53515:     /* Scripted call. */
53515:     masm.move(Imm32(argc), Registers::ArgReg1);
53515:     masm.stubCall(callingNew ? stubs::New : stubs::Call,
53515:                   PC, frame.stackDepth() + script->nfixed);
53515: 
53515:     Jump invokeCallDone;
53515:     {
53515:         /*
53515:          * Stub call returns a pointer to JIT'd code, or NULL.
53515:          *
53515:          * If the function could not be JIT'd, it was already invoked using
53515:          * js_Interpret() or js_Invoke(). In that case, the stack frame has
53515:          * already been popped. We don't have to do any extra work.
53515:          */
53515:         Jump j = stubcc.masm.branchTestPtr(Assembler::NonZero, Registers::ReturnReg, Registers::ReturnReg);
53515:         stubcc.crossJump(j, masm.label());
53515:         if (callingNew)
53515:             invokeCallDone = stubcc.masm.jump();
53515:     }
53515: 
53515:     /* Fast-path: return address contains scripted call. */
53515:     masm.call(Registers::ReturnReg);
53515: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
53515:     masm.callLabel = masm.label();
53515: #endif
53515:     ADD_CALLSITE(false);
53515: 
53515:     /*
53515:      * Functions invoked with |new| can return, for some reason, primitive
53515:      * values. Just deal with this here.
53515:      */
53515:     if (callingNew) {
52954:         Jump primitive = masm.testPrimitive(Assembler::Equal, JSReturnReg_Type);
53088:         stubcc.linkExitDirect(primitive, stubcc.masm.label());
52850:         FrameEntry *fe = frame.peek(-int(argc + 1));
52850:         Address thisv(frame.addressOf(fe));
52850:         stubcc.masm.loadTypeTag(thisv, JSReturnReg_Type);
53144:         stubcc.masm.loadPayload(thisv, JSReturnReg_Data);
52850:         Jump primFix = stubcc.masm.jump();
52850:         stubcc.crossJump(primFix, masm.label());
53515:         invokeCallDone.linkTo(stubcc.masm.label(), &stubcc.masm);
52850:     }
52850: 
52850:     frame.popn(argc + 2);
52850:     frame.takeReg(JSReturnReg_Type);
52850:     frame.takeReg(JSReturnReg_Data);
52850:     frame.pushRegs(JSReturnReg_Type, JSReturnReg_Data);
52850: 
53088:     stubcc.rejoin(Changes(0));
53301: 
53301: #ifdef JS_MONOIC
53515:     mic.callEnd = masm.label();
53515:     mics.append(mic);
53301: #endif
52645: }
52645: 
53168: /*
53168:  * This function must be called immediately after any instruction which could
53168:  * cause a new JSStackFrame to be pushed and could lead to a new debug trap
53168:  * being set. This includes any API callbacks and any scripted or native call.
53168:  */
53168: void
53168: mjit::Compiler::addCallSite(uint32 id, bool stub)
53168: {
53168:     InternalCallSite site;
53168:     site.stub = stub;
53477: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
53326:     site.location = stub ? stubcc.masm.callLabel : masm.callLabel;
53326: #else
53168:     site.location = stub ? stubcc.masm.label() : masm.label();
53326: #endif
53477: 
53168:     site.pc = PC;
53168:     site.id = id;
53168:     callSites.append(site);
53168: }
53168: 
52645: void
53133: mjit::Compiler::restoreFrameRegs(Assembler &masm)
52645: {
53482:     masm.loadPtr(FrameAddress(offsetof(VMFrame, regs.fp)), JSFrameReg);
52645: }
52645: 
52651: bool
52651: mjit::Compiler::compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs)
52651: {
52651:     JS_ASSERT(lhs.isPrimitive());
52651:     JS_ASSERT(rhs.isPrimitive());
52651: 
52651:     if (lhs.isString() && rhs.isString()) {
53081:         int cmp = js_CompareStrings(lhs.toString(), rhs.toString());
52651:         switch (op) {
52651:           case JSOP_LT:
52651:             return cmp < 0;
52651:           case JSOP_LE:
52651:             return cmp <= 0;
52651:           case JSOP_GT:
52651:             return cmp > 0;
52651:           case JSOP_GE:
52651:             return cmp >= 0;
52679:           case JSOP_EQ:
52679:             return cmp == 0;
52679:           case JSOP_NE:
52679:             return cmp != 0;
52651:           default:
52651:             JS_NOT_REACHED("NYI");
52651:         }
52651:     } else {
52651:         double ld, rd;
52651:         
52651:         /* These should be infallible w/ primitives. */
52651:         ValueToNumber(cx, lhs, &ld);
52651:         ValueToNumber(cx, rhs, &rd);
52651:         switch(op) {
52651:           case JSOP_LT:
52651:             return ld < rd;
52651:           case JSOP_LE:
52651:             return ld <= rd;
52651:           case JSOP_GT:
52651:             return ld > rd;
52651:           case JSOP_GE:
52651:             return ld >= rd;
52679:           case JSOP_EQ: /* fall through */
52679:           case JSOP_NE:
52679:             /* Special case null/undefined/void comparisons. */
52679:             if (lhs.isNullOrUndefined()) {
52679:                 if (rhs.isNullOrUndefined())
52679:                     return op == JSOP_EQ;
52679:                 return op == JSOP_NE;
52679:             }
52679:             if (rhs.isNullOrUndefined())
52679:                 return op == JSOP_NE;
52679: 
52679:             /* Normal return. */
52679:             return (op == JSOP_EQ) ? (ld == rd) : (ld != rd);
52651:           default:
52651:             JS_NOT_REACHED("NYI");
52651:         }
52651:     }
52651: 
52651:     JS_NOT_REACHED("NYI");
52651:     return false;
52651: }
52651: 
52653: void
52653: mjit::Compiler::emitStubCmpOp(BoolStub stub, jsbytecode *target, JSOp fused)
52653: {
53087:     prepareStubCall(Uses(2));
53087:     stubCall(stub);
52653:     frame.pop();
52653:     frame.pop();
52653: 
52653:     if (!target) {
52653:         frame.takeReg(Registers::ReturnReg);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, Registers::ReturnReg);
52653:     } else {
52679:         JS_ASSERT(fused == JSOP_IFEQ || fused == JSOP_IFNE);
52679: 
52653:         frame.forgetEverything();
52653:         Assembler::Condition cond = (fused == JSOP_IFEQ)
52653:                                     ? Assembler::Zero
52653:                                     : Assembler::NonZero;
52653:         Jump j = masm.branchTest32(cond, Registers::ReturnReg,
52653:                                    Registers::ReturnReg);
53133:         jumpAndTrace(j, target);
52653:     }
52653: }
52653: 
52692: void
52892: mjit::Compiler::jsop_setprop_slow(JSAtom *atom)
52886: {
53087:     prepareStubCall(Uses(2));
52886:     masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:     stubCall(stubs::SetName);
52886:     JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
52886:     frame.shimmy(1);
52886: }
52886: 
52886: void
52743: mjit::Compiler::jsop_getprop_slow()
52743: {
53087:     prepareStubCall(Uses(1));
53087:     stubCall(stubs::GetProp);
52743:     frame.pop();
52743:     frame.pushSynced();
52743: }
52743: 
52903: bool
52896: mjit::Compiler::jsop_callprop_slow(JSAtom *atom)
52896: {
53087:     prepareStubCall(Uses(1));
52896:     masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:     stubCall(stubs::CallProp);
52896:     frame.pop();
52896:     frame.pushSynced();
52896:     frame.pushSynced();
52903:     return true;
52896: }
52896: 
52896: void
52884: mjit::Compiler::jsop_length()
52884: {
52884:     FrameEntry *top = frame.peek(-1);
52884: 
53025:     if (top->isTypeKnown() && top->getKnownType() == JSVAL_TYPE_STRING) {
52884:         if (top->isConstant()) {
53081:             JSString *str = top->getValue().toString();
52884:             Value v;
52885:             v.setNumber(uint32(str->length()));
52884:             frame.pop();
52884:             frame.push(v);
52884:         } else {
52884:             RegisterID str = frame.ownRegForData(top);
53125:             masm.loadPtr(Address(str, offsetof(JSString, mLengthAndFlags)), str);
53125:             masm.rshiftPtr(Imm32(JSString::FLAGS_LENGTH_SHIFT), str);
52884:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_INT32, str);
52884:         }
52884:         return;
52884:     }
52884: 
53119: #if defined JS_POLYIC
52892:     jsop_getprop(cx->runtime->atomState.lengthAtom);
52884: #else
53087:     prepareStubCall(Uses(1));
53087:     stubCall(stubs::Length);
52884:     frame.pop();
52884:     frame.pushSynced();
52884: #endif
52884: }
52884: 
53119: #if defined JS_POLYIC
52880: void
52894: mjit::Compiler::jsop_getprop(JSAtom *atom, bool doTypeCheck)
52880: {
52880:     FrameEntry *top = frame.peek(-1);
52880: 
52884:     /* If the incoming type will never PIC, take slow path. */
53025:     if (top->isTypeKnown() && top->getKnownType() != JSVAL_TYPE_OBJECT) {
52892:         JS_ASSERT_IF(atom == cx->runtime->atomState.lengthAtom,
53025:                      top->getKnownType() != JSVAL_TYPE_STRING);
52880:         jsop_getprop_slow();
52880:         return;
52880:     }
52880: 
52884:     /*
52884:      * These two must be loaded first. The objReg because the string path
52884:      * wants to read it, and the shapeReg because it could cause a spill that
52884:      * the string path wouldn't sink back.
52884:      */
52884:     RegisterID objReg = Registers::ReturnReg;
52884:     RegisterID shapeReg = Registers::ReturnReg;
52892:     if (atom == cx->runtime->atomState.lengthAtom) {
52884:         objReg = frame.copyDataIntoReg(top);
52884:         shapeReg = frame.allocReg();
52884:     }
52884: 
52880:     PICGenInfo pic(ic::PICInfo::GET);
52880: 
52880:     /* Guard that the type is an object. */
52884:     Jump typeCheck;
52894:     if (doTypeCheck && !top->isTypeKnown()) {
52880:         RegisterID reg = frame.tempRegForType(top);
52884:         pic.typeReg = reg;
52884: 
52884:         /* Start the hot path where it's easy to patch it. */
53270:         pic.fastPathStart = masm.label();
53023:         Jump j = masm.testObject(Assembler::NotEqual, reg);
52884: 
53270:         /* GETPROP_INLINE_TYPE_GUARD is used to patch the jmp, not cmp. */
53270:         JS_ASSERT(masm.differenceBetween(pic.fastPathStart, masm.label()) == GETPROP_INLINE_TYPE_GUARD);
53270: 
53479:         pic.typeCheck = stubcc.linkExit(j, Uses(1));
52884:         pic.hasTypeCheck = true;
52884:     } else {
53270:         pic.fastPathStart = masm.label();
52884:         pic.hasTypeCheck = false;
52884:         pic.typeReg = Registers::ReturnReg;
52880:     }
52880: 
52892:     if (atom != cx->runtime->atomState.lengthAtom) {
52884:         objReg = frame.copyDataIntoReg(top);
52884:         shapeReg = frame.allocReg();
52884:     }
52884: 
52880:     pic.shapeReg = shapeReg;
52892:     pic.atom = atom;
52880:     pic.objRemat = frame.dataRematInfo(top);
52880: 
52880:     /* Guard on shape. */
53445:     masm.loadShape(objReg, shapeReg);
52880:     pic.shapeGuard = masm.label();
53270: 
53408:     DataLabel32 inlineShapeLabel;
53270:     Jump j = masm.branch32WithPatch(Assembler::NotEqual, shapeReg,
53270:                                     Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53315:                                     inlineShapeLabel);
53270:     DBGLABEL(dbgInlineShapeJump);
53270: 
53479:     pic.slowPathStart = stubcc.linkExit(j, Uses(1));
52880: 
52880:     stubcc.leave();
52880:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52880:     pic.callReturn = stubcc.call(ic::GetProp);
52880: 
52880:     /* Load dslots. */
53315: #if defined JS_NUNBOX32
53270:     DBGLABEL(dbgDslotsLoad);
53315: #elif defined JS_PUNBOX64
53315:     Label dslotsLoadLabel = masm.label();
53315: #endif
52880:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52880: 
52880:     /* Copy the slot value to the expression stack. */
52880:     Address slot(objReg, 1 << 24);
52880:     frame.pop();
53270: 
53315: #if defined JS_NUNBOX32
52880:     masm.loadTypeTag(slot, shapeReg);
53270:     DBGLABEL(dbgTypeLoad);
53270: 
53144:     masm.loadPayload(slot, objReg);
53270:     DBGLABEL(dbgDataLoad);
53315: #elif defined JS_PUNBOX64
53386:     Label inlineValueLoadLabel =
53386:         masm.loadValueAsComponents(slot, shapeReg, objReg);
53315: #endif
53270:     pic.storeBack = masm.label();
53270: 
53315: 
53270:     /* Assert correctness of hardcoded offsets. */
53315: #if defined JS_NUNBOX32
53270:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslotsLoad) == GETPROP_DSLOTS_LOAD);
53270:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgTypeLoad) == GETPROP_TYPE_LOAD);
53270:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDataLoad) == GETPROP_DATA_LOAD);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineShapeLabel) == GETPROP_INLINE_SHAPE_OFFSET);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineShapeJump) == GETPROP_INLINE_SHAPE_JUMP);
53315: #elif defined JS_PUNBOX64
53315:     pic.labels.getprop.dslotsLoadOffset = masm.differenceBetween(pic.storeBack, dslotsLoadLabel);
53426:     JS_ASSERT(pic.labels.getprop.dslotsLoadOffset == masm.differenceBetween(pic.storeBack, dslotsLoadLabel));
53426: 
53315:     pic.labels.getprop.inlineShapeOffset = masm.differenceBetween(pic.shapeGuard, inlineShapeLabel);
53426:     JS_ASSERT(pic.labels.getprop.inlineShapeOffset == masm.differenceBetween(pic.shapeGuard, inlineShapeLabel));
53426: 
53315:     pic.labels.getprop.inlineValueOffset = masm.differenceBetween(pic.storeBack, inlineValueLoadLabel);
53426:     JS_ASSERT(pic.labels.getprop.inlineValueOffset == masm.differenceBetween(pic.storeBack, inlineValueLoadLabel));
53426: 
53315:     JS_ASSERT(masm.differenceBetween(inlineShapeLabel, dbgInlineShapeJump) == GETPROP_INLINE_SHAPE_JUMP);
53315: #endif
53270:     /* GETPROP_INLINE_TYPE_GUARD's validity is asserted above. */
53270: 
52880:     pic.objReg = objReg;
52880:     frame.pushRegs(shapeReg, objReg);
52880: 
53088:     stubcc.rejoin(Changes(1));
52880: 
52880:     pics.append(pic);
52880: }
52880: 
53137: #ifdef JS_POLYIC
53137: void
53137: mjit::Compiler::jsop_getelem_pic(FrameEntry *obj, FrameEntry *id, RegisterID objReg,
53137:                                  RegisterID idReg, RegisterID shapeReg)
53137: {
53137:     PICGenInfo pic(ic::PICInfo::GETELEM);
53137: 
53137:     pic.objRemat = frame.dataRematInfo(obj);
53137:     pic.idRemat = frame.dataRematInfo(id);
53137:     pic.shapeReg = shapeReg;
53137:     pic.hasTypeCheck = false;
53137: 
53270:     pic.fastPathStart = masm.label();
53137: 
53137:     /* Guard on shape. */
53445:     masm.loadShape(objReg, shapeReg);
53137:     pic.shapeGuard = masm.label();
53315: 
53408:     DataLabel32 inlineShapeOffsetLabel;
53270:     Jump jmpShapeGuard = masm.branch32WithPatch(Assembler::NotEqual, shapeReg,
53270:                                  Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53315:                                  inlineShapeOffsetLabel);
53270:     DBGLABEL(dbgInlineShapeJump);
53137: 
53137:     /* Guard on id identity. */
53315: #if defined JS_NUNBOX32
53315:     static const void *BOGUS_ATOM = (void *)0xdeadbeef;
53315: #elif defined JS_PUNBOX64
53315:     static const void *BOGUS_ATOM = (void *)0xfeedfacedeadbeef;
53315: #endif
53315: 
53315:     DataLabelPtr inlineAtomOffsetLabel;
53315:     Jump idGuard = masm.branchPtrWithPatch(Assembler::NotEqual, idReg,
53315:                                  inlineAtomOffsetLabel, ImmPtr(BOGUS_ATOM));
53270:     DBGLABEL(dbgInlineAtomJump);
53270: 
53137:     stubcc.linkExit(idGuard, Uses(2));
53290:     pic.slowPathStart = stubcc.linkExit(jmpShapeGuard, Uses(2));
53137: 
53137:     stubcc.leave();
53137:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
53137:     pic.callReturn = stubcc.call(ic::GetElem);
53137: 
53137:     /* Load dslots. */
53315: #if defined JS_NUNBOX32
53270:     DBGLABEL(dbgDslotsLoad);
53315: #elif defined JS_PUNBOX64
53315:     Label dslotsLoadLabel = masm.label();
53315: #endif
53137:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
53137: 
53137:     /* Copy the slot value to the expression stack. */
53137:     Address slot(objReg, 1 << 24);
53315: #if defined JS_NUNBOX32
53137:     masm.loadTypeTag(slot, shapeReg);
53270:     DBGLABEL(dbgTypeLoad);
53144:     masm.loadPayload(slot, objReg);
53270:     DBGLABEL(dbgDataLoad);
53315: #elif defined JS_PUNBOX64
53386:     Label inlineValueOffsetLabel =
53386:         masm.loadValueAsComponents(slot, shapeReg, objReg);
53315: #endif
53137:     pic.storeBack = masm.label();
53315: 
53137:     pic.objReg = objReg;
53137:     pic.idReg = idReg;
53270: 
53315: #if defined JS_NUNBOX32
53270:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslotsLoad) == GETELEM_DSLOTS_LOAD);
53270:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgTypeLoad) == GETELEM_TYPE_LOAD);
53270:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDataLoad) == GETELEM_DATA_LOAD);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineAtomOffsetLabel) == GETELEM_INLINE_ATOM_OFFSET);
53270:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineAtomJump) == GETELEM_INLINE_ATOM_JUMP);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineShapeOffsetLabel) == GETELEM_INLINE_SHAPE_OFFSET);
53270:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineShapeJump) == GETELEM_INLINE_SHAPE_JUMP);
53315: #elif defined JS_PUNBOX64
53315:     pic.labels.getelem.dslotsLoadOffset = masm.differenceBetween(pic.storeBack, dslotsLoadLabel);
53426:     JS_ASSERT(pic.labels.getelem.dslotsLoadOffset == masm.differenceBetween(pic.storeBack, dslotsLoadLabel));
53426: 
53315:     pic.labels.getelem.inlineShapeOffset = masm.differenceBetween(pic.shapeGuard, inlineShapeOffsetLabel);
53426:     JS_ASSERT(pic.labels.getelem.inlineShapeOffset == masm.differenceBetween(pic.shapeGuard, inlineShapeOffsetLabel));
53426: 
53315:     pic.labels.getelem.inlineAtomOffset = masm.differenceBetween(pic.shapeGuard, inlineAtomOffsetLabel);
53426:     JS_ASSERT(pic.labels.getelem.inlineAtomOffset == masm.differenceBetween(pic.shapeGuard, inlineAtomOffsetLabel));
53426: 
53315:     pic.labels.getelem.inlineValueOffset = masm.differenceBetween(pic.storeBack, inlineValueOffsetLabel);
53426:     JS_ASSERT(pic.labels.getelem.inlineValueOffset == masm.differenceBetween(pic.storeBack, inlineValueOffsetLabel));
53426: 
53315:     JS_ASSERT(masm.differenceBetween(inlineShapeOffsetLabel, dbgInlineShapeJump) == GETELEM_INLINE_SHAPE_JUMP);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineAtomJump) ==
53315:               pic.labels.getelem.inlineAtomOffset + GETELEM_INLINE_ATOM_JUMP);
53315: #endif
53270: 
53137:     JS_ASSERT(pic.idReg != pic.objReg);
53137:     JS_ASSERT(pic.idReg != pic.shapeReg);
53137:     JS_ASSERT(pic.objReg != pic.shapeReg);
53270: 
53137:     pics.append(pic);
53137: }
53137: #endif
53137: 
52903: bool
52906: mjit::Compiler::jsop_callprop_generic(JSAtom *atom)
52906: {
52906:     FrameEntry *top = frame.peek(-1);
52906: 
52906:     /*
52906:      * These two must be loaded first. The objReg because the string path
52906:      * wants to read it, and the shapeReg because it could cause a spill that
52906:      * the string path wouldn't sink back.
52906:      */
52906:     RegisterID objReg = frame.copyDataIntoReg(top);
52906:     RegisterID shapeReg = frame.allocReg();
52906: 
52906:     PICGenInfo pic(ic::PICInfo::CALL);
52906: 
52906:     /* Guard that the type is an object. */
52906:     pic.typeReg = frame.copyTypeIntoReg(top);
52906: 
52906:     /* Start the hot path where it's easy to patch it. */
53270:     pic.fastPathStart = masm.label();
52906: 
52906:     /*
52906:      * Guard that the value is an object. This part needs some extra gunk
52906:      * because the leave() after the shape guard will emit a jump from this
52906:      * path to the final call. We need a label in between that jump, which
52906:      * will be the target of patched jumps in the PIC.
52906:      */
53023:     Jump typeCheck = masm.testObject(Assembler::NotEqual, pic.typeReg);
53307:     DBGLABEL(dbgInlineTypeGuard);
53307: 
53479:     pic.typeCheck = stubcc.linkExit(typeCheck, Uses(1));
52906:     pic.hasTypeCheck = true;
52906:     pic.objReg = objReg;
52906:     pic.shapeReg = shapeReg;
52906:     pic.atom = atom;
52906:     pic.objRemat = frame.dataRematInfo(top);
52906: 
52906:     /*
52906:      * Store the type and object back. Don't bother keeping them in registers,
52906:      * since a sync will be needed for the upcoming call.
52906:      */
52906:     uint32 thisvSlot = frame.frameDepth();
52906:     Address thisv = Address(JSFrameReg, sizeof(JSStackFrame) + thisvSlot * sizeof(Value));
53315: #if defined JS_NUNBOX32
52906:     masm.storeTypeTag(pic.typeReg, thisv);
53144:     masm.storePayload(pic.objReg, thisv);
53315: #elif defined JS_PUNBOX64
53315:     masm.orPtr(pic.objReg, pic.typeReg);
53315:     masm.storePtr(pic.typeReg, thisv);
53315: #endif
52906:     frame.freeReg(pic.typeReg);
52906: 
52906:     /* Guard on shape. */
53445:     masm.loadShape(objReg, shapeReg);
52906:     pic.shapeGuard = masm.label();
53307: 
53408:     DataLabel32 inlineShapeLabel;
53307:     Jump j = masm.branch32WithPatch(Assembler::NotEqual, shapeReg,
53307:                            Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53315:                            inlineShapeLabel);
53307:     DBGLABEL(dbgInlineShapeJump);
53307: 
53479:     pic.slowPathStart = stubcc.linkExit(j, Uses(1));
52906: 
52906:     /* Slow path. */
52906:     stubcc.leave();
52906:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52906:     pic.callReturn = stubcc.call(ic::CallProp);
52906: 
52906:     /* Adjust the frame. None of this will generate code. */
52906:     frame.pop();
52906:     frame.pushRegs(shapeReg, objReg);
52906:     frame.pushSynced();
52906: 
52906:     /* Load dslots. */
53315: #if defined JS_NUNBOX32
53307:     DBGLABEL(dbgDslotsLoad);
53315: #elif defined JS_PUNBOX64
53315:     Label dslotsLoadLabel = masm.label();
53315: #endif
52906:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52906: 
52906:     /* Copy the slot value to the expression stack. */
52906:     Address slot(objReg, 1 << 24);
53307: 
53315: #if defined JS_NUNBOX32
52906:     masm.loadTypeTag(slot, shapeReg);
53307:     DBGLABEL(dbgTypeLoad);
53307: 
53144:     masm.loadPayload(slot, objReg);
53307:     DBGLABEL(dbgDataLoad);
53315: #elif defined JS_PUNBOX64
53386:     Label inlineValueLoadLabel =
53386:         masm.loadValueAsComponents(slot, shapeReg, objReg);
53315: #endif
52906:     pic.storeBack = masm.label();
52906: 
53307:     /* Assert correctness of hardcoded offsets. */
53315:     JS_ASSERT(masm.differenceBetween(pic.fastPathStart, dbgInlineTypeGuard) == GETPROP_INLINE_TYPE_GUARD);
53315: #if defined JS_NUNBOX32
53307:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslotsLoad) == GETPROP_DSLOTS_LOAD);
53307:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgTypeLoad) == GETPROP_TYPE_LOAD);
53307:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDataLoad) == GETPROP_DATA_LOAD);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineShapeLabel) == GETPROP_INLINE_SHAPE_OFFSET);
53307:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineShapeJump) == GETPROP_INLINE_SHAPE_JUMP);
53315: #elif defined JS_PUNBOX64
53315:     pic.labels.getprop.dslotsLoadOffset = masm.differenceBetween(pic.storeBack, dslotsLoadLabel);
53426:     JS_ASSERT(pic.labels.getprop.dslotsLoadOffset == masm.differenceBetween(pic.storeBack, dslotsLoadLabel));
53426: 
53315:     pic.labels.getprop.inlineShapeOffset = masm.differenceBetween(pic.shapeGuard, inlineShapeLabel);
53426:     JS_ASSERT(pic.labels.getprop.inlineShapeOffset == masm.differenceBetween(pic.shapeGuard, inlineShapeLabel));
53426: 
53315:     pic.labels.getprop.inlineValueOffset = masm.differenceBetween(pic.storeBack, inlineValueLoadLabel);
53426:     JS_ASSERT(pic.labels.getprop.inlineValueOffset == masm.differenceBetween(pic.storeBack, inlineValueLoadLabel));
53426: 
53315:     JS_ASSERT(masm.differenceBetween(inlineShapeLabel, dbgInlineShapeJump) == GETPROP_INLINE_SHAPE_JUMP);
53315: #endif
53307: 
53088:     stubcc.rejoin(Changes(2));
52906:     pics.append(pic);
52906: 
52906:     return true;
52906: }
52906: 
52906: bool
52903: mjit::Compiler::jsop_callprop_str(JSAtom *atom)
52903: {
52903:     if (!script->compileAndGo) {
52903:         jsop_callprop_slow(atom);
52903:         return true; 
52903:     }
52903: 
52903:     /* Bake in String.prototype. Is this safe? */
52903:     JSObject *obj;
52903:     if (!js_GetClassPrototype(cx, NULL, JSProto_String, &obj))
52903:         return false;
52903: 
52903:     /* Force into a register because getprop won't expect a constant. */
52903:     RegisterID reg = frame.allocReg();
52903:     masm.move(ImmPtr(obj), reg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, reg);
52903: 
52903:     /* Get the property. */
52903:     jsop_getprop(atom);
52903: 
52903:     /* Perform a swap. */
52903:     frame.dup2();
52903:     frame.shift(-3);
52903:     frame.shift(-1);
52903: 
52903:     /* 4) Test if the function can take a primitive. */
52903:     FrameEntry *funFe = frame.peek(-2);
52903:     JS_ASSERT(!funFe->isTypeKnown());
52903: 
53374:     /*
53374:      * See bug 584579 - need to forget string type, since wrapping could
53374:      * create an object. forgetType() alone is not valid because it cannot be
53374:      * used on copies or constants.
53374:      */
53374:     RegisterID strReg;
53374:     FrameEntry *strFe = frame.peek(-1);
53374:     if (strFe->isConstant()) {
53374:         strReg = frame.allocReg();
53374:         masm.move(ImmPtr(strFe->getValue().toString()), strReg);
53374:     } else {
53374:         strReg = frame.ownRegForData(strFe);
53374:     }
53374:     frame.pop();
53374:     frame.pushTypedPayload(JSVAL_TYPE_STRING, strReg);
53374:     frame.forgetType(frame.peek(-1));
53374: 
52903:     RegisterID temp = frame.allocReg();
53023:     RegisterID funReg = frame.copyDataIntoReg(funFe);
53023:     Jump notFun1 = frame.testObject(Assembler::NotEqual, funFe);
53023:     Jump notFun2 = masm.testFunction(Assembler::NotEqual, funReg);
53023: 
53157:     masm.loadFunctionPrivate(funReg, temp);
52903:     masm.load16(Address(temp, offsetof(JSFunction, flags)), temp);
52903:     masm.and32(Imm32(JSFUN_THISP_STRING), temp);
52903:     Jump noPrim = masm.branchTest32(Assembler::Zero, temp, temp);
52903:     {
53374:         stubcc.linkExit(noPrim, Uses(2));
52903:         stubcc.leave();
52903:         stubcc.call(stubs::WrapPrimitiveThis);
52903:     }
52903: 
53023:     frame.freeReg(funReg);
52903:     frame.freeReg(temp);
53023:     notFun2.linkTo(masm.label(), &masm);
53023:     notFun1.linkTo(masm.label(), &masm);
52903:     
53374:     stubcc.rejoin(Changes(1));
52903: 
52903:     return true;
52903: }
52903: 
52903: bool
52896: mjit::Compiler::jsop_callprop_obj(JSAtom *atom)
52896: {
52896:     FrameEntry *top = frame.peek(-1);
52896: 
52896:     PICGenInfo pic(ic::PICInfo::CALL);
52896: 
52896:     JS_ASSERT(top->isTypeKnown());
53025:     JS_ASSERT(top->getKnownType() == JSVAL_TYPE_OBJECT);
52896: 
53270:     pic.fastPathStart = masm.label();
52896:     pic.hasTypeCheck = false;
52896:     pic.typeReg = Registers::ReturnReg;
52896: 
52896:     RegisterID objReg = frame.copyDataIntoReg(top);
52896:     RegisterID shapeReg = frame.allocReg();
52896: 
52896:     pic.shapeReg = shapeReg;
52896:     pic.atom = atom;
52896:     pic.objRemat = frame.dataRematInfo(top);
52896: 
52896:     /* Guard on shape. */
53445:     masm.loadShape(objReg, shapeReg);
52896:     pic.shapeGuard = masm.label();
53307: 
53408:     DataLabel32 inlineShapeLabel;
53307:     Jump j = masm.branch32WithPatch(Assembler::NotEqual, shapeReg,
53307:                            Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53315:                            inlineShapeLabel);
53307:     DBGLABEL(dbgInlineShapeJump);
53307: 
52896:     pic.slowPathStart = stubcc.masm.label();
53088:     stubcc.linkExit(j, Uses(1));
52896: 
52896:     stubcc.leave();
52896:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52896:     pic.callReturn = stubcc.call(ic::CallProp);
52896: 
52896:     /* Load dslots. */
53315: #if defined JS_NUNBOX32
53307:     DBGLABEL(dbgDslotsLoad);
53315: #elif defined JS_PUNBOX64
53315:     Label dslotsLoadLabel = masm.label();
53315: #endif
52896:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52896: 
52896:     /* Copy the slot value to the expression stack. */
52896:     Address slot(objReg, 1 << 24);
53307: 
53315: #if defined JS_NUNBOX32
52896:     masm.loadTypeTag(slot, shapeReg);
53307:     DBGLABEL(dbgTypeLoad);
53307: 
53144:     masm.loadPayload(slot, objReg);
53307:     DBGLABEL(dbgDataLoad);
53315: #elif defined JS_PUNBOX64
53386:     Label inlineValueLoadLabel =
53386:         masm.loadValueAsComponents(slot, shapeReg, objReg);
53315: #endif
53307: 
53307:     pic.storeBack = masm.label();
52896:     pic.objReg = objReg;
52896: 
52896:     /*
52896:      * 1) Dup the |this| object.
52896:      * 2) Push the property value onto the stack.
52896:      * 3) Move the value below the dup'd |this|, uncopying it. This could
52896:      * generate code, thus the storeBack label being prior. This is safe
52896:      * as a stack transition, because JSOP_CALLPROP has JOF_TMPSLOT. It is
52896:      * also safe for correctness, because if we know the LHS is an object, it
52896:      * is the resulting vp[1].
52896:      */
52896:     frame.dup();
52896:     frame.pushRegs(shapeReg, objReg);
52896:     frame.shift(-2);
52896: 
53315:     /* 
53315:      * Assert correctness of hardcoded offsets.
53315:      * No type guard: type is asserted.
53315:      */
53315: #if defined JS_NUNBOX32
53307:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslotsLoad) == GETPROP_DSLOTS_LOAD);
53307:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgTypeLoad) == GETPROP_TYPE_LOAD);
53307:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDataLoad) == GETPROP_DATA_LOAD);
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineShapeLabel) == GETPROP_INLINE_SHAPE_OFFSET);
53307:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineShapeJump) == GETPROP_INLINE_SHAPE_JUMP);
53315: #elif defined JS_PUNBOX64
53315:     pic.labels.getprop.dslotsLoadOffset = masm.differenceBetween(pic.storeBack, dslotsLoadLabel);
53426:     JS_ASSERT(pic.labels.getprop.dslotsLoadOffset == masm.differenceBetween(pic.storeBack, dslotsLoadLabel));
53426: 
53315:     pic.labels.getprop.inlineShapeOffset = masm.differenceBetween(pic.shapeGuard, inlineShapeLabel);
53426:     JS_ASSERT(pic.labels.getprop.inlineShapeOffset == masm.differenceBetween(pic.shapeGuard, inlineShapeLabel));
53426: 
53315:     pic.labels.getprop.inlineValueOffset = masm.differenceBetween(pic.storeBack, inlineValueLoadLabel);
53426:     JS_ASSERT(pic.labels.getprop.inlineValueOffset == masm.differenceBetween(pic.storeBack, inlineValueLoadLabel));
53426: 
53315:     JS_ASSERT(masm.differenceBetween(inlineShapeLabel, dbgInlineShapeJump) == GETPROP_INLINE_SHAPE_JUMP);
53315: #endif
53307: 
53088:     stubcc.rejoin(Changes(2));
52896:     pics.append(pic);
52903: 
52903:     return true;
52896: }
52896: 
52903: bool
52896: mjit::Compiler::jsop_callprop(JSAtom *atom)
52896: {
52896:     FrameEntry *top = frame.peek(-1);
52896: 
52896:     /* If the incoming type will never PIC, take slow path. */
53025:     if (top->isTypeKnown() && top->getKnownType() != JSVAL_TYPE_OBJECT) {
53025:         if (top->getKnownType() == JSVAL_TYPE_STRING)
52903:             return jsop_callprop_str(atom);
52903:         return jsop_callprop_slow(atom);
52896:     }
52896: 
52896:     if (top->isTypeKnown())
52903:         return jsop_callprop_obj(atom);
52906:     return jsop_callprop_generic(atom);
52896: }
52896: 
52896: void
52892: mjit::Compiler::jsop_setprop(JSAtom *atom)
52886: {
52887:     FrameEntry *lhs = frame.peek(-2);
52887:     FrameEntry *rhs = frame.peek(-1);
52887: 
52887:     /* If the incoming type will never PIC, take slow path. */
53025:     if (lhs->isTypeKnown() && lhs->getKnownType() != JSVAL_TYPE_OBJECT) {
52892:         jsop_setprop_slow(atom);
52887:         return;
52887:     }
52887: 
52887:     PICGenInfo pic(ic::PICInfo::SET);
52892:     pic.atom = atom;
52887: 
52887:     /* Guard that the type is an object. */
52887:     Jump typeCheck;
52887:     if (!lhs->isTypeKnown()) {
52887:         RegisterID reg = frame.tempRegForType(lhs);
52887:         pic.typeReg = reg;
52887: 
52887:         /* Start the hot path where it's easy to patch it. */
53270:         pic.fastPathStart = masm.label();
53025:         Jump j = masm.testObject(Assembler::NotEqual, reg);
52887: 
52887:         pic.typeCheck = stubcc.masm.label();
53088:         stubcc.linkExit(j, Uses(2));
52887:         stubcc.leave();
53492: 
53492:         /*
53492:          * This gets called from PROPINC/PROPDEC which aren't compatible with
53492:          * the normal SETNAME property cache logic.
53492:          */
53492:         JSOp op = JSOp(*PC);
53492:         if (op == JSOP_SETNAME || op == JSOP_SETPROP || op == JSOP_SETGNAME || op ==
53492:             JSOP_SETMETHOD) {
52892:             stubcc.masm.move(ImmPtr(atom), Registers::ArgReg1);
52887:             stubcc.call(stubs::SetName);
53492:         } else {
53492:             stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
53492:             stubcc.call(ic::SetPropDumb);
53492:         }
53492: 
52887:         typeCheck = stubcc.masm.jump();
52887:         pic.hasTypeCheck = true;
52887:     } else {
53270:         pic.fastPathStart = masm.label();
52887:         pic.hasTypeCheck = false;
52887:         pic.typeReg = Registers::ReturnReg;
52887:     }
52887: 
52887:     /* Get the object into a mutable register. */
52887:     RegisterID objReg = frame.copyDataIntoReg(lhs);
52887:     pic.objReg = objReg;
52887: 
52887:     /* Get info about the RHS and pin it. */
52887:     ValueRemat vr;
52887:     if (rhs->isConstant()) {
52887:         vr.isConstant = true;
52887:         vr.u.v = Jsvalify(rhs->getValue());
52887:     } else {
52887:         vr.isConstant = false;
52887:         vr.u.s.isTypeKnown = rhs->isTypeKnown();
52887:         if (vr.u.s.isTypeKnown) {
53144:             vr.u.s.type.knownType = rhs->getKnownType();
52887:         } else {
52887:             vr.u.s.type.reg = frame.tempRegForType(rhs);
52887:             frame.pinReg(vr.u.s.type.reg);
52887:         }
52887:         vr.u.s.data = frame.tempRegForData(rhs);
52887:         frame.pinReg(vr.u.s.data);
52887:     }
52887:     pic.vr = vr;
52887: 
52887:     RegisterID shapeReg = frame.allocReg();
52887:     pic.shapeReg = shapeReg;
52887:     pic.objRemat = frame.dataRematInfo(lhs);
52887: 
52887:     if (!vr.isConstant) {
52887:         if (!vr.u.s.isTypeKnown)
52887:             frame.unpinReg(vr.u.s.type.reg);
52887:         frame.unpinReg(vr.u.s.data);
52887:     }
52887: 
52887:     /* Guard on shape. */
53445:     masm.loadShape(objReg, shapeReg);
52887:     pic.shapeGuard = masm.label();
53408:     DataLabel32 inlineShapeOffsetLabel;
53270:     Jump j = masm.branch32WithPatch(Assembler::NotEqual, shapeReg,
53270:                                     Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53315:                                     inlineShapeOffsetLabel);
53270:     DBGLABEL(dbgInlineShapeJump);
52887: 
52887:     /* Slow path. */
52887:     {
52887:         pic.slowPathStart = stubcc.masm.label();
53088:         stubcc.linkExit(j, Uses(2));
52887: 
52887:         stubcc.leave();
52887:         stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52887:         pic.callReturn = stubcc.call(ic::SetProp);
52887:     }
52887: 
52887:     /* Load dslots. */
53315: #if defined JS_NUNBOX32
53270:     DBGLABEL(dbgDslots);
53315: #elif defined JS_PUNBOX64
53315:     Label dslotsLoadLabel = masm.label();
53315: #endif
52887:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52887: 
52887:     /* Store RHS into object slot. */
53315:     Address slot(objReg, 1 << 24);
53315: #if defined JS_NUNBOX32
53270:     Label dbgInlineStoreType;
53270:     DBGLABEL(dbgInlineStoreData);
53270: 
52887:     if (vr.isConstant) {
53275:         dbgInlineStoreType = masm.storeValueForIC(Valueify(vr.u.v), slot);
53270:         DBGLABEL_ASSIGN(dbgInlineStoreData);
52887:     } else {
53270:         if (vr.u.s.isTypeKnown) {
53144:             masm.storeTypeTag(ImmType(vr.u.s.type.knownType), slot);
53270:             DBGLABEL_ASSIGN(dbgInlineStoreType);
53270:         } else {
52887:             masm.storeTypeTag(vr.u.s.type.reg, slot);
53270:             DBGLABEL_ASSIGN(dbgInlineStoreType);
53270:         }
53144:         masm.storePayload(vr.u.s.data, slot);
53270:         DBGLABEL_ASSIGN(dbgInlineStoreData);
52887:     }
53315: #elif defined JS_PUNBOX64
53315:     if (vr.isConstant) {
53315:         masm.storeValueForIC(Valueify(vr.u.v), slot);
53315:     } else {
53315:         if (vr.u.s.isTypeKnown)
53315:             masm.move(ImmType(vr.u.s.type.knownType), Registers::ValueReg);
53315:         else
53315:             masm.move(vr.u.s.type.reg, Registers::ValueReg);
53315:         masm.orPtr(vr.u.s.data, Registers::ValueReg);
53315:         masm.storePtr(Registers::ValueReg, slot);
53315:     }
53315:     DBGLABEL(dbgInlineStoreValue);
53315: #endif
53315:     pic.storeBack = masm.label();
53315: 
52887:     frame.freeReg(objReg);
52887:     frame.freeReg(shapeReg);
52887: 
52887:     /* "Pop under", taking out object (LHS) and leaving RHS. */
52887:     frame.shimmy(1);
52887: 
52887:     /* Finish slow path. */
52887:     {
52887:         if (pic.hasTypeCheck)
52887:             typeCheck.linkTo(stubcc.masm.label(), &stubcc.masm);
53088:         stubcc.rejoin(Changes(1));
52887:     }
52887: 
53315: #if defined JS_PUNBOX64
53315:     pic.labels.setprop.dslotsLoadOffset = masm.differenceBetween(pic.storeBack, dslotsLoadLabel);
53315:     pic.labels.setprop.inlineShapeOffset = masm.differenceBetween(pic.shapeGuard, inlineShapeOffsetLabel);
53315:     JS_ASSERT(masm.differenceBetween(inlineShapeOffsetLabel, dbgInlineShapeJump) == SETPROP_INLINE_SHAPE_JUMP);
53315:     JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreValue) == SETPROP_INLINE_STORE_VALUE);
53315: #elif defined JS_NUNBOX32
53315:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineShapeOffsetLabel) == SETPROP_INLINE_SHAPE_OFFSET);
53270:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, dbgInlineShapeJump) == SETPROP_INLINE_SHAPE_JUMP);
53270:     if (vr.isConstant) {
53270:         /* Constants are offset inside the opcode by 4. */
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreType)-4 == SETPROP_INLINE_STORE_CONST_TYPE);
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreData)-4 == SETPROP_INLINE_STORE_CONST_DATA);
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslots) == SETPROP_DSLOTS_BEFORE_CONSTANT);
53315:     } else if (vr.u.s.isTypeKnown) {
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreType)-4 == SETPROP_INLINE_STORE_KTYPE_TYPE);
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreData) == SETPROP_INLINE_STORE_KTYPE_DATA);
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslots) == SETPROP_DSLOTS_BEFORE_KTYPE);
53270:     } else {
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreType) == SETPROP_INLINE_STORE_DYN_TYPE);
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgInlineStoreData) == SETPROP_INLINE_STORE_DYN_DATA);
53270:         JS_ASSERT(masm.differenceBetween(pic.storeBack, dbgDslots) == SETPROP_DSLOTS_BEFORE_DYNAMIC);
53270:     }
53270: #endif
53270: 
52887:     pics.append(pic);
52886: }
52886: 
53054: void
53054: mjit::Compiler::jsop_name(JSAtom *atom)
53054: {
53054:     PICGenInfo pic(ic::PICInfo::NAME);
53054: 
53054:     pic.shapeReg = frame.allocReg();
53054:     pic.objReg = frame.allocReg();
53054:     pic.typeReg = Registers::ReturnReg;
53054:     pic.atom = atom;
53054:     pic.hasTypeCheck = false;
53270:     pic.fastPathStart = masm.label();
53054: 
53054:     pic.shapeGuard = masm.label();
53054:     Jump j = masm.jump();
53270:     DBGLABEL(dbgJumpOffset);
53054:     {
53054:         pic.slowPathStart = stubcc.masm.label();
53421:         stubcc.linkExitDirect(j, pic.slowPathStart);
53421:         frame.sync(stubcc.masm, Uses(0));
53054:         stubcc.leave();
53054:         stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
53054:         pic.callReturn = stubcc.call(ic::Name);
53054:     }
53054: 
53054:     pic.storeBack = masm.label();
53054:     frame.pushRegs(pic.shapeReg, pic.objReg);
53054: 
53270:     JS_ASSERT(masm.differenceBetween(pic.fastPathStart, dbgJumpOffset) == SCOPENAME_JUMP_OFFSET);
53270: 
53088:     stubcc.rejoin(Changes(1));
53054: 
53054:     pics.append(pic);
53054: }
53054: 
53055: void
53055: mjit::Compiler::jsop_bindname(uint32 index)
53055: {
53055:     PICGenInfo pic(ic::PICInfo::BIND);
53055: 
53055:     pic.shapeReg = frame.allocReg();
53055:     pic.objReg = frame.allocReg();
53055:     pic.typeReg = Registers::ReturnReg;
53055:     pic.atom = script->getAtom(index);
53055:     pic.hasTypeCheck = false;
53270:     pic.fastPathStart = masm.label();
53055: 
53244:     Address parent(pic.objReg, offsetof(JSObject, parent));
53435:     masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetScopeChain()), pic.objReg);
53055: 
53055:     pic.shapeGuard = masm.label();
53224: #if defined JS_NUNBOX32
53055:     Jump j = masm.branchPtr(Assembler::NotEqual, masm.payloadOf(parent), ImmPtr(0));
53317:     DBGLABEL(inlineJumpOffset);
53224: #elif defined JS_PUNBOX64
53162:     masm.loadPayload(parent, Registers::ValueReg);
53162:     Jump j = masm.branchPtr(Assembler::NotEqual, Registers::ValueReg, ImmPtr(0));
53317:     Label inlineJumpOffset = masm.label();
53162: #endif
53055:     {
53055:         pic.slowPathStart = stubcc.masm.label();
53088:         stubcc.linkExit(j, Uses(0));
53055:         stubcc.leave();
53055:         stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
53055:         pic.callReturn = stubcc.call(ic::BindName);
53055:     }
53055: 
53055:     pic.storeBack = masm.label();
53055:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, pic.objReg);
53055:     frame.freeReg(pic.shapeReg);
53055: 
53317: #if defined JS_NUNBOX32
53317:     JS_ASSERT(masm.differenceBetween(pic.shapeGuard, inlineJumpOffset) == BINDNAME_INLINE_JUMP_OFFSET);
53317: #elif defined JS_PUNBOX64
53317:     pic.labels.bindname.inlineJumpOffset = masm.differenceBetween(pic.shapeGuard, inlineJumpOffset);
53426:     JS_ASSERT(pic.labels.bindname.inlineJumpOffset == masm.differenceBetween(pic.shapeGuard, inlineJumpOffset));
53317: #endif
53270: 
53088:     stubcc.rejoin(Changes(1));
53055: 
53055:     pics.append(pic);
53055: }
53055: 
53119: #else /* JS_POLYIC */
52880: 
52880: void
53054: mjit::Compiler::jsop_name(JSAtom *atom)
53054: {
53087:     prepareStubCall(Uses(0));
53087:     stubCall(stubs::Name);
53054:     frame.pushSynced();
53054: }
53054: 
53054: void
52894: mjit::Compiler::jsop_getprop(JSAtom *atom, bool typecheck)
52880: {
52892:     jsop_getprop_slow();
52886: }
52886: 
53119: bool
52896: mjit::Compiler::jsop_callprop(JSAtom *atom)
52896: {
53119:     return jsop_callprop_slow(atom);
52896: }
52896: 
52896: void
52892: mjit::Compiler::jsop_setprop(JSAtom *atom)
52886: {
52892:     jsop_setprop_slow(atom);
52880: }
53055: 
53055: void
53055: mjit::Compiler::jsop_bindname(uint32 index)
53055: {
53055:     RegisterID reg = frame.allocReg();
53435:     Address scopeChain(JSFrameReg, JSStackFrame::offsetScopeChain());
53162:     masm.loadPtr(scopeChain, reg);
53055: 
53246:     Address address(reg, offsetof(JSObject, parent));
53246: 
53055:     Jump j = masm.branchPtr(Assembler::NotEqual, masm.payloadOf(address), ImmPtr(0));
53055: 
53088:     stubcc.linkExit(j, Uses(0));
53055:     stubcc.leave();
53055:     stubcc.call(stubs::BindName);
53055: 
53055:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, reg);
53055: 
53088:     stubcc.rejoin(Changes(1));
53055: }
52880: #endif
52880: 
52743: void
52741: mjit::Compiler::jsop_getarg(uint32 index)
52741: {
52741:     RegisterID reg = frame.allocReg();
52829:     masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, argv)), reg);
52741:     frame.freeReg(reg);
52741:     frame.push(Address(reg, index * sizeof(Value)));
52741: }
52741: 
52741: void
52741: mjit::Compiler::jsop_this()
52741: {
53440:     Address thisvAddr(JSFrameReg, JSStackFrame::offsetThisValue());
53023:     if (0 && !script->strictModeCode) {
53023:         Jump null = masm.testNull(Assembler::Equal, thisvAddr);
53088:         stubcc.linkExit(null, Uses(1));
53023:         stubcc.leave();
53023:         stubcc.call(stubs::ComputeThis);
53088:         stubcc.rejoin(Changes(1));
53023: 
53023:         RegisterID reg = frame.allocReg();
53144:         masm.loadPayload(thisvAddr, reg);
53025:         frame.pushTypedPayload(JSVAL_TYPE_OBJECT, reg);
53023:     } else {
53023:         frame.push(thisvAddr);
53023:         Jump null = frame.testNull(Assembler::Equal, frame.peek(-1));
53088:         stubcc.linkExit(null, Uses(1));
52854:         stubcc.leave();
52854:         stubcc.call(stubs::This);
53088:         stubcc.rejoin(Changes(1));
52741:     }
53023: }
52741: 
52741: void
53118: mjit::Compiler::jsop_gnameinc(JSOp op, VoidStubAtom stub, uint32 index)
52732: {
52732:     JSAtom *atom = script->getAtom(index);
53511: #if defined JS_MONOIC
53511:     jsbytecode *next = &PC[JSOP_GNAMEINC_LENGTH];
53511:     bool pop = (JSOp(*next) == JSOP_POP) && !analysis[next].nincoming;
53511:     int amt = (op == JSOP_GNAMEINC || op == JSOP_INCGNAME) ? -1 : 1;
53511: 
53511:     if (pop || (op == JSOP_INCGNAME || op == JSOP_DECGNAME)) {
53511:         /* These cases are easy, the original value is not observed. */
53511: 
53511:         jsop_getgname(index);
53511:         // V
53511: 
53511:         frame.push(Int32Value(amt));
53511:         // V 1
53511: 
53511:         /* Use sub since it calls ValueToNumber instead of string concat. */
53511:         jsop_binary(JSOP_SUB, stubs::Sub);
53511:         // N+1
53511: 
53511:         jsop_bindgname();
53511:         // V+1 OBJ
53511: 
53511:         frame.dup2();
53511:         // V+1 OBJ V+1 OBJ
53511: 
53511:         frame.shift(-3);
53511:         // OBJ OBJ V+1
53511: 
53511:         frame.shift(-1);
53511:         // OBJ V+1
53511: 
53511:         jsop_setgname(index);
53511:         // V+1
53511: 
53511:         if (pop)
53511:             frame.pop();
53511:     } else {
53511:         /* The pre-value is observed, making this more tricky. */
53511: 
53511:         jsop_getgname(index);
53511:         // V
53511: 
53511:         jsop_pos();
53511:         // N
53511: 
53511:         frame.dup();
53511:         // N N
53511: 
53511:         frame.push(Int32Value(-amt));
53511:         // N N 1
53511: 
53511:         jsop_binary(JSOP_ADD, stubs::Add);
53511:         // N N+1
53511: 
53511:         jsop_bindgname();
53511:         // N N+1 OBJ
53511: 
53511:         frame.dup2();
53511:         // N N+1 OBJ N+1 OBJ
53511: 
53511:         frame.shift(-3);
53511:         // N OBJ OBJ N+1
53511: 
53511:         frame.shift(-1);
53511:         // N OBJ N+1
53511: 
53511:         jsop_setgname(index);
53511:         // N N+1
53511: 
53511:         frame.pop();
53511:         // N
53511:     }
53511: 
53511:     if (pop)
53511:         PC += JSOP_POP_LENGTH;
53511: #else
53087:     prepareStubCall(Uses(0));
52732:     masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:     stubCall(stub);
52732:     frame.pushSynced();
53511: #endif
53511: 
53511:     PC += JSOP_GNAMEINC_LENGTH;
52732: }
52732: 
52746: void
53118: mjit::Compiler::jsop_nameinc(JSOp op, VoidStubAtom stub, uint32 index)
53118: {
53118:     JSAtom *atom = script->getAtom(index);
53119: #if defined JS_POLYIC
53118:     jsbytecode *next = &PC[JSOP_NAMEINC_LENGTH];
53118:     bool pop = (JSOp(*next) == JSOP_POP) && !analysis[next].nincoming;
53118:     int amt = (op == JSOP_NAMEINC || op == JSOP_INCNAME) ? -1 : 1;
53118: 
53118:     if (pop || (op == JSOP_INCNAME || op == JSOP_DECNAME)) {
53118:         /* These cases are easy, the original value is not observed. */
53118: 
53118:         jsop_name(atom);
53118:         // V
53118: 
53118:         frame.push(Int32Value(amt));
53118:         // V 1
53118: 
53118:         /* Use sub since it calls ValueToNumber instead of string concat. */
53118:         jsop_binary(JSOP_SUB, stubs::Sub);
53118:         // N+1
53118: 
53118:         jsop_bindname(index);
53118:         // V+1 OBJ
53118: 
53118:         frame.dup2();
53118:         // V+1 OBJ V+1 OBJ
53118: 
53118:         frame.shift(-3);
53118:         // OBJ OBJ V+1
53118: 
53118:         frame.shift(-1);
53118:         // OBJ V+1
53118: 
53118:         jsop_setprop(atom);
53118:         // V+1
53118: 
53118:         if (pop)
53118:             frame.pop();
53118:     } else {
53118:         /* The pre-value is observed, making this more tricky. */
53118: 
53118:         jsop_name(atom);
53118:         // V
53118: 
53118:         jsop_pos();
53118:         // N
53118: 
53118:         frame.dup();
53118:         // N N
53118: 
53118:         frame.push(Int32Value(-amt));
53118:         // N N 1
53118: 
53118:         jsop_binary(JSOP_ADD, stubs::Add);
53118:         // N N+1
53118: 
53118:         jsop_bindname(index);
53118:         // N N+1 OBJ
53118: 
53118:         frame.dup2();
53118:         // N N+1 OBJ N+1 OBJ
53118: 
53118:         frame.shift(-3);
53118:         // N OBJ OBJ N+1
53118: 
53118:         frame.shift(-1);
53118:         // N OBJ N+1
53118: 
53118:         jsop_setprop(atom);
53118:         // N N+1
53118: 
53118:         frame.pop();
53118:         // N
53118:     }
53119: 
53119:     if (pop)
53119:         PC += JSOP_POP_LENGTH;
53118: #else
53122:     prepareStubCall(Uses(0));
53118:     masm.move(ImmPtr(atom), Registers::ArgReg1);
53118:     stubCall(stub);
53118:     frame.pushSynced();
53118: #endif
53118: 
53118:     PC += JSOP_NAMEINC_LENGTH;
53118: }
53118: 
53118: void
52746: mjit::Compiler::jsop_propinc(JSOp op, VoidStubAtom stub, uint32 index)
52746: {
52746:     JSAtom *atom = script->getAtom(index);
53119: #if defined JS_POLYIC
53172:     FrameEntry *objFe = frame.peek(-1);
53172:     if (!objFe->isTypeKnown() || objFe->getKnownType() == JSVAL_TYPE_OBJECT) {
52916:         jsbytecode *next = &PC[JSOP_PROPINC_LENGTH];
52916:         bool pop = (JSOp(*next) == JSOP_POP) && !analysis[next].nincoming;
52916:         int amt = (op == JSOP_PROPINC || op == JSOP_INCPROP) ? -1 : 1;
52916: 
52916:         if (pop || (op == JSOP_INCPROP || op == JSOP_DECPROP)) {
52916:             /* These cases are easy, the original value is not observed. */
52916: 
52916:             frame.dup();
52916:             // OBJ OBJ
52916: 
52916:             jsop_getprop(atom);
52916:             // OBJ V
52916: 
53081:             frame.push(Int32Value(amt));
52916:             // OBJ V 1
52916: 
52916:             /* Use sub since it calls ValueToNumber instead of string concat. */
52916:             jsop_binary(JSOP_SUB, stubs::Sub);
52916:             // OBJ V+1
52916: 
52916:             jsop_setprop(atom);
52916:             // V+1
52916: 
52916:             if (pop)
52916:                 frame.pop();
52916:         } else {
52916:             /* The pre-value is observed, making this more tricky. */
52916: 
52916:             frame.dup();
52916:             // OBJ OBJ 
52916: 
52916:             jsop_getprop(atom);
52916:             // OBJ V
52916: 
52916:             jsop_pos();
52916:             // OBJ N
52916: 
52916:             frame.dup();
52916:             // OBJ N N
52916: 
53081:             frame.push(Int32Value(-amt));
52916:             // OBJ N N 1
52916: 
52916:             jsop_binary(JSOP_ADD, stubs::Add);
52916:             // OBJ N N+1
52916: 
52916:             frame.dupAt(-3);
52916:             // OBJ N N+1 OBJ
52916: 
52916:             frame.dupAt(-2);
52916:             // OBJ N N+1 OBJ N+1
52916: 
52916:             jsop_setprop(atom);
52916:             // OBJ N N+1 N+1
52916: 
52916:             frame.popn(2);
52916:             // OBJ N
52916: 
52916:             frame.shimmy(1);
52916:             // N
52916:         }
53119:         if (pop)
53119:             PC += JSOP_POP_LENGTH;
53172:     } else
53173: #endif
53172:     {
53087:         prepareStubCall(Uses(1));
52746:         masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:         stubCall(stub);
52746:         frame.pop();
52746:         frame.pushSynced();
53172:     }
52916: 
52916:     PC += JSOP_PROPINC_LENGTH;
52746: }
52746: 
53404: void
53404: mjit::Compiler::iter(uintN flags)
53404: {
53404:     FrameEntry *fe = frame.peek(-1);
53404: 
53404:     /*
53404:      * Stub the call if this is not a simple 'for in' loop or if the iterated
53404:      * value is known to not be an object.
53404:      */
53404:     if ((flags != JSITER_ENUMERATE) || fe->isNotType(JSVAL_TYPE_OBJECT)) {
53404:         prepareStubCall(Uses(1));
53404:         masm.move(Imm32(flags), Registers::ArgReg1);
53404:         stubCall(stubs::Iter);
53404:         frame.pop();
53404:         frame.pushSynced();
53404:         return;
53404:     }
53404: 
53404:     if (!fe->isTypeKnown()) {
53404:         Jump notObject = frame.testObject(Assembler::NotEqual, fe);
53404:         stubcc.linkExit(notObject, Uses(1));
53404:     }
53404: 
53404:     RegisterID reg = frame.tempRegForData(fe);
53404: 
53404:     frame.pinReg(reg);
53404:     RegisterID ioreg = frame.allocReg();  /* Will hold iterator JSObject */
53404:     RegisterID nireg = frame.allocReg();  /* Will hold NativeIterator */
53404:     RegisterID T1 = frame.allocReg();
53404:     RegisterID T2 = frame.allocReg();
53404:     frame.unpinReg(reg);
53404: 
53404:     /*
53404:      * Fetch the most recent iterator. TODO: bake this pointer in when
53404:      * iterator caches become per-compartment.
53404:      */
53404:     masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), T1);
53404: #ifdef JS_THREADSAFE
53404:     masm.loadPtr(Address(T1, offsetof(JSContext, thread)), T1);
53404:     masm.loadPtr(Address(T1, offsetof(JSThread, data.lastNativeIterator)), ioreg);
53404: #else
53404:     masm.loadPtr(Address(T1, offsetof(JSContext, runtime)), T1);
53404:     masm.loadPtr(Address(T1, offsetof(JSRuntime, threadData.lastNativeIterator)), ioreg);
53404: #endif
53404: 
53404:     /* Test for NULL. */
53404:     Jump nullIterator = masm.branchTest32(Assembler::Zero, ioreg, ioreg);
53404:     stubcc.linkExit(nullIterator, Uses(1));
53404: 
53404:     /* Get NativeIterator from iter obj. :FIXME: X64, also most of this function */
53404:     Address privSlot(ioreg, offsetof(JSObject, fslots) + sizeof(Value) * JSSLOT_PRIVATE);
53404:     masm.loadPayload(privSlot, nireg);
53404: 
53404:     /* Test for active iterator. */
53404:     Address flagsAddr(nireg, offsetof(NativeIterator, flags));
53404:     masm.load32(flagsAddr, T1);
53404:     masm.and32(Imm32(JSITER_ACTIVE), T1);
53404:     Jump activeIterator = masm.branchTest32(Assembler::NonZero, T1, T1);
53404:     stubcc.linkExit(activeIterator, Uses(1));
53404: 
53404:     /* Compare shape of object with iterator. */
53404:     masm.loadShape(reg, T1);
53404:     masm.loadPtr(Address(nireg, offsetof(NativeIterator, shapes_array)), T2);
53404:     masm.load32(Address(T2, 0), T2);
53404:     Jump mismatchedObject = masm.branch32(Assembler::NotEqual, T1, T2);
53404:     stubcc.linkExit(mismatchedObject, Uses(1));
53404: 
53404:     /* Compare shape of object's prototype with iterator. */
53404:     masm.loadPtr(Address(reg, offsetof(JSObject, proto)), T1);
53404:     masm.loadShape(T1, T1);
53404:     masm.loadPtr(Address(nireg, offsetof(NativeIterator, shapes_array)), T2);
53404:     masm.load32(Address(T2, sizeof(uint32)), T2);
53404:     Jump mismatchedProto = masm.branch32(Assembler::NotEqual, T1, T2);
53404:     stubcc.linkExit(mismatchedProto, Uses(1));
53404: 
53404:     /*
53404:      * Compare object's prototype's prototype with NULL. The last native
53404:      * iterator will always have a prototype chain length of one
53404:      * (i.e. it must be a plain object), so we do not need to generate
53404:      * a loop here.
53404:      */
53404:     masm.loadPtr(Address(reg, offsetof(JSObject, proto)), T1);
53404:     masm.loadPtr(Address(T1, offsetof(JSObject, proto)), T1);
53404:     Jump overlongChain = masm.branchPtr(Assembler::NonZero, T1, T1);
53404:     stubcc.linkExit(overlongChain, Uses(1));
53404: 
53404:     /* Found a match with the most recent iterator. Hooray! */
53404: 
53404:     /* Mark iterator as active. */
53404:     masm.load32(flagsAddr, T1);
53404:     masm.or32(Imm32(JSITER_ACTIVE), T1);
53404:     masm.store32(T1, flagsAddr);
53404: 
53404:     /* Chain onto the active iterator stack. */
53404:     masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), T1);
53404:     masm.loadPtr(Address(T1, offsetof(JSContext, enumerators)), T2);
53404:     masm.storePtr(T2, Address(nireg, offsetof(NativeIterator, next)));
53404:     masm.storePtr(ioreg, Address(T1, offsetof(JSContext, enumerators)));
53404: 
53404:     frame.freeReg(nireg);
53404:     frame.freeReg(T1);
53404:     frame.freeReg(T2);
53404: 
53404:     stubcc.leave();
53404:     stubcc.masm.move(Imm32(flags), Registers::ArgReg1);
53404:     stubcc.call(stubs::Iter);
53404: 
53404:     /* Push the iterator object. */
53404:     frame.pop();
53404:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, ioreg);
53404: 
53404:     stubcc.rejoin(Changes(1));
53404: }
53404: 
52737: /*
52737:  * This big nasty function emits a fast-path for native iterators, producing
52737:  * a temporary value on the stack for FORLOCAL,ARG,GLOBAL,etc ops to use.
52737:  */
52737: void
52737: mjit::Compiler::iterNext()
52737: {
52737:     FrameEntry *fe = frame.peek(-1);
52737:     RegisterID reg = frame.tempRegForData(fe);
52737: 
52737:     /* Is it worth trying to pin this longer? Prolly not. */
52737:     frame.pinReg(reg);
52737:     RegisterID T1 = frame.allocReg();
52737:     frame.unpinReg(reg);
52737: 
52737:     /* Test clasp */
52737:     masm.loadPtr(Address(reg, offsetof(JSObject, clasp)), T1);
53244:     Jump notFast = masm.branchPtr(Assembler::NotEqual, T1, ImmPtr(&js_IteratorClass));
53088:     stubcc.linkExit(notFast, Uses(1));
52737: 
53178:     /* Get private from iter obj. */
53157:     masm.loadFunctionPrivate(reg, T1);
52737: 
52737:     RegisterID T3 = frame.allocReg();
52973:     RegisterID T4 = frame.allocReg();
52737: 
52737:     /* Test if for-each. */
52737:     masm.load32(Address(T1, offsetof(NativeIterator, flags)), T3);
52737:     masm.and32(Imm32(JSITER_FOREACH), T3);
52973:     notFast = masm.branchTest32(Assembler::NonZero, T3, T3);
53088:     stubcc.linkExit(notFast, Uses(1));
52973: 
52973:     RegisterID T2 = frame.allocReg();
52973: 
52973:     /* Get cursor. */
52973:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_cursor)), T2);
52973: 
52973:     /* Test if the jsid is a string. */
52973:     masm.loadPtr(T2, T3);
52973:     masm.move(T3, T4);
52973:     masm.andPtr(Imm32(JSID_TYPE_MASK), T4);
52973:     notFast = masm.branchTestPtr(Assembler::NonZero, T4, T4);
53088:     stubcc.linkExit(notFast, Uses(1));
52737: 
52737:     /* It's safe to increase the cursor now. */
52973:     masm.addPtr(Imm32(sizeof(jsid)), T2, T4);
52973:     masm.storePtr(T4, Address(T1, offsetof(NativeIterator, props_cursor)));
52973: 
52973:     frame.freeReg(T4);
52737:     frame.freeReg(T1);
52973:     frame.freeReg(T2);
52737: 
52737:     stubcc.leave();
52737:     stubcc.call(stubs::IterNext);
52737: 
53025:     frame.pushUntypedPayload(JSVAL_TYPE_STRING, T3);
52737: 
52737:     /* Join with the stub call. */
53088:     stubcc.rejoin(Changes(1));
52737: }
52737: 
52737: void
52737: mjit::Compiler::iterMore()
52737: {
52737:     FrameEntry *fe= frame.peek(-1);
52737:     RegisterID reg = frame.tempRegForData(fe);
52737: 
52737:     frame.pinReg(reg);
52737:     RegisterID T1 = frame.allocReg();
52737:     frame.unpinReg(reg);
52737: 
52737:     /* Test clasp */
52737:     masm.loadPtr(Address(reg, offsetof(JSObject, clasp)), T1);
53244:     Jump notFast = masm.branchPtr(Assembler::NotEqual, T1, ImmPtr(&js_IteratorClass));
53277:     stubcc.linkExitForBranch(notFast);
52737: 
53178:     /* Get private from iter obj. */
53157:     masm.loadFunctionPrivate(reg, T1);
52737: 
52737:     /* Get props_cursor, test */
52737:     RegisterID T2 = frame.allocReg();
52737:     frame.forgetEverything();
52737:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_cursor)), T2);
52737:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_end)), T1);
53133:     Jump jFast = masm.branchPtr(Assembler::LessThan, T2, T1);
52737: 
52737:     jsbytecode *target = &PC[JSOP_MOREITER_LENGTH];
52737:     JSOp next = JSOp(*target);
52737:     JS_ASSERT(next == JSOP_IFNE || next == JSOP_IFNEX);
52737: 
52737:     target += (next == JSOP_IFNE)
52737:               ? GET_JUMP_OFFSET(target)
52737:               : GET_JUMPX_OFFSET(target);
52737: 
52737:     stubcc.leave();
52737:     stubcc.call(stubs::IterMore);
53133:     Jump j = stubcc.masm.branchTest32(Assembler::NonZero, Registers::ReturnReg,
53133:                                       Registers::ReturnReg);
53133: 
52737:     PC += JSOP_MOREITER_LENGTH;
52737:     PC += js_CodeSpec[next].length;
52737: 
53088:     stubcc.rejoin(Changes(1));
53133: 
53277:     jumpAndTrace(jFast, target, &j);
52737: }
52737: 
52815: void
53404: mjit::Compiler::iterEnd()
53404: {
53404:     FrameEntry *fe= frame.peek(-1);
53404:     RegisterID reg = frame.tempRegForData(fe);
53404: 
53404:     frame.pinReg(reg);
53404:     RegisterID T1 = frame.allocReg();
53404:     frame.unpinReg(reg);
53404: 
53404:     /* Test clasp */
53404:     masm.loadPtr(Address(reg, offsetof(JSObject, clasp)), T1);
53404:     Jump notIterator = masm.branchPtr(Assembler::NotEqual, T1, ImmPtr(&js_IteratorClass));
53404:     stubcc.linkExit(notIterator, Uses(1));
53404: 
53404:     /* Get private from iter obj. :FIXME: X64 */
53404:     Address privSlot(reg, offsetof(JSObject, fslots) + sizeof(Value) * JSSLOT_PRIVATE);
53404:     masm.loadPayload(privSlot, T1);
53404: 
53404:     RegisterID T2 = frame.allocReg();
53404: 
53404:     /* Load flags. */
53404:     Address flagAddr(T1, offsetof(NativeIterator, flags));
53404:     masm.loadPtr(flagAddr, T2);
53404: 
53404:     /* Test for (flags == ENUMERATE | ACTIVE). */
53404:     Jump notEnumerate = masm.branch32(Assembler::NotEqual, T2,
53404:                                       Imm32(JSITER_ENUMERATE | JSITER_ACTIVE));
53404:     stubcc.linkExit(notEnumerate, Uses(1));
53404: 
53404:     /* Clear active bit. */
53404:     masm.and32(Imm32(~JSITER_ACTIVE), T2);
53404:     masm.storePtr(T2, flagAddr);
53404: 
53404:     /* Reset property cursor. */
53404:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_array)), T2);
53404:     masm.storePtr(T2, Address(T1, offsetof(NativeIterator, props_cursor)));
53404: 
53404:     /* Advance enumerators list. */
53404:     masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), T2);
53404:     masm.loadPtr(Address(T1, offsetof(NativeIterator, next)), T1);
53404:     masm.storePtr(T1, Address(T2, offsetof(JSContext, enumerators)));
53404: 
53404:     frame.freeReg(T1);
53404:     frame.freeReg(T2);
53404: 
53404:     stubcc.leave();
53404:     stubcc.call(stubs::EndIter);
53404: 
53404:     frame.pop();
53404: 
53404:     stubcc.rejoin(Changes(1));
53404: }
53404: 
53404: void
52815: mjit::Compiler::jsop_eleminc(JSOp op, VoidStub stub)
52815: {
53087:     prepareStubCall(Uses(2));
53087:     stubCall(stub);
52815:     frame.popn(2);
52815:     frame.pushSynced();
52815: }
52815: 
52826: void
52826: mjit::Compiler::jsop_getgname_slow(uint32 index)
52826: {
53087:     prepareStubCall(Uses(0));
53087:     stubCall(stubs::GetGlobalName);
52826:     frame.pushSynced();
52826: }
52826: 
52826: void
52826: mjit::Compiler::jsop_bindgname()
52826: {
52826:     if (script->compileAndGo && globalObj) {
53081:         frame.push(ObjectValue(*globalObj));
52826:         return;
52826:     }
52826: 
52826:     /* :TODO: this is slower than it needs to be. */
53087:     prepareStubCall(Uses(0));
53087:     stubCall(stubs::BindGlobalName);
52826:     frame.takeReg(Registers::ReturnReg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52826: }
52826: 
52826: void
52826: mjit::Compiler::jsop_getgname(uint32 index)
52826: {
53119: #if defined JS_MONOIC
52826:     jsop_bindgname();
52826: 
52826:     FrameEntry *fe = frame.peek(-1);
53025:     JS_ASSERT(fe->isTypeKnown() && fe->getKnownType() == JSVAL_TYPE_OBJECT);
52826: 
53116:     MICGenInfo mic(ic::MICInfo::GET);
52826:     RegisterID objReg;
52826:     Jump shapeGuard;
52826: 
52826:     mic.entry = masm.label();
52826:     if (fe->isConstant()) {
53081:         JSObject *obj = &fe->getValue().toObject();
52826:         frame.pop();
52826:         JS_ASSERT(obj->isNative());
52826: 
52826:         JSObjectMap *map = obj->map;
52826:         objReg = frame.allocReg();
52826: 
52826:         masm.load32FromImm(&map->shape, objReg);
53408:         shapeGuard = masm.branch32WithPatch(Assembler::NotEqual, objReg,
53408:                                             Imm32(int32(JSObjectMap::INVALID_SHAPE)), mic.shape);
52826:         masm.move(ImmPtr(obj), objReg);
52826:     } else {
52826:         objReg = frame.ownRegForData(fe);
52826:         frame.pop();
52826:         RegisterID reg = frame.allocReg();
52826: 
53445:         masm.loadShape(objReg, reg);
53408:         shapeGuard = masm.branch32WithPatch(Assembler::NotEqual, reg,
53408:                                             Imm32(int32(JSObjectMap::INVALID_SHAPE)), mic.shape);
52826:         frame.freeReg(reg);
52826:     }
53088:     stubcc.linkExit(shapeGuard, Uses(0));
52826: 
52826:     stubcc.leave();
52826:     stubcc.masm.move(Imm32(mics.length()), Registers::ArgReg1);
52826:     mic.stubEntry = stubcc.masm.label();
52826:     mic.call = stubcc.call(ic::GetGlobalName);
52826: 
52826:     /* Garbage value. */
52826:     uint32 slot = 1 << 24;
52826: 
52826:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52826:     Address address(objReg, slot);
53269:     
53269:     /*
53269:      * On x86_64, the length of the movq instruction used is variable
53269:      * depending on the registers used. For example, 'movq $0x5(%r12), %r12'
53269:      * is one byte larger than 'movq $0x5(%r14), %r14'. This means that
53269:      * the constant '0x5' that we want to write is at a variable position.
53269:      *
53269:      * x86_64 only performs a single load. The constant offset is always
53269:      * at the end of the bytecode. Knowing the start and end of the move
53269:      * bytecode is sufficient for patching.
53269:      */
53269: 
53269:     /* Allocate any register other than objReg. */
53269:     RegisterID dreg = frame.allocReg();
53269:     /* After dreg is loaded, it's safe to clobber objReg. */
53269:     RegisterID treg = objReg;
53269: 
53269:     mic.load = masm.label();
53269: # if defined JS_NUNBOX32
53451: #  if defined JS_CPU_ARM
53451:     DataLabel32 offsetAddress = masm.load64WithAddressOffsetPatch(address, treg, dreg);
53451:     JS_ASSERT(masm.differenceBetween(mic.load, offsetAddress) == 0);
53451: #  else
53269:     masm.loadPayload(address, dreg);
53269:     masm.loadTypeTag(address, treg);
53451: #  endif
53269: # elif defined JS_PUNBOX64
53386:     Label inlineValueLoadLabel =
53386:         masm.loadValueAsComponents(address, treg, dreg);
53386:     mic.patchValueOffset = masm.differenceBetween(mic.load, inlineValueLoadLabel);
53426:     JS_ASSERT(mic.patchValueOffset == masm.differenceBetween(mic.load, inlineValueLoadLabel));
53269: # endif
53269: 
53269:     frame.pushRegs(treg, dreg);
52826: 
53088:     stubcc.rejoin(Changes(1));
52826:     mics.append(mic);
53269: 
52826: #else
52826:     jsop_getgname_slow(index);
52826: #endif
52826: }
52826: 
52831: void
52831: mjit::Compiler::jsop_setgname_slow(uint32 index)
52831: {
52831:     JSAtom *atom = script->getAtom(index);
53087:     prepareStubCall(Uses(2));
52831:     masm.move(ImmPtr(atom), Registers::ArgReg1);
53087:     stubCall(stubs::SetGlobalName);
52831:     frame.popn(2);
52831:     frame.pushSynced();
52831: }
52831: 
52831: void
52831: mjit::Compiler::jsop_setgname(uint32 index)
52831: {
53119: #if defined JS_MONOIC
52831:     FrameEntry *objFe = frame.peek(-2);
53025:     JS_ASSERT_IF(objFe->isTypeKnown(), objFe->getKnownType() == JSVAL_TYPE_OBJECT);
52831: 
53116:     MICGenInfo mic(ic::MICInfo::SET);
52831:     RegisterID objReg;
52831:     Jump shapeGuard;
52831: 
52831:     mic.entry = masm.label();
52831:     if (objFe->isConstant()) {
53081:         JSObject *obj = &objFe->getValue().toObject();
52831:         JS_ASSERT(obj->isNative());
52831: 
52831:         JSObjectMap *map = obj->map;
52831:         objReg = frame.allocReg();
52831: 
52831:         masm.load32FromImm(&map->shape, objReg);
53408:         shapeGuard = masm.branch32WithPatch(Assembler::NotEqual, objReg,
53408:                                             Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53408:                                             mic.shape);
52831:         masm.move(ImmPtr(obj), objReg);
52831:     } else {
52831:         objReg = frame.tempRegForData(objFe);
52831:         frame.pinReg(objReg);
52831:         RegisterID reg = frame.allocReg();
52831: 
53445:         masm.loadShape(objReg, reg);
53408:         shapeGuard = masm.branch32WithPatch(Assembler::NotEqual, reg,
53408:                                             Imm32(int32(JSObjectMap::INVALID_SHAPE)),
53408:                                             mic.shape);
52831:         frame.freeReg(reg);
52831:     }
53113:     stubcc.linkExit(shapeGuard, Uses(2));
52831: 
52831:     stubcc.leave();
52831:     stubcc.masm.move(Imm32(mics.length()), Registers::ArgReg1);
52831:     mic.stubEntry = stubcc.masm.label();
52831:     mic.call = stubcc.call(ic::SetGlobalName);
52831: 
52831:     /* Garbage value. */
52831:     uint32 slot = 1 << 24;
52831: 
52831:     /* Get both type and reg into registers. */
52831:     FrameEntry *fe = frame.peek(-1);
52831: 
52831:     Value v;
52831:     RegisterID typeReg = Registers::ReturnReg;
52831:     RegisterID dataReg = Registers::ReturnReg;
53025:     JSValueType typeTag = JSVAL_TYPE_INT32;
52831: 
53133:     mic.u.name.typeConst = fe->isTypeKnown();
53133:     mic.u.name.dataConst = fe->isConstant();
53133: 
53133:     if (!mic.u.name.dataConst) {
52831:         dataReg = frame.ownRegForData(fe);
53133:         if (!mic.u.name.typeConst)
52831:             typeReg = frame.ownRegForType(fe);
52831:         else
53025:             typeTag = fe->getKnownType();
52831:     } else {
52831:         v = fe->getValue();
52831:     }
52831: 
52831:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52831:     Address address(objReg, slot);
52831: 
53451:     mic.load = masm.label();
53451: 
53269: #if defined JS_NUNBOX32
53451: # if defined JS_CPU_ARM
53451:     DataLabel32 offsetAddress;
53451:     if (mic.u.name.dataConst) {
53451:         offsetAddress = masm.moveWithPatch(Imm32(address.offset), JSC::ARMRegisters::S0);
53451:         masm.add32(address.base, JSC::ARMRegisters::S0);
53451:         masm.storeValue(v, Address(JSC::ARMRegisters::S0, 0));
53451:     } else {
53451:         if (mic.u.name.typeConst) {
53451:             offsetAddress = masm.store64WithAddressOffsetPatch(ImmType(typeTag), dataReg, address);
53451:         } else {
53451:             offsetAddress = masm.store64WithAddressOffsetPatch(typeReg, dataReg, address);
53451:         }
53451:     }
53451:     JS_ASSERT(masm.differenceBetween(mic.load, offsetAddress) == 0);
53451: # else
53133:     if (mic.u.name.dataConst) {
52831:         masm.storeValue(v, address);
52831:     } else {
53133:         if (mic.u.name.typeConst)
53025:             masm.storeTypeTag(ImmType(typeTag), address);
52831:         else
52831:             masm.storeTypeTag(typeReg, address);
53144:         masm.storePayload(dataReg, address);
52831:     }
53451: # endif
53269: #elif defined JS_PUNBOX64
53269:     if (mic.u.name.dataConst) {
53269:         /* Emits a single move. No code length variation. */
53269:         masm.storeValue(v, address);
53269:     } else {
53269:         if (mic.u.name.typeConst)
53269:             masm.move(ImmType(typeTag), Registers::ValueReg);
53269:         else
53269:             masm.move(typeReg, Registers::ValueReg);
53269:         masm.orPtr(dataReg, Registers::ValueReg);
53269:         masm.storePtr(Registers::ValueReg, address);
53269:     }
53269: 
53269:     /* 
53269:      * Instructions on x86_64 can vary in size based on registers
53269:      * used. Since we only need to patch the last instruction in
53269:      * both paths above, remember the distance between the
53269:      * load label and after the instruction to be patched.
53269:      */
53269:     mic.patchValueOffset = masm.differenceBetween(mic.load, masm.label());
53426:     JS_ASSERT(mic.patchValueOffset == masm.differenceBetween(mic.load, masm.label()));
53269: #endif
52831: 
52831:     if (objFe->isConstant())
52831:         frame.freeReg(objReg);
52831:     frame.popn(2);
53133:     if (mic.u.name.dataConst) {
52831:         frame.push(v);
52831:     } else {
53133:         if (mic.u.name.typeConst)
52831:             frame.pushTypedPayload(typeTag, dataReg);
52831:         else
52831:             frame.pushRegs(typeReg, dataReg);
52831:     }
52831: 
53088:     stubcc.rejoin(Changes(1));
52831: 
52831:     mics.append(mic);
52831: #else
52831:     jsop_setgname_slow(index);
52831: #endif
52831: }
52831: 
52838: void
52838: mjit::Compiler::jsop_setelem_slow()
52838: {
53087:     prepareStubCall(Uses(3));
53087:     stubCall(stubs::SetElem);
52838:     frame.popn(3);
52838:     frame.pushSynced();
52838: }
52838: 
52843: void
52843: mjit::Compiler::jsop_getelem_slow()
52843: {
53087:     prepareStubCall(Uses(2));
53087:     stubCall(stubs::GetElem);
52843:     frame.popn(2);
52843:     frame.pushSynced();
52843: }
52843: 
52874: void
52874: mjit::Compiler::jsop_unbrand()
52874: {
53087:     prepareStubCall(Uses(1));
53087:     stubCall(stubs::Unbrand);
52874: }
52874: 
52894: void
52894: mjit::Compiler::jsop_instanceof()
52894: {
53124:     FrameEntry *lhs = frame.peek(-2);
52894:     FrameEntry *rhs = frame.peek(-1);
52894: 
53124:     // The fast path applies only when both operands are objects.
53124:     if (rhs->isNotType(JSVAL_TYPE_OBJECT) || lhs->isNotType(JSVAL_TYPE_OBJECT)) {
53087:         prepareStubCall(Uses(2));
53087:         stubCall(stubs::InstanceOf);
52894:         frame.popn(2);
52894:         frame.takeReg(Registers::ReturnReg);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, Registers::ReturnReg);
52894:         return;
52894:     }
52894: 
53124:     MaybeJump firstSlow;
53124:     if (!rhs->isTypeKnown()) {
53023:         Jump j = frame.testObject(Assembler::NotEqual, rhs);
53088:         stubcc.linkExit(j, Uses(2));
53023:         RegisterID reg = frame.tempRegForData(rhs);
53023:         j = masm.testFunction(Assembler::NotEqual, reg);
53088:         stubcc.linkExit(j, Uses(2));
52894:         stubcc.leave();
52894:         stubcc.call(stubs::InstanceOf);
52911:         firstSlow = stubcc.masm.jump();
52911:     }
52911: 
52911:     /* This is sadly necessary because the error case needs the object. */
52894:     frame.dup();
52894: 
52894:     jsop_getprop(cx->runtime->atomState.classPrototypeAtom, false);
52894: 
52911:     /* Primitive prototypes are invalid. */
52911:     rhs = frame.peek(-1);
52911:     Jump j = frame.testPrimitive(Assembler::Equal, rhs);
53088:     stubcc.linkExit(j, Uses(3));
52911: 
52911:     /* Allocate registers up front, because of branchiness. */
52911:     RegisterID obj = frame.copyDataIntoReg(lhs);
52911:     RegisterID proto = frame.copyDataIntoReg(rhs);
52911:     RegisterID temp = frame.allocReg();
52911: 
53124:     MaybeJump isFalse;
53124:     if (!lhs->isTypeKnown())
53124:         isFalse = frame.testPrimitive(Assembler::Equal, lhs);
52911: 
52911:     /* Quick test to avoid wrapped objects. */
52911:     masm.loadPtr(Address(obj, offsetof(JSObject, clasp)), temp);
53445:     masm.loadPtr(Address(temp, offsetof(Class, ext) +
53445:                               offsetof(ClassExtension, wrappedObject)), temp);
53445:     j = masm.branchTestPtr(Assembler::NonZero, temp, temp);
53088:     stubcc.linkExit(j, Uses(3));
52911: 
53081:     Address protoAddr(obj, offsetof(JSObject, proto));
52911:     Label loop = masm.label();
52911: 
52911:     /* Walk prototype chain, break out on NULL or hit. */
53144:     masm.loadPayload(protoAddr, obj);
52911:     Jump isFalse2 = masm.branchTestPtr(Assembler::Zero, obj, obj);
52911:     Jump isTrue = masm.branchPtr(Assembler::NotEqual, obj, proto);
52911:     isTrue.linkTo(loop, &masm);
52911:     masm.move(Imm32(1), temp);
52911:     isTrue = masm.jump();
52911: 
53124:     if (isFalse.isSet())
53124:         isFalse.getJump().linkTo(masm.label(), &masm);
52911:     isFalse2.linkTo(masm.label(), &masm);
52911:     masm.move(Imm32(0), temp);
52911:     isTrue.linkTo(masm.label(), &masm);
52911: 
52911:     frame.freeReg(proto);
52911:     frame.freeReg(obj);
52911: 
52911:     stubcc.leave();
52911:     stubcc.call(stubs::FastInstanceOf);
52911: 
52894:     frame.popn(3);
53025:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, temp);
52911: 
53124:     if (firstSlow.isSet())
53124:         firstSlow.getJump().linkTo(stubcc.masm.label(), &stubcc.masm);
53088:     stubcc.rejoin(Changes(1));
52894: }
52894: 
53133: /*
53133:  * Note: This function emits tracer hooks into the OOL path. This means if
53460:  * it is used in the middle of an in-progress slow path, the stream will be
53133:  * hopelessly corrupted. Take care to only call this before linkExits() and
53133:  * after rejoin()s.
53133:  */
53133: void
53277: mjit::Compiler::jumpAndTrace(Jump j, jsbytecode *target, Jump *slow)
53133: {
53133: #ifndef JS_TRACER
53133:     jumpInScript(j, target);
53288:     if (slow)
53288:         stubcc.jumpInScript(*slow, target);
53133: #else
53133:     if (!addTraceHints || target >= PC || JSOp(*target) != JSOP_TRACE) {
53133:         jumpInScript(j, target);
53277:         if (slow)
53277:             stubcc.jumpInScript(*slow, target);
53133:         return;
53133:     }
53133: 
53133: # if JS_MONOIC
53133:     MICGenInfo mic(ic::MICInfo::TRACER);
53133: 
53133:     mic.entry = masm.label();
53133:     mic.jumpTarget = target;
53133:     mic.traceHint = j;
53277:     if (slow)
53277:         mic.slowTraceHint = *slow;
53133: # endif
53133: 
53133:     stubcc.linkExitDirect(j, stubcc.masm.label());
53277:     if (slow)
53277:         slow->linkTo(stubcc.masm.label(), &stubcc.masm);
53133: # if JS_MONOIC
53133:     stubcc.masm.move(Imm32(mics.length()), Registers::ArgReg1);
53133: # endif
53133: 
53133:     /* Save and restore compiler-tracked PC, so cx->regs is right in InvokeTracer. */
53133:     {
53133:         jsbytecode* pc = PC;
53133:         PC = target;
53133: 
53133:         stubcc.call(stubs::InvokeTracer);
53133: 
53133:         PC = pc;
53133:     }
53133: 
53133:     Jump no = stubcc.masm.branchTestPtr(Assembler::Zero, Registers::ReturnReg,
53133:                                         Registers::ReturnReg);
53133:     restoreFrameRegs(stubcc.masm);
53133:     stubcc.masm.jump(Registers::ReturnReg);
53133:     no.linkTo(stubcc.masm.label(), &stubcc.masm);
53133:     stubcc.jumpInScript(stubcc.masm.jump(), target);
53133: 
53133: # if JS_MONOIC
53133:     mics.append(mic);
53133: # endif
53133: #endif
53133: }
53133: 
