    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object to wrap rendering objects that should be scrollable */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsPresContext.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIView.h"
    1: #include "nsIScrollable.h"
    1: #include "nsIViewManager.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsGfxScrollFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsIDocument.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIScrollbarFrame.h"
    1: #include "nsIScrollbarMediator.h"
    1: #include "nsITextControlFrame.h"
    1: #include "nsIDOMHTMLTextAreaElement.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIURI.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsPresState.h"
    1: #include "nsIGlobalHistory3.h"
    1: #include "nsDocShellCID.h"
11877: #include "nsIHTMLDocument.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsContentUtils.h"
    1: #include "nsLayoutUtils.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsDisplayList.h"
    1: #include "nsBidiUtils.h"
33373: #include "nsFrameManager.h"
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: //----------nsHTMLScrollFrame-------------------------------------------
    1: 
    1: nsIFrame*
    1: NS_NewHTMLScrollFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot)
    1: {
    1:   return new (aPresShell) nsHTMLScrollFrame(aPresShell, aContext, aIsRoot);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsHTMLScrollFrame)
32423: 
    1: nsHTMLScrollFrame::nsHTMLScrollFrame(nsIPresShell* aShell, nsStyleContext* aContext, PRBool aIsRoot)
    1:   : nsHTMLContainerFrame(aContext),
    1:     mInner(this, aIsRoot, PR_FALSE)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsHTMLScrollFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
    1: {
    1:   return mInner.CreateAnonymousContent(aElements);
    1: }
    1: 
    1: void
36647: nsHTMLScrollFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   mInner.Destroy();
36647:   nsHTMLContainerFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: NS_IMETHODIMP
30790: nsHTMLScrollFrame::SetInitialChildList(nsIAtom*     aListName,
30790:                                        nsFrameList& aChildList)
    1: {
    1:   nsresult rv = nsHTMLContainerFrame::SetInitialChildList(aListName, aChildList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::AppendFrames(nsIAtom*  aListName,
30941:                                 nsFrameList& aFrameList)
    1: {
    1:   NS_ASSERTION(!aListName, "Only main list supported");
    1:   mFrames.AppendFrames(nsnull, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::InsertFrames(nsIAtom*  aListName,
    1:                                 nsIFrame* aPrevFrame,
30941:                                 nsFrameList& aFrameList)
    1: {
    1:   NS_ASSERTION(!aListName, "Only main list supported");
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                "inserting after sibling frame with different parent");
    1:   mFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::RemoveFrame(nsIAtom*  aListName,
    1:                                nsIFrame* aOldFrame)
    1: {
    1:   NS_ASSERTION(!aListName, "Only main list supported");
 8156:   mFrames.DestroyFrame(aOldFrame);
    1:   mInner.ReloadChildFrames();
    1:   return NS_OK;
    1: }
    1: 
    1: nsSplittableType
    1: nsHTMLScrollFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_NOT_SPLITTABLE;
    1: }
    1: 
    1: PRIntn
    1: nsHTMLScrollFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsIAtom*
    1: nsHTMLScrollFrame::GetType() const
    1: {
    1:   return nsGkAtoms::scrollFrame; 
    1: }
    1: 
15910: void
15910: nsHTMLScrollFrame::InvalidateInternal(const nsRect& aDamageRect,
15910:                                       nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                       PRUint32 aFlags)
15910: {
30690:   if (aForChild) {
30507:     if (aForChild == mInner.mScrolledFrame) {
15910:       // restrict aDamageRect to the scrollable view's bounds
19380:       nsRect damage = aDamageRect + nsPoint(aX, aY);
15910:       nsRect r;
37083:       if (r.IntersectRect(damage, mInner.mScrollPort)) {
19380:         nsHTMLContainerFrame::InvalidateInternal(r, 0, 0, aForChild, aFlags);
19380:       }
19380:       if (mInner.mIsRoot && r != damage) {
19380:         // Make sure we notify our prescontext about invalidations outside
19380:         // viewport clipping.
19380:         // This is important for things that are snapshotting the viewport,
19380:         // possibly outside the scrolled bounds.
19380:         // We don't need to propagate this any further up, though. Anyone who
19380:         // cares about scrolled-out-of-view invalidates had better be listening
19380:         // to our window directly.
32894:         PresContext()->NotifyInvalidation(damage, aFlags);
15910:       }
15910:       return;
30507:     } else if (aForChild == mInner.mHScrollbarBox) {
30507:       if (!mInner.mHasHorizontalScrollbar) {
30507:         // Our scrollbars may send up invalidations even when they're collapsed,
30507:         // because we just size a collapsed scrollbar to empty and some
30507:         // descendants may be non-empty. Suppress that invalidation here.
30507:         return;
30507:       }
30507:     } else if (aForChild == mInner.mVScrollbarBox) {
30507:       if (!mInner.mHasVerticalScrollbar) {
30507:         // Our scrollbars may send up invalidations even when they're collapsed,
30507:         // because we just size a collapsed scrollbar to empty and some
30507:         // descendants may be non-empty. Suppress that invalidation here.
30507:         return;
30507:       }
30507:     }
30690:   }
15910:  
19380:   nsHTMLContainerFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aFlags);
15910: }
15910: 
    1: /**
    1:  HTML scrolling implementation
    1: 
    1:  All other things being equal, we prefer layouts with fewer scrollbars showing.
    1: */
    1: 
    1: struct ScrollReflowState {
    1:   const nsHTMLReflowState& mReflowState;
    1:   nsBoxLayoutState mBoxState;
    1:   nsGfxScrollFrameInner::ScrollbarStyles mStyles;
    1:   nsMargin mComputedBorder;
    1: 
 8731:   // === Filled in by ReflowScrolledFrame ===
37083:   nsRect mContentsOverflowArea;
 8731:   PRPackedBool mReflowedContentsWithHScrollbar;
 8731:   PRPackedBool mReflowedContentsWithVScrollbar;
 8731: 
    1:   // === Filled in when TryLayout succeeds ===
    1:   // The size of the inside-border area
    1:   nsSize mInsideBorderSize;
    1:   // Whether we decided to show the horizontal scrollbar
    1:   PRPackedBool mShowHScrollbar;
    1:   // Whether we decided to show the vertical scrollbar
    1:   PRPackedBool mShowVScrollbar;
    1: 
    1:   ScrollReflowState(nsIScrollableFrame* aFrame,
    1:                     const nsHTMLReflowState& aState) :
    1:     mReflowState(aState),
14159:     // mBoxState is just used for scrollbars so we don't need to
14159:     // worry about the reflow depth here
14159:     mBoxState(aState.frame->PresContext(), aState.rendContext, 0),
    1:     mStyles(aFrame->GetScrollbarStyles()) {
    1:   }
    1: };
    1: 
    1: // XXXldb Can this go away?
    1: static nsSize ComputeInsideBorderSize(ScrollReflowState* aState,
    1:                                       const nsSize& aDesiredInsideBorderSize)
    1: {
    1:   // aDesiredInsideBorderSize is the frame size; i.e., it includes
    1:   // borders and padding (but the scrolled child doesn't have
    1:   // borders). The scrolled child has the same padding as us.
    1:   nscoord contentWidth = aState->mReflowState.ComputedWidth();
    1:   if (contentWidth == NS_UNCONSTRAINEDSIZE) {
    1:     contentWidth = aDesiredInsideBorderSize.width -
    1:       aState->mReflowState.mComputedPadding.LeftRight();
    1:   }
 4166:   nscoord contentHeight = aState->mReflowState.ComputedHeight();
    1:   if (contentHeight == NS_UNCONSTRAINEDSIZE) {
    1:     contentHeight = aDesiredInsideBorderSize.height -
    1:       aState->mReflowState.mComputedPadding.TopBottom();
    1:   }
    1: 
    1:   aState->mReflowState.ApplyMinMaxConstraints(&contentWidth, &contentHeight);
    1:   return nsSize(contentWidth + aState->mReflowState.mComputedPadding.LeftRight(),
    1:                 contentHeight + aState->mReflowState.mComputedPadding.TopBottom());
    1: }
    1: 
    1: static void
    1: GetScrollbarMetrics(nsBoxLayoutState& aState, nsIBox* aBox, nsSize* aMin,
    1:                     nsSize* aPref, PRBool aVertical)
    1: {
    1:   NS_ASSERTION(aState.GetRenderingContext(),
    1:                "Must have rendering context in layout state for size "
    1:                "computations");
    1:   
    1:   if (aMin) {
    1:     *aMin = aBox->GetMinSize(aState);
    1:   }
    1:  
    1:   if (aPref) {
    1:     *aPref = aBox->GetPrefSize(aState);
    1:   }
    1: }
    1: 
    1: /**
    1:  * Assuming that we know the metrics for our wrapped frame and
    1:  * whether the horizontal and/or vertical scrollbars are present,
    1:  * compute the resulting layout and return PR_TRUE if the layout is
    1:  * consistent. If the layout is consistent then we fill in the
    1:  * computed fields of the ScrollReflowState.
    1:  *
    1:  * The layout is consistent when both scrollbars are showing if and only
    1:  * if they should be showing. A horizontal scrollbar should be showing if all
    1:  * following conditions are met:
    1:  * 1) the style is not HIDDEN
    1:  * 2) our inside-border height is at least the scrollbar height (i.e., the
    1:  * scrollbar fits vertically)
    1:  * 3) our scrollport width (the inside-border width minus the width allocated for a
    1:  * vertical scrollbar, if showing) is at least the scrollbar's min-width
    1:  * (i.e., the scrollbar fits horizontally)
    1:  * 4) the style is SCROLL, or the kid's overflow-area XMost is
    1:  * greater than the scrollport width
    1:  *
    1:  * @param aForce if PR_TRUE, then we just assume the layout is consistent.
    1:  */
    1: PRBool
    1: nsHTMLScrollFrame::TryLayout(ScrollReflowState* aState,
 8731:                              nsHTMLReflowMetrics* aKidMetrics,
 8731:                              PRBool aAssumeHScroll, PRBool aAssumeVScroll,
 8731:                              PRBool aForce, nsresult* aResult)
    1: {
 8731:   *aResult = NS_OK;
 8731: 
    1:   if ((aState->mStyles.mVertical == NS_STYLE_OVERFLOW_HIDDEN && aAssumeVScroll) ||
    1:       (aState->mStyles.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN && aAssumeHScroll)) {
    1:     NS_ASSERTION(!aForce, "Shouldn't be forcing a hidden scrollbar to show!");
    1:     return PR_FALSE;
    1:   }
    1: 
 8731:   if (aAssumeVScroll != aState->mReflowedContentsWithVScrollbar ||
12142:       (aAssumeHScroll != aState->mReflowedContentsWithHScrollbar &&
12142:        ScrolledContentDependsOnHeight(aState))) {
 8731:     nsresult rv = ReflowScrolledFrame(aState, aAssumeHScroll, aAssumeVScroll,
 8731:                                       aKidMetrics, PR_FALSE);
 8731:     if (NS_FAILED(rv)) {
 8731:       *aResult = rv;
 8731:       return PR_FALSE;
 8731:     }
 8731:   }
 8731: 
    1:   nsSize vScrollbarMinSize(0, 0);
    1:   nsSize vScrollbarPrefSize(0, 0);
    1:   if (mInner.mVScrollbarBox) {
    1:     GetScrollbarMetrics(aState->mBoxState, mInner.mVScrollbarBox,
    1:                         &vScrollbarMinSize,
    1:                         aAssumeVScroll ? &vScrollbarPrefSize : nsnull, PR_TRUE);
    1:   }
    1:   nscoord vScrollbarDesiredWidth = aAssumeVScroll ? vScrollbarPrefSize.width : 0;
12186:   nscoord vScrollbarMinHeight = aAssumeVScroll ? vScrollbarMinSize.height : 0;
    1: 
    1:   nsSize hScrollbarMinSize(0, 0);
    1:   nsSize hScrollbarPrefSize(0, 0);
    1:   if (mInner.mHScrollbarBox) {
    1:     GetScrollbarMetrics(aState->mBoxState, mInner.mHScrollbarBox,
    1:                         &hScrollbarMinSize,
    1:                         aAssumeHScroll ? &hScrollbarPrefSize : nsnull, PR_FALSE);
    1:   }
    1:   nscoord hScrollbarDesiredHeight = aAssumeHScroll ? hScrollbarPrefSize.height : 0;
12186:   nscoord hScrollbarMinWidth = aAssumeHScroll ? hScrollbarMinSize.width : 0;
    1: 
    1:   // First, compute our inside-border size and scrollport size
    1:   // XXXldb Can we depend more on ComputeSize here?
    1:   nsSize desiredInsideBorderSize;
    1:   desiredInsideBorderSize.width = vScrollbarDesiredWidth +
32531:     NS_MAX(aKidMetrics->width, hScrollbarMinWidth);
    1:   desiredInsideBorderSize.height = hScrollbarDesiredHeight +
32531:     NS_MAX(aKidMetrics->height, vScrollbarMinHeight);
    1:   aState->mInsideBorderSize =
    1:     ComputeInsideBorderSize(aState, desiredInsideBorderSize);
32531:   nsSize scrollPortSize = nsSize(NS_MAX(0, aState->mInsideBorderSize.width - vScrollbarDesiredWidth),
32531:                                  NS_MAX(0, aState->mInsideBorderSize.height - hScrollbarDesiredHeight));
    1:                                                                                 
    1:   if (!aForce) {
37083:     nsRect scrolledRect =
37083:       mInner.GetScrolledRectInternal(aState->mContentsOverflowArea, scrollPortSize);
14659:     nscoord oneDevPixel = aState->mBoxState.PresContext()->DevPixelsToAppUnits(1);
    1: 
    1:     // If the style is HIDDEN then we already know that aAssumeHScroll is PR_FALSE
    1:     if (aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN) {
    1:       PRBool wantHScrollbar =
    1:         aState->mStyles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL ||
14659:         scrolledRect.XMost() >= scrollPortSize.width + oneDevPixel ||
14659:         scrolledRect.x <= -oneDevPixel;
    1:       if (aState->mInsideBorderSize.height < hScrollbarMinSize.height ||
    1:           scrollPortSize.width < hScrollbarMinSize.width)
    1:         wantHScrollbar = PR_FALSE;
    1:       if (wantHScrollbar != aAssumeHScroll)
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     // If the style is HIDDEN then we already know that aAssumeVScroll is PR_FALSE
    1:     if (aState->mStyles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) {
    1:       PRBool wantVScrollbar =
    1:         aState->mStyles.mVertical == NS_STYLE_OVERFLOW_SCROLL ||
14659:         scrolledRect.YMost() >= scrollPortSize.height + oneDevPixel ||
14659:         scrolledRect.y <= -oneDevPixel;
    1:       if (aState->mInsideBorderSize.width < vScrollbarMinSize.width ||
    1:           scrollPortSize.height < vScrollbarMinSize.height)
    1:         wantVScrollbar = PR_FALSE;
    1:       if (wantVScrollbar != aAssumeVScroll)
    1:         return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   nscoord vScrollbarActualWidth = aState->mInsideBorderSize.width - scrollPortSize.width;
    1: 
    1:   aState->mShowHScrollbar = aAssumeHScroll;
    1:   aState->mShowVScrollbar = aAssumeVScroll;
    1:   nsPoint scrollPortOrigin(aState->mComputedBorder.left,
    1:                            aState->mComputedBorder.top);
    1:   if (!mInner.IsScrollbarOnRight()) {
    1:     scrollPortOrigin.x += vScrollbarActualWidth;
    1:   }
37083:   mInner.mScrollPort = nsRect(scrollPortOrigin, scrollPortSize);
    1:   return PR_TRUE;
    1: }
    1: 
12142: PRBool
12142: nsHTMLScrollFrame::ScrolledContentDependsOnHeight(ScrollReflowState* aState)
12142: {
12142:   // Return true if ReflowScrolledFrame is going to do something different
12142:   // based on the presence of a horizontal scrollbar.
12142:   return (mInner.mScrolledFrame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT) ||
12142:     aState->mReflowState.ComputedHeight() != NS_UNCONSTRAINEDSIZE ||
12142:     aState->mReflowState.mComputedMinHeight > 0 ||
12142:     aState->mReflowState.mComputedMaxHeight != NS_UNCONSTRAINEDSIZE;
12142: }
12142: 
    1: nsresult
 8731: nsHTMLScrollFrame::ReflowScrolledFrame(ScrollReflowState* aState,
    1:                                        PRBool aAssumeHScroll,
    1:                                        PRBool aAssumeVScroll,
    1:                                        nsHTMLReflowMetrics* aMetrics,
    1:                                        PRBool aFirstPass)
    1: {
32531:   // these could be NS_UNCONSTRAINEDSIZE ... NS_MIN arithmetic should
    1:   // be OK
 8731:   nscoord paddingLR = aState->mReflowState.mComputedPadding.LeftRight();
 8731: 
 8731:   nscoord availWidth = aState->mReflowState.ComputedWidth() + paddingLR;
 8731: 
 8731:   nscoord computedHeight = aState->mReflowState.ComputedHeight();
 8731:   nscoord computedMinHeight = aState->mReflowState.mComputedMinHeight;
 8731:   nscoord computedMaxHeight = aState->mReflowState.mComputedMaxHeight;
 8802:   if (!ShouldPropagateComputedHeightToScrolledContent()) {
 8802:     computedHeight = NS_UNCONSTRAINEDSIZE;
 8802:     computedMinHeight = 0;
 8802:     computedMaxHeight = NS_UNCONSTRAINEDSIZE;
 8802:   }
 8731:   if (aAssumeHScroll) {
 8731:     nsSize hScrollbarPrefSize = 
 8731:       mInner.mHScrollbarBox->GetPrefSize(const_cast<nsBoxLayoutState&>(aState->mBoxState));
 8731:     if (computedHeight != NS_UNCONSTRAINEDSIZE)
32531:       computedHeight = NS_MAX(0, computedHeight - hScrollbarPrefSize.height);
32531:     computedMinHeight = NS_MAX(0, computedMinHeight - hScrollbarPrefSize.height);
 8731:     if (computedMaxHeight != NS_UNCONSTRAINEDSIZE)
32531:       computedMaxHeight = NS_MAX(0, computedMaxHeight - hScrollbarPrefSize.height);
 8731:   }
    1: 
    1:   if (aAssumeVScroll) {
    1:     nsSize vScrollbarPrefSize = 
 8731:       mInner.mVScrollbarBox->GetPrefSize(const_cast<nsBoxLayoutState&>(aState->mBoxState));
32531:     availWidth = NS_MAX(0, availWidth - vScrollbarPrefSize.width);
    1:   }
    1: 
    1:   // We're forcing the padding on our scrolled frame, so let it know what that
    1:   // padding is.
    1:   mInner.mScrolledFrame->
    1:     SetProperty(nsGkAtoms::usedPaddingProperty,
 8731:                 new nsMargin(aState->mReflowState.mComputedPadding),
    1:                 nsCSSOffsetState::DestroyMarginFunc);  
    1:   
 6028:   nsPresContext* presContext = PresContext();
    1:   // Pass PR_FALSE for aInit so we can pass in the correct padding
 8731:   nsHTMLReflowState kidReflowState(presContext, aState->mReflowState,
    1:                                    mInner.mScrolledFrame,
    1:                                    nsSize(availWidth, NS_UNCONSTRAINEDSIZE),
    1:                                    -1, -1, PR_FALSE);
    1:   kidReflowState.Init(presContext, -1, -1, nsnull,
 8731:                       &aState->mReflowState.mComputedPadding);
    1:   kidReflowState.mFlags.mAssumingHScrollbar = aAssumeHScroll;
    1:   kidReflowState.mFlags.mAssumingVScrollbar = aAssumeVScroll;
 8731:   kidReflowState.SetComputedHeight(computedHeight);
 8731:   kidReflowState.mComputedMinHeight = computedMinHeight;
 8731:   kidReflowState.mComputedMaxHeight = computedMaxHeight;
    1: 
37292:   // Temporarily set mHasHorizontalScrollbar/mHasVerticalScrollbar to
37292:   // reflect our assumptions while we reflow the child.
37292:   PRBool didHaveHorizonalScrollbar = mInner.mHasHorizontalScrollbar;
37292:   PRBool didHaveVerticalScrollbar = mInner.mHasVerticalScrollbar;
37292:   mInner.mHasHorizontalScrollbar = aAssumeHScroll;
37292:   mInner.mHasVerticalScrollbar = aAssumeVScroll;
37292: 
    1:   nsReflowStatus status;
    1:   nsresult rv = ReflowChild(mInner.mScrolledFrame, presContext, *aMetrics,
    1:                             kidReflowState, 0, 0,
    1:                             NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_MOVE_VIEW, status);
37292: 
37292:   mInner.mHasHorizontalScrollbar = didHaveHorizonalScrollbar;
37292:   mInner.mHasVerticalScrollbar = didHaveVerticalScrollbar;
37292: 
37083:   // Don't resize or position the view (if any) because we're going to resize
    1:   // it to the correct size anyway in PlaceScrollArea. Allowing it to
    1:   // resize here would size it to the natural height of the frame,
    1:   // which will usually be different from the scrollport height;
    1:   // invalidating the difference will cause unnecessary repainting.
    1:   FinishReflowChild(mInner.mScrolledFrame, presContext,
    1:                     &kidReflowState, *aMetrics, 0, 0,
    1:                     NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_MOVE_VIEW | NS_FRAME_NO_SIZE_VIEW);
    1: 
    1:   // XXX Some frames (e.g., nsObjectFrame, nsFrameFrame, nsTextFrame) don't bother
    1:   // setting their mOverflowArea. This is wrong because every frame should
    1:   // always set mOverflowArea. In fact nsObjectFrame and nsFrameFrame don't
    1:   // support the 'outline' property because of this. Rather than fix the world
    1:   // right now, just fix up the overflow area if necessary. Note that we don't
26950:   // check HasOverflowRect() because it could be set even though the
    1:   // overflow area doesn't include the frame bounds.
    1:   aMetrics->mOverflowArea.UnionRect(aMetrics->mOverflowArea,
    1:                                     nsRect(0, 0, aMetrics->width, aMetrics->height));
    1: 
37083:   aState->mContentsOverflowArea = aMetrics->mOverflowArea;
 8731:   aState->mReflowedContentsWithHScrollbar = aAssumeHScroll;
 8731:   aState->mReflowedContentsWithVScrollbar = aAssumeVScroll;
 8731:   
    1:   return rv;
    1: }
    1: 
    1: PRBool
12142: nsHTMLScrollFrame::GuessHScrollbarNeeded(const ScrollReflowState& aState)
12142: {
12142:   if (aState.mStyles.mHorizontal != NS_STYLE_OVERFLOW_AUTO)
12142:     // no guessing required
12142:     return aState.mStyles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL;
12142: 
12142:   return mInner.mHasHorizontalScrollbar;
12142: }
12142: 
12142: PRBool
    1: nsHTMLScrollFrame::GuessVScrollbarNeeded(const ScrollReflowState& aState)
    1: {
    1:   if (aState.mStyles.mVertical != NS_STYLE_OVERFLOW_AUTO)
    1:     // no guessing required
    1:     return aState.mStyles.mVertical == NS_STYLE_OVERFLOW_SCROLL;
    1: 
    1:   // If we've had at least one non-initial reflow, then just assume
    1:   // the state of the vertical scrollbar will be what we determined
    1:   // last time.
    1:   if (mInner.mHadNonInitialReflow) {
    1:     return mInner.mHasVerticalScrollbar;
    1:   }
    1: 
    1:   // If this is the initial reflow, guess PR_FALSE because usually
    1:   // we have very little content by then.
  823:   if (InInitialReflow())
    1:     return PR_FALSE;
    1: 
    1:   if (mInner.mIsRoot) {
    1:     // For viewports, try getting a hint from global history
    1:     // as to whether we had a vertical scrollbar last time.
    1:     PRBool hint;
    1:     nsresult rv = mInner.GetVScrollbarHintFromGlobalHistory(&hint);
    1:     if (NS_SUCCEEDED(rv))
    1:       return hint;
    1:     // No hint. Assume that there will be a scrollbar; it seems to me
    1:     // that 'most pages' do have a scrollbar, and anyway, it's cheaper
    1:     // to do an extra reflow for the pages that *don't* need a
    1:     // scrollbar (because on average they will have less content).
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // For non-viewports, just guess that we don't need a scrollbar.
    1:   // XXX I wonder if statistically this is the right idea; I'm
    1:   // basically guessing that there are a lot of overflow:auto DIVs
    1:   // that get their intrinsic size and don't overflow
    1:   return PR_FALSE;
    1: }
    1: 
  823: PRBool
  823: nsHTMLScrollFrame::InInitialReflow() const
  823: {
  823:   // We're in an initial reflow if NS_FRAME_FIRST_REFLOW is set, unless we're a
  967:   // root scrollframe.  In that case we want to skip this clause altogether.
  967:   // The guess here is that there are lots of overflow:auto divs out there that
  967:   // end up auto-sizing so they don't overflow, and that the root basically
  967:   // always needs a scrollbar if it did last time we loaded this page (good
  967:   // assumption, because our initial reflow is no longer synchronous).
  967:   return !mInner.mIsRoot && (GetStateBits() & NS_FRAME_FIRST_REFLOW);
  823: }
  823: 
    1: nsresult
    1: nsHTMLScrollFrame::ReflowContents(ScrollReflowState* aState,
    1:                                   const nsHTMLReflowMetrics& aDesiredSize)
    1: {
    1:   nsHTMLReflowMetrics kidDesiredSize(aDesiredSize.mFlags);
12142:   nsresult rv = ReflowScrolledFrame(aState, GuessHScrollbarNeeded(*aState),
 8731:       GuessVScrollbarNeeded(*aState), &kidDesiredSize, PR_TRUE);
 8731:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // There's an important special case ... if the child appears to fit
    1:   // in the inside-border rect (but overflows the scrollport), we
    1:   // should try laying it out without a vertical scrollbar. It will
    1:   // usually fit because making the available-width wider will not
    1:   // normally make the child taller. (The only situation I can think
    1:   // of is when you have a line containing %-width inline replaced
    1:   // elements whose percentages sum to more than 100%, so increasing
    1:   // the available width makes the line break where it was fitting
    1:   // before.) If we don't treat this case specially, then we will
    1:   // decide that showing scrollbars is OK because the content
    1:   // overflows when we're showing scrollbars and we won't try to
    1:   // remove the vertical scrollbar.
    1: 
    1:   // Detecting when we enter this special case is important for when
    1:   // people design layouts that exactly fit the container "most of the
    1:   // time".
 8731: 
 8731:   // XXX Is this check really sufficient to catch all the incremental cases
 8731:   // where the ideal case doesn't have a scrollbar?
 8731:   if ((aState->mReflowedContentsWithHScrollbar || aState->mReflowedContentsWithVScrollbar) &&
    1:       aState->mStyles.mVertical != NS_STYLE_OVERFLOW_SCROLL &&
    1:       aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL) {
    1:     nsSize insideBorderSize =
    1:       ComputeInsideBorderSize(aState,
    1:                               nsSize(kidDesiredSize.width, kidDesiredSize.height));
37083:     nsRect scrolledRect =
37083:       mInner.GetScrolledRectInternal(kidDesiredSize.mOverflowArea, insideBorderSize);
    1:     if (nsRect(nsPoint(0, 0), insideBorderSize).Contains(scrolledRect)) {
 8731:       // Let's pretend we had no scrollbars coming in here
 8731:       rv = ReflowScrolledFrame(aState, PR_FALSE, PR_FALSE,
    1:                                &kidDesiredSize, PR_FALSE);
 8731:       NS_ENSURE_SUCCESS(rv, rv);
 8731:     }
 8731:   }
 8731: 
 8731:   // Try vertical scrollbar settings that leave the vertical scrollbar unchanged.
 8731:   // Do this first because changing the vertical scrollbar setting is expensive,
 8731:   // forcing a reflow always.
 8731: 
12142:   // Try leaving the horizontal scrollbar unchanged first. This will be more
12142:   // efficient.
12142:   if (TryLayout(aState, &kidDesiredSize, aState->mReflowedContentsWithHScrollbar,
 8731:                 aState->mReflowedContentsWithVScrollbar, PR_FALSE, &rv))
 8731:     return NS_OK;
12142:   if (TryLayout(aState, &kidDesiredSize, !aState->mReflowedContentsWithHScrollbar,
 8731:                 aState->mReflowedContentsWithVScrollbar, PR_FALSE, &rv))
 8731:     return NS_OK;
 8731: 
 8731:   // OK, now try toggling the vertical scrollbar. The performance advantage
12142:   // of trying the status-quo horizontal scrollbar state
 8731:   // does not exist here (we'll have to reflow due to the vertical scrollbar
 8731:   // change), so always try no horizontal scrollbar first.
 8731:   PRBool newVScrollbarState = !aState->mReflowedContentsWithVScrollbar;
 8731:   if (TryLayout(aState, &kidDesiredSize, PR_FALSE, newVScrollbarState, PR_FALSE, &rv))
 8731:     return NS_OK;
 8731:   if (TryLayout(aState, &kidDesiredSize, PR_TRUE, newVScrollbarState, PR_FALSE, &rv))
 8731:     return NS_OK;
 8731: 
 8941:   // OK, we're out of ideas. Try again enabling whatever scrollbars we can
 8941:   // enable and force the layout to stick even if it's inconsistent.
 8941:   // This just happens sometimes.
 8941:   TryLayout(aState, &kidDesiredSize,
 8941:             aState->mStyles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN,
 8941:             aState->mStyles.mVertical != NS_STYLE_OVERFLOW_HIDDEN,
 8941:             PR_TRUE, &rv);
 8523:   return rv;
    1: }
    1: 
    1: void
37083: nsHTMLScrollFrame::PlaceScrollArea(const ScrollReflowState& aState,
37083:                                    const nsPoint& aScrollPosition)
    1: {
    1:   nsIFrame *scrolledFrame = mInner.mScrolledFrame;
37083:   // Set the x,y of the scrolled frame to the correct value
37083:   scrolledFrame->SetPosition(mInner.mScrollPort.TopLeft() - aScrollPosition);
    1: 
    1:   nsRect scrolledArea;
12354:   // Preserve the width or height of empty rects
37083:   nsSize portSize = mInner.mScrollPort.Size();
37083:   nsRect scrolledRect = mInner.GetScrolledRectInternal(aState.mContentsOverflowArea, portSize);
37083:   scrolledArea.UnionRectIncludeEmpty(scrolledRect,
37083:                                      nsRect(nsPoint(0,0), portSize));
    1: 
    1:   // Store the new overflow area. Note that this changes where an outline
    1:   // of the scrolled frame would be painted, but scrolled frames can't have
    1:   // outlines (the outline would go on this scrollframe instead).
26950:   // Using FinishAndStoreOverflow is needed so the overflow rect
    1:   // gets set correctly.  It also messes with the overflow rect in the
    1:   // -moz-hidden-unscrollable case, but scrolled frames can't have
    1:   // 'overflow' either.
    1:   // This needs to happen before SyncFrameViewAfterReflow so
26950:   // HasOverflowRect() will return the correct value.
    1:   scrolledFrame->FinishAndStoreOverflow(&scrolledArea,
    1:                                         scrolledFrame->GetSize());
    1: 
    1:   // Note that making the view *exactly* the size of the scrolled area
    1:   // is critical, since the view scrolling code uses the size of the
    1:   // scrolled view to clamp scroll requests.
37083:   // Normally the scrolledFrame won't have a view but in some cases it
37083:   // might create its own.
  238:   nsContainerFrame::SyncFrameViewAfterReflow(scrolledFrame->PresContext(),
    1:                                              scrolledFrame,
37083:                                              scrolledFrame->GetView(),
    1:                                              &scrolledArea,
37083:                                              0);
    1: }
    1: 
12407: nscoord
12407: nsHTMLScrollFrame::GetIntrinsicVScrollbarWidth(nsIRenderingContext *aRenderingContext)
12407: {
12407:   nsGfxScrollFrameInner::ScrollbarStyles ss = GetScrollbarStyles();
12407:   if (ss.mVertical != NS_STYLE_OVERFLOW_SCROLL || !mInner.mVScrollbarBox)
12407:     return 0;
12407: 
14159:   // Don't need to worry about reflow depth here since it's
14159:   // just for scrollbars
14159:   nsBoxLayoutState bls(PresContext(), aRenderingContext, 0);
12407:   nsSize vScrollbarPrefSize(0, 0);
12407:   GetScrollbarMetrics(bls, mInner.mVScrollbarBox,
12407:                       nsnull, &vScrollbarPrefSize, PR_TRUE);
12407:   return vScrollbarPrefSize.width;
12407: }
12407: 
    1: /* virtual */ nscoord
    1: nsHTMLScrollFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
 8691:   nscoord result = mInner.mScrolledFrame->GetMinWidth(aRenderingContext);
    1:   DISPLAY_MIN_WIDTH(this, result);
12407:   return result + GetIntrinsicVScrollbarWidth(aRenderingContext);
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsHTMLScrollFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
12407:   nscoord result = mInner.mScrolledFrame->GetPrefWidth(aRenderingContext);
    1:   DISPLAY_PREF_WIDTH(this, result);
12407:   return NSCoordSaturatingAdd(result, GetIntrinsicVScrollbarWidth(aRenderingContext));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::GetPadding(nsMargin& aMargin)
    1: {
    1:   // Our padding hangs out on the inside of the scrollframe, but XUL doesn't
    1:   // reaize that.  If we're stuck inside a XUL box, we need to claim no
    1:   // padding.
    1:   // @see also nsXULScrollFrame::GetPadding.
    1:   aMargin.SizeTo(0,0,0,0);
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsHTMLScrollFrame::IsCollapsed(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   // We're never collapsed in the box sense.
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::Reflow(nsPresContext*           aPresContext,
    1:                           nsHTMLReflowMetrics&     aDesiredSize,
    1:                           const nsHTMLReflowState& aReflowState,
    1:                           nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsHTMLScrollFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   ScrollReflowState state(this, aReflowState);
    1:   // sanity check: ensure that if we have no scrollbar, we treat it
    1:   // as hidden.
    1:   if (!mInner.mVScrollbarBox || mInner.mNeverHasVerticalScrollbar)
    1:     state.mStyles.mVertical = NS_STYLE_OVERFLOW_HIDDEN;
    1:   if (!mInner.mHScrollbarBox || mInner.mNeverHasHorizontalScrollbar)
    1:     state.mStyles.mHorizontal = NS_STYLE_OVERFLOW_HIDDEN;
    1: 
    1:   //------------ Handle Incremental Reflow -----------------
    1:   PRBool reflowContents = PR_TRUE; // XXX Ignored
    1:   PRBool reflowHScrollbar = PR_TRUE;
    1:   PRBool reflowVScrollbar = PR_TRUE;
    1:   PRBool reflowScrollCorner = PR_TRUE;
    1:   if (!aReflowState.ShouldReflowAllKids()) {
    1:     #define NEEDS_REFLOW(frame_) \
 1158:       ((frame_) && NS_SUBTREE_DIRTY(frame_))
    1: 
    1:     reflowContents = NEEDS_REFLOW(mInner.mScrolledFrame);
    1:     reflowHScrollbar = NEEDS_REFLOW(mInner.mHScrollbarBox);
    1:     reflowVScrollbar = NEEDS_REFLOW(mInner.mVScrollbarBox);
    1:     reflowScrollCorner = NEEDS_REFLOW(mInner.mScrollCornerBox);
    1: 
    1:     #undef NEEDS_REFLOW
    1:   }
    1: 
37083:   nsRect oldScrollAreaBounds = mInner.mScrollPort;
37083:   nsRect oldScrolledAreaBounds =
37083:     mInner.mScrolledFrame->GetOverflowRectRelativeToParent();
37083:   // Adjust to a multiple of device pixels to restore the invariant that
37083:   // oldScrollPosition is a multiple of device pixels. This could have been
37083:   // thrown out by a zoom change.
37083:   nsIntPoint ptDevPx;
37083:   nsPoint oldScrollPosition =
37083:     mInner.ClampAndRestrictToDevPixels(mInner.GetScrollPosition(), &ptDevPx);
37083:   
    1:   state.mComputedBorder = aReflowState.mComputedBorderPadding -
    1:     aReflowState.mComputedPadding;
    1: 
    1:   nsresult rv = ReflowContents(&state, aDesiredSize);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
37083:   PlaceScrollArea(state, oldScrollPosition);
29508:   if (!mInner.mPostedReflowCallback) {
29508:     // Make sure we'll try scrolling to restored position
29508:     PresContext()->PresShell()->PostReflowCallback(&mInner);
29508:     mInner.mPostedReflowCallback = PR_TRUE;
29508:   }
    1: 
    1:   PRBool didHaveHScrollbar = mInner.mHasHorizontalScrollbar;
    1:   PRBool didHaveVScrollbar = mInner.mHasVerticalScrollbar;
    1:   mInner.mHasHorizontalScrollbar = state.mShowHScrollbar;
    1:   mInner.mHasVerticalScrollbar = state.mShowVScrollbar;
37083:   nsRect newScrollAreaBounds = mInner.mScrollPort;
37083:   nsRect newScrolledAreaBounds =
37083:     mInner.mScrolledFrame->GetOverflowRectRelativeToParent();
    1:   if (mInner.mSkippedScrollbarLayout ||
    1:       reflowHScrollbar || reflowVScrollbar || reflowScrollCorner ||
    1:       (GetStateBits() & NS_FRAME_IS_DIRTY) ||
    1:       didHaveHScrollbar != state.mShowHScrollbar ||
    1:       didHaveVScrollbar != state.mShowVScrollbar ||
    1:       oldScrollAreaBounds != newScrollAreaBounds ||
    1:       oldScrolledAreaBounds != newScrolledAreaBounds) {
    1:     if (!mInner.mSupppressScrollbarUpdate) {
    1:       mInner.mSkippedScrollbarLayout = PR_FALSE;
    1:       mInner.SetScrollbarVisibility(mInner.mHScrollbarBox, state.mShowHScrollbar);
    1:       mInner.SetScrollbarVisibility(mInner.mVScrollbarBox, state.mShowVScrollbar);
    1:       // place and reflow scrollbars
    1:       nsRect insideBorderArea =
    1:         nsRect(nsPoint(state.mComputedBorder.left, state.mComputedBorder.top),
    1:                state.mInsideBorderSize);
    1:       mInner.LayoutScrollbars(state.mBoxState, insideBorderArea,
37083:                               oldScrollAreaBounds);
    1:     } else {
    1:       mInner.mSkippedScrollbarLayout = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   aDesiredSize.width = state.mInsideBorderSize.width +
    1:     state.mComputedBorder.LeftRight();
    1:   aDesiredSize.height = state.mInsideBorderSize.height +
    1:     state.mComputedBorder.TopBottom();
    1: 
    1:   aDesiredSize.mOverflowArea = nsRect(0, 0, aDesiredSize.width, aDesiredSize.height);
35704: 
35704:   CheckInvalidateSizeChange(aDesiredSize);
35704: 
    1:   FinishAndStoreOverflow(&aDesiredSize);
    1: 
  823:   if (!InInitialReflow() && !mInner.mHadNonInitialReflow) {
    1:     mInner.mHadNonInitialReflow = PR_TRUE;
    1:     if (mInner.mIsRoot) {
    1:       // For viewports, record whether we needed a vertical scrollbar
    1:       // after the first non-initial reflow.
    1:       mInner.SaveVScrollbarStateToGlobalHistory();
    1:     }
    1:   }
    1: 
33011:   if (mInner.mIsRoot && oldScrolledAreaBounds != newScrolledAreaBounds) {
37084:     mInner.PostScrolledAreaEvent();
33011:   }
33011: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
 6722:   mInner.PostOverflowEvent();
    1:   return rv;
    1: }
    1: 
33011: 
33011: ////////////////////////////////////////////////////////////////////////////////
33011: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsHTMLScrollFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("HTMLScroll"), aResult);
    1: }
    1: #endif
    1: 
    1: #ifdef ACCESSIBILITY
    1: NS_IMETHODIMP nsHTMLScrollFrame::GetAccessible(nsIAccessible** aAccessible)
    1: {
    1:   *aAccessible = nsnull;
    1:   if (!IsFocusable()) {
    1:     return NS_OK;
    1:   }
    1:   // Focusable via CSS, so needs to be in accessibility hierarchy
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
 3233:     return accService->CreateHTMLGenericAccessible(static_cast<nsIFrame*>(this), aAccessible);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: #endif
    1: 
23554: NS_QUERYFRAME_HEAD(nsHTMLScrollFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsIScrollableFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsHTMLContainerFrame)
    1: 
    1: //----------nsXULScrollFrame-------------------------------------------
    1: 
    1: nsIFrame*
    1: NS_NewXULScrollFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot)
    1: {
    1:   return new (aPresShell) nsXULScrollFrame(aPresShell, aContext, aIsRoot);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsXULScrollFrame)
32423: 
    1: nsXULScrollFrame::nsXULScrollFrame(nsIPresShell* aShell, nsStyleContext* aContext, PRBool aIsRoot)
    1:   : nsBoxFrame(aShell, aContext, aIsRoot),
    1:     mInner(this, aIsRoot, PR_TRUE)
    1: {
    1:     SetLayoutManager(nsnull);
    1: }
    1: 
    1: nsMargin nsGfxScrollFrameInner::GetDesiredScrollbarSizes(nsBoxLayoutState* aState) {
    1:   NS_ASSERTION(aState && aState->GetRenderingContext(),
    1:                "Must have rendering context in layout state for size "
    1:                "computations");
    1:   
    1:   nsMargin result(0, 0, 0, 0);
    1: 
    1:   if (mVScrollbarBox) {
    1:     nsSize size = mVScrollbarBox->GetPrefSize(*aState);
    1:     if (IsScrollbarOnRight())
    1:       result.left = size.width;
    1:     else
    1:       result.right = size.width;
    1:   }
    1: 
    1:   if (mHScrollbarBox) {
    1:     nsSize size = mHScrollbarBox->GetPrefSize(*aState);
    1:     // We don't currently support any scripts that would require a scrollbar
    1:     // at the top. (Are there any?)
    1:     result.bottom = size.height;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsXULScrollFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
    1: {
    1:   return mInner.CreateAnonymousContent(aElements);
    1: }
    1: 
    1: void
36647: nsXULScrollFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   mInner.Destroy();
36647:   nsBoxFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                       nsFrameList&    aChildList)
    1: {
    1:   nsresult rv = nsBoxFrame::SetInitialChildList(aListName, aChildList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::AppendFrames(nsIAtom*        aListName,
30941:                                nsFrameList&    aFrameList)
    1: {
    1:   nsresult rv = nsBoxFrame::AppendFrames(aListName, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::InsertFrames(nsIAtom*        aListName,
    1:                                nsIFrame*       aPrevFrame,
30941:                                nsFrameList&    aFrameList)
    1: {
    1:   nsresult rv = nsBoxFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::RemoveFrame(nsIAtom*        aListName,
    1:                               nsIFrame*       aOldFrame)
    1: {
    1:   nsresult rv = nsBoxFrame::RemoveFrame(aListName, aOldFrame);
    1:   mInner.ReloadChildFrames();
    1:   return rv;
    1: }
    1: 
    1: nsSplittableType
    1: nsXULScrollFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_NOT_SPLITTABLE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::GetPadding(nsMargin& aMargin)
    1: {
    1:    aMargin.SizeTo(0,0,0,0);
    1:    return NS_OK;
    1: }
    1: 
    1: PRIntn
    1: nsXULScrollFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsIAtom*
    1: nsXULScrollFrame::GetType() const
    1: {
    1:   return nsGkAtoms::scrollFrame; 
    1: }
    1: 
15910: void
15910: nsXULScrollFrame::InvalidateInternal(const nsRect& aDamageRect,
15910:                                      nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                      PRUint32 aFlags)
15910: {
15910:   if (aForChild == mInner.mScrolledFrame) {
15910:     // restrict aDamageRect to the scrollable view's bounds
15910:     nsRect r;
37083:     if (r.IntersectRect(aDamageRect + nsPoint(aX, aY), mInner.mScrollPort)) {
19380:       nsBoxFrame::InvalidateInternal(r, 0, 0, aForChild, aFlags);
15910:     }
15910:     return;
15910:   }
15910:   
19380:   nsBoxFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aFlags);
15910: }
15910: 
    1: nscoord
    1: nsXULScrollFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
    1:   if (!mInner.mScrolledFrame)
    1:     return 0;
    1: 
    1:   nscoord ascent = mInner.mScrolledFrame->GetBoxAscent(aState);
    1:   nsMargin m(0,0,0,0);
    1:   GetBorderAndPadding(m);
    1:   ascent += m.top;
    1:   GetMargin(m);
    1:   ascent += m.top;
    1: 
    1:   return ascent;
    1: }
    1: 
    1: nsSize
    1: nsXULScrollFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
    1:   nsSize pref = mInner.mScrolledFrame->GetPrefSize(aState);
    1: 
    1:   nsGfxScrollFrameInner::ScrollbarStyles styles = GetScrollbarStyles();
    1: 
    1:   // scrolled frames don't have their own margins
    1: 
    1:   if (mInner.mVScrollbarBox &&
    1:       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {
    1:     nsSize vSize = mInner.mVScrollbarBox->GetPrefSize(aState);
    1:     pref.width += vSize.width;
    1:   }
    1:    
    1:   if (mInner.mHScrollbarBox &&
    1:       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {
    1:     nsSize hSize = mInner.mHScrollbarBox->GetPrefSize(aState);
    1:     pref.height += hSize.height;
    1:   }
    1: 
    1:   AddBorderAndPadding(pref);
    1:   nsIBox::AddCSSPrefSize(aState, this, pref);
    1:   return pref;
    1: }
    1: 
    1: nsSize
    1: nsXULScrollFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
    1:   nsSize min = mInner.mScrolledFrame->GetMinSizeForScrollArea(aState);
    1: 
    1:   nsGfxScrollFrameInner::ScrollbarStyles styles = GetScrollbarStyles();
    1:      
    1:   if (mInner.mVScrollbarBox &&
    1:       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {
    1:      nsSize vSize = mInner.mVScrollbarBox->GetMinSize(aState);
    1:      min.width += vSize.width;
    1:      if (min.height < vSize.height)
    1:         min.height = vSize.height;
    1:   }
    1:         
    1:   if (mInner.mHScrollbarBox &&
    1:       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {
    1:      nsSize hSize = mInner.mHScrollbarBox->GetMinSize(aState);
    1:      min.height += hSize.height;
    1:      if (min.width < hSize.width)
    1:         min.width = hSize.width;
    1:   }
    1: 
    1:   AddBorderAndPadding(min);
    1:   nsIBox::AddCSSMinSize(aState, this, min);
    1:   return min;
    1: }
    1: 
    1: nsSize
    1: nsXULScrollFrame::GetMaxSize(nsBoxLayoutState& aState)
    1: {
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
12306:   nsSize maxSize(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
12306: 
12306:   AddBorderAndPadding(maxSize);
12306:   nsIBox::AddCSSMaxSize(aState, this, maxSize);
12306:   return maxSize;
    1: }
    1: 
    1: #if 0 // XXXldb I don't think this is even needed
    1: /* virtual */ nscoord
    1: nsXULScrollFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nsStyleUnit widthUnit = GetStylePosition()->mWidth.GetUnit();
    1:   if (widthUnit == eStyleUnit_Percent || widthUnit == eStyleUnit_Auto) {
    1:     nsMargin border = aReflowState.mComputedBorderPadding;
    1:     aDesiredSize.mMaxElementWidth = border.right + border.left;
    1:     mMaxElementWidth = aDesiredSize.mMaxElementWidth;
    1:   } else {
    1:     NS_NOTYETIMPLEMENTED("Use the info from the scrolled frame");
    1: #if 0
    1:     // if not set then use the cached size. If set then set it.
    1:     if (aDesiredSize.mMaxElementWidth == -1)
    1:       aDesiredSize.mMaxElementWidth = mMaxElementWidth;
    1:     else
    1:       mMaxElementWidth = aDesiredSize.mMaxElementWidth;
    1: #endif
    1:   }
    1:   return 0;
    1: }
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("XULScroll"), aResult);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsXULScrollFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   PRUint32 flags = aState.LayoutFlags();
    1:   nsresult rv = Layout(aState);
    1:   aState.SetLayoutFlags(flags);
    1: 
    1:   nsBox::DoLayout(aState);
    1:   return rv;
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsXULScrollFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsIScrollableFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
    1:  
    1: //-------------------- Inner ----------------------
    1: 
37083: #define SMOOTH_SCROLL_MSECS_PER_FRAME 10
37083: #define SMOOTH_SCROLL_FRAMES    10
37083: 
37083: #define SMOOTH_SCROLL_PREF_NAME "general.smoothScroll"
37083: 
37083: class nsGfxScrollFrameInner::AsyncScroll {
37083: public:
37083:   AsyncScroll() {}
37083:   ~AsyncScroll() {
37083:     if (mScrollTimer) mScrollTimer->Cancel();
37083:   }
37083: 
37083:   nsCOMPtr<nsITimer> mScrollTimer;
37083:   PRInt32 mVelocities[SMOOTH_SCROLL_FRAMES*2];
37083:   PRInt32 mFrameIndex;
37083:   PRPackedBool mIsSmoothScroll;
37083: };
37083: 
37083: static void ComputeVelocities(PRInt32 aCurVelocity, nscoord aCurPos, nscoord aDstPos,
37083:                               PRInt32* aVelocities, PRInt32 aP2A)
37083: {
37083:   // scrolling always works in units of whole pixels. So compute velocities
37083:   // in pixels and then scale them up. This ensures, for example, that
37083:   // a 1-pixel scroll isn't broken into N frames of 1/N pixels each, each
37083:   // frame increment being rounded to 0 whole pixels.
37083:   aCurPos = NSAppUnitsToIntPixels(aCurPos, aP2A);
37083:   aDstPos = NSAppUnitsToIntPixels(aDstPos, aP2A);
37083: 
37083:   PRInt32 i;
37083:   PRInt32 direction = (aCurPos < aDstPos ? 1 : -1);
37083:   PRInt32 absDelta = (aDstPos - aCurPos)*direction;
37083:   PRInt32 baseVelocity = absDelta/SMOOTH_SCROLL_FRAMES;
37083: 
37083:   for (i = 0; i < SMOOTH_SCROLL_FRAMES; i++) {
37083:     aVelocities[i*2] = baseVelocity;
37083:   }
37083:   nscoord total = baseVelocity*SMOOTH_SCROLL_FRAMES;
37083:   for (i = 0; i < SMOOTH_SCROLL_FRAMES; i++) {
37083:     if (total < absDelta) {
37083:       aVelocities[i*2]++;
37083:       total++;
37083:     }
37083:   }
37083:   NS_ASSERTION(total == absDelta, "Invalid velocity sum");
37083: 
37083:   PRInt32 scale = NSIntPixelsToAppUnits(direction, aP2A);
37083:   for (i = 0; i < SMOOTH_SCROLL_FRAMES; i++) {
37083:     aVelocities[i*2] *= scale;
37083:   }
37083: }
37083: 
37083: static PRBool
37083: IsSmoothScrollingEnabled()
37083: {
37083:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
37083:   if (prefs) {
37083:     PRBool enabled;
37083:     nsresult rv = prefs->GetBoolPref(SMOOTH_SCROLL_PREF_NAME, &enabled);
37083:     if (NS_SUCCEEDED(rv)) {
37083:       return enabled;
37083:     }
37083:   }
37083:   return PR_FALSE;
37083: }
37083: 
    1: nsGfxScrollFrameInner::nsGfxScrollFrameInner(nsContainerFrame* aOuter,
    1:                                              PRBool aIsRoot,
    1:                                              PRBool aIsXUL)
37083:   : mHScrollbarBox(nsnull),
    1:     mVScrollbarBox(nsnull),
    1:     mScrolledFrame(nsnull),
    1:     mScrollCornerBox(nsnull),
    1:     mOuter(aOuter),
37083:     mAsyncScroll(nsnull),
37083:     mDestination(0, 0),
37083:     mRestorePos(-1, -1),
    1:     mLastPos(-1, -1),
    1:     mNeverHasVerticalScrollbar(PR_FALSE),
    1:     mNeverHasHorizontalScrollbar(PR_FALSE),
    1:     mHasVerticalScrollbar(PR_FALSE), 
    1:     mHasHorizontalScrollbar(PR_FALSE),
37083:     mFrameIsUpdatingScrollbar(PR_FALSE),
    1:     mDidHistoryRestore(PR_FALSE),
    1:     mIsRoot(aIsRoot),
    1:     mIsXUL(aIsXUL),
    1:     mSupppressScrollbarUpdate(PR_FALSE),
    1:     mSkippedScrollbarLayout(PR_FALSE),
    1:     mDidLoadHistoryVScrollbarHint(PR_FALSE),
    1:     mHistoryVScrollbarHint(PR_FALSE),
    1:     mHadNonInitialReflow(PR_FALSE),
    1:     mHorizontalOverflow(PR_FALSE),
    1:     mVerticalOverflow(PR_FALSE),
 9564:     mPostedReflowCallback(PR_FALSE),
29508:     mMayHaveDirtyFixedChildren(PR_FALSE),
29508:     mUpdateScrollbarAttributes(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsGfxScrollFrameInner::~nsGfxScrollFrameInner()
    1: {
37083:   delete mAsyncScroll;
37083: }
37083: 
37083: static nscoord
37083: Clamp(nscoord aLower, nscoord aVal, nscoord aUpper)
37083: {
37083:   if (aVal < aLower)
37083:     return aLower;
37083:   if (aVal > aUpper)
37083:     return aUpper;
37083:   return aVal;
37083: }
37083: 
37083: nsPoint
37083: nsGfxScrollFrameInner::ClampScrollPosition(const nsPoint& aPt) const
37083: {
37083:   nsRect range = GetScrollRange();
37083:   return nsPoint(Clamp(range.x, aPt.x, range.XMost()),
37083:                  Clamp(range.y, aPt.y, range.YMost()));
37083: }
37083: 
37083: /*
37083:  * Callback function from timer used in nsGfxScrollFrameInner::ScrollTo
37083:  */
37083: void
37083: nsGfxScrollFrameInner::AsyncScrollCallback(nsITimer *aTimer, void* anInstance)
37083: {
37083:   nsGfxScrollFrameInner* self = static_cast<nsGfxScrollFrameInner*>(anInstance);
37083:   if (!self || !self->mAsyncScroll)
37083:     return;
37083: 
37083:   if (self->mAsyncScroll->mIsSmoothScroll) {
37083:     // XXX this is crappy, the scroll position needs to be based on the
37083:     // current time
37083:     NS_ASSERTION(self->mAsyncScroll->mFrameIndex < SMOOTH_SCROLL_FRAMES,
37083:                  "Past last frame?");
37083:     nscoord* velocities =
37083:       &self->mAsyncScroll->mVelocities[self->mAsyncScroll->mFrameIndex*2];
37083:     nsPoint destination =
37083:       self->GetScrollPosition() + nsPoint(velocities[0], velocities[1]);        
37083: 
37083:     self->mAsyncScroll->mFrameIndex++;
37083:     if (self->mAsyncScroll->mFrameIndex >= SMOOTH_SCROLL_FRAMES) {
37083:       delete self->mAsyncScroll;
37083:       self->mAsyncScroll = nsnull;
37083:     }
37083: 
37083:     self->ScrollToImpl(destination);
37083:     // 'self' may be a dangling pointer here since ScrollToImpl may have destroyed it
37083:   } else {
37083:     delete self->mAsyncScroll;
37083:     self->mAsyncScroll = nsnull;
37083: 
37083:     self->ScrollToImpl(self->mDestination);
37083:     // 'self' may be a dangling pointer here since ScrollToImpl may have destroyed it
37083:   }
37083: }
37083: 
37083: /*
37083:  * this method wraps calls to ScrollToImpl(), either in one shot or incrementally,
37083:  *  based on the setting of the smooth scroll pref
37083:  */
37083: void
37083: nsGfxScrollFrameInner::ScrollTo(nsPoint aScrollPosition,
37083:                                 nsIScrollableFrame::ScrollMode aMode)
37083: {
37083:   mDestination = ClampScrollPosition(aScrollPosition);
37083: 
37083:   if (aMode == nsIScrollableFrame::INSTANT) {
37083:     // Asynchronous scrolling is not allowed, so we'll kill any existing
37083:     // async-scrolling process and do an instant scroll
37083:     delete mAsyncScroll;
37083:     mAsyncScroll = nsnull;
37083:     ScrollToImpl(mDestination);
37083:     return;
37083:   }
37083: 
37083:   PRInt32 currentVelocityX = 0;
37083:   PRInt32 currentVelocityY = 0;
37083:   PRBool isSmoothScroll = IsSmoothScrollingEnabled();
37083: 
37083:   if (mAsyncScroll) {
37083:     if (mAsyncScroll->mIsSmoothScroll) {
37083:       currentVelocityX = mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2];
37083:       currentVelocityY = mAsyncScroll->mVelocities[mAsyncScroll->mFrameIndex*2 + 1];
37083:     }
37083:   } else {
37083:     mAsyncScroll = new AsyncScroll;
37083:     if (mAsyncScroll) {
37083:       mAsyncScroll->mScrollTimer = do_CreateInstance("@mozilla.org/timer;1");
37083:       if (!mAsyncScroll->mScrollTimer) {
37083:         delete mAsyncScroll;
37083:         mAsyncScroll = nsnull;
37083:       }
37083:     }
37083:     if (!mAsyncScroll) {
37083:       // some allocation failed. Scroll the normal way.
37083:       ScrollToImpl(mDestination);
37083:       return;
37083:     }
37083:     if (isSmoothScroll) {
37083:       mAsyncScroll->mScrollTimer->InitWithFuncCallback(
37083:         AsyncScrollCallback, this, SMOOTH_SCROLL_MSECS_PER_FRAME,
37083:         nsITimer::TYPE_REPEATING_PRECISE);
37083:     } else {
37083:       mAsyncScroll->mScrollTimer->InitWithFuncCallback(
37083:         AsyncScrollCallback, this, 0, nsITimer::TYPE_ONE_SHOT);
37083:     }
37083:   }
37083: 
37083:   mAsyncScroll->mFrameIndex = 0;
37083:   mAsyncScroll->mIsSmoothScroll = isSmoothScroll;
37083: 
37083:   if (isSmoothScroll) {
37083:     PRInt32 p2a = mOuter->PresContext()->AppUnitsPerDevPixel();
37083: 
37083:     // compute velocity vectors
37083:     nsPoint currentPos = GetScrollPosition();
37083:     ComputeVelocities(currentVelocityX, currentPos.x, mDestination.x,
37083:                       mAsyncScroll->mVelocities, p2a);
37083:     ComputeVelocities(currentVelocityY, currentPos.y, mDestination.y,
37083:                       mAsyncScroll->mVelocities + 1, p2a);
37083:   }
37083: }
37083: 
37083: static void InvalidateWidgets(nsIView* aView)
37083: {
37083:   if (aView->HasWidget()) {
37083:     nsIWidget* widget = aView->GetWidget();
37083:     nsWindowType type;
37083:     widget->GetWindowType(type);
37083:     if (type != eWindowType_popup) {
37083:       // Force the widget and everything in it to repaint. We can't
37083:       // just use Invalidate because the widget might have child
37083:       // widgets and they wouldn't get updated. We can't call
37083:       // UpdateView(aView) because the area to be repainted might be
37083:       // outside aView's clipped bounds. This isn't the greatest way
37083:       // to achieve this, perhaps, but it works.
37083:       widget->Show(PR_FALSE);
37083:       widget->Show(PR_TRUE);
37083:     }
37083:     return;
37083:   }
37083: 
37083:   for (nsIView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
37083:     InvalidateWidgets(v);
37083:   }
37083: }
37083: 
37083: // We can't use nsContainerFrame::PositionChildViews here because
37083: // we don't want to invalidate views that have moved.
37083: // aInvalidateWidgets is set to true if we should invalidate the area
37083: // covered by every widget in the subtree.
37083: static void AdjustViewsAndWidgets(nsIFrame* aFrame,
37083:                                   PRBool aInvalidateWidgets)
37083: {
37083:   nsIView* view = aFrame->GetView();
37083:   if (view) {
37083:     nsPoint pt;
37083:     aFrame->GetParent()->GetClosestView(&pt);
37083:     pt += aFrame->GetPosition();
37083:     view->SetPosition(pt.x, pt.y);
37083: 
37083:     if (aInvalidateWidgets) {
37083:       InvalidateWidgets(view);
37083:     }
37083:     return;
37083:   }
37083: 
37083:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
37083:     return;
37083:   }
37083: 
37083:   nsIAtom* childListName = nsnull;
37083:   PRInt32  childListIndex = 0;
37083:   do {
37083:     // Recursively walk aFrame's child frames
37083:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
37083:     while (childFrame) {
37083:       AdjustViewsAndWidgets(childFrame, aInvalidateWidgets);
37083: 
37083:       // Get the next sibling child frame
37083:       childFrame = childFrame->GetNextSibling();
37083:     }
37083: 
37083:     // also process the additional child lists, but skip the popup list as the
37083:     // views for popups are not scrolled.
37083:     do {
37083:       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
37083:     } while (childListName == nsGkAtoms::popupList);
37083:   } while (childListName);
37083: }
37083: 
37083: /**
37083:  * Given aBlitRegion in appunits, create and return an nsRegion in
37083:  * device pixels that represents the device pixels whose centers are
37083:  * contained in aBlitRegion. Whatever appunit area was removed from
37083:  * aBlitRegion in that process is added to aRepaintRegion. An appunits
37083:  * version of the result is placed in aAppunitsBlitRegion.
37083:  * 
37083:  * We convert the blit region to pixels this way because in general
37083:  * frames touch the pixels whose centers are contained in the
37083:  * (possibly not pixel-aligned) frame bounds.
37083:  */
37083: static void
37083: ConvertBlitRegionToPixelRects(const nsRegion& aBlitRegion,
37083:                               nscoord aAppUnitsPerPixel,
37083:                               nsTArray<nsIntRect>* aPixelRects,
37083:                               nsRegion* aRepaintRegion,
37083:                               nsRegion* aAppunitsBlitRegion)
37083: {
37083:   const nsRect* r;
37083: 
37083:   aPixelRects->Clear();
37083:   aAppunitsBlitRegion->SetEmpty();
37083:   // The rectangles in aBlitRegion don't overlap so converting them via
37083:   // ToNearestPixels also produces a sequence of non-overlapping rectangles
37083:   for (nsRegionRectIterator iter(aBlitRegion); (r = iter.Next());) {
37083:     nsIntRect pixRect = r->ToNearestPixels(aAppUnitsPerPixel);
37083:     aPixelRects->AppendElement(pixRect);
37083:     aAppunitsBlitRegion->Or(*aAppunitsBlitRegion,
37083:                             pixRect.ToAppUnits(aAppUnitsPerPixel));
37083:   }
37083: 
37083:   nsRegion repaint;
37083:   repaint.Sub(aBlitRegion, *aAppunitsBlitRegion);
37083:   aRepaintRegion->Or(*aRepaintRegion, repaint);
37083: }
37083: 
37083: /**
37083:  * An nsTArray comparator that lets us sort nsIntRects by their right edge.
37083:  */
37083: class RightEdgeComparator {
37083: public:
37083:   /** @return True if the elements are equals; false otherwise. */
37083:   PRBool Equals(const nsIntRect& aA, const nsIntRect& aB) const
37083:   {
37083:     return aA.XMost() == aB.XMost();
37083:   }
37083:   /** @return True if (a < b); false otherwise. */
37083:   PRBool LessThan(const nsIntRect& aA, const nsIntRect& aB) const
37083:   {
37083:     return aA.XMost() < aB.XMost();
37083:   }
37083: };
37083: 
37083: // If aPixDelta has a negative component, flip aRect across the
37083: // axis in that direction. We do this so we can assume all scrolling is
37083: // down and to the right to simplify SortBlitRectsForCopy
37083: static nsIntRect
37083: FlipRect(const nsIntRect& aRect, nsIntPoint aPixDelta)
37083: {
37083:   nsIntRect r = aRect;
37083:   if (aPixDelta.x < 0) {
37083:     r.x = -r.XMost();
37083:   }
37083:   if (aPixDelta.y < 0) {
37083:     r.y = -r.YMost();
37083:   }
37083:   return r;
37083: }
37083: 
37083: // Sort aRects so that moving rectangle aRects[i] - aPixDelta to aRects[i]
37083: // will not cause the rectangle to overlap any rectangles that haven't
37083: // moved yet.
37083: // See http://weblogs.mozillazine.org/roc/archives/2009/08/homework_answer.html
37083: static void
37083: SortBlitRectsForCopy(nsIntPoint aPixDelta, nsTArray<nsIntRect>* aRects)
37083: {
37083:   nsTArray<nsIntRect> rects;
37083: 
37083:   for (PRUint32 i = 0; i < aRects->Length(); ++i) {
37083:     nsIntRect* r = &aRects->ElementAt(i);
37083:     nsIntRect rect =
37083:       FlipRect(nsIntRect(r->x, r->y, r->width, r->height), aPixDelta);
37083:     rects.AppendElement(rect);
37083:   }
37083:   rects.Sort(RightEdgeComparator());
37083: 
37083:   aRects->Clear();
37083:   // This could probably be improved a bit for some worst-case scenarios.
37083:   // But in common cases this should be very fast, and we shouldn't
37083:   // make it more complex unless we really need to.
37083:   while (!rects.IsEmpty()) {
37083:     PRInt32 i = rects.Length() - 1;
37083:     PRBool overlappedBelow;
37083:     do {
37083:       overlappedBelow = PR_FALSE;
37083:       const nsIntRect& rectI = rects[i];
37083:       // see if any rectangle < i overlaps rectI horizontally and is below
37083:       // rectI
37083:       for (PRInt32 j = i - 1; j >= 0; --j) {
37083:         if (rects[j].XMost() <= rectI.x) {
37083:           // No rectangle with index <= j can overlap rectI horizontally
37083:           break;
37083:         }
37083:         // Rectangle j overlaps rectI horizontally.
37083:         if (rects[j].y >= rectI.y) {
37083:           // Rectangle j is below rectangle i. This is the rightmost such
37083:           // rectangle, so set i to this rectangle and continue.
37083:           i = j;
37083:           overlappedBelow = PR_TRUE;
37083:           break;
37083:         }
37083:       }
37083:     } while (overlappedBelow); 
37083: 
37083:     // Rectangle i has no rectangles to the right or below.
37083:     // Flip it back before saving the result.
37083:     aRects->AppendElement(FlipRect(rects[i], aPixDelta));
37083:     rects.RemoveElementAt(i);
37083:   }
37083: }
37083: 
37083: static PRBool
37083: CanScrollWithBlitting(nsIFrame* aFrame)
37083: {
37083:   for (nsIFrame* f = aFrame; f; f = f->GetParent()) {
37083:     if (f->GetStyleDisplay()->HasTransform()) {
37083:       return PR_FALSE;
37083:     }
37083: #ifdef MOZ_SVG
37083:     if (nsSVGIntegrationUtils::UsingEffectsForFrame(f) ||
37083:         f->IsFrameOfType(nsIFrame::eSVG)) {
37083:       return PR_FALSE;
37083:     }
37083: #endif
37083:   }
37083:   return PR_TRUE;
37083: }
37083: 
37083: void nsGfxScrollFrameInner::ScrollVisual(nsIntPoint aPixDelta)
37083: {
37502:   nsRootPresContext* rootPresContext =
37502:     mOuter->PresContext()->GetRootPresContext();
37502:   if (!rootPresContext) {
37502:     return;
37502:   }
37083: 
37083:   nsPoint offsetToView;
37083:   nsPoint offsetToWidget;
37083:   nsIWidget* nearestWidget =
37083:     mOuter->GetClosestView(&offsetToView)->GetNearestWidget(&offsetToWidget);
37083:   nsPoint nearestWidgetOffset = offsetToView + offsetToWidget;
37083: 
37083:   nsTArray<nsIWidget::Configuration> configurations;
37083:   // Only update plugin configurations if we're going to scroll the
37083:   // root widget. Otherwise we must be in a popup or some other situation
37083:   // where we don't actually support windows plugins.
37083:   if (rootPresContext->FrameManager()->GetRootFrame()->GetWindow() == nearestWidget) {
37083:     rootPresContext->GetPluginGeometryUpdates(mOuter, &configurations);
37083:   }
37083: 
37083:   if (!nearestWidget ||
37083:       nearestWidget->GetTransparencyMode() == eTransparencyTransparent ||
37083:       !CanScrollWithBlitting(mOuter)) {
37083:     // Just invalidate the frame and adjust child widgets
37083:     // Recall that our widget's origin is at our bounds' top-left
37083:     if (nearestWidget) {
37083:       nearestWidget->ConfigureChildren(configurations);
37083:     }
37083:     AdjustViewsAndWidgets(mScrolledFrame, PR_FALSE);
37083:     // We need to call this after fixing up the widget and view positions
37083:     // to be consistent with the view and frame hierarchy.
37083:     mOuter->InvalidateWithFlags(mScrollPort,
37083:                                 nsIFrame::INVALIDATE_REASON_SCROLL_REPAINT);
37083:   } else {
37083:     nsIFrame* displayRoot = nsLayoutUtils::GetDisplayRootFrame(mOuter);
37083:     nsRegion blitRegion;
37083:     nsRegion repaintRegion;
37083:     nsPresContext* presContext = mOuter->PresContext();
37083:     nsPoint delta(presContext->DevPixelsToAppUnits(aPixDelta.x),
37083:                   presContext->DevPixelsToAppUnits(aPixDelta.y));
37083:     nsPoint offsetToDisplayRoot = mOuter->GetOffsetTo(displayRoot);
37083:     nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37083:     nsRect scrollPort =
37083:       (mScrollPort + offsetToDisplayRoot).ToNearestPixels(appUnitsPerDevPixel).
37083:       ToAppUnits(appUnitsPerDevPixel);
37083:     nsresult rv =
37083:       nsLayoutUtils::ComputeRepaintRegionForCopy(displayRoot, mScrolledFrame,
37083:                                                  delta, scrollPort,
37083:                                                  &blitRegion,
37083:                                                  &repaintRegion);
37083:     if (NS_FAILED(rv)) {
37083:       nearestWidget->ConfigureChildren(configurations);
37083:       AdjustViewsAndWidgets(mScrolledFrame, PR_FALSE);
37083:       mOuter->InvalidateWithFlags(mScrollPort,
37083:                                   nsIFrame::INVALIDATE_REASON_SCROLL_REPAINT);
37083:       return;
37083:     }
37083: 
37083:     blitRegion.MoveBy(nearestWidgetOffset - offsetToDisplayRoot);
37083:     repaintRegion.MoveBy(nearestWidgetOffset - offsetToDisplayRoot);
37083: 
37083:     // We're going to bit-blit.  Let the viewmanager know so it can
37083:     // adjust dirty regions appropriately.
37083:     nsIView* view = displayRoot->GetView();
37083:     NS_ASSERTION(view, "Display root has no view?");
37083:     nsIViewManager* vm = view->GetViewManager();
37083:     vm->WillBitBlit(view, mScrollPort + offsetToDisplayRoot, -delta);
37083: 
37083:     // innerPixRegion is in device pixels
37083:     nsTArray<nsIntRect> blitRects;
37083:     nsRegion blitRectsRegion;
37083:     ConvertBlitRegionToPixelRects(blitRegion,
37083:                                   appUnitsPerDevPixel,
37083:                                   &blitRects, &repaintRegion,
37083:                                   &blitRectsRegion);
37083:     SortBlitRectsForCopy(aPixDelta, &blitRects);
37083: 
37083:     nearestWidget->Scroll(aPixDelta, blitRects, configurations);
37083:     AdjustViewsAndWidgets(mScrolledFrame, PR_TRUE);
37083:     repaintRegion.MoveBy(-nearestWidgetOffset + offsetToDisplayRoot);
37088: 
37088:     {
37088:       // Block script execution. This suppresses event dispatching in
37088:       // PresShell::HandleEvent. We need to do this because Windows
37088:       // is evil and can dispatch WM_MOUSEACTIVATE messages during
37088:       // our call to ::UpdateWindow (in the presence of out-of-process
37088:       // plugins, it seems). We are not able to handle event dispatch
37088:       // here.
37088:       // No script runners should be added as we paint!
37088:       nsContentUtils::AddScriptBlockerAndPreventAddingRunners();
37083:       vm->UpdateViewAfterScroll(view, repaintRegion);
37088:       nsContentUtils::RemoveScriptBlocker();
37088:       // Nothing should run here on removing the blocker, since we
37088:       // prevented the addition of any script runners.
37088:     }
37083: 
37083:     nsIFrame* presContextRootFrame = presContext->FrameManager()->GetRootFrame();
37083:     if (nearestWidget == presContextRootFrame->GetWindow()) {
37083:       nsPoint offsetToPresContext = mOuter->GetOffsetTo(presContextRootFrame);
37083:       blitRectsRegion.MoveBy(-nearestWidgetOffset + offsetToPresContext);
37083:       repaintRegion.MoveBy(-offsetToDisplayRoot + offsetToPresContext);
37083:       presContext->NotifyInvalidateForScrolling(blitRectsRegion, repaintRegion);
37083:     }
37083:   }
37083: }
37083: 
37083: static PRInt32
37083: ClampInt(nscoord aLower, nscoord aVal, nscoord aUpper, nscoord aAppUnitsPerPixel)
37083: {
37083:   PRInt32 low = NSToIntCeil(float(aLower)/aAppUnitsPerPixel);
37083:   PRInt32 high = NSToIntFloor(float(aUpper)/aAppUnitsPerPixel);
37083:   PRInt32 v = NSToIntRound(float(aVal)/aAppUnitsPerPixel);
37083:   NS_ASSERTION(low <= high, "No integers in range; 0 is supposed to be in range");
37083:   if (v < low)
37083:     return low;
37083:   if (v > high)
37083:     return high;
37083:   return v;
37083: }
37083: 
37083: nsPoint
37083: nsGfxScrollFrameInner::ClampAndRestrictToDevPixels(const nsPoint& aPt,
37083:                                                    nsIntPoint* aPtDevPx) const
37083: {
37083:   nsPresContext* presContext = mOuter->PresContext();
37083:   nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37083:   // Convert to device pixels so we scroll to an integer offset of device
37083:   // pixels. But we also need to make sure that our position remains
37083:   // inside the allowed region.
37083:   nsRect scrollRange = GetScrollRange();
37083:   *aPtDevPx = nsIntPoint(ClampInt(scrollRange.x, aPt.x, scrollRange.XMost(), appUnitsPerDevPixel),
37083:                          ClampInt(scrollRange.y, aPt.y, scrollRange.YMost(), appUnitsPerDevPixel));
37083:   return nsPoint(NSIntPixelsToAppUnits(aPtDevPx->x, appUnitsPerDevPixel),
37083:                  NSIntPixelsToAppUnits(aPtDevPx->y, appUnitsPerDevPixel));
37083: }
37083: 
37083: void
37083: nsGfxScrollFrameInner::ScrollToImpl(nsPoint aPt)
37083: {
37083:   nsPresContext* presContext = mOuter->PresContext();
37083:   nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37083:   nsIntPoint ptDevPx;
37083:   nsPoint pt = ClampAndRestrictToDevPixels(aPt, &ptDevPx);
37083: 
37083:   nsPoint curPos = GetScrollPosition();
37083:   if (pt == curPos) {
37083:     return;
37083:   }
37083:   nsIntPoint curPosDevPx(NSAppUnitsToIntPixels(curPos.x, appUnitsPerDevPixel),
37083:                          NSAppUnitsToIntPixels(curPos.y, appUnitsPerDevPixel));
37083:   // We maintain the invariant that the scroll position is a multiple of device
37083:   // pixels.
37083:   NS_ASSERTION(curPosDevPx.x*appUnitsPerDevPixel == curPos.x,
37083:                "curPos.x not a multiple of device pixels");
37083:   NS_ASSERTION(curPosDevPx.y*appUnitsPerDevPixel == curPos.y,
37083:                "curPos.y not a multiple of device pixels");
37083: 
37083:   // notify the listeners.
37083:   for (PRInt32 i = 0; i < mListeners.Count(); i++) {
37083:     mListeners[i]->ScrollPositionWillChange(pt.x, pt.y);
37083:   }
37083:   
37083:   // Update frame position for scrolling
37083:   mScrolledFrame->SetPosition(mScrollPort.TopLeft() - pt);
37083: 
37083:   // We pass in the amount to move visually
37083:   ScrollVisual(curPosDevPx - ptDevPx);
37083: 
37083:   presContext->PresShell()->GetViewManager()->SynthesizeMouseMove(PR_TRUE);
37083:   UpdateScrollbarPosition();
37083:   PostScrollEvent();
37083: 
37083:   // notify the listeners.
37083:   for (PRInt32 i = 0; i < mListeners.Count(); i++) {
37083:     mListeners[i]->ScrollPositionDidChange(pt.x, pt.y);
37083:   }
37083: }
    1: 
    1: nsresult
    1: nsGfxScrollFrameInner::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                         const nsRect&           aDirtyRect,
    1:                                         const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = mOuter->DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   if (aBuilder->GetIgnoreScrollFrame() == mOuter) {
    1:     // Don't clip the scrolled child, and don't paint scrollbars/scrollcorner.
    1:     // The scrolled frame shouldn't have its own background/border, so we
26699:     // can just pass aLists directly.
26699:     return mOuter->BuildDisplayListForChild(aBuilder, mScrolledFrame,
26699:                                             aDirtyRect, aLists);
    1:   }
    1: 
25539:   // Now display the scrollbars and scrollcorner. These parts are drawn
25539:   // in the border-background layer, on top of our own background and
25539:   // borders and underneath borders and backgrounds of later elements
25539:   // in the tree.
25539:   nsIFrame* kid = mOuter->GetFirstChild(nsnull);
25539:   while (kid) {
25539:     if (kid != mScrolledFrame) {
25539:       rv = mOuter->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
25539:       NS_ENSURE_SUCCESS(rv, rv);
25539:     }
25539:     kid = kid->GetNextSibling();
25539:   }
25539: 
    1:   // Overflow clipping can never clip frames outside our subtree, so there
    1:   // is no need to worry about whether we are a moving frame that might clip
    1:   // non-moving frames.
    1:   nsRect dirtyRect;
    1:   // Not all our descendants will be clipped by overflow clipping, but all
    1:   // the ones that aren't clipped will be out of flow frames that have already
    1:   // had dirty rects saved for them by their parent frames calling
    1:   // MarkOutOfFlowChildrenForDisplayList, so it's safe to restrict our
    1:   // dirty rect here.
37083:   dirtyRect.IntersectRect(aDirtyRect, mScrollPort);
    1:   
    1:   nsDisplayListCollection set;
    1:   rv = mOuter->BuildDisplayListForChild(aBuilder, mScrolledFrame, dirtyRect, set);
    1:   NS_ENSURE_SUCCESS(rv, rv);
37083:   nsRect clip = mScrollPort + aBuilder->ToReferenceFrame(mOuter);
    1:   // mScrolledFrame may have given us a background, e.g., the scrolled canvas
    1:   // frame below the viewport. If so, we want it to be clipped. We also want
    1:   // to end up on our BorderBackground list.
    1:   // If we are the viewport scrollframe, then clip all our descendants (to ensure
    1:   // that fixed-pos elements get clipped by us).
    1:   rv = mOuter->OverflowClip(aBuilder, set, aLists, clip, PR_TRUE, mIsRoot);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void HandleScrollPref(nsIScrollable *aScrollable, PRInt32 aOrientation,
    1:                              PRUint8& aValue)
    1: {
    1:   PRInt32 pref;
    1:   aScrollable->GetDefaultScrollbarPreferences(aOrientation, &pref);
    1:   switch (pref) {
    1:     case nsIScrollable::Scrollbar_Auto:
    1:       // leave |aValue| untouched
    1:       break;
    1:     case nsIScrollable::Scrollbar_Never:
    1:       aValue = NS_STYLE_OVERFLOW_HIDDEN;
    1:       break;
    1:     case nsIScrollable::Scrollbar_Always:
    1:       aValue = NS_STYLE_OVERFLOW_SCROLL;
    1:       break;
    1:   }
    1: }
    1: 
    1: nsGfxScrollFrameInner::ScrollbarStyles
    1: nsGfxScrollFrameInner::GetScrollbarStylesFromFrame() const
    1: {
    1:   ScrollbarStyles result;
    1: 
  238:   nsPresContext* presContext = mOuter->PresContext();
    1:   if (!presContext->IsDynamic() &&
    1:       !(mIsRoot && presContext->HasPaginatedScrolling())) {
    1:     return ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN, NS_STYLE_OVERFLOW_HIDDEN);
    1:   }
    1: 
    1:   if (mIsRoot) {
    1:     result = presContext->GetViewportOverflowOverride();
    1: 
    1:     nsCOMPtr<nsISupports> container = presContext->GetContainer();
    1:     nsCOMPtr<nsIScrollable> scrollable = do_QueryInterface(container);
    1:     if (scrollable) {
    1:       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,
    1:                        result.mHorizontal);
    1:       HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_Y,
    1:                        result.mVertical);
    1:     }
    1:   } else {
    1:     const nsStyleDisplay *disp = mOuter->GetStyleDisplay();
    1:     result.mHorizontal = disp->mOverflowX;
    1:     result.mVertical = disp->mOverflowY;
    1:   }
    1: 
    1:   NS_ASSERTION(result.mHorizontal != NS_STYLE_OVERFLOW_VISIBLE &&
    1:                result.mHorizontal != NS_STYLE_OVERFLOW_CLIP &&
    1:                result.mVertical != NS_STYLE_OVERFLOW_VISIBLE &&
    1:                result.mVertical != NS_STYLE_OVERFLOW_CLIP,
    1:                "scrollbars should not have been created");
    1:   return result;
    1: }
    1: 
37055: static nscoord
37055: AlignToDevPixelRoundingToZero(nscoord aVal, PRInt32 aAppUnitsPerDevPixel)
37055: {
37055:   return (aVal/aAppUnitsPerDevPixel)*aAppUnitsPerDevPixel;
37055: }
37055: 
37055: nsRect
37055: nsGfxScrollFrameInner::GetScrollRange() const
37055: {
37083:   nsRect range = GetScrolledRect();
37083:   range.width -= mScrollPort.width;
37083:   range.height -= mScrollPort.height;
37055: 
37055:   nsPresContext* presContext = mOuter->PresContext();
37055:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37055:   range.width =
37055:     AlignToDevPixelRoundingToZero(range.XMost(), appUnitsPerDevPixel) - range.x;
37055:   range.height =
37055:     AlignToDevPixelRoundingToZero(range.YMost(), appUnitsPerDevPixel) - range.y;
37055:   range.x = AlignToDevPixelRoundingToZero(range.x, appUnitsPerDevPixel);
37055:   range.y = AlignToDevPixelRoundingToZero(range.y, appUnitsPerDevPixel);
37055:   return range;
37055: }
37055: 
37055: static void
37055: AdjustForWholeDelta(PRInt32 aDelta, nscoord* aCoord)
37055: {
37055:   if (aDelta < 0) {
37055:     *aCoord = nscoord_MIN;
37055:   } else if (aDelta > 0) {
37055:     *aCoord = nscoord_MAX;
37055:   }
37055: }
37055: 
37055: void
37055: nsGfxScrollFrameInner::ScrollBy(nsIntPoint aDelta,
37055:                                 nsIScrollableFrame::ScrollUnit aUnit,
37055:                                 nsIScrollableFrame::ScrollMode aMode,
37055:                                 nsIntPoint* aOverflow)
37055: {
37083:   nsSize deltaMultiplier;
37055:   switch (aUnit) {
37055:   case nsIScrollableFrame::DEVICE_PIXELS: {
37083:     nscoord appUnitsPerDevPixel =
37083:       mOuter->PresContext()->AppUnitsPerDevPixel();
37083:     deltaMultiplier = nsSize(appUnitsPerDevPixel, appUnitsPerDevPixel);
37055:     break;
37055:   }
37055:   case nsIScrollableFrame::LINES: {
37083:     deltaMultiplier = GetLineScrollAmount();
37055:     break;
37055:   }
37055:   case nsIScrollableFrame::PAGES: {
37083:     deltaMultiplier = GetPageScrollAmount();
37055:     break;
37055:   }
37055:   case nsIScrollableFrame::WHOLE: {
37055:     nsPoint pos = GetScrollPosition();
37055:     AdjustForWholeDelta(aDelta.x, &pos.x);
37055:     AdjustForWholeDelta(aDelta.y, &pos.y);
37055:     ScrollTo(pos, aMode);
37055:     if (aOverflow) {
37083:       *aOverflow = nsIntPoint(0, 0);
37083:     }
37083:     return;
37083:   }
37083:   default:
37083:     NS_ERROR("Invalid scroll mode");
37083:     return;
37083:   }
37083: 
37083:   nsPoint newPos = mDestination +
37083:     nsPoint(aDelta.x*deltaMultiplier.width, aDelta.y*deltaMultiplier.height);
37083:   ScrollTo(newPos, aMode);
37083: 
37083:   if (aOverflow) {
37083:     nsPoint clampAmount = mDestination - newPos;
37083:     float appUnitsPerDevPixel = mOuter->PresContext()->AppUnitsPerDevPixel();
37083:     *aOverflow = nsIntPoint(
37083:         NSAppUnitsToIntPixels(PR_ABS(clampAmount.x), appUnitsPerDevPixel),
37083:         NSAppUnitsToIntPixels(PR_ABS(clampAmount.y), appUnitsPerDevPixel));
37055:   }
37055: }
37055: 
37055: nsSize
37055: nsGfxScrollFrameInner::GetLineScrollAmount() const
37055: {
37083:   const nsStyleFont* font = mOuter->GetStyleFont();
37083:   const nsFont& f = font->mFont;
37083:   nsCOMPtr<nsIFontMetrics> fm = mOuter->PresContext()->GetMetricsFor(f);
37083:   NS_ASSERTION(fm, "FontMetrics is null, assuming fontHeight == 1 appunit");
37083:   nscoord fontHeight = 1;
37083:   if (fm) {
37083:     fm->GetHeight(fontHeight);
37083:   }
37083: 
37083:   return nsSize(fontHeight, fontHeight);
37055: }
37055: 
37055: nsSize
37055: nsGfxScrollFrameInner::GetPageScrollAmount() const
37055: {
37083:   nsSize lineScrollAmount = GetLineScrollAmount();
37083:   // The page increment is the size of the page, minus the smaller of
37083:   // 10% of the size or 2 lines.
37083:   return nsSize(
37083:     mScrollPort.width - NS_MIN(mScrollPort.width/10, 2*lineScrollAmount.width),
37083:     mScrollPort.height - NS_MIN(mScrollPort.height/10, 2*lineScrollAmount.height));
37055: }
37055: 
    1:   /**
    1:    * this code is resposible for restoring the scroll position back to some
    1:    * saved position. if the user has not moved the scroll position manually
    1:    * we keep scrolling down until we get to our original position. keep in
    1:    * mind that content could incrementally be coming in. we only want to stop
    1:    * when we reach our new position.
    1:    */
    1: void
    1: nsGfxScrollFrameInner::ScrollToRestoredPosition()
    1: {
37083:   if (mRestorePos.y == -1 || mLastPos.x == -1 || mLastPos.y == -1) {
    1:     return;
    1:   }
    1:   // make sure our scroll position did not change for where we last put
    1:   // it. if it does then the user must have moved it, and we no longer
    1:   // need to restore.
37083:   nsPoint scrollPos = GetScrollPosition();
    1: 
    1:   // if we didn't move, we still need to restore
37083:   if (scrollPos == mLastPos) {
37083:     // if our desired position is different to the scroll position, scroll.
    1:     // remember that we could be incrementally loading so we may enter
    1:     // and scroll many times.
37083:     if (mRestorePos != scrollPos) {
37083:       ScrollTo(mRestorePos, nsIScrollableFrame::INSTANT);
37083:       // Re-get the scroll position, it might not be exactly equal to
37083:       // mRestorePos due to rounding and clamping.
37083:       mLastPos = GetScrollPosition();
    1:     } else {
    1:       // if we reached the position then stop
37083:       mRestorePos.y = -1;
    1:       mLastPos.x = -1;
    1:       mLastPos.y = -1;
    1:     }
    1:   } else {
    1:     // user moved the position, so we won't need to restore
    1:     mLastPos.x = -1;
    1:     mLastPos.y = -1;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsGfxScrollFrameInner::FireScrollPortEvent()
    1: {
    1:   mAsyncScrollPortEvent.Forget();
 6722: 
 6722:   // Keep this in sync with PostOverflowEvent().
37083:   nsSize scrollportSize = mScrollPort.Size();
37083:   nsSize childSize = GetScrolledRect().Size();
    1: 
    1:   PRBool newVerticalOverflow = childSize.height > scrollportSize.height;
    1:   PRBool vertChanged = mVerticalOverflow != newVerticalOverflow;
    1: 
    1:   PRBool newHorizontalOverflow = childSize.width > scrollportSize.width;
    1:   PRBool horizChanged = mHorizontalOverflow != newHorizontalOverflow;
    1: 
    1:   if (!vertChanged && !horizChanged) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If both either overflowed or underflowed then we dispatch only one
    1:   // DOM event.
    1:   PRBool both = vertChanged && horizChanged &&
    1:                 newVerticalOverflow == newHorizontalOverflow;
    1:   nsScrollPortEvent::orientType orient;
    1:   if (both) {
    1:     orient = nsScrollPortEvent::both;
    1:     mHorizontalOverflow = newHorizontalOverflow;
    1:     mVerticalOverflow = newVerticalOverflow;
    1:   }
    1:   else if (vertChanged) {
    1:     orient = nsScrollPortEvent::vertical;
    1:     mVerticalOverflow = newVerticalOverflow;
    1:     if (horizChanged) {
    1:       // We need to dispatch a separate horizontal DOM event. Do that the next
    1:       // time around since dispatching the vertical DOM event might destroy
    1:       // the frame.
    1:       PostOverflowEvent();
    1:     }
    1:   }
    1:   else {
    1:     orient = nsScrollPortEvent::horizontal;
    1:     mHorizontalOverflow = newHorizontalOverflow;
    1:   }
    1: 
    1:   nsScrollPortEvent event(PR_TRUE,
    1:                           (orient == nsScrollPortEvent::horizontal ?
    1:                            mHorizontalOverflow : mVerticalOverflow) ?
    1:                             NS_SCROLLPORT_OVERFLOW : NS_SCROLLPORT_UNDERFLOW,
    1:                           nsnull);
    1:   event.orient = orient;
    1:   return nsEventDispatcher::Dispatch(mOuter->GetContent(),
  238:                                      mOuter->PresContext(), &event);
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::ReloadChildFrames()
    1: {
    1:   mScrolledFrame = nsnull;
    1:   mHScrollbarBox = nsnull;
    1:   mVScrollbarBox = nsnull;
    1:   mScrollCornerBox = nsnull;
    1: 
    1:   nsIFrame* frame = mOuter->GetFirstChild(nsnull);
    1:   while (frame) {
    1:     nsIContent* content = frame->GetContent();
    1:     if (content == mOuter->GetContent()) {
    1:       NS_ASSERTION(!mScrolledFrame, "Already found the scrolled frame");
    1:       mScrolledFrame = frame;
    1:     } else {
    1:       nsAutoString value;
    1:       content->GetAttr(kNameSpaceID_None, nsGkAtoms::orient, value);
    1:       if (!value.IsEmpty()) {
    1:         // probably a scrollbar then
    1:         if (value.LowerCaseEqualsLiteral("horizontal")) {
    1:           NS_ASSERTION(!mHScrollbarBox, "Found multiple horizontal scrollbars?");
    1:           mHScrollbarBox = frame;
    1:         } else {
    1:           NS_ASSERTION(!mVScrollbarBox, "Found multiple vertical scrollbars?");
    1:           mVScrollbarBox = frame;
    1:         }
    1:       } else {
    1:         // probably a scrollcorner
    1:         NS_ASSERTION(!mScrollCornerBox, "Found multiple scrollcorners");
    1:         mScrollCornerBox = frame;
    1:       }
    1:     }
    1: 
    1:     frame = frame->GetNextSibling();
    1:   }
    1: }
    1:   
    1: nsresult
    1: nsGfxScrollFrameInner::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
    1: {
  238:   nsPresContext* presContext = mOuter->PresContext();
    1:   nsIFrame* parent = mOuter->GetParent();
    1: 
    1:   // Don't create scrollbars if we're printing/print previewing
    1:   // Get rid of this code when printing moves to its own presentation
    1:   if (!presContext->IsDynamic()) {
    1:     // allow scrollbars if this is the child of the viewport, because
    1:     // we must be the scrollbars for the print preview window
    1:     if (!(mIsRoot && presContext->HasPaginatedScrolling())) {
    1:       mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
23554:   nsIScrollableFrame *scrollable = do_QueryFrame(mOuter);
    1: 
    1:   // At this stage in frame construction, the document element and/or
    1:   // BODY overflow styles have not yet been propagated to the
    1:   // viewport. So GetScrollbarStylesFromFrame called here will only
    1:   // take into account the scrollbar preferences set on the docshell.
    1:   // Thus if no scrollbar preferences are set on the docshell, we will
    1:   // always create scrollbars, which means later dynamic changes to
    1:   // propagated overflow styles will show or hide scrollbars on the
    1:   // viewport without requiring frame reconstruction of the viewport
    1:   // (good!).
    1: 
    1:   // XXX On the other hand, if scrolling="no" is set on the container
    1:   // we won't create scrollbars here so no scrollbars will ever be
    1:   // created even if the container's scrolling attribute is later
    1:   // changed. However, this has never been supported.
    1:   ScrollbarStyles styles = scrollable->GetScrollbarStyles();
    1:   PRBool canHaveHorizontal = styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN;
    1:   PRBool canHaveVertical = styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN;
    1:   if (!canHaveHorizontal && !canHaveVertical) {
    1:     // Nothing to do.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // The anonymous <div> used by <inputs> never gets scrollbars.
23554:   nsITextControlFrame* textFrame = do_QueryFrame(parent);
    1:   if (textFrame) {
    1:     // Make sure we are not a text area.
    1:     nsCOMPtr<nsIDOMHTMLTextAreaElement> textAreaElement(do_QueryInterface(parent->GetContent()));
    1:     if (!textAreaElement) {
    1:       mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsresult rv;
    1: 
    1:   nsNodeInfoManager *nodeInfoManager =
    1:     presContext->Document()->NodeInfoManager();
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::scrollbar, nsnull,
19197:                                           kNameSpaceID_XUL);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (canHaveHorizontal) {
    1:     rv = NS_NewElement(getter_AddRefs(mHScrollbarContent),
14437:                        kNameSpaceID_XUL, nodeInfo, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mHScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
    1:                                 NS_LITERAL_STRING("horizontal"), PR_FALSE);
    1:     if (!aElements.AppendElement(mHScrollbarContent))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (canHaveVertical) {
    1:     rv = NS_NewElement(getter_AddRefs(mVScrollbarContent),
14437:                        kNameSpaceID_XUL, nodeInfo, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mVScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::orient,
    1:                                 NS_LITERAL_STRING("vertical"), PR_FALSE);
    1:     if (!aElements.AppendElement(mVScrollbarContent))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (canHaveHorizontal && canHaveVertical) {
19197:     nodeInfo = nodeInfoManager->GetNodeInfo(nsGkAtoms::scrollcorner, nsnull,
19197:                                             kNameSpaceID_XUL);
    1:     rv = NS_NewElement(getter_AddRefs(mScrollCornerContent),
14437:                        kNameSpaceID_XUL, nodeInfo, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (!aElements.AppendElement(mScrollCornerContent))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::Destroy()
    1: {
    1:   // Unbind any content created in CreateAnonymousContent from the tree
    1:   nsContentUtils::DestroyAnonymousContent(&mHScrollbarContent);
    1:   nsContentUtils::DestroyAnonymousContent(&mVScrollbarContent);
    1:   nsContentUtils::DestroyAnonymousContent(&mScrollCornerContent);
    1: 
    1:   if (mPostedReflowCallback) {
  238:     mOuter->PresContext()->PresShell()->CancelReflowCallback(this);
    1:     mPostedReflowCallback = PR_FALSE;
    1:   }
    1: }
    1: 
    1: /**
    1:  * Called when we want to update the scrollbar position, either because scrolling happened
    1:  * or the user moved the scrollbar position and we need to undo that (e.g., when the user
    1:  * clicks to scroll and we're using smooth scrolling, so we need to put the thumb back
    1:  * to its initial position for the start of the smooth sequence).
    1:  */
    1: void
37083: nsGfxScrollFrameInner::UpdateScrollbarPosition()
    1: {
37083:   mFrameIsUpdatingScrollbar = PR_TRUE;
37083: 
37083:   nsPoint pt = GetScrollPosition();
37083:   if (mVScrollbarBox) {
    1:     SetCoordAttribute(mVScrollbarBox->GetContent(), nsGkAtoms::curpos,
37083:                       pt.y - GetScrolledRect().y);
37083:   }
37083:   if (mHScrollbarBox) {
    1:     SetCoordAttribute(mHScrollbarBox->GetContent(), nsGkAtoms::curpos,
37083:                       pt.x - GetScrolledRect().x);
37083:   }
37083: 
37083:   mFrameIsUpdatingScrollbar = PR_FALSE;
    1: }
    1: 
    1: void nsGfxScrollFrameInner::CurPosAttributeChanged(nsIContent* aContent)
    1: {
    1:   NS_ASSERTION(aContent, "aContent must not be null");
    1:   NS_ASSERTION((mHScrollbarBox && mHScrollbarBox->GetContent() == aContent) ||
    1:                (mVScrollbarBox && mVScrollbarBox->GetContent() == aContent),
    1:                "unexpected child");
    1: 
    1:   // Attribute changes on the scrollbars happen in one of three ways:
    1:   // 1) The scrollbar changed the attribute in response to some user event
    1:   // 2) We changed the attribute in response to a ScrollPositionDidChange
    1:   // callback from the scrolling view
    1:   // 3) We changed the attribute to adjust the scrollbars for the start
    1:   // of a smooth scroll operation
    1:   //
37083:   // In cases 2 and 3 we do not need to scroll because we're just
37083:   // updating our scrollbar.
37083:   if (mFrameIsUpdatingScrollbar)
37083:     return;
37083: 
37083:   nsRect scrolledRect = GetScrolledRect();
    1: 
    1:   nscoord x = GetCoordAttribute(mHScrollbarBox, nsGkAtoms::curpos,
    1:                                 -scrolledRect.x) +
    1:               scrolledRect.x;
    1:   nscoord y = GetCoordAttribute(mVScrollbarBox, nsGkAtoms::curpos,
    1:                                 -scrolledRect.y) +
    1:               scrolledRect.y;
    1: 
    1:   PRBool isSmooth = aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::smooth);
    1:   if (isSmooth) {
    1:     // Make sure an attribute-setting callback occurs even if the view
    1:     // didn't actually move yet.  We need to make sure other listeners
    1:     // see that the scroll position is not (yet) what they thought it
    1:     // was.
37083:     UpdateScrollbarPosition();
37083:   }
37083:   ScrollTo(nsPoint(x, y),
37083:            isSmooth ? nsIScrollableFrame::SMOOTH : nsIScrollableFrame::INSTANT);
    1: }
    1: 
    1: /* ============= Scroll events ========== */
    1: 
    1: NS_IMETHODIMP
    1: nsGfxScrollFrameInner::ScrollEvent::Run()
    1: {
    1:   if (mInner)
    1:     mInner->FireScrollEvent();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::FireScrollEvent()
    1: {
    1:   mScrollEvent.Forget();
    1: 
    1:   nsScrollbarEvent event(PR_TRUE, NS_SCROLL_EVENT, nsnull);
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsIContent* content = mOuter->GetContent();
  238:   nsPresContext* prescontext = mOuter->PresContext();
    1:   // Fire viewport scroll events at the document (where they
    1:   // will bubble to the window)
    1:   if (mIsRoot) {
    1:     nsIDocument* doc = content->GetCurrentDoc();
    1:     if (doc) {
    1:       nsEventDispatcher::Dispatch(doc, prescontext, &event, nsnull,  &status);
    1:     }
    1:   } else {
    1:     // scroll events fired at elements don't bubble (although scroll events
    1:     // fired at documents do, to the window)
    1:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1:     nsEventDispatcher::Dispatch(content, prescontext, &event, nsnull, &status);
    1:   }
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::PostScrollEvent()
    1: {
    1:   if (mScrollEvent.IsPending())
    1:     return;
    1: 
    1:   nsRefPtr<ScrollEvent> ev = new ScrollEvent(this);
    1:   if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
    1:     NS_WARNING("failed to dispatch ScrollEvent");
    1:   } else {
    1:     mScrollEvent = ev;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGfxScrollFrameInner::AsyncScrollPortEvent::Run()
    1: {
  514:   if (mInner) {
  514:     mInner->mOuter->PresContext()->GetPresShell()->
27993:       FlushPendingNotifications(Flush_InterruptibleLayout);
  514:   }
    1:   return mInner ? mInner->FireScrollPortEvent() : NS_OK;
    1: }
    1: 
    1: PRBool
37083: nsXULScrollFrame::AddHorizontalScrollbar(nsBoxLayoutState& aState, PRBool aOnTop)
    1: {
    1:   if (!mInner.mHScrollbarBox)
    1:     return PR_TRUE;
    1: 
37083:   return AddRemoveScrollbar(aState, aOnTop, PR_TRUE, PR_TRUE);
    1: }
    1: 
    1: PRBool
37083: nsXULScrollFrame::AddVerticalScrollbar(nsBoxLayoutState& aState, PRBool aOnRight)
    1: {
    1:   if (!mInner.mVScrollbarBox)
    1:     return PR_TRUE;
    1: 
37083:   return AddRemoveScrollbar(aState, aOnRight, PR_FALSE, PR_TRUE);
    1: }
    1: 
    1: void
37083: nsXULScrollFrame::RemoveHorizontalScrollbar(nsBoxLayoutState& aState, PRBool aOnTop)
    1: {
    1:   // removing a scrollbar should always fit
    1: #ifdef DEBUG
    1:   PRBool result =
    1: #endif
37083:   AddRemoveScrollbar(aState, aOnTop, PR_TRUE, PR_FALSE);
    1:   NS_ASSERTION(result, "Removing horizontal scrollbar failed to fit??");
    1: }
    1: 
    1: void
37083: nsXULScrollFrame::RemoveVerticalScrollbar(nsBoxLayoutState& aState, PRBool aOnRight)
    1: {
    1:   // removing a scrollbar should always fit
    1: #ifdef DEBUG
    1:   PRBool result =
    1: #endif
37083:   AddRemoveScrollbar(aState, aOnRight, PR_FALSE, PR_FALSE);
    1:   NS_ASSERTION(result, "Removing vertical scrollbar failed to fit??");
    1: }
    1: 
    1: PRBool
37083: nsXULScrollFrame::AddRemoveScrollbar(nsBoxLayoutState& aState,
    1:                                      PRBool aOnTop, PRBool aHorizontal, PRBool aAdd)
    1: {
    1:   if (aHorizontal) {
    1:      if (mInner.mNeverHasHorizontalScrollbar || !mInner.mHScrollbarBox)
    1:        return PR_FALSE;
    1: 
    1:      nsSize hSize = mInner.mHScrollbarBox->GetPrefSize(aState);
    1: 
    1:      mInner.SetScrollbarVisibility(mInner.mHScrollbarBox, aAdd);
    1: 
    1:      PRBool hasHorizontalScrollbar;
37083:      PRBool fit = AddRemoveScrollbar(hasHorizontalScrollbar,
37083:                                      mInner.mScrollPort.y,
37083:                                      mInner.mScrollPort.height,
37083:                                      hSize.height, aOnTop, aAdd);
    1:      mInner.mHasHorizontalScrollbar = hasHorizontalScrollbar;    // because mHasHorizontalScrollbar is a PRPackedBool
    1:      if (!fit)
    1:         mInner.SetScrollbarVisibility(mInner.mHScrollbarBox, !aAdd);
    1: 
    1:      return fit;
    1:   } else {
    1:      if (mInner.mNeverHasVerticalScrollbar || !mInner.mVScrollbarBox)
    1:        return PR_FALSE;
    1: 
    1:      nsSize vSize = mInner.mVScrollbarBox->GetPrefSize(aState);
    1: 
    1:      mInner.SetScrollbarVisibility(mInner.mVScrollbarBox, aAdd);
    1: 
    1:      PRBool hasVerticalScrollbar;
37083:      PRBool fit = AddRemoveScrollbar(hasVerticalScrollbar,
37083:                                      mInner.mScrollPort.x,
37083:                                      mInner.mScrollPort.width,
37083:                                      vSize.width, aOnTop, aAdd);
    1:      mInner.mHasVerticalScrollbar = hasVerticalScrollbar;    // because mHasVerticalScrollbar is a PRPackedBool
    1:      if (!fit)
    1:         mInner.SetScrollbarVisibility(mInner.mVScrollbarBox, !aAdd);
    1: 
    1:      return fit;
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsXULScrollFrame::AddRemoveScrollbar(PRBool& aHasScrollbar, nscoord& aXY,
    1:                                      nscoord& aSize, nscoord aSbSize,
    1:                                      PRBool aRightOrBottom, PRBool aAdd)
    1: { 
    1:    nscoord size = aSize;
    1:    nscoord xy = aXY;
    1: 
    1:    if (size != NS_INTRINSICSIZE) {
    1:      if (aAdd) {
    1:         size -= aSbSize;
    1:         if (!aRightOrBottom && size >= 0)
    1:           xy += aSbSize;
    1:      } else {
    1:         size += aSbSize;
    1:         if (!aRightOrBottom)
    1:           xy -= aSbSize;
    1:      }
    1:    }
    1: 
    1:    // not enough room? Yes? Return true.
    1:    if (size >= 0) {
    1:        aHasScrollbar = aAdd;
    1:        aSize = size;
    1:        aXY = xy;
    1:        return PR_TRUE;
    1:    }
    1: 
    1:    aHasScrollbar = PR_FALSE;
    1:    return PR_FALSE;
    1: }
    1: 
    1: void
37083: nsXULScrollFrame::LayoutScrollArea(nsBoxLayoutState& aState,
37083:                                    const nsPoint& aScrollPosition)
    1: {
    1:   PRUint32 oldflags = aState.LayoutFlags();
37083:   nsRect childRect = nsRect(mInner.mScrollPort.TopLeft() - aScrollPosition,
37083:                             mInner.mScrollPort.Size());
    1:   PRInt32 flags = NS_FRAME_NO_MOVE_VIEW;
    1: 
    1:   nsSize minSize = mInner.mScrolledFrame->GetMinSize(aState);
    1:   
    1:   if (minSize.height > childRect.height)
    1:     childRect.height = minSize.height;
    1:   
    1:   if (minSize.width > childRect.width)
    1:     childRect.width = minSize.width;
    1: 
    1:   aState.SetLayoutFlags(flags);
    1:   mInner.mScrolledFrame->SetBounds(aState, childRect);
    1:   mInner.mScrolledFrame->Layout(aState);
    1: 
    1:   childRect = mInner.mScrolledFrame->GetRect();
    1: 
37083:   if (childRect.width < mInner.mScrollPort.width ||
37083:       childRect.height < mInner.mScrollPort.height)
    1:   {
37083:     childRect.width = NS_MAX(childRect.width, mInner.mScrollPort.width);
37083:     childRect.height = NS_MAX(childRect.height, mInner.mScrollPort.height);
    1: 
    1:     // remove overflow area when we update the bounds,
    1:     // because we've already accounted for it
  189:     mInner.mScrolledFrame->SetBounds(aState, childRect);
26950:     mInner.mScrolledFrame->ClearOverflowRect();
    1:   }
    1: 
    1:   aState.SetLayoutFlags(oldflags);
    1: 
    1: }
    1: 
    1: void nsGfxScrollFrameInner::PostOverflowEvent()
    1: {
    1:   if (mAsyncScrollPortEvent.IsPending())
    1:     return;
    1: 
 6722:   // Keep this in sync with FireScrollPortEvent().
37083:   nsSize scrollportSize = mScrollPort.Size();
37083:   nsSize childSize = GetScrolledRect().Size();
 6722: 
 6722:   PRBool newVerticalOverflow = childSize.height > scrollportSize.height;
 6722:   PRBool vertChanged = mVerticalOverflow != newVerticalOverflow;
 6722: 
 6722:   PRBool newHorizontalOverflow = childSize.width > scrollportSize.width;
 6722:   PRBool horizChanged = mHorizontalOverflow != newHorizontalOverflow;
 6722: 
 6722:   if (!vertChanged && !horizChanged) {
 6722:     return;
 6722:   }
 6722: 
    1:   nsRefPtr<AsyncScrollPortEvent> ev = new AsyncScrollPortEvent(this);
    1:   if (NS_SUCCEEDED(NS_DispatchToCurrentThread(ev)))
    1:     mAsyncScrollPortEvent = ev;
    1: }
    1: 
    1: PRBool
    1: nsGfxScrollFrameInner::IsLTR() const
    1: {
    1:   //TODO make bidi code set these from preferences
    1: 
    1:   nsIFrame *frame = mOuter;
    1:   // XXX This is a bit on the slow side.
    1:   if (mIsRoot) {
    1:     // If we're the root scrollframe, we need the root element's style data.
  238:     nsPresContext *presContext = mOuter->PresContext();
    1:     nsIDocument *document = presContext->Document();
    1:     nsIContent *root = document->GetRootContent();
    1: 
    1:     // But for HTML we want the body element.
11877:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(document);
11875:     if (htmlDoc) {
11877:       nsIContent *bodyContent = htmlDoc->GetBodyContentExternal();
    1:       if (bodyContent)
    1:         root = bodyContent; // we can trust the document to hold on to it
    1:     }
    1: 
    1:     if (root) {
36656:       nsIFrame *rootsFrame = root->GetPrimaryFrame();
    1:       if (rootsFrame)
    1:         frame = rootsFrame;
    1:     }
    1:   }
    1: 
    1:   return frame->GetStyleVisibility()->mDirection != NS_STYLE_DIRECTION_RTL;
    1: }
    1: 
    1: PRBool
    1: nsGfxScrollFrameInner::IsScrollbarOnRight() const
    1: {
  238:   nsPresContext *presContext = mOuter->PresContext();
    1:   switch (presContext->GetCachedIntPref(kPresContext_ScrollbarSide)) {
    1:     default:
    1:     case 0: // UI directionality
    1:       return presContext->GetCachedIntPref(kPresContext_BidiDirection)
    1:              == IBMBIDI_TEXTDIRECTION_LTR;
    1:     case 1: // Document / content directionality
    1:       return IsLTR();
    1:     case 2: // Always right
    1:       return PR_TRUE;
    1:     case 3: // Always left
    1:       return PR_FALSE;
    1:   }
    1: }
    1: 
    1: /**
    1:  * Reflow the scroll area if it needs it and return its size. Also determine if the reflow will
    1:  * cause any of the scrollbars to need to be reflowed.
    1:  */
    1: nsresult
    1: nsXULScrollFrame::Layout(nsBoxLayoutState& aState)
    1: {
    1:   PRBool scrollbarRight = mInner.IsScrollbarOnRight();
    1:   PRBool scrollbarBottom = PR_TRUE;
    1: 
    1:   // get the content rect
    1:   nsRect clientRect(0,0,0,0);
    1:   GetClientRect(clientRect);
    1: 
37083:   nsRect oldScrollAreaBounds = mInner.mScrollPort;
37083:   nsPoint oldScrollPosition = mInner.GetScrollPosition();
37083: 
    1:   // the scroll area size starts off as big as our content area
37083:   mInner.mScrollPort = clientRect;
    1: 
    1:   /**************
    1:    Our basic strategy here is to first try laying out the content with
    1:    the scrollbars in their current state. We're hoping that that will
    1:    just "work"; the content will overflow wherever there's a scrollbar
    1:    already visible. If that does work, then there's no need to lay out
    1:    the scrollarea. Otherwise we fix up the scrollbars; first we add a
    1:    vertical one to scroll the content if necessary, or remove it if
    1:    it's not needed. Then we reflow the content if the scrollbar
    1:    changed.  Then we add a horizontal scrollbar if necessary (or
    1:    remove if not needed), and if that changed, we reflow the content
    1:    again. At this point, any scrollbars that are needed to scroll the
    1:    content have been added.
    1: 
    1:    In the second phase we check to see if any scrollbars are too small
    1:    to display, and if so, we remove them. We check the horizontal
    1:    scrollbar first; removing it might make room for the vertical
    1:    scrollbar, and if we have room for just one scrollbar we'll save
    1:    the vertical one.
    1: 
    1:    Finally we position and size the scrollbars and scrollcorner (the
    1:    square that is needed in the corner of the window when two
    1:    scrollbars are visible), and reflow any fixed position views
    1:    (if we're the viewport and we added or removed a scrollbar).
    1:    **************/
    1: 
    1:   ScrollbarStyles styles = GetScrollbarStyles();
    1: 
    1:   // Look at our style do we always have vertical or horizontal scrollbars?
    1:   if (styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL)
    1:      mInner.mHasHorizontalScrollbar = PR_TRUE;
    1:   if (styles.mVertical == NS_STYLE_OVERFLOW_SCROLL)
    1:      mInner.mHasVerticalScrollbar = PR_TRUE;
    1: 
    1:   if (mInner.mHasHorizontalScrollbar)
37083:      AddHorizontalScrollbar(aState, scrollbarBottom);
    1: 
    1:   if (mInner.mHasVerticalScrollbar)
37083:      AddVerticalScrollbar(aState, scrollbarRight);
    1:      
    1:   // layout our the scroll area
37083:   LayoutScrollArea(aState, oldScrollPosition);
    1:   
    1:   // now look at the content area and see if we need scrollbars or not
    1:   PRBool needsLayout = PR_FALSE;
    1: 
    1:   // if we have 'auto' scrollbars look at the vertical case
    1:   if (styles.mVertical != NS_STYLE_OVERFLOW_SCROLL) {
    1:     // These are only good until the call to LayoutScrollArea.
37083:     nsRect scrolledRect = mInner.GetScrolledRect();
    1:     nsSize scrolledContentSize(scrolledRect.XMost(), scrolledRect.YMost());
    1: 
    1:     // There are two cases to consider
37083:       if (scrolledContentSize.height <= mInner.mScrollPort.height
    1:           || styles.mVertical != NS_STYLE_OVERFLOW_AUTO) {
    1:         if (mInner.mHasVerticalScrollbar) {
    1:           // We left room for the vertical scrollbar, but it's not needed;
    1:           // remove it.
37083:           RemoveVerticalScrollbar(aState, scrollbarRight);
    1:           needsLayout = PR_TRUE;
    1:         }
    1:       } else {
    1:         if (!mInner.mHasVerticalScrollbar) {
    1:           // We didn't leave room for the vertical scrollbar, but it turns
    1:           // out we needed it
37083:           if (AddVerticalScrollbar(aState, scrollbarRight))
    1:             needsLayout = PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     // ok layout at the right size
    1:     if (needsLayout) {
    1:        nsBoxLayoutState resizeState(aState);
37083:        LayoutScrollArea(resizeState, oldScrollPosition);
    1:        needsLayout = PR_FALSE;
    1:     }
    1:   }
    1: 
    1: 
    1:   // if scrollbars are auto look at the horizontal case
    1:   if (styles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL)
    1:   {
    1:     // These are only good until the call to LayoutScrollArea.
37083:     nsRect scrolledRect = mInner.GetScrolledRect();
    1:     nsSize scrolledContentSize(scrolledRect.XMost(), scrolledRect.YMost());
    1: 
    1:     // if the child is wider that the scroll area
    1:     // and we don't have a scrollbar add one.
37083:     if (scrolledContentSize.width > mInner.mScrollPort.width
    1:         && styles.mHorizontal == NS_STYLE_OVERFLOW_AUTO) {
    1: 
    1:       if (!mInner.mHasHorizontalScrollbar) {
    1:            // no scrollbar? 
37083:           if (AddHorizontalScrollbar(aState, scrollbarBottom))
    1:              needsLayout = PR_TRUE;
    1: 
16050:            // if we added a horizontal scrollbar and we did not have a vertical
16050:            // there is a chance that by adding the horizontal scrollbar we will
    1:            // suddenly need a vertical scrollbar. Is a special case but its 
    1:            // important.
    1:            //if (!mHasVerticalScrollbar && scrolledContentSize.height > scrollAreaRect.height - sbSize.height)
    1:            //  printf("****Gfx Scrollbar Special case hit!!*****\n");
    1:            
    1:       }
    1:     } else {
    1:         // if the area is smaller or equal to and we have a scrollbar then
    1:         // remove it.
    1:       if (mInner.mHasHorizontalScrollbar) {
37083:         RemoveHorizontalScrollbar(aState, scrollbarBottom);
    1:         needsLayout = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // we only need to set the rect. The inner child stays the same size.
    1:   if (needsLayout) {
    1:      nsBoxLayoutState resizeState(aState);
37083:      LayoutScrollArea(resizeState, oldScrollPosition);
    1:      needsLayout = PR_FALSE;
    1:   }
    1:     
    1:   // get the preferred size of the scrollbars
    1:   nsSize hMinSize(0, 0);
    1:   if (mInner.mHScrollbarBox && mInner.mHasHorizontalScrollbar) {
    1:     GetScrollbarMetrics(aState, mInner.mHScrollbarBox, &hMinSize, nsnull, PR_FALSE);
    1:   }
    1:   nsSize vMinSize(0, 0);
    1:   if (mInner.mVScrollbarBox && mInner.mHasVerticalScrollbar) {
    1:     GetScrollbarMetrics(aState, mInner.mVScrollbarBox, &vMinSize, nsnull, PR_TRUE);
    1:   }
    1: 
    1:   // Disable scrollbars that are too small
    1:   // Disable horizontal scrollbar first. If we have to disable only one
    1:   // scrollbar, we'd rather keep the vertical scrollbar.
    1:   // Note that we always give horizontal scrollbars their preferred height,
    1:   // never their min-height. So check that there's room for the preferred height.
    1:   if (mInner.mHasHorizontalScrollbar &&
    1:       (hMinSize.width > clientRect.width - vMinSize.width
    1:        || hMinSize.height > clientRect.height)) {
37083:     RemoveHorizontalScrollbar(aState, scrollbarBottom);
    1:     needsLayout = PR_TRUE;
    1:   }
    1:   // Now disable vertical scrollbar if necessary
    1:   if (mInner.mHasVerticalScrollbar &&
    1:       (vMinSize.height > clientRect.height - hMinSize.height
    1:        || vMinSize.width > clientRect.width)) {
37083:     RemoveVerticalScrollbar(aState, scrollbarRight);
    1:     needsLayout = PR_TRUE;
    1:   }
    1: 
    1:   // we only need to set the rect. The inner child stays the same size.
    1:   if (needsLayout) {
    1:     nsBoxLayoutState resizeState(aState);
37083:     LayoutScrollArea(resizeState, oldScrollPosition);
    1:   }
    1: 
    1:   if (!mInner.mSupppressScrollbarUpdate) { 
37083:     mInner.LayoutScrollbars(aState, clientRect, oldScrollAreaBounds);
    1:   }
29508:   if (!mInner.mPostedReflowCallback) {
29508:     // Make sure we'll try scrolling to restored position
29508:     PresContext()->PresShell()->PostReflowCallback(&mInner);
29508:     mInner.mPostedReflowCallback = PR_TRUE;
29508:   }
    1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
    1:     mInner.mHadNonInitialReflow = PR_TRUE;
    1:   }
    1: 
    1:   mInner.PostOverflowEvent();
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::FinishReflowForScrollbar(nsIContent* aContent,
    1:                                                 nscoord aMinXY, nscoord aMaxXY,
    1:                                                 nscoord aCurPosXY,
    1:                                                 nscoord aPageIncrement,
    1:                                                 nscoord aIncrement)
    1: {
    1:   // Scrollbars assume zero is the minimum position, so translate for them.
    1:   SetCoordAttribute(aContent, nsGkAtoms::curpos, aCurPosXY - aMinXY);
    1:   SetScrollbarEnabled(aContent, aMaxXY - aMinXY);
    1:   SetCoordAttribute(aContent, nsGkAtoms::maxpos, aMaxXY - aMinXY);
    1:   SetCoordAttribute(aContent, nsGkAtoms::pageincrement, aPageIncrement);
    1:   SetCoordAttribute(aContent, nsGkAtoms::increment, aIncrement);
    1: }
    1: 
    1: PRBool
    1: nsGfxScrollFrameInner::ReflowFinished()
    1: {
    1:   mPostedReflowCallback = PR_FALSE;
    1: 
29508:   ScrollToRestoredPosition();
29508: 
29508:   if (NS_SUBTREE_DIRTY(mOuter) || !mUpdateScrollbarAttributes)
29108:     return PR_FALSE;
29108: 
29508:   mUpdateScrollbarAttributes = PR_FALSE;
29508: 
29108:   // Update scrollbar attributes.
29108:   nsPresContext* presContext = mOuter->PresContext();
29108: 
 9564:   if (mMayHaveDirtyFixedChildren) {
 9564:     mMayHaveDirtyFixedChildren = PR_FALSE;
 9564:     nsIFrame* parentFrame = mOuter->GetParent();
 9564:     for (nsIFrame* fixedChild =
 9564:            parentFrame->GetFirstChild(nsGkAtoms::fixedList);
 9564:          fixedChild; fixedChild = fixedChild->GetNextSibling()) {
 9564:       // force a reflow of the fixed child
29108:       presContext->PresShell()->
 9564:         FrameNeedsReflow(fixedChild, nsIPresShell::eResize,
 9564:                          NS_FRAME_HAS_DIRTY_CHILDREN);
 9564:     }
 9564:   }
 9564: 
37083:   nsRect scrolledContentRect = GetScrolledRect();
    1:   nscoord minX = scrolledContentRect.x;
37083:   nscoord maxX = scrolledContentRect.XMost() - mScrollPort.width;
    1:   nscoord minY = scrolledContentRect.y;
37083:   nscoord maxY = scrolledContentRect.YMost() - mScrollPort.height;
    1: 
    1:   // Suppress handling of the curpos attribute changes we make here.
37083:   NS_ASSERTION(!mFrameIsUpdatingScrollbar, "We shouldn't be reentering here");
37083:   mFrameIsUpdatingScrollbar = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIContent> vScroll =
    1:     mVScrollbarBox ? mVScrollbarBox->GetContent() : nsnull;
    1:   nsCOMPtr<nsIContent> hScroll =
    1:     mHScrollbarBox ? mHScrollbarBox->GetContent() : nsnull;
    1: 
    1:   // Note, in some cases mOuter may get deleted while finishing reflow
    1:   // for scrollbars.
    1:   if (vScroll || hScroll) {
    1:     nsWeakFrame weakFrame(mOuter);
37083:     nsPoint scrollPos = GetScrollPosition();
37083:     // XXX shouldn't we use GetPageScrollAmount/GetLineScrollAmount here?
    1:     if (vScroll) {
37083:       nscoord fontHeight = GetLineScrollAmount().height;
12167:       // We normally use (scrollArea.height - fontHeight) for height
12167:       // of page scrolling.  However, it is too small when
12167:       // fontHeight is very large. (If fontHeight is larger than
12167:       // scrollArea.height, direction of scrolling will be opposite).
12167:       // To avoid it, we use (float(scrollArea.height) * 0.8) as
12167:       // lower bound value of height of page scrolling. (bug 383267)
37083:       nscoord pageincrement = nscoord(mScrollPort.height - fontHeight);
37083:       nscoord pageincrementMin = nscoord(float(mScrollPort.height) * 0.8);
37083:       FinishReflowForScrollbar(vScroll, minY, maxY, scrollPos.y,
32531:                                NS_MAX(pageincrement,pageincrementMin),
    1:                                fontHeight);
    1:     }
    1:     if (hScroll) {
37083:       FinishReflowForScrollbar(hScroll, minX, maxX, scrollPos.x,
37083:                                nscoord(float(mScrollPort.width) * 0.8),
    1:                                nsPresContext::CSSPixelsToAppUnits(10));
    1:     }
    1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), PR_FALSE);
    1:   }
    1: 
37083:   mFrameIsUpdatingScrollbar = PR_FALSE;
    1:   // We used to rely on the curpos attribute changes above to scroll the
    1:   // view.  However, for scrolling to the left of the viewport, we
    1:   // rescale the curpos attribute, which means that operations like
    1:   // resizing the window while it is scrolled all the way to the left
    1:   // hold the curpos attribute constant at 0 while still requiring
    1:   // scrolling.  So we suppress the effect of the changes above with
37083:   // mFrameIsUpdatingScrollbar and call CurPosAttributeChanged here.
    1:   // (It actually even works some of the time without this, thanks to
    1:   // nsSliderFrame::AttributeChanged's handling of maxpos, but not when
    1:   // we hide the scrollbar on a large size change, such as
    1:   // maximization.)
    1:   if (!mHScrollbarBox && !mVScrollbarBox)
    1:     return PR_FALSE;
    1:   CurPosAttributeChanged(mVScrollbarBox ? mVScrollbarBox->GetContent()
    1:                                         : mHScrollbarBox->GetContent());
    1:   return PR_TRUE;
    1: }
    1: 
 8509: void
 8509: nsGfxScrollFrameInner::ReflowCallbackCanceled()
 8509: {
 8509:   mPostedReflowCallback = PR_FALSE;
 8509: }
 8509: 
  189: static void LayoutAndInvalidate(nsBoxLayoutState& aState,
  189:                                 nsIFrame* aBox, const nsRect& aRect)
  189: {
  189:   // When a child box changes shape of position, the parent
  189:   // is responsible for invalidation; the overflow rect must be invalidated
37175:   // to make sure to catch any overflow.
37175:   // We invalidate the parent (i.e. the scrollframe) directly, because
37175:   // invalidates coming from scrollbars are suppressed by nsHTMLScrollFrame when
37175:   // mHasVScrollbar/mHasHScrollbar is false, and this is called after those
37175:   // flags have been set ... if a scrollbar is being hidden, we still need
37175:   // to invalidate the scrollbar area here.
  189:   PRBool rectChanged = aBox->GetRect() != aRect;
37175:   if (rectChanged) {
37175:     aBox->GetParent()->Invalidate(aBox->GetOverflowRect() + aBox->GetPosition());
37175:   }
  189:   nsBoxFrame::LayoutChildAt(aState, aBox, aRect);
37175:   if (rectChanged) {
37175:     aBox->GetParent()->Invalidate(aBox->GetOverflowRect() + aBox->GetPosition());
37175:   }
  189: }
  189: 
37083: static void AdjustScrollbarRect(nsIFrame* aFrame, nsPresContext* aPresContext,
16520:                                 nsRect& aRect, PRBool aVertical)
16520: {
16520:   if ((aVertical ? aRect.width : aRect.height) == 0)
16520:     return;
16520: 
37083:   nsPoint offsetToView;
37083:   nsPoint offsetToWidget;
37083:   nsIWidget* widget =
37083:     aFrame->GetClosestView(&offsetToView)->GetNearestWidget(&offsetToWidget);
37083:   nsPoint offset = offsetToView + offsetToWidget;
16520:   nsIntRect widgetRect;
37083:   if (!widget || !widget->ShowsResizeIndicator(&widgetRect))
16520:     return;
16520: 
16520:   nsRect resizerRect =
16520:       nsRect(aPresContext->DevPixelsToAppUnits(widgetRect.x) - offset.x,
16520:              aPresContext->DevPixelsToAppUnits(widgetRect.y) - offset.y,
16520:              aPresContext->DevPixelsToAppUnits(widgetRect.width),
16520:              aPresContext->DevPixelsToAppUnits(widgetRect.height));
16520: 
33453:   if (!resizerRect.Contains(aRect.BottomRight() - nsPoint(1, 1)))
16520:     return;
16520: 
16520:   if (aVertical)
32531:     aRect.height = NS_MAX(0, resizerRect.y - aRect.y);
16520:   else
32531:     aRect.width = NS_MAX(0, resizerRect.x - aRect.x);
16520: }
16520: 
    1: void
    1: nsGfxScrollFrameInner::LayoutScrollbars(nsBoxLayoutState& aState,
    1:                                         const nsRect& aContentArea,
37083:                                         const nsRect& aOldScrollArea)
    1: {
    1:   NS_ASSERTION(!mSupppressScrollbarUpdate,
    1:                "This should have been suppressed");
    1: 
16520:   nsPresContext* presContext = mScrolledFrame->PresContext();
    1:   if (mVScrollbarBox) {
    1:     NS_PRECONDITION(mVScrollbarBox->IsBoxFrame(), "Must be a box frame!");
37083:     nsRect vRect(mScrollPort);
37083:     vRect.width = aContentArea.width - mScrollPort.width;
37083:     vRect.x = IsScrollbarOnRight() ? mScrollPort.XMost() : aContentArea.x;
37293: #ifdef DEBUG
    1:     nsMargin margin;
    1:     mVScrollbarBox->GetMargin(margin);
37293:     NS_ASSERTION(margin == nsMargin(0,0,0,0), "Scrollbar margin not supported");
37293: #endif
37083:     AdjustScrollbarRect(mOuter, presContext, vRect, PR_TRUE);
  189:     LayoutAndInvalidate(aState, mVScrollbarBox, vRect);
    1:   }
    1: 
    1:   if (mHScrollbarBox) {
    1:     NS_PRECONDITION(mHScrollbarBox->IsBoxFrame(), "Must be a box frame!");
37083:     nsRect hRect(mScrollPort);
37083:     hRect.height = aContentArea.height - mScrollPort.height;
37083:     hRect.y = PR_TRUE ? mScrollPort.YMost() : aContentArea.y;
37293: #ifdef DEBUG
    1:     nsMargin margin;
    1:     mHScrollbarBox->GetMargin(margin);
37293:     NS_ASSERTION(margin == nsMargin(0,0,0,0), "Scrollbar margin not supported");
37293: #endif
37083:     AdjustScrollbarRect(mOuter, presContext, hRect, PR_FALSE);
  189:     LayoutAndInvalidate(aState, mHScrollbarBox, hRect);
    1:   }
    1: 
    1:   // place the scrollcorner
    1:   if (mScrollCornerBox) {
    1:     NS_PRECONDITION(mScrollCornerBox->IsBoxFrame(), "Must be a box frame!");
    1:     nsRect r(0, 0, 0, 0);
37083:     if (aContentArea.x != mScrollPort.x) {
    1:       // scrollbar (if any) on left
    1:       r.x = aContentArea.x;
37083:       r.width = mScrollPort.x - aContentArea.x;
    1:       NS_ASSERTION(r.width >= 0, "Scroll area should be inside client rect");
    1:     } else {
    1:       // scrollbar (if any) on right
37083:       r.x = mScrollPort.XMost();
37083:       r.width = aContentArea.XMost() - mScrollPort.XMost();
    1:       NS_ASSERTION(r.width >= 0, "Scroll area should be inside client rect");
    1:     }
37083:     if (aContentArea.y != mScrollPort.y) {
    1:       // scrollbar (if any) on top
    1:       r.y = aContentArea.y;
37083:       r.height = mScrollPort.y - aContentArea.y;
    1:       NS_ASSERTION(r.height >= 0, "Scroll area should be inside client rect");
    1:     } else {
    1:       // scrollbar (if any) on bottom
37083:       r.y = mScrollPort.YMost();
37083:       r.height = aContentArea.YMost() - mScrollPort.YMost();
    1:       NS_ASSERTION(r.height >= 0, "Scroll area should be inside client rect");
    1:     }
  189:     LayoutAndInvalidate(aState, mScrollCornerBox, r);
    1:   }
    1: 
    1:   // may need to update fixed position children of the viewport,
    1:   // if the client area changed size because of an incremental
    1:   // reflow of a descendant.  (If the outer frame is dirty, the fixed
    1:   // children will be re-laid out anyway)
37083:   if (aOldScrollArea.Size() != mScrollPort.Size() && 
    1:       !(mOuter->GetStateBits() & NS_FRAME_IS_DIRTY) &&
    1:       mIsRoot) {
 9564:     mMayHaveDirtyFixedChildren = PR_TRUE;
    1:   }
    1:   
    1:   // post reflow callback to modify scrollbar attributes
29508:   mUpdateScrollbarAttributes = PR_TRUE;
    1:   if (!mPostedReflowCallback) {
    1:     aState.PresContext()->PresShell()->PostReflowCallback(this);
    1:     mPostedReflowCallback = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::SetScrollbarEnabled(nsIContent* aContent, nscoord aMaxPos)
    1: {
    1:   if (aMaxPos) {
    1:     aContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, PR_TRUE);
    1:   } else {
    1:     aContent->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled,
    1:                       NS_LITERAL_STRING("true"), PR_TRUE);
    1:   }
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::SetCoordAttribute(nsIContent* aContent, nsIAtom* aAtom,
    1:                                          nscoord aSize)
    1: {
    1:   // convert to pixels
    1:   aSize = nsPresContext::AppUnitsToIntCSSPixels(aSize);
    1: 
    1:   // only set the attribute if it changed.
    1: 
    1:   nsAutoString newValue;
    1:   newValue.AppendInt(aSize);
    1: 
    1:   if (aContent->AttrValueIs(kNameSpaceID_None, aAtom, newValue, eCaseMatters))
    1:     return;
    1: 
    1:   aContent->SetAttr(kNameSpaceID_None, aAtom, newValue, PR_TRUE);
    1: }
    1: 
    1: nsRect
37083: nsGfxScrollFrameInner::GetScrolledRect() const
    1: {
37083:   nsRect result =
37083:     GetScrolledRectInternal(mScrolledFrame->GetOverflowRect(),
37083:                             mScrollPort.Size());
37083: 
37083:   NS_ASSERTION(result.width >= mScrollPort.width,
37083:                "Scrolled rect smaller than scrollport?");
37083:   NS_ASSERTION(result.height >= mScrollPort.height,
37083:                "Scrolled rect smaller than scrollport?");
37083:   return result;
37083: }
37083: 
37083: nsRect
37083: nsGfxScrollFrameInner::GetScrolledRectInternal(const nsRect& aScrolledFrameOverflowArea,
37083:                                                const nsSize& aScrollPortSize) const
37083: {
37083:   nscoord x1 = aScrolledFrameOverflowArea.x,
37083:           x2 = aScrolledFrameOverflowArea.XMost(),
37083:           y1 = aScrolledFrameOverflowArea.y,
37083:           y2 = aScrolledFrameOverflowArea.YMost();
    1:   if (y1 < 0)
    1:     y1 = 0;
    1:   if (IsLTR() || mIsXUL) {
    1:     if (x1 < 0)
    1:       x1 = 0;
    1:   } else {
    1:     if (x2 > aScrollPortSize.width)
    1:       x2 = aScrollPortSize.width;
15908:     // When the scrolled frame chooses a size larger than its available width (because
15908:     // its padding alone is larger than the available width), we need to keep the
15908:     // start-edge of the scroll frame anchored to the start-edge of the scrollport. 
15908:     // When the scrolled frame is RTL, this means moving it in our left-based
15908:     // coordinate system, so we need to compensate for its extra width here by
15908:     // effectively repositioning the frame.
32531:     nscoord extraWidth = NS_MAX(0, mScrolledFrame->GetSize().width - aScrollPortSize.width);
15908:     x2 += extraWidth;
    1:   }
    1:   return nsRect(x1, y1, x2 - x1, y2 - y1);
    1: }
    1: 
    1: nsMargin
37293: nsGfxScrollFrameInner::GetActualScrollbarSizes() const
37293: {
37293:   nsMargin result(0, 0, 0, 0);
37293:   if (mVScrollbarBox) {
37293:     if (IsScrollbarOnRight()) {
37293:       result.right = mVScrollbarBox->GetRect().width;
37293:     } else {
37293:       result.left = mVScrollbarBox->GetRect().width;
37293:     }
37293:   }
37293:   if (mHScrollbarBox) {
37293:     result.bottom = mHScrollbarBox->GetRect().height;
37293:   }
37293:   return result;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::SetScrollbarVisibility(nsIBox* aScrollbar, PRBool aVisible)
    1: {
    1:   if (!aScrollbar)
    1:     return;
    1: 
23554:   nsIScrollbarFrame* scrollbar = do_QueryFrame(aScrollbar);
    1:   if (scrollbar) {
    1:     // See if we have a mediator.
    1:     nsIScrollbarMediator* mediator = scrollbar->GetScrollbarMediator();
    1:     if (mediator) {
    1:       // Inform the mediator of the visibility change.
23554:       mediator->VisibilityChanged(aVisible);
    1:     }
    1:   }
    1: }
    1: 
    1: PRInt32
    1: nsGfxScrollFrameInner::GetCoordAttribute(nsIBox* aBox, nsIAtom* atom, PRInt32 defaultValue)
    1: {
    1:   if (aBox) {
    1:     nsIContent* content = aBox->GetContent();
    1: 
    1:     nsAutoString value;
    1:     content->GetAttr(kNameSpaceID_None, atom, value);
    1:     if (!value.IsEmpty())
    1:     {
    1:       PRInt32 error;
    1: 
    1:       // convert it to an integer
    1:       defaultValue = nsPresContext::CSSPixelsToAppUnits(value.ToInteger(&error));
    1:     }
    1:   }
    1: 
    1:   return defaultValue;
    1: }
    1: 
    1: static nsIURI* GetDocURI(nsIFrame* aFrame)
    1: {
  238:   nsIPresShell* shell = aFrame->PresContext()->GetPresShell();
    1:   if (!shell)
    1:     return nsnull;
    1:   nsIDocument* doc = shell->GetDocument();
    1:   if (!doc)
    1:     return nsnull;
    1:   return doc->GetDocumentURI();
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::SaveVScrollbarStateToGlobalHistory()
    1: {
    1:   NS_ASSERTION(mIsRoot, "Only use this on viewports");
    1: 
    1:   // If the hint is the same as the one we loaded, don't bother
    1:   // saving it
    1:   if (mDidLoadHistoryVScrollbarHint &&
    1:       (mHistoryVScrollbarHint == mHasVerticalScrollbar))
    1:     return;
    1: 
    1:   nsIURI* uri = GetDocURI(mOuter);
    1:   if (!uri)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIGlobalHistory3> history(do_GetService(NS_GLOBALHISTORY2_CONTRACTID));
    1:   if (!history)
    1:     return;
    1:   
    1:   PRUint32 flags = 0;
    1:   if (mHasVerticalScrollbar) {
    1:     flags |= NS_GECKO_FLAG_NEEDS_VERTICAL_SCROLLBAR;
    1:   }
    1:   history->SetURIGeckoFlags(uri, flags);
    1:   // if it fails, we don't care
    1: }
    1: 
    1: nsresult
    1: nsGfxScrollFrameInner::GetVScrollbarHintFromGlobalHistory(PRBool* aVScrollbarNeeded)
    1: {
    1:   NS_ASSERTION(mIsRoot, "Only use this on viewports");
    1:   NS_ASSERTION(!mDidLoadHistoryVScrollbarHint,
    1:                "Should only load a hint once, it can be expensive");
    1: 
    1:   nsIURI* uri = GetDocURI(mOuter);
    1:   if (!uri)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIGlobalHistory3> history(do_GetService(NS_GLOBALHISTORY2_CONTRACTID));
    1:   if (!history)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   PRUint32 flags;
    1:   nsresult rv = history->GetURIGeckoFlags(uri, &flags);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *aVScrollbarNeeded = (flags & NS_GECKO_FLAG_NEEDS_VERTICAL_SCROLLBAR) != 0;
    1:   mDidLoadHistoryVScrollbarHint = PR_TRUE;
    1:   mHistoryVScrollbarHint = *aVScrollbarNeeded;
    1:   return NS_OK;
    1: }
    1: 
    1: nsPresState*
    1: nsGfxScrollFrameInner::SaveState(nsIStatefulFrame::SpecialStateID aStateID)
    1: {
    1:   // Don't save "normal" state for the root scrollframe; that's
    1:   // handled via the eDocumentScrollState state id
    1:   if (mIsRoot && aStateID == nsIStatefulFrame::eNoID) {
    1:     return nsnull;
    1:   }
    1: 
23554:   nsIScrollbarMediator* mediator = do_QueryFrame(GetScrolledFrame());
    1:   if (mediator) {
    1:     // child handles its own scroll state, so don't bother saving state here
    1:     return nsnull;
    1:   }
    1: 
37083:   nsPoint scrollPos = GetScrollPosition();
    1:   // Don't save scroll position if we are at (0,0)
37083:   if (scrollPos == nsPoint(0,0)) {
    1:     return nsnull;
    1:   }
    1: 
22740:   nsPresState* state = new nsPresState();
22740:   if (!state) {
22740:     return nsnull;
22740:   }
    1:  
37083:   state->SetScrollState(scrollPos);
    1: 
22740:   return state;
    1: }
    1: 
    1: void
    1: nsGfxScrollFrameInner::RestoreState(nsPresState* aState)
    1: {
37083:   mRestorePos = aState->GetScrollState();
    1:   mLastPos.x = -1;
    1:   mLastPos.y = -1;
    1:   mDidHistoryRestore = PR_TRUE;
37083:   mLastPos = mScrolledFrame ? GetScrollPosition() : nsPoint(0,0);
    1: }
34480: 
34480: void
37084: nsGfxScrollFrameInner::PostScrolledAreaEvent()
34480: {
37084:   if (mScrolledAreaEvent.IsPending()) {
34480:     return;
34480:   }
37084:   mScrolledAreaEvent = new ScrolledAreaEvent(this);
37084:   NS_DispatchToCurrentThread(mScrolledAreaEvent.get());
34480: }
34480: 
34480: ////////////////////////////////////////////////////////////////////////////////
34480: // ScrolledArea change event dispatch
34480: 
34480: NS_IMETHODIMP
37084: nsGfxScrollFrameInner::ScrolledAreaEvent::Run()
34480: {
37084:   if (mInner) {
37084:     mInner->FireScrolledAreaEvent();
37084:   }
34480:   return NS_OK;
34480: }
34480: 
34480: void
37084: nsGfxScrollFrameInner::FireScrolledAreaEvent()
34480: {
37084:   mScrolledAreaEvent.Forget();
34480: 
34480:   nsScrollAreaEvent event(PR_TRUE, NS_SCROLLEDAREACHANGED, nsnull);
34480:   nsPresContext *prescontext = mOuter->PresContext();
34480:   nsIContent* content = mOuter->GetContent();
34480: 
37084:   event.mArea = mScrolledFrame->GetOverflowRectRelativeToParent();
34480: 
34480:   nsIDocument *doc = content->GetCurrentDoc();
34480:   if (doc) {
34480:     nsEventDispatcher::Dispatch(doc, prescontext, &event, nsnull);
34480:   }
34480: }
