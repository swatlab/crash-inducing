   1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
   1: /* vim:expandtab:shiftwidth=4:tabstop=4:
   1:  */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is Christopher Blizzard
   1:  * <blizzard@mozilla.org>.  Portions created by the Initial Developer
   1:  * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Mats Palmgren <mats.palmgren@bredband.net>
   1:  *   Masayuki Nakano <masayuki@d-toybox.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "prlink.h"
   1: 
   1: #include "nsWindow.h"
   1: #include "nsGTKToolkit.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsIRegion.h"
   1: #include "nsIRollupListener.h"
   1: #include "nsIMenuRollup.h"
   1: #include "nsIDOMNode.h"
   1: 
   1: #include "nsWidgetsCID.h"
   1: #include "nsIDragService.h"
   1: #include "nsIDragSessionGTK.h"
   1: 
   1: #include "nsGtkKeyUtils.h"
   1: #include "nsGtkCursors.h"
   1: 
   1: #include <gtk/gtkwindow.h>
   1: #include <gdk/gdkx.h>
   1: #include <gdk/gdkkeysyms.h>
   1: 
   1: #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
   1: #define SN_API_NOT_YET_FROZEN
   1: #include <startup-notification-1.0/libsn/sn.h>
   1: #endif
   1: 
   1: #include "gtk2xtbin.h"
   1: 
   1: #include "nsIPrefService.h"
   1: #include "nsIPrefBranch.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsIStringBundle.h"
   1: #include "nsGfxCIID.h"
   1: 
   1: #ifdef ACCESSIBILITY
   1: #include "nsIAccessibleRole.h"
   1: #include "nsPIAccessNode.h"
   1: #include "nsPIAccessible.h"
   1: #include "nsIAccessibleEvent.h"
   1: #include "prenv.h"
   1: #include "stdlib.h"
   1: static PRBool sAccessibilityChecked = PR_FALSE;
   1: /* static */
   1: PRBool nsWindow::sAccessibilityEnabled = PR_FALSE;
   1: static const char sSysPrefService [] = "@mozilla.org/system-preference-service;1";
   1: static const char sAccEnv [] = "GNOME_ACCESSIBILITY";
   1: static const char sAccessibilityKey [] = "config.use_system_prefs.accessibility";
   1: #endif
   1: 
   1: /* For SetIcon */
   1: #include "nsAppDirectoryServiceDefs.h"
   1: #include "nsXPIDLString.h"
   1: #include "nsIFile.h"
   1: #include "nsILocalFile.h"
   1: 
   1: /* SetCursor(imgIContainer*) */
   1: #include <gdk/gdk.h>
   1: #include "imgIContainer.h"
   1: #include "gfxIImageFrame.h"
   1: #include "nsGfxCIID.h"
   1: #include "nsIImage.h"
   1: #include "nsImageToPixbuf.h"
   1: #include "nsIInterfaceRequestorUtils.h"
   1: #include "nsAutoPtr.h"
   1: 
   1: #include "gfxPlatformGtk.h"
   1: #include "gfxXlibSurface.h"
   1: #include "gfxContext.h"
   1: #include "gfxImageSurface.h"
   1: 
   1: #ifdef MOZ_ENABLE_GLITZ
   1: #include "gfxGlitzSurface.h"
   1: #include "glitz-glx.h"
   1: #endif
   1: 
   1: /* For PrepareNativeWidget */
   1: static NS_DEFINE_IID(kDeviceContextCID, NS_DEVICE_CONTEXT_CID);
   1: 
   1: /* utility functions */
   1: static PRBool     check_for_rollup(GdkWindow *aWindow,
   1:                                    gdouble aMouseX, gdouble aMouseY,
   1:                                    PRBool aIsWheel);
   1: static PRBool     is_mouse_in_window(GdkWindow* aWindow,
   1:                                      gdouble aMouseX, gdouble aMouseY);
   1: static nsWindow  *get_window_for_gtk_widget(GtkWidget *widget);
   1: static nsWindow  *get_window_for_gdk_window(GdkWindow *window);
   1: static nsWindow  *get_owning_window_for_gdk_window(GdkWindow *window);
   1: static GtkWidget *get_gtk_widget_for_gdk_window(GdkWindow *window);
   1: static GdkCursor *get_gtk_cursor(nsCursor aCursor);
   1: 
   1: static GdkWindow *get_inner_gdk_window (GdkWindow *aWindow,
   1:                                         gint x, gint y,
   1:                                         gint *retx, gint *rety);
   1: 
   1: static inline PRBool is_context_menu_key(const nsKeyEvent& inKeyEvent);
   1: static void   key_event_to_context_menu_event(const nsKeyEvent* inKeyEvent,
   1:                                               nsMouseEvent* outCMEvent);
   1: 
   1: static int    is_parent_ungrab_enter(GdkEventCrossing *aEvent);
   1: static int    is_parent_grab_leave(GdkEventCrossing *aEvent);
   1: 
   1: /* callbacks from widgets */
   1: static gboolean expose_event_cb           (GtkWidget *widget,
   1:                                            GdkEventExpose *event);
   1: static gboolean configure_event_cb        (GtkWidget *widget,
   1:                                            GdkEventConfigure *event);
   1: static void     size_allocate_cb          (GtkWidget *widget,
   1:                                            GtkAllocation *allocation);
   1: static gboolean delete_event_cb           (GtkWidget *widget,
   1:                                            GdkEventAny *event);
   1: static gboolean enter_notify_event_cb     (GtkWidget *widget,
   1:                                            GdkEventCrossing *event);
   1: static gboolean leave_notify_event_cb     (GtkWidget *widget,
   1:                                            GdkEventCrossing *event);
   1: static gboolean motion_notify_event_cb    (GtkWidget *widget,
   1:                                            GdkEventMotion *event);
   1: static gboolean button_press_event_cb     (GtkWidget *widget,
   1:                                            GdkEventButton *event);
   1: static gboolean button_release_event_cb   (GtkWidget *widget,
   1:                                            GdkEventButton *event);
   1: static gboolean focus_in_event_cb         (GtkWidget *widget,
   1:                                            GdkEventFocus *event);
   1: static gboolean focus_out_event_cb        (GtkWidget *widget,
   1:                                            GdkEventFocus *event);
   1: static gboolean key_press_event_cb        (GtkWidget *widget,
   1:                                            GdkEventKey *event);
   1: static gboolean key_release_event_cb      (GtkWidget *widget,
   1:                                            GdkEventKey *event);
   1: static gboolean scroll_event_cb           (GtkWidget *widget,
   1:                                            GdkEventScroll *event);
   1: static gboolean visibility_notify_event_cb(GtkWidget *widget,
   1:                                            GdkEventVisibility *event);
   1: static gboolean window_state_event_cb     (GtkWidget *widget,
   1:                                            GdkEventWindowState *event);
   1: static void     theme_changed_cb          (GtkSettings *settings,
   1:                                            GParamSpec *pspec,
   1:                                            nsWindow *data);
   1: #ifdef __cplusplus
   1: extern "C" {
   1: #endif /* __cplusplus */
   1: static GdkFilterReturn plugin_window_filter_func (GdkXEvent *gdk_xevent,
   1:                                                   GdkEvent *event,
   1:                                                   gpointer data);
   1: static GdkFilterReturn plugin_client_message_filter (GdkXEvent *xevent,
   1:                                                      GdkEvent *event,
   1:                                                      gpointer data);
   1: #ifdef __cplusplus
   1: }
   1: #endif /* __cplusplus */
   1: 
   1: static gboolean drag_motion_event_cb      (GtkWidget *aWidget,
   1:                                            GdkDragContext *aDragContext,
   1:                                            gint aX,
   1:                                            gint aY,
   1:                                            guint aTime,
   1:                                            gpointer aData);
   1: static void     drag_leave_event_cb       (GtkWidget *aWidget,
   1:                                            GdkDragContext *aDragContext,
   1:                                            guint aTime,
   1:                                            gpointer aData);
   1: static gboolean drag_drop_event_cb        (GtkWidget *aWidget,
   1:                                            GdkDragContext *aDragContext,
   1:                                            gint aX,
   1:                                            gint aY,
   1:                                            guint aTime,
   1:                                            gpointer *aData);
   1: static void    drag_data_received_event_cb(GtkWidget *aWidget,
   1:                                            GdkDragContext *aDragContext,
   1:                                            gint aX,
   1:                                            gint aY,
   1:                                            GtkSelectionData  *aSelectionData,
   1:                                            guint aInfo,
   1:                                            guint32 aTime,
   1:                                            gpointer aData);
   1: 
2475: static GdkModifierType gdk_keyboard_get_modifiers();
2475: static PRBool gdk_keyboard_get_modmap_masks(Display*  aDisplay,
2475:                                             PRUint32* aCapsLockMask,
2475:                                             PRUint32* aNumLockMask,
2475:                                             PRUint32* aScrollLockMask);
2475: 
   1: /* initialization static functions */
   1: static nsresult    initialize_prefs        (void);
   1: 
   1: // this is the last window that had a drag event happen on it.
   1: nsWindow *nsWindow::mLastDragMotionWindow = NULL;
   1: PRBool nsWindow::sIsDraggingOutOf = PR_FALSE;
   1: 
   1: // This is the time of the last button press event.  The drag service
   1: // uses it as the time to start drags.
   1: guint32   nsWindow::mLastButtonPressTime = 0;
   1: // Time of the last button release event. We use it to detect when the
   1: // drag ended before we could properly setup drag and drop.
   1: guint32   nsWindow::mLastButtonReleaseTime = 0;
   1: 
   1: static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
   1: 
   1: // the current focus window
   1: static nsWindow         *gFocusWindow          = NULL;
   1: static PRBool            gGlobalsInitialized   = PR_FALSE;
   1: static PRBool            gRaiseWindows         = PR_TRUE;
   1: static nsWindow         *gPluginFocusWindow    = NULL;
   1: 
   1: nsCOMPtr  <nsIRollupListener> gRollupListener;
   1: nsWeakPtr                     gRollupWindow;
   1: 
   1: #define NS_WINDOW_TITLE_MAX_LENGTH 4095
   1: 
   1: #ifdef USE_XIM
   1: 
   1: static nsWindow    *gIMEFocusWindow = NULL;
   1: static GdkEventKey *gKeyEvent = NULL;
   1: static PRBool       gKeyEventCommitted = PR_FALSE;
   1: static PRBool       gKeyEventChanged = PR_FALSE;
   1: static PRBool       gIMESuppressCommit = PR_FALSE;
   1: 
   1: static void IM_commit_cb              (GtkIMContext *aContext,
   1:                                        const gchar *aString,
   1:                                        nsWindow *aWindow);
   1: static void IM_commit_cb_internal     (const gchar *aString,
   1:                                        nsWindow *aWindow);
   1: static void IM_preedit_changed_cb     (GtkIMContext *aContext,
   1:                                        nsWindow *aWindow);
   1: static void IM_set_text_range         (const PRInt32 aLen,
   1:                                        const gchar *aPreeditString,
   1:                                        const gint aCursorPos,
   1:                                        const PangoAttrList *aFeedback,
   1:                                        PRUint32 *aTextRangeListLengthResult,
   1:                                        nsTextRangeArray *aTextRangeListResult);
   1: 
   1: static nsWindow *IM_get_owning_window(MozDrawingarea *aArea);
   1: 
   1: static GtkIMContext *IM_get_input_context(nsWindow *window);
   1: 
   1: // If after selecting profile window, the startup fail, please refer to
   1: // http://bugzilla.gnome.org/show_bug.cgi?id=88940
   1: #endif
   1: 
   1: // needed for imgIContainer cursors
   1: // GdkDisplay* was added in 2.2
   1: typedef struct _GdkDisplay GdkDisplay;
   1: typedef GdkDisplay* (*_gdk_display_get_default_fn)(void);
   1: 
   1: typedef GdkCursor*  (*_gdk_cursor_new_from_pixbuf_fn)(GdkDisplay *display,
   1:                                                       GdkPixbuf *pixbuf,
   1:                                                       gint x,
   1:                                                       gint y);
   1: static _gdk_display_get_default_fn    _gdk_display_get_default;
   1: static _gdk_cursor_new_from_pixbuf_fn _gdk_cursor_new_from_pixbuf;
   1: static PRBool sPixbufCursorChecked;
   1: 
   1: // needed for GetAttention calls
   1: // gdk_window_set_urgency_hint was added in 2.8
   1: typedef void (*_gdk_window_set_urgency_hint_fn)(GdkWindow *window,
   1:                                                 gboolean urgency);
   1: 
   1: #define kWindowPositionSlop 20
   1: 
   1: // cursor cache
   1: static GdkCursor *gCursorCache[eCursorCount];
   1: 
   1: nsWindow::nsWindow()
   1: {
   1:     mContainer           = nsnull;
   1:     mDrawingarea         = nsnull;
   1:     mShell               = nsnull;
   1:     mWindowGroup         = nsnull;
   1:     mContainerGotFocus   = PR_FALSE;
   1:     mContainerLostFocus  = PR_FALSE;
   1:     mContainerBlockFocus = PR_FALSE;
   1:     mIsVisible           = PR_FALSE;
   1:     mRetryPointerGrab    = PR_FALSE;
   1:     mRetryKeyboardGrab   = PR_FALSE;
   1:     mActivatePending     = PR_FALSE;
   1:     mTransientParent     = nsnull;
   1:     mWindowType          = eWindowType_child;
   1:     mSizeState           = nsSizeMode_Normal;
   1:     mOldFocusWindow      = 0;
   1:     mPluginType          = PluginType_NONE;
   1: 
   1:     if (!gGlobalsInitialized) {
   1:         gGlobalsInitialized = PR_TRUE;
   1: 
   1:         // It's OK if either of these fail, but it may not be one day.
   1:         initialize_prefs();
   1:     }
   1: 
 889:     memset(mKeyDownFlags, 0, sizeof(mKeyDownFlags));
 889: 
   1:     if (mLastDragMotionWindow == this)
   1:         mLastDragMotionWindow = NULL;
   1:     mDragMotionWidget = 0;
   1:     mDragMotionContext = 0;
   1:     mDragMotionX = 0;
   1:     mDragMotionY = 0;
   1:     mDragMotionTime = 0;
   1:     mDragMotionTimerID = 0;
   1: 
   1: #ifdef USE_XIM
   1:     mIMEData = nsnull;
   1: #endif
   1: 
   1: #ifdef ACCESSIBILITY
   1:     mRootAccessible  = nsnull;
   1: #endif
   1: 
   1:     mIsTranslucent = PR_FALSE;
   1:     mTransparencyBitmap = nsnull;
   1: 
   1:     mTransparencyBitmapWidth  = 0;
   1:     mTransparencyBitmapHeight = 0;
   1: }
   1: 
   1: nsWindow::~nsWindow()
   1: {
   1:     LOG(("nsWindow::~nsWindow() [%p]\n", (void *)this));
   1:     if (mLastDragMotionWindow == this) {
   1:         mLastDragMotionWindow = NULL;
   1:     }
   1: 
   1:     delete[] mTransparencyBitmap;
   1:     mTransparencyBitmap = nsnull;
   1: 
   1:     Destroy();
   1: }
   1: 
   1: /* static */ void
   1: nsWindow::ReleaseGlobals()
   1: {
 829:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gCursorCache); ++i) {
   1:     if (gCursorCache[i]) {
   1:       gdk_cursor_unref(gCursorCache[i]);
   1:       gCursorCache[i] = nsnull;
   1:     }
   1:   }
   1: }
   1: 
   1: #ifndef USE_XIM
   1: NS_IMPL_ISUPPORTS_INHERITED1(nsWindow, nsCommonWidget,
   1:                              nsISupportsWeakReference)
   1: #else
   1: NS_IMPL_ISUPPORTS_INHERITED2(nsWindow, nsCommonWidget,
   1:                              nsISupportsWeakReference,
   1:                              nsIKBStateControl)
   1: #endif
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Create(nsIWidget        *aParent,
   1:                  const nsRect     &aRect,
   1:                  EVENT_CALLBACK   aHandleEventFunction,
   1:                  nsIDeviceContext *aContext,
   1:                  nsIAppShell      *aAppShell,
   1:                  nsIToolkit       *aToolkit,
   1:                  nsWidgetInitData *aInitData)
   1: {
   1:     nsresult rv = NativeCreate(aParent, nsnull, aRect, aHandleEventFunction,
   1:                                aContext, aAppShell, aToolkit, aInitData);
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Create(nsNativeWidget aParent,
   1:                  const nsRect     &aRect,
   1:                  EVENT_CALLBACK   aHandleEventFunction,
   1:                  nsIDeviceContext *aContext,
   1:                  nsIAppShell      *aAppShell,
   1:                  nsIToolkit       *aToolkit,
   1:                  nsWidgetInitData *aInitData)
   1: {
   1:     nsresult rv = NativeCreate(nsnull, aParent, aRect, aHandleEventFunction,
   1:                                aContext, aAppShell, aToolkit, aInitData);
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Destroy(void)
   1: {
   1:     if (mIsDestroyed || !mCreated)
   1:         return NS_OK;
   1: 
   1:     LOG(("nsWindow::Destroy [%p]\n", (void *)this));
   1:     mIsDestroyed = PR_TRUE;
   1:     mCreated = PR_FALSE;
   1:     
   1:     g_signal_handlers_disconnect_by_func(gtk_settings_get_default(),
   1:                                          (gpointer)G_CALLBACK(theme_changed_cb),
   1:                                          this);
   1: 
   1:     // ungrab if required
   1:     nsCOMPtr<nsIWidget> rollupWidget = do_QueryReferent(gRollupWindow);
3233:     if (static_cast<nsIWidget *>(this) == rollupWidget.get()) {
   1:         if (gRollupListener)
   1:             gRollupListener->Rollup();
   1:         gRollupWindow = nsnull;
   1:         gRollupListener = nsnull;
   1:     }
   1: 
   1:     NativeShow(PR_FALSE);
   1: 
   1:     // walk the list of children and call destroy on them.  Have to be
   1:     // careful, though -- calling destroy on a kid may actually remove
   1:     // it from our child list, losing its sibling links.
   1:     for (nsIWidget* kid = mFirstChild; kid; ) {
   1:         nsIWidget* next = kid->GetNextSibling();
   1:         kid->Destroy();
   1:         kid = next;
   1:     }
   1: 
   1: #ifdef USE_XIM
   1:     IMEDestroyContext();
   1: #endif
   1: 
   1:     // make sure that we remove ourself as the focus window
   1:     if (gFocusWindow == this) {
   1:         LOGFOCUS(("automatically losing focus...\n"));
   1:         gFocusWindow = nsnull;
   1:     }
   1: 
   1:     // make sure that we remove ourself as the plugin focus window
   1:     if (gPluginFocusWindow == this) {
   1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
   1:     }
   1: 
   1:     // Remove our reference to the window group.  If there was a window
   1:     // group destroying the widget will have automatically unreferenced
   1:     // the group, destroying it if necessary.  And, if we're a child
   1:     // window this isn't going to harm anything.
   1:     mWindowGroup = nsnull;
   1: 
   1:     // Destroy thebes surface now. Badness can happen if we destroy
   1:     // the surface after its X Window.
   1:     mThebesSurface = nsnull;
   1: 
   1:     if (mDragMotionTimerID) {
   1:         gtk_timeout_remove(mDragMotionTimerID);
   1:         mDragMotionTimerID = 0;
   1:     }
   1: 
   1:     if (mShell) {
   1:         gtk_widget_destroy(mShell);
   1:         mShell = nsnull;
   1:         mContainer = nsnull;
   1:     }
   1:     else if (mContainer) {
   1:         gtk_widget_destroy(GTK_WIDGET(mContainer));
   1:         mContainer = nsnull;
   1:     }
   1: 
   1:     if (mDrawingarea) {
   1:         g_object_unref(mDrawingarea);
   1:         mDrawingarea = nsnull;
   1:     }
   1: 
   1:     OnDestroy();
   1: 
   1: #ifdef ACCESSIBILITY
   1:     if (mRootAccessible) {
   1:         mRootAccessible = nsnull;
   1:     }
   1: #endif
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetParent(nsIWidget *aNewParent)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aNewParent);
   1: 
   1:     GdkWindow* newParentWindow =
3233:         static_cast<GdkWindow*>(aNewParent->GetNativeData(NS_NATIVE_WINDOW));
   1:     NS_ASSERTION(newParentWindow, "Parent widget has a null native window handle");
   1: 
   1:     if (!mShell && mDrawingarea) {
   1:         moz_drawingarea_reparent(mDrawingarea, newParentWindow);
   1:     } else {
   1:         NS_NOTREACHED("nsWindow::SetParent - reparenting a non-child window");
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetModal(PRBool aModal)
   1: {
   1:     LOG(("nsWindow::SetModal [%p] %d\n", (void *)this, aModal));
   1: 
   1:     // find the toplevel window and add it to the grab list
   1:     GtkWidget *grabWidget = nsnull;
   1: 
   1:     GetToplevelWidget(&grabWidget);
   1: 
   1:     if (!grabWidget)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     if (aModal)
   1:         gtk_grab_add(grabWidget);
   1:     else
   1:         gtk_grab_remove(grabWidget);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::IsVisible(PRBool & aState)
   1: {
   1:     aState = mIsVisible;
   1:     if (mIsTopLevel && mShell) {
   1:         aState = GTK_WIDGET_VISIBLE(mShell);
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY)
   1: {
   1:     if (mIsTopLevel && mShell) {
   1:         PRInt32 screenWidth = gdk_screen_width();
   1:         PRInt32 screenHeight = gdk_screen_height();
   1:         if (aAllowSlop) {
   1:             if (*aX < (kWindowPositionSlop - mBounds.width))
   1:                 *aX = kWindowPositionSlop - mBounds.width;
   1:             if (*aX > (screenWidth - kWindowPositionSlop))
   1:                 *aX = screenWidth - kWindowPositionSlop;
   1:             if (*aY < (kWindowPositionSlop - mBounds.height))
   1:                 *aY = kWindowPositionSlop - mBounds.height;
   1:             if (*aY > (screenHeight - kWindowPositionSlop))
   1:                 *aY = screenHeight - kWindowPositionSlop;
   1:         } else {
   1:             if (*aX < 0)
   1:                 *aX = 0;
   1:             if (*aX > (screenWidth - mBounds.width))
   1:                 *aX = screenWidth - mBounds.width;
   1:             if (*aY < 0)
   1:                 *aY = 0;
   1:             if (*aY > (screenHeight - mBounds.height))
   1:                 *aY = screenHeight - mBounds.height;
   1:         }
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Move(PRInt32 aX, PRInt32 aY)
   1: {
   1:     LOG(("nsWindow::Move [%p] %d %d\n", (void *)this,
   1:          aX, aY));
   1: 
   1:     mPlaced = PR_TRUE;
   1: 
   1:     // Since a popup window's x/y coordinates are in relation to to
   1:     // the parent, the parent might have moved so we always move a
   1:     // popup window.
   1:     if (aX == mBounds.x && aY == mBounds.y &&
   1:         mWindowType != eWindowType_popup)
   1:         return NS_OK;
   1: 
   1:     // XXX Should we do some AreBoundsSane check here?
   1: 
   1:     mBounds.x = aX;
   1:     mBounds.y = aY;
   1: 
   1:     if (!mCreated)
   1:         return NS_OK;
   1: 
   1:     if (mIsTopLevel) {
   1:         if (mParent && mWindowType == eWindowType_popup) {
   1:             nsRect oldrect, newrect;
   1:             oldrect.x = aX;
   1:             oldrect.y = aY;
   1:             mParent->WidgetToScreen(oldrect, newrect);
   1:             gtk_window_move(GTK_WINDOW(mShell), newrect.x, newrect.y);
   1:         }
   1:         else {
   1:             gtk_window_move(GTK_WINDOW(mShell), aX, aY);
   1:         }
   1:     }
   1:     else if (mDrawingarea) {
   1:         moz_drawingarea_move(mDrawingarea, aX, aY);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement  aPlacement,
   1:                       nsIWidget                  *aWidget,
   1:                       PRBool                      aActivate)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetZIndex(PRInt32 aZIndex)
   1: {
   1:     nsIWidget* oldPrev = GetPrevSibling();
   1: 
   1:     nsBaseWidget::SetZIndex(aZIndex);
   1: 
   1:     if (GetPrevSibling() == oldPrev) {
   1:         return NS_OK;
   1:     }
   1: 
   1:     NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
   1: 
   1:     // We skip the nsWindows that don't have mDrawingareas.
   1:     // These are probably in the process of being destroyed.
   1: 
   1:     if (!GetNextSibling()) {
   1:         // We're to be on top.
   1:         if (mDrawingarea)
   1:             gdk_window_raise(mDrawingarea->clip_window);
   1:     } else {
   1:         // All the siblings before us need to be below our widget. 
   1:         for (nsWindow* w = this; w;
3233:              w = static_cast<nsWindow*>(w->GetPrevSibling())) {
   1:             if (w->mDrawingarea)
   1:                 gdk_window_lower(w->mDrawingarea->clip_window);
   1:         }
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetSizeMode(PRInt32 aMode)
   1: {
   1:     nsresult rv;
   1: 
   1:     LOG(("nsWindow::SetSizeMode [%p] %d\n", (void *)this, aMode));
   1: 
   1:     // Save the requested state.
   1:     rv = nsBaseWidget::SetSizeMode(aMode);
   1: 
   1:     // return if there's no shell or our current state is the same as
   1:     // the mode we were just set to.
   1:     if (!mShell || mSizeState == mSizeMode) {
   1:         return rv;
   1:     }
   1: 
   1:     switch (aMode) {
   1:     case nsSizeMode_Maximized:
   1:         gtk_window_maximize(GTK_WINDOW(mShell));
   1:         break;
   1:     case nsSizeMode_Minimized:
   1:         gtk_window_iconify(GTK_WINDOW(mShell));
   1:         break;
   1:     default:
   1:         // nsSizeMode_Normal, really.
   1:         if (mSizeState == nsSizeMode_Minimized)
   1:             gtk_window_deiconify(GTK_WINDOW(mShell));
   1:         else if (mSizeState == nsSizeMode_Maximized)
   1:             gtk_window_unmaximize(GTK_WINDOW(mShell));
   1:         break;
   1:     }
   1: 
   1:     mSizeState = mSizeMode;
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Enable(PRBool aState)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: typedef void (* SetUserTimeFunc)(GdkWindow* aWindow, guint32 aTimestamp);
   1: 
   1: // This will become obsolete when new GTK APIs are widely supported,
   1: // as described here: http://bugzilla.gnome.org/show_bug.cgi?id=347375
   1: static void
   1: SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
   1: {
   1:     nsCOMPtr<nsIToolkit> toolkit;
   1:     NS_GetCurrentToolkit(getter_AddRefs(toolkit));
   1:     if (!toolkit)
   1:         return;
   1: 
3233:     nsGTKToolkit* GTKToolkit = static_cast<nsGTKToolkit*>
3233:                                           (static_cast<nsIToolkit*>(toolkit));
   1:     nsCAutoString desktopStartupID;
   1:     GTKToolkit->GetDesktopStartupID(&desktopStartupID);
   1:     if (desktopStartupID.IsEmpty()) {
   1:         // We don't have the data we need. Fall back to an
   1:         // approximation ... using the timestamp of the remote command
   1:         // being received as a guess for the timestamp of the user event
   1:         // that triggered it.
   1:         PRUint32 timestamp = GTKToolkit->GetFocusTimestamp();
   1:         if (timestamp) {
   1:             gdk_window_focus(aWindow->window, timestamp);
   1:             GTKToolkit->SetFocusTimestamp(0);
   1:         }
   1:         return;
   1:     }
   1:  
   1: #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
   1:     GdkDrawable* drawable = GDK_DRAWABLE(aWindow->window);
   1:     GtkWindow* win = GTK_WINDOW(aWindow);
   1:     if (!win) {
   1:         NS_WARNING("Passed in widget was not a GdkWindow!");
   1:         return;
   1:     }
   1:     GdkScreen* screen = gtk_window_get_screen(win);
   1:     SnDisplay* snd =
   1:         sn_display_new(gdk_x11_drawable_get_xdisplay(drawable), nsnull, nsnull);
   1:     if (!snd)
   1:         return;
   1:     SnLauncheeContext* ctx =
   1:         sn_launchee_context_new(snd, gdk_screen_get_number(screen),
   1:                                 desktopStartupID.get());
   1:     if (!ctx) {
   1:         sn_display_unref(snd);
   1:         return;
   1:     }
   1: 
   1:     if (sn_launchee_context_get_id_has_timestamp(ctx)) {
   1:         PRLibrary* gtkLibrary;
   1:         SetUserTimeFunc setUserTimeFunc = (SetUserTimeFunc)
   1:             PR_FindFunctionSymbolAndLibrary("gdk_x11_window_set_user_time", &gtkLibrary);
   1:         if (setUserTimeFunc) {
   1:             setUserTimeFunc(aWindow->window, sn_launchee_context_get_timestamp(ctx));
   1:             PR_UnloadLibrary(gtkLibrary);
   1:         }
   1:     }
   1: 
   1:     sn_launchee_context_setup_window(ctx, gdk_x11_drawable_get_xid(drawable));
   1:     sn_launchee_context_complete(ctx);
   1: 
   1:     sn_launchee_context_unref(ctx);
   1:     sn_display_unref(snd);
   1: #endif
   1:  
   1:     GTKToolkit->SetDesktopStartupID(EmptyCString());
   1: } 
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetFocus(PRBool aRaise)
   1: {
   1:     // Make sure that our owning widget has focus.  If it doesn't try to
   1:     // grab it.  Note that we don't set our focus flag in this case.
   1: 
   1:     LOGFOCUS(("  SetFocus [%p]\n", (void *)this));
   1: 
   1:     if (!mDrawingarea)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     GtkWidget *owningWidget =
   1:         get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1:     if (!owningWidget)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     // Raise the window if someone passed in PR_TRUE and the prefs are
   1:     // set properly.
   1:     GtkWidget *toplevelWidget = gtk_widget_get_toplevel(owningWidget);
   1: 
   1:     if (gRaiseWindows && aRaise && toplevelWidget &&
   1:         !GTK_WIDGET_HAS_FOCUS(owningWidget) &&
   1:         !GTK_WIDGET_HAS_FOCUS(toplevelWidget)) {
   1:         GtkWidget* top_window = nsnull;
   1:         GetToplevelWidget(&top_window);
   1:         if (top_window && (GTK_WIDGET_VISIBLE(top_window)))
   1:         {
   1:             gdk_window_show_unraised(top_window->window);
   1:             // Unset the urgency hint if possible.
   1:             SetUrgencyHint(top_window, PR_FALSE);
   1:         }
   1:     }
   1: 
 920:     nsRefPtr<nsWindow> owningWindow = get_window_for_gtk_widget(owningWidget);
   1:     if (!owningWindow)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     if (!GTK_WIDGET_HAS_FOCUS(owningWidget)) {
   1:         LOGFOCUS(("  grabbing focus for the toplevel [%p]\n", (void *)this));
   1:         owningWindow->mContainerBlockFocus = PR_TRUE;
   1:         
   1:         // Set focus to the window
   1:         if (gRaiseWindows && aRaise && toplevelWidget &&
   1:             !GTK_WIDGET_HAS_FOCUS(toplevelWidget) &&
   1:             owningWindow->mIsShown && GTK_IS_WINDOW(owningWindow->mShell))
   1:           gtk_window_present(GTK_WINDOW(owningWindow->mShell));
   1:         
   1:         gtk_widget_grab_focus(owningWidget);
   1:         owningWindow->mContainerBlockFocus = PR_FALSE;
   1: 
   1:         DispatchGotFocusEvent();
   1: 
   1:         // unset the activate flag
   1:         if (owningWindow->mActivatePending) {
   1:             owningWindow->mActivatePending = PR_FALSE;
   1:             DispatchActivateEvent();
   1:         }
   1: 
   1:         return NS_OK;
   1:     }
   1: 
   1:     // If this is the widget that already has focus, return.
   1:     if (gFocusWindow == this) {
   1:         LOGFOCUS(("  already have focus [%p]\n", (void *)this));
   1:         return NS_OK;
   1:     }
   1: 
   1:     // If there is already a focused child window, dispatch a LOSTFOCUS
   1:     // event from that widget and unset its got focus flag.
   1:     if (gFocusWindow) {
 920:         nsRefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
   1: #ifdef USE_XIM
   1:         // If the focus window and this window share the same input
   1:         // context we don't have to change the focus of the IME
   1:         // context
   1:         if (IM_get_input_context(this) !=
   1:             IM_get_input_context(gFocusWindow))
   1:             gFocusWindow->IMELoseFocus();
   1: #endif
   1:         gFocusWindow->LoseFocus();
   1:     }
   1: 
   1:     // Set this window to be the focused child window, update our has
   1:     // focus flag and dispatch a GOTFOCUS event.
   1:     gFocusWindow = this;
   1: 
   1: #ifdef USE_XIM
   1:     IMESetFocus();
   1: #endif
   1: 
   1:     LOGFOCUS(("  widget now has focus - dispatching events [%p]\n",
   1:               (void *)this));
   1: 
   1:     DispatchGotFocusEvent();
   1: 
   1:     // unset the activate flag
   1:     if (owningWindow->mActivatePending) {
   1:         owningWindow->mActivatePending = PR_FALSE;
   1:         DispatchActivateEvent();
   1:     }
   1: 
   1:     LOGFOCUS(("  done dispatching events in SetFocus() [%p]\n",
   1:               (void *)this));
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::GetScreenBounds(nsRect &aRect)
   1: {
   1:     nsRect origin(0, 0, mBounds.width, mBounds.height);
   1:     WidgetToScreen(origin, aRect);
   1:     LOG(("GetScreenBounds %d %d | %d %d | %d %d\n",
   1:          aRect.x, aRect.y,
   1:          mBounds.width, mBounds.height,
   1:          aRect.width, aRect.height));
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetForegroundColor(const nscolor &aColor)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetBackgroundColor(const nscolor &aColor)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: nsIFontMetrics*
   1: nsWindow::GetFont(void)
   1: {
   1:     return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetFont(const nsFont &aFont)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetCursor(nsCursor aCursor)
   1: {
   1:     // if we're not the toplevel window pass up the cursor request to
   1:     // the toplevel window to handle it.
   1:     if (!mContainer && mDrawingarea) {
   1:         GtkWidget *widget =
   1:             get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1:         nsWindow *window = get_window_for_gtk_widget(widget);
   1:         return window->SetCursor(aCursor);
   1:     }
   1: 
   1:     // Only change cursor if it's actually been changed
   1:     if (aCursor != mCursor) {
   1:         GdkCursor *newCursor = NULL;
   1: 
   1:         newCursor = get_gtk_cursor(aCursor);
   1: 
   1:         if (nsnull != newCursor) {
   1:             mCursor = aCursor;
   1: 
   1:             if (!mContainer)
   1:                 return NS_OK;
   1: 
   1:             gdk_window_set_cursor(GTK_WIDGET(mContainer)->window, newCursor);
   1:         }
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: static
   1: PRUint8* Data32BitTo1Bit(PRUint8* aImageData,
   1:                          PRUint32 aImageBytesPerRow,
   1:                          PRUint32 aWidth, PRUint32 aHeight)
   1: {
   1:   PRUint32 outBpr = (aWidth + 7) / 8;
   1:   
   1:   PRUint8* outData = new PRUint8[outBpr * aHeight];
   1:   if (!outData)
   1:       return NULL;
   1: 
   1:   PRUint8 *outRow = outData,
   1:           *imageRow = aImageData;
   1: 
   1:   for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {
   1:       PRUint8 *irow = imageRow;
   1:       PRUint8 *orow = outRow;
   1:       PRUint8 imagePixels = 0;
   1:       PRUint8 offset = 0;
   1: 
   1:       for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {
   1:           PRUint8 r = *imageRow++,
   1:                   g = *imageRow++,
   1:                   b = *imageRow++;
   1:                /* a = * */imageRow++;
   1: 
   1:           if ((r + b + g) < 3 * 128)
   1:               imagePixels |= (1 << offset);
   1: 
   1:           if (offset == 7) {
   1:               *outRow++ = imagePixels;
   1:               offset = 0;
   1:               imagePixels = 0;
   1:           } else {
   1:               offset++;
   1:           }
   1:       }
   1:       if (offset != 0)
   1:           *outRow++ = imagePixels;
   1: 
   1:       imageRow = irow + aImageBytesPerRow;
   1:       outRow = orow + outBpr;
   1:   }
   1: 
   1:   return outData;
   1: }
   1: 
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetCursor(imgIContainer* aCursor,
   1:                     PRUint32 aHotspotX, PRUint32 aHotspotY)
   1: {
   1:     // if we're not the toplevel window pass up the cursor request to
   1:     // the toplevel window to handle it.
   1:     if (!mContainer && mDrawingarea) {
   1:         GtkWidget *widget =
   1:             get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1:         nsWindow *window = get_window_for_gtk_widget(widget);
   1:         return window->SetCursor(aCursor, aHotspotX, aHotspotY);
   1:     }
   1: 
   1:     if (!sPixbufCursorChecked) {
   1:         PRLibrary* lib;
   1:         _gdk_cursor_new_from_pixbuf = (_gdk_cursor_new_from_pixbuf_fn)
   1:             PR_FindFunctionSymbolAndLibrary("gdk_cursor_new_from_pixbuf", &lib);
 544:         if (lib) {
 544:             // We already link against GDK, so we can unload it.
 544:             PR_UnloadLibrary(lib);
 544:             lib = nsnull;
 544:         }
   1:         _gdk_display_get_default = (_gdk_display_get_default_fn)
   1:             PR_FindFunctionSymbolAndLibrary("gdk_display_get_default", &lib);
 544:         if (lib) {
 544:             // We already link against GDK, so we can unload it.
 544:             PR_UnloadLibrary(lib);
 544:             lib = nsnull;
 544:         }
   1:         sPixbufCursorChecked = PR_TRUE;
   1:     }
   1:     mCursor = nsCursor(-1);
   1: 
   1:     // Get first image frame
   1:     nsCOMPtr<gfxIImageFrame> frame;
   1:     aCursor->GetFrameAt(0, getter_AddRefs(frame));
   1:     if (!frame)
   1:         return NS_ERROR_NOT_AVAILABLE;
   1: 
   1:     nsCOMPtr<nsIImage> img(do_GetInterface(frame));
   1:     if (!img)
   1:         return NS_ERROR_NOT_AVAILABLE;
   1: 
   1:     GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(img);
   1:     if (!pixbuf)
   1:         return NS_ERROR_NOT_AVAILABLE;
   1: 
   1:     int width = gdk_pixbuf_get_width(pixbuf);
   1:     int height = gdk_pixbuf_get_height(pixbuf);
   1:     // Reject cursors greater than 128 pixels in some direction, to prevent
   1:     // spoofing.
   1:     // XXX ideally we should rescale. Also, we could modify the API to
   1:     // allow trusted content to set larger cursors.
   1:     if (width > 128 || height > 128)
   1:         return NS_ERROR_NOT_AVAILABLE;
   1: 
   1:     // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
   1:     // is of course not documented anywhere...
   1:     // So add one if there isn't one yet
   1:     if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
   1:         GdkPixbuf* alphaBuf = gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0);
   1:         gdk_pixbuf_unref(pixbuf);
   1:         if (!alphaBuf) {
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1:         pixbuf = alphaBuf;
   1:     }
   1: 
   1:     GdkCursor* cursor;
   1:     if (!_gdk_cursor_new_from_pixbuf || !_gdk_display_get_default) {
   1:         // Fallback to a monochrome cursor
   1:         GdkPixmap* mask = gdk_pixmap_new(NULL, width, height, 1);
   1:         if (!mask)
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:         PRUint8* data = Data32BitTo1Bit(gdk_pixbuf_get_pixels(pixbuf),
   1:                                         gdk_pixbuf_get_rowstride(pixbuf),
   1:                                         width, height);
   1:         if (!data) {
   1:             g_object_unref(mask);
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1: 
   1:         GdkPixmap* image = gdk_bitmap_create_from_data(NULL, (const gchar*)data, width,
   1:                                                        height);
   1:         delete[] data;
   1:         if (!image) {
   1:             g_object_unref(mask);
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1: 
   1:         gdk_pixbuf_render_threshold_alpha(pixbuf, mask, 0, 0, 0, 0, width,
   1:                                           height, 1);
   1: 
   1:         GdkColor fg = { 0, 0, 0, 0 }; // Black
   1:         GdkColor bg = { 0, 0xFFFF, 0xFFFF, 0xFFFF }; // White
   1: 
   1:         cursor = gdk_cursor_new_from_pixmap(image, mask, &fg, &bg, aHotspotX,
   1:                                             aHotspotY);
   1:         g_object_unref(image);
   1:         g_object_unref(mask);
   1:     } else {
   1:         // Now create the cursor
   1:         cursor = _gdk_cursor_new_from_pixbuf(_gdk_display_get_default(),
   1:                                              pixbuf,
   1:                                              aHotspotX, aHotspotY);
   1:     }
   1:     gdk_pixbuf_unref(pixbuf);
   1:     nsresult rv = NS_ERROR_OUT_OF_MEMORY;
   1:     if (cursor) {
   1:         if (mContainer) {
   1:             gdk_window_set_cursor(GTK_WIDGET(mContainer)->window, cursor);
   1:             rv = NS_OK;
   1:         }
   1:         gdk_cursor_unref(cursor);
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Validate()
   1: {
   1:     // Get the update for this window and, well, just drop it on the
   1:     // floor.
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     GdkRegion *region = gdk_window_get_update_area(mDrawingarea->inner_window);
   1: 
   1:     if (region)
   1:         gdk_region_destroy(region);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Invalidate(PRBool aIsSynchronous)
   1: {
   1:     GdkRectangle rect;
   1: 
   1:     rect.x = mBounds.x;
   1:     rect.y = mBounds.y;
   1:     rect.width = mBounds.width;
   1:     rect.height = mBounds.height;
   1: 
   1:     LOGDRAW(("Invalidate (all) [%p]: %d %d %d %d\n", (void *)this,
   1:              rect.x, rect.y, rect.width, rect.height));
   1: 
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     gdk_window_invalidate_rect(mDrawingarea->inner_window,
   1:                                &rect, FALSE);
   1:     if (aIsSynchronous)
   1:         gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Invalidate(const nsRect &aRect,
   1:                      PRBool        aIsSynchronous)
   1: {
   1:     GdkRectangle rect;
   1: 
   1:     rect.x = aRect.x;
   1:     rect.y = aRect.y;
   1:     rect.width = aRect.width;
   1:     rect.height = aRect.height;
   1: 
   1:     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d (sync: %d)\n", (void *)this,
   1:              rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
   1: 
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     gdk_window_invalidate_rect(mDrawingarea->inner_window,
   1:                                &rect, FALSE);
   1:     if (aIsSynchronous)
   1:         gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::InvalidateRegion(const nsIRegion* aRegion,
   1:                            PRBool           aIsSynchronous)
   1: {
   1:     GdkRegion *region = nsnull;
   1:     aRegion->GetNativeRegion((void *&)region);
   1: 
   1:     if (region && mDrawingarea) {
   1:         GdkRectangle rect;
   1:         gdk_region_get_clipbox(region, &rect);
   1: 
   1:         LOGDRAW(("Invalidate (region) [%p]: %d %d %d %d (sync: %d)\n",
   1:                  (void *)this,
   1:                  rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
   1: 
   1:         gdk_window_invalidate_region(mDrawingarea->inner_window,
   1:                                      region, FALSE);
   1:     }
   1:     else {
   1:         LOGDRAW(("Invalidate (region) [%p] with empty region\n",
   1:                  (void *)this));
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Update()
   1: {
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetColorMap(nsColorMap *aColorMap)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::Scroll(PRInt32  aDx,
   1:                  PRInt32  aDy,
   1:                  nsRect  *aClipRect)
   1: {
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     moz_drawingarea_scroll(mDrawingarea, aDx, aDy);
   1: 
   1:     // Update bounds on our child windows
   1:     for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
   1:         nsRect bounds;
   1:         kid->GetBounds(bounds);
   1:         bounds.x += aDx;
   1:         bounds.y += aDy;
3233:         static_cast<nsBaseWidget*>(kid)->SetBounds(bounds);
   1:     }
   1: 
   1:     // Process all updates so that everything is drawn.
   1:     gdk_window_process_all_updates();
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::ScrollWidgets(PRInt32 aDx,
   1:                         PRInt32 aDy)
   1: {
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     moz_drawingarea_scroll(mDrawingarea, aDx, aDy);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::ScrollRect(nsRect  &aSrcRect,
   1:                      PRInt32  aDx,
   1:                      PRInt32  aDy)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: void*
   1: nsWindow::GetNativeData(PRUint32 aDataType)
   1: {
   1:     switch (aDataType) {
   1:     case NS_NATIVE_WINDOW:
   1:     case NS_NATIVE_WIDGET: {
   1:         if (!mDrawingarea)
   1:             return nsnull;
   1: 
   1:         return mDrawingarea->inner_window;
   1:         break;
   1:     }
   1: 
   1:     case NS_NATIVE_PLUGIN_PORT:
   1:         return SetupPluginPort();
   1:         break;
   1: 
   1:     case NS_NATIVE_DISPLAY:
   1:         return GDK_DISPLAY();
   1:         break;
   1: 
   1:     case NS_NATIVE_GRAPHIC: {
   1:         NS_ASSERTION(nsnull != mToolkit, "NULL toolkit, unable to get a GC");
3233:         return (void *)static_cast<nsGTKToolkit *>(mToolkit)->GetSharedGC();
   1:         break;
   1:     }
   1: 
   1:     case NS_NATIVE_SHELLWIDGET:
   1:         return (void *) mShell;
   1: 
   1:     default:
   1:         NS_WARNING("nsWindow::GetNativeData called with bad value");
   1:         return nsnull;
   1:     }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetBorderStyle(nsBorderStyle aBorderStyle)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetTitle(const nsAString& aTitle)
   1: {
   1:     if (!mShell)
   1:         return NS_OK;
   1: 
   1:     // convert the string into utf8 and set the title.
   1: #define UTF8_FOLLOWBYTE(ch) (((ch) & 0xC0) == 0x80)
   1:     NS_ConvertUTF16toUTF8 titleUTF8(aTitle);
   1:     if (titleUTF8.Length() > NS_WINDOW_TITLE_MAX_LENGTH) {
   1:         // Truncate overlong titles (bug 167315). Make sure we chop after a
   1:         // complete sequence by making sure the next char isn't a follow-byte.
   1:         PRUint32 len = NS_WINDOW_TITLE_MAX_LENGTH;
   1:         while(UTF8_FOLLOWBYTE(titleUTF8[len]))
   1:             --len;
   1:         titleUTF8.Truncate(len);
   1:     }
   1:     gtk_window_set_title(GTK_WINDOW(mShell), (const char *)titleUTF8.get());
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetIcon(const nsAString& aIconSpec)
   1: {
   1:     if (!mShell)
   1:         return NS_OK;
   1: 
   1:     nsCOMPtr<nsILocalFile> iconFile;
   1:     nsCAutoString path;
   1:     nsCStringArray iconList;
   1: 
   1:     // Assume the given string is a local identifier for an icon file.
   1: 
   1:     ResolveIconName(aIconSpec, NS_LITERAL_STRING(".xpm"),
   1:                     getter_AddRefs(iconFile));
   1:     if (iconFile) {
   1:         iconFile->GetNativePath(path);
   1:         iconList.AppendCString(path);
   1:     }
   1: 
   1:     // Get the 16px icon path as well
   1:     ResolveIconName(aIconSpec, NS_LITERAL_STRING("16.xpm"),
   1:                     getter_AddRefs(iconFile));
   1:     if (iconFile) {
   1:         iconFile->GetNativePath(path);
   1:         iconList.AppendCString(path);
   1:     }
   1: 
   1:     // leave the default icon intact if no matching icons were found
   1:     if (iconList.Count() == 0)
   1:         return NS_OK;
   1: 
   1:     return SetWindowIconList(iconList);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetMenuBar(nsIMenuBar * aMenuBar)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::ShowMenuBar(PRBool aShow)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::WidgetToScreen(const nsRect& aOldRect, nsRect& aNewRect)
   1: {
   1:     gint x = 0, y = 0;
   1: 
   1:     if (mContainer) {
   1:         gdk_window_get_root_origin(GTK_WIDGET(mContainer)->window,
   1:                                    &x, &y);
   1:         LOG(("WidgetToScreen (container) %d %d\n", x, y));
   1:     }
   1:     else if (mDrawingarea) {
   1:         gdk_window_get_origin(mDrawingarea->inner_window, &x, &y);
   1:         LOG(("WidgetToScreen (drawing) %d %d\n", x, y));
   1:     }
   1: 
   1:     aNewRect.x = x + aOldRect.x;
   1:     aNewRect.y = y + aOldRect.y;
   1:     aNewRect.width = aOldRect.width;
   1:     aNewRect.height = aOldRect.height;
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::ScreenToWidget(const nsRect& aOldRect, nsRect& aNewRect)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::BeginResizingChildren(void)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::EndResizingChildren(void)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::EnableDragDrop(PRBool aEnable)
   1: {
   1:     return NS_OK;
   1: }
   1: 
   1: void
   1: nsWindow::ConvertToDeviceCoordinates(nscoord &aX,
   1:                                      nscoord &aY)
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::PreCreateWidget(nsWidgetInitData *aWidgetInitData)
   1: {
   1:     if (nsnull != aWidgetInitData) {
   1:         mWindowType = aWidgetInitData->mWindowType;
   1:         mBorderStyle = aWidgetInitData->mBorderStyle;
   1:         return NS_OK;
   1:     }
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::CaptureMouse(PRBool aCapture)
   1: {
   1:     LOG(("CaptureMouse %p\n", (void *)this));
   1: 
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     GtkWidget *widget =
   1:         get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1: 
   1:     if (aCapture) {
   1:         gtk_grab_add(widget);
   1:         GrabPointer();
   1:     }
   1:     else {
   1:         ReleaseGrabs();
   1:         gtk_grab_remove(widget);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
   1:                               PRBool             aDoCapture,
   1:                               PRBool             aConsumeRollupEvent)
   1: {
   1:     if (!mDrawingarea)
   1:         return NS_OK;
   1: 
   1:     GtkWidget *widget =
   1:         get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1: 
   1:     LOG(("CaptureRollupEvents %p\n", (void *)this));
   1: 
   1:     if (aDoCapture) {
   1:         gRollupListener = aListener;
3233:         gRollupWindow = do_GetWeakReference(static_cast<nsIWidget*>
3233:                                                        (this));
   1:         // real grab is only done when there is no dragging
   1:         if (!nsWindow::DragInProgress()) {
   1:             gtk_grab_add(widget);
   1:             GrabPointer();
   1:             GrabKeyboard();
   1:         }
   1:     }
   1:     else {
   1:         if (!nsWindow::DragInProgress()) {
   1:             ReleaseGrabs();
   1:             gtk_grab_remove(widget);
   1:         }
   1:         gRollupListener = nsnull;
   1:         gRollupWindow = nsnull;
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::GetAttention(PRInt32 aCycleCount)
   1: {
   1:     LOG(("nsWindow::GetAttention [%p]\n", (void *)this));
   1: 
   1:     GtkWidget* top_window = nsnull;
   1:     GtkWidget* top_focused_window = nsnull;
   1:     GetToplevelWidget(&top_window);
   1:     if (gFocusWindow)
   1:         gFocusWindow->GetToplevelWidget(&top_focused_window);
   1: 
   1:     // Don't get attention if the window is focused anyway.
   1:     if (top_window && (GTK_WIDGET_VISIBLE(top_window)) &&
   1:         top_window != top_focused_window) {
   1:         SetUrgencyHint(top_window, PR_TRUE);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: void
   1: nsWindow::LoseFocus(void)
   1: {
 889:     // make sure that we reset our key down counter so the next keypress
   1:     // for this widget will get the down event
 889:     memset(mKeyDownFlags, 0, sizeof(mKeyDownFlags));
   1: 
   1:     // Dispatch a lostfocus event
   1:     DispatchLostFocusEvent();
   1: 
   1:     LOGFOCUS(("  widget lost focus [%p]\n", (void *)this));
   1: }
   1: 
   1: #ifdef DEBUG
   1: // Paint flashing code
   1: 
   1: #define CAPS_LOCK_IS_ON \
   1: (gdk_keyboard_get_modifiers() & GDK_LOCK_MASK)
   1: 
   1: #define WANT_PAINT_FLASHING \
   1: (debug_WantPaintFlashing() && CAPS_LOCK_IS_ON)
   1: 
   1: static void
   1: gdk_window_flash(GdkWindow *    aGdkWindow,
   1:                  unsigned int   aTimes,
   1:                  unsigned int   aInterval,  // Milliseconds
   1:                  GdkRegion *    aRegion)
   1: {
   1:   gint         x;
   1:   gint         y;
   1:   gint         width;
   1:   gint         height;
   1:   guint        i;
   1:   GdkGC *      gc = 0;
   1:   GdkColor     white;
   1: 
   1:   gdk_window_get_geometry(aGdkWindow,
   1:                           NULL,
   1:                           NULL,
   1:                           &width,
   1:                           &height,
   1:                           NULL);
   1: 
   1:   gdk_window_get_origin (aGdkWindow,
   1:                          &x,
   1:                          &y);
   1: 
   1:   gc = gdk_gc_new(GDK_ROOT_PARENT());
   1: 
   1:   white.pixel = WhitePixel(gdk_display,DefaultScreen(gdk_display));
   1: 
   1:   gdk_gc_set_foreground(gc,&white);
   1:   gdk_gc_set_function(gc,GDK_XOR);
   1:   gdk_gc_set_subwindow(gc,GDK_INCLUDE_INFERIORS);
   1:   
   1:   gdk_region_offset(aRegion, x, y);
   1:   gdk_gc_set_clip_region(gc, aRegion);
   1: 
   1:   /*
   1:    * Need to do this twice so that the XOR effect can replace 
   1:    * the original window contents.
   1:    */
   1:   for (i = 0; i < aTimes * 2; i++)
   1:   {
   1:     gdk_draw_rectangle(GDK_ROOT_PARENT(),
   1:                        gc,
   1:                        TRUE,
   1:                        x,
   1:                        y,
   1:                        width,
   1:                        height);
   1: 
   1:     gdk_flush();
   1:     
   1:     PR_Sleep(PR_MillisecondsToInterval(aInterval));
   1:   }
   1: 
   1:   gdk_gc_destroy(gc);
   1: 
   1:   gdk_region_offset(aRegion, -x, -y);
   1: }
   1: #endif // DEBUG
   1: 
   1: gboolean
   1: nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
   1: {
   1:     if (mIsDestroyed) {
   1:         LOG(("Expose event on destroyed window [%p] window %p\n",
   1:              (void *)this, (void *)aEvent->window));
   1:         return FALSE;
   1:     }
   1: 
   1:     if (!mDrawingarea)
   1:         return FALSE;
   1: 
   1:     // handle exposes for the inner window only
   1:     if (aEvent->window != mDrawingarea->inner_window)
   1:         return FALSE;
   1: 
   1:     static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
   1: 
   1:     nsCOMPtr<nsIRegion> updateRegion = do_CreateInstance(kRegionCID);
   1:     if (!updateRegion)
   1:         return FALSE;
   1: 
   1:     updateRegion->Init();
   1: 
   1:     GdkRectangle *rects;
   1:     gint nrects;
   1:     gdk_region_get_rectangles(aEvent->region, &rects, &nrects);
3368:     if (NS_UNLIKELY(!rects)) // OOM
3368:         return FALSE;
3368: 
   1:     LOGDRAW(("sending expose event [%p] %p 0x%lx (rects follow):\n",
   1:              (void *)this, (void *)aEvent->window,
   1:              GDK_WINDOW_XWINDOW(aEvent->window)));
   1: 
   1:     GdkRectangle *r;
   1:     GdkRectangle *r_end = rects + nrects;
   1:     for (r = rects; r < r_end; ++r) {
   1:         updateRegion->Union(r->x, r->y, r->width, r->height);
   1:         LOGDRAW(("\t%d %d %d %d\n", r->x, r->y, r->width, r->height));
   1:     }
   1: 
   1:     nsCOMPtr<nsIRenderingContext> rc = getter_AddRefs(GetRenderingContext());
3368:     if (NS_UNLIKELY(!rc)) {
3368:         g_free(rects);
3368:         return FALSE;
3368:     }
   1: 
   1:     PRBool translucent;
   1:     GetWindowTranslucency(translucent);
   1:     nsIntRect boundsRect;
   1:     GdkPixmap* bufferPixmap = nsnull;
   1:     nsRefPtr<gfxXlibSurface> bufferPixmapSurface;
   1: 
   1:     updateRegion->GetBoundingBox(&boundsRect.x, &boundsRect.y,
   1:                                  &boundsRect.width, &boundsRect.height);
   1: 
   1:     // do double-buffering and clipping here
   1:     nsRefPtr<gfxContext> ctx
   1:         = (gfxContext*)rc->GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT);
   1:     ctx->Save();
   1:     ctx->NewPath();
   1:     if (translucent) {
   1:         // Collapse update area to the bounding box. This is so we only have to
   1:         // call UpdateTranslucentWindowAlpha once. After we have dropped
   1:         // support for non-Thebes graphics, UpdateTranslucentWindowAlpha will be
   1:         // our private interface so we can rework things to avoid this.
   1:         ctx->Rectangle(gfxRect(boundsRect.x, boundsRect.y,
   1:                                boundsRect.width, boundsRect.height));
   1:     } else {
   1:         for (r = rects; r < r_end; ++r) {
   1:             ctx->Rectangle(gfxRect(r->x, r->y, r->width, r->height));
   1:         }
   1:     }
   1:     ctx->Clip();
   1: 
   1:     // double buffer
   1:     if (translucent) {
   1:         ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
   1:     } else {
   1: #ifdef MOZ_ENABLE_GLITZ
   1:         ctx->PushGroup(gfxASurface::CONTENT_COLOR);
   1: #else // MOZ_ENABLE_GLITZ
   1:         // Instead of just doing PushGroup we're going to do a little dance
   1:         // to ensure that GDK creates the pixmap, so it doesn't go all
   1:         // XGetGeometry on us in gdk_pixmap_foreign_new_for_display when we
   1:         // paint native themes
   1:         GdkDrawable* d = GDK_DRAWABLE(mDrawingarea->inner_window);
   1:         gint depth = gdk_drawable_get_depth(d);
   1:         bufferPixmap = gdk_pixmap_new(d, boundsRect.width, boundsRect.height, depth);
   1:         if (bufferPixmap) {
   1:             GdkVisual* visual = gdk_drawable_get_visual(GDK_DRAWABLE(bufferPixmap));
   1:             Visual* XVisual = gdk_x11_visual_get_xvisual(visual);
   1:             Display* display = gdk_x11_drawable_get_xdisplay(GDK_DRAWABLE(bufferPixmap));
   1:             Drawable drawable = gdk_x11_drawable_get_xid(GDK_DRAWABLE(bufferPixmap));
   1:             bufferPixmapSurface =
   1:                 new gfxXlibSurface(display, drawable, XVisual,
   1:                                    gfxIntSize(boundsRect.width, boundsRect.height));
   1:             if (bufferPixmapSurface) {
   1:                 bufferPixmapSurface->SetDeviceOffset(gfxPoint(-boundsRect.x, -boundsRect.y));
   1:                 nsCOMPtr<nsIRenderingContext> newRC;
   1:                 nsresult rv = GetDeviceContext()->
   1:                     CreateRenderingContextInstance(*getter_AddRefs(newRC));
   1:                 if (NS_FAILED(rv)) {
   1:                     bufferPixmapSurface = nsnull;
   1:                 } else {
   1:                     rv = newRC->Init(GetDeviceContext(), bufferPixmapSurface);
   1:                     if (NS_FAILED(rv)) {
   1:                         bufferPixmapSurface = nsnull;
   1:                     } else {
   1:                         rc = newRC;
   1:                     }
   1:                 }
   1:             }
   1:         }
   1: #endif // MOZ_ENABLE_GLITZ
   1:     }
2467: 
2467: #if 0
   1:     // NOTE: Paint flashing region would be wrong for cairo, since
   1:     // cairo inflates the update region, etc.  So don't paint flash
   1:     // for cairo.
2467: #ifdef DEBUG
   1:     if (WANT_PAINT_FLASHING && aEvent->window)
   1:         gdk_window_flash(aEvent->window, 1, 100, aEvent->region);
2467: #endif
2467: #endif
   1: 
   1:     nsPaintEvent event(PR_TRUE, NS_PAINT, this);
   1:     event.refPoint.x = aEvent->area.x;
   1:     event.refPoint.y = aEvent->area.y;
   1:     event.rect = nsnull;
   1:     event.region = updateRegion;
   1:     event.renderingContext = rc;
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: 
 920:     // DispatchEvent can Destroy us (bug 378273), avoid doing any paint
 920:     // operations below if that happened - it will lead to XError and exit().
 920:     if (NS_LIKELY(!mIsDestroyed)) {
   1:         if (status != nsEventStatus_eIgnore) {
   1:             if (translucent) {
   1:                 nsRefPtr<gfxPattern> pattern = ctx->PopGroup();
   1:                 ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
   1:                 ctx->SetPattern(pattern);
   1:                 ctx->Paint();
   1: 
   1:                 nsRefPtr<gfxImageSurface> img =
   1:                     new gfxImageSurface(gfxIntSize(boundsRect.width, boundsRect.height),
   1:                                         gfxImageSurface::ImageFormatA8);
3368:                 if (img && !img->CairoStatus()) {
   1:                     img->SetDeviceOffset(gfxPoint(-boundsRect.x, -boundsRect.y));
   1:             
   1:                     nsRefPtr<gfxContext> imgCtx = new gfxContext(img);
3368:                     if (imgCtx) {
   1:                         imgCtx->SetPattern(pattern);
   1:                         imgCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
   1:                         imgCtx->Paint();
3368:                     }
   1: 
   1:                     UpdateTranslucentWindowAlphaInternal(nsRect(boundsRect.x, boundsRect.y,
   1:                                                                 boundsRect.width, boundsRect.height),
   1:                                                          img->Data(), img->Stride());
3368:                 }
   1:             } else {
   1: #ifdef MOZ_ENABLE_GLITZ
   1:                 ctx->PopGroupToSource();
   1:                 ctx->Paint();
   1: #else // MOZ_ENABLE_GLITZ
   1:                 if (bufferPixmapSurface) {
   1:                     ctx->SetSource(bufferPixmapSurface);
   1:                     ctx->Paint();
   1:                 }
   1: #endif // MOZ_ENABLE_GLITZ
   1:             }
   1:         } else {
   1:             // ignore
   1:             if (translucent) {
   1:                 ctx->PopGroup();
   1:             } else {
   1: #ifdef MOZ_ENABLE_GLITZ
   1:                 ctx->PopGroup();
   1: #endif // MOZ_ENABLE_GLITZ
   1:             }
   1:         }
   1: 
   1:         if (bufferPixmap) {
   1:             g_object_unref(G_OBJECT(bufferPixmap));
   1:         }
   1: 
   1:         ctx->Restore();
 920:     }
 920: 
   1:     g_free(rects);
   1: 
   1:     // check the return value!
   1:     return TRUE;
   1: }
   1: 
   1: gboolean
   1: nsWindow::OnConfigureEvent(GtkWidget *aWidget, GdkEventConfigure *aEvent)
   1: {
   1:     LOG(("configure event [%p] %d %d %d %d\n", (void *)this,
   1:          aEvent->x, aEvent->y, aEvent->width, aEvent->height));
   1: 
   1:     // can we shortcut?
   1:     if (mBounds.x == aEvent->x &&
   1:         mBounds.y == aEvent->y)
   1:         return FALSE;
   1: 
   1:     // Toplevel windows need to have their bounds set so that we can
   1:     // keep track of our location.  It's not often that the x,y is set
   1:     // by the layout engine.  Width and height are set elsewhere.
   1:     if (mIsTopLevel) {
   1:         mPlaced = PR_TRUE;
   1:         // Need to translate this into the right coordinates
   1:         nsRect oldrect, newrect;
   1:         WidgetToScreen(oldrect, newrect);
   1:         mBounds.x = newrect.x;
   1:         mBounds.y = newrect.y;
   1:     }
   1: 
   1:     nsGUIEvent event(PR_TRUE, NS_MOVE, this);
   1: 
   1:     event.refPoint.x = aEvent->x;
   1:     event.refPoint.y = aEvent->y;
   1: 
   1:     // XXX mozilla will invalidate the entire window after this move
   1:     // complete.  wtf?
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: 
   1:     return FALSE;
   1: }
   1: 
   1: void
   1: nsWindow::OnSizeAllocate(GtkWidget *aWidget, GtkAllocation *aAllocation)
   1: {
   1:     LOG(("size_allocate [%p] %d %d %d %d\n",
   1:          (void *)this, aAllocation->x, aAllocation->y,
   1:          aAllocation->width, aAllocation->height));
   1: 
   1:     nsRect rect(aAllocation->x, aAllocation->y,
   1:                 aAllocation->width, aAllocation->height);
   1: 
   1:     ResizeTransparencyBitmap(rect.width, rect.height);
   1: 
   1:     mBounds.width = rect.width;
   1:     mBounds.height = rect.height;
   1: 
   1:     if (!mDrawingarea)
   1:         return;
   1: 
   1:     moz_drawingarea_resize (mDrawingarea, rect.width, rect.height);
   1: 
   1:     if (mTransparencyBitmap) {
   1:       ApplyTransparencyBitmap();
   1:     }
   1: 
   1:     nsEventStatus status;
   1:     DispatchResizeEvent (rect, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnDeleteEvent(GtkWidget *aWidget, GdkEventAny *aEvent)
   1: {
   1:     nsGUIEvent event(PR_TRUE, NS_XUL_CLOSE, this);
   1: 
   1:     event.refPoint.x = 0;
   1:     event.refPoint.y = 0;
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnEnterNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)
   1: {
   1:     // XXXldb Is this the right test for embedding cases?
   1:     if (aEvent->subwindow != NULL)
   1:         return;
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_ENTER, this, nsMouseEvent::eReal);
   1: 
   1:     event.refPoint.x = nscoord(aEvent->x);
   1:     event.refPoint.y = nscoord(aEvent->y);
   1: 
   1:     event.time = aEvent->time;
   1: 
   1:     LOG(("OnEnterNotify: %p\n", (void *)this));
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnLeaveNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)
   1: {
   1:     // XXXldb Is this the right test for embedding cases?
   1:     if (aEvent->subwindow != NULL)
   1:         return;
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_EXIT, this, nsMouseEvent::eReal);
   1: 
   1:     event.refPoint.x = nscoord(aEvent->x);
   1:     event.refPoint.y = nscoord(aEvent->y);
   1: 
   1:     event.time = aEvent->time;
   1: 
   1:     LOG(("OnLeaveNotify: %p\n", (void *)this));
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnMotionNotifyEvent(GtkWidget *aWidget, GdkEventMotion *aEvent)
   1: {
   1:     // when we receive this, it must be that the gtk dragging is over,
   1:     // it is dropped either in or out of mozilla, clear the flag
   1:     sIsDraggingOutOf = PR_FALSE;
   1: 
   1:     // see if we can compress this event
   1:     // XXXldb Why skip every other motion event when we have multiple,
   1:     // but not more than that?
   1:     XEvent xevent;
   1:     PRPackedBool synthEvent = PR_FALSE;
   1:     while (XCheckWindowEvent(GDK_WINDOW_XDISPLAY(aEvent->window),
   1:                              GDK_WINDOW_XWINDOW(aEvent->window),
   1:                              ButtonMotionMask, &xevent)) {
   1:         synthEvent = PR_TRUE;
   1:     }
   1: 
   1:     // if plugins still keeps the focus, get it back
   1:     if (gPluginFocusWindow && gPluginFocusWindow != this) {
 920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
   1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
   1:     }
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, this, nsMouseEvent::eReal);
   1: 
   1:     if (synthEvent) {
   1:         event.refPoint.x = nscoord(xevent.xmotion.x);
   1:         event.refPoint.y = nscoord(xevent.xmotion.y);
   1: 
   1:         event.isShift   = (xevent.xmotion.state & GDK_SHIFT_MASK)
   1:             ? PR_TRUE : PR_FALSE;
   1:         event.isControl = (xevent.xmotion.state & GDK_CONTROL_MASK)
   1:             ? PR_TRUE : PR_FALSE;
   1:         event.isAlt     = (xevent.xmotion.state & GDK_MOD1_MASK)
   1:             ? PR_TRUE : PR_FALSE;
   1: 
   1:         event.time = xevent.xmotion.time;
   1:     }
   1:     else {
   1:         event.refPoint.x = nscoord(aEvent->x);
   1:         event.refPoint.y = nscoord(aEvent->y);
   1: 
   1:         event.isShift   = (aEvent->state & GDK_SHIFT_MASK)
   1:             ? PR_TRUE : PR_FALSE;
   1:         event.isControl = (aEvent->state & GDK_CONTROL_MASK)
   1:             ? PR_TRUE : PR_FALSE;
   1:         event.isAlt     = (aEvent->state & GDK_MOD1_MASK)
   1:             ? PR_TRUE : PR_FALSE;
   1: 
   1:         event.time = aEvent->time;
   1:     }
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnButtonPressEvent(GtkWidget *aWidget, GdkEventButton *aEvent)
   1: {
   1:     nsEventStatus status;
   1: 
   1:     // If you double click in GDK, it will actually generate a single
   1:     // click event before sending the double click event, and this is
   1:     // different than the DOM spec.  GDK puts this in the queue
   1:     // programatically, so it's safe to assume that if there's a
   1:     // double click in the queue, it was generated so we can just drop
   1:     // this click.
   1:     GdkEvent *peekedEvent = gdk_event_peek();
   1:     if (peekedEvent) {
   1:         GdkEventType type = peekedEvent->any.type;
   1:         gdk_event_free(peekedEvent);
   1:         if (type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS)
   1:             return;
   1:     }
   1: 
   1:     // Always save the time of this event
   1:     mLastButtonPressTime = aEvent->time;
   1:     mLastButtonReleaseTime = 0;
   1: 
   1:     // check to see if we should rollup
   1:     nsWindow *containerWindow;
   1:     GetContainerWindow(&containerWindow);
   1: 
   1:     if (!gFocusWindow) {
   1:         containerWindow->mActivatePending = PR_FALSE;
   1:         DispatchActivateEvent();
   1:     }
   1:     if (check_for_rollup(aEvent->window, aEvent->x_root, aEvent->y_root,
   1:                          PR_FALSE))
   1:         return;
   1: 
   1:     PRUint16 domButton;
   1:     switch (aEvent->button) {
   1:     case 2:
   1:         domButton = nsMouseEvent::eMiddleButton;
   1:         break;
   1:     case 3:
   1:         domButton = nsMouseEvent::eRightButton;
   1:         break;
   1:     default:
   1:         domButton = nsMouseEvent::eLeftButton;
   1:         break;
   1:     }
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_BUTTON_DOWN, this, nsMouseEvent::eReal);
   1:     event.button = domButton;
   1:     InitButtonEvent(event, aEvent);
   1: 
   1:     DispatchEvent(&event, status);
   1: 
   1:     // right menu click on linux should also pop up a context menu
 920:     if (domButton == nsMouseEvent::eRightButton &&
 920:         NS_LIKELY(!mIsDestroyed)) {
   1:         nsMouseEvent contextMenuEvent(PR_TRUE, NS_CONTEXTMENU, this,
   1:                                       nsMouseEvent::eReal);
   1:         InitButtonEvent(contextMenuEvent, aEvent);
   1:         DispatchEvent(&contextMenuEvent, status);
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::OnButtonReleaseEvent(GtkWidget *aWidget, GdkEventButton *aEvent)
   1: {
   1:     PRUint16 domButton;
   1:     mLastButtonReleaseTime = aEvent->time;
   1: 
   1:     switch (aEvent->button) {
   1:     case 2:
   1:         domButton = nsMouseEvent::eMiddleButton;
   1:         break;
   1:     case 3:
   1:         domButton = nsMouseEvent::eRightButton;
   1:         break;
   1:         // don't send events for these types
   1:     case 4:
   1:     case 5:
   1:         return;
   1:         break;
   1:         // default including button 1 is left button up
   1:     default:
   1:         domButton = nsMouseEvent::eLeftButton;
   1:         break;
   1:     }
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_BUTTON_UP, this, nsMouseEvent::eReal);
   1:     event.button = domButton;
   1:     InitButtonEvent(event, aEvent);
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnContainerFocusInEvent(GtkWidget *aWidget, GdkEventFocus *aEvent)
   1: {
   1:     LOGFOCUS(("OnContainerFocusInEvent [%p]\n", (void *)this));
   1:     // Return if someone has blocked events for this widget.  This will
   1:     // happen if someone has called gtk_widget_grab_focus() from
   1:     // nsWindow::SetFocus() and will prevent recursion.
   1:     if (mContainerBlockFocus) {
   1:         LOGFOCUS(("Container focus is blocked [%p]\n", (void *)this));
   1:         return;
   1:     }
   1: 
   1:     if (mIsTopLevel)
   1:         mActivatePending = PR_TRUE;
   1: 
   1:     // Unset the urgency hint, if possible
   1:     GtkWidget* top_window = nsnull;
   1:     GetToplevelWidget(&top_window);
   1:     if (top_window && (GTK_WIDGET_VISIBLE(top_window)))
   1:         SetUrgencyHint(top_window, PR_FALSE);
   1: 
   1:     // dispatch a got focus event
   1:     DispatchGotFocusEvent();
   1: 
   1:     // send the activate event if it wasn't already sent via any
   1:     // SetFocus() calls that were the result of the GOTFOCUS event
   1:     // above.
   1:     if (mActivatePending) {
   1:         mActivatePending = PR_FALSE;
   1:         DispatchActivateEvent();
   1:     }
   1: 
   1:     LOGFOCUS(("Events sent from focus in event [%p]\n", (void *)this));
   1: }
   1: 
   1: void
   1: nsWindow::OnContainerFocusOutEvent(GtkWidget *aWidget, GdkEventFocus *aEvent)
   1: {
   1:     LOGFOCUS(("OnContainerFocusOutEvent [%p]\n", (void *)this));
   1: 
   1:     // plugin lose focus
   1:     if (gPluginFocusWindow) {
 920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
   1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
   1:     }
   1: 
   1:     // Figure out if the focus widget is the child of this window.  If
   1:     // it is, send a focus out and deactivate event for it.
   1:     if (!gFocusWindow)
   1:         return;
   1: 
   1:     GdkWindow *tmpWindow;
   1:     tmpWindow = (GdkWindow *)gFocusWindow->GetNativeData(NS_NATIVE_WINDOW);
   1:     nsWindow *tmpnsWindow = get_window_for_gdk_window(tmpWindow);
   1: 
   1:     while (tmpWindow && tmpnsWindow) {
   1:         // found it!
   1:         if (tmpnsWindow == this)
   1:             goto foundit;
   1: 
   1:         tmpWindow = gdk_window_get_parent(tmpWindow);
   1:         if (!tmpWindow)
   1:             break;
   1: 
   1:         tmpnsWindow = get_owning_window_for_gdk_window(tmpWindow);
   1:     }
   1: 
   1:     LOGFOCUS(("The focus widget was not a child of this window [%p]\n",
   1:               (void *)this));
   1: 
   1:     return;
   1: 
   1:  foundit:
   1: 
 920:     nsRefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
   1: #ifdef USE_XIM
   1:     gFocusWindow->IMELoseFocus();
   1: #endif
   1: 
   1:     gFocusWindow->LoseFocus();
   1: 
   1:     // We only dispatch a deactivate event if we are a toplevel
   1:     // window, otherwise the embedding code takes care of it.
 920:     if (mIsTopLevel && NS_LIKELY(!gFocusWindow->mIsDestroyed))
   1:         gFocusWindow->DispatchDeactivateEvent();
   1: 
   1:     gFocusWindow = nsnull;
   1: 
   1:     mActivatePending = PR_FALSE;
   1: 
   1:     LOGFOCUS(("Done with container focus out [%p]\n", (void *)this));
   1: }
   1: 
   1: gboolean
   1: nsWindow::OnKeyPressEvent(GtkWidget *aWidget, GdkEventKey *aEvent)
   1: {
   1:     LOGFOCUS(("OnKeyPressEvent [%p]\n", (void *)this));
   1: 
   1: #ifdef USE_XIM
   1:     // if we are in the middle of composing text, XIM gets to see it
   1:     // before mozilla does.
   1:    LOGIM(("key press [%p]: composing %d val %d\n",
   1:            (void *)this, IMEComposingWindow() != nsnull, aEvent->keyval));
   1:    if (IMEFilterEvent(aEvent))
   1:        return TRUE;
   1:    LOGIM(("sending as regular key press event\n"));
   1: #endif
   1: 
   1:     nsEventStatus status;
   1: 
   1:     // work around for annoying things.
   1:     if (aEvent->keyval == GDK_Tab && aEvent->state & GDK_CONTROL_MASK &&
   1:         aEvent->state & GDK_MOD1_MASK) {
   1:         return TRUE;
   1:     }
   1: 
   1:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
   1: 
 889:     // If the key down flag isn't set then set it so we don't send
   1:     // another key down event on the next key press -- DOM events are
   1:     // key down, key press and key up.  X only has key press and key
   1:     // release.  gtk2 already filters the extra key release events for
   1:     // us.
   1: 
   1:     PRBool isKeyDownCancelled = PR_FALSE;
 889:     
 889:     PRUint32 domVirtualKeyCode = GdkKeyCodeToDOMKeyCode(aEvent->keyval);
 889: 
 889:     if (!IsKeyDown(domVirtualKeyCode)) {
 889:         SetKeyDownFlag(domVirtualKeyCode);
   1: 
   1:         // send the key down event
   1:         nsKeyEvent downEvent(PR_TRUE, NS_KEY_DOWN, this);
   1:         InitKeyEvent(downEvent, aEvent);
   1:         DispatchEvent(&downEvent, status);
 920:         if (NS_UNLIKELY(mIsDestroyed))
 920:             return PR_TRUE;
   1:         isKeyDownCancelled = (status == nsEventStatus_eConsumeNoDefault);
   1:     }
   1: 
   1:     // Don't pass modifiers as NS_KEY_PRESS events.
   1:     // TODO: Instead of selectively excluding some keys from NS_KEY_PRESS events,
   1:     //       we should instead selectively include (as per MSDN spec; no official
   1:     //       spec covers KeyPress events).
   1:     if (aEvent->keyval == GDK_Shift_L
   1:         || aEvent->keyval == GDK_Shift_R
   1:         || aEvent->keyval == GDK_Control_L
   1:         || aEvent->keyval == GDK_Control_R
   1:         || aEvent->keyval == GDK_Alt_L
   1:         || aEvent->keyval == GDK_Alt_R
   1:         || aEvent->keyval == GDK_Meta_L
   1:         || aEvent->keyval == GDK_Meta_R) {
   1:         return TRUE;
   1:     }
   1:     nsKeyEvent event(PR_TRUE, NS_KEY_PRESS, this);
   1:     InitKeyEvent(event, aEvent);
   1:     if (isKeyDownCancelled) {
   1:       // If prevent default set for onkeydown, do the same for onkeypress
   1:       event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
   1:     }
   1:     event.charCode = nsConvertCharCodeToUnicode(aEvent);
   1:     if (event.charCode) {
   1:         event.keyCode = 0;
   1:         // if the control, meta, or alt key is down, then we should leave
   1:         // the isShift flag alone (probably not a printable character)
   1:         // if none of the other modifier keys are pressed then we need to
   1:         // clear isShift so the character can be inserted in the editor
   1: 
   1:         if (event.isControl || event.isAlt || event.isMeta) {
   1:            // make Ctrl+uppercase functional as same as Ctrl+lowercase
   1:            // when Ctrl+uppercase(eg.Ctrl+C) is pressed,convert the charCode
   1:            // from uppercase to lowercase(eg.Ctrl+c),so do Alt and Meta Key
   1:            // It is hack code for bug 61355, there is same code snip for
   1:            // Windows platform in widget/src/windows/nsWindow.cpp: See bug 16486
   1:            // Note: if Shift is pressed at the same time, do not to_lower()
   1:            // Because Ctrl+Shift has different function with Ctrl
   1:            if (!event.isShift &&
   1:                event.charCode >= GDK_A &&
   1:                event.charCode <= GDK_Z)
   1:             event.charCode = gdk_keyval_to_lower(event.charCode);
   1: 
   1:            // Keep the characters unshifted for shortcuts and accesskeys and
   1:            // make sure that numbers are always passed as such (among others:
   1:            // bugs 50255 and 351310)
   1:            if (!event.isControl && event.isShift &&
   1:                (event.charCode < GDK_0 || event.charCode > GDK_9)) {
   1:                GdkKeymapKey k = { aEvent->hardware_keycode, aEvent->group, 0 };
   1:                guint savedKeyval = aEvent->keyval;
   1:                aEvent->keyval = gdk_keymap_lookup_key(gdk_keymap_get_default(), &k);
   1:                PRUint32 unshiftedCharCode = nsConvertCharCodeToUnicode(aEvent);
   1:                if (unshiftedCharCode)
   1:                    event.charCode = unshiftedCharCode;
   1:                else
   1:                    aEvent->keyval = savedKeyval;
   1:            }
   1:         }
   1:     }
   1: 
   1:     // before we dispatch a key, check if it's the context menu key.
   1:     // If so, send a context menu key event instead.
   1:     if (is_context_menu_key(event)) {
   1:         nsMouseEvent contextMenuEvent(PR_TRUE, 0, nsnull, nsMouseEvent::eReal);
   1:         key_event_to_context_menu_event(&event, &contextMenuEvent);
   1:         DispatchEvent(&contextMenuEvent, status);
   1:     }
   1:     else {
   1:         // send the key press event
   1:         DispatchEvent(&event, status);
   1:     }
   1: 
   1:     // If the event was consumed, return.
   1:     LOGIM(("status %d\n", status));
   1:     if (status == nsEventStatus_eConsumeNoDefault) {
   1:         LOGIM(("key press consumed\n"));
   1:         return TRUE;
   1:     }
   1: 
   1:     return FALSE;
   1: }
   1: 
   1: gboolean
   1: nsWindow::OnKeyReleaseEvent(GtkWidget *aWidget, GdkEventKey *aEvent)
   1: {
   1:     LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void *)this));
   1: 
   1: #ifdef USE_XIM
   1:     if (IMEFilterEvent(aEvent))
   1:         return TRUE;
   1: #endif
   1: 
   1:     // send the key event as a key up event
   1:     nsKeyEvent event(PR_TRUE, NS_KEY_UP, this);
   1:     InitKeyEvent(event, aEvent);
   1: 
 889:     // unset the key down flag
 889:     ClearKeyDownFlag(event.keyCode);
 889: 
 920:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: 
   1:     // If the event was consumed, return.
   1:     if (status == nsEventStatus_eConsumeNoDefault) {
   1:         LOGIM(("key release consumed\n"));
   1:         return TRUE;
   1:     }
   1: 
   1:     return FALSE;
   1: }
   1: 
   1: void
   1: nsWindow::OnScrollEvent(GtkWidget *aWidget, GdkEventScroll *aEvent)
   1: {
   1:     nsMouseScrollEvent event(PR_TRUE, NS_MOUSE_SCROLL, this);
   1:     InitMouseScrollEvent(event, aEvent);
   1: 
   1:     // check to see if we should rollup
   1:     if (check_for_rollup(aEvent->window, aEvent->x_root, aEvent->y_root,
   1:                          PR_TRUE)) {
   1:         return;
   1:     }
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::OnVisibilityNotifyEvent(GtkWidget *aWidget,
   1:                                   GdkEventVisibility *aEvent)
   1: {
   1:     switch (aEvent->state) {
   1:     case GDK_VISIBILITY_UNOBSCURED:
   1:     case GDK_VISIBILITY_PARTIAL:
   1:         mIsVisible = PR_TRUE;
   1:         // if we have to retry the grab, retry it.
   1:         EnsureGrabs();
   1:         break;
   1:     default: // includes GDK_VISIBILITY_FULLY_OBSCURED
   1:         mIsVisible = PR_FALSE;
   1:         break;
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::OnWindowStateEvent(GtkWidget *aWidget, GdkEventWindowState *aEvent)
   1: {
   1:     LOG(("nsWindow::OnWindowStateEvent [%p] changed %d new_window_state %d\n",
   1:          (void *)this, aEvent->changed_mask, aEvent->new_window_state));
   1: 
   1:     nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
   1: 
   1:     // We don't care about anything but changes in the maximized/icon
   1:     // states
   1:     if (aEvent->changed_mask &
   1:         (GDK_WINDOW_STATE_ICONIFIED|GDK_WINDOW_STATE_MAXIMIZED) == 0) {
   1:         return;
   1:     }
   1: 
   1:     if (aEvent->new_window_state & GDK_WINDOW_STATE_ICONIFIED) {
   1:         LOG(("\tIconified\n"));
   1:         event.mSizeMode = nsSizeMode_Minimized;
   1:         mSizeState = nsSizeMode_Minimized;
   1:     }
   1:     else if (aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
   1:         LOG(("\tMaximized\n"));
   1:         event.mSizeMode = nsSizeMode_Maximized;
   1:         mSizeState = nsSizeMode_Maximized;
   1:     }
   1:     else {
   1:         LOG(("\tNormal\n"));
   1:         event.mSizeMode = nsSizeMode_Normal;
   1:         mSizeState = nsSizeMode_Normal;
   1:     }
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: void
   1: nsWindow::ThemeChanged()
   1: {
   1:     nsGUIEvent event(PR_TRUE, NS_THEMECHANGED, this);
   1:     nsEventStatus status = nsEventStatus_eIgnore;
   1:     DispatchEvent(&event, status);
   1: 
 920:     if (!mDrawingarea || NS_UNLIKELY(mIsDestroyed))
   1:         return;
   1: 
   1:     // Dispatch NS_THEMECHANGED to all child windows
   1:     GList *children =
   1:         gdk_window_peek_children(mDrawingarea->inner_window);
   1:     while (children) {
   1:         GdkWindow *gdkWin = GDK_WINDOW(children->data);
   1: 
   1:         nsWindow *win = (nsWindow*) g_object_get_data(G_OBJECT(gdkWin),
   1:                                                       "nsWindow");
   1: 
 920:         if (win && win != this) { // guard against infinite recursion
 920:             nsRefPtr<nsWindow> kungFuDeathGrip = win;
   1:             win->ThemeChanged();
 920:         }
   1: 
   1:         children = children->next;
   1:     }
   1: }
   1: 
   1: gboolean
   1: nsWindow::OnDragMotionEvent(GtkWidget *aWidget,
   1:                             GdkDragContext *aDragContext,
   1:                             gint aX,
   1:                             gint aY,
   1:                             guint aTime,
   1:                             gpointer aData)
   1: {
   1:     LOG(("nsWindow::OnDragMotionSignal\n"));
   1: 
   1:     if (mLastButtonReleaseTime) {
   1:       // The drag ended before it was even setup to handle the end of the drag
   1:       // So, we fake the button getting released again to release the drag
   1:       GtkWidget *widget = gtk_grab_get_current();
   1:       GdkEvent event;
   1:       gboolean retval;
   1:       memset(&event, 0, sizeof(event));
   1:       event.type = GDK_BUTTON_RELEASE;
   1:       event.button.time = mLastButtonReleaseTime;
   1:       event.button.button = 1;
   1:       mLastButtonReleaseTime = 0;
   1:       if (widget) {
   1:         g_signal_emit_by_name(widget, "button_release_event", &event, &retval);
   1:         return TRUE;
   1:       }
   1:     }
   1: 
   1:     sIsDraggingOutOf = PR_FALSE;
   1: 
   1:     // Reset out drag motion timer
   1:     ResetDragMotionTimer(aWidget, aDragContext, aX, aY, aTime);
   1: 
   1:     // get our drag context
   1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
   1:     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
   1: 
   1:     // first, figure out which internal widget this drag motion actually
   1:     // happened on
   1:     nscoord retx = 0;
   1:     nscoord rety = 0;
   1: 
 920:     GdkWindow *innerWindow = get_inner_gdk_window(aWidget->window, aX, aY,
   1:                                                   &retx, &rety);
 920:     nsRefPtr<nsWindow> innerMostWidget = get_window_for_gdk_window(innerWindow);
   1: 
   1:     if (!innerMostWidget)
   1:         innerMostWidget = this;
   1: 
   1:     // check to see if there was a drag motion window already in place
   1:     if (mLastDragMotionWindow) {
   1:         // if it wasn't this
   1:         if (mLastDragMotionWindow != innerMostWidget) {
   1:             // send a drag event to the last window that got a motion event
 920:             nsRefPtr<nsWindow> kungFuDeathGrip = mLastDragMotionWindow;
   1:             mLastDragMotionWindow->OnDragLeave();
   1:             // and enter on the new one
   1:             innerMostWidget->OnDragEnter(retx, rety);
   1:         }
   1:     }
   1:     else {
   1:         // if there was no other motion window, then we're starting a
   1:         // drag. Send an enter event to initiate the drag.
   1: 
   1:         innerMostWidget->OnDragEnter(retx, rety);
   1:     }
   1: 
   1:     // set the last window to the innerMostWidget
   1:     mLastDragMotionWindow = innerMostWidget;
   1: 
   1:     // update the drag context
   1:     dragSessionGTK->TargetSetLastContext(aWidget, aDragContext, aTime);
   1: 
   1:     // notify the drag service that we are starting a drag motion.
   1:     dragSessionGTK->TargetStartDragMotion();
   1: 
 482:     dragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
 482: 
   1:     nsMouseEvent event(PR_TRUE, NS_DRAGDROP_OVER, innerMostWidget,
   1:                        nsMouseEvent::eReal);
   1: 
   1:     InitDragEvent(event);
   1: 
   1:     // now that we have initialized the event update our drag status
   1:     UpdateDragStatus(event, aDragContext, dragService);
   1: 
   1:     event.refPoint.x = retx;
   1:     event.refPoint.y = rety;
   1:     event.time = aTime;
   1: 
   1:     nsEventStatus status;
   1:     innerMostWidget->DispatchEvent(&event, status);
   1: 
   1:     // we're done with the drag motion event.  notify the drag service.
   1:     dragSessionGTK->TargetEndDragMotion(aWidget, aDragContext, aTime);
   1: 
   1:     // and unset our context
   1:     dragSessionGTK->TargetSetLastContext(0, 0, 0);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: void
   1: nsWindow::OnDragLeaveEvent(GtkWidget *aWidget,
   1:                            GdkDragContext *aDragContext,
   1:                            guint aTime,
   1:                            gpointer aData)
   1: {
   1:     // XXX Do we want to pass this on only if the event's subwindow is null?
   1: 
   1:     LOG(("nsWindow::OnDragLeaveSignal(%p)\n", this));
   1: 
   1:     sIsDraggingOutOf = PR_TRUE;
   1: 
   1:     // make sure to unset any drag motion timers here.
   1:     ResetDragMotionTimer(0, 0, 0, 0, 0);
   1: 
   1:     // create a fast timer - we're delaying the drag leave until the
   1:     // next mainloop in hopes that we might be able to get a drag drop
   1:     // signal
   1:     mDragLeaveTimer = do_CreateInstance("@mozilla.org/timer;1");
   1:     NS_ASSERTION(mDragLeaveTimer, "Failed to create drag leave timer!");
   1:     // fire this baby asafp, but not too quickly... see bug 216800 ;-)
   1:     mDragLeaveTimer->InitWithFuncCallback(DragLeaveTimerCallback,
   1:                                           (void *)this,
   1:                                           20, nsITimer::TYPE_ONE_SHOT);
   1: }
   1: 
   1: gboolean
   1: nsWindow::OnDragDropEvent(GtkWidget *aWidget,
   1:                           GdkDragContext *aDragContext,
   1:                           gint aX,
   1:                           gint aY,
   1:                           guint aTime,
   1:                           gpointer *aData)
   1: 
   1: {
   1:     LOG(("nsWindow::OnDragDropSignal\n"));
   1: 
   1:     // get our drag context
   1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
   1:     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
   1: 
   1:     nscoord retx = 0;
   1:     nscoord rety = 0;
   1: 
 920:     GdkWindow *innerWindow = get_inner_gdk_window(aWidget->window, aX, aY,
 920:                                                   &retx, &rety);
 920:     nsRefPtr<nsWindow> innerMostWidget = get_window_for_gdk_window(innerWindow);
   1: 
   1:     // set this now before any of the drag enter or leave events happen
   1:     dragSessionGTK->TargetSetLastContext(aWidget, aDragContext, aTime);
   1: 
   1:     if (!innerMostWidget)
   1:         innerMostWidget = this;
   1: 
   1:     // check to see if there was a drag motion window already in place
   1:     if (mLastDragMotionWindow) {
   1:         // if it wasn't this
   1:         if (mLastDragMotionWindow != innerMostWidget) {
   1:             // send a drag event to the last window that got a motion event
 920:             nsRefPtr<nsWindow> kungFuDeathGrip = mLastDragMotionWindow;
   1:             mLastDragMotionWindow->OnDragLeave();
   1:             // and enter on the new one
   1:             innerMostWidget->OnDragEnter(retx, rety);
   1:         }
   1:     }
   1:     else {
   1:         // if there was no other motion window, send an enter event to
   1:         // initiate the drag session.
   1:         innerMostWidget->OnDragEnter(retx, rety);
   1:     }
   1: 
   1:     // clear any drag leave timer that might be pending so that it
   1:     // doesn't get processed when we actually go out to get data.
   1:     if (mDragLeaveTimer) {
   1:         mDragLeaveTimer->Cancel();
   1:         mDragLeaveTimer = 0;
   1:     }
   1: 
   1:     // set the last window to this
   1:     mLastDragMotionWindow = innerMostWidget;
   1: 
   1:     // What we do here is dispatch a new drag motion event to
   1:     // re-validate the drag target and then we do the drop.  The events
   1:     // look the same except for the type.
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_DRAGDROP_OVER, innerMostWidget,
   1:                        nsMouseEvent::eReal);
   1: 
   1:     InitDragEvent(event);
   1: 
   1:     // now that we have initialized the event update our drag status
   1:     UpdateDragStatus(event, aDragContext, dragService);
   1: 
   1:     event.refPoint.x = retx;
   1:     event.refPoint.y = rety;
   1:     event.time = aTime;
   1: 
   1:     nsEventStatus status;
   1:     innerMostWidget->DispatchEvent(&event, status);
   1: 
 920:     // We need to check innerMostWidget->mIsDestroyed here because the nsRefPtr
 920:     // only protects innerMostWidget from being deleted, it does NOT protect
 920:     // against nsView::~nsView() calling Destroy() on it, bug 378670.
 920:     if (!innerMostWidget->mIsDestroyed) {
   1:         event.message = NS_DRAGDROP_DROP;
   1:         event.widget = innerMostWidget;
   1:         event.refPoint.x = retx;
   1:         event.refPoint.y = rety;
   1: 
   1:         innerMostWidget->DispatchEvent(&event, status);
 920:     }
   1: 
   1:     // before we unset the context we need to do a drop_finish
   1: 
   1:     gdk_drop_finish(aDragContext, TRUE, aTime);
   1: 
   1:     // after a drop takes place we need to make sure that the drag
   1:     // service doesn't think that it still has a context.  if the other
   1:     // way ( besides the drop ) to end a drag event is during the leave
   1:     // event and and that case is handled in that handler.
   1:     dragSessionGTK->TargetSetLastContext(0, 0, 0);
   1: 
   1:     // send our drag exit event
   1:     innerMostWidget->OnDragLeave();
   1:     // and clear the mLastDragMotion window
   1:     mLastDragMotionWindow = 0;
   1: 
   1:     // Make sure to end the drag session. If this drag started in a
   1:     // different app, we won't get a drag_end signal to end it from.
 482:     dragService->EndDragSession(PR_TRUE);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: void
   1: nsWindow::OnDragDataReceivedEvent(GtkWidget *aWidget,
   1:                                   GdkDragContext *aDragContext,
   1:                                   gint aX,
   1:                                   gint aY,
   1:                                   GtkSelectionData  *aSelectionData,
   1:                                   guint aInfo,
   1:                                   guint aTime,
   1:                                   gpointer aData)
   1: {
   1:     LOG(("nsWindow::OnDragDataReceived(%p)\n", this));
   1: 
   1:     // get our drag context
   1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
   1:     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
   1: 
   1:     dragSessionGTK->TargetDataReceived(aWidget, aDragContext, aX, aY,
   1:                                        aSelectionData, aInfo, aTime);
   1: }
   1: 
   1: void
   1: nsWindow::OnDragLeave(void)
   1: {
   1:     LOG(("nsWindow::OnDragLeave(%p)\n", this));
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_DRAGDROP_EXIT, this, nsMouseEvent::eReal);
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: 
   1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
   1: 
   1:     if (dragService) {
   1:         nsCOMPtr<nsIDragSession> currentDragSession;
   1:         dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
   1: 
   1:         if (currentDragSession) {
   1:             nsCOMPtr<nsIDOMNode> sourceNode;
   1:             currentDragSession->GetSourceNode(getter_AddRefs(sourceNode));
   1: 
   1:             if (!sourceNode) {
   1:                 // We're leaving a window while doing a drag that was
   1:                 // initiated in a different app. End the drag session,
   1:                 // since we're done with it for now (until the user
   1:                 // drags back into mozilla).
 482:                 dragService->EndDragSession(PR_FALSE);
   1:             }
   1:         }
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::OnDragEnter(nscoord aX, nscoord aY)
   1: {
   1:     // XXX Do we want to pass this on only if the event's subwindow is null?
   1: 
   1:     LOG(("nsWindow::OnDragEnter(%p)\n", this));
   1: 
   1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
   1: 
   1:     if (dragService) {
   1:         // Make sure that the drag service knows we're now dragging.
   1:         dragService->StartDragSession();
   1:     }
   1: 
   1:     nsMouseEvent event(PR_TRUE, NS_DRAGDROP_ENTER, this, nsMouseEvent::eReal);
   1: 
   1:     event.refPoint.x = aX;
   1:     event.refPoint.y = aY;
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1: }
   1: 
   1: static void
   1: GetBrandName(nsXPIDLString& brandName)
   1: {
   1:     nsCOMPtr<nsIStringBundleService> bundleService = 
   1:         do_GetService(NS_STRINGBUNDLE_CONTRACTID);
   1: 
   1:     nsCOMPtr<nsIStringBundle> bundle;
   1:     if (bundleService)
   1:         bundleService->CreateBundle(
   1:             "chrome://branding/locale/brand.properties",
   1:             getter_AddRefs(bundle));
   1: 
   1:     if (bundle)
   1:         bundle->GetStringFromName(
   1:             NS_LITERAL_STRING("brandShortName").get(),
   1:             getter_Copies(brandName));
   1: 
   1:     if (brandName.IsEmpty())
   1:         brandName.Assign(NS_LITERAL_STRING("Mozilla"));
   1: }
   1: 
   1: nsresult
   1: nsWindow::NativeCreate(nsIWidget        *aParent,
   1:                        nsNativeWidget    aNativeParent,
   1:                        const nsRect     &aRect,
   1:                        EVENT_CALLBACK    aHandleEventFunction,
   1:                        nsIDeviceContext *aContext,
   1:                        nsIAppShell      *aAppShell,
   1:                        nsIToolkit       *aToolkit,
   1:                        nsWidgetInitData *aInitData)
   1: {
   1:     // only set the base parent if we're going to be a dialog or a
   1:     // toplevel
   1:     nsIWidget *baseParent = aInitData &&
   1:         (aInitData->mWindowType == eWindowType_dialog ||
   1:          aInitData->mWindowType == eWindowType_toplevel ||
   1:          aInitData->mWindowType == eWindowType_invisible) ?
   1:         nsnull : aParent;
   1: 
   1:     NS_ASSERTION(aInitData->mWindowType != eWindowType_popup ||
   1:                  !aParent, "Popups should not be hooked into nsIWidget hierarchy");
   1: 
   1:     // initialize all the common bits of this class
   1:     BaseCreate(baseParent, aRect, aHandleEventFunction, aContext,
   1:                aAppShell, aToolkit, aInitData);
   1: 
   1:     // Do we need to listen for resizes?
   1:     PRBool listenForResizes = PR_FALSE;;
   1:     if (aNativeParent || (aInitData && aInitData->mListenForResizes))
   1:         listenForResizes = PR_TRUE;
   1: 
   1:     // and do our common creation
   1:     CommonCreate(aParent, listenForResizes);
   1: 
   1:     // save our bounds
   1:     mBounds = aRect;
   1:     if (mWindowType != eWindowType_child) {
   1:         // The window manager might place us. Indicate that if we're
   1:         // shown, we want to go through
   1:         // nsWindow::NativeResize(x,y,w,h) to maybe set our own
   1:         // position.
   1:         mNeedsMove = PR_TRUE;
   1:     }
   1: 
   1:     // figure out our parent window
   1:     MozDrawingarea *parentArea = nsnull;
   1:     MozContainer   *parentMozContainer = nsnull;
   1:     GtkContainer   *parentGtkContainer = nsnull;
   1:     GdkWindow      *parentGdkWindow = nsnull;
   1:     GtkWindow      *topLevelParent = nsnull;
   1: 
   1:     if (aParent)
   1:         parentGdkWindow = GDK_WINDOW(aParent->GetNativeData(NS_NATIVE_WINDOW));
   1:     else if (aNativeParent && GDK_IS_WINDOW(aNativeParent))
   1:         parentGdkWindow = GDK_WINDOW(aNativeParent);
   1:     else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent))
   1:         parentGtkContainer = GTK_CONTAINER(aNativeParent);
   1: 
   1:     if (parentGdkWindow) {
   1:         // find the mozarea on that window
   1:         gpointer user_data = nsnull;
   1:         user_data = g_object_get_data(G_OBJECT(parentGdkWindow),
   1:                                       "mozdrawingarea");
   1:         parentArea = MOZ_DRAWINGAREA(user_data);
   1: 
   1:         NS_ASSERTION(parentArea, "no drawingarea for parent widget!\n");
   1:         if (!parentArea)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         // get the user data for the widget - it should be a container
   1:         user_data = nsnull;
   1:         gdk_window_get_user_data(parentArea->inner_window, &user_data);
   1:         NS_ASSERTION(user_data, "no user data for parentArea\n");
   1:         if (!user_data)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         // Get the parent moz container
   1:         parentMozContainer = MOZ_CONTAINER(user_data);
   1:         NS_ASSERTION(parentMozContainer,
   1:                      "owning widget is not a mozcontainer!\n");
   1:         if (!parentMozContainer)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         // get the toplevel window just in case someone needs to use it
   1:         // for setting transients or whatever.
   1:         topLevelParent =
   1:             GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentMozContainer)));
   1:     }
   1: 
   1:     GdkVisual* visual = nsnull;
   1: #ifdef MOZ_ENABLE_GLITZ
   1:     if (gfxPlatform::UseGlitz()) {
   1:         nsCOMPtr<nsIDeviceContext> dc = aContext;
   1:         if (!dc) {
   1:             nsCOMPtr<nsIDeviceContext> dc = do_CreateInstance(kDeviceContextCID);
   1:             // no parent widget to initialize with
   1:             dc->Init(nsnull);
   1:         }
   1: 
   1:         Display* dpy = GDK_DISPLAY();
   1:         int defaultScreen = gdk_x11_get_default_screen();
   1:         glitz_drawable_format_t* format = glitz_glx_find_window_format (dpy, defaultScreen,
   1:                                                                         0, NULL, 0);
   1:         if (format) {
   1:             XVisualInfo* vinfo = glitz_glx_get_visual_info_from_format(dpy, defaultScreen, format);
   1:             GdkScreen* screen = gdk_display_get_screen(gdk_x11_lookup_xdisplay(dpy), defaultScreen);
   1:             visual = gdk_x11_screen_lookup_visual(screen, vinfo->visualid);
   1:         } else {
   1:             // couldn't find a GLX visual; force Glitz off
   1:             gfxPlatform::SetUseGlitz(PR_FALSE);
   1:         }
   1:     }
   1: #endif
   1: 
   1:     // ok, create our windows
   1:     switch (mWindowType) {
   1:     case eWindowType_dialog:
   1:     case eWindowType_popup:
   1:     case eWindowType_toplevel:
   1:     case eWindowType_invisible: {
   1:         mIsTopLevel = PR_TRUE;
   1: 
   1:         nsXPIDLString brandName;
   1:         GetBrandName(brandName);
   1:         NS_ConvertUTF16toUTF8 cBrand(brandName);
   1: 
   1:         if (mWindowType == eWindowType_dialog) {
   1:             mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
   1:             SetDefaultIcon();
   1:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Dialog", cBrand.get());
   1:             gtk_window_set_type_hint(GTK_WINDOW(mShell),
   1:                                      GDK_WINDOW_TYPE_HINT_DIALOG);
   1:             gtk_window_set_transient_for(GTK_WINDOW(mShell),
   1:                                          topLevelParent);
   1:             mTransientParent = topLevelParent;
   1:             // add ourselves to the parent window's window group
   1:             if (!topLevelParent) {
   1:                 gtk_widget_realize(mShell);
   1:                 GdkWindow* dialoglead = mShell->window;
   1:                 gdk_window_set_group(dialoglead, dialoglead);
   1:             }
   1:             if (parentArea) {
   1:                 nsWindow *parentnsWindow =
   1:                     get_window_for_gdk_window(parentArea->inner_window);
   1:                 NS_ASSERTION(parentnsWindow,
   1:                              "no nsWindow for parentArea!");
   1:                 if (parentnsWindow && parentnsWindow->mWindowGroup) {
   1:                     gtk_window_group_add_window(parentnsWindow->mWindowGroup,
   1:                                                 GTK_WINDOW(mShell));
   1:                     // store this in case any children are created
   1:                     mWindowGroup = parentnsWindow->mWindowGroup;
   1:                     LOG(("adding window %p to group %p\n",
   1:                          (void *)mShell, (void *)mWindowGroup));
   1:                 }
   1:             }
   1:         }
   1:         else if (mWindowType == eWindowType_popup) {
   1:             mShell = gtk_window_new(GTK_WINDOW_POPUP);
   1:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Popup", cBrand.get());
   1: 
   1:             if (topLevelParent) {
   1:                 gtk_window_set_transient_for(GTK_WINDOW(mShell),
   1:                                             topLevelParent);
   1:                 mTransientParent = topLevelParent;
   1: 
   1:                 if (topLevelParent->group) {
   1:                     gtk_window_group_add_window(topLevelParent->group,
   1:                                             GTK_WINDOW(mShell));
   1:                     mWindowGroup = topLevelParent->group;
   1:                 }
   1:             }
   1:         }
   1:         else { // must be eWindowType_toplevel
   1:             mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
   1:             SetDefaultIcon();
   1:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Toplevel", cBrand.get());
   1: 
   1:             // each toplevel window gets its own window group
   1:             mWindowGroup = gtk_window_group_new();
   1: 
   1:             // and add ourselves to the window group
   1:             LOG(("adding window %p to new group %p\n",
   1:                  (void *)mShell, (void *)mWindowGroup));
   1:             gtk_window_group_add_window(mWindowGroup, GTK_WINDOW(mShell));
   1:         }
   1: 
   1:         // create our container
   1:         mContainer = MOZ_CONTAINER(moz_container_new());
   1:         gtk_container_add(GTK_CONTAINER(mShell), GTK_WIDGET(mContainer));
   1:         gtk_widget_realize(GTK_WIDGET(mContainer));
   1: 
   1:         // make sure this is the focus widget in the container
   1:         gtk_window_set_focus(GTK_WINDOW(mShell), GTK_WIDGET(mContainer));
   1: 
   1:         // and the drawing area
   1:         mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
   1: 
   1:         if (mWindowType == eWindowType_popup) {
   1:             // gdk does not automatically set the cursor for "temporary"
   1:             // windows, which are what gtk uses for popups.
   1: 
   1:             mCursor = eCursor_wait; // force SetCursor to actually set the
   1:                                     // cursor, even though our internal state
   1:                                     // indicates that we already have the
   1:                                     // standard cursor.
   1:             SetCursor(eCursor_standard);
   1:         }
   1:     }
   1:         break;
   1:     case eWindowType_child: {
   1:         if (parentMozContainer) {
   1:             mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer, visual);
   1:         }
   1:         else if (parentGtkContainer) {
   1:             mContainer = MOZ_CONTAINER(moz_container_new());
   1:             gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
   1:             gtk_widget_realize(GTK_WIDGET(mContainer));
   1: 
   1:             mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
   1:         }
   1:         else {
   1:             NS_WARNING("Warning: tried to create a new child widget with no parent!");
   1:             return NS_ERROR_FAILURE;
   1:         }
   1:     }
   1:         break;
   1:     default:
   1:         break;
   1:     }
   1:     // Disable the double buffer because it will make the caret crazy
   1:     // For bug#153805 (Gtk2 double buffer makes carets misbehave)
   1:     if (mContainer)
   1:         gtk_widget_set_double_buffered (GTK_WIDGET(mContainer),FALSE);
   1: 
   1:     // label the drawing area with this object so we can find our way
   1:     // home
   1:     g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
   1:                       this);
   1:     g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
   1:                       this);
   1: 
   1:     g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
   1:                       mDrawingarea);
   1:     g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
   1:                       mDrawingarea);
   1: 
   1:     if (mContainer)
   1:         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
   1: 
   1:     if (mShell)
   1:         g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
   1: 
   1:     // attach listeners for events
   1:     if (mShell) {
   1:         g_signal_connect(G_OBJECT(mShell), "configure_event",
   1:                          G_CALLBACK(configure_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mShell), "delete_event",
   1:                          G_CALLBACK(delete_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mShell), "window_state_event",
   1:                          G_CALLBACK(window_state_event_cb), NULL);
   1: 
   1:         GtkSettings* default_settings = gtk_settings_get_default();
   1:         g_signal_connect_after(default_settings,
   1:                                "notify::gtk-theme-name",
   1:                                G_CALLBACK(theme_changed_cb), this);
   1:         g_signal_connect_after(default_settings,
   1:                                "notify::gtk-font-name",
   1:                                G_CALLBACK(theme_changed_cb), this);
   1:     }
   1: 
   1:     if (mContainer) {
   1:         g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
   1:                                G_CALLBACK(size_allocate_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "expose_event",
   1:                          G_CALLBACK(expose_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "enter_notify_event",
   1:                          G_CALLBACK(enter_notify_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "leave_notify_event",
   1:                          G_CALLBACK(leave_notify_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "motion_notify_event",
   1:                          G_CALLBACK(motion_notify_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "button_press_event",
   1:                          G_CALLBACK(button_press_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "button_release_event",
   1:                          G_CALLBACK(button_release_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "focus_in_event",
   1:                          G_CALLBACK(focus_in_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "focus_out_event",
   1:                          G_CALLBACK(focus_out_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "key_press_event",
   1:                          G_CALLBACK(key_press_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "key_release_event",
   1:                          G_CALLBACK(key_release_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "scroll_event",
   1:                          G_CALLBACK(scroll_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "visibility_notify_event",
   1:                          G_CALLBACK(visibility_notify_event_cb), NULL);
   1: 
   1:         gtk_drag_dest_set((GtkWidget *)mContainer,
   1:                           (GtkDestDefaults)0,
   1:                           NULL,
   1:                           0,
   1:                           (GdkDragAction)0);
   1: 
   1:         g_signal_connect(G_OBJECT(mContainer), "drag_motion",
   1:                          G_CALLBACK(drag_motion_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "drag_leave",
   1:                          G_CALLBACK(drag_leave_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "drag_drop",
   1:                          G_CALLBACK(drag_drop_event_cb), NULL);
   1:         g_signal_connect(G_OBJECT(mContainer), "drag_data_received",
   1:                          G_CALLBACK(drag_data_received_event_cb), NULL);
   1: 
   1: #ifdef USE_XIM
   1:         // We create input contexts for all containers, except for
   1:         // toplevel popup windows
   1:         if (mWindowType != eWindowType_popup)
   1:             IMECreateContext();
   1: #endif
   1:     }
   1: 
   1:     LOG(("nsWindow [%p]\n", (void *)this));
   1:     if (mShell) {
   1:         LOG(("\tmShell %p %p %lx\n", (void *)mShell, (void *)mShell->window,
   1:              GDK_WINDOW_XWINDOW(mShell->window)));
   1:     }
   1: 
   1:     if (mContainer) {
   1:         LOG(("\tmContainer %p %p %lx\n", (void *)mContainer,
   1:              (void *)GTK_WIDGET(mContainer)->window,
   1:              GDK_WINDOW_XWINDOW(GTK_WIDGET(mContainer)->window)));
   1:     }
   1: 
   1:     if (mDrawingarea) {
   1:         LOG(("\tmDrawingarea %p %p %p %lx %lx\n", (void *)mDrawingarea,
   1:              (void *)mDrawingarea->clip_window,
   1:              (void *)mDrawingarea->inner_window,
   1:              GDK_WINDOW_XWINDOW(mDrawingarea->clip_window),
   1:              GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)));
   1:     }
   1: 
   1:     // resize so that everything is set to the right dimensions
2144:     if (!mIsTopLevel)
1931:         Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, PR_FALSE);
   1: 
   1: #ifdef ACCESSIBILITY
   1:     nsresult rv;
   1:     if (!sAccessibilityChecked) {
   1:         sAccessibilityChecked = PR_TRUE;
   1: 
   1:         //check if accessibility enabled/disabled by environment variable
   1:         const char *envValue = PR_GetEnv(sAccEnv);
   1:         if (envValue) {
   1:             sAccessibilityEnabled = atoi(envValue);
   1:             LOG(("Accessibility Env %s=%s\n", sAccEnv, envValue));
   1:         }
   1:         //check gconf-2 setting
   1:         else {
   1:             nsCOMPtr<nsIPrefBranch> sysPrefService =
   1:                 do_GetService(sSysPrefService, &rv);
   1:             if (NS_SUCCEEDED(rv) && sysPrefService) {
   1: 
   1:                 // do the work to get gconf setting.
   1:                 // will be done soon later.
   1:                 sysPrefService->GetBoolPref(sAccessibilityKey,
   1:                                             &sAccessibilityEnabled);
   1:             }
   1: 
   1:         }
   1:     }
   1:     if (sAccessibilityEnabled) {
   1:         LOG(("nsWindow:: Create Toplevel Accessibility\n"));
   1:         CreateRootAccessible();
   1:     }
   1: #endif
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetWindowClass(const nsAString &xulWinType)
   1: {
   1:   if (!mShell)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsXPIDLString brandName;
   1:   GetBrandName(brandName);
   1: 
   1:   XClassHint *class_hint = XAllocClassHint();
   1:   if (!class_hint)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   const char *role = NULL;
   1:   class_hint->res_name = ToNewCString(xulWinType);
   1:   if (!class_hint->res_name) {
   1:     XFree(class_hint);
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   class_hint->res_class = ToNewCString(brandName);
   1:   if (!class_hint->res_class) {
   1:     nsMemory::Free(class_hint->res_name);
   1:     XFree(class_hint);
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1: 
   1:   // Parse res_name into a name and role. Characters other than
   1:   // [A-Za-z0-9_-] are converted to '_'. Anything after the first
   1:   // colon is assigned to role; if there's no colon, assign the
   1:   // whole thing to both role and res_name.
   1:   for (char *c = class_hint->res_name; *c; c++) {
   1:     if (':' == *c) {
   1:       *c = 0;
   1:       role = c + 1;
   1:     }
   1:     else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
   1:       *c = '_';
   1:   }
   1:   class_hint->res_name[0] = toupper(class_hint->res_name[0]);
   1:   if (!role) role = class_hint->res_name;
   1: 
   1:   gdk_window_set_role(GTK_WIDGET(mShell)->window, role);
   1:   // Can't use gtk_window_set_wmclass() for this; it prints
   1:   // a warning & refuses to make the change.
   1:   XSetClassHint(GDK_DISPLAY(),
   1:                 GDK_WINDOW_XWINDOW(GTK_WIDGET(mShell)->window),
   1:                 class_hint);
   1:   nsMemory::Free(class_hint->res_class);
   1:   nsMemory::Free(class_hint->res_name);
   1:   XFree(class_hint);
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsWindow::NativeResize(PRInt32 aWidth, PRInt32 aHeight, PRBool  aRepaint)
   1: {
   1:     LOG(("nsWindow::NativeResize [%p] %d %d\n", (void *)this,
   1:          aWidth, aHeight));
   1: 
   1:     ResizeTransparencyBitmap(aWidth, aHeight);
   1: 
   1:     // clear our resize flag
   1:     mNeedsResize = PR_FALSE;
   1: 
   1:     if (mIsTopLevel) {
   1:         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
   1:     }
   1:     else if (mContainer) {
   1:         GtkAllocation allocation;
   1:         allocation.x = 0;
   1:         allocation.y = 0;
   1:         allocation.width = aWidth;
   1:         allocation.height = aHeight;
   1:         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
   1:     }
   1: 
   1:     moz_drawingarea_resize (mDrawingarea, aWidth, aHeight);
   1: }
   1: 
   1: void
   1: nsWindow::NativeResize(PRInt32 aX, PRInt32 aY,
   1:                        PRInt32 aWidth, PRInt32 aHeight,
   1:                        PRBool  aRepaint)
   1: {
   1:     mNeedsResize = PR_FALSE;
   1:     mNeedsMove = PR_FALSE;
   1: 
   1:     LOG(("nsWindow::NativeResize [%p] %d %d %d %d\n", (void *)this,
   1:          aX, aY, aWidth, aHeight));
   1: 
   1:     ResizeTransparencyBitmap(aWidth, aHeight);
   1: 
   1:     if (mIsTopLevel) {
   1:         if (mParent && mWindowType == eWindowType_popup) {
   1:             nsRect oldrect, newrect;
   1:             oldrect.x = aX;
   1:             oldrect.y = aY;
   1:             mParent->WidgetToScreen(oldrect, newrect);
   1:             moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
   1:             gtk_window_move(GTK_WINDOW(mShell), newrect.x, newrect.y);
   1:             gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
   1:         }
   1:         else {
   1:             // We only move the toplevel window if someone has
   1:             // actually placed the window somewhere.  If no placement
   1:             // has taken place, we just let the window manager Do The
   1:             // Right Thing.
   1:             if (mPlaced)
   1:                 gtk_window_move(GTK_WINDOW(mShell), aX, aY);
   1: 
   1:             gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
   1:             moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
   1:         }
   1:     }
   1:     else if (mContainer) {
   1:         GtkAllocation allocation;
   1:         allocation.x = 0;
   1:         allocation.y = 0;
   1:         allocation.width = aWidth;
   1:         allocation.height = aHeight;
   1:         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
   1:         moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
   1:     }
   1:     else if (mDrawingarea) {
   1:         moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::NativeShow (PRBool  aAction)
   1: {
   1:     if (aAction) {
   1:         // GTK wants us to set the window mask before we show the window
   1:         // for the first time, or setting the mask later won't work.
   1:         // GTK also wants us to NOT set the window mask if we're not really
   1:         // going to need it, because GTK won't let us unset the mask properly
   1:         // later.
   1:         // So, we delay setting the mask until the last moment: when the window
   1:         // is shown.
   1:         // XXX that may or may not be true for GTK+ 2.x
   1:         if (mTransparencyBitmap) {
   1:             ApplyTransparencyBitmap();
   1:         }
   1: 
   1:         // unset our flag now that our window has been shown
   1:         mNeedsShow = PR_FALSE;
   1: 
   1:         if (mIsTopLevel) {
   1:             // Set up usertime/startupID metadata for the created window.
   1:             if (mWindowType != eWindowType_invisible) {
   1:                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
   1:             }
   1: 
   1:             moz_drawingarea_set_visibility(mDrawingarea, aAction);
   1:             gtk_widget_show(GTK_WIDGET(mContainer));
   1:             gtk_widget_show(mShell);
   1:         }
   1:         else if (mContainer) {
   1:             moz_drawingarea_set_visibility(mDrawingarea, TRUE);
   1:             gtk_widget_show(GTK_WIDGET(mContainer));
   1:         }
   1:         else if (mDrawingarea) {
   1:             moz_drawingarea_set_visibility(mDrawingarea, TRUE);
   1:         }
   1:     }
   1:     else {
   1:         if (mIsTopLevel) {
   1:             gtk_widget_hide(GTK_WIDGET(mShell));
   1:             gtk_widget_hide(GTK_WIDGET(mContainer));
   1:         }
   1:         else if (mContainer) {
   1:             gtk_widget_hide(GTK_WIDGET(mContainer));
   1:             moz_drawingarea_set_visibility(mDrawingarea, FALSE);
   1:         }
   1:         if (mDrawingarea) {
   1:             moz_drawingarea_set_visibility(mDrawingarea, FALSE);
   1:         }
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::EnsureGrabs(void)
   1: {
   1:     if (mRetryPointerGrab)
   1:         GrabPointer();
   1:     if (mRetryKeyboardGrab)
   1:         GrabKeyboard();
   1: }
   1: 
   1: #ifndef MOZ_XUL
   1: void
   1: nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
   1: {
   1: }
   1: 
   1: void
   1: nsWindow::ApplyTransparencyBitmap()
   1: {
   1: }
   1: #else
   1: NS_IMETHODIMP
   1: nsWindow::SetWindowTranslucency(PRBool aTranslucent)
   1: {
   1:     if (!mShell) {
   1:         // Pass the request to the toplevel window
   1:         GtkWidget *topWidget = nsnull;
   1:         GetToplevelWidget(&topWidget);
   1:         if (!topWidget)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
   1:         if (!topWindow)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         return topWindow->SetWindowTranslucency(aTranslucent);
   1:     }
   1: 
   1:     if (mIsTranslucent == aTranslucent)
   1:         return NS_OK;
   1: 
   1:     if (!aTranslucent) {
   1:         if (mTransparencyBitmap) {
   1:             delete[] mTransparencyBitmap;
   1:             mTransparencyBitmap = nsnull;
   1:             mTransparencyBitmapWidth = 0;
   1:             mTransparencyBitmapHeight = 0;
   1:             gtk_widget_reset_shapes(mShell);
   1:         }
   1:     } // else the new default alpha values are "all 1", so we don't
   1:     // need to change anything yet
   1: 
   1:     mIsTranslucent = aTranslucent;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::GetWindowTranslucency(PRBool& aTranslucent)
   1: {
   1:     if (!mShell) {
   1:         // Pass the request to the toplevel window
   1:         GtkWidget *topWidget = nsnull;
   1:         GetToplevelWidget(&topWidget);
   1:         if (!topWidget) {
   1:             aTranslucent = PR_FALSE;
   1:             return NS_ERROR_FAILURE;
   1:         }
   1: 
   1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
   1:         if (!topWindow) {
   1:             aTranslucent = PR_FALSE;
   1:             return NS_ERROR_FAILURE;
   1:         }
   1: 
   1:         return topWindow->GetWindowTranslucency(aTranslucent);
   1:     }
   1: 
   1:     aTranslucent = mIsTranslucent;
   1:     return NS_OK;
   1: }
   1: 
   1: void
   1: nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
   1: {
   1:     if (!mTransparencyBitmap)
   1:         return;
   1: 
   1:     if (aNewWidth == mTransparencyBitmapWidth &&
   1:         aNewHeight == mTransparencyBitmapHeight)
   1:         return;
   1: 
   1:     PRInt32 newSize = ((aNewWidth+7)/8)*aNewHeight;
   1:     gchar* newBits = new gchar[newSize];
   1:     if (!newBits) {
   1:         delete[] mTransparencyBitmap;
   1:         mTransparencyBitmap = nsnull;
   1:         mTransparencyBitmapWidth = 0;
   1:         mTransparencyBitmapHeight = 0;
   1:         return;
   1:     }
   1:     // fill new mask with "opaque", first
   1:     memset(newBits, 255, newSize);
   1: 
   1:     // Now copy the intersection of the old and new areas into the new mask
   1:     PRInt32 copyWidth = PR_MIN(aNewWidth, mTransparencyBitmapWidth);
   1:     PRInt32 copyHeight = PR_MIN(aNewHeight, mTransparencyBitmapHeight);
   1:     PRInt32 oldRowBytes = (mTransparencyBitmapWidth+7)/8;
   1:     PRInt32 newRowBytes = (aNewWidth+7)/8;
   1:     PRInt32 copyBytes = (copyWidth+7)/8;
   1: 
   1:     PRInt32 i;
   1:     gchar* fromPtr = mTransparencyBitmap;
   1:     gchar* toPtr = newBits;
   1:     for (i = 0; i < copyHeight; i++) {
   1:         memcpy(toPtr, fromPtr, copyBytes);
   1:         fromPtr += oldRowBytes;
   1:         toPtr += newRowBytes;
   1:     }
   1: 
   1:     delete[] mTransparencyBitmap;
   1:     mTransparencyBitmap = newBits;
   1:     mTransparencyBitmapWidth = aNewWidth;
   1:     mTransparencyBitmapHeight = aNewHeight;
   1: }
   1: 
   1: static PRBool
   1: ChangedMaskBits(gchar* aMaskBits, PRInt32 aMaskWidth, PRInt32 aMaskHeight,
   1:         const nsRect& aRect, PRUint8* aAlphas, PRInt32 aStride)
   1: {
   1:     PRInt32 x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
   1:     PRInt32 maskBytesPerRow = (aMaskWidth + 7)/8;
   1:     for (y = aRect.y; y < yMax; y++) {
   1:         gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
   1:         PRUint8* alphas = aAlphas;
   1:         for (x = aRect.x; x < xMax; x++) {
   1:             PRBool newBit = *alphas > 0;
   1:             alphas++;
   1: 
   1:             gchar maskByte = maskBytes[x >> 3];
   1:             PRBool maskBit = (maskByte & (1 << (x & 7))) != 0;
   1: 
   1:             if (maskBit != newBit) {
   1:                 return PR_TRUE;
   1:             }
   1:         }
   1:         aAlphas += aStride;
   1:     }
   1: 
   1:     return PR_FALSE;
   1: }
   1: 
   1: static
   1: void UpdateMaskBits(gchar* aMaskBits, PRInt32 aMaskWidth, PRInt32 aMaskHeight,
   1:         const nsRect& aRect, PRUint8* aAlphas, PRInt32 aStride)
   1: {
   1:     PRInt32 x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
   1:     PRInt32 maskBytesPerRow = (aMaskWidth + 7)/8;
   1:     for (y = aRect.y; y < yMax; y++) {
   1:         gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
   1:         PRUint8* alphas = aAlphas;
   1:         for (x = aRect.x; x < xMax; x++) {
   1:             PRBool newBit = *alphas > 0;
   1:             alphas++;
   1: 
   1:             gchar mask = 1 << (x & 7);
   1:             gchar maskByte = maskBytes[x >> 3];
   1:             // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
   1:             maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
   1:         }
   1:         aAlphas += aStride;
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::ApplyTransparencyBitmap()
   1: {
   1:     gtk_widget_reset_shapes(mShell);
   1:     GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(mShell->window,
   1:             mTransparencyBitmap,
   1:             mTransparencyBitmapWidth, mTransparencyBitmapHeight);
   1:     if (!maskBitmap)
   1:         return;
   1: 
   1:     gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
   1:     gdk_bitmap_unref(maskBitmap);
   1: }
   1: 
   1: nsresult
   1: nsWindow::UpdateTranslucentWindowAlphaInternal(const nsRect& aRect,
   1:                                                PRUint8* aAlphas, PRInt32 aStride)
   1: {
   1:     if (!mShell) {
   1:         // Pass the request to the toplevel window
   1:         GtkWidget *topWidget = nsnull;
   1:         GetToplevelWidget(&topWidget);
   1:         if (!topWidget)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
   1:         if (!topWindow)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
   1:     }
   1: 
   1:     NS_ASSERTION(mIsTranslucent, "Window is not transparent");
   1: 
   1:     if (mTransparencyBitmap == nsnull) {
   1:         PRInt32 size = ((mBounds.width+7)/8)*mBounds.height;
   1:         mTransparencyBitmap = new gchar[size];
   1:         if (mTransparencyBitmap == nsnull)
   1:             return NS_ERROR_FAILURE;
   1:         memset(mTransparencyBitmap, 255, size);
   1:         mTransparencyBitmapWidth = mBounds.width;
   1:         mTransparencyBitmapHeight = mBounds.height;
   1:     }
   1: 
   1:     NS_ASSERTION(aRect.x >= 0 && aRect.y >= 0
   1:             && aRect.XMost() <= mBounds.width && aRect.YMost() <= mBounds.height,
   1:             "Rect is out of window bounds");
   1: 
   1:     if (!ChangedMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
   1:                          aRect, aAlphas, aStride))
   1:         // skip the expensive stuff if the mask bits haven't changed; hopefully
   1:         // this is the common case
   1:         return NS_OK;
   1: 
   1:     UpdateMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
   1:                    aRect, aAlphas, aStride);
   1: 
   1:     if (!mNeedsShow) {
   1:         ApplyTransparencyBitmap();
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::UpdateTranslucentWindowAlpha(const nsRect& aRect, PRUint8* aAlphas)
   1: {
   1:     return UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aRect.width);
   1: }
   1: #endif
   1: 
   1: void
   1: nsWindow::GrabPointer(void)
   1: {
   1:     LOG(("GrabPointer %d\n", mRetryPointerGrab));
   1: 
   1:     mRetryPointerGrab = PR_FALSE;
   1: 
   1:     // If the window isn't visible, just set the flag to retry the
   1:     // grab.  When this window becomes visible, the grab will be
   1:     // retried.
   1:     PRBool visibility = PR_TRUE;
   1:     IsVisible(visibility);
   1:     if (!visibility) {
   1:         LOG(("GrabPointer: window not visible\n"));
   1:         mRetryPointerGrab = PR_TRUE;
   1:         return;
   1:     }
   1: 
   1:     if (!mDrawingarea)
   1:         return;
   1: 
   1:     gint retval;
   1:     retval = gdk_pointer_grab(mDrawingarea->inner_window, TRUE,
   1:                               (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
   1:                                              GDK_BUTTON_RELEASE_MASK |
   1:                                              GDK_ENTER_NOTIFY_MASK |
   1:                                              GDK_LEAVE_NOTIFY_MASK |
   1:                                              GDK_POINTER_MOTION_MASK),
   1:                               (GdkWindow *)NULL, NULL, GDK_CURRENT_TIME);
   1: 
   1:     if (retval != GDK_GRAB_SUCCESS) {
   1:         LOG(("GrabPointer: pointer grab failed\n"));
   1:         mRetryPointerGrab = PR_TRUE;
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::GrabKeyboard(void)
   1: {
   1:     LOG(("GrabKeyboard %d\n", mRetryKeyboardGrab));
   1: 
   1:     mRetryKeyboardGrab = PR_FALSE;
   1: 
   1:     // If the window isn't visible, just set the flag to retry the
   1:     // grab.  When this window becomes visible, the grab will be
   1:     // retried.
   1:     PRBool visibility = PR_TRUE;
   1:     IsVisible(visibility);
   1:     if (!visibility) {
   1:         LOG(("GrabKeyboard: window not visible\n"));
   1:         mRetryKeyboardGrab = PR_TRUE;
   1:         return;
   1:     }
   1: 
   1:     // we need to grab the keyboard on the transient parent so that we
   1:     // don't end up with any focus events that end up on the parent
   1:     // window that will cause the popup to go away
   1:     GdkWindow *grabWindow;
   1: 
   1:     if (mTransientParent)
   1:         grabWindow = GTK_WIDGET(mTransientParent)->window;
   1:     else if (mDrawingarea)
   1:         grabWindow = mDrawingarea->inner_window;
   1:     else
   1:         return;
   1: 
   1:     gint retval;
   1:     retval = gdk_keyboard_grab(grabWindow, TRUE, GDK_CURRENT_TIME);
   1: 
   1:     if (retval != GDK_GRAB_SUCCESS) {
   1:         LOG(("GrabKeyboard: keyboard grab failed %d\n", retval));
   1:         gdk_pointer_ungrab(GDK_CURRENT_TIME);
   1:         mRetryKeyboardGrab = PR_TRUE;
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::ReleaseGrabs(void)
   1: {
   1:     LOG(("ReleaseGrabs\n"));
   1: 
   1:     mRetryPointerGrab = PR_FALSE;
   1:     mRetryKeyboardGrab = PR_FALSE;
   1: 
   1:     gdk_pointer_ungrab(GDK_CURRENT_TIME);
   1:     gdk_keyboard_ungrab(GDK_CURRENT_TIME);
   1: }
   1: 
   1: void
   1: nsWindow::GetToplevelWidget(GtkWidget **aWidget)
   1: {
   1:     *aWidget = nsnull;
   1: 
   1:     if (mShell) {
   1:         *aWidget = mShell;
   1:         return;
   1:     }
   1: 
   1:     if (!mDrawingarea)
   1:         return;
   1: 
   1:     GtkWidget *widget =
   1:         get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1:     if (!widget)
   1:         return;
   1: 
   1:     *aWidget = gtk_widget_get_toplevel(widget);
   1: }
   1: 
   1: void
   1: nsWindow::GetContainerWindow(nsWindow **aWindow)
   1: {
   1:     if (!mDrawingarea)
   1:         return;
   1: 
   1:     GtkWidget *owningWidget =
   1:         get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
   1: 
   1:     *aWindow = get_window_for_gtk_widget(owningWidget);
   1: }
   1: 
   1: void
   1: nsWindow::SetUrgencyHint(GtkWidget *top_window, PRBool state)
   1: {
   1:     if (!top_window)
   1:         return;
   1: 
   1:     // Try to get a pointer to gdk_window_set_urgency_hint
   1:     PRLibrary* lib;
   1:     _gdk_window_set_urgency_hint_fn _gdk_window_set_urgency_hint = nsnull;
   1:     _gdk_window_set_urgency_hint = (_gdk_window_set_urgency_hint_fn)
   1:            PR_FindFunctionSymbolAndLibrary("gdk_window_set_urgency_hint", &lib);
   1: 
   1:     if (_gdk_window_set_urgency_hint) {
   1:         _gdk_window_set_urgency_hint(top_window->window, state);
   1:         PR_UnloadLibrary(lib);
   1:     }
   1:     else if (state) {
   1:         gdk_window_show_unraised(top_window->window);
   1:     }
   1: }
   1: 
   1: void *
   1: nsWindow::SetupPluginPort(void)
   1: {
   1:     if (!mDrawingarea)
   1:         return nsnull;
   1: 
   1:     if (GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed == TRUE)
   1:         return nsnull;
   1: 
   1:     // we have to flush the X queue here so that any plugins that
   1:     // might be running on separate X connections will be able to use
   1:     // this window in case it was just created
   1:     XWindowAttributes xattrs;
   1:     XGetWindowAttributes(GDK_DISPLAY (),
   1:                          GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
   1:                          &xattrs);
   1:     XSelectInput (GDK_DISPLAY (),
   1:                   GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
   1:                   xattrs.your_event_mask |
   1:                   SubstructureNotifyMask);
   1: 
   1:     gdk_window_add_filter(mDrawingarea->inner_window,
   1:                           plugin_window_filter_func,
   1:                           this);
   1: 
   1:     XSync(GDK_DISPLAY(), False);
   1: 
   1:     return (void *)GDK_WINDOW_XWINDOW(mDrawingarea->inner_window);
   1: }
   1: 
   1: nsresult
   1: nsWindow::SetWindowIconList(const nsCStringArray &aIconList)
   1: {
   1:     GList *list = NULL;
   1: 
   1:     for (int i = 0; i < aIconList.Count(); ++i) {
   1:         const char *path = aIconList[i]->get();
   1:         LOG(("window [%p] Loading icon from %s\n", (void *)this, path));
   1: 
   1:         GdkPixbuf *icon = gdk_pixbuf_new_from_file(path, NULL);
   1:         if (!icon)
   1:             continue;
   1: 
   1:         list = g_list_append(list, icon);
   1:     }
   1: 
   1:     if (!list)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     gtk_window_set_icon_list(GTK_WINDOW(mShell), list);
   1: 
   1:     g_list_foreach(list, (GFunc) g_object_unref, NULL);
   1:     g_list_free(list);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: void
   1: nsWindow::SetDefaultIcon(void)
   1: {
   1:     // Set up the default window icon
   1:     nsCOMPtr<nsILocalFile> iconFile;
   1:     ResolveIconName(NS_LITERAL_STRING("default"),
   1:                     NS_LITERAL_STRING(".xpm"),
   1:                     getter_AddRefs(iconFile));
   1:     if (!iconFile) {
   1:         NS_WARNING("default.xpm not found");
   1:         return;
   1:     }
   1: 
   1:     nsCAutoString path;
   1:     iconFile->GetNativePath(path);
   1: 
   1:     nsCStringArray iconList;
   1:     iconList.AppendCString(path);
   1: 
   1:     SetWindowIconList(iconList);
   1: }
   1: 
   1: void
   1: nsWindow::SetPluginType(PluginType aPluginType)
   1: {
   1:     mPluginType = aPluginType;
   1: }
   1: 
   1: void
   1: nsWindow::SetNonXEmbedPluginFocus()
   1: {
   1:     if (gPluginFocusWindow == this || mPluginType!=PluginType_NONXEMBED) {
   1:         return;
   1:     }
   1: 
   1:     if (gPluginFocusWindow) {
 920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
   1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
   1:     }
   1: 
   1:     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus\n"));
   1: 
   1:     Window curFocusWindow;
   1:     int focusState;
   1: 
   1:     XGetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
   1:                    &curFocusWindow,
   1:                    &focusState);
   1: 
   1:     LOGFOCUS(("\t curFocusWindow=%p\n", curFocusWindow));
   1: 
   1:     GdkWindow* toplevel = gdk_window_get_toplevel
   1:                                 (mDrawingarea->inner_window);
   1:     GdkWindow *gdkfocuswin = gdk_window_lookup(curFocusWindow);
   1: 
   1:     // lookup with the focus proxy window is supposed to get the
   1:     // same GdkWindow as toplevel. If the current focused window
   1:     // is not the focus proxy, we return without any change.
   1:     if (gdkfocuswin != toplevel) {
   1:         return;
   1:     }
   1: 
   1:     // switch the focus from the focus proxy to the plugin window
   1:     mOldFocusWindow = curFocusWindow;
   1:     XRaiseWindow(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
   1:                  GDK_WINDOW_XWINDOW(mDrawingarea->inner_window));
   1:     gdk_error_trap_push();
   1:     XSetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
   1:                    GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
   1:                    RevertToNone,
   1:                    CurrentTime);
   1:     gdk_flush();
   1:     gdk_error_trap_pop();
   1:     gPluginFocusWindow = this;
   1:     gdk_window_add_filter(NULL, plugin_client_message_filter, this);
   1: 
   1:     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus oldfocus=%p new=%p\n",
   1:                 mOldFocusWindow,
   1:                 GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)));
   1: }
   1: 
   1: void
   1: nsWindow::LoseNonXEmbedPluginFocus()
   1: {
   1:     LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus\n"));
   1: 
   1:     // This method is only for the nsWindow which contains a
   1:     // Non-XEmbed plugin, for example, JAVA plugin.
   1:     if (gPluginFocusWindow != this || mPluginType!=PluginType_NONXEMBED) {
   1:         return;
   1:     }
   1: 
   1:     Window curFocusWindow;
   1:     int focusState;
   1: 
   1:     XGetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
   1:                    &curFocusWindow,
   1:                    &focusState);
   1: 
   1:     // we only switch focus between plugin window and focus proxy. If the
   1:     // current focused window is not the plugin window, just removing the
   1:     // event filter that blocks the WM_TAKE_FOCUS is enough. WM and gtk2
   1:     // will take care of the focus later.
   1:     if (!curFocusWindow ||
   1:         curFocusWindow == GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)) {
   1: 
   1:         gdk_error_trap_push();
   1:         XRaiseWindow(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
   1:                      mOldFocusWindow);
   1:         XSetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
   1:                        mOldFocusWindow,
   1:                        RevertToParent,
   1:                        CurrentTime);
   1:         gdk_flush();
   1:         gdk_error_trap_pop();
   1:     }
   1:     gPluginFocusWindow = NULL;
   1:     mOldFocusWindow = 0;
   1:     gdk_window_remove_filter(NULL, plugin_client_message_filter, this);
   1: 
   1:     LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus end\n"));
   1: }
   1: 
   1: 
   1: gint
   1: nsWindow::ConvertBorderStyles(nsBorderStyle aStyle)
   1: {
   1:     gint w = 0;
   1: 
   1:     if (aStyle == eBorderStyle_default)
   1:         return -1;
   1: 
   1:     if (aStyle & eBorderStyle_all)
   1:         w |= GDK_DECOR_ALL;
   1:     if (aStyle & eBorderStyle_border)
   1:         w |= GDK_DECOR_BORDER;
   1:     if (aStyle & eBorderStyle_resizeh)
   1:         w |= GDK_DECOR_RESIZEH;
   1:     if (aStyle & eBorderStyle_title)
   1:         w |= GDK_DECOR_TITLE;
   1:     if (aStyle & eBorderStyle_menu)
   1:         w |= GDK_DECOR_MENU;
   1:     if (aStyle & eBorderStyle_minimize)
   1:         w |= GDK_DECOR_MINIMIZE;
   1:     if (aStyle & eBorderStyle_maximize)
   1:         w |= GDK_DECOR_MAXIMIZE;
   1:     if (aStyle & eBorderStyle_close) {
   1: #ifdef DEBUG
   1:         printf("we don't handle eBorderStyle_close yet... please fix me\n");
   1: #endif /* DEBUG */
   1:     }
   1: 
   1:     return w;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::MakeFullScreen(PRBool aFullScreen)
   1: {
   1: #if GTK_CHECK_VERSION(2,2,0)
   1:     if (aFullScreen)
   1:         gdk_window_fullscreen (mShell->window);
   1:     else
   1:         gdk_window_unfullscreen (mShell->window);
   1: #else
   1:     HideWindowChrome(aFullScreen);
   1: #endif
   1:     return MakeFullScreenInternal(aFullScreen);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::HideWindowChrome(PRBool aShouldHide)
   1: {
   1:     if (!mShell) {
   1:         // Pass the request to the toplevel window
   1:         GtkWidget *topWidget = nsnull;
   1:         GetToplevelWidget(&topWidget);
   1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
   1:         return topWindow->HideWindowChrome(aShouldHide);
   1:     }
   1: 
   1:     // Sawfish, metacity, and presumably other window managers get
   1:     // confused if we change the window decorations while the window
   1:     // is visible.
   1:     gdk_window_hide(mShell->window);
   1: 
   1:     gint wmd;
   1:     if (aShouldHide)
   1:         wmd = 0;
   1:     else
   1:         wmd = ConvertBorderStyles(mBorderStyle);
   1: 
   1:     gdk_window_set_decorations(mShell->window, (GdkWMDecoration) wmd);
   1: 
   1:     gdk_window_show(mShell->window);
   1: 
   1:     // For some window managers, adding or removing window decorations
   1:     // requires unmapping and remapping our toplevel window.  Go ahead
   1:     // and flush the queue here so that we don't end up with a BadWindow
   1:     // error later when this happens (when the persistence timer fires
   1:     // and GetWindowPos is called)
   1:     XSync(GDK_DISPLAY(), False);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: PRBool
   1: check_for_rollup(GdkWindow *aWindow, gdouble aMouseX, gdouble aMouseY,
   1:                  PRBool aIsWheel)
   1: {
   1:     PRBool retVal = PR_FALSE;
   1:     nsCOMPtr<nsIWidget> rollupWidget = do_QueryReferent(gRollupWindow);
   1: 
   1:     if (rollupWidget && gRollupListener) {
   1:         GdkWindow *currentPopup =
   1:             (GdkWindow *)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
   1:         if (!is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
   1:             PRBool rollup = PR_TRUE;
   1:             if (aIsWheel) {
   1:                 gRollupListener->ShouldRollupOnMouseWheelEvent(&rollup);
   1:                 retVal = PR_TRUE;
   1:             }
   1:             // if we're dealing with menus, we probably have submenus and
   1:             // we don't want to rollup if the clickis in a parent menu of
   1:             // the current submenu
   1:             nsCOMPtr<nsIMenuRollup> menuRollup;
   1:             menuRollup = (do_QueryInterface(gRollupListener));
   1:             if (menuRollup) {
   1:                 nsCOMPtr<nsISupportsArray> widgetChain;
   1:                 menuRollup->GetSubmenuWidgetChain(getter_AddRefs(widgetChain));
   1:                 if (widgetChain) {
   1:                     PRUint32 count = 0;
   1:                     widgetChain->Count(&count);
   1:                     for (PRUint32 i=0; i<count; ++i) {
   1:                         nsCOMPtr<nsISupports> genericWidget;
   1:                         widgetChain->GetElementAt(i,
   1:                                                   getter_AddRefs(genericWidget));
   1:                         nsCOMPtr<nsIWidget> widget(do_QueryInterface(genericWidget));
   1:                         if (widget) {
   1:                             GdkWindow* currWindow =
   1:                                 (GdkWindow*) widget->GetNativeData(NS_NATIVE_WINDOW);
   1:                             if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
   1:                                 rollup = PR_FALSE;
   1:                                 break;
   1:                             }
   1:                         }
   1:                     } // foreach parent menu widget
   1:                 }
   1:             } // if rollup listener knows about menus
   1: 
   1:             // if we've determined that we should still rollup, do it.
   1:             if (rollup) {
   1:                 gRollupListener->Rollup();
   1:                 retVal = PR_TRUE;
   1:             }
   1:         }
   1:     } else {
   1:         gRollupWindow = nsnull;
   1:         gRollupListener = nsnull;
   1:     }
   1: 
   1:     return retVal;
   1: }
   1: 
   1: /* static */
   1: PRBool
   1: nsWindow::DragInProgress(void)
   1: {
   1:     // mLastDragMotionWindow means the drag arrow is over mozilla
   1:     // sIsDraggingOutOf means the drag arrow is out of mozilla
   1:     // both cases mean the dragging is happenning.
   1:     return (mLastDragMotionWindow || sIsDraggingOutOf);
   1: }
   1: 
   1: /* static */
   1: PRBool
   1: is_mouse_in_window (GdkWindow* aWindow, gdouble aMouseX, gdouble aMouseY)
   1: {
   1:     gint x = 0;
   1:     gint y = 0;
   1:     gint w, h;
   1: 
   1:     gint offsetX = 0;
   1:     gint offsetY = 0;
   1: 
   1:     GtkWidget *widget;
   1:     GdkWindow *window;
   1: 
   1:     window = aWindow;
   1: 
   1:     while (window) {
   1:         gint tmpX = 0;
   1:         gint tmpY = 0;
   1: 
   1:         gdk_window_get_position(window, &tmpX, &tmpY);
   1:         widget = get_gtk_widget_for_gdk_window(window);
   1: 
   1:         // if this is a window, compute x and y given its origin and our
   1:         // offset
   1:         if (GTK_IS_WINDOW(widget)) {
   1:             x = tmpX + offsetX;
   1:             y = tmpY + offsetY;
   1:             break;
   1:         }
   1: 
   1:         offsetX += tmpX;
   1:         offsetY += tmpY;
   1:         window = gdk_window_get_parent(window);
   1:     }
   1: 
   1:     gdk_window_get_size(aWindow, &w, &h);
   1: 
   1:     if (aMouseX > x && aMouseX < x + w &&
   1:         aMouseY > y && aMouseY < y + h)
   1:         return PR_TRUE;
   1: 
   1:     return PR_FALSE;
   1: }
   1: 
   1: /* static */
   1: nsWindow *
   1: get_window_for_gtk_widget(GtkWidget *widget)
   1: {
   1:     gpointer user_data;
   1:     user_data = g_object_get_data(G_OBJECT(widget), "nsWindow");
   1: 
   1:     if (!user_data)
   1:         return nsnull;
   1: 
3233:     return static_cast<nsWindow *>(user_data);
   1: }
   1: 
   1: /* static */
   1: nsWindow *
   1: get_window_for_gdk_window(GdkWindow *window)
   1: {
   1:     gpointer user_data;
   1:     user_data = g_object_get_data(G_OBJECT(window), "nsWindow");
   1: 
   1:     if (!user_data)
   1:         return nsnull;
   1: 
3233:     return static_cast<nsWindow *>(user_data);
   1: }
   1: 
   1: /* static */
   1: nsWindow *
   1: get_owning_window_for_gdk_window(GdkWindow *window)
   1: {
   1:     GtkWidget *owningWidget = get_gtk_widget_for_gdk_window(window);
   1:     if (!owningWidget)
   1:         return nsnull;
   1: 
   1:     gpointer user_data;
   1:     user_data = g_object_get_data(G_OBJECT(owningWidget), "nsWindow");
   1: 
   1:     if (!user_data)
   1:         return nsnull;
   1: 
   1:     return (nsWindow *)user_data;
   1: }
   1: 
   1: /* static */
   1: GtkWidget *
   1: get_gtk_widget_for_gdk_window(GdkWindow *window)
   1: {
   1:     gpointer user_data = NULL;
   1:     gdk_window_get_user_data(window, &user_data);
   1:     if (!user_data)
   1:         return NULL;
   1: 
   1:     return GTK_WIDGET(user_data);
   1: }
   1: 
   1: /* static */
   1: GdkCursor *
   1: get_gtk_cursor(nsCursor aCursor)
   1: {
   1:     GdkPixmap *cursor;
   1:     GdkPixmap *mask;
   1:     GdkColor fg, bg;
   1:     GdkCursor *gdkcursor = nsnull;
   1:     PRUint8 newType = 0xff;
   1: 
   1:     if ((gdkcursor = gCursorCache[aCursor])) {
   1:         return gdkcursor;
   1:     }
   1: 
   1:     switch (aCursor) {
   1:     case eCursor_standard:
   1:         gdkcursor = gdk_cursor_new(GDK_LEFT_PTR);
   1:         break;
   1:     case eCursor_wait:
   1:         gdkcursor = gdk_cursor_new(GDK_WATCH);
   1:         break;
   1:     case eCursor_select:
   1:         gdkcursor = gdk_cursor_new(GDK_XTERM);
   1:         break;
   1:     case eCursor_hyperlink:
   1:         gdkcursor = gdk_cursor_new(GDK_HAND2);
   1:         break;
   1:     case eCursor_n_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_TOP_SIDE);
   1:         break;
   1:     case eCursor_s_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_SIDE);
   1:         break;
   1:     case eCursor_w_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_LEFT_SIDE);
   1:         break;
   1:     case eCursor_e_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_RIGHT_SIDE);
   1:         break;
   1:     case eCursor_nw_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_TOP_LEFT_CORNER);
   1:         break;
   1:     case eCursor_se_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);
   1:         break;
   1:     case eCursor_ne_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);
   1:         break;
   1:     case eCursor_sw_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);
   1:         break;
   1:     case eCursor_crosshair:
   1:         gdkcursor = gdk_cursor_new(GDK_CROSSHAIR);
   1:         break;
   1:     case eCursor_move:
   1:         gdkcursor = gdk_cursor_new(GDK_FLEUR);
   1:         break;
   1:     case eCursor_help:
   1:         newType = MOZ_CURSOR_QUESTION_ARROW;
   1:         break;
   1:     case eCursor_copy: // CSS3
   1:         newType = MOZ_CURSOR_COPY;
   1:         break;
   1:     case eCursor_alias:
   1:         newType = MOZ_CURSOR_ALIAS;
   1:         break;
   1:     case eCursor_context_menu:
   1:         newType = MOZ_CURSOR_CONTEXT_MENU;
   1:         break;
   1:     case eCursor_cell:
   1:         gdkcursor = gdk_cursor_new(GDK_PLUS);
   1:         break;
   1:     case eCursor_grab:
   1:         newType = MOZ_CURSOR_HAND_GRAB;
   1:         break;
   1:     case eCursor_grabbing:
   1:         newType = MOZ_CURSOR_HAND_GRABBING;
   1:         break;
   1:     case eCursor_spinning:
   1:         newType = MOZ_CURSOR_SPINNING;
   1:         break;
   1:     case eCursor_zoom_in:
   1:         newType = MOZ_CURSOR_ZOOM_IN;
   1:         break;
   1:     case eCursor_zoom_out:
   1:         newType = MOZ_CURSOR_ZOOM_OUT;
   1:         break;
   1:     case eCursor_not_allowed:
   1:     case eCursor_no_drop:
   1:         newType = MOZ_CURSOR_NOT_ALLOWED;
   1:         break;
   1:     case eCursor_col_resize:
   1:         newType = MOZ_CURSOR_COL_RESIZE;
   1:         break;
   1:     case eCursor_row_resize:
   1:         newType = MOZ_CURSOR_ROW_RESIZE;
   1:         break;
   1:     case eCursor_vertical_text:
   1:         newType = MOZ_CURSOR_VERTICAL_TEXT;
   1:         break;
   1:     case eCursor_all_scroll:
   1:         gdkcursor = gdk_cursor_new(GDK_FLEUR);
   1:         break;
   1:     case eCursor_nesw_resize:
   1:         newType = MOZ_CURSOR_NESW_RESIZE;
   1:         break;
   1:     case eCursor_nwse_resize:
   1:         newType = MOZ_CURSOR_NWSE_RESIZE;
   1:         break;
   1:     case eCursor_ns_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_SB_V_DOUBLE_ARROW);
   1:         break;
   1:     case eCursor_ew_resize:
   1:         gdkcursor = gdk_cursor_new(GDK_SB_H_DOUBLE_ARROW);
   1:         break;
   1:     default:
   1:         NS_ASSERTION(aCursor, "Invalid cursor type");
   1:         gdkcursor = gdk_cursor_new(GDK_LEFT_PTR);
   1:         break;
   1:     }
   1: 
   1:     // if by now we don't have a xcursor, this means we have to make a
   1:     // custom one
   1:     if (newType != 0xff) {
   1:         gdk_color_parse("#000000", &fg);
   1:         gdk_color_parse("#ffffff", &bg);
   1: 
   1:         cursor = gdk_bitmap_create_from_data(NULL,
   1:                                              (char *)GtkCursors[newType].bits,
   1:                                              32, 32);
   1:         mask =
   1:             gdk_bitmap_create_from_data(NULL,
   1:                                         (char *)GtkCursors[newType].mask_bits,
   1:                                         32, 32);
   1: 
   1:         gdkcursor = gdk_cursor_new_from_pixmap(cursor, mask, &fg, &bg,
   1:                                                GtkCursors[newType].hot_x,
   1:                                                GtkCursors[newType].hot_y);
   1: 
   1:         gdk_bitmap_unref(mask);
   1:         gdk_bitmap_unref(cursor);
   1:     }
   1: 
   1:     gCursorCache[aCursor] = gdkcursor;
   1: 
   1:     return gdkcursor;
   1: }
   1: 
   1: // gtk callbacks
   1: 
   1: /* static */
   1: gboolean
   1: expose_event_cb(GtkWidget *widget, GdkEventExpose *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     // XXX We are so getting lucky here.  We are doing all of
   1:     // mozilla's painting and then allowing default processing to occur.
   1:     // This means that Mozilla paints in all of it's stuff and then
   1:     // NO_WINDOW widgets (like scrollbars, for example) are painted by
   1:     // Gtk on top of what we painted.
   1: 
   1:     // This return window->OnExposeEvent(widget, event); */
   1: 
   1:     window->OnExposeEvent(widget, event);
   1:     return FALSE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: configure_event_cb(GtkWidget *widget,
   1:                    GdkEventConfigure *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     return window->OnConfigureEvent(widget, event);
   1: }
   1: 
   1: /* static */
   1: void
   1: size_allocate_cb (GtkWidget *widget, GtkAllocation *allocation)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return;
   1: 
   1:     window->OnSizeAllocate(widget, allocation);
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: delete_event_cb(GtkWidget *widget, GdkEventAny *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     window->OnDeleteEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: enter_notify_event_cb(GtkWidget *widget,
   1:                       GdkEventCrossing *event)
   1: {
   1:     if (is_parent_ungrab_enter(event)) {
   1:         return TRUE;
   1:     }
   1: 
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return TRUE;
   1: 
   1:     window->OnEnterNotifyEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: leave_notify_event_cb(GtkWidget *widget,
   1:                       GdkEventCrossing *event)
   1: {
   1:     if (is_parent_grab_leave(event)) {
   1:         return TRUE;
   1:     }
   1: 
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return TRUE;
   1: 
   1:     window->OnLeaveNotifyEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: motion_notify_event_cb(GtkWidget *widget, GdkEventMotion *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return TRUE;
   1: 
   1:     window->OnMotionNotifyEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: button_press_event_cb(GtkWidget *widget, GdkEventButton *event)
   1: {
   1:     LOG(("button_press_event_cb\n"));
   1:     nsWindow *window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return TRUE;
   1: 
   1:     window->OnButtonPressEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: button_release_event_cb(GtkWidget *widget, GdkEventButton *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return TRUE;
   1: 
   1:     window->OnButtonReleaseEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: focus_in_event_cb(GtkWidget *widget, GdkEventFocus *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     window->OnContainerFocusInEvent(widget, event);
   1: 
   1:     return FALSE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: focus_out_event_cb(GtkWidget *widget, GdkEventFocus *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     window->OnContainerFocusOutEvent(widget, event);
   1: 
   1:     return FALSE;
   1: }
   1: 
   1: /* static */
   1: GdkFilterReturn
   1: plugin_window_filter_func(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
   1: {
   1:     GtkWidget *widget;
   1:     GdkWindow *plugin_window;
   1:     gpointer  user_data;
   1:     XEvent    *xevent;
   1: 
 920:     nsRefPtr<nsWindow> nswindow = (nsWindow*)data;
   1:     GdkFilterReturn return_val;
   1: 
   1:     xevent = (XEvent *)gdk_xevent;
   1:     return_val = GDK_FILTER_CONTINUE;
   1: 
   1:     switch (xevent->type)
   1:     {
   1:         case CreateNotify:
   1:         case ReparentNotify:
   1:             if (xevent->type==CreateNotify) {
   1:                 plugin_window = gdk_window_lookup(xevent->xcreatewindow.window);
   1:             }
   1:             else {
   1:                 if (xevent->xreparent.event != xevent->xreparent.parent)
   1:                     break;
   1:                 plugin_window = gdk_window_lookup (xevent->xreparent.window);
   1:             }
   1:             if (plugin_window) {
   1:                 user_data = nsnull;
   1:                 gdk_window_get_user_data(plugin_window, &user_data);
   1:                 widget = GTK_WIDGET(user_data);
   1: 
   1:                 if (GTK_IS_XTBIN(widget)) {
   1:                     nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
   1:                     break;
   1:                 }
   1:                 else if(GTK_IS_SOCKET(widget)) {
   1:                     nswindow->SetPluginType(nsWindow::PluginType_XEMBED);
   1:                     break;
   1:                 }
   1:             }
   1:             nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
   1:             return_val = GDK_FILTER_REMOVE;
   1:             break;
   1:         case EnterNotify:
   1:             nswindow->SetNonXEmbedPluginFocus();
   1:             break;
   1:         case DestroyNotify:
   1:             gdk_window_remove_filter
   1:                 ((GdkWindow*)(nswindow->GetNativeData(NS_NATIVE_WINDOW)),
   1:                  plugin_window_filter_func,
   1:                  nswindow);
   1:             // Currently we consider all plugins are non-xembed and calls
   1:             // LoseNonXEmbedPluginFocus without any checking.
   1:             nswindow->LoseNonXEmbedPluginFocus();
   1:             break;
   1:         default:
   1:             break;
   1:     }
   1:     return return_val;
   1: }
   1: 
   1: /* static */
   1: GdkFilterReturn
   1: plugin_client_message_filter(GdkXEvent *gdk_xevent,
   1:                              GdkEvent *event,
   1:                              gpointer data)
   1: {
   1:     XEvent    *xevent;
   1:     xevent = (XEvent *)gdk_xevent;
   1: 
   1:     GdkFilterReturn return_val;
   1:     return_val = GDK_FILTER_CONTINUE;
   1: 
   1:     if (!gPluginFocusWindow || xevent->type!=ClientMessage) {
   1:         return return_val;
   1:     }
   1: 
   1:     // When WM sends out WM_TAKE_FOCUS, gtk2 will use XSetInputFocus
   1:     // to set the focus to the focus proxy. To prevent this happen
   1:     // while the focus is on the plugin, we filter the WM_TAKE_FOCUS
   1:     // out.
   1:     Display *dpy ;
   1:     dpy = GDK_WINDOW_XDISPLAY((GdkWindow*)(gPluginFocusWindow->
   1:                 GetNativeData(NS_NATIVE_WINDOW)));
   1:     if (gdk_x11_get_xatom_by_name("WM_PROTOCOLS")
   1:             != xevent->xclient.message_type) {
   1:         return return_val;
   1:     }
   1: 
   1:     if ((Atom) xevent->xclient.data.l[0] ==
   1:             gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS")) {
   1:         // block it from gtk2.0 focus proxy
   1:         return_val = GDK_FILTER_REMOVE;
   1:     }
   1: 
   1:     return return_val;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: key_press_event_cb(GtkWidget *widget, GdkEventKey *event)
   1: {
   1:     LOG(("key_press_event_cb\n"));
   1:     // find the window with focus and dispatch this event to that widget
   1:     nsWindow *window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
 920:     nsRefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
   1: 
   1:     return focusWindow->OnKeyPressEvent(widget, event);
   1: }
   1: 
   1: gboolean
   1: key_release_event_cb(GtkWidget *widget, GdkEventKey *event)
   1: {
   1:     LOG(("key_release_event_cb\n"));
   1:     // find the window with focus and dispatch this event to that widget
   1:     nsWindow *window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
 920:     nsRefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
   1: 
   1:     return focusWindow->OnKeyReleaseEvent(widget, event);
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: scroll_event_cb(GtkWidget *widget, GdkEventScroll *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     window->OnScrollEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: visibility_notify_event_cb (GtkWidget *widget, GdkEventVisibility *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     window->OnVisibilityNotifyEvent(widget, event);
   1: 
   1:     return TRUE;
   1: }
   1: 
   1: /* static */
   1: gboolean
   1: window_state_event_cb (GtkWidget *widget, GdkEventWindowState *event)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     window->OnWindowStateEvent(widget, event);
   1: 
   1:     return FALSE;
   1: }
   1: 
   1: /* static */
   1: void
   1: theme_changed_cb (GtkSettings *settings, GParamSpec *pspec, nsWindow *data)
   1: {
 920:     nsRefPtr<nsWindow> window = data;
 920:     window->ThemeChanged();
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: // These are all of our drag and drop operations
   1: 
   1: void
   1: nsWindow::InitDragEvent(nsMouseEvent &aEvent)
   1: {
   1:     // set the keyboard modifiers
   1:     gint x, y;
   1:     GdkModifierType state = (GdkModifierType)0;
   1:     gdk_window_get_pointer(NULL, &x, &y, &state);
   1:     aEvent.isShift = (state & GDK_SHIFT_MASK) ? PR_TRUE : PR_FALSE;
   1:     aEvent.isControl = (state & GDK_CONTROL_MASK) ? PR_TRUE : PR_FALSE;
   1:     aEvent.isAlt = (state & GDK_MOD1_MASK) ? PR_TRUE : PR_FALSE;
   1:     aEvent.isMeta = PR_FALSE; // GTK+ doesn't support the meta key
   1: }
   1: 
   1: // This will update the drag action based on the information in the
   1: // drag context.  Gtk gets this from a combination of the key settings
   1: // and what the source is offering.
   1: 
   1: void
   1: nsWindow::UpdateDragStatus(nsMouseEvent   &aEvent,
   1:                            GdkDragContext *aDragContext,
   1:                            nsIDragService *aDragService)
   1: {
   1:     // default is to do nothing
   1:     int action = nsIDragService::DRAGDROP_ACTION_NONE;
   1: 
   1:     // set the default just in case nothing matches below
   1:     if (aDragContext->actions & GDK_ACTION_DEFAULT)
   1:         action = nsIDragService::DRAGDROP_ACTION_MOVE;
   1: 
   1:     // first check to see if move is set
   1:     if (aDragContext->actions & GDK_ACTION_MOVE)
   1:         action = nsIDragService::DRAGDROP_ACTION_MOVE;
   1: 
   1:     // then fall to the others
   1:     else if (aDragContext->actions & GDK_ACTION_LINK)
   1:         action = nsIDragService::DRAGDROP_ACTION_LINK;
   1: 
   1:     // copy is ctrl
   1:     else if (aDragContext->actions & GDK_ACTION_COPY)
   1:         action = nsIDragService::DRAGDROP_ACTION_COPY;
   1: 
   1:     // update the drag information
   1:     nsCOMPtr<nsIDragSession> session;
   1:     aDragService->GetCurrentSession(getter_AddRefs(session));
   1: 
   1:     if (session)
   1:         session->SetDragAction(action);
   1: }
   1: 
   1: 
   1: /* static */
   1: gboolean
   1: drag_motion_event_cb(GtkWidget *aWidget,
   1:                      GdkDragContext *aDragContext,
   1:                      gint aX,
   1:                      gint aY,
   1:                      guint aTime,
   1:                      gpointer aData)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     return window->OnDragMotionEvent(aWidget,
   1:                                      aDragContext,
   1:                                      aX, aY, aTime, aData);
   1: }
   1: /* static */
   1: void
   1: drag_leave_event_cb(GtkWidget *aWidget,
   1:                     GdkDragContext *aDragContext,
   1:                     guint aTime,
   1:                     gpointer aData)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
   1:     if (!window)
   1:         return;
   1: 
   1:     window->OnDragLeaveEvent(aWidget, aDragContext, aTime, aData);
   1: }
   1: 
   1: 
   1: /* static */
   1: gboolean
   1: drag_drop_event_cb(GtkWidget *aWidget,
   1:                    GdkDragContext *aDragContext,
   1:                    gint aX,
   1:                    gint aY,
   1:                    guint aTime,
   1:                    gpointer *aData)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
   1:     if (!window)
   1:         return FALSE;
   1: 
   1:     return window->OnDragDropEvent(aWidget,
   1:                                    aDragContext,
   1:                                    aX, aY, aTime, aData);
   1: }
   1: 
   1: /* static */
   1: void
   1: drag_data_received_event_cb(GtkWidget *aWidget,
   1:                             GdkDragContext *aDragContext,
   1:                             gint aX,
   1:                             gint aY,
   1:                             GtkSelectionData  *aSelectionData,
   1:                             guint aInfo,
   1:                             guint aTime,
   1:                             gpointer aData)
   1: {
 920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
   1:     if (!window)
   1:         return;
   1: 
   1:     window->OnDragDataReceivedEvent(aWidget,
   1:                                     aDragContext,
   1:                                     aX, aY,
   1:                                     aSelectionData,
   1:                                     aInfo, aTime, aData);
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: initialize_prefs(void)
   1: {
   1:     // check to see if we should set our raise pref
   1:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
2475:     if (!prefs)
2475:         return NS_OK;
2475: 
   1:     PRBool val = PR_TRUE;
   1:     nsresult rv;
   1:     rv = prefs->GetBoolPref("mozilla.widget.raise-on-setfocus", &val);
   1:     if (NS_SUCCEEDED(rv))
   1:         gRaiseWindows = val;
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: void
   1: nsWindow::ResetDragMotionTimer(GtkWidget *aWidget,
   1:                                GdkDragContext *aDragContext,
   1:                                gint aX, gint aY, guint aTime)
   1: {
   1: 
   1:     // We have to be careful about ref ordering here.  if aWidget ==
   1:     // mDraMotionWidget be careful not to let the refcnt drop to zero.
   1:     // Same with the drag context.
   1:     if (aWidget)
   1:         gtk_widget_ref(aWidget);
   1:     if (mDragMotionWidget)
   1:         gtk_widget_unref(mDragMotionWidget);
   1:     mDragMotionWidget = aWidget;
   1: 
   1:     if (aDragContext)
   1:         gdk_drag_context_ref(aDragContext);
   1:     if (mDragMotionContext)
   1:         gdk_drag_context_unref(mDragMotionContext);
   1:     mDragMotionContext = aDragContext;
   1: 
   1:     mDragMotionX = aX;
   1:     mDragMotionY = aY;
   1:     mDragMotionTime = aTime;
   1: 
   1:     // always clear the timer
   1:     if (mDragMotionTimerID) {
   1:         gtk_timeout_remove(mDragMotionTimerID);
   1:         mDragMotionTimerID = 0;
   1:         LOG(("*** canceled motion timer\n"));
   1:     }
   1: 
   1:     // if no widget was passed in, just return instead of setting a new
   1:     // timer
   1:     if (!aWidget) {
   1:         return;
   1:     }
   1: 
   1:     // otherwise we create a new timer
   1:     mDragMotionTimerID = gtk_timeout_add(100,
   1:                                          (GtkFunction)DragMotionTimerCallback,
   1:                                          this);
   1: }
   1: 
   1: void
   1: nsWindow::FireDragMotionTimer(void)
   1: {
   1:     LOG(("nsWindow::FireDragMotionTimer(%p)\n", this));
   1: 
   1:     OnDragMotionEvent(mDragMotionWidget, mDragMotionContext,
   1:                       mDragMotionX, mDragMotionY, mDragMotionTime,
   1:                       this);
   1: }
   1: 
   1: void
   1: nsWindow::FireDragLeaveTimer(void)
   1: {
   1:     LOG(("nsWindow::FireDragLeaveTimer(%p)\n", this));
   1: 
   1:     mDragLeaveTimer = 0;
   1: 
   1:     // clean up any pending drag motion window info
   1:     if (mLastDragMotionWindow) {
 920:         nsRefPtr<nsWindow> kungFuDeathGrip = mLastDragMotionWindow;
   1:         // send our leave signal
   1:         mLastDragMotionWindow->OnDragLeave();
   1:         mLastDragMotionWindow = 0;
   1:     }
   1: }
   1: 
   1: /* static */
   1: guint
   1: nsWindow::DragMotionTimerCallback(gpointer aClosure)
   1: {
3233:     nsRefPtr<nsWindow> window = static_cast<nsWindow *>(aClosure);
   1:     window->FireDragMotionTimer();
   1:     return FALSE;
   1: }
   1: 
   1: /* static */
   1: void
   1: nsWindow::DragLeaveTimerCallback(nsITimer *aTimer, void *aClosure)
   1: {
3233:     nsRefPtr<nsWindow> window = static_cast<nsWindow *>(aClosure);
   1:     window->FireDragLeaveTimer();
   1: }
   1: 
   1: /* static */
   1: GdkWindow *
   1: get_inner_gdk_window (GdkWindow *aWindow,
   1:                       gint x, gint y,
   1:                       gint *retx, gint *rety)
   1: {
   1:     gint cx, cy, cw, ch, cd;
   1:     GList * children = gdk_window_peek_children(aWindow);
   1:     guint num = g_list_length(children);
   1:     for (int i = 0; i < (int)num; i++) {
   1:         GList * child = g_list_nth(children, num - i - 1) ;
   1:         if (child) {
   1:             GdkWindow * childWindow = (GdkWindow *) child->data;
   1:             gdk_window_get_geometry (childWindow, &cx, &cy, &cw, &ch, &cd);
   1:             if ((cx < x) && (x < (cx + cw)) &&
   1:                 (cy < y) && (y < (cy + ch)) &&
   1:                 gdk_window_is_visible (childWindow)) {
   1:                 return get_inner_gdk_window (childWindow,
   1:                                              x - cx, y - cy,
   1:                                              retx, rety);
   1:             }
   1:         }
   1:     }
   1:     *retx = x;
   1:     *rety = y;
   1:     return aWindow;
   1: }
   1: 
   1: inline PRBool
   1: is_context_menu_key(const nsKeyEvent& aKeyEvent)
   1: {
   1:     return ((aKeyEvent.keyCode == NS_VK_F10 && aKeyEvent.isShift &&
   1:              !aKeyEvent.isControl && !aKeyEvent.isMeta && !aKeyEvent.isAlt) ||
   1:             (aKeyEvent.keyCode == NS_VK_CONTEXT_MENU && !aKeyEvent.isShift &&
   1:              !aKeyEvent.isControl && !aKeyEvent.isMeta && !aKeyEvent.isAlt));
   1: }
   1: 
   1: void
   1: key_event_to_context_menu_event(const nsKeyEvent* aKeyEvent,
   1:                                 nsMouseEvent* aCMEvent)
   1: {
   1:     memcpy(aCMEvent, aKeyEvent, sizeof(nsInputEvent));
   1:     aCMEvent->eventStructType = NS_MOUSE_EVENT;
   1:     aCMEvent->message = NS_CONTEXTMENU;
   1:     aCMEvent->context = nsMouseEvent::eContextMenuKey;
   1:     aCMEvent->button = nsMouseEvent::eRightButton;
   1:     aCMEvent->isShift = aCMEvent->isControl = PR_FALSE;
   1:     aCMEvent->isAlt = aCMEvent->isMeta = PR_FALSE;
   1:     aCMEvent->clickCount = 0;
   1:     aCMEvent->acceptActivation = PR_FALSE;
   1: }
   1: 
   1: /* static */
   1: int
   1: is_parent_ungrab_enter(GdkEventCrossing *aEvent)
   1: {
   1:     return (GDK_CROSSING_UNGRAB == aEvent->mode) &&
   1:         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
   1:          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
   1: 
   1: }
   1: 
   1: /* static */
   1: int
   1: is_parent_grab_leave(GdkEventCrossing *aEvent)
   1: {
   1:     return (GDK_CROSSING_GRAB == aEvent->mode) &&
   1:         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
   1:             (GDK_NOTIFY_VIRTUAL == aEvent->detail));
   1: }
   1: 
2475: static GdkModifierType
2475: gdk_keyboard_get_modifiers()
2475: {
2475:     GdkModifierType m = (GdkModifierType) 0;
2475: 
2475:     gdk_window_get_pointer(NULL, NULL, NULL, &m);
2475: 
2475:     return m;
2475: }
2475: 
2475: // Get the modifier masks for GDK_Caps_Lock, GDK_Num_Lock and GDK_Scroll_Lock.
2475: // Return PR_TRUE on success, PR_FALSE on error.
2475: static PRBool
2475: gdk_keyboard_get_modmap_masks(Display*  aDisplay,
2475:                               PRUint32* aCapsLockMask,
2475:                               PRUint32* aNumLockMask,
2475:                               PRUint32* aScrollLockMask)
2475: {
2475:     *aCapsLockMask = 0;
2475:     *aNumLockMask = 0;
2475:     *aScrollLockMask = 0;
2475: 
2475:     int min_keycode = 0;
2475:     int max_keycode = 0;
2475:     XDisplayKeycodes(aDisplay, &min_keycode, &max_keycode);
2475: 
2475:     int keysyms_per_keycode = 0;
2475:     KeySym* xkeymap = XGetKeyboardMapping(aDisplay, min_keycode,
2475:                                           max_keycode - min_keycode + 1,
2475:                                           &keysyms_per_keycode);
2475:     if (!xkeymap) {
2475:         return PR_FALSE;
2475:     }
2475: 
2475:     XModifierKeymap* xmodmap = XGetModifierMapping(aDisplay);
2475:     if (!xmodmap) {
2475:         XFree(xkeymap);
2475:         return PR_FALSE;
2475:     }
2475: 
2475:     /*
2475:       The modifiermap member of the XModifierKeymap structure contains 8 sets
2475:       of max_keypermod KeyCodes, one for each modifier in the order Shift,
2475:       Lock, Control, Mod1, Mod2, Mod3, Mod4, and Mod5.
2475:       Only nonzero KeyCodes have meaning in each set, and zero KeyCodes are ignored.
2475:     */
2475:     const unsigned int map_size = 8 * xmodmap->max_keypermod;
2475:     for (unsigned int i = 0; i < map_size; i++) {
2475:         KeyCode keycode = xmodmap->modifiermap[i];
2475:         if (!keycode || keycode < min_keycode || keycode > max_keycode)
2475:             continue;
2475: 
2475:         const KeySym* syms = xkeymap + (keycode - min_keycode) * keysyms_per_keycode;
2475:         const unsigned int mask = 1 << (i / xmodmap->max_keypermod);
2475:         for (int j = 0; j < keysyms_per_keycode; j++) {
2475:             switch (syms[j]) {
2475:                 case GDK_Caps_Lock:   *aCapsLockMask |= mask;   break;
2475:                 case GDK_Num_Lock:    *aNumLockMask |= mask;    break;
2475:                 case GDK_Scroll_Lock: *aScrollLockMask |= mask; break;
2475:             }
2475:         }
2475:     }
2475: 
2475:     XFreeModifiermap(xmodmap);
2475:     XFree(xkeymap);
2475:     return PR_TRUE;
2475: }
2475: 
   1: #ifdef ACCESSIBILITY
   1: /**
   1:  * void
   1:  * nsWindow::CreateRootAccessible
   1:  *
   1:  * request to create the nsIAccessible Object for the toplevel window
   1:  **/
   1: void
   1: nsWindow::CreateRootAccessible()
   1: {
   1:     if (mIsTopLevel && !mRootAccessible) {
   1:         nsCOMPtr<nsIAccessible> acc;
   1:         DispatchAccessibleEvent(getter_AddRefs(acc));
   1: 
   1:         if (acc) {
   1:             mRootAccessible = acc;
   1:         }
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::GetRootAccessible(nsIAccessible** aAccessible)
   1: {
   1:     nsCOMPtr<nsIAccessible> accessible, parentAccessible;
   1:     DispatchAccessibleEvent(getter_AddRefs(accessible));
   1:     PRUint32 role;
   1: 
   1:     if (!accessible) {
   1:         return;
   1:     }
   1:     while (PR_TRUE) {
   1:         accessible->GetParent(getter_AddRefs(parentAccessible));
   1:         if (!parentAccessible) {
   1:             break;
   1:         }
   1:         parentAccessible->GetRole(&role);
   1:         if (role == nsIAccessibleRole::ROLE_APP_ROOT) {
   1:             NS_ADDREF(*aAccessible = accessible);
   1:             break;
   1:         }
   1:         accessible = parentAccessible;
   1:     }
   1: }
   1: 
   1: /**
   1:  * void
   1:  * nsWindow::DispatchAccessibleEvent
   1:  * @aAccessible: the out var, hold the new accessible object
   1:  *
   1:  * generate the NS_GETACCESSIBLE event, the event handler is
   1:  * reponsible to create an nsIAccessible instant.
   1:  **/
   1: PRBool
   1: nsWindow::DispatchAccessibleEvent(nsIAccessible** aAccessible)
   1: {
   1:     PRBool result = PR_FALSE;
   1:     nsAccessibleEvent event(PR_TRUE, NS_GETACCESSIBLE, this);
   1: 
   1:     *aAccessible = nsnull;
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&event, status);
   1:     result = (nsEventStatus_eConsumeNoDefault == status) ? PR_TRUE : PR_FALSE;
   1: 
   1:     // if the event returned an accesssible get it.
   1:     if (event.accessible)
   1:         *aAccessible = event.accessible;
   1: 
   1:     return result;
   1: }
   1: 
   1: void
   1: nsWindow::DispatchActivateEvent(void)
   1: {
   1:     if (sAccessibilityEnabled) {
   1:         nsCOMPtr<nsIAccessible> rootAcc;
   1:         GetRootAccessible(getter_AddRefs(rootAcc));
   1:         nsCOMPtr<nsPIAccessible> privAcc(do_QueryInterface(rootAcc));
   1:         if (privAcc) {
   1:             privAcc->FireToolkitEvent(
 330:                          nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE,
   1:                          rootAcc, nsnull);
   1:         }
   1:     }
   1: 
   1:     nsCommonWidget::DispatchActivateEvent();
   1: }
   1: 
   1: void
   1: nsWindow::DispatchDeactivateEvent(void)
   1: {
   1:     nsCommonWidget::DispatchDeactivateEvent();
   1: 
   1:     if (sAccessibilityEnabled) {
   1:         nsCOMPtr<nsIAccessible> rootAcc;
   1:         GetRootAccessible(getter_AddRefs(rootAcc));
   1:         nsCOMPtr<nsPIAccessible> privAcc(do_QueryInterface(rootAcc));
   1:         if (privAcc) {
   1:             privAcc->FireToolkitEvent(
 330:                          nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE,
   1:                          rootAcc, nsnull);
   1:         }
   1:     }
   1: }
   1: #endif /* #ifdef ACCESSIBILITY */
   1: 
   1: // nsChildWindow class
   1: 
   1: nsChildWindow::nsChildWindow()
   1: {
   1: }
   1: 
   1: nsChildWindow::~nsChildWindow()
   1: {
   1: }
   1: 
   1: #ifdef USE_XIM
   1: 
   1: void
   1: nsWindow::IMEInitData(void)
   1: {
   1:     if (mIMEData)
   1:         return;
   1:     nsWindow *win = IMEGetOwningWindow();
   1:     if (!win)
   1:         return;
   1:     mIMEData = win->mIMEData;
   1:     if (!mIMEData)
   1:         return;
   1:     mIMEData->mRefCount++;
   1: }
   1: 
   1: void
   1: nsWindow::IMEReleaseData(void)
   1: {
   1:     if (!mIMEData)
   1:         return;
   1: 
   1:     mIMEData->mRefCount--;
   1:     if (mIMEData->mRefCount != 0)
   1:         return;
   1: 
   1:     delete mIMEData;
   1:     mIMEData = nsnull;
   1: }
   1: 
   1: void
   1: nsWindow::IMEDestroyContext(void)
   1: {
   1:     if (!mIMEData || mIMEData->mOwner != this) {
   1:         // This nsWindow is not the owner of the instance of mIMEData.
   1:         if (IMEComposingWindow() == this)
   1:             CancelIMEComposition();
   1:         if (gIMEFocusWindow == this)
   1:             gIMEFocusWindow = nsnull;
   1:         IMEReleaseData();
   1:         return;
   1:     }
   1: 
   1:     /* NOTE:
   1:      * This nsWindow is the owner of the instance of mIMEData,
   1:      * so, we must release the contexts now. But that might be referred from
   1:      * other nsWindows.(They are children of this. But we don't know why there
   1:      * are the cases.) So, we need to clear the pointers that refers to contexts
   1:      * and this if the other referrers are still alive. See bug 349727.
   1:      */
   1: 
   1:     // If this is the focus window and we have an IM context we need
   1:     // to unset the focus on this window before we destroy the window.
   1:     GtkIMContext *im = IMEGetContext();
   1:     if (im && gIMEFocusWindow && gIMEFocusWindow->IMEGetContext() == im) {
   1:         gIMEFocusWindow->IMELoseFocus();
   1:         gIMEFocusWindow = nsnull;
   1:     }
   1: 
   1:     mIMEData->mOwner   = nsnull;
 539:     mIMEData->mEnabled = nsIKBStateControl::IME_STATUS_DISABLED;
   1: 
   1:     if (mIMEData->mContext) {
   1:         gtk_im_context_set_client_window(mIMEData->mContext, nsnull);
   1:         g_object_unref(G_OBJECT(mIMEData->mContext));
   1:         mIMEData->mContext = nsnull;
   1:     }
   1: 
   1:     if (mIMEData->mDummyContext) {
   1:         gtk_im_context_set_client_window(mIMEData->mDummyContext, nsnull);
   1:         g_object_unref(G_OBJECT(mIMEData->mDummyContext));
   1:         mIMEData->mDummyContext = nsnull;
   1:     }
   1: 
   1:     IMEReleaseData();
   1: }
   1: 
   1: void
   1: nsWindow::IMESetFocus(void)
   1: {
   1:     IMEInitData();
   1: 
   1:     LOGIM(("IMESetFocus %p\n", (void *)this));
   1:     GtkIMContext *im = IMEGetContext();
   1:     if (!im)
   1:         return;
   1: 
   1:     gtk_im_context_focus_in(im);
   1:     gIMEFocusWindow = this;
   1: 
   1:     if (!IMEIsEnabled()) {
   1:         // We should release IME focus for uim and scim.
   1:         // These IMs are using snooper that is released at losing focus.
   1:         IMELoseFocus();
   1:     }
   1: }
   1: 
   1: void
   1: nsWindow::IMELoseFocus(void)
   1: {
   1:     LOGIM(("IMELoseFocus %p\n", (void *)this));
   1:     GtkIMContext *im = IMEGetContext();
   1:     if (!im)
   1:         return;
   1: 
   1:     gtk_im_context_focus_out(im);
   1: }
   1: 
   1: void
   1: nsWindow::IMEComposeStart(void)
   1: {
   1:     LOGIM(("IMEComposeStart [%p]\n", (void *)this));
   1: 
   1:     if (!mIMEData) {
   1:         NS_ERROR("This widget doesn't support IM");
   1:         return;
   1:     }
   1: 
   1:     if (IMEComposingWindow()) {
   1:         NS_WARNING("tried to re-start text composition\n");
   1:         return;
   1:     }
   1: 
   1:     mIMEData->mComposingWindow = this;
   1: 
   1:     nsCompositionEvent compEvent(PR_TRUE, NS_COMPOSITION_START, this);
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&compEvent, status);
   1: 
 920:     if (NS_UNLIKELY(mIsDestroyed))
 920:         return;
 920: 
   1:     gint x1, y1, x2, y2;
   1:     GtkWidget *widget =
   1:         get_gtk_widget_for_gdk_window(this->mDrawingarea->inner_window);
   1: 
   1:     gdk_window_get_origin(widget->window, &x1, &y1);
   1:     gdk_window_get_origin(this->mDrawingarea->inner_window, &x2, &y2);
   1: 
   1:     GdkRectangle area;
   1:     area.x = compEvent.theReply.mCursorPosition.x + (x2 - x1);
   1:     area.y = compEvent.theReply.mCursorPosition.y + (y2 - y1);
   1:     area.width  = 0;
   1:     area.height = compEvent.theReply.mCursorPosition.height;
   1: 
   1:     gtk_im_context_set_cursor_location(IMEGetContext(), &area);
   1: }
   1: 
   1: void
   1: nsWindow::IMEComposeText(const PRUnichar *aText,
   1:                          const PRInt32 aLen,
   1:                          const gchar *aPreeditString,
   1:                          const gint aCursorPos,
   1:                          const PangoAttrList *aFeedback)
   1: {
   1:     if (!mIMEData) {
   1:         NS_ERROR("This widget doesn't support IM");
   1:         return;
   1:     }
   1: 
   1:     // Send our start composition event if we need to
 920:     if (!IMEComposingWindow()) {
   1:         IMEComposeStart();
 920:         if (NS_UNLIKELY(mIsDestroyed))
 920:             return;
 920:     }
 920: 
   1: 
   1:     LOGIM(("IMEComposeText\n"));
   1:     nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, this);
   1: 
   1:     if (aLen != 0) {
   1:         textEvent.theText = (PRUnichar*)aText;
   1: 
   1:         if (aPreeditString && aFeedback && (aLen > 0)) {
   1:             IM_set_text_range(aLen, aPreeditString, aCursorPos, aFeedback,
   1:                               &(textEvent.rangeCount),
   1:                               &(textEvent.rangeArray));
   1:         }
   1:     }
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&textEvent, status);
   1: 
   1:     if (textEvent.rangeArray) {
   1:         delete[] textEvent.rangeArray;
   1:     }
   1: 
 920:     if (NS_UNLIKELY(mIsDestroyed))
 920:         return;
 920: 
   1:     gint x1, y1, x2, y2;
   1:     GtkWidget *widget =
   1:         get_gtk_widget_for_gdk_window(this->mDrawingarea->inner_window);
   1: 
   1:     gdk_window_get_origin(widget->window, &x1, &y1);
   1:     gdk_window_get_origin(this->mDrawingarea->inner_window, &x2, &y2);
   1: 
   1:     GdkRectangle area;
   1:     area.x = textEvent.theReply.mCursorPosition.x + (x2 - x1);
   1:     area.y = textEvent.theReply.mCursorPosition.y + (y2 - y1);
   1:     area.width  = 0;
   1:     area.height = textEvent.theReply.mCursorPosition.height;
   1: 
   1:     gtk_im_context_set_cursor_location(IMEGetContext(), &area);
   1: }
   1: 
   1: void
   1: nsWindow::IMEComposeEnd(void)
   1: {
   1:     LOGIM(("IMEComposeEnd [%p]\n", (void *)this));
   1:     NS_ASSERTION(mIMEData, "This widget doesn't support IM");
   1: 
   1:     if (!IMEComposingWindow()) {
   1:         NS_WARNING("tried to end text composition before it was started");
   1:         return;
   1:     }
   1: 
   1:     mIMEData->mComposingWindow = nsnull;
   1: 
   1:     nsCompositionEvent compEvent(PR_TRUE, NS_COMPOSITION_END, this);
   1: 
   1:     nsEventStatus status;
   1:     DispatchEvent(&compEvent, status);
   1: }
   1: 
   1: GtkIMContext*
   1: nsWindow::IMEGetContext()
   1: {
   1:     return IM_get_input_context(this);
   1: }
   1: 
 539: static PRBool
 539: IsIMEEnabledState(PRUint32 aState)
 539: {
 539:     return aState == nsIKBStateControl::IME_STATUS_ENABLED ? PR_TRUE : PR_FALSE;
 539: }
 539: 
   1: PRBool
   1: nsWindow::IMEIsEnabled(void)
   1: {
 539:     return mIMEData ? IsIMEEnabledState(mIMEData->mEnabled) : PR_FALSE;
   1: }
   1: 
   1: nsWindow*
   1: nsWindow::IMEComposingWindow(void)
   1: {
   1:     return mIMEData ? mIMEData->mComposingWindow : nsnull;
   1: }
   1: 
   1: nsWindow*
   1: nsWindow::IMEGetOwningWindow(void)
   1: {
   1:     nsWindow *window = IM_get_owning_window(this->mDrawingarea);
   1:     return window;
   1: }
   1: 
   1: void
   1: nsWindow::IMECreateContext(void)
   1: {
   1:     mIMEData = new nsIMEData(this);
   1:     if (!mIMEData)
   1:         return;
   1: 
   1:     mIMEData->mContext = gtk_im_multicontext_new();
   1:     mIMEData->mDummyContext = gtk_im_multicontext_new();
   1:     if (!mIMEData->mContext || !mIMEData->mDummyContext) {
   1:         NS_ERROR("failed to create IM context.");
   1:         IMEDestroyContext();
   1:         return;
   1:     }
   1: 
   1:     gtk_im_context_set_client_window(mIMEData->mContext,
   1:                                      GTK_WIDGET(mContainer)->window);
   1:     gtk_im_context_set_client_window(mIMEData->mDummyContext,
   1:                                      GTK_WIDGET(mContainer)->window);
   1: 
   1:     g_signal_connect(G_OBJECT(mIMEData->mContext), "preedit_changed",
   1:                      G_CALLBACK(IM_preedit_changed_cb), this);
   1:     g_signal_connect(G_OBJECT(mIMEData->mContext), "commit",
   1:                      G_CALLBACK(IM_commit_cb), this);
   1: }
   1: 
   1: PRBool
   1: nsWindow::IMEFilterEvent(GdkEventKey *aEvent)
   1: {
   1:     if (!IMEIsEnabled())
   1:         return FALSE;
   1: 
   1:     GtkIMContext *im = IMEGetContext();
   1:     if (!im)
   1:         return FALSE;
   1: 
   1:     gKeyEvent = aEvent;
   1:     gboolean filtered = gtk_im_context_filter_keypress(im, aEvent);
   1:     gKeyEvent = NULL;
   1: 
   1:     LOGIM(("key filtered: %d committed: %d changed: %d\n",
   1:            filtered, gKeyEventCommitted, gKeyEventChanged));
   1: 
   1:     // We filter the key event if the event was not committed (because
   1:     // it's probably part of a composition) or if the key event was
   1:     // committed _and_ changed.  This way we still let key press
   1:     // events go through as simple key press events instead of
   1:     // composed characters.
   1: 
   1:     PRBool retval = PR_FALSE;
   1:     if (filtered &&
   1:         (!gKeyEventCommitted || (gKeyEventCommitted && gKeyEventChanged)))
   1:         retval = PR_TRUE;
   1: 
   1:     gKeyEventChanged = PR_FALSE;
   1:     gKeyEventCommitted = PR_FALSE;
   1:     gKeyEventChanged = PR_FALSE;
   1: 
   1:     return retval;
   1: }
   1: 
   1: /* nsIKBStateControl */
   1: NS_IMETHODIMP
   1: nsWindow::ResetInputState()
   1: {
   1:     IMEInitData();
   1: 
 920:     nsRefPtr<nsWindow> win = IMEComposingWindow();
   1:     if (win) {
   1:         GtkIMContext *im = IMEGetContext();
   1:         if (!im)
   1:             return NS_OK;
   1: 
   1:         gchar *preedit_string;
   1:         gint cursor_pos;
   1:         PangoAttrList *feedback_list;
   1:         gtk_im_context_get_preedit_string(im, &preedit_string,
   1:                                           &feedback_list, &cursor_pos);
   1:         if (preedit_string && *preedit_string) {
   1:             IM_commit_cb_internal(preedit_string, win);
   1:             g_free(preedit_string);
   1:         }
   1:         if (feedback_list)
   1:             pango_attr_list_unref(feedback_list);
   1:     }
   1: 
   1:     CancelIMEComposition();
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::SetIMEOpenState(PRBool aState)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::GetIMEOpenState(PRBool* aState)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
 539: nsWindow::SetIMEEnabled(PRUint32 aState)
   1: {
   1:     IMEInitData();
 539:     if (!mIMEData)
   1:         return NS_OK;
   1: 
 539:     PRBool newState = IsIMEEnabledState(aState);
 539:     PRBool oldState = IsIMEEnabledState(mIMEData->mEnabled);
 539:     if (newState == oldState) {
 539:         mIMEData->mEnabled = aState;
 539:         return NS_OK;
 539:     }
 539: 
   1:     GtkIMContext *focusedIm = nsnull;
   1:     // XXX Don't we need to check gFocusWindow?
 920:     nsRefPtr<nsWindow> focusedWin = gIMEFocusWindow;
   1:     if (focusedWin && focusedWin->mIMEData)
   1:         focusedIm = focusedWin->mIMEData->mContext;
   1: 
   1:     if (focusedIm && focusedIm == mIMEData->mContext) {
   1:         // Release current IME focus if IME is enabled.
 539:         if (oldState) {
   1:             focusedWin->ResetInputState();
   1:             focusedWin->IMELoseFocus();
   1:         }
   1: 
   1:         mIMEData->mEnabled = aState;
   1: 
   1:         // Even when aState is not PR_TRUE, we need to set IME focus.
   1:         // Because some IMs are updating the status bar of them in this time.
   1:         focusedWin->IMESetFocus();
   1:     } else {
 539:         if (oldState)
   1:             ResetInputState();
   1:         mIMEData->mEnabled = aState;
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
 539: nsWindow::GetIMEEnabled(PRUint32* aState)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aState);
   1: 
   1:     IMEInitData();
   1: 
 539:     *aState =
 539:       mIMEData ? mIMEData->mEnabled : nsIKBStateControl::IME_STATUS_DISABLED;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsWindow::CancelIMEComposition()
   1: {
   1:     IMEInitData();
   1: 
   1:     GtkIMContext *im = IMEGetContext();
   1:     if (!im)
   1:         return NS_OK;
   1: 
   1:     NS_ASSERTION(!gIMESuppressCommit,
   1:                  "CancelIMEComposition is already called!");
   1:     gIMESuppressCommit = PR_TRUE;
   1:     gtk_im_context_reset(im);
   1:     gIMESuppressCommit = PR_FALSE;
   1: 
 920:     nsRefPtr<nsWindow> win = IMEComposingWindow();
   1:     if (win) {
   1:         win->IMEComposeText(nsnull, 0, nsnull, 0, nsnull);
   1:         win->IMEComposeEnd();
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
2475: NS_IMETHODIMP
2475: nsWindow::GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState)
2475: {
2475:     NS_ENSURE_ARG_POINTER(aLEDState);
2475: 
2475:     GdkModifierType modifiers = gdk_keyboard_get_modifiers();
2475:     PRUint32 capsLockMask, numLockMask, scrollLockMask;
2475:     PRBool foundMasks = gdk_keyboard_get_modmap_masks(
2475:                           GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
2475:                           &capsLockMask, &numLockMask, &scrollLockMask);
2475: 
2475:     PRUint32 mask = 0;
2475:     switch (aKeyCode) {
2475:         case NS_VK_CAPS_LOCK:   mask = capsLockMask;   break;
2475:         case NS_VK_NUM_LOCK:    mask = numLockMask;    break;
2475:         case NS_VK_SCROLL_LOCK: mask = scrollLockMask; break;
2475:     }
2475:     if (mask == 0)
2475:         return NS_ERROR_NOT_IMPLEMENTED;
2475: 
2475:     *aLEDState = (modifiers & mask) != 0;
2475:     return NS_OK;
2475: }
2475: 
   1: /* static */
   1: void
   1: IM_preedit_changed_cb(GtkIMContext *aContext,
   1:                       nsWindow     *aWindow)
   1: {
   1:     gchar *preedit_string;
   1:     gint cursor_pos;
   1:     PangoAttrList *feedback_list;
   1: 
   1:     // if gFocusWindow is null, use the last focused gIMEFocusWindow
 920:     nsRefPtr<nsWindow> window = gFocusWindow ? gFocusWindow : gIMEFocusWindow;
   1:     if (!window)
   1:         return;
   1: 
   1:     // Should use cursor_pos ?
   1:     // Of course!!!
   1:     gtk_im_context_get_preedit_string(aContext, &preedit_string,
   1:                                       &feedback_list, &cursor_pos);
   1: 
   1:     LOGIM(("preedit string is: %s   length is: %d\n",
   1:            preedit_string, strlen(preedit_string)));
   1: 
   1:     if (!preedit_string || !*preedit_string) {
   1:         LOGIM(("preedit ended\n"));
   1:         window->IMEComposeText(NULL, 0, NULL, 0, NULL);
   1:         window->IMEComposeEnd();
   1:         return;
   1:     }
   1: 
   1:     LOGIM(("preedit len %d\n", strlen(preedit_string)));
   1: 
   1:     gunichar2 * uniStr;
   1:     glong uniStrLen;
   1: 
   1:     uniStr = NULL;
   1:     uniStrLen = 0;
   1:     uniStr = g_utf8_to_utf16(preedit_string, -1, NULL, &uniStrLen, NULL);
   1: 
   1:     if (!uniStr) {
   1:         g_free(preedit_string);
   1:         LOG(("utf8-utf16 string tranfer failed!\n"));
   1:         if (feedback_list)
   1:             pango_attr_list_unref(feedback_list);
   1:         return;
   1:     }
   1: 
   1:     if (uniStrLen) {
3233:         window->IMEComposeText(static_cast<const PRUnichar *>(uniStr),
   1:                                uniStrLen, preedit_string, cursor_pos, feedback_list);
   1:     }
   1: 
   1:     g_free(preedit_string);
   1:     g_free(uniStr);
   1: 
   1:     if (feedback_list)
   1:         pango_attr_list_unref(feedback_list);
   1: }
   1: 
   1: /* static */
   1: void
   1: IM_commit_cb(GtkIMContext *aContext,
   1:              const gchar  *aUtf8_str,
   1:              nsWindow     *aWindow)
   1: {
   1:     if (gIMESuppressCommit)
   1:         return;
   1: 
   1:     LOGIM(("IM_commit_cb\n"));
   1: 
   1:     gKeyEventCommitted = PR_TRUE;
   1: 
   1:     // if gFocusWindow is null, use the last focused gIMEFocusWindow
 920:     nsRefPtr<nsWindow> window = gFocusWindow ? gFocusWindow : gIMEFocusWindow;
   1: 
   1:     if (!window)
   1:         return;
   1: 
   1:     /* If IME doesn't change they keyevent that generated this commit,
   1:        don't send it through XIM - just send it as a normal key press
   1:        event. */
   1: 
   1:     if (gKeyEvent) {
   1:         char keyval_utf8[8]; /* should have at least 6 bytes of space */
   1:         gint keyval_utf8_len;
   1:         guint32 keyval_unicode;
   1: 
   1:         keyval_unicode = gdk_keyval_to_unicode(gKeyEvent->keyval);
   1:         keyval_utf8_len = g_unichar_to_utf8(keyval_unicode, keyval_utf8);
   1:         keyval_utf8[keyval_utf8_len] = '\0';
   1: 
   1:         if (!strcmp(aUtf8_str, keyval_utf8)) {
   1:             gKeyEventChanged = PR_FALSE;
   1:             return;
   1:         }
   1:     }
   1: 
   1:     gKeyEventChanged = PR_TRUE;
   1:     IM_commit_cb_internal(aUtf8_str, window);
   1: }
   1: 
   1: /* static */
   1: void
   1: IM_commit_cb_internal(const gchar  *aUtf8_str,
   1:                       nsWindow     *aWindow)
   1: {
   1:     gunichar2 *uniStr = nsnull;
   1:     glong uniStrLen = 0;
   1:     uniStr = g_utf8_to_utf16(aUtf8_str, -1, NULL, &uniStrLen, NULL);
   1: 
   1:     if (!uniStr) {
   1:         LOGIM(("utf80utf16 string tranfer failed!\n"));
   1:         return;
   1:     }
   1: 
   1:     if (uniStrLen) {
   1:         aWindow->IMEComposeText((const PRUnichar *)uniStr,
   1:                                 (PRInt32)uniStrLen, nsnull, 0, nsnull);
   1:         aWindow->IMEComposeEnd();
   1:     }
   1: 
   1:     g_free(uniStr);
   1: }
   1: 
   1: #define	START_OFFSET(I)	\
   1:     (*aTextRangeListResult)[I].mStartOffset
   1: 
   1: #define	END_OFFSET(I) \
   1:     (*aTextRangeListResult)[I].mEndOffset
   1: 
   1: #define	SET_FEEDBACKTYPE(I,T) (*aTextRangeListResult)[I].mRangeType = T
   1: 
   1: /* static */
   1: void
   1: IM_set_text_range(const PRInt32 aLen,
   1:                   const gchar *aPreeditString,
   1:                   const gint aCursorPos,
   1:                   const PangoAttrList *aFeedback,
   1:                   PRUint32 *aTextRangeListLengthResult,
   1:                   nsTextRangeArray *aTextRangeListResult)
   1: {
   1:     if (aLen == 0) {
   1:         aTextRangeListLengthResult = 0;
   1:         aTextRangeListResult = NULL;
   1:         return;
   1:     }
   1: 
   1:     PangoAttrIterator * aFeedbackIterator;
   1:     aFeedbackIterator = pango_attr_list_get_iterator((PangoAttrList*)aFeedback);
3233:     //(reinterpret_cast<PangoAttrList*>(aFeedback));
   1:     // Since some compilers don't permit this casting -- from const to un-const
   1:     if (aFeedbackIterator == NULL) return;
   1: 
   1:     /*
   1:      * Don't use pango_attr_iterator_range, it'll mislead you.
   1:      * As for going through the list to get the attribute number,
   1:      * it take much time for performance.
   1:      * Now it's simple and enough, although maybe waste a little space.
   1:     */
   1:     PRInt32 aMaxLenOfTextRange;
   1:     aMaxLenOfTextRange = 2*aLen + 1;
   1:     *aTextRangeListResult = new nsTextRange[aMaxLenOfTextRange];
   1:     NS_ASSERTION(*aTextRangeListResult, "No enough memory.");
   1: 
   1:     // Set caret's postion
   1:     SET_FEEDBACKTYPE(0, NS_TEXTRANGE_CARETPOSITION);
   1:     START_OFFSET(0) = aCursorPos;
   1:     END_OFFSET(0) = aCursorPos;
   1: 
   1:     int count = 0;
   1:     PangoAttribute * aPangoAttr;
   1:     PangoAttribute * aPangoAttrReverse, * aPangoAttrUnderline;
   1:     /*
   1:      * Depend on gtk2's implementation on XIM support.
   1:      * In aFeedback got from gtk2, there are only three types of data:
   1:      * PANGO_ATTR_UNDERLINE, PANGO_ATTR_FOREGROUND, PANGO_ATTR_BACKGROUND.
   1:      * Corresponding to XIMUnderline, XIMReverse.
   1:      * Don't take PANGO_ATTR_BACKGROUND into account, since
   1:      * PANGO_ATTR_BACKGROUND and PANGO_ATTR_FOREGROUND are always
   1:      * a couple.
   1:      */
   1:     gint start, end;
   1:     gunichar2 * uniStr;
   1:     glong uniStrLen;
   1:     do {
   1:         aPangoAttrUnderline = pango_attr_iterator_get(aFeedbackIterator,
   1:                                                       PANGO_ATTR_UNDERLINE);
   1:         aPangoAttrReverse = pango_attr_iterator_get(aFeedbackIterator,
   1:                                                     PANGO_ATTR_FOREGROUND);
   1:         if (!aPangoAttrUnderline && !aPangoAttrReverse)
   1:             continue;
   1: 
   1:         // Get the range of the current attribute(s)
   1:         pango_attr_iterator_range(aFeedbackIterator, &start, &end);
   1: 
   1:         PRUint32 feedbackType = 0;
   1:         // XIMReverse | XIMUnderline
   1:         if (aPangoAttrUnderline && aPangoAttrReverse) {
   1:             feedbackType = NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
   1:             // Doesn't matter which attribute we use here since we
   1:             // are using pango_attr_iterator_range to determine the
   1:             // range of the attributes.
   1:             aPangoAttr = aPangoAttrUnderline;
   1:         }
   1:         // XIMUnderline
   1:         else if (aPangoAttrUnderline) {
   1:             feedbackType = NS_TEXTRANGE_CONVERTEDTEXT;
   1:             aPangoAttr = aPangoAttrUnderline;
   1:         }
   1:         // XIMReverse
   1:         else if (aPangoAttrReverse) {
   1:             feedbackType = NS_TEXTRANGE_SELECTEDRAWTEXT;
   1:             aPangoAttr = aPangoAttrReverse;
   1:         }
   1: 
   1:         count++;
   1:         START_OFFSET(count) = 0;
   1:         END_OFFSET(count) = 0;
   1: 
   1:         uniStr = NULL;
   1:         if (start > 0) {
   1:             uniStr = g_utf8_to_utf16(aPreeditString, start,
   1:                                      NULL, &uniStrLen, NULL);
   1:         }
   1:         if (uniStr) {
   1:             START_OFFSET(count) = uniStrLen;
   1:             g_free(uniStr);
   1:         }
   1: 
   1:         uniStr = NULL;
   1:         uniStr = g_utf8_to_utf16(aPreeditString + start, end - start,
   1:                                  NULL, &uniStrLen, NULL);
   1:         if (uniStr) {
   1:             END_OFFSET(count) = START_OFFSET(count) + uniStrLen;
   1:             SET_FEEDBACKTYPE(count, feedbackType);
   1:             g_free(uniStr);
   1:         }
   1: 
   1:     } while ((count < aMaxLenOfTextRange - 1) &&
   1:              (pango_attr_iterator_next(aFeedbackIterator)));
   1: 
   1:    *aTextRangeListLengthResult = count + 1;
   1: 
   1:    pango_attr_iterator_destroy(aFeedbackIterator);
   1: }
   1: 
   1: /* static */
   1: nsWindow *
   1: IM_get_owning_window(MozDrawingarea *aArea)
   1: {
   1:     if (!aArea)
   1:         return nsnull;
   1:     GtkWidget *owningWidget =
   1:         get_gtk_widget_for_gdk_window(aArea->inner_window);
   1:     if (!owningWidget)
   1:         return nsnull;
   1:     return get_window_for_gtk_widget(owningWidget);
   1: }
   1: 
   1: /* static */
   1: GtkIMContext *
   1: IM_get_input_context(nsWindow *aWindow)
   1: {
   1:     if (!aWindow)
   1:         return nsnull;
   1:     nsWindow::nsIMEData *data = aWindow->mIMEData;
   1:     if (!data)
   1:         return nsnull;
   1:     return data->mEnabled ? data->mContext : data->mDummyContext;
   1: }
   1: 
   1: #endif
   1: 
   1: // return the gfxASurface for rendering to this widget
   1: gfxASurface*
   1: nsWindow::GetThebesSurface()
   1: {
   1:     // XXXvlad always create a new thebes surface for now,
   1:     // because the old clip doesn't get cleared otherwise.
   1:     // we should fix this at some point, and just reset
   1:     // the clip.
   1:     mThebesSurface = nsnull;
   1: 
   1:     if (!mThebesSurface) {
   1:         GdkDrawable* d = GDK_DRAWABLE(mDrawingarea->inner_window);
   1:         gint width, height;
   1:         gdk_drawable_get_size(d, &width, &height);
   1:         if (!gfxPlatform::UseGlitz()) {
   1:             mThebesSurface = new gfxXlibSurface
   1:                 (GDK_WINDOW_XDISPLAY(d),
   1:                  GDK_WINDOW_XWINDOW(d),
   1:                  GDK_VISUAL_XVISUAL(gdk_drawable_get_visual(d)),
   1:                  gfxIntSize(width, height));
3368:             if (mThebesSurface && !mThebesSurface->CairoStatus()) {
   1:                 gfxPlatformGtk::GetPlatform()->SetSurfaceGdkWindow(mThebesSurface, GDK_WINDOW(d));
3368:             }
3368:             else {
3368:                 mThebesSurface = nsnull;
3368:             }
   1:         } else {
   1: #ifdef MOZ_ENABLE_GLITZ
   1:             glitz_surface_t *gsurf;
   1:             glitz_drawable_t *gdraw;
   1: 
   1:             glitz_drawable_format_t *gdformat = glitz_glx_find_window_format (GDK_DISPLAY(),
   1:                                                                               gdk_x11_get_default_screen(),
   1:                                                                               0, NULL, 0);
   1:             if (!gdformat)
   1:                 NS_ERROR("Failed to find glitz drawable format");
   1: 
   1:             Display* dpy = GDK_WINDOW_XDISPLAY(d);
   1:             Window wnd = GDK_WINDOW_XWINDOW(d);
   1:             
   1:             gdraw =
   1:                 glitz_glx_create_drawable_for_window (dpy,
   1:                                                       DefaultScreen(dpy),
   1:                                                       gdformat,
   1:                                                       wnd,
   1:                                                       width,
   1:                                                       height);
   1:             glitz_format_t *gformat =
   1:                 glitz_find_standard_format (gdraw, GLITZ_STANDARD_RGB24);
   1:             gsurf =
   1:                 glitz_surface_create (gdraw,
   1:                                       gformat,
   1:                                       width,
   1:                                       height,
   1:                                       0,
   1:                                       NULL);
   1:             glitz_surface_attach (gsurf, gdraw, GLITZ_DRAWABLE_BUFFER_FRONT_COLOR);
   1: 
   1: 
   1:             //fprintf (stderr, "## nsThebesDrawingSurface::Init Glitz DRAWABLE %p (DC: %p)\n", aWidget, aDC);
   1:             mThebesSurface = new gfxGlitzSurface (gdraw, gsurf, PR_TRUE);
   1: #endif
   1:         }
   1:     }
   1: 
   1:     return mThebesSurface;
   1: }
