    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
59512:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Sharable code and data for wrapper around JSObjects. */
    1: 
    1: #include "xpcprivate.h"
27611: #include "nsArrayEnumerator.h"
27646: #include "nsWrapperCache.h"
27664: #include "XPCWrapper.h"
55604: #include "AccessCheck.h"
59512: #include "nsJSUtils.h"
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsXPCWrappedJSClass, nsIXPCWrappedJSClass)
    1: 
    1: // the value of this variable is never used - we use its address as a sentinel
    1: static uint32 zero_methods_descriptor;
    1: 
61765: PRBool AutoScriptEvaluate::StartEvaluating(JSObject *scope, JSErrorReporter errorReporter)
    1: {
    1:     NS_PRECONDITION(!mEvaluated, "AutoScriptEvaluate::Evaluate should only be called once");
    1: 
    1:     if (!mJSContext)
61765:         return PR_TRUE;
61765: 
    1:     mEvaluated = PR_TRUE;
20343:     if(!mJSContext->errorReporter)
20343:     {
20343:         JS_SetErrorReporter(mJSContext, errorReporter);
20343:         mErrorReporterSet = PR_TRUE;
20343:     }
    1:     mContextHasThread = JS_GetContextThread(mJSContext);
    1:     if (mContextHasThread)
    1:         JS_BeginRequest(mJSContext);
    1: 
61765:     if (!mEnterCompartment.enter(mJSContext, scope))
61765:         return PR_FALSE;
61765: 
    1:     // Saving the exception state keeps us from interfering with another script
    1:     // that may also be running on this context.  This occurred first with the
    1:     // js debugger, as described in
    1:     // http://bugzilla.mozilla.org/show_bug.cgi?id=88130 but presumably could
    1:     // show up in any situation where a script calls into a wrapped js component
    1:     // on the same context, while the context has a nonzero exception state.
    1:     // Because JS_SaveExceptionState/JS_RestoreExceptionState use malloc
    1:     // and addroot, we avoid them if possible by returning null (as opposed to
    1:     // a JSExceptionState with no information) when there is no pending
    1:     // exception.
    1:     if(JS_IsExceptionPending(mJSContext))
    1:     {
    1:         mState = JS_SaveExceptionState(mJSContext);
    1:         JS_ClearPendingException(mJSContext);
    1:     }
61765: 
61765:     return PR_TRUE;
    1: }
    1: 
    1: AutoScriptEvaluate::~AutoScriptEvaluate()
    1: {
    1:     if(!mJSContext || !mEvaluated)
    1:         return;
    1:     if(mState)
    1:         JS_RestoreExceptionState(mJSContext, mState);
    1:     else
    1:         JS_ClearPendingException(mJSContext);
    1: 
    1:     if(mContextHasThread)
    1:         JS_EndRequest(mJSContext);
    1: 
    1:     // If this is a JSContext that has a private context that provides a
    1:     // nsIXPCScriptNotify interface, then notify the object the script has
    1:     // been executed.
    1:     //
    1:     // Note: We rely on the rule that if any JSContext in our JSRuntime has
    1:     // private data that points to an nsISupports subclass, it has also set
    1:     // the JSOPTION_PRIVATE_IS_NSISUPPORTS option.
    1: 
    1:     if (JS_GetOptions(mJSContext) & JSOPTION_PRIVATE_IS_NSISUPPORTS)
    1:     {
    1:         nsCOMPtr<nsIXPCScriptNotify> scriptNotify = 
 3233:             do_QueryInterface(static_cast<nsISupports*>
 3233:                                          (JS_GetContextPrivate(mJSContext)));
    1:         if(scriptNotify)
    1:             scriptNotify->ScriptExecuted();
    1:     }
20343: 
20343:     if(mErrorReporterSet)
20343:         JS_SetErrorReporter(mJSContext, NULL);
    1: }
    1: 
    1: // It turns out that some errors may be not worth reporting. So, this
    1: // function is factored out to manage that.
    1: JSBool xpc_IsReportableErrorCode(nsresult code)
    1: {
14170:     if (NS_SUCCEEDED(code))
14170:         return JS_FALSE;
14170: 
    1:     switch(code)
    1:     {
14170:         // Error codes that we don't want to report as errors...
14170:         // These generally indicate bad interface design AFAIC. 
14170:         case NS_ERROR_FACTORY_REGISTER_AGAIN:
14170:         case NS_BASE_STREAM_WOULD_BLOCK:
14170:             return JS_FALSE;
14170:     }
14170: 
 7162:     return JS_TRUE;
 7162: }
    1: 
    1: // static
    1: nsresult
    1: nsXPCWrappedJSClass::GetNewOrUsed(XPCCallContext& ccx, REFNSIID aIID,
    1:                                   nsXPCWrappedJSClass** resultClazz)
    1: {
    1:     nsXPCWrappedJSClass* clazz = nsnull;
    1:     XPCJSRuntime* rt = ccx.GetRuntime();
    1: 
    1:     {   // scoped lock
    1:         XPCAutoLock lock(rt->GetMapLock());
    1:         IID2WrappedJSClassMap* map = rt->GetWrappedJSClassMap();
    1:         clazz = map->Find(aIID);
    1:         NS_IF_ADDREF(clazz);
    1:     }
    1: 
    1:     if(!clazz)
    1:     {
    1:         nsCOMPtr<nsIInterfaceInfo> info;
    1:         ccx.GetXPConnect()->GetInfoForIID(&aIID, getter_AddRefs(info));
    1:         if(info)
    1:         {
    1:             PRBool canScript;
    1:             if(NS_SUCCEEDED(info->IsScriptable(&canScript)) && canScript &&
    1:                nsXPConnect::IsISupportsDescendant(info))
    1:             {
    1:                 clazz = new nsXPCWrappedJSClass(ccx, aIID, info);
    1:                 if(clazz && !clazz->mDescriptors)
    1:                     NS_RELEASE(clazz);  // sets clazz to nsnull
    1:             }
    1:         }
    1:     }
    1:     *resultClazz = clazz;
    1:     return NS_OK;
    1: }
    1: 
    1: nsXPCWrappedJSClass::nsXPCWrappedJSClass(XPCCallContext& ccx, REFNSIID aIID,
    1:                                          nsIInterfaceInfo* aInfo)
    1:     : mRuntime(ccx.GetRuntime()),
    1:       mInfo(aInfo),
    1:       mName(nsnull),
    1:       mIID(aIID),
    1:       mDescriptors(nsnull)
    1: {
    1:     NS_ADDREF(mInfo);
    1:     NS_ADDREF_THIS();
    1: 
    1:     {   // scoped lock
    1:         XPCAutoLock lock(mRuntime->GetMapLock());
    1:         mRuntime->GetWrappedJSClassMap()->Add(this);
    1:     }
    1: 
    1:     uint16 methodCount;
    1:     if(NS_SUCCEEDED(mInfo->GetMethodCount(&methodCount)))
    1:     {
    1:         if(methodCount)
    1:         {
    1:             int wordCount = (methodCount/32)+1;
    1:             if(nsnull != (mDescriptors = new uint32[wordCount]))
    1:             {
    1:                 int i;
    1:                 // init flags to 0;
    1:                 for(i = wordCount-1; i >= 0; i--)
    1:                     mDescriptors[i] = 0;
    1: 
    1:                 for(i = 0; i < methodCount; i++)
    1:                 {
    1:                     const nsXPTMethodInfo* info;
    1:                     if(NS_SUCCEEDED(mInfo->GetMethodInfo(i, &info)))
    1:                         SetReflectable(i, XPCConvert::IsMethodReflectable(*info));
    1:                     else
    1:                     {
    1:                         delete [] mDescriptors;
    1:                         mDescriptors = nsnull;
    1:                         break;
    1:                     }
    1:                 }
    1:             }
    1:         }
    1:         else
    1:         {
    1:             mDescriptors = &zero_methods_descriptor;
    1:         }
    1:     }
    1: }
    1: 
    1: nsXPCWrappedJSClass::~nsXPCWrappedJSClass()
    1: {
    1:     if(mDescriptors && mDescriptors != &zero_methods_descriptor)
    1:         delete [] mDescriptors;
    1:     if(mRuntime)
    1:     {   // scoped lock
    1:         XPCAutoLock lock(mRuntime->GetMapLock());
    1:         mRuntime->GetWrappedJSClassMap()->Remove(this);
    1:     }
    1:     if(mName)
    1:         nsMemory::Free(mName);
    1:     NS_IF_RELEASE(mInfo);
    1: }
    1: 
    1: JSObject*
    1: nsXPCWrappedJSClass::CallQueryInterfaceOnJSObject(XPCCallContext& ccx,
    1:                                                   JSObject* jsobj,
    1:                                                   REFNSIID aIID)
    1: {
    1:     JSContext* cx = ccx.GetJSContext();
    1:     JSObject* id;
    1:     jsval retval;
    1:     JSObject* retObj;
    1:     JSBool success = JS_FALSE;
    1:     jsid funid;
    1:     jsval fun;
    1: 
30623:     // Don't call the actual function on a content object. We'll determine
30623:     // whether or not a content object is capable of implementing the
30623:     // interface (i.e. whether the interface is scriptable) and most content
30623:     // objects don't have QI implementations anyway. Also see bug 503926.
31651:     if(XPCPerThreadData::IsMainThread(ccx) &&
61451:        !xpc::AccessCheck::isChrome(jsobj->compartment()))
30623:     {
30623:         return nsnull;
30623:     }
30623: 
61765:     // OK, it looks like we'll be calling into JS code.
61765:     AutoScriptEvaluate scriptEval(cx);
61765: 
61765:     // XXX we should install an error reporter that will send reports to
61765:     // the JS error console service.
61765:     if (!scriptEval.StartEvaluating(jsobj))
61765:         return nsnull;
61765: 
    1:     // check upfront for the existence of the function property
    1:     funid = mRuntime->GetStringID(XPCJSRuntime::IDX_QUERY_INTERFACE);
26167:     if(!JS_GetPropertyById(cx, jsobj, funid, &fun) || JSVAL_IS_PRIMITIVE(fun))
    1:         return nsnull;
    1: 
    1:     // protect fun so that we're sure it's alive when we call it
    1:     AUTO_MARK_JSVAL(ccx, fun);
    1: 
    1:     // Ensure that we are asking for a scriptable interface.
    1:     // NB:  It's important for security that this check is here rather
    1:     // than later, since it prevents untrusted objects from implementing
    1:     // some interfaces in JS and aggregating a trusted object to
    1:     // implement intentionally (for security) unscriptable interfaces.
    1:     // We so often ask for nsISupports that we can short-circuit the test...
    1:     if(!aIID.Equals(NS_GET_IID(nsISupports)))
    1:     {
    1:         nsCOMPtr<nsIInterfaceInfo> info;
    1:         ccx.GetXPConnect()->GetInfoForIID(&aIID, getter_AddRefs(info));
    1:         if(!info)
    1:             return nsnull;
    1:         PRBool canScript;
    1:         if(NS_FAILED(info->IsScriptable(&canScript)) || !canScript)
    1:             return nsnull;
    1:     }
    1: 
    1:     id = xpc_NewIDObject(cx, jsobj, aIID);
    1:     if(id)
    1:     {
21852:         // Throwing NS_NOINTERFACE is the prescribed way to fail QI from JS. It
21852:         // is not an exception that is ever worth reporting, but we don't want
21852:         // to eat all exceptions either.
21852: 
21852:         uint32 oldOpts =
21852:           JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_DONT_REPORT_UNCAUGHT);
21852: 
    1:         jsval args[1] = {OBJECT_TO_JSVAL(id)};
    1:         success = JS_CallFunctionValue(cx, jsobj, fun, 1, args, &retval);
21852: 
22041:         JS_SetOptions(cx, oldOpts);
22041: 
21852:         if(!success)
21852:         {
21852:             NS_ASSERTION(JS_IsExceptionPending(cx),
21852:                          "JS failed without setting an exception!");
21852: 
22475:             jsval jsexception = JSVAL_NULL;
22475:             AUTO_MARK_JSVAL(ccx, &jsexception);
21852: 
22041:             if(JS_GetPendingException(cx, &jsexception))
21852:             {
22041:                 nsresult rv;
22041:                 if(JSVAL_IS_OBJECT(jsexception))
22041:                 {
22041:                     // XPConnect may have constructed an object to represent a
22041:                     // C++ QI failure. See if that is the case.
21852:                     nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
21852: 
21852:                     nsXPConnect::GetXPConnect()->
21852:                         GetWrappedNativeOfJSObject(ccx,
21852:                                                    JSVAL_TO_OBJECT(jsexception),
21852:                                                    getter_AddRefs(wrapper));
21852: 
21852:                     if(wrapper)
21852:                     {
21852:                         nsCOMPtr<nsIException> exception =
21852:                             do_QueryWrappedNative(wrapper);
22041:                         if(exception &&
22041:                            NS_SUCCEEDED(exception->GetResult(&rv)) &&
21852:                            rv == NS_NOINTERFACE)
21852:                         {
21852:                             JS_ClearPendingException(cx);
21852:                         }
21852:                     }
21852:                 }
22041:                 else if(JSVAL_IS_NUMBER(jsexception))
22041:                 {
22041:                     // JS often throws an nsresult.
22041:                     if(JSVAL_IS_DOUBLE(jsexception))
48470:                         rv = (nsresult)(JSVAL_TO_DOUBLE(jsexception));
22041:                     else
22041:                         rv = (nsresult)(JSVAL_TO_INT(jsexception));
21852: 
22041:                     if(rv == NS_NOINTERFACE)
22041:                         JS_ClearPendingException(cx);
22041:                 }
22041:             }
22041: 
22041:             // Don't report if reporting was disabled by someone else.
22041:             if(!(oldOpts & JSOPTION_DONT_REPORT_UNCAUGHT))
21852:                 JS_ReportPendingException(cx);
21852:         }
    1:     }
    1: 
    1:     if(success)
    1:         success = JS_ValueToObject(cx, retval, &retObj);
    1: 
    1:     return success ? retObj : nsnull;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: static JSBool 
    1: GetNamedPropertyAsVariantRaw(XPCCallContext& ccx, 
    1:                              JSObject* aJSObj,
    1:                              jsid aName, 
    1:                              nsIVariant** aResult,
    1:                              nsresult* pErr)
    1: {
    1:     nsXPTType type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));
    1:     jsval val;
    1: 
26167:     return JS_GetPropertyById(ccx, aJSObj, aName, &val) &&
    1:            XPCConvert::JSData2Native(ccx, aResult, val, type, JS_FALSE, 
    1:                                      &NS_GET_IID(nsIVariant), pErr);
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsXPCWrappedJSClass::GetNamedPropertyAsVariant(XPCCallContext& ccx, 
    1:                                                JSObject* aJSObj,
    1:                                                jsval aName, 
    1:                                                nsIVariant** aResult)
    1: {
    1:     JSContext* cx = ccx.GetJSContext();
    1:     JSBool ok;
    1:     jsid id;
    1:     nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:     AutoScriptEvaluate scriptEval(cx);
61765:     if (!scriptEval.StartEvaluating(aJSObj))
61765:         return NS_ERROR_FAILURE;
    1: 
    1:     ok = JS_ValueToId(cx, aName, &id) && 
    1:          GetNamedPropertyAsVariantRaw(ccx, aJSObj, id, aResult, &rv);
    1: 
    1:     return ok ? NS_OK : NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // static 
    1: nsresult 
    1: nsXPCWrappedJSClass::BuildPropertyEnumerator(XPCCallContext& ccx,
    1:                                              JSObject* aJSObj,
    1:                                              nsISimpleEnumerator** aEnumerate)
    1: {
    1:     JSContext* cx = ccx.GetJSContext();
    1:     nsresult retval = NS_ERROR_FAILURE;
    1:     JSIdArray* idArray = nsnull;
    1:     int i;
    1: 
    1:     // Saved state must be restored, all exits through 'out'...
    1:     AutoScriptEvaluate scriptEval(cx);
61765:     if (!scriptEval.StartEvaluating(aJSObj))
61765:         return NS_ERROR_FAILURE;
    1: 
    1:     idArray = JS_Enumerate(cx, aJSObj);
    1:     if(!idArray)
27611:         return retval;
    1:     
27611:     nsCOMArray<nsIProperty> propertyArray(idArray->length);
    1:     for(i = 0; i < idArray->length; i++)
    1:     {
    1:         nsCOMPtr<nsIVariant> value;
    1:         jsid idName = idArray->vector[i];
    1:         nsresult rv;
    1: 
    1:         if(!GetNamedPropertyAsVariantRaw(ccx, aJSObj, idName, 
    1:                                          getter_AddRefs(value), &rv))
    1:         {
    1:             if(NS_FAILED(rv))
    1:                 retval = rv;                                        
    1:             goto out;
    1:         }
    1: 
    1:         jsval jsvalName;
    1:         if(!JS_IdToValue(cx, idName, &jsvalName))
    1:             goto out;
    1: 
    1:         JSString* name = JS_ValueToString(cx, jsvalName);
    1:         if(!name)
    1:             goto out;
    1: 
59889:         size_t length;
59889:         const jschar *chars = JS_GetStringCharsAndLength(cx, name, &length);
59889:         if (!chars)
59889:             goto out;
59889: 
    1:         nsCOMPtr<nsIProperty> property = 
59889:             new xpcProperty(chars, (PRUint32) length, value);
    1:         if(!property)
    1:             goto out;
    1: 
27611:         if(!propertyArray.AppendObject(property))
    1:             goto out;
    1:     }
    1: 
27611:     retval = NS_NewArrayEnumerator(aEnumerate, propertyArray);
    1: 
    1: out:
    1:     JS_DestroyIdArray(cx, idArray);
    1: 
    1:     return retval;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: NS_IMPL_ISUPPORTS1(xpcProperty, nsIProperty)
    1: 
    1: xpcProperty::xpcProperty(const PRUnichar* aName, PRUint32 aNameLen, 
    1:                          nsIVariant* aValue)
    1:     : mName(aName, aNameLen), mValue(aValue)
    1: {
    1: }
    1: 
    1: /* readonly attribute AString name; */
    1: NS_IMETHODIMP xpcProperty::GetName(nsAString & aName)
    1: {
    1:     aName.Assign(mName);
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIVariant value; */
    1: NS_IMETHODIMP xpcProperty::GetValue(nsIVariant * *aValue)
    1: {
    1:     NS_ADDREF(*aValue = mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: /***************************************************************************/
    1: // This 'WrappedJSIdentity' class and singleton allow us to figure out if
    1: // any given nsISupports* is implemented by a WrappedJS object. This is done
    1: // using a QueryInterface call on the interface pointer with our ID. If
    1: // that call returns NS_OK and the pointer is to our singleton, then the
    1: // interface must be implemented by a WrappedJS object. NOTE: the
    1: // 'WrappedJSIdentity' object is not a real XPCOM object and should not be
    1: // used for anything else (hence it is declared in this implementation file).
    1: 
    1: // {5C5C3BB0-A9BA-11d2-BA64-00805F8A5DD7}
    1: #define NS_IXPCONNECT_WRAPPED_JS_IDENTITY_CLASS_IID \
    1: { 0x5c5c3bb0, 0xa9ba, 0x11d2,                       \
    1:   { 0xba, 0x64, 0x0, 0x80, 0x5f, 0x8a, 0x5d, 0xd7 } }
    1: 
    1: class WrappedJSIdentity
    1: {
    1:     // no instance methods...
    1: public:
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_IXPCONNECT_WRAPPED_JS_IDENTITY_CLASS_IID)
    1: 
    1:     static void* GetSingleton()
    1:     {
    1:         static WrappedJSIdentity* singleton = nsnull;
    1:         if(!singleton)
    1:             singleton = new WrappedJSIdentity();
    1:         return (void*) singleton;
    1:     }
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(WrappedJSIdentity,
    1:                               NS_IXPCONNECT_WRAPPED_JS_IDENTITY_CLASS_IID)
    1: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: JSBool
    1: nsXPCWrappedJSClass::IsWrappedJS(nsISupports* aPtr)
    1: {
    1:     void* result;
    1:     NS_PRECONDITION(aPtr, "null pointer");
    1:     return aPtr &&
    1:            NS_OK == aPtr->QueryInterface(NS_GET_IID(WrappedJSIdentity), &result) &&
    1:            result == WrappedJSIdentity::GetSingleton();
    1: }
    1: 
10291: static JSContext *
10291: GetContextFromObject(JSObject *obj)
10291: {
10857:     // Don't stomp over a running context.
10857:     XPCJSContextStack* stack =
10857:         XPCPerThreadData::GetData(nsnull)->GetJSContextStack();
10857:     JSContext* topJSContext;
10857: 
10857:     if(stack && NS_SUCCEEDED(stack->Peek(&topJSContext)) && topJSContext)
10506:         return nsnull;
10506: 
10291:     // In order to get a context, we need a context.
10291:     XPCCallContext ccx(NATIVE_CALLER);
11973:     if(!ccx.IsValid())
11973:         return nsnull;
55601: 
55601:     JSAutoEnterCompartment ac;
55601:     if(!ac.enter(ccx, obj))
55601:         return nsnull;
10291:     XPCWrappedNativeScope* scope =
10291:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, obj);
10291:     XPCContext *xpcc = scope->GetContext();
10967: 
10967:     if(xpcc)
10967:     {
10967:         JSContext *cx = xpcc->GetJSContext();
10967:         if(cx->thread->id == js_CurrentThreadId())
10967:             return cx;
10967:     }
10967: 
10967:     return nsnull;
10291: }
10291: 
28734: #ifndef XPCONNECT_STANDALONE
28734: class SameOriginCheckedComponent : public nsISecurityCheckedComponent
28734: {
28734: public:
28734:     SameOriginCheckedComponent(nsXPCWrappedJS* delegate)
28734:         : mDelegate(delegate)
28734:     {}
28734: 
28734:     NS_DECL_ISUPPORTS
28734:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
28734: 
28734: private:
28734:     nsRefPtr<nsXPCWrappedJS> mDelegate;
28734: };
28734: 
28734: NS_IMPL_ADDREF(SameOriginCheckedComponent)
28734: NS_IMPL_RELEASE(SameOriginCheckedComponent)
28734: 
28734: NS_INTERFACE_MAP_BEGIN(SameOriginCheckedComponent)
28734:     NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
28734: NS_INTERFACE_MAP_END_AGGREGATED(mDelegate)
28734: 
28734: NS_IMETHODIMP
28734: SameOriginCheckedComponent::CanCreateWrapper(const nsIID * iid,
28734:                                              char **_retval NS_OUTPARAM)
28734: {
28734:     // XXX This doesn't actually work because nsScriptSecurityManager doesn't
28734:     // know what to do with "sameOrigin" for canCreateWrapper.
28734:     *_retval = NS_strdup("sameOrigin");
28734:     return *_retval ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
28734: }
28734: 
28734: NS_IMETHODIMP
28734: SameOriginCheckedComponent::CanCallMethod(const nsIID * iid,
28734:                                           const PRUnichar *methodName,
28734:                                           char **_retval NS_OUTPARAM)
28734: {
28734:     *_retval = NS_strdup("sameOrigin");
28734:     return *_retval ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
28734: }
28734: 
28734: NS_IMETHODIMP
28734: SameOriginCheckedComponent::CanGetProperty(const nsIID * iid,
28734:                                            const PRUnichar *propertyName,
28734:                                            char **_retval NS_OUTPARAM)
28734: {
28734:     *_retval = NS_strdup("sameOrigin");
28734:     return *_retval ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
28734: }
28734: 
28734: NS_IMETHODIMP
28734: SameOriginCheckedComponent::CanSetProperty(const nsIID * iid,
28734:                                            const PRUnichar *propertyName,
28734:                                            char **_retval NS_OUTPARAM)
28734: {
28734:     *_retval = NS_strdup("sameOrigin");
28734:     return *_retval ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
28734: }
28734: 
28734: #endif
28734: 
    1: NS_IMETHODIMP
    1: nsXPCWrappedJSClass::DelegatedQueryInterface(nsXPCWrappedJS* self,
    1:                                              REFNSIID aIID,
    1:                                              void** aInstancePtr)
    1: {
    1:     if(aIID.Equals(NS_GET_IID(nsIXPConnectJSObjectHolder)))
    1:     {
    1:         NS_ADDREF(self);
 3233:         *aInstancePtr = (void*) static_cast<nsIXPConnectJSObjectHolder*>(self);
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Objects internal to xpconnect are the only objects that even know *how*
 9633:     // to ask for this iid. And none of them bother refcounting the thing.
    1:     if(aIID.Equals(NS_GET_IID(WrappedJSIdentity)))
    1:     {
    1:         // asking to find out if this is a wrapper object
    1:         *aInstancePtr = WrappedJSIdentity::GetSingleton();
    1:         return NS_OK;
    1:     }
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     // If IDispatch is enabled and we're QI'ing to IDispatch
    1:     if(nsXPConnect::IsIDispatchEnabled() && aIID.Equals(NSID_IDISPATCH))
    1:     {
    1:         return XPCIDispatchExtension::IDispatchQIWrappedJS(self, aInstancePtr);
    1:     }
    1: #endif
    1:     if(aIID.Equals(NS_GET_IID(nsIPropertyBag)))
    1:     {
    1:         // We only want to expose one implementation from our aggregate.
    1:         nsXPCWrappedJS* root = self->GetRootWrapper();
    1: 
    1:         if(!root->IsValid())
    1:         {
    1:             *aInstancePtr = nsnull;
    1:             return NS_NOINTERFACE;
    1:         }
    1: 
    1:         NS_ADDREF(root);
 3233:         *aInstancePtr = (void*) static_cast<nsIPropertyBag*>(root);
    1:         return NS_OK;
    1:     }
    1: 
27646:     // We can't have a cached wrapper.
27646:     if(aIID.Equals(NS_GET_IID(nsWrapperCache)))
27646:     {
27646:         *aInstancePtr = nsnull;
27646:         return NS_NOINTERFACE;
27646:     }
10291: 
10291:     JSContext *context = GetContextFromObject(self->GetJSObject());
10291:     XPCCallContext ccx(NATIVE_CALLER, context);
    1:     if(!ccx.IsValid())
    1:     {
    1:         *aInstancePtr = nsnull;
    1:         return NS_NOINTERFACE;
    1:     }
    1: 
    1:     // We support nsISupportsWeakReference iff the root wrapped JSObject
    1:     // claims to support it in its QueryInterface implementation.
    1:     if(aIID.Equals(NS_GET_IID(nsISupportsWeakReference)))
    1:     {
    1:         // We only want to expose one implementation from our aggregate.
    1:         nsXPCWrappedJS* root = self->GetRootWrapper();
    1: 
    1:         // Fail if JSObject doesn't claim support for nsISupportsWeakReference
    1:         if(!root->IsValid() ||
    1:            !CallQueryInterfaceOnJSObject(ccx, root->GetJSObject(), aIID))
    1:         {
    1:             *aInstancePtr = nsnull;
    1:             return NS_NOINTERFACE;
    1:         }
    1: 
    1:         NS_ADDREF(root);
 3233:         *aInstancePtr = (void*) static_cast<nsISupportsWeakReference*>(root);
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsXPCWrappedJS* sibling;
    1: 
    1:     // Checks for any existing wrapper explicitly constructed for this iid.
    1:     // This includes the current 'self' wrapper. This also deals with the
    1:     // nsISupports case (for which it returns mRoot).
    1:     if(nsnull != (sibling = self->Find(aIID)))
    1:     {
    1:         NS_ADDREF(sibling);
    1:         *aInstancePtr = sibling->GetXPTCStub();
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Check if asking for an interface from which one of our wrappers inherits.
    1:     if(nsnull != (sibling = self->FindInherited(aIID)))
    1:     {
    1:         NS_ADDREF(sibling);
    1:         *aInstancePtr = sibling->GetXPTCStub();
    1:         return NS_OK;
    1:     }
    1: 
    1:     // else we do the more expensive stuff...
    1: 
 2456: #ifndef XPCONNECT_STANDALONE
 2456:     // Before calling out, ensure that we're not about to claim to implement
 2456:     // nsISecurityCheckedComponent for an untrusted object. Doing so causes
 2456:     // problems. See bug 352882.
28734:     // But if this is a content object, then we might be wrapping it for
28734:     // content. If our JS object isn't a double-wrapped object (that is, we
28734:     // don't have XPCWrappedJS(XPCWrappedNative(some C++ object))), then it
28734:     // definitely will not have classinfo (and therefore won't be a DOM
28734:     // object). Since content wants to be able to use these objects (directly
28734:     // or indirectly, see bug 483672), we implement nsISecurityCheckedComponent
28734:     // for them and tell caps that they are also bound by the same origin
28734:     // model.
 2456: 
 2456:     if(aIID.Equals(NS_GET_IID(nsISecurityCheckedComponent)))
 2456:     {
 2456:         // XXX This code checks to see if the given object has chrome (also
 2456:         // known as system) principals. It really wants to do a
 2456:         // UniversalXPConnect type check.
 2456: 
28734:         *aInstancePtr = nsnull;
28734: 
28734:         if(!XPCPerThreadData::IsMainThread(ccx.GetJSContext()))
28734:             return NS_NOINTERFACE;
28734: 
 2456:         nsXPConnect *xpc = nsXPConnect::GetXPConnect();
 2456:         nsCOMPtr<nsIScriptSecurityManager> secMan =
 2456:             do_QueryInterface(xpc->GetDefaultSecurityManager());
 2456:         if(!secMan)
28734:             return NS_NOINTERFACE;
28734: 
28734:         JSObject *selfObj = self->GetJSObject();
28734:         nsCOMPtr<nsIPrincipal> objPrin;
28734:         nsresult rv = secMan->GetObjectPrincipal(ccx, selfObj,
28734:                                                  getter_AddRefs(objPrin));
28734:         if(NS_FAILED(rv))
28734:             return rv;
28734: 
28734:         PRBool isSystem;
28734:         rv = secMan->IsSystemPrincipal(objPrin, &isSystem);
28734:         if((NS_FAILED(rv) || !isSystem) &&
40410:            !IS_WRAPPER_CLASS(selfObj->getClass()))
28714:         {
28734:             // A content object.
28734:             nsRefPtr<SameOriginCheckedComponent> checked =
28734:                 new SameOriginCheckedComponent(self);
28734:             if(!checked)
28734:                 return NS_ERROR_OUT_OF_MEMORY;
28734:             *aInstancePtr = checked.forget().get();
28734:             return NS_OK;
 2456:         }
 2456:     }
 2456: #endif
 2456: 
    1:     // check if the JSObject claims to implement this interface
    1:     JSObject* jsobj = CallQueryInterfaceOnJSObject(ccx, self->GetJSObject(),
    1:                                                    aIID);
    1:     if(jsobj)
    1:     {
    1:         // protect jsobj until it is actually attached
    1:         AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(jsobj));
    1: 
    1:         // We can't use XPConvert::JSObject2NativeInterface() here
    1:         // since that can find a XPCWrappedNative directly on the
    1:         // proto chain, and we don't want that here. We need to find
    1:         // the actual JS object that claimed it supports the interface
    1:         // we're looking for or we'll potentially bypass security
    1:         // checks etc by calling directly through to a native found on
    1:         // the prototype chain.
    1:         //
    1:         // Instead, simply do the nsXPCWrappedJS part of
    1:         // XPConvert::JSObject2NativeInterface() here to make sure we
    1:         // get a new (or used) nsXPCWrappedJS.
    1:         nsXPCWrappedJS* wrapper;
    1:         nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, jsobj, aIID, nsnull,
    1:                                                    &wrapper);
    1:         if(NS_SUCCEEDED(rv) && wrapper)
    1:         {
    1:             // We need to go through the QueryInterface logic to make
    1:             // this return the right thing for the various 'special'
    1:             // interfaces; e.g.  nsIPropertyBag.
    1:             rv = wrapper->QueryInterface(aIID, aInstancePtr);
    1:             NS_RELEASE(wrapper);
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     // else...
    1:     // no can do
    1:     *aInstancePtr = nsnull;
    1:     return NS_NOINTERFACE;
    1: }
    1: 
    1: JSObject*
    1: nsXPCWrappedJSClass::GetRootJSObject(XPCCallContext& ccx, JSObject* aJSObj)
    1: {
    1:     JSObject* result = CallQueryInterfaceOnJSObject(ccx, aJSObj,
    1:                                                     NS_GET_IID(nsISupports));
27664:     if(!result)
27664:         return aJSObj;
27664:     JSObject* inner = XPCWrapper::Unwrap(ccx, result);
27664:     if (inner)
27664:         return inner;
27664:     return result;
    1: }
    1: 
18907: void
    1: xpcWrappedJSErrorReporter(JSContext *cx, const char *message,
    1:                           JSErrorReport *report)
    1: {
    1:     if(report)
    1:     {
    1:         // If it is an exception report, then we can just deal with the
    1:         // exception later (if not caught in the JS code).
    1:         if(JSREPORT_IS_EXCEPTION(report->flags))
    1:         {
    1:             // XXX We have a problem with error reports from uncaught exceptions.
    1:             //
    1:             // http://bugzilla.mozilla.org/show_bug.cgi?id=66453
    1:             //
    1:             // The issue is...
    1:             //
    1:             // We can't assume that the exception will *stay* uncaught. So, if
    1:             // we build an nsIXPCException here and the underlying exception
    1:             // really is caught before our script is done running then we blow
    1:             // it by returning failure to our caller when the script didn't
    1:             // really fail. However, This report contains error location info
    1:             // that is no longer available after the script is done. So, if the
    1:             // exception really is not caught (and is a non-engine exception)
    1:             // then we've lost the oportunity to capture the script location
    1:             // info that we *could* have captured here.
    1:             //
    1:             // This is expecially an issue with nested evaluations.
    1:             //
    1:             // Perhaps we could capture an expception here and store it as
    1:             // 'provisional' and then later if there is a pending exception
    1:             // when the script is done then we could maybe compare that in some
    1:             // way with the 'provisional' one in which we captured location info.
    1:             // We would not want to assume that the one discovered here is the
    1:             // same one that is later detected. This could cause us to lie.
    1:             //
    1:             // The thing is. we do not currently store the right stuff to compare
    1:             // these two nsIXPCExceptions (triggered by the same exception jsval
    1:             // in the engine). Maybe we should store the jsval and compare that?
    1:             // Maybe without even rooting it since we will not dereference it.
    1:             // This is inexact, but maybe the right thing to do?
    1:             //
    1:             // if(report->errorNumber == JSMSG_UNCAUGHT_EXCEPTION)) ...
    1:             //
    1: 
    1:             return;
    1:         }
    1: 
    1:         if(JSREPORT_IS_WARNING(report->flags))
    1:         {
    1:             // XXX printf the warning (#ifdef DEBUG only!).
    1:             // XXX send the warning to the console service.
    1:             return;
    1:         }
    1:     }
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1:     if(!ccx.IsValid())
    1:         return;
    1: 
    1:     nsCOMPtr<nsIException> e;
    1:     XPCConvert::JSErrorToXPCException(ccx, message, nsnull, nsnull, report,
    1:                                       getter_AddRefs(e));
    1:     if(e)
    1:         ccx.GetXPCContext()->SetException(e);
    1: }
    1: 
    1: JSBool
    1: nsXPCWrappedJSClass::GetArraySizeFromParam(JSContext* cx,
    1:                                            const XPTMethodDescriptor* method,
    1:                                            const nsXPTParamInfo& param,
    1:                                            uint16 methodIndex,
    1:                                            uint8 paramIndex,
    1:                                            SizeMode mode,
    1:                                            nsXPTCMiniVariant* nativeParams,
    1:                                            JSUint32* result)
    1: {
    1:     uint8 argnum;
    1:     nsresult rv;
    1: 
    1:     if(mode == GET_SIZE)
    1:         rv = mInfo->GetSizeIsArgNumberForParam(methodIndex, &param, 0, &argnum);
    1:     else
    1:         rv = mInfo->GetLengthIsArgNumberForParam(methodIndex, &param, 0, &argnum);
    1:     if(NS_FAILED(rv))
    1:         return JS_FALSE;
    1: 
    1:     const nsXPTParamInfo& arg_param = method->params[argnum];
    1:     const nsXPTType& arg_type = arg_param.GetType();
    1: 
    1:     // The xpidl compiler ensures this. We reaffirm it for safety.
    1:     if(arg_type.IsPointer() || arg_type.TagPart() != nsXPTType::T_U32)
    1:         return JS_FALSE;
    1: 
    1:     if(arg_param.IsOut())
    1:         *result = *(JSUint32*)nativeParams[argnum].val.p;
    1:     else
    1:         *result = nativeParams[argnum].val.u32;
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: nsXPCWrappedJSClass::GetInterfaceTypeFromParam(JSContext* cx,
    1:                                                const XPTMethodDescriptor* method,
    1:                                                const nsXPTParamInfo& param,
    1:                                                uint16 methodIndex,
    1:                                                const nsXPTType& type,
    1:                                                nsXPTCMiniVariant* nativeParams,
    1:                                                nsID* result)
    1: {
    1:     uint8 type_tag = type.TagPart();
    1: 
    1:     if(type_tag == nsXPTType::T_INTERFACE)
    1:     {
    1:         if(NS_SUCCEEDED(GetInterfaceInfo()->
    1:                 GetIIDForParamNoAlloc(methodIndex, &param, result)))
    1:         {
    1:             return JS_TRUE;
    1:         }
    1:     }
    1:     else if(type_tag == nsXPTType::T_INTERFACE_IS)
    1:     {
    1:         uint8 argnum;
    1:         nsresult rv;
    1:         rv = mInfo->GetInterfaceIsArgNumberForParam(methodIndex,
    1:                                                     &param, &argnum);
    1:         if(NS_FAILED(rv))
    1:             return JS_FALSE;
    1: 
    1:         const nsXPTParamInfo& arg_param = method->params[argnum];
    1:         const nsXPTType& arg_type = arg_param.GetType();
    1:         if(arg_type.IsPointer() &&
    1:            arg_type.TagPart() == nsXPTType::T_IID)
    1:         {
    1:             if(arg_param.IsOut())
    1:             {
    1:                 nsID** p = (nsID**) nativeParams[argnum].val.p;
    1:                 if(!p || !*p)
    1:                     return JS_FALSE;
    1:                 *result = **p;
    1:             }
    1:             else
    1:             {
    1:                 nsID* p = (nsID*) nativeParams[argnum].val.p;
    1:                 if(!p)
    1:                     return JS_FALSE;
    1:                 *result = *p;
    1:             }
    1:             return JS_TRUE;
    1:         }
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: void
    1: nsXPCWrappedJSClass::CleanupPointerArray(const nsXPTType& datum_type,
    1:                                          JSUint32 array_count,
    1:                                          void** arrayp)
    1: {
    1:     if(datum_type.IsInterfacePointer())
    1:     {
    1:         nsISupports** pp = (nsISupports**) arrayp;
    1:         for(JSUint32 k = 0; k < array_count; k++)
    1:         {
    1:             nsISupports* p = pp[k];
    1:             NS_IF_RELEASE(p);
    1:         }
    1:     }
    1:     else
    1:     {
    1:         void** pp = (void**) arrayp;
    1:         for(JSUint32 k = 0; k < array_count; k++)
    1:         {
    1:             void* p = pp[k];
    1:             if(p) nsMemory::Free(p);
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsXPCWrappedJSClass::CleanupPointerTypeObject(const nsXPTType& type,
    1:                                               void** pp)
    1: {
    1:     NS_ASSERTION(pp,"null pointer");
    1:     if(type.IsInterfacePointer())
    1:     {
    1:         nsISupports* p = *((nsISupports**)pp);
    1:         if(p) p->Release();
    1:     }
    1:     else
    1:     {
    1:         void* p = *((void**)pp);
    1:         if(p) nsMemory::Free(p);
    1:     }
    1: }
    1: 
20343: class AutoClearPendingException
20343: {
20343: public:
20343:   AutoClearPendingException(JSContext *cx) : mCx(cx) { }
20343:   ~AutoClearPendingException() { JS_ClearPendingException(mCx); }
20343: private:
20343:   JSContext* mCx;
20343: };
20343: 
    1: nsresult
    1: nsXPCWrappedJSClass::CheckForException(XPCCallContext & ccx,
    1:                                        const char * aPropertyName,
14170:                                        const char * anInterfaceName,
14170:                                        PRBool aForceReport)
    1: {
    1:     XPCContext * xpcc = ccx.GetXPCContext();
    1:     JSContext * cx = ccx.GetJSContext();
    1:     nsCOMPtr<nsIException> xpc_exception;
    1:     /* this one would be set by our error reporter */
    1: 
    1:     xpcc->GetException(getter_AddRefs(xpc_exception));
    1:     if(xpc_exception)
    1:         xpcc->SetException(nsnull);
    1: 
    1:     // get this right away in case we do something below to cause JS code
    1:     // to run on this JSContext
    1:     nsresult pending_result = xpcc->GetPendingResult();
    1: 
    1:     jsval js_exception;
20343:     JSBool is_js_exception = JS_GetPendingException(cx, &js_exception);
20343: 
    1:     /* JS might throw an expection whether the reporter was called or not */
20343:     if(is_js_exception)
    1:     {
    1:         if(!xpc_exception)
    1:             XPCConvert::JSValToXPCException(ccx, js_exception, anInterfaceName,
14170:                                             aPropertyName,
14170:                                             getter_AddRefs(xpc_exception));
    1: 
    1:         /* cleanup and set failed even if we can't build an exception */
    1:         if(!xpc_exception)
    1:         {
    1:             ccx.GetThreadData()->SetException(nsnull); // XXX necessary?
    1:         }
    1:     }
    1: 
20343:     AutoClearPendingException acpe(cx);
20343: 
    1:     if(xpc_exception)
    1:     {
    1:         nsresult e_result;
    1:         if(NS_SUCCEEDED(xpc_exception->GetResult(&e_result)))
    1:         {
14170:             // Figure out whether or not we should report this exception.
14170:             PRBool reportable = xpc_IsReportableErrorCode(e_result);
14170:             if(reportable)
14170:             {
14170:                 // Always want to report forced exceptions and XPConnect's own
14170:                 // errors.
14170:                 reportable = aForceReport ||
14170:                     NS_ERROR_GET_MODULE(e_result) == NS_ERROR_MODULE_XPCONNECT;
14170: 
14170:                 // See if an environment variable was set or someone has told us
14170:                 // that a user pref was set indicating that we should report all
14170:                 // exceptions.
14170:                 if(!reportable)
14170:                     reportable = nsXPConnect::ReportAllJSExceptions();
14170: 
14170:                 // Finally, check to see if this is the last JS frame on the
14170:                 // stack. If so then we always want to report it.
14170:                 if(!reportable)
14170:                 {
14170:                     PRBool onlyNativeStackFrames = PR_TRUE;
14170:                     JSStackFrame * fp = nsnull;
14170:                     while((fp = JS_FrameIterator(cx, &fp)))
14170:                     {
53557:                         if(JS_IsScriptFrame(cx, fp))
14170:                         {
14170:                             onlyNativeStackFrames = PR_FALSE;
14170:                             break;
14170:                         }
14170:                     }
14170:                     reportable = onlyNativeStackFrames;
14170:                 }
14170:                 
14170:                 // Ugly special case for GetInterface. It's "special" in the
14170:                 // same way as QueryInterface in that a failure is not
14170:                 // exceptional and shouldn't be reported. We have to do this
14170:                 // check here instead of in xpcwrappedjs (like we do for QI) to
14170:                 // avoid adding extra code to all xpcwrappedjs objects.
14170:                 if(reportable && e_result == NS_ERROR_NO_INTERFACE &&
14170:                    !strcmp(anInterfaceName, "nsIInterfaceRequestor") &&
14170:                    !strcmp(aPropertyName, "getInterface"))
14170:                 {
14170:                     reportable = PR_FALSE;
14170:                 }
14170:             }
14170: 
20343:             // Try to use the error reporter set on the context to handle this
20343:             // error if it came from a JS exception.
20343:             if(reportable && is_js_exception &&
20343:                cx->errorReporter != xpcWrappedJSErrorReporter)
20343:             {
20343:                 reportable = !JS_ReportPendingException(cx);
20343:             }
20343: 
14170:             if(reportable)
    1:             {
    1: #ifdef DEBUG
    1:                 static const char line[] =
    1:                     "************************************************************\n";
    1:                 static const char preamble[] =
    1:                     "* Call to xpconnect wrapped JSObject produced this error:  *\n";
    1:                 static const char cant_get_text[] =
    1:                     "FAILED TO GET TEXT FROM EXCEPTION\n";
    1: 
    1:                 fputs(line, stdout);
    1:                 fputs(preamble, stdout);
    1:                 char* text;
    1:                 if(NS_SUCCEEDED(xpc_exception->ToString(&text)) && text)
    1:                 {
    1:                     fputs(text, stdout);
    1:                     fputs("\n", stdout);
    1:                     nsMemory::Free(text);
    1:                 }
    1:                 else
    1:                     fputs(cant_get_text, stdout);
    1:                 fputs(line, stdout);
    1: #endif
    1: 
    1:                 // Log the exception to the JS Console, so that users can do
    1:                 // something with it.
    1:                 nsCOMPtr<nsIConsoleService> consoleService
    1:                     (do_GetService(XPC_CONSOLE_CONTRACTID));
    1:                 if(nsnull != consoleService)
    1:                 {
    1:                     nsresult rv;
    1:                     nsCOMPtr<nsIScriptError> scriptError;
    1:                     nsCOMPtr<nsISupports> errorData;
    1:                     rv = xpc_exception->GetData(getter_AddRefs(errorData));
    1:                     if(NS_SUCCEEDED(rv))
    1:                         scriptError = do_QueryInterface(errorData);
    1: 
    1:                     if(nsnull == scriptError)
    1:                     {
    1:                         // No luck getting one from the exception, so
    1:                         // try to cook one up.
    1:                         scriptError = do_CreateInstance(XPC_SCRIPT_ERROR_CONTRACTID);
    1:                         if(nsnull != scriptError)
    1:                         {
    1:                             char* exn_string;
    1:                             rv = xpc_exception->ToString(&exn_string);
    1:                             if(NS_SUCCEEDED(rv))
    1:                             {
    1:                                 // use toString on the exception as the message
    1:                                 nsAutoString newMessage;
    1:                                 newMessage.AssignWithConversion(exn_string);
    1:                                 nsMemory::Free((void *) exn_string);
    1: 
    1:                                 // try to get filename, lineno from the first
    1:                                 // stack frame location.
    1:                                 PRInt32 lineNumber = 0;
    1:                                 nsXPIDLCString sourceName;
    1: 
    1:                                 nsCOMPtr<nsIStackFrame> location;
    1:                                 xpc_exception->
    1:                                     GetLocation(getter_AddRefs(location));
    1:                                 if(location)
    1:                                 {
    1:                                     // Get line number w/o checking; 0 is ok.
    1:                                     location->GetLineNumber(&lineNumber);
    1: 
    1:                                     // get a filename.
    1:                                     rv = location->GetFilename(getter_Copies(sourceName));
    1:                                 }
    1: 
59512:                                 nsCOMPtr<nsIScriptError2> scriptError2 =
59512:                                     do_QueryInterface(scriptError);
59512:                                 rv = scriptError2->InitWithWindowID(newMessage.get(),
    1:                                                                     NS_ConvertASCIItoUTF16(sourceName).get(),
    1:                                                                     nsnull,
    1:                                                                     lineNumber, 0, 0,
59512:                                                                     "XPConnect JavaScript",
59512:                                                                     nsJSUtils::GetCurrentlyRunningCodeWindowID(cx));
    1:                                 if(NS_FAILED(rv))
    1:                                     scriptError = nsnull;
    1:                             }
    1:                         }
    1:                     }
    1:                     if(nsnull != scriptError)
    1:                         consoleService->LogMessage(scriptError);
    1:                 }
    1:             }
    1:             // Whether or not it passes the 'reportable' test, it might
    1:             // still be an error and we have to do the right thing here...
    1:             if(NS_FAILED(e_result))
    1:             {
    1:                 ccx.GetThreadData()->SetException(xpc_exception);
    1:                 return e_result;
    1:             }
    1:         }
    1:     }
    1:     else
    1:     {
    1:         // see if JS code signaled failure result without throwing exception
    1:         if(NS_FAILED(pending_result))
    1:         {
    1:             return pending_result;
    1:         }
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
42714: class ContextPrincipalGuard
42714: {
42714:     nsIScriptSecurityManager *ssm;
42714:     XPCCallContext &ccx;
42714:   public:
42714:     ContextPrincipalGuard(XPCCallContext &ccx)
42714:       : ssm(nsnull), ccx(ccx) {}
42714:     void principalPushed(nsIScriptSecurityManager *ssm) { this->ssm = ssm; }
42714:     ~ContextPrincipalGuard() { if (ssm) ssm->PopContextPrincipal(ccx); }
42714: };
42714: 
    1: NS_IMETHODIMP
    1: nsXPCWrappedJSClass::CallMethod(nsXPCWrappedJS* wrapper, uint16 methodIndex,
    1:                                 const XPTMethodDescriptor* info,
    1:                                 nsXPTCMiniVariant* nativeParams)
    1: {
    1:     jsval* sp = nsnull;
50465:     jsval* argv = nsnull;
    1:     uint8 i;
    1:     uint8 argc=0;
    1:     uint8 paramCount=0;
    1:     nsresult retval = NS_ERROR_FAILURE;
    1:     nsresult pending_result = NS_OK;
    1:     JSBool success;
    1:     JSBool readyToDoTheCall = JS_FALSE;
    1:     nsID  param_iid;
    1:     JSObject* obj;
    1:     const char* name = info->name;
    1:     jsval fval;
    1:     JSBool foundDependentParam;
    1:     XPCContext* xpcc;
    1:     JSContext* cx;
    1:     JSObject* thisObj;
    1: 
    1:     // Make sure not to set the callee on ccx until after we've gone through
    1:     // the whole nsIXPCFunctionThisTranslator bit.  That code uses ccx to
    1:     // convert natives to JSObjects, but we do NOT plan to pass those JSObjects
    1:     // to our real callee.
10291:     JSContext *context = GetContextFromObject(wrapper->GetJSObject());
10291:     XPCCallContext ccx(NATIVE_CALLER, context);
    1:     if(ccx.IsValid())
    1:     {
    1:         xpcc = ccx.GetXPCContext();
    1:         cx = ccx.GetJSContext();
    1:     }
    1:     else
    1:     {
    1:         xpcc = nsnull;
    1:         cx = nsnull;
    1:     }
    1: 
61426:     js::AutoValueVector args(cx);
61247:     AutoScriptEvaluate scriptEval(cx);
42714:     ContextPrincipalGuard principalGuard(ccx);
    1: 
    1:     obj = thisObj = wrapper->GetJSObject();
    1: 
    1:     // XXX ASSUMES that retval is last arg. The xpidl compiler ensures this.
    1:     paramCount = info->num_args;
    1:     argc = paramCount -
    1:         (paramCount && XPT_PD_IS_RETVAL(info->params[paramCount-1].flags) ? 1 : 0);
    1: 
    1:     if(!cx || !xpcc || !IsReflectable(methodIndex))
    1:         goto pre_call_clean_up;
    1: 
61765:     if (!scriptEval.StartEvaluating(obj, xpcWrappedJSErrorReporter))
61765:         goto pre_call_clean_up;
    1: 
    1:     xpcc->SetPendingResult(pending_result);
    1:     xpcc->SetException(nsnull);
    1:     ccx.GetThreadData()->SetException(nsnull);
    1: 
41436:     if(XPCPerThreadData::IsMainThread(ccx))
41436:     {
55604:         // TODO Remove me in favor of security wrappers.
42714:         nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
41436:         if(ssm)
41436:         {
55604:             nsIPrincipal *objPrincipal =
61451:                 xpc::AccessCheck::getPrincipal(obj->compartment());
41436:             if(objPrincipal)
41436:             {
41436:                 JSStackFrame* fp = nsnull;
41436:                 nsresult rv =
41436:                     ssm->PushContextPrincipal(ccx, JS_FrameIterator(ccx, &fp),
41436:                                               objPrincipal);
41436:                 if(NS_FAILED(rv))
41436:                 {
41436:                     JS_ReportOutOfMemory(ccx);
41436:                     retval = NS_ERROR_OUT_OF_MEMORY;
41436:                     goto pre_call_clean_up;
41436:                 }
41436: 
42714:                 principalGuard.principalPushed(ssm);
41436:             }
41436:         }
41436:     }
41436: 
42714:     // We use js_Invoke so that the gcthings we use as args will be rooted by
42714:     // the engine as we do conversions and prepare to do the function call.
    1: 
37741:     js::LeaveTrace(cx);
25214: 
    1:     // setup stack
    1: 
    1:     // if this isn't a function call then we don't need to push extra stuff
50465:     if (!(XPT_MD_IS_SETTER(info->flags) || XPT_MD_IS_GETTER(info->flags)))
    1:     {
    1:         // We get fval before allocating the stack to avoid gc badness that can
    1:         // happen if the GetProperty call leaves our request and the gc runs
    1:         // while the stack we allocate contains garbage.
    1: 
    1:         // If the interface is marked as a [function] then we will assume that
    1:         // our JSObject is a function and not an object with a named method.
    1: 
    1:         PRBool isFunction;
    1:         if(NS_FAILED(mInfo->IsFunction(&isFunction)))
    1:             goto pre_call_clean_up;
    1: 
    1:         // In the xpidl [function] case we are making sure now that the 
    1:         // JSObject is callable. If it is *not* callable then we silently 
    1:         // fallback to looking up the named property...
    1:         // (because jst says he thinks this fallback is 'The Right Thing'.)
    1:         //
    1:         // In the normal (non-function) case we just lookup the property by 
    1:         // name and as long as the object has such a named property we go ahead
    1:         // and try to make the call. If it turns out the named property is not
    1:         // a callable object then the JS engine will throw an error and we'll
    1:         // pass this along to the caller as an exception/result code.
    1: 
    1:         if(isFunction && 
    1:            JS_TypeOfValue(ccx, OBJECT_TO_JSVAL(obj)) == JSTYPE_FUNCTION)
    1:         {
    1:             fval = OBJECT_TO_JSVAL(obj);
    1: 
    1:             // We may need to translate the 'this' for the function object.
    1: 
    1:             if(paramCount)
    1:             {
    1:                 const nsXPTParamInfo& firstParam = info->params[0];
    1:                 if(firstParam.IsIn())
    1:                 {
    1:                     const nsXPTType& firstType = firstParam.GetType();
    1:                     if(firstType.IsPointer() && firstType.IsInterfacePointer())
    1:                     {
    1:                         nsIXPCFunctionThisTranslator* translator;
    1: 
    1:                         IID2ThisTranslatorMap* map =
    1:                             mRuntime->GetThisTranslatorMap();
    1: 
    1:                         {
    1:                             XPCAutoLock lock(mRuntime->GetMapLock()); // scoped lock
    1:                             translator = map->Find(mIID);
    1:                         }
    1: 
    1:                         if(translator)
    1:                         {
    1:                             PRBool hideFirstParamFromJS = PR_FALSE;
    1:                             nsIID* newWrapperIID = nsnull;
    1:                             nsCOMPtr<nsISupports> newThis;
    1: 
    1:                             if(NS_FAILED(translator->
    1:                               TranslateThis((nsISupports*)nativeParams[0].val.p,
    1:                                             mInfo, methodIndex,
    1:                                             &hideFirstParamFromJS,
    1:                                             &newWrapperIID,
    1:                                             getter_AddRefs(newThis))))
    1:                             {
    1:                                 goto pre_call_clean_up;
    1:                             }
    1:                             if(hideFirstParamFromJS)
    1:                             {
    1:                                 NS_ERROR("HideFirstParamFromJS not supported");
    1:                                 goto pre_call_clean_up;
    1:                             }
    1:                             if(newThis)
    1:                             {
22841:                                 jsval v;
51515:                                 xpcObjectHelper helper(newThis);
    1:                                 JSBool ok =
    1:                                   XPCConvert::NativeInterface2JSObject(ccx,
51515:                                         &v, nsnull, helper, newWrapperIID,
51515:                                         nsnull, obj, PR_FALSE, PR_FALSE,
22842:                                         nsnull);
22842:                                 if(newWrapperIID)
    1:                                     nsMemory::Free(newWrapperIID);
22841:                                 if(!ok)
    1:                                 {
    1:                                     goto pre_call_clean_up;
    1:                                 }
22841:                                 thisObj = JSVAL_TO_OBJECT(v);
55946:                                 if(!JS_WrapObject(cx, &thisObj))
55946:                                     goto pre_call_clean_up;
    1:                             }
    1:                         }
    1:                     }
    1:                 }
    1:             }
    1:         }
    1:         else if(!JS_GetMethod(cx, obj, name, &thisObj, &fval))
    1:         {
    1:             // XXX We really want to factor out the error reporting better and
    1:             // specifically report the failure to find a function with this name.
    1:             // This is what we do below if the property is found but is not a
    1:             // function. We just need to factor better so we can get to that
    1:             // reporting path from here.
    1:             goto pre_call_clean_up;
    1:         }
    1:     }
    1: 
50465:     if (!args.resize(argc))
    1:     {
    1:         retval = NS_ERROR_OUT_OF_MEMORY;
    1:         goto pre_call_clean_up;
    1:     }
    1: 
50465:     argv = args.jsval_begin();
50465:     sp = argv;
    1: 
29947:     // Figure out what our callee is
29947:     if(XPT_MD_IS_GETTER(info->flags) || XPT_MD_IS_SETTER(info->flags))
29947:     {
29947:         // Pull the getter or setter off of |obj|
29947:         uintN attrs;
29947:         JSBool found;
29947:         JSPropertyOp getter;
29947:         JSPropertyOp setter;
29947:         if(!JS_GetPropertyAttrsGetterAndSetter(cx, obj, name,
29947:                                                &attrs, &found,
29947:                                                &getter, &setter))
29947:         {
29947:             // XXX Do we want to report this exception?
29947:             JS_ClearPendingException(cx);
29947:             goto pre_call_clean_up;
29947:         }
29947: 
29947:         if(XPT_MD_IS_GETTER(info->flags) && (attrs & JSPROP_GETTER))
29947:         {
29947:             // JSPROP_GETTER means the getter is actually a
29947:             // function object.
29947:             ccx.SetCallee(JS_FUNC_TO_DATA_PTR(JSObject*, getter));
29947:         }
29947:         else if(XPT_MD_IS_SETTER(info->flags) && (attrs & JSPROP_SETTER))
29947:         {
29947:             // JSPROP_SETTER means the setter is actually a
29947:             // function object.
29947:             ccx.SetCallee(JS_FUNC_TO_DATA_PTR(JSObject*, setter));
29947:         }
29947:     }
29947:     else if(JSVAL_IS_OBJECT(fval))
29947:     {
29947:         ccx.SetCallee(JSVAL_TO_OBJECT(fval));
29947:     }
29947: 
    1:     // build the args
55604:     // NB: This assignment *looks* wrong because we haven't yet called our
55604:     // function. However, we *have* already entered the compartmen that we're
55604:     // about to call, and that's the global that we want here. In other words:
55604:     // we're trusting the JS engine to come up with a good global to use for
55604:     // our object (whatever it was).
    1:     for(i = 0; i < argc; i++)
    1:     {
    1:         const nsXPTParamInfo& param = info->params[i];
    1:         const nsXPTType& type = param.GetType();
    1:         nsXPTType datum_type;
    1:         JSUint32 array_count;
    1:         PRBool isArray = type.IsArray();
    1:         jsval val = JSVAL_NULL;
    1:         AUTO_MARK_JSVAL(ccx, &val);
    1:         PRBool isSizedString = isArray ?
    1:                 JS_FALSE :
    1:                 type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS ||
    1:                 type.TagPart() == nsXPTType::T_PWSTRING_SIZE_IS;
    1: 
    1: 
    1:         // verify that null was not passed for 'out' param
    1:         if(param.IsOut() && !nativeParams[i].val.p)
    1:         {
    1:             retval = NS_ERROR_INVALID_ARG;
    1:             goto pre_call_clean_up;
    1:         }
    1: 
    1:         if(isArray)
    1:         {
    1:             if(NS_FAILED(mInfo->GetTypeForParam(methodIndex, &param, 1,
    1:                                                 &datum_type)))
    1:                 goto pre_call_clean_up;
    1:         }
    1:         else
    1:             datum_type = type;
    1: 
    1:         if(param.IsIn())
    1:         {
    1:             nsXPTCMiniVariant* pv;
    1: 
    1:             if(param.IsOut())
    1:                 pv = (nsXPTCMiniVariant*) nativeParams[i].val.p;
    1:             else
    1:                 pv = &nativeParams[i];
    1: 
    1:             if(datum_type.IsInterfacePointer() &&
    1:                !GetInterfaceTypeFromParam(cx, info, param, methodIndex,
    1:                                           datum_type, nativeParams,
    1:                                           &param_iid))
    1:                 goto pre_call_clean_up;
    1: 
    1:             if(isArray || isSizedString)
    1:             {
    1:                 if(!GetArraySizeFromParam(cx, info, param, methodIndex,
    1:                                           i, GET_LENGTH, nativeParams,
    1:                                           &array_count))
    1:                     goto pre_call_clean_up;
    1:             }
    1: 
    1:             if(isArray)
    1:             {
31395:                 XPCLazyCallContext lccx(ccx);
31395:                 if(!XPCConvert::NativeArray2JS(lccx, &val,
31395:                                                (const void**)&pv->val,
    1:                                                datum_type, &param_iid,
55685:                                                array_count, obj, nsnull))
    1:                     goto pre_call_clean_up;
    1:             }
    1:             else if(isSizedString)
    1:             {
    1:                 if(!XPCConvert::NativeStringWithSize2JS(ccx, &val,
    1:                                                (const void*)&pv->val,
    1:                                                datum_type,
    1:                                                array_count, nsnull))
    1:                     goto pre_call_clean_up;
    1:             }
    1:             else
    1:             {
    1:                 if(!XPCConvert::NativeData2JS(ccx, &val, &pv->val, type,
55685:                                               &param_iid, obj, nsnull))
    1:                     goto pre_call_clean_up;
    1:             }
    1:         }
    1: 
36581:         if(param.IsOut() || param.IsDipper())
    1:         {
    1:             // create an 'out' object
55685:             JSObject* out_obj = NewOutObject(cx, obj);
    1:             if(!out_obj)
    1:             {
    1:                 retval = NS_ERROR_OUT_OF_MEMORY;
    1:                 goto pre_call_clean_up;
    1:             }
    1: 
    1:             if(param.IsIn())
    1:             {
26167:                 if(!JS_SetPropertyById(cx, out_obj,
    1:                         mRuntime->GetStringID(XPCJSRuntime::IDX_VALUE),
    1:                         &val))
    1:                 {
    1:                     goto pre_call_clean_up;
    1:                 }
    1:             }
    1:             *sp++ = OBJECT_TO_JSVAL(out_obj);
    1:         }
    1:         else
    1:             *sp++ = val;
    1:     }
    1: 
    1:     readyToDoTheCall = JS_TRUE;
    1: 
    1: pre_call_clean_up:
    1:     // clean up any 'out' params handed in
    1:     for(i = 0; i < paramCount; i++)
    1:     {
    1:         const nsXPTParamInfo& param = info->params[i];
    1:         if(!param.IsOut())
    1:             continue;
    1: 
    1:         const nsXPTType& type = param.GetType();
    1:         if(!type.IsPointer())
    1:             continue;
    1:         void* p;
    1:         if(!(p = nativeParams[i].val.p))
    1:             continue;
    1: 
    1:         if(param.IsIn())
    1:         {
    1:             if(type.IsArray())
    1:             {
    1:                 void** pp;
    1:                 if(nsnull != (pp = *((void***)p)))
    1:                 {
    1: 
    1:                     // we need to get the array length and iterate the items
    1:                     JSUint32 array_count;
    1:                     nsXPTType datum_type;
    1: 
    1:                     if(NS_SUCCEEDED(mInfo->GetTypeForParam(methodIndex, &param,
    1:                                                            1, &datum_type)) &&
    1:                        datum_type.IsPointer() &&
    1:                        GetArraySizeFromParam(cx, info, param, methodIndex,
    1:                                              i, GET_LENGTH, nativeParams,
    1:                                              &array_count) && array_count)
    1:                     {
    1:                         CleanupPointerArray(datum_type, array_count, pp);
    1:                     }
    1:                     // always release the array if it is inout
    1:                     nsMemory::Free(pp);
    1:                 }
    1:             }
    1:             else
    1:                 CleanupPointerTypeObject(type, (void**)p);
    1:         }
    1:         *((void**)p) = nsnull;
    1:     }
    1: 
    1:     // Make sure "this" doesn't get deleted during this call.
    1:     nsCOMPtr<nsIXPCWrappedJSClass> kungFuDeathGrip(this);
    1: 
    1:     if(!readyToDoTheCall)
42714:         return retval;
    1: 
    1:     // do the deed - note exceptions
    1: 
    1:     JS_ClearPendingException(cx);
    1: 
50465:     jsval rval;
    1:     if(XPT_MD_IS_GETTER(info->flags))
50465:     {
50465:         success = JS_GetProperty(cx, obj, name, argv);
50465:         rval = *argv;
50465:     }
    1:     else if(XPT_MD_IS_SETTER(info->flags))
50465:     {
50465:         success = JS_SetProperty(cx, obj, name, argv);
50465:         rval = *argv;
50465:     }
    1:     else
    1:     {
    1:         if(!JSVAL_IS_PRIMITIVE(fval))
    1:         {
50465:             uint32 oldOpts = JS_GetOptions(cx);
50465:             JS_SetOptions(cx, oldOpts | JSOPTION_DONT_REPORT_UNCAUGHT);
50465: 
50465:             success = JS_CallFunctionValue(cx, thisObj, fval, argc, argv, &rval);
50465: 
50465:             JS_SetOptions(cx, oldOpts);
    1:         }
    1:         else
    1:         {
    1:             // The property was not an object so can't be a function.
    1:             // Let's build and 'throw' an exception.
    1: 
    1:             static const nsresult code =
    1:                     NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED;
    1:             static const char format[] = "%s \"%s\"";
    1:             const char * msg;
    1:             char* sz = nsnull;
    1: 
    1:             if(nsXPCException::NameAndFormatForNSResult(code, nsnull, &msg) && msg)
    1:                 sz = JS_smprintf(format, msg, name);
    1: 
    1:             nsCOMPtr<nsIException> e;
    1: 
    1:             XPCConvert::ConstructException(code, sz, GetInterfaceName(), name,
21377:                                            nsnull, getter_AddRefs(e), nsnull, nsnull);
    1:             xpcc->SetException(e);
    1:             if(sz)
    1:                 JS_smprintf_free(sz);
    1:             success = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     if(!success)
    1:     {
14170:         PRBool forceReport;
14170:         if(NS_FAILED(mInfo->IsFunction(&forceReport)))
14170:             forceReport = PR_FALSE;
14170: 
14170:         // May also want to check if we're moving from content->chrome and force
14170:         // a report in that case.
14170: 
42714:         return CheckForException(ccx, name, GetInterfaceName(), forceReport);
    1:     }
    1: 
    1:     ccx.GetThreadData()->SetException(nsnull); // XXX necessary?
    1: 
    1:     // convert out args and result
    1:     // NOTE: this is the total number of native params, not just the args
    1:     // Convert independent params only.
    1:     // When we later convert the dependent params (if any) we will know that
    1:     // the params upon which they depend will have already been converted -
    1:     // regardless of ordering.
    1: 
    1:     foundDependentParam = JS_FALSE;
    1:     for(i = 0; i < paramCount; i++)
    1:     {
    1:         const nsXPTParamInfo& param = info->params[i];
    1:         if(!param.IsOut() && !param.IsDipper())
    1:             continue;
    1: 
    1:         const nsXPTType& type = param.GetType();
    1:         if(type.IsDependent())
    1:         {
    1:             foundDependentParam = JS_TRUE;
    1:             continue;
    1:         }
    1: 
    1:         jsval val;
    1:         uint8 type_tag = type.TagPart();
    1:         JSBool useAllocator = JS_FALSE;
    1:         nsXPTCMiniVariant* pv;
    1: 
    1:         if(param.IsDipper())
    1:             pv = (nsXPTCMiniVariant*) &nativeParams[i].val.p;
    1:         else
    1:             pv = (nsXPTCMiniVariant*) nativeParams[i].val.p;
    1: 
    1:         if(param.IsRetval())
50465:             val = rval;
50465:         else if(JSVAL_IS_PRIMITIVE(argv[i]) ||
50465:                 !JS_GetPropertyById(cx, JSVAL_TO_OBJECT(argv[i]),
    1:                     mRuntime->GetStringID(XPCJSRuntime::IDX_VALUE),
    1:                     &val))
29946:             break;
    1: 
    1:         // setup allocator and/or iid
    1: 
    1:         if(type_tag == nsXPTType::T_INTERFACE)
    1:         {
    1:             if(NS_FAILED(GetInterfaceInfo()->
    1:                             GetIIDForParamNoAlloc(methodIndex, &param,
    1:                                                   &param_iid)))
29946:                 break;
    1:         }
    1:         else if(type.IsPointer() && !param.IsShared() && !param.IsDipper())
    1:             useAllocator = JS_TRUE;
    1: 
    1:         if(!XPCConvert::JSData2Native(ccx, &pv->val, val, type,
    1:                                       useAllocator, &param_iid, nsnull))
29946:             break;
    1:     }
    1: 
    1:     // if any params were dependent, then we must iterate again to convert them.
29946:     if(foundDependentParam && i == paramCount)
    1:     {
    1:         for(i = 0; i < paramCount; i++)
    1:         {
    1:             const nsXPTParamInfo& param = info->params[i];
    1:             if(!param.IsOut())
    1:                 continue;
    1: 
    1:             const nsXPTType& type = param.GetType();
    1:             if(!type.IsDependent())
    1:                 continue;
    1: 
    1:             jsval val;
    1:             nsXPTCMiniVariant* pv;
    1:             nsXPTType datum_type;
    1:             JSBool useAllocator = JS_FALSE;
    1:             JSUint32 array_count;
    1:             PRBool isArray = type.IsArray();
    1:             PRBool isSizedString = isArray ?
    1:                     JS_FALSE :
    1:                     type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS ||
    1:                     type.TagPart() == nsXPTType::T_PWSTRING_SIZE_IS;
    1: 
    1:             pv = (nsXPTCMiniVariant*) nativeParams[i].val.p;
    1: 
    1:             if(param.IsRetval())
50465:                 val = rval;
50465:             else if(!JS_GetPropertyById(cx, JSVAL_TO_OBJECT(argv[i]),
    1:                         mRuntime->GetStringID(XPCJSRuntime::IDX_VALUE),
    1:                         &val))
29946:                 break;
    1: 
    1:             // setup allocator and/or iid
    1: 
    1:             if(isArray)
    1:             {
    1:                 if(NS_FAILED(mInfo->GetTypeForParam(methodIndex, &param, 1,
    1:                                                     &datum_type)))
29946:                     break;
    1:             }
    1:             else
    1:                 datum_type = type;
    1: 
    1:             if(datum_type.IsInterfacePointer())
    1:             {
    1:                if(!GetInterfaceTypeFromParam(cx, info, param, methodIndex,
    1:                                              datum_type, nativeParams,
    1:                                              &param_iid))
29946:                    break;
    1:             }
    1:             else if(type.IsPointer() && !param.IsShared())
    1:                 useAllocator = JS_TRUE;
    1: 
    1:             if(isArray || isSizedString)
    1:             {
    1:                 if(!GetArraySizeFromParam(cx, info, param, methodIndex,
    1:                                           i, GET_LENGTH, nativeParams,
    1:                                           &array_count))
29946:                     break;
    1:             }
    1: 
    1:             if(isArray)
    1:             {
    1:                 if(array_count &&
    1:                    !XPCConvert::JSArray2Native(ccx, (void**)&pv->val, val,
    1:                                                array_count, array_count,
    1:                                                datum_type,
    1:                                                useAllocator, &param_iid,
    1:                                                nsnull))
29946:                     break;
    1:             }
    1:             else if(isSizedString)
    1:             {
    1:                 if(!XPCConvert::JSStringWithSize2Native(ccx,
    1:                                                    (void*)&pv->val, val,
    1:                                                    array_count, array_count,
    1:                                                    datum_type, useAllocator,
    1:                                                    nsnull))
29946:                     break;
    1:             }
    1:             else
    1:             {
    1:                 if(!XPCConvert::JSData2Native(ccx, &pv->val, val, type,
    1:                                               useAllocator, &param_iid,
    1:                                               nsnull))
29946:                     break;
    1:             }
    1:         }
    1:     }
    1: 
29946:     if(i != paramCount)
    1:     {
    1:         // We didn't manage all the result conversions!
    1:         // We have to cleanup any junk that *did* get converted.
    1: 
    1:         for(uint8 k = 0; k < i; k++)
    1:         {
    1:             const nsXPTParamInfo& param = info->params[k];
    1:             if(!param.IsOut())
    1:                 continue;
    1:             const nsXPTType& type = param.GetType();
    1:             if(!type.IsPointer())
    1:                 continue;
    1:             void* p;
    1:             if(!(p = nativeParams[k].val.p))
    1:                 continue;
    1: 
    1:             if(type.IsArray())
    1:             {
    1:                 void** pp;
    1:                 if(nsnull != (pp = *((void***)p)))
    1:                 {
    1:                     // we need to get the array length and iterate the items
    1:                     JSUint32 array_count;
    1:                     nsXPTType datum_type;
    1: 
    1:                     if(NS_SUCCEEDED(mInfo->GetTypeForParam(methodIndex, &param,
    1:                                                            1, &datum_type)) &&
    1:                        datum_type.IsPointer() &&
    1:                        GetArraySizeFromParam(cx, info, param, methodIndex,
    1:                                              k, GET_LENGTH, nativeParams,
    1:                                              &array_count) && array_count)
    1:                     {
    1:                         CleanupPointerArray(datum_type, array_count, pp);
    1:                     }
    1:                     nsMemory::Free(pp);
    1:                 }
    1:             }
    1:             else
    1:                 CleanupPointerTypeObject(type, (void**)p);
    1:             *((void**)p) = nsnull;
    1:         }
    1:     }
    1:     else
    1:     {
    1:         // set to whatever the JS code might have set as the result
    1:         retval = pending_result;
    1:     }
    1: 
    1:     return retval;
    1: }
    1: 
    1: const char*
    1: nsXPCWrappedJSClass::GetInterfaceName()
    1: {
    1:     if(!mName)
    1:         mInfo->GetName(&mName);
    1:     return mName;
    1: }
    1: 
    1: JSObject*
27428: nsXPCWrappedJSClass::NewOutObject(JSContext* cx, JSObject* scope)
    1: {
27428:     return JS_NewObject(cx, nsnull, nsnull, JS_GetGlobalForObject(cx, scope));
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXPCWrappedJSClass::DebugDump(PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     depth-- ;
    1:     XPC_LOG_ALWAYS(("nsXPCWrappedJSClass @ %x with mRefCnt = %d", this, mRefCnt.get()));
    1:     XPC_LOG_INDENT();
    1:         char* name;
    1:         mInfo->GetName(&name);
    1:         XPC_LOG_ALWAYS(("interface name is %s", name));
    1:         if(name)
    1:             nsMemory::Free(name);
    1:         char * iid = mIID.ToString();
    1:         XPC_LOG_ALWAYS(("IID number is %s", iid ? iid : "invalid"));
    1:         if(iid)
30833:             NS_Free(iid);
    1:         XPC_LOG_ALWAYS(("InterfaceInfo @ %x", mInfo));
    1:         uint16 methodCount = 0;
    1:         if(depth)
    1:         {
    1:             uint16 i;
 4214:             nsCOMPtr<nsIInterfaceInfo> parent;
    1:             XPC_LOG_INDENT();
 4214:             mInfo->GetParent(getter_AddRefs(parent));
 4214:             XPC_LOG_ALWAYS(("parent @ %x", parent.get()));
    1:             mInfo->GetMethodCount(&methodCount);
    1:             XPC_LOG_ALWAYS(("MethodCount = %d", methodCount));
    1:             mInfo->GetConstantCount(&i);
    1:             XPC_LOG_ALWAYS(("ConstantCount = %d", i));
    1:             XPC_LOG_OUTDENT();
    1:         }
    1:         XPC_LOG_ALWAYS(("mRuntime @ %x", mRuntime));
    1:         XPC_LOG_ALWAYS(("mDescriptors @ %x count = %d", mDescriptors, methodCount));
    1:         if(depth && mDescriptors && methodCount)
    1:         {
    1:             depth--;
    1:             XPC_LOG_INDENT();
    1:             for(uint16 i = 0; i < methodCount; i++)
    1:             {
    1:                 XPC_LOG_ALWAYS(("Method %d is %s%s", \
    1:                         i, IsReflectable(i) ? "":" NOT ","reflectable"));
    1:             }
    1:             XPC_LOG_OUTDENT();
    1:             depth++;
    1:         }
    1:     XPC_LOG_OUTDENT();
    1: #endif
    1:     return NS_OK;
    1: }
