    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Dainis Jonitis, <Dainis_Jonitis@swh-t.lv>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "prlock.h"
    1: #include "nsRegion.h"
    1: #include "nsISupportsImpl.h"
    1: 
37534: /*
37534:  * The SENTINEL values below guaranties that a < or >
37534:  * comparison with it will be false for all values of the
37534:  * underlying nscoord type.  E.g. this is always false:
37534:  *   aCoord > NS_COORD_GREATER_SENTINEL
37534:  * Setting the mRectListHead dummy rectangle to these values
37534:  * allows us to loop without checking for the list end.
37534:  */
37534: #ifdef NS_COORD_IS_FLOAT
37534: #define NS_COORD_LESS_SENTINEL nscoord_MIN
37534: #define NS_COORD_GREATER_SENTINEL nscoord_MAX
37534: #else
37534: #define NS_COORD_LESS_SENTINEL PR_INT32_MIN
37534: #define NS_COORD_GREATER_SENTINEL PR_INT32_MAX
37534: #endif
37534: 
    1: // Fast inline analogues of nsRect methods for nsRegion::nsRectFast.
    1: // Check for emptiness is not required - it is guaranteed by caller.
    1: 
    1: inline PRBool nsRegion::nsRectFast::Contains (const nsRect& aRect) const
    1: {
    1:   return (PRBool) ((aRect.x >= x) && (aRect.y >= y) &&
    1:                    (aRect.XMost () <= XMost ()) && (aRect.YMost () <= YMost ()));
    1: }
    1: 
    1: inline PRBool nsRegion::nsRectFast::Intersects (const nsRect& aRect) const
    1: {
    1:   return (PRBool) ((x < aRect.XMost ()) && (y < aRect.YMost ()) &&
    1:                    (aRect.x < XMost ()) && (aRect.y < YMost ()));
    1: }
    1: 
    1: inline PRBool nsRegion::nsRectFast::IntersectRect (const nsRect& aRect1, const nsRect& aRect2)
    1: {
    1:   const nscoord xmost = PR_MIN (aRect1.XMost (), aRect2.XMost ());
    1:   x = PR_MAX (aRect1.x, aRect2.x);
    1:   width = xmost - x;
    1:   if (width <= 0) return PR_FALSE;
    1: 
    1:   const nscoord ymost = PR_MIN (aRect1.YMost (), aRect2.YMost ());
    1:   y = PR_MAX (aRect1.y, aRect2.y);
    1:   height = ymost - y;
    1:   if (height <= 0) return PR_FALSE;
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: inline void nsRegion::nsRectFast::UnionRect (const nsRect& aRect1, const nsRect& aRect2)
    1: {
    1:   const nscoord xmost = PR_MAX (aRect1.XMost (), aRect2.XMost ());
    1:   const nscoord ymost = PR_MAX (aRect1.YMost (), aRect2.YMost ());
    1:   x = PR_MIN (aRect1.x, aRect2.x);
    1:   y = PR_MIN (aRect1.y, aRect2.y);
    1:   width  = xmost - x;
    1:   height = ymost - y;
    1: }
    1: 
    1: 
    1: 
    1: // Custom memory allocator for nsRegion::RgnRect structures.
    1: // Entries are allocated from global memory pool.
    1: // Memory pool can grow in size, but it can't shrink.
    1: 
    1: #define INIT_MEM_CHUNK_ENTRIES 100
    1: #define INCR_MEM_CHUNK_ENTRIES 100
    1: 
    1: class RgnRectMemoryAllocator
    1: {
    1:   nsRegion::RgnRect*  mFreeListHead;
    1:   PRUint32  mFreeEntries;
    1:   void*     mChunkListHead;
    1: #if 0
    1:   PRLock*   mLock;
    1: 
    1:   void InitLock ()    { mLock = PR_NewLock (); }
    1:   void DestroyLock () { PR_DestroyLock (mLock); }
    1:   void Lock ()        { PR_Lock   (mLock); }
    1:   void Unlock ()      { PR_Unlock (mLock); }
    1: #elif defined (DEBUG)
    1:   NS_DECL_OWNINGTHREAD
    1: 
    1:   void InitLock ()    { NS_ASSERT_OWNINGTHREAD (RgnRectMemoryAllocator); }
    1:   void DestroyLock () { NS_ASSERT_OWNINGTHREAD (RgnRectMemoryAllocator); }
    1:   void Lock ()        { NS_ASSERT_OWNINGTHREAD (RgnRectMemoryAllocator); }
    1:   void Unlock ()      { NS_ASSERT_OWNINGTHREAD (RgnRectMemoryAllocator); }
    1: #else
    1:   void InitLock ()    { }
    1:   void DestroyLock () { }
    1:   void Lock ()        { }
    1:   void Unlock ()      { }
    1: #endif
    1: 
    1:   void* AllocChunk (PRUint32 aEntries, void* aNextChunk, nsRegion::RgnRect* aTailDest)
    1:   {
    1:     PRUint8* pBuf = new PRUint8 [aEntries * sizeof (nsRegion::RgnRect) + sizeof (void*)];
 3233:     *reinterpret_cast<void**>(pBuf) = aNextChunk;
 3233:     nsRegion::RgnRect* pRect = reinterpret_cast<nsRegion::RgnRect*>(pBuf + sizeof (void*));
    1: 
    1:     for (PRUint32 cnt = 0 ; cnt < aEntries - 1 ; cnt++)
    1:       pRect [cnt].next = &pRect [cnt + 1];
    1: 
    1:     pRect [aEntries - 1].next = aTailDest;
    1: 
    1:     return pBuf;
    1:   }
    1: 
    1:   void FreeChunk (void* aChunk) {  delete [] (PRUint8 *) aChunk;  }
 3233:   void* NextChunk (void* aThisChunk) const { return *static_cast<void**>(aThisChunk); }
    1: 
    1:   nsRegion::RgnRect* ChunkHead (void* aThisChunk) const
 3233:   {   return reinterpret_cast<nsRegion::RgnRect*>(static_cast<PRUint8*>(aThisChunk) + sizeof (void*));  }
    1: 
    1: public:
    1:   RgnRectMemoryAllocator (PRUint32 aNumOfEntries);
    1:  ~RgnRectMemoryAllocator ();
    1: 
    1:   nsRegion::RgnRect* Alloc ();
    1:   void Free (nsRegion::RgnRect* aRect);
    1: };
    1: 
    1: 
    1: RgnRectMemoryAllocator::RgnRectMemoryAllocator (PRUint32 aNumOfEntries)
    1: {
    1:   InitLock ();
    1:   mChunkListHead = AllocChunk (aNumOfEntries, nsnull, nsnull);
    1:   mFreeEntries   = aNumOfEntries;
    1:   mFreeListHead  = ChunkHead (mChunkListHead);
    1: }
    1: 
    1: RgnRectMemoryAllocator::~RgnRectMemoryAllocator ()
    1: {
    1:   while (mChunkListHead)
    1:   {
    1:     void* tmp = mChunkListHead;
    1:     mChunkListHead = NextChunk (mChunkListHead);
    1:     FreeChunk (tmp);
    1:   }
    1: 
    1: #if 0
    1:   /*
    1:    * As a static object this class outlives any library which would implement
    1:    * locking. So we intentionally leak the 'lock'.
    1:    *
    1:    * Currently RgnRectMemoryAllocator is only used from the primary thread,
    1:    * so we aren't using a lock which means that there is no lock to leak.
    1:    * If we ever switch to multiple GUI threads (e.g. one per window),
    1:    * we'd probably use one allocator per window-thread to avoid the
    1:    * locking overhead and just require consumers not to pass regions
    1:    * across threads/windows, which would be a reasonable restriction
    1:    * because they wouldn't be useful outside their window.
    1:    */
    1:   DestroyLock ();
    1: #endif
    1: }
    1: 
    1: nsRegion::RgnRect* RgnRectMemoryAllocator::Alloc ()
    1: {
    1:   Lock ();
    1: 
    1:   if (mFreeEntries == 0)
    1:   {
    1:     mChunkListHead = AllocChunk (INCR_MEM_CHUNK_ENTRIES, mChunkListHead, mFreeListHead);
    1:     mFreeEntries   = INCR_MEM_CHUNK_ENTRIES;
    1:     mFreeListHead  = ChunkHead (mChunkListHead);
    1:   }
    1: 
    1:   nsRegion::RgnRect* tmp = mFreeListHead;
    1:   mFreeListHead = mFreeListHead->next;
    1:   mFreeEntries--;
    1:   Unlock ();
    1: 
    1:   return tmp;
    1: }
    1: 
    1: void RgnRectMemoryAllocator::Free (nsRegion::RgnRect* aRect)
    1: {
    1:   Lock ();
    1:   mFreeEntries++;
    1:   aRect->next = mFreeListHead;
    1:   mFreeListHead = aRect;
    1:   Unlock ();
    1: }
    1: 
    1: 
    1: // Global pool for nsRegion::RgnRect allocation
32353: static RgnRectMemoryAllocator* gRectPool;
    1: 
32353: nsresult nsRegion::InitStatic()
32353: {
32353:   gRectPool = new RgnRectMemoryAllocator(INIT_MEM_CHUNK_ENTRIES);
32353:   return !gRectPool ? NS_ERROR_OUT_OF_MEMORY : NS_OK;
32353: }
32353: 
32353: void nsRegion::ShutdownStatic()
32353: {
32353:     delete gRectPool;
32353: }
    1: 
 9676: void* nsRegion::RgnRect::operator new (size_t) CPP_THROW_NEW
    1: {
32353:   return gRectPool->Alloc ();
    1: }
    1: 
 9676: void nsRegion::RgnRect::operator delete (void* aRect, size_t)
    1: {
32353:   gRectPool->Free (static_cast<RgnRect*>(aRect));
    1: }
    1: 
    1: 
    1: 
    1: void nsRegion::Init()
    1: {
    1:   mRectListHead.prev = mRectListHead.next = &mRectListHead;
    1:   mCurRect = &mRectListHead;
    1:   mRectCount = 0;
    1:   mBoundRect.SetRect (0, 0, 0, 0);
    1: }
    1: 
    1: inline void nsRegion::InsertBefore (RgnRect* aNewRect, RgnRect* aRelativeRect)
    1: {
    1:   aNewRect->prev = aRelativeRect->prev;
    1:   aNewRect->next = aRelativeRect;
    1:   aRelativeRect->prev->next = aNewRect;
    1:   aRelativeRect->prev = aNewRect;
    1:   mCurRect = aNewRect;
    1:   mRectCount++;
    1: }
    1: 
    1: inline void nsRegion::InsertAfter (RgnRect* aNewRect, RgnRect* aRelativeRect)
    1: {
    1:   aNewRect->prev = aRelativeRect;
    1:   aNewRect->next = aRelativeRect->next;
    1:   aRelativeRect->next->prev = aNewRect;
    1:   aRelativeRect->next = aNewRect;
    1:   mCurRect = aNewRect;
    1:   mRectCount++;
    1: }
    1: 
    1: 
    1: // Adjust the number of rectangles in region.
    1: // Content of rectangles should be changed by caller.
    1: 
    1: void nsRegion::SetToElements (PRUint32 aCount)
    1: {
    1:   if (mRectCount < aCount)        // Add missing rectangles
    1:   {
    1:     PRUint32 InsertCount = aCount - mRectCount;
    1:     mRectCount = aCount;
    1:     RgnRect* pPrev = &mRectListHead;
    1:     RgnRect* pNext = mRectListHead.next;
    1: 
    1:     while (InsertCount--)
    1:     {
    1:       mCurRect = new RgnRect;
    1:       mCurRect->prev = pPrev;
    1:       pPrev->next = mCurRect;
    1:       pPrev = mCurRect;
    1:     }
    1: 
    1:     pPrev->next = pNext;
    1:     pNext->prev = pPrev;
    1:   } else
    1:   if (mRectCount > aCount)        // Remove unnecessary rectangles
    1:   {
    1:     PRUint32 RemoveCount = mRectCount - aCount;
    1:     mRectCount = aCount;
    1:     mCurRect = mRectListHead.next;
    1: 
    1:     while (RemoveCount--)
    1:     {
    1:       RgnRect* tmp = mCurRect;
    1:       mCurRect = mCurRect->next;
    1:       delete tmp;
    1:     }
    1: 
    1:     mRectListHead.next = mCurRect;
    1:     mCurRect->prev = &mRectListHead;
    1:   }
    1: }
    1: 
    1: 
    1: // Save the entire chain of linked elements in 'prev' field of the RgnRect structure.
    1: // After that forward-only iterations using 'next' field could still be used.
    1: // Some elements from forward-only chain could be temporarily removed to optimize inner loops.
    1: // The original double linked state could be restored by call to RestoreLinkChain ().
    1: // Both functions despite size can be inline because they are called only from one function.
    1: 
    1: inline void nsRegion::SaveLinkChain ()
    1: {
    1:   RgnRect* pRect = &mRectListHead;
    1: 
    1:   do
    1:   {
    1:     pRect->prev = pRect->next;
    1:     pRect = pRect->next;
    1:   } while (pRect != &mRectListHead);
    1: }
    1: 
    1: 
    1: inline void nsRegion::RestoreLinkChain ()
    1: {
    1:   RgnRect* pPrev = &mRectListHead;
    1:   RgnRect* pRect = mRectListHead.next = mRectListHead.prev;
    1: 
    1:   while (pRect != &mRectListHead)
    1:   {
    1:     pRect->next = pRect->prev;
    1:     pRect->prev = pPrev;
    1:     pPrev = pRect;
    1:     pRect = pRect->next;
    1:   }
    1: 
    1:   mRectListHead.prev = pPrev;
    1: }
    1: 
    1: 
    1: // Insert node in right place of sorted list
    1: // If necessary then bounding rectangle could be updated and rectangle combined
    1: // with neighbour rectangles. This is usually done in Optimize ()
    1: 
    1: void nsRegion::InsertInPlace (RgnRect* aRect, PRBool aOptimizeOnFly)
    1: {
    1:   if (mRectCount == 0)
    1:     InsertAfter (aRect, &mRectListHead);
    1:   else
    1:   {
    1:     if (aRect->y > mCurRect->y)
    1:     {
37534:       mRectListHead.y = NS_COORD_GREATER_SENTINEL;
    1:       while (aRect->y > mCurRect->next->y)
    1:         mCurRect = mCurRect->next;
    1: 
37534:       mRectListHead.x = NS_COORD_GREATER_SENTINEL;
    1:       while (aRect->y == mCurRect->next->y && aRect->x > mCurRect->next->x)
    1:         mCurRect = mCurRect->next;
    1: 
    1:       InsertAfter (aRect, mCurRect);
    1:     } else
    1:     if (aRect->y < mCurRect->y)
    1:     {
37534:       mRectListHead.y = NS_COORD_LESS_SENTINEL;
    1:       while (aRect->y < mCurRect->prev->y)
    1:         mCurRect = mCurRect->prev;
    1: 
37534:       mRectListHead.x = NS_COORD_LESS_SENTINEL;
    1:       while (aRect->y == mCurRect->prev->y && aRect->x < mCurRect->prev->x)
    1:         mCurRect = mCurRect->prev;
    1: 
    1:       InsertBefore (aRect, mCurRect);
    1:     } else
    1:     {
    1:       if (aRect->x > mCurRect->x)
    1:       {
37534:         mRectListHead.x = NS_COORD_GREATER_SENTINEL;
    1:         while (aRect->y == mCurRect->next->y && aRect->x > mCurRect->next->x)
    1:           mCurRect = mCurRect->next;
    1: 
    1:         InsertAfter (aRect, mCurRect);
    1:       } else
    1:       {
37534:         mRectListHead.x = NS_COORD_LESS_SENTINEL;
    1:         while (aRect->y == mCurRect->prev->y && aRect->x < mCurRect->prev->x)
    1:           mCurRect = mCurRect->prev;
    1: 
    1:         InsertBefore (aRect, mCurRect);
    1:       }
    1:     }
    1:   }
    1: 
    1: 
    1:   if (aOptimizeOnFly)
    1:   {
    1:     if (mRectCount == 1)
    1:       mBoundRect = *mCurRect;
    1:     else
    1:     {
    1:       mBoundRect.UnionRect (mBoundRect, *mCurRect);
    1: 
    1:       // Check if we can go left or up before starting to combine rectangles
    1:       if ((mCurRect->y == mCurRect->prev->y && mCurRect->height == mCurRect->prev->height &&
    1:            mCurRect->x == mCurRect->prev->XMost ()) ||
    1:           (mCurRect->x == mCurRect->prev->x && mCurRect->width == mCurRect->prev->width &&
    1:            mCurRect->y == mCurRect->prev->YMost ()) )
    1:         mCurRect = mCurRect->prev;
    1: 
    1:       // Try to combine with rectangle on right side
    1:       while (mCurRect->y == mCurRect->next->y && mCurRect->height == mCurRect->next->height &&
    1:              mCurRect->XMost () == mCurRect->next->x)
    1:       {
    1:         mCurRect->width += mCurRect->next->width;
    1:         delete Remove (mCurRect->next);
    1:       }
    1: 
    1:       // Try to combine with rectangle under this one
    1:       while (mCurRect->x == mCurRect->next->x && mCurRect->width == mCurRect->next->width &&
    1:              mCurRect->YMost () == mCurRect->next->y)
    1:       {
    1:         mCurRect->height += mCurRect->next->height;
    1:         delete Remove (mCurRect->next);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: nsRegion::RgnRect* nsRegion::Remove (RgnRect* aRect)
    1: {
    1:   aRect->prev->next = aRect->next;
    1:   aRect->next->prev = aRect->prev;
    1:   mRectCount--;
    1: 
    1:   if (mCurRect == aRect)
    1:     mCurRect = (aRect->next != &mRectListHead) ? aRect->next : aRect->prev;
    1: 
    1:   return aRect;
    1: }
    1: 
    1: 
    1: // Try to reduce the number of rectangles in complex region by combining with
    1: // surrounding ones on right and bottom sides of each rectangle in list.
    1: // Update bounding rectangle
    1: 
    1: void nsRegion::Optimize ()
    1: {
    1:   if (mRectCount == 0)
    1:     mBoundRect.SetRect (0, 0, 0, 0);
    1:   else
    1:   {
    1:     RgnRect* pRect = mRectListHead.next;
    1:     PRInt32 xmost = mRectListHead.prev->XMost ();
    1:     PRInt32 ymost = mRectListHead.prev->YMost ();
    1:     mBoundRect.x = mRectListHead.next->x;
    1:     mBoundRect.y = mRectListHead.next->y;
    1: 
    1:     while (pRect != &mRectListHead)
    1:     {
    1:       // Try to combine with rectangle on right side
    1:       while (pRect->y == pRect->next->y && pRect->height == pRect->next->height &&
    1:              pRect->XMost () == pRect->next->x)
    1:       {
    1:         pRect->width += pRect->next->width;
    1:         delete Remove (pRect->next);
    1:       }
    1: 
    1:       // Try to combine with rectangle under this one
    1:       while (pRect->x == pRect->next->x && pRect->width == pRect->next->width &&
    1:              pRect->YMost () == pRect->next->y)
    1:       {
    1:         pRect->height += pRect->next->height;
    1:         delete Remove (pRect->next);
    1:       }
    1: 
    1:       // Determine bound rectangle. Use fact that rectangles are sorted.
    1:       if (pRect->x < mBoundRect.x) mBoundRect.x = pRect->x;
    1:       if (pRect->XMost () > xmost) xmost = pRect->XMost ();
    1:       if (pRect->YMost () > ymost) ymost = pRect->YMost ();
    1: 
    1:       pRect = pRect->next;
    1:     }
    1: 
    1:     mBoundRect.width  = xmost - mBoundRect.x;
    1:     mBoundRect.height = ymost - mBoundRect.y;
    1:   }
    1: }
    1: 
    1: 
    1: // Move rectangles starting from 'aStartRect' till end of the list to the destionation region.
    1: // Important for temporary objects - instead of copying rectangles with Merge () and then
    1: // emptying region in destructor they could be moved to destination region in one step.
    1: 
    1: void nsRegion::MoveInto (nsRegion& aDestRegion, const RgnRect* aStartRect)
    1: {
 3233:   RgnRect* pRect = const_cast<RgnRect*>(aStartRect);
    1:   RgnRect* pPrev = pRect->prev;
    1: 
    1:   while (pRect != &mRectListHead)
    1:   {
    1:     RgnRect* next = pRect->next;
    1:     aDestRegion.InsertInPlace (pRect);
    1: 
    1:     mRectCount--;
    1:     pRect = next;
    1:   }
    1: 
    1:   pPrev->next = &mRectListHead;
    1:   mRectListHead.prev = pPrev;
    1:   mCurRect = mRectListHead.next;
    1: }
    1: 
    1: 
    1: // Merge two non-overlapping regions into one.
    1: // Automatically optimize region by calling Optimize ()
    1: 
    1: void nsRegion::Merge (const nsRegion& aRgn1, const nsRegion& aRgn2)
    1: {
    1:   if (aRgn1.mRectCount == 0)            // Region empty. Result is equal to other region
    1:     Copy (aRgn2);
    1:   else
    1:   if (aRgn2.mRectCount == 0)            // Region empty. Result is equal to other region
    1:     Copy (aRgn1);
    1:   if (aRgn1.mRectCount == 1)            // Region is single rectangle. Optimize on fly
    1:   {
    1:     RgnRect* TmpRect = new RgnRect (*aRgn1.mRectListHead.next);
    1:     Copy (aRgn2);
    1:     InsertInPlace (TmpRect, PR_TRUE);
    1:   } else
    1:   if (aRgn2.mRectCount == 1)            // Region is single rectangle. Optimize on fly
    1:   {
    1:     RgnRect* TmpRect = new RgnRect (*aRgn2.mRectListHead.next);
    1:     Copy (aRgn1);
    1:     InsertInPlace (TmpRect, PR_TRUE);
    1:   } else
    1:   {
    1:     const nsRegion* pCopyRegion, *pInsertRegion;
    1: 
    1:     // Determine which region contains more rectangles. Copy the larger one
    1:     if (aRgn1.mRectCount >= aRgn2.mRectCount)
    1:     {
    1:       pCopyRegion = &aRgn1;
    1:       pInsertRegion = &aRgn2;
    1:     } else
    1:     {
    1:       pCopyRegion = &aRgn2;
    1:       pInsertRegion = &aRgn1;
    1:     }
    1: 
    1:     if (pInsertRegion == this)          // Do merge in-place
    1:       pInsertRegion = pCopyRegion;
    1:     else
    1:       Copy (*pCopyRegion);
    1: 
    1:     const RgnRect* pSrcRect = pInsertRegion->mRectListHead.next;
    1: 
    1:     while (pSrcRect != &pInsertRegion->mRectListHead)
    1:     {
    1:       InsertInPlace (new RgnRect (*pSrcRect));
    1: 
    1:       pSrcRect = pSrcRect->next;
    1:     }
    1: 
    1:     Optimize ();
    1:   }
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Copy (const nsRegion& aRegion)
    1: {
    1:   if (&aRegion == this)
    1:     return *this;
    1: 
    1:   if (aRegion.mRectCount == 0)
    1:     SetEmpty ();
    1:   else
    1:   {
    1:     SetToElements (aRegion.mRectCount);
    1: 
    1:     const RgnRect* pSrc = aRegion.mRectListHead.next;
    1:     RgnRect* pDest = mRectListHead.next;
    1: 
    1:     while (pSrc != &aRegion.mRectListHead)
    1:     {
    1:       *pDest = *pSrc;
    1: 
    1:       pSrc  = pSrc->next;
    1:       pDest = pDest->next;
    1:     }
    1: 
    1:     mCurRect = mRectListHead.next;
    1:     mBoundRect = aRegion.mBoundRect;
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Copy (const nsRect& aRect)
    1: {
    1:   if (aRect.IsEmpty ())
    1:     SetEmpty ();
    1:   else
    1:   {
    1:     SetToElements (1);
 3233:     *mRectListHead.next = static_cast<const RgnRect&>(aRect);
 3233:     mBoundRect = static_cast<const nsRectFast&>(aRect);
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::And (const nsRegion& aRgn1, const nsRegion& aRgn2)
    1: {
    1:   if (&aRgn1 == &aRgn2)                                       // And with self
    1:     Copy (aRgn1);
    1:   else
    1:   if (aRgn1.mRectCount == 0 || aRgn2.mRectCount == 0)         // If either region is empty then result is empty
    1:     SetEmpty ();
    1:   else
    1:   {
    1:     nsRectFast TmpRect;
    1: 
    1:     if (aRgn1.mRectCount == 1 && aRgn2.mRectCount == 1)       // Intersect rectangle with rectangle
    1:     {
    1:       TmpRect.IntersectRect (*aRgn1.mRectListHead.next, *aRgn2.mRectListHead.next);
    1:       Copy (TmpRect);
    1:     } else
    1:     {
    1:       if (!aRgn1.mBoundRect.Intersects (aRgn2.mBoundRect))    // Regions do not intersect
    1:         SetEmpty ();
    1:       else
    1:       {
    1:         // Region is simple rectangle and it fully overlays other region
    1:         if (aRgn1.mRectCount == 1 && aRgn1.mBoundRect.Contains (aRgn2.mBoundRect))
    1:           Copy (aRgn2);
    1:         else
    1:         // Region is simple rectangle and it fully overlays other region
    1:         if (aRgn2.mRectCount == 1 && aRgn2.mBoundRect.Contains (aRgn1.mBoundRect))
    1:           Copy (aRgn1);
    1:         else
    1:         {
    1:           nsRegion TmpRegion;
 3233:           nsRegion* pSrcRgn1 = const_cast<nsRegion*>(&aRgn1);
 3233:           nsRegion* pSrcRgn2 = const_cast<nsRegion*>(&aRgn2);
    1: 
    1:           if (&aRgn1 == this)     // Copy region if it is both source and result
    1:           {
    1:             TmpRegion.Copy (aRgn1);
    1:             pSrcRgn1 = &TmpRegion;
    1:           }
    1: 
    1:           if (&aRgn2 == this)     // Copy region if it is both source and result
    1:           {
    1:             TmpRegion.Copy (aRgn2);
    1:             pSrcRgn2 = &TmpRegion;
    1:           }
    1: 
    1:           // For outer loop prefer region for which at least one rectangle is below other's bound rectangle
    1:           if (pSrcRgn2->mRectListHead.prev->y >= pSrcRgn1->mBoundRect.YMost ())
    1:           {
    1:             nsRegion* Tmp = pSrcRgn1;
    1:             pSrcRgn1 = pSrcRgn2;
    1:             pSrcRgn2 = Tmp;
    1:           }
    1: 
    1: 
    1:           SetToElements (0);
    1:           pSrcRgn2->SaveLinkChain ();
    1: 
37534:           pSrcRgn1->mRectListHead.y = NS_COORD_GREATER_SENTINEL;
37534:           pSrcRgn2->mRectListHead.y = NS_COORD_GREATER_SENTINEL;
    1: 
    1:           for (RgnRect* pSrcRect1 = pSrcRgn1->mRectListHead.next ;
    1:                pSrcRect1->y < pSrcRgn2->mBoundRect.YMost () ; pSrcRect1 = pSrcRect1->next)
    1:           {
    1:             if (pSrcRect1->Intersects (pSrcRgn2->mBoundRect))   // Rectangle intersects region. Process each rectangle
    1:             {
    1:               RgnRect* pPrev2 = &pSrcRgn2->mRectListHead;
    1: 
    1:               for (RgnRect* pSrcRect2 = pSrcRgn2->mRectListHead.next ;
    1:                    pSrcRect2->y < pSrcRect1->YMost () ; pSrcRect2 = pSrcRect2->next)
    1:               {
    1:                 if (pSrcRect2->YMost () <= pSrcRect1->y)        // Rect2's bottom is above the top of Rect1.
    1:                 {                                               // No successive rectangles in Rgn1 can intersect it.
    1:                   pPrev2->next = pSrcRect2->next;               // Remove Rect2 from Rgn2's checklist
    1:                   continue;
    1:                 }
    1: 
    1:                 if (pSrcRect1->Contains (*pSrcRect2))           // Rect1 fully overlays Rect2.
    1:                 {                                               // No any other rectangle in Rgn1 can intersect it.
    1:                   pPrev2->next = pSrcRect2->next;               // Remove Rect2 from Rgn2's checklist
    1:                   InsertInPlace (new RgnRect (*pSrcRect2));
    1:                   continue;
    1:                 }
    1: 
    1: 
    1:                 if (TmpRect.IntersectRect (*pSrcRect1, *pSrcRect2))
    1:                   InsertInPlace (new RgnRect (TmpRect));
    1: 
    1:                 pPrev2 = pSrcRect2;
    1:               }
    1:             }
    1:           }
    1: 
    1:           pSrcRgn2->RestoreLinkChain ();
    1:           Optimize ();
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::And (const nsRegion& aRegion, const nsRect& aRect)
    1: {
    1:   // If either region or rectangle is empty then result is empty
    1:   if (aRegion.mRectCount == 0 || aRect.IsEmpty ())
    1:     SetEmpty ();
    1:   else                            // Intersect region with rectangle
    1:   {
 3233:     const nsRectFast& aRectFast = static_cast<const nsRectFast&>(aRect);
    1:     nsRectFast TmpRect;
    1: 
    1:     if (aRegion.mRectCount == 1)  // Intersect rectangle with rectangle
    1:     {
    1:       TmpRect.IntersectRect (*aRegion.mRectListHead.next, aRectFast);
    1:       Copy (TmpRect);
    1:     } else                        // Intersect complex region with rectangle
    1:     {
    1:       if (!aRectFast.Intersects (aRegion.mBoundRect))   // Rectangle does not intersect region
    1:         SetEmpty ();
    1:       else
    1:       {
    1:         if (aRectFast.Contains (aRegion.mBoundRect))    // Rectangle fully overlays region
    1:           Copy (aRegion);
    1:         else
    1:         {
    1:           nsRegion TmpRegion;
 3233:           nsRegion* pSrcRegion = const_cast<nsRegion*>(&aRegion);
    1: 
    1:           if (&aRegion == this)   // Copy region if it is both source and result
    1:           {
    1:             TmpRegion.Copy (aRegion);
    1:             pSrcRegion = &TmpRegion;
    1:           }
    1: 
    1:           SetToElements (0);
37534:           pSrcRegion->mRectListHead.y = NS_COORD_GREATER_SENTINEL;
    1: 
    1:           for (const RgnRect* pSrcRect = pSrcRegion->mRectListHead.next ;
    1:                pSrcRect->y < aRectFast.YMost () ; pSrcRect = pSrcRect->next)
    1:           {
    1:             if (TmpRect.IntersectRect (*pSrcRect, aRectFast))
    1:               InsertInPlace (new RgnRect (TmpRect));
    1:           }
    1: 
    1:           Optimize ();
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Or (const nsRegion& aRgn1, const nsRegion& aRgn2)
    1: {
    1:   if (&aRgn1 == &aRgn2)                 // Or with self
    1:     Copy (aRgn1);
    1:   else
    1:   if (aRgn1.mRectCount == 0)            // Region empty. Result is equal to other region
    1:     Copy (aRgn2);
    1:   else
    1:   if (aRgn2.mRectCount == 0)            // Region empty. Result is equal to other region
    1:     Copy (aRgn1);
    1:   else
    1:   {
    1:     if (!aRgn1.mBoundRect.Intersects (aRgn2.mBoundRect))  // Regions do not intersect
    1:       Merge (aRgn1, aRgn2);
    1:     else
    1:     {
    1:       // Region is simple rectangle and it fully overlays other region
    1:       if (aRgn1.mRectCount == 1 && aRgn1.mBoundRect.Contains (aRgn2.mBoundRect))
    1:         Copy (aRgn1);
    1:       else
    1:       // Region is simple rectangle and it fully overlays other region
    1:       if (aRgn2.mRectCount == 1 && aRgn2.mBoundRect.Contains (aRgn1.mBoundRect))
    1:         Copy (aRgn2);
    1:       else
    1:       {
    1:         nsRegion TmpRegion;
    1:         aRgn1.SubRegion (aRgn2, TmpRegion);               // Get only parts of region which not overlap the other region
    1:         Copy (aRgn2);
    1:         TmpRegion.MoveInto (*this);
    1:         Optimize ();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Or (const nsRegion& aRegion, const nsRect& aRect)
    1: {
    1:   if (aRegion.mRectCount == 0)          // Region empty. Result is equal to rectangle
    1:     Copy (aRect);
    1:   else
    1:   if (aRect.IsEmpty ())                 // Rectangle is empty. Result is equal to region
    1:     Copy (aRegion);
    1:   else
    1:   {
 3233:     const nsRectFast& aRectFast = static_cast<const nsRectFast&>(aRect);
    1: 
    1:     if (!aRectFast.Intersects (aRegion.mBoundRect))     // Rectangle does not intersect region
    1:     {
    1:       Copy (aRegion);
    1:       InsertInPlace (new RgnRect (aRectFast), PR_TRUE);
    1:     } else
    1:     {
    1:       // Region is simple rectangle and it fully overlays rectangle
    1:       if (aRegion.mRectCount == 1 && aRegion.mBoundRect.Contains (aRectFast))
    1:         Copy (aRegion);
    1:       else
    1:       if (aRectFast.Contains (aRegion.mBoundRect))      // Rectangle fully overlays region
    1:         Copy (aRectFast);
    1:       else
    1:       {
    1:         aRegion.SubRect (aRectFast, *this);             // Exclude from region parts that overlap the rectangle
    1:         InsertInPlace (new RgnRect (aRectFast));
    1:         Optimize ();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Xor (const nsRegion& aRgn1, const nsRegion& aRgn2)
    1: {
    1:   if (&aRgn1 == &aRgn2)                 // Xor with self
    1:     SetEmpty ();
    1:   else
    1:   if (aRgn1.mRectCount == 0)            // Region empty. Result is equal to other region
    1:     Copy (aRgn2);
    1:   else
    1:   if (aRgn2.mRectCount == 0)            // Region empty. Result is equal to other region
    1:     Copy (aRgn1);
    1:   else
    1:   {
    1:     if (!aRgn1.mBoundRect.Intersects (aRgn2.mBoundRect))      // Regions do not intersect
    1:       Merge (aRgn1, aRgn2);
    1:     else
    1:     {
    1:       // Region is simple rectangle and it fully overlays other region
    1:       if (aRgn1.mRectCount == 1 && aRgn1.mBoundRect.Contains (aRgn2.mBoundRect))
    1:       {
    1:         aRgn1.SubRegion (aRgn2, *this);
    1:         Optimize ();
    1:       } else
    1:       // Region is simple rectangle and it fully overlays other region
    1:       if (aRgn2.mRectCount == 1 && aRgn2.mBoundRect.Contains (aRgn1.mBoundRect))
    1:       {
    1:         aRgn2.SubRegion (aRgn1, *this);
    1:         Optimize ();
    1:       } else
    1:       {
    1:         nsRegion TmpRegion;
    1:         aRgn1.SubRegion (aRgn2, TmpRegion);
    1:         aRgn2.SubRegion (aRgn1, *this);
    1:         TmpRegion.MoveInto (*this);
    1:         Optimize ();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Xor (const nsRegion& aRegion, const nsRect& aRect)
    1: {
    1:   if (aRegion.mRectCount == 0)          // Region empty. Result is equal to rectangle
    1:     Copy (aRect);
    1:   else
    1:   if (aRect.IsEmpty ())                 // Rectangle is empty. Result is equal to region
    1:     Copy (aRegion);
    1:   else
    1:   {
 3233:     const nsRectFast& aRectFast = static_cast<const nsRectFast&>(aRect);
    1: 
    1:     if (!aRectFast.Intersects (aRegion.mBoundRect))     // Rectangle does not intersect region
    1:     {
    1:       Copy (aRegion);
    1:       InsertInPlace (new RgnRect (aRectFast), PR_TRUE);
    1:     } else
    1:     {
    1:       // Region is simple rectangle and it fully overlays rectangle
    1:       if (aRegion.mRectCount == 1 && aRegion.mBoundRect.Contains (aRectFast))
    1:       {
    1:         aRegion.SubRect (aRectFast, *this);
    1:         Optimize ();
    1:       } else
    1:       if (aRectFast.Contains (aRegion.mBoundRect))      // Rectangle fully overlays region
    1:       {
    1:         nsRegion TmpRegion;
    1:         TmpRegion.Copy (aRectFast);
    1:         TmpRegion.SubRegion (aRegion, *this);
    1:         Optimize ();
    1:       } else
    1:       {
    1:         nsRegion TmpRegion;
    1:         TmpRegion.Copy (aRectFast);
    1:         TmpRegion.SubRegion (aRegion, TmpRegion);
    1:         aRegion.SubRect (aRectFast, *this);
    1:         TmpRegion.MoveInto (*this);
    1:         Optimize ();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Sub (const nsRegion& aRgn1, const nsRegion& aRgn2)
    1: {
    1:   if (&aRgn1 == &aRgn2)         // Sub from self
    1:     SetEmpty ();
    1:   else
    1:   if (aRgn1.mRectCount == 0)    // If source is empty then result is empty, too
    1:     SetEmpty ();
    1:   else
    1:   if (aRgn2.mRectCount == 0)    // Nothing to subtract
    1:     Copy (aRgn1);
    1:   else
    1:   {
    1:     if (!aRgn1.mBoundRect.Intersects (aRgn2.mBoundRect))   // Regions do not intersect
    1:       Copy (aRgn1);
    1:     else
    1:     {
    1:       aRgn1.SubRegion (aRgn2, *this);
    1:       Optimize ();
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: 
    1: nsRegion& nsRegion::Sub (const nsRegion& aRegion, const nsRect& aRect)
    1: {
    1:   if (aRegion.mRectCount == 0)    // If source is empty then result is empty, too
    1:     SetEmpty ();
    1:   else
    1:   if (aRect.IsEmpty ())           // Nothing to subtract
    1:     Copy (aRegion);
    1:   else
    1:   {
 3233:     const nsRectFast& aRectFast = static_cast<const nsRectFast&>(aRect);
    1: 
    1:     if (!aRectFast.Intersects (aRegion.mBoundRect))   // Rectangle does not intersect region
    1:       Copy (aRegion);
    1:     else
    1:     {
    1:       if (aRectFast.Contains (aRegion.mBoundRect))    // Rectangle fully overlays region
    1:         SetEmpty ();
    1:       else
    1:       {
    1:         aRegion.SubRect (aRectFast, *this);
    1:         Optimize ();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return *this;
    1: }
    1: 
    1: PRBool nsRegion::Contains (const nsRect& aRect) const
    1: {
    1:   if (aRect.IsEmpty())
    1:     return PR_TRUE;
    1:   if (IsEmpty())
    1:     return PR_FALSE;
    1:   if (!IsComplex())
    1:     return mBoundRect.Contains (aRect);
    1: 
    1:   nsRegion tmpRgn;
    1:   tmpRgn.Sub(aRect, *this);
    1:   return tmpRgn.IsEmpty();
    1: }
    1: 
    1: PRBool nsRegion::Intersects (const nsRect& aRect) const
    1: {
    1:   if (aRect.IsEmpty() || IsEmpty())
    1:     return PR_FALSE;
    1: 
    1:   const RgnRect* r = mRectListHead.next;
    1:   while (r != &mRectListHead)
    1:   {
    1:     if (r->Intersects(aRect))
    1:       return PR_TRUE;
    1:     r = r->next;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // Subtract region from current region.
    1: // Both regions are non-empty and they intersect each other.
    1: // Result could be empty region if aRgn2 is rectangle that fully overlays aRgn1.
    1: // Optimize () is not called on exit (bound rectangle is not updated).
    1: 
    1: void nsRegion::SubRegion (const nsRegion& aRegion, nsRegion& aResult) const
    1: {
    1:   if (aRegion.mRectCount == 1)    // Subtract simple rectangle
    1:   {
    1:     if (aRegion.mBoundRect.Contains (mBoundRect))
    1:       aResult.SetEmpty ();
    1:     else
    1:       SubRect (*aRegion.mRectListHead.next, aResult);
    1:   } else
    1:   {
    1:     nsRegion TmpRegion, CompletedRegion;
    1:     const nsRegion* pSubRgn = &aRegion;
    1: 
    1:     if (&aResult == &aRegion)     // Copy region if it is both source and result
    1:     {
    1:       TmpRegion.Copy (aRegion);
    1:       pSubRgn = &TmpRegion;
    1:     }
    1: 
    1:     const RgnRect* pSubRect = pSubRgn->mRectListHead.next;
    1: 
    1:     SubRect (*pSubRect, aResult, CompletedRegion);
    1:     pSubRect = pSubRect->next;
    1: 
    1:     while (pSubRect != &pSubRgn->mRectListHead)
    1:     {
    1:       aResult.SubRect (*pSubRect, aResult, CompletedRegion);
    1:       pSubRect = pSubRect->next;
    1:     }
    1: 
    1:     CompletedRegion.MoveInto (aResult);
    1:   }
    1: }
    1: 
    1: 
    1: // Subtract rectangle from current region.
    1: // Both region and rectangle are non-empty and they intersect each other.
    1: // Result could be empty region if aRect fully overlays aRegion.
    1: // Could be called repeatedly with 'this' as input and result - bound rectangle is not known.
    1: // Optimize () is not called on exit (bound rectangle is not updated).
    1: //
    1: // aCompleted is filled with rectangles which are already checked and could be safely
    1: // removed from further examination in case aRect rectangles come from ordered list.
    1: // aCompleted is not automatically emptied. aCompleted and aResult could be the same region.
    1: 
    1: void nsRegion::SubRect (const nsRectFast& aRect, nsRegion& aResult, nsRegion& aCompleted) const
    1: {
    1:   nsRegion TmpRegion;
    1:   const nsRegion* pSrcRegion = this;
    1: 
    1:   if (&aResult == this)           // Copy region if it is both source and result
    1:   {
    1:     TmpRegion.Copy (*this);
    1:     pSrcRegion = &TmpRegion;
    1:   }
    1: 
    1:   aResult.SetToElements (0);
    1: 
37534:   const_cast<nsRegion*>(pSrcRegion)->mRectListHead.y = NS_COORD_GREATER_SENTINEL;
    1:   const RgnRect* pSrcRect = pSrcRegion->mRectListHead.next;
    1: 
    1:   for ( ; pSrcRect->y < aRect.YMost () ; pSrcRect = pSrcRect->next)
    1:   {
    1:     nsRectFast TmpRect;
    1: 
    1:     // If bottom of current rectangle is above the top of aRect then this rectangle
    1:     // could be moved to aCompleted region. Successive aRect rectangles from ordered
    1:     // list do not have to check this rectangle again.
    1:     if (pSrcRect->YMost () <= aRect.y)
    1:     {
    1:       aCompleted.InsertInPlace (new RgnRect (*pSrcRect));
    1:       continue;
    1:     }
    1: 
    1:     if (!TmpRect.IntersectRect (*pSrcRect, aRect))
    1:       aResult.InsertInPlace (new RgnRect (*pSrcRect));
    1:     else
    1:     {
    1:       // Rectangle A. Subtract from this rectangle B
    1:       const nscoord ax  = pSrcRect->x;
    1:       const nscoord axm = pSrcRect->XMost ();
    1:       const nscoord aw  = pSrcRect->width;
    1:       const nscoord ay  = pSrcRect->y;
    1:       const nscoord aym = pSrcRect->YMost ();
    1:       const nscoord ah  = pSrcRect->height;
    1:       // Rectangle B. Subtract this from rectangle A
    1:       const nscoord bx  = aRect.x;
    1:       const nscoord bxm = aRect.XMost ();
    1:       const nscoord by  = aRect.y;
    1:       const nscoord bym = aRect.YMost ();
    1:       // Rectangle I. Area where rectangles A and B intersect
    1:       const nscoord ix  = TmpRect.x;
    1:       const nscoord ixm = TmpRect.XMost ();
    1:       const nscoord iy  = TmpRect.y;
    1:       const nscoord iym = TmpRect.YMost ();
    1:       const nscoord ih  = TmpRect.height;
    1: 
    1:       // There are 16 combinations how rectangles could intersect
    1: 
    1:       if (bx <= ax && by <= ay)
    1:       {
    1:         if (bxm < axm && bym < aym)     // 1.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ixm, ay, axm - ixm, ih));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm >= axm && bym < aym)    // 2.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm < axm && bym >= aym)    // 3.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ixm, ay, axm - ixm, ah));
    1:         } else
    1:         if (*pSrcRect == aRect)         // 4. subset
    1:         {                               // Current rectangle is equal to aRect
    1:           pSrcRect = pSrcRect->next;    // don't add this one to the result, it's removed
    1:           break;                        // No any other rectangle in region can intersect it
    1:         }
    1:       } else
    1:       if (bx > ax && by <= ay)
    1:       {
    1:         if (bxm < axm && bym < aym)     // 5.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, ix - ax, ih));
    1:           aResult.InsertInPlace (new RgnRect (ixm, ay, axm - ixm, ih));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm >= axm && bym < aym)    // 6.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, ix - ax, ih));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm < axm && bym >= aym)    // 7.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, ix - ax, ah));
    1:           aResult.InsertInPlace (new RgnRect (ixm, ay, axm - ixm, ah));
    1:         } else
    1:         if (bxm >= axm && bym >= aym)   // 8.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, ix - ax, ah));
    1:         }
    1:       } else
    1:       if (bx <= ax && by > ay)
    1:       {
    1:         if (bxm < axm && bym < aym)     // 9.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ixm, iy, axm - ixm, ih));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm >= axm && bym < aym)    // 10.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm < axm && bym >= aym)    // 11.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ixm, iy, axm - ixm, ih));
    1:         } else
    1:         if (bxm >= axm && bym >= aym)   // 12.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:         }
    1:       } else
    1:       if (bx > ax && by > ay)
    1:       {
    1:         if (bxm < axm && bym < aym)     // 13.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ax, iy, ix - ax, ih));
    1:           aResult.InsertInPlace (new RgnRect (ixm, iy, axm - ixm, ih));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1: 
    1:           // Current rectangle fully overlays aRect. No any other rectangle can intersect it.
    1:           pSrcRect = pSrcRect->next;    // don't add this one to the result, it's removed
    1:           break;
    1:         } else
    1:         if (bxm >= axm && bym < aym)    // 14.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ax, iy, ix - ax, ih));
    1:           aResult.InsertInPlace (new RgnRect (ax, iym, aw, aym - iym));
    1:         } else
    1:         if (bxm < axm && bym >= aym)    // 15.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ax, iy, ix - ax, ih));
    1:           aResult.InsertInPlace (new RgnRect (ixm, iy, axm - ixm, ih));
    1:         } else
    1:         if (bxm >= axm && bym >= aym)   // 16.
    1:         {
    1:           aResult.InsertInPlace (new RgnRect (ax, ay, aw, iy - ay));
    1:           aResult.InsertInPlace (new RgnRect (ax, iy, ix - ax, ih));
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Just copy remaining rectangles in region which are below aRect and can't intersect it.
    1:   // If rectangles are in temporary region then they could be moved.
    1:   if (pSrcRegion == &TmpRegion)
    1:     TmpRegion.MoveInto (aResult, pSrcRect);
    1:   else
    1:   {
    1:     while (pSrcRect != &pSrcRegion->mRectListHead)
    1:     {
    1:       aResult.InsertInPlace (new RgnRect (*pSrcRect));
    1:       pSrcRect = pSrcRect->next;
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: PRBool nsRegion::IsEqual (const nsRegion& aRegion) const
    1: {
    1:   if (mRectCount == 0)
    1:     return (aRegion.mRectCount == 0) ? PR_TRUE : PR_FALSE;
    1: 
    1:   if (aRegion.mRectCount == 0)
    1:     return (mRectCount == 0) ? PR_TRUE : PR_FALSE;
    1: 
    1:   if (mRectCount == 1 && aRegion.mRectCount == 1) // Both regions are simple rectangles
    1:     return (*mRectListHead.next == *aRegion.mRectListHead.next);
    1:   else                                            // At least one is complex region.
    1:   {
    1:     if (mBoundRect != aRegion.mBoundRect)         // If regions are equal then bounding rectangles should match
    1:       return PR_FALSE;
    1:     else
    1:     {
    1:       nsRegion TmpRegion;
    1:       TmpRegion.Xor (*this, aRegion);             // Get difference between two regions
    1: 
    1:       return (TmpRegion.mRectCount == 0);
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: void nsRegion::MoveBy (nsPoint aPt)
    1: {
    1:   if (aPt.x || aPt.y)
    1:   {
    1:     RgnRect* pRect = mRectListHead.next;
    1: 
    1:     while (pRect != &mRectListHead)
    1:     {
    1:       pRect->MoveBy (aPt.x, aPt.y);
    1:       pRect = pRect->next;
    1:     }
    1: 
    1:     mBoundRect.MoveBy (aPt.x, aPt.y);
    1:   }
    1: }
    1: 
    1: void nsRegion::SimplifyOutward (PRUint32 aMaxRects)
    1: {
    1:   NS_ASSERTION(aMaxRects >= 1, "Invalid max rect count");
    1:   
    1:   if (mRectCount <= aMaxRects)
    1:     return;
    1: 
    1:   *this = GetBounds();
    1: }
    1: 
    1: void nsRegion::SimplifyInward (PRUint32 aMaxRects)
    1: {
    1:   NS_ASSERTION(aMaxRects >= 1, "Invalid max rect count");
    1: 
    1:   if (mRectCount <= aMaxRects)
    1:     return;
    1: 
    1:   SetEmpty();
    1: }
    1: 
    1: void nsRegion::SimpleSubtract (const nsRect& aRect)
    1: {
    1:   if (aRect.IsEmpty())
    1:     return;
    1: 
    1:   // protect against aRect being one of our own rectangles
    1:   nsRect param = aRect;
    1:   RgnRect* r = mRectListHead.next;
    1:   while (r != &mRectListHead)
    1:   {
    1:     RgnRect* next = r->next;
    1:     if (param.Contains(*r)) {
    1:       delete Remove(r);
    1:     }
    1:     r = next;
    1:   }
    1:   
    1:   Optimize();
    1: }
    1: 
    1: void nsRegion::SimpleSubtract (const nsRegion& aRegion)
    1: {
    1:   if (aRegion.IsEmpty())
    1:     return;
    1: 
    1:   if (&aRegion == this) {
    1:     SetEmpty();
    1:     return;
    1:   }
    1: 
    1:   const RgnRect* r = aRegion.mRectListHead.next;
    1:   while (r != &aRegion.mRectListHead)
    1:   {
    1:     SimpleSubtract(*r);
    1:     r = r->next;
    1:   }
    1: 
    1:   Optimize();
    1: }
