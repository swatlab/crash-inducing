     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* container for a document and its presentation */
     1: 
     1: #include "nscore.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsCRT.h"
     1: #include "nsString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsISupports.h"
     1: #include "nsIContent.h"
     1: #include "nsIContentViewerContainer.h"
 80401: #include "nsIContentViewer.h"
     1: #include "nsIDocumentViewerPrint.h"
 29522: #include "nsIDOMBeforeUnloadEvent.h"
     1: #include "nsIDocument.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsStyleSet.h"
     1: #include "nsIStyleSheet.h"
 42163: #include "nsCSSStyleSheet.h"
     1: #include "nsIFrame.h"
 54315: #include "nsSubDocumentFrame.h"
     1: 
     1: #include "nsILinkHandler.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsISelectionListener.h"
     1: #include "nsISelectionPrivate.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMHTMLCollection.h"
     1: #include "nsIDOMHTMLElement.h"
     1: #include "nsIDOMRange.h"
     1: #include "nsContentCID.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsContentUtils.h"
     1: #include "nsLayoutStylesheetCache.h"
 70976: #include "mozilla/Preferences.h"
134908: #include "mozilla/dom/EncodingUtils.h"
     1: 
     1: #include "nsIDeviceContextSpec.h"
127607: #include "nsViewManager.h"
127357: #include "nsView.h"
     1: 
     1: #include "nsIPageSequenceFrame.h"
     1: #include "nsIURL.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIContentViewerEdit.h"
     1: #include "nsIContentViewerFile.h"
 47937: #include "mozilla/css/Loader.h"
     1: #include "nsIMarkupDocumentViewer.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIDocShellTreeOwner.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsILayoutHistoryState.h"
 93784: #include "nsCharsetSource.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsHTMLReflowState.h"
     1: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsIDOMHTMLAreaElement.h"
     1: #include "nsIDOMHTMLLinkElement.h"
     1: #include "nsIImageLoadingContent.h"
     1: #include "nsCopySupport.h"
     1: #include "nsIDOMHTMLFrameSetElement.h"
     1: #ifdef MOZ_XUL
     1: #include "nsIXULDocument.h"
  3799: #include "nsXULPopupManager.h"
     1: #endif
     1: 
     1: #include "nsIClipboardHelper.h"
     1: 
     1: #include "nsPIDOMWindow.h"
 72298: #include "nsDOMNavigationTiming.h"
 38336: #include "nsPIWindowRoot.h"
     1: #include "nsJSEnvironment.h"
 29018: #include "nsFocusManager.h"
     1: 
 37067: #include "nsIScrollableFrame.h"
     1: #include "nsIHTMLDocument.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsStyleSheetService.h"
 25034: #include "nsURILoader.h"
 68487: #include "nsRenderingContext.h"
103068: #include "nsILoadContext.h"
     1: 
     1: #include "nsIPrompt.h"
     1: #include "imgIContainer.h" // image animation mode constants
     1: 
     1: //--------------------------
     1: // Printing Include
     1: //---------------------------
     1: #ifdef NS_PRINTING
     1: 
     1: #include "nsIWebBrowserPrint.h"
     1: 
     1: #include "nsPrintEngine.h"
     1: 
     1: // Print Options
     1: #include "nsIPrintSettings.h"
     1: #include "nsIPrintSettingsService.h"
     1: #include "nsIPrintOptions.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsISimpleEnumerator.h"
     1: #include "nsXPCOM.h"
     1: #include "nsISupportsPrimitives.h"
     1: 
     1: // PrintOptions is now implemented by PrintSettingsService
     1: static const char sPrintOptionsContractID[]         = "@mozilla.org/gfx/printsettings-service;1";
     1: 
     1: // Printing Events
     1: #include "nsPrintPreviewListener.h"
     1: 
     1: #include "nsIDOMHTMLFrameElement.h"
     1: #include "nsIDOMHTMLIFrameElement.h"
     1: #include "nsIDOMHTMLObjectElement.h"
     1: #include "nsIPluginDocument.h"
     1: 
     1: // Print Progress
     1: #include "nsIPrintProgress.h"
     1: #include "nsIPrintProgressParams.h"
     1: 
     1: // Print error dialog
     1: #include "nsIWindowWatcher.h"
     1: 
     1: // Printing 
     1: #include "nsPagePrintTimer.h"
     1: 
     1: #endif // NS_PRINTING
     1: 
     1: //focus
  1418: #include "nsIDOMEventTarget.h"
 72631: #include "nsIDOMEventListener.h"
     1: #include "nsISelectionController.h"
     1: 
     1: #include "nsBidiUtils.h"
     1: #include "nsISHEntry.h"
     1: #include "nsISHistory.h"
     1: #include "nsISHistoryInternal.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsWeakPtr.h"
     1: #include "nsEventDispatcher.h"
     1: 
     1: //paint forcing
     1: #include "prenv.h"
     1: #include <stdio.h>
     1: 
 86797: #include "nsObserverService.h"
 86797: 
 74131: #include "mozilla/dom/Element.h"
 74131: 
 88182: #include "jsfriendapi.h"
 88182: 
 70976: using namespace mozilla;
134908: using namespace mozilla::dom;
 70976: 
102909: #ifdef DEBUG
     1: 
     1: #undef NOISY_VIEWER
     1: #else
     1: #undef NOISY_VIEWER
     1: #endif
     1: 
     1: //-----------------------------------------------------
     1: // PR LOGGING
     1: #ifdef MOZ_LOGGING
     1: #define FORCE_PR_LOG /* Allow logging in the release build */
     1: #endif
     1: 
     1: #include "prlog.h"
     1: 
     1: #ifdef PR_LOGGING
     1: 
121210: #ifdef NS_PRINTING
120415: static PRLogModuleInfo *
120415: GetPrintingLog()
120415: {
120415:   static PRLogModuleInfo *sLog;
120415:   if (!sLog)
120415:     sLog = PR_NewLogModule("printing");
120415:   return sLog;
120415: }
120415: #define PR_PL(_p1)  PR_LOG(GetPrintingLog(), PR_LOG_DEBUG, _p1);
121210: #endif // NS_PRINTING
     1: 
     1: #define PRT_YESNO(_p) ((_p)?"YES":"NO")
     1: #else
     1: #define PRT_YESNO(_p)
     1: #define PR_PL(_p1)
     1: #endif
     1: //-----------------------------------------------------
     1: 
124284: class nsDocumentViewer;
111090: class nsPrintEventDispatcher;
     1: 
     1: // a small delegate class used to avoid circular references
     1: 
     1: class nsDocViewerSelectionListener : public nsISelectionListener
     1: {
     1: public:
     1: 
     1:   // nsISupports interface...
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   // nsISelectionListerner interface
     1:   NS_DECL_NSISELECTIONLISTENER
     1: 
     1:                        nsDocViewerSelectionListener()
     1:                        : mDocViewer(NULL)
 80486:                        , mGotSelectionState(false)
 80486:                        , mSelectionWasCollapsed(false)
     1:                        {
     1:                        }
     1: 
     1:   virtual              ~nsDocViewerSelectionListener() {}
     1: 
124284:   nsresult             Init(nsDocumentViewer *aDocViewer);
     1: 
     1: protected:
     1: 
124284:   nsDocumentViewer*  mDocViewer;
 79445:   bool                 mGotSelectionState;
 79445:   bool                 mSelectionWasCollapsed;
     1: 
     1: };
     1: 
     1: 
     1: /** editor Implementation of the FocusListener interface
     1:  */
 72631: class nsDocViewerFocusListener : public nsIDOMEventListener
     1: {
     1: public:
     1:   /** default constructor
     1:    */
     1:   nsDocViewerFocusListener();
     1:   /** default destructor
     1:    */
     1:   virtual ~nsDocViewerFocusListener();
     1: 
     1:   NS_DECL_ISUPPORTS
 72631:   NS_DECL_NSIDOMEVENTLISTENER
 72631: 
124284:   nsresult             Init(nsDocumentViewer *aDocViewer);
     1: 
     1: private:
124284:     nsDocumentViewer*  mDocViewer;
     1: };
     1: 
     1: 
     1: //-------------------------------------------------------------
124284: class nsDocumentViewer : public nsIContentViewer,
     1:                            public nsIContentViewerEdit,
     1:                            public nsIContentViewerFile,
 71056:                            public nsIMarkupDocumentViewer,
     1:                            public nsIDocumentViewerPrint
     1: 
     1: #ifdef NS_PRINTING
     1:                            , public nsIWebBrowserPrint
     1: #endif
     1: 
     1: {
     1:   friend class nsDocViewerSelectionListener;
     1:   friend class nsPagePrintTimer;
     1:   friend class nsPrintEngine;
     1: 
     1: public:
124284:   nsDocumentViewer();
     1: 
     1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
     1: 
     1:   // nsISupports interface...
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   // nsIContentViewer interface...
     1:   NS_DECL_NSICONTENTVIEWER
     1: 
     1:   // nsIContentViewerEdit
     1:   NS_DECL_NSICONTENTVIEWEREDIT
     1: 
     1:   // nsIContentViewerFile
     1:   NS_DECL_NSICONTENTVIEWERFILE
     1: 
     1:   // nsIMarkupDocumentViewer
     1:   NS_DECL_NSIMARKUPDOCUMENTVIEWER
     1: 
     1: #ifdef NS_PRINTING
     1:   // nsIWebBrowserPrint
     1:   NS_DECL_NSIWEBBROWSERPRINT
     1: #endif
     1: 
     1:   typedef void (*CallChildFunc)(nsIMarkupDocumentViewer* aViewer,
     1:                                 void* aClosure);
     1:   void CallChildren(CallChildFunc aFunc, void* aClosure);
     1: 
     1:   // nsIDocumentViewerPrint Printing Methods
     1:   NS_DECL_NSIDOCUMENTVIEWERPRINT
     1: 
 69880: 
 69880:   static void DispatchBeforePrint(nsIDocument* aTop)
 69880:   {
 69880:     DispatchEventToWindowTree(aTop, NS_LITERAL_STRING("beforeprint"));
 69880:   }
 69880:   static void DispatchAfterPrint(nsIDocument* aTop)
 69880:   {
 69880:     DispatchEventToWindowTree(aTop, NS_LITERAL_STRING("afterprint"));
 69880:   }
 69880:   static void DispatchEventToWindowTree(nsIDocument* aTop,
 69880:                                         const nsAString& aEvent);
 69880: 
     1: protected:
124284:   virtual ~nsDocumentViewer();
     1: 
     1: private:
  8519:   /**
  8519:    * Creates a view manager, root view, and widget for the root view, setting
  8519:    * mViewManager and mWindow.
  8519:    * @param aSize the initial size in appunits
 30513:    * @param aContainerView the container view to hook our root view up
 30513:    * to as a child, or null if this will be the root view manager
  8519:    */
127357:   nsresult MakeWindow(const nsSize& aSize, nsView* aContainerView);
 30513: 
 30513:   /**
 17009:    * Create our device context
 17009:    */
127357:   nsresult CreateDeviceContext(nsView* aContainerView);
 17009: 
 17009:   /**
 30537:    * If aDoCreation is true, this creates the device context, creates a
 30537:    * prescontext if necessary, and calls MakeWindow.
 61100:    *
 61100:    * If aForceSetNewDocument is false, then SetNewDocument won't be
 61100:    * called if the window's current document is already mDocument.
 17009:    */
     1:   nsresult InitInternal(nsIWidget* aParentWidget,
     1:                         nsISupports *aState,
 23738:                         const nsIntRect& aBounds,
 79445:                         bool aDoCreation,
 79445:                         bool aNeedMakeCX = true,
 79445:                         bool aForceSetNewDocument = true);
 10100:   /**
 10100:    * @param aDoInitialReflow set to true if you want to kick off the initial
 10100:    * reflow
 10100:    */
 79445:   nsresult InitPresentationStuff(bool aDoInitialReflow);
     1: 
     1:   nsresult GetPopupNode(nsIDOMNode** aNode);
     1:   nsresult GetPopupLinkNode(nsIDOMNode** aNode);
     1:   nsresult GetPopupImageNode(nsIImageLoadingContent** aNode);
     1: 
     1:   void PrepareToStartLoad(void);
     1: 
     1:   nsresult SyncParentSubDocMap();
     1: 
     1:   nsresult GetDocumentSelection(nsISelection **aSelection);
     1: 
 23902:   void DestroyPresShell();
 61100:   void DestroyPresContext();
 23902: 
     1: #ifdef NS_PRINTING
     1:   // Called when the DocViewer is notified that the state
     1:   // of Printing or PP has changed
     1:   void SetIsPrintingInDocShellTree(nsIDocShellTreeNode* aParentNode, 
 79445:                                    bool                 aIsPrintingOrPP, 
 79445:                                    bool                 aStartAtTop);
     1: #endif // NS_PRINTING
     1: 
 62248:   // Whether we should attach to the top level widget. This is true if we
 62248:   // are sharing/recycling a single base widget and not creating multiple
 62248:   // child widgets.
 79445:   bool ShouldAttachToTopLevel();
 62248: 
     1: protected:
  7740:   // These return the current shell/prescontext etc.
  7740:   nsIPresShell* GetPresShell();
  7740:   nsPresContext* GetPresContext();
127607:   nsViewManager* GetViewManager();
  7740: 
 46194:   void DetachFromTopLevelWidget();
 46194: 
     1:   // IMPORTANT: The ownership implicit in the following member
     1:   // variables has been explicitly checked and set using nsCOMPtr
     1:   // for owning pointers and raw COM interface pointers for weak
     1:   // (ie, non owning) references. If you add any members to this
     1:   // class, please make the ownership explicit (pinkerton, scc).
     1: 
     1:   nsWeakPtr mContainer; // it owns me!
 63709:   nsWeakPtr mTopContainerWhilePrinting;
 68668:   nsRefPtr<nsDeviceContext> mDeviceContext;  // We create and own this baby
     1: 
     1:   // the following six items are explicitly in this order
     1:   // so they will be destroyed in the reverse order (pinkerton, scc)
     1:   nsCOMPtr<nsIDocument>    mDocument;
 30537:   nsCOMPtr<nsIWidget>      mWindow;      // may be null
127608:   nsRefPtr<nsViewManager> mViewManager;
 39823:   nsRefPtr<nsPresContext>  mPresContext;
     1:   nsCOMPtr<nsIPresShell>   mPresShell;
     1: 
     1:   nsCOMPtr<nsISelectionListener> mSelectionListener;
 72631:   nsRefPtr<nsDocViewerFocusListener> mFocusListener;
     1: 
     1:   nsCOMPtr<nsIContentViewer> mPreviousViewer;
     1:   nsCOMPtr<nsISHEntry> mSHEntry;
     1: 
 19869:   nsIWidget* mParentWidget; // purposely won't be ref counted.  May be null
 79445:   bool mAttachedToParent; // view is attached to the parent widget
     1: 
 30537:   nsIntRect mBounds;
 30537: 
  7780:   // mTextZoom/mPageZoom record the textzoom/pagezoom of the first (galley)
  7780:   // presshell only.
     1:   float mTextZoom;      // Text zoom, defaults to 1.0
  5357:   float mPageZoom;
 63383:   int mMinFontSize;
     1: 
108991:   int16_t mNumURLStarts;
108991:   int16_t mDestroyRefCount;    // a second "refcount" for the document viewer's "destroy"
     1: 
     1:   unsigned      mStopped : 1;
     1:   unsigned      mLoaded : 1;
     1:   unsigned      mDeferredWindowClose : 1;
     1:   // document management data
     1:   //   these items are specific to markup documents (html and xml)
     1:   //   may consider splitting these out into a subclass
     1:   unsigned      mIsSticky : 1;
     1:   unsigned      mInPermitUnload : 1;
     1: 
     1: #ifdef NS_PRINTING
     1:   unsigned      mClosingWhilePrinting : 1;
     1: 
     1: #if NS_PRINT_PREVIEW
 25840:   unsigned                         mPrintPreviewZoomed : 1;
 25840: 
     1:   // These data members support delayed printing when the document is loading
     1:   unsigned                         mPrintIsPending : 1;
     1:   unsigned                         mPrintDocIsFullyLoaded : 1;
     1:   nsCOMPtr<nsIPrintSettings>       mCachedPrintSettings;
     1:   nsCOMPtr<nsIWebProgressListener> mCachedPrintWebProgressListner;
     1: 
114469:   nsRefPtr<nsPrintEngine>          mPrintEngine;
 25840:   float                            mOriginalPrintPreviewScale;
 25840:   float                            mPrintPreviewZoom;
111090:   nsAutoPtr<nsPrintEventDispatcher> mBeforeAndAfterPrint;
     1: #endif // NS_PRINT_PREVIEW
     1: 
102909: #ifdef DEBUG
     1:   FILE* mDebugFile;
102909: #endif // DEBUG
     1: #endif // NS_PRINTING
     1: 
     1:   /* character set member data */
108991:   int32_t mHintCharsetSource;
     1:   nsCString mHintCharset;
     1:   nsCString mDefaultCharacterSet;
     1:   nsCString mForceCharacterSet;
     1:   nsCString mPrevDocCharacterSet;
     1:   
 79445:   bool mIsPageMode;
 79445:   bool mCallerIsClosingWindow;
 79445:   bool mInitializedForPrintPreview;
 79445:   bool mHidden;
     1: };
     1: 
 69880: class nsPrintEventDispatcher
 69880: {
 69880: public:
 69880:   nsPrintEventDispatcher(nsIDocument* aTop) : mTop(aTop)
 69880:   {
124284:     nsDocumentViewer::DispatchBeforePrint(mTop);
 69880:   }
 69880:   ~nsPrintEventDispatcher()
 69880:   {
124284:     nsDocumentViewer::DispatchAfterPrint(mTop);
 69880:   }
 69880: 
 69880:   nsCOMPtr<nsIDocument> mTop;
 69880: };
 69880: 
 86797: class nsDocumentShownDispatcher : public nsRunnable
 86797: {
 86797: public:
 86797:   nsDocumentShownDispatcher(nsCOMPtr<nsIDocument> aDocument)
 86797:   : mDocument(aDocument) {}
 86797: 
 86797:   NS_IMETHOD Run();
 86797: 
 86797: private:
 86797:   nsCOMPtr<nsIDocument> mDocument;
 86797: };
 86797: 
 69880: 
     1: //------------------------------------------------------------------
124284: // nsDocumentViewer
     1: //------------------------------------------------------------------
     1: 
     1: //------------------------------------------------------------------
     1: nsresult
 80401: NS_NewContentViewer(nsIContentViewer** aResult)
     1: {
124284:   *aResult = new nsDocumentViewer();
     1: 
     1:   NS_ADDREF(*aResult);
     1: 
     1:   return NS_OK;
     1: }
     1: 
124284: void nsDocumentViewer::PrepareToStartLoad()
     1: {
 80486:   mStopped          = false;
 80486:   mLoaded           = false;
 80486:   mAttachedToParent = false;
 80486:   mDeferredWindowClose = false;
 80486:   mCallerIsClosingWindow = false;
     1: 
     1: #ifdef NS_PRINTING
 80486:   mPrintIsPending        = false;
 80486:   mPrintDocIsFullyLoaded = false;
 80486:   mClosingWhilePrinting  = false;
     1: 
     1:   // Make sure we have destroyed it and cleared the data member
     1:   if (mPrintEngine) {
     1:     mPrintEngine->Destroy();
106838:     mPrintEngine = nullptr;
     1: #ifdef NS_PRINT_PREVIEW
 80486:     SetIsPrintPreview(false);
     1: #endif
 35581:   }
     1: 
102909: #ifdef DEBUG
106838:   mDebugFile = nullptr;
     1: #endif
     1: 
     1: #endif // NS_PRINTING
     1: }
     1: 
     1: // Note: operator new zeros our memory, so no need to init things to null.
124284: nsDocumentViewer::nsDocumentViewer()
 63383:   : mTextZoom(1.0), mPageZoom(1.0), mMinFontSize(0),
 80486:     mIsSticky(true),
 25840: #ifdef NS_PRINT_PREVIEW
 25840:     mPrintPreviewZoom(1.0),
 25840: #endif
 35581:     mHintCharsetSource(kCharsetUninitialized),
 80486:     mInitializedForPrintPreview(false),
 80486:     mHidden(false)
     1: {
     1:   PrepareToStartLoad();
     1: }
     1: 
124284: NS_IMPL_ADDREF(nsDocumentViewer)
124284: NS_IMPL_RELEASE(nsDocumentViewer)
124284: 
124284: NS_INTERFACE_MAP_BEGIN(nsDocumentViewer)
     1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewer)
     1:     NS_INTERFACE_MAP_ENTRY(nsIMarkupDocumentViewer)
     1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerFile)
     1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerEdit)
     1:     NS_INTERFACE_MAP_ENTRY(nsIDocumentViewerPrint)
     1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentViewer)
     1: #ifdef NS_PRINTING
     1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserPrint)
     1: #endif
     1: NS_INTERFACE_MAP_END
     1: 
124284: nsDocumentViewer::~nsDocumentViewer()
     1: {
     1:   if (mDocument) {
106838:     Close(nullptr);
     1:     mDocument->Destroy();
     1:   }
     1: 
     1:   NS_ASSERTION(!mPresShell && !mPresContext,
     1:                "User did not call nsIContentViewer::Destroy");
     1:   if (mPresShell || mPresContext) {
     1:     // Make sure we don't hand out a reference to the content viewer to
     1:     // the SHEntry!
106838:     mSHEntry = nullptr;
     1: 
     1:     Destroy();
     1:   }
     1: 
     1:   // XXX(?) Revoke pending invalidate events
     1: }
     1: 
     1: /*
     1:  * This method is called by the Document Loader once a document has
     1:  * been created for a particular data stream...  The content viewer
     1:  * must cache this document for later use when Init(...) is called.
     1:  *
     1:  * This method is also called when an out of band document.write() happens.
     1:  * In that case, the document passed in is the same as the previous document.
     1:  */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::LoadStart(nsISupports *aDoc)
     1: {
     1: #ifdef NOISY_VIEWER
124284:   printf("nsDocumentViewer::LoadStart\n");
     1: #endif
     1: 
     1:   nsresult rv = NS_OK;
     1:   if (!mDocument) {
     1:     mDocument = do_QueryInterface(aDoc, &rv);
     1:   }
     1:   else if (mDocument == aDoc) {
     1:     // Reset the document viewer's state back to what it was
     1:     // when the document load started.
     1:     PrepareToStartLoad();
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
124284: nsDocumentViewer::SyncParentSubDocMap()
     1: {
     1:   nsCOMPtr<nsIDocShellTreeItem> item(do_QueryReferent(mContainer));
     1:   nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(item));
     1:   nsCOMPtr<nsIContent> content;
     1: 
     1:   if (mDocument && pwin) {
     1:     content = do_QueryInterface(pwin->GetFrameElementInternal());
     1:   }
     1: 
     1:   if (content) {
     1:     nsCOMPtr<nsIDocShellTreeItem> parent;
     1:     item->GetParent(getter_AddRefs(parent));
     1: 
     1:     nsCOMPtr<nsIDOMWindow> parent_win(do_GetInterface(parent));
     1: 
     1:     if (parent_win) {
     1:       nsCOMPtr<nsIDOMDocument> dom_doc;
     1:       parent_win->GetDocument(getter_AddRefs(dom_doc));
     1: 
     1:       nsCOMPtr<nsIDocument> parent_doc(do_QueryInterface(dom_doc));
     1: 
     1:       if (parent_doc) {
 81062:         if (mDocument &&
 81062:             parent_doc->GetSubDocumentFor(content) != mDocument) {
 25722:           mDocument->SuppressEventHandling(parent_doc->EventHandlingSuppressed());
 25722:         }
 81062:         return parent_doc->SetSubDocumentFor(content->AsElement(), mDocument);
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetContainer(nsISupports* aContainer)
     1: {
     1:   mContainer = do_GetWeakReference(aContainer);
     1:   if (mPresContext) {
     1:     mPresContext->SetContainer(aContainer);
     1:   }
     1: 
     1:   // We're loading a new document into the window where this document
     1:   // viewer lives, sync the parent document's frame element -> sub
     1:   // document map
     1: 
     1:   return SyncParentSubDocMap();
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetContainer(nsISupports** aResult)
     1: {
     1:    NS_ENSURE_ARG_POINTER(aResult);
     1: 
106838:    *aResult = nullptr;
     1:    nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
     1:    container.swap(*aResult);
     1:    return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Init(nsIWidget* aParentWidget,
 23738:                          const nsIntRect& aBounds)
     1: {
106838:   return InitInternal(aParentWidget, nullptr, aBounds, true);
     1: }
     1: 
     1: nsresult
124284: nsDocumentViewer::InitPresentationStuff(bool aDoInitialReflow)
     1: {
 35581:   if (GetIsPrintPreview())
 35581:     return NS_OK;
 35581: 
 23902:   NS_ASSERTION(!mPresShell,
 23902:                "Someone should have destroyed the presshell!");
 23902: 
     1:   // Create the style set...
     1:   nsStyleSet *styleSet;
     1:   nsresult rv = CreateStyleSet(mDocument, &styleSet);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // Now make the shell for the document
     1:   rv = mDocument->CreateShell(mPresContext, mViewManager, styleSet,
     1:                               getter_AddRefs(mPresShell));
     1:   if (NS_FAILED(rv)) {
     1:     delete styleSet;
     1:     return rv;
     1:   }
     1: 
     1:   // We're done creating the style set
     1:   styleSet->EndUpdate();
     1: 
     1:   if (aDoInitialReflow) {
111413:     // Since Initialize() will create frames for *all* items
     1:     // that are currently in the document tree, we need to flush
     1:     // any pending notifications to prevent the content sink from
     1:     // duplicating layout frames for content it has added to the tree
     1:     // but hasn't notified the document about. (Bug 154018)
     1:     //
     1:     // Note that we are flushing before we add mPresShell as an observer
     1:     // to avoid bogus notifications.
     1: 
     1:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
     1:   }
     1: 
     1:   mPresShell->BeginObservingDocument();
     1: 
     1:   // Initialize our view manager
 30537:   nscoord width = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel() * mBounds.width;
 30537:   nscoord height = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel() * mBounds.height;
     1: 
     1:   mViewManager->SetWindowDimensions(width, height);
     1:   mPresContext->SetTextZoom(mTextZoom);
  5357:   mPresContext->SetFullZoom(mPageZoom);
 63383:   mPresContext->SetMinFontSize(mMinFontSize);
     1: 
     1:   if (aDoInitialReflow) {
  1416:     nsCOMPtr<nsIPresShell> shellGrip = mPresShell;
     1:     // Initial reflow
111413:     mPresShell->Initialize(width, height);
     1:   } else {
     1:     // Store the visible area so it's available for other callers of
111413:     // Initialize, like nsContentSink::StartLayout.
     1:     mPresContext->SetVisibleArea(nsRect(0, 0, width, height));
     1:   }
     1: 
     1:   // now register ourselves as a selection listener, so that we get
     1:   // called when the selection changes in the window
 23902:   if (!mSelectionListener) {
     1:     nsDocViewerSelectionListener *selectionListener =
     1:       new nsDocViewerSelectionListener();
     1: 
     1:     selectionListener->Init(this);
     1: 
     1:     // mSelectionListener is a owning reference
     1:     mSelectionListener = selectionListener;
 23902:   }
     1: 
     1:   nsCOMPtr<nsISelection> selection;
     1:   rv = GetDocumentSelection(getter_AddRefs(selection));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
     1:   rv = selPrivate->AddSelectionListener(mSelectionListener);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   // Save old listener so we can unregister it
 72631:   nsRefPtr<nsDocViewerFocusListener> oldFocusListener = mFocusListener;
     1: 
     1:   // focus listener
     1:   //
     1:   // now register ourselves as a focus listener, so that we get called
     1:   // when the focus changes in the window
 47223:   nsDocViewerFocusListener *focusListener = new nsDocViewerFocusListener();
     1: 
     1:   focusListener->Init(this);
     1: 
     1:   // mFocusListener is a strong reference
     1:   mFocusListener = focusListener;
     1: 
  1418:   if (mDocument) {
 72631:     mDocument->AddEventListener(NS_LITERAL_STRING("focus"),
 72631:                                 mFocusListener,
 80486:                                 false, false);
 72631:     mDocument->AddEventListener(NS_LITERAL_STRING("blur"),
 72631:                                 mFocusListener,
 80486:                                 false, false);
 72631: 
 10100:     if (oldFocusListener) {
 72631:       mDocument->RemoveEventListener(NS_LITERAL_STRING("focus"),
 80486:                                      oldFocusListener, false);
 72631:       mDocument->RemoveEventListener(NS_LITERAL_STRING("blur"),
 80486:                                      oldFocusListener, false);
     1:     }
     1:   }
     1: 
 42357:   if (aDoInitialReflow && mDocument) {
 42357:     mDocument->ScrollToRef();
 42357:   }
 42357: 
     1:   return NS_OK;
     1: }
     1: 
 30514: static nsPresContext*
 30514: CreatePresContext(nsIDocument* aDocument,
 30514:                   nsPresContext::nsPresContextType aType,
127357:                   nsView* aContainerView)
 30514: {
 30514:   if (aContainerView)
 30514:     return new nsPresContext(aDocument, aType);
 30514:   return new nsRootPresContext(aDocument, aType);
 30514: }
 30514: 
     1: //-----------------------------------------------
     1: // This method can be used to initial the "presentation"
     1: // The aDoCreation indicates whether it should create
     1: // all the new objects or just initialize the existing ones
     1: nsresult
124284: nsDocumentViewer::InitInternal(nsIWidget* aParentWidget,
     1:                                  nsISupports *aState,
 23738:                                  const nsIntRect& aBounds,
 79445:                                  bool aDoCreation,
 79445:                                  bool aNeedMakeCX /*= true*/,
 79445:                                  bool aForceSetNewDocument /* = true*/)
     1: {
 61100:   if (mIsPageMode) {
 80486:     // XXXbz should the InitInternal in SetPageMode just pass false
 61100:     // here itself?
 80486:     aForceSetNewDocument = false;
 61100:   }
 61100: 
 35158:   // We don't want any scripts to run here. That can cause flushing,
 35158:   // which can cause reentry into initialization of this document viewer,
 35158:   // which would be disastrous.
 35158:   nsAutoScriptBlocker blockScripts;
 35158: 
     1:   mParentWidget = aParentWidget; // not ref counted
 30537:   mBounds = aBounds;
     1: 
     1:   nsresult rv = NS_OK;
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NULL_POINTER);
     1: 
127357:   nsView* containerView = FindContainerView();
 30513: 
 79445:   bool makeCX = false;
     1:   if (aDoCreation) {
 30537:     nsresult rv = CreateDeviceContext(containerView);
 30537:     NS_ENSURE_SUCCESS(rv, rv);
 30537: 
 20078:     // XXXbz this is a nasty hack to do with the fact that we create
 20078:     // presentations both in Init() and in Show()...  Ideally we would only do
 20078:     // it in one place (Show()) and require that callers call init(), open(),
 20078:     // show() in that order or something.
 30537:     if (!mPresContext &&
 52207:         (aParentWidget || containerView || mDocument->IsBeingUsedAsImage() ||
 49570:          (mDocument->GetDisplayDocument() &&
 49570:           mDocument->GetDisplayDocument()->GetShell()))) {
     1:       // Create presentation context
     1:       if (mIsPageMode) {
     1:         //Presentation context already created in SetPageMode which is calling this method
 30514:       } else {
 30514:         mPresContext = CreatePresContext(mDocument,
 30514:             nsPresContext::eContext_Galley, containerView);
 30514:       }
     1:       NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
     1: 
 17009:       nsresult rv = mPresContext->Init(mDeviceContext); 
     1:       if (NS_FAILED(rv)) {
106838:         mPresContext = nullptr;
     1:         return rv;
     1:       }
     1: 
     1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
     1:       makeCX = !GetIsPrintPreview() && aNeedMakeCX; // needs to be true except when we are already in PP or we are enabling/disabling paginated mode.
     1: #else
 80486:       makeCX = true;
     1: #endif
     1:     }
     1: 
     1:     if (mPresContext) {
     1:       // Create the ViewManager and Root View...
     1: 
     1:       // We must do this before we tell the script global object about
     1:       // this new document since doing that will cause us to re-enter
     1:       // into nsSubDocumentFrame code through reflows caused by
     1:       // FlushPendingNotifications() calls down the road...
     1: 
  8519:       rv = MakeWindow(nsSize(mPresContext->DevPixelsToAppUnits(aBounds.width),
 30513:                              mPresContext->DevPixelsToAppUnits(aBounds.height)),
 30513:                       containerView);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:       Hide();
     1: 
     1: #ifdef NS_PRINT_PREVIEW
     1:       if (mIsPageMode) {
     1:         // I'm leaving this in a broken state for the moment; we should
     1:         // be measuring/scaling with the print device context, not the
     1:         // screen device context, but this is good enough to allow
     1:         // printing reftests to work.
  3540:         double pageWidth = 0, pageHeight = 0;
  3540:         mPresContext->GetPrintSettings()->GetEffectivePageSize(&pageWidth,
     1:                                                                &pageHeight);
     1:         mPresContext->SetPageSize(
 50791:           nsSize(mPresContext->CSSTwipsToAppUnits(NSToIntFloor(pageWidth)),
 50791:                  mPresContext->CSSTwipsToAppUnits(NSToIntFloor(pageHeight))));
 80486:         mPresContext->SetIsRootPaginatedDocument(true);
     1:         mPresContext->SetPageScale(1.0f);
     1:       }
     1: #endif
121657:     } else {
121657:       // Avoid leaking the old viewer.
121657:       if (mPreviousViewer) {
121657:         mPreviousViewer->Destroy();
121657:         mPreviousViewer = nullptr;
121657:       }
     1:     }
     1:   }
     1: 
     1:   nsCOMPtr<nsIInterfaceRequestor> requestor(do_QueryReferent(mContainer));
     1:   if (requestor) {
     1:     if (mPresContext) {
     1:       nsCOMPtr<nsILinkHandler> linkHandler;
     1:       requestor->GetInterface(NS_GET_IID(nsILinkHandler),
     1:                               getter_AddRefs(linkHandler));
     1: 
     1:       mPresContext->SetContainer(requestor);
     1:       mPresContext->SetLinkHandler(linkHandler);
     1:     }
     1: 
     1:     // Set script-context-owner in the document
     1: 
     1:     nsCOMPtr<nsPIDOMWindow> window;
     1:     requestor->GetInterface(NS_GET_IID(nsPIDOMWindow),
     1:                             getter_AddRefs(window));
     1: 
     1:     if (window) {
 39705:       nsCOMPtr<nsIDocument> curDoc =
 39705:         do_QueryInterface(window->GetExtantDocument());
 61100:       if (aForceSetNewDocument || curDoc != mDocument) {
 80486:         window->SetNewDocument(mDocument, aState, false);
     1:         nsJSContext::LoadStart();
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (aDoCreation && mPresContext) {
     1:     // The ViewManager and Root View was created above (in
     1:     // MakeWindow())...
     1: 
 38273:     rv = InitPresentationStuff(!makeCX);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
124284: void nsDocumentViewer::SetNavigationTiming(nsDOMNavigationTiming* timing)
 72298: {
 72298:   NS_ASSERTION(mDocument, "Must have a document to set navigation timing.");
 72298:   if (mDocument) {
 72298:     mDocument->SetNavigationTiming(timing);
 72298:   }
 72298: }
 72298: 
     1: //
     1: // LoadComplete(aStatus)
     1: //
     1: //   aStatus - The status returned from loading the document.
     1: //
     1: // This method is called by the container when the document has been
     1: // completely loaded.
     1: //
     1: NS_IMETHODIMP
124284: nsDocumentViewer::LoadComplete(nsresult aStatus)
     1: {
     1:   /* We need to protect ourself against auto-destruction in case the
     1:      window is closed while processing the OnLoad event.  See bug
     1:      http://bugzilla.mozilla.org/show_bug.cgi?id=78445 for more
     1:      explanation.
     1:   */
124284:   nsRefPtr<nsDocumentViewer> kungFuDeathGrip(this);
     1: 
   971:   // Flush out layout so it's up-to-date by the time onload is called.
   971:   // Note that this could destroy the window, so do this before
   971:   // checking for our mDocument and its window.
   921:   if (mPresShell && !mStopped) {
   921:     // Hold strong ref because this could conceivably run script
   921:     nsCOMPtr<nsIPresShell> shell = mPresShell;
   921:     shell->FlushPendingNotifications(Flush_Layout);
   921:   }
   921: 
 63195:   nsresult rv = NS_OK;
   971:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
   971: 
   971:   // First, get the window from the document...
133684:   nsCOMPtr<nsPIDOMWindow> window = mDocument->GetWindow();
   971: 
 80486:   mLoaded = true;
   971: 
     1:   // Now, fire either an OnLoad or OnError event to the document...
 79445:   bool restoring = false;
 21811:   // XXXbz imagelib kills off the document load for a full-page image with
 25034:   // NS_ERROR_PARSED_DATA_CACHED if it's in the cache.  So we want to treat
 21811:   // that one as a success code; otherwise whether we fire onload for the image
 21811:   // will depend on whether it's cached!
 21811:   if(window &&
 25034:      (NS_SUCCEEDED(aStatus) || aStatus == NS_ERROR_PARSED_DATA_CACHED)) {
     1:     nsEventStatus status = nsEventStatus_eIgnore;
 80486:     nsEvent event(true, NS_LOAD);
126030:     event.mFlags.mBubbles = false;
     1:      // XXX Dispatching to |window|, but using |document| as the target.
     1:     event.target = mDocument;
     1: 
     1:     // If the document presentation is being restored, we don't want to fire
     1:     // onload to the document content since that would likely confuse scripts
     1:     // on the page.
     1: 
     1:     nsIDocShell *docShell = window->GetDocShell();
     1:     NS_ENSURE_TRUE(docShell, NS_ERROR_UNEXPECTED);
     1: 
     1:     docShell->GetRestoringDocument(&restoring);
     1:     if (!restoring) {
137777:       NS_ASSERTION(mDocument->IsXUL() || // readyState for XUL is bogus
106728:                    mDocument->GetReadyStateEnum() ==
106728:                      nsIDocument::READYSTATE_INTERACTIVE ||
106728:                    // test_stricttransportsecurity.html has old-style
106728:                    // docshell-generated about:blank docs reach this code!
106728:                    (mDocument->GetReadyStateEnum() ==
106728:                       nsIDocument::READYSTATE_UNINITIALIZED &&
106728:                     NS_IsAboutBlank(mDocument->GetDocumentURI())),
106728:                    "Bad readystate");
133684:       nsCOMPtr<nsIDocument> d = mDocument;
106728:       mDocument->SetReadyStateInternal(nsIDocument::READYSTATE_COMPLETE);
106728: 
133684:       nsRefPtr<nsDOMNavigationTiming> timing(d->GetNavigationTiming());
 72298:       if (timing) {
 72298:         timing->NotifyLoadEventStart();
 72298:       }
106838:       nsEventDispatcher::Dispatch(window, mPresContext, &event, nullptr,
     1:                                   &status);
 72298:       if (timing) {
 72298:         timing->NotifyLoadEventEnd();
 72298:       }
     1:     }
     1:   } else {
     1:     // XXX: Should fire error event to the document...
     1:   }
     1: 
     1:   // Notify the document that it has been shown (regardless of whether
     1:   // it was just loaded). Note: mDocument may be null now if the above
     1:   // firing of onload caused the document to unload.
 34446:   if (mDocument) {
 34446:     // Re-get window, since it might have changed during above firing of onload
 34446:     window = mDocument->GetWindow();
 34446:     if (window) {
 34446:       nsIDocShell *docShell = window->GetDocShell();
 79445:       bool isInUnload;
 36696:       if (docShell && NS_SUCCEEDED(docShell->GetIsInUnload(&isInUnload)) &&
 36696:           !isInUnload) {
106838:         mDocument->OnPageShow(restoring, nullptr);
 34446:       }
 34446:     }
 34446:   }
     1: 
     1:   // Now that the document has loaded, we can tell the presshell
     1:   // to unsuppress painting.
     1:   if (mPresShell && !mStopped) {
 14187:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell);
     1:     mPresShell->UnsuppressPainting();
 14187:     // mPresShell could have been removed now, see bug 378682/421432
 14187:     if (mPresShell) {
 12356:       mPresShell->ScrollToAnchor();
     1:     }
 14187:   }
     1: 
  7080:   nsJSContext::LoadEnd();
     1: 
     1: #ifdef NS_PRINTING
     1:   // Check to see if someone tried to print during the load
     1:   if (mPrintIsPending) {
 80486:     mPrintIsPending        = false;
 80486:     mPrintDocIsFullyLoaded = true;
     1:     Print(mCachedPrintSettings, mCachedPrintWebProgressListner);
106838:     mCachedPrintSettings           = nullptr;
106838:     mCachedPrintWebProgressListner = nullptr;
     1:   }
     1: #endif
     1: 
 63195:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::PermitUnload(bool aCallerClosesWindow, bool *aPermitUnload)
     1: {
 80486:   *aPermitUnload = true;
     1: 
 34032:   if (!mDocument || mInPermitUnload || mCallerIsClosingWindow) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // First, get the script global object from the document...
     1:   nsPIDOMWindow *window = mDocument->GetWindow();
     1: 
     1:   if (!window) {
     1:     // This is odd, but not fatal
     1:     NS_WARNING("window not set for document!");
     1:     return NS_OK;
     1:   }
     1: 
 13098:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(), "This is unsafe");
 13098: 
     1:   // Now, fire an BeforeUnload event to the document and see if it's ok
     1:   // to unload...
 70359:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(mDocument);
 29522:   nsCOMPtr<nsIDOMEvent> event;
 70359:   domDoc->CreateEvent(NS_LITERAL_STRING("beforeunloadevent"),
 29522:                       getter_AddRefs(event));
 29522:   nsCOMPtr<nsIDOMBeforeUnloadEvent> beforeUnload = do_QueryInterface(event);
101616:   NS_ENSURE_STATE(beforeUnload);
 29522:   nsresult rv = event->InitEvent(NS_LITERAL_STRING("beforeunload"),
 80486:                                  false, true);
 29522:   NS_ENSURE_SUCCESS(rv, rv);
 29522: 
101616:   // Dispatching to |window|, but using |document| as the target.
101616:   event->SetTarget(mDocument);
101616:   event->SetTrusted(true);
     1: 
     1:   // In evil cases we might be destroyed while handling the
     1:   // onbeforeunload event, don't let that happen. (see also bug#331040)
124284:   nsRefPtr<nsDocumentViewer> kungFuDeathGrip(this);
     1: 
     1:   {
     1:     // Never permit popups from the beforeunload handler, no matter
     1:     // how we get here.
 80486:     nsAutoPopupStatePusher popupStatePusher(openAbused, true);
 80486: 
 80486:     mInPermitUnload = true;
106838:     nsEventDispatcher::DispatchDOMEvent(window, nullptr, event, mPresContext,
106838:                                         nullptr);
 80486:     mInPermitUnload = false;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
 29522:   nsAutoString text;
 29522:   beforeUnload->GetReturnValue(text);
126032:   if (event->GetInternalNSEvent()->mFlags.mDefaultPrevented ||
 29522:       !text.IsEmpty()) {
     1:     // Ask the user if it's ok to unload the current page
     1: 
     1:     nsCOMPtr<nsIPrompt> prompt = do_GetInterface(docShellNode);
     1: 
     1:     if (prompt) {
 54135:       nsXPIDLString title, message, stayLabel, leaveLabel;
     1:       rv  = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
 54135:                                                "OnBeforeUnloadTitle",
 54135:                                                title);
106850:       nsresult tmp = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
 54135:                                                "OnBeforeUnloadMessage",
 54135:                                                message);
106850:       if (NS_FAILED(tmp)) {
106850:         rv = tmp;
106850:       }
106850:       tmp = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
 54135:                                                "OnBeforeUnloadLeaveButton",
 54135:                                                leaveLabel);
106850:       if (NS_FAILED(tmp)) {
106850:         rv = tmp;
106850:       }
106850:       tmp = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
 54135:                                                "OnBeforeUnloadStayButton",
 54135:                                                stayLabel);
106850:       if (NS_FAILED(tmp)) {
106850:         rv = tmp;
106850:       }
 54135: 
 54135:       if (NS_FAILED(rv) || !title || !message || !stayLabel || !leaveLabel) {
     1:         NS_ERROR("Failed to get strings from dom.properties!");
     1:         return NS_OK;
     1:       }
     1: 
 71081:       // Although the exact value is ignored, we must not pass invalid
 79445:       // bool values through XPConnect.
 79445:       bool dummy = false;
108991:       int32_t buttonPressed = 0;
108991:       uint32_t buttonFlags = (nsIPrompt::BUTTON_POS_0_DEFAULT |
 54135:                              (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_0) |
 54135:                              (nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_1));
 54135: 
 94465:       nsAutoSyncOperation sync(mDocument);
 54135:       rv = prompt->ConfirmEx(title, message, buttonFlags,
106838:                              leaveLabel, stayLabel, nullptr, nullptr,
 54135:                              &dummy, &buttonPressed);
 54135:       NS_ENSURE_SUCCESS(rv, rv);
 54135: 
 54135:       // Button 0 == leave, button 1 == stay
 54135:       *aPermitUnload = (buttonPressed == 0);
     1:     }
     1:   }
     1: 
     1:   if (docShellNode) {
108991:     int32_t childCount;
     1:     docShellNode->GetChildCount(&childCount);
     1: 
108991:     for (int32_t i = 0; i < childCount && *aPermitUnload; ++i) {
     1:       nsCOMPtr<nsIDocShellTreeItem> item;
     1:       docShellNode->GetChildAt(i, getter_AddRefs(item));
     1: 
     1:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(item));
     1: 
     1:       if (docShell) {
     1:         nsCOMPtr<nsIContentViewer> cv;
     1:         docShell->GetContentViewer(getter_AddRefs(cv));
     1: 
     1:         if (cv) {
 34032:           cv->PermitUnload(aCallerClosesWindow, aPermitUnload);
 34032:         }
 34032:       }
 34032:     }
 34032:   }
 34032: 
 34032:   if (aCallerClosesWindow && *aPermitUnload)
 80486:     mCallerIsClosingWindow = true;
 34032: 
 34032:   return NS_OK;
 34032: }
 34032: 
 34032: NS_IMETHODIMP
124284: nsDocumentViewer::ResetCloseWindow()
 34032: {
 80486:   mCallerIsClosingWindow = false;
 34032: 
 34032:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
 34032:   if (docShellNode) {
108991:     int32_t childCount;
 34032:     docShellNode->GetChildCount(&childCount);
 34032: 
108991:     for (int32_t i = 0; i < childCount; ++i) {
 34032:       nsCOMPtr<nsIDocShellTreeItem> item;
 34032:       docShellNode->GetChildAt(i, getter_AddRefs(item));
 34032: 
 34032:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(item));
 34032: 
 34032:       if (docShell) {
 34032:         nsCOMPtr<nsIContentViewer> cv;
 34032:         docShell->GetContentViewer(getter_AddRefs(cv));
 34032: 
 34032:         if (cv) {
 34032:           cv->ResetCloseWindow();
 34032:         }
 34032:       }
 34032:     }
 34032:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::PageHide(bool aIsUnload)
     1: {
 80486:   mHidden = true;
     1: 
     1:   if (!mDocument) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
106838:   mDocument->OnPageHide(!aIsUnload, nullptr);
 29018: 
 29018:   // inform the window so that the focus state is reset.
 29018:   NS_ENSURE_STATE(mDocument);
 29018:   nsPIDOMWindow *window = mDocument->GetWindow();
 29018:   if (window)
 29018:     window->PageHidden();
 29018: 
     1:   if (aIsUnload) {
 62725:     // Poke the GC. The window might be collectable garbage now.
136640:     nsJSContext::PokeGC(JS::gcreason::PAGE_HIDE, NS_GC_DELAY * 2);
 62725: 
106838:     // if Destroy() was called during OnPageHide(), mDocument is nullptr.
     1:     NS_ENSURE_STATE(mDocument);
     1: 
     1:     // First, get the window from the document...
     1:     nsPIDOMWindow *window = mDocument->GetWindow();
     1: 
     1:     if (!window) {
     1:       // Fail if no window is available...
 39690:       NS_WARNING("window not set for document!");
     1:       return NS_ERROR_NULL_POINTER;
     1:     }
     1: 
     1:     // Now, fire an Unload event to the document...
     1:     nsEventStatus status = nsEventStatus_eIgnore;
 80486:     nsEvent event(true, NS_PAGE_UNLOAD);
126030:     event.mFlags.mBubbles = false;
     1:     // XXX Dispatching to |window|, but using |document| as the target.
     1:     event.target = mDocument;
     1: 
     1:     // Never permit popups from the unload handler, no matter how we get
     1:     // here.
 80486:     nsAutoPopupStatePusher popupStatePusher(openAbused, true);
     1: 
106838:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nullptr, &status);
     1:   }
     1: 
  3799: #ifdef MOZ_XUL
     1:   // look for open menupopups and close them after the unload event, in case
     1:   // the unload event listeners open any new popups
 11414:   nsContentUtils::HidePopupsInDocument(mDocument);
  3799: #endif
   825: 
   825:   return NS_OK;
     1: }
     1: 
     1: static void
     1: AttachContainerRecurse(nsIDocShell* aShell)
     1: {
     1:   nsCOMPtr<nsIContentViewer> viewer;
     1:   aShell->GetContentViewer(getter_AddRefs(viewer));
 80401:   if (viewer) {
 80401:     nsIDocument* doc = viewer->GetDocument();
     1:     if (doc) {
     1:       doc->SetContainer(aShell);
     1:     }
 39823:     nsRefPtr<nsPresContext> pc;
 80401:     viewer->GetPresContext(getter_AddRefs(pc));
     1:     if (pc) {
     1:       pc->SetContainer(aShell);
     1:       pc->SetLinkHandler(nsCOMPtr<nsILinkHandler>(do_QueryInterface(aShell)));
     1:     }
     1:     nsCOMPtr<nsIPresShell> presShell;
 80401:     viewer->GetPresShell(getter_AddRefs(presShell));
     1:     if (presShell) {
106838:       presShell->SetForwardingContainer(nullptr);
     1:     }
     1:   }
     1: 
     1:   // Now recurse through the children
108991:   int32_t childCount;
132686:   aShell->GetChildCount(&childCount);
108991:   for (int32_t i = 0; i < childCount; ++i) {
     1:     nsCOMPtr<nsIDocShellTreeItem> childItem;
132686:     aShell->GetChildAt(i, getter_AddRefs(childItem));
     1:     AttachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(childItem)));
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Open(nsISupports *aState, nsISHEntry *aSHEntry)
     1: {
     1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
     1: 
 20078:   if (mDocument)
 20078:     mDocument->SetContainer(nsCOMPtr<nsISupports>(do_QueryReferent(mContainer)));
 20078: 
 80486:   nsresult rv = InitInternal(mParentWidget, aState, mBounds, false);
 19919:   NS_ENSURE_SUCCESS(rv, rv);
 19919: 
 80486:   mHidden = false;
 68689: 
     1:   if (mPresShell)
106838:     mPresShell->SetForwardingContainer(nullptr);
     1: 
     1:   // Rehook the child presentations.  The child shells are still in
     1:   // session history, so get them from there.
     1: 
 19869:   if (aSHEntry) {
     1:     nsCOMPtr<nsIDocShellTreeItem> item;
108991:     int32_t itemIndex = 0;
     1:     while (NS_SUCCEEDED(aSHEntry->ChildShellAt(itemIndex++,
     1:                                                getter_AddRefs(item))) && item) {
     1:       AttachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(item)));
     1:     }
 19869:   }
     1:   
     1:   SyncParentSubDocMap();
     1: 
  1418:   if (mFocusListener && mDocument) {
 72631:     mDocument->AddEventListener(NS_LITERAL_STRING("focus"), mFocusListener,
 80486:                                 false, false);
 72631:     mDocument->AddEventListener(NS_LITERAL_STRING("blur"), mFocusListener,
 80486:                                 false, false);
     1:   }
     1: 
     1:   // XXX re-enable image animations once that works correctly
     1: 
     1:   PrepareToStartLoad();
 62248: 
 62248:   // When loading a page from the bfcache with puppet widgets, we do the
 62248:   // widget attachment here (it is otherwise done in MakeWindow, which is
 62248:   // called for non-bfcache pages in the history, but not bfcache pages).
 62248:   // Attachment is necessary, since we get detached when another page
 62248:   // is browsed to. That is, if we are one page A, then when we go to
 62248:   // page B, we detach. So page A's view has no widget. If we then go
 62248:   // back to it, and it is in the bfcache, we will use that view, which
 62248:   // doesn't have a widget. The attach call here will properly attach us.
 62248:   if (nsIWidget::UsePuppetWidgets() && mPresContext &&
 62248:       ShouldAttachToTopLevel()) {
 62248:     // If the old view is already attached to our parent, detach
 62248:     DetachFromTopLevelWidget();
 62248: 
127607:     nsViewManager *vm = GetViewManager();
 62248:     NS_ABORT_IF_FALSE(vm, "no view manager");
127357:     nsView* v = vm->GetRootView();
 62248:     NS_ABORT_IF_FALSE(v, "no root view");
 62248:     NS_ABORT_IF_FALSE(mParentWidget, "no mParentWidget to set");
 62248:     v->AttachToTopLevelWidget(mParentWidget);
 62248: 
 80486:     mAttachedToParent = true;
 62248:   }
 62248: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Close(nsISHEntry *aSHEntry)
     1: {
     1:   // All callers are supposed to call close to break circular
     1:   // references.  If we do this stuff in the destructor, the
     1:   // destructor might never be called (especially if we're being
     1:   // used from JS.
     1: 
     1:   mSHEntry = aSHEntry;
     1: 
     1:   // Close is also needed to disable scripts during paint suppression,
     1:   // since we transfer the existing global object to the new document
     1:   // that is loaded.  In the future, the global object may become a proxy
     1:   // for an object that can be switched in and out so that we don't need
     1:   // to disable scripts during paint suppression.
     1: 
     1:   if (!mDocument)
     1:     return NS_OK;
     1: 
     1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
     1:   // Turn scripting back on
     1:   // after PrintPreview had turned it off
     1:   if (GetIsPrintPreview() && mPrintEngine) {
 80486:     mPrintEngine->TurnScriptingOn(true);
     1:   }
     1: #endif
     1: 
     1: #ifdef NS_PRINTING
     1:   // A Close was called while we were printing
     1:   // so don't clear the ScriptGlobalObject
     1:   // or clear the mDocument below
     1:   if (mPrintEngine && !mClosingWhilePrinting) {
 80486:     mClosingWhilePrinting = true;
     1:   } else
     1: #endif
     1:     {
 28078:       // out of band cleanup of docshell
106838:       mDocument->SetScriptGlobalObject(nullptr);
     1: 
 22959:       if (!mSHEntry && mDocument)
 14469:         mDocument->RemovedFromDocShell();
     1:     }
     1: 
  1418:   if (mFocusListener && mDocument) {
 72631:     mDocument->RemoveEventListener(NS_LITERAL_STRING("focus"), mFocusListener,
 80486:                                    false);
 72631:     mDocument->RemoveEventListener(NS_LITERAL_STRING("blur"), mFocusListener,
 80486:                                    false);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: DetachContainerRecurse(nsIDocShell *aShell)
     1: {
     1:   // Unhook this docshell's presentation
     1:   nsCOMPtr<nsIContentViewer> viewer;
     1:   aShell->GetContentViewer(getter_AddRefs(viewer));
 80401:   if (viewer) {
 80401:     nsIDocument* doc = viewer->GetDocument();
     1:     if (doc) {
106838:       doc->SetContainer(nullptr);
     1:     }
 39823:     nsRefPtr<nsPresContext> pc;
 80401:     viewer->GetPresContext(getter_AddRefs(pc));
     1:     if (pc) {
106838:       pc->SetContainer(nullptr);
106838:       pc->SetLinkHandler(nullptr);
     1:     }
     1:     nsCOMPtr<nsIPresShell> presShell;
 80401:     viewer->GetPresShell(getter_AddRefs(presShell));
     1:     if (presShell) {
     1:       presShell->SetForwardingContainer(nsWeakPtr(do_GetWeakReference(aShell)));
     1:     }
     1:   }
     1: 
     1:   // Now recurse through the children
108991:   int32_t childCount;
132686:   aShell->GetChildCount(&childCount);
108991:   for (int32_t i = 0; i < childCount; ++i) {
     1:     nsCOMPtr<nsIDocShellTreeItem> childItem;
132686:     aShell->GetChildAt(i, getter_AddRefs(childItem));
     1:     DetachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(childItem)));
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Destroy()
     1: {
     1:   NS_ASSERTION(mDocument, "No document in Destroy()!");
     1: 
     1: #ifdef NS_PRINTING
 23839:   // Here is where we check to see if the document was still being prepared 
     1:   // for printing when it was asked to be destroy from someone externally
 23839:   // This usually happens if the document is unloaded while the user is in the
 23839:   // Print Dialog
     1:   //
     1:   // So we flip the bool to remember that the document is going away
     1:   // and we can clean up and abort later after returning from the Print Dialog
     1:   if (mPrintEngine) {
     1:     if (mPrintEngine->CheckBeforeDestroy()) {
     1:       return NS_OK;
     1:     }
     1:   }
111090:   mBeforeAndAfterPrint = nullptr;
     1: #endif
     1: 
     1:   // Don't let the document get unloaded while we are printing.
     1:   // this could happen if we hit the back button during printing.
     1:   // We also keep the viewer from being cached in session history, since
     1:   // we require all documents there to be sanitized.
     1:   if (mDestroyRefCount != 0) {
     1:     --mDestroyRefCount;
     1:     return NS_OK;
     1:   }
     1: 
     1:   // If we were told to put ourselves into session history instead of destroy
     1:   // the presentation, do that now.
     1:   if (mSHEntry) {
     1:     if (mPresShell)
     1:       mPresShell->Freeze();
     1: 
     1:     // Make sure the presentation isn't torn down by Hide().
     1:     mSHEntry->SetSticky(mIsSticky);
 80486:     mIsSticky = true;
     1: 
126488:     bool savePresentation = mDocument ? mDocument->IsBFCachingAllowed() : true;
     1: 
     1:     // Remove our root view from the view hierarchy.
     1:     if (mPresShell) {
127607:       nsViewManager *vm = mPresShell->GetViewManager();
     1:       if (vm) {
127357:         nsView *rootView = vm->GetRootView();
     1: 
     1:         if (rootView) {
 62099:           // The invalidate that removing this view causes is dropped because
 62099:           // the Freeze call above sets painting to be suppressed for our
 62099:           // document. So we do it ourselves and make it happen.
 87353:           vm->InvalidateViewNoSuppression(rootView,
 87340:             rootView->GetBounds() - rootView->GetPosition());
 62099: 
127357:           nsView *rootViewParent = rootView->GetParent();
     1:           if (rootViewParent) {
127607:             nsViewManager *parentVM = rootViewParent->GetViewManager();
     1:             if (parentVM) {
     1:               parentVM->RemoveChild(rootView);
     1:             }
     1:           }
     1:         }
     1:       }
     1:     }
     1: 
     1:     Hide();
     1: 
     1:     // This is after Hide() so that the user doesn't see the inputs clear.
     1:     if (mDocument) {
     1:       nsresult rv = mDocument->Sanitize();
     1:       if (NS_FAILED(rv)) {
     1:         // If we failed to sanitize, don't save presentation.
 58185:         // XXX Shouldn't we run all the stuff after the |if (mSHEntry)| then?
 80486:         savePresentation = false;
     1:       }
     1:     }
     1: 
     1: 
     1:     // Reverse ownership. Do this *after* calling sanitize so that sanitize
     1:     // doesn't cause mutations that make the SHEntry drop the presentation
 62556: 
 62556:     // Grab a reference to mSHEntry before calling into things like
 62556:     // SyncPresentationState that might mess with our members.
     1:     nsCOMPtr<nsISHEntry> shEntry = mSHEntry; // we'll need this below
106838:     mSHEntry = nullptr;
     1: 
 62556:     if (savePresentation) {
 62556:       shEntry->SetContentViewer(this);
 62556:     }
 62556: 
 62556:     // Always sync the presentation state.  That way even if someone screws up
 62556:     // and shEntry has no window state at this point we'll be ok; we just won't
 62556:     // cache ourselves.
 62556:     shEntry->SyncPresentationState();
 62556: 
     1:     // Break the link from the document/presentation to the docshell, so that
     1:     // link traversals cannot affect the currently-loaded document.
     1:     // When the presentation is restored, Open() and InitInternal() will reset
     1:     // these pointers to their original values.
     1: 
 58185:     if (mDocument) {
106838:       mDocument->SetContainer(nullptr);
 58185:     }
     1:     if (mPresContext) {
106838:       mPresContext->SetLinkHandler(nullptr);
106838:       mPresContext->SetContainer(nullptr);
     1:     }
     1:     if (mPresShell)
     1:       mPresShell->SetForwardingContainer(mContainer);
     1: 
     1:     // Do the same for our children.  Note that we need to get the child
     1:     // docshells from the SHEntry now; the docshell will have cleared them.
     1:     nsCOMPtr<nsIDocShellTreeItem> item;
108991:     int32_t itemIndex = 0;
     1:     while (NS_SUCCEEDED(shEntry->ChildShellAt(itemIndex++,
     1:                                               getter_AddRefs(item))) && item) {
     1:       DetachContainerRecurse(nsCOMPtr<nsIDocShell>(do_QueryInterface(item)));
     1:     }
     1: 
     1:     return NS_OK;
     1:   }
     1: 
 58185:   // The document was not put in the bfcache
 58185: 
128753:   if (mPresShell) {
128753:     DestroyPresShell();
128753:   }
     1:   if (mDocument) {
     1:     mDocument->Destroy();
106838:     mDocument = nullptr;
     1:   }
     1: 
     1:   // All callers are supposed to call destroy to break circular
     1:   // references.  If we do this stuff in the destructor, the
     1:   // destructor might never be called (especially if we're being
     1:   // used from JS.
     1: 
 14111: #ifdef NS_PRINTING
 14111:   if (mPrintEngine) {
 14111: #ifdef NS_PRINT_PREVIEW
 79445:     bool doingPrintPreview;
 14111:     mPrintEngine->GetDoingPrintPreview(&doingPrintPreview);
 14111:     if (doingPrintPreview) {
 14111:       mPrintEngine->FinishPrintPreview();
 14111:     }
 14111: #endif
 14111: 
 14111:     mPrintEngine->Destroy();
106838:     mPrintEngine = nullptr;
 14111:   }
 14111: #endif
 14111: 
     1:   // Avoid leaking the old viewer.
     1:   if (mPreviousViewer) {
     1:     mPreviousViewer->Destroy();
106838:     mPreviousViewer = nullptr;
106838:   }
106838: 
106838:   mDeviceContext = nullptr;
     1: 
     1:   if (mPresContext) {
 61100:     DestroyPresContext();
     1:   }
     1: 
106838:   mWindow = nullptr;
106838:   mViewManager = nullptr;
106838:   mContainer = nullptr;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Stop(void)
     1: {
     1:   NS_ASSERTION(mDocument, "Stop called too early or too late");
     1:   if (mDocument) {
     1:     mDocument->StopDocumentLoad();
     1:   }
     1: 
 38273:   if (!mHidden && (mLoaded || mStopped) && mPresContext && !mSHEntry)
     1:     mPresContext->SetImageAnimationMode(imgIContainer::kDontAnimMode);
     1: 
 80486:   mStopped = true;
     1: 
     1:   if (!mLoaded && mPresShell) {
     1:     // Well, we might as well paint what we have so far.
   867:     nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
     1:     mPresShell->UnsuppressPainting();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetDOMDocument(nsIDOMDocument **aResult)
     1: {
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
     1:   return CallQueryInterface(mDocument, aResult);
     1: }
     1: 
 37433: NS_IMETHODIMP_(nsIDocument *)
124284: nsDocumentViewer::GetDocument()
 37433: {
 37433:   return mDocument;
 37433: }
 37433: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetDOMDocument(nsIDOMDocument *aDocument)
     1: {
     1:   // Assumptions:
     1:   //
     1:   // 1) this document viewer has been initialized with a call to Init().
     1:   // 2) the stylesheets associated with the document have been added
     1:   // to the document.
     1: 
     1:   // XXX Right now, this method assumes that the layout of the current
     1:   // document hasn't started yet.  More cleanup will probably be
     1:   // necessary to make this method work for the case when layout *has*
     1:   // occurred for the current document.
     1:   // That work can happen when and if it is needed.
     1: 
     1:   if (!aDocument)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
 53996:   nsCOMPtr<nsIDocument> newDoc = do_QueryInterface(aDocument);
 53996:   NS_ENSURE_TRUE(newDoc, NS_ERROR_UNEXPECTED);
 53996: 
 80486:   return SetDocumentInternal(newDoc, false);
 53996: }
 53996: 
 53996: NS_IMETHODIMP
124284: nsDocumentViewer::SetDocumentInternal(nsIDocument* aDocument,
 79445:                                         bool aForceReuseInnerWindow)
 53996: {
101132:   MOZ_ASSERT(aDocument);
     1: 
     1:   // Set new container
     1:   nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
 53996:   aDocument->SetContainer(container);
 53996: 
 53996:   if (mDocument != aDocument) {
 71899:     if (mDocument->IsStaticDocument()) {
106838:       mDocument->SetScriptGlobalObject(nullptr);
 71899:       mDocument->Destroy();
 71899:     }
     1:     // Replace the old document with the new one. Do this only when
     1:     // the new document really is a new document.
 53996:     mDocument = aDocument;
     1: 
     1:     // Set the script global object on the new document
     1:     nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(container);
     1:     if (window) {
106838:       window->SetNewDocument(aDocument, nullptr, aForceReuseInnerWindow);
     1:     }
     1: 
 61100:     // Clear the list of old child docshells. Child docshells for the new
     1:     // document will be constructed as frames are created.
 53996:     if (!aDocument->IsStaticDocument()) {
     1:       nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(container);
     1:       if (node) {
108991:         int32_t count;
     1:         node->GetChildCount(&count);
108991:         for (int32_t i = 0; i < count; ++i) {
     1:           nsCOMPtr<nsIDocShellTreeItem> child;
     1:           node->GetChildAt(0, getter_AddRefs(child));
     1:           node->RemoveChild(child);
     1:         }
     1:       }
     1:     }
 35581:   }
     1: 
 53996:   nsresult rv = SyncParentSubDocMap();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // Replace the current pres shell with a new shell for the new document
     1: 
     1:   if (mPresShell) {
 61100:     DestroyPresShell();
  8519:   }
  8519: 
     1:   if (mPresContext) {
 61100:     DestroyPresContext();
 61100: 
106838:     mWindow = nullptr;
106838:     InitInternal(mParentWidget, nullptr, mBounds, true, true, false);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
  7740: nsIPresShell*
124284: nsDocumentViewer::GetPresShell()
  7740: {
  7740:   return mPresShell;
  7740: }
  7740: 
  7740: nsPresContext*
124284: nsDocumentViewer::GetPresContext()
  7740: {
  7740:   return mPresContext;
  7740: }
  7740: 
127607: nsViewManager*
124284: nsDocumentViewer::GetViewManager()
  7740: {
  7740:   return mViewManager;
  7740: }
  7740: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetPresShell(nsIPresShell** aResult)
     1: {
  7740:   nsIPresShell* shell = GetPresShell();
  7740:   NS_IF_ADDREF(*aResult = shell);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetPresContext(nsPresContext** aResult)
     1: {
  7740:   nsPresContext* pc = GetPresContext();
  7740:   NS_IF_ADDREF(*aResult = pc);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetBounds(nsIntRect& aResult)
     1: {
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
 30537:   aResult = mBounds;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetPreviousViewer(nsIContentViewer** aViewer)
     1: {
     1:   *aViewer = mPreviousViewer;
     1:   NS_IF_ADDREF(*aViewer);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetPreviousViewer(nsIContentViewer* aViewer)
     1: {
     1:   // NOTE:  |Show| sets |mPreviousViewer| to null without calling this
     1:   // function.
     1: 
     1:   if (aViewer) {
     1:     NS_ASSERTION(!mPreviousViewer,
     1:                  "can't set previous viewer when there already is one");
     1: 
     1:     // In a multiple chaining situation (which occurs when running a thrashing
     1:     // test like i-bench or jrgm's tests with no delay), we can build up a
     1:     // whole chain of viewers.  In order to avoid this, we always set our previous
     1:     // viewer to the MOST previous viewer in the chain, and then dump the intermediate
     1:     // link from the chain.  This ensures that at most only 2 documents are alive
     1:     // and undestroyed at any given time (the one that is showing and the one that
     1:     // is loading with painting suppressed).
  6685:     // It's very important that if this ever gets changed the code
  6685:     // before the RestorePresentation call in nsDocShell::InternalLoad
  6685:     // be changed accordingly.
     1:     nsCOMPtr<nsIContentViewer> prevViewer;
     1:     aViewer->GetPreviousViewer(getter_AddRefs(prevViewer));
     1:     if (prevViewer) {
106838:       aViewer->SetPreviousViewer(nullptr);
     1:       aViewer->Destroy();
     1:       return SetPreviousViewer(prevViewer);
     1:     }
     1:   }
     1: 
     1:   mPreviousViewer = aViewer;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetBounds(const nsIntRect& aBounds)
     1: {
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
     1: 
 30537:   mBounds = aBounds;
     1:   if (mWindow) {
119748:     if (!mAttachedToParent) {
     1:       // Don't have the widget repaint. Layout will generate repaint requests
 46194:       // during reflow.
 46194:       mWindow->Resize(aBounds.x, aBounds.y,
 46194:                       aBounds.width, aBounds.height,
 80486:                       false);
 83107:     }
 30537:   } else if (mPresContext && mViewManager) {
108991:     int32_t p2a = mPresContext->AppUnitsPerDevPixel();
 30537:     mViewManager->SetWindowDimensions(NSIntPixelsToAppUnits(mBounds.width, p2a),
 30537:                                       NSIntPixelsToAppUnits(mBounds.height, p2a));
     1:   }
     1: 
     1:   // If there's a previous viewer, it's the one that's actually showing,
     1:   // so be sure to resize it as well so it paints over the right area.
     1:   // This may slow down the performance of the new page load, but resize
     1:   // during load is also probably a relatively unusual condition
     1:   // relating to things being hidden while something is loaded.  It so
     1:   // happens that Firefox does this a good bit with its infobar, and it
     1:   // looks ugly if we don't do this.
114538:   if (mPreviousViewer) {
114538:     nsCOMPtr<nsIContentViewer> previousViewer = mPreviousViewer;
114538:     previousViewer->SetBounds(aBounds);
114538:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Move(int32_t aX, int32_t aY)
     1: {
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
 30537:   mBounds.MoveTo(aX, aY);
     1:   if (mWindow) {
     1:     mWindow->Move(aX, aY);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Show(void)
     1: {
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
     1: 
     1:   // We don't need the previous viewer anymore since we're not
     1:   // displaying it.
     1:   if (mPreviousViewer) {
     1:     // This little dance *may* only be to keep
     1:     // PresShell::EndObservingDocument happy, but I'm not sure.
     1:     nsCOMPtr<nsIContentViewer> prevViewer(mPreviousViewer);
106838:     mPreviousViewer = nullptr;
     1:     prevViewer->Destroy();
     1: 
     1:     // Make sure we don't have too many cached ContentViewers
     1:     nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryReferent(mContainer);
     1:     if (treeItem) {
     1:       // We need to find the root DocShell since only that object has an
     1:       // SHistory and we need the SHistory to evict content viewers
     1:       nsCOMPtr<nsIDocShellTreeItem> root;
     1:       treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
     1:       nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(root);
     1:       nsCOMPtr<nsISHistory> history;
     1:       webNav->GetSessionHistory(getter_AddRefs(history));
     1:       nsCOMPtr<nsISHistoryInternal> historyInt = do_QueryInterface(history);
     1:       if (historyInt) {
108991:         int32_t prevIndex,loadedIndex;
 19870:         nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(treeItem);
 19870:         docShell->GetPreviousTransIndex(&prevIndex);
 19870:         docShell->GetLoadedTransIndex(&loadedIndex);
     1: #ifdef DEBUG_PAGE_CACHE
 19870:         printf("About to evict content viewers: prev=%d, loaded=%d\n",
 19870:                prevIndex, loadedIndex);
     1: #endif
 80731:         historyInt->EvictOutOfRangeContentViewers(loadedIndex);
     1:       }
     1:     }
     1:   }
     1: 
 47783:   if (mWindow) {
 55866:     // When attached to a top level xul window, we do not need to call
 55866:     // Show on the widget. Underlying window management code handles
 55866:     // this when the window is initialized.
 55866:     if (!mAttachedToParent) {
 80486:       mWindow->Show(true);
     1:     }
 48796:   }
     1: 
 30537:   if (mDocument && !mPresShell) {
 30537:     NS_ASSERTION(!mWindow, "Window already created but no presshell?");
 30537: 
     1:     nsCOMPtr<nsIBaseWindow> base_win(do_QueryReferent(mContainer));
 19869:     if (base_win) {
     1:       base_win->GetParentWidget(&mParentWidget);
 30537:       if (mParentWidget) {
  4482:         mParentWidget->Release(); // GetParentWidget AddRefs, but mParentWidget is weak
 19869:       }
 30537:     }
 30537: 
127357:     nsView* containerView = FindContainerView();
 30537: 
 30537:     nsresult rv = CreateDeviceContext(containerView);
 17009:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Create presentation context
     1:     NS_ASSERTION(!mPresContext, "Shouldn't have a prescontext if we have no shell!");
 30514:     mPresContext = CreatePresContext(mDocument,
 30514:         nsPresContext::eContext_Galley, containerView);
     1:     NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     rv = mPresContext->Init(mDeviceContext);
     1:     if (NS_FAILED(rv)) {
106838:       mPresContext = nullptr;
     1:       return rv;
     1:     }
     1: 
 30537:     rv = MakeWindow(nsSize(mPresContext->DevPixelsToAppUnits(mBounds.width),
 30537:                            mPresContext->DevPixelsToAppUnits(mBounds.height)),
 30513:                            containerView);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     if (mPresContext && base_win) {
     1:       nsCOMPtr<nsILinkHandler> linkHandler(do_GetInterface(base_win));
     1: 
     1:       if (linkHandler) {
     1:         mPresContext->SetLinkHandler(linkHandler);
     1:       }
     1: 
     1:       mPresContext->SetContainer(base_win);
     1:     }
     1: 
     1:     if (mPresContext) {
     1:       Hide();
     1: 
 38273:       rv = InitPresentationStuff(mDocument->MayStartLayout());
     1:     }
     1: 
     1:     // If we get here the document load has already started and the
     1:     // window is shown because some JS on the page caused it to be
     1:     // shown...
     1: 
 35581:     if (mPresShell) {
   867:       nsCOMPtr<nsIPresShell> shellDeathGrip(mPresShell); // bug 378682
     1:       mPresShell->UnsuppressPainting();
     1:     }
 35581:   }
     1: 
 93070:   // Notify observers that a new page has been shown. This will get run
 93070:   // from the event loop after we actually draw the page.
 86797:   NS_DispatchToMainThread(new nsDocumentShownDispatcher(mDocument));
 86797: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Hide(void)
     1: {
 56344:   if (!mAttachedToParent && mWindow) {
 80486:     mWindow->Show(false);
     1:   }
     1: 
     1:   if (!mPresShell)
     1:     return NS_OK;
     1: 
     1:   NS_ASSERTION(mPresContext, "Can't have a presshell and no prescontext!");
     1: 
     1:   // Avoid leaking the old viewer.
     1:   if (mPreviousViewer) {
     1:     mPreviousViewer->Destroy();
106838:     mPreviousViewer = nullptr;
     1:   }
     1: 
     1:   if (mIsSticky) {
     1:     // This window is sticky, that means that it might be shown again
     1:     // and we don't want the presshell n' all that to be thrown away
     1:     // just because the window is hidden.
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
     1:   if (docShell) {
     1:     nsCOMPtr<nsILayoutHistoryState> layoutState;
121999:     mPresShell->CaptureHistoryState(getter_AddRefs(layoutState));
     1:   }
     1: 
 23902:   DestroyPresShell();
 23902: 
 61100:   DestroyPresContext();
 61100: 
106838:   mViewManager   = nullptr;
106838:   mWindow        = nullptr;
106838:   mDeviceContext = nullptr;
106838:   mParentWidget  = nullptr;
     1: 
     1:   nsCOMPtr<nsIBaseWindow> base_win(do_QueryReferent(mContainer));
     1: 
 56344:   if (base_win && !mAttachedToParent) {
106838:     base_win->SetParentWidget(nullptr);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetSticky(bool *aSticky)
     1: {
     1:   *aSticky = mIsSticky;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetSticky(bool aSticky)
     1: {
     1:   mIsSticky = aSticky;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::RequestWindowClose(bool* aCanClose)
     1: {
     1: #ifdef NS_PRINTING
     1:   if (mPrintIsPending || (mPrintEngine && mPrintEngine->GetIsPrinting())) {
 80486:     *aCanClose = false;
 80486:     mDeferredWindowClose = true;
     1:   } else
     1: #endif
 80486:     *aCanClose = true;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: static bool
     1: AppendAgentSheet(nsIStyleSheet *aSheet, void *aData)
     1: {
  3233:   nsStyleSet *styleSet = static_cast<nsStyleSet*>(aData);
     1:   styleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
 80486:   return true;
     1: }
     1: 
 79445: static bool
     1: PrependUserSheet(nsIStyleSheet *aSheet, void *aData)
     1: {
  3233:   nsStyleSet *styleSet = static_cast<nsStyleSet*>(aData);
     1:   styleSet->PrependStyleSheet(nsStyleSet::eUserSheet, aSheet);
 80486:   return true;
     1: }
     1: 
     1: nsresult
124284: nsDocumentViewer::CreateStyleSet(nsIDocument* aDocument,
     1:                                    nsStyleSet** aStyleSet)
     1: {
     1:   // Make sure this does the same thing as PresShell::AddSheet wrt ordering.
     1: 
     1:   // this should eventually get expanded to allow for creating
     1:   // different sets for different media
     1:   nsStyleSet *styleSet = new nsStyleSet();
     1: 
     1:   styleSet->BeginUpdate();
     1:   
     1:   // The document will fill in the document sheets when we create the presshell
     1:   
     1:   // Handle the user sheets.
106838:   nsCSSStyleSheet* sheet = nullptr;
 20078:   if (nsContentUtils::IsInChromeDocshell(aDocument)) {
     1:     sheet = nsLayoutStylesheetCache::UserChromeSheet();
     1:   }
     1:   else {
     1:     sheet = nsLayoutStylesheetCache::UserContentSheet();
     1:   }
     1: 
     1:   if (sheet)
     1:     styleSet->AppendStyleSheet(nsStyleSet::eUserSheet, sheet);
     1: 
     1:   // Append chrome sheets (scrollbars + forms).
 79445:   bool shouldOverride = false;
 20078:   // We don't want a docshell here for external resource docs, so just
 20078:   // look at mContainer.
 20078:   nsCOMPtr<nsIDocShell> ds(do_QueryReferent(mContainer));
     1:   nsCOMPtr<nsIDOMEventTarget> chromeHandler;
     1:   nsCOMPtr<nsIURI> uri;
 42163:   nsRefPtr<nsCSSStyleSheet> csssheet;
     1: 
 19869:   if (ds) {
     1:     ds->GetChromeEventHandler(getter_AddRefs(chromeHandler));
 19869:   }
     1:   if (chromeHandler) {
     1:     nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(chromeHandler));
     1:     nsCOMPtr<nsIContent> content(do_QueryInterface(elt));
     1:     if (elt && content) {
     1:       nsCOMPtr<nsIURI> baseURI = content->GetBaseURI();
     1: 
     1:       nsAutoString sheets;
     1:       elt->GetAttribute(NS_LITERAL_STRING("usechromesheets"), sheets);
     1:       if (!sheets.IsEmpty() && baseURI) {
 38851:         nsRefPtr<mozilla::css::Loader> cssLoader = new mozilla::css::Loader();
     1: 
     1:         char *str = ToNewCString(sheets);
     1:         char *newStr = str;
     1:         char *token;
     1:         while ( (token = nsCRT::strtok(newStr, ", ", &newStr)) ) {
106838:           NS_NewURI(getter_AddRefs(uri), nsDependentCString(token), nullptr,
     1:                     baseURI);
     1:           if (!uri) continue;
     1: 
     1:           cssLoader->LoadSheetSync(uri, getter_AddRefs(csssheet));
 41523:           if (!csssheet) continue;
     1: 
     1:           styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, csssheet);
 80486:           shouldOverride = true;
     1:         }
     1:         nsMemory::Free(str);
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (!shouldOverride) {
     1:     sheet = nsLayoutStylesheetCache::ScrollbarsSheet();
     1:     if (sheet) {
     1:       styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
     1:     }
     1:   }
     1: 
     1:   sheet = nsLayoutStylesheetCache::FormsSheet();
     1:   if (sheet) {
     1:     styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, sheet);
     1:   }
     1: 
 82957:   sheet = nsLayoutStylesheetCache::FullScreenOverrideSheet();
 82957:   if (sheet) {
 82957:     styleSet->PrependStyleSheet(nsStyleSet::eOverrideSheet, sheet);
 82957:   }
 82957: 
 21209:   // Make sure to clone the quirk sheet so that it can be usefully
 21209:   // enabled/disabled as needed.
 42163:   nsRefPtr<nsCSSStyleSheet> quirkClone;
 42163:   nsCSSStyleSheet* quirkSheet;
 21209:   if (!nsLayoutStylesheetCache::UASheet() ||
 42162:       !(quirkSheet = nsLayoutStylesheetCache::QuirkSheet()) ||
106838:       !(quirkClone = quirkSheet->Clone(nullptr, nullptr, nullptr, nullptr)) ||
 21209:       !sheet) {
 21209:     delete styleSet;
 21209:     return NS_ERROR_OUT_OF_MEMORY;
 21209:   }
 21209:   // quirk.css needs to come after the regular UA sheet (or more precisely,
 21209:   // after the html.css and so forth that the UA sheet imports).
 21209:   styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet, quirkClone);
 21209:   styleSet->SetQuirkStyleSheet(quirkClone);
 21209:   styleSet->PrependStyleSheet(nsStyleSet::eAgentSheet,
 21209:                               nsLayoutStylesheetCache::UASheet());
     1: 
119109:   nsStyleSheetService *sheetService = nsStyleSheetService::GetInstance();
     1:   if (sheetService) {
     1:     sheetService->AgentStyleSheets()->EnumerateForwards(AppendAgentSheet,
     1:                                                         styleSet);
     1:     sheetService->UserStyleSheets()->EnumerateBackwards(PrependUserSheet,
     1:                                                         styleSet);
     1:   }
     1: 
     1:   // Caller will handle calling EndUpdate, per contract.
     1:   *aStyleSet = styleSet;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::ClearHistoryEntry()
     1: {
106838:   mSHEntry = nullptr;
     1:   return NS_OK;
     1: }
     1: 
     1: //-------------------------------------------------------
     1: 
     1: nsresult
127357: nsDocumentViewer::MakeWindow(const nsSize& aSize, nsView* aContainerView)
     1: {
 35581:   if (GetIsPrintPreview())
 35581:     return NS_OK;
 35581: 
 79445:   bool shouldAttach = ShouldAttachToTopLevel();
 62248: 
 62248:   if (shouldAttach) {
 46194:     // If the old view is already attached to our parent, detach
 46194:     DetachFromTopLevelWidget();
 62248:   }
 46194: 
127609:   mViewManager = new nsViewManager();
     1: 
 68668:   nsDeviceContext *dx = mPresContext->DeviceContext();
     1: 
127609:   nsresult rv = mViewManager->Init(dx);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 30513:   // The root view is always at 0,0.
 30513:   nsRect tbounds(nsPoint(0, 0), aSize);
 30513:   // Create a view
127357:   nsView* view = mViewManager->CreateView(tbounds, aContainerView);
 30513:   if (!view)
 30513:     return NS_ERROR_OUT_OF_MEMORY;
 30513: 
 51048:   // Create a widget if we were given a parent widget or don't have a
 52208:   // container view that we can hook up to without a widget.
 52209:   // Don't create widgets for ResourceDocs (external resources & svg images),
 52209:   // because when they're displayed, they're painted into *another* document's
 52209:   // widget.
 52209:   if (!mDocument->IsResourceDoc() &&
 52208:       (mParentWidget || !aContainerView)) {
 30513:     // pass in a native widget to be the parent widget ONLY if the view hierarchy will stand alone.
 30513:     // otherwise the view will find its own parent widget and "do the right thing" to
 30513:     // establish a parent/child widget relationship
 30513:     nsWidgetInitData initData;
 30513:     nsWidgetInitData* initDataPtr;
 30513:     if (!mParentWidget) {
 30513:       initDataPtr = &initData;
 30513:       initData.mWindowType = eWindowType_invisible;
 30513:     } else {
106838:       initDataPtr = nullptr;
 30513:     }
 46194: 
 62248:     if (shouldAttach) {
 46194:       // Reuse the top level parent widget.
 46194:       rv = view->AttachToTopLevelWidget(mParentWidget);
 80486:       mAttachedToParent = true;
 46194:     }
 51048:     else if (!aContainerView && mParentWidget) {
 51050:       rv = view->CreateWidgetForParent(mParentWidget, initDataPtr,
 80486:                                        true, false);
 51048:     }
 46194:     else {
 80486:       rv = view->CreateWidget(initDataPtr, true, false);
 46194:     }
 30513:     if (NS_FAILED(rv))
 30513:       return rv;
 30537:   }
 30513: 
 30513:   // Setup hierarchical relationship in view manager
 30513:   mViewManager->SetRootView(view);
 30513: 
 30513:   mWindow = view->GetWidget();
 30513: 
 30513:   // This SetFocus is necessary so the Arrow Key and Page Key events
 30513:   // go to the scrolled view as soon as the Window is created instead of going to
 30513:   // the browser window (this enables keyboard scrolling of the document)
 30513:   // mWindow->SetFocus();
 30513: 
 30513:   return rv;
 30513: }
 30513: 
 46194: void
124284: nsDocumentViewer::DetachFromTopLevelWidget()
 46194: {
 46194:   if (mViewManager) {
127357:     nsView* oldView = mViewManager->GetRootView();
 46194:     if (oldView && oldView->IsAttachedToTopLevel()) {
 46194:       oldView->DetachFromTopLevelWidget();
 46194:     }
 46194:   }
 80486:   mAttachedToParent = false;
 46194: }
 46194: 
127357: nsView*
124284: nsDocumentViewer::FindContainerView()
 30513: {
127357:   nsView* containerView = nullptr;
 30537: 
 51635:   if (mContainer) {
 30537:     nsCOMPtr<nsIDocShellTreeItem> docShellItem = do_QueryReferent(mContainer);
 30537:     nsCOMPtr<nsPIDOMWindow> pwin(do_GetInterface(docShellItem));
 30537:     if (pwin) {
 51634:       nsCOMPtr<nsIContent> containerElement = do_QueryInterface(pwin->GetFrameElementInternal());
 78878:       if (!containerElement) {
106838:         return nullptr;
 78878:       }
 30537:       nsCOMPtr<nsIPresShell> parentPresShell;
 30537:       if (docShellItem) {
 30537:         nsCOMPtr<nsIDocShellTreeItem> parentDocShellItem;
 30537:         docShellItem->GetParent(getter_AddRefs(parentDocShellItem));
 30537:         if (parentDocShellItem) {
 30537:           nsCOMPtr<nsIDocShell> parentDocShell = do_QueryInterface(parentDocShellItem);
127381:           parentPresShell = parentDocShell->GetPresShell();
 30537:         }
 30537:       }
 78878:       if (!parentPresShell) {
 51185:         nsCOMPtr<nsIDocument> parentDoc = containerElement->GetCurrentDoc();
 51185:         if (parentDoc) {
 51185:           parentPresShell = parentDoc->GetShell();
 51185:         }
 51185:       }
 78878:       if (!parentPresShell) {
 31952:         NS_WARNING("Subdocument container has no presshell");
 31952:       } else {
 38958:         nsIFrame* f = parentPresShell->GetRealPrimaryFrameFor(containerElement);
 30537:         if (f) {
 30537:           nsIFrame* subdocFrame = f->GetContentInsertionFrame();
 30537:           // subdocFrame might not be a subdocument frame; the frame
 30537:           // constructor can treat a <frame> as an inline in some XBL
 30537:           // cases. Treat that as display:none, the document is not
 30537:           // displayed.
 30537:           if (subdocFrame->GetType() == nsGkAtoms::subDocumentFrame) {
 54315:             NS_ASSERTION(subdocFrame->GetView(), "Subdoc frames must have views");
127357:             nsView* innerView =
 54315:               static_cast<nsSubDocumentFrame*>(subdocFrame)->EnsureInnerView();
 30537:             containerView = innerView;
 31952:           } else {
 31952:             NS_WARNING("Subdocument container has non-subdocument frame");
 31952:           }
 31952:         } else {
 31952:           NS_WARNING("Subdocument container has no frame");
 30537:         }
 30537:       }
 30537:     }
 30537:   }
 30537: 
 38958:   return containerView;
     1: }
     1: 
 17009: nsresult
127357: nsDocumentViewer::CreateDeviceContext(nsView* aContainerView)
 17009: {
 39705:   NS_PRECONDITION(!mPresShell && !mWindow,
 19869:                   "This will screw up our existing presentation");
 20078:   NS_PRECONDITION(mDocument, "Gotta have a document here");
 20078:   
 20078:   nsIDocument* doc = mDocument->GetDisplayDocument();
 20078:   if (doc) {
 30537:     NS_ASSERTION(!aContainerView, "External resource document embedded somewhere?");
 20078:     // We want to use our display document's device context if possible
 46225:     nsIPresShell* shell = doc->GetShell();
 20078:     if (shell) {
 20078:       nsPresContext* ctx = shell->GetPresContext();
 20078:       if (ctx) {
 20078:         mDeviceContext = ctx->DeviceContext();
 20078:         return NS_OK;
 20078:       }
 20078:     }
 20078:   }
 20078:   
 19869:   // Create a device context even if we already have one, since our widget
 19869:   // might have changed.
106838:   nsIWidget* widget = nullptr;
 30537:   if (aContainerView) {
106838:     widget = aContainerView->GetNearestWidget(nullptr);
 31621:   }
 31621:   if (!widget) {
 31621:     widget = mParentWidget;
 31621:   }
 30537:   if (widget) {
 30537:     widget = widget->GetTopLevelWidget();
 30537:   }
 31621: 
 68667:   mDeviceContext = new nsDeviceContext();
 30537:   mDeviceContext->Init(widget);
 17009:   return NS_OK;
 17009: }
 17009: 
     1: // Return the selection for the document. Note that text fields have their
 39646: // own selection, which cannot be accessed with this method.
124284: nsresult nsDocumentViewer::GetDocumentSelection(nsISelection **aSelection)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aSelection);
     1:   if (!mPresShell) {
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   }
     1: 
     1:   nsCOMPtr<nsISelectionController> selcon;
     1:   selcon = do_QueryInterface(mPresShell);
     1:   if (selcon)
     1:     return selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
     1:                                 aSelection);
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: /* ========================================================================================
     1:  * nsIContentViewerEdit
     1:  * ======================================================================================== */
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::ClearSelection()
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsISelection> selection;
     1: 
 39646:   // use nsCopySupport::GetSelectionForCopy() ?
     1:   rv = GetDocumentSelection(getter_AddRefs(selection));
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   return selection->CollapseToStart();
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SelectAll()
     1: {
     1:   // XXX this is a temporary implementation copied from nsWebShell
     1:   // for now. I think nsDocument and friends should have some helper
     1:   // functions to make this easier.
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult rv;
     1: 
 39646:   // use nsCopySupport::GetSelectionForCopy() ?
     1:   rv = GetDocumentSelection(getter_AddRefs(selection));
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   nsCOMPtr<nsIDOMHTMLDocument> htmldoc = do_QueryInterface(mDocument);
     1:   nsCOMPtr<nsIDOMNode> bodyNode;
     1: 
     1:   if (htmldoc)
     1:   {
     1:     nsCOMPtr<nsIDOMHTMLElement>bodyElement;
     1:     rv = htmldoc->GetBody(getter_AddRefs(bodyElement));
     1:     if (NS_FAILED(rv) || !bodyElement) return rv;
     1: 
     1:     bodyNode = do_QueryInterface(bodyElement);
     1:   }
     1:   else if (mDocument)
     1:   {
 41634:     bodyNode = do_QueryInterface(mDocument->GetRootElement());
     1:   }
     1:   if (!bodyNode) return NS_ERROR_FAILURE;
     1: 
     1:   rv = selection->RemoveAllRanges();
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = selection->SelectAllChildren(bodyNode);
     1:   return rv;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::CopySelection()
     1: {
106838:   nsCopySupport::FireClipboardEvent(NS_COPY, mPresShell, nullptr);
 39646:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::CopyLinkLocation()
     1: {
     1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   GetPopupLinkNode(getter_AddRefs(node));
     1:   // make noise if we're not in a link
     1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
 99308:   nsCOMPtr<dom::Element> elm(do_QueryInterface(node));
 99308:   NS_ENSURE_TRUE(elm, NS_ERROR_FAILURE);
 99308: 
     1:   nsAutoString locationText;
 99308:   nsContentUtils::GetLinkLocation(elm, locationText);
 99308:   if (locationText.IsEmpty())
 99308:     return NS_ERROR_FAILURE;
 99308: 
 99308:   nsresult rv = NS_OK;
     1:   nsCOMPtr<nsIClipboardHelper> clipboard(do_GetService("@mozilla.org/widget/clipboardhelper;1", &rv));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // copy the href onto the clipboard
103068:   nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(mDocument);
103068:   return clipboard->CopyString(locationText, doc);
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::CopyImage(int32_t aCopyFlags)
     1: {
     1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
     1:   nsCOMPtr<nsIImageLoadingContent> node;
     1:   GetPopupImageNode(getter_AddRefs(node));
     1:   // make noise if we're not in an image
     1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
103068:   nsCOMPtr<nsILoadContext> loadContext(do_QueryReferent(mContainer));
103068:   return nsCopySupport::ImageCopy(node, loadContext, aCopyFlags);
     1: }
     1: 
  5538: 
124284: NS_IMETHODIMP nsDocumentViewer::GetCopyable(bool *aCopyable)
     1: {
  4010:   NS_ENSURE_ARG_POINTER(aCopyable);
 39646:   *aCopyable = nsCopySupport::CanCopy(mDocument);
 12176:   return NS_OK;
     1: }
     1: 
     1: /* AString getContents (in string mimeType, in boolean selectionOnly); */
124284: NS_IMETHODIMP nsDocumentViewer::GetContents(const char *mimeType, bool selectionOnly, nsAString& aOutValue)
     1: {
 39646:   aOutValue.Truncate();
 39646: 
     1:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_INITIALIZED);
 39646:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_INITIALIZED);
 39646: 
 39646:   // Now we have the selection.  Make sure it's nonzero:
 39646:   nsCOMPtr<nsISelection> sel;
 39646:   if (selectionOnly) {
 39646:     nsCopySupport::GetSelectionForCopy(mDocument, getter_AddRefs(sel));
 39646:     NS_ENSURE_TRUE(sel, NS_ERROR_FAILURE);
 39646:   
 79445:     bool isCollapsed;
 39646:     sel->GetIsCollapsed(&isCollapsed);
 39646:     if (isCollapsed)
 39646:       return NS_OK;
 39646:   }
 39646: 
 39646:   // call the copy code
 39646:   return nsCopySupport::GetContents(nsDependentCString(mimeType), 0, sel,
 39646:                                     mDocument, aOutValue);
     1: }
     1: 
     1: /* readonly attribute boolean canGetContents; */
124284: NS_IMETHODIMP nsDocumentViewer::GetCanGetContents(bool *aCanGetContents)
     1: {
 39646:   NS_ENSURE_ARG_POINTER(aCanGetContents);
 80486:   *aCanGetContents = false;
 39646:   NS_ENSURE_STATE(mDocument);
 39646:   *aCanGetContents = nsCopySupport::CanCopy(mDocument);
 39646:   return NS_OK;
     1: }
     1: 
     1: 
     1: /* ========================================================================================
     1:  * nsIContentViewerFile
     1:  * ======================================================================================== */
     1: /** ---------------------------------------------------
     1:  *  See documentation above in the nsIContentViewerfile class definition
     1:  *	@update 01/24/00 dwc
     1:  */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Print(bool              aSilent,
     1:                           FILE *            aDebugFile,
     1:                           nsIPrintSettings* aPrintSettings)
     1: {
     1: #ifdef NS_PRINTING
     1:   nsCOMPtr<nsIPrintSettings> printSettings;
     1: 
102909: #ifdef DEBUG
     1:   nsresult rv = NS_ERROR_FAILURE;
     1: 
     1:   mDebugFile = aDebugFile;
     1:   // if they don't pass in a PrintSettings, then make one
     1:   // it will have all the default values
     1:   printSettings = aPrintSettings;
     1:   nsCOMPtr<nsIPrintOptions> printOptions = do_GetService(sPrintOptionsContractID, &rv);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // if they don't pass in a PrintSettings, then make one
106838:     if (printSettings == nullptr) {
     1:       printOptions->CreatePrintSettings(getter_AddRefs(printSettings));
     1:     }
     1:     NS_ASSERTION(printSettings, "You can't PrintPreview without a PrintSettings!");
     1:   }
     1:   if (printSettings) printSettings->SetPrintSilent(aSilent);
 80486:   if (printSettings) printSettings->SetShowPrintProgress(false);
     1: #endif
     1: 
     1: 
106838:   return Print(printSettings, nullptr);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
 73870: /* [noscript] void printWithParent (in nsIDOMWindow aParentWin, in nsIPrintSettings aThePrintSettings, in nsIWebProgressListener aWPListener); */
     1: NS_IMETHODIMP 
124284: nsDocumentViewer::PrintWithParent(nsIDOMWindow*, nsIPrintSettings *aThePrintSettings, nsIWebProgressListener *aWPListener)
     1: {
     1: #ifdef NS_PRINTING
     1:   return Print(aThePrintSettings, aWPListener);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: // nsIContentViewerFile interface
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetPrintable(bool *aPrintable)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPrintable);
     1: 
     1:   *aPrintable = !GetIsPrinting();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsIMarkupDocumentViewer
     1: //*****************************************************************************
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::ScrollToNode(nsIDOMNode* aNode)
     1: {
     1:   NS_ENSURE_ARG(aNode);
     1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
     1:   nsCOMPtr<nsIPresShell> presShell;
     1:   NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(presShell)), NS_ERROR_FAILURE);
     1: 
     1:   // Get the nsIContent interface, because that's what we need to
     1:   // get the primary frame
     1: 
     1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
     1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
     1: 
     1:   // Tell the PresShell to scroll to the primary frame of the content.
 93554:   NS_ENSURE_SUCCESS(
 93554:     presShell->ScrollContentIntoView(content,
 93554:                                      nsIPresShell::ScrollAxis(
 93554:                                        nsIPresShell::SCROLL_TOP,
 93554:                                        nsIPresShell::SCROLL_ALWAYS),
 93554:                                      nsIPresShell::ScrollAxis(),
 56647:                                      nsIPresShell::SCROLL_OVERFLOW_HIDDEN),
     1:     NS_ERROR_FAILURE);
     1:   return NS_OK;
     1: }
     1: 
     1: void
124284: nsDocumentViewer::CallChildren(CallChildFunc aFunc, void* aClosure)
     1: {
     1:   nsCOMPtr<nsIDocShellTreeNode> docShellNode(do_QueryReferent(mContainer));
     1:   if (docShellNode)
     1:   {
108991:     int32_t i;
108991:     int32_t n;
     1:     docShellNode->GetChildCount(&n);
     1:     for (i=0; i < n; i++)
     1:     {
     1:       nsCOMPtr<nsIDocShellTreeItem> child;
     1:       docShellNode->GetChildAt(i, getter_AddRefs(child));
     1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
     1:       NS_ASSERTION(childAsShell, "null child in docshell");
     1:       if (childAsShell)
     1:       {
     1:         nsCOMPtr<nsIContentViewer> childCV;
     1:         childAsShell->GetContentViewer(getter_AddRefs(childCV));
     1:         if (childCV)
     1:         {
     1:           nsCOMPtr<nsIMarkupDocumentViewer> markupCV = do_QueryInterface(childCV);
     1:           if (markupCV) {
     1:             (*aFunc)(markupCV, aClosure);
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
111211: struct LineBoxInfo
111211: {
111211:   nscoord mMaxLineBoxWidth;
111211: };
111211: 
111211: static void
111211: ChangeChildMaxLineBoxWidth(nsIMarkupDocumentViewer* aChild, void* aClosure)
111211: {
111211:   struct LineBoxInfo* lbi = (struct LineBoxInfo*) aClosure;
111211:   aChild->ChangeMaxLineBoxWidth(lbi->mMaxLineBoxWidth);
111211: }
111211: 
  4359: struct ZoomInfo
     1: {
  4359:   float mZoom;
     1: };
     1: 
     1: static void
     1: SetChildTextZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
  4359:   struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
  4359:   aChild->SetTextZoom(ZoomInfo->mZoom);
  4359: }
  4359: 
  4359: static void
 63383: SetChildMinFontSize(nsIMarkupDocumentViewer* aChild, void* aClosure)
 63383: {
 71056:   nsCOMPtr<nsIMarkupDocumentViewer> branch =
 63383:     do_QueryInterface(aChild);
 68822:   branch->SetMinFontSize(NS_PTR_TO_INT32(aClosure));
 63383: }
 63383: 
 63383: static void
  4359: SetChildFullZoom(nsIMarkupDocumentViewer* aChild, void* aClosure)
  4359: {
  4359:   struct ZoomInfo* ZoomInfo = (struct ZoomInfo*) aClosure;
  4359:   aChild->SetFullZoom(ZoomInfo->mZoom);
     1: }
     1: 
 79445: static bool
 20078: SetExtResourceTextZoom(nsIDocument* aDocument, void* aClosure)
 20078: {
 20078:   // Would it be better to enumerate external resource viewers instead?
 46225:   nsIPresShell* shell = aDocument->GetShell();
 20078:   if (shell) {
 20078:     nsPresContext* ctxt = shell->GetPresContext();
 20078:     if (ctxt) {
 20078:       struct ZoomInfo* ZoomInfo = static_cast<struct ZoomInfo*>(aClosure);
 20078:       ctxt->SetTextZoom(ZoomInfo->mZoom);
 20078:     }
 20078:   }
 20078: 
 80486:   return true;
 20078: }
 20078: 
 79445: static bool
 63383: SetExtResourceMinFontSize(nsIDocument* aDocument, void* aClosure)
 63383: {
 63383:   nsIPresShell* shell = aDocument->GetShell();
 63383:   if (shell) {
 63383:     nsPresContext* ctxt = shell->GetPresContext();
 63383:     if (ctxt) {
 68822:       ctxt->SetMinFontSize(NS_PTR_TO_INT32(aClosure));
 63383:     }
 63383:   }
 63383: 
 80486:   return true;
 63383: }
 63383: 
 79445: static bool
 20078: SetExtResourceFullZoom(nsIDocument* aDocument, void* aClosure)
 20078: {
 20078:   // Would it be better to enumerate external resource viewers instead?
 46225:   nsIPresShell* shell = aDocument->GetShell();
 20078:   if (shell) {
 20078:     nsPresContext* ctxt = shell->GetPresContext();
 20078:     if (ctxt) {
 20078:       struct ZoomInfo* ZoomInfo = static_cast<struct ZoomInfo*>(aClosure);
 20078:       ctxt->SetFullZoom(ZoomInfo->mZoom);
 20078:     }
 20078:   }
 20078: 
 80486:   return true;
 20078: }
 20078: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetTextZoom(float aTextZoom)
     1: {
 25840:   if (GetIsPrintPreview()) {
 25840:     return NS_OK;
 25840:   }
 25840: 
     1:   mTextZoom = aTextZoom;
 10730: 
     1:   // Set the text zoom on all children of mContainer (even if our zoom didn't
     1:   // change, our children's zoom may be different, though it would be unusual).
     1:   // Do this first, in case kids are auto-sizing and post reflow commands on
     1:   // our presshell (which should be subsumed into our own style change reflow).
  4359:   struct ZoomInfo ZoomInfo = { aTextZoom };
  4359:   CallChildren(SetChildTextZoom, &ZoomInfo);
     1: 
     1:   // Now change our own zoom
  7740:   nsPresContext* pc = GetPresContext();
  7740:   if (pc && aTextZoom != mPresContext->TextZoom()) {
  7740:       pc->SetTextZoom(aTextZoom);
  7740:   }
  7740: 
 20078:   // And do the external resources
 20078:   mDocument->EnumerateExternalResources(SetExtResourceTextZoom, &ZoomInfo);
 20078: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetTextZoom(float* aTextZoom)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aTextZoom);
  7740:   nsPresContext* pc = GetPresContext();
  7740:   *aTextZoom = pc ? pc->TextZoom() : 1.0f;
     1:   return NS_OK;
     1: }
     1: 
  4003: NS_IMETHODIMP
124284: nsDocumentViewer::SetMinFontSize(int32_t aMinFontSize)
 63383: {
 63383:   if (GetIsPrintPreview()) {
 63383:     return NS_OK;
 63383:   }
 63383: 
 63383:   mMinFontSize = aMinFontSize;
 63383: 
 63383:   // Set the min font on all children of mContainer (even if our min font didn't
 63383:   // change, our children's min font may be different, though it would be unusual).
 63383:   // Do this first, in case kids are auto-sizing and post reflow commands on
 63383:   // our presshell (which should be subsumed into our own style change reflow).
 68822:   CallChildren(SetChildMinFontSize, NS_INT32_TO_PTR(aMinFontSize));
 63383: 
 63383:   // Now change our own min font
 63383:   nsPresContext* pc = GetPresContext();
106838:   if (pc && aMinFontSize != mPresContext->MinFontSize(nullptr)) {
 63383:     pc->SetMinFontSize(aMinFontSize);
 63383:   }
 63383: 
 63383:   // And do the external resources
 68822:   mDocument->EnumerateExternalResources(SetExtResourceMinFontSize,
 68822:                                         NS_INT32_TO_PTR(aMinFontSize));
 63383: 
 63383:   return NS_OK;
 63383: }
 63383: 
 63383: NS_IMETHODIMP
124284: nsDocumentViewer::GetMinFontSize(int32_t* aMinFontSize)
 63383: {
 63383:   NS_ENSURE_ARG_POINTER(aMinFontSize);
 63383:   nsPresContext* pc = GetPresContext();
106838:   *aMinFontSize = pc ? pc->MinFontSize(nullptr) : 0;
 63383:   return NS_OK;
 63383: }
 63383: 
 63383: NS_IMETHODIMP
124284: nsDocumentViewer::SetFullZoom(float aFullZoom)
  4003: {
 25840: #ifdef NS_PRINT_PREVIEW
 25840:   if (GetIsPrintPreview()) {
 25840:     nsPresContext* pc = GetPresContext();
 25840:     NS_ENSURE_TRUE(pc, NS_OK);
 25840:     nsCOMPtr<nsIPresShell> shell = pc->GetPresShell();
 25840:     NS_ENSURE_TRUE(shell, NS_OK);
 25840: 
 25840:     if (!mPrintPreviewZoomed) {
 25840:       mOriginalPrintPreviewScale = pc->GetPrintPreviewScale();
 80486:       mPrintPreviewZoomed = true;
 25840:     }
 25840: 
 25840:     mPrintPreviewZoom = aFullZoom;
 25840:     pc->SetPrintPreviewScale(aFullZoom * mOriginalPrintPreviewScale);
 39668:     nsIPageSequenceFrame* pf = shell->GetPageSequenceFrame();
 25840:     if (pf) {
 25840:       nsIFrame* f = do_QueryFrame(pf);
 25840:       shell->FrameNeedsReflow(f, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);
 25840:     }
 25840: 
 25840:     nsIFrame* rootFrame = shell->GetRootFrame();
 25840:     if (rootFrame) {
115305:       rootFrame->InvalidateFrame();
 25840:     }
 25840:     return NS_OK;
 25840:   }
 25840: #endif
 25840: 
  5357:   mPageZoom = aFullZoom;
  7740: 
  4359:   struct ZoomInfo ZoomInfo = { aFullZoom };
  4359:   CallChildren(SetChildFullZoom, &ZoomInfo);
  7740: 
  7740:   nsPresContext* pc = GetPresContext();
  7740:   if (pc) {
  7740:     pc->SetFullZoom(aFullZoom);
  7740:   }
  7740: 
 20078:   // And do the external resources
 20078:   mDocument->EnumerateExternalResources(SetExtResourceFullZoom, &ZoomInfo);
 20078: 
  4003:   return NS_OK;
  4003: }
  4003: 
  4003: NS_IMETHODIMP
124284: nsDocumentViewer::GetFullZoom(float* aFullZoom)
  4003: {
  4003:   NS_ENSURE_ARG_POINTER(aFullZoom);
 25840: #ifdef NS_PRINT_PREVIEW
 25840:   if (GetIsPrintPreview()) {
 25840:     *aFullZoom = mPrintPreviewZoom;
 25840:     return NS_OK;
 25840:   }
 25840: #endif
 15169:   // Check the prescontext first because it might have a temporary
 15169:   // setting for print-preview
  7740:   nsPresContext* pc = GetPresContext();
 15169:   *aFullZoom = pc ? pc->GetFullZoom() : mPageZoom;
  4003:   return NS_OK;
  4003: }
  4003: 
     1: static void
     1: SetChildAuthorStyleDisabled(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
 79445:   bool styleDisabled  = *static_cast<bool*>(aClosure);
     1:   aChild->SetAuthorStyleDisabled(styleDisabled);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetAuthorStyleDisabled(bool aStyleDisabled)
     1: {
     1:   if (mPresShell) {
     1:     mPresShell->SetAuthorStyleDisabled(aStyleDisabled);
     1:   }
     1:   CallChildren(SetChildAuthorStyleDisabled, &aStyleDisabled);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetAuthorStyleDisabled(bool* aStyleDisabled)
     1: {
     1:   if (mPresShell) {
     1:     *aStyleDisabled = mPresShell->GetAuthorStyleDisabled();
     1:   } else {
 80486:     *aStyleDisabled = false;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetDefaultCharacterSet(nsACString& aDefaultCharacterSet)
     1: {
     1:   if (mDefaultCharacterSet.IsEmpty())
     1:   {
 70976:     const nsAdoptingCString& defCharset =
 70976:       Preferences::GetLocalizedCString("intl.charset.default");
 70976: 
134908:     // Don't let the user break things by setting intl.charset.default to
134908:     // not a rough ASCII superset
134908:     nsAutoCString canonical;
134908:     if (EncodingUtils::FindEncodingForLabel(defCharset, canonical) &&
134908:         EncodingUtils::IsAsciiCompatible(canonical)) {
134908:       mDefaultCharacterSet = canonical;
 70976:     } else {
134908:       mDefaultCharacterSet.AssignLiteral("windows-1252");
     1:     }
 70976:   }
     1:   aDefaultCharacterSet = mDefaultCharacterSet;
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: SetChildDefaultCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
  3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
     1:   aChild->SetDefaultCharacterSet(*charset);
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetDefaultCharacterSet(const nsACString& aDefaultCharacterSet)
     1: {
     1:   mDefaultCharacterSet = aDefaultCharacterSet;  // this does a copy of aDefaultCharacterSet
     1:   // now set the default char set on all children of mContainer
     1:   CallChildren(SetChildDefaultCharacterSet, (void*) &aDefaultCharacterSet);
     1:   return NS_OK;
     1: }
     1: 
     1: // XXX: SEMANTIC CHANGE!
     1: //      returns a copy of the string.  Caller is responsible for freeing result
     1: //      using Recycle(aForceCharacterSet)
124284: NS_IMETHODIMP nsDocumentViewer::GetForceCharacterSet(nsACString& aForceCharacterSet)
     1: {
     1:   aForceCharacterSet = mForceCharacterSet;
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: SetChildForceCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
  3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
     1:   aChild->SetForceCharacterSet(*charset);
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetForceCharacterSet(const nsACString& aForceCharacterSet)
     1: {
     1:   mForceCharacterSet = aForceCharacterSet;
     1:   // now set the force char set on all children of mContainer
     1:   CallChildren(SetChildForceCharacterSet, (void*) &aForceCharacterSet);
     1:   return NS_OK;
     1: }
     1: 
     1: // XXX: SEMANTIC CHANGE!
     1: //      returns a copy of the string.  Caller is responsible for freeing result
     1: //      using Recycle(aHintCharacterSet)
124284: NS_IMETHODIMP nsDocumentViewer::GetHintCharacterSet(nsACString& aHintCharacterSet)
     1: {
     1: 
     1:   if(kCharsetUninitialized == mHintCharsetSource) {
     1:     aHintCharacterSet.Truncate();
     1:   } else {
     1:     aHintCharacterSet = mHintCharset;
     1:     // this can't possibly be right.  we can't set a value just because somebody got a related value!
     1:     //mHintCharsetSource = kCharsetUninitialized;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetHintCharacterSetSource(int32_t *aHintCharacterSetSource)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aHintCharacterSetSource);
     1: 
     1:   *aHintCharacterSetSource = mHintCharsetSource;
     1:   return NS_OK;
     1: }
     1: 
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetPrevDocCharacterSet(nsACString& aPrevDocCharacterSet)
     1: {
     1:   aPrevDocCharacterSet = mPrevDocCharacterSet;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: SetChildPrevDocCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
  3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
     1:   aChild->SetPrevDocCharacterSet(*charset);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetPrevDocCharacterSet(const nsACString& aPrevDocCharacterSet)
     1: {
     1:   mPrevDocCharacterSet = aPrevDocCharacterSet;  
     1:   CallChildren(SetChildPrevDocCharacterSet, (void*) &aPrevDocCharacterSet);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: static void
     1: SetChildHintCharacterSetSource(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
     1:   aChild->SetHintCharacterSetSource(NS_PTR_TO_INT32(aClosure));
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetHintCharacterSetSource(int32_t aHintCharacterSetSource)
     1: {
     1:   mHintCharsetSource = aHintCharacterSetSource;
     1:   // now set the hint char set source on all children of mContainer
     1:   CallChildren(SetChildHintCharacterSetSource,
 68822:                       NS_INT32_TO_PTR(aHintCharacterSetSource));
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: SetChildHintCharacterSet(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
  3233:   const nsACString* charset = static_cast<nsACString*>(aClosure);
     1:   aChild->SetHintCharacterSet(*charset);
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::SetHintCharacterSet(const nsACString& aHintCharacterSet)
     1: {
     1:   mHintCharset = aHintCharacterSet;
     1:   // now set the hint char set on all children of mContainer
     1:   CallChildren(SetChildHintCharacterSet, (void*) &aHintCharacterSet);
     1:   return NS_OK;
     1: }
     1: 
     1: static void
     1: SetChildBidiOptions(nsIMarkupDocumentViewer* aChild, void* aClosure)
     1: {
     1:   aChild->SetBidiOptions(NS_PTR_TO_INT32(aClosure));
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SetBidiTextDirection(uint8_t aTextDirection)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   GetBidiOptions(&bidiOptions);
     1:   SET_BIDI_OPTION_DIRECTION(bidiOptions, aTextDirection);
     1:   SetBidiOptions(bidiOptions);
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetBidiTextDirection(uint8_t* aTextDirection)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   if (aTextDirection) {
     1:     GetBidiOptions(&bidiOptions);
     1:     *aTextDirection = GET_BIDI_OPTION_DIRECTION(bidiOptions);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SetBidiTextType(uint8_t aTextType)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   GetBidiOptions(&bidiOptions);
     1:   SET_BIDI_OPTION_TEXTTYPE(bidiOptions, aTextType);
     1:   SetBidiOptions(bidiOptions);
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetBidiTextType(uint8_t* aTextType)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   if (aTextType) {
     1:     GetBidiOptions(&bidiOptions);
     1:     *aTextType = GET_BIDI_OPTION_TEXTTYPE(bidiOptions);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SetBidiNumeral(uint8_t aNumeral)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   GetBidiOptions(&bidiOptions);
     1:   SET_BIDI_OPTION_NUMERAL(bidiOptions, aNumeral);
     1:   SetBidiOptions(bidiOptions);
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetBidiNumeral(uint8_t* aNumeral)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   if (aNumeral) {
     1:     GetBidiOptions(&bidiOptions);
     1:     *aNumeral = GET_BIDI_OPTION_NUMERAL(bidiOptions);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SetBidiSupport(uint8_t aSupport)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   GetBidiOptions(&bidiOptions);
     1:   SET_BIDI_OPTION_SUPPORT(bidiOptions, aSupport);
     1:   SetBidiOptions(bidiOptions);
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetBidiSupport(uint8_t* aSupport)
     1: {
108991:   uint32_t bidiOptions;
     1: 
     1:   if (aSupport) {
     1:     GetBidiOptions(&bidiOptions);
     1:     *aSupport = GET_BIDI_OPTION_SUPPORT(bidiOptions);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SetBidiOptions(uint32_t aBidiOptions)
     1: {
     1:   if (mPresContext) {
 80486:     mPresContext->SetBidi(aBidiOptions, true); // could cause reflow
     1:   }
     1:   // now set bidi on all children of mContainer
 68822:   CallChildren(SetChildBidiOptions, NS_INT32_TO_PTR(aBidiOptions));
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetBidiOptions(uint32_t* aBidiOptions)
     1: {
     1:   if (aBidiOptions) {
     1:     if (mPresContext) {
     1:       *aBidiOptions = mPresContext->GetBidi();
     1:     }
     1:     else
     1:       *aBidiOptions = IBMBIDI_DEFAULT_BIDI_OPTIONS;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 97800: static void
 97800: AppendChildSubtree(nsIMarkupDocumentViewer* aChild, void* aClosure)
 97800: {
 97800:   nsTArray<nsCOMPtr<nsIMarkupDocumentViewer> >& array =
 97800:     *static_cast<nsTArray<nsCOMPtr<nsIMarkupDocumentViewer> >*>(aClosure);
 97800:   aChild->AppendSubtree(array);
 97800: }
 97800: 
124284: NS_IMETHODIMP nsDocumentViewer::AppendSubtree(nsTArray<nsCOMPtr<nsIMarkupDocumentViewer> >& aArray)
 97800: {
 97800:   aArray.AppendElement(this);
 97800:   CallChildren(AppendChildSubtree, &aArray);
 97800:   return NS_OK;
 97800: }
 97800: 
124284: NS_IMETHODIMP nsDocumentViewer::ChangeMaxLineBoxWidth(int32_t aMaxLineBoxWidth)
111211: {
111211:   // Change the max line box width for all children.
111211:   struct LineBoxInfo lbi = { aMaxLineBoxWidth };
111211:   CallChildren(ChangeChildMaxLineBoxWidth, &lbi);
111211: 
111211:   // Now, change our max line box width.
111211:   // Convert to app units, since our input is in CSS pixels.
111211:   nscoord mlbw = nsPresContext::CSSPixelsToAppUnits(aMaxLineBoxWidth);
111211:   nsIPresShell* presShell = GetPresShell();
111211:   if (presShell) {
111211:     presShell->SetMaxLineBoxWidth(mlbw);
111211:   }
111211: 
111211:   return NS_OK;
111211: }
111211: 
123585: NS_IMETHODIMP
124284: nsDocumentViewer::GetContentSize(int32_t* aWidth, int32_t* aHeight)
     1: {
     1:    NS_ENSURE_TRUE(mDocument, NS_ERROR_NOT_AVAILABLE);
     1: 
 19869:    // Skip doing this on docshell-less documents for now
     1:    nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryReferent(mContainer));
 19869:    NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_NOT_AVAILABLE);
     1:    
     1:    nsCOMPtr<nsIDocShellTreeItem> docShellParent;
     1:    docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
     1: 
     1:    // It's only valid to access this from a top frame.  Doesn't work from
     1:    // sub-frames.
     1:    NS_ENSURE_TRUE(!docShellParent, NS_ERROR_FAILURE);
     1: 
     1:    nsCOMPtr<nsIPresShell> presShell;
     1:    GetPresShell(getter_AddRefs(presShell));
     1:    NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
     1: 
     1:    // Flush out all content and style updates. We can't use a resize reflow
     1:    // because it won't change some sizes that a style change reflow will.
     1:    mDocument->FlushPendingNotifications(Flush_Layout);
     1: 
     1:   nsIFrame *root = presShell->GetRootFrame();
     1:   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
     1: 
     1:   nscoord prefWidth;
     1:   {
 68481:     nsRefPtr<nsRenderingContext> rcx =
 51038:       presShell->GetReferenceRenderingContext();
     1:     NS_ENSURE_TRUE(rcx, NS_ERROR_FAILURE);
     1:     prefWidth = root->GetPrefWidth(rcx);
     1:   }
     1: 
     1:   nsresult rv = presShell->ResizeReflow(prefWidth, NS_UNCONSTRAINEDSIZE);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 39823:    nsRefPtr<nsPresContext> presContext;
     1:    GetPresContext(getter_AddRefs(presContext));
     1:    NS_ENSURE_TRUE(presContext, NS_ERROR_FAILURE);
     1: 
     1:    // so how big is it?
     1:    nsRect shellArea = presContext->GetVisibleArea();
     1:    // Protect against bogus returns here
 12971:    NS_ENSURE_TRUE(shellArea.width != NS_UNCONSTRAINEDSIZE &&
 12971:                   shellArea.height != NS_UNCONSTRAINEDSIZE,
 12971:                   NS_ERROR_FAILURE);
123585: 
123585:    *aWidth = presContext->AppUnitsToDevPixels(shellArea.width);
123585:    *aHeight = presContext->AppUnitsToDevPixels(shellArea.height);
     1: 
     1:    return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMPL_ISUPPORTS1(nsDocViewerSelectionListener, nsISelectionListener)
     1: 
124284: nsresult nsDocViewerSelectionListener::Init(nsDocumentViewer *aDocViewer)
     1: {
     1:   mDocViewer = aDocViewer;
     1:   return NS_OK;
     1: }
     1: 
     1: /*
     1:  * GetPopupNode, GetPopupLinkNode and GetPopupImageNode are helpers
     1:  * for the cmd_copyLink / cmd_copyImageLocation / cmd_copyImageContents family
     1:  * of commands. The focus controller stores the popup node, these retrieve
     1:  * them and munge appropriately. Note that we have to store the popup node
     1:  * rather than retrieving it from EventStateManager::GetFocusedContent because
     1:  * not all content (images included) can receive focus.
     1:  */
     1: 
     1: nsresult
124284: nsDocumentViewer::GetPopupNode(nsIDOMNode** aNode)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aNode);
     1: 
106838:   *aNode = nullptr;
 49309: 
     1:   // get the document
 37433:   nsIDocument* document = GetDocument();
     1:   NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
     1: 
     1:   // get the private dom window
 38336:   nsCOMPtr<nsPIDOMWindow> window(document->GetWindow());
 38336:   NS_ENSURE_TRUE(window, NS_ERROR_NOT_AVAILABLE);
 38336:   if (window) {
 38336:     nsCOMPtr<nsPIWindowRoot> root = window->GetTopWindowRoot();
 38336:     NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
     1: 
     1:     // get the popup node
 49309:     nsCOMPtr<nsIDOMNode> node = root->GetPopupNode();
 49309: #ifdef MOZ_XUL
 49309:     if (!node) {
 49309:       nsPIDOMWindow* rootWindow = root->GetWindow();
 49309:       if (rootWindow) {
 49309:         nsCOMPtr<nsIDocument> rootDoc = do_QueryInterface(rootWindow->GetExtantDocument());
 49309:         if (rootDoc) {
 49309:           nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 49309:           if (pm) {
 49309:             node = pm->GetLastTriggerPopupNode(rootDoc);
 49309:           }
 49309:         }
 49309:       }
 49309:     }
 49309: #endif
 49309:     node.swap(*aNode);
 38336:   }
     1: 
 37433:   return NS_OK;
     1: }
     1: 
     1: // GetPopupLinkNode: return popup link node or fail
     1: nsresult
124284: nsDocumentViewer::GetPopupLinkNode(nsIDOMNode** aNode)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aNode);
     1: 
     1:   // you get null unless i say so
106838:   *aNode = nullptr;
     1: 
     1:   // find popup node
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   nsresult rv = GetPopupNode(getter_AddRefs(node));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // find out if we have a link in our ancestry
     1:   while (node) {
     1: 
 72415:     nsCOMPtr<nsIContent> content(do_QueryInterface(node));
 72415:     if (content) {
 72415:       nsCOMPtr<nsIURI> hrefURI = content->GetHrefURI();
 72415:       if (hrefURI) {
     1:         *aNode = node;
     1:         NS_IF_ADDREF(*aNode); // addref
     1:         return NS_OK;
     1:       }
 72415:     }
 72415: 
 72415:     // get our parent and keep trying...
     1:     nsCOMPtr<nsIDOMNode> parentNode;
     1:     node->GetParentNode(getter_AddRefs(parentNode));
     1:     node = parentNode;
     1:   }
     1: 
     1:   // if we have no node, fail
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: // GetPopupLinkNode: return popup image node or fail
     1: nsresult
124284: nsDocumentViewer::GetPopupImageNode(nsIImageLoadingContent** aNode)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aNode);
     1: 
     1:   // you get null unless i say so
106838:   *aNode = nullptr;
     1: 
     1:   // find popup node
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   nsresult rv = GetPopupNode(getter_AddRefs(node));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (node)
     1:     CallQueryInterface(node, aNode);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /*
     1:  * XXX dr
     1:  * ------
     1:  * These two functions -- GetInLink and GetInImage -- are kind of annoying
     1:  * in that they only get called from the controller (in
     1:  * nsDOMWindowController::IsCommandEnabled). The actual construction of the
     1:  * context menus in communicator (nsContextMenu.js) has its own, redundant
     1:  * tests. No big deal, but good to keep in mind if we ever clean context
     1:  * menus.
     1:  */
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetInLink(bool* aInLink)
     1: {
     1: #ifdef DEBUG_dr
124284:   printf("dr :: nsDocumentViewer::GetInLink\n");
     1: #endif
     1: 
     1:   NS_ENSURE_ARG_POINTER(aInLink);
     1: 
     1:   // we're not in a link unless i say so
 80486:   *aInLink = false;
     1: 
     1:   // get the popup link
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   nsresult rv = GetPopupLinkNode(getter_AddRefs(node));
     1:   if (NS_FAILED(rv)) return rv;
     1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
     1:   // if we made it here, we're in a link
 80486:   *aInLink = true;
     1:   return NS_OK;
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::GetInImage(bool* aInImage)
     1: {
     1: #ifdef DEBUG_dr
124284:   printf("dr :: nsDocumentViewer::GetInImage\n");
     1: #endif
     1: 
     1:   NS_ENSURE_ARG_POINTER(aInImage);
     1: 
     1:   // we're not in an image unless i say so
 80486:   *aInImage = false;
     1: 
     1:   // get the popup image
     1:   nsCOMPtr<nsIImageLoadingContent> node;
     1:   nsresult rv = GetPopupImageNode(getter_AddRefs(node));
     1:   if (NS_FAILED(rv)) return rv;
     1:   NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
     1: 
     1:   // if we made it here, we're in an image
 80486:   *aInImage = true;
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsDocViewerSelectionListener::NotifySelectionChanged(nsIDOMDocument *, nsISelection *, int16_t)
     1: {
     1:   NS_ASSERTION(mDocViewer, "Should have doc viewer!");
     1: 
     1:   // get the selection state
     1:   nsCOMPtr<nsISelection> selection;
     1:   nsresult rv = mDocViewer->GetDocumentSelection(getter_AddRefs(selection));
     1:   if (NS_FAILED(rv)) return rv;
     1: 
 79445:   bool selectionCollapsed;
     1:   selection->GetIsCollapsed(&selectionCollapsed);
     1:   // we only call UpdateCommands when the selection changes from collapsed
     1:   // to non-collapsed or vice versa. We might need another update string
     1:   // for simple selection changes, but that would be expenseive.
     1:   if (!mGotSelectionState || mSelectionWasCollapsed != selectionCollapsed)
     1:   {
 37433:     nsIDocument* theDoc = mDocViewer->GetDocument();
     1:     if (!theDoc) return NS_ERROR_FAILURE;
     1: 
     1:     nsPIDOMWindow *domWindow = theDoc->GetWindow();
     1:     if (!domWindow) return NS_ERROR_FAILURE;
     1: 
     1:     domWindow->UpdateCommands(NS_LITERAL_STRING("select"));
 80486:     mGotSelectionState = true;
     1:     mSelectionWasCollapsed = selectionCollapsed;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //nsDocViewerFocusListener
 72631: NS_IMPL_ISUPPORTS1(nsDocViewerFocusListener,
     1:                    nsIDOMEventListener)
     1: 
     1: nsDocViewerFocusListener::nsDocViewerFocusListener()
106838: :mDocViewer(nullptr)
     1: {
     1: }
     1: 
     1: nsDocViewerFocusListener::~nsDocViewerFocusListener(){}
     1: 
     1: nsresult
     1: nsDocViewerFocusListener::HandleEvent(nsIDOMEvent* aEvent)
     1: {
 72631:   NS_ENSURE_STATE(mDocViewer);
 72631: 
     1:   nsCOMPtr<nsIPresShell> shell;
 78878:   mDocViewer->GetPresShell(getter_AddRefs(shell));
 72631:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
 72631: 
 72631:   nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(shell);
108991:   int16_t selectionStatus;
     1:   selCon->GetDisplaySelection(&selectionStatus);
     1: 
 72631:   nsAutoString eventType;
 72631:   aEvent->GetType(eventType);
 72631:   if (eventType.EqualsLiteral("focus")) {
     1:     // If selection was disabled, re-enable it.
     1:     if(selectionStatus == nsISelectionController::SELECTION_DISABLED ||
 72631:        selectionStatus == nsISelectionController::SELECTION_HIDDEN) {
     1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
     1:       selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
     1:     }
 72631:   } else {
 72631:     NS_ABORT_IF_FALSE(eventType.EqualsLiteral("blur"),
 72631:                       "Unexpected event type");
     1:     // If selection was on, disable it.
     1:     if(selectionStatus == nsISelectionController::SELECTION_ON ||
 72631:        selectionStatus == nsISelectionController::SELECTION_ATTENTION) {
     1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_DISABLED);
     1:       selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
     1:     }
 72631:   }
 72631: 
 72631:   return NS_OK;
 72631: }
     1: 
     1: nsresult
124284: nsDocViewerFocusListener::Init(nsDocumentViewer *aDocViewer)
     1: {
     1:   mDocViewer = aDocViewer;
     1:   return NS_OK;
     1: }
     1: 
     1: /** ---------------------------------------------------
     1:  *  From nsIWebBrowserPrint
     1:  */
     1: 
     1: #ifdef NS_PRINTING
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Print(nsIPrintSettings*       aPrintSettings,
     1:                           nsIWebProgressListener* aWebProgressListener)
     1: {
     1: 
     1: #ifdef MOZ_XUL
     1:   // Temporary code for Bug 136185 / Bug 240490
     1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
     1:   if (xulDoc) {
     1:     nsPrintEngine::ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_NO_XUL);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: #endif
     1: 
 10495:   if (!mContainer) {
 10495:     PR_PL(("Container was destroyed yet we are still trying to use it!"));
 10495:     return NS_ERROR_FAILURE;
 10495:   }
 10495: 
     1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
 69583:   NS_ENSURE_STATE(docShell);
     1: 
     1:   // Check to see if this document is still busy
     1:   // If it is busy and we aren't already "queued" up to print then
     1:   // Indicate there is a print pending and cache the args for later
108991:   uint32_t busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
     1:   if ((NS_FAILED(docShell->GetBusyFlags(&busyFlags)) ||
     1:        (busyFlags != nsIDocShell::BUSY_FLAGS_NONE && busyFlags & nsIDocShell::BUSY_FLAGS_PAGE_LOADING)) && 
     1:       !mPrintDocIsFullyLoaded) {
     1:     if (!mPrintIsPending) {
     1:       mCachedPrintSettings           = aPrintSettings;
     1:       mCachedPrintWebProgressListner = aWebProgressListener;
 80486:       mPrintIsPending                = true;
     1:     }
     1:     PR_PL(("Printing Stopped - document is still busy!"));
     1:     return NS_ERROR_GFX_PRINTER_DOC_IS_BUSY;
     1:   }
     1: 
 82411:   if (!mDocument || !mDeviceContext) {
 82498:     PR_PL(("Can't Print without a document and a device context"));
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   nsresult rv;
     1: 
     1:   // if we are printing another URL, then exit
     1:   // the reason we check here is because this method can be called while
     1:   // another is still in here (the printing dialog is a good example).
     1:   // the only time we can print more than one job at a time is the regression tests
     1:   if (GetIsPrinting()) {
     1:     // Let the user know we are not ready to print.
     1:     rv = NS_ERROR_NOT_AVAILABLE;
     1:     nsPrintEngine::ShowPrintErrorDialog(rv);
     1:     return rv;
     1:   }
     1: 
111090:   nsAutoPtr<nsPrintEventDispatcher> beforeAndAfterPrint(
111090:     new nsPrintEventDispatcher(mDocument));
 73433:   NS_ENSURE_STATE(!GetIsPrinting());
     1:   // If we are hosting a full-page plugin, tell it to print
     1:   // first. It shows its own native print UI.
     1:   nsCOMPtr<nsIPluginDocument> pDoc(do_QueryInterface(mDocument));
     1:   if (pDoc)
     1:     return pDoc->Print();
     1: 
     1:   if (!mPrintEngine) {
 72850:     NS_ENSURE_STATE(mDeviceContext);
     1:     mPrintEngine = new nsPrintEngine();
     1: 
 69583:     rv = mPrintEngine->Initialize(this, mContainer, mDocument, 
 50791:                                   float(mDeviceContext->AppUnitsPerCSSInch()) /
 31784:                                   float(mDeviceContext->AppUnitsPerDevPixel()) /
 31784:                                   mPageZoom,
102909: #ifdef DEBUG
     1:                                   mDebugFile
     1: #else
106838:                                   nullptr
     1: #endif
     1:                                   );
     1:     if (NS_FAILED(rv)) {
     1:       mPrintEngine->Destroy();
106838:       mPrintEngine = nullptr;
     1:       return rv;
     1:     }
     1:   }
111090:   if (mPrintEngine->HasPrintCallbackCanvas()) {
111090:     mBeforeAndAfterPrint = beforeAndAfterPrint;
111090:   }
130807:   dom::Element* root = mDocument->GetRootElement();
130807:   if (root && root->HasAttr(kNameSpaceID_None, nsGkAtoms::mozdisallowselectionprint)) {
130807:     mPrintEngine->SetDisallowSelectionPrint(true);
130807:   }
133678:   if (root && root->HasAttr(kNameSpaceID_None, nsGkAtoms::moznomarginboxes)) {
133678:     mPrintEngine->SetNoMarginBoxes(true);
133678:   }
     1:   rv = mPrintEngine->Print(aPrintSettings, aWebProgressListener);
     1:   if (NS_FAILED(rv)) {
     1:     OnDonePrinting();
     1:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
124284: nsDocumentViewer::PrintPreview(nsIPrintSettings* aPrintSettings, 
     1:                                  nsIDOMWindow *aChildDOMWin, 
     1:                                  nsIWebProgressListener* aWebProgressListener)
     1: {
     1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
 35581:   NS_WARN_IF_FALSE(IsInitializedForPrintPreview(),
 35581:                    "Using docshell.printPreview is the preferred way for print previewing!");
 35581: 
 35581:   NS_ENSURE_ARG_POINTER(aChildDOMWin);
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (GetIsPrinting()) {
     1:     nsPrintEngine::CloseProgressDialog(aWebProgressListener);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1: #ifdef MOZ_XUL
     1:   // Temporary code for Bug 136185 / Bug 240490
     1:   nsCOMPtr<nsIXULDocument> xulDoc(do_QueryInterface(mDocument));
     1:   if (xulDoc) {
     1:     nsPrintEngine::CloseProgressDialog(aWebProgressListener);
 80486:     nsPrintEngine::ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_NO_XUL, false);
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: #endif
     1: 
     1:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
 51637:   if (!docShell || !mDeviceContext) {
 51637:     PR_PL(("Can't Print Preview without device context and docshell"));
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 35581:   nsCOMPtr<nsIDOMDocument> domDoc;
 35581:   aChildDOMWin->GetDocument(getter_AddRefs(domDoc));
 35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
 35581:   NS_ENSURE_STATE(doc);
 35581: 
111090:   nsAutoPtr<nsPrintEventDispatcher> beforeAndAfterPrint(
111090:     new nsPrintEventDispatcher(doc));
 73433:   NS_ENSURE_STATE(!GetIsPrinting());
 69880:   if (!mPrintEngine) {
     1:     mPrintEngine = new nsPrintEngine();
     1: 
 69583:     rv = mPrintEngine->Initialize(this, mContainer, doc,
 50791:                                   float(mDeviceContext->AppUnitsPerCSSInch()) /
 31784:                                   float(mDeviceContext->AppUnitsPerDevPixel()) /
 31784:                                   mPageZoom,
102909: #ifdef DEBUG
     1:                                   mDebugFile
     1: #else
106838:                                   nullptr
     1: #endif
     1:                                   );
     1:     if (NS_FAILED(rv)) {
     1:       mPrintEngine->Destroy();
106838:       mPrintEngine = nullptr;
     1:       return rv;
     1:     }
     1:   }
111090:   if (mPrintEngine->HasPrintCallbackCanvas()) {
111090:     mBeforeAndAfterPrint = beforeAndAfterPrint;
111090:   }
     1:   rv = mPrintEngine->PrintPreview(aPrintSettings, aChildDOMWin, aWebProgressListener);
 80486:   mPrintPreviewZoomed = false;
     1:   if (NS_FAILED(rv)) {
     1:     OnDonePrinting();
     1:   }
     1:   return rv;
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: NS_IMETHODIMP
124284: nsDocumentViewer::PrintPreviewNavigate(int16_t aType, int32_t aPageNum)
     1: {
     1:   if (!GetIsPrintPreview() ||
     1:       mPrintEngine->GetIsCreatingPrintPreview())
     1:     return NS_ERROR_FAILURE;
     1: 
 37067:   nsIScrollableFrame* sf =
 37067:     mPrintEngine->GetPrintPreviewPresShell()->GetRootScrollFrameAsScrollable();
 37067:   if (!sf)
     1:     return NS_OK;
     1: 
     1:   // Check to see if we can short circut scrolling to the top
     1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_HOME ||
     1:       (aType == nsIWebBrowserPrint::PRINTPREVIEW_GOTO_PAGENUM && aPageNum == 1)) {
 37067:     sf->ScrollTo(nsPoint(0, 0), nsIScrollableFrame::INSTANT);
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Finds the SimplePageSequencer frame
     1:   // in PP mPrtPreview->mPrintObject->mSeqFrame is null
106838:   nsIFrame* seqFrame  = nullptr;
108991:   int32_t   pageCount = 0;
     1:   if (NS_FAILED(mPrintEngine->GetSeqFrameAndCountPages(seqFrame, pageCount))) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // Figure where we are currently scrolled to
 37067:   nsPoint pt = sf->GetScrollPosition();
     1: 
108991:   int32_t    pageNum = 1;
106838:   nsIFrame * fndPageFrame  = nullptr;
106838:   nsIFrame * currentPage   = nullptr;
     1: 
     1:   // If it is "End" then just do a "goto" to the last page
     1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_END) {
     1:     aType    = nsIWebBrowserPrint::PRINTPREVIEW_GOTO_PAGENUM;
     1:     aPageNum = pageCount;
     1:   }
     1: 
     1:   // Now, locate the current page we are on and
     1:   // and the page of the page number
 77154:   nsIFrame* pageFrame = seqFrame->GetFirstPrincipalChild();
106838:   while (pageFrame != nullptr) {
     1:     nsRect pageRect = pageFrame->GetRect();
 37067:     if (pageRect.Contains(pageRect.x, pt.y)) {
     1:       currentPage = pageFrame;
     1:     }
     1:     if (pageNum == aPageNum) {
     1:       fndPageFrame = pageFrame;
     1:       break;
     1:     }
     1:     pageNum++;
     1:     pageFrame = pageFrame->GetNextSibling();
     1:   }
     1: 
     1:   if (aType == nsIWebBrowserPrint::PRINTPREVIEW_PREV_PAGE) {
     1:     if (currentPage) {
     1:       fndPageFrame = currentPage->GetPrevInFlow();
     1:       if (!fndPageFrame) {
     1:         return NS_OK;
     1:       }
     1:     } else {
     1:       return NS_OK;
     1:     }
     1:   } else if (aType == nsIWebBrowserPrint::PRINTPREVIEW_NEXT_PAGE) {
     1:     if (currentPage) {
     1:       fndPageFrame = currentPage->GetNextInFlow();
     1:       if (!fndPageFrame) {
     1:         return NS_OK;
     1:       }
     1:     } else {
     1:       return NS_OK;
     1:     }
     1:   } else { // If we get here we are doing "GoTo"
     1:     if (aPageNum < 0 || aPageNum > pageCount) {
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
 37067:   if (fndPageFrame) {
 10937:     nscoord newYPosn =
 71581:       nscoord(mPrintEngine->GetPrintPreviewScale() * fndPageFrame->GetPosition().y);
 37067:     sf->ScrollTo(nsPoint(pt.x, newYPosn), nsIScrollableFrame::INSTANT);
     1:   }
     1:   return NS_OK;
     1: 
     1: }
     1: 
     1: /* readonly attribute nsIPrintSettings globalPrintSettings; */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetGlobalPrintSettings(nsIPrintSettings * *aGlobalPrintSettings)
     1: {
     1:   return nsPrintEngine::GetGlobalPrintSettings(aGlobalPrintSettings);
     1: }
     1: 
     1: /* readonly attribute boolean doingPrint; */
 80486: // XXX This always returns false for subdocuments
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetDoingPrint(bool *aDoingPrint)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDoingPrint);
     1:   
 80486:   *aDoingPrint = false;
     1:   if (mPrintEngine) {
     1:     // XXX shouldn't this be GetDoingPrint() ?
     1:     return mPrintEngine->GetDoingPrintPreview(aDoingPrint);
     1:   } 
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute boolean doingPrintPreview; */
 80486: // XXX This always returns false for subdocuments
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetDoingPrintPreview(bool *aDoingPrintPreview)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDoingPrintPreview);
     1: 
 80486:   *aDoingPrintPreview = false;
     1:   if (mPrintEngine) {
     1:     return mPrintEngine->GetDoingPrintPreview(aDoingPrintPreview);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsIPrintSettings currentPrintSettings; */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetCurrentPrintSettings(nsIPrintSettings * *aCurrentPrintSettings)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aCurrentPrintSettings);
     1: 
106838:   *aCurrentPrintSettings = nullptr;
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->GetCurrentPrintSettings(aCurrentPrintSettings);
     1: }
     1: 
     1: 
     1: /* readonly attribute nsIDOMWindow currentChildDOMWindow; */
     1: NS_IMETHODIMP 
124284: nsDocumentViewer::GetCurrentChildDOMWindow(nsIDOMWindow * *aCurrentChildDOMWindow)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aCurrentChildDOMWindow);
106838:   *aCurrentChildDOMWindow = nullptr;
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* void cancel (); */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::Cancel()
     1: {
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1:   return mPrintEngine->Cancelled();
     1: }
     1: 
     1: /* void exitPrintPreview (); */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::ExitPrintPreview()
     1: {
 33890:   if (GetIsPrinting())
 33890:     return NS_ERROR_FAILURE;
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   if (GetIsPrintPreview()) {
     1:     ReturnToGalleyPresentation();
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: // Enumerate all the documents for their titles
     1: NS_IMETHODIMP
124284: nsDocumentViewer::EnumerateDocumentNames(uint32_t* aCount,
     1:                                            PRUnichar*** aResult)
     1: {
     1: #ifdef NS_PRINTING
     1:   NS_ENSURE_ARG(aCount);
     1:   NS_ENSURE_ARG_POINTER(aResult);
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->EnumerateDocumentNames(aCount, aResult);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: /* readonly attribute boolean isFramesetFrameSelected; */
     1: NS_IMETHODIMP 
124284: nsDocumentViewer::GetIsFramesetFrameSelected(bool *aIsFramesetFrameSelected)
     1: {
     1: #ifdef NS_PRINTING
 80486:   *aIsFramesetFrameSelected = false;
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->GetIsFramesetFrameSelected(aIsFramesetFrameSelected);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: /* readonly attribute long printPreviewNumPages; */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetPrintPreviewNumPages(int32_t *aPrintPreviewNumPages)
     1: {
     1: #ifdef NS_PRINTING
     1:   NS_ENSURE_ARG_POINTER(aPrintPreviewNumPages);
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->GetPrintPreviewNumPages(aPrintPreviewNumPages);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: /* readonly attribute boolean isFramesetDocument; */
     1: NS_IMETHODIMP
124284: nsDocumentViewer::GetIsFramesetDocument(bool *aIsFramesetDocument)
     1: {
     1: #ifdef NS_PRINTING
 80486:   *aIsFramesetDocument = false;
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->GetIsFramesetDocument(aIsFramesetDocument);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: /* readonly attribute boolean isIFrameSelected; */
     1: NS_IMETHODIMP 
124284: nsDocumentViewer::GetIsIFrameSelected(bool *aIsIFrameSelected)
     1: {
     1: #ifdef NS_PRINTING
 80486:   *aIsIFrameSelected = false;
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->GetIsIFrameSelected(aIsIFrameSelected);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: /* readonly attribute boolean isRangeSelection; */
     1: NS_IMETHODIMP 
124284: nsDocumentViewer::GetIsRangeSelection(bool *aIsRangeSelection)
     1: {
     1: #ifdef NS_PRINTING
 80486:   *aIsRangeSelection = false;
     1:   NS_ENSURE_TRUE(mPrintEngine, NS_ERROR_FAILURE);
     1: 
     1:   return mPrintEngine->GetIsRangeSelection(aIsRangeSelection);
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: // Printing/Print Preview Helpers
     1: //----------------------------------------------------------------------------------
     1: 
     1: //----------------------------------------------------------------------------------
     1: // Walks the document tree and tells each DocShell whether Printing/PP is happening
     1: void 
124284: nsDocumentViewer::SetIsPrintingInDocShellTree(nsIDocShellTreeNode* aParentNode, 
 79445:                                                 bool                 aIsPrintingOrPP, 
 79445:                                                 bool                 aStartAtTop)
     1: {
     1:   nsCOMPtr<nsIDocShellTreeItem> parentItem(do_QueryInterface(aParentNode));
     1: 
     1:   // find top of "same parent" tree
     1:   if (aStartAtTop) {
 63709:     if (aIsPrintingOrPP) {
     1:       while (parentItem) {
     1:         nsCOMPtr<nsIDocShellTreeItem> parent;
     1:         parentItem->GetSameTypeParent(getter_AddRefs(parent));
     1:         if (!parent) {
     1:           break;
     1:         }
     1:         parentItem = do_QueryInterface(parent);
     1:       }
 63709:       mTopContainerWhilePrinting = do_GetWeakReference(parentItem);
 63709:     } else {
 63709:       parentItem = do_QueryReferent(mTopContainerWhilePrinting);
 63709:     }
 63709:   }
     1: 
     1:   // Check to see if the DocShell's ContentViewer is printing/PP
     1:   nsCOMPtr<nsIContentViewerContainer> viewerContainer(do_QueryInterface(parentItem));
     1:   if (viewerContainer) {
     1:     viewerContainer->SetIsPrinting(aIsPrintingOrPP);
     1:   }
     1: 
 63709:   if (!aParentNode) {
 63709:     return;
 63709:   }
 63709: 
     1:   // Traverse children to see if any of them are printing.
108991:   int32_t n;
     1:   aParentNode->GetChildCount(&n);
108991:   for (int32_t i=0; i < n; i++) {
     1:     nsCOMPtr<nsIDocShellTreeItem> child;
     1:     aParentNode->GetChildAt(i, getter_AddRefs(child));
     1:     nsCOMPtr<nsIDocShellTreeNode> childAsNode(do_QueryInterface(child));
     1:     NS_ASSERTION(childAsNode, "child isn't nsIDocShellTreeNode");
     1:     if (childAsNode) {
 80486:       SetIsPrintingInDocShellTree(childAsNode, aIsPrintingOrPP, false);
     1:     }
     1:   }
     1: 
     1: }
     1: #endif // NS_PRINTING
     1: 
 79445: bool
124284: nsDocumentViewer::ShouldAttachToTopLevel()
 62248: {
 62248:   if (!mParentWidget)
 80486:     return false;
 62248: 
 62248:   nsCOMPtr<nsIDocShellTreeItem> containerItem = do_QueryReferent(mContainer);
 62248:   if (!containerItem)
 80486:     return false;
 62248: 
 62248:   // We always attach when using puppet widgets
 62248:   if (nsIWidget::UsePuppetWidgets())
 80486:     return true;
 62248: 
119753: #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
 62248:   // On windows, in the parent process we also attach, but just to
 62248:   // chrome items
108991:   int32_t docType;
 62248:   nsWindowType winType;
 62248:   containerItem->GetItemType(&docType);
 62248:   mParentWidget->GetWindowType(winType);
 62248:   if ((winType == eWindowType_toplevel ||
 62248:        winType == eWindowType_dialog ||
 62248:        winType == eWindowType_invisible) &&
 62248:       docType == nsIDocShellTreeItem::typeChrome)
 80486:     return true;
 62248: #endif
 62248: 
 80486:   return false;
 62248: }
 62248: 
 79445: bool CollectDocuments(nsIDocument* aDocument, void* aData)
 69880: {
 69880:   if (aDocument) {
 69880:     static_cast<nsCOMArray<nsIDocument>*>(aData)->AppendObject(aDocument);
 69880:     aDocument->EnumerateSubDocuments(CollectDocuments, aData);
 69880:   }
 80486:   return true;
 69880: }
 69880: 
 69880: void
124284: nsDocumentViewer::DispatchEventToWindowTree(nsIDocument* aDoc,
 69880:                                               const nsAString& aEvent)
 69880: {
 69880:   nsCOMArray<nsIDocument> targets;
 69880:   CollectDocuments(aDoc, &targets);
108991:   for (int32_t i = 0; i < targets.Count(); ++i) {
 69880:     nsIDocument* d = targets[i];
 69880:     nsContentUtils::DispatchTrustedEvent(d, d->GetWindow(),
106838:                                          aEvent, false, false, nullptr);
 69880:   }
 69880: }
 69880: 
     1: //------------------------------------------------------------
 80486: // XXX this always returns false for subdocuments
 79445: bool
124284: nsDocumentViewer::GetIsPrinting()
     1: {
     1: #ifdef NS_PRINTING
     1:   if (mPrintEngine) {
     1:     return mPrintEngine->GetIsPrinting();
     1:   }
     1: #endif
 80486:   return false; 
     1: }
     1: 
     1: //------------------------------------------------------------
     1: // Notification from the PrintEngine of the current Printing status
     1: void
124284: nsDocumentViewer::SetIsPrinting(bool aIsPrinting)
     1: {
     1: #ifdef NS_PRINTING
     1:   // Set all the docShells in the docshell tree to be printing.
     1:   // that way if anyone of them tries to "navigate" it can't
     1:   nsCOMPtr<nsIDocShellTreeNode> docShellTreeNode(do_QueryReferent(mContainer));
 63709:   if (docShellTreeNode || !aIsPrinting) {
 80486:     SetIsPrintingInDocShellTree(docShellTreeNode, aIsPrinting, true);
 39324:   } else {
 63709:     NS_WARNING("Did you close a window before printing?");
     1:   }
111090: 
111090:   if (!aIsPrinting) {
111090:     mBeforeAndAfterPrint = nullptr;
111090:   }
     1: #endif
     1: }
     1: 
     1: //------------------------------------------------------------
     1: // The PrintEngine holds the current value
     1: // this called from inside the DocViewer.
 80486: // XXX it always returns false for subdocuments
 79445: bool
124284: nsDocumentViewer::GetIsPrintPreview()
     1: {
     1: #ifdef NS_PRINTING
     1:   if (mPrintEngine) {
     1:     return mPrintEngine->GetIsPrintPreview();
     1:   }
     1: #endif
 80486:   return false; 
     1: }
     1: 
     1: //------------------------------------------------------------
     1: // Notification from the PrintEngine of the current PP status
     1: void
124284: nsDocumentViewer::SetIsPrintPreview(bool aIsPrintPreview)
     1: {
     1: #ifdef NS_PRINTING
     1:   // Set all the docShells in the docshell tree to be printing.
     1:   // that way if anyone of them tries to "navigate" it can't
     1:   nsCOMPtr<nsIDocShellTreeNode> docShellTreeNode(do_QueryReferent(mContainer));
 63709:   if (docShellTreeNode || !aIsPrintPreview) {
 80486:     SetIsPrintingInDocShellTree(docShellTreeNode, aIsPrintPreview, true);
     1:   }
111090:   if (!aIsPrintPreview) {
111090:     mBeforeAndAfterPrint = nullptr;
111090:   }
     1: #endif
 35581:   if (!aIsPrintPreview) {
 38057:     if (mPresShell) {
 38057:       DestroyPresShell();
 38057:     }
106838:     mWindow = nullptr;
106838:     mViewManager = nullptr;
106838:     mPresContext = nullptr;
106838:     mPresShell = nullptr;
 35581:   }
     1: }
     1: 
     1: //----------------------------------------------------------------------------------
     1: // nsIDocumentViewerPrint IFace
     1: //----------------------------------------------------------------------------------
     1: 
     1: //------------------------------------------------------------
     1: void
124284: nsDocumentViewer::IncrementDestroyRefCount()
     1: {
     1:   ++mDestroyRefCount;
     1: }
     1: 
     1: //------------------------------------------------------------
     1: 
     1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
     1: //------------------------------------------------------------
     1: // Reset ESM focus for all descendent doc shells.
     1: static void
     1: ResetFocusState(nsIDocShell* aDocShell)
     1: {
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (!fm)
 29018:     return;
 29018: 
     1:   nsCOMPtr<nsISimpleEnumerator> docShellEnumerator;
     1:   aDocShell->GetDocShellEnumerator(nsIDocShellTreeItem::typeContent,
     1:                                    nsIDocShell::ENUMERATE_FORWARDS,
     1:                                    getter_AddRefs(docShellEnumerator));
     1:   
     1:   nsCOMPtr<nsISupports> currentContainer;
 79445:   bool hasMoreDocShells;
     1:   while (NS_SUCCEEDED(docShellEnumerator->HasMoreElements(&hasMoreDocShells))
     1:          && hasMoreDocShells) {
     1:     docShellEnumerator->GetNext(getter_AddRefs(currentContainer));
 29018:     nsCOMPtr<nsIDOMWindow> win = do_GetInterface(currentContainer);
 29018:     if (win)
 29018:       fm->ClearFocus(win);
     1:   }
     1: }
121210: #endif // NS_PRINTING && NS_PRINT_PREVIEW
121210: 
121210: void
124284: nsDocumentViewer::ReturnToGalleyPresentation()
121210: {
121210: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
121210:   if (!GetIsPrintPreview()) {
121210:     NS_ERROR("Wow, we should never get here!");
121210:     return;
121210:   }
121210: 
121210:   SetIsPrintPreview(false);
121210: 
121210:   mPrintEngine->TurnScriptingOn(true);
121210:   mPrintEngine->Destroy();
121210:   mPrintEngine = nullptr;
121210: 
121210:   nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mContainer));
121210:   ResetFocusState(docShell);
121210: 
121210:   SetTextZoom(mTextZoom);
121210:   SetFullZoom(mPageZoom);
121210:   SetMinFontSize(mMinFontSize);
121210:   Show();
121210: 
121210: #endif // NS_PRINTING && NS_PRINT_PREVIEW
121210: }
     1: 
     1: //------------------------------------------------------------
     1: // This called ONLY when printing has completed and the DV
     1: // is being notified that it should get rid of the PrintEngine.
     1: //
     1: // BUT, if we are in Print Preview then we want to ignore the 
     1: // notification (we do not get rid of the PrintEngine)
     1: // 
     1: // One small caveat: 
     1: //   This IS called from two places in this module for cleaning
     1: //   up when an error occurred during the start up printing 
     1: //   and print preview
     1: //
     1: void
124284: nsDocumentViewer::OnDonePrinting() 
     1: {
     1: #if defined(NS_PRINTING) && defined(NS_PRINT_PREVIEW)
     1:   if (mPrintEngine) {
129621:     nsRefPtr<nsPrintEngine> pe = mPrintEngine;
     1:     if (GetIsPrintPreview()) {
129621:       pe->DestroyPrintingData();
     1:     } else {
130043:       mPrintEngine = nullptr;
129621:       pe->Destroy();
     1:     }
     1: 
     1:     // We are done printing, now cleanup 
     1:     if (mDeferredWindowClose) {
 80486:       mDeferredWindowClose = false;
     1:       nsCOMPtr<nsISupports> container = do_QueryReferent(mContainer);
 73870:       nsCOMPtr<nsIDOMWindow> win = do_GetInterface(container);
     1:       if (win)
     1:         win->Close();
     1:     } else if (mClosingWhilePrinting) {
     1:       if (mDocument) {
106838:         mDocument->SetScriptGlobalObject(nullptr);
     1:         mDocument->Destroy();
106838:         mDocument = nullptr;
     1:       }
 80486:       mClosingWhilePrinting = false;
     1:     }
     1:   }
     1: #endif // NS_PRINTING && NS_PRINT_PREVIEW
     1: }
     1: 
124284: NS_IMETHODIMP nsDocumentViewer::SetPageMode(bool aPageMode, nsIPrintSettings* aPrintSettings)
     1: {
     1:   // XXX Page mode is only partially working; it's currently used for
     1:   // reftests that require a paginated context
     1:   mIsPageMode = aPageMode;
     1: 
     1:   if (mPresShell) {
 23902:     DestroyPresShell();
     1:   }
     1: 
     1:   if (mPresContext) {
 61100:     DestroyPresContext();
 61100:   }
 61100: 
106838:   mViewManager  = nullptr;
106838:   mWindow       = nullptr;
     1: 
     1:   NS_ENSURE_STATE(mDocument);
     1:   if (aPageMode)
     1:   {    
 30514:     mPresContext = CreatePresContext(mDocument,
 30514:         nsPresContext::eContext_PageLayout, FindContainerView());
     1:     NS_ENSURE_TRUE(mPresContext, NS_ERROR_OUT_OF_MEMORY);
 80486:     mPresContext->SetPaginatedScrolling(true);
     1:     mPresContext->SetPrintSettings(aPrintSettings);
     1:     nsresult rv = mPresContext->Init(mDeviceContext);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
106838:   InitInternal(mParentWidget, nullptr, mBounds, true, false);
     1: 
     1:   Show();
     1:   return NS_OK;
     1: }
  6685: 
  6685: NS_IMETHODIMP
124284: nsDocumentViewer::GetHistoryEntry(nsISHEntry **aHistoryEntry)
  6685: {
  6685:   NS_IF_ADDREF(*aHistoryEntry = mSHEntry);
  6685:   return NS_OK;
  6685: }
 23902: 
 62631: NS_IMETHODIMP
124284: nsDocumentViewer::GetIsTabModalPromptAllowed(bool *aAllowed)
 62631: {
 62631:   *aAllowed = !(mInPermitUnload || mHidden);
 62631:   return NS_OK;
 62631: }
 62631: 
108233: NS_IMETHODIMP
124284: nsDocumentViewer::GetIsHidden(bool *aHidden)
108233: {
108233:   *aHidden = mHidden;
108233:   return NS_OK;
108233: }
108233: 
 23902: void
124284: nsDocumentViewer::DestroyPresShell()
 23902: {
 23902:   // Break circular reference (or something)
 23902:   mPresShell->EndObservingDocument();
 23902: 
 23902:   nsCOMPtr<nsISelection> selection;
 23902:   GetDocumentSelection(getter_AddRefs(selection));
 23902:   nsCOMPtr<nsISelectionPrivate> selPrivate = do_QueryInterface(selection);
 23902:   if (selPrivate && mSelectionListener)
 23902:     selPrivate->RemoveSelectionListener(mSelectionListener);
 23902: 
 28371:   nsAutoScriptBlocker scriptBlocker;
 23902:   mPresShell->Destroy();
106838:   mPresShell = nullptr;
 23902: }
 35581: 
 61100: void
124284: nsDocumentViewer::DestroyPresContext()
 61100: {
106838:   mPresContext->SetContainer(nullptr);
106838:   mPresContext->SetLinkHandler(nullptr);
106838:   mPresContext = nullptr;
 61100: }
 61100: 
 79445: bool
124284: nsDocumentViewer::IsInitializedForPrintPreview()
 35581: {
 35581:   return mInitializedForPrintPreview;
 35581: }
 35581: 
 35581: void
124284: nsDocumentViewer::InitializeForPrintPreview()
 35581: {
 80486:   mInitializedForPrintPreview = true;
 35581: }
 35581: 
 35581: void
127607: nsDocumentViewer::SetPrintPreviewPresentation(nsViewManager* aViewManager,
 35581:                                                 nsPresContext* aPresContext,
 35581:                                                 nsIPresShell* aPresShell)
 35581: {
 35581:   if (mPresShell) {
 35581:     DestroyPresShell();
 35581:   }
 35581: 
106838:   mWindow = nullptr;
 35581:   mViewManager = aViewManager;
 35581:   mPresContext = aPresContext;
 35581:   mPresShell = aPresShell;
 35581: }
 86797: 
 93070: // Fires the "document-shown" event so that interested parties are aware of it.
 93070: NS_IMETHODIMP
 86797: nsDocumentShownDispatcher::Run()
 86797: {
 86797:   nsCOMPtr<nsIObserverService> observerService =
 86797:     mozilla::services::GetObserverService();
 86797:   if (observerService) {
 86797:     observerService->NotifyObservers(mDocument, "document-shown", NULL);
 86797:   }
 86797:   return NS_OK;
 86797: }
 86797: 
